
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x00054e28 memsz 0x0006f094 flags rwx
    LOAD off    0x00056000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00056000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004cef8  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00005f00  8114d154  8114d154  0004e154  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  81153054  81153054  00054054  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a26c  81154e48  81154e48  00055e48  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  8116f0b4  8116f0b4  00056000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00056000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00056000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d78  00000000  00000000  00056028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0007286e  00000000  00000000  00057da0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0001699d  00000000  00000000  000ca60e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000233c1  00000000  00000000  000e0fab  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00009a5c  00000000  00000000  0010436c  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000cc81  00000000  00000000  0010ddc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ee0  00000000  00000000  0011aa49  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0014192c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000023a0  00000000  00000000  00141970  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  00150231  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  00150237  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00150243  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00150244  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00150245  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00150249  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  0015024d  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  00150251  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  0015025c  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  00150266  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  00150270  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  00150281  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00226f57  00000000  00000000  001502c0  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
8114d154 l    d  .rodata	00000000 .rodata
81153054 l    d  .rwdata	00000000 .rwdata
81154e48 l    d  .bss	00000000 .bss
8116f0b4 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
811048bc l     F .text	00000050 uliCommReadReg
81104868 l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
81105208 l     F .text	00000050 uliDpktReadReg
811051b4 l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
81154e6c l     O .bss	00000004 viCh1HoldContext
81154e70 l     O .bss	00000004 viCh2HoldContext
81154e74 l     O .bss	00000004 viCh3HoldContext
81154e78 l     O .bss	00000004 viCh4HoldContext
81154e7c l     O .bss	00000004 viCh5HoldContext
81154e80 l     O .bss	00000004 viCh6HoldContext
81154e84 l     O .bss	00000004 viCh7HoldContext
81154e88 l     O .bss	00000004 viCh8HoldContext
8110700c l     F .text	00000054 vFeebWriteReg
81107060 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
81154e8c l     O .bss	00000004 viCh1HoldContext
81154e90 l     O .bss	00000004 viCh2HoldContext
81154e94 l     O .bss	00000004 viCh3HoldContext
81154e98 l     O .bss	00000004 viCh4HoldContext
81154e9c l     O .bss	00000004 viCh5HoldContext
81154ea0 l     O .bss	00000004 viCh6HoldContext
81154ea4 l     O .bss	00000004 viCh7HoldContext
81154ea8 l     O .bss	00000004 viCh8HoldContext
8110a444 l     F .text	00000054 vRmapWriteReg
8110a4e8 l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
8110ae84 l     F .text	00000050 uliSpwcReadReg
8110ae30 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
81154d70 l     O .rwdata	00000001 ucIoValue
8110b084 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110b974 l     F .text	0000013c msgdma_write_extended_descriptor
8110bab0 l     F .text	00000164 msgdma_construct_extended_descriptor
8110bc14 l     F .text	00000348 msgdma_descriptor_async_transfer
8110bf5c l     F .text	00000490 msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110cb6c l     F .text	00000054 vRstcWriteReg
8110cbc0 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
81154eb0 l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
81154eb8 l     O .bss	00000004 pxNFee.5701
81154ebc l     O .bss	00000004 incrementador.5706
81154ec0 l     O .bss	00000004 tCodFeeTask.5704
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
81154ec6 l     O .bss	00000004 xRAckLocal.5631
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
81154ecc l     O .bss	00000004 bDmaBack.5672
81154ed0 l     O .bss	00000001 ucWhoGetDMA.5673
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
81154ed2 l     O .bss	00000004 xSAckLocal.5616
00000000 l    df *ABS*	00000000 parser_comm_task.c
8115504c l     O .bss	0000004c PreParsedLocal.5669
81155098 l     O .bss	00000054 xTcPusL.5668
00000000 l    df *ABS*	00000000 receiver_uart_task.c
811550ec l     O .bss	0000004c xPreParsedReader.5661
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
81155138 l     O .bss	00000054 xPusLocal.5904
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
81150965 l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 atoll.c
00000000 l    df *ABS*	00000000 ctype_.c
81152495 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
81153054 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
81124884 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 strtoll.c
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
81152662 l     O .rodata	00000010 zeroes.4389
81152672 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
81152682 l     O .rodata	00000010 zeroes.4404
81129800 l     F .text	000000c4 __sbprintf
81152692 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
811526aa l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
8112b4e8 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
8112d038 l     F .text	00000008 __fp_unlock
8112d04c l     F .text	000001a4 __sinit.part.1
8112d1f0 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
811538a0 l     O .rwdata	00000020 lc_ctype_charset
81153880 l     O .rwdata	00000020 lc_message_charset
811538c0 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
811526e8 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
81130060 l     F .text	0000006c sulp
81152830 l     O .rodata	00000014 fpi.2737
81152844 l     O .rodata	00000028 tinytens
8115281c l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
8115287c l     O .rodata	00000010 blanks.4332
8115286c l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
811333e8 l     F .text	00000104 __sprint_r.part.0
8115289c l     O .rodata	00000010 blanks.4348
8115288c l     O .rodata	00000010 zeroes.4349
81134984 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
81134e38 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
81138014 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
81138158 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
8113818c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
81138410 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
81138508 l       .text	00000000 tx_next_char
81138530 l       .text	00000000 end_tx
81138510 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
8113900c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
81139288 l     F .text	00000044 alt_get_errno
811392cc l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
811394f4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
81154db8 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
81139a94 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
81154dc4 l     O .rwdata	00000004 lockid
81154f94 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
81154dc8 l     O .rwdata	00000004 lockid
81154f9c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
8113b520 l     F .text	00000050 OS_InitMisc
8113b570 l     F .text	00000074 OS_InitRdyList
8113b6f4 l     F .text	000000ec OS_InitTCBList
8113b438 l     F .text	000000e8 OS_InitEventList
8113b5e4 l     F .text	00000088 OS_InitTaskIdle
8113b66c l     F .text	00000088 OS_InitTaskStat
8113b984 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
8113d79c l     F .text	000000fc OS_FlagTaskRdy
8113d54c l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
8113f088 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
81143ab8 l     F .text	00000044 OSTmr_Lock
81143558 l     F .text	00000074 OSTmr_Alloc
81143afc l     F .text	0000003c OSTmr_Unlock
811439bc l     F .text	000000fc OSTmr_Unlink
811435cc l     F .text	000000a4 OSTmr_Free
8114386c l     F .text	00000150 OSTmr_Link
811437e4 l     F .text	00000088 OSTmr_InitTask
81143b38 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
81143c48 l     F .text	0000003c alt_dev_reg
81153b3c l     O .rwdata	0000106c jtag_uart_0
81154ba8 l     O .rwdata	000000d0 rs232_uart
81154c78 l     O .rwdata	00000064 dma_DDR_M1
81154cdc l     O .rwdata	00000064 dma_DDR_M2
81154d40 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
811484d8 l     F .text	000002bc altera_avalon_jtag_uart_irq
81148794 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81148f98 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
81149330 l     F .text	000000a4 altera_avalon_uart_irq
811493d4 l     F .text	00000140 altera_avalon_uart_rxirq
81149514 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
8114971c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
811499d0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
81149c54 l     F .text	00000044 alt_get_errno
81149c98 l     F .text	0000009c alt_msgdma_write_standard_descriptor
81149d34 l     F .text	00000134 alt_msgdma_write_extended_descriptor
81149e68 l     F .text	0000018c alt_msgdma_irq
81149ff4 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
8114a088 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
8114a1e4 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
8114a524 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
8114ac2c l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
8114acd8 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
8114bea4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
8114c4e8 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81155044 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
81155048 g     O .bss	00000004 alt_instruction_exception_handler
81107570 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
811558cc g     O .bss	00001000 vFeeTask0_stk
81106998 g     F .text	00000068 bFeebGetCh2LeftFeeBusy
8111d598 g     F .text	00000064 vFailDeleteInitialization
8111bbf4 g     F .text	00000ff4 vLoadDebugConfs
81155018 g     O .bss	00000004 aux_status_register
811568cc g     O .bss	00001000 vInAckHandlerTask_stk
8114bc60 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
811078b8 g     F .text	00000054 uliRmapCh1WriteCmdAddress
8110d208 g     F .text	0000004c vSyncInitIrq
811183c8 g     F .text	00000284 vCheckRetransmission128
8112f6e4 g     F .text	0000007c _mprec_log10
8111f09c g     F .text	0000006c vFailRequestDMAFromIRQ
8110d410 g     F .text	00000040 bSyncSetMbt
8110b268 g     F .text	00000108 I2C_Read
81154e16 g     O .rwdata	00000002 OSTaskNameSize
81154edc g     O .bss	00000004 xWaitSyncQFee
811578cc g     O .bss	00000260 xBuffer64
8112f7d8 g     F .text	0000008c __any_on
8112e1ac g     F .text	0000005c _isatty_r
811526f4 g     O .rodata	00000028 __mprec_tinytens
81107860 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
8113912c g     F .text	0000015c alt_main
811066b0 g     F .text	00000078 bFeebGetRightBufferEmpty
811247a8 g     F .text	000000c8 _puts_r
81105800 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
81154fa4 g     O .bss	00000004 OSTmrFreeList
8116efb4 g     O .bss	00000100 alt_irq
8112e31c g     F .text	00000068 _lseek_r
811204d8 g     F .text	00000030 vChangeDefaultAutoResetSync
8113dffc g     F .text	000000d4 OS_MemInit
8111f030 g     F .text	0000006c vFailRequestDMA
81106728 g     F .text	00000068 bFeebGetCh1LeftBufferEmpty
8111ae84 g     F .text	00000a40 vLoadDefaultETHConf
81113040 g     F .text	0000014c bCheckInAck64
81157b2c g     O .bss	00000150 xPus
81142a98 g     F .text	00000068 OSTimeSet
81116f6c g     F .text	000000ac vPusType250run
8112d3f0 g     F .text	000000ac __sflags
8111e884 g     F .text	00000080 vCoudlNotCreateNFee2Task
8111ed60 g     F .text	00000064 vCouldNotGetMutexMebPus
81137cb8 g     F .text	00000088 .hidden __eqdf2
81117708 g     F .text	00000088 vSendCmdQToDataCTRL
81102ae0 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
811203c4 g     F .text	00000034 vLoadDefaultSyncSource
8111ceb0 g     F .text	00000064 vFailCreateMutexDMA
81144148 g     F .text	000001ac Check_for_Master_Boot_Record
811689c8 g     O .bss	00000010 OSTmrWheelTbl
81107960 g     F .text	00000054 uliRmapCh3WriteCmdAddress
8114a9ec g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
81157c7c g     O .bss	00000020 xFeeQueueTBL3
8113a184 g     F .text	00000594 OSEventPendMulti
81154ee0 g     O .bss	00000004 xNfeeSchedule
8116f0b4 g       *ABS*	00000000 __alt_heap_start
8114cb20 g     F .text	0000002c OSTaskCreateHook
81147fc0 g     F .text	000001c4 alt_up_sd_card_fclose
81154ee4 g     O .bss	00000004 xSemCountBuffer64
811045b4 g     F .text	000001b8 bCommSetGlobalIrqEn
81107dcc g     F .text	00000088 bRmapGetIrqControl
81154ead g     O .bss	00000001 SspdConfigControl
8110d82c g     F .text	00000054 bSyncCtrReset
81154dee g     O .rwdata	00000002 OSMboxEn
81110fc0 g     F .text	00000584 vQCmdFeeRMAPWaitingSync
81120f64 g     F .text	000000a4 aatoh
8113a77c g     F .text	00000054 OSIntEnter
81135aa4 g     F .text	000000a4 _wcrtomb_r
8110570c g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
8111d4d0 g     F .text	00000064 vFailReceiverCreate
81154ee8 g     O .bss	00000004 xQMaskDataCtrl
811053a8 g     F .text	00000038 vFeebCh2HandleIrq
81124d10 g     F .text	00000064 __sseek
8112d3a0 g     F .text	00000010 __sinit
8110c4ac g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
8112b168 g     F .text	00000148 __swbuf_r
81118ba0 g     F .text	00000470 bResourcesInitRTOS
8110a96c g     F .text	000000f4 bSpwcGetLinkError
81154dfe g     O .rwdata	00000002 OSQEn
81110358 g     F .text	00000684 vQCmdFeeRMAPinStandBy
811072c0 g     F .text	00000038 vRmapCh4HandleIrq
8112e238 g     F .text	00000084 _setlocale_r
81157c9c g     O .bss	00000020 SyncTBL2
81154d74 g     O .rwdata	00000004 LedsPainelControl
811551b4 g     O .bss	00000100 cDebugBuffer
8112d1f8 g     F .text	00000070 __sfmoreglue
811333d0 g     F .text	00000018 ungetc
81105a10 g     F .text	000000e0 bFeebCh1SetBufferSize
81139e40 g     F .text	000000d4 __malloc_unlock
81102ddc g     F .text	00000214 DMA_MULTIPLE_TRANSFER
8114cba0 g     F .text	00000028 OSTaskStatHook
81117564 g     F .text	00000088 vSendCmdQToNFeeCTRL
81120434 g     F .text	00000030 vChangeDefaultSyncSource
81154fa8 g     O .bss	00000001 OSLockNesting
81154fac g     O .bss	00000004 OSTmrSemSignal
8111f5d0 g     F .text	00000284 vNFeeStructureInit
81154eec g     O .bss	00000004 xSemCommInit
81102964 g     F .text	00000080 uliXorshift32
811300cc g     F .text	00001600 _strtod_r
81154ef0 g     O .bss	00000004 xSemCountSenderACK
81121134 g     F .text	00000448 .hidden __divsf3
8115503c g     O .bss	00000004 current_sector_modified
81154e3c g     O .rwdata	00000002 OSDataSize
81154fb0 g     O .bss	00000001 OSRunning
8110ac4c g     F .text	000001e4 bSpwcInitCh
81138df4 g     F .text	00000064 alt_log_jtag_uart_isr_proc
81157cbc g     O .bss	00001000 senderTask_stk
8110890c g     F .text	00000094 bRmapGetMemConfigStat
81154ef4 g     O .bss	00000004 fp
81158cbc g     O .bss	00000048 xNfeeScheduleTBL
81112ef8 g     F .text	00000148 bCheckInAck128
8112e6ac g     F .text	0000015c memmove
8114cc1c g     F .text	0000002c OSInitHookBegin
8110dcc8 g     F .text	00000074 bSyncCtrCh8OutEnable
811116b0 g     F .text	00000098 bEnableDbBuffer
81154e34 g     O .rwdata	00000002 OSTmrSize
8112d388 g     F .text	00000018 _cleanup
811208f4 g     F .text	00000040 siCloseFile
81106e28 g     F .text	000001e4 bFeebInitCh
8112e808 g     F .text	000000b0 _Balloc
81120464 g     F .text	00000038 vLoadDefaultAutoResetSync
81107edc g     F .text	000000dc bRmapSetCodecConfig
81146b9c g     F .text	000000cc alt_up_sd_card_is_Present
8114a92c g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
81154e50 g     O .bss	00000004 pxDmaM1Dev
81102b78 g     F .text	000000a8 DMA_DISPATCHER_STOP
81143e70 g     F .text	00000054 Save_Modified_Sector
81105960 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
81154fb4 g     O .bss	00000004 OSIdleCtr
81154f70 g     O .bss	00000001 alt_log_write_on_flag
8110aed4 g     F .text	0000003c bEnableIsoDrivers
81121ba4 g     F .text	000000dc .hidden __gtdf2
8114c8b0 g     F .text	0000002c altera_nios2_gen2_irq_init
8114c998 g       .text	00000000 OSStartTsk
8110d584 g     F .text	00000070 bSyncSetNCycles
8113bcf4 g     F .text	000002dc OS_TCBInit
81154f73 g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
8112004c g     F .text	00000078 vInitSimucamBasicHW
81158d04 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110dbe0 g     F .text	00000074 bSyncCtrCh6OutEnable
8110b5e4 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
81155034 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
81154fb8 g     O .bss	00000002 OSTmrUsed
81154ef8 g     O .bss	00000004 xSemCountBuffer128
811032b8 g     F .text	000000f8 TEMP_Read
81107d20 g     F .text	000000ac bRmapSetIrqControl
81105d90 g     F .text	000000e0 bFeebCh5SetBufferSize
81159d04 g     O .bss	00001000 vDataControlTask_stk
81105418 g     F .text	00000038 vFeebCh4HandleIrq
81154e3a g     O .rwdata	00000002 OSTmrWheelTblSize
8111fcf4 g     F .text	0000002c cFeeSpwChannelDisable
81154dda g     O .rwdata	00000002 OSEventSize
81154fba g     O .bss	00000001 OSPrioHighRdy
81123804 g     F .text	00000064 _fstat_r
8114cb4c g     F .text	0000002c OSTaskDelHook
81154f4c g     O .bss	00000004 errno
8110dfbc g     F .text	0000003c uliSyncGetCtr
8112b0f8 g     F .text	0000001c __svfscanf
81124c84 g     F .text	00000008 __seofread
8114c978 g       .text	00000000 OSStartHighRdy
8111f530 g     F .text	00000028 vEvtChangeFeeControllerMode
811118fc g     F .text	00000968 vPrintConsoleNFee
81114020 g     F .text	000000c8 bSendCmdQToNFeeInst
81107368 g     F .text	00000038 vRmapCh7HandleIrq
811414c8 g     F .text	000001ec OSTaskCreateExt
8116899c g     O .bss	00000011 alt_log_write_buf
81104bb0 g     F .text	00000158 bDpktGetPacketConfig
81107b04 g     F .text	00000054 uliRmapCh8WriteCmdAddress
8111d97c g     F .text	00000080 vFailGetCountSemaphorePreParsedBuffer
81131f14 g     F .text	00001244 ___svfiprintf_internal_r
81115e08 g     F .text	0000037c bPreParserV2
8113d07c g     F .text	00000068 OSFlagPendGetFlagsRdy
81154e1a g     O .rwdata	00000002 OSTaskStatStkSize
81106860 g     F .text	00000068 bFeebGetCh2RightBufferEmpty
8113c1c8 g     F .text	00000310 OSFlagAccept
8113f7a4 g     F .text	000000c0 OSQFlush
811556b4 g     O .bss	00000118 xRmap
8113f220 g     F .text	00000148 OSQAccept
81154f84 g     O .bss	00000004 alt_argv
8115cd6c g       *ABS*	00000000 _gp
8111d0c0 g     F .text	00000064 vFailSendPreAckReceiverSemaphore
81139958 g     F .text	0000013c usleep
81147174 g     F .text	00000384 alt_up_sd_card_fopen
81120760 g     F .text	00000030 bSDcardIsPresent
81116184 g     F .text	00000210 vSenderComTask
81146cdc g     F .text	000000d8 alt_up_sd_card_find_first
81141314 g     F .text	000001b4 OSTaskCreate
8111db7c g     F .text	00000080 vFailSendNack
81155028 g     O .bss	00000004 command_argument_register
81140e1c g     F .text	000004f8 OSTaskChangePrio
81116a6c g     F .text	000000c4 vPusMebInTaskConfigMode
8111e4d4 g     F .text	000000a0 vCouldNotSendTMPusCommand
81154fa0 g     O .bss	00000004 alt_heapsem
8111fb94 g     F .text	000000b0 vResetMemCCDFEE
8110b87c g     F .text	00000080 bSetBoardLeds
8113bfd0 g     F .text	000001f8 OSDebugInit
811416b4 g     F .text	0000034c OSTaskDel
8113e0d0 g     F .text	000001ac OSMutexAccept
8115ad04 g     O .bss	000002c0 xSimMeb
8111ff30 g     F .text	00000040 vSetTimeCode
8114b4d4 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
81154efc g     O .bss	00000004 xSemCountPreParsed
81153920 g     O .rwdata	00000180 alt_fd_list
811058b0 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
81153abc g     O .rwdata	0000001d alt_log_msg_alt_main
811689d8 g     O .bss	00000840 OSFlagTbl
811075f8 g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
8111d288 g     F .text	00000080 vFailGetCountSemaphoreReceiverTask
81107a08 g     F .text	00000054 uliRmapCh5WriteCmdAddress
8112031c g     F .text	0000003c vLoadDefaultRTValue
8113b200 g     F .text	000000c0 OS_EventTaskRemove
8115afc4 g     O .bss	00001000 vFeeTask5_stk
81154f72 g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
811463f0 g     F .text	00000134 find_first_empty_record_in_root_directory
8114bf94 g     F .text	00000098 alt_find_dev
81124350 g     F .text	00000150 memcpy
81135770 g     F .text	00000264 __hexnan
81104fe4 g     F .text	000001d0 bDpktInitCh
8115bfc4 g     O .bss	00000160 xBuffer32
81154e04 g     O .rwdata	00000002 OSRdyTblSize
81169218 g     O .bss	000001a0 OSTmrTbl
8112d040 g     F .text	0000000c _cleanup_r
81122d24 g     F .text	000000e4 .hidden __floatsidf
8111aaac g     F .text	000001a8 vSendPusTM64
8110d380 g     F .text	0000004c ucSyncStatusErrorCode
81117674 g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8111fdf0 g     F .text	00000034 cFeeRMAPLogDisable
811144d8 g     F .text	00000fc0 vParserCommTask
8114c5b4 g     F .text	00000084 alt_io_redirect
8111fd84 g     F .text	00000034 cFeeRMAPEchoingDisable
81137d40 g     F .text	000000f4 .hidden __ltdf2
8111ec7c g     F .text	00000064 vFailSendPUStoMebTask
81107808 g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
811062d8 g     F .text	000000d8 bFeebSetIrqControl
8111e254 g     F .text	00000080 vCouldNotRetransmitB128TimeoutTask
81154f00 g     O .bss	00000004 xMutexReceivedACK
81103c40 g     F .text	000000c4 bSdmaInitM2Dma
81154e68 g     O .bss	00000004 EDpktMode
8114b95c g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
8114bca4 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110d8d4 g     F .text	00000054 bSyncCtrErrInj
8114bc04 g     F .text	0000005c alt_msgdma_register_callback
8111b8c4 g     F .text	00000330 vShowEthConfig
811200c4 g     F .text	00000030 bLogWriteSDCard
8111d67c g     F .text	00000080 vFailSetCountSemaphorexBuffer64
81124870 g     F .text	00000014 puts
81120974 g     F .text	000001b8 bInitSync
8114ccc4 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110d0d0 g     F .text	0000010c vSyncHandleIrq
81139f14 g     F .text	00000128 OSEventNameGet
81105574 g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
81154de8 g     O .rwdata	00000002 OSFlagMax
8112e438 g     F .text	000000e0 mbrtowc
81145fe8 g     F .text	000001b4 find_first_empty_cluster
81117790 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110db6c g     F .text	00000074 bSyncCtrCh5OutEnable
81154eb4 g     O .bss	00000001 vucN
8112fe38 g     F .text	00000074 __fpclassifyd
8110d2e0 g     F .text	00000054 bSyncStatusExtnIrq
8112b114 g     F .text	00000054 _vfscanf_r
8113e750 g     F .text	000005a4 OSMutexPend
8112f638 g     F .text	000000ac __ratio
81146ad8 g     F .text	000000c4 alt_up_sd_card_open_dev
8111e574 g     F .text	00000080 vWarnCouldNotgetMutexRetrans128
8113a7d0 g     F .text	00000100 OSIntExit
8110d450 g     F .text	00000040 bSyncSetBt
81134968 g     F .text	0000001c __vfiprintf_internal
8111edc4 g     F .text	00000080 vCouldNotCreateQueueMaskNfeeCtrl
81154e22 g     O .rwdata	00000002 OSTCBSize
81105530 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
81154fbb g     O .bss	00000001 OSPrioCur
81148a08 g     F .text	000002c4 altera_avalon_jtag_uart_read
8114b19c g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
8113685c g     F .text	00000064 .hidden __udivsi3
81138454 g     F .text	000000ac isatty
81154eac g     O .bss	00000001 LedsBoardControl
81154f04 g     O .bss	00000004 xSemCountReceivedACK
81154e08 g     O .rwdata	00000002 OSStkWidth
8112e208 g     F .text	00000030 iswspace
81152744 g     O .rodata	000000c8 __mprec_tens
81154dfc g     O .rwdata	00000002 OSPtrSize
8111f108 g     F .text	0000006c vFailSendRMAPFromIRQ
8111ea84 g     F .text	00000080 vCoudlNotCreateNFeeControllerTask
8112e2bc g     F .text	0000000c __locale_charset
8110da84 g     F .text	00000074 bSyncCtrCh3OutEnable
81125100 g     F .text	0000001c strtoll
81136a4c g     F .text	000000c8 .hidden __lesf2
81154ddc g     O .rwdata	00000002 OSEventTblSize
811210b8 g     F .text	0000007c .hidden __fixunsdfsi
8114c8dc g       .text	00000000 OSCtxSw
8110b370 g     F .text	00000160 I2C_MultipleRead
81138f98 g     F .text	00000074 alt_log_system_clock
81154f58 g     O .bss	00000004 __malloc_top_pad
81154fbc g     O .bss	00000004 OSTCBList
81143518 g     F .text	00000040 OSTmrSignal
81154f68 g     O .bss	00000004 alt_fd_list_lock
81131a40 g     F .text	0000001c strtoul
81154d8c g     O .rwdata	00000004 __mb_cur_max
8112e2ec g     F .text	0000000c _localeconv_r
81131a5c g     F .text	000002e0 _strtoull_r
8110cafc g     F .text	00000070 vRstcHoldDeviceReset
8112ec2c g     F .text	00000044 __i2b
8112db50 g     F .text	000004c4 __sfvwrite_r
811452c8 g     F .text	000000c0 get_dir_divider_location
811074a4 g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
811693b8 g     O .bss	00000c30 OSMemTbl
81154fc0 g     O .bss	00000001 OSTickStepState
81138ba8 g     F .text	00000060 alt_log_printf_proc
81104f20 g     F .text	000000c4 bDpktGetPixelDelay
8115c124 g     O .bss	00001800 vReceiverUartTask_stk
81124a7c g     F .text	0000005c _sbrk_r
81154f08 g     O .bss	00000004 xSemTimeoutChecker
81144f88 g     F .text	000000cc filename_to_upper_case
81154f74 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
81154e00 g     O .rwdata	00000002 OSQMax
811474f8 g     F .text	00000090 alt_up_sd_card_set_attributes
8113e44c g     F .text	00000304 OSMutexDel
81169fe8 g     O .bss	00001000 OSTaskStatStk
81120790 g     F .text	00000030 bSDcardFAT16Check
8113dc18 g     F .text	000000f8 OSMemNameGet
8111ce38 g     F .text	00000078 vFailCreateMutexSResources
811442f4 g     F .text	00000284 Read_File_Record_At_Offset
8115d924 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
81154de0 g     O .rwdata	00000002 OSFlagEn
8112f864 g     F .text	00000068 _read_r
81154e26 g     O .rwdata	00000002 OSTimeTickHookEn
8113d898 g     F .text	000000ac OS_FlagUnlink
8113fc6c g     F .text	00000170 OSQPost
811024c0 g     F .text	000004a4 bDdr2MemoryRandomReadTest
81154da8 g     O .rwdata	00000004 alt_max_fd
8111df70 g     F .text	00000064 vFailTimeoutCheckerTaskCreate
8113b83c g     F .text	00000070 OS_MemCopy
8113b8ac g     F .text	000000d8 OS_Sched
81145b6c g     F .text	0000047c find_file_in_directory
81134b14 g     F .text	000000f8 _fclose_r
8113db20 g     F .text	000000f8 OSMemGet
81141cf8 g     F .text	000001bc OSTaskNameSet
8112d008 g     F .text	00000030 fflush
81154f54 g     O .bss	00000004 __malloc_max_sbrked_mem
81154fc4 g     O .bss	00000004 OSCtxSwCtr
81105e70 g     F .text	000000e0 bFeebCh6SetBufferSize
8114cbc8 g     F .text	00000054 OSTimeTickHook
8115d964 g     O .bss	00001000 vOutAckHandlerTask_stk
81138288 g     F .text	00000188 alt_irq_register
81154dea g     O .rwdata	00000002 OSFlagNameSize
81122e08 g     F .text	00000118 .hidden __extendsfdf2
8113b2c0 g     F .text	00000108 OS_EventTaskRemoveMulti
8111e6fc g     F .text	00000088 vFailCreateNFEESyncQueue
81146c68 g     F .text	00000074 alt_up_sd_card_is_FAT16
8110b100 g     F .text	00000088 I2C_TestAdress
81136b14 g     F .text	000008b4 .hidden __adddf3
811689b0 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
81136918 g     F .text	00000078 .hidden __nesf2
81107460 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
811052e4 g     F .text	0000008c usiLineTrDelayCalcPeriodNs
8113b0a8 g     F .text	00000158 OS_EventTaskWaitMulti
8115e964 g     O .bss	00000020 SyncTBL4
8112f3d0 g     F .text	00000114 __b2d
8114aed4 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
81154e02 g     O .rwdata	00000002 OSQSize
81136224 g     F .text	00000540 .hidden __umoddi3
81139050 g     F .text	000000dc lseek
8114075c g     F .text	00000214 OSSemPend
8111ece0 g     F .text	00000080 vCouldNotGetCmdQueueMeb
81108044 g     F .text	00000160 bRmapGetCodecStatus
8110aa60 g     F .text	000000d0 bSpwcGetLinkStatus
81106bfc g     F .text	00000088 bFeebGetWindowing
81154d7c g     O .rwdata	00000004 _global_impure_ptr
8110d084 g     F .text	0000004c bSSDisplayUpdate
81123150 g     F .text	0000000c _atoll_r
8114562c g     F .text	00000540 get_home_directory_cluster_for_file
8112f8cc g     F .text	0000056c _realloc_r
81154dec g     O .rwdata	00000002 OSLowestPrio
8116f0b4 g       *ABS*	00000000 __bss_end
8114c3f0 g     F .text	000000f8 alt_iic_isr_register
8114cc98 g     F .text	0000002c OSTCBInitHook
81154e32 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81139848 g     F .text	00000110 alt_tick
81107b58 g     F .text	000001c8 vRmapInitIrq
8111d208 g     F .text	00000080 vFailGetMutexSenderTask
8110ca1c g     F .text	0000006c vRstcSimucamReset
811117b4 g     F .text	000000a4 bSendRequestNFeeCtrl
811528ac g     O .rodata	00000100 __hexdig
8114ba50 g     F .text	000001b4 alt_msgdma_init
81135ca4 g     F .text	00000580 .hidden __udivdi3
81115ad8 g     F .text	0000017c setPreAckSenderFreePos
81134d8c g     F .text	00000024 _fputwc_r
81154dd4 g     O .rwdata	00000002 OSEventEn
8115271c g     O .rodata	00000028 __mprec_bigtens
8112ea08 g     F .text	0000010c __s2b
81154e2e g     O .rwdata	00000002 OSTmrCfgNameSize
8115e984 g     O .bss	00000020 xFeeQueueTBL4
8110d510 g     F .text	00000074 bSyncSetPolarity
8111864c g     F .text	0000028c vCheckRetransmission64
81137e34 g     F .text	000000b0 .hidden __floatunsidf
81154f78 g     O .bss	00000004 alt_system_clock_in_sec
81138da0 g     F .text	00000054 alt_log_jtag_uart_startup_info
8111d8fc g     F .text	00000080 vFailFoundBufferRetransmission
8112f108 g     F .text	00000060 __mcmp
81155040 g     O .bss	00000004 current_sector_index
811491c8 g     F .text	00000168 altera_avalon_uart_init
8114bd2c g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
81104158 g     F .text	0000045c bSdmaDmaM2Transfer
8111ff70 g     F .text	00000034 vResetTimeCode
8111fcc8 g     F .text	0000002c cFeeSpwChannelEnable
8112d3c0 g     F .text	00000018 __fp_lock_all
8111f314 g     F .text	00000064 vFailSendMsgDataCTRL
8114c39c g     F .text	00000054 alt_ic_irq_enabled
8110b188 g     F .text	000000e0 I2C_Write
811076a8 g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
81154fc8 g     O .bss	00000002 OSTmrFree
8113d6b4 g     F .text	000000e8 OS_FlagInit
811397a4 g     F .text	000000a4 alt_alarm_stop
811250e4 g     F .text	0000001c strtol
81154f71 g     O .bss	00000001 alt_log_sys_clk_on_flag
81142cc4 g     F .text	00000140 OSTmrDel
81144060 g     F .text	000000e8 mark_cluster
81154e10 g     O .rwdata	00000002 OSTaskIdleStkSize
81154f6c g     O .bss	00000004 alt_irq_active
8114037c g     F .text	000000b8 OSSemAccept
8112339c g     F .text	0000044c _fseeko_r
81119544 g     F .text	00000354 vFillMemmoryPattern
81124e60 g     F .text	00000044 strnlen
8113de2c g     F .text	000000e0 OSMemPut
8113d944 g     F .text	000001dc OSMemCreate
81154fcc g     O .bss	00000004 OSIdleCtrMax
8111ac54 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
811385f0 g     F .text	000005b8 alt_log_private_printf
811538f8 g     O .rwdata	00000028 alt_dev_null
8114aae4 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110d4d0 g     F .text	00000040 bSyncSetOst
81154e24 g     O .rwdata	00000002 OSTicksPerSec
81153aa0 g     O .rwdata	00000019 alt_log_msg_bss
81146524 g     F .text	00000194 convert_filename_to_name_extension
811089a0 g     F .text	000010cc bRmapSetRmapMemHKArea
81106a68 g     F .text	000000e8 bFeebSetBufferSize
81116394 g     F .text	0000057c vSimMebTask
8110b4d0 g     F .text	00000094 i2c_start
8114c8dc g       .text	00000000 OSIntCtxSw
8111f174 g     F .text	0000006c vFailSendMsgSync
8110daf8 g     F .text	00000074 bSyncCtrCh4OutEnable
8114b8c8 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
81138130 g     F .text	00000028 alt_dcache_flush_all
8112eb14 g     F .text	00000068 __hi0bits
81117018 g     F .text	0000012c vPusType251run
81107a5c g     F .text	00000054 uliRmapCh6WriteCmdAddress
81120358 g     F .text	0000003c vChangeRTValue
81155014 g     O .bss	00000004 is_sd_card_formated_as_FAT16
81118224 g     F .text	000001a4 vCheck
8111f580 g     F .text	00000050 vNFeeNotInUse
81122ca4 g     F .text	00000080 .hidden __fixdfsi
811140e8 g     F .text	000000c8 bSendCmdQToNFeeInst_Prio
81106030 g     F .text	000000e0 bFeebCh8SetBufferSize
81106d10 g     F .text	0000008c bFeebStopCh
8110e0e8 g     F .text	00000084 uliPerCalcPeriodMs
81113964 g     F .text	00000450 vNFeeControlTask
8115e9a4 g     O .bss	00001000 vInitialTask_stk
81154f0c g     O .bss	00000002 usiIdCMD
8115f9a4 g     O .bss	00000020 SyncTBL3
8110d7d8 g     F .text	00000054 bSyncCtrStart
8114619c g     F .text	00000254 find_first_empty_record_in_a_subdirectory
811316cc g     F .text	00000018 strtod
81106d9c g     F .text	0000008c bFeebClrCh
81154fd0 g     O .bss	00000004 OSTCBFreeList
811077b0 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
81140970 g     F .text	00000174 OSSemPendAbort
8111d408 g     F .text	00000064 vFailGetMacRTC
811079b4 g     F .text	00000054 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8111dea8 g     F .text	00000064 vFailCreateTimerRetransmisison
8111d87c g     F .text	00000080 vFailGetCountSemaphorexBuffer32
81119a8c g     F .text	00000320 bSendUART128v2
8112018c g     F .text	000000ec vSimucamStructureInit
81154da0 g     O .rwdata	00000008 alt_dev_list
811232cc g     F .text	0000004c _fputc_r
81139ad8 g     F .text	0000010c write
81124630 g     F .text	000000a8 _putc_r
81155038 g     O .bss	00000004 device_pointer
81154e28 g     O .rwdata	00000002 OSVersionNbr
81136990 g     F .text	000000bc .hidden __gtsf2
8111f440 g     F .text	00000064 vFailFlushMEBQueue
81115498 g     F .text	00000118 getPreParsedPacket
81111650 g     F .text	00000060 bEnableSPWChannel
811381d0 g     F .text	000000b8 fstat
8111ffd8 g     F .text	00000040 vChangeIdNFEEMaster
811232a0 g     F .text	0000002c fprintf
8111fdb8 g     F .text	00000038 cFeeRMAPLogEnable
81102cc8 g     F .text	00000114 DMA_SINGLE_TRANSFER
81105908 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
8111e054 g     F .text	00000080 vFailPostBlockingSemTimeoutTask
81120c2c g     F .text	00000058 _reg_write
81120018 g     F .text	00000034 vChangeDefaultIdNFEEMaster
81137d40 g     F .text	000000f4 .hidden __ledf2
811072f8 g     F .text	00000038 vRmapCh5HandleIrq
81111544 g     F .text	00000054 bDisableRmapIRQ
8115f9c4 g     O .bss	00001000 vStackMonitor_stk
8111e454 g     F .text	00000080 vCouldNotSendLog
81142f44 g     F .text	000001b8 OSTmrRemainGet
81154dd0 g     O .rwdata	00000004 OSEndiannessTest
8110cc10 g     F .text	00000058 v_spi_start
8112ee70 g     F .text	00000148 __pow5mult
8110790c g     F .text	00000054 uliRmapCh2WriteCmdAddress
81133504 g     F .text	00001464 ___vfiprintf_internal_r
81154f64 g     O .bss	00000004 __nlocale_changed
811368c0 g     F .text	00000058 .hidden __umodsi3
8110d928 g     F .text	00000074 bSyncCtrSyncOutEnable
811207c0 g     F .text	000000f8 bInitializeSDCard
8111dd7c g     F .text	00000064 vFailParserCommTaskCreate
8111e3d4 g     F .text	00000080 vCouldNotSendReset
81124b1c g     F .text	00000038 _scanf_r
8111de44 g     F .text	00000064 vFailOutAckHandlerTaskCreate
81154de2 g     O .rwdata	00000002 OSFlagGrpSize
81116b30 g     F .text	000000ac vPusType250conf
811609c4 g     O .bss	00000058 xInUseRetrans
8110d290 g     F .text	00000050 bSyncIrqFlagSync
8114af34 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
811430fc g     F .text	000000ec OSTmrStateGet
8116f0b4 g       *ABS*	00000000 end
81105488 g     F .text	00000038 vFeebCh6HandleIrq
8111da7c g     F .text	00000080 vNoContentInPreParsedBuffer
811237e8 g     F .text	0000001c fseeko
811155b0 g     F .text	00000168 bSendMessagePUStoMebTask
8111e674 g     F .text	00000088 vFailCreateNFEEQueue
81123138 g     F .text	0000000c _atoi_r
81149a14 g     F .text	00000240 altera_avalon_uart_write
81138534 g     F .text	00000054 alt_log_txchar
81123380 g     F .text	0000001c fseek
811199fc g     F .text	00000090 vCCDChangeValues
81148308 g     F .text	000001d0 altera_avalon_jtag_uart_init
8113bb3c g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
8111cf78 g     F .text	00000064 vFailTestCriticasParts
81106930 g     F .text	00000068 bFeebGetCh1RightFeeBusy
811fa000 g       *ABS*	00000000 __alt_stack_pointer
81102048 g     F .text	00000478 bDdr2MemoryRandomWriteTest
8114901c g     F .text	00000084 alt_avalon_timer_sc_init
81106b50 g     F .text	000000ac bFeebSetWindowing
81149108 g     F .text	00000068 altera_avalon_uart_write_fd
811230c8 g     F .text	00000064 .hidden __clzsi2
81149170 g     F .text	00000058 altera_avalon_uart_close_fd
81160a1c g     O .bss	00000020 xMebQTBL
81148ccc g     F .text	000002cc altera_avalon_jtag_uart_write
81143670 g     F .text	00000174 OSTmr_Init
81160a3c g     O .bss	00000348 xBuffer128
8112d3b0 g     F .text	00000004 __sfp_lock_acquire
811033b0 g     F .text	00000048 sense_log_temp
8112e5c8 g     F .text	000000e4 memchr
8113b7e0 g     F .text	0000005c OS_MemClr
811275e4 g     F .text	00002200 ___vfprintf_internal_r
8114c9bc g     F .text	00000164 OSTaskStkInit
81124b54 g     F .text	00000060 _sprintf_r
81108638 g     F .text	000002d4 bRmapGetMemConfigArea
81154f0e g     O .bss	00000001 SemCount32
8112d838 g     F .text	00000318 _free_r
8114c638 g     F .text	00000234 alt_printf
8111aa5c g     F .text	00000050 vTimeoutCheck
81120cdc g     F .text	00000214 _print_codec_status
8112e2c8 g     F .text	00000010 __locale_mb_cur_max
8113adf0 g     F .text	000001a0 OS_EventTaskRdy
81107e54 g     F .text	00000088 bRmapGetIrqFlags
81102c20 g     F .text	000000a8 DMA_DISPATCHER_RESET
8114cf10 g     F .text	00000188 __call_exitprocs
81113eb8 g     F .text	00000168 vPerformActionNFCRunning
81154fd4 g     O .bss	00000001 OSCPUUsage
8111e984 g     F .text	00000080 vCoudlNotCreateNFee4Task
81154f60 g     O .bss	00000004 __mlocale_changed
81113db4 g     F .text	00000104 vPerformActionNFCConfig
8110d880 g     F .text	00000054 bSyncCtrOneShot
81154d84 g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110dff8 g     F .text	0000003c uliSyncReadStatus
81154f8c g     O .bss	00000004 _alt_tick_rate
8113f864 g     F .text	00000294 OSQPend
8112511c g     F .text	000002e8 _strtoll_r
81160d84 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
8116894c g     O .bss	00000034 xDefaults
811425e8 g     F .text	0000010c OSTimeDly
81116ea8 g     F .text	000000c4 vPusMebInTaskRunningMode
8110d254 g     F .text	0000003c vSyncIrqFlagClrSync
8112efb8 g     F .text	00000150 __lshift
811141b0 g     F .text	00000328 vOutAckHandlerTask
8114a98c g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
81154f90 g     O .bss	00000004 _alt_nticks
81139538 g     F .text	00000104 read
81143cc4 g     F .text	000000f0 alt_sys_init
81121980 g     F .text	0000012c .hidden __floatsisf
8110741c g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
81131d3c g     F .text	000001d8 __ssprint_r
811245c8 g     F .text	00000068 _open_r
81120bcc g     F .text	00000060 bTestSimucamCriticalHW
811064e4 g     F .text	00000154 bFeebGetBuffersStatus
8111cbe8 g     F .text	000000a4 ucCrc8
81100824 g     F .text	00000cbc bDdr2EepromDump
81154fd5 g     O .bss	00000001 OSTaskCtr
81138500 g       .text	00000000 tx_log_str
81116910 g     F .text	0000015c vPusMebTask
8111aa0c g     F .text	00000050 siPosStr
811175ec g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
811359d4 g     F .text	000000d0 strncmp
8110e034 g     F .text	0000005c bSyncWriteReg
81107758 g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
811426f4 g     F .text	00000164 OSTimeDlyHMSM
8112ec70 g     F .text	00000200 __multiply
811488a0 g     F .text	00000070 altera_avalon_jtag_uart_close
8110cde0 g     F .text	00000058 v_spi_end
81120934 g     F .text	00000040 cGetNextChar
8114ce24 g     F .text	000000ec strncpy
8115518c g     O .bss	00000028 __malloc_current_mallinfo
81154dd6 g     O .rwdata	00000002 OSEventMax
81136918 g     F .text	00000078 .hidden __eqsf2
8112f4e4 g     F .text	00000154 __d2b
81140ae4 g     F .text	00000118 OSSemPost
811055fc g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
81120394 g     F .text	00000030 vChangeDefaultRTValue
811054f8 g     F .text	00000038 vFeebCh8HandleIrq
81155010 g     O .bss	00000004 initialized
8111a8bc g     F .text	00000100 vSendLog
8113a964 g     F .text	000000e4 OSSchedUnlock
8110ce38 g     F .text	0000017c RTCC_SPI_R_MAC
81154db4 g     O .rwdata	00000004 alt_log_boot_on_flag
81148184 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
811317ec g     F .text	00000254 _strtoul_r
81160dc4 g     O .bss	00000020 xFeeQueueTBL5
8114c13c g     F .text	000000e4 alt_get_fd
81154fd8 g     O .bss	00000004 OSMemFreeList
8113aac0 g     F .text	000000b8 OSStatInit
81120b98 g     F .text	00000034 bClearCounterSync
811029e4 g     F .text	00000064 DMA_OPEN_DEVICE
8116ea4c g     O .bss	00000014 search_data
8110a750 g     F .text	00000138 bSpwcSetLink
81137ee4 g     F .text	00000130 alt_busy_sleep
8113d480 g     F .text	000000cc OSFlagQuery
8110d99c g     F .text	00000074 bSyncCtrCh1OutEnable
81154e0c g     O .rwdata	00000002 OSTaskCreateExtEn
81120ef0 g     F .text	00000074 _split_codec_status
8112b48c g     F .text	0000005c _close_r
8111dafc g     F .text	00000080 vCouldNotSendEthConfUART
811132d8 g     F .text	0000068c vInitialTask
81138ca8 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
8114ae74 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
8114cda8 g     F .text	0000007c memcmp
8113adc8 g     F .text	00000028 OS_Dummy
81148254 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
8116f0b4 g       *ABS*	00000000 __alt_stack_base
81105f50 g     F .text	000000e0 bFeebCh7SetBufferSize
811482ac g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
81105640 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
81123868 g     F .text	000000d4 _fwrite_r
81117920 g     F .text	000000a4 vReleaseSyncMessages
8114af94 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
81105750 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
8112b330 g     F .text	0000015c __swsetup_r
8116afe8 g     O .bss	00000300 OSQTbl
8111eec4 g     F .text	00000080 vCouldNotGetQueueMaskNfeeCtrl
81168980 g     O .bss	0000001c xConfEth
811373c8 g     F .text	000008f0 .hidden __divdf3
811203f8 g     F .text	0000003c vChangeSyncSource
8112d268 g     F .text	00000120 __sfp
8116ea60 g     O .bss	00000054 boot_sector_data
8111ee44 g     F .text	00000080 vCouldNotCreateQueueMaskDataCtrl
8110abc0 g     F .text	0000008c bSpwcClearTimecode
81102b2c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
8112f760 g     F .text	00000078 __copybits
81153478 g     O .rwdata	00000408 __malloc_av_
8112d3bc g     F .text	00000004 __sinit_lock_release
81154e48 g     O .bss	00000004 uliInitialState
8110b564 g     F .text	00000080 i2c_stop
81121008 g     F .text	0000007c Verif_Error
81121084 g     F .text	00000034 toInt
8111d124 g     F .text	00000064 vFailSendPreAckSenderSemaphore
81154fdc g     O .bss	00000004 OSTCBHighRdy
81121c80 g     F .text	00000720 .hidden __muldf3
81124c28 g     F .text	0000005c __sread
8112d6d0 g     F .text	0000003c fread
81154fe0 g     O .bss	00000004 OSQFreeList
8114c02c g     F .text	00000110 alt_find_file
8114bee8 g     F .text	000000ac alt_dev_llist_insert
81139d18 g     F .text	00000128 __malloc_lock
81123270 g     F .text	00000030 _fprintf_r
811396a8 g     F .text	000000fc sbrk
8111fc44 g     F .text	0000002c vFeeSpwRMAPLoadDefault
8111d7fc g     F .text	00000080 vFailGetCountSemaphorexBuffer64
81125404 g     F .text	000021e0 ___svfprintf_internal_r
8111adfc g     F .text	00000088 vTMPusTestConnection
81154f10 g     O .bss	00000004 xMebQ
8113a03c g     F .text	00000148 OSEventNameSet
8112cfa4 g     F .text	00000064 _fflush_r
81134a48 g     F .text	000000cc _calloc_r
81154fe4 g     O .bss	00000001 OSRdyGrp
8111f2b0 g     F .text	00000064 vFailSendMsgFeeCTRL
8110d3cc g     F .text	00000044 ucSyncStatusCycleNumber
81107fb8 g     F .text	0000008c bRmapGetCodecConfig
811431e8 g     F .text	00000148 OSTmrStart
81105450 g     F .text	00000038 vFeebCh5HandleIrq
81123258 g     F .text	00000018 fopen
81102a48 g     F .text	0000004c DMA_CONFIG
81154e48 g       *ABS*	00000000 __bss_start
81105cb0 g     F .text	000000e0 bFeebCh4SetBufferSize
811244a0 g     F .text	00000128 memset
8111599c g     F .text	0000013c setPreParsedFreePos
8110fe74 g     F .text	0000025c vQCmdFEEinStandBy
8114b9f0 g     F .text	00000060 alt_msgdma_open
81120550 g     F .text	00000210 pattern_createPattern
81119324 g     F .text	00000220 main
8111d308 g     F .text	00000080 vFailGetMutexReceiverTask
81160de4 g     O .bss	00001000 vNFeeControlTask_stk
811075b4 g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
811202b0 g     F .text	0000003c vChangeEPValue
81107700 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
81154f88 g     O .bss	00000004 alt_envp
8111f378 g     F .text	00000064 vFailFlushQueue
81154f50 g     O .bss	00000004 __malloc_max_total_mem
8114b294 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8111cc8c g     F .text	0000005c ucCrc8wInit
8111df0c g     F .text	00000064 vCouldNotCheckBufferTimeOutFunction
811481ec g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102ff0 g     F .text	000002c8 POWER_Read
8110b71c g     F .text	00000160 i2c_read
81161de4 g     O .bss	00000020 SyncTBL5
8112b2b0 g     F .text	00000018 __swbuf
81152bac g     O .rodata	00000100 OSUnMapTbl
81136a4c g     F .text	000000c8 .hidden __ltsf2
81147588 g     F .text	00000090 alt_up_sd_card_get_attributes
8112d49c g     F .text	00000234 _fread_r
8111d188 g     F .text	00000080 vFailGetCountSemaphoreSenderTask
8110af10 g     F .text	0000003c bDisableIsoDrivers
81154e06 g     O .rwdata	00000002 OSSemEn
81143db4 g     F .text	000000bc Write_Sector_Data
81147998 g     F .text	00000628 alt_up_sd_card_write
81154f14 g     O .bss	00000004 xFeeQ
81106790 g     F .text	00000068 bFeebGetCh1RightBufferEmpty
8113d0e4 g     F .text	0000039c OSFlagPost
81124d74 g     F .text	00000008 __sclose
8111e2d4 g     F .text	00000080 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
81134c0c g     F .text	00000014 fclose
8113af90 g     F .text	00000118 OS_EventTaskWait
8111e154 g     F .text	00000080 vCouldNotRetransmitB32TimeoutTask
81124ea4 g     F .text	00000240 _strtol_r
81122f20 g     F .text	000001a8 .hidden __truncdfsf2
81161e04 g     O .bss	00000020 xFeeQueueTBL2
8113bc20 g     F .text	000000d4 OS_TaskStatStkChk
81141a00 g     F .text	00000158 OSTaskDelReq
81104d08 g     F .text	000000c4 bDpktGetPacketHeader
811070b0 g     F .text	000000ec vRmapCh1HandleIrq
8112b6f0 g     F .text	00001690 _dtoa_r
8114b5b0 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
81123b3c g     F .text	00000814 _malloc_r
81161e24 g     O .bss	00000020 SyncTBL0
81135c10 g     F .text	00000030 __ascii_wctomb
8113e27c g     F .text	000001d0 OSMutexCreate
8111e0d4 g     F .text	00000080 vFailCouldNotRetransmitTimeoutTask
8111318c g     F .text	0000014c bCheckInAck32
81154dac g     O .rwdata	00000004 alt_errno
8114b0dc g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
8113aa48 g     F .text	00000078 OSStart
8110a888 g     F .text	000000e4 bSpwcGetLink
8110c534 g     F .text	000004e8 POWER_SPI_RW
81133158 g     F .text	000000dc __submore
81138c08 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
81139cb0 g     F .text	00000068 __env_unlock
8111e804 g     F .text	00000080 vCoudlNotCreateNFee1Task
8112e014 g     F .text	000000cc _fwalk
811068c8 g     F .text	00000068 bFeebGetCh1LeftFeeBusy
81141eb4 g     F .text	000001dc OSTaskResume
8113df0c g     F .text	000000f0 OSMemQuery
81154e18 g     O .rwdata	00000002 OSTaskStatEn
8116f0b4 g       *ABS*	00000000 __alt_stack_limit
81154e58 g     O .bss	00000004 ECommSpwCh
8112049c g     F .text	0000003c vChangeAutoResetSync
8112e564 g     F .text	00000064 _mbtowc_r
81112b78 g     F .text	00000380 vInAckHandlerTaskV2
81154df2 g     O .rwdata	00000002 OSMemMax
8113fddc g     F .text	00000178 OSQPostFront
811246d8 g     F .text	000000d0 putc
81136764 g     F .text	00000084 .hidden __divsi3
81154fe5 g     O .bss	00000006 OSRdyTbl
81154dcc g     O .rwdata	00000002 OSDebugEn
81153b10 g     O .rwdata	0000002a alt_log_msg_cache
8112d70c g     F .text	0000012c _malloc_trim_r
8110a238 g     F .text	0000020c bRmapInitCh
81154f44 g     O .bss	00000008 xSdHandle
8112157c g     F .text	00000404 .hidden __mulsf3
81154de4 g     O .rwdata	00000002 OSFlagNodeSize
81154e4c g     O .bss	00000004 pnt_memory
81120508 g     F .text	00000048 vSyncReset
81112650 g     F .text	00000528 vLoadCtemp
8110d490 g     F .text	00000040 bSyncSetPer
81100308 g     F .text	0000051c bDdr2EepromTest
8115501c g     O .bss	00000004 status_register
81154e2c g     O .rwdata	00000002 OSTmrCfgMax
8110de24 g     F .text	00000074 bSyncIrqFlagClrError
8111dbfc g     F .text	00000080 vFailSetPreAckSenderBuffer
8112ff84 g     F .text	000000dc strcmp
81155024 g     O .bss	00000004 command_register
8113f368 g     F .text	000001b4 OSQCreate
81141b58 g     F .text	000001a0 OSTaskNameGet
81161e44 g     O .bss	00001000 vFeeTask4_stk
81162e44 g     O .bss	00000018 xReceivedACK
8113ff54 g     F .text	00000214 OSQPostOpt
8113ab78 g     F .text	00000228 OSTimeTick
81154e14 g     O .rwdata	00000002 OSTaskMax
81140434 g     F .text	000000e0 OSSemCreate
81154e38 g     O .rwdata	00000002 OSTmrWheelSize
8111e5f4 g     F .text	00000080 vFailCreateScheduleQueue
81120c84 g     F .text	00000058 _reg_read
8113ef14 g     F .text	00000174 OSMutexQuery
81111858 g     F .text	000000a4 bSendGiveBackNFeeCtrl
81137cb8 g     F .text	00000088 .hidden __nedf2
81154e0e g     O .rwdata	00000002 OSTaskDelEn
81120278 g     F .text	00000038 vLoadDefaultEPValue
81162e5c g     O .bss	00001000 vFeeTask1_stk
8110dc54 g     F .text	00000074 bSyncCtrCh7OutEnable
81140bfc g     F .text	00000118 OSSemQuery
8113f51c g     F .text	00000288 OSQDel
8113faf8 g     F .text	00000174 OSQPendAbort
81154f18 g     O .bss	00000004 xMutexPreParsed
81143c84 g     F .text	00000040 alt_irq_init
8113963c g     F .text	0000006c alt_release_fd
81143fa4 g     F .text	000000bc get_cluster_flag
8110de98 g     F .text	00000074 bSyncIrqFlagClrBlank
8114bce8 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110d1dc g     F .text	0000002c vSyncClearCounter
81112264 g     F .text	000003ec bPrepareDoubleBuffer
81153adc g     O .rwdata	00000031 alt_log_msg_stackpointer
81124bb4 g     F .text	00000074 sprintf
81152294 g     O .rodata	00000100 .hidden __clz_tab
81144578 g     F .text	00000294 Write_File_Record_At_Offset
811015a8 g     F .text	00000588 bDdr2MemoryWriteTest
8111d388 g     F .text	00000080 vFailGetMutexTxUARTSenderTask
81154f5c g     O .bss	00000004 _PathLocale
8110df64 g     F .text	00000058 bSyncIrqFlagBlank
8110c3ec g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
81143330 g     F .text	000001e8 OSTmrStop
8110a498 g     F .text	00000050 uliRmapReadReg
8111a9bc g     F .text	00000050 usiGetIdCMD
8110e090 g     F .text	00000058 uliSyncReadReg
81106a00 g     F .text	00000068 bFeebGetCh2RightFeeBusy
811316e4 g     F .text	00000108 strtof
811053e0 g     F .text	00000038 vFeebCh3HandleIrq
81136990 g     F .text	000000bc .hidden __gesf2
81124d7c g     F .text	0000004c strcspn
8112b2c8 g     F .text	00000068 _write_r
8110ca88 g     F .text	00000074 vRstcReleaseDeviceReset
8111dde0 g     F .text	00000064 vFailInAckHandlerTaskCreate
8113a8d0 g     F .text	00000094 OSSchedLock
8111e904 g     F .text	00000080 vCoudlNotCreateNFee3Task
8112e2f8 g     F .text	00000018 setlocale
8114b03c g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
8116b2e8 g     O .bss	00000800 OSTmrTaskStk
81124ad8 g     F .text	00000044 scanf
8111ec04 g     F .text	00000078 vFailCreateMutexSPUSQueueMeb
8113c4d8 g     F .text	00000110 OSFlagCreate
8114480c g     F .text	00000688 Check_for_DOS_FAT
81117818 g     F .text	00000064 vMebInit
811466b8 g     F .text	000002d0 create_file
8112ff7c g     F .text	00000008 nanf
81154d80 g     O .rwdata	00000004 _impure_ptr
81155020 g     O .bss	00000004 CSD_register_w0
81154f80 g     O .bss	00000004 alt_argc
8111d77c g     F .text	00000080 vFailGetCountSemaphorexBuffer128
8112cd80 g     F .text	00000224 __sflush_r
8112e384 g     F .text	000000b4 _mbrtowc_r
8110ab30 g     F .text	00000090 bSpwcGetTimecode
8112e2e4 g     F .text	00000008 __locale_cjk_lang
811033f8 g     F .text	0000078c sense_log
81154e5c g     O .bss	00000004 ESdmaBufferSide
81154dde g     O .rwdata	00000002 OSEventMultiEn
8112337c g     F .text	00000004 _fseek_r
81163e5c g     O .bss	00001800 vParserCommTask_stk
8111cdc8 g     F .text	00000070 printErrorTask
811202ec g     F .text	00000030 vChangeDefaultEPValue
811188d8 g     F .text	000002c8 vCheckRetransmission32
81142b00 g     F .text	000001c4 OSTmrCreate
811179c4 g     F .text	000007dc vStackMonitor
811248a0 g     F .text	000001dc __srefill_r
8110af4c g     F .text	0000003c bEnableLvdsBoard
81154f1c g     O .bss	00000004 xMutexBuffer32
81154ec4 g     O .bss	00000001 ucIterationSide
8110719c g     F .text	000000ec vRmapCh2HandleIrq
8113c5e8 g     F .text	00000250 OSFlagDel
81154fec g     O .bss	00000004 OSEventFreeList
8110afc4 g     F .text	000000c0 bSetPreEmphasys
8110fc30 g     F .text	00000244 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
8112e518 g     F .text	0000004c __ascii_mbtowc
8110d760 g     F .text	00000078 bSyncCtrExtnIrq
811067f8 g     F .text	00000068 bFeebGetCh2LeftBufferEmpty
8112f36c g     F .text	00000064 __ulp
8111fe24 g     F .text	0000010c vNFeeControlInit
8111787c g     F .text	000000a4 vSwapMemmory
8113cabc g     F .text	000005c0 OSFlagPend
81154e2a g     O .rwdata	00000002 OSTmrEn
8112d3d8 g     F .text	00000018 __fp_unlock_all
8116565c g     O .bss	00000010 xDma
81123318 g     F .text	00000064 fputc
81111598 g     F .text	00000058 bEnableRmapIRQ
8111a0d4 g     F .text	00000328 bSendUART32v2
81115c54 g     F .text	000001b4 setPreAckReceiverFreePos
8110d720 g     F .text	00000040 bSyncErrInj
81154d98 g     O .rwdata	00000008 alt_fs_list
8116566c g     O .bss	00001000 vSimMebTask_stk
8111eb84 g     F .text	00000080 vCoudlNotCreateMebTask
81145054 g     F .text	00000274 check_file_name_for_FAT16_compliance
8116666c g     O .bss	00001000 vFeeTask3_stk
81142e04 g     F .text	00000140 OSTmrNameGet
811552b4 g     O .bss	00000400 xSZData
811100d0 g     F .text	00000288 vQCmdFEEinFullPattern
8113ba00 g     F .text	0000007c OS_StrCopy
8115502c g     O .bss	00000004 buffer_memory
8111d9fc g     F .text	00000080 vFailGetxMutexPreParsedParserRxTask
811200f4 g     F .text	00000098 vLogWriteNUC
81154df4 g     O .rwdata	00000002 OSMemNameSize
81103b84 g     F .text	000000bc bSdmaInitM1Dma
8110ddb0 g     F .text	00000074 bSyncIrqEnableBlank
8114cc48 g     F .text	00000028 OSInitHookEnd
8111f854 g     F .text	00000340 vUpdateMemMapFEE
8111dcfc g     F .text	00000080 vFailSetPreAckReceiverBuffer
811059b8 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
81154e20 g     O .rwdata	00000002 OSTCBPrioTblMax
8112e310 g     F .text	0000000c localeconv
8111eb04 g     F .text	00000080 vCoudlNotCreateDataControllerTask
81154f20 g     O .bss	00000004 xTimerRetransmission
81115718 g     F .text	00000284 vReceiverUartTask
81154f7c g     O .bss	00000004 alt_log_sys_clk_count
81154e1c g     O .rwdata	00000002 OSTaskStatStkChkEn
81138e58 g     F .text	00000140 alt_log_write
8116766c g     O .bss	00001000 vFeeTask2_stk
81154f24 g     O .bss	00000004 xMutexBuffer128
81105370 g     F .text	00000038 vFeebCh1HandleIrq
81120b2c g     F .text	0000003c bStartSync
811054c0 g     F .text	00000038 vFeebCh7HandleIrq
81120b68 g     F .text	00000030 bStopSync
81154e60 g     O .bss	00000004 ECommBufferSide
8114c220 g     F .text	00000058 alt_ic_isr_register
81154df0 g     O .rwdata	00000002 OSMemEn
81107288 g     F .text	00000038 vRmapCh3HandleIrq
81154d6c g     O .rwdata	00000004 alt_stack_limit_value
81117144 g     F .text	00000420 vPusType252run
8111f24c g     F .text	00000064 vFailSendMsgMasterSyncMeb
8112393c g     F .text	0000003c fwrite
81155030 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
81154dfa g     O .rwdata	00000002 OSMutexEn
8111ef44 g     F .text	00000080 vCouldNotGetQueueMaskDataCtrl
81154e48 g       *ABS*	00000000 _edata
811490a0 g     F .text	00000068 altera_avalon_uart_read_fd
8111ffa4 g     F .text	00000034 vLoadDefaultIdNFEEMaster
81105258 g     F .text	0000008c usiAdcPxDelayCalcPeriodNs
8116f0b4 g       *ABS*	00000000 _end
8116eab4 g     O .bss	00000500 active_files
81154ff0 g     O .bss	00000001 OSIntNesting
8111d46c g     F .text	00000064 vFailInitialization
811014e0 g     F .text	000000c8 bDdr2SwitchMemory
8111fd20 g     F .text	0000002c cFeeRMAPDump
81105bd0 g     F .text	000000e0 bFeebCh3SetBufferSize
81154f28 g     O .bss	00000004 xSemCountBuffer32
81134c20 g     F .text	0000016c __fputwc
81154f2c g     O .bss	00000004 xQMaskFeeCtrl
8111fc70 g     F .text	0000002c vFeeSpwRMAPChangeConfig
8112b088 g     F .text	00000070 vfscanf
81146988 g     F .text	00000150 copy_file_record_name_to_string
81148910 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
81142858 g     F .text	000001dc OSTimeDlyResume
81144e94 g     F .text	000000f4 Look_for_FAT16
811115f0 g     F .text	00000060 bDisableSPWChannel
8113c968 g     F .text	00000154 OSFlagNameSet
81111748 g     F .text	0000006c bDisAndClrDbBuffer
81154f30 g     O .bss	00000004 xMutexBuffer64
811081a4 g     F .text	00000160 bRmapGetCodecError
81142090 g     F .text	000001c8 OSTaskStkChk
8114c308 g     F .text	00000094 alt_ic_irq_disable
81103d04 g     F .text	00000454 bSdmaDmaM1Transfer
81154df6 g     O .rwdata	00000002 OSMemSize
81116c48 g     F .text	00000260 vPusType252conf
8111d5fc g     F .text	00000080 vFailSetCountSemaphorexBuffer32
81124c8c g     F .text	00000084 __swrite
81154d88 g     O .rwdata	00000004 __malloc_trim_threshold
8112e2d8 g     F .text	0000000c __locale_msgcharset
8116866c g     O .bss	00000020 xFeeQueueTBL1
81154ff4 g     O .bss	00000004 OSTCBCur
8111e1d4 g     F .text	00000080 vCouldNotRetransmitB64TimeoutTask
8110c4f0 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
8114cd68 g     F .text	00000040 exit
8113ecf4 g     F .text	00000220 OSMutexPost
8110df0c g     F .text	00000058 bSyncIrqFlagError
81146db4 g     F .text	000003c0 alt_up_sd_card_find_next
81154df8 g     O .rwdata	00000002 OSMemTblSize
8112e0e0 g     F .text	000000cc _fwalk_reent
8114b434 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
81121aac g     F .text	000000f8 .hidden __floatunsisf
8112f168 g     F .text	00000204 __mdiff
8111e784 g     F .text	00000080 vCoudlNotCreateNFee0Task
81106110 g     F .text	000001c8 vFeebInitIrq
8110490c g     F .text	000002a4 bDpktSetPacketConfig
8111d534 g     F .text	00000064 vFailSenderCreate
811367e8 g     F .text	00000074 .hidden __modsi3
8111ea04 g     F .text	00000080 vCoudlNotCreateNFee5Task
8110d66c g     F .text	0000003c uliSyncGetPer
81107330 g     F .text	00000038 vRmapCh6HandleIrq
81154f34 g     O .bss	00000004 xMutexSenderACK
8111dfd4 g     F .text	00000080 vFailGetBlockingSemTimeoutTask
81154d78 g     O .rwdata	00000004 __ctype_ptr__
8111dc7c g     F .text	00000080 vFailSetPreParsedBuffer
81143ec4 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
8112d3b4 g     F .text	00000004 __sfp_lock_release
811063b0 g     F .text	000000ac bFeebGetIrqControl
8111e354 g     F .text	00000080 vCouldNotSendTurnOff
8113a718 g     F .text	00000064 OSInit
8110b8fc g     F .text	00000078 bSetPainelLeds
8114ab7c g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
81154ff8 g     O .bss	00000004 OSTmrTime
81101b30 g     F .text	00000518 bDdr2MemoryReadTest
81108304 g     F .text	00000334 bRmapSetMemConfigArea
81142444 g     F .text	0000012c OSTaskQuery
8110dd3c g     F .text	00000074 bSyncIrqEnableError
81154f38 g     O .bss	00000004 xMutexPus
811402cc g     F .text	000000b0 OS_QInit
8112feac g     F .text	000000d0 __sccl
8112312c g     F .text	0000000c atoi
8110e224 g     F .text	000017f4 vFeeTask
8113ba7c g     F .text	0000005c OS_StrLen
8111f4a4 g     F .text	00000064 vFailFlushNFEEQueue
811057a8 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
8111cce8 g     F .text	000000e0 vDataControllerInit
8113dd10 g     F .text	0000011c OSMemNameSet
81152394 g     O .rodata	00000101 _ctype_
8110d630 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
8111d6fc g     F .text	00000080 vFailSetCountSemaphorexBuffer128
81154e12 g     O .rwdata	00000002 OSTaskProfileEn
8111f508 g     F .text	00000028 vEvtChangeMebMode
8114aa4c g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
81154f3c g     O .bss	00000004 xTxUARTMutex
81154ffc g     O .bss	00000004 OSTime
81154d90 g     O .rwdata	00000004 __mbtowc
811496c0 g     F .text	0000005c altera_avalon_uart_close
8110fa18 g     F .text	00000218 vQCmdFEEinWaitingSync
81155000 g     O .bss	00000004 OSTmrSem
81116bdc g     F .text	0000006c vPusType251conf
8116bae8 g     O .bss	00001000 OSTaskIdleStk
8112315c g     F .text	000000fc _fopen_r
81154ed8 g     O .bss	00000004 pdata
8114d098 g     F .text	000000bc _exit
81106638 g     F .text	00000078 bFeebGetLeftBufferEmpty
8114bd70 g     F .text	00000134 alt_alarm_start
8113c838 g     F .text	00000130 OSFlagNameGet
81142a34 g     F .text	00000064 OSTimeGet
81154e64 g     O .bss	00000004 ESdmaChBufferId
81147618 g     F .text	00000380 alt_up_sd_card_read
811074e8 g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
81123978 g     F .text	000001c4 __smakebuf_r
81154f40 g     O .bss	00000001 SemCount64
81119dac g     F .text	00000328 bSendUART64v2
8111f3dc g     F .text	00000064 vFailFlushQueueData
81105858 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
81154e40 g     O .rwdata	00000008 alt_msgdma_list
81124dc8 g     F .text	00000098 strlen
8110cd2c g     F .text	000000b4 uc_spi_get_byte
8110752c g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
8111efc4 g     F .text	0000006c vFailSendMsgAccessDMA
8114cb78 g     F .text	00000028 OSTaskSwHook
81139398 g     F .text	0000015c open
81109a6c g     F .text	000007cc bRmapGetRmapMemHKArea
8116cae8 g     O .bss	00000d00 OSEventTbl
8111fc9c g     F .text	0000002c vFeeSpwRMAPChangeDefault
81121ba4 g     F .text	000000dc .hidden __gedf2
8111f1e0 g     F .text	0000006c vFailSendMsgSyncRMAPTRIGGER
8116868c g     O .bss	00000020 xSenderACK
8114c86c g     F .text	00000044 alt_putchar
81123144 g     F .text	0000000c atoll
8116d7e8 g     O .bss	000011b8 OSTCBTbl
81134f38 g     F .text	00000838 __gethex
81140d14 g     F .text	00000108 OSSemSet
811181a0 g     F .text	00000084 vTimeoutCheckerTaskv2
8111fd4c g     F .text	00000038 cFeeRMAPEchoingEnable
81154d94 g     O .rwdata	00000004 __wctomb
81119010 g     F .text	00000314 vVariablesInitialization
811334ec g     F .text	00000018 __sprint_r
811109dc g     F .text	000005e4 vQCmdFeeRMAPinFullPattern
8110645c g     F .text	00000088 bFeebGetIrqFlags
81154e54 g     O .bss	00000004 pxDmaM2Dev
8111cf14 g     F .text	00000064 vFailCreateSemaphoreResources
81154db0 g     O .rwdata	00000004 alt_priority_mask
8110af88 g     F .text	0000003c bDisableLvdsBoard
81140514 g     F .text	00000248 OSSemDel
81105af0 g     F .text	000000e0 bFeebCh2SetBufferSize
81155004 g     O .bss	00000004 OSFlagFreeList
8110cc68 g     F .text	000000c4 v_spi_send_byte
8110cfb4 g     F .text	000000d0 bSSDisplayConfig
8114c278 g     F .text	00000090 alt_ic_irq_enable
81154dd8 g     O .rwdata	00000002 OSEventNameSize
811297e4 g     F .text	0000001c __vfprintf_internal
81155008 g     O .bss	00000001 OSStatRdy
8110da10 g     F .text	00000074 bSyncCtrCh2OutEnable
8116e9a0 g     O .bss	000000ac OSTCBPrioTbl
81149760 g     F .text	00000270 altera_avalon_uart_read
81135c40 g     F .text	00000064 _wctomb_r
81139be4 g     F .text	000000cc __env_lock
81154e1e g     O .rwdata	00000002 OSTaskSwHookEn
811557cc g     O .bss	00000100 cTemp
811055b8 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
811223a0 g     F .text	00000904 .hidden __subdf3
811686ac g     O .bss	00000260 xPreParsed
8110d6a8 g     F .text	0000003c uliSyncGetOst
81154f41 g     O .bss	00000001 SemCount128
811073a0 g     F .text	00000038 vRmapCh8HandleIrq
81105684 g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
8111a3fc g     F .text	00000290 vSendEthConf
8110476c g     F .text	000000fc bCommInitCh
8112eb7c g     F .text	000000b0 __lo0bits
811298c4 g     F .text	000017c4 __svfscanf_r
81154dbc g     O .rwdata	00000008 alt_alarm_list
81133234 g     F .text	0000019c _ungetc_r
81154de6 g     O .rwdata	00000002 OSFlagWidth
811073d8 g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a94 g     F .text	0000004c DMA_BUSY
81135b48 g     F .text	000000c8 wcrtomb
81104dcc g     F .text	00000154 bDpktSetPixelDelay
81119898 g     F .text	00000164 vCCDLoadDefaultValues
81138058 g     F .text	000000d8 close
8110d6e4 g     F .text	0000003c uliSyncGetGeneral
8111f558 g     F .text	00000028 vEvtChangeDataControllerMode
81154f98 g     O .bss	00000004 alt_envsem
81138588 g     F .text	00000068 alt_log_repchar
8115500c g     O .bss	00000004 OSIdleCtrRun
8113ada0 g     F .text	00000028 OSVersion
81154e30 g     O .rwdata	00000002 OSTmrCfgWheelSize
81142570 g     F .text	00000078 OS_TaskStkClr
811208b8 g     F .text	0000003c siOpenFile
8110e16c g     F .text	000000b8 vDataControlTask
81154e0a g     O .rwdata	00000002 OSTaskCreateEn
81107650 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
81107ab0 g     F .text	00000054 uliRmapCh7WriteCmdAddress
81106c84 g     F .text	0000008c bFeebStartCh
8111a68c g     F .text	00000118 vSendTurnOff
8111d05c g     F .text	00000064 vFailSendPreParsedSemaphore
81145388 g     F .text	000002a4 match_file_record_to_name_ext
8113b3c8 g     F .text	00000070 OS_EventWaitListInit
81134db0 g     F .text	00000088 fputwc
8116890c g     O .bss	00000020 xFeeQueueTBL0
8111cfdc g     F .text	00000080 vFailSendxSemCommInit
8114cc70 g     F .text	00000028 OSTaskIdleHook
8111a7a4 g     F .text	00000118 vSendReset
8112d3b8 g     F .text	00000004 __sinit_lock_acquire
8112e8e0 g     F .text	00000128 __multadd
8116892c g     O .bss	00000020 SyncTBL1
811056c8 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110d334 g     F .text	0000004c ucSyncStatusState
81142258 g     F .text	000001ec OSTaskSuspend
8112e8b8 g     F .text	00000028 _Bfree
8110d5f4 g     F .text	0000003c uliSyncGetMbt
8113bad8 g     F .text	00000064 OS_TaskIdle
81154e36 g     O .rwdata	00000002 OSTmrTblSize
81140168 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	113a77c0 	call	8113a77c <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045f4 	movhi	r2,33047
81100150:	10bbed04 	addi	r2,r2,-4172
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045f4 	movhi	r2,33047
81100168:	10bbed04 	addi	r2,r2,-4172
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	113a7d00 	call	8113a7d0 <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b717 	ldw	r2,-32036(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b717 	ldw	r2,-32036(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	21136d04 	addi	r4,r4,19892
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	210ec404 	addi	r4,r4,15120
81100274:	11385000 	call	81138500 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	21136d04 	addi	r4,r4,19892
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	210eb704 	addi	r4,r4,15068
81100290:	11385000 	call	81138500 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d6b35b14 	ori	gp,gp,52588
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	21136d04 	addi	r4,r4,19892
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	210ea804 	addi	r4,r4,15008
811002bc:	11385000 	call	81138500 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04574 	movhi	r2,33045
    ori r2, r2, %lo(__bss_start)
811002c4:	10939214 	ori	r2,r2,20040

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18fc2d14 	ori	r3,r3,61620

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	21136d04 	addi	r4,r4,19892
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	210eaf04 	addi	r4,r4,15036
811002fc:	11385000 	call	81138500 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	113912c0 	call	8113912c <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18d46d04 	addi	r3,r3,20916
81100330:	00a04574 	movhi	r2,33045
81100334:	10b45504 	addi	r2,r2,-11948
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	11243500 	call	81124350 <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a06217 	ldw	r2,-32376(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	29546d04 	addi	r5,r5,20916
8110035c:	1009883a 	mov	r4,r2
81100360:	11232a00 	call	811232a0 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess = FALSE;
8110036c:	e03ff915 	stw	zero,-28(fp)
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	switch (ucMemoryId) {
81100370:	e0bfff03 	ldbu	r2,-4(fp)
81100374:	10000326 	beq	r2,zero,81100384 <bDdr2EepromTest+0x7c>
81100378:	10800060 	cmpeqi	r2,r2,1
8110037c:	10000a1e 	bne	r2,zero,811003a8 <bDdr2EepromTest+0xa0>
81100380:	00001206 	br	811003cc <bDdr2EepromTest+0xc4>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100384:	00a00034 	movhi	r2,32768
81100388:	10827c04 	addi	r2,r2,2544
8110038c:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100390:	00a00034 	movhi	r2,32768
81100394:	10828004 	addi	r2,r2,2560
81100398:	e0bffb15 	stw	r2,-20(fp)
		bSuccess = TRUE;
8110039c:	00800044 	movi	r2,1
811003a0:	e0bff915 	stw	r2,-28(fp)
		break;
811003a4:	00001b06 	br	81100414 <bDdr2EepromTest+0x10c>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a8:	00a00034 	movhi	r2,32768
811003ac:	10825804 	addi	r2,r2,2400
811003b0:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b4:	00a00034 	movhi	r2,32768
811003b8:	10825c04 	addi	r2,r2,2416
811003bc:	e0bffb15 	stw	r2,-20(fp)
		bSuccess = TRUE;
811003c0:	00800044 	movi	r2,1
811003c4:	e0bff915 	stw	r2,-28(fp)
		break;
811003c8:	00001206 	br	81100414 <bDdr2EepromTest+0x10c>
	default:
		bSuccess = FALSE;
811003cc:	e03ff915 	stw	zero,-28(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
811003d0:	00e04574 	movhi	r3,33045
811003d4:	18d46d04 	addi	r3,r3,20916
811003d8:	00a04574 	movhi	r2,33045
811003dc:	10b45e04 	addi	r2,r2,-11912
811003e0:	1009883a 	mov	r4,r2
811003e4:	00800bc4 	movi	r2,47
811003e8:	100d883a 	mov	r6,r2
811003ec:	200b883a 	mov	r5,r4
811003f0:	1809883a 	mov	r4,r3
811003f4:	11243500 	call	81124350 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003f8:	d0a06217 	ldw	r2,-32376(gp)
811003fc:	01604574 	movhi	r5,33045
81100400:	29546d04 	addi	r5,r5,20916
81100404:	1009883a 	mov	r4,r2
81100408:	11232a00 	call	811232a0 <fprintf>
		;
#endif
		return bSuccess;
8110040c:	e0bff917 	ldw	r2,-28(fp)
81100410:	0000ff06 	br	81100810 <bDdr2EepromTest+0x508>
	}

	alt_u8 ucControlAddr, ucValue;
#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100414:	00e04574 	movhi	r3,33045
81100418:	18d46d04 	addi	r3,r3,20916
8110041c:	00a04574 	movhi	r2,33045
81100420:	10b46a04 	addi	r2,r2,-11864
81100424:	1009883a 	mov	r4,r2
81100428:	008005c4 	movi	r2,23
8110042c:	100d883a 	mov	r6,r2
81100430:	200b883a 	mov	r5,r4
81100434:	1809883a 	mov	r4,r3
81100438:	11243500 	call	81124350 <memcpy>
	debug(fp, cDebugBuffer);
8110043c:	d0a06217 	ldw	r2,-32376(gp)
81100440:	01604574 	movhi	r5,33045
81100444:	29546d04 	addi	r5,r5,20916
81100448:	1009883a 	mov	r4,r2
8110044c:	11232a00 	call	811232a0 <fprintf>
#endif
	usleep(20 * 1000);
81100450:	01138804 	movi	r4,20000
81100454:	11399580 	call	81139958 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100458:	e03ffc15 	stw	zero,-16(fp)
8110045c:	00003306 	br	8110052c <bDdr2EepromTest+0x224>
		ucControlAddr = iI;
81100460:	e0bffc17 	ldw	r2,-16(fp)
81100464:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100468:	e0bffd03 	ldbu	r2,-12(fp)
8110046c:	10c03fcc 	andi	r3,r2,255
81100470:	18c0201c 	xori	r3,r3,128
81100474:	18ffe004 	addi	r3,r3,-128
81100478:	e13ffd43 	ldbu	r4,-11(fp)
8110047c:	e0bffe04 	addi	r2,fp,-8
81100480:	d8800015 	stw	r2,0(sp)
81100484:	200f883a 	mov	r7,r4
81100488:	180d883a 	mov	r6,r3
8110048c:	e17ffb17 	ldw	r5,-20(fp)
81100490:	e13ffa17 	ldw	r4,-24(fp)
81100494:	110b2680 	call	8110b268 <I2C_Read>
81100498:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
8110049c:	e0bff917 	ldw	r2,-28(fp)
811004a0:	10001026 	beq	r2,zero,811004e4 <bDdr2EepromTest+0x1dc>
#if DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
811004a4:	e0bffd43 	ldbu	r2,-11(fp)
811004a8:	e0fffe03 	ldbu	r3,-8(fp)
811004ac:	18c03fcc 	andi	r3,r3,255
811004b0:	180f883a 	mov	r7,r3
811004b4:	100d883a 	mov	r6,r2
811004b8:	01604574 	movhi	r5,33045
811004bc:	29747004 	addi	r5,r5,-11840
811004c0:	01204574 	movhi	r4,33045
811004c4:	21146d04 	addi	r4,r4,20916
811004c8:	1124bb40 	call	81124bb4 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004cc:	d0a06217 	ldw	r2,-32376(gp)
811004d0:	01604574 	movhi	r5,33045
811004d4:	29546d04 	addi	r5,r5,20916
811004d8:	1009883a 	mov	r4,r2
811004dc:	11232a00 	call	811232a0 <fprintf>
811004e0:	00000f06 	br	81100520 <bDdr2EepromTest+0x218>
#endif
		} else {
#if DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004e4:	00e04574 	movhi	r3,33045
811004e8:	18d46d04 	addi	r3,r3,20916
811004ec:	00a04574 	movhi	r2,33045
811004f0:	10b47504 	addi	r2,r2,-11820
811004f4:	1009883a 	mov	r4,r2
811004f8:	008005c4 	movi	r2,23
811004fc:	100d883a 	mov	r6,r2
81100500:	200b883a 	mov	r5,r4
81100504:	1809883a 	mov	r4,r3
81100508:	11243500 	call	81124350 <memcpy>
			debug(fp, cDebugBuffer);
8110050c:	d0a06217 	ldw	r2,-32376(gp)
81100510:	01604574 	movhi	r5,33045
81100514:	29546d04 	addi	r5,r5,20916
81100518:	1009883a 	mov	r4,r2
8110051c:	11232a00 	call	811232a0 <fprintf>
#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10800044 	addi	r2,r2,1
81100528:	e0bffc15 	stw	r2,-16(fp)
8110052c:	e0bffc17 	ldw	r2,-16(fp)
81100530:	10804008 	cmpgei	r2,r2,256
81100534:	1000021e 	bne	r2,zero,81100540 <bDdr2EepromTest+0x238>
81100538:	e0bff917 	ldw	r2,-28(fp)
8110053c:	103fc81e 	bne	r2,zero,81100460 <__reset+0xfb0e0460>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100540:	e0bff917 	ldw	r2,-28(fp)
81100544:	10001026 	beq	r2,zero,81100588 <bDdr2EepromTest+0x280>
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
81100548:	00e04574 	movhi	r3,33045
8110054c:	18d46d04 	addi	r3,r3,20916
81100550:	00a04574 	movhi	r2,33045
81100554:	10b47b04 	addi	r2,r2,-11796
81100558:	1009883a 	mov	r4,r2
8110055c:	00800884 	movi	r2,34
81100560:	100d883a 	mov	r6,r2
81100564:	200b883a 	mov	r5,r4
81100568:	1809883a 	mov	r4,r3
8110056c:	11243500 	call	81124350 <memcpy>
		debug(fp, cDebugBuffer);
81100570:	d0a06217 	ldw	r2,-32376(gp)
81100574:	01604574 	movhi	r5,33045
81100578:	29546d04 	addi	r5,r5,20916
8110057c:	1009883a 	mov	r4,r2
81100580:	11232a00 	call	811232a0 <fprintf>
81100584:	00000f06 	br	811005c4 <bDdr2EepromTest+0x2bc>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
81100588:	00e04574 	movhi	r3,33045
8110058c:	18d46d04 	addi	r3,r3,20916
81100590:	00a04574 	movhi	r2,33045
81100594:	10b48404 	addi	r2,r2,-11760
81100598:	1009883a 	mov	r4,r2
8110059c:	008007c4 	movi	r2,31
811005a0:	100d883a 	mov	r6,r2
811005a4:	200b883a 	mov	r5,r4
811005a8:	1809883a 	mov	r4,r3
811005ac:	11243500 	call	81124350 <memcpy>
		debug(fp, cDebugBuffer);
811005b0:	d0a06217 	ldw	r2,-32376(gp)
811005b4:	01604574 	movhi	r5,33045
811005b8:	29546d04 	addi	r5,r5,20916
811005bc:	1009883a 	mov	r4,r2
811005c0:	11232a00 	call	811232a0 <fprintf>
#endif
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005c4:	00e04574 	movhi	r3,33045
811005c8:	18d46d04 	addi	r3,r3,20916
811005cc:	00a04574 	movhi	r2,33045
811005d0:	10b48c04 	addi	r2,r2,-11728
811005d4:	1009883a 	mov	r4,r2
811005d8:	00800604 	movi	r2,24
811005dc:	100d883a 	mov	r6,r2
811005e0:	200b883a 	mov	r5,r4
811005e4:	1809883a 	mov	r4,r3
811005e8:	11243500 	call	81124350 <memcpy>
	debug(fp, cDebugBuffer);
811005ec:	d0a06217 	ldw	r2,-32376(gp)
811005f0:	01604574 	movhi	r5,33045
811005f4:	29546d04 	addi	r5,r5,20916
811005f8:	1009883a 	mov	r4,r2
811005fc:	11232a00 	call	811232a0 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
81100600:	00800484 	movi	r2,18
81100604:	e0bffd85 	stb	r2,-10(fp)
81100608:	00bfe004 	movi	r2,-128
8110060c:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100610:	01138804 	movi	r4,20000
81100614:	11399580 	call	81139958 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100618:	e0bffd03 	ldbu	r2,-12(fp)
8110061c:	10c03fcc 	andi	r3,r2,255
81100620:	18c0201c 	xori	r3,r3,128
81100624:	18ffe004 	addi	r3,r3,-128
81100628:	e13ffdc3 	ldbu	r4,-9(fp)
8110062c:	e0bffd83 	ldbu	r2,-10(fp)
81100630:	d8800015 	stw	r2,0(sp)
81100634:	200f883a 	mov	r7,r4
81100638:	180d883a 	mov	r6,r3
8110063c:	e17ffb17 	ldw	r5,-20(fp)
81100640:	e13ffa17 	ldw	r4,-24(fp)
81100644:	110b1880 	call	8110b188 <I2C_Write>
81100648:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
8110064c:	e0bff917 	ldw	r2,-28(fp)
81100650:	1000101e 	bne	r2,zero,81100694 <bDdr2EepromTest+0x38c>
#if DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100654:	00e04574 	movhi	r3,33045
81100658:	18d46d04 	addi	r3,r3,20916
8110065c:	00a04574 	movhi	r2,33045
81100660:	10b49204 	addi	r2,r2,-11704
81100664:	1009883a 	mov	r4,r2
81100668:	00800604 	movi	r2,24
8110066c:	100d883a 	mov	r6,r2
81100670:	200b883a 	mov	r5,r4
81100674:	1809883a 	mov	r4,r3
81100678:	11243500 	call	81124350 <memcpy>
		debug(fp, cDebugBuffer);
8110067c:	d0a06217 	ldw	r2,-32376(gp)
81100680:	01604574 	movhi	r5,33045
81100684:	29546d04 	addi	r5,r5,20916
81100688:	1009883a 	mov	r4,r2
8110068c:	11232a00 	call	811232a0 <fprintf>
81100690:	00003306 	br	81100760 <bDdr2EepromTest+0x458>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100694:	e0bffd03 	ldbu	r2,-12(fp)
81100698:	10c03fcc 	andi	r3,r2,255
8110069c:	18c0201c 	xori	r3,r3,128
811006a0:	18ffe004 	addi	r3,r3,-128
811006a4:	e13ffdc3 	ldbu	r4,-9(fp)
811006a8:	e0bffe44 	addi	r2,fp,-7
811006ac:	d8800015 	stw	r2,0(sp)
811006b0:	200f883a 	mov	r7,r4
811006b4:	180d883a 	mov	r6,r3
811006b8:	e17ffb17 	ldw	r5,-20(fp)
811006bc:	e13ffa17 	ldw	r4,-24(fp)
811006c0:	110b2680 	call	8110b268 <I2C_Read>
811006c4:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006c8:	e0bff917 	ldw	r2,-28(fp)
811006cc:	1000101e 	bne	r2,zero,81100710 <bDdr2EepromTest+0x408>
#if DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006d0:	00e04574 	movhi	r3,33045
811006d4:	18d46d04 	addi	r3,r3,20916
811006d8:	00a04574 	movhi	r2,33045
811006dc:	10b49804 	addi	r2,r2,-11680
811006e0:	1009883a 	mov	r4,r2
811006e4:	00800884 	movi	r2,34
811006e8:	100d883a 	mov	r6,r2
811006ec:	200b883a 	mov	r5,r4
811006f0:	1809883a 	mov	r4,r3
811006f4:	11243500 	call	81124350 <memcpy>
			debug(fp, cDebugBuffer);
811006f8:	d0a06217 	ldw	r2,-32376(gp)
811006fc:	01604574 	movhi	r5,33045
81100700:	29546d04 	addi	r5,r5,20916
81100704:	1009883a 	mov	r4,r2
81100708:	11232a00 	call	811232a0 <fprintf>
8110070c:	00001406 	br	81100760 <bDdr2EepromTest+0x458>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100710:	e0bffe43 	ldbu	r2,-7(fp)
81100714:	10c03fcc 	andi	r3,r2,255
81100718:	e0bffd83 	ldbu	r2,-10(fp)
8110071c:	18801026 	beq	r3,r2,81100760 <bDdr2EepromTest+0x458>
				bSuccess = FALSE;
81100720:	e03ff915 	stw	zero,-28(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100724:	e0bffe43 	ldbu	r2,-7(fp)
81100728:	10803fcc 	andi	r2,r2,255
8110072c:	e0fffd83 	ldbu	r3,-10(fp)
81100730:	180f883a 	mov	r7,r3
81100734:	100d883a 	mov	r6,r2
81100738:	01604574 	movhi	r5,33045
8110073c:	2974a104 	addi	r5,r5,-11644
81100740:	01204574 	movhi	r4,33045
81100744:	21146d04 	addi	r4,r4,20916
81100748:	1124bb40 	call	81124bb4 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
8110074c:	d0a06217 	ldw	r2,-32376(gp)
81100750:	01604574 	movhi	r5,33045
81100754:	29546d04 	addi	r5,r5,20916
81100758:	1009883a 	mov	r4,r2
8110075c:	11232a00 	call	811232a0 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100760:	e0bff917 	ldw	r2,-28(fp)
81100764:	10001026 	beq	r2,zero,811007a8 <bDdr2EepromTest+0x4a0>
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
81100768:	00e04574 	movhi	r3,33045
8110076c:	18d46d04 	addi	r3,r3,20916
81100770:	00a04574 	movhi	r2,33045
81100774:	10b4b004 	addi	r2,r2,-11584
81100778:	1009883a 	mov	r4,r2
8110077c:	008008c4 	movi	r2,35
81100780:	100d883a 	mov	r6,r2
81100784:	200b883a 	mov	r5,r4
81100788:	1809883a 	mov	r4,r3
8110078c:	11243500 	call	81124350 <memcpy>
		debug(fp, cDebugBuffer);
81100790:	d0a06217 	ldw	r2,-32376(gp)
81100794:	01604574 	movhi	r5,33045
81100798:	29546d04 	addi	r5,r5,20916
8110079c:	1009883a 	mov	r4,r2
811007a0:	11232a00 	call	811232a0 <fprintf>
811007a4:	00000f06 	br	811007e4 <bDdr2EepromTest+0x4dc>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
811007a8:	00e04574 	movhi	r3,33045
811007ac:	18d46d04 	addi	r3,r3,20916
811007b0:	00a04574 	movhi	r2,33045
811007b4:	10b4b904 	addi	r2,r2,-11548
811007b8:	1009883a 	mov	r4,r2
811007bc:	00800804 	movi	r2,32
811007c0:	100d883a 	mov	r6,r2
811007c4:	200b883a 	mov	r5,r4
811007c8:	1809883a 	mov	r4,r3
811007cc:	11243500 	call	81124350 <memcpy>
		debug(fp, cDebugBuffer);
811007d0:	d0a06217 	ldw	r2,-32376(gp)
811007d4:	01604574 	movhi	r5,33045
811007d8:	29546d04 	addi	r5,r5,20916
811007dc:	1009883a 	mov	r4,r2
811007e0:	11232a00 	call	811232a0 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007e4:	00a04574 	movhi	r2,33045
811007e8:	10946d04 	addi	r2,r2,20916
811007ec:	00c00284 	movi	r3,10
811007f0:	10c00005 	stb	r3,0(r2)
811007f4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007f8:	d0a06217 	ldw	r2,-32376(gp)
811007fc:	01604574 	movhi	r5,33045
81100800:	29546d04 	addi	r5,r5,20916
81100804:	1009883a 	mov	r4,r2
81100808:	11232a00 	call	811232a0 <fprintf>
#endif

	return bSuccess;
8110080c:	e0bff917 	ldw	r2,-28(fp)
}
81100810:	e037883a 	mov	sp,fp
81100814:	dfc00117 	ldw	ra,4(sp)
81100818:	df000017 	ldw	fp,0(sp)
8110081c:	dec00204 	addi	sp,sp,8
81100820:	f800283a 	ret

81100824 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100824:	deffb704 	addi	sp,sp,-292
81100828:	de00012e 	bgeu	sp,et,81100830 <bDdr2EepromDump+0xc>
8110082c:	003b68fa 	trap	3
81100830:	dfc04815 	stw	ra,288(sp)
81100834:	df004715 	stw	fp,284(sp)
81100838:	df004704 	addi	fp,sp,284
8110083c:	2005883a 	mov	r2,r4
81100840:	e0bfff05 	stb	r2,-4(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100844:	00e04574 	movhi	r3,33045
81100848:	18d46d04 	addi	r3,r3,20916
8110084c:	00a04574 	movhi	r2,33045
81100850:	10b4c104 	addi	r2,r2,-11516
81100854:	1009883a 	mov	r4,r2
81100858:	00800884 	movi	r2,34
8110085c:	100d883a 	mov	r6,r2
81100860:	200b883a 	mov	r5,r4
81100864:	1809883a 	mov	r4,r3
81100868:	11243500 	call	81124350 <memcpy>
	debug(fp, cDebugBuffer);
8110086c:	d0a06217 	ldw	r2,-32376(gp)
81100870:	01604574 	movhi	r5,33045
81100874:	29546d04 	addi	r5,r5,20916
81100878:	1009883a 	mov	r4,r2
8110087c:	11232a00 	call	811232a0 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100880:	00bfe804 	movi	r2,-96
81100884:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess = FALSE;
81100888:	e03fbe15 	stw	zero,-264(fp)
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	switch (ucMemoryId) {
8110088c:	e0bfff03 	ldbu	r2,-4(fp)
81100890:	10000326 	beq	r2,zero,811008a0 <bDdr2EepromDump+0x7c>
81100894:	10800060 	cmpeqi	r2,r2,1
81100898:	10000a1e 	bne	r2,zero,811008c4 <bDdr2EepromDump+0xa0>
8110089c:	00001206 	br	811008e8 <bDdr2EepromDump+0xc4>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
811008a0:	00a00034 	movhi	r2,32768
811008a4:	10827c04 	addi	r2,r2,2544
811008a8:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008ac:	00a00034 	movhi	r2,32768
811008b0:	10828004 	addi	r2,r2,2560
811008b4:	e0bfbb15 	stw	r2,-276(fp)
		bSuccess = TRUE;
811008b8:	00800044 	movi	r2,1
811008bc:	e0bfbe15 	stw	r2,-264(fp)
		break;
811008c0:	00001b06 	br	81100930 <bDdr2EepromDump+0x10c>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008c4:	00a00034 	movhi	r2,32768
811008c8:	10825804 	addi	r2,r2,2400
811008cc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008d0:	00a00034 	movhi	r2,32768
811008d4:	10825c04 	addi	r2,r2,2416
811008d8:	e0bfbb15 	stw	r2,-276(fp)
		bSuccess = TRUE;
811008dc:	00800044 	movi	r2,1
811008e0:	e0bfbe15 	stw	r2,-264(fp)
		break;
811008e4:	00001206 	br	81100930 <bDdr2EepromDump+0x10c>
	default:
		bSuccess = FALSE;
811008e8:	e03fbe15 	stw	zero,-264(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
811008ec:	00e04574 	movhi	r3,33045
811008f0:	18d46d04 	addi	r3,r3,20916
811008f4:	00a04574 	movhi	r2,33045
811008f8:	10b4ca04 	addi	r2,r2,-11480
811008fc:	1009883a 	mov	r4,r2
81100900:	00800bc4 	movi	r2,47
81100904:	100d883a 	mov	r6,r2
81100908:	200b883a 	mov	r5,r4
8110090c:	1809883a 	mov	r4,r3
81100910:	11243500 	call	81124350 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
81100914:	d0a06217 	ldw	r2,-32376(gp)
81100918:	01604574 	movhi	r5,33045
8110091c:	29546d04 	addi	r5,r5,20916
81100920:	1009883a 	mov	r4,r2
81100924:	11232a00 	call	811232a0 <fprintf>
		;
#endif
		return bSuccess;
81100928:	e0bfbe17 	ldw	r2,-264(fp)
8110092c:	0002e706 	br	811014cc <bDdr2EepromDump+0xca8>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100930:	e0bfbd03 	ldbu	r2,-268(fp)
81100934:	10c03fcc 	andi	r3,r2,255
81100938:	18c0201c 	xori	r3,r3,128
8110093c:	18ffe004 	addi	r3,r3,-128
81100940:	e13fbf04 	addi	r4,fp,-260
81100944:	00804004 	movi	r2,256
81100948:	d8800015 	stw	r2,0(sp)
8110094c:	200f883a 	mov	r7,r4
81100950:	180d883a 	mov	r6,r3
81100954:	e17fbb17 	ldw	r5,-276(fp)
81100958:	e13fba17 	ldw	r4,-280(fp)
8110095c:	110b3700 	call	8110b370 <I2C_MultipleRead>
81100960:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
81100964:	e0bfbe17 	ldw	r2,-264(fp)
81100968:	1002be26 	beq	r2,zero,81101464 <bDdr2EepromDump+0xc40>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
8110096c:	e03fbc15 	stw	zero,-272(fp)
81100970:	0002b606 	br	8110144c <bDdr2EepromDump+0xc28>
			if (iI == 0) {
81100974:	e0bfbc17 	ldw	r2,-272(fp)
81100978:	1000121e 	bne	r2,zero,811009c4 <bDdr2EepromDump+0x1a0>
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
8110097c:	e0ffbf04 	addi	r3,fp,-260
81100980:	e0bfbc17 	ldw	r2,-272(fp)
81100984:	1885883a 	add	r2,r3,r2
81100988:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
8110098c:	10803fcc 	andi	r2,r2,255
81100990:	100f883a 	mov	r7,r2
81100994:	e1bfbc17 	ldw	r6,-272(fp)
81100998:	01604574 	movhi	r5,33045
8110099c:	2974d604 	addi	r5,r5,-11432
811009a0:	01204574 	movhi	r4,33045
811009a4:	21146d04 	addi	r4,r4,20916
811009a8:	1124bb40 	call	81124bb4 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
811009ac:	d0a06217 	ldw	r2,-32376(gp)
811009b0:	01604574 	movhi	r5,33045
811009b4:	29546d04 	addi	r5,r5,20916
811009b8:	1009883a 	mov	r4,r2
811009bc:	11232a00 	call	811232a0 <fprintf>
811009c0:	00029f06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 1) {
811009c4:	e0bfbc17 	ldw	r2,-272(fp)
811009c8:	10800058 	cmpnei	r2,r2,1
811009cc:	1000101e 	bne	r2,zero,81100a10 <bDdr2EepromDump+0x1ec>
#if DEBUG_ON
				sprintf(cDebugBuffer,
811009d0:	00e04574 	movhi	r3,33045
811009d4:	18d46d04 	addi	r3,r3,20916
811009d8:	00a04574 	movhi	r2,33045
811009dc:	10b4e204 	addi	r2,r2,-11384
811009e0:	1009883a 	mov	r4,r2
811009e4:	00800c04 	movi	r2,48
811009e8:	100d883a 	mov	r6,r2
811009ec:	200b883a 	mov	r5,r4
811009f0:	1809883a 	mov	r4,r3
811009f4:	11243500 	call	81124350 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009f8:	d0a06217 	ldw	r2,-32376(gp)
811009fc:	01604574 	movhi	r5,33045
81100a00:	29546d04 	addi	r5,r5,20916
81100a04:	1009883a 	mov	r4,r2
81100a08:	11232a00 	call	811232a0 <fprintf>
81100a0c:	00028c06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 2) {
81100a10:	e0bfbc17 	ldw	r2,-272(fp)
81100a14:	10800098 	cmpnei	r2,r2,2
81100a18:	1000101e 	bne	r2,zero,81100a5c <bDdr2EepromDump+0x238>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a1c:	00e04574 	movhi	r3,33045
81100a20:	18d46d04 	addi	r3,r3,20916
81100a24:	00a04574 	movhi	r2,33045
81100a28:	10b4ee04 	addi	r2,r2,-11336
81100a2c:	1009883a 	mov	r4,r2
81100a30:	008007c4 	movi	r2,31
81100a34:	100d883a 	mov	r6,r2
81100a38:	200b883a 	mov	r5,r4
81100a3c:	1809883a 	mov	r4,r3
81100a40:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
81100a44:	d0a06217 	ldw	r2,-32376(gp)
81100a48:	01604574 	movhi	r5,33045
81100a4c:	29546d04 	addi	r5,r5,20916
81100a50:	1009883a 	mov	r4,r2
81100a54:	11232a00 	call	811232a0 <fprintf>
81100a58:	00027906 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 3) {
81100a5c:	e0bfbc17 	ldw	r2,-272(fp)
81100a60:	108000d8 	cmpnei	r2,r2,3
81100a64:	1000101e 	bne	r2,zero,81100aa8 <bDdr2EepromDump+0x284>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100a68:	00e04574 	movhi	r3,33045
81100a6c:	18d46d04 	addi	r3,r3,20916
81100a70:	00a04574 	movhi	r2,33045
81100a74:	10b4f604 	addi	r2,r2,-11304
81100a78:	1009883a 	mov	r4,r2
81100a7c:	008009c4 	movi	r2,39
81100a80:	100d883a 	mov	r6,r2
81100a84:	200b883a 	mov	r5,r4
81100a88:	1809883a 	mov	r4,r3
81100a8c:	11243500 	call	81124350 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a90:	d0a06217 	ldw	r2,-32376(gp)
81100a94:	01604574 	movhi	r5,33045
81100a98:	29546d04 	addi	r5,r5,20916
81100a9c:	1009883a 	mov	r4,r2
81100aa0:	11232a00 	call	811232a0 <fprintf>
81100aa4:	00026606 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 4) {
81100aa8:	e0bfbc17 	ldw	r2,-272(fp)
81100aac:	10800118 	cmpnei	r2,r2,4
81100ab0:	1000101e 	bne	r2,zero,81100af4 <bDdr2EepromDump+0x2d0>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100ab4:	00e04574 	movhi	r3,33045
81100ab8:	18d46d04 	addi	r3,r3,20916
81100abc:	00a04574 	movhi	r2,33045
81100ac0:	10b50004 	addi	r2,r2,-11264
81100ac4:	1009883a 	mov	r4,r2
81100ac8:	00800a84 	movi	r2,42
81100acc:	100d883a 	mov	r6,r2
81100ad0:	200b883a 	mov	r5,r4
81100ad4:	1809883a 	mov	r4,r3
81100ad8:	11243500 	call	81124350 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100adc:	d0a06217 	ldw	r2,-32376(gp)
81100ae0:	01604574 	movhi	r5,33045
81100ae4:	29546d04 	addi	r5,r5,20916
81100ae8:	1009883a 	mov	r4,r2
81100aec:	11232a00 	call	811232a0 <fprintf>
81100af0:	00025306 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 5) {
81100af4:	e0bfbc17 	ldw	r2,-272(fp)
81100af8:	10800158 	cmpnei	r2,r2,5
81100afc:	1000101e 	bne	r2,zero,81100b40 <bDdr2EepromDump+0x31c>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100b00:	00e04574 	movhi	r3,33045
81100b04:	18d46d04 	addi	r3,r3,20916
81100b08:	00a04574 	movhi	r2,33045
81100b0c:	10b50b04 	addi	r2,r2,-11220
81100b10:	1009883a 	mov	r4,r2
81100b14:	00800c04 	movi	r2,48
81100b18:	100d883a 	mov	r6,r2
81100b1c:	200b883a 	mov	r5,r4
81100b20:	1809883a 	mov	r4,r3
81100b24:	11243500 	call	81124350 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b28:	d0a06217 	ldw	r2,-32376(gp)
81100b2c:	01604574 	movhi	r5,33045
81100b30:	29546d04 	addi	r5,r5,20916
81100b34:	1009883a 	mov	r4,r2
81100b38:	11232a00 	call	811232a0 <fprintf>
81100b3c:	00024006 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 6) {
81100b40:	e0bfbc17 	ldw	r2,-272(fp)
81100b44:	10800198 	cmpnei	r2,r2,6
81100b48:	1000101e 	bne	r2,zero,81100b8c <bDdr2EepromDump+0x368>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b4c:	00e04574 	movhi	r3,33045
81100b50:	18d46d04 	addi	r3,r3,20916
81100b54:	00a04574 	movhi	r2,33045
81100b58:	10b51704 	addi	r2,r2,-11172
81100b5c:	1009883a 	mov	r4,r2
81100b60:	00800544 	movi	r2,21
81100b64:	100d883a 	mov	r6,r2
81100b68:	200b883a 	mov	r5,r4
81100b6c:	1809883a 	mov	r4,r3
81100b70:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
81100b74:	d0a06217 	ldw	r2,-32376(gp)
81100b78:	01604574 	movhi	r5,33045
81100b7c:	29546d04 	addi	r5,r5,20916
81100b80:	1009883a 	mov	r4,r2
81100b84:	11232a00 	call	811232a0 <fprintf>
81100b88:	00022d06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 7) {
81100b8c:	e0bfbc17 	ldw	r2,-272(fp)
81100b90:	108001d8 	cmpnei	r2,r2,7
81100b94:	1000101e 	bne	r2,zero,81100bd8 <bDdr2EepromDump+0x3b4>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b98:	00e04574 	movhi	r3,33045
81100b9c:	18d46d04 	addi	r3,r3,20916
81100ba0:	00a04574 	movhi	r2,33045
81100ba4:	10b51d04 	addi	r2,r2,-11148
81100ba8:	1009883a 	mov	r4,r2
81100bac:	00800804 	movi	r2,32
81100bb0:	100d883a 	mov	r6,r2
81100bb4:	200b883a 	mov	r5,r4
81100bb8:	1809883a 	mov	r4,r3
81100bbc:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
81100bc0:	d0a06217 	ldw	r2,-32376(gp)
81100bc4:	01604574 	movhi	r5,33045
81100bc8:	29546d04 	addi	r5,r5,20916
81100bcc:	1009883a 	mov	r4,r2
81100bd0:	11232a00 	call	811232a0 <fprintf>
81100bd4:	00021a06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 16) {
81100bd8:	e0bfbc17 	ldw	r2,-272(fp)
81100bdc:	10800418 	cmpnei	r2,r2,16
81100be0:	1000101e 	bne	r2,zero,81100c24 <bDdr2EepromDump+0x400>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100be4:	00e04574 	movhi	r3,33045
81100be8:	18d46d04 	addi	r3,r3,20916
81100bec:	00a04574 	movhi	r2,33045
81100bf0:	10b52504 	addi	r2,r2,-11116
81100bf4:	1009883a 	mov	r4,r2
81100bf8:	00800d04 	movi	r2,52
81100bfc:	100d883a 	mov	r6,r2
81100c00:	200b883a 	mov	r5,r4
81100c04:	1809883a 	mov	r4,r3
81100c08:	11243500 	call	81124350 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100c0c:	d0a06217 	ldw	r2,-32376(gp)
81100c10:	01604574 	movhi	r5,33045
81100c14:	29546d04 	addi	r5,r5,20916
81100c18:	1009883a 	mov	r4,r2
81100c1c:	11232a00 	call	811232a0 <fprintf>
81100c20:	00020706 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 13) {
81100c24:	e0bfbc17 	ldw	r2,-272(fp)
81100c28:	10800358 	cmpnei	r2,r2,13
81100c2c:	1000101e 	bne	r2,zero,81100c70 <bDdr2EepromDump+0x44c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c30:	00e04574 	movhi	r3,33045
81100c34:	18d46d04 	addi	r3,r3,20916
81100c38:	00a04574 	movhi	r2,33045
81100c3c:	10b53204 	addi	r2,r2,-11064
81100c40:	1009883a 	mov	r4,r2
81100c44:	008005c4 	movi	r2,23
81100c48:	100d883a 	mov	r6,r2
81100c4c:	200b883a 	mov	r5,r4
81100c50:	1809883a 	mov	r4,r3
81100c54:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
81100c58:	d0a06217 	ldw	r2,-32376(gp)
81100c5c:	01604574 	movhi	r5,33045
81100c60:	29546d04 	addi	r5,r5,20916
81100c64:	1009883a 	mov	r4,r2
81100c68:	11232a00 	call	811232a0 <fprintf>
81100c6c:	0001f406 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 14) {
81100c70:	e0bfbc17 	ldw	r2,-272(fp)
81100c74:	10800398 	cmpnei	r2,r2,14
81100c78:	1000101e 	bne	r2,zero,81100cbc <bDdr2EepromDump+0x498>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c7c:	00e04574 	movhi	r3,33045
81100c80:	18d46d04 	addi	r3,r3,20916
81100c84:	00a04574 	movhi	r2,33045
81100c88:	10b53804 	addi	r2,r2,-11040
81100c8c:	1009883a 	mov	r4,r2
81100c90:	008004c4 	movi	r2,19
81100c94:	100d883a 	mov	r6,r2
81100c98:	200b883a 	mov	r5,r4
81100c9c:	1809883a 	mov	r4,r3
81100ca0:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
81100ca4:	d0a06217 	ldw	r2,-32376(gp)
81100ca8:	01604574 	movhi	r5,33045
81100cac:	29546d04 	addi	r5,r5,20916
81100cb0:	1009883a 	mov	r4,r2
81100cb4:	11232a00 	call	811232a0 <fprintf>
81100cb8:	0001e106 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 17) {
81100cbc:	e0bfbc17 	ldw	r2,-272(fp)
81100cc0:	10800458 	cmpnei	r2,r2,17
81100cc4:	1000101e 	bne	r2,zero,81100d08 <bDdr2EepromDump+0x4e4>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cc8:	00e04574 	movhi	r3,33045
81100ccc:	18d46d04 	addi	r3,r3,20916
81100cd0:	00a04574 	movhi	r2,33045
81100cd4:	10b53d04 	addi	r2,r2,-11020
81100cd8:	1009883a 	mov	r4,r2
81100cdc:	00800684 	movi	r2,26
81100ce0:	100d883a 	mov	r6,r2
81100ce4:	200b883a 	mov	r5,r4
81100ce8:	1809883a 	mov	r4,r3
81100cec:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
81100cf0:	d0a06217 	ldw	r2,-32376(gp)
81100cf4:	01604574 	movhi	r5,33045
81100cf8:	29546d04 	addi	r5,r5,20916
81100cfc:	1009883a 	mov	r4,r2
81100d00:	11232a00 	call	811232a0 <fprintf>
81100d04:	0001ce06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 18) {
81100d08:	e0bfbc17 	ldw	r2,-272(fp)
81100d0c:	10800498 	cmpnei	r2,r2,18
81100d10:	1000101e 	bne	r2,zero,81100d54 <bDdr2EepromDump+0x530>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100d14:	00e04574 	movhi	r3,33045
81100d18:	18d46d04 	addi	r3,r3,20916
81100d1c:	00a04574 	movhi	r2,33045
81100d20:	10b54404 	addi	r2,r2,-10992
81100d24:	1009883a 	mov	r4,r2
81100d28:	00800d44 	movi	r2,53
81100d2c:	100d883a 	mov	r6,r2
81100d30:	200b883a 	mov	r5,r4
81100d34:	1809883a 	mov	r4,r3
81100d38:	11243500 	call	81124350 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d3c:	d0a06217 	ldw	r2,-32376(gp)
81100d40:	01604574 	movhi	r5,33045
81100d44:	29546d04 	addi	r5,r5,20916
81100d48:	1009883a 	mov	r4,r2
81100d4c:	11232a00 	call	811232a0 <fprintf>
81100d50:	0001bb06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 20) {
81100d54:	e0bfbc17 	ldw	r2,-272(fp)
81100d58:	10800518 	cmpnei	r2,r2,20
81100d5c:	1000101e 	bne	r2,zero,81100da0 <bDdr2EepromDump+0x57c>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100d60:	00e04574 	movhi	r3,33045
81100d64:	18d46d04 	addi	r3,r3,20916
81100d68:	00a04574 	movhi	r2,33045
81100d6c:	10b55204 	addi	r2,r2,-10936
81100d70:	1009883a 	mov	r4,r2
81100d74:	00801204 	movi	r2,72
81100d78:	100d883a 	mov	r6,r2
81100d7c:	200b883a 	mov	r5,r4
81100d80:	1809883a 	mov	r4,r3
81100d84:	11243500 	call	81124350 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d88:	d0a06217 	ldw	r2,-32376(gp)
81100d8c:	01604574 	movhi	r5,33045
81100d90:	29546d04 	addi	r5,r5,20916
81100d94:	1009883a 	mov	r4,r2
81100d98:	11232a00 	call	811232a0 <fprintf>
81100d9c:	0001a806 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 22) {
81100da0:	e0bfbc17 	ldw	r2,-272(fp)
81100da4:	10800598 	cmpnei	r2,r2,22
81100da8:	1000101e 	bne	r2,zero,81100dec <bDdr2EepromDump+0x5c8>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100dac:	00e04574 	movhi	r3,33045
81100db0:	18d46d04 	addi	r3,r3,20916
81100db4:	00a04574 	movhi	r2,33045
81100db8:	10b56404 	addi	r2,r2,-10864
81100dbc:	1009883a 	mov	r4,r2
81100dc0:	00800784 	movi	r2,30
81100dc4:	100d883a 	mov	r6,r2
81100dc8:	200b883a 	mov	r5,r4
81100dcc:	1809883a 	mov	r4,r3
81100dd0:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
81100dd4:	d0a06217 	ldw	r2,-32376(gp)
81100dd8:	01604574 	movhi	r5,33045
81100ddc:	29546d04 	addi	r5,r5,20916
81100de0:	1009883a 	mov	r4,r2
81100de4:	11232a00 	call	811232a0 <fprintf>
81100de8:	00019506 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 27) {
81100dec:	e0bfbc17 	ldw	r2,-272(fp)
81100df0:	108006d8 	cmpnei	r2,r2,27
81100df4:	1000101e 	bne	r2,zero,81100e38 <bDdr2EepromDump+0x614>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100df8:	00e04574 	movhi	r3,33045
81100dfc:	18d46d04 	addi	r3,r3,20916
81100e00:	00a04574 	movhi	r2,33045
81100e04:	10b56c04 	addi	r2,r2,-10832
81100e08:	1009883a 	mov	r4,r2
81100e0c:	00800a04 	movi	r2,40
81100e10:	100d883a 	mov	r6,r2
81100e14:	200b883a 	mov	r5,r4
81100e18:	1809883a 	mov	r4,r3
81100e1c:	11243500 	call	81124350 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e20:	d0a06217 	ldw	r2,-32376(gp)
81100e24:	01604574 	movhi	r5,33045
81100e28:	29546d04 	addi	r5,r5,20916
81100e2c:	1009883a 	mov	r4,r2
81100e30:	11232a00 	call	811232a0 <fprintf>
81100e34:	00018206 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 28) {
81100e38:	e0bfbc17 	ldw	r2,-272(fp)
81100e3c:	10800718 	cmpnei	r2,r2,28
81100e40:	1000101e 	bne	r2,zero,81100e84 <bDdr2EepromDump+0x660>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100e44:	00e04574 	movhi	r3,33045
81100e48:	18d46d04 	addi	r3,r3,20916
81100e4c:	00a04574 	movhi	r2,33045
81100e50:	10b57604 	addi	r2,r2,-10792
81100e54:	1009883a 	mov	r4,r2
81100e58:	00800cc4 	movi	r2,51
81100e5c:	100d883a 	mov	r6,r2
81100e60:	200b883a 	mov	r5,r4
81100e64:	1809883a 	mov	r4,r3
81100e68:	11243500 	call	81124350 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e6c:	d0a06217 	ldw	r2,-32376(gp)
81100e70:	01604574 	movhi	r5,33045
81100e74:	29546d04 	addi	r5,r5,20916
81100e78:	1009883a 	mov	r4,r2
81100e7c:	11232a00 	call	811232a0 <fprintf>
81100e80:	00016f06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 29) {
81100e84:	e0bfbc17 	ldw	r2,-272(fp)
81100e88:	10800758 	cmpnei	r2,r2,29
81100e8c:	1000101e 	bne	r2,zero,81100ed0 <bDdr2EepromDump+0x6ac>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100e90:	00e04574 	movhi	r3,33045
81100e94:	18d46d04 	addi	r3,r3,20916
81100e98:	00a04574 	movhi	r2,33045
81100e9c:	10b58304 	addi	r2,r2,-10740
81100ea0:	1009883a 	mov	r4,r2
81100ea4:	008009c4 	movi	r2,39
81100ea8:	100d883a 	mov	r6,r2
81100eac:	200b883a 	mov	r5,r4
81100eb0:	1809883a 	mov	r4,r3
81100eb4:	11243500 	call	81124350 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100eb8:	d0a06217 	ldw	r2,-32376(gp)
81100ebc:	01604574 	movhi	r5,33045
81100ec0:	29546d04 	addi	r5,r5,20916
81100ec4:	1009883a 	mov	r4,r2
81100ec8:	11232a00 	call	811232a0 <fprintf>
81100ecc:	00015c06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 30) {
81100ed0:	e0bfbc17 	ldw	r2,-272(fp)
81100ed4:	10800798 	cmpnei	r2,r2,30
81100ed8:	1000101e 	bne	r2,zero,81100f1c <bDdr2EepromDump+0x6f8>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100edc:	00e04574 	movhi	r3,33045
81100ee0:	18d46d04 	addi	r3,r3,20916
81100ee4:	00a04574 	movhi	r2,33045
81100ee8:	10b58d04 	addi	r2,r2,-10700
81100eec:	1009883a 	mov	r4,r2
81100ef0:	00800b04 	movi	r2,44
81100ef4:	100d883a 	mov	r6,r2
81100ef8:	200b883a 	mov	r5,r4
81100efc:	1809883a 	mov	r4,r3
81100f00:	11243500 	call	81124350 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100f04:	d0a06217 	ldw	r2,-32376(gp)
81100f08:	01604574 	movhi	r5,33045
81100f0c:	29546d04 	addi	r5,r5,20916
81100f10:	1009883a 	mov	r4,r2
81100f14:	11232a00 	call	811232a0 <fprintf>
81100f18:	00014906 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 31) {
81100f1c:	e0bfbc17 	ldw	r2,-272(fp)
81100f20:	108007d8 	cmpnei	r2,r2,31
81100f24:	1000101e 	bne	r2,zero,81100f68 <bDdr2EepromDump+0x744>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100f28:	00e04574 	movhi	r3,33045
81100f2c:	18d46d04 	addi	r3,r3,20916
81100f30:	00a04574 	movhi	r2,33045
81100f34:	10b59804 	addi	r2,r2,-10656
81100f38:	1009883a 	mov	r4,r2
81100f3c:	008010c4 	movi	r2,67
81100f40:	100d883a 	mov	r6,r2
81100f44:	200b883a 	mov	r5,r4
81100f48:	1809883a 	mov	r4,r3
81100f4c:	11243500 	call	81124350 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f50:	d0a06217 	ldw	r2,-32376(gp)
81100f54:	01604574 	movhi	r5,33045
81100f58:	29546d04 	addi	r5,r5,20916
81100f5c:	1009883a 	mov	r4,r2
81100f60:	11232a00 	call	811232a0 <fprintf>
81100f64:	00013606 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 36) {
81100f68:	e0bfbc17 	ldw	r2,-272(fp)
81100f6c:	10800918 	cmpnei	r2,r2,36
81100f70:	1000101e 	bne	r2,zero,81100fb4 <bDdr2EepromDump+0x790>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100f74:	00e04574 	movhi	r3,33045
81100f78:	18d46d04 	addi	r3,r3,20916
81100f7c:	00a04574 	movhi	r2,33045
81100f80:	10b5a904 	addi	r2,r2,-10588
81100f84:	1009883a 	mov	r4,r2
81100f88:	00800a84 	movi	r2,42
81100f8c:	100d883a 	mov	r6,r2
81100f90:	200b883a 	mov	r5,r4
81100f94:	1809883a 	mov	r4,r3
81100f98:	11243500 	call	81124350 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f9c:	d0a06217 	ldw	r2,-32376(gp)
81100fa0:	01604574 	movhi	r5,33045
81100fa4:	29546d04 	addi	r5,r5,20916
81100fa8:	1009883a 	mov	r4,r2
81100fac:	11232a00 	call	811232a0 <fprintf>
81100fb0:	00012306 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 37) {
81100fb4:	e0bfbc17 	ldw	r2,-272(fp)
81100fb8:	10800958 	cmpnei	r2,r2,37
81100fbc:	1000101e 	bne	r2,zero,81101000 <bDdr2EepromDump+0x7dc>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100fc0:	00e04574 	movhi	r3,33045
81100fc4:	18d46d04 	addi	r3,r3,20916
81100fc8:	00a04574 	movhi	r2,33045
81100fcc:	10b5b404 	addi	r2,r2,-10544
81100fd0:	1009883a 	mov	r4,r2
81100fd4:	00800cc4 	movi	r2,51
81100fd8:	100d883a 	mov	r6,r2
81100fdc:	200b883a 	mov	r5,r4
81100fe0:	1809883a 	mov	r4,r3
81100fe4:	11243500 	call	81124350 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fe8:	d0a06217 	ldw	r2,-32376(gp)
81100fec:	01604574 	movhi	r5,33045
81100ff0:	29546d04 	addi	r5,r5,20916
81100ff4:	1009883a 	mov	r4,r2
81100ff8:	11232a00 	call	811232a0 <fprintf>
81100ffc:	00011006 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 38) {
81101000:	e0bfbc17 	ldw	r2,-272(fp)
81101004:	10800998 	cmpnei	r2,r2,38
81101008:	1000101e 	bne	r2,zero,8110104c <bDdr2EepromDump+0x828>
#if DEBUG_ON
				sprintf(cDebugBuffer,
8110100c:	00e04574 	movhi	r3,33045
81101010:	18d46d04 	addi	r3,r3,20916
81101014:	00a04574 	movhi	r2,33045
81101018:	10b5c104 	addi	r2,r2,-10492
8110101c:	1009883a 	mov	r4,r2
81101020:	00800dc4 	movi	r2,55
81101024:	100d883a 	mov	r6,r2
81101028:	200b883a 	mov	r5,r4
8110102c:	1809883a 	mov	r4,r3
81101030:	11243500 	call	81124350 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
81101034:	d0a06217 	ldw	r2,-32376(gp)
81101038:	01604574 	movhi	r5,33045
8110103c:	29546d04 	addi	r5,r5,20916
81101040:	1009883a 	mov	r4,r2
81101044:	11232a00 	call	811232a0 <fprintf>
81101048:	0000fd06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 41) {
8110104c:	e0bfbc17 	ldw	r2,-272(fp)
81101050:	10800a58 	cmpnei	r2,r2,41
81101054:	1000101e 	bne	r2,zero,81101098 <bDdr2EepromDump+0x874>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101058:	00e04574 	movhi	r3,33045
8110105c:	18d46d04 	addi	r3,r3,20916
81101060:	00a04574 	movhi	r2,33045
81101064:	10b5cf04 	addi	r2,r2,-10436
81101068:	1009883a 	mov	r4,r2
8110106c:	00800c84 	movi	r2,50
81101070:	100d883a 	mov	r6,r2
81101074:	200b883a 	mov	r5,r4
81101078:	1809883a 	mov	r4,r3
8110107c:	11243500 	call	81124350 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101080:	d0a06217 	ldw	r2,-32376(gp)
81101084:	01604574 	movhi	r5,33045
81101088:	29546d04 	addi	r5,r5,20916
8110108c:	1009883a 	mov	r4,r2
81101090:	11232a00 	call	811232a0 <fprintf>
81101094:	0000ea06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 42) {
81101098:	e0bfbc17 	ldw	r2,-272(fp)
8110109c:	10800a98 	cmpnei	r2,r2,42
811010a0:	1000101e 	bne	r2,zero,811010e4 <bDdr2EepromDump+0x8c0>
#if DEBUG_ON
				sprintf(cDebugBuffer,
811010a4:	00e04574 	movhi	r3,33045
811010a8:	18d46d04 	addi	r3,r3,20916
811010ac:	00a04574 	movhi	r2,33045
811010b0:	10b5dc04 	addi	r2,r2,-10384
811010b4:	1009883a 	mov	r4,r2
811010b8:	00800cc4 	movi	r2,51
811010bc:	100d883a 	mov	r6,r2
811010c0:	200b883a 	mov	r5,r4
811010c4:	1809883a 	mov	r4,r3
811010c8:	11243500 	call	81124350 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010cc:	d0a06217 	ldw	r2,-32376(gp)
811010d0:	01604574 	movhi	r5,33045
811010d4:	29546d04 	addi	r5,r5,20916
811010d8:	1009883a 	mov	r4,r2
811010dc:	11232a00 	call	811232a0 <fprintf>
811010e0:	0000d706 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 62) {
811010e4:	e0bfbc17 	ldw	r2,-272(fp)
811010e8:	10800f98 	cmpnei	r2,r2,62
811010ec:	1000101e 	bne	r2,zero,81101130 <bDdr2EepromDump+0x90c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010f0:	00e04574 	movhi	r3,33045
811010f4:	18d46d04 	addi	r3,r3,20916
811010f8:	00a04574 	movhi	r2,33045
811010fc:	10b5e904 	addi	r2,r2,-10332
81101100:	1009883a 	mov	r4,r2
81101104:	00800404 	movi	r2,16
81101108:	100d883a 	mov	r6,r2
8110110c:	200b883a 	mov	r5,r4
81101110:	1809883a 	mov	r4,r3
81101114:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
81101118:	d0a06217 	ldw	r2,-32376(gp)
8110111c:	01604574 	movhi	r5,33045
81101120:	29546d04 	addi	r5,r5,20916
81101124:	1009883a 	mov	r4,r2
81101128:	11232a00 	call	811232a0 <fprintf>
8110112c:	0000c406 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 63) {
81101130:	e0bfbc17 	ldw	r2,-272(fp)
81101134:	10800fd8 	cmpnei	r2,r2,63
81101138:	10001f1e 	bne	r2,zero,811011b8 <bDdr2EepromDump+0x994>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
8110113c:	00a04574 	movhi	r2,33045
81101140:	10946d04 	addi	r2,r2,20916
81101144:	00c00a04 	movi	r3,40
81101148:	10c00005 	stb	r3,0(r2)
8110114c:	00c010c4 	movi	r3,67
81101150:	10c00045 	stb	r3,1(r2)
81101154:	00c01a04 	movi	r3,104
81101158:	10c00085 	stb	r3,2(r2)
8110115c:	00c01944 	movi	r3,101
81101160:	10c000c5 	stb	r3,3(r2)
81101164:	00c018c4 	movi	r3,99
81101168:	10c00105 	stb	r3,4(r2)
8110116c:	00c01ac4 	movi	r3,107
81101170:	10c00145 	stb	r3,5(r2)
81101174:	00c01cc4 	movi	r3,115
81101178:	10c00185 	stb	r3,6(r2)
8110117c:	00c01d44 	movi	r3,117
81101180:	10c001c5 	stb	r3,7(r2)
81101184:	00c01b44 	movi	r3,109
81101188:	10c00205 	stb	r3,8(r2)
8110118c:	00c00a44 	movi	r3,41
81101190:	10c00245 	stb	r3,9(r2)
81101194:	00c00284 	movi	r3,10
81101198:	10c00285 	stb	r3,10(r2)
8110119c:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
811011a0:	d0a06217 	ldw	r2,-32376(gp)
811011a4:	01604574 	movhi	r5,33045
811011a8:	29546d04 	addi	r5,r5,20916
811011ac:	1009883a 	mov	r4,r2
811011b0:	11232a00 	call	811232a0 <fprintf>
811011b4:	0000a206 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 64) {
811011b8:	e0bfbc17 	ldw	r2,-272(fp)
811011bc:	10801018 	cmpnei	r2,r2,64
811011c0:	1000101e 	bne	r2,zero,81101204 <bDdr2EepromDump+0x9e0>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011c4:	00e04574 	movhi	r3,33045
811011c8:	18d46d04 	addi	r3,r3,20916
811011cc:	00a04574 	movhi	r2,33045
811011d0:	10b5ed04 	addi	r2,r2,-10316
811011d4:	1009883a 	mov	r4,r2
811011d8:	00800804 	movi	r2,32
811011dc:	100d883a 	mov	r6,r2
811011e0:	200b883a 	mov	r5,r4
811011e4:	1809883a 	mov	r4,r3
811011e8:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
811011ec:	d0a06217 	ldw	r2,-32376(gp)
811011f0:	01604574 	movhi	r5,33045
811011f4:	29546d04 	addi	r5,r5,20916
811011f8:	1009883a 	mov	r4,r2
811011fc:	11232a00 	call	811232a0 <fprintf>
81101200:	00008f06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 72) {
81101204:	e0bfbc17 	ldw	r2,-272(fp)
81101208:	10801218 	cmpnei	r2,r2,72
8110120c:	1000101e 	bne	r2,zero,81101250 <bDdr2EepromDump+0xa2c>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101210:	00e04574 	movhi	r3,33045
81101214:	18d46d04 	addi	r3,r3,20916
81101218:	00a04574 	movhi	r2,33045
8110121c:	10b5f504 	addi	r2,r2,-10284
81101220:	1009883a 	mov	r4,r2
81101224:	00800dc4 	movi	r2,55
81101228:	100d883a 	mov	r6,r2
8110122c:	200b883a 	mov	r5,r4
81101230:	1809883a 	mov	r4,r3
81101234:	11243500 	call	81124350 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101238:	d0a06217 	ldw	r2,-32376(gp)
8110123c:	01604574 	movhi	r5,33045
81101240:	29546d04 	addi	r5,r5,20916
81101244:	1009883a 	mov	r4,r2
81101248:	11232a00 	call	811232a0 <fprintf>
8110124c:	00007c06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 73) {
81101250:	e0bfbc17 	ldw	r2,-272(fp)
81101254:	10801258 	cmpnei	r2,r2,73
81101258:	1000101e 	bne	r2,zero,8110129c <bDdr2EepromDump+0xa78>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
8110125c:	00e04574 	movhi	r3,33045
81101260:	18d46d04 	addi	r3,r3,20916
81101264:	00a04574 	movhi	r2,33045
81101268:	10b60304 	addi	r2,r2,-10228
8110126c:	1009883a 	mov	r4,r2
81101270:	00800784 	movi	r2,30
81101274:	100d883a 	mov	r6,r2
81101278:	200b883a 	mov	r5,r4
8110127c:	1809883a 	mov	r4,r3
81101280:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
81101284:	d0a06217 	ldw	r2,-32376(gp)
81101288:	01604574 	movhi	r5,33045
8110128c:	29546d04 	addi	r5,r5,20916
81101290:	1009883a 	mov	r4,r2
81101294:	11232a00 	call	811232a0 <fprintf>
81101298:	00006906 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 91) {
8110129c:	e0bfbc17 	ldw	r2,-272(fp)
811012a0:	108016d8 	cmpnei	r2,r2,91
811012a4:	1000101e 	bne	r2,zero,811012e8 <bDdr2EepromDump+0xac4>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
811012a8:	00e04574 	movhi	r3,33045
811012ac:	18d46d04 	addi	r3,r3,20916
811012b0:	00a04574 	movhi	r2,33045
811012b4:	10b60b04 	addi	r2,r2,-10196
811012b8:	1009883a 	mov	r4,r2
811012bc:	00800804 	movi	r2,32
811012c0:	100d883a 	mov	r6,r2
811012c4:	200b883a 	mov	r5,r4
811012c8:	1809883a 	mov	r4,r3
811012cc:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
811012d0:	d0a06217 	ldw	r2,-32376(gp)
811012d4:	01604574 	movhi	r5,33045
811012d8:	29546d04 	addi	r5,r5,20916
811012dc:	1009883a 	mov	r4,r2
811012e0:	11232a00 	call	811232a0 <fprintf>
811012e4:	00005606 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 93) {
811012e8:	e0bfbc17 	ldw	r2,-272(fp)
811012ec:	10801758 	cmpnei	r2,r2,93
811012f0:	1000101e 	bne	r2,zero,81101334 <bDdr2EepromDump+0xb10>
#if DEBUG_ON
				sprintf(cDebugBuffer,
811012f4:	00e04574 	movhi	r3,33045
811012f8:	18d46d04 	addi	r3,r3,20916
811012fc:	00a04574 	movhi	r2,33045
81101300:	10b61304 	addi	r2,r2,-10164
81101304:	1009883a 	mov	r4,r2
81101308:	008009c4 	movi	r2,39
8110130c:	100d883a 	mov	r6,r2
81101310:	200b883a 	mov	r5,r4
81101314:	1809883a 	mov	r4,r3
81101318:	11243500 	call	81124350 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
8110131c:	d0a06217 	ldw	r2,-32376(gp)
81101320:	01604574 	movhi	r5,33045
81101324:	29546d04 	addi	r5,r5,20916
81101328:	1009883a 	mov	r4,r2
8110132c:	11232a00 	call	811232a0 <fprintf>
81101330:	00004306 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 94) {
81101334:	e0bfbc17 	ldw	r2,-272(fp)
81101338:	10801798 	cmpnei	r2,r2,94
8110133c:	1000101e 	bne	r2,zero,81101380 <bDdr2EepromDump+0xb5c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101340:	00e04574 	movhi	r3,33045
81101344:	18d46d04 	addi	r3,r3,20916
81101348:	00a04574 	movhi	r2,33045
8110134c:	10b61d04 	addi	r2,r2,-10124
81101350:	1009883a 	mov	r4,r2
81101354:	008006c4 	movi	r2,27
81101358:	100d883a 	mov	r6,r2
8110135c:	200b883a 	mov	r5,r4
81101360:	1809883a 	mov	r4,r3
81101364:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
81101368:	d0a06217 	ldw	r2,-32376(gp)
8110136c:	01604574 	movhi	r5,33045
81101370:	29546d04 	addi	r5,r5,20916
81101374:	1009883a 	mov	r4,r2
81101378:	11232a00 	call	811232a0 <fprintf>
8110137c:	00003006 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 95) {
81101380:	e0bfbc17 	ldw	r2,-272(fp)
81101384:	108017d8 	cmpnei	r2,r2,95
81101388:	1000101e 	bne	r2,zero,811013cc <bDdr2EepromDump+0xba8>
#if DEBUG_ON
				sprintf(cDebugBuffer,
8110138c:	00e04574 	movhi	r3,33045
81101390:	18d46d04 	addi	r3,r3,20916
81101394:	00a04574 	movhi	r2,33045
81101398:	10b62404 	addi	r2,r2,-10096
8110139c:	1009883a 	mov	r4,r2
811013a0:	00800a04 	movi	r2,40
811013a4:	100d883a 	mov	r6,r2
811013a8:	200b883a 	mov	r5,r4
811013ac:	1809883a 	mov	r4,r3
811013b0:	11243500 	call	81124350 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
811013b4:	d0a06217 	ldw	r2,-32376(gp)
811013b8:	01604574 	movhi	r5,33045
811013bc:	29546d04 	addi	r5,r5,20916
811013c0:	1009883a 	mov	r4,r2
811013c4:	11232a00 	call	811232a0 <fprintf>
811013c8:	00001d06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else if (iI == 99) {
811013cc:	e0bfbc17 	ldw	r2,-272(fp)
811013d0:	108018d8 	cmpnei	r2,r2,99
811013d4:	1000101e 	bne	r2,zero,81101418 <bDdr2EepromDump+0xbf4>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013d8:	00e04574 	movhi	r3,33045
811013dc:	18d46d04 	addi	r3,r3,20916
811013e0:	00a04574 	movhi	r2,33045
811013e4:	10b62e04 	addi	r2,r2,-10056
811013e8:	1009883a 	mov	r4,r2
811013ec:	00800984 	movi	r2,38
811013f0:	100d883a 	mov	r6,r2
811013f4:	200b883a 	mov	r5,r4
811013f8:	1809883a 	mov	r4,r3
811013fc:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
81101400:	d0a06217 	ldw	r2,-32376(gp)
81101404:	01604574 	movhi	r5,33045
81101408:	29546d04 	addi	r5,r5,20916
8110140c:	1009883a 	mov	r4,r2
81101410:	11232a00 	call	811232a0 <fprintf>
81101414:	00000a06 	br	81101440 <bDdr2EepromDump+0xc1c>
#endif
			} else {
#if DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101418:	00a04574 	movhi	r2,33045
8110141c:	10946d04 	addi	r2,r2,20916
81101420:	00c00284 	movi	r3,10
81101424:	10c00005 	stb	r3,0(r2)
81101428:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
8110142c:	d0a06217 	ldw	r2,-32376(gp)
81101430:	01604574 	movhi	r5,33045
81101434:	29546d04 	addi	r5,r5,20916
81101438:	1009883a 	mov	r4,r2
8110143c:	11232a00 	call	811232a0 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101440:	e0bfbc17 	ldw	r2,-272(fp)
81101444:	10800044 	addi	r2,r2,1
81101448:	e0bfbc15 	stw	r2,-272(fp)
8110144c:	e0bfbc17 	ldw	r2,-272(fp)
81101450:	10804008 	cmpgei	r2,r2,256
81101454:	1000121e 	bne	r2,zero,811014a0 <bDdr2EepromDump+0xc7c>
81101458:	e0bfbe17 	ldw	r2,-264(fp)
8110145c:	103d451e 	bne	r2,zero,81100974 <__reset+0xfb0e0974>
81101460:	00000f06 	br	811014a0 <bDdr2EepromDump+0xc7c>
#endif
			}
		}
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
81101464:	00e04574 	movhi	r3,33045
81101468:	18d46d04 	addi	r3,r3,20916
8110146c:	00a04574 	movhi	r2,33045
81101470:	10b63804 	addi	r2,r2,-10016
81101474:	1009883a 	mov	r4,r2
81101478:	008005c4 	movi	r2,23
8110147c:	100d883a 	mov	r6,r2
81101480:	200b883a 	mov	r5,r4
81101484:	1809883a 	mov	r4,r3
81101488:	11243500 	call	81124350 <memcpy>
		debug(fp, cDebugBuffer);
8110148c:	d0a06217 	ldw	r2,-32376(gp)
81101490:	01604574 	movhi	r5,33045
81101494:	29546d04 	addi	r5,r5,20916
81101498:	1009883a 	mov	r4,r2
8110149c:	11232a00 	call	811232a0 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811014a0:	00a04574 	movhi	r2,33045
811014a4:	10946d04 	addi	r2,r2,20916
811014a8:	00c00284 	movi	r3,10
811014ac:	10c00005 	stb	r3,0(r2)
811014b0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811014b4:	d0a06217 	ldw	r2,-32376(gp)
811014b8:	01604574 	movhi	r5,33045
811014bc:	29546d04 	addi	r5,r5,20916
811014c0:	1009883a 	mov	r4,r2
811014c4:	11232a00 	call	811232a0 <fprintf>
#endif

	return bSuccess;
811014c8:	e0bfbe17 	ldw	r2,-264(fp)
}
811014cc:	e037883a 	mov	sp,fp
811014d0:	dfc00117 	ldw	ra,4(sp)
811014d4:	df000017 	ldw	fp,0(sp)
811014d8:	dec00204 	addi	sp,sp,8
811014dc:	f800283a 	ret

811014e0 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014e0:	defffb04 	addi	sp,sp,-20
811014e4:	de00012e 	bgeu	sp,et,811014ec <bDdr2SwitchMemory+0xc>
811014e8:	003b68fa 	trap	3
811014ec:	dfc00415 	stw	ra,16(sp)
811014f0:	df000315 	stw	fp,12(sp)
811014f4:	df000304 	addi	fp,sp,12
811014f8:	2005883a 	mov	r2,r4
811014fc:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess = FALSE;
81101500:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
81101504:	00a04834 	movhi	r2,33056
81101508:	108c2204 	addi	r2,r2,12424
8110150c:	e0bffe15 	stw	r2,-8(fp)

	switch (ucMemoryId) {
81101510:	e0bfff03 	ldbu	r2,-4(fp)
81101514:	10000326 	beq	r2,zero,81101524 <bDdr2SwitchMemory+0x44>
81101518:	10800060 	cmpeqi	r2,r2,1
8110151c:	1000061e 	bne	r2,zero,81101538 <bDdr2SwitchMemory+0x58>
81101520:	00000b06 	br	81101550 <bDdr2SwitchMemory+0x70>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101524:	e0bffe17 	ldw	r2,-8(fp)
81101528:	10000015 	stw	zero,0(r2)
		bSuccess = TRUE;
8110152c:	00800044 	movi	r2,1
81101530:	e0bffd15 	stw	r2,-12(fp)
		break;
81101534:	00001606 	br	81101590 <bDdr2SwitchMemory+0xb0>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
81101538:	e0bffe17 	ldw	r2,-8(fp)
8110153c:	00e00034 	movhi	r3,32768
81101540:	10c00015 	stw	r3,0(r2)
		bSuccess = TRUE;
81101544:	00800044 	movi	r2,1
81101548:	e0bffd15 	stw	r2,-12(fp)
		break;
8110154c:	00001006 	br	81101590 <bDdr2SwitchMemory+0xb0>
	default:
		bSuccess = FALSE;
81101550:	e03ffd15 	stw	zero,-12(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101554:	00e04574 	movhi	r3,33045
81101558:	18d46d04 	addi	r3,r3,20916
8110155c:	00a04574 	movhi	r2,33045
81101560:	10b63e04 	addi	r2,r2,-9992
81101564:	1009883a 	mov	r4,r2
81101568:	00800f04 	movi	r2,60
8110156c:	100d883a 	mov	r6,r2
81101570:	200b883a 	mov	r5,r4
81101574:	1809883a 	mov	r4,r3
81101578:	11243500 	call	81124350 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
8110157c:	d0a06217 	ldw	r2,-32376(gp)
81101580:	01604574 	movhi	r5,33045
81101584:	29546d04 	addi	r5,r5,20916
81101588:	1009883a 	mov	r4,r2
8110158c:	11232a00 	call	811232a0 <fprintf>
		;
#endif
	}

	return bSuccess;
81101590:	e0bffd17 	ldw	r2,-12(fp)
}
81101594:	e037883a 	mov	sp,fp
81101598:	dfc00117 	ldw	ra,4(sp)
8110159c:	df000017 	ldw	fp,0(sp)
811015a0:	dec00204 	addi	sp,sp,8
811015a4:	f800283a 	ret

811015a8 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
811015a8:	deffe204 	addi	sp,sp,-120
811015ac:	de00012e 	bgeu	sp,et,811015b4 <bDdr2MemoryWriteTest+0xc>
811015b0:	003b68fa 	trap	3
811015b4:	dfc01d15 	stw	ra,116(sp)
811015b8:	df001c15 	stw	fp,112(sp)
811015bc:	dc401b15 	stw	r17,108(sp)
811015c0:	dc001a15 	stw	r16,104(sp)
811015c4:	df001c04 	addi	fp,sp,112
811015c8:	2005883a 	mov	r2,r4
811015cc:	e0bffd05 	stb	r2,-12(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015d0:	00e04574 	movhi	r3,33045
811015d4:	18d46d04 	addi	r3,r3,20916
811015d8:	00a04574 	movhi	r2,33045
811015dc:	10b64d04 	addi	r2,r2,-9932
811015e0:	1009883a 	mov	r4,r2
811015e4:	00800a04 	movi	r2,40
811015e8:	100d883a 	mov	r6,r2
811015ec:	200b883a 	mov	r5,r4
811015f0:	1809883a 	mov	r4,r3
811015f4:	11243500 	call	81124350 <memcpy>
	debug(fp, cDebugBuffer);
811015f8:	d0a06217 	ldw	r2,-32376(gp)
811015fc:	01604574 	movhi	r5,33045
81101600:	29546d04 	addi	r5,r5,20916
81101604:	1009883a 	mov	r4,r2
81101608:	11232a00 	call	811232a0 <fprintf>
#endif
	bool bSuccess = FALSE;
8110160c:	e03fe515 	stw	zero,-108(fp)
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	switch (ucMemoryId) {
81101610:	e0bffd03 	ldbu	r2,-12(fp)
81101614:	10000326 	beq	r2,zero,81101624 <bDdr2MemoryWriteTest+0x7c>
81101618:	10800060 	cmpeqi	r2,r2,1
8110161c:	10000a1e 	bne	r2,zero,81101648 <bDdr2MemoryWriteTest+0xa0>
81101620:	00001206 	br	8110166c <bDdr2MemoryWriteTest+0xc4>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101624:	e0bffd03 	ldbu	r2,-12(fp)
81101628:	1009883a 	mov	r4,r2
8110162c:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101630:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101634:	00a00034 	movhi	r2,32768
81101638:	e0bfe715 	stw	r2,-100(fp)
		bSuccess = TRUE;
8110163c:	00800044 	movi	r2,1
81101640:	e0bfe515 	stw	r2,-108(fp)
		break;
81101644:	00001b06 	br	811016b4 <bDdr2MemoryWriteTest+0x10c>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101648:	e0bffd03 	ldbu	r2,-12(fp)
8110164c:	1009883a 	mov	r4,r2
81101650:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101654:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101658:	00a00034 	movhi	r2,32768
8110165c:	e0bfe715 	stw	r2,-100(fp)
		bSuccess = TRUE;
81101660:	00800044 	movi	r2,1
81101664:	e0bfe515 	stw	r2,-108(fp)
		break;
81101668:	00001206 	br	811016b4 <bDdr2MemoryWriteTest+0x10c>
	default:
		bSuccess = FALSE;
8110166c:	e03fe515 	stw	zero,-108(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101670:	00e04574 	movhi	r3,33045
81101674:	18d46d04 	addi	r3,r3,20916
81101678:	00a04574 	movhi	r2,33045
8110167c:	10b45e04 	addi	r2,r2,-11912
81101680:	1009883a 	mov	r4,r2
81101684:	00800bc4 	movi	r2,47
81101688:	100d883a 	mov	r6,r2
8110168c:	200b883a 	mov	r5,r4
81101690:	1809883a 	mov	r4,r3
81101694:	11243500 	call	81124350 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101698:	d0a06217 	ldw	r2,-32376(gp)
8110169c:	01604574 	movhi	r5,33045
811016a0:	29546d04 	addi	r5,r5,20916
811016a4:	1009883a 	mov	r4,r2
811016a8:	11232a00 	call	811232a0 <fprintf>
		;
#endif
		return bSuccess;
811016ac:	e0bfe517 	ldw	r2,-108(fp)
811016b0:	00011806 	br	81101b14 <bDdr2MemoryWriteTest+0x56c>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
811016b4:	e0bfe717 	ldw	r2,-100(fp)
811016b8:	1004d53a 	srli	r2,r2,20
811016bc:	100d883a 	mov	r6,r2
811016c0:	01604574 	movhi	r5,33045
811016c4:	29765704 	addi	r5,r5,-9892
811016c8:	01204574 	movhi	r4,33045
811016cc:	21146d04 	addi	r4,r4,20916
811016d0:	1124bb40 	call	81124bb4 <sprintf>
	debug(fp, cDebugBuffer);
811016d4:	d0a06217 	ldw	r2,-32376(gp)
811016d8:	01604574 	movhi	r5,33045
811016dc:	29546d04 	addi	r5,r5,20916
811016e0:	1009883a 	mov	r4,r2
811016e4:	11232a00 	call	811232a0 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016e8:	00800104 	movi	r2,4
811016ec:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016f0:	e03fed15 	stw	zero,-76(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016f4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016f8:	e03fe815 	stw	zero,-96(fp)
811016fc:	00001506 	br	81101754 <bDdr2MemoryWriteTest+0x1ac>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101700:	e0ffe717 	ldw	r3,-100(fp)
81101704:	00b33374 	movhi	r2,52429
81101708:	10b33344 	addi	r2,r2,-13107
8110170c:	1888383a 	mulxuu	r4,r3,r2
81101710:	1885383a 	mul	r2,r3,r2
81101714:	1021883a 	mov	r16,r2
81101718:	2023883a 	mov	r17,r4
8110171c:	8804d0fa 	srli	r2,r17,3
81101720:	e0ffe817 	ldw	r3,-96(fp)
81101724:	18c00044 	addi	r3,r3,1
81101728:	10c7383a 	mul	r3,r2,r3
8110172c:	e0bfe817 	ldw	r2,-96(fp)
81101730:	1085883a 	add	r2,r2,r2
81101734:	1085883a 	add	r2,r2,r2
81101738:	e13fe504 	addi	r4,fp,-108
8110173c:	2085883a 	add	r2,r4,r2
81101740:	10800e04 	addi	r2,r2,56
81101744:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101748:	e0bfe817 	ldw	r2,-96(fp)
8110174c:	10800044 	addi	r2,r2,1
81101750:	e0bfe815 	stw	r2,-96(fp)
81101754:	e0bfe817 	ldw	r2,-96(fp)
81101758:	10800290 	cmplti	r2,r2,10
8110175c:	103fe81e 	bne	r2,zero,81101700 <__reset+0xfb0e1700>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101760:	d0a08917 	ldw	r2,-32220(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101764:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101768:	00804004 	movi	r2,256
8110176c:	e0bfeb15 	stw	r2,-84(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101770:	e03fe815 	stw	zero,-96(fp)
81101774:	00001e06 	br	811017f0 <bDdr2MemoryWriteTest+0x248>
		if (iI == 0) {
81101778:	e0bfe817 	ldw	r2,-96(fp)
8110177c:	1000091e 	bne	r2,zero,811017a4 <bDdr2MemoryWriteTest+0x1fc>
			xSZData[iI] = uliInitValue;
81101780:	00a04574 	movhi	r2,33045
81101784:	1094ad04 	addi	r2,r2,21172
81101788:	e0ffe817 	ldw	r3,-96(fp)
8110178c:	18c7883a 	add	r3,r3,r3
81101790:	18c7883a 	add	r3,r3,r3
81101794:	10c5883a 	add	r2,r2,r3
81101798:	e0fff017 	ldw	r3,-64(fp)
8110179c:	10c00015 	stw	r3,0(r2)
811017a0:	00001006 	br	811017e4 <bDdr2MemoryWriteTest+0x23c>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
811017a4:	e0bfe817 	ldw	r2,-96(fp)
811017a8:	10ffffc4 	addi	r3,r2,-1
811017ac:	00a04574 	movhi	r2,33045
811017b0:	1094ad04 	addi	r2,r2,21172
811017b4:	18c7883a 	add	r3,r3,r3
811017b8:	18c7883a 	add	r3,r3,r3
811017bc:	10c5883a 	add	r2,r2,r3
811017c0:	10800017 	ldw	r2,0(r2)
811017c4:	11000364 	muli	r4,r2,13
811017c8:	00a04574 	movhi	r2,33045
811017cc:	1094ad04 	addi	r2,r2,21172
811017d0:	e0ffe817 	ldw	r3,-96(fp)
811017d4:	18c7883a 	add	r3,r3,r3
811017d8:	18c7883a 	add	r3,r3,r3
811017dc:	10c5883a 	add	r2,r2,r3
811017e0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017e4:	e0bfe817 	ldw	r2,-96(fp)
811017e8:	10800044 	addi	r2,r2,1
811017ec:	e0bfe815 	stw	r2,-96(fp)
811017f0:	e0ffe817 	ldw	r3,-96(fp)
811017f4:	e0bfeb17 	ldw	r2,-84(fp)
811017f8:	18bfdf16 	blt	r3,r2,81101778 <__reset+0xfb0e1778>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017fc:	e0bfeb17 	ldw	r2,-84(fp)
81101800:	10ffffc4 	addi	r3,r2,-1
81101804:	00a04574 	movhi	r2,33045
81101808:	1094ad04 	addi	r2,r2,21172
8110180c:	18c7883a 	add	r3,r3,r3
81101810:	18c7883a 	add	r3,r3,r3
81101814:	10c7883a 	add	r3,r2,r3
81101818:	00aaaaf4 	movhi	r2,43691
8110181c:	10aaaa84 	addi	r2,r2,-21846
81101820:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
81101824:	e0bfeb17 	ldw	r2,-84(fp)
81101828:	10ffff84 	addi	r3,r2,-2
8110182c:	00a04574 	movhi	r2,33045
81101830:	1094ad04 	addi	r2,r2,21172
81101834:	18c7883a 	add	r3,r3,r3
81101838:	18c7883a 	add	r3,r3,r3
8110183c:	10c7883a 	add	r3,r2,r3
81101840:	00955574 	movhi	r2,21845
81101844:	10955544 	addi	r2,r2,21845
81101848:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110184c:	e0bfeb17 	ldw	r2,-84(fp)
81101850:	10ffff44 	addi	r3,r2,-3
81101854:	00a04574 	movhi	r2,33045
81101858:	1094ad04 	addi	r2,r2,21172
8110185c:	18c7883a 	add	r3,r3,r3
81101860:	18c7883a 	add	r3,r3,r3
81101864:	10c5883a 	add	r2,r2,r3
81101868:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110186c:	e0bfeb17 	ldw	r2,-84(fp)
81101870:	10ffff04 	addi	r3,r2,-4
81101874:	00a04574 	movhi	r2,33045
81101878:	1094ad04 	addi	r2,r2,21172
8110187c:	18c7883a 	add	r3,r3,r3
81101880:	18c7883a 	add	r3,r3,r3
81101884:	10c5883a 	add	r2,r2,r3
81101888:	00ffffc4 	movi	r3,-1
8110188c:	10c00015 	stw	r3,0(r2)

#if DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101890:	00e04574 	movhi	r3,33045
81101894:	18d46d04 	addi	r3,r3,20916
81101898:	00a04574 	movhi	r2,33045
8110189c:	10b65d04 	addi	r2,r2,-9868
811018a0:	1009883a 	mov	r4,r2
811018a4:	00800444 	movi	r2,17
811018a8:	100d883a 	mov	r6,r2
811018ac:	200b883a 	mov	r5,r4
811018b0:	1809883a 	mov	r4,r3
811018b4:	11243500 	call	81124350 <memcpy>
	debug(fp, cDebugBuffer);
811018b8:	d0a06217 	ldw	r2,-32376(gp)
811018bc:	01604574 	movhi	r5,33045
811018c0:	29546d04 	addi	r5,r5,20916
811018c4:	1009883a 	mov	r4,r2
811018c8:	11232a00 	call	811232a0 <fprintf>
811018cc:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
811018d0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018d4:	e0bfe617 	ldw	r2,-104(fp)
811018d8:	e0bfea15 	stw	r2,-88(fp)
	iNAccessLen = sizeof(xSZData);
811018dc:	00810004 	movi	r2,1024
811018e0:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018e4:	e0ffe917 	ldw	r3,-92(fp)
811018e8:	e0bfee17 	ldw	r2,-72(fp)
811018ec:	1885283a 	div	r2,r3,r2
811018f0:	e0bfeb15 	stw	r2,-84(fp)
	iNPos = 0;
811018f4:	e03fec15 	stw	zero,-80(fp)
	while (iNPos < uliByteLen) {
811018f8:	00003a06 	br	811019e4 <bDdr2MemoryWriteTest+0x43c>
		iNRemainedLen = uliByteLen - iNPos;
811018fc:	e0bfec17 	ldw	r2,-80(fp)
81101900:	e0ffe717 	ldw	r3,-100(fp)
81101904:	1885c83a 	sub	r2,r3,r2
81101908:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
8110190c:	e0bfe917 	ldw	r2,-92(fp)
81101910:	e0fff217 	ldw	r3,-56(fp)
81101914:	1880060e 	bge	r3,r2,81101930 <bDdr2MemoryWriteTest+0x388>
			iNAccessLen = iNRemainedLen;
81101918:	e0bff217 	ldw	r2,-56(fp)
8110191c:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101920:	e0ffe917 	ldw	r3,-92(fp)
81101924:	e0bfee17 	ldw	r2,-72(fp)
81101928:	1885283a 	div	r2,r3,r2
8110192c:	e0bfeb15 	stw	r2,-84(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101930:	e0bfe917 	ldw	r2,-92(fp)
81101934:	100d883a 	mov	r6,r2
81101938:	01604574 	movhi	r5,33045
8110193c:	2954ad04 	addi	r5,r5,21172
81101940:	e13fea17 	ldw	r4,-88(fp)
81101944:	11243500 	call	81124350 <memcpy>
		pxDes += iNItemNum;
81101948:	e0bfeb17 	ldw	r2,-84(fp)
8110194c:	1085883a 	add	r2,r2,r2
81101950:	1085883a 	add	r2,r2,r2
81101954:	1007883a 	mov	r3,r2
81101958:	e0bfea17 	ldw	r2,-88(fp)
8110195c:	10c5883a 	add	r2,r2,r3
81101960:	e0bfea15 	stw	r2,-88(fp)
		iNPos += iNAccessLen;
81101964:	e0ffec17 	ldw	r3,-80(fp)
81101968:	e0bfe917 	ldw	r2,-92(fp)
8110196c:	1885883a 	add	r2,r3,r2
81101970:	e0bfec15 	stw	r2,-80(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101974:	e0bfed17 	ldw	r2,-76(fp)
81101978:	10800288 	cmpgei	r2,r2,10
8110197c:	1000191e 	bne	r2,zero,811019e4 <bDdr2MemoryWriteTest+0x43c>
81101980:	e0bfed17 	ldw	r2,-76(fp)
81101984:	1085883a 	add	r2,r2,r2
81101988:	1085883a 	add	r2,r2,r2
8110198c:	e0ffe504 	addi	r3,fp,-108
81101990:	1885883a 	add	r2,r3,r2
81101994:	10800e04 	addi	r2,r2,56
81101998:	10800017 	ldw	r2,0(r2)
8110199c:	e0ffec17 	ldw	r3,-80(fp)
811019a0:	18801036 	bltu	r3,r2,811019e4 <bDdr2MemoryWriteTest+0x43c>
			iNProgressIndex++;
811019a4:	e0bfed17 	ldw	r2,-76(fp)
811019a8:	10800044 	addi	r2,r2,1
811019ac:	e0bfed15 	stw	r2,-76(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
811019b0:	e0bfed17 	ldw	r2,-76(fp)
811019b4:	108002a4 	muli	r2,r2,10
811019b8:	100d883a 	mov	r6,r2
811019bc:	01604574 	movhi	r5,33045
811019c0:	29766204 	addi	r5,r5,-9848
811019c4:	01204574 	movhi	r4,33045
811019c8:	21146d04 	addi	r4,r4,20916
811019cc:	1124bb40 	call	81124bb4 <sprintf>
			debug(fp, cDebugBuffer);
811019d0:	d0a06217 	ldw	r2,-32376(gp)
811019d4:	01604574 	movhi	r5,33045
811019d8:	29546d04 	addi	r5,r5,20916
811019dc:	1009883a 	mov	r4,r2
811019e0:	11232a00 	call	811232a0 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019e4:	e0ffec17 	ldw	r3,-80(fp)
811019e8:	e0bfe717 	ldw	r2,-100(fp)
811019ec:	18bfc336 	bltu	r3,r2,811018fc <__reset+0xfb0e18fc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019f0:	11381300 	call	81138130 <alt_dcache_flush_all>
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019f4:	00a04574 	movhi	r2,33045
811019f8:	10946d04 	addi	r2,r2,20916
811019fc:	00c00284 	movi	r3,10
81101a00:	10c00005 	stb	r3,0(r2)
81101a04:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101a08:	d0a06217 	ldw	r2,-32376(gp)
81101a0c:	01604574 	movhi	r5,33045
81101a10:	29546d04 	addi	r5,r5,20916
81101a14:	1009883a 	mov	r4,r2
81101a18:	11232a00 	call	811232a0 <fprintf>
81101a1c:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101a20:	e0bff117 	ldw	r2,-60(fp)
81101a24:	1885c83a 	sub	r2,r3,r2
81101a28:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
81101a2c:	e0bfe517 	ldw	r2,-108(fp)
81101a30:	10001e26 	beq	r2,zero,81101aac <bDdr2MemoryWriteTest+0x504>
#if DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a34:	e13fef17 	ldw	r4,-68(fp)
81101a38:	11219800 	call	81121980 <__floatsisf>
81101a3c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a40:	d0a08817 	ldw	r2,-32224(gp)
81101a44:	1009883a 	mov	r4,r2
81101a48:	1121aac0 	call	81121aac <__floatunsisf>
81101a4c:	1007883a 	mov	r3,r2
81101a50:	180b883a 	mov	r5,r3
81101a54:	8009883a 	mov	r4,r16
81101a58:	11211340 	call	81121134 <__divsf3>
81101a5c:	1007883a 	mov	r3,r2
81101a60:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101a64:	1009883a 	mov	r4,r2
81101a68:	1122e080 	call	81122e08 <__extendsfdf2>
81101a6c:	1009883a 	mov	r4,r2
81101a70:	180b883a 	mov	r5,r3
81101a74:	d9400015 	stw	r5,0(sp)
81101a78:	200f883a 	mov	r7,r4
81101a7c:	e1bfe717 	ldw	r6,-100(fp)
81101a80:	01604574 	movhi	r5,33045
81101a84:	29766404 	addi	r5,r5,-9840
81101a88:	01204574 	movhi	r4,33045
81101a8c:	21146d04 	addi	r4,r4,20916
81101a90:	1124bb40 	call	81124bb4 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a94:	d0a06217 	ldw	r2,-32376(gp)
81101a98:	01604574 	movhi	r5,33045
81101a9c:	29546d04 	addi	r5,r5,20916
81101aa0:	1009883a 	mov	r4,r2
81101aa4:	11232a00 	call	811232a0 <fprintf>
81101aa8:	00000f06 	br	81101ae8 <bDdr2MemoryWriteTest+0x540>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101aac:	00e04574 	movhi	r3,33045
81101ab0:	18d46d04 	addi	r3,r3,20916
81101ab4:	00a04574 	movhi	r2,33045
81101ab8:	10b67004 	addi	r2,r2,-9792
81101abc:	1009883a 	mov	r4,r2
81101ac0:	00800584 	movi	r2,22
81101ac4:	100d883a 	mov	r6,r2
81101ac8:	200b883a 	mov	r5,r4
81101acc:	1809883a 	mov	r4,r3
81101ad0:	11243500 	call	81124350 <memcpy>
		debug(fp, cDebugBuffer);
81101ad4:	d0a06217 	ldw	r2,-32376(gp)
81101ad8:	01604574 	movhi	r5,33045
81101adc:	29546d04 	addi	r5,r5,20916
81101ae0:	1009883a 	mov	r4,r2
81101ae4:	11232a00 	call	811232a0 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ae8:	00a04574 	movhi	r2,33045
81101aec:	10946d04 	addi	r2,r2,20916
81101af0:	00c00284 	movi	r3,10
81101af4:	10c00005 	stb	r3,0(r2)
81101af8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101afc:	d0a06217 	ldw	r2,-32376(gp)
81101b00:	01604574 	movhi	r5,33045
81101b04:	29546d04 	addi	r5,r5,20916
81101b08:	1009883a 	mov	r4,r2
81101b0c:	11232a00 	call	811232a0 <fprintf>
#endif

	return bSuccess;
81101b10:	e0bfe517 	ldw	r2,-108(fp)
}
81101b14:	e6fffe04 	addi	sp,fp,-8
81101b18:	dfc00317 	ldw	ra,12(sp)
81101b1c:	df000217 	ldw	fp,8(sp)
81101b20:	dc400117 	ldw	r17,4(sp)
81101b24:	dc000017 	ldw	r16,0(sp)
81101b28:	dec00404 	addi	sp,sp,16
81101b2c:	f800283a 	ret

81101b30 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b30:	deffe204 	addi	sp,sp,-120
81101b34:	de00012e 	bgeu	sp,et,81101b3c <bDdr2MemoryReadTest+0xc>
81101b38:	003b68fa 	trap	3
81101b3c:	dfc01d15 	stw	ra,116(sp)
81101b40:	df001c15 	stw	fp,112(sp)
81101b44:	dc401b15 	stw	r17,108(sp)
81101b48:	dc001a15 	stw	r16,104(sp)
81101b4c:	df001c04 	addi	fp,sp,112
81101b50:	2005883a 	mov	r2,r4
81101b54:	e0bffd05 	stb	r2,-12(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b58:	00e04574 	movhi	r3,33045
81101b5c:	18d46d04 	addi	r3,r3,20916
81101b60:	00a04574 	movhi	r2,33045
81101b64:	10b67604 	addi	r2,r2,-9768
81101b68:	1009883a 	mov	r4,r2
81101b6c:	008009c4 	movi	r2,39
81101b70:	100d883a 	mov	r6,r2
81101b74:	200b883a 	mov	r5,r4
81101b78:	1809883a 	mov	r4,r3
81101b7c:	11243500 	call	81124350 <memcpy>
	debug(fp, cDebugBuffer);
81101b80:	d0a06217 	ldw	r2,-32376(gp)
81101b84:	01604574 	movhi	r5,33045
81101b88:	29546d04 	addi	r5,r5,20916
81101b8c:	1009883a 	mov	r4,r2
81101b90:	11232a00 	call	811232a0 <fprintf>
#endif
	bool bSuccess = FALSE;
81101b94:	e03fe515 	stw	zero,-108(fp)
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	switch (ucMemoryId) {
81101b98:	e0bffd03 	ldbu	r2,-12(fp)
81101b9c:	10000326 	beq	r2,zero,81101bac <bDdr2MemoryReadTest+0x7c>
81101ba0:	10800060 	cmpeqi	r2,r2,1
81101ba4:	10000a1e 	bne	r2,zero,81101bd0 <bDdr2MemoryReadTest+0xa0>
81101ba8:	00001206 	br	81101bf4 <bDdr2MemoryReadTest+0xc4>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101bac:	e0bffd03 	ldbu	r2,-12(fp)
81101bb0:	1009883a 	mov	r4,r2
81101bb4:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101bb8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101bbc:	00a00034 	movhi	r2,32768
81101bc0:	e0bfe715 	stw	r2,-100(fp)
		bSuccess = TRUE;
81101bc4:	00800044 	movi	r2,1
81101bc8:	e0bfe515 	stw	r2,-108(fp)
		break;
81101bcc:	00001b06 	br	81101c3c <bDdr2MemoryReadTest+0x10c>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101bd0:	e0bffd03 	ldbu	r2,-12(fp)
81101bd4:	1009883a 	mov	r4,r2
81101bd8:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101bdc:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101be0:	00a00034 	movhi	r2,32768
81101be4:	e0bfe715 	stw	r2,-100(fp)
		bSuccess = TRUE;
81101be8:	00800044 	movi	r2,1
81101bec:	e0bfe515 	stw	r2,-108(fp)
		break;
81101bf0:	00001206 	br	81101c3c <bDdr2MemoryReadTest+0x10c>
	default:
		bSuccess = FALSE;
81101bf4:	e03fe515 	stw	zero,-108(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101bf8:	00e04574 	movhi	r3,33045
81101bfc:	18d46d04 	addi	r3,r3,20916
81101c00:	00a04574 	movhi	r2,33045
81101c04:	10b45e04 	addi	r2,r2,-11912
81101c08:	1009883a 	mov	r4,r2
81101c0c:	00800bc4 	movi	r2,47
81101c10:	100d883a 	mov	r6,r2
81101c14:	200b883a 	mov	r5,r4
81101c18:	1809883a 	mov	r4,r3
81101c1c:	11243500 	call	81124350 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101c20:	d0a06217 	ldw	r2,-32376(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	29546d04 	addi	r5,r5,20916
81101c2c:	1009883a 	mov	r4,r2
81101c30:	11232a00 	call	811232a0 <fprintf>
		;
#endif
		return bSuccess;
81101c34:	e0bfe517 	ldw	r2,-108(fp)
81101c38:	0000fc06 	br	8110202c <bDdr2MemoryReadTest+0x4fc>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c3c:	e0bfe717 	ldw	r2,-100(fp)
81101c40:	1004d53a 	srli	r2,r2,20
81101c44:	100d883a 	mov	r6,r2
81101c48:	01604574 	movhi	r5,33045
81101c4c:	29768004 	addi	r5,r5,-9728
81101c50:	01204574 	movhi	r4,33045
81101c54:	21146d04 	addi	r4,r4,20916
81101c58:	1124bb40 	call	81124bb4 <sprintf>
	debug(fp, cDebugBuffer);
81101c5c:	d0a06217 	ldw	r2,-32376(gp)
81101c60:	01604574 	movhi	r5,33045
81101c64:	29546d04 	addi	r5,r5,20916
81101c68:	1009883a 	mov	r4,r2
81101c6c:	11232a00 	call	811232a0 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c70:	00804004 	movi	r2,256
81101c74:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c78:	00800104 	movi	r2,4
81101c7c:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c80:	e0ffec17 	ldw	r3,-80(fp)
81101c84:	e0bfef17 	ldw	r2,-68(fp)
81101c88:	1885383a 	mul	r2,r3,r2
81101c8c:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c90:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c94:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c98:	e03fe815 	stw	zero,-96(fp)
81101c9c:	00001506 	br	81101cf4 <bDdr2MemoryReadTest+0x1c4>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101ca0:	e0ffe717 	ldw	r3,-100(fp)
81101ca4:	00b33374 	movhi	r2,52429
81101ca8:	10b33344 	addi	r2,r2,-13107
81101cac:	1888383a 	mulxuu	r4,r3,r2
81101cb0:	1885383a 	mul	r2,r3,r2
81101cb4:	1021883a 	mov	r16,r2
81101cb8:	2023883a 	mov	r17,r4
81101cbc:	8804d0fa 	srli	r2,r17,3
81101cc0:	e0ffe817 	ldw	r3,-96(fp)
81101cc4:	18c00044 	addi	r3,r3,1
81101cc8:	10c7383a 	mul	r3,r2,r3
81101ccc:	e0bfe817 	ldw	r2,-96(fp)
81101cd0:	1085883a 	add	r2,r2,r2
81101cd4:	1085883a 	add	r2,r2,r2
81101cd8:	e13fe504 	addi	r4,fp,-108
81101cdc:	2085883a 	add	r2,r4,r2
81101ce0:	10800e04 	addi	r2,r2,56
81101ce4:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101ce8:	e0bfe817 	ldw	r2,-96(fp)
81101cec:	10800044 	addi	r2,r2,1
81101cf0:	e0bfe815 	stw	r2,-96(fp)
81101cf4:	e0bfe817 	ldw	r2,-96(fp)
81101cf8:	10800290 	cmplti	r2,r2,10
81101cfc:	103fe81e 	bne	r2,zero,81101ca0 <__reset+0xfb0e1ca0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101d00:	e03fee15 	stw	zero,-72(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101d04:	00e04574 	movhi	r3,33045
81101d08:	18d46d04 	addi	r3,r3,20916
81101d0c:	00a04574 	movhi	r2,33045
81101d10:	10b68604 	addi	r2,r2,-9704
81101d14:	1009883a 	mov	r4,r2
81101d18:	008006c4 	movi	r2,27
81101d1c:	100d883a 	mov	r6,r2
81101d20:	200b883a 	mov	r5,r4
81101d24:	1809883a 	mov	r4,r3
81101d28:	11243500 	call	81124350 <memcpy>
	debug(fp, cDebugBuffer);
81101d2c:	d0a06217 	ldw	r2,-32376(gp)
81101d30:	01604574 	movhi	r5,33045
81101d34:	29546d04 	addi	r5,r5,20916
81101d38:	1009883a 	mov	r4,r2
81101d3c:	11232a00 	call	811232a0 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d40:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
81101d44:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d48:	e0bfe617 	ldw	r2,-104(fp)
81101d4c:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d50:	00810004 	movi	r2,1024
81101d54:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d68:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d6c:	00006206 	br	81101ef8 <bDdr2MemoryReadTest+0x3c8>
		iNRemainedLen = uliByteLen - iNPos;
81101d70:	e0bfed17 	ldw	r2,-76(fp)
81101d74:	e0ffe717 	ldw	r3,-100(fp)
81101d78:	1885c83a 	sub	r2,r3,r2
81101d7c:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d80:	e0bfe917 	ldw	r2,-92(fp)
81101d84:	e0fff217 	ldw	r3,-56(fp)
81101d88:	1880060e 	bge	r3,r2,81101da4 <bDdr2MemoryReadTest+0x274>
			iNAccessLen = iNRemainedLen;
81101d8c:	e0bff217 	ldw	r2,-56(fp)
81101d90:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d94:	e0ffe917 	ldw	r3,-92(fp)
81101d98:	e0bfef17 	ldw	r2,-68(fp)
81101d9c:	1885283a 	div	r2,r3,r2
81101da0:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101da4:	00a04574 	movhi	r2,33045
81101da8:	1094ad04 	addi	r2,r2,21172
81101dac:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101db0:	e03fe815 	stw	zero,-96(fp)
81101db4:	00002b06 	br	81101e64 <bDdr2MemoryReadTest+0x334>
			if (*pxSrc++ != *pxDes++) {
81101db8:	e0bfeb17 	ldw	r2,-84(fp)
81101dbc:	10c00104 	addi	r3,r2,4
81101dc0:	e0ffeb15 	stw	r3,-84(fp)
81101dc4:	10c00017 	ldw	r3,0(r2)
81101dc8:	e0bfea17 	ldw	r2,-88(fp)
81101dcc:	11000104 	addi	r4,r2,4
81101dd0:	e13fea15 	stw	r4,-88(fp)
81101dd4:	10800017 	ldw	r2,0(r2)
81101dd8:	18801f26 	beq	r3,r2,81101e58 <bDdr2MemoryReadTest+0x328>
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101ddc:	e0bfeb17 	ldw	r2,-84(fp)
81101de0:	10bfff04 	addi	r2,r2,-4
81101de4:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101de8:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101dec:	00a04574 	movhi	r2,33045
81101df0:	1094ad04 	addi	r2,r2,21172
81101df4:	e0ffe817 	ldw	r3,-96(fp)
81101df8:	18c7883a 	add	r3,r3,r3
81101dfc:	18c7883a 	add	r3,r3,r3
81101e00:	10c5883a 	add	r2,r2,r3
81101e04:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101e08:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101e0c:	e0ffed17 	ldw	r3,-76(fp)
81101e10:	e0bfef17 	ldw	r2,-68(fp)
81101e14:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101e18:	e0bfe817 	ldw	r2,-96(fp)
81101e1c:	1885883a 	add	r2,r3,r2
81101e20:	d8800015 	stw	r2,0(sp)
81101e24:	280f883a 	mov	r7,r5
81101e28:	200d883a 	mov	r6,r4
81101e2c:	01604574 	movhi	r5,33045
81101e30:	29768d04 	addi	r5,r5,-9676
81101e34:	01204574 	movhi	r4,33045
81101e38:	21146d04 	addi	r4,r4,20916
81101e3c:	1124bb40 	call	81124bb4 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e40:	d0a06217 	ldw	r2,-32376(gp)
81101e44:	01604574 	movhi	r5,33045
81101e48:	29546d04 	addi	r5,r5,20916
81101e4c:	1009883a 	mov	r4,r2
81101e50:	11232a00 	call	811232a0 <fprintf>
#endif
				bSuccess = FALSE;
81101e54:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e58:	e0bfe817 	ldw	r2,-96(fp)
81101e5c:	10800044 	addi	r2,r2,1
81101e60:	e0bfe815 	stw	r2,-96(fp)
81101e64:	e0ffe817 	ldw	r3,-96(fp)
81101e68:	e0bfec17 	ldw	r2,-80(fp)
81101e6c:	1880020e 	bge	r3,r2,81101e78 <bDdr2MemoryReadTest+0x348>
81101e70:	e0bfe517 	ldw	r2,-108(fp)
81101e74:	103fd01e 	bne	r2,zero,81101db8 <__reset+0xfb0e1db8>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e78:	e0ffed17 	ldw	r3,-76(fp)
81101e7c:	e0bfe917 	ldw	r2,-92(fp)
81101e80:	1885883a 	add	r2,r3,r2
81101e84:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	10800288 	cmpgei	r2,r2,10
81101e90:	1000191e 	bne	r2,zero,81101ef8 <bDdr2MemoryReadTest+0x3c8>
81101e94:	e0bfee17 	ldw	r2,-72(fp)
81101e98:	1085883a 	add	r2,r2,r2
81101e9c:	1085883a 	add	r2,r2,r2
81101ea0:	e0ffe504 	addi	r3,fp,-108
81101ea4:	1885883a 	add	r2,r3,r2
81101ea8:	10800e04 	addi	r2,r2,56
81101eac:	10800017 	ldw	r2,0(r2)
81101eb0:	e0ffed17 	ldw	r3,-76(fp)
81101eb4:	18801036 	bltu	r3,r2,81101ef8 <bDdr2MemoryReadTest+0x3c8>
			iNProgressIndex++;
81101eb8:	e0bfee17 	ldw	r2,-72(fp)
81101ebc:	10800044 	addi	r2,r2,1
81101ec0:	e0bfee15 	stw	r2,-72(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101ec4:	e0bfee17 	ldw	r2,-72(fp)
81101ec8:	108002a4 	muli	r2,r2,10
81101ecc:	100d883a 	mov	r6,r2
81101ed0:	01604574 	movhi	r5,33045
81101ed4:	29766204 	addi	r5,r5,-9848
81101ed8:	01204574 	movhi	r4,33045
81101edc:	21146d04 	addi	r4,r4,20916
81101ee0:	1124bb40 	call	81124bb4 <sprintf>
			debug(fp, cDebugBuffer);
81101ee4:	d0a06217 	ldw	r2,-32376(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	29546d04 	addi	r5,r5,20916
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	11232a00 	call	811232a0 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ef8:	e0bfe517 	ldw	r2,-108(fp)
81101efc:	10000326 	beq	r2,zero,81101f0c <bDdr2MemoryReadTest+0x3dc>
81101f00:	e0ffed17 	ldw	r3,-76(fp)
81101f04:	e0bfe717 	ldw	r2,-100(fp)
81101f08:	18bf9936 	bltu	r3,r2,81101d70 <__reset+0xfb0e1d70>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101f0c:	00a04574 	movhi	r2,33045
81101f10:	10946d04 	addi	r2,r2,20916
81101f14:	00c00284 	movi	r3,10
81101f18:	10c00005 	stb	r3,0(r2)
81101f1c:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101f20:	d0a06217 	ldw	r2,-32376(gp)
81101f24:	01604574 	movhi	r5,33045
81101f28:	29546d04 	addi	r5,r5,20916
81101f2c:	1009883a 	mov	r4,r2
81101f30:	11232a00 	call	811232a0 <fprintf>
81101f34:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101f38:	e0bff117 	ldw	r2,-60(fp)
81101f3c:	1885c83a 	sub	r2,r3,r2
81101f40:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f44:	e0bfe517 	ldw	r2,-108(fp)
81101f48:	10001e26 	beq	r2,zero,81101fc4 <bDdr2MemoryReadTest+0x494>
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f4c:	e13ff017 	ldw	r4,-64(fp)
81101f50:	11219800 	call	81121980 <__floatsisf>
81101f54:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f58:	d0a08817 	ldw	r2,-32224(gp)
81101f5c:	1009883a 	mov	r4,r2
81101f60:	1121aac0 	call	81121aac <__floatunsisf>
81101f64:	1007883a 	mov	r3,r2
81101f68:	180b883a 	mov	r5,r3
81101f6c:	8009883a 	mov	r4,r16
81101f70:	11211340 	call	81121134 <__divsf3>
81101f74:	1007883a 	mov	r3,r2
81101f78:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f7c:	1009883a 	mov	r4,r2
81101f80:	1122e080 	call	81122e08 <__extendsfdf2>
81101f84:	1009883a 	mov	r4,r2
81101f88:	180b883a 	mov	r5,r3
81101f8c:	d9400015 	stw	r5,0(sp)
81101f90:	200f883a 	mov	r7,r4
81101f94:	e1bfe717 	ldw	r6,-100(fp)
81101f98:	01604574 	movhi	r5,33045
81101f9c:	29769b04 	addi	r5,r5,-9620
81101fa0:	01204574 	movhi	r4,33045
81101fa4:	21146d04 	addi	r4,r4,20916
81101fa8:	1124bb40 	call	81124bb4 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101fac:	d0a06217 	ldw	r2,-32376(gp)
81101fb0:	01604574 	movhi	r5,33045
81101fb4:	29546d04 	addi	r5,r5,20916
81101fb8:	1009883a 	mov	r4,r2
81101fbc:	11232a00 	call	811232a0 <fprintf>
81101fc0:	00000f06 	br	81102000 <bDdr2MemoryReadTest+0x4d0>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101fc4:	00e04574 	movhi	r3,33045
81101fc8:	18d46d04 	addi	r3,r3,20916
81101fcc:	00a04574 	movhi	r2,33045
81101fd0:	10b6a704 	addi	r2,r2,-9572
81101fd4:	1009883a 	mov	r4,r2
81101fd8:	00800544 	movi	r2,21
81101fdc:	100d883a 	mov	r6,r2
81101fe0:	200b883a 	mov	r5,r4
81101fe4:	1809883a 	mov	r4,r3
81101fe8:	11243500 	call	81124350 <memcpy>
		debug(fp, cDebugBuffer);
81101fec:	d0a06217 	ldw	r2,-32376(gp)
81101ff0:	01604574 	movhi	r5,33045
81101ff4:	29546d04 	addi	r5,r5,20916
81101ff8:	1009883a 	mov	r4,r2
81101ffc:	11232a00 	call	811232a0 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102000:	00a04574 	movhi	r2,33045
81102004:	10946d04 	addi	r2,r2,20916
81102008:	00c00284 	movi	r3,10
8110200c:	10c00005 	stb	r3,0(r2)
81102010:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81102014:	d0a06217 	ldw	r2,-32376(gp)
81102018:	01604574 	movhi	r5,33045
8110201c:	29546d04 	addi	r5,r5,20916
81102020:	1009883a 	mov	r4,r2
81102024:	11232a00 	call	811232a0 <fprintf>
#endif

	return bSuccess;
81102028:	e0bfe517 	ldw	r2,-108(fp)
}
8110202c:	e6fffe04 	addi	sp,fp,-8
81102030:	dfc00317 	ldw	ra,12(sp)
81102034:	df000217 	ldw	fp,8(sp)
81102038:	dc400117 	ldw	r17,4(sp)
8110203c:	dc000017 	ldw	r16,0(sp)
81102040:	dec00404 	addi	sp,sp,16
81102044:	f800283a 	ret

81102048 <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102048:	deffec04 	addi	sp,sp,-80
8110204c:	de00012e 	bgeu	sp,et,81102054 <bDdr2MemoryRandomWriteTest+0xc>
81102050:	003b68fa 	trap	3
81102054:	dfc01315 	stw	ra,76(sp)
81102058:	df001215 	stw	fp,72(sp)
8110205c:	dcc01115 	stw	r19,68(sp)
81102060:	dc801015 	stw	r18,64(sp)
81102064:	dc400f15 	stw	r17,60(sp)
81102068:	dc000e15 	stw	r16,56(sp)
8110206c:	df001204 	addi	fp,sp,72
81102070:	2005883a 	mov	r2,r4
81102074:	e17ffa15 	stw	r5,-24(fp)
81102078:	e1bffb15 	stw	r6,-20(fp)
8110207c:	e0bff905 	stb	r2,-28(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102080:	00e04574 	movhi	r3,33045
81102084:	18d46d04 	addi	r3,r3,20916
81102088:	00a04574 	movhi	r2,33045
8110208c:	10b6ad04 	addi	r2,r2,-9548
81102090:	1009883a 	mov	r4,r2
81102094:	00800bc4 	movi	r2,47
81102098:	100d883a 	mov	r6,r2
8110209c:	200b883a 	mov	r5,r4
811020a0:	1809883a 	mov	r4,r3
811020a4:	11243500 	call	81124350 <memcpy>
	debug(fp, cDebugBuffer);
811020a8:	d0a06217 	ldw	r2,-32376(gp)
811020ac:	01604574 	movhi	r5,33045
811020b0:	29546d04 	addi	r5,r5,20916
811020b4:	1009883a 	mov	r4,r2
811020b8:	11232a00 	call	811232a0 <fprintf>
#endif
	bool bSuccess = FALSE;
811020bc:	e03fef15 	stw	zero,-68(fp)
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	switch (ucMemoryId) {
811020c0:	e0bff903 	ldbu	r2,-28(fp)
811020c4:	10000326 	beq	r2,zero,811020d4 <bDdr2MemoryRandomWriteTest+0x8c>
811020c8:	10800060 	cmpeqi	r2,r2,1
811020cc:	10000a1e 	bne	r2,zero,811020f8 <bDdr2MemoryRandomWriteTest+0xb0>
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0xd4>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020d4:	e0bff903 	ldbu	r2,-28(fp)
811020d8:	1009883a 	mov	r4,r2
811020dc:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020e0:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020e4:	00a00034 	movhi	r2,32768
811020e8:	e0bff115 	stw	r2,-60(fp)
		bSuccess = TRUE;
811020ec:	00800044 	movi	r2,1
811020f0:	e0bfef15 	stw	r2,-68(fp)
		break;
811020f4:	00001b06 	br	81102164 <bDdr2MemoryRandomWriteTest+0x11c>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020f8:	e0bff903 	ldbu	r2,-28(fp)
811020fc:	1009883a 	mov	r4,r2
81102100:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102104:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102108:	00a00034 	movhi	r2,32768
8110210c:	e0bff115 	stw	r2,-60(fp)
		bSuccess = TRUE;
81102110:	00800044 	movi	r2,1
81102114:	e0bfef15 	stw	r2,-68(fp)
		break;
81102118:	00001206 	br	81102164 <bDdr2MemoryRandomWriteTest+0x11c>
	default:
		bSuccess = FALSE;
8110211c:	e03fef15 	stw	zero,-68(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81102120:	00e04574 	movhi	r3,33045
81102124:	18d46d04 	addi	r3,r3,20916
81102128:	00a04574 	movhi	r2,33045
8110212c:	10b45e04 	addi	r2,r2,-11912
81102130:	1009883a 	mov	r4,r2
81102134:	00800bc4 	movi	r2,47
81102138:	100d883a 	mov	r6,r2
8110213c:	200b883a 	mov	r5,r4
81102140:	1809883a 	mov	r4,r3
81102144:	11243500 	call	81124350 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102148:	d0a06217 	ldw	r2,-32376(gp)
8110214c:	01604574 	movhi	r5,33045
81102150:	29546d04 	addi	r5,r5,20916
81102154:	1009883a 	mov	r4,r2
81102158:	11232a00 	call	811232a0 <fprintf>
		;
#endif
		return bSuccess;
8110215c:	e0bfef17 	ldw	r2,-68(fp)
81102160:	0000ce06 	br	8110249c <bDdr2MemoryRandomWriteTest+0x454>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102164:	e0bff117 	ldw	r2,-60(fp)
81102168:	1004d53a 	srli	r2,r2,20
8110216c:	100d883a 	mov	r6,r2
81102170:	01604574 	movhi	r5,33045
81102174:	29765704 	addi	r5,r5,-9892
81102178:	01204574 	movhi	r4,33045
8110217c:	21146d04 	addi	r4,r4,20916
81102180:	1124bb40 	call	81124bb4 <sprintf>
	debug(fp, cDebugBuffer);
81102184:	d0a06217 	ldw	r2,-32376(gp)
81102188:	01604574 	movhi	r5,33045
8110218c:	29546d04 	addi	r5,r5,20916
81102190:	1009883a 	mov	r4,r2
81102194:	11232a00 	call	811232a0 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102198:	d0a08917 	ldw	r2,-32220(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
8110219c:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
811021a0:	d0a03717 	ldw	r2,-32548(gp)
811021a4:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811021a8:	e0fff017 	ldw	r3,-64(fp)
811021ac:	e0bff117 	ldw	r2,-60(fp)
811021b0:	1885883a 	add	r2,r3,r2
811021b4:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811021b8:	e0fff117 	ldw	r3,-60(fp)
811021bc:	00b33374 	movhi	r2,52429
811021c0:	10b33344 	addi	r2,r2,-13107
811021c4:	1888383a 	mulxuu	r4,r3,r2
811021c8:	1885383a 	mul	r2,r3,r2
811021cc:	1025883a 	mov	r18,r2
811021d0:	2027883a 	mov	r19,r4
811021d4:	9806d13a 	srli	r3,r19,4
811021d8:	e0bff017 	ldw	r2,-64(fp)
811021dc:	1885883a 	add	r2,r3,r2
811021e0:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
811021e4:	00800144 	movi	r2,5
811021e8:	e0bff405 	stb	r2,-48(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021ec:	00e04574 	movhi	r3,33045
811021f0:	18d46d04 	addi	r3,r3,20916
811021f4:	00a04574 	movhi	r2,33045
811021f8:	10b6b904 	addi	r2,r2,-9500
811021fc:	1009883a 	mov	r4,r2
81102200:	00800584 	movi	r2,22
81102204:	100d883a 	mov	r6,r2
81102208:	200b883a 	mov	r5,r4
8110220c:	1809883a 	mov	r4,r3
81102210:	11243500 	call	81124350 <memcpy>
	debug(fp, cDebugBuffer);
81102214:	d0a06217 	ldw	r2,-32376(gp)
81102218:	01604574 	movhi	r5,33045
8110221c:	29546d04 	addi	r5,r5,20916
81102220:	1009883a 	mov	r4,r2
81102224:	11232a00 	call	811232a0 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102228:	e0bffa17 	ldw	r2,-24(fp)
8110222c:	10800058 	cmpnei	r2,r2,1
81102230:	10000a1e 	bne	r2,zero,8110225c <bDdr2MemoryRandomWriteTest+0x214>
#if DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102234:	01604574 	movhi	r5,33045
81102238:	2976bf04 	addi	r5,r5,-9476
8110223c:	01204574 	movhi	r4,33045
81102240:	21146d04 	addi	r4,r4,20916
81102244:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, cDebugBuffer);
81102248:	d0a06217 	ldw	r2,-32376(gp)
8110224c:	01604574 	movhi	r5,33045
81102250:	29546d04 	addi	r5,r5,20916
81102254:	1009883a 	mov	r4,r2
81102258:	11232a00 	call	811232a0 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
8110225c:	e03ff615 	stw	zero,-40(fp)
81102260:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
81102264:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102268:	e0bff017 	ldw	r2,-64(fp)
8110226c:	e0bff215 	stw	r2,-56(fp)
81102270:	00002c06 	br	81102324 <bDdr2MemoryRandomWriteTest+0x2dc>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
81102274:	e0bff804 	addi	r2,fp,-32
81102278:	1009883a 	mov	r4,r2
8110227c:	11029640 	call	81102964 <uliXorshift32>
81102280:	1007883a 	mov	r3,r2
81102284:	e0bff217 	ldw	r2,-56(fp)
81102288:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
8110228c:	e0bffa17 	ldw	r2,-24(fp)
81102290:	10800060 	cmpeqi	r2,r2,1
81102294:	1009883a 	mov	r4,r2
81102298:	e0bff217 	ldw	r2,-56(fp)
8110229c:	e0fff317 	ldw	r3,-52(fp)
811022a0:	1885803a 	cmpltu	r2,r3,r2
811022a4:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
811022a8:	10803fcc 	andi	r2,r2,255
811022ac:	10001a26 	beq	r2,zero,81102318 <bDdr2MemoryRandomWriteTest+0x2d0>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#if DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
811022b0:	e0bff403 	ldbu	r2,-48(fp)
811022b4:	100d883a 	mov	r6,r2
811022b8:	01604574 	movhi	r5,33045
811022bc:	2976c104 	addi	r5,r5,-9468
811022c0:	01204574 	movhi	r4,33045
811022c4:	21146d04 	addi	r4,r4,20916
811022c8:	1124bb40 	call	81124bb4 <sprintf>
			debug(fp, cDebugBuffer);
811022cc:	d0a06217 	ldw	r2,-32376(gp)
811022d0:	01604574 	movhi	r5,33045
811022d4:	29546d04 	addi	r5,r5,20916
811022d8:	1009883a 	mov	r4,r2
811022dc:	11232a00 	call	811232a0 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
811022e0:	e0fff117 	ldw	r3,-60(fp)
811022e4:	00b33374 	movhi	r2,52429
811022e8:	10b33344 	addi	r2,r2,-13107
811022ec:	1888383a 	mulxuu	r4,r3,r2
811022f0:	1885383a 	mul	r2,r3,r2
811022f4:	1021883a 	mov	r16,r2
811022f8:	2023883a 	mov	r17,r4
811022fc:	8804d13a 	srli	r2,r17,4
81102300:	e0fff317 	ldw	r3,-52(fp)
81102304:	1885883a 	add	r2,r3,r2
81102308:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
8110230c:	e0bff403 	ldbu	r2,-48(fp)
81102310:	10800144 	addi	r2,r2,5
81102314:	e0bff405 	stb	r2,-48(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
81102318:	e0bff217 	ldw	r2,-56(fp)
8110231c:	10800104 	addi	r2,r2,4
81102320:	e0bff215 	stw	r2,-56(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
81102324:	e0fff217 	ldw	r3,-56(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102328:	e0bff517 	ldw	r2,-44(fp)
8110232c:	18bfd136 	bltu	r3,r2,81102274 <__reset+0xfb0e2274>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
81102330:	11381300 	call	81138130 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
81102334:	e0bffa17 	ldw	r2,-24(fp)
81102338:	10800058 	cmpnei	r2,r2,1
8110233c:	10000a1e 	bne	r2,zero,81102368 <bDdr2MemoryRandomWriteTest+0x320>
#if DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102340:	01604574 	movhi	r5,33045
81102344:	2976c404 	addi	r5,r5,-9456
81102348:	01204574 	movhi	r4,33045
8110234c:	21146d04 	addi	r4,r4,20916
81102350:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, cDebugBuffer);
81102354:	d0a06217 	ldw	r2,-32376(gp)
81102358:	01604574 	movhi	r5,33045
8110235c:	29546d04 	addi	r5,r5,20916
81102360:	1009883a 	mov	r4,r2
81102364:	11232a00 	call	811232a0 <fprintf>
#endif
	}

	if (bSuccess) {
81102368:	e0bfef17 	ldw	r2,-68(fp)
8110236c:	10003126 	beq	r2,zero,81102434 <bDdr2MemoryRandomWriteTest+0x3ec>
		if (bTime == TRUE) {
81102370:	e0bffb17 	ldw	r2,-20(fp)
81102374:	10800058 	cmpnei	r2,r2,1
81102378:	1000221e 	bne	r2,zero,81102404 <bDdr2MemoryRandomWriteTest+0x3bc>
8110237c:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102380:	e0bff717 	ldw	r2,-36(fp)
81102384:	1885c83a 	sub	r2,r3,r2
81102388:	e0bff615 	stw	r2,-40(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
8110238c:	e13ff617 	ldw	r4,-40(fp)
81102390:	11219800 	call	81121980 <__floatsisf>
81102394:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102398:	d0a08817 	ldw	r2,-32224(gp)
8110239c:	1009883a 	mov	r4,r2
811023a0:	1121aac0 	call	81121aac <__floatunsisf>
811023a4:	1007883a 	mov	r3,r2
811023a8:	180b883a 	mov	r5,r3
811023ac:	8009883a 	mov	r4,r16
811023b0:	11211340 	call	81121134 <__divsf3>
811023b4:	1007883a 	mov	r3,r2
811023b8:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#if DEBUG_ON
			sprintf(cDebugBuffer,
811023bc:	1009883a 	mov	r4,r2
811023c0:	1122e080 	call	81122e08 <__extendsfdf2>
811023c4:	1009883a 	mov	r4,r2
811023c8:	180b883a 	mov	r5,r3
811023cc:	d9400015 	stw	r5,0(sp)
811023d0:	200f883a 	mov	r7,r4
811023d4:	e1bff117 	ldw	r6,-60(fp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	2976c704 	addi	r5,r5,-9444
811023e0:	01204574 	movhi	r4,33045
811023e4:	21146d04 	addi	r4,r4,20916
811023e8:	1124bb40 	call	81124bb4 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023ec:	d0a06217 	ldw	r2,-32376(gp)
811023f0:	01604574 	movhi	r5,33045
811023f4:	29546d04 	addi	r5,r5,20916
811023f8:	1009883a 	mov	r4,r2
811023fc:	11232a00 	call	811232a0 <fprintf>
81102400:	00001b06 	br	81102470 <bDdr2MemoryRandomWriteTest+0x428>
#endif
		} else {
#if DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
81102404:	e1bff117 	ldw	r6,-60(fp)
81102408:	01604574 	movhi	r5,33045
8110240c:	2976d304 	addi	r5,r5,-9396
81102410:	01204574 	movhi	r4,33045
81102414:	21146d04 	addi	r4,r4,20916
81102418:	1124bb40 	call	81124bb4 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110241c:	d0a06217 	ldw	r2,-32376(gp)
81102420:	01604574 	movhi	r5,33045
81102424:	29546d04 	addi	r5,r5,20916
81102428:	1009883a 	mov	r4,r2
8110242c:	11232a00 	call	811232a0 <fprintf>
81102430:	00000f06 	br	81102470 <bDdr2MemoryRandomWriteTest+0x428>
#endif
		}
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81102434:	00e04574 	movhi	r3,33045
81102438:	18d46d04 	addi	r3,r3,20916
8110243c:	00a04574 	movhi	r2,33045
81102440:	10b67004 	addi	r2,r2,-9792
81102444:	1009883a 	mov	r4,r2
81102448:	00800584 	movi	r2,22
8110244c:	100d883a 	mov	r6,r2
81102450:	200b883a 	mov	r5,r4
81102454:	1809883a 	mov	r4,r3
81102458:	11243500 	call	81124350 <memcpy>
		debug(fp, cDebugBuffer);
8110245c:	d0a06217 	ldw	r2,-32376(gp)
81102460:	01604574 	movhi	r5,33045
81102464:	29546d04 	addi	r5,r5,20916
81102468:	1009883a 	mov	r4,r2
8110246c:	11232a00 	call	811232a0 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102470:	00a04574 	movhi	r2,33045
81102474:	10946d04 	addi	r2,r2,20916
81102478:	00c00284 	movi	r3,10
8110247c:	10c00005 	stb	r3,0(r2)
81102480:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81102484:	d0a06217 	ldw	r2,-32376(gp)
81102488:	01604574 	movhi	r5,33045
8110248c:	29546d04 	addi	r5,r5,20916
81102490:	1009883a 	mov	r4,r2
81102494:	11232a00 	call	811232a0 <fprintf>
#endif

	return bSuccess;
81102498:	e0bfef17 	ldw	r2,-68(fp)
}
8110249c:	e6fffc04 	addi	sp,fp,-16
811024a0:	dfc00517 	ldw	ra,20(sp)
811024a4:	df000417 	ldw	fp,16(sp)
811024a8:	dcc00317 	ldw	r19,12(sp)
811024ac:	dc800217 	ldw	r18,8(sp)
811024b0:	dc400117 	ldw	r17,4(sp)
811024b4:	dc000017 	ldw	r16,0(sp)
811024b8:	dec00604 	addi	sp,sp,24
811024bc:	f800283a 	ret

811024c0 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
811024c0:	deffec04 	addi	sp,sp,-80
811024c4:	de00012e 	bgeu	sp,et,811024cc <bDdr2MemoryRandomReadTest+0xc>
811024c8:	003b68fa 	trap	3
811024cc:	dfc01315 	stw	ra,76(sp)
811024d0:	df001215 	stw	fp,72(sp)
811024d4:	dcc01115 	stw	r19,68(sp)
811024d8:	dc801015 	stw	r18,64(sp)
811024dc:	dc400f15 	stw	r17,60(sp)
811024e0:	dc000e15 	stw	r16,56(sp)
811024e4:	df001204 	addi	fp,sp,72
811024e8:	2005883a 	mov	r2,r4
811024ec:	e17ffa15 	stw	r5,-24(fp)
811024f0:	e1bffb15 	stw	r6,-20(fp)
811024f4:	e0bff905 	stb	r2,-28(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024f8:	00e04574 	movhi	r3,33045
811024fc:	18d46d04 	addi	r3,r3,20916
81102500:	00a04574 	movhi	r2,33045
81102504:	10b6dd04 	addi	r2,r2,-9356
81102508:	1009883a 	mov	r4,r2
8110250c:	00800b84 	movi	r2,46
81102510:	100d883a 	mov	r6,r2
81102514:	200b883a 	mov	r5,r4
81102518:	1809883a 	mov	r4,r3
8110251c:	11243500 	call	81124350 <memcpy>
	debug(fp, cDebugBuffer);
81102520:	d0a06217 	ldw	r2,-32376(gp)
81102524:	01604574 	movhi	r5,33045
81102528:	29546d04 	addi	r5,r5,20916
8110252c:	1009883a 	mov	r4,r2
81102530:	11232a00 	call	811232a0 <fprintf>
#endif
	bool bSuccess = FALSE;
81102534:	e03fef15 	stw	zero,-68(fp)
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	switch (ucMemoryId) {
81102538:	e0bff903 	ldbu	r2,-28(fp)
8110253c:	10000326 	beq	r2,zero,8110254c <bDdr2MemoryRandomReadTest+0x8c>
81102540:	10800060 	cmpeqi	r2,r2,1
81102544:	10000a1e 	bne	r2,zero,81102570 <bDdr2MemoryRandomReadTest+0xb0>
81102548:	00001206 	br	81102594 <bDdr2MemoryRandomReadTest+0xd4>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110254c:	e0bff903 	ldbu	r2,-28(fp)
81102550:	1009883a 	mov	r4,r2
81102554:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102558:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
8110255c:	00a00034 	movhi	r2,32768
81102560:	e0bff115 	stw	r2,-60(fp)
		bSuccess = TRUE;
81102564:	00800044 	movi	r2,1
81102568:	e0bfef15 	stw	r2,-68(fp)
		break;
8110256c:	00001b06 	br	811025dc <bDdr2MemoryRandomReadTest+0x11c>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102570:	e0bff903 	ldbu	r2,-28(fp)
81102574:	1009883a 	mov	r4,r2
81102578:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110257c:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102580:	00a00034 	movhi	r2,32768
81102584:	e0bff115 	stw	r2,-60(fp)
		bSuccess = TRUE;
81102588:	00800044 	movi	r2,1
8110258c:	e0bfef15 	stw	r2,-68(fp)
		break;
81102590:	00001206 	br	811025dc <bDdr2MemoryRandomReadTest+0x11c>
	default:
		bSuccess = FALSE;
81102594:	e03fef15 	stw	zero,-68(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81102598:	00e04574 	movhi	r3,33045
8110259c:	18d46d04 	addi	r3,r3,20916
811025a0:	00a04574 	movhi	r2,33045
811025a4:	10b45e04 	addi	r2,r2,-11912
811025a8:	1009883a 	mov	r4,r2
811025ac:	00800bc4 	movi	r2,47
811025b0:	100d883a 	mov	r6,r2
811025b4:	200b883a 	mov	r5,r4
811025b8:	1809883a 	mov	r4,r3
811025bc:	11243500 	call	81124350 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811025c0:	d0a06217 	ldw	r2,-32376(gp)
811025c4:	01604574 	movhi	r5,33045
811025c8:	29546d04 	addi	r5,r5,20916
811025cc:	1009883a 	mov	r4,r2
811025d0:	11232a00 	call	811232a0 <fprintf>
		;
#endif
		return bSuccess;
811025d4:	e0bfef17 	ldw	r2,-68(fp)
811025d8:	0000d906 	br	81102940 <bDdr2MemoryRandomReadTest+0x480>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
811025dc:	e0bff117 	ldw	r2,-60(fp)
811025e0:	1004d53a 	srli	r2,r2,20
811025e4:	100d883a 	mov	r6,r2
811025e8:	01604574 	movhi	r5,33045
811025ec:	29765704 	addi	r5,r5,-9892
811025f0:	01204574 	movhi	r4,33045
811025f4:	21146d04 	addi	r4,r4,20916
811025f8:	1124bb40 	call	81124bb4 <sprintf>
	debug(fp, cDebugBuffer);
811025fc:	d0a06217 	ldw	r2,-32376(gp)
81102600:	01604574 	movhi	r5,33045
81102604:	29546d04 	addi	r5,r5,20916
81102608:	1009883a 	mov	r4,r2
8110260c:	11232a00 	call	811232a0 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
81102610:	d0a03717 	ldw	r2,-32548(gp)
81102614:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102618:	e0fff017 	ldw	r3,-64(fp)
8110261c:	e0bff117 	ldw	r2,-60(fp)
81102620:	1885883a 	add	r2,r3,r2
81102624:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102628:	e0fff117 	ldw	r3,-60(fp)
8110262c:	00b33374 	movhi	r2,52429
81102630:	10b33344 	addi	r2,r2,-13107
81102634:	1888383a 	mulxuu	r4,r3,r2
81102638:	1885383a 	mul	r2,r3,r2
8110263c:	1025883a 	mov	r18,r2
81102640:	2027883a 	mov	r19,r4
81102644:	9806d13a 	srli	r3,r19,4
81102648:	e0bff017 	ldw	r2,-64(fp)
8110264c:	1885883a 	add	r2,r3,r2
81102650:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102654:	00800144 	movi	r2,5
81102658:	e0bff405 	stb	r2,-48(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
8110265c:	00e04574 	movhi	r3,33045
81102660:	18d46d04 	addi	r3,r3,20916
81102664:	00a04574 	movhi	r2,33045
81102668:	10b6e904 	addi	r2,r2,-9308
8110266c:	1009883a 	mov	r4,r2
81102670:	00800604 	movi	r2,24
81102674:	100d883a 	mov	r6,r2
81102678:	200b883a 	mov	r5,r4
8110267c:	1809883a 	mov	r4,r3
81102680:	11243500 	call	81124350 <memcpy>
	debug(fp, cDebugBuffer);
81102684:	d0a06217 	ldw	r2,-32376(gp)
81102688:	01604574 	movhi	r5,33045
8110268c:	29546d04 	addi	r5,r5,20916
81102690:	1009883a 	mov	r4,r2
81102694:	11232a00 	call	811232a0 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102698:	e0bffa17 	ldw	r2,-24(fp)
8110269c:	10800058 	cmpnei	r2,r2,1
811026a0:	10000a1e 	bne	r2,zero,811026cc <bDdr2MemoryRandomReadTest+0x20c>
#if DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811026a4:	01604574 	movhi	r5,33045
811026a8:	2976bf04 	addi	r5,r5,-9476
811026ac:	01204574 	movhi	r4,33045
811026b0:	21146d04 	addi	r4,r4,20916
811026b4:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, cDebugBuffer);
811026b8:	d0a06217 	ldw	r2,-32376(gp)
811026bc:	01604574 	movhi	r5,33045
811026c0:	29546d04 	addi	r5,r5,20916
811026c4:	1009883a 	mov	r4,r2
811026c8:	11232a00 	call	811232a0 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
811026cc:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
811026d0:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
811026d4:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
811026d8:	e0bff017 	ldw	r2,-64(fp)
811026dc:	e0bff215 	stw	r2,-56(fp)
811026e0:	00003a06 	br	811027cc <bDdr2MemoryRandomReadTest+0x30c>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
811026e4:	e0bff804 	addi	r2,fp,-32
811026e8:	1009883a 	mov	r4,r2
811026ec:	11029640 	call	81102964 <uliXorshift32>
811026f0:	1007883a 	mov	r3,r2
811026f4:	e0bff217 	ldw	r2,-56(fp)
811026f8:	10800017 	ldw	r2,0(r2)
811026fc:	18801026 	beq	r3,r2,81102740 <bDdr2MemoryRandomReadTest+0x280>
			bSuccess = FALSE;
81102700:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
81102704:	e0bffa17 	ldw	r2,-24(fp)
81102708:	10800058 	cmpnei	r2,r2,1
8110270c:	10000c1e 	bne	r2,zero,81102740 <bDdr2MemoryRandomReadTest+0x280>
#if DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
81102710:	e0bff217 	ldw	r2,-56(fp)
81102714:	100d883a 	mov	r6,r2
81102718:	01604574 	movhi	r5,33045
8110271c:	2976ef04 	addi	r5,r5,-9284
81102720:	01204574 	movhi	r4,33045
81102724:	21146d04 	addi	r4,r4,20916
81102728:	1124bb40 	call	81124bb4 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
8110272c:	d0a06217 	ldw	r2,-32376(gp)
81102730:	01604574 	movhi	r5,33045
81102734:	29546d04 	addi	r5,r5,20916
81102738:	1009883a 	mov	r4,r2
8110273c:	11232a00 	call	811232a0 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
81102740:	e0bffa17 	ldw	r2,-24(fp)
81102744:	10800058 	cmpnei	r2,r2,1
81102748:	10001d1e 	bne	r2,zero,811027c0 <bDdr2MemoryRandomReadTest+0x300>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
8110274c:	e0bff217 	ldw	r2,-56(fp)
81102750:	e0fff317 	ldw	r3,-52(fp)
81102754:	18801a2e 	bgeu	r3,r2,811027c0 <bDdr2MemoryRandomReadTest+0x300>
#if DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102758:	e0bff403 	ldbu	r2,-48(fp)
8110275c:	100d883a 	mov	r6,r2
81102760:	01604574 	movhi	r5,33045
81102764:	2976c104 	addi	r5,r5,-9468
81102768:	01204574 	movhi	r4,33045
8110276c:	21146d04 	addi	r4,r4,20916
81102770:	1124bb40 	call	81124bb4 <sprintf>
			debug(fp, cDebugBuffer);
81102774:	d0a06217 	ldw	r2,-32376(gp)
81102778:	01604574 	movhi	r5,33045
8110277c:	29546d04 	addi	r5,r5,20916
81102780:	1009883a 	mov	r4,r2
81102784:	11232a00 	call	811232a0 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102788:	e0fff117 	ldw	r3,-60(fp)
8110278c:	00b33374 	movhi	r2,52429
81102790:	10b33344 	addi	r2,r2,-13107
81102794:	1888383a 	mulxuu	r4,r3,r2
81102798:	1885383a 	mul	r2,r3,r2
8110279c:	1021883a 	mov	r16,r2
811027a0:	2023883a 	mov	r17,r4
811027a4:	8804d13a 	srli	r2,r17,4
811027a8:	e0fff317 	ldw	r3,-52(fp)
811027ac:	1885883a 	add	r2,r3,r2
811027b0:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
811027b4:	e0bff403 	ldbu	r2,-48(fp)
811027b8:	10800144 	addi	r2,r2,5
811027bc:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
811027c0:	e0bff217 	ldw	r2,-56(fp)
811027c4:	10800104 	addi	r2,r2,4
811027c8:	e0bff215 	stw	r2,-56(fp)
811027cc:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
811027d0:	e0bff517 	ldw	r2,-44(fp)
811027d4:	18bfc336 	bltu	r3,r2,811026e4 <__reset+0xfb0e26e4>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
811027d8:	e0bffa17 	ldw	r2,-24(fp)
811027dc:	10800058 	cmpnei	r2,r2,1
811027e0:	10000a1e 	bne	r2,zero,8110280c <bDdr2MemoryRandomReadTest+0x34c>
#if DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811027e4:	01604574 	movhi	r5,33045
811027e8:	2976c404 	addi	r5,r5,-9456
811027ec:	01204574 	movhi	r4,33045
811027f0:	21146d04 	addi	r4,r4,20916
811027f4:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, cDebugBuffer);
811027f8:	d0a06217 	ldw	r2,-32376(gp)
811027fc:	01604574 	movhi	r5,33045
81102800:	29546d04 	addi	r5,r5,20916
81102804:	1009883a 	mov	r4,r2
81102808:	11232a00 	call	811232a0 <fprintf>
#endif
	}

	if (bSuccess) {
8110280c:	e0bfef17 	ldw	r2,-68(fp)
81102810:	10003126 	beq	r2,zero,811028d8 <bDdr2MemoryRandomReadTest+0x418>
		if (bTime == TRUE) {
81102814:	e0bffb17 	ldw	r2,-20(fp)
81102818:	10800058 	cmpnei	r2,r2,1
8110281c:	1000221e 	bne	r2,zero,811028a8 <bDdr2MemoryRandomReadTest+0x3e8>
81102820:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102824:	e0bff717 	ldw	r2,-36(fp)
81102828:	1885c83a 	sub	r2,r3,r2
8110282c:	e0bff615 	stw	r2,-40(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102830:	e13ff617 	ldw	r4,-40(fp)
81102834:	11219800 	call	81121980 <__floatsisf>
81102838:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8110283c:	d0a08817 	ldw	r2,-32224(gp)
81102840:	1009883a 	mov	r4,r2
81102844:	1121aac0 	call	81121aac <__floatunsisf>
81102848:	1007883a 	mov	r3,r2
8110284c:	180b883a 	mov	r5,r3
81102850:	8009883a 	mov	r4,r16
81102854:	11211340 	call	81121134 <__divsf3>
81102858:	1007883a 	mov	r3,r2
8110285c:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#if DEBUG_ON
			sprintf(cDebugBuffer,
81102860:	1009883a 	mov	r4,r2
81102864:	1122e080 	call	81122e08 <__extendsfdf2>
81102868:	1009883a 	mov	r4,r2
8110286c:	180b883a 	mov	r5,r3
81102870:	d9400015 	stw	r5,0(sp)
81102874:	200f883a 	mov	r7,r4
81102878:	e1bff117 	ldw	r6,-60(fp)
8110287c:	01604574 	movhi	r5,33045
81102880:	2976f704 	addi	r5,r5,-9252
81102884:	01204574 	movhi	r4,33045
81102888:	21146d04 	addi	r4,r4,20916
8110288c:	1124bb40 	call	81124bb4 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
81102890:	d0a06217 	ldw	r2,-32376(gp)
81102894:	01604574 	movhi	r5,33045
81102898:	29546d04 	addi	r5,r5,20916
8110289c:	1009883a 	mov	r4,r2
811028a0:	11232a00 	call	811232a0 <fprintf>
811028a4:	00001b06 	br	81102914 <bDdr2MemoryRandomReadTest+0x454>
#endif
		} else {
#if DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
811028a8:	e1bff117 	ldw	r6,-60(fp)
811028ac:	01604574 	movhi	r5,33045
811028b0:	29770304 	addi	r5,r5,-9204
811028b4:	01204574 	movhi	r4,33045
811028b8:	21146d04 	addi	r4,r4,20916
811028bc:	1124bb40 	call	81124bb4 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811028c0:	d0a06217 	ldw	r2,-32376(gp)
811028c4:	01604574 	movhi	r5,33045
811028c8:	29546d04 	addi	r5,r5,20916
811028cc:	1009883a 	mov	r4,r2
811028d0:	11232a00 	call	811232a0 <fprintf>
811028d4:	00000f06 	br	81102914 <bDdr2MemoryRandomReadTest+0x454>
#endif
		}
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
811028d8:	00e04574 	movhi	r3,33045
811028dc:	18d46d04 	addi	r3,r3,20916
811028e0:	00a04574 	movhi	r2,33045
811028e4:	10b6a704 	addi	r2,r2,-9572
811028e8:	1009883a 	mov	r4,r2
811028ec:	00800544 	movi	r2,21
811028f0:	100d883a 	mov	r6,r2
811028f4:	200b883a 	mov	r5,r4
811028f8:	1809883a 	mov	r4,r3
811028fc:	11243500 	call	81124350 <memcpy>
		debug(fp, cDebugBuffer);
81102900:	d0a06217 	ldw	r2,-32376(gp)
81102904:	01604574 	movhi	r5,33045
81102908:	29546d04 	addi	r5,r5,20916
8110290c:	1009883a 	mov	r4,r2
81102910:	11232a00 	call	811232a0 <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102914:	00a04574 	movhi	r2,33045
81102918:	10946d04 	addi	r2,r2,20916
8110291c:	00c00284 	movi	r3,10
81102920:	10c00005 	stb	r3,0(r2)
81102924:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81102928:	d0a06217 	ldw	r2,-32376(gp)
8110292c:	01604574 	movhi	r5,33045
81102930:	29546d04 	addi	r5,r5,20916
81102934:	1009883a 	mov	r4,r2
81102938:	11232a00 	call	811232a0 <fprintf>
#endif

	return bSuccess;
8110293c:	e0bfef17 	ldw	r2,-68(fp)
}
81102940:	e6fffc04 	addi	sp,fp,-16
81102944:	dfc00517 	ldw	ra,20(sp)
81102948:	df000417 	ldw	fp,16(sp)
8110294c:	dcc00317 	ldw	r19,12(sp)
81102950:	dc800217 	ldw	r18,8(sp)
81102954:	dc400117 	ldw	r17,4(sp)
81102958:	dc000017 	ldw	r16,0(sp)
8110295c:	dec00604 	addi	sp,sp,24
81102960:	f800283a 	ret

81102964 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102964:	defffd04 	addi	sp,sp,-12
81102968:	de00012e 	bgeu	sp,et,81102970 <uliXorshift32+0xc>
8110296c:	003b68fa 	trap	3
81102970:	df000215 	stw	fp,8(sp)
81102974:	df000204 	addi	fp,sp,8
81102978:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
8110297c:	e0bfff17 	ldw	r2,-4(fp)
81102980:	10800017 	ldw	r2,0(r2)
81102984:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102988:	e0bffe17 	ldw	r2,-8(fp)
8110298c:	1004937a 	slli	r2,r2,13
81102990:	e0fffe17 	ldw	r3,-8(fp)
81102994:	1884f03a 	xor	r2,r3,r2
81102998:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
8110299c:	e0bffe17 	ldw	r2,-8(fp)
811029a0:	1004d47a 	srli	r2,r2,17
811029a4:	e0fffe17 	ldw	r3,-8(fp)
811029a8:	1884f03a 	xor	r2,r3,r2
811029ac:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
811029b0:	e0bffe17 	ldw	r2,-8(fp)
811029b4:	1004917a 	slli	r2,r2,5
811029b8:	e0fffe17 	ldw	r3,-8(fp)
811029bc:	1884f03a 	xor	r2,r3,r2
811029c0:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
811029c4:	e0bfff17 	ldw	r2,-4(fp)
811029c8:	e0fffe17 	ldw	r3,-8(fp)
811029cc:	10c00015 	stw	r3,0(r2)

	return uliX;
811029d0:	e0bffe17 	ldw	r2,-8(fp)
}
811029d4:	e037883a 	mov	sp,fp
811029d8:	df000017 	ldw	fp,0(sp)
811029dc:	dec00104 	addi	sp,sp,4
811029e0:	f800283a 	ret

811029e4 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
811029e4:	defffb04 	addi	sp,sp,-20
811029e8:	de00012e 	bgeu	sp,et,811029f0 <DMA_OPEN_DEVICE+0xc>
811029ec:	003b68fa 	trap	3
811029f0:	dfc00415 	stw	ra,16(sp)
811029f4:	df000315 	stw	fp,12(sp)
811029f8:	df000304 	addi	fp,sp,12
811029fc:	e13ffe15 	stw	r4,-8(fp)
81102a00:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a04:	00800044 	movi	r2,1
81102a08:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
81102a0c:	e13fff17 	ldw	r4,-4(fp)
81102a10:	114b9f00 	call	8114b9f0 <alt_msgdma_open>
81102a14:	1007883a 	mov	r3,r2
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
81102a20:	e0bffe17 	ldw	r2,-8(fp)
81102a24:	10800017 	ldw	r2,0(r2)
81102a28:	1000011e 	bne	r2,zero,81102a30 <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
81102a2c:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
81102a30:	e0bffd17 	ldw	r2,-12(fp)
}
81102a34:	e037883a 	mov	sp,fp
81102a38:	dfc00117 	ldw	ra,4(sp)
81102a3c:	df000017 	ldw	fp,0(sp)
81102a40:	dec00204 	addi	sp,sp,8
81102a44:	f800283a 	ret

81102a48 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
81102a48:	defffc04 	addi	sp,sp,-16
81102a4c:	de00012e 	bgeu	sp,et,81102a54 <DMA_CONFIG+0xc>
81102a50:	003b68fa 	trap	3
81102a54:	df000315 	stw	fp,12(sp)
81102a58:	df000304 	addi	fp,sp,12
81102a5c:	e13ffe15 	stw	r4,-8(fp)
81102a60:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a64:	00800044 	movi	r2,1
81102a68:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a6c:	e0bffe17 	ldw	r2,-8(fp)
81102a70:	10800317 	ldw	r2,12(r2)
81102a74:	10800104 	addi	r2,r2,4
81102a78:	e0ffff17 	ldw	r3,-4(fp)
81102a7c:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a80:	e0bffd17 	ldw	r2,-12(fp)
}
81102a84:	e037883a 	mov	sp,fp
81102a88:	df000017 	ldw	fp,0(sp)
81102a8c:	dec00104 	addi	sp,sp,4
81102a90:	f800283a 	ret

81102a94 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a94:	defffd04 	addi	sp,sp,-12
81102a98:	de00012e 	bgeu	sp,et,81102aa0 <DMA_BUSY+0xc>
81102a9c:	003b68fa 	trap	3
81102aa0:	df000215 	stw	fp,8(sp)
81102aa4:	df000204 	addi	fp,sp,8
81102aa8:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102aac:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102ab0:	e0bfff17 	ldw	r2,-4(fp)
81102ab4:	10800317 	ldw	r2,12(r2)
81102ab8:	10800037 	ldwio	r2,0(r2)
81102abc:	1080004c 	andi	r2,r2,1
81102ac0:	10000226 	beq	r2,zero,81102acc <DMA_BUSY+0x38>
    bBusy = TRUE;
81102ac4:	00800044 	movi	r2,1
81102ac8:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102acc:	e0bffe17 	ldw	r2,-8(fp)
}
81102ad0:	e037883a 	mov	sp,fp
81102ad4:	df000017 	ldw	fp,0(sp)
81102ad8:	dec00104 	addi	sp,sp,4
81102adc:	f800283a 	ret

81102ae0 <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102ae0:	defffd04 	addi	sp,sp,-12
81102ae4:	de00012e 	bgeu	sp,et,81102aec <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102ae8:	003b68fa 	trap	3
81102aec:	df000215 	stw	fp,8(sp)
81102af0:	df000204 	addi	fp,sp,8
81102af4:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102af8:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102afc:	e0bfff17 	ldw	r2,-4(fp)
81102b00:	10800317 	ldw	r2,12(r2)
81102b04:	10800037 	ldwio	r2,0(r2)
81102b08:	1080010c 	andi	r2,r2,4
81102b0c:	10000226 	beq	r2,zero,81102b18 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102b10:	00800044 	movi	r2,1
81102b14:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102b18:	e0bffe17 	ldw	r2,-8(fp)
}
81102b1c:	e037883a 	mov	sp,fp
81102b20:	df000017 	ldw	fp,0(sp)
81102b24:	dec00104 	addi	sp,sp,4
81102b28:	f800283a 	ret

81102b2c <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102b2c:	defffd04 	addi	sp,sp,-12
81102b30:	de00012e 	bgeu	sp,et,81102b38 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102b34:	003b68fa 	trap	3
81102b38:	df000215 	stw	fp,8(sp)
81102b3c:	df000204 	addi	fp,sp,8
81102b40:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102b44:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102b48:	e0bfff17 	ldw	r2,-4(fp)
81102b4c:	10800317 	ldw	r2,12(r2)
81102b50:	10800037 	ldwio	r2,0(r2)
81102b54:	1080008c 	andi	r2,r2,2
81102b58:	10000226 	beq	r2,zero,81102b64 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b5c:	00800044 	movi	r2,1
81102b60:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b64:	e0bffe17 	ldw	r2,-8(fp)
}
81102b68:	e037883a 	mov	sp,fp
81102b6c:	df000017 	ldw	fp,0(sp)
81102b70:	dec00104 	addi	sp,sp,4
81102b74:	f800283a 	ret

81102b78 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b78:	defffa04 	addi	sp,sp,-24
81102b7c:	de00012e 	bgeu	sp,et,81102b84 <DMA_DISPATCHER_STOP+0xc>
81102b80:	003b68fa 	trap	3
81102b84:	dfc00515 	stw	ra,20(sp)
81102b88:	df000415 	stw	fp,16(sp)
81102b8c:	df000404 	addi	fp,sp,16
81102b90:	e13ffd15 	stw	r4,-12(fp)
81102b94:	e17ffe15 	stw	r5,-8(fp)
81102b98:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b9c:	00800044 	movi	r2,1
81102ba0:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102ba4:	e0bffd17 	ldw	r2,-12(fp)
81102ba8:	10800317 	ldw	r2,12(r2)
81102bac:	10800104 	addi	r2,r2,4
81102bb0:	00c00044 	movi	r3,1
81102bb4:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102bb8:	e0bffe17 	ldw	r2,-8(fp)
81102bbc:	10800058 	cmpnei	r2,r2,1
81102bc0:	10000f1e 	bne	r2,zero,81102c00 <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102bc4:	00000806 	br	81102be8 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102bc8:	e0bfff17 	ldw	r2,-4(fp)
81102bcc:	1000031e 	bne	r2,zero,81102bdc <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102bd0:	01000044 	movi	r4,1
81102bd4:	11399580 	call	81139958 <usleep>
81102bd8:	00000306 	br	81102be8 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102bdc:	e0bfff17 	ldw	r2,-4(fp)
81102be0:	1009883a 	mov	r4,r2
81102be4:	11399580 	call	81139958 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102be8:	e0bffd17 	ldw	r2,-12(fp)
81102bec:	10800317 	ldw	r2,12(r2)
81102bf0:	10800037 	ldwio	r2,0(r2)
81102bf4:	1080080c 	andi	r2,r2,32
81102bf8:	103ff31e 	bne	r2,zero,81102bc8 <__reset+0xfb0e2bc8>
81102bfc:	00000206 	br	81102c08 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c00:	e0bffc17 	ldw	r2,-16(fp)
81102c04:	00000106 	br	81102c0c <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102c08:	e0bffc17 	ldw	r2,-16(fp)
}
81102c0c:	e037883a 	mov	sp,fp
81102c10:	dfc00117 	ldw	ra,4(sp)
81102c14:	df000017 	ldw	fp,0(sp)
81102c18:	dec00204 	addi	sp,sp,8
81102c1c:	f800283a 	ret

81102c20 <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102c20:	defffa04 	addi	sp,sp,-24
81102c24:	de00012e 	bgeu	sp,et,81102c2c <DMA_DISPATCHER_RESET+0xc>
81102c28:	003b68fa 	trap	3
81102c2c:	dfc00515 	stw	ra,20(sp)
81102c30:	df000415 	stw	fp,16(sp)
81102c34:	df000404 	addi	fp,sp,16
81102c38:	e13ffd15 	stw	r4,-12(fp)
81102c3c:	e17ffe15 	stw	r5,-8(fp)
81102c40:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102c44:	00800044 	movi	r2,1
81102c48:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102c4c:	e0bffd17 	ldw	r2,-12(fp)
81102c50:	10800317 	ldw	r2,12(r2)
81102c54:	10800104 	addi	r2,r2,4
81102c58:	00c00084 	movi	r3,2
81102c5c:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c60:	e0bffe17 	ldw	r2,-8(fp)
81102c64:	10800058 	cmpnei	r2,r2,1
81102c68:	10000f1e 	bne	r2,zero,81102ca8 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c6c:	00000806 	br	81102c90 <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c70:	e0bfff17 	ldw	r2,-4(fp)
81102c74:	1000031e 	bne	r2,zero,81102c84 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c78:	01000044 	movi	r4,1
81102c7c:	11399580 	call	81139958 <usleep>
81102c80:	00000306 	br	81102c90 <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c84:	e0bfff17 	ldw	r2,-4(fp)
81102c88:	1009883a 	mov	r4,r2
81102c8c:	11399580 	call	81139958 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c90:	e0bffd17 	ldw	r2,-12(fp)
81102c94:	10800317 	ldw	r2,12(r2)
81102c98:	10800037 	ldwio	r2,0(r2)
81102c9c:	1080100c 	andi	r2,r2,64
81102ca0:	103ff31e 	bne	r2,zero,81102c70 <__reset+0xfb0e2c70>
81102ca4:	00000206 	br	81102cb0 <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102ca8:	e0bffc17 	ldw	r2,-16(fp)
81102cac:	00000106 	br	81102cb4 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102cb0:	e0bffc17 	ldw	r2,-16(fp)
}
81102cb4:	e037883a 	mov	sp,fp
81102cb8:	dfc00117 	ldw	ra,4(sp)
81102cbc:	df000017 	ldw	fp,0(sp)
81102cc0:	dec00204 	addi	sp,sp,8
81102cc4:	f800283a 	ret

81102cc8 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102cc8:	defff604 	addi	sp,sp,-40
81102ccc:	de00012e 	bgeu	sp,et,81102cd4 <DMA_SINGLE_TRANSFER+0xc>
81102cd0:	003b68fa 	trap	3
81102cd4:	dfc00915 	stw	ra,36(sp)
81102cd8:	df000815 	stw	fp,32(sp)
81102cdc:	dc000715 	stw	r16,28(sp)
81102ce0:	df000804 	addi	fp,sp,32
81102ce4:	e13ffb15 	stw	r4,-20(fp)
81102ce8:	e17ffc15 	stw	r5,-16(fp)
81102cec:	e1bffd15 	stw	r6,-12(fp)
81102cf0:	e1fffe15 	stw	r7,-8(fp)
81102cf4:	defff804 	addi	sp,sp,-32
81102cf8:	d8800204 	addi	r2,sp,8
81102cfc:	108003c4 	addi	r2,r2,15
81102d00:	1004d13a 	srli	r2,r2,4
81102d04:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102d08:	00800044 	movi	r2,1
81102d0c:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102d10:	e0fffc17 	ldw	r3,-16(fp)
81102d14:	e13ffd17 	ldw	r4,-12(fp)
81102d18:	e0800217 	ldw	r2,8(fp)
81102d1c:	d8800115 	stw	r2,4(sp)
81102d20:	e0bffe17 	ldw	r2,-8(fp)
81102d24:	d8800015 	stw	r2,0(sp)
81102d28:	200f883a 	mov	r7,r4
81102d2c:	180d883a 	mov	r6,r3
81102d30:	800b883a 	mov	r5,r16
81102d34:	e13ffb17 	ldw	r4,-20(fp)
81102d38:	114a9ec0 	call	8114a9ec <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102d3c:	10000326 	beq	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102d40:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102d44:	e0bffa17 	ldw	r2,-24(fp)
81102d48:	00001e06 	br	81102dc4 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102d4c:	800b883a 	mov	r5,r16
81102d50:	e13ffb17 	ldw	r4,-20(fp)
81102d54:	114bc600 	call	8114bc60 <alt_msgdma_standard_descriptor_async_transfer>
81102d58:	10000326 	beq	r2,zero,81102d68 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d5c:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d60:	e0bffa17 	ldw	r2,-24(fp)
81102d64:	00001706 	br	81102dc4 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d68:	e0bffa17 	ldw	r2,-24(fp)
81102d6c:	10800060 	cmpeqi	r2,r2,1
81102d70:	1007883a 	mov	r3,r2
81102d74:	e0800317 	ldw	r2,12(fp)
81102d78:	10800060 	cmpeqi	r2,r2,1
81102d7c:	1884703a 	and	r2,r3,r2
81102d80:	10803fcc 	andi	r2,r2,255
81102d84:	10000e26 	beq	r2,zero,81102dc0 <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d88:	00000806 	br	81102dac <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d8c:	e0800417 	ldw	r2,16(fp)
81102d90:	1000031e 	bne	r2,zero,81102da0 <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d94:	0100fa04 	movi	r4,1000
81102d98:	11399580 	call	81139958 <usleep>
81102d9c:	00000306 	br	81102dac <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102da0:	e0800417 	ldw	r2,16(fp)
81102da4:	1009883a 	mov	r4,r2
81102da8:	11399580 	call	81139958 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102dac:	e0bffb17 	ldw	r2,-20(fp)
81102db0:	10800317 	ldw	r2,12(r2)
81102db4:	10800037 	ldwio	r2,0(r2)
81102db8:	1080004c 	andi	r2,r2,1
81102dbc:	103ff31e 	bne	r2,zero,81102d8c <__reset+0xfb0e2d8c>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102dc0:	e0bffa17 	ldw	r2,-24(fp)
}
81102dc4:	e6ffff04 	addi	sp,fp,-4
81102dc8:	dfc00217 	ldw	ra,8(sp)
81102dcc:	df000117 	ldw	fp,4(sp)
81102dd0:	dc000017 	ldw	r16,0(sp)
81102dd4:	dec00304 	addi	sp,sp,12
81102dd8:	f800283a 	ret

81102ddc <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102ddc:	defff504 	addi	sp,sp,-44
81102de0:	de00012e 	bgeu	sp,et,81102de8 <DMA_MULTIPLE_TRANSFER+0xc>
81102de4:	003b68fa 	trap	3
81102de8:	dfc00a15 	stw	ra,40(sp)
81102dec:	df000915 	stw	fp,36(sp)
81102df0:	dc000815 	stw	r16,32(sp)
81102df4:	df000904 	addi	fp,sp,36
81102df8:	e13ffb15 	stw	r4,-20(fp)
81102dfc:	e17ffc15 	stw	r5,-16(fp)
81102e00:	e1bffd15 	stw	r6,-12(fp)
81102e04:	3805883a 	mov	r2,r7
81102e08:	e0bffe05 	stb	r2,-8(fp)
81102e0c:	defff804 	addi	sp,sp,-32
81102e10:	d8800204 	addi	r2,sp,8
81102e14:	108003c4 	addi	r2,r2,15
81102e18:	1004d13a 	srli	r2,r2,4
81102e1c:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102e20:	00800044 	movi	r2,1
81102e24:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102e28:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e2c:	00002506 	br	81102ec4 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102e30:	e0bffa03 	ldbu	r2,-24(fp)
81102e34:	1085883a 	add	r2,r2,r2
81102e38:	1085883a 	add	r2,r2,r2
81102e3c:	1007883a 	mov	r3,r2
81102e40:	e0bffc17 	ldw	r2,-16(fp)
81102e44:	10c5883a 	add	r2,r2,r3
81102e48:	10800017 	ldw	r2,0(r2)
81102e4c:	1009883a 	mov	r4,r2
81102e50:	e0bffa03 	ldbu	r2,-24(fp)
81102e54:	1085883a 	add	r2,r2,r2
81102e58:	1085883a 	add	r2,r2,r2
81102e5c:	1007883a 	mov	r3,r2
81102e60:	e0bffd17 	ldw	r2,-12(fp)
81102e64:	10c5883a 	add	r2,r2,r3
81102e68:	10800017 	ldw	r2,0(r2)
81102e6c:	1007883a 	mov	r3,r2
81102e70:	e0800317 	ldw	r2,12(fp)
81102e74:	10804034 	orhi	r2,r2,256
81102e78:	d8800115 	stw	r2,4(sp)
81102e7c:	e0800217 	ldw	r2,8(fp)
81102e80:	d8800015 	stw	r2,0(sp)
81102e84:	180f883a 	mov	r7,r3
81102e88:	200d883a 	mov	r6,r4
81102e8c:	800b883a 	mov	r5,r16
81102e90:	e13ffb17 	ldw	r4,-20(fp)
81102e94:	114a9ec0 	call	8114a9ec <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e98:	10000226 	beq	r2,zero,81102ea4 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e9c:	e03ff915 	stw	zero,-28(fp)
81102ea0:	00000506 	br	81102eb8 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102ea4:	800b883a 	mov	r5,r16
81102ea8:	e13ffb17 	ldw	r4,-20(fp)
81102eac:	114bc600 	call	8114bc60 <alt_msgdma_standard_descriptor_async_transfer>
81102eb0:	10000126 	beq	r2,zero,81102eb8 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102eb4:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102eb8:	e0bffa03 	ldbu	r2,-24(fp)
81102ebc:	10800044 	addi	r2,r2,1
81102ec0:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102ec4:	e0bff917 	ldw	r2,-28(fp)
81102ec8:	10800060 	cmpeqi	r2,r2,1
81102ecc:	1009883a 	mov	r4,r2
81102ed0:	e0fffa03 	ldbu	r3,-24(fp)
81102ed4:	e0bffe03 	ldbu	r2,-8(fp)
81102ed8:	10bfffc4 	addi	r2,r2,-1
81102edc:	1884803a 	cmplt	r2,r3,r2
81102ee0:	2084703a 	and	r2,r4,r2
81102ee4:	10803fcc 	andi	r2,r2,255
81102ee8:	103fd11e 	bne	r2,zero,81102e30 <__reset+0xfb0e2e30>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102eec:	e0bff917 	ldw	r2,-28(fp)
81102ef0:	10800058 	cmpnei	r2,r2,1
81102ef4:	1000211e 	bne	r2,zero,81102f7c <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ef8:	e0bffa03 	ldbu	r2,-24(fp)
81102efc:	1085883a 	add	r2,r2,r2
81102f00:	1085883a 	add	r2,r2,r2
81102f04:	1007883a 	mov	r3,r2
81102f08:	e0bffc17 	ldw	r2,-16(fp)
81102f0c:	10c5883a 	add	r2,r2,r3
81102f10:	10800017 	ldw	r2,0(r2)
81102f14:	1009883a 	mov	r4,r2
81102f18:	e0bffa03 	ldbu	r2,-24(fp)
81102f1c:	1085883a 	add	r2,r2,r2
81102f20:	1085883a 	add	r2,r2,r2
81102f24:	1007883a 	mov	r3,r2
81102f28:	e0bffd17 	ldw	r2,-12(fp)
81102f2c:	10c5883a 	add	r2,r2,r3
81102f30:	10800017 	ldw	r2,0(r2)
81102f34:	1007883a 	mov	r3,r2
81102f38:	e0800317 	ldw	r2,12(fp)
81102f3c:	d8800115 	stw	r2,4(sp)
81102f40:	e0800217 	ldw	r2,8(fp)
81102f44:	d8800015 	stw	r2,0(sp)
81102f48:	180f883a 	mov	r7,r3
81102f4c:	200d883a 	mov	r6,r4
81102f50:	800b883a 	mov	r5,r16
81102f54:	e13ffb17 	ldw	r4,-20(fp)
81102f58:	114a9ec0 	call	8114a9ec <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f5c:	10000226 	beq	r2,zero,81102f68 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f60:	e03ff915 	stw	zero,-28(fp)
81102f64:	00000506 	br	81102f7c <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f68:	800b883a 	mov	r5,r16
81102f6c:	e13ffb17 	ldw	r4,-20(fp)
81102f70:	114bc600 	call	8114bc60 <alt_msgdma_standard_descriptor_async_transfer>
81102f74:	10000126 	beq	r2,zero,81102f7c <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f78:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f7c:	e0bff917 	ldw	r2,-28(fp)
81102f80:	10800060 	cmpeqi	r2,r2,1
81102f84:	1007883a 	mov	r3,r2
81102f88:	e0800417 	ldw	r2,16(fp)
81102f8c:	10800060 	cmpeqi	r2,r2,1
81102f90:	1884703a 	and	r2,r3,r2
81102f94:	10803fcc 	andi	r2,r2,255
81102f98:	10000e26 	beq	r2,zero,81102fd4 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f9c:	00000806 	br	81102fc0 <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102fa0:	e0800517 	ldw	r2,20(fp)
81102fa4:	1000031e 	bne	r2,zero,81102fb4 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102fa8:	0100fa04 	movi	r4,1000
81102fac:	11399580 	call	81139958 <usleep>
81102fb0:	00000306 	br	81102fc0 <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102fb4:	e0800517 	ldw	r2,20(fp)
81102fb8:	1009883a 	mov	r4,r2
81102fbc:	11399580 	call	81139958 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102fc0:	e0bffb17 	ldw	r2,-20(fp)
81102fc4:	10800317 	ldw	r2,12(r2)
81102fc8:	10800037 	ldwio	r2,0(r2)
81102fcc:	1080004c 	andi	r2,r2,1
81102fd0:	103ff31e 	bne	r2,zero,81102fa0 <__reset+0xfb0e2fa0>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102fd4:	e0bff917 	ldw	r2,-28(fp)
}
81102fd8:	e6ffff04 	addi	sp,fp,-4
81102fdc:	dfc00217 	ldw	ra,8(sp)
81102fe0:	df000117 	ldw	fp,4(sp)
81102fe4:	dc000017 	ldw	r16,0(sp)
81102fe8:	dec00304 	addi	sp,sp,12
81102fec:	f800283a 	ret

81102ff0 <POWER_Read>:

#if DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102ff0:	deffef04 	addi	sp,sp,-68
81102ff4:	de00012e 	bgeu	sp,et,81102ffc <POWER_Read+0xc>
81102ff8:	003b68fa 	trap	3
81102ffc:	dfc01015 	stw	ra,64(sp)
81103000:	df000f15 	stw	fp,60(sp)
81103004:	df000f04 	addi	fp,sp,60
81103008:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
8110300c:	00800044 	movi	r2,1
81103010:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81103014:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81103018:	00800204 	movi	r2,8
8110301c:	e0bffc15 	stw	r2,-16(fp)
81103020:	00800104 	movi	r2,4
81103024:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81103028:	00800044 	movi	r2,1
8110302c:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81103030:	00800044 	movi	r2,1
81103034:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81103038:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110303c:	e03ff515 	stw	zero,-44(fp)
81103040:	00009206 	br	8110328c <POWER_Read+0x29c>
		NextChannel = 0;
81103044:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81103048:	e0bff517 	ldw	r2,-44(fp)
8110304c:	10c03fcc 	andi	r3,r2,255
81103050:	e13ffa03 	ldbu	r4,-24(fp)
81103054:	e0bfff17 	ldw	r2,-4(fp)
81103058:	d8800115 	stw	r2,4(sp)
8110305c:	e0bff917 	ldw	r2,-28(fp)
81103060:	d8800015 	stw	r2,0(sp)
81103064:	e1fff817 	ldw	r7,-32(fp)
81103068:	e1bff717 	ldw	r6,-36(fp)
8110306c:	200b883a 	mov	r5,r4
81103070:	1809883a 	mov	r4,r3
81103074:	110c5340 	call	8110c534 <POWER_SPI_RW>
81103078:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
8110307c:	e03ff415 	stw	zero,-48(fp)
81103080:	00007406 	br	81103254 <POWER_Read+0x264>
			NextChannel = i + 1;
81103084:	e0bff417 	ldw	r2,-48(fp)
81103088:	10800044 	addi	r2,r2,1
8110308c:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
81103090:	e0bff517 	ldw	r2,-44(fp)
81103094:	10c03fcc 	andi	r3,r2,255
81103098:	e13ffa03 	ldbu	r4,-24(fp)
8110309c:	e0bffe04 	addi	r2,fp,-8
811030a0:	d8800115 	stw	r2,4(sp)
811030a4:	e0bff917 	ldw	r2,-28(fp)
811030a8:	d8800015 	stw	r2,0(sp)
811030ac:	e1fff817 	ldw	r7,-32(fp)
811030b0:	e1bff717 	ldw	r6,-36(fp)
811030b4:	200b883a 	mov	r5,r4
811030b8:	1809883a 	mov	r4,r3
811030bc:	110c5340 	call	8110c534 <POWER_SPI_RW>
811030c0:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
811030c4:	e0bff317 	ldw	r2,-52(fp)
811030c8:	10005026 	beq	r2,zero,8110320c <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
811030cc:	e0bffe17 	ldw	r2,-8(fp)
811030d0:	1004d7ba 	srli	r2,r2,30
811030d4:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
811030d8:	e0bffe17 	ldw	r2,-8(fp)
811030dc:	1004d07a 	srli	r2,r2,1
811030e0:	108001cc 	andi	r2,r2,7
811030e4:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
811030e8:	e0bffe17 	ldw	r2,-8(fp)
811030ec:	1004d13a 	srli	r2,r2,4
811030f0:	1080004c 	andi	r2,r2,1
811030f4:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030f8:	e0bffe17 	ldw	r2,-8(fp)
811030fc:	1004d17a 	srli	r2,r2,5
81103100:	1080004c 	andi	r2,r2,1
81103104:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
81103108:	e0bffe17 	ldw	r2,-8(fp)
8110310c:	1080004c 	andi	r2,r2,1
81103110:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
81103114:	e0bffa43 	ldbu	r2,-23(fp)
81103118:	10000d26 	beq	r2,zero,81103150 <POWER_Read+0x160>
#if DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
8110311c:	e1bff417 	ldw	r6,-48(fp)
81103120:	01604574 	movhi	r5,33045
81103124:	29770d04 	addi	r5,r5,-9164
81103128:	01204574 	movhi	r4,33045
8110312c:	21146d04 	addi	r4,r4,20916
81103130:	1124bb40 	call	81124bb4 <sprintf>
					debug(fp, cDebugBuffer);
81103134:	d0a06217 	ldw	r2,-32376(gp)
81103138:	01604574 	movhi	r5,33045
8110313c:	29546d04 	addi	r5,r5,20916
81103140:	1009883a 	mov	r4,r2
81103144:	11232a00 	call	811232a0 <fprintf>
#endif
					bSuccess = FALSE;
81103148:	e03ff315 	stw	zero,-52(fp)
8110314c:	00002206 	br	811031d8 <POWER_Read+0x1e8>
				} else if (Channel != i) {
81103150:	e0fffa83 	ldbu	r3,-22(fp)
81103154:	e0bff417 	ldw	r2,-48(fp)
81103158:	18801026 	beq	r3,r2,8110319c <POWER_Read+0x1ac>
#if DEBUG_ON
					sprintf(cDebugBuffer,
8110315c:	e0bffa83 	ldbu	r2,-22(fp)
81103160:	d8800015 	stw	r2,0(sp)
81103164:	e1fff417 	ldw	r7,-48(fp)
81103168:	e1bff417 	ldw	r6,-48(fp)
8110316c:	01604574 	movhi	r5,33045
81103170:	29771304 	addi	r5,r5,-9140
81103174:	01204574 	movhi	r4,33045
81103178:	21146d04 	addi	r4,r4,20916
8110317c:	1124bb40 	call	81124bb4 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
81103180:	d0a06217 	ldw	r2,-32376(gp)
81103184:	01604574 	movhi	r5,33045
81103188:	29546d04 	addi	r5,r5,20916
8110318c:	1009883a 	mov	r4,r2
81103190:	11232a00 	call	811232a0 <fprintf>
#endif
					bSuccess = FALSE;
81103194:	e03ff315 	stw	zero,-52(fp)
81103198:	00000f06 	br	811031d8 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
8110319c:	e0fffac3 	ldbu	r3,-21(fp)
811031a0:	e0bff817 	ldw	r2,-32(fp)
811031a4:	18800c26 	beq	r3,r2,811031d8 <POWER_Read+0x1e8>
#if DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
811031a8:	e1bff417 	ldw	r6,-48(fp)
811031ac:	01604574 	movhi	r5,33045
811031b0:	29771f04 	addi	r5,r5,-9092
811031b4:	01204574 	movhi	r4,33045
811031b8:	21146d04 	addi	r4,r4,20916
811031bc:	1124bb40 	call	81124bb4 <sprintf>
					debug(fp, cDebugBuffer);
811031c0:	d0a06217 	ldw	r2,-32376(gp)
811031c4:	01604574 	movhi	r5,33045
811031c8:	29546d04 	addi	r5,r5,20916
811031cc:	1009883a 	mov	r4,r2
811031d0:	11232a00 	call	811232a0 <fprintf>
#endif
					bSuccess = FALSE;
811031d4:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
811031d8:	e0bff317 	ldw	r2,-52(fp)
811031dc:	10001a26 	beq	r2,zero,81103248 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
811031e0:	e0bff617 	ldw	r2,-40(fp)
811031e4:	10c00044 	addi	r3,r2,1
811031e8:	e0fff615 	stw	r3,-40(fp)
811031ec:	1085883a 	add	r2,r2,r2
811031f0:	1085883a 	add	r2,r2,r2
811031f4:	1007883a 	mov	r3,r2
811031f8:	e0bfff17 	ldw	r2,-4(fp)
811031fc:	10c5883a 	add	r2,r2,r3
81103200:	e0fffe17 	ldw	r3,-8(fp)
81103204:	10c00015 	stw	r3,0(r2)
81103208:	00000f06 	br	81103248 <POWER_Read+0x258>
			} else {
#if DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
8110320c:	00e04574 	movhi	r3,33045
81103210:	18d46d04 	addi	r3,r3,20916
81103214:	00a04574 	movhi	r2,33045
81103218:	10b72504 	addi	r2,r2,-9068
8110321c:	1009883a 	mov	r4,r2
81103220:	00800444 	movi	r2,17
81103224:	100d883a 	mov	r6,r2
81103228:	200b883a 	mov	r5,r4
8110322c:	1809883a 	mov	r4,r3
81103230:	11243500 	call	81124350 <memcpy>
				debug(fp, cDebugBuffer);
81103234:	d0a06217 	ldw	r2,-32376(gp)
81103238:	01604574 	movhi	r5,33045
8110323c:	29546d04 	addi	r5,r5,20916
81103240:	1009883a 	mov	r4,r2
81103244:	11232a00 	call	811232a0 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103248:	e0bff417 	ldw	r2,-48(fp)
8110324c:	10800044 	addi	r2,r2,1
81103250:	e0bff415 	stw	r2,-48(fp)
81103254:	e0bff517 	ldw	r2,-44(fp)
81103258:	1085883a 	add	r2,r2,r2
8110325c:	1085883a 	add	r2,r2,r2
81103260:	e0fff304 	addi	r3,fp,-52
81103264:	1885883a 	add	r2,r3,r2
81103268:	10800904 	addi	r2,r2,36
8110326c:	10800017 	ldw	r2,0(r2)
81103270:	e0fff417 	ldw	r3,-48(fp)
81103274:	1880020e 	bge	r3,r2,81103280 <POWER_Read+0x290>
81103278:	e0bff317 	ldw	r2,-52(fp)
8110327c:	103f811e 	bne	r2,zero,81103084 <__reset+0xfb0e3084>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81103280:	e0bff517 	ldw	r2,-44(fp)
81103284:	10800044 	addi	r2,r2,1
81103288:	e0bff515 	stw	r2,-44(fp)
8110328c:	e0bff517 	ldw	r2,-44(fp)
81103290:	10800088 	cmpgei	r2,r2,2
81103294:	1000021e 	bne	r2,zero,811032a0 <POWER_Read+0x2b0>
81103298:	e0bff317 	ldw	r2,-52(fp)
8110329c:	103f691e 	bne	r2,zero,81103044 <__reset+0xfb0e3044>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
811032a0:	e0bff317 	ldw	r2,-52(fp)
}
811032a4:	e037883a 	mov	sp,fp
811032a8:	dfc00117 	ldw	ra,4(sp)
811032ac:	df000017 	ldw	fp,0(sp)
811032b0:	dec00204 	addi	sp,sp,8
811032b4:	f800283a 	ret

811032b8 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
811032b8:	defff904 	addi	sp,sp,-28
811032bc:	de00012e 	bgeu	sp,et,811032c4 <TEMP_Read+0xc>
811032c0:	003b68fa 	trap	3
811032c4:	dfc00615 	stw	ra,24(sp)
811032c8:	df000515 	stw	fp,20(sp)
811032cc:	df000504 	addi	fp,sp,20
811032d0:	e13ffe15 	stw	r4,-8(fp)
811032d4:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
811032d8:	00800c04 	movi	r2,48
811032dc:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
811032e0:	e0bffd83 	ldbu	r2,-10(fp)
811032e4:	10c03fcc 	andi	r3,r2,255
811032e8:	18c0201c 	xori	r3,r3,128
811032ec:	18ffe004 	addi	r3,r3,-128
811032f0:	e0bffdc4 	addi	r2,fp,-9
811032f4:	d8800015 	stw	r2,0(sp)
811032f8:	000f883a 	mov	r7,zero
811032fc:	180d883a 	mov	r6,r3
81103300:	01600034 	movhi	r5,32768
81103304:	29426004 	addi	r5,r5,2432
81103308:	01200034 	movhi	r4,32768
8110330c:	21026404 	addi	r4,r4,2448
81103310:	110b2680 	call	8110b268 <I2C_Read>
81103314:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
81103318:	e0bffc17 	ldw	r2,-16(fp)
8110331c:	10000226 	beq	r2,zero,81103328 <TEMP_Read+0x70>
		BoardTemp = Data;
81103320:	e0bffdc3 	ldbu	r2,-9(fp)
81103324:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
81103328:	e0bffc17 	ldw	r2,-16(fp)
8110332c:	10001226 	beq	r2,zero,81103378 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
81103330:	e0bffd83 	ldbu	r2,-10(fp)
81103334:	10c03fcc 	andi	r3,r2,255
81103338:	18c0201c 	xori	r3,r3,128
8110333c:	18ffe004 	addi	r3,r3,-128
81103340:	e0bffdc4 	addi	r2,fp,-9
81103344:	d8800015 	stw	r2,0(sp)
81103348:	01c00044 	movi	r7,1
8110334c:	180d883a 	mov	r6,r3
81103350:	01600034 	movhi	r5,32768
81103354:	29426004 	addi	r5,r5,2432
81103358:	01200034 	movhi	r4,32768
8110335c:	21026404 	addi	r4,r4,2448
81103360:	110b2680 	call	8110b268 <I2C_Read>
81103364:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103368:	e0bffc17 	ldw	r2,-16(fp)
8110336c:	10000226 	beq	r2,zero,81103378 <TEMP_Read+0xc0>
			FpgaTemp = Data;
81103370:	e0bffdc3 	ldbu	r2,-9(fp)
81103374:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103378:	e0bffc17 	ldw	r2,-16(fp)
8110337c:	10000626 	beq	r2,zero,81103398 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
81103380:	e0bffe17 	ldw	r2,-8(fp)
81103384:	e0fffd03 	ldbu	r3,-12(fp)
81103388:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
8110338c:	e0bfff17 	ldw	r2,-4(fp)
81103390:	e0fffd43 	ldbu	r3,-11(fp)
81103394:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103398:	e0bffc17 	ldw	r2,-16(fp)
}
8110339c:	e037883a 	mov	sp,fp
811033a0:	dfc00117 	ldw	ra,4(sp)
811033a4:	df000017 	ldw	fp,0(sp)
811033a8:	dec00204 	addi	sp,sp,8
811033ac:	f800283a 	ret

811033b0 <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
811033b0:	defffb04 	addi	sp,sp,-20
811033b4:	de00012e 	bgeu	sp,et,811033bc <sense_log_temp+0xc>
811033b8:	003b68fa 	trap	3
811033bc:	dfc00415 	stw	ra,16(sp)
811033c0:	df000315 	stw	fp,12(sp)
811033c4:	df000304 	addi	fp,sp,12
811033c8:	e13ffe15 	stw	r4,-8(fp)
811033cc:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
811033d0:	e17fff17 	ldw	r5,-4(fp)
811033d4:	e13ffe17 	ldw	r4,-8(fp)
811033d8:	11032b80 	call	811032b8 <TEMP_Read>
811033dc:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
811033e0:	e0bffd17 	ldw	r2,-12(fp)
}
811033e4:	e037883a 	mov	sp,fp
811033e8:	dfc00117 	ldw	ra,4(sp)
811033ec:	df000017 	ldw	fp,0(sp)
811033f0:	dec00204 	addi	sp,sp,8
811033f4:	f800283a 	ret

811033f8 <sense_log>:

void sense_log(void) {
811033f8:	deff0404 	addi	sp,sp,-1008
811033fc:	de00012e 	bgeu	sp,et,81103404 <sense_log+0xc>
81103400:	003b68fa 	trap	3
81103404:	dfc0fb15 	stw	ra,1004(sp)
81103408:	df00fa15 	stw	fp,1000(sp)
8110340c:	dd40f915 	stw	r21,996(sp)
81103410:	dd00f815 	stw	r20,992(sp)
81103414:	dcc0f715 	stw	r19,988(sp)
81103418:	dc80f615 	stw	r18,984(sp)
8110341c:	dc40f515 	stw	r17,980(sp)
81103420:	dc00f415 	stw	r16,976(sp)
81103424:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
81103428:	00902834 	movhi	r2,16544
8110342c:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2215 	stw	r2,-888(fp)
8110343c:	008ea0f4 	movhi	r2,14979
81103440:	10849bc4 	addi	r2,r2,4719
81103444:	e0bf2315 	stw	r2,-884(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2415 	stw	r2,-880(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2515 	stw	r2,-876(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2615 	stw	r2,-872(fp)
8110346c:	008ed174 	movhi	r2,15173
81103470:	10a6e984 	addi	r2,r2,-25690
81103474:	e0bf2715 	stw	r2,-868(fp)
81103478:	008ed174 	movhi	r2,15173
8110347c:	10a6e984 	addi	r2,r2,-25690
81103480:	e0bf2815 	stw	r2,-864(fp)
81103484:	008ed174 	movhi	r2,15173
81103488:	10a6e984 	addi	r2,r2,-25690
8110348c:	e0bf2915 	stw	r2,-860(fp)
81103490:	008ed174 	movhi	r2,15173
81103494:	10a6e984 	addi	r2,r2,-25690
81103498:	e0bf2a15 	stw	r2,-856(fp)
8110349c:	008ed174 	movhi	r2,15173
811034a0:	10a6e984 	addi	r2,r2,-25690
811034a4:	e0bf2b15 	stw	r2,-852(fp)
811034a8:	008ed174 	movhi	r2,15173
811034ac:	10a6e984 	addi	r2,r2,-25690
811034b0:	e0bf2c15 	stw	r2,-848(fp)
811034b4:	008ed174 	movhi	r2,15173
811034b8:	10a6e984 	addi	r2,r2,-25690
811034bc:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
811034c0:	008fd9b4 	movhi	r2,16230
811034c4:	10999984 	addi	r2,r2,26214
811034c8:	e0bf2e15 	stw	r2,-840(fp)
811034cc:	008fd9b4 	movhi	r2,16230
811034d0:	10999984 	addi	r2,r2,26214
811034d4:	e0bf2f15 	stw	r2,-836(fp)
811034d8:	00901034 	movhi	r2,16448
811034dc:	e0bf3015 	stw	r2,-832(fp)
811034e0:	008fd9b4 	movhi	r2,16230
811034e4:	10999984 	addi	r2,r2,26214
811034e8:	e0bf3115 	stw	r2,-828(fp)
811034ec:	008ff9b4 	movhi	r2,16358
811034f0:	10999984 	addi	r2,r2,26214
811034f4:	e0bf3215 	stw	r2,-824(fp)
811034f8:	00900834 	movhi	r2,16416
811034fc:	e0bf3315 	stw	r2,-820(fp)
81103500:	008ff9b4 	movhi	r2,16358
81103504:	10999984 	addi	r2,r2,26214
81103508:	e0bf3415 	stw	r2,-816(fp)
8110350c:	00900834 	movhi	r2,16416
81103510:	e0bf3515 	stw	r2,-812(fp)
81103514:	008fe374 	movhi	r2,16269
81103518:	10b33344 	addi	r2,r2,-13107
8110351c:	e0bf3615 	stw	r2,-808(fp)
81103520:	008fecf4 	movhi	r2,16307
81103524:	108cccc4 	addi	r2,r2,13107
81103528:	e0bf3715 	stw	r2,-804(fp)
8110352c:	009014f4 	movhi	r2,16467
81103530:	108cccc4 	addi	r2,r2,13107
81103534:	e0bf3815 	stw	r2,-800(fp)
81103538:	00900834 	movhi	r2,16416
8110353c:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
81103540:	00a04574 	movhi	r2,33045
81103544:	10b75c04 	addi	r2,r2,-8848
81103548:	e0ff3a04 	addi	r3,fp,-792
8110354c:	1009883a 	mov	r4,r2
81103550:	0080c004 	movi	r2,768
81103554:	100d883a 	mov	r6,r2
81103558:	200b883a 	mov	r5,r4
8110355c:	1809883a 	mov	r4,r3
81103560:	11243500 	call	81124350 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103564:	e0bf1604 	addi	r2,fp,-936
81103568:	1009883a 	mov	r4,r2
8110356c:	1102ff00 	call	81102ff0 <POWER_Read>
81103570:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103574:	e0bf0f17 	ldw	r2,-964(fp)
81103578:	10016026 	beq	r2,zero,81103afc <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
8110357c:	e03f0c15 	stw	zero,-976(fp)
81103580:	00014c06 	br	81103ab4 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103584:	e0bf0c17 	ldw	r2,-976(fp)
81103588:	1085883a 	add	r2,r2,r2
8110358c:	1085883a 	add	r2,r2,r2
81103590:	e0ff0c04 	addi	r3,fp,-976
81103594:	1885883a 	add	r2,r3,r2
81103598:	10800a04 	addi	r2,r2,40
8110359c:	10800017 	ldw	r2,0(r2)
811035a0:	1004d77a 	srli	r2,r2,29
811035a4:	1080004c 	andi	r2,r2,1
811035a8:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
811035ac:	e0bf0c17 	ldw	r2,-976(fp)
811035b0:	1085883a 	add	r2,r2,r2
811035b4:	1085883a 	add	r2,r2,r2
811035b8:	e0ff0c04 	addi	r3,fp,-976
811035bc:	1885883a 	add	r2,r3,r2
811035c0:	10800a04 	addi	r2,r2,40
811035c4:	10800017 	ldw	r2,0(r2)
811035c8:	1004d73a 	srli	r2,r2,28
811035cc:	1080004c 	andi	r2,r2,1
811035d0:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
811035d4:	e0bf0c17 	ldw	r2,-976(fp)
811035d8:	1085883a 	add	r2,r2,r2
811035dc:	1085883a 	add	r2,r2,r2
811035e0:	e0ff0c04 	addi	r3,fp,-976
811035e4:	1885883a 	add	r2,r3,r2
811035e8:	10800a04 	addi	r2,r2,40
811035ec:	10800017 	ldw	r2,0(r2)
811035f0:	1006d1ba 	srli	r3,r2,6
811035f4:	00801034 	movhi	r2,64
811035f8:	10bfffc4 	addi	r2,r2,-1
811035fc:	1884703a 	and	r2,r3,r2
81103600:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
81103604:	e0bf1117 	ldw	r2,-956(fp)
81103608:	1000091e 	bne	r2,zero,81103630 <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
8110360c:	e13f1217 	ldw	r4,-952(fp)
81103610:	1121aac0 	call	81121aac <__floatunsisf>
81103614:	1007883a 	mov	r3,r2
81103618:	0152a034 	movhi	r5,19072
8110361c:	1809883a 	mov	r4,r3
81103620:	11211340 	call	81121134 <__divsf3>
81103624:	1007883a 	mov	r3,r2
81103628:	e0ff0d15 	stw	r3,-972(fp)
8110362c:	00000106 	br	81103634 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
81103630:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
81103634:	e0bf1017 	ldw	r2,-960(fp)
81103638:	10002626 	beq	r2,zero,811036d4 <sense_log+0x2dc>
8110363c:	e0bf1117 	ldw	r2,-956(fp)
81103640:	10002426 	beq	r2,zero,811036d4 <sense_log+0x2dc>
				fVol = fRef * 0.5;
81103644:	014fc034 	movhi	r5,16128
81103648:	e13f0e17 	ldw	r4,-968(fp)
8110364c:	112157c0 	call	8112157c <__mulsf3>
81103650:	1007883a 	mov	r3,r2
81103654:	e0ff1315 	stw	r3,-948(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103658:	e0ff3a04 	addi	r3,fp,-792
8110365c:	e0bf0c17 	ldw	r2,-976(fp)
81103660:	100491ba 	slli	r2,r2,6
81103664:	18a1883a 	add	r16,r3,r2
81103668:	e0bf0c17 	ldw	r2,-976(fp)
8110366c:	1085883a 	add	r2,r2,r2
81103670:	1085883a 	add	r2,r2,r2
81103674:	e0ff0c04 	addi	r3,fp,-976
81103678:	1885883a 	add	r2,r3,r2
8110367c:	10800a04 	addi	r2,r2,40
81103680:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103684:	1023883a 	mov	r17,r2
81103688:	e13f1317 	ldw	r4,-948(fp)
8110368c:	1122e080 	call	81122e08 <__extendsfdf2>
81103690:	1009883a 	mov	r4,r2
81103694:	180b883a 	mov	r5,r3
81103698:	d9000015 	stw	r4,0(sp)
8110369c:	d9400115 	stw	r5,4(sp)
811036a0:	880f883a 	mov	r7,r17
811036a4:	800d883a 	mov	r6,r16
811036a8:	01604574 	movhi	r5,33045
811036ac:	29772a04 	addi	r5,r5,-9048
811036b0:	01204574 	movhi	r4,33045
811036b4:	21146d04 	addi	r4,r4,20916
811036b8:	1124bb40 	call	81124bb4 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
811036bc:	d0a06217 	ldw	r2,-32376(gp)
811036c0:	01604574 	movhi	r5,33045
811036c4:	29546d04 	addi	r5,r5,20916
811036c8:	1009883a 	mov	r4,r2
811036cc:	11232a00 	call	811232a0 <fprintf>
811036d0:	0000f506 	br	81103aa8 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
811036d4:	e0bf1017 	ldw	r2,-960(fp)
811036d8:	10006426 	beq	r2,zero,8110386c <sense_log+0x474>
811036dc:	e0bf1117 	ldw	r2,-956(fp)
811036e0:	1000621e 	bne	r2,zero,8110386c <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
811036e4:	e13f0e17 	ldw	r4,-968(fp)
811036e8:	1122e080 	call	81122e08 <__extendsfdf2>
811036ec:	1011883a 	mov	r8,r2
811036f0:	1813883a 	mov	r9,r3
811036f4:	000d883a 	mov	r6,zero
811036f8:	01cff834 	movhi	r7,16352
811036fc:	4009883a 	mov	r4,r8
81103700:	480b883a 	mov	r5,r9
81103704:	1121c800 	call	81121c80 <__muldf3>
81103708:	1009883a 	mov	r4,r2
8110370c:	180b883a 	mov	r5,r3
81103710:	2021883a 	mov	r16,r4
81103714:	2823883a 	mov	r17,r5
81103718:	e13f0d17 	ldw	r4,-972(fp)
8110371c:	1122e080 	call	81122e08 <__extendsfdf2>
81103720:	1009883a 	mov	r4,r2
81103724:	180b883a 	mov	r5,r3
81103728:	200d883a 	mov	r6,r4
8110372c:	280f883a 	mov	r7,r5
81103730:	8009883a 	mov	r4,r16
81103734:	880b883a 	mov	r5,r17
81103738:	1121c800 	call	81121c80 <__muldf3>
8110373c:	1009883a 	mov	r4,r2
81103740:	180b883a 	mov	r5,r3
81103744:	2005883a 	mov	r2,r4
81103748:	2807883a 	mov	r3,r5
8110374c:	1009883a 	mov	r4,r2
81103750:	180b883a 	mov	r5,r3
81103754:	1122f200 	call	81122f20 <__truncdfsf2>
81103758:	1007883a 	mov	r3,r2
8110375c:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
81103760:	e0bf0c17 	ldw	r2,-976(fp)
81103764:	1085883a 	add	r2,r2,r2
81103768:	1085883a 	add	r2,r2,r2
8110376c:	e0ff0c04 	addi	r3,fp,-976
81103770:	1885883a 	add	r2,r3,r2
81103774:	10801604 	addi	r2,r2,88
81103778:	10c00017 	ldw	r3,0(r2)
8110377c:	180b883a 	mov	r5,r3
81103780:	e13f0d17 	ldw	r4,-972(fp)
81103784:	11211340 	call	81121134 <__divsf3>
81103788:	1007883a 	mov	r3,r2
8110378c:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
81103790:	e0bf0c17 	ldw	r2,-976(fp)
81103794:	1085883a 	add	r2,r2,r2
81103798:	1085883a 	add	r2,r2,r2
8110379c:	e0ff0c04 	addi	r3,fp,-976
811037a0:	1885883a 	add	r2,r3,r2
811037a4:	10802204 	addi	r2,r2,136
811037a8:	10c00017 	ldw	r3,0(r2)
811037ac:	e17f1417 	ldw	r5,-944(fp)
811037b0:	1809883a 	mov	r4,r3
811037b4:	112157c0 	call	8112157c <__mulsf3>
811037b8:	1007883a 	mov	r3,r2
811037bc:	e0ff1515 	stw	r3,-940(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
811037c0:	e0ff3a04 	addi	r3,fp,-792
811037c4:	e0bf0c17 	ldw	r2,-976(fp)
811037c8:	100491ba 	slli	r2,r2,6
811037cc:	18a9883a 	add	r20,r3,r2
811037d0:	e0bf0c17 	ldw	r2,-976(fp)
811037d4:	1085883a 	add	r2,r2,r2
811037d8:	1085883a 	add	r2,r2,r2
811037dc:	e0ff0c04 	addi	r3,fp,-976
811037e0:	1885883a 	add	r2,r3,r2
811037e4:	10800a04 	addi	r2,r2,40
811037e8:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#if DEBUG_ON
				sprintf(cDebugBuffer,
811037ec:	102b883a 	mov	r21,r2
811037f0:	e13f0d17 	ldw	r4,-972(fp)
811037f4:	1122e080 	call	81122e08 <__extendsfdf2>
811037f8:	1021883a 	mov	r16,r2
811037fc:	1823883a 	mov	r17,r3
81103800:	e13f1417 	ldw	r4,-944(fp)
81103804:	1122e080 	call	81122e08 <__extendsfdf2>
81103808:	1025883a 	mov	r18,r2
8110380c:	1827883a 	mov	r19,r3
81103810:	e13f1517 	ldw	r4,-940(fp)
81103814:	1122e080 	call	81122e08 <__extendsfdf2>
81103818:	1009883a 	mov	r4,r2
8110381c:	180b883a 	mov	r5,r3
81103820:	d9000415 	stw	r4,16(sp)
81103824:	d9400515 	stw	r5,20(sp)
81103828:	dc800215 	stw	r18,8(sp)
8110382c:	dcc00315 	stw	r19,12(sp)
81103830:	dc000015 	stw	r16,0(sp)
81103834:	dc400115 	stw	r17,4(sp)
81103838:	a80f883a 	mov	r7,r21
8110383c:	a00d883a 	mov	r6,r20
81103840:	01604574 	movhi	r5,33045
81103844:	29773304 	addi	r5,r5,-9012
81103848:	01204574 	movhi	r4,33045
8110384c:	21146d04 	addi	r4,r4,20916
81103850:	1124bb40 	call	81124bb4 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103854:	d0a06217 	ldw	r2,-32376(gp)
81103858:	01604574 	movhi	r5,33045
8110385c:	29546d04 	addi	r5,r5,20916
81103860:	1009883a 	mov	r4,r2
81103864:	11232a00 	call	811232a0 <fprintf>
81103868:	00008f06 	br	81103aa8 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
8110386c:	e0bf1017 	ldw	r2,-960(fp)
81103870:	1000641e 	bne	r2,zero,81103a04 <sense_log+0x60c>
81103874:	e0bf1117 	ldw	r2,-956(fp)
81103878:	10006226 	beq	r2,zero,81103a04 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
8110387c:	e13f0e17 	ldw	r4,-968(fp)
81103880:	1122e080 	call	81122e08 <__extendsfdf2>
81103884:	1011883a 	mov	r8,r2
81103888:	1813883a 	mov	r9,r3
8110388c:	000d883a 	mov	r6,zero
81103890:	01cff834 	movhi	r7,16352
81103894:	4009883a 	mov	r4,r8
81103898:	480b883a 	mov	r5,r9
8110389c:	1121c800 	call	81121c80 <__muldf3>
811038a0:	1009883a 	mov	r4,r2
811038a4:	180b883a 	mov	r5,r3
811038a8:	2021883a 	mov	r16,r4
811038ac:	2823883a 	mov	r17,r5
811038b0:	e13f0d17 	ldw	r4,-972(fp)
811038b4:	1122e080 	call	81122e08 <__extendsfdf2>
811038b8:	1009883a 	mov	r4,r2
811038bc:	180b883a 	mov	r5,r3
811038c0:	200d883a 	mov	r6,r4
811038c4:	280f883a 	mov	r7,r5
811038c8:	8009883a 	mov	r4,r16
811038cc:	880b883a 	mov	r5,r17
811038d0:	1121c800 	call	81121c80 <__muldf3>
811038d4:	1009883a 	mov	r4,r2
811038d8:	180b883a 	mov	r5,r3
811038dc:	2005883a 	mov	r2,r4
811038e0:	2807883a 	mov	r3,r5
811038e4:	1009883a 	mov	r4,r2
811038e8:	180b883a 	mov	r5,r3
811038ec:	1122f200 	call	81122f20 <__truncdfsf2>
811038f0:	1007883a 	mov	r3,r2
811038f4:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038f8:	e0bf0c17 	ldw	r2,-976(fp)
811038fc:	1085883a 	add	r2,r2,r2
81103900:	1085883a 	add	r2,r2,r2
81103904:	e0ff0c04 	addi	r3,fp,-976
81103908:	1885883a 	add	r2,r3,r2
8110390c:	10801604 	addi	r2,r2,88
81103910:	10c00017 	ldw	r3,0(r2)
81103914:	180b883a 	mov	r5,r3
81103918:	e13f0d17 	ldw	r4,-972(fp)
8110391c:	11211340 	call	81121134 <__divsf3>
81103920:	1007883a 	mov	r3,r2
81103924:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
81103928:	e0bf0c17 	ldw	r2,-976(fp)
8110392c:	1085883a 	add	r2,r2,r2
81103930:	1085883a 	add	r2,r2,r2
81103934:	e0ff0c04 	addi	r3,fp,-976
81103938:	1885883a 	add	r2,r3,r2
8110393c:	10802204 	addi	r2,r2,136
81103940:	10c00017 	ldw	r3,0(r2)
81103944:	e17f1417 	ldw	r5,-944(fp)
81103948:	1809883a 	mov	r4,r3
8110394c:	112157c0 	call	8112157c <__mulsf3>
81103950:	1007883a 	mov	r3,r2
81103954:	e0ff1515 	stw	r3,-940(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103958:	e0ff3a04 	addi	r3,fp,-792
8110395c:	e0bf0c17 	ldw	r2,-976(fp)
81103960:	100491ba 	slli	r2,r2,6
81103964:	18a9883a 	add	r20,r3,r2
81103968:	e0bf0c17 	ldw	r2,-976(fp)
8110396c:	1085883a 	add	r2,r2,r2
81103970:	1085883a 	add	r2,r2,r2
81103974:	e0ff0c04 	addi	r3,fp,-976
81103978:	1885883a 	add	r2,r3,r2
8110397c:	10800a04 	addi	r2,r2,40
81103980:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#if DEBUG_ON
				sprintf(cDebugBuffer,
81103984:	102b883a 	mov	r21,r2
81103988:	e13f0d17 	ldw	r4,-972(fp)
8110398c:	1122e080 	call	81122e08 <__extendsfdf2>
81103990:	1021883a 	mov	r16,r2
81103994:	1823883a 	mov	r17,r3
81103998:	e13f1417 	ldw	r4,-944(fp)
8110399c:	1122e080 	call	81122e08 <__extendsfdf2>
811039a0:	1025883a 	mov	r18,r2
811039a4:	1827883a 	mov	r19,r3
811039a8:	e13f1517 	ldw	r4,-940(fp)
811039ac:	1122e080 	call	81122e08 <__extendsfdf2>
811039b0:	1009883a 	mov	r4,r2
811039b4:	180b883a 	mov	r5,r3
811039b8:	d9000415 	stw	r4,16(sp)
811039bc:	d9400515 	stw	r5,20(sp)
811039c0:	dc800215 	stw	r18,8(sp)
811039c4:	dcc00315 	stw	r19,12(sp)
811039c8:	dc000015 	stw	r16,0(sp)
811039cc:	dc400115 	stw	r17,4(sp)
811039d0:	a80f883a 	mov	r7,r21
811039d4:	a00d883a 	mov	r6,r20
811039d8:	01604574 	movhi	r5,33045
811039dc:	29774304 	addi	r5,r5,-8948
811039e0:	01204574 	movhi	r4,33045
811039e4:	21146d04 	addi	r4,r4,20916
811039e8:	1124bb40 	call	81124bb4 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
811039ec:	d0a06217 	ldw	r2,-32376(gp)
811039f0:	01604574 	movhi	r5,33045
811039f4:	29546d04 	addi	r5,r5,20916
811039f8:	1009883a 	mov	r4,r2
811039fc:	11232a00 	call	811232a0 <fprintf>
81103a00:	00002906 	br	81103aa8 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
81103a04:	e0bf1017 	ldw	r2,-960(fp)
81103a08:	1000271e 	bne	r2,zero,81103aa8 <sense_log+0x6b0>
81103a0c:	e0bf1117 	ldw	r2,-956(fp)
81103a10:	1000251e 	bne	r2,zero,81103aa8 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
81103a14:	e0bf0e17 	ldw	r2,-968(fp)
81103a18:	10a0003c 	xorhi	r2,r2,32768
81103a1c:	014fc034 	movhi	r5,16128
81103a20:	1009883a 	mov	r4,r2
81103a24:	112157c0 	call	8112157c <__mulsf3>
81103a28:	1007883a 	mov	r3,r2
81103a2c:	e0ff1315 	stw	r3,-948(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103a30:	e0ff3a04 	addi	r3,fp,-792
81103a34:	e0bf0c17 	ldw	r2,-976(fp)
81103a38:	100491ba 	slli	r2,r2,6
81103a3c:	18a1883a 	add	r16,r3,r2
81103a40:	e0bf0c17 	ldw	r2,-976(fp)
81103a44:	1085883a 	add	r2,r2,r2
81103a48:	1085883a 	add	r2,r2,r2
81103a4c:	e0ff0c04 	addi	r3,fp,-976
81103a50:	1885883a 	add	r2,r3,r2
81103a54:	10800a04 	addi	r2,r2,40
81103a58:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a5c:	1023883a 	mov	r17,r2
81103a60:	e13f1317 	ldw	r4,-948(fp)
81103a64:	1122e080 	call	81122e08 <__extendsfdf2>
81103a68:	1009883a 	mov	r4,r2
81103a6c:	180b883a 	mov	r5,r3
81103a70:	d9000015 	stw	r4,0(sp)
81103a74:	d9400115 	stw	r5,4(sp)
81103a78:	880f883a 	mov	r7,r17
81103a7c:	800d883a 	mov	r6,r16
81103a80:	01604574 	movhi	r5,33045
81103a84:	29775304 	addi	r5,r5,-8884
81103a88:	01204574 	movhi	r4,33045
81103a8c:	21146d04 	addi	r4,r4,20916
81103a90:	1124bb40 	call	81124bb4 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a94:	d0a06217 	ldw	r2,-32376(gp)
81103a98:	01604574 	movhi	r5,33045
81103a9c:	29546d04 	addi	r5,r5,20916
81103aa0:	1009883a 	mov	r4,r2
81103aa4:	11232a00 	call	811232a0 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103aa8:	e0bf0c17 	ldw	r2,-976(fp)
81103aac:	10800044 	addi	r2,r2,1
81103ab0:	e0bf0c15 	stw	r2,-976(fp)
81103ab4:	e0bf0c17 	ldw	r2,-976(fp)
81103ab8:	10800308 	cmpgei	r2,r2,12
81103abc:	1000021e 	bne	r2,zero,81103ac8 <sense_log+0x6d0>
81103ac0:	e0bf0f17 	ldw	r2,-964(fp)
81103ac4:	103eaf1e 	bne	r2,zero,81103584 <__reset+0xfb0e3584>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#if DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103ac8:	00a04574 	movhi	r2,33045
81103acc:	10946d04 	addi	r2,r2,20916
81103ad0:	00c00344 	movi	r3,13
81103ad4:	10c00005 	stb	r3,0(r2)
81103ad8:	00c00284 	movi	r3,10
81103adc:	10c00045 	stb	r3,1(r2)
81103ae0:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103ae4:	d0a06217 	ldw	r2,-32376(gp)
81103ae8:	01604574 	movhi	r5,33045
81103aec:	29546d04 	addi	r5,r5,20916
81103af0:	1009883a 	mov	r4,r2
81103af4:	11232a00 	call	811232a0 <fprintf>
#if DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103af8:	00001606 	br	81103b54 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103afc:	00a04574 	movhi	r2,33045
81103b00:	10946d04 	addi	r2,r2,20916
81103b04:	00c01144 	movi	r3,69
81103b08:	10c00005 	stb	r3,0(r2)
81103b0c:	00c01c84 	movi	r3,114
81103b10:	10c00045 	stb	r3,1(r2)
81103b14:	00c01c84 	movi	r3,114
81103b18:	10c00085 	stb	r3,2(r2)
81103b1c:	00c01bc4 	movi	r3,111
81103b20:	10c000c5 	stb	r3,3(r2)
81103b24:	00c01c84 	movi	r3,114
81103b28:	10c00105 	stb	r3,4(r2)
81103b2c:	00c00344 	movi	r3,13
81103b30:	10c00145 	stb	r3,5(r2)
81103b34:	00c00284 	movi	r3,10
81103b38:	10c00185 	stb	r3,6(r2)
81103b3c:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103b40:	d0a06217 	ldw	r2,-32376(gp)
81103b44:	01604574 	movhi	r5,33045
81103b48:	29546d04 	addi	r5,r5,20916
81103b4c:	1009883a 	mov	r4,r2
81103b50:	11232a00 	call	811232a0 <fprintf>
#endif
	}
}
81103b54:	0001883a 	nop
81103b58:	e6fffa04 	addi	sp,fp,-24
81103b5c:	dfc00717 	ldw	ra,28(sp)
81103b60:	df000617 	ldw	fp,24(sp)
81103b64:	dd400517 	ldw	r21,20(sp)
81103b68:	dd000417 	ldw	r20,16(sp)
81103b6c:	dcc00317 	ldw	r19,12(sp)
81103b70:	dc800217 	ldw	r18,8(sp)
81103b74:	dc400117 	ldw	r17,4(sp)
81103b78:	dc000017 	ldw	r16,0(sp)
81103b7c:	dec00804 	addi	sp,sp,32
81103b80:	f800283a 	ret

81103b84 <bSdmaInitM1Dma>:
alt_msgdma_dev *pxDmaM1Dev = NULL;
alt_msgdma_dev *pxDmaM2Dev = NULL;
//! [data memory public global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b84:	defffb04 	addi	sp,sp,-20
81103b88:	de00012e 	bgeu	sp,et,81103b90 <bSdmaInitM1Dma+0xc>
81103b8c:	003b68fa 	trap	3
81103b90:	dfc00415 	stw	ra,16(sp)
81103b94:	df000315 	stw	fp,12(sp)
81103b98:	df000304 	addi	fp,sp,12
	bool bStatus = FALSE;
81103b9c:	e03ffd15 	stw	zero,-12(fp)
	bool bFailDispatcher = FALSE;
81103ba0:	e03ffe15 	stw	zero,-8(fp)
	alt_u16 usiCounter = 0;
81103ba4:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103ba8:	01204574 	movhi	r4,33045
81103bac:	21381c04 	addi	r4,r4,-8080
81103bb0:	114b9f00 	call	8114b9f0 <alt_msgdma_open>
81103bb4:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev != NULL) {
81103bb8:	d0a03917 	ldw	r2,-32540(gp)
81103bbc:	10001a26 	beq	r2,zero,81103c28 <bSdmaInitM1Dma+0xa4>
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81103bc0:	d0a03917 	ldw	r2,-32540(gp)
81103bc4:	10800317 	ldw	r2,12(r2)
81103bc8:	10800104 	addi	r2,r2,4
81103bcc:	00c00084 	movi	r3,2
81103bd0:	10c00035 	stwio	r3,0(r2)
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bd4:	00000b06 	br	81103c04 <bSdmaInitM1Dma+0x80>
			usleep(1);
81103bd8:	01000044 	movi	r4,1
81103bdc:	11399580 	call	81139958 <usleep>
			usiCounter++;
81103be0:	e0bfff0b 	ldhu	r2,-4(fp)
81103be4:	10800044 	addi	r2,r2,1
81103be8:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103bec:	e0bfff0b 	ldhu	r2,-4(fp)
81103bf0:	1084e230 	cmpltui	r2,r2,5000
81103bf4:	1000031e 	bne	r2,zero,81103c04 <bSdmaInitM1Dma+0x80>
				bFailDispatcher = TRUE;
81103bf8:	00800044 	movi	r2,1
81103bfc:	e0bffe15 	stw	r2,-8(fp)
				break;
81103c00:	00000506 	br	81103c18 <bSdmaInitM1Dma+0x94>
	// check if the device was opened
	if (pxDmaM1Dev != NULL) {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c04:	d0a03917 	ldw	r2,-32540(gp)
81103c08:	10800317 	ldw	r2,12(r2)
81103c0c:	10800037 	ldwio	r2,0(r2)
81103c10:	1080100c 	andi	r2,r2,64
81103c14:	103ff01e 	bne	r2,zero,81103bd8 <__reset+0xfb0e3bd8>
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
				bFailDispatcher = TRUE;
				break;
			}
		}
		if (bFailDispatcher == FALSE)
81103c18:	e0bffe17 	ldw	r2,-8(fp)
81103c1c:	1000021e 	bne	r2,zero,81103c28 <bSdmaInitM1Dma+0xa4>
			bStatus = TRUE;
81103c20:	00800044 	movi	r2,1
81103c24:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81103c28:	e0bffd17 	ldw	r2,-12(fp)
}
81103c2c:	e037883a 	mov	sp,fp
81103c30:	dfc00117 	ldw	ra,4(sp)
81103c34:	df000017 	ldw	fp,0(sp)
81103c38:	dec00204 	addi	sp,sp,8
81103c3c:	f800283a 	ret

81103c40 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103c40:	defffb04 	addi	sp,sp,-20
81103c44:	de00012e 	bgeu	sp,et,81103c4c <bSdmaInitM2Dma+0xc>
81103c48:	003b68fa 	trap	3
81103c4c:	dfc00415 	stw	ra,16(sp)
81103c50:	df000315 	stw	fp,12(sp)
81103c54:	df000304 	addi	fp,sp,12
	bool bStatus = FALSE;
81103c58:	e03ffd15 	stw	zero,-12(fp)
	bool bFailDispatcher = FALSE;
81103c5c:	e03ffe15 	stw	zero,-8(fp)
	alt_u16 usiCounter = 0;
81103c60:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c64:	01204574 	movhi	r4,33045
81103c68:	21382104 	addi	r4,r4,-8060
81103c6c:	114b9f00 	call	8114b9f0 <alt_msgdma_open>
81103c70:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c74:	d0a03a17 	ldw	r2,-32536(gp)
81103c78:	1000021e 	bne	r2,zero,81103c84 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c7c:	e03ffd15 	stw	zero,-12(fp)
81103c80:	00001a06 	br	81103cec <bSdmaInitM2Dma+0xac>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81103c84:	d0a03a17 	ldw	r2,-32536(gp)
81103c88:	10800317 	ldw	r2,12(r2)
81103c8c:	10800104 	addi	r2,r2,4
81103c90:	00c00084 	movi	r3,2
81103c94:	10c00035 	stwio	r3,0(r2)
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c98:	00000b06 	br	81103cc8 <bSdmaInitM2Dma+0x88>
			usleep(1);
81103c9c:	01000044 	movi	r4,1
81103ca0:	11399580 	call	81139958 <usleep>
			usiCounter++;
81103ca4:	e0bfff0b 	ldhu	r2,-4(fp)
81103ca8:	10800044 	addi	r2,r2,1
81103cac:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103cb0:	e0bfff0b 	ldhu	r2,-4(fp)
81103cb4:	1084e230 	cmpltui	r2,r2,5000
81103cb8:	1000031e 	bne	r2,zero,81103cc8 <bSdmaInitM2Dma+0x88>
				bFailDispatcher = TRUE;
81103cbc:	00800044 	movi	r2,1
81103cc0:	e0bffe15 	stw	r2,-8(fp)
				break;
81103cc4:	00000506 	br	81103cdc <bSdmaInitM2Dma+0x9c>
		bStatus = FALSE;
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103cc8:	d0a03a17 	ldw	r2,-32536(gp)
81103ccc:	10800317 	ldw	r2,12(r2)
81103cd0:	10800037 	ldwio	r2,0(r2)
81103cd4:	1080100c 	andi	r2,r2,64
81103cd8:	103ff01e 	bne	r2,zero,81103c9c <__reset+0xfb0e3c9c>
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
				bFailDispatcher = TRUE;
				break;
			}
		}
		if (bFailDispatcher == FALSE)
81103cdc:	e0bffe17 	ldw	r2,-8(fp)
81103ce0:	1000021e 	bne	r2,zero,81103cec <bSdmaInitM2Dma+0xac>
			bStatus = TRUE;
81103ce4:	00800044 	movi	r2,1
81103ce8:	e0bffd15 	stw	r2,-12(fp)
	}
	return bStatus;
81103cec:	e0bffd17 	ldw	r2,-12(fp)
}
81103cf0:	e037883a 	mov	sp,fp
81103cf4:	dfc00117 	ldw	ra,4(sp)
81103cf8:	df000017 	ldw	fp,0(sp)
81103cfc:	dec00204 	addi	sp,sp,8
81103d00:	f800283a 	ret

81103d04 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
81103d04:	deffe804 	addi	sp,sp,-96
81103d08:	de00012e 	bgeu	sp,et,81103d10 <bSdmaDmaM1Transfer+0xc>
81103d0c:	003b68fa 	trap	3
81103d10:	dfc01715 	stw	ra,92(sp)
81103d14:	df001615 	stw	fp,88(sp)
81103d18:	dc001515 	stw	r16,84(sp)
81103d1c:	df001604 	addi	fp,sp,88
81103d20:	e13ffb15 	stw	r4,-20(fp)
81103d24:	2809883a 	mov	r4,r5
81103d28:	3007883a 	mov	r3,r6
81103d2c:	3805883a 	mov	r2,r7
81103d30:	e13ffc0d 	sth	r4,-16(fp)
81103d34:	e0fffd05 	stb	r3,-12(fp)
81103d38:	e0bffe05 	stb	r2,-8(fp)
81103d3c:	defff004 	addi	sp,sp,-64
81103d40:	d8800904 	addi	r2,sp,36
81103d44:	108007c4 	addi	r2,r2,31
81103d48:	1004d17a 	srli	r2,r2,5
81103d4c:	1020917a 	slli	r16,r2,5
	bool bStatus;

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103d50:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
81103d54:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
81103d58:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103d5c:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103d60:	e03ffa15 	stw	zero,-24(fp)
	bool bBufferEmptyFlag;
	bool bChannelFlag;

	/* Assuming that the channel selected exist, change to FALSE if doesn't */
	bChannelFlag = TRUE;
81103d64:	00800044 	movi	r2,1
81103d68:	e0bff715 	stw	r2,-36(fp)
	bStatus = FALSE;
81103d6c:	e03ff315 	stw	zero,-52(fp)
	bBufferEmptyFlag = FALSE;
81103d70:	e03ff615 	stw	zero,-40(fp)
	switch (ucChBufferId) {
81103d74:	e0bffe03 	ldbu	r2,-8(fp)
81103d78:	10c00228 	cmpgeui	r3,r2,8
81103d7c:	1800b81e 	bne	r3,zero,81104060 <bSdmaDmaM1Transfer+0x35c>
81103d80:	100690ba 	slli	r3,r2,2
81103d84:	00a04434 	movhi	r2,33040
81103d88:	108f6604 	addi	r2,r2,15768
81103d8c:	1885883a 	add	r2,r3,r2
81103d90:	10800017 	ldw	r2,0(r2)
81103d94:	1000683a 	jmp	r2
81103d98:	81103db8 	rdprs	r4,r16,16630
81103d9c:	81103e0c 	andi	r4,r16,16632
81103da0:	81103e68 	cmpgeui	r4,r16,16633
81103da4:	81103ebc 	xorhi	r4,r16,16634
81103da8:	81103f10 	cmplti	r4,r16,16636
81103dac:	81103f64 	muli	r4,r16,16637
81103db0:	81103fb8 	rdprs	r4,r16,16638
81103db4:	8110400c 	andi	r4,r16,16640
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103db8:	e0bffd03 	ldbu	r2,-12(fp)
81103dbc:	10000826 	beq	r2,zero,81103de0 <bSdmaDmaM1Transfer+0xdc>
81103dc0:	10800060 	cmpeqi	r2,r2,1
81103dc4:	10000d26 	beq	r2,zero,81103dfc <bSdmaDmaM1Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103dc8:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103dcc:	00800044 	movi	r2,1
81103dd0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
81103dd4:	11067900 	call	81106790 <bFeebGetCh1RightBufferEmpty>
81103dd8:	e0bff615 	stw	r2,-40(fp)
			break;
81103ddc:	00000a06 	br	81103e08 <bSdmaDmaM1Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103de0:	00800074 	movhi	r2,1
81103de4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103de8:	00800044 	movi	r2,1
81103dec:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
81103df0:	11067280 	call	81106728 <bFeebGetCh1LeftBufferEmpty>
81103df4:	e0bff615 	stw	r2,-40(fp)
			break;
81103df8:	00000306 	br	81103e08 <bSdmaDmaM1Transfer+0x104>
		default:
			bChannelFlag = FALSE;
81103dfc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103e00:	e03ff615 	stw	zero,-40(fp)
			break;
81103e04:	0001883a 	nop
		}
		break;
81103e08:	00009706 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103e0c:	e0bffd03 	ldbu	r2,-12(fp)
81103e10:	10000926 	beq	r2,zero,81103e38 <bSdmaDmaM1Transfer+0x134>
81103e14:	10800060 	cmpeqi	r2,r2,1
81103e18:	10000f26 	beq	r2,zero,81103e58 <bSdmaDmaM1Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103e1c:	00880004 	movi	r2,8192
81103e20:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103e24:	00800044 	movi	r2,1
81103e28:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81103e2c:	11068600 	call	81106860 <bFeebGetCh2RightBufferEmpty>
81103e30:	e0bff615 	stw	r2,-40(fp)
			break;
81103e34:	00000b06 	br	81103e64 <bSdmaDmaM1Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103e38:	00800074 	movhi	r2,1
81103e3c:	10880004 	addi	r2,r2,8192
81103e40:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103e44:	00800044 	movi	r2,1
81103e48:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
81103e4c:	11067f80 	call	811067f8 <bFeebGetCh2LeftBufferEmpty>
81103e50:	e0bff615 	stw	r2,-40(fp)
			break;
81103e54:	00000306 	br	81103e64 <bSdmaDmaM1Transfer+0x160>
		default:
			bChannelFlag = FALSE;
81103e58:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103e5c:	e03ff615 	stw	zero,-40(fp)
			break;
81103e60:	0001883a 	nop
		}
		break;
81103e64:	00008006 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103e68:	e0bffd03 	ldbu	r2,-12(fp)
81103e6c:	10000826 	beq	r2,zero,81103e90 <bSdmaDmaM1Transfer+0x18c>
81103e70:	10800060 	cmpeqi	r2,r2,1
81103e74:	10000d26 	beq	r2,zero,81103eac <bSdmaDmaM1Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103e78:	00900004 	movi	r2,16384
81103e7c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103e80:	00800044 	movi	r2,1
81103e84:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e88:	e03ff615 	stw	zero,-40(fp)
			break;
81103e8c:	00000a06 	br	81103eb8 <bSdmaDmaM1Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103e90:	00800074 	movhi	r2,1
81103e94:	10900004 	addi	r2,r2,16384
81103e98:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103e9c:	00800044 	movi	r2,1
81103ea0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ea4:	e03ff615 	stw	zero,-40(fp)
			break;
81103ea8:	00000306 	br	81103eb8 <bSdmaDmaM1Transfer+0x1b4>
		default:
			bChannelFlag = FALSE;
81103eac:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103eb0:	e03ff615 	stw	zero,-40(fp)
			break;
81103eb4:	0001883a 	nop
		}
		break;
81103eb8:	00006b06 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103ebc:	e0bffd03 	ldbu	r2,-12(fp)
81103ec0:	10000826 	beq	r2,zero,81103ee4 <bSdmaDmaM1Transfer+0x1e0>
81103ec4:	10800060 	cmpeqi	r2,r2,1
81103ec8:	10000d26 	beq	r2,zero,81103f00 <bSdmaDmaM1Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103ecc:	00980004 	movi	r2,24576
81103ed0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103ed4:	00800044 	movi	r2,1
81103ed8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103edc:	e03ff615 	stw	zero,-40(fp)
			break;
81103ee0:	00000a06 	br	81103f0c <bSdmaDmaM1Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103ee4:	00800074 	movhi	r2,1
81103ee8:	10980004 	addi	r2,r2,24576
81103eec:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103ef0:	00800044 	movi	r2,1
81103ef4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ef8:	e03ff615 	stw	zero,-40(fp)
			break;
81103efc:	00000306 	br	81103f0c <bSdmaDmaM1Transfer+0x208>
		default:
			bChannelFlag = FALSE;
81103f00:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103f04:	e03ff615 	stw	zero,-40(fp)
			break;
81103f08:	0001883a 	nop
		}
		break;
81103f0c:	00005606 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103f10:	e0bffd03 	ldbu	r2,-12(fp)
81103f14:	10000826 	beq	r2,zero,81103f38 <bSdmaDmaM1Transfer+0x234>
81103f18:	10800060 	cmpeqi	r2,r2,1
81103f1c:	10000d26 	beq	r2,zero,81103f54 <bSdmaDmaM1Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103f20:	00a00014 	movui	r2,32768
81103f24:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103f28:	00800044 	movi	r2,1
81103f2c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f30:	e03ff615 	stw	zero,-40(fp)
			break;
81103f34:	00000a06 	br	81103f60 <bSdmaDmaM1Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103f38:	008000b4 	movhi	r2,2
81103f3c:	10a00004 	addi	r2,r2,-32768
81103f40:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103f44:	00800044 	movi	r2,1
81103f48:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f4c:	e03ff615 	stw	zero,-40(fp)
			break;
81103f50:	00000306 	br	81103f60 <bSdmaDmaM1Transfer+0x25c>
		default:
			bChannelFlag = FALSE;
81103f54:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103f58:	e03ff615 	stw	zero,-40(fp)
			break;
81103f5c:	0001883a 	nop
		}
		break;
81103f60:	00004106 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103f64:	e0bffd03 	ldbu	r2,-12(fp)
81103f68:	10000826 	beq	r2,zero,81103f8c <bSdmaDmaM1Transfer+0x288>
81103f6c:	10800060 	cmpeqi	r2,r2,1
81103f70:	10000d26 	beq	r2,zero,81103fa8 <bSdmaDmaM1Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103f74:	00a80014 	movui	r2,40960
81103f78:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103f7c:	00800044 	movi	r2,1
81103f80:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f84:	e03ff615 	stw	zero,-40(fp)
			break;
81103f88:	00000a06 	br	81103fb4 <bSdmaDmaM1Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103f8c:	008000b4 	movhi	r2,2
81103f90:	10a80004 	addi	r2,r2,-24576
81103f94:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103f98:	00800044 	movi	r2,1
81103f9c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fa0:	e03ff615 	stw	zero,-40(fp)
			break;
81103fa4:	00000306 	br	81103fb4 <bSdmaDmaM1Transfer+0x2b0>
		default:
			bChannelFlag = FALSE;
81103fa8:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103fac:	e03ff615 	stw	zero,-40(fp)
			break;
81103fb0:	0001883a 	nop
		}
		break;
81103fb4:	00002c06 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103fb8:	e0bffd03 	ldbu	r2,-12(fp)
81103fbc:	10000826 	beq	r2,zero,81103fe0 <bSdmaDmaM1Transfer+0x2dc>
81103fc0:	10800060 	cmpeqi	r2,r2,1
81103fc4:	10000d26 	beq	r2,zero,81103ffc <bSdmaDmaM1Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103fc8:	00b00014 	movui	r2,49152
81103fcc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103fd0:	00800044 	movi	r2,1
81103fd4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fd8:	e03ff615 	stw	zero,-40(fp)
			break;
81103fdc:	00000a06 	br	81104008 <bSdmaDmaM1Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103fe0:	008000b4 	movhi	r2,2
81103fe4:	10b00004 	addi	r2,r2,-16384
81103fe8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103fec:	00800044 	movi	r2,1
81103ff0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ff4:	e03ff615 	stw	zero,-40(fp)
			break;
81103ff8:	00000306 	br	81104008 <bSdmaDmaM1Transfer+0x304>
		default:
			bChannelFlag = FALSE;
81103ffc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104000:	e03ff615 	stw	zero,-40(fp)
			break;
81104004:	0001883a 	nop
		}
		break;
81104008:	00001706 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
8110400c:	e0bffd03 	ldbu	r2,-12(fp)
81104010:	10000826 	beq	r2,zero,81104034 <bSdmaDmaM1Transfer+0x330>
81104014:	10800060 	cmpeqi	r2,r2,1
81104018:	10000d26 	beq	r2,zero,81104050 <bSdmaDmaM1Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
8110401c:	00b80014 	movui	r2,57344
81104020:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104024:	00800044 	movi	r2,1
81104028:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110402c:	e03ff615 	stw	zero,-40(fp)
			break;
81104030:	00000a06 	br	8110405c <bSdmaDmaM1Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104034:	008000b4 	movhi	r2,2
81104038:	10b80004 	addi	r2,r2,-8192
8110403c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81104040:	00800044 	movi	r2,1
81104044:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104048:	e03ff615 	stw	zero,-40(fp)
			break;
8110404c:	00000306 	br	8110405c <bSdmaDmaM1Transfer+0x358>
		default:
			bChannelFlag = FALSE;
81104050:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104054:	e03ff615 	stw	zero,-40(fp)
			break;
81104058:	0001883a 	nop
		}
		break;
8110405c:	00000206 	br	81104068 <bSdmaDmaM1Transfer+0x364>
	default:
		bChannelFlag = FALSE;
81104060:	e03ff715 	stw	zero,-36(fp)
		break;
81104064:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW	+ (alt_u32) uliDdrInitialAddr;
81104068:	e0bffb17 	ldw	r2,-20(fp)
8110406c:	e0bff815 	stw	r2,-32(fp)
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81104070:	e03ff915 	stw	zero,-28(fp)

	if ( (bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= SDMA_MAX_BLOCKS)) {
81104074:	e0bff717 	ldw	r2,-36(fp)
81104078:	10003026 	beq	r2,zero,8110413c <bSdmaDmaM1Transfer+0x438>
8110407c:	e0bff617 	ldw	r2,-40(fp)
81104080:	10002e26 	beq	r2,zero,8110413c <bSdmaDmaM1Transfer+0x438>
81104084:	e0bffc0b 	ldhu	r2,-16(fp)
81104088:	10800468 	cmpgeui	r2,r2,17
8110408c:	10002b1e 	bne	r2,zero,8110413c <bSdmaDmaM1Transfer+0x438>

		if (pxDmaM1Dev != NULL) {
81104090:	d0a03917 	ldw	r2,-32540(gp)
81104094:	10002926 	beq	r2,zero,8110413c <bSdmaDmaM1Transfer+0x438>
			// hold transfers for descriptor fifo space
			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104098:	00000206 	br	811040a4 <bSdmaDmaM1Transfer+0x3a0>
				alt_busy_sleep(1); /* delay 1us */
8110409c:	01000044 	movi	r4,1
811040a0:	1137ee40 	call	81137ee4 <alt_busy_sleep>

	if ( (bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= SDMA_MAX_BLOCKS)) {

		if (pxDmaM1Dev != NULL) {
			// hold transfers for descriptor fifo space
			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811040a4:	d0a03917 	ldw	r2,-32540(gp)
811040a8:	10800317 	ldw	r2,12(r2)
811040ac:	10800037 	ldwio	r2,0(r2)
811040b0:	1080010c 	andi	r2,r2,4
811040b4:	103ff91e 	bne	r2,zero,8110409c <__reset+0xfb0e409c>
				alt_busy_sleep(1); /* delay 1us */
			}
			/* Success = 0 */
			if (0 == iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
811040b8:	d2203917 	ldw	r8,-32540(gp)
811040bc:	e1bff817 	ldw	r6,-32(fp)
811040c0:	e1fff417 	ldw	r7,-48(fp)
811040c4:	e0bffc0b 	ldhu	r2,-16(fp)
811040c8:	10802224 	muli	r2,r2,136
811040cc:	e0fff917 	ldw	r3,-28(fp)
811040d0:	e13ff517 	ldw	r4,-44(fp)
811040d4:	01400044 	movi	r5,1
811040d8:	d9400815 	stw	r5,32(sp)
811040dc:	01400044 	movi	r5,1
811040e0:	d9400715 	stw	r5,28(sp)
811040e4:	01400044 	movi	r5,1
811040e8:	d9400615 	stw	r5,24(sp)
811040ec:	01400044 	movi	r5,1
811040f0:	d9400515 	stw	r5,20(sp)
811040f4:	01400044 	movi	r5,1
811040f8:	d9400415 	stw	r5,16(sp)
811040fc:	d9000315 	stw	r4,12(sp)
81104100:	d8c00215 	stw	r3,8(sp)
81104104:	e0fffa17 	ldw	r3,-24(fp)
81104108:	d8c00115 	stw	r3,4(sp)
8110410c:	d8800015 	stw	r2,0(sp)
81104110:	800b883a 	mov	r5,r16
81104114:	4009883a 	mov	r4,r8
81104118:	110c3ec0 	call	8110c3ec <iMsgdmaConstructExtendedMmToMmDescriptor>
8110411c:	1000071e 	bne	r2,zero,8110413c <bSdmaDmaM1Transfer+0x438>
					(alt_u32 *) uliDestAddrLow,
					SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
					(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
					1, 1, 1, 1, 1)	) {
				/* Success = 0 */
				if (0 == iMsgdmaExtendedDescriptorAsyncTransfer(pxDmaM1Dev,	&xDmaExtendedDescriptor)) {
81104120:	d0a03917 	ldw	r2,-32540(gp)
81104124:	800b883a 	mov	r5,r16
81104128:	1009883a 	mov	r4,r2
8110412c:	110c4ac0 	call	8110c4ac <iMsgdmaExtendedDescriptorAsyncTransfer>
81104130:	1000021e 	bne	r2,zero,8110413c <bSdmaDmaM1Transfer+0x438>
					bStatus = TRUE;
81104134:	00800044 	movi	r2,1
81104138:	e0bff315 	stw	r2,-52(fp)
				}
			}
		}
	}
	return bStatus;
8110413c:	e0bff317 	ldw	r2,-52(fp)
}
81104140:	e6ffff04 	addi	sp,fp,-4
81104144:	dfc00217 	ldw	ra,8(sp)
81104148:	df000117 	ldw	fp,4(sp)
8110414c:	dc000017 	ldw	r16,0(sp)
81104150:	dec00304 	addi	sp,sp,12
81104154:	f800283a 	ret

81104158 <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
81104158:	deffe804 	addi	sp,sp,-96
8110415c:	de00012e 	bgeu	sp,et,81104164 <bSdmaDmaM2Transfer+0xc>
81104160:	003b68fa 	trap	3
81104164:	dfc01715 	stw	ra,92(sp)
81104168:	df001615 	stw	fp,88(sp)
8110416c:	dc001515 	stw	r16,84(sp)
81104170:	df001604 	addi	fp,sp,88
81104174:	e13ffb15 	stw	r4,-20(fp)
81104178:	2809883a 	mov	r4,r5
8110417c:	3007883a 	mov	r3,r6
81104180:	3805883a 	mov	r2,r7
81104184:	e13ffc0d 	sth	r4,-16(fp)
81104188:	e0fffd05 	stb	r3,-12(fp)
8110418c:	e0bffe05 	stb	r2,-8(fp)
81104190:	defff004 	addi	sp,sp,-64
81104194:	d8800904 	addi	r2,sp,36
81104198:	108007c4 	addi	r2,r2,31
8110419c:	1004d17a 	srli	r2,r2,5
811041a0:	1020917a 	slli	r16,r2,5
	bool bStatus;

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
811041a4:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
811041a8:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
811041ac:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
811041b0:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
811041b4:	e03ffa15 	stw	zero,-24(fp)
	bool bBufferEmptyFlag;
	bool bChannelFlag;


	/* Assuming that the channel selected exist, change to FALSE if doesn't */
	bChannelFlag = TRUE;
811041b8:	00800044 	movi	r2,1
811041bc:	e0bff715 	stw	r2,-36(fp)
	bStatus = FALSE;
811041c0:	e03ff315 	stw	zero,-52(fp)
	bBufferEmptyFlag = FALSE;
811041c4:	e03ff615 	stw	zero,-40(fp)
	switch (ucChBufferId) {
811041c8:	e0bffe03 	ldbu	r2,-8(fp)
811041cc:	10c00228 	cmpgeui	r3,r2,8
811041d0:	1800b81e 	bne	r3,zero,811044b4 <bSdmaDmaM2Transfer+0x35c>
811041d4:	100690ba 	slli	r3,r2,2
811041d8:	00a04434 	movhi	r2,33040
811041dc:	10907b04 	addi	r2,r2,16876
811041e0:	1885883a 	add	r2,r3,r2
811041e4:	10800017 	ldw	r2,0(r2)
811041e8:	1000683a 	jmp	r2
811041ec:	8110420c 	andi	r4,r16,16648
811041f0:	81104260 	cmpeqi	r4,r16,16649
811041f4:	811042bc 	xorhi	r4,r16,16650
811041f8:	81104310 	cmplti	r4,r16,16652
811041fc:	81104364 	muli	r4,r16,16653
81104200:	811043b8 	rdprs	r4,r16,16654
81104204:	8110440c 	andi	r4,r16,16656
81104208:	81104460 	cmpeqi	r4,r16,16657
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
8110420c:	e0bffd03 	ldbu	r2,-12(fp)
81104210:	10000826 	beq	r2,zero,81104234 <bSdmaDmaM2Transfer+0xdc>
81104214:	10800060 	cmpeqi	r2,r2,1
81104218:	10000d26 	beq	r2,zero,81104250 <bSdmaDmaM2Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
8110421c:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81104220:	00800044 	movi	r2,1
81104224:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
81104228:	11067900 	call	81106790 <bFeebGetCh1RightBufferEmpty>
8110422c:	e0bff615 	stw	r2,-40(fp)
			break;
81104230:	00000a06 	br	8110425c <bSdmaDmaM2Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81104234:	00800074 	movhi	r2,1
81104238:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
8110423c:	00800044 	movi	r2,1
81104240:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
81104244:	11067280 	call	81106728 <bFeebGetCh1LeftBufferEmpty>
81104248:	e0bff615 	stw	r2,-40(fp)
			break;
8110424c:	00000306 	br	8110425c <bSdmaDmaM2Transfer+0x104>
		default:
			bChannelFlag = FALSE;
81104250:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104254:	e03ff615 	stw	zero,-40(fp)
			break;
81104258:	0001883a 	nop
		}
		break;
8110425c:	00009706 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81104260:	e0bffd03 	ldbu	r2,-12(fp)
81104264:	10000926 	beq	r2,zero,8110428c <bSdmaDmaM2Transfer+0x134>
81104268:	10800060 	cmpeqi	r2,r2,1
8110426c:	10000f26 	beq	r2,zero,811042ac <bSdmaDmaM2Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81104270:	00880004 	movi	r2,8192
81104274:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81104278:	00800044 	movi	r2,1
8110427c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81104280:	11068600 	call	81106860 <bFeebGetCh2RightBufferEmpty>
81104284:	e0bff615 	stw	r2,-40(fp)
			break;
81104288:	00000b06 	br	811042b8 <bSdmaDmaM2Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
8110428c:	00800074 	movhi	r2,1
81104290:	10880004 	addi	r2,r2,8192
81104294:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81104298:	00800044 	movi	r2,1
8110429c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
811042a0:	11067f80 	call	811067f8 <bFeebGetCh2LeftBufferEmpty>
811042a4:	e0bff615 	stw	r2,-40(fp)
			break;
811042a8:	00000306 	br	811042b8 <bSdmaDmaM2Transfer+0x160>
		default:
			bChannelFlag = FALSE;
811042ac:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
811042b0:	e03ff615 	stw	zero,-40(fp)
			break;
811042b4:	0001883a 	nop
		}
		break;
811042b8:	00008006 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
811042bc:	e0bffd03 	ldbu	r2,-12(fp)
811042c0:	10000826 	beq	r2,zero,811042e4 <bSdmaDmaM2Transfer+0x18c>
811042c4:	10800060 	cmpeqi	r2,r2,1
811042c8:	10000d26 	beq	r2,zero,81104300 <bSdmaDmaM2Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
811042cc:	00900004 	movi	r2,16384
811042d0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
811042d4:	00800044 	movi	r2,1
811042d8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042dc:	e03ff615 	stw	zero,-40(fp)
			break;
811042e0:	00000a06 	br	8110430c <bSdmaDmaM2Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
811042e4:	00800074 	movhi	r2,1
811042e8:	10900004 	addi	r2,r2,16384
811042ec:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
811042f0:	00800044 	movi	r2,1
811042f4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042f8:	e03ff615 	stw	zero,-40(fp)
			break;
811042fc:	00000306 	br	8110430c <bSdmaDmaM2Transfer+0x1b4>
		default:
			bChannelFlag = FALSE;
81104300:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104304:	e03ff615 	stw	zero,-40(fp)
			break;
81104308:	0001883a 	nop
		}
		break;
8110430c:	00006b06 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81104310:	e0bffd03 	ldbu	r2,-12(fp)
81104314:	10000826 	beq	r2,zero,81104338 <bSdmaDmaM2Transfer+0x1e0>
81104318:	10800060 	cmpeqi	r2,r2,1
8110431c:	10000d26 	beq	r2,zero,81104354 <bSdmaDmaM2Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81104320:	00980004 	movi	r2,24576
81104324:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81104328:	00800044 	movi	r2,1
8110432c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104330:	e03ff615 	stw	zero,-40(fp)
			break;
81104334:	00000a06 	br	81104360 <bSdmaDmaM2Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81104338:	00800074 	movhi	r2,1
8110433c:	10980004 	addi	r2,r2,24576
81104340:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81104344:	00800044 	movi	r2,1
81104348:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110434c:	e03ff615 	stw	zero,-40(fp)
			break;
81104350:	00000306 	br	81104360 <bSdmaDmaM2Transfer+0x208>
		default:
			bChannelFlag = FALSE;
81104354:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104358:	e03ff615 	stw	zero,-40(fp)
			break;
8110435c:	0001883a 	nop
		}
		break;
81104360:	00005606 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81104364:	e0bffd03 	ldbu	r2,-12(fp)
81104368:	10000826 	beq	r2,zero,8110438c <bSdmaDmaM2Transfer+0x234>
8110436c:	10800060 	cmpeqi	r2,r2,1
81104370:	10000d26 	beq	r2,zero,811043a8 <bSdmaDmaM2Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81104374:	00a00014 	movui	r2,32768
81104378:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
8110437c:	00800044 	movi	r2,1
81104380:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104384:	e03ff615 	stw	zero,-40(fp)
			break;
81104388:	00000a06 	br	811043b4 <bSdmaDmaM2Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
8110438c:	008000b4 	movhi	r2,2
81104390:	10a00004 	addi	r2,r2,-32768
81104394:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81104398:	00800044 	movi	r2,1
8110439c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043a0:	e03ff615 	stw	zero,-40(fp)
			break;
811043a4:	00000306 	br	811043b4 <bSdmaDmaM2Transfer+0x25c>
		default:
			bChannelFlag = FALSE;
811043a8:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
811043ac:	e03ff615 	stw	zero,-40(fp)
			break;
811043b0:	0001883a 	nop
		}
		break;
811043b4:	00004106 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
811043b8:	e0bffd03 	ldbu	r2,-12(fp)
811043bc:	10000826 	beq	r2,zero,811043e0 <bSdmaDmaM2Transfer+0x288>
811043c0:	10800060 	cmpeqi	r2,r2,1
811043c4:	10000d26 	beq	r2,zero,811043fc <bSdmaDmaM2Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
811043c8:	00a80014 	movui	r2,40960
811043cc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
811043d0:	00800044 	movi	r2,1
811043d4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043d8:	e03ff615 	stw	zero,-40(fp)
			break;
811043dc:	00000a06 	br	81104408 <bSdmaDmaM2Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
811043e0:	008000b4 	movhi	r2,2
811043e4:	10a80004 	addi	r2,r2,-24576
811043e8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
811043ec:	00800044 	movi	r2,1
811043f0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043f4:	e03ff615 	stw	zero,-40(fp)
			break;
811043f8:	00000306 	br	81104408 <bSdmaDmaM2Transfer+0x2b0>
		default:
			bChannelFlag = FALSE;
811043fc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104400:	e03ff615 	stw	zero,-40(fp)
			break;
81104404:	0001883a 	nop
		}
		break;
81104408:	00002c06 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
8110440c:	e0bffd03 	ldbu	r2,-12(fp)
81104410:	10000826 	beq	r2,zero,81104434 <bSdmaDmaM2Transfer+0x2dc>
81104414:	10800060 	cmpeqi	r2,r2,1
81104418:	10000d26 	beq	r2,zero,81104450 <bSdmaDmaM2Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
8110441c:	00b00014 	movui	r2,49152
81104420:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81104424:	00800044 	movi	r2,1
81104428:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110442c:	e03ff615 	stw	zero,-40(fp)
			break;
81104430:	00000a06 	br	8110445c <bSdmaDmaM2Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81104434:	008000b4 	movhi	r2,2
81104438:	10b00004 	addi	r2,r2,-16384
8110443c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81104440:	00800044 	movi	r2,1
81104444:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104448:	e03ff615 	stw	zero,-40(fp)
			break;
8110444c:	00000306 	br	8110445c <bSdmaDmaM2Transfer+0x304>
		default:
			bChannelFlag = FALSE;
81104450:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104454:	e03ff615 	stw	zero,-40(fp)
			break;
81104458:	0001883a 	nop
		}
		break;
8110445c:	00001706 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81104460:	e0bffd03 	ldbu	r2,-12(fp)
81104464:	10000826 	beq	r2,zero,81104488 <bSdmaDmaM2Transfer+0x330>
81104468:	10800060 	cmpeqi	r2,r2,1
8110446c:	10000d26 	beq	r2,zero,811044a4 <bSdmaDmaM2Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81104470:	00b80014 	movui	r2,57344
81104474:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104478:	00800044 	movi	r2,1
8110447c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104480:	e03ff615 	stw	zero,-40(fp)
			break;
81104484:	00000a06 	br	811044b0 <bSdmaDmaM2Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104488:	008000b4 	movhi	r2,2
8110448c:	10b80004 	addi	r2,r2,-8192
81104490:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81104494:	00800044 	movi	r2,1
81104498:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110449c:	e03ff615 	stw	zero,-40(fp)
			break;
811044a0:	00000306 	br	811044b0 <bSdmaDmaM2Transfer+0x358>
		default:
			bChannelFlag = FALSE;
811044a4:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
811044a8:	e03ff615 	stw	zero,-40(fp)
			break;
811044ac:	0001883a 	nop
		}
		break;
811044b0:	00000206 	br	811044bc <bSdmaDmaM2Transfer+0x364>
	default:
		bChannelFlag = FALSE;
811044b4:	e03ff715 	stw	zero,-36(fp)
		break;
811044b8:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
811044bc:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bChannelFlag = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
811044c0:	00a00034 	movhi	r2,32768
811044c4:	1885883a 	add	r2,r3,r2
811044c8:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
811044cc:	e03ff915 	stw	zero,-28(fp)

	if ((bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= SDMA_MAX_BLOCKS)) {
811044d0:	e0bff717 	ldw	r2,-36(fp)
811044d4:	10003026 	beq	r2,zero,81104598 <bSdmaDmaM2Transfer+0x440>
811044d8:	e0bff617 	ldw	r2,-40(fp)
811044dc:	10002e26 	beq	r2,zero,81104598 <bSdmaDmaM2Transfer+0x440>
811044e0:	e0bffc0b 	ldhu	r2,-16(fp)
811044e4:	10800468 	cmpgeui	r2,r2,17
811044e8:	10002b1e 	bne	r2,zero,81104598 <bSdmaDmaM2Transfer+0x440>
		if (pxDmaM2Dev != NULL) {
811044ec:	d0a03a17 	ldw	r2,-32536(gp)
811044f0:	10002926 	beq	r2,zero,81104598 <bSdmaDmaM2Transfer+0x440>

			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811044f4:	00000206 	br	81104500 <bSdmaDmaM2Transfer+0x3a8>
				alt_busy_sleep(1); /* delay 1us */
811044f8:	01000044 	movi	r4,1
811044fc:	1137ee40 	call	81137ee4 <alt_busy_sleep>
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;

	if ((bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= SDMA_MAX_BLOCKS)) {
		if (pxDmaM2Dev != NULL) {

			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104500:	d0a03a17 	ldw	r2,-32536(gp)
81104504:	10800317 	ldw	r2,12(r2)
81104508:	10800037 	ldwio	r2,0(r2)
8110450c:	1080010c 	andi	r2,r2,4
81104510:	103ff91e 	bne	r2,zero,811044f8 <__reset+0xfb0e44f8>
				alt_busy_sleep(1); /* delay 1us */
			}
			/* Success = 0 */
			if ( 0 == iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
81104514:	d2203a17 	ldw	r8,-32536(gp)
81104518:	e1bff817 	ldw	r6,-32(fp)
8110451c:	e1fff417 	ldw	r7,-48(fp)
81104520:	e0bffc0b 	ldhu	r2,-16(fp)
81104524:	10802224 	muli	r2,r2,136
81104528:	e0fff917 	ldw	r3,-28(fp)
8110452c:	e13ff517 	ldw	r4,-44(fp)
81104530:	01400044 	movi	r5,1
81104534:	d9400815 	stw	r5,32(sp)
81104538:	01400044 	movi	r5,1
8110453c:	d9400715 	stw	r5,28(sp)
81104540:	01400044 	movi	r5,1
81104544:	d9400615 	stw	r5,24(sp)
81104548:	01400044 	movi	r5,1
8110454c:	d9400515 	stw	r5,20(sp)
81104550:	01400044 	movi	r5,1
81104554:	d9400415 	stw	r5,16(sp)
81104558:	d9000315 	stw	r4,12(sp)
8110455c:	d8c00215 	stw	r3,8(sp)
81104560:	e0fffa17 	ldw	r3,-24(fp)
81104564:	d8c00115 	stw	r3,4(sp)
81104568:	d8800015 	stw	r2,0(sp)
8110456c:	800b883a 	mov	r5,r16
81104570:	4009883a 	mov	r4,r8
81104574:	110c3ec0 	call	8110c3ec <iMsgdmaConstructExtendedMmToMmDescriptor>
81104578:	1000071e 	bne	r2,zero,81104598 <bSdmaDmaM2Transfer+0x440>
					(alt_u32 *) uliDestAddrLow,
					SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
					(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
					1, 1, 1, 1, 1)) {
				/* Success = 0 */
				if ( 0 == iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
8110457c:	d0a03a17 	ldw	r2,-32536(gp)
81104580:	800b883a 	mov	r5,r16
81104584:	1009883a 	mov	r4,r2
81104588:	110c4f00 	call	8110c4f0 <iMsgdmaExtendedDescriptorSyncTransfer>
8110458c:	1000021e 	bne	r2,zero,81104598 <bSdmaDmaM2Transfer+0x440>
						&xDmaExtendedDescriptor)) {
					bStatus = TRUE;
81104590:	00800044 	movi	r2,1
81104594:	e0bff315 	stw	r2,-52(fp)
				}
			}
		}
	}
	return bStatus;
81104598:	e0bff317 	ldw	r2,-52(fp)
}
8110459c:	e6ffff04 	addi	sp,fp,-4
811045a0:	dfc00217 	ldw	ra,8(sp)
811045a4:	df000117 	ldw	fp,4(sp)
811045a8:	dc000017 	ldw	r16,0(sp)
811045ac:	dec00304 	addi	sp,sp,12
811045b0:	f800283a 	ret

811045b4 <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
811045b4:	defff804 	addi	sp,sp,-32
811045b8:	de00012e 	bgeu	sp,et,811045c0 <bCommSetGlobalIrqEn+0xc>
811045bc:	003b68fa 	trap	3
811045c0:	dfc00715 	stw	ra,28(sp)
811045c4:	df000615 	stw	fp,24(sp)
811045c8:	df000604 	addi	fp,sp,24
811045cc:	e13ffe15 	stw	r4,-8(fp)
811045d0:	2805883a 	mov	r2,r5
811045d4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
811045d8:	e03ffa15 	stw	zero,-24(fp)
	bool bValidCh = FALSE;
811045dc:	e03ffb15 	stw	zero,-20(fp)
	volatile alt_u32 uliReg = 0;
811045e0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 *puliCommAddr = 0;
811045e4:	e03ffc15 	stw	zero,-16(fp)

	switch (ucCommCh) {
811045e8:	e0bfff03 	ldbu	r2,-4(fp)
811045ec:	10c00228 	cmpgeui	r3,r2,8
811045f0:	18003e1e 	bne	r3,zero,811046ec <bCommSetGlobalIrqEn+0x138>
811045f4:	100690ba 	slli	r3,r2,2
811045f8:	00a04434 	movhi	r2,33040
811045fc:	10918304 	addi	r2,r2,17932
81104600:	1885883a 	add	r2,r3,r2
81104604:	10800017 	ldw	r2,0(r2)
81104608:	1000683a 	jmp	r2
8110460c:	8110462c 	andhi	r4,r16,16664
81104610:	81104644 	addi	r4,r16,16665
81104614:	8110465c 	xori	r4,r16,16665
81104618:	81104674 	orhi	r4,r16,16665
8110461c:	8110468c 	andi	r4,r16,16666
81104620:	811046a4 	muli	r4,r16,16666
81104624:	811046bc 	xorhi	r4,r16,16666
81104628:	811046d4 	ori	r4,r16,16667
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110462c:	00a04834 	movhi	r2,33056
81104630:	108b0004 	addi	r2,r2,11264
81104634:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
81104638:	00800044 	movi	r2,1
8110463c:	e0bffb15 	stw	r2,-20(fp)
		break;
81104640:	00002c06 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104644:	00a04834 	movhi	r2,33056
81104648:	108a0004 	addi	r2,r2,10240
8110464c:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
81104650:	00800044 	movi	r2,1
81104654:	e0bffb15 	stw	r2,-20(fp)
		break;
81104658:	00002606 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110465c:	00a04834 	movhi	r2,33056
81104660:	108b0004 	addi	r2,r2,11264
81104664:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
81104668:	00800044 	movi	r2,1
8110466c:	e0bffb15 	stw	r2,-20(fp)
		break;
81104670:	00002006 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104674:	00a04834 	movhi	r2,33056
81104678:	108a0004 	addi	r2,r2,10240
8110467c:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
81104680:	00800044 	movi	r2,1
81104684:	e0bffb15 	stw	r2,-20(fp)
		break;
81104688:	00001a06 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110468c:	00a04834 	movhi	r2,33056
81104690:	108b0004 	addi	r2,r2,11264
81104694:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
81104698:	00800044 	movi	r2,1
8110469c:	e0bffb15 	stw	r2,-20(fp)
		break;
811046a0:	00001406 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811046a4:	00a04834 	movhi	r2,33056
811046a8:	108a0004 	addi	r2,r2,10240
811046ac:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
811046b0:	00800044 	movi	r2,1
811046b4:	e0bffb15 	stw	r2,-20(fp)
		break;
811046b8:	00000e06 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
811046bc:	00a04834 	movhi	r2,33056
811046c0:	108b0004 	addi	r2,r2,11264
811046c4:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
811046c8:	00800044 	movi	r2,1
811046cc:	e0bffb15 	stw	r2,-20(fp)
		break;
811046d0:	00000806 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
811046d4:	00a04834 	movhi	r2,33056
811046d8:	108a0004 	addi	r2,r2,10240
811046dc:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
811046e0:	00800044 	movi	r2,1
811046e4:	e0bffb15 	stw	r2,-20(fp)
		break;
811046e8:	00000206 	br	811046f4 <bCommSetGlobalIrqEn+0x140>
	default:
		bValidCh = FALSE;
811046ec:	e03ffb15 	stw	zero,-20(fp)
		break;
811046f0:	0001883a 	nop
	}

	if (bValidCh) {
811046f4:	e0bffb17 	ldw	r2,-20(fp)
811046f8:	10001626 	beq	r2,zero,81104754 <bCommSetGlobalIrqEn+0x1a0>
		uliReg = uliCommReadReg(puliCommAddr,
811046fc:	01400444 	movi	r5,17
81104700:	e13ffc17 	ldw	r4,-16(fp)
81104704:	11048bc0 	call	811048bc <uliCommReadReg>
81104708:	e0bffd15 	stw	r2,-12(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
8110470c:	e0bffe17 	ldw	r2,-8(fp)
81104710:	10000426 	beq	r2,zero,81104724 <bCommSetGlobalIrqEn+0x170>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
81104714:	e0bffd17 	ldw	r2,-12(fp)
81104718:	10800074 	orhi	r2,r2,1
8110471c:	e0bffd15 	stw	r2,-12(fp)
81104720:	00000506 	br	81104738 <bCommSetGlobalIrqEn+0x184>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
81104724:	e0fffd17 	ldw	r3,-12(fp)
81104728:	00bffff4 	movhi	r2,65535
8110472c:	10bfffc4 	addi	r2,r2,-1
81104730:	1884703a 	and	r2,r3,r2
81104734:	e0bffd15 	stw	r2,-12(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
81104738:	e0bffd17 	ldw	r2,-12(fp)
8110473c:	100d883a 	mov	r6,r2
81104740:	01400444 	movi	r5,17
81104744:	e13ffc17 	ldw	r4,-16(fp)
81104748:	11048680 	call	81104868 <vCommWriteReg>

		bStatus = TRUE;
8110474c:	00800044 	movi	r2,1
81104750:	e0bffa15 	stw	r2,-24(fp)
	}

	return bStatus;
81104754:	e0bffa17 	ldw	r2,-24(fp)
}
81104758:	e037883a 	mov	sp,fp
8110475c:	dfc00117 	ldw	ra,4(sp)
81104760:	df000017 	ldw	fp,0(sp)
81104764:	dec00204 	addi	sp,sp,8
81104768:	f800283a 	ret

8110476c <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
8110476c:	defffa04 	addi	sp,sp,-24
81104770:	de00012e 	bgeu	sp,et,81104778 <bCommInitCh+0xc>
81104774:	003b68fa 	trap	3
81104778:	dfc00515 	stw	ra,20(sp)
8110477c:	df000415 	stw	fp,16(sp)
81104780:	df000404 	addi	fp,sp,16
81104784:	e13ffe15 	stw	r4,-8(fp)
81104788:	2805883a 	mov	r2,r5
8110478c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104790:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
81104794:	e03ffd15 	stw	zero,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
81104798:	e0bffe17 	ldw	r2,-8(fp)
8110479c:	10805904 	addi	r2,r2,356
811047a0:	e0ffff03 	ldbu	r3,-4(fp)
811047a4:	180b883a 	mov	r5,r3
811047a8:	1009883a 	mov	r4,r2
811047ac:	110ac4c0 	call	8110ac4c <bSpwcInitCh>
811047b0:	1000021e 	bne	r2,zero,811047bc <bCommInitCh+0x50>
		bInitFail = TRUE;
811047b4:	00800044 	movi	r2,1
811047b8:	e0bffd15 	stw	r2,-12(fp)
	}
//	if (!vFeebInitIrq(ucCommCh)) {
//		bInitFail = TRUE;
//	}
	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
811047bc:	e0bffe17 	ldw	r2,-8(fp)
811047c0:	10800904 	addi	r2,r2,36
811047c4:	e0ffff03 	ldbu	r3,-4(fp)
811047c8:	180b883a 	mov	r5,r3
811047cc:	1009883a 	mov	r4,r2
811047d0:	1106e280 	call	81106e28 <bFeebInitCh>
811047d4:	1000021e 	bne	r2,zero,811047e0 <bCommInitCh+0x74>
		bInitFail = TRUE;
811047d8:	00800044 	movi	r2,1
811047dc:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
811047e0:	e0bffe17 	ldw	r2,-8(fp)
811047e4:	10801304 	addi	r2,r2,76
811047e8:	e0ffff03 	ldbu	r3,-4(fp)
811047ec:	180b883a 	mov	r5,r3
811047f0:	1009883a 	mov	r4,r2
811047f4:	110a2380 	call	8110a238 <bRmapInitCh>
811047f8:	1000021e 	bne	r2,zero,81104804 <bCommInitCh+0x98>
		bInitFail = TRUE;
811047fc:	00800044 	movi	r2,1
81104800:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!vRmapInitIrq(ucCommCh)) {
81104804:	e0bfff03 	ldbu	r2,-4(fp)
81104808:	1009883a 	mov	r4,r2
8110480c:	1107b580 	call	81107b58 <vRmapInitIrq>
81104810:	1000021e 	bne	r2,zero,8110481c <bCommInitCh+0xb0>
		bInitFail = TRUE;
81104814:	00800044 	movi	r2,1
81104818:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
8110481c:	e0bffe17 	ldw	r2,-8(fp)
81104820:	10800104 	addi	r2,r2,4
81104824:	e0ffff03 	ldbu	r3,-4(fp)
81104828:	180b883a 	mov	r5,r3
8110482c:	1009883a 	mov	r4,r2
81104830:	1104fe40 	call	81104fe4 <bDpktInitCh>
81104834:	1000021e 	bne	r2,zero,81104840 <bCommInitCh+0xd4>
		bInitFail = TRUE;
81104838:	00800044 	movi	r2,1
8110483c:	e0bffd15 	stw	r2,-12(fp)
	}

	if (!bInitFail) {
81104840:	e0bffd17 	ldw	r2,-12(fp)
81104844:	1000021e 	bne	r2,zero,81104850 <bCommInitCh+0xe4>
		bStatus = TRUE;
81104848:	00800044 	movi	r2,1
8110484c:	e0bffc15 	stw	r2,-16(fp)
	}

	return bStatus;
81104850:	e0bffc17 	ldw	r2,-16(fp)
}
81104854:	e037883a 	mov	sp,fp
81104858:	dfc00117 	ldw	ra,4(sp)
8110485c:	df000017 	ldw	fp,0(sp)
81104860:	dec00204 	addi	sp,sp,8
81104864:	f800283a 	ret

81104868 <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104868:	defffc04 	addi	sp,sp,-16
8110486c:	de00012e 	bgeu	sp,et,81104874 <vCommWriteReg+0xc>
81104870:	003b68fa 	trap	3
81104874:	df000315 	stw	fp,12(sp)
81104878:	df000304 	addi	fp,sp,12
8110487c:	e13ffd15 	stw	r4,-12(fp)
81104880:	e17ffe15 	stw	r5,-8(fp)
81104884:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104888:	e0bffe17 	ldw	r2,-8(fp)
8110488c:	1085883a 	add	r2,r2,r2
81104890:	1085883a 	add	r2,r2,r2
81104894:	1007883a 	mov	r3,r2
81104898:	e0bffd17 	ldw	r2,-12(fp)
8110489c:	10c5883a 	add	r2,r2,r3
811048a0:	e0ffff17 	ldw	r3,-4(fp)
811048a4:	10c00015 	stw	r3,0(r2)
}
811048a8:	0001883a 	nop
811048ac:	e037883a 	mov	sp,fp
811048b0:	df000017 	ldw	fp,0(sp)
811048b4:	dec00104 	addi	sp,sp,4
811048b8:	f800283a 	ret

811048bc <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811048bc:	defffc04 	addi	sp,sp,-16
811048c0:	de00012e 	bgeu	sp,et,811048c8 <uliCommReadReg+0xc>
811048c4:	003b68fa 	trap	3
811048c8:	df000315 	stw	fp,12(sp)
811048cc:	df000304 	addi	fp,sp,12
811048d0:	e13ffe15 	stw	r4,-8(fp)
811048d4:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811048d8:	e0bfff17 	ldw	r2,-4(fp)
811048dc:	1085883a 	add	r2,r2,r2
811048e0:	1085883a 	add	r2,r2,r2
811048e4:	1007883a 	mov	r3,r2
811048e8:	e0bffe17 	ldw	r2,-8(fp)
811048ec:	10c5883a 	add	r2,r2,r3
811048f0:	10800017 	ldw	r2,0(r2)
811048f4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
811048f8:	e0bffd17 	ldw	r2,-12(fp)
}
811048fc:	e037883a 	mov	sp,fp
81104900:	df000017 	ldw	fp,0(sp)
81104904:	dec00104 	addi	sp,sp,4
81104908:	f800283a 	ret

8110490c <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
8110490c:	defffb04 	addi	sp,sp,-20
81104910:	de00012e 	bgeu	sp,et,81104918 <bDpktSetPacketConfig+0xc>
81104914:	003b68fa 	trap	3
81104918:	dfc00415 	stw	ra,16(sp)
8110491c:	df000315 	stw	fp,12(sp)
81104920:	df000304 	addi	fp,sp,12
81104924:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104928:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110492c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104930:	e0bfff17 	ldw	r2,-4(fp)
81104934:	10009826 	beq	r2,zero,81104b98 <bDpktSetPacketConfig+0x28c>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104938:	e0bfff17 	ldw	r2,-4(fp)
8110493c:	10800017 	ldw	r2,0(r2)
81104940:	01400204 	movi	r5,8
81104944:	1009883a 	mov	r4,r2
81104948:	11052080 	call	81105208 <uliDpktReadReg>
8110494c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
81104950:	e0bffe17 	ldw	r2,-8(fp)
81104954:	10bfffec 	andhi	r2,r2,65535
81104958:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
8110495c:	e0bfff17 	ldw	r2,-4(fp)
81104960:	1080010b 	ldhu	r2,4(r2)
81104964:	10ffffcc 	andi	r3,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
81104968:	e0bffe17 	ldw	r2,-8(fp)
8110496c:	1884b03a 	or	r2,r3,r2
81104970:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
81104974:	e0bffe17 	ldw	r2,-8(fp)
81104978:	10bfffcc 	andi	r2,r2,65535
8110497c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
81104980:	e0bfff17 	ldw	r2,-4(fp)
81104984:	1080018b 	ldhu	r2,6(r2)
81104988:	10bfffcc 	andi	r2,r2,65535
8110498c:	1004943a 	slli	r2,r2,16
81104990:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
81104994:	e0bffe17 	ldw	r2,-8(fp)
81104998:	1884b03a 	or	r2,r3,r2
8110499c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
811049a0:	e0bfff17 	ldw	r2,-4(fp)
811049a4:	10800017 	ldw	r2,0(r2)
811049a8:	e0fffe17 	ldw	r3,-8(fp)
811049ac:	180d883a 	mov	r6,r3
811049b0:	01400204 	movi	r5,8
811049b4:	1009883a 	mov	r4,r2
811049b8:	11051b40 	call	811051b4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811049bc:	e0bfff17 	ldw	r2,-4(fp)
811049c0:	10800017 	ldw	r2,0(r2)
811049c4:	01400244 	movi	r5,9
811049c8:	1009883a 	mov	r4,r2
811049cc:	11052080 	call	81105208 <uliDpktReadReg>
811049d0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
811049d4:	e0bffe17 	ldw	r2,-8(fp)
811049d8:	10bfffec 	andhi	r2,r2,65535
811049dc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
811049e0:	e0bfff17 	ldw	r2,-4(fp)
811049e4:	1080020b 	ldhu	r2,8(r2)
811049e8:	10ffffcc 	andi	r3,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
811049ec:	e0bffe17 	ldw	r2,-8(fp)
811049f0:	1884b03a 	or	r2,r3,r2
811049f4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
811049f8:	e0bffe17 	ldw	r2,-8(fp)
811049fc:	10bfffcc 	andi	r2,r2,65535
81104a00:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81104a04:	e0bfff17 	ldw	r2,-4(fp)
81104a08:	1080028b 	ldhu	r2,10(r2)
										<< 16));
81104a0c:	10bfffcc 	andi	r2,r2,65535
81104a10:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
81104a14:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
81104a18:	e0bffe17 	ldw	r2,-8(fp)
81104a1c:	1884b03a 	or	r2,r3,r2
81104a20:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
81104a24:	e0bfff17 	ldw	r2,-4(fp)
81104a28:	10800017 	ldw	r2,0(r2)
81104a2c:	e0fffe17 	ldw	r3,-8(fp)
81104a30:	180d883a 	mov	r6,r3
81104a34:	01400244 	movi	r5,9
81104a38:	1009883a 	mov	r4,r2
81104a3c:	11051b40 	call	811051b4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a40:	e0bfff17 	ldw	r2,-4(fp)
81104a44:	10800017 	ldw	r2,0(r2)
81104a48:	01400284 	movi	r5,10
81104a4c:	1009883a 	mov	r4,r2
81104a50:	11052080 	call	81105208 <uliDpktReadReg>
81104a54:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
81104a58:	e0bffe17 	ldw	r2,-8(fp)
81104a5c:	10bfffec 	andhi	r2,r2,65535
81104a60:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
81104a64:	e0bfff17 	ldw	r2,-4(fp)
81104a68:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
81104a6c:	10ffffcc 	andi	r3,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
81104a70:	e0bffe17 	ldw	r2,-8(fp)
81104a74:	1884b03a 	or	r2,r3,r2
81104a78:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
81104a7c:	e0bfff17 	ldw	r2,-4(fp)
81104a80:	10800017 	ldw	r2,0(r2)
81104a84:	e0fffe17 	ldw	r3,-8(fp)
81104a88:	180d883a 	mov	r6,r3
81104a8c:	01400284 	movi	r5,10
81104a90:	1009883a 	mov	r4,r2
81104a94:	11051b40 	call	811051b4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a98:	e0bfff17 	ldw	r2,-4(fp)
81104a9c:	10800017 	ldw	r2,0(r2)
81104aa0:	014002c4 	movi	r5,11
81104aa4:	1009883a 	mov	r4,r2
81104aa8:	11052080 	call	81105208 <uliDpktReadReg>
81104aac:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
81104ab0:	e0fffe17 	ldw	r3,-8(fp)
81104ab4:	00bfc004 	movi	r2,-256
81104ab8:	1884703a 	and	r2,r3,r2
81104abc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
81104ac0:	e0bfff17 	ldw	r2,-4(fp)
81104ac4:	10800383 	ldbu	r2,14(r2)
81104ac8:	10c03fcc 	andi	r3,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
81104acc:	e0bffe17 	ldw	r2,-8(fp)
81104ad0:	1884b03a 	or	r2,r3,r2
81104ad4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
81104ad8:	e0fffe17 	ldw	r3,-8(fp)
81104adc:	00bffff4 	movhi	r2,65535
81104ae0:	10803fc4 	addi	r2,r2,255
81104ae4:	1884703a 	and	r2,r3,r2
81104ae8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81104aec:	e0bfff17 	ldw	r2,-4(fp)
81104af0:	108003c3 	ldbu	r2,15(r2)
81104af4:	10803fcc 	andi	r2,r2,255
81104af8:	1004923a 	slli	r2,r2,8
81104afc:	10ffffcc 	andi	r3,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104b00:	e0bffe17 	ldw	r2,-8(fp)
81104b04:	1884b03a 	or	r2,r3,r2
81104b08:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
		uliReg &= (~COMM_DATA_PKT_PROTOCOL_ID_MSK);
81104b0c:	e0fffe17 	ldw	r3,-8(fp)
81104b10:	00bfc074 	movhi	r2,65281
81104b14:	10bfffc4 	addi	r2,r2,-1
81104b18:	1884703a 	and	r2,r3,r2
81104b1c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_PROTOCOL_ID_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucProtocolId << 16));
81104b20:	e0bfff17 	ldw	r2,-4(fp)
81104b24:	10800403 	ldbu	r2,16(r2)
81104b28:	10803fcc 	andi	r2,r2,255
81104b2c:	1004943a 	slli	r2,r2,16
81104b30:	10c03fec 	andhi	r3,r2,255
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
		uliReg &= (~COMM_DATA_PKT_PROTOCOL_ID_MSK);
		uliReg |= (COMM_DATA_PKT_PROTOCOL_ID_MSK
81104b34:	e0bffe17 	ldw	r2,-8(fp)
81104b38:	1884b03a 	or	r2,r3,r2
81104b3c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucProtocolId << 16));
		uliReg &= (~COMM_DATA_PKT_LOGICAL_ADDR_MSK);
81104b40:	e0fffe17 	ldw	r3,-8(fp)
81104b44:	00804034 	movhi	r2,256
81104b48:	10bfffc4 	addi	r2,r2,-1
81104b4c:	1884703a 	and	r2,r3,r2
81104b50:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LOGICAL_ADDR_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucLogicalAddr << 24));
81104b54:	e0bfff17 	ldw	r2,-4(fp)
81104b58:	10800443 	ldbu	r2,17(r2)
81104b5c:	10803fcc 	andi	r2,r2,255
81104b60:	1004963a 	slli	r2,r2,24
81104b64:	1007883a 	mov	r3,r2
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
		uliReg &= (~COMM_DATA_PKT_PROTOCOL_ID_MSK);
		uliReg |= (COMM_DATA_PKT_PROTOCOL_ID_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucProtocolId << 16));
		uliReg &= (~COMM_DATA_PKT_LOGICAL_ADDR_MSK);
		uliReg |= (COMM_DATA_PKT_LOGICAL_ADDR_MSK
81104b68:	e0bffe17 	ldw	r2,-8(fp)
81104b6c:	1884b03a 	or	r2,r3,r2
81104b70:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucLogicalAddr << 24));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104b74:	e0bfff17 	ldw	r2,-4(fp)
81104b78:	10800017 	ldw	r2,0(r2)
81104b7c:	e0fffe17 	ldw	r3,-8(fp)
81104b80:	180d883a 	mov	r6,r3
81104b84:	014002c4 	movi	r5,11
81104b88:	1009883a 	mov	r4,r2
81104b8c:	11051b40 	call	811051b4 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104b90:	00800044 	movi	r2,1
81104b94:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104b98:	e0bffd17 	ldw	r2,-12(fp)
}
81104b9c:	e037883a 	mov	sp,fp
81104ba0:	dfc00117 	ldw	ra,4(sp)
81104ba4:	df000017 	ldw	fp,0(sp)
81104ba8:	dec00204 	addi	sp,sp,8
81104bac:	f800283a 	ret

81104bb0 <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
81104bb0:	defffb04 	addi	sp,sp,-20
81104bb4:	de00012e 	bgeu	sp,et,81104bbc <bDpktGetPacketConfig+0xc>
81104bb8:	003b68fa 	trap	3
81104bbc:	dfc00415 	stw	ra,16(sp)
81104bc0:	df000315 	stw	fp,12(sp)
81104bc4:	df000304 	addi	fp,sp,12
81104bc8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104bcc:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81104bd0:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104bd4:	e0bfff17 	ldw	r2,-4(fp)
81104bd8:	10004526 	beq	r2,zero,81104cf0 <bDpktGetPacketConfig+0x140>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104bdc:	e0bfff17 	ldw	r2,-4(fp)
81104be0:	10800017 	ldw	r2,0(r2)
81104be4:	01400204 	movi	r5,8
81104be8:	1009883a 	mov	r4,r2
81104bec:	11052080 	call	81105208 <uliDpktReadReg>
81104bf0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104bf4:	e0bffe17 	ldw	r2,-8(fp)
81104bf8:	1007883a 	mov	r3,r2
81104bfc:	e0bfff17 	ldw	r2,-4(fp)
81104c00:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104c04:	e0bffe17 	ldw	r2,-8(fp)
81104c08:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104c0c:	1007883a 	mov	r3,r2
81104c10:	e0bfff17 	ldw	r2,-4(fp)
81104c14:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c18:	e0bfff17 	ldw	r2,-4(fp)
81104c1c:	10800017 	ldw	r2,0(r2)
81104c20:	01400244 	movi	r5,9
81104c24:	1009883a 	mov	r4,r2
81104c28:	11052080 	call	81105208 <uliDpktReadReg>
81104c2c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104c30:	e0bffe17 	ldw	r2,-8(fp)
81104c34:	1007883a 	mov	r3,r2
81104c38:	e0bfff17 	ldw	r2,-4(fp)
81104c3c:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104c40:	e0bffe17 	ldw	r2,-8(fp)
81104c44:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104c48:	1007883a 	mov	r3,r2
81104c4c:	e0bfff17 	ldw	r2,-4(fp)
81104c50:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c54:	e0bfff17 	ldw	r2,-4(fp)
81104c58:	10800017 	ldw	r2,0(r2)
81104c5c:	01400284 	movi	r5,10
81104c60:	1009883a 	mov	r4,r2
81104c64:	11052080 	call	81105208 <uliDpktReadReg>
81104c68:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104c6c:	e0bffe17 	ldw	r2,-8(fp)
81104c70:	1007883a 	mov	r3,r2
81104c74:	e0bfff17 	ldw	r2,-4(fp)
81104c78:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c7c:	e0bfff17 	ldw	r2,-4(fp)
81104c80:	10800017 	ldw	r2,0(r2)
81104c84:	014002c4 	movi	r5,11
81104c88:	1009883a 	mov	r4,r2
81104c8c:	11052080 	call	81105208 <uliDpktReadReg>
81104c90:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81104c94:	e0bffe17 	ldw	r2,-8(fp)
81104c98:	1007883a 	mov	r3,r2
81104c9c:	e0bfff17 	ldw	r2,-4(fp)
81104ca0:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81104ca4:	e0bffe17 	ldw	r2,-8(fp)
81104ca8:	10bfc00c 	andi	r2,r2,65280
81104cac:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81104cb0:	1007883a 	mov	r3,r2
81104cb4:	e0bfff17 	ldw	r2,-4(fp)
81104cb8:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
		pxDpktCh->xDpktDataPacketConfig.ucProtocolId= (alt_u8)(
				(uliReg & COMM_DATA_PKT_PROTOCOL_ID_MSK) >> 16);
81104cbc:	e0bffe17 	ldw	r2,-8(fp)
81104cc0:	10803fec 	andhi	r2,r2,255
81104cc4:	1004d43a 	srli	r2,r2,16

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
		pxDpktCh->xDpktDataPacketConfig.ucProtocolId= (alt_u8)(
81104cc8:	1007883a 	mov	r3,r2
81104ccc:	e0bfff17 	ldw	r2,-4(fp)
81104cd0:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_DATA_PKT_PROTOCOL_ID_MSK) >> 16);
		pxDpktCh->xDpktDataPacketConfig.ucLogicalAddr= (alt_u8)(
				(uliReg & COMM_DATA_PKT_LOGICAL_ADDR_MSK) >> 24);
81104cd4:	e0bffe17 	ldw	r2,-8(fp)
81104cd8:	1004d63a 	srli	r2,r2,24
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
		pxDpktCh->xDpktDataPacketConfig.ucProtocolId= (alt_u8)(
				(uliReg & COMM_DATA_PKT_PROTOCOL_ID_MSK) >> 16);
		pxDpktCh->xDpktDataPacketConfig.ucLogicalAddr= (alt_u8)(
81104cdc:	1007883a 	mov	r3,r2
81104ce0:	e0bfff17 	ldw	r2,-4(fp)
81104ce4:	10c00445 	stb	r3,17(r2)
				(uliReg & COMM_DATA_PKT_LOGICAL_ADDR_MSK) >> 24);

		bStatus = TRUE;
81104ce8:	00800044 	movi	r2,1
81104cec:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104cf0:	e0bffd17 	ldw	r2,-12(fp)
}
81104cf4:	e037883a 	mov	sp,fp
81104cf8:	dfc00117 	ldw	ra,4(sp)
81104cfc:	df000017 	ldw	fp,0(sp)
81104d00:	dec00204 	addi	sp,sp,8
81104d04:	f800283a 	ret

81104d08 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104d08:	defffb04 	addi	sp,sp,-20
81104d0c:	de00012e 	bgeu	sp,et,81104d14 <bDpktGetPacketHeader+0xc>
81104d10:	003b68fa 	trap	3
81104d14:	dfc00415 	stw	ra,16(sp)
81104d18:	df000315 	stw	fp,12(sp)
81104d1c:	df000304 	addi	fp,sp,12
81104d20:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104d24:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81104d28:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104d2c:	e0bfff17 	ldw	r2,-4(fp)
81104d30:	10002026 	beq	r2,zero,81104db4 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d34:	e0bfff17 	ldw	r2,-4(fp)
81104d38:	10800017 	ldw	r2,0(r2)
81104d3c:	01400304 	movi	r5,12
81104d40:	1009883a 	mov	r4,r2
81104d44:	11052080 	call	81105208 <uliDpktReadReg>
81104d48:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104d4c:	e0bffe17 	ldw	r2,-8(fp)
81104d50:	1007883a 	mov	r3,r2
81104d54:	e0bfff17 	ldw	r2,-4(fp)
81104d58:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104d5c:	e0bffe17 	ldw	r2,-8(fp)
81104d60:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104d64:	1007883a 	mov	r3,r2
81104d68:	e0bfff17 	ldw	r2,-4(fp)
81104d6c:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d70:	e0bfff17 	ldw	r2,-4(fp)
81104d74:	10800017 	ldw	r2,0(r2)
81104d78:	01400344 	movi	r5,13
81104d7c:	1009883a 	mov	r4,r2
81104d80:	11052080 	call	81105208 <uliDpktReadReg>
81104d84:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104d88:	e0bffe17 	ldw	r2,-8(fp)
81104d8c:	1007883a 	mov	r3,r2
81104d90:	e0bfff17 	ldw	r2,-4(fp)
81104d94:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104d98:	e0bffe17 	ldw	r2,-8(fp)
81104d9c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81104da0:	1007883a 	mov	r3,r2
81104da4:	e0bfff17 	ldw	r2,-4(fp)
81104da8:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104dac:	00800044 	movi	r2,1
81104db0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104db4:	e0bffd17 	ldw	r2,-12(fp)
}
81104db8:	e037883a 	mov	sp,fp
81104dbc:	dfc00117 	ldw	ra,4(sp)
81104dc0:	df000017 	ldw	fp,0(sp)
81104dc4:	dec00204 	addi	sp,sp,8
81104dc8:	f800283a 	ret

81104dcc <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81104dcc:	defffb04 	addi	sp,sp,-20
81104dd0:	de00012e 	bgeu	sp,et,81104dd8 <bDpktSetPixelDelay+0xc>
81104dd4:	003b68fa 	trap	3
81104dd8:	dfc00415 	stw	ra,16(sp)
81104ddc:	df000315 	stw	fp,12(sp)
81104de0:	df000304 	addi	fp,sp,12
81104de4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104de8:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81104dec:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104df0:	e0bfff17 	ldw	r2,-4(fp)
81104df4:	10004426 	beq	r2,zero,81104f08 <bDpktSetPixelDelay+0x13c>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104df8:	e0bfff17 	ldw	r2,-4(fp)
81104dfc:	10800017 	ldw	r2,0(r2)
81104e00:	01400384 	movi	r5,14
81104e04:	1009883a 	mov	r4,r2
81104e08:	11052080 	call	81105208 <uliDpktReadReg>
81104e0c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104e10:	e0bffe17 	ldw	r2,-8(fp)
81104e14:	10bfffec 	andhi	r2,r2,65535
81104e18:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104e1c:	e0bfff17 	ldw	r2,-4(fp)
81104e20:	1080068b 	ldhu	r2,26(r2)
81104e24:	10ffffcc 	andi	r3,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104e28:	e0bffe17 	ldw	r2,-8(fp)
81104e2c:	1884b03a 	or	r2,r3,r2
81104e30:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104e34:	e0bfff17 	ldw	r2,-4(fp)
81104e38:	10800017 	ldw	r2,0(r2)
81104e3c:	e0fffe17 	ldw	r3,-8(fp)
81104e40:	180d883a 	mov	r6,r3
81104e44:	01400384 	movi	r5,14
81104e48:	1009883a 	mov	r4,r2
81104e4c:	11051b40 	call	811051b4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104e50:	e0bfff17 	ldw	r2,-4(fp)
81104e54:	10800017 	ldw	r2,0(r2)
81104e58:	014003c4 	movi	r5,15
81104e5c:	1009883a 	mov	r4,r2
81104e60:	11052080 	call	81105208 <uliDpktReadReg>
81104e64:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104e68:	e0bffe17 	ldw	r2,-8(fp)
81104e6c:	10bfffec 	andhi	r2,r2,65535
81104e70:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104e74:	e0bfff17 	ldw	r2,-4(fp)
81104e78:	1080070b 	ldhu	r2,28(r2)
81104e7c:	10ffffcc 	andi	r3,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104e80:	e0bffe17 	ldw	r2,-8(fp)
81104e84:	1884b03a 	or	r2,r3,r2
81104e88:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104e8c:	e0bfff17 	ldw	r2,-4(fp)
81104e90:	10800017 	ldw	r2,0(r2)
81104e94:	e0fffe17 	ldw	r3,-8(fp)
81104e98:	180d883a 	mov	r6,r3
81104e9c:	014003c4 	movi	r5,15
81104ea0:	1009883a 	mov	r4,r2
81104ea4:	11051b40 	call	811051b4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104ea8:	e0bfff17 	ldw	r2,-4(fp)
81104eac:	10800017 	ldw	r2,0(r2)
81104eb0:	01400404 	movi	r5,16
81104eb4:	1009883a 	mov	r4,r2
81104eb8:	11052080 	call	81105208 <uliDpktReadReg>
81104ebc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104ec0:	e0bffe17 	ldw	r2,-8(fp)
81104ec4:	10bfffec 	andhi	r2,r2,65535
81104ec8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104ecc:	e0bfff17 	ldw	r2,-4(fp)
81104ed0:	1080078b 	ldhu	r2,30(r2)
81104ed4:	10ffffcc 	andi	r3,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104ed8:	e0bffe17 	ldw	r2,-8(fp)
81104edc:	1884b03a 	or	r2,r3,r2
81104ee0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104ee4:	e0bfff17 	ldw	r2,-4(fp)
81104ee8:	10800017 	ldw	r2,0(r2)
81104eec:	e0fffe17 	ldw	r3,-8(fp)
81104ef0:	180d883a 	mov	r6,r3
81104ef4:	01400404 	movi	r5,16
81104ef8:	1009883a 	mov	r4,r2
81104efc:	11051b40 	call	811051b4 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104f00:	00800044 	movi	r2,1
81104f04:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104f08:	e0bffd17 	ldw	r2,-12(fp)
}
81104f0c:	e037883a 	mov	sp,fp
81104f10:	dfc00117 	ldw	ra,4(sp)
81104f14:	df000017 	ldw	fp,0(sp)
81104f18:	dec00204 	addi	sp,sp,8
81104f1c:	f800283a 	ret

81104f20 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104f20:	defffb04 	addi	sp,sp,-20
81104f24:	de00012e 	bgeu	sp,et,81104f2c <bDpktGetPixelDelay+0xc>
81104f28:	003b68fa 	trap	3
81104f2c:	dfc00415 	stw	ra,16(sp)
81104f30:	df000315 	stw	fp,12(sp)
81104f34:	df000304 	addi	fp,sp,12
81104f38:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104f3c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81104f40:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104f44:	e0bfff17 	ldw	r2,-4(fp)
81104f48:	10002026 	beq	r2,zero,81104fcc <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104f4c:	e0bfff17 	ldw	r2,-4(fp)
81104f50:	10800017 	ldw	r2,0(r2)
81104f54:	01400384 	movi	r5,14
81104f58:	1009883a 	mov	r4,r2
81104f5c:	11052080 	call	81105208 <uliDpktReadReg>
81104f60:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104f64:	e0bffe17 	ldw	r2,-8(fp)
81104f68:	1007883a 	mov	r3,r2
81104f6c:	e0bfff17 	ldw	r2,-4(fp)
81104f70:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104f74:	e0bfff17 	ldw	r2,-4(fp)
81104f78:	10800017 	ldw	r2,0(r2)
81104f7c:	014003c4 	movi	r5,15
81104f80:	1009883a 	mov	r4,r2
81104f84:	11052080 	call	81105208 <uliDpktReadReg>
81104f88:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104f8c:	e0bffe17 	ldw	r2,-8(fp)
81104f90:	1007883a 	mov	r3,r2
81104f94:	e0bfff17 	ldw	r2,-4(fp)
81104f98:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104f9c:	e0bfff17 	ldw	r2,-4(fp)
81104fa0:	10800017 	ldw	r2,0(r2)
81104fa4:	01400404 	movi	r5,16
81104fa8:	1009883a 	mov	r4,r2
81104fac:	11052080 	call	81105208 <uliDpktReadReg>
81104fb0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104fb4:	e0bffe17 	ldw	r2,-8(fp)
81104fb8:	1007883a 	mov	r3,r2
81104fbc:	e0bfff17 	ldw	r2,-4(fp)
81104fc0:	10c0078d 	sth	r3,30(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104fc4:	00800044 	movi	r2,1
81104fc8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104fcc:	e0bffd17 	ldw	r2,-12(fp)
}
81104fd0:	e037883a 	mov	sp,fp
81104fd4:	dfc00117 	ldw	ra,4(sp)
81104fd8:	df000017 	ldw	fp,0(sp)
81104fdc:	dec00204 	addi	sp,sp,8
81104fe0:	f800283a 	ret

81104fe4 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104fe4:	defff904 	addi	sp,sp,-28
81104fe8:	de00012e 	bgeu	sp,et,81104ff0 <bDpktInitCh+0xc>
81104fec:	003b68fa 	trap	3
81104ff0:	dfc00615 	stw	ra,24(sp)
81104ff4:	df000515 	stw	fp,20(sp)
81104ff8:	df000504 	addi	fp,sp,20
81104ffc:	e13ffe15 	stw	r4,-8(fp)
81105000:	2805883a 	mov	r2,r5
81105004:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105008:	e03ffb15 	stw	zero,-20(fp)
	bool bValidCh = FALSE;
8110500c:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
81105010:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81105014:	e0bffe17 	ldw	r2,-8(fp)
81105018:	10006026 	beq	r2,zero,8110519c <bDpktInitCh+0x1b8>

		switch (ucCommCh) {
8110501c:	e0bfff03 	ldbu	r2,-4(fp)
81105020:	10c00228 	cmpgeui	r3,r2,8
81105024:	1800461e 	bne	r3,zero,81105140 <bDpktInitCh+0x15c>
81105028:	100690ba 	slli	r3,r2,2
8110502c:	00a04434 	movhi	r2,33040
81105030:	10941004 	addi	r2,r2,20544
81105034:	1885883a 	add	r2,r3,r2
81105038:	10800017 	ldw	r2,0(r2)
8110503c:	1000683a 	jmp	r2
81105040:	81105060 	cmpeqi	r4,r16,16705
81105044:	8110507c 	xorhi	r4,r16,16705
81105048:	81105098 	cmpnei	r4,r16,16706
8110504c:	811050b4 	orhi	r4,r16,16706
81105050:	811050d0 	cmplti	r4,r16,16707
81105054:	811050ec 	andhi	r4,r16,16707
81105058:	81105108 	cmpgei	r4,r16,16708
8110505c:	81105124 	muli	r4,r16,16708
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81105060:	e0fffe17 	ldw	r3,-8(fp)
81105064:	00a04834 	movhi	r2,33056
81105068:	108b0004 	addi	r2,r2,11264
8110506c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81105070:	00800044 	movi	r2,1
81105074:	e0bffc15 	stw	r2,-16(fp)
			break;
81105078:	00003306 	br	81105148 <bDpktInitCh+0x164>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8110507c:	e0fffe17 	ldw	r3,-8(fp)
81105080:	00a04834 	movhi	r2,33056
81105084:	108a0004 	addi	r2,r2,10240
81105088:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110508c:	00800044 	movi	r2,1
81105090:	e0bffc15 	stw	r2,-16(fp)
			break;
81105094:	00002c06 	br	81105148 <bDpktInitCh+0x164>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81105098:	e0fffe17 	ldw	r3,-8(fp)
8110509c:	00a04834 	movhi	r2,33056
811050a0:	108b0004 	addi	r2,r2,11264
811050a4:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
811050a8:	00800044 	movi	r2,1
811050ac:	e0bffc15 	stw	r2,-16(fp)
			break;
811050b0:	00002506 	br	81105148 <bDpktInitCh+0x164>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811050b4:	e0fffe17 	ldw	r3,-8(fp)
811050b8:	00a04834 	movhi	r2,33056
811050bc:	108a0004 	addi	r2,r2,10240
811050c0:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
811050c4:	00800044 	movi	r2,1
811050c8:	e0bffc15 	stw	r2,-16(fp)
			break;
811050cc:	00001e06 	br	81105148 <bDpktInitCh+0x164>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811050d0:	e0fffe17 	ldw	r3,-8(fp)
811050d4:	00a04834 	movhi	r2,33056
811050d8:	108b0004 	addi	r2,r2,11264
811050dc:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
811050e0:	00800044 	movi	r2,1
811050e4:	e0bffc15 	stw	r2,-16(fp)
			break;
811050e8:	00001706 	br	81105148 <bDpktInitCh+0x164>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811050ec:	e0fffe17 	ldw	r3,-8(fp)
811050f0:	00a04834 	movhi	r2,33056
811050f4:	108a0004 	addi	r2,r2,10240
811050f8:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
811050fc:	00800044 	movi	r2,1
81105100:	e0bffc15 	stw	r2,-16(fp)
			break;
81105104:	00001006 	br	81105148 <bDpktInitCh+0x164>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81105108:	e0fffe17 	ldw	r3,-8(fp)
8110510c:	00a04834 	movhi	r2,33056
81105110:	108b0004 	addi	r2,r2,11264
81105114:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81105118:	00800044 	movi	r2,1
8110511c:	e0bffc15 	stw	r2,-16(fp)
			break;
81105120:	00000906 	br	81105148 <bDpktInitCh+0x164>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81105124:	e0fffe17 	ldw	r3,-8(fp)
81105128:	00a04834 	movhi	r2,33056
8110512c:	108a0004 	addi	r2,r2,10240
81105130:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81105134:	00800044 	movi	r2,1
81105138:	e0bffc15 	stw	r2,-16(fp)
			break;
8110513c:	00000206 	br	81105148 <bDpktInitCh+0x164>
		default:
			bValidCh = FALSE;
81105140:	e03ffc15 	stw	zero,-16(fp)
			break;
81105144:	0001883a 	nop
		}

		if (bValidCh) {
81105148:	e0bffc17 	ldw	r2,-16(fp)
8110514c:	10001326 	beq	r2,zero,8110519c <bDpktInitCh+0x1b8>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81105150:	e13ffe17 	ldw	r4,-8(fp)
81105154:	1104bb00 	call	81104bb0 <bDpktGetPacketConfig>
81105158:	1000021e 	bne	r2,zero,81105164 <bDpktInitCh+0x180>
				bInitFail = TRUE;
8110515c:	00800044 	movi	r2,1
81105160:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81105164:	e13ffe17 	ldw	r4,-8(fp)
81105168:	1104d080 	call	81104d08 <bDpktGetPacketHeader>
8110516c:	1000021e 	bne	r2,zero,81105178 <bDpktInitCh+0x194>
				bInitFail = TRUE;
81105170:	00800044 	movi	r2,1
81105174:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81105178:	e13ffe17 	ldw	r4,-8(fp)
8110517c:	1104f200 	call	81104f20 <bDpktGetPixelDelay>
81105180:	1000021e 	bne	r2,zero,8110518c <bDpktInitCh+0x1a8>
				bInitFail = TRUE;
81105184:	00800044 	movi	r2,1
81105188:	e0bffd15 	stw	r2,-12(fp)
			}

			if (!bInitFail) {
8110518c:	e0bffd17 	ldw	r2,-12(fp)
81105190:	1000021e 	bne	r2,zero,8110519c <bDpktInitCh+0x1b8>
				bStatus = TRUE;
81105194:	00800044 	movi	r2,1
81105198:	e0bffb15 	stw	r2,-20(fp)
			}
		}
	}
	return bStatus;
8110519c:	e0bffb17 	ldw	r2,-20(fp)
}
811051a0:	e037883a 	mov	sp,fp
811051a4:	dfc00117 	ldw	ra,4(sp)
811051a8:	df000017 	ldw	fp,0(sp)
811051ac:	dec00204 	addi	sp,sp,8
811051b0:	f800283a 	ret

811051b4 <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811051b4:	defffc04 	addi	sp,sp,-16
811051b8:	de00012e 	bgeu	sp,et,811051c0 <vDpktWriteReg+0xc>
811051bc:	003b68fa 	trap	3
811051c0:	df000315 	stw	fp,12(sp)
811051c4:	df000304 	addi	fp,sp,12
811051c8:	e13ffd15 	stw	r4,-12(fp)
811051cc:	e17ffe15 	stw	r5,-8(fp)
811051d0:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811051d4:	e0bffe17 	ldw	r2,-8(fp)
811051d8:	1085883a 	add	r2,r2,r2
811051dc:	1085883a 	add	r2,r2,r2
811051e0:	1007883a 	mov	r3,r2
811051e4:	e0bffd17 	ldw	r2,-12(fp)
811051e8:	10c5883a 	add	r2,r2,r3
811051ec:	e0ffff17 	ldw	r3,-4(fp)
811051f0:	10c00015 	stw	r3,0(r2)
}
811051f4:	0001883a 	nop
811051f8:	e037883a 	mov	sp,fp
811051fc:	df000017 	ldw	fp,0(sp)
81105200:	dec00104 	addi	sp,sp,4
81105204:	f800283a 	ret

81105208 <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81105208:	defffc04 	addi	sp,sp,-16
8110520c:	de00012e 	bgeu	sp,et,81105214 <uliDpktReadReg+0xc>
81105210:	003b68fa 	trap	3
81105214:	df000315 	stw	fp,12(sp)
81105218:	df000304 	addi	fp,sp,12
8110521c:	e13ffe15 	stw	r4,-8(fp)
81105220:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81105224:	e0bfff17 	ldw	r2,-4(fp)
81105228:	1085883a 	add	r2,r2,r2
8110522c:	1085883a 	add	r2,r2,r2
81105230:	1007883a 	mov	r3,r2
81105234:	e0bffe17 	ldw	r2,-8(fp)
81105238:	10c5883a 	add	r2,r2,r3
8110523c:	10800017 	ldw	r2,0(r2)
81105240:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81105244:	e0bffd17 	ldw	r2,-12(fp)
}
81105248:	e037883a 	mov	sp,fp
8110524c:	df000017 	ldw	fp,0(sp)
81105250:	dec00104 	addi	sp,sp,4
81105254:	f800283a 	ret

81105258 <usiAdcPxDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * ADC Pixel Delay period in uliPeriodNs ns.
 */
alt_u16 usiAdcPxDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
81105258:	defffc04 	addi	sp,sp,-16
8110525c:	de00012e 	bgeu	sp,et,81105264 <usiAdcPxDelayCalcPeriodNs+0xc>
81105260:	003b68fa 	trap	3
81105264:	dfc00315 	stw	ra,12(sp)
81105268:	df000215 	stw	fp,8(sp)
8110526c:	df000204 	addi	fp,sp,8
81105270:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 10 = Delay[ns] * 1e-1
	 * AdcPxDelay = Delay[ns] * 1e-1
	 */

	alt_u16 usiAdcPxDelay;
	usiAdcPxDelay = (alt_u16) ((float) uliPeriodNs * 1e-1);
81105274:	e13fff17 	ldw	r4,-4(fp)
81105278:	1121aac0 	call	81121aac <__floatunsisf>
8110527c:	1007883a 	mov	r3,r2
81105280:	1809883a 	mov	r4,r3
81105284:	1122e080 	call	81122e08 <__extendsfdf2>
81105288:	1011883a 	mov	r8,r2
8110528c:	1813883a 	mov	r9,r3
81105290:	01a666b4 	movhi	r6,39322
81105294:	31a66684 	addi	r6,r6,-26214
81105298:	01cfeeb4 	movhi	r7,16314
8110529c:	39e66644 	addi	r7,r7,-26215
811052a0:	4009883a 	mov	r4,r8
811052a4:	480b883a 	mov	r5,r9
811052a8:	1121c800 	call	81121c80 <__muldf3>
811052ac:	1009883a 	mov	r4,r2
811052b0:	180b883a 	mov	r5,r3
811052b4:	2005883a 	mov	r2,r4
811052b8:	2807883a 	mov	r3,r5
811052bc:	1009883a 	mov	r4,r2
811052c0:	180b883a 	mov	r5,r3
811052c4:	11210b80 	call	811210b8 <__fixunsdfsi>
811052c8:	e0bffe0d 	sth	r2,-8(fp)

	return usiAdcPxDelay;
811052cc:	e0bffe0b 	ldhu	r2,-8(fp)
}
811052d0:	e037883a 	mov	sp,fp
811052d4:	dfc00117 	ldw	ra,4(sp)
811052d8:	df000017 	ldw	fp,0(sp)
811052dc:	dec00204 	addi	sp,sp,8
811052e0:	f800283a 	ret

811052e4 <usiLineTrDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * Line Transfer Delay period in uliPeriodNs ns.
 */
alt_u16 usiLineTrDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
811052e4:	defffc04 	addi	sp,sp,-16
811052e8:	de00012e 	bgeu	sp,et,811052f0 <usiLineTrDelayCalcPeriodNs+0xc>
811052ec:	003b68fa 	trap	3
811052f0:	dfc00315 	stw	ra,12(sp)
811052f4:	df000215 	stw	fp,8(sp)
811052f8:	df000204 	addi	fp,sp,8
811052fc:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 100 = Delay[ns] * 1e-2
	 * LineTrDelay = Delay[ns] * 1e-2
	 */

	alt_u16 LineTrDelay;
	LineTrDelay = (alt_u16) ((float) uliPeriodNs * 1e-2);
81105300:	e13fff17 	ldw	r4,-4(fp)
81105304:	1121aac0 	call	81121aac <__floatunsisf>
81105308:	1007883a 	mov	r3,r2
8110530c:	1809883a 	mov	r4,r3
81105310:	1122e080 	call	81122e08 <__extendsfdf2>
81105314:	1011883a 	mov	r8,r2
81105318:	1813883a 	mov	r9,r3
8110531c:	0191ebb4 	movhi	r6,18350
81105320:	31851ec4 	addi	r6,r6,5243
81105324:	01cfe134 	movhi	r7,16260
81105328:	39deb844 	addi	r7,r7,31457
8110532c:	4009883a 	mov	r4,r8
81105330:	480b883a 	mov	r5,r9
81105334:	1121c800 	call	81121c80 <__muldf3>
81105338:	1009883a 	mov	r4,r2
8110533c:	180b883a 	mov	r5,r3
81105340:	2005883a 	mov	r2,r4
81105344:	2807883a 	mov	r3,r5
81105348:	1009883a 	mov	r4,r2
8110534c:	180b883a 	mov	r5,r3
81105350:	11210b80 	call	811210b8 <__fixunsdfsi>
81105354:	e0bffe0d 	sth	r2,-8(fp)

	return LineTrDelay;
81105358:	e0bffe0b 	ldhu	r2,-8(fp)
}
8110535c:	e037883a 	mov	sp,fp
81105360:	dfc00117 	ldw	ra,4(sp)
81105364:	df000017 	ldw	fp,0(sp)
81105368:	dec00204 	addi	sp,sp,8
8110536c:	f800283a 	ret

81105370 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81105370:	defffd04 	addi	sp,sp,-12
81105374:	de00012e 	bgeu	sp,et,8110537c <vFeebCh1HandleIrq+0xc>
81105378:	003b68fa 	trap	3
8110537c:	dfc00215 	stw	ra,8(sp)
81105380:	df000115 	stw	fp,4(sp)
81105384:	df000104 	addi	fp,sp,4
81105388:	e13fff15 	stw	r4,-4(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	//INT8U error_codel;
	//tQMask uiCmdtoSend;

	vFeebCh1IrqFlagClrBufferEmpty();
8110538c:	11055300 	call	81105530 <vFeebCh1IrqFlagClrBufferEmpty>
	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */



}
81105390:	0001883a 	nop
81105394:	e037883a 	mov	sp,fp
81105398:	dfc00117 	ldw	ra,4(sp)
8110539c:	df000017 	ldw	fp,0(sp)
811053a0:	dec00204 	addi	sp,sp,8
811053a4:	f800283a 	ret

811053a8 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
811053a8:	defffd04 	addi	sp,sp,-12
811053ac:	de00012e 	bgeu	sp,et,811053b4 <vFeebCh2HandleIrq+0xc>
811053b0:	003b68fa 	trap	3
811053b4:	dfc00215 	stw	ra,8(sp)
811053b8:	df000115 	stw	fp,4(sp)
811053bc:	df000104 	addi	fp,sp,4
811053c0:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;

	//INT8U error_codel;
	//tQMask uiCmdtoSend;

	vFeebCh2IrqFlagClrBufferEmpty();
811053c4:	11055740 	call	81105574 <vFeebCh2IrqFlagClrBufferEmpty>
	if ( error_codel != OS_ERR_NONE ) {
		vFailRequestDMAFromIRQ( 1 );
	}
*/

}
811053c8:	0001883a 	nop
811053cc:	e037883a 	mov	sp,fp
811053d0:	dfc00117 	ldw	ra,4(sp)
811053d4:	df000017 	ldw	fp,0(sp)
811053d8:	dec00204 	addi	sp,sp,8
811053dc:	f800283a 	ret

811053e0 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
811053e0:	defffd04 	addi	sp,sp,-12
811053e4:	de00012e 	bgeu	sp,et,811053ec <vFeebCh3HandleIrq+0xc>
811053e8:	003b68fa 	trap	3
811053ec:	dfc00215 	stw	ra,8(sp)
811053f0:	df000115 	stw	fp,4(sp)
811053f4:	df000104 	addi	fp,sp,4
811053f8:	e13fff15 	stw	r4,-4(fp)
//	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 2 );
//	}

	vFeebCh3IrqFlagClrBufferEmpty();
811053fc:	11055b80 	call	811055b8 <vFeebCh3IrqFlagClrBufferEmpty>
}
81105400:	0001883a 	nop
81105404:	e037883a 	mov	sp,fp
81105408:	dfc00117 	ldw	ra,4(sp)
8110540c:	df000017 	ldw	fp,0(sp)
81105410:	dec00204 	addi	sp,sp,8
81105414:	f800283a 	ret

81105418 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
81105418:	defffd04 	addi	sp,sp,-12
8110541c:	de00012e 	bgeu	sp,et,81105424 <vFeebCh4HandleIrq+0xc>
81105420:	003b68fa 	trap	3
81105424:	dfc00215 	stw	ra,8(sp)
81105428:	df000115 	stw	fp,4(sp)
8110542c:	df000104 	addi	fp,sp,4
81105430:	e13fff15 	stw	r4,-4(fp)
//	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 3 );
//	}

	vFeebCh4IrqFlagClrBufferEmpty();
81105434:	11055fc0 	call	811055fc <vFeebCh4IrqFlagClrBufferEmpty>
}
81105438:	0001883a 	nop
8110543c:	e037883a 	mov	sp,fp
81105440:	dfc00117 	ldw	ra,4(sp)
81105444:	df000017 	ldw	fp,0(sp)
81105448:	dec00204 	addi	sp,sp,8
8110544c:	f800283a 	ret

81105450 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81105450:	defffd04 	addi	sp,sp,-12
81105454:	de00012e 	bgeu	sp,et,8110545c <vFeebCh5HandleIrq+0xc>
81105458:	003b68fa 	trap	3
8110545c:	dfc00215 	stw	ra,8(sp)
81105460:	df000115 	stw	fp,4(sp)
81105464:	df000104 	addi	fp,sp,4
81105468:	e13fff15 	stw	r4,-4(fp)
//	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 4 );
//	}

	vFeebCh5IrqFlagClrBufferEmpty();
8110546c:	11056400 	call	81105640 <vFeebCh5IrqFlagClrBufferEmpty>
}
81105470:	0001883a 	nop
81105474:	e037883a 	mov	sp,fp
81105478:	dfc00117 	ldw	ra,4(sp)
8110547c:	df000017 	ldw	fp,0(sp)
81105480:	dec00204 	addi	sp,sp,8
81105484:	f800283a 	ret

81105488 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
81105488:	defffd04 	addi	sp,sp,-12
8110548c:	de00012e 	bgeu	sp,et,81105494 <vFeebCh6HandleIrq+0xc>
81105490:	003b68fa 	trap	3
81105494:	dfc00215 	stw	ra,8(sp)
81105498:	df000115 	stw	fp,4(sp)
8110549c:	df000104 	addi	fp,sp,4
811054a0:	e13fff15 	stw	r4,-4(fp)
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 5 );
//	}


	vFeebCh6IrqFlagClrBufferEmpty();
811054a4:	11056840 	call	81105684 <vFeebCh6IrqFlagClrBufferEmpty>
}
811054a8:	0001883a 	nop
811054ac:	e037883a 	mov	sp,fp
811054b0:	dfc00117 	ldw	ra,4(sp)
811054b4:	df000017 	ldw	fp,0(sp)
811054b8:	dec00204 	addi	sp,sp,8
811054bc:	f800283a 	ret

811054c0 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
811054c0:	defffd04 	addi	sp,sp,-12
811054c4:	de00012e 	bgeu	sp,et,811054cc <vFeebCh7HandleIrq+0xc>
811054c8:	003b68fa 	trap	3
811054cc:	dfc00215 	stw	ra,8(sp)
811054d0:	df000115 	stw	fp,4(sp)
811054d4:	df000104 	addi	fp,sp,4
811054d8:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;


	vFeebCh7IrqFlagClrBufferEmpty();
811054dc:	11056c80 	call	811056c8 <vFeebCh7IrqFlagClrBufferEmpty>
}
811054e0:	0001883a 	nop
811054e4:	e037883a 	mov	sp,fp
811054e8:	dfc00117 	ldw	ra,4(sp)
811054ec:	df000017 	ldw	fp,0(sp)
811054f0:	dec00204 	addi	sp,sp,8
811054f4:	f800283a 	ret

811054f8 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
811054f8:	defffd04 	addi	sp,sp,-12
811054fc:	de00012e 	bgeu	sp,et,81105504 <vFeebCh8HandleIrq+0xc>
81105500:	003b68fa 	trap	3
81105504:	dfc00215 	stw	ra,8(sp)
81105508:	df000115 	stw	fp,4(sp)
8110550c:	df000104 	addi	fp,sp,4
81105510:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;


	vFeebCh8IrqFlagClrBufferEmpty();
81105514:	110570c0 	call	8110570c <vFeebCh8IrqFlagClrBufferEmpty>
}
81105518:	0001883a 	nop
8110551c:	e037883a 	mov	sp,fp
81105520:	dfc00117 	ldw	ra,4(sp)
81105524:	df000017 	ldw	fp,0(sp)
81105528:	dec00204 	addi	sp,sp,8
8110552c:	f800283a 	ret

81105530 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81105530:	defffe04 	addi	sp,sp,-8
81105534:	de00012e 	bgeu	sp,et,8110553c <vFeebCh1IrqFlagClrBufferEmpty+0xc>
81105538:	003b68fa 	trap	3
8110553c:	dfc00115 	stw	ra,4(sp)
81105540:	df000015 	stw	fp,0(sp)
81105544:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105548:	01804004 	movi	r6,256
8110554c:	014004c4 	movi	r5,19
81105550:	01204834 	movhi	r4,33056
81105554:	210b0004 	addi	r4,r4,11264
81105558:	110700c0 	call	8110700c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110555c:	0001883a 	nop
81105560:	e037883a 	mov	sp,fp
81105564:	dfc00117 	ldw	ra,4(sp)
81105568:	df000017 	ldw	fp,0(sp)
8110556c:	dec00204 	addi	sp,sp,8
81105570:	f800283a 	ret

81105574 <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
81105574:	defffe04 	addi	sp,sp,-8
81105578:	de00012e 	bgeu	sp,et,81105580 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
8110557c:	003b68fa 	trap	3
81105580:	dfc00115 	stw	ra,4(sp)
81105584:	df000015 	stw	fp,0(sp)
81105588:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110558c:	01804004 	movi	r6,256
81105590:	014004c4 	movi	r5,19
81105594:	01204834 	movhi	r4,33056
81105598:	210a0004 	addi	r4,r4,10240
8110559c:	110700c0 	call	8110700c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811055a0:	0001883a 	nop
811055a4:	e037883a 	mov	sp,fp
811055a8:	dfc00117 	ldw	ra,4(sp)
811055ac:	df000017 	ldw	fp,0(sp)
811055b0:	dec00204 	addi	sp,sp,8
811055b4:	f800283a 	ret

811055b8 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
811055b8:	defffe04 	addi	sp,sp,-8
811055bc:	de00012e 	bgeu	sp,et,811055c4 <vFeebCh3IrqFlagClrBufferEmpty+0xc>
811055c0:	003b68fa 	trap	3
811055c4:	dfc00115 	stw	ra,4(sp)
811055c8:	df000015 	stw	fp,0(sp)
811055cc:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811055d0:	01804004 	movi	r6,256
811055d4:	014004c4 	movi	r5,19
811055d8:	01204834 	movhi	r4,33056
811055dc:	210b0004 	addi	r4,r4,11264
811055e0:	110700c0 	call	8110700c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811055e4:	0001883a 	nop
811055e8:	e037883a 	mov	sp,fp
811055ec:	dfc00117 	ldw	ra,4(sp)
811055f0:	df000017 	ldw	fp,0(sp)
811055f4:	dec00204 	addi	sp,sp,8
811055f8:	f800283a 	ret

811055fc <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
811055fc:	defffe04 	addi	sp,sp,-8
81105600:	de00012e 	bgeu	sp,et,81105608 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
81105604:	003b68fa 	trap	3
81105608:	dfc00115 	stw	ra,4(sp)
8110560c:	df000015 	stw	fp,0(sp)
81105610:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105614:	01804004 	movi	r6,256
81105618:	014004c4 	movi	r5,19
8110561c:	01204834 	movhi	r4,33056
81105620:	210a0004 	addi	r4,r4,10240
81105624:	110700c0 	call	8110700c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105628:	0001883a 	nop
8110562c:	e037883a 	mov	sp,fp
81105630:	dfc00117 	ldw	ra,4(sp)
81105634:	df000017 	ldw	fp,0(sp)
81105638:	dec00204 	addi	sp,sp,8
8110563c:	f800283a 	ret

81105640 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
81105640:	defffe04 	addi	sp,sp,-8
81105644:	de00012e 	bgeu	sp,et,8110564c <vFeebCh5IrqFlagClrBufferEmpty+0xc>
81105648:	003b68fa 	trap	3
8110564c:	dfc00115 	stw	ra,4(sp)
81105650:	df000015 	stw	fp,0(sp)
81105654:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105658:	01804004 	movi	r6,256
8110565c:	014004c4 	movi	r5,19
81105660:	01204834 	movhi	r4,33056
81105664:	210b0004 	addi	r4,r4,11264
81105668:	110700c0 	call	8110700c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110566c:	0001883a 	nop
81105670:	e037883a 	mov	sp,fp
81105674:	dfc00117 	ldw	ra,4(sp)
81105678:	df000017 	ldw	fp,0(sp)
8110567c:	dec00204 	addi	sp,sp,8
81105680:	f800283a 	ret

81105684 <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
81105684:	defffe04 	addi	sp,sp,-8
81105688:	de00012e 	bgeu	sp,et,81105690 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
8110568c:	003b68fa 	trap	3
81105690:	dfc00115 	stw	ra,4(sp)
81105694:	df000015 	stw	fp,0(sp)
81105698:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
8110569c:	01804004 	movi	r6,256
811056a0:	014004c4 	movi	r5,19
811056a4:	01204834 	movhi	r4,33056
811056a8:	210a0004 	addi	r4,r4,10240
811056ac:	110700c0 	call	8110700c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811056b0:	0001883a 	nop
811056b4:	e037883a 	mov	sp,fp
811056b8:	dfc00117 	ldw	ra,4(sp)
811056bc:	df000017 	ldw	fp,0(sp)
811056c0:	dec00204 	addi	sp,sp,8
811056c4:	f800283a 	ret

811056c8 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
811056c8:	defffe04 	addi	sp,sp,-8
811056cc:	de00012e 	bgeu	sp,et,811056d4 <vFeebCh7IrqFlagClrBufferEmpty+0xc>
811056d0:	003b68fa 	trap	3
811056d4:	dfc00115 	stw	ra,4(sp)
811056d8:	df000015 	stw	fp,0(sp)
811056dc:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811056e0:	01804004 	movi	r6,256
811056e4:	014004c4 	movi	r5,19
811056e8:	01204834 	movhi	r4,33056
811056ec:	210b0004 	addi	r4,r4,11264
811056f0:	110700c0 	call	8110700c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811056f4:	0001883a 	nop
811056f8:	e037883a 	mov	sp,fp
811056fc:	dfc00117 	ldw	ra,4(sp)
81105700:	df000017 	ldw	fp,0(sp)
81105704:	dec00204 	addi	sp,sp,8
81105708:	f800283a 	ret

8110570c <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
8110570c:	defffe04 	addi	sp,sp,-8
81105710:	de00012e 	bgeu	sp,et,81105718 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
81105714:	003b68fa 	trap	3
81105718:	dfc00115 	stw	ra,4(sp)
8110571c:	df000015 	stw	fp,0(sp)
81105720:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105724:	01804004 	movi	r6,256
81105728:	014004c4 	movi	r5,19
8110572c:	01204834 	movhi	r4,33056
81105730:	210a0004 	addi	r4,r4,10240
81105734:	110700c0 	call	8110700c <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105738:	0001883a 	nop
8110573c:	e037883a 	mov	sp,fp
81105740:	dfc00117 	ldw	ra,4(sp)
81105744:	df000017 	ldw	fp,0(sp)
81105748:	dec00204 	addi	sp,sp,8
8110574c:	f800283a 	ret

81105750 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
81105750:	defffd04 	addi	sp,sp,-12
81105754:	de00012e 	bgeu	sp,et,8110575c <bFeebCh1IrqFlagBufferEmpty+0xc>
81105758:	003b68fa 	trap	3
8110575c:	dfc00215 	stw	ra,8(sp)
81105760:	df000115 	stw	fp,4(sp)
81105764:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105768:	01400484 	movi	r5,18
8110576c:	01204834 	movhi	r4,33056
81105770:	210b0004 	addi	r4,r4,11264
81105774:	11070600 	call	81107060 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105778:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
8110577c:	10000326 	beq	r2,zero,8110578c <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105780:	00800044 	movi	r2,1
81105784:	e0bfff15 	stw	r2,-4(fp)
81105788:	00000106 	br	81105790 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110578c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105790:	e0bfff17 	ldw	r2,-4(fp)
}
81105794:	e037883a 	mov	sp,fp
81105798:	dfc00117 	ldw	ra,4(sp)
8110579c:	df000017 	ldw	fp,0(sp)
811057a0:	dec00204 	addi	sp,sp,8
811057a4:	f800283a 	ret

811057a8 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
811057a8:	defffd04 	addi	sp,sp,-12
811057ac:	de00012e 	bgeu	sp,et,811057b4 <bFeebCh2IrqFlagBufferEmpty+0xc>
811057b0:	003b68fa 	trap	3
811057b4:	dfc00215 	stw	ra,8(sp)
811057b8:	df000115 	stw	fp,4(sp)
811057bc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811057c0:	01400484 	movi	r5,18
811057c4:	01204834 	movhi	r4,33056
811057c8:	210a0004 	addi	r4,r4,10240
811057cc:	11070600 	call	81107060 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811057d0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811057d4:	10000326 	beq	r2,zero,811057e4 <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811057d8:	00800044 	movi	r2,1
811057dc:	e0bfff15 	stw	r2,-4(fp)
811057e0:	00000106 	br	811057e8 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811057e4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811057e8:	e0bfff17 	ldw	r2,-4(fp)
}
811057ec:	e037883a 	mov	sp,fp
811057f0:	dfc00117 	ldw	ra,4(sp)
811057f4:	df000017 	ldw	fp,0(sp)
811057f8:	dec00204 	addi	sp,sp,8
811057fc:	f800283a 	ret

81105800 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
81105800:	defffd04 	addi	sp,sp,-12
81105804:	de00012e 	bgeu	sp,et,8110580c <bFeebCh3IrqFlagBufferEmpty+0xc>
81105808:	003b68fa 	trap	3
8110580c:	dfc00215 	stw	ra,8(sp)
81105810:	df000115 	stw	fp,4(sp)
81105814:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105818:	01400484 	movi	r5,18
8110581c:	01204834 	movhi	r4,33056
81105820:	210b0004 	addi	r4,r4,11264
81105824:	11070600 	call	81107060 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105828:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110582c:	10000326 	beq	r2,zero,8110583c <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105830:	00800044 	movi	r2,1
81105834:	e0bfff15 	stw	r2,-4(fp)
81105838:	00000106 	br	81105840 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110583c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105840:	e0bfff17 	ldw	r2,-4(fp)
}
81105844:	e037883a 	mov	sp,fp
81105848:	dfc00117 	ldw	ra,4(sp)
8110584c:	df000017 	ldw	fp,0(sp)
81105850:	dec00204 	addi	sp,sp,8
81105854:	f800283a 	ret

81105858 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81105858:	defffd04 	addi	sp,sp,-12
8110585c:	de00012e 	bgeu	sp,et,81105864 <bFeebCh4IrqFlagBufferEmpty+0xc>
81105860:	003b68fa 	trap	3
81105864:	dfc00215 	stw	ra,8(sp)
81105868:	df000115 	stw	fp,4(sp)
8110586c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105870:	01400484 	movi	r5,18
81105874:	01204834 	movhi	r4,33056
81105878:	210a0004 	addi	r4,r4,10240
8110587c:	11070600 	call	81107060 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105880:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105884:	10000326 	beq	r2,zero,81105894 <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105888:	00800044 	movi	r2,1
8110588c:	e0bfff15 	stw	r2,-4(fp)
81105890:	00000106 	br	81105898 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105894:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105898:	e0bfff17 	ldw	r2,-4(fp)
}
8110589c:	e037883a 	mov	sp,fp
811058a0:	dfc00117 	ldw	ra,4(sp)
811058a4:	df000017 	ldw	fp,0(sp)
811058a8:	dec00204 	addi	sp,sp,8
811058ac:	f800283a 	ret

811058b0 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
811058b0:	defffd04 	addi	sp,sp,-12
811058b4:	de00012e 	bgeu	sp,et,811058bc <bFeebCh5IrqFlagBufferEmpty+0xc>
811058b8:	003b68fa 	trap	3
811058bc:	dfc00215 	stw	ra,8(sp)
811058c0:	df000115 	stw	fp,4(sp)
811058c4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811058c8:	01400484 	movi	r5,18
811058cc:	01204834 	movhi	r4,33056
811058d0:	210b0004 	addi	r4,r4,11264
811058d4:	11070600 	call	81107060 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811058d8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811058dc:	10000326 	beq	r2,zero,811058ec <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811058e0:	00800044 	movi	r2,1
811058e4:	e0bfff15 	stw	r2,-4(fp)
811058e8:	00000106 	br	811058f0 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811058ec:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811058f0:	e0bfff17 	ldw	r2,-4(fp)
}
811058f4:	e037883a 	mov	sp,fp
811058f8:	dfc00117 	ldw	ra,4(sp)
811058fc:	df000017 	ldw	fp,0(sp)
81105900:	dec00204 	addi	sp,sp,8
81105904:	f800283a 	ret

81105908 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81105908:	defffd04 	addi	sp,sp,-12
8110590c:	de00012e 	bgeu	sp,et,81105914 <bFeebCh6IrqFlagBufferEmpty+0xc>
81105910:	003b68fa 	trap	3
81105914:	dfc00215 	stw	ra,8(sp)
81105918:	df000115 	stw	fp,4(sp)
8110591c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105920:	01400484 	movi	r5,18
81105924:	01204834 	movhi	r4,33056
81105928:	210a0004 	addi	r4,r4,10240
8110592c:	11070600 	call	81107060 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105930:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105934:	10000326 	beq	r2,zero,81105944 <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105938:	00800044 	movi	r2,1
8110593c:	e0bfff15 	stw	r2,-4(fp)
81105940:	00000106 	br	81105948 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105944:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105948:	e0bfff17 	ldw	r2,-4(fp)
}
8110594c:	e037883a 	mov	sp,fp
81105950:	dfc00117 	ldw	ra,4(sp)
81105954:	df000017 	ldw	fp,0(sp)
81105958:	dec00204 	addi	sp,sp,8
8110595c:	f800283a 	ret

81105960 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81105960:	defffd04 	addi	sp,sp,-12
81105964:	de00012e 	bgeu	sp,et,8110596c <bFeebCh7IrqFlagBufferEmpty+0xc>
81105968:	003b68fa 	trap	3
8110596c:	dfc00215 	stw	ra,8(sp)
81105970:	df000115 	stw	fp,4(sp)
81105974:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105978:	01400484 	movi	r5,18
8110597c:	01204834 	movhi	r4,33056
81105980:	210b0004 	addi	r4,r4,11264
81105984:	11070600 	call	81107060 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105988:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110598c:	10000326 	beq	r2,zero,8110599c <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105990:	00800044 	movi	r2,1
81105994:	e0bfff15 	stw	r2,-4(fp)
81105998:	00000106 	br	811059a0 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110599c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811059a0:	e0bfff17 	ldw	r2,-4(fp)
}
811059a4:	e037883a 	mov	sp,fp
811059a8:	dfc00117 	ldw	ra,4(sp)
811059ac:	df000017 	ldw	fp,0(sp)
811059b0:	dec00204 	addi	sp,sp,8
811059b4:	f800283a 	ret

811059b8 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
811059b8:	defffd04 	addi	sp,sp,-12
811059bc:	de00012e 	bgeu	sp,et,811059c4 <bFeebCh8IrqFlagBufferEmpty+0xc>
811059c0:	003b68fa 	trap	3
811059c4:	dfc00215 	stw	ra,8(sp)
811059c8:	df000115 	stw	fp,4(sp)
811059cc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811059d0:	01400484 	movi	r5,18
811059d4:	01204834 	movhi	r4,33056
811059d8:	210a0004 	addi	r4,r4,10240
811059dc:	11070600 	call	81107060 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811059e0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811059e4:	10000326 	beq	r2,zero,811059f4 <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811059e8:	00800044 	movi	r2,1
811059ec:	e0bfff15 	stw	r2,-4(fp)
811059f0:	00000106 	br	811059f8 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811059f4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811059f8:	e0bfff17 	ldw	r2,-4(fp)
}
811059fc:	e037883a 	mov	sp,fp
81105a00:	dfc00117 	ldw	ra,4(sp)
81105a04:	df000017 	ldw	fp,0(sp)
81105a08:	dec00204 	addi	sp,sp,8
81105a0c:	f800283a 	ret

81105a10 <bFeebCh1SetBufferSize>:

bool bFeebCh1SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105a10:	defffa04 	addi	sp,sp,-24
81105a14:	de00012e 	bgeu	sp,et,81105a1c <bFeebCh1SetBufferSize+0xc>
81105a18:	003b68fa 	trap	3
81105a1c:	dfc00515 	stw	ra,20(sp)
81105a20:	df000415 	stw	fp,16(sp)
81105a24:	df000404 	addi	fp,sp,16
81105a28:	2007883a 	mov	r3,r4
81105a2c:	2805883a 	mov	r2,r5
81105a30:	e0fffe05 	stb	r3,-8(fp)
81105a34:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105a38:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81105a3c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105a40:	e0bffe03 	ldbu	r2,-8(fp)
81105a44:	10002426 	beq	r2,zero,81105ad8 <bFeebCh1SetBufferSize+0xc8>
81105a48:	e0bffe03 	ldbu	r2,-8(fp)
81105a4c:	10800468 	cmpgeui	r2,r2,17
81105a50:	1000211e 	bne	r2,zero,81105ad8 <bFeebCh1SetBufferSize+0xc8>
		switch (ucBufferSide) {
81105a54:	e0bfff03 	ldbu	r2,-4(fp)
81105a58:	10000326 	beq	r2,zero,81105a68 <bFeebCh1SetBufferSize+0x58>
81105a5c:	10800060 	cmpeqi	r2,r2,1
81105a60:	10000e1e 	bne	r2,zero,81105a9c <bFeebCh1SetBufferSize+0x8c>
81105a64:	00001a06 	br	81105ad0 <bFeebCh1SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a68:	e0bffe03 	ldbu	r2,-8(fp)
81105a6c:	10bfffc4 	addi	r2,r2,-1
81105a70:	108003cc 	andi	r2,r2,15
81105a74:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105a78:	e0bffd17 	ldw	r2,-12(fp)
81105a7c:	100d883a 	mov	r6,r2
81105a80:	01400544 	movi	r5,21
81105a84:	01204834 	movhi	r4,33056
81105a88:	210b0004 	addi	r4,r4,11264
81105a8c:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105a90:	00800044 	movi	r2,1
81105a94:	e0bffc15 	stw	r2,-16(fp)
			break;
81105a98:	00000f06 	br	81105ad8 <bFeebCh1SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a9c:	e0bffe03 	ldbu	r2,-8(fp)
81105aa0:	10bfffc4 	addi	r2,r2,-1
81105aa4:	108003cc 	andi	r2,r2,15
81105aa8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105aac:	e0bffd17 	ldw	r2,-12(fp)
81105ab0:	100d883a 	mov	r6,r2
81105ab4:	01400504 	movi	r5,20
81105ab8:	01204834 	movhi	r4,33056
81105abc:	210b0004 	addi	r4,r4,11264
81105ac0:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105ac4:	00800044 	movi	r2,1
81105ac8:	e0bffc15 	stw	r2,-16(fp)
			break;
81105acc:	00000206 	br	81105ad8 <bFeebCh1SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81105ad0:	e03ffc15 	stw	zero,-16(fp)
			break;
81105ad4:	0001883a 	nop
		}
	}

	return bStatus;
81105ad8:	e0bffc17 	ldw	r2,-16(fp)
}
81105adc:	e037883a 	mov	sp,fp
81105ae0:	dfc00117 	ldw	ra,4(sp)
81105ae4:	df000017 	ldw	fp,0(sp)
81105ae8:	dec00204 	addi	sp,sp,8
81105aec:	f800283a 	ret

81105af0 <bFeebCh2SetBufferSize>:

bool bFeebCh2SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105af0:	defffa04 	addi	sp,sp,-24
81105af4:	de00012e 	bgeu	sp,et,81105afc <bFeebCh2SetBufferSize+0xc>
81105af8:	003b68fa 	trap	3
81105afc:	dfc00515 	stw	ra,20(sp)
81105b00:	df000415 	stw	fp,16(sp)
81105b04:	df000404 	addi	fp,sp,16
81105b08:	2007883a 	mov	r3,r4
81105b0c:	2805883a 	mov	r2,r5
81105b10:	e0fffe05 	stb	r3,-8(fp)
81105b14:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105b18:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81105b1c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105b20:	e0bffe03 	ldbu	r2,-8(fp)
81105b24:	10002426 	beq	r2,zero,81105bb8 <bFeebCh2SetBufferSize+0xc8>
81105b28:	e0bffe03 	ldbu	r2,-8(fp)
81105b2c:	10800468 	cmpgeui	r2,r2,17
81105b30:	1000211e 	bne	r2,zero,81105bb8 <bFeebCh2SetBufferSize+0xc8>
		switch (ucBufferSide) {
81105b34:	e0bfff03 	ldbu	r2,-4(fp)
81105b38:	10000326 	beq	r2,zero,81105b48 <bFeebCh2SetBufferSize+0x58>
81105b3c:	10800060 	cmpeqi	r2,r2,1
81105b40:	10000e1e 	bne	r2,zero,81105b7c <bFeebCh2SetBufferSize+0x8c>
81105b44:	00001a06 	br	81105bb0 <bFeebCh2SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105b48:	e0bffe03 	ldbu	r2,-8(fp)
81105b4c:	10bfffc4 	addi	r2,r2,-1
81105b50:	108003cc 	andi	r2,r2,15
81105b54:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105b58:	e0bffd17 	ldw	r2,-12(fp)
81105b5c:	100d883a 	mov	r6,r2
81105b60:	01400544 	movi	r5,21
81105b64:	01204834 	movhi	r4,33056
81105b68:	210a0004 	addi	r4,r4,10240
81105b6c:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105b70:	00800044 	movi	r2,1
81105b74:	e0bffc15 	stw	r2,-16(fp)
			break;
81105b78:	00000f06 	br	81105bb8 <bFeebCh2SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105b7c:	e0bffe03 	ldbu	r2,-8(fp)
81105b80:	10bfffc4 	addi	r2,r2,-1
81105b84:	108003cc 	andi	r2,r2,15
81105b88:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105b8c:	e0bffd17 	ldw	r2,-12(fp)
81105b90:	100d883a 	mov	r6,r2
81105b94:	01400504 	movi	r5,20
81105b98:	01204834 	movhi	r4,33056
81105b9c:	210a0004 	addi	r4,r4,10240
81105ba0:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105ba4:	00800044 	movi	r2,1
81105ba8:	e0bffc15 	stw	r2,-16(fp)
			break;
81105bac:	00000206 	br	81105bb8 <bFeebCh2SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81105bb0:	e03ffc15 	stw	zero,-16(fp)
			break;
81105bb4:	0001883a 	nop
		}
	}

	return bStatus;
81105bb8:	e0bffc17 	ldw	r2,-16(fp)
}
81105bbc:	e037883a 	mov	sp,fp
81105bc0:	dfc00117 	ldw	ra,4(sp)
81105bc4:	df000017 	ldw	fp,0(sp)
81105bc8:	dec00204 	addi	sp,sp,8
81105bcc:	f800283a 	ret

81105bd0 <bFeebCh3SetBufferSize>:

bool bFeebCh3SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105bd0:	defffa04 	addi	sp,sp,-24
81105bd4:	de00012e 	bgeu	sp,et,81105bdc <bFeebCh3SetBufferSize+0xc>
81105bd8:	003b68fa 	trap	3
81105bdc:	dfc00515 	stw	ra,20(sp)
81105be0:	df000415 	stw	fp,16(sp)
81105be4:	df000404 	addi	fp,sp,16
81105be8:	2007883a 	mov	r3,r4
81105bec:	2805883a 	mov	r2,r5
81105bf0:	e0fffe05 	stb	r3,-8(fp)
81105bf4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105bf8:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81105bfc:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105c00:	e0bffe03 	ldbu	r2,-8(fp)
81105c04:	10002426 	beq	r2,zero,81105c98 <bFeebCh3SetBufferSize+0xc8>
81105c08:	e0bffe03 	ldbu	r2,-8(fp)
81105c0c:	10800468 	cmpgeui	r2,r2,17
81105c10:	1000211e 	bne	r2,zero,81105c98 <bFeebCh3SetBufferSize+0xc8>
		switch (ucBufferSide) {
81105c14:	e0bfff03 	ldbu	r2,-4(fp)
81105c18:	10000326 	beq	r2,zero,81105c28 <bFeebCh3SetBufferSize+0x58>
81105c1c:	10800060 	cmpeqi	r2,r2,1
81105c20:	10000e1e 	bne	r2,zero,81105c5c <bFeebCh3SetBufferSize+0x8c>
81105c24:	00001a06 	br	81105c90 <bFeebCh3SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105c28:	e0bffe03 	ldbu	r2,-8(fp)
81105c2c:	10bfffc4 	addi	r2,r2,-1
81105c30:	108003cc 	andi	r2,r2,15
81105c34:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105c38:	e0bffd17 	ldw	r2,-12(fp)
81105c3c:	100d883a 	mov	r6,r2
81105c40:	01400544 	movi	r5,21
81105c44:	01204834 	movhi	r4,33056
81105c48:	210b0004 	addi	r4,r4,11264
81105c4c:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105c50:	00800044 	movi	r2,1
81105c54:	e0bffc15 	stw	r2,-16(fp)
			break;
81105c58:	00000f06 	br	81105c98 <bFeebCh3SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105c5c:	e0bffe03 	ldbu	r2,-8(fp)
81105c60:	10bfffc4 	addi	r2,r2,-1
81105c64:	108003cc 	andi	r2,r2,15
81105c68:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105c6c:	e0bffd17 	ldw	r2,-12(fp)
81105c70:	100d883a 	mov	r6,r2
81105c74:	01400504 	movi	r5,20
81105c78:	01204834 	movhi	r4,33056
81105c7c:	210b0004 	addi	r4,r4,11264
81105c80:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105c84:	00800044 	movi	r2,1
81105c88:	e0bffc15 	stw	r2,-16(fp)
			break;
81105c8c:	00000206 	br	81105c98 <bFeebCh3SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81105c90:	e03ffc15 	stw	zero,-16(fp)
			break;
81105c94:	0001883a 	nop
		}
	}

	return bStatus;
81105c98:	e0bffc17 	ldw	r2,-16(fp)
}
81105c9c:	e037883a 	mov	sp,fp
81105ca0:	dfc00117 	ldw	ra,4(sp)
81105ca4:	df000017 	ldw	fp,0(sp)
81105ca8:	dec00204 	addi	sp,sp,8
81105cac:	f800283a 	ret

81105cb0 <bFeebCh4SetBufferSize>:

bool bFeebCh4SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105cb0:	defffa04 	addi	sp,sp,-24
81105cb4:	de00012e 	bgeu	sp,et,81105cbc <bFeebCh4SetBufferSize+0xc>
81105cb8:	003b68fa 	trap	3
81105cbc:	dfc00515 	stw	ra,20(sp)
81105cc0:	df000415 	stw	fp,16(sp)
81105cc4:	df000404 	addi	fp,sp,16
81105cc8:	2007883a 	mov	r3,r4
81105ccc:	2805883a 	mov	r2,r5
81105cd0:	e0fffe05 	stb	r3,-8(fp)
81105cd4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105cd8:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81105cdc:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105ce0:	e0bffe03 	ldbu	r2,-8(fp)
81105ce4:	10002426 	beq	r2,zero,81105d78 <bFeebCh4SetBufferSize+0xc8>
81105ce8:	e0bffe03 	ldbu	r2,-8(fp)
81105cec:	10800468 	cmpgeui	r2,r2,17
81105cf0:	1000211e 	bne	r2,zero,81105d78 <bFeebCh4SetBufferSize+0xc8>
		switch (ucBufferSide) {
81105cf4:	e0bfff03 	ldbu	r2,-4(fp)
81105cf8:	10000326 	beq	r2,zero,81105d08 <bFeebCh4SetBufferSize+0x58>
81105cfc:	10800060 	cmpeqi	r2,r2,1
81105d00:	10000e1e 	bne	r2,zero,81105d3c <bFeebCh4SetBufferSize+0x8c>
81105d04:	00001a06 	br	81105d70 <bFeebCh4SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d08:	e0bffe03 	ldbu	r2,-8(fp)
81105d0c:	10bfffc4 	addi	r2,r2,-1
81105d10:	108003cc 	andi	r2,r2,15
81105d14:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105d18:	e0bffd17 	ldw	r2,-12(fp)
81105d1c:	100d883a 	mov	r6,r2
81105d20:	01400544 	movi	r5,21
81105d24:	01204834 	movhi	r4,33056
81105d28:	210a0004 	addi	r4,r4,10240
81105d2c:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105d30:	00800044 	movi	r2,1
81105d34:	e0bffc15 	stw	r2,-16(fp)
			break;
81105d38:	00000f06 	br	81105d78 <bFeebCh4SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d3c:	e0bffe03 	ldbu	r2,-8(fp)
81105d40:	10bfffc4 	addi	r2,r2,-1
81105d44:	108003cc 	andi	r2,r2,15
81105d48:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105d4c:	e0bffd17 	ldw	r2,-12(fp)
81105d50:	100d883a 	mov	r6,r2
81105d54:	01400504 	movi	r5,20
81105d58:	01204834 	movhi	r4,33056
81105d5c:	210a0004 	addi	r4,r4,10240
81105d60:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105d64:	00800044 	movi	r2,1
81105d68:	e0bffc15 	stw	r2,-16(fp)
			break;
81105d6c:	00000206 	br	81105d78 <bFeebCh4SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81105d70:	e03ffc15 	stw	zero,-16(fp)
			break;
81105d74:	0001883a 	nop
		}
	}

	return bStatus;
81105d78:	e0bffc17 	ldw	r2,-16(fp)
}
81105d7c:	e037883a 	mov	sp,fp
81105d80:	dfc00117 	ldw	ra,4(sp)
81105d84:	df000017 	ldw	fp,0(sp)
81105d88:	dec00204 	addi	sp,sp,8
81105d8c:	f800283a 	ret

81105d90 <bFeebCh5SetBufferSize>:

bool bFeebCh5SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105d90:	defffa04 	addi	sp,sp,-24
81105d94:	de00012e 	bgeu	sp,et,81105d9c <bFeebCh5SetBufferSize+0xc>
81105d98:	003b68fa 	trap	3
81105d9c:	dfc00515 	stw	ra,20(sp)
81105da0:	df000415 	stw	fp,16(sp)
81105da4:	df000404 	addi	fp,sp,16
81105da8:	2007883a 	mov	r3,r4
81105dac:	2805883a 	mov	r2,r5
81105db0:	e0fffe05 	stb	r3,-8(fp)
81105db4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105db8:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81105dbc:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105dc0:	e0bffe03 	ldbu	r2,-8(fp)
81105dc4:	10002426 	beq	r2,zero,81105e58 <bFeebCh5SetBufferSize+0xc8>
81105dc8:	e0bffe03 	ldbu	r2,-8(fp)
81105dcc:	10800468 	cmpgeui	r2,r2,17
81105dd0:	1000211e 	bne	r2,zero,81105e58 <bFeebCh5SetBufferSize+0xc8>
		switch (ucBufferSide) {
81105dd4:	e0bfff03 	ldbu	r2,-4(fp)
81105dd8:	10000326 	beq	r2,zero,81105de8 <bFeebCh5SetBufferSize+0x58>
81105ddc:	10800060 	cmpeqi	r2,r2,1
81105de0:	10000e1e 	bne	r2,zero,81105e1c <bFeebCh5SetBufferSize+0x8c>
81105de4:	00001a06 	br	81105e50 <bFeebCh5SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105de8:	e0bffe03 	ldbu	r2,-8(fp)
81105dec:	10bfffc4 	addi	r2,r2,-1
81105df0:	108003cc 	andi	r2,r2,15
81105df4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105df8:	e0bffd17 	ldw	r2,-12(fp)
81105dfc:	100d883a 	mov	r6,r2
81105e00:	01400544 	movi	r5,21
81105e04:	01204834 	movhi	r4,33056
81105e08:	210b0004 	addi	r4,r4,11264
81105e0c:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105e10:	00800044 	movi	r2,1
81105e14:	e0bffc15 	stw	r2,-16(fp)
			break;
81105e18:	00000f06 	br	81105e58 <bFeebCh5SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e1c:	e0bffe03 	ldbu	r2,-8(fp)
81105e20:	10bfffc4 	addi	r2,r2,-1
81105e24:	108003cc 	andi	r2,r2,15
81105e28:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105e2c:	e0bffd17 	ldw	r2,-12(fp)
81105e30:	100d883a 	mov	r6,r2
81105e34:	01400504 	movi	r5,20
81105e38:	01204834 	movhi	r4,33056
81105e3c:	210b0004 	addi	r4,r4,11264
81105e40:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105e44:	00800044 	movi	r2,1
81105e48:	e0bffc15 	stw	r2,-16(fp)
			break;
81105e4c:	00000206 	br	81105e58 <bFeebCh5SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81105e50:	e03ffc15 	stw	zero,-16(fp)
			break;
81105e54:	0001883a 	nop
		}
	}

	return bStatus;
81105e58:	e0bffc17 	ldw	r2,-16(fp)
}
81105e5c:	e037883a 	mov	sp,fp
81105e60:	dfc00117 	ldw	ra,4(sp)
81105e64:	df000017 	ldw	fp,0(sp)
81105e68:	dec00204 	addi	sp,sp,8
81105e6c:	f800283a 	ret

81105e70 <bFeebCh6SetBufferSize>:

bool bFeebCh6SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105e70:	defffa04 	addi	sp,sp,-24
81105e74:	de00012e 	bgeu	sp,et,81105e7c <bFeebCh6SetBufferSize+0xc>
81105e78:	003b68fa 	trap	3
81105e7c:	dfc00515 	stw	ra,20(sp)
81105e80:	df000415 	stw	fp,16(sp)
81105e84:	df000404 	addi	fp,sp,16
81105e88:	2007883a 	mov	r3,r4
81105e8c:	2805883a 	mov	r2,r5
81105e90:	e0fffe05 	stb	r3,-8(fp)
81105e94:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105e98:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81105e9c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105ea0:	e0bffe03 	ldbu	r2,-8(fp)
81105ea4:	10002426 	beq	r2,zero,81105f38 <bFeebCh6SetBufferSize+0xc8>
81105ea8:	e0bffe03 	ldbu	r2,-8(fp)
81105eac:	10800468 	cmpgeui	r2,r2,17
81105eb0:	1000211e 	bne	r2,zero,81105f38 <bFeebCh6SetBufferSize+0xc8>
		switch (ucBufferSide) {
81105eb4:	e0bfff03 	ldbu	r2,-4(fp)
81105eb8:	10000326 	beq	r2,zero,81105ec8 <bFeebCh6SetBufferSize+0x58>
81105ebc:	10800060 	cmpeqi	r2,r2,1
81105ec0:	10000e1e 	bne	r2,zero,81105efc <bFeebCh6SetBufferSize+0x8c>
81105ec4:	00001a06 	br	81105f30 <bFeebCh6SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ec8:	e0bffe03 	ldbu	r2,-8(fp)
81105ecc:	10bfffc4 	addi	r2,r2,-1
81105ed0:	108003cc 	andi	r2,r2,15
81105ed4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105ed8:	e0bffd17 	ldw	r2,-12(fp)
81105edc:	100d883a 	mov	r6,r2
81105ee0:	01400544 	movi	r5,21
81105ee4:	01204834 	movhi	r4,33056
81105ee8:	210a0004 	addi	r4,r4,10240
81105eec:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105ef0:	00800044 	movi	r2,1
81105ef4:	e0bffc15 	stw	r2,-16(fp)
			break;
81105ef8:	00000f06 	br	81105f38 <bFeebCh6SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105efc:	e0bffe03 	ldbu	r2,-8(fp)
81105f00:	10bfffc4 	addi	r2,r2,-1
81105f04:	108003cc 	andi	r2,r2,15
81105f08:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105f0c:	e0bffd17 	ldw	r2,-12(fp)
81105f10:	100d883a 	mov	r6,r2
81105f14:	01400504 	movi	r5,20
81105f18:	01204834 	movhi	r4,33056
81105f1c:	210a0004 	addi	r4,r4,10240
81105f20:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105f24:	00800044 	movi	r2,1
81105f28:	e0bffc15 	stw	r2,-16(fp)
			break;
81105f2c:	00000206 	br	81105f38 <bFeebCh6SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81105f30:	e03ffc15 	stw	zero,-16(fp)
			break;
81105f34:	0001883a 	nop
		}
	}

	return bStatus;
81105f38:	e0bffc17 	ldw	r2,-16(fp)
}
81105f3c:	e037883a 	mov	sp,fp
81105f40:	dfc00117 	ldw	ra,4(sp)
81105f44:	df000017 	ldw	fp,0(sp)
81105f48:	dec00204 	addi	sp,sp,8
81105f4c:	f800283a 	ret

81105f50 <bFeebCh7SetBufferSize>:

bool bFeebCh7SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105f50:	defffa04 	addi	sp,sp,-24
81105f54:	de00012e 	bgeu	sp,et,81105f5c <bFeebCh7SetBufferSize+0xc>
81105f58:	003b68fa 	trap	3
81105f5c:	dfc00515 	stw	ra,20(sp)
81105f60:	df000415 	stw	fp,16(sp)
81105f64:	df000404 	addi	fp,sp,16
81105f68:	2007883a 	mov	r3,r4
81105f6c:	2805883a 	mov	r2,r5
81105f70:	e0fffe05 	stb	r3,-8(fp)
81105f74:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105f78:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
81105f7c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105f80:	e0bffe03 	ldbu	r2,-8(fp)
81105f84:	10002426 	beq	r2,zero,81106018 <bFeebCh7SetBufferSize+0xc8>
81105f88:	e0bffe03 	ldbu	r2,-8(fp)
81105f8c:	10800468 	cmpgeui	r2,r2,17
81105f90:	1000211e 	bne	r2,zero,81106018 <bFeebCh7SetBufferSize+0xc8>
		switch (ucBufferSide) {
81105f94:	e0bfff03 	ldbu	r2,-4(fp)
81105f98:	10000326 	beq	r2,zero,81105fa8 <bFeebCh7SetBufferSize+0x58>
81105f9c:	10800060 	cmpeqi	r2,r2,1
81105fa0:	10000e1e 	bne	r2,zero,81105fdc <bFeebCh7SetBufferSize+0x8c>
81105fa4:	00001a06 	br	81106010 <bFeebCh7SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105fa8:	e0bffe03 	ldbu	r2,-8(fp)
81105fac:	10bfffc4 	addi	r2,r2,-1
81105fb0:	108003cc 	andi	r2,r2,15
81105fb4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105fb8:	e0bffd17 	ldw	r2,-12(fp)
81105fbc:	100d883a 	mov	r6,r2
81105fc0:	01400544 	movi	r5,21
81105fc4:	01204834 	movhi	r4,33056
81105fc8:	210b0004 	addi	r4,r4,11264
81105fcc:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81105fd0:	00800044 	movi	r2,1
81105fd4:	e0bffc15 	stw	r2,-16(fp)
			break;
81105fd8:	00000f06 	br	81106018 <bFeebCh7SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105fdc:	e0bffe03 	ldbu	r2,-8(fp)
81105fe0:	10bfffc4 	addi	r2,r2,-1
81105fe4:	108003cc 	andi	r2,r2,15
81105fe8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105fec:	e0bffd17 	ldw	r2,-12(fp)
81105ff0:	100d883a 	mov	r6,r2
81105ff4:	01400504 	movi	r5,20
81105ff8:	01204834 	movhi	r4,33056
81105ffc:	210b0004 	addi	r4,r4,11264
81106000:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
81106004:	00800044 	movi	r2,1
81106008:	e0bffc15 	stw	r2,-16(fp)
			break;
8110600c:	00000206 	br	81106018 <bFeebCh7SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81106010:	e03ffc15 	stw	zero,-16(fp)
			break;
81106014:	0001883a 	nop
		}
	}

	return bStatus;
81106018:	e0bffc17 	ldw	r2,-16(fp)
}
8110601c:	e037883a 	mov	sp,fp
81106020:	dfc00117 	ldw	ra,4(sp)
81106024:	df000017 	ldw	fp,0(sp)
81106028:	dec00204 	addi	sp,sp,8
8110602c:	f800283a 	ret

81106030 <bFeebCh8SetBufferSize>:

bool bFeebCh8SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81106030:	defffa04 	addi	sp,sp,-24
81106034:	de00012e 	bgeu	sp,et,8110603c <bFeebCh8SetBufferSize+0xc>
81106038:	003b68fa 	trap	3
8110603c:	dfc00515 	stw	ra,20(sp)
81106040:	df000415 	stw	fp,16(sp)
81106044:	df000404 	addi	fp,sp,16
81106048:	2007883a 	mov	r3,r4
8110604c:	2805883a 	mov	r2,r5
81106050:	e0fffe05 	stb	r3,-8(fp)
81106054:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81106058:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
8110605c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106060:	e0bffe03 	ldbu	r2,-8(fp)
81106064:	10002426 	beq	r2,zero,811060f8 <bFeebCh8SetBufferSize+0xc8>
81106068:	e0bffe03 	ldbu	r2,-8(fp)
8110606c:	10800468 	cmpgeui	r2,r2,17
81106070:	1000211e 	bne	r2,zero,811060f8 <bFeebCh8SetBufferSize+0xc8>
		switch (ucBufferSide) {
81106074:	e0bfff03 	ldbu	r2,-4(fp)
81106078:	10000326 	beq	r2,zero,81106088 <bFeebCh8SetBufferSize+0x58>
8110607c:	10800060 	cmpeqi	r2,r2,1
81106080:	10000e1e 	bne	r2,zero,811060bc <bFeebCh8SetBufferSize+0x8c>
81106084:	00001a06 	br	811060f0 <bFeebCh8SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106088:	e0bffe03 	ldbu	r2,-8(fp)
8110608c:	10bfffc4 	addi	r2,r2,-1
81106090:	108003cc 	andi	r2,r2,15
81106094:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106098:	e0bffd17 	ldw	r2,-12(fp)
8110609c:	100d883a 	mov	r6,r2
811060a0:	01400544 	movi	r5,21
811060a4:	01204834 	movhi	r4,33056
811060a8:	210a0004 	addi	r4,r4,10240
811060ac:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
811060b0:	00800044 	movi	r2,1
811060b4:	e0bffc15 	stw	r2,-16(fp)
			break;
811060b8:	00000f06 	br	811060f8 <bFeebCh8SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811060bc:	e0bffe03 	ldbu	r2,-8(fp)
811060c0:	10bfffc4 	addi	r2,r2,-1
811060c4:	108003cc 	andi	r2,r2,15
811060c8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811060cc:	e0bffd17 	ldw	r2,-12(fp)
811060d0:	100d883a 	mov	r6,r2
811060d4:	01400504 	movi	r5,20
811060d8:	01204834 	movhi	r4,33056
811060dc:	210a0004 	addi	r4,r4,10240
811060e0:	110700c0 	call	8110700c <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
811060e4:	00800044 	movi	r2,1
811060e8:	e0bffc15 	stw	r2,-16(fp)
			break;
811060ec:	00000206 	br	811060f8 <bFeebCh8SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
811060f0:	e03ffc15 	stw	zero,-16(fp)
			break;
811060f4:	0001883a 	nop
		}
	}

	return bStatus;
811060f8:	e0bffc17 	ldw	r2,-16(fp)
}
811060fc:	e037883a 	mov	sp,fp
81106100:	dfc00117 	ldw	ra,4(sp)
81106104:	df000017 	ldw	fp,0(sp)
81106108:	dec00204 	addi	sp,sp,8
8110610c:	f800283a 	ret

81106110 <vFeebInitIrq>:

bool vFeebInitIrq(alt_u8 ucCommCh) {
81106110:	defffb04 	addi	sp,sp,-20
81106114:	de00012e 	bgeu	sp,et,8110611c <vFeebInitIrq+0xc>
81106118:	003b68fa 	trap	3
8110611c:	dfc00415 	stw	ra,16(sp)
81106120:	df000315 	stw	fp,12(sp)
81106124:	df000304 	addi	fp,sp,12
81106128:	2005883a 	mov	r2,r4
8110612c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81106130:	e03ffd15 	stw	zero,-12(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81106134:	e0bfff03 	ldbu	r2,-4(fp)
81106138:	10c00228 	cmpgeui	r3,r2,8
8110613c:	18005e1e 	bne	r3,zero,811062b8 <vFeebInitIrq+0x1a8>
81106140:	100690ba 	slli	r3,r2,2
81106144:	00a04434 	movhi	r2,33040
81106148:	10985604 	addi	r2,r2,24920
8110614c:	1885883a 	add	r2,r3,r2
81106150:	10800017 	ldw	r2,0(r2)
81106154:	1000683a 	jmp	r2
81106158:	81106178 	rdprs	r4,r16,16773
8110615c:	811061a0 	cmpeqi	r4,r16,16774
81106160:	811061c8 	cmpgei	r4,r16,16775
81106164:	811061f0 	cmpltui	r4,r16,16775
81106168:	81106218 	cmpnei	r4,r16,16776
8110616c:	81106240 	call	88110624 <__reset+0x20f0624>
81106170:	81106268 	cmpgeui	r4,r16,16777
81106174:	81106290 	cmplti	r4,r16,16778
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81106178:	d0a04004 	addi	r2,gp,-32512
8110617c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
81106180:	01a04434 	movhi	r6,33040
81106184:	3194dc04 	addi	r6,r6,21360
81106188:	e17ffe17 	ldw	r5,-8(fp)
8110618c:	01000584 	movi	r4,22
81106190:	11382880 	call	81138288 <alt_irq_register>
				vFeebCh1HandleIrq);
		bStatus = TRUE;
81106194:	00800044 	movi	r2,1
81106198:	e0bffd15 	stw	r2,-12(fp)
		break;
8110619c:	00004806 	br	811062c0 <vFeebInitIrq+0x1b0>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811061a0:	d0a04104 	addi	r2,gp,-32508
811061a4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
811061a8:	01a04434 	movhi	r6,33040
811061ac:	3194ea04 	addi	r6,r6,21416
811061b0:	e17ffe17 	ldw	r5,-8(fp)
811061b4:	01000504 	movi	r4,20
811061b8:	11382880 	call	81138288 <alt_irq_register>
				vFeebCh2HandleIrq);
		bStatus = TRUE;
811061bc:	00800044 	movi	r2,1
811061c0:	e0bffd15 	stw	r2,-12(fp)
		break;
811061c4:	00003e06 	br	811062c0 <vFeebInitIrq+0x1b0>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811061c8:	d0a04204 	addi	r2,gp,-32504
811061cc:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
811061d0:	01a04434 	movhi	r6,33040
811061d4:	3194f804 	addi	r6,r6,21472
811061d8:	e17ffe17 	ldw	r5,-8(fp)
811061dc:	01000484 	movi	r4,18
811061e0:	11382880 	call	81138288 <alt_irq_register>
				vFeebCh3HandleIrq);
		bStatus = TRUE;
811061e4:	00800044 	movi	r2,1
811061e8:	e0bffd15 	stw	r2,-12(fp)
		break;
811061ec:	00003406 	br	811062c0 <vFeebInitIrq+0x1b0>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
811061f0:	d0a04304 	addi	r2,gp,-32500
811061f4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
811061f8:	01a04434 	movhi	r6,33040
811061fc:	31950604 	addi	r6,r6,21528
81106200:	e17ffe17 	ldw	r5,-8(fp)
81106204:	01000404 	movi	r4,16
81106208:	11382880 	call	81138288 <alt_irq_register>
				vFeebCh4HandleIrq);
		bStatus = TRUE;
8110620c:	00800044 	movi	r2,1
81106210:	e0bffd15 	stw	r2,-12(fp)
		break;
81106214:	00002a06 	br	811062c0 <vFeebInitIrq+0x1b0>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81106218:	d0a04404 	addi	r2,gp,-32496
8110621c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
81106220:	01a04434 	movhi	r6,33040
81106224:	31951404 	addi	r6,r6,21584
81106228:	e17ffe17 	ldw	r5,-8(fp)
8110622c:	01000204 	movi	r4,8
81106230:	11382880 	call	81138288 <alt_irq_register>
				vFeebCh5HandleIrq);
		bStatus = TRUE;
81106234:	00800044 	movi	r2,1
81106238:	e0bffd15 	stw	r2,-12(fp)
		break;
8110623c:	00002006 	br	811062c0 <vFeebInitIrq+0x1b0>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81106240:	d0a04504 	addi	r2,gp,-32492
81106244:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
81106248:	01a04434 	movhi	r6,33040
8110624c:	31952204 	addi	r6,r6,21640
81106250:	e17ffe17 	ldw	r5,-8(fp)
81106254:	01000184 	movi	r4,6
81106258:	11382880 	call	81138288 <alt_irq_register>
				vFeebCh6HandleIrq);
		bStatus = TRUE;
8110625c:	00800044 	movi	r2,1
81106260:	e0bffd15 	stw	r2,-12(fp)
		break;
81106264:	00001606 	br	811062c0 <vFeebInitIrq+0x1b0>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81106268:	d0a04604 	addi	r2,gp,-32488
8110626c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
81106270:	01a04434 	movhi	r6,33040
81106274:	31953004 	addi	r6,r6,21696
81106278:	e17ffe17 	ldw	r5,-8(fp)
8110627c:	01000144 	movi	r4,5
81106280:	11382880 	call	81138288 <alt_irq_register>
				vFeebCh7HandleIrq);
		bStatus = TRUE;
81106284:	00800044 	movi	r2,1
81106288:	e0bffd15 	stw	r2,-12(fp)
		break;
8110628c:	00000c06 	br	811062c0 <vFeebInitIrq+0x1b0>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81106290:	d0a04704 	addi	r2,gp,-32484
81106294:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
81106298:	01a04434 	movhi	r6,33040
8110629c:	31953e04 	addi	r6,r6,21752
811062a0:	e17ffe17 	ldw	r5,-8(fp)
811062a4:	01000084 	movi	r4,2
811062a8:	11382880 	call	81138288 <alt_irq_register>
				vFeebCh8HandleIrq);
		bStatus = TRUE;
811062ac:	00800044 	movi	r2,1
811062b0:	e0bffd15 	stw	r2,-12(fp)
		break;
811062b4:	00000206 	br	811062c0 <vFeebInitIrq+0x1b0>
	default:
		bStatus = FALSE;
811062b8:	e03ffd15 	stw	zero,-12(fp)
		break;
811062bc:	0001883a 	nop
	}

	return bStatus;
811062c0:	e0bffd17 	ldw	r2,-12(fp)
}
811062c4:	e037883a 	mov	sp,fp
811062c8:	dfc00117 	ldw	ra,4(sp)
811062cc:	df000017 	ldw	fp,0(sp)
811062d0:	dec00204 	addi	sp,sp,8
811062d4:	f800283a 	ret

811062d8 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
811062d8:	defffb04 	addi	sp,sp,-20
811062dc:	de00012e 	bgeu	sp,et,811062e4 <bFeebSetIrqControl+0xc>
811062e0:	003b68fa 	trap	3
811062e4:	dfc00415 	stw	ra,16(sp)
811062e8:	df000315 	stw	fp,12(sp)
811062ec:	df000304 	addi	fp,sp,12
811062f0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811062f4:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
811062f8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811062fc:	e0bfff17 	ldw	r2,-4(fp)
81106300:	10002526 	beq	r2,zero,81106398 <bFeebSetIrqControl+0xc0>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106304:	e0bfff17 	ldw	r2,-4(fp)
81106308:	10800017 	ldw	r2,0(r2)
8110630c:	01400444 	movi	r5,17
81106310:	1009883a 	mov	r4,r2
81106314:	11070600 	call	81107060 <uliFeebReadReg>
81106318:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
8110631c:	e0bfff17 	ldw	r2,-4(fp)
81106320:	10800217 	ldw	r2,8(r2)
81106324:	10000426 	beq	r2,zero,81106338 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
81106328:	e0bffe17 	ldw	r2,-8(fp)
8110632c:	10808014 	ori	r2,r2,512
81106330:	e0bffe15 	stw	r2,-8(fp)
81106334:	00000406 	br	81106348 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
81106338:	e0fffe17 	ldw	r3,-8(fp)
8110633c:	00bf7fc4 	movi	r2,-513
81106340:	1884703a 	and	r2,r3,r2
81106344:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
81106348:	e0bfff17 	ldw	r2,-4(fp)
8110634c:	10800317 	ldw	r2,12(r2)
81106350:	10000426 	beq	r2,zero,81106364 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
81106354:	e0bffe17 	ldw	r2,-8(fp)
81106358:	10804014 	ori	r2,r2,256
8110635c:	e0bffe15 	stw	r2,-8(fp)
81106360:	00000406 	br	81106374 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
81106364:	e0fffe17 	ldw	r3,-8(fp)
81106368:	00bfbfc4 	movi	r2,-257
8110636c:	1884703a 	and	r2,r3,r2
81106370:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
81106374:	e0bfff17 	ldw	r2,-4(fp)
81106378:	10800017 	ldw	r2,0(r2)
8110637c:	e0fffe17 	ldw	r3,-8(fp)
81106380:	180d883a 	mov	r6,r3
81106384:	01400444 	movi	r5,17
81106388:	1009883a 	mov	r4,r2
8110638c:	110700c0 	call	8110700c <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81106390:	00800044 	movi	r2,1
81106394:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106398:	e0bffd17 	ldw	r2,-12(fp)
}
8110639c:	e037883a 	mov	sp,fp
811063a0:	dfc00117 	ldw	ra,4(sp)
811063a4:	df000017 	ldw	fp,0(sp)
811063a8:	dec00204 	addi	sp,sp,8
811063ac:	f800283a 	ret

811063b0 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
811063b0:	defffb04 	addi	sp,sp,-20
811063b4:	de00012e 	bgeu	sp,et,811063bc <bFeebGetIrqControl+0xc>
811063b8:	003b68fa 	trap	3
811063bc:	dfc00415 	stw	ra,16(sp)
811063c0:	df000315 	stw	fp,12(sp)
811063c4:	df000304 	addi	fp,sp,12
811063c8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811063cc:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
811063d0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811063d4:	e0bfff17 	ldw	r2,-4(fp)
811063d8:	10001a26 	beq	r2,zero,81106444 <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811063dc:	e0bfff17 	ldw	r2,-4(fp)
811063e0:	10800017 	ldw	r2,0(r2)
811063e4:	01400444 	movi	r5,17
811063e8:	1009883a 	mov	r4,r2
811063ec:	11070600 	call	81107060 <uliFeebReadReg>
811063f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
811063f4:	e0bffe17 	ldw	r2,-8(fp)
811063f8:	1080800c 	andi	r2,r2,512
811063fc:	10000426 	beq	r2,zero,81106410 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81106400:	e0bfff17 	ldw	r2,-4(fp)
81106404:	00c00044 	movi	r3,1
81106408:	10c00215 	stw	r3,8(r2)
8110640c:	00000206 	br	81106418 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81106410:	e0bfff17 	ldw	r2,-4(fp)
81106414:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
81106418:	e0bffe17 	ldw	r2,-8(fp)
8110641c:	1080400c 	andi	r2,r2,256
81106420:	10000426 	beq	r2,zero,81106434 <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81106424:	e0bfff17 	ldw	r2,-4(fp)
81106428:	00c00044 	movi	r3,1
8110642c:	10c00315 	stw	r3,12(r2)
81106430:	00000206 	br	8110643c <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81106434:	e0bfff17 	ldw	r2,-4(fp)
81106438:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
8110643c:	00800044 	movi	r2,1
81106440:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106444:	e0bffd17 	ldw	r2,-12(fp)
}
81106448:	e037883a 	mov	sp,fp
8110644c:	dfc00117 	ldw	ra,4(sp)
81106450:	df000017 	ldw	fp,0(sp)
81106454:	dec00204 	addi	sp,sp,8
81106458:	f800283a 	ret

8110645c <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
8110645c:	defffb04 	addi	sp,sp,-20
81106460:	de00012e 	bgeu	sp,et,81106468 <bFeebGetIrqFlags+0xc>
81106464:	003b68fa 	trap	3
81106468:	dfc00415 	stw	ra,16(sp)
8110646c:	df000315 	stw	fp,12(sp)
81106470:	df000304 	addi	fp,sp,12
81106474:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106478:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110647c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106480:	e0bfff17 	ldw	r2,-4(fp)
81106484:	10001126 	beq	r2,zero,811064cc <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106488:	e0bfff17 	ldw	r2,-4(fp)
8110648c:	10800017 	ldw	r2,0(r2)
81106490:	01400484 	movi	r5,18
81106494:	1009883a 	mov	r4,r2
81106498:	11070600 	call	81107060 <uliFeebReadReg>
8110649c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811064a0:	e0bffe17 	ldw	r2,-8(fp)
811064a4:	1080400c 	andi	r2,r2,256
811064a8:	10000426 	beq	r2,zero,811064bc <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
811064ac:	e0bfff17 	ldw	r2,-4(fp)
811064b0:	00c00044 	movi	r3,1
811064b4:	10c00415 	stw	r3,16(r2)
811064b8:	00000206 	br	811064c4 <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
811064bc:	e0bfff17 	ldw	r2,-4(fp)
811064c0:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
811064c4:	00800044 	movi	r2,1
811064c8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811064cc:	e0bffd17 	ldw	r2,-12(fp)
}
811064d0:	e037883a 	mov	sp,fp
811064d4:	dfc00117 	ldw	ra,4(sp)
811064d8:	df000017 	ldw	fp,0(sp)
811064dc:	dec00204 	addi	sp,sp,8
811064e0:	f800283a 	ret

811064e4 <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
811064e4:	defffb04 	addi	sp,sp,-20
811064e8:	de00012e 	bgeu	sp,et,811064f0 <bFeebGetBuffersStatus+0xc>
811064ec:	003b68fa 	trap	3
811064f0:	dfc00415 	stw	ra,16(sp)
811064f4:	df000315 	stw	fp,12(sp)
811064f8:	df000304 	addi	fp,sp,12
811064fc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106500:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81106504:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106508:	e0bfff17 	ldw	r2,-4(fp)
8110650c:	10004426 	beq	r2,zero,81106620 <bFeebGetBuffersStatus+0x13c>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106510:	e0bfff17 	ldw	r2,-4(fp)
81106514:	10800017 	ldw	r2,0(r2)
81106518:	014000c4 	movi	r5,3
8110651c:	1009883a 	mov	r4,r2
81106520:	11070600 	call	81107060 <uliFeebReadReg>
81106524:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81106528:	e0bffe17 	ldw	r2,-8(fp)
8110652c:	1080008c 	andi	r2,r2,2
81106530:	10000426 	beq	r2,zero,81106544 <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
81106534:	e0bfff17 	ldw	r2,-4(fp)
81106538:	00c00044 	movi	r3,1
8110653c:	10c00515 	stw	r3,20(r2)
81106540:	00000206 	br	8110654c <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
81106544:	e0bfff17 	ldw	r2,-4(fp)
81106548:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
8110654c:	e0bffe17 	ldw	r2,-8(fp)
81106550:	1080004c 	andi	r2,r2,1
81106554:	10000426 	beq	r2,zero,81106568 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
81106558:	e0bfff17 	ldw	r2,-4(fp)
8110655c:	00c00044 	movi	r3,1
81106560:	10c00615 	stw	r3,24(r2)
81106564:	00000206 	br	81106570 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
81106568:	e0bfff17 	ldw	r2,-4(fp)
8110656c:	10000615 	stw	zero,24(r2)
		}

		if (uliReg & COMM_WIND_RIGH_FEE_BUSY_MSK) {
81106570:	e0bffe17 	ldw	r2,-8(fp)
81106574:	1080400c 	andi	r2,r2,256
81106578:	10000426 	beq	r2,zero,8110658c <bFeebGetBuffersStatus+0xa8>
			pxFeebCh->xBufferStatus.bRightFeeBusy = TRUE;
8110657c:	e0bfff17 	ldw	r2,-4(fp)
81106580:	00c00044 	movi	r3,1
81106584:	10c00815 	stw	r3,32(r2)
81106588:	00000206 	br	81106594 <bFeebGetBuffersStatus+0xb0>
		} else {
			pxFeebCh->xBufferStatus.bRightFeeBusy = FALSE;
8110658c:	e0bfff17 	ldw	r2,-4(fp)
81106590:	10000815 	stw	zero,32(r2)
		}
		if (uliReg & COMM_WIND_LEFT_FEE_BUSY_MSK) {
81106594:	e0bffe17 	ldw	r2,-8(fp)
81106598:	1080800c 	andi	r2,r2,512
8110659c:	10000426 	beq	r2,zero,811065b0 <bFeebGetBuffersStatus+0xcc>
			pxFeebCh->xBufferStatus.bLeftFeeBusy = TRUE;
811065a0:	e0bfff17 	ldw	r2,-4(fp)
811065a4:	00c00044 	movi	r3,1
811065a8:	10c00715 	stw	r3,28(r2)
811065ac:	00000206 	br	811065b8 <bFeebGetBuffersStatus+0xd4>
		} else {
			pxFeebCh->xBufferStatus.bLeftFeeBusy = FALSE;
811065b0:	e0bfff17 	ldw	r2,-4(fp)
811065b4:	10000715 	stw	zero,28(r2)
		}

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811065b8:	e0bfff17 	ldw	r2,-4(fp)
811065bc:	10800017 	ldw	r2,0(r2)
811065c0:	01400504 	movi	r5,20
811065c4:	1009883a 	mov	r4,r2
811065c8:	11070600 	call	81107060 <uliFeebReadReg>
811065cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RIGT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
811065d0:	e0bffe17 	ldw	r2,-8(fp)
811065d4:	108003cc 	andi	r2,r2,15
811065d8:	10800044 	addi	r2,r2,1
811065dc:	1007883a 	mov	r3,r2
811065e0:	e0bfff17 	ldw	r2,-4(fp)
811065e4:	10c00945 	stb	r3,37(r2)
				& COMM_RIGT_FEEBUFF_SIZE_MSK) + 1;

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811065e8:	e0bfff17 	ldw	r2,-4(fp)
811065ec:	10800017 	ldw	r2,0(r2)
811065f0:	01400544 	movi	r5,21
811065f4:	1009883a 	mov	r4,r2
811065f8:	11070600 	call	81107060 <uliFeebReadReg>
811065fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_LEFT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81106600:	e0bffe17 	ldw	r2,-8(fp)
81106604:	108003cc 	andi	r2,r2,15
81106608:	10800044 	addi	r2,r2,1
8110660c:	1007883a 	mov	r3,r2
81106610:	e0bfff17 	ldw	r2,-4(fp)
81106614:	10c00945 	stb	r3,37(r2)
				& COMM_LEFT_FEEBUFF_SIZE_MSK) + 1;

		bStatus = TRUE;
81106618:	00800044 	movi	r2,1
8110661c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106620:	e0bffd17 	ldw	r2,-12(fp)
}
81106624:	e037883a 	mov	sp,fp
81106628:	dfc00117 	ldw	ra,4(sp)
8110662c:	df000017 	ldw	fp,0(sp)
81106630:	dec00204 	addi	sp,sp,8
81106634:	f800283a 	ret

81106638 <bFeebGetLeftBufferEmpty>:

bool bFeebGetLeftBufferEmpty(TFeebChannel *pxFeebCh){
81106638:	defffb04 	addi	sp,sp,-20
8110663c:	de00012e 	bgeu	sp,et,81106644 <bFeebGetLeftBufferEmpty+0xc>
81106640:	003b68fa 	trap	3
81106644:	dfc00415 	stw	ra,16(sp)
81106648:	df000315 	stw	fp,12(sp)
8110664c:	df000304 	addi	fp,sp,12
81106650:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
81106654:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81106658:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110665c:	e0bfff17 	ldw	r2,-4(fp)
81106660:	10000d26 	beq	r2,zero,81106698 <bFeebGetLeftBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106664:	e0bfff17 	ldw	r2,-4(fp)
81106668:	10800017 	ldw	r2,0(r2)
8110666c:	014000c4 	movi	r5,3
81106670:	1009883a 	mov	r4,r2
81106674:	11070600 	call	81107060 <uliFeebReadReg>
81106678:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110667c:	e0bffe17 	ldw	r2,-8(fp)
81106680:	1080008c 	andi	r2,r2,2
81106684:	10000326 	beq	r2,zero,81106694 <bFeebGetLeftBufferEmpty+0x5c>
			bFlag = TRUE;
81106688:	00800044 	movi	r2,1
8110668c:	e0bffd15 	stw	r2,-12(fp)
81106690:	00000106 	br	81106698 <bFeebGetLeftBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
81106694:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81106698:	e0bffd17 	ldw	r2,-12(fp)
}
8110669c:	e037883a 	mov	sp,fp
811066a0:	dfc00117 	ldw	ra,4(sp)
811066a4:	df000017 	ldw	fp,0(sp)
811066a8:	dec00204 	addi	sp,sp,8
811066ac:	f800283a 	ret

811066b0 <bFeebGetRightBufferEmpty>:

bool bFeebGetRightBufferEmpty(TFeebChannel *pxFeebCh){
811066b0:	defffb04 	addi	sp,sp,-20
811066b4:	de00012e 	bgeu	sp,et,811066bc <bFeebGetRightBufferEmpty+0xc>
811066b8:	003b68fa 	trap	3
811066bc:	dfc00415 	stw	ra,16(sp)
811066c0:	df000315 	stw	fp,12(sp)
811066c4:	df000304 	addi	fp,sp,12
811066c8:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
811066cc:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
811066d0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811066d4:	e0bfff17 	ldw	r2,-4(fp)
811066d8:	10000d26 	beq	r2,zero,81106710 <bFeebGetRightBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811066dc:	e0bfff17 	ldw	r2,-4(fp)
811066e0:	10800017 	ldw	r2,0(r2)
811066e4:	014000c4 	movi	r5,3
811066e8:	1009883a 	mov	r4,r2
811066ec:	11070600 	call	81107060 <uliFeebReadReg>
811066f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811066f4:	e0bffe17 	ldw	r2,-8(fp)
811066f8:	1080004c 	andi	r2,r2,1
811066fc:	10000326 	beq	r2,zero,8110670c <bFeebGetRightBufferEmpty+0x5c>
			bFlag = TRUE;
81106700:	00800044 	movi	r2,1
81106704:	e0bffd15 	stw	r2,-12(fp)
81106708:	00000106 	br	81106710 <bFeebGetRightBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
8110670c:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81106710:	e0bffd17 	ldw	r2,-12(fp)
}
81106714:	e037883a 	mov	sp,fp
81106718:	dfc00117 	ldw	ra,4(sp)
8110671c:	df000017 	ldw	fp,0(sp)
81106720:	dec00204 	addi	sp,sp,8
81106724:	f800283a 	ret

81106728 <bFeebGetCh1LeftBufferEmpty>:

bool bFeebGetCh1LeftBufferEmpty(void){
81106728:	defffc04 	addi	sp,sp,-16
8110672c:	de00012e 	bgeu	sp,et,81106734 <bFeebGetCh1LeftBufferEmpty+0xc>
81106730:	003b68fa 	trap	3
81106734:	dfc00315 	stw	ra,12(sp)
81106738:	df000215 	stw	fp,8(sp)
8110673c:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106740:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
81106744:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106748:	014000c4 	movi	r5,3
8110674c:	01204834 	movhi	r4,33056
81106750:	210b0004 	addi	r4,r4,11264
81106754:	11070600 	call	81107060 <uliFeebReadReg>
81106758:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110675c:	e0bfff17 	ldw	r2,-4(fp)
81106760:	1080008c 	andi	r2,r2,2
81106764:	10000326 	beq	r2,zero,81106774 <bFeebGetCh1LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81106768:	00800044 	movi	r2,1
8110676c:	e0bffe15 	stw	r2,-8(fp)
81106770:	00000106 	br	81106778 <bFeebGetCh1LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106774:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106778:	e0bffe17 	ldw	r2,-8(fp)
}
8110677c:	e037883a 	mov	sp,fp
81106780:	dfc00117 	ldw	ra,4(sp)
81106784:	df000017 	ldw	fp,0(sp)
81106788:	dec00204 	addi	sp,sp,8
8110678c:	f800283a 	ret

81106790 <bFeebGetCh1RightBufferEmpty>:

bool bFeebGetCh1RightBufferEmpty(void){
81106790:	defffc04 	addi	sp,sp,-16
81106794:	de00012e 	bgeu	sp,et,8110679c <bFeebGetCh1RightBufferEmpty+0xc>
81106798:	003b68fa 	trap	3
8110679c:	dfc00315 	stw	ra,12(sp)
811067a0:	df000215 	stw	fp,8(sp)
811067a4:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811067a8:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
811067ac:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
811067b0:	014000c4 	movi	r5,3
811067b4:	01204834 	movhi	r4,33056
811067b8:	210b0004 	addi	r4,r4,11264
811067bc:	11070600 	call	81107060 <uliFeebReadReg>
811067c0:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811067c4:	e0bfff17 	ldw	r2,-4(fp)
811067c8:	1080004c 	andi	r2,r2,1
811067cc:	10000326 	beq	r2,zero,811067dc <bFeebGetCh1RightBufferEmpty+0x4c>
			bFlag = TRUE;
811067d0:	00800044 	movi	r2,1
811067d4:	e0bffe15 	stw	r2,-8(fp)
811067d8:	00000106 	br	811067e0 <bFeebGetCh1RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811067dc:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811067e0:	e0bffe17 	ldw	r2,-8(fp)
}
811067e4:	e037883a 	mov	sp,fp
811067e8:	dfc00117 	ldw	ra,4(sp)
811067ec:	df000017 	ldw	fp,0(sp)
811067f0:	dec00204 	addi	sp,sp,8
811067f4:	f800283a 	ret

811067f8 <bFeebGetCh2LeftBufferEmpty>:

bool bFeebGetCh2LeftBufferEmpty(void){
811067f8:	defffc04 	addi	sp,sp,-16
811067fc:	de00012e 	bgeu	sp,et,81106804 <bFeebGetCh2LeftBufferEmpty+0xc>
81106800:	003b68fa 	trap	3
81106804:	dfc00315 	stw	ra,12(sp)
81106808:	df000215 	stw	fp,8(sp)
8110680c:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106810:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
81106814:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106818:	014000c4 	movi	r5,3
8110681c:	01204834 	movhi	r4,33056
81106820:	210a0004 	addi	r4,r4,10240
81106824:	11070600 	call	81107060 <uliFeebReadReg>
81106828:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110682c:	e0bfff17 	ldw	r2,-4(fp)
81106830:	1080008c 	andi	r2,r2,2
81106834:	10000326 	beq	r2,zero,81106844 <bFeebGetCh2LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81106838:	00800044 	movi	r2,1
8110683c:	e0bffe15 	stw	r2,-8(fp)
81106840:	00000106 	br	81106848 <bFeebGetCh2LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106844:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106848:	e0bffe17 	ldw	r2,-8(fp)
}
8110684c:	e037883a 	mov	sp,fp
81106850:	dfc00117 	ldw	ra,4(sp)
81106854:	df000017 	ldw	fp,0(sp)
81106858:	dec00204 	addi	sp,sp,8
8110685c:	f800283a 	ret

81106860 <bFeebGetCh2RightBufferEmpty>:

bool bFeebGetCh2RightBufferEmpty(void){
81106860:	defffc04 	addi	sp,sp,-16
81106864:	de00012e 	bgeu	sp,et,8110686c <bFeebGetCh2RightBufferEmpty+0xc>
81106868:	003b68fa 	trap	3
8110686c:	dfc00315 	stw	ra,12(sp)
81106870:	df000215 	stw	fp,8(sp)
81106874:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106878:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
8110687c:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106880:	014000c4 	movi	r5,3
81106884:	01204834 	movhi	r4,33056
81106888:	210a0004 	addi	r4,r4,10240
8110688c:	11070600 	call	81107060 <uliFeebReadReg>
81106890:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106894:	e0bfff17 	ldw	r2,-4(fp)
81106898:	1080004c 	andi	r2,r2,1
8110689c:	10000326 	beq	r2,zero,811068ac <bFeebGetCh2RightBufferEmpty+0x4c>
			bFlag = TRUE;
811068a0:	00800044 	movi	r2,1
811068a4:	e0bffe15 	stw	r2,-8(fp)
811068a8:	00000106 	br	811068b0 <bFeebGetCh2RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811068ac:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811068b0:	e0bffe17 	ldw	r2,-8(fp)
}
811068b4:	e037883a 	mov	sp,fp
811068b8:	dfc00117 	ldw	ra,4(sp)
811068bc:	df000017 	ldw	fp,0(sp)
811068c0:	dec00204 	addi	sp,sp,8
811068c4:	f800283a 	ret

811068c8 <bFeebGetCh1LeftFeeBusy>:

bool bFeebGetCh1LeftFeeBusy(void){
811068c8:	defffc04 	addi	sp,sp,-16
811068cc:	de00012e 	bgeu	sp,et,811068d4 <bFeebGetCh1LeftFeeBusy+0xc>
811068d0:	003b68fa 	trap	3
811068d4:	dfc00315 	stw	ra,12(sp)
811068d8:	df000215 	stw	fp,8(sp)
811068dc:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811068e0:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
811068e4:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
811068e8:	014000c4 	movi	r5,3
811068ec:	01204834 	movhi	r4,33056
811068f0:	210b0004 	addi	r4,r4,11264
811068f4:	11070600 	call	81107060 <uliFeebReadReg>
811068f8:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_FEE_BUSY_MSK) {
811068fc:	e0bfff17 	ldw	r2,-4(fp)
81106900:	1080800c 	andi	r2,r2,512
81106904:	10000326 	beq	r2,zero,81106914 <bFeebGetCh1LeftFeeBusy+0x4c>
			bFlag = TRUE;
81106908:	00800044 	movi	r2,1
8110690c:	e0bffe15 	stw	r2,-8(fp)
81106910:	00000106 	br	81106918 <bFeebGetCh1LeftFeeBusy+0x50>
		} else {
			bFlag = FALSE;
81106914:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106918:	e0bffe17 	ldw	r2,-8(fp)
}
8110691c:	e037883a 	mov	sp,fp
81106920:	dfc00117 	ldw	ra,4(sp)
81106924:	df000017 	ldw	fp,0(sp)
81106928:	dec00204 	addi	sp,sp,8
8110692c:	f800283a 	ret

81106930 <bFeebGetCh1RightFeeBusy>:

bool bFeebGetCh1RightFeeBusy(void){
81106930:	defffc04 	addi	sp,sp,-16
81106934:	de00012e 	bgeu	sp,et,8110693c <bFeebGetCh1RightFeeBusy+0xc>
81106938:	003b68fa 	trap	3
8110693c:	dfc00315 	stw	ra,12(sp)
81106940:	df000215 	stw	fp,8(sp)
81106944:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106948:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
8110694c:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106950:	014000c4 	movi	r5,3
81106954:	01204834 	movhi	r4,33056
81106958:	210b0004 	addi	r4,r4,11264
8110695c:	11070600 	call	81107060 <uliFeebReadReg>
81106960:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_FEE_BUSY_MSK) {
81106964:	e0bfff17 	ldw	r2,-4(fp)
81106968:	1080400c 	andi	r2,r2,256
8110696c:	10000326 	beq	r2,zero,8110697c <bFeebGetCh1RightFeeBusy+0x4c>
			bFlag = TRUE;
81106970:	00800044 	movi	r2,1
81106974:	e0bffe15 	stw	r2,-8(fp)
81106978:	00000106 	br	81106980 <bFeebGetCh1RightFeeBusy+0x50>
		} else {
			bFlag = FALSE;
8110697c:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106980:	e0bffe17 	ldw	r2,-8(fp)
}
81106984:	e037883a 	mov	sp,fp
81106988:	dfc00117 	ldw	ra,4(sp)
8110698c:	df000017 	ldw	fp,0(sp)
81106990:	dec00204 	addi	sp,sp,8
81106994:	f800283a 	ret

81106998 <bFeebGetCh2LeftFeeBusy>:

bool bFeebGetCh2LeftFeeBusy(void){
81106998:	defffc04 	addi	sp,sp,-16
8110699c:	de00012e 	bgeu	sp,et,811069a4 <bFeebGetCh2LeftFeeBusy+0xc>
811069a0:	003b68fa 	trap	3
811069a4:	dfc00315 	stw	ra,12(sp)
811069a8:	df000215 	stw	fp,8(sp)
811069ac:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811069b0:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
811069b4:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
811069b8:	014000c4 	movi	r5,3
811069bc:	01204834 	movhi	r4,33056
811069c0:	210a0004 	addi	r4,r4,10240
811069c4:	11070600 	call	81107060 <uliFeebReadReg>
811069c8:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_FEE_BUSY_MSK) {
811069cc:	e0bfff17 	ldw	r2,-4(fp)
811069d0:	1080800c 	andi	r2,r2,512
811069d4:	10000326 	beq	r2,zero,811069e4 <bFeebGetCh2LeftFeeBusy+0x4c>
			bFlag = TRUE;
811069d8:	00800044 	movi	r2,1
811069dc:	e0bffe15 	stw	r2,-8(fp)
811069e0:	00000106 	br	811069e8 <bFeebGetCh2LeftFeeBusy+0x50>
		} else {
			bFlag = FALSE;
811069e4:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811069e8:	e0bffe17 	ldw	r2,-8(fp)
}
811069ec:	e037883a 	mov	sp,fp
811069f0:	dfc00117 	ldw	ra,4(sp)
811069f4:	df000017 	ldw	fp,0(sp)
811069f8:	dec00204 	addi	sp,sp,8
811069fc:	f800283a 	ret

81106a00 <bFeebGetCh2RightFeeBusy>:

bool bFeebGetCh2RightFeeBusy(void){
81106a00:	defffc04 	addi	sp,sp,-16
81106a04:	de00012e 	bgeu	sp,et,81106a0c <bFeebGetCh2RightFeeBusy+0xc>
81106a08:	003b68fa 	trap	3
81106a0c:	dfc00315 	stw	ra,12(sp)
81106a10:	df000215 	stw	fp,8(sp)
81106a14:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106a18:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
81106a1c:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106a20:	014000c4 	movi	r5,3
81106a24:	01204834 	movhi	r4,33056
81106a28:	210a0004 	addi	r4,r4,10240
81106a2c:	11070600 	call	81107060 <uliFeebReadReg>
81106a30:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_FEE_BUSY_MSK) {
81106a34:	e0bfff17 	ldw	r2,-4(fp)
81106a38:	1080400c 	andi	r2,r2,256
81106a3c:	10000326 	beq	r2,zero,81106a4c <bFeebGetCh2RightFeeBusy+0x4c>
			bFlag = TRUE;
81106a40:	00800044 	movi	r2,1
81106a44:	e0bffe15 	stw	r2,-8(fp)
81106a48:	00000106 	br	81106a50 <bFeebGetCh2RightFeeBusy+0x50>
		} else {
			bFlag = FALSE;
81106a4c:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106a50:	e0bffe17 	ldw	r2,-8(fp)
}
81106a54:	e037883a 	mov	sp,fp
81106a58:	dfc00117 	ldw	ra,4(sp)
81106a5c:	df000017 	ldw	fp,0(sp)
81106a60:	dec00204 	addi	sp,sp,8
81106a64:	f800283a 	ret

81106a68 <bFeebSetBufferSize>:

bool bFeebSetBufferSize(TFeebChannel *pxFeebCh, alt_u8 ucBufferSizeInBlocks,
		alt_u8 ucBufferSide) {
81106a68:	defff904 	addi	sp,sp,-28
81106a6c:	de00012e 	bgeu	sp,et,81106a74 <bFeebSetBufferSize+0xc>
81106a70:	003b68fa 	trap	3
81106a74:	dfc00615 	stw	ra,24(sp)
81106a78:	df000515 	stw	fp,20(sp)
81106a7c:	df000504 	addi	fp,sp,20
81106a80:	e13ffd15 	stw	r4,-12(fp)
81106a84:	2807883a 	mov	r3,r5
81106a88:	3005883a 	mov	r2,r6
81106a8c:	e0fffe05 	stb	r3,-8(fp)
81106a90:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81106a94:	00800044 	movi	r2,1
81106a98:	e0bffb15 	stw	r2,-20(fp)
	volatile alt_u32 uliReg = 0;
81106a9c:	e03ffc15 	stw	zero,-16(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106aa0:	e0bffe03 	ldbu	r2,-8(fp)
81106aa4:	10002326 	beq	r2,zero,81106b34 <bFeebSetBufferSize+0xcc>
81106aa8:	e0bffe03 	ldbu	r2,-8(fp)
81106aac:	10800468 	cmpgeui	r2,r2,17
81106ab0:	1000201e 	bne	r2,zero,81106b34 <bFeebSetBufferSize+0xcc>
		switch (ucBufferSide) {
81106ab4:	e0bfff03 	ldbu	r2,-4(fp)
81106ab8:	10000326 	beq	r2,zero,81106ac8 <bFeebSetBufferSize+0x60>
81106abc:	10800060 	cmpeqi	r2,r2,1
81106ac0:	10000d1e 	bne	r2,zero,81106af8 <bFeebSetBufferSize+0x90>
81106ac4:	00001806 	br	81106b28 <bFeebSetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106ac8:	e0bffe03 	ldbu	r2,-8(fp)
81106acc:	10bfffc4 	addi	r2,r2,-1
81106ad0:	108003cc 	andi	r2,r2,15
81106ad4:	e0bffc15 	stw	r2,-16(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81106ad8:	e0bffd17 	ldw	r2,-12(fp)
81106adc:	10800017 	ldw	r2,0(r2)
81106ae0:	e0fffc17 	ldw	r3,-16(fp)
81106ae4:	180d883a 	mov	r6,r3
81106ae8:	01400544 	movi	r5,21
81106aec:	1009883a 	mov	r4,r2
81106af0:	110700c0 	call	8110700c <vFeebWriteReg>
					COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106af4:	00000e06 	br	81106b30 <bFeebSetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106af8:	e0bffe03 	ldbu	r2,-8(fp)
81106afc:	10bfffc4 	addi	r2,r2,-1
81106b00:	108003cc 	andi	r2,r2,15
81106b04:	e0bffc15 	stw	r2,-16(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81106b08:	e0bffd17 	ldw	r2,-12(fp)
81106b0c:	10800017 	ldw	r2,0(r2)
81106b10:	e0fffc17 	ldw	r3,-16(fp)
81106b14:	180d883a 	mov	r6,r3
81106b18:	01400504 	movi	r5,20
81106b1c:	1009883a 	mov	r4,r2
81106b20:	110700c0 	call	8110700c <vFeebWriteReg>
					COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106b24:	00000206 	br	81106b30 <bFeebSetBufferSize+0xc8>
		default:
			bStatus = FALSE;
81106b28:	e03ffb15 	stw	zero,-20(fp)
			break;
81106b2c:	0001883a 	nop
		}
	} else {
81106b30:	00000106 	br	81106b38 <bFeebSetBufferSize+0xd0>
		bStatus = FALSE;
81106b34:	e03ffb15 	stw	zero,-20(fp)
	}

	return bStatus;
81106b38:	e0bffb17 	ldw	r2,-20(fp)
}
81106b3c:	e037883a 	mov	sp,fp
81106b40:	dfc00117 	ldw	ra,4(sp)
81106b44:	df000017 	ldw	fp,0(sp)
81106b48:	dec00204 	addi	sp,sp,8
81106b4c:	f800283a 	ret

81106b50 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81106b50:	defffb04 	addi	sp,sp,-20
81106b54:	de00012e 	bgeu	sp,et,81106b5c <bFeebSetWindowing+0xc>
81106b58:	003b68fa 	trap	3
81106b5c:	dfc00415 	stw	ra,16(sp)
81106b60:	df000315 	stw	fp,12(sp)
81106b64:	df000304 	addi	fp,sp,12
81106b68:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106b6c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81106b70:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106b74:	e0bfff17 	ldw	r2,-4(fp)
81106b78:	10001a26 	beq	r2,zero,81106be4 <bFeebSetWindowing+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106b7c:	e0bfff17 	ldw	r2,-4(fp)
81106b80:	10800017 	ldw	r2,0(r2)
81106b84:	01400084 	movi	r5,2
81106b88:	1009883a 	mov	r4,r2
81106b8c:	11070600 	call	81107060 <uliFeebReadReg>
81106b90:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81106b94:	e0bfff17 	ldw	r2,-4(fp)
81106b98:	10800117 	ldw	r2,4(r2)
81106b9c:	10000426 	beq	r2,zero,81106bb0 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81106ba0:	e0bffe17 	ldw	r2,-8(fp)
81106ba4:	10800214 	ori	r2,r2,8
81106ba8:	e0bffe15 	stw	r2,-8(fp)
81106bac:	00000406 	br	81106bc0 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
81106bb0:	e0fffe17 	ldw	r3,-8(fp)
81106bb4:	00bffdc4 	movi	r2,-9
81106bb8:	1884703a 	and	r2,r3,r2
81106bbc:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106bc0:	e0bfff17 	ldw	r2,-4(fp)
81106bc4:	10800017 	ldw	r2,0(r2)
81106bc8:	e0fffe17 	ldw	r3,-8(fp)
81106bcc:	180d883a 	mov	r6,r3
81106bd0:	01400084 	movi	r5,2
81106bd4:	1009883a 	mov	r4,r2
81106bd8:	110700c0 	call	8110700c <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106bdc:	00800044 	movi	r2,1
81106be0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106be4:	e0bffd17 	ldw	r2,-12(fp)
}
81106be8:	e037883a 	mov	sp,fp
81106bec:	dfc00117 	ldw	ra,4(sp)
81106bf0:	df000017 	ldw	fp,0(sp)
81106bf4:	dec00204 	addi	sp,sp,8
81106bf8:	f800283a 	ret

81106bfc <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81106bfc:	defffb04 	addi	sp,sp,-20
81106c00:	de00012e 	bgeu	sp,et,81106c08 <bFeebGetWindowing+0xc>
81106c04:	003b68fa 	trap	3
81106c08:	dfc00415 	stw	ra,16(sp)
81106c0c:	df000315 	stw	fp,12(sp)
81106c10:	df000304 	addi	fp,sp,12
81106c14:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106c18:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81106c1c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106c20:	e0bfff17 	ldw	r2,-4(fp)
81106c24:	10001126 	beq	r2,zero,81106c6c <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106c28:	e0bfff17 	ldw	r2,-4(fp)
81106c2c:	10800017 	ldw	r2,0(r2)
81106c30:	01400084 	movi	r5,2
81106c34:	1009883a 	mov	r4,r2
81106c38:	11070600 	call	81107060 <uliFeebReadReg>
81106c3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
81106c40:	e0bffe17 	ldw	r2,-8(fp)
81106c44:	1080020c 	andi	r2,r2,8
81106c48:	10000426 	beq	r2,zero,81106c5c <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81106c4c:	e0bfff17 	ldw	r2,-4(fp)
81106c50:	00c00044 	movi	r3,1
81106c54:	10c00115 	stw	r3,4(r2)
81106c58:	00000206 	br	81106c64 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81106c5c:	e0bfff17 	ldw	r2,-4(fp)
81106c60:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
81106c64:	00800044 	movi	r2,1
81106c68:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106c6c:	e0bffd17 	ldw	r2,-12(fp)
}
81106c70:	e037883a 	mov	sp,fp
81106c74:	dfc00117 	ldw	ra,4(sp)
81106c78:	df000017 	ldw	fp,0(sp)
81106c7c:	dec00204 	addi	sp,sp,8
81106c80:	f800283a 	ret

81106c84 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81106c84:	defffb04 	addi	sp,sp,-20
81106c88:	de00012e 	bgeu	sp,et,81106c90 <bFeebStartCh+0xc>
81106c8c:	003b68fa 	trap	3
81106c90:	dfc00415 	stw	ra,16(sp)
81106c94:	df000315 	stw	fp,12(sp)
81106c98:	df000304 	addi	fp,sp,12
81106c9c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106ca0:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81106ca4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106ca8:	e0bfff17 	ldw	r2,-4(fp)
81106cac:	10001226 	beq	r2,zero,81106cf8 <bFeebStartCh+0x74>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106cb0:	e0bfff17 	ldw	r2,-4(fp)
81106cb4:	10800017 	ldw	r2,0(r2)
81106cb8:	01400084 	movi	r5,2
81106cbc:	1009883a 	mov	r4,r2
81106cc0:	11070600 	call	81107060 <uliFeebReadReg>
81106cc4:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
81106cc8:	e0bffe17 	ldw	r2,-8(fp)
81106ccc:	10800114 	ori	r2,r2,4
81106cd0:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106cd4:	e0bfff17 	ldw	r2,-4(fp)
81106cd8:	10800017 	ldw	r2,0(r2)
81106cdc:	e0fffe17 	ldw	r3,-8(fp)
81106ce0:	180d883a 	mov	r6,r3
81106ce4:	01400084 	movi	r5,2
81106ce8:	1009883a 	mov	r4,r2
81106cec:	110700c0 	call	8110700c <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106cf0:	00800044 	movi	r2,1
81106cf4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106cf8:	e0bffd17 	ldw	r2,-12(fp)
}
81106cfc:	e037883a 	mov	sp,fp
81106d00:	dfc00117 	ldw	ra,4(sp)
81106d04:	df000017 	ldw	fp,0(sp)
81106d08:	dec00204 	addi	sp,sp,8
81106d0c:	f800283a 	ret

81106d10 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
81106d10:	defffb04 	addi	sp,sp,-20
81106d14:	de00012e 	bgeu	sp,et,81106d1c <bFeebStopCh+0xc>
81106d18:	003b68fa 	trap	3
81106d1c:	dfc00415 	stw	ra,16(sp)
81106d20:	df000315 	stw	fp,12(sp)
81106d24:	df000304 	addi	fp,sp,12
81106d28:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106d2c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81106d30:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106d34:	e0bfff17 	ldw	r2,-4(fp)
81106d38:	10001226 	beq	r2,zero,81106d84 <bFeebStopCh+0x74>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106d3c:	e0bfff17 	ldw	r2,-4(fp)
81106d40:	10800017 	ldw	r2,0(r2)
81106d44:	01400084 	movi	r5,2
81106d48:	1009883a 	mov	r4,r2
81106d4c:	11070600 	call	81107060 <uliFeebReadReg>
81106d50:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81106d54:	e0bffe17 	ldw	r2,-8(fp)
81106d58:	10800094 	ori	r2,r2,2
81106d5c:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106d60:	e0bfff17 	ldw	r2,-4(fp)
81106d64:	10800017 	ldw	r2,0(r2)
81106d68:	e0fffe17 	ldw	r3,-8(fp)
81106d6c:	180d883a 	mov	r6,r3
81106d70:	01400084 	movi	r5,2
81106d74:	1009883a 	mov	r4,r2
81106d78:	110700c0 	call	8110700c <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106d7c:	00800044 	movi	r2,1
81106d80:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106d84:	e0bffd17 	ldw	r2,-12(fp)
}
81106d88:	e037883a 	mov	sp,fp
81106d8c:	dfc00117 	ldw	ra,4(sp)
81106d90:	df000017 	ldw	fp,0(sp)
81106d94:	dec00204 	addi	sp,sp,8
81106d98:	f800283a 	ret

81106d9c <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81106d9c:	defffb04 	addi	sp,sp,-20
81106da0:	de00012e 	bgeu	sp,et,81106da8 <bFeebClrCh+0xc>
81106da4:	003b68fa 	trap	3
81106da8:	dfc00415 	stw	ra,16(sp)
81106dac:	df000315 	stw	fp,12(sp)
81106db0:	df000304 	addi	fp,sp,12
81106db4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106db8:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81106dbc:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106dc0:	e0bfff17 	ldw	r2,-4(fp)
81106dc4:	10001226 	beq	r2,zero,81106e10 <bFeebClrCh+0x74>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106dc8:	e0bfff17 	ldw	r2,-4(fp)
81106dcc:	10800017 	ldw	r2,0(r2)
81106dd0:	01400084 	movi	r5,2
81106dd4:	1009883a 	mov	r4,r2
81106dd8:	11070600 	call	81107060 <uliFeebReadReg>
81106ddc:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
81106de0:	e0bffe17 	ldw	r2,-8(fp)
81106de4:	10800054 	ori	r2,r2,1
81106de8:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106dec:	e0bfff17 	ldw	r2,-4(fp)
81106df0:	10800017 	ldw	r2,0(r2)
81106df4:	e0fffe17 	ldw	r3,-8(fp)
81106df8:	180d883a 	mov	r6,r3
81106dfc:	01400084 	movi	r5,2
81106e00:	1009883a 	mov	r4,r2
81106e04:	110700c0 	call	8110700c <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106e08:	00800044 	movi	r2,1
81106e0c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106e10:	e0bffd17 	ldw	r2,-12(fp)
}
81106e14:	e037883a 	mov	sp,fp
81106e18:	dfc00117 	ldw	ra,4(sp)
81106e1c:	df000017 	ldw	fp,0(sp)
81106e20:	dec00204 	addi	sp,sp,8
81106e24:	f800283a 	ret

81106e28 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
81106e28:	defff904 	addi	sp,sp,-28
81106e2c:	de00012e 	bgeu	sp,et,81106e34 <bFeebInitCh+0xc>
81106e30:	003b68fa 	trap	3
81106e34:	dfc00615 	stw	ra,24(sp)
81106e38:	df000515 	stw	fp,20(sp)
81106e3c:	df000504 	addi	fp,sp,20
81106e40:	e13ffe15 	stw	r4,-8(fp)
81106e44:	2805883a 	mov	r2,r5
81106e48:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81106e4c:	e03ffb15 	stw	zero,-20(fp)
	bool bValidCh = FALSE;
81106e50:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
81106e54:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81106e58:	e0bffe17 	ldw	r2,-8(fp)
81106e5c:	10006526 	beq	r2,zero,81106ff4 <bFeebInitCh+0x1cc>

		switch (ucCommCh) {
81106e60:	e0bfff03 	ldbu	r2,-4(fp)
81106e64:	10c00228 	cmpgeui	r3,r2,8
81106e68:	1800461e 	bne	r3,zero,81106f84 <bFeebInitCh+0x15c>
81106e6c:	100690ba 	slli	r3,r2,2
81106e70:	00a04434 	movhi	r2,33040
81106e74:	109ba104 	addi	r2,r2,28292
81106e78:	1885883a 	add	r2,r3,r2
81106e7c:	10800017 	ldw	r2,0(r2)
81106e80:	1000683a 	jmp	r2
81106e84:	81106ea4 	muli	r4,r16,16826
81106e88:	81106ec0 	call	881106ec <__reset+0x20f06ec>
81106e8c:	81106edc 	xori	r4,r16,16827
81106e90:	81106ef8 	rdprs	r4,r16,16827
81106e94:	81106f14 	ori	r4,r16,16828
81106e98:	81106f30 	cmpltui	r4,r16,16828
81106e9c:	81106f4c 	andi	r4,r16,16829
81106ea0:	81106f68 	cmpgeui	r4,r16,16829
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81106ea4:	e0fffe17 	ldw	r3,-8(fp)
81106ea8:	00a04834 	movhi	r2,33056
81106eac:	108b0004 	addi	r2,r2,11264
81106eb0:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81106eb4:	00800044 	movi	r2,1
81106eb8:	e0bffc15 	stw	r2,-16(fp)
			break;
81106ebc:	00003306 	br	81106f8c <bFeebInitCh+0x164>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81106ec0:	e0fffe17 	ldw	r3,-8(fp)
81106ec4:	00a04834 	movhi	r2,33056
81106ec8:	108a0004 	addi	r2,r2,10240
81106ecc:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81106ed0:	00800044 	movi	r2,1
81106ed4:	e0bffc15 	stw	r2,-16(fp)
			break;
81106ed8:	00002c06 	br	81106f8c <bFeebInitCh+0x164>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81106edc:	e0fffe17 	ldw	r3,-8(fp)
81106ee0:	00a04834 	movhi	r2,33056
81106ee4:	108b0004 	addi	r2,r2,11264
81106ee8:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81106eec:	00800044 	movi	r2,1
81106ef0:	e0bffc15 	stw	r2,-16(fp)
			break;
81106ef4:	00002506 	br	81106f8c <bFeebInitCh+0x164>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81106ef8:	e0fffe17 	ldw	r3,-8(fp)
81106efc:	00a04834 	movhi	r2,33056
81106f00:	108a0004 	addi	r2,r2,10240
81106f04:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81106f08:	00800044 	movi	r2,1
81106f0c:	e0bffc15 	stw	r2,-16(fp)
			break;
81106f10:	00001e06 	br	81106f8c <bFeebInitCh+0x164>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81106f14:	e0fffe17 	ldw	r3,-8(fp)
81106f18:	00a04834 	movhi	r2,33056
81106f1c:	108b0004 	addi	r2,r2,11264
81106f20:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81106f24:	00800044 	movi	r2,1
81106f28:	e0bffc15 	stw	r2,-16(fp)
			break;
81106f2c:	00001706 	br	81106f8c <bFeebInitCh+0x164>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81106f30:	e0fffe17 	ldw	r3,-8(fp)
81106f34:	00a04834 	movhi	r2,33056
81106f38:	108a0004 	addi	r2,r2,10240
81106f3c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81106f40:	00800044 	movi	r2,1
81106f44:	e0bffc15 	stw	r2,-16(fp)
			break;
81106f48:	00001006 	br	81106f8c <bFeebInitCh+0x164>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81106f4c:	e0fffe17 	ldw	r3,-8(fp)
81106f50:	00a04834 	movhi	r2,33056
81106f54:	108b0004 	addi	r2,r2,11264
81106f58:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81106f5c:	00800044 	movi	r2,1
81106f60:	e0bffc15 	stw	r2,-16(fp)
			break;
81106f64:	00000906 	br	81106f8c <bFeebInitCh+0x164>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81106f68:	e0fffe17 	ldw	r3,-8(fp)
81106f6c:	00a04834 	movhi	r2,33056
81106f70:	108a0004 	addi	r2,r2,10240
81106f74:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
81106f78:	00800044 	movi	r2,1
81106f7c:	e0bffc15 	stw	r2,-16(fp)
			break;
81106f80:	00000206 	br	81106f8c <bFeebInitCh+0x164>
		default:
			bValidCh = FALSE;
81106f84:	e03ffc15 	stw	zero,-16(fp)
			break;
81106f88:	0001883a 	nop
		}

		if (bValidCh) {
81106f8c:	e0bffc17 	ldw	r2,-16(fp)
81106f90:	10001826 	beq	r2,zero,81106ff4 <bFeebInitCh+0x1cc>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81106f94:	e13ffe17 	ldw	r4,-8(fp)
81106f98:	11063b00 	call	811063b0 <bFeebGetIrqControl>
81106f9c:	1000021e 	bne	r2,zero,81106fa8 <bFeebInitCh+0x180>
				bInitFail = TRUE;
81106fa0:	00800044 	movi	r2,1
81106fa4:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81106fa8:	e13ffe17 	ldw	r4,-8(fp)
81106fac:	110645c0 	call	8110645c <bFeebGetIrqFlags>
81106fb0:	1000021e 	bne	r2,zero,81106fbc <bFeebInitCh+0x194>
				bInitFail = TRUE;
81106fb4:	00800044 	movi	r2,1
81106fb8:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81106fbc:	e13ffe17 	ldw	r4,-8(fp)
81106fc0:	11064e40 	call	811064e4 <bFeebGetBuffersStatus>
81106fc4:	1000021e 	bne	r2,zero,81106fd0 <bFeebInitCh+0x1a8>
				bInitFail = TRUE;
81106fc8:	00800044 	movi	r2,1
81106fcc:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81106fd0:	e13ffe17 	ldw	r4,-8(fp)
81106fd4:	1106bfc0 	call	81106bfc <bFeebGetWindowing>
81106fd8:	1000021e 	bne	r2,zero,81106fe4 <bFeebInitCh+0x1bc>
				bInitFail = TRUE;
81106fdc:	00800044 	movi	r2,1
81106fe0:	e0bffd15 	stw	r2,-12(fp)
			}

			if (!bInitFail) {
81106fe4:	e0bffd17 	ldw	r2,-12(fp)
81106fe8:	1000021e 	bne	r2,zero,81106ff4 <bFeebInitCh+0x1cc>
				bStatus = TRUE;
81106fec:	00800044 	movi	r2,1
81106ff0:	e0bffb15 	stw	r2,-20(fp)
			}
		}
	}
	return bStatus;
81106ff4:	e0bffb17 	ldw	r2,-20(fp)
}
81106ff8:	e037883a 	mov	sp,fp
81106ffc:	dfc00117 	ldw	ra,4(sp)
81107000:	df000017 	ldw	fp,0(sp)
81107004:	dec00204 	addi	sp,sp,8
81107008:	f800283a 	ret

8110700c <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110700c:	defffc04 	addi	sp,sp,-16
81107010:	de00012e 	bgeu	sp,et,81107018 <vFeebWriteReg+0xc>
81107014:	003b68fa 	trap	3
81107018:	df000315 	stw	fp,12(sp)
8110701c:	df000304 	addi	fp,sp,12
81107020:	e13ffd15 	stw	r4,-12(fp)
81107024:	e17ffe15 	stw	r5,-8(fp)
81107028:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110702c:	e0bffe17 	ldw	r2,-8(fp)
81107030:	1085883a 	add	r2,r2,r2
81107034:	1085883a 	add	r2,r2,r2
81107038:	1007883a 	mov	r3,r2
8110703c:	e0bffd17 	ldw	r2,-12(fp)
81107040:	10c5883a 	add	r2,r2,r3
81107044:	e0ffff17 	ldw	r3,-4(fp)
81107048:	10c00015 	stw	r3,0(r2)
}
8110704c:	0001883a 	nop
81107050:	e037883a 	mov	sp,fp
81107054:	df000017 	ldw	fp,0(sp)
81107058:	dec00104 	addi	sp,sp,4
8110705c:	f800283a 	ret

81107060 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81107060:	defffc04 	addi	sp,sp,-16
81107064:	de00012e 	bgeu	sp,et,8110706c <uliFeebReadReg+0xc>
81107068:	003b68fa 	trap	3
8110706c:	df000315 	stw	fp,12(sp)
81107070:	df000304 	addi	fp,sp,12
81107074:	e13ffe15 	stw	r4,-8(fp)
81107078:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110707c:	e0bfff17 	ldw	r2,-4(fp)
81107080:	1085883a 	add	r2,r2,r2
81107084:	1085883a 	add	r2,r2,r2
81107088:	1007883a 	mov	r3,r2
8110708c:	e0bffe17 	ldw	r2,-8(fp)
81107090:	10c5883a 	add	r2,r2,r3
81107094:	10800017 	ldw	r2,0(r2)
81107098:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110709c:	e0bffd17 	ldw	r2,-12(fp)
}
811070a0:	e037883a 	mov	sp,fp
811070a4:	df000017 	ldw	fp,0(sp)
811070a8:	dec00104 	addi	sp,sp,4
811070ac:	f800283a 	ret

811070b0 <vRmapCh1HandleIrq>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
/* todo:Trigger not working right */
void vRmapCh1HandleIrq(void* pvContext) {
811070b0:	defffb04 	addi	sp,sp,-20
811070b4:	de00012e 	bgeu	sp,et,811070bc <vRmapCh1HandleIrq+0xc>
811070b8:	003b68fa 	trap	3
811070bc:	dfc00415 	stw	ra,16(sp)
811070c0:	df000315 	stw	fp,12(sp)
811070c4:	df000304 	addi	fp,sp,12
811070c8:	e13fff15 	stw	r4,-4(fp)
	INT8U error_codel;

	/* Warnning simplification: For now all address is lower than 1 bytes  */

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811070cc:	00a045f4 	movhi	r2,33047
811070d0:	10a25304 	addi	r2,r2,-30388
811070d4:	10800a8b 	ldhu	r2,42(r2)
811070d8:	10bfffcc 	andi	r2,r2,65535
811070dc:	108000e8 	cmpgeui	r2,r2,3
811070e0:	1000071e 	bne	r2,zero,81107100 <vRmapCh1HandleIrq+0x50>
		fprintf(fp,"IRQ RMAP.\n");
811070e4:	d0a06217 	ldw	r2,-32376(gp)
811070e8:	100f883a 	mov	r7,r2
811070ec:	01800284 	movi	r6,10
811070f0:	01400044 	movi	r5,1
811070f4:	01204574 	movhi	r4,33045
811070f8:	21382604 	addi	r4,r4,-8040
811070fc:	112393c0 	call	8112393c <fwrite>
	}
#endif

	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
81107100:	11078b80 	call	811078b8 <uliRmapCh1WriteCmdAddress>
81107104:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81107108:	00800444 	movi	r2,17
8110710c:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81107110:	00bffc04 	movi	r2,-16
81107114:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81107118:	e0bffd03 	ldbu	r2,-12(fp)
8110711c:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
81107120:	e03ffe05 	stb	zero,-8(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81107124:	00a045f4 	movhi	r2,33047
81107128:	10a25304 	addi	r2,r2,-30388
8110712c:	10800a8b 	ldhu	r2,42(r2)
81107130:	10bfffcc 	andi	r2,r2,65535
81107134:	108000e8 	cmpgeui	r2,r2,3
81107138:	1000071e 	bne	r2,zero,81107158 <vRmapCh1HandleIrq+0xa8>
		fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
8110713c:	d0a06217 	ldw	r2,-32376(gp)
81107140:	e0fffd03 	ldbu	r3,-12(fp)
81107144:	180d883a 	mov	r6,r3
81107148:	01604574 	movhi	r5,33045
8110714c:	29782904 	addi	r5,r5,-8028
81107150:	1009883a 	mov	r4,r2
81107154:	11232a00 	call	811232a0 <fprintf>
	}
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
81107158:	d0a06a17 	ldw	r2,-32344(gp)
8110715c:	e0fffe17 	ldw	r3,-8(fp)
81107160:	180b883a 	mov	r5,r3
81107164:	1009883a 	mov	r4,r2
81107168:	113fddc0 	call	8113fddc <OSQPostFront>
8110716c:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81107170:	e0bffd43 	ldbu	r2,-11(fp)
81107174:	10000226 	beq	r2,zero,81107180 <vRmapCh1HandleIrq+0xd0>
		vFailSendRMAPFromIRQ( 0 );
81107178:	0009883a 	mov	r4,zero
8110717c:	111f1080 	call	8111f108 <vFailSendRMAPFromIRQ>
	}

	vRmapCh1IrqFlagClrWriteCmd();
81107180:	11073d80 	call	811073d8 <vRmapCh1IrqFlagClrWriteCmd>
}
81107184:	0001883a 	nop
81107188:	e037883a 	mov	sp,fp
8110718c:	dfc00117 	ldw	ra,4(sp)
81107190:	df000017 	ldw	fp,0(sp)
81107194:	dec00204 	addi	sp,sp,8
81107198:	f800283a 	ret

8110719c <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
8110719c:	defffb04 	addi	sp,sp,-20
811071a0:	de00012e 	bgeu	sp,et,811071a8 <vRmapCh2HandleIrq+0xc>
811071a4:	003b68fa 	trap	3
811071a8:	dfc00415 	stw	ra,16(sp)
811071ac:	df000315 	stw	fp,12(sp)
811071b0:	df000304 	addi	fp,sp,12
811071b4:	e13fff15 	stw	r4,-4(fp)
	INT8U ucADDRReg;
	INT8U error_codel;


#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811071b8:	00a045f4 	movhi	r2,33047
811071bc:	10a25304 	addi	r2,r2,-30388
811071c0:	10800a8b 	ldhu	r2,42(r2)
811071c4:	10bfffcc 	andi	r2,r2,65535
811071c8:	108000e8 	cmpgeui	r2,r2,3
811071cc:	1000071e 	bne	r2,zero,811071ec <vRmapCh2HandleIrq+0x50>
		fprintf(fp,"IRQ RMAP.\n");
811071d0:	d0a06217 	ldw	r2,-32376(gp)
811071d4:	100f883a 	mov	r7,r2
811071d8:	01800284 	movi	r6,10
811071dc:	01400044 	movi	r5,1
811071e0:	01204574 	movhi	r4,33045
811071e4:	21382604 	addi	r4,r4,-8040
811071e8:	112393c0 	call	8112393c <fwrite>
	}
#endif

	ucADDRReg = (unsigned char)uliRmapCh2WriteCmdAddress();
811071ec:	110790c0 	call	8110790c <uliRmapCh2WriteCmdAddress>
811071f0:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
811071f4:	00800444 	movi	r2,17
811071f8:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
811071fc:	00bffc04 	movi	r2,-16
81107200:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81107204:	e0bffd03 	ldbu	r2,-12(fp)
81107208:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
8110720c:	e03ffe05 	stb	zero,-8(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81107210:	00a045f4 	movhi	r2,33047
81107214:	10a25304 	addi	r2,r2,-30388
81107218:	10800a8b 	ldhu	r2,42(r2)
8110721c:	10bfffcc 	andi	r2,r2,65535
81107220:	108000e8 	cmpgeui	r2,r2,3
81107224:	1000071e 	bne	r2,zero,81107244 <vRmapCh2HandleIrq+0xa8>
		fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81107228:	d0a06217 	ldw	r2,-32376(gp)
8110722c:	e0fffd03 	ldbu	r3,-12(fp)
81107230:	180d883a 	mov	r6,r3
81107234:	01604574 	movhi	r5,33045
81107238:	29782904 	addi	r5,r5,-8028
8110723c:	1009883a 	mov	r4,r2
81107240:	11232a00 	call	811232a0 <fprintf>
	}
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
81107244:	d0a06a17 	ldw	r2,-32344(gp)
81107248:	e0fffe17 	ldw	r3,-8(fp)
8110724c:	180b883a 	mov	r5,r3
81107250:	1009883a 	mov	r4,r2
81107254:	113fddc0 	call	8113fddc <OSQPostFront>
81107258:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110725c:	e0bffd43 	ldbu	r2,-11(fp)
81107260:	10000226 	beq	r2,zero,8110726c <vRmapCh2HandleIrq+0xd0>
		vFailSendRMAPFromIRQ( 0 );
81107264:	0009883a 	mov	r4,zero
81107268:	111f1080 	call	8111f108 <vFailSendRMAPFromIRQ>
	}


	vRmapCh2IrqFlagClrWriteCmd();
8110726c:	110741c0 	call	8110741c <vRmapCh2IrqFlagClrWriteCmd>
}
81107270:	0001883a 	nop
81107274:	e037883a 	mov	sp,fp
81107278:	dfc00117 	ldw	ra,4(sp)
8110727c:	df000017 	ldw	fp,0(sp)
81107280:	dec00204 	addi	sp,sp,8
81107284:	f800283a 	ret

81107288 <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81107288:	defffd04 	addi	sp,sp,-12
8110728c:	de00012e 	bgeu	sp,et,81107294 <vRmapCh3HandleIrq+0xc>
81107290:	003b68fa 	trap	3
81107294:	dfc00215 	stw	ra,8(sp)
81107298:	df000115 	stw	fp,4(sp)
8110729c:	df000104 	addi	fp,sp,4
811072a0:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
811072a4:	11074600 	call	81107460 <vRmapCh3IrqFlagClrWriteCmd>
}
811072a8:	0001883a 	nop
811072ac:	e037883a 	mov	sp,fp
811072b0:	dfc00117 	ldw	ra,4(sp)
811072b4:	df000017 	ldw	fp,0(sp)
811072b8:	dec00204 	addi	sp,sp,8
811072bc:	f800283a 	ret

811072c0 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
811072c0:	defffd04 	addi	sp,sp,-12
811072c4:	de00012e 	bgeu	sp,et,811072cc <vRmapCh4HandleIrq+0xc>
811072c8:	003b68fa 	trap	3
811072cc:	dfc00215 	stw	ra,8(sp)
811072d0:	df000115 	stw	fp,4(sp)
811072d4:	df000104 	addi	fp,sp,4
811072d8:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
811072dc:	11074a40 	call	811074a4 <vRmapCh4IrqFlagClrWriteCmd>
}
811072e0:	0001883a 	nop
811072e4:	e037883a 	mov	sp,fp
811072e8:	dfc00117 	ldw	ra,4(sp)
811072ec:	df000017 	ldw	fp,0(sp)
811072f0:	dec00204 	addi	sp,sp,8
811072f4:	f800283a 	ret

811072f8 <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
811072f8:	defffd04 	addi	sp,sp,-12
811072fc:	de00012e 	bgeu	sp,et,81107304 <vRmapCh5HandleIrq+0xc>
81107300:	003b68fa 	trap	3
81107304:	dfc00215 	stw	ra,8(sp)
81107308:	df000115 	stw	fp,4(sp)
8110730c:	df000104 	addi	fp,sp,4
81107310:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
81107314:	11074e80 	call	811074e8 <vRmapCh5IrqFlagClrWriteCmd>
}
81107318:	0001883a 	nop
8110731c:	e037883a 	mov	sp,fp
81107320:	dfc00117 	ldw	ra,4(sp)
81107324:	df000017 	ldw	fp,0(sp)
81107328:	dec00204 	addi	sp,sp,8
8110732c:	f800283a 	ret

81107330 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
81107330:	defffd04 	addi	sp,sp,-12
81107334:	de00012e 	bgeu	sp,et,8110733c <vRmapCh6HandleIrq+0xc>
81107338:	003b68fa 	trap	3
8110733c:	dfc00215 	stw	ra,8(sp)
81107340:	df000115 	stw	fp,4(sp)
81107344:	df000104 	addi	fp,sp,4
81107348:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
8110734c:	110752c0 	call	8110752c <vRmapCh6IrqFlagClrWriteCmd>
}
81107350:	0001883a 	nop
81107354:	e037883a 	mov	sp,fp
81107358:	dfc00117 	ldw	ra,4(sp)
8110735c:	df000017 	ldw	fp,0(sp)
81107360:	dec00204 	addi	sp,sp,8
81107364:	f800283a 	ret

81107368 <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
81107368:	defffd04 	addi	sp,sp,-12
8110736c:	de00012e 	bgeu	sp,et,81107374 <vRmapCh7HandleIrq+0xc>
81107370:	003b68fa 	trap	3
81107374:	dfc00215 	stw	ra,8(sp)
81107378:	df000115 	stw	fp,4(sp)
8110737c:	df000104 	addi	fp,sp,4
81107380:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81107384:	11075700 	call	81107570 <vRmapCh7IrqFlagClrWriteCmd>
}
81107388:	0001883a 	nop
8110738c:	e037883a 	mov	sp,fp
81107390:	dfc00117 	ldw	ra,4(sp)
81107394:	df000017 	ldw	fp,0(sp)
81107398:	dec00204 	addi	sp,sp,8
8110739c:	f800283a 	ret

811073a0 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
811073a0:	defffd04 	addi	sp,sp,-12
811073a4:	de00012e 	bgeu	sp,et,811073ac <vRmapCh8HandleIrq+0xc>
811073a8:	003b68fa 	trap	3
811073ac:	dfc00215 	stw	ra,8(sp)
811073b0:	df000115 	stw	fp,4(sp)
811073b4:	df000104 	addi	fp,sp,4
811073b8:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
811073bc:	11075b40 	call	811075b4 <vRmapCh8IrqFlagClrWriteCmd>
}
811073c0:	0001883a 	nop
811073c4:	e037883a 	mov	sp,fp
811073c8:	dfc00117 	ldw	ra,4(sp)
811073cc:	df000017 	ldw	fp,0(sp)
811073d0:	dec00204 	addi	sp,sp,8
811073d4:	f800283a 	ret

811073d8 <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
811073d8:	defffe04 	addi	sp,sp,-8
811073dc:	de00012e 	bgeu	sp,et,811073e4 <vRmapCh1IrqFlagClrWriteCmd+0xc>
811073e0:	003b68fa 	trap	3
811073e4:	dfc00115 	stw	ra,4(sp)
811073e8:	df000015 	stw	fp,0(sp)
811073ec:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811073f0:	01800044 	movi	r6,1
811073f4:	014004c4 	movi	r5,19
811073f8:	01204834 	movhi	r4,33056
811073fc:	210b0004 	addi	r4,r4,11264
81107400:	110a4440 	call	8110a444 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107404:	0001883a 	nop
81107408:	e037883a 	mov	sp,fp
8110740c:	dfc00117 	ldw	ra,4(sp)
81107410:	df000017 	ldw	fp,0(sp)
81107414:	dec00204 	addi	sp,sp,8
81107418:	f800283a 	ret

8110741c <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
8110741c:	defffe04 	addi	sp,sp,-8
81107420:	de00012e 	bgeu	sp,et,81107428 <vRmapCh2IrqFlagClrWriteCmd+0xc>
81107424:	003b68fa 	trap	3
81107428:	dfc00115 	stw	ra,4(sp)
8110742c:	df000015 	stw	fp,0(sp)
81107430:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107434:	01800044 	movi	r6,1
81107438:	014004c4 	movi	r5,19
8110743c:	01204834 	movhi	r4,33056
81107440:	210a0004 	addi	r4,r4,10240
81107444:	110a4440 	call	8110a444 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107448:	0001883a 	nop
8110744c:	e037883a 	mov	sp,fp
81107450:	dfc00117 	ldw	ra,4(sp)
81107454:	df000017 	ldw	fp,0(sp)
81107458:	dec00204 	addi	sp,sp,8
8110745c:	f800283a 	ret

81107460 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
81107460:	defffe04 	addi	sp,sp,-8
81107464:	de00012e 	bgeu	sp,et,8110746c <vRmapCh3IrqFlagClrWriteCmd+0xc>
81107468:	003b68fa 	trap	3
8110746c:	dfc00115 	stw	ra,4(sp)
81107470:	df000015 	stw	fp,0(sp)
81107474:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81107478:	01800044 	movi	r6,1
8110747c:	014004c4 	movi	r5,19
81107480:	01204834 	movhi	r4,33056
81107484:	210b0004 	addi	r4,r4,11264
81107488:	110a4440 	call	8110a444 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110748c:	0001883a 	nop
81107490:	e037883a 	mov	sp,fp
81107494:	dfc00117 	ldw	ra,4(sp)
81107498:	df000017 	ldw	fp,0(sp)
8110749c:	dec00204 	addi	sp,sp,8
811074a0:	f800283a 	ret

811074a4 <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
811074a4:	defffe04 	addi	sp,sp,-8
811074a8:	de00012e 	bgeu	sp,et,811074b0 <vRmapCh4IrqFlagClrWriteCmd+0xc>
811074ac:	003b68fa 	trap	3
811074b0:	dfc00115 	stw	ra,4(sp)
811074b4:	df000015 	stw	fp,0(sp)
811074b8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811074bc:	01800044 	movi	r6,1
811074c0:	014004c4 	movi	r5,19
811074c4:	01204834 	movhi	r4,33056
811074c8:	210a0004 	addi	r4,r4,10240
811074cc:	110a4440 	call	8110a444 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811074d0:	0001883a 	nop
811074d4:	e037883a 	mov	sp,fp
811074d8:	dfc00117 	ldw	ra,4(sp)
811074dc:	df000017 	ldw	fp,0(sp)
811074e0:	dec00204 	addi	sp,sp,8
811074e4:	f800283a 	ret

811074e8 <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
811074e8:	defffe04 	addi	sp,sp,-8
811074ec:	de00012e 	bgeu	sp,et,811074f4 <vRmapCh5IrqFlagClrWriteCmd+0xc>
811074f0:	003b68fa 	trap	3
811074f4:	dfc00115 	stw	ra,4(sp)
811074f8:	df000015 	stw	fp,0(sp)
811074fc:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107500:	01800044 	movi	r6,1
81107504:	014004c4 	movi	r5,19
81107508:	01204834 	movhi	r4,33056
8110750c:	210b0004 	addi	r4,r4,11264
81107510:	110a4440 	call	8110a444 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107514:	0001883a 	nop
81107518:	e037883a 	mov	sp,fp
8110751c:	dfc00117 	ldw	ra,4(sp)
81107520:	df000017 	ldw	fp,0(sp)
81107524:	dec00204 	addi	sp,sp,8
81107528:	f800283a 	ret

8110752c <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
8110752c:	defffe04 	addi	sp,sp,-8
81107530:	de00012e 	bgeu	sp,et,81107538 <vRmapCh6IrqFlagClrWriteCmd+0xc>
81107534:	003b68fa 	trap	3
81107538:	dfc00115 	stw	ra,4(sp)
8110753c:	df000015 	stw	fp,0(sp)
81107540:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81107544:	01800044 	movi	r6,1
81107548:	014004c4 	movi	r5,19
8110754c:	01204834 	movhi	r4,33056
81107550:	210a0004 	addi	r4,r4,10240
81107554:	110a4440 	call	8110a444 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107558:	0001883a 	nop
8110755c:	e037883a 	mov	sp,fp
81107560:	dfc00117 	ldw	ra,4(sp)
81107564:	df000017 	ldw	fp,0(sp)
81107568:	dec00204 	addi	sp,sp,8
8110756c:	f800283a 	ret

81107570 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
81107570:	defffe04 	addi	sp,sp,-8
81107574:	de00012e 	bgeu	sp,et,8110757c <vRmapCh7IrqFlagClrWriteCmd+0xc>
81107578:	003b68fa 	trap	3
8110757c:	dfc00115 	stw	ra,4(sp)
81107580:	df000015 	stw	fp,0(sp)
81107584:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107588:	01800044 	movi	r6,1
8110758c:	014004c4 	movi	r5,19
81107590:	01204834 	movhi	r4,33056
81107594:	210b0004 	addi	r4,r4,11264
81107598:	110a4440 	call	8110a444 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110759c:	0001883a 	nop
811075a0:	e037883a 	mov	sp,fp
811075a4:	dfc00117 	ldw	ra,4(sp)
811075a8:	df000017 	ldw	fp,0(sp)
811075ac:	dec00204 	addi	sp,sp,8
811075b0:	f800283a 	ret

811075b4 <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
811075b4:	defffe04 	addi	sp,sp,-8
811075b8:	de00012e 	bgeu	sp,et,811075c0 <vRmapCh8IrqFlagClrWriteCmd+0xc>
811075bc:	003b68fa 	trap	3
811075c0:	dfc00115 	stw	ra,4(sp)
811075c4:	df000015 	stw	fp,0(sp)
811075c8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811075cc:	01800044 	movi	r6,1
811075d0:	014004c4 	movi	r5,19
811075d4:	01204834 	movhi	r4,33056
811075d8:	210a0004 	addi	r4,r4,10240
811075dc:	110a4440 	call	8110a444 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811075e0:	0001883a 	nop
811075e4:	e037883a 	mov	sp,fp
811075e8:	dfc00117 	ldw	ra,4(sp)
811075ec:	df000017 	ldw	fp,0(sp)
811075f0:	dec00204 	addi	sp,sp,8
811075f4:	f800283a 	ret

811075f8 <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
811075f8:	defffd04 	addi	sp,sp,-12
811075fc:	de00012e 	bgeu	sp,et,81107604 <bRmapCh1IrqFlagWriteCmd+0xc>
81107600:	003b68fa 	trap	3
81107604:	dfc00215 	stw	ra,8(sp)
81107608:	df000115 	stw	fp,4(sp)
8110760c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81107610:	01400484 	movi	r5,18
81107614:	01204834 	movhi	r4,33056
81107618:	210b0004 	addi	r4,r4,11264
8110761c:	110a4980 	call	8110a498 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107620:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81107624:	10000326 	beq	r2,zero,81107634 <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107628:	00800044 	movi	r2,1
8110762c:	e0bfff15 	stw	r2,-4(fp)
81107630:	00000106 	br	81107638 <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107634:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107638:	e0bfff17 	ldw	r2,-4(fp)
}
8110763c:	e037883a 	mov	sp,fp
81107640:	dfc00117 	ldw	ra,4(sp)
81107644:	df000017 	ldw	fp,0(sp)
81107648:	dec00204 	addi	sp,sp,8
8110764c:	f800283a 	ret

81107650 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
81107650:	defffd04 	addi	sp,sp,-12
81107654:	de00012e 	bgeu	sp,et,8110765c <bRmapCh2IrqFlagWriteCmd+0xc>
81107658:	003b68fa 	trap	3
8110765c:	dfc00215 	stw	ra,8(sp)
81107660:	df000115 	stw	fp,4(sp)
81107664:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107668:	01400484 	movi	r5,18
8110766c:	01204834 	movhi	r4,33056
81107670:	210a0004 	addi	r4,r4,10240
81107674:	110a4980 	call	8110a498 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107678:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110767c:	10000326 	beq	r2,zero,8110768c <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107680:	00800044 	movi	r2,1
81107684:	e0bfff15 	stw	r2,-4(fp)
81107688:	00000106 	br	81107690 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110768c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107690:	e0bfff17 	ldw	r2,-4(fp)
}
81107694:	e037883a 	mov	sp,fp
81107698:	dfc00117 	ldw	ra,4(sp)
8110769c:	df000017 	ldw	fp,0(sp)
811076a0:	dec00204 	addi	sp,sp,8
811076a4:	f800283a 	ret

811076a8 <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
811076a8:	defffd04 	addi	sp,sp,-12
811076ac:	de00012e 	bgeu	sp,et,811076b4 <bRmapCh3IrqFlagWriteCmd+0xc>
811076b0:	003b68fa 	trap	3
811076b4:	dfc00215 	stw	ra,8(sp)
811076b8:	df000115 	stw	fp,4(sp)
811076bc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811076c0:	01400484 	movi	r5,18
811076c4:	01204834 	movhi	r4,33056
811076c8:	210b0004 	addi	r4,r4,11264
811076cc:	110a4980 	call	8110a498 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811076d0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811076d4:	10000326 	beq	r2,zero,811076e4 <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811076d8:	00800044 	movi	r2,1
811076dc:	e0bfff15 	stw	r2,-4(fp)
811076e0:	00000106 	br	811076e8 <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811076e4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811076e8:	e0bfff17 	ldw	r2,-4(fp)
}
811076ec:	e037883a 	mov	sp,fp
811076f0:	dfc00117 	ldw	ra,4(sp)
811076f4:	df000017 	ldw	fp,0(sp)
811076f8:	dec00204 	addi	sp,sp,8
811076fc:	f800283a 	ret

81107700 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
81107700:	defffd04 	addi	sp,sp,-12
81107704:	de00012e 	bgeu	sp,et,8110770c <bRmapCh4IrqFlagWriteCmd+0xc>
81107708:	003b68fa 	trap	3
8110770c:	dfc00215 	stw	ra,8(sp)
81107710:	df000115 	stw	fp,4(sp)
81107714:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81107718:	01400484 	movi	r5,18
8110771c:	01204834 	movhi	r4,33056
81107720:	210a0004 	addi	r4,r4,10240
81107724:	110a4980 	call	8110a498 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107728:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110772c:	10000326 	beq	r2,zero,8110773c <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107730:	00800044 	movi	r2,1
81107734:	e0bfff15 	stw	r2,-4(fp)
81107738:	00000106 	br	81107740 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110773c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107740:	e0bfff17 	ldw	r2,-4(fp)
}
81107744:	e037883a 	mov	sp,fp
81107748:	dfc00117 	ldw	ra,4(sp)
8110774c:	df000017 	ldw	fp,0(sp)
81107750:	dec00204 	addi	sp,sp,8
81107754:	f800283a 	ret

81107758 <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
81107758:	defffd04 	addi	sp,sp,-12
8110775c:	de00012e 	bgeu	sp,et,81107764 <bRmapCh5IrqFlagWriteCmd+0xc>
81107760:	003b68fa 	trap	3
81107764:	dfc00215 	stw	ra,8(sp)
81107768:	df000115 	stw	fp,4(sp)
8110776c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107770:	01400484 	movi	r5,18
81107774:	01204834 	movhi	r4,33056
81107778:	210b0004 	addi	r4,r4,11264
8110777c:	110a4980 	call	8110a498 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107780:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107784:	10000326 	beq	r2,zero,81107794 <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107788:	00800044 	movi	r2,1
8110778c:	e0bfff15 	stw	r2,-4(fp)
81107790:	00000106 	br	81107798 <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107794:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107798:	e0bfff17 	ldw	r2,-4(fp)
}
8110779c:	e037883a 	mov	sp,fp
811077a0:	dfc00117 	ldw	ra,4(sp)
811077a4:	df000017 	ldw	fp,0(sp)
811077a8:	dec00204 	addi	sp,sp,8
811077ac:	f800283a 	ret

811077b0 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
811077b0:	defffd04 	addi	sp,sp,-12
811077b4:	de00012e 	bgeu	sp,et,811077bc <bRmapCh6IrqFlagWriteCmd+0xc>
811077b8:	003b68fa 	trap	3
811077bc:	dfc00215 	stw	ra,8(sp)
811077c0:	df000115 	stw	fp,4(sp)
811077c4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811077c8:	01400484 	movi	r5,18
811077cc:	01204834 	movhi	r4,33056
811077d0:	210a0004 	addi	r4,r4,10240
811077d4:	110a4980 	call	8110a498 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811077d8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811077dc:	10000326 	beq	r2,zero,811077ec <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811077e0:	00800044 	movi	r2,1
811077e4:	e0bfff15 	stw	r2,-4(fp)
811077e8:	00000106 	br	811077f0 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811077ec:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811077f0:	e0bfff17 	ldw	r2,-4(fp)
}
811077f4:	e037883a 	mov	sp,fp
811077f8:	dfc00117 	ldw	ra,4(sp)
811077fc:	df000017 	ldw	fp,0(sp)
81107800:	dec00204 	addi	sp,sp,8
81107804:	f800283a 	ret

81107808 <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
81107808:	defffd04 	addi	sp,sp,-12
8110780c:	de00012e 	bgeu	sp,et,81107814 <bRmapCh7IrqFlagWriteCmd+0xc>
81107810:	003b68fa 	trap	3
81107814:	dfc00215 	stw	ra,8(sp)
81107818:	df000115 	stw	fp,4(sp)
8110781c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107820:	01400484 	movi	r5,18
81107824:	01204834 	movhi	r4,33056
81107828:	210b0004 	addi	r4,r4,11264
8110782c:	110a4980 	call	8110a498 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107830:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107834:	10000326 	beq	r2,zero,81107844 <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107838:	00800044 	movi	r2,1
8110783c:	e0bfff15 	stw	r2,-4(fp)
81107840:	00000106 	br	81107848 <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107844:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107848:	e0bfff17 	ldw	r2,-4(fp)
}
8110784c:	e037883a 	mov	sp,fp
81107850:	dfc00117 	ldw	ra,4(sp)
81107854:	df000017 	ldw	fp,0(sp)
81107858:	dec00204 	addi	sp,sp,8
8110785c:	f800283a 	ret

81107860 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
81107860:	defffd04 	addi	sp,sp,-12
81107864:	de00012e 	bgeu	sp,et,8110786c <bRmapCh8IrqFlagWriteCmd+0xc>
81107868:	003b68fa 	trap	3
8110786c:	dfc00215 	stw	ra,8(sp)
81107870:	df000115 	stw	fp,4(sp)
81107874:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107878:	01400484 	movi	r5,18
8110787c:	01204834 	movhi	r4,33056
81107880:	210a0004 	addi	r4,r4,10240
81107884:	110a4980 	call	8110a498 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107888:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110788c:	10000326 	beq	r2,zero,8110789c <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107890:	00800044 	movi	r2,1
81107894:	e0bfff15 	stw	r2,-4(fp)
81107898:	00000106 	br	811078a0 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110789c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811078a0:	e0bfff17 	ldw	r2,-4(fp)
}
811078a4:	e037883a 	mov	sp,fp
811078a8:	dfc00117 	ldw	ra,4(sp)
811078ac:	df000017 	ldw	fp,0(sp)
811078b0:	dec00204 	addi	sp,sp,8
811078b4:	f800283a 	ret

811078b8 <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
811078b8:	defffd04 	addi	sp,sp,-12
811078bc:	de00012e 	bgeu	sp,et,811078c4 <uliRmapCh1WriteCmdAddress+0xc>
811078c0:	003b68fa 	trap	3
811078c4:	dfc00215 	stw	ra,8(sp)
811078c8:	df000115 	stw	fp,4(sp)
811078cc:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811078d0:	01400184 	movi	r5,6
811078d4:	01204834 	movhi	r4,33056
811078d8:	210b0004 	addi	r4,r4,11264
811078dc:	110a4980 	call	8110a498 <uliRmapReadReg>
811078e0:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);


	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811078e4:	e0bfff17 	ldw	r2,-4(fp)
811078e8:	1009883a 	mov	r4,r2
811078ec:	110a4e80 	call	8110a4e8 <uliConvRmapCfgAddr>
811078f0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811078f4:	e0bfff17 	ldw	r2,-4(fp)
}
811078f8:	e037883a 	mov	sp,fp
811078fc:	dfc00117 	ldw	ra,4(sp)
81107900:	df000017 	ldw	fp,0(sp)
81107904:	dec00204 	addi	sp,sp,8
81107908:	f800283a 	ret

8110790c <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
8110790c:	defffd04 	addi	sp,sp,-12
81107910:	de00012e 	bgeu	sp,et,81107918 <uliRmapCh2WriteCmdAddress+0xc>
81107914:	003b68fa 	trap	3
81107918:	dfc00215 	stw	ra,8(sp)
8110791c:	df000115 	stw	fp,4(sp)
81107920:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107924:	01400184 	movi	r5,6
81107928:	01204834 	movhi	r4,33056
8110792c:	210a0004 	addi	r4,r4,10240
81107930:	110a4980 	call	8110a498 <uliRmapReadReg>
81107934:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107938:	e0bfff17 	ldw	r2,-4(fp)
8110793c:	1009883a 	mov	r4,r2
81107940:	110a4e80 	call	8110a4e8 <uliConvRmapCfgAddr>
81107944:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107948:	e0bfff17 	ldw	r2,-4(fp)
}
8110794c:	e037883a 	mov	sp,fp
81107950:	dfc00117 	ldw	ra,4(sp)
81107954:	df000017 	ldw	fp,0(sp)
81107958:	dec00204 	addi	sp,sp,8
8110795c:	f800283a 	ret

81107960 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
81107960:	defffd04 	addi	sp,sp,-12
81107964:	de00012e 	bgeu	sp,et,8110796c <uliRmapCh3WriteCmdAddress+0xc>
81107968:	003b68fa 	trap	3
8110796c:	dfc00215 	stw	ra,8(sp)
81107970:	df000115 	stw	fp,4(sp)
81107974:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107978:	01400184 	movi	r5,6
8110797c:	01204834 	movhi	r4,33056
81107980:	210b0004 	addi	r4,r4,11264
81107984:	110a4980 	call	8110a498 <uliRmapReadReg>
81107988:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110798c:	e0bfff17 	ldw	r2,-4(fp)
81107990:	1009883a 	mov	r4,r2
81107994:	110a4e80 	call	8110a4e8 <uliConvRmapCfgAddr>
81107998:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
8110799c:	e0bfff17 	ldw	r2,-4(fp)
}
811079a0:	e037883a 	mov	sp,fp
811079a4:	dfc00117 	ldw	ra,4(sp)
811079a8:	df000017 	ldw	fp,0(sp)
811079ac:	dec00204 	addi	sp,sp,8
811079b0:	f800283a 	ret

811079b4 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
811079b4:	defffd04 	addi	sp,sp,-12
811079b8:	de00012e 	bgeu	sp,et,811079c0 <uliRmapCh4WriteCmdAddress+0xc>
811079bc:	003b68fa 	trap	3
811079c0:	dfc00215 	stw	ra,8(sp)
811079c4:	df000115 	stw	fp,4(sp)
811079c8:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811079cc:	01400184 	movi	r5,6
811079d0:	01204834 	movhi	r4,33056
811079d4:	210a0004 	addi	r4,r4,10240
811079d8:	110a4980 	call	8110a498 <uliRmapReadReg>
811079dc:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811079e0:	e0bfff17 	ldw	r2,-4(fp)
811079e4:	1009883a 	mov	r4,r2
811079e8:	110a4e80 	call	8110a4e8 <uliConvRmapCfgAddr>
811079ec:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811079f0:	e0bfff17 	ldw	r2,-4(fp)
}
811079f4:	e037883a 	mov	sp,fp
811079f8:	dfc00117 	ldw	ra,4(sp)
811079fc:	df000017 	ldw	fp,0(sp)
81107a00:	dec00204 	addi	sp,sp,8
81107a04:	f800283a 	ret

81107a08 <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
81107a08:	defffd04 	addi	sp,sp,-12
81107a0c:	de00012e 	bgeu	sp,et,81107a14 <uliRmapCh5WriteCmdAddress+0xc>
81107a10:	003b68fa 	trap	3
81107a14:	dfc00215 	stw	ra,8(sp)
81107a18:	df000115 	stw	fp,4(sp)
81107a1c:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107a20:	01400184 	movi	r5,6
81107a24:	01204834 	movhi	r4,33056
81107a28:	210b0004 	addi	r4,r4,11264
81107a2c:	110a4980 	call	8110a498 <uliRmapReadReg>
81107a30:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107a34:	e0bfff17 	ldw	r2,-4(fp)
81107a38:	1009883a 	mov	r4,r2
81107a3c:	110a4e80 	call	8110a4e8 <uliConvRmapCfgAddr>
81107a40:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107a44:	e0bfff17 	ldw	r2,-4(fp)
}
81107a48:	e037883a 	mov	sp,fp
81107a4c:	dfc00117 	ldw	ra,4(sp)
81107a50:	df000017 	ldw	fp,0(sp)
81107a54:	dec00204 	addi	sp,sp,8
81107a58:	f800283a 	ret

81107a5c <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
81107a5c:	defffd04 	addi	sp,sp,-12
81107a60:	de00012e 	bgeu	sp,et,81107a68 <uliRmapCh6WriteCmdAddress+0xc>
81107a64:	003b68fa 	trap	3
81107a68:	dfc00215 	stw	ra,8(sp)
81107a6c:	df000115 	stw	fp,4(sp)
81107a70:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107a74:	01400184 	movi	r5,6
81107a78:	01204834 	movhi	r4,33056
81107a7c:	210a0004 	addi	r4,r4,10240
81107a80:	110a4980 	call	8110a498 <uliRmapReadReg>
81107a84:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107a88:	e0bfff17 	ldw	r2,-4(fp)
81107a8c:	1009883a 	mov	r4,r2
81107a90:	110a4e80 	call	8110a4e8 <uliConvRmapCfgAddr>
81107a94:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107a98:	e0bfff17 	ldw	r2,-4(fp)
}
81107a9c:	e037883a 	mov	sp,fp
81107aa0:	dfc00117 	ldw	ra,4(sp)
81107aa4:	df000017 	ldw	fp,0(sp)
81107aa8:	dec00204 	addi	sp,sp,8
81107aac:	f800283a 	ret

81107ab0 <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
81107ab0:	defffd04 	addi	sp,sp,-12
81107ab4:	de00012e 	bgeu	sp,et,81107abc <uliRmapCh7WriteCmdAddress+0xc>
81107ab8:	003b68fa 	trap	3
81107abc:	dfc00215 	stw	ra,8(sp)
81107ac0:	df000115 	stw	fp,4(sp)
81107ac4:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107ac8:	01400184 	movi	r5,6
81107acc:	01204834 	movhi	r4,33056
81107ad0:	210b0004 	addi	r4,r4,11264
81107ad4:	110a4980 	call	8110a498 <uliRmapReadReg>
81107ad8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107adc:	e0bfff17 	ldw	r2,-4(fp)
81107ae0:	1009883a 	mov	r4,r2
81107ae4:	110a4e80 	call	8110a4e8 <uliConvRmapCfgAddr>
81107ae8:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107aec:	e0bfff17 	ldw	r2,-4(fp)
}
81107af0:	e037883a 	mov	sp,fp
81107af4:	dfc00117 	ldw	ra,4(sp)
81107af8:	df000017 	ldw	fp,0(sp)
81107afc:	dec00204 	addi	sp,sp,8
81107b00:	f800283a 	ret

81107b04 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
81107b04:	defffd04 	addi	sp,sp,-12
81107b08:	de00012e 	bgeu	sp,et,81107b10 <uliRmapCh8WriteCmdAddress+0xc>
81107b0c:	003b68fa 	trap	3
81107b10:	dfc00215 	stw	ra,8(sp)
81107b14:	df000115 	stw	fp,4(sp)
81107b18:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107b1c:	01400184 	movi	r5,6
81107b20:	01204834 	movhi	r4,33056
81107b24:	210a0004 	addi	r4,r4,10240
81107b28:	110a4980 	call	8110a498 <uliRmapReadReg>
81107b2c:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107b30:	e0bfff17 	ldw	r2,-4(fp)
81107b34:	1009883a 	mov	r4,r2
81107b38:	110a4e80 	call	8110a4e8 <uliConvRmapCfgAddr>
81107b3c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107b40:	e0bfff17 	ldw	r2,-4(fp)
}
81107b44:	e037883a 	mov	sp,fp
81107b48:	dfc00117 	ldw	ra,4(sp)
81107b4c:	df000017 	ldw	fp,0(sp)
81107b50:	dec00204 	addi	sp,sp,8
81107b54:	f800283a 	ret

81107b58 <vRmapInitIrq>:

bool vRmapInitIrq(alt_u8 ucCommCh) {
81107b58:	defffb04 	addi	sp,sp,-20
81107b5c:	de00012e 	bgeu	sp,et,81107b64 <vRmapInitIrq+0xc>
81107b60:	003b68fa 	trap	3
81107b64:	dfc00415 	stw	ra,16(sp)
81107b68:	df000315 	stw	fp,12(sp)
81107b6c:	df000304 	addi	fp,sp,12
81107b70:	2005883a 	mov	r2,r4
81107b74:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81107b78:	e03ffd15 	stw	zero,-12(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81107b7c:	e0bfff03 	ldbu	r2,-4(fp)
81107b80:	10c00228 	cmpgeui	r3,r2,8
81107b84:	18005e1e 	bne	r3,zero,81107d00 <vRmapInitIrq+0x1a8>
81107b88:	100690ba 	slli	r3,r2,2
81107b8c:	00a04434 	movhi	r2,33040
81107b90:	109ee804 	addi	r2,r2,31648
81107b94:	1885883a 	add	r2,r3,r2
81107b98:	10800017 	ldw	r2,0(r2)
81107b9c:	1000683a 	jmp	r2
81107ba0:	81107bc0 	call	881107bc <__reset+0x20f07bc>
81107ba4:	81107be8 	cmpgeui	r4,r16,16879
81107ba8:	81107c10 	cmplti	r4,r16,16880
81107bac:	81107c38 	rdprs	r4,r16,16880
81107bb0:	81107c60 	cmpeqi	r4,r16,16881
81107bb4:	81107c88 	cmpgei	r4,r16,16882
81107bb8:	81107cb0 	cmpltui	r4,r16,16882
81107bbc:	81107cd8 	cmpnei	r4,r16,16883
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81107bc0:	d0a04804 	addi	r2,gp,-32480
81107bc4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
81107bc8:	01a04434 	movhi	r6,33040
81107bcc:	319c2c04 	addi	r6,r6,28848
81107bd0:	e17ffe17 	ldw	r5,-8(fp)
81107bd4:	010005c4 	movi	r4,23
81107bd8:	11382880 	call	81138288 <alt_irq_register>
		bStatus = TRUE;
81107bdc:	00800044 	movi	r2,1
81107be0:	e0bffd15 	stw	r2,-12(fp)
		break;
81107be4:	00004806 	br	81107d08 <vRmapInitIrq+0x1b0>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81107be8:	d0a04904 	addi	r2,gp,-32476
81107bec:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
81107bf0:	01a04434 	movhi	r6,33040
81107bf4:	319c6704 	addi	r6,r6,29084
81107bf8:	e17ffe17 	ldw	r5,-8(fp)
81107bfc:	01000544 	movi	r4,21
81107c00:	11382880 	call	81138288 <alt_irq_register>
		bStatus = TRUE;
81107c04:	00800044 	movi	r2,1
81107c08:	e0bffd15 	stw	r2,-12(fp)
		break;
81107c0c:	00003e06 	br	81107d08 <vRmapInitIrq+0x1b0>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81107c10:	d0a04a04 	addi	r2,gp,-32472
81107c14:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
81107c18:	01a04434 	movhi	r6,33040
81107c1c:	319ca204 	addi	r6,r6,29320
81107c20:	e17ffe17 	ldw	r5,-8(fp)
81107c24:	010004c4 	movi	r4,19
81107c28:	11382880 	call	81138288 <alt_irq_register>
		bStatus = TRUE;
81107c2c:	00800044 	movi	r2,1
81107c30:	e0bffd15 	stw	r2,-12(fp)
		break;
81107c34:	00003406 	br	81107d08 <vRmapInitIrq+0x1b0>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81107c38:	d0a04b04 	addi	r2,gp,-32468
81107c3c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
81107c40:	01a04434 	movhi	r6,33040
81107c44:	319cb004 	addi	r6,r6,29376
81107c48:	e17ffe17 	ldw	r5,-8(fp)
81107c4c:	01000444 	movi	r4,17
81107c50:	11382880 	call	81138288 <alt_irq_register>
		bStatus = TRUE;
81107c54:	00800044 	movi	r2,1
81107c58:	e0bffd15 	stw	r2,-12(fp)
		break;
81107c5c:	00002a06 	br	81107d08 <vRmapInitIrq+0x1b0>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81107c60:	d0a04c04 	addi	r2,gp,-32464
81107c64:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
81107c68:	01a04434 	movhi	r6,33040
81107c6c:	319cbe04 	addi	r6,r6,29432
81107c70:	e17ffe17 	ldw	r5,-8(fp)
81107c74:	01000244 	movi	r4,9
81107c78:	11382880 	call	81138288 <alt_irq_register>
		bStatus = TRUE;
81107c7c:	00800044 	movi	r2,1
81107c80:	e0bffd15 	stw	r2,-12(fp)
		break;
81107c84:	00002006 	br	81107d08 <vRmapInitIrq+0x1b0>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81107c88:	d0a04d04 	addi	r2,gp,-32460
81107c8c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
81107c90:	01a04434 	movhi	r6,33040
81107c94:	319ccc04 	addi	r6,r6,29488
81107c98:	e17ffe17 	ldw	r5,-8(fp)
81107c9c:	010001c4 	movi	r4,7
81107ca0:	11382880 	call	81138288 <alt_irq_register>
		bStatus = TRUE;
81107ca4:	00800044 	movi	r2,1
81107ca8:	e0bffd15 	stw	r2,-12(fp)
		break;
81107cac:	00001606 	br	81107d08 <vRmapInitIrq+0x1b0>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81107cb0:	d0a04e04 	addi	r2,gp,-32456
81107cb4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
81107cb8:	01a04434 	movhi	r6,33040
81107cbc:	319cda04 	addi	r6,r6,29544
81107cc0:	e17ffe17 	ldw	r5,-8(fp)
81107cc4:	01000104 	movi	r4,4
81107cc8:	11382880 	call	81138288 <alt_irq_register>
		bStatus = TRUE;
81107ccc:	00800044 	movi	r2,1
81107cd0:	e0bffd15 	stw	r2,-12(fp)
		break;
81107cd4:	00000c06 	br	81107d08 <vRmapInitIrq+0x1b0>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81107cd8:	d0a04f04 	addi	r2,gp,-32452
81107cdc:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
81107ce0:	01a04434 	movhi	r6,33040
81107ce4:	319ce804 	addi	r6,r6,29600
81107ce8:	e17ffe17 	ldw	r5,-8(fp)
81107cec:	010000c4 	movi	r4,3
81107cf0:	11382880 	call	81138288 <alt_irq_register>
		bStatus = TRUE;
81107cf4:	00800044 	movi	r2,1
81107cf8:	e0bffd15 	stw	r2,-12(fp)
		break;
81107cfc:	00000206 	br	81107d08 <vRmapInitIrq+0x1b0>
	default:
		bStatus = FALSE;
81107d00:	e03ffd15 	stw	zero,-12(fp)
		break;
81107d04:	0001883a 	nop
	}

	return bStatus;
81107d08:	e0bffd17 	ldw	r2,-12(fp)
}
81107d0c:	e037883a 	mov	sp,fp
81107d10:	dfc00117 	ldw	ra,4(sp)
81107d14:	df000017 	ldw	fp,0(sp)
81107d18:	dec00204 	addi	sp,sp,8
81107d1c:	f800283a 	ret

81107d20 <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
81107d20:	defffb04 	addi	sp,sp,-20
81107d24:	de00012e 	bgeu	sp,et,81107d2c <bRmapSetIrqControl+0xc>
81107d28:	003b68fa 	trap	3
81107d2c:	dfc00415 	stw	ra,16(sp)
81107d30:	df000315 	stw	fp,12(sp)
81107d34:	df000304 	addi	fp,sp,12
81107d38:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107d3c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81107d40:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107d44:	e0bfff17 	ldw	r2,-4(fp)
81107d48:	10001a26 	beq	r2,zero,81107db4 <bRmapSetIrqControl+0x94>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d4c:	e0bfff17 	ldw	r2,-4(fp)
81107d50:	10800017 	ldw	r2,0(r2)
81107d54:	01400444 	movi	r5,17
81107d58:	1009883a 	mov	r4,r2
81107d5c:	110a4980 	call	8110a498 <uliRmapReadReg>
81107d60:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
81107d64:	e0bfff17 	ldw	r2,-4(fp)
81107d68:	10801017 	ldw	r2,64(r2)
81107d6c:	10000426 	beq	r2,zero,81107d80 <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
81107d70:	e0bffe17 	ldw	r2,-8(fp)
81107d74:	10800054 	ori	r2,r2,1
81107d78:	e0bffe15 	stw	r2,-8(fp)
81107d7c:	00000406 	br	81107d90 <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
81107d80:	e0fffe17 	ldw	r3,-8(fp)
81107d84:	00bfff84 	movi	r2,-2
81107d88:	1884703a 	and	r2,r3,r2
81107d8c:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81107d90:	e0bfff17 	ldw	r2,-4(fp)
81107d94:	10800017 	ldw	r2,0(r2)
81107d98:	e0fffe17 	ldw	r3,-8(fp)
81107d9c:	180d883a 	mov	r6,r3
81107da0:	01400444 	movi	r5,17
81107da4:	1009883a 	mov	r4,r2
81107da8:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81107dac:	00800044 	movi	r2,1
81107db0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107db4:	e0bffd17 	ldw	r2,-12(fp)
}
81107db8:	e037883a 	mov	sp,fp
81107dbc:	dfc00117 	ldw	ra,4(sp)
81107dc0:	df000017 	ldw	fp,0(sp)
81107dc4:	dec00204 	addi	sp,sp,8
81107dc8:	f800283a 	ret

81107dcc <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
81107dcc:	defffb04 	addi	sp,sp,-20
81107dd0:	de00012e 	bgeu	sp,et,81107dd8 <bRmapGetIrqControl+0xc>
81107dd4:	003b68fa 	trap	3
81107dd8:	dfc00415 	stw	ra,16(sp)
81107ddc:	df000315 	stw	fp,12(sp)
81107de0:	df000304 	addi	fp,sp,12
81107de4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107de8:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81107dec:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107df0:	e0bfff17 	ldw	r2,-4(fp)
81107df4:	10001126 	beq	r2,zero,81107e3c <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107df8:	e0bfff17 	ldw	r2,-4(fp)
81107dfc:	10800017 	ldw	r2,0(r2)
81107e00:	01400444 	movi	r5,17
81107e04:	1009883a 	mov	r4,r2
81107e08:	110a4980 	call	8110a498 <uliRmapReadReg>
81107e0c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
81107e10:	e0bffe17 	ldw	r2,-8(fp)
81107e14:	1080004c 	andi	r2,r2,1
81107e18:	10000426 	beq	r2,zero,81107e2c <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
81107e1c:	e0bfff17 	ldw	r2,-4(fp)
81107e20:	00c00044 	movi	r3,1
81107e24:	10c01015 	stw	r3,64(r2)
81107e28:	00000206 	br	81107e34 <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
81107e2c:	e0bfff17 	ldw	r2,-4(fp)
81107e30:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
81107e34:	00800044 	movi	r2,1
81107e38:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107e3c:	e0bffd17 	ldw	r2,-12(fp)
}
81107e40:	e037883a 	mov	sp,fp
81107e44:	dfc00117 	ldw	ra,4(sp)
81107e48:	df000017 	ldw	fp,0(sp)
81107e4c:	dec00204 	addi	sp,sp,8
81107e50:	f800283a 	ret

81107e54 <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
81107e54:	defffb04 	addi	sp,sp,-20
81107e58:	de00012e 	bgeu	sp,et,81107e60 <bRmapGetIrqFlags+0xc>
81107e5c:	003b68fa 	trap	3
81107e60:	dfc00415 	stw	ra,16(sp)
81107e64:	df000315 	stw	fp,12(sp)
81107e68:	df000304 	addi	fp,sp,12
81107e6c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107e70:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81107e74:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107e78:	e0bfff17 	ldw	r2,-4(fp)
81107e7c:	10001126 	beq	r2,zero,81107ec4 <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e80:	e0bfff17 	ldw	r2,-4(fp)
81107e84:	10800017 	ldw	r2,0(r2)
81107e88:	01400484 	movi	r5,18
81107e8c:	1009883a 	mov	r4,r2
81107e90:	110a4980 	call	8110a498 <uliRmapReadReg>
81107e94:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107e98:	e0bffe17 	ldw	r2,-8(fp)
81107e9c:	1080004c 	andi	r2,r2,1
81107ea0:	10000426 	beq	r2,zero,81107eb4 <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81107ea4:	e0bfff17 	ldw	r2,-4(fp)
81107ea8:	00c00044 	movi	r3,1
81107eac:	10c01115 	stw	r3,68(r2)
81107eb0:	00000206 	br	81107ebc <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81107eb4:	e0bfff17 	ldw	r2,-4(fp)
81107eb8:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81107ebc:	00800044 	movi	r2,1
81107ec0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107ec4:	e0bffd17 	ldw	r2,-12(fp)
}
81107ec8:	e037883a 	mov	sp,fp
81107ecc:	dfc00117 	ldw	ra,4(sp)
81107ed0:	df000017 	ldw	fp,0(sp)
81107ed4:	dec00204 	addi	sp,sp,8
81107ed8:	f800283a 	ret

81107edc <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81107edc:	defffb04 	addi	sp,sp,-20
81107ee0:	de00012e 	bgeu	sp,et,81107ee8 <bRmapSetCodecConfig+0xc>
81107ee4:	003b68fa 	trap	3
81107ee8:	dfc00415 	stw	ra,16(sp)
81107eec:	df000315 	stw	fp,12(sp)
81107ef0:	df000304 	addi	fp,sp,12
81107ef4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107ef8:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81107efc:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107f00:	e0bfff17 	ldw	r2,-4(fp)
81107f04:	10002626 	beq	r2,zero,81107fa0 <bRmapSetCodecConfig+0xc4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f08:	e0bfff17 	ldw	r2,-4(fp)
81107f0c:	10800017 	ldw	r2,0(r2)
81107f10:	01400104 	movi	r5,4
81107f14:	1009883a 	mov	r4,r2
81107f18:	110a4980 	call	8110a498 <uliRmapReadReg>
81107f1c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
81107f20:	e0fffe17 	ldw	r3,-8(fp)
81107f24:	00bfc004 	movi	r2,-256
81107f28:	1884703a 	and	r2,r3,r2
81107f2c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81107f30:	e0bfff17 	ldw	r2,-4(fp)
81107f34:	10800143 	ldbu	r2,5(r2)
81107f38:	10c03fcc 	andi	r3,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81107f3c:	e0bffe17 	ldw	r2,-8(fp)
81107f40:	1884b03a 	or	r2,r3,r2
81107f44:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
81107f48:	e0fffe17 	ldw	r3,-8(fp)
81107f4c:	00bffff4 	movhi	r2,65535
81107f50:	10803fc4 	addi	r2,r2,255
81107f54:	1884703a 	and	r2,r3,r2
81107f58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81107f5c:	e0bfff17 	ldw	r2,-4(fp)
81107f60:	10800103 	ldbu	r2,4(r2)
81107f64:	10803fcc 	andi	r2,r2,255
81107f68:	1004923a 	slli	r2,r2,8
81107f6c:	10ffffcc 	andi	r3,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81107f70:	e0bffe17 	ldw	r2,-8(fp)
81107f74:	1884b03a 	or	r2,r3,r2
81107f78:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81107f7c:	e0bfff17 	ldw	r2,-4(fp)
81107f80:	10800017 	ldw	r2,0(r2)
81107f84:	e0fffe17 	ldw	r3,-8(fp)
81107f88:	180d883a 	mov	r6,r3
81107f8c:	01400104 	movi	r5,4
81107f90:	1009883a 	mov	r4,r2
81107f94:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81107f98:	00800044 	movi	r2,1
81107f9c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107fa0:	e0bffd17 	ldw	r2,-12(fp)
}
81107fa4:	e037883a 	mov	sp,fp
81107fa8:	dfc00117 	ldw	ra,4(sp)
81107fac:	df000017 	ldw	fp,0(sp)
81107fb0:	dec00204 	addi	sp,sp,8
81107fb4:	f800283a 	ret

81107fb8 <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81107fb8:	defffb04 	addi	sp,sp,-20
81107fbc:	de00012e 	bgeu	sp,et,81107fc4 <bRmapGetCodecConfig+0xc>
81107fc0:	003b68fa 	trap	3
81107fc4:	dfc00415 	stw	ra,16(sp)
81107fc8:	df000315 	stw	fp,12(sp)
81107fcc:	df000304 	addi	fp,sp,12
81107fd0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107fd4:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81107fd8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107fdc:	e0bfff17 	ldw	r2,-4(fp)
81107fe0:	10001226 	beq	r2,zero,8110802c <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107fe4:	e0bfff17 	ldw	r2,-4(fp)
81107fe8:	10800017 	ldw	r2,0(r2)
81107fec:	01400104 	movi	r5,4
81107ff0:	1009883a 	mov	r4,r2
81107ff4:	110a4980 	call	8110a498 <uliRmapReadReg>
81107ff8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81107ffc:	e0bffe17 	ldw	r2,-8(fp)
81108000:	1007883a 	mov	r3,r2
81108004:	e0bfff17 	ldw	r2,-4(fp)
81108008:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
8110800c:	e0bffe17 	ldw	r2,-8(fp)
81108010:	10bfc00c 	andi	r2,r2,65280
81108014:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81108018:	1007883a 	mov	r3,r2
8110801c:	e0bfff17 	ldw	r2,-4(fp)
81108020:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81108024:	00800044 	movi	r2,1
81108028:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110802c:	e0bffd17 	ldw	r2,-12(fp)
}
81108030:	e037883a 	mov	sp,fp
81108034:	dfc00117 	ldw	ra,4(sp)
81108038:	df000017 	ldw	fp,0(sp)
8110803c:	dec00204 	addi	sp,sp,8
81108040:	f800283a 	ret

81108044 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81108044:	defffb04 	addi	sp,sp,-20
81108048:	de00012e 	bgeu	sp,et,81108050 <bRmapGetCodecStatus+0xc>
8110804c:	003b68fa 	trap	3
81108050:	dfc00415 	stw	ra,16(sp)
81108054:	df000315 	stw	fp,12(sp)
81108058:	df000304 	addi	fp,sp,12
8110805c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108060:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81108064:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108068:	e0bfff17 	ldw	r2,-4(fp)
8110806c:	10004726 	beq	r2,zero,8110818c <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108070:	e0bfff17 	ldw	r2,-4(fp)
81108074:	10800017 	ldw	r2,0(r2)
81108078:	01400144 	movi	r5,5
8110807c:	1009883a 	mov	r4,r2
81108080:	110a4980 	call	8110a498 <uliRmapReadReg>
81108084:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81108088:	e0bffe17 	ldw	r2,-8(fp)
8110808c:	1080004c 	andi	r2,r2,1
81108090:	10000426 	beq	r2,zero,811080a4 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81108094:	e0bfff17 	ldw	r2,-4(fp)
81108098:	00c00044 	movi	r3,1
8110809c:	10c00215 	stw	r3,8(r2)
811080a0:	00000206 	br	811080ac <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
811080a4:	e0bfff17 	ldw	r2,-4(fp)
811080a8:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
811080ac:	e0bffe17 	ldw	r2,-8(fp)
811080b0:	1080008c 	andi	r2,r2,2
811080b4:	10000426 	beq	r2,zero,811080c8 <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
811080b8:	e0bfff17 	ldw	r2,-4(fp)
811080bc:	00c00044 	movi	r3,1
811080c0:	10c00315 	stw	r3,12(r2)
811080c4:	00000206 	br	811080d0 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
811080c8:	e0bfff17 	ldw	r2,-4(fp)
811080cc:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
811080d0:	e0bffe17 	ldw	r2,-8(fp)
811080d4:	1080010c 	andi	r2,r2,4
811080d8:	10000426 	beq	r2,zero,811080ec <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
811080dc:	e0bfff17 	ldw	r2,-4(fp)
811080e0:	00c00044 	movi	r3,1
811080e4:	10c00415 	stw	r3,16(r2)
811080e8:	00000206 	br	811080f4 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
811080ec:	e0bfff17 	ldw	r2,-4(fp)
811080f0:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
811080f4:	e0bffe17 	ldw	r2,-8(fp)
811080f8:	1080020c 	andi	r2,r2,8
811080fc:	10000426 	beq	r2,zero,81108110 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81108100:	e0bfff17 	ldw	r2,-4(fp)
81108104:	00c00044 	movi	r3,1
81108108:	10c00515 	stw	r3,20(r2)
8110810c:	00000206 	br	81108118 <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81108110:	e0bfff17 	ldw	r2,-4(fp)
81108114:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81108118:	e0bffe17 	ldw	r2,-8(fp)
8110811c:	1080040c 	andi	r2,r2,16
81108120:	10000426 	beq	r2,zero,81108134 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81108124:	e0bfff17 	ldw	r2,-4(fp)
81108128:	00c00044 	movi	r3,1
8110812c:	10c00615 	stw	r3,24(r2)
81108130:	00000206 	br	8110813c <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81108134:	e0bfff17 	ldw	r2,-4(fp)
81108138:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
8110813c:	e0bffe17 	ldw	r2,-8(fp)
81108140:	1080080c 	andi	r2,r2,32
81108144:	10000426 	beq	r2,zero,81108158 <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81108148:	e0bfff17 	ldw	r2,-4(fp)
8110814c:	00c00044 	movi	r3,1
81108150:	10c00715 	stw	r3,28(r2)
81108154:	00000206 	br	81108160 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81108158:	e0bfff17 	ldw	r2,-4(fp)
8110815c:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81108160:	e0bffe17 	ldw	r2,-8(fp)
81108164:	1080100c 	andi	r2,r2,64
81108168:	10000426 	beq	r2,zero,8110817c <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
8110816c:	e0bfff17 	ldw	r2,-4(fp)
81108170:	00c00044 	movi	r3,1
81108174:	10c00815 	stw	r3,32(r2)
81108178:	00000206 	br	81108184 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
8110817c:	e0bfff17 	ldw	r2,-4(fp)
81108180:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81108184:	00800044 	movi	r2,1
81108188:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110818c:	e0bffd17 	ldw	r2,-12(fp)
}
81108190:	e037883a 	mov	sp,fp
81108194:	dfc00117 	ldw	ra,4(sp)
81108198:	df000017 	ldw	fp,0(sp)
8110819c:	dec00204 	addi	sp,sp,8
811081a0:	f800283a 	ret

811081a4 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
811081a4:	defffb04 	addi	sp,sp,-20
811081a8:	de00012e 	bgeu	sp,et,811081b0 <bRmapGetCodecError+0xc>
811081ac:	003b68fa 	trap	3
811081b0:	dfc00415 	stw	ra,16(sp)
811081b4:	df000315 	stw	fp,12(sp)
811081b8:	df000304 	addi	fp,sp,12
811081bc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811081c0:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
811081c4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811081c8:	e0bfff17 	ldw	r2,-4(fp)
811081cc:	10004726 	beq	r2,zero,811082ec <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081d0:	e0bfff17 	ldw	r2,-4(fp)
811081d4:	10800017 	ldw	r2,0(r2)
811081d8:	01400144 	movi	r5,5
811081dc:	1009883a 	mov	r4,r2
811081e0:	110a4980 	call	8110a498 <uliRmapReadReg>
811081e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
811081e8:	e0bffe17 	ldw	r2,-8(fp)
811081ec:	1080006c 	andhi	r2,r2,1
811081f0:	10000426 	beq	r2,zero,81108204 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
811081f4:	e0bfff17 	ldw	r2,-4(fp)
811081f8:	00c00044 	movi	r3,1
811081fc:	10c00915 	stw	r3,36(r2)
81108200:	00000206 	br	8110820c <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81108204:	e0bfff17 	ldw	r2,-4(fp)
81108208:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
8110820c:	e0bffe17 	ldw	r2,-8(fp)
81108210:	108000ac 	andhi	r2,r2,2
81108214:	10000426 	beq	r2,zero,81108228 <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81108218:	e0bfff17 	ldw	r2,-4(fp)
8110821c:	00c00044 	movi	r3,1
81108220:	10c00a15 	stw	r3,40(r2)
81108224:	00000206 	br	81108230 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81108228:	e0bfff17 	ldw	r2,-4(fp)
8110822c:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81108230:	e0bffe17 	ldw	r2,-8(fp)
81108234:	1080012c 	andhi	r2,r2,4
81108238:	10000426 	beq	r2,zero,8110824c <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
8110823c:	e0bfff17 	ldw	r2,-4(fp)
81108240:	00c00044 	movi	r3,1
81108244:	10c00b15 	stw	r3,44(r2)
81108248:	00000206 	br	81108254 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
8110824c:	e0bfff17 	ldw	r2,-4(fp)
81108250:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81108254:	e0bffe17 	ldw	r2,-8(fp)
81108258:	1080022c 	andhi	r2,r2,8
8110825c:	10000426 	beq	r2,zero,81108270 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81108260:	e0bfff17 	ldw	r2,-4(fp)
81108264:	00c00044 	movi	r3,1
81108268:	10c00c15 	stw	r3,48(r2)
8110826c:	00000206 	br	81108278 <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81108270:	e0bfff17 	ldw	r2,-4(fp)
81108274:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81108278:	e0bffe17 	ldw	r2,-8(fp)
8110827c:	1080042c 	andhi	r2,r2,16
81108280:	10000426 	beq	r2,zero,81108294 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81108284:	e0bfff17 	ldw	r2,-4(fp)
81108288:	00c00044 	movi	r3,1
8110828c:	10c00d15 	stw	r3,52(r2)
81108290:	00000206 	br	8110829c <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81108294:	e0bfff17 	ldw	r2,-4(fp)
81108298:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
8110829c:	e0bffe17 	ldw	r2,-8(fp)
811082a0:	1080082c 	andhi	r2,r2,32
811082a4:	10000426 	beq	r2,zero,811082b8 <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
811082a8:	e0bfff17 	ldw	r2,-4(fp)
811082ac:	00c00044 	movi	r3,1
811082b0:	10c00e15 	stw	r3,56(r2)
811082b4:	00000206 	br	811082c0 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
811082b8:	e0bfff17 	ldw	r2,-4(fp)
811082bc:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
811082c0:	e0bffe17 	ldw	r2,-8(fp)
811082c4:	1080102c 	andhi	r2,r2,64
811082c8:	10000426 	beq	r2,zero,811082dc <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
811082cc:	e0bfff17 	ldw	r2,-4(fp)
811082d0:	00c00044 	movi	r3,1
811082d4:	10c00f15 	stw	r3,60(r2)
811082d8:	00000206 	br	811082e4 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
811082dc:	e0bfff17 	ldw	r2,-4(fp)
811082e0:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
811082e4:	00800044 	movi	r2,1
811082e8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811082ec:	e0bffd17 	ldw	r2,-12(fp)
}
811082f0:	e037883a 	mov	sp,fp
811082f4:	dfc00117 	ldw	ra,4(sp)
811082f8:	df000017 	ldw	fp,0(sp)
811082fc:	dec00204 	addi	sp,sp,8
81108300:	f800283a 	ret

81108304 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81108304:	defffb04 	addi	sp,sp,-20
81108308:	de00012e 	bgeu	sp,et,81108310 <bRmapSetMemConfigArea+0xc>
8110830c:	003b68fa 	trap	3
81108310:	dfc00415 	stw	ra,16(sp)
81108314:	df000315 	stw	fp,12(sp)
81108318:	df000304 	addi	fp,sp,12
8110831c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108320:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81108324:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108328:	e0bfff17 	ldw	r2,-4(fp)
8110832c:	1000bc26 	beq	r2,zero,81108620 <bRmapSetMemConfigArea+0x31c>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81108330:	e0bfff17 	ldw	r2,-4(fp)
81108334:	10801217 	ldw	r2,72(r2)
81108338:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110833c:	e0bfff17 	ldw	r2,-4(fp)
81108340:	10800017 	ldw	r2,0(r2)
81108344:	e0fffe17 	ldw	r3,-8(fp)
81108348:	180d883a 	mov	r6,r3
8110834c:	01401004 	movi	r5,64
81108350:	1009883a 	mov	r4,r2
81108354:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81108358:	e0bfff17 	ldw	r2,-4(fp)
8110835c:	10801317 	ldw	r2,76(r2)
81108360:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108364:	e0bfff17 	ldw	r2,-4(fp)
81108368:	10800017 	ldw	r2,0(r2)
8110836c:	e0fffe17 	ldw	r3,-8(fp)
81108370:	180d883a 	mov	r6,r3
81108374:	01401044 	movi	r5,65
81108378:	1009883a 	mov	r4,r2
8110837c:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
81108380:	e0bfff17 	ldw	r2,-4(fp)
81108384:	10801417 	ldw	r2,80(r2)
81108388:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110838c:	e0bfff17 	ldw	r2,-4(fp)
81108390:	10800017 	ldw	r2,0(r2)
81108394:	e0fffe17 	ldw	r3,-8(fp)
81108398:	180d883a 	mov	r6,r3
8110839c:	01401084 	movi	r5,66
811083a0:	1009883a 	mov	r4,r2
811083a4:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
811083a8:	e0bfff17 	ldw	r2,-4(fp)
811083ac:	10801517 	ldw	r2,84(r2)
811083b0:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811083b4:	e0bfff17 	ldw	r2,-4(fp)
811083b8:	10800017 	ldw	r2,0(r2)
811083bc:	e0fffe17 	ldw	r3,-8(fp)
811083c0:	180d883a 	mov	r6,r3
811083c4:	014010c4 	movi	r5,67
811083c8:	1009883a 	mov	r4,r2
811083cc:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811083d0:	e0bfff17 	ldw	r2,-4(fp)
811083d4:	10802217 	ldw	r2,136(r2)
811083d8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811083dc:	e0bfff17 	ldw	r2,-4(fp)
811083e0:	10800017 	ldw	r2,0(r2)
811083e4:	e0fffe17 	ldw	r3,-8(fp)
811083e8:	180d883a 	mov	r6,r3
811083ec:	01401104 	movi	r5,68
811083f0:	1009883a 	mov	r4,r2
811083f4:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
811083f8:	e0bfff17 	ldw	r2,-4(fp)
811083fc:	10801717 	ldw	r2,92(r2)
81108400:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108404:	e0bfff17 	ldw	r2,-4(fp)
81108408:	10800017 	ldw	r2,0(r2)
8110840c:	e0fffe17 	ldw	r3,-8(fp)
81108410:	180d883a 	mov	r6,r3
81108414:	01401144 	movi	r5,69
81108418:	1009883a 	mov	r4,r2
8110841c:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81108420:	e0bfff17 	ldw	r2,-4(fp)
81108424:	10801817 	ldw	r2,96(r2)
81108428:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110842c:	e0bfff17 	ldw	r2,-4(fp)
81108430:	10800017 	ldw	r2,0(r2)
81108434:	e0fffe17 	ldw	r3,-8(fp)
81108438:	180d883a 	mov	r6,r3
8110843c:	01401184 	movi	r5,70
81108440:	1009883a 	mov	r4,r2
81108444:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81108448:	e0bfff17 	ldw	r2,-4(fp)
8110844c:	10801917 	ldw	r2,100(r2)
81108450:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108454:	e0bfff17 	ldw	r2,-4(fp)
81108458:	10800017 	ldw	r2,0(r2)
8110845c:	e0fffe17 	ldw	r3,-8(fp)
81108460:	180d883a 	mov	r6,r3
81108464:	014011c4 	movi	r5,71
81108468:	1009883a 	mov	r4,r2
8110846c:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81108470:	e0bfff17 	ldw	r2,-4(fp)
81108474:	10801a17 	ldw	r2,104(r2)
81108478:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110847c:	e0bfff17 	ldw	r2,-4(fp)
81108480:	10800017 	ldw	r2,0(r2)
81108484:	e0fffe17 	ldw	r3,-8(fp)
81108488:	180d883a 	mov	r6,r3
8110848c:	01401204 	movi	r5,72
81108490:	1009883a 	mov	r4,r2
81108494:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
81108498:	e0bfff17 	ldw	r2,-4(fp)
8110849c:	10801b17 	ldw	r2,108(r2)
811084a0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811084a4:	e0bfff17 	ldw	r2,-4(fp)
811084a8:	10800017 	ldw	r2,0(r2)
811084ac:	e0fffe17 	ldw	r3,-8(fp)
811084b0:	180d883a 	mov	r6,r3
811084b4:	01401244 	movi	r5,73
811084b8:	1009883a 	mov	r4,r2
811084bc:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084c0:	e0bfff17 	ldw	r2,-4(fp)
811084c4:	10800017 	ldw	r2,0(r2)
811084c8:	01401284 	movi	r5,74
811084cc:	1009883a 	mov	r4,r2
811084d0:	110a4980 	call	8110a498 <uliRmapReadReg>
811084d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
811084d8:	e0bfff17 	ldw	r2,-4(fp)
811084dc:	10801c17 	ldw	r2,112(r2)
811084e0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811084e4:	e0bfff17 	ldw	r2,-4(fp)
811084e8:	10800017 	ldw	r2,0(r2)
811084ec:	e0fffe17 	ldw	r3,-8(fp)
811084f0:	180d883a 	mov	r6,r3
811084f4:	01401284 	movi	r5,74
811084f8:	1009883a 	mov	r4,r2
811084fc:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
81108500:	e0bfff17 	ldw	r2,-4(fp)
81108504:	10801d17 	ldw	r2,116(r2)
81108508:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110850c:	e0bfff17 	ldw	r2,-4(fp)
81108510:	10800017 	ldw	r2,0(r2)
81108514:	e0fffe17 	ldw	r3,-8(fp)
81108518:	180d883a 	mov	r6,r3
8110851c:	014012c4 	movi	r5,75
81108520:	1009883a 	mov	r4,r2
81108524:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
81108528:	e0bfff17 	ldw	r2,-4(fp)
8110852c:	10801e17 	ldw	r2,120(r2)
81108530:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81108534:	e0bfff17 	ldw	r2,-4(fp)
81108538:	10800017 	ldw	r2,0(r2)
8110853c:	e0fffe17 	ldw	r3,-8(fp)
81108540:	180d883a 	mov	r6,r3
81108544:	01401304 	movi	r5,76
81108548:	1009883a 	mov	r4,r2
8110854c:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
81108550:	e0bfff17 	ldw	r2,-4(fp)
81108554:	10801f17 	ldw	r2,124(r2)
81108558:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
8110855c:	e0bfff17 	ldw	r2,-4(fp)
81108560:	10800017 	ldw	r2,0(r2)
81108564:	e0fffe17 	ldw	r3,-8(fp)
81108568:	180d883a 	mov	r6,r3
8110856c:	01401344 	movi	r5,77
81108570:	1009883a 	mov	r4,r2
81108574:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
81108578:	e0bfff17 	ldw	r2,-4(fp)
8110857c:	10802017 	ldw	r2,128(r2)
81108580:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
81108584:	e0bfff17 	ldw	r2,-4(fp)
81108588:	10800017 	ldw	r2,0(r2)
8110858c:	e0fffe17 	ldw	r3,-8(fp)
81108590:	180d883a 	mov	r6,r3
81108594:	01401384 	movi	r5,78
81108598:	1009883a 	mov	r4,r2
8110859c:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811085a0:	e0bfff17 	ldw	r2,-4(fp)
811085a4:	10802217 	ldw	r2,136(r2)
811085a8:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811085ac:	e0bfff17 	ldw	r2,-4(fp)
811085b0:	10800017 	ldw	r2,0(r2)
811085b4:	e0fffe17 	ldw	r3,-8(fp)
811085b8:	180d883a 	mov	r6,r3
811085bc:	014013c4 	movi	r5,79
811085c0:	1009883a 	mov	r4,r2
811085c4:	110a4440 	call	8110a444 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811085c8:	e0bfff17 	ldw	r2,-4(fp)
811085cc:	10802217 	ldw	r2,136(r2)
811085d0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
811085d4:	e0bfff17 	ldw	r2,-4(fp)
811085d8:	10800017 	ldw	r2,0(r2)
811085dc:	e0fffe17 	ldw	r3,-8(fp)
811085e0:	180d883a 	mov	r6,r3
811085e4:	01401404 	movi	r5,80
811085e8:	1009883a 	mov	r4,r2
811085ec:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
811085f0:	e0bfff17 	ldw	r2,-4(fp)
811085f4:	10802317 	ldw	r2,140(r2)
811085f8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
811085fc:	e0bfff17 	ldw	r2,-4(fp)
81108600:	10800017 	ldw	r2,0(r2)
81108604:	e0fffe17 	ldw	r3,-8(fp)
81108608:	180d883a 	mov	r6,r3
8110860c:	01401444 	movi	r5,81
81108610:	1009883a 	mov	r4,r2
81108614:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108618:	00800044 	movi	r2,1
8110861c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108620:	e0bffd17 	ldw	r2,-12(fp)
}
81108624:	e037883a 	mov	sp,fp
81108628:	dfc00117 	ldw	ra,4(sp)
8110862c:	df000017 	ldw	fp,0(sp)
81108630:	dec00204 	addi	sp,sp,8
81108634:	f800283a 	ret

81108638 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81108638:	defffb04 	addi	sp,sp,-20
8110863c:	de00012e 	bgeu	sp,et,81108644 <bRmapGetMemConfigArea+0xc>
81108640:	003b68fa 	trap	3
81108644:	dfc00415 	stw	ra,16(sp)
81108648:	df000315 	stw	fp,12(sp)
8110864c:	df000304 	addi	fp,sp,12
81108650:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108654:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81108658:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110865c:	e0bfff17 	ldw	r2,-4(fp)
81108660:	1000a426 	beq	r2,zero,811088f4 <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108664:	e0bfff17 	ldw	r2,-4(fp)
81108668:	10800017 	ldw	r2,0(r2)
8110866c:	01401004 	movi	r5,64
81108670:	1009883a 	mov	r4,r2
81108674:	110a4980 	call	8110a498 <uliRmapReadReg>
81108678:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
8110867c:	e0fffe17 	ldw	r3,-8(fp)
81108680:	e0bfff17 	ldw	r2,-4(fp)
81108684:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108688:	e0bfff17 	ldw	r2,-4(fp)
8110868c:	10800017 	ldw	r2,0(r2)
81108690:	01401044 	movi	r5,65
81108694:	1009883a 	mov	r4,r2
81108698:	110a4980 	call	8110a498 <uliRmapReadReg>
8110869c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
811086a0:	e0fffe17 	ldw	r3,-8(fp)
811086a4:	e0bfff17 	ldw	r2,-4(fp)
811086a8:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086ac:	e0bfff17 	ldw	r2,-4(fp)
811086b0:	10800017 	ldw	r2,0(r2)
811086b4:	01401084 	movi	r5,66
811086b8:	1009883a 	mov	r4,r2
811086bc:	110a4980 	call	8110a498 <uliRmapReadReg>
811086c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
811086c4:	e0fffe17 	ldw	r3,-8(fp)
811086c8:	e0bfff17 	ldw	r2,-4(fp)
811086cc:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086d0:	e0bfff17 	ldw	r2,-4(fp)
811086d4:	10800017 	ldw	r2,0(r2)
811086d8:	014010c4 	movi	r5,67
811086dc:	1009883a 	mov	r4,r2
811086e0:	110a4980 	call	8110a498 <uliRmapReadReg>
811086e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
811086e8:	e0fffe17 	ldw	r3,-8(fp)
811086ec:	e0bfff17 	ldw	r2,-4(fp)
811086f0:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086f4:	e0bfff17 	ldw	r2,-4(fp)
811086f8:	10800017 	ldw	r2,0(r2)
811086fc:	01401104 	movi	r5,68
81108700:	1009883a 	mov	r4,r2
81108704:	110a4980 	call	8110a498 <uliRmapReadReg>
81108708:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
8110870c:	e0fffe17 	ldw	r3,-8(fp)
81108710:	e0bfff17 	ldw	r2,-4(fp)
81108714:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108718:	e0bfff17 	ldw	r2,-4(fp)
8110871c:	10800017 	ldw	r2,0(r2)
81108720:	01401144 	movi	r5,69
81108724:	1009883a 	mov	r4,r2
81108728:	110a4980 	call	8110a498 <uliRmapReadReg>
8110872c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
81108730:	e0fffe17 	ldw	r3,-8(fp)
81108734:	e0bfff17 	ldw	r2,-4(fp)
81108738:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110873c:	e0bfff17 	ldw	r2,-4(fp)
81108740:	10800017 	ldw	r2,0(r2)
81108744:	01401184 	movi	r5,70
81108748:	1009883a 	mov	r4,r2
8110874c:	110a4980 	call	8110a498 <uliRmapReadReg>
81108750:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
81108754:	e0fffe17 	ldw	r3,-8(fp)
81108758:	e0bfff17 	ldw	r2,-4(fp)
8110875c:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108760:	e0bfff17 	ldw	r2,-4(fp)
81108764:	10800017 	ldw	r2,0(r2)
81108768:	014011c4 	movi	r5,71
8110876c:	1009883a 	mov	r4,r2
81108770:	110a4980 	call	8110a498 <uliRmapReadReg>
81108774:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
81108778:	e0fffe17 	ldw	r3,-8(fp)
8110877c:	e0bfff17 	ldw	r2,-4(fp)
81108780:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108784:	e0bfff17 	ldw	r2,-4(fp)
81108788:	10800017 	ldw	r2,0(r2)
8110878c:	01401204 	movi	r5,72
81108790:	1009883a 	mov	r4,r2
81108794:	110a4980 	call	8110a498 <uliRmapReadReg>
81108798:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
8110879c:	e0fffe17 	ldw	r3,-8(fp)
811087a0:	e0bfff17 	ldw	r2,-4(fp)
811087a4:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087a8:	e0bfff17 	ldw	r2,-4(fp)
811087ac:	10800017 	ldw	r2,0(r2)
811087b0:	01401244 	movi	r5,73
811087b4:	1009883a 	mov	r4,r2
811087b8:	110a4980 	call	8110a498 <uliRmapReadReg>
811087bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
811087c0:	e0fffe17 	ldw	r3,-8(fp)
811087c4:	e0bfff17 	ldw	r2,-4(fp)
811087c8:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087cc:	e0bfff17 	ldw	r2,-4(fp)
811087d0:	10800017 	ldw	r2,0(r2)
811087d4:	01401284 	movi	r5,74
811087d8:	1009883a 	mov	r4,r2
811087dc:	110a4980 	call	8110a498 <uliRmapReadReg>
811087e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
811087e4:	e0fffe17 	ldw	r3,-8(fp)
811087e8:	e0bfff17 	ldw	r2,-4(fp)
811087ec:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087f0:	e0bfff17 	ldw	r2,-4(fp)
811087f4:	10800017 	ldw	r2,0(r2)
811087f8:	014012c4 	movi	r5,75
811087fc:	1009883a 	mov	r4,r2
81108800:	110a4980 	call	8110a498 <uliRmapReadReg>
81108804:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
81108808:	e0fffe17 	ldw	r3,-8(fp)
8110880c:	e0bfff17 	ldw	r2,-4(fp)
81108810:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108814:	e0bfff17 	ldw	r2,-4(fp)
81108818:	10800017 	ldw	r2,0(r2)
8110881c:	01401304 	movi	r5,76
81108820:	1009883a 	mov	r4,r2
81108824:	110a4980 	call	8110a498 <uliRmapReadReg>
81108828:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
8110882c:	e0fffe17 	ldw	r3,-8(fp)
81108830:	e0bfff17 	ldw	r2,-4(fp)
81108834:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108838:	e0bfff17 	ldw	r2,-4(fp)
8110883c:	10800017 	ldw	r2,0(r2)
81108840:	01401344 	movi	r5,77
81108844:	1009883a 	mov	r4,r2
81108848:	110a4980 	call	8110a498 <uliRmapReadReg>
8110884c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
81108850:	e0fffe17 	ldw	r3,-8(fp)
81108854:	e0bfff17 	ldw	r2,-4(fp)
81108858:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110885c:	e0bfff17 	ldw	r2,-4(fp)
81108860:	10800017 	ldw	r2,0(r2)
81108864:	01401384 	movi	r5,78
81108868:	1009883a 	mov	r4,r2
8110886c:	110a4980 	call	8110a498 <uliRmapReadReg>
81108870:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
81108874:	e0fffe17 	ldw	r3,-8(fp)
81108878:	e0bfff17 	ldw	r2,-4(fp)
8110887c:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108880:	e0bfff17 	ldw	r2,-4(fp)
81108884:	10800017 	ldw	r2,0(r2)
81108888:	014013c4 	movi	r5,79
8110888c:	1009883a 	mov	r4,r2
81108890:	110a4980 	call	8110a498 <uliRmapReadReg>
81108894:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81108898:	e0fffe17 	ldw	r3,-8(fp)
8110889c:	e0bfff17 	ldw	r2,-4(fp)
811088a0:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088a4:	e0bfff17 	ldw	r2,-4(fp)
811088a8:	10800017 	ldw	r2,0(r2)
811088ac:	01401404 	movi	r5,80
811088b0:	1009883a 	mov	r4,r2
811088b4:	110a4980 	call	8110a498 <uliRmapReadReg>
811088b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811088bc:	e0fffe17 	ldw	r3,-8(fp)
811088c0:	e0bfff17 	ldw	r2,-4(fp)
811088c4:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088c8:	e0bfff17 	ldw	r2,-4(fp)
811088cc:	10800017 	ldw	r2,0(r2)
811088d0:	01401444 	movi	r5,81
811088d4:	1009883a 	mov	r4,r2
811088d8:	110a4980 	call	8110a498 <uliRmapReadReg>
811088dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
811088e0:	e0fffe17 	ldw	r3,-8(fp)
811088e4:	e0bfff17 	ldw	r2,-4(fp)
811088e8:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
811088ec:	00800044 	movi	r2,1
811088f0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811088f4:	e0bffd17 	ldw	r2,-12(fp)
}
811088f8:	e037883a 	mov	sp,fp
811088fc:	dfc00117 	ldw	ra,4(sp)
81108900:	df000017 	ldw	fp,0(sp)
81108904:	dec00204 	addi	sp,sp,8
81108908:	f800283a 	ret

8110890c <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
8110890c:	defffb04 	addi	sp,sp,-20
81108910:	de00012e 	bgeu	sp,et,81108918 <bRmapGetMemConfigStat+0xc>
81108914:	003b68fa 	trap	3
81108918:	dfc00415 	stw	ra,16(sp)
8110891c:	df000315 	stw	fp,12(sp)
81108920:	df000304 	addi	fp,sp,12
81108924:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108928:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110892c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108930:	e0bfff17 	ldw	r2,-4(fp)
81108934:	10001426 	beq	r2,zero,81108988 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108938:	e0bfff17 	ldw	r2,-4(fp)
8110893c:	10800017 	ldw	r2,0(r2)
81108940:	014001c4 	movi	r5,7
81108944:	1009883a 	mov	r4,r2
81108948:	110a4980 	call	8110a498 <uliRmapReadReg>
8110894c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
81108950:	e0fffe17 	ldw	r3,-8(fp)
81108954:	e0bfff17 	ldw	r2,-4(fp)
81108958:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110895c:	e0bfff17 	ldw	r2,-4(fp)
81108960:	10800017 	ldw	r2,0(r2)
81108964:	01400184 	movi	r5,6
81108968:	1009883a 	mov	r4,r2
8110896c:	110a4980 	call	8110a498 <uliRmapReadReg>
81108970:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
81108974:	e0fffe17 	ldw	r3,-8(fp)
81108978:	e0bfff17 	ldw	r2,-4(fp)
8110897c:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
81108980:	00800044 	movi	r2,1
81108984:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108988:	e0bffd17 	ldw	r2,-12(fp)
}
8110898c:	e037883a 	mov	sp,fp
81108990:	dfc00117 	ldw	ra,4(sp)
81108994:	df000017 	ldw	fp,0(sp)
81108998:	dec00204 	addi	sp,sp,8
8110899c:	f800283a 	ret

811089a0 <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811089a0:	defffb04 	addi	sp,sp,-20
811089a4:	de00012e 	bgeu	sp,et,811089ac <bRmapSetRmapMemHKArea+0xc>
811089a8:	003b68fa 	trap	3
811089ac:	dfc00415 	stw	ra,16(sp)
811089b0:	df000315 	stw	fp,12(sp)
811089b4:	df000304 	addi	fp,sp,12
811089b8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811089bc:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
811089c0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811089c4:	e0bfff17 	ldw	r2,-4(fp)
811089c8:	10042226 	beq	r2,zero,81109a54 <bRmapSetRmapMemHKArea+0x10b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089cc:	e0bfff17 	ldw	r2,-4(fp)
811089d0:	10800017 	ldw	r2,0(r2)
811089d4:	01402804 	movi	r5,160
811089d8:	1009883a 	mov	r4,r2
811089dc:	110a4980 	call	8110a498 <uliRmapReadReg>
811089e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
811089e4:	e0bffe17 	ldw	r2,-8(fp)
811089e8:	10bfffec 	andhi	r2,r2,65535
811089ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
811089f0:	e0bfff17 	ldw	r2,-4(fp)
811089f4:	1080260b 	ldhu	r2,152(r2)
811089f8:	10ffffcc 	andi	r3,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
811089fc:	e0bffe17 	ldw	r2,-8(fp)
81108a00:	1884b03a 	or	r2,r3,r2
81108a04:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
81108a08:	e0bffe17 	ldw	r2,-8(fp)
81108a0c:	10bfffcc 	andi	r2,r2,65535
81108a10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
81108a14:	e0bfff17 	ldw	r2,-4(fp)
81108a18:	1080268b 	ldhu	r2,154(r2)
81108a1c:	10bfffcc 	andi	r2,r2,65535
81108a20:	1004943a 	slli	r2,r2,16
81108a24:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
81108a28:	e0bffe17 	ldw	r2,-8(fp)
81108a2c:	1884b03a 	or	r2,r3,r2
81108a30:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
81108a34:	e0bfff17 	ldw	r2,-4(fp)
81108a38:	10800017 	ldw	r2,0(r2)
81108a3c:	e0fffe17 	ldw	r3,-8(fp)
81108a40:	180d883a 	mov	r6,r3
81108a44:	01402804 	movi	r5,160
81108a48:	1009883a 	mov	r4,r2
81108a4c:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a50:	e0bfff17 	ldw	r2,-4(fp)
81108a54:	10800017 	ldw	r2,0(r2)
81108a58:	01402844 	movi	r5,161
81108a5c:	1009883a 	mov	r4,r2
81108a60:	110a4980 	call	8110a498 <uliRmapReadReg>
81108a64:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
81108a68:	e0bffe17 	ldw	r2,-8(fp)
81108a6c:	10bfffec 	andhi	r2,r2,65535
81108a70:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
81108a74:	e0bfff17 	ldw	r2,-4(fp)
81108a78:	1080270b 	ldhu	r2,156(r2)
81108a7c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
81108a80:	e0bffe17 	ldw	r2,-8(fp)
81108a84:	1884b03a 	or	r2,r3,r2
81108a88:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
81108a8c:	e0bffe17 	ldw	r2,-8(fp)
81108a90:	10bfffcc 	andi	r2,r2,65535
81108a94:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
81108a98:	e0bfff17 	ldw	r2,-4(fp)
81108a9c:	1080278b 	ldhu	r2,158(r2)
81108aa0:	10bfffcc 	andi	r2,r2,65535
81108aa4:	1004943a 	slli	r2,r2,16
81108aa8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
81108aac:	e0bffe17 	ldw	r2,-8(fp)
81108ab0:	1884b03a 	or	r2,r3,r2
81108ab4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
81108ab8:	e0bfff17 	ldw	r2,-4(fp)
81108abc:	10800017 	ldw	r2,0(r2)
81108ac0:	e0fffe17 	ldw	r3,-8(fp)
81108ac4:	180d883a 	mov	r6,r3
81108ac8:	01402844 	movi	r5,161
81108acc:	1009883a 	mov	r4,r2
81108ad0:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ad4:	e0bfff17 	ldw	r2,-4(fp)
81108ad8:	10800017 	ldw	r2,0(r2)
81108adc:	01402884 	movi	r5,162
81108ae0:	1009883a 	mov	r4,r2
81108ae4:	110a4980 	call	8110a498 <uliRmapReadReg>
81108ae8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
81108aec:	e0bffe17 	ldw	r2,-8(fp)
81108af0:	10bfffec 	andhi	r2,r2,65535
81108af4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
81108af8:	e0bfff17 	ldw	r2,-4(fp)
81108afc:	1080280b 	ldhu	r2,160(r2)
81108b00:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
81108b04:	e0bffe17 	ldw	r2,-8(fp)
81108b08:	1884b03a 	or	r2,r3,r2
81108b0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
81108b10:	e0bffe17 	ldw	r2,-8(fp)
81108b14:	10bfffcc 	andi	r2,r2,65535
81108b18:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
81108b1c:	e0bfff17 	ldw	r2,-4(fp)
81108b20:	1080288b 	ldhu	r2,162(r2)
81108b24:	10bfffcc 	andi	r2,r2,65535
81108b28:	1004943a 	slli	r2,r2,16
81108b2c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
81108b30:	e0bffe17 	ldw	r2,-8(fp)
81108b34:	1884b03a 	or	r2,r3,r2
81108b38:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
81108b3c:	e0bfff17 	ldw	r2,-4(fp)
81108b40:	10800017 	ldw	r2,0(r2)
81108b44:	e0fffe17 	ldw	r3,-8(fp)
81108b48:	180d883a 	mov	r6,r3
81108b4c:	01402884 	movi	r5,162
81108b50:	1009883a 	mov	r4,r2
81108b54:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b58:	e0bfff17 	ldw	r2,-4(fp)
81108b5c:	10800017 	ldw	r2,0(r2)
81108b60:	014028c4 	movi	r5,163
81108b64:	1009883a 	mov	r4,r2
81108b68:	110a4980 	call	8110a498 <uliRmapReadReg>
81108b6c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
81108b70:	e0bffe17 	ldw	r2,-8(fp)
81108b74:	10bfffec 	andhi	r2,r2,65535
81108b78:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
81108b7c:	e0bfff17 	ldw	r2,-4(fp)
81108b80:	1080290b 	ldhu	r2,164(r2)
81108b84:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
81108b88:	e0bffe17 	ldw	r2,-8(fp)
81108b8c:	1884b03a 	or	r2,r3,r2
81108b90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
81108b94:	e0bffe17 	ldw	r2,-8(fp)
81108b98:	10bfffcc 	andi	r2,r2,65535
81108b9c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
81108ba0:	e0bfff17 	ldw	r2,-4(fp)
81108ba4:	1080298b 	ldhu	r2,166(r2)
81108ba8:	10bfffcc 	andi	r2,r2,65535
81108bac:	1004943a 	slli	r2,r2,16
81108bb0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
81108bb4:	e0bffe17 	ldw	r2,-8(fp)
81108bb8:	1884b03a 	or	r2,r3,r2
81108bbc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
81108bc0:	e0bfff17 	ldw	r2,-4(fp)
81108bc4:	10800017 	ldw	r2,0(r2)
81108bc8:	e0fffe17 	ldw	r3,-8(fp)
81108bcc:	180d883a 	mov	r6,r3
81108bd0:	014028c4 	movi	r5,163
81108bd4:	1009883a 	mov	r4,r2
81108bd8:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108bdc:	e0bfff17 	ldw	r2,-4(fp)
81108be0:	10800017 	ldw	r2,0(r2)
81108be4:	01402904 	movi	r5,164
81108be8:	1009883a 	mov	r4,r2
81108bec:	110a4980 	call	8110a498 <uliRmapReadReg>
81108bf0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
81108bf4:	e0bffe17 	ldw	r2,-8(fp)
81108bf8:	10bfffec 	andhi	r2,r2,65535
81108bfc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
81108c00:	e0bfff17 	ldw	r2,-4(fp)
81108c04:	10802a0b 	ldhu	r2,168(r2)
81108c08:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
81108c0c:	e0bffe17 	ldw	r2,-8(fp)
81108c10:	1884b03a 	or	r2,r3,r2
81108c14:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
81108c18:	e0bffe17 	ldw	r2,-8(fp)
81108c1c:	10bfffcc 	andi	r2,r2,65535
81108c20:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
81108c24:	e0bfff17 	ldw	r2,-4(fp)
81108c28:	10802a8b 	ldhu	r2,170(r2)
81108c2c:	10bfffcc 	andi	r2,r2,65535
81108c30:	1004943a 	slli	r2,r2,16
81108c34:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
81108c38:	e0bffe17 	ldw	r2,-8(fp)
81108c3c:	1884b03a 	or	r2,r3,r2
81108c40:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
81108c44:	e0bfff17 	ldw	r2,-4(fp)
81108c48:	10800017 	ldw	r2,0(r2)
81108c4c:	e0fffe17 	ldw	r3,-8(fp)
81108c50:	180d883a 	mov	r6,r3
81108c54:	01402904 	movi	r5,164
81108c58:	1009883a 	mov	r4,r2
81108c5c:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c60:	e0bfff17 	ldw	r2,-4(fp)
81108c64:	10800017 	ldw	r2,0(r2)
81108c68:	01402944 	movi	r5,165
81108c6c:	1009883a 	mov	r4,r2
81108c70:	110a4980 	call	8110a498 <uliRmapReadReg>
81108c74:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
81108c78:	e0bffe17 	ldw	r2,-8(fp)
81108c7c:	10bfffec 	andhi	r2,r2,65535
81108c80:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
81108c84:	e0bfff17 	ldw	r2,-4(fp)
81108c88:	10802b0b 	ldhu	r2,172(r2)
81108c8c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
81108c90:	e0bffe17 	ldw	r2,-8(fp)
81108c94:	1884b03a 	or	r2,r3,r2
81108c98:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
81108c9c:	e0bffe17 	ldw	r2,-8(fp)
81108ca0:	10bfffcc 	andi	r2,r2,65535
81108ca4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
81108ca8:	e0bfff17 	ldw	r2,-4(fp)
81108cac:	10802b8b 	ldhu	r2,174(r2)
81108cb0:	10bfffcc 	andi	r2,r2,65535
81108cb4:	1004943a 	slli	r2,r2,16
81108cb8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
81108cbc:	e0bffe17 	ldw	r2,-8(fp)
81108cc0:	1884b03a 	or	r2,r3,r2
81108cc4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
81108cc8:	e0bfff17 	ldw	r2,-4(fp)
81108ccc:	10800017 	ldw	r2,0(r2)
81108cd0:	e0fffe17 	ldw	r3,-8(fp)
81108cd4:	180d883a 	mov	r6,r3
81108cd8:	01402944 	movi	r5,165
81108cdc:	1009883a 	mov	r4,r2
81108ce0:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ce4:	e0bfff17 	ldw	r2,-4(fp)
81108ce8:	10800017 	ldw	r2,0(r2)
81108cec:	01402984 	movi	r5,166
81108cf0:	1009883a 	mov	r4,r2
81108cf4:	110a4980 	call	8110a498 <uliRmapReadReg>
81108cf8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
81108cfc:	e0bffe17 	ldw	r2,-8(fp)
81108d00:	10bfffec 	andhi	r2,r2,65535
81108d04:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
81108d08:	e0bfff17 	ldw	r2,-4(fp)
81108d0c:	10802c0b 	ldhu	r2,176(r2)
81108d10:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
81108d14:	e0bffe17 	ldw	r2,-8(fp)
81108d18:	1884b03a 	or	r2,r3,r2
81108d1c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
81108d20:	e0bffe17 	ldw	r2,-8(fp)
81108d24:	10bfffcc 	andi	r2,r2,65535
81108d28:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
81108d2c:	e0bfff17 	ldw	r2,-4(fp)
81108d30:	10802c8b 	ldhu	r2,178(r2)
81108d34:	10bfffcc 	andi	r2,r2,65535
81108d38:	1004943a 	slli	r2,r2,16
81108d3c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
81108d40:	e0bffe17 	ldw	r2,-8(fp)
81108d44:	1884b03a 	or	r2,r3,r2
81108d48:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
81108d4c:	e0bfff17 	ldw	r2,-4(fp)
81108d50:	10800017 	ldw	r2,0(r2)
81108d54:	e0fffe17 	ldw	r3,-8(fp)
81108d58:	180d883a 	mov	r6,r3
81108d5c:	01402984 	movi	r5,166
81108d60:	1009883a 	mov	r4,r2
81108d64:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d68:	e0bfff17 	ldw	r2,-4(fp)
81108d6c:	10800017 	ldw	r2,0(r2)
81108d70:	014029c4 	movi	r5,167
81108d74:	1009883a 	mov	r4,r2
81108d78:	110a4980 	call	8110a498 <uliRmapReadReg>
81108d7c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
81108d80:	e0bffe17 	ldw	r2,-8(fp)
81108d84:	10bfffec 	andhi	r2,r2,65535
81108d88:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
81108d8c:	e0bfff17 	ldw	r2,-4(fp)
81108d90:	10802d0b 	ldhu	r2,180(r2)
81108d94:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
81108d98:	e0bffe17 	ldw	r2,-8(fp)
81108d9c:	1884b03a 	or	r2,r3,r2
81108da0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
81108da4:	e0bffe17 	ldw	r2,-8(fp)
81108da8:	10bfffcc 	andi	r2,r2,65535
81108dac:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
81108db0:	e0bfff17 	ldw	r2,-4(fp)
81108db4:	10802d8b 	ldhu	r2,182(r2)
81108db8:	10bfffcc 	andi	r2,r2,65535
81108dbc:	1004943a 	slli	r2,r2,16
81108dc0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
81108dc4:	e0bffe17 	ldw	r2,-8(fp)
81108dc8:	1884b03a 	or	r2,r3,r2
81108dcc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
81108dd0:	e0bfff17 	ldw	r2,-4(fp)
81108dd4:	10800017 	ldw	r2,0(r2)
81108dd8:	e0fffe17 	ldw	r3,-8(fp)
81108ddc:	180d883a 	mov	r6,r3
81108de0:	014029c4 	movi	r5,167
81108de4:	1009883a 	mov	r4,r2
81108de8:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108dec:	e0bfff17 	ldw	r2,-4(fp)
81108df0:	10800017 	ldw	r2,0(r2)
81108df4:	01402a04 	movi	r5,168
81108df8:	1009883a 	mov	r4,r2
81108dfc:	110a4980 	call	8110a498 <uliRmapReadReg>
81108e00:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
81108e04:	e0bffe17 	ldw	r2,-8(fp)
81108e08:	10bfffec 	andhi	r2,r2,65535
81108e0c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
81108e10:	e0bfff17 	ldw	r2,-4(fp)
81108e14:	10802e0b 	ldhu	r2,184(r2)
81108e18:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81108e1c:	e0bffe17 	ldw	r2,-8(fp)
81108e20:	1884b03a 	or	r2,r3,r2
81108e24:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
81108e28:	e0bffe17 	ldw	r2,-8(fp)
81108e2c:	10bfffcc 	andi	r2,r2,65535
81108e30:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
81108e34:	e0bfff17 	ldw	r2,-4(fp)
81108e38:	10802e8b 	ldhu	r2,186(r2)
81108e3c:	10bfffcc 	andi	r2,r2,65535
81108e40:	1004943a 	slli	r2,r2,16
81108e44:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
81108e48:	e0bffe17 	ldw	r2,-8(fp)
81108e4c:	1884b03a 	or	r2,r3,r2
81108e50:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81108e54:	e0bfff17 	ldw	r2,-4(fp)
81108e58:	10800017 	ldw	r2,0(r2)
81108e5c:	e0fffe17 	ldw	r3,-8(fp)
81108e60:	180d883a 	mov	r6,r3
81108e64:	01402a04 	movi	r5,168
81108e68:	1009883a 	mov	r4,r2
81108e6c:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e70:	e0bfff17 	ldw	r2,-4(fp)
81108e74:	10800017 	ldw	r2,0(r2)
81108e78:	01402a44 	movi	r5,169
81108e7c:	1009883a 	mov	r4,r2
81108e80:	110a4980 	call	8110a498 <uliRmapReadReg>
81108e84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
81108e88:	e0bffe17 	ldw	r2,-8(fp)
81108e8c:	10bfffec 	andhi	r2,r2,65535
81108e90:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
81108e94:	e0bfff17 	ldw	r2,-4(fp)
81108e98:	10802f0b 	ldhu	r2,188(r2)
81108e9c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
81108ea0:	e0bffe17 	ldw	r2,-8(fp)
81108ea4:	1884b03a 	or	r2,r3,r2
81108ea8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
81108eac:	e0bffe17 	ldw	r2,-8(fp)
81108eb0:	10bfffcc 	andi	r2,r2,65535
81108eb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
81108eb8:	e0bfff17 	ldw	r2,-4(fp)
81108ebc:	10802f8b 	ldhu	r2,190(r2)
81108ec0:	10bfffcc 	andi	r2,r2,65535
81108ec4:	1004943a 	slli	r2,r2,16
81108ec8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
81108ecc:	e0bffe17 	ldw	r2,-8(fp)
81108ed0:	1884b03a 	or	r2,r3,r2
81108ed4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
81108ed8:	e0bfff17 	ldw	r2,-4(fp)
81108edc:	10800017 	ldw	r2,0(r2)
81108ee0:	e0fffe17 	ldw	r3,-8(fp)
81108ee4:	180d883a 	mov	r6,r3
81108ee8:	01402a44 	movi	r5,169
81108eec:	1009883a 	mov	r4,r2
81108ef0:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ef4:	e0bfff17 	ldw	r2,-4(fp)
81108ef8:	10800017 	ldw	r2,0(r2)
81108efc:	01402a84 	movi	r5,170
81108f00:	1009883a 	mov	r4,r2
81108f04:	110a4980 	call	8110a498 <uliRmapReadReg>
81108f08:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81108f0c:	e0bffe17 	ldw	r2,-8(fp)
81108f10:	10bfffec 	andhi	r2,r2,65535
81108f14:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
81108f18:	e0bfff17 	ldw	r2,-4(fp)
81108f1c:	1080300b 	ldhu	r2,192(r2)
81108f20:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81108f24:	e0bffe17 	ldw	r2,-8(fp)
81108f28:	1884b03a 	or	r2,r3,r2
81108f2c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81108f30:	e0bffe17 	ldw	r2,-8(fp)
81108f34:	10bfffcc 	andi	r2,r2,65535
81108f38:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
81108f3c:	e0bfff17 	ldw	r2,-4(fp)
81108f40:	1080308b 	ldhu	r2,194(r2)
81108f44:	10bfffcc 	andi	r2,r2,65535
81108f48:	1004943a 	slli	r2,r2,16
81108f4c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
81108f50:	e0bffe17 	ldw	r2,-8(fp)
81108f54:	1884b03a 	or	r2,r3,r2
81108f58:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81108f5c:	e0bfff17 	ldw	r2,-4(fp)
81108f60:	10800017 	ldw	r2,0(r2)
81108f64:	e0fffe17 	ldw	r3,-8(fp)
81108f68:	180d883a 	mov	r6,r3
81108f6c:	01402a84 	movi	r5,170
81108f70:	1009883a 	mov	r4,r2
81108f74:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f78:	e0bfff17 	ldw	r2,-4(fp)
81108f7c:	10800017 	ldw	r2,0(r2)
81108f80:	01402ac4 	movi	r5,171
81108f84:	1009883a 	mov	r4,r2
81108f88:	110a4980 	call	8110a498 <uliRmapReadReg>
81108f8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81108f90:	e0bffe17 	ldw	r2,-8(fp)
81108f94:	10bfffec 	andhi	r2,r2,65535
81108f98:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81108f9c:	e0bfff17 	ldw	r2,-4(fp)
81108fa0:	1080310b 	ldhu	r2,196(r2)
81108fa4:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
81108fa8:	e0bffe17 	ldw	r2,-8(fp)
81108fac:	1884b03a 	or	r2,r3,r2
81108fb0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
81108fb4:	e0bffe17 	ldw	r2,-8(fp)
81108fb8:	10bfffcc 	andi	r2,r2,65535
81108fbc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
81108fc0:	e0bfff17 	ldw	r2,-4(fp)
81108fc4:	1080318b 	ldhu	r2,198(r2)
81108fc8:	10bfffcc 	andi	r2,r2,65535
81108fcc:	1004943a 	slli	r2,r2,16
81108fd0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
81108fd4:	e0bffe17 	ldw	r2,-8(fp)
81108fd8:	1884b03a 	or	r2,r3,r2
81108fdc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81108fe0:	e0bfff17 	ldw	r2,-4(fp)
81108fe4:	10800017 	ldw	r2,0(r2)
81108fe8:	e0fffe17 	ldw	r3,-8(fp)
81108fec:	180d883a 	mov	r6,r3
81108ff0:	01402ac4 	movi	r5,171
81108ff4:	1009883a 	mov	r4,r2
81108ff8:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ffc:	e0bfff17 	ldw	r2,-4(fp)
81109000:	10800017 	ldw	r2,0(r2)
81109004:	01402b04 	movi	r5,172
81109008:	1009883a 	mov	r4,r2
8110900c:	110a4980 	call	8110a498 <uliRmapReadReg>
81109010:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
81109014:	e0bffe17 	ldw	r2,-8(fp)
81109018:	10bfffec 	andhi	r2,r2,65535
8110901c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
81109020:	e0bfff17 	ldw	r2,-4(fp)
81109024:	1080320b 	ldhu	r2,200(r2)
81109028:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
8110902c:	e0bffe17 	ldw	r2,-8(fp)
81109030:	1884b03a 	or	r2,r3,r2
81109034:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
81109038:	e0bffe17 	ldw	r2,-8(fp)
8110903c:	10bfffcc 	andi	r2,r2,65535
81109040:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
81109044:	e0bfff17 	ldw	r2,-4(fp)
81109048:	1080328b 	ldhu	r2,202(r2)
8110904c:	10bfffcc 	andi	r2,r2,65535
81109050:	1004943a 	slli	r2,r2,16
81109054:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
81109058:	e0bffe17 	ldw	r2,-8(fp)
8110905c:	1884b03a 	or	r2,r3,r2
81109060:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81109064:	e0bfff17 	ldw	r2,-4(fp)
81109068:	10800017 	ldw	r2,0(r2)
8110906c:	e0fffe17 	ldw	r3,-8(fp)
81109070:	180d883a 	mov	r6,r3
81109074:	01402b04 	movi	r5,172
81109078:	1009883a 	mov	r4,r2
8110907c:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109080:	e0bfff17 	ldw	r2,-4(fp)
81109084:	10800017 	ldw	r2,0(r2)
81109088:	01402b44 	movi	r5,173
8110908c:	1009883a 	mov	r4,r2
81109090:	110a4980 	call	8110a498 <uliRmapReadReg>
81109094:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81109098:	e0bffe17 	ldw	r2,-8(fp)
8110909c:	10bfffec 	andhi	r2,r2,65535
811090a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
811090a4:	e0bfff17 	ldw	r2,-4(fp)
811090a8:	1080330b 	ldhu	r2,204(r2)
811090ac:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
811090b0:	e0bffe17 	ldw	r2,-8(fp)
811090b4:	1884b03a 	or	r2,r3,r2
811090b8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
811090bc:	e0bffe17 	ldw	r2,-8(fp)
811090c0:	10bfffcc 	andi	r2,r2,65535
811090c4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
811090c8:	e0bfff17 	ldw	r2,-4(fp)
811090cc:	1080338b 	ldhu	r2,206(r2)
811090d0:	10bfffcc 	andi	r2,r2,65535
811090d4:	1004943a 	slli	r2,r2,16
811090d8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
811090dc:	e0bffe17 	ldw	r2,-8(fp)
811090e0:	1884b03a 	or	r2,r3,r2
811090e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
811090e8:	e0bfff17 	ldw	r2,-4(fp)
811090ec:	10800017 	ldw	r2,0(r2)
811090f0:	e0fffe17 	ldw	r3,-8(fp)
811090f4:	180d883a 	mov	r6,r3
811090f8:	01402b44 	movi	r5,173
811090fc:	1009883a 	mov	r4,r2
81109100:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109104:	e0bfff17 	ldw	r2,-4(fp)
81109108:	10800017 	ldw	r2,0(r2)
8110910c:	01402b84 	movi	r5,174
81109110:	1009883a 	mov	r4,r2
81109114:	110a4980 	call	8110a498 <uliRmapReadReg>
81109118:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
8110911c:	e0bffe17 	ldw	r2,-8(fp)
81109120:	10bfffec 	andhi	r2,r2,65535
81109124:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81109128:	e0bfff17 	ldw	r2,-4(fp)
8110912c:	1080340b 	ldhu	r2,208(r2)
81109130:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81109134:	e0bffe17 	ldw	r2,-8(fp)
81109138:	1884b03a 	or	r2,r3,r2
8110913c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81109140:	e0bffe17 	ldw	r2,-8(fp)
81109144:	10bfffcc 	andi	r2,r2,65535
81109148:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
8110914c:	e0bfff17 	ldw	r2,-4(fp)
81109150:	1080348b 	ldhu	r2,210(r2)
81109154:	10bfffcc 	andi	r2,r2,65535
81109158:	1004943a 	slli	r2,r2,16
8110915c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
81109160:	e0bffe17 	ldw	r2,-8(fp)
81109164:	1884b03a 	or	r2,r3,r2
81109168:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
8110916c:	e0bfff17 	ldw	r2,-4(fp)
81109170:	10800017 	ldw	r2,0(r2)
81109174:	e0fffe17 	ldw	r3,-8(fp)
81109178:	180d883a 	mov	r6,r3
8110917c:	01402b84 	movi	r5,174
81109180:	1009883a 	mov	r4,r2
81109184:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109188:	e0bfff17 	ldw	r2,-4(fp)
8110918c:	10800017 	ldw	r2,0(r2)
81109190:	01402bc4 	movi	r5,175
81109194:	1009883a 	mov	r4,r2
81109198:	110a4980 	call	8110a498 <uliRmapReadReg>
8110919c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
811091a0:	e0bffe17 	ldw	r2,-8(fp)
811091a4:	10bfffec 	andhi	r2,r2,65535
811091a8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
811091ac:	e0bfff17 	ldw	r2,-4(fp)
811091b0:	1080350b 	ldhu	r2,212(r2)
811091b4:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
811091b8:	e0bffe17 	ldw	r2,-8(fp)
811091bc:	1884b03a 	or	r2,r3,r2
811091c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
811091c4:	e0bffe17 	ldw	r2,-8(fp)
811091c8:	10bfffcc 	andi	r2,r2,65535
811091cc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
811091d0:	e0bfff17 	ldw	r2,-4(fp)
811091d4:	1080358b 	ldhu	r2,214(r2)
811091d8:	10bfffcc 	andi	r2,r2,65535
811091dc:	1004943a 	slli	r2,r2,16
811091e0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
811091e4:	e0bffe17 	ldw	r2,-8(fp)
811091e8:	1884b03a 	or	r2,r3,r2
811091ec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
811091f0:	e0bfff17 	ldw	r2,-4(fp)
811091f4:	10800017 	ldw	r2,0(r2)
811091f8:	e0fffe17 	ldw	r3,-8(fp)
811091fc:	180d883a 	mov	r6,r3
81109200:	01402bc4 	movi	r5,175
81109204:	1009883a 	mov	r4,r2
81109208:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110920c:	e0bfff17 	ldw	r2,-4(fp)
81109210:	10800017 	ldw	r2,0(r2)
81109214:	01402c04 	movi	r5,176
81109218:	1009883a 	mov	r4,r2
8110921c:	110a4980 	call	8110a498 <uliRmapReadReg>
81109220:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81109224:	e0bffe17 	ldw	r2,-8(fp)
81109228:	10bfffec 	andhi	r2,r2,65535
8110922c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81109230:	e0bfff17 	ldw	r2,-4(fp)
81109234:	1080360b 	ldhu	r2,216(r2)
81109238:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
8110923c:	e0bffe17 	ldw	r2,-8(fp)
81109240:	1884b03a 	or	r2,r3,r2
81109244:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81109248:	e0bffe17 	ldw	r2,-8(fp)
8110924c:	10bfffcc 	andi	r2,r2,65535
81109250:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
81109254:	e0bfff17 	ldw	r2,-4(fp)
81109258:	1080368b 	ldhu	r2,218(r2)
8110925c:	10bfffcc 	andi	r2,r2,65535
81109260:	1004943a 	slli	r2,r2,16
81109264:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
81109268:	e0bffe17 	ldw	r2,-8(fp)
8110926c:	1884b03a 	or	r2,r3,r2
81109270:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81109274:	e0bfff17 	ldw	r2,-4(fp)
81109278:	10800017 	ldw	r2,0(r2)
8110927c:	e0fffe17 	ldw	r3,-8(fp)
81109280:	180d883a 	mov	r6,r3
81109284:	01402c04 	movi	r5,176
81109288:	1009883a 	mov	r4,r2
8110928c:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109290:	e0bfff17 	ldw	r2,-4(fp)
81109294:	10800017 	ldw	r2,0(r2)
81109298:	01402c44 	movi	r5,177
8110929c:	1009883a 	mov	r4,r2
811092a0:	110a4980 	call	8110a498 <uliRmapReadReg>
811092a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
811092a8:	e0bffe17 	ldw	r2,-8(fp)
811092ac:	10bfffec 	andhi	r2,r2,65535
811092b0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
811092b4:	e0bfff17 	ldw	r2,-4(fp)
811092b8:	1080370b 	ldhu	r2,220(r2)
811092bc:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
811092c0:	e0bffe17 	ldw	r2,-8(fp)
811092c4:	1884b03a 	or	r2,r3,r2
811092c8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
811092cc:	e0bffe17 	ldw	r2,-8(fp)
811092d0:	10bfffcc 	andi	r2,r2,65535
811092d4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
811092d8:	e0bfff17 	ldw	r2,-4(fp)
811092dc:	1080378b 	ldhu	r2,222(r2)
811092e0:	10bfffcc 	andi	r2,r2,65535
811092e4:	1004943a 	slli	r2,r2,16
811092e8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
811092ec:	e0bffe17 	ldw	r2,-8(fp)
811092f0:	1884b03a 	or	r2,r3,r2
811092f4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
811092f8:	e0bfff17 	ldw	r2,-4(fp)
811092fc:	10800017 	ldw	r2,0(r2)
81109300:	e0fffe17 	ldw	r3,-8(fp)
81109304:	180d883a 	mov	r6,r3
81109308:	01402c44 	movi	r5,177
8110930c:	1009883a 	mov	r4,r2
81109310:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109314:	e0bfff17 	ldw	r2,-4(fp)
81109318:	10800017 	ldw	r2,0(r2)
8110931c:	01402c84 	movi	r5,178
81109320:	1009883a 	mov	r4,r2
81109324:	110a4980 	call	8110a498 <uliRmapReadReg>
81109328:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
8110932c:	e0bffe17 	ldw	r2,-8(fp)
81109330:	10bfffec 	andhi	r2,r2,65535
81109334:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81109338:	e0bfff17 	ldw	r2,-4(fp)
8110933c:	1080380b 	ldhu	r2,224(r2)
81109340:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81109344:	e0bffe17 	ldw	r2,-8(fp)
81109348:	1884b03a 	or	r2,r3,r2
8110934c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81109350:	e0bffe17 	ldw	r2,-8(fp)
81109354:	10bfffcc 	andi	r2,r2,65535
81109358:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
8110935c:	e0bfff17 	ldw	r2,-4(fp)
81109360:	1080388b 	ldhu	r2,226(r2)
81109364:	10bfffcc 	andi	r2,r2,65535
81109368:	1004943a 	slli	r2,r2,16
8110936c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
81109370:	e0bffe17 	ldw	r2,-8(fp)
81109374:	1884b03a 	or	r2,r3,r2
81109378:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
8110937c:	e0bfff17 	ldw	r2,-4(fp)
81109380:	10800017 	ldw	r2,0(r2)
81109384:	e0fffe17 	ldw	r3,-8(fp)
81109388:	180d883a 	mov	r6,r3
8110938c:	01402c84 	movi	r5,178
81109390:	1009883a 	mov	r4,r2
81109394:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109398:	e0bfff17 	ldw	r2,-4(fp)
8110939c:	10800017 	ldw	r2,0(r2)
811093a0:	01402cc4 	movi	r5,179
811093a4:	1009883a 	mov	r4,r2
811093a8:	110a4980 	call	8110a498 <uliRmapReadReg>
811093ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
811093b0:	e0bffe17 	ldw	r2,-8(fp)
811093b4:	10bfffec 	andhi	r2,r2,65535
811093b8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
811093bc:	e0bfff17 	ldw	r2,-4(fp)
811093c0:	1080390b 	ldhu	r2,228(r2)
811093c4:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
811093c8:	e0bffe17 	ldw	r2,-8(fp)
811093cc:	1884b03a 	or	r2,r3,r2
811093d0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
811093d4:	e0bffe17 	ldw	r2,-8(fp)
811093d8:	10bfffcc 	andi	r2,r2,65535
811093dc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
811093e0:	e0bfff17 	ldw	r2,-4(fp)
811093e4:	1080398b 	ldhu	r2,230(r2)
811093e8:	10bfffcc 	andi	r2,r2,65535
811093ec:	1004943a 	slli	r2,r2,16
811093f0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
811093f4:	e0bffe17 	ldw	r2,-8(fp)
811093f8:	1884b03a 	or	r2,r3,r2
811093fc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
81109400:	e0bfff17 	ldw	r2,-4(fp)
81109404:	10800017 	ldw	r2,0(r2)
81109408:	e0fffe17 	ldw	r3,-8(fp)
8110940c:	180d883a 	mov	r6,r3
81109410:	01402cc4 	movi	r5,179
81109414:	1009883a 	mov	r4,r2
81109418:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110941c:	e0bfff17 	ldw	r2,-4(fp)
81109420:	10800017 	ldw	r2,0(r2)
81109424:	01402d04 	movi	r5,180
81109428:	1009883a 	mov	r4,r2
8110942c:	110a4980 	call	8110a498 <uliRmapReadReg>
81109430:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
81109434:	e0bffe17 	ldw	r2,-8(fp)
81109438:	10bfffec 	andhi	r2,r2,65535
8110943c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81109440:	e0bfff17 	ldw	r2,-4(fp)
81109444:	10803a0b 	ldhu	r2,232(r2)
81109448:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
8110944c:	e0bffe17 	ldw	r2,-8(fp)
81109450:	1884b03a 	or	r2,r3,r2
81109454:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81109458:	e0bffe17 	ldw	r2,-8(fp)
8110945c:	10bfffcc 	andi	r2,r2,65535
81109460:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
81109464:	e0bfff17 	ldw	r2,-4(fp)
81109468:	10803a8b 	ldhu	r2,234(r2)
8110946c:	10bfffcc 	andi	r2,r2,65535
81109470:	1004943a 	slli	r2,r2,16
81109474:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
81109478:	e0bffe17 	ldw	r2,-8(fp)
8110947c:	1884b03a 	or	r2,r3,r2
81109480:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81109484:	e0bfff17 	ldw	r2,-4(fp)
81109488:	10800017 	ldw	r2,0(r2)
8110948c:	e0fffe17 	ldw	r3,-8(fp)
81109490:	180d883a 	mov	r6,r3
81109494:	01402d04 	movi	r5,180
81109498:	1009883a 	mov	r4,r2
8110949c:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811094a0:	e0bfff17 	ldw	r2,-4(fp)
811094a4:	10800017 	ldw	r2,0(r2)
811094a8:	01402d44 	movi	r5,181
811094ac:	1009883a 	mov	r4,r2
811094b0:	110a4980 	call	8110a498 <uliRmapReadReg>
811094b4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
811094b8:	e0bffe17 	ldw	r2,-8(fp)
811094bc:	10bfffec 	andhi	r2,r2,65535
811094c0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
811094c4:	e0bfff17 	ldw	r2,-4(fp)
811094c8:	10803b0b 	ldhu	r2,236(r2)
811094cc:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
811094d0:	e0bffe17 	ldw	r2,-8(fp)
811094d4:	1884b03a 	or	r2,r3,r2
811094d8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
811094dc:	e0bffe17 	ldw	r2,-8(fp)
811094e0:	10bfffcc 	andi	r2,r2,65535
811094e4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
811094e8:	e0bfff17 	ldw	r2,-4(fp)
811094ec:	10803b8b 	ldhu	r2,238(r2)
811094f0:	10bfffcc 	andi	r2,r2,65535
811094f4:	1004943a 	slli	r2,r2,16
811094f8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
811094fc:	e0bffe17 	ldw	r2,-8(fp)
81109500:	1884b03a 	or	r2,r3,r2
81109504:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
81109508:	e0bfff17 	ldw	r2,-4(fp)
8110950c:	10800017 	ldw	r2,0(r2)
81109510:	e0fffe17 	ldw	r3,-8(fp)
81109514:	180d883a 	mov	r6,r3
81109518:	01402d44 	movi	r5,181
8110951c:	1009883a 	mov	r4,r2
81109520:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109524:	e0bfff17 	ldw	r2,-4(fp)
81109528:	10800017 	ldw	r2,0(r2)
8110952c:	01402d84 	movi	r5,182
81109530:	1009883a 	mov	r4,r2
81109534:	110a4980 	call	8110a498 <uliRmapReadReg>
81109538:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
8110953c:	e0bffe17 	ldw	r2,-8(fp)
81109540:	10bfffec 	andhi	r2,r2,65535
81109544:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
81109548:	e0bfff17 	ldw	r2,-4(fp)
8110954c:	10803c0b 	ldhu	r2,240(r2)
81109550:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
81109554:	e0bffe17 	ldw	r2,-8(fp)
81109558:	1884b03a 	or	r2,r3,r2
8110955c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81109560:	e0bffe17 	ldw	r2,-8(fp)
81109564:	10bfffcc 	andi	r2,r2,65535
81109568:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
8110956c:	e0bfff17 	ldw	r2,-4(fp)
81109570:	10803c8b 	ldhu	r2,242(r2)
81109574:	10bfffcc 	andi	r2,r2,65535
81109578:	1004943a 	slli	r2,r2,16
8110957c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
81109580:	e0bffe17 	ldw	r2,-8(fp)
81109584:	1884b03a 	or	r2,r3,r2
81109588:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
8110958c:	e0bfff17 	ldw	r2,-4(fp)
81109590:	10800017 	ldw	r2,0(r2)
81109594:	e0fffe17 	ldw	r3,-8(fp)
81109598:	180d883a 	mov	r6,r3
8110959c:	01402d84 	movi	r5,182
811095a0:	1009883a 	mov	r4,r2
811095a4:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095a8:	e0bfff17 	ldw	r2,-4(fp)
811095ac:	10800017 	ldw	r2,0(r2)
811095b0:	01402dc4 	movi	r5,183
811095b4:	1009883a 	mov	r4,r2
811095b8:	110a4980 	call	8110a498 <uliRmapReadReg>
811095bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
811095c0:	e0bffe17 	ldw	r2,-8(fp)
811095c4:	10bfffec 	andhi	r2,r2,65535
811095c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
811095cc:	e0bfff17 	ldw	r2,-4(fp)
811095d0:	10803d0b 	ldhu	r2,244(r2)
811095d4:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
811095d8:	e0bffe17 	ldw	r2,-8(fp)
811095dc:	1884b03a 	or	r2,r3,r2
811095e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
811095e4:	e0bffe17 	ldw	r2,-8(fp)
811095e8:	10bfffcc 	andi	r2,r2,65535
811095ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
811095f0:	e0bfff17 	ldw	r2,-4(fp)
811095f4:	10803d8b 	ldhu	r2,246(r2)
811095f8:	10bfffcc 	andi	r2,r2,65535
811095fc:	1004943a 	slli	r2,r2,16
81109600:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
81109604:	e0bffe17 	ldw	r2,-8(fp)
81109608:	1884b03a 	or	r2,r3,r2
8110960c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
81109610:	e0bfff17 	ldw	r2,-4(fp)
81109614:	10800017 	ldw	r2,0(r2)
81109618:	e0fffe17 	ldw	r3,-8(fp)
8110961c:	180d883a 	mov	r6,r3
81109620:	01402dc4 	movi	r5,183
81109624:	1009883a 	mov	r4,r2
81109628:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110962c:	e0bfff17 	ldw	r2,-4(fp)
81109630:	10800017 	ldw	r2,0(r2)
81109634:	01402e04 	movi	r5,184
81109638:	1009883a 	mov	r4,r2
8110963c:	110a4980 	call	8110a498 <uliRmapReadReg>
81109640:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
81109644:	e0bffe17 	ldw	r2,-8(fp)
81109648:	10bfffec 	andhi	r2,r2,65535
8110964c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
81109650:	e0bfff17 	ldw	r2,-4(fp)
81109654:	10803e0b 	ldhu	r2,248(r2)
81109658:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
8110965c:	e0bffe17 	ldw	r2,-8(fp)
81109660:	1884b03a 	or	r2,r3,r2
81109664:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81109668:	e0bffe17 	ldw	r2,-8(fp)
8110966c:	10bfffcc 	andi	r2,r2,65535
81109670:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
81109674:	e0bfff17 	ldw	r2,-4(fp)
81109678:	10803e8b 	ldhu	r2,250(r2)
8110967c:	10bfffcc 	andi	r2,r2,65535
81109680:	1004943a 	slli	r2,r2,16
81109684:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
81109688:	e0bffe17 	ldw	r2,-8(fp)
8110968c:	1884b03a 	or	r2,r3,r2
81109690:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81109694:	e0bfff17 	ldw	r2,-4(fp)
81109698:	10800017 	ldw	r2,0(r2)
8110969c:	e0fffe17 	ldw	r3,-8(fp)
811096a0:	180d883a 	mov	r6,r3
811096a4:	01402e04 	movi	r5,184
811096a8:	1009883a 	mov	r4,r2
811096ac:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811096b0:	e0bfff17 	ldw	r2,-4(fp)
811096b4:	10800017 	ldw	r2,0(r2)
811096b8:	01402e44 	movi	r5,185
811096bc:	1009883a 	mov	r4,r2
811096c0:	110a4980 	call	8110a498 <uliRmapReadReg>
811096c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
811096c8:	e0bffe17 	ldw	r2,-8(fp)
811096cc:	10bfffec 	andhi	r2,r2,65535
811096d0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
811096d4:	e0bfff17 	ldw	r2,-4(fp)
811096d8:	10803f0b 	ldhu	r2,252(r2)
811096dc:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
811096e0:	e0bffe17 	ldw	r2,-8(fp)
811096e4:	1884b03a 	or	r2,r3,r2
811096e8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
811096ec:	e0bffe17 	ldw	r2,-8(fp)
811096f0:	10bfffcc 	andi	r2,r2,65535
811096f4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
811096f8:	e0bfff17 	ldw	r2,-4(fp)
811096fc:	10803f8b 	ldhu	r2,254(r2)
81109700:	10bfffcc 	andi	r2,r2,65535
81109704:	1004943a 	slli	r2,r2,16
81109708:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
8110970c:	e0bffe17 	ldw	r2,-8(fp)
81109710:	1884b03a 	or	r2,r3,r2
81109714:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
81109718:	e0bfff17 	ldw	r2,-4(fp)
8110971c:	10800017 	ldw	r2,0(r2)
81109720:	e0fffe17 	ldw	r3,-8(fp)
81109724:	180d883a 	mov	r6,r3
81109728:	01402e44 	movi	r5,185
8110972c:	1009883a 	mov	r4,r2
81109730:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109734:	e0bfff17 	ldw	r2,-4(fp)
81109738:	10800017 	ldw	r2,0(r2)
8110973c:	01402e84 	movi	r5,186
81109740:	1009883a 	mov	r4,r2
81109744:	110a4980 	call	8110a498 <uliRmapReadReg>
81109748:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
8110974c:	e0bffe17 	ldw	r2,-8(fp)
81109750:	10bfffec 	andhi	r2,r2,65535
81109754:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
81109758:	e0bfff17 	ldw	r2,-4(fp)
8110975c:	1080400b 	ldhu	r2,256(r2)
81109760:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
81109764:	e0bffe17 	ldw	r2,-8(fp)
81109768:	1884b03a 	or	r2,r3,r2
8110976c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81109770:	e0bffe17 	ldw	r2,-8(fp)
81109774:	10bfffcc 	andi	r2,r2,65535
81109778:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
8110977c:	e0bfff17 	ldw	r2,-4(fp)
81109780:	1080408b 	ldhu	r2,258(r2)
81109784:	10bfffcc 	andi	r2,r2,65535
81109788:	1004943a 	slli	r2,r2,16
8110978c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
81109790:	e0bffe17 	ldw	r2,-8(fp)
81109794:	1884b03a 	or	r2,r3,r2
81109798:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
8110979c:	e0bfff17 	ldw	r2,-4(fp)
811097a0:	10800017 	ldw	r2,0(r2)
811097a4:	e0fffe17 	ldw	r3,-8(fp)
811097a8:	180d883a 	mov	r6,r3
811097ac:	01402e84 	movi	r5,186
811097b0:	1009883a 	mov	r4,r2
811097b4:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811097b8:	e0bfff17 	ldw	r2,-4(fp)
811097bc:	10800017 	ldw	r2,0(r2)
811097c0:	01402ec4 	movi	r5,187
811097c4:	1009883a 	mov	r4,r2
811097c8:	110a4980 	call	8110a498 <uliRmapReadReg>
811097cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
811097d0:	e0bffe17 	ldw	r2,-8(fp)
811097d4:	10bfffec 	andhi	r2,r2,65535
811097d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
811097dc:	e0bfff17 	ldw	r2,-4(fp)
811097e0:	1080410b 	ldhu	r2,260(r2)
811097e4:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
811097e8:	e0bffe17 	ldw	r2,-8(fp)
811097ec:	1884b03a 	or	r2,r3,r2
811097f0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
811097f4:	e0bffe17 	ldw	r2,-8(fp)
811097f8:	10bfffcc 	andi	r2,r2,65535
811097fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
81109800:	e0bfff17 	ldw	r2,-4(fp)
81109804:	1080418b 	ldhu	r2,262(r2)
81109808:	10bfffcc 	andi	r2,r2,65535
8110980c:	1004943a 	slli	r2,r2,16
81109810:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
81109814:	e0bffe17 	ldw	r2,-8(fp)
81109818:	1884b03a 	or	r2,r3,r2
8110981c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
81109820:	e0bfff17 	ldw	r2,-4(fp)
81109824:	10800017 	ldw	r2,0(r2)
81109828:	e0fffe17 	ldw	r3,-8(fp)
8110982c:	180d883a 	mov	r6,r3
81109830:	01402ec4 	movi	r5,187
81109834:	1009883a 	mov	r4,r2
81109838:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110983c:	e0bfff17 	ldw	r2,-4(fp)
81109840:	10800017 	ldw	r2,0(r2)
81109844:	01402f04 	movi	r5,188
81109848:	1009883a 	mov	r4,r2
8110984c:	110a4980 	call	8110a498 <uliRmapReadReg>
81109850:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
81109854:	e0bffe17 	ldw	r2,-8(fp)
81109858:	10bfffec 	andhi	r2,r2,65535
8110985c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
81109860:	e0bfff17 	ldw	r2,-4(fp)
81109864:	1080420b 	ldhu	r2,264(r2)
81109868:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
8110986c:	e0bffe17 	ldw	r2,-8(fp)
81109870:	1884b03a 	or	r2,r3,r2
81109874:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81109878:	e0bffe17 	ldw	r2,-8(fp)
8110987c:	10bfffcc 	andi	r2,r2,65535
81109880:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
81109884:	e0bfff17 	ldw	r2,-4(fp)
81109888:	1080428b 	ldhu	r2,266(r2)
8110988c:	10bfffcc 	andi	r2,r2,65535
81109890:	1004943a 	slli	r2,r2,16
81109894:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
81109898:	e0bffe17 	ldw	r2,-8(fp)
8110989c:	1884b03a 	or	r2,r3,r2
811098a0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
811098a4:	e0bfff17 	ldw	r2,-4(fp)
811098a8:	10800017 	ldw	r2,0(r2)
811098ac:	e0fffe17 	ldw	r3,-8(fp)
811098b0:	180d883a 	mov	r6,r3
811098b4:	01402f04 	movi	r5,188
811098b8:	1009883a 	mov	r4,r2
811098bc:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098c0:	e0bfff17 	ldw	r2,-4(fp)
811098c4:	10800017 	ldw	r2,0(r2)
811098c8:	01402f44 	movi	r5,189
811098cc:	1009883a 	mov	r4,r2
811098d0:	110a4980 	call	8110a498 <uliRmapReadReg>
811098d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
811098d8:	e0bffe17 	ldw	r2,-8(fp)
811098dc:	10bfffec 	andhi	r2,r2,65535
811098e0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
811098e4:	e0bfff17 	ldw	r2,-4(fp)
811098e8:	1080430b 	ldhu	r2,268(r2)
811098ec:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
811098f0:	e0bffe17 	ldw	r2,-8(fp)
811098f4:	1884b03a 	or	r2,r3,r2
811098f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
811098fc:	e0bffe17 	ldw	r2,-8(fp)
81109900:	10bfffcc 	andi	r2,r2,65535
81109904:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
81109908:	e0bfff17 	ldw	r2,-4(fp)
8110990c:	1080438b 	ldhu	r2,270(r2)
81109910:	10bfffcc 	andi	r2,r2,65535
81109914:	1004943a 	slli	r2,r2,16
81109918:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
8110991c:	e0bffe17 	ldw	r2,-8(fp)
81109920:	1884b03a 	or	r2,r3,r2
81109924:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
81109928:	e0bfff17 	ldw	r2,-4(fp)
8110992c:	10800017 	ldw	r2,0(r2)
81109930:	e0fffe17 	ldw	r3,-8(fp)
81109934:	180d883a 	mov	r6,r3
81109938:	01402f44 	movi	r5,189
8110993c:	1009883a 	mov	r4,r2
81109940:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109944:	e0bfff17 	ldw	r2,-4(fp)
81109948:	10800017 	ldw	r2,0(r2)
8110994c:	01402f84 	movi	r5,190
81109950:	1009883a 	mov	r4,r2
81109954:	110a4980 	call	8110a498 <uliRmapReadReg>
81109958:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
8110995c:	e0bffe17 	ldw	r2,-8(fp)
81109960:	10bfffec 	andhi	r2,r2,65535
81109964:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
81109968:	e0bfff17 	ldw	r2,-4(fp)
8110996c:	1080440b 	ldhu	r2,272(r2)
81109970:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
81109974:	e0bffe17 	ldw	r2,-8(fp)
81109978:	1884b03a 	or	r2,r3,r2
8110997c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81109980:	e0bffe17 	ldw	r2,-8(fp)
81109984:	10bfffcc 	andi	r2,r2,65535
81109988:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
8110998c:	e0bfff17 	ldw	r2,-4(fp)
81109990:	1080448b 	ldhu	r2,274(r2)
81109994:	10bfffcc 	andi	r2,r2,65535
81109998:	1004943a 	slli	r2,r2,16
8110999c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
811099a0:	e0bffe17 	ldw	r2,-8(fp)
811099a4:	1884b03a 	or	r2,r3,r2
811099a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
811099ac:	e0bfff17 	ldw	r2,-4(fp)
811099b0:	10800017 	ldw	r2,0(r2)
811099b4:	e0fffe17 	ldw	r3,-8(fp)
811099b8:	180d883a 	mov	r6,r3
811099bc:	01402f84 	movi	r5,190
811099c0:	1009883a 	mov	r4,r2
811099c4:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811099c8:	e0bfff17 	ldw	r2,-4(fp)
811099cc:	10800017 	ldw	r2,0(r2)
811099d0:	01402fc4 	movi	r5,191
811099d4:	1009883a 	mov	r4,r2
811099d8:	110a4980 	call	8110a498 <uliRmapReadReg>
811099dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
811099e0:	e0bffe17 	ldw	r2,-8(fp)
811099e4:	10bfffec 	andhi	r2,r2,65535
811099e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
811099ec:	e0bfff17 	ldw	r2,-4(fp)
811099f0:	1080450b 	ldhu	r2,276(r2)
811099f4:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
811099f8:	e0bffe17 	ldw	r2,-8(fp)
811099fc:	1884b03a 	or	r2,r3,r2
81109a00:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
81109a04:	e0bffe17 	ldw	r2,-8(fp)
81109a08:	10bfffcc 	andi	r2,r2,65535
81109a0c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
81109a10:	e0bfff17 	ldw	r2,-4(fp)
81109a14:	1080458b 	ldhu	r2,278(r2)
81109a18:	10bfffcc 	andi	r2,r2,65535
81109a1c:	1004943a 	slli	r2,r2,16
81109a20:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
81109a24:	e0bffe17 	ldw	r2,-8(fp)
81109a28:	1884b03a 	or	r2,r3,r2
81109a2c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
81109a30:	e0bfff17 	ldw	r2,-4(fp)
81109a34:	10800017 	ldw	r2,0(r2)
81109a38:	e0fffe17 	ldw	r3,-8(fp)
81109a3c:	180d883a 	mov	r6,r3
81109a40:	01402fc4 	movi	r5,191
81109a44:	1009883a 	mov	r4,r2
81109a48:	110a4440 	call	8110a444 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81109a4c:	00800044 	movi	r2,1
81109a50:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109a54:	e0bffd17 	ldw	r2,-12(fp)
}
81109a58:	e037883a 	mov	sp,fp
81109a5c:	dfc00117 	ldw	ra,4(sp)
81109a60:	df000017 	ldw	fp,0(sp)
81109a64:	dec00204 	addi	sp,sp,8
81109a68:	f800283a 	ret

81109a6c <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81109a6c:	defffb04 	addi	sp,sp,-20
81109a70:	de00012e 	bgeu	sp,et,81109a78 <bRmapGetRmapMemHKArea+0xc>
81109a74:	003b68fa 	trap	3
81109a78:	dfc00415 	stw	ra,16(sp)
81109a7c:	df000315 	stw	fp,12(sp)
81109a80:	df000304 	addi	fp,sp,12
81109a84:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109a88:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
81109a8c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81109a90:	e0bfff17 	ldw	r2,-4(fp)
81109a94:	1001e226 	beq	r2,zero,8110a220 <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a98:	e0bfff17 	ldw	r2,-4(fp)
81109a9c:	10800017 	ldw	r2,0(r2)
81109aa0:	01402804 	movi	r5,160
81109aa4:	1009883a 	mov	r4,r2
81109aa8:	110a4980 	call	8110a498 <uliRmapReadReg>
81109aac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
81109ab0:	e0bffe17 	ldw	r2,-8(fp)
81109ab4:	1007883a 	mov	r3,r2
81109ab8:	e0bfff17 	ldw	r2,-4(fp)
81109abc:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
81109ac0:	e0bffe17 	ldw	r2,-8(fp)
81109ac4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
81109ac8:	1007883a 	mov	r3,r2
81109acc:	e0bfff17 	ldw	r2,-4(fp)
81109ad0:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109ad4:	e0bfff17 	ldw	r2,-4(fp)
81109ad8:	10800017 	ldw	r2,0(r2)
81109adc:	01402844 	movi	r5,161
81109ae0:	1009883a 	mov	r4,r2
81109ae4:	110a4980 	call	8110a498 <uliRmapReadReg>
81109ae8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
81109aec:	e0bffe17 	ldw	r2,-8(fp)
81109af0:	1007883a 	mov	r3,r2
81109af4:	e0bfff17 	ldw	r2,-4(fp)
81109af8:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
81109afc:	e0bffe17 	ldw	r2,-8(fp)
81109b00:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
81109b04:	1007883a 	mov	r3,r2
81109b08:	e0bfff17 	ldw	r2,-4(fp)
81109b0c:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b10:	e0bfff17 	ldw	r2,-4(fp)
81109b14:	10800017 	ldw	r2,0(r2)
81109b18:	01402884 	movi	r5,162
81109b1c:	1009883a 	mov	r4,r2
81109b20:	110a4980 	call	8110a498 <uliRmapReadReg>
81109b24:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
81109b28:	e0bffe17 	ldw	r2,-8(fp)
81109b2c:	1007883a 	mov	r3,r2
81109b30:	e0bfff17 	ldw	r2,-4(fp)
81109b34:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
81109b38:	e0bffe17 	ldw	r2,-8(fp)
81109b3c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
81109b40:	1007883a 	mov	r3,r2
81109b44:	e0bfff17 	ldw	r2,-4(fp)
81109b48:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b4c:	e0bfff17 	ldw	r2,-4(fp)
81109b50:	10800017 	ldw	r2,0(r2)
81109b54:	014028c4 	movi	r5,163
81109b58:	1009883a 	mov	r4,r2
81109b5c:	110a4980 	call	8110a498 <uliRmapReadReg>
81109b60:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
81109b64:	e0bffe17 	ldw	r2,-8(fp)
81109b68:	1007883a 	mov	r3,r2
81109b6c:	e0bfff17 	ldw	r2,-4(fp)
81109b70:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
81109b74:	e0bffe17 	ldw	r2,-8(fp)
81109b78:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
81109b7c:	1007883a 	mov	r3,r2
81109b80:	e0bfff17 	ldw	r2,-4(fp)
81109b84:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b88:	e0bfff17 	ldw	r2,-4(fp)
81109b8c:	10800017 	ldw	r2,0(r2)
81109b90:	01402904 	movi	r5,164
81109b94:	1009883a 	mov	r4,r2
81109b98:	110a4980 	call	8110a498 <uliRmapReadReg>
81109b9c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
81109ba0:	e0bffe17 	ldw	r2,-8(fp)
81109ba4:	1007883a 	mov	r3,r2
81109ba8:	e0bfff17 	ldw	r2,-4(fp)
81109bac:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
81109bb0:	e0bffe17 	ldw	r2,-8(fp)
81109bb4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81109bb8:	1007883a 	mov	r3,r2
81109bbc:	e0bfff17 	ldw	r2,-4(fp)
81109bc0:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109bc4:	e0bfff17 	ldw	r2,-4(fp)
81109bc8:	10800017 	ldw	r2,0(r2)
81109bcc:	01402944 	movi	r5,165
81109bd0:	1009883a 	mov	r4,r2
81109bd4:	110a4980 	call	8110a498 <uliRmapReadReg>
81109bd8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
81109bdc:	e0bffe17 	ldw	r2,-8(fp)
81109be0:	1007883a 	mov	r3,r2
81109be4:	e0bfff17 	ldw	r2,-4(fp)
81109be8:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
81109bec:	e0bffe17 	ldw	r2,-8(fp)
81109bf0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
81109bf4:	1007883a 	mov	r3,r2
81109bf8:	e0bfff17 	ldw	r2,-4(fp)
81109bfc:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c00:	e0bfff17 	ldw	r2,-4(fp)
81109c04:	10800017 	ldw	r2,0(r2)
81109c08:	01402984 	movi	r5,166
81109c0c:	1009883a 	mov	r4,r2
81109c10:	110a4980 	call	8110a498 <uliRmapReadReg>
81109c14:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
81109c18:	e0bffe17 	ldw	r2,-8(fp)
81109c1c:	1007883a 	mov	r3,r2
81109c20:	e0bfff17 	ldw	r2,-4(fp)
81109c24:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
81109c28:	e0bffe17 	ldw	r2,-8(fp)
81109c2c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
81109c30:	1007883a 	mov	r3,r2
81109c34:	e0bfff17 	ldw	r2,-4(fp)
81109c38:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c3c:	e0bfff17 	ldw	r2,-4(fp)
81109c40:	10800017 	ldw	r2,0(r2)
81109c44:	014029c4 	movi	r5,167
81109c48:	1009883a 	mov	r4,r2
81109c4c:	110a4980 	call	8110a498 <uliRmapReadReg>
81109c50:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
81109c54:	e0bffe17 	ldw	r2,-8(fp)
81109c58:	1007883a 	mov	r3,r2
81109c5c:	e0bfff17 	ldw	r2,-4(fp)
81109c60:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
81109c64:	e0bffe17 	ldw	r2,-8(fp)
81109c68:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
81109c6c:	1007883a 	mov	r3,r2
81109c70:	e0bfff17 	ldw	r2,-4(fp)
81109c74:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c78:	e0bfff17 	ldw	r2,-4(fp)
81109c7c:	10800017 	ldw	r2,0(r2)
81109c80:	01402a04 	movi	r5,168
81109c84:	1009883a 	mov	r4,r2
81109c88:	110a4980 	call	8110a498 <uliRmapReadReg>
81109c8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
81109c90:	e0bffe17 	ldw	r2,-8(fp)
81109c94:	1007883a 	mov	r3,r2
81109c98:	e0bfff17 	ldw	r2,-4(fp)
81109c9c:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
81109ca0:	e0bffe17 	ldw	r2,-8(fp)
81109ca4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
81109ca8:	1007883a 	mov	r3,r2
81109cac:	e0bfff17 	ldw	r2,-4(fp)
81109cb0:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109cb4:	e0bfff17 	ldw	r2,-4(fp)
81109cb8:	10800017 	ldw	r2,0(r2)
81109cbc:	01402a44 	movi	r5,169
81109cc0:	1009883a 	mov	r4,r2
81109cc4:	110a4980 	call	8110a498 <uliRmapReadReg>
81109cc8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
81109ccc:	e0bffe17 	ldw	r2,-8(fp)
81109cd0:	1007883a 	mov	r3,r2
81109cd4:	e0bfff17 	ldw	r2,-4(fp)
81109cd8:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
81109cdc:	e0bffe17 	ldw	r2,-8(fp)
81109ce0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
81109ce4:	1007883a 	mov	r3,r2
81109ce8:	e0bfff17 	ldw	r2,-4(fp)
81109cec:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109cf0:	e0bfff17 	ldw	r2,-4(fp)
81109cf4:	10800017 	ldw	r2,0(r2)
81109cf8:	01402a84 	movi	r5,170
81109cfc:	1009883a 	mov	r4,r2
81109d00:	110a4980 	call	8110a498 <uliRmapReadReg>
81109d04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
81109d08:	e0bffe17 	ldw	r2,-8(fp)
81109d0c:	1007883a 	mov	r3,r2
81109d10:	e0bfff17 	ldw	r2,-4(fp)
81109d14:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
81109d18:	e0bffe17 	ldw	r2,-8(fp)
81109d1c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
81109d20:	1007883a 	mov	r3,r2
81109d24:	e0bfff17 	ldw	r2,-4(fp)
81109d28:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109d2c:	e0bfff17 	ldw	r2,-4(fp)
81109d30:	10800017 	ldw	r2,0(r2)
81109d34:	01402ac4 	movi	r5,171
81109d38:	1009883a 	mov	r4,r2
81109d3c:	110a4980 	call	8110a498 <uliRmapReadReg>
81109d40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
81109d44:	e0bffe17 	ldw	r2,-8(fp)
81109d48:	1007883a 	mov	r3,r2
81109d4c:	e0bfff17 	ldw	r2,-4(fp)
81109d50:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
81109d54:	e0bffe17 	ldw	r2,-8(fp)
81109d58:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
81109d5c:	1007883a 	mov	r3,r2
81109d60:	e0bfff17 	ldw	r2,-4(fp)
81109d64:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109d68:	e0bfff17 	ldw	r2,-4(fp)
81109d6c:	10800017 	ldw	r2,0(r2)
81109d70:	01402b04 	movi	r5,172
81109d74:	1009883a 	mov	r4,r2
81109d78:	110a4980 	call	8110a498 <uliRmapReadReg>
81109d7c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
81109d80:	e0bffe17 	ldw	r2,-8(fp)
81109d84:	1007883a 	mov	r3,r2
81109d88:	e0bfff17 	ldw	r2,-4(fp)
81109d8c:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
81109d90:	e0bffe17 	ldw	r2,-8(fp)
81109d94:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
81109d98:	1007883a 	mov	r3,r2
81109d9c:	e0bfff17 	ldw	r2,-4(fp)
81109da0:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109da4:	e0bfff17 	ldw	r2,-4(fp)
81109da8:	10800017 	ldw	r2,0(r2)
81109dac:	01402b44 	movi	r5,173
81109db0:	1009883a 	mov	r4,r2
81109db4:	110a4980 	call	8110a498 <uliRmapReadReg>
81109db8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
81109dbc:	e0bffe17 	ldw	r2,-8(fp)
81109dc0:	1007883a 	mov	r3,r2
81109dc4:	e0bfff17 	ldw	r2,-4(fp)
81109dc8:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
81109dcc:	e0bffe17 	ldw	r2,-8(fp)
81109dd0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
81109dd4:	1007883a 	mov	r3,r2
81109dd8:	e0bfff17 	ldw	r2,-4(fp)
81109ddc:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109de0:	e0bfff17 	ldw	r2,-4(fp)
81109de4:	10800017 	ldw	r2,0(r2)
81109de8:	01402b84 	movi	r5,174
81109dec:	1009883a 	mov	r4,r2
81109df0:	110a4980 	call	8110a498 <uliRmapReadReg>
81109df4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
81109df8:	e0bffe17 	ldw	r2,-8(fp)
81109dfc:	1007883a 	mov	r3,r2
81109e00:	e0bfff17 	ldw	r2,-4(fp)
81109e04:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
81109e08:	e0bffe17 	ldw	r2,-8(fp)
81109e0c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
81109e10:	1007883a 	mov	r3,r2
81109e14:	e0bfff17 	ldw	r2,-4(fp)
81109e18:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109e1c:	e0bfff17 	ldw	r2,-4(fp)
81109e20:	10800017 	ldw	r2,0(r2)
81109e24:	01402bc4 	movi	r5,175
81109e28:	1009883a 	mov	r4,r2
81109e2c:	110a4980 	call	8110a498 <uliRmapReadReg>
81109e30:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
81109e34:	e0bffe17 	ldw	r2,-8(fp)
81109e38:	1007883a 	mov	r3,r2
81109e3c:	e0bfff17 	ldw	r2,-4(fp)
81109e40:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
81109e44:	e0bffe17 	ldw	r2,-8(fp)
81109e48:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
81109e4c:	1007883a 	mov	r3,r2
81109e50:	e0bfff17 	ldw	r2,-4(fp)
81109e54:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109e58:	e0bfff17 	ldw	r2,-4(fp)
81109e5c:	10800017 	ldw	r2,0(r2)
81109e60:	01402c04 	movi	r5,176
81109e64:	1009883a 	mov	r4,r2
81109e68:	110a4980 	call	8110a498 <uliRmapReadReg>
81109e6c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
81109e70:	e0bffe17 	ldw	r2,-8(fp)
81109e74:	1007883a 	mov	r3,r2
81109e78:	e0bfff17 	ldw	r2,-4(fp)
81109e7c:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
81109e80:	e0bffe17 	ldw	r2,-8(fp)
81109e84:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
81109e88:	1007883a 	mov	r3,r2
81109e8c:	e0bfff17 	ldw	r2,-4(fp)
81109e90:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109e94:	e0bfff17 	ldw	r2,-4(fp)
81109e98:	10800017 	ldw	r2,0(r2)
81109e9c:	01402c44 	movi	r5,177
81109ea0:	1009883a 	mov	r4,r2
81109ea4:	110a4980 	call	8110a498 <uliRmapReadReg>
81109ea8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
81109eac:	e0bffe17 	ldw	r2,-8(fp)
81109eb0:	1007883a 	mov	r3,r2
81109eb4:	e0bfff17 	ldw	r2,-4(fp)
81109eb8:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
81109ebc:	e0bffe17 	ldw	r2,-8(fp)
81109ec0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
81109ec4:	1007883a 	mov	r3,r2
81109ec8:	e0bfff17 	ldw	r2,-4(fp)
81109ecc:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109ed0:	e0bfff17 	ldw	r2,-4(fp)
81109ed4:	10800017 	ldw	r2,0(r2)
81109ed8:	01402c84 	movi	r5,178
81109edc:	1009883a 	mov	r4,r2
81109ee0:	110a4980 	call	8110a498 <uliRmapReadReg>
81109ee4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
81109ee8:	e0bffe17 	ldw	r2,-8(fp)
81109eec:	1007883a 	mov	r3,r2
81109ef0:	e0bfff17 	ldw	r2,-4(fp)
81109ef4:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
81109ef8:	e0bffe17 	ldw	r2,-8(fp)
81109efc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
81109f00:	1007883a 	mov	r3,r2
81109f04:	e0bfff17 	ldw	r2,-4(fp)
81109f08:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109f0c:	e0bfff17 	ldw	r2,-4(fp)
81109f10:	10800017 	ldw	r2,0(r2)
81109f14:	01402cc4 	movi	r5,179
81109f18:	1009883a 	mov	r4,r2
81109f1c:	110a4980 	call	8110a498 <uliRmapReadReg>
81109f20:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
81109f24:	e0bffe17 	ldw	r2,-8(fp)
81109f28:	1007883a 	mov	r3,r2
81109f2c:	e0bfff17 	ldw	r2,-4(fp)
81109f30:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
81109f34:	e0bffe17 	ldw	r2,-8(fp)
81109f38:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
81109f3c:	1007883a 	mov	r3,r2
81109f40:	e0bfff17 	ldw	r2,-4(fp)
81109f44:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109f48:	e0bfff17 	ldw	r2,-4(fp)
81109f4c:	10800017 	ldw	r2,0(r2)
81109f50:	01402d04 	movi	r5,180
81109f54:	1009883a 	mov	r4,r2
81109f58:	110a4980 	call	8110a498 <uliRmapReadReg>
81109f5c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
81109f60:	e0bffe17 	ldw	r2,-8(fp)
81109f64:	1007883a 	mov	r3,r2
81109f68:	e0bfff17 	ldw	r2,-4(fp)
81109f6c:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
81109f70:	e0bffe17 	ldw	r2,-8(fp)
81109f74:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
81109f78:	1007883a 	mov	r3,r2
81109f7c:	e0bfff17 	ldw	r2,-4(fp)
81109f80:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109f84:	e0bfff17 	ldw	r2,-4(fp)
81109f88:	10800017 	ldw	r2,0(r2)
81109f8c:	01402d44 	movi	r5,181
81109f90:	1009883a 	mov	r4,r2
81109f94:	110a4980 	call	8110a498 <uliRmapReadReg>
81109f98:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
81109f9c:	e0bffe17 	ldw	r2,-8(fp)
81109fa0:	1007883a 	mov	r3,r2
81109fa4:	e0bfff17 	ldw	r2,-4(fp)
81109fa8:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
81109fac:	e0bffe17 	ldw	r2,-8(fp)
81109fb0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
81109fb4:	1007883a 	mov	r3,r2
81109fb8:	e0bfff17 	ldw	r2,-4(fp)
81109fbc:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109fc0:	e0bfff17 	ldw	r2,-4(fp)
81109fc4:	10800017 	ldw	r2,0(r2)
81109fc8:	01402d84 	movi	r5,182
81109fcc:	1009883a 	mov	r4,r2
81109fd0:	110a4980 	call	8110a498 <uliRmapReadReg>
81109fd4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
81109fd8:	e0bffe17 	ldw	r2,-8(fp)
81109fdc:	1007883a 	mov	r3,r2
81109fe0:	e0bfff17 	ldw	r2,-4(fp)
81109fe4:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
81109fe8:	e0bffe17 	ldw	r2,-8(fp)
81109fec:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
81109ff0:	1007883a 	mov	r3,r2
81109ff4:	e0bfff17 	ldw	r2,-4(fp)
81109ff8:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109ffc:	e0bfff17 	ldw	r2,-4(fp)
8110a000:	10800017 	ldw	r2,0(r2)
8110a004:	01402dc4 	movi	r5,183
8110a008:	1009883a 	mov	r4,r2
8110a00c:	110a4980 	call	8110a498 <uliRmapReadReg>
8110a010:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
8110a014:	e0bffe17 	ldw	r2,-8(fp)
8110a018:	1007883a 	mov	r3,r2
8110a01c:	e0bfff17 	ldw	r2,-4(fp)
8110a020:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
8110a024:	e0bffe17 	ldw	r2,-8(fp)
8110a028:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
8110a02c:	1007883a 	mov	r3,r2
8110a030:	e0bfff17 	ldw	r2,-4(fp)
8110a034:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a038:	e0bfff17 	ldw	r2,-4(fp)
8110a03c:	10800017 	ldw	r2,0(r2)
8110a040:	01402e04 	movi	r5,184
8110a044:	1009883a 	mov	r4,r2
8110a048:	110a4980 	call	8110a498 <uliRmapReadReg>
8110a04c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
8110a050:	e0bffe17 	ldw	r2,-8(fp)
8110a054:	1007883a 	mov	r3,r2
8110a058:	e0bfff17 	ldw	r2,-4(fp)
8110a05c:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
8110a060:	e0bffe17 	ldw	r2,-8(fp)
8110a064:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
8110a068:	1007883a 	mov	r3,r2
8110a06c:	e0bfff17 	ldw	r2,-4(fp)
8110a070:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a074:	e0bfff17 	ldw	r2,-4(fp)
8110a078:	10800017 	ldw	r2,0(r2)
8110a07c:	01402e44 	movi	r5,185
8110a080:	1009883a 	mov	r4,r2
8110a084:	110a4980 	call	8110a498 <uliRmapReadReg>
8110a088:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
8110a08c:	e0bffe17 	ldw	r2,-8(fp)
8110a090:	1007883a 	mov	r3,r2
8110a094:	e0bfff17 	ldw	r2,-4(fp)
8110a098:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
8110a09c:	e0bffe17 	ldw	r2,-8(fp)
8110a0a0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
8110a0a4:	1007883a 	mov	r3,r2
8110a0a8:	e0bfff17 	ldw	r2,-4(fp)
8110a0ac:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a0b0:	e0bfff17 	ldw	r2,-4(fp)
8110a0b4:	10800017 	ldw	r2,0(r2)
8110a0b8:	01402e84 	movi	r5,186
8110a0bc:	1009883a 	mov	r4,r2
8110a0c0:	110a4980 	call	8110a498 <uliRmapReadReg>
8110a0c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
8110a0c8:	e0bffe17 	ldw	r2,-8(fp)
8110a0cc:	1007883a 	mov	r3,r2
8110a0d0:	e0bfff17 	ldw	r2,-4(fp)
8110a0d4:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
8110a0d8:	e0bffe17 	ldw	r2,-8(fp)
8110a0dc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
8110a0e0:	1007883a 	mov	r3,r2
8110a0e4:	e0bfff17 	ldw	r2,-4(fp)
8110a0e8:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a0ec:	e0bfff17 	ldw	r2,-4(fp)
8110a0f0:	10800017 	ldw	r2,0(r2)
8110a0f4:	01402ec4 	movi	r5,187
8110a0f8:	1009883a 	mov	r4,r2
8110a0fc:	110a4980 	call	8110a498 <uliRmapReadReg>
8110a100:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
8110a104:	e0bffe17 	ldw	r2,-8(fp)
8110a108:	1007883a 	mov	r3,r2
8110a10c:	e0bfff17 	ldw	r2,-4(fp)
8110a110:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
8110a114:	e0bffe17 	ldw	r2,-8(fp)
8110a118:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
8110a11c:	1007883a 	mov	r3,r2
8110a120:	e0bfff17 	ldw	r2,-4(fp)
8110a124:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a128:	e0bfff17 	ldw	r2,-4(fp)
8110a12c:	10800017 	ldw	r2,0(r2)
8110a130:	01402f04 	movi	r5,188
8110a134:	1009883a 	mov	r4,r2
8110a138:	110a4980 	call	8110a498 <uliRmapReadReg>
8110a13c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
8110a140:	e0bffe17 	ldw	r2,-8(fp)
8110a144:	1007883a 	mov	r3,r2
8110a148:	e0bfff17 	ldw	r2,-4(fp)
8110a14c:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
8110a150:	e0bffe17 	ldw	r2,-8(fp)
8110a154:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
8110a158:	1007883a 	mov	r3,r2
8110a15c:	e0bfff17 	ldw	r2,-4(fp)
8110a160:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a164:	e0bfff17 	ldw	r2,-4(fp)
8110a168:	10800017 	ldw	r2,0(r2)
8110a16c:	01402f44 	movi	r5,189
8110a170:	1009883a 	mov	r4,r2
8110a174:	110a4980 	call	8110a498 <uliRmapReadReg>
8110a178:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
8110a17c:	e0bffe17 	ldw	r2,-8(fp)
8110a180:	1007883a 	mov	r3,r2
8110a184:	e0bfff17 	ldw	r2,-4(fp)
8110a188:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
8110a18c:	e0bffe17 	ldw	r2,-8(fp)
8110a190:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
8110a194:	1007883a 	mov	r3,r2
8110a198:	e0bfff17 	ldw	r2,-4(fp)
8110a19c:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a1a0:	e0bfff17 	ldw	r2,-4(fp)
8110a1a4:	10800017 	ldw	r2,0(r2)
8110a1a8:	01402f84 	movi	r5,190
8110a1ac:	1009883a 	mov	r4,r2
8110a1b0:	110a4980 	call	8110a498 <uliRmapReadReg>
8110a1b4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
8110a1b8:	e0bffe17 	ldw	r2,-8(fp)
8110a1bc:	1007883a 	mov	r3,r2
8110a1c0:	e0bfff17 	ldw	r2,-4(fp)
8110a1c4:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
8110a1c8:	e0bffe17 	ldw	r2,-8(fp)
8110a1cc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
8110a1d0:	1007883a 	mov	r3,r2
8110a1d4:	e0bfff17 	ldw	r2,-4(fp)
8110a1d8:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110a1dc:	e0bfff17 	ldw	r2,-4(fp)
8110a1e0:	10800017 	ldw	r2,0(r2)
8110a1e4:	01402fc4 	movi	r5,191
8110a1e8:	1009883a 	mov	r4,r2
8110a1ec:	110a4980 	call	8110a498 <uliRmapReadReg>
8110a1f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
8110a1f4:	e0bffe17 	ldw	r2,-8(fp)
8110a1f8:	1007883a 	mov	r3,r2
8110a1fc:	e0bfff17 	ldw	r2,-4(fp)
8110a200:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
8110a204:	e0bffe17 	ldw	r2,-8(fp)
8110a208:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
8110a20c:	1007883a 	mov	r3,r2
8110a210:	e0bfff17 	ldw	r2,-4(fp)
8110a214:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
8110a218:	00800044 	movi	r2,1
8110a21c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a220:	e0bffd17 	ldw	r2,-12(fp)
}
8110a224:	e037883a 	mov	sp,fp
8110a228:	dfc00117 	ldw	ra,4(sp)
8110a22c:	df000017 	ldw	fp,0(sp)
8110a230:	dec00204 	addi	sp,sp,8
8110a234:	f800283a 	ret

8110a238 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
8110a238:	defff904 	addi	sp,sp,-28
8110a23c:	de00012e 	bgeu	sp,et,8110a244 <bRmapInitCh+0xc>
8110a240:	003b68fa 	trap	3
8110a244:	dfc00615 	stw	ra,24(sp)
8110a248:	df000515 	stw	fp,20(sp)
8110a24c:	df000504 	addi	fp,sp,20
8110a250:	e13ffe15 	stw	r4,-8(fp)
8110a254:	2805883a 	mov	r2,r5
8110a258:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110a25c:	e03ffb15 	stw	zero,-20(fp)
	bool bValidCh = FALSE;
8110a260:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
8110a264:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
8110a268:	e0bffe17 	ldw	r2,-8(fp)
8110a26c:	10006f26 	beq	r2,zero,8110a42c <bRmapInitCh+0x1f4>

		switch (ucCommCh) {
8110a270:	e0bfff03 	ldbu	r2,-4(fp)
8110a274:	10c00228 	cmpgeui	r3,r2,8
8110a278:	1800461e 	bne	r3,zero,8110a394 <bRmapInitCh+0x15c>
8110a27c:	100690ba 	slli	r3,r2,2
8110a280:	00a04474 	movhi	r2,33041
8110a284:	10a8a504 	addi	r2,r2,-23916
8110a288:	1885883a 	add	r2,r3,r2
8110a28c:	10800017 	ldw	r2,0(r2)
8110a290:	1000683a 	jmp	r2
8110a294:	8110a2b4 	orhi	r4,r16,17034
8110a298:	8110a2d0 	cmplti	r4,r16,17035
8110a29c:	8110a2ec 	andhi	r4,r16,17035
8110a2a0:	8110a308 	cmpgei	r4,r16,17036
8110a2a4:	8110a324 	muli	r4,r16,17036
8110a2a8:	8110a340 	call	88110a34 <__reset+0x20f0a34>
8110a2ac:	8110a35c 	xori	r4,r16,17037
8110a2b0:	8110a378 	rdprs	r4,r16,17037
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110a2b4:	e0fffe17 	ldw	r3,-8(fp)
8110a2b8:	00a04834 	movhi	r2,33056
8110a2bc:	108b0004 	addi	r2,r2,11264
8110a2c0:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a2c4:	00800044 	movi	r2,1
8110a2c8:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a2cc:	00003306 	br	8110a39c <bRmapInitCh+0x164>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8110a2d0:	e0fffe17 	ldw	r3,-8(fp)
8110a2d4:	00a04834 	movhi	r2,33056
8110a2d8:	108a0004 	addi	r2,r2,10240
8110a2dc:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a2e0:	00800044 	movi	r2,1
8110a2e4:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a2e8:	00002c06 	br	8110a39c <bRmapInitCh+0x164>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110a2ec:	e0fffe17 	ldw	r3,-8(fp)
8110a2f0:	00a04834 	movhi	r2,33056
8110a2f4:	108b0004 	addi	r2,r2,11264
8110a2f8:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a2fc:	00800044 	movi	r2,1
8110a300:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a304:	00002506 	br	8110a39c <bRmapInitCh+0x164>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110a308:	e0fffe17 	ldw	r3,-8(fp)
8110a30c:	00a04834 	movhi	r2,33056
8110a310:	108a0004 	addi	r2,r2,10240
8110a314:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a318:	00800044 	movi	r2,1
8110a31c:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a320:	00001e06 	br	8110a39c <bRmapInitCh+0x164>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110a324:	e0fffe17 	ldw	r3,-8(fp)
8110a328:	00a04834 	movhi	r2,33056
8110a32c:	108b0004 	addi	r2,r2,11264
8110a330:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a334:	00800044 	movi	r2,1
8110a338:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a33c:	00001706 	br	8110a39c <bRmapInitCh+0x164>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8110a340:	e0fffe17 	ldw	r3,-8(fp)
8110a344:	00a04834 	movhi	r2,33056
8110a348:	108a0004 	addi	r2,r2,10240
8110a34c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a350:	00800044 	movi	r2,1
8110a354:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a358:	00001006 	br	8110a39c <bRmapInitCh+0x164>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110a35c:	e0fffe17 	ldw	r3,-8(fp)
8110a360:	00a04834 	movhi	r2,33056
8110a364:	108b0004 	addi	r2,r2,11264
8110a368:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a36c:	00800044 	movi	r2,1
8110a370:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a374:	00000906 	br	8110a39c <bRmapInitCh+0x164>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110a378:	e0fffe17 	ldw	r3,-8(fp)
8110a37c:	00a04834 	movhi	r2,33056
8110a380:	108a0004 	addi	r2,r2,10240
8110a384:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110a388:	00800044 	movi	r2,1
8110a38c:	e0bffc15 	stw	r2,-16(fp)
			break;
8110a390:	00000206 	br	8110a39c <bRmapInitCh+0x164>
		default:
			bValidCh = FALSE;
8110a394:	e03ffc15 	stw	zero,-16(fp)
			break;
8110a398:	0001883a 	nop
		}

		if (bValidCh) {
8110a39c:	e0bffc17 	ldw	r2,-16(fp)
8110a3a0:	10002226 	beq	r2,zero,8110a42c <bRmapInitCh+0x1f4>
			if (!bRmapGetIrqControl(pxRmapCh)) {
8110a3a4:	e13ffe17 	ldw	r4,-8(fp)
8110a3a8:	1107dcc0 	call	81107dcc <bRmapGetIrqControl>
8110a3ac:	1000021e 	bne	r2,zero,8110a3b8 <bRmapInitCh+0x180>
				bInitFail = TRUE;
8110a3b0:	00800044 	movi	r2,1
8110a3b4:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
8110a3b8:	e13ffe17 	ldw	r4,-8(fp)
8110a3bc:	1107fb80 	call	81107fb8 <bRmapGetCodecConfig>
8110a3c0:	1000021e 	bne	r2,zero,8110a3cc <bRmapInitCh+0x194>
				bInitFail = TRUE;
8110a3c4:	00800044 	movi	r2,1
8110a3c8:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
8110a3cc:	e13ffe17 	ldw	r4,-8(fp)
8110a3d0:	11080440 	call	81108044 <bRmapGetCodecStatus>
8110a3d4:	1000021e 	bne	r2,zero,8110a3e0 <bRmapInitCh+0x1a8>
				bInitFail = TRUE;
8110a3d8:	00800044 	movi	r2,1
8110a3dc:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
8110a3e0:	e13ffe17 	ldw	r4,-8(fp)
8110a3e4:	11086380 	call	81108638 <bRmapGetMemConfigArea>
8110a3e8:	1000021e 	bne	r2,zero,8110a3f4 <bRmapInitCh+0x1bc>
				bInitFail = TRUE;
8110a3ec:	00800044 	movi	r2,1
8110a3f0:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
8110a3f4:	e13ffe17 	ldw	r4,-8(fp)
8110a3f8:	110890c0 	call	8110890c <bRmapGetMemConfigStat>
8110a3fc:	1000021e 	bne	r2,zero,8110a408 <bRmapInitCh+0x1d0>
				bInitFail = TRUE;
8110a400:	00800044 	movi	r2,1
8110a404:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
8110a408:	e13ffe17 	ldw	r4,-8(fp)
8110a40c:	1109a6c0 	call	81109a6c <bRmapGetRmapMemHKArea>
8110a410:	1000021e 	bne	r2,zero,8110a41c <bRmapInitCh+0x1e4>
				bInitFail = TRUE;
8110a414:	00800044 	movi	r2,1
8110a418:	e0bffd15 	stw	r2,-12(fp)
			}

			if (!bInitFail) {
8110a41c:	e0bffd17 	ldw	r2,-12(fp)
8110a420:	1000021e 	bne	r2,zero,8110a42c <bRmapInitCh+0x1f4>
				bStatus = TRUE;
8110a424:	00800044 	movi	r2,1
8110a428:	e0bffb15 	stw	r2,-20(fp)
			}
		}
	}
	return bStatus;
8110a42c:	e0bffb17 	ldw	r2,-20(fp)
}
8110a430:	e037883a 	mov	sp,fp
8110a434:	dfc00117 	ldw	ra,4(sp)
8110a438:	df000017 	ldw	fp,0(sp)
8110a43c:	dec00204 	addi	sp,sp,8
8110a440:	f800283a 	ret

8110a444 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110a444:	defffc04 	addi	sp,sp,-16
8110a448:	de00012e 	bgeu	sp,et,8110a450 <vRmapWriteReg+0xc>
8110a44c:	003b68fa 	trap	3
8110a450:	df000315 	stw	fp,12(sp)
8110a454:	df000304 	addi	fp,sp,12
8110a458:	e13ffd15 	stw	r4,-12(fp)
8110a45c:	e17ffe15 	stw	r5,-8(fp)
8110a460:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110a464:	e0bffe17 	ldw	r2,-8(fp)
8110a468:	1085883a 	add	r2,r2,r2
8110a46c:	1085883a 	add	r2,r2,r2
8110a470:	1007883a 	mov	r3,r2
8110a474:	e0bffd17 	ldw	r2,-12(fp)
8110a478:	10c5883a 	add	r2,r2,r3
8110a47c:	e0ffff17 	ldw	r3,-4(fp)
8110a480:	10c00015 	stw	r3,0(r2)
}
8110a484:	0001883a 	nop
8110a488:	e037883a 	mov	sp,fp
8110a48c:	df000017 	ldw	fp,0(sp)
8110a490:	dec00104 	addi	sp,sp,4
8110a494:	f800283a 	ret

8110a498 <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110a498:	defffc04 	addi	sp,sp,-16
8110a49c:	de00012e 	bgeu	sp,et,8110a4a4 <uliRmapReadReg+0xc>
8110a4a0:	003b68fa 	trap	3
8110a4a4:	df000315 	stw	fp,12(sp)
8110a4a8:	df000304 	addi	fp,sp,12
8110a4ac:	e13ffe15 	stw	r4,-8(fp)
8110a4b0:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110a4b4:	e0bfff17 	ldw	r2,-4(fp)
8110a4b8:	1085883a 	add	r2,r2,r2
8110a4bc:	1085883a 	add	r2,r2,r2
8110a4c0:	1007883a 	mov	r3,r2
8110a4c4:	e0bffe17 	ldw	r2,-8(fp)
8110a4c8:	10c5883a 	add	r2,r2,r3
8110a4cc:	10800017 	ldw	r2,0(r2)
8110a4d0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110a4d4:	e0bffd17 	ldw	r2,-12(fp)
}
8110a4d8:	e037883a 	mov	sp,fp
8110a4dc:	df000017 	ldw	fp,0(sp)
8110a4e0:	dec00104 	addi	sp,sp,4
8110a4e4:	f800283a 	ret

8110a4e8 <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
8110a4e8:	defffd04 	addi	sp,sp,-12
8110a4ec:	de00012e 	bgeu	sp,et,8110a4f4 <uliConvRmapCfgAddr+0xc>
8110a4f0:	003b68fa 	trap	3
8110a4f4:	df000215 	stw	fp,8(sp)
8110a4f8:	df000204 	addi	fp,sp,8
8110a4fc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
8110a500:	e0bfff17 	ldw	r2,-4(fp)
8110a504:	10801368 	cmpgeui	r2,r2,77
8110a508:	10008a1e 	bne	r2,zero,8110a734 <uliConvRmapCfgAddr+0x24c>
8110a50c:	e0bfff17 	ldw	r2,-4(fp)
8110a510:	100690ba 	slli	r3,r2,2
8110a514:	00a04474 	movhi	r2,33041
8110a518:	10a94a04 	addi	r2,r2,-23256
8110a51c:	1885883a 	add	r2,r3,r2
8110a520:	10800017 	ldw	r2,0(r2)
8110a524:	1000683a 	jmp	r2
8110a528:	8110a65c 	xori	r4,r16,17049
8110a52c:	8110a734 	orhi	r4,r16,17052
8110a530:	8110a734 	orhi	r4,r16,17052
8110a534:	8110a734 	orhi	r4,r16,17052
8110a538:	8110a668 	cmpgeui	r4,r16,17049
8110a53c:	8110a734 	orhi	r4,r16,17052
8110a540:	8110a734 	orhi	r4,r16,17052
8110a544:	8110a734 	orhi	r4,r16,17052
8110a548:	8110a674 	orhi	r4,r16,17049
8110a54c:	8110a734 	orhi	r4,r16,17052
8110a550:	8110a734 	orhi	r4,r16,17052
8110a554:	8110a734 	orhi	r4,r16,17052
8110a558:	8110a680 	call	88110a68 <__reset+0x20f0a68>
8110a55c:	8110a734 	orhi	r4,r16,17052
8110a560:	8110a734 	orhi	r4,r16,17052
8110a564:	8110a734 	orhi	r4,r16,17052
8110a568:	8110a68c 	andi	r4,r16,17050
8110a56c:	8110a734 	orhi	r4,r16,17052
8110a570:	8110a734 	orhi	r4,r16,17052
8110a574:	8110a734 	orhi	r4,r16,17052
8110a578:	8110a698 	cmpnei	r4,r16,17050
8110a57c:	8110a734 	orhi	r4,r16,17052
8110a580:	8110a734 	orhi	r4,r16,17052
8110a584:	8110a734 	orhi	r4,r16,17052
8110a588:	8110a6a4 	muli	r4,r16,17050
8110a58c:	8110a734 	orhi	r4,r16,17052
8110a590:	8110a734 	orhi	r4,r16,17052
8110a594:	8110a734 	orhi	r4,r16,17052
8110a598:	8110a6b0 	cmpltui	r4,r16,17050
8110a59c:	8110a734 	orhi	r4,r16,17052
8110a5a0:	8110a734 	orhi	r4,r16,17052
8110a5a4:	8110a734 	orhi	r4,r16,17052
8110a5a8:	8110a6bc 	xorhi	r4,r16,17050
8110a5ac:	8110a734 	orhi	r4,r16,17052
8110a5b0:	8110a734 	orhi	r4,r16,17052
8110a5b4:	8110a734 	orhi	r4,r16,17052
8110a5b8:	8110a6c8 	cmpgei	r4,r16,17051
8110a5bc:	8110a734 	orhi	r4,r16,17052
8110a5c0:	8110a734 	orhi	r4,r16,17052
8110a5c4:	8110a734 	orhi	r4,r16,17052
8110a5c8:	8110a6d4 	ori	r4,r16,17051
8110a5cc:	8110a734 	orhi	r4,r16,17052
8110a5d0:	8110a734 	orhi	r4,r16,17052
8110a5d4:	8110a734 	orhi	r4,r16,17052
8110a5d8:	8110a6e0 	cmpeqi	r4,r16,17051
8110a5dc:	8110a734 	orhi	r4,r16,17052
8110a5e0:	8110a734 	orhi	r4,r16,17052
8110a5e4:	8110a734 	orhi	r4,r16,17052
8110a5e8:	8110a734 	orhi	r4,r16,17052
8110a5ec:	8110a734 	orhi	r4,r16,17052
8110a5f0:	8110a734 	orhi	r4,r16,17052
8110a5f4:	8110a734 	orhi	r4,r16,17052
8110a5f8:	8110a734 	orhi	r4,r16,17052
8110a5fc:	8110a734 	orhi	r4,r16,17052
8110a600:	8110a734 	orhi	r4,r16,17052
8110a604:	8110a734 	orhi	r4,r16,17052
8110a608:	8110a6ec 	andhi	r4,r16,17051
8110a60c:	8110a734 	orhi	r4,r16,17052
8110a610:	8110a734 	orhi	r4,r16,17052
8110a614:	8110a734 	orhi	r4,r16,17052
8110a618:	8110a6f8 	rdprs	r4,r16,17051
8110a61c:	8110a734 	orhi	r4,r16,17052
8110a620:	8110a734 	orhi	r4,r16,17052
8110a624:	8110a734 	orhi	r4,r16,17052
8110a628:	8110a704 	addi	r4,r16,17052
8110a62c:	8110a734 	orhi	r4,r16,17052
8110a630:	8110a734 	orhi	r4,r16,17052
8110a634:	8110a734 	orhi	r4,r16,17052
8110a638:	8110a710 	cmplti	r4,r16,17052
8110a63c:	8110a734 	orhi	r4,r16,17052
8110a640:	8110a734 	orhi	r4,r16,17052
8110a644:	8110a734 	orhi	r4,r16,17052
8110a648:	8110a71c 	xori	r4,r16,17052
8110a64c:	8110a734 	orhi	r4,r16,17052
8110a650:	8110a734 	orhi	r4,r16,17052
8110a654:	8110a734 	orhi	r4,r16,17052
8110a658:	8110a728 	cmpgeui	r4,r16,17052
	case 0x00000000:
		uliValue = 0x00000040;
8110a65c:	00801004 	movi	r2,64
8110a660:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a664:	00003506 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
8110a668:	00801044 	movi	r2,65
8110a66c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a670:	00003206 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
8110a674:	00801084 	movi	r2,66
8110a678:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a67c:	00002f06 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
8110a680:	008010c4 	movi	r2,67
8110a684:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a688:	00002c06 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
8110a68c:	00801104 	movi	r2,68
8110a690:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a694:	00002906 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
8110a698:	00801144 	movi	r2,69
8110a69c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a6a0:	00002606 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
8110a6a4:	00801184 	movi	r2,70
8110a6a8:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a6ac:	00002306 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
8110a6b0:	008011c4 	movi	r2,71
8110a6b4:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a6b8:	00002006 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
8110a6bc:	00801204 	movi	r2,72
8110a6c0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a6c4:	00001d06 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
8110a6c8:	00801244 	movi	r2,73
8110a6cc:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a6d0:	00001a06 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
8110a6d4:	00801284 	movi	r2,74
8110a6d8:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a6dc:	00001706 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
8110a6e0:	008012c4 	movi	r2,75
8110a6e4:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a6e8:	00001406 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
8110a6ec:	00801304 	movi	r2,76
8110a6f0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a6f4:	00001106 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
8110a6f8:	00801344 	movi	r2,77
8110a6fc:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a700:	00000e06 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
8110a704:	00801384 	movi	r2,78
8110a708:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a70c:	00000b06 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
8110a710:	008013c4 	movi	r2,79
8110a714:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a718:	00000806 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
8110a71c:	00801404 	movi	r2,80
8110a720:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a724:	00000506 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
8110a728:	00801444 	movi	r2,81
8110a72c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a730:	00000206 	br	8110a73c <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
8110a734:	e03ffe15 	stw	zero,-8(fp)
		break;
8110a738:	0001883a 	nop
	}

	return uliValue;
8110a73c:	e0bffe17 	ldw	r2,-8(fp)
}
8110a740:	e037883a 	mov	sp,fp
8110a744:	df000017 	ldw	fp,0(sp)
8110a748:	dec00104 	addi	sp,sp,4
8110a74c:	f800283a 	ret

8110a750 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
8110a750:	defffb04 	addi	sp,sp,-20
8110a754:	de00012e 	bgeu	sp,et,8110a75c <bSpwcSetLink+0xc>
8110a758:	003b68fa 	trap	3
8110a75c:	dfc00415 	stw	ra,16(sp)
8110a760:	df000315 	stw	fp,12(sp)
8110a764:	df000304 	addi	fp,sp,12
8110a768:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a76c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110a770:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a774:	e0bfff17 	ldw	r2,-4(fp)
8110a778:	10003d26 	beq	r2,zero,8110a870 <bSpwcSetLink+0x120>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a77c:	e0bfff17 	ldw	r2,-4(fp)
8110a780:	10800017 	ldw	r2,0(r2)
8110a784:	000b883a 	mov	r5,zero
8110a788:	1009883a 	mov	r4,r2
8110a78c:	110ae840 	call	8110ae84 <uliSpwcReadReg>
8110a790:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
8110a794:	e0bfff17 	ldw	r2,-4(fp)
8110a798:	10800117 	ldw	r2,4(r2)
8110a79c:	10000426 	beq	r2,zero,8110a7b0 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
8110a7a0:	e0bffe17 	ldw	r2,-8(fp)
8110a7a4:	10800114 	ori	r2,r2,4
8110a7a8:	e0bffe15 	stw	r2,-8(fp)
8110a7ac:	00000406 	br	8110a7c0 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
8110a7b0:	e0fffe17 	ldw	r3,-8(fp)
8110a7b4:	00bffec4 	movi	r2,-5
8110a7b8:	1884703a 	and	r2,r3,r2
8110a7bc:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
8110a7c0:	e0bfff17 	ldw	r2,-4(fp)
8110a7c4:	10800217 	ldw	r2,8(r2)
8110a7c8:	10000426 	beq	r2,zero,8110a7dc <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
8110a7cc:	e0bffe17 	ldw	r2,-8(fp)
8110a7d0:	10800094 	ori	r2,r2,2
8110a7d4:	e0bffe15 	stw	r2,-8(fp)
8110a7d8:	00000406 	br	8110a7ec <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
8110a7dc:	e0fffe17 	ldw	r3,-8(fp)
8110a7e0:	00bfff44 	movi	r2,-3
8110a7e4:	1884703a 	and	r2,r3,r2
8110a7e8:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
8110a7ec:	e0bfff17 	ldw	r2,-4(fp)
8110a7f0:	10800317 	ldw	r2,12(r2)
8110a7f4:	10000426 	beq	r2,zero,8110a808 <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
8110a7f8:	e0bffe17 	ldw	r2,-8(fp)
8110a7fc:	10800054 	ori	r2,r2,1
8110a800:	e0bffe15 	stw	r2,-8(fp)
8110a804:	00000406 	br	8110a818 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
8110a808:	e0fffe17 	ldw	r3,-8(fp)
8110a80c:	00bfff84 	movi	r2,-2
8110a810:	1884703a 	and	r2,r3,r2
8110a814:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
8110a818:	e0fffe17 	ldw	r3,-8(fp)
8110a81c:	00804034 	movhi	r2,256
8110a820:	10bfffc4 	addi	r2,r2,-1
8110a824:	1884703a 	and	r2,r3,r2
8110a828:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
8110a82c:	e0bfff17 	ldw	r2,-4(fp)
8110a830:	10800403 	ldbu	r2,16(r2)
8110a834:	10803fcc 	andi	r2,r2,255
8110a838:	1004963a 	slli	r2,r2,24
8110a83c:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
8110a840:	e0bffe17 	ldw	r2,-8(fp)
8110a844:	1884b03a 	or	r2,r3,r2
8110a848:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
8110a84c:	e0bfff17 	ldw	r2,-4(fp)
8110a850:	10800017 	ldw	r2,0(r2)
8110a854:	e0fffe17 	ldw	r3,-8(fp)
8110a858:	180d883a 	mov	r6,r3
8110a85c:	000b883a 	mov	r5,zero
8110a860:	1009883a 	mov	r4,r2
8110a864:	110ae300 	call	8110ae30 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
8110a868:	00800044 	movi	r2,1
8110a86c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a870:	e0bffd17 	ldw	r2,-12(fp)
}
8110a874:	e037883a 	mov	sp,fp
8110a878:	dfc00117 	ldw	ra,4(sp)
8110a87c:	df000017 	ldw	fp,0(sp)
8110a880:	dec00204 	addi	sp,sp,8
8110a884:	f800283a 	ret

8110a888 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
8110a888:	defffb04 	addi	sp,sp,-20
8110a88c:	de00012e 	bgeu	sp,et,8110a894 <bSpwcGetLink+0xc>
8110a890:	003b68fa 	trap	3
8110a894:	dfc00415 	stw	ra,16(sp)
8110a898:	df000315 	stw	fp,12(sp)
8110a89c:	df000304 	addi	fp,sp,12
8110a8a0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a8a4:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110a8a8:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a8ac:	e0bfff17 	ldw	r2,-4(fp)
8110a8b0:	10002826 	beq	r2,zero,8110a954 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a8b4:	e0bfff17 	ldw	r2,-4(fp)
8110a8b8:	10800017 	ldw	r2,0(r2)
8110a8bc:	000b883a 	mov	r5,zero
8110a8c0:	1009883a 	mov	r4,r2
8110a8c4:	110ae840 	call	8110ae84 <uliSpwcReadReg>
8110a8c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
8110a8cc:	e0bffe17 	ldw	r2,-8(fp)
8110a8d0:	1080010c 	andi	r2,r2,4
8110a8d4:	10000426 	beq	r2,zero,8110a8e8 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
8110a8d8:	e0bfff17 	ldw	r2,-4(fp)
8110a8dc:	00c00044 	movi	r3,1
8110a8e0:	10c00115 	stw	r3,4(r2)
8110a8e4:	00000206 	br	8110a8f0 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
8110a8e8:	e0bfff17 	ldw	r2,-4(fp)
8110a8ec:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
8110a8f0:	e0bffe17 	ldw	r2,-8(fp)
8110a8f4:	1080008c 	andi	r2,r2,2
8110a8f8:	10000426 	beq	r2,zero,8110a90c <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
8110a8fc:	e0bfff17 	ldw	r2,-4(fp)
8110a900:	00c00044 	movi	r3,1
8110a904:	10c00215 	stw	r3,8(r2)
8110a908:	00000206 	br	8110a914 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
8110a90c:	e0bfff17 	ldw	r2,-4(fp)
8110a910:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
8110a914:	e0bffe17 	ldw	r2,-8(fp)
8110a918:	1080004c 	andi	r2,r2,1
8110a91c:	10000426 	beq	r2,zero,8110a930 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
8110a920:	e0bfff17 	ldw	r2,-4(fp)
8110a924:	00c00044 	movi	r3,1
8110a928:	10c00315 	stw	r3,12(r2)
8110a92c:	00000206 	br	8110a938 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
8110a930:	e0bfff17 	ldw	r2,-4(fp)
8110a934:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
8110a938:	e0bffe17 	ldw	r2,-8(fp)
8110a93c:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
8110a940:	1007883a 	mov	r3,r2
8110a944:	e0bfff17 	ldw	r2,-4(fp)
8110a948:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
8110a94c:	00800044 	movi	r2,1
8110a950:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a954:	e0bffd17 	ldw	r2,-12(fp)
}
8110a958:	e037883a 	mov	sp,fp
8110a95c:	dfc00117 	ldw	ra,4(sp)
8110a960:	df000017 	ldw	fp,0(sp)
8110a964:	dec00204 	addi	sp,sp,8
8110a968:	f800283a 	ret

8110a96c <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8110a96c:	defffb04 	addi	sp,sp,-20
8110a970:	de00012e 	bgeu	sp,et,8110a978 <bSpwcGetLinkError+0xc>
8110a974:	003b68fa 	trap	3
8110a978:	dfc00415 	stw	ra,16(sp)
8110a97c:	df000315 	stw	fp,12(sp)
8110a980:	df000304 	addi	fp,sp,12
8110a984:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a988:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110a98c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a990:	e0bfff17 	ldw	r2,-4(fp)
8110a994:	10002c26 	beq	r2,zero,8110aa48 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a998:	e0bfff17 	ldw	r2,-4(fp)
8110a99c:	10800017 	ldw	r2,0(r2)
8110a9a0:	000b883a 	mov	r5,zero
8110a9a4:	1009883a 	mov	r4,r2
8110a9a8:	110ae840 	call	8110ae84 <uliSpwcReadReg>
8110a9ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
8110a9b0:	e0bffe17 	ldw	r2,-8(fp)
8110a9b4:	1080006c 	andhi	r2,r2,1
8110a9b8:	10000426 	beq	r2,zero,8110a9cc <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
8110a9bc:	e0bfff17 	ldw	r2,-4(fp)
8110a9c0:	00c00044 	movi	r3,1
8110a9c4:	10c00515 	stw	r3,20(r2)
8110a9c8:	00000206 	br	8110a9d4 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
8110a9cc:	e0bfff17 	ldw	r2,-4(fp)
8110a9d0:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
8110a9d4:	e0bffe17 	ldw	r2,-8(fp)
8110a9d8:	108000ac 	andhi	r2,r2,2
8110a9dc:	10000426 	beq	r2,zero,8110a9f0 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
8110a9e0:	e0bfff17 	ldw	r2,-4(fp)
8110a9e4:	00c00044 	movi	r3,1
8110a9e8:	10c00615 	stw	r3,24(r2)
8110a9ec:	00000206 	br	8110a9f8 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
8110a9f0:	e0bfff17 	ldw	r2,-4(fp)
8110a9f4:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
8110a9f8:	e0bffe17 	ldw	r2,-8(fp)
8110a9fc:	1080012c 	andhi	r2,r2,4
8110aa00:	10000426 	beq	r2,zero,8110aa14 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
8110aa04:	e0bfff17 	ldw	r2,-4(fp)
8110aa08:	00c00044 	movi	r3,1
8110aa0c:	10c00715 	stw	r3,28(r2)
8110aa10:	00000206 	br	8110aa1c <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
8110aa14:	e0bfff17 	ldw	r2,-4(fp)
8110aa18:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
8110aa1c:	e0bffe17 	ldw	r2,-8(fp)
8110aa20:	1080022c 	andhi	r2,r2,8
8110aa24:	10000426 	beq	r2,zero,8110aa38 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
8110aa28:	e0bfff17 	ldw	r2,-4(fp)
8110aa2c:	00c00044 	movi	r3,1
8110aa30:	10c00815 	stw	r3,32(r2)
8110aa34:	00000206 	br	8110aa40 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
8110aa38:	e0bfff17 	ldw	r2,-4(fp)
8110aa3c:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
8110aa40:	00800044 	movi	r2,1
8110aa44:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110aa48:	e0bffd17 	ldw	r2,-12(fp)
}
8110aa4c:	e037883a 	mov	sp,fp
8110aa50:	dfc00117 	ldw	ra,4(sp)
8110aa54:	df000017 	ldw	fp,0(sp)
8110aa58:	dec00204 	addi	sp,sp,8
8110aa5c:	f800283a 	ret

8110aa60 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
8110aa60:	defffb04 	addi	sp,sp,-20
8110aa64:	de00012e 	bgeu	sp,et,8110aa6c <bSpwcGetLinkStatus+0xc>
8110aa68:	003b68fa 	trap	3
8110aa6c:	dfc00415 	stw	ra,16(sp)
8110aa70:	df000315 	stw	fp,12(sp)
8110aa74:	df000304 	addi	fp,sp,12
8110aa78:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110aa7c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110aa80:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110aa84:	e0bfff17 	ldw	r2,-4(fp)
8110aa88:	10002326 	beq	r2,zero,8110ab18 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110aa8c:	e0bfff17 	ldw	r2,-4(fp)
8110aa90:	10800017 	ldw	r2,0(r2)
8110aa94:	000b883a 	mov	r5,zero
8110aa98:	1009883a 	mov	r4,r2
8110aa9c:	110ae840 	call	8110ae84 <uliSpwcReadReg>
8110aaa0:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
8110aaa4:	e0bffe17 	ldw	r2,-8(fp)
8110aaa8:	1081000c 	andi	r2,r2,1024
8110aaac:	10000426 	beq	r2,zero,8110aac0 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
8110aab0:	e0bfff17 	ldw	r2,-4(fp)
8110aab4:	00c00044 	movi	r3,1
8110aab8:	10c00915 	stw	r3,36(r2)
8110aabc:	00000206 	br	8110aac8 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
8110aac0:	e0bfff17 	ldw	r2,-4(fp)
8110aac4:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
8110aac8:	e0bffe17 	ldw	r2,-8(fp)
8110aacc:	1080800c 	andi	r2,r2,512
8110aad0:	10000426 	beq	r2,zero,8110aae4 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
8110aad4:	e0bfff17 	ldw	r2,-4(fp)
8110aad8:	00c00044 	movi	r3,1
8110aadc:	10c00a15 	stw	r3,40(r2)
8110aae0:	00000206 	br	8110aaec <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
8110aae4:	e0bfff17 	ldw	r2,-4(fp)
8110aae8:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
8110aaec:	e0bffe17 	ldw	r2,-8(fp)
8110aaf0:	1080400c 	andi	r2,r2,256
8110aaf4:	10000426 	beq	r2,zero,8110ab08 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
8110aaf8:	e0bfff17 	ldw	r2,-4(fp)
8110aafc:	00c00044 	movi	r3,1
8110ab00:	10c00b15 	stw	r3,44(r2)
8110ab04:	00000206 	br	8110ab10 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
8110ab08:	e0bfff17 	ldw	r2,-4(fp)
8110ab0c:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
8110ab10:	00800044 	movi	r2,1
8110ab14:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110ab18:	e0bffd17 	ldw	r2,-12(fp)
}
8110ab1c:	e037883a 	mov	sp,fp
8110ab20:	dfc00117 	ldw	ra,4(sp)
8110ab24:	df000017 	ldw	fp,0(sp)
8110ab28:	dec00204 	addi	sp,sp,8
8110ab2c:	f800283a 	ret

8110ab30 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
8110ab30:	defffb04 	addi	sp,sp,-20
8110ab34:	de00012e 	bgeu	sp,et,8110ab3c <bSpwcGetTimecode+0xc>
8110ab38:	003b68fa 	trap	3
8110ab3c:	dfc00415 	stw	ra,16(sp)
8110ab40:	df000315 	stw	fp,12(sp)
8110ab44:	df000304 	addi	fp,sp,12
8110ab48:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110ab4c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110ab50:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110ab54:	e0bfff17 	ldw	r2,-4(fp)
8110ab58:	10001326 	beq	r2,zero,8110aba8 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110ab5c:	e0bfff17 	ldw	r2,-4(fp)
8110ab60:	10800017 	ldw	r2,0(r2)
8110ab64:	01400044 	movi	r5,1
8110ab68:	1009883a 	mov	r4,r2
8110ab6c:	110ae840 	call	8110ae84 <uliSpwcReadReg>
8110ab70:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
8110ab74:	e0bffe17 	ldw	r2,-8(fp)
8110ab78:	1080300c 	andi	r2,r2,192
8110ab7c:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
8110ab80:	1007883a 	mov	r3,r2
8110ab84:	e0bfff17 	ldw	r2,-4(fp)
8110ab88:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
8110ab8c:	e0bffe17 	ldw	r2,-8(fp)
8110ab90:	10800fcc 	andi	r2,r2,63
8110ab94:	1007883a 	mov	r3,r2
8110ab98:	e0bfff17 	ldw	r2,-4(fp)
8110ab9c:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
8110aba0:	00800044 	movi	r2,1
8110aba4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110aba8:	e0bffd17 	ldw	r2,-12(fp)
}
8110abac:	e037883a 	mov	sp,fp
8110abb0:	dfc00117 	ldw	ra,4(sp)
8110abb4:	df000017 	ldw	fp,0(sp)
8110abb8:	dec00204 	addi	sp,sp,8
8110abbc:	f800283a 	ret

8110abc0 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
8110abc0:	defffb04 	addi	sp,sp,-20
8110abc4:	de00012e 	bgeu	sp,et,8110abcc <bSpwcClearTimecode+0xc>
8110abc8:	003b68fa 	trap	3
8110abcc:	dfc00415 	stw	ra,16(sp)
8110abd0:	df000315 	stw	fp,12(sp)
8110abd4:	df000304 	addi	fp,sp,12
8110abd8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110abdc:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8110abe0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110abe4:	e0bfff17 	ldw	r2,-4(fp)
8110abe8:	10001226 	beq	r2,zero,8110ac34 <bSpwcClearTimecode+0x74>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110abec:	e0bfff17 	ldw	r2,-4(fp)
8110abf0:	10800017 	ldw	r2,0(r2)
8110abf4:	01400044 	movi	r5,1
8110abf8:	1009883a 	mov	r4,r2
8110abfc:	110ae840 	call	8110ae84 <uliSpwcReadReg>
8110ac00:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
8110ac04:	e0bffe17 	ldw	r2,-8(fp)
8110ac08:	10804014 	ori	r2,r2,256
8110ac0c:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
8110ac10:	e0bfff17 	ldw	r2,-4(fp)
8110ac14:	10800017 	ldw	r2,0(r2)
8110ac18:	e0fffe17 	ldw	r3,-8(fp)
8110ac1c:	180d883a 	mov	r6,r3
8110ac20:	01400044 	movi	r5,1
8110ac24:	1009883a 	mov	r4,r2
8110ac28:	110ae300 	call	8110ae30 <vSpwcWriteReg>
		bStatus = TRUE;
8110ac2c:	00800044 	movi	r2,1
8110ac30:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110ac34:	e0bffd17 	ldw	r2,-12(fp)
}
8110ac38:	e037883a 	mov	sp,fp
8110ac3c:	dfc00117 	ldw	ra,4(sp)
8110ac40:	df000017 	ldw	fp,0(sp)
8110ac44:	dec00204 	addi	sp,sp,8
8110ac48:	f800283a 	ret

8110ac4c <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
8110ac4c:	defff904 	addi	sp,sp,-28
8110ac50:	de00012e 	bgeu	sp,et,8110ac58 <bSpwcInitCh+0xc>
8110ac54:	003b68fa 	trap	3
8110ac58:	dfc00615 	stw	ra,24(sp)
8110ac5c:	df000515 	stw	fp,20(sp)
8110ac60:	df000504 	addi	fp,sp,20
8110ac64:	e13ffe15 	stw	r4,-8(fp)
8110ac68:	2805883a 	mov	r2,r5
8110ac6c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110ac70:	e03ffb15 	stw	zero,-20(fp)
	bool bValidCh = FALSE;
8110ac74:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
8110ac78:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
8110ac7c:	e0bffe17 	ldw	r2,-8(fp)
8110ac80:	10006526 	beq	r2,zero,8110ae18 <bSpwcInitCh+0x1cc>

		switch (ucCommCh) {
8110ac84:	e0bfff03 	ldbu	r2,-4(fp)
8110ac88:	10c00228 	cmpgeui	r3,r2,8
8110ac8c:	1800461e 	bne	r3,zero,8110ada8 <bSpwcInitCh+0x15c>
8110ac90:	100690ba 	slli	r3,r2,2
8110ac94:	00a04474 	movhi	r2,33041
8110ac98:	10ab2a04 	addi	r2,r2,-21336
8110ac9c:	1885883a 	add	r2,r3,r2
8110aca0:	10800017 	ldw	r2,0(r2)
8110aca4:	1000683a 	jmp	r2
8110aca8:	8110acc8 	cmpgei	r4,r16,17075
8110acac:	8110ace4 	muli	r4,r16,17075
8110acb0:	8110ad00 	call	88110ad0 <__reset+0x20f0ad0>
8110acb4:	8110ad1c 	xori	r4,r16,17076
8110acb8:	8110ad38 	rdprs	r4,r16,17076
8110acbc:	8110ad54 	ori	r4,r16,17077
8110acc0:	8110ad70 	cmpltui	r4,r16,17077
8110acc4:	8110ad8c 	andi	r4,r16,17078
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110acc8:	e0fffe17 	ldw	r3,-8(fp)
8110accc:	00a04834 	movhi	r2,33056
8110acd0:	108b0004 	addi	r2,r2,11264
8110acd4:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110acd8:	00800044 	movi	r2,1
8110acdc:	e0bffc15 	stw	r2,-16(fp)
			break;
8110ace0:	00003306 	br	8110adb0 <bSpwcInitCh+0x164>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8110ace4:	e0fffe17 	ldw	r3,-8(fp)
8110ace8:	00a04834 	movhi	r2,33056
8110acec:	108a0004 	addi	r2,r2,10240
8110acf0:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110acf4:	00800044 	movi	r2,1
8110acf8:	e0bffc15 	stw	r2,-16(fp)
			break;
8110acfc:	00002c06 	br	8110adb0 <bSpwcInitCh+0x164>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110ad00:	e0fffe17 	ldw	r3,-8(fp)
8110ad04:	00a04834 	movhi	r2,33056
8110ad08:	108b0004 	addi	r2,r2,11264
8110ad0c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110ad10:	00800044 	movi	r2,1
8110ad14:	e0bffc15 	stw	r2,-16(fp)
			break;
8110ad18:	00002506 	br	8110adb0 <bSpwcInitCh+0x164>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110ad1c:	e0fffe17 	ldw	r3,-8(fp)
8110ad20:	00a04834 	movhi	r2,33056
8110ad24:	108a0004 	addi	r2,r2,10240
8110ad28:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110ad2c:	00800044 	movi	r2,1
8110ad30:	e0bffc15 	stw	r2,-16(fp)
			break;
8110ad34:	00001e06 	br	8110adb0 <bSpwcInitCh+0x164>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110ad38:	e0fffe17 	ldw	r3,-8(fp)
8110ad3c:	00a04834 	movhi	r2,33056
8110ad40:	108b0004 	addi	r2,r2,11264
8110ad44:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110ad48:	00800044 	movi	r2,1
8110ad4c:	e0bffc15 	stw	r2,-16(fp)
			break;
8110ad50:	00001706 	br	8110adb0 <bSpwcInitCh+0x164>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8110ad54:	e0fffe17 	ldw	r3,-8(fp)
8110ad58:	00a04834 	movhi	r2,33056
8110ad5c:	108a0004 	addi	r2,r2,10240
8110ad60:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110ad64:	00800044 	movi	r2,1
8110ad68:	e0bffc15 	stw	r2,-16(fp)
			break;
8110ad6c:	00001006 	br	8110adb0 <bSpwcInitCh+0x164>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110ad70:	e0fffe17 	ldw	r3,-8(fp)
8110ad74:	00a04834 	movhi	r2,33056
8110ad78:	108b0004 	addi	r2,r2,11264
8110ad7c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110ad80:	00800044 	movi	r2,1
8110ad84:	e0bffc15 	stw	r2,-16(fp)
			break;
8110ad88:	00000906 	br	8110adb0 <bSpwcInitCh+0x164>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110ad8c:	e0fffe17 	ldw	r3,-8(fp)
8110ad90:	00a04834 	movhi	r2,33056
8110ad94:	108a0004 	addi	r2,r2,10240
8110ad98:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8110ad9c:	00800044 	movi	r2,1
8110ada0:	e0bffc15 	stw	r2,-16(fp)
			break;
8110ada4:	00000206 	br	8110adb0 <bSpwcInitCh+0x164>
		default:
			bValidCh = FALSE;
8110ada8:	e03ffc15 	stw	zero,-16(fp)
			break;
8110adac:	0001883a 	nop
		}

		if (bValidCh) {
8110adb0:	e0bffc17 	ldw	r2,-16(fp)
8110adb4:	10001826 	beq	r2,zero,8110ae18 <bSpwcInitCh+0x1cc>
			if (!bSpwcGetLink(pxSpwcCh)) {
8110adb8:	e13ffe17 	ldw	r4,-8(fp)
8110adbc:	110a8880 	call	8110a888 <bSpwcGetLink>
8110adc0:	1000021e 	bne	r2,zero,8110adcc <bSpwcInitCh+0x180>
				bInitFail = TRUE;
8110adc4:	00800044 	movi	r2,1
8110adc8:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
8110adcc:	e13ffe17 	ldw	r4,-8(fp)
8110add0:	110a96c0 	call	8110a96c <bSpwcGetLinkError>
8110add4:	1000021e 	bne	r2,zero,8110ade0 <bSpwcInitCh+0x194>
				bInitFail = TRUE;
8110add8:	00800044 	movi	r2,1
8110addc:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
8110ade0:	e13ffe17 	ldw	r4,-8(fp)
8110ade4:	110aa600 	call	8110aa60 <bSpwcGetLinkStatus>
8110ade8:	1000021e 	bne	r2,zero,8110adf4 <bSpwcInitCh+0x1a8>
				bInitFail = TRUE;
8110adec:	00800044 	movi	r2,1
8110adf0:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
8110adf4:	e13ffe17 	ldw	r4,-8(fp)
8110adf8:	110ab300 	call	8110ab30 <bSpwcGetTimecode>
8110adfc:	1000021e 	bne	r2,zero,8110ae08 <bSpwcInitCh+0x1bc>
				bInitFail = TRUE;
8110ae00:	00800044 	movi	r2,1
8110ae04:	e0bffd15 	stw	r2,-12(fp)
			}

			if (!bInitFail) {
8110ae08:	e0bffd17 	ldw	r2,-12(fp)
8110ae0c:	1000021e 	bne	r2,zero,8110ae18 <bSpwcInitCh+0x1cc>
				bStatus = TRUE;
8110ae10:	00800044 	movi	r2,1
8110ae14:	e0bffb15 	stw	r2,-20(fp)
			}
		}
	}
	return bStatus;
8110ae18:	e0bffb17 	ldw	r2,-20(fp)
}
8110ae1c:	e037883a 	mov	sp,fp
8110ae20:	dfc00117 	ldw	ra,4(sp)
8110ae24:	df000017 	ldw	fp,0(sp)
8110ae28:	dec00204 	addi	sp,sp,8
8110ae2c:	f800283a 	ret

8110ae30 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110ae30:	defffc04 	addi	sp,sp,-16
8110ae34:	de00012e 	bgeu	sp,et,8110ae3c <vSpwcWriteReg+0xc>
8110ae38:	003b68fa 	trap	3
8110ae3c:	df000315 	stw	fp,12(sp)
8110ae40:	df000304 	addi	fp,sp,12
8110ae44:	e13ffd15 	stw	r4,-12(fp)
8110ae48:	e17ffe15 	stw	r5,-8(fp)
8110ae4c:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110ae50:	e0bffe17 	ldw	r2,-8(fp)
8110ae54:	1085883a 	add	r2,r2,r2
8110ae58:	1085883a 	add	r2,r2,r2
8110ae5c:	1007883a 	mov	r3,r2
8110ae60:	e0bffd17 	ldw	r2,-12(fp)
8110ae64:	10c5883a 	add	r2,r2,r3
8110ae68:	e0ffff17 	ldw	r3,-4(fp)
8110ae6c:	10c00015 	stw	r3,0(r2)
}
8110ae70:	0001883a 	nop
8110ae74:	e037883a 	mov	sp,fp
8110ae78:	df000017 	ldw	fp,0(sp)
8110ae7c:	dec00104 	addi	sp,sp,4
8110ae80:	f800283a 	ret

8110ae84 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110ae84:	defffc04 	addi	sp,sp,-16
8110ae88:	de00012e 	bgeu	sp,et,8110ae90 <uliSpwcReadReg+0xc>
8110ae8c:	003b68fa 	trap	3
8110ae90:	df000315 	stw	fp,12(sp)
8110ae94:	df000304 	addi	fp,sp,12
8110ae98:	e13ffe15 	stw	r4,-8(fp)
8110ae9c:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110aea0:	e0bfff17 	ldw	r2,-4(fp)
8110aea4:	1085883a 	add	r2,r2,r2
8110aea8:	1085883a 	add	r2,r2,r2
8110aeac:	1007883a 	mov	r3,r2
8110aeb0:	e0bffe17 	ldw	r2,-8(fp)
8110aeb4:	10c5883a 	add	r2,r2,r3
8110aeb8:	10800017 	ldw	r2,0(r2)
8110aebc:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110aec0:	e0bffd17 	ldw	r2,-12(fp)
}
8110aec4:	e037883a 	mov	sp,fp
8110aec8:	df000017 	ldw	fp,0(sp)
8110aecc:	dec00104 	addi	sp,sp,4
8110aed0:	f800283a 	ret

8110aed4 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110aed4:	defffe04 	addi	sp,sp,-8
8110aed8:	de00012e 	bgeu	sp,et,8110aee0 <bEnableIsoDrivers+0xc>
8110aedc:	003b68fa 	trap	3
8110aee0:	dfc00115 	stw	ra,4(sp)
8110aee4:	df000015 	stw	fp,0(sp)
8110aee8:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
8110aeec:	01400204 	movi	r5,8
8110aef0:	01000044 	movi	r4,1
8110aef4:	110b0840 	call	8110b084 <bCtrlIoLvdsDrive>
  return  TRUE;
8110aef8:	00800044 	movi	r2,1
}
8110aefc:	e037883a 	mov	sp,fp
8110af00:	dfc00117 	ldw	ra,4(sp)
8110af04:	df000017 	ldw	fp,0(sp)
8110af08:	dec00204 	addi	sp,sp,8
8110af0c:	f800283a 	ret

8110af10 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
8110af10:	defffe04 	addi	sp,sp,-8
8110af14:	de00012e 	bgeu	sp,et,8110af1c <bDisableIsoDrivers+0xc>
8110af18:	003b68fa 	trap	3
8110af1c:	dfc00115 	stw	ra,4(sp)
8110af20:	df000015 	stw	fp,0(sp)
8110af24:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
8110af28:	01400204 	movi	r5,8
8110af2c:	0009883a 	mov	r4,zero
8110af30:	110b0840 	call	8110b084 <bCtrlIoLvdsDrive>
  return  TRUE;
8110af34:	00800044 	movi	r2,1
}
8110af38:	e037883a 	mov	sp,fp
8110af3c:	dfc00117 	ldw	ra,4(sp)
8110af40:	df000017 	ldw	fp,0(sp)
8110af44:	dec00204 	addi	sp,sp,8
8110af48:	f800283a 	ret

8110af4c <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
8110af4c:	defffe04 	addi	sp,sp,-8
8110af50:	de00012e 	bgeu	sp,et,8110af58 <bEnableLvdsBoard+0xc>
8110af54:	003b68fa 	trap	3
8110af58:	dfc00115 	stw	ra,4(sp)
8110af5c:	df000015 	stw	fp,0(sp)
8110af60:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110af64:	01400104 	movi	r5,4
8110af68:	01000044 	movi	r4,1
8110af6c:	110b0840 	call	8110b084 <bCtrlIoLvdsDrive>
  return  TRUE;
8110af70:	00800044 	movi	r2,1
}
8110af74:	e037883a 	mov	sp,fp
8110af78:	dfc00117 	ldw	ra,4(sp)
8110af7c:	df000017 	ldw	fp,0(sp)
8110af80:	dec00204 	addi	sp,sp,8
8110af84:	f800283a 	ret

8110af88 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8110af88:	defffe04 	addi	sp,sp,-8
8110af8c:	de00012e 	bgeu	sp,et,8110af94 <bDisableLvdsBoard+0xc>
8110af90:	003b68fa 	trap	3
8110af94:	dfc00115 	stw	ra,4(sp)
8110af98:	df000015 	stw	fp,0(sp)
8110af9c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
8110afa0:	01400104 	movi	r5,4
8110afa4:	0009883a 	mov	r4,zero
8110afa8:	110b0840 	call	8110b084 <bCtrlIoLvdsDrive>
  return  TRUE;
8110afac:	00800044 	movi	r2,1
}
8110afb0:	e037883a 	mov	sp,fp
8110afb4:	dfc00117 	ldw	ra,4(sp)
8110afb8:	df000017 	ldw	fp,0(sp)
8110afbc:	dec00204 	addi	sp,sp,8
8110afc0:	f800283a 	ret

8110afc4 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110afc4:	defffd04 	addi	sp,sp,-12
8110afc8:	de00012e 	bgeu	sp,et,8110afd0 <bSetPreEmphasys+0xc>
8110afcc:	003b68fa 	trap	3
8110afd0:	dfc00215 	stw	ra,8(sp)
8110afd4:	df000115 	stw	fp,4(sp)
8110afd8:	df000104 	addi	fp,sp,4
8110afdc:	2005883a 	mov	r2,r4
8110afe0:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8110afe4:	e0bfff03 	ldbu	r2,-4(fp)
8110afe8:	10c00060 	cmpeqi	r3,r2,1
8110afec:	18000d1e 	bne	r3,zero,8110b024 <bSetPreEmphasys+0x60>
8110aff0:	10c00088 	cmpgei	r3,r2,2
8110aff4:	1800021e 	bne	r3,zero,8110b000 <bSetPreEmphasys+0x3c>
8110aff8:	10000626 	beq	r2,zero,8110b014 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110affc:	00001b06 	br	8110b06c <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
8110b000:	10c000a0 	cmpeqi	r3,r2,2
8110b004:	18000e1e 	bne	r3,zero,8110b040 <bSetPreEmphasys+0x7c>
8110b008:	108000e0 	cmpeqi	r2,r2,3
8110b00c:	1000131e 	bne	r2,zero,8110b05c <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110b010:	00001606 	br	8110b06c <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110b014:	014000c4 	movi	r5,3
8110b018:	0009883a 	mov	r4,zero
8110b01c:	110b0840 	call	8110b084 <bCtrlIoLvdsDrive>
      break;
8110b020:	00001206 	br	8110b06c <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110b024:	01400084 	movi	r5,2
8110b028:	0009883a 	mov	r4,zero
8110b02c:	110b0840 	call	8110b084 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
8110b030:	01400044 	movi	r5,1
8110b034:	01000044 	movi	r4,1
8110b038:	110b0840 	call	8110b084 <bCtrlIoLvdsDrive>
      break;
8110b03c:	00000b06 	br	8110b06c <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
8110b040:	01400044 	movi	r5,1
8110b044:	0009883a 	mov	r4,zero
8110b048:	110b0840 	call	8110b084 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
8110b04c:	01400084 	movi	r5,2
8110b050:	01000044 	movi	r4,1
8110b054:	110b0840 	call	8110b084 <bCtrlIoLvdsDrive>
      break;
8110b058:	00000406 	br	8110b06c <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110b05c:	014000c4 	movi	r5,3
8110b060:	01000044 	movi	r4,1
8110b064:	110b0840 	call	8110b084 <bCtrlIoLvdsDrive>
      break;
8110b068:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
8110b06c:	00800044 	movi	r2,1
}
8110b070:	e037883a 	mov	sp,fp
8110b074:	dfc00117 	ldw	ra,4(sp)
8110b078:	df000017 	ldw	fp,0(sp)
8110b07c:	dec00204 	addi	sp,sp,8
8110b080:	f800283a 	ret

8110b084 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8110b084:	defffd04 	addi	sp,sp,-12
8110b088:	de00012e 	bgeu	sp,et,8110b090 <bCtrlIoLvdsDrive+0xc>
8110b08c:	003b68fa 	trap	3
8110b090:	df000215 	stw	fp,8(sp)
8110b094:	df000204 	addi	fp,sp,8
8110b098:	e13ffe15 	stw	r4,-8(fp)
8110b09c:	2805883a 	mov	r2,r5
8110b0a0:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8110b0a4:	e0bffe17 	ldw	r2,-8(fp)
8110b0a8:	1000071e 	bne	r2,zero,8110b0c8 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
8110b0ac:	e0bfff03 	ldbu	r2,-4(fp)
8110b0b0:	0084303a 	nor	r2,zero,r2
8110b0b4:	1007883a 	mov	r3,r2
8110b0b8:	d0a00103 	ldbu	r2,-32764(gp)
8110b0bc:	1884703a 	and	r2,r3,r2
8110b0c0:	d0a00105 	stb	r2,-32764(gp)
8110b0c4:	00000406 	br	8110b0d8 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
8110b0c8:	d0e00103 	ldbu	r3,-32764(gp)
8110b0cc:	e0bfff03 	ldbu	r2,-4(fp)
8110b0d0:	1884b03a 	or	r2,r3,r2
8110b0d4:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
8110b0d8:	d0a00103 	ldbu	r2,-32764(gp)
8110b0dc:	10c03fcc 	andi	r3,r2,255
8110b0e0:	00a00034 	movhi	r2,32768
8110b0e4:	10822804 	addi	r2,r2,2208
8110b0e8:	10c00035 	stwio	r3,0(r2)
  return TRUE;
8110b0ec:	00800044 	movi	r2,1
}
8110b0f0:	e037883a 	mov	sp,fp
8110b0f4:	df000017 	ldw	fp,0(sp)
8110b0f8:	dec00104 	addi	sp,sp,4
8110b0fc:	f800283a 	ret

8110b100 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
8110b100:	defffa04 	addi	sp,sp,-24
8110b104:	de00012e 	bgeu	sp,et,8110b10c <I2C_TestAdress+0xc>
8110b108:	003b68fa 	trap	3
8110b10c:	dfc00515 	stw	ra,20(sp)
8110b110:	df000415 	stw	fp,16(sp)
8110b114:	df000404 	addi	fp,sp,16
8110b118:	e13ffd15 	stw	r4,-12(fp)
8110b11c:	e17ffe15 	stw	r5,-8(fp)
8110b120:	3005883a 	mov	r2,r6
8110b124:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110b128:	00800044 	movi	r2,1
8110b12c:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110b130:	e17ffe17 	ldw	r5,-8(fp)
8110b134:	e13ffd17 	ldw	r4,-12(fp)
8110b138:	110b4d00 	call	8110b4d0 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110b13c:	e0bfff03 	ldbu	r2,-4(fp)
8110b140:	10803fcc 	andi	r2,r2,255
8110b144:	100d883a 	mov	r6,r2
8110b148:	e17ffe17 	ldw	r5,-8(fp)
8110b14c:	e13ffd17 	ldw	r4,-12(fp)
8110b150:	110b5e40 	call	8110b5e4 <i2c_write>
8110b154:	1000011e 	bne	r2,zero,8110b15c <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
8110b158:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110b15c:	e17ffe17 	ldw	r5,-8(fp)
8110b160:	e13ffd17 	ldw	r4,-12(fp)
8110b164:	110b5640 	call	8110b564 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110b168:	0106d604 	movi	r4,7000
8110b16c:	11399580 	call	81139958 <usleep>
    
    return bSuccess;
8110b170:	e0bffc17 	ldw	r2,-16(fp)

}
8110b174:	e037883a 	mov	sp,fp
8110b178:	dfc00117 	ldw	ra,4(sp)
8110b17c:	df000017 	ldw	fp,0(sp)
8110b180:	dec00204 	addi	sp,sp,8
8110b184:	f800283a 	ret

8110b188 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
8110b188:	defff804 	addi	sp,sp,-32
8110b18c:	de00012e 	bgeu	sp,et,8110b194 <I2C_Write+0xc>
8110b190:	003b68fa 	trap	3
8110b194:	dfc00715 	stw	ra,28(sp)
8110b198:	df000615 	stw	fp,24(sp)
8110b19c:	df000604 	addi	fp,sp,24
8110b1a0:	e13ffb15 	stw	r4,-20(fp)
8110b1a4:	e17ffc15 	stw	r5,-16(fp)
8110b1a8:	3009883a 	mov	r4,r6
8110b1ac:	3807883a 	mov	r3,r7
8110b1b0:	e0800217 	ldw	r2,8(fp)
8110b1b4:	e13ffd05 	stb	r4,-12(fp)
8110b1b8:	e0fffe05 	stb	r3,-8(fp)
8110b1bc:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110b1c0:	00800044 	movi	r2,1
8110b1c4:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110b1c8:	e17ffc17 	ldw	r5,-16(fp)
8110b1cc:	e13ffb17 	ldw	r4,-20(fp)
8110b1d0:	110b4d00 	call	8110b4d0 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110b1d4:	e0bffd03 	ldbu	r2,-12(fp)
8110b1d8:	10803fcc 	andi	r2,r2,255
8110b1dc:	100d883a 	mov	r6,r2
8110b1e0:	e17ffc17 	ldw	r5,-16(fp)
8110b1e4:	e13ffb17 	ldw	r4,-20(fp)
8110b1e8:	110b5e40 	call	8110b5e4 <i2c_write>
8110b1ec:	1000011e 	bne	r2,zero,8110b1f4 <I2C_Write+0x6c>
        bSuccess = FALSE;
8110b1f0:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110b1f4:	e0bffa17 	ldw	r2,-24(fp)
8110b1f8:	10000726 	beq	r2,zero,8110b218 <I2C_Write+0x90>
8110b1fc:	e0bffe03 	ldbu	r2,-8(fp)
8110b200:	100d883a 	mov	r6,r2
8110b204:	e17ffc17 	ldw	r5,-16(fp)
8110b208:	e13ffb17 	ldw	r4,-20(fp)
8110b20c:	110b5e40 	call	8110b5e4 <i2c_write>
8110b210:	1000011e 	bne	r2,zero,8110b218 <I2C_Write+0x90>
        bSuccess = FALSE;
8110b214:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
8110b218:	e0bffa17 	ldw	r2,-24(fp)
8110b21c:	10000726 	beq	r2,zero,8110b23c <I2C_Write+0xb4>
8110b220:	e0bfff03 	ldbu	r2,-4(fp)
8110b224:	100d883a 	mov	r6,r2
8110b228:	e17ffc17 	ldw	r5,-16(fp)
8110b22c:	e13ffb17 	ldw	r4,-20(fp)
8110b230:	110b5e40 	call	8110b5e4 <i2c_write>
8110b234:	1000011e 	bne	r2,zero,8110b23c <I2C_Write+0xb4>
        bSuccess = FALSE;
8110b238:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110b23c:	e17ffc17 	ldw	r5,-16(fp)
8110b240:	e13ffb17 	ldw	r4,-20(fp)
8110b244:	110b5640 	call	8110b564 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110b248:	0106d604 	movi	r4,7000
8110b24c:	11399580 	call	81139958 <usleep>
    
    return bSuccess;
8110b250:	e0bffa17 	ldw	r2,-24(fp)

}
8110b254:	e037883a 	mov	sp,fp
8110b258:	dfc00117 	ldw	ra,4(sp)
8110b25c:	df000017 	ldw	fp,0(sp)
8110b260:	dec00204 	addi	sp,sp,8
8110b264:	f800283a 	ret

8110b268 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
8110b268:	defff904 	addi	sp,sp,-28
8110b26c:	de00012e 	bgeu	sp,et,8110b274 <I2C_Read+0xc>
8110b270:	003b68fa 	trap	3
8110b274:	dfc00615 	stw	ra,24(sp)
8110b278:	df000515 	stw	fp,20(sp)
8110b27c:	df000504 	addi	fp,sp,20
8110b280:	e13ffc15 	stw	r4,-16(fp)
8110b284:	e17ffd15 	stw	r5,-12(fp)
8110b288:	3007883a 	mov	r3,r6
8110b28c:	3805883a 	mov	r2,r7
8110b290:	e0fffe05 	stb	r3,-8(fp)
8110b294:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110b298:	00800044 	movi	r2,1
8110b29c:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110b2a0:	e17ffd17 	ldw	r5,-12(fp)
8110b2a4:	e13ffc17 	ldw	r4,-16(fp)
8110b2a8:	110b4d00 	call	8110b4d0 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110b2ac:	e0bffe03 	ldbu	r2,-8(fp)
8110b2b0:	10803fcc 	andi	r2,r2,255
8110b2b4:	100d883a 	mov	r6,r2
8110b2b8:	e17ffd17 	ldw	r5,-12(fp)
8110b2bc:	e13ffc17 	ldw	r4,-16(fp)
8110b2c0:	110b5e40 	call	8110b5e4 <i2c_write>
8110b2c4:	1000011e 	bne	r2,zero,8110b2cc <I2C_Read+0x64>
        bSuccess = FALSE;
8110b2c8:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110b2cc:	e0bffb17 	ldw	r2,-20(fp)
8110b2d0:	10000726 	beq	r2,zero,8110b2f0 <I2C_Read+0x88>
8110b2d4:	e0bfff03 	ldbu	r2,-4(fp)
8110b2d8:	100d883a 	mov	r6,r2
8110b2dc:	e17ffd17 	ldw	r5,-12(fp)
8110b2e0:	e13ffc17 	ldw	r4,-16(fp)
8110b2e4:	110b5e40 	call	8110b5e4 <i2c_write>
8110b2e8:	1000011e 	bne	r2,zero,8110b2f0 <I2C_Read+0x88>
        bSuccess = FALSE;
8110b2ec:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
8110b2f0:	e17ffd17 	ldw	r5,-12(fp)
8110b2f4:	e13ffc17 	ldw	r4,-16(fp)
8110b2f8:	110b4d00 	call	8110b4d0 <i2c_start>
    DeviceAddr |= 1; // Read
8110b2fc:	e0bffe03 	ldbu	r2,-8(fp)
8110b300:	10800054 	ori	r2,r2,1
8110b304:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110b308:	e0bffb17 	ldw	r2,-20(fp)
8110b30c:	10000826 	beq	r2,zero,8110b330 <I2C_Read+0xc8>
8110b310:	e0bffe03 	ldbu	r2,-8(fp)
8110b314:	10803fcc 	andi	r2,r2,255
8110b318:	100d883a 	mov	r6,r2
8110b31c:	e17ffd17 	ldw	r5,-12(fp)
8110b320:	e13ffc17 	ldw	r4,-16(fp)
8110b324:	110b5e40 	call	8110b5e4 <i2c_write>
8110b328:	1000011e 	bne	r2,zero,8110b330 <I2C_Read+0xc8>
        bSuccess = FALSE;
8110b32c:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110b330:	e0bffb17 	ldw	r2,-20(fp)
8110b334:	10000526 	beq	r2,zero,8110b34c <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
8110b338:	000f883a 	mov	r7,zero
8110b33c:	e1800217 	ldw	r6,8(fp)
8110b340:	e17ffd17 	ldw	r5,-12(fp)
8110b344:	e13ffc17 	ldw	r4,-16(fp)
8110b348:	110b71c0 	call	8110b71c <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
8110b34c:	e17ffd17 	ldw	r5,-12(fp)
8110b350:	e13ffc17 	ldw	r4,-16(fp)
8110b354:	110b5640 	call	8110b564 <i2c_stop>
    
    return bSuccess;
8110b358:	e0bffb17 	ldw	r2,-20(fp)
}
8110b35c:	e037883a 	mov	sp,fp
8110b360:	dfc00117 	ldw	ra,4(sp)
8110b364:	df000017 	ldw	fp,0(sp)
8110b368:	dec00204 	addi	sp,sp,8
8110b36c:	f800283a 	ret

8110b370 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
8110b370:	defff604 	addi	sp,sp,-40
8110b374:	de00012e 	bgeu	sp,et,8110b37c <I2C_MultipleRead+0xc>
8110b378:	003b68fa 	trap	3
8110b37c:	dfc00915 	stw	ra,36(sp)
8110b380:	df000815 	stw	fp,32(sp)
8110b384:	df000804 	addi	fp,sp,32
8110b388:	e13ffb15 	stw	r4,-20(fp)
8110b38c:	e17ffc15 	stw	r5,-16(fp)
8110b390:	3007883a 	mov	r3,r6
8110b394:	e1fffe15 	stw	r7,-8(fp)
8110b398:	e0800217 	ldw	r2,8(fp)
8110b39c:	e0fffd05 	stb	r3,-12(fp)
8110b3a0:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
8110b3a4:	00800044 	movi	r2,1
8110b3a8:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
8110b3ac:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110b3b0:	e17ffc17 	ldw	r5,-16(fp)
8110b3b4:	e13ffb17 	ldw	r4,-20(fp)
8110b3b8:	110b4d00 	call	8110b4d0 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110b3bc:	e0bffd03 	ldbu	r2,-12(fp)
8110b3c0:	10803fcc 	andi	r2,r2,255
8110b3c4:	100d883a 	mov	r6,r2
8110b3c8:	e17ffc17 	ldw	r5,-16(fp)
8110b3cc:	e13ffb17 	ldw	r4,-20(fp)
8110b3d0:	110b5e40 	call	8110b5e4 <i2c_write>
8110b3d4:	1000011e 	bne	r2,zero,8110b3dc <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
8110b3d8:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110b3dc:	e0bff917 	ldw	r2,-28(fp)
8110b3e0:	10000726 	beq	r2,zero,8110b400 <I2C_MultipleRead+0x90>
8110b3e4:	e0bffa03 	ldbu	r2,-24(fp)
8110b3e8:	100d883a 	mov	r6,r2
8110b3ec:	e17ffc17 	ldw	r5,-16(fp)
8110b3f0:	e13ffb17 	ldw	r4,-20(fp)
8110b3f4:	110b5e40 	call	8110b5e4 <i2c_write>
8110b3f8:	1000011e 	bne	r2,zero,8110b400 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
8110b3fc:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
8110b400:	e0bff917 	ldw	r2,-28(fp)
8110b404:	10000326 	beq	r2,zero,8110b414 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
8110b408:	e17ffc17 	ldw	r5,-16(fp)
8110b40c:	e13ffb17 	ldw	r4,-20(fp)
8110b410:	110b4d00 	call	8110b4d0 <i2c_start>
    DeviceAddr |= 1; // Read
8110b414:	e0bffd03 	ldbu	r2,-12(fp)
8110b418:	10800054 	ori	r2,r2,1
8110b41c:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110b420:	e0bff917 	ldw	r2,-28(fp)
8110b424:	10000826 	beq	r2,zero,8110b448 <I2C_MultipleRead+0xd8>
8110b428:	e0bffd03 	ldbu	r2,-12(fp)
8110b42c:	10803fcc 	andi	r2,r2,255
8110b430:	100d883a 	mov	r6,r2
8110b434:	e17ffc17 	ldw	r5,-16(fp)
8110b438:	e13ffb17 	ldw	r4,-20(fp)
8110b43c:	110b5e40 	call	8110b5e4 <i2c_write>
8110b440:	1000011e 	bne	r2,zero,8110b448 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
8110b444:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110b448:	e0bff917 	ldw	r2,-28(fp)
8110b44c:	10001726 	beq	r2,zero,8110b4ac <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
8110b450:	e03ff815 	stw	zero,-32(fp)
8110b454:	00001006 	br	8110b498 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
8110b458:	e0bff817 	ldw	r2,-32(fp)
8110b45c:	e0fffe17 	ldw	r3,-8(fp)
8110b460:	1889883a 	add	r4,r3,r2
8110b464:	e0bfff0b 	ldhu	r2,-4(fp)
8110b468:	10ffffc4 	addi	r3,r2,-1
8110b46c:	e0bff817 	ldw	r2,-32(fp)
8110b470:	1884c03a 	cmpne	r2,r3,r2
8110b474:	10803fcc 	andi	r2,r2,255
8110b478:	100f883a 	mov	r7,r2
8110b47c:	200d883a 	mov	r6,r4
8110b480:	e17ffc17 	ldw	r5,-16(fp)
8110b484:	e13ffb17 	ldw	r4,-20(fp)
8110b488:	110b71c0 	call	8110b71c <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
8110b48c:	e0bff817 	ldw	r2,-32(fp)
8110b490:	10800044 	addi	r2,r2,1
8110b494:	e0bff815 	stw	r2,-32(fp)
8110b498:	e0bfff0b 	ldhu	r2,-4(fp)
8110b49c:	e0fff817 	ldw	r3,-32(fp)
8110b4a0:	1880020e 	bge	r3,r2,8110b4ac <I2C_MultipleRead+0x13c>
8110b4a4:	e0bff917 	ldw	r2,-28(fp)
8110b4a8:	103feb1e 	bne	r2,zero,8110b458 <__reset+0xfb0eb458>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
8110b4ac:	e17ffc17 	ldw	r5,-16(fp)
8110b4b0:	e13ffb17 	ldw	r4,-20(fp)
8110b4b4:	110b5640 	call	8110b564 <i2c_stop>
    
    return bSuccess;    
8110b4b8:	e0bff917 	ldw	r2,-28(fp)
    
}
8110b4bc:	e037883a 	mov	sp,fp
8110b4c0:	dfc00117 	ldw	ra,4(sp)
8110b4c4:	df000017 	ldw	fp,0(sp)
8110b4c8:	dec00204 	addi	sp,sp,8
8110b4cc:	f800283a 	ret

8110b4d0 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
8110b4d0:	defffc04 	addi	sp,sp,-16
8110b4d4:	de00012e 	bgeu	sp,et,8110b4dc <i2c_start+0xc>
8110b4d8:	003b68fa 	trap	3
8110b4dc:	dfc00315 	stw	ra,12(sp)
8110b4e0:	df000215 	stw	fp,8(sp)
8110b4e4:	df000204 	addi	fp,sp,8
8110b4e8:	e13ffe15 	stw	r4,-8(fp)
8110b4ec:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
8110b4f0:	e0bfff17 	ldw	r2,-4(fp)
8110b4f4:	10800104 	addi	r2,r2,4
8110b4f8:	1007883a 	mov	r3,r2
8110b4fc:	00800044 	movi	r2,1
8110b500:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
8110b504:	e0bfff17 	ldw	r2,-4(fp)
8110b508:	00c00044 	movi	r3,1
8110b50c:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
8110b510:	e0bffe17 	ldw	r2,-8(fp)
8110b514:	00c00044 	movi	r3,1
8110b518:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110b51c:	01000044 	movi	r4,1
8110b520:	11399580 	call	81139958 <usleep>
     
    SDA_LOW(data_base); // data low
8110b524:	e0bfff17 	ldw	r2,-4(fp)
8110b528:	0007883a 	mov	r3,zero
8110b52c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
8110b530:	01000044 	movi	r4,1
8110b534:	11399580 	call	81139958 <usleep>
    SCL_LOW(clk_base); // clock low
8110b538:	e0bffe17 	ldw	r2,-8(fp)
8110b53c:	0007883a 	mov	r3,zero
8110b540:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110b544:	01000044 	movi	r4,1
8110b548:	11399580 	call	81139958 <usleep>
}
8110b54c:	0001883a 	nop
8110b550:	e037883a 	mov	sp,fp
8110b554:	dfc00117 	ldw	ra,4(sp)
8110b558:	df000017 	ldw	fp,0(sp)
8110b55c:	dec00204 	addi	sp,sp,8
8110b560:	f800283a 	ret

8110b564 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
8110b564:	defffc04 	addi	sp,sp,-16
8110b568:	de00012e 	bgeu	sp,et,8110b570 <i2c_stop+0xc>
8110b56c:	003b68fa 	trap	3
8110b570:	dfc00315 	stw	ra,12(sp)
8110b574:	df000215 	stw	fp,8(sp)
8110b578:	df000204 	addi	fp,sp,8
8110b57c:	e13ffe15 	stw	r4,-8(fp)
8110b580:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
8110b584:	e0bfff17 	ldw	r2,-4(fp)
8110b588:	10800104 	addi	r2,r2,4
8110b58c:	1007883a 	mov	r3,r2
8110b590:	00800044 	movi	r2,1
8110b594:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
8110b598:	e0bfff17 	ldw	r2,-4(fp)
8110b59c:	0007883a 	mov	r3,zero
8110b5a0:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
8110b5a4:	e0bffe17 	ldw	r2,-8(fp)
8110b5a8:	00c00044 	movi	r3,1
8110b5ac:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
8110b5b0:	01000044 	movi	r4,1
8110b5b4:	11399580 	call	81139958 <usleep>
    SDA_HIGH(data_base); // data high
8110b5b8:	e0bfff17 	ldw	r2,-4(fp)
8110b5bc:	00c00044 	movi	r3,1
8110b5c0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
8110b5c4:	01000044 	movi	r4,1
8110b5c8:	11399580 	call	81139958 <usleep>
    

    
}
8110b5cc:	0001883a 	nop
8110b5d0:	e037883a 	mov	sp,fp
8110b5d4:	dfc00117 	ldw	ra,4(sp)
8110b5d8:	df000017 	ldw	fp,0(sp)
8110b5dc:	dec00204 	addi	sp,sp,8
8110b5e0:	f800283a 	ret

8110b5e4 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
8110b5e4:	defff804 	addi	sp,sp,-32
8110b5e8:	de00012e 	bgeu	sp,et,8110b5f0 <i2c_write+0xc>
8110b5ec:	003b68fa 	trap	3
8110b5f0:	dfc00715 	stw	ra,28(sp)
8110b5f4:	df000615 	stw	fp,24(sp)
8110b5f8:	df000604 	addi	fp,sp,24
8110b5fc:	e13ffd15 	stw	r4,-12(fp)
8110b600:	e17ffe15 	stw	r5,-8(fp)
8110b604:	3005883a 	mov	r2,r6
8110b608:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
8110b60c:	00bfe004 	movi	r2,-128
8110b610:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
8110b614:	e0bffe17 	ldw	r2,-8(fp)
8110b618:	10800104 	addi	r2,r2,4
8110b61c:	1007883a 	mov	r3,r2
8110b620:	00800044 	movi	r2,1
8110b624:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
8110b628:	e03ffb15 	stw	zero,-20(fp)
8110b62c:	00001f06 	br	8110b6ac <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
8110b630:	e0bffd17 	ldw	r2,-12(fp)
8110b634:	0007883a 	mov	r3,zero
8110b638:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
8110b63c:	e0ffff03 	ldbu	r3,-4(fp)
8110b640:	e0bffa03 	ldbu	r2,-24(fp)
8110b644:	1884703a 	and	r2,r3,r2
8110b648:	10803fcc 	andi	r2,r2,255
8110b64c:	10000426 	beq	r2,zero,8110b660 <i2c_write+0x7c>
            SDA_HIGH(data_base);
8110b650:	e0bffe17 	ldw	r2,-8(fp)
8110b654:	00c00044 	movi	r3,1
8110b658:	10c00035 	stwio	r3,0(r2)
8110b65c:	00000306 	br	8110b66c <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8110b660:	e0bffe17 	ldw	r2,-8(fp)
8110b664:	0007883a 	mov	r3,zero
8110b668:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
8110b66c:	e0bffa03 	ldbu	r2,-24(fp)
8110b670:	1004d07a 	srli	r2,r2,1
8110b674:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
8110b678:	e0bffd17 	ldw	r2,-12(fp)
8110b67c:	00c00044 	movi	r3,1
8110b680:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b684:	01000044 	movi	r4,1
8110b688:	11399580 	call	81139958 <usleep>
        SCL_LOW(clk_base);
8110b68c:	e0bffd17 	ldw	r2,-12(fp)
8110b690:	0007883a 	mov	r3,zero
8110b694:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b698:	01000044 	movi	r4,1
8110b69c:	11399580 	call	81139958 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110b6a0:	e0bffb17 	ldw	r2,-20(fp)
8110b6a4:	10800044 	addi	r2,r2,1
8110b6a8:	e0bffb15 	stw	r2,-20(fp)
8110b6ac:	e0bffb17 	ldw	r2,-20(fp)
8110b6b0:	10800210 	cmplti	r2,r2,8
8110b6b4:	103fde1e 	bne	r2,zero,8110b630 <__reset+0xfb0eb630>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8110b6b8:	e0bffe17 	ldw	r2,-8(fp)
8110b6bc:	10800104 	addi	r2,r2,4
8110b6c0:	0007883a 	mov	r3,zero
8110b6c4:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8110b6c8:	e0bffd17 	ldw	r2,-12(fp)
8110b6cc:	00c00044 	movi	r3,1
8110b6d0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8110b6d4:	01000044 	movi	r4,1
8110b6d8:	11399580 	call	81139958 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8110b6dc:	e0bffe17 	ldw	r2,-8(fp)
8110b6e0:	10800037 	ldwio	r2,0(r2)
8110b6e4:	1005003a 	cmpeq	r2,r2,zero
8110b6e8:	10803fcc 	andi	r2,r2,255
8110b6ec:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110b6f0:	e0bffd17 	ldw	r2,-12(fp)
8110b6f4:	0007883a 	mov	r3,zero
8110b6f8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b6fc:	01000044 	movi	r4,1
8110b700:	11399580 	call	81139958 <usleep>
    return bAck;
8110b704:	e0bffc17 	ldw	r2,-16(fp)
}    
8110b708:	e037883a 	mov	sp,fp
8110b70c:	dfc00117 	ldw	ra,4(sp)
8110b710:	df000017 	ldw	fp,0(sp)
8110b714:	dec00204 	addi	sp,sp,8
8110b718:	f800283a 	ret

8110b71c <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8110b71c:	defff804 	addi	sp,sp,-32
8110b720:	de00012e 	bgeu	sp,et,8110b728 <i2c_read+0xc>
8110b724:	003b68fa 	trap	3
8110b728:	dfc00715 	stw	ra,28(sp)
8110b72c:	df000615 	stw	fp,24(sp)
8110b730:	df000604 	addi	fp,sp,24
8110b734:	e13ffc15 	stw	r4,-16(fp)
8110b738:	e17ffd15 	stw	r5,-12(fp)
8110b73c:	e1bffe15 	stw	r6,-8(fp)
8110b740:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110b744:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8110b748:	e0bffd17 	ldw	r2,-12(fp)
8110b74c:	10800104 	addi	r2,r2,4
8110b750:	0007883a 	mov	r3,zero
8110b754:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8110b758:	e0bffc17 	ldw	r2,-16(fp)
8110b75c:	0007883a 	mov	r3,zero
8110b760:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b764:	01000044 	movi	r4,1
8110b768:	11399580 	call	81139958 <usleep>

    for(i=0;i<8;i++){
8110b76c:	e03ffb15 	stw	zero,-20(fp)
8110b770:	00001606 	br	8110b7cc <i2c_read+0xb0>
        Data <<= 1;
8110b774:	e0bffa03 	ldbu	r2,-24(fp)
8110b778:	1085883a 	add	r2,r2,r2
8110b77c:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110b780:	e0bffc17 	ldw	r2,-16(fp)
8110b784:	00c00044 	movi	r3,1
8110b788:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b78c:	01000044 	movi	r4,1
8110b790:	11399580 	call	81139958 <usleep>
        if (SDA_READ(data_base))  // read data   
8110b794:	e0bffd17 	ldw	r2,-12(fp)
8110b798:	10800037 	ldwio	r2,0(r2)
8110b79c:	10000326 	beq	r2,zero,8110b7ac <i2c_read+0x90>
            Data |= 0x01;
8110b7a0:	e0bffa03 	ldbu	r2,-24(fp)
8110b7a4:	10800054 	ori	r2,r2,1
8110b7a8:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8110b7ac:	e0bffc17 	ldw	r2,-16(fp)
8110b7b0:	0007883a 	mov	r3,zero
8110b7b4:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b7b8:	01000044 	movi	r4,1
8110b7bc:	11399580 	call	81139958 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110b7c0:	e0bffb17 	ldw	r2,-20(fp)
8110b7c4:	10800044 	addi	r2,r2,1
8110b7c8:	e0bffb15 	stw	r2,-20(fp)
8110b7cc:	e0bffb17 	ldw	r2,-20(fp)
8110b7d0:	10800210 	cmplti	r2,r2,8
8110b7d4:	103fe71e 	bne	r2,zero,8110b774 <__reset+0xfb0eb774>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110b7d8:	e0bffc17 	ldw	r2,-16(fp)
8110b7dc:	0007883a 	mov	r3,zero
8110b7e0:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110b7e4:	e0bffd17 	ldw	r2,-12(fp)
8110b7e8:	10800104 	addi	r2,r2,4
8110b7ec:	1007883a 	mov	r3,r2
8110b7f0:	00800044 	movi	r2,1
8110b7f4:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110b7f8:	e0bfff17 	ldw	r2,-4(fp)
8110b7fc:	10000426 	beq	r2,zero,8110b810 <i2c_read+0xf4>
        SDA_LOW(data_base);
8110b800:	e0bffd17 	ldw	r2,-12(fp)
8110b804:	0007883a 	mov	r3,zero
8110b808:	10c00035 	stwio	r3,0(r2)
8110b80c:	00000306 	br	8110b81c <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8110b810:	e0bffd17 	ldw	r2,-12(fp)
8110b814:	00c00044 	movi	r3,1
8110b818:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8110b81c:	e0bffc17 	ldw	r2,-16(fp)
8110b820:	00c00044 	movi	r3,1
8110b824:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8110b828:	01000044 	movi	r4,1
8110b82c:	11399580 	call	81139958 <usleep>
    SCL_LOW(clk_base); // clock low
8110b830:	e0bffc17 	ldw	r2,-16(fp)
8110b834:	0007883a 	mov	r3,zero
8110b838:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b83c:	01000044 	movi	r4,1
8110b840:	11399580 	call	81139958 <usleep>
    SDA_LOW(data_base);  // data low
8110b844:	e0bffd17 	ldw	r2,-12(fp)
8110b848:	0007883a 	mov	r3,zero
8110b84c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8110b850:	01000044 	movi	r4,1
8110b854:	11399580 	call	81139958 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8110b858:	e0bffe17 	ldw	r2,-8(fp)
8110b85c:	e0fffa03 	ldbu	r3,-24(fp)
8110b860:	10c00005 	stb	r3,0(r2)
}
8110b864:	0001883a 	nop
8110b868:	e037883a 	mov	sp,fp
8110b86c:	dfc00117 	ldw	ra,4(sp)
8110b870:	df000017 	ldw	fp,0(sp)
8110b874:	dec00204 	addi	sp,sp,8
8110b878:	f800283a 	ret

8110b87c <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8110b87c:	defffd04 	addi	sp,sp,-12
8110b880:	de00012e 	bgeu	sp,et,8110b888 <bSetBoardLeds+0xc>
8110b884:	003b68fa 	trap	3
8110b888:	df000215 	stw	fp,8(sp)
8110b88c:	df000204 	addi	fp,sp,8
8110b890:	e13ffe15 	stw	r4,-8(fp)
8110b894:	2805883a 	mov	r2,r5
8110b898:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110b89c:	e0bffe17 	ldw	r2,-8(fp)
8110b8a0:	10800058 	cmpnei	r2,r2,1
8110b8a4:	1000071e 	bne	r2,zero,8110b8c4 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110b8a8:	e0bfff03 	ldbu	r2,-4(fp)
8110b8ac:	0084303a 	nor	r2,zero,r2
8110b8b0:	1007883a 	mov	r3,r2
8110b8b4:	d0a05003 	ldbu	r2,-32448(gp)
8110b8b8:	1884703a 	and	r2,r3,r2
8110b8bc:	d0a05005 	stb	r2,-32448(gp)
8110b8c0:	00000406 	br	8110b8d4 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110b8c4:	d0e05003 	ldbu	r3,-32448(gp)
8110b8c8:	e0bfff03 	ldbu	r2,-4(fp)
8110b8cc:	1884b03a 	or	r2,r3,r2
8110b8d0:	d0a05005 	stb	r2,-32448(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110b8d4:	d0a05003 	ldbu	r2,-32448(gp)
8110b8d8:	10c03fcc 	andi	r3,r2,255
8110b8dc:	00a00034 	movhi	r2,32768
8110b8e0:	10827404 	addi	r2,r2,2512
8110b8e4:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b8e8:	00800044 	movi	r2,1
}
8110b8ec:	e037883a 	mov	sp,fp
8110b8f0:	df000017 	ldw	fp,0(sp)
8110b8f4:	dec00104 	addi	sp,sp,4
8110b8f8:	f800283a 	ret

8110b8fc <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110b8fc:	defffd04 	addi	sp,sp,-12
8110b900:	de00012e 	bgeu	sp,et,8110b908 <bSetPainelLeds+0xc>
8110b904:	003b68fa 	trap	3
8110b908:	df000215 	stw	fp,8(sp)
8110b90c:	df000204 	addi	fp,sp,8
8110b910:	e13ffe15 	stw	r4,-8(fp)
8110b914:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110b918:	e0bffe17 	ldw	r2,-8(fp)
8110b91c:	10800058 	cmpnei	r2,r2,1
8110b920:	1000051e 	bne	r2,zero,8110b938 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110b924:	d0e00217 	ldw	r3,-32760(gp)
8110b928:	e0bfff17 	ldw	r2,-4(fp)
8110b92c:	1884b03a 	or	r2,r3,r2
8110b930:	d0a00215 	stw	r2,-32760(gp)
8110b934:	00000506 	br	8110b94c <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110b938:	e0bfff17 	ldw	r2,-4(fp)
8110b93c:	0086303a 	nor	r3,zero,r2
8110b940:	d0a00217 	ldw	r2,-32760(gp)
8110b944:	1884703a 	and	r2,r3,r2
8110b948:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110b94c:	d0a00217 	ldw	r2,-32760(gp)
8110b950:	1007883a 	mov	r3,r2
8110b954:	00a00034 	movhi	r2,32768
8110b958:	10824004 	addi	r2,r2,2304
8110b95c:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b960:	00800044 	movi	r2,1
}
8110b964:	e037883a 	mov	sp,fp
8110b968:	df000017 	ldw	fp,0(sp)
8110b96c:	dec00104 	addi	sp,sp,4
8110b970:	f800283a 	ret

8110b974 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110b974:	defffc04 	addi	sp,sp,-16
8110b978:	de00012e 	bgeu	sp,et,8110b980 <msgdma_write_extended_descriptor+0xc>
8110b97c:	003b68fa 	trap	3
8110b980:	df000315 	stw	fp,12(sp)
8110b984:	df000304 	addi	fp,sp,12
8110b988:	e13ffd15 	stw	r4,-12(fp)
8110b98c:	e17ffe15 	stw	r5,-8(fp)
8110b990:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110b994:	e0bffd17 	ldw	r2,-12(fp)
8110b998:	10800037 	ldwio	r2,0(r2)
8110b99c:	1080010c 	andi	r2,r2,4
8110b9a0:	10000226 	beq	r2,zero,8110b9ac <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110b9a4:	00bff904 	movi	r2,-28
8110b9a8:	00003d06 	br	8110baa0 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110b9ac:	e0bfff17 	ldw	r2,-4(fp)
8110b9b0:	10800017 	ldw	r2,0(r2)
8110b9b4:	1007883a 	mov	r3,r2
8110b9b8:	e0bffe17 	ldw	r2,-8(fp)
8110b9bc:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110b9c0:	e0bffe17 	ldw	r2,-8(fp)
8110b9c4:	10800104 	addi	r2,r2,4
8110b9c8:	e0ffff17 	ldw	r3,-4(fp)
8110b9cc:	18c00117 	ldw	r3,4(r3)
8110b9d0:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110b9d4:	e0bffe17 	ldw	r2,-8(fp)
8110b9d8:	10800204 	addi	r2,r2,8
8110b9dc:	e0ffff17 	ldw	r3,-4(fp)
8110b9e0:	18c00217 	ldw	r3,8(r3)
8110b9e4:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110b9e8:	e0bffe17 	ldw	r2,-8(fp)
8110b9ec:	10800304 	addi	r2,r2,12
8110b9f0:	e0ffff17 	ldw	r3,-4(fp)
8110b9f4:	18c0030b 	ldhu	r3,12(r3)
8110b9f8:	18ffffcc 	andi	r3,r3,65535
8110b9fc:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110ba00:	e0bffe17 	ldw	r2,-8(fp)
8110ba04:	10800384 	addi	r2,r2,14
8110ba08:	e0ffff17 	ldw	r3,-4(fp)
8110ba0c:	18c00383 	ldbu	r3,14(r3)
8110ba10:	18c03fcc 	andi	r3,r3,255
8110ba14:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110ba18:	e0bffe17 	ldw	r2,-8(fp)
8110ba1c:	108003c4 	addi	r2,r2,15
8110ba20:	e0ffff17 	ldw	r3,-4(fp)
8110ba24:	18c003c3 	ldbu	r3,15(r3)
8110ba28:	18c03fcc 	andi	r3,r3,255
8110ba2c:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110ba30:	e0bffe17 	ldw	r2,-8(fp)
8110ba34:	10800404 	addi	r2,r2,16
8110ba38:	e0ffff17 	ldw	r3,-4(fp)
8110ba3c:	18c0040b 	ldhu	r3,16(r3)
8110ba40:	18ffffcc 	andi	r3,r3,65535
8110ba44:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110ba48:	e0bffe17 	ldw	r2,-8(fp)
8110ba4c:	10800484 	addi	r2,r2,18
8110ba50:	e0ffff17 	ldw	r3,-4(fp)
8110ba54:	18c0048b 	ldhu	r3,18(r3)
8110ba58:	18ffffcc 	andi	r3,r3,65535
8110ba5c:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110ba60:	e0bffe17 	ldw	r2,-8(fp)
8110ba64:	10800504 	addi	r2,r2,20
8110ba68:	e0ffff17 	ldw	r3,-4(fp)
8110ba6c:	18c00517 	ldw	r3,20(r3)
8110ba70:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110ba74:	e0bffe17 	ldw	r2,-8(fp)
8110ba78:	10800604 	addi	r2,r2,24
8110ba7c:	e0ffff17 	ldw	r3,-4(fp)
8110ba80:	18c00617 	ldw	r3,24(r3)
8110ba84:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110ba88:	e0bffe17 	ldw	r2,-8(fp)
8110ba8c:	10800704 	addi	r2,r2,28
8110ba90:	e0ffff17 	ldw	r3,-4(fp)
8110ba94:	18c00717 	ldw	r3,28(r3)
8110ba98:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110ba9c:	0005883a 	mov	r2,zero
}
8110baa0:	e037883a 	mov	sp,fp
8110baa4:	df000017 	ldw	fp,0(sp)
8110baa8:	dec00104 	addi	sp,sp,4
8110baac:	f800283a 	ret

8110bab0 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110bab0:	defff604 	addi	sp,sp,-40
8110bab4:	de00012e 	bgeu	sp,et,8110babc <msgdma_construct_extended_descriptor+0xc>
8110bab8:	003b68fa 	trap	3
8110babc:	df000915 	stw	fp,36(sp)
8110bac0:	df000904 	addi	fp,sp,36
8110bac4:	e13ff715 	stw	r4,-36(fp)
8110bac8:	e17ff815 	stw	r5,-32(fp)
8110bacc:	e1bff915 	stw	r6,-28(fp)
8110bad0:	e1fffa15 	stw	r7,-24(fp)
8110bad4:	e1800517 	ldw	r6,20(fp)
8110bad8:	e1400617 	ldw	r5,24(fp)
8110badc:	e1000717 	ldw	r4,28(fp)
8110bae0:	e0c00817 	ldw	r3,32(fp)
8110bae4:	e0800917 	ldw	r2,36(fp)
8110bae8:	e1bffb0d 	sth	r6,-20(fp)
8110baec:	e17ffc05 	stb	r5,-16(fp)
8110baf0:	e13ffd05 	stb	r4,-12(fp)
8110baf4:	e0fffe0d 	sth	r3,-8(fp)
8110baf8:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110bafc:	e0bff717 	ldw	r2,-36(fp)
8110bb00:	10c01217 	ldw	r3,72(r2)
8110bb04:	e0800117 	ldw	r2,4(fp)
8110bb08:	18801936 	bltu	r3,r2,8110bb70 <msgdma_construct_extended_descriptor+0xc0>
8110bb0c:	e13ff717 	ldw	r4,-36(fp)
8110bb10:	20801317 	ldw	r2,76(r4)
8110bb14:	20c01417 	ldw	r3,80(r4)
8110bb18:	e13ffe0b 	ldhu	r4,-8(fp)
8110bb1c:	213fffcc 	andi	r4,r4,65535
8110bb20:	2015883a 	mov	r10,r4
8110bb24:	0017883a 	mov	r11,zero
8110bb28:	1ac01136 	bltu	r3,r11,8110bb70 <msgdma_construct_extended_descriptor+0xc0>
8110bb2c:	58c0011e 	bne	r11,r3,8110bb34 <msgdma_construct_extended_descriptor+0x84>
8110bb30:	12800f36 	bltu	r2,r10,8110bb70 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110bb34:	e13ff717 	ldw	r4,-36(fp)
8110bb38:	20801317 	ldw	r2,76(r4)
8110bb3c:	20c01417 	ldw	r3,80(r4)
8110bb40:	e13fff0b 	ldhu	r4,-4(fp)
8110bb44:	213fffcc 	andi	r4,r4,65535
8110bb48:	2011883a 	mov	r8,r4
8110bb4c:	0013883a 	mov	r9,zero
8110bb50:	1a400736 	bltu	r3,r9,8110bb70 <msgdma_construct_extended_descriptor+0xc0>
8110bb54:	48c0011e 	bne	r9,r3,8110bb5c <msgdma_construct_extended_descriptor+0xac>
8110bb58:	12000536 	bltu	r2,r8,8110bb70 <msgdma_construct_extended_descriptor+0xc0>
8110bb5c:	e0bff717 	ldw	r2,-36(fp)
8110bb60:	10801703 	ldbu	r2,92(r2)
8110bb64:	10803fcc 	andi	r2,r2,255
8110bb68:	10800060 	cmpeqi	r2,r2,1
8110bb6c:	1000021e 	bne	r2,zero,8110bb78 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110bb70:	00bffa84 	movi	r2,-22
8110bb74:	00002306 	br	8110bc04 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110bb78:	e0bff817 	ldw	r2,-32(fp)
8110bb7c:	e0fff917 	ldw	r3,-28(fp)
8110bb80:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110bb84:	e0bff817 	ldw	r2,-32(fp)
8110bb88:	e0fffa17 	ldw	r3,-24(fp)
8110bb8c:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110bb90:	e0bff817 	ldw	r2,-32(fp)
8110bb94:	e0c00117 	ldw	r3,4(fp)
8110bb98:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110bb9c:	e0bff817 	ldw	r2,-32(fp)
8110bba0:	e0fffb0b 	ldhu	r3,-20(fp)
8110bba4:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110bba8:	e0bff817 	ldw	r2,-32(fp)
8110bbac:	e0fffc03 	ldbu	r3,-16(fp)
8110bbb0:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110bbb4:	e0bff817 	ldw	r2,-32(fp)
8110bbb8:	e0fffd03 	ldbu	r3,-12(fp)
8110bbbc:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110bbc0:	e0bff817 	ldw	r2,-32(fp)
8110bbc4:	e0fffe0b 	ldhu	r3,-8(fp)
8110bbc8:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110bbcc:	e0bff817 	ldw	r2,-32(fp)
8110bbd0:	e0ffff0b 	ldhu	r3,-4(fp)
8110bbd4:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110bbd8:	e0bff817 	ldw	r2,-32(fp)
8110bbdc:	e0c00317 	ldw	r3,12(fp)
8110bbe0:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110bbe4:	e0bff817 	ldw	r2,-32(fp)
8110bbe8:	e0c00417 	ldw	r3,16(fp)
8110bbec:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110bbf0:	e0800217 	ldw	r2,8(fp)
8110bbf4:	10e00034 	orhi	r3,r2,32768
8110bbf8:	e0bff817 	ldw	r2,-32(fp)
8110bbfc:	10c00715 	stw	r3,28(r2)

	return 0;
8110bc00:	0005883a 	mov	r2,zero

}
8110bc04:	e037883a 	mov	sp,fp
8110bc08:	df000017 	ldw	fp,0(sp)
8110bc0c:	dec00104 	addi	sp,sp,4
8110bc10:	f800283a 	ret

8110bc14 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110bc14:	deffee04 	addi	sp,sp,-72
8110bc18:	de00012e 	bgeu	sp,et,8110bc20 <msgdma_descriptor_async_transfer+0xc>
8110bc1c:	003b68fa 	trap	3
8110bc20:	dfc01115 	stw	ra,68(sp)
8110bc24:	df001015 	stw	fp,64(sp)
8110bc28:	df001004 	addi	fp,sp,64
8110bc2c:	e13ffd15 	stw	r4,-12(fp)
8110bc30:	e17ffe15 	stw	r5,-8(fp)
8110bc34:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110bc38:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110bc3c:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110bc40:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110bc44:	e0bffd17 	ldw	r2,-12(fp)
8110bc48:	10800317 	ldw	r2,12(r2)
8110bc4c:	10800204 	addi	r2,r2,8
8110bc50:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110bc54:	10bfffcc 	andi	r2,r2,65535
8110bc58:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110bc5c:	e0bffd17 	ldw	r2,-12(fp)
8110bc60:	10800317 	ldw	r2,12(r2)
8110bc64:	10800204 	addi	r2,r2,8
8110bc68:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110bc6c:	1004d43a 	srli	r2,r2,16
8110bc70:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110bc74:	e0bffd17 	ldw	r2,-12(fp)
8110bc78:	10800917 	ldw	r2,36(r2)
8110bc7c:	e0fff417 	ldw	r3,-48(fp)
8110bc80:	1880042e 	bgeu	r3,r2,8110bc94 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110bc84:	e0bffd17 	ldw	r2,-12(fp)
8110bc88:	10800917 	ldw	r2,36(r2)
8110bc8c:	e0fff317 	ldw	r3,-52(fp)
8110bc90:	18800236 	bltu	r3,r2,8110bc9c <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110bc94:	00bff904 	movi	r2,-28
8110bc98:	0000ab06 	br	8110bf48 <msgdma_descriptor_async_transfer+0x334>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110bc9c:	e0bffd17 	ldw	r2,-12(fp)
8110bca0:	10801817 	ldw	r2,96(r2)
8110bca4:	e0bff615 	stw	r2,-40(fp)
8110bca8:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110bcac:	e0bffc0b 	ldhu	r2,-16(fp)
8110bcb0:	e0fffc84 	addi	r3,fp,-14
8110bcb4:	180d883a 	mov	r6,r3
8110bcb8:	100b883a 	mov	r5,r2
8110bcbc:	e13ff617 	ldw	r4,-40(fp)
8110bcc0:	114075c0 	call	8114075c <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110bcc4:	00800804 	movi	r2,32
8110bcc8:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110bccc:	0005303a 	rdctl	r2,status
8110bcd0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110bcd4:	e0fff717 	ldw	r3,-36(fp)
8110bcd8:	00bfff84 	movi	r2,-2
8110bcdc:	1884703a 	and	r2,r3,r2
8110bce0:	1001703a 	wrctl	status,r2
  
  return context;
8110bce4:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110bce8:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110bcec:	e0bffd17 	ldw	r2,-12(fp)
8110bcf0:	10800317 	ldw	r2,12(r2)
8110bcf4:	10800104 	addi	r2,r2,4
8110bcf8:	e0fff117 	ldw	r3,-60(fp)
8110bcfc:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110bd00:	e0bffd17 	ldw	r2,-12(fp)
8110bd04:	10800317 	ldw	r2,12(r2)
8110bd08:	e0fffd17 	ldw	r3,-12(fp)
8110bd0c:	18c00317 	ldw	r3,12(r3)
8110bd10:	18c00037 	ldwio	r3,0(r3)
8110bd14:	10c00035 	stwio	r3,0(r2)
8110bd18:	e0bff217 	ldw	r2,-56(fp)
8110bd1c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bd20:	e0bffb17 	ldw	r2,-20(fp)
8110bd24:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110bd28:	e0bffe17 	ldw	r2,-8(fp)
8110bd2c:	10001626 	beq	r2,zero,8110bd88 <msgdma_descriptor_async_transfer+0x174>
8110bd30:	e0bfff17 	ldw	r2,-4(fp)
8110bd34:	1000141e 	bne	r2,zero,8110bd88 <msgdma_descriptor_async_transfer+0x174>
		counter = 0; /* reset counter */
8110bd38:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110bd3c:	00a045f4 	movhi	r2,33047
8110bd40:	10a25304 	addi	r2,r2,-30388
8110bd44:	10800a8b 	ldhu	r2,42(r2)
8110bd48:	10bfffcc 	andi	r2,r2,65535
8110bd4c:	10800228 	cmpgeui	r2,r2,8
8110bd50:	1000071e 	bne	r2,zero,8110bd70 <msgdma_descriptor_async_transfer+0x15c>
		debug(fp, "invalid dma descriptor option\n");
8110bd54:	d0a06217 	ldw	r2,-32376(gp)
8110bd58:	100f883a 	mov	r7,r2
8110bd5c:	01800784 	movi	r6,30
8110bd60:	01400044 	movi	r5,1
8110bd64:	01204574 	movhi	r4,33045
8110bd68:	21382d04 	addi	r4,r4,-8012
8110bd6c:	112393c0 	call	8112393c <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110bd70:	e0bffd17 	ldw	r2,-12(fp)
8110bd74:	10801817 	ldw	r2,96(r2)
8110bd78:	1009883a 	mov	r4,r2
8110bd7c:	1140ae40 	call	81140ae4 <OSSemPost>

		return -ETIME;
8110bd80:	00bff084 	movi	r2,-62
8110bd84:	00007006 	br	8110bf48 <msgdma_descriptor_async_transfer+0x334>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110bd88:	e0bffe17 	ldw	r2,-8(fp)
8110bd8c:	1000291e 	bne	r2,zero,8110be34 <msgdma_descriptor_async_transfer+0x220>
8110bd90:	e0bfff17 	ldw	r2,-4(fp)
8110bd94:	10002726 	beq	r2,zero,8110be34 <msgdma_descriptor_async_transfer+0x220>
		counter = 0; /* reset counter */
8110bd98:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110bd9c:	00001b06 	br	8110be0c <msgdma_descriptor_async_transfer+0x1f8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110bda0:	01000044 	movi	r4,1
8110bda4:	1137ee40 	call	81137ee4 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110bda8:	e0bff00b 	ldhu	r2,-64(fp)
8110bdac:	1084e230 	cmpltui	r2,r2,5000
8110bdb0:	1000131e 	bne	r2,zero,8110be00 <msgdma_descriptor_async_transfer+0x1ec>
			{
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110bdb4:	00a045f4 	movhi	r2,33047
8110bdb8:	10a25304 	addi	r2,r2,-30388
8110bdbc:	10800a8b 	ldhu	r2,42(r2)
8110bdc0:	10bfffcc 	andi	r2,r2,65535
8110bdc4:	10800228 	cmpgeui	r2,r2,8
8110bdc8:	1000071e 	bne	r2,zero,8110bde8 <msgdma_descriptor_async_transfer+0x1d4>
					debug(fp, "time out after 5 msec while waiting free FIFO buffer for storing extended descriptor\n");
8110bdcc:	d0a06217 	ldw	r2,-32376(gp)
8110bdd0:	100f883a 	mov	r7,r2
8110bdd4:	01801544 	movi	r6,85
8110bdd8:	01400044 	movi	r5,1
8110bddc:	01204574 	movhi	r4,33045
8110bde0:	21383504 	addi	r4,r4,-7980
8110bde4:	112393c0 	call	8112393c <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110bde8:	e0bffd17 	ldw	r2,-12(fp)
8110bdec:	10801817 	ldw	r2,96(r2)
8110bdf0:	1009883a 	mov	r4,r2
8110bdf4:	1140ae40 	call	81140ae4 <OSSemPost>

				return -ETIME;
8110bdf8:	00bff084 	movi	r2,-62
8110bdfc:	00005206 	br	8110bf48 <msgdma_descriptor_async_transfer+0x334>
			}
			counter++;
8110be00:	e0bff00b 	ldhu	r2,-64(fp)
8110be04:	10800044 	addi	r2,r2,1
8110be08:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110be0c:	e0bffd17 	ldw	r2,-12(fp)
8110be10:	10c00317 	ldw	r3,12(r2)
8110be14:	e0bffd17 	ldw	r2,-12(fp)
8110be18:	10800417 	ldw	r2,16(r2)
8110be1c:	e1bfff17 	ldw	r6,-4(fp)
8110be20:	100b883a 	mov	r5,r2
8110be24:	1809883a 	mov	r4,r3
8110be28:	110b9740 	call	8110b974 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110be2c:	103fdc1e 	bne	r2,zero,8110bda0 <__reset+0xfb0ebda0>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110be30:	00000606 	br	8110be4c <msgdma_descriptor_async_transfer+0x238>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110be34:	e0bffd17 	ldw	r2,-12(fp)
8110be38:	10801817 	ldw	r2,96(r2)
8110be3c:	1009883a 	mov	r4,r2
8110be40:	1140ae40 	call	81140ae4 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110be44:	00bfffc4 	movi	r2,-1
8110be48:	00003f06 	br	8110bf48 <msgdma_descriptor_async_transfer+0x334>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110be4c:	e0bffd17 	ldw	r2,-12(fp)
8110be50:	10800b17 	ldw	r2,44(r2)
8110be54:	10001c26 	beq	r2,zero,8110bec8 <msgdma_descriptor_async_transfer+0x2b4>

		control |= (dev->control |
8110be58:	e0bffd17 	ldw	r2,-12(fp)
8110be5c:	10c00d17 	ldw	r3,52(r2)
8110be60:	e0bff117 	ldw	r2,-60(fp)
8110be64:	1884b03a 	or	r2,r3,r2
8110be68:	10800514 	ori	r2,r2,20
8110be6c:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110be70:	e0fff117 	ldw	r3,-60(fp)
8110be74:	00bff7c4 	movi	r2,-33
8110be78:	1884703a 	and	r2,r3,r2
8110be7c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110be80:	0005303a 	rdctl	r2,status
8110be84:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110be88:	e0fff917 	ldw	r3,-28(fp)
8110be8c:	00bfff84 	movi	r2,-2
8110be90:	1884703a 	and	r2,r3,r2
8110be94:	1001703a 	wrctl	status,r2
  
  return context;
8110be98:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110be9c:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110bea0:	e0bffd17 	ldw	r2,-12(fp)
8110bea4:	10800317 	ldw	r2,12(r2)
8110bea8:	10800104 	addi	r2,r2,4
8110beac:	e0fff117 	ldw	r3,-60(fp)
8110beb0:	10c00035 	stwio	r3,0(r2)
8110beb4:	e0bff217 	ldw	r2,-56(fp)
8110beb8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bebc:	e0bff517 	ldw	r2,-44(fp)
8110bec0:	1001703a 	wrctl	status,r2
8110bec4:	00001b06 	br	8110bf34 <msgdma_descriptor_async_transfer+0x320>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110bec8:	e0bffd17 	ldw	r2,-12(fp)
8110becc:	10c00d17 	ldw	r3,52(r2)
8110bed0:	e0bff117 	ldw	r2,-60(fp)
8110bed4:	1884b03a 	or	r2,r3,r2
8110bed8:	10800114 	ori	r2,r2,4
8110bedc:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110bee0:	e0fff117 	ldw	r3,-60(fp)
8110bee4:	00bff3c4 	movi	r2,-49
8110bee8:	1884703a 	and	r2,r3,r2
8110beec:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110bef0:	0005303a 	rdctl	r2,status
8110bef4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110bef8:	e0fffa17 	ldw	r3,-24(fp)
8110befc:	00bfff84 	movi	r2,-2
8110bf00:	1884703a 	and	r2,r3,r2
8110bf04:	1001703a 	wrctl	status,r2
  
  return context;
8110bf08:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110bf0c:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110bf10:	e0bffd17 	ldw	r2,-12(fp)
8110bf14:	10800317 	ldw	r2,12(r2)
8110bf18:	10800104 	addi	r2,r2,4
8110bf1c:	e0fff117 	ldw	r3,-60(fp)
8110bf20:	10c00035 	stwio	r3,0(r2)
8110bf24:	e0bff217 	ldw	r2,-56(fp)
8110bf28:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bf2c:	e0bff817 	ldw	r2,-32(fp)
8110bf30:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110bf34:	e0bffd17 	ldw	r2,-12(fp)
8110bf38:	10801817 	ldw	r2,96(r2)
8110bf3c:	1009883a 	mov	r4,r2
8110bf40:	1140ae40 	call	81140ae4 <OSSemPost>

	return 0;
8110bf44:	0005883a 	mov	r2,zero
}
8110bf48:	e037883a 	mov	sp,fp
8110bf4c:	dfc00117 	ldw	ra,4(sp)
8110bf50:	df000017 	ldw	fp,0(sp)
8110bf54:	dec00204 	addi	sp,sp,8
8110bf58:	f800283a 	ret

8110bf5c <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110bf5c:	deffee04 	addi	sp,sp,-72
8110bf60:	de00012e 	bgeu	sp,et,8110bf68 <msgdma_descriptor_sync_transfer+0xc>
8110bf64:	003b68fa 	trap	3
8110bf68:	dfc01115 	stw	ra,68(sp)
8110bf6c:	df001015 	stw	fp,64(sp)
8110bf70:	df001004 	addi	fp,sp,64
8110bf74:	e13ffd15 	stw	r4,-12(fp)
8110bf78:	e17ffe15 	stw	r5,-8(fp)
8110bf7c:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110bf80:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110bf84:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110bf88:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110bf8c:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110bf90:	e0bffd17 	ldw	r2,-12(fp)
8110bf94:	10800317 	ldw	r2,12(r2)
8110bf98:	10800204 	addi	r2,r2,8
8110bf9c:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110bfa0:	10bfffcc 	andi	r2,r2,65535
8110bfa4:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110bfa8:	e0bffd17 	ldw	r2,-12(fp)
8110bfac:	10800317 	ldw	r2,12(r2)
8110bfb0:	10800204 	addi	r2,r2,8
8110bfb4:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110bfb8:	1004d43a 	srli	r2,r2,16
8110bfbc:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110bfc0:	00807804 	movi	r2,480
8110bfc4:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110bfc8:	00003006 	br	8110c08c <msgdma_descriptor_sync_transfer+0x130>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110bfcc:	01000044 	movi	r4,1
8110bfd0:	1137ee40 	call	81137ee4 <alt_busy_sleep>
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110bfd4:	00a045f4 	movhi	r2,33047
8110bfd8:	10a25304 	addi	r2,r2,-30388
8110bfdc:	10800a8b 	ldhu	r2,42(r2)
8110bfe0:	10bfffcc 	andi	r2,r2,65535
8110bfe4:	10800228 	cmpgeui	r2,r2,8
8110bfe8:	1000071e 	bne	r2,zero,8110c008 <msgdma_descriptor_sync_transfer+0xac>
		fprintf(fp,"\n-- DMA can't write in the descriptor \n ");
8110bfec:	d0a06217 	ldw	r2,-32376(gp)
8110bff0:	100f883a 	mov	r7,r2
8110bff4:	01800a04 	movi	r6,40
8110bff8:	01400044 	movi	r5,1
8110bffc:	01204574 	movhi	r4,33045
8110c000:	21384b04 	addi	r4,r4,-7892
8110c004:	112393c0 	call	8112393c <fwrite>
	}
#endif
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110c008:	e0bff10b 	ldhu	r2,-60(fp)
8110c00c:	1084e230 	cmpltui	r2,r2,5000
8110c010:	10000f1e 	bne	r2,zero,8110c050 <msgdma_descriptor_sync_transfer+0xf4>
		{
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110c014:	00a045f4 	movhi	r2,33047
8110c018:	10a25304 	addi	r2,r2,-30388
8110c01c:	10800a8b 	ldhu	r2,42(r2)
8110c020:	10bfffcc 	andi	r2,r2,65535
8110c024:	10800228 	cmpgeui	r2,r2,8
8110c028:	1000071e 	bne	r2,zero,8110c048 <msgdma_descriptor_sync_transfer+0xec>
		debug(fp, "time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
8110c02c:	d0a06217 	ldw	r2,-32376(gp)
8110c030:	100f883a 	mov	r7,r2
8110c034:	01801304 	movi	r6,76
8110c038:	01400044 	movi	r5,1
8110c03c:	01204574 	movhi	r4,33045
8110c040:	21385604 	addi	r4,r4,-7848
8110c044:	112393c0 	call	8112393c <fwrite>
	}
#endif
			return -ETIME;
8110c048:	00bff084 	movi	r2,-62
8110c04c:	0000e206 	br	8110c3d8 <msgdma_descriptor_sync_transfer+0x47c>
		}
		counter++;
8110c050:	e0bff10b 	ldhu	r2,-60(fp)
8110c054:	10800044 	addi	r2,r2,1
8110c058:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110c05c:	e0bffd17 	ldw	r2,-12(fp)
8110c060:	10800317 	ldw	r2,12(r2)
8110c064:	10800204 	addi	r2,r2,8
8110c068:	10800037 	ldwio	r2,0(r2)
	}
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110c06c:	10bfffcc 	andi	r2,r2,65535
8110c070:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110c074:	e0bffd17 	ldw	r2,-12(fp)
8110c078:	10800317 	ldw	r2,12(r2)
8110c07c:	10800204 	addi	r2,r2,8
8110c080:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110c084:	1004d43a 	srli	r2,r2,16
8110c088:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110c08c:	e0bffd17 	ldw	r2,-12(fp)
8110c090:	10800917 	ldw	r2,36(r2)
8110c094:	e0fff317 	ldw	r3,-52(fp)
8110c098:	18bfcc2e 	bgeu	r3,r2,8110bfcc <__reset+0xfb0ebfcc>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110c09c:	e0bffd17 	ldw	r2,-12(fp)
8110c0a0:	10800917 	ldw	r2,36(r2)
8110c0a4:	e0fff217 	ldw	r3,-56(fp)
8110c0a8:	18bfc82e 	bgeu	r3,r2,8110bfcc <__reset+0xfb0ebfcc>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110c0ac:	e0bffd17 	ldw	r2,-12(fp)
8110c0b0:	10801817 	ldw	r2,96(r2)
8110c0b4:	e0bff815 	stw	r2,-32(fp)
8110c0b8:	e03ffc0d 	sth	zero,-16(fp)
8110c0bc:	e0bffc0b 	ldhu	r2,-16(fp)
8110c0c0:	e0fffc84 	addi	r3,fp,-14
8110c0c4:	180d883a 	mov	r6,r3
8110c0c8:	100b883a 	mov	r5,r2
8110c0cc:	e13ff817 	ldw	r4,-32(fp)
8110c0d0:	114075c0 	call	8114075c <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110c0d4:	0005303a 	rdctl	r2,status
8110c0d8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110c0dc:	e0fffb17 	ldw	r3,-20(fp)
8110c0e0:	00bfff84 	movi	r2,-2
8110c0e4:	1884703a 	and	r2,r3,r2
8110c0e8:	1001703a 	wrctl	status,r2
  
  return context;
8110c0ec:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110c0f0:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110c0f4:	e0bffd17 	ldw	r2,-12(fp)
8110c0f8:	10800317 	ldw	r2,12(r2)
8110c0fc:	10800104 	addi	r2,r2,4
8110c100:	00c00804 	movi	r3,32
8110c104:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110c108:	e0bffd17 	ldw	r2,-12(fp)
8110c10c:	10800317 	ldw	r2,12(r2)
8110c110:	e0fffd17 	ldw	r3,-12(fp)
8110c114:	18c00317 	ldw	r3,12(r3)
8110c118:	18c00037 	ldwio	r3,0(r3)
8110c11c:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110c120:	e0bffe17 	ldw	r2,-8(fp)
8110c124:	10001626 	beq	r2,zero,8110c180 <msgdma_descriptor_sync_transfer+0x224>
8110c128:	e0bfff17 	ldw	r2,-4(fp)
8110c12c:	1000141e 	bne	r2,zero,8110c180 <msgdma_descriptor_sync_transfer+0x224>
		counter = 0; /* reset counter */
8110c130:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110c134:	00a045f4 	movhi	r2,33047
8110c138:	10a25304 	addi	r2,r2,-30388
8110c13c:	10800a8b 	ldhu	r2,42(r2)
8110c140:	10bfffcc 	andi	r2,r2,65535
8110c144:	10800228 	cmpgeui	r2,r2,8
8110c148:	1000071e 	bne	r2,zero,8110c168 <msgdma_descriptor_sync_transfer+0x20c>
			debug(fp, "invalid dma descriptor option\n");
8110c14c:	d0a06217 	ldw	r2,-32376(gp)
8110c150:	100f883a 	mov	r7,r2
8110c154:	01800784 	movi	r6,30
8110c158:	01400044 	movi	r5,1
8110c15c:	01204574 	movhi	r4,33045
8110c160:	21382d04 	addi	r4,r4,-8012
8110c164:	112393c0 	call	8112393c <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110c168:	e0bffd17 	ldw	r2,-12(fp)
8110c16c:	10801817 	ldw	r2,96(r2)
8110c170:	1009883a 	mov	r4,r2
8110c174:	1140ae40 	call	81140ae4 <OSSemPost>

		return -ETIME;
8110c178:	00bff084 	movi	r2,-62
8110c17c:	00009606 	br	8110c3d8 <msgdma_descriptor_sync_transfer+0x47c>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110c180:	e0bffe17 	ldw	r2,-8(fp)
8110c184:	1000291e 	bne	r2,zero,8110c22c <msgdma_descriptor_sync_transfer+0x2d0>
8110c188:	e0bfff17 	ldw	r2,-4(fp)
8110c18c:	10002726 	beq	r2,zero,8110c22c <msgdma_descriptor_sync_transfer+0x2d0>
		counter = 0; /* reset counter */
8110c190:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110c194:	00001b06 	br	8110c204 <msgdma_descriptor_sync_transfer+0x2a8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110c198:	01000044 	movi	r4,1
8110c19c:	1137ee40 	call	81137ee4 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110c1a0:	e0bff10b 	ldhu	r2,-60(fp)
8110c1a4:	1084e230 	cmpltui	r2,r2,5000
8110c1a8:	1000131e 	bne	r2,zero,8110c1f8 <msgdma_descriptor_sync_transfer+0x29c>
			{
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110c1ac:	00a045f4 	movhi	r2,33047
8110c1b0:	10a25304 	addi	r2,r2,-30388
8110c1b4:	10800a8b 	ldhu	r2,42(r2)
8110c1b8:	10bfffcc 	andi	r2,r2,65535
8110c1bc:	10800228 	cmpgeui	r2,r2,8
8110c1c0:	1000071e 	bne	r2,zero,8110c1e0 <msgdma_descriptor_sync_transfer+0x284>
					debug(fp, "time out after 5 msec while writing extended descriptor to FIFO\n");
8110c1c4:	d0a06217 	ldw	r2,-32376(gp)
8110c1c8:	100f883a 	mov	r7,r2
8110c1cc:	01801004 	movi	r6,64
8110c1d0:	01400044 	movi	r5,1
8110c1d4:	01204574 	movhi	r4,33045
8110c1d8:	21386a04 	addi	r4,r4,-7768
8110c1dc:	112393c0 	call	8112393c <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110c1e0:	e0bffd17 	ldw	r2,-12(fp)
8110c1e4:	10801817 	ldw	r2,96(r2)
8110c1e8:	1009883a 	mov	r4,r2
8110c1ec:	1140ae40 	call	81140ae4 <OSSemPost>

				return -ETIME;
8110c1f0:	00bff084 	movi	r2,-62
8110c1f4:	00007806 	br	8110c3d8 <msgdma_descriptor_sync_transfer+0x47c>
			}
			counter++;
8110c1f8:	e0bff10b 	ldhu	r2,-60(fp)
8110c1fc:	10800044 	addi	r2,r2,1
8110c200:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110c204:	e0bffd17 	ldw	r2,-12(fp)
8110c208:	10c00317 	ldw	r3,12(r2)
8110c20c:	e0bffd17 	ldw	r2,-12(fp)
8110c210:	10800417 	ldw	r2,16(r2)
8110c214:	e1bfff17 	ldw	r6,-4(fp)
8110c218:	100b883a 	mov	r5,r2
8110c21c:	1809883a 	mov	r4,r3
8110c220:	110b9740 	call	8110b974 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110c224:	103fdc1e 	bne	r2,zero,8110c198 <__reset+0xfb0ec198>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110c228:	00000606 	br	8110c244 <msgdma_descriptor_sync_transfer+0x2e8>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110c22c:	e0bffd17 	ldw	r2,-12(fp)
8110c230:	10801817 	ldw	r2,96(r2)
8110c234:	1009883a 	mov	r4,r2
8110c238:	1140ae40 	call	81140ae4 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110c23c:	00bfffc4 	movi	r2,-1
8110c240:	00006506 	br	8110c3d8 <msgdma_descriptor_sync_transfer+0x47c>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110c244:	e0bffd17 	ldw	r2,-12(fp)
8110c248:	10800317 	ldw	r2,12(r2)
8110c24c:	10800104 	addi	r2,r2,4
8110c250:	e0fffd17 	ldw	r3,-12(fp)
8110c254:	19000d17 	ldw	r4,52(r3)
8110c258:	00fff2c4 	movi	r3,-53
8110c25c:	20c6703a 	and	r3,r4,r3
8110c260:	18c00114 	ori	r3,r3,4
8110c264:	10c00035 	stwio	r3,0(r2)
8110c268:	e0bff517 	ldw	r2,-44(fp)
8110c26c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110c270:	e0bff717 	ldw	r2,-36(fp)
8110c274:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110c278:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110c27c:	e0bffd17 	ldw	r2,-12(fp)
8110c280:	10800317 	ldw	r2,12(r2)
8110c284:	10800037 	ldwio	r2,0(r2)
8110c288:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110c28c:	00001f06 	br	8110c30c <msgdma_descriptor_sync_transfer+0x3b0>
		alt_busy_sleep(1); /* delay 1us */
8110c290:	01000044 	movi	r4,1
8110c294:	1137ee40 	call	81137ee4 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110c298:	e0bff10b 	ldhu	r2,-60(fp)
8110c29c:	1084e230 	cmpltui	r2,r2,5000
8110c2a0:	1000131e 	bne	r2,zero,8110c2f0 <msgdma_descriptor_sync_transfer+0x394>
		{
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110c2a4:	00a045f4 	movhi	r2,33047
8110c2a8:	10a25304 	addi	r2,r2,-30388
8110c2ac:	10800a8b 	ldhu	r2,42(r2)
8110c2b0:	10bfffcc 	andi	r2,r2,65535
8110c2b4:	10800228 	cmpgeui	r2,r2,8
8110c2b8:	1000071e 	bne	r2,zero,8110c2d8 <msgdma_descriptor_sync_transfer+0x37c>
				debug(fp, "time out after 5 msec while waiting for any pending transfer complete\n");
8110c2bc:	d0a06217 	ldw	r2,-32376(gp)
8110c2c0:	100f883a 	mov	r7,r2
8110c2c4:	01801184 	movi	r6,70
8110c2c8:	01400044 	movi	r5,1
8110c2cc:	01204574 	movhi	r4,33045
8110c2d0:	21387b04 	addi	r4,r4,-7700
8110c2d4:	112393c0 	call	8112393c <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110c2d8:	e0bffd17 	ldw	r2,-12(fp)
8110c2dc:	10801817 	ldw	r2,96(r2)
8110c2e0:	1009883a 	mov	r4,r2
8110c2e4:	1140ae40 	call	81140ae4 <OSSemPost>

			return -ETIME;
8110c2e8:	00bff084 	movi	r2,-62
8110c2ec:	00003a06 	br	8110c3d8 <msgdma_descriptor_sync_transfer+0x47c>
		}
		counter++;
8110c2f0:	e0bff10b 	ldhu	r2,-60(fp)
8110c2f4:	10800044 	addi	r2,r2,1
8110c2f8:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110c2fc:	e0bffd17 	ldw	r2,-12(fp)
8110c300:	10800317 	ldw	r2,12(r2)
8110c304:	10800037 	ldwio	r2,0(r2)
8110c308:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110c30c:	e0fff017 	ldw	r3,-64(fp)
8110c310:	e0bff617 	ldw	r2,-40(fp)
8110c314:	1884703a 	and	r2,r3,r2
8110c318:	1000031e 	bne	r2,zero,8110c328 <msgdma_descriptor_sync_transfer+0x3cc>
8110c31c:	e0bff017 	ldw	r2,-64(fp)
8110c320:	1080004c 	andi	r2,r2,1
8110c324:	103fda1e 	bne	r2,zero,8110c290 <__reset+0xfb0ec290>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110c328:	e0fff017 	ldw	r3,-64(fp)
8110c32c:	e0bff617 	ldw	r2,-40(fp)
8110c330:	1884703a 	and	r2,r3,r2
8110c334:	10000626 	beq	r2,zero,8110c350 <msgdma_descriptor_sync_transfer+0x3f4>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110c338:	e0bffd17 	ldw	r2,-12(fp)
8110c33c:	10801817 	ldw	r2,96(r2)
8110c340:	1009883a 	mov	r4,r2
8110c344:	1140ae40 	call	81140ae4 <OSSemPost>

		return error;
8110c348:	e0bff617 	ldw	r2,-40(fp)
8110c34c:	00002206 	br	8110c3d8 <msgdma_descriptor_sync_transfer+0x47c>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110c350:	e0bffd17 	ldw	r2,-12(fp)
8110c354:	10800317 	ldw	r2,12(r2)
8110c358:	10800104 	addi	r2,r2,4
8110c35c:	10800037 	ldwio	r2,0(r2)
8110c360:	10800814 	ori	r2,r2,32
8110c364:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110c368:	0005303a 	rdctl	r2,status
8110c36c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110c370:	e0fffa17 	ldw	r3,-24(fp)
8110c374:	00bfff84 	movi	r2,-2
8110c378:	1884703a 	and	r2,r3,r2
8110c37c:	1001703a 	wrctl	status,r2
  
  return context;
8110c380:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110c384:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110c388:	e0bffd17 	ldw	r2,-12(fp)
8110c38c:	10800317 	ldw	r2,12(r2)
8110c390:	10800104 	addi	r2,r2,4
8110c394:	e0fff417 	ldw	r3,-48(fp)
8110c398:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110c39c:	e0bffd17 	ldw	r2,-12(fp)
8110c3a0:	10800317 	ldw	r2,12(r2)
8110c3a4:	e0fffd17 	ldw	r3,-12(fp)
8110c3a8:	18c00317 	ldw	r3,12(r3)
8110c3ac:	18c00037 	ldwio	r3,0(r3)
8110c3b0:	10c00035 	stwio	r3,0(r2)
8110c3b4:	e0bff517 	ldw	r2,-44(fp)
8110c3b8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110c3bc:	e0bff917 	ldw	r2,-28(fp)
8110c3c0:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110c3c4:	e0bffd17 	ldw	r2,-12(fp)
8110c3c8:	10801817 	ldw	r2,96(r2)
8110c3cc:	1009883a 	mov	r4,r2
8110c3d0:	1140ae40 	call	81140ae4 <OSSemPost>

	return 0;
8110c3d4:	0005883a 	mov	r2,zero

}
8110c3d8:	e037883a 	mov	sp,fp
8110c3dc:	dfc00117 	ldw	ra,4(sp)
8110c3e0:	df000017 	ldw	fp,0(sp)
8110c3e4:	dec00204 	addi	sp,sp,8
8110c3e8:	f800283a 	ret

8110c3ec <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110c3ec:	deffec04 	addi	sp,sp,-80
8110c3f0:	de00012e 	bgeu	sp,et,8110c3f8 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110c3f4:	003b68fa 	trap	3
8110c3f8:	dfc01315 	stw	ra,76(sp)
8110c3fc:	df001215 	stw	fp,72(sp)
8110c400:	df001204 	addi	fp,sp,72
8110c404:	e13ff715 	stw	r4,-36(fp)
8110c408:	e17ff815 	stw	r5,-32(fp)
8110c40c:	e1bff915 	stw	r6,-28(fp)
8110c410:	e1fffa15 	stw	r7,-24(fp)
8110c414:	e1800617 	ldw	r6,24(fp)
8110c418:	e1400717 	ldw	r5,28(fp)
8110c41c:	e1000817 	ldw	r4,32(fp)
8110c420:	e0c00917 	ldw	r3,36(fp)
8110c424:	e0800a17 	ldw	r2,40(fp)
8110c428:	e1bffb0d 	sth	r6,-20(fp)
8110c42c:	e17ffc05 	stb	r5,-16(fp)
8110c430:	e13ffd05 	stb	r4,-12(fp)
8110c434:	e0fffe0d 	sth	r3,-8(fp)
8110c438:	e0bfff0d 	sth	r2,-4(fp)

	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110c43c:	e0bffb0b 	ldhu	r2,-20(fp)
8110c440:	e0fffc03 	ldbu	r3,-16(fp)
8110c444:	e13ffd03 	ldbu	r4,-12(fp)
8110c448:	e17ffe0b 	ldhu	r5,-8(fp)
8110c44c:	e1bfff0b 	ldhu	r6,-4(fp)
8110c450:	d9800815 	stw	r6,32(sp)
8110c454:	d9400715 	stw	r5,28(sp)
8110c458:	d9000615 	stw	r4,24(sp)
8110c45c:	d8c00515 	stw	r3,20(sp)
8110c460:	d8800415 	stw	r2,16(sp)
8110c464:	e0800517 	ldw	r2,20(fp)
8110c468:	d8800315 	stw	r2,12(sp)
8110c46c:	e0800417 	ldw	r2,16(fp)
8110c470:	d8800215 	stw	r2,8(sp)
8110c474:	e0800317 	ldw	r2,12(fp)
8110c478:	d8800115 	stw	r2,4(sp)
8110c47c:	e0800217 	ldw	r2,8(fp)
8110c480:	d8800015 	stw	r2,0(sp)
8110c484:	e1fffa17 	ldw	r7,-24(fp)
8110c488:	e1bff917 	ldw	r6,-28(fp)
8110c48c:	e17ff817 	ldw	r5,-32(fp)
8110c490:	e13ff717 	ldw	r4,-36(fp)
8110c494:	110bab00 	call	8110bab0 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110c498:	e037883a 	mov	sp,fp
8110c49c:	dfc00117 	ldw	ra,4(sp)
8110c4a0:	df000017 	ldw	fp,0(sp)
8110c4a4:	dec00204 	addi	sp,sp,8
8110c4a8:	f800283a 	ret

8110c4ac <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110c4ac:	defffc04 	addi	sp,sp,-16
8110c4b0:	de00012e 	bgeu	sp,et,8110c4b8 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110c4b4:	003b68fa 	trap	3
8110c4b8:	dfc00315 	stw	ra,12(sp)
8110c4bc:	df000215 	stw	fp,8(sp)
8110c4c0:	df000204 	addi	fp,sp,8
8110c4c4:	e13ffe15 	stw	r4,-8(fp)
8110c4c8:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110c4cc:	e1bfff17 	ldw	r6,-4(fp)
8110c4d0:	000b883a 	mov	r5,zero
8110c4d4:	e13ffe17 	ldw	r4,-8(fp)
8110c4d8:	110bc140 	call	8110bc14 <msgdma_descriptor_async_transfer>
}
8110c4dc:	e037883a 	mov	sp,fp
8110c4e0:	dfc00117 	ldw	ra,4(sp)
8110c4e4:	df000017 	ldw	fp,0(sp)
8110c4e8:	dec00204 	addi	sp,sp,8
8110c4ec:	f800283a 	ret

8110c4f0 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110c4f0:	defffc04 	addi	sp,sp,-16
8110c4f4:	de00012e 	bgeu	sp,et,8110c4fc <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110c4f8:	003b68fa 	trap	3
8110c4fc:	dfc00315 	stw	ra,12(sp)
8110c500:	df000215 	stw	fp,8(sp)
8110c504:	df000204 	addi	fp,sp,8
8110c508:	e13ffe15 	stw	r4,-8(fp)
8110c50c:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110c510:	e1bfff17 	ldw	r6,-4(fp)
8110c514:	000b883a 	mov	r5,zero
8110c518:	e13ffe17 	ldw	r4,-8(fp)
8110c51c:	110bf5c0 	call	8110bf5c <msgdma_descriptor_sync_transfer>
}
8110c520:	e037883a 	mov	sp,fp
8110c524:	dfc00117 	ldw	ra,4(sp)
8110c528:	df000017 	ldw	fp,0(sp)
8110c52c:	dec00204 	addi	sp,sp,8
8110c530:	f800283a 	ret

8110c534 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110c534:	defff204 	addi	sp,sp,-56
8110c538:	de00012e 	bgeu	sp,et,8110c540 <POWER_SPI_RW+0xc>
8110c53c:	003b68fa 	trap	3
8110c540:	dfc00d15 	stw	ra,52(sp)
8110c544:	df000c15 	stw	fp,48(sp)
8110c548:	df000c04 	addi	fp,sp,48
8110c54c:	2007883a 	mov	r3,r4
8110c550:	2805883a 	mov	r2,r5
8110c554:	e1bffe15 	stw	r6,-8(fp)
8110c558:	e1ffff15 	stw	r7,-4(fp)
8110c55c:	e0fffc05 	stb	r3,-16(fp)
8110c560:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110c564:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110c568:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110c56c:	008003f4 	movhi	r2,15
8110c570:	10909004 	addi	r2,r2,16960
8110c574:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110c578:	00bfe004 	movi	r2,-128
8110c57c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110c580:	e0bffe17 	ldw	r2,-8(fp)
8110c584:	10000226 	beq	r2,zero,8110c590 <POWER_SPI_RW+0x5c>
8110c588:	00800804 	movi	r2,32
8110c58c:	00000106 	br	8110c594 <POWER_SPI_RW+0x60>
8110c590:	0005883a 	mov	r2,zero
8110c594:	e0fff403 	ldbu	r3,-48(fp)
8110c598:	10c4b03a 	or	r2,r2,r3
8110c59c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110c5a0:	e0800217 	ldw	r2,8(fp)
8110c5a4:	10000226 	beq	r2,zero,8110c5b0 <POWER_SPI_RW+0x7c>
8110c5a8:	00800404 	movi	r2,16
8110c5ac:	00000106 	br	8110c5b4 <POWER_SPI_RW+0x80>
8110c5b0:	0005883a 	mov	r2,zero
8110c5b4:	e0fff403 	ldbu	r3,-48(fp)
8110c5b8:	10c4b03a 	or	r2,r2,r3
8110c5bc:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110c5c0:	e0bfff17 	ldw	r2,-4(fp)
8110c5c4:	10000226 	beq	r2,zero,8110c5d0 <POWER_SPI_RW+0x9c>
8110c5c8:	00800204 	movi	r2,8
8110c5cc:	00000106 	br	8110c5d4 <POWER_SPI_RW+0xa0>
8110c5d0:	0005883a 	mov	r2,zero
8110c5d4:	e0fff403 	ldbu	r3,-48(fp)
8110c5d8:	10c4b03a 	or	r2,r2,r3
8110c5dc:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110c5e0:	e0bffd03 	ldbu	r2,-12(fp)
8110c5e4:	108001cc 	andi	r2,r2,7
8110c5e8:	1007883a 	mov	r3,r2
8110c5ec:	e0bff403 	ldbu	r2,-48(fp)
8110c5f0:	1884b03a 	or	r2,r3,r2
8110c5f4:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110c5f8:	0007883a 	mov	r3,zero
8110c5fc:	00a00034 	movhi	r2,32768
8110c600:	10824404 	addi	r2,r2,2320
8110c604:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110c608:	0007883a 	mov	r3,zero
8110c60c:	00a00034 	movhi	r2,32768
8110c610:	10824c04 	addi	r2,r2,2352
8110c614:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110c618:	e0bffc03 	ldbu	r2,-16(fp)
8110c61c:	1000021e 	bne	r2,zero,8110c628 <POWER_SPI_RW+0xf4>
8110c620:	00c00084 	movi	r3,2
8110c624:	00000106 	br	8110c62c <POWER_SPI_RW+0xf8>
8110c628:	00c00044 	movi	r3,1
8110c62c:	00a00034 	movhi	r2,32768
8110c630:	10824804 	addi	r2,r2,2336
8110c634:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110c638:	010003c4 	movi	r4,15
8110c63c:	11399580 	call	81139958 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110c640:	00000306 	br	8110c650 <POWER_SPI_RW+0x11c>
		nWait++;
8110c644:	e0bff817 	ldw	r2,-32(fp)
8110c648:	10800044 	addi	r2,r2,1
8110c64c:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110c650:	00a00034 	movhi	r2,32768
8110c654:	10825404 	addi	r2,r2,2384
8110c658:	10800037 	ldwio	r2,0(r2)
8110c65c:	1080004c 	andi	r2,r2,1
8110c660:	10000326 	beq	r2,zero,8110c670 <POWER_SPI_RW+0x13c>
8110c664:	e0fff817 	ldw	r3,-32(fp)
8110c668:	e0bffa17 	ldw	r2,-24(fp)
8110c66c:	18bff516 	blt	r3,r2,8110c644 <__reset+0xfb0ec644>
		nWait++;
	}

	if (SPI_SDO) {
8110c670:	00a00034 	movhi	r2,32768
8110c674:	10825404 	addi	r2,r2,2384
8110c678:	10800037 	ldwio	r2,0(r2)
8110c67c:	1080004c 	andi	r2,r2,1
8110c680:	10000626 	beq	r2,zero,8110c69c <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110c684:	00c000c4 	movi	r3,3
8110c688:	00a00034 	movhi	r2,32768
8110c68c:	10824804 	addi	r2,r2,2336
8110c690:	10c00035 	stwio	r3,0(r2)
		return FALSE;
8110c694:	0005883a 	mov	r2,zero
8110c698:	0000db06 	br	8110ca08 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110c69c:	e03ff715 	stw	zero,-36(fp)
8110c6a0:	00002406 	br	8110c734 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110c6a4:	e0bff403 	ldbu	r2,-48(fp)
8110c6a8:	10803fcc 	andi	r2,r2,255
8110c6ac:	1004d1fa 	srli	r2,r2,7
8110c6b0:	10c03fcc 	andi	r3,r2,255
8110c6b4:	00a00034 	movhi	r2,32768
8110c6b8:	10825004 	addi	r2,r2,2368
8110c6bc:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110c6c0:	e0bff403 	ldbu	r2,-48(fp)
8110c6c4:	1085883a 	add	r2,r2,r2
8110c6c8:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110c6cc:	e0bff517 	ldw	r2,-44(fp)
8110c6d0:	1085883a 	add	r2,r2,r2
8110c6d4:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110c6d8:	00a00034 	movhi	r2,32768
8110c6dc:	10825404 	addi	r2,r2,2384
8110c6e0:	10800037 	ldwio	r2,0(r2)
8110c6e4:	1080004c 	andi	r2,r2,1
8110c6e8:	1007883a 	mov	r3,r2
8110c6ec:	e0bff517 	ldw	r2,-44(fp)
8110c6f0:	10c4b03a 	or	r2,r2,r3
8110c6f4:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c6f8:	00c00044 	movi	r3,1
8110c6fc:	00a00034 	movhi	r2,32768
8110c700:	10824c04 	addi	r2,r2,2352
8110c704:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c708:	010003c4 	movi	r4,15
8110c70c:	11399580 	call	81139958 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c710:	0007883a 	mov	r3,zero
8110c714:	00a00034 	movhi	r2,32768
8110c718:	10824c04 	addi	r2,r2,2352
8110c71c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c720:	010003c4 	movi	r4,15
8110c724:	11399580 	call	81139958 <usleep>
	if (SPI_SDO) {
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110c728:	e0bff717 	ldw	r2,-36(fp)
8110c72c:	10800044 	addi	r2,r2,1
8110c730:	e0bff715 	stw	r2,-36(fp)
8110c734:	e0bff717 	ldw	r2,-36(fp)
8110c738:	10800090 	cmplti	r2,r2,2
8110c73c:	103fd91e 	bne	r2,zero,8110c6a4 <__reset+0xfb0ec6a4>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110c740:	e03ff715 	stw	zero,-36(fp)
8110c744:	00002406 	br	8110c7d8 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110c748:	e0bff403 	ldbu	r2,-48(fp)
8110c74c:	10803fcc 	andi	r2,r2,255
8110c750:	1004d1fa 	srli	r2,r2,7
8110c754:	10c03fcc 	andi	r3,r2,255
8110c758:	00a00034 	movhi	r2,32768
8110c75c:	10825004 	addi	r2,r2,2368
8110c760:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110c764:	e0bff403 	ldbu	r2,-48(fp)
8110c768:	1085883a 	add	r2,r2,r2
8110c76c:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110c770:	e0bff517 	ldw	r2,-44(fp)
8110c774:	1085883a 	add	r2,r2,r2
8110c778:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110c77c:	00a00034 	movhi	r2,32768
8110c780:	10825404 	addi	r2,r2,2384
8110c784:	10800037 	ldwio	r2,0(r2)
8110c788:	1080004c 	andi	r2,r2,1
8110c78c:	1007883a 	mov	r3,r2
8110c790:	e0bff517 	ldw	r2,-44(fp)
8110c794:	10c4b03a 	or	r2,r2,r3
8110c798:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c79c:	00c00044 	movi	r3,1
8110c7a0:	00a00034 	movhi	r2,32768
8110c7a4:	10824c04 	addi	r2,r2,2352
8110c7a8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c7ac:	010003c4 	movi	r4,15
8110c7b0:	11399580 	call	81139958 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c7b4:	0007883a 	mov	r3,zero
8110c7b8:	00a00034 	movhi	r2,32768
8110c7bc:	10824c04 	addi	r2,r2,2352
8110c7c0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c7c4:	010003c4 	movi	r4,15
8110c7c8:	11399580 	call	81139958 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110c7cc:	e0bff717 	ldw	r2,-36(fp)
8110c7d0:	10800044 	addi	r2,r2,1
8110c7d4:	e0bff715 	stw	r2,-36(fp)
8110c7d8:	e0bff717 	ldw	r2,-36(fp)
8110c7dc:	10800210 	cmplti	r2,r2,8
8110c7e0:	103fd91e 	bne	r2,zero,8110c748 <__reset+0xfb0ec748>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c7e4:	e03ff715 	stw	zero,-36(fp)
8110c7e8:	00001a06 	br	8110c854 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110c7ec:	e0bff517 	ldw	r2,-44(fp)
8110c7f0:	1085883a 	add	r2,r2,r2
8110c7f4:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110c7f8:	00a00034 	movhi	r2,32768
8110c7fc:	10825404 	addi	r2,r2,2384
8110c800:	10800037 	ldwio	r2,0(r2)
8110c804:	1080004c 	andi	r2,r2,1
8110c808:	1007883a 	mov	r3,r2
8110c80c:	e0bff517 	ldw	r2,-44(fp)
8110c810:	10c4b03a 	or	r2,r2,r3
8110c814:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c818:	00c00044 	movi	r3,1
8110c81c:	00a00034 	movhi	r2,32768
8110c820:	10824c04 	addi	r2,r2,2352
8110c824:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c828:	010003c4 	movi	r4,15
8110c82c:	11399580 	call	81139958 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c830:	0007883a 	mov	r3,zero
8110c834:	00a00034 	movhi	r2,32768
8110c838:	10824c04 	addi	r2,r2,2352
8110c83c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c840:	010003c4 	movi	r4,15
8110c844:	11399580 	call	81139958 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c848:	e0bff717 	ldw	r2,-36(fp)
8110c84c:	10800044 	addi	r2,r2,1
8110c850:	e0bff715 	stw	r2,-36(fp)
8110c854:	e0bff717 	ldw	r2,-36(fp)
8110c858:	10800210 	cmplti	r2,r2,8
8110c85c:	103fe31e 	bne	r2,zero,8110c7ec <__reset+0xfb0ec7ec>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c860:	e03ff715 	stw	zero,-36(fp)
8110c864:	00001a06 	br	8110c8d0 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110c868:	e0bff517 	ldw	r2,-44(fp)
8110c86c:	1085883a 	add	r2,r2,r2
8110c870:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110c874:	00a00034 	movhi	r2,32768
8110c878:	10825404 	addi	r2,r2,2384
8110c87c:	10800037 	ldwio	r2,0(r2)
8110c880:	1080004c 	andi	r2,r2,1
8110c884:	1007883a 	mov	r3,r2
8110c888:	e0bff517 	ldw	r2,-44(fp)
8110c88c:	10c4b03a 	or	r2,r2,r3
8110c890:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c894:	00c00044 	movi	r3,1
8110c898:	00a00034 	movhi	r2,32768
8110c89c:	10824c04 	addi	r2,r2,2352
8110c8a0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c8a4:	010003c4 	movi	r4,15
8110c8a8:	11399580 	call	81139958 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c8ac:	0007883a 	mov	r3,zero
8110c8b0:	00a00034 	movhi	r2,32768
8110c8b4:	10824c04 	addi	r2,r2,2352
8110c8b8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c8bc:	010003c4 	movi	r4,15
8110c8c0:	11399580 	call	81139958 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c8c4:	e0bff717 	ldw	r2,-36(fp)
8110c8c8:	10800044 	addi	r2,r2,1
8110c8cc:	e0bff715 	stw	r2,-36(fp)
8110c8d0:	e0bff717 	ldw	r2,-36(fp)
8110c8d4:	10800210 	cmplti	r2,r2,8
8110c8d8:	103fe31e 	bne	r2,zero,8110c868 <__reset+0xfb0ec868>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c8dc:	e03ff715 	stw	zero,-36(fp)
8110c8e0:	00001a06 	br	8110c94c <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110c8e4:	e0bff517 	ldw	r2,-44(fp)
8110c8e8:	1085883a 	add	r2,r2,r2
8110c8ec:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110c8f0:	00a00034 	movhi	r2,32768
8110c8f4:	10825404 	addi	r2,r2,2384
8110c8f8:	10800037 	ldwio	r2,0(r2)
8110c8fc:	1080004c 	andi	r2,r2,1
8110c900:	1007883a 	mov	r3,r2
8110c904:	e0bff517 	ldw	r2,-44(fp)
8110c908:	10c4b03a 	or	r2,r2,r3
8110c90c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c910:	00c00044 	movi	r3,1
8110c914:	00a00034 	movhi	r2,32768
8110c918:	10824c04 	addi	r2,r2,2352
8110c91c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c920:	010003c4 	movi	r4,15
8110c924:	11399580 	call	81139958 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c928:	0007883a 	mov	r3,zero
8110c92c:	00a00034 	movhi	r2,32768
8110c930:	10824c04 	addi	r2,r2,2352
8110c934:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c938:	010003c4 	movi	r4,15
8110c93c:	11399580 	call	81139958 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c940:	e0bff717 	ldw	r2,-36(fp)
8110c944:	10800044 	addi	r2,r2,1
8110c948:	e0bff715 	stw	r2,-36(fp)
8110c94c:	e0bff717 	ldw	r2,-36(fp)
8110c950:	10800190 	cmplti	r2,r2,6
8110c954:	103fe31e 	bne	r2,zero,8110c8e4 <__reset+0xfb0ec8e4>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110c958:	00c00044 	movi	r3,1
8110c95c:	00a00034 	movhi	r2,32768
8110c960:	10824c04 	addi	r2,r2,2352
8110c964:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110c968:	010003c4 	movi	r4,15
8110c96c:	11399580 	call	81139958 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110c970:	00c000c4 	movi	r3,3
8110c974:	00a00034 	movhi	r2,32768
8110c978:	10824804 	addi	r2,r2,2336
8110c97c:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110c980:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110c984:	00800044 	movi	r2,1
8110c988:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110c98c:	e03ff715 	stw	zero,-36(fp)
8110c990:	00000d06 	br	8110c9c8 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110c994:	e0fff517 	ldw	r3,-44(fp)
8110c998:	e0bff617 	ldw	r2,-40(fp)
8110c99c:	1884703a 	and	r2,r3,r2
8110c9a0:	1000031e 	bne	r2,zero,8110c9b0 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110c9a4:	e0bff917 	ldw	r2,-28(fp)
8110c9a8:	10800044 	addi	r2,r2,1
8110c9ac:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110c9b0:	e0bff617 	ldw	r2,-40(fp)
8110c9b4:	1085883a 	add	r2,r2,r2
8110c9b8:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110c9bc:	e0bff717 	ldw	r2,-36(fp)
8110c9c0:	10800044 	addi	r2,r2,1
8110c9c4:	e0bff715 	stw	r2,-36(fp)
8110c9c8:	e0bff717 	ldw	r2,-36(fp)
8110c9cc:	10800810 	cmplti	r2,r2,32
8110c9d0:	103ff01e 	bne	r2,zero,8110c994 <__reset+0xfb0ec994>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110c9d4:	e0bff917 	ldw	r2,-28(fp)
8110c9d8:	1080004c 	andi	r2,r2,1
8110c9dc:	1005003a 	cmpeq	r2,r2,zero
8110c9e0:	10803fcc 	andi	r2,r2,255
8110c9e4:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110c9e8:	e0bffb17 	ldw	r2,-20(fp)
8110c9ec:	1000021e 	bne	r2,zero,8110c9f8 <POWER_SPI_RW+0x4c4>
		return FALSE;
8110c9f0:	0005883a 	mov	r2,zero
8110c9f4:	00000406 	br	8110ca08 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110c9f8:	e0800317 	ldw	r2,12(fp)
8110c9fc:	e0fff517 	ldw	r3,-44(fp)
8110ca00:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110ca04:	e0bffb17 	ldw	r2,-20(fp)
}
8110ca08:	e037883a 	mov	sp,fp
8110ca0c:	dfc00117 	ldw	ra,4(sp)
8110ca10:	df000017 	ldw	fp,0(sp)
8110ca14:	dec00204 	addi	sp,sp,8
8110ca18:	f800283a 	ret

8110ca1c <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110ca1c:	defffc04 	addi	sp,sp,-16
8110ca20:	de00012e 	bgeu	sp,et,8110ca28 <vRstcSimucamReset+0xc>
8110ca24:	003b68fa 	trap	3
8110ca28:	dfc00315 	stw	ra,12(sp)
8110ca2c:	df000215 	stw	fp,8(sp)
8110ca30:	df000204 	addi	fp,sp,8
8110ca34:	2005883a 	mov	r2,r4
8110ca38:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110ca3c:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110ca40:	e0bfff0b 	ldhu	r2,-4(fp)
8110ca44:	e0fffe17 	ldw	r3,-8(fp)
8110ca48:	1884b03a 	or	r2,r3,r2
8110ca4c:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110ca50:	e0bffe17 	ldw	r2,-8(fp)
8110ca54:	10800074 	orhi	r2,r2,1
8110ca58:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110ca5c:	e1bffe17 	ldw	r6,-8(fp)
8110ca60:	000b883a 	mov	r5,zero
8110ca64:	01200034 	movhi	r4,32768
8110ca68:	21020004 	addi	r4,r4,2048
8110ca6c:	110cb6c0 	call	8110cb6c <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110ca70:	0001883a 	nop
8110ca74:	e037883a 	mov	sp,fp
8110ca78:	dfc00117 	ldw	ra,4(sp)
8110ca7c:	df000017 	ldw	fp,0(sp)
8110ca80:	dec00204 	addi	sp,sp,8
8110ca84:	f800283a 	ret

8110ca88 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110ca88:	defffc04 	addi	sp,sp,-16
8110ca8c:	de00012e 	bgeu	sp,et,8110ca94 <vRstcReleaseDeviceReset+0xc>
8110ca90:	003b68fa 	trap	3
8110ca94:	dfc00315 	stw	ra,12(sp)
8110ca98:	df000215 	stw	fp,8(sp)
8110ca9c:	df000204 	addi	fp,sp,8
8110caa0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110caa4:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110caa8:	01400044 	movi	r5,1
8110caac:	01200034 	movhi	r4,32768
8110cab0:	21020004 	addi	r4,r4,2048
8110cab4:	110cbc00 	call	8110cbc0 <uliRstReadReg>
8110cab8:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110cabc:	e0bfff17 	ldw	r2,-4(fp)
8110cac0:	0084303a 	nor	r2,zero,r2
8110cac4:	e0fffe17 	ldw	r3,-8(fp)
8110cac8:	1884703a 	and	r2,r3,r2
8110cacc:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110cad0:	e1bffe17 	ldw	r6,-8(fp)
8110cad4:	01400044 	movi	r5,1
8110cad8:	01200034 	movhi	r4,32768
8110cadc:	21020004 	addi	r4,r4,2048
8110cae0:	110cb6c0 	call	8110cb6c <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110cae4:	0001883a 	nop
8110cae8:	e037883a 	mov	sp,fp
8110caec:	dfc00117 	ldw	ra,4(sp)
8110caf0:	df000017 	ldw	fp,0(sp)
8110caf4:	dec00204 	addi	sp,sp,8
8110caf8:	f800283a 	ret

8110cafc <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110cafc:	defffc04 	addi	sp,sp,-16
8110cb00:	de00012e 	bgeu	sp,et,8110cb08 <vRstcHoldDeviceReset+0xc>
8110cb04:	003b68fa 	trap	3
8110cb08:	dfc00315 	stw	ra,12(sp)
8110cb0c:	df000215 	stw	fp,8(sp)
8110cb10:	df000204 	addi	fp,sp,8
8110cb14:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110cb18:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110cb1c:	01400044 	movi	r5,1
8110cb20:	01200034 	movhi	r4,32768
8110cb24:	21020004 	addi	r4,r4,2048
8110cb28:	110cbc00 	call	8110cbc0 <uliRstReadReg>
8110cb2c:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110cb30:	e0fffe17 	ldw	r3,-8(fp)
8110cb34:	e0bfff17 	ldw	r2,-4(fp)
8110cb38:	1884b03a 	or	r2,r3,r2
8110cb3c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110cb40:	e1bffe17 	ldw	r6,-8(fp)
8110cb44:	01400044 	movi	r5,1
8110cb48:	01200034 	movhi	r4,32768
8110cb4c:	21020004 	addi	r4,r4,2048
8110cb50:	110cb6c0 	call	8110cb6c <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110cb54:	0001883a 	nop
8110cb58:	e037883a 	mov	sp,fp
8110cb5c:	dfc00117 	ldw	ra,4(sp)
8110cb60:	df000017 	ldw	fp,0(sp)
8110cb64:	dec00204 	addi	sp,sp,8
8110cb68:	f800283a 	ret

8110cb6c <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110cb6c:	defffc04 	addi	sp,sp,-16
8110cb70:	de00012e 	bgeu	sp,et,8110cb78 <vRstcWriteReg+0xc>
8110cb74:	003b68fa 	trap	3
8110cb78:	df000315 	stw	fp,12(sp)
8110cb7c:	df000304 	addi	fp,sp,12
8110cb80:	e13ffd15 	stw	r4,-12(fp)
8110cb84:	e17ffe15 	stw	r5,-8(fp)
8110cb88:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110cb8c:	e0bffe17 	ldw	r2,-8(fp)
8110cb90:	1085883a 	add	r2,r2,r2
8110cb94:	1085883a 	add	r2,r2,r2
8110cb98:	1007883a 	mov	r3,r2
8110cb9c:	e0bffd17 	ldw	r2,-12(fp)
8110cba0:	10c5883a 	add	r2,r2,r3
8110cba4:	e0ffff17 	ldw	r3,-4(fp)
8110cba8:	10c00015 	stw	r3,0(r2)
}
8110cbac:	0001883a 	nop
8110cbb0:	e037883a 	mov	sp,fp
8110cbb4:	df000017 	ldw	fp,0(sp)
8110cbb8:	dec00104 	addi	sp,sp,4
8110cbbc:	f800283a 	ret

8110cbc0 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110cbc0:	defffc04 	addi	sp,sp,-16
8110cbc4:	de00012e 	bgeu	sp,et,8110cbcc <uliRstReadReg+0xc>
8110cbc8:	003b68fa 	trap	3
8110cbcc:	df000315 	stw	fp,12(sp)
8110cbd0:	df000304 	addi	fp,sp,12
8110cbd4:	e13ffe15 	stw	r4,-8(fp)
8110cbd8:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110cbdc:	e0bfff17 	ldw	r2,-4(fp)
8110cbe0:	1085883a 	add	r2,r2,r2
8110cbe4:	1085883a 	add	r2,r2,r2
8110cbe8:	1007883a 	mov	r3,r2
8110cbec:	e0bffe17 	ldw	r2,-8(fp)
8110cbf0:	10c5883a 	add	r2,r2,r3
8110cbf4:	10800017 	ldw	r2,0(r2)
8110cbf8:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110cbfc:	e0bffd17 	ldw	r2,-12(fp)
}
8110cc00:	e037883a 	mov	sp,fp
8110cc04:	df000017 	ldw	fp,0(sp)
8110cc08:	dec00104 	addi	sp,sp,4
8110cc0c:	f800283a 	ret

8110cc10 <v_spi_start>:

#if DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110cc10:	defffe04 	addi	sp,sp,-8
8110cc14:	de00012e 	bgeu	sp,et,8110cc1c <v_spi_start+0xc>
8110cc18:	003b68fa 	trap	3
8110cc1c:	dfc00115 	stw	ra,4(sp)
8110cc20:	df000015 	stw	fp,0(sp)
8110cc24:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110cc28:	0007883a 	mov	r3,zero
8110cc2c:	00a00034 	movhi	r2,32768
8110cc30:	10823004 	addi	r2,r2,2240
8110cc34:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110cc38:	0007883a 	mov	r3,zero
8110cc3c:	00a00034 	movhi	r2,32768
8110cc40:	10822c04 	addi	r2,r2,2224
8110cc44:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110cc48:	01002584 	movi	r4,150
8110cc4c:	11399580 	call	81139958 <usleep>
}
8110cc50:	0001883a 	nop
8110cc54:	e037883a 	mov	sp,fp
8110cc58:	dfc00117 	ldw	ra,4(sp)
8110cc5c:	df000017 	ldw	fp,0(sp)
8110cc60:	dec00204 	addi	sp,sp,8
8110cc64:	f800283a 	ret

8110cc68 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110cc68:	defffc04 	addi	sp,sp,-16
8110cc6c:	de00012e 	bgeu	sp,et,8110cc74 <v_spi_send_byte+0xc>
8110cc70:	003b68fa 	trap	3
8110cc74:	dfc00315 	stw	ra,12(sp)
8110cc78:	df000215 	stw	fp,8(sp)
8110cc7c:	df000204 	addi	fp,sp,8
8110cc80:	2005883a 	mov	r2,r4
8110cc84:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110cc88:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110cc8c:	00bfe004 	movi	r2,-128
8110cc90:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110cc94:	e03ffe05 	stb	zero,-8(fp)
8110cc98:	00001b06 	br	8110cd08 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110cc9c:	e0ffff03 	ldbu	r3,-4(fp)
8110cca0:	e0bffe43 	ldbu	r2,-7(fp)
8110cca4:	1884703a 	and	r2,r3,r2
8110cca8:	10803fcc 	andi	r2,r2,255
8110ccac:	1004c03a 	cmpne	r2,r2,zero
8110ccb0:	10c03fcc 	andi	r3,r2,255
8110ccb4:	00a00034 	movhi	r2,32768
8110ccb8:	10823404 	addi	r2,r2,2256
8110ccbc:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110ccc0:	e0bffe43 	ldbu	r2,-7(fp)
8110ccc4:	1004d07a 	srli	r2,r2,1
8110ccc8:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110cccc:	00c00044 	movi	r3,1
8110ccd0:	00a00034 	movhi	r2,32768
8110ccd4:	10823004 	addi	r2,r2,2240
8110ccd8:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110ccdc:	01002584 	movi	r4,150
8110cce0:	11399580 	call	81139958 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110cce4:	0007883a 	mov	r3,zero
8110cce8:	00a00034 	movhi	r2,32768
8110ccec:	10823004 	addi	r2,r2,2240
8110ccf0:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110ccf4:	01002584 	movi	r4,150
8110ccf8:	11399580 	call	81139958 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110ccfc:	e0bffe03 	ldbu	r2,-8(fp)
8110cd00:	10800044 	addi	r2,r2,1
8110cd04:	e0bffe05 	stb	r2,-8(fp)
8110cd08:	e0bffe03 	ldbu	r2,-8(fp)
8110cd0c:	10800230 	cmpltui	r2,r2,8
8110cd10:	103fe21e 	bne	r2,zero,8110cc9c <__reset+0xfb0ecc9c>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110cd14:	0001883a 	nop
8110cd18:	e037883a 	mov	sp,fp
8110cd1c:	dfc00117 	ldw	ra,4(sp)
8110cd20:	df000017 	ldw	fp,0(sp)
8110cd24:	dec00204 	addi	sp,sp,8
8110cd28:	f800283a 	ret

8110cd2c <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110cd2c:	defffd04 	addi	sp,sp,-12
8110cd30:	de00012e 	bgeu	sp,et,8110cd38 <uc_spi_get_byte+0xc>
8110cd34:	003b68fa 	trap	3
8110cd38:	dfc00215 	stw	ra,8(sp)
8110cd3c:	df000115 	stw	fp,4(sp)
8110cd40:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110cd44:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110cd48:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110cd4c:	e03fff05 	stb	zero,-4(fp)
8110cd50:	00001a06 	br	8110cdbc <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110cd54:	e0bfff43 	ldbu	r2,-3(fp)
8110cd58:	1085883a 	add	r2,r2,r2
8110cd5c:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110cd60:	00a00034 	movhi	r2,32768
8110cd64:	10823804 	addi	r2,r2,2272
8110cd68:	10800037 	ldwio	r2,0(r2)
8110cd6c:	1080004c 	andi	r2,r2,1
8110cd70:	1007883a 	mov	r3,r2
8110cd74:	e0bfff43 	ldbu	r2,-3(fp)
8110cd78:	1884b03a 	or	r2,r3,r2
8110cd7c:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110cd80:	00c00044 	movi	r3,1
8110cd84:	00a00034 	movhi	r2,32768
8110cd88:	10823004 	addi	r2,r2,2240
8110cd8c:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110cd90:	01002584 	movi	r4,150
8110cd94:	11399580 	call	81139958 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110cd98:	0007883a 	mov	r3,zero
8110cd9c:	00a00034 	movhi	r2,32768
8110cda0:	10823004 	addi	r2,r2,2240
8110cda4:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110cda8:	01002584 	movi	r4,150
8110cdac:	11399580 	call	81139958 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110cdb0:	e0bfff03 	ldbu	r2,-4(fp)
8110cdb4:	10800044 	addi	r2,r2,1
8110cdb8:	e0bfff05 	stb	r2,-4(fp)
8110cdbc:	e0bfff03 	ldbu	r2,-4(fp)
8110cdc0:	10800230 	cmpltui	r2,r2,8
8110cdc4:	103fe31e 	bne	r2,zero,8110cd54 <__reset+0xfb0ecd54>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110cdc8:	e0bfff43 	ldbu	r2,-3(fp)
}
8110cdcc:	e037883a 	mov	sp,fp
8110cdd0:	dfc00117 	ldw	ra,4(sp)
8110cdd4:	df000017 	ldw	fp,0(sp)
8110cdd8:	dec00204 	addi	sp,sp,8
8110cddc:	f800283a 	ret

8110cde0 <v_spi_end>:

void v_spi_end(void){
8110cde0:	defffe04 	addi	sp,sp,-8
8110cde4:	de00012e 	bgeu	sp,et,8110cdec <v_spi_end+0xc>
8110cde8:	003b68fa 	trap	3
8110cdec:	dfc00115 	stw	ra,4(sp)
8110cdf0:	df000015 	stw	fp,0(sp)
8110cdf4:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110cdf8:	0007883a 	mov	r3,zero
8110cdfc:	00a00034 	movhi	r2,32768
8110ce00:	10823004 	addi	r2,r2,2240
8110ce04:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110ce08:	01002584 	movi	r4,150
8110ce0c:	11399580 	call	81139958 <usleep>
    SPI_CS_N(1);
8110ce10:	00c00044 	movi	r3,1
8110ce14:	00a00034 	movhi	r2,32768
8110ce18:	10822c04 	addi	r2,r2,2224
8110ce1c:	10c00035 	stwio	r3,0(r2)
}
8110ce20:	0001883a 	nop
8110ce24:	e037883a 	mov	sp,fp
8110ce28:	dfc00117 	ldw	ra,4(sp)
8110ce2c:	df000017 	ldw	fp,0(sp)
8110ce30:	dec00204 	addi	sp,sp,8
8110ce34:	f800283a 	ret

8110ce38 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110ce38:	defff604 	addi	sp,sp,-40
8110ce3c:	de00012e 	bgeu	sp,et,8110ce44 <RTCC_SPI_R_MAC+0xc>
8110ce40:	003b68fa 	trap	3
8110ce44:	dfc00915 	stw	ra,36(sp)
8110ce48:	df000815 	stw	fp,32(sp)
8110ce4c:	df000804 	addi	fp,sp,32
8110ce50:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110ce54:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110ce58:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110ce5c:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110ce60:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110ce64:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110ce68:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110ce6c:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110ce70:	00800084 	movi	r2,2
8110ce74:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110ce78:	00800cc4 	movi	r2,51
8110ce7c:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110ce80:	110cc100 	call	8110cc10 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110ce84:	e0bffec3 	ldbu	r2,-5(fp)
8110ce88:	1009883a 	mov	r4,r2
8110ce8c:	110cc680 	call	8110cc68 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110ce90:	e0bffe83 	ldbu	r2,-6(fp)
8110ce94:	1009883a 	mov	r4,r2
8110ce98:	110cc680 	call	8110cc68 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110ce9c:	110cd2c0 	call	8110cd2c <uc_spi_get_byte>
8110cea0:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110cea4:	110cd2c0 	call	8110cd2c <uc_spi_get_byte>
8110cea8:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110ceac:	110cd2c0 	call	8110cd2c <uc_spi_get_byte>
8110ceb0:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110ceb4:	110cd2c0 	call	8110cd2c <uc_spi_get_byte>
8110ceb8:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110cebc:	110cd2c0 	call	8110cd2c <uc_spi_get_byte>
8110cec0:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110cec4:	110cd2c0 	call	8110cd2c <uc_spi_get_byte>
8110cec8:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110cecc:	110cde00 	call	8110cde0 <v_spi_end>

    bSuccess = TRUE;
8110ced0:	00800044 	movi	r2,1
8110ced4:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110ced8:	e0bfff17 	ldw	r2,-4(fp)
8110cedc:	e0fffd03 	ldbu	r3,-12(fp)
8110cee0:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110cee4:	e0bfff17 	ldw	r2,-4(fp)
8110cee8:	10800044 	addi	r2,r2,1
8110ceec:	e0fffd43 	ldbu	r3,-11(fp)
8110cef0:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110cef4:	e0bfff17 	ldw	r2,-4(fp)
8110cef8:	10800084 	addi	r2,r2,2
8110cefc:	e0fffd83 	ldbu	r3,-10(fp)
8110cf00:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110cf04:	e0bfff17 	ldw	r2,-4(fp)
8110cf08:	108000c4 	addi	r2,r2,3
8110cf0c:	e0fffdc3 	ldbu	r3,-9(fp)
8110cf10:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110cf14:	e0bfff17 	ldw	r2,-4(fp)
8110cf18:	10800104 	addi	r2,r2,4
8110cf1c:	e0fffe03 	ldbu	r3,-8(fp)
8110cf20:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110cf24:	e0bfff17 	ldw	r2,-4(fp)
8110cf28:	10800144 	addi	r2,r2,5
8110cf2c:	e0fffe43 	ldbu	r3,-7(fp)
8110cf30:	10c00005 	stb	r3,0(r2)

#if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110cf34:	00a045f4 	movhi	r2,33047
8110cf38:	10a25304 	addi	r2,r2,-30388
8110cf3c:	10800a8b 	ldhu	r2,42(r2)
8110cf40:	10bfffcc 	andi	r2,r2,65535
8110cf44:	108000e8 	cmpgeui	r2,r2,3
8110cf48:	1000141e 	bne	r2,zero,8110cf9c <RTCC_SPI_R_MAC+0x164>
		sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110cf4c:	e1bffd03 	ldbu	r6,-12(fp)
8110cf50:	e1fffd43 	ldbu	r7,-11(fp)
8110cf54:	e0bffd83 	ldbu	r2,-10(fp)
8110cf58:	e0fffdc3 	ldbu	r3,-9(fp)
8110cf5c:	e13ffe03 	ldbu	r4,-8(fp)
8110cf60:	e17ffe43 	ldbu	r5,-7(fp)
8110cf64:	d9400315 	stw	r5,12(sp)
8110cf68:	d9000215 	stw	r4,8(sp)
8110cf6c:	d8c00115 	stw	r3,4(sp)
8110cf70:	d8800015 	stw	r2,0(sp)
8110cf74:	01604574 	movhi	r5,33045
8110cf78:	29788d04 	addi	r5,r5,-7628
8110cf7c:	01204574 	movhi	r4,33045
8110cf80:	21146d04 	addi	r4,r4,20916
8110cf84:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, cDebugBuffer);
8110cf88:	d0a06217 	ldw	r2,-32376(gp)
8110cf8c:	01604574 	movhi	r5,33045
8110cf90:	29546d04 	addi	r5,r5,20916
8110cf94:	1009883a 	mov	r4,r2
8110cf98:	11232a00 	call	811232a0 <fprintf>
    }
#endif

    return bSuccess;
8110cf9c:	e0bffc17 	ldw	r2,-16(fp)
}
8110cfa0:	e037883a 	mov	sp,fp
8110cfa4:	dfc00117 	ldw	ra,4(sp)
8110cfa8:	df000017 	ldw	fp,0(sp)
8110cfac:	dec00204 	addi	sp,sp,8
8110cfb0:	f800283a 	ret

8110cfb4 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110cfb4:	defffd04 	addi	sp,sp,-12
8110cfb8:	de00012e 	bgeu	sp,et,8110cfc0 <bSSDisplayConfig+0xc>
8110cfbc:	003b68fa 	trap	3
8110cfc0:	df000215 	stw	fp,8(sp)
8110cfc4:	df000204 	addi	fp,sp,8
8110cfc8:	2005883a 	mov	r2,r4
8110cfcc:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110cfd0:	e0bfff03 	ldbu	r2,-4(fp)
8110cfd4:	10c00168 	cmpgeui	r3,r2,5
8110cfd8:	18001c1e 	bne	r3,zero,8110d04c <bSSDisplayConfig+0x98>
8110cfdc:	100690ba 	slli	r3,r2,2
8110cfe0:	00a04474 	movhi	r2,33041
8110cfe4:	10b3fd04 	addi	r2,r2,-12300
8110cfe8:	1885883a 	add	r2,r3,r2
8110cfec:	10800017 	ldw	r2,0(r2)
8110cff0:	1000683a 	jmp	r2
8110cff4:	8110d008 	cmpgei	r4,r16,17216
8110cff8:	8110d014 	ori	r4,r16,17216
8110cffc:	8110d020 	cmpeqi	r4,r16,17216
8110d000:	8110d034 	orhi	r4,r16,17216
8110d004:	8110d044 	addi	r4,r16,17217
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110d008:	00800cc4 	movi	r2,51
8110d00c:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110d010:	00001006 	br	8110d054 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110d014:	00801544 	movi	r2,85
8110d018:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110d01c:	00000d06 	br	8110d054 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110d020:	d0e05043 	ldbu	r3,-32447(gp)
8110d024:	00bff744 	movi	r2,-35
8110d028:	1884703a 	and	r2,r3,r2
8110d02c:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110d030:	00000806 	br	8110d054 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110d034:	d0a05043 	ldbu	r2,-32447(gp)
8110d038:	10800894 	ori	r2,r2,34
8110d03c:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110d040:	00000406 	br	8110d054 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110d044:	d0205045 	stb	zero,-32447(gp)
	    break;
8110d048:	00000206 	br	8110d054 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110d04c:	0005883a 	mov	r2,zero
8110d050:	00000806 	br	8110d074 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110d054:	00a00034 	movhi	r2,32768
8110d058:	10828404 	addi	r2,r2,2576
8110d05c:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110d060:	d0a05043 	ldbu	r2,-32447(gp)
8110d064:	10c03fcc 	andi	r3,r2,255
8110d068:	e0bffe17 	ldw	r2,-8(fp)
8110d06c:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110d070:	00800044 	movi	r2,1
}
8110d074:	e037883a 	mov	sp,fp
8110d078:	df000017 	ldw	fp,0(sp)
8110d07c:	dec00104 	addi	sp,sp,4
8110d080:	f800283a 	ret

8110d084 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110d084:	defffd04 	addi	sp,sp,-12
8110d088:	de00012e 	bgeu	sp,et,8110d090 <bSSDisplayUpdate+0xc>
8110d08c:	003b68fa 	trap	3
8110d090:	df000215 	stw	fp,8(sp)
8110d094:	df000204 	addi	fp,sp,8
8110d098:	2005883a 	mov	r2,r4
8110d09c:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110d0a0:	00a00034 	movhi	r2,32768
8110d0a4:	10828404 	addi	r2,r2,2576
8110d0a8:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110d0ac:	e0bffe17 	ldw	r2,-8(fp)
8110d0b0:	10800104 	addi	r2,r2,4
8110d0b4:	e0ffff03 	ldbu	r3,-4(fp)
8110d0b8:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110d0bc:	00800044 	movi	r2,1
}
8110d0c0:	e037883a 	mov	sp,fp
8110d0c4:	df000017 	ldw	fp,0(sp)
8110d0c8:	dec00104 	addi	sp,sp,4
8110d0cc:	f800283a 	ret

8110d0d0 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110d0d0:	defff904 	addi	sp,sp,-28
8110d0d4:	de00012e 	bgeu	sp,et,8110d0dc <vSyncHandleIrq+0xc>
8110d0d8:	003b68fa 	trap	3
8110d0dc:	dfc00615 	stw	ra,24(sp)
8110d0e0:	df000515 	stw	fp,20(sp)
8110d0e4:	df000504 	addi	fp,sp,20
8110d0e8:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110d0ec:	e0bfff17 	ldw	r2,-4(fp)
8110d0f0:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110d0f4:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110d0f8:	d0a05203 	ldbu	r2,-32440(gp)
8110d0fc:	108000cc 	andi	r2,r2,3
8110d100:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 )
8110d104:	e0bffd03 	ldbu	r2,-12(fp)
8110d108:	1000031e 	bne	r2,zero,8110d118 <vSyncHandleIrq+0x48>
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110d10c:	00bff804 	movi	r2,-32
8110d110:	e0bffe85 	stb	r2,-6(fp)
8110d114:	00000206 	br	8110d120 <vSyncHandleIrq+0x50>
	else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110d118:	00bff844 	movi	r2,-31
8110d11c:	e0bffe85 	stb	r2,-6(fp)

	uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110d120:	00800044 	movi	r2,1
8110d124:	e0bffec5 	stb	r2,-5(fp)

	/* Send Priority message to the Meb Task to indicate the Master Sync */
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110d128:	d0a06917 	ldw	r2,-32348(gp)
8110d12c:	e0fffe17 	ldw	r3,-8(fp)
8110d130:	180b883a 	mov	r5,r3
8110d134:	1009883a 	mov	r4,r2
8110d138:	113fddc0 	call	8113fddc <OSQPostFront>
8110d13c:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110d140:	e0bffd43 	ldbu	r2,-11(fp)
8110d144:	10000126 	beq	r2,zero,8110d14c <vSyncHandleIrq+0x7c>
		vFailSendMsgMasterSyncMeb( );
8110d148:	111f24c0 	call	8111f24c <vFailSendMsgMasterSyncMeb>
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110d14c:	e03ffb05 	stb	zero,-20(fp)
8110d150:	00001606 	br	8110d1ac <vSyncHandleIrq+0xdc>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110d154:	e0bffb03 	ldbu	r2,-20(fp)
8110d158:	10800444 	addi	r2,r2,17
8110d15c:	e0bffec5 	stb	r2,-5(fp)
		error_codel = OSQPostFront(xFeeQ[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110d160:	e0bffb03 	ldbu	r2,-20(fp)
8110d164:	1085883a 	add	r2,r2,r2
8110d168:	1087883a 	add	r3,r2,r2
8110d16c:	d0a06a04 	addi	r2,gp,-32344
8110d170:	1885883a 	add	r2,r3,r2
8110d174:	10800017 	ldw	r2,0(r2)
8110d178:	e0fffe17 	ldw	r3,-8(fp)
8110d17c:	180b883a 	mov	r5,r3
8110d180:	1009883a 	mov	r4,r2
8110d184:	113fddc0 	call	8113fddc <OSQPostFront>
8110d188:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110d18c:	e0bffd43 	ldbu	r2,-11(fp)
8110d190:	10000326 	beq	r2,zero,8110d1a0 <vSyncHandleIrq+0xd0>
			vFailSendMsgSync( ucIL );
8110d194:	e0bffb03 	ldbu	r2,-20(fp)
8110d198:	1009883a 	mov	r4,r2
8110d19c:	111f1740 	call	8111f174 <vFailSendMsgSync>
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
	if ( error_codel != OS_ERR_NONE ) {
		vFailSendMsgMasterSyncMeb( );
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110d1a0:	e0bffb03 	ldbu	r2,-20(fp)
8110d1a4:	10800044 	addi	r2,r2,1
8110d1a8:	e0bffb05 	stb	r2,-20(fp)
8110d1ac:	e0bffb03 	ldbu	r2,-20(fp)
8110d1b0:	103fe826 	beq	r2,zero,8110d154 <__reset+0xfb0ed154>
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}

	vucN += 1;
8110d1b4:	d0a05203 	ldbu	r2,-32440(gp)
8110d1b8:	10800044 	addi	r2,r2,1
8110d1bc:	d0a05205 	stb	r2,-32440(gp)

	vSyncIrqFlagClrSync();
8110d1c0:	110d2540 	call	8110d254 <vSyncIrqFlagClrSync>
}
8110d1c4:	0001883a 	nop
8110d1c8:	e037883a 	mov	sp,fp
8110d1cc:	dfc00117 	ldw	ra,4(sp)
8110d1d0:	df000017 	ldw	fp,0(sp)
8110d1d4:	dec00204 	addi	sp,sp,8
8110d1d8:	f800283a 	ret

8110d1dc <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110d1dc:	deffff04 	addi	sp,sp,-4
8110d1e0:	de00012e 	bgeu	sp,et,8110d1e8 <vSyncClearCounter+0xc>
8110d1e4:	003b68fa 	trap	3
8110d1e8:	df000015 	stw	fp,0(sp)
8110d1ec:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110d1f0:	d0205205 	stb	zero,-32440(gp)
}
8110d1f4:	0001883a 	nop
8110d1f8:	e037883a 	mov	sp,fp
8110d1fc:	df000017 	ldw	fp,0(sp)
8110d200:	dec00104 	addi	sp,sp,4
8110d204:	f800283a 	ret

8110d208 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110d208:	defffd04 	addi	sp,sp,-12
8110d20c:	de00012e 	bgeu	sp,et,8110d214 <vSyncInitIrq+0xc>
8110d210:	003b68fa 	trap	3
8110d214:	dfc00215 	stw	ra,8(sp)
8110d218:	df000115 	stw	fp,4(sp)
8110d21c:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110d220:	d0a05104 	addi	r2,gp,-32444
8110d224:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110d228:	01a04474 	movhi	r6,33041
8110d22c:	31b43404 	addi	r6,r6,-12080
8110d230:	e17fff17 	ldw	r5,-4(fp)
8110d234:	01000284 	movi	r4,10
8110d238:	11382880 	call	81138288 <alt_irq_register>
}
8110d23c:	0001883a 	nop
8110d240:	e037883a 	mov	sp,fp
8110d244:	dfc00117 	ldw	ra,4(sp)
8110d248:	df000017 	ldw	fp,0(sp)
8110d24c:	dec00204 	addi	sp,sp,8
8110d250:	f800283a 	ret

8110d254 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110d254:	defffe04 	addi	sp,sp,-8
8110d258:	de00012e 	bgeu	sp,et,8110d260 <vSyncIrqFlagClrSync+0xc>
8110d25c:	003b68fa 	trap	3
8110d260:	dfc00115 	stw	ra,4(sp)
8110d264:	df000015 	stw	fp,0(sp)
8110d268:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110d26c:	01400044 	movi	r5,1
8110d270:	010002c4 	movi	r4,11
8110d274:	110e0340 	call	8110e034 <bSyncWriteReg>
}
8110d278:	0001883a 	nop
8110d27c:	e037883a 	mov	sp,fp
8110d280:	dfc00117 	ldw	ra,4(sp)
8110d284:	df000017 	ldw	fp,0(sp)
8110d288:	dec00204 	addi	sp,sp,8
8110d28c:	f800283a 	ret

8110d290 <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110d290:	defffd04 	addi	sp,sp,-12
8110d294:	de00012e 	bgeu	sp,et,8110d29c <bSyncIrqFlagSync+0xc>
8110d298:	003b68fa 	trap	3
8110d29c:	dfc00215 	stw	ra,8(sp)
8110d2a0:	df000115 	stw	fp,4(sp)
8110d2a4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110d2a8:	01000304 	movi	r4,12
8110d2ac:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d2b0:	1080004c 	andi	r2,r2,1
8110d2b4:	10000326 	beq	r2,zero,8110d2c4 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110d2b8:	00800044 	movi	r2,1
8110d2bc:	e0bfff15 	stw	r2,-4(fp)
8110d2c0:	00000106 	br	8110d2c8 <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110d2c4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110d2c8:	e0bfff17 	ldw	r2,-4(fp)
}
8110d2cc:	e037883a 	mov	sp,fp
8110d2d0:	dfc00117 	ldw	ra,4(sp)
8110d2d4:	df000017 	ldw	fp,0(sp)
8110d2d8:	dec00204 	addi	sp,sp,8
8110d2dc:	f800283a 	ret

8110d2e0 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110d2e0:	defffc04 	addi	sp,sp,-16
8110d2e4:	de00012e 	bgeu	sp,et,8110d2ec <bSyncStatusExtnIrq+0xc>
8110d2e8:	003b68fa 	trap	3
8110d2ec:	dfc00315 	stw	ra,12(sp)
8110d2f0:	df000215 	stw	fp,8(sp)
8110d2f4:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d2f8:	0009883a 	mov	r4,zero
8110d2fc:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d300:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110d304:	e0bfff17 	ldw	r2,-4(fp)
8110d308:	1000030e 	bge	r2,zero,8110d318 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110d30c:	00800044 	movi	r2,1
8110d310:	e0bffe15 	stw	r2,-8(fp)
8110d314:	00000106 	br	8110d31c <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110d318:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d31c:	e0bffe17 	ldw	r2,-8(fp)
}
8110d320:	e037883a 	mov	sp,fp
8110d324:	dfc00117 	ldw	ra,4(sp)
8110d328:	df000017 	ldw	fp,0(sp)
8110d32c:	dec00204 	addi	sp,sp,8
8110d330:	f800283a 	ret

8110d334 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110d334:	defffc04 	addi	sp,sp,-16
8110d338:	de00012e 	bgeu	sp,et,8110d340 <ucSyncStatusState+0xc>
8110d33c:	003b68fa 	trap	3
8110d340:	dfc00315 	stw	ra,12(sp)
8110d344:	df000215 	stw	fp,8(sp)
8110d348:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d34c:	0009883a 	mov	r4,zero
8110d350:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d354:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110d358:	e0bffe17 	ldw	r2,-8(fp)
8110d35c:	10803fec 	andhi	r2,r2,255
8110d360:	1004d43a 	srli	r2,r2,16
8110d364:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110d368:	e0bfff03 	ldbu	r2,-4(fp)
}
8110d36c:	e037883a 	mov	sp,fp
8110d370:	dfc00117 	ldw	ra,4(sp)
8110d374:	df000017 	ldw	fp,0(sp)
8110d378:	dec00204 	addi	sp,sp,8
8110d37c:	f800283a 	ret

8110d380 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110d380:	defffc04 	addi	sp,sp,-16
8110d384:	de00012e 	bgeu	sp,et,8110d38c <ucSyncStatusErrorCode+0xc>
8110d388:	003b68fa 	trap	3
8110d38c:	dfc00315 	stw	ra,12(sp)
8110d390:	df000215 	stw	fp,8(sp)
8110d394:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d398:	0009883a 	mov	r4,zero
8110d39c:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d3a0:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110d3a4:	e0bffe17 	ldw	r2,-8(fp)
8110d3a8:	10bfc00c 	andi	r2,r2,65280
8110d3ac:	1004d23a 	srli	r2,r2,8
8110d3b0:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110d3b4:	e0bfff03 	ldbu	r2,-4(fp)
}
8110d3b8:	e037883a 	mov	sp,fp
8110d3bc:	dfc00117 	ldw	ra,4(sp)
8110d3c0:	df000017 	ldw	fp,0(sp)
8110d3c4:	dec00204 	addi	sp,sp,8
8110d3c8:	f800283a 	ret

8110d3cc <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110d3cc:	defffc04 	addi	sp,sp,-16
8110d3d0:	de00012e 	bgeu	sp,et,8110d3d8 <ucSyncStatusCycleNumber+0xc>
8110d3d4:	003b68fa 	trap	3
8110d3d8:	dfc00315 	stw	ra,12(sp)
8110d3dc:	df000215 	stw	fp,8(sp)
8110d3e0:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d3e4:	0009883a 	mov	r4,zero
8110d3e8:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d3ec:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110d3f0:	e0bffe17 	ldw	r2,-8(fp)
8110d3f4:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110d3f8:	e0bfff03 	ldbu	r2,-4(fp)
}
8110d3fc:	e037883a 	mov	sp,fp
8110d400:	dfc00117 	ldw	ra,4(sp)
8110d404:	df000017 	ldw	fp,0(sp)
8110d408:	dec00204 	addi	sp,sp,8
8110d40c:	f800283a 	ret

8110d410 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110d410:	defffd04 	addi	sp,sp,-12
8110d414:	de00012e 	bgeu	sp,et,8110d41c <bSyncSetMbt+0xc>
8110d418:	003b68fa 	trap	3
8110d41c:	dfc00215 	stw	ra,8(sp)
8110d420:	df000115 	stw	fp,4(sp)
8110d424:	df000104 	addi	fp,sp,4
8110d428:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110d42c:	e17fff17 	ldw	r5,-4(fp)
8110d430:	01000104 	movi	r4,4
8110d434:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d438:	00800044 	movi	r2,1
}
8110d43c:	e037883a 	mov	sp,fp
8110d440:	dfc00117 	ldw	ra,4(sp)
8110d444:	df000017 	ldw	fp,0(sp)
8110d448:	dec00204 	addi	sp,sp,8
8110d44c:	f800283a 	ret

8110d450 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110d450:	defffd04 	addi	sp,sp,-12
8110d454:	de00012e 	bgeu	sp,et,8110d45c <bSyncSetBt+0xc>
8110d458:	003b68fa 	trap	3
8110d45c:	dfc00215 	stw	ra,8(sp)
8110d460:	df000115 	stw	fp,4(sp)
8110d464:	df000104 	addi	fp,sp,4
8110d468:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110d46c:	e17fff17 	ldw	r5,-4(fp)
8110d470:	01000144 	movi	r4,5
8110d474:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d478:	00800044 	movi	r2,1
}
8110d47c:	e037883a 	mov	sp,fp
8110d480:	dfc00117 	ldw	ra,4(sp)
8110d484:	df000017 	ldw	fp,0(sp)
8110d488:	dec00204 	addi	sp,sp,8
8110d48c:	f800283a 	ret

8110d490 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110d490:	defffd04 	addi	sp,sp,-12
8110d494:	de00012e 	bgeu	sp,et,8110d49c <bSyncSetPer+0xc>
8110d498:	003b68fa 	trap	3
8110d49c:	dfc00215 	stw	ra,8(sp)
8110d4a0:	df000115 	stw	fp,4(sp)
8110d4a4:	df000104 	addi	fp,sp,4
8110d4a8:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110d4ac:	e17fff17 	ldw	r5,-4(fp)
8110d4b0:	01000184 	movi	r4,6
8110d4b4:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d4b8:	00800044 	movi	r2,1
}
8110d4bc:	e037883a 	mov	sp,fp
8110d4c0:	dfc00117 	ldw	ra,4(sp)
8110d4c4:	df000017 	ldw	fp,0(sp)
8110d4c8:	dec00204 	addi	sp,sp,8
8110d4cc:	f800283a 	ret

8110d4d0 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110d4d0:	defffd04 	addi	sp,sp,-12
8110d4d4:	de00012e 	bgeu	sp,et,8110d4dc <bSyncSetOst+0xc>
8110d4d8:	003b68fa 	trap	3
8110d4dc:	dfc00215 	stw	ra,8(sp)
8110d4e0:	df000115 	stw	fp,4(sp)
8110d4e4:	df000104 	addi	fp,sp,4
8110d4e8:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110d4ec:	e17fff17 	ldw	r5,-4(fp)
8110d4f0:	010001c4 	movi	r4,7
8110d4f4:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d4f8:	00800044 	movi	r2,1
}
8110d4fc:	e037883a 	mov	sp,fp
8110d500:	dfc00117 	ldw	ra,4(sp)
8110d504:	df000017 	ldw	fp,0(sp)
8110d508:	dec00204 	addi	sp,sp,8
8110d50c:	f800283a 	ret

8110d510 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110d510:	defffc04 	addi	sp,sp,-16
8110d514:	de00012e 	bgeu	sp,et,8110d51c <bSyncSetPolarity+0xc>
8110d518:	003b68fa 	trap	3
8110d51c:	dfc00315 	stw	ra,12(sp)
8110d520:	df000215 	stw	fp,8(sp)
8110d524:	df000204 	addi	fp,sp,8
8110d528:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110d52c:	01000204 	movi	r4,8
8110d530:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d534:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d538:	e0bfff17 	ldw	r2,-4(fp)
8110d53c:	1000051e 	bne	r2,zero,8110d554 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110d540:	e0fffe17 	ldw	r3,-8(fp)
8110d544:	00bfbfc4 	movi	r2,-257
8110d548:	1884703a 	and	r2,r3,r2
8110d54c:	e0bffe15 	stw	r2,-8(fp)
8110d550:	00000306 	br	8110d560 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110d554:	e0bffe17 	ldw	r2,-8(fp)
8110d558:	10804014 	ori	r2,r2,256
8110d55c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110d560:	e17ffe17 	ldw	r5,-8(fp)
8110d564:	01000204 	movi	r4,8
8110d568:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d56c:	00800044 	movi	r2,1
}
8110d570:	e037883a 	mov	sp,fp
8110d574:	dfc00117 	ldw	ra,4(sp)
8110d578:	df000017 	ldw	fp,0(sp)
8110d57c:	dec00204 	addi	sp,sp,8
8110d580:	f800283a 	ret

8110d584 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110d584:	defffc04 	addi	sp,sp,-16
8110d588:	de00012e 	bgeu	sp,et,8110d590 <bSyncSetNCycles+0xc>
8110d58c:	003b68fa 	trap	3
8110d590:	dfc00315 	stw	ra,12(sp)
8110d594:	df000215 	stw	fp,8(sp)
8110d598:	df000204 	addi	fp,sp,8
8110d59c:	2005883a 	mov	r2,r4
8110d5a0:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110d5a4:	01000204 	movi	r4,8
8110d5a8:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d5ac:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110d5b0:	e0fffe17 	ldw	r3,-8(fp)
8110d5b4:	00bfc004 	movi	r2,-256
8110d5b8:	1884703a 	and	r2,r3,r2
8110d5bc:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110d5c0:	e0bfff03 	ldbu	r2,-4(fp)
8110d5c4:	e0fffe17 	ldw	r3,-8(fp)
8110d5c8:	1884b03a 	or	r2,r3,r2
8110d5cc:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110d5d0:	e17ffe17 	ldw	r5,-8(fp)
8110d5d4:	01000204 	movi	r4,8
8110d5d8:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d5dc:	00800044 	movi	r2,1
}
8110d5e0:	e037883a 	mov	sp,fp
8110d5e4:	dfc00117 	ldw	ra,4(sp)
8110d5e8:	df000017 	ldw	fp,0(sp)
8110d5ec:	dec00204 	addi	sp,sp,8
8110d5f0:	f800283a 	ret

8110d5f4 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110d5f4:	defffd04 	addi	sp,sp,-12
8110d5f8:	de00012e 	bgeu	sp,et,8110d600 <uliSyncGetMbt+0xc>
8110d5fc:	003b68fa 	trap	3
8110d600:	dfc00215 	stw	ra,8(sp)
8110d604:	df000115 	stw	fp,4(sp)
8110d608:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110d60c:	01000104 	movi	r4,4
8110d610:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d614:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d618:	e0bfff17 	ldw	r2,-4(fp)
}
8110d61c:	e037883a 	mov	sp,fp
8110d620:	dfc00117 	ldw	ra,4(sp)
8110d624:	df000017 	ldw	fp,0(sp)
8110d628:	dec00204 	addi	sp,sp,8
8110d62c:	f800283a 	ret

8110d630 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110d630:	defffd04 	addi	sp,sp,-12
8110d634:	de00012e 	bgeu	sp,et,8110d63c <uliSyncGetBt+0xc>
8110d638:	003b68fa 	trap	3
8110d63c:	dfc00215 	stw	ra,8(sp)
8110d640:	df000115 	stw	fp,4(sp)
8110d644:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110d648:	01000144 	movi	r4,5
8110d64c:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d650:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d654:	e0bfff17 	ldw	r2,-4(fp)
}
8110d658:	e037883a 	mov	sp,fp
8110d65c:	dfc00117 	ldw	ra,4(sp)
8110d660:	df000017 	ldw	fp,0(sp)
8110d664:	dec00204 	addi	sp,sp,8
8110d668:	f800283a 	ret

8110d66c <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110d66c:	defffd04 	addi	sp,sp,-12
8110d670:	de00012e 	bgeu	sp,et,8110d678 <uliSyncGetPer+0xc>
8110d674:	003b68fa 	trap	3
8110d678:	dfc00215 	stw	ra,8(sp)
8110d67c:	df000115 	stw	fp,4(sp)
8110d680:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110d684:	01000184 	movi	r4,6
8110d688:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d68c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d690:	e0bfff17 	ldw	r2,-4(fp)
}
8110d694:	e037883a 	mov	sp,fp
8110d698:	dfc00117 	ldw	ra,4(sp)
8110d69c:	df000017 	ldw	fp,0(sp)
8110d6a0:	dec00204 	addi	sp,sp,8
8110d6a4:	f800283a 	ret

8110d6a8 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110d6a8:	defffd04 	addi	sp,sp,-12
8110d6ac:	de00012e 	bgeu	sp,et,8110d6b4 <uliSyncGetOst+0xc>
8110d6b0:	003b68fa 	trap	3
8110d6b4:	dfc00215 	stw	ra,8(sp)
8110d6b8:	df000115 	stw	fp,4(sp)
8110d6bc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110d6c0:	010001c4 	movi	r4,7
8110d6c4:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d6c8:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d6cc:	e0bfff17 	ldw	r2,-4(fp)
}
8110d6d0:	e037883a 	mov	sp,fp
8110d6d4:	dfc00117 	ldw	ra,4(sp)
8110d6d8:	df000017 	ldw	fp,0(sp)
8110d6dc:	dec00204 	addi	sp,sp,8
8110d6e0:	f800283a 	ret

8110d6e4 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110d6e4:	defffd04 	addi	sp,sp,-12
8110d6e8:	de00012e 	bgeu	sp,et,8110d6f0 <uliSyncGetGeneral+0xc>
8110d6ec:	003b68fa 	trap	3
8110d6f0:	dfc00215 	stw	ra,8(sp)
8110d6f4:	df000115 	stw	fp,4(sp)
8110d6f8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110d6fc:	01000204 	movi	r4,8
8110d700:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d704:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d708:	e0bfff17 	ldw	r2,-4(fp)
}
8110d70c:	e037883a 	mov	sp,fp
8110d710:	dfc00117 	ldw	ra,4(sp)
8110d714:	df000017 	ldw	fp,0(sp)
8110d718:	dec00204 	addi	sp,sp,8
8110d71c:	f800283a 	ret

8110d720 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110d720:	defffd04 	addi	sp,sp,-12
8110d724:	de00012e 	bgeu	sp,et,8110d72c <bSyncErrInj+0xc>
8110d728:	003b68fa 	trap	3
8110d72c:	dfc00215 	stw	ra,8(sp)
8110d730:	df000115 	stw	fp,4(sp)
8110d734:	df000104 	addi	fp,sp,4
8110d738:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110d73c:	e17fff17 	ldw	r5,-4(fp)
8110d740:	01000244 	movi	r4,9
8110d744:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d748:	00800044 	movi	r2,1
}
8110d74c:	e037883a 	mov	sp,fp
8110d750:	dfc00117 	ldw	ra,4(sp)
8110d754:	df000017 	ldw	fp,0(sp)
8110d758:	dec00204 	addi	sp,sp,8
8110d75c:	f800283a 	ret

8110d760 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110d760:	defffc04 	addi	sp,sp,-16
8110d764:	de00012e 	bgeu	sp,et,8110d76c <bSyncCtrExtnIrq+0xc>
8110d768:	003b68fa 	trap	3
8110d76c:	dfc00315 	stw	ra,12(sp)
8110d770:	df000215 	stw	fp,8(sp)
8110d774:	df000204 	addi	fp,sp,8
8110d778:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d77c:	01000284 	movi	r4,10
8110d780:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d784:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d788:	e0bfff17 	ldw	r2,-4(fp)
8110d78c:	1000061e 	bne	r2,zero,8110d7a8 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110d790:	e0fffe17 	ldw	r3,-8(fp)
8110d794:	00a00034 	movhi	r2,32768
8110d798:	10bfffc4 	addi	r2,r2,-1
8110d79c:	1884703a 	and	r2,r3,r2
8110d7a0:	e0bffe15 	stw	r2,-8(fp)
8110d7a4:	00000306 	br	8110d7b4 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110d7a8:	e0bffe17 	ldw	r2,-8(fp)
8110d7ac:	10a00034 	orhi	r2,r2,32768
8110d7b0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d7b4:	e17ffe17 	ldw	r5,-8(fp)
8110d7b8:	01000284 	movi	r4,10
8110d7bc:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d7c0:	00800044 	movi	r2,1
}
8110d7c4:	e037883a 	mov	sp,fp
8110d7c8:	dfc00117 	ldw	ra,4(sp)
8110d7cc:	df000017 	ldw	fp,0(sp)
8110d7d0:	dec00204 	addi	sp,sp,8
8110d7d4:	f800283a 	ret

8110d7d8 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110d7d8:	defffd04 	addi	sp,sp,-12
8110d7dc:	de00012e 	bgeu	sp,et,8110d7e4 <bSyncCtrStart+0xc>
8110d7e0:	003b68fa 	trap	3
8110d7e4:	dfc00215 	stw	ra,8(sp)
8110d7e8:	df000115 	stw	fp,4(sp)
8110d7ec:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d7f0:	01000284 	movi	r4,10
8110d7f4:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d7f8:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110d7fc:	e0bfff17 	ldw	r2,-4(fp)
8110d800:	10800234 	orhi	r2,r2,8
8110d804:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d808:	e17fff17 	ldw	r5,-4(fp)
8110d80c:	01000284 	movi	r4,10
8110d810:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d814:	00800044 	movi	r2,1
}
8110d818:	e037883a 	mov	sp,fp
8110d81c:	dfc00117 	ldw	ra,4(sp)
8110d820:	df000017 	ldw	fp,0(sp)
8110d824:	dec00204 	addi	sp,sp,8
8110d828:	f800283a 	ret

8110d82c <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110d82c:	defffd04 	addi	sp,sp,-12
8110d830:	de00012e 	bgeu	sp,et,8110d838 <bSyncCtrReset+0xc>
8110d834:	003b68fa 	trap	3
8110d838:	dfc00215 	stw	ra,8(sp)
8110d83c:	df000115 	stw	fp,4(sp)
8110d840:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d844:	01000284 	movi	r4,10
8110d848:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d84c:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110d850:	e0bfff17 	ldw	r2,-4(fp)
8110d854:	10800134 	orhi	r2,r2,4
8110d858:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d85c:	e17fff17 	ldw	r5,-4(fp)
8110d860:	01000284 	movi	r4,10
8110d864:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d868:	00800044 	movi	r2,1
}
8110d86c:	e037883a 	mov	sp,fp
8110d870:	dfc00117 	ldw	ra,4(sp)
8110d874:	df000017 	ldw	fp,0(sp)
8110d878:	dec00204 	addi	sp,sp,8
8110d87c:	f800283a 	ret

8110d880 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110d880:	defffd04 	addi	sp,sp,-12
8110d884:	de00012e 	bgeu	sp,et,8110d88c <bSyncCtrOneShot+0xc>
8110d888:	003b68fa 	trap	3
8110d88c:	dfc00215 	stw	ra,8(sp)
8110d890:	df000115 	stw	fp,4(sp)
8110d894:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d898:	01000284 	movi	r4,10
8110d89c:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d8a0:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110d8a4:	e0bfff17 	ldw	r2,-4(fp)
8110d8a8:	108000b4 	orhi	r2,r2,2
8110d8ac:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d8b0:	e17fff17 	ldw	r5,-4(fp)
8110d8b4:	01000284 	movi	r4,10
8110d8b8:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d8bc:	00800044 	movi	r2,1
}
8110d8c0:	e037883a 	mov	sp,fp
8110d8c4:	dfc00117 	ldw	ra,4(sp)
8110d8c8:	df000017 	ldw	fp,0(sp)
8110d8cc:	dec00204 	addi	sp,sp,8
8110d8d0:	f800283a 	ret

8110d8d4 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110d8d4:	defffd04 	addi	sp,sp,-12
8110d8d8:	de00012e 	bgeu	sp,et,8110d8e0 <bSyncCtrErrInj+0xc>
8110d8dc:	003b68fa 	trap	3
8110d8e0:	dfc00215 	stw	ra,8(sp)
8110d8e4:	df000115 	stw	fp,4(sp)
8110d8e8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d8ec:	01000284 	movi	r4,10
8110d8f0:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d8f4:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110d8f8:	e0bfff17 	ldw	r2,-4(fp)
8110d8fc:	10800074 	orhi	r2,r2,1
8110d900:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d904:	e17fff17 	ldw	r5,-4(fp)
8110d908:	01000284 	movi	r4,10
8110d90c:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d910:	00800044 	movi	r2,1
}
8110d914:	e037883a 	mov	sp,fp
8110d918:	dfc00117 	ldw	ra,4(sp)
8110d91c:	df000017 	ldw	fp,0(sp)
8110d920:	dec00204 	addi	sp,sp,8
8110d924:	f800283a 	ret

8110d928 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110d928:	defffc04 	addi	sp,sp,-16
8110d92c:	de00012e 	bgeu	sp,et,8110d934 <bSyncCtrSyncOutEnable+0xc>
8110d930:	003b68fa 	trap	3
8110d934:	dfc00315 	stw	ra,12(sp)
8110d938:	df000215 	stw	fp,8(sp)
8110d93c:	df000204 	addi	fp,sp,8
8110d940:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d944:	01000284 	movi	r4,10
8110d948:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d94c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d950:	e0bfff17 	ldw	r2,-4(fp)
8110d954:	1000051e 	bne	r2,zero,8110d96c <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110d958:	e0fffe17 	ldw	r3,-8(fp)
8110d95c:	00bfbfc4 	movi	r2,-257
8110d960:	1884703a 	and	r2,r3,r2
8110d964:	e0bffe15 	stw	r2,-8(fp)
8110d968:	00000306 	br	8110d978 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110d96c:	e0bffe17 	ldw	r2,-8(fp)
8110d970:	10804014 	ori	r2,r2,256
8110d974:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d978:	e17ffe17 	ldw	r5,-8(fp)
8110d97c:	01000284 	movi	r4,10
8110d980:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d984:	00800044 	movi	r2,1
}
8110d988:	e037883a 	mov	sp,fp
8110d98c:	dfc00117 	ldw	ra,4(sp)
8110d990:	df000017 	ldw	fp,0(sp)
8110d994:	dec00204 	addi	sp,sp,8
8110d998:	f800283a 	ret

8110d99c <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110d99c:	defffc04 	addi	sp,sp,-16
8110d9a0:	de00012e 	bgeu	sp,et,8110d9a8 <bSyncCtrCh1OutEnable+0xc>
8110d9a4:	003b68fa 	trap	3
8110d9a8:	dfc00315 	stw	ra,12(sp)
8110d9ac:	df000215 	stw	fp,8(sp)
8110d9b0:	df000204 	addi	fp,sp,8
8110d9b4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d9b8:	01000284 	movi	r4,10
8110d9bc:	110e0900 	call	8110e090 <uliSyncReadReg>
8110d9c0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d9c4:	e0bfff17 	ldw	r2,-4(fp)
8110d9c8:	1000051e 	bne	r2,zero,8110d9e0 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110d9cc:	e0fffe17 	ldw	r3,-8(fp)
8110d9d0:	00bfff84 	movi	r2,-2
8110d9d4:	1884703a 	and	r2,r3,r2
8110d9d8:	e0bffe15 	stw	r2,-8(fp)
8110d9dc:	00000306 	br	8110d9ec <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110d9e0:	e0bffe17 	ldw	r2,-8(fp)
8110d9e4:	10800054 	ori	r2,r2,1
8110d9e8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d9ec:	e17ffe17 	ldw	r5,-8(fp)
8110d9f0:	01000284 	movi	r4,10
8110d9f4:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110d9f8:	00800044 	movi	r2,1
}
8110d9fc:	e037883a 	mov	sp,fp
8110da00:	dfc00117 	ldw	ra,4(sp)
8110da04:	df000017 	ldw	fp,0(sp)
8110da08:	dec00204 	addi	sp,sp,8
8110da0c:	f800283a 	ret

8110da10 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110da10:	defffc04 	addi	sp,sp,-16
8110da14:	de00012e 	bgeu	sp,et,8110da1c <bSyncCtrCh2OutEnable+0xc>
8110da18:	003b68fa 	trap	3
8110da1c:	dfc00315 	stw	ra,12(sp)
8110da20:	df000215 	stw	fp,8(sp)
8110da24:	df000204 	addi	fp,sp,8
8110da28:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110da2c:	01000284 	movi	r4,10
8110da30:	110e0900 	call	8110e090 <uliSyncReadReg>
8110da34:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110da38:	e0bfff17 	ldw	r2,-4(fp)
8110da3c:	1000051e 	bne	r2,zero,8110da54 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110da40:	e0fffe17 	ldw	r3,-8(fp)
8110da44:	00bfff44 	movi	r2,-3
8110da48:	1884703a 	and	r2,r3,r2
8110da4c:	e0bffe15 	stw	r2,-8(fp)
8110da50:	00000306 	br	8110da60 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110da54:	e0bffe17 	ldw	r2,-8(fp)
8110da58:	10800094 	ori	r2,r2,2
8110da5c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110da60:	e17ffe17 	ldw	r5,-8(fp)
8110da64:	01000284 	movi	r4,10
8110da68:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110da6c:	00800044 	movi	r2,1
}
8110da70:	e037883a 	mov	sp,fp
8110da74:	dfc00117 	ldw	ra,4(sp)
8110da78:	df000017 	ldw	fp,0(sp)
8110da7c:	dec00204 	addi	sp,sp,8
8110da80:	f800283a 	ret

8110da84 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110da84:	defffc04 	addi	sp,sp,-16
8110da88:	de00012e 	bgeu	sp,et,8110da90 <bSyncCtrCh3OutEnable+0xc>
8110da8c:	003b68fa 	trap	3
8110da90:	dfc00315 	stw	ra,12(sp)
8110da94:	df000215 	stw	fp,8(sp)
8110da98:	df000204 	addi	fp,sp,8
8110da9c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110daa0:	01000284 	movi	r4,10
8110daa4:	110e0900 	call	8110e090 <uliSyncReadReg>
8110daa8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110daac:	e0bfff17 	ldw	r2,-4(fp)
8110dab0:	1000051e 	bne	r2,zero,8110dac8 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110dab4:	e0fffe17 	ldw	r3,-8(fp)
8110dab8:	00bffec4 	movi	r2,-5
8110dabc:	1884703a 	and	r2,r3,r2
8110dac0:	e0bffe15 	stw	r2,-8(fp)
8110dac4:	00000306 	br	8110dad4 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110dac8:	e0bffe17 	ldw	r2,-8(fp)
8110dacc:	10800114 	ori	r2,r2,4
8110dad0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110dad4:	e17ffe17 	ldw	r5,-8(fp)
8110dad8:	01000284 	movi	r4,10
8110dadc:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110dae0:	00800044 	movi	r2,1
}
8110dae4:	e037883a 	mov	sp,fp
8110dae8:	dfc00117 	ldw	ra,4(sp)
8110daec:	df000017 	ldw	fp,0(sp)
8110daf0:	dec00204 	addi	sp,sp,8
8110daf4:	f800283a 	ret

8110daf8 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110daf8:	defffc04 	addi	sp,sp,-16
8110dafc:	de00012e 	bgeu	sp,et,8110db04 <bSyncCtrCh4OutEnable+0xc>
8110db00:	003b68fa 	trap	3
8110db04:	dfc00315 	stw	ra,12(sp)
8110db08:	df000215 	stw	fp,8(sp)
8110db0c:	df000204 	addi	fp,sp,8
8110db10:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110db14:	01000284 	movi	r4,10
8110db18:	110e0900 	call	8110e090 <uliSyncReadReg>
8110db1c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110db20:	e0bfff17 	ldw	r2,-4(fp)
8110db24:	1000051e 	bne	r2,zero,8110db3c <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110db28:	e0fffe17 	ldw	r3,-8(fp)
8110db2c:	00bffdc4 	movi	r2,-9
8110db30:	1884703a 	and	r2,r3,r2
8110db34:	e0bffe15 	stw	r2,-8(fp)
8110db38:	00000306 	br	8110db48 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110db3c:	e0bffe17 	ldw	r2,-8(fp)
8110db40:	10800214 	ori	r2,r2,8
8110db44:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110db48:	e17ffe17 	ldw	r5,-8(fp)
8110db4c:	01000284 	movi	r4,10
8110db50:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110db54:	00800044 	movi	r2,1
}
8110db58:	e037883a 	mov	sp,fp
8110db5c:	dfc00117 	ldw	ra,4(sp)
8110db60:	df000017 	ldw	fp,0(sp)
8110db64:	dec00204 	addi	sp,sp,8
8110db68:	f800283a 	ret

8110db6c <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110db6c:	defffc04 	addi	sp,sp,-16
8110db70:	de00012e 	bgeu	sp,et,8110db78 <bSyncCtrCh5OutEnable+0xc>
8110db74:	003b68fa 	trap	3
8110db78:	dfc00315 	stw	ra,12(sp)
8110db7c:	df000215 	stw	fp,8(sp)
8110db80:	df000204 	addi	fp,sp,8
8110db84:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110db88:	01000284 	movi	r4,10
8110db8c:	110e0900 	call	8110e090 <uliSyncReadReg>
8110db90:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110db94:	e0bfff17 	ldw	r2,-4(fp)
8110db98:	1000051e 	bne	r2,zero,8110dbb0 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110db9c:	e0fffe17 	ldw	r3,-8(fp)
8110dba0:	00bffbc4 	movi	r2,-17
8110dba4:	1884703a 	and	r2,r3,r2
8110dba8:	e0bffe15 	stw	r2,-8(fp)
8110dbac:	00000306 	br	8110dbbc <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110dbb0:	e0bffe17 	ldw	r2,-8(fp)
8110dbb4:	10800414 	ori	r2,r2,16
8110dbb8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110dbbc:	e17ffe17 	ldw	r5,-8(fp)
8110dbc0:	01000284 	movi	r4,10
8110dbc4:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110dbc8:	00800044 	movi	r2,1
}
8110dbcc:	e037883a 	mov	sp,fp
8110dbd0:	dfc00117 	ldw	ra,4(sp)
8110dbd4:	df000017 	ldw	fp,0(sp)
8110dbd8:	dec00204 	addi	sp,sp,8
8110dbdc:	f800283a 	ret

8110dbe0 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110dbe0:	defffc04 	addi	sp,sp,-16
8110dbe4:	de00012e 	bgeu	sp,et,8110dbec <bSyncCtrCh6OutEnable+0xc>
8110dbe8:	003b68fa 	trap	3
8110dbec:	dfc00315 	stw	ra,12(sp)
8110dbf0:	df000215 	stw	fp,8(sp)
8110dbf4:	df000204 	addi	fp,sp,8
8110dbf8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110dbfc:	01000284 	movi	r4,10
8110dc00:	110e0900 	call	8110e090 <uliSyncReadReg>
8110dc04:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110dc08:	e0bfff17 	ldw	r2,-4(fp)
8110dc0c:	1000051e 	bne	r2,zero,8110dc24 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110dc10:	e0fffe17 	ldw	r3,-8(fp)
8110dc14:	00bff7c4 	movi	r2,-33
8110dc18:	1884703a 	and	r2,r3,r2
8110dc1c:	e0bffe15 	stw	r2,-8(fp)
8110dc20:	00000306 	br	8110dc30 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110dc24:	e0bffe17 	ldw	r2,-8(fp)
8110dc28:	10800814 	ori	r2,r2,32
8110dc2c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110dc30:	e17ffe17 	ldw	r5,-8(fp)
8110dc34:	01000284 	movi	r4,10
8110dc38:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110dc3c:	00800044 	movi	r2,1
}
8110dc40:	e037883a 	mov	sp,fp
8110dc44:	dfc00117 	ldw	ra,4(sp)
8110dc48:	df000017 	ldw	fp,0(sp)
8110dc4c:	dec00204 	addi	sp,sp,8
8110dc50:	f800283a 	ret

8110dc54 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110dc54:	defffc04 	addi	sp,sp,-16
8110dc58:	de00012e 	bgeu	sp,et,8110dc60 <bSyncCtrCh7OutEnable+0xc>
8110dc5c:	003b68fa 	trap	3
8110dc60:	dfc00315 	stw	ra,12(sp)
8110dc64:	df000215 	stw	fp,8(sp)
8110dc68:	df000204 	addi	fp,sp,8
8110dc6c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110dc70:	01000284 	movi	r4,10
8110dc74:	110e0900 	call	8110e090 <uliSyncReadReg>
8110dc78:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110dc7c:	e0bfff17 	ldw	r2,-4(fp)
8110dc80:	1000051e 	bne	r2,zero,8110dc98 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110dc84:	e0fffe17 	ldw	r3,-8(fp)
8110dc88:	00bfefc4 	movi	r2,-65
8110dc8c:	1884703a 	and	r2,r3,r2
8110dc90:	e0bffe15 	stw	r2,-8(fp)
8110dc94:	00000306 	br	8110dca4 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110dc98:	e0bffe17 	ldw	r2,-8(fp)
8110dc9c:	10801014 	ori	r2,r2,64
8110dca0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110dca4:	e17ffe17 	ldw	r5,-8(fp)
8110dca8:	01000284 	movi	r4,10
8110dcac:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110dcb0:	00800044 	movi	r2,1
}
8110dcb4:	e037883a 	mov	sp,fp
8110dcb8:	dfc00117 	ldw	ra,4(sp)
8110dcbc:	df000017 	ldw	fp,0(sp)
8110dcc0:	dec00204 	addi	sp,sp,8
8110dcc4:	f800283a 	ret

8110dcc8 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110dcc8:	defffc04 	addi	sp,sp,-16
8110dccc:	de00012e 	bgeu	sp,et,8110dcd4 <bSyncCtrCh8OutEnable+0xc>
8110dcd0:	003b68fa 	trap	3
8110dcd4:	dfc00315 	stw	ra,12(sp)
8110dcd8:	df000215 	stw	fp,8(sp)
8110dcdc:	df000204 	addi	fp,sp,8
8110dce0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110dce4:	01000284 	movi	r4,10
8110dce8:	110e0900 	call	8110e090 <uliSyncReadReg>
8110dcec:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110dcf0:	e0bfff17 	ldw	r2,-4(fp)
8110dcf4:	1000051e 	bne	r2,zero,8110dd0c <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110dcf8:	e0fffe17 	ldw	r3,-8(fp)
8110dcfc:	00bfdfc4 	movi	r2,-129
8110dd00:	1884703a 	and	r2,r3,r2
8110dd04:	e0bffe15 	stw	r2,-8(fp)
8110dd08:	00000306 	br	8110dd18 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110dd0c:	e0bffe17 	ldw	r2,-8(fp)
8110dd10:	10802014 	ori	r2,r2,128
8110dd14:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110dd18:	e17ffe17 	ldw	r5,-8(fp)
8110dd1c:	01000284 	movi	r4,10
8110dd20:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110dd24:	00800044 	movi	r2,1
}
8110dd28:	e037883a 	mov	sp,fp
8110dd2c:	dfc00117 	ldw	ra,4(sp)
8110dd30:	df000017 	ldw	fp,0(sp)
8110dd34:	dec00204 	addi	sp,sp,8
8110dd38:	f800283a 	ret

8110dd3c <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110dd3c:	defffc04 	addi	sp,sp,-16
8110dd40:	de00012e 	bgeu	sp,et,8110dd48 <bSyncIrqEnableError+0xc>
8110dd44:	003b68fa 	trap	3
8110dd48:	dfc00315 	stw	ra,12(sp)
8110dd4c:	df000215 	stw	fp,8(sp)
8110dd50:	df000204 	addi	fp,sp,8
8110dd54:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110dd58:	01000044 	movi	r4,1
8110dd5c:	110e0900 	call	8110e090 <uliSyncReadReg>
8110dd60:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110dd64:	e0bfff17 	ldw	r2,-4(fp)
8110dd68:	1000051e 	bne	r2,zero,8110dd80 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110dd6c:	e0fffe17 	ldw	r3,-8(fp)
8110dd70:	00bfff44 	movi	r2,-3
8110dd74:	1884703a 	and	r2,r3,r2
8110dd78:	e0bffe15 	stw	r2,-8(fp)
8110dd7c:	00000306 	br	8110dd8c <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110dd80:	e0bffe17 	ldw	r2,-8(fp)
8110dd84:	10800094 	ori	r2,r2,2
8110dd88:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110dd8c:	e17ffe17 	ldw	r5,-8(fp)
8110dd90:	01000044 	movi	r4,1
8110dd94:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110dd98:	00800044 	movi	r2,1
}
8110dd9c:	e037883a 	mov	sp,fp
8110dda0:	dfc00117 	ldw	ra,4(sp)
8110dda4:	df000017 	ldw	fp,0(sp)
8110dda8:	dec00204 	addi	sp,sp,8
8110ddac:	f800283a 	ret

8110ddb0 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110ddb0:	defffc04 	addi	sp,sp,-16
8110ddb4:	de00012e 	bgeu	sp,et,8110ddbc <bSyncIrqEnableBlank+0xc>
8110ddb8:	003b68fa 	trap	3
8110ddbc:	dfc00315 	stw	ra,12(sp)
8110ddc0:	df000215 	stw	fp,8(sp)
8110ddc4:	df000204 	addi	fp,sp,8
8110ddc8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110ddcc:	01000044 	movi	r4,1
8110ddd0:	110e0900 	call	8110e090 <uliSyncReadReg>
8110ddd4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ddd8:	e0bfff17 	ldw	r2,-4(fp)
8110dddc:	1000051e 	bne	r2,zero,8110ddf4 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110dde0:	e0fffe17 	ldw	r3,-8(fp)
8110dde4:	00bfff84 	movi	r2,-2
8110dde8:	1884703a 	and	r2,r3,r2
8110ddec:	e0bffe15 	stw	r2,-8(fp)
8110ddf0:	00000306 	br	8110de00 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110ddf4:	e0bffe17 	ldw	r2,-8(fp)
8110ddf8:	10800054 	ori	r2,r2,1
8110ddfc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110de00:	e17ffe17 	ldw	r5,-8(fp)
8110de04:	01000044 	movi	r4,1
8110de08:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110de0c:	00800044 	movi	r2,1
}
8110de10:	e037883a 	mov	sp,fp
8110de14:	dfc00117 	ldw	ra,4(sp)
8110de18:	df000017 	ldw	fp,0(sp)
8110de1c:	dec00204 	addi	sp,sp,8
8110de20:	f800283a 	ret

8110de24 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110de24:	defffc04 	addi	sp,sp,-16
8110de28:	de00012e 	bgeu	sp,et,8110de30 <bSyncIrqFlagClrError+0xc>
8110de2c:	003b68fa 	trap	3
8110de30:	dfc00315 	stw	ra,12(sp)
8110de34:	df000215 	stw	fp,8(sp)
8110de38:	df000204 	addi	fp,sp,8
8110de3c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110de40:	01000084 	movi	r4,2
8110de44:	110e0900 	call	8110e090 <uliSyncReadReg>
8110de48:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110de4c:	e0bfff17 	ldw	r2,-4(fp)
8110de50:	1000051e 	bne	r2,zero,8110de68 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110de54:	e0fffe17 	ldw	r3,-8(fp)
8110de58:	00bfff44 	movi	r2,-3
8110de5c:	1884703a 	and	r2,r3,r2
8110de60:	e0bffe15 	stw	r2,-8(fp)
8110de64:	00000306 	br	8110de74 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110de68:	e0bffe17 	ldw	r2,-8(fp)
8110de6c:	10800094 	ori	r2,r2,2
8110de70:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110de74:	e17ffe17 	ldw	r5,-8(fp)
8110de78:	01000084 	movi	r4,2
8110de7c:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110de80:	00800044 	movi	r2,1
}
8110de84:	e037883a 	mov	sp,fp
8110de88:	dfc00117 	ldw	ra,4(sp)
8110de8c:	df000017 	ldw	fp,0(sp)
8110de90:	dec00204 	addi	sp,sp,8
8110de94:	f800283a 	ret

8110de98 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110de98:	defffc04 	addi	sp,sp,-16
8110de9c:	de00012e 	bgeu	sp,et,8110dea4 <bSyncIrqFlagClrBlank+0xc>
8110dea0:	003b68fa 	trap	3
8110dea4:	dfc00315 	stw	ra,12(sp)
8110dea8:	df000215 	stw	fp,8(sp)
8110deac:	df000204 	addi	fp,sp,8
8110deb0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110deb4:	01000084 	movi	r4,2
8110deb8:	110e0900 	call	8110e090 <uliSyncReadReg>
8110debc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110dec0:	e0bfff17 	ldw	r2,-4(fp)
8110dec4:	1000051e 	bne	r2,zero,8110dedc <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110dec8:	e0fffe17 	ldw	r3,-8(fp)
8110decc:	00bfff84 	movi	r2,-2
8110ded0:	1884703a 	and	r2,r3,r2
8110ded4:	e0bffe15 	stw	r2,-8(fp)
8110ded8:	00000306 	br	8110dee8 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110dedc:	e0bffe17 	ldw	r2,-8(fp)
8110dee0:	10800054 	ori	r2,r2,1
8110dee4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110dee8:	e17ffe17 	ldw	r5,-8(fp)
8110deec:	01000084 	movi	r4,2
8110def0:	110e0340 	call	8110e034 <bSyncWriteReg>
	return TRUE;
8110def4:	00800044 	movi	r2,1
}
8110def8:	e037883a 	mov	sp,fp
8110defc:	dfc00117 	ldw	ra,4(sp)
8110df00:	df000017 	ldw	fp,0(sp)
8110df04:	dec00204 	addi	sp,sp,8
8110df08:	f800283a 	ret

8110df0c <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110df0c:	defffc04 	addi	sp,sp,-16
8110df10:	de00012e 	bgeu	sp,et,8110df18 <bSyncIrqFlagError+0xc>
8110df14:	003b68fa 	trap	3
8110df18:	dfc00315 	stw	ra,12(sp)
8110df1c:	df000215 	stw	fp,8(sp)
8110df20:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110df24:	010000c4 	movi	r4,3
8110df28:	110e0900 	call	8110e090 <uliSyncReadReg>
8110df2c:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110df30:	e0bfff17 	ldw	r2,-4(fp)
8110df34:	1080008c 	andi	r2,r2,2
8110df38:	10000326 	beq	r2,zero,8110df48 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110df3c:	00800044 	movi	r2,1
8110df40:	e0bffe15 	stw	r2,-8(fp)
8110df44:	00000106 	br	8110df4c <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110df48:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110df4c:	e0bffe17 	ldw	r2,-8(fp)
}
8110df50:	e037883a 	mov	sp,fp
8110df54:	dfc00117 	ldw	ra,4(sp)
8110df58:	df000017 	ldw	fp,0(sp)
8110df5c:	dec00204 	addi	sp,sp,8
8110df60:	f800283a 	ret

8110df64 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110df64:	defffc04 	addi	sp,sp,-16
8110df68:	de00012e 	bgeu	sp,et,8110df70 <bSyncIrqFlagBlank+0xc>
8110df6c:	003b68fa 	trap	3
8110df70:	dfc00315 	stw	ra,12(sp)
8110df74:	df000215 	stw	fp,8(sp)
8110df78:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110df7c:	010000c4 	movi	r4,3
8110df80:	110e0900 	call	8110e090 <uliSyncReadReg>
8110df84:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110df88:	e0bfff17 	ldw	r2,-4(fp)
8110df8c:	1080004c 	andi	r2,r2,1
8110df90:	10000326 	beq	r2,zero,8110dfa0 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110df94:	00800044 	movi	r2,1
8110df98:	e0bffe15 	stw	r2,-8(fp)
8110df9c:	00000106 	br	8110dfa4 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110dfa0:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110dfa4:	e0bffe17 	ldw	r2,-8(fp)
}
8110dfa8:	e037883a 	mov	sp,fp
8110dfac:	dfc00117 	ldw	ra,4(sp)
8110dfb0:	df000017 	ldw	fp,0(sp)
8110dfb4:	dec00204 	addi	sp,sp,8
8110dfb8:	f800283a 	ret

8110dfbc <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110dfbc:	defffd04 	addi	sp,sp,-12
8110dfc0:	de00012e 	bgeu	sp,et,8110dfc8 <uliSyncGetCtr+0xc>
8110dfc4:	003b68fa 	trap	3
8110dfc8:	dfc00215 	stw	ra,8(sp)
8110dfcc:	df000115 	stw	fp,4(sp)
8110dfd0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110dfd4:	01000284 	movi	r4,10
8110dfd8:	110e0900 	call	8110e090 <uliSyncReadReg>
8110dfdc:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110dfe0:	e0bfff17 	ldw	r2,-4(fp)
}
8110dfe4:	e037883a 	mov	sp,fp
8110dfe8:	dfc00117 	ldw	ra,4(sp)
8110dfec:	df000017 	ldw	fp,0(sp)
8110dff0:	dec00204 	addi	sp,sp,8
8110dff4:	f800283a 	ret

8110dff8 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110dff8:	defffd04 	addi	sp,sp,-12
8110dffc:	de00012e 	bgeu	sp,et,8110e004 <uliSyncReadStatus+0xc>
8110e000:	003b68fa 	trap	3
8110e004:	dfc00215 	stw	ra,8(sp)
8110e008:	df000115 	stw	fp,4(sp)
8110e00c:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110e010:	0009883a 	mov	r4,zero
8110e014:	110e0900 	call	8110e090 <uliSyncReadReg>
8110e018:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110e01c:	e0bfff17 	ldw	r2,-4(fp)
}
8110e020:	e037883a 	mov	sp,fp
8110e024:	dfc00117 	ldw	ra,4(sp)
8110e028:	df000017 	ldw	fp,0(sp)
8110e02c:	dec00204 	addi	sp,sp,8
8110e030:	f800283a 	ret

8110e034 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110e034:	defffc04 	addi	sp,sp,-16
8110e038:	de00012e 	bgeu	sp,et,8110e040 <bSyncWriteReg+0xc>
8110e03c:	003b68fa 	trap	3
8110e040:	df000315 	stw	fp,12(sp)
8110e044:	df000304 	addi	fp,sp,12
8110e048:	e13ffe15 	stw	r4,-8(fp)
8110e04c:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110e050:	00a00034 	movhi	r2,32768
8110e054:	10810004 	addi	r2,r2,1024
8110e058:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110e05c:	e0bffe17 	ldw	r2,-8(fp)
8110e060:	1085883a 	add	r2,r2,r2
8110e064:	1085883a 	add	r2,r2,r2
8110e068:	1007883a 	mov	r3,r2
8110e06c:	e0bffd17 	ldw	r2,-12(fp)
8110e070:	10c5883a 	add	r2,r2,r3
8110e074:	e0ffff17 	ldw	r3,-4(fp)
8110e078:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110e07c:	00800044 	movi	r2,1
}
8110e080:	e037883a 	mov	sp,fp
8110e084:	df000017 	ldw	fp,0(sp)
8110e088:	dec00104 	addi	sp,sp,4
8110e08c:	f800283a 	ret

8110e090 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110e090:	defffc04 	addi	sp,sp,-16
8110e094:	de00012e 	bgeu	sp,et,8110e09c <uliSyncReadReg+0xc>
8110e098:	003b68fa 	trap	3
8110e09c:	df000315 	stw	fp,12(sp)
8110e0a0:	df000304 	addi	fp,sp,12
8110e0a4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110e0a8:	00a00034 	movhi	r2,32768
8110e0ac:	10810004 	addi	r2,r2,1024
8110e0b0:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110e0b4:	e0bfff17 	ldw	r2,-4(fp)
8110e0b8:	1085883a 	add	r2,r2,r2
8110e0bc:	1085883a 	add	r2,r2,r2
8110e0c0:	1007883a 	mov	r3,r2
8110e0c4:	e0bffd17 	ldw	r2,-12(fp)
8110e0c8:	10c5883a 	add	r2,r2,r3
8110e0cc:	10800017 	ldw	r2,0(r2)
8110e0d0:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110e0d4:	e0bffe17 	ldw	r2,-8(fp)
}
8110e0d8:	e037883a 	mov	sp,fp
8110e0dc:	df000017 	ldw	fp,0(sp)
8110e0e0:	dec00104 	addi	sp,sp,4
8110e0e4:	f800283a 	ret

8110e0e8 <uliPerCalcPeriodMs>:

/*
 * Return the necessary PER value for a
 * Sync Signal period in usiPeriodMs ms.
 */
alt_u32 uliPerCalcPeriodMs(alt_u16 usiPeriodMs) {
8110e0e8:	defffc04 	addi	sp,sp,-16
8110e0ec:	de00012e 	bgeu	sp,et,8110e0f4 <uliPerCalcPeriodMs+0xc>
8110e0f0:	003b68fa 	trap	3
8110e0f4:	dfc00315 	stw	ra,12(sp)
8110e0f8:	df000215 	stw	fp,8(sp)
8110e0fc:	df000204 	addi	fp,sp,8
8110e100:	2005883a 	mov	r2,r4
8110e104:	e0bfff0d 	sth	r2,-4(fp)
	 * Period[ms] / 20e-6 = Period[ms] * 5e+4
	 * PER = Period[ms] * 5e+4
	 */

	alt_u32 uliPer;
	uliPer = usiPeriodMs * 5e+4;
8110e108:	e0bfff0b 	ldhu	r2,-4(fp)
8110e10c:	1009883a 	mov	r4,r2
8110e110:	1122d240 	call	81122d24 <__floatsidf>
8110e114:	1011883a 	mov	r8,r2
8110e118:	1813883a 	mov	r9,r3
8110e11c:	000d883a 	mov	r6,zero
8110e120:	01d03a34 	movhi	r7,16616
8110e124:	39da8004 	addi	r7,r7,27136
8110e128:	4009883a 	mov	r4,r8
8110e12c:	480b883a 	mov	r5,r9
8110e130:	1121c800 	call	81121c80 <__muldf3>
8110e134:	1009883a 	mov	r4,r2
8110e138:	180b883a 	mov	r5,r3
8110e13c:	2005883a 	mov	r2,r4
8110e140:	2807883a 	mov	r3,r5
8110e144:	1009883a 	mov	r4,r2
8110e148:	180b883a 	mov	r5,r3
8110e14c:	11210b80 	call	811210b8 <__fixunsdfsi>
8110e150:	e0bffe15 	stw	r2,-8(fp)

	return uliPer;
8110e154:	e0bffe17 	ldw	r2,-8(fp)
}
8110e158:	e037883a 	mov	sp,fp
8110e15c:	dfc00117 	ldw	ra,4(sp)
8110e160:	df000017 	ldw	fp,0(sp)
8110e164:	dec00204 	addi	sp,sp,8
8110e168:	f800283a 	ret

8110e16c <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110e16c:	defff804 	addi	sp,sp,-32
8110e170:	de00012e 	bgeu	sp,et,8110e178 <vDataControlTask+0xc>
8110e174:	003b68fa 	trap	3
8110e178:	dfc00715 	stw	ra,28(sp)
8110e17c:	df000615 	stw	fp,24(sp)
8110e180:	df000604 	addi	fp,sp,24
8110e184:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110e188:	e0bffd17 	ldw	r2,-12(fp)
8110e18c:	e0bffa15 	stw	r2,-24(fp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110e190:	00a045f4 	movhi	r2,33047
8110e194:	10a25304 	addi	r2,r2,-30388
8110e198:	10800a8b 	ldhu	r2,42(r2)
8110e19c:	10bfffcc 	andi	r2,r2,65535
8110e1a0:	10800168 	cmpgeui	r2,r2,5
8110e1a4:	1000071e 	bne	r2,zero,8110e1c4 <vDataControlTask+0x58>
        debug(fp,"Data Controller Task. (Task on)\n");
8110e1a8:	d0a06217 	ldw	r2,-32376(gp)
8110e1ac:	100f883a 	mov	r7,r2
8110e1b0:	01800804 	movi	r6,32
8110e1b4:	01400044 	movi	r5,1
8110e1b8:	01204574 	movhi	r4,33045
8110e1bc:	21389c04 	addi	r4,r4,-7568
8110e1c0:	112393c0 	call	8112393c <fwrite>
	}
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110e1c4:	e0bffa17 	ldw	r2,-24(fp)
8110e1c8:	00c00044 	movi	r3,1
8110e1cc:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110e1d0:	d0a05f17 	ldw	r2,-32388(gp)
8110e1d4:	1009883a 	mov	r4,r2
8110e1d8:	113f7a40 	call	8113f7a4 <OSQFlush>
8110e1dc:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110e1e0:	e0bffc03 	ldbu	r2,-16(fp)
8110e1e4:	10803fcc 	andi	r2,r2,255
8110e1e8:	10000126 	beq	r2,zero,8110e1f0 <vDataControlTask+0x84>
		vFailFlushQueueData();
8110e1ec:	111f3dc0 	call	8111f3dc <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskDataCtrl, 0, &error_code); /* Blocking operation */
8110e1f0:	d0a05f17 	ldw	r2,-32388(gp)
8110e1f4:	e0fffc04 	addi	r3,fp,-16
8110e1f8:	180d883a 	mov	r6,r3
8110e1fc:	000b883a 	mov	r5,zero
8110e200:	1009883a 	mov	r4,r2
8110e204:	113f8640 	call	8113f864 <OSQPend>
8110e208:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110e20c:	000f883a 	mov	r7,zero
8110e210:	01800144 	movi	r6,5
8110e214:	000b883a 	mov	r5,zero
8110e218:	0009883a 	mov	r4,zero
8110e21c:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
	}
8110e220:	003ff306 	br	8110e1f0 <__reset+0xfb0ee1f0>

8110e224 <vFeeTask>:

const char *cTemp[64];
unsigned char ucIterationSide;


void vFeeTask(void *task_data) {
8110e224:	defff204 	addi	sp,sp,-56
8110e228:	de00012e 	bgeu	sp,et,8110e230 <vFeeTask+0xc>
8110e22c:	003b68fa 	trap	3
8110e230:	dfc00d15 	stw	ra,52(sp)
8110e234:	df000c15 	stw	fp,48(sp)
8110e238:	df000c04 	addi	fp,sp,48
8110e23c:	e13fff15 	stw	r4,-4(fp)
	bool bFinal;
	alt_u16 *pusiHK;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
8110e240:	e0bfff17 	ldw	r2,-4(fp)
8110e244:	d0a05315 	stw	r2,-32436(gp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110e248:	00a045f4 	movhi	r2,33047
8110e24c:	10a25304 	addi	r2,r2,-30388
8110e250:	10800a8b 	ldhu	r2,42(r2)
8110e254:	10bfffcc 	andi	r2,r2,65535
8110e258:	10800168 	cmpgeui	r2,r2,5
8110e25c:	1000091e 	bne	r2,zero,8110e284 <vFeeTask+0x60>
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110e260:	d0e06217 	ldw	r3,-32376(gp)
8110e264:	d0a05317 	ldw	r2,-32436(gp)
8110e268:	10800003 	ldbu	r2,0(r2)
8110e26c:	10803fcc 	andi	r2,r2,255
8110e270:	100d883a 	mov	r6,r2
8110e274:	01604574 	movhi	r5,33045
8110e278:	2978a504 	addi	r5,r5,-7532
8110e27c:	1809883a 	mov	r4,r3
8110e280:	11232a00 	call	811232a0 <fprintf>
	}
	#endif

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110e284:	00a045f4 	movhi	r2,33047
8110e288:	10a25304 	addi	r2,r2,-30388
8110e28c:	10800a8b 	ldhu	r2,42(r2)
8110e290:	10bfffcc 	andi	r2,r2,65535
8110e294:	108000e8 	cmpgeui	r2,r2,3
8110e298:	1000031e 	bne	r2,zero,8110e2a8 <vFeeTask+0x84>
		vPrintConsoleNFee( pxNFee );
8110e29c:	d0a05317 	ldw	r2,-32436(gp)
8110e2a0:	1009883a 	mov	r4,r2
8110e2a4:	11118fc0 	call	811118fc <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110e2a8:	d0a05317 	ldw	r2,-32436(gp)
8110e2ac:	10802c17 	ldw	r2,176(r2)
8110e2b0:	10c00368 	cmpgeui	r3,r2,13
8110e2b4:	1805b91e 	bne	r3,zero,8110f99c <vFeeTask+0x1778>
8110e2b8:	100690ba 	slli	r3,r2,2
8110e2bc:	00a04474 	movhi	r2,33041
8110e2c0:	10b8b404 	addi	r2,r2,-7472
8110e2c4:	1885883a 	add	r2,r3,r2
8110e2c8:	10800017 	ldw	r2,0(r2)
8110e2cc:	1000683a 	jmp	r2
8110e2d0:	8110e304 	addi	r4,r16,17292
8110e2d4:	8110eb10 	cmplti	r4,r16,17324
8110e2d8:	8110ebac 	andhi	r4,r16,17326
8110e2dc:	8110ed24 	muli	r4,r16,17332
8110e2e0:	8110f498 	cmpnei	r4,r16,17362
8110e2e4:	8110e930 	cmpltui	r4,r16,17316
8110e2e8:	8110ebbc 	xorhi	r4,r16,17326
8110e2ec:	8110f370 	cmpltui	r4,r16,17357
8110e2f0:	8110f99c 	xori	r4,r16,17382
8110e2f4:	8110f99c 	xori	r4,r16,17382
8110e2f8:	8110edc0 	call	88110edc <__reset+0x20f0edc>
8110e2fc:	8110f7a8 	cmpgeui	r4,r16,17374
8110e300:	8110f8c4 	addi	r4,r16,17379
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110e304:	d0a05317 	ldw	r2,-32436(gp)
8110e308:	10800003 	ldbu	r2,0(r2)
8110e30c:	10803fcc 	andi	r2,r2,255
8110e310:	1085883a 	add	r2,r2,r2
8110e314:	1087883a 	add	r3,r2,r2
8110e318:	d0a06a04 	addi	r2,gp,-32344
8110e31c:	1885883a 	add	r2,r3,r2
8110e320:	10800017 	ldw	r2,0(r2)
8110e324:	1009883a 	mov	r4,r2
8110e328:	113f7a40 	call	8113f7a4 <OSQFlush>
8110e32c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e330:	e0bffd03 	ldbu	r2,-12(fp)
8110e334:	10803fcc 	andi	r2,r2,255
8110e338:	10000126 	beq	r2,zero,8110e340 <vFeeTask+0x11c>
					vFailFlushNFEEQueue();
8110e33c:	111f4a40 	call	8111f4a4 <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e340:	d0a05317 	ldw	r2,-32436(gp)
8110e344:	10800003 	ldbu	r2,0(r2)
8110e348:	10803fcc 	andi	r2,r2,255
8110e34c:	1085883a 	add	r2,r2,r2
8110e350:	1087883a 	add	r3,r2,r2
8110e354:	d0a05c04 	addi	r2,gp,-32400
8110e358:	1885883a 	add	r2,r3,r2
8110e35c:	10800017 	ldw	r2,0(r2)
8110e360:	1009883a 	mov	r4,r2
8110e364:	113f7a40 	call	8113f7a4 <OSQFlush>
8110e368:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e36c:	e0bffd03 	ldbu	r2,-12(fp)
8110e370:	10803fcc 	andi	r2,r2,255
8110e374:	10000126 	beq	r2,zero,8110e37c <vFeeTask+0x158>
					vFailFlushNFEEQueue();
8110e378:	111f4a40 	call	8111f4a4 <vFailFlushNFEEQueue>
				}				

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e37c:	d0a05317 	ldw	r2,-32436(gp)
8110e380:	10803304 	addi	r2,r2,204
8110e384:	1009883a 	mov	r4,r2
8110e388:	1104bb00 	call	81104bb0 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth + pxNFee->xCcdInfo.usiSPrescanN + pxNFee->xCcdInfo.usiSOverscanN;
8110e38c:	d0a05317 	ldw	r2,-32436(gp)
8110e390:	d0e05317 	ldw	r3,-32436(gp)
8110e394:	1900308b 	ldhu	r4,194(r3)
8110e398:	d0e05317 	ldw	r3,-32436(gp)
8110e39c:	18c02f0b 	ldhu	r3,188(r3)
8110e3a0:	20c7883a 	add	r3,r4,r3
8110e3a4:	1809883a 	mov	r4,r3
8110e3a8:	d0e05317 	ldw	r3,-32436(gp)
8110e3ac:	18c02f8b 	ldhu	r3,190(r3)
8110e3b0:	20c7883a 	add	r3,r4,r3
8110e3b4:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight + pxNFee->xCcdInfo.usiOLN;
8110e3b8:	d0a05317 	ldw	r2,-32436(gp)
8110e3bc:	d0e05317 	ldw	r3,-32436(gp)
8110e3c0:	1900310b 	ldhu	r4,196(r3)
8110e3c4:	d0e05317 	ldw	r3,-32436(gp)
8110e3c8:	18c0300b 	ldhu	r3,192(r3)
8110e3cc:	20c7883a 	add	r3,r4,r3
8110e3d0:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight;
8110e3d4:	d0a05317 	ldw	r2,-32436(gp)
8110e3d8:	d0e05317 	ldw	r3,-32436(gp)
8110e3dc:	18c0310b 	ldhu	r3,196(r3)
8110e3e0:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8110e3e4:	d0a05317 	ldw	r2,-32436(gp)
8110e3e8:	d0e05317 	ldw	r3,-32436(gp)
8110e3ec:	18c0300b 	ldhu	r3,192(r3)
8110e3f0:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8110e3f4:	d0a05317 	ldw	r2,-32436(gp)
8110e3f8:	00e00004 	movi	r3,-32768
8110e3fc:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8110e400:	d0a05317 	ldw	r2,-32436(gp)
8110e404:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
8110e408:	d0a05317 	ldw	r2,-32436(gp)
8110e40c:	10003685 	stb	zero,218(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucProtocolId = xDefaults.usiDataProtId; /* 0xF0 ou  0x02*/
8110e410:	d0e05317 	ldw	r3,-32436(gp)
8110e414:	00a045f4 	movhi	r2,33047
8110e418:	10a25304 	addi	r2,r2,-30388
8110e41c:	10800c0b 	ldhu	r2,48(r2)
8110e420:	18803705 	stb	r2,220(r3)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucLogicalAddr = xDefaults.usiDpuLogicalAddr;
8110e424:	d0e05317 	ldw	r3,-32436(gp)
8110e428:	00a045f4 	movhi	r2,33047
8110e42c:	10a25304 	addi	r2,r2,-30388
8110e430:	10800c8b 	ldhu	r2,50(r2)
8110e434:	18803745 	stb	r2,221(r3)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e438:	d0a05317 	ldw	r2,-32436(gp)
8110e43c:	10803304 	addi	r2,r2,204
8110e440:	1009883a 	mov	r4,r2
8110e444:	110490c0 	call	8110490c <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110e448:	d0a05317 	ldw	r2,-32436(gp)
8110e44c:	10804504 	addi	r2,r2,276
8110e450:	1009883a 	mov	r4,r2
8110e454:	1109a6c0 	call	81109a6c <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
8110e458:	d0a05317 	ldw	r2,-32436(gp)
8110e45c:	00ffc004 	movi	r3,-256
8110e460:	10c06b0d 	sth	r3,428(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
8110e464:	d0a05317 	ldw	r2,-32436(gp)
8110e468:	00ffc044 	movi	r3,-255
8110e46c:	10c06b8d 	sth	r3,430(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
8110e470:	d0a05317 	ldw	r2,-32436(gp)
8110e474:	00ffc084 	movi	r3,-254
8110e478:	10c06c0d 	sth	r3,432(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
8110e47c:	d0a05317 	ldw	r2,-32436(gp)
8110e480:	00ffc0c4 	movi	r3,-253
8110e484:	10c06c8d 	sth	r3,434(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
8110e488:	d0a05317 	ldw	r2,-32436(gp)
8110e48c:	00ffc104 	movi	r3,-252
8110e490:	10c06d0d 	sth	r3,436(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
8110e494:	d0a05317 	ldw	r2,-32436(gp)
8110e498:	00ffc144 	movi	r3,-251
8110e49c:	10c06d8d 	sth	r3,438(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
8110e4a0:	d0a05317 	ldw	r2,-32436(gp)
8110e4a4:	00ffc184 	movi	r3,-250
8110e4a8:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
8110e4ac:	d0a05317 	ldw	r2,-32436(gp)
8110e4b0:	00ffc1c4 	movi	r3,-249
8110e4b4:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
8110e4b8:	d0a05317 	ldw	r2,-32436(gp)
8110e4bc:	00ffc204 	movi	r3,-248
8110e4c0:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
8110e4c4:	d0a05317 	ldw	r2,-32436(gp)
8110e4c8:	00ffc244 	movi	r3,-247
8110e4cc:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
8110e4d0:	d0a05317 	ldw	r2,-32436(gp)
8110e4d4:	00ffc284 	movi	r3,-246
8110e4d8:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
8110e4dc:	d0a05317 	ldw	r2,-32436(gp)
8110e4e0:	00ffc2c4 	movi	r3,-245
8110e4e4:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
8110e4e8:	d0a05317 	ldw	r2,-32436(gp)
8110e4ec:	00ffc304 	movi	r3,-244
8110e4f0:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
8110e4f4:	d0a05317 	ldw	r2,-32436(gp)
8110e4f8:	00ffc344 	movi	r3,-243
8110e4fc:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
8110e500:	d0a05317 	ldw	r2,-32436(gp)
8110e504:	00ffc384 	movi	r3,-242
8110e508:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
8110e50c:	d0a05317 	ldw	r2,-32436(gp)
8110e510:	00ffc3c4 	movi	r3,-241
8110e514:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
8110e518:	d0a05317 	ldw	r2,-32436(gp)
8110e51c:	00ffc404 	movi	r3,-240
8110e520:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
8110e524:	d0a05317 	ldw	r2,-32436(gp)
8110e528:	00ffc444 	movi	r3,-239
8110e52c:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
8110e530:	d0a05317 	ldw	r2,-32436(gp)
8110e534:	00ffc484 	movi	r3,-238
8110e538:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
8110e53c:	d0a05317 	ldw	r2,-32436(gp)
8110e540:	00ffc4c4 	movi	r3,-237
8110e544:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
8110e548:	d0a05317 	ldw	r2,-32436(gp)
8110e54c:	00ffc504 	movi	r3,-236
8110e550:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
8110e554:	d0a05317 	ldw	r2,-32436(gp)
8110e558:	00ffc544 	movi	r3,-235
8110e55c:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
8110e560:	d0a05317 	ldw	r2,-32436(gp)
8110e564:	00ffc584 	movi	r3,-234
8110e568:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
8110e56c:	d0a05317 	ldw	r2,-32436(gp)
8110e570:	00ffc5c4 	movi	r3,-233
8110e574:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
8110e578:	d0a05317 	ldw	r2,-32436(gp)
8110e57c:	00ffc604 	movi	r3,-232
8110e580:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
8110e584:	d0a05317 	ldw	r2,-32436(gp)
8110e588:	00ffc644 	movi	r3,-231
8110e58c:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
8110e590:	d0a05317 	ldw	r2,-32436(gp)
8110e594:	00ffc684 	movi	r3,-230
8110e598:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
8110e59c:	d0a05317 	ldw	r2,-32436(gp)
8110e5a0:	00ffc6c4 	movi	r3,-229
8110e5a4:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
8110e5a8:	d0a05317 	ldw	r2,-32436(gp)
8110e5ac:	00ffc704 	movi	r3,-228
8110e5b0:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
8110e5b4:	d0a05317 	ldw	r2,-32436(gp)
8110e5b8:	00ffc744 	movi	r3,-227
8110e5bc:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
8110e5c0:	d0a05317 	ldw	r2,-32436(gp)
8110e5c4:	00ffc784 	movi	r3,-226
8110e5c8:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
8110e5cc:	d0a05317 	ldw	r2,-32436(gp)
8110e5d0:	00ffc7c4 	movi	r3,-225
8110e5d4:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
8110e5d8:	d0a05317 	ldw	r2,-32436(gp)
8110e5dc:	00ffc804 	movi	r3,-224
8110e5e0:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
8110e5e4:	d0a05317 	ldw	r2,-32436(gp)
8110e5e8:	00ffc844 	movi	r3,-223
8110e5ec:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
8110e5f0:	d0a05317 	ldw	r2,-32436(gp)
8110e5f4:	00ffc884 	movi	r3,-222
8110e5f8:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
8110e5fc:	d0a05317 	ldw	r2,-32436(gp)
8110e600:	00ffc8c4 	movi	r3,-221
8110e604:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
8110e608:	d0a05317 	ldw	r2,-32436(gp)
8110e60c:	00ffc904 	movi	r3,-220
8110e610:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
8110e614:	d0a05317 	ldw	r2,-32436(gp)
8110e618:	00ffc944 	movi	r3,-219
8110e61c:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
8110e620:	d0a05317 	ldw	r2,-32436(gp)
8110e624:	00ffc984 	movi	r3,-218
8110e628:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
8110e62c:	d0a05317 	ldw	r2,-32436(gp)
8110e630:	00ffc9c4 	movi	r3,-217
8110e634:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
8110e638:	d0a05317 	ldw	r2,-32436(gp)
8110e63c:	00ffca04 	movi	r3,-216
8110e640:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
8110e644:	d0a05317 	ldw	r2,-32436(gp)
8110e648:	00ffca44 	movi	r3,-215
8110e64c:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
8110e650:	d0a05317 	ldw	r2,-32436(gp)
8110e654:	00ffca84 	movi	r3,-214
8110e658:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
8110e65c:	d0a05317 	ldw	r2,-32436(gp)
8110e660:	00ffcac4 	movi	r3,-213
8110e664:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
8110e668:	d0a05317 	ldw	r2,-32436(gp)
8110e66c:	00ffcb04 	movi	r3,-212
8110e670:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
8110e674:	d0a05317 	ldw	r2,-32436(gp)
8110e678:	00ffcb44 	movi	r3,-211
8110e67c:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
8110e680:	d0a05317 	ldw	r2,-32436(gp)
8110e684:	00ffcb84 	movi	r3,-210
8110e688:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
8110e68c:	d0a05317 	ldw	r2,-32436(gp)
8110e690:	00ffcbc4 	movi	r3,-209
8110e694:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
8110e698:	d0a05317 	ldw	r2,-32436(gp)
8110e69c:	00ffcc04 	movi	r3,-208
8110e6a0:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
8110e6a4:	d0a05317 	ldw	r2,-32436(gp)
8110e6a8:	00ffcc44 	movi	r3,-207
8110e6ac:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
8110e6b0:	d0a05317 	ldw	r2,-32436(gp)
8110e6b4:	00ffcc84 	movi	r3,-206
8110e6b8:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
8110e6bc:	d0a05317 	ldw	r2,-32436(gp)
8110e6c0:	00ffccc4 	movi	r3,-205
8110e6c4:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
8110e6c8:	d0a05317 	ldw	r2,-32436(gp)
8110e6cc:	00ffcd04 	movi	r3,-204
8110e6d0:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
8110e6d4:	d0a05317 	ldw	r2,-32436(gp)
8110e6d8:	00ffcd44 	movi	r3,-203
8110e6dc:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
8110e6e0:	d0a05317 	ldw	r2,-32436(gp)
8110e6e4:	00ffcd84 	movi	r3,-202
8110e6e8:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
8110e6ec:	d0a05317 	ldw	r2,-32436(gp)
8110e6f0:	00ffcdc4 	movi	r3,-201
8110e6f4:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
8110e6f8:	d0a05317 	ldw	r2,-32436(gp)
8110e6fc:	00ffce04 	movi	r3,-200
8110e700:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
8110e704:	d0a05317 	ldw	r2,-32436(gp)
8110e708:	00ffce44 	movi	r3,-199
8110e70c:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
8110e710:	d0a05317 	ldw	r2,-32436(gp)
8110e714:	00ffce84 	movi	r3,-198
8110e718:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
8110e71c:	d0a05317 	ldw	r2,-32436(gp)
8110e720:	00ffcec4 	movi	r3,-197
8110e724:	10c0888d 	sth	r3,546(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
8110e728:	d0a05317 	ldw	r2,-32436(gp)
8110e72c:	00ffcf04 	movi	r3,-196
8110e730:	10c0890d 	sth	r3,548(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
8110e734:	d0a05317 	ldw	r2,-32436(gp)
8110e738:	00ffcf44 	movi	r3,-195
8110e73c:	10c0898d 	sth	r3,550(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
8110e740:	d0a05317 	ldw	r2,-32436(gp)
8110e744:	00ffcf84 	movi	r3,-194
8110e748:	10c08a0d 	sth	r3,552(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
8110e74c:	d0a05317 	ldw	r2,-32436(gp)
8110e750:	00ffcfc4 	movi	r3,-193
8110e754:	10c08a8d 	sth	r3,554(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110e758:	d0a05317 	ldw	r2,-32436(gp)
8110e75c:	10804504 	addi	r2,r2,276
8110e760:	1009883a 	mov	r4,r2
8110e764:	11089a00 	call	811089a0 <bRmapSetRmapMemHKArea>


				vLoadCtemp();
8110e768:	11126500 	call	81112650 <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110e76c:	d0a05317 	ldw	r2,-32436(gp)
8110e770:	10804504 	addi	r2,r2,276
8110e774:	1009883a 	mov	r4,r2
8110e778:	1109a6c0 	call	81109a6c <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
8110e77c:	d0a05317 	ldw	r2,-32436(gp)
8110e780:	10806b04 	addi	r2,r2,428
8110e784:	e0bffa15 	stw	r2,-24(fp)

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110e788:	00a045f4 	movhi	r2,33047
8110e78c:	10a25304 	addi	r2,r2,-30388
8110e790:	10800a8b 	ldhu	r2,42(r2)
8110e794:	10bfffcc 	andi	r2,r2,65535
8110e798:	108000e8 	cmpgeui	r2,r2,3
8110e79c:	1000291e 	bne	r2,zero,8110e844 <vFeeTask+0x620>
					fprintf(fp,"\n\n================= H  K ==================\n");
8110e7a0:	d0a06217 	ldw	r2,-32376(gp)
8110e7a4:	100f883a 	mov	r7,r2
8110e7a8:	01800b04 	movi	r6,44
8110e7ac:	01400044 	movi	r5,1
8110e7b0:	01204574 	movhi	r4,33045
8110e7b4:	2138ac04 	addi	r4,r4,-7504
8110e7b8:	112393c0 	call	8112393c <fwrite>
					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110e7bc:	e03ffb05 	stb	zero,-20(fp)
8110e7c0:	00001606 	br	8110e81c <vFeeTask+0x5f8>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
8110e7c4:	d1206217 	ldw	r4,-32376(gp)
8110e7c8:	e0fffb03 	ldbu	r3,-20(fp)
8110e7cc:	00a04574 	movhi	r2,33045
8110e7d0:	1095f304 	addi	r2,r2,22476
8110e7d4:	18c7883a 	add	r3,r3,r3
8110e7d8:	18c7883a 	add	r3,r3,r3
8110e7dc:	10c5883a 	add	r2,r2,r3
8110e7e0:	10c00017 	ldw	r3,0(r2)
8110e7e4:	e0bffa17 	ldw	r2,-24(fp)
8110e7e8:	1080000b 	ldhu	r2,0(r2)
8110e7ec:	10bfffcc 	andi	r2,r2,65535
8110e7f0:	100f883a 	mov	r7,r2
8110e7f4:	180d883a 	mov	r6,r3
8110e7f8:	01604574 	movhi	r5,33045
8110e7fc:	2978b804 	addi	r5,r5,-7456
8110e800:	11232a00 	call	811232a0 <fprintf>
						pusiHK++;
8110e804:	e0bffa17 	ldw	r2,-24(fp)
8110e808:	10800084 	addi	r2,r2,2
8110e80c:	e0bffa15 	stw	r2,-24(fp)
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
					fprintf(fp,"\n\n================= H  K ==================\n");
					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110e810:	e0bffb03 	ldbu	r2,-20(fp)
8110e814:	10800044 	addi	r2,r2,1
8110e818:	e0bffb05 	stb	r2,-20(fp)
8110e81c:	e0bffb03 	ldbu	r2,-20(fp)
8110e820:	10801030 	cmpltui	r2,r2,64
8110e824:	103fe71e 	bne	r2,zero,8110e7c4 <__reset+0xfb0ee7c4>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
						pusiHK++;
					}
					fprintf(fp,"\n================= H  K ==================\n\n");
8110e828:	d0a06217 	ldw	r2,-32376(gp)
8110e82c:	100f883a 	mov	r7,r2
8110e830:	01800b04 	movi	r6,44
8110e834:	01400044 	movi	r5,1
8110e838:	01204574 	movhi	r4,33045
8110e83c:	2138bd04 	addi	r4,r4,-7436
8110e840:	112393c0 	call	8112393c <fwrite>
				}
				#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
8110e844:	d0a05317 	ldw	r2,-32436(gp)
8110e848:	10804504 	addi	r2,r2,276
8110e84c:	1009883a 	mov	r4,r2
8110e850:	1107fb80 	call	81107fb8 <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
8110e854:	d0e05317 	ldw	r3,-32436(gp)
8110e858:	00a045f4 	movhi	r2,33047
8110e85c:	10a25304 	addi	r2,r2,-30388
8110e860:	1080080b 	ldhu	r2,32(r2)
8110e864:	18804605 	stb	r2,280(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
8110e868:	d0e05317 	ldw	r3,-32436(gp)
8110e86c:	00a045f4 	movhi	r2,33047
8110e870:	10a25304 	addi	r2,r2,-30388
8110e874:	1080088b 	ldhu	r2,34(r2)
8110e878:	18804645 	stb	r2,281(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
8110e87c:	d0a05317 	ldw	r2,-32436(gp)
8110e880:	10804504 	addi	r2,r2,276
8110e884:	1009883a 	mov	r4,r2
8110e888:	1107edc0 	call	81107edc <bRmapSetCodecConfig>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110e88c:	00a045f4 	movhi	r2,33047
8110e890:	10a25304 	addi	r2,r2,-30388
8110e894:	10800a8b 	ldhu	r2,42(r2)
8110e898:	10bfffcc 	andi	r2,r2,65535
8110e89c:	108000e8 	cmpgeui	r2,r2,3
8110e8a0:	10001c1e 	bne	r2,zero,8110e914 <vFeeTask+0x6f0>
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", pxNFee->ucId ,xDefaults.ucRmapKey );
8110e8a4:	d0e06217 	ldw	r3,-32376(gp)
8110e8a8:	d0a05317 	ldw	r2,-32436(gp)
8110e8ac:	10800003 	ldbu	r2,0(r2)
8110e8b0:	11003fcc 	andi	r4,r2,255
8110e8b4:	00a045f4 	movhi	r2,33047
8110e8b8:	10a25304 	addi	r2,r2,-30388
8110e8bc:	1080080b 	ldhu	r2,32(r2)
8110e8c0:	10bfffcc 	andi	r2,r2,65535
8110e8c4:	100f883a 	mov	r7,r2
8110e8c8:	200d883a 	mov	r6,r4
8110e8cc:	01604574 	movhi	r5,33045
8110e8d0:	2978c904 	addi	r5,r5,-7388
8110e8d4:	1809883a 	mov	r4,r3
8110e8d8:	11232a00 	call	811232a0 <fprintf>
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", pxNFee->ucId, xDefaults.ucLogicalAddr);
8110e8dc:	d0e06217 	ldw	r3,-32376(gp)
8110e8e0:	d0a05317 	ldw	r2,-32436(gp)
8110e8e4:	10800003 	ldbu	r2,0(r2)
8110e8e8:	11003fcc 	andi	r4,r2,255
8110e8ec:	00a045f4 	movhi	r2,33047
8110e8f0:	10a25304 	addi	r2,r2,-30388
8110e8f4:	1080088b 	ldhu	r2,34(r2)
8110e8f8:	10bfffcc 	andi	r2,r2,65535
8110e8fc:	100f883a 	mov	r7,r2
8110e900:	200d883a 	mov	r6,r4
8110e904:	01604574 	movhi	r5,33045
8110e908:	2978d104 	addi	r5,r5,-7356
8110e90c:	1809883a 	mov	r4,r3
8110e910:	11232a00 	call	811232a0 <fprintf>
				}
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
8110e914:	d0a05317 	ldw	r2,-32436(gp)
8110e918:	00c00144 	movi	r3,5
8110e91c:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e920:	d0a05317 	ldw	r2,-32436(gp)
8110e924:	10802e17 	ldw	r2,184(r2)
8110e928:	d0a05605 	stb	r2,-32424(gp)

				break;
8110e92c:	00043906 	br	8110fa14 <vFeeTask+0x17f0>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e930:	d0a05317 	ldw	r2,-32436(gp)
8110e934:	10804504 	addi	r2,r2,276
8110e938:	1009883a 	mov	r4,r2
8110e93c:	11086380 	call	81108638 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8110e940:	d0a05317 	ldw	r2,-32436(gp)
8110e944:	00c00184 	movi	r3,6
8110e948:	10c06815 	stw	r3,416(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e94c:	d0a05317 	ldw	r2,-32436(gp)
8110e950:	10804504 	addi	r2,r2,276
8110e954:	1009883a 	mov	r4,r2
8110e958:	11083040 	call	81108304 <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e95c:	d0a05317 	ldw	r2,-32436(gp)
8110e960:	10808b04 	addi	r2,r2,556
8110e964:	1009883a 	mov	r4,r2
8110e968:	11115f00 	call	811115f0 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110e96c:	d0a05317 	ldw	r2,-32436(gp)
8110e970:	10002615 	stw	zero,152(r2)

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucSPWId);
8110e974:	d0a05317 	ldw	r2,-32436(gp)
8110e978:	10c04504 	addi	r3,r2,276
8110e97c:	d0a05317 	ldw	r2,-32436(gp)
8110e980:	10800043 	ldbu	r2,1(r2)
8110e984:	10803fcc 	andi	r2,r2,255
8110e988:	100b883a 	mov	r5,r2
8110e98c:	1809883a 	mov	r4,r3
8110e990:	11115440 	call	81111544 <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e994:	d0a05317 	ldw	r2,-32436(gp)
8110e998:	10803b04 	addi	r2,r2,236
8110e99c:	1009883a 	mov	r4,r2
8110e9a0:	11117480 	call	81111748 <bDisAndClrDbBuffer>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110e9a4:	00a045f4 	movhi	r2,33047
8110e9a8:	10a25304 	addi	r2,r2,-30388
8110e9ac:	10800a8b 	ldhu	r2,42(r2)
8110e9b0:	10bfffcc 	andi	r2,r2,65535
8110e9b4:	10800168 	cmpgeui	r2,r2,5
8110e9b8:	1000091e 	bne	r2,zero,8110e9e0 <vFeeTask+0x7bc>
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110e9bc:	d0e06217 	ldw	r3,-32376(gp)
8110e9c0:	d0a05317 	ldw	r2,-32436(gp)
8110e9c4:	10800003 	ldbu	r2,0(r2)
8110e9c8:	10803fcc 	andi	r2,r2,255
8110e9cc:	100d883a 	mov	r6,r2
8110e9d0:	01604574 	movhi	r5,33045
8110e9d4:	2978da04 	addi	r5,r5,-7320
8110e9d8:	1809883a 	mov	r4,r3
8110e9dc:	11232a00 	call	811232a0 <fprintf>
				}
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110e9e0:	d0a05317 	ldw	r2,-32436(gp)
8110e9e4:	10802217 	ldw	r2,136(r2)
8110e9e8:	10800058 	cmpnei	r2,r2,1
8110e9ec:	10000a1e 	bne	r2,zero,8110ea18 <vFeeTask+0x7f4>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e9f0:	e0fff403 	ldbu	r3,-48(fp)
8110e9f4:	00a045b4 	movhi	r2,33046
8110e9f8:	10959704 	addi	r2,r2,22108
8110e9fc:	180690fa 	slli	r3,r3,3
8110ea00:	10c5883a 	add	r2,r2,r3
8110ea04:	10800017 	ldw	r2,0(r2)
8110ea08:	1009883a 	mov	r4,r2
8110ea0c:	113ecf40 	call	8113ecf4 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110ea10:	d0a05317 	ldw	r2,-32436(gp)
8110ea14:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110ea18:	d0a05317 	ldw	r2,-32436(gp)
8110ea1c:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110ea20:	d0a05317 	ldw	r2,-32436(gp)
8110ea24:	10800003 	ldbu	r2,0(r2)
8110ea28:	10803fcc 	andi	r2,r2,255
8110ea2c:	1085883a 	add	r2,r2,r2
8110ea30:	1087883a 	add	r3,r2,r2
8110ea34:	d0a05c04 	addi	r2,gp,-32400
8110ea38:	1885883a 	add	r2,r3,r2
8110ea3c:	10800017 	ldw	r2,0(r2)
8110ea40:	1009883a 	mov	r4,r2
8110ea44:	113f7a40 	call	8113f7a4 <OSQFlush>
8110ea48:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110ea4c:	e0bffd03 	ldbu	r2,-12(fp)
8110ea50:	10803fcc 	andi	r2,r2,255
8110ea54:	10000126 	beq	r2,zero,8110ea5c <vFeeTask+0x838>
					vFailFlushNFEEQueue();
8110ea58:	111f4a40 	call	8111f4a4 <vFailFlushNFEEQueue>
				}

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110ea5c:	d0a05317 	ldw	r2,-32436(gp)
8110ea60:	10800003 	ldbu	r2,0(r2)
8110ea64:	10803fcc 	andi	r2,r2,255
8110ea68:	100d883a 	mov	r6,r2
8110ea6c:	000b883a 	mov	r5,zero
8110ea70:	01002044 	movi	r4,129
8110ea74:	11118580 	call	81111858 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110ea78:	d0a05317 	ldw	r2,-32436(gp)
8110ea7c:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110ea80:	d0a05317 	ldw	r2,-32436(gp)
8110ea84:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110ea88:	d0a05317 	ldw	r2,-32436(gp)
8110ea8c:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110ea90:	d0a05317 	ldw	r2,-32436(gp)
8110ea94:	00c00044 	movi	r3,1
8110ea98:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
8110ea9c:	d0a05317 	ldw	r2,-32436(gp)
8110eaa0:	1009883a 	mov	r4,r2
8110eaa4:	111fb940 	call	8111fb94 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110eaa8:	d0a05317 	ldw	r2,-32436(gp)
8110eaac:	10800003 	ldbu	r2,0(r2)
8110eab0:	10803fcc 	andi	r2,r2,255
8110eab4:	1085883a 	add	r2,r2,r2
8110eab8:	1087883a 	add	r3,r2,r2
8110eabc:	d0a06a04 	addi	r2,gp,-32344
8110eac0:	1885883a 	add	r2,r3,r2
8110eac4:	10800017 	ldw	r2,0(r2)
8110eac8:	1009883a 	mov	r4,r2
8110eacc:	113f7a40 	call	8113f7a4 <OSQFlush>
8110ead0:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110ead4:	e0bffd03 	ldbu	r2,-12(fp)
8110ead8:	10803fcc 	andi	r2,r2,255
8110eadc:	10000126 	beq	r2,zero,8110eae4 <vFeeTask+0x8c0>
					vFailFlushNFEEQueue();
8110eae0:	111f4a40 	call	8111f4a4 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
8110eae4:	d0a05317 	ldw	r2,-32436(gp)
8110eae8:	00c00044 	movi	r3,1
8110eaec:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
8110eaf0:	d0a05317 	ldw	r2,-32436(gp)
8110eaf4:	00c00044 	movi	r3,1
8110eaf8:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110eafc:	d0a05317 	ldw	r2,-32436(gp)
8110eb00:	10802e17 	ldw	r2,184(r2)
8110eb04:	d0a05605 	stb	r2,-32424(gp)
				bFinal = FALSE;
8110eb08:	e03ff915 	stw	zero,-28(fp)
				break;
8110eb0c:	0003c106 	br	8110fa14 <vFeeTask+0x17f0>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110eb10:	d0a05317 	ldw	r2,-32436(gp)
8110eb14:	10800003 	ldbu	r2,0(r2)
8110eb18:	10803fcc 	andi	r2,r2,255
8110eb1c:	1085883a 	add	r2,r2,r2
8110eb20:	1087883a 	add	r3,r2,r2
8110eb24:	d0a06a04 	addi	r2,gp,-32344
8110eb28:	1885883a 	add	r2,r3,r2
8110eb2c:	10800017 	ldw	r2,0(r2)
8110eb30:	e0fffd04 	addi	r3,fp,-12
8110eb34:	180d883a 	mov	r6,r3
8110eb38:	000b883a 	mov	r5,zero
8110eb3c:	1009883a 	mov	r4,r2
8110eb40:	113f8640 	call	8113f864 <OSQPend>
8110eb44:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110eb48:	e0bffd03 	ldbu	r2,-12(fp)
8110eb4c:	10803fcc 	andi	r2,r2,255
8110eb50:	1000061e 	bne	r2,zero,8110eb6c <vFeeTask+0x948>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110eb54:	d0a05317 	ldw	r2,-32436(gp)
8110eb58:	e0fffe17 	ldw	r3,-8(fp)
8110eb5c:	180b883a 	mov	r5,r3
8110eb60:	1009883a 	mov	r4,r2
8110eb64:	110fc300 	call	8110fc30 <vQCmdFEEinConfig>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110eb68:	00039f06 	br	8110f9e8 <vFeeTask+0x17c4>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110eb6c:	00a045f4 	movhi	r2,33047
8110eb70:	10a25304 	addi	r2,r2,-30388
8110eb74:	10800a8b 	ldhu	r2,42(r2)
8110eb78:	10bfffcc 	andi	r2,r2,65535
8110eb7c:	10800228 	cmpgeui	r2,r2,8
8110eb80:	1003991e 	bne	r2,zero,8110f9e8 <vFeeTask+0x17c4>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110eb84:	d0e06217 	ldw	r3,-32376(gp)
8110eb88:	d0a05317 	ldw	r2,-32436(gp)
8110eb8c:	10800003 	ldbu	r2,0(r2)
8110eb90:	10803fcc 	andi	r2,r2,255
8110eb94:	100d883a 	mov	r6,r2
8110eb98:	01604574 	movhi	r5,33045
8110eb9c:	2978e104 	addi	r5,r5,-7292
8110eba0:	1809883a 	mov	r4,r3
8110eba4:	11232a00 	call	811232a0 <fprintf>
					}
					#endif
				}

				break;
8110eba8:	00038f06 	br	8110f9e8 <vFeeTask+0x17c4>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110ebac:	d0a05317 	ldw	r2,-32436(gp)
8110ebb0:	00c00184 	movi	r3,6
8110ebb4:	10c02c15 	stw	r3,176(r2)
				break;
8110ebb8:	00039606 	br	8110fa14 <vFeeTask+0x17f0>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ebbc:	d0a05317 	ldw	r2,-32436(gp)
8110ebc0:	10804504 	addi	r2,r2,276
8110ebc4:	1009883a 	mov	r4,r2
8110ebc8:	11086380 	call	81108638 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8110ebcc:	d0a05317 	ldw	r2,-32436(gp)
8110ebd0:	10006815 	stw	zero,416(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ebd4:	d0a05317 	ldw	r2,-32436(gp)
8110ebd8:	10804504 	addi	r2,r2,276
8110ebdc:	1009883a 	mov	r4,r2
8110ebe0:	11083040 	call	81108304 <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110ebe4:	d0a05317 	ldw	r2,-32436(gp)
8110ebe8:	10803b04 	addi	r2,r2,236
8110ebec:	1009883a 	mov	r4,r2
8110ebf0:	11117480 	call	81111748 <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110ebf4:	d0a05317 	ldw	r2,-32436(gp)
8110ebf8:	10c04504 	addi	r3,r2,276
8110ebfc:	d0a05317 	ldw	r2,-32436(gp)
8110ec00:	10800003 	ldbu	r2,0(r2)
8110ec04:	10803fcc 	andi	r2,r2,255
8110ec08:	100b883a 	mov	r5,r2
8110ec0c:	1809883a 	mov	r4,r3
8110ec10:	11115980 	call	81111598 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110ec14:	d0a05317 	ldw	r2,-32436(gp)
8110ec18:	10808b04 	addi	r2,r2,556
8110ec1c:	1009883a 	mov	r4,r2
8110ec20:	11116500 	call	81111650 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110ec24:	d0a05317 	ldw	r2,-32436(gp)
8110ec28:	00c00044 	movi	r3,1
8110ec2c:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.bSimulating = TRUE;
8110ec30:	d0a05317 	ldw	r2,-32436(gp)
8110ec34:	00c00044 	movi	r3,1
8110ec38:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110ec3c:	d0a05317 	ldw	r2,-32436(gp)
8110ec40:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110ec44:	d0a05317 	ldw	r2,-32436(gp)
8110ec48:	00c00044 	movi	r3,1
8110ec4c:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110ec50:	d0a05317 	ldw	r2,-32436(gp)
8110ec54:	10800003 	ldbu	r2,0(r2)
8110ec58:	10803fcc 	andi	r2,r2,255
8110ec5c:	100d883a 	mov	r6,r2
8110ec60:	000b883a 	mov	r5,zero
8110ec64:	01002044 	movi	r4,129
8110ec68:	11118580 	call	81111858 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110ec6c:	d0a05317 	ldw	r2,-32436(gp)
8110ec70:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110ec74:	d0a05317 	ldw	r2,-32436(gp)
8110ec78:	10800003 	ldbu	r2,0(r2)
8110ec7c:	10803fcc 	andi	r2,r2,255
8110ec80:	1085883a 	add	r2,r2,r2
8110ec84:	1087883a 	add	r3,r2,r2
8110ec88:	d0a05c04 	addi	r2,gp,-32400
8110ec8c:	1885883a 	add	r2,r3,r2
8110ec90:	10800017 	ldw	r2,0(r2)
8110ec94:	1009883a 	mov	r4,r2
8110ec98:	113f7a40 	call	8113f7a4 <OSQFlush>
8110ec9c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110eca0:	e0bffd03 	ldbu	r2,-12(fp)
8110eca4:	10803fcc 	andi	r2,r2,255
8110eca8:	10000126 	beq	r2,zero,8110ecb0 <vFeeTask+0xa8c>
					vFailFlushNFEEQueue();
8110ecac:	111f4a40 	call	8111f4a4 <vFailFlushNFEEQueue>
				}

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110ecb0:	00a045f4 	movhi	r2,33047
8110ecb4:	10a25304 	addi	r2,r2,-30388
8110ecb8:	10800a8b 	ldhu	r2,42(r2)
8110ecbc:	10bfffcc 	andi	r2,r2,65535
8110ecc0:	10800168 	cmpgeui	r2,r2,5
8110ecc4:	1000091e 	bne	r2,zero,8110ecec <vFeeTask+0xac8>
					fprintf(fp,"NFEE-%hu Task: Standby\n", pxNFee->ucId);
8110ecc8:	d0e06217 	ldw	r3,-32376(gp)
8110eccc:	d0a05317 	ldw	r2,-32436(gp)
8110ecd0:	10800003 	ldbu	r2,0(r2)
8110ecd4:	10803fcc 	andi	r2,r2,255
8110ecd8:	100d883a 	mov	r6,r2
8110ecdc:	01604574 	movhi	r5,33045
8110ece0:	2978ed04 	addi	r5,r5,-7244
8110ece4:	1809883a 	mov	r4,r3
8110ece8:	11232a00 	call	811232a0 <fprintf>
				}
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
8110ecec:	d0a05317 	ldw	r2,-32436(gp)
8110ecf0:	1009883a 	mov	r4,r2
8110ecf4:	111fb940 	call	8111fb94 <vResetMemCCDFEE>

				incrementador = 0;
8110ecf8:	d0205415 	stw	zero,-32432(gp)

				pxNFee->xControl.bWatingSync = TRUE;
8110ecfc:	d0a05317 	ldw	r2,-32436(gp)
8110ed00:	00c00044 	movi	r3,1
8110ed04:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
8110ed08:	d0a05317 	ldw	r2,-32436(gp)
8110ed0c:	00c000c4 	movi	r3,3
8110ed10:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110ed14:	d0a05317 	ldw	r2,-32436(gp)
8110ed18:	10802e17 	ldw	r2,184(r2)
8110ed1c:	d0a05605 	stb	r2,-32424(gp)
				break;
8110ed20:	00033c06 	br	8110fa14 <vFeeTask+0x17f0>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ed24:	d0a05317 	ldw	r2,-32436(gp)
8110ed28:	10800003 	ldbu	r2,0(r2)
8110ed2c:	10803fcc 	andi	r2,r2,255
8110ed30:	1085883a 	add	r2,r2,r2
8110ed34:	1087883a 	add	r3,r2,r2
8110ed38:	d0a06a04 	addi	r2,gp,-32344
8110ed3c:	1885883a 	add	r2,r3,r2
8110ed40:	10800017 	ldw	r2,0(r2)
8110ed44:	e0fffd04 	addi	r3,fp,-12
8110ed48:	180d883a 	mov	r6,r3
8110ed4c:	000b883a 	mov	r5,zero
8110ed50:	1009883a 	mov	r4,r2
8110ed54:	113f8640 	call	8113f864 <OSQPend>
8110ed58:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ed5c:	e0bffd03 	ldbu	r2,-12(fp)
8110ed60:	10803fcc 	andi	r2,r2,255
8110ed64:	1000061e 	bne	r2,zero,8110ed80 <vFeeTask+0xb5c>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110ed68:	d0a05317 	ldw	r2,-32436(gp)
8110ed6c:	e0fffe17 	ldw	r3,-8(fp)
8110ed70:	180b883a 	mov	r5,r3
8110ed74:	1009883a 	mov	r4,r2
8110ed78:	110fe740 	call	8110fe74 <vQCmdFEEinStandBy>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110ed7c:	00031c06 	br	8110f9f0 <vFeeTask+0x17cc>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110ed80:	00a045f4 	movhi	r2,33047
8110ed84:	10a25304 	addi	r2,r2,-30388
8110ed88:	10800a8b 	ldhu	r2,42(r2)
8110ed8c:	10bfffcc 	andi	r2,r2,65535
8110ed90:	10800228 	cmpgeui	r2,r2,8
8110ed94:	1003161e 	bne	r2,zero,8110f9f0 <vFeeTask+0x17cc>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110ed98:	d0e06217 	ldw	r3,-32376(gp)
8110ed9c:	d0a05317 	ldw	r2,-32436(gp)
8110eda0:	10800003 	ldbu	r2,0(r2)
8110eda4:	10803fcc 	andi	r2,r2,255
8110eda8:	100d883a 	mov	r6,r2
8110edac:	01604574 	movhi	r5,33045
8110edb0:	2978e104 	addi	r5,r5,-7292
8110edb4:	1809883a 	mov	r4,r3
8110edb8:	11232a00 	call	811232a0 <fprintf>
					}
					#endif
				}

				break;
8110edbc:	00030c06 	br	8110f9f0 <vFeeTask+0x17cc>


			case sNextPatternIteration:


				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110edc0:	d0a05317 	ldw	r2,-32436(gp)
8110edc4:	10800003 	ldbu	r2,0(r2)
8110edc8:	10803fcc 	andi	r2,r2,255
8110edcc:	1085883a 	add	r2,r2,r2
8110edd0:	1087883a 	add	r3,r2,r2
8110edd4:	d0a05c04 	addi	r2,gp,-32400
8110edd8:	1885883a 	add	r2,r3,r2
8110eddc:	10800017 	ldw	r2,0(r2)
8110ede0:	1009883a 	mov	r4,r2
8110ede4:	113f7a40 	call	8113f7a4 <OSQFlush>
8110ede8:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110edec:	e0bffd03 	ldbu	r2,-12(fp)
8110edf0:	10803fcc 	andi	r2,r2,255
8110edf4:	10000126 	beq	r2,zero,8110edfc <vFeeTask+0xbd8>
					vFailFlushNFEEQueue();
8110edf8:	111f4a40 	call	8111f4a4 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bUsingDMA = TRUE;
8110edfc:	d0a05317 	ldw	r2,-32436(gp)
8110ee00:	00c00044 	movi	r3,1
8110ee04:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110ee08:	d0a05317 	ldw	r2,-32436(gp)
8110ee0c:	00c00044 	movi	r3,1
8110ee10:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
8110ee14:	d0a05317 	ldw	r2,-32436(gp)
8110ee18:	1009883a 	mov	r4,r2
8110ee1c:	111fb940 	call	8111fb94 <vResetMemCCDFEE>

				/* Wait until both buffers are empty  */
				if (xDefaults.usiLinkNFEE0 == 0) {
8110ee20:	00a045f4 	movhi	r2,33047
8110ee24:	10a25304 	addi	r2,r2,-30388
8110ee28:	10800a0b 	ldhu	r2,40(r2)
8110ee2c:	10bfffcc 	andi	r2,r2,65535
8110ee30:	1000081e 	bne	r2,zero,8110ee54 <vFeeTask+0xc30>
					while ( (bFeebGetCh1LeftFeeBusy()== TRUE) || (bFeebGetCh1RightFeeBusy()== TRUE)  ) {}
8110ee34:	0001883a 	nop
8110ee38:	11068c80 	call	811068c8 <bFeebGetCh1LeftFeeBusy>
8110ee3c:	10800060 	cmpeqi	r2,r2,1
8110ee40:	103ffd1e 	bne	r2,zero,8110ee38 <__reset+0xfb0eee38>
8110ee44:	11069300 	call	81106930 <bFeebGetCh1RightFeeBusy>
8110ee48:	10800060 	cmpeqi	r2,r2,1
8110ee4c:	103ffa1e 	bne	r2,zero,8110ee38 <__reset+0xfb0eee38>
8110ee50:	00000706 	br	8110ee70 <vFeeTask+0xc4c>
				} else {
					while ( (bFeebGetCh2LeftFeeBusy()== TRUE) || (bFeebGetCh2RightFeeBusy()== TRUE)  ) {}
8110ee54:	0001883a 	nop
8110ee58:	11069980 	call	81106998 <bFeebGetCh2LeftFeeBusy>
8110ee5c:	10800060 	cmpeqi	r2,r2,1
8110ee60:	103ffd1e 	bne	r2,zero,8110ee58 <__reset+0xfb0eee58>
8110ee64:	1106a000 	call	81106a00 <bFeebGetCh2RightFeeBusy>
8110ee68:	10800060 	cmpeqi	r2,r2,1
8110ee6c:	103ffa1e 	bne	r2,zero,8110ee58 <__reset+0xfb0eee58>
				}

				OSTimeDlyHMSM(0,0,0,xDefaults.usiGuardNFEEDelay);
8110ee70:	00a045f4 	movhi	r2,33047
8110ee74:	10a25304 	addi	r2,r2,-30388
8110ee78:	10800b8b 	ldhu	r2,46(r2)
8110ee7c:	10bfffcc 	andi	r2,r2,65535
8110ee80:	100f883a 	mov	r7,r2
8110ee84:	000d883a 	mov	r6,zero
8110ee88:	000b883a 	mov	r5,zero
8110ee8c:	0009883a 	mov	r4,zero
8110ee90:	11426f40 	call	811426f4 <OSTimeDlyHMSM>

				if (xDefaults.usiLinkNFEE0 == 0) {
8110ee94:	00a045f4 	movhi	r2,33047
8110ee98:	10a25304 	addi	r2,r2,-30388
8110ee9c:	10800a0b 	ldhu	r2,40(r2)
8110eea0:	10bfffcc 	andi	r2,r2,65535
8110eea4:	1000071e 	bne	r2,zero,8110eec4 <vFeeTask+0xca0>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110eea8:	000b883a 	mov	r5,zero
8110eeac:	01000404 	movi	r4,16
8110eeb0:	1105a100 	call	81105a10 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110eeb4:	01400044 	movi	r5,1
8110eeb8:	01000404 	movi	r4,16
8110eebc:	1105a100 	call	81105a10 <bFeebCh1SetBufferSize>
8110eec0:	00000606 	br	8110eedc <vFeeTask+0xcb8>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110eec4:	000b883a 	mov	r5,zero
8110eec8:	01000404 	movi	r4,16
8110eecc:	1105af00 	call	81105af0 <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110eed0:	01400044 	movi	r5,1
8110eed4:	01000404 	movi	r4,16
8110eed8:	1105af00 	call	81105af0 <bFeebCh2SetBufferSize>
				}

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110eedc:	d0a05317 	ldw	r2,-32436(gp)
8110eee0:	10803b04 	addi	r2,r2,236
8110eee4:	1009883a 	mov	r4,r2
8110eee8:	11116b00 	call	811116b0 <bEnableDbBuffer>

				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110eeec:	d0a05317 	ldw	r2,-32436(gp)
8110eef0:	10808b04 	addi	r2,r2,556
8110eef4:	1009883a 	mov	r4,r2
8110eef8:	110ab300 	call	8110ab30 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
8110eefc:	d0a05317 	ldw	r2,-32436(gp)
8110ef00:	10809743 	ldbu	r2,605(r2)
8110ef04:	10803fcc 	andi	r2,r2,255
8110ef08:	d0a05515 	stw	r2,-32428(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
8110ef0c:	d0a05517 	ldw	r2,-32428(gp)
8110ef10:	10800044 	addi	r2,r2,1
8110ef14:	108000cc 	andi	r2,r2,3
8110ef18:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8110ef1c:	e0bffc17 	ldw	r2,-16(fp)
8110ef20:	10000e1e 	bne	r2,zero,8110ef5c <vFeeTask+0xd38>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110ef24:	d0a05317 	ldw	r2,-32436(gp)
8110ef28:	10802917 	ldw	r2,164(r2)
8110ef2c:	10800003 	ldbu	r2,0(r2)
8110ef30:	10803fcc 	andi	r2,r2,255
8110ef34:	10c00044 	addi	r3,r2,1
8110ef38:	00a00034 	movhi	r2,32768
8110ef3c:	10800044 	addi	r2,r2,1
8110ef40:	1884703a 	and	r2,r3,r2
8110ef44:	1000040e 	bge	r2,zero,8110ef58 <vFeeTask+0xd34>
8110ef48:	10bfffc4 	addi	r2,r2,-1
8110ef4c:	00ffff84 	movi	r3,-2
8110ef50:	10c4b03a 	or	r2,r2,r3
8110ef54:	10800044 	addi	r2,r2,1
8110ef58:	e0bff405 	stb	r2,-48(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110ef5c:	d0e05317 	ldw	r3,-32436(gp)
8110ef60:	e0bffc17 	ldw	r2,-16(fp)
8110ef64:	1885883a 	add	r2,r3,r2
8110ef68:	10802a44 	addi	r2,r2,169
8110ef6c:	10800003 	ldbu	r2,0(r2)
8110ef70:	e0bff605 	stb	r2,-40(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110ef74:	d0a05317 	ldw	r2,-32436(gp)
8110ef78:	10802e17 	ldw	r2,184(r2)
8110ef7c:	1000071e 	bne	r2,zero,8110ef9c <vFeeTask+0xd78>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110ef80:	d0e05317 	ldw	r3,-32436(gp)
8110ef84:	e0bff603 	ldbu	r2,-40(fp)
8110ef88:	10800624 	muli	r2,r2,24
8110ef8c:	10800904 	addi	r2,r2,36
8110ef90:	1885883a 	add	r2,r3,r2
8110ef94:	e0bff515 	stw	r2,-44(fp)
8110ef98:	00000606 	br	8110efb4 <vFeeTask+0xd90>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110ef9c:	d0e05317 	ldw	r3,-32436(gp)
8110efa0:	e0bff603 	ldbu	r2,-40(fp)
8110efa4:	10800624 	muli	r2,r2,24
8110efa8:	10800c04 	addi	r2,r2,48
8110efac:	1885883a 	add	r2,r3,r2
8110efb0:	e0bff515 	stw	r2,-44(fp)

				ucIterationSide = pxNFee->xControl.eSide;
8110efb4:	d0a05317 	ldw	r2,-32436(gp)
8110efb8:	10802e17 	ldw	r2,184(r2)
8110efbc:	d0a05605 	stb	r2,-32424(gp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110efc0:	d0a05317 	ldw	r2,-32436(gp)
8110efc4:	10803304 	addi	r2,r2,204
8110efc8:	1009883a 	mov	r4,r2
8110efcc:	1104bb00 	call	81104bb0 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110efd0:	d0a05317 	ldw	r2,-32436(gp)
8110efd4:	e0fff603 	ldbu	r3,-40(fp)
8110efd8:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern;
8110efdc:	d0a05317 	ldw	r2,-32436(gp)
8110efe0:	00c00244 	movi	r3,9
8110efe4:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110efe8:	d0a05317 	ldw	r2,-32436(gp)
8110efec:	10803304 	addi	r2,r2,204
8110eff0:	1009883a 	mov	r4,r2
8110eff4:	110490c0 	call	8110490c <bDpktSetPacketConfig>


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110eff8:	d0a05317 	ldw	r2,-32436(gp)
8110effc:	10803304 	addi	r2,r2,204
8110f000:	1009883a 	mov	r4,r2
8110f004:	1104bb00 	call	81104bb0 <bDpktGetPacketConfig>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110f008:	00a045f4 	movhi	r2,33047
8110f00c:	10a25304 	addi	r2,r2,-30388
8110f010:	10800a8b 	ldhu	r2,42(r2)
8110f014:	10bfffcc 	andi	r2,r2,65535
8110f018:	108000e8 	cmpgeui	r2,r2,3
8110f01c:	10004d1e 	bne	r2,zero,8110f154 <vFeeTask+0xf30>
					fprintf(fp,"\n\n=========DATA PACKET=============\n");
8110f020:	d0a06217 	ldw	r2,-32376(gp)
8110f024:	100f883a 	mov	r7,r2
8110f028:	01800904 	movi	r6,36
8110f02c:	01400044 	movi	r5,1
8110f030:	01204574 	movhi	r4,33045
8110f034:	2138f304 	addi	r4,r4,-7220
8110f038:	112393c0 	call	8112393c <fwrite>
					fprintf(fp,"usiCcdXSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize);
8110f03c:	d0e06217 	ldw	r3,-32376(gp)
8110f040:	d0a05317 	ldw	r2,-32436(gp)
8110f044:	1080340b 	ldhu	r2,208(r2)
8110f048:	10bfffcc 	andi	r2,r2,65535
8110f04c:	100d883a 	mov	r6,r2
8110f050:	01604574 	movhi	r5,33045
8110f054:	2978fd04 	addi	r5,r5,-7180
8110f058:	1809883a 	mov	r4,r3
8110f05c:	11232a00 	call	811232a0 <fprintf>
					fprintf(fp,"usiCcdYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize);
8110f060:	d0e06217 	ldw	r3,-32376(gp)
8110f064:	d0a05317 	ldw	r2,-32436(gp)
8110f068:	1080348b 	ldhu	r2,210(r2)
8110f06c:	10bfffcc 	andi	r2,r2,65535
8110f070:	100d883a 	mov	r6,r2
8110f074:	01604574 	movhi	r5,33045
8110f078:	29790204 	addi	r5,r5,-7160
8110f07c:	1809883a 	mov	r4,r3
8110f080:	11232a00 	call	811232a0 <fprintf>
					fprintf(fp,"usiDataYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize);
8110f084:	d0e06217 	ldw	r3,-32376(gp)
8110f088:	d0a05317 	ldw	r2,-32436(gp)
8110f08c:	1080350b 	ldhu	r2,212(r2)
8110f090:	10bfffcc 	andi	r2,r2,65535
8110f094:	100d883a 	mov	r6,r2
8110f098:	01604574 	movhi	r5,33045
8110f09c:	29790704 	addi	r5,r5,-7140
8110f0a0:	1809883a 	mov	r4,r3
8110f0a4:	11232a00 	call	811232a0 <fprintf>
					fprintf(fp,"usiOverscanYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize);
8110f0a8:	d0e06217 	ldw	r3,-32376(gp)
8110f0ac:	d0a05317 	ldw	r2,-32436(gp)
8110f0b0:	1080358b 	ldhu	r2,214(r2)
8110f0b4:	10bfffcc 	andi	r2,r2,65535
8110f0b8:	100d883a 	mov	r6,r2
8110f0bc:	01604574 	movhi	r5,33045
8110f0c0:	29790c04 	addi	r5,r5,-7120
8110f0c4:	1809883a 	mov	r4,r3
8110f0c8:	11232a00 	call	811232a0 <fprintf>
					fprintf(fp,"usiPacketLength %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength);
8110f0cc:	d0e06217 	ldw	r3,-32376(gp)
8110f0d0:	d0a05317 	ldw	r2,-32436(gp)
8110f0d4:	1080360b 	ldhu	r2,216(r2)
8110f0d8:	10bfffcc 	andi	r2,r2,65535
8110f0dc:	100d883a 	mov	r6,r2
8110f0e0:	01604574 	movhi	r5,33045
8110f0e4:	29791204 	addi	r5,r5,-7096
8110f0e8:	1809883a 	mov	r4,r3
8110f0ec:	11232a00 	call	811232a0 <fprintf>
					fprintf(fp,"ucCcdNumber %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber);
8110f0f0:	d0e06217 	ldw	r3,-32376(gp)
8110f0f4:	d0a05317 	ldw	r2,-32436(gp)
8110f0f8:	108036c3 	ldbu	r2,219(r2)
8110f0fc:	10803fcc 	andi	r2,r2,255
8110f100:	100d883a 	mov	r6,r2
8110f104:	01604574 	movhi	r5,33045
8110f108:	29791804 	addi	r5,r5,-7072
8110f10c:	1809883a 	mov	r4,r3
8110f110:	11232a00 	call	811232a0 <fprintf>
					fprintf(fp,"ucFeeMode %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode);
8110f114:	d0e06217 	ldw	r3,-32376(gp)
8110f118:	d0a05317 	ldw	r2,-32436(gp)
8110f11c:	10803683 	ldbu	r2,218(r2)
8110f120:	10803fcc 	andi	r2,r2,255
8110f124:	100d883a 	mov	r6,r2
8110f128:	01604574 	movhi	r5,33045
8110f12c:	29791d04 	addi	r5,r5,-7052
8110f130:	1809883a 	mov	r4,r3
8110f134:	11232a00 	call	811232a0 <fprintf>
					fprintf(fp,"=========DATA PACKET=============\n");
8110f138:	d0a06217 	ldw	r2,-32376(gp)
8110f13c:	100f883a 	mov	r7,r2
8110f140:	01800884 	movi	r6,34
8110f144:	01400044 	movi	r5,1
8110f148:	01204574 	movhi	r4,33045
8110f14c:	21392104 	addi	r4,r4,-7036
8110f150:	112393c0 	call	8112393c <fwrite>
				}
				#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110f154:	d0a05317 	ldw	r2,-32436(gp)
8110f158:	10800003 	ldbu	r2,0(r2)
8110f15c:	10803fcc 	andi	r2,r2,255
8110f160:	100d883a 	mov	r6,r2
8110f164:	000b883a 	mov	r5,zero
8110f168:	01002004 	movi	r4,128
8110f16c:	11117b40 	call	811117b4 <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8110f170:	e03ff815 	stw	zero,-32(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110f174:	d0a05317 	ldw	r2,-32436(gp)
8110f178:	10800003 	ldbu	r2,0(r2)
8110f17c:	10803fcc 	andi	r2,r2,255
8110f180:	1085883a 	add	r2,r2,r2
8110f184:	1087883a 	add	r3,r2,r2
8110f188:	d0a06a04 	addi	r2,gp,-32344
8110f18c:	1885883a 	add	r2,r3,r2
8110f190:	10800017 	ldw	r2,0(r2)
8110f194:	e0fffd04 	addi	r3,fp,-12
8110f198:	180d883a 	mov	r6,r3
8110f19c:	000b883a 	mov	r5,zero
8110f1a0:	1009883a 	mov	r4,r2
8110f1a4:	113f8640 	call	8113f864 <OSQPend>
8110f1a8:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110f1ac:	e0bffd03 	ldbu	r2,-12(fp)
8110f1b0:	10803fcc 	andi	r2,r2,255
8110f1b4:	10005e1e 	bne	r2,zero,8110f330 <vFeeTask+0x110c>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110f1b8:	e0bffe83 	ldbu	r2,-6(fp)
8110f1bc:	10803fcc 	andi	r2,r2,255
8110f1c0:	108023d8 	cmpnei	r2,r2,143
8110f1c4:	1000541e 	bne	r2,zero,8110f318 <vFeeTask+0x10f4>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110f1c8:	e0fff403 	ldbu	r3,-48(fp)
8110f1cc:	00a045b4 	movhi	r2,33046
8110f1d0:	10959704 	addi	r2,r2,22108
8110f1d4:	180690fa 	slli	r3,r3,3
8110f1d8:	10c5883a 	add	r2,r2,r3
8110f1dc:	10800017 	ldw	r2,0(r2)
8110f1e0:	e0fffd04 	addi	r3,fp,-12
8110f1e4:	180d883a 	mov	r6,r3
8110f1e8:	000b883a 	mov	r5,zero
8110f1ec:	1009883a 	mov	r4,r2
8110f1f0:	113e7500 	call	8113e750 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110f1f4:	e0bffd03 	ldbu	r2,-12(fp)
8110f1f8:	10803fcc 	andi	r2,r2,255
8110f1fc:	1000181e 	bne	r2,zero,8110f260 <vFeeTask+0x103c>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110f200:	d0a05317 	ldw	r2,-32436(gp)
8110f204:	00c00044 	movi	r3,1
8110f208:	10c02215 	stw	r3,136(r2)

							bDmaReturn = bPrepareDoubleBuffer( xCcdMapLocal, ucMemUsing, pxNFee->ucId, pxNFee );
8110f20c:	e0fff403 	ldbu	r3,-48(fp)
8110f210:	d0a05317 	ldw	r2,-32436(gp)
8110f214:	10800003 	ldbu	r2,0(r2)
8110f218:	10803fcc 	andi	r2,r2,255
8110f21c:	d1205317 	ldw	r4,-32436(gp)
8110f220:	200f883a 	mov	r7,r4
8110f224:	100d883a 	mov	r6,r2
8110f228:	180b883a 	mov	r5,r3
8110f22c:	e13ff517 	ldw	r4,-44(fp)
8110f230:	11122640 	call	81112264 <bPrepareDoubleBuffer>
8110f234:	e0bff815 	stw	r2,-32(fp)
							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110f238:	e0fff403 	ldbu	r3,-48(fp)
8110f23c:	00a045b4 	movhi	r2,33046
8110f240:	10959704 	addi	r2,r2,22108
8110f244:	180690fa 	slli	r3,r3,3
8110f248:	10c5883a 	add	r2,r2,r3
8110f24c:	10800017 	ldw	r2,0(r2)
8110f250:	1009883a 	mov	r4,r2
8110f254:	113ecf40 	call	8113ecf4 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8110f258:	d0a05317 	ldw	r2,-32436(gp)
8110f25c:	10002215 	stw	zero,136(r2)
		
						}
						/* Send message telling to controller that is not using the DMA any more */
						bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);							
8110f260:	d0a05317 	ldw	r2,-32436(gp)
8110f264:	10800003 	ldbu	r2,0(r2)
8110f268:	10803fcc 	andi	r2,r2,255
8110f26c:	100d883a 	mov	r6,r2
8110f270:	000b883a 	mov	r5,zero
8110f274:	01002044 	movi	r4,129
8110f278:	11118580 	call	81111858 <bSendGiveBackNFeeCtrl>

						if ( bDmaReturn == TRUE ) {
8110f27c:	e0bff817 	ldw	r2,-32(fp)
8110f280:	10800058 	cmpnei	r2,r2,1
8110f284:	1000141e 	bne	r2,zero,8110f2d8 <vFeeTask+0x10b4>
							if (pxNFee->xControl.bWatingSync==TRUE) {
8110f288:	d0a05317 	ldw	r2,-32436(gp)
8110f28c:	10802817 	ldw	r2,160(r2)
8110f290:	10800058 	cmpnei	r2,r2,1
8110f294:	1000071e 	bne	r2,zero,8110f2b4 <vFeeTask+0x1090>
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110f298:	d0a05317 	ldw	r2,-32436(gp)
8110f29c:	00c001c4 	movi	r3,7
8110f2a0:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sFeeWaitingSync;
8110f2a4:	d0a05317 	ldw	r2,-32436(gp)
8110f2a8:	00c00304 	movi	r3,12
8110f2ac:	10c02c15 	stw	r3,176(r2)
8110f2b0:	00000606 	br	8110f2cc <vFeeTask+0x10a8>
							} else {
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110f2b4:	d0a05317 	ldw	r2,-32436(gp)
8110f2b8:	00c001c4 	movi	r3,7
8110f2bc:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sToTestFullPattern;
8110f2c0:	d0a05317 	ldw	r2,-32436(gp)
8110f2c4:	00c001c4 	movi	r3,7
8110f2c8:	10c02c15 	stw	r3,176(r2)
							}
							incrementador++;
8110f2cc:	d0a05417 	ldw	r2,-32432(gp)
8110f2d0:	10800044 	addi	r2,r2,1
8110f2d4:	d0a05415 	stw	r2,-32432(gp)
						}

						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f2d8:	00a045f4 	movhi	r2,33047
8110f2dc:	10a25304 	addi	r2,r2,-30388
8110f2e0:	10800a8b 	ldhu	r2,42(r2)
8110f2e4:	10bfffcc 	andi	r2,r2,65535
8110f2e8:	10800168 	cmpgeui	r2,r2,5
8110f2ec:	1001c21e 	bne	r2,zero,8110f9f8 <vFeeTask+0x17d4>
							fprintf(fp,"\nNFEE-%hu Task: Double buffer prepared\n", pxNFee->ucId);
8110f2f0:	d0e06217 	ldw	r3,-32376(gp)
8110f2f4:	d0a05317 	ldw	r2,-32436(gp)
8110f2f8:	10800003 	ldbu	r2,0(r2)
8110f2fc:	10803fcc 	andi	r2,r2,255
8110f300:	100d883a 	mov	r6,r2
8110f304:	01604574 	movhi	r5,33045
8110f308:	29792a04 	addi	r5,r5,-7000
8110f30c:	1809883a 	mov	r4,r3
8110f310:	11232a00 	call	811232a0 <fprintf>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8110f314:	0001b806 	br	8110f9f8 <vFeeTask+0x17d4>
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
							fprintf(fp,"\nNFEE-%hu Task: Double buffer prepared\n", pxNFee->ucId);
						}
						#endif
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110f318:	d0a05317 	ldw	r2,-32436(gp)
8110f31c:	e0fffe17 	ldw	r3,-8(fp)
8110f320:	180b883a 	mov	r5,r3
8110f324:	1009883a 	mov	r4,r2
8110f328:	11100d00 	call	811100d0 <vQCmdFEEinFullPattern>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8110f32c:	0001b206 	br	8110f9f8 <vFeeTask+0x17d4>
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
					}
				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f330:	00a045f4 	movhi	r2,33047
8110f334:	10a25304 	addi	r2,r2,-30388
8110f338:	10800a8b 	ldhu	r2,42(r2)
8110f33c:	10bfffcc 	andi	r2,r2,65535
8110f340:	10800228 	cmpgeui	r2,r2,8
8110f344:	1001ac1e 	bne	r2,zero,8110f9f8 <vFeeTask+0x17d4>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110f348:	d0e06217 	ldw	r3,-32376(gp)
8110f34c:	d0a05317 	ldw	r2,-32436(gp)
8110f350:	10800003 	ldbu	r2,0(r2)
8110f354:	10803fcc 	andi	r2,r2,255
8110f358:	100d883a 	mov	r6,r2
8110f35c:	01604574 	movhi	r5,33045
8110f360:	2978e104 	addi	r5,r5,-7292
8110f364:	1809883a 	mov	r4,r3
8110f368:	11232a00 	call	811232a0 <fprintf>
					}
					#endif
				}	
				break;
8110f36c:	0001a206 	br	8110f9f8 <vFeeTask+0x17d4>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
8110f370:	e03ff915 	stw	zero,-28(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110f374:	d0a05317 	ldw	r2,-32436(gp)
8110f378:	10804504 	addi	r2,r2,276
8110f37c:	1009883a 	mov	r4,r2
8110f380:	11086380 	call	81108638 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8110f384:	d0a05317 	ldw	r2,-32436(gp)
8110f388:	00c00084 	movi	r3,2
8110f38c:	10c06815 	stw	r3,416(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110f390:	d0a05317 	ldw	r2,-32436(gp)
8110f394:	10804504 	addi	r2,r2,276
8110f398:	1009883a 	mov	r4,r2
8110f39c:	11083040 	call	81108304 <bRmapSetMemConfigArea>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110f3a0:	00a045f4 	movhi	r2,33047
8110f3a4:	10a25304 	addi	r2,r2,-30388
8110f3a8:	10800a8b 	ldhu	r2,42(r2)
8110f3ac:	10bfffcc 	andi	r2,r2,65535
8110f3b0:	108000e8 	cmpgeui	r2,r2,3
8110f3b4:	1000091e 	bne	r2,zero,8110f3dc <vFeeTask+0x11b8>
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110f3b8:	d0e06217 	ldw	r3,-32376(gp)
8110f3bc:	d0a05317 	ldw	r2,-32436(gp)
8110f3c0:	10800003 	ldbu	r2,0(r2)
8110f3c4:	10803fcc 	andi	r2,r2,255
8110f3c8:	100d883a 	mov	r6,r2
8110f3cc:	01604574 	movhi	r5,33045
8110f3d0:	29793404 	addi	r5,r5,-6960
8110f3d4:	1809883a 	mov	r4,r3
8110f3d8:	11232a00 	call	811232a0 <fprintf>
				}
				#endif

				ucIterationSide = pxNFee->xControl.eSide;
8110f3dc:	d0a05317 	ldw	r2,-32436(gp)
8110f3e0:	10802e17 	ldw	r2,184(r2)
8110f3e4:	d0a05605 	stb	r2,-32424(gp)

				pxNFee->xControl.bUsingDMA = TRUE;
8110f3e8:	d0a05317 	ldw	r2,-32436(gp)
8110f3ec:	00c00044 	movi	r3,1
8110f3f0:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110f3f4:	d0a05317 	ldw	r2,-32436(gp)
8110f3f8:	00c00104 	movi	r3,4
8110f3fc:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
8110f400:	d0a05317 	ldw	r2,-32436(gp)
8110f404:	00c00104 	movi	r3,4
8110f408:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8110f40c:	d0a05317 	ldw	r2,-32436(gp)
8110f410:	00c00044 	movi	r3,1
8110f414:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110f418:	d0a05317 	ldw	r2,-32436(gp)
8110f41c:	00c00044 	movi	r3,1
8110f420:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110f424:	d0a05317 	ldw	r2,-32436(gp)
8110f428:	00c00044 	movi	r3,1
8110f42c:	10c02115 	stw	r3,132(r2)
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110f430:	d0a05317 	ldw	r2,-32436(gp)
8110f434:	10800003 	ldbu	r2,0(r2)
8110f438:	10803fcc 	andi	r2,r2,255
8110f43c:	100d883a 	mov	r6,r2
8110f440:	000b883a 	mov	r5,zero
8110f444:	01002004 	movi	r4,128
8110f448:	11117b40 	call	811117b4 <bSendRequestNFeeCtrl>

				if (xDefaults.usiLinkNFEE0 == 0) {
8110f44c:	00a045f4 	movhi	r2,33047
8110f450:	10a25304 	addi	r2,r2,-30388
8110f454:	10800a0b 	ldhu	r2,40(r2)
8110f458:	10bfffcc 	andi	r2,r2,65535
8110f45c:	1000071e 	bne	r2,zero,8110f47c <vFeeTask+0x1258>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110f460:	000b883a 	mov	r5,zero
8110f464:	01000404 	movi	r4,16
8110f468:	1105a100 	call	81105a10 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110f46c:	01400044 	movi	r5,1
8110f470:	01000404 	movi	r4,16
8110f474:	1105a100 	call	81105a10 <bFeebCh1SetBufferSize>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				}

				break;
8110f478:	00016606 	br	8110fa14 <vFeeTask+0x17f0>

				if (xDefaults.usiLinkNFEE0 == 0) {
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110f47c:	000b883a 	mov	r5,zero
8110f480:	01000404 	movi	r4,16
8110f484:	1105af00 	call	81105af0 <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110f488:	01400044 	movi	r5,1
8110f48c:	01000404 	movi	r4,16
8110f490:	1105af00 	call	81105af0 <bFeebCh2SetBufferSize>
				}

				break;
8110f494:	00015f06 	br	8110fa14 <vFeeTask+0x17f0>

			case sFeeTestFullPattern: /* Real mode */
				bFinal = FALSE;
8110f498:	e03ff915 	stw	zero,-28(fp)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110f49c:	d0a05317 	ldw	r2,-32436(gp)
8110f4a0:	10800003 	ldbu	r2,0(r2)
8110f4a4:	10803fcc 	andi	r2,r2,255
8110f4a8:	1085883a 	add	r2,r2,r2
8110f4ac:	1087883a 	add	r3,r2,r2
8110f4b0:	d0a06a04 	addi	r2,gp,-32344
8110f4b4:	1885883a 	add	r2,r3,r2
8110f4b8:	10800017 	ldw	r2,0(r2)
8110f4bc:	e0fffd04 	addi	r3,fp,-12
8110f4c0:	180d883a 	mov	r6,r3
8110f4c4:	000b883a 	mov	r5,zero
8110f4c8:	1009883a 	mov	r4,r2
8110f4cc:	113f8640 	call	8113f864 <OSQPend>
8110f4d0:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110f4d4:	e0bffd03 	ldbu	r2,-12(fp)
8110f4d8:	10803fcc 	andi	r2,r2,255
8110f4dc:	1000a21e 	bne	r2,zero,8110f768 <vFeeTask+0x1544>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110f4e0:	e0bffe83 	ldbu	r2,-6(fp)
8110f4e4:	10803fcc 	andi	r2,r2,255
8110f4e8:	108023d8 	cmpnei	r2,r2,143
8110f4ec:	1000911e 	bne	r2,zero,8110f734 <vFeeTask+0x1510>

						/* Try to get the Mutex */
						OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110f4f0:	e0fff403 	ldbu	r3,-48(fp)
8110f4f4:	00a045b4 	movhi	r2,33046
8110f4f8:	10959704 	addi	r2,r2,22108
8110f4fc:	180690fa 	slli	r3,r3,3
8110f500:	10c5883a 	add	r2,r2,r3
8110f504:	10800017 	ldw	r2,0(r2)
8110f508:	e0fffd04 	addi	r3,fp,-12
8110f50c:	180d883a 	mov	r6,r3
8110f510:	000b883a 	mov	r5,zero
8110f514:	1009883a 	mov	r4,r2
8110f518:	113e7500 	call	8113e750 <OSMutexPend>
						if ( error_code == OS_ERR_NONE ) {
8110f51c:	e0bffd03 	ldbu	r2,-12(fp)
8110f520:	10803fcc 	andi	r2,r2,255
8110f524:	1001361e 	bne	r2,zero,8110fa00 <vFeeTask+0x17dc>
							pxNFee->xControl.bDMALocked = TRUE;
8110f528:	d0a05317 	ldw	r2,-32436(gp)
8110f52c:	00c00044 	movi	r3,1
8110f530:	10c02215 	stw	r3,136(r2)

							/* Is this the last block? */
							if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110f534:	e0bff517 	ldw	r2,-44(fp)
8110f538:	10800117 	ldw	r2,4(r2)
8110f53c:	10c00404 	addi	r3,r2,16
8110f540:	d0a05317 	ldw	r2,-32436(gp)
8110f544:	10800417 	ldw	r2,16(r2)
8110f548:	18802336 	bltu	r3,r2,8110f5d8 <vFeeTask+0x13b4>

								/*Define the size of the data in the double buffer (need this to create the interrupt right)*/
								usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110f54c:	d0a05317 	ldw	r2,-32436(gp)
8110f550:	10c00417 	ldw	r3,16(r2)
8110f554:	e0bff517 	ldw	r2,-44(fp)
8110f558:	10800117 	ldw	r2,4(r2)
8110f55c:	1885c83a 	sub	r2,r3,r2
8110f560:	e0bff715 	stw	r2,-36(fp)

								if (xDefaults.usiLinkNFEE0 == 0) {
8110f564:	00a045f4 	movhi	r2,33047
8110f568:	10a25304 	addi	r2,r2,-30388
8110f56c:	10800a0b 	ldhu	r2,40(r2)
8110f570:	10bfffcc 	andi	r2,r2,65535
8110f574:	10000b1e 	bne	r2,zero,8110f5a4 <vFeeTask+0x1380>
									bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,0);
8110f578:	e0bff717 	ldw	r2,-36(fp)
8110f57c:	10803fcc 	andi	r2,r2,255
8110f580:	000b883a 	mov	r5,zero
8110f584:	1009883a 	mov	r4,r2
8110f588:	1105a100 	call	81105a10 <bFeebCh1SetBufferSize>
									bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,1);
8110f58c:	e0bff717 	ldw	r2,-36(fp)
8110f590:	10803fcc 	andi	r2,r2,255
8110f594:	01400044 	movi	r5,1
8110f598:	1009883a 	mov	r4,r2
8110f59c:	1105a100 	call	81105a10 <bFeebCh1SetBufferSize>
8110f5a0:	00000a06 	br	8110f5cc <vFeeTask+0x13a8>
								} else {
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,0);
8110f5a4:	e0bff717 	ldw	r2,-36(fp)
8110f5a8:	10803fcc 	andi	r2,r2,255
8110f5ac:	000b883a 	mov	r5,zero
8110f5b0:	1009883a 	mov	r4,r2
8110f5b4:	1105af00 	call	81105af0 <bFeebCh2SetBufferSize>
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
8110f5b8:	e0bff717 	ldw	r2,-36(fp)
8110f5bc:	10803fcc 	andi	r2,r2,255
8110f5c0:	01400044 	movi	r5,1
8110f5c4:	1009883a 	mov	r4,r2
8110f5c8:	1105af00 	call	81105af0 <bFeebCh2SetBufferSize>
								}

								bFinal = TRUE;
8110f5cc:	00800044 	movi	r2,1
8110f5d0:	e0bff915 	stw	r2,-28(fp)
8110f5d4:	00000206 	br	8110f5e0 <vFeeTask+0x13bc>

							} else {
								usiLengthBlocks = SDMA_MAX_BLOCKS;
8110f5d8:	00800404 	movi	r2,16
8110f5dc:	e0bff715 	stw	r2,-36(fp)
							}


							if ( ucMemUsing == 0  ) {
8110f5e0:	e0bff403 	ldbu	r2,-48(fp)
8110f5e4:	1000111e 	bne	r2,zero,8110f62c <vFeeTask+0x1408>
								bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110f5e8:	e0bff517 	ldw	r2,-44(fp)
8110f5ec:	10800217 	ldw	r2,8(r2)
8110f5f0:	1011883a 	mov	r8,r2
8110f5f4:	e0bff717 	ldw	r2,-36(fp)
8110f5f8:	10ffffcc 	andi	r3,r2,65535
8110f5fc:	d0a05603 	ldbu	r2,-32424(gp)
8110f600:	11003fcc 	andi	r4,r2,255
8110f604:	d0a05317 	ldw	r2,-32436(gp)
8110f608:	10800043 	ldbu	r2,1(r2)
8110f60c:	10803fcc 	andi	r2,r2,255
8110f610:	100f883a 	mov	r7,r2
8110f614:	200d883a 	mov	r6,r4
8110f618:	180b883a 	mov	r5,r3
8110f61c:	4009883a 	mov	r4,r8
8110f620:	1103d040 	call	81103d04 <bSdmaDmaM1Transfer>
8110f624:	e0bff815 	stw	r2,-32(fp)
8110f628:	00001006 	br	8110f66c <vFeeTask+0x1448>
							} else {
								bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110f62c:	e0bff517 	ldw	r2,-44(fp)
8110f630:	10800217 	ldw	r2,8(r2)
8110f634:	1011883a 	mov	r8,r2
8110f638:	e0bff717 	ldw	r2,-36(fp)
8110f63c:	10ffffcc 	andi	r3,r2,65535
8110f640:	d0a05603 	ldbu	r2,-32424(gp)
8110f644:	11003fcc 	andi	r4,r2,255
8110f648:	d0a05317 	ldw	r2,-32436(gp)
8110f64c:	10800043 	ldbu	r2,1(r2)
8110f650:	10803fcc 	andi	r2,r2,255
8110f654:	100f883a 	mov	r7,r2
8110f658:	200d883a 	mov	r6,r4
8110f65c:	180b883a 	mov	r5,r3
8110f660:	4009883a 	mov	r4,r8
8110f664:	11041580 	call	81104158 <bSdmaDmaM2Transfer>
8110f668:	e0bff815 	stw	r2,-32(fp)
							}

							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110f66c:	e0fff403 	ldbu	r3,-48(fp)
8110f670:	00a045b4 	movhi	r2,33046
8110f674:	10959704 	addi	r2,r2,22108
8110f678:	180690fa 	slli	r3,r3,3
8110f67c:	10c5883a 	add	r2,r2,r3
8110f680:	10800017 	ldw	r2,0(r2)
8110f684:	1009883a 	mov	r4,r2
8110f688:	113ecf40 	call	8113ecf4 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8110f68c:	d0a05317 	ldw	r2,-32436(gp)
8110f690:	10002215 	stw	zero,136(r2)

							if ( bDmaReturn == TRUE ) {
8110f694:	e0bff817 	ldw	r2,-32(fp)
8110f698:	10800058 	cmpnei	r2,r2,1
8110f69c:	10000e1e 	bne	r2,zero,8110f6d8 <vFeeTask+0x14b4>
								/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
								xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*usiLengthBlocks;
8110f6a0:	e0bff517 	ldw	r2,-44(fp)
8110f6a4:	10c00217 	ldw	r3,8(r2)
8110f6a8:	e0bff717 	ldw	r2,-36(fp)
8110f6ac:	10802224 	muli	r2,r2,136
8110f6b0:	1887883a 	add	r3,r3,r2
8110f6b4:	e0bff517 	ldw	r2,-44(fp)
8110f6b8:	10c00215 	stw	r3,8(r2)
								xCcdMapLocal->ulBlockI += usiLengthBlocks;
8110f6bc:	e0bff517 	ldw	r2,-44(fp)
8110f6c0:	10c00117 	ldw	r3,4(r2)
8110f6c4:	e0bff717 	ldw	r2,-36(fp)
8110f6c8:	1887883a 	add	r3,r3,r2
8110f6cc:	e0bff517 	ldw	r2,-44(fp)
8110f6d0:	10c00115 	stw	r3,4(r2)
8110f6d4:	00000106 	br	8110f6dc <vFeeTask+0x14b8>
							} else {
								bFinal = FALSE;
8110f6d8:	e03ff915 	stw	zero,-28(fp)
							}

							/* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110f6dc:	d0a05317 	ldw	r2,-32436(gp)
8110f6e0:	10800003 	ldbu	r2,0(r2)
8110f6e4:	10803fcc 	andi	r2,r2,255
8110f6e8:	100d883a 	mov	r6,r2
8110f6ec:	000b883a 	mov	r5,zero
8110f6f0:	01002044 	movi	r4,129
8110f6f4:	11118580 	call	81111858 <bSendGiveBackNFeeCtrl>

							if ( bFinal == TRUE ) {
8110f6f8:	e0bff917 	ldw	r2,-28(fp)
8110f6fc:	10800058 	cmpnei	r2,r2,1
8110f700:	1000041e 	bne	r2,zero,8110f714 <vFeeTask+0x14f0>
								pxNFee->xControl.eMode = sEndTransmission;
8110f704:	d0a05317 	ldw	r2,-32436(gp)
8110f708:	00c002c4 	movi	r3,11
8110f70c:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f710:	0000bb06 	br	8110fa00 <vFeeTask+0x17dc>
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);

							if ( bFinal == TRUE ) {
								pxNFee->xControl.eMode = sEndTransmission;
							} else {
								bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110f714:	d0a05317 	ldw	r2,-32436(gp)
8110f718:	10800003 	ldbu	r2,0(r2)
8110f71c:	10803fcc 	andi	r2,r2,255
8110f720:	100d883a 	mov	r6,r2
8110f724:	000b883a 	mov	r5,zero
8110f728:	01002004 	movi	r4,128
8110f72c:	11117b40 	call	811117b4 <bSendRequestNFeeCtrl>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f730:	0000b306 	br	8110fa00 <vFeeTask+0x17dc>
								bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
							}

						}
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110f734:	d0a05317 	ldw	r2,-32436(gp)
8110f738:	e0fffe17 	ldw	r3,-8(fp)
8110f73c:	180b883a 	mov	r5,r3
8110f740:	1009883a 	mov	r4,r2
8110f744:	11100d00 	call	811100d0 <vQCmdFEEinFullPattern>

						if ( pxNFee->xControl.bWatingSync == FALSE ) {
8110f748:	d0a05317 	ldw	r2,-32436(gp)
8110f74c:	10802817 	ldw	r2,160(r2)
8110f750:	1000ab1e 	bne	r2,zero,8110fa00 <vFeeTask+0x17dc>
							pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110f754:	d0a05317 	ldw	r2,-32436(gp)
8110f758:	d0e05317 	ldw	r3,-32436(gp)
8110f75c:	18c02d17 	ldw	r3,180(r3)
8110f760:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f764:	0000a606 	br	8110fa00 <vFeeTask+0x17dc>
						}
					}

				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f768:	00a045f4 	movhi	r2,33047
8110f76c:	10a25304 	addi	r2,r2,-30388
8110f770:	10800a8b 	ldhu	r2,42(r2)
8110f774:	10bfffcc 	andi	r2,r2,65535
8110f778:	10800228 	cmpgeui	r2,r2,8
8110f77c:	1000a01e 	bne	r2,zero,8110fa00 <vFeeTask+0x17dc>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110f780:	d0e06217 	ldw	r3,-32376(gp)
8110f784:	d0a05317 	ldw	r2,-32436(gp)
8110f788:	10800003 	ldbu	r2,0(r2)
8110f78c:	10803fcc 	andi	r2,r2,255
8110f790:	100d883a 	mov	r6,r2
8110f794:	01604574 	movhi	r5,33045
8110f798:	2978e104 	addi	r5,r5,-7292
8110f79c:	1809883a 	mov	r4,r3
8110f7a0:	11232a00 	call	811232a0 <fprintf>
					}
					#endif
				}

				break;
8110f7a4:	00009606 	br	8110fa00 <vFeeTask+0x17dc>

			case sEndTransmission:

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f7a8:	00a045f4 	movhi	r2,33047
8110f7ac:	10a25304 	addi	r2,r2,-30388
8110f7b0:	10800a8b 	ldhu	r2,42(r2)
8110f7b4:	10bfffcc 	andi	r2,r2,65535
8110f7b8:	10800168 	cmpgeui	r2,r2,5
8110f7bc:	1000121e 	bne	r2,zero,8110f808 <vFeeTask+0x15e4>
					fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu\n", pxNFee->ucId, ucReadout);
8110f7c0:	d0e06217 	ldw	r3,-32376(gp)
8110f7c4:	d0a05317 	ldw	r2,-32436(gp)
8110f7c8:	10800003 	ldbu	r2,0(r2)
8110f7cc:	10803fcc 	andi	r2,r2,255
8110f7d0:	e13ff603 	ldbu	r4,-40(fp)
8110f7d4:	200f883a 	mov	r7,r4
8110f7d8:	100d883a 	mov	r6,r2
8110f7dc:	01604574 	movhi	r5,33045
8110f7e0:	29793e04 	addi	r5,r5,-6920
8110f7e4:	1809883a 	mov	r4,r3
8110f7e8:	11232a00 	call	811232a0 <fprintf>
					fprintf(fp,"Memory used: %u\n", ucMemUsing);
8110f7ec:	d0a06217 	ldw	r2,-32376(gp)
8110f7f0:	e0fff403 	ldbu	r3,-48(fp)
8110f7f4:	180d883a 	mov	r6,r3
8110f7f8:	01604574 	movhi	r5,33045
8110f7fc:	29794904 	addi	r5,r5,-6876
8110f800:	1009883a 	mov	r4,r2
8110f804:	11232a00 	call	811232a0 <fprintf>
				}
				#endif

				pxNFee->xControl.bWatingSync = TRUE;
8110f808:	d0a05317 	ldw	r2,-32436(gp)
8110f80c:	00c00044 	movi	r3,1
8110f810:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110f814:	d0a05317 	ldw	r2,-32436(gp)
8110f818:	10002315 	stw	zero,140(r2)

				if ( xDefaults.bOneShot == FALSE ) {
8110f81c:	00a045f4 	movhi	r2,33047
8110f820:	10a25304 	addi	r2,r2,-30388
8110f824:	10800917 	ldw	r2,36(r2)
8110f828:	10001f1e 	bne	r2,zero,8110f8a8 <vFeeTask+0x1684>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
8110f82c:	d0a05317 	ldw	r2,-32436(gp)
8110f830:	10802d17 	ldw	r2,180(r2)
8110f834:	10800198 	cmpnei	r2,r2,6
8110f838:	1000141e 	bne	r2,zero,8110f88c <vFeeTask+0x1668>

						bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110f83c:	d0a05317 	ldw	r2,-32436(gp)
8110f840:	10803304 	addi	r2,r2,204
8110f844:	1009883a 	mov	r4,r2
8110f848:	1104bb00 	call	81104bb0 <bDpktGetPacketConfig>
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110f84c:	d0a05317 	ldw	r2,-32436(gp)
8110f850:	e0fff603 	ldbu	r3,-40(fp)
8110f854:	10c036c5 	stb	r3,219(r2)
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
8110f858:	d0a05317 	ldw	r2,-32436(gp)
8110f85c:	10003685 	stb	zero,218(r2)
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110f860:	d0a05317 	ldw	r2,-32436(gp)
8110f864:	10803304 	addi	r2,r2,204
8110f868:	1009883a 	mov	r4,r2
8110f86c:	110490c0 	call	8110490c <bDpktSetPacketConfig>

						pxNFee->xControl.eMode =  sFeeWaitingSync;
8110f870:	d0a05317 	ldw	r2,-32436(gp)
8110f874:	00c00304 	movi	r3,12
8110f878:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110f87c:	d0a05317 	ldw	r2,-32436(gp)
8110f880:	00c00184 	movi	r3,6
8110f884:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
8110f888:	00006206 	br	8110fa14 <vFeeTask+0x17f0>
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);

						pxNFee->xControl.eMode =  sFeeWaitingSync;
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
					} else {
						pxNFee->xControl.eMode =  sNextPatternIteration;
8110f88c:	d0a05317 	ldw	r2,-32436(gp)
8110f890:	00c00284 	movi	r3,10
8110f894:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
8110f898:	d0a05317 	ldw	r2,-32436(gp)
8110f89c:	00c00304 	movi	r3,12
8110f8a0:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
8110f8a4:	00005b06 	br	8110fa14 <vFeeTask+0x17f0>
						pxNFee->xControl.eMode =  sNextPatternIteration;
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
					}

				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
8110f8a8:	d0a05317 	ldw	r2,-32436(gp)
8110f8ac:	00c00304 	movi	r3,12
8110f8b0:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110f8b4:	d0a05317 	ldw	r2,-32436(gp)
8110f8b8:	00c00184 	movi	r3,6
8110f8bc:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110f8c0:	00005406 	br	8110fa14 <vFeeTask+0x17f0>

			case sFeeWaitingSync:

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f8c4:	00a045f4 	movhi	r2,33047
8110f8c8:	10a25304 	addi	r2,r2,-30388
8110f8cc:	10800a8b 	ldhu	r2,42(r2)
8110f8d0:	10bfffcc 	andi	r2,r2,65535
8110f8d4:	10800168 	cmpgeui	r2,r2,5
8110f8d8:	1000091e 	bne	r2,zero,8110f900 <vFeeTask+0x16dc>
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
8110f8dc:	d0e06217 	ldw	r3,-32376(gp)
8110f8e0:	d0a05317 	ldw	r2,-32436(gp)
8110f8e4:	10800003 	ldbu	r2,0(r2)
8110f8e8:	10803fcc 	andi	r2,r2,255
8110f8ec:	100d883a 	mov	r6,r2
8110f8f0:	01604574 	movhi	r5,33045
8110f8f4:	29794e04 	addi	r5,r5,-6856
8110f8f8:	1809883a 	mov	r4,r3
8110f8fc:	11232a00 	call	811232a0 <fprintf>
				}
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110f900:	d0a05317 	ldw	r2,-32436(gp)
8110f904:	10800003 	ldbu	r2,0(r2)
8110f908:	10803fcc 	andi	r2,r2,255
8110f90c:	1085883a 	add	r2,r2,r2
8110f910:	1087883a 	add	r3,r2,r2
8110f914:	d0a06a04 	addi	r2,gp,-32344
8110f918:	1885883a 	add	r2,r3,r2
8110f91c:	10800017 	ldw	r2,0(r2)
8110f920:	e0fffd04 	addi	r3,fp,-12
8110f924:	180d883a 	mov	r6,r3
8110f928:	000b883a 	mov	r5,zero
8110f92c:	1009883a 	mov	r4,r2
8110f930:	113f8640 	call	8113f864 <OSQPend>
8110f934:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8110f938:	e0bffd03 	ldbu	r2,-12(fp)
8110f93c:	10803fcc 	andi	r2,r2,255
8110f940:	10001026 	beq	r2,zero,8110f984 <vFeeTask+0x1760>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f944:	00a045f4 	movhi	r2,33047
8110f948:	10a25304 	addi	r2,r2,-30388
8110f94c:	10800a8b 	ldhu	r2,42(r2)
8110f950:	10bfffcc 	andi	r2,r2,65535
8110f954:	10800228 	cmpgeui	r2,r2,8
8110f958:	10002b1e 	bne	r2,zero,8110fa08 <vFeeTask+0x17e4>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
8110f95c:	d0e06217 	ldw	r3,-32376(gp)
8110f960:	d0a05317 	ldw	r2,-32436(gp)
8110f964:	10800003 	ldbu	r2,0(r2)
8110f968:	10803fcc 	andi	r2,r2,255
8110f96c:	100d883a 	mov	r6,r2
8110f970:	01604574 	movhi	r5,33045
8110f974:	29795704 	addi	r5,r5,-6820
8110f978:	1809883a 	mov	r4,r3
8110f97c:	11232a00 	call	811232a0 <fprintf>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110f980:	00002106 	br	8110fa08 <vFeeTask+0x17e4>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					}
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
8110f984:	d0a05317 	ldw	r2,-32436(gp)
8110f988:	e0fffe17 	ldw	r3,-8(fp)
8110f98c:	180b883a 	mov	r5,r3
8110f990:	1009883a 	mov	r4,r2
8110f994:	110fa180 	call	8110fa18 <vQCmdFEEinWaitingSync>
				}

				break;
8110f998:	00001b06 	br	8110fa08 <vFeeTask+0x17e4>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110f99c:	d0a05317 	ldw	r2,-32436(gp)
8110f9a0:	00c00144 	movi	r3,5
8110f9a4:	10c02c15 	stw	r3,176(r2)
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f9a8:	00a045f4 	movhi	r2,33047
8110f9ac:	10a25304 	addi	r2,r2,-30388
8110f9b0:	10800a8b 	ldhu	r2,42(r2)
8110f9b4:	10bfffcc 	andi	r2,r2,65535
8110f9b8:	10800228 	cmpgeui	r2,r2,8
8110f9bc:	1000141e 	bne	r2,zero,8110fa10 <vFeeTask+0x17ec>
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110f9c0:	d0e06217 	ldw	r3,-32376(gp)
8110f9c4:	d0a05317 	ldw	r2,-32436(gp)
8110f9c8:	10800003 	ldbu	r2,0(r2)
8110f9cc:	10803fcc 	andi	r2,r2,255
8110f9d0:	100d883a 	mov	r6,r2
8110f9d4:	01604574 	movhi	r5,33045
8110f9d8:	29796804 	addi	r5,r5,-6752
8110f9dc:	1809883a 	mov	r4,r3
8110f9e0:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				break;
8110f9e4:	00000a06 	br	8110fa10 <vFeeTask+0x17ec>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f9e8:	0001883a 	nop
8110f9ec:	003a2e06 	br	8110e2a8 <__reset+0xfb0ee2a8>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f9f0:	0001883a 	nop
8110f9f4:	003a2c06 	br	8110e2a8 <__reset+0xfb0ee2a8>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8110f9f8:	0001883a 	nop
8110f9fc:	003a2a06 	br	8110e2a8 <__reset+0xfb0ee2a8>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110fa00:	0001883a 	nop
8110fa04:	003a2806 	br	8110e2a8 <__reset+0xfb0ee2a8>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110fa08:	0001883a 	nop
8110fa0c:	003a2606 	br	8110e2a8 <__reset+0xfb0ee2a8>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				}
				#endif
				break;
8110fa10:	0001883a 	nop
		}

	}
8110fa14:	003a2406 	br	8110e2a8 <__reset+0xfb0ee2a8>

8110fa18 <vQCmdFEEinWaitingSync>:

}

void vQCmdFEEinWaitingSync( TNFee *pxNFeeP, unsigned int cmd ) {
8110fa18:	defffb04 	addi	sp,sp,-20
8110fa1c:	de00012e 	bgeu	sp,et,8110fa24 <vQCmdFEEinWaitingSync+0xc>
8110fa20:	003b68fa 	trap	3
8110fa24:	dfc00415 	stw	ra,16(sp)
8110fa28:	df000315 	stw	fp,12(sp)
8110fa2c:	df000304 	addi	fp,sp,12
8110fa30:	e13ffe15 	stw	r4,-8(fp)
8110fa34:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110fa38:	e0bfff17 	ldw	r2,-4(fp)
8110fa3c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110fa40:	e0bffdc3 	ldbu	r2,-9(fp)
8110fa44:	10c03fcc 	andi	r3,r2,255
8110fa48:	e0bffe17 	ldw	r2,-8(fp)
8110fa4c:	10800003 	ldbu	r2,0(r2)
8110fa50:	10803fcc 	andi	r2,r2,255
8110fa54:	10800444 	addi	r2,r2,17
8110fa58:	18806f1e 	bne	r3,r2,8110fc18 <vQCmdFEEinWaitingSync+0x200>

		switch (uiCmdFEEL.ucByte[2]) {
8110fa5c:	e0bffd83 	ldbu	r2,-10(fp)
8110fa60:	10803fcc 	andi	r2,r2,255
8110fa64:	10c02860 	cmpeqi	r3,r2,161
8110fa68:	18001a1e 	bne	r3,zero,8110fad4 <vQCmdFEEinWaitingSync+0xbc>
8110fa6c:	10c02888 	cmpgei	r3,r2,162
8110fa70:	18000c1e 	bne	r3,zero,8110faa4 <vQCmdFEEinWaitingSync+0x8c>
8110fa74:	10c00120 	cmpeqi	r3,r2,4
8110fa78:	18001f1e 	bne	r3,zero,8110faf8 <vQCmdFEEinWaitingSync+0xe0>
8110fa7c:	10c00148 	cmpgei	r3,r2,5
8110fa80:	1800031e 	bne	r3,zero,8110fa90 <vQCmdFEEinWaitingSync+0x78>
8110fa84:	10800060 	cmpeqi	r2,r2,1
8110fa88:	1000121e 	bne	r2,zero,8110fad4 <vQCmdFEEinWaitingSync+0xbc>
8110fa8c:	00005206 	br	8110fbd8 <vQCmdFEEinWaitingSync+0x1c0>
8110fa90:	10c00220 	cmpeqi	r3,r2,8
8110fa94:	1800221e 	bne	r3,zero,8110fb20 <vQCmdFEEinWaitingSync+0x108>
8110fa98:	108023e0 	cmpeqi	r2,r2,143
8110fa9c:	1000441e 	bne	r2,zero,8110fbb0 <vQCmdFEEinWaitingSync+0x198>
8110faa0:	00004d06 	br	8110fbd8 <vQCmdFEEinWaitingSync+0x1c0>
8110faa4:	10c03888 	cmpgei	r3,r2,226
8110faa8:	1800071e 	bne	r3,zero,8110fac8 <vQCmdFEEinWaitingSync+0xb0>
8110faac:	10c03808 	cmpgei	r3,r2,224
8110fab0:	1800381e 	bne	r3,zero,8110fb94 <vQCmdFEEinWaitingSync+0x17c>
8110fab4:	10c02920 	cmpeqi	r3,r2,164
8110fab8:	18000f1e 	bne	r3,zero,8110faf8 <vQCmdFEEinWaitingSync+0xe0>
8110fabc:	10802a20 	cmpeqi	r2,r2,168
8110fac0:	1000171e 	bne	r2,zero,8110fb20 <vQCmdFEEinWaitingSync+0x108>
8110fac4:	00004406 	br	8110fbd8 <vQCmdFEEinWaitingSync+0x1c0>
8110fac8:	10803c20 	cmpeqi	r2,r2,240
8110facc:	10001e1e 	bne	r2,zero,8110fb48 <vQCmdFEEinWaitingSync+0x130>
8110fad0:	00004106 	br	8110fbd8 <vQCmdFEEinWaitingSync+0x1c0>
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110fad4:	e0bffe17 	ldw	r2,-8(fp)
8110fad8:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110fadc:	e0bffe17 	ldw	r2,-8(fp)
8110fae0:	00c00144 	movi	r3,5
8110fae4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110fae8:	e0bffe17 	ldw	r2,-8(fp)
8110faec:	00c00144 	movi	r3,5
8110faf0:	10c02d15 	stw	r3,180(r2)
				break;
8110faf4:	00004806 	br	8110fc18 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110faf8:	e0bffe17 	ldw	r2,-8(fp)
8110fafc:	00c00044 	movi	r3,1
8110fb00:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8110fb04:	e0bffe17 	ldw	r2,-8(fp)
8110fb08:	00c00304 	movi	r3,12
8110fb0c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110fb10:	e0bffe17 	ldw	r2,-8(fp)
8110fb14:	00c00184 	movi	r3,6
8110fb18:	10c02d15 	stw	r3,180(r2)
				break;
8110fb1c:	00003e06 	br	8110fc18 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110fb20:	e0bffe17 	ldw	r2,-8(fp)
8110fb24:	00c00044 	movi	r3,1
8110fb28:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110fb2c:	e0bffe17 	ldw	r2,-8(fp)
8110fb30:	00c00284 	movi	r3,10
8110fb34:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110fb38:	e0bffe17 	ldw	r2,-8(fp)
8110fb3c:	00c00304 	movi	r3,12
8110fb40:	10c02d15 	stw	r3,180(r2)
				break;
8110fb44:	00003406 	br	8110fc18 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_RMAP:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110fb48:	00a045f4 	movhi	r2,33047
8110fb4c:	10a25304 	addi	r2,r2,-30388
8110fb50:	10800a8b 	ldhu	r2,42(r2)
8110fb54:	10bfffcc 	andi	r2,r2,65535
8110fb58:	108000e8 	cmpgeui	r2,r2,3
8110fb5c:	1000091e 	bne	r2,zero,8110fb84 <vQCmdFEEinWaitingSync+0x16c>
					fprintf(fp,"\nNFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
8110fb60:	d0e06217 	ldw	r3,-32376(gp)
8110fb64:	e0bffe17 	ldw	r2,-8(fp)
8110fb68:	10800003 	ldbu	r2,0(r2)
8110fb6c:	10803fcc 	andi	r2,r2,255
8110fb70:	100d883a 	mov	r6,r2
8110fb74:	01604574 	movhi	r5,33045
8110fb78:	29797304 	addi	r5,r5,-6708
8110fb7c:	1809883a 	mov	r4,r3
8110fb80:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPWaitingSync( pxNFeeP, cmd );
8110fb84:	e17fff17 	ldw	r5,-4(fp)
8110fb88:	e13ffe17 	ldw	r4,-8(fp)
8110fb8c:	1110fc00 	call	81110fc0 <vQCmdFeeRMAPWaitingSync>
				break;
8110fb90:	00002106 	br	8110fc18 <vQCmdFEEinWaitingSync+0x200>
			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110fb94:	e0bffe17 	ldw	r2,-8(fp)
8110fb98:	10c02d17 	ldw	r3,180(r2)
8110fb9c:	e0bffe17 	ldw	r2,-8(fp)
8110fba0:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110fba4:	e0bffe17 	ldw	r2,-8(fp)
8110fba8:	10002815 	stw	zero,160(r2)

				break;
8110fbac:	00001a06 	br	8110fc18 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110fbb0:	e0bffe17 	ldw	r2,-8(fp)
8110fbb4:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110fbb8:	e0bffe17 	ldw	r2,-8(fp)
8110fbbc:	10800003 	ldbu	r2,0(r2)
8110fbc0:	10803fcc 	andi	r2,r2,255
8110fbc4:	100d883a 	mov	r6,r2
8110fbc8:	000b883a 	mov	r5,zero
8110fbcc:	01002044 	movi	r4,129
8110fbd0:	11118580 	call	81111858 <bSendGiveBackNFeeCtrl>
				break;
8110fbd4:	00001006 	br	8110fc18 <vQCmdFEEinWaitingSync+0x200>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110fbd8:	00a045f4 	movhi	r2,33047
8110fbdc:	10a25304 	addi	r2,r2,-30388
8110fbe0:	10800a8b 	ldhu	r2,42(r2)
8110fbe4:	10bfffcc 	andi	r2,r2,65535
8110fbe8:	10800228 	cmpgeui	r2,r2,8
8110fbec:	1000091e 	bne	r2,zero,8110fc14 <vQCmdFEEinWaitingSync+0x1fc>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110fbf0:	d0e06217 	ldw	r3,-32376(gp)
8110fbf4:	e0bffe17 	ldw	r2,-8(fp)
8110fbf8:	10800003 	ldbu	r2,0(r2)
8110fbfc:	10803fcc 	andi	r2,r2,255
8110fc00:	100d883a 	mov	r6,r2
8110fc04:	01604574 	movhi	r5,33045
8110fc08:	29797b04 	addi	r5,r5,-6676
8110fc0c:	1809883a 	mov	r4,r3
8110fc10:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				break;
8110fc14:	0001883a 	nop
		}
	}
}
8110fc18:	0001883a 	nop
8110fc1c:	e037883a 	mov	sp,fp
8110fc20:	dfc00117 	ldw	ra,4(sp)
8110fc24:	df000017 	ldw	fp,0(sp)
8110fc28:	dec00204 	addi	sp,sp,8
8110fc2c:	f800283a 	ret

8110fc30 <vQCmdFEEinConfig>:


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110fc30:	defffb04 	addi	sp,sp,-20
8110fc34:	de00012e 	bgeu	sp,et,8110fc3c <vQCmdFEEinConfig+0xc>
8110fc38:	003b68fa 	trap	3
8110fc3c:	dfc00415 	stw	ra,16(sp)
8110fc40:	df000315 	stw	fp,12(sp)
8110fc44:	df000304 	addi	fp,sp,12
8110fc48:	e13ffe15 	stw	r4,-8(fp)
8110fc4c:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110fc50:	e0bfff17 	ldw	r2,-4(fp)
8110fc54:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110fc58:	e0bffdc3 	ldbu	r2,-9(fp)
8110fc5c:	10c03fcc 	andi	r3,r2,255
8110fc60:	e0bffe17 	ldw	r2,-8(fp)
8110fc64:	10800003 	ldbu	r2,0(r2)
8110fc68:	10803fcc 	andi	r2,r2,255
8110fc6c:	10800444 	addi	r2,r2,17
8110fc70:	18807a1e 	bne	r3,r2,8110fe5c <vQCmdFEEinConfig+0x22c>

		switch (uiCmdFEEL.ucByte[2]) {
8110fc74:	e0bffd83 	ldbu	r2,-10(fp)
8110fc78:	10803fcc 	andi	r2,r2,255
8110fc7c:	10c02860 	cmpeqi	r3,r2,161
8110fc80:	18001a1e 	bne	r3,zero,8110fcec <vQCmdFEEinConfig+0xbc>
8110fc84:	10c02888 	cmpgei	r3,r2,162
8110fc88:	18000c1e 	bne	r3,zero,8110fcbc <vQCmdFEEinConfig+0x8c>
8110fc8c:	10c00120 	cmpeqi	r3,r2,4
8110fc90:	1800261e 	bne	r3,zero,8110fd2c <vQCmdFEEinConfig+0xfc>
8110fc94:	10c00148 	cmpgei	r3,r2,5
8110fc98:	1800031e 	bne	r3,zero,8110fca8 <vQCmdFEEinConfig+0x78>
8110fc9c:	10800060 	cmpeqi	r2,r2,1
8110fca0:	1000121e 	bne	r2,zero,8110fcec <vQCmdFEEinConfig+0xbc>
8110fca4:	00005406 	br	8110fdf8 <vQCmdFEEinConfig+0x1c8>
8110fca8:	10c00220 	cmpeqi	r3,r2,8
8110fcac:	1800281e 	bne	r3,zero,8110fd50 <vQCmdFEEinConfig+0x120>
8110fcb0:	108023e0 	cmpeqi	r2,r2,143
8110fcb4:	1000461e 	bne	r2,zero,8110fdd0 <vQCmdFEEinConfig+0x1a0>
8110fcb8:	00004f06 	br	8110fdf8 <vQCmdFEEinConfig+0x1c8>
8110fcbc:	10c03888 	cmpgei	r3,r2,226
8110fcc0:	1800071e 	bne	r3,zero,8110fce0 <vQCmdFEEinConfig+0xb0>
8110fcc4:	10c03808 	cmpgei	r3,r2,224
8110fcc8:	18005b1e 	bne	r3,zero,8110fe38 <vQCmdFEEinConfig+0x208>
8110fccc:	10c02920 	cmpeqi	r3,r2,164
8110fcd0:	1800161e 	bne	r3,zero,8110fd2c <vQCmdFEEinConfig+0xfc>
8110fcd4:	10802a20 	cmpeqi	r2,r2,168
8110fcd8:	10001d1e 	bne	r2,zero,8110fd50 <vQCmdFEEinConfig+0x120>
8110fcdc:	00004606 	br	8110fdf8 <vQCmdFEEinConfig+0x1c8>
8110fce0:	10803c20 	cmpeqi	r2,r2,240
8110fce4:	10002a1e 	bne	r2,zero,8110fd90 <vQCmdFEEinConfig+0x160>
8110fce8:	00004306 	br	8110fdf8 <vQCmdFEEinConfig+0x1c8>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110fcec:	00a045f4 	movhi	r2,33047
8110fcf0:	10a25304 	addi	r2,r2,-30388
8110fcf4:	10800a8b 	ldhu	r2,42(r2)
8110fcf8:	10bfffcc 	andi	r2,r2,65535
8110fcfc:	10800168 	cmpgeui	r2,r2,5
8110fd00:	10004f1e 	bne	r2,zero,8110fe40 <vQCmdFEEinConfig+0x210>
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110fd04:	d0e06217 	ldw	r3,-32376(gp)
8110fd08:	e0bffe17 	ldw	r2,-8(fp)
8110fd0c:	10800003 	ldbu	r2,0(r2)
8110fd10:	10803fcc 	andi	r2,r2,255
8110fd14:	100d883a 	mov	r6,r2
8110fd18:	01604574 	movhi	r5,33045
8110fd1c:	29798c04 	addi	r5,r5,-6608
8110fd20:	1809883a 	mov	r4,r3
8110fd24:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				break;
8110fd28:	00004506 	br	8110fe40 <vQCmdFEEinConfig+0x210>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				break;*/
			case M_FEE_STANDBY: /* Config -> StandBy is always forced mode (don't need sync) */
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110fd2c:	e0bffe17 	ldw	r2,-8(fp)
8110fd30:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110fd34:	e0bffe17 	ldw	r2,-8(fp)
8110fd38:	00c00184 	movi	r3,6
8110fd3c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110fd40:	e0bffe17 	ldw	r2,-8(fp)
8110fd44:	00c00184 	movi	r3,6
8110fd48:	10c02d15 	stw	r3,180(r2)
				break;				
8110fd4c:	00004306 	br	8110fe5c <vQCmdFEEinConfig+0x22c>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110fd50:	00a045f4 	movhi	r2,33047
8110fd54:	10a25304 	addi	r2,r2,-30388
8110fd58:	10800a8b 	ldhu	r2,42(r2)
8110fd5c:	10bfffcc 	andi	r2,r2,65535
8110fd60:	10800168 	cmpgeui	r2,r2,5
8110fd64:	1000381e 	bne	r2,zero,8110fe48 <vQCmdFEEinConfig+0x218>
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110fd68:	d0e06217 	ldw	r3,-32376(gp)
8110fd6c:	e0bffe17 	ldw	r2,-8(fp)
8110fd70:	10800003 	ldbu	r2,0(r2)
8110fd74:	10803fcc 	andi	r2,r2,255
8110fd78:	100d883a 	mov	r6,r2
8110fd7c:	01604574 	movhi	r5,33045
8110fd80:	29799704 	addi	r5,r5,-6564
8110fd84:	1809883a 	mov	r4,r3
8110fd88:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				break;
8110fd8c:	00002e06 	br	8110fe48 <vQCmdFEEinConfig+0x218>
			case M_FEE_RMAP:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110fd90:	00a045f4 	movhi	r2,33047
8110fd94:	10a25304 	addi	r2,r2,-30388
8110fd98:	10800a8b 	ldhu	r2,42(r2)
8110fd9c:	10bfffcc 	andi	r2,r2,65535
8110fda0:	10800168 	cmpgeui	r2,r2,5
8110fda4:	10002a1e 	bne	r2,zero,8110fe50 <vQCmdFEEinConfig+0x220>
					fprintf(fp,"NFEE %hhu Task: Can't threat RMAP Messages in this mode (Config)\n", pxNFeeP->ucId);
8110fda8:	d0e06217 	ldw	r3,-32376(gp)
8110fdac:	e0bffe17 	ldw	r2,-8(fp)
8110fdb0:	10800003 	ldbu	r2,0(r2)
8110fdb4:	10803fcc 	andi	r2,r2,255
8110fdb8:	100d883a 	mov	r6,r2
8110fdbc:	01604574 	movhi	r5,33045
8110fdc0:	2979a804 	addi	r5,r5,-6496
8110fdc4:	1809883a 	mov	r4,r3
8110fdc8:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				break;
8110fdcc:	00002006 	br	8110fe50 <vQCmdFEEinConfig+0x220>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110fdd0:	e0bffe17 	ldw	r2,-8(fp)
8110fdd4:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110fdd8:	e0bffe17 	ldw	r2,-8(fp)
8110fddc:	10800003 	ldbu	r2,0(r2)
8110fde0:	10803fcc 	andi	r2,r2,255
8110fde4:	100d883a 	mov	r6,r2
8110fde8:	000b883a 	mov	r5,zero
8110fdec:	01002044 	movi	r4,129
8110fdf0:	11118580 	call	81111858 <bSendGiveBackNFeeCtrl>
				break;
8110fdf4:	00001906 	br	8110fe5c <vQCmdFEEinConfig+0x22c>
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110fdf8:	00a045f4 	movhi	r2,33047
8110fdfc:	10a25304 	addi	r2,r2,-30388
8110fe00:	10800a8b 	ldhu	r2,42(r2)
8110fe04:	10bfffcc 	andi	r2,r2,65535
8110fe08:	10800228 	cmpgeui	r2,r2,8
8110fe0c:	1000121e 	bne	r2,zero,8110fe58 <vQCmdFEEinConfig+0x228>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (Config)\n", pxNFeeP->ucId);
8110fe10:	d0e06217 	ldw	r3,-32376(gp)
8110fe14:	e0bffe17 	ldw	r2,-8(fp)
8110fe18:	10800003 	ldbu	r2,0(r2)
8110fe1c:	10803fcc 	andi	r2,r2,255
8110fe20:	100d883a 	mov	r6,r2
8110fe24:	01604574 	movhi	r5,33045
8110fe28:	2979b904 	addi	r5,r5,-6428
8110fe2c:	1809883a 	mov	r4,r3
8110fe30:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				break;
8110fe34:	00000806 	br	8110fe58 <vQCmdFEEinConfig+0x228>
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
				break;
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
8110fe38:	0001883a 	nop
8110fe3c:	00000706 	br	8110fe5c <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110fe40:	0001883a 	nop
8110fe44:	00000506 	br	8110fe5c <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110fe48:	0001883a 	nop
8110fe4c:	00000306 	br	8110fe5c <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task: Can't threat RMAP Messages in this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110fe50:	0001883a 	nop
8110fe54:	00000106 	br	8110fe5c <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110fe58:	0001883a 	nop
		}
	}
}
8110fe5c:	0001883a 	nop
8110fe60:	e037883a 	mov	sp,fp
8110fe64:	dfc00117 	ldw	ra,4(sp)
8110fe68:	df000017 	ldw	fp,0(sp)
8110fe6c:	dec00204 	addi	sp,sp,8
8110fe70:	f800283a 	ret

8110fe74 <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110fe74:	defffb04 	addi	sp,sp,-20
8110fe78:	de00012e 	bgeu	sp,et,8110fe80 <vQCmdFEEinStandBy+0xc>
8110fe7c:	003b68fa 	trap	3
8110fe80:	dfc00415 	stw	ra,16(sp)
8110fe84:	df000315 	stw	fp,12(sp)
8110fe88:	df000304 	addi	fp,sp,12
8110fe8c:	e13ffe15 	stw	r4,-8(fp)
8110fe90:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110fe94:	e0bfff17 	ldw	r2,-4(fp)
8110fe98:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110fe9c:	e0bffdc3 	ldbu	r2,-9(fp)
8110fea0:	10c03fcc 	andi	r3,r2,255
8110fea4:	e0bffe17 	ldw	r2,-8(fp)
8110fea8:	10800003 	ldbu	r2,0(r2)
8110feac:	10803fcc 	andi	r2,r2,255
8110feb0:	10800444 	addi	r2,r2,17
8110feb4:	1880801e 	bne	r3,r2,811100b8 <vQCmdFEEinStandBy+0x244>

		switch (uiCmdFEEL.ucByte[2]) {
8110feb8:	e0bffd83 	ldbu	r2,-10(fp)
8110febc:	10803fcc 	andi	r2,r2,255
8110fec0:	10c02860 	cmpeqi	r3,r2,161
8110fec4:	18001a1e 	bne	r3,zero,8110ff30 <vQCmdFEEinStandBy+0xbc>
8110fec8:	10c02888 	cmpgei	r3,r2,162
8110fecc:	18000c1e 	bne	r3,zero,8110ff00 <vQCmdFEEinStandBy+0x8c>
8110fed0:	10c00120 	cmpeqi	r3,r2,4
8110fed4:	18001f1e 	bne	r3,zero,8110ff54 <vQCmdFEEinStandBy+0xe0>
8110fed8:	10c00148 	cmpgei	r3,r2,5
8110fedc:	1800031e 	bne	r3,zero,8110feec <vQCmdFEEinStandBy+0x78>
8110fee0:	10800060 	cmpeqi	r2,r2,1
8110fee4:	1000121e 	bne	r2,zero,8110ff30 <vQCmdFEEinStandBy+0xbc>
8110fee8:	00005c06 	br	8111005c <vQCmdFEEinStandBy+0x1e8>
8110feec:	10c00220 	cmpeqi	r3,r2,8
8110fef0:	1800281e 	bne	r3,zero,8110ff94 <vQCmdFEEinStandBy+0x120>
8110fef4:	108023e0 	cmpeqi	r2,r2,143
8110fef8:	10004e1e 	bne	r2,zero,81110034 <vQCmdFEEinStandBy+0x1c0>
8110fefc:	00005706 	br	8111005c <vQCmdFEEinStandBy+0x1e8>
8110ff00:	10c03888 	cmpgei	r3,r2,226
8110ff04:	1800071e 	bne	r3,zero,8110ff24 <vQCmdFEEinStandBy+0xb0>
8110ff08:	10c03808 	cmpgei	r3,r2,224
8110ff0c:	18003e1e 	bne	r3,zero,81110008 <vQCmdFEEinStandBy+0x194>
8110ff10:	10c02920 	cmpeqi	r3,r2,164
8110ff14:	18000f1e 	bne	r3,zero,8110ff54 <vQCmdFEEinStandBy+0xe0>
8110ff18:	10802a20 	cmpeqi	r2,r2,168
8110ff1c:	10001d1e 	bne	r2,zero,8110ff94 <vQCmdFEEinStandBy+0x120>
8110ff20:	00004e06 	br	8111005c <vQCmdFEEinStandBy+0x1e8>
8110ff24:	10803c20 	cmpeqi	r2,r2,240
8110ff28:	1000241e 	bne	r2,zero,8110ffbc <vQCmdFEEinStandBy+0x148>
8110ff2c:	00004b06 	br	8111005c <vQCmdFEEinStandBy+0x1e8>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110ff30:	e0bffe17 	ldw	r2,-8(fp)
8110ff34:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110ff38:	e0bffe17 	ldw	r2,-8(fp)
8110ff3c:	00c00144 	movi	r3,5
8110ff40:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110ff44:	e0bffe17 	ldw	r2,-8(fp)
8110ff48:	00c00144 	movi	r3,5
8110ff4c:	10c02d15 	stw	r3,180(r2)
				break;				
8110ff50:	00005906 	br	811100b8 <vQCmdFEEinStandBy+0x244>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110ff54:	00a045f4 	movhi	r2,33047
8110ff58:	10a25304 	addi	r2,r2,-30388
8110ff5c:	10800a8b 	ldhu	r2,42(r2)
8110ff60:	10bfffcc 	andi	r2,r2,65535
8110ff64:	10800168 	cmpgeui	r2,r2,5
8110ff68:	10004c1e 	bne	r2,zero,8111009c <vQCmdFEEinStandBy+0x228>
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by\n", pxNFeeP->ucId);
8110ff6c:	d0e06217 	ldw	r3,-32376(gp)
8110ff70:	e0bffe17 	ldw	r2,-8(fp)
8110ff74:	10800003 	ldbu	r2,0(r2)
8110ff78:	10803fcc 	andi	r2,r2,255
8110ff7c:	100d883a 	mov	r6,r2
8110ff80:	01604574 	movhi	r5,33045
8110ff84:	2979c804 	addi	r5,r5,-6368
8110ff88:	1809883a 	mov	r4,r3
8110ff8c:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				break;
8110ff90:	00004206 	br	8111009c <vQCmdFEEinStandBy+0x228>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110ff94:	e0bffe17 	ldw	r2,-8(fp)
8110ff98:	00c00044 	movi	r3,1
8110ff9c:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110ffa0:	e0bffe17 	ldw	r2,-8(fp)
8110ffa4:	00c00284 	movi	r3,10
8110ffa8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110ffac:	e0bffe17 	ldw	r2,-8(fp)
8110ffb0:	00c00304 	movi	r3,12
8110ffb4:	10c02d15 	stw	r3,180(r2)
				break;
8110ffb8:	00003f06 	br	811100b8 <vQCmdFEEinStandBy+0x244>

			case M_FEE_RMAP:
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
8110ffbc:	e17fff17 	ldw	r5,-4(fp)
8110ffc0:	e13ffe17 	ldw	r4,-8(fp)
8110ffc4:	11103580 	call	81110358 <vQCmdFeeRMAPinStandBy>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110ffc8:	00a045f4 	movhi	r2,33047
8110ffcc:	10a25304 	addi	r2,r2,-30388
8110ffd0:	10800a8b 	ldhu	r2,42(r2)
8110ffd4:	10bfffcc 	andi	r2,r2,65535
8110ffd8:	10800168 	cmpgeui	r2,r2,5
8110ffdc:	1000311e 	bne	r2,zero,811100a4 <vQCmdFEEinStandBy+0x230>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
8110ffe0:	d0e06217 	ldw	r3,-32376(gp)
8110ffe4:	e0bffe17 	ldw	r2,-8(fp)
8110ffe8:	10800003 	ldbu	r2,0(r2)
8110ffec:	10803fcc 	andi	r2,r2,255
8110fff0:	100d883a 	mov	r6,r2
8110fff4:	01604574 	movhi	r5,33045
8110fff8:	2979d204 	addi	r5,r5,-6328
8110fffc:	1809883a 	mov	r4,r3
81110000:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
81110004:	00002706 	br	811100a4 <vQCmdFEEinStandBy+0x230>


			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
81110008:	e0bffe17 	ldw	r2,-8(fp)
8111000c:	10802c17 	ldw	r2,176(r2)
81110010:	10800318 	cmpnei	r2,r2,12
81110014:	1000251e 	bne	r2,zero,811100ac <vQCmdFEEinStandBy+0x238>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
81110018:	e0bffe17 	ldw	r2,-8(fp)
8111001c:	10c02d17 	ldw	r3,180(r2)
81110020:	e0bffe17 	ldw	r2,-8(fp)
81110024:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
81110028:	e0bffe17 	ldw	r2,-8(fp)
8111002c:	10002815 	stw	zero,160(r2)
				}
				break;
81110030:	00001e06 	br	811100ac <vQCmdFEEinStandBy+0x238>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
81110034:	e0bffe17 	ldw	r2,-8(fp)
81110038:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8111003c:	e0bffe17 	ldw	r2,-8(fp)
81110040:	10800003 	ldbu	r2,0(r2)
81110044:	10803fcc 	andi	r2,r2,255
81110048:	100d883a 	mov	r6,r2
8111004c:	000b883a 	mov	r5,zero
81110050:	01002044 	movi	r4,129
81110054:	11118580 	call	81111858 <bSendGiveBackNFeeCtrl>
				break;
81110058:	00001706 	br	811100b8 <vQCmdFEEinStandBy+0x244>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111005c:	00a045f4 	movhi	r2,33047
81110060:	10a25304 	addi	r2,r2,-30388
81110064:	10800a8b 	ldhu	r2,42(r2)
81110068:	10bfffcc 	andi	r2,r2,65535
8111006c:	10800228 	cmpgeui	r2,r2,8
81110070:	1000101e 	bne	r2,zero,811100b4 <vQCmdFEEinStandBy+0x240>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
81110074:	d0e06217 	ldw	r3,-32376(gp)
81110078:	e0bffe17 	ldw	r2,-8(fp)
8111007c:	10800003 	ldbu	r2,0(r2)
81110080:	10803fcc 	andi	r2,r2,255
81110084:	100d883a 	mov	r6,r2
81110088:	01604574 	movhi	r5,33045
8111008c:	29797b04 	addi	r5,r5,-6676
81110090:	1809883a 	mov	r4,r3
81110094:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				break;
81110098:	00000606 	br	811100b4 <vQCmdFEEinStandBy+0x240>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by\n", pxNFeeP->ucId);
				}
				#endif
				break;
8111009c:	0001883a 	nop
811100a0:	00000506 	br	811100b8 <vQCmdFEEinStandBy+0x244>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
811100a4:	0001883a 	nop
811100a8:	00000306 	br	811100b8 <vQCmdFEEinStandBy+0x244>
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}
				break;
811100ac:	0001883a 	nop
811100b0:	00000106 	br	811100b8 <vQCmdFEEinStandBy+0x244>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
811100b4:	0001883a 	nop
		}
	}
}
811100b8:	0001883a 	nop
811100bc:	e037883a 	mov	sp,fp
811100c0:	dfc00117 	ldw	ra,4(sp)
811100c4:	df000017 	ldw	fp,0(sp)
811100c8:	dec00204 	addi	sp,sp,8
811100cc:	f800283a 	ret

811100d0 <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
811100d0:	defffb04 	addi	sp,sp,-20
811100d4:	de00012e 	bgeu	sp,et,811100dc <vQCmdFEEinFullPattern+0xc>
811100d8:	003b68fa 	trap	3
811100dc:	dfc00415 	stw	ra,16(sp)
811100e0:	df000315 	stw	fp,12(sp)
811100e4:	df000304 	addi	fp,sp,12
811100e8:	e13ffe15 	stw	r4,-8(fp)
811100ec:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
811100f0:	e0bfff17 	ldw	r2,-4(fp)
811100f4:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
811100f8:	e0bffdc3 	ldbu	r2,-9(fp)
811100fc:	10c03fcc 	andi	r3,r2,255
81110100:	e0bffe17 	ldw	r2,-8(fp)
81110104:	10800003 	ldbu	r2,0(r2)
81110108:	10803fcc 	andi	r2,r2,255
8111010c:	10800444 	addi	r2,r2,17
81110110:	18808b1e 	bne	r3,r2,81110340 <vQCmdFEEinFullPattern+0x270>

		switch (uiCmdFEEL.ucByte[2]) {
81110114:	e0bffd83 	ldbu	r2,-10(fp)
81110118:	10803fcc 	andi	r2,r2,255
8111011c:	10c02860 	cmpeqi	r3,r2,161
81110120:	1800181e 	bne	r3,zero,81110184 <vQCmdFEEinFullPattern+0xb4>
81110124:	10c02888 	cmpgei	r3,r2,162
81110128:	18000c1e 	bne	r3,zero,8111015c <vQCmdFEEinFullPattern+0x8c>
8111012c:	10c000a0 	cmpeqi	r3,r2,2
81110130:	18007c1e 	bne	r3,zero,81110324 <vQCmdFEEinFullPattern+0x254>
81110134:	10c000c8 	cmpgei	r3,r2,3
81110138:	1800031e 	bne	r3,zero,81110148 <vQCmdFEEinFullPattern+0x78>
8111013c:	10800060 	cmpeqi	r2,r2,1
81110140:	1000101e 	bne	r2,zero,81110184 <vQCmdFEEinFullPattern+0xb4>
81110144:	00006706 	br	811102e4 <vQCmdFEEinFullPattern+0x214>
81110148:	10c00120 	cmpeqi	r3,r2,4
8111014c:	1800161e 	bne	r3,zero,811101a8 <vQCmdFEEinFullPattern+0xd8>
81110150:	10800220 	cmpeqi	r2,r2,8
81110154:	1000351e 	bne	r2,zero,8111022c <vQCmdFEEinFullPattern+0x15c>
81110158:	00006206 	br	811102e4 <vQCmdFEEinFullPattern+0x214>
8111015c:	10c03888 	cmpgei	r3,r2,226
81110160:	1800051e 	bne	r3,zero,81110178 <vQCmdFEEinFullPattern+0xa8>
81110164:	10c03808 	cmpgei	r3,r2,224
81110168:	1800531e 	bne	r3,zero,811102b8 <vQCmdFEEinFullPattern+0x1e8>
8111016c:	10802920 	cmpeqi	r2,r2,164
81110170:	1000251e 	bne	r2,zero,81110208 <vQCmdFEEinFullPattern+0x138>
81110174:	00005b06 	br	811102e4 <vQCmdFEEinFullPattern+0x214>
81110178:	10803c20 	cmpeqi	r2,r2,240
8111017c:	10003b1e 	bne	r2,zero,8111026c <vQCmdFEEinFullPattern+0x19c>
81110180:	00005806 	br	811102e4 <vQCmdFEEinFullPattern+0x214>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
81110184:	e0bffe17 	ldw	r2,-8(fp)
81110188:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8111018c:	e0bffe17 	ldw	r2,-8(fp)
81110190:	00c00144 	movi	r3,5
81110194:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
81110198:	e0bffe17 	ldw	r2,-8(fp)
8111019c:	00c00144 	movi	r3,5
811101a0:	10c02d15 	stw	r3,180(r2)
				break;				
811101a4:	00006606 	br	81110340 <vQCmdFEEinFullPattern+0x270>
				break;
			case M_FEE_STANDBY:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;*/ /* To finish the actual transfer only when sync comes */
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
811101a8:	e0bffe17 	ldw	r2,-8(fp)
811101ac:	10802c17 	ldw	r2,176(r2)
811101b0:	10800298 	cmpnei	r2,r2,10
811101b4:	10000a1e 	bne	r2,zero,811101e0 <vQCmdFEEinFullPattern+0x110>
					pxNFeeP->xControl.bWatingSync = TRUE;
811101b8:	e0bffe17 	ldw	r2,-8(fp)
811101bc:	00c00044 	movi	r3,1
811101c0:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
811101c4:	e0bffe17 	ldw	r2,-8(fp)
811101c8:	00c00304 	movi	r3,12
811101cc:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
811101d0:	e0bffe17 	ldw	r2,-8(fp)
811101d4:	00c00184 	movi	r3,6
811101d8:	10c02d15 	stw	r3,180(r2)
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				}

				break;
811101dc:	00005806 	br	81110340 <vQCmdFEEinFullPattern+0x270>
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				} else {
					pxNFeeP->xControl.bWatingSync = TRUE;
811101e0:	e0bffe17 	ldw	r2,-8(fp)
811101e4:	00c00044 	movi	r3,1
811101e8:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
811101ec:	e0bffe17 	ldw	r2,-8(fp)
811101f0:	00c00104 	movi	r3,4
811101f4:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
811101f8:	e0bffe17 	ldw	r2,-8(fp)
811101fc:	00c00184 	movi	r3,6
81110200:	10c02d15 	stw	r3,180(r2)
				}

				break;
81110204:	00004e06 	br	81110340 <vQCmdFEEinFullPattern+0x270>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
81110208:	e0bffe17 	ldw	r2,-8(fp)
8111020c:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
81110210:	e0bffe17 	ldw	r2,-8(fp)
81110214:	00c00184 	movi	r3,6
81110218:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8111021c:	e0bffe17 	ldw	r2,-8(fp)
81110220:	00c00184 	movi	r3,6
81110224:	10c02d15 	stw	r3,180(r2)
				break;				
81110228:	00004506 	br	81110340 <vQCmdFEEinFullPattern+0x270>
			case M_FEE_FULL_PATTERN:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8111022c:	00a045f4 	movhi	r2,33047
81110230:	10a25304 	addi	r2,r2,-30388
81110234:	10800a8b 	ldhu	r2,42(r2)
81110238:	10bfffcc 	andi	r2,r2,65535
8111023c:	10800168 	cmpgeui	r2,r2,5
81110240:	10003a1e 	bne	r2,zero,8111032c <vQCmdFEEinFullPattern+0x25c>
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
81110244:	d0e06217 	ldw	r3,-32376(gp)
81110248:	e0bffe17 	ldw	r2,-8(fp)
8111024c:	10800003 	ldbu	r2,0(r2)
81110250:	10803fcc 	andi	r2,r2,255
81110254:	100d883a 	mov	r6,r2
81110258:	01604574 	movhi	r5,33045
8111025c:	2979da04 	addi	r5,r5,-6296
81110260:	1809883a 	mov	r4,r3
81110264:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				break;
81110268:	00003006 	br	8111032c <vQCmdFEEinFullPattern+0x25c>
			case M_FEE_RMAP:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8111026c:	00a045f4 	movhi	r2,33047
81110270:	10a25304 	addi	r2,r2,-30388
81110274:	10800a8b 	ldhu	r2,42(r2)
81110278:	10bfffcc 	andi	r2,r2,65535
8111027c:	10800168 	cmpgeui	r2,r2,5
81110280:	1000091e 	bne	r2,zero,811102a8 <vQCmdFEEinFullPattern+0x1d8>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
81110284:	d0e06217 	ldw	r3,-32376(gp)
81110288:	e0bffe17 	ldw	r2,-8(fp)
8111028c:	10800003 	ldbu	r2,0(r2)
81110290:	10803fcc 	andi	r2,r2,255
81110294:	100d883a 	mov	r6,r2
81110298:	01604574 	movhi	r5,33045
8111029c:	2979d204 	addi	r5,r5,-6328
811102a0:	1809883a 	mov	r4,r3
811102a4:	11232a00 	call	811232a0 <fprintf>
				}
				#endif

				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
811102a8:	e17fff17 	ldw	r5,-4(fp)
811102ac:	e13ffe17 	ldw	r4,-8(fp)
811102b0:	11109dc0 	call	811109dc <vQCmdFeeRMAPinFullPattern>

				break;
811102b4:	00002206 	br	81110340 <vQCmdFEEinFullPattern+0x270>

			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
811102b8:	e0bffe17 	ldw	r2,-8(fp)
811102bc:	10802c17 	ldw	r2,176(r2)
811102c0:	10800318 	cmpnei	r2,r2,12
811102c4:	10001b1e 	bne	r2,zero,81110334 <vQCmdFEEinFullPattern+0x264>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
811102c8:	e0bffe17 	ldw	r2,-8(fp)
811102cc:	10c02d17 	ldw	r3,180(r2)
811102d0:	e0bffe17 	ldw	r2,-8(fp)
811102d4:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
811102d8:	e0bffe17 	ldw	r2,-8(fp)
811102dc:	10002815 	stw	zero,160(r2)
				}

				break;
811102e0:	00001406 	br	81110334 <vQCmdFEEinFullPattern+0x264>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811102e4:	00a045f4 	movhi	r2,33047
811102e8:	10a25304 	addi	r2,r2,-30388
811102ec:	10800a8b 	ldhu	r2,42(r2)
811102f0:	10bfffcc 	andi	r2,r2,65535
811102f4:	10800228 	cmpgeui	r2,r2,8
811102f8:	1000101e 	bne	r2,zero,8111033c <vQCmdFEEinFullPattern+0x26c>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
811102fc:	d0e06217 	ldw	r3,-32376(gp)
81110300:	e0bffe17 	ldw	r2,-8(fp)
81110304:	10800003 	ldbu	r2,0(r2)
81110308:	10803fcc 	andi	r2,r2,255
8111030c:	100d883a 	mov	r6,r2
81110310:	01604574 	movhi	r5,33045
81110314:	2979e804 	addi	r5,r5,-6240
81110318:	1809883a 	mov	r4,r3
8111031c:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				break;
81110320:	00000606 	br	8111033c <vQCmdFEEinFullPattern+0x26c>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
81110324:	0001883a 	nop
81110328:	00000506 	br	81110340 <vQCmdFEEinFullPattern+0x270>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
8111032c:	0001883a 	nop
81110330:	00000306 	br	81110340 <vQCmdFEEinFullPattern+0x270>
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}

				break;
81110334:	0001883a 	nop
81110338:	00000106 	br	81110340 <vQCmdFEEinFullPattern+0x270>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8111033c:	0001883a 	nop
		}
	}
}
81110340:	0001883a 	nop
81110344:	e037883a 	mov	sp,fp
81110348:	dfc00117 	ldw	ra,4(sp)
8111034c:	df000017 	ldw	fp,0(sp)
81110350:	dec00204 	addi	sp,sp,8
81110354:	f800283a 	ret

81110358 <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
81110358:	defff704 	addi	sp,sp,-36
8111035c:	de00012e 	bgeu	sp,et,81110364 <vQCmdFeeRMAPinStandBy+0xc>
81110360:	003b68fa 	trap	3
81110364:	dfc00815 	stw	ra,32(sp)
81110368:	df000715 	stw	fp,28(sp)
8111036c:	df000704 	addi	fp,sp,28
81110370:	e13ffe15 	stw	r4,-8(fp)
81110374:	e17fff15 	stw	r5,-4(fp)
	INT32U ucValueMasked;
	INT32U ucValueMasked2;


#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110378:	00a045f4 	movhi	r2,33047
8111037c:	10a25304 	addi	r2,r2,-30388
81110380:	10800a8b 	ldhu	r2,42(r2)
81110384:	10bfffcc 	andi	r2,r2,65535
81110388:	108000e8 	cmpgeui	r2,r2,3
8111038c:	1000091e 	bne	r2,zero,811103b4 <vQCmdFeeRMAPinStandBy+0x5c>
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (StandBy)\n", pxNFeeP->ucId);
81110390:	d0e06217 	ldw	r3,-32376(gp)
81110394:	e0bffe17 	ldw	r2,-8(fp)
81110398:	10800003 	ldbu	r2,0(r2)
8111039c:	10803fcc 	andi	r2,r2,255
811103a0:	100d883a 	mov	r6,r2
811103a4:	01604574 	movhi	r5,33045
811103a8:	2979f904 	addi	r5,r5,-6172
811103ac:	1809883a 	mov	r4,r3
811103b0:	11232a00 	call	811232a0 <fprintf>
	}
#endif


	uiCmdFEEL.ulWord = cmd;
811103b4:	e0bfff17 	ldw	r2,-4(fp)
811103b8:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
811103bc:	e0bffd43 	ldbu	r2,-11(fp)
811103c0:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
811103c4:	e0bffe17 	ldw	r2,-8(fp)
811103c8:	10804517 	ldw	r2,276(r2)
811103cc:	e0fff903 	ldbu	r3,-28(fp)
811103d0:	180b883a 	mov	r5,r3
811103d4:	1009883a 	mov	r4,r2
811103d8:	110a4980 	call	8110a498 <uliRmapReadReg>
811103dc:	e0bffa15 	stw	r2,-24(fp)

	switch (ucADDRReg) {
811103e0:	e0bff903 	ldbu	r2,-28(fp)
811103e4:	10bff004 	addi	r2,r2,-64
811103e8:	10c003a8 	cmpgeui	r3,r2,14
811103ec:	18015e1e 	bne	r3,zero,81110968 <vQCmdFeeRMAPinStandBy+0x610>
811103f0:	100690ba 	slli	r3,r2,2
811103f4:	00a04474 	movhi	r2,33041
811103f8:	10810204 	addi	r2,r2,1032
811103fc:	1885883a 	add	r2,r3,r2
81110400:	10800017 	ldw	r2,0(r2)
81110404:	1000683a 	jmp	r2
81110408:	81110440 	call	88111044 <__reset+0x20f1044>
8111040c:	811109a0 	cmpeqi	r4,r16,17446
81110410:	8111052c 	andhi	r4,r16,17428
81110414:	81110768 	cmpgeui	r4,r16,17437
81110418:	81110768 	cmpgeui	r4,r16,17437
8111041c:	81110768 	cmpgeui	r4,r16,17437
81110420:	81110768 	cmpgeui	r4,r16,17437
81110424:	81110768 	cmpgeui	r4,r16,17437
81110428:	81110768 	cmpgeui	r4,r16,17437
8111042c:	81110768 	cmpgeui	r4,r16,17437
81110430:	81110768 	cmpgeui	r4,r16,17437
81110434:	81110768 	cmpgeui	r4,r16,17437
81110438:	811107a0 	cmpeqi	r4,r16,17438
8111043c:	811108e0 	cmpeqi	r4,r16,17443
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
81110440:	e0fffa17 	ldw	r3,-24(fp)
81110444:	00800434 	movhi	r2,16
81110448:	10bffc04 	addi	r2,r2,-16
8111044c:	1884703a 	and	r2,r3,r2
81110450:	1004d13a 	srli	r2,r2,4
81110454:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
81110458:	e0bffa17 	ldw	r2,-24(fp)
8111045c:	1004d53a 	srli	r2,r2,20
81110460:	e0bffc15 	stw	r2,-16(fp)


			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
81110464:	e0bffb17 	ldw	r2,-20(fp)
81110468:	1007883a 	mov	r3,r2
8111046c:	e0bffe17 	ldw	r2,-8(fp)
81110470:	1080300b 	ldhu	r2,192(r2)
81110474:	1885c83a 	sub	r2,r3,r2
81110478:	1007883a 	mov	r3,r2
8111047c:	e0bffe17 	ldw	r2,-8(fp)
81110480:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2 - (pxNFeeP->xCcdInfo.usiSOverscanN + pxNFeeP->xCcdInfo.usiSPrescanN);
81110484:	e0bffc17 	ldw	r2,-16(fp)
81110488:	1009883a 	mov	r4,r2
8111048c:	e0bffe17 	ldw	r2,-8(fp)
81110490:	10c02f8b 	ldhu	r3,190(r2)
81110494:	e0bffe17 	ldw	r2,-8(fp)
81110498:	10802f0b 	ldhu	r2,188(r2)
8111049c:	1885883a 	add	r2,r3,r2
811104a0:	2085c83a 	sub	r2,r4,r2
811104a4:	1007883a 	mov	r3,r2
811104a8:	e0bffe17 	ldw	r2,-8(fp)
811104ac:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
811104b0:	e13ffe17 	ldw	r4,-8(fp)
811104b4:	111f8540 	call	8111f854 <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
811104b8:	e0bffe17 	ldw	r2,-8(fp)
811104bc:	10803304 	addi	r2,r2,204
811104c0:	1009883a 	mov	r4,r2
811104c4:	1104bb00 	call	81104bb0 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFeeP->xCcdInfo.usiOLN;
811104c8:	e0bffe17 	ldw	r2,-8(fp)
811104cc:	10c0300b 	ldhu	r3,192(r2)
811104d0:	e0bffe17 	ldw	r2,-8(fp)
811104d4:	10c0358d 	sth	r3,214(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = ucValueMasked2 ;
811104d8:	e0bffc17 	ldw	r2,-16(fp)
811104dc:	1007883a 	mov	r3,r2
811104e0:	e0bffe17 	ldw	r2,-8(fp)
811104e4:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = ucValueMasked;
811104e8:	e0bffb17 	ldw	r2,-20(fp)
811104ec:	1007883a 	mov	r3,r2
811104f0:	e0bffe17 	ldw	r2,-8(fp)
811104f4:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
811104f8:	e0bffb17 	ldw	r2,-20(fp)
811104fc:	1007883a 	mov	r3,r2
81110500:	e0bffe17 	ldw	r2,-8(fp)
81110504:	1080300b 	ldhu	r2,192(r2)
81110508:	1885c83a 	sub	r2,r3,r2
8111050c:	1007883a 	mov	r3,r2
81110510:	e0bffe17 	ldw	r2,-8(fp)
81110514:	10c0350d 	sth	r3,212(r2)
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
81110518:	e0bffe17 	ldw	r2,-8(fp)
8111051c:	10803304 	addi	r2,r2,204
81110520:	1009883a 	mov	r4,r2
81110524:	110490c0 	call	8110490c <bDpktSetPacketConfig>

			break;
81110528:	00012606 	br	811109c4 <vQCmdFeeRMAPinStandBy+0x66c>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
8111052c:	e0fffa17 	ldw	r3,-24(fp)
81110530:	00800434 	movhi	r2,16
81110534:	10bffc04 	addi	r2,r2,-16
81110538:	1884703a 	and	r2,r3,r2
8111053c:	1004d13a 	srli	r2,r2,4
81110540:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
81110544:	e0bffe17 	ldw	r2,-8(fp)
81110548:	10803304 	addi	r2,r2,204
8111054c:	1009883a 	mov	r4,r2
81110550:	1104bb00 	call	81104bb0 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
81110554:	e0bffb17 	ldw	r2,-20(fp)
81110558:	1007883a 	mov	r3,r2
8111055c:	e0bffe17 	ldw	r2,-8(fp)
81110560:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
81110564:	e0bffe17 	ldw	r2,-8(fp)
81110568:	10803304 	addi	r2,r2,204
8111056c:	1009883a 	mov	r4,r2
81110570:	110490c0 	call	8110490c <bDpktSetPacketConfig>

			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110574:	00a045f4 	movhi	r2,33047
81110578:	10a25304 	addi	r2,r2,-30388
8111057c:	10800a8b 	ldhu	r2,42(r2)
81110580:	10bfffcc 	andi	r2,r2,65535
81110584:	108000e8 	cmpgeui	r2,r2,3
81110588:	1000061e 	bne	r2,zero,811105a4 <vQCmdFeeRMAPinStandBy+0x24c>
				fprintf(fp,"- Pckt Length: %lu\n", ucValueMasked);
8111058c:	d0a06217 	ldw	r2,-32376(gp)
81110590:	e1bffb17 	ldw	r6,-20(fp)
81110594:	01604574 	movhi	r5,33045
81110598:	297a0504 	addi	r5,r5,-6124
8111059c:	1009883a 	mov	r4,r2
811105a0:	11232a00 	call	811232a0 <fprintf>
			}
			#endif

			ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
811105a4:	e0bffa17 	ldw	r2,-24(fp)
811105a8:	1080030c 	andi	r2,r2,12
811105ac:	1004d0ba 	srli	r2,r2,2
811105b0:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked2) {
811105b4:	e0bffc17 	ldw	r2,-16(fp)
811105b8:	10c000a0 	cmpeqi	r3,r2,2
811105bc:	1800141e 	bne	r3,zero,81110610 <vQCmdFeeRMAPinStandBy+0x2b8>
811105c0:	10c000e0 	cmpeqi	r3,r2,3
811105c4:	1800231e 	bne	r3,zero,81110654 <vQCmdFeeRMAPinStandBy+0x2fc>
811105c8:	10800060 	cmpeqi	r2,r2,1
811105cc:	10003026 	beq	r2,zero,81110690 <vQCmdFeeRMAPinStandBy+0x338>
				case 0b01:
					pxNFeeP->xControl.eSide = sLeft;
811105d0:	e0bffe17 	ldw	r2,-8(fp)
811105d4:	10002e15 	stw	zero,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811105d8:	00a045f4 	movhi	r2,33047
811105dc:	10a25304 	addi	r2,r2,-30388
811105e0:	10800a8b 	ldhu	r2,42(r2)
811105e4:	10bfffcc 	andi	r2,r2,65535
811105e8:	108000e8 	cmpgeui	r2,r2,3
811105ec:	1000461e 	bne	r2,zero,81110708 <vQCmdFeeRMAPinStandBy+0x3b0>
						fprintf(fp," - Left side\n");
811105f0:	d0a06217 	ldw	r2,-32376(gp)
811105f4:	100f883a 	mov	r7,r2
811105f8:	01800344 	movi	r6,13
811105fc:	01400044 	movi	r5,1
81110600:	01204574 	movhi	r4,33045
81110604:	213a0a04 	addi	r4,r4,-6104
81110608:	112393c0 	call	8112393c <fwrite>
					}
					#endif
					break;
8111060c:	00003e06 	br	81110708 <vQCmdFeeRMAPinStandBy+0x3b0>
				case 0b10:
					pxNFeeP->xControl.eSide = sRight;
81110610:	e0bffe17 	ldw	r2,-8(fp)
81110614:	00c00044 	movi	r3,1
81110618:	10c02e15 	stw	r3,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111061c:	00a045f4 	movhi	r2,33047
81110620:	10a25304 	addi	r2,r2,-30388
81110624:	10800a8b 	ldhu	r2,42(r2)
81110628:	10bfffcc 	andi	r2,r2,65535
8111062c:	108000e8 	cmpgeui	r2,r2,3
81110630:	1000371e 	bne	r2,zero,81110710 <vQCmdFeeRMAPinStandBy+0x3b8>
						fprintf(fp," - Right side\n");
81110634:	d0a06217 	ldw	r2,-32376(gp)
81110638:	100f883a 	mov	r7,r2
8111063c:	01800384 	movi	r6,14
81110640:	01400044 	movi	r5,1
81110644:	01204574 	movhi	r4,33045
81110648:	213a0e04 	addi	r4,r4,-6088
8111064c:	112393c0 	call	8112393c <fwrite>
					}
					#endif
					break;
81110650:	00002f06 	br	81110710 <vQCmdFeeRMAPinStandBy+0x3b8>
				case 0b11:
					pxNFeeP->xControl.eSide = sLeft;
81110654:	e0bffe17 	ldw	r2,-8(fp)
81110658:	10002e15 	stw	zero,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111065c:	00a045f4 	movhi	r2,33047
81110660:	10a25304 	addi	r2,r2,-30388
81110664:	10800a8b 	ldhu	r2,42(r2)
81110668:	10bfffcc 	andi	r2,r2,65535
8111066c:	108000e8 	cmpgeui	r2,r2,3
81110670:	1000071e 	bne	r2,zero,81110690 <vQCmdFeeRMAPinStandBy+0x338>
						fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
81110674:	d0a06217 	ldw	r2,-32376(gp)
81110678:	100f883a 	mov	r7,r2
8111067c:	01800f44 	movi	r6,61
81110680:	01400044 	movi	r5,1
81110684:	01204574 	movhi	r4,33045
81110688:	213a1204 	addi	r4,r4,-6072
8111068c:	112393c0 	call	8112393c <fwrite>
					}
					#endif
				default:
					pxNFeeP->xControl.eSide = sLeft;
81110690:	e0bffe17 	ldw	r2,-8(fp)
81110694:	10002e15 	stw	zero,184(r2)

					bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110698:	e0bffe17 	ldw	r2,-8(fp)
8111069c:	10804504 	addi	r2,r2,276
811106a0:	1009883a 	mov	r4,r2
811106a4:	11086380 	call	81108638 <bRmapGetMemConfigArea>
					pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
811106a8:	e0bffe17 	ldw	r2,-8(fp)
811106ac:	10c05917 	ldw	r3,356(r2)
811106b0:	00bffdc4 	movi	r2,-9
811106b4:	1886703a 	and	r3,r3,r2
811106b8:	e0bffe17 	ldw	r2,-8(fp)
811106bc:	10c05915 	stw	r3,356(r2)
					bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
811106c0:	e0bffe17 	ldw	r2,-8(fp)
811106c4:	10804504 	addi	r2,r2,276
811106c8:	1009883a 	mov	r4,r2
811106cc:	11083040 	call	81108304 <bRmapSetMemConfigArea>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811106d0:	00a045f4 	movhi	r2,33047
811106d4:	10a25304 	addi	r2,r2,-30388
811106d8:	10800a8b 	ldhu	r2,42(r2)
811106dc:	10bfffcc 	andi	r2,r2,65535
811106e0:	108000e8 	cmpgeui	r2,r2,3
811106e4:	10000c1e 	bne	r2,zero,81110718 <vQCmdFeeRMAPinStandBy+0x3c0>
						fprintf(fp," - Switching to Left side\n");
811106e8:	d0a06217 	ldw	r2,-32376(gp)
811106ec:	100f883a 	mov	r7,r2
811106f0:	01800684 	movi	r6,26
811106f4:	01400044 	movi	r5,1
811106f8:	01204574 	movhi	r4,33045
811106fc:	213a2204 	addi	r4,r4,-6008
81110700:	112393c0 	call	8112393c <fwrite>
					}
					#endif
					break;
81110704:	00000406 	br	81110718 <vQCmdFeeRMAPinStandBy+0x3c0>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Left side\n");
					}
					#endif
					break;
81110708:	0001883a 	nop
8111070c:	00000306 	br	8111071c <vQCmdFeeRMAPinStandBy+0x3c4>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Right side\n");
					}
					#endif
					break;
81110710:	0001883a 	nop
81110714:	00000106 	br	8111071c <vQCmdFeeRMAPinStandBy+0x3c4>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Switching to Left side\n");
					}
					#endif
					break;
81110718:	0001883a 	nop
				}
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8111071c:	00a045f4 	movhi	r2,33047
81110720:	10a25304 	addi	r2,r2,-30388
81110724:	10800a8b 	ldhu	r2,42(r2)
81110728:	10bfffcc 	andi	r2,r2,65535
8111072c:	10800168 	cmpgeui	r2,r2,5
81110730:	10009d1e 	bne	r2,zero,811109a8 <vQCmdFeeRMAPinStandBy+0x650>
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110734:	d0e06217 	ldw	r3,-32376(gp)
81110738:	e0bffe17 	ldw	r2,-8(fp)
8111073c:	10800003 	ldbu	r2,0(r2)
81110740:	11003fcc 	andi	r4,r2,255
81110744:	e0bffe17 	ldw	r2,-8(fp)
81110748:	10802e17 	ldw	r2,184(r2)
8111074c:	100f883a 	mov	r7,r2
81110750:	200d883a 	mov	r6,r4
81110754:	01604574 	movhi	r5,33045
81110758:	297a2904 	addi	r5,r5,-5980
8111075c:	1809883a 	mov	r4,r3
81110760:	11232a00 	call	811232a0 <fprintf>
			}
			#endif
			break;
81110764:	00009006 	br	811109a8 <vQCmdFeeRMAPinStandBy+0x650>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110768:	00a045f4 	movhi	r2,33047
8111076c:	10a25304 	addi	r2,r2,-30388
81110770:	10800a8b 	ldhu	r2,42(r2)
81110774:	10bfffcc 	andi	r2,r2,65535
81110778:	10800168 	cmpgeui	r2,r2,5
8111077c:	10008c1e 	bne	r2,zero,811109b0 <vQCmdFeeRMAPinStandBy+0x658>
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
81110780:	d0a06217 	ldw	r2,-32376(gp)
81110784:	e0fff903 	ldbu	r3,-28(fp)
81110788:	180d883a 	mov	r6,r3
8111078c:	01604574 	movhi	r5,33045
81110790:	297a3704 	addi	r5,r5,-5924
81110794:	1009883a 	mov	r4,r2
81110798:	11232a00 	call	811232a0 <fprintf>
			}
			#endif
				break;
8111079c:	00008406 	br	811109b0 <vQCmdFeeRMAPinStandBy+0x658>
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
811107a0:	e0bffa17 	ldw	r2,-24(fp)
811107a4:	10803c0c 	andi	r2,r2,240
811107a8:	1004d13a 	srli	r2,r2,4
811107ac:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
811107b0:	e0bffb17 	ldw	r2,-20(fp)
811107b4:	10c000a0 	cmpeqi	r3,r2,2
811107b8:	1800111e 	bne	r3,zero,81110800 <vQCmdFeeRMAPinStandBy+0x4a8>
811107bc:	10c001a0 	cmpeqi	r3,r2,6
811107c0:	1800261e 	bne	r3,zero,8111085c <vQCmdFeeRMAPinStandBy+0x504>
811107c4:	1000331e 	bne	r2,zero,81110894 <vQCmdFeeRMAPinStandBy+0x53c>
				case 0: /* Standby */

				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811107c8:	00a045f4 	movhi	r2,33047
811107cc:	10a25304 	addi	r2,r2,-30388
811107d0:	10800a8b 	ldhu	r2,42(r2)
811107d4:	10bfffcc 	andi	r2,r2,65535
811107d8:	10800168 	cmpgeui	r2,r2,5
811107dc:	10003a1e 	bne	r2,zero,811108c8 <vQCmdFeeRMAPinStandBy+0x570>
						fprintf(fp,"- already in Stand by mode\n");
811107e0:	d0a06217 	ldw	r2,-32376(gp)
811107e4:	100f883a 	mov	r7,r2
811107e8:	018006c4 	movi	r6,27
811107ec:	01400044 	movi	r5,1
811107f0:	01204574 	movhi	r4,33045
811107f4:	213a4004 	addi	r4,r4,-5888
811107f8:	112393c0 	call	8112393c <fwrite>
					}
				#endif

					break;
811107fc:	00003206 	br	811108c8 <vQCmdFeeRMAPinStandBy+0x570>
				case 2: /* PAttern Full image */
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110800:	00a045f4 	movhi	r2,33047
81110804:	10a25304 	addi	r2,r2,-30388
81110808:	10800a8b 	ldhu	r2,42(r2)
8111080c:	10bfffcc 	andi	r2,r2,65535
81110810:	10800168 	cmpgeui	r2,r2,5
81110814:	1000071e 	bne	r2,zero,81110834 <vQCmdFeeRMAPinStandBy+0x4dc>
						fprintf(fp,"- to Full-Image-Pattern\n");
81110818:	d0a06217 	ldw	r2,-32376(gp)
8111081c:	100f883a 	mov	r7,r2
81110820:	01800604 	movi	r6,24
81110824:	01400044 	movi	r5,1
81110828:	01204574 	movhi	r4,33045
8111082c:	213a4704 	addi	r4,r4,-5860
81110830:	112393c0 	call	8112393c <fwrite>
					}
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
81110834:	e0bffe17 	ldw	r2,-8(fp)
81110838:	00c00044 	movi	r3,1
8111083c:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
81110840:	e0bffe17 	ldw	r2,-8(fp)
81110844:	00c00284 	movi	r3,10
81110848:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8111084c:	e0bffe17 	ldw	r2,-8(fp)
81110850:	00c00304 	movi	r3,12
81110854:	10c02d15 	stw	r3,180(r2)

					break;
81110858:	00002006 	br	811108dc <vQCmdFeeRMAPinStandBy+0x584>
				case 6:
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8111085c:	00a045f4 	movhi	r2,33047
81110860:	10a25304 	addi	r2,r2,-30388
81110864:	10800a8b 	ldhu	r2,42(r2)
81110868:	10bfffcc 	andi	r2,r2,65535
8111086c:	10800168 	cmpgeui	r2,r2,5
81110870:	1000171e 	bne	r2,zero,811108d0 <vQCmdFeeRMAPinStandBy+0x578>
						fprintf(fp,"- Off-Mode not allowed.\n");
81110874:	d0a06217 	ldw	r2,-32376(gp)
81110878:	100f883a 	mov	r7,r2
8111087c:	01800604 	movi	r6,24
81110880:	01400044 	movi	r5,1
81110884:	01204574 	movhi	r4,33045
81110888:	213a4e04 	addi	r4,r4,-5832
8111088c:	112393c0 	call	8112393c <fwrite>
					}
				#endif
					break;
81110890:	00000f06 	br	811108d0 <vQCmdFeeRMAPinStandBy+0x578>
				case 3:
				case 4:
				case 5:
				default:
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81110894:	00a045f4 	movhi	r2,33047
81110898:	10a25304 	addi	r2,r2,-30388
8111089c:	10800a8b 	ldhu	r2,42(r2)
811108a0:	10bfffcc 	andi	r2,r2,65535
811108a4:	10800228 	cmpgeui	r2,r2,8
811108a8:	10000b1e 	bne	r2,zero,811108d8 <vQCmdFeeRMAPinStandBy+0x580>
						fprintf(fp,"- mode not allowed yet ( %lu )\n", ucValueMasked);
811108ac:	d0a06217 	ldw	r2,-32376(gp)
811108b0:	e1bffb17 	ldw	r6,-20(fp)
811108b4:	01604574 	movhi	r5,33045
811108b8:	297a5504 	addi	r5,r5,-5804
811108bc:	1009883a 	mov	r4,r2
811108c0:	11232a00 	call	811232a0 <fprintf>
					}
					#endif
					break;
811108c4:	00000406 	br	811108d8 <vQCmdFeeRMAPinStandBy+0x580>
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"- already in Stand by mode\n");
					}
				#endif

					break;
811108c8:	0001883a 	nop
811108cc:	00003d06 	br	811109c4 <vQCmdFeeRMAPinStandBy+0x66c>
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"- Off-Mode not allowed.\n");
					}
				#endif
					break;
811108d0:	0001883a 	nop
811108d4:	00003b06 	br	811109c4 <vQCmdFeeRMAPinStandBy+0x66c>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"- mode not allowed yet ( %lu )\n", ucValueMasked);
					}
					#endif
					break;
811108d8:	0001883a 	nop
			}

			break;
811108dc:	00003906 	br	811109c4 <vQCmdFeeRMAPinStandBy+0x66c>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
811108e0:	e0bffa17 	ldw	r2,-24(fp)
811108e4:	1080010c 	andi	r2,r2,4
811108e8:	1004d0ba 	srli	r2,r2,2
811108ec:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
811108f0:	e0bffb17 	ldw	r2,-20(fp)
811108f4:	10003026 	beq	r2,zero,811109b8 <vQCmdFeeRMAPinStandBy+0x660>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811108f8:	00a045f4 	movhi	r2,33047
811108fc:	10a25304 	addi	r2,r2,-30388
81110900:	10800a8b 	ldhu	r2,42(r2)
81110904:	10bfffcc 	andi	r2,r2,65535
81110908:	10800168 	cmpgeui	r2,r2,5
8111090c:	1000071e 	bne	r2,zero,8111092c <vQCmdFeeRMAPinStandBy+0x5d4>
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
81110910:	d0a06217 	ldw	r2,-32376(gp)
81110914:	100f883a 	mov	r7,r2
81110918:	01800a04 	movi	r6,40
8111091c:	01400044 	movi	r5,1
81110920:	01204574 	movhi	r4,33045
81110924:	213a5d04 	addi	r4,r4,-5772
81110928:	112393c0 	call	8112393c <fwrite>
				}
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8111092c:	e0bffe17 	ldw	r2,-8(fp)
81110930:	10804504 	addi	r2,r2,276
81110934:	1009883a 	mov	r4,r2
81110938:	11086380 	call	81108638 <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
8111093c:	e0bffe17 	ldw	r2,-8(fp)
81110940:	10c06417 	ldw	r3,400(r2)
81110944:	00bffec4 	movi	r2,-5
81110948:	1886703a 	and	r3,r3,r2
8111094c:	e0bffe17 	ldw	r2,-8(fp)
81110950:	10c06415 	stw	r3,400(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110954:	e0bffe17 	ldw	r2,-8(fp)
81110958:	10804504 	addi	r2,r2,276
8111095c:	1009883a 	mov	r4,r2
81110960:	11083040 	call	81108304 <bRmapSetMemConfigArea>
			}

			break;
81110964:	00001406 	br	811109b8 <vQCmdFeeRMAPinStandBy+0x660>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81110968:	00a045f4 	movhi	r2,33047
8111096c:	10a25304 	addi	r2,r2,-30388
81110970:	10800a8b 	ldhu	r2,42(r2)
81110974:	10bfffcc 	andi	r2,r2,65535
81110978:	10800228 	cmpgeui	r2,r2,8
8111097c:	1000101e 	bne	r2,zero,811109c0 <vQCmdFeeRMAPinStandBy+0x668>
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
81110980:	d0a06217 	ldw	r2,-32376(gp)
81110984:	e0fff903 	ldbu	r3,-28(fp)
81110988:	180d883a 	mov	r6,r3
8111098c:	01604574 	movhi	r5,33045
81110990:	297a6804 	addi	r5,r5,-5728
81110994:	1009883a 	mov	r4,r2
81110998:	11232a00 	call	811232a0 <fprintf>
			}
			#endif
			break;
8111099c:	00000806 	br	811109c0 <vQCmdFeeRMAPinStandBy+0x668>
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
811109a0:	0001883a 	nop
811109a4:	00000706 	br	811109c4 <vQCmdFeeRMAPinStandBy+0x66c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
			}
			#endif
			break;
811109a8:	0001883a 	nop
811109ac:	00000506 	br	811109c4 <vQCmdFeeRMAPinStandBy+0x66c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
				break;
811109b0:	0001883a 	nop
811109b4:	00000306 	br	811109c4 <vQCmdFeeRMAPinStandBy+0x66c>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
811109b8:	0001883a 	nop
811109bc:	00000106 	br	811109c4 <vQCmdFeeRMAPinStandBy+0x66c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
811109c0:	0001883a 	nop
		}
}
811109c4:	0001883a 	nop
811109c8:	e037883a 	mov	sp,fp
811109cc:	dfc00117 	ldw	ra,4(sp)
811109d0:	df000017 	ldw	fp,0(sp)
811109d4:	dec00204 	addi	sp,sp,8
811109d8:	f800283a 	ret

811109dc <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ) {
811109dc:	defff804 	addi	sp,sp,-32
811109e0:	de00012e 	bgeu	sp,et,811109e8 <vQCmdFeeRMAPinFullPattern+0xc>
811109e4:	003b68fa 	trap	3
811109e8:	dfc00715 	stw	ra,28(sp)
811109ec:	df000615 	stw	fp,24(sp)
811109f0:	df000604 	addi	fp,sp,24
811109f4:	e13ffe15 	stw	r4,-8(fp)
811109f8:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811109fc:	00a045f4 	movhi	r2,33047
81110a00:	10a25304 	addi	r2,r2,-30388
81110a04:	10800a8b 	ldhu	r2,42(r2)
81110a08:	10bfffcc 	andi	r2,r2,65535
81110a0c:	108000e8 	cmpgeui	r2,r2,3
81110a10:	1000091e 	bne	r2,zero,81110a38 <vQCmdFeeRMAPinFullPattern+0x5c>
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (FullPattern)\n", pxNFeeP->ucId);
81110a14:	d0e06217 	ldw	r3,-32376(gp)
81110a18:	e0bffe17 	ldw	r2,-8(fp)
81110a1c:	10800003 	ldbu	r2,0(r2)
81110a20:	10803fcc 	andi	r2,r2,255
81110a24:	100d883a 	mov	r6,r2
81110a28:	01604574 	movhi	r5,33045
81110a2c:	297a7104 	addi	r5,r5,-5692
81110a30:	1809883a 	mov	r4,r3
81110a34:	11232a00 	call	811232a0 <fprintf>
	}
	#endif

	uiCmdFEEL.ulWord = cmd;
81110a38:	e0bfff17 	ldw	r2,-4(fp)
81110a3c:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
81110a40:	e0bffd43 	ldbu	r2,-11(fp)
81110a44:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
81110a48:	e0bffe17 	ldw	r2,-8(fp)
81110a4c:	10804517 	ldw	r2,276(r2)
81110a50:	e0fffa03 	ldbu	r3,-24(fp)
81110a54:	180b883a 	mov	r5,r3
81110a58:	1009883a 	mov	r4,r2
81110a5c:	110a4980 	call	8110a498 <uliRmapReadReg>
81110a60:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
81110a64:	e0bffa03 	ldbu	r2,-24(fp)
81110a68:	10bff004 	addi	r2,r2,-64
81110a6c:	10c003a8 	cmpgeui	r3,r2,14
81110a70:	1801381e 	bne	r3,zero,81110f54 <vQCmdFeeRMAPinFullPattern+0x578>
81110a74:	100690ba 	slli	r3,r2,2
81110a78:	00a04474 	movhi	r2,33041
81110a7c:	1082a304 	addi	r2,r2,2700
81110a80:	1885883a 	add	r2,r3,r2
81110a84:	10800017 	ldw	r2,0(r2)
81110a88:	1000683a 	jmp	r2
81110a8c:	81110ac4 	addi	r4,r16,17451
81110a90:	81110ac4 	addi	r4,r16,17451
81110a94:	81110ac4 	addi	r4,r16,17451
81110a98:	81110d1c 	xori	r4,r16,17460
81110a9c:	81110d1c 	xori	r4,r16,17460
81110aa0:	81110d1c 	xori	r4,r16,17460
81110aa4:	81110d1c 	xori	r4,r16,17460
81110aa8:	81110d1c 	xori	r4,r16,17460
81110aac:	81110d1c 	xori	r4,r16,17460
81110ab0:	81110d1c 	xori	r4,r16,17460
81110ab4:	81110d1c 	xori	r4,r16,17460
81110ab8:	81110d1c 	xori	r4,r16,17460
81110abc:	81110d54 	ori	r4,r16,17461
81110ac0:	81110ed4 	ori	r4,r16,17467
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config
			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
81110ac4:	e0bffe17 	ldw	r2,-8(fp)
81110ac8:	10802d17 	ldw	r2,180(r2)
81110acc:	108001e0 	cmpeqi	r2,r2,7
81110ad0:	1000041e 	bne	r2,zero,81110ae4 <vQCmdFeeRMAPinFullPattern+0x108>
81110ad4:	e0bffe17 	ldw	r2,-8(fp)
81110ad8:	10802d17 	ldw	r2,180(r2)
81110adc:	10800318 	cmpnei	r2,r2,12
81110ae0:	1000771e 	bne	r2,zero,81110cc0 <vQCmdFeeRMAPinFullPattern+0x2e4>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
81110ae4:	e0bffa43 	ldbu	r2,-23(fp)
81110ae8:	1080030c 	andi	r2,r2,12
81110aec:	1005d0ba 	srai	r2,r2,2
81110af0:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
81110af4:	e0bffb17 	ldw	r2,-20(fp)
81110af8:	10c000a0 	cmpeqi	r3,r2,2
81110afc:	1800141e 	bne	r3,zero,81110b50 <vQCmdFeeRMAPinFullPattern+0x174>
81110b00:	10c000e0 	cmpeqi	r3,r2,3
81110b04:	1800231e 	bne	r3,zero,81110b94 <vQCmdFeeRMAPinFullPattern+0x1b8>
81110b08:	10800060 	cmpeqi	r2,r2,1
81110b0c:	10003026 	beq	r2,zero,81110bd0 <vQCmdFeeRMAPinFullPattern+0x1f4>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
81110b10:	e0bffe17 	ldw	r2,-8(fp)
81110b14:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110b18:	00a045f4 	movhi	r2,33047
81110b1c:	10a25304 	addi	r2,r2,-30388
81110b20:	10800a8b 	ldhu	r2,42(r2)
81110b24:	10bfffcc 	andi	r2,r2,65535
81110b28:	108000e8 	cmpgeui	r2,r2,3
81110b2c:	1000461e 	bne	r2,zero,81110c48 <vQCmdFeeRMAPinFullPattern+0x26c>
							fprintf(fp," - Left side\n");
81110b30:	d0a06217 	ldw	r2,-32376(gp)
81110b34:	100f883a 	mov	r7,r2
81110b38:	01800344 	movi	r6,13
81110b3c:	01400044 	movi	r5,1
81110b40:	01204574 	movhi	r4,33045
81110b44:	213a0a04 	addi	r4,r4,-6104
81110b48:	112393c0 	call	8112393c <fwrite>
						}
						#endif
						break;
81110b4c:	00003e06 	br	81110c48 <vQCmdFeeRMAPinFullPattern+0x26c>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
81110b50:	e0bffe17 	ldw	r2,-8(fp)
81110b54:	00c00044 	movi	r3,1
81110b58:	10c02e15 	stw	r3,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110b5c:	00a045f4 	movhi	r2,33047
81110b60:	10a25304 	addi	r2,r2,-30388
81110b64:	10800a8b 	ldhu	r2,42(r2)
81110b68:	10bfffcc 	andi	r2,r2,65535
81110b6c:	108000e8 	cmpgeui	r2,r2,3
81110b70:	1000371e 	bne	r2,zero,81110c50 <vQCmdFeeRMAPinFullPattern+0x274>
							fprintf(fp," - Right side\n");
81110b74:	d0a06217 	ldw	r2,-32376(gp)
81110b78:	100f883a 	mov	r7,r2
81110b7c:	01800384 	movi	r6,14
81110b80:	01400044 	movi	r5,1
81110b84:	01204574 	movhi	r4,33045
81110b88:	213a0e04 	addi	r4,r4,-6088
81110b8c:	112393c0 	call	8112393c <fwrite>
						}
						#endif
						break;
81110b90:	00002f06 	br	81110c50 <vQCmdFeeRMAPinFullPattern+0x274>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
81110b94:	e0bffe17 	ldw	r2,-8(fp)
81110b98:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110b9c:	00a045f4 	movhi	r2,33047
81110ba0:	10a25304 	addi	r2,r2,-30388
81110ba4:	10800a8b 	ldhu	r2,42(r2)
81110ba8:	10bfffcc 	andi	r2,r2,65535
81110bac:	108000e8 	cmpgeui	r2,r2,3
81110bb0:	1000071e 	bne	r2,zero,81110bd0 <vQCmdFeeRMAPinFullPattern+0x1f4>
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
81110bb4:	d0a06217 	ldw	r2,-32376(gp)
81110bb8:	100f883a 	mov	r7,r2
81110bbc:	01800f44 	movi	r6,61
81110bc0:	01400044 	movi	r5,1
81110bc4:	01204574 	movhi	r4,33045
81110bc8:	213a1204 	addi	r4,r4,-6072
81110bcc:	112393c0 	call	8112393c <fwrite>
						}
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
81110bd0:	e0bffe17 	ldw	r2,-8(fp)
81110bd4:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110bd8:	e0bffe17 	ldw	r2,-8(fp)
81110bdc:	10804504 	addi	r2,r2,276
81110be0:	1009883a 	mov	r4,r2
81110be4:	11086380 	call	81108638 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
81110be8:	e0bffe17 	ldw	r2,-8(fp)
81110bec:	10c05917 	ldw	r3,356(r2)
81110bf0:	00bffdc4 	movi	r2,-9
81110bf4:	1886703a 	and	r3,r3,r2
81110bf8:	e0bffe17 	ldw	r2,-8(fp)
81110bfc:	10c05915 	stw	r3,356(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110c00:	e0bffe17 	ldw	r2,-8(fp)
81110c04:	10804504 	addi	r2,r2,276
81110c08:	1009883a 	mov	r4,r2
81110c0c:	11083040 	call	81108304 <bRmapSetMemConfigArea>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110c10:	00a045f4 	movhi	r2,33047
81110c14:	10a25304 	addi	r2,r2,-30388
81110c18:	10800a8b 	ldhu	r2,42(r2)
81110c1c:	10bfffcc 	andi	r2,r2,65535
81110c20:	108000e8 	cmpgeui	r2,r2,3
81110c24:	10000c1e 	bne	r2,zero,81110c58 <vQCmdFeeRMAPinFullPattern+0x27c>
							fprintf(fp," - Switching to Left side\n");
81110c28:	d0a06217 	ldw	r2,-32376(gp)
81110c2c:	100f883a 	mov	r7,r2
81110c30:	01800684 	movi	r6,26
81110c34:	01400044 	movi	r5,1
81110c38:	01204574 	movhi	r4,33045
81110c3c:	213a2204 	addi	r4,r4,-6008
81110c40:	112393c0 	call	8112393c <fwrite>
						}
						#endif
					break;
81110c44:	00000406 	br	81110c58 <vQCmdFeeRMAPinFullPattern+0x27c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Left side\n");
						}
						#endif
						break;
81110c48:	0001883a 	nop
81110c4c:	00000306 	br	81110c5c <vQCmdFeeRMAPinFullPattern+0x280>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Right side\n");
						}
						#endif
						break;
81110c50:	0001883a 	nop
81110c54:	00000106 	br	81110c5c <vQCmdFeeRMAPinFullPattern+0x280>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Switching to Left side\n");
						}
						#endif
					break;
81110c58:	0001883a 	nop
				}
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110c5c:	00a045f4 	movhi	r2,33047
81110c60:	10a25304 	addi	r2,r2,-30388
81110c64:	10800a8b 	ldhu	r2,42(r2)
81110c68:	10bfffcc 	andi	r2,r2,65535
81110c6c:	10800168 	cmpgeui	r2,r2,5
81110c70:	10000c1e 	bne	r2,zero,81110ca4 <vQCmdFeeRMAPinFullPattern+0x2c8>
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110c74:	d0e06217 	ldw	r3,-32376(gp)
81110c78:	e0bffe17 	ldw	r2,-8(fp)
81110c7c:	10800003 	ldbu	r2,0(r2)
81110c80:	11003fcc 	andi	r4,r2,255
81110c84:	e0bffe17 	ldw	r2,-8(fp)
81110c88:	10802e17 	ldw	r2,184(r2)
81110c8c:	100f883a 	mov	r7,r2
81110c90:	200d883a 	mov	r6,r4
81110c94:	01604574 	movhi	r5,33045
81110c98:	297a2904 	addi	r5,r5,-5980
81110c9c:	1809883a 	mov	r4,r3
81110ca0:	11232a00 	call	811232a0 <fprintf>
				}
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
81110ca4:	e0bffe17 	ldw	r2,-8(fp)
81110ca8:	00c00284 	movi	r3,10
81110cac:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
81110cb0:	e0bffe17 	ldw	r2,-8(fp)
81110cb4:	00c00304 	movi	r3,12
81110cb8:	10c02d15 	stw	r3,180(r2)
				}
			}



			break;
81110cbc:	0000b306 	br	81110f8c <vQCmdFeeRMAPinFullPattern+0x5b0>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
81110cc0:	e0bffe17 	ldw	r2,-8(fp)
81110cc4:	10802d17 	ldw	r2,180(r2)
81110cc8:	10800118 	cmpnei	r2,r2,4
81110ccc:	1000af1e 	bne	r2,zero,81110f8c <vQCmdFeeRMAPinFullPattern+0x5b0>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110cd0:	00a045f4 	movhi	r2,33047
81110cd4:	10a25304 	addi	r2,r2,-30388
81110cd8:	10800a8b 	ldhu	r2,42(r2)
81110cdc:	10bfffcc 	andi	r2,r2,65535
81110ce0:	10800168 	cmpgeui	r2,r2,5
81110ce4:	1000a91e 	bne	r2,zero,81110f8c <vQCmdFeeRMAPinFullPattern+0x5b0>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110ce8:	d0e06217 	ldw	r3,-32376(gp)
81110cec:	e0bffe17 	ldw	r2,-8(fp)
81110cf0:	10800003 	ldbu	r2,0(r2)
81110cf4:	11003fcc 	andi	r4,r2,255
81110cf8:	e0bffe17 	ldw	r2,-8(fp)
81110cfc:	10802e17 	ldw	r2,184(r2)
81110d00:	100f883a 	mov	r7,r2
81110d04:	200d883a 	mov	r6,r4
81110d08:	01604574 	movhi	r5,33045
81110d0c:	297a7e04 	addi	r5,r5,-5640
81110d10:	1809883a 	mov	r4,r3
81110d14:	11232a00 	call	811232a0 <fprintf>
				}
			}



			break;
81110d18:	00009c06 	br	81110f8c <vQCmdFeeRMAPinFullPattern+0x5b0>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110d1c:	00a045f4 	movhi	r2,33047
81110d20:	10a25304 	addi	r2,r2,-30388
81110d24:	10800a8b 	ldhu	r2,42(r2)
81110d28:	10bfffcc 	andi	r2,r2,65535
81110d2c:	10800168 	cmpgeui	r2,r2,5
81110d30:	1000981e 	bne	r2,zero,81110f94 <vQCmdFeeRMAPinFullPattern+0x5b8>
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
81110d34:	d0a06217 	ldw	r2,-32376(gp)
81110d38:	e0fffa03 	ldbu	r3,-24(fp)
81110d3c:	180d883a 	mov	r6,r3
81110d40:	01604574 	movhi	r5,33045
81110d44:	297a6804 	addi	r5,r5,-5728
81110d48:	1009883a 	mov	r4,r2
81110d4c:	11232a00 	call	811232a0 <fprintf>
			}
			#endif
				break;
81110d50:	00009006 	br	81110f94 <vQCmdFeeRMAPinFullPattern+0x5b8>

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
81110d54:	e0bffa43 	ldbu	r2,-23(fp)
81110d58:	1004d13a 	srli	r2,r2,4
81110d5c:	10803fcc 	andi	r2,r2,255
81110d60:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked) {
81110d64:	e0bffc17 	ldw	r2,-16(fp)
81110d68:	10c000a0 	cmpeqi	r3,r2,2
81110d6c:	1800281e 	bne	r3,zero,81110e10 <vQCmdFeeRMAPinFullPattern+0x434>
81110d70:	10c001a0 	cmpeqi	r3,r2,6
81110d74:	1800361e 	bne	r3,zero,81110e50 <vQCmdFeeRMAPinFullPattern+0x474>
81110d78:	1000431e 	bne	r2,zero,81110e88 <vQCmdFeeRMAPinFullPattern+0x4ac>
				case 0: /* Standby */
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110d7c:	00a045f4 	movhi	r2,33047
81110d80:	10a25304 	addi	r2,r2,-30388
81110d84:	10800a8b 	ldhu	r2,42(r2)
81110d88:	10bfffcc 	andi	r2,r2,65535
81110d8c:	108000e8 	cmpgeui	r2,r2,3
81110d90:	1000071e 	bne	r2,zero,81110db0 <vQCmdFeeRMAPinFullPattern+0x3d4>
						fprintf(fp,"- to Stand-By\n");
81110d94:	d0a06217 	ldw	r2,-32376(gp)
81110d98:	100f883a 	mov	r7,r2
81110d9c:	01800384 	movi	r6,14
81110da0:	01400044 	movi	r5,1
81110da4:	01204574 	movhi	r4,33045
81110da8:	213a9504 	addi	r4,r4,-5548
81110dac:	112393c0 	call	8112393c <fwrite>
					}
				#endif

					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
81110db0:	e0bffe17 	ldw	r2,-8(fp)
81110db4:	10802c17 	ldw	r2,176(r2)
81110db8:	10800298 	cmpnei	r2,r2,10
81110dbc:	10000a1e 	bne	r2,zero,81110de8 <vQCmdFeeRMAPinFullPattern+0x40c>
						pxNFeeP->xControl.bWatingSync = TRUE;
81110dc0:	e0bffe17 	ldw	r2,-8(fp)
81110dc4:	00c00044 	movi	r3,1
81110dc8:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
81110dcc:	e0bffe17 	ldw	r2,-8(fp)
81110dd0:	00c00304 	movi	r3,12
81110dd4:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110dd8:	e0bffe17 	ldw	r2,-8(fp)
81110ddc:	00c00184 	movi	r3,6
81110de0:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
81110de4:	00003a06 	br	81110ed0 <vQCmdFeeRMAPinFullPattern+0x4f4>
					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
						pxNFeeP->xControl.bWatingSync = TRUE;
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
					} else {
						pxNFeeP->xControl.bWatingSync = TRUE;
81110de8:	e0bffe17 	ldw	r2,-8(fp)
81110dec:	00c00044 	movi	r3,1
81110df0:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeTestFullPattern;
81110df4:	e0bffe17 	ldw	r2,-8(fp)
81110df8:	00c00104 	movi	r3,4
81110dfc:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110e00:	e0bffe17 	ldw	r2,-8(fp)
81110e04:	00c00184 	movi	r3,6
81110e08:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
81110e0c:	00003006 	br	81110ed0 <vQCmdFeeRMAPinFullPattern+0x4f4>
				case 2: /* PAttern Full image */
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110e10:	00a045f4 	movhi	r2,33047
81110e14:	10a25304 	addi	r2,r2,-30388
81110e18:	10800a8b 	ldhu	r2,42(r2)
81110e1c:	10bfffcc 	andi	r2,r2,65535
81110e20:	10800168 	cmpgeui	r2,r2,5
81110e24:	1000251e 	bne	r2,zero,81110ebc <vQCmdFeeRMAPinFullPattern+0x4e0>
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
81110e28:	d0e06217 	ldw	r3,-32376(gp)
81110e2c:	e0bffe17 	ldw	r2,-8(fp)
81110e30:	10800003 	ldbu	r2,0(r2)
81110e34:	10803fcc 	andi	r2,r2,255
81110e38:	100d883a 	mov	r6,r2
81110e3c:	01604574 	movhi	r5,33045
81110e40:	2979da04 	addi	r5,r5,-6296
81110e44:	1809883a 	mov	r4,r3
81110e48:	11232a00 	call	811232a0 <fprintf>
					}
					#endif

					break;
81110e4c:	00001b06 	br	81110ebc <vQCmdFeeRMAPinFullPattern+0x4e0>
				case 6:
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110e50:	00a045f4 	movhi	r2,33047
81110e54:	10a25304 	addi	r2,r2,-30388
81110e58:	10800a8b 	ldhu	r2,42(r2)
81110e5c:	10bfffcc 	andi	r2,r2,65535
81110e60:	10800168 	cmpgeui	r2,r2,5
81110e64:	1000171e 	bne	r2,zero,81110ec4 <vQCmdFeeRMAPinFullPattern+0x4e8>
						fprintf(fp," Off-Mode not allowed.\n");
81110e68:	d0a06217 	ldw	r2,-32376(gp)
81110e6c:	100f883a 	mov	r7,r2
81110e70:	018005c4 	movi	r6,23
81110e74:	01400044 	movi	r5,1
81110e78:	01204574 	movhi	r4,33045
81110e7c:	213a9904 	addi	r4,r4,-5532
81110e80:	112393c0 	call	8112393c <fwrite>
					}
				#endif
					break;
81110e84:	00000f06 	br	81110ec4 <vQCmdFeeRMAPinFullPattern+0x4e8>
				case 3:
				case 4:
				case 5:
				default:
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110e88:	00a045f4 	movhi	r2,33047
81110e8c:	10a25304 	addi	r2,r2,-30388
81110e90:	10800a8b 	ldhu	r2,42(r2)
81110e94:	10bfffcc 	andi	r2,r2,65535
81110e98:	10800168 	cmpgeui	r2,r2,5
81110e9c:	10000b1e 	bne	r2,zero,81110ecc <vQCmdFeeRMAPinFullPattern+0x4f0>
						fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
81110ea0:	d0a06217 	ldw	r2,-32376(gp)
81110ea4:	e1bffc17 	ldw	r6,-16(fp)
81110ea8:	01604574 	movhi	r5,33045
81110eac:	297a9f04 	addi	r5,r5,-5508
81110eb0:	1009883a 	mov	r4,r2
81110eb4:	11232a00 	call	811232a0 <fprintf>
					}
					#endif
					break;
81110eb8:	00000406 	br	81110ecc <vQCmdFeeRMAPinFullPattern+0x4f0>
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
					}
					#endif

					break;
81110ebc:	0001883a 	nop
81110ec0:	00003906 	br	81110fa8 <vQCmdFeeRMAPinFullPattern+0x5cc>
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp," Off-Mode not allowed.\n");
					}
				#endif
					break;
81110ec4:	0001883a 	nop
81110ec8:	00003706 	br	81110fa8 <vQCmdFeeRMAPinFullPattern+0x5cc>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
					}
					#endif
					break;
81110ecc:	0001883a 	nop
			}

			break;
81110ed0:	00003506 	br	81110fa8 <vQCmdFeeRMAPinFullPattern+0x5cc>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
81110ed4:	e0bffa43 	ldbu	r2,-23(fp)
81110ed8:	1080010c 	andi	r2,r2,4
81110edc:	10803fcc 	andi	r2,r2,255
81110ee0:	1004d0ba 	srli	r2,r2,2
81110ee4:	10803fcc 	andi	r2,r2,255
81110ee8:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
81110eec:	e0bffc17 	ldw	r2,-16(fp)
81110ef0:	10002a26 	beq	r2,zero,81110f9c <vQCmdFeeRMAPinFullPattern+0x5c0>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
81110ef4:	e0bffe17 	ldw	r2,-8(fp)
81110ef8:	10802d17 	ldw	r2,180(r2)
81110efc:	10800198 	cmpnei	r2,r2,6
81110f00:	1000261e 	bne	r2,zero,81110f9c <vQCmdFeeRMAPinFullPattern+0x5c0>
					pxNFeeP->xControl.bWatingSync = FALSE;
81110f04:	e0bffe17 	ldw	r2,-8(fp)
81110f08:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
81110f0c:	e0bffe17 	ldw	r2,-8(fp)
81110f10:	10c02d17 	ldw	r3,180(r2)
81110f14:	e0bffe17 	ldw	r2,-8(fp)
81110f18:	10c02c15 	stw	r3,176(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110f1c:	00a045f4 	movhi	r2,33047
81110f20:	10a25304 	addi	r2,r2,-30388
81110f24:	10800a8b 	ldhu	r2,42(r2)
81110f28:	10bfffcc 	andi	r2,r2,65535
81110f2c:	10800168 	cmpgeui	r2,r2,5
81110f30:	10001a1e 	bne	r2,zero,81110f9c <vQCmdFeeRMAPinFullPattern+0x5c0>
						fprintf(fp," - Mode Forced.\n");
81110f34:	d0a06217 	ldw	r2,-32376(gp)
81110f38:	100f883a 	mov	r7,r2
81110f3c:	01800404 	movi	r6,16
81110f40:	01400044 	movi	r5,1
81110f44:	01204574 	movhi	r4,33045
81110f48:	213aa704 	addi	r4,r4,-5476
81110f4c:	112393c0 	call	8112393c <fwrite>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
81110f50:	00001206 	br	81110f9c <vQCmdFeeRMAPinFullPattern+0x5c0>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81110f54:	00a045f4 	movhi	r2,33047
81110f58:	10a25304 	addi	r2,r2,-30388
81110f5c:	10800a8b 	ldhu	r2,42(r2)
81110f60:	10bfffcc 	andi	r2,r2,65535
81110f64:	10800228 	cmpgeui	r2,r2,8
81110f68:	10000e1e 	bne	r2,zero,81110fa4 <vQCmdFeeRMAPinFullPattern+0x5c8>
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
81110f6c:	d0a06217 	ldw	r2,-32376(gp)
81110f70:	e0fffa03 	ldbu	r3,-24(fp)
81110f74:	180d883a 	mov	r6,r3
81110f78:	01604574 	movhi	r5,33045
81110f7c:	297a3704 	addi	r5,r5,-5924
81110f80:	1009883a 	mov	r4,r2
81110f84:	11232a00 	call	811232a0 <fprintf>
			}
			#endif
			break;
81110f88:	00000606 	br	81110fa4 <vQCmdFeeRMAPinFullPattern+0x5c8>
				}
			}



			break;
81110f8c:	0001883a 	nop
81110f90:	00000506 	br	81110fa8 <vQCmdFeeRMAPinFullPattern+0x5cc>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
				break;
81110f94:	0001883a 	nop
81110f98:	00000306 	br	81110fa8 <vQCmdFeeRMAPinFullPattern+0x5cc>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
81110f9c:	0001883a 	nop
81110fa0:	00000106 	br	81110fa8 <vQCmdFeeRMAPinFullPattern+0x5cc>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
81110fa4:	0001883a 	nop
		}
}
81110fa8:	0001883a 	nop
81110fac:	e037883a 	mov	sp,fp
81110fb0:	dfc00117 	ldw	ra,4(sp)
81110fb4:	df000017 	ldw	fp,0(sp)
81110fb8:	dec00204 	addi	sp,sp,8
81110fbc:	f800283a 	ret

81110fc0 <vQCmdFeeRMAPWaitingSync>:


void vQCmdFeeRMAPWaitingSync( TNFee *pxNFeeP, unsigned int cmd ){
81110fc0:	defff804 	addi	sp,sp,-32
81110fc4:	de00012e 	bgeu	sp,et,81110fcc <vQCmdFeeRMAPWaitingSync+0xc>
81110fc8:	003b68fa 	trap	3
81110fcc:	dfc00715 	stw	ra,28(sp)
81110fd0:	df000615 	stw	fp,24(sp)
81110fd4:	df000604 	addi	fp,sp,24
81110fd8:	e13ffe15 	stw	r4,-8(fp)
81110fdc:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110fe0:	00a045f4 	movhi	r2,33047
81110fe4:	10a25304 	addi	r2,r2,-30388
81110fe8:	10800a8b 	ldhu	r2,42(r2)
81110fec:	10bfffcc 	andi	r2,r2,65535
81110ff0:	108000e8 	cmpgeui	r2,r2,3
81110ff4:	1000091e 	bne	r2,zero,8111101c <vQCmdFeeRMAPWaitingSync+0x5c>
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (WaitingSync)\n", pxNFeeP->ucId);
81110ff8:	d0e06217 	ldw	r3,-32376(gp)
81110ffc:	e0bffe17 	ldw	r2,-8(fp)
81111000:	10800003 	ldbu	r2,0(r2)
81111004:	10803fcc 	andi	r2,r2,255
81111008:	100d883a 	mov	r6,r2
8111100c:	01604574 	movhi	r5,33045
81111010:	297aac04 	addi	r5,r5,-5456
81111014:	1809883a 	mov	r4,r3
81111018:	11232a00 	call	811232a0 <fprintf>
	}
	#endif

	uiCmdFEEL.ulWord = cmd;
8111101c:	e0bfff17 	ldw	r2,-4(fp)
81111020:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
81111024:	e0bffd43 	ldbu	r2,-11(fp)
81111028:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8111102c:	e0bffe17 	ldw	r2,-8(fp)
81111030:	10804517 	ldw	r2,276(r2)
81111034:	e0fffa03 	ldbu	r3,-24(fp)
81111038:	180b883a 	mov	r5,r3
8111103c:	1009883a 	mov	r4,r2
81111040:	110a4980 	call	8110a498 <uliRmapReadReg>
81111044:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
81111048:	e0bffa03 	ldbu	r2,-24(fp)
8111104c:	10c010c8 	cmpgei	r3,r2,67
81111050:	1800051e 	bne	r3,zero,81111068 <vQCmdFeeRMAPWaitingSync+0xa8>
81111054:	10c01008 	cmpgei	r3,r2,64
81111058:	1800081e 	bne	r3,zero,8111107c <vQCmdFeeRMAPWaitingSync+0xbc>
8111105c:	108000a0 	cmpeqi	r2,r2,2
81111060:	1000e61e 	bne	r2,zero,811113fc <vQCmdFeeRMAPWaitingSync+0x43c>
81111064:	00011e06 	br	811114e0 <vQCmdFeeRMAPWaitingSync+0x520>
81111068:	10c01350 	cmplti	r3,r2,77
8111106c:	1800991e 	bne	r3,zero,811112d4 <vQCmdFeeRMAPWaitingSync+0x314>
81111070:	10801360 	cmpeqi	r2,r2,77
81111074:	1000fa1e 	bne	r2,zero,81111460 <vQCmdFeeRMAPWaitingSync+0x4a0>
81111078:	00011906 	br	811114e0 <vQCmdFeeRMAPWaitingSync+0x520>
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config

			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
8111107c:	e0bffe17 	ldw	r2,-8(fp)
81111080:	10802d17 	ldw	r2,180(r2)
81111084:	108001e0 	cmpeqi	r2,r2,7
81111088:	1000041e 	bne	r2,zero,8111109c <vQCmdFeeRMAPWaitingSync+0xdc>
8111108c:	e0bffe17 	ldw	r2,-8(fp)
81111090:	10802d17 	ldw	r2,180(r2)
81111094:	10800318 	cmpnei	r2,r2,12
81111098:	1000771e 	bne	r2,zero,81111278 <vQCmdFeeRMAPWaitingSync+0x2b8>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8111109c:	e0bffa43 	ldbu	r2,-23(fp)
811110a0:	1080030c 	andi	r2,r2,12
811110a4:	1005d0ba 	srai	r2,r2,2
811110a8:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
811110ac:	e0bffb17 	ldw	r2,-20(fp)
811110b0:	10c000a0 	cmpeqi	r3,r2,2
811110b4:	1800141e 	bne	r3,zero,81111108 <vQCmdFeeRMAPWaitingSync+0x148>
811110b8:	10c000e0 	cmpeqi	r3,r2,3
811110bc:	1800231e 	bne	r3,zero,8111114c <vQCmdFeeRMAPWaitingSync+0x18c>
811110c0:	10800060 	cmpeqi	r2,r2,1
811110c4:	10003026 	beq	r2,zero,81111188 <vQCmdFeeRMAPWaitingSync+0x1c8>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
811110c8:	e0bffe17 	ldw	r2,-8(fp)
811110cc:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811110d0:	00a045f4 	movhi	r2,33047
811110d4:	10a25304 	addi	r2,r2,-30388
811110d8:	10800a8b 	ldhu	r2,42(r2)
811110dc:	10bfffcc 	andi	r2,r2,65535
811110e0:	108000e8 	cmpgeui	r2,r2,3
811110e4:	1000461e 	bne	r2,zero,81111200 <vQCmdFeeRMAPWaitingSync+0x240>
							fprintf(fp," - Left side\n");
811110e8:	d0a06217 	ldw	r2,-32376(gp)
811110ec:	100f883a 	mov	r7,r2
811110f0:	01800344 	movi	r6,13
811110f4:	01400044 	movi	r5,1
811110f8:	01204574 	movhi	r4,33045
811110fc:	213a0a04 	addi	r4,r4,-6104
81111100:	112393c0 	call	8112393c <fwrite>
						}
						#endif
						break;
81111104:	00003e06 	br	81111200 <vQCmdFeeRMAPWaitingSync+0x240>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
81111108:	e0bffe17 	ldw	r2,-8(fp)
8111110c:	00c00044 	movi	r3,1
81111110:	10c02e15 	stw	r3,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81111114:	00a045f4 	movhi	r2,33047
81111118:	10a25304 	addi	r2,r2,-30388
8111111c:	10800a8b 	ldhu	r2,42(r2)
81111120:	10bfffcc 	andi	r2,r2,65535
81111124:	108000e8 	cmpgeui	r2,r2,3
81111128:	1000371e 	bne	r2,zero,81111208 <vQCmdFeeRMAPWaitingSync+0x248>
							fprintf(fp," - Right side\n");
8111112c:	d0a06217 	ldw	r2,-32376(gp)
81111130:	100f883a 	mov	r7,r2
81111134:	01800384 	movi	r6,14
81111138:	01400044 	movi	r5,1
8111113c:	01204574 	movhi	r4,33045
81111140:	213a0e04 	addi	r4,r4,-6088
81111144:	112393c0 	call	8112393c <fwrite>
						}
						#endif
						break;
81111148:	00002f06 	br	81111208 <vQCmdFeeRMAPWaitingSync+0x248>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
8111114c:	e0bffe17 	ldw	r2,-8(fp)
81111150:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81111154:	00a045f4 	movhi	r2,33047
81111158:	10a25304 	addi	r2,r2,-30388
8111115c:	10800a8b 	ldhu	r2,42(r2)
81111160:	10bfffcc 	andi	r2,r2,65535
81111164:	10800168 	cmpgeui	r2,r2,5
81111168:	1000071e 	bne	r2,zero,81111188 <vQCmdFeeRMAPWaitingSync+0x1c8>
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8111116c:	d0a06217 	ldw	r2,-32376(gp)
81111170:	100f883a 	mov	r7,r2
81111174:	01800f44 	movi	r6,61
81111178:	01400044 	movi	r5,1
8111117c:	01204574 	movhi	r4,33045
81111180:	213a1204 	addi	r4,r4,-6072
81111184:	112393c0 	call	8112393c <fwrite>
						}
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
81111188:	e0bffe17 	ldw	r2,-8(fp)
8111118c:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81111190:	e0bffe17 	ldw	r2,-8(fp)
81111194:	10804504 	addi	r2,r2,276
81111198:	1009883a 	mov	r4,r2
8111119c:	11086380 	call	81108638 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
811111a0:	e0bffe17 	ldw	r2,-8(fp)
811111a4:	10c05917 	ldw	r3,356(r2)
811111a8:	00bffdc4 	movi	r2,-9
811111ac:	1886703a 	and	r3,r3,r2
811111b0:	e0bffe17 	ldw	r2,-8(fp)
811111b4:	10c05915 	stw	r3,356(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
811111b8:	e0bffe17 	ldw	r2,-8(fp)
811111bc:	10804504 	addi	r2,r2,276
811111c0:	1009883a 	mov	r4,r2
811111c4:	11083040 	call	81108304 <bRmapSetMemConfigArea>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811111c8:	00a045f4 	movhi	r2,33047
811111cc:	10a25304 	addi	r2,r2,-30388
811111d0:	10800a8b 	ldhu	r2,42(r2)
811111d4:	10bfffcc 	andi	r2,r2,65535
811111d8:	108000e8 	cmpgeui	r2,r2,3
811111dc:	10000c1e 	bne	r2,zero,81111210 <vQCmdFeeRMAPWaitingSync+0x250>
							fprintf(fp," - Switching to Left side\n");
811111e0:	d0a06217 	ldw	r2,-32376(gp)
811111e4:	100f883a 	mov	r7,r2
811111e8:	01800684 	movi	r6,26
811111ec:	01400044 	movi	r5,1
811111f0:	01204574 	movhi	r4,33045
811111f4:	213a2204 	addi	r4,r4,-6008
811111f8:	112393c0 	call	8112393c <fwrite>
						}
						#endif
					break;
811111fc:	00000406 	br	81111210 <vQCmdFeeRMAPWaitingSync+0x250>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Left side\n");
						}
						#endif
						break;
81111200:	0001883a 	nop
81111204:	00000306 	br	81111214 <vQCmdFeeRMAPWaitingSync+0x254>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Right side\n");
						}
						#endif
						break;
81111208:	0001883a 	nop
8111120c:	00000106 	br	81111214 <vQCmdFeeRMAPWaitingSync+0x254>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Switching to Left side\n");
						}
						#endif
					break;
81111210:	0001883a 	nop
				}
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81111214:	00a045f4 	movhi	r2,33047
81111218:	10a25304 	addi	r2,r2,-30388
8111121c:	10800a8b 	ldhu	r2,42(r2)
81111220:	10bfffcc 	andi	r2,r2,65535
81111224:	10800168 	cmpgeui	r2,r2,5
81111228:	10000c1e 	bne	r2,zero,8111125c <vQCmdFeeRMAPWaitingSync+0x29c>
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
8111122c:	d0e06217 	ldw	r3,-32376(gp)
81111230:	e0bffe17 	ldw	r2,-8(fp)
81111234:	10800003 	ldbu	r2,0(r2)
81111238:	11003fcc 	andi	r4,r2,255
8111123c:	e0bffe17 	ldw	r2,-8(fp)
81111240:	10802e17 	ldw	r2,184(r2)
81111244:	100f883a 	mov	r7,r2
81111248:	200d883a 	mov	r6,r4
8111124c:	01604574 	movhi	r5,33045
81111250:	297a2904 	addi	r5,r5,-5980
81111254:	1809883a 	mov	r4,r3
81111258:	11232a00 	call	811232a0 <fprintf>
				}
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
8111125c:	e0bffe17 	ldw	r2,-8(fp)
81111260:	00c00284 	movi	r3,10
81111264:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
81111268:	e0bffe17 	ldw	r2,-8(fp)
8111126c:	00c00304 	movi	r3,12
81111270:	10c02d15 	stw	r3,180(r2)
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					}
					#endif
				}
			}
			break;
81111274:	0000a806 	br	81111518 <vQCmdFeeRMAPWaitingSync+0x558>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
81111278:	e0bffe17 	ldw	r2,-8(fp)
8111127c:	10802d17 	ldw	r2,180(r2)
81111280:	10800118 	cmpnei	r2,r2,4
81111284:	1000a41e 	bne	r2,zero,81111518 <vQCmdFeeRMAPWaitingSync+0x558>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81111288:	00a045f4 	movhi	r2,33047
8111128c:	10a25304 	addi	r2,r2,-30388
81111290:	10800a8b 	ldhu	r2,42(r2)
81111294:	10bfffcc 	andi	r2,r2,65535
81111298:	10800228 	cmpgeui	r2,r2,8
8111129c:	10009e1e 	bne	r2,zero,81111518 <vQCmdFeeRMAPWaitingSync+0x558>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
811112a0:	d0e06217 	ldw	r3,-32376(gp)
811112a4:	e0bffe17 	ldw	r2,-8(fp)
811112a8:	10800003 	ldbu	r2,0(r2)
811112ac:	11003fcc 	andi	r4,r2,255
811112b0:	e0bffe17 	ldw	r2,-8(fp)
811112b4:	10802e17 	ldw	r2,184(r2)
811112b8:	100f883a 	mov	r7,r2
811112bc:	200d883a 	mov	r6,r4
811112c0:	01604574 	movhi	r5,33045
811112c4:	297a7e04 	addi	r5,r5,-5640
811112c8:	1809883a 	mov	r4,r3
811112cc:	11232a00 	call	811232a0 <fprintf>
					}
					#endif
				}
			}
			break;
811112d0:	00009106 	br	81111518 <vQCmdFeeRMAPWaitingSync+0x558>
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
		case 0x0000004C://0x00000038:operation_mode_config

		ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
811112d4:	e0bffa43 	ldbu	r2,-23(fp)
811112d8:	1004d13a 	srli	r2,r2,4
811112dc:	10803fcc 	andi	r2,r2,255
811112e0:	e0bffc15 	stw	r2,-16(fp)

		switch (ucValueMasked) {
811112e4:	e0bffc17 	ldw	r2,-16(fp)
811112e8:	10c000a0 	cmpeqi	r3,r2,2
811112ec:	18001a1e 	bne	r3,zero,81111358 <vQCmdFeeRMAPWaitingSync+0x398>
811112f0:	10c001a0 	cmpeqi	r3,r2,6
811112f4:	1800221e 	bne	r3,zero,81111380 <vQCmdFeeRMAPWaitingSync+0x3c0>
811112f8:	10002f1e 	bne	r2,zero,811113b8 <vQCmdFeeRMAPWaitingSync+0x3f8>
			case 0: /* Standby */
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811112fc:	00a045f4 	movhi	r2,33047
81111300:	10a25304 	addi	r2,r2,-30388
81111304:	10800a8b 	ldhu	r2,42(r2)
81111308:	10bfffcc 	andi	r2,r2,65535
8111130c:	108000e8 	cmpgeui	r2,r2,3
81111310:	1000071e 	bne	r2,zero,81111330 <vQCmdFeeRMAPWaitingSync+0x370>
					fprintf(fp,"- to Stand-By\n");
81111314:	d0a06217 	ldw	r2,-32376(gp)
81111318:	100f883a 	mov	r7,r2
8111131c:	01800384 	movi	r6,14
81111320:	01400044 	movi	r5,1
81111324:	01204574 	movhi	r4,33045
81111328:	213a9504 	addi	r4,r4,-5548
8111132c:	112393c0 	call	8112393c <fwrite>
				}
			#endif

				pxNFeeP->xControl.bWatingSync = TRUE;
81111330:	e0bffe17 	ldw	r2,-8(fp)
81111334:	00c00044 	movi	r3,1
81111338:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8111133c:	e0bffe17 	ldw	r2,-8(fp)
81111340:	00c00304 	movi	r3,12
81111344:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81111348:	e0bffe17 	ldw	r2,-8(fp)
8111134c:	00c00184 	movi	r3,6
81111350:	10c02d15 	stw	r3,180(r2)


				break;
81111354:	00002806 	br	811113f8 <vQCmdFeeRMAPWaitingSync+0x438>
			case 2: /* PAttern Full image */

				pxNFeeP->xControl.bWatingSync = TRUE;
81111358:	e0bffe17 	ldw	r2,-8(fp)
8111135c:	00c00044 	movi	r3,1
81111360:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
81111364:	e0bffe17 	ldw	r2,-8(fp)
81111368:	00c00304 	movi	r3,12
8111136c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sNextPatternIteration;
81111370:	e0bffe17 	ldw	r2,-8(fp)
81111374:	00c00284 	movi	r3,10
81111378:	10c02d15 	stw	r3,180(r2)

				break;
8111137c:	00001e06 	br	811113f8 <vQCmdFeeRMAPWaitingSync+0x438>
			case 6:
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81111380:	00a045f4 	movhi	r2,33047
81111384:	10a25304 	addi	r2,r2,-30388
81111388:	10800a8b 	ldhu	r2,42(r2)
8111138c:	10bfffcc 	andi	r2,r2,65535
81111390:	10800168 	cmpgeui	r2,r2,5
81111394:	1000151e 	bne	r2,zero,811113ec <vQCmdFeeRMAPWaitingSync+0x42c>
					fprintf(fp," Off-Mode not allowed.\n");
81111398:	d0a06217 	ldw	r2,-32376(gp)
8111139c:	100f883a 	mov	r7,r2
811113a0:	018005c4 	movi	r6,23
811113a4:	01400044 	movi	r5,1
811113a8:	01204574 	movhi	r4,33045
811113ac:	213a9904 	addi	r4,r4,-5532
811113b0:	112393c0 	call	8112393c <fwrite>
				}
			#endif
				break;
811113b4:	00000d06 	br	811113ec <vQCmdFeeRMAPWaitingSync+0x42c>
			case 3:
			case 4:
			case 5:
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811113b8:	00a045f4 	movhi	r2,33047
811113bc:	10a25304 	addi	r2,r2,-30388
811113c0:	10800a8b 	ldhu	r2,42(r2)
811113c4:	10bfffcc 	andi	r2,r2,65535
811113c8:	10800168 	cmpgeui	r2,r2,5
811113cc:	1000091e 	bne	r2,zero,811113f4 <vQCmdFeeRMAPWaitingSync+0x434>
					fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
811113d0:	d0a06217 	ldw	r2,-32376(gp)
811113d4:	e1bffc17 	ldw	r6,-16(fp)
811113d8:	01604574 	movhi	r5,33045
811113dc:	297a9f04 	addi	r5,r5,-5508
811113e0:	1009883a 	mov	r4,r2
811113e4:	11232a00 	call	811232a0 <fprintf>
				}
				#endif
				break;
811113e8:	00000206 	br	811113f4 <vQCmdFeeRMAPWaitingSync+0x434>
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp," Off-Mode not allowed.\n");
				}
			#endif
				break;
811113ec:	0001883a 	nop
811113f0:	00004e06 	br	8111152c <vQCmdFeeRMAPWaitingSync+0x56c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
				}
				#endif
				break;
811113f4:	0001883a 	nop
		}

			break;
811113f8:	00004c06 	br	8111152c <vQCmdFeeRMAPWaitingSync+0x56c>
		case 2: /* PAttern Full image */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811113fc:	00a045f4 	movhi	r2,33047
81111400:	10a25304 	addi	r2,r2,-30388
81111404:	10800a8b 	ldhu	r2,42(r2)
81111408:	10bfffcc 	andi	r2,r2,65535
8111140c:	10800168 	cmpgeui	r2,r2,5
81111410:	1000091e 	bne	r2,zero,81111438 <vQCmdFeeRMAPWaitingSync+0x478>
				fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
81111414:	d0e06217 	ldw	r3,-32376(gp)
81111418:	e0bffe17 	ldw	r2,-8(fp)
8111141c:	10800003 	ldbu	r2,0(r2)
81111420:	10803fcc 	andi	r2,r2,255
81111424:	100d883a 	mov	r6,r2
81111428:	01604574 	movhi	r5,33045
8111142c:	2979da04 	addi	r5,r5,-6296
81111430:	1809883a 	mov	r4,r3
81111434:	11232a00 	call	811232a0 <fprintf>
			}
			#endif

			pxNFeeP->xControl.bWatingSync = TRUE;
81111438:	e0bffe17 	ldw	r2,-8(fp)
8111143c:	00c00044 	movi	r3,1
81111440:	10c02815 	stw	r3,160(r2)
			pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
81111444:	e0bffe17 	ldw	r2,-8(fp)
81111448:	00c00284 	movi	r3,10
8111144c:	10c02c15 	stw	r3,176(r2)
			pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
81111450:	e0bffe17 	ldw	r2,-8(fp)
81111454:	00c00304 	movi	r3,12
81111458:	10c02d15 	stw	r3,180(r2)

			break;
8111145c:	00003306 	br	8111152c <vQCmdFeeRMAPWaitingSync+0x56c>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
81111460:	e0bffa43 	ldbu	r2,-23(fp)
81111464:	1080010c 	andi	r2,r2,4
81111468:	10803fcc 	andi	r2,r2,255
8111146c:	1004d0ba 	srli	r2,r2,2
81111470:	10803fcc 	andi	r2,r2,255
81111474:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
81111478:	e0bffc17 	ldw	r2,-16(fp)
8111147c:	10002826 	beq	r2,zero,81111520 <vQCmdFeeRMAPWaitingSync+0x560>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
81111480:	e0bffe17 	ldw	r2,-8(fp)
81111484:	10802d17 	ldw	r2,180(r2)
81111488:	10800198 	cmpnei	r2,r2,6
8111148c:	1000241e 	bne	r2,zero,81111520 <vQCmdFeeRMAPWaitingSync+0x560>
					pxNFeeP->xControl.bWatingSync = FALSE;
81111490:	e0bffe17 	ldw	r2,-8(fp)
81111494:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
81111498:	e0bffe17 	ldw	r2,-8(fp)
8111149c:	10c02d17 	ldw	r3,180(r2)
811114a0:	e0bffe17 	ldw	r2,-8(fp)
811114a4:	10c02c15 	stw	r3,176(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811114a8:	00a045f4 	movhi	r2,33047
811114ac:	10a25304 	addi	r2,r2,-30388
811114b0:	10800a8b 	ldhu	r2,42(r2)
811114b4:	10bfffcc 	andi	r2,r2,65535
811114b8:	10800168 	cmpgeui	r2,r2,5
811114bc:	1000181e 	bne	r2,zero,81111520 <vQCmdFeeRMAPWaitingSync+0x560>
						fprintf(fp," - Mode Forced.\n");
811114c0:	d0a06217 	ldw	r2,-32376(gp)
811114c4:	100f883a 	mov	r7,r2
811114c8:	01800404 	movi	r6,16
811114cc:	01400044 	movi	r5,1
811114d0:	01204574 	movhi	r4,33045
811114d4:	213aa704 	addi	r4,r4,-5476
811114d8:	112393c0 	call	8112393c <fwrite>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
811114dc:	00001006 	br	81111520 <vQCmdFeeRMAPWaitingSync+0x560>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811114e0:	00a045f4 	movhi	r2,33047
811114e4:	10a25304 	addi	r2,r2,-30388
811114e8:	10800a8b 	ldhu	r2,42(r2)
811114ec:	10bfffcc 	andi	r2,r2,65535
811114f0:	10800228 	cmpgeui	r2,r2,8
811114f4:	10000c1e 	bne	r2,zero,81111528 <vQCmdFeeRMAPWaitingSync+0x568>
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
811114f8:	d0a06217 	ldw	r2,-32376(gp)
811114fc:	e0fffa03 	ldbu	r3,-24(fp)
81111500:	180d883a 	mov	r6,r3
81111504:	01604574 	movhi	r5,33045
81111508:	297a6804 	addi	r5,r5,-5728
8111150c:	1009883a 	mov	r4,r2
81111510:	11232a00 	call	811232a0 <fprintf>
			}
			#endif
			break;
81111514:	00000406 	br	81111528 <vQCmdFeeRMAPWaitingSync+0x568>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					}
					#endif
				}
			}
			break;
81111518:	0001883a 	nop
8111151c:	00000306 	br	8111152c <vQCmdFeeRMAPWaitingSync+0x56c>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81111520:	0001883a 	nop
81111524:	00000106 	br	8111152c <vQCmdFeeRMAPWaitingSync+0x56c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
81111528:	0001883a 	nop
		}
}
8111152c:	0001883a 	nop
81111530:	e037883a 	mov	sp,fp
81111534:	dfc00117 	ldw	ra,4(sp)
81111538:	df000017 	ldw	fp,0(sp)
8111153c:	dec00204 	addi	sp,sp,8
81111540:	f800283a 	ret

81111544 <bDisableRmapIRQ>:


bool bDisableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
81111544:	defffc04 	addi	sp,sp,-16
81111548:	de00012e 	bgeu	sp,et,81111550 <bDisableRmapIRQ+0xc>
8111154c:	003b68fa 	trap	3
81111550:	dfc00315 	stw	ra,12(sp)
81111554:	df000215 	stw	fp,8(sp)
81111558:	df000204 	addi	fp,sp,8
8111155c:	e13ffe15 	stw	r4,-8(fp)
81111560:	2805883a 	mov	r2,r5
81111564:	e0bfff05 	stb	r2,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
81111568:	e13ffe17 	ldw	r4,-8(fp)
8111156c:	1107dcc0 	call	81107dcc <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
81111570:	e0bffe17 	ldw	r2,-8(fp)
81111574:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
81111578:	e13ffe17 	ldw	r4,-8(fp)
8111157c:	1107d200 	call	81107d20 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81111580:	00800044 	movi	r2,1
}
81111584:	e037883a 	mov	sp,fp
81111588:	dfc00117 	ldw	ra,4(sp)
8111158c:	df000017 	ldw	fp,0(sp)
81111590:	dec00204 	addi	sp,sp,8
81111594:	f800283a 	ret

81111598 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
81111598:	defffc04 	addi	sp,sp,-16
8111159c:	de00012e 	bgeu	sp,et,811115a4 <bEnableRmapIRQ+0xc>
811115a0:	003b68fa 	trap	3
811115a4:	dfc00315 	stw	ra,12(sp)
811115a8:	df000215 	stw	fp,8(sp)
811115ac:	df000204 	addi	fp,sp,8
811115b0:	e13ffe15 	stw	r4,-8(fp)
811115b4:	2805883a 	mov	r2,r5
811115b8:	e0bfff05 	stb	r2,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	//bRmapGetMemConfigArea(&xRmap[ucId]);

	bRmapGetIrqControl(pxRmapCh);
811115bc:	e13ffe17 	ldw	r4,-8(fp)
811115c0:	1107dcc0 	call	81107dcc <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
811115c4:	e0bffe17 	ldw	r2,-8(fp)
811115c8:	00c00044 	movi	r3,1
811115cc:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
811115d0:	e13ffe17 	ldw	r4,-8(fp)
811115d4:	1107d200 	call	81107d20 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
811115d8:	00800044 	movi	r2,1
}
811115dc:	e037883a 	mov	sp,fp
811115e0:	dfc00117 	ldw	ra,4(sp)
811115e4:	df000017 	ldw	fp,0(sp)
811115e8:	dec00204 	addi	sp,sp,8
811115ec:	f800283a 	ret

811115f0 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
811115f0:	defffd04 	addi	sp,sp,-12
811115f4:	de00012e 	bgeu	sp,et,811115fc <bDisableSPWChannel+0xc>
811115f8:	003b68fa 	trap	3
811115fc:	dfc00215 	stw	ra,8(sp)
81111600:	df000115 	stw	fp,4(sp)
81111604:	df000104 	addi	fp,sp,4
81111608:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
8111160c:	e13fff17 	ldw	r4,-4(fp)
81111610:	110a8880 	call	8110a888 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
81111614:	e0bfff17 	ldw	r2,-4(fp)
81111618:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
8111161c:	e0bfff17 	ldw	r2,-4(fp)
81111620:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
81111624:	e0bfff17 	ldw	r2,-4(fp)
81111628:	00c00044 	movi	r3,1
8111162c:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
81111630:	e13fff17 	ldw	r4,-4(fp)
81111634:	110a7500 	call	8110a750 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
81111638:	00800044 	movi	r2,1
}
8111163c:	e037883a 	mov	sp,fp
81111640:	dfc00117 	ldw	ra,4(sp)
81111644:	df000017 	ldw	fp,0(sp)
81111648:	dec00204 	addi	sp,sp,8
8111164c:	f800283a 	ret

81111650 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
81111650:	defffd04 	addi	sp,sp,-12
81111654:	de00012e 	bgeu	sp,et,8111165c <bEnableSPWChannel+0xc>
81111658:	003b68fa 	trap	3
8111165c:	dfc00215 	stw	ra,8(sp)
81111660:	df000115 	stw	fp,4(sp)
81111664:	df000104 	addi	fp,sp,4
81111668:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
8111166c:	e13fff17 	ldw	r4,-4(fp)
81111670:	110a8880 	call	8110a888 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
81111674:	e0bfff17 	ldw	r2,-4(fp)
81111678:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
8111167c:	e0bfff17 	ldw	r2,-4(fp)
81111680:	00c00044 	movi	r3,1
81111684:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
81111688:	e0bfff17 	ldw	r2,-4(fp)
8111168c:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
81111690:	e13fff17 	ldw	r4,-4(fp)
81111694:	110a7500 	call	8110a750 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
81111698:	00800044 	movi	r2,1
}
8111169c:	e037883a 	mov	sp,fp
811116a0:	dfc00117 	ldw	ra,4(sp)
811116a4:	df000017 	ldw	fp,0(sp)
811116a8:	dec00204 	addi	sp,sp,8
811116ac:	f800283a 	ret

811116b0 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
811116b0:	defffd04 	addi	sp,sp,-12
811116b4:	de00012e 	bgeu	sp,et,811116bc <bEnableDbBuffer+0xc>
811116b8:	003b68fa 	trap	3
811116bc:	dfc00215 	stw	ra,8(sp)
811116c0:	df000115 	stw	fp,4(sp)
811116c4:	df000104 	addi	fp,sp,4
811116c8:	e13fff15 	stw	r4,-4(fp)
	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
811116cc:	e13fff17 	ldw	r4,-4(fp)
811116d0:	1106d100 	call	81106d10 <bFeebStopCh>
	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
811116d4:	e13fff17 	ldw	r4,-4(fp)
811116d8:	1106d9c0 	call	81106d9c <bFeebClrCh>
	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
811116dc:	e13fff17 	ldw	r4,-4(fp)
811116e0:	1106c840 	call	81106c84 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
811116e4:	e13fff17 	ldw	r4,-4(fp)
811116e8:	1106bfc0 	call	81106bfc <bFeebGetWindowing>
	//pxFeebCh->xWindowingConfig.bMasking = DATA_PACKET;/* True= data packet;    FALSE= Transparent mode */
	pxFeebCh->xWindowingConfig.bMasking = xDefaults.bDataPacket;
811116ec:	00a045f4 	movhi	r2,33047
811116f0:	10a25304 	addi	r2,r2,-30388
811116f4:	10c00417 	ldw	r3,16(r2)
811116f8:	e0bfff17 	ldw	r2,-4(fp)
811116fc:	10c00115 	stw	r3,4(r2)
	bFeebSetWindowing(pxFeebCh);
81111700:	e13fff17 	ldw	r4,-4(fp)
81111704:	1106b500 	call	81106b50 <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
81111708:	e13fff17 	ldw	r4,-4(fp)
8111170c:	11063b00 	call	811063b0 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81111710:	e0bfff17 	ldw	r2,-4(fp)
81111714:	00c00044 	movi	r3,1
81111718:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8111171c:	e0bfff17 	ldw	r2,-4(fp)
81111720:	00c00044 	movi	r3,1
81111724:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
81111728:	e13fff17 	ldw	r4,-4(fp)
8111172c:	11062d80 	call	811062d8 <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81111730:	00800044 	movi	r2,1
}
81111734:	e037883a 	mov	sp,fp
81111738:	dfc00117 	ldw	ra,4(sp)
8111173c:	df000017 	ldw	fp,0(sp)
81111740:	dec00204 	addi	sp,sp,8
81111744:	f800283a 	ret

81111748 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
81111748:	defffd04 	addi	sp,sp,-12
8111174c:	de00012e 	bgeu	sp,et,81111754 <bDisAndClrDbBuffer+0xc>
81111750:	003b68fa 	trap	3
81111754:	dfc00215 	stw	ra,8(sp)
81111758:	df000115 	stw	fp,4(sp)
8111175c:	df000104 	addi	fp,sp,4
81111760:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
81111764:	e13fff17 	ldw	r4,-4(fp)
81111768:	11063b00 	call	811063b0 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
8111176c:	e0bfff17 	ldw	r2,-4(fp)
81111770:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81111774:	e0bfff17 	ldw	r2,-4(fp)
81111778:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8111177c:	e13fff17 	ldw	r4,-4(fp)
81111780:	11062d80 	call	811062d8 <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
81111784:	e13fff17 	ldw	r4,-4(fp)
81111788:	1106d100 	call	81106d10 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8111178c:	e13fff17 	ldw	r4,-4(fp)
81111790:	1106d9c0 	call	81106d9c <bFeebClrCh>
	bFeebStartCh(pxFeebCh);
81111794:	e13fff17 	ldw	r4,-4(fp)
81111798:	1106c840 	call	81106c84 <bFeebStartCh>

	/*todo: No treatment for now  */
	return TRUE;
8111179c:	00800044 	movi	r2,1
}
811117a0:	e037883a 	mov	sp,fp
811117a4:	dfc00117 	ldw	ra,4(sp)
811117a8:	df000017 	ldw	fp,0(sp)
811117ac:	dec00204 	addi	sp,sp,8
811117b0:	f800283a 	ret

811117b4 <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811117b4:	defff804 	addi	sp,sp,-32
811117b8:	de00012e 	bgeu	sp,et,811117c0 <bSendRequestNFeeCtrl+0xc>
811117bc:	003b68fa 	trap	3
811117c0:	dfc00715 	stw	ra,28(sp)
811117c4:	df000615 	stw	fp,24(sp)
811117c8:	df000604 	addi	fp,sp,24
811117cc:	2807883a 	mov	r3,r5
811117d0:	3005883a 	mov	r2,r6
811117d4:	e13ffd05 	stb	r4,-12(fp)
811117d8:	e0fffe05 	stb	r3,-8(fp)
811117dc:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811117e0:	00800404 	movi	r2,16
811117e4:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811117e8:	e0bffd03 	ldbu	r2,-12(fp)
811117ec:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811117f0:	e0bffe03 	ldbu	r2,-8(fp)
811117f4:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811117f8:	e0bfff03 	ldbu	r2,-4(fp)
811117fc:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81111800:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81111804:	d0a05d17 	ldw	r2,-32396(gp)
81111808:	e0fffc17 	ldw	r3,-16(fp)
8111180c:	180b883a 	mov	r5,r3
81111810:	1009883a 	mov	r4,r2
81111814:	113fc6c0 	call	8113fc6c <OSQPost>
81111818:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111181c:	e0bffb03 	ldbu	r2,-20(fp)
81111820:	10000526 	beq	r2,zero,81111838 <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
81111824:	e0bfff03 	ldbu	r2,-4(fp)
81111828:	1009883a 	mov	r4,r2
8111182c:	111f0300 	call	8111f030 <vFailRequestDMA>
		bSuccesL = FALSE;
81111830:	e03ffa15 	stw	zero,-24(fp)
81111834:	00000206 	br	81111840 <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81111838:	00800044 	movi	r2,1
8111183c:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
81111840:	e0bffa17 	ldw	r2,-24(fp)
}
81111844:	e037883a 	mov	sp,fp
81111848:	dfc00117 	ldw	ra,4(sp)
8111184c:	df000017 	ldw	fp,0(sp)
81111850:	dec00204 	addi	sp,sp,8
81111854:	f800283a 	ret

81111858 <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111858:	defff804 	addi	sp,sp,-32
8111185c:	de00012e 	bgeu	sp,et,81111864 <bSendGiveBackNFeeCtrl+0xc>
81111860:	003b68fa 	trap	3
81111864:	dfc00715 	stw	ra,28(sp)
81111868:	df000615 	stw	fp,24(sp)
8111186c:	df000604 	addi	fp,sp,24
81111870:	2807883a 	mov	r3,r5
81111874:	3005883a 	mov	r2,r6
81111878:	e13ffd05 	stb	r4,-12(fp)
8111187c:	e0fffe05 	stb	r3,-8(fp)
81111880:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81111884:	00800404 	movi	r2,16
81111888:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111188c:	e0bffd03 	ldbu	r2,-12(fp)
81111890:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111894:	e0bffe03 	ldbu	r2,-8(fp)
81111898:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111189c:	e0bfff03 	ldbu	r2,-4(fp)
811118a0:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
811118a4:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811118a8:	d0a07017 	ldw	r2,-32320(gp)
811118ac:	e0fffc17 	ldw	r3,-16(fp)
811118b0:	180b883a 	mov	r5,r3
811118b4:	1009883a 	mov	r4,r2
811118b8:	113fc6c0 	call	8113fc6c <OSQPost>
811118bc:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811118c0:	e0bffb03 	ldbu	r2,-20(fp)
811118c4:	10000526 	beq	r2,zero,811118dc <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
811118c8:	e0bfff03 	ldbu	r2,-4(fp)
811118cc:	1009883a 	mov	r4,r2
811118d0:	111f0300 	call	8111f030 <vFailRequestDMA>
		bSuccesL = FALSE;
811118d4:	e03ffa15 	stw	zero,-24(fp)
811118d8:	00000206 	br	811118e4 <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
811118dc:	00800044 	movi	r2,1
811118e0:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
811118e4:	e0bffa17 	ldw	r2,-24(fp)
}
811118e8:	e037883a 	mov	sp,fp
811118ec:	dfc00117 	ldw	ra,4(sp)
811118f0:	df000017 	ldw	fp,0(sp)
811118f4:	dec00204 	addi	sp,sp,8
811118f8:	f800283a 	ret

811118fc <vPrintConsoleNFee>:




#if DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
811118fc:	defffa04 	addi	sp,sp,-24
81111900:	de00012e 	bgeu	sp,et,81111908 <vPrintConsoleNFee+0xc>
81111904:	003b68fa 	trap	3
81111908:	dfc00515 	stw	ra,20(sp)
8111190c:	df000415 	stw	fp,16(sp)
81111910:	df000404 	addi	fp,sp,16
81111914:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
81111918:	e0bfff17 	ldw	r2,-4(fp)
8111191c:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
81111920:	d0e06217 	ldw	r3,-32376(gp)
81111924:	e0bffe17 	ldw	r2,-8(fp)
81111928:	10800003 	ldbu	r2,0(r2)
8111192c:	10803fcc 	andi	r2,r2,255
81111930:	100d883a 	mov	r6,r2
81111934:	01604574 	movhi	r5,33045
81111938:	297ab904 	addi	r5,r5,-5404
8111193c:	1809883a 	mov	r4,r3
81111940:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"\n");
81111944:	d0a06217 	ldw	r2,-32376(gp)
81111948:	100b883a 	mov	r5,r2
8111194c:	01000284 	movi	r4,10
81111950:	11233180 	call	81123318 <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
81111954:	d0e06217 	ldw	r3,-32376(gp)
81111958:	e0bffe17 	ldw	r2,-8(fp)
8111195c:	10800003 	ldbu	r2,0(r2)
81111960:	10803fcc 	andi	r2,r2,255
81111964:	100d883a 	mov	r6,r2
81111968:	01604574 	movhi	r5,33045
8111196c:	297ace04 	addi	r5,r5,-5320
81111970:	1809883a 	mov	r4,r3
81111974:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
81111978:	d0e06217 	ldw	r3,-32376(gp)
8111197c:	e0bffe17 	ldw	r2,-8(fp)
81111980:	10802f0b 	ldhu	r2,188(r2)
81111984:	10bfffcc 	andi	r2,r2,65535
81111988:	100d883a 	mov	r6,r2
8111198c:	01604574 	movhi	r5,33045
81111990:	297ad404 	addi	r5,r5,-5296
81111994:	1809883a 	mov	r4,r3
81111998:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
8111199c:	d0e06217 	ldw	r3,-32376(gp)
811119a0:	e0bffe17 	ldw	r2,-8(fp)
811119a4:	10802f8b 	ldhu	r2,190(r2)
811119a8:	10bfffcc 	andi	r2,r2,65535
811119ac:	100d883a 	mov	r6,r2
811119b0:	01604574 	movhi	r5,33045
811119b4:	297ad904 	addi	r5,r5,-5276
811119b8:	1809883a 	mov	r4,r3
811119bc:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
811119c0:	d0e06217 	ldw	r3,-32376(gp)
811119c4:	e0bffe17 	ldw	r2,-8(fp)
811119c8:	1080300b 	ldhu	r2,192(r2)
811119cc:	10bfffcc 	andi	r2,r2,65535
811119d0:	100d883a 	mov	r6,r2
811119d4:	01604574 	movhi	r5,33045
811119d8:	297adf04 	addi	r5,r5,-5252
811119dc:	1809883a 	mov	r4,r3
811119e0:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
811119e4:	d0e06217 	ldw	r3,-32376(gp)
811119e8:	e0bffe17 	ldw	r2,-8(fp)
811119ec:	1080308b 	ldhu	r2,194(r2)
811119f0:	10bfffcc 	andi	r2,r2,65535
811119f4:	100d883a 	mov	r6,r2
811119f8:	01604574 	movhi	r5,33045
811119fc:	297ae304 	addi	r5,r5,-5236
81111a00:	1809883a 	mov	r4,r3
81111a04:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
81111a08:	d0e06217 	ldw	r3,-32376(gp)
81111a0c:	e0bffe17 	ldw	r2,-8(fp)
81111a10:	1080310b 	ldhu	r2,196(r2)
81111a14:	10bfffcc 	andi	r2,r2,65535
81111a18:	100d883a 	mov	r6,r2
81111a1c:	01604574 	movhi	r5,33045
81111a20:	297ae904 	addi	r5,r5,-5212
81111a24:	1809883a 	mov	r4,r3
81111a28:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"\n");
81111a2c:	d0a06217 	ldw	r2,-32376(gp)
81111a30:	100b883a 	mov	r5,r2
81111a34:	01000284 	movi	r4,10
81111a38:	11233180 	call	81123318 <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
81111a3c:	d0e06217 	ldw	r3,-32376(gp)
81111a40:	e0bffe17 	ldw	r2,-8(fp)
81111a44:	10800003 	ldbu	r2,0(r2)
81111a48:	10803fcc 	andi	r2,r2,255
81111a4c:	100d883a 	mov	r6,r2
81111a50:	01604574 	movhi	r5,33045
81111a54:	297aee04 	addi	r5,r5,-5192
81111a58:	1809883a 	mov	r4,r3
81111a5c:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
81111a60:	d0e06217 	ldw	r3,-32376(gp)
81111a64:	e0bffe17 	ldw	r2,-8(fp)
81111a68:	10802c17 	ldw	r2,176(r2)
81111a6c:	100d883a 	mov	r6,r2
81111a70:	01604574 	movhi	r5,33045
81111a74:	297af404 	addi	r5,r5,-5168
81111a78:	1809883a 	mov	r4,r3
81111a7c:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
81111a80:	d0e06217 	ldw	r3,-32376(gp)
81111a84:	e0bffe17 	ldw	r2,-8(fp)
81111a88:	10802117 	ldw	r2,132(r2)
81111a8c:	100d883a 	mov	r6,r2
81111a90:	01604574 	movhi	r5,33045
81111a94:	297afa04 	addi	r5,r5,-5144
81111a98:	1809883a 	mov	r4,r3
81111a9c:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
81111aa0:	d0e06217 	ldw	r3,-32376(gp)
81111aa4:	e0bffe17 	ldw	r2,-8(fp)
81111aa8:	10802317 	ldw	r2,140(r2)
81111aac:	100d883a 	mov	r6,r2
81111ab0:	01604574 	movhi	r5,33045
81111ab4:	297b0104 	addi	r5,r5,-5116
81111ab8:	1809883a 	mov	r4,r3
81111abc:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
81111ac0:	d0e06217 	ldw	r3,-32376(gp)
81111ac4:	e0bffe17 	ldw	r2,-8(fp)
81111ac8:	10802417 	ldw	r2,144(r2)
81111acc:	100d883a 	mov	r6,r2
81111ad0:	01604574 	movhi	r5,33045
81111ad4:	297b0804 	addi	r5,r5,-5088
81111ad8:	1809883a 	mov	r4,r3
81111adc:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
81111ae0:	d0e06217 	ldw	r3,-32376(gp)
81111ae4:	e0bffe17 	ldw	r2,-8(fp)
81111ae8:	10802517 	ldw	r2,148(r2)
81111aec:	100d883a 	mov	r6,r2
81111af0:	01604574 	movhi	r5,33045
81111af4:	297b0f04 	addi	r5,r5,-5060
81111af8:	1809883a 	mov	r4,r3
81111afc:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
81111b00:	d0e06217 	ldw	r3,-32376(gp)
81111b04:	e0bffe17 	ldw	r2,-8(fp)
81111b08:	10802617 	ldw	r2,152(r2)
81111b0c:	100d883a 	mov	r6,r2
81111b10:	01604574 	movhi	r5,33045
81111b14:	297b1604 	addi	r5,r5,-5032
81111b18:	1809883a 	mov	r4,r3
81111b1c:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
81111b20:	d1206217 	ldw	r4,-32376(gp)
81111b24:	e0bffe17 	ldw	r2,-8(fp)
81111b28:	10802a43 	ldbu	r2,169(r2)
81111b2c:	11403fcc 	andi	r5,r2,255
81111b30:	e0bffe17 	ldw	r2,-8(fp)
81111b34:	10802a83 	ldbu	r2,170(r2)
81111b38:	11803fcc 	andi	r6,r2,255
81111b3c:	e0bffe17 	ldw	r2,-8(fp)
81111b40:	10802ac3 	ldbu	r2,171(r2)
81111b44:	10803fcc 	andi	r2,r2,255
81111b48:	e0fffe17 	ldw	r3,-8(fp)
81111b4c:	18c02b03 	ldbu	r3,172(r3)
81111b50:	18c03fcc 	andi	r3,r3,255
81111b54:	d8c00115 	stw	r3,4(sp)
81111b58:	d8800015 	stw	r2,0(sp)
81111b5c:	300f883a 	mov	r7,r6
81111b60:	280d883a 	mov	r6,r5
81111b64:	01604574 	movhi	r5,33045
81111b68:	297b1d04 	addi	r5,r5,-5004
81111b6c:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
81111b70:	d0e06217 	ldw	r3,-32376(gp)
81111b74:	e0bffe17 	ldw	r2,-8(fp)
81111b78:	10802e17 	ldw	r2,184(r2)
81111b7c:	100d883a 	mov	r6,r2
81111b80:	01604574 	movhi	r5,33045
81111b84:	297b2a04 	addi	r5,r5,-4952
81111b88:	1809883a 	mov	r4,r3
81111b8c:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"\n\n");
81111b90:	d0a06217 	ldw	r2,-32376(gp)
81111b94:	100f883a 	mov	r7,r2
81111b98:	01800084 	movi	r6,2
81111b9c:	01400044 	movi	r5,1
81111ba0:	01204574 	movhi	r4,33045
81111ba4:	213b3004 	addi	r4,r4,-4928
81111ba8:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
81111bac:	d0e06217 	ldw	r3,-32376(gp)
81111bb0:	e0bffe17 	ldw	r2,-8(fp)
81111bb4:	10800003 	ldbu	r2,0(r2)
81111bb8:	10803fcc 	andi	r2,r2,255
81111bbc:	100d883a 	mov	r6,r2
81111bc0:	01604574 	movhi	r5,33045
81111bc4:	297b3104 	addi	r5,r5,-4924
81111bc8:	1809883a 	mov	r4,r3
81111bcc:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    General Info: \n");
81111bd0:	d0a06217 	ldw	r2,-32376(gp)
81111bd4:	100f883a 	mov	r7,r2
81111bd8:	018004c4 	movi	r6,19
81111bdc:	01400044 	movi	r5,1
81111be0:	01204574 	movhi	r4,33045
81111be4:	213b3704 	addi	r4,r4,-4900
81111be8:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
81111bec:	d0e06217 	ldw	r3,-32376(gp)
81111bf0:	e0bffe17 	ldw	r2,-8(fp)
81111bf4:	10800117 	ldw	r2,4(r2)
81111bf8:	100d883a 	mov	r6,r2
81111bfc:	01604574 	movhi	r5,33045
81111c00:	297b3c04 	addi	r5,r5,-4880
81111c04:	1809883a 	mov	r4,r3
81111c08:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
81111c0c:	d0e06217 	ldw	r3,-32376(gp)
81111c10:	e0bffe17 	ldw	r2,-8(fp)
81111c14:	10800217 	ldw	r2,8(r2)
81111c18:	100d883a 	mov	r6,r2
81111c1c:	01604574 	movhi	r5,33045
81111c20:	297b4404 	addi	r5,r5,-4848
81111c24:	1809883a 	mov	r4,r3
81111c28:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
81111c2c:	d0e06217 	ldw	r3,-32376(gp)
81111c30:	e0bffe17 	ldw	r2,-8(fp)
81111c34:	10800317 	ldw	r2,12(r2)
81111c38:	100d883a 	mov	r6,r2
81111c3c:	01604574 	movhi	r5,33045
81111c40:	297b4c04 	addi	r5,r5,-4816
81111c44:	1809883a 	mov	r4,r3
81111c48:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
81111c4c:	d0a06217 	ldw	r2,-32376(gp)
81111c50:	100f883a 	mov	r7,r2
81111c54:	01800644 	movi	r6,25
81111c58:	01400044 	movi	r5,1
81111c5c:	01204574 	movhi	r4,33045
81111c60:	213b5304 	addi	r4,r4,-4788
81111c64:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
81111c68:	d0e06217 	ldw	r3,-32376(gp)
81111c6c:	e0bffe17 	ldw	r2,-8(fp)
81111c70:	10800517 	ldw	r2,20(r2)
81111c74:	100d883a 	mov	r6,r2
81111c78:	01604574 	movhi	r5,33045
81111c7c:	297b4404 	addi	r5,r5,-4848
81111c80:	1809883a 	mov	r4,r3
81111c84:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        Total of Blocks = %lu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
81111c88:	d0e06217 	ldw	r3,-32376(gp)
81111c8c:	e0bffe17 	ldw	r2,-8(fp)
81111c90:	10800417 	ldw	r2,16(r2)
81111c94:	100d883a 	mov	r6,r2
81111c98:	01604574 	movhi	r5,33045
81111c9c:	297b5a04 	addi	r5,r5,-4760
81111ca0:	1809883a 	mov	r4,r3
81111ca4:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
81111ca8:	d0e06217 	ldw	r3,-32376(gp)
81111cac:	e0bffe17 	ldw	r2,-8(fp)
81111cb0:	10800603 	ldbu	r2,24(r2)
81111cb4:	10803fcc 	andi	r2,r2,255
81111cb8:	100d883a 	mov	r6,r2
81111cbc:	01604574 	movhi	r5,33045
81111cc0:	297b6204 	addi	r5,r5,-4728
81111cc4:	1809883a 	mov	r4,r3
81111cc8:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
81111ccc:	d2206217 	ldw	r8,-32376(gp)
81111cd0:	e13ffe17 	ldw	r4,-8(fp)
81111cd4:	20800717 	ldw	r2,28(r4)
81111cd8:	20c00817 	ldw	r3,32(r4)
81111cdc:	100d883a 	mov	r6,r2
81111ce0:	180f883a 	mov	r7,r3
81111ce4:	01604574 	movhi	r5,33045
81111ce8:	297b6a04 	addi	r5,r5,-4696
81111cec:	4009883a 	mov	r4,r8
81111cf0:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"\n");
81111cf4:	d0a06217 	ldw	r2,-32376(gp)
81111cf8:	100b883a 	mov	r5,r2
81111cfc:	01000284 	movi	r4,10
81111d00:	11233180 	call	81123318 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
81111d04:	d0e06217 	ldw	r3,-32376(gp)
81111d08:	e0bffe17 	ldw	r2,-8(fp)
81111d0c:	10800003 	ldbu	r2,0(r2)
81111d10:	10803fcc 	andi	r2,r2,255
81111d14:	100f883a 	mov	r7,r2
81111d18:	000d883a 	mov	r6,zero
81111d1c:	01604574 	movhi	r5,33045
81111d20:	297b7204 	addi	r5,r5,-4664
81111d24:	1809883a 	mov	r4,r3
81111d28:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        Left side \n");
81111d2c:	d0a06217 	ldw	r2,-32376(gp)
81111d30:	100f883a 	mov	r7,r2
81111d34:	018004c4 	movi	r6,19
81111d38:	01400044 	movi	r5,1
81111d3c:	01204574 	movhi	r4,33045
81111d40:	213b7c04 	addi	r4,r4,-4624
81111d44:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
81111d48:	d0e06217 	ldw	r3,-32376(gp)
81111d4c:	e0bffe17 	ldw	r2,-8(fp)
81111d50:	10800917 	ldw	r2,36(r2)
81111d54:	100d883a 	mov	r6,r2
81111d58:	01604574 	movhi	r5,33045
81111d5c:	297b8104 	addi	r5,r5,-4604
81111d60:	1809883a 	mov	r4,r3
81111d64:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
81111d68:	d0e06217 	ldw	r3,-32376(gp)
81111d6c:	e0bffe17 	ldw	r2,-8(fp)
81111d70:	10800a17 	ldw	r2,40(r2)
81111d74:	100d883a 	mov	r6,r2
81111d78:	01604574 	movhi	r5,33045
81111d7c:	297b8a04 	addi	r5,r5,-4568
81111d80:	1809883a 	mov	r4,r3
81111d84:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
81111d88:	d0e06217 	ldw	r3,-32376(gp)
81111d8c:	e0bffe17 	ldw	r2,-8(fp)
81111d90:	10800b17 	ldw	r2,44(r2)
81111d94:	100d883a 	mov	r6,r2
81111d98:	01604574 	movhi	r5,33045
81111d9c:	297b9504 	addi	r5,r5,-4524
81111da0:	1809883a 	mov	r4,r3
81111da4:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        Right side \n");
81111da8:	d0a06217 	ldw	r2,-32376(gp)
81111dac:	100f883a 	mov	r7,r2
81111db0:	01800504 	movi	r6,20
81111db4:	01400044 	movi	r5,1
81111db8:	01204574 	movhi	r4,33045
81111dbc:	213ba104 	addi	r4,r4,-4476
81111dc0:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
81111dc4:	d0e06217 	ldw	r3,-32376(gp)
81111dc8:	e0bffe17 	ldw	r2,-8(fp)
81111dcc:	10800c17 	ldw	r2,48(r2)
81111dd0:	100d883a 	mov	r6,r2
81111dd4:	01604574 	movhi	r5,33045
81111dd8:	297b8104 	addi	r5,r5,-4604
81111ddc:	1809883a 	mov	r4,r3
81111de0:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
81111de4:	d0e06217 	ldw	r3,-32376(gp)
81111de8:	e0bffe17 	ldw	r2,-8(fp)
81111dec:	10800d17 	ldw	r2,52(r2)
81111df0:	100d883a 	mov	r6,r2
81111df4:	01604574 	movhi	r5,33045
81111df8:	297b8a04 	addi	r5,r5,-4568
81111dfc:	1809883a 	mov	r4,r3
81111e00:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
81111e04:	d0e06217 	ldw	r3,-32376(gp)
81111e08:	e0bffe17 	ldw	r2,-8(fp)
81111e0c:	10800e17 	ldw	r2,56(r2)
81111e10:	100d883a 	mov	r6,r2
81111e14:	01604574 	movhi	r5,33045
81111e18:	297b9504 	addi	r5,r5,-4524
81111e1c:	1809883a 	mov	r4,r3
81111e20:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"\n");
81111e24:	d0a06217 	ldw	r2,-32376(gp)
81111e28:	100b883a 	mov	r5,r2
81111e2c:	01000284 	movi	r4,10
81111e30:	11233180 	call	81123318 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
81111e34:	d0e06217 	ldw	r3,-32376(gp)
81111e38:	e0bffe17 	ldw	r2,-8(fp)
81111e3c:	10800003 	ldbu	r2,0(r2)
81111e40:	10803fcc 	andi	r2,r2,255
81111e44:	100f883a 	mov	r7,r2
81111e48:	01800044 	movi	r6,1
81111e4c:	01604574 	movhi	r5,33045
81111e50:	297b7204 	addi	r5,r5,-4664
81111e54:	1809883a 	mov	r4,r3
81111e58:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        Left side \n");
81111e5c:	d0a06217 	ldw	r2,-32376(gp)
81111e60:	100f883a 	mov	r7,r2
81111e64:	018004c4 	movi	r6,19
81111e68:	01400044 	movi	r5,1
81111e6c:	01204574 	movhi	r4,33045
81111e70:	213b7c04 	addi	r4,r4,-4624
81111e74:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
81111e78:	d0e06217 	ldw	r3,-32376(gp)
81111e7c:	e0bffe17 	ldw	r2,-8(fp)
81111e80:	10800f17 	ldw	r2,60(r2)
81111e84:	100d883a 	mov	r6,r2
81111e88:	01604574 	movhi	r5,33045
81111e8c:	297b8104 	addi	r5,r5,-4604
81111e90:	1809883a 	mov	r4,r3
81111e94:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
81111e98:	d0e06217 	ldw	r3,-32376(gp)
81111e9c:	e0bffe17 	ldw	r2,-8(fp)
81111ea0:	10801017 	ldw	r2,64(r2)
81111ea4:	100d883a 	mov	r6,r2
81111ea8:	01604574 	movhi	r5,33045
81111eac:	297b8a04 	addi	r5,r5,-4568
81111eb0:	1809883a 	mov	r4,r3
81111eb4:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
81111eb8:	d0e06217 	ldw	r3,-32376(gp)
81111ebc:	e0bffe17 	ldw	r2,-8(fp)
81111ec0:	10801117 	ldw	r2,68(r2)
81111ec4:	100d883a 	mov	r6,r2
81111ec8:	01604574 	movhi	r5,33045
81111ecc:	297b9504 	addi	r5,r5,-4524
81111ed0:	1809883a 	mov	r4,r3
81111ed4:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        Right side \n");
81111ed8:	d0a06217 	ldw	r2,-32376(gp)
81111edc:	100f883a 	mov	r7,r2
81111ee0:	01800504 	movi	r6,20
81111ee4:	01400044 	movi	r5,1
81111ee8:	01204574 	movhi	r4,33045
81111eec:	213ba104 	addi	r4,r4,-4476
81111ef0:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
81111ef4:	d0e06217 	ldw	r3,-32376(gp)
81111ef8:	e0bffe17 	ldw	r2,-8(fp)
81111efc:	10801217 	ldw	r2,72(r2)
81111f00:	100d883a 	mov	r6,r2
81111f04:	01604574 	movhi	r5,33045
81111f08:	297b8104 	addi	r5,r5,-4604
81111f0c:	1809883a 	mov	r4,r3
81111f10:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
81111f14:	d0e06217 	ldw	r3,-32376(gp)
81111f18:	e0bffe17 	ldw	r2,-8(fp)
81111f1c:	10801317 	ldw	r2,76(r2)
81111f20:	100d883a 	mov	r6,r2
81111f24:	01604574 	movhi	r5,33045
81111f28:	297b8a04 	addi	r5,r5,-4568
81111f2c:	1809883a 	mov	r4,r3
81111f30:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
81111f34:	d0e06217 	ldw	r3,-32376(gp)
81111f38:	e0bffe17 	ldw	r2,-8(fp)
81111f3c:	10801417 	ldw	r2,80(r2)
81111f40:	100d883a 	mov	r6,r2
81111f44:	01604574 	movhi	r5,33045
81111f48:	297b9504 	addi	r5,r5,-4524
81111f4c:	1809883a 	mov	r4,r3
81111f50:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"\n");
81111f54:	d0a06217 	ldw	r2,-32376(gp)
81111f58:	100b883a 	mov	r5,r2
81111f5c:	01000284 	movi	r4,10
81111f60:	11233180 	call	81123318 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
81111f64:	d0e06217 	ldw	r3,-32376(gp)
81111f68:	e0bffe17 	ldw	r2,-8(fp)
81111f6c:	10800003 	ldbu	r2,0(r2)
81111f70:	10803fcc 	andi	r2,r2,255
81111f74:	100f883a 	mov	r7,r2
81111f78:	01800084 	movi	r6,2
81111f7c:	01604574 	movhi	r5,33045
81111f80:	297b7204 	addi	r5,r5,-4664
81111f84:	1809883a 	mov	r4,r3
81111f88:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        Left side \n");
81111f8c:	d0a06217 	ldw	r2,-32376(gp)
81111f90:	100f883a 	mov	r7,r2
81111f94:	018004c4 	movi	r6,19
81111f98:	01400044 	movi	r5,1
81111f9c:	01204574 	movhi	r4,33045
81111fa0:	213b7c04 	addi	r4,r4,-4624
81111fa4:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
81111fa8:	d0e06217 	ldw	r3,-32376(gp)
81111fac:	e0bffe17 	ldw	r2,-8(fp)
81111fb0:	10801517 	ldw	r2,84(r2)
81111fb4:	100d883a 	mov	r6,r2
81111fb8:	01604574 	movhi	r5,33045
81111fbc:	297b8104 	addi	r5,r5,-4604
81111fc0:	1809883a 	mov	r4,r3
81111fc4:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
81111fc8:	d0e06217 	ldw	r3,-32376(gp)
81111fcc:	e0bffe17 	ldw	r2,-8(fp)
81111fd0:	10801617 	ldw	r2,88(r2)
81111fd4:	100d883a 	mov	r6,r2
81111fd8:	01604574 	movhi	r5,33045
81111fdc:	297b8a04 	addi	r5,r5,-4568
81111fe0:	1809883a 	mov	r4,r3
81111fe4:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
81111fe8:	d0e06217 	ldw	r3,-32376(gp)
81111fec:	e0bffe17 	ldw	r2,-8(fp)
81111ff0:	10801717 	ldw	r2,92(r2)
81111ff4:	100d883a 	mov	r6,r2
81111ff8:	01604574 	movhi	r5,33045
81111ffc:	297b9504 	addi	r5,r5,-4524
81112000:	1809883a 	mov	r4,r3
81112004:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        Right side \n");
81112008:	d0a06217 	ldw	r2,-32376(gp)
8111200c:	100f883a 	mov	r7,r2
81112010:	01800504 	movi	r6,20
81112014:	01400044 	movi	r5,1
81112018:	01204574 	movhi	r4,33045
8111201c:	213ba104 	addi	r4,r4,-4476
81112020:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
81112024:	d0e06217 	ldw	r3,-32376(gp)
81112028:	e0bffe17 	ldw	r2,-8(fp)
8111202c:	10801817 	ldw	r2,96(r2)
81112030:	100d883a 	mov	r6,r2
81112034:	01604574 	movhi	r5,33045
81112038:	297b8104 	addi	r5,r5,-4604
8111203c:	1809883a 	mov	r4,r3
81112040:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
81112044:	d0e06217 	ldw	r3,-32376(gp)
81112048:	e0bffe17 	ldw	r2,-8(fp)
8111204c:	10801917 	ldw	r2,100(r2)
81112050:	100d883a 	mov	r6,r2
81112054:	01604574 	movhi	r5,33045
81112058:	297b8a04 	addi	r5,r5,-4568
8111205c:	1809883a 	mov	r4,r3
81112060:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
81112064:	d0e06217 	ldw	r3,-32376(gp)
81112068:	e0bffe17 	ldw	r2,-8(fp)
8111206c:	10801a17 	ldw	r2,104(r2)
81112070:	100d883a 	mov	r6,r2
81112074:	01604574 	movhi	r5,33045
81112078:	297b9504 	addi	r5,r5,-4524
8111207c:	1809883a 	mov	r4,r3
81112080:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"\n");
81112084:	d0a06217 	ldw	r2,-32376(gp)
81112088:	100b883a 	mov	r5,r2
8111208c:	01000284 	movi	r4,10
81112090:	11233180 	call	81123318 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
81112094:	d0e06217 	ldw	r3,-32376(gp)
81112098:	e0bffe17 	ldw	r2,-8(fp)
8111209c:	10800003 	ldbu	r2,0(r2)
811120a0:	10803fcc 	andi	r2,r2,255
811120a4:	100f883a 	mov	r7,r2
811120a8:	018000c4 	movi	r6,3
811120ac:	01604574 	movhi	r5,33045
811120b0:	297b7204 	addi	r5,r5,-4664
811120b4:	1809883a 	mov	r4,r3
811120b8:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        Left side \n");
811120bc:	d0a06217 	ldw	r2,-32376(gp)
811120c0:	100f883a 	mov	r7,r2
811120c4:	018004c4 	movi	r6,19
811120c8:	01400044 	movi	r5,1
811120cc:	01204574 	movhi	r4,33045
811120d0:	213b7c04 	addi	r4,r4,-4624
811120d4:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
811120d8:	d0e06217 	ldw	r3,-32376(gp)
811120dc:	e0bffe17 	ldw	r2,-8(fp)
811120e0:	10801b17 	ldw	r2,108(r2)
811120e4:	100d883a 	mov	r6,r2
811120e8:	01604574 	movhi	r5,33045
811120ec:	297b8104 	addi	r5,r5,-4604
811120f0:	1809883a 	mov	r4,r3
811120f4:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
811120f8:	d0e06217 	ldw	r3,-32376(gp)
811120fc:	e0bffe17 	ldw	r2,-8(fp)
81112100:	10801c17 	ldw	r2,112(r2)
81112104:	100d883a 	mov	r6,r2
81112108:	01604574 	movhi	r5,33045
8111210c:	297b8a04 	addi	r5,r5,-4568
81112110:	1809883a 	mov	r4,r3
81112114:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
81112118:	d0e06217 	ldw	r3,-32376(gp)
8111211c:	e0bffe17 	ldw	r2,-8(fp)
81112120:	10801d17 	ldw	r2,116(r2)
81112124:	100d883a 	mov	r6,r2
81112128:	01604574 	movhi	r5,33045
8111212c:	297b9504 	addi	r5,r5,-4524
81112130:	1809883a 	mov	r4,r3
81112134:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"        Right side \n");
81112138:	d0a06217 	ldw	r2,-32376(gp)
8111213c:	100f883a 	mov	r7,r2
81112140:	01800504 	movi	r6,20
81112144:	01400044 	movi	r5,1
81112148:	01204574 	movhi	r4,33045
8111214c:	213ba104 	addi	r4,r4,-4476
81112150:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
81112154:	d0e06217 	ldw	r3,-32376(gp)
81112158:	e0bffe17 	ldw	r2,-8(fp)
8111215c:	10801e17 	ldw	r2,120(r2)
81112160:	100d883a 	mov	r6,r2
81112164:	01604574 	movhi	r5,33045
81112168:	297b8104 	addi	r5,r5,-4604
8111216c:	1809883a 	mov	r4,r3
81112170:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
81112174:	d0e06217 	ldw	r3,-32376(gp)
81112178:	e0bffe17 	ldw	r2,-8(fp)
8111217c:	10801f17 	ldw	r2,124(r2)
81112180:	100d883a 	mov	r6,r2
81112184:	01604574 	movhi	r5,33045
81112188:	297b8a04 	addi	r5,r5,-4568
8111218c:	1809883a 	mov	r4,r3
81112190:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
81112194:	d0e06217 	ldw	r3,-32376(gp)
81112198:	e0bffe17 	ldw	r2,-8(fp)
8111219c:	10802017 	ldw	r2,128(r2)
811121a0:	100d883a 	mov	r6,r2
811121a4:	01604574 	movhi	r5,33045
811121a8:	297b9504 	addi	r5,r5,-4524
811121ac:	1809883a 	mov	r4,r3
811121b0:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"\n");
811121b4:	d0a06217 	ldw	r2,-32376(gp)
811121b8:	100b883a 	mov	r5,r2
811121bc:	01000284 	movi	r4,10
811121c0:	11233180 	call	81123318 <fputc>
		fprintf(fp,"==============================================================================\n");
811121c4:	d0a06217 	ldw	r2,-32376(gp)
811121c8:	100f883a 	mov	r7,r2
811121cc:	018013c4 	movi	r6,79
811121d0:	01400044 	movi	r5,1
811121d4:	01204574 	movhi	r4,33045
811121d8:	213ba704 	addi	r4,r4,-4452
811121dc:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"==============================================================================\n");
811121e0:	d0a06217 	ldw	r2,-32376(gp)
811121e4:	100f883a 	mov	r7,r2
811121e8:	018013c4 	movi	r6,79
811121ec:	01400044 	movi	r5,1
811121f0:	01204574 	movhi	r4,33045
811121f4:	213ba704 	addi	r4,r4,-4452
811121f8:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"\n");
811121fc:	d0a06217 	ldw	r2,-32376(gp)
81112200:	100b883a 	mov	r5,r2
81112204:	01000284 	movi	r4,10
81112208:	11233180 	call	81123318 <fputc>
		fprintf(fp,"\n");
8111220c:	d0a06217 	ldw	r2,-32376(gp)
81112210:	100b883a 	mov	r5,r2
81112214:	01000284 	movi	r4,10
81112218:	11233180 	call	81123318 <fputc>
		fprintf(fp,"\n");
8111221c:	d0a06217 	ldw	r2,-32376(gp)
81112220:	100b883a 	mov	r5,r2
81112224:	01000284 	movi	r4,10
81112228:	11233180 	call	81123318 <fputc>
		fprintf(fp,"\n");
8111222c:	d0a06217 	ldw	r2,-32376(gp)
81112230:	100b883a 	mov	r5,r2
81112234:	01000284 	movi	r4,10
81112238:	11233180 	call	81123318 <fputc>
		fprintf(fp,"\n");
8111223c:	d0a06217 	ldw	r2,-32376(gp)
81112240:	100b883a 	mov	r5,r2
81112244:	01000284 	movi	r4,10
81112248:	11233180 	call	81123318 <fputc>
	}
8111224c:	0001883a 	nop
81112250:	e037883a 	mov	sp,fp
81112254:	dfc00117 	ldw	ra,4(sp)
81112258:	df000017 	ldw	fp,0(sp)
8111225c:	dec00204 	addi	sp,sp,8
81112260:	f800283a 	ret

81112264 <bPrepareDoubleBuffer>:
#endif


bool bPrepareDoubleBuffer( TCcdMemMap *xCcdMapLocal, unsigned char ucMem, unsigned char ucID, TNFee *pxNFee ) {
81112264:	defff804 	addi	sp,sp,-32
81112268:	de00012e 	bgeu	sp,et,81112270 <bPrepareDoubleBuffer+0xc>
8111226c:	003b68fa 	trap	3
81112270:	dfc00715 	stw	ra,28(sp)
81112274:	df000615 	stw	fp,24(sp)
81112278:	df000604 	addi	fp,sp,24
8111227c:	e13ffc15 	stw	r4,-16(fp)
81112280:	2807883a 	mov	r3,r5
81112284:	3005883a 	mov	r2,r6
81112288:	e1ffff15 	stw	r7,-4(fp)
8111228c:	e0fffd05 	stb	r3,-12(fp)
81112290:	e0bffe05 	stb	r2,-8(fp)
	bool  bDmaReturn;
	unsigned long ulLengthBlocks;

	bDmaReturn = FALSE;
81112294:	e03ffa15 	stw	zero,-24(fp)
	xCcdMapLocal->ulBlockI = 0;
81112298:	e0bffc17 	ldw	r2,-16(fp)
8111229c:	10000115 	stw	zero,4(r2)
	xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
811122a0:	e0bffc17 	ldw	r2,-16(fp)
811122a4:	10c00017 	ldw	r3,0(r2)
811122a8:	e0bffc17 	ldw	r2,-16(fp)
811122ac:	10c00215 	stw	r3,8(r2)


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
811122b0:	e0bffc17 	ldw	r2,-16(fp)
811122b4:	10800117 	ldw	r2,4(r2)
811122b8:	10c00404 	addi	r3,r2,16
811122bc:	e0bfff17 	ldw	r2,-4(fp)
811122c0:	10800417 	ldw	r2,16(r2)
811122c4:	18800736 	bltu	r3,r2,811122e4 <bPrepareDoubleBuffer+0x80>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
811122c8:	e0bfff17 	ldw	r2,-4(fp)
811122cc:	10c00417 	ldw	r3,16(r2)
811122d0:	e0bffc17 	ldw	r2,-16(fp)
811122d4:	10800117 	ldw	r2,4(r2)
811122d8:	1885c83a 	sub	r2,r3,r2
811122dc:	e0bffb15 	stw	r2,-20(fp)
811122e0:	00000206 	br	811122ec <bPrepareDoubleBuffer+0x88>
	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
811122e4:	00800404 	movi	r2,16
811122e8:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
811122ec:	00a045f4 	movhi	r2,33047
811122f0:	10a25304 	addi	r2,r2,-30388
811122f4:	10800a0b 	ldhu	r2,40(r2)
811122f8:	10bfffcc 	andi	r2,r2,65535
811122fc:	10000b1e 	bne	r2,zero,8111232c <bPrepareDoubleBuffer+0xc8>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
81112300:	e0bffb17 	ldw	r2,-20(fp)
81112304:	10803fcc 	andi	r2,r2,255
81112308:	000b883a 	mov	r5,zero
8111230c:	1009883a 	mov	r4,r2
81112310:	1105a100 	call	81105a10 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
81112314:	e0bffb17 	ldw	r2,-20(fp)
81112318:	10803fcc 	andi	r2,r2,255
8111231c:	01400044 	movi	r5,1
81112320:	1009883a 	mov	r4,r2
81112324:	1105a100 	call	81105a10 <bFeebCh1SetBufferSize>
81112328:	00000a06 	br	81112354 <bPrepareDoubleBuffer+0xf0>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
8111232c:	e0bffb17 	ldw	r2,-20(fp)
81112330:	10803fcc 	andi	r2,r2,255
81112334:	000b883a 	mov	r5,zero
81112338:	1009883a 	mov	r4,r2
8111233c:	1105af00 	call	81105af0 <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
81112340:	e0bffb17 	ldw	r2,-20(fp)
81112344:	10803fcc 	andi	r2,r2,255
81112348:	01400044 	movi	r5,1
8111234c:	1009883a 	mov	r4,r2
81112350:	1105af00 	call	81105af0 <bFeebCh2SetBufferSize>
	}

	if (  ucMem == 0  ) {
81112354:	e0bffd03 	ldbu	r2,-12(fp)
81112358:	1000231e 	bne	r2,zero,811123e8 <bPrepareDoubleBuffer+0x184>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8111235c:	e0bffc17 	ldw	r2,-16(fp)
81112360:	10800217 	ldw	r2,8(r2)
81112364:	1011883a 	mov	r8,r2
81112368:	e0bffb17 	ldw	r2,-20(fp)
8111236c:	10ffffcc 	andi	r3,r2,65535
81112370:	d0a05603 	ldbu	r2,-32424(gp)
81112374:	11003fcc 	andi	r4,r2,255
81112378:	e0bfff17 	ldw	r2,-4(fp)
8111237c:	10800043 	ldbu	r2,1(r2)
81112380:	10803fcc 	andi	r2,r2,255
81112384:	100f883a 	mov	r7,r2
81112388:	200d883a 	mov	r6,r4
8111238c:	180b883a 	mov	r5,r3
81112390:	4009883a 	mov	r4,r8
81112394:	1103d040 	call	81103d04 <bSdmaDmaM1Transfer>
81112398:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
8111239c:	e0bffa17 	ldw	r2,-24(fp)
811123a0:	10800058 	cmpnei	r2,r2,1
811123a4:	10000e1e 	bne	r2,zero,811123e0 <bPrepareDoubleBuffer+0x17c>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
811123a8:	e0bffc17 	ldw	r2,-16(fp)
811123ac:	10c00217 	ldw	r3,8(r2)
811123b0:	e0bffb17 	ldw	r2,-20(fp)
811123b4:	10802224 	muli	r2,r2,136
811123b8:	1887883a 	add	r3,r3,r2
811123bc:	e0bffc17 	ldw	r2,-16(fp)
811123c0:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
811123c4:	e0bffc17 	ldw	r2,-16(fp)
811123c8:	10c00117 	ldw	r3,4(r2)
811123cc:	e0bffb17 	ldw	r2,-20(fp)
811123d0:	1887883a 	add	r3,r3,r2
811123d4:	e0bffc17 	ldw	r2,-16(fp)
811123d8:	10c00115 	stw	r3,4(r2)
811123dc:	00002506 	br	81112474 <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
811123e0:	e0bffa17 	ldw	r2,-24(fp)
811123e4:	00009506 	br	8111263c <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
811123e8:	e0bffc17 	ldw	r2,-16(fp)
811123ec:	10800217 	ldw	r2,8(r2)
811123f0:	1011883a 	mov	r8,r2
811123f4:	e0bffb17 	ldw	r2,-20(fp)
811123f8:	10ffffcc 	andi	r3,r2,65535
811123fc:	d0a05603 	ldbu	r2,-32424(gp)
81112400:	11003fcc 	andi	r4,r2,255
81112404:	e0bfff17 	ldw	r2,-4(fp)
81112408:	10800043 	ldbu	r2,1(r2)
8111240c:	10803fcc 	andi	r2,r2,255
81112410:	100f883a 	mov	r7,r2
81112414:	200d883a 	mov	r6,r4
81112418:	180b883a 	mov	r5,r3
8111241c:	4009883a 	mov	r4,r8
81112420:	11041580 	call	81104158 <bSdmaDmaM2Transfer>
81112424:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81112428:	e0bffa17 	ldw	r2,-24(fp)
8111242c:	10800058 	cmpnei	r2,r2,1
81112430:	10000e1e 	bne	r2,zero,8111246c <bPrepareDoubleBuffer+0x208>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81112434:	e0bffc17 	ldw	r2,-16(fp)
81112438:	10c00217 	ldw	r3,8(r2)
8111243c:	e0bffb17 	ldw	r2,-20(fp)
81112440:	10802224 	muli	r2,r2,136
81112444:	1887883a 	add	r3,r3,r2
81112448:	e0bffc17 	ldw	r2,-16(fp)
8111244c:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81112450:	e0bffc17 	ldw	r2,-16(fp)
81112454:	10c00117 	ldw	r3,4(r2)
81112458:	e0bffb17 	ldw	r2,-20(fp)
8111245c:	1887883a 	add	r3,r3,r2
81112460:	e0bffc17 	ldw	r2,-16(fp)
81112464:	10c00115 	stw	r3,4(r2)
81112468:	00000206 	br	81112474 <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
8111246c:	e0bffa17 	ldw	r2,-24(fp)
81112470:	00007206 	br	8111263c <bPrepareDoubleBuffer+0x3d8>
	}


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
81112474:	e0bffc17 	ldw	r2,-16(fp)
81112478:	10800117 	ldw	r2,4(r2)
8111247c:	10c00404 	addi	r3,r2,16
81112480:	e0bfff17 	ldw	r2,-4(fp)
81112484:	10800417 	ldw	r2,16(r2)
81112488:	18800736 	bltu	r3,r2,811124a8 <bPrepareDoubleBuffer+0x244>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8111248c:	e0bfff17 	ldw	r2,-4(fp)
81112490:	10c00417 	ldw	r3,16(r2)
81112494:	e0bffc17 	ldw	r2,-16(fp)
81112498:	10800117 	ldw	r2,4(r2)
8111249c:	1885c83a 	sub	r2,r3,r2
811124a0:	e0bffb15 	stw	r2,-20(fp)
811124a4:	00000206 	br	811124b0 <bPrepareDoubleBuffer+0x24c>
	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
811124a8:	00800404 	movi	r2,16
811124ac:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
811124b0:	00a045f4 	movhi	r2,33047
811124b4:	10a25304 	addi	r2,r2,-30388
811124b8:	10800a0b 	ldhu	r2,40(r2)
811124bc:	10bfffcc 	andi	r2,r2,65535
811124c0:	10000b1e 	bne	r2,zero,811124f0 <bPrepareDoubleBuffer+0x28c>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
811124c4:	e0bffb17 	ldw	r2,-20(fp)
811124c8:	10803fcc 	andi	r2,r2,255
811124cc:	000b883a 	mov	r5,zero
811124d0:	1009883a 	mov	r4,r2
811124d4:	1105a100 	call	81105a10 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
811124d8:	e0bffb17 	ldw	r2,-20(fp)
811124dc:	10803fcc 	andi	r2,r2,255
811124e0:	01400044 	movi	r5,1
811124e4:	1009883a 	mov	r4,r2
811124e8:	1105a100 	call	81105a10 <bFeebCh1SetBufferSize>
811124ec:	00000a06 	br	81112518 <bPrepareDoubleBuffer+0x2b4>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
811124f0:	e0bffb17 	ldw	r2,-20(fp)
811124f4:	10803fcc 	andi	r2,r2,255
811124f8:	000b883a 	mov	r5,zero
811124fc:	1009883a 	mov	r4,r2
81112500:	1105af00 	call	81105af0 <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
81112504:	e0bffb17 	ldw	r2,-20(fp)
81112508:	10803fcc 	andi	r2,r2,255
8111250c:	01400044 	movi	r5,1
81112510:	1009883a 	mov	r4,r2
81112514:	1105af00 	call	81105af0 <bFeebCh2SetBufferSize>
	}

	if (  ucMem == 0  ) {
81112518:	e0bffd03 	ldbu	r2,-12(fp)
8111251c:	1000231e 	bne	r2,zero,811125ac <bPrepareDoubleBuffer+0x348>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81112520:	e0bffc17 	ldw	r2,-16(fp)
81112524:	10800217 	ldw	r2,8(r2)
81112528:	1011883a 	mov	r8,r2
8111252c:	e0bffb17 	ldw	r2,-20(fp)
81112530:	10ffffcc 	andi	r3,r2,65535
81112534:	d0a05603 	ldbu	r2,-32424(gp)
81112538:	11003fcc 	andi	r4,r2,255
8111253c:	e0bfff17 	ldw	r2,-4(fp)
81112540:	10800043 	ldbu	r2,1(r2)
81112544:	10803fcc 	andi	r2,r2,255
81112548:	100f883a 	mov	r7,r2
8111254c:	200d883a 	mov	r6,r4
81112550:	180b883a 	mov	r5,r3
81112554:	4009883a 	mov	r4,r8
81112558:	1103d040 	call	81103d04 <bSdmaDmaM1Transfer>
8111255c:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81112560:	e0bffa17 	ldw	r2,-24(fp)
81112564:	10800058 	cmpnei	r2,r2,1
81112568:	10000e1e 	bne	r2,zero,811125a4 <bPrepareDoubleBuffer+0x340>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
8111256c:	e0bffc17 	ldw	r2,-16(fp)
81112570:	10c00217 	ldw	r3,8(r2)
81112574:	e0bffb17 	ldw	r2,-20(fp)
81112578:	10802224 	muli	r2,r2,136
8111257c:	1887883a 	add	r3,r3,r2
81112580:	e0bffc17 	ldw	r2,-16(fp)
81112584:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81112588:	e0bffc17 	ldw	r2,-16(fp)
8111258c:	10c00117 	ldw	r3,4(r2)
81112590:	e0bffb17 	ldw	r2,-20(fp)
81112594:	1887883a 	add	r3,r3,r2
81112598:	e0bffc17 	ldw	r2,-16(fp)
8111259c:	10c00115 	stw	r3,4(r2)
811125a0:	00002506 	br	81112638 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
811125a4:	e0bffa17 	ldw	r2,-24(fp)
811125a8:	00002406 	br	8111263c <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
811125ac:	e0bffc17 	ldw	r2,-16(fp)
811125b0:	10800217 	ldw	r2,8(r2)
811125b4:	1011883a 	mov	r8,r2
811125b8:	e0bffb17 	ldw	r2,-20(fp)
811125bc:	10ffffcc 	andi	r3,r2,65535
811125c0:	d0a05603 	ldbu	r2,-32424(gp)
811125c4:	11003fcc 	andi	r4,r2,255
811125c8:	e0bfff17 	ldw	r2,-4(fp)
811125cc:	10800043 	ldbu	r2,1(r2)
811125d0:	10803fcc 	andi	r2,r2,255
811125d4:	100f883a 	mov	r7,r2
811125d8:	200d883a 	mov	r6,r4
811125dc:	180b883a 	mov	r5,r3
811125e0:	4009883a 	mov	r4,r8
811125e4:	11041580 	call	81104158 <bSdmaDmaM2Transfer>
811125e8:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
811125ec:	e0bffa17 	ldw	r2,-24(fp)
811125f0:	10800058 	cmpnei	r2,r2,1
811125f4:	10000e1e 	bne	r2,zero,81112630 <bPrepareDoubleBuffer+0x3cc>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
811125f8:	e0bffc17 	ldw	r2,-16(fp)
811125fc:	10c00217 	ldw	r3,8(r2)
81112600:	e0bffb17 	ldw	r2,-20(fp)
81112604:	10802224 	muli	r2,r2,136
81112608:	1887883a 	add	r3,r3,r2
8111260c:	e0bffc17 	ldw	r2,-16(fp)
81112610:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81112614:	e0bffc17 	ldw	r2,-16(fp)
81112618:	10c00117 	ldw	r3,4(r2)
8111261c:	e0bffb17 	ldw	r2,-20(fp)
81112620:	1887883a 	add	r3,r3,r2
81112624:	e0bffc17 	ldw	r2,-16(fp)
81112628:	10c00115 	stw	r3,4(r2)
8111262c:	00000206 	br	81112638 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
81112630:	e0bffa17 	ldw	r2,-24(fp)
81112634:	00000106 	br	8111263c <bPrepareDoubleBuffer+0x3d8>
	}

	return bDmaReturn;
81112638:	e0bffa17 	ldw	r2,-24(fp)

}
8111263c:	e037883a 	mov	sp,fp
81112640:	dfc00117 	ldw	ra,4(sp)
81112644:	df000017 	ldw	fp,0(sp)
81112648:	dec00204 	addi	sp,sp,8
8111264c:	f800283a 	ret

81112650 <vLoadCtemp>:


void vLoadCtemp(void) {
81112650:	deffff04 	addi	sp,sp,-4
81112654:	de00012e 	bgeu	sp,et,8111265c <vLoadCtemp+0xc>
81112658:	003b68fa 	trap	3
8111265c:	df000015 	stw	fp,0(sp)
81112660:	d839883a 	mov	fp,sp
	cTemp[0]="usiHkCcd1VodE";
81112664:	00a04574 	movhi	r2,33045
81112668:	1095f304 	addi	r2,r2,22476
8111266c:	00e04574 	movhi	r3,33045
81112670:	18fbbb04 	addi	r3,r3,-4372
81112674:	10c00015 	stw	r3,0(r2)
	cTemp[1]="usiHkCcd1VodF";
81112678:	00a04574 	movhi	r2,33045
8111267c:	1095f304 	addi	r2,r2,22476
81112680:	00e04574 	movhi	r3,33045
81112684:	18fbbf04 	addi	r3,r3,-4356
81112688:	10c00115 	stw	r3,4(r2)
	cTemp[2]="usiHkCcd1VrdMon";
8111268c:	00a04574 	movhi	r2,33045
81112690:	1095f304 	addi	r2,r2,22476
81112694:	00e04574 	movhi	r3,33045
81112698:	18fbc304 	addi	r3,r3,-4340
8111269c:	10c00215 	stw	r3,8(r2)
	cTemp[3]="usiHkCcd2VodE";
811126a0:	00a04574 	movhi	r2,33045
811126a4:	1095f304 	addi	r2,r2,22476
811126a8:	00e04574 	movhi	r3,33045
811126ac:	18fbc704 	addi	r3,r3,-4324
811126b0:	10c00315 	stw	r3,12(r2)
	cTemp[4]="usiHkCcd2VodF";
811126b4:	00a04574 	movhi	r2,33045
811126b8:	1095f304 	addi	r2,r2,22476
811126bc:	00e04574 	movhi	r3,33045
811126c0:	18fbcb04 	addi	r3,r3,-4308
811126c4:	10c00415 	stw	r3,16(r2)
	cTemp[5]="usiHkCcd2VrdMon";
811126c8:	00a04574 	movhi	r2,33045
811126cc:	1095f304 	addi	r2,r2,22476
811126d0:	00e04574 	movhi	r3,33045
811126d4:	18fbcf04 	addi	r3,r3,-4292
811126d8:	10c00515 	stw	r3,20(r2)
	cTemp[6]="usiHkCcd3VodE";
811126dc:	00a04574 	movhi	r2,33045
811126e0:	1095f304 	addi	r2,r2,22476
811126e4:	00e04574 	movhi	r3,33045
811126e8:	18fbd304 	addi	r3,r3,-4276
811126ec:	10c00615 	stw	r3,24(r2)
	cTemp[7]="usiHkCcd3VodF";
811126f0:	00a04574 	movhi	r2,33045
811126f4:	1095f304 	addi	r2,r2,22476
811126f8:	00e04574 	movhi	r3,33045
811126fc:	18fbd704 	addi	r3,r3,-4260
81112700:	10c00715 	stw	r3,28(r2)
	cTemp[8]="usiHkCcd3VrdMon";
81112704:	00a04574 	movhi	r2,33045
81112708:	1095f304 	addi	r2,r2,22476
8111270c:	00e04574 	movhi	r3,33045
81112710:	18fbdb04 	addi	r3,r3,-4244
81112714:	10c00815 	stw	r3,32(r2)
	cTemp[9]="usiHkCcd4VodE";
81112718:	00a04574 	movhi	r2,33045
8111271c:	1095f304 	addi	r2,r2,22476
81112720:	00e04574 	movhi	r3,33045
81112724:	18fbdf04 	addi	r3,r3,-4228
81112728:	10c00915 	stw	r3,36(r2)
	cTemp[10]="usiHkCcd4VodF";
8111272c:	00a04574 	movhi	r2,33045
81112730:	1095f304 	addi	r2,r2,22476
81112734:	00e04574 	movhi	r3,33045
81112738:	18fbe304 	addi	r3,r3,-4212
8111273c:	10c00a15 	stw	r3,40(r2)
	cTemp[11]="usiHkCcd4VrdMon";
81112740:	00a04574 	movhi	r2,33045
81112744:	1095f304 	addi	r2,r2,22476
81112748:	00e04574 	movhi	r3,33045
8111274c:	18fbe704 	addi	r3,r3,-4196
81112750:	10c00b15 	stw	r3,44(r2)
	cTemp[12]="usiHkVccd";
81112754:	00a04574 	movhi	r2,33045
81112758:	1095f304 	addi	r2,r2,22476
8111275c:	00e04574 	movhi	r3,33045
81112760:	18fbeb04 	addi	r3,r3,-4180
81112764:	10c00c15 	stw	r3,48(r2)
	cTemp[13]="usiHkVrclk";
81112768:	00a04574 	movhi	r2,33045
8111276c:	1095f304 	addi	r2,r2,22476
81112770:	00e04574 	movhi	r3,33045
81112774:	18fbee04 	addi	r3,r3,-4168
81112778:	10c00d15 	stw	r3,52(r2)
	cTemp[14]="usiHkViclk";
8111277c:	00a04574 	movhi	r2,33045
81112780:	1095f304 	addi	r2,r2,22476
81112784:	00e04574 	movhi	r3,33045
81112788:	18fbf104 	addi	r3,r3,-4156
8111278c:	10c00e15 	stw	r3,56(r2)
	cTemp[15]="usiHkVrclkLow";
81112790:	00a04574 	movhi	r2,33045
81112794:	1095f304 	addi	r2,r2,22476
81112798:	00e04574 	movhi	r3,33045
8111279c:	18fbf404 	addi	r3,r3,-4144
811127a0:	10c00f15 	stw	r3,60(r2)
	cTemp[16]="usiHk5vbPos";
811127a4:	00a04574 	movhi	r2,33045
811127a8:	1095f304 	addi	r2,r2,22476
811127ac:	00e04574 	movhi	r3,33045
811127b0:	18fbf804 	addi	r3,r3,-4128
811127b4:	10c01015 	stw	r3,64(r2)
	cTemp[17]="usiHk5vbNeg";
811127b8:	00a04574 	movhi	r2,33045
811127bc:	1095f304 	addi	r2,r2,22476
811127c0:	00e04574 	movhi	r3,33045
811127c4:	18fbfb04 	addi	r3,r3,-4116
811127c8:	10c01115 	stw	r3,68(r2)
	cTemp[18]="usiHk33vbPos";
811127cc:	00a04574 	movhi	r2,33045
811127d0:	1095f304 	addi	r2,r2,22476
811127d4:	00e04574 	movhi	r3,33045
811127d8:	18fbfe04 	addi	r3,r3,-4104
811127dc:	10c01215 	stw	r3,72(r2)
	cTemp[19]="usiHk25vaPos";
811127e0:	00a04574 	movhi	r2,33045
811127e4:	1095f304 	addi	r2,r2,22476
811127e8:	00e04574 	movhi	r3,33045
811127ec:	18fc0204 	addi	r3,r3,-4088
811127f0:	10c01315 	stw	r3,76(r2)
	cTemp[20]="usiHk33vdPos";
811127f4:	00a04574 	movhi	r2,33045
811127f8:	1095f304 	addi	r2,r2,22476
811127fc:	00e04574 	movhi	r3,33045
81112800:	18fc0604 	addi	r3,r3,-4072
81112804:	10c01415 	stw	r3,80(r2)
	cTemp[21]="usiHk25vdPos";
81112808:	00a04574 	movhi	r2,33045
8111280c:	1095f304 	addi	r2,r2,22476
81112810:	00e04574 	movhi	r3,33045
81112814:	18fc0a04 	addi	r3,r3,-4056
81112818:	10c01515 	stw	r3,84(r2)
	cTemp[22]="usiHk15vdPos";
8111281c:	00a04574 	movhi	r2,33045
81112820:	1095f304 	addi	r2,r2,22476
81112824:	00e04574 	movhi	r3,33045
81112828:	18fc0e04 	addi	r3,r3,-4040
8111282c:	10c01615 	stw	r3,88(r2)
	cTemp[23]="usiHk5vref";
81112830:	00a04574 	movhi	r2,33045
81112834:	1095f304 	addi	r2,r2,22476
81112838:	00e04574 	movhi	r3,33045
8111283c:	18fc1204 	addi	r3,r3,-4024
81112840:	10c01715 	stw	r3,92(r2)
	cTemp[24]="usiHkVccdPosRaw";
81112844:	00a04574 	movhi	r2,33045
81112848:	1095f304 	addi	r2,r2,22476
8111284c:	00e04574 	movhi	r3,33045
81112850:	18fc1504 	addi	r3,r3,-4012
81112854:	10c01815 	stw	r3,96(r2)
	cTemp[25]="usiHkVclkPosRaw";
81112858:	00a04574 	movhi	r2,33045
8111285c:	1095f304 	addi	r2,r2,22476
81112860:	00e04574 	movhi	r3,33045
81112864:	18fc1904 	addi	r3,r3,-3996
81112868:	10c01915 	stw	r3,100(r2)
	cTemp[26]="usiHkVan1PosRaw";
8111286c:	00a04574 	movhi	r2,33045
81112870:	1095f304 	addi	r2,r2,22476
81112874:	00e04574 	movhi	r3,33045
81112878:	18fc1d04 	addi	r3,r3,-3980
8111287c:	10c01a15 	stw	r3,104(r2)
	cTemp[27]="usiHkVan3NegRaw";
81112880:	00a04574 	movhi	r2,33045
81112884:	1095f304 	addi	r2,r2,22476
81112888:	00e04574 	movhi	r3,33045
8111288c:	18fc2104 	addi	r3,r3,-3964
81112890:	10c01b15 	stw	r3,108(r2)
	cTemp[28]="usiHkVan2PosRaw";
81112894:	00a04574 	movhi	r2,33045
81112898:	1095f304 	addi	r2,r2,22476
8111289c:	00e04574 	movhi	r3,33045
811128a0:	18fc2504 	addi	r3,r3,-3948
811128a4:	10c01c15 	stw	r3,112(r2)
	cTemp[29]="usiHkVdigFpgaRaw";
811128a8:	00a04574 	movhi	r2,33045
811128ac:	1095f304 	addi	r2,r2,22476
811128b0:	00e04574 	movhi	r3,33045
811128b4:	18fc2904 	addi	r3,r3,-3932
811128b8:	10c01d15 	stw	r3,116(r2)
	cTemp[30]="usiHkVdigSpwRaw";
811128bc:	00a04574 	movhi	r2,33045
811128c0:	1095f304 	addi	r2,r2,22476
811128c4:	00e04574 	movhi	r3,33045
811128c8:	18fc2e04 	addi	r3,r3,-3912
811128cc:	10c01e15 	stw	r3,120(r2)
	cTemp[31]="usiHkViclkLow";
811128d0:	00a04574 	movhi	r2,33045
811128d4:	1095f304 	addi	r2,r2,22476
811128d8:	00e04574 	movhi	r3,33045
811128dc:	18fc3204 	addi	r3,r3,-3896
811128e0:	10c01f15 	stw	r3,124(r2)
	cTemp[32]="usiHkAdcTempAE";
811128e4:	00a04574 	movhi	r2,33045
811128e8:	1095f304 	addi	r2,r2,22476
811128ec:	00e04574 	movhi	r3,33045
811128f0:	18fc3604 	addi	r3,r3,-3880
811128f4:	10c02015 	stw	r3,128(r2)
	cTemp[33]="usiHkAdcTempAF";
811128f8:	00a04574 	movhi	r2,33045
811128fc:	1095f304 	addi	r2,r2,22476
81112900:	00e04574 	movhi	r3,33045
81112904:	18fc3a04 	addi	r3,r3,-3864
81112908:	10c02115 	stw	r3,132(r2)
	cTemp[34]="usiHkCcd1Temp";
8111290c:	00a04574 	movhi	r2,33045
81112910:	1095f304 	addi	r2,r2,22476
81112914:	00e04574 	movhi	r3,33045
81112918:	18fc3e04 	addi	r3,r3,-3848
8111291c:	10c02215 	stw	r3,136(r2)
	cTemp[35]="usiHkCcd2Temp";
81112920:	00a04574 	movhi	r2,33045
81112924:	1095f304 	addi	r2,r2,22476
81112928:	00e04574 	movhi	r3,33045
8111292c:	18fc4204 	addi	r3,r3,-3832
81112930:	10c02315 	stw	r3,140(r2)
	cTemp[36]="usiHkCcd3Temp";
81112934:	00a04574 	movhi	r2,33045
81112938:	1095f304 	addi	r2,r2,22476
8111293c:	00e04574 	movhi	r3,33045
81112940:	18fc4604 	addi	r3,r3,-3816
81112944:	10c02415 	stw	r3,144(r2)
	cTemp[37]="usiHkCcd4Temp";
81112948:	00a04574 	movhi	r2,33045
8111294c:	1095f304 	addi	r2,r2,22476
81112950:	00e04574 	movhi	r3,33045
81112954:	18fc4a04 	addi	r3,r3,-3800
81112958:	10c02515 	stw	r3,148(r2)
	cTemp[38]="usiHkWp605Spare";
8111295c:	00a04574 	movhi	r2,33045
81112960:	1095f304 	addi	r2,r2,22476
81112964:	00e04574 	movhi	r3,33045
81112968:	18fc4e04 	addi	r3,r3,-3784
8111296c:	10c02615 	stw	r3,152(r2)
	cTemp[39]="usiLowresPrtA0";
81112970:	00a04574 	movhi	r2,33045
81112974:	1095f304 	addi	r2,r2,22476
81112978:	00e04574 	movhi	r3,33045
8111297c:	18fc5204 	addi	r3,r3,-3768
81112980:	10c02715 	stw	r3,156(r2)
	cTemp[40]="usiLowresPrtA1";
81112984:	00a04574 	movhi	r2,33045
81112988:	1095f304 	addi	r2,r2,22476
8111298c:	00e04574 	movhi	r3,33045
81112990:	18fc5604 	addi	r3,r3,-3752
81112994:	10c02815 	stw	r3,160(r2)
	cTemp[41]="usiLowresPrtA2";
81112998:	00a04574 	movhi	r2,33045
8111299c:	1095f304 	addi	r2,r2,22476
811129a0:	00e04574 	movhi	r3,33045
811129a4:	18fc5a04 	addi	r3,r3,-3736
811129a8:	10c02915 	stw	r3,164(r2)
	cTemp[42]="usiLowresPrtA3";
811129ac:	00a04574 	movhi	r2,33045
811129b0:	1095f304 	addi	r2,r2,22476
811129b4:	00e04574 	movhi	r3,33045
811129b8:	18fc5e04 	addi	r3,r3,-3720
811129bc:	10c02a15 	stw	r3,168(r2)
	cTemp[43]="usiLowresPrtA4";
811129c0:	00a04574 	movhi	r2,33045
811129c4:	1095f304 	addi	r2,r2,22476
811129c8:	00e04574 	movhi	r3,33045
811129cc:	18fc6204 	addi	r3,r3,-3704
811129d0:	10c02b15 	stw	r3,172(r2)
	cTemp[44]="usiLowresPrtA5";
811129d4:	00a04574 	movhi	r2,33045
811129d8:	1095f304 	addi	r2,r2,22476
811129dc:	00e04574 	movhi	r3,33045
811129e0:	18fc6604 	addi	r3,r3,-3688
811129e4:	10c02c15 	stw	r3,176(r2)
	cTemp[45]="usiLowresPrtA6";
811129e8:	00a04574 	movhi	r2,33045
811129ec:	1095f304 	addi	r2,r2,22476
811129f0:	00e04574 	movhi	r3,33045
811129f4:	18fc6a04 	addi	r3,r3,-3672
811129f8:	10c02d15 	stw	r3,180(r2)
	cTemp[46]="usiLowresPrtA7";
811129fc:	00a04574 	movhi	r2,33045
81112a00:	1095f304 	addi	r2,r2,22476
81112a04:	00e04574 	movhi	r3,33045
81112a08:	18fc6e04 	addi	r3,r3,-3656
81112a0c:	10c02e15 	stw	r3,184(r2)
	cTemp[47]="usiLowresPrtA8";
81112a10:	00a04574 	movhi	r2,33045
81112a14:	1095f304 	addi	r2,r2,22476
81112a18:	00e04574 	movhi	r3,33045
81112a1c:	18fc7204 	addi	r3,r3,-3640
81112a20:	10c02f15 	stw	r3,188(r2)
	cTemp[48]="usiLowresPrtA9";
81112a24:	00a04574 	movhi	r2,33045
81112a28:	1095f304 	addi	r2,r2,22476
81112a2c:	00e04574 	movhi	r3,33045
81112a30:	18fc7604 	addi	r3,r3,-3624
81112a34:	10c03015 	stw	r3,192(r2)
	cTemp[49]="usiLowresPrtA10";
81112a38:	00a04574 	movhi	r2,33045
81112a3c:	1095f304 	addi	r2,r2,22476
81112a40:	00e04574 	movhi	r3,33045
81112a44:	18fc7a04 	addi	r3,r3,-3608
81112a48:	10c03115 	stw	r3,196(r2)
	cTemp[50]="usiLowresPrtA11";
81112a4c:	00a04574 	movhi	r2,33045
81112a50:	1095f304 	addi	r2,r2,22476
81112a54:	00e04574 	movhi	r3,33045
81112a58:	18fc7e04 	addi	r3,r3,-3592
81112a5c:	10c03215 	stw	r3,200(r2)
	cTemp[51]="usiLowresPrtA12";
81112a60:	00a04574 	movhi	r2,33045
81112a64:	1095f304 	addi	r2,r2,22476
81112a68:	00e04574 	movhi	r3,33045
81112a6c:	18fc8204 	addi	r3,r3,-3576
81112a70:	10c03315 	stw	r3,204(r2)
	cTemp[52]="usiLowresPrtA13";
81112a74:	00a04574 	movhi	r2,33045
81112a78:	1095f304 	addi	r2,r2,22476
81112a7c:	00e04574 	movhi	r3,33045
81112a80:	18fc8604 	addi	r3,r3,-3560
81112a84:	10c03415 	stw	r3,208(r2)
	cTemp[53]="usiLowresPrtA14";
81112a88:	00a04574 	movhi	r2,33045
81112a8c:	1095f304 	addi	r2,r2,22476
81112a90:	00e04574 	movhi	r3,33045
81112a94:	18fc8a04 	addi	r3,r3,-3544
81112a98:	10c03515 	stw	r3,212(r2)
	cTemp[54]="usiLowresPrtA15";
81112a9c:	00a04574 	movhi	r2,33045
81112aa0:	1095f304 	addi	r2,r2,22476
81112aa4:	00e04574 	movhi	r3,33045
81112aa8:	18fc8e04 	addi	r3,r3,-3528
81112aac:	10c03615 	stw	r3,216(r2)
	cTemp[55]="usiSelHiresPrt0";
81112ab0:	00a04574 	movhi	r2,33045
81112ab4:	1095f304 	addi	r2,r2,22476
81112ab8:	00e04574 	movhi	r3,33045
81112abc:	18fc9204 	addi	r3,r3,-3512
81112ac0:	10c03715 	stw	r3,220(r2)
	cTemp[56]="usiSelHiresPrt1";
81112ac4:	00a04574 	movhi	r2,33045
81112ac8:	1095f304 	addi	r2,r2,22476
81112acc:	00e04574 	movhi	r3,33045
81112ad0:	18fc9604 	addi	r3,r3,-3496
81112ad4:	10c03815 	stw	r3,224(r2)
	cTemp[57]="usiSelHiresPrt2";
81112ad8:	00a04574 	movhi	r2,33045
81112adc:	1095f304 	addi	r2,r2,22476
81112ae0:	00e04574 	movhi	r3,33045
81112ae4:	18fc9a04 	addi	r3,r3,-3480
81112ae8:	10c03915 	stw	r3,228(r2)
	cTemp[58]="usiSelHiresPrt3";
81112aec:	00a04574 	movhi	r2,33045
81112af0:	1095f304 	addi	r2,r2,22476
81112af4:	00e04574 	movhi	r3,33045
81112af8:	18fc9e04 	addi	r3,r3,-3464
81112afc:	10c03a15 	stw	r3,232(r2)
	cTemp[59]="usiSelHiresPrt4";
81112b00:	00a04574 	movhi	r2,33045
81112b04:	1095f304 	addi	r2,r2,22476
81112b08:	00e04574 	movhi	r3,33045
81112b0c:	18fca204 	addi	r3,r3,-3448
81112b10:	10c03b15 	stw	r3,236(r2)
	cTemp[60]="usiSelHiresPrt5";
81112b14:	00a04574 	movhi	r2,33045
81112b18:	1095f304 	addi	r2,r2,22476
81112b1c:	00e04574 	movhi	r3,33045
81112b20:	18fca604 	addi	r3,r3,-3432
81112b24:	10c03c15 	stw	r3,240(r2)
	cTemp[61]="usiSelHiresPrt6";
81112b28:	00a04574 	movhi	r2,33045
81112b2c:	1095f304 	addi	r2,r2,22476
81112b30:	00e04574 	movhi	r3,33045
81112b34:	18fcaa04 	addi	r3,r3,-3416
81112b38:	10c03d15 	stw	r3,244(r2)
	cTemp[62]="usiSelHiresPrt7";
81112b3c:	00a04574 	movhi	r2,33045
81112b40:	1095f304 	addi	r2,r2,22476
81112b44:	00e04574 	movhi	r3,33045
81112b48:	18fcae04 	addi	r3,r3,-3400
81112b4c:	10c03e15 	stw	r3,248(r2)
	cTemp[63]="usiZeroHiresAmp";
81112b50:	00a04574 	movhi	r2,33045
81112b54:	1095f304 	addi	r2,r2,22476
81112b58:	00e04574 	movhi	r3,33045
81112b5c:	18fcb204 	addi	r3,r3,-3384
81112b60:	10c03f15 	stw	r3,252(r2)
}
81112b64:	0001883a 	nop
81112b68:	e037883a 	mov	sp,fp
81112b6c:	df000017 	ldw	fp,0(sp)
81112b70:	dec00104 	addi	sp,sp,4
81112b74:	f800283a 	ret

81112b78 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
81112b78:	defff604 	addi	sp,sp,-40
81112b7c:	de00012e 	bgeu	sp,et,81112b84 <vInAckHandlerTaskV2+0xc>
81112b80:	003b68fa 	trap	3
81112b84:	dfc00915 	stw	ra,36(sp)
81112b88:	df000815 	stw	fp,32(sp)
81112b8c:	df000804 	addi	fp,sp,32
81112b90:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
81112b94:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
81112b98:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
81112b9c:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
81112ba0:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
81112ba4:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
81112ba8:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
81112bac:	e03ffa45 	stb	zero,-23(fp)

    #if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81112bb0:	00a045f4 	movhi	r2,33047
81112bb4:	10a25304 	addi	r2,r2,-30388
81112bb8:	10800a8b 	ldhu	r2,42(r2)
81112bbc:	10bfffcc 	andi	r2,r2,65535
81112bc0:	10800168 	cmpgeui	r2,r2,5
81112bc4:	1000071e 	bne	r2,zero,81112be4 <vInAckHandlerTaskV2+0x6c>
        debug(fp,"In Ack Handler Task. (Task on)\n");
81112bc8:	d0a06217 	ldw	r2,-32376(gp)
81112bcc:	100f883a 	mov	r7,r2
81112bd0:	018007c4 	movi	r6,31
81112bd4:	01400044 	movi	r5,1
81112bd8:	01204574 	movhi	r4,33045
81112bdc:	213cb604 	addi	r4,r4,-3368
81112be0:	112393c0 	call	8112393c <fwrite>
    }
    #endif

	eReceiverAckState = sRAConfiguring;
81112be4:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
81112be8:	e0bff917 	ldw	r2,-28(fp)
81112bec:	10c00060 	cmpeqi	r3,r2,1
81112bf0:	1800071e 	bne	r3,zero,81112c10 <vInAckHandlerTaskV2+0x98>
81112bf4:	0080032e 	bgeu	zero,r2,81112c04 <vInAckHandlerTaskV2+0x8c>
81112bf8:	108000a0 	cmpeqi	r2,r2,2
81112bfc:	10004a1e 	bne	r2,zero,81112d28 <vInAckHandlerTaskV2+0x1b0>
81112c00:	0000ac06 	br	81112eb4 <vInAckHandlerTaskV2+0x33c>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
81112c04:	00800044 	movi	r2,1
81112c08:	e0bff915 	stw	r2,-28(fp)
				break;
81112c0c:	0000b906 	br	81112ef4 <vInAckHandlerTaskV2+0x37c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
81112c10:	00800044 	movi	r2,1
81112c14:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
81112c18:	d0a06617 	ldw	r2,-32360(gp)
81112c1c:	e0fffe04 	addi	r3,fp,-8
81112c20:	180d883a 	mov	r6,r3
81112c24:	000b883a 	mov	r5,zero
81112c28:	1009883a 	mov	r4,r2
81112c2c:	114075c0 	call	8114075c <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81112c30:	e0bffe03 	ldbu	r2,-8(fp)
81112c34:	10803fcc 	andi	r2,r2,255
81112c38:	1000391e 	bne	r2,zero,81112d20 <vInAckHandlerTaskV2+0x1a8>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
81112c3c:	d0a06517 	ldw	r2,-32364(gp)
81112c40:	e0fffe04 	addi	r3,fp,-8
81112c44:	180d883a 	mov	r6,r3
81112c48:	000b883a 	mov	r5,zero
81112c4c:	1009883a 	mov	r4,r2
81112c50:	113e7500 	call	8113e750 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81112c54:	e0bffe03 	ldbu	r2,-8(fp)
81112c58:	10803fcc 	andi	r2,r2,255
81112c5c:	10002b1e 	bne	r2,zero,81112d0c <vInAckHandlerTaskV2+0x194>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81112c60:	e03ffa45 	stb	zero,-23(fp)
81112c64:	00002206 	br	81112cf0 <vInAckHandlerTaskV2+0x178>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
81112c68:	e0fffa43 	ldbu	r3,-23(fp)
81112c6c:	00a045b4 	movhi	r2,33046
81112c70:	108b9104 	addi	r2,r2,11844
81112c74:	18c7883a 	add	r3,r3,r3
81112c78:	18c7883a 	add	r3,r3,r3
81112c7c:	10c5883a 	add	r2,r2,r3
81112c80:	10800003 	ldbu	r2,0(r2)
81112c84:	10803fcc 	andi	r2,r2,255
81112c88:	1080201c 	xori	r2,r2,128
81112c8c:	10bfe004 	addi	r2,r2,-128
81112c90:	10001426 	beq	r2,zero,81112ce4 <vInAckHandlerTaskV2+0x16c>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
81112c94:	e0fffa43 	ldbu	r3,-23(fp)
81112c98:	00a045b4 	movhi	r2,33046
81112c9c:	108b9104 	addi	r2,r2,11844
81112ca0:	18c7883a 	add	r3,r3,r3
81112ca4:	18c7883a 	add	r3,r3,r3
81112ca8:	10c5883a 	add	r2,r2,r3
81112cac:	10c0000b 	ldhu	r3,0(r2)
81112cb0:	d0e0568d 	sth	r3,-32422(gp)
81112cb4:	1080008b 	ldhu	r2,2(r2)
81112cb8:	d0a0570d 	sth	r2,-32420(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81112cbc:	e0fffa43 	ldbu	r3,-23(fp)
81112cc0:	00a045b4 	movhi	r2,33046
81112cc4:	108b9104 	addi	r2,r2,11844
81112cc8:	18c7883a 	add	r3,r3,r3
81112ccc:	18c7883a 	add	r3,r3,r3
81112cd0:	10c5883a 	add	r2,r2,r3
81112cd4:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
81112cd8:	00800084 	movi	r2,2
81112cdc:	e0bff915 	stw	r2,-28(fp)
                                break;                                
81112ce0:	00000606 	br	81112cfc <vInAckHandlerTaskV2+0x184>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81112ce4:	e0bffa43 	ldbu	r2,-23(fp)
81112ce8:	10800044 	addi	r2,r2,1
81112cec:	e0bffa45 	stb	r2,-23(fp)
81112cf0:	e0bffa43 	ldbu	r2,-23(fp)
81112cf4:	108001b0 	cmpltui	r2,r2,6
81112cf8:	103fdb1e 	bne	r2,zero,81112c68 <__reset+0xfb0f2c68>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
81112cfc:	d0a06517 	ldw	r2,-32364(gp)
81112d00:	1009883a 	mov	r4,r2
81112d04:	113ecf40 	call	8113ecf4 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81112d08:	00007a06 	br	81112ef4 <vInAckHandlerTaskV2+0x37c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
81112d0c:	d0a06617 	ldw	r2,-32360(gp)
81112d10:	1009883a 	mov	r4,r2
81112d14:	1140ae40 	call	81140ae4 <OSSemPost>
                    	vFailGetMutexReceiverTask();
81112d18:	111d3080 	call	8111d308 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81112d1c:	00007506 	br	81112ef4 <vInAckHandlerTaskV2+0x37c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
81112d20:	111d2880 	call	8111d288 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
81112d24:	00007306 	br	81112ef4 <vInAckHandlerTaskV2+0x37c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
81112d28:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81112d2c:	d0a06883 	ldbu	r2,-32350(gp)
81112d30:	10803fcc 	andi	r2,r2,255
81112d34:	10800218 	cmpnei	r2,r2,8
81112d38:	1000021e 	bne	r2,zero,81112d44 <vInAckHandlerTaskV2+0x1cc>
81112d3c:	00c00104 	movi	r3,4
81112d40:	00000106 	br	81112d48 <vInAckHandlerTaskV2+0x1d0>
81112d44:	0007883a 	mov	r3,zero
81112d48:	d0a07503 	ldbu	r2,-32300(gp)
81112d4c:	10803fcc 	andi	r2,r2,255
81112d50:	10800218 	cmpnei	r2,r2,8
81112d54:	1000021e 	bne	r2,zero,81112d60 <vInAckHandlerTaskV2+0x1e8>
81112d58:	00800084 	movi	r2,2
81112d5c:	00000106 	br	81112d64 <vInAckHandlerTaskV2+0x1ec>
81112d60:	0005883a 	mov	r2,zero
81112d64:	1884b03a 	or	r2,r3,r2
81112d68:	1007883a 	mov	r3,r2
81112d6c:	d0a07543 	ldbu	r2,-32299(gp)
81112d70:	10803fcc 	andi	r2,r2,255
81112d74:	108001a0 	cmpeqi	r2,r2,6
81112d78:	1884b03a 	or	r2,r3,r2
81112d7c:	1007883a 	mov	r3,r2
81112d80:	e0bffa83 	ldbu	r2,-22(fp)
81112d84:	1884b03a 	or	r2,r3,r2
81112d88:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
81112d8c:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
81112d90:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
81112d94:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
81112d98:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
81112d9c:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
81112da0:	e0bffa03 	ldbu	r2,-24(fp)
81112da4:	10800044 	addi	r2,r2,1
81112da8:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81112dac:	e0bffa83 	ldbu	r2,-22(fp)
81112db0:	1080004c 	andi	r2,r2,1
81112db4:	10803fcc 	andi	r2,r2,255
81112db8:	1000061e 	bne	r2,zero,81112dd4 <vInAckHandlerTaskV2+0x25c>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
81112dbc:	e0bffd04 	addi	r2,fp,-12
81112dc0:	100b883a 	mov	r5,r2
81112dc4:	d1205684 	addi	r4,gp,-32422
81112dc8:	1112ef80 	call	81112ef8 <bCheckInAck128>
81112dcc:	e0bff815 	stw	r2,-32(fp)
81112dd0:	00000206 	br	81112ddc <vInAckHandlerTaskV2+0x264>
                    else
                        bFinished128 = TRUE;
81112dd4:	00800044 	movi	r2,1
81112dd8:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
81112ddc:	e0bffa83 	ldbu	r2,-22(fp)
81112de0:	1080008c 	andi	r2,r2,2
81112de4:	10803fcc 	andi	r2,r2,255
81112de8:	1000081e 	bne	r2,zero,81112e0c <vInAckHandlerTaskV2+0x294>
81112dec:	e0bff817 	ldw	r2,-32(fp)
81112df0:	1000061e 	bne	r2,zero,81112e0c <vInAckHandlerTaskV2+0x294>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
81112df4:	e0bffc04 	addi	r2,fp,-16
81112df8:	100b883a 	mov	r5,r2
81112dfc:	d1205684 	addi	r4,gp,-32422
81112e00:	11130400 	call	81113040 <bCheckInAck64>
81112e04:	e0bff815 	stw	r2,-32(fp)
81112e08:	00000206 	br	81112e14 <vInAckHandlerTaskV2+0x29c>
                    else
                        bFinished64 = TRUE;
81112e0c:	00800044 	movi	r2,1
81112e10:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
81112e14:	e0bffa83 	ldbu	r2,-22(fp)
81112e18:	1080010c 	andi	r2,r2,4
81112e1c:	10803fcc 	andi	r2,r2,255
81112e20:	1000081e 	bne	r2,zero,81112e44 <vInAckHandlerTaskV2+0x2cc>
81112e24:	e0bff817 	ldw	r2,-32(fp)
81112e28:	1000061e 	bne	r2,zero,81112e44 <vInAckHandlerTaskV2+0x2cc>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
81112e2c:	e0bffb04 	addi	r2,fp,-20
81112e30:	100b883a 	mov	r5,r2
81112e34:	d1205684 	addi	r4,gp,-32422
81112e38:	111318c0 	call	8111318c <bCheckInAck32>
81112e3c:	e0bff815 	stw	r2,-32(fp)
81112e40:	00000206 	br	81112e4c <vInAckHandlerTaskV2+0x2d4>
                    else
                        bFinished32 = TRUE;
81112e44:	00800044 	movi	r2,1
81112e48:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
81112e4c:	e0bffa03 	ldbu	r2,-24(fp)
81112e50:	10c00044 	addi	r3,r2,1
81112e54:	e0fffa05 	stb	r3,-24(fp)
81112e58:	10803fcc 	andi	r2,r2,255
81112e5c:	10800ca8 	cmpgeui	r2,r2,50
81112e60:	10000e1e 	bne	r2,zero,81112e9c <vInAckHandlerTaskV2+0x324>
81112e64:	e0bff817 	ldw	r2,-32(fp)
81112e68:	10000c1e 	bne	r2,zero,81112e9c <vInAckHandlerTaskV2+0x324>
81112e6c:	e0bffb17 	ldw	r2,-20(fp)
81112e70:	1005003a 	cmpeq	r2,r2,zero
81112e74:	1007883a 	mov	r3,r2
81112e78:	e0bffc17 	ldw	r2,-16(fp)
81112e7c:	1005003a 	cmpeq	r2,r2,zero
81112e80:	1884b03a 	or	r2,r3,r2
81112e84:	10c03fcc 	andi	r3,r2,255
81112e88:	e0bffd17 	ldw	r2,-12(fp)
81112e8c:	1005003a 	cmpeq	r2,r2,zero
81112e90:	10803fcc 	andi	r2,r2,255
81112e94:	1884b03a 	or	r2,r3,r2
81112e98:	103fc11e 	bne	r2,zero,81112da0 <__reset+0xfb0f2da0>
                
                if (bFound == FALSE) {
81112e9c:	e0bff817 	ldw	r2,-32(fp)
81112ea0:	1000011e 	bne	r2,zero,81112ea8 <vInAckHandlerTaskV2+0x330>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
81112ea4:	111d8fc0 	call	8111d8fc <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
81112ea8:	00800044 	movi	r2,1
81112eac:	e0bff915 	stw	r2,-28(fp)
				break;
81112eb0:	00001006 	br	81112ef4 <vInAckHandlerTaskV2+0x37c>
			default:
                #if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly) {
81112eb4:	00a045f4 	movhi	r2,33047
81112eb8:	10a25304 	addi	r2,r2,-30388
81112ebc:	10800a8b 	ldhu	r2,42(r2)
81112ec0:	10bfffcc 	andi	r2,r2,65535
81112ec4:	10800228 	cmpgeui	r2,r2,8
81112ec8:	1000071e 	bne	r2,zero,81112ee8 <vInAckHandlerTaskV2+0x370>
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
81112ecc:	d0a06217 	ldw	r2,-32376(gp)
81112ed0:	100f883a 	mov	r7,r2
81112ed4:	01801144 	movi	r6,69
81112ed8:	01400044 	movi	r5,1
81112edc:	01204574 	movhi	r4,33045
81112ee0:	213cbe04 	addi	r4,r4,-3336
81112ee4:	112393c0 	call	8112393c <fwrite>
				}
	            #endif
                eReceiverAckState = sRAGettingACK;
81112ee8:	00800044 	movi	r2,1
81112eec:	e0bff915 	stw	r2,-28(fp)
				break;
81112ef0:	0001883a 	nop
		}
	}
81112ef4:	003f3c06 	br	81112be8 <__reset+0xfb0f2be8>

81112ef8 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
81112ef8:	defffa04 	addi	sp,sp,-24
81112efc:	de00012e 	bgeu	sp,et,81112f04 <bCheckInAck128+0xc>
81112f00:	003b68fa 	trap	3
81112f04:	dfc00515 	stw	ra,20(sp)
81112f08:	df000415 	stw	fp,16(sp)
81112f0c:	df000404 	addi	fp,sp,16
81112f10:	e13ffe15 	stw	r4,-8(fp)
81112f14:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81112f18:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81112f1c:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81112f20:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81112f24:	e0bfff17 	ldw	r2,-4(fp)
81112f28:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
81112f2c:	d0a06e17 	ldw	r2,-32328(gp)
81112f30:	e0fffd44 	addi	r3,fp,-11
81112f34:	180d883a 	mov	r6,r3
81112f38:	01400144 	movi	r5,5
81112f3c:	1009883a 	mov	r4,r2
81112f40:	113e7500 	call	8113e750 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81112f44:	e0bffd43 	ldbu	r2,-11(fp)
81112f48:	10803fcc 	andi	r2,r2,255
81112f4c:	10000226 	beq	r2,zero,81112f58 <bCheckInAck128+0x60>
        return bFound;
81112f50:	e0bffc17 	ldw	r2,-16(fp)
81112f54:	00003506 	br	8111302c <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81112f58:	e03ffd05 	stb	zero,-12(fp)
81112f5c:	00002706 	br	81112ffc <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
81112f60:	e0fffd03 	ldbu	r3,-12(fp)
81112f64:	00a045b4 	movhi	r2,33046
81112f68:	10828f04 	addi	r2,r2,2620
81112f6c:	18c02324 	muli	r3,r3,140
81112f70:	10c5883a 	add	r2,r2,r3
81112f74:	10802104 	addi	r2,r2,132
81112f78:	10c0000b 	ldhu	r3,0(r2)
81112f7c:	e0bffe17 	ldw	r2,-8(fp)
81112f80:	1080008b 	ldhu	r2,2(r2)
81112f84:	18ffffcc 	andi	r3,r3,65535
81112f88:	10bfffcc 	andi	r2,r2,65535
81112f8c:	1880181e 	bne	r3,r2,81112ff0 <bCheckInAck128+0xf8>
            bFound = TRUE;
81112f90:	00800044 	movi	r2,1
81112f94:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
81112f98:	e0fffd03 	ldbu	r3,-12(fp)
81112f9c:	00a045b4 	movhi	r2,33046
81112fa0:	10827104 	addi	r2,r2,2500
81112fa4:	18c7883a 	add	r3,r3,r3
81112fa8:	18c7883a 	add	r3,r3,r3
81112fac:	10c5883a 	add	r2,r2,r3
81112fb0:	10000015 	stw	zero,0(r2)
            SemCount128++;
81112fb4:	d0a07543 	ldbu	r2,-32299(gp)
81112fb8:	10800044 	addi	r2,r2,1
81112fbc:	d0a07545 	stb	r2,-32299(gp)
            error_code = OSSemPost(xSemCountBuffer128);
81112fc0:	d0a06317 	ldw	r2,-32372(gp)
81112fc4:	1009883a 	mov	r4,r2
81112fc8:	1140ae40 	call	81140ae4 <OSSemPost>
81112fcc:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81112fd0:	e0bffd43 	ldbu	r2,-11(fp)
81112fd4:	10803fcc 	andi	r2,r2,255
81112fd8:	10000c26 	beq	r2,zero,8111300c <bCheckInAck128+0x114>
                SemCount128--;
81112fdc:	d0a07543 	ldbu	r2,-32299(gp)
81112fe0:	10bfffc4 	addi	r2,r2,-1
81112fe4:	d0a07545 	stb	r2,-32299(gp)
                vFailSetCountSemaphorexBuffer128();
81112fe8:	111d6fc0 	call	8111d6fc <vFailSetCountSemaphorexBuffer128>
            }
            break;
81112fec:	00000706 	br	8111300c <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81112ff0:	e0bffd03 	ldbu	r2,-12(fp)
81112ff4:	10800044 	addi	r2,r2,1
81112ff8:	e0bffd05 	stb	r2,-12(fp)
81112ffc:	e0bffd03 	ldbu	r2,-12(fp)
81113000:	108001b0 	cmpltui	r2,r2,6
81113004:	103fd61e 	bne	r2,zero,81112f60 <__reset+0xfb0f2f60>
81113008:	00000106 	br	81113010 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
8111300c:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81113010:	d0a06e17 	ldw	r2,-32328(gp)
81113014:	1009883a 	mov	r4,r2
81113018:	113ecf40 	call	8113ecf4 <OSMutexPost>
    (*bFinished) = TRUE;
8111301c:	e0bfff17 	ldw	r2,-4(fp)
81113020:	00c00044 	movi	r3,1
81113024:	10c00015 	stw	r3,0(r2)

    return bFound;
81113028:	e0bffc17 	ldw	r2,-16(fp)
}
8111302c:	e037883a 	mov	sp,fp
81113030:	dfc00117 	ldw	ra,4(sp)
81113034:	df000017 	ldw	fp,0(sp)
81113038:	dec00204 	addi	sp,sp,8
8111303c:	f800283a 	ret

81113040 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
81113040:	defffa04 	addi	sp,sp,-24
81113044:	de00012e 	bgeu	sp,et,8111304c <bCheckInAck64+0xc>
81113048:	003b68fa 	trap	3
8111304c:	dfc00515 	stw	ra,20(sp)
81113050:	df000415 	stw	fp,16(sp)
81113054:	df000404 	addi	fp,sp,16
81113058:	e13ffe15 	stw	r4,-8(fp)
8111305c:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81113060:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81113064:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81113068:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8111306c:	e0bfff17 	ldw	r2,-4(fp)
81113070:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
81113074:	d0a07117 	ldw	r2,-32316(gp)
81113078:	e0fffd44 	addi	r3,fp,-11
8111307c:	180d883a 	mov	r6,r3
81113080:	01400044 	movi	r5,1
81113084:	1009883a 	mov	r4,r2
81113088:	113e7500 	call	8113e750 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8111308c:	e0bffd43 	ldbu	r2,-11(fp)
81113090:	10803fcc 	andi	r2,r2,255
81113094:	10000226 	beq	r2,zero,811130a0 <bCheckInAck64+0x60>
        return bFound;
81113098:	e0bffc17 	ldw	r2,-16(fp)
8111309c:	00003606 	br	81113178 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
811130a0:	e03ffd05 	stb	zero,-12(fp)
811130a4:	00002806 	br	81113148 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
811130a8:	e0fffd03 	ldbu	r3,-12(fp)
811130ac:	00a04574 	movhi	r2,33045
811130b0:	109e3304 	addi	r2,r2,30924
811130b4:	18c01324 	muli	r3,r3,76
811130b8:	10c5883a 	add	r2,r2,r3
811130bc:	10801104 	addi	r2,r2,68
811130c0:	10c0000b 	ldhu	r3,0(r2)
811130c4:	e0bffe17 	ldw	r2,-8(fp)
811130c8:	1080008b 	ldhu	r2,2(r2)
811130cc:	18ffffcc 	andi	r3,r3,65535
811130d0:	10bfffcc 	andi	r2,r2,65535
811130d4:	1880191e 	bne	r3,r2,8111313c <bCheckInAck64+0xfc>
            bFound = TRUE;
811130d8:	00800044 	movi	r2,1
811130dc:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
811130e0:	e0fffd03 	ldbu	r3,-12(fp)
811130e4:	00a045b4 	movhi	r2,33046
811130e8:	10827104 	addi	r2,r2,2500
811130ec:	18c00184 	addi	r3,r3,6
811130f0:	18c7883a 	add	r3,r3,r3
811130f4:	18c7883a 	add	r3,r3,r3
811130f8:	10c5883a 	add	r2,r2,r3
811130fc:	10000015 	stw	zero,0(r2)
            SemCount64++;
81113100:	d0a07503 	ldbu	r2,-32300(gp)
81113104:	10800044 	addi	r2,r2,1
81113108:	d0a07505 	stb	r2,-32300(gp)
            error_code = OSSemPost(xSemCountBuffer64);
8111310c:	d0a05e17 	ldw	r2,-32392(gp)
81113110:	1009883a 	mov	r4,r2
81113114:	1140ae40 	call	81140ae4 <OSSemPost>
81113118:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8111311c:	e0bffd43 	ldbu	r2,-11(fp)
81113120:	10803fcc 	andi	r2,r2,255
81113124:	10000c26 	beq	r2,zero,81113158 <bCheckInAck64+0x118>
                SemCount64--;
81113128:	d0a07503 	ldbu	r2,-32300(gp)
8111312c:	10bfffc4 	addi	r2,r2,-1
81113130:	d0a07505 	stb	r2,-32300(gp)
                vFailSetCountSemaphorexBuffer64();
81113134:	111d67c0 	call	8111d67c <vFailSetCountSemaphorexBuffer64>
            }
            break;
81113138:	00000706 	br	81113158 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8111313c:	e0bffd03 	ldbu	r2,-12(fp)
81113140:	10800044 	addi	r2,r2,1
81113144:	e0bffd05 	stb	r2,-12(fp)
81113148:	e0bffd03 	ldbu	r2,-12(fp)
8111314c:	10800230 	cmpltui	r2,r2,8
81113150:	103fd51e 	bne	r2,zero,811130a8 <__reset+0xfb0f30a8>
81113154:	00000106 	br	8111315c <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
81113158:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
8111315c:	d0a07117 	ldw	r2,-32316(gp)
81113160:	1009883a 	mov	r4,r2
81113164:	113ecf40 	call	8113ecf4 <OSMutexPost>
    (*bFinished) = TRUE;
81113168:	e0bfff17 	ldw	r2,-4(fp)
8111316c:	00c00044 	movi	r3,1
81113170:	10c00015 	stw	r3,0(r2)

    return bFound;
81113174:	e0bffc17 	ldw	r2,-16(fp)
}
81113178:	e037883a 	mov	sp,fp
8111317c:	dfc00117 	ldw	ra,4(sp)
81113180:	df000017 	ldw	fp,0(sp)
81113184:	dec00204 	addi	sp,sp,8
81113188:	f800283a 	ret

8111318c <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
8111318c:	defffa04 	addi	sp,sp,-24
81113190:	de00012e 	bgeu	sp,et,81113198 <bCheckInAck32+0xc>
81113194:	003b68fa 	trap	3
81113198:	dfc00515 	stw	ra,20(sp)
8111319c:	df000415 	stw	fp,16(sp)
811131a0:	df000404 	addi	fp,sp,16
811131a4:	e13ffe15 	stw	r4,-8(fp)
811131a8:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
811131ac:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811131b0:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811131b4:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
811131b8:	e0bfff17 	ldw	r2,-4(fp)
811131bc:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
811131c0:	d0a06c17 	ldw	r2,-32336(gp)
811131c4:	e0fffd44 	addi	r3,fp,-11
811131c8:	180d883a 	mov	r6,r3
811131cc:	01400044 	movi	r5,1
811131d0:	1009883a 	mov	r4,r2
811131d4:	113e7500 	call	8113e750 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
811131d8:	e0bffd43 	ldbu	r2,-11(fp)
811131dc:	10803fcc 	andi	r2,r2,255
811131e0:	10000226 	beq	r2,zero,811131ec <bCheckInAck32+0x60>
        return bFound;
811131e4:	e0bffc17 	ldw	r2,-16(fp)
811131e8:	00003606 	br	811132c4 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
811131ec:	e03ffd05 	stb	zero,-12(fp)
811131f0:	00002806 	br	81113294 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
811131f4:	e0fffd03 	ldbu	r3,-12(fp)
811131f8:	00a045b4 	movhi	r2,33046
811131fc:	10aff104 	addi	r2,r2,-16444
81113200:	18c00b24 	muli	r3,r3,44
81113204:	10c5883a 	add	r2,r2,r3
81113208:	10800904 	addi	r2,r2,36
8111320c:	10c0000b 	ldhu	r3,0(r2)
81113210:	e0bffe17 	ldw	r2,-8(fp)
81113214:	1080008b 	ldhu	r2,2(r2)
81113218:	18ffffcc 	andi	r3,r3,65535
8111321c:	10bfffcc 	andi	r2,r2,65535
81113220:	1880191e 	bne	r3,r2,81113288 <bCheckInAck32+0xfc>
            bFound = TRUE;
81113224:	00800044 	movi	r2,1
81113228:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
8111322c:	e0fffd03 	ldbu	r3,-12(fp)
81113230:	00a045b4 	movhi	r2,33046
81113234:	10827104 	addi	r2,r2,2500
81113238:	18c00384 	addi	r3,r3,14
8111323c:	18c7883a 	add	r3,r3,r3
81113240:	18c7883a 	add	r3,r3,r3
81113244:	10c5883a 	add	r2,r2,r3
81113248:	10000015 	stw	zero,0(r2)
            SemCount32++;
8111324c:	d0a06883 	ldbu	r2,-32350(gp)
81113250:	10800044 	addi	r2,r2,1
81113254:	d0a06885 	stb	r2,-32350(gp)
            error_code = OSSemPost(xSemCountBuffer32);
81113258:	d0a06f17 	ldw	r2,-32324(gp)
8111325c:	1009883a 	mov	r4,r2
81113260:	1140ae40 	call	81140ae4 <OSSemPost>
81113264:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81113268:	e0bffd43 	ldbu	r2,-11(fp)
8111326c:	10803fcc 	andi	r2,r2,255
81113270:	10000c26 	beq	r2,zero,811132a4 <bCheckInAck32+0x118>
                SemCount32--;
81113274:	d0a06883 	ldbu	r2,-32350(gp)
81113278:	10bfffc4 	addi	r2,r2,-1
8111327c:	d0a06885 	stb	r2,-32350(gp)
                vFailSetCountSemaphorexBuffer32();
81113280:	111d5fc0 	call	8111d5fc <vFailSetCountSemaphorexBuffer32>
            }
            break;
81113284:	00000706 	br	811132a4 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81113288:	e0bffd03 	ldbu	r2,-12(fp)
8111328c:	10800044 	addi	r2,r2,1
81113290:	e0bffd05 	stb	r2,-12(fp)
81113294:	e0bffd03 	ldbu	r2,-12(fp)
81113298:	10800230 	cmpltui	r2,r2,8
8111329c:	103fd51e 	bne	r2,zero,811131f4 <__reset+0xfb0f31f4>
811132a0:	00000106 	br	811132a8 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
811132a4:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
811132a8:	d0a06c17 	ldw	r2,-32336(gp)
811132ac:	1009883a 	mov	r4,r2
811132b0:	113ecf40 	call	8113ecf4 <OSMutexPost>
    (*bFinished) = TRUE;
811132b4:	e0bfff17 	ldw	r2,-4(fp)
811132b8:	00c00044 	movi	r3,1
811132bc:	10c00015 	stw	r3,0(r2)

    return bFound;
811132c0:	e0bffc17 	ldw	r2,-16(fp)
}
811132c4:	e037883a 	mov	sp,fp
811132c8:	dfc00117 	ldw	ra,4(sp)
811132cc:	df000017 	ldw	fp,0(sp)
811132d0:	dec00204 	addi	sp,sp,8
811132d4:	f800283a 	ret

811132d8 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
811132d8:	defff704 	addi	sp,sp,-36
811132dc:	de00012e 	bgeu	sp,et,811132e4 <vInitialTask+0xc>
811132e0:	003b68fa 	trap	3
811132e4:	dfc00815 	stw	ra,32(sp)
811132e8:	df000715 	stw	fp,28(sp)
811132ec:	df000704 	addi	fp,sp,28
811132f0:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
811132f4:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
811132f8:	d8000415 	stw	zero,16(sp)
811132fc:	d8000315 	stw	zero,12(sp)
81113300:	00810004 	movi	r2,1024
81113304:	d8800215 	stw	r2,8(sp)
81113308:	00a04574 	movhi	r2,33045
8111330c:	10963304 	addi	r2,r2,22732
81113310:	d8800115 	stw	r2,4(sp)
81113314:	008002c4 	movi	r2,11
81113318:	d8800015 	stw	r2,0(sp)
8111331c:	01c002c4 	movi	r7,11
81113320:	01a04574 	movhi	r6,33045
81113324:	319a3204 	addi	r6,r6,26824
81113328:	016045b4 	movhi	r5,33046
8111332c:	296b5304 	addi	r5,r5,-21172
81113330:	01204474 	movhi	r4,33041
81113334:	21388904 	addi	r4,r4,-7644
81113338:	11414c80 	call	811414c8 <OSTaskCreateExt>
8111333c:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81113340:	e0bffe03 	ldbu	r2,-8(fp)
81113344:	10803fcc 	andi	r2,r2,255
81113348:	10000b26 	beq	r2,zero,81113378 <vInitialTask+0xa0>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111334c:	00a045f4 	movhi	r2,33047
81113350:	10a25304 	addi	r2,r2,-30388
81113354:	10800a8b 	ldhu	r2,42(r2)
81113358:	10bfffcc 	andi	r2,r2,65535
8111335c:	10800228 	cmpgeui	r2,r2,8
81113360:	1000041e 	bne	r2,zero,81113374 <vInitialTask+0x9c>
			printErrorTask( error_code );
81113364:	e0bffe03 	ldbu	r2,-8(fp)
81113368:	10803fcc 	andi	r2,r2,255
8111336c:	1009883a 	mov	r4,r2
81113370:	111cdc80 	call	8111cdc8 <printErrorTask>
		}
		#endif
			vCoudlNotCreateNFee0Task();
81113374:	111e7840 	call	8111e784 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81113378:	01c17704 	movi	r7,1500
8111337c:	000d883a 	mov	r6,zero
81113380:	000b883a 	mov	r5,zero
81113384:	0009883a 	mov	r4,zero
81113388:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
8111338c:	d8000415 	stw	zero,16(sp)
81113390:	d8000315 	stw	zero,12(sp)
81113394:	00810004 	movi	r2,1024
81113398:	d8800215 	stw	r2,8(sp)
8111339c:	00a045b4 	movhi	r2,33046
811133a0:	10a74104 	addi	r2,r2,-25340
811133a4:	d8800115 	stw	r2,4(sp)
811133a8:	00800284 	movi	r2,10
811133ac:	d8800015 	stw	r2,0(sp)
811133b0:	01c00284 	movi	r7,10
811133b4:	01a045b4 	movhi	r6,33046
811133b8:	31ab4004 	addi	r6,r6,-21248
811133bc:	016045b4 	movhi	r5,33046
811133c0:	296b4b04 	addi	r5,r5,-21204
811133c4:	01204474 	movhi	r4,33041
811133c8:	21385b04 	addi	r4,r4,-7828
811133cc:	11414c80 	call	811414c8 <OSTaskCreateExt>
811133d0:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811133d4:	e0bffe03 	ldbu	r2,-8(fp)
811133d8:	10803fcc 	andi	r2,r2,255
811133dc:	10000b26 	beq	r2,zero,8111340c <vInitialTask+0x134>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811133e0:	00a045f4 	movhi	r2,33047
811133e4:	10a25304 	addi	r2,r2,-30388
811133e8:	10800a8b 	ldhu	r2,42(r2)
811133ec:	10bfffcc 	andi	r2,r2,65535
811133f0:	10800228 	cmpgeui	r2,r2,8
811133f4:	1000041e 	bne	r2,zero,81113408 <vInitialTask+0x130>
			printErrorTask( error_code );
811133f8:	e0bffe03 	ldbu	r2,-8(fp)
811133fc:	10803fcc 	andi	r2,r2,255
81113400:	1009883a 	mov	r4,r2
81113404:	111cdc80 	call	8111cdc8 <printErrorTask>
		}
		#endif
			vCoudlNotCreateDataControllerTask();
81113408:	111eb040 	call	8111eb04 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8111340c:	01c17704 	movi	r7,1500
81113410:	000d883a 	mov	r6,zero
81113414:	000b883a 	mov	r5,zero
81113418:	0009883a 	mov	r4,zero
8111341c:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
81113420:	d8000415 	stw	zero,16(sp)
81113424:	d8000315 	stw	zero,12(sp)
81113428:	00810004 	movi	r2,1024
8111342c:	d8800215 	stw	r2,8(sp)
81113430:	00a045b4 	movhi	r2,33046
81113434:	10837904 	addi	r2,r2,3556
81113438:	d8800115 	stw	r2,4(sp)
8111343c:	00800244 	movi	r2,9
81113440:	d8800015 	stw	r2,0(sp)
81113444:	01c00244 	movi	r7,9
81113448:	01a045b4 	movhi	r6,33046
8111344c:	31877804 	addi	r6,r6,7648
81113450:	016045b4 	movhi	r5,33046
81113454:	296b5304 	addi	r5,r5,-21172
81113458:	01204474 	movhi	r4,33041
8111345c:	210e5904 	addi	r4,r4,14692
81113460:	11414c80 	call	811414c8 <OSTaskCreateExt>
81113464:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81113468:	e0bffe03 	ldbu	r2,-8(fp)
8111346c:	10803fcc 	andi	r2,r2,255
81113470:	10000b26 	beq	r2,zero,811134a0 <vInitialTask+0x1c8>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113474:	00a045f4 	movhi	r2,33047
81113478:	10a25304 	addi	r2,r2,-30388
8111347c:	10800a8b 	ldhu	r2,42(r2)
81113480:	10bfffcc 	andi	r2,r2,65535
81113484:	10800228 	cmpgeui	r2,r2,8
81113488:	1000041e 	bne	r2,zero,8111349c <vInitialTask+0x1c4>
			printErrorTask( error_code );
8111348c:	e0bffe03 	ldbu	r2,-8(fp)
81113490:	10803fcc 	andi	r2,r2,255
81113494:	1009883a 	mov	r4,r2
81113498:	111cdc80 	call	8111cdc8 <printErrorTask>
		}
		#endif
			vCoudlNotCreateNFeeControllerTask();
8111349c:	111ea840 	call	8111ea84 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
811134a0:	01c17704 	movi	r7,1500
811134a4:	000d883a 	mov	r6,zero
811134a8:	000b883a 	mov	r5,zero
811134ac:	0009883a 	mov	r4,zero
811134b0:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
811134b4:	d8000415 	stw	zero,16(sp)
811134b8:	d8000315 	stw	zero,12(sp)
811134bc:	00810004 	movi	r2,1024
811134c0:	d8800215 	stw	r2,8(sp)
811134c4:	00a045b4 	movhi	r2,33046
811134c8:	10959b04 	addi	r2,r2,22124
811134cc:	d8800115 	stw	r2,4(sp)
811134d0:	00800204 	movi	r2,8
811134d4:	d8800015 	stw	r2,0(sp)
811134d8:	01c00204 	movi	r7,8
811134dc:	01a045b4 	movhi	r6,33046
811134e0:	31999a04 	addi	r6,r6,26216
811134e4:	016045b4 	movhi	r5,33046
811134e8:	296b4104 	addi	r5,r5,-21244
811134ec:	01204474 	movhi	r4,33041
811134f0:	2118e504 	addi	r4,r4,25492
811134f4:	11414c80 	call	811414c8 <OSTaskCreateExt>
811134f8:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811134fc:	e0bffe03 	ldbu	r2,-8(fp)
81113500:	10803fcc 	andi	r2,r2,255
81113504:	10000b26 	beq	r2,zero,81113534 <vInitialTask+0x25c>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113508:	00a045f4 	movhi	r2,33047
8111350c:	10a25304 	addi	r2,r2,-30388
81113510:	10800a8b 	ldhu	r2,42(r2)
81113514:	10bfffcc 	andi	r2,r2,65535
81113518:	10800228 	cmpgeui	r2,r2,8
8111351c:	1000041e 	bne	r2,zero,81113530 <vInitialTask+0x258>
			printErrorTask( error_code );
81113520:	e0bffe03 	ldbu	r2,-8(fp)
81113524:	10803fcc 	andi	r2,r2,255
81113528:	1009883a 	mov	r4,r2
8111352c:	111cdc80 	call	8111cdc8 <printErrorTask>
		}
		#endif
			vCoudlNotCreateMebTask();
81113530:	111eb840 	call	8111eb84 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81113534:	01c17704 	movi	r7,1500
81113538:	000d883a 	mov	r6,zero
8111353c:	000b883a 	mov	r5,zero
81113540:	0009883a 	mov	r4,zero
81113544:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
81113548:	d8000415 	stw	zero,16(sp)
8111354c:	d8000315 	stw	zero,12(sp)
81113550:	00810004 	movi	r2,1024
81113554:	d8800215 	stw	r2,8(sp)
81113558:	00a045b4 	movhi	r2,33046
8111355c:	10a34104 	addi	r2,r2,-29436
81113560:	d8800115 	stw	r2,4(sp)
81113564:	00800784 	movi	r2,30
81113568:	d8800015 	stw	r2,0(sp)
8111356c:	01c00784 	movi	r7,30
81113570:	01a045b4 	movhi	r6,33046
81113574:	31a74004 	addi	r6,r6,-25344
81113578:	000b883a 	mov	r5,zero
8111357c:	012044b4 	movhi	r4,33042
81113580:	21206804 	addi	r4,r4,-32352
81113584:	11414c80 	call	811414c8 <OSTaskCreateExt>
81113588:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8111358c:	e0bffe03 	ldbu	r2,-8(fp)
81113590:	10803fcc 	andi	r2,r2,255
81113594:	10000b26 	beq	r2,zero,811135c4 <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113598:	00a045f4 	movhi	r2,33047
8111359c:	10a25304 	addi	r2,r2,-30388
811135a0:	10800a8b 	ldhu	r2,42(r2)
811135a4:	10bfffcc 	andi	r2,r2,65535
811135a8:	10800228 	cmpgeui	r2,r2,8
811135ac:	1000041e 	bne	r2,zero,811135c0 <vInitialTask+0x2e8>
			printErrorTask( error_code );
811135b0:	e0bffe03 	ldbu	r2,-8(fp)
811135b4:	10803fcc 	andi	r2,r2,255
811135b8:	1009883a 	mov	r4,r2
811135bc:	111cdc80 	call	8111cdc8 <printErrorTask>
		}
		#endif
		vFailTimeoutCheckerTaskCreate();
811135c0:	111df700 	call	8111df70 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
811135c4:	01c03204 	movi	r7,200
811135c8:	000d883a 	mov	r6,zero
811135cc:	000b883a 	mov	r5,zero
811135d0:	0009883a 	mov	r4,zero
811135d4:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
811135d8:	d8000415 	stw	zero,16(sp)
811135dc:	d8000315 	stw	zero,12(sp)
811135e0:	00810004 	movi	r2,1024
811135e4:	d8800215 	stw	r2,8(sp)
811135e8:	00a045b4 	movhi	r2,33046
811135ec:	10b65904 	addi	r2,r2,-9884
811135f0:	d8800115 	stw	r2,4(sp)
811135f4:	008006c4 	movi	r2,27
811135f8:	d8800015 	stw	r2,0(sp)
811135fc:	01c006c4 	movi	r7,27
81113600:	01a045b4 	movhi	r6,33046
81113604:	31ba5804 	addi	r6,r6,-5792
81113608:	000b883a 	mov	r5,zero
8111360c:	01204474 	movhi	r4,33041
81113610:	21106c04 	addi	r4,r4,16816
81113614:	11414c80 	call	811414c8 <OSTaskCreateExt>
81113618:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8111361c:	e0bffe03 	ldbu	r2,-8(fp)
81113620:	10803fcc 	andi	r2,r2,255
81113624:	10000b26 	beq	r2,zero,81113654 <vInitialTask+0x37c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113628:	00a045f4 	movhi	r2,33047
8111362c:	10a25304 	addi	r2,r2,-30388
81113630:	10800a8b 	ldhu	r2,42(r2)
81113634:	10bfffcc 	andi	r2,r2,65535
81113638:	10800228 	cmpgeui	r2,r2,8
8111363c:	1000041e 	bne	r2,zero,81113650 <vInitialTask+0x378>
			printErrorTask( error_code );
81113640:	e0bffe03 	ldbu	r2,-8(fp)
81113644:	10803fcc 	andi	r2,r2,255
81113648:	1009883a 	mov	r4,r2
8111364c:	111cdc80 	call	8111cdc8 <printErrorTask>
		}
		#endif
		vFailOutAckHandlerTaskCreate();
81113650:	111de440 	call	8111de44 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81113654:	01c03204 	movi	r7,200
81113658:	000d883a 	mov	r6,zero
8111365c:	000b883a 	mov	r5,zero
81113660:	0009883a 	mov	r4,zero
81113664:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
81113668:	d8000415 	stw	zero,16(sp)
8111366c:	d8000315 	stw	zero,12(sp)
81113670:	00810004 	movi	r2,1024
81113674:	d8800215 	stw	r2,8(sp)
81113678:	00a04574 	movhi	r2,33045
8111367c:	109a3304 	addi	r2,r2,26828
81113680:	d8800115 	stw	r2,4(sp)
81113684:	00800644 	movi	r2,25
81113688:	d8800015 	stw	r2,0(sp)
8111368c:	01c00644 	movi	r7,25
81113690:	01a04574 	movhi	r6,33045
81113694:	319e3204 	addi	r6,r6,30920
81113698:	000b883a 	mov	r5,zero
8111369c:	01204474 	movhi	r4,33041
811136a0:	210ade04 	addi	r4,r4,11128
811136a4:	11414c80 	call	811414c8 <OSTaskCreateExt>
811136a8:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811136ac:	e0bffe03 	ldbu	r2,-8(fp)
811136b0:	10803fcc 	andi	r2,r2,255
811136b4:	10000b26 	beq	r2,zero,811136e4 <vInitialTask+0x40c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811136b8:	00a045f4 	movhi	r2,33047
811136bc:	10a25304 	addi	r2,r2,-30388
811136c0:	10800a8b 	ldhu	r2,42(r2)
811136c4:	10bfffcc 	andi	r2,r2,65535
811136c8:	10800228 	cmpgeui	r2,r2,8
811136cc:	1000041e 	bne	r2,zero,811136e0 <vInitialTask+0x408>
			printErrorTask( error_code );
811136d0:	e0bffe03 	ldbu	r2,-8(fp)
811136d4:	10803fcc 	andi	r2,r2,255
811136d8:	1009883a 	mov	r4,r2
811136dc:	111cdc80 	call	8111cdc8 <printErrorTask>
		}
		#endif
		vFailInAckHandlerTaskCreate();
811136e0:	111dde00 	call	8111dde0 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
811136e4:	01c03204 	movi	r7,200
811136e8:	000d883a 	mov	r6,zero
811136ec:	000b883a 	mov	r5,zero
811136f0:	0009883a 	mov	r4,zero
811136f4:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
811136f8:	d8000415 	stw	zero,16(sp)
811136fc:	d8000315 	stw	zero,12(sp)
81113700:	00818004 	movi	r2,1536
81113704:	d8800215 	stw	r2,8(sp)
81113708:	00a045b4 	movhi	r2,33046
8111370c:	108f9704 	addi	r2,r2,15964
81113710:	d8800115 	stw	r2,4(sp)
81113714:	00800704 	movi	r2,28
81113718:	d8800015 	stw	r2,0(sp)
8111371c:	01c00704 	movi	r7,28
81113720:	01a045b4 	movhi	r6,33046
81113724:	31959604 	addi	r6,r6,22104
81113728:	000b883a 	mov	r5,zero
8111372c:	01204474 	movhi	r4,33041
81113730:	21113604 	addi	r4,r4,17624
81113734:	11414c80 	call	811414c8 <OSTaskCreateExt>
81113738:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8111373c:	e0bffe03 	ldbu	r2,-8(fp)
81113740:	10803fcc 	andi	r2,r2,255
81113744:	10000b26 	beq	r2,zero,81113774 <vInitialTask+0x49c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113748:	00a045f4 	movhi	r2,33047
8111374c:	10a25304 	addi	r2,r2,-30388
81113750:	10800a8b 	ldhu	r2,42(r2)
81113754:	10bfffcc 	andi	r2,r2,65535
81113758:	10800228 	cmpgeui	r2,r2,8
8111375c:	1000041e 	bne	r2,zero,81113770 <vInitialTask+0x498>
			printErrorTask( error_code );
81113760:	e0bffe03 	ldbu	r2,-8(fp)
81113764:	10803fcc 	andi	r2,r2,255
81113768:	1009883a 	mov	r4,r2
8111376c:	111cdc80 	call	8111cdc8 <printErrorTask>
		}
		#endif
		vFailParserCommTaskCreate();
81113770:	111dd7c0 	call	8111dd7c <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81113774:	01c03204 	movi	r7,200
81113778:	000d883a 	mov	r6,zero
8111377c:	000b883a 	mov	r5,zero
81113780:	0009883a 	mov	r4,zero
81113784:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
81113788:	d8000415 	stw	zero,16(sp)
8111378c:	d8000315 	stw	zero,12(sp)
81113790:	00818004 	movi	r2,1536
81113794:	d8800215 	stw	r2,8(sp)
81113798:	00a045b4 	movhi	r2,33046
8111379c:	10b04904 	addi	r2,r2,-16092
811137a0:	d8800115 	stw	r2,4(sp)
811137a4:	00800804 	movi	r2,32
811137a8:	d8800015 	stw	r2,0(sp)
811137ac:	01c00804 	movi	r7,32
811137b0:	01a045b4 	movhi	r6,33046
811137b4:	31b64804 	addi	r6,r6,-9952
811137b8:	000b883a 	mov	r5,zero
811137bc:	01204474 	movhi	r4,33041
811137c0:	2115c604 	addi	r4,r4,22296
811137c4:	11414c80 	call	811414c8 <OSTaskCreateExt>
811137c8:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811137cc:	e0bffe03 	ldbu	r2,-8(fp)
811137d0:	10803fcc 	andi	r2,r2,255
811137d4:	10000b26 	beq	r2,zero,81113804 <vInitialTask+0x52c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811137d8:	00a045f4 	movhi	r2,33047
811137dc:	10a25304 	addi	r2,r2,-30388
811137e0:	10800a8b 	ldhu	r2,42(r2)
811137e4:	10bfffcc 	andi	r2,r2,65535
811137e8:	10800228 	cmpgeui	r2,r2,8
811137ec:	1000041e 	bne	r2,zero,81113800 <vInitialTask+0x528>
			printErrorTask( error_code );
811137f0:	e0bffe03 	ldbu	r2,-8(fp)
811137f4:	10803fcc 	andi	r2,r2,255
811137f8:	1009883a 	mov	r4,r2
811137fc:	111cdc80 	call	8111cdc8 <printErrorTask>
		}
		#endif
		vFailReceiverCreate();
81113800:	111d4d00 	call	8111d4d0 <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81113804:	01c03204 	movi	r7,200
81113808:	000d883a 	mov	r6,zero
8111380c:	000b883a 	mov	r5,zero
81113810:	0009883a 	mov	r4,zero
81113814:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
81113818:	d8000415 	stw	zero,16(sp)
8111381c:	d8000315 	stw	zero,12(sp)
81113820:	00810004 	movi	r2,1024
81113824:	d8800215 	stw	r2,8(sp)
81113828:	00a04574 	movhi	r2,33045
8111382c:	109f2f04 	addi	r2,r2,31932
81113830:	d8800115 	stw	r2,4(sp)
81113834:	00800684 	movi	r2,26
81113838:	d8800015 	stw	r2,0(sp)
8111383c:	01c00684 	movi	r7,26
81113840:	01a045b4 	movhi	r6,33046
81113844:	31a32e04 	addi	r6,r6,-29512
81113848:	000b883a 	mov	r5,zero
8111384c:	01204474 	movhi	r4,33041
81113850:	21186104 	addi	r4,r4,24964
81113854:	11414c80 	call	811414c8 <OSTaskCreateExt>
81113858:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
8111385c:	01c03204 	movi	r7,200
81113860:	000d883a 	mov	r6,zero
81113864:	000b883a 	mov	r5,zero
81113868:	0009883a 	mov	r4,zero
8111386c:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
81113870:	e0bffe03 	ldbu	r2,-8(fp)
81113874:	10803fcc 	andi	r2,r2,255
81113878:	10000b26 	beq	r2,zero,811138a8 <vInitialTask+0x5d0>
		/* Can't create Task for sender comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111387c:	00a045f4 	movhi	r2,33047
81113880:	10a25304 	addi	r2,r2,-30388
81113884:	10800a8b 	ldhu	r2,42(r2)
81113888:	10bfffcc 	andi	r2,r2,65535
8111388c:	10800228 	cmpgeui	r2,r2,8
81113890:	1000041e 	bne	r2,zero,811138a4 <vInitialTask+0x5cc>
			printErrorTask( error_code );
81113894:	e0bffe03 	ldbu	r2,-8(fp)
81113898:	10803fcc 	andi	r2,r2,255
8111389c:	1009883a 	mov	r4,r2
811138a0:	111cdc80 	call	8111cdc8 <printErrorTask>
		}
		#endif
		vFailSenderCreate();
811138a4:	111d5340 	call	8111d534 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
811138a8:	d0a06d17 	ldw	r2,-32332(gp)
811138ac:	e17ffe04 	addi	r5,fp,-8
811138b0:	1009883a 	mov	r4,r2
811138b4:	11431e80 	call	811431e8 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
811138b8:	e0bffe03 	ldbu	r2,-8(fp)
811138bc:	10803fcc 	andi	r2,r2,255
811138c0:	10000126 	beq	r2,zero,811138c8 <vInitialTask+0x5f0>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
811138c4:	111e2d40 	call	8111e2d4 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
811138c8:	01c00084 	movi	r7,2
811138cc:	01800784 	movi	r6,30
811138d0:	000b883a 	mov	r5,zero
811138d4:	0009883a 	mov	r4,zero
811138d8:	11426f40 	call	811426f4 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
811138dc:	01003fc4 	movi	r4,255
811138e0:	11416b40 	call	811416b4 <OSTaskDel>
811138e4:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
811138e8:	e0bffe03 	ldbu	r2,-8(fp)
811138ec:	10803fcc 	andi	r2,r2,255
811138f0:	10001626 	beq	r2,zero,8111394c <vInitialTask+0x674>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811138f4:	00a045f4 	movhi	r2,33047
811138f8:	10a25304 	addi	r2,r2,-30388
811138fc:	10800a8b 	ldhu	r2,42(r2)
81113900:	10bfffcc 	andi	r2,r2,65535
81113904:	10800228 	cmpgeui	r2,r2,8
81113908:	1000041e 	bne	r2,zero,8111391c <vInitialTask+0x644>
			printErrorTask( error_code );		
8111390c:	e0bffe03 	ldbu	r2,-8(fp)
81113910:	10803fcc 	andi	r2,r2,255
81113914:	1009883a 	mov	r4,r2
81113918:	111cdc80 	call	8111cdc8 <printErrorTask>
		}
		#endif
		vFailDeleteInitialization();
8111391c:	111d5980 	call	8111d598 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
81113920:	014009c4 	movi	r5,39
81113924:	01000044 	movi	r4,1
81113928:	1140e1c0 	call	81140e1c <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
8111392c:	01003fc4 	movi	r4,255
81113930:	11416b40 	call	811416b4 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
81113934:	000f883a 	mov	r7,zero
81113938:	01800284 	movi	r6,10
8111393c:	000b883a 	mov	r5,zero
81113940:	0009883a 	mov	r4,zero
81113944:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
		}
81113948:	003ff806 	br	8111392c <__reset+0xfb0f392c>
	}

}
8111394c:	0001883a 	nop
81113950:	e037883a 	mov	sp,fp
81113954:	dfc00117 	ldw	ra,4(sp)
81113958:	df000017 	ldw	fp,0(sp)
8111395c:	dec00204 	addi	sp,sp,8
81113960:	f800283a 	ret

81113964 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
81113964:	defff704 	addi	sp,sp,-36
81113968:	de00012e 	bgeu	sp,et,81113970 <vNFeeControlTask+0xc>
8111396c:	003b68fa 	trap	3
81113970:	dfc00815 	stw	ra,32(sp)
81113974:	df000715 	stw	fp,28(sp)
81113978:	df000704 	addi	fp,sp,28
8111397c:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	static unsigned char ucWhoGetDMA;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
81113980:	e0bfff17 	ldw	r2,-4(fp)
81113984:	e0bffa15 	stw	r2,-24(fp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81113988:	00a045f4 	movhi	r2,33047
8111398c:	10a25304 	addi	r2,r2,-30388
81113990:	10800a8b 	ldhu	r2,42(r2)
81113994:	10bfffcc 	andi	r2,r2,65535
81113998:	10800168 	cmpgeui	r2,r2,5
8111399c:	1000071e 	bne	r2,zero,811139bc <vNFeeControlTask+0x58>
        debug(fp,"NFee Controller Task. (Task on)\n");
811139a0:	d0a06217 	ldw	r2,-32376(gp)
811139a4:	100f883a 	mov	r7,r2
811139a8:	01800804 	movi	r6,32
811139ac:	01400044 	movi	r5,1
811139b0:	01204574 	movhi	r4,33045
811139b4:	213cd004 	addi	r4,r4,-3264
811139b8:	112393c0 	call	8112393c <fwrite>
	}
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
811139bc:	e0bffa17 	ldw	r2,-24(fp)
811139c0:	10809c17 	ldw	r2,624(r2)
811139c4:	10c00168 	cmpgeui	r3,r2,5
811139c8:	1800e71e 	bne	r3,zero,81113d68 <vNFeeControlTask+0x404>
811139cc:	100690ba 	slli	r3,r2,2
811139d0:	00a04474 	movhi	r2,33041
811139d4:	108e7904 	addi	r2,r2,14820
811139d8:	1885883a 	add	r2,r3,r2
811139dc:	10800017 	ldw	r2,0(r2)
811139e0:	1000683a 	jmp	r2
811139e4:	811139f8 	rdprs	r4,r16,17639
811139e8:	81113a28 	cmpgeui	r4,r16,17640
811139ec:	81113aa0 	cmpeqi	r4,r16,17642
811139f0:	81113b6c 	andhi	r4,r16,17645
811139f4:	81113bcc 	andi	r4,r16,17647
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
811139f8:	d0a07017 	ldw	r2,-32320(gp)
811139fc:	1009883a 	mov	r4,r2
81113a00:	113f7a40 	call	8113f7a4 <OSQFlush>
81113a04:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81113a08:	e0bffe03 	ldbu	r2,-8(fp)
81113a0c:	10803fcc 	andi	r2,r2,255
81113a10:	10000126 	beq	r2,zero,81113a18 <vNFeeControlTask+0xb4>
					vFailFlushQueue();
81113a14:	111f3780 	call	8111f378 <vFailFlushQueue>
				}

				pxFeeC->sMode = sMebToConfig;
81113a18:	e0bffa17 	ldw	r2,-24(fp)
81113a1c:	00c00044 	movi	r3,1
81113a20:	10c09c15 	stw	r3,624(r2)
				break;
81113a24:	0000e206 	br	81113db0 <vNFeeControlTask+0x44c>


			case sMebToConfig:
				/* Transition state */
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81113a28:	00a045f4 	movhi	r2,33047
81113a2c:	10a25304 	addi	r2,r2,-30388
81113a30:	10800a8b 	ldhu	r2,42(r2)
81113a34:	10bfffcc 	andi	r2,r2,65535
81113a38:	108000e8 	cmpgeui	r2,r2,3
81113a3c:	1000071e 	bne	r2,zero,81113a5c <vNFeeControlTask+0xf8>
					debug(fp,"NFEE Controller Task: Config Mode\n");
81113a40:	d0a06217 	ldw	r2,-32376(gp)
81113a44:	100f883a 	mov	r7,r2
81113a48:	01800884 	movi	r6,34
81113a4c:	01400044 	movi	r5,1
81113a50:	01204574 	movhi	r4,33045
81113a54:	213cd904 	addi	r4,r4,-3228
81113a58:	112393c0 	call	8112393c <fwrite>
				}
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81113a5c:	d0a05d17 	ldw	r2,-32396(gp)
81113a60:	1009883a 	mov	r4,r2
81113a64:	113f7a40 	call	8113f7a4 <OSQFlush>
81113a68:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81113a6c:	e0bffe03 	ldbu	r2,-8(fp)
81113a70:	10803fcc 	andi	r2,r2,255
81113a74:	10000126 	beq	r2,zero,81113a7c <vNFeeControlTask+0x118>
					vFailFlushQueue();
81113a78:	111f3780 	call	8111f378 <vFailFlushQueue>
				}

				bCmdSent = FALSE;
81113a7c:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
81113a80:	00800044 	movi	r2,1
81113a84:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
81113a88:	00bfffc4 	movi	r2,-1
81113a8c:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebConfig;
81113a90:	e0bffa17 	ldw	r2,-24(fp)
81113a94:	00c000c4 	movi	r3,3
81113a98:	10c09c15 	stw	r3,624(r2)
				break;
81113a9c:	0000c406 	br	81113db0 <vNFeeControlTask+0x44c>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
81113aa0:	111f5300 	call	8111f530 <vEvtChangeFeeControllerMode>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81113aa4:	00a045f4 	movhi	r2,33047
81113aa8:	10a25304 	addi	r2,r2,-30388
81113aac:	10800a8b 	ldhu	r2,42(r2)
81113ab0:	10bfffcc 	andi	r2,r2,65535
81113ab4:	108000e8 	cmpgeui	r2,r2,3
81113ab8:	1000071e 	bne	r2,zero,81113ad8 <vNFeeControlTask+0x174>
					debug(fp,"NFEE Controller Task: RUN Mode\n");
81113abc:	d0a06217 	ldw	r2,-32376(gp)
81113ac0:	100f883a 	mov	r7,r2
81113ac4:	018007c4 	movi	r6,31
81113ac8:	01400044 	movi	r5,1
81113acc:	01204574 	movhi	r4,33045
81113ad0:	213ce204 	addi	r4,r4,-3192
81113ad4:	112393c0 	call	8112393c <fwrite>
				}
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81113ad8:	d0a05d17 	ldw	r2,-32396(gp)
81113adc:	1009883a 	mov	r4,r2
81113ae0:	113f7a40 	call	8113f7a4 <OSQFlush>
81113ae4:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81113ae8:	e0bffe03 	ldbu	r2,-8(fp)
81113aec:	10803fcc 	andi	r2,r2,255
81113af0:	10000126 	beq	r2,zero,81113af8 <vNFeeControlTask+0x194>
					vFailFlushQueue();
81113af4:	111f3780 	call	8111f378 <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
81113af8:	e03ff905 	stb	zero,-28(fp)
81113afc:	00001006 	br	81113b40 <vNFeeControlTask+0x1dc>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
81113b00:	e0bff903 	ldbu	r2,-28(fp)
81113b04:	1085883a 	add	r2,r2,r2
81113b08:	1087883a 	add	r3,r2,r2
81113b0c:	d0a06a04 	addi	r2,gp,-32344
81113b10:	1885883a 	add	r2,r3,r2
81113b14:	10800017 	ldw	r2,0(r2)
81113b18:	1009883a 	mov	r4,r2
81113b1c:	113f7a40 	call	8113f7a4 <OSQFlush>
81113b20:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
81113b24:	e0bffe03 	ldbu	r2,-8(fp)
81113b28:	10803fcc 	andi	r2,r2,255
81113b2c:	10000126 	beq	r2,zero,81113b34 <vNFeeControlTask+0x1d0>
						vFailFlushQueue();
81113b30:	111f3780 	call	8111f378 <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
81113b34:	e0bff903 	ldbu	r2,-28(fp)
81113b38:	10800044 	addi	r2,r2,1
81113b3c:	e0bff905 	stb	r2,-28(fp)
81113b40:	e0bff903 	ldbu	r2,-28(fp)
81113b44:	103fee26 	beq	r2,zero,81113b00 <__reset+0xfb0f3b00>
					if ( error_codeCtrl != OS_NO_ERR ) {
						vFailFlushQueue();
					}
				}

				bCmdSent = FALSE;
81113b48:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
81113b4c:	00800044 	movi	r2,1
81113b50:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
81113b54:	00bfffc4 	movi	r2,-1
81113b58:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebRun;
81113b5c:	e0bffa17 	ldw	r2,-24(fp)
81113b60:	00c00104 	movi	r3,4
81113b64:	10c09c15 	stw	r3,624(r2)
				break;
81113b68:	00009106 	br	81113db0 <vNFeeControlTask+0x44c>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
81113b6c:	d0a07017 	ldw	r2,-32320(gp)
81113b70:	e0fffe04 	addi	r3,fp,-8
81113b74:	180d883a 	mov	r6,r3
81113b78:	000b883a 	mov	r5,zero
81113b7c:	1009883a 	mov	r4,r2
81113b80:	113f8640 	call	8113f864 <OSQPend>
81113b84:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
81113b88:	e0bffe03 	ldbu	r2,-8(fp)
81113b8c:	10803fcc 	andi	r2,r2,255
81113b90:	10000c1e 	bne	r2,zero,81113bc4 <vNFeeControlTask+0x260>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81113b94:	e0bffdc3 	ldbu	r2,-9(fp)
81113b98:	10803fcc 	andi	r2,r2,255
81113b9c:	10800418 	cmpnei	r2,r2,16
81113ba0:	1000041e 	bne	r2,zero,81113bb4 <vNFeeControlTask+0x250>
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
81113ba4:	e0bffd17 	ldw	r2,-12(fp)
81113ba8:	e17ffa17 	ldw	r5,-24(fp)
81113bac:	1009883a 	mov	r4,r2
81113bb0:	1113db40 	call	81113db4 <vPerformActionNFCConfig>
					}
					bCmdSent = FALSE;
81113bb4:	e03ffb15 	stw	zero,-20(fp)
					bDmaBack = TRUE;
81113bb8:	00800044 	movi	r2,1
81113bbc:	d0a05815 	stw	r2,-32416(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
81113bc0:	00007b06 	br	81113db0 <vNFeeControlTask+0x44c>
					}
					bCmdSent = FALSE;
					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
81113bc4:	111eec40 	call	8111eec4 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
81113bc8:	00007906 	br	81113db0 <vNFeeControlTask+0x44c>
				/* 	We have 2 importantes Queues here.  
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fast way and
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				
				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
81113bcc:	d0a05817 	ldw	r2,-32416(gp)
81113bd0:	10800058 	cmpnei	r2,r2,1
81113bd4:	1000221e 	bne	r2,zero,81113c60 <vNFeeControlTask+0x2fc>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
81113bd8:	d0a05d17 	ldw	r2,-32396(gp)
81113bdc:	e0fffe04 	addi	r3,fp,-8
81113be0:	180d883a 	mov	r6,r3
81113be4:	01400104 	movi	r5,4
81113be8:	1009883a 	mov	r4,r2
81113bec:	113f8640 	call	8113f864 <OSQPend>
81113bf0:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
81113bf4:	e0bffe03 	ldbu	r2,-8(fp)
81113bf8:	10803fcc 	andi	r2,r2,255
81113bfc:	1000181e 	bne	r2,zero,81113c60 <vNFeeControlTask+0x2fc>
						ucFeeInstL = uiCmdNFC.ucByte[0];
81113c00:	e0bffd03 	ldbu	r2,-12(fp)
81113c04:	e0bffc05 	stb	r2,-16(fp)

						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
81113c08:	e0bffc03 	ldbu	r2,-16(fp)
81113c0c:	e0fffa17 	ldw	r3,-24(fp)
81113c10:	10809824 	muli	r2,r2,608
81113c14:	1885883a 	add	r2,r3,r2
81113c18:	10802304 	addi	r2,r2,140
81113c1c:	10800017 	ldw	r2,0(r2)
81113c20:	10800058 	cmpnei	r2,r2,1
81113c24:	10000e1e 	bne	r2,zero,81113c60 <vNFeeControlTask+0x2fc>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
81113c28:	e0bffc03 	ldbu	r2,-16(fp)
81113c2c:	e0fffc03 	ldbu	r3,-16(fp)
81113c30:	180f883a 	mov	r7,r3
81113c34:	000d883a 	mov	r6,zero
81113c38:	014023c4 	movi	r5,143
81113c3c:	1009883a 	mov	r4,r2
81113c40:	11140200 	call	81114020 <bSendCmdQToNFeeInst>
81113c44:	e0bffb15 	stw	r2,-20(fp)
							if ( bCmdSent == TRUE ) {
81113c48:	e0bffb17 	ldw	r2,-20(fp)
81113c4c:	10800058 	cmpnei	r2,r2,1
81113c50:	1000031e 	bne	r2,zero,81113c60 <vNFeeControlTask+0x2fc>
								bDmaBack = FALSE;
81113c54:	d0205815 	stw	zero,-32416(gp)
								ucWhoGetDMA = ucFeeInstL;
81113c58:	e0bffc03 	ldbu	r2,-16(fp)
81113c5c:	d0a05905 	stb	r2,-32412(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
81113c60:	d0a05817 	ldw	r2,-32416(gp)
81113c64:	1000081e 	bne	r2,zero,81113c88 <vNFeeControlTask+0x324>
					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
81113c68:	d0a07017 	ldw	r2,-32320(gp)
81113c6c:	e0fffe04 	addi	r3,fp,-8
81113c70:	180d883a 	mov	r6,r3
81113c74:	000b883a 	mov	r5,zero
81113c78:	1009883a 	mov	r4,r2
81113c7c:	113f8640 	call	8113f864 <OSQPend>
81113c80:	e0bffd15 	stw	r2,-12(fp)
81113c84:	00000706 	br	81113ca4 <vNFeeControlTask+0x340>
				} else {
					/* If No FEE has the DMA */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
81113c88:	d0a07017 	ldw	r2,-32320(gp)
81113c8c:	e0fffe04 	addi	r3,fp,-8
81113c90:	180d883a 	mov	r6,r3
81113c94:	01400104 	movi	r5,4
81113c98:	1009883a 	mov	r4,r2
81113c9c:	113f8640 	call	8113f864 <OSQPend>
81113ca0:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
81113ca4:	e0bffe03 	ldbu	r2,-8(fp)
81113ca8:	10803fcc 	andi	r2,r2,255
81113cac:	10003f1e 	bne	r2,zero,81113dac <vNFeeControlTask+0x448>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
81113cb0:	e0bffd83 	ldbu	r2,-10(fp)
81113cb4:	10803fcc 	andi	r2,r2,255
81113cb8:	10802058 	cmpnei	r2,r2,129
81113cbc:	10000a1e 	bne	r2,zero,81113ce8 <vNFeeControlTask+0x384>
						if ( uiCmdNFC.ucByte[0] == ucWhoGetDMA ){
81113cc0:	e0fffd03 	ldbu	r3,-12(fp)
81113cc4:	d0a05903 	ldbu	r2,-32412(gp)
81113cc8:	18c03fcc 	andi	r3,r3,255
81113ccc:	10803fcc 	andi	r2,r2,255
81113cd0:	1880361e 	bne	r3,r2,81113dac <vNFeeControlTask+0x448>
							bDmaBack = TRUE;
81113cd4:	00800044 	movi	r2,1
81113cd8:	d0a05815 	stw	r2,-32416(gp)
							ucFeeInstL = 255;
81113cdc:	00bfffc4 	movi	r2,-1
81113ce0:	e0bffc05 	stb	r2,-16(fp)
							}
						}
					}
				}
				
				break;		
81113ce4:	00003106 	br	81113dac <vNFeeControlTask+0x448>
						}

					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81113ce8:	e0bffdc3 	ldbu	r2,-9(fp)
81113cec:	10803fcc 	andi	r2,r2,255
81113cf0:	10800418 	cmpnei	r2,r2,16
81113cf4:	1000051e 	bne	r2,zero,81113d0c <vNFeeControlTask+0x3a8>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
81113cf8:	e0bffd17 	ldw	r2,-12(fp)
81113cfc:	e17ffa17 	ldw	r5,-24(fp)
81113d00:	1009883a 	mov	r4,r2
81113d04:	1113eb80 	call	81113eb8 <vPerformActionNFCRunning>
							}
						}
					}
				}
				
				break;		
81113d08:	00002806 	br	81113dac <vNFeeControlTask+0x448>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
81113d0c:	e0bffdc3 	ldbu	r2,-9(fp)
81113d10:	10803fcc 	andi	r2,r2,255
81113d14:	10800470 	cmpltui	r2,r2,17
81113d18:	1000241e 	bne	r2,zero,81113dac <vNFeeControlTask+0x448>
81113d1c:	e0bffdc3 	ldbu	r2,-9(fp)
81113d20:	10803fcc 	andi	r2,r2,255
81113d24:	108004e8 	cmpgeui	r2,r2,19
81113d28:	1000201e 	bne	r2,zero,81113dac <vNFeeControlTask+0x448>
								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
81113d2c:	e0bffdc3 	ldbu	r2,-9(fp)
81113d30:	10bffbc4 	addi	r2,r2,-17
81113d34:	10803fcc 	andi	r2,r2,255
81113d38:	e0fffd83 	ldbu	r3,-10(fp)
81113d3c:	18c03fcc 	andi	r3,r3,255
81113d40:	e13ffd43 	ldbu	r4,-11(fp)
81113d44:	21003fcc 	andi	r4,r4,255
81113d48:	e17ffd03 	ldbu	r5,-12(fp)
81113d4c:	29403fcc 	andi	r5,r5,255
81113d50:	280f883a 	mov	r7,r5
81113d54:	200d883a 	mov	r6,r4
81113d58:	180b883a 	mov	r5,r3
81113d5c:	1009883a 	mov	r4,r2
81113d60:	11140200 	call	81114020 <bSendCmdQToNFeeInst>
							}
						}
					}
				}
				
				break;		
81113d64:	00001106 	br	81113dac <vNFeeControlTask+0x448>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113d68:	00a045f4 	movhi	r2,33047
81113d6c:	10a25304 	addi	r2,r2,-30388
81113d70:	10800a8b 	ldhu	r2,42(r2)
81113d74:	10bfffcc 	andi	r2,r2,65535
81113d78:	10800228 	cmpgeui	r2,r2,8
81113d7c:	1000071e 	bne	r2,zero,81113d9c <vNFeeControlTask+0x438>
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
81113d80:	d0a06217 	ldw	r2,-32376(gp)
81113d84:	100f883a 	mov	r7,r2
81113d88:	01800f44 	movi	r6,61
81113d8c:	01400044 	movi	r5,1
81113d90:	01204574 	movhi	r4,33045
81113d94:	213cea04 	addi	r4,r4,-3160
81113d98:	112393c0 	call	8112393c <fwrite>
				}
				#endif
				
				pxFeeC->sMode = sMebConfig;
81113d9c:	e0bffa17 	ldw	r2,-24(fp)
81113da0:	00c000c4 	movi	r3,3
81113da4:	10c09c15 	stw	r3,624(r2)
				break;
81113da8:	00000106 	br	81113db0 <vNFeeControlTask+0x44c>
							}
						}
					}
				}
				
				break;		
81113dac:	0001883a 	nop
				#endif
				
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
81113db0:	003f0206 	br	811139bc <__reset+0xfb0f39bc>

81113db4 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81113db4:	defffb04 	addi	sp,sp,-20
81113db8:	de00012e 	bgeu	sp,et,81113dc0 <vPerformActionNFCConfig+0xc>
81113dbc:	003b68fa 	trap	3
81113dc0:	dfc00415 	stw	ra,16(sp)
81113dc4:	df000315 	stw	fp,12(sp)
81113dc8:	df000304 	addi	fp,sp,12
81113dcc:	e13ffe15 	stw	r4,-8(fp)
81113dd0:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;

	uiCmdLocal.ulWord = uiCmdParam;
81113dd4:	e0bffe17 	ldw	r2,-8(fp)
81113dd8:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81113ddc:	e0bffd83 	ldbu	r2,-10(fp)
81113de0:	10803fcc 	andi	r2,r2,255
81113de4:	10c000a0 	cmpeqi	r3,r2,2
81113de8:	1800181e 	bne	r3,zero,81113e4c <vPerformActionNFCConfig+0x98>
81113dec:	10c000c8 	cmpgei	r3,r2,3
81113df0:	1800031e 	bne	r3,zero,81113e00 <vPerformActionNFCConfig+0x4c>
81113df4:	10800060 	cmpeqi	r2,r2,1
81113df8:	1000061e 	bne	r2,zero,81113e14 <vPerformActionNFCConfig+0x60>
81113dfc:	00001706 	br	81113e5c <vPerformActionNFCConfig+0xa8>
81113e00:	10c02860 	cmpeqi	r3,r2,161
81113e04:	1800031e 	bne	r3,zero,81113e14 <vPerformActionNFCConfig+0x60>
81113e08:	108028a0 	cmpeqi	r2,r2,162
81113e0c:	10000f1e 	bne	r2,zero,81113e4c <vPerformActionNFCConfig+0x98>
81113e10:	00001206 	br	81113e5c <vPerformActionNFCConfig+0xa8>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81113e14:	00a045f4 	movhi	r2,33047
81113e18:	10a25304 	addi	r2,r2,-30388
81113e1c:	10800a8b 	ldhu	r2,42(r2)
81113e20:	10bfffcc 	andi	r2,r2,65535
81113e24:	108000e8 	cmpgeui	r2,r2,3
81113e28:	10001a1e 	bne	r2,zero,81113e94 <vPerformActionNFCConfig+0xe0>
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
81113e2c:	d0a06217 	ldw	r2,-32376(gp)
81113e30:	100f883a 	mov	r7,r2
81113e34:	01800d44 	movi	r6,53
81113e38:	01400044 	movi	r5,1
81113e3c:	01204574 	movhi	r4,33045
81113e40:	213cfa04 	addi	r4,r4,-3096
81113e44:	112393c0 	call	8112393c <fwrite>
			}
			#endif
			/* Do nothing for now */
			break;
81113e48:	00001206 	br	81113e94 <vPerformActionNFCConfig+0xe0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
81113e4c:	e0bfff17 	ldw	r2,-4(fp)
81113e50:	00c00084 	movi	r3,2
81113e54:	10c09c15 	stw	r3,624(r2)
			break;
81113e58:	00001106 	br	81113ea0 <vPerformActionNFCConfig+0xec>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:

		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113e5c:	00a045f4 	movhi	r2,33047
81113e60:	10a25304 	addi	r2,r2,-30388
81113e64:	10800a8b 	ldhu	r2,42(r2)
81113e68:	10bfffcc 	andi	r2,r2,65535
81113e6c:	10800228 	cmpgeui	r2,r2,8
81113e70:	10000a1e 	bne	r2,zero,81113e9c <vPerformActionNFCConfig+0xe8>
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
81113e74:	d0a06217 	ldw	r2,-32376(gp)
81113e78:	100f883a 	mov	r7,r2
81113e7c:	018009c4 	movi	r6,39
81113e80:	01400044 	movi	r5,1
81113e84:	01204574 	movhi	r4,33045
81113e88:	213d0804 	addi	r4,r4,-3040
81113e8c:	112393c0 	call	8112393c <fwrite>
			}
			#endif	
			break;
81113e90:	00000206 	br	81113e9c <vPerformActionNFCConfig+0xe8>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
			}
			#endif
			/* Do nothing for now */
			break;
81113e94:	0001883a 	nop
81113e98:	00000106 	br	81113ea0 <vPerformActionNFCConfig+0xec>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
81113e9c:	0001883a 	nop
	}

}
81113ea0:	0001883a 	nop
81113ea4:	e037883a 	mov	sp,fp
81113ea8:	dfc00117 	ldw	ra,4(sp)
81113eac:	df000017 	ldw	fp,0(sp)
81113eb0:	dec00204 	addi	sp,sp,8
81113eb4:	f800283a 	ret

81113eb8 <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81113eb8:	defffa04 	addi	sp,sp,-24
81113ebc:	de00012e 	bgeu	sp,et,81113ec4 <vPerformActionNFCRunning+0xc>
81113ec0:	003b68fa 	trap	3
81113ec4:	dfc00515 	stw	ra,20(sp)
81113ec8:	df000415 	stw	fp,16(sp)
81113ecc:	df000404 	addi	fp,sp,16
81113ed0:	e13ffe15 	stw	r4,-8(fp)
81113ed4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
81113ed8:	e0bffe17 	ldw	r2,-8(fp)
81113edc:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81113ee0:	e0bffd83 	ldbu	r2,-10(fp)
81113ee4:	10803fcc 	andi	r2,r2,255
81113ee8:	10c02088 	cmpgei	r3,r2,130
81113eec:	1800071e 	bne	r3,zero,81113f0c <vPerformActionNFCRunning+0x54>
81113ef0:	10c02008 	cmpgei	r3,r2,128
81113ef4:	18003f1e 	bne	r3,zero,81113ff4 <vPerformActionNFCRunning+0x13c>
81113ef8:	10c00060 	cmpeqi	r3,r2,1
81113efc:	1800051e 	bne	r3,zero,81113f14 <vPerformActionNFCRunning+0x5c>
81113f00:	108000a0 	cmpeqi	r2,r2,2
81113f04:	10001f1e 	bne	r2,zero,81113f84 <vPerformActionNFCRunning+0xcc>
81113f08:	00002c06 	br	81113fbc <vPerformActionNFCRunning+0x104>
81113f0c:	10802860 	cmpeqi	r2,r2,161
81113f10:	10002a26 	beq	r2,zero,81113fbc <vPerformActionNFCRunning+0x104>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;
81113f14:	e0bfff17 	ldw	r2,-4(fp)
81113f18:	00c00044 	movi	r3,1
81113f1c:	10c09c15 	stw	r3,624(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81113f20:	e03ffc05 	stb	zero,-16(fp)
81113f24:	00001406 	br	81113f78 <vPerformActionNFCRunning+0xc0>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
81113f28:	e0bffc03 	ldbu	r2,-16(fp)
81113f2c:	e0ffff17 	ldw	r3,-4(fp)
81113f30:	10802644 	addi	r2,r2,153
81113f34:	1085883a 	add	r2,r2,r2
81113f38:	1085883a 	add	r2,r2,r2
81113f3c:	1885883a 	add	r2,r3,r2
81113f40:	10800017 	ldw	r2,0(r2)
81113f44:	10800017 	ldw	r2,0(r2)
81113f48:	10800058 	cmpnei	r2,r2,1
81113f4c:	1000071e 	bne	r2,zero,81113f6c <vPerformActionNFCRunning+0xb4>
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
81113f50:	e0bffc03 	ldbu	r2,-16(fp)
81113f54:	e0fffc03 	ldbu	r3,-16(fp)
81113f58:	180f883a 	mov	r7,r3
81113f5c:	000d883a 	mov	r6,zero
81113f60:	01402844 	movi	r5,161
81113f64:	1009883a 	mov	r4,r2
81113f68:	11140e80 	call	811140e8 <bSendCmdQToNFeeInst_Prio>
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81113f6c:	e0bffc03 	ldbu	r2,-16(fp)
81113f70:	10800044 	addi	r2,r2,1
81113f74:	e0bffc05 	stb	r2,-16(fp)
81113f78:	e0bffc03 	ldbu	r2,-16(fp)
81113f7c:	103fea26 	beq	r2,zero,81113f28 <__reset+0xfb0f3f28>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
81113f80:	00002106 	br	81114008 <vPerformActionNFCRunning+0x150>
		case M_NFC_RUN:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81113f84:	00a045f4 	movhi	r2,33047
81113f88:	10a25304 	addi	r2,r2,-30388
81113f8c:	10800a8b 	ldhu	r2,42(r2)
81113f90:	10bfffcc 	andi	r2,r2,65535
81113f94:	108000e8 	cmpgeui	r2,r2,3
81113f98:	1000181e 	bne	r2,zero,81113ffc <vPerformActionNFCRunning+0x144>
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
81113f9c:	d0a06217 	ldw	r2,-32376(gp)
81113fa0:	100f883a 	mov	r7,r2
81113fa4:	01800d84 	movi	r6,54
81113fa8:	01400044 	movi	r5,1
81113fac:	01204574 	movhi	r4,33045
81113fb0:	213d1204 	addi	r4,r4,-3000
81113fb4:	112393c0 	call	8112393c <fwrite>
			}
			#endif		
			/* Do nothing for now */

			break;
81113fb8:	00001006 	br	81113ffc <vPerformActionNFCRunning+0x144>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113fbc:	00a045f4 	movhi	r2,33047
81113fc0:	10a25304 	addi	r2,r2,-30388
81113fc4:	10800a8b 	ldhu	r2,42(r2)
81113fc8:	10bfffcc 	andi	r2,r2,65535
81113fcc:	10800228 	cmpgeui	r2,r2,8
81113fd0:	10000c1e 	bne	r2,zero,81114004 <vPerformActionNFCRunning+0x14c>
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
81113fd4:	d0a06217 	ldw	r2,-32376(gp)
81113fd8:	100f883a 	mov	r7,r2
81113fdc:	018009c4 	movi	r6,39
81113fe0:	01400044 	movi	r5,1
81113fe4:	01204574 	movhi	r4,33045
81113fe8:	213d0804 	addi	r4,r4,-3040
81113fec:	112393c0 	call	8112393c <fwrite>
			}
			#endif	
			break;
81113ff0:	00000406 	br	81114004 <vPerformActionNFCRunning+0x14c>
			/* Do nothing for now */

			break;
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
81113ff4:	0001883a 	nop
81113ff8:	00000306 	br	81114008 <vPerformActionNFCRunning+0x150>
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
			}
			#endif		
			/* Do nothing for now */

			break;
81113ffc:	0001883a 	nop
81114000:	00000106 	br	81114008 <vPerformActionNFCRunning+0x150>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
81114004:	0001883a 	nop
	}
}
81114008:	0001883a 	nop
8111400c:	e037883a 	mov	sp,fp
81114010:	dfc00117 	ldw	ra,4(sp)
81114014:	df000017 	ldw	fp,0(sp)
81114018:	dec00204 	addi	sp,sp,8
8111401c:	f800283a 	ret

81114020 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81114020:	defff704 	addi	sp,sp,-36
81114024:	de00012e 	bgeu	sp,et,8111402c <bSendCmdQToNFeeInst+0xc>
81114028:	003b68fa 	trap	3
8111402c:	dfc00815 	stw	ra,32(sp)
81114030:	df000715 	stw	fp,28(sp)
81114034:	df000704 	addi	fp,sp,28
81114038:	2011883a 	mov	r8,r4
8111403c:	2809883a 	mov	r4,r5
81114040:	3007883a 	mov	r3,r6
81114044:	3805883a 	mov	r2,r7
81114048:	e23ffc05 	stb	r8,-16(fp)
8111404c:	e13ffd05 	stb	r4,-12(fp)
81114050:	e0fffe05 	stb	r3,-8(fp)
81114054:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
81114058:	e0bffc03 	ldbu	r2,-16(fp)
8111405c:	10800444 	addi	r2,r2,17
81114060:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81114064:	e0bffd03 	ldbu	r2,-12(fp)
81114068:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8111406c:	e0bffe03 	ldbu	r2,-8(fp)
81114070:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81114074:	e0bfff03 	ldbu	r2,-4(fp)
81114078:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8111407c:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81114080:	e0bffc03 	ldbu	r2,-16(fp)
81114084:	1085883a 	add	r2,r2,r2
81114088:	1087883a 	add	r3,r2,r2
8111408c:	d0a06a04 	addi	r2,gp,-32344
81114090:	1885883a 	add	r2,r3,r2
81114094:	10800017 	ldw	r2,0(r2)
81114098:	e0fffb17 	ldw	r3,-20(fp)
8111409c:	180b883a 	mov	r5,r3
811140a0:	1009883a 	mov	r4,r2
811140a4:	113fc6c0 	call	8113fc6c <OSQPost>
811140a8:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
811140ac:	e0bffa03 	ldbu	r2,-24(fp)
811140b0:	10000526 	beq	r2,zero,811140c8 <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
811140b4:	e0bffc03 	ldbu	r2,-16(fp)
811140b8:	1009883a 	mov	r4,r2
811140bc:	111efc40 	call	8111efc4 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
811140c0:	e03ff915 	stw	zero,-28(fp)
811140c4:	00000206 	br	811140d0 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
811140c8:	00800044 	movi	r2,1
811140cc:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
811140d0:	e0bff917 	ldw	r2,-28(fp)
}
811140d4:	e037883a 	mov	sp,fp
811140d8:	dfc00117 	ldw	ra,4(sp)
811140dc:	df000017 	ldw	fp,0(sp)
811140e0:	dec00204 	addi	sp,sp,8
811140e4:	f800283a 	ret

811140e8 <bSendCmdQToNFeeInst_Prio>:


bool bSendCmdQToNFeeInst_Prio( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811140e8:	defff704 	addi	sp,sp,-36
811140ec:	de00012e 	bgeu	sp,et,811140f4 <bSendCmdQToNFeeInst_Prio+0xc>
811140f0:	003b68fa 	trap	3
811140f4:	dfc00815 	stw	ra,32(sp)
811140f8:	df000715 	stw	fp,28(sp)
811140fc:	df000704 	addi	fp,sp,28
81114100:	2011883a 	mov	r8,r4
81114104:	2809883a 	mov	r4,r5
81114108:	3007883a 	mov	r3,r6
8111410c:	3805883a 	mov	r2,r7
81114110:	e23ffc05 	stb	r8,-16(fp)
81114114:	e13ffd05 	stb	r4,-12(fp)
81114118:	e0fffe05 	stb	r3,-8(fp)
8111411c:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
81114120:	e0bffc03 	ldbu	r2,-16(fp)
81114124:	10800444 	addi	r2,r2,17
81114128:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111412c:	e0bffd03 	ldbu	r2,-12(fp)
81114130:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81114134:	e0bffe03 	ldbu	r2,-8(fp)
81114138:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111413c:	e0bfff03 	ldbu	r2,-4(fp)
81114140:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81114144:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPostFront(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81114148:	e0bffc03 	ldbu	r2,-16(fp)
8111414c:	1085883a 	add	r2,r2,r2
81114150:	1087883a 	add	r3,r2,r2
81114154:	d0a06a04 	addi	r2,gp,-32344
81114158:	1885883a 	add	r2,r3,r2
8111415c:	10800017 	ldw	r2,0(r2)
81114160:	e0fffb17 	ldw	r3,-20(fp)
81114164:	180b883a 	mov	r5,r3
81114168:	1009883a 	mov	r4,r2
8111416c:	113fddc0 	call	8113fddc <OSQPostFront>
81114170:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81114174:	e0bffa03 	ldbu	r2,-24(fp)
81114178:	10000526 	beq	r2,zero,81114190 <bSendCmdQToNFeeInst_Prio+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
8111417c:	e0bffc03 	ldbu	r2,-16(fp)
81114180:	1009883a 	mov	r4,r2
81114184:	111efc40 	call	8111efc4 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81114188:	e03ff915 	stw	zero,-28(fp)
8111418c:	00000206 	br	81114198 <bSendCmdQToNFeeInst_Prio+0xb0>
	} else {
		bSuccesL =  TRUE;
81114190:	00800044 	movi	r2,1
81114194:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81114198:	e0bff917 	ldw	r2,-28(fp)
}
8111419c:	e037883a 	mov	sp,fp
811141a0:	dfc00117 	ldw	ra,4(sp)
811141a4:	df000017 	ldw	fp,0(sp)
811141a8:	dec00204 	addi	sp,sp,8
811141ac:	f800283a 	ret

811141b0 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
811141b0:	defff704 	addi	sp,sp,-36
811141b4:	de00012e 	bgeu	sp,et,811141bc <vOutAckHandlerTask+0xc>
811141b8:	003b68fa 	trap	3
811141bc:	dfc00815 	stw	ra,32(sp)
811141c0:	df000715 	stw	fp,28(sp)
811141c4:	df000704 	addi	fp,sp,28
811141c8:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
811141cc:	e03ffac5 	stb	zero,-21(fp)
811141d0:	e03ffb05 	stb	zero,-20(fp)
811141d4:	e03ffb45 	stb	zero,-19(fp)
811141d8:	e03ffb85 	stb	zero,-18(fp)
811141dc:	e03ffbc5 	stb	zero,-17(fp)
811141e0:	e03ffc05 	stb	zero,-16(fp)
811141e4:	e03ffc45 	stb	zero,-15(fp)
811141e8:	e03ffc85 	stb	zero,-14(fp)
811141ec:	e03ffcc5 	stb	zero,-13(fp)
811141f0:	e03ffd05 	stb	zero,-12(fp)
811141f4:	e03ffd45 	stb	zero,-11(fp)
811141f8:	e03ffd85 	stb	zero,-10(fp)
811141fc:	e03ffdc5 	stb	zero,-9(fp)
81114200:	e03ffe05 	stb	zero,-8(fp)
81114204:	e03ffe45 	stb	zero,-7(fp)
81114208:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
8111420c:	e03ffa45 	stb	zero,-23(fp)

	#if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81114210:	00a045f4 	movhi	r2,33047
81114214:	10a25304 	addi	r2,r2,-30388
81114218:	10800a8b 	ldhu	r2,42(r2)
8111421c:	10bfffcc 	andi	r2,r2,65535
81114220:	10800168 	cmpgeui	r2,r2,5
81114224:	1000071e 	bne	r2,zero,81114244 <vOutAckHandlerTask+0x94>
		debug(fp,"Out Ack Handler Task. (Task on)\n");
81114228:	d0a06217 	ldw	r2,-32376(gp)
8111422c:	100f883a 	mov	r7,r2
81114230:	01800804 	movi	r6,32
81114234:	01400044 	movi	r5,1
81114238:	01204574 	movhi	r4,33045
8111423c:	213d2004 	addi	r4,r4,-2944
81114240:	112393c0 	call	8112393c <fwrite>
    }
	#endif

	eSenderAckState = sSAConfiguring;
81114244:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
81114248:	e0bff917 	ldw	r2,-28(fp)
8111424c:	10c00060 	cmpeqi	r3,r2,1
81114250:	1800071e 	bne	r3,zero,81114270 <vOutAckHandlerTask+0xc0>
81114254:	0080032e 	bgeu	zero,r2,81114264 <vOutAckHandlerTask+0xb4>
81114258:	108000a0 	cmpeqi	r2,r2,2
8111425c:	1000471e 	bne	r2,zero,8111437c <vOutAckHandlerTask+0x1cc>
81114260:	00008c06 	br	81114494 <vOutAckHandlerTask+0x2e4>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
81114264:	00800044 	movi	r2,1
81114268:	e0bff915 	stw	r2,-28(fp)
				break;
8111426c:	00009906 	br	811144d4 <vOutAckHandlerTask+0x324>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
81114270:	00800044 	movi	r2,1
81114274:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
81114278:	d0a06117 	ldw	r2,-32380(gp)
8111427c:	e0fffa84 	addi	r3,fp,-22
81114280:	180d883a 	mov	r6,r3
81114284:	000b883a 	mov	r5,zero
81114288:	1009883a 	mov	r4,r2
8111428c:	114075c0 	call	8114075c <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81114290:	e0bffa83 	ldbu	r2,-22(fp)
81114294:	10803fcc 	andi	r2,r2,255
81114298:	1000361e 	bne	r2,zero,81114374 <vOutAckHandlerTask+0x1c4>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
8111429c:	d0a07217 	ldw	r2,-32312(gp)
811142a0:	e0fffa84 	addi	r3,fp,-22
811142a4:	180d883a 	mov	r6,r3
811142a8:	000b883a 	mov	r5,zero
811142ac:	1009883a 	mov	r4,r2
811142b0:	113e7500 	call	8113e750 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
811142b4:	e0bffa83 	ldbu	r2,-22(fp)
811142b8:	10803fcc 	andi	r2,r2,255
811142bc:	10002b1e 	bne	r2,zero,8111436c <vOutAckHandlerTask+0x1bc>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
811142c0:	e03ffa05 	stb	zero,-24(fp)
811142c4:	00002206 	br	81114350 <vOutAckHandlerTask+0x1a0>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
811142c8:	e0fffa03 	ldbu	r3,-24(fp)
811142cc:	00a045f4 	movhi	r2,33047
811142d0:	10a1a304 	addi	r2,r2,-31092
811142d4:	18c7883a 	add	r3,r3,r3
811142d8:	18c7883a 	add	r3,r3,r3
811142dc:	10c5883a 	add	r2,r2,r3
811142e0:	10800003 	ldbu	r2,0(r2)
811142e4:	10803fcc 	andi	r2,r2,255
811142e8:	1080201c 	xori	r2,r2,128
811142ec:	10bfe004 	addi	r2,r2,-128
811142f0:	10001426 	beq	r2,zero,81114344 <vOutAckHandlerTask+0x194>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
811142f4:	e0fffa03 	ldbu	r3,-24(fp)
811142f8:	00a045f4 	movhi	r2,33047
811142fc:	10a1a304 	addi	r2,r2,-31092
81114300:	18c7883a 	add	r3,r3,r3
81114304:	18c7883a 	add	r3,r3,r3
81114308:	10c5883a 	add	r2,r2,r3
8111430c:	10c0000b 	ldhu	r3,0(r2)
81114310:	d0e0598d 	sth	r3,-32410(gp)
81114314:	1080008b 	ldhu	r2,2(r2)
81114318:	d0a05a0d 	sth	r2,-32408(gp)
                                eSenderAckState = sSASending;
8111431c:	00800084 	movi	r2,2
81114320:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81114324:	e0fffa03 	ldbu	r3,-24(fp)
81114328:	00a045f4 	movhi	r2,33047
8111432c:	10a1a304 	addi	r2,r2,-31092
81114330:	18c7883a 	add	r3,r3,r3
81114334:	18c7883a 	add	r3,r3,r3
81114338:	10c5883a 	add	r2,r2,r3
8111433c:	10000005 	stb	zero,0(r2)
                                break;
81114340:	00000606 	br	8111435c <vOutAckHandlerTask+0x1ac>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81114344:	e0bffa03 	ldbu	r2,-24(fp)
81114348:	10800044 	addi	r2,r2,1
8111434c:	e0bffa05 	stb	r2,-24(fp)
81114350:	e0bffa03 	ldbu	r2,-24(fp)
81114354:	10800230 	cmpltui	r2,r2,8
81114358:	103fdb1e 	bne	r2,zero,811142c8 <__reset+0xfb0f42c8>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
8111435c:	d0a07217 	ldw	r2,-32312(gp)
81114360:	1009883a 	mov	r4,r2
81114364:	113ecf40 	call	8113ecf4 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81114368:	00005a06 	br	811144d4 <vOutAckHandlerTask+0x324>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
8111436c:	111d2080 	call	8111d208 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81114370:	00005806 	br	811144d4 <vOutAckHandlerTask+0x324>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
81114374:	111d1880 	call	8111d188 <vFailGetCountSemaphoreSenderTask>
                }

                break;
81114378:	00005606 	br	811144d4 <vOutAckHandlerTask+0x324>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
8111437c:	d0a05983 	ldbu	r2,-32410(gp)
81114380:	10803fcc 	andi	r2,r2,255
81114384:	1080201c 	xori	r2,r2,128
81114388:	10bfe004 	addi	r2,r2,-128
8111438c:	108008e0 	cmpeqi	r2,r2,35
81114390:	1000201e 	bne	r2,zero,81114414 <vOutAckHandlerTask+0x264>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
81114394:	d0a059c3 	ldbu	r2,-32409(gp)
81114398:	10c03fcc 	andi	r3,r2,255
8111439c:	18c0201c 	xori	r3,r3,128
811143a0:	18ffe004 	addi	r3,r3,-128
811143a4:	d0a05a0b 	ldhu	r2,-32408(gp)
811143a8:	113fffcc 	andi	r4,r2,65535
811143ac:	e0bffac4 	addi	r2,fp,-21
811143b0:	200f883a 	mov	r7,r4
811143b4:	180d883a 	mov	r6,r3
811143b8:	01604574 	movhi	r5,33045
811143bc:	297d2904 	addi	r5,r5,-2908
811143c0:	1009883a 	mov	r4,r2
811143c4:	1124bb40 	call	81124bb4 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
811143c8:	e0bffac4 	addi	r2,fp,-21
811143cc:	1009883a 	mov	r4,r2
811143d0:	1124dc80 	call	81124dc8 <strlen>
811143d4:	1007883a 	mov	r3,r2
811143d8:	e0bffac4 	addi	r2,fp,-21
811143dc:	180b883a 	mov	r5,r3
811143e0:	1009883a 	mov	r4,r2
811143e4:	111cc8c0 	call	8111cc8c <ucCrc8wInit>
811143e8:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
811143ec:	e13ffa43 	ldbu	r4,-23(fp)
811143f0:	e0fffac4 	addi	r3,fp,-21
811143f4:	e0bffac4 	addi	r2,fp,-21
811143f8:	200f883a 	mov	r7,r4
811143fc:	180d883a 	mov	r6,r3
81114400:	01604574 	movhi	r5,33045
81114404:	297d2b04 	addi	r5,r5,-2900
81114408:	1009883a 	mov	r4,r2
8111440c:	1124bb40 	call	81124bb4 <sprintf>
81114410:	00000c06 	br	81114444 <vOutAckHandlerTask+0x294>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
81114414:	e0bffac4 	addi	r2,fp,-21
81114418:	00c008c4 	movi	r3,35
8111441c:	10c00005 	stb	r3,0(r2)
81114420:	00c01f04 	movi	r3,124
81114424:	10c00045 	stb	r3,1(r2)
81114428:	00c00d44 	movi	r3,53
8111442c:	10c00085 	stb	r3,2(r2)
81114430:	00c00d04 	movi	r3,52
81114434:	10c000c5 	stb	r3,3(r2)
81114438:	00c00ec4 	movi	r3,59
8111443c:	10c00105 	stb	r3,4(r2)
81114440:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
81114444:	d0a07417 	ldw	r2,-32304(gp)
81114448:	e0fffa84 	addi	r3,fp,-22
8111444c:	180d883a 	mov	r6,r3
81114450:	01401904 	movi	r5,100
81114454:	1009883a 	mov	r4,r2
81114458:	113e7500 	call	8113e750 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
8111445c:	e0bffa83 	ldbu	r2,-22(fp)
81114460:	10803fcc 	andi	r2,r2,255
81114464:	1000071e 	bne	r2,zero,81114484 <vOutAckHandlerTask+0x2d4>
                    puts(cBufferAck);
81114468:	e0bffac4 	addi	r2,fp,-21
8111446c:	1009883a 	mov	r4,r2
81114470:	11248700 	call	81124870 <puts>
                    OSMutexPost(xTxUARTMutex);
81114474:	d0a07417 	ldw	r2,-32304(gp)
81114478:	1009883a 	mov	r4,r2
8111447c:	113ecf40 	call	8113ecf4 <OSMutexPost>
81114480:	00000106 	br	81114488 <vOutAckHandlerTask+0x2d8>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
81114484:	111d3880 	call	8111d388 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
81114488:	00800044 	movi	r2,1
8111448c:	e0bff915 	stw	r2,-28(fp)
                
				break;
81114490:	00001006 	br	811144d4 <vOutAckHandlerTask+0x324>
			default:
            	#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81114494:	00a045f4 	movhi	r2,33047
81114498:	10a25304 	addi	r2,r2,-30388
8111449c:	10800a8b 	ldhu	r2,42(r2)
811144a0:	10bfffcc 	andi	r2,r2,65535
811144a4:	10800228 	cmpgeui	r2,r2,8
811144a8:	1000071e 	bne	r2,zero,811144c8 <vOutAckHandlerTask+0x318>
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
811144ac:	d0a06217 	ldw	r2,-32376(gp)
811144b0:	100f883a 	mov	r7,r2
811144b4:	01801104 	movi	r6,68
811144b8:	01400044 	movi	r5,1
811144bc:	01204574 	movhi	r4,33045
811144c0:	213d2e04 	addi	r4,r4,-2888
811144c4:	112393c0 	call	8112393c <fwrite>
				}
	            #endif
                eSenderAckState = sSAGettingACK;
811144c8:	00800044 	movi	r2,1
811144cc:	e0bff915 	stw	r2,-28(fp)
				break;
811144d0:	0001883a 	nop
		}
	}
811144d4:	003f5c06 	br	81114248 <__reset+0xfb0f4248>

811144d8 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
811144d8:	deffd704 	addi	sp,sp,-164
811144dc:	de00012e 	bgeu	sp,et,811144e4 <vParserCommTask+0xc>
811144e0:	003b68fa 	trap	3
811144e4:	dfc02815 	stw	ra,160(sp)
811144e8:	df002715 	stw	fp,156(sp)
811144ec:	df002704 	addi	fp,sp,156
811144f0:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
811144f4:	e03fdd15 	stw	zero,-140(fp)
	#if DEBUG_ON
		char cPUSDebug[128];
	#endif

    #if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811144f8:	00a045f4 	movhi	r2,33047
811144fc:	10a25304 	addi	r2,r2,-30388
81114500:	10800a8b 	ldhu	r2,42(r2)
81114504:	10bfffcc 	andi	r2,r2,65535
81114508:	10800168 	cmpgeui	r2,r2,5
8111450c:	1000071e 	bne	r2,zero,8111452c <vParserCommTask+0x54>
			debug(fp,"Parser Comm Task. (Task on)\n");
81114510:	d0a06217 	ldw	r2,-32376(gp)
81114514:	100f883a 	mov	r7,r2
81114518:	01800704 	movi	r6,28
8111451c:	01400044 	movi	r5,1
81114520:	01204574 	movhi	r4,33045
81114524:	213d4004 	addi	r4,r4,-2816
81114528:	112393c0 	call	8112393c <fwrite>
		}
    #endif

	eParserMode = sConfiguring;
8111452c:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
81114530:	e0bfdc17 	ldw	r2,-144(fp)
81114534:	10800168 	cmpgeui	r2,r2,5
81114538:	1003d31e 	bne	r2,zero,81115488 <vParserCommTask+0xfb0>
8111453c:	e0bfdc17 	ldw	r2,-144(fp)
81114540:	100690ba 	slli	r3,r2,2
81114544:	00a04474 	movhi	r2,33041
81114548:	10915604 	addi	r2,r2,17752
8111454c:	1885883a 	add	r2,r3,r2
81114550:	10800017 	ldw	r2,0(r2)
81114554:	1000683a 	jmp	r2
81114558:	8111456c 	andhi	r4,r16,17685
8111455c:	81114578 	rdprs	r4,r16,17685
81114560:	8111460c 	andi	r4,r16,17688
81114564:	81114788 	cmpgei	r4,r16,17694
81114568:	811147cc 	andi	r4,r16,17695
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
8111456c:	00800044 	movi	r2,1
81114570:	e0bfdc15 	stw	r2,-144(fp)
				break;
81114574:	0003c706 	br	81115494 <vParserCommTask+0xfbc>
			case sWaitingMessage:

				bSuccess = FALSE;
81114578:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
8111457c:	00800044 	movi	r2,1
81114580:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
81114584:	d0a06417 	ldw	r2,-32368(gp)
81114588:	e0ffde84 	addi	r3,fp,-134
8111458c:	180d883a 	mov	r6,r3
81114590:	000b883a 	mov	r5,zero
81114594:	1009883a 	mov	r4,r2
81114598:	114075c0 	call	8114075c <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
8111459c:	e0bfde83 	ldbu	r2,-134(fp)
811145a0:	10803fcc 	andi	r2,r2,255
811145a4:	1000171e 	bne	r2,zero,81114604 <vParserCommTask+0x12c>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
811145a8:	01204574 	movhi	r4,33045
811145ac:	21141304 	addi	r4,r4,20556
811145b0:	11154980 	call	81115498 <getPreParsedPacket>
811145b4:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
811145b8:	e0bfdd17 	ldw	r2,-140(fp)
811145bc:	10800058 	cmpnei	r2,r2,1
811145c0:	10000e1e 	bne	r2,zero,811145fc <vParserCommTask+0x124>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
811145c4:	00a04574 	movhi	r2,33045
811145c8:	10941304 	addi	r2,r2,20556
811145cc:	10800103 	ldbu	r2,4(r2)
811145d0:	10803fcc 	andi	r2,r2,255
811145d4:	1080201c 	xori	r2,r2,128
811145d8:	10bfe004 	addi	r2,r2,-128
811145dc:	10800858 	cmpnei	r2,r2,33
811145e0:	1000031e 	bne	r2,zero,811145f0 <vParserCommTask+0x118>
							eParserMode = sReplyParsing;
811145e4:	008000c4 	movi	r2,3
811145e8:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811145ec:	0003a906 	br	81115494 <vParserCommTask+0xfbc>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
811145f0:	00800084 	movi	r2,2
811145f4:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811145f8:	0003a606 	br	81115494 <vParserCommTask+0xfbc>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
811145fc:	111da7c0 	call	8111da7c <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81114600:	0003a406 	br	81115494 <vParserCommTask+0xfbc>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
81114604:	111d97c0 	call	8111d97c <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
81114608:	0003a206 	br	81115494 <vParserCommTask+0xfbc>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
8111460c:	00a04574 	movhi	r2,33045
81114610:	10941304 	addi	r2,r2,20556
81114614:	10800143 	ldbu	r2,5(r2)
81114618:	10803fcc 	andi	r2,r2,255
8111461c:	1080201c 	xori	r2,r2,128
81114620:	10bfe004 	addi	r2,r2,-128
81114624:	10c010e0 	cmpeqi	r3,r2,67
81114628:	1800031e 	bne	r3,zero,81114638 <vParserCommTask+0x160>
8111462c:	10801420 	cmpeqi	r2,r2,80
81114630:	1000051e 	bne	r2,zero,81114648 <vParserCommTask+0x170>
81114634:	00005006 	br	81114778 <vParserCommTask+0x2a0>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
81114638:	111a3fc0 	call	8111a3fc <vSendEthConf>
						eParserMode = sWaitingMessage;
8111463c:	00800044 	movi	r2,1
81114640:	e0bfdc15 	stw	r2,-144(fp)
						break;
81114644:	00004f06 	br	81114784 <vParserCommTask+0x2ac>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#if DEBUG_ON
                    	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114648:	00a045f4 	movhi	r2,33047
8111464c:	10a25304 	addi	r2,r2,-30388
81114650:	10800a8b 	ldhu	r2,42(r2)
81114654:	10bfffcc 	andi	r2,r2,65535
81114658:	108000e8 	cmpgeui	r2,r2,3
8111465c:	1000281e 	bne	r2,zero,81114700 <vParserCommTask+0x228>
							memset(cPUSDebug,0,128);
81114660:	e0bfdec4 	addi	r2,fp,-133
81114664:	01802004 	movi	r6,128
81114668:	000b883a 	mov	r5,zero
8111466c:	1009883a 	mov	r4,r2
81114670:	11244a00 	call	811244a0 <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
81114674:	00a04574 	movhi	r2,33045
81114678:	10941304 	addi	r2,r2,20556
8111467c:	1080028b 	ldhu	r2,10(r2)
81114680:	117fffcc 	andi	r5,r2,65535
81114684:	00a04574 	movhi	r2,33045
81114688:	10941304 	addi	r2,r2,20556
8111468c:	1080030b 	ldhu	r2,12(r2)
81114690:	11bfffcc 	andi	r6,r2,65535
81114694:	00a04574 	movhi	r2,33045
81114698:	10941304 	addi	r2,r2,20556
8111469c:	1080038b 	ldhu	r2,14(r2)
811146a0:	10ffffcc 	andi	r3,r2,65535
811146a4:	00a04574 	movhi	r2,33045
811146a8:	10941304 	addi	r2,r2,20556
811146ac:	1080040b 	ldhu	r2,16(r2)
811146b0:	113fffcc 	andi	r4,r2,65535
811146b4:	00a04574 	movhi	r2,33045
811146b8:	10941304 	addi	r2,r2,20556
811146bc:	1080048b 	ldhu	r2,18(r2)
811146c0:	10bfffcc 	andi	r2,r2,65535
811146c4:	e23fdec4 	addi	r8,fp,-133
811146c8:	d8800215 	stw	r2,8(sp)
811146cc:	d9000115 	stw	r4,4(sp)
811146d0:	d8c00015 	stw	r3,0(sp)
811146d4:	300f883a 	mov	r7,r6
811146d8:	280d883a 	mov	r6,r5
811146dc:	01604574 	movhi	r5,33045
811146e0:	297d4804 	addi	r5,r5,-2784
811146e4:	4009883a 	mov	r4,r8
811146e8:	1124bb40 	call	81124bb4 <sprintf>
							debug(fp, cPUSDebug );
811146ec:	d0a06217 	ldw	r2,-32376(gp)
811146f0:	e0ffdec4 	addi	r3,fp,-133
811146f4:	180b883a 	mov	r5,r3
811146f8:	1009883a 	mov	r4,r2
811146fc:	11232a00 	call	811232a0 <fprintf>
                    	}
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
81114700:	00a04574 	movhi	r2,33045
81114704:	10941304 	addi	r2,r2,20556
81114708:	10c0030b 	ldhu	r3,12(r2)
8111470c:	00a04574 	movhi	r2,33045
81114710:	10942604 	addi	r2,r2,20632
81114714:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
81114718:	00a04574 	movhi	r2,33045
8111471c:	10941304 	addi	r2,r2,20556
81114720:	10c0038b 	ldhu	r3,14(r2)
81114724:	00a04574 	movhi	r2,33045
81114728:	10942604 	addi	r2,r2,20632
8111472c:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
81114730:	00a04574 	movhi	r2,33045
81114734:	10941304 	addi	r2,r2,20556
81114738:	10c0040b 	ldhu	r3,16(r2)
8111473c:	00a04574 	movhi	r2,33045
81114740:	10942604 	addi	r2,r2,20632
81114744:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
81114748:	00a04574 	movhi	r2,33045
8111474c:	10941304 	addi	r2,r2,20556
81114750:	10c0048b 	ldhu	r3,18(r2)
81114754:	00a04574 	movhi	r2,33045
81114758:	10942604 	addi	r2,r2,20632
8111475c:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
81114760:	00a04574 	movhi	r2,33045
81114764:	10942604 	addi	r2,r2,20632
81114768:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
8111476c:	00800104 	movi	r2,4
81114770:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
81114774:	00000306 	br	81114784 <vParserCommTask+0x2ac>
					default:
						eParserMode = sWaitingMessage;
81114778:	00800044 	movi	r2,1
8111477c:	e0bfdc15 	stw	r2,-144(fp)
						break;
81114780:	0001883a 	nop
				}
				break;
81114784:	00034306 	br	81115494 <vParserCommTask+0xfbc>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
81114788:	00800044 	movi	r2,1
8111478c:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
81114790:	00a04574 	movhi	r2,33045
81114794:	10942604 	addi	r2,r2,20632
81114798:	1080030b 	ldhu	r2,12(r2)
8111479c:	10bfffcc 	andi	r2,r2,65535
811147a0:	10c01220 	cmpeqi	r3,r2,72
811147a4:	1800051e 	bne	r3,zero,811147bc <vParserCommTask+0x2e4>
811147a8:	108014e0 	cmpeqi	r2,r2,83
811147ac:	1000051e 	bne	r2,zero,811147c4 <vParserCommTask+0x2ec>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
811147b0:	00800044 	movi	r2,1
811147b4:	e0bfdc15 	stw	r2,-144(fp)
                        break;
811147b8:	00000306 	br	811147c8 <vParserCommTask+0x2f0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
811147bc:	0001883a 	nop
811147c0:	00033406 	br	81115494 <vParserCommTask+0xfbc>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
811147c4:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
811147c8:	00033206 	br	81115494 <vParserCommTask+0xfbc>
			case sPusHandling:
				eParserMode = sWaitingMessage;
811147cc:	00800044 	movi	r2,1
811147d0:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
811147d4:	00a04574 	movhi	r2,33045
811147d8:	10942604 	addi	r2,r2,20632
811147dc:	1080030b 	ldhu	r2,12(r2)
811147e0:	10bfffcc 	andi	r2,r2,65535
811147e4:	10c03ea0 	cmpeqi	r3,r2,250
811147e8:	18004c1e 	bne	r3,zero,8111491c <vParserCommTask+0x444>
811147ec:	10c03ec8 	cmpgei	r3,r2,251
811147f0:	1800031e 	bne	r3,zero,81114800 <vParserCommTask+0x328>
811147f4:	10800460 	cmpeqi	r2,r2,17
811147f8:	1000061e 	bne	r2,zero,81114814 <vParserCommTask+0x33c>
811147fc:	00031d06 	br	81115474 <vParserCommTask+0xf9c>
81114800:	10c03ee0 	cmpeqi	r3,r2,251
81114804:	1800c71e 	bne	r3,zero,81114b24 <vParserCommTask+0x64c>
81114808:	10803f20 	cmpeqi	r2,r2,252
8111480c:	10017a1e 	bne	r2,zero,81114df8 <vParserCommTask+0x920>
81114810:	00031806 	br	81115474 <vParserCommTask+0xf9c>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
81114814:	00a04574 	movhi	r2,33045
81114818:	10942604 	addi	r2,r2,20632
8111481c:	1080038b 	ldhu	r2,14(r2)
81114820:	10bfffcc 	andi	r2,r2,65535
81114824:	10800060 	cmpeqi	r2,r2,1
81114828:	10001426 	beq	r2,zero,8111487c <vParserCommTask+0x3a4>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8111482c:	00a045f4 	movhi	r2,33047
81114830:	10a25304 	addi	r2,r2,-30388
81114834:	10800a8b 	ldhu	r2,42(r2)
81114838:	10bfffcc 	andi	r2,r2,65535
8111483c:	10800168 	cmpgeui	r2,r2,5
81114840:	1000071e 	bne	r2,zero,81114860 <vParserCommTask+0x388>
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
81114844:	d0a06217 	ldw	r2,-32376(gp)
81114848:	100f883a 	mov	r7,r2
8111484c:	01800944 	movi	r6,37
81114850:	01400044 	movi	r5,1
81114854:	01204574 	movhi	r4,33045
81114858:	213d5e04 	addi	r4,r4,-2696
8111485c:	112393c0 	call	8112393c <fwrite>
								}
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
81114860:	00a04574 	movhi	r2,33045
81114864:	10942604 	addi	r2,r2,20632
81114868:	1080040b 	ldhu	r2,16(r2)
8111486c:	10bfffcc 	andi	r2,r2,65535
81114870:	1009883a 	mov	r4,r2
81114874:	111adfc0 	call	8111adfc <vTMPusTestConnection>

								break;
81114878:	00002706 	br	81114918 <vParserCommTask+0x440>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111487c:	00a045f4 	movhi	r2,33047
81114880:	10a25304 	addi	r2,r2,-30388
81114884:	10800a8b 	ldhu	r2,42(r2)
81114888:	10bfffcc 	andi	r2,r2,65535
8111488c:	108000e8 	cmpgeui	r2,r2,3
81114890:	10001e1e 	bne	r2,zero,8111490c <vParserCommTask+0x434>
									memset(cPUSDebug,0,128);
81114894:	e0bfdec4 	addi	r2,fp,-133
81114898:	01802004 	movi	r6,128
8111489c:	000b883a 	mov	r5,zero
811148a0:	1009883a 	mov	r4,r2
811148a4:	11244a00 	call	811244a0 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811148a8:	00a04574 	movhi	r2,33045
811148ac:	10942604 	addi	r2,r2,20632
811148b0:	1080030b 	ldhu	r2,12(r2)
811148b4:	113fffcc 	andi	r4,r2,65535
811148b8:	00a04574 	movhi	r2,33045
811148bc:	10942604 	addi	r2,r2,20632
811148c0:	1080038b 	ldhu	r2,14(r2)
811148c4:	117fffcc 	andi	r5,r2,65535
811148c8:	00a04574 	movhi	r2,33045
811148cc:	10942604 	addi	r2,r2,20632
811148d0:	1080040b 	ldhu	r2,16(r2)
811148d4:	10bfffcc 	andi	r2,r2,65535
811148d8:	e0ffdec4 	addi	r3,fp,-133
811148dc:	d8800015 	stw	r2,0(sp)
811148e0:	280f883a 	mov	r7,r5
811148e4:	200d883a 	mov	r6,r4
811148e8:	01604574 	movhi	r5,33045
811148ec:	297d6804 	addi	r5,r5,-2656
811148f0:	1809883a 	mov	r4,r3
811148f4:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
811148f8:	d0a06217 	ldw	r2,-32376(gp)
811148fc:	e0ffdec4 	addi	r3,fp,-133
81114900:	180b883a 	mov	r5,r3
81114904:	1009883a 	mov	r4,r2
81114908:	11232a00 	call	811232a0 <fprintf>
								}
								#endif
								eParserMode = sWaitingMessage;
8111490c:	00800044 	movi	r2,1
81114910:	e0bfdc15 	stw	r2,-144(fp)
								break;
81114914:	0001883a 	nop
						}
                        break;
81114918:	0002da06 	br	81115484 <vParserCommTask+0xfac>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
8111491c:	00a04574 	movhi	r2,33045
81114920:	10942604 	addi	r2,r2,20632
81114924:	1080038b 	ldhu	r2,14(r2)
81114928:	10bfffcc 	andi	r2,r2,65535
8111492c:	10c00f20 	cmpeqi	r3,r2,60
81114930:	1800201e 	bne	r3,zero,811149b4 <vParserCommTask+0x4dc>
81114934:	10c00f48 	cmpgei	r3,r2,61
81114938:	1800031e 	bne	r3,zero,81114948 <vParserCommTask+0x470>
8111493c:	10800ee0 	cmpeqi	r2,r2,59
81114940:	1000061e 	bne	r2,zero,8111495c <vParserCommTask+0x484>
81114944:	00004f06 	br	81114a84 <vParserCommTask+0x5ac>
81114948:	10c00f60 	cmpeqi	r3,r2,61
8111494c:	18002a1e 	bne	r3,zero,811149f8 <vParserCommTask+0x520>
81114950:	10800fa0 	cmpeqi	r2,r2,62
81114954:	1000391e 	bne	r2,zero,81114a3c <vParserCommTask+0x564>
81114958:	00004a06 	br	81114a84 <vParserCommTask+0x5ac>
						{
							case 59: /* TC_SCAM_RESET */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111495c:	00a045f4 	movhi	r2,33047
81114960:	10a25304 	addi	r2,r2,-30388
81114964:	10800a8b 	ldhu	r2,42(r2)
81114968:	10bfffcc 	andi	r2,r2,65535
8111496c:	108000e8 	cmpgeui	r2,r2,3
81114970:	1000071e 	bne	r2,zero,81114990 <vParserCommTask+0x4b8>
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
81114974:	d0a06217 	ldw	r2,-32376(gp)
81114978:	100f883a 	mov	r7,r2
8111497c:	018006c4 	movi	r6,27
81114980:	01400044 	movi	r5,1
81114984:	01204574 	movhi	r4,33045
81114988:	213d7b04 	addi	r4,r4,-2580
8111498c:	112393c0 	call	8112393c <fwrite>
								}
								#endif
								vSendReset();
81114990:	111a7a40 	call	8111a7a4 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
81114994:	000f883a 	mov	r7,zero
81114998:	018000c4 	movi	r6,3
8111499c:	000b883a 	mov	r5,zero
811149a0:	0009883a 	mov	r4,zero
811149a4:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
811149a8:	0104e204 	movi	r4,5000
811149ac:	110ca1c0 	call	8110ca1c <vRstcSimucamReset>

								break;
811149b0:	00005b06 	br	81114b20 <vParserCommTask+0x648>
							case 60: /* TC_SCAM_CONFIG */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811149b4:	00a045f4 	movhi	r2,33047
811149b8:	10a25304 	addi	r2,r2,-30388
811149bc:	10800a8b 	ldhu	r2,42(r2)
811149c0:	10bfffcc 	andi	r2,r2,65535
811149c4:	108000e8 	cmpgeui	r2,r2,3
811149c8:	1000071e 	bne	r2,zero,811149e8 <vParserCommTask+0x510>
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
811149cc:	d0a06217 	ldw	r2,-32376(gp)
811149d0:	100f883a 	mov	r7,r2
811149d4:	01800704 	movi	r6,28
811149d8:	01400044 	movi	r5,1
811149dc:	01204574 	movhi	r4,33045
811149e0:	213d8204 	addi	r4,r4,-2552
811149e4:	112393c0 	call	8112393c <fwrite>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811149e8:	01204574 	movhi	r4,33045
811149ec:	21142604 	addi	r4,r4,20632
811149f0:	11155b00 	call	811155b0 <bSendMessagePUStoMebTask>

								break;
811149f4:	00004a06 	br	81114b20 <vParserCommTask+0x648>
							case 61: /* TC_SCAM_RUN */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811149f8:	00a045f4 	movhi	r2,33047
811149fc:	10a25304 	addi	r2,r2,-30388
81114a00:	10800a8b 	ldhu	r2,42(r2)
81114a04:	10bfffcc 	andi	r2,r2,65535
81114a08:	108000e8 	cmpgeui	r2,r2,3
81114a0c:	1000071e 	bne	r2,zero,81114a2c <vParserCommTask+0x554>
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
81114a10:	d0a06217 	ldw	r2,-32376(gp)
81114a14:	100f883a 	mov	r7,r2
81114a18:	01800644 	movi	r6,25
81114a1c:	01400044 	movi	r5,1
81114a20:	01204574 	movhi	r4,33045
81114a24:	213d8a04 	addi	r4,r4,-2520
81114a28:	112393c0 	call	8112393c <fwrite>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114a2c:	01204574 	movhi	r4,33045
81114a30:	21142604 	addi	r4,r4,20632
81114a34:	11155b00 	call	811155b0 <bSendMessagePUStoMebTask>

								break;
81114a38:	00003906 	br	81114b20 <vParserCommTask+0x648>
							case 62: /* TC_SCAM_TURNOFF */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114a3c:	00a045f4 	movhi	r2,33047
81114a40:	10a25304 	addi	r2,r2,-30388
81114a44:	10800a8b 	ldhu	r2,42(r2)
81114a48:	10bfffcc 	andi	r2,r2,65535
81114a4c:	108000e8 	cmpgeui	r2,r2,3
81114a50:	1000071e 	bne	r2,zero,81114a70 <vParserCommTask+0x598>
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
81114a54:	d0a06217 	ldw	r2,-32376(gp)
81114a58:	100f883a 	mov	r7,r2
81114a5c:	01800744 	movi	r6,29
81114a60:	01400044 	movi	r5,1
81114a64:	01204574 	movhi	r4,33045
81114a68:	213d9104 	addi	r4,r4,-2492
81114a6c:	112393c0 	call	8112393c <fwrite>
								}
								#endif
								vSendTurnOff();
81114a70:	111a68c0 	call	8111a68c <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
81114a74:	01204574 	movhi	r4,33045
81114a78:	21142604 	addi	r4,r4,20632
81114a7c:	11155b00 	call	811155b0 <bSendMessagePUStoMebTask>

								break;
81114a80:	00002706 	br	81114b20 <vParserCommTask+0x648>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114a84:	00a045f4 	movhi	r2,33047
81114a88:	10a25304 	addi	r2,r2,-30388
81114a8c:	10800a8b 	ldhu	r2,42(r2)
81114a90:	10bfffcc 	andi	r2,r2,65535
81114a94:	108000e8 	cmpgeui	r2,r2,3
81114a98:	10001e1e 	bne	r2,zero,81114b14 <vParserCommTask+0x63c>
									memset(cPUSDebug,0,128);
81114a9c:	e0bfdec4 	addi	r2,fp,-133
81114aa0:	01802004 	movi	r6,128
81114aa4:	000b883a 	mov	r5,zero
81114aa8:	1009883a 	mov	r4,r2
81114aac:	11244a00 	call	811244a0 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81114ab0:	00a04574 	movhi	r2,33045
81114ab4:	10942604 	addi	r2,r2,20632
81114ab8:	1080030b 	ldhu	r2,12(r2)
81114abc:	113fffcc 	andi	r4,r2,65535
81114ac0:	00a04574 	movhi	r2,33045
81114ac4:	10942604 	addi	r2,r2,20632
81114ac8:	1080038b 	ldhu	r2,14(r2)
81114acc:	117fffcc 	andi	r5,r2,65535
81114ad0:	00a04574 	movhi	r2,33045
81114ad4:	10942604 	addi	r2,r2,20632
81114ad8:	1080040b 	ldhu	r2,16(r2)
81114adc:	10bfffcc 	andi	r2,r2,65535
81114ae0:	e0ffdec4 	addi	r3,fp,-133
81114ae4:	d8800015 	stw	r2,0(sp)
81114ae8:	280f883a 	mov	r7,r5
81114aec:	200d883a 	mov	r6,r4
81114af0:	01604574 	movhi	r5,33045
81114af4:	297d6804 	addi	r5,r5,-2656
81114af8:	1809883a 	mov	r4,r3
81114afc:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
81114b00:	d0a06217 	ldw	r2,-32376(gp)
81114b04:	e0ffdec4 	addi	r3,fp,-133
81114b08:	180b883a 	mov	r5,r3
81114b0c:	1009883a 	mov	r4,r2
81114b10:	11232a00 	call	811232a0 <fprintf>
								}
								#endif							
								eParserMode = sWaitingMessage;
81114b14:	00800044 	movi	r2,1
81114b18:	e0bfdc15 	stw	r2,-144(fp)
								break;
81114b1c:	0001883a 	nop
						}
                        break;
81114b20:	00025806 	br	81115484 <vParserCommTask+0xfac>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81114b24:	00a04574 	movhi	r2,33045
81114b28:	10941304 	addi	r2,r2,20556
81114b2c:	1080050b 	ldhu	r2,20(r2)
81114b30:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
81114b34:	e0bfde0b 	ldhu	r2,-136(fp)
81114b38:	108000b0 	cmpltui	r2,r2,2
81114b3c:	1000181e 	bne	r2,zero,81114ba0 <vParserCommTask+0x6c8>
							#if DEBUG_ON
							if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114b40:	00a045f4 	movhi	r2,33047
81114b44:	10a25304 	addi	r2,r2,-30388
81114b48:	10800a8b 	ldhu	r2,42(r2)
81114b4c:	10bfffcc 	andi	r2,r2,65535
81114b50:	108000e8 	cmpgeui	r2,r2,3
81114b54:	10024a1e 	bne	r2,zero,81115480 <vParserCommTask+0xfa8>
								memset(cPUSDebug,0,128);
81114b58:	e0bfdec4 	addi	r2,fp,-133
81114b5c:	01802004 	movi	r6,128
81114b60:	000b883a 	mov	r5,zero
81114b64:	1009883a 	mov	r4,r2
81114b68:	11244a00 	call	811244a0 <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
81114b6c:	e0ffde0b 	ldhu	r3,-136(fp)
81114b70:	e0bfdec4 	addi	r2,fp,-133
81114b74:	180d883a 	mov	r6,r3
81114b78:	01604574 	movhi	r5,33045
81114b7c:	297d9904 	addi	r5,r5,-2460
81114b80:	1009883a 	mov	r4,r2
81114b84:	1124bb40 	call	81124bb4 <sprintf>
								debug(fp, cPUSDebug );
81114b88:	d0a06217 	ldw	r2,-32376(gp)
81114b8c:	e0ffdec4 	addi	r3,fp,-133
81114b90:	180b883a 	mov	r5,r3
81114b94:	1009883a 	mov	r4,r2
81114b98:	11232a00 	call	811232a0 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
81114b9c:	00023806 	br	81115480 <vParserCommTask+0xfa8>
								debug(fp, cPUSDebug );
							}
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81114ba0:	00a04574 	movhi	r2,33045
81114ba4:	10942604 	addi	r2,r2,20632
81114ba8:	10800483 	ldbu	r2,18(r2)
81114bac:	10c03fcc 	andi	r3,r2,255
81114bb0:	00a04574 	movhi	r2,33045
81114bb4:	10942604 	addi	r2,r2,20632
81114bb8:	18c00284 	addi	r3,r3,10
81114bbc:	18c7883a 	add	r3,r3,r3
81114bc0:	10c5883a 	add	r2,r2,r3
81114bc4:	e0ffde0b 	ldhu	r3,-136(fp)
81114bc8:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
81114bcc:	00a04574 	movhi	r2,33045
81114bd0:	10942604 	addi	r2,r2,20632
81114bd4:	10800483 	ldbu	r2,18(r2)
81114bd8:	10800044 	addi	r2,r2,1
81114bdc:	1007883a 	mov	r3,r2
81114be0:	00a04574 	movhi	r2,33045
81114be4:	10942604 	addi	r2,r2,20632
81114be8:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
81114bec:	00a04574 	movhi	r2,33045
81114bf0:	10942604 	addi	r2,r2,20632
81114bf4:	1080038b 	ldhu	r2,14(r2)
81114bf8:	10bfffcc 	andi	r2,r2,65535
81114bfc:	10c000a0 	cmpeqi	r3,r2,2
81114c00:	18001f1e 	bne	r3,zero,81114c80 <vParserCommTask+0x7a8>
81114c04:	10c00160 	cmpeqi	r3,r2,5
81114c08:	1800381e 	bne	r3,zero,81114cec <vParserCommTask+0x814>
81114c0c:	10800060 	cmpeqi	r2,r2,1
81114c10:	10005126 	beq	r2,zero,81114d58 <vParserCommTask+0x880>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114c14:	00a045f4 	movhi	r2,33047
81114c18:	10a25304 	addi	r2,r2,-30388
81114c1c:	10800a8b 	ldhu	r2,42(r2)
81114c20:	10bfffcc 	andi	r2,r2,65535
81114c24:	108000e8 	cmpgeui	r2,r2,3
81114c28:	1000111e 	bne	r2,zero,81114c70 <vParserCommTask+0x798>
										memset(cPUSDebug,0,128);
81114c2c:	e0bfdec4 	addi	r2,fp,-133
81114c30:	01802004 	movi	r6,128
81114c34:	000b883a 	mov	r5,zero
81114c38:	1009883a 	mov	r4,r2
81114c3c:	11244a00 	call	811244a0 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114c40:	e0ffde0b 	ldhu	r3,-136(fp)
81114c44:	e0bfdec4 	addi	r2,fp,-133
81114c48:	180d883a 	mov	r6,r3
81114c4c:	01604574 	movhi	r5,33045
81114c50:	297da804 	addi	r5,r5,-2400
81114c54:	1009883a 	mov	r4,r2
81114c58:	1124bb40 	call	81124bb4 <sprintf>
										debug(fp, cPUSDebug );
81114c5c:	d0a06217 	ldw	r2,-32376(gp)
81114c60:	e0ffdec4 	addi	r3,fp,-133
81114c64:	180b883a 	mov	r5,r3
81114c68:	1009883a 	mov	r4,r2
81114c6c:	11232a00 	call	811232a0 <fprintf>
									}
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
81114c70:	01204574 	movhi	r4,33045
81114c74:	21142604 	addi	r4,r4,20632
81114c78:	11155b00 	call	811155b0 <bSendMessagePUStoMebTask>

									break;
81114c7c:	00005d06 	br	81114df4 <vParserCommTask+0x91c>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114c80:	00a045f4 	movhi	r2,33047
81114c84:	10a25304 	addi	r2,r2,-30388
81114c88:	10800a8b 	ldhu	r2,42(r2)
81114c8c:	10bfffcc 	andi	r2,r2,65535
81114c90:	108000e8 	cmpgeui	r2,r2,3
81114c94:	1000111e 	bne	r2,zero,81114cdc <vParserCommTask+0x804>
										memset(cPUSDebug,0,128);
81114c98:	e0bfdec4 	addi	r2,fp,-133
81114c9c:	01802004 	movi	r6,128
81114ca0:	000b883a 	mov	r5,zero
81114ca4:	1009883a 	mov	r4,r2
81114ca8:	11244a00 	call	811244a0 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114cac:	e0ffde0b 	ldhu	r3,-136(fp)
81114cb0:	e0bfdec4 	addi	r2,fp,-133
81114cb4:	180d883a 	mov	r6,r3
81114cb8:	01604574 	movhi	r5,33045
81114cbc:	297db804 	addi	r5,r5,-2336
81114cc0:	1009883a 	mov	r4,r2
81114cc4:	1124bb40 	call	81124bb4 <sprintf>
										debug(fp, cPUSDebug );
81114cc8:	d0a06217 	ldw	r2,-32376(gp)
81114ccc:	e0ffdec4 	addi	r3,fp,-133
81114cd0:	180b883a 	mov	r5,r3
81114cd4:	1009883a 	mov	r4,r2
81114cd8:	11232a00 	call	811232a0 <fprintf>
									}
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81114cdc:	01204574 	movhi	r4,33045
81114ce0:	21142604 	addi	r4,r4,20632
81114ce4:	11155b00 	call	811155b0 <bSendMessagePUStoMebTask>

									break;
81114ce8:	00004206 	br	81114df4 <vParserCommTask+0x91c>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114cec:	00a045f4 	movhi	r2,33047
81114cf0:	10a25304 	addi	r2,r2,-30388
81114cf4:	10800a8b 	ldhu	r2,42(r2)
81114cf8:	10bfffcc 	andi	r2,r2,65535
81114cfc:	108000e8 	cmpgeui	r2,r2,3
81114d00:	1000111e 	bne	r2,zero,81114d48 <vParserCommTask+0x870>
										memset(cPUSDebug,0,128);
81114d04:	e0bfdec4 	addi	r2,fp,-133
81114d08:	01802004 	movi	r6,128
81114d0c:	000b883a 	mov	r5,zero
81114d10:	1009883a 	mov	r4,r2
81114d14:	11244a00 	call	811244a0 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114d18:	e0ffde0b 	ldhu	r3,-136(fp)
81114d1c:	e0bfdec4 	addi	r2,fp,-133
81114d20:	180d883a 	mov	r6,r3
81114d24:	01604574 	movhi	r5,33045
81114d28:	297dc804 	addi	r5,r5,-2272
81114d2c:	1009883a 	mov	r4,r2
81114d30:	1124bb40 	call	81124bb4 <sprintf>
										debug(fp, cPUSDebug );
81114d34:	d0a06217 	ldw	r2,-32376(gp)
81114d38:	e0ffdec4 	addi	r3,fp,-133
81114d3c:	180b883a 	mov	r5,r3
81114d40:	1009883a 	mov	r4,r2
81114d44:	11232a00 	call	811232a0 <fprintf>
									}
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81114d48:	01204574 	movhi	r4,33045
81114d4c:	21142604 	addi	r4,r4,20632
81114d50:	11155b00 	call	811155b0 <bSendMessagePUStoMebTask>

									break;
81114d54:	00002706 	br	81114df4 <vParserCommTask+0x91c>
								default:
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114d58:	00a045f4 	movhi	r2,33047
81114d5c:	10a25304 	addi	r2,r2,-30388
81114d60:	10800a8b 	ldhu	r2,42(r2)
81114d64:	10bfffcc 	andi	r2,r2,65535
81114d68:	108000e8 	cmpgeui	r2,r2,3
81114d6c:	10001e1e 	bne	r2,zero,81114de8 <vParserCommTask+0x910>
										memset(cPUSDebug,0,128);
81114d70:	e0bfdec4 	addi	r2,fp,-133
81114d74:	01802004 	movi	r6,128
81114d78:	000b883a 	mov	r5,zero
81114d7c:	1009883a 	mov	r4,r2
81114d80:	11244a00 	call	811244a0 <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81114d84:	00a04574 	movhi	r2,33045
81114d88:	10942604 	addi	r2,r2,20632
81114d8c:	1080030b 	ldhu	r2,12(r2)
81114d90:	113fffcc 	andi	r4,r2,65535
81114d94:	00a04574 	movhi	r2,33045
81114d98:	10942604 	addi	r2,r2,20632
81114d9c:	1080038b 	ldhu	r2,14(r2)
81114da0:	117fffcc 	andi	r5,r2,65535
81114da4:	00a04574 	movhi	r2,33045
81114da8:	10942604 	addi	r2,r2,20632
81114dac:	1080040b 	ldhu	r2,16(r2)
81114db0:	10bfffcc 	andi	r2,r2,65535
81114db4:	e0ffdec4 	addi	r3,fp,-133
81114db8:	d8800015 	stw	r2,0(sp)
81114dbc:	280f883a 	mov	r7,r5
81114dc0:	200d883a 	mov	r6,r4
81114dc4:	01604574 	movhi	r5,33045
81114dc8:	297d6804 	addi	r5,r5,-2656
81114dcc:	1809883a 	mov	r4,r3
81114dd0:	1124bb40 	call	81124bb4 <sprintf>
										debug(fp, cPUSDebug );
81114dd4:	d0a06217 	ldw	r2,-32376(gp)
81114dd8:	e0ffdec4 	addi	r3,fp,-133
81114ddc:	180b883a 	mov	r5,r3
81114de0:	1009883a 	mov	r4,r2
81114de4:	11232a00 	call	811232a0 <fprintf>
									}
									#endif							
									eParserMode = sWaitingMessage;
81114de8:	00800044 	movi	r2,1
81114dec:	e0bfdc15 	stw	r2,-144(fp)
									break;
81114df0:	0001883a 	nop
							}
						}
                        break;
81114df4:	0001a206 	br	81115480 <vParserCommTask+0xfa8>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81114df8:	00a04574 	movhi	r2,33045
81114dfc:	10941304 	addi	r2,r2,20556
81114e00:	1080050b 	ldhu	r2,20(r2)
81114e04:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81114e08:	00a04574 	movhi	r2,33045
81114e0c:	10942604 	addi	r2,r2,20632
81114e10:	10800483 	ldbu	r2,18(r2)
81114e14:	10c03fcc 	andi	r3,r2,255
81114e18:	00a04574 	movhi	r2,33045
81114e1c:	10942604 	addi	r2,r2,20632
81114e20:	18c00284 	addi	r3,r3,10
81114e24:	18c7883a 	add	r3,r3,r3
81114e28:	10c5883a 	add	r2,r2,r3
81114e2c:	e0ffde0b 	ldhu	r3,-136(fp)
81114e30:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
81114e34:	00a04574 	movhi	r2,33045
81114e38:	10942604 	addi	r2,r2,20632
81114e3c:	10800483 	ldbu	r2,18(r2)
81114e40:	10800044 	addi	r2,r2,1
81114e44:	1007883a 	mov	r3,r2
81114e48:	00a04574 	movhi	r2,33045
81114e4c:	10942604 	addi	r2,r2,20632
81114e50:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
81114e54:	00a04574 	movhi	r2,33045
81114e58:	10942604 	addi	r2,r2,20632
81114e5c:	1080038b 	ldhu	r2,14(r2)
81114e60:	10bfffcc 	andi	r2,r2,65535
81114e64:	10c000e0 	cmpeqi	r3,r2,3
81114e68:	18000a1e 	bne	r3,zero,81114e94 <vParserCommTask+0x9bc>
81114e6c:	10c00108 	cmpgei	r3,r2,4
81114e70:	1800031e 	bne	r3,zero,81114e80 <vParserCommTask+0x9a8>
81114e74:	108000a0 	cmpeqi	r2,r2,2
81114e78:	1000571e 	bne	r2,zero,81114fd8 <vParserCommTask+0xb00>
81114e7c:	00015406 	br	811153d0 <vParserCommTask+0xef8>
81114e80:	10c00120 	cmpeqi	r3,r2,4
81114e84:	18001e1e 	bne	r3,zero,81114f00 <vParserCommTask+0xa28>
81114e88:	10800160 	cmpeqi	r2,r2,5
81114e8c:	1000371e 	bne	r2,zero,81114f6c <vParserCommTask+0xa94>
81114e90:	00014f06 	br	811153d0 <vParserCommTask+0xef8>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114e94:	00a045f4 	movhi	r2,33047
81114e98:	10a25304 	addi	r2,r2,-30388
81114e9c:	10800a8b 	ldhu	r2,42(r2)
81114ea0:	10bfffcc 	andi	r2,r2,65535
81114ea4:	108000e8 	cmpgeui	r2,r2,3
81114ea8:	1000111e 	bne	r2,zero,81114ef0 <vParserCommTask+0xa18>
									memset(cPUSDebug,0,128);
81114eac:	e0bfdec4 	addi	r2,fp,-133
81114eb0:	01802004 	movi	r6,128
81114eb4:	000b883a 	mov	r5,zero
81114eb8:	1009883a 	mov	r4,r2
81114ebc:	11244a00 	call	811244a0 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114ec0:	e0ffde0b 	ldhu	r3,-136(fp)
81114ec4:	e0bfdec4 	addi	r2,fp,-133
81114ec8:	180d883a 	mov	r6,r3
81114ecc:	01604574 	movhi	r5,33045
81114ed0:	297dda04 	addi	r5,r5,-2200
81114ed4:	1009883a 	mov	r4,r2
81114ed8:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
81114edc:	d0a06217 	ldw	r2,-32376(gp)
81114ee0:	e0ffdec4 	addi	r3,fp,-133
81114ee4:	180b883a 	mov	r5,r3
81114ee8:	1009883a 	mov	r4,r2
81114eec:	11232a00 	call	811232a0 <fprintf>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114ef0:	01204574 	movhi	r4,33045
81114ef4:	21142604 	addi	r4,r4,20632
81114ef8:	11155b00 	call	811155b0 <bSendMessagePUStoMebTask>

								break;
81114efc:	00015c06 	br	81115470 <vParserCommTask+0xf98>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114f00:	00a045f4 	movhi	r2,33047
81114f04:	10a25304 	addi	r2,r2,-30388
81114f08:	10800a8b 	ldhu	r2,42(r2)
81114f0c:	10bfffcc 	andi	r2,r2,65535
81114f10:	108000e8 	cmpgeui	r2,r2,3
81114f14:	1000111e 	bne	r2,zero,81114f5c <vParserCommTask+0xa84>
									memset(cPUSDebug,0,128);
81114f18:	e0bfdec4 	addi	r2,fp,-133
81114f1c:	01802004 	movi	r6,128
81114f20:	000b883a 	mov	r5,zero
81114f24:	1009883a 	mov	r4,r2
81114f28:	11244a00 	call	811244a0 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114f2c:	e0ffde0b 	ldhu	r3,-136(fp)
81114f30:	e0bfdec4 	addi	r2,fp,-133
81114f34:	180d883a 	mov	r6,r3
81114f38:	01604574 	movhi	r5,33045
81114f3c:	297dea04 	addi	r5,r5,-2136
81114f40:	1009883a 	mov	r4,r2
81114f44:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
81114f48:	d0a06217 	ldw	r2,-32376(gp)
81114f4c:	e0ffdec4 	addi	r3,fp,-133
81114f50:	180b883a 	mov	r5,r3
81114f54:	1009883a 	mov	r4,r2
81114f58:	11232a00 	call	811232a0 <fprintf>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114f5c:	01204574 	movhi	r4,33045
81114f60:	21142604 	addi	r4,r4,20632
81114f64:	11155b00 	call	811155b0 <bSendMessagePUStoMebTask>

								break;
81114f68:	00014106 	br	81115470 <vParserCommTask+0xf98>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114f6c:	00a045f4 	movhi	r2,33047
81114f70:	10a25304 	addi	r2,r2,-30388
81114f74:	10800a8b 	ldhu	r2,42(r2)
81114f78:	10bfffcc 	andi	r2,r2,65535
81114f7c:	108000e8 	cmpgeui	r2,r2,3
81114f80:	1000111e 	bne	r2,zero,81114fc8 <vParserCommTask+0xaf0>
									memset(cPUSDebug,0,128);
81114f84:	e0bfdec4 	addi	r2,fp,-133
81114f88:	01802004 	movi	r6,128
81114f8c:	000b883a 	mov	r5,zero
81114f90:	1009883a 	mov	r4,r2
81114f94:	11244a00 	call	811244a0 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114f98:	e0ffde0b 	ldhu	r3,-136(fp)
81114f9c:	e0bfdec4 	addi	r2,fp,-133
81114fa0:	180d883a 	mov	r6,r3
81114fa4:	01604574 	movhi	r5,33045
81114fa8:	297dfa04 	addi	r5,r5,-2072
81114fac:	1009883a 	mov	r4,r2
81114fb0:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
81114fb4:	d0a06217 	ldw	r2,-32376(gp)
81114fb8:	e0ffdec4 	addi	r3,fp,-133
81114fbc:	180b883a 	mov	r5,r3
81114fc0:	1009883a 	mov	r4,r2
81114fc4:	11232a00 	call	811232a0 <fprintf>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114fc8:	01204574 	movhi	r4,33045
81114fcc:	21142604 	addi	r4,r4,20632
81114fd0:	11155b00 	call	811155b0 <bSendMessagePUStoMebTask>

								break;
81114fd4:	00012606 	br	81115470 <vParserCommTask+0xf98>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
81114fd8:	00a04574 	movhi	r2,33045
81114fdc:	10942604 	addi	r2,r2,20632
81114fe0:	10800483 	ldbu	r2,18(r2)
81114fe4:	10c03fcc 	andi	r3,r2,255
81114fe8:	00a04574 	movhi	r2,33045
81114fec:	10941304 	addi	r2,r2,20556
81114ff0:	1100058b 	ldhu	r4,22(r2)
81114ff4:	00a04574 	movhi	r2,33045
81114ff8:	10942604 	addi	r2,r2,20632
81114ffc:	18c00284 	addi	r3,r3,10
81115000:	18c7883a 	add	r3,r3,r3
81115004:	10c5883a 	add	r2,r2,r3
81115008:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8111500c:	00a04574 	movhi	r2,33045
81115010:	10942604 	addi	r2,r2,20632
81115014:	10800483 	ldbu	r2,18(r2)
81115018:	10800044 	addi	r2,r2,1
8111501c:	1007883a 	mov	r3,r2
81115020:	00a04574 	movhi	r2,33045
81115024:	10942604 	addi	r2,r2,20632
81115028:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
8111502c:	00a04574 	movhi	r2,33045
81115030:	10942604 	addi	r2,r2,20632
81115034:	10800483 	ldbu	r2,18(r2)
81115038:	10c03fcc 	andi	r3,r2,255
8111503c:	00a04574 	movhi	r2,33045
81115040:	10941304 	addi	r2,r2,20556
81115044:	1100060b 	ldhu	r4,24(r2)
81115048:	00a04574 	movhi	r2,33045
8111504c:	10942604 	addi	r2,r2,20632
81115050:	18c00284 	addi	r3,r3,10
81115054:	18c7883a 	add	r3,r3,r3
81115058:	10c5883a 	add	r2,r2,r3
8111505c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81115060:	00a04574 	movhi	r2,33045
81115064:	10942604 	addi	r2,r2,20632
81115068:	10800483 	ldbu	r2,18(r2)
8111506c:	10800044 	addi	r2,r2,1
81115070:	1007883a 	mov	r3,r2
81115074:	00a04574 	movhi	r2,33045
81115078:	10942604 	addi	r2,r2,20632
8111507c:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
81115080:	00a04574 	movhi	r2,33045
81115084:	10942604 	addi	r2,r2,20632
81115088:	10800483 	ldbu	r2,18(r2)
8111508c:	10c03fcc 	andi	r3,r2,255
81115090:	00a04574 	movhi	r2,33045
81115094:	10941304 	addi	r2,r2,20556
81115098:	1100068b 	ldhu	r4,26(r2)
8111509c:	00a04574 	movhi	r2,33045
811150a0:	10942604 	addi	r2,r2,20632
811150a4:	18c00284 	addi	r3,r3,10
811150a8:	18c7883a 	add	r3,r3,r3
811150ac:	10c5883a 	add	r2,r2,r3
811150b0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811150b4:	00a04574 	movhi	r2,33045
811150b8:	10942604 	addi	r2,r2,20632
811150bc:	10800483 	ldbu	r2,18(r2)
811150c0:	10800044 	addi	r2,r2,1
811150c4:	1007883a 	mov	r3,r2
811150c8:	00a04574 	movhi	r2,33045
811150cc:	10942604 	addi	r2,r2,20632
811150d0:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
811150d4:	00a04574 	movhi	r2,33045
811150d8:	10942604 	addi	r2,r2,20632
811150dc:	10800483 	ldbu	r2,18(r2)
811150e0:	10c03fcc 	andi	r3,r2,255
811150e4:	00a04574 	movhi	r2,33045
811150e8:	10941304 	addi	r2,r2,20556
811150ec:	1100070b 	ldhu	r4,28(r2)
811150f0:	00a04574 	movhi	r2,33045
811150f4:	10942604 	addi	r2,r2,20632
811150f8:	18c00284 	addi	r3,r3,10
811150fc:	18c7883a 	add	r3,r3,r3
81115100:	10c5883a 	add	r2,r2,r3
81115104:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81115108:	00a04574 	movhi	r2,33045
8111510c:	10942604 	addi	r2,r2,20632
81115110:	10800483 	ldbu	r2,18(r2)
81115114:	10800044 	addi	r2,r2,1
81115118:	1007883a 	mov	r3,r2
8111511c:	00a04574 	movhi	r2,33045
81115120:	10942604 	addi	r2,r2,20632
81115124:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
81115128:	00a04574 	movhi	r2,33045
8111512c:	10942604 	addi	r2,r2,20632
81115130:	10800483 	ldbu	r2,18(r2)
81115134:	10c03fcc 	andi	r3,r2,255
81115138:	00a04574 	movhi	r2,33045
8111513c:	10941304 	addi	r2,r2,20556
81115140:	1100078b 	ldhu	r4,30(r2)
81115144:	00a04574 	movhi	r2,33045
81115148:	10942604 	addi	r2,r2,20632
8111514c:	18c00284 	addi	r3,r3,10
81115150:	18c7883a 	add	r3,r3,r3
81115154:	10c5883a 	add	r2,r2,r3
81115158:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8111515c:	00a04574 	movhi	r2,33045
81115160:	10942604 	addi	r2,r2,20632
81115164:	10800483 	ldbu	r2,18(r2)
81115168:	10800044 	addi	r2,r2,1
8111516c:	1007883a 	mov	r3,r2
81115170:	00a04574 	movhi	r2,33045
81115174:	10942604 	addi	r2,r2,20632
81115178:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
8111517c:	00a04574 	movhi	r2,33045
81115180:	10942604 	addi	r2,r2,20632
81115184:	10800483 	ldbu	r2,18(r2)
81115188:	10c03fcc 	andi	r3,r2,255
8111518c:	00a04574 	movhi	r2,33045
81115190:	10941304 	addi	r2,r2,20556
81115194:	1100080b 	ldhu	r4,32(r2)
81115198:	00a04574 	movhi	r2,33045
8111519c:	10942604 	addi	r2,r2,20632
811151a0:	18c00284 	addi	r3,r3,10
811151a4:	18c7883a 	add	r3,r3,r3
811151a8:	10c5883a 	add	r2,r2,r3
811151ac:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811151b0:	00a04574 	movhi	r2,33045
811151b4:	10942604 	addi	r2,r2,20632
811151b8:	10800483 	ldbu	r2,18(r2)
811151bc:	10800044 	addi	r2,r2,1
811151c0:	1007883a 	mov	r3,r2
811151c4:	00a04574 	movhi	r2,33045
811151c8:	10942604 	addi	r2,r2,20632
811151cc:	10c00485 	stb	r3,18(r2)


								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811151d0:	00a045f4 	movhi	r2,33047
811151d4:	10a25304 	addi	r2,r2,-30388
811151d8:	10800a8b 	ldhu	r2,42(r2)
811151dc:	10bfffcc 	andi	r2,r2,65535
811151e0:	108000e8 	cmpgeui	r2,r2,3
811151e4:	1000a11e 	bne	r2,zero,8111546c <vParserCommTask+0xf94>
									memset(cPUSDebug,0,128);
811151e8:	e0bfdec4 	addi	r2,fp,-133
811151ec:	01802004 	movi	r6,128
811151f0:	000b883a 	mov	r5,zero
811151f4:	1009883a 	mov	r4,r2
811151f8:	11244a00 	call	811244a0 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
811151fc:	e0ffdec4 	addi	r3,fp,-133
81115200:	00a04574 	movhi	r2,33045
81115204:	10be0904 	addi	r2,r2,-2012
81115208:	1009883a 	mov	r4,r2
8111520c:	00800b84 	movi	r2,46
81115210:	100d883a 	mov	r6,r2
81115214:	200b883a 	mov	r5,r4
81115218:	1809883a 	mov	r4,r3
8111521c:	11243500 	call	81124350 <memcpy>
									debug(fp, cPUSDebug );
81115220:	d0a06217 	ldw	r2,-32376(gp)
81115224:	e0ffdec4 	addi	r3,fp,-133
81115228:	180b883a 	mov	r5,r3
8111522c:	1009883a 	mov	r4,r2
81115230:	11232a00 	call	811232a0 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81115234:	e0ffde0b 	ldhu	r3,-136(fp)
81115238:	e0bfdec4 	addi	r2,fp,-133
8111523c:	180d883a 	mov	r6,r3
81115240:	01604574 	movhi	r5,33045
81115244:	297e1504 	addi	r5,r5,-1964
81115248:	1009883a 	mov	r4,r2
8111524c:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
81115250:	d0a06217 	ldw	r2,-32376(gp)
81115254:	e0ffdec4 	addi	r3,fp,-133
81115258:	180b883a 	mov	r5,r3
8111525c:	1009883a 	mov	r4,r2
81115260:	11232a00 	call	811232a0 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
81115264:	00a04574 	movhi	r2,33045
81115268:	10941304 	addi	r2,r2,20556
8111526c:	1080058b 	ldhu	r2,22(r2)
81115270:	10ffffcc 	andi	r3,r2,65535
81115274:	e0bfdec4 	addi	r2,fp,-133
81115278:	180d883a 	mov	r6,r3
8111527c:	01604574 	movhi	r5,33045
81115280:	297e1c04 	addi	r5,r5,-1936
81115284:	1009883a 	mov	r4,r2
81115288:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
8111528c:	d0a06217 	ldw	r2,-32376(gp)
81115290:	e0ffdec4 	addi	r3,fp,-133
81115294:	180b883a 	mov	r5,r3
81115298:	1009883a 	mov	r4,r2
8111529c:	11232a00 	call	811232a0 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
811152a0:	00a04574 	movhi	r2,33045
811152a4:	10941304 	addi	r2,r2,20556
811152a8:	1080060b 	ldhu	r2,24(r2)
811152ac:	10ffffcc 	andi	r3,r2,65535
811152b0:	e0bfdec4 	addi	r2,fp,-133
811152b4:	180d883a 	mov	r6,r3
811152b8:	01604574 	movhi	r5,33045
811152bc:	297e2004 	addi	r5,r5,-1920
811152c0:	1009883a 	mov	r4,r2
811152c4:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
811152c8:	d0a06217 	ldw	r2,-32376(gp)
811152cc:	e0ffdec4 	addi	r3,fp,-133
811152d0:	180b883a 	mov	r5,r3
811152d4:	1009883a 	mov	r4,r2
811152d8:	11232a00 	call	811232a0 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
811152dc:	00a04574 	movhi	r2,33045
811152e0:	10941304 	addi	r2,r2,20556
811152e4:	1080068b 	ldhu	r2,26(r2)
811152e8:	10ffffcc 	andi	r3,r2,65535
811152ec:	e0bfdec4 	addi	r2,fp,-133
811152f0:	180d883a 	mov	r6,r3
811152f4:	01604574 	movhi	r5,33045
811152f8:	297e2504 	addi	r5,r5,-1900
811152fc:	1009883a 	mov	r4,r2
81115300:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
81115304:	d0a06217 	ldw	r2,-32376(gp)
81115308:	e0ffdec4 	addi	r3,fp,-133
8111530c:	180b883a 	mov	r5,r3
81115310:	1009883a 	mov	r4,r2
81115314:	11232a00 	call	811232a0 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
81115318:	00a04574 	movhi	r2,33045
8111531c:	10941304 	addi	r2,r2,20556
81115320:	1080070b 	ldhu	r2,28(r2)
81115324:	10ffffcc 	andi	r3,r2,65535
81115328:	e0bfdec4 	addi	r2,fp,-133
8111532c:	180d883a 	mov	r6,r3
81115330:	01604574 	movhi	r5,33045
81115334:	297e2c04 	addi	r5,r5,-1872
81115338:	1009883a 	mov	r4,r2
8111533c:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
81115340:	d0a06217 	ldw	r2,-32376(gp)
81115344:	e0ffdec4 	addi	r3,fp,-133
81115348:	180b883a 	mov	r5,r3
8111534c:	1009883a 	mov	r4,r2
81115350:	11232a00 	call	811232a0 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
81115354:	00a04574 	movhi	r2,33045
81115358:	10941304 	addi	r2,r2,20556
8111535c:	1080078b 	ldhu	r2,30(r2)
81115360:	10ffffcc 	andi	r3,r2,65535
81115364:	e0bfdec4 	addi	r2,fp,-133
81115368:	180d883a 	mov	r6,r3
8111536c:	01604574 	movhi	r5,33045
81115370:	297e3304 	addi	r5,r5,-1844
81115374:	1009883a 	mov	r4,r2
81115378:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
8111537c:	d0a06217 	ldw	r2,-32376(gp)
81115380:	e0ffdec4 	addi	r3,fp,-133
81115384:	180b883a 	mov	r5,r3
81115388:	1009883a 	mov	r4,r2
8111538c:	11232a00 	call	811232a0 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
81115390:	00a04574 	movhi	r2,33045
81115394:	10941304 	addi	r2,r2,20556
81115398:	1080080b 	ldhu	r2,32(r2)
8111539c:	10ffffcc 	andi	r3,r2,65535
811153a0:	e0bfdec4 	addi	r2,fp,-133
811153a4:	180d883a 	mov	r6,r3
811153a8:	01604574 	movhi	r5,33045
811153ac:	297e3904 	addi	r5,r5,-1820
811153b0:	1009883a 	mov	r4,r2
811153b4:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
811153b8:	d0a06217 	ldw	r2,-32376(gp)
811153bc:	e0ffdec4 	addi	r3,fp,-133
811153c0:	180b883a 	mov	r5,r3
811153c4:	1009883a 	mov	r4,r2
811153c8:	11232a00 	call	811232a0 <fprintf>
								}
								#endif

								break;
811153cc:	00002706 	br	8111546c <vParserCommTask+0xf94>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811153d0:	00a045f4 	movhi	r2,33047
811153d4:	10a25304 	addi	r2,r2,-30388
811153d8:	10800a8b 	ldhu	r2,42(r2)
811153dc:	10bfffcc 	andi	r2,r2,65535
811153e0:	108000e8 	cmpgeui	r2,r2,3
811153e4:	10001e1e 	bne	r2,zero,81115460 <vParserCommTask+0xf88>
									memset(cPUSDebug,0,128);
811153e8:	e0bfdec4 	addi	r2,fp,-133
811153ec:	01802004 	movi	r6,128
811153f0:	000b883a 	mov	r5,zero
811153f4:	1009883a 	mov	r4,r2
811153f8:	11244a00 	call	811244a0 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811153fc:	00a04574 	movhi	r2,33045
81115400:	10942604 	addi	r2,r2,20632
81115404:	1080030b 	ldhu	r2,12(r2)
81115408:	113fffcc 	andi	r4,r2,65535
8111540c:	00a04574 	movhi	r2,33045
81115410:	10942604 	addi	r2,r2,20632
81115414:	1080038b 	ldhu	r2,14(r2)
81115418:	117fffcc 	andi	r5,r2,65535
8111541c:	00a04574 	movhi	r2,33045
81115420:	10942604 	addi	r2,r2,20632
81115424:	1080040b 	ldhu	r2,16(r2)
81115428:	10bfffcc 	andi	r2,r2,65535
8111542c:	e0ffdec4 	addi	r3,fp,-133
81115430:	d8800015 	stw	r2,0(sp)
81115434:	280f883a 	mov	r7,r5
81115438:	200d883a 	mov	r6,r4
8111543c:	01604574 	movhi	r5,33045
81115440:	297d6804 	addi	r5,r5,-2656
81115444:	1809883a 	mov	r4,r3
81115448:	1124bb40 	call	81124bb4 <sprintf>
									debug(fp, cPUSDebug );
8111544c:	d0a06217 	ldw	r2,-32376(gp)
81115450:	e0ffdec4 	addi	r3,fp,-133
81115454:	180b883a 	mov	r5,r3
81115458:	1009883a 	mov	r4,r2
8111545c:	11232a00 	call	811232a0 <fprintf>
								}
								#endif							
								eParserMode = sWaitingMessage;
81115460:	00800044 	movi	r2,1
81115464:	e0bfdc15 	stw	r2,-144(fp)
								break;
81115468:	00000106 	br	81115470 <vParserCommTask+0xf98>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
									debug(fp, cPUSDebug );
								}
								#endif

								break;
8111546c:	0001883a 	nop
								}
								#endif							
								eParserMode = sWaitingMessage;
								break;
						}
                        break;
81115470:	00000406 	br	81115484 <vParserCommTask+0xfac>
                    default:
						eParserMode = sWaitingMessage;
81115474:	00800044 	movi	r2,1
81115478:	e0bfdc15 	stw	r2,-144(fp)
                        break;
8111547c:	00000106 	br	81115484 <vParserCommTask+0xfac>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
81115480:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;				
81115484:	00000306 	br	81115494 <vParserCommTask+0xfbc>
			default:
				eParserMode = sWaitingMessage;
81115488:	00800044 	movi	r2,1
8111548c:	e0bfdc15 	stw	r2,-144(fp)
				break;
81115490:	0001883a 	nop
		}
	}
81115494:	003c2606 	br	81114530 <__reset+0xfb0f4530>

81115498 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
81115498:	defffb04 	addi	sp,sp,-20
8111549c:	de00012e 	bgeu	sp,et,811154a4 <getPreParsedPacket+0xc>
811154a0:	003b68fa 	trap	3
811154a4:	dfc00415 	stw	ra,16(sp)
811154a8:	df000315 	stw	fp,12(sp)
811154ac:	df000304 	addi	fp,sp,12
811154b0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811154b4:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
811154b8:	d0a06b17 	ldw	r2,-32340(gp)
811154bc:	e0fffe44 	addi	r3,fp,-7
811154c0:	180d883a 	mov	r6,r3
811154c4:	000b883a 	mov	r5,zero
811154c8:	1009883a 	mov	r4,r2
811154cc:	113e7500 	call	8113e750 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
811154d0:	e0bffe43 	ldbu	r2,-7(fp)
811154d4:	10803fcc 	andi	r2,r2,255
811154d8:	10002e1e 	bne	r2,zero,81115594 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
811154dc:	e03ffe05 	stb	zero,-8(fp)
811154e0:	00002506 	br	81115578 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
811154e4:	e0fffe03 	ldbu	r3,-8(fp)
811154e8:	00a045f4 	movhi	r2,33047
811154ec:	10a1ab04 	addi	r2,r2,-31060
811154f0:	18c01324 	muli	r3,r3,76
811154f4:	10c5883a 	add	r2,r2,r3
811154f8:	10800104 	addi	r2,r2,4
811154fc:	10800003 	ldbu	r2,0(r2)
81115500:	10803fcc 	andi	r2,r2,255
81115504:	1080201c 	xori	r2,r2,128
81115508:	10bfe004 	addi	r2,r2,-128
8111550c:	10001726 	beq	r2,zero,8111556c <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
81115510:	e0fffe03 	ldbu	r3,-8(fp)
81115514:	e13fff17 	ldw	r4,-4(fp)
81115518:	00a045f4 	movhi	r2,33047
8111551c:	10a1ab04 	addi	r2,r2,-31060
81115520:	18c01324 	muli	r3,r3,76
81115524:	10c5883a 	add	r2,r2,r3
81115528:	2007883a 	mov	r3,r4
8111552c:	1009883a 	mov	r4,r2
81115530:	00801304 	movi	r2,76
81115534:	100d883a 	mov	r6,r2
81115538:	200b883a 	mov	r5,r4
8111553c:	1809883a 	mov	r4,r3
81115540:	11243500 	call	81124350 <memcpy>
                bSuccess = TRUE;
81115544:	00800044 	movi	r2,1
81115548:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
8111554c:	e0fffe03 	ldbu	r3,-8(fp)
81115550:	00a045f4 	movhi	r2,33047
81115554:	10a1ab04 	addi	r2,r2,-31060
81115558:	18c01324 	muli	r3,r3,76
8111555c:	10c5883a 	add	r2,r2,r3
81115560:	10800104 	addi	r2,r2,4
81115564:	10000005 	stb	zero,0(r2)
                break;
81115568:	00000606 	br	81115584 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8111556c:	e0bffe03 	ldbu	r2,-8(fp)
81115570:	10800044 	addi	r2,r2,1
81115574:	e0bffe05 	stb	r2,-8(fp)
81115578:	e0bffe03 	ldbu	r2,-8(fp)
8111557c:	10800230 	cmpltui	r2,r2,8
81115580:	103fd81e 	bne	r2,zero,811154e4 <__reset+0xfb0f54e4>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
81115584:	d0a06b17 	ldw	r2,-32340(gp)
81115588:	1009883a 	mov	r4,r2
8111558c:	113ecf40 	call	8113ecf4 <OSMutexPost>
81115590:	00000106 	br	81115598 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
81115594:	111d9fc0 	call	8111d9fc <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
81115598:	e0bffd17 	ldw	r2,-12(fp)
}
8111559c:	e037883a 	mov	sp,fp
811155a0:	dfc00117 	ldw	ra,4(sp)
811155a4:	df000017 	ldw	fp,0(sp)
811155a8:	dec00204 	addi	sp,sp,8
811155ac:	f800283a 	ret

811155b0 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
811155b0:	defffa04 	addi	sp,sp,-24
811155b4:	de00012e 	bgeu	sp,et,811155bc <bSendMessagePUStoMebTask+0xc>
811155b8:	003b68fa 	trap	3
811155bc:	dfc00515 	stw	ra,20(sp)
811155c0:	df000415 	stw	fp,16(sp)
811155c4:	df000404 	addi	fp,sp,16
811155c8:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811155cc:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
811155d0:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
811155d4:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
811155d8:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
811155dc:	d0a07317 	ldw	r2,-32308(gp)
811155e0:	e0fffd44 	addi	r3,fp,-11
811155e4:	180d883a 	mov	r6,r3
811155e8:	01400284 	movi	r5,10
811155ec:	1009883a 	mov	r4,r2
811155f0:	113e7500 	call	8113e750 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811155f4:	e0bffd43 	ldbu	r2,-11(fp)
811155f8:	10803fcc 	andi	r2,r2,255
811155fc:	1000401e 	bne	r2,zero,81115700 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
81115600:	e03ffd05 	stb	zero,-12(fp)
81115604:	00003806 	br	811156e8 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
81115608:	e0fffd03 	ldbu	r3,-12(fp)
8111560c:	00a04574 	movhi	r2,33045
81115610:	109ecb04 	addi	r2,r2,31532
81115614:	18c01524 	muli	r3,r3,84
81115618:	10c5883a 	add	r2,r2,r3
8111561c:	10800104 	addi	r2,r2,4
81115620:	10800017 	ldw	r2,0(r2)
81115624:	10002d1e 	bne	r2,zero,811156dc <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
81115628:	e0fffd03 	ldbu	r3,-12(fp)
8111562c:	00a04574 	movhi	r2,33045
81115630:	109ecb04 	addi	r2,r2,31532
81115634:	18c01524 	muli	r3,r3,84
81115638:	10c7883a 	add	r3,r2,r3
8111563c:	e0bfff17 	ldw	r2,-4(fp)
81115640:	1009883a 	mov	r4,r2
81115644:	00801504 	movi	r2,84
81115648:	100d883a 	mov	r6,r2
8111564c:	200b883a 	mov	r5,r4
81115650:	1809883a 	mov	r4,r3
81115654:	11243500 	call	81124350 <memcpy>
            	xPus[i].bInUse = TRUE;
81115658:	e0fffd03 	ldbu	r3,-12(fp)
8111565c:	00a04574 	movhi	r2,33045
81115660:	109ecb04 	addi	r2,r2,31532
81115664:	18c01524 	muli	r3,r3,84
81115668:	10c5883a 	add	r2,r2,r3
8111566c:	10800104 	addi	r2,r2,4
81115670:	00c00044 	movi	r3,1
81115674:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
81115678:	00800044 	movi	r2,1
8111567c:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
81115680:	00800044 	movi	r2,1
81115684:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
81115688:	d0a06917 	ldw	r2,-32348(gp)
8111568c:	e0fffe17 	ldw	r3,-8(fp)
81115690:	180b883a 	mov	r5,r3
81115694:	1009883a 	mov	r4,r2
81115698:	113fc6c0 	call	8113fc6c <OSQPost>
8111569c:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
811156a0:	e0bffd43 	ldbu	r2,-11(fp)
811156a4:	10803fcc 	andi	r2,r2,255
811156a8:	10000926 	beq	r2,zero,811156d0 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
811156ac:	111ec7c0 	call	8111ec7c <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
811156b0:	e0fffd03 	ldbu	r3,-12(fp)
811156b4:	00a04574 	movhi	r2,33045
811156b8:	109ecb04 	addi	r2,r2,31532
811156bc:	18c01524 	muli	r3,r3,84
811156c0:	10c5883a 	add	r2,r2,r3
811156c4:	10800104 	addi	r2,r2,4
811156c8:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
811156cc:	00000906 	br	811156f4 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
811156d0:	00800044 	movi	r2,1
811156d4:	e0bffc15 	stw	r2,-16(fp)
                break;
811156d8:	00000606 	br	811156f4 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
811156dc:	e0bffd03 	ldbu	r2,-12(fp)
811156e0:	10800044 	addi	r2,r2,1
811156e4:	e0bffd05 	stb	r2,-12(fp)
811156e8:	e0bffd03 	ldbu	r2,-12(fp)
811156ec:	10800130 	cmpltui	r2,r2,4
811156f0:	103fc51e 	bne	r2,zero,81115608 <__reset+0xfb0f5608>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
811156f4:	d0a07317 	ldw	r2,-32308(gp)
811156f8:	1009883a 	mov	r4,r2
811156fc:	113ecf40 	call	8113ecf4 <OSMutexPost>
    }

    return bSuccess;
81115700:	e0bffc17 	ldw	r2,-16(fp)
}
81115704:	e037883a 	mov	sp,fp
81115708:	dfc00117 	ldw	ra,4(sp)
8111570c:	df000017 	ldw	fp,0(sp)
81115710:	dec00204 	addi	sp,sp,8
81115714:	f800283a 	ret

81115718 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
81115718:	deffab04 	addi	sp,sp,-340
8111571c:	de00012e 	bgeu	sp,et,81115724 <vReceiverUartTask+0xc>
81115720:	003b68fa 	trap	3
81115724:	dfc05415 	stw	ra,336(sp)
81115728:	df005315 	stw	fp,332(sp)
8111572c:	df005304 	addi	fp,sp,332
81115730:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81115734:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81115738:	00a045f4 	movhi	r2,33047
8111573c:	10a25304 	addi	r2,r2,-30388
81115740:	10800a8b 	ldhu	r2,42(r2)
81115744:	10bfffcc 	andi	r2,r2,65535
81115748:	10800168 	cmpgeui	r2,r2,5
8111574c:	1000071e 	bne	r2,zero,8111576c <vReceiverUartTask+0x54>
        debug(fp,"Receiver UART Task. (Task on)\n");
81115750:	d0a06217 	ldw	r2,-32376(gp)
81115754:	100f883a 	mov	r7,r2
81115758:	01800784 	movi	r6,30
8111575c:	01400044 	movi	r5,1
81115760:	01204574 	movhi	r4,33045
81115764:	213e3f04 	addi	r4,r4,-1796
81115768:	112393c0 	call	8112393c <fwrite>
    }
    #endif

    eReaderRXMode = sRConfiguring;
8111576c:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
81115770:	e0bfad17 	ldw	r2,-332(fp)
81115774:	10c00060 	cmpeqi	r3,r2,1
81115778:	1800091e 	bne	r3,zero,811157a0 <vReceiverUartTask+0x88>
8111577c:	0080052e 	bgeu	zero,r2,81115794 <vReceiverUartTask+0x7c>
81115780:	10c000a0 	cmpeqi	r3,r2,2
81115784:	1800631e 	bne	r3,zero,81115914 <vReceiverUartTask+0x1fc>
81115788:	108000e0 	cmpeqi	r2,r2,3
8111578c:	1000741e 	bne	r2,zero,81115960 <vReceiverUartTask+0x248>
81115790:	00007d06 	br	81115988 <vReceiverUartTask+0x270>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
81115794:	00800044 	movi	r2,1
81115798:	e0bfad15 	stw	r2,-332(fp)
                break;
8111579c:	00007e06 	br	81115998 <vReceiverUartTask+0x280>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
811157a0:	e0bfaf04 	addi	r2,fp,-324
811157a4:	01802004 	movi	r6,128
811157a8:	000b883a 	mov	r5,zero
811157ac:	1009883a 	mov	r4,r2
811157b0:	11244a00 	call	811244a0 <memset>
                scanf("%s", cReceive);
811157b4:	e0bfcf04 	addi	r2,fp,-196
811157b8:	100b883a 	mov	r5,r2
811157bc:	01204574 	movhi	r4,33045
811157c0:	213e4704 	addi	r4,r4,-1764
811157c4:	1124ad80 	call	81124ad8 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
811157c8:	e0ffcf04 	addi	r3,fp,-196
811157cc:	e0bfaf04 	addi	r2,fp,-324
811157d0:	01801fc4 	movi	r6,127
811157d4:	180b883a 	mov	r5,r3
811157d8:	1009883a 	mov	r4,r2
811157dc:	11243500 	call	81124350 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
811157e0:	e0bfaf04 	addi	r2,fp,-324
811157e4:	01604574 	movhi	r5,33045
811157e8:	29543b04 	addi	r5,r5,20716
811157ec:	1009883a 	mov	r4,r2
811157f0:	1115e080 	call	81115e08 <bPreParserV2>
811157f4:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
811157f8:	e0bfae17 	ldw	r2,-328(fp)
811157fc:	10800058 	cmpnei	r2,r2,1
81115800:	10002e1e 	bne	r2,zero,811158bc <vReceiverUartTask+0x1a4>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
81115804:	00a04574 	movhi	r2,33045
81115808:	10943b04 	addi	r2,r2,20716
8111580c:	10800103 	ldbu	r2,4(r2)
81115810:	10803fcc 	andi	r2,r2,255
81115814:	1080201c 	xori	r2,r2,128
81115818:	10bfe004 	addi	r2,r2,-128
8111581c:	10800fe0 	cmpeqi	r2,r2,63
81115820:	1000081e 	bne	r2,zero,81115844 <vReceiverUartTask+0x12c>
81115824:	00a04574 	movhi	r2,33045
81115828:	10943b04 	addi	r2,r2,20716
8111582c:	10800103 	ldbu	r2,4(r2)
81115830:	10803fcc 	andi	r2,r2,255
81115834:	1080201c 	xori	r2,r2,128
81115838:	10bfe004 	addi	r2,r2,-128
8111583c:	10800858 	cmpnei	r2,r2,33
81115840:	1000031e 	bne	r2,zero,81115850 <vReceiverUartTask+0x138>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
81115844:	00800084 	movi	r2,2
81115848:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8111584c:	00005106 	br	81115994 <vReceiverUartTask+0x27c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
81115850:	00a04574 	movhi	r2,33045
81115854:	10943b04 	addi	r2,r2,20716
81115858:	10800103 	ldbu	r2,4(r2)
8111585c:	10803fcc 	andi	r2,r2,255
81115860:	1080201c 	xori	r2,r2,128
81115864:	10bfe004 	addi	r2,r2,-128
81115868:	108008d8 	cmpnei	r2,r2,35
8111586c:	1000101e 	bne	r2,zero,811158b0 <vReceiverUartTask+0x198>
                            eReaderRXMode = sGetRxUart;
81115870:	00800044 	movi	r2,1
81115874:	e0bfad15 	stw	r2,-332(fp)
                            #if DEBUG_ON
                            if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115878:	00a045f4 	movhi	r2,33047
8111587c:	10a25304 	addi	r2,r2,-30388
81115880:	10800a8b 	ldhu	r2,42(r2)
81115884:	10bfffcc 	andi	r2,r2,65535
81115888:	108000e8 	cmpgeui	r2,r2,3
8111588c:	1000411e 	bne	r2,zero,81115994 <vReceiverUartTask+0x27c>
                                debug(fp,"Nack Received. Do nothing!\n");
81115890:	d0a06217 	ldw	r2,-32376(gp)
81115894:	100f883a 	mov	r7,r2
81115898:	018006c4 	movi	r6,27
8111589c:	01400044 	movi	r5,1
811158a0:	01204574 	movhi	r4,33045
811158a4:	213e4804 	addi	r4,r4,-1760
811158a8:	112393c0 	call	8112393c <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
811158ac:	00003906 	br	81115994 <vReceiverUartTask+0x27c>
                            if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
                                debug(fp,"Nack Received. Do nothing!\n");
                            }
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
811158b0:	008000c4 	movi	r2,3
811158b4:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
811158b8:	00003606 	br	81115994 <vReceiverUartTask+0x27c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
811158bc:	00a04574 	movhi	r2,33045
811158c0:	10943b04 	addi	r2,r2,20716
811158c4:	00c008c4 	movi	r3,35
811158c8:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
811158cc:	00a04574 	movhi	r2,33045
811158d0:	10943b04 	addi	r2,r2,20716
811158d4:	00c00b84 	movi	r3,46
811158d8:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
811158dc:	00a04574 	movhi	r2,33045
811158e0:	10943b04 	addi	r2,r2,20716
811158e4:	00c00044 	movi	r3,1
811158e8:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
811158ec:	01204574 	movhi	r4,33045
811158f0:	21143b04 	addi	r4,r4,20716
811158f4:	1115ad80 	call	81115ad8 <setPreAckSenderFreePos>
811158f8:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
811158fc:	e0bfae17 	ldw	r2,-328(fp)
81115900:	1000011e 	bne	r2,zero,81115908 <vReceiverUartTask+0x1f0>
                        vFailSendNack();
81115904:	111db7c0 	call	8111db7c <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
81115908:	00800044 	movi	r2,1
8111590c:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
81115910:	00002006 	br	81115994 <vReceiverUartTask+0x27c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81115914:	01204574 	movhi	r4,33045
81115918:	21143b04 	addi	r4,r4,20716
8111591c:	1115ad80 	call	81115ad8 <setPreAckSenderFreePos>
81115920:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
81115924:	e0bfae17 	ldw	r2,-328(fp)
81115928:	10800058 	cmpnei	r2,r2,1
8111592c:	1000081e 	bne	r2,zero,81115950 <vReceiverUartTask+0x238>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
81115930:	01204574 	movhi	r4,33045
81115934:	21143b04 	addi	r4,r4,20716
81115938:	111599c0 	call	8111599c <setPreParsedFreePos>
8111593c:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81115940:	e0bfae17 	ldw	r2,-328(fp)
81115944:	1000031e 	bne	r2,zero,81115954 <vReceiverUartTask+0x23c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
81115948:	111dc7c0 	call	8111dc7c <vFailSetPreParsedBuffer>
8111594c:	00000106 	br	81115954 <vReceiverUartTask+0x23c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
81115950:	111dbfc0 	call	8111dbfc <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
81115954:	00800044 	movi	r2,1
81115958:	e0bfad15 	stw	r2,-332(fp)
                break;
8111595c:	00000e06 	br	81115998 <vReceiverUartTask+0x280>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
81115960:	01204574 	movhi	r4,33045
81115964:	21143b04 	addi	r4,r4,20716
81115968:	1115c540 	call	81115c54 <setPreAckReceiverFreePos>
8111596c:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
81115970:	e0bfae17 	ldw	r2,-328(fp)
81115974:	1000011e 	bne	r2,zero,8111597c <vReceiverUartTask+0x264>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81115978:	111dcfc0 	call	8111dcfc <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
8111597c:	00800044 	movi	r2,1
81115980:	e0bfad15 	stw	r2,-332(fp)
                break;
81115984:	00000406 	br	81115998 <vReceiverUartTask+0x280>
            default:
                eReaderRXMode = sGetRxUart;
81115988:	00800044 	movi	r2,1
8111598c:	e0bfad15 	stw	r2,-332(fp)
                break;
81115990:	00000106 	br	81115998 <vReceiverUartTask+0x280>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81115994:	0001883a 	nop
            default:
                eReaderRXMode = sGetRxUart;
                break;
        }

    }
81115998:	003f7506 	br	81115770 <__reset+0xfb0f5770>

8111599c <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
8111599c:	defffb04 	addi	sp,sp,-20
811159a0:	de00012e 	bgeu	sp,et,811159a8 <setPreParsedFreePos+0xc>
811159a4:	003b68fa 	trap	3
811159a8:	dfc00415 	stw	ra,16(sp)
811159ac:	df000315 	stw	fp,12(sp)
811159b0:	df000304 	addi	fp,sp,12
811159b4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811159b8:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
811159bc:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
811159c0:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
811159c4:	d0a06b17 	ldw	r2,-32340(gp)
811159c8:	e0fffe44 	addi	r3,fp,-7
811159cc:	180d883a 	mov	r6,r3
811159d0:	01400284 	movi	r5,10
811159d4:	1009883a 	mov	r4,r2
811159d8:	113e7500 	call	8113e750 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811159dc:	e0bffe43 	ldbu	r2,-7(fp)
811159e0:	10803fcc 	andi	r2,r2,255
811159e4:	1000361e 	bne	r2,zero,81115ac0 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
811159e8:	e03ffe05 	stb	zero,-8(fp)
811159ec:	00002e06 	br	81115aa8 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
811159f0:	e0fffe03 	ldbu	r3,-8(fp)
811159f4:	00a045f4 	movhi	r2,33047
811159f8:	10a1ab04 	addi	r2,r2,-31060
811159fc:	18c01324 	muli	r3,r3,76
81115a00:	10c5883a 	add	r2,r2,r3
81115a04:	10800104 	addi	r2,r2,4
81115a08:	10800003 	ldbu	r2,0(r2)
81115a0c:	10803fcc 	andi	r2,r2,255
81115a10:	1080201c 	xori	r2,r2,128
81115a14:	10bfe004 	addi	r2,r2,-128
81115a18:	1000201e 	bne	r2,zero,81115a9c <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
81115a1c:	e0fffe03 	ldbu	r3,-8(fp)
81115a20:	00a045f4 	movhi	r2,33047
81115a24:	10a1ab04 	addi	r2,r2,-31060
81115a28:	18c01324 	muli	r3,r3,76
81115a2c:	10c7883a 	add	r3,r2,r3
81115a30:	e0bfff17 	ldw	r2,-4(fp)
81115a34:	1009883a 	mov	r4,r2
81115a38:	00801304 	movi	r2,76
81115a3c:	100d883a 	mov	r6,r2
81115a40:	200b883a 	mov	r5,r4
81115a44:	1809883a 	mov	r4,r3
81115a48:	11243500 	call	81124350 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
81115a4c:	d0a06417 	ldw	r2,-32368(gp)
81115a50:	1009883a 	mov	r4,r2
81115a54:	1140ae40 	call	81140ae4 <OSSemPost>
81115a58:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81115a5c:	e0bffe43 	ldbu	r2,-7(fp)
81115a60:	10803fcc 	andi	r2,r2,255
81115a64:	1000031e 	bne	r2,zero,81115a74 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
81115a68:	00800044 	movi	r2,1
81115a6c:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
81115a70:	00001006 	br	81115ab4 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
81115a74:	111d05c0 	call	8111d05c <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81115a78:	e0fffe03 	ldbu	r3,-8(fp)
81115a7c:	00a045f4 	movhi	r2,33047
81115a80:	10a1ab04 	addi	r2,r2,-31060
81115a84:	18c01324 	muli	r3,r3,76
81115a88:	10c5883a 	add	r2,r2,r3
81115a8c:	10800104 	addi	r2,r2,4
81115a90:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
81115a94:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81115a98:	00000606 	br	81115ab4 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81115a9c:	e0bffe03 	ldbu	r2,-8(fp)
81115aa0:	10800044 	addi	r2,r2,1
81115aa4:	e0bffe05 	stb	r2,-8(fp)
81115aa8:	e0bffe03 	ldbu	r2,-8(fp)
81115aac:	10800230 	cmpltui	r2,r2,8
81115ab0:	103fcf1e 	bne	r2,zero,811159f0 <__reset+0xfb0f59f0>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
81115ab4:	d0a06b17 	ldw	r2,-32340(gp)
81115ab8:	1009883a 	mov	r4,r2
81115abc:	113ecf40 	call	8113ecf4 <OSMutexPost>
    }
    return bSuccess;
81115ac0:	e0bffd17 	ldw	r2,-12(fp)
}
81115ac4:	e037883a 	mov	sp,fp
81115ac8:	dfc00117 	ldw	ra,4(sp)
81115acc:	df000017 	ldw	fp,0(sp)
81115ad0:	dec00204 	addi	sp,sp,8
81115ad4:	f800283a 	ret

81115ad8 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
81115ad8:	defffb04 	addi	sp,sp,-20
81115adc:	de00012e 	bgeu	sp,et,81115ae4 <setPreAckSenderFreePos+0xc>
81115ae0:	003b68fa 	trap	3
81115ae4:	dfc00415 	stw	ra,16(sp)
81115ae8:	df000315 	stw	fp,12(sp)
81115aec:	df000304 	addi	fp,sp,12
81115af0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81115af4:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81115af8:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81115afc:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81115b00:	d0a07217 	ldw	r2,-32312(gp)
81115b04:	e0fffe44 	addi	r3,fp,-7
81115b08:	180d883a 	mov	r6,r3
81115b0c:	01400284 	movi	r5,10
81115b10:	1009883a 	mov	r4,r2
81115b14:	113e7500 	call	8113e750 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81115b18:	e0bffe43 	ldbu	r2,-7(fp)
81115b1c:	10803fcc 	andi	r2,r2,255
81115b20:	1000461e 	bne	r2,zero,81115c3c <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81115b24:	e03ffe05 	stb	zero,-8(fp)
81115b28:	00003e06 	br	81115c24 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
81115b2c:	e0fffe03 	ldbu	r3,-8(fp)
81115b30:	00a045f4 	movhi	r2,33047
81115b34:	10a1a304 	addi	r2,r2,-31092
81115b38:	18c7883a 	add	r3,r3,r3
81115b3c:	18c7883a 	add	r3,r3,r3
81115b40:	10c5883a 	add	r2,r2,r3
81115b44:	10800003 	ldbu	r2,0(r2)
81115b48:	10803fcc 	andi	r2,r2,255
81115b4c:	1080201c 	xori	r2,r2,128
81115b50:	10bfe004 	addi	r2,r2,-128
81115b54:	1000301e 	bne	r2,zero,81115c18 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
81115b58:	e0fffe03 	ldbu	r3,-8(fp)
81115b5c:	e0bfff17 	ldw	r2,-4(fp)
81115b60:	11000103 	ldbu	r4,4(r2)
81115b64:	00a045f4 	movhi	r2,33047
81115b68:	10a1a304 	addi	r2,r2,-31092
81115b6c:	18c7883a 	add	r3,r3,r3
81115b70:	18c7883a 	add	r3,r3,r3
81115b74:	10c5883a 	add	r2,r2,r3
81115b78:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81115b7c:	e0fffe03 	ldbu	r3,-8(fp)
81115b80:	e0bfff17 	ldw	r2,-4(fp)
81115b84:	11000143 	ldbu	r4,5(r2)
81115b88:	00a045f4 	movhi	r2,33047
81115b8c:	10a1a304 	addi	r2,r2,-31092
81115b90:	18c7883a 	add	r3,r3,r3
81115b94:	18c7883a 	add	r3,r3,r3
81115b98:	10c5883a 	add	r2,r2,r3
81115b9c:	10800044 	addi	r2,r2,1
81115ba0:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
81115ba4:	e0fffe03 	ldbu	r3,-8(fp)
81115ba8:	e0bfff17 	ldw	r2,-4(fp)
81115bac:	1100020b 	ldhu	r4,8(r2)
81115bb0:	00a045f4 	movhi	r2,33047
81115bb4:	10a1a304 	addi	r2,r2,-31092
81115bb8:	18c7883a 	add	r3,r3,r3
81115bbc:	18c7883a 	add	r3,r3,r3
81115bc0:	10c5883a 	add	r2,r2,r3
81115bc4:	10800084 	addi	r2,r2,2
81115bc8:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
81115bcc:	d0a06117 	ldw	r2,-32380(gp)
81115bd0:	1009883a 	mov	r4,r2
81115bd4:	1140ae40 	call	81140ae4 <OSSemPost>
81115bd8:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
81115bdc:	e0bffe43 	ldbu	r2,-7(fp)
81115be0:	10803fcc 	andi	r2,r2,255
81115be4:	10000926 	beq	r2,zero,81115c0c <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
81115be8:	111d1240 	call	8111d124 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
81115bec:	e0fffe03 	ldbu	r3,-8(fp)
81115bf0:	00a045f4 	movhi	r2,33047
81115bf4:	10a1a304 	addi	r2,r2,-31092
81115bf8:	18c7883a 	add	r3,r3,r3
81115bfc:	18c7883a 	add	r3,r3,r3
81115c00:	10c5883a 	add	r2,r2,r3
81115c04:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81115c08:	00000906 	br	81115c30 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
81115c0c:	00800044 	movi	r2,1
81115c10:	e0bffd15 	stw	r2,-12(fp)
                break;
81115c14:	00000606 	br	81115c30 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81115c18:	e0bffe03 	ldbu	r2,-8(fp)
81115c1c:	10800044 	addi	r2,r2,1
81115c20:	e0bffe05 	stb	r2,-8(fp)
81115c24:	e0bffe03 	ldbu	r2,-8(fp)
81115c28:	10800230 	cmpltui	r2,r2,8
81115c2c:	103fbf1e 	bne	r2,zero,81115b2c <__reset+0xfb0f5b2c>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
81115c30:	d0a07217 	ldw	r2,-32312(gp)
81115c34:	1009883a 	mov	r4,r2
81115c38:	113ecf40 	call	8113ecf4 <OSMutexPost>
    }

    return bSuccess;
81115c3c:	e0bffd17 	ldw	r2,-12(fp)
}
81115c40:	e037883a 	mov	sp,fp
81115c44:	dfc00117 	ldw	ra,4(sp)
81115c48:	df000017 	ldw	fp,0(sp)
81115c4c:	dec00204 	addi	sp,sp,8
81115c50:	f800283a 	ret

81115c54 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
81115c54:	defffb04 	addi	sp,sp,-20
81115c58:	de00012e 	bgeu	sp,et,81115c60 <setPreAckReceiverFreePos+0xc>
81115c5c:	003b68fa 	trap	3
81115c60:	dfc00415 	stw	ra,16(sp)
81115c64:	df000315 	stw	fp,12(sp)
81115c68:	df000304 	addi	fp,sp,12
81115c6c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81115c70:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81115c74:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81115c78:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
81115c7c:	d0a06517 	ldw	r2,-32364(gp)
81115c80:	e0fffe44 	addi	r3,fp,-7
81115c84:	180d883a 	mov	r6,r3
81115c88:	01400504 	movi	r5,20
81115c8c:	1009883a 	mov	r4,r2
81115c90:	113e7500 	call	8113e750 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81115c94:	e0bffe43 	ldbu	r2,-7(fp)
81115c98:	10803fcc 	andi	r2,r2,255
81115c9c:	1000471e 	bne	r2,zero,81115dbc <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81115ca0:	e03ffe05 	stb	zero,-8(fp)
81115ca4:	00003e06 	br	81115da0 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
81115ca8:	e0fffe03 	ldbu	r3,-8(fp)
81115cac:	00a045b4 	movhi	r2,33046
81115cb0:	108b9104 	addi	r2,r2,11844
81115cb4:	18c7883a 	add	r3,r3,r3
81115cb8:	18c7883a 	add	r3,r3,r3
81115cbc:	10c5883a 	add	r2,r2,r3
81115cc0:	10800003 	ldbu	r2,0(r2)
81115cc4:	10803fcc 	andi	r2,r2,255
81115cc8:	1080201c 	xori	r2,r2,128
81115ccc:	10bfe004 	addi	r2,r2,-128
81115cd0:	1000301e 	bne	r2,zero,81115d94 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
81115cd4:	e0fffe03 	ldbu	r3,-8(fp)
81115cd8:	e0bfff17 	ldw	r2,-4(fp)
81115cdc:	11000103 	ldbu	r4,4(r2)
81115ce0:	00a045b4 	movhi	r2,33046
81115ce4:	108b9104 	addi	r2,r2,11844
81115ce8:	18c7883a 	add	r3,r3,r3
81115cec:	18c7883a 	add	r3,r3,r3
81115cf0:	10c5883a 	add	r2,r2,r3
81115cf4:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
81115cf8:	e0fffe03 	ldbu	r3,-8(fp)
81115cfc:	e0bfff17 	ldw	r2,-4(fp)
81115d00:	11000143 	ldbu	r4,5(r2)
81115d04:	00a045b4 	movhi	r2,33046
81115d08:	108b9104 	addi	r2,r2,11844
81115d0c:	18c7883a 	add	r3,r3,r3
81115d10:	18c7883a 	add	r3,r3,r3
81115d14:	10c5883a 	add	r2,r2,r3
81115d18:	10800044 	addi	r2,r2,1
81115d1c:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
81115d20:	e0fffe03 	ldbu	r3,-8(fp)
81115d24:	e0bfff17 	ldw	r2,-4(fp)
81115d28:	1100020b 	ldhu	r4,8(r2)
81115d2c:	00a045b4 	movhi	r2,33046
81115d30:	108b9104 	addi	r2,r2,11844
81115d34:	18c7883a 	add	r3,r3,r3
81115d38:	18c7883a 	add	r3,r3,r3
81115d3c:	10c5883a 	add	r2,r2,r3
81115d40:	10800084 	addi	r2,r2,2
81115d44:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
81115d48:	d0a06617 	ldw	r2,-32360(gp)
81115d4c:	1009883a 	mov	r4,r2
81115d50:	1140ae40 	call	81140ae4 <OSSemPost>
81115d54:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81115d58:	e0bffe43 	ldbu	r2,-7(fp)
81115d5c:	10803fcc 	andi	r2,r2,255
81115d60:	1000031e 	bne	r2,zero,81115d70 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
81115d64:	00800044 	movi	r2,1
81115d68:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
81115d6c:	00000f06 	br	81115dac <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
81115d70:	111d0c00 	call	8111d0c0 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
81115d74:	e0fffe03 	ldbu	r3,-8(fp)
81115d78:	00a045b4 	movhi	r2,33046
81115d7c:	108b9104 	addi	r2,r2,11844
81115d80:	18c7883a 	add	r3,r3,r3
81115d84:	18c7883a 	add	r3,r3,r3
81115d88:	10c5883a 	add	r2,r2,r3
81115d8c:	10000005 	stb	zero,0(r2)
                }
                break;
81115d90:	00000606 	br	81115dac <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81115d94:	e0bffe03 	ldbu	r2,-8(fp)
81115d98:	10800044 	addi	r2,r2,1
81115d9c:	e0bffe05 	stb	r2,-8(fp)
81115da0:	e0bffe03 	ldbu	r2,-8(fp)
81115da4:	108001b0 	cmpltui	r2,r2,6
81115da8:	103fbf1e 	bne	r2,zero,81115ca8 <__reset+0xfb0f5ca8>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
81115dac:	d0a06517 	ldw	r2,-32364(gp)
81115db0:	1009883a 	mov	r4,r2
81115db4:	113ecf40 	call	8113ecf4 <OSMutexPost>
81115db8:	00000d06 	br	81115df0 <setPreAckReceiverFreePos+0x19c>
    } else {
        /* Could not  */
        #if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81115dbc:	00a045f4 	movhi	r2,33047
81115dc0:	10a25304 	addi	r2,r2,-30388
81115dc4:	10800a8b 	ldhu	r2,42(r2)
81115dc8:	10bfffcc 	andi	r2,r2,65535
81115dcc:	10800228 	cmpgeui	r2,r2,8
81115dd0:	1000071e 	bne	r2,zero,81115df0 <setPreAckReceiverFreePos+0x19c>
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
81115dd4:	d0a06217 	ldw	r2,-32376(gp)
81115dd8:	100f883a 	mov	r7,r2
81115ddc:	01801404 	movi	r6,80
81115de0:	01400044 	movi	r5,1
81115de4:	01204574 	movhi	r4,33045
81115de8:	213e4f04 	addi	r4,r4,-1732
81115dec:	112393c0 	call	8112393c <fwrite>
    	}
        #endif
    }

    return bSuccess;
81115df0:	e0bffd17 	ldw	r2,-12(fp)
}
81115df4:	e037883a 	mov	sp,fp
81115df8:	dfc00117 	ldw	ra,4(sp)
81115dfc:	df000017 	ldw	fp,0(sp)
81115e00:	dec00204 	addi	sp,sp,8
81115e04:	f800283a 	ret

81115e08 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
81115e08:	defff404 	addi	sp,sp,-48
81115e0c:	de00012e 	bgeu	sp,et,81115e14 <bPreParserV2+0xc>
81115e10:	003b68fa 	trap	3
81115e14:	dfc00b15 	stw	ra,44(sp)
81115e18:	df000a15 	stw	fp,40(sp)
81115e1c:	dc000915 	stw	r16,36(sp)
81115e20:	df000a04 	addi	fp,sp,40
81115e24:	e13ffd15 	stw	r4,-12(fp)
81115e28:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
81115e2c:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
81115e30:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
81115e34:	01402004 	movi	r5,128
81115e38:	e13ffd17 	ldw	r4,-12(fp)
81115e3c:	1124e600 	call	81124e60 <strnlen>
81115e40:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
81115e44:	01400ec4 	movi	r5,59
81115e48:	e13ffd17 	ldw	r4,-12(fp)
81115e4c:	111aa0c0 	call	8111aa0c <siPosStr>
81115e50:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
81115e54:	e0fff98f 	ldh	r3,-26(fp)
81115e58:	e0bff90f 	ldh	r2,-28(fp)
81115e5c:	10bfffc4 	addi	r2,r2,-1
81115e60:	18800226 	beq	r3,r2,81115e6c <bPreParserV2+0x64>
        return bSuccess;
81115e64:	e0bff617 	ldw	r2,-40(fp)
81115e68:	0000c006 	br	8111616c <bPreParserV2+0x364>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81115e6c:	01401f04 	movi	r5,124
81115e70:	e13ffd17 	ldw	r4,-12(fp)
81115e74:	111aa0c0 	call	8111aa0c <siPosStr>
81115e78:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81115e7c:	e0bffa0f 	ldh	r2,-24(fp)
81115e80:	e0fff98f 	ldh	r3,-26(fp)
81115e84:	1880020e 	bge	r3,r2,81115e90 <bPreParserV2+0x88>
        return bSuccess;
81115e88:	e0bff617 	ldw	r2,-40(fp)
81115e8c:	0000b706 	br	8111616c <bPreParserV2+0x364>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81115e90:	01604574 	movhi	r5,33045
81115e94:	297e6404 	addi	r5,r5,-1648
81115e98:	e13ffd17 	ldw	r4,-12(fp)
81115e9c:	1124d7c0 	call	81124d7c <strcspn>
81115ea0:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
81115ea4:	e0bffa8f 	ldh	r2,-22(fp)
81115ea8:	e0fffa0f 	ldh	r3,-24(fp)
81115eac:	1880020e 	bge	r3,r2,81115eb8 <bPreParserV2+0xb0>
        return bSuccess;
81115eb0:	e0bff617 	ldw	r2,-40(fp)
81115eb4:	0000ad06 	br	8111616c <bPreParserV2+0x364>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
81115eb8:	e0bffa8f 	ldh	r2,-22(fp)
81115ebc:	e0fffd17 	ldw	r3,-12(fp)
81115ec0:	1885883a 	add	r2,r3,r2
81115ec4:	10c00003 	ldbu	r3,0(r2)
81115ec8:	e0bffe17 	ldw	r2,-8(fp)
81115ecc:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81115ed0:	e0bffe17 	ldw	r2,-8(fp)
81115ed4:	10800103 	ldbu	r2,4(r2)
81115ed8:	10803fcc 	andi	r2,r2,255
81115edc:	1080201c 	xori	r2,r2,128
81115ee0:	10bfe004 	addi	r2,r2,-128
81115ee4:	108008d8 	cmpnei	r2,r2,35
81115ee8:	1000041e 	bne	r2,zero,81115efc <bPreParserV2+0xf4>
        bSuccess = TRUE;
81115eec:	00800044 	movi	r2,1
81115ef0:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
81115ef4:	e0bff617 	ldw	r2,-40(fp)
81115ef8:	00009c06 	br	8111616c <bPreParserV2+0x364>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
81115efc:	e0bffa8f 	ldh	r2,-22(fp)
81115f00:	e0fffd17 	ldw	r3,-12(fp)
81115f04:	1889883a 	add	r4,r3,r2
81115f08:	e0fffa0f 	ldh	r3,-24(fp)
81115f0c:	e0bffa8f 	ldh	r2,-22(fp)
81115f10:	1885c83a 	sub	r2,r3,r2
81115f14:	100b883a 	mov	r5,r2
81115f18:	111cc8c0 	call	8111cc8c <ucCrc8wInit>
81115f1c:	1007883a 	mov	r3,r2
81115f20:	e0bffe17 	ldw	r2,-8(fp)
81115f24:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
81115f28:	e0bffa8f 	ldh	r2,-22(fp)
81115f2c:	10800044 	addi	r2,r2,1
81115f30:	e0fffd17 	ldw	r3,-12(fp)
81115f34:	1885883a 	add	r2,r3,r2
81115f38:	10c00003 	ldbu	r3,0(r2)
81115f3c:	e0bffe17 	ldw	r2,-8(fp)
81115f40:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
81115f44:	e0bffe17 	ldw	r2,-8(fp)
81115f48:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
81115f4c:	e0bffe17 	ldw	r2,-8(fp)
81115f50:	10800204 	addi	r2,r2,8
81115f54:	01801004 	movi	r6,64
81115f58:	000b883a 	mov	r5,zero
81115f5c:	1009883a 	mov	r4,r2
81115f60:	11244a00 	call	811244a0 <memset>

    i = siIni + 3; /* "?C:i..." */
81115f64:	e0bffa8b 	ldhu	r2,-22(fp)
81115f68:	108000c4 	addi	r2,r2,3
81115f6c:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81115f70:	e0bffb44 	addi	r2,fp,-19
81115f74:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
81115f78:	e0bffb44 	addi	r2,fp,-19
81115f7c:	01800184 	movi	r6,6
81115f80:	000b883a 	mov	r5,zero
81115f84:	1009883a 	mov	r4,r2
81115f88:	11244a00 	call	811244a0 <memset>
        do {
            c = buffer[i];
81115f8c:	e0bff703 	ldbu	r2,-36(fp)
81115f90:	e0fffd17 	ldw	r3,-12(fp)
81115f94:	1885883a 	add	r2,r3,r2
81115f98:	10800003 	ldbu	r2,0(r2)
81115f9c:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81115fa0:	d0e00317 	ldw	r3,-32756(gp)
81115fa4:	e0bffb07 	ldb	r2,-20(fp)
81115fa8:	10800044 	addi	r2,r2,1
81115fac:	1885883a 	add	r2,r3,r2
81115fb0:	10800003 	ldbu	r2,0(r2)
81115fb4:	10803fcc 	andi	r2,r2,255
81115fb8:	1080010c 	andi	r2,r2,4
81115fbc:	10000626 	beq	r2,zero,81115fd8 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81115fc0:	e0bff817 	ldw	r2,-32(fp)
81115fc4:	e0fffb03 	ldbu	r3,-20(fp)
81115fc8:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81115fcc:	e0bff817 	ldw	r2,-32(fp)
81115fd0:	10800044 	addi	r2,r2,1
81115fd4:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
81115fd8:	e0bff703 	ldbu	r2,-36(fp)
81115fdc:	10800044 	addi	r2,r2,1
81115fe0:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
81115fe4:	e0bff90f 	ldh	r2,-28(fp)
81115fe8:	e0fff703 	ldbu	r3,-36(fp)
81115fec:	1880090e 	bge	r3,r2,81116014 <bPreParserV2+0x20c>
81115ff0:	e0bffb07 	ldb	r2,-20(fp)
81115ff4:	10800ea0 	cmpeqi	r2,r2,58
81115ff8:	1000061e 	bne	r2,zero,81116014 <bPreParserV2+0x20c>
81115ffc:	e0bffb07 	ldb	r2,-20(fp)
81116000:	10800ee0 	cmpeqi	r2,r2,59
81116004:	1000031e 	bne	r2,zero,81116014 <bPreParserV2+0x20c>
81116008:	e0bffb07 	ldb	r2,-20(fp)
8111600c:	10801f18 	cmpnei	r2,r2,124
81116010:	103fde1e 	bne	r2,zero,81115f8c <__reset+0xfb0f5f8c>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116014:	e0bff817 	ldw	r2,-32(fp)
81116018:	00c00284 	movi	r3,10
8111601c:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
81116020:	e0bffb07 	ldb	r2,-20(fp)
81116024:	10800ea0 	cmpeqi	r2,r2,58
81116028:	1000031e 	bne	r2,zero,81116038 <bPreParserV2+0x230>
8111602c:	e0bffb07 	ldb	r2,-20(fp)
81116030:	10801f18 	cmpnei	r2,r2,124
81116034:	10001a1e 	bne	r2,zero,811160a0 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
81116038:	e0bffe17 	ldw	r2,-8(fp)
8111603c:	10800183 	ldbu	r2,6(r2)
81116040:	10803fcc 	andi	r2,r2,255
81116044:	10800828 	cmpgeui	r2,r2,32
81116048:	1000041e 	bne	r2,zero,8111605c <bPreParserV2+0x254>
8111604c:	e0bffe17 	ldw	r2,-8(fp)
81116050:	10800183 	ldbu	r2,6(r2)
81116054:	14003fcc 	andi	r16,r2,255
81116058:	00000106 	br	81116060 <bPreParserV2+0x258>
8111605c:	04000804 	movi	r16,32
81116060:	e0bffb44 	addi	r2,fp,-19
81116064:	1009883a 	mov	r4,r2
81116068:	112312c0 	call	8112312c <atoi>
8111606c:	1009883a 	mov	r4,r2
81116070:	e0fffe17 	ldw	r3,-8(fp)
81116074:	80800104 	addi	r2,r16,4
81116078:	1085883a 	add	r2,r2,r2
8111607c:	1885883a 	add	r2,r3,r2
81116080:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
81116084:	e0bffe17 	ldw	r2,-8(fp)
81116088:	10800183 	ldbu	r2,6(r2)
8111608c:	10800044 	addi	r2,r2,1
81116090:	1007883a 	mov	r3,r2
81116094:	e0bffe17 	ldw	r2,-8(fp)
81116098:	10c00185 	stb	r3,6(r2)
8111609c:	00000906 	br	811160c4 <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
811160a0:	e0bffb07 	ldb	r2,-20(fp)
811160a4:	10800ed8 	cmpnei	r2,r2,59
811160a8:	1000061e 	bne	r2,zero,811160c4 <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
811160ac:	e0bffb44 	addi	r2,fp,-19
811160b0:	1009883a 	mov	r4,r2
811160b4:	112312c0 	call	8112312c <atoi>
811160b8:	1007883a 	mov	r3,r2
811160bc:	e0bffe17 	ldw	r2,-8(fp)
811160c0:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
811160c4:	e0bffb07 	ldb	r2,-20(fp)
811160c8:	10800ee0 	cmpeqi	r2,r2,59
811160cc:	1000031e 	bne	r2,zero,811160dc <bPreParserV2+0x2d4>
811160d0:	e0bff90f 	ldh	r2,-28(fp)
811160d4:	e0fff703 	ldbu	r3,-36(fp)
811160d8:	18bfa516 	blt	r3,r2,81115f70 <__reset+0xfb0f5f70>


    if ( c == FINAL_CHAR )
811160dc:	e0bffb07 	ldb	r2,-20(fp)
811160e0:	10800ed8 	cmpnei	r2,r2,59
811160e4:	10001f1e 	bne	r2,zero,81116164 <bPreParserV2+0x35c>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
811160e8:	e0bffe17 	ldw	r2,-8(fp)
811160ec:	10c01243 	ldbu	r3,73(r2)
811160f0:	e0bffe17 	ldw	r2,-8(fp)
811160f4:	10801203 	ldbu	r2,72(r2)
811160f8:	18c03fcc 	andi	r3,r3,255
811160fc:	10803fcc 	andi	r2,r2,255
81116100:	1880031e 	bne	r3,r2,81116110 <bPreParserV2+0x308>
            bSuccess = TRUE;
81116104:	00800044 	movi	r2,1
81116108:	e0bff615 	stw	r2,-40(fp)
8111610c:	00001606 	br	81116168 <bPreParserV2+0x360>
        } else {
            /* Wrong CRC */
            #if DEBUG_ON
        	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116110:	00a045f4 	movhi	r2,33047
81116114:	10a25304 	addi	r2,r2,-30388
81116118:	10800a8b 	ldhu	r2,42(r2)
8111611c:	10bfffcc 	andi	r2,r2,65535
81116120:	10800228 	cmpgeui	r2,r2,8
81116124:	10000d1e 	bne	r2,zero,8111615c <bPreParserV2+0x354>
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
81116128:	d0e06217 	ldw	r3,-32376(gp)
8111612c:	e0bffe17 	ldw	r2,-8(fp)
81116130:	10801203 	ldbu	r2,72(r2)
81116134:	11003fcc 	andi	r4,r2,255
81116138:	e0bffe17 	ldw	r2,-8(fp)
8111613c:	10801243 	ldbu	r2,73(r2)
81116140:	10803fcc 	andi	r2,r2,255
81116144:	100f883a 	mov	r7,r2
81116148:	200d883a 	mov	r6,r4
8111614c:	01604574 	movhi	r5,33045
81116150:	297e6604 	addi	r5,r5,-1640
81116154:	1809883a 	mov	r4,r3
81116158:	11232a00 	call	811232a0 <fprintf>
        	}
            #endif
            bSuccess = FALSE;
8111615c:	e03ff615 	stw	zero,-40(fp)
81116160:	00000106 	br	81116168 <bPreParserV2+0x360>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
81116164:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
81116168:	e0bff617 	ldw	r2,-40(fp)
}
8111616c:	e6ffff04 	addi	sp,fp,-4
81116170:	dfc00217 	ldw	ra,8(sp)
81116174:	df000117 	ldw	fp,4(sp)
81116178:	dc000017 	ldw	r16,0(sp)
8111617c:	dec00304 	addi	sp,sp,12
81116180:	f800283a 	ret

81116184 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81116184:	defffb04 	addi	sp,sp,-20
81116188:	de00012e 	bgeu	sp,et,81116190 <vSenderComTask+0xc>
8111618c:	003b68fa 	trap	3
81116190:	dfc00415 	stw	ra,16(sp)
81116194:	df000315 	stw	fp,12(sp)
81116198:	df000304 	addi	fp,sp,12
8111619c:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
811161a0:	e03ffd15 	stw	zero,-12(fp)

    #if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811161a4:	00a045f4 	movhi	r2,33047
811161a8:	10a25304 	addi	r2,r2,-30388
811161ac:	10800a8b 	ldhu	r2,42(r2)
811161b0:	10bfffcc 	andi	r2,r2,65535
811161b4:	10800168 	cmpgeui	r2,r2,5
811161b8:	1000071e 	bne	r2,zero,811161d8 <vSenderComTask+0x54>
        debug(fp,"Sender Comm Task. (Task on)\n");
811161bc:	d0a06217 	ldw	r2,-32376(gp)
811161c0:	100f883a 	mov	r7,r2
811161c4:	01800704 	movi	r6,28
811161c8:	01400044 	movi	r5,1
811161cc:	01204574 	movhi	r4,33045
811161d0:	213e7204 	addi	r4,r4,-1592
811161d4:	112393c0 	call	8112393c <fwrite>
    }
    #endif

    for (;;){
        
        switch (eSenderMode)
811161d8:	e0bffd17 	ldw	r2,-12(fp)
811161dc:	10c00060 	cmpeqi	r3,r2,1
811161e0:	1800091e 	bne	r3,zero,81116208 <vSenderComTask+0x84>
811161e4:	0080052e 	bgeu	zero,r2,811161fc <vSenderComTask+0x78>
811161e8:	10c000a0 	cmpeqi	r3,r2,2
811161ec:	1800651e 	bne	r3,zero,81116384 <vSenderComTask+0x200>
811161f0:	10800160 	cmpeqi	r2,r2,5
811161f4:	10003e1e 	bne	r2,zero,811162f0 <vSenderComTask+0x16c>
811161f8:	00005206 	br	81116344 <vSenderComTask+0x1c0>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
811161fc:	00800044 	movi	r2,1
81116200:	e0bffd15 	stw	r2,-12(fp)
                break;
81116204:	00006206 	br	81116390 <vSenderComTask+0x20c>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #if DEBUG_ON
            	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116208:	00a045f4 	movhi	r2,33047
8111620c:	10a25304 	addi	r2,r2,-30388
81116210:	10800a8b 	ldhu	r2,42(r2)
81116214:	10bfffcc 	andi	r2,r2,65535
81116218:	108000e8 	cmpgeui	r2,r2,3
8111621c:	1000071e 	bne	r2,zero,8111623c <vSenderComTask+0xb8>
                    debug(fp,"Preparing the Start Sequence.\n");
81116220:	d0a06217 	ldw	r2,-32376(gp)
81116224:	100f883a 	mov	r7,r2
81116228:	01800784 	movi	r6,30
8111622c:	01400044 	movi	r5,1
81116230:	01204574 	movhi	r4,33045
81116234:	213e7a04 	addi	r4,r4,-1560
81116238:	112393c0 	call	8112393c <fwrite>
            	}
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
8111623c:	01400044 	movi	r5,1
81116240:	01204574 	movhi	r4,33045
81116244:	213e8204 	addi	r4,r4,-1528
81116248:	111a0d40 	call	8111a0d4 <bSendUART32v2>
8111624c:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
81116250:	e0bffe17 	ldw	r2,-8(fp)
81116254:	10800058 	cmpnei	r2,r2,1
81116258:	1000101e 	bne	r2,zero,8111629c <vSenderComTask+0x118>
                    eSenderMode = sDummySender;
8111625c:	00800144 	movi	r2,5
81116260:	e0bffd15 	stw	r2,-12(fp)
                    #if DEBUG_ON
                    if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116264:	00a045f4 	movhi	r2,33047
81116268:	10a25304 	addi	r2,r2,-30388
8111626c:	10800a8b 	ldhu	r2,42(r2)
81116270:	10bfffcc 	andi	r2,r2,65535
81116274:	108000e8 	cmpgeui	r2,r2,3
81116278:	1000441e 	bne	r2,zero,8111638c <vSenderComTask+0x208>
                        debug(fp,"Success, start message in the retransmission buffer.\n");
8111627c:	d0a06217 	ldw	r2,-32376(gp)
81116280:	100f883a 	mov	r7,r2
81116284:	01800d44 	movi	r6,53
81116288:	01400044 	movi	r5,1
8111628c:	01204574 	movhi	r4,33045
81116290:	213e8504 	addi	r4,r4,-1516
81116294:	112393c0 	call	8112393c <fwrite>
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81116298:	00003c06 	br	8111638c <vSenderComTask+0x208>
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    }
                    #endif                    
                } else {
                    #if DEBUG_ON
                	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111629c:	00a045f4 	movhi	r2,33047
811162a0:	10a25304 	addi	r2,r2,-30388
811162a4:	10800a8b 	ldhu	r2,42(r2)
811162a8:	10bfffcc 	andi	r2,r2,65535
811162ac:	108000e8 	cmpgeui	r2,r2,3
811162b0:	1000071e 	bne	r2,zero,811162d0 <vSenderComTask+0x14c>
                        debug(fp,"Fail, try again in 5 seconds.\n");
811162b4:	d0a06217 	ldw	r2,-32376(gp)
811162b8:	100f883a 	mov	r7,r2
811162bc:	01800784 	movi	r6,30
811162c0:	01400044 	movi	r5,1
811162c4:	01204574 	movhi	r4,33045
811162c8:	213e9304 	addi	r4,r4,-1460
811162cc:	112393c0 	call	8112393c <fwrite>
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
811162d0:	00800044 	movi	r2,1
811162d4:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
811162d8:	000f883a 	mov	r7,zero
811162dc:	01800144 	movi	r6,5
811162e0:	000b883a 	mov	r5,zero
811162e4:	0009883a 	mov	r4,zero
811162e8:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
                }
                break;
811162ec:	00002706 	br	8111638c <vSenderComTask+0x208>
            case sReadingQueue:

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
811162f0:	00800144 	movi	r2,5
811162f4:	e0bffd15 	stw	r2,-12(fp)

                #if DEBUG_ON
                if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811162f8:	00a045f4 	movhi	r2,33047
811162fc:	10a25304 	addi	r2,r2,-30388
81116300:	10800a8b 	ldhu	r2,42(r2)
81116304:	10bfffcc 	andi	r2,r2,65535
81116308:	108000e8 	cmpgeui	r2,r2,3
8111630c:	1000071e 	bne	r2,zero,8111632c <vSenderComTask+0x1a8>
                    debug(fp,"Working...\n");
81116310:	d0a06217 	ldw	r2,-32376(gp)
81116314:	100f883a 	mov	r7,r2
81116318:	018002c4 	movi	r6,11
8111631c:	01400044 	movi	r5,1
81116320:	01204574 	movhi	r4,33045
81116324:	213e9b04 	addi	r4,r4,-1428
81116328:	112393c0 	call	8112393c <fwrite>
                }
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
8111632c:	000f883a 	mov	r7,zero
81116330:	01800644 	movi	r6,25
81116334:	000b883a 	mov	r5,zero
81116338:	0009883a 	mov	r4,zero
8111633c:	11426f40 	call	811426f4 <OSTimeDlyHMSM>

                break;
81116340:	00001306 	br	81116390 <vSenderComTask+0x20c>
            default:
                #if DEBUG_ON
            	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116344:	00a045f4 	movhi	r2,33047
81116348:	10a25304 	addi	r2,r2,-30388
8111634c:	10800a8b 	ldhu	r2,42(r2)
81116350:	10bfffcc 	andi	r2,r2,65535
81116354:	10800228 	cmpgeui	r2,r2,8
81116358:	1000071e 	bne	r2,zero,81116378 <vSenderComTask+0x1f4>
                    debug(fp,"Sender default\n");
8111635c:	d0a06217 	ldw	r2,-32376(gp)
81116360:	100f883a 	mov	r7,r2
81116364:	018003c4 	movi	r6,15
81116368:	01400044 	movi	r5,1
8111636c:	01204574 	movhi	r4,33045
81116370:	213e9e04 	addi	r4,r4,-1416
81116374:	112393c0 	call	8112393c <fwrite>
            	}
                #endif
                eSenderMode = sDummySender;
81116378:	00800144 	movi	r2,5
8111637c:	e0bffd15 	stw	r2,-12(fp)
                break;
81116380:	00000306 	br	81116390 <vSenderComTask+0x20c>
                break;


            case sReadingQueue:

                break;
81116384:	0001883a 	nop
81116388:	003f9306 	br	811161d8 <__reset+0xfb0f61d8>
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
8111638c:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81116390:	003f9106 	br	811161d8 <__reset+0xfb0f61d8>

81116394 <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
81116394:	defff804 	addi	sp,sp,-32
81116398:	de00012e 	bgeu	sp,et,811163a0 <vSimMebTask+0xc>
8111639c:	003b68fa 	trap	3
811163a0:	dfc00715 	stw	ra,28(sp)
811163a4:	df000615 	stw	fp,24(sp)
811163a8:	df000604 	addi	fp,sp,24
811163ac:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	tQMask uiCmdMeb;
	INT8U error_code;
	INT8U ucFrameNumber;

	pxMebC = (TSimucam_MEB *) task_data;
811163b0:	e0bfff17 	ldw	r2,-4(fp)
811163b4:	e0bffb15 	stw	r2,-20(fp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811163b8:	00a045f4 	movhi	r2,33047
811163bc:	10a25304 	addi	r2,r2,-30388
811163c0:	10800a8b 	ldhu	r2,42(r2)
811163c4:	10bfffcc 	andi	r2,r2,65535
811163c8:	10800168 	cmpgeui	r2,r2,5
811163cc:	1000071e 	bne	r2,zero,811163ec <vSimMebTask+0x58>
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
811163d0:	d0a06217 	ldw	r2,-32376(gp)
811163d4:	100f883a 	mov	r7,r2
811163d8:	018008c4 	movi	r6,35
811163dc:	01400044 	movi	r5,1
811163e0:	01204574 	movhi	r4,33045
811163e4:	213ea204 	addi	r4,r4,-1400
811163e8:	112393c0 	call	8112393c <fwrite>
	}
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
811163ec:	e0bffb17 	ldw	r2,-20(fp)
811163f0:	10800117 	ldw	r2,4(r2)
811163f4:	10c00168 	cmpgeui	r3,r2,5
811163f8:	1801301e 	bne	r3,zero,811168bc <vSimMebTask+0x528>
811163fc:	100690ba 	slli	r3,r2,2
81116400:	00a04474 	movhi	r2,33041
81116404:	10990504 	addi	r2,r2,25620
81116408:	1885883a 	add	r2,r3,r2
8111640c:	10800017 	ldw	r2,0(r2)
81116410:	1000683a 	jmp	r2
81116414:	81116428 	cmpgeui	r4,r16,17808
81116418:	81116440 	call	88111644 <__reset+0x20f1644>
8111641c:	811164d8 	cmpnei	r4,r16,17811
81116420:	811165bc 	xorhi	r4,r16,17814
81116424:	811166e8 	cmpgeui	r4,r16,17819
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
81116428:	e13ffb17 	ldw	r4,-20(fp)
8111642c:	11178180 	call	81117818 <vMebInit>
				pxMebC->eMode = sMebToConfig;
81116430:	e0bffb17 	ldw	r2,-20(fp)
81116434:	00c00044 	movi	r3,1
81116438:	10c00115 	stw	r3,4(r2)
				break;
8111643c:	00013306 	br	8111690c <vSimMebTask+0x578>


			case sMebToConfig:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116440:	00a045f4 	movhi	r2,33047
81116444:	10a25304 	addi	r2,r2,-30388
81116448:	10800a8b 	ldhu	r2,42(r2)
8111644c:	10bfffcc 	andi	r2,r2,65535
81116450:	10800168 	cmpgeui	r2,r2,5
81116454:	1000071e 	bne	r2,zero,81116474 <vSimMebTask+0xe0>
					debug(fp,"MEB Task: Config Mode\n");
81116458:	d0a06217 	ldw	r2,-32376(gp)
8111645c:	100f883a 	mov	r7,r2
81116460:	01800584 	movi	r6,22
81116464:	01400044 	movi	r5,1
81116468:	01204574 	movhi	r4,33045
8111646c:	213eab04 	addi	r4,r4,-1364
81116470:	112393c0 	call	8112393c <fwrite>
				}
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
81116474:	1120b680 	call	81120b68 <bStopSync>
				vSyncClearCounter();
81116478:	110d1dc0 	call	8110d1dc <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
8111647c:	11179200 	call	81117920 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
81116480:	01c00284 	movi	r7,10
81116484:	000d883a 	mov	r6,zero
81116488:	000b883a 	mov	r5,zero
8111648c:	0009883a 	mov	r4,zero
81116490:	11426f40 	call	811426f4 <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
81116494:	000d883a 	mov	r6,zero
81116498:	000b883a 	mov	r5,zero
8111649c:	01002844 	movi	r4,161
811164a0:	11175ec0 	call	811175ec <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
811164a4:	000d883a 	mov	r6,zero
811164a8:	000b883a 	mov	r5,zero
811164ac:	01002844 	movi	r4,161
811164b0:	11177900 	call	81117790 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
811164b4:	01c03e84 	movi	r7,250
811164b8:	000d883a 	mov	r6,zero
811164bc:	000b883a 	mov	r5,zero
811164c0:	0009883a 	mov	r4,zero
811164c4:	11426f40 	call	811426f4 <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
811164c8:	e0bffb17 	ldw	r2,-20(fp)
811164cc:	00c000c4 	movi	r3,3
811164d0:	10c00115 	stw	r3,4(r2)
				break;
811164d4:	00010d06 	br	8111690c <vSimMebTask+0x578>


			case sMebToRun:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811164d8:	00a045f4 	movhi	r2,33047
811164dc:	10a25304 	addi	r2,r2,-30388
811164e0:	10800a8b 	ldhu	r2,42(r2)
811164e4:	10bfffcc 	andi	r2,r2,65535
811164e8:	10800168 	cmpgeui	r2,r2,5
811164ec:	1000071e 	bne	r2,zero,8111650c <vSimMebTask+0x178>
					debug(fp,"MEB Task: Run Mode\n");
811164f0:	d0a06217 	ldw	r2,-32376(gp)
811164f4:	100f883a 	mov	r7,r2
811164f8:	018004c4 	movi	r6,19
811164fc:	01400044 	movi	r5,1
81116500:	01204574 	movhi	r4,33045
81116504:	213eb104 	addi	r4,r4,-1340
81116508:	112393c0 	call	8112393c <fwrite>
				}
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
8111650c:	000d883a 	mov	r6,zero
81116510:	000b883a 	mov	r5,zero
81116514:	01002884 	movi	r4,162
81116518:	11175ec0 	call	811175ec <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
8111651c:	000d883a 	mov	r6,zero
81116520:	000b883a 	mov	r5,zero
81116524:	01002884 	movi	r4,162
81116528:	11177900 	call	81117790 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
8111652c:	e0bffb17 	ldw	r2,-20(fp)
81116530:	1080050b 	ldhu	r2,20(r2)
81116534:	10bfffcc 	andi	r2,r2,65535
81116538:	100f883a 	mov	r7,r2
8111653c:	000d883a 	mov	r6,zero
81116540:	000b883a 	mov	r5,zero
81116544:	0009883a 	mov	r4,zero
81116548:	11426f40 	call	811426f4 <OSTimeDlyHMSM>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
8111654c:	e03ffa05 	stb	zero,-24(fp)
81116550:	00001006 	br	81116594 <vSimMebTask+0x200>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
81116554:	e0bffa03 	ldbu	r2,-24(fp)
81116558:	10809824 	muli	r2,r2,608
8111655c:	10809d04 	addi	r2,r2,628
81116560:	e0fffb17 	ldw	r3,-20(fp)
81116564:	1885883a 	add	r2,r3,r2
81116568:	1009883a 	mov	r4,r2
8111656c:	110abc00 	call	8110abc0 <bSpwcClearTimecode>
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
81116570:	e0bffa03 	ldbu	r2,-24(fp)
81116574:	e0fffb17 	ldw	r3,-20(fp)
81116578:	10809824 	muli	r2,r2,608
8111657c:	1885883a 	add	r2,r3,r2
81116580:	10803c04 	addi	r2,r2,240
81116584:	10000005 	stb	zero,0(r2)
				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81116588:	e0bffa03 	ldbu	r2,-24(fp)
8111658c:	10800044 	addi	r2,r2,1
81116590:	e0bffa05 	stb	r2,-24(fp)
81116594:	e0bffa03 	ldbu	r2,-24(fp)
81116598:	103fee26 	beq	r2,zero,81116554 <__reset+0xfb0f6554>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
				}

				bSyncCtrReset();
8111659c:	110d82c0 	call	8110d82c <bSyncCtrReset>
				vSyncClearCounter();
811165a0:	110d1dc0 	call	8110d1dc <vSyncClearCounter>
				bStartSync();
811165a4:	1120b2c0 	call	81120b2c <bStartSync>

				vEvtChangeMebMode();
811165a8:	111f5080 	call	8111f508 <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
811165ac:	e0bffb17 	ldw	r2,-20(fp)
811165b0:	00c00104 	movi	r3,4
811165b4:	10c00115 	stw	r3,4(r2)
				break;
811165b8:	0000d406 	br	8111690c <vSimMebTask+0x578>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
811165bc:	d0a06917 	ldw	r2,-32348(gp)
811165c0:	e0fffe04 	addi	r3,fp,-8
811165c4:	180d883a 	mov	r6,r3
811165c8:	000b883a 	mov	r5,zero
811165cc:	1009883a 	mov	r4,r2
811165d0:	113f8640 	call	8113f864 <OSQPend>
811165d4:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
811165d8:	e0bffe03 	ldbu	r2,-8(fp)
811165dc:	10803fcc 	andi	r2,r2,255
811165e0:	10003b1e 	bne	r2,zero,811166d0 <vSimMebTask+0x33c>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
811165e4:	e0bffdc3 	ldbu	r2,-9(fp)
811165e8:	10803fcc 	andi	r2,r2,255
811165ec:	10800058 	cmpnei	r2,r2,1
811165f0:	1000281e 	bne	r2,zero,81116694 <vSimMebTask+0x300>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
811165f4:	e0bffd83 	ldbu	r2,-10(fp)
811165f8:	10803fcc 	andi	r2,r2,255
811165fc:	10c00060 	cmpeqi	r3,r2,1
81116600:	1800031e 	bne	r3,zero,81116610 <vSimMebTask+0x27c>
81116604:	10803820 	cmpeqi	r2,r2,224
81116608:	1000041e 	bne	r2,zero,8111661c <vSimMebTask+0x288>
8111660c:	00001106 	br	81116654 <vSimMebTask+0x2c0>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81116610:	e13ffb17 	ldw	r4,-20(fp)
81116614:	11169100 	call	81116910 <vPusMebTask>
								break;
81116618:	00003206 	br	811166e4 <vSimMebTask+0x350>
							case M_MASTER_SYNC:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111661c:	00a045f4 	movhi	r2,33047
81116620:	10a25304 	addi	r2,r2,-30388
81116624:	10800a8b 	ldhu	r2,42(r2)
81116628:	10bfffcc 	andi	r2,r2,65535
8111662c:	10800228 	cmpgeui	r2,r2,8
81116630:	1000291e 	bne	r2,zero,811166d8 <vSimMebTask+0x344>
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
81116634:	d0a06217 	ldw	r2,-32376(gp)
81116638:	100f883a 	mov	r7,r2
8111663c:	018012c4 	movi	r6,75
81116640:	01400044 	movi	r5,1
81116644:	01204574 	movhi	r4,33045
81116648:	213eb604 	addi	r4,r4,-1320
8111664c:	112393c0 	call	8112393c <fwrite>
								}
								#endif
								break;
81116650:	00002106 	br	811166d8 <vSimMebTask+0x344>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116654:	00a045f4 	movhi	r2,33047
81116658:	10a25304 	addi	r2,r2,-30388
8111665c:	10800a8b 	ldhu	r2,42(r2)
81116660:	10bfffcc 	andi	r2,r2,65535
81116664:	10800228 	cmpgeui	r2,r2,8
81116668:	10001d1e 	bne	r2,zero,811166e0 <vSimMebTask+0x34c>
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
8111666c:	d0a06217 	ldw	r2,-32376(gp)
81116670:	e0fffd83 	ldbu	r3,-10(fp)
81116674:	18c03fcc 	andi	r3,r3,255
81116678:	180d883a 	mov	r6,r3
8111667c:	01604574 	movhi	r5,33045
81116680:	297ec904 	addi	r5,r5,-1244
81116684:	1009883a 	mov	r4,r2
81116688:	11232a00 	call	811232a0 <fprintf>
								}
								#endif
								break;
8111668c:	0001883a 	nop
81116690:	00001306 	br	811166e0 <vSimMebTask+0x34c>
						}
					} else {
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116694:	00a045f4 	movhi	r2,33047
81116698:	10a25304 	addi	r2,r2,-30388
8111669c:	10800a8b 	ldhu	r2,42(r2)
811166a0:	10bfffcc 	andi	r2,r2,65535
811166a4:	10800228 	cmpgeui	r2,r2,8
811166a8:	1000951e 	bne	r2,zero,81116900 <vSimMebTask+0x56c>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
811166ac:	d0a06217 	ldw	r2,-32376(gp)
811166b0:	e0fffdc3 	ldbu	r3,-9(fp)
811166b4:	18c03fcc 	andi	r3,r3,255
811166b8:	180d883a 	mov	r6,r3
811166bc:	01604574 	movhi	r5,33045
811166c0:	297edb04 	addi	r5,r5,-1172
811166c4:	1009883a 	mov	r4,r2
811166c8:	11232a00 	call	811232a0 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
811166cc:	00008c06 	br	81116900 <vSimMebTask+0x56c>
						}
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
811166d0:	111ece00 	call	8111ece0 <vCouldNotGetCmdQueueMeb>
				}

				break;
811166d4:	00008a06 	br	81116900 <vSimMebTask+0x56c>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
								}
								#endif
								break;
811166d8:	0001883a 	nop
811166dc:	00008806 	br	81116900 <vSimMebTask+0x56c>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
								}
								#endif
								break;
811166e0:	0001883a 	nop
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
811166e4:	00008606 	br	81116900 <vSimMebTask+0x56c>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
811166e8:	d0a06917 	ldw	r2,-32348(gp)
811166ec:	e0fffe04 	addi	r3,fp,-8
811166f0:	180d883a 	mov	r6,r3
811166f4:	000b883a 	mov	r5,zero
811166f8:	1009883a 	mov	r4,r2
811166fc:	113f8640 	call	8113f864 <OSQPend>
81116700:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81116704:	e0bffe03 	ldbu	r2,-8(fp)
81116708:	10803fcc 	andi	r2,r2,255
8111670c:	1000651e 	bne	r2,zero,811168a4 <vSimMebTask+0x510>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81116710:	e0bffdc3 	ldbu	r2,-9(fp)
81116714:	10803fcc 	andi	r2,r2,255
81116718:	10800058 	cmpnei	r2,r2,1
8111671c:	1000521e 	bne	r2,zero,81116868 <vSimMebTask+0x4d4>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81116720:	e0bffd83 	ldbu	r2,-10(fp)
81116724:	10803fcc 	andi	r2,r2,255
81116728:	10c03820 	cmpeqi	r3,r2,224
8111672c:	1800071e 	bne	r3,zero,8111674c <vSimMebTask+0x3b8>
81116730:	10c03860 	cmpeqi	r3,r2,225
81116734:	1800071e 	bne	r3,zero,81116754 <vSimMebTask+0x3c0>
81116738:	10800060 	cmpeqi	r2,r2,1
8111673c:	10003a26 	beq	r2,zero,81116828 <vSimMebTask+0x494>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81116740:	e13ffb17 	ldw	r4,-20(fp)
81116744:	11169100 	call	81116910 <vPusMebTask>
								break;
81116748:	00005b06 	br	811168b8 <vSimMebTask+0x524>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
8111674c:	e13ffb17 	ldw	r4,-20(fp)
81116750:	111787c0 	call	8111787c <vSwapMemmory>
							case M_SYNC:
								#if DEBUG_ON

								if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116754:	00a045f4 	movhi	r2,33047
81116758:	10a25304 	addi	r2,r2,-30388
8111675c:	10800a8b 	ldhu	r2,42(r2)
81116760:	10bfffcc 	andi	r2,r2,65535
81116764:	10800168 	cmpgeui	r2,r2,5
81116768:	1000501e 	bne	r2,zero,811168ac <vSimMebTask+0x518>
									fprintf(fp,"\n\nSync\n");
8111676c:	d0a06217 	ldw	r2,-32376(gp)
81116770:	100f883a 	mov	r7,r2
81116774:	018001c4 	movi	r6,7
81116778:	01400044 	movi	r5,1
8111677c:	01204574 	movhi	r4,33045
81116780:	213ee904 	addi	r4,r4,-1116
81116784:	112393c0 	call	8112393c <fwrite>
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116788:	00a045f4 	movhi	r2,33047
8111678c:	10a25304 	addi	r2,r2,-30388
81116790:	10800a8b 	ldhu	r2,42(r2)
81116794:	10bfffcc 	andi	r2,r2,65535
81116798:	108000e8 	cmpgeui	r2,r2,3
8111679c:	1000431e 	bne	r2,zero,811168ac <vSimMebTask+0x518>
										bSpwcGetTimecode(&pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire);
811167a0:	e0bffb17 	ldw	r2,-20(fp)
811167a4:	10809d04 	addi	r2,r2,628
811167a8:	1009883a 	mov	r4,r2
811167ac:	110ab300 	call	8110ab30 <bSpwcGetTimecode>
										tCode = ( pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire.xTimecode.ucCounter);
811167b0:	e0bffb17 	ldw	r2,-20(fp)
811167b4:	1080a943 	ldbu	r2,677(r2)
811167b8:	e0bffc05 	stb	r2,-16(fp)
										tCodeNext = ( tCode ) % 4;
811167bc:	e0bffc03 	ldbu	r2,-16(fp)
811167c0:	108000cc 	andi	r2,r2,3
811167c4:	e0bffc45 	stb	r2,-15(fp)
										fprintf(fp,"TC: %hhu ( %hhu )\n ", tCode, tCodeNext);
811167c8:	d0a06217 	ldw	r2,-32376(gp)
811167cc:	e0fffc03 	ldbu	r3,-16(fp)
811167d0:	e13ffc43 	ldbu	r4,-15(fp)
811167d4:	200f883a 	mov	r7,r4
811167d8:	180d883a 	mov	r6,r3
811167dc:	01604574 	movhi	r5,33045
811167e0:	297eeb04 	addi	r5,r5,-1108
811167e4:	1009883a 	mov	r4,r2
811167e8:	11232a00 	call	811232a0 <fprintf>
										bRmapGetMemConfigArea(&pxMebC->xFeeControl.xNfee[0].xChannel.xRmap);
811167ec:	e0bffb17 	ldw	r2,-20(fp)
811167f0:	10805704 	addi	r2,r2,348
811167f4:	1009883a 	mov	r4,r2
811167f8:	11086380 	call	81108638 <bRmapGetMemConfigArea>
										ucFrameNumber = pxMebC->xFeeControl.xNfee[0].xChannel.xRmap.xRmapMemConfigArea.uliFrameNumber;
811167fc:	e0bffb17 	ldw	r2,-20(fp)
81116800:	10807917 	ldw	r2,484(r2)
81116804:	e0bffc85 	stb	r2,-14(fp)
										fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
81116808:	d0a06217 	ldw	r2,-32376(gp)
8111680c:	e0fffc83 	ldbu	r3,-14(fp)
81116810:	180d883a 	mov	r6,r3
81116814:	01604574 	movhi	r5,33045
81116818:	297ef004 	addi	r5,r5,-1088
8111681c:	1009883a 	mov	r4,r2
81116820:	11232a00 	call	811232a0 <fprintf>
									}
								}
								#endif

								break;
81116824:	00002106 	br	811168ac <vSimMebTask+0x518>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116828:	00a045f4 	movhi	r2,33047
8111682c:	10a25304 	addi	r2,r2,-30388
81116830:	10800a8b 	ldhu	r2,42(r2)
81116834:	10bfffcc 	andi	r2,r2,65535
81116838:	10800228 	cmpgeui	r2,r2,8
8111683c:	10001d1e 	bne	r2,zero,811168b4 <vSimMebTask+0x520>
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
81116840:	d0a06217 	ldw	r2,-32376(gp)
81116844:	e0fffd83 	ldbu	r3,-10(fp)
81116848:	18c03fcc 	andi	r3,r3,255
8111684c:	180d883a 	mov	r6,r3
81116850:	01604574 	movhi	r5,33045
81116854:	297ef904 	addi	r5,r5,-1052
81116858:	1009883a 	mov	r4,r2
8111685c:	11232a00 	call	811232a0 <fprintf>
								}
								#endif
								break;
81116860:	0001883a 	nop
81116864:	00001306 	br	811168b4 <vSimMebTask+0x520>
						}
					} else {
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116868:	00a045f4 	movhi	r2,33047
8111686c:	10a25304 	addi	r2,r2,-30388
81116870:	10800a8b 	ldhu	r2,42(r2)
81116874:	10bfffcc 	andi	r2,r2,65535
81116878:	10800228 	cmpgeui	r2,r2,8
8111687c:	1000221e 	bne	r2,zero,81116908 <vSimMebTask+0x574>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81116880:	d0a06217 	ldw	r2,-32376(gp)
81116884:	e0fffdc3 	ldbu	r3,-9(fp)
81116888:	18c03fcc 	andi	r3,r3,255
8111688c:	180d883a 	mov	r6,r3
81116890:	01604574 	movhi	r5,33045
81116894:	297edb04 	addi	r5,r5,-1172
81116898:	1009883a 	mov	r4,r2
8111689c:	11232a00 	call	811232a0 <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
811168a0:	00001906 	br	81116908 <vSimMebTask+0x574>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
811168a4:	111ece00 	call	8111ece0 <vCouldNotGetCmdQueueMeb>
				}			
				break;
811168a8:	00001706 	br	81116908 <vSimMebTask+0x574>
										fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
									}
								}
								#endif

								break;
811168ac:	0001883a 	nop
811168b0:	00001506 	br	81116908 <vSimMebTask+0x574>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
								}
								#endif
								break;
811168b4:	0001883a 	nop

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
811168b8:	00001306 	br	81116908 <vSimMebTask+0x574>

			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811168bc:	00a045f4 	movhi	r2,33047
811168c0:	10a25304 	addi	r2,r2,-30388
811168c4:	10800a8b 	ldhu	r2,42(r2)
811168c8:	10bfffcc 	andi	r2,r2,65535
811168cc:	10800228 	cmpgeui	r2,r2,8
811168d0:	1000071e 	bne	r2,zero,811168f0 <vSimMebTask+0x55c>
					debug(fp,"MEB Task: Unknown state, backing to Config Mode\n");
811168d4:	d0a06217 	ldw	r2,-32376(gp)
811168d8:	100f883a 	mov	r7,r2
811168dc:	01800c04 	movi	r6,48
811168e0:	01400044 	movi	r5,1
811168e4:	01204574 	movhi	r4,33045
811168e8:	213f0204 	addi	r4,r4,-1016
811168ec:	112393c0 	call	8112393c <fwrite>
				}
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
811168f0:	e0bffb17 	ldw	r2,-20(fp)
811168f4:	00c00044 	movi	r3,1
811168f8:	10c00115 	stw	r3,4(r2)
				break;
811168fc:	00000306 	br	8111690c <vSimMebTask+0x578>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81116900:	0001883a 	nop
81116904:	003eb906 	br	811163ec <__reset+0xfb0f63ec>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81116908:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
				break;
		}
	}
8111690c:	003eb706 	br	811163ec <__reset+0xfb0f63ec>

81116910 <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
81116910:	defffb04 	addi	sp,sp,-20
81116914:	de00012e 	bgeu	sp,et,8111691c <vPusMebTask+0xc>
81116918:	003b68fa 	trap	3
8111691c:	dfc00415 	stw	ra,16(sp)
81116920:	df000315 	stw	fp,12(sp)
81116924:	df000304 	addi	fp,sp,12
81116928:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
8111692c:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
81116930:	d0a07317 	ldw	r2,-32308(gp)
81116934:	e0fffe44 	addi	r3,fp,-7
81116938:	180d883a 	mov	r6,r3
8111693c:	01400084 	movi	r5,2
81116940:	1009883a 	mov	r4,r2
81116944:	113e7500 	call	8113e750 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
81116948:	e0bffe43 	ldbu	r2,-7(fp)
8111694c:	10803fcc 	andi	r2,r2,255
81116950:	10002c1e 	bne	r2,zero,81116a04 <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81116954:	e03ffe05 	stb	zero,-8(fp)
81116958:	00002306 	br	811169e8 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
8111695c:	e0fffe03 	ldbu	r3,-8(fp)
81116960:	00a04574 	movhi	r2,33045
81116964:	109ecb04 	addi	r2,r2,31532
81116968:	18c01524 	muli	r3,r3,84
8111696c:	10c5883a 	add	r2,r2,r3
81116970:	10800104 	addi	r2,r2,4
81116974:	10800017 	ldw	r2,0(r2)
81116978:	10800058 	cmpnei	r2,r2,1
8111697c:	1000171e 	bne	r2,zero,811169dc <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81116980:	e13ffe03 	ldbu	r4,-8(fp)
81116984:	00e04574 	movhi	r3,33045
81116988:	18d44e04 	addi	r3,r3,20792
8111698c:	00a04574 	movhi	r2,33045
81116990:	109ecb04 	addi	r2,r2,31532
81116994:	21001524 	muli	r4,r4,84
81116998:	1105883a 	add	r2,r2,r4
8111699c:	1009883a 	mov	r4,r2
811169a0:	00801504 	movi	r2,84
811169a4:	100d883a 	mov	r6,r2
811169a8:	200b883a 	mov	r5,r4
811169ac:	1809883a 	mov	r4,r3
811169b0:	11243500 	call	81124350 <memcpy>
            	xPus[ucIL].bInUse = FALSE;
811169b4:	e0fffe03 	ldbu	r3,-8(fp)
811169b8:	00a04574 	movhi	r2,33045
811169bc:	109ecb04 	addi	r2,r2,31532
811169c0:	18c01524 	muli	r3,r3,84
811169c4:	10c5883a 	add	r2,r2,r3
811169c8:	10800104 	addi	r2,r2,4
811169cc:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
811169d0:	00800044 	movi	r2,1
811169d4:	e0bffd15 	stw	r2,-12(fp)
                break;
811169d8:	00000606 	br	811169f4 <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811169dc:	e0bffe03 	ldbu	r2,-8(fp)
811169e0:	10800044 	addi	r2,r2,1
811169e4:	e0bffe05 	stb	r2,-8(fp)
811169e8:	e0bffe03 	ldbu	r2,-8(fp)
811169ec:	10800130 	cmpltui	r2,r2,4
811169f0:	103fda1e 	bne	r2,zero,8111695c <__reset+0xfb0f695c>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
811169f4:	d0a07317 	ldw	r2,-32308(gp)
811169f8:	1009883a 	mov	r4,r2
811169fc:	113ecf40 	call	8113ecf4 <OSMutexPost>
81116a00:	00000106 	br	81116a08 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
81116a04:	111ed600 	call	8111ed60 <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
81116a08:	e0bffd17 	ldw	r2,-12(fp)
81116a0c:	10001126 	beq	r2,zero,81116a54 <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
81116a10:	e0bfff17 	ldw	r2,-4(fp)
81116a14:	10800117 	ldw	r2,4(r2)
81116a18:	10c000e0 	cmpeqi	r3,r2,3
81116a1c:	1800031e 	bne	r3,zero,81116a2c <vPusMebTask+0x11c>
81116a20:	10800120 	cmpeqi	r2,r2,4
81116a24:	1000061e 	bne	r2,zero,81116a40 <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
81116a28:	00000a06 	br	81116a54 <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
81116a2c:	01604574 	movhi	r5,33045
81116a30:	29544e04 	addi	r5,r5,20792
81116a34:	e13fff17 	ldw	r4,-4(fp)
81116a38:	1116a6c0 	call	81116a6c <vPusMebInTaskConfigMode>
				break;
81116a3c:	00000506 	br	81116a54 <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
81116a40:	01604574 	movhi	r5,33045
81116a44:	29544e04 	addi	r5,r5,20792
81116a48:	e13fff17 	ldw	r4,-4(fp)
81116a4c:	1116ea80 	call	81116ea8 <vPusMebInTaskRunningMode>
				break;
81116a50:	0001883a 	nop
			default:
				break;
		}
	}
}
81116a54:	0001883a 	nop
81116a58:	e037883a 	mov	sp,fp
81116a5c:	dfc00117 	ldw	ra,4(sp)
81116a60:	df000017 	ldw	fp,0(sp)
81116a64:	dec00204 	addi	sp,sp,8
81116a68:	f800283a 	ret

81116a6c <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116a6c:	defffc04 	addi	sp,sp,-16
81116a70:	de00012e 	bgeu	sp,et,81116a78 <vPusMebInTaskConfigMode+0xc>
81116a74:	003b68fa 	trap	3
81116a78:	dfc00315 	stw	ra,12(sp)
81116a7c:	df000215 	stw	fp,8(sp)
81116a80:	df000204 	addi	fp,sp,8
81116a84:	e13ffe15 	stw	r4,-8(fp)
81116a88:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81116a8c:	e0bfff17 	ldw	r2,-4(fp)
81116a90:	1080030b 	ldhu	r2,12(r2)
81116a94:	10bfffcc 	andi	r2,r2,65535
81116a98:	10c03ee0 	cmpeqi	r3,r2,251
81116a9c:	1800081e 	bne	r3,zero,81116ac0 <vPusMebInTaskConfigMode+0x54>
81116aa0:	10c03f20 	cmpeqi	r3,r2,252
81116aa4:	18000a1e 	bne	r3,zero,81116ad0 <vPusMebInTaskConfigMode+0x64>
81116aa8:	10803ea0 	cmpeqi	r2,r2,250
81116aac:	10000c26 	beq	r2,zero,81116ae0 <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
81116ab0:	e17fff17 	ldw	r5,-4(fp)
81116ab4:	e13ffe17 	ldw	r4,-8(fp)
81116ab8:	1116b300 	call	81116b30 <vPusType250conf>
			break;
81116abc:	00001606 	br	81116b18 <vPusMebInTaskConfigMode+0xac>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
81116ac0:	e17fff17 	ldw	r5,-4(fp)
81116ac4:	e13ffe17 	ldw	r4,-8(fp)
81116ac8:	1116bdc0 	call	81116bdc <vPusType251conf>
			break;
81116acc:	00001206 	br	81116b18 <vPusMebInTaskConfigMode+0xac>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
81116ad0:	e17fff17 	ldw	r5,-4(fp)
81116ad4:	e13ffe17 	ldw	r4,-8(fp)
81116ad8:	1116c480 	call	81116c48 <vPusType252conf>
			break;
81116adc:	00000e06 	br	81116b18 <vPusMebInTaskConfigMode+0xac>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116ae0:	00a045f4 	movhi	r2,33047
81116ae4:	10a25304 	addi	r2,r2,-30388
81116ae8:	10800a8b 	ldhu	r2,42(r2)
81116aec:	10bfffcc 	andi	r2,r2,65535
81116af0:	10800228 	cmpgeui	r2,r2,8
81116af4:	1000071e 	bne	r2,zero,81116b14 <vPusMebInTaskConfigMode+0xa8>
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
81116af8:	d0a06217 	ldw	r2,-32376(gp)
81116afc:	100f883a 	mov	r7,r2
81116b00:	01800d84 	movi	r6,54
81116b04:	01400044 	movi	r5,1
81116b08:	01204574 	movhi	r4,33045
81116b0c:	213f0f04 	addi	r4,r4,-964
81116b10:	112393c0 	call	8112393c <fwrite>
			}
			#endif
			break;
81116b14:	0001883a 	nop
	}
}
81116b18:	0001883a 	nop
81116b1c:	e037883a 	mov	sp,fp
81116b20:	dfc00117 	ldw	ra,4(sp)
81116b24:	df000017 	ldw	fp,0(sp)
81116b28:	dec00204 	addi	sp,sp,8
81116b2c:	f800283a 	ret

81116b30 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116b30:	defffc04 	addi	sp,sp,-16
81116b34:	de00012e 	bgeu	sp,et,81116b3c <vPusType250conf+0xc>
81116b38:	003b68fa 	trap	3
81116b3c:	dfc00315 	stw	ra,12(sp)
81116b40:	df000215 	stw	fp,8(sp)
81116b44:	df000204 	addi	fp,sp,8
81116b48:	e13ffe15 	stw	r4,-8(fp)
81116b4c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81116b50:	e0bfff17 	ldw	r2,-4(fp)
81116b54:	1080038b 	ldhu	r2,14(r2)
81116b58:	10bfffcc 	andi	r2,r2,65535
81116b5c:	10c00f60 	cmpeqi	r3,r2,61
81116b60:	1800031e 	bne	r3,zero,81116b70 <vPusType250conf+0x40>
81116b64:	10800fa0 	cmpeqi	r2,r2,62
81116b68:	1000131e 	bne	r2,zero,81116bb8 <vPusType250conf+0x88>
81116b6c:	00000406 	br	81116b80 <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
81116b70:	e0bffe17 	ldw	r2,-8(fp)
81116b74:	00c00084 	movi	r3,2
81116b78:	10c00115 	stw	r3,4(r2)
			break;
81116b7c:	00001106 	br	81116bc4 <vPusType250conf+0x94>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116b80:	00a045f4 	movhi	r2,33047
81116b84:	10a25304 	addi	r2,r2,-30388
81116b88:	10800a8b 	ldhu	r2,42(r2)
81116b8c:	10bfffcc 	andi	r2,r2,65535
81116b90:	10800228 	cmpgeui	r2,r2,8
81116b94:	10000a1e 	bne	r2,zero,81116bc0 <vPusType250conf+0x90>
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81116b98:	d0a06217 	ldw	r2,-32376(gp)
81116b9c:	100f883a 	mov	r7,r2
81116ba0:	01800b04 	movi	r6,44
81116ba4:	01400044 	movi	r5,1
81116ba8:	01204574 	movhi	r4,33045
81116bac:	213f1d04 	addi	r4,r4,-908
81116bb0:	112393c0 	call	8112393c <fwrite>
			}
			#endif
			break;
81116bb4:	00000206 	br	81116bc0 <vPusType250conf+0x90>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81116bb8:	0001883a 	nop
81116bbc:	00000106 	br	81116bc4 <vPusType250conf+0x94>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			}
			#endif
			break;
81116bc0:	0001883a 	nop
	}
}
81116bc4:	0001883a 	nop
81116bc8:	e037883a 	mov	sp,fp
81116bcc:	dfc00117 	ldw	ra,4(sp)
81116bd0:	df000017 	ldw	fp,0(sp)
81116bd4:	dec00204 	addi	sp,sp,8
81116bd8:	f800283a 	ret

81116bdc <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116bdc:	defffc04 	addi	sp,sp,-16
81116be0:	de00012e 	bgeu	sp,et,81116be8 <vPusType251conf+0xc>
81116be4:	003b68fa 	trap	3
81116be8:	dfc00315 	stw	ra,12(sp)
81116bec:	df000215 	stw	fp,8(sp)
81116bf0:	df000204 	addi	fp,sp,8
81116bf4:	e13ffe15 	stw	r4,-8(fp)
81116bf8:	e17fff15 	stw	r5,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116bfc:	00a045f4 	movhi	r2,33047
81116c00:	10a25304 	addi	r2,r2,-30388
81116c04:	10800a8b 	ldhu	r2,42(r2)
81116c08:	10bfffcc 	andi	r2,r2,65535
81116c0c:	10800168 	cmpgeui	r2,r2,5
81116c10:	1000071e 	bne	r2,zero,81116c30 <vPusType251conf+0x54>
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
81116c14:	d0a06217 	ldw	r2,-32376(gp)
81116c18:	100f883a 	mov	r7,r2
81116c1c:	01801184 	movi	r6,70
81116c20:	01400044 	movi	r5,1
81116c24:	01204574 	movhi	r4,33045
81116c28:	213f2904 	addi	r4,r4,-860
81116c2c:	112393c0 	call	8112393c <fwrite>
	}
	#endif
}
81116c30:	0001883a 	nop
81116c34:	e037883a 	mov	sp,fp
81116c38:	dfc00117 	ldw	ra,4(sp)
81116c3c:	df000017 	ldw	fp,0(sp)
81116c40:	dec00204 	addi	sp,sp,8
81116c44:	f800283a 	ret

81116c48 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116c48:	defffb04 	addi	sp,sp,-20
81116c4c:	de00012e 	bgeu	sp,et,81116c54 <vPusType252conf+0xc>
81116c50:	003b68fa 	trap	3
81116c54:	dfc00415 	stw	ra,16(sp)
81116c58:	df000315 	stw	fp,12(sp)
81116c5c:	df000304 	addi	fp,sp,12
81116c60:	e13ffe15 	stw	r4,-8(fp)
81116c64:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81116c68:	e0bfff17 	ldw	r2,-4(fp)
81116c6c:	1080050b 	ldhu	r2,20(r2)
81116c70:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81116c74:	e0bfff17 	ldw	r2,-4(fp)
81116c78:	1080038b 	ldhu	r2,14(r2)
81116c7c:	10bfffcc 	andi	r2,r2,65535
81116c80:	10c000a0 	cmpeqi	r3,r2,2
81116c84:	1800121e 	bne	r3,zero,81116cd0 <vPusType252conf+0x88>
81116c88:	10c00090 	cmplti	r3,r2,2
81116c8c:	18006d1e 	bne	r3,zero,81116e44 <vPusType252conf+0x1fc>
81116c90:	10800188 	cmpgei	r2,r2,6
81116c94:	10006b1e 	bne	r2,zero,81116e44 <vPusType252conf+0x1fc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116c98:	00a045f4 	movhi	r2,33047
81116c9c:	10a25304 	addi	r2,r2,-30388
81116ca0:	10800a8b 	ldhu	r2,42(r2)
81116ca4:	10bfffcc 	andi	r2,r2,65535
81116ca8:	10800168 	cmpgeui	r2,r2,5
81116cac:	1000731e 	bne	r2,zero,81116e7c <vPusType252conf+0x234>
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
81116cb0:	d0a06217 	ldw	r2,-32376(gp)
81116cb4:	100f883a 	mov	r7,r2
81116cb8:	01801384 	movi	r6,78
81116cbc:	01400044 	movi	r5,1
81116cc0:	01204574 	movhi	r4,33045
81116cc4:	213f3b04 	addi	r4,r4,-788
81116cc8:	112393c0 	call	8112393c <fwrite>
			}
			#endif
			break;
81116ccc:	00006b06 	br	81116e7c <vPusType252conf+0x234>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116cd0:	e0bffd0b 	ldhu	r2,-12(fp)
81116cd4:	10809824 	muli	r2,r2,608
81116cd8:	10805704 	addi	r2,r2,348
81116cdc:	e0fffe17 	ldw	r3,-8(fp)
81116ce0:	1885883a 	add	r2,r3,r2
81116ce4:	1009883a 	mov	r4,r2
81116ce8:	1107dcc0 	call	81107dcc <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81116cec:	e0bffd0b 	ldhu	r2,-12(fp)
81116cf0:	e0fffe17 	ldw	r3,-8(fp)
81116cf4:	10809824 	muli	r2,r2,608
81116cf8:	1885883a 	add	r2,r3,r2
81116cfc:	10806704 	addi	r2,r2,412
81116d00:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116d04:	e0bffd0b 	ldhu	r2,-12(fp)
81116d08:	10809824 	muli	r2,r2,608
81116d0c:	10805704 	addi	r2,r2,348
81116d10:	e0fffe17 	ldw	r3,-8(fp)
81116d14:	1885883a 	add	r2,r3,r2
81116d18:	1009883a 	mov	r4,r2
81116d1c:	1107d200 	call	81107d20 <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81116d20:	e0bffd0b 	ldhu	r2,-12(fp)
81116d24:	10809824 	muli	r2,r2,608
81116d28:	10805704 	addi	r2,r2,348
81116d2c:	e0fffe17 	ldw	r3,-8(fp)
81116d30:	1885883a 	add	r2,r3,r2
81116d34:	1009883a 	mov	r4,r2
81116d38:	1107fb80 	call	81107fb8 <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81116d3c:	e0bffd0b 	ldhu	r2,-12(fp)
81116d40:	e0ffff17 	ldw	r3,-4(fp)
81116d44:	18c00b0b 	ldhu	r3,44(r3)
81116d48:	1809883a 	mov	r4,r3
81116d4c:	e0fffe17 	ldw	r3,-8(fp)
81116d50:	10809824 	muli	r2,r2,608
81116d54:	1885883a 	add	r2,r3,r2
81116d58:	10805804 	addi	r2,r2,352
81116d5c:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81116d60:	e0bffd0b 	ldhu	r2,-12(fp)
81116d64:	e0ffff17 	ldw	r3,-4(fp)
81116d68:	18c0098b 	ldhu	r3,38(r3)
81116d6c:	1809883a 	mov	r4,r3
81116d70:	e0fffe17 	ldw	r3,-8(fp)
81116d74:	10809824 	muli	r2,r2,608
81116d78:	1885883a 	add	r2,r3,r2
81116d7c:	10805844 	addi	r2,r2,353
81116d80:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81116d84:	e0bffd0b 	ldhu	r2,-12(fp)
81116d88:	10809824 	muli	r2,r2,608
81116d8c:	10805704 	addi	r2,r2,348
81116d90:	e0fffe17 	ldw	r3,-8(fp)
81116d94:	1885883a 	add	r2,r3,r2
81116d98:	1009883a 	mov	r4,r2
81116d9c:	1107edc0 	call	81107edc <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116da0:	e0bffd0b 	ldhu	r2,-12(fp)
81116da4:	10809824 	muli	r2,r2,608
81116da8:	10805704 	addi	r2,r2,348
81116dac:	e0fffe17 	ldw	r3,-8(fp)
81116db0:	1885883a 	add	r2,r3,r2
81116db4:	1009883a 	mov	r4,r2
81116db8:	1107dcc0 	call	81107dcc <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81116dbc:	e0bffd0b 	ldhu	r2,-12(fp)
81116dc0:	e0fffe17 	ldw	r3,-8(fp)
81116dc4:	10809824 	muli	r2,r2,608
81116dc8:	1885883a 	add	r2,r3,r2
81116dcc:	10806704 	addi	r2,r2,412
81116dd0:	00c00044 	movi	r3,1
81116dd4:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116dd8:	e0bffd0b 	ldhu	r2,-12(fp)
81116ddc:	10809824 	muli	r2,r2,608
81116de0:	10805704 	addi	r2,r2,348
81116de4:	e0fffe17 	ldw	r3,-8(fp)
81116de8:	1885883a 	add	r2,r3,r2
81116dec:	1009883a 	mov	r4,r2
81116df0:	1107d200 	call	81107d20 <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116df4:	00a045f4 	movhi	r2,33047
81116df8:	10a25304 	addi	r2,r2,-30388
81116dfc:	10800a8b 	ldhu	r2,42(r2)
81116e00:	10bfffcc 	andi	r2,r2,65535
81116e04:	108000e8 	cmpgeui	r2,r2,3
81116e08:	10001e1e 	bne	r2,zero,81116e84 <vPusType252conf+0x23c>
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81116e0c:	d0e06217 	ldw	r3,-32376(gp)
81116e10:	e0bfff17 	ldw	r2,-4(fp)
81116e14:	10800b0b 	ldhu	r2,44(r2)
81116e18:	113fffcc 	andi	r4,r2,65535
81116e1c:	e0bfff17 	ldw	r2,-4(fp)
81116e20:	1080098b 	ldhu	r2,38(r2)
81116e24:	10bfffcc 	andi	r2,r2,65535
81116e28:	100f883a 	mov	r7,r2
81116e2c:	200d883a 	mov	r6,r4
81116e30:	01604574 	movhi	r5,33045
81116e34:	297f4f04 	addi	r5,r5,-708
81116e38:	1809883a 	mov	r4,r3
81116e3c:	11232a00 	call	811232a0 <fprintf>
			}
			#endif

			break;
81116e40:	00001006 	br	81116e84 <vPusType252conf+0x23c>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116e44:	00a045f4 	movhi	r2,33047
81116e48:	10a25304 	addi	r2,r2,-30388
81116e4c:	10800a8b 	ldhu	r2,42(r2)
81116e50:	10bfffcc 	andi	r2,r2,65535
81116e54:	10800228 	cmpgeui	r2,r2,8
81116e58:	10000c1e 	bne	r2,zero,81116e8c <vPusType252conf+0x244>
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81116e5c:	d0a06217 	ldw	r2,-32376(gp)
81116e60:	100f883a 	mov	r7,r2
81116e64:	01800b04 	movi	r6,44
81116e68:	01400044 	movi	r5,1
81116e6c:	01204574 	movhi	r4,33045
81116e70:	213f1d04 	addi	r4,r4,-908
81116e74:	112393c0 	call	8112393c <fwrite>
			}
			#endif
			break;
81116e78:	00000406 	br	81116e8c <vPusType252conf+0x244>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
			}
			#endif
			break;
81116e7c:	0001883a 	nop
81116e80:	00000306 	br	81116e90 <vPusType252conf+0x248>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			}
			#endif

			break;
81116e84:	0001883a 	nop
81116e88:	00000106 	br	81116e90 <vPusType252conf+0x248>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			}
			#endif
			break;
81116e8c:	0001883a 	nop
	}
}
81116e90:	0001883a 	nop
81116e94:	e037883a 	mov	sp,fp
81116e98:	dfc00117 	ldw	ra,4(sp)
81116e9c:	df000017 	ldw	fp,0(sp)
81116ea0:	dec00204 	addi	sp,sp,8
81116ea4:	f800283a 	ret

81116ea8 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116ea8:	defffc04 	addi	sp,sp,-16
81116eac:	de00012e 	bgeu	sp,et,81116eb4 <vPusMebInTaskRunningMode+0xc>
81116eb0:	003b68fa 	trap	3
81116eb4:	dfc00315 	stw	ra,12(sp)
81116eb8:	df000215 	stw	fp,8(sp)
81116ebc:	df000204 	addi	fp,sp,8
81116ec0:	e13ffe15 	stw	r4,-8(fp)
81116ec4:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81116ec8:	e0bfff17 	ldw	r2,-4(fp)
81116ecc:	1080030b 	ldhu	r2,12(r2)
81116ed0:	10bfffcc 	andi	r2,r2,65535
81116ed4:	10c03ee0 	cmpeqi	r3,r2,251
81116ed8:	1800081e 	bne	r3,zero,81116efc <vPusMebInTaskRunningMode+0x54>
81116edc:	10c03f20 	cmpeqi	r3,r2,252
81116ee0:	18000a1e 	bne	r3,zero,81116f0c <vPusMebInTaskRunningMode+0x64>
81116ee4:	10803ea0 	cmpeqi	r2,r2,250
81116ee8:	10000c26 	beq	r2,zero,81116f1c <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
81116eec:	e17fff17 	ldw	r5,-4(fp)
81116ef0:	e13ffe17 	ldw	r4,-8(fp)
81116ef4:	1116f6c0 	call	81116f6c <vPusType250run>
			break;
81116ef8:	00001606 	br	81116f54 <vPusMebInTaskRunningMode+0xac>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
81116efc:	e17fff17 	ldw	r5,-4(fp)
81116f00:	e13ffe17 	ldw	r4,-8(fp)
81116f04:	11170180 	call	81117018 <vPusType251run>
			break;
81116f08:	00001206 	br	81116f54 <vPusMebInTaskRunningMode+0xac>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
81116f0c:	e17fff17 	ldw	r5,-4(fp)
81116f10:	e13ffe17 	ldw	r4,-8(fp)
81116f14:	11171440 	call	81117144 <vPusType252run>
			break;
81116f18:	00000e06 	br	81116f54 <vPusMebInTaskRunningMode+0xac>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116f1c:	00a045f4 	movhi	r2,33047
81116f20:	10a25304 	addi	r2,r2,-30388
81116f24:	10800a8b 	ldhu	r2,42(r2)
81116f28:	10bfffcc 	andi	r2,r2,65535
81116f2c:	10800228 	cmpgeui	r2,r2,8
81116f30:	1000071e 	bne	r2,zero,81116f50 <vPusMebInTaskRunningMode+0xa8>
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
81116f34:	d0a06217 	ldw	r2,-32376(gp)
81116f38:	100f883a 	mov	r7,r2
81116f3c:	01800cc4 	movi	r6,51
81116f40:	01400044 	movi	r5,1
81116f44:	01204574 	movhi	r4,33045
81116f48:	213f5f04 	addi	r4,r4,-644
81116f4c:	112393c0 	call	8112393c <fwrite>
			}
			#endif
			break;
81116f50:	0001883a 	nop
	}
}
81116f54:	0001883a 	nop
81116f58:	e037883a 	mov	sp,fp
81116f5c:	dfc00117 	ldw	ra,4(sp)
81116f60:	df000017 	ldw	fp,0(sp)
81116f64:	dec00204 	addi	sp,sp,8
81116f68:	f800283a 	ret

81116f6c <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116f6c:	defffc04 	addi	sp,sp,-16
81116f70:	de00012e 	bgeu	sp,et,81116f78 <vPusType250run+0xc>
81116f74:	003b68fa 	trap	3
81116f78:	dfc00315 	stw	ra,12(sp)
81116f7c:	df000215 	stw	fp,8(sp)
81116f80:	df000204 	addi	fp,sp,8
81116f84:	e13ffe15 	stw	r4,-8(fp)
81116f88:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81116f8c:	e0bfff17 	ldw	r2,-4(fp)
81116f90:	1080038b 	ldhu	r2,14(r2)
81116f94:	10bfffcc 	andi	r2,r2,65535
81116f98:	10c00f20 	cmpeqi	r3,r2,60
81116f9c:	1800031e 	bne	r3,zero,81116fac <vPusType250run+0x40>
81116fa0:	10800fa0 	cmpeqi	r2,r2,62
81116fa4:	1000131e 	bne	r2,zero,81116ff4 <vPusType250run+0x88>
81116fa8:	00000406 	br	81116fbc <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
81116fac:	e0bffe17 	ldw	r2,-8(fp)
81116fb0:	00c00044 	movi	r3,1
81116fb4:	10c00115 	stw	r3,4(r2)
			break;
81116fb8:	00001106 	br	81117000 <vPusType250run+0x94>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116fbc:	00a045f4 	movhi	r2,33047
81116fc0:	10a25304 	addi	r2,r2,-30388
81116fc4:	10800a8b 	ldhu	r2,42(r2)
81116fc8:	10bfffcc 	andi	r2,r2,65535
81116fcc:	10800228 	cmpgeui	r2,r2,8
81116fd0:	10000a1e 	bne	r2,zero,81116ffc <vPusType250run+0x90>
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81116fd4:	d0a06217 	ldw	r2,-32376(gp)
81116fd8:	100f883a 	mov	r7,r2
81116fdc:	01800c84 	movi	r6,50
81116fe0:	01400044 	movi	r5,1
81116fe4:	01204574 	movhi	r4,33045
81116fe8:	213f6c04 	addi	r4,r4,-592
81116fec:	112393c0 	call	8112393c <fwrite>
			}
			#endif
			break;
81116ff0:	00000206 	br	81116ffc <vPusType250run+0x90>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81116ff4:	0001883a 	nop
81116ff8:	00000106 	br	81117000 <vPusType250run+0x94>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
81116ffc:	0001883a 	nop
	}
}
81117000:	0001883a 	nop
81117004:	e037883a 	mov	sp,fp
81117008:	dfc00117 	ldw	ra,4(sp)
8111700c:	df000017 	ldw	fp,0(sp)
81117010:	dec00204 	addi	sp,sp,8
81117014:	f800283a 	ret

81117018 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81117018:	defffb04 	addi	sp,sp,-20
8111701c:	de00012e 	bgeu	sp,et,81117024 <vPusType251run+0xc>
81117020:	003b68fa 	trap	3
81117024:	dfc00415 	stw	ra,16(sp)
81117028:	df000315 	stw	fp,12(sp)
8111702c:	df000304 	addi	fp,sp,12
81117030:	e13ffe15 	stw	r4,-8(fp)
81117034:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81117038:	e0bfff17 	ldw	r2,-4(fp)
8111703c:	1080050b 	ldhu	r2,20(r2)
81117040:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81117044:	e0bfff17 	ldw	r2,-4(fp)
81117048:	1080038b 	ldhu	r2,14(r2)
8111704c:	10bfffcc 	andi	r2,r2,65535
81117050:	10c000a0 	cmpeqi	r3,r2,2
81117054:	18000f1e 	bne	r3,zero,81117094 <vPusType251run+0x7c>
81117058:	10c00160 	cmpeqi	r3,r2,5
8111705c:	1800181e 	bne	r3,zero,811170c0 <vPusType251run+0xa8>
81117060:	10800060 	cmpeqi	r2,r2,1
81117064:	10002126 	beq	r2,zero,811170ec <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
81117068:	e0bffd0b 	ldhu	r2,-12(fp)
8111706c:	10800444 	addi	r2,r2,17
81117070:	10803fcc 	andi	r2,r2,255
81117074:	e0fffd0b 	ldhu	r3,-12(fp)
81117078:	18c03fcc 	andi	r3,r3,255
8111707c:	180f883a 	mov	r7,r3
81117080:	000d883a 	mov	r6,zero
81117084:	01400044 	movi	r5,1
81117088:	1009883a 	mov	r4,r2
8111708c:	11176740 	call	81117674 <vSendCmdQToNFeeCTRL_GEN>
			break;
81117090:	00002606 	br	8111712c <vPusType251run+0x114>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
81117094:	e0bffd0b 	ldhu	r2,-12(fp)
81117098:	10800444 	addi	r2,r2,17
8111709c:	10803fcc 	andi	r2,r2,255
811170a0:	e0fffd0b 	ldhu	r3,-12(fp)
811170a4:	18c03fcc 	andi	r3,r3,255
811170a8:	180f883a 	mov	r7,r3
811170ac:	000d883a 	mov	r6,zero
811170b0:	01400104 	movi	r5,4
811170b4:	1009883a 	mov	r4,r2
811170b8:	11176740 	call	81117674 <vSendCmdQToNFeeCTRL_GEN>
			break;
811170bc:	00001b06 	br	8111712c <vPusType251run+0x114>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
811170c0:	e0bffd0b 	ldhu	r2,-12(fp)
811170c4:	10800444 	addi	r2,r2,17
811170c8:	10803fcc 	andi	r2,r2,255
811170cc:	e0fffd0b 	ldhu	r3,-12(fp)
811170d0:	18c03fcc 	andi	r3,r3,255
811170d4:	180f883a 	mov	r7,r3
811170d8:	000d883a 	mov	r6,zero
811170dc:	01400204 	movi	r5,8
811170e0:	1009883a 	mov	r4,r2
811170e4:	11176740 	call	81117674 <vSendCmdQToNFeeCTRL_GEN>
			break;
811170e8:	00001006 	br	8111712c <vPusType251run+0x114>
		case 3:
		case 4:
		case 6:
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811170ec:	00a045f4 	movhi	r2,33047
811170f0:	10a25304 	addi	r2,r2,-30388
811170f4:	10800a8b 	ldhu	r2,42(r2)
811170f8:	10bfffcc 	andi	r2,r2,65535
811170fc:	10800228 	cmpgeui	r2,r2,8
81117100:	1000091e 	bne	r2,zero,81117128 <vPusType251run+0x110>
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
81117104:	d0e06217 	ldw	r3,-32376(gp)
81117108:	e0bfff17 	ldw	r2,-4(fp)
8111710c:	1080038b 	ldhu	r2,14(r2)
81117110:	10bfffcc 	andi	r2,r2,65535
81117114:	100d883a 	mov	r6,r2
81117118:	01604574 	movhi	r5,33045
8111711c:	297f7904 	addi	r5,r5,-540
81117120:	1809883a 	mov	r4,r3
81117124:	11232a00 	call	811232a0 <fprintf>
			}
			#endif
			break;
81117128:	0001883a 	nop
	}
}
8111712c:	0001883a 	nop
81117130:	e037883a 	mov	sp,fp
81117134:	dfc00117 	ldw	ra,4(sp)
81117138:	df000017 	ldw	fp,0(sp)
8111713c:	dec00204 	addi	sp,sp,8
81117140:	f800283a 	ret

81117144 <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81117144:	defffb04 	addi	sp,sp,-20
81117148:	de00012e 	bgeu	sp,et,81117150 <vPusType252run+0xc>
8111714c:	003b68fa 	trap	3
81117150:	dfc00415 	stw	ra,16(sp)
81117154:	df000315 	stw	fp,12(sp)
81117158:	df000304 	addi	fp,sp,12
8111715c:	e13ffe15 	stw	r4,-8(fp)
81117160:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81117164:	e0bfff17 	ldw	r2,-4(fp)
81117168:	1080050b 	ldhu	r2,20(r2)
8111716c:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81117170:	e0bfff17 	ldw	r2,-4(fp)
81117174:	1080038b 	ldhu	r2,14(r2)
81117178:	10bfffcc 	andi	r2,r2,65535
8111717c:	10c000e0 	cmpeqi	r3,r2,3
81117180:	18000a1e 	bne	r3,zero,811171ac <vPusType252run+0x68>
81117184:	10c00108 	cmpgei	r3,r2,4
81117188:	1800031e 	bne	r3,zero,81117198 <vPusType252run+0x54>
8111718c:	108000a0 	cmpeqi	r2,r2,2
81117190:	1000641e 	bne	r2,zero,81117324 <vPusType252run+0x1e0>
81117194:	0000d606 	br	811174f0 <vPusType252run+0x3ac>
81117198:	10c00120 	cmpeqi	r3,r2,4
8111719c:	1800321e 	bne	r3,zero,81117268 <vPusType252run+0x124>
811171a0:	10800160 	cmpeqi	r2,r2,5
811171a4:	1000e01e 	bne	r2,zero,81117528 <vPusType252run+0x3e4>
811171a8:	0000d106 	br	811174f0 <vPusType252run+0x3ac>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
811171ac:	e0bffd0b 	ldhu	r2,-12(fp)
811171b0:	10809824 	muli	r2,r2,608
811171b4:	10809d04 	addi	r2,r2,628
811171b8:	e0fffe17 	ldw	r3,-8(fp)
811171bc:	1885883a 	add	r2,r3,r2
811171c0:	1009883a 	mov	r4,r2
811171c4:	110a8880 	call	8110a888 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
811171c8:	e0bffd0b 	ldhu	r2,-12(fp)
811171cc:	e0fffe17 	ldw	r3,-8(fp)
811171d0:	10809824 	muli	r2,r2,608
811171d4:	1885883a 	add	r2,r3,r2
811171d8:	10809f04 	addi	r2,r2,636
811171dc:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
811171e0:	e0bffd0b 	ldhu	r2,-12(fp)
811171e4:	e0fffe17 	ldw	r3,-8(fp)
811171e8:	10809824 	muli	r2,r2,608
811171ec:	1885883a 	add	r2,r3,r2
811171f0:	10809e04 	addi	r2,r2,632
811171f4:	00c00044 	movi	r3,1
811171f8:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
811171fc:	e0bffd0b 	ldhu	r2,-12(fp)
81117200:	e0fffe17 	ldw	r3,-8(fp)
81117204:	10809824 	muli	r2,r2,608
81117208:	1885883a 	add	r2,r3,r2
8111720c:	1080a004 	addi	r2,r2,640
81117210:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81117214:	e0bffd0b 	ldhu	r2,-12(fp)
81117218:	10809824 	muli	r2,r2,608
8111721c:	10809d04 	addi	r2,r2,628
81117220:	e0fffe17 	ldw	r3,-8(fp)
81117224:	1885883a 	add	r2,r3,r2
81117228:	1009883a 	mov	r4,r2
8111722c:	110a7500 	call	8110a750 <bSpwcSetLink>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81117230:	00a045f4 	movhi	r2,33047
81117234:	10a25304 	addi	r2,r2,-30388
81117238:	10800a8b 	ldhu	r2,42(r2)
8111723c:	10bfffcc 	andi	r2,r2,65535
81117240:	108000e8 	cmpgeui	r2,r2,3
81117244:	1000ba1e 	bne	r2,zero,81117530 <vPusType252run+0x3ec>
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
81117248:	d0a06217 	ldw	r2,-32376(gp)
8111724c:	e0fffd0b 	ldhu	r3,-12(fp)
81117250:	180d883a 	mov	r6,r3
81117254:	01604574 	movhi	r5,33045
81117258:	297f8704 	addi	r5,r5,-484
8111725c:	1009883a 	mov	r4,r2
81117260:	11232a00 	call	811232a0 <fprintf>
			}
			#endif

			break;
81117264:	0000b206 	br	81117530 <vPusType252run+0x3ec>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81117268:	e0bffd0b 	ldhu	r2,-12(fp)
8111726c:	10809824 	muli	r2,r2,608
81117270:	10809d04 	addi	r2,r2,628
81117274:	e0fffe17 	ldw	r3,-8(fp)
81117278:	1885883a 	add	r2,r3,r2
8111727c:	1009883a 	mov	r4,r2
81117280:	110a8880 	call	8110a888 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81117284:	e0bffd0b 	ldhu	r2,-12(fp)
81117288:	e0fffe17 	ldw	r3,-8(fp)
8111728c:	10809824 	muli	r2,r2,608
81117290:	1885883a 	add	r2,r3,r2
81117294:	10809f04 	addi	r2,r2,636
81117298:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
8111729c:	e0bffd0b 	ldhu	r2,-12(fp)
811172a0:	e0fffe17 	ldw	r3,-8(fp)
811172a4:	10809824 	muli	r2,r2,608
811172a8:	1885883a 	add	r2,r3,r2
811172ac:	10809e04 	addi	r2,r2,632
811172b0:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
811172b4:	e0bffd0b 	ldhu	r2,-12(fp)
811172b8:	e0fffe17 	ldw	r3,-8(fp)
811172bc:	10809824 	muli	r2,r2,608
811172c0:	1885883a 	add	r2,r3,r2
811172c4:	1080a004 	addi	r2,r2,640
811172c8:	00c00044 	movi	r3,1
811172cc:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
811172d0:	e0bffd0b 	ldhu	r2,-12(fp)
811172d4:	10809824 	muli	r2,r2,608
811172d8:	10809d04 	addi	r2,r2,628
811172dc:	e0fffe17 	ldw	r3,-8(fp)
811172e0:	1885883a 	add	r2,r3,r2
811172e4:	1009883a 	mov	r4,r2
811172e8:	110a7500 	call	8110a750 <bSpwcSetLink>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811172ec:	00a045f4 	movhi	r2,33047
811172f0:	10a25304 	addi	r2,r2,-30388
811172f4:	10800a8b 	ldhu	r2,42(r2)
811172f8:	10bfffcc 	andi	r2,r2,65535
811172fc:	108000e8 	cmpgeui	r2,r2,3
81117300:	10008d1e 	bne	r2,zero,81117538 <vPusType252run+0x3f4>
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81117304:	d0a06217 	ldw	r2,-32376(gp)
81117308:	e0fffd0b 	ldhu	r3,-12(fp)
8111730c:	180d883a 	mov	r6,r3
81117310:	01604574 	movhi	r5,33045
81117314:	297f9004 	addi	r5,r5,-448
81117318:	1009883a 	mov	r4,r2
8111731c:	11232a00 	call	811232a0 <fprintf>
			}
			#endif

			break;
81117320:	00008506 	br	81117538 <vPusType252run+0x3f4>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81117324:	e0bffd0b 	ldhu	r2,-12(fp)
81117328:	e0fffe17 	ldw	r3,-8(fp)
8111732c:	10809824 	muli	r2,r2,608
81117330:	1885883a 	add	r2,r3,r2
81117334:	10803e04 	addi	r2,r2,248
81117338:	10800017 	ldw	r2,0(r2)
8111733c:	10800058 	cmpnei	r2,r2,1
81117340:	10004a1e 	bne	r2,zero,8111746c <vPusType252run+0x328>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81117344:	e0bffd0b 	ldhu	r2,-12(fp)
81117348:	10809824 	muli	r2,r2,608
8111734c:	10805704 	addi	r2,r2,348
81117350:	e0fffe17 	ldw	r3,-8(fp)
81117354:	1885883a 	add	r2,r3,r2
81117358:	1009883a 	mov	r4,r2
8111735c:	1107dcc0 	call	81107dcc <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81117360:	e0bffd0b 	ldhu	r2,-12(fp)
81117364:	e0fffe17 	ldw	r3,-8(fp)
81117368:	10809824 	muli	r2,r2,608
8111736c:	1885883a 	add	r2,r3,r2
81117370:	10806704 	addi	r2,r2,412
81117374:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81117378:	e0bffd0b 	ldhu	r2,-12(fp)
8111737c:	10809824 	muli	r2,r2,608
81117380:	10805704 	addi	r2,r2,348
81117384:	e0fffe17 	ldw	r3,-8(fp)
81117388:	1885883a 	add	r2,r3,r2
8111738c:	1009883a 	mov	r4,r2
81117390:	1107d200 	call	81107d20 <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81117394:	e0bffd0b 	ldhu	r2,-12(fp)
81117398:	10809824 	muli	r2,r2,608
8111739c:	10805704 	addi	r2,r2,348
811173a0:	e0fffe17 	ldw	r3,-8(fp)
811173a4:	1885883a 	add	r2,r3,r2
811173a8:	1009883a 	mov	r4,r2
811173ac:	1107fb80 	call	81107fb8 <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
811173b0:	e0bffd0b 	ldhu	r2,-12(fp)
811173b4:	e0ffff17 	ldw	r3,-4(fp)
811173b8:	18c00b0b 	ldhu	r3,44(r3)
811173bc:	1809883a 	mov	r4,r3
811173c0:	e0fffe17 	ldw	r3,-8(fp)
811173c4:	10809824 	muli	r2,r2,608
811173c8:	1885883a 	add	r2,r3,r2
811173cc:	10805804 	addi	r2,r2,352
811173d0:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
811173d4:	e0bffd0b 	ldhu	r2,-12(fp)
811173d8:	e0ffff17 	ldw	r3,-4(fp)
811173dc:	18c0098b 	ldhu	r3,38(r3)
811173e0:	1809883a 	mov	r4,r3
811173e4:	e0fffe17 	ldw	r3,-8(fp)
811173e8:	10809824 	muli	r2,r2,608
811173ec:	1885883a 	add	r2,r3,r2
811173f0:	10805844 	addi	r2,r2,353
811173f4:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811173f8:	e0bffd0b 	ldhu	r2,-12(fp)
811173fc:	10809824 	muli	r2,r2,608
81117400:	10805704 	addi	r2,r2,348
81117404:	e0fffe17 	ldw	r3,-8(fp)
81117408:	1885883a 	add	r2,r3,r2
8111740c:	1009883a 	mov	r4,r2
81117410:	1107edc0 	call	81107edc <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81117414:	e0bffd0b 	ldhu	r2,-12(fp)
81117418:	10809824 	muli	r2,r2,608
8111741c:	10805704 	addi	r2,r2,348
81117420:	e0fffe17 	ldw	r3,-8(fp)
81117424:	1885883a 	add	r2,r3,r2
81117428:	1009883a 	mov	r4,r2
8111742c:	1107dcc0 	call	81107dcc <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81117430:	e0bffd0b 	ldhu	r2,-12(fp)
81117434:	e0fffe17 	ldw	r3,-8(fp)
81117438:	10809824 	muli	r2,r2,608
8111743c:	1885883a 	add	r2,r3,r2
81117440:	10806704 	addi	r2,r2,412
81117444:	00c00044 	movi	r3,1
81117448:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
8111744c:	e0bffd0b 	ldhu	r2,-12(fp)
81117450:	10809824 	muli	r2,r2,608
81117454:	10805704 	addi	r2,r2,348
81117458:	e0fffe17 	ldw	r3,-8(fp)
8111745c:	1885883a 	add	r2,r3,r2
81117460:	1009883a 	mov	r4,r2
81117464:	1107d200 	call	81107d20 <bRmapSetIrqControl>
81117468:	00000d06 	br	811174a0 <vPusType252run+0x35c>
			} else {
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8111746c:	00a045f4 	movhi	r2,33047
81117470:	10a25304 	addi	r2,r2,-30388
81117474:	10800a8b 	ldhu	r2,42(r2)
81117478:	10bfffcc 	andi	r2,r2,65535
8111747c:	10800168 	cmpgeui	r2,r2,5
81117480:	1000071e 	bne	r2,zero,811174a0 <vPusType252run+0x35c>
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
81117484:	d0a06217 	ldw	r2,-32376(gp)
81117488:	e0fffd0b 	ldhu	r3,-12(fp)
8111748c:	180d883a 	mov	r6,r3
81117490:	01604574 	movhi	r5,33045
81117494:	297f9904 	addi	r5,r5,-412
81117498:	1009883a 	mov	r4,r2
8111749c:	11232a00 	call	811232a0 <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811174a0:	00a045f4 	movhi	r2,33047
811174a4:	10a25304 	addi	r2,r2,-30388
811174a8:	10800a8b 	ldhu	r2,42(r2)
811174ac:	10bfffcc 	andi	r2,r2,65535
811174b0:	108000e8 	cmpgeui	r2,r2,3
811174b4:	1000221e 	bne	r2,zero,81117540 <vPusType252run+0x3fc>
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
811174b8:	d0e06217 	ldw	r3,-32376(gp)
811174bc:	e0bfff17 	ldw	r2,-4(fp)
811174c0:	10800b0b 	ldhu	r2,44(r2)
811174c4:	113fffcc 	andi	r4,r2,65535
811174c8:	e0bfff17 	ldw	r2,-4(fp)
811174cc:	1080098b 	ldhu	r2,38(r2)
811174d0:	10bfffcc 	andi	r2,r2,65535
811174d4:	100f883a 	mov	r7,r2
811174d8:	200d883a 	mov	r6,r4
811174dc:	01604574 	movhi	r5,33045
811174e0:	297f4f04 	addi	r5,r5,-708
811174e4:	1809883a 	mov	r4,r3
811174e8:	11232a00 	call	811232a0 <fprintf>
			}
			#endif
			break;
811174ec:	00001406 	br	81117540 <vPusType252run+0x3fc>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811174f0:	00a045f4 	movhi	r2,33047
811174f4:	10a25304 	addi	r2,r2,-30388
811174f8:	10800a8b 	ldhu	r2,42(r2)
811174fc:	10bfffcc 	andi	r2,r2,65535
81117500:	10800168 	cmpgeui	r2,r2,5
81117504:	1000101e 	bne	r2,zero,81117548 <vPusType252run+0x404>
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81117508:	d0a06217 	ldw	r2,-32376(gp)
8111750c:	100f883a 	mov	r7,r2
81117510:	01800c84 	movi	r6,50
81117514:	01400044 	movi	r5,1
81117518:	01204574 	movhi	r4,33045
8111751c:	213f6c04 	addi	r4,r4,-592
81117520:	112393c0 	call	8112393c <fwrite>
			}
			#endif
			break;
81117524:	00000806 	br	81117548 <vPusType252run+0x404>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
81117528:	0001883a 	nop
8111752c:	00000706 	br	8111754c <vPusType252run+0x408>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
			}
			#endif

			break;
81117530:	0001883a 	nop
81117534:	00000506 	br	8111754c <vPusType252run+0x408>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
			}
			#endif

			break;
81117538:	0001883a 	nop
8111753c:	00000306 	br	8111754c <vPusType252run+0x408>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			}
			#endif
			break;
81117540:	0001883a 	nop
81117544:	00000106 	br	8111754c <vPusType252run+0x408>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
81117548:	0001883a 	nop
	}
}
8111754c:	0001883a 	nop
81117550:	e037883a 	mov	sp,fp
81117554:	dfc00117 	ldw	ra,4(sp)
81117558:	df000017 	ldw	fp,0(sp)
8111755c:	dec00204 	addi	sp,sp,8
81117560:	f800283a 	ret

81117564 <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81117564:	defff904 	addi	sp,sp,-28
81117568:	de00012e 	bgeu	sp,et,81117570 <vSendCmdQToNFeeCTRL+0xc>
8111756c:	003b68fa 	trap	3
81117570:	dfc00615 	stw	ra,24(sp)
81117574:	df000515 	stw	fp,20(sp)
81117578:	df000504 	addi	fp,sp,20
8111757c:	2807883a 	mov	r3,r5
81117580:	3005883a 	mov	r2,r6
81117584:	e13ffd05 	stb	r4,-12(fp)
81117588:	e0fffe05 	stb	r3,-8(fp)
8111758c:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81117590:	00800404 	movi	r2,16
81117594:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81117598:	e0bffd03 	ldbu	r2,-12(fp)
8111759c:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811175a0:	e0bffe03 	ldbu	r2,-8(fp)
811175a4:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811175a8:	e0bfff03 	ldbu	r2,-4(fp)
811175ac:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811175b0:	d0a07017 	ldw	r2,-32320(gp)
811175b4:	e0fffc17 	ldw	r3,-16(fp)
811175b8:	180b883a 	mov	r5,r3
811175bc:	1009883a 	mov	r4,r2
811175c0:	113fc6c0 	call	8113fc6c <OSQPost>
811175c4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811175c8:	e0bffb03 	ldbu	r2,-20(fp)
811175cc:	10000126 	beq	r2,zero,811175d4 <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
811175d0:	111f2b00 	call	8111f2b0 <vFailSendMsgFeeCTRL>
	}
}
811175d4:	0001883a 	nop
811175d8:	e037883a 	mov	sp,fp
811175dc:	dfc00117 	ldw	ra,4(sp)
811175e0:	df000017 	ldw	fp,0(sp)
811175e4:	dec00204 	addi	sp,sp,8
811175e8:	f800283a 	ret

811175ec <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811175ec:	defff904 	addi	sp,sp,-28
811175f0:	de00012e 	bgeu	sp,et,811175f8 <vSendCmdQToNFeeCTRL_PRIO+0xc>
811175f4:	003b68fa 	trap	3
811175f8:	dfc00615 	stw	ra,24(sp)
811175fc:	df000515 	stw	fp,20(sp)
81117600:	df000504 	addi	fp,sp,20
81117604:	2807883a 	mov	r3,r5
81117608:	3005883a 	mov	r2,r6
8111760c:	e13ffd05 	stb	r4,-12(fp)
81117610:	e0fffe05 	stb	r3,-8(fp)
81117614:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81117618:	00800404 	movi	r2,16
8111761c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81117620:	e0bffd03 	ldbu	r2,-12(fp)
81117624:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81117628:	e0bffe03 	ldbu	r2,-8(fp)
8111762c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81117630:	e0bfff03 	ldbu	r2,-4(fp)
81117634:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81117638:	d0a07017 	ldw	r2,-32320(gp)
8111763c:	e0fffc17 	ldw	r3,-16(fp)
81117640:	180b883a 	mov	r5,r3
81117644:	1009883a 	mov	r4,r2
81117648:	113fddc0 	call	8113fddc <OSQPostFront>
8111764c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81117650:	e0bffb03 	ldbu	r2,-20(fp)
81117654:	10000126 	beq	r2,zero,8111765c <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81117658:	111f2b00 	call	8111f2b0 <vFailSendMsgFeeCTRL>
	}
}
8111765c:	0001883a 	nop
81117660:	e037883a 	mov	sp,fp
81117664:	dfc00117 	ldw	ra,4(sp)
81117668:	df000017 	ldw	fp,0(sp)
8111766c:	dec00204 	addi	sp,sp,8
81117670:	f800283a 	ret

81117674 <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81117674:	defff804 	addi	sp,sp,-32
81117678:	de00012e 	bgeu	sp,et,81117680 <vSendCmdQToNFeeCTRL_GEN+0xc>
8111767c:	003b68fa 	trap	3
81117680:	dfc00715 	stw	ra,28(sp)
81117684:	df000615 	stw	fp,24(sp)
81117688:	df000604 	addi	fp,sp,24
8111768c:	2011883a 	mov	r8,r4
81117690:	2809883a 	mov	r4,r5
81117694:	3007883a 	mov	r3,r6
81117698:	3805883a 	mov	r2,r7
8111769c:	e23ffc05 	stb	r8,-16(fp)
811176a0:	e13ffd05 	stb	r4,-12(fp)
811176a4:	e0fffe05 	stb	r3,-8(fp)
811176a8:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
811176ac:	e0bffc03 	ldbu	r2,-16(fp)
811176b0:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811176b4:	e0bffd03 	ldbu	r2,-12(fp)
811176b8:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811176bc:	e0bffe03 	ldbu	r2,-8(fp)
811176c0:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811176c4:	e0bfff03 	ldbu	r2,-4(fp)
811176c8:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811176cc:	d0a07017 	ldw	r2,-32320(gp)
811176d0:	e0fffb17 	ldw	r3,-20(fp)
811176d4:	180b883a 	mov	r5,r3
811176d8:	1009883a 	mov	r4,r2
811176dc:	113fc6c0 	call	8113fc6c <OSQPost>
811176e0:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
811176e4:	e0bffa03 	ldbu	r2,-24(fp)
811176e8:	10000126 	beq	r2,zero,811176f0 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
811176ec:	111f2b00 	call	8111f2b0 <vFailSendMsgFeeCTRL>
	}
}
811176f0:	0001883a 	nop
811176f4:	e037883a 	mov	sp,fp
811176f8:	dfc00117 	ldw	ra,4(sp)
811176fc:	df000017 	ldw	fp,0(sp)
81117700:	dec00204 	addi	sp,sp,8
81117704:	f800283a 	ret

81117708 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81117708:	defff904 	addi	sp,sp,-28
8111770c:	de00012e 	bgeu	sp,et,81117714 <vSendCmdQToDataCTRL+0xc>
81117710:	003b68fa 	trap	3
81117714:	dfc00615 	stw	ra,24(sp)
81117718:	df000515 	stw	fp,20(sp)
8111771c:	df000504 	addi	fp,sp,20
81117720:	2807883a 	mov	r3,r5
81117724:	3005883a 	mov	r2,r6
81117728:	e13ffd05 	stb	r4,-12(fp)
8111772c:	e0fffe05 	stb	r3,-8(fp)
81117730:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81117734:	00800804 	movi	r2,32
81117738:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111773c:	e0bffd03 	ldbu	r2,-12(fp)
81117740:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81117744:	e0bffe03 	ldbu	r2,-8(fp)
81117748:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111774c:	e0bfff03 	ldbu	r2,-4(fp)
81117750:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81117754:	d0a05f17 	ldw	r2,-32388(gp)
81117758:	e0fffc17 	ldw	r3,-16(fp)
8111775c:	180b883a 	mov	r5,r3
81117760:	1009883a 	mov	r4,r2
81117764:	113fc6c0 	call	8113fc6c <OSQPost>
81117768:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111776c:	e0bffb03 	ldbu	r2,-20(fp)
81117770:	10000126 	beq	r2,zero,81117778 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81117774:	111f3140 	call	8111f314 <vFailSendMsgDataCTRL>
	}
}
81117778:	0001883a 	nop
8111777c:	e037883a 	mov	sp,fp
81117780:	dfc00117 	ldw	ra,4(sp)
81117784:	df000017 	ldw	fp,0(sp)
81117788:	dec00204 	addi	sp,sp,8
8111778c:	f800283a 	ret

81117790 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81117790:	defff904 	addi	sp,sp,-28
81117794:	de00012e 	bgeu	sp,et,8111779c <vSendCmdQToDataCTRL_PRIO+0xc>
81117798:	003b68fa 	trap	3
8111779c:	dfc00615 	stw	ra,24(sp)
811177a0:	df000515 	stw	fp,20(sp)
811177a4:	df000504 	addi	fp,sp,20
811177a8:	2807883a 	mov	r3,r5
811177ac:	3005883a 	mov	r2,r6
811177b0:	e13ffd05 	stb	r4,-12(fp)
811177b4:	e0fffe05 	stb	r3,-8(fp)
811177b8:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811177bc:	00800404 	movi	r2,16
811177c0:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811177c4:	e0bffd03 	ldbu	r2,-12(fp)
811177c8:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811177cc:	e0bffe03 	ldbu	r2,-8(fp)
811177d0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811177d4:	e0bfff03 	ldbu	r2,-4(fp)
811177d8:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
811177dc:	d0a05f17 	ldw	r2,-32388(gp)
811177e0:	e0fffc17 	ldw	r3,-16(fp)
811177e4:	180b883a 	mov	r5,r3
811177e8:	1009883a 	mov	r4,r2
811177ec:	113fddc0 	call	8113fddc <OSQPostFront>
811177f0:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811177f4:	e0bffb03 	ldbu	r2,-20(fp)
811177f8:	10000126 	beq	r2,zero,81117800 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
811177fc:	111f2b00 	call	8111f2b0 <vFailSendMsgFeeCTRL>
	}
}
81117800:	0001883a 	nop
81117804:	e037883a 	mov	sp,fp
81117808:	dfc00117 	ldw	ra,4(sp)
8111780c:	df000017 	ldw	fp,0(sp)
81117810:	dec00204 	addi	sp,sp,8
81117814:	f800283a 	ret

81117818 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
81117818:	defffc04 	addi	sp,sp,-16
8111781c:	de00012e 	bgeu	sp,et,81117824 <vMebInit+0xc>
81117820:	003b68fa 	trap	3
81117824:	dfc00315 	stw	ra,12(sp)
81117828:	df000215 	stw	fp,8(sp)
8111782c:	df000204 	addi	fp,sp,8
81117830:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
81117834:	e0bfff17 	ldw	r2,-4(fp)
81117838:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
8111783c:	e0bfff17 	ldw	r2,-4(fp)
81117840:	00c00044 	movi	r3,1
81117844:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
81117848:	d0a06917 	ldw	r2,-32348(gp)
8111784c:	1009883a 	mov	r4,r2
81117850:	113f7a40 	call	8113f7a4 <OSQFlush>
81117854:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
81117858:	e0bffe03 	ldbu	r2,-8(fp)
8111785c:	10000126 	beq	r2,zero,81117864 <vMebInit+0x4c>
		vFailFlushMEBQueue();
81117860:	111f4400 	call	8111f440 <vFailFlushMEBQueue>
	}
}
81117864:	0001883a 	nop
81117868:	e037883a 	mov	sp,fp
8111786c:	dfc00117 	ldw	ra,4(sp)
81117870:	df000017 	ldw	fp,0(sp)
81117874:	dec00204 	addi	sp,sp,8
81117878:	f800283a 	ret

8111787c <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
8111787c:	defffe04 	addi	sp,sp,-8
81117880:	de00012e 	bgeu	sp,et,81117888 <vSwapMemmory+0xc>
81117884:	003b68fa 	trap	3
81117888:	df000115 	stw	fp,4(sp)
8111788c:	df000104 	addi	fp,sp,4
81117890:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
81117894:	e0bfff17 	ldw	r2,-4(fp)
81117898:	10800203 	ldbu	r2,8(r2)
8111789c:	10803fcc 	andi	r2,r2,255
811178a0:	10c00044 	addi	r3,r2,1
811178a4:	00a00034 	movhi	r2,32768
811178a8:	10800044 	addi	r2,r2,1
811178ac:	1884703a 	and	r2,r3,r2
811178b0:	1000040e 	bge	r2,zero,811178c4 <vSwapMemmory+0x48>
811178b4:	10bfffc4 	addi	r2,r2,-1
811178b8:	00ffff84 	movi	r3,-2
811178bc:	10c4b03a 	or	r2,r2,r3
811178c0:	10800044 	addi	r2,r2,1
811178c4:	1007883a 	mov	r3,r2
811178c8:	e0bfff17 	ldw	r2,-4(fp)
811178cc:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
811178d0:	e0bfff17 	ldw	r2,-4(fp)
811178d4:	10800243 	ldbu	r2,9(r2)
811178d8:	10803fcc 	andi	r2,r2,255
811178dc:	10c00044 	addi	r3,r2,1
811178e0:	00a00034 	movhi	r2,32768
811178e4:	10800044 	addi	r2,r2,1
811178e8:	1884703a 	and	r2,r3,r2
811178ec:	1000040e 	bge	r2,zero,81117900 <vSwapMemmory+0x84>
811178f0:	10bfffc4 	addi	r2,r2,-1
811178f4:	00ffff84 	movi	r3,-2
811178f8:	10c4b03a 	or	r2,r2,r3
811178fc:	10800044 	addi	r2,r2,1
81117900:	1007883a 	mov	r3,r2
81117904:	e0bfff17 	ldw	r2,-4(fp)
81117908:	10c00245 	stb	r3,9(r2)

}
8111790c:	0001883a 	nop
81117910:	e037883a 	mov	sp,fp
81117914:	df000017 	ldw	fp,0(sp)
81117918:	dec00104 	addi	sp,sp,4
8111791c:	f800283a 	ret

81117920 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
81117920:	defffc04 	addi	sp,sp,-16
81117924:	de00012e 	bgeu	sp,et,8111792c <vReleaseSyncMessages+0xc>
81117928:	003b68fa 	trap	3
8111792c:	dfc00315 	stw	ra,12(sp)
81117930:	df000215 	stw	fp,8(sp)
81117934:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
81117938:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
8111793c:	00bff844 	movi	r2,-31
81117940:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81117944:	e03ffe05 	stb	zero,-8(fp)
81117948:	00001606 	br	811179a4 <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8111794c:	e0bffe03 	ldbu	r2,-8(fp)
81117950:	10800444 	addi	r2,r2,17
81117954:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
81117958:	e0bffe03 	ldbu	r2,-8(fp)
8111795c:	1085883a 	add	r2,r2,r2
81117960:	1087883a 	add	r3,r2,r2
81117964:	d0a05c04 	addi	r2,gp,-32400
81117968:	1885883a 	add	r2,r3,r2
8111796c:	10800017 	ldw	r2,0(r2)
81117970:	e0ffff17 	ldw	r3,-4(fp)
81117974:	180b883a 	mov	r5,r3
81117978:	1009883a 	mov	r4,r2
8111797c:	113fc6c0 	call	8113fc6c <OSQPost>
81117980:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
81117984:	e0bffe43 	ldbu	r2,-7(fp)
81117988:	10000326 	beq	r2,zero,81117998 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
8111798c:	e0bffe03 	ldbu	r2,-8(fp)
81117990:	1009883a 	mov	r4,r2
81117994:	111f1740 	call	8111f174 <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81117998:	e0bffe03 	ldbu	r2,-8(fp)
8111799c:	10800044 	addi	r2,r2,1
811179a0:	e0bffe05 	stb	r2,-8(fp)
811179a4:	e0bffe03 	ldbu	r2,-8(fp)
811179a8:	103fe826 	beq	r2,zero,8111794c <__reset+0xfb0f794c>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
811179ac:	0001883a 	nop
811179b0:	e037883a 	mov	sp,fp
811179b4:	dfc00117 	ldw	ra,4(sp)
811179b8:	df000017 	ldw	fp,0(sp)
811179bc:	dec00204 	addi	sp,sp,8
811179c0:	f800283a 	ret

811179c4 <vStackMonitor>:
    }
}

#else
#if DEBUG_ON
void vStackMonitor(void *task_data) {
811179c4:	defff804 	addi	sp,sp,-32
811179c8:	de00012e 	bgeu	sp,et,811179d0 <vStackMonitor+0xc>
811179cc:	003b68fa 	trap	3
811179d0:	dfc00715 	stw	ra,28(sp)
811179d4:	df000615 	stw	fp,24(sp)
811179d8:	df000604 	addi	fp,sp,24
811179dc:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
811179e0:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
811179e4:	d0a06217 	ldw	r2,-32376(gp)
811179e8:	100f883a 	mov	r7,r2
811179ec:	018006c4 	movi	r6,27
811179f0:	01400044 	movi	r5,1
811179f4:	01204574 	movhi	r4,33045
811179f8:	213fac04 	addi	r4,r4,-336
811179fc:	112393c0 	call	8112393c <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
81117a00:	d0a06217 	ldw	r2,-32376(gp)
81117a04:	100f883a 	mov	r7,r2
81117a08:	01800b04 	movi	r6,44
81117a0c:	01400044 	movi	r5,1
81117a10:	01204574 	movhi	r4,33045
81117a14:	213fb304 	addi	r4,r4,-308
81117a18:	112393c0 	call	8112393c <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
81117a1c:	d0a06217 	ldw	r2,-32376(gp)
81117a20:	100f883a 	mov	r7,r2
81117a24:	01800f84 	movi	r6,62
81117a28:	01400044 	movi	r5,1
81117a2c:	01204574 	movhi	r4,33045
81117a30:	213fbf04 	addi	r4,r4,-260
81117a34:	112393c0 	call	8112393c <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
81117a38:	e0bffd04 	addi	r2,fp,-12
81117a3c:	100b883a 	mov	r5,r2
81117a40:	01000804 	movi	r4,32
81117a44:	11420900 	call	81142090 <OSTaskStkChk>
81117a48:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
81117a4c:	e0bffc03 	ldbu	r2,-16(fp)
81117a50:	10000f1e 	bne	r2,zero,81117a90 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117a54:	d1206217 	ldw	r4,-32376(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
81117a58:	e0fffd17 	ldw	r3,-12(fp)
81117a5c:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117a60:	188b883a 	add	r5,r3,r2
81117a64:	e0bffd17 	ldw	r2,-12(fp)
81117a68:	e0fffe17 	ldw	r3,-8(fp)
81117a6c:	d8c00115 	stw	r3,4(sp)
81117a70:	d8800015 	stw	r2,0(sp)
81117a74:	280f883a 	mov	r7,r5
81117a78:	01a04574 	movhi	r6,33045
81117a7c:	31bfcf04 	addi	r6,r6,-196
81117a80:	01604574 	movhi	r5,33045
81117a84:	297fd304 	addi	r5,r5,-180
81117a88:	11232a00 	call	811232a0 <fprintf>
81117a8c:	00000706 	br	81117aac <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81117a90:	d0a06217 	ldw	r2,-32376(gp)
81117a94:	100f883a 	mov	r7,r2
81117a98:	01800904 	movi	r6,36
81117a9c:	01400044 	movi	r5,1
81117aa0:	01204574 	movhi	r4,33045
81117aa4:	213fe204 	addi	r4,r4,-120
81117aa8:	112393c0 	call	8112393c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
81117aac:	e0bffd04 	addi	r2,fp,-12
81117ab0:	100b883a 	mov	r5,r2
81117ab4:	01000784 	movi	r4,30
81117ab8:	11420900 	call	81142090 <OSTaskStkChk>
81117abc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117ac0:	e0bffc03 	ldbu	r2,-16(fp)
81117ac4:	10000f1e 	bne	r2,zero,81117b04 <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117ac8:	d1206217 	ldw	r4,-32376(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
81117acc:	e0fffd17 	ldw	r3,-12(fp)
81117ad0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117ad4:	188b883a 	add	r5,r3,r2
81117ad8:	e0bffd17 	ldw	r2,-12(fp)
81117adc:	e0fffe17 	ldw	r3,-8(fp)
81117ae0:	d8c00115 	stw	r3,4(sp)
81117ae4:	d8800015 	stw	r2,0(sp)
81117ae8:	280f883a 	mov	r7,r5
81117aec:	01a04574 	movhi	r6,33045
81117af0:	31bfec04 	addi	r6,r6,-80
81117af4:	01604574 	movhi	r5,33045
81117af8:	297fd304 	addi	r5,r5,-180
81117afc:	11232a00 	call	811232a0 <fprintf>
81117b00:	00000706 	br	81117b20 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
81117b04:	d0a06217 	ldw	r2,-32376(gp)
81117b08:	100f883a 	mov	r7,r2
81117b0c:	01800984 	movi	r6,38
81117b10:	01400044 	movi	r5,1
81117b14:	01204574 	movhi	r4,33045
81117b18:	213ff004 	addi	r4,r4,-64
81117b1c:	112393c0 	call	8112393c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
81117b20:	e0bffd04 	addi	r2,fp,-12
81117b24:	100b883a 	mov	r5,r2
81117b28:	01000704 	movi	r4,28
81117b2c:	11420900 	call	81142090 <OSTaskStkChk>
81117b30:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117b34:	e0bffc03 	ldbu	r2,-16(fp)
81117b38:	10000f1e 	bne	r2,zero,81117b78 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117b3c:	d1206217 	ldw	r4,-32376(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
81117b40:	e0fffd17 	ldw	r3,-12(fp)
81117b44:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117b48:	188b883a 	add	r5,r3,r2
81117b4c:	e0bffd17 	ldw	r2,-12(fp)
81117b50:	e0fffe17 	ldw	r3,-8(fp)
81117b54:	d8c00115 	stw	r3,4(sp)
81117b58:	d8800015 	stw	r2,0(sp)
81117b5c:	280f883a 	mov	r7,r5
81117b60:	01a04574 	movhi	r6,33045
81117b64:	31bffa04 	addi	r6,r6,-24
81117b68:	01604574 	movhi	r5,33045
81117b6c:	297fd304 	addi	r5,r5,-180
81117b70:	11232a00 	call	811232a0 <fprintf>
81117b74:	00000706 	br	81117b94 <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
81117b78:	d0a06217 	ldw	r2,-32376(gp)
81117b7c:	100f883a 	mov	r7,r2
81117b80:	01800884 	movi	r6,34
81117b84:	01400044 	movi	r5,1
81117b88:	01204574 	movhi	r4,33045
81117b8c:	213ffd04 	addi	r4,r4,-12
81117b90:	112393c0 	call	8112393c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
81117b94:	e0bffd04 	addi	r2,fp,-12
81117b98:	100b883a 	mov	r5,r2
81117b9c:	010006c4 	movi	r4,27
81117ba0:	11420900 	call	81142090 <OSTaskStkChk>
81117ba4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117ba8:	e0bffc03 	ldbu	r2,-16(fp)
81117bac:	10000f1e 	bne	r2,zero,81117bec <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117bb0:	d1206217 	ldw	r4,-32376(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
81117bb4:	e0fffd17 	ldw	r3,-12(fp)
81117bb8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117bbc:	188b883a 	add	r5,r3,r2
81117bc0:	e0bffd17 	ldw	r2,-12(fp)
81117bc4:	e0fffe17 	ldw	r3,-8(fp)
81117bc8:	d8c00115 	stw	r3,4(sp)
81117bcc:	d8800015 	stw	r2,0(sp)
81117bd0:	280f883a 	mov	r7,r5
81117bd4:	01a04574 	movhi	r6,33045
81117bd8:	31800604 	addi	r6,r6,24
81117bdc:	01604574 	movhi	r5,33045
81117be0:	297fd304 	addi	r5,r5,-180
81117be4:	11232a00 	call	811232a0 <fprintf>
81117be8:	00000706 	br	81117c08 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
81117bec:	d0a06217 	ldw	r2,-32376(gp)
81117bf0:	100f883a 	mov	r7,r2
81117bf4:	018008c4 	movi	r6,35
81117bf8:	01400044 	movi	r5,1
81117bfc:	01204574 	movhi	r4,33045
81117c00:	21000a04 	addi	r4,r4,40
81117c04:	112393c0 	call	8112393c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
81117c08:	e0bffd04 	addi	r2,fp,-12
81117c0c:	100b883a 	mov	r5,r2
81117c10:	01000684 	movi	r4,26
81117c14:	11420900 	call	81142090 <OSTaskStkChk>
81117c18:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117c1c:	e0bffc03 	ldbu	r2,-16(fp)
81117c20:	10000f1e 	bne	r2,zero,81117c60 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117c24:	d1206217 	ldw	r4,-32376(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
81117c28:	e0fffd17 	ldw	r3,-12(fp)
81117c2c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117c30:	188b883a 	add	r5,r3,r2
81117c34:	e0bffd17 	ldw	r2,-12(fp)
81117c38:	e0fffe17 	ldw	r3,-8(fp)
81117c3c:	d8c00115 	stw	r3,4(sp)
81117c40:	d8800015 	stw	r2,0(sp)
81117c44:	280f883a 	mov	r7,r5
81117c48:	01a04574 	movhi	r6,33045
81117c4c:	31801304 	addi	r6,r6,76
81117c50:	01604574 	movhi	r5,33045
81117c54:	297fd304 	addi	r5,r5,-180
81117c58:	11232a00 	call	811232a0 <fprintf>
81117c5c:	00000706 	br	81117c7c <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
81117c60:	d0a06217 	ldw	r2,-32376(gp)
81117c64:	100f883a 	mov	r7,r2
81117c68:	01800884 	movi	r6,34
81117c6c:	01400044 	movi	r5,1
81117c70:	01204574 	movhi	r4,33045
81117c74:	21001604 	addi	r4,r4,88
81117c78:	112393c0 	call	8112393c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
81117c7c:	e0bffd04 	addi	r2,fp,-12
81117c80:	100b883a 	mov	r5,r2
81117c84:	01000644 	movi	r4,25
81117c88:	11420900 	call	81142090 <OSTaskStkChk>
81117c8c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117c90:	e0bffc03 	ldbu	r2,-16(fp)
81117c94:	10000f1e 	bne	r2,zero,81117cd4 <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117c98:	d1206217 	ldw	r4,-32376(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
81117c9c:	e0fffd17 	ldw	r3,-12(fp)
81117ca0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117ca4:	188b883a 	add	r5,r3,r2
81117ca8:	e0bffd17 	ldw	r2,-12(fp)
81117cac:	e0fffe17 	ldw	r3,-8(fp)
81117cb0:	d8c00115 	stw	r3,4(sp)
81117cb4:	d8800015 	stw	r2,0(sp)
81117cb8:	280f883a 	mov	r7,r5
81117cbc:	01a04574 	movhi	r6,33045
81117cc0:	31801f04 	addi	r6,r6,124
81117cc4:	01604574 	movhi	r5,33045
81117cc8:	297fd304 	addi	r5,r5,-180
81117ccc:	11232a00 	call	811232a0 <fprintf>
81117cd0:	00000706 	br	81117cf0 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
81117cd4:	d0a06217 	ldw	r2,-32376(gp)
81117cd8:	100f883a 	mov	r7,r2
81117cdc:	01800884 	movi	r6,34
81117ce0:	01400044 	movi	r5,1
81117ce4:	01204574 	movhi	r4,33045
81117ce8:	21002204 	addi	r4,r4,136
81117cec:	112393c0 	call	8112393c <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
81117cf0:	e0bffd04 	addi	r2,fp,-12
81117cf4:	100b883a 	mov	r5,r2
81117cf8:	01000044 	movi	r4,1
81117cfc:	11420900 	call	81142090 <OSTaskStkChk>
81117d00:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117d04:	e0bffc03 	ldbu	r2,-16(fp)
81117d08:	10000f1e 	bne	r2,zero,81117d48 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117d0c:	d1206217 	ldw	r4,-32376(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
81117d10:	e0fffd17 	ldw	r3,-12(fp)
81117d14:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117d18:	188b883a 	add	r5,r3,r2
81117d1c:	e0bffd17 	ldw	r2,-12(fp)
81117d20:	e0fffe17 	ldw	r3,-8(fp)
81117d24:	d8c00115 	stw	r3,4(sp)
81117d28:	d8800015 	stw	r2,0(sp)
81117d2c:	280f883a 	mov	r7,r5
81117d30:	01a04574 	movhi	r6,33045
81117d34:	31802b04 	addi	r6,r6,172
81117d38:	01604574 	movhi	r5,33045
81117d3c:	297fd304 	addi	r5,r5,-180
81117d40:	11232a00 	call	811232a0 <fprintf>
81117d44:	00000706 	br	81117d64 <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
81117d48:	d0a06217 	ldw	r2,-32376(gp)
81117d4c:	100f883a 	mov	r7,r2
81117d50:	01800804 	movi	r6,32
81117d54:	01400044 	movi	r5,1
81117d58:	01204574 	movhi	r4,33045
81117d5c:	21002e04 	addi	r4,r4,184
81117d60:	112393c0 	call	8112393c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
81117d64:	e0bffd04 	addi	r2,fp,-12
81117d68:	100b883a 	mov	r5,r2
81117d6c:	010002c4 	movi	r4,11
81117d70:	11420900 	call	81142090 <OSTaskStkChk>
81117d74:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117d78:	e0bffc03 	ldbu	r2,-16(fp)
81117d7c:	10000f1e 	bne	r2,zero,81117dbc <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117d80:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
81117d84:	e0fffd17 	ldw	r3,-12(fp)
81117d88:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117d8c:	188b883a 	add	r5,r3,r2
81117d90:	e0bffd17 	ldw	r2,-12(fp)
81117d94:	e0fffe17 	ldw	r3,-8(fp)
81117d98:	d8c00115 	stw	r3,4(sp)
81117d9c:	d8800015 	stw	r2,0(sp)
81117da0:	280f883a 	mov	r7,r5
81117da4:	01a04574 	movhi	r6,33045
81117da8:	31803704 	addi	r6,r6,220
81117dac:	01604574 	movhi	r5,33045
81117db0:	297fd304 	addi	r5,r5,-180
81117db4:	11232a00 	call	811232a0 <fprintf>
81117db8:	00000706 	br	81117dd8 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
81117dbc:	d0a06217 	ldw	r2,-32376(gp)
81117dc0:	100f883a 	mov	r7,r2
81117dc4:	018008c4 	movi	r6,35
81117dc8:	01400044 	movi	r5,1
81117dcc:	01204574 	movhi	r4,33045
81117dd0:	21003a04 	addi	r4,r4,232
81117dd4:	112393c0 	call	8112393c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
81117dd8:	e0bffd04 	addi	r2,fp,-12
81117ddc:	100b883a 	mov	r5,r2
81117de0:	01000304 	movi	r4,12
81117de4:	11420900 	call	81142090 <OSTaskStkChk>
81117de8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117dec:	e0bffc03 	ldbu	r2,-16(fp)
81117df0:	10000f1e 	bne	r2,zero,81117e30 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117df4:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
81117df8:	e0fffd17 	ldw	r3,-12(fp)
81117dfc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117e00:	188b883a 	add	r5,r3,r2
81117e04:	e0bffd17 	ldw	r2,-12(fp)
81117e08:	e0fffe17 	ldw	r3,-8(fp)
81117e0c:	d8c00115 	stw	r3,4(sp)
81117e10:	d8800015 	stw	r2,0(sp)
81117e14:	280f883a 	mov	r7,r5
81117e18:	01a04574 	movhi	r6,33045
81117e1c:	31804304 	addi	r6,r6,268
81117e20:	01604574 	movhi	r5,33045
81117e24:	297fd304 	addi	r5,r5,-180
81117e28:	11232a00 	call	811232a0 <fprintf>
81117e2c:	00000706 	br	81117e4c <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
81117e30:	d0a06217 	ldw	r2,-32376(gp)
81117e34:	100f883a 	mov	r7,r2
81117e38:	018008c4 	movi	r6,35
81117e3c:	01400044 	movi	r5,1
81117e40:	01204574 	movhi	r4,33045
81117e44:	21004604 	addi	r4,r4,280
81117e48:	112393c0 	call	8112393c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
81117e4c:	e0bffd04 	addi	r2,fp,-12
81117e50:	100b883a 	mov	r5,r2
81117e54:	01000344 	movi	r4,13
81117e58:	11420900 	call	81142090 <OSTaskStkChk>
81117e5c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117e60:	e0bffc03 	ldbu	r2,-16(fp)
81117e64:	10000f1e 	bne	r2,zero,81117ea4 <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117e68:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
81117e6c:	e0fffd17 	ldw	r3,-12(fp)
81117e70:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117e74:	188b883a 	add	r5,r3,r2
81117e78:	e0bffd17 	ldw	r2,-12(fp)
81117e7c:	e0fffe17 	ldw	r3,-8(fp)
81117e80:	d8c00115 	stw	r3,4(sp)
81117e84:	d8800015 	stw	r2,0(sp)
81117e88:	280f883a 	mov	r7,r5
81117e8c:	01a04574 	movhi	r6,33045
81117e90:	31804f04 	addi	r6,r6,316
81117e94:	01604574 	movhi	r5,33045
81117e98:	297fd304 	addi	r5,r5,-180
81117e9c:	11232a00 	call	811232a0 <fprintf>
81117ea0:	00000706 	br	81117ec0 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
81117ea4:	d0a06217 	ldw	r2,-32376(gp)
81117ea8:	100f883a 	mov	r7,r2
81117eac:	018008c4 	movi	r6,35
81117eb0:	01400044 	movi	r5,1
81117eb4:	01204574 	movhi	r4,33045
81117eb8:	21005204 	addi	r4,r4,328
81117ebc:	112393c0 	call	8112393c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
81117ec0:	e0bffd04 	addi	r2,fp,-12
81117ec4:	100b883a 	mov	r5,r2
81117ec8:	01000384 	movi	r4,14
81117ecc:	11420900 	call	81142090 <OSTaskStkChk>
81117ed0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117ed4:	e0bffc03 	ldbu	r2,-16(fp)
81117ed8:	10000f1e 	bne	r2,zero,81117f18 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117edc:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
81117ee0:	e0fffd17 	ldw	r3,-12(fp)
81117ee4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117ee8:	188b883a 	add	r5,r3,r2
81117eec:	e0bffd17 	ldw	r2,-12(fp)
81117ef0:	e0fffe17 	ldw	r3,-8(fp)
81117ef4:	d8c00115 	stw	r3,4(sp)
81117ef8:	d8800015 	stw	r2,0(sp)
81117efc:	280f883a 	mov	r7,r5
81117f00:	01a04574 	movhi	r6,33045
81117f04:	31805b04 	addi	r6,r6,364
81117f08:	01604574 	movhi	r5,33045
81117f0c:	297fd304 	addi	r5,r5,-180
81117f10:	11232a00 	call	811232a0 <fprintf>
81117f14:	00000706 	br	81117f34 <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
81117f18:	d0a06217 	ldw	r2,-32376(gp)
81117f1c:	100f883a 	mov	r7,r2
81117f20:	018008c4 	movi	r6,35
81117f24:	01400044 	movi	r5,1
81117f28:	01204574 	movhi	r4,33045
81117f2c:	21005e04 	addi	r4,r4,376
81117f30:	112393c0 	call	8112393c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
81117f34:	e0bffd04 	addi	r2,fp,-12
81117f38:	100b883a 	mov	r5,r2
81117f3c:	010003c4 	movi	r4,15
81117f40:	11420900 	call	81142090 <OSTaskStkChk>
81117f44:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117f48:	e0bffc03 	ldbu	r2,-16(fp)
81117f4c:	10000f1e 	bne	r2,zero,81117f8c <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117f50:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
81117f54:	e0fffd17 	ldw	r3,-12(fp)
81117f58:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117f5c:	188b883a 	add	r5,r3,r2
81117f60:	e0bffd17 	ldw	r2,-12(fp)
81117f64:	e0fffe17 	ldw	r3,-8(fp)
81117f68:	d8c00115 	stw	r3,4(sp)
81117f6c:	d8800015 	stw	r2,0(sp)
81117f70:	280f883a 	mov	r7,r5
81117f74:	01a04574 	movhi	r6,33045
81117f78:	31806704 	addi	r6,r6,412
81117f7c:	01604574 	movhi	r5,33045
81117f80:	297fd304 	addi	r5,r5,-180
81117f84:	11232a00 	call	811232a0 <fprintf>
81117f88:	00000706 	br	81117fa8 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
81117f8c:	d0a06217 	ldw	r2,-32376(gp)
81117f90:	100f883a 	mov	r7,r2
81117f94:	018008c4 	movi	r6,35
81117f98:	01400044 	movi	r5,1
81117f9c:	01204574 	movhi	r4,33045
81117fa0:	21006a04 	addi	r4,r4,424
81117fa4:	112393c0 	call	8112393c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81117fa8:	e0bffd04 	addi	r2,fp,-12
81117fac:	100b883a 	mov	r5,r2
81117fb0:	01000404 	movi	r4,16
81117fb4:	11420900 	call	81142090 <OSTaskStkChk>
81117fb8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117fbc:	e0bffc03 	ldbu	r2,-16(fp)
81117fc0:	10000f1e 	bne	r2,zero,81118000 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117fc4:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
81117fc8:	e0fffd17 	ldw	r3,-12(fp)
81117fcc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117fd0:	188b883a 	add	r5,r3,r2
81117fd4:	e0bffd17 	ldw	r2,-12(fp)
81117fd8:	e0fffe17 	ldw	r3,-8(fp)
81117fdc:	d8c00115 	stw	r3,4(sp)
81117fe0:	d8800015 	stw	r2,0(sp)
81117fe4:	280f883a 	mov	r7,r5
81117fe8:	01a04574 	movhi	r6,33045
81117fec:	31807304 	addi	r6,r6,460
81117ff0:	01604574 	movhi	r5,33045
81117ff4:	297fd304 	addi	r5,r5,-180
81117ff8:	11232a00 	call	811232a0 <fprintf>
81117ffc:	00000706 	br	8111801c <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
81118000:	d0a06217 	ldw	r2,-32376(gp)
81118004:	100f883a 	mov	r7,r2
81118008:	018008c4 	movi	r6,35
8111800c:	01400044 	movi	r5,1
81118010:	01204574 	movhi	r4,33045
81118014:	21007604 	addi	r4,r4,472
81118018:	112393c0 	call	8112393c <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
8111801c:	e0bffd04 	addi	r2,fp,-12
81118020:	100b883a 	mov	r5,r2
81118024:	01000284 	movi	r4,10
81118028:	11420900 	call	81142090 <OSTaskStkChk>
8111802c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81118030:	e0bffc03 	ldbu	r2,-16(fp)
81118034:	10000f1e 	bne	r2,zero,81118074 <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118038:	d1206217 	ldw	r4,-32376(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
8111803c:	e0fffd17 	ldw	r3,-12(fp)
81118040:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118044:	188b883a 	add	r5,r3,r2
81118048:	e0bffd17 	ldw	r2,-12(fp)
8111804c:	e0fffe17 	ldw	r3,-8(fp)
81118050:	d8c00115 	stw	r3,4(sp)
81118054:	d8800015 	stw	r2,0(sp)
81118058:	280f883a 	mov	r7,r5
8111805c:	01a04574 	movhi	r6,33045
81118060:	31807f04 	addi	r6,r6,508
81118064:	01604574 	movhi	r5,33045
81118068:	297fd304 	addi	r5,r5,-180
8111806c:	11232a00 	call	811232a0 <fprintf>
81118070:	00000706 	br	81118090 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
81118074:	d0a06217 	ldw	r2,-32376(gp)
81118078:	100f883a 	mov	r7,r2
8111807c:	01800884 	movi	r6,34
81118080:	01400044 	movi	r5,1
81118084:	01204574 	movhi	r4,33045
81118088:	21008204 	addi	r4,r4,520
8111808c:	112393c0 	call	8112393c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
81118090:	e0bffd04 	addi	r2,fp,-12
81118094:	100b883a 	mov	r5,r2
81118098:	01000244 	movi	r4,9
8111809c:	11420900 	call	81142090 <OSTaskStkChk>
811180a0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811180a4:	e0bffc03 	ldbu	r2,-16(fp)
811180a8:	10000f1e 	bne	r2,zero,811180e8 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811180ac:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
811180b0:	e0fffd17 	ldw	r3,-12(fp)
811180b4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811180b8:	188b883a 	add	r5,r3,r2
811180bc:	e0bffd17 	ldw	r2,-12(fp)
811180c0:	e0fffe17 	ldw	r3,-8(fp)
811180c4:	d8c00115 	stw	r3,4(sp)
811180c8:	d8800015 	stw	r2,0(sp)
811180cc:	280f883a 	mov	r7,r5
811180d0:	01a04574 	movhi	r6,33045
811180d4:	31808b04 	addi	r6,r6,556
811180d8:	01604574 	movhi	r5,33045
811180dc:	297fd304 	addi	r5,r5,-180
811180e0:	11232a00 	call	811232a0 <fprintf>
811180e4:	00000706 	br	81118104 <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
811180e8:	d0a06217 	ldw	r2,-32376(gp)
811180ec:	100f883a 	mov	r7,r2
811180f0:	01800844 	movi	r6,33
811180f4:	01400044 	movi	r5,1
811180f8:	01204574 	movhi	r4,33045
811180fc:	21008e04 	addi	r4,r4,568
81118100:	112393c0 	call	8112393c <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
81118104:	e0bffd04 	addi	r2,fp,-12
81118108:	100b883a 	mov	r5,r2
8111810c:	01000204 	movi	r4,8
81118110:	11420900 	call	81142090 <OSTaskStkChk>
81118114:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81118118:	e0bffc03 	ldbu	r2,-16(fp)
8111811c:	10000f1e 	bne	r2,zero,8111815c <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81118120:	d1206217 	ldw	r4,-32376(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
81118124:	e0fffd17 	ldw	r3,-12(fp)
81118128:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111812c:	188b883a 	add	r5,r3,r2
81118130:	e0bffd17 	ldw	r2,-12(fp)
81118134:	e0fffe17 	ldw	r3,-8(fp)
81118138:	d8c00115 	stw	r3,4(sp)
8111813c:	d8800015 	stw	r2,0(sp)
81118140:	280f883a 	mov	r7,r5
81118144:	01a04574 	movhi	r6,33045
81118148:	31809704 	addi	r6,r6,604
8111814c:	01604574 	movhi	r5,33045
81118150:	297fd304 	addi	r5,r5,-180
81118154:	11232a00 	call	811232a0 <fprintf>
81118158:	00000706 	br	81118178 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
8111815c:	d0a06217 	ldw	r2,-32376(gp)
81118160:	100f883a 	mov	r7,r2
81118164:	018007c4 	movi	r6,31
81118168:	01400044 	movi	r5,1
8111816c:	01204574 	movhi	r4,33045
81118170:	21009a04 	addi	r4,r4,616
81118174:	112393c0 	call	8112393c <fwrite>
    	}		


    	fprintf(fp, "\n" );
81118178:	d0a06217 	ldw	r2,-32376(gp)
8111817c:	100b883a 	mov	r5,r2
81118180:	01000284 	movi	r4,10
81118184:	11233180 	call	81123318 <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
81118188:	000f883a 	mov	r7,zero
8111818c:	01800284 	movi	r6,10
81118190:	000b883a 	mov	r5,zero
81118194:	0009883a 	mov	r4,zero
81118198:	11426f40 	call	811426f4 <OSTimeDlyHMSM>
    }
8111819c:	003e1806 	br	81117a00 <__reset+0xfb0f7a00>

811181a0 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
811181a0:	defffc04 	addi	sp,sp,-16
811181a4:	de00012e 	bgeu	sp,et,811181ac <vTimeoutCheckerTaskv2+0xc>
811181a8:	003b68fa 	trap	3
811181ac:	dfc00315 	stw	ra,12(sp)
811181b0:	df000215 	stw	fp,8(sp)
811181b4:	df000204 	addi	fp,sp,8
811181b8:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
811181bc:	e03ffe05 	stb	zero,-8(fp)

    #if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811181c0:	00a045f4 	movhi	r2,33047
811181c4:	10a25304 	addi	r2,r2,-30388
811181c8:	10800a8b 	ldhu	r2,42(r2)
811181cc:	10bfffcc 	andi	r2,r2,65535
811181d0:	10800168 	cmpgeui	r2,r2,5
811181d4:	1000071e 	bne	r2,zero,811181f4 <vTimeoutCheckerTaskv2+0x54>
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
811181d8:	d0a06217 	ldw	r2,-32376(gp)
811181dc:	100f883a 	mov	r7,r2
811181e0:	01800844 	movi	r6,33
811181e4:	01400044 	movi	r5,1
811181e8:	01204574 	movhi	r4,33045
811181ec:	2100a204 	addi	r4,r4,648
811181f0:	112393c0 	call	8112393c <fwrite>
	}
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
811181f4:	d0a06717 	ldw	r2,-32356(gp)
811181f8:	e1bffe04 	addi	r6,fp,-8
811181fc:	000b883a 	mov	r5,zero
81118200:	1009883a 	mov	r4,r2
81118204:	114075c0 	call	8114075c <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
81118208:	e0bffe03 	ldbu	r2,-8(fp)
8111820c:	10803fcc 	andi	r2,r2,255
81118210:	1000021e 	bne	r2,zero,8111821c <vTimeoutCheckerTaskv2+0x7c>
            /* Just check the restransmission buffer */
            vCheck();
81118214:	11182240 	call	81118224 <vCheck>
81118218:	003ff606 	br	811181f4 <__reset+0xfb0f81f4>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
8111821c:	111dfd40 	call	8111dfd4 <vFailGetBlockingSemTimeoutTask>
        }
    }
81118220:	003ff406 	br	811181f4 <__reset+0xfb0f81f4>

81118224 <vCheck>:
}


void vCheck( void ) {
81118224:	defffd04 	addi	sp,sp,-12
81118228:	de00012e 	bgeu	sp,et,81118230 <vCheck+0xc>
8111822c:	003b68fa 	trap	3
81118230:	dfc00215 	stw	ra,8(sp)
81118234:	df000115 	stw	fp,4(sp)
81118238:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
8111823c:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
81118240:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81118244:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81118248:	d0a06883 	ldbu	r2,-32350(gp)
8111824c:	10803fcc 	andi	r2,r2,255
81118250:	10800218 	cmpnei	r2,r2,8
81118254:	1000021e 	bne	r2,zero,81118260 <vCheck+0x3c>
81118258:	00c00104 	movi	r3,4
8111825c:	00000106 	br	81118264 <vCheck+0x40>
81118260:	0007883a 	mov	r3,zero
81118264:	d0a07503 	ldbu	r2,-32300(gp)
81118268:	10803fcc 	andi	r2,r2,255
8111826c:	10800218 	cmpnei	r2,r2,8
81118270:	1000021e 	bne	r2,zero,8111827c <vCheck+0x58>
81118274:	00800084 	movi	r2,2
81118278:	00000106 	br	81118280 <vCheck+0x5c>
8111827c:	0005883a 	mov	r2,zero
81118280:	1884b03a 	or	r2,r3,r2
81118284:	1007883a 	mov	r3,r2
81118288:	d0a07543 	ldbu	r2,-32299(gp)
8111828c:	10803fcc 	andi	r2,r2,255
81118290:	108001a0 	cmpeqi	r2,r2,6
81118294:	1884b03a 	or	r2,r3,r2
81118298:	1007883a 	mov	r3,r2
8111829c:	e0bfff03 	ldbu	r2,-4(fp)
811182a0:	1884b03a 	or	r2,r3,r2
811182a4:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
811182a8:	e0bfff03 	ldbu	r2,-4(fp)
811182ac:	108001d8 	cmpnei	r2,r2,7
811182b0:	10003d26 	beq	r2,zero,811183a8 <vCheck+0x184>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
811182b4:	d0a07417 	ldw	r2,-32304(gp)
811182b8:	e0ffff44 	addi	r3,fp,-3
811182bc:	180d883a 	mov	r6,r3
811182c0:	000b883a 	mov	r5,zero
811182c4:	1009883a 	mov	r4,r2
811182c8:	113e7500 	call	8113e750 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
811182cc:	e0bfff43 	ldbu	r2,-3(fp)
811182d0:	10803fcc 	andi	r2,r2,255
811182d4:	10000e26 	beq	r2,zero,81118310 <vCheck+0xec>
        /* Should never get here, is a blocking operation */
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811182d8:	00a045f4 	movhi	r2,33047
811182dc:	10a25304 	addi	r2,r2,-30388
811182e0:	10800a8b 	ldhu	r2,42(r2)
811182e4:	10bfffcc 	andi	r2,r2,65535
811182e8:	10800228 	cmpgeui	r2,r2,8
811182ec:	1000301e 	bne	r2,zero,811183b0 <vCheck+0x18c>
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
811182f0:	d0a06217 	ldw	r2,-32376(gp)
811182f4:	100f883a 	mov	r7,r2
811182f8:	01800f04 	movi	r6,60
811182fc:	01400044 	movi	r5,1
81118300:	01204574 	movhi	r4,33045
81118304:	2100ab04 	addi	r4,r4,684
81118308:	112393c0 	call	8112393c <fwrite>
    	}
		#endif
        return;
8111830c:	00002806 	br	811183b0 <vCheck+0x18c>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81118310:	e0bfff03 	ldbu	r2,-4(fp)
81118314:	1080004c 	andi	r2,r2,1
81118318:	10803fcc 	andi	r2,r2,255
8111831c:	1000021e 	bne	r2,zero,81118328 <vCheck+0x104>
        vCheckRetransmission128();
81118320:	11183c80 	call	811183c8 <vCheckRetransmission128>
81118324:	00000506 	br	8111833c <vCheck+0x118>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
81118328:	01800604 	movi	r6,24
8111832c:	000b883a 	mov	r5,zero
81118330:	012045b4 	movhi	r4,33046
81118334:	21027104 	addi	r4,r4,2500
81118338:	11244a00 	call	811244a0 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
8111833c:	e0bfff03 	ldbu	r2,-4(fp)
81118340:	1080008c 	andi	r2,r2,2
81118344:	10803fcc 	andi	r2,r2,255
81118348:	1000021e 	bne	r2,zero,81118354 <vCheck+0x130>
        vCheckRetransmission64();
8111834c:	111864c0 	call	8111864c <vCheckRetransmission64>
81118350:	00000506 	br	81118368 <vCheck+0x144>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
81118354:	01800804 	movi	r6,32
81118358:	000b883a 	mov	r5,zero
8111835c:	012045b4 	movhi	r4,33046
81118360:	21027704 	addi	r4,r4,2524
81118364:	11244a00 	call	811244a0 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
81118368:	e0bfff03 	ldbu	r2,-4(fp)
8111836c:	1080010c 	andi	r2,r2,4
81118370:	10803fcc 	andi	r2,r2,255
81118374:	1000021e 	bne	r2,zero,81118380 <vCheck+0x15c>
        vCheckRetransmission32();
81118378:	11188d80 	call	811188d8 <vCheckRetransmission32>
8111837c:	00000506 	br	81118394 <vCheck+0x170>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81118380:	01800804 	movi	r6,32
81118384:	000b883a 	mov	r5,zero
81118388:	012045b4 	movhi	r4,33046
8111838c:	21027f04 	addi	r4,r4,2556
81118390:	11244a00 	call	811244a0 <memset>


    OSMutexPost(xTxUARTMutex);
81118394:	d0a07417 	ldw	r2,-32304(gp)
81118398:	1009883a 	mov	r4,r2
8111839c:	113ecf40 	call	8113ecf4 <OSMutexPost>

    return;
811183a0:	0001883a 	nop
811183a4:	00000306 	br	811183b4 <vCheck+0x190>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
811183a8:	0001883a 	nop
811183ac:	00000106 	br	811183b4 <vCheck+0x190>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
    	}
		#endif
        return;
811183b0:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
811183b4:	e037883a 	mov	sp,fp
811183b8:	dfc00117 	ldw	ra,4(sp)
811183bc:	df000017 	ldw	fp,0(sp)
811183c0:	dec00204 	addi	sp,sp,8
811183c4:	f800283a 	ret

811183c8 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
811183c8:	defffd04 	addi	sp,sp,-12
811183cc:	de00012e 	bgeu	sp,et,811183d4 <vCheckRetransmission128+0xc>
811183d0:	003b68fa 	trap	3
811183d4:	dfc00215 	stw	ra,8(sp)
811183d8:	df000115 	stw	fp,4(sp)
811183dc:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
811183e0:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
811183e4:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
811183e8:	d0a06e17 	ldw	r2,-32328(gp)
811183ec:	e0ffff44 	addi	r3,fp,-3
811183f0:	180b883a 	mov	r5,r3
811183f4:	1009883a 	mov	r4,r2
811183f8:	113e0d00 	call	8113e0d0 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811183fc:	e0bfff43 	ldbu	r2,-3(fp)
81118400:	10803fcc 	andi	r2,r2,255
81118404:	10008b1e 	bne	r2,zero,81118634 <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81118408:	e03fff05 	stb	zero,-4(fp)
8111840c:	00008106 	br	81118614 <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
81118410:	e0ffff03 	ldbu	r3,-4(fp)
81118414:	00a045b4 	movhi	r2,33046
81118418:	10827104 	addi	r2,r2,2500
8111841c:	18c7883a 	add	r3,r3,r3
81118420:	18c7883a 	add	r3,r3,r3
81118424:	10c5883a 	add	r2,r2,r3
81118428:	10800017 	ldw	r2,0(r2)
8111842c:	10800058 	cmpnei	r2,r2,1
81118430:	1000751e 	bne	r2,zero,81118608 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
81118434:	e0ffff03 	ldbu	r3,-4(fp)
81118438:	00a045b4 	movhi	r2,33046
8111843c:	10828f04 	addi	r2,r2,2620
81118440:	18c02324 	muli	r3,r3,140
81118444:	10c5883a 	add	r2,r2,r3
81118448:	10802004 	addi	r2,r2,128
8111844c:	10800017 	ldw	r2,0(r2)
81118450:	10800058 	cmpnei	r2,r2,1
81118454:	1000211e 	bne	r2,zero,811184dc <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
81118458:	e0ffff03 	ldbu	r3,-4(fp)
8111845c:	00a045b4 	movhi	r2,33046
81118460:	10828f04 	addi	r2,r2,2620
81118464:	19002324 	muli	r4,r3,140
81118468:	1105883a 	add	r2,r2,r4
8111846c:	10802184 	addi	r2,r2,134
81118470:	1080000b 	ldhu	r2,0(r2)
81118474:	10800044 	addi	r2,r2,1
81118478:	100b883a 	mov	r5,r2
8111847c:	00a045b4 	movhi	r2,33046
81118480:	10828f04 	addi	r2,r2,2620
81118484:	19002324 	muli	r4,r3,140
81118488:	1105883a 	add	r2,r2,r4
8111848c:	10802184 	addi	r2,r2,134
81118490:	1140000d 	sth	r5,0(r2)
81118494:	00a045b4 	movhi	r2,33046
81118498:	10828f04 	addi	r2,r2,2620
8111849c:	18c02324 	muli	r3,r3,140
811184a0:	10c5883a 	add	r2,r2,r3
811184a4:	10802184 	addi	r2,r2,134
811184a8:	1080000b 	ldhu	r2,0(r2)
811184ac:	10bfffcc 	andi	r2,r2,65535
811184b0:	10a0001c 	xori	r2,r2,32768
811184b4:	10a00004 	addi	r2,r2,-32768
811184b8:	10800090 	cmplti	r2,r2,2
811184bc:	1000071e 	bne	r2,zero,811184dc <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
811184c0:	e0ffff03 	ldbu	r3,-4(fp)
811184c4:	00a045b4 	movhi	r2,33046
811184c8:	10828f04 	addi	r2,r2,2620
811184cc:	18c02324 	muli	r3,r3,140
811184d0:	10c5883a 	add	r2,r2,r3
811184d4:	10802004 	addi	r2,r2,128
811184d8:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
811184dc:	e0ffff03 	ldbu	r3,-4(fp)
811184e0:	00a045b4 	movhi	r2,33046
811184e4:	10828f04 	addi	r2,r2,2620
811184e8:	18c02324 	muli	r3,r3,140
811184ec:	10c5883a 	add	r2,r2,r3
811184f0:	10802004 	addi	r2,r2,128
811184f4:	10800017 	ldw	r2,0(r2)
811184f8:	1000431e 	bne	r2,zero,81118608 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
811184fc:	e0bfff03 	ldbu	r2,-4(fp)
81118500:	10c02324 	muli	r3,r2,140
81118504:	00a045b4 	movhi	r2,33046
81118508:	10828f04 	addi	r2,r2,2620
8111850c:	1885883a 	add	r2,r3,r2
81118510:	1009883a 	mov	r4,r2
81118514:	11248700 	call	81124870 <puts>
                xBuffer128[ucIL].bSent = TRUE;
81118518:	e0ffff03 	ldbu	r3,-4(fp)
8111851c:	00a045b4 	movhi	r2,33046
81118520:	10828f04 	addi	r2,r2,2620
81118524:	18c02324 	muli	r3,r3,140
81118528:	10c5883a 	add	r2,r2,r3
8111852c:	10802004 	addi	r2,r2,128
81118530:	00c00044 	movi	r3,1
81118534:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81118538:	e0ffff03 	ldbu	r3,-4(fp)
8111853c:	00a045b4 	movhi	r2,33046
81118540:	10828f04 	addi	r2,r2,2620
81118544:	18c02324 	muli	r3,r3,140
81118548:	10c5883a 	add	r2,r2,r3
8111854c:	10802184 	addi	r2,r2,134
81118550:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81118554:	e0ffff03 	ldbu	r3,-4(fp)
81118558:	00a045b4 	movhi	r2,33046
8111855c:	10828f04 	addi	r2,r2,2620
81118560:	19002324 	muli	r4,r3,140
81118564:	1105883a 	add	r2,r2,r4
81118568:	10802204 	addi	r2,r2,136
8111856c:	10800003 	ldbu	r2,0(r2)
81118570:	10800044 	addi	r2,r2,1
81118574:	100b883a 	mov	r5,r2
81118578:	00a045b4 	movhi	r2,33046
8111857c:	10828f04 	addi	r2,r2,2620
81118580:	19002324 	muli	r4,r3,140
81118584:	1105883a 	add	r2,r2,r4
81118588:	10802204 	addi	r2,r2,136
8111858c:	11400005 	stb	r5,0(r2)
81118590:	00a045b4 	movhi	r2,33046
81118594:	10828f04 	addi	r2,r2,2620
81118598:	18c02324 	muli	r3,r3,140
8111859c:	10c5883a 	add	r2,r2,r3
811185a0:	10802204 	addi	r2,r2,136
811185a4:	10800003 	ldbu	r2,0(r2)
811185a8:	10803fcc 	andi	r2,r2,255
811185ac:	108000b0 	cmpltui	r2,r2,2
811185b0:	1000151e 	bne	r2,zero,81118608 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
811185b4:	e0ffff03 	ldbu	r3,-4(fp)
811185b8:	00a045b4 	movhi	r2,33046
811185bc:	10827104 	addi	r2,r2,2500
811185c0:	18c7883a 	add	r3,r3,r3
811185c4:	18c7883a 	add	r3,r3,r3
811185c8:	10c5883a 	add	r2,r2,r3
811185cc:	10000015 	stw	zero,0(r2)
                    SemCount128++;
811185d0:	d0a07543 	ldbu	r2,-32299(gp)
811185d4:	10800044 	addi	r2,r2,1
811185d8:	d0a07545 	stb	r2,-32299(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
811185dc:	d0a06317 	ldw	r2,-32372(gp)
811185e0:	1009883a 	mov	r4,r2
811185e4:	1140ae40 	call	81140ae4 <OSSemPost>
811185e8:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
811185ec:	e0bfff43 	ldbu	r2,-3(fp)
811185f0:	10803fcc 	andi	r2,r2,255
811185f4:	10000426 	beq	r2,zero,81118608 <vCheckRetransmission128+0x240>
                        SemCount128--;
811185f8:	d0a07543 	ldbu	r2,-32299(gp)
811185fc:	10bfffc4 	addi	r2,r2,-1
81118600:	d0a07545 	stb	r2,-32299(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81118604:	111d6fc0 	call	8111d6fc <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81118608:	e0bfff03 	ldbu	r2,-4(fp)
8111860c:	10800044 	addi	r2,r2,1
81118610:	e0bfff05 	stb	r2,-4(fp)
81118614:	e0bfff03 	ldbu	r2,-4(fp)
81118618:	108001b0 	cmpltui	r2,r2,6
8111861c:	103f7c1e 	bne	r2,zero,81118410 <__reset+0xfb0f8410>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
81118620:	d0a06e17 	ldw	r2,-32328(gp)
81118624:	1009883a 	mov	r4,r2
81118628:	113ecf40 	call	8113ecf4 <OSMutexPost>

    return;
8111862c:	0001883a 	nop
81118630:	00000106 	br	81118638 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81118634:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
81118638:	e037883a 	mov	sp,fp
8111863c:	dfc00117 	ldw	ra,4(sp)
81118640:	df000017 	ldw	fp,0(sp)
81118644:	dec00204 	addi	sp,sp,8
81118648:	f800283a 	ret

8111864c <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
8111864c:	defffd04 	addi	sp,sp,-12
81118650:	de00012e 	bgeu	sp,et,81118658 <vCheckRetransmission64+0xc>
81118654:	003b68fa 	trap	3
81118658:	dfc00215 	stw	ra,8(sp)
8111865c:	df000115 	stw	fp,4(sp)
81118660:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81118664:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81118668:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8111866c:	d0a07117 	ldw	r2,-32316(gp)
81118670:	e0ffff44 	addi	r3,fp,-3
81118674:	180b883a 	mov	r5,r3
81118678:	1009883a 	mov	r4,r2
8111867c:	113e0d00 	call	8113e0d0 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81118680:	e0bfff43 	ldbu	r2,-3(fp)
81118684:	10803fcc 	andi	r2,r2,255
81118688:	10008d1e 	bne	r2,zero,811188c0 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
8111868c:	e03fff05 	stb	zero,-4(fp)
81118690:	00008306 	br	811188a0 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
81118694:	e0ffff03 	ldbu	r3,-4(fp)
81118698:	00a045b4 	movhi	r2,33046
8111869c:	10827104 	addi	r2,r2,2500
811186a0:	18c00184 	addi	r3,r3,6
811186a4:	18c7883a 	add	r3,r3,r3
811186a8:	18c7883a 	add	r3,r3,r3
811186ac:	10c5883a 	add	r2,r2,r3
811186b0:	10800017 	ldw	r2,0(r2)
811186b4:	10800058 	cmpnei	r2,r2,1
811186b8:	1000761e 	bne	r2,zero,81118894 <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
811186bc:	e0ffff03 	ldbu	r3,-4(fp)
811186c0:	00a04574 	movhi	r2,33045
811186c4:	109e3304 	addi	r2,r2,30924
811186c8:	18c01324 	muli	r3,r3,76
811186cc:	10c5883a 	add	r2,r2,r3
811186d0:	10801004 	addi	r2,r2,64
811186d4:	10800017 	ldw	r2,0(r2)
811186d8:	10800058 	cmpnei	r2,r2,1
811186dc:	1000211e 	bne	r2,zero,81118764 <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
811186e0:	e0ffff03 	ldbu	r3,-4(fp)
811186e4:	00a04574 	movhi	r2,33045
811186e8:	109e3304 	addi	r2,r2,30924
811186ec:	19001324 	muli	r4,r3,76
811186f0:	1105883a 	add	r2,r2,r4
811186f4:	10801184 	addi	r2,r2,70
811186f8:	1080000b 	ldhu	r2,0(r2)
811186fc:	10800044 	addi	r2,r2,1
81118700:	100b883a 	mov	r5,r2
81118704:	00a04574 	movhi	r2,33045
81118708:	109e3304 	addi	r2,r2,30924
8111870c:	19001324 	muli	r4,r3,76
81118710:	1105883a 	add	r2,r2,r4
81118714:	10801184 	addi	r2,r2,70
81118718:	1140000d 	sth	r5,0(r2)
8111871c:	00a04574 	movhi	r2,33045
81118720:	109e3304 	addi	r2,r2,30924
81118724:	18c01324 	muli	r3,r3,76
81118728:	10c5883a 	add	r2,r2,r3
8111872c:	10801184 	addi	r2,r2,70
81118730:	1080000b 	ldhu	r2,0(r2)
81118734:	10bfffcc 	andi	r2,r2,65535
81118738:	10a0001c 	xori	r2,r2,32768
8111873c:	10a00004 	addi	r2,r2,-32768
81118740:	10800090 	cmplti	r2,r2,2
81118744:	1000071e 	bne	r2,zero,81118764 <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81118748:	e0ffff03 	ldbu	r3,-4(fp)
8111874c:	00a04574 	movhi	r2,33045
81118750:	109e3304 	addi	r2,r2,30924
81118754:	18c01324 	muli	r3,r3,76
81118758:	10c5883a 	add	r2,r2,r3
8111875c:	10801004 	addi	r2,r2,64
81118760:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
81118764:	e0ffff03 	ldbu	r3,-4(fp)
81118768:	00a04574 	movhi	r2,33045
8111876c:	109e3304 	addi	r2,r2,30924
81118770:	18c01324 	muli	r3,r3,76
81118774:	10c5883a 	add	r2,r2,r3
81118778:	10801004 	addi	r2,r2,64
8111877c:	10800017 	ldw	r2,0(r2)
81118780:	1000441e 	bne	r2,zero,81118894 <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
81118784:	e0bfff03 	ldbu	r2,-4(fp)
81118788:	10c01324 	muli	r3,r2,76
8111878c:	00a04574 	movhi	r2,33045
81118790:	109e3304 	addi	r2,r2,30924
81118794:	1885883a 	add	r2,r3,r2
81118798:	1009883a 	mov	r4,r2
8111879c:	11248700 	call	81124870 <puts>
                xBuffer64[ucIL].bSent = TRUE;
811187a0:	e0ffff03 	ldbu	r3,-4(fp)
811187a4:	00a04574 	movhi	r2,33045
811187a8:	109e3304 	addi	r2,r2,30924
811187ac:	18c01324 	muli	r3,r3,76
811187b0:	10c5883a 	add	r2,r2,r3
811187b4:	10801004 	addi	r2,r2,64
811187b8:	00c00044 	movi	r3,1
811187bc:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
811187c0:	e0ffff03 	ldbu	r3,-4(fp)
811187c4:	00a04574 	movhi	r2,33045
811187c8:	109e3304 	addi	r2,r2,30924
811187cc:	18c01324 	muli	r3,r3,76
811187d0:	10c5883a 	add	r2,r2,r3
811187d4:	10801184 	addi	r2,r2,70
811187d8:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
811187dc:	e0ffff03 	ldbu	r3,-4(fp)
811187e0:	00a04574 	movhi	r2,33045
811187e4:	109e3304 	addi	r2,r2,30924
811187e8:	19001324 	muli	r4,r3,76
811187ec:	1105883a 	add	r2,r2,r4
811187f0:	10801204 	addi	r2,r2,72
811187f4:	10800003 	ldbu	r2,0(r2)
811187f8:	10800044 	addi	r2,r2,1
811187fc:	100b883a 	mov	r5,r2
81118800:	00a04574 	movhi	r2,33045
81118804:	109e3304 	addi	r2,r2,30924
81118808:	19001324 	muli	r4,r3,76
8111880c:	1105883a 	add	r2,r2,r4
81118810:	10801204 	addi	r2,r2,72
81118814:	11400005 	stb	r5,0(r2)
81118818:	00a04574 	movhi	r2,33045
8111881c:	109e3304 	addi	r2,r2,30924
81118820:	18c01324 	muli	r3,r3,76
81118824:	10c5883a 	add	r2,r2,r3
81118828:	10801204 	addi	r2,r2,72
8111882c:	10800003 	ldbu	r2,0(r2)
81118830:	10803fcc 	andi	r2,r2,255
81118834:	108000b0 	cmpltui	r2,r2,2
81118838:	1000161e 	bne	r2,zero,81118894 <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
8111883c:	e0ffff03 	ldbu	r3,-4(fp)
81118840:	00a045b4 	movhi	r2,33046
81118844:	10827104 	addi	r2,r2,2500
81118848:	18c00184 	addi	r3,r3,6
8111884c:	18c7883a 	add	r3,r3,r3
81118850:	18c7883a 	add	r3,r3,r3
81118854:	10c5883a 	add	r2,r2,r3
81118858:	10000015 	stw	zero,0(r2)
                    SemCount64++;
8111885c:	d0a07503 	ldbu	r2,-32300(gp)
81118860:	10800044 	addi	r2,r2,1
81118864:	d0a07505 	stb	r2,-32300(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
81118868:	d0a05e17 	ldw	r2,-32392(gp)
8111886c:	1009883a 	mov	r4,r2
81118870:	1140ae40 	call	81140ae4 <OSSemPost>
81118874:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81118878:	e0bfff43 	ldbu	r2,-3(fp)
8111887c:	10803fcc 	andi	r2,r2,255
81118880:	10000426 	beq	r2,zero,81118894 <vCheckRetransmission64+0x248>
                        SemCount64--;
81118884:	d0a07503 	ldbu	r2,-32300(gp)
81118888:	10bfffc4 	addi	r2,r2,-1
8111888c:	d0a07505 	stb	r2,-32300(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81118890:	111d67c0 	call	8111d67c <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81118894:	e0bfff03 	ldbu	r2,-4(fp)
81118898:	10800044 	addi	r2,r2,1
8111889c:	e0bfff05 	stb	r2,-4(fp)
811188a0:	e0bfff03 	ldbu	r2,-4(fp)
811188a4:	10800230 	cmpltui	r2,r2,8
811188a8:	103f7a1e 	bne	r2,zero,81118694 <__reset+0xfb0f8694>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
811188ac:	d0a07117 	ldw	r2,-32316(gp)
811188b0:	1009883a 	mov	r4,r2
811188b4:	113ecf40 	call	8113ecf4 <OSMutexPost>

    return;
811188b8:	0001883a 	nop
811188bc:	00000106 	br	811188c4 <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
811188c0:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
811188c4:	e037883a 	mov	sp,fp
811188c8:	dfc00117 	ldw	ra,4(sp)
811188cc:	df000017 	ldw	fp,0(sp)
811188d0:	dec00204 	addi	sp,sp,8
811188d4:	f800283a 	ret

811188d8 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
811188d8:	defffd04 	addi	sp,sp,-12
811188dc:	de00012e 	bgeu	sp,et,811188e4 <vCheckRetransmission32+0xc>
811188e0:	003b68fa 	trap	3
811188e4:	dfc00215 	stw	ra,8(sp)
811188e8:	df000115 	stw	fp,4(sp)
811188ec:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
811188f0:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
811188f4:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
811188f8:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
811188fc:	d0a06c17 	ldw	r2,-32336(gp)
81118900:	e0ffff84 	addi	r3,fp,-2
81118904:	180b883a 	mov	r5,r3
81118908:	1009883a 	mov	r4,r2
8111890c:	113e0d00 	call	8113e0d0 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81118910:	e0bfff83 	ldbu	r2,-2(fp)
81118914:	10803fcc 	andi	r2,r2,255
81118918:	10009b1e 	bne	r2,zero,81118b88 <vCheckRetransmission32+0x2b0>
    }
    
    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
8111891c:	e03fff05 	stb	zero,-4(fp)
81118920:	00009106 	br	81118b68 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
81118924:	e0ffff03 	ldbu	r3,-4(fp)
81118928:	00a045b4 	movhi	r2,33046
8111892c:	10827104 	addi	r2,r2,2500
81118930:	18c00384 	addi	r3,r3,14
81118934:	18c7883a 	add	r3,r3,r3
81118938:	18c7883a 	add	r3,r3,r3
8111893c:	10c5883a 	add	r2,r2,r3
81118940:	10800017 	ldw	r2,0(r2)
81118944:	10800058 	cmpnei	r2,r2,1
81118948:	1000841e 	bne	r2,zero,81118b5c <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
8111894c:	e0ffff03 	ldbu	r3,-4(fp)
81118950:	00a045b4 	movhi	r2,33046
81118954:	10aff104 	addi	r2,r2,-16444
81118958:	18c00b24 	muli	r3,r3,44
8111895c:	10c5883a 	add	r2,r2,r3
81118960:	10800804 	addi	r2,r2,32
81118964:	10800017 	ldw	r2,0(r2)
81118968:	10800058 	cmpnei	r2,r2,1
8111896c:	1000211e 	bne	r2,zero,811189f4 <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
81118970:	e0ffff03 	ldbu	r3,-4(fp)
81118974:	00a045b4 	movhi	r2,33046
81118978:	10aff104 	addi	r2,r2,-16444
8111897c:	19000b24 	muli	r4,r3,44
81118980:	1105883a 	add	r2,r2,r4
81118984:	10800984 	addi	r2,r2,38
81118988:	1080000b 	ldhu	r2,0(r2)
8111898c:	10800044 	addi	r2,r2,1
81118990:	100b883a 	mov	r5,r2
81118994:	00a045b4 	movhi	r2,33046
81118998:	10aff104 	addi	r2,r2,-16444
8111899c:	19000b24 	muli	r4,r3,44
811189a0:	1105883a 	add	r2,r2,r4
811189a4:	10800984 	addi	r2,r2,38
811189a8:	1140000d 	sth	r5,0(r2)
811189ac:	00a045b4 	movhi	r2,33046
811189b0:	10aff104 	addi	r2,r2,-16444
811189b4:	18c00b24 	muli	r3,r3,44
811189b8:	10c5883a 	add	r2,r2,r3
811189bc:	10800984 	addi	r2,r2,38
811189c0:	1080000b 	ldhu	r2,0(r2)
811189c4:	10bfffcc 	andi	r2,r2,65535
811189c8:	10a0001c 	xori	r2,r2,32768
811189cc:	10a00004 	addi	r2,r2,-32768
811189d0:	10800090 	cmplti	r2,r2,2
811189d4:	1000071e 	bne	r2,zero,811189f4 <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
811189d8:	e0ffff03 	ldbu	r3,-4(fp)
811189dc:	00a045b4 	movhi	r2,33046
811189e0:	10aff104 	addi	r2,r2,-16444
811189e4:	18c00b24 	muli	r3,r3,44
811189e8:	10c5883a 	add	r2,r2,r3
811189ec:	10800804 	addi	r2,r2,32
811189f0:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
811189f4:	e0ffff03 	ldbu	r3,-4(fp)
811189f8:	00a045b4 	movhi	r2,33046
811189fc:	10aff104 	addi	r2,r2,-16444
81118a00:	18c00b24 	muli	r3,r3,44
81118a04:	10c5883a 	add	r2,r2,r3
81118a08:	10800804 	addi	r2,r2,32
81118a0c:	10800017 	ldw	r2,0(r2)
81118a10:	1000521e 	bne	r2,zero,81118b5c <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
81118a14:	e0bfff03 	ldbu	r2,-4(fp)
81118a18:	10c00b24 	muli	r3,r2,44
81118a1c:	00a045b4 	movhi	r2,33046
81118a20:	10aff104 	addi	r2,r2,-16444
81118a24:	1885883a 	add	r2,r3,r2
81118a28:	1009883a 	mov	r4,r2
81118a2c:	11248700 	call	81124870 <puts>
                xBuffer32[ucIL].bSent = TRUE;
81118a30:	e0ffff03 	ldbu	r3,-4(fp)
81118a34:	00a045b4 	movhi	r2,33046
81118a38:	10aff104 	addi	r2,r2,-16444
81118a3c:	18c00b24 	muli	r3,r3,44
81118a40:	10c5883a 	add	r2,r2,r3
81118a44:	10800804 	addi	r2,r2,32
81118a48:	00c00044 	movi	r3,1
81118a4c:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
81118a50:	e0ffff03 	ldbu	r3,-4(fp)
81118a54:	00a045b4 	movhi	r2,33046
81118a58:	10aff104 	addi	r2,r2,-16444
81118a5c:	18c00b24 	muli	r3,r3,44
81118a60:	10c5883a 	add	r2,r2,r3
81118a64:	10800984 	addi	r2,r2,38
81118a68:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
81118a6c:	e0ffff03 	ldbu	r3,-4(fp)
81118a70:	00a045b4 	movhi	r2,33046
81118a74:	10aff104 	addi	r2,r2,-16444
81118a78:	18c00b24 	muli	r3,r3,44
81118a7c:	10c5883a 	add	r2,r2,r3
81118a80:	10800904 	addi	r2,r2,36
81118a84:	1080000b 	ldhu	r2,0(r2)
81118a88:	10bfffcc 	andi	r2,r2,65535
81118a8c:	10800058 	cmpnei	r2,r2,1
81118a90:	1000021e 	bne	r2,zero,81118a9c <vCheckRetransmission32+0x1c4>
81118a94:	00bffe84 	movi	r2,-6
81118a98:	00000106 	br	81118aa0 <vCheckRetransmission32+0x1c8>
81118a9c:	00800044 	movi	r2,1
81118aa0:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
81118aa4:	e0ffff03 	ldbu	r3,-4(fp)
81118aa8:	00a045b4 	movhi	r2,33046
81118aac:	10aff104 	addi	r2,r2,-16444
81118ab0:	19000b24 	muli	r4,r3,44
81118ab4:	1105883a 	add	r2,r2,r4
81118ab8:	10800a04 	addi	r2,r2,40
81118abc:	10800003 	ldbu	r2,0(r2)
81118ac0:	10800044 	addi	r2,r2,1
81118ac4:	100b883a 	mov	r5,r2
81118ac8:	00a045b4 	movhi	r2,33046
81118acc:	10aff104 	addi	r2,r2,-16444
81118ad0:	19000b24 	muli	r4,r3,44
81118ad4:	1105883a 	add	r2,r2,r4
81118ad8:	10800a04 	addi	r2,r2,40
81118adc:	11400005 	stb	r5,0(r2)
81118ae0:	00a045b4 	movhi	r2,33046
81118ae4:	10aff104 	addi	r2,r2,-16444
81118ae8:	18c00b24 	muli	r3,r3,44
81118aec:	10c5883a 	add	r2,r2,r3
81118af0:	10800a04 	addi	r2,r2,40
81118af4:	10800003 	ldbu	r2,0(r2)
81118af8:	10803fcc 	andi	r2,r2,255
81118afc:	e0ffff43 	ldbu	r3,-3(fp)
81118b00:	1880162e 	bgeu	r3,r2,81118b5c <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
81118b04:	e0ffff03 	ldbu	r3,-4(fp)
81118b08:	00a045b4 	movhi	r2,33046
81118b0c:	10827104 	addi	r2,r2,2500
81118b10:	18c00384 	addi	r3,r3,14
81118b14:	18c7883a 	add	r3,r3,r3
81118b18:	18c7883a 	add	r3,r3,r3
81118b1c:	10c5883a 	add	r2,r2,r3
81118b20:	10000015 	stw	zero,0(r2)
                    SemCount32++;
81118b24:	d0a06883 	ldbu	r2,-32350(gp)
81118b28:	10800044 	addi	r2,r2,1
81118b2c:	d0a06885 	stb	r2,-32350(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
81118b30:	d0a06f17 	ldw	r2,-32324(gp)
81118b34:	1009883a 	mov	r4,r2
81118b38:	1140ae40 	call	81140ae4 <OSSemPost>
81118b3c:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81118b40:	e0bfff83 	ldbu	r2,-2(fp)
81118b44:	10803fcc 	andi	r2,r2,255
81118b48:	10000426 	beq	r2,zero,81118b5c <vCheckRetransmission32+0x284>
                        SemCount32--;
81118b4c:	d0a06883 	ldbu	r2,-32350(gp)
81118b50:	10bfffc4 	addi	r2,r2,-1
81118b54:	d0a06885 	stb	r2,-32350(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81118b58:	111d5fc0 	call	8111d5fc <vFailSetCountSemaphorexBuffer32>
    }
    
    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81118b5c:	e0bfff03 	ldbu	r2,-4(fp)
81118b60:	10800044 	addi	r2,r2,1
81118b64:	e0bfff05 	stb	r2,-4(fp)
81118b68:	e0bfff03 	ldbu	r2,-4(fp)
81118b6c:	10800230 	cmpltui	r2,r2,8
81118b70:	103f6c1e 	bne	r2,zero,81118924 <__reset+0xfb0f8924>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
81118b74:	d0a06c17 	ldw	r2,-32336(gp)
81118b78:	1009883a 	mov	r4,r2
81118b7c:	113ecf40 	call	8113ecf4 <OSMutexPost>

    return;
81118b80:	0001883a 	nop
81118b84:	00000106 	br	81118b8c <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81118b88:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
81118b8c:	e037883a 	mov	sp,fp
81118b90:	dfc00117 	ldw	ra,4(sp)
81118b94:	df000017 	ldw	fp,0(sp)
81118b98:	dec00204 	addi	sp,sp,8
81118b9c:	f800283a 	ret

81118ba0 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81118ba0:	defff904 	addi	sp,sp,-28
81118ba4:	de00012e 	bgeu	sp,et,81118bac <bResourcesInitRTOS+0xc>
81118ba8:	003b68fa 	trap	3
81118bac:	dfc00615 	stw	ra,24(sp)
81118bb0:	df000515 	stw	fp,20(sp)
81118bb4:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81118bb8:	00800044 	movi	r2,1
81118bbc:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81118bc0:	0009883a 	mov	r4,zero
81118bc4:	11404340 	call	81140434 <OSSemCreate>
81118bc8:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCommInit) {
81118bcc:	d0a06017 	ldw	r2,-32384(gp)
81118bd0:	1000021e 	bne	r2,zero,81118bdc <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
81118bd4:	111cf140 	call	8111cf14 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118bd8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81118bdc:	e0bfff04 	addi	r2,fp,-4
81118be0:	100b883a 	mov	r5,r2
81118be4:	01000444 	movi	r4,17
81118be8:	113e27c0 	call	8113e27c <OSMutexCreate>
81118bec:	d0a07415 	stw	r2,-32304(gp)
	if ( err != OS_ERR_NONE ) {
81118bf0:	e0bfff03 	ldbu	r2,-4(fp)
81118bf4:	10803fcc 	andi	r2,r2,255
81118bf8:	10000526 	beq	r2,zero,81118c10 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
81118bfc:	e0bfff03 	ldbu	r2,-4(fp)
81118c00:	10803fcc 	andi	r2,r2,255
81118c04:	1009883a 	mov	r4,r2
81118c08:	111ce380 	call	8111ce38 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118c0c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
81118c10:	e0bfff04 	addi	r2,fp,-4
81118c14:	100b883a 	mov	r5,r2
81118c18:	01000504 	movi	r4,20
81118c1c:	113e27c0 	call	8113e27c <OSMutexCreate>
81118c20:	d0a06e15 	stw	r2,-32328(gp)
	if ( err != OS_ERR_NONE ) {
81118c24:	e0bfff03 	ldbu	r2,-4(fp)
81118c28:	10803fcc 	andi	r2,r2,255
81118c2c:	10000526 	beq	r2,zero,81118c44 <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
81118c30:	e0bfff03 	ldbu	r2,-4(fp)
81118c34:	10803fcc 	andi	r2,r2,255
81118c38:	1009883a 	mov	r4,r2
81118c3c:	111ce380 	call	8111ce38 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118c40:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
81118c44:	e0bfff04 	addi	r2,fp,-4
81118c48:	100b883a 	mov	r5,r2
81118c4c:	01000544 	movi	r4,21
81118c50:	113e27c0 	call	8113e27c <OSMutexCreate>
81118c54:	d0a07115 	stw	r2,-32316(gp)
	if ( err != OS_ERR_NONE ) {
81118c58:	e0bfff03 	ldbu	r2,-4(fp)
81118c5c:	10803fcc 	andi	r2,r2,255
81118c60:	10000526 	beq	r2,zero,81118c78 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
81118c64:	e0bfff03 	ldbu	r2,-4(fp)
81118c68:	10803fcc 	andi	r2,r2,255
81118c6c:	1009883a 	mov	r4,r2
81118c70:	111ce380 	call	8111ce38 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118c74:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81118c78:	e0bfff04 	addi	r2,fp,-4
81118c7c:	100b883a 	mov	r5,r2
81118c80:	01000584 	movi	r4,22
81118c84:	113e27c0 	call	8113e27c <OSMutexCreate>
81118c88:	d0a06c15 	stw	r2,-32336(gp)
	if ( err != OS_ERR_NONE ) {
81118c8c:	e0bfff03 	ldbu	r2,-4(fp)
81118c90:	10803fcc 	andi	r2,r2,255
81118c94:	10000526 	beq	r2,zero,81118cac <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
81118c98:	e0bfff03 	ldbu	r2,-4(fp)
81118c9c:	10803fcc 	andi	r2,r2,255
81118ca0:	1009883a 	mov	r4,r2
81118ca4:	111ce380 	call	8111ce38 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118ca8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
81118cac:	00800184 	movi	r2,6
81118cb0:	d0a07545 	stb	r2,-32299(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
81118cb4:	01000184 	movi	r4,6
81118cb8:	11404340 	call	81140434 <OSSemCreate>
81118cbc:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemCountBuffer128) {
81118cc0:	d0a06317 	ldw	r2,-32372(gp)
81118cc4:	1000031e 	bne	r2,zero,81118cd4 <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81118cc8:	d0207545 	stb	zero,-32299(gp)
		vFailCreateSemaphoreResources();
81118ccc:	111cf140 	call	8111cf14 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118cd0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
81118cd4:	00800204 	movi	r2,8
81118cd8:	d0a07505 	stb	r2,-32300(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81118cdc:	01000204 	movi	r4,8
81118ce0:	11404340 	call	81140434 <OSSemCreate>
81118ce4:	d0a05e15 	stw	r2,-32392(gp)
	if (!xSemCountBuffer64) {
81118ce8:	d0a05e17 	ldw	r2,-32392(gp)
81118cec:	1000031e 	bne	r2,zero,81118cfc <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81118cf0:	d0207505 	stb	zero,-32300(gp)
		vFailCreateSemaphoreResources();
81118cf4:	111cf140 	call	8111cf14 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118cf8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
81118cfc:	00800204 	movi	r2,8
81118d00:	d0a06885 	stb	r2,-32350(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
81118d04:	01000204 	movi	r4,8
81118d08:	11404340 	call	81140434 <OSSemCreate>
81118d0c:	d0a06f15 	stw	r2,-32324(gp)
	if (!xSemCountBuffer32) {
81118d10:	d0a06f17 	ldw	r2,-32324(gp)
81118d14:	1000031e 	bne	r2,zero,81118d24 <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
81118d18:	d0206885 	stb	zero,-32350(gp)
		vFailCreateSemaphoreResources();
81118d1c:	111cf140 	call	8111cf14 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118d20:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
81118d24:	e0bfff04 	addi	r2,fp,-4
81118d28:	100b883a 	mov	r5,r2
81118d2c:	010004c4 	movi	r4,19
81118d30:	113e27c0 	call	8113e27c <OSMutexCreate>
81118d34:	d0a06515 	stw	r2,-32364(gp)
	if ( err != OS_ERR_NONE ) {
81118d38:	e0bfff03 	ldbu	r2,-4(fp)
81118d3c:	10803fcc 	andi	r2,r2,255
81118d40:	10000526 	beq	r2,zero,81118d58 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
81118d44:	e0bfff03 	ldbu	r2,-4(fp)
81118d48:	10803fcc 	andi	r2,r2,255
81118d4c:	1009883a 	mov	r4,r2
81118d50:	111ce380 	call	8111ce38 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118d54:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
81118d58:	e0bfff04 	addi	r2,fp,-4
81118d5c:	100b883a 	mov	r5,r2
81118d60:	010005c4 	movi	r4,23
81118d64:	113e27c0 	call	8113e27c <OSMutexCreate>
81118d68:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
81118d6c:	e0bfff03 	ldbu	r2,-4(fp)
81118d70:	10803fcc 	andi	r2,r2,255
81118d74:	10000526 	beq	r2,zero,81118d8c <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81118d78:	e0bfff03 	ldbu	r2,-4(fp)
81118d7c:	10803fcc 	andi	r2,r2,255
81118d80:	1009883a 	mov	r4,r2
81118d84:	111ce380 	call	8111ce38 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118d88:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81118d8c:	0009883a 	mov	r4,zero
81118d90:	11404340 	call	81140434 <OSSemCreate>
81118d94:	d0a06615 	stw	r2,-32360(gp)
	if (!xSemCountReceivedACK) {
81118d98:	d0a06617 	ldw	r2,-32360(gp)
81118d9c:	1000021e 	bne	r2,zero,81118da8 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81118da0:	111cf140 	call	8111cf14 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118da4:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81118da8:	0009883a 	mov	r4,zero
81118dac:	11404340 	call	81140434 <OSSemCreate>
81118db0:	d0a06415 	stw	r2,-32368(gp)
	if (!xSemCountPreParsed) {
81118db4:	d0a06417 	ldw	r2,-32368(gp)
81118db8:	1000021e 	bne	r2,zero,81118dc4 <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
81118dbc:	111cf140 	call	8111cf14 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118dc0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
81118dc4:	0009883a 	mov	r4,zero
81118dc8:	11404340 	call	81140434 <OSSemCreate>
81118dcc:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemCountSenderACK) {
81118dd0:	d0a06117 	ldw	r2,-32380(gp)
81118dd4:	1000021e 	bne	r2,zero,81118de0 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81118dd8:	111cf140 	call	8111cf14 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118ddc:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81118de0:	e0bfff04 	addi	r2,fp,-4
81118de4:	100b883a 	mov	r5,r2
81118de8:	01000484 	movi	r4,18
81118dec:	113e27c0 	call	8113e27c <OSMutexCreate>
81118df0:	d0a07215 	stw	r2,-32312(gp)
	if ( err != OS_ERR_NONE ) {
81118df4:	e0bfff03 	ldbu	r2,-4(fp)
81118df8:	10803fcc 	andi	r2,r2,255
81118dfc:	10000526 	beq	r2,zero,81118e14 <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
81118e00:	e0bfff03 	ldbu	r2,-4(fp)
81118e04:	10803fcc 	andi	r2,r2,255
81118e08:	1009883a 	mov	r4,r2
81118e0c:	111ce380 	call	8111ce38 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118e10:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
81118e14:	0009883a 	mov	r4,zero
81118e18:	11404340 	call	81140434 <OSSemCreate>
81118e1c:	d0a06715 	stw	r2,-32356(gp)
	if (!xSemTimeoutChecker) {
81118e20:	d0a06717 	ldw	r2,-32356(gp)
81118e24:	1000021e 	bne	r2,zero,81118e30 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
81118e28:	111cf140 	call	8111cf14 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118e2c:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
81118e30:	e0bfff04 	addi	r2,fp,-4
81118e34:	d8800215 	stw	r2,8(sp)
81118e38:	00a04574 	movhi	r2,33045
81118e3c:	1080bb04 	addi	r2,r2,748
81118e40:	d8800115 	stw	r2,4(sp)
81118e44:	d8000015 	stw	zero,0(sp)
81118e48:	01e044b4 	movhi	r7,33042
81118e4c:	39ea9704 	addi	r7,r7,-21924
81118e50:	01800084 	movi	r6,2
81118e54:	01400104 	movi	r5,4
81118e58:	01000284 	movi	r4,10
81118e5c:	1142b000 	call	81142b00 <OSTmrCreate>
81118e60:	d0a06d15 	stw	r2,-32332(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
81118e64:	e0bfff03 	ldbu	r2,-4(fp)
81118e68:	10803fcc 	andi	r2,r2,255
81118e6c:	10000226 	beq	r2,zero,81118e78 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81118e70:	111dea80 	call	8111dea8 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
81118e74:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81118e78:	01400484 	movi	r5,18
81118e7c:	012045b4 	movhi	r4,33046
81118e80:	21232f04 	addi	r4,r4,-29508
81118e84:	113f3680 	call	8113f368 <OSQCreate>
81118e88:	d0a05d15 	stw	r2,-32396(gp)
	if ( xNfeeSchedule == NULL ) {
81118e8c:	d0a05d17 	ldw	r2,-32396(gp)
81118e90:	1000021e 	bne	r2,zero,81118e9c <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
81118e94:	111e5f40 	call	8111e5f4 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81118e98:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81118e9c:	01400204 	movi	r5,8
81118ea0:	012045f4 	movhi	r4,33047
81118ea4:	21224304 	addi	r4,r4,-30452
81118ea8:	113f3680 	call	8113f368 <OSQCreate>
81118eac:	d0a06a15 	stw	r2,-32344(gp)
	if ( xFeeQ[0] == NULL ) {
81118eb0:	d0a06a17 	ldw	r2,-32344(gp)
81118eb4:	1000031e 	bne	r2,zero,81118ec4 <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81118eb8:	0009883a 	mov	r4,zero
81118ebc:	111e6740 	call	8111e674 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81118ec0:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
81118ec4:	01400204 	movi	r5,8
81118ec8:	012045b4 	movhi	r4,33046
81118ecc:	21078904 	addi	r4,r4,7716
81118ed0:	113f3680 	call	8113f368 <OSQCreate>
81118ed4:	d0a05c15 	stw	r2,-32400(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
81118ed8:	d0a05c17 	ldw	r2,-32400(gp)
81118edc:	1000031e 	bne	r2,zero,81118eec <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81118ee0:	0009883a 	mov	r4,zero
81118ee4:	111e6fc0 	call	8111e6fc <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
81118ee8:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
81118eec:	01400204 	movi	r5,8
81118ef0:	012045b4 	movhi	r4,33046
81118ef4:	21028704 	addi	r4,r4,2588
81118ef8:	113f3680 	call	8113f368 <OSQCreate>
81118efc:	d0a06915 	stw	r2,-32348(gp)
	if ( xMebQ == NULL ) {
81118f00:	d0a06917 	ldw	r2,-32348(gp)
81118f04:	1000031e 	bne	r2,zero,81118f14 <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
81118f08:	01000144 	movi	r4,5
81118f0c:	111e6740 	call	8111e674 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81118f10:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
81118f14:	e0bfff04 	addi	r2,fp,-4
81118f18:	100b883a 	mov	r5,r2
81118f1c:	010001c4 	movi	r4,7
81118f20:	113e27c0 	call	8113e27c <OSMutexCreate>
81118f24:	d0a07315 	stw	r2,-32308(gp)
	if ( err != OS_ERR_NONE ) {
81118f28:	e0bfff03 	ldbu	r2,-4(fp)
81118f2c:	10803fcc 	andi	r2,r2,255
81118f30:	10000526 	beq	r2,zero,81118f48 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
81118f34:	e0bfff03 	ldbu	r2,-4(fp)
81118f38:	10803fcc 	andi	r2,r2,255
81118f3c:	1009883a 	mov	r4,r2
81118f40:	111ec040 	call	8111ec04 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
81118f44:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81118f48:	01400404 	movi	r5,16
81118f4c:	012045b4 	movhi	r4,33046
81118f50:	21036104 	addi	r4,r4,3460
81118f54:	113f3680 	call	8113f368 <OSQCreate>
81118f58:	d0a07015 	stw	r2,-32320(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81118f5c:	d0a07017 	ldw	r2,-32320(gp)
81118f60:	1000021e 	bne	r2,zero,81118f6c <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
81118f64:	111edc40 	call	8111edc4 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
81118f68:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81118f6c:	01400404 	movi	r5,16
81118f70:	012045b4 	movhi	r4,33046
81118f74:	21364904 	addi	r4,r4,-9948
81118f78:	113f3680 	call	8113f368 <OSQCreate>
81118f7c:	d0a05f15 	stw	r2,-32388(gp)
	if ( xQMaskDataCtrl == NULL ) {
81118f80:	d0a05f17 	ldw	r2,-32388(gp)
81118f84:	1000021e 	bne	r2,zero,81118f90 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
81118f88:	111ee440 	call	8111ee44 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81118f8c:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
81118f90:	e0bfff04 	addi	r2,fp,-4
81118f94:	100b883a 	mov	r5,r2
81118f98:	01000104 	movi	r4,4
81118f9c:	113e27c0 	call	8113e27c <OSMutexCreate>
81118fa0:	1007883a 	mov	r3,r2
81118fa4:	00a045b4 	movhi	r2,33046
81118fa8:	10959704 	addi	r2,r2,22108
81118fac:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
81118fb0:	e0bfff03 	ldbu	r2,-4(fp)
81118fb4:	10803fcc 	andi	r2,r2,255
81118fb8:	10000226 	beq	r2,zero,81118fc4 <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
81118fbc:	111ceb00 	call	8111ceb0 <vFailCreateMutexDMA>
		bSuccess = FALSE;
81118fc0:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
81118fc4:	e0bfff04 	addi	r2,fp,-4
81118fc8:	100b883a 	mov	r5,r2
81118fcc:	01000184 	movi	r4,6
81118fd0:	113e27c0 	call	8113e27c <OSMutexCreate>
81118fd4:	1007883a 	mov	r3,r2
81118fd8:	00a045b4 	movhi	r2,33046
81118fdc:	10959704 	addi	r2,r2,22108
81118fe0:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
81118fe4:	e0bfff03 	ldbu	r2,-4(fp)
81118fe8:	10803fcc 	andi	r2,r2,255
81118fec:	10000226 	beq	r2,zero,81118ff8 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
81118ff0:	111ceb00 	call	8111ceb0 <vFailCreateMutexDMA>
		bSuccess = FALSE;
81118ff4:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
81118ff8:	e0bffe17 	ldw	r2,-8(fp)
}
81118ffc:	e037883a 	mov	sp,fp
81119000:	dfc00117 	ldw	ra,4(sp)
81119004:	df000017 	ldw	fp,0(sp)
81119008:	dec00204 	addi	sp,sp,8
8111900c:	f800283a 	ret

81119010 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
81119010:	defffd04 	addi	sp,sp,-12
81119014:	de00012e 	bgeu	sp,et,8111901c <vVariablesInitialization+0xc>
81119018:	003b68fa 	trap	3
8111901c:	dfc00215 	stw	ra,8(sp)
81119020:	df000115 	stw	fp,4(sp)
81119024:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
81119028:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
8111902c:	00800084 	movi	r2,2
81119030:	d0a0680d 	sth	r2,-32352(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
81119034:	01800604 	movi	r6,24
81119038:	000b883a 	mov	r5,zero
8111903c:	012045b4 	movhi	r4,33046
81119040:	21027104 	addi	r4,r4,2500
81119044:	11244a00 	call	811244a0 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
81119048:	01800804 	movi	r6,32
8111904c:	000b883a 	mov	r5,zero
81119050:	012045b4 	movhi	r4,33046
81119054:	21027704 	addi	r4,r4,2524
81119058:	11244a00 	call	811244a0 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
8111905c:	01800804 	movi	r6,32
81119060:	000b883a 	mov	r5,zero
81119064:	012045b4 	movhi	r4,33046
81119068:	21027f04 	addi	r4,r4,2556
8111906c:	11244a00 	call	811244a0 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81119070:	e03fff05 	stb	zero,-4(fp)
81119074:	00002806 	br	81119118 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
81119078:	e0bfff03 	ldbu	r2,-4(fp)
8111907c:	10c02324 	muli	r3,r2,140
81119080:	00a045b4 	movhi	r2,33046
81119084:	10828f04 	addi	r2,r2,2620
81119088:	1885883a 	add	r2,r3,r2
8111908c:	01802004 	movi	r6,128
81119090:	000b883a 	mov	r5,zero
81119094:	1009883a 	mov	r4,r2
81119098:	11244a00 	call	811244a0 <memset>
		xBuffer128[ucIL].bSent = FALSE;
8111909c:	e0ffff03 	ldbu	r3,-4(fp)
811190a0:	00a045b4 	movhi	r2,33046
811190a4:	10828f04 	addi	r2,r2,2620
811190a8:	18c02324 	muli	r3,r3,140
811190ac:	10c5883a 	add	r2,r2,r3
811190b0:	10802004 	addi	r2,r2,128
811190b4:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
811190b8:	e0ffff03 	ldbu	r3,-4(fp)
811190bc:	00a045b4 	movhi	r2,33046
811190c0:	10828f04 	addi	r2,r2,2620
811190c4:	18c02324 	muli	r3,r3,140
811190c8:	10c5883a 	add	r2,r2,r3
811190cc:	10802104 	addi	r2,r2,132
811190d0:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
811190d4:	e0ffff03 	ldbu	r3,-4(fp)
811190d8:	00a045b4 	movhi	r2,33046
811190dc:	10828f04 	addi	r2,r2,2620
811190e0:	18c02324 	muli	r3,r3,140
811190e4:	10c5883a 	add	r2,r2,r3
811190e8:	10802184 	addi	r2,r2,134
811190ec:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
811190f0:	e0ffff03 	ldbu	r3,-4(fp)
811190f4:	00a045b4 	movhi	r2,33046
811190f8:	10828f04 	addi	r2,r2,2620
811190fc:	18c02324 	muli	r3,r3,140
81119100:	10c5883a 	add	r2,r2,r3
81119104:	10802204 	addi	r2,r2,136
81119108:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8111910c:	e0bfff03 	ldbu	r2,-4(fp)
81119110:	10800044 	addi	r2,r2,1
81119114:	e0bfff05 	stb	r2,-4(fp)
81119118:	e0bfff03 	ldbu	r2,-4(fp)
8111911c:	108001b0 	cmpltui	r2,r2,6
81119120:	103fd51e 	bne	r2,zero,81119078 <__reset+0xfb0f9078>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81119124:	e03fff05 	stb	zero,-4(fp)
81119128:	00002806 	br	811191cc <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
8111912c:	e0bfff03 	ldbu	r2,-4(fp)
81119130:	10c01324 	muli	r3,r2,76
81119134:	00a04574 	movhi	r2,33045
81119138:	109e3304 	addi	r2,r2,30924
8111913c:	1885883a 	add	r2,r3,r2
81119140:	01801004 	movi	r6,64
81119144:	000b883a 	mov	r5,zero
81119148:	1009883a 	mov	r4,r2
8111914c:	11244a00 	call	811244a0 <memset>
		xBuffer64[ucIL].bSent = FALSE;
81119150:	e0ffff03 	ldbu	r3,-4(fp)
81119154:	00a04574 	movhi	r2,33045
81119158:	109e3304 	addi	r2,r2,30924
8111915c:	18c01324 	muli	r3,r3,76
81119160:	10c5883a 	add	r2,r2,r3
81119164:	10801004 	addi	r2,r2,64
81119168:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
8111916c:	e0ffff03 	ldbu	r3,-4(fp)
81119170:	00a04574 	movhi	r2,33045
81119174:	109e3304 	addi	r2,r2,30924
81119178:	18c01324 	muli	r3,r3,76
8111917c:	10c5883a 	add	r2,r2,r3
81119180:	10801104 	addi	r2,r2,68
81119184:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
81119188:	e0ffff03 	ldbu	r3,-4(fp)
8111918c:	00a04574 	movhi	r2,33045
81119190:	109e3304 	addi	r2,r2,30924
81119194:	18c01324 	muli	r3,r3,76
81119198:	10c5883a 	add	r2,r2,r3
8111919c:	10801184 	addi	r2,r2,70
811191a0:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
811191a4:	e0ffff03 	ldbu	r3,-4(fp)
811191a8:	00a04574 	movhi	r2,33045
811191ac:	109e3304 	addi	r2,r2,30924
811191b0:	18c01324 	muli	r3,r3,76
811191b4:	10c5883a 	add	r2,r2,r3
811191b8:	10801204 	addi	r2,r2,72
811191bc:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
811191c0:	e0bfff03 	ldbu	r2,-4(fp)
811191c4:	10800044 	addi	r2,r2,1
811191c8:	e0bfff05 	stb	r2,-4(fp)
811191cc:	e0bfff03 	ldbu	r2,-4(fp)
811191d0:	10800230 	cmpltui	r2,r2,8
811191d4:	103fd51e 	bne	r2,zero,8111912c <__reset+0xfb0f912c>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
811191d8:	e03fff05 	stb	zero,-4(fp)
811191dc:	00002806 	br	81119280 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
811191e0:	e0bfff03 	ldbu	r2,-4(fp)
811191e4:	10c00b24 	muli	r3,r2,44
811191e8:	00a045b4 	movhi	r2,33046
811191ec:	10aff104 	addi	r2,r2,-16444
811191f0:	1885883a 	add	r2,r3,r2
811191f4:	01800804 	movi	r6,32
811191f8:	000b883a 	mov	r5,zero
811191fc:	1009883a 	mov	r4,r2
81119200:	11244a00 	call	811244a0 <memset>
		xBuffer32[ucIL].bSent = FALSE;
81119204:	e0ffff03 	ldbu	r3,-4(fp)
81119208:	00a045b4 	movhi	r2,33046
8111920c:	10aff104 	addi	r2,r2,-16444
81119210:	18c00b24 	muli	r3,r3,44
81119214:	10c5883a 	add	r2,r2,r3
81119218:	10800804 	addi	r2,r2,32
8111921c:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81119220:	e0ffff03 	ldbu	r3,-4(fp)
81119224:	00a045b4 	movhi	r2,33046
81119228:	10aff104 	addi	r2,r2,-16444
8111922c:	18c00b24 	muli	r3,r3,44
81119230:	10c5883a 	add	r2,r2,r3
81119234:	10800904 	addi	r2,r2,36
81119238:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
8111923c:	e0ffff03 	ldbu	r3,-4(fp)
81119240:	00a045b4 	movhi	r2,33046
81119244:	10aff104 	addi	r2,r2,-16444
81119248:	18c00b24 	muli	r3,r3,44
8111924c:	10c5883a 	add	r2,r2,r3
81119250:	10800984 	addi	r2,r2,38
81119254:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81119258:	e0ffff03 	ldbu	r3,-4(fp)
8111925c:	00a045b4 	movhi	r2,33046
81119260:	10aff104 	addi	r2,r2,-16444
81119264:	18c00b24 	muli	r3,r3,44
81119268:	10c5883a 	add	r2,r2,r3
8111926c:	10800a04 	addi	r2,r2,40
81119270:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81119274:	e0bfff03 	ldbu	r2,-4(fp)
81119278:	10800044 	addi	r2,r2,1
8111927c:	e0bfff05 	stb	r2,-4(fp)
81119280:	e0bfff03 	ldbu	r2,-4(fp)
81119284:	10800230 	cmpltui	r2,r2,8
81119288:	103fd51e 	bne	r2,zero,811191e0 <__reset+0xfb0f91e0>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
8111928c:	e03fff05 	stb	zero,-4(fp)
81119290:	00001b06 	br	81119300 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
81119294:	e0ffff03 	ldbu	r3,-4(fp)
81119298:	00a04574 	movhi	r2,33045
8111929c:	109ecb04 	addi	r2,r2,31532
811192a0:	18c01524 	muli	r3,r3,84
811192a4:	10c5883a 	add	r2,r2,r3
811192a8:	10800104 	addi	r2,r2,4
811192ac:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
811192b0:	e0ffff03 	ldbu	r3,-4(fp)
811192b4:	00a04574 	movhi	r2,33045
811192b8:	109ecb04 	addi	r2,r2,31532
811192bc:	18c01524 	muli	r3,r3,84
811192c0:	10c5883a 	add	r2,r2,r3
811192c4:	10800484 	addi	r2,r2,18
811192c8:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
811192cc:	e0bfff03 	ldbu	r2,-4(fp)
811192d0:	10801524 	muli	r2,r2,84
811192d4:	10c00504 	addi	r3,r2,20
811192d8:	00a04574 	movhi	r2,33045
811192dc:	109ecb04 	addi	r2,r2,31532
811192e0:	1885883a 	add	r2,r3,r2
811192e4:	01801004 	movi	r6,64
811192e8:	000b883a 	mov	r5,zero
811192ec:	1009883a 	mov	r4,r2
811192f0:	11244a00 	call	811244a0 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811192f4:	e0bfff03 	ldbu	r2,-4(fp)
811192f8:	10800044 	addi	r2,r2,1
811192fc:	e0bfff05 	stb	r2,-4(fp)
81119300:	e0bfff03 	ldbu	r2,-4(fp)
81119304:	10800130 	cmpltui	r2,r2,4
81119308:	103fe21e 	bne	r2,zero,81119294 <__reset+0xfb0f9294>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
8111930c:	0001883a 	nop
81119310:	e037883a 	mov	sp,fp
81119314:	dfc00117 	ldw	ra,4(sp)
81119318:	df000017 	ldw	fp,0(sp)
8111931c:	dec00204 	addi	sp,sp,8
81119320:	f800283a 	ret

81119324 <main>:
void vFillMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
81119324:	defff704 	addi	sp,sp,-36
81119328:	de00012e 	bgeu	sp,et,81119330 <main+0xc>
8111932c:	003b68fa 	trap	3
81119330:	dfc00815 	stw	ra,32(sp)
81119334:	df000715 	stw	fp,28(sp)
81119338:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
8111933c:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
81119340:	113a7180 	call	8113a718 <OSInit>

	/* Debug device initialization - JTAG USB */
	#if DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
81119344:	01604574 	movhi	r5,33045
81119348:	2940bf04 	addi	r5,r5,764
8111934c:	01204574 	movhi	r4,33045
81119350:	2100c004 	addi	r4,r4,768
81119354:	11232580 	call	81123258 <fopen>
81119358:	d0a06215 	stw	r2,-32376(gp)
	#endif	

	#if DEBUG_ON
		debug(fp, "Main entry point.\n");
8111935c:	d0a06217 	ldw	r2,-32376(gp)
81119360:	100f883a 	mov	r7,r2
81119364:	01800484 	movi	r6,18
81119368:	01400044 	movi	r5,1
8111936c:	01204574 	movhi	r4,33045
81119370:	2100c504 	addi	r4,r4,788
81119374:	112393c0 	call	8112393c <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
81119378:	112004c0 	call	8112004c <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
8111937c:	1120bcc0 	call	81120bcc <bTestSimucamCriticalHW>
81119380:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81119384:	e0bffe17 	ldw	r2,-8(fp)
81119388:	1000031e 	bne	r2,zero,81119398 <main+0x74>
		vFailTestCriticasParts();
8111938c:	111cf780 	call	8111cf78 <vFailTestCriticasParts>
		return -1;
81119390:	00bfffc4 	movi	r2,-1
81119394:	00006606 	br	81119530 <main+0x20c>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
81119398:	11207c00 	call	811207c0 <bInitializeSDCard>
8111939c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811193a0:	e0bffe17 	ldw	r2,-8(fp)
811193a4:	1000031e 	bne	r2,zero,811193b4 <main+0x90>
		vFailTestCriticasParts();
811193a8:	111cf780 	call	8111cf78 <vFailTestCriticasParts>
		return -1;
811193ac:	00bfffc4 	movi	r2,-1
811193b0:	00005f06 	br	81119530 <main+0x20c>
	}

	bIniSimucamStatus = vLoadDebugConfs();
811193b4:	111bbf40 	call	8111bbf4 <vLoadDebugConfs>
811193b8:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811193bc:	e0bffe17 	ldw	r2,-8(fp)
811193c0:	10000f1e 	bne	r2,zero,81119400 <main+0xdc>
		/* Default configuration for eth connection loaded */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811193c4:	00a045f4 	movhi	r2,33047
811193c8:	10a25304 	addi	r2,r2,-30388
811193cc:	10800a8b 	ldhu	r2,42(r2)
811193d0:	10bfffcc 	andi	r2,r2,65535
811193d4:	10800228 	cmpgeui	r2,r2,8
811193d8:	1000071e 	bne	r2,zero,811193f8 <main+0xd4>
			debug(fp, "Didn't load DEBUG configuration from SDCard. Default configuration will be loaded. \n");
811193dc:	d0a06217 	ldw	r2,-32376(gp)
811193e0:	100f883a 	mov	r7,r2
811193e4:	01801504 	movi	r6,84
811193e8:	01400044 	movi	r5,1
811193ec:	01204574 	movhi	r4,33045
811193f0:	2100ca04 	addi	r4,r4,808
811193f4:	112393c0 	call	8112393c <fwrite>
		}
		#endif
		return -1;
811193f8:	00bfffc4 	movi	r2,-1
811193fc:	00004c06 	br	81119530 <main+0x20c>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
81119400:	111ae840 	call	8111ae84 <vLoadDefaultETHConf>
81119404:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81119408:	e0bffe17 	ldw	r2,-8(fp)
8111940c:	10000f1e 	bne	r2,zero,8111944c <main+0x128>
		/* Default configuration for eth connection loaded */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81119410:	00a045f4 	movhi	r2,33047
81119414:	10a25304 	addi	r2,r2,-30388
81119418:	10800a8b 	ldhu	r2,42(r2)
8111941c:	10bfffcc 	andi	r2,r2,65535
81119420:	10800228 	cmpgeui	r2,r2,8
81119424:	1000071e 	bne	r2,zero,81119444 <main+0x120>
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. \n");
81119428:	d0a06217 	ldw	r2,-32376(gp)
8111942c:	100f883a 	mov	r7,r2
81119430:	01801484 	movi	r6,82
81119434:	01400044 	movi	r5,1
81119438:	01204574 	movhi	r4,33045
8111943c:	2100e004 	addi	r4,r4,896
81119440:	112393c0 	call	8112393c <fwrite>
		}
		#endif
		return -1;
81119444:	00bfffc4 	movi	r2,-1
81119448:	00003906 	br	81119530 <main+0x20c>
	}


	/* If debug is enable, will print the eth configuration in the*/
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111944c:	00a045f4 	movhi	r2,33047
81119450:	10a25304 	addi	r2,r2,-30388
81119454:	10800a8b 	ldhu	r2,42(r2)
81119458:	10bfffcc 	andi	r2,r2,65535
8111945c:	108000e8 	cmpgeui	r2,r2,3
81119460:	1000011e 	bne	r2,zero,81119468 <main+0x144>
		vShowEthConfig();
81119464:	111b8c40 	call	8111b8c4 <vShowEthConfig>
	}
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
81119468:	1118ba00 	call	81118ba0 <bResourcesInitRTOS>
8111946c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81119470:	e0bffe17 	ldw	r2,-8(fp)
81119474:	10000f1e 	bne	r2,zero,811194b4 <main+0x190>
		/* Default configuration for eth connection loaded */
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81119478:	00a045f4 	movhi	r2,33047
8111947c:	10a25304 	addi	r2,r2,-30388
81119480:	10800a8b 	ldhu	r2,42(r2)
81119484:	10bfffcc 	andi	r2,r2,65535
81119488:	10800228 	cmpgeui	r2,r2,8
8111948c:	1000071e 	bne	r2,zero,811194ac <main+0x188>
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
81119490:	d0a06217 	ldw	r2,-32376(gp)
81119494:	100f883a 	mov	r7,r2
81119498:	01800ac4 	movi	r6,43
8111949c:	01400044 	movi	r5,1
811194a0:	01204574 	movhi	r4,33045
811194a4:	2100f504 	addi	r4,r4,980
811194a8:	112393c0 	call	8112393c <fwrite>
	}
	#endif
		return -1;
811194ac:	00bfffc4 	movi	r2,-1
811194b0:	00001f06 	br	81119530 <main+0x20c>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
811194b4:	012045b4 	movhi	r4,33046
811194b8:	212b4104 	addi	r4,r4,-21244
811194bc:	112018c0 	call	8112018c <vSimucamStructureInit>

	vVariablesInitialization();
811194c0:	11190100 	call	81119010 <vVariablesInitialization>

	bInitSync();
811194c4:	11209740 	call	81120974 <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
811194c8:	012045b4 	movhi	r4,33046
811194cc:	212b4104 	addi	r4,r4,-21244
811194d0:	11195440 	call	81119544 <vFillMemmoryPattern>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
811194d4:	d8000415 	stw	zero,16(sp)
811194d8:	d8000315 	stw	zero,12(sp)
811194dc:	00810004 	movi	r2,1024
811194e0:	d8800215 	stw	r2,8(sp)
811194e4:	00a045b4 	movhi	r2,33046
811194e8:	10ba6904 	addi	r2,r2,-5724
811194ec:	d8800115 	stw	r2,4(sp)
811194f0:	00800044 	movi	r2,1
811194f4:	d8800015 	stw	r2,0(sp)
811194f8:	01c00044 	movi	r7,1
811194fc:	01a045b4 	movhi	r6,33046
81119500:	31be6804 	addi	r6,r6,-1632
81119504:	000b883a 	mov	r5,zero
81119508:	01204474 	movhi	r4,33041
8111950c:	210cb604 	addi	r4,r4,13016
81119510:	11414c80 	call	811414c8 <OSTaskCreateExt>
81119514:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
81119518:	e0bfff03 	ldbu	r2,-4(fp)
8111951c:	1000021e 	bne	r2,zero,81119528 <main+0x204>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
81119520:	113aa480 	call	8113aa48 <OSStart>
81119524:	00000106 	br	8111952c <main+0x208>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
81119528:	111d46c0 	call	8111d46c <vFailInitialization>
	}
  
	return 0;
8111952c:	0005883a 	mov	r2,zero
}
81119530:	e037883a 	mov	sp,fp
81119534:	dfc00117 	ldw	ra,4(sp)
81119538:	df000017 	ldw	fp,0(sp)
8111953c:	dec00204 	addi	sp,sp,8
81119540:	f800283a 	ret

81119544 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81119544:	defff604 	addi	sp,sp,-40
81119548:	de00012e 	bgeu	sp,et,81119550 <vFillMemmoryPattern+0xc>
8111954c:	003b68fa 	trap	3
81119550:	dfc00915 	stw	ra,36(sp)
81119554:	df000815 	stw	fp,32(sp)
81119558:	df000804 	addi	fp,sp,32
8111955c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81119560:	00800044 	movi	r2,1
81119564:	e0bffcc5 	stb	r2,-13(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81119568:	00a045f4 	movhi	r2,33047
8111956c:	10a25304 	addi	r2,r2,-30388
81119570:	10800a8b 	ldhu	r2,42(r2)
81119574:	10bfffcc 	andi	r2,r2,65535
81119578:	10800168 	cmpgeui	r2,r2,5
8111957c:	1000071e 	bne	r2,zero,8111959c <vFillMemmoryPattern+0x58>
		debug(fp, "\nStart to fill the memory with Pattern.\n");
81119580:	d0a06217 	ldw	r2,-32376(gp)
81119584:	100f883a 	mov	r7,r2
81119588:	01800a04 	movi	r6,40
8111958c:	01400044 	movi	r5,1
81119590:	01204574 	movhi	r4,33045
81119594:	21010004 	addi	r4,r4,1024
81119598:	112393c0 	call	8112393c <fwrite>
	}
#endif

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
8111959c:	e03ffa05 	stb	zero,-24(fp)
811195a0:	0000a706 	br	81119840 <vFillMemmoryPattern+0x2fc>
		/* n NFEE */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811195a4:	00a045f4 	movhi	r2,33047
811195a8:	10a25304 	addi	r2,r2,-30388
811195ac:	10800a8b 	ldhu	r2,42(r2)
811195b0:	10bfffcc 	andi	r2,r2,65535
811195b4:	10800168 	cmpgeui	r2,r2,5
811195b8:	1000071e 	bne	r2,zero,811195d8 <vFillMemmoryPattern+0x94>
			fprintf(fp, "Memory %i\n",mem_number);
811195bc:	d0a06217 	ldw	r2,-32376(gp)
811195c0:	e0fffa03 	ldbu	r3,-24(fp)
811195c4:	180d883a 	mov	r6,r3
811195c8:	01604574 	movhi	r5,33045
811195cc:	29410b04 	addi	r5,r5,1068
811195d0:	1009883a 	mov	r4,r2
811195d4:	11232a00 	call	811232a0 <fprintf>
		}
		#endif
		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811195d8:	e03ffc85 	stb	zero,-14(fp)
811195dc:	00009206 	br	81119828 <vFillMemmoryPattern+0x2e4>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811195e0:	00a045f4 	movhi	r2,33047
811195e4:	10a25304 	addi	r2,r2,-30388
811195e8:	10800a8b 	ldhu	r2,42(r2)
811195ec:	10bfffcc 	andi	r2,r2,65535
811195f0:	10800168 	cmpgeui	r2,r2,5
811195f4:	1000071e 	bne	r2,zero,81119614 <vFillMemmoryPattern+0xd0>
				fprintf(fp, "--NFEE %i\n", NFee_i);
811195f8:	d0a06217 	ldw	r2,-32376(gp)
811195fc:	e0fffc83 	ldbu	r3,-14(fp)
81119600:	180d883a 	mov	r6,r3
81119604:	01604574 	movhi	r5,33045
81119608:	29410e04 	addi	r5,r5,1080
8111960c:	1009883a 	mov	r4,r2
81119610:	11232a00 	call	811232a0 <fprintf>
			}
			#endif
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81119614:	e0bffc83 	ldbu	r2,-14(fp)
81119618:	e0ffff17 	ldw	r3,-4(fp)
8111961c:	10809824 	muli	r2,r2,608
81119620:	1885883a 	add	r2,r3,r2
81119624:	10804304 	addi	r2,r2,268
81119628:	1080000b 	ldhu	r2,0(r2)
8111962c:	10ffffcc 	andi	r3,r2,65535
81119630:	e0bffc83 	ldbu	r2,-14(fp)
81119634:	e13fff17 	ldw	r4,-4(fp)
81119638:	10809824 	muli	r2,r2,608
8111963c:	2085883a 	add	r2,r4,r2
81119640:	10804204 	addi	r2,r2,264
81119644:	1080000b 	ldhu	r2,0(r2)
81119648:	10bfffcc 	andi	r2,r2,65535
8111964c:	1885883a 	add	r2,r3,r2
81119650:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81119654:	e0bffc83 	ldbu	r2,-14(fp)
81119658:	e0ffff17 	ldw	r3,-4(fp)
8111965c:	10809824 	muli	r2,r2,608
81119660:	1885883a 	add	r2,r3,r2
81119664:	10804284 	addi	r2,r2,266
81119668:	1080000b 	ldhu	r2,0(r2)
8111966c:	10ffffcc 	andi	r3,r2,65535
81119670:	e0bffc83 	ldbu	r2,-14(fp)
81119674:	e13fff17 	ldw	r4,-4(fp)
81119678:	10809824 	muli	r2,r2,608
8111967c:	2085883a 	add	r2,r4,r2
81119680:	10804184 	addi	r2,r2,262
81119684:	1080000b 	ldhu	r2,0(r2)
81119688:	10bfffcc 	andi	r2,r2,65535
8111968c:	1887883a 	add	r3,r3,r2
81119690:	e0bffc83 	ldbu	r2,-14(fp)
81119694:	e13fff17 	ldw	r4,-4(fp)
81119698:	10809824 	muli	r2,r2,608
8111969c:	2085883a 	add	r2,r4,r2
811196a0:	10804104 	addi	r2,r2,260
811196a4:	1080000b 	ldhu	r2,0(r2)
811196a8:	10bfffcc 	andi	r2,r2,65535
811196ac:	1885883a 	add	r2,r3,r2
811196b0:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811196b4:	e03ffc05 	stb	zero,-16(fp)
811196b8:	00005506 	br	81119810 <vFillMemmoryPattern+0x2cc>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811196bc:	00a045f4 	movhi	r2,33047
811196c0:	10a25304 	addi	r2,r2,-30388
811196c4:	10800a8b 	ldhu	r2,42(r2)
811196c8:	10bfffcc 	andi	r2,r2,65535
811196cc:	10800168 	cmpgeui	r2,r2,5
811196d0:	1000071e 	bne	r2,zero,811196f0 <vFillMemmoryPattern+0x1ac>
					fprintf(fp, "-----CCD %i\n", ccd_number);
811196d4:	d0a06217 	ldw	r2,-32376(gp)
811196d8:	e0fffc03 	ldbu	r3,-16(fp)
811196dc:	180d883a 	mov	r6,r3
811196e0:	01604574 	movhi	r5,33045
811196e4:	29411104 	addi	r5,r5,1092
811196e8:	1009883a 	mov	r4,r2
811196ec:	11232a00 	call	811232a0 <fprintf>
				}
				#endif

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811196f0:	e03ffc45 	stb	zero,-15(fp)
811196f4:	00004006 	br	811197f8 <vFillMemmoryPattern+0x2b4>
					if (ccd_side == 0){
811196f8:	e0bffc43 	ldbu	r2,-15(fp)
811196fc:	1000181e 	bne	r2,zero,81119760 <vFillMemmoryPattern+0x21c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81119700:	00a045f4 	movhi	r2,33047
81119704:	10a25304 	addi	r2,r2,-30388
81119708:	10800a8b 	ldhu	r2,42(r2)
8111970c:	10bfffcc 	andi	r2,r2,65535
81119710:	10800168 	cmpgeui	r2,r2,5
81119714:	1000071e 	bne	r2,zero,81119734 <vFillMemmoryPattern+0x1f0>
							fprintf(fp, "------Left side\n");
81119718:	d0a06217 	ldw	r2,-32376(gp)
8111971c:	100f883a 	mov	r7,r2
81119720:	01800404 	movi	r6,16
81119724:	01400044 	movi	r5,1
81119728:	01204574 	movhi	r4,33045
8111972c:	21011504 	addi	r4,r4,1108
81119730:	112393c0 	call	8112393c <fwrite>
						}
						#endif
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81119734:	e0bffc83 	ldbu	r2,-14(fp)
81119738:	e13ffc03 	ldbu	r4,-16(fp)
8111973c:	e0ffff17 	ldw	r3,-4(fp)
81119740:	21000624 	muli	r4,r4,24
81119744:	10809824 	muli	r2,r2,608
81119748:	2085883a 	add	r2,r4,r2
8111974c:	1885883a 	add	r2,r3,r2
81119750:	10801b04 	addi	r2,r2,108
81119754:	10800017 	ldw	r2,0(r2)
81119758:	e0bffb15 	stw	r2,-20(fp)
8111975c:	00001706 	br	811197bc <vFillMemmoryPattern+0x278>
					} else {
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81119760:	00a045f4 	movhi	r2,33047
81119764:	10a25304 	addi	r2,r2,-30388
81119768:	10800a8b 	ldhu	r2,42(r2)
8111976c:	10bfffcc 	andi	r2,r2,65535
81119770:	10800168 	cmpgeui	r2,r2,5
81119774:	1000071e 	bne	r2,zero,81119794 <vFillMemmoryPattern+0x250>
							fprintf(fp, "------Right side\n");
81119778:	d0a06217 	ldw	r2,-32376(gp)
8111977c:	100f883a 	mov	r7,r2
81119780:	01800444 	movi	r6,17
81119784:	01400044 	movi	r5,1
81119788:	01204574 	movhi	r4,33045
8111978c:	21011a04 	addi	r4,r4,1128
81119790:	112393c0 	call	8112393c <fwrite>
						}
						#endif
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81119794:	e0bffc83 	ldbu	r2,-14(fp)
81119798:	e13ffc03 	ldbu	r4,-16(fp)
8111979c:	e0ffff17 	ldw	r3,-4(fp)
811197a0:	21000624 	muli	r4,r4,24
811197a4:	10809824 	muli	r2,r2,608
811197a8:	2085883a 	add	r2,r4,r2
811197ac:	1885883a 	add	r2,r3,r2
811197b0:	10801e04 	addi	r2,r2,120
811197b4:	10800017 	ldw	r2,0(r2)
811197b8:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
811197bc:	e0fffa03 	ldbu	r3,-24(fp)
811197c0:	e13ffc03 	ldbu	r4,-16(fp)
811197c4:	e17ffc43 	ldbu	r5,-15(fp)
811197c8:	e0bffd17 	ldw	r2,-12(fp)
811197cc:	d8800115 	stw	r2,4(sp)
811197d0:	e0bffe17 	ldw	r2,-8(fp)
811197d4:	d8800015 	stw	r2,0(sp)
811197d8:	280f883a 	mov	r7,r5
811197dc:	200d883a 	mov	r6,r4
811197e0:	e17ffb17 	ldw	r5,-20(fp)
811197e4:	1809883a 	mov	r4,r3
811197e8:	11205500 	call	81120550 <pattern_createPattern>
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp, "-----CCD %i\n", ccd_number);
				}
				#endif

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811197ec:	e0bffc43 	ldbu	r2,-15(fp)
811197f0:	10800044 	addi	r2,r2,1
811197f4:	e0bffc45 	stb	r2,-15(fp)
811197f8:	e0bffc43 	ldbu	r2,-15(fp)
811197fc:	108000b0 	cmpltui	r2,r2,2
81119800:	103fbd1e 	bne	r2,zero,811196f8 <__reset+0xfb0f96f8>
			}
			#endif
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81119804:	e0bffc03 	ldbu	r2,-16(fp)
81119808:	10800044 	addi	r2,r2,1
8111980c:	e0bffc05 	stb	r2,-16(fp)
81119810:	e0bffc03 	ldbu	r2,-16(fp)
81119814:	10800130 	cmpltui	r2,r2,4
81119818:	103fa81e 	bne	r2,zero,811196bc <__reset+0xfb0f96bc>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
			fprintf(fp, "Memory %i\n",mem_number);
		}
		#endif
		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
8111981c:	e0bffc83 	ldbu	r2,-14(fp)
81119820:	10800044 	addi	r2,r2,1
81119824:	e0bffc85 	stb	r2,-14(fp)
81119828:	e0fffc83 	ldbu	r3,-14(fp)
8111982c:	e0bffcc3 	ldbu	r2,-13(fp)
81119830:	18bf6b36 	bltu	r3,r2,811195e0 <__reset+0xfb0f95e0>
		debug(fp, "\nStart to fill the memory with Pattern.\n");
	}
#endif

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81119834:	e0bffa03 	ldbu	r2,-24(fp)
81119838:	10800044 	addi	r2,r2,1
8111983c:	e0bffa05 	stb	r2,-24(fp)
81119840:	e0bffa03 	ldbu	r2,-24(fp)
81119844:	108000b0 	cmpltui	r2,r2,2
81119848:	103f561e 	bne	r2,zero,811195a4 <__reset+0xfb0f95a4>
			}
		}
	}

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8111984c:	00a045f4 	movhi	r2,33047
81119850:	10a25304 	addi	r2,r2,-30388
81119854:	10800a8b 	ldhu	r2,42(r2)
81119858:	10bfffcc 	andi	r2,r2,65535
8111985c:	10800168 	cmpgeui	r2,r2,5
81119860:	1000071e 	bne	r2,zero,81119880 <vFillMemmoryPattern+0x33c>
	debug(fp, "\nMemory Filled\n");
81119864:	d0a06217 	ldw	r2,-32376(gp)
81119868:	100f883a 	mov	r7,r2
8111986c:	018003c4 	movi	r6,15
81119870:	01400044 	movi	r5,1
81119874:	01204574 	movhi	r4,33045
81119878:	21011f04 	addi	r4,r4,1148
8111987c:	112393c0 	call	8112393c <fwrite>
	}
#endif

}
81119880:	0001883a 	nop
81119884:	e037883a 	mov	sp,fp
81119888:	dfc00117 	ldw	ra,4(sp)
8111988c:	df000017 	ldw	fp,0(sp)
81119890:	dec00204 	addi	sp,sp,8
81119894:	f800283a 	ret

81119898 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
81119898:	defffd04 	addi	sp,sp,-12
8111989c:	de00012e 	bgeu	sp,et,811198a4 <vCCDLoadDefaultValues+0xc>
811198a0:	003b68fa 	trap	3
811198a4:	dfc00215 	stw	ra,8(sp)
811198a8:	df000115 	stw	fp,4(sp)
811198ac:	df000104 	addi	fp,sp,4
811198b0:	e13fff15 	stw	r4,-4(fp)
	ccdDef->usiOLN = 30;
	ccdDef->usiHalfWidth = 2255;
	ccdDef->usiSOverscanN = 15;
	ccdDef->usiSPrescanN = 25;
*/
	ccdDef->usiHeight = xDefaults.usiRows;
811198b4:	00a045f4 	movhi	r2,33047
811198b8:	10a25304 	addi	r2,r2,-30388
811198bc:	10c0030b 	ldhu	r3,12(r2)
811198c0:	e0bfff17 	ldw	r2,-4(fp)
811198c4:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = xDefaults.usiOLN;
811198c8:	00a045f4 	movhi	r2,33047
811198cc:	10a25304 	addi	r2,r2,-30388
811198d0:	10c0020b 	ldhu	r3,8(r2)
811198d4:	e0bfff17 	ldw	r2,-4(fp)
811198d8:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = xDefaults.usiCols;
811198dc:	00a045f4 	movhi	r2,33047
811198e0:	10a25304 	addi	r2,r2,-30388
811198e4:	10c0028b 	ldhu	r3,10(r2)
811198e8:	e0bfff17 	ldw	r2,-4(fp)
811198ec:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = xDefaults.usiOverScanSerial;
811198f0:	00a045f4 	movhi	r2,33047
811198f4:	10a25304 	addi	r2,r2,-30388
811198f8:	10c0010b 	ldhu	r3,4(r2)
811198fc:	e0bfff17 	ldw	r2,-4(fp)
81119900:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = xDefaults.usiPreScanSerial;
81119904:	00a045f4 	movhi	r2,33047
81119908:	10a25304 	addi	r2,r2,-30388
8111990c:	10c0018b 	ldhu	r3,6(r2)
81119910:	e0bfff17 	ldw	r2,-4(fp)
81119914:	10c0000d 	sth	r3,0(r2)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81119918:	00a045f4 	movhi	r2,33047
8111991c:	10a25304 	addi	r2,r2,-30388
81119920:	10800a8b 	ldhu	r2,42(r2)
81119924:	10bfffcc 	andi	r2,r2,65535
81119928:	108000e8 	cmpgeui	r2,r2,3
8111992c:	10002d1e 	bne	r2,zero,811199e4 <vCCDLoadDefaultValues+0x14c>
		fprintf(fp,"\nusiHeight %hu\n", ccdDef->usiHeight);
81119930:	d0e06217 	ldw	r3,-32376(gp)
81119934:	e0bfff17 	ldw	r2,-4(fp)
81119938:	1080020b 	ldhu	r2,8(r2)
8111993c:	10bfffcc 	andi	r2,r2,65535
81119940:	100d883a 	mov	r6,r2
81119944:	01604574 	movhi	r5,33045
81119948:	29412304 	addi	r5,r5,1164
8111994c:	1809883a 	mov	r4,r3
81119950:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"usiOLN %hu\n", ccdDef->usiOLN);
81119954:	d0e06217 	ldw	r3,-32376(gp)
81119958:	e0bfff17 	ldw	r2,-4(fp)
8111995c:	1080010b 	ldhu	r2,4(r2)
81119960:	10bfffcc 	andi	r2,r2,65535
81119964:	100d883a 	mov	r6,r2
81119968:	01604574 	movhi	r5,33045
8111996c:	29412704 	addi	r5,r5,1180
81119970:	1809883a 	mov	r4,r3
81119974:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"usiHalfWidth %hu\n", ccdDef->usiHalfWidth);
81119978:	d0e06217 	ldw	r3,-32376(gp)
8111997c:	e0bfff17 	ldw	r2,-4(fp)
81119980:	1080018b 	ldhu	r2,6(r2)
81119984:	10bfffcc 	andi	r2,r2,65535
81119988:	100d883a 	mov	r6,r2
8111998c:	01604574 	movhi	r5,33045
81119990:	29412a04 	addi	r5,r5,1192
81119994:	1809883a 	mov	r4,r3
81119998:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"usiSOverscanN %hu\n", ccdDef->usiSOverscanN);
8111999c:	d0e06217 	ldw	r3,-32376(gp)
811199a0:	e0bfff17 	ldw	r2,-4(fp)
811199a4:	1080008b 	ldhu	r2,2(r2)
811199a8:	10bfffcc 	andi	r2,r2,65535
811199ac:	100d883a 	mov	r6,r2
811199b0:	01604574 	movhi	r5,33045
811199b4:	29412f04 	addi	r5,r5,1212
811199b8:	1809883a 	mov	r4,r3
811199bc:	11232a00 	call	811232a0 <fprintf>
		fprintf(fp,"usiSPrescanN %hu\n",  ccdDef->usiSPrescanN);
811199c0:	d0e06217 	ldw	r3,-32376(gp)
811199c4:	e0bfff17 	ldw	r2,-4(fp)
811199c8:	1080000b 	ldhu	r2,0(r2)
811199cc:	10bfffcc 	andi	r2,r2,65535
811199d0:	100d883a 	mov	r6,r2
811199d4:	01604574 	movhi	r5,33045
811199d8:	29413404 	addi	r5,r5,1232
811199dc:	1809883a 	mov	r4,r3
811199e0:	11232a00 	call	811232a0 <fprintf>
	}
#endif

}
811199e4:	0001883a 	nop
811199e8:	e037883a 	mov	sp,fp
811199ec:	dfc00117 	ldw	ra,4(sp)
811199f0:	df000017 	ldw	fp,0(sp)
811199f4:	dec00204 	addi	sp,sp,8
811199f8:	f800283a 	ret

811199fc <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
811199fc:	defff904 	addi	sp,sp,-28
81119a00:	de00012e 	bgeu	sp,et,81119a08 <vCCDChangeValues+0xc>
81119a04:	003b68fa 	trap	3
81119a08:	df000615 	stw	fp,24(sp)
81119a0c:	df000604 	addi	fp,sp,24
81119a10:	e13ffa15 	stw	r4,-24(fp)
81119a14:	2811883a 	mov	r8,r5
81119a18:	300b883a 	mov	r5,r6
81119a1c:	3809883a 	mov	r4,r7
81119a20:	e0c00117 	ldw	r3,4(fp)
81119a24:	e0800217 	ldw	r2,8(fp)
81119a28:	e23ffb0d 	sth	r8,-20(fp)
81119a2c:	e17ffc0d 	sth	r5,-16(fp)
81119a30:	e13ffd0d 	sth	r4,-12(fp)
81119a34:	e0fffe0d 	sth	r3,-8(fp)
81119a38:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
81119a3c:	e0bffa17 	ldw	r2,-24(fp)
81119a40:	e0fffb0b 	ldhu	r3,-20(fp)
81119a44:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
81119a48:	e0bffa17 	ldw	r2,-24(fp)
81119a4c:	e0fffc0b 	ldhu	r3,-16(fp)
81119a50:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81119a54:	e0bffa17 	ldw	r2,-24(fp)
81119a58:	e0fffd0b 	ldhu	r3,-12(fp)
81119a5c:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81119a60:	e0bffa17 	ldw	r2,-24(fp)
81119a64:	e0fffe0b 	ldhu	r3,-8(fp)
81119a68:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
81119a6c:	e0bffa17 	ldw	r2,-24(fp)
81119a70:	e0ffff0b 	ldhu	r3,-4(fp)
81119a74:	10c0000d 	sth	r3,0(r2)
}
81119a78:	0001883a 	nop
81119a7c:	e037883a 	mov	sp,fp
81119a80:	df000017 	ldw	fp,0(sp)
81119a84:	dec00104 	addi	sp,sp,4
81119a88:	f800283a 	ret

81119a8c <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
81119a8c:	defff904 	addi	sp,sp,-28
81119a90:	de00012e 	bgeu	sp,et,81119a98 <bSendUART128v2+0xc>
81119a94:	003b68fa 	trap	3
81119a98:	dfc00615 	stw	ra,24(sp)
81119a9c:	df000515 	stw	fp,20(sp)
81119aa0:	df000504 	addi	fp,sp,20
81119aa4:	e13ffe15 	stw	r4,-8(fp)
81119aa8:	2805883a 	mov	r2,r5
81119aac:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
81119ab0:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81119ab4:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81119ab8:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81119abc:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81119ac0:	d0a06317 	ldw	r2,-32372(gp)
81119ac4:	e0fffd04 	addi	r3,fp,-12
81119ac8:	180d883a 	mov	r6,r3
81119acc:	01400504 	movi	r5,20
81119ad0:	1009883a 	mov	r4,r2
81119ad4:	114075c0 	call	8114075c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81119ad8:	e0bffd03 	ldbu	r2,-12(fp)
81119adc:	10803fcc 	andi	r2,r2,255
81119ae0:	10000326 	beq	r2,zero,81119af0 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81119ae4:	111d77c0 	call	8111d77c <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
81119ae8:	e0bffc17 	ldw	r2,-16(fp)
81119aec:	0000aa06 	br	81119d98 <bSendUART128v2+0x30c>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81119af0:	d0a06e17 	ldw	r2,-32328(gp)
81119af4:	e0fffd04 	addi	r3,fp,-12
81119af8:	180d883a 	mov	r6,r3
81119afc:	01400104 	movi	r5,4
81119b00:	1009883a 	mov	r4,r2
81119b04:	113e7500 	call	8113e750 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81119b08:	e0bffd03 	ldbu	r2,-12(fp)
81119b0c:	10803fcc 	andi	r2,r2,255
81119b10:	10001726 	beq	r2,zero,81119b70 <bSendUART128v2+0xe4>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81119b14:	00a045f4 	movhi	r2,33047
81119b18:	10a25304 	addi	r2,r2,-30388
81119b1c:	10800a8b 	ldhu	r2,42(r2)
81119b20:	10bfffcc 	andi	r2,r2,65535
81119b24:	10800228 	cmpgeui	r2,r2,8
81119b28:	1000071e 	bne	r2,zero,81119b48 <bSendUART128v2+0xbc>
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
81119b2c:	d0a06217 	ldw	r2,-32376(gp)
81119b30:	100f883a 	mov	r7,r2
81119b34:	01801484 	movi	r6,82
81119b38:	01400044 	movi	r5,1
81119b3c:	01204574 	movhi	r4,33045
81119b40:	21013904 	addi	r4,r4,1252
81119b44:	112393c0 	call	8112393c <fwrite>
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81119b48:	d0a06317 	ldw	r2,-32372(gp)
81119b4c:	1009883a 	mov	r4,r2
81119b50:	1140ae40 	call	81140ae4 <OSSemPost>
81119b54:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81119b58:	e0bffd03 	ldbu	r2,-12(fp)
81119b5c:	10803fcc 	andi	r2,r2,255
81119b60:	10000126 	beq	r2,zero,81119b68 <bSendUART128v2+0xdc>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81119b64:	111d6fc0 	call	8111d6fc <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81119b68:	e0bffc17 	ldw	r2,-16(fp)
81119b6c:	00008a06 	br	81119d98 <bSendUART128v2+0x30c>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81119b70:	e03ffb05 	stb	zero,-20(fp)
81119b74:	00004306 	br	81119c84 <bSendUART128v2+0x1f8>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81119b78:	e0fffb03 	ldbu	r3,-20(fp)
81119b7c:	00a045b4 	movhi	r2,33046
81119b80:	10827104 	addi	r2,r2,2500
81119b84:	18c7883a 	add	r3,r3,r3
81119b88:	18c7883a 	add	r3,r3,r3
81119b8c:	10c5883a 	add	r2,r2,r3
81119b90:	10800017 	ldw	r2,0(r2)
81119b94:	1000381e 	bne	r2,zero,81119c78 <bSendUART128v2+0x1ec>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81119b98:	e0bffb03 	ldbu	r2,-20(fp)
81119b9c:	10c02324 	muli	r3,r2,140
81119ba0:	00a045b4 	movhi	r2,33046
81119ba4:	10828f04 	addi	r2,r2,2620
81119ba8:	1885883a 	add	r2,r3,r2
81119bac:	01802004 	movi	r6,128
81119bb0:	000b883a 	mov	r5,zero
81119bb4:	1009883a 	mov	r4,r2
81119bb8:	11244a00 	call	811244a0 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81119bbc:	e0bffb03 	ldbu	r2,-20(fp)
81119bc0:	10c02324 	muli	r3,r2,140
81119bc4:	00a045b4 	movhi	r2,33046
81119bc8:	10828f04 	addi	r2,r2,2620
81119bcc:	1885883a 	add	r2,r3,r2
81119bd0:	01801fc4 	movi	r6,127
81119bd4:	e17ffe17 	ldw	r5,-8(fp)
81119bd8:	1009883a 	mov	r4,r2
81119bdc:	11243500 	call	81124350 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81119be0:	e13ffb03 	ldbu	r4,-20(fp)
81119be4:	e0ffff0b 	ldhu	r3,-4(fp)
81119be8:	00a045b4 	movhi	r2,33046
81119bec:	10828f04 	addi	r2,r2,2620
81119bf0:	21002324 	muli	r4,r4,140
81119bf4:	1105883a 	add	r2,r2,r4
81119bf8:	10802104 	addi	r2,r2,132
81119bfc:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
81119c00:	e0fffb03 	ldbu	r3,-20(fp)
81119c04:	00a045b4 	movhi	r2,33046
81119c08:	10828f04 	addi	r2,r2,2620
81119c0c:	18c02324 	muli	r3,r3,140
81119c10:	10c5883a 	add	r2,r2,r3
81119c14:	10802204 	addi	r2,r2,136
81119c18:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
81119c1c:	e0fffb03 	ldbu	r3,-20(fp)
81119c20:	00a045b4 	movhi	r2,33046
81119c24:	10828f04 	addi	r2,r2,2620
81119c28:	18c02324 	muli	r3,r3,140
81119c2c:	10c5883a 	add	r2,r2,r3
81119c30:	10802184 	addi	r2,r2,134
81119c34:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
81119c38:	e0fffb03 	ldbu	r3,-20(fp)
81119c3c:	00a045b4 	movhi	r2,33046
81119c40:	10828f04 	addi	r2,r2,2620
81119c44:	18c02324 	muli	r3,r3,140
81119c48:	10c5883a 	add	r2,r2,r3
81119c4c:	10802004 	addi	r2,r2,128
81119c50:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
81119c54:	e0fffb03 	ldbu	r3,-20(fp)
81119c58:	00a045b4 	movhi	r2,33046
81119c5c:	10827104 	addi	r2,r2,2500
81119c60:	18c7883a 	add	r3,r3,r3
81119c64:	18c7883a 	add	r3,r3,r3
81119c68:	10c5883a 	add	r2,r2,r3
81119c6c:	00c00044 	movi	r3,1
81119c70:	10c00015 	stw	r3,0(r2)
			break;
81119c74:	00000606 	br	81119c90 <bSendUART128v2+0x204>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81119c78:	e0bffb03 	ldbu	r2,-20(fp)
81119c7c:	10800044 	addi	r2,r2,1
81119c80:	e0bffb05 	stb	r2,-20(fp)
81119c84:	e0bffb03 	ldbu	r2,-20(fp)
81119c88:	108001b0 	cmpltui	r2,r2,6
81119c8c:	103fba1e 	bne	r2,zero,81119b78 <__reset+0xfb0f9b78>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
81119c90:	e0bffb03 	ldbu	r2,-20(fp)
81119c94:	108001b0 	cmpltui	r2,r2,6
81119c98:	1000091e 	bne	r2,zero,81119cc0 <bSendUART128v2+0x234>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81119c9c:	d0a06317 	ldw	r2,-32372(gp)
81119ca0:	1009883a 	mov	r4,r2
81119ca4:	1140ae40 	call	81140ae4 <OSSemPost>
81119ca8:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
81119cac:	d0a06e17 	ldw	r2,-32328(gp)
81119cb0:	1009883a 	mov	r4,r2
81119cb4:	113ecf40 	call	8113ecf4 <OSMutexPost>
		return bSuccessL;
81119cb8:	e0bffc17 	ldw	r2,-16(fp)
81119cbc:	00003606 	br	81119d98 <bSendUART128v2+0x30c>
	}

	bSuccessL = TRUE;
81119cc0:	00800044 	movi	r2,1
81119cc4:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
81119cc8:	d0a07543 	ldbu	r2,-32299(gp)
81119ccc:	10bfffc4 	addi	r2,r2,-1
81119cd0:	d0a07545 	stb	r2,-32299(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81119cd4:	d0a07417 	ldw	r2,-32304(gp)
81119cd8:	e0fffd04 	addi	r3,fp,-12
81119cdc:	180d883a 	mov	r6,r3
81119ce0:	01400084 	movi	r5,2
81119ce4:	1009883a 	mov	r4,r2
81119ce8:	113e7500 	call	8113e750 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81119cec:	e0bffd03 	ldbu	r2,-12(fp)
81119cf0:	10803fcc 	andi	r2,r2,255
81119cf4:	10001226 	beq	r2,zero,81119d40 <bSendUART128v2+0x2b4>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81119cf8:	00a045f4 	movhi	r2,33047
81119cfc:	10a25304 	addi	r2,r2,-30388
81119d00:	10800a8b 	ldhu	r2,42(r2)
81119d04:	10bfffcc 	andi	r2,r2,65535
81119d08:	10800228 	cmpgeui	r2,r2,8
81119d0c:	1000071e 	bne	r2,zero,81119d2c <bSendUART128v2+0x2a0>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
81119d10:	d0a06217 	ldw	r2,-32376(gp)
81119d14:	100f883a 	mov	r7,r2
81119d18:	01801c04 	movi	r6,112
81119d1c:	01400044 	movi	r5,1
81119d20:	01204574 	movhi	r4,33045
81119d24:	21014e04 	addi	r4,r4,1336
81119d28:	112393c0 	call	8112393c <fwrite>
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81119d2c:	d0a06e17 	ldw	r2,-32328(gp)
81119d30:	1009883a 	mov	r4,r2
81119d34:	113ecf40 	call	8113ecf4 <OSMutexPost>
		return bSuccessL;
81119d38:	e0bffc17 	ldw	r2,-16(fp)
81119d3c:	00001606 	br	81119d98 <bSendUART128v2+0x30c>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
81119d40:	e0bffb03 	ldbu	r2,-20(fp)
81119d44:	10c02324 	muli	r3,r2,140
81119d48:	00a045b4 	movhi	r2,33046
81119d4c:	10828f04 	addi	r2,r2,2620
81119d50:	1885883a 	add	r2,r3,r2
81119d54:	1009883a 	mov	r4,r2
81119d58:	11248700 	call	81124870 <puts>
	xBuffer128[ucIL].bSent = TRUE;
81119d5c:	e0fffb03 	ldbu	r3,-20(fp)
81119d60:	00a045b4 	movhi	r2,33046
81119d64:	10828f04 	addi	r2,r2,2620
81119d68:	18c02324 	muli	r3,r3,140
81119d6c:	10c5883a 	add	r2,r2,r3
81119d70:	10802004 	addi	r2,r2,128
81119d74:	00c00044 	movi	r3,1
81119d78:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81119d7c:	d0a07417 	ldw	r2,-32304(gp)
81119d80:	1009883a 	mov	r4,r2
81119d84:	113ecf40 	call	8113ecf4 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81119d88:	d0a06e17 	ldw	r2,-32328(gp)
81119d8c:	1009883a 	mov	r4,r2
81119d90:	113ecf40 	call	8113ecf4 <OSMutexPost>

	return bSuccessL;
81119d94:	e0bffc17 	ldw	r2,-16(fp)
}
81119d98:	e037883a 	mov	sp,fp
81119d9c:	dfc00117 	ldw	ra,4(sp)
81119da0:	df000017 	ldw	fp,0(sp)
81119da4:	dec00204 	addi	sp,sp,8
81119da8:	f800283a 	ret

81119dac <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
81119dac:	defff904 	addi	sp,sp,-28
81119db0:	de00012e 	bgeu	sp,et,81119db8 <bSendUART64v2+0xc>
81119db4:	003b68fa 	trap	3
81119db8:	dfc00615 	stw	ra,24(sp)
81119dbc:	df000515 	stw	fp,20(sp)
81119dc0:	df000504 	addi	fp,sp,20
81119dc4:	e13ffe15 	stw	r4,-8(fp)
81119dc8:	2805883a 	mov	r2,r5
81119dcc:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81119dd0:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81119dd4:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81119dd8:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81119ddc:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81119de0:	d0a05e17 	ldw	r2,-32392(gp)
81119de4:	e0fffd04 	addi	r3,fp,-12
81119de8:	180d883a 	mov	r6,r3
81119dec:	01400504 	movi	r5,20
81119df0:	1009883a 	mov	r4,r2
81119df4:	114075c0 	call	8114075c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81119df8:	e0bffd03 	ldbu	r2,-12(fp)
81119dfc:	10803fcc 	andi	r2,r2,255
81119e00:	10000326 	beq	r2,zero,81119e10 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81119e04:	111d7fc0 	call	8111d7fc <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
81119e08:	e0bffc17 	ldw	r2,-16(fp)
81119e0c:	0000ac06 	br	8111a0c0 <bSendUART64v2+0x314>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81119e10:	d0a07117 	ldw	r2,-32316(gp)
81119e14:	e0fffd04 	addi	r3,fp,-12
81119e18:	180d883a 	mov	r6,r3
81119e1c:	01400104 	movi	r5,4
81119e20:	1009883a 	mov	r4,r2
81119e24:	113e7500 	call	8113e750 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81119e28:	e0bffd03 	ldbu	r2,-12(fp)
81119e2c:	10803fcc 	andi	r2,r2,255
81119e30:	10001726 	beq	r2,zero,81119e90 <bSendUART64v2+0xe4>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81119e34:	00a045f4 	movhi	r2,33047
81119e38:	10a25304 	addi	r2,r2,-30388
81119e3c:	10800a8b 	ldhu	r2,42(r2)
81119e40:	10bfffcc 	andi	r2,r2,65535
81119e44:	10800228 	cmpgeui	r2,r2,8
81119e48:	1000071e 	bne	r2,zero,81119e68 <bSendUART64v2+0xbc>
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
81119e4c:	d0a06217 	ldw	r2,-32376(gp)
81119e50:	100f883a 	mov	r7,r2
81119e54:	018013c4 	movi	r6,79
81119e58:	01400044 	movi	r5,1
81119e5c:	01204574 	movhi	r4,33045
81119e60:	21016b04 	addi	r4,r4,1452
81119e64:	112393c0 	call	8112393c <fwrite>
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81119e68:	d0a05e17 	ldw	r2,-32392(gp)
81119e6c:	1009883a 	mov	r4,r2
81119e70:	1140ae40 	call	81140ae4 <OSSemPost>
81119e74:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81119e78:	e0bffd03 	ldbu	r2,-12(fp)
81119e7c:	10803fcc 	andi	r2,r2,255
81119e80:	10000126 	beq	r2,zero,81119e88 <bSendUART64v2+0xdc>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81119e84:	111d67c0 	call	8111d67c <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81119e88:	e0bffc17 	ldw	r2,-16(fp)
81119e8c:	00008c06 	br	8111a0c0 <bSendUART64v2+0x314>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81119e90:	e03ffb05 	stb	zero,-20(fp)
81119e94:	00004506 	br	81119fac <bSendUART64v2+0x200>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81119e98:	e0fffb03 	ldbu	r3,-20(fp)
81119e9c:	00a045b4 	movhi	r2,33046
81119ea0:	10827104 	addi	r2,r2,2500
81119ea4:	18c00184 	addi	r3,r3,6
81119ea8:	18c7883a 	add	r3,r3,r3
81119eac:	18c7883a 	add	r3,r3,r3
81119eb0:	10c5883a 	add	r2,r2,r3
81119eb4:	10800017 	ldw	r2,0(r2)
81119eb8:	1000391e 	bne	r2,zero,81119fa0 <bSendUART64v2+0x1f4>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81119ebc:	e0bffb03 	ldbu	r2,-20(fp)
81119ec0:	10c01324 	muli	r3,r2,76
81119ec4:	00a04574 	movhi	r2,33045
81119ec8:	109e3304 	addi	r2,r2,30924
81119ecc:	1885883a 	add	r2,r3,r2
81119ed0:	01801004 	movi	r6,64
81119ed4:	000b883a 	mov	r5,zero
81119ed8:	1009883a 	mov	r4,r2
81119edc:	11244a00 	call	811244a0 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
81119ee0:	e0bffb03 	ldbu	r2,-20(fp)
81119ee4:	10c01324 	muli	r3,r2,76
81119ee8:	00a04574 	movhi	r2,33045
81119eec:	109e3304 	addi	r2,r2,30924
81119ef0:	1885883a 	add	r2,r3,r2
81119ef4:	01800fc4 	movi	r6,63
81119ef8:	e17ffe17 	ldw	r5,-8(fp)
81119efc:	1009883a 	mov	r4,r2
81119f00:	11243500 	call	81124350 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
81119f04:	e13ffb03 	ldbu	r4,-20(fp)
81119f08:	e0ffff0b 	ldhu	r3,-4(fp)
81119f0c:	00a04574 	movhi	r2,33045
81119f10:	109e3304 	addi	r2,r2,30924
81119f14:	21001324 	muli	r4,r4,76
81119f18:	1105883a 	add	r2,r2,r4
81119f1c:	10801104 	addi	r2,r2,68
81119f20:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
81119f24:	e0fffb03 	ldbu	r3,-20(fp)
81119f28:	00a04574 	movhi	r2,33045
81119f2c:	109e3304 	addi	r2,r2,30924
81119f30:	18c01324 	muli	r3,r3,76
81119f34:	10c5883a 	add	r2,r2,r3
81119f38:	10801204 	addi	r2,r2,72
81119f3c:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
81119f40:	e0fffb03 	ldbu	r3,-20(fp)
81119f44:	00a04574 	movhi	r2,33045
81119f48:	109e3304 	addi	r2,r2,30924
81119f4c:	18c01324 	muli	r3,r3,76
81119f50:	10c5883a 	add	r2,r2,r3
81119f54:	10801184 	addi	r2,r2,70
81119f58:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
81119f5c:	e0fffb03 	ldbu	r3,-20(fp)
81119f60:	00a04574 	movhi	r2,33045
81119f64:	109e3304 	addi	r2,r2,30924
81119f68:	18c01324 	muli	r3,r3,76
81119f6c:	10c5883a 	add	r2,r2,r3
81119f70:	10801004 	addi	r2,r2,64
81119f74:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81119f78:	e0fffb03 	ldbu	r3,-20(fp)
81119f7c:	00a045b4 	movhi	r2,33046
81119f80:	10827104 	addi	r2,r2,2500
81119f84:	18c00184 	addi	r3,r3,6
81119f88:	18c7883a 	add	r3,r3,r3
81119f8c:	18c7883a 	add	r3,r3,r3
81119f90:	10c5883a 	add	r2,r2,r3
81119f94:	00c00044 	movi	r3,1
81119f98:	10c00015 	stw	r3,0(r2)
			break;
81119f9c:	00000606 	br	81119fb8 <bSendUART64v2+0x20c>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81119fa0:	e0bffb03 	ldbu	r2,-20(fp)
81119fa4:	10800044 	addi	r2,r2,1
81119fa8:	e0bffb05 	stb	r2,-20(fp)
81119fac:	e0bffb03 	ldbu	r2,-20(fp)
81119fb0:	10800230 	cmpltui	r2,r2,8
81119fb4:	103fb81e 	bne	r2,zero,81119e98 <__reset+0xfb0f9e98>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81119fb8:	e0bffb03 	ldbu	r2,-20(fp)
81119fbc:	10800230 	cmpltui	r2,r2,8
81119fc0:	1000091e 	bne	r2,zero,81119fe8 <bSendUART64v2+0x23c>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81119fc4:	d0a05e17 	ldw	r2,-32392(gp)
81119fc8:	1009883a 	mov	r4,r2
81119fcc:	1140ae40 	call	81140ae4 <OSSemPost>
81119fd0:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
81119fd4:	d0a07117 	ldw	r2,-32316(gp)
81119fd8:	1009883a 	mov	r4,r2
81119fdc:	113ecf40 	call	8113ecf4 <OSMutexPost>
		return bSuccessL;
81119fe0:	e0bffc17 	ldw	r2,-16(fp)
81119fe4:	00003606 	br	8111a0c0 <bSendUART64v2+0x314>
	}

	bSuccessL = TRUE;
81119fe8:	00800044 	movi	r2,1
81119fec:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
81119ff0:	d0a07503 	ldbu	r2,-32300(gp)
81119ff4:	10bfffc4 	addi	r2,r2,-1
81119ff8:	d0a07505 	stb	r2,-32300(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81119ffc:	d0a07417 	ldw	r2,-32304(gp)
8111a000:	e0fffd04 	addi	r3,fp,-12
8111a004:	180d883a 	mov	r6,r3
8111a008:	01400084 	movi	r5,2
8111a00c:	1009883a 	mov	r4,r2
8111a010:	113e7500 	call	8113e750 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111a014:	e0bffd03 	ldbu	r2,-12(fp)
8111a018:	10803fcc 	andi	r2,r2,255
8111a01c:	10001226 	beq	r2,zero,8111a068 <bSendUART64v2+0x2bc>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111a020:	00a045f4 	movhi	r2,33047
8111a024:	10a25304 	addi	r2,r2,-30388
8111a028:	10800a8b 	ldhu	r2,42(r2)
8111a02c:	10bfffcc 	andi	r2,r2,65535
8111a030:	10800228 	cmpgeui	r2,r2,8
8111a034:	1000071e 	bne	r2,zero,8111a054 <bSendUART64v2+0x2a8>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
8111a038:	d0a06217 	ldw	r2,-32376(gp)
8111a03c:	100f883a 	mov	r7,r2
8111a040:	01801bc4 	movi	r6,111
8111a044:	01400044 	movi	r5,1
8111a048:	01204574 	movhi	r4,33045
8111a04c:	21017f04 	addi	r4,r4,1532
8111a050:	112393c0 	call	8112393c <fwrite>
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
8111a054:	d0a07117 	ldw	r2,-32316(gp)
8111a058:	1009883a 	mov	r4,r2
8111a05c:	113ecf40 	call	8113ecf4 <OSMutexPost>
		return bSuccessL;
8111a060:	e0bffc17 	ldw	r2,-16(fp)
8111a064:	00001606 	br	8111a0c0 <bSendUART64v2+0x314>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
8111a068:	e0bffb03 	ldbu	r2,-20(fp)
8111a06c:	10c01324 	muli	r3,r2,76
8111a070:	00a04574 	movhi	r2,33045
8111a074:	109e3304 	addi	r2,r2,30924
8111a078:	1885883a 	add	r2,r3,r2
8111a07c:	1009883a 	mov	r4,r2
8111a080:	11248700 	call	81124870 <puts>
	xBuffer64[ucIL].bSent = TRUE;
8111a084:	e0fffb03 	ldbu	r3,-20(fp)
8111a088:	00a04574 	movhi	r2,33045
8111a08c:	109e3304 	addi	r2,r2,30924
8111a090:	18c01324 	muli	r3,r3,76
8111a094:	10c5883a 	add	r2,r2,r3
8111a098:	10801004 	addi	r2,r2,64
8111a09c:	00c00044 	movi	r3,1
8111a0a0:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
8111a0a4:	d0a07417 	ldw	r2,-32304(gp)
8111a0a8:	1009883a 	mov	r4,r2
8111a0ac:	113ecf40 	call	8113ecf4 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
8111a0b0:	d0a07117 	ldw	r2,-32316(gp)
8111a0b4:	1009883a 	mov	r4,r2
8111a0b8:	113ecf40 	call	8113ecf4 <OSMutexPost>

	return bSuccessL;
8111a0bc:	e0bffc17 	ldw	r2,-16(fp)
}
8111a0c0:	e037883a 	mov	sp,fp
8111a0c4:	dfc00117 	ldw	ra,4(sp)
8111a0c8:	df000017 	ldw	fp,0(sp)
8111a0cc:	dec00204 	addi	sp,sp,8
8111a0d0:	f800283a 	ret

8111a0d4 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
8111a0d4:	defff904 	addi	sp,sp,-28
8111a0d8:	de00012e 	bgeu	sp,et,8111a0e0 <bSendUART32v2+0xc>
8111a0dc:	003b68fa 	trap	3
8111a0e0:	dfc00615 	stw	ra,24(sp)
8111a0e4:	df000515 	stw	fp,20(sp)
8111a0e8:	df000504 	addi	fp,sp,20
8111a0ec:	e13ffe15 	stw	r4,-8(fp)
8111a0f0:	2805883a 	mov	r2,r5
8111a0f4:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
8111a0f8:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8111a0fc:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8111a100:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8111a104:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8111a108:	d0a06f17 	ldw	r2,-32324(gp)
8111a10c:	e0fffd04 	addi	r3,fp,-12
8111a110:	180d883a 	mov	r6,r3
8111a114:	01400504 	movi	r5,20
8111a118:	1009883a 	mov	r4,r2
8111a11c:	114075c0 	call	8114075c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8111a120:	e0bffd03 	ldbu	r2,-12(fp)
8111a124:	10803fcc 	andi	r2,r2,255
8111a128:	10000326 	beq	r2,zero,8111a138 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8111a12c:	111d87c0 	call	8111d87c <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
8111a130:	e0bffc17 	ldw	r2,-16(fp)
8111a134:	0000ac06 	br	8111a3e8 <bSendUART32v2+0x314>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8111a138:	d0a06c17 	ldw	r2,-32336(gp)
8111a13c:	e0fffd04 	addi	r3,fp,-12
8111a140:	180d883a 	mov	r6,r3
8111a144:	01400104 	movi	r5,4
8111a148:	1009883a 	mov	r4,r2
8111a14c:	113e7500 	call	8113e750 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111a150:	e0bffd03 	ldbu	r2,-12(fp)
8111a154:	10803fcc 	andi	r2,r2,255
8111a158:	10001726 	beq	r2,zero,8111a1b8 <bSendUART32v2+0xe4>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111a15c:	00a045f4 	movhi	r2,33047
8111a160:	10a25304 	addi	r2,r2,-30388
8111a164:	10800a8b 	ldhu	r2,42(r2)
8111a168:	10bfffcc 	andi	r2,r2,65535
8111a16c:	10800228 	cmpgeui	r2,r2,8
8111a170:	1000071e 	bne	r2,zero,8111a190 <bSendUART32v2+0xbc>
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
8111a174:	d0a06217 	ldw	r2,-32376(gp)
8111a178:	100f883a 	mov	r7,r2
8111a17c:	018013c4 	movi	r6,79
8111a180:	01400044 	movi	r5,1
8111a184:	01204574 	movhi	r4,33045
8111a188:	21019b04 	addi	r4,r4,1644
8111a18c:	112393c0 	call	8112393c <fwrite>
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
8111a190:	d0a06f17 	ldw	r2,-32324(gp)
8111a194:	1009883a 	mov	r4,r2
8111a198:	1140ae40 	call	81140ae4 <OSSemPost>
8111a19c:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
8111a1a0:	e0bffd03 	ldbu	r2,-12(fp)
8111a1a4:	10803fcc 	andi	r2,r2,255
8111a1a8:	10000126 	beq	r2,zero,8111a1b0 <bSendUART32v2+0xdc>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8111a1ac:	111d5fc0 	call	8111d5fc <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
8111a1b0:	e0bffc17 	ldw	r2,-16(fp)
8111a1b4:	00008c06 	br	8111a3e8 <bSendUART32v2+0x314>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
8111a1b8:	e03ffb05 	stb	zero,-20(fp)
8111a1bc:	00004506 	br	8111a2d4 <bSendUART32v2+0x200>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
8111a1c0:	e0fffb03 	ldbu	r3,-20(fp)
8111a1c4:	00a045b4 	movhi	r2,33046
8111a1c8:	10827104 	addi	r2,r2,2500
8111a1cc:	18c00384 	addi	r3,r3,14
8111a1d0:	18c7883a 	add	r3,r3,r3
8111a1d4:	18c7883a 	add	r3,r3,r3
8111a1d8:	10c5883a 	add	r2,r2,r3
8111a1dc:	10800017 	ldw	r2,0(r2)
8111a1e0:	1000391e 	bne	r2,zero,8111a2c8 <bSendUART32v2+0x1f4>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
8111a1e4:	e0bffb03 	ldbu	r2,-20(fp)
8111a1e8:	10c00b24 	muli	r3,r2,44
8111a1ec:	00a045b4 	movhi	r2,33046
8111a1f0:	10aff104 	addi	r2,r2,-16444
8111a1f4:	1885883a 	add	r2,r3,r2
8111a1f8:	01800804 	movi	r6,32
8111a1fc:	000b883a 	mov	r5,zero
8111a200:	1009883a 	mov	r4,r2
8111a204:	11244a00 	call	811244a0 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
8111a208:	e0bffb03 	ldbu	r2,-20(fp)
8111a20c:	10c00b24 	muli	r3,r2,44
8111a210:	00a045b4 	movhi	r2,33046
8111a214:	10aff104 	addi	r2,r2,-16444
8111a218:	1885883a 	add	r2,r3,r2
8111a21c:	018007c4 	movi	r6,31
8111a220:	e17ffe17 	ldw	r5,-8(fp)
8111a224:	1009883a 	mov	r4,r2
8111a228:	11243500 	call	81124350 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
8111a22c:	e13ffb03 	ldbu	r4,-20(fp)
8111a230:	e0ffff0b 	ldhu	r3,-4(fp)
8111a234:	00a045b4 	movhi	r2,33046
8111a238:	10aff104 	addi	r2,r2,-16444
8111a23c:	21000b24 	muli	r4,r4,44
8111a240:	1105883a 	add	r2,r2,r4
8111a244:	10800904 	addi	r2,r2,36
8111a248:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
8111a24c:	e0fffb03 	ldbu	r3,-20(fp)
8111a250:	00a045b4 	movhi	r2,33046
8111a254:	10aff104 	addi	r2,r2,-16444
8111a258:	18c00b24 	muli	r3,r3,44
8111a25c:	10c5883a 	add	r2,r2,r3
8111a260:	10800a04 	addi	r2,r2,40
8111a264:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
8111a268:	e0fffb03 	ldbu	r3,-20(fp)
8111a26c:	00a045b4 	movhi	r2,33046
8111a270:	10aff104 	addi	r2,r2,-16444
8111a274:	18c00b24 	muli	r3,r3,44
8111a278:	10c5883a 	add	r2,r2,r3
8111a27c:	10800984 	addi	r2,r2,38
8111a280:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
8111a284:	e0fffb03 	ldbu	r3,-20(fp)
8111a288:	00a045b4 	movhi	r2,33046
8111a28c:	10aff104 	addi	r2,r2,-16444
8111a290:	18c00b24 	muli	r3,r3,44
8111a294:	10c5883a 	add	r2,r2,r3
8111a298:	10800804 	addi	r2,r2,32
8111a29c:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
8111a2a0:	e0fffb03 	ldbu	r3,-20(fp)
8111a2a4:	00a045b4 	movhi	r2,33046
8111a2a8:	10827104 	addi	r2,r2,2500
8111a2ac:	18c00384 	addi	r3,r3,14
8111a2b0:	18c7883a 	add	r3,r3,r3
8111a2b4:	18c7883a 	add	r3,r3,r3
8111a2b8:	10c5883a 	add	r2,r2,r3
8111a2bc:	00c00044 	movi	r3,1
8111a2c0:	10c00015 	stw	r3,0(r2)
			break;
8111a2c4:	00000606 	br	8111a2e0 <bSendUART32v2+0x20c>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
8111a2c8:	e0bffb03 	ldbu	r2,-20(fp)
8111a2cc:	10800044 	addi	r2,r2,1
8111a2d0:	e0bffb05 	stb	r2,-20(fp)
8111a2d4:	e0bffb03 	ldbu	r2,-20(fp)
8111a2d8:	10800230 	cmpltui	r2,r2,8
8111a2dc:	103fb81e 	bne	r2,zero,8111a1c0 <__reset+0xfb0fa1c0>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
8111a2e0:	e0bffb03 	ldbu	r2,-20(fp)
8111a2e4:	10800230 	cmpltui	r2,r2,8
8111a2e8:	1000091e 	bne	r2,zero,8111a310 <bSendUART32v2+0x23c>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
8111a2ec:	d0a06f17 	ldw	r2,-32324(gp)
8111a2f0:	1009883a 	mov	r4,r2
8111a2f4:	1140ae40 	call	81140ae4 <OSSemPost>
8111a2f8:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
8111a2fc:	d0a06c17 	ldw	r2,-32336(gp)
8111a300:	1009883a 	mov	r4,r2
8111a304:	113ecf40 	call	8113ecf4 <OSMutexPost>
		return bSuccessL;
8111a308:	e0bffc17 	ldw	r2,-16(fp)
8111a30c:	00003606 	br	8111a3e8 <bSendUART32v2+0x314>
	}
	
	bSuccessL = TRUE;
8111a310:	00800044 	movi	r2,1
8111a314:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
8111a318:	d0a06883 	ldbu	r2,-32350(gp)
8111a31c:	10bfffc4 	addi	r2,r2,-1
8111a320:	d0a06885 	stb	r2,-32350(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8111a324:	d0a07417 	ldw	r2,-32304(gp)
8111a328:	e0fffd04 	addi	r3,fp,-12
8111a32c:	180d883a 	mov	r6,r3
8111a330:	01400084 	movi	r5,2
8111a334:	1009883a 	mov	r4,r2
8111a338:	113e7500 	call	8113e750 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111a33c:	e0bffd03 	ldbu	r2,-12(fp)
8111a340:	10803fcc 	andi	r2,r2,255
8111a344:	10001226 	beq	r2,zero,8111a390 <bSendUART32v2+0x2bc>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111a348:	00a045f4 	movhi	r2,33047
8111a34c:	10a25304 	addi	r2,r2,-30388
8111a350:	10800a8b 	ldhu	r2,42(r2)
8111a354:	10bfffcc 	andi	r2,r2,65535
8111a358:	10800228 	cmpgeui	r2,r2,8
8111a35c:	1000071e 	bne	r2,zero,8111a37c <bSendUART32v2+0x2a8>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
8111a360:	d0a06217 	ldw	r2,-32376(gp)
8111a364:	100f883a 	mov	r7,r2
8111a368:	01801bc4 	movi	r6,111
8111a36c:	01400044 	movi	r5,1
8111a370:	01204574 	movhi	r4,33045
8111a374:	2101af04 	addi	r4,r4,1724
8111a378:	112393c0 	call	8112393c <fwrite>
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
8111a37c:	d0a06c17 	ldw	r2,-32336(gp)
8111a380:	1009883a 	mov	r4,r2
8111a384:	113ecf40 	call	8113ecf4 <OSMutexPost>
		return bSuccessL;
8111a388:	e0bffc17 	ldw	r2,-16(fp)
8111a38c:	00001606 	br	8111a3e8 <bSendUART32v2+0x314>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
8111a390:	e0bffb03 	ldbu	r2,-20(fp)
8111a394:	10c00b24 	muli	r3,r2,44
8111a398:	00a045b4 	movhi	r2,33046
8111a39c:	10aff104 	addi	r2,r2,-16444
8111a3a0:	1885883a 	add	r2,r3,r2
8111a3a4:	1009883a 	mov	r4,r2
8111a3a8:	11248700 	call	81124870 <puts>
	xBuffer32[ucIL].bSent = TRUE;
8111a3ac:	e0fffb03 	ldbu	r3,-20(fp)
8111a3b0:	00a045b4 	movhi	r2,33046
8111a3b4:	10aff104 	addi	r2,r2,-16444
8111a3b8:	18c00b24 	muli	r3,r3,44
8111a3bc:	10c5883a 	add	r2,r2,r3
8111a3c0:	10800804 	addi	r2,r2,32
8111a3c4:	00c00044 	movi	r3,1
8111a3c8:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
8111a3cc:	d0a07417 	ldw	r2,-32304(gp)
8111a3d0:	1009883a 	mov	r4,r2
8111a3d4:	113ecf40 	call	8113ecf4 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
8111a3d8:	d0a06c17 	ldw	r2,-32336(gp)
8111a3dc:	1009883a 	mov	r4,r2
8111a3e0:	113ecf40 	call	8113ecf4 <OSMutexPost>

	return bSuccessL;
8111a3e4:	e0bffc17 	ldw	r2,-16(fp)
}
8111a3e8:	e037883a 	mov	sp,fp
8111a3ec:	dfc00117 	ldw	ra,4(sp)
8111a3f0:	df000017 	ldw	fp,0(sp)
8111a3f4:	dec00204 	addi	sp,sp,8
8111a3f8:	f800283a 	ret

8111a3fc <vSendEthConf>:


void vSendEthConf ( void ) {
8111a3fc:	deffc304 	addi	sp,sp,-244
8111a400:	de00012e 	bgeu	sp,et,8111a408 <vSendEthConf+0xc>
8111a404:	003b68fa 	trap	3
8111a408:	dfc03c15 	stw	ra,240(sp)
8111a40c:	df003b15 	stw	fp,236(sp)
8111a410:	dd403a15 	stw	r21,232(sp)
8111a414:	dd003915 	stw	r20,228(sp)
8111a418:	dcc03815 	stw	r19,224(sp)
8111a41c:	dc803715 	stw	r18,220(sp)
8111a420:	dc403615 	stw	r17,216(sp)
8111a424:	dc003515 	stw	r16,212(sp)
8111a428:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
8111a42c:	e03fd98d 	sth	zero,-154(fp)
8111a430:	e03fda0d 	sth	zero,-152(fp)
8111a434:	e0bfda84 	addi	r2,fp,-150
8111a438:	00c01f04 	movi	r3,124
8111a43c:	180d883a 	mov	r6,r3
8111a440:	000b883a 	mov	r5,zero
8111a444:	1009883a 	mov	r4,r2
8111a448:	11244a00 	call	811244a0 <memset>
    unsigned char crc = 0;
8111a44c:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a450:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a454:	111a9bc0 	call	8111a9bc <usiGetIdCMD>
8111a458:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a45c:	e57fd90b 	ldhu	r21,-156(fp)
8111a460:	00a045f4 	movhi	r2,33047
8111a464:	10a26004 	addi	r2,r2,-30336
8111a468:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8111a46c:	00a045f4 	movhi	r2,33047
8111a470:	10a26004 	addi	r2,r2,-30336
8111a474:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a478:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8111a47c:	00a045f4 	movhi	r2,33047
8111a480:	10a26004 	addi	r2,r2,-30336
8111a484:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a488:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8111a48c:	00a045f4 	movhi	r2,33047
8111a490:	10a26004 	addi	r2,r2,-30336
8111a494:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a498:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8111a49c:	00a045f4 	movhi	r2,33047
8111a4a0:	10a26004 	addi	r2,r2,-30336
8111a4a4:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a4a8:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8111a4ac:	00a045f4 	movhi	r2,33047
8111a4b0:	10a26004 	addi	r2,r2,-30336
8111a4b4:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a4b8:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8111a4bc:	00a045f4 	movhi	r2,33047
8111a4c0:	10a26004 	addi	r2,r2,-30336
8111a4c4:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a4c8:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8111a4cc:	00a045f4 	movhi	r2,33047
8111a4d0:	10a26004 	addi	r2,r2,-30336
8111a4d4:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a4d8:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8111a4dc:	00a045f4 	movhi	r2,33047
8111a4e0:	10a26004 	addi	r2,r2,-30336
8111a4e4:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a4e8:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111a4ec:	00a045f4 	movhi	r2,33047
8111a4f0:	10a26004 	addi	r2,r2,-30336
8111a4f4:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a4f8:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111a4fc:	00a045f4 	movhi	r2,33047
8111a500:	10a26004 	addi	r2,r2,-30336
8111a504:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a508:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111a50c:	00a045f4 	movhi	r2,33047
8111a510:	10a26004 	addi	r2,r2,-30336
8111a514:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a518:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111a51c:	00a045f4 	movhi	r2,33047
8111a520:	10a26004 	addi	r2,r2,-30336
8111a524:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a528:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111a52c:	00a045f4 	movhi	r2,33047
8111a530:	10a26004 	addi	r2,r2,-30336
8111a534:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a538:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111a53c:	00a045f4 	movhi	r2,33047
8111a540:	10a26004 	addi	r2,r2,-30336
8111a544:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a548:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111a54c:	00a045f4 	movhi	r2,33047
8111a550:	10a26004 	addi	r2,r2,-30336
8111a554:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a558:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111a55c:	00a045f4 	movhi	r2,33047
8111a560:	10a26004 	addi	r2,r2,-30336
8111a564:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a568:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
8111a56c:	00a045f4 	movhi	r2,33047
8111a570:	10a26004 	addi	r2,r2,-30336
8111a574:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111a578:	10bfffcc 	andi	r2,r2,65535
8111a57c:	e53fd984 	addi	r20,fp,-154
8111a580:	d8801115 	stw	r2,68(sp)
8111a584:	dcc01015 	stw	r19,64(sp)
8111a588:	dc800f15 	stw	r18,60(sp)
8111a58c:	dc400e15 	stw	r17,56(sp)
8111a590:	dc000d15 	stw	r16,52(sp)
8111a594:	dbc00c15 	stw	r15,48(sp)
8111a598:	db800b15 	stw	r14,44(sp)
8111a59c:	db400a15 	stw	r13,40(sp)
8111a5a0:	db000915 	stw	r12,36(sp)
8111a5a4:	dac00815 	stw	r11,32(sp)
8111a5a8:	da800715 	stw	r10,28(sp)
8111a5ac:	da400615 	stw	r9,24(sp)
8111a5b0:	da000515 	stw	r8,20(sp)
8111a5b4:	d9c00415 	stw	r7,16(sp)
8111a5b8:	d9800315 	stw	r6,12(sp)
8111a5bc:	d9400215 	stw	r5,8(sp)
8111a5c0:	d9000115 	stw	r4,4(sp)
8111a5c4:	d8c00015 	stw	r3,0(sp)
8111a5c8:	a80f883a 	mov	r7,r21
8111a5cc:	018010c4 	movi	r6,67
8111a5d0:	01604574 	movhi	r5,33045
8111a5d4:	2941cb04 	addi	r5,r5,1836
8111a5d8:	a009883a 	mov	r4,r20
8111a5dc:	1124bb40 	call	81124bb4 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
8111a5e0:	e0bfd984 	addi	r2,fp,-154
8111a5e4:	1009883a 	mov	r4,r2
8111a5e8:	1124dc80 	call	81124dc8 <strlen>
8111a5ec:	1007883a 	mov	r3,r2
8111a5f0:	e0bfd984 	addi	r2,fp,-154
8111a5f4:	180b883a 	mov	r5,r3
8111a5f8:	1009883a 	mov	r4,r2
8111a5fc:	111cc8c0 	call	8111cc8c <ucCrc8wInit>
8111a600:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
8111a604:	e13fd703 	ldbu	r4,-164(fp)
8111a608:	e0ffd984 	addi	r3,fp,-154
8111a60c:	e0bfd984 	addi	r2,fp,-154
8111a610:	200f883a 	mov	r7,r4
8111a614:	180d883a 	mov	r6,r3
8111a618:	01604574 	movhi	r5,33045
8111a61c:	2941e304 	addi	r5,r5,1932
8111a620:	1009883a 	mov	r4,r2
8111a624:	1124bb40 	call	81124bb4 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
8111a628:	e0bfd90b 	ldhu	r2,-156(fp)
8111a62c:	10ffffcc 	andi	r3,r2,65535
8111a630:	18e0001c 	xori	r3,r3,32768
8111a634:	18e00004 	addi	r3,r3,-32768
8111a638:	e0bfd984 	addi	r2,fp,-154
8111a63c:	180b883a 	mov	r5,r3
8111a640:	1009883a 	mov	r4,r2
8111a644:	1119a8c0 	call	81119a8c <bSendUART128v2>
8111a648:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
8111a64c:	e0bfd817 	ldw	r2,-160(fp)
8111a650:	10800060 	cmpeqi	r2,r2,1
8111a654:	1000011e 	bne	r2,zero,8111a65c <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
8111a658:	111dafc0 	call	8111dafc <vCouldNotSendEthConfUART>
	}
}
8111a65c:	0001883a 	nop
8111a660:	e6fffa04 	addi	sp,fp,-24
8111a664:	dfc00717 	ldw	ra,28(sp)
8111a668:	df000617 	ldw	fp,24(sp)
8111a66c:	dd400517 	ldw	r21,20(sp)
8111a670:	dd000417 	ldw	r20,16(sp)
8111a674:	dcc00317 	ldw	r19,12(sp)
8111a678:	dc800217 	ldw	r18,8(sp)
8111a67c:	dc400117 	ldw	r17,4(sp)
8111a680:	dc000017 	ldw	r16,0(sp)
8111a684:	dec00804 	addi	sp,sp,32
8111a688:	f800283a 	ret

8111a68c <vSendTurnOff>:


void vSendTurnOff ( void ) {
8111a68c:	defff304 	addi	sp,sp,-52
8111a690:	de00012e 	bgeu	sp,et,8111a698 <vSendTurnOff+0xc>
8111a694:	003b68fa 	trap	3
8111a698:	dfc00c15 	stw	ra,48(sp)
8111a69c:	df000b15 	stw	fp,44(sp)
8111a6a0:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
8111a6a4:	e03ff78d 	sth	zero,-34(fp)
8111a6a8:	e03ff80d 	sth	zero,-32(fp)
8111a6ac:	e03ff88d 	sth	zero,-30(fp)
8111a6b0:	e03ff90d 	sth	zero,-28(fp)
8111a6b4:	e03ff98d 	sth	zero,-26(fp)
8111a6b8:	e03ffa0d 	sth	zero,-24(fp)
8111a6bc:	e03ffa8d 	sth	zero,-22(fp)
8111a6c0:	e03ffb0d 	sth	zero,-20(fp)
8111a6c4:	e03ffb8d 	sth	zero,-18(fp)
8111a6c8:	e03ffc0d 	sth	zero,-16(fp)
8111a6cc:	e03ffc8d 	sth	zero,-14(fp)
8111a6d0:	e03ffd0d 	sth	zero,-12(fp)
8111a6d4:	e03ffd8d 	sth	zero,-10(fp)
8111a6d8:	e03ffe0d 	sth	zero,-8(fp)
8111a6dc:	e03ffe8d 	sth	zero,-6(fp)
8111a6e0:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8111a6e4:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a6e8:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a6ec:	111a9bc0 	call	8111a9bc <usiGetIdCMD>
8111a6f0:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
8111a6f4:	e0fff70b 	ldhu	r3,-36(fp)
8111a6f8:	e0bff784 	addi	r2,fp,-34
8111a6fc:	180d883a 	mov	r6,r3
8111a700:	01604574 	movhi	r5,33045
8111a704:	2941e604 	addi	r5,r5,1944
8111a708:	1009883a 	mov	r4,r2
8111a70c:	1124bb40 	call	81124bb4 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8111a710:	e0bff784 	addi	r2,fp,-34
8111a714:	1009883a 	mov	r4,r2
8111a718:	1124dc80 	call	81124dc8 <strlen>
8111a71c:	1007883a 	mov	r3,r2
8111a720:	e0bff784 	addi	r2,fp,-34
8111a724:	180b883a 	mov	r5,r3
8111a728:	1009883a 	mov	r4,r2
8111a72c:	111cc8c0 	call	8111cc8c <ucCrc8wInit>
8111a730:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8111a734:	e13ff503 	ldbu	r4,-44(fp)
8111a738:	e0fff784 	addi	r3,fp,-34
8111a73c:	e0bff784 	addi	r2,fp,-34
8111a740:	200f883a 	mov	r7,r4
8111a744:	180d883a 	mov	r6,r3
8111a748:	01604574 	movhi	r5,33045
8111a74c:	2941e304 	addi	r5,r5,1932
8111a750:	1009883a 	mov	r4,r2
8111a754:	1124bb40 	call	81124bb4 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8111a758:	e0bff70b 	ldhu	r2,-36(fp)
8111a75c:	10ffffcc 	andi	r3,r2,65535
8111a760:	18e0001c 	xori	r3,r3,32768
8111a764:	18e00004 	addi	r3,r3,-32768
8111a768:	e0bff784 	addi	r2,fp,-34
8111a76c:	180b883a 	mov	r5,r3
8111a770:	1009883a 	mov	r4,r2
8111a774:	111a0d40 	call	8111a0d4 <bSendUART32v2>
8111a778:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8111a77c:	e0bff617 	ldw	r2,-40(fp)
8111a780:	10800060 	cmpeqi	r2,r2,1
8111a784:	1000011e 	bne	r2,zero,8111a78c <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111a788:	111e3540 	call	8111e354 <vCouldNotSendTurnOff>
	}
}
8111a78c:	0001883a 	nop
8111a790:	e037883a 	mov	sp,fp
8111a794:	dfc00117 	ldw	ra,4(sp)
8111a798:	df000017 	ldw	fp,0(sp)
8111a79c:	dec00204 	addi	sp,sp,8
8111a7a0:	f800283a 	ret

8111a7a4 <vSendReset>:

void vSendReset ( void ) {
8111a7a4:	defff304 	addi	sp,sp,-52
8111a7a8:	de00012e 	bgeu	sp,et,8111a7b0 <vSendReset+0xc>
8111a7ac:	003b68fa 	trap	3
8111a7b0:	dfc00c15 	stw	ra,48(sp)
8111a7b4:	df000b15 	stw	fp,44(sp)
8111a7b8:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
8111a7bc:	e03ff78d 	sth	zero,-34(fp)
8111a7c0:	e03ff80d 	sth	zero,-32(fp)
8111a7c4:	e03ff88d 	sth	zero,-30(fp)
8111a7c8:	e03ff90d 	sth	zero,-28(fp)
8111a7cc:	e03ff98d 	sth	zero,-26(fp)
8111a7d0:	e03ffa0d 	sth	zero,-24(fp)
8111a7d4:	e03ffa8d 	sth	zero,-22(fp)
8111a7d8:	e03ffb0d 	sth	zero,-20(fp)
8111a7dc:	e03ffb8d 	sth	zero,-18(fp)
8111a7e0:	e03ffc0d 	sth	zero,-16(fp)
8111a7e4:	e03ffc8d 	sth	zero,-14(fp)
8111a7e8:	e03ffd0d 	sth	zero,-12(fp)
8111a7ec:	e03ffd8d 	sth	zero,-10(fp)
8111a7f0:	e03ffe0d 	sth	zero,-8(fp)
8111a7f4:	e03ffe8d 	sth	zero,-6(fp)
8111a7f8:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8111a7fc:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a800:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a804:	111a9bc0 	call	8111a9bc <usiGetIdCMD>
8111a808:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
8111a80c:	e0fff70b 	ldhu	r3,-36(fp)
8111a810:	e0bff784 	addi	r2,fp,-34
8111a814:	180d883a 	mov	r6,r3
8111a818:	01604574 	movhi	r5,33045
8111a81c:	2941e804 	addi	r5,r5,1952
8111a820:	1009883a 	mov	r4,r2
8111a824:	1124bb40 	call	81124bb4 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8111a828:	e0bff784 	addi	r2,fp,-34
8111a82c:	1009883a 	mov	r4,r2
8111a830:	1124dc80 	call	81124dc8 <strlen>
8111a834:	1007883a 	mov	r3,r2
8111a838:	e0bff784 	addi	r2,fp,-34
8111a83c:	180b883a 	mov	r5,r3
8111a840:	1009883a 	mov	r4,r2
8111a844:	111cc8c0 	call	8111cc8c <ucCrc8wInit>
8111a848:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8111a84c:	e13ff503 	ldbu	r4,-44(fp)
8111a850:	e0fff784 	addi	r3,fp,-34
8111a854:	e0bff784 	addi	r2,fp,-34
8111a858:	200f883a 	mov	r7,r4
8111a85c:	180d883a 	mov	r6,r3
8111a860:	01604574 	movhi	r5,33045
8111a864:	2941e304 	addi	r5,r5,1932
8111a868:	1009883a 	mov	r4,r2
8111a86c:	1124bb40 	call	81124bb4 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8111a870:	e0bff70b 	ldhu	r2,-36(fp)
8111a874:	10ffffcc 	andi	r3,r2,65535
8111a878:	18e0001c 	xori	r3,r3,32768
8111a87c:	18e00004 	addi	r3,r3,-32768
8111a880:	e0bff784 	addi	r2,fp,-34
8111a884:	180b883a 	mov	r5,r3
8111a888:	1009883a 	mov	r4,r2
8111a88c:	111a0d40 	call	8111a0d4 <bSendUART32v2>
8111a890:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8111a894:	e0bff617 	ldw	r2,-40(fp)
8111a898:	10800060 	cmpeqi	r2,r2,1
8111a89c:	1000011e 	bne	r2,zero,8111a8a4 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111a8a0:	111e3540 	call	8111e354 <vCouldNotSendTurnOff>
	}
}
8111a8a4:	0001883a 	nop
8111a8a8:	e037883a 	mov	sp,fp
8111a8ac:	dfc00117 	ldw	ra,4(sp)
8111a8b0:	df000017 	ldw	fp,0(sp)
8111a8b4:	dec00204 	addi	sp,sp,8
8111a8b8:	f800283a 	ret

8111a8bc <vSendLog>:

void vSendLog ( const char * cDataIn ) {
8111a8bc:	deffda04 	addi	sp,sp,-152
8111a8c0:	de00012e 	bgeu	sp,et,8111a8c8 <vSendLog+0xc>
8111a8c4:	003b68fa 	trap	3
8111a8c8:	dfc02515 	stw	ra,148(sp)
8111a8cc:	df002415 	stw	fp,144(sp)
8111a8d0:	df002404 	addi	fp,sp,144
8111a8d4:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
8111a8d8:	e03fde8d 	sth	zero,-134(fp)
8111a8dc:	e03fdf0d 	sth	zero,-132(fp)
8111a8e0:	e0bfdf84 	addi	r2,fp,-130
8111a8e4:	00c01f04 	movi	r3,124
8111a8e8:	180d883a 	mov	r6,r3
8111a8ec:	000b883a 	mov	r5,zero
8111a8f0:	1009883a 	mov	r4,r2
8111a8f4:	11244a00 	call	811244a0 <memset>
    unsigned char crc = 0;
8111a8f8:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a8fc:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a900:	111a9bc0 	call	8111a9bc <usiGetIdCMD>
8111a904:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
8111a908:	e0ffde0b 	ldhu	r3,-136(fp)
8111a90c:	e0bfde84 	addi	r2,fp,-134
8111a910:	e1ffff17 	ldw	r7,-4(fp)
8111a914:	180d883a 	mov	r6,r3
8111a918:	01604574 	movhi	r5,33045
8111a91c:	2941ea04 	addi	r5,r5,1960
8111a920:	1009883a 	mov	r4,r2
8111a924:	1124bb40 	call	81124bb4 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
8111a928:	e0bfde84 	addi	r2,fp,-134
8111a92c:	1009883a 	mov	r4,r2
8111a930:	1124dc80 	call	81124dc8 <strlen>
8111a934:	1007883a 	mov	r3,r2
8111a938:	e0bfde84 	addi	r2,fp,-134
8111a93c:	180b883a 	mov	r5,r3
8111a940:	1009883a 	mov	r4,r2
8111a944:	111cc8c0 	call	8111cc8c <ucCrc8wInit>
8111a948:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
8111a94c:	e13fdc03 	ldbu	r4,-144(fp)
8111a950:	e0ffde84 	addi	r3,fp,-134
8111a954:	e0bfde84 	addi	r2,fp,-134
8111a958:	200f883a 	mov	r7,r4
8111a95c:	180d883a 	mov	r6,r3
8111a960:	01604574 	movhi	r5,33045
8111a964:	2941e304 	addi	r5,r5,1932
8111a968:	1009883a 	mov	r4,r2
8111a96c:	1124bb40 	call	81124bb4 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
8111a970:	e0bfde0b 	ldhu	r2,-136(fp)
8111a974:	10ffffcc 	andi	r3,r2,65535
8111a978:	18e0001c 	xori	r3,r3,32768
8111a97c:	18e00004 	addi	r3,r3,-32768
8111a980:	e0bfde84 	addi	r2,fp,-134
8111a984:	180b883a 	mov	r5,r3
8111a988:	1009883a 	mov	r4,r2
8111a98c:	1119a8c0 	call	81119a8c <bSendUART128v2>
8111a990:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
8111a994:	e0bfdd17 	ldw	r2,-140(fp)
8111a998:	10800060 	cmpeqi	r2,r2,1
8111a99c:	1000011e 	bne	r2,zero,8111a9a4 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
8111a9a0:	111e4540 	call	8111e454 <vCouldNotSendLog>
	}
}
8111a9a4:	0001883a 	nop
8111a9a8:	e037883a 	mov	sp,fp
8111a9ac:	dfc00117 	ldw	ra,4(sp)
8111a9b0:	df000017 	ldw	fp,0(sp)
8111a9b4:	dec00204 	addi	sp,sp,8
8111a9b8:	f800283a 	ret

8111a9bc <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
8111a9bc:	deffff04 	addi	sp,sp,-4
8111a9c0:	de00012e 	bgeu	sp,et,8111a9c8 <usiGetIdCMD+0xc>
8111a9c4:	003b68fa 	trap	3
8111a9c8:	df000015 	stw	fp,0(sp)
8111a9cc:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
8111a9d0:	d0a0680b 	ldhu	r2,-32352(gp)
8111a9d4:	10ffffcc 	andi	r3,r2,65535
8111a9d8:	00bfffd4 	movui	r2,65535
8111a9dc:	1880031e 	bne	r3,r2,8111a9ec <usiGetIdCMD+0x30>
        usiIdCMD = 2;
8111a9e0:	00800084 	movi	r2,2
8111a9e4:	d0a0680d 	sth	r2,-32352(gp)
8111a9e8:	00000306 	br	8111a9f8 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
8111a9ec:	d0a0680b 	ldhu	r2,-32352(gp)
8111a9f0:	10800044 	addi	r2,r2,1
8111a9f4:	d0a0680d 	sth	r2,-32352(gp)

    return usiIdCMD;
8111a9f8:	d0a0680b 	ldhu	r2,-32352(gp)
}
8111a9fc:	e037883a 	mov	sp,fp
8111aa00:	df000017 	ldw	fp,0(sp)
8111aa04:	dec00104 	addi	sp,sp,4
8111aa08:	f800283a 	ret

8111aa0c <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
8111aa0c:	defffb04 	addi	sp,sp,-20
8111aa10:	de00012e 	bgeu	sp,et,8111aa18 <siPosStr+0xc>
8111aa14:	003b68fa 	trap	3
8111aa18:	dfc00415 	stw	ra,16(sp)
8111aa1c:	df000315 	stw	fp,12(sp)
8111aa20:	df000304 	addi	fp,sp,12
8111aa24:	e13ffe15 	stw	r4,-8(fp)
8111aa28:	2805883a 	mov	r2,r5
8111aa2c:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
8111aa30:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
8111aa34:	e0bfff03 	ldbu	r2,-4(fp)
8111aa38:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
8111aa3c:	e17ffd04 	addi	r5,fp,-12
8111aa40:	e13ffe17 	ldw	r4,-8(fp)
8111aa44:	1124d7c0 	call	81124d7c <strcspn>
}
8111aa48:	e037883a 	mov	sp,fp
8111aa4c:	dfc00117 	ldw	ra,4(sp)
8111aa50:	df000017 	ldw	fp,0(sp)
8111aa54:	dec00204 	addi	sp,sp,8
8111aa58:	f800283a 	ret

8111aa5c <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
8111aa5c:	defffc04 	addi	sp,sp,-16
8111aa60:	de00012e 	bgeu	sp,et,8111aa68 <vTimeoutCheck+0xc>
8111aa64:	003b68fa 	trap	3
8111aa68:	dfc00315 	stw	ra,12(sp)
8111aa6c:	df000215 	stw	fp,8(sp)
8111aa70:	df000204 	addi	fp,sp,8
8111aa74:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
8111aa78:	d0a06717 	ldw	r2,-32356(gp)
8111aa7c:	1009883a 	mov	r4,r2
8111aa80:	1140ae40 	call	81140ae4 <OSSemPost>
8111aa84:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
8111aa88:	e0bffe03 	ldbu	r2,-8(fp)
8111aa8c:	10000126 	beq	r2,zero,8111aa94 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
8111aa90:	111e0540 	call	8111e054 <vFailPostBlockingSemTimeoutTask>
	}
}
8111aa94:	0001883a 	nop
8111aa98:	e037883a 	mov	sp,fp
8111aa9c:	dfc00117 	ldw	ra,4(sp)
8111aaa0:	df000017 	ldw	fp,0(sp)
8111aaa4:	dec00204 	addi	sp,sp,8
8111aaa8:	f800283a 	ret

8111aaac <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
8111aaac:	deffe304 	addi	sp,sp,-116
8111aab0:	de00012e 	bgeu	sp,et,8111aab8 <vSendPusTM64+0xc>
8111aab4:	003b68fa 	trap	3
8111aab8:	dfc01815 	stw	ra,96(sp)
8111aabc:	df001715 	stw	fp,92(sp)
8111aac0:	df001704 	addi	fp,sp,92
8111aac4:	e1000215 	stw	r4,8(fp)
8111aac8:	e1400315 	stw	r5,12(fp)
8111aacc:	e1800415 	stw	r6,16(fp)
8111aad0:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
8111aad4:	e03fef8d 	sth	zero,-66(fp)
8111aad8:	e03ff00d 	sth	zero,-64(fp)
8111aadc:	e0bff084 	addi	r2,fp,-62
8111aae0:	00c00f04 	movi	r3,60
8111aae4:	180d883a 	mov	r6,r3
8111aae8:	000b883a 	mov	r5,zero
8111aaec:	1009883a 	mov	r4,r2
8111aaf0:	11244a00 	call	811244a0 <memset>
    unsigned char crc = 0;
8111aaf4:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
8111aaf8:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111aafc:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111ab00:	111a9bc0 	call	8111a9bc <usiGetIdCMD>
8111ab04:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8111ab08:	e1bfef0b 	ldhu	r6,-68(fp)
8111ab0c:	e080040b 	ldhu	r2,16(fp)
8111ab10:	11ffffcc 	andi	r7,r2,65535
8111ab14:	e080048b 	ldhu	r2,18(fp)
8111ab18:	10bfffcc 	andi	r2,r2,65535
8111ab1c:	e0c0050b 	ldhu	r3,20(fp)
8111ab20:	18ffffcc 	andi	r3,r3,65535
8111ab24:	e100058b 	ldhu	r4,22(fp)
8111ab28:	213fffcc 	andi	r4,r4,65535
8111ab2c:	e140060b 	ldhu	r5,24(fp)
8111ab30:	297fffcc 	andi	r5,r5,65535
8111ab34:	e23fef84 	addi	r8,fp,-66
8111ab38:	d9400315 	stw	r5,12(sp)
8111ab3c:	d9000215 	stw	r4,8(sp)
8111ab40:	d8c00115 	stw	r3,4(sp)
8111ab44:	d8800015 	stw	r2,0(sp)
8111ab48:	01604574 	movhi	r5,33045
8111ab4c:	2941ed04 	addi	r5,r5,1972
8111ab50:	4009883a 	mov	r4,r8
8111ab54:	1124bb40 	call	81124bb4 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111ab58:	e03fed05 	stb	zero,-76(fp)
8111ab5c:	00001206 	br	8111aba8 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8111ab60:	e0bfed03 	ldbu	r2,-76(fp)
8111ab64:	10800284 	addi	r2,r2,10
8111ab68:	1085883a 	add	r2,r2,r2
8111ab6c:	e0c00204 	addi	r3,fp,8
8111ab70:	1885883a 	add	r2,r3,r2
8111ab74:	1080000b 	ldhu	r2,0(r2)
8111ab78:	113fffcc 	andi	r4,r2,65535
8111ab7c:	e0ffef84 	addi	r3,fp,-66
8111ab80:	e0bfef84 	addi	r2,fp,-66
8111ab84:	200f883a 	mov	r7,r4
8111ab88:	180d883a 	mov	r6,r3
8111ab8c:	01604574 	movhi	r5,33045
8111ab90:	2941f404 	addi	r5,r5,2000
8111ab94:	1009883a 	mov	r4,r2
8111ab98:	1124bb40 	call	81124bb4 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111ab9c:	e0bfed03 	ldbu	r2,-76(fp)
8111aba0:	10800044 	addi	r2,r2,1
8111aba4:	e0bfed05 	stb	r2,-76(fp)
8111aba8:	e0800683 	ldbu	r2,26(fp)
8111abac:	10803fcc 	andi	r2,r2,255
8111abb0:	e0ffed03 	ldbu	r3,-76(fp)
8111abb4:	18bfea36 	bltu	r3,r2,8111ab60 <__reset+0xfb0fab60>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111abb8:	e0bfef84 	addi	r2,fp,-66
8111abbc:	1009883a 	mov	r4,r2
8111abc0:	1124dc80 	call	81124dc8 <strlen>
8111abc4:	1007883a 	mov	r3,r2
8111abc8:	e0bfef84 	addi	r2,fp,-66
8111abcc:	180b883a 	mov	r5,r3
8111abd0:	1009883a 	mov	r4,r2
8111abd4:	111cc8c0 	call	8111cc8c <ucCrc8wInit>
8111abd8:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8111abdc:	e13fed43 	ldbu	r4,-75(fp)
8111abe0:	e0ffef84 	addi	r3,fp,-66
8111abe4:	e0bfef84 	addi	r2,fp,-66
8111abe8:	200f883a 	mov	r7,r4
8111abec:	180d883a 	mov	r6,r3
8111abf0:	01604574 	movhi	r5,33045
8111abf4:	2941e304 	addi	r5,r5,1932
8111abf8:	1009883a 	mov	r4,r2
8111abfc:	1124bb40 	call	81124bb4 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
8111ac00:	e0bfef0b 	ldhu	r2,-68(fp)
8111ac04:	10ffffcc 	andi	r3,r2,65535
8111ac08:	18e0001c 	xori	r3,r3,32768
8111ac0c:	18e00004 	addi	r3,r3,-32768
8111ac10:	e0bfef84 	addi	r2,fp,-66
8111ac14:	180b883a 	mov	r5,r3
8111ac18:	1009883a 	mov	r4,r2
8111ac1c:	1119dac0 	call	81119dac <bSendUART64v2>
8111ac20:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
8111ac24:	e0bfee17 	ldw	r2,-72(fp)
8111ac28:	10800060 	cmpeqi	r2,r2,1
8111ac2c:	1000031e 	bne	r2,zero,8111ac3c <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111ac30:	e0bfef84 	addi	r2,fp,-66
8111ac34:	1009883a 	mov	r4,r2
8111ac38:	111e4d40 	call	8111e4d4 <vCouldNotSendTMPusCommand>
	}
}
8111ac3c:	0001883a 	nop
8111ac40:	e037883a 	mov	sp,fp
8111ac44:	dfc00117 	ldw	ra,4(sp)
8111ac48:	df000017 	ldw	fp,0(sp)
8111ac4c:	dec00604 	addi	sp,sp,24
8111ac50:	f800283a 	ret

8111ac54 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
8111ac54:	deffd304 	addi	sp,sp,-180
8111ac58:	de00012e 	bgeu	sp,et,8111ac60 <vSendPusTM128+0xc>
8111ac5c:	003b68fa 	trap	3
8111ac60:	dfc02815 	stw	ra,160(sp)
8111ac64:	df002715 	stw	fp,156(sp)
8111ac68:	df002704 	addi	fp,sp,156
8111ac6c:	e1000215 	stw	r4,8(fp)
8111ac70:	e1400315 	stw	r5,12(fp)
8111ac74:	e1800415 	stw	r6,16(fp)
8111ac78:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
8111ac7c:	e03fdf8d 	sth	zero,-130(fp)
8111ac80:	e03fe00d 	sth	zero,-128(fp)
8111ac84:	e0bfe084 	addi	r2,fp,-126
8111ac88:	00c01f04 	movi	r3,124
8111ac8c:	180d883a 	mov	r6,r3
8111ac90:	000b883a 	mov	r5,zero
8111ac94:	1009883a 	mov	r4,r2
8111ac98:	11244a00 	call	811244a0 <memset>
    unsigned char crc = 0;
8111ac9c:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
8111aca0:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
8111aca4:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111aca8:	111a9bc0 	call	8111a9bc <usiGetIdCMD>
8111acac:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8111acb0:	e1bfdf0b 	ldhu	r6,-132(fp)
8111acb4:	e080040b 	ldhu	r2,16(fp)
8111acb8:	11ffffcc 	andi	r7,r2,65535
8111acbc:	e080048b 	ldhu	r2,18(fp)
8111acc0:	10bfffcc 	andi	r2,r2,65535
8111acc4:	e0c0050b 	ldhu	r3,20(fp)
8111acc8:	18ffffcc 	andi	r3,r3,65535
8111accc:	e100058b 	ldhu	r4,22(fp)
8111acd0:	213fffcc 	andi	r4,r4,65535
8111acd4:	e140060b 	ldhu	r5,24(fp)
8111acd8:	297fffcc 	andi	r5,r5,65535
8111acdc:	e23fdf84 	addi	r8,fp,-130
8111ace0:	d9400315 	stw	r5,12(sp)
8111ace4:	d9000215 	stw	r4,8(sp)
8111ace8:	d8c00115 	stw	r3,4(sp)
8111acec:	d8800015 	stw	r2,0(sp)
8111acf0:	01604574 	movhi	r5,33045
8111acf4:	2941ed04 	addi	r5,r5,1972
8111acf8:	4009883a 	mov	r4,r8
8111acfc:	1124bb40 	call	81124bb4 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111ad00:	e03fdd05 	stb	zero,-140(fp)
8111ad04:	00001206 	br	8111ad50 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8111ad08:	e0bfdd03 	ldbu	r2,-140(fp)
8111ad0c:	10800284 	addi	r2,r2,10
8111ad10:	1085883a 	add	r2,r2,r2
8111ad14:	e0c00204 	addi	r3,fp,8
8111ad18:	1885883a 	add	r2,r3,r2
8111ad1c:	1080000b 	ldhu	r2,0(r2)
8111ad20:	113fffcc 	andi	r4,r2,65535
8111ad24:	e0ffdf84 	addi	r3,fp,-130
8111ad28:	e0bfdf84 	addi	r2,fp,-130
8111ad2c:	200f883a 	mov	r7,r4
8111ad30:	180d883a 	mov	r6,r3
8111ad34:	01604574 	movhi	r5,33045
8111ad38:	2941f404 	addi	r5,r5,2000
8111ad3c:	1009883a 	mov	r4,r2
8111ad40:	1124bb40 	call	81124bb4 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111ad44:	e0bfdd03 	ldbu	r2,-140(fp)
8111ad48:	10800044 	addi	r2,r2,1
8111ad4c:	e0bfdd05 	stb	r2,-140(fp)
8111ad50:	e0800683 	ldbu	r2,26(fp)
8111ad54:	10803fcc 	andi	r2,r2,255
8111ad58:	e0ffdd03 	ldbu	r3,-140(fp)
8111ad5c:	18bfea36 	bltu	r3,r2,8111ad08 <__reset+0xfb0fad08>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111ad60:	e0bfdf84 	addi	r2,fp,-130
8111ad64:	1009883a 	mov	r4,r2
8111ad68:	1124dc80 	call	81124dc8 <strlen>
8111ad6c:	1007883a 	mov	r3,r2
8111ad70:	e0bfdf84 	addi	r2,fp,-130
8111ad74:	180b883a 	mov	r5,r3
8111ad78:	1009883a 	mov	r4,r2
8111ad7c:	111cc8c0 	call	8111cc8c <ucCrc8wInit>
8111ad80:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8111ad84:	e13fdd43 	ldbu	r4,-139(fp)
8111ad88:	e0ffdf84 	addi	r3,fp,-130
8111ad8c:	e0bfdf84 	addi	r2,fp,-130
8111ad90:	200f883a 	mov	r7,r4
8111ad94:	180d883a 	mov	r6,r3
8111ad98:	01604574 	movhi	r5,33045
8111ad9c:	2941e304 	addi	r5,r5,1932
8111ada0:	1009883a 	mov	r4,r2
8111ada4:	1124bb40 	call	81124bb4 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
8111ada8:	e0bfdf0b 	ldhu	r2,-132(fp)
8111adac:	10ffffcc 	andi	r3,r2,65535
8111adb0:	18e0001c 	xori	r3,r3,32768
8111adb4:	18e00004 	addi	r3,r3,-32768
8111adb8:	e0bfdf84 	addi	r2,fp,-130
8111adbc:	180b883a 	mov	r5,r3
8111adc0:	1009883a 	mov	r4,r2
8111adc4:	1119a8c0 	call	81119a8c <bSendUART128v2>
8111adc8:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
8111adcc:	e0bfde17 	ldw	r2,-136(fp)
8111add0:	10800060 	cmpeqi	r2,r2,1
8111add4:	1000031e 	bne	r2,zero,8111ade4 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111add8:	e0bfdf84 	addi	r2,fp,-130
8111addc:	1009883a 	mov	r4,r2
8111ade0:	111e4d40 	call	8111e4d4 <vCouldNotSendTMPusCommand>
	}
}
8111ade4:	0001883a 	nop
8111ade8:	e037883a 	mov	sp,fp
8111adec:	dfc00117 	ldw	ra,4(sp)
8111adf0:	df000017 	ldw	fp,0(sp)
8111adf4:	dec00604 	addi	sp,sp,24
8111adf8:	f800283a 	ret

8111adfc <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
8111adfc:	deffd704 	addi	sp,sp,-164
8111ae00:	de00012e 	bgeu	sp,et,8111ae08 <vTMPusTestConnection+0xc>
8111ae04:	003b68fa 	trap	3
8111ae08:	dfc02815 	stw	ra,160(sp)
8111ae0c:	df002715 	stw	fp,156(sp)
8111ae10:	df002704 	addi	fp,sp,156
8111ae14:	2005883a 	mov	r2,r4
8111ae18:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
8111ae1c:	e0bfff0b 	ldhu	r2,-4(fp)
8111ae20:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
8111ae24:	00801c04 	movi	r2,112
8111ae28:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
8111ae2c:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
8111ae30:	00800444 	movi	r2,17
8111ae34:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
8111ae38:	00800084 	movi	r2,2
8111ae3c:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
8111ae40:	d809883a 	mov	r4,sp
8111ae44:	e0bfee04 	addi	r2,fp,-72
8111ae48:	00c01104 	movi	r3,68
8111ae4c:	180d883a 	mov	r6,r3
8111ae50:	100b883a 	mov	r5,r2
8111ae54:	11243500 	call	81124350 <memcpy>
8111ae58:	e13fea17 	ldw	r4,-88(fp)
8111ae5c:	e17feb17 	ldw	r5,-84(fp)
8111ae60:	e1bfec17 	ldw	r6,-80(fp)
8111ae64:	e1ffed17 	ldw	r7,-76(fp)
8111ae68:	111aaac0 	call	8111aaac <vSendPusTM64>
}
8111ae6c:	0001883a 	nop
8111ae70:	e037883a 	mov	sp,fp
8111ae74:	dfc00117 	ldw	ra,4(sp)
8111ae78:	df000017 	ldw	fp,0(sp)
8111ae7c:	dec00204 	addi	sp,sp,8
8111ae80:	f800283a 	ret

8111ae84 <vLoadDefaultETHConf>:
/*Configuration related to the eth connection*/
TConfEth xConfEth;
TDefaults xDefaults;


bool vLoadDefaultETHConf( void ){
8111ae84:	defff504 	addi	sp,sp,-44
8111ae88:	de00012e 	bgeu	sp,et,8111ae90 <vLoadDefaultETHConf+0xc>
8111ae8c:	003b68fa 	trap	3
8111ae90:	dfc00a15 	stw	ra,40(sp)
8111ae94:	df000915 	stw	fp,36(sp)
8111ae98:	dc000815 	stw	r16,32(sp)
8111ae9c:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8111aea0:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
8111aea4:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
8111aea8:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8111aeac:	d0a07617 	ldw	r2,-32296(gp)
8111aeb0:	10800058 	cmpnei	r2,r2,1
8111aeb4:	10021f1e 	bne	r2,zero,8111b734 <vLoadDefaultETHConf+0x8b0>
8111aeb8:	11207600 	call	81120760 <bSDcardIsPresent>
8111aebc:	10021d26 	beq	r2,zero,8111b734 <vLoadDefaultETHConf+0x8b0>
8111aec0:	11207900 	call	81120790 <bSDcardFAT16Check>
8111aec4:	10021b26 	beq	r2,zero,8111b734 <vLoadDefaultETHConf+0x8b0>

		siFile = siOpenFile( ETH_FILE_NAME );
8111aec8:	01204574 	movhi	r4,33045
8111aecc:	2101f604 	addi	r4,r4,2008
8111aed0:	11208b80 	call	811208b8 <siOpenFile>
8111aed4:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
8111aed8:	e0bffc0f 	ldh	r2,-16(fp)
8111aedc:	10020716 	blt	r2,zero,8111b6fc <vLoadDefaultETHConf+0x878>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8111aee0:	e0bffd04 	addi	r2,fp,-12
8111aee4:	01800204 	movi	r6,8
8111aee8:	01400284 	movi	r5,10
8111aeec:	1009883a 	mov	r4,r2
8111aef0:	11244a00 	call	811244a0 <memset>
			p_inteiro = inteiro;
8111aef4:	e0bffd04 	addi	r2,fp,-12
8111aef8:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
8111aefc:	e0bffc0f 	ldh	r2,-16(fp)
8111af00:	1009883a 	mov	r4,r2
8111af04:	11209340 	call	81120934 <cGetNextChar>
8111af08:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
8111af0c:	e0bff947 	ldb	r2,-27(fp)
8111af10:	10800084 	addi	r2,r2,2
8111af14:	10c015a8 	cmpgeui	r3,r2,86
8111af18:	1801e41e 	bne	r3,zero,8111b6ac <vLoadDefaultETHConf+0x828>
8111af1c:	100690ba 	slli	r3,r2,2
8111af20:	00a044b4 	movhi	r2,33042
8111af24:	10abcd04 	addi	r2,r2,-20684
8111af28:	1885883a 	add	r2,r3,r2
8111af2c:	10800017 	ldw	r2,0(r2)
8111af30:	1000683a 	jmp	r2
8111af34:	8111b0cc 	andi	r4,r16,18115
8111af38:	8111b0c0 	call	88111b0c <__reset+0x20f1b0c>
8111af3c:	8111b6ac 	andhi	r4,r16,18138
8111af40:	8111b6ac 	andhi	r4,r16,18138
8111af44:	8111b6ac 	andhi	r4,r16,18138
8111af48:	8111b6ac 	andhi	r4,r16,18138
8111af4c:	8111b6ac 	andhi	r4,r16,18138
8111af50:	8111b6ac 	andhi	r4,r16,18138
8111af54:	8111b6ac 	andhi	r4,r16,18138
8111af58:	8111b6ac 	andhi	r4,r16,18138
8111af5c:	8111b6ac 	andhi	r4,r16,18138
8111af60:	8111b6ac 	andhi	r4,r16,18138
8111af64:	8111b6e4 	muli	r4,r16,18139
8111af68:	8111b6ac 	andhi	r4,r16,18138
8111af6c:	8111b6ac 	andhi	r4,r16,18138
8111af70:	8111b6e4 	muli	r4,r16,18139
8111af74:	8111b6ac 	andhi	r4,r16,18138
8111af78:	8111b6ac 	andhi	r4,r16,18138
8111af7c:	8111b6ac 	andhi	r4,r16,18138
8111af80:	8111b6ac 	andhi	r4,r16,18138
8111af84:	8111b6ac 	andhi	r4,r16,18138
8111af88:	8111b6ac 	andhi	r4,r16,18138
8111af8c:	8111b6ac 	andhi	r4,r16,18138
8111af90:	8111b6ac 	andhi	r4,r16,18138
8111af94:	8111b6ac 	andhi	r4,r16,18138
8111af98:	8111b6ac 	andhi	r4,r16,18138
8111af9c:	8111b6ac 	andhi	r4,r16,18138
8111afa0:	8111b6ac 	andhi	r4,r16,18138
8111afa4:	8111b6ac 	andhi	r4,r16,18138
8111afa8:	8111b6ac 	andhi	r4,r16,18138
8111afac:	8111b6ac 	andhi	r4,r16,18138
8111afb0:	8111b6ac 	andhi	r4,r16,18138
8111afb4:	8111b6ac 	andhi	r4,r16,18138
8111afb8:	8111b6ac 	andhi	r4,r16,18138
8111afbc:	8111b6e4 	muli	r4,r16,18139
8111afc0:	8111b6ac 	andhi	r4,r16,18138
8111afc4:	8111b6ac 	andhi	r4,r16,18138
8111afc8:	8111b6ac 	andhi	r4,r16,18138
8111afcc:	8111b6ac 	andhi	r4,r16,18138
8111afd0:	8111b6ac 	andhi	r4,r16,18138
8111afd4:	8111b6ac 	andhi	r4,r16,18138
8111afd8:	8111b08c 	andi	r4,r16,18114
8111afdc:	8111b6ac 	andhi	r4,r16,18138
8111afe0:	8111b6ac 	andhi	r4,r16,18138
8111afe4:	8111b6ac 	andhi	r4,r16,18138
8111afe8:	8111b6ac 	andhi	r4,r16,18138
8111afec:	8111b6ac 	andhi	r4,r16,18138
8111aff0:	8111b6ac 	andhi	r4,r16,18138
8111aff4:	8111b6ac 	andhi	r4,r16,18138
8111aff8:	8111b6ac 	andhi	r4,r16,18138
8111affc:	8111b6ac 	andhi	r4,r16,18138
8111b000:	8111b6ac 	andhi	r4,r16,18138
8111b004:	8111b6ac 	andhi	r4,r16,18138
8111b008:	8111b6ac 	andhi	r4,r16,18138
8111b00c:	8111b6ac 	andhi	r4,r16,18138
8111b010:	8111b6ac 	andhi	r4,r16,18138
8111b014:	8111b6ac 	andhi	r4,r16,18138
8111b018:	8111b6ac 	andhi	r4,r16,18138
8111b01c:	8111b6ac 	andhi	r4,r16,18138
8111b020:	8111b6ac 	andhi	r4,r16,18138
8111b024:	8111b6ac 	andhi	r4,r16,18138
8111b028:	8111b6ac 	andhi	r4,r16,18138
8111b02c:	8111b64c 	andi	r4,r16,18137
8111b030:	8111b6ac 	andhi	r4,r16,18138
8111b034:	8111b6ac 	andhi	r4,r16,18138
8111b038:	8111b6ac 	andhi	r4,r16,18138
8111b03c:	8111b6ac 	andhi	r4,r16,18138
8111b040:	8111b6ac 	andhi	r4,r16,18138
8111b044:	8111b6ac 	andhi	r4,r16,18138
8111b048:	8111b6ac 	andhi	r4,r16,18138
8111b04c:	8111b57c 	xorhi	r4,r16,18133
8111b050:	8111b6ac 	andhi	r4,r16,18138
8111b054:	8111b6ac 	andhi	r4,r16,18138
8111b058:	8111b2a8 	cmpgeui	r4,r16,18122
8111b05c:	8111b404 	addi	r4,r16,18128
8111b060:	8111b1dc 	xori	r4,r16,18119
8111b064:	8111b6ac 	andhi	r4,r16,18138
8111b068:	8111b6ac 	andhi	r4,r16,18138
8111b06c:	8111b6ac 	andhi	r4,r16,18138
8111b070:	8111b10c 	andi	r4,r16,18116
8111b074:	8111b6ac 	andhi	r4,r16,18138
8111b078:	8111b6ac 	andhi	r4,r16,18138
8111b07c:	8111b378 	rdprs	r4,r16,18125
8111b080:	8111b6ac 	andhi	r4,r16,18138
8111b084:	8111b6ac 	andhi	r4,r16,18138
8111b088:	8111b4ac 	andhi	r4,r16,18130
					case 39:// single quote '
						c = cGetNextChar(siFile);
8111b08c:	e0bffc0f 	ldh	r2,-16(fp)
8111b090:	1009883a 	mov	r4,r2
8111b094:	11209340 	call	81120934 <cGetNextChar>
8111b098:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
8111b09c:	00000406 	br	8111b0b0 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
8111b0a0:	e0bffc0f 	ldh	r2,-16(fp)
8111b0a4:	1009883a 	mov	r4,r2
8111b0a8:	11209340 	call	81120934 <cGetNextChar>
8111b0ac:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111b0b0:	e0bff947 	ldb	r2,-27(fp)
8111b0b4:	108009d8 	cmpnei	r2,r2,39
8111b0b8:	103ff91e 	bne	r2,zero,8111b0a0 <__reset+0xfb0fb0a0>
							c = cGetNextChar(siFile);
						}
						break;
8111b0bc:	00018c06 	br	8111b6f0 <vLoadDefaultETHConf+0x86c>
					case -1: 	//EOF
						bEOF = TRUE;
8111b0c0:	00800044 	movi	r2,1
8111b0c4:	e0bff815 	stw	r2,-32(fp)
						break;
8111b0c8:	00018906 	br	8111b6f0 <vLoadDefaultETHConf+0x86c>
					case -2: 	//EOF
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111b0cc:	00a045f4 	movhi	r2,33047
8111b0d0:	10a25304 	addi	r2,r2,-30388
8111b0d4:	10800a8b 	ldhu	r2,42(r2)
8111b0d8:	10bfffcc 	andi	r2,r2,65535
8111b0dc:	10800228 	cmpgeui	r2,r2,8
8111b0e0:	1000071e 	bne	r2,zero,8111b100 <vLoadDefaultETHConf+0x27c>
							debug(fp,"SDCard: Problem with SDCard");
8111b0e4:	d0a06217 	ldw	r2,-32376(gp)
8111b0e8:	100f883a 	mov	r7,r2
8111b0ec:	018006c4 	movi	r6,27
8111b0f0:	01400044 	movi	r5,1
8111b0f4:	01204574 	movhi	r4,33045
8111b0f8:	2101f804 	addi	r4,r4,2016
8111b0fc:	112393c0 	call	8112393c <fwrite>
						}
						#endif
						bEOF = TRUE;
8111b100:	00800044 	movi	r2,1
8111b104:	e0bff815 	stw	r2,-32(fp)
						break;
8111b108:	00017906 	br	8111b6f0 <vLoadDefaultETHConf+0x86c>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
8111b10c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b110:	e0bffc0f 	ldh	r2,-16(fp)
8111b114:	1009883a 	mov	r4,r2
8111b118:	11209340 	call	81120934 <cGetNextChar>
8111b11c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111b120:	d0e00317 	ldw	r3,-32756(gp)
8111b124:	e0bff947 	ldb	r2,-27(fp)
8111b128:	10800044 	addi	r2,r2,1
8111b12c:	1885883a 	add	r2,r3,r2
8111b130:	10800003 	ldbu	r2,0(r2)
8111b134:	10803fcc 	andi	r2,r2,255
8111b138:	1080010c 	andi	r2,r2,4
8111b13c:	10000626 	beq	r2,zero,8111b158 <vLoadDefaultETHConf+0x2d4>
									(*p_inteiro) = c;
8111b140:	e0bffa17 	ldw	r2,-24(fp)
8111b144:	e0fff943 	ldbu	r3,-27(fp)
8111b148:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b14c:	e0bffa17 	ldw	r2,-24(fp)
8111b150:	10800044 	addi	r2,r2,1
8111b154:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
8111b158:	e0bff947 	ldb	r2,-27(fp)
8111b15c:	10800ea0 	cmpeqi	r2,r2,58
8111b160:	1000031e 	bne	r2,zero,8111b170 <vLoadDefaultETHConf+0x2ec>
8111b164:	e0bff947 	ldb	r2,-27(fp)
8111b168:	10800ed8 	cmpnei	r2,r2,59
8111b16c:	103fe81e 	bne	r2,zero,8111b110 <__reset+0xfb0fb110>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b170:	e0bffa17 	ldw	r2,-24(fp)
8111b174:	00c00284 	movi	r3,10
8111b178:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = (unsigned char)atoi( inteiro );
8111b17c:	e0bff903 	ldbu	r2,-28(fp)
8111b180:	10800168 	cmpgeui	r2,r2,5
8111b184:	1000021e 	bne	r2,zero,8111b190 <vLoadDefaultETHConf+0x30c>
8111b188:	e43ff903 	ldbu	r16,-28(fp)
8111b18c:	00000106 	br	8111b194 <vLoadDefaultETHConf+0x310>
8111b190:	04000144 	movi	r16,5
8111b194:	e0bffd04 	addi	r2,fp,-12
8111b198:	1009883a 	mov	r4,r2
8111b19c:	112312c0 	call	8112312c <atoi>
8111b1a0:	1007883a 	mov	r3,r2
8111b1a4:	00a045f4 	movhi	r2,33047
8111b1a8:	10a26004 	addi	r2,r2,-30336
8111b1ac:	1405883a 	add	r2,r2,r16
8111b1b0:	10800404 	addi	r2,r2,16
8111b1b4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b1b8:	e0bffd04 	addi	r2,fp,-12
8111b1bc:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111b1c0:	e0bff903 	ldbu	r2,-28(fp)
8111b1c4:	10800044 	addi	r2,r2,1
8111b1c8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111b1cc:	e0bff947 	ldb	r2,-27(fp)
8111b1d0:	10800ed8 	cmpnei	r2,r2,59
8111b1d4:	103fce1e 	bne	r2,zero,8111b110 <__reset+0xfb0fb110>

						break;
8111b1d8:	00014506 	br	8111b6f0 <vLoadDefaultETHConf+0x86c>
					case 'I':

						ucParser = 0;
8111b1dc:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b1e0:	e0bffc0f 	ldh	r2,-16(fp)
8111b1e4:	1009883a 	mov	r4,r2
8111b1e8:	11209340 	call	81120934 <cGetNextChar>
8111b1ec:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111b1f0:	d0e00317 	ldw	r3,-32756(gp)
8111b1f4:	e0bff947 	ldb	r2,-27(fp)
8111b1f8:	10800044 	addi	r2,r2,1
8111b1fc:	1885883a 	add	r2,r3,r2
8111b200:	10800003 	ldbu	r2,0(r2)
8111b204:	10803fcc 	andi	r2,r2,255
8111b208:	1080010c 	andi	r2,r2,4
8111b20c:	10000626 	beq	r2,zero,8111b228 <vLoadDefaultETHConf+0x3a4>
									(*p_inteiro) = c;
8111b210:	e0bffa17 	ldw	r2,-24(fp)
8111b214:	e0fff943 	ldbu	r3,-27(fp)
8111b218:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b21c:	e0bffa17 	ldw	r2,-24(fp)
8111b220:	10800044 	addi	r2,r2,1
8111b224:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b228:	e0bff947 	ldb	r2,-27(fp)
8111b22c:	10800ba0 	cmpeqi	r2,r2,46
8111b230:	1000031e 	bne	r2,zero,8111b240 <vLoadDefaultETHConf+0x3bc>
8111b234:	e0bff947 	ldb	r2,-27(fp)
8111b238:	10800ed8 	cmpnei	r2,r2,59
8111b23c:	103fe81e 	bne	r2,zero,8111b1e0 <__reset+0xfb0fb1e0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b240:	e0bffa17 	ldw	r2,-24(fp)
8111b244:	00c00284 	movi	r3,10
8111b248:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8111b24c:	e0bff903 	ldbu	r2,-28(fp)
8111b250:	108000e8 	cmpgeui	r2,r2,3
8111b254:	1000021e 	bne	r2,zero,8111b260 <vLoadDefaultETHConf+0x3dc>
8111b258:	e43ff903 	ldbu	r16,-28(fp)
8111b25c:	00000106 	br	8111b264 <vLoadDefaultETHConf+0x3e0>
8111b260:	040000c4 	movi	r16,3
8111b264:	e0bffd04 	addi	r2,fp,-12
8111b268:	1009883a 	mov	r4,r2
8111b26c:	112312c0 	call	8112312c <atoi>
8111b270:	1007883a 	mov	r3,r2
8111b274:	00a045f4 	movhi	r2,33047
8111b278:	10a26004 	addi	r2,r2,-30336
8111b27c:	1405883a 	add	r2,r2,r16
8111b280:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b284:	e0bffd04 	addi	r2,fp,-12
8111b288:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111b28c:	e0bff903 	ldbu	r2,-28(fp)
8111b290:	10800044 	addi	r2,r2,1
8111b294:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111b298:	e0bff947 	ldb	r2,-27(fp)
8111b29c:	10800ed8 	cmpnei	r2,r2,59
8111b2a0:	103fcf1e 	bne	r2,zero,8111b1e0 <__reset+0xfb0fb1e0>

						break;
8111b2a4:	00011206 	br	8111b6f0 <vLoadDefaultETHConf+0x86c>
					case 'G':

						ucParser = 0;
8111b2a8:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b2ac:	e0bffc0f 	ldh	r2,-16(fp)
8111b2b0:	1009883a 	mov	r4,r2
8111b2b4:	11209340 	call	81120934 <cGetNextChar>
8111b2b8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111b2bc:	d0e00317 	ldw	r3,-32756(gp)
8111b2c0:	e0bff947 	ldb	r2,-27(fp)
8111b2c4:	10800044 	addi	r2,r2,1
8111b2c8:	1885883a 	add	r2,r3,r2
8111b2cc:	10800003 	ldbu	r2,0(r2)
8111b2d0:	10803fcc 	andi	r2,r2,255
8111b2d4:	1080010c 	andi	r2,r2,4
8111b2d8:	10000626 	beq	r2,zero,8111b2f4 <vLoadDefaultETHConf+0x470>
									(*p_inteiro) = c;
8111b2dc:	e0bffa17 	ldw	r2,-24(fp)
8111b2e0:	e0fff943 	ldbu	r3,-27(fp)
8111b2e4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b2e8:	e0bffa17 	ldw	r2,-24(fp)
8111b2ec:	10800044 	addi	r2,r2,1
8111b2f0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b2f4:	e0bff947 	ldb	r2,-27(fp)
8111b2f8:	10800ba0 	cmpeqi	r2,r2,46
8111b2fc:	1000031e 	bne	r2,zero,8111b30c <vLoadDefaultETHConf+0x488>
8111b300:	e0bff947 	ldb	r2,-27(fp)
8111b304:	10800ed8 	cmpnei	r2,r2,59
8111b308:	103fe81e 	bne	r2,zero,8111b2ac <__reset+0xfb0fb2ac>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b30c:	e0bffa17 	ldw	r2,-24(fp)
8111b310:	00c00284 	movi	r3,10
8111b314:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8111b318:	e0bff903 	ldbu	r2,-28(fp)
8111b31c:	108000e8 	cmpgeui	r2,r2,3
8111b320:	1000021e 	bne	r2,zero,8111b32c <vLoadDefaultETHConf+0x4a8>
8111b324:	e43ff903 	ldbu	r16,-28(fp)
8111b328:	00000106 	br	8111b330 <vLoadDefaultETHConf+0x4ac>
8111b32c:	040000c4 	movi	r16,3
8111b330:	e0bffd04 	addi	r2,fp,-12
8111b334:	1009883a 	mov	r4,r2
8111b338:	112312c0 	call	8112312c <atoi>
8111b33c:	1007883a 	mov	r3,r2
8111b340:	00a045f4 	movhi	r2,33047
8111b344:	10a26004 	addi	r2,r2,-30336
8111b348:	1405883a 	add	r2,r2,r16
8111b34c:	10800104 	addi	r2,r2,4
8111b350:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b354:	e0bffd04 	addi	r2,fp,-12
8111b358:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111b35c:	e0bff903 	ldbu	r2,-28(fp)
8111b360:	10800044 	addi	r2,r2,1
8111b364:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111b368:	e0bff947 	ldb	r2,-27(fp)
8111b36c:	10800ed8 	cmpnei	r2,r2,59
8111b370:	103fce1e 	bne	r2,zero,8111b2ac <__reset+0xfb0fb2ac>

						break;
8111b374:	0000de06 	br	8111b6f0 <vLoadDefaultETHConf+0x86c>
					case 'P':
						ucParser = 0;
8111b378:	e03ff905 	stb	zero,-28(fp)
						do {
							c = cGetNextChar(siFile);
8111b37c:	e0bffc0f 	ldh	r2,-16(fp)
8111b380:	1009883a 	mov	r4,r2
8111b384:	11209340 	call	81120934 <cGetNextChar>
8111b388:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111b38c:	d0e00317 	ldw	r3,-32756(gp)
8111b390:	e0bff947 	ldb	r2,-27(fp)
8111b394:	10800044 	addi	r2,r2,1
8111b398:	1885883a 	add	r2,r3,r2
8111b39c:	10800003 	ldbu	r2,0(r2)
8111b3a0:	10803fcc 	andi	r2,r2,255
8111b3a4:	1080010c 	andi	r2,r2,4
8111b3a8:	10000626 	beq	r2,zero,8111b3c4 <vLoadDefaultETHConf+0x540>
								(*p_inteiro) = c;
8111b3ac:	e0bffa17 	ldw	r2,-24(fp)
8111b3b0:	e0fff943 	ldbu	r3,-27(fp)
8111b3b4:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b3b8:	e0bffa17 	ldw	r2,-24(fp)
8111b3bc:	10800044 	addi	r2,r2,1
8111b3c0:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b3c4:	e0bff947 	ldb	r2,-27(fp)
8111b3c8:	10800ed8 	cmpnei	r2,r2,59
8111b3cc:	103feb1e 	bne	r2,zero,8111b37c <__reset+0xfb0fb37c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b3d0:	e0bffa17 	ldw	r2,-24(fp)
8111b3d4:	00c00284 	movi	r3,10
8111b3d8:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = (unsigned short int)atoi( inteiro );
8111b3dc:	e0bffd04 	addi	r2,fp,-12
8111b3e0:	1009883a 	mov	r4,r2
8111b3e4:	112312c0 	call	8112312c <atoi>
8111b3e8:	1007883a 	mov	r3,r2
8111b3ec:	00a045f4 	movhi	r2,33047
8111b3f0:	10a26004 	addi	r2,r2,-30336
8111b3f4:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b3f8:	e0bffd04 	addi	r2,fp,-12
8111b3fc:	e0bffa15 	stw	r2,-24(fp)

						break;
8111b400:	0000bb06 	br	8111b6f0 <vLoadDefaultETHConf+0x86c>
					case 'H':

						do {
							c = cGetNextChar(siFile);
8111b404:	e0bffc0f 	ldh	r2,-16(fp)
8111b408:	1009883a 	mov	r4,r2
8111b40c:	11209340 	call	81120934 <cGetNextChar>
8111b410:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111b414:	d0e00317 	ldw	r3,-32756(gp)
8111b418:	e0bff947 	ldb	r2,-27(fp)
8111b41c:	10800044 	addi	r2,r2,1
8111b420:	1885883a 	add	r2,r3,r2
8111b424:	10800003 	ldbu	r2,0(r2)
8111b428:	10803fcc 	andi	r2,r2,255
8111b42c:	1080010c 	andi	r2,r2,4
8111b430:	10000626 	beq	r2,zero,8111b44c <vLoadDefaultETHConf+0x5c8>
								(*p_inteiro) = c;
8111b434:	e0bffa17 	ldw	r2,-24(fp)
8111b438:	e0fff943 	ldbu	r3,-27(fp)
8111b43c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b440:	e0bffa17 	ldw	r2,-24(fp)
8111b444:	10800044 	addi	r2,r2,1
8111b448:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b44c:	e0bff947 	ldb	r2,-27(fp)
8111b450:	10800ed8 	cmpnei	r2,r2,59
8111b454:	103feb1e 	bne	r2,zero,8111b404 <__reset+0xfb0fb404>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b458:	e0bffa17 	ldw	r2,-24(fp)
8111b45c:	00c00284 	movi	r3,10
8111b460:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111b464:	e0bffd04 	addi	r2,fp,-12
8111b468:	1009883a 	mov	r4,r2
8111b46c:	112312c0 	call	8112312c <atoi>
8111b470:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
8111b474:	e0bffc8f 	ldh	r2,-14(fp)
8111b478:	10800058 	cmpnei	r2,r2,1
8111b47c:	1000051e 	bne	r2,zero,8111b494 <vLoadDefaultETHConf+0x610>
							xConfEth.bDHCP = TRUE;
8111b480:	00a045f4 	movhi	r2,33047
8111b484:	10a26004 	addi	r2,r2,-30336
8111b488:	00c00044 	movi	r3,1
8111b48c:	10c00615 	stw	r3,24(r2)
8111b490:	00000306 	br	8111b4a0 <vLoadDefaultETHConf+0x61c>
						else
							xConfEth.bDHCP = FALSE;
8111b494:	00a045f4 	movhi	r2,33047
8111b498:	10a26004 	addi	r2,r2,-30336
8111b49c:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b4a0:	e0bffd04 	addi	r2,fp,-12
8111b4a4:	e0bffa15 	stw	r2,-24(fp)

						break;
8111b4a8:	00009106 	br	8111b6f0 <vLoadDefaultETHConf+0x86c>

					case 'S':

						ucParser = 0;
8111b4ac:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b4b0:	e0bffc0f 	ldh	r2,-16(fp)
8111b4b4:	1009883a 	mov	r4,r2
8111b4b8:	11209340 	call	81120934 <cGetNextChar>
8111b4bc:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111b4c0:	d0e00317 	ldw	r3,-32756(gp)
8111b4c4:	e0bff947 	ldb	r2,-27(fp)
8111b4c8:	10800044 	addi	r2,r2,1
8111b4cc:	1885883a 	add	r2,r3,r2
8111b4d0:	10800003 	ldbu	r2,0(r2)
8111b4d4:	10803fcc 	andi	r2,r2,255
8111b4d8:	1080010c 	andi	r2,r2,4
8111b4dc:	10000626 	beq	r2,zero,8111b4f8 <vLoadDefaultETHConf+0x674>
									(*p_inteiro) = c;
8111b4e0:	e0bffa17 	ldw	r2,-24(fp)
8111b4e4:	e0fff943 	ldbu	r3,-27(fp)
8111b4e8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b4ec:	e0bffa17 	ldw	r2,-24(fp)
8111b4f0:	10800044 	addi	r2,r2,1
8111b4f4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b4f8:	e0bff947 	ldb	r2,-27(fp)
8111b4fc:	10800ba0 	cmpeqi	r2,r2,46
8111b500:	1000031e 	bne	r2,zero,8111b510 <vLoadDefaultETHConf+0x68c>
8111b504:	e0bff947 	ldb	r2,-27(fp)
8111b508:	10800ed8 	cmpnei	r2,r2,59
8111b50c:	103fe81e 	bne	r2,zero,8111b4b0 <__reset+0xfb0fb4b0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b510:	e0bffa17 	ldw	r2,-24(fp)
8111b514:	00c00284 	movi	r3,10
8111b518:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8111b51c:	e0bff903 	ldbu	r2,-28(fp)
8111b520:	108000e8 	cmpgeui	r2,r2,3
8111b524:	1000021e 	bne	r2,zero,8111b530 <vLoadDefaultETHConf+0x6ac>
8111b528:	e43ff903 	ldbu	r16,-28(fp)
8111b52c:	00000106 	br	8111b534 <vLoadDefaultETHConf+0x6b0>
8111b530:	040000c4 	movi	r16,3
8111b534:	e0bffd04 	addi	r2,fp,-12
8111b538:	1009883a 	mov	r4,r2
8111b53c:	112312c0 	call	8112312c <atoi>
8111b540:	1007883a 	mov	r3,r2
8111b544:	00a045f4 	movhi	r2,33047
8111b548:	10a26004 	addi	r2,r2,-30336
8111b54c:	1405883a 	add	r2,r2,r16
8111b550:	10800204 	addi	r2,r2,8
8111b554:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b558:	e0bffd04 	addi	r2,fp,-12
8111b55c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111b560:	e0bff903 	ldbu	r2,-28(fp)
8111b564:	10800044 	addi	r2,r2,1
8111b568:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111b56c:	e0bff947 	ldb	r2,-27(fp)
8111b570:	10800ed8 	cmpnei	r2,r2,59
8111b574:	103fce1e 	bne	r2,zero,8111b4b0 <__reset+0xfb0fb4b0>

						break;
8111b578:	00005d06 	br	8111b6f0 <vLoadDefaultETHConf+0x86c>
					case 'D':

						ucParser = 0;
8111b57c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b580:	e0bffc0f 	ldh	r2,-16(fp)
8111b584:	1009883a 	mov	r4,r2
8111b588:	11209340 	call	81120934 <cGetNextChar>
8111b58c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111b590:	d0e00317 	ldw	r3,-32756(gp)
8111b594:	e0bff947 	ldb	r2,-27(fp)
8111b598:	10800044 	addi	r2,r2,1
8111b59c:	1885883a 	add	r2,r3,r2
8111b5a0:	10800003 	ldbu	r2,0(r2)
8111b5a4:	10803fcc 	andi	r2,r2,255
8111b5a8:	1080010c 	andi	r2,r2,4
8111b5ac:	10000626 	beq	r2,zero,8111b5c8 <vLoadDefaultETHConf+0x744>
									(*p_inteiro) = c;
8111b5b0:	e0bffa17 	ldw	r2,-24(fp)
8111b5b4:	e0fff943 	ldbu	r3,-27(fp)
8111b5b8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b5bc:	e0bffa17 	ldw	r2,-24(fp)
8111b5c0:	10800044 	addi	r2,r2,1
8111b5c4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b5c8:	e0bff947 	ldb	r2,-27(fp)
8111b5cc:	10800ba0 	cmpeqi	r2,r2,46
8111b5d0:	1000031e 	bne	r2,zero,8111b5e0 <vLoadDefaultETHConf+0x75c>
8111b5d4:	e0bff947 	ldb	r2,-27(fp)
8111b5d8:	10800ed8 	cmpnei	r2,r2,59
8111b5dc:	103fe81e 	bne	r2,zero,8111b580 <__reset+0xfb0fb580>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b5e0:	e0bffa17 	ldw	r2,-24(fp)
8111b5e4:	00c00284 	movi	r3,10
8111b5e8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8111b5ec:	e0bff903 	ldbu	r2,-28(fp)
8111b5f0:	108000e8 	cmpgeui	r2,r2,3
8111b5f4:	1000021e 	bne	r2,zero,8111b600 <vLoadDefaultETHConf+0x77c>
8111b5f8:	e43ff903 	ldbu	r16,-28(fp)
8111b5fc:	00000106 	br	8111b604 <vLoadDefaultETHConf+0x780>
8111b600:	040000c4 	movi	r16,3
8111b604:	e0bffd04 	addi	r2,fp,-12
8111b608:	1009883a 	mov	r4,r2
8111b60c:	112312c0 	call	8112312c <atoi>
8111b610:	1007883a 	mov	r3,r2
8111b614:	00a045f4 	movhi	r2,33047
8111b618:	10a26004 	addi	r2,r2,-30336
8111b61c:	1405883a 	add	r2,r2,r16
8111b620:	10800304 	addi	r2,r2,12
8111b624:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b628:	e0bffd04 	addi	r2,fp,-12
8111b62c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111b630:	e0bff903 	ldbu	r2,-28(fp)
8111b634:	10800044 	addi	r2,r2,1
8111b638:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111b63c:	e0bff947 	ldb	r2,-27(fp)
8111b640:	10800ed8 	cmpnei	r2,r2,59
8111b644:	103fce1e 	bne	r2,zero,8111b580 <__reset+0xfb0fb580>

						break;						
8111b648:	00002906 	br	8111b6f0 <vLoadDefaultETHConf+0x86c>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111b64c:	e0bffc0f 	ldh	r2,-16(fp)
8111b650:	1009883a 	mov	r4,r2
8111b654:	11208f40 	call	811208f4 <siCloseFile>
8111b658:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
8111b65c:	e0bffb17 	ldw	r2,-20(fp)
8111b660:	10000d1e 	bne	r2,zero,8111b698 <vLoadDefaultETHConf+0x814>
							#if DEBUG_ON
							if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111b664:	00a045f4 	movhi	r2,33047
8111b668:	10a25304 	addi	r2,r2,-30388
8111b66c:	10800a8b 	ldhu	r2,42(r2)
8111b670:	10bfffcc 	andi	r2,r2,65535
8111b674:	10800228 	cmpgeui	r2,r2,8
8111b678:	1000071e 	bne	r2,zero,8111b698 <vLoadDefaultETHConf+0x814>
								debug(fp,"SDCard: Can't close the file.\n");
8111b67c:	d0a06217 	ldw	r2,-32376(gp)
8111b680:	100f883a 	mov	r7,r2
8111b684:	01800784 	movi	r6,30
8111b688:	01400044 	movi	r5,1
8111b68c:	01204574 	movhi	r4,33045
8111b690:	2101ff04 	addi	r4,r4,2044
8111b694:	112393c0 	call	8112393c <fwrite>
							}
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111b698:	00800044 	movi	r2,1
8111b69c:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
8111b6a0:	00800044 	movi	r2,1
8111b6a4:	e0bff715 	stw	r2,-36(fp)
						break;
8111b6a8:	00001106 	br	8111b6f0 <vLoadDefaultETHConf+0x86c>
					default:
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111b6ac:	00a045f4 	movhi	r2,33047
8111b6b0:	10a25304 	addi	r2,r2,-30388
8111b6b4:	10800a8b 	ldhu	r2,42(r2)
8111b6b8:	10bfffcc 	andi	r2,r2,65535
8111b6bc:	10800228 	cmpgeui	r2,r2,8
8111b6c0:	10000a1e 	bne	r2,zero,8111b6ec <vLoadDefaultETHConf+0x868>
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111b6c4:	d0a06217 	ldw	r2,-32376(gp)
8111b6c8:	100f883a 	mov	r7,r2
8111b6cc:	01800844 	movi	r6,33
8111b6d0:	01400044 	movi	r5,1
8111b6d4:	01204574 	movhi	r4,33045
8111b6d8:	21020704 	addi	r4,r4,2076
8111b6dc:	112393c0 	call	8112393c <fwrite>
						}
						#endif
						break;
8111b6e0:	00000206 	br	8111b6ec <vLoadDefaultETHConf+0x868>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111b6e4:	0001883a 	nop
8111b6e8:	00000106 	br	8111b6f0 <vLoadDefaultETHConf+0x86c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
							fprintf(fp,"SDCard: Problem with the parser.\n");
						}
						#endif
						break;
8111b6ec:	0001883a 	nop
				}
			} while ( bEOF == FALSE );
8111b6f0:	e0bff817 	ldw	r2,-32(fp)
8111b6f4:	103e0126 	beq	r2,zero,8111aefc <__reset+0xfb0faefc>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111b6f8:	00001c06 	br	8111b76c <vLoadDefaultETHConf+0x8e8>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111b6fc:	00a045f4 	movhi	r2,33047
8111b700:	10a25304 	addi	r2,r2,-30388
8111b704:	10800a8b 	ldhu	r2,42(r2)
8111b708:	10bfffcc 	andi	r2,r2,65535
8111b70c:	10800228 	cmpgeui	r2,r2,8
8111b710:	1000161e 	bne	r2,zero,8111b76c <vLoadDefaultETHConf+0x8e8>
				fprintf(fp,"SDCard: File not found.\n");
8111b714:	d0a06217 	ldw	r2,-32376(gp)
8111b718:	100f883a 	mov	r7,r2
8111b71c:	01800604 	movi	r6,24
8111b720:	01400044 	movi	r5,1
8111b724:	01204574 	movhi	r4,33045
8111b728:	21021004 	addi	r4,r4,2112
8111b72c:	112393c0 	call	8112393c <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111b730:	00000e06 	br	8111b76c <vLoadDefaultETHConf+0x8e8>
			}
			#endif
		}
	} else {
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111b734:	00a045f4 	movhi	r2,33047
8111b738:	10a25304 	addi	r2,r2,-30388
8111b73c:	10800a8b 	ldhu	r2,42(r2)
8111b740:	10bfffcc 	andi	r2,r2,65535
8111b744:	10800228 	cmpgeui	r2,r2,8
8111b748:	1000091e 	bne	r2,zero,8111b770 <vLoadDefaultETHConf+0x8ec>
			fprintf(fp,"SDCard: No SDCard.\n");
8111b74c:	d0a06217 	ldw	r2,-32376(gp)
8111b750:	100f883a 	mov	r7,r2
8111b754:	018004c4 	movi	r6,19
8111b758:	01400044 	movi	r5,1
8111b75c:	01204574 	movhi	r4,33045
8111b760:	21021704 	addi	r4,r4,2140
8111b764:	112393c0 	call	8112393c <fwrite>
8111b768:	00000106 	br	8111b770 <vLoadDefaultETHConf+0x8ec>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111b76c:	0001883a 	nop
			fprintf(fp,"SDCard: No SDCard.\n");
		}
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
8111b770:	e0bff717 	ldw	r2,-36(fp)
8111b774:	10004c1e 	bne	r2,zero,8111b8a8 <vLoadDefaultETHConf+0xa24>
		xConfEth.siPortPUS = 17000;
8111b778:	00a045f4 	movhi	r2,33047
8111b77c:	10a26004 	addi	r2,r2,-30336
8111b780:	00d09a04 	movi	r3,17000
8111b784:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
8111b788:	00a045f4 	movhi	r2,33047
8111b78c:	10a26004 	addi	r2,r2,-30336
8111b790:	00fff004 	movi	r3,-64
8111b794:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
8111b798:	00a045f4 	movhi	r2,33047
8111b79c:	10a26004 	addi	r2,r2,-30336
8111b7a0:	00ffea04 	movi	r3,-88
8111b7a4:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
8111b7a8:	00a045f4 	movhi	r2,33047
8111b7ac:	10a26004 	addi	r2,r2,-30336
8111b7b0:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
8111b7b4:	00a045f4 	movhi	r2,33047
8111b7b8:	10a26004 	addi	r2,r2,-30336
8111b7bc:	00c00144 	movi	r3,5
8111b7c0:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
8111b7c4:	00a045f4 	movhi	r2,33047
8111b7c8:	10a26004 	addi	r2,r2,-30336
8111b7cc:	00fff004 	movi	r3,-64
8111b7d0:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
8111b7d4:	00a045f4 	movhi	r2,33047
8111b7d8:	10a26004 	addi	r2,r2,-30336
8111b7dc:	00ffea04 	movi	r3,-88
8111b7e0:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
8111b7e4:	00a045f4 	movhi	r2,33047
8111b7e8:	10a26004 	addi	r2,r2,-30336
8111b7ec:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
8111b7f0:	00a045f4 	movhi	r2,33047
8111b7f4:	10a26004 	addi	r2,r2,-30336
8111b7f8:	00c00044 	movi	r3,1
8111b7fc:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
8111b800:	00a045f4 	movhi	r2,33047
8111b804:	10a26004 	addi	r2,r2,-30336
8111b808:	00ffffc4 	movi	r3,-1
8111b80c:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
8111b810:	00a045f4 	movhi	r2,33047
8111b814:	10a26004 	addi	r2,r2,-30336
8111b818:	00ffffc4 	movi	r3,-1
8111b81c:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
8111b820:	00a045f4 	movhi	r2,33047
8111b824:	10a26004 	addi	r2,r2,-30336
8111b828:	00ffffc4 	movi	r3,-1
8111b82c:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
8111b830:	00a045f4 	movhi	r2,33047
8111b834:	10a26004 	addi	r2,r2,-30336
8111b838:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
8111b83c:	00a045f4 	movhi	r2,33047
8111b840:	10a26004 	addi	r2,r2,-30336
8111b844:	00ffff04 	movi	r3,-4
8111b848:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
8111b84c:	00a045f4 	movhi	r2,33047
8111b850:	10a26004 	addi	r2,r2,-30336
8111b854:	00fffdc4 	movi	r3,-9
8111b858:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
8111b85c:	00a045f4 	movhi	r2,33047
8111b860:	10a26004 	addi	r2,r2,-30336
8111b864:	00c018c4 	movi	r3,99
8111b868:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
8111b86c:	00a045f4 	movhi	r2,33047
8111b870:	10a26004 	addi	r2,r2,-30336
8111b874:	00c01344 	movi	r3,77
8111b878:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
8111b87c:	00a045f4 	movhi	r2,33047
8111b880:	10a26004 	addi	r2,r2,-30336
8111b884:	00c007c4 	movi	r3,31
8111b888:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
8111b88c:	00a045f4 	movhi	r2,33047
8111b890:	10a26004 	addi	r2,r2,-30336
8111b894:	00c01084 	movi	r3,66
8111b898:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
8111b89c:	00a045f4 	movhi	r2,33047
8111b8a0:	10a26004 	addi	r2,r2,-30336
8111b8a4:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
8111b8a8:	e0bff717 	ldw	r2,-36(fp)
}
8111b8ac:	e6ffff04 	addi	sp,fp,-4
8111b8b0:	dfc00217 	ldw	ra,8(sp)
8111b8b4:	df000117 	ldw	fp,4(sp)
8111b8b8:	dc000017 	ldw	r16,0(sp)
8111b8bc:	dec00304 	addi	sp,sp,12
8111b8c0:	f800283a 	ret

8111b8c4 <vShowEthConfig>:

#if DEBUG_ON
	void vShowEthConfig( void ) {
8111b8c4:	defff004 	addi	sp,sp,-64
8111b8c8:	de00012e 	bgeu	sp,et,8111b8d0 <vShowEthConfig+0xc>
8111b8cc:	003b68fa 	trap	3
8111b8d0:	dfc00f15 	stw	ra,60(sp)
8111b8d4:	df000e15 	stw	fp,56(sp)
8111b8d8:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
8111b8dc:	d0a06217 	ldw	r2,-32376(gp)
8111b8e0:	100f883a 	mov	r7,r2
8111b8e4:	018007c4 	movi	r6,31
8111b8e8:	01400044 	movi	r5,1
8111b8ec:	01204574 	movhi	r4,33045
8111b8f0:	21021c04 	addi	r4,r4,2160
8111b8f4:	112393c0 	call	8112393c <fwrite>

		memset(buffer,0,40);
8111b8f8:	01800a04 	movi	r6,40
8111b8fc:	000b883a 	mov	r5,zero
8111b900:	e13ff604 	addi	r4,fp,-40
8111b904:	11244a00 	call	811244a0 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
8111b908:	00a045f4 	movhi	r2,33047
8111b90c:	10a26004 	addi	r2,r2,-30336
8111b910:	10800403 	ldbu	r2,16(r2)
8111b914:	11803fcc 	andi	r6,r2,255
8111b918:	00a045f4 	movhi	r2,33047
8111b91c:	10a26004 	addi	r2,r2,-30336
8111b920:	10800443 	ldbu	r2,17(r2)
8111b924:	11c03fcc 	andi	r7,r2,255
8111b928:	00a045f4 	movhi	r2,33047
8111b92c:	10a26004 	addi	r2,r2,-30336
8111b930:	10800483 	ldbu	r2,18(r2)
8111b934:	10c03fcc 	andi	r3,r2,255
8111b938:	00a045f4 	movhi	r2,33047
8111b93c:	10a26004 	addi	r2,r2,-30336
8111b940:	108004c3 	ldbu	r2,19(r2)
8111b944:	11003fcc 	andi	r4,r2,255
8111b948:	00a045f4 	movhi	r2,33047
8111b94c:	10a26004 	addi	r2,r2,-30336
8111b950:	10800503 	ldbu	r2,20(r2)
8111b954:	11403fcc 	andi	r5,r2,255
8111b958:	00a045f4 	movhi	r2,33047
8111b95c:	10a26004 	addi	r2,r2,-30336
8111b960:	10800543 	ldbu	r2,21(r2)
8111b964:	10803fcc 	andi	r2,r2,255
8111b968:	d8800315 	stw	r2,12(sp)
8111b96c:	d9400215 	stw	r5,8(sp)
8111b970:	d9000115 	stw	r4,4(sp)
8111b974:	d8c00015 	stw	r3,0(sp)
8111b978:	01604574 	movhi	r5,33045
8111b97c:	29422404 	addi	r5,r5,2192
8111b980:	e13ff604 	addi	r4,fp,-40
8111b984:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, buffer );
8111b988:	d0a06217 	ldw	r2,-32376(gp)
8111b98c:	e17ff604 	addi	r5,fp,-40
8111b990:	1009883a 	mov	r4,r2
8111b994:	11232a00 	call	811232a0 <fprintf>

		memset(buffer,0,40);
8111b998:	01800a04 	movi	r6,40
8111b99c:	000b883a 	mov	r5,zero
8111b9a0:	e13ff604 	addi	r4,fp,-40
8111b9a4:	11244a00 	call	811244a0 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
8111b9a8:	00a045f4 	movhi	r2,33047
8111b9ac:	10a26004 	addi	r2,r2,-30336
8111b9b0:	10800003 	ldbu	r2,0(r2)
8111b9b4:	11003fcc 	andi	r4,r2,255
8111b9b8:	00a045f4 	movhi	r2,33047
8111b9bc:	10a26004 	addi	r2,r2,-30336
8111b9c0:	10800043 	ldbu	r2,1(r2)
8111b9c4:	11403fcc 	andi	r5,r2,255
8111b9c8:	00a045f4 	movhi	r2,33047
8111b9cc:	10a26004 	addi	r2,r2,-30336
8111b9d0:	10800083 	ldbu	r2,2(r2)
8111b9d4:	10c03fcc 	andi	r3,r2,255
8111b9d8:	00a045f4 	movhi	r2,33047
8111b9dc:	10a26004 	addi	r2,r2,-30336
8111b9e0:	108000c3 	ldbu	r2,3(r2)
8111b9e4:	10803fcc 	andi	r2,r2,255
8111b9e8:	d8800115 	stw	r2,4(sp)
8111b9ec:	d8c00015 	stw	r3,0(sp)
8111b9f0:	280f883a 	mov	r7,r5
8111b9f4:	200d883a 	mov	r6,r4
8111b9f8:	01604574 	movhi	r5,33045
8111b9fc:	29422d04 	addi	r5,r5,2228
8111ba00:	e13ff604 	addi	r4,fp,-40
8111ba04:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, buffer );
8111ba08:	d0a06217 	ldw	r2,-32376(gp)
8111ba0c:	e17ff604 	addi	r5,fp,-40
8111ba10:	1009883a 	mov	r4,r2
8111ba14:	11232a00 	call	811232a0 <fprintf>

		memset(buffer,0,40);
8111ba18:	01800a04 	movi	r6,40
8111ba1c:	000b883a 	mov	r5,zero
8111ba20:	e13ff604 	addi	r4,fp,-40
8111ba24:	11244a00 	call	811244a0 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
8111ba28:	00a045f4 	movhi	r2,33047
8111ba2c:	10a26004 	addi	r2,r2,-30336
8111ba30:	10800103 	ldbu	r2,4(r2)
8111ba34:	11003fcc 	andi	r4,r2,255
8111ba38:	00a045f4 	movhi	r2,33047
8111ba3c:	10a26004 	addi	r2,r2,-30336
8111ba40:	10800143 	ldbu	r2,5(r2)
8111ba44:	11403fcc 	andi	r5,r2,255
8111ba48:	00a045f4 	movhi	r2,33047
8111ba4c:	10a26004 	addi	r2,r2,-30336
8111ba50:	10800183 	ldbu	r2,6(r2)
8111ba54:	10c03fcc 	andi	r3,r2,255
8111ba58:	00a045f4 	movhi	r2,33047
8111ba5c:	10a26004 	addi	r2,r2,-30336
8111ba60:	108001c3 	ldbu	r2,7(r2)
8111ba64:	10803fcc 	andi	r2,r2,255
8111ba68:	d8800115 	stw	r2,4(sp)
8111ba6c:	d8c00015 	stw	r3,0(sp)
8111ba70:	280f883a 	mov	r7,r5
8111ba74:	200d883a 	mov	r6,r4
8111ba78:	01604574 	movhi	r5,33045
8111ba7c:	29423304 	addi	r5,r5,2252
8111ba80:	e13ff604 	addi	r4,fp,-40
8111ba84:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, buffer );
8111ba88:	d0a06217 	ldw	r2,-32376(gp)
8111ba8c:	e17ff604 	addi	r5,fp,-40
8111ba90:	1009883a 	mov	r4,r2
8111ba94:	11232a00 	call	811232a0 <fprintf>

		memset(buffer,0,40);
8111ba98:	01800a04 	movi	r6,40
8111ba9c:	000b883a 	mov	r5,zero
8111baa0:	e13ff604 	addi	r4,fp,-40
8111baa4:	11244a00 	call	811244a0 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
8111baa8:	00a045f4 	movhi	r2,33047
8111baac:	10a26004 	addi	r2,r2,-30336
8111bab0:	10800203 	ldbu	r2,8(r2)
8111bab4:	11003fcc 	andi	r4,r2,255
8111bab8:	00a045f4 	movhi	r2,33047
8111babc:	10a26004 	addi	r2,r2,-30336
8111bac0:	10800243 	ldbu	r2,9(r2)
8111bac4:	11403fcc 	andi	r5,r2,255
8111bac8:	00a045f4 	movhi	r2,33047
8111bacc:	10a26004 	addi	r2,r2,-30336
8111bad0:	10800283 	ldbu	r2,10(r2)
8111bad4:	10c03fcc 	andi	r3,r2,255
8111bad8:	00a045f4 	movhi	r2,33047
8111badc:	10a26004 	addi	r2,r2,-30336
8111bae0:	108002c3 	ldbu	r2,11(r2)
8111bae4:	10803fcc 	andi	r2,r2,255
8111bae8:	d8800115 	stw	r2,4(sp)
8111baec:	d8c00015 	stw	r3,0(sp)
8111baf0:	280f883a 	mov	r7,r5
8111baf4:	200d883a 	mov	r6,r4
8111baf8:	01604574 	movhi	r5,33045
8111bafc:	29423a04 	addi	r5,r5,2280
8111bb00:	e13ff604 	addi	r4,fp,-40
8111bb04:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, buffer );
8111bb08:	d0a06217 	ldw	r2,-32376(gp)
8111bb0c:	e17ff604 	addi	r5,fp,-40
8111bb10:	1009883a 	mov	r4,r2
8111bb14:	11232a00 	call	811232a0 <fprintf>

		memset(buffer,0,40);
8111bb18:	01800a04 	movi	r6,40
8111bb1c:	000b883a 	mov	r5,zero
8111bb20:	e13ff604 	addi	r4,fp,-40
8111bb24:	11244a00 	call	811244a0 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
8111bb28:	00a045f4 	movhi	r2,33047
8111bb2c:	10a26004 	addi	r2,r2,-30336
8111bb30:	10800303 	ldbu	r2,12(r2)
8111bb34:	11003fcc 	andi	r4,r2,255
8111bb38:	00a045f4 	movhi	r2,33047
8111bb3c:	10a26004 	addi	r2,r2,-30336
8111bb40:	10800343 	ldbu	r2,13(r2)
8111bb44:	11403fcc 	andi	r5,r2,255
8111bb48:	00a045f4 	movhi	r2,33047
8111bb4c:	10a26004 	addi	r2,r2,-30336
8111bb50:	10800383 	ldbu	r2,14(r2)
8111bb54:	10c03fcc 	andi	r3,r2,255
8111bb58:	00a045f4 	movhi	r2,33047
8111bb5c:	10a26004 	addi	r2,r2,-30336
8111bb60:	108003c3 	ldbu	r2,15(r2)
8111bb64:	10803fcc 	andi	r2,r2,255
8111bb68:	d8800115 	stw	r2,4(sp)
8111bb6c:	d8c00015 	stw	r3,0(sp)
8111bb70:	280f883a 	mov	r7,r5
8111bb74:	200d883a 	mov	r6,r4
8111bb78:	01604574 	movhi	r5,33045
8111bb7c:	29424104 	addi	r5,r5,2308
8111bb80:	e13ff604 	addi	r4,fp,-40
8111bb84:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, buffer );
8111bb88:	d0a06217 	ldw	r2,-32376(gp)
8111bb8c:	e17ff604 	addi	r5,fp,-40
8111bb90:	1009883a 	mov	r4,r2
8111bb94:	11232a00 	call	811232a0 <fprintf>

		memset(buffer,0,40);
8111bb98:	01800a04 	movi	r6,40
8111bb9c:	000b883a 	mov	r5,zero
8111bba0:	e13ff604 	addi	r4,fp,-40
8111bba4:	11244a00 	call	811244a0 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
8111bba8:	00a045f4 	movhi	r2,33047
8111bbac:	10a26004 	addi	r2,r2,-30336
8111bbb0:	1080058b 	ldhu	r2,22(r2)
8111bbb4:	10bfffcc 	andi	r2,r2,65535
8111bbb8:	100d883a 	mov	r6,r2
8111bbbc:	01604574 	movhi	r5,33045
8111bbc0:	29424804 	addi	r5,r5,2336
8111bbc4:	e13ff604 	addi	r4,fp,-40
8111bbc8:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, buffer );
8111bbcc:	d0a06217 	ldw	r2,-32376(gp)
8111bbd0:	e17ff604 	addi	r5,fp,-40
8111bbd4:	1009883a 	mov	r4,r2
8111bbd8:	11232a00 	call	811232a0 <fprintf>

	}
8111bbdc:	0001883a 	nop
8111bbe0:	e037883a 	mov	sp,fp
8111bbe4:	dfc00117 	ldw	ra,4(sp)
8111bbe8:	df000017 	ldw	fp,0(sp)
8111bbec:	dec00204 	addi	sp,sp,8
8111bbf0:	f800283a 	ret

8111bbf4 <vLoadDebugConfs>:
#endif




bool vLoadDebugConfs( void ){
8111bbf4:	deffee04 	addi	sp,sp,-72
8111bbf8:	de00012e 	bgeu	sp,et,8111bc00 <vLoadDebugConfs+0xc>
8111bbfc:	003b68fa 	trap	3
8111bc00:	dfc01115 	stw	ra,68(sp)
8111bc04:	df001015 	stw	fp,64(sp)
8111bc08:	dc000f15 	stw	r16,60(sp)
8111bc0c:	df001004 	addi	fp,sp,64
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8111bc10:	e03ff015 	stw	zero,-64(fp)
	bool bEOF = FALSE;
8111bc14:	e03ff115 	stw	zero,-60(fp)
	bool close = FALSE;
8111bc18:	e03ff515 	stw	zero,-44(fp)
	char c, *p_inteiro, *p_inteiroll;
	char inteiro[8];
	char inteiroll[24];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8111bc1c:	d0a07617 	ldw	r2,-32296(gp)
8111bc20:	10800058 	cmpnei	r2,r2,1
8111bc24:	1003e21e 	bne	r2,zero,8111cbb0 <vLoadDebugConfs+0xfbc>
8111bc28:	11207600 	call	81120760 <bSDcardIsPresent>
8111bc2c:	1003e026 	beq	r2,zero,8111cbb0 <vLoadDebugConfs+0xfbc>
8111bc30:	11207900 	call	81120790 <bSDcardFAT16Check>
8111bc34:	1003de26 	beq	r2,zero,8111cbb0 <vLoadDebugConfs+0xfbc>

		siFile = siOpenFile( DEBUG_FILE_NAME );
8111bc38:	01204574 	movhi	r4,33045
8111bc3c:	21024c04 	addi	r4,r4,2352
8111bc40:	11208b80 	call	811208b8 <siOpenFile>
8111bc44:	e0bff60d 	sth	r2,-40(fp)

		if ( siFile >= 0 ){
8111bc48:	e0bff60f 	ldh	r2,-40(fp)
8111bc4c:	1003d016 	blt	r2,zero,8111cb90 <vLoadDebugConfs+0xf9c>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8111bc50:	e0bff704 	addi	r2,fp,-36
8111bc54:	01800204 	movi	r6,8
8111bc58:	01400284 	movi	r5,10
8111bc5c:	1009883a 	mov	r4,r2
8111bc60:	11244a00 	call	811244a0 <memset>
			memset( &(inteiroll) , 10 , sizeof( inteiroll ) );
8111bc64:	e0bff904 	addi	r2,fp,-28
8111bc68:	01800604 	movi	r6,24
8111bc6c:	01400284 	movi	r5,10
8111bc70:	1009883a 	mov	r4,r2
8111bc74:	11244a00 	call	811244a0 <memset>
			p_inteiro = inteiro;
8111bc78:	e0bff704 	addi	r2,fp,-36
8111bc7c:	e0bff315 	stw	r2,-52(fp)
			p_inteiroll = inteiroll;
8111bc80:	e0bff904 	addi	r2,fp,-28
8111bc84:	e0bff415 	stw	r2,-48(fp)

			do {
				c = cGetNextChar(siFile);
8111bc88:	e0bff60f 	ldh	r2,-40(fp)
8111bc8c:	1009883a 	mov	r4,r2
8111bc90:	11209340 	call	81120934 <cGetNextChar>
8111bc94:	e0bff245 	stb	r2,-55(fp)
				//printf("%c \n", c);
				switch (c) {
8111bc98:	e0bff247 	ldb	r2,-55(fp)
8111bc9c:	10800084 	addi	r2,r2,2
8111bca0:	10c01768 	cmpgeui	r3,r2,93
8111bca4:	1803ae1e 	bne	r3,zero,8111cb60 <vLoadDebugConfs+0xf6c>
8111bca8:	100690ba 	slli	r3,r2,2
8111bcac:	00a044b4 	movhi	r2,33042
8111bcb0:	10af3004 	addi	r2,r2,-17216
8111bcb4:	1885883a 	add	r2,r3,r2
8111bcb8:	10800017 	ldw	r2,0(r2)
8111bcbc:	1000683a 	jmp	r2
8111bcc0:	8111be74 	orhi	r4,r16,18169
8111bcc4:	8111be68 	cmpgeui	r4,r16,18169
8111bcc8:	8111cb60 	cmpeqi	r4,r16,18221
8111bccc:	8111cb60 	cmpeqi	r4,r16,18221
8111bcd0:	8111cb60 	cmpeqi	r4,r16,18221
8111bcd4:	8111cb60 	cmpeqi	r4,r16,18221
8111bcd8:	8111cb60 	cmpeqi	r4,r16,18221
8111bcdc:	8111cb60 	cmpeqi	r4,r16,18221
8111bce0:	8111cb60 	cmpeqi	r4,r16,18221
8111bce4:	8111cb60 	cmpeqi	r4,r16,18221
8111bce8:	8111cb60 	cmpeqi	r4,r16,18221
8111bcec:	8111cb60 	cmpeqi	r4,r16,18221
8111bcf0:	8111cb80 	call	88111cb8 <__reset+0x20f1cb8>
8111bcf4:	8111cb60 	cmpeqi	r4,r16,18221
8111bcf8:	8111cb60 	cmpeqi	r4,r16,18221
8111bcfc:	8111cb80 	call	88111cb8 <__reset+0x20f1cb8>
8111bd00:	8111cb60 	cmpeqi	r4,r16,18221
8111bd04:	8111cb60 	cmpeqi	r4,r16,18221
8111bd08:	8111cb60 	cmpeqi	r4,r16,18221
8111bd0c:	8111cb60 	cmpeqi	r4,r16,18221
8111bd10:	8111cb60 	cmpeqi	r4,r16,18221
8111bd14:	8111cb60 	cmpeqi	r4,r16,18221
8111bd18:	8111cb60 	cmpeqi	r4,r16,18221
8111bd1c:	8111cb60 	cmpeqi	r4,r16,18221
8111bd20:	8111cb60 	cmpeqi	r4,r16,18221
8111bd24:	8111cb60 	cmpeqi	r4,r16,18221
8111bd28:	8111cb60 	cmpeqi	r4,r16,18221
8111bd2c:	8111cb60 	cmpeqi	r4,r16,18221
8111bd30:	8111cb60 	cmpeqi	r4,r16,18221
8111bd34:	8111cb60 	cmpeqi	r4,r16,18221
8111bd38:	8111cb60 	cmpeqi	r4,r16,18221
8111bd3c:	8111cb60 	cmpeqi	r4,r16,18221
8111bd40:	8111cb60 	cmpeqi	r4,r16,18221
8111bd44:	8111cb60 	cmpeqi	r4,r16,18221
8111bd48:	8111cb80 	call	88111cb8 <__reset+0x20f1cb8>
8111bd4c:	8111cb60 	cmpeqi	r4,r16,18221
8111bd50:	8111cb60 	cmpeqi	r4,r16,18221
8111bd54:	8111cb60 	cmpeqi	r4,r16,18221
8111bd58:	8111cb60 	cmpeqi	r4,r16,18221
8111bd5c:	8111cb60 	cmpeqi	r4,r16,18221
8111bd60:	8111cb60 	cmpeqi	r4,r16,18221
8111bd64:	8111be34 	orhi	r4,r16,18168
8111bd68:	8111cb60 	cmpeqi	r4,r16,18221
8111bd6c:	8111cb60 	cmpeqi	r4,r16,18221
8111bd70:	8111cb60 	cmpeqi	r4,r16,18221
8111bd74:	8111cb60 	cmpeqi	r4,r16,18221
8111bd78:	8111cb60 	cmpeqi	r4,r16,18221
8111bd7c:	8111cb60 	cmpeqi	r4,r16,18221
8111bd80:	8111cb60 	cmpeqi	r4,r16,18221
8111bd84:	8111cb60 	cmpeqi	r4,r16,18221
8111bd88:	8111cb60 	cmpeqi	r4,r16,18221
8111bd8c:	8111cb60 	cmpeqi	r4,r16,18221
8111bd90:	8111cb60 	cmpeqi	r4,r16,18221
8111bd94:	8111cb60 	cmpeqi	r4,r16,18221
8111bd98:	8111cb60 	cmpeqi	r4,r16,18221
8111bd9c:	8111cb60 	cmpeqi	r4,r16,18221
8111bda0:	8111cb60 	cmpeqi	r4,r16,18221
8111bda4:	8111cb60 	cmpeqi	r4,r16,18221
8111bda8:	8111cb60 	cmpeqi	r4,r16,18221
8111bdac:	8111cb60 	cmpeqi	r4,r16,18221
8111bdb0:	8111cb60 	cmpeqi	r4,r16,18221
8111bdb4:	8111cb60 	cmpeqi	r4,r16,18221
8111bdb8:	8111cb18 	cmpnei	r4,r16,18220
8111bdbc:	8111cb60 	cmpeqi	r4,r16,18221
8111bdc0:	8111cb60 	cmpeqi	r4,r16,18221
8111bdc4:	8111cb60 	cmpeqi	r4,r16,18221
8111bdc8:	8111cb60 	cmpeqi	r4,r16,18221
8111bdcc:	8111c15c 	xori	r4,r16,18181
8111bdd0:	8111c5cc 	andi	r4,r16,18199
8111bdd4:	8111c36c 	andhi	r4,r16,18189
8111bdd8:	8111c7ec 	andhi	r4,r16,18207
8111bddc:	8111c8fc 	xorhi	r4,r16,18211
8111bde0:	8111c654 	ori	r4,r16,18201
8111bde4:	8111cb60 	cmpeqi	r4,r16,18221
8111bde8:	8111c874 	orhi	r4,r16,18209
8111bdec:	8111cb60 	cmpeqi	r4,r16,18221
8111bdf0:	8111c53c 	xorhi	r4,r16,18196
8111bdf4:	8111c41c 	xori	r4,r16,18192
8111bdf8:	8111c20c 	andi	r4,r16,18184
8111bdfc:	8111c4ac 	andhi	r4,r16,18194
8111be00:	8111bffc 	xorhi	r4,r16,18175
8111be04:	8111c2bc 	xorhi	r4,r16,18186
8111be08:	8111bf4c 	andi	r4,r16,18173
8111be0c:	8111c6dc 	xori	r4,r16,18203
8111be10:	8111c0ac 	andhi	r4,r16,18178
8111be14:	8111be9c 	xori	r4,r16,18170
8111be18:	8111c9c8 	cmpgei	r4,r16,18215
8111be1c:	8111cb60 	cmpeqi	r4,r16,18221
8111be20:	8111cb60 	cmpeqi	r4,r16,18221
8111be24:	8111cb60 	cmpeqi	r4,r16,18221
8111be28:	8111cb60 	cmpeqi	r4,r16,18221
8111be2c:	8111c764 	muli	r4,r16,18205
8111be30:	8111ca70 	cmpltui	r4,r16,18217
					case 39:// single quote '
						c = cGetNextChar(siFile);
8111be34:	e0bff60f 	ldh	r2,-40(fp)
8111be38:	1009883a 	mov	r4,r2
8111be3c:	11209340 	call	81120934 <cGetNextChar>
8111be40:	e0bff245 	stb	r2,-55(fp)
						while ( c != 39 ){
8111be44:	00000406 	br	8111be58 <vLoadDebugConfs+0x264>
							c = cGetNextChar(siFile);
8111be48:	e0bff60f 	ldh	r2,-40(fp)
8111be4c:	1009883a 	mov	r4,r2
8111be50:	11209340 	call	81120934 <cGetNextChar>
8111be54:	e0bff245 	stb	r2,-55(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111be58:	e0bff247 	ldb	r2,-55(fp)
8111be5c:	108009d8 	cmpnei	r2,r2,39
8111be60:	103ff91e 	bne	r2,zero,8111be48 <__reset+0xfb0fbe48>
							c = cGetNextChar(siFile);
						}
						break;
8111be64:	00034706 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case -1: 	//EOF
						bEOF = TRUE;
8111be68:	00800044 	movi	r2,1
8111be6c:	e0bff115 	stw	r2,-60(fp)
						break;
8111be70:	00034406 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case -2: 	//EOF
						#if DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
8111be74:	d0a06217 	ldw	r2,-32376(gp)
8111be78:	100f883a 	mov	r7,r2
8111be7c:	018006c4 	movi	r6,27
8111be80:	01400044 	movi	r5,1
8111be84:	01204574 	movhi	r4,33045
8111be88:	2101f804 	addi	r4,r4,2016
8111be8c:	112393c0 	call	8112393c <fwrite>
						#endif
						bEOF = TRUE;
8111be90:	00800044 	movi	r2,1
8111be94:	e0bff115 	stw	r2,-60(fp)
						break;
8111be98:	00033a06 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;

					case 'S':
						ucParser = 0;
8111be9c:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111bea0:	e0bff60f 	ldh	r2,-40(fp)
8111bea4:	1009883a 	mov	r4,r2
8111bea8:	11209340 	call	81120934 <cGetNextChar>
8111beac:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111beb0:	d0e00317 	ldw	r3,-32756(gp)
8111beb4:	e0bff247 	ldb	r2,-55(fp)
8111beb8:	10800044 	addi	r2,r2,1
8111bebc:	1885883a 	add	r2,r3,r2
8111bec0:	10800003 	ldbu	r2,0(r2)
8111bec4:	10803fcc 	andi	r2,r2,255
8111bec8:	1080010c 	andi	r2,r2,4
8111becc:	10000626 	beq	r2,zero,8111bee8 <vLoadDebugConfs+0x2f4>
									(*p_inteiro) = c;
8111bed0:	e0bff317 	ldw	r2,-52(fp)
8111bed4:	e0fff243 	ldbu	r3,-55(fp)
8111bed8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111bedc:	e0bff317 	ldw	r2,-52(fp)
8111bee0:	10800044 	addi	r2,r2,1
8111bee4:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111bee8:	e0bff247 	ldb	r2,-55(fp)
8111beec:	10800ba0 	cmpeqi	r2,r2,46
8111bef0:	1000031e 	bne	r2,zero,8111bf00 <vLoadDebugConfs+0x30c>
8111bef4:	e0bff247 	ldb	r2,-55(fp)
8111bef8:	10800ed8 	cmpnei	r2,r2,59
8111befc:	103fe81e 	bne	r2,zero,8111bea0 <__reset+0xfb0fbea0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bf00:	e0bff317 	ldw	r2,-52(fp)
8111bf04:	00c00284 	movi	r3,10
8111bf08:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiSyncPeriod = (unsigned short int)atoi( inteiro );
8111bf0c:	e0bff704 	addi	r2,fp,-36
8111bf10:	1009883a 	mov	r4,r2
8111bf14:	112312c0 	call	8112312c <atoi>
8111bf18:	1007883a 	mov	r3,r2
8111bf1c:	00a045f4 	movhi	r2,33047
8111bf20:	10a25304 	addi	r2,r2,-30388
8111bf24:	10c0038d 	sth	r3,14(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111bf28:	e0bff704 	addi	r2,fp,-36
8111bf2c:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111bf30:	e0bff203 	ldbu	r2,-56(fp)
8111bf34:	10800044 	addi	r2,r2,1
8111bf38:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111bf3c:	e0bff247 	ldb	r2,-55(fp)
8111bf40:	10800ed8 	cmpnei	r2,r2,59
8111bf44:	103fd61e 	bne	r2,zero,8111bea0 <__reset+0xfb0fbea0>

						break;
8111bf48:	00030e06 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'P':
						ucParser = 0;
8111bf4c:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111bf50:	e0bff60f 	ldh	r2,-40(fp)
8111bf54:	1009883a 	mov	r4,r2
8111bf58:	11209340 	call	81120934 <cGetNextChar>
8111bf5c:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111bf60:	d0e00317 	ldw	r3,-32756(gp)
8111bf64:	e0bff247 	ldb	r2,-55(fp)
8111bf68:	10800044 	addi	r2,r2,1
8111bf6c:	1885883a 	add	r2,r3,r2
8111bf70:	10800003 	ldbu	r2,0(r2)
8111bf74:	10803fcc 	andi	r2,r2,255
8111bf78:	1080010c 	andi	r2,r2,4
8111bf7c:	10000626 	beq	r2,zero,8111bf98 <vLoadDebugConfs+0x3a4>
									(*p_inteiro) = c;
8111bf80:	e0bff317 	ldw	r2,-52(fp)
8111bf84:	e0fff243 	ldbu	r3,-55(fp)
8111bf88:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111bf8c:	e0bff317 	ldw	r2,-52(fp)
8111bf90:	10800044 	addi	r2,r2,1
8111bf94:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111bf98:	e0bff247 	ldb	r2,-55(fp)
8111bf9c:	10800ba0 	cmpeqi	r2,r2,46
8111bfa0:	1000031e 	bne	r2,zero,8111bfb0 <vLoadDebugConfs+0x3bc>
8111bfa4:	e0bff247 	ldb	r2,-55(fp)
8111bfa8:	10800ed8 	cmpnei	r2,r2,59
8111bfac:	103fe81e 	bne	r2,zero,8111bf50 <__reset+0xfb0fbf50>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bfb0:	e0bff317 	ldw	r2,-52(fp)
8111bfb4:	00c00284 	movi	r3,10
8111bfb8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiPreScanSerial = (unsigned short int)atoi( inteiro );
8111bfbc:	e0bff704 	addi	r2,fp,-36
8111bfc0:	1009883a 	mov	r4,r2
8111bfc4:	112312c0 	call	8112312c <atoi>
8111bfc8:	1007883a 	mov	r3,r2
8111bfcc:	00a045f4 	movhi	r2,33047
8111bfd0:	10a25304 	addi	r2,r2,-30388
8111bfd4:	10c0018d 	sth	r3,6(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111bfd8:	e0bff704 	addi	r2,fp,-36
8111bfdc:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111bfe0:	e0bff203 	ldbu	r2,-56(fp)
8111bfe4:	10800044 	addi	r2,r2,1
8111bfe8:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111bfec:	e0bff247 	ldb	r2,-55(fp)
8111bff0:	10800ed8 	cmpnei	r2,r2,59
8111bff4:	103fd61e 	bne	r2,zero,8111bf50 <__reset+0xfb0fbf50>

						break;
8111bff8:	0002e206 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'N':
						ucParser = 0;
8111bffc:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c000:	e0bff60f 	ldh	r2,-40(fp)
8111c004:	1009883a 	mov	r4,r2
8111c008:	11209340 	call	81120934 <cGetNextChar>
8111c00c:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c010:	d0e00317 	ldw	r3,-32756(gp)
8111c014:	e0bff247 	ldb	r2,-55(fp)
8111c018:	10800044 	addi	r2,r2,1
8111c01c:	1885883a 	add	r2,r3,r2
8111c020:	10800003 	ldbu	r2,0(r2)
8111c024:	10803fcc 	andi	r2,r2,255
8111c028:	1080010c 	andi	r2,r2,4
8111c02c:	10000626 	beq	r2,zero,8111c048 <vLoadDebugConfs+0x454>
									(*p_inteiro) = c;
8111c030:	e0bff317 	ldw	r2,-52(fp)
8111c034:	e0fff243 	ldbu	r3,-55(fp)
8111c038:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c03c:	e0bff317 	ldw	r2,-52(fp)
8111c040:	10800044 	addi	r2,r2,1
8111c044:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c048:	e0bff247 	ldb	r2,-55(fp)
8111c04c:	10800ba0 	cmpeqi	r2,r2,46
8111c050:	1000031e 	bne	r2,zero,8111c060 <vLoadDebugConfs+0x46c>
8111c054:	e0bff247 	ldb	r2,-55(fp)
8111c058:	10800ed8 	cmpnei	r2,r2,59
8111c05c:	103fe81e 	bne	r2,zero,8111c000 <__reset+0xfb0fc000>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c060:	e0bff317 	ldw	r2,-52(fp)
8111c064:	00c00284 	movi	r3,10
8111c068:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOverScanSerial = (unsigned short int)atoi( inteiro );
8111c06c:	e0bff704 	addi	r2,fp,-36
8111c070:	1009883a 	mov	r4,r2
8111c074:	112312c0 	call	8112312c <atoi>
8111c078:	1007883a 	mov	r3,r2
8111c07c:	00a045f4 	movhi	r2,33047
8111c080:	10a25304 	addi	r2,r2,-30388
8111c084:	10c0010d 	sth	r3,4(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c088:	e0bff704 	addi	r2,fp,-36
8111c08c:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c090:	e0bff203 	ldbu	r2,-56(fp)
8111c094:	10800044 	addi	r2,r2,1
8111c098:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c09c:	e0bff247 	ldb	r2,-55(fp)
8111c0a0:	10800ed8 	cmpnei	r2,r2,59
8111c0a4:	103fd61e 	bne	r2,zero,8111c000 <__reset+0xfb0fc000>

						break;
8111c0a8:	0002b606 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'R':
						ucParser = 0;
8111c0ac:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c0b0:	e0bff60f 	ldh	r2,-40(fp)
8111c0b4:	1009883a 	mov	r4,r2
8111c0b8:	11209340 	call	81120934 <cGetNextChar>
8111c0bc:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c0c0:	d0e00317 	ldw	r3,-32756(gp)
8111c0c4:	e0bff247 	ldb	r2,-55(fp)
8111c0c8:	10800044 	addi	r2,r2,1
8111c0cc:	1885883a 	add	r2,r3,r2
8111c0d0:	10800003 	ldbu	r2,0(r2)
8111c0d4:	10803fcc 	andi	r2,r2,255
8111c0d8:	1080010c 	andi	r2,r2,4
8111c0dc:	10000626 	beq	r2,zero,8111c0f8 <vLoadDebugConfs+0x504>
									(*p_inteiro) = c;
8111c0e0:	e0bff317 	ldw	r2,-52(fp)
8111c0e4:	e0fff243 	ldbu	r3,-55(fp)
8111c0e8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c0ec:	e0bff317 	ldw	r2,-52(fp)
8111c0f0:	10800044 	addi	r2,r2,1
8111c0f4:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c0f8:	e0bff247 	ldb	r2,-55(fp)
8111c0fc:	10800ba0 	cmpeqi	r2,r2,46
8111c100:	1000031e 	bne	r2,zero,8111c110 <vLoadDebugConfs+0x51c>
8111c104:	e0bff247 	ldb	r2,-55(fp)
8111c108:	10800ed8 	cmpnei	r2,r2,59
8111c10c:	103fe81e 	bne	r2,zero,8111c0b0 <__reset+0xfb0fc0b0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c110:	e0bff317 	ldw	r2,-52(fp)
8111c114:	00c00284 	movi	r3,10
8111c118:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucRmapKey = (unsigned short int)atoi( inteiro );
8111c11c:	e0bff704 	addi	r2,fp,-36
8111c120:	1009883a 	mov	r4,r2
8111c124:	112312c0 	call	8112312c <atoi>
8111c128:	1007883a 	mov	r3,r2
8111c12c:	00a045f4 	movhi	r2,33047
8111c130:	10a25304 	addi	r2,r2,-30388
8111c134:	10c0080d 	sth	r3,32(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c138:	e0bff704 	addi	r2,fp,-36
8111c13c:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c140:	e0bff203 	ldbu	r2,-56(fp)
8111c144:	10800044 	addi	r2,r2,1
8111c148:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c14c:	e0bff247 	ldb	r2,-55(fp)
8111c150:	10800ed8 	cmpnei	r2,r2,59
8111c154:	103fd61e 	bne	r2,zero,8111c0b0 <__reset+0xfb0fc0b0>

						break;
8111c158:	00028a06 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'A':
						ucParser = 0;
8111c15c:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c160:	e0bff60f 	ldh	r2,-40(fp)
8111c164:	1009883a 	mov	r4,r2
8111c168:	11209340 	call	81120934 <cGetNextChar>
8111c16c:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c170:	d0e00317 	ldw	r3,-32756(gp)
8111c174:	e0bff247 	ldb	r2,-55(fp)
8111c178:	10800044 	addi	r2,r2,1
8111c17c:	1885883a 	add	r2,r3,r2
8111c180:	10800003 	ldbu	r2,0(r2)
8111c184:	10803fcc 	andi	r2,r2,255
8111c188:	1080010c 	andi	r2,r2,4
8111c18c:	10000626 	beq	r2,zero,8111c1a8 <vLoadDebugConfs+0x5b4>
									(*p_inteiro) = c;
8111c190:	e0bff317 	ldw	r2,-52(fp)
8111c194:	e0fff243 	ldbu	r3,-55(fp)
8111c198:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c19c:	e0bff317 	ldw	r2,-52(fp)
8111c1a0:	10800044 	addi	r2,r2,1
8111c1a4:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c1a8:	e0bff247 	ldb	r2,-55(fp)
8111c1ac:	10800ba0 	cmpeqi	r2,r2,46
8111c1b0:	1000031e 	bne	r2,zero,8111c1c0 <vLoadDebugConfs+0x5cc>
8111c1b4:	e0bff247 	ldb	r2,-55(fp)
8111c1b8:	10800ed8 	cmpnei	r2,r2,59
8111c1bc:	103fe81e 	bne	r2,zero,8111c160 <__reset+0xfb0fc160>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c1c0:	e0bff317 	ldw	r2,-52(fp)
8111c1c4:	00c00284 	movi	r3,10
8111c1c8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucLogicalAddr = (unsigned short int)atoi( inteiro );
8111c1cc:	e0bff704 	addi	r2,fp,-36
8111c1d0:	1009883a 	mov	r4,r2
8111c1d4:	112312c0 	call	8112312c <atoi>
8111c1d8:	1007883a 	mov	r3,r2
8111c1dc:	00a045f4 	movhi	r2,33047
8111c1e0:	10a25304 	addi	r2,r2,-30388
8111c1e4:	10c0088d 	sth	r3,34(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c1e8:	e0bff704 	addi	r2,fp,-36
8111c1ec:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c1f0:	e0bff203 	ldbu	r2,-56(fp)
8111c1f4:	10800044 	addi	r2,r2,1
8111c1f8:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c1fc:	e0bff247 	ldb	r2,-55(fp)
8111c200:	10800ed8 	cmpnei	r2,r2,59
8111c204:	103fd61e 	bne	r2,zero,8111c160 <__reset+0xfb0fc160>

						break;
8111c208:	00025e06 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'L':
						ucParser = 0;
8111c20c:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c210:	e0bff60f 	ldh	r2,-40(fp)
8111c214:	1009883a 	mov	r4,r2
8111c218:	11209340 	call	81120934 <cGetNextChar>
8111c21c:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c220:	d0e00317 	ldw	r3,-32756(gp)
8111c224:	e0bff247 	ldb	r2,-55(fp)
8111c228:	10800044 	addi	r2,r2,1
8111c22c:	1885883a 	add	r2,r3,r2
8111c230:	10800003 	ldbu	r2,0(r2)
8111c234:	10803fcc 	andi	r2,r2,255
8111c238:	1080010c 	andi	r2,r2,4
8111c23c:	10000626 	beq	r2,zero,8111c258 <vLoadDebugConfs+0x664>
									(*p_inteiro) = c;
8111c240:	e0bff317 	ldw	r2,-52(fp)
8111c244:	e0fff243 	ldbu	r3,-55(fp)
8111c248:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c24c:	e0bff317 	ldw	r2,-52(fp)
8111c250:	10800044 	addi	r2,r2,1
8111c254:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c258:	e0bff247 	ldb	r2,-55(fp)
8111c25c:	10800ba0 	cmpeqi	r2,r2,46
8111c260:	1000031e 	bne	r2,zero,8111c270 <vLoadDebugConfs+0x67c>
8111c264:	e0bff247 	ldb	r2,-55(fp)
8111c268:	10800ed8 	cmpnei	r2,r2,59
8111c26c:	103fe81e 	bne	r2,zero,8111c210 <__reset+0xfb0fc210>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c270:	e0bff317 	ldw	r2,-52(fp)
8111c274:	00c00284 	movi	r3,10
8111c278:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiRows = (unsigned short int)atoi( inteiro );
8111c27c:	e0bff704 	addi	r2,fp,-36
8111c280:	1009883a 	mov	r4,r2
8111c284:	112312c0 	call	8112312c <atoi>
8111c288:	1007883a 	mov	r3,r2
8111c28c:	00a045f4 	movhi	r2,33047
8111c290:	10a25304 	addi	r2,r2,-30388
8111c294:	10c0030d 	sth	r3,12(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c298:	e0bff704 	addi	r2,fp,-36
8111c29c:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c2a0:	e0bff203 	ldbu	r2,-56(fp)
8111c2a4:	10800044 	addi	r2,r2,1
8111c2a8:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c2ac:	e0bff247 	ldb	r2,-55(fp)
8111c2b0:	10800ed8 	cmpnei	r2,r2,59
8111c2b4:	103fd61e 	bne	r2,zero,8111c210 <__reset+0xfb0fc210>

						break;
8111c2b8:	00023206 	br	8111cb84 <vLoadDebugConfs+0xf90>

					case 'O':
						ucParser = 0;
8111c2bc:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c2c0:	e0bff60f 	ldh	r2,-40(fp)
8111c2c4:	1009883a 	mov	r4,r2
8111c2c8:	11209340 	call	81120934 <cGetNextChar>
8111c2cc:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c2d0:	d0e00317 	ldw	r3,-32756(gp)
8111c2d4:	e0bff247 	ldb	r2,-55(fp)
8111c2d8:	10800044 	addi	r2,r2,1
8111c2dc:	1885883a 	add	r2,r3,r2
8111c2e0:	10800003 	ldbu	r2,0(r2)
8111c2e4:	10803fcc 	andi	r2,r2,255
8111c2e8:	1080010c 	andi	r2,r2,4
8111c2ec:	10000626 	beq	r2,zero,8111c308 <vLoadDebugConfs+0x714>
									(*p_inteiro) = c;
8111c2f0:	e0bff317 	ldw	r2,-52(fp)
8111c2f4:	e0fff243 	ldbu	r3,-55(fp)
8111c2f8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c2fc:	e0bff317 	ldw	r2,-52(fp)
8111c300:	10800044 	addi	r2,r2,1
8111c304:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c308:	e0bff247 	ldb	r2,-55(fp)
8111c30c:	10800ba0 	cmpeqi	r2,r2,46
8111c310:	1000031e 	bne	r2,zero,8111c320 <vLoadDebugConfs+0x72c>
8111c314:	e0bff247 	ldb	r2,-55(fp)
8111c318:	10800ed8 	cmpnei	r2,r2,59
8111c31c:	103fe81e 	bne	r2,zero,8111c2c0 <__reset+0xfb0fc2c0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c320:	e0bff317 	ldw	r2,-52(fp)
8111c324:	00c00284 	movi	r3,10
8111c328:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOLN = (unsigned short int)atoi( inteiro );
8111c32c:	e0bff704 	addi	r2,fp,-36
8111c330:	1009883a 	mov	r4,r2
8111c334:	112312c0 	call	8112312c <atoi>
8111c338:	1007883a 	mov	r3,r2
8111c33c:	00a045f4 	movhi	r2,33047
8111c340:	10a25304 	addi	r2,r2,-30388
8111c344:	10c0020d 	sth	r3,8(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c348:	e0bff704 	addi	r2,fp,-36
8111c34c:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c350:	e0bff203 	ldbu	r2,-56(fp)
8111c354:	10800044 	addi	r2,r2,1
8111c358:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c35c:	e0bff247 	ldb	r2,-55(fp)
8111c360:	10800ed8 	cmpnei	r2,r2,59
8111c364:	103fd61e 	bne	r2,zero,8111c2c0 <__reset+0xfb0fc2c0>

						break;
8111c368:	00020606 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'C':
						ucParser = 0;
8111c36c:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c370:	e0bff60f 	ldh	r2,-40(fp)
8111c374:	1009883a 	mov	r4,r2
8111c378:	11209340 	call	81120934 <cGetNextChar>
8111c37c:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c380:	d0e00317 	ldw	r3,-32756(gp)
8111c384:	e0bff247 	ldb	r2,-55(fp)
8111c388:	10800044 	addi	r2,r2,1
8111c38c:	1885883a 	add	r2,r3,r2
8111c390:	10800003 	ldbu	r2,0(r2)
8111c394:	10803fcc 	andi	r2,r2,255
8111c398:	1080010c 	andi	r2,r2,4
8111c39c:	10000626 	beq	r2,zero,8111c3b8 <vLoadDebugConfs+0x7c4>
									(*p_inteiro) = c;
8111c3a0:	e0bff317 	ldw	r2,-52(fp)
8111c3a4:	e0fff243 	ldbu	r3,-55(fp)
8111c3a8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c3ac:	e0bff317 	ldw	r2,-52(fp)
8111c3b0:	10800044 	addi	r2,r2,1
8111c3b4:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c3b8:	e0bff247 	ldb	r2,-55(fp)
8111c3bc:	10800ba0 	cmpeqi	r2,r2,46
8111c3c0:	1000031e 	bne	r2,zero,8111c3d0 <vLoadDebugConfs+0x7dc>
8111c3c4:	e0bff247 	ldb	r2,-55(fp)
8111c3c8:	10800ed8 	cmpnei	r2,r2,59
8111c3cc:	103fe81e 	bne	r2,zero,8111c370 <__reset+0xfb0fc370>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c3d0:	e0bff317 	ldw	r2,-52(fp)
8111c3d4:	00c00284 	movi	r3,10
8111c3d8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiCols = (unsigned short int)atoi( inteiro );
8111c3dc:	e0bff704 	addi	r2,fp,-36
8111c3e0:	1009883a 	mov	r4,r2
8111c3e4:	112312c0 	call	8112312c <atoi>
8111c3e8:	1007883a 	mov	r3,r2
8111c3ec:	00a045f4 	movhi	r2,33047
8111c3f0:	10a25304 	addi	r2,r2,-30388
8111c3f4:	10c0028d 	sth	r3,10(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c3f8:	e0bff704 	addi	r2,fp,-36
8111c3fc:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c400:	e0bff203 	ldbu	r2,-56(fp)
8111c404:	10800044 	addi	r2,r2,1
8111c408:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c40c:	e0bff247 	ldb	r2,-55(fp)
8111c410:	10800ed8 	cmpnei	r2,r2,59
8111c414:	103fd61e 	bne	r2,zero,8111c370 <__reset+0xfb0fc370>

						break;
8111c418:	0001da06 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'K':

						do {
							c = cGetNextChar(siFile);
8111c41c:	e0bff60f 	ldh	r2,-40(fp)
8111c420:	1009883a 	mov	r4,r2
8111c424:	11209340 	call	81120934 <cGetNextChar>
8111c428:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c42c:	d0e00317 	ldw	r3,-32756(gp)
8111c430:	e0bff247 	ldb	r2,-55(fp)
8111c434:	10800044 	addi	r2,r2,1
8111c438:	1885883a 	add	r2,r3,r2
8111c43c:	10800003 	ldbu	r2,0(r2)
8111c440:	10803fcc 	andi	r2,r2,255
8111c444:	1080010c 	andi	r2,r2,4
8111c448:	10000626 	beq	r2,zero,8111c464 <vLoadDebugConfs+0x870>
								(*p_inteiroll) = c;
8111c44c:	e0bff417 	ldw	r2,-48(fp)
8111c450:	e0fff243 	ldbu	r3,-55(fp)
8111c454:	10c00005 	stb	r3,0(r2)
								p_inteiroll++;
8111c458:	e0bff417 	ldw	r2,-48(fp)
8111c45c:	10800044 	addi	r2,r2,1
8111c460:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c464:	e0bff247 	ldb	r2,-55(fp)
8111c468:	10800ed8 	cmpnei	r2,r2,59
8111c46c:	103feb1e 	bne	r2,zero,8111c41c <__reset+0xfb0fc41c>
						(*p_inteiroll) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c470:	e0bff417 	ldw	r2,-48(fp)
8111c474:	00c00284 	movi	r3,10
8111c478:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulColDelay = (unsigned long)atoll( inteiroll );
8111c47c:	e0bff904 	addi	r2,fp,-28
8111c480:	1009883a 	mov	r4,r2
8111c484:	11231440 	call	81123144 <atoll>
8111c488:	1009883a 	mov	r4,r2
8111c48c:	180b883a 	mov	r5,r3
8111c490:	2007883a 	mov	r3,r4
8111c494:	00a045f4 	movhi	r2,33047
8111c498:	10a25304 	addi	r2,r2,-30388
8111c49c:	10c00615 	stw	r3,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiroll = inteiroll;
8111c4a0:	e0bff904 	addi	r2,fp,-28
8111c4a4:	e0bff415 	stw	r2,-48(fp)

						break;
8111c4a8:	0001b606 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'M':

						do {
							c = cGetNextChar(siFile);
8111c4ac:	e0bff60f 	ldh	r2,-40(fp)
8111c4b0:	1009883a 	mov	r4,r2
8111c4b4:	11209340 	call	81120934 <cGetNextChar>
8111c4b8:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c4bc:	d0e00317 	ldw	r3,-32756(gp)
8111c4c0:	e0bff247 	ldb	r2,-55(fp)
8111c4c4:	10800044 	addi	r2,r2,1
8111c4c8:	1885883a 	add	r2,r3,r2
8111c4cc:	10800003 	ldbu	r2,0(r2)
8111c4d0:	10803fcc 	andi	r2,r2,255
8111c4d4:	1080010c 	andi	r2,r2,4
8111c4d8:	10000626 	beq	r2,zero,8111c4f4 <vLoadDebugConfs+0x900>
								(*p_inteiroll) = c;
8111c4dc:	e0bff417 	ldw	r2,-48(fp)
8111c4e0:	e0fff243 	ldbu	r3,-55(fp)
8111c4e4:	10c00005 	stb	r3,0(r2)
								p_inteiroll++;
8111c4e8:	e0bff417 	ldw	r2,-48(fp)
8111c4ec:	10800044 	addi	r2,r2,1
8111c4f0:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c4f4:	e0bff247 	ldb	r2,-55(fp)
8111c4f8:	10800ed8 	cmpnei	r2,r2,59
8111c4fc:	103feb1e 	bne	r2,zero,8111c4ac <__reset+0xfb0fc4ac>
						(*p_inteiroll) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c500:	e0bff417 	ldw	r2,-48(fp)
8111c504:	00c00284 	movi	r3,10
8111c508:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulADCPixelDelay = (unsigned long)atoll( inteiroll );
8111c50c:	e0bff904 	addi	r2,fp,-28
8111c510:	1009883a 	mov	r4,r2
8111c514:	11231440 	call	81123144 <atoll>
8111c518:	1009883a 	mov	r4,r2
8111c51c:	180b883a 	mov	r5,r3
8111c520:	2007883a 	mov	r3,r4
8111c524:	00a045f4 	movhi	r2,33047
8111c528:	10a25304 	addi	r2,r2,-30388
8111c52c:	10c00715 	stw	r3,28(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiroll = inteiroll;
8111c530:	e0bff904 	addi	r2,fp,-28
8111c534:	e0bff415 	stw	r2,-48(fp)

						break;
8111c538:	00019206 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'J':

						do {
							c = cGetNextChar(siFile);
8111c53c:	e0bff60f 	ldh	r2,-40(fp)
8111c540:	1009883a 	mov	r4,r2
8111c544:	11209340 	call	81120934 <cGetNextChar>
8111c548:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c54c:	d0e00317 	ldw	r3,-32756(gp)
8111c550:	e0bff247 	ldb	r2,-55(fp)
8111c554:	10800044 	addi	r2,r2,1
8111c558:	1885883a 	add	r2,r3,r2
8111c55c:	10800003 	ldbu	r2,0(r2)
8111c560:	10803fcc 	andi	r2,r2,255
8111c564:	1080010c 	andi	r2,r2,4
8111c568:	10000626 	beq	r2,zero,8111c584 <vLoadDebugConfs+0x990>
								(*p_inteiroll) = c;
8111c56c:	e0bff417 	ldw	r2,-48(fp)
8111c570:	e0fff243 	ldbu	r3,-55(fp)
8111c574:	10c00005 	stb	r3,0(r2)
								p_inteiroll++;
8111c578:	e0bff417 	ldw	r2,-48(fp)
8111c57c:	10800044 	addi	r2,r2,1
8111c580:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c584:	e0bff247 	ldb	r2,-55(fp)
8111c588:	10800ed8 	cmpnei	r2,r2,59
8111c58c:	103feb1e 	bne	r2,zero,8111c53c <__reset+0xfb0fc53c>
						(*p_inteiroll) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c590:	e0bff417 	ldw	r2,-48(fp)
8111c594:	00c00284 	movi	r3,10
8111c598:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulLineDelay = (unsigned long)atoll( inteiroll );
8111c59c:	e0bff904 	addi	r2,fp,-28
8111c5a0:	1009883a 	mov	r4,r2
8111c5a4:	11231440 	call	81123144 <atoll>
8111c5a8:	1009883a 	mov	r4,r2
8111c5ac:	180b883a 	mov	r5,r3
8111c5b0:	2007883a 	mov	r3,r4
8111c5b4:	00a045f4 	movhi	r2,33047
8111c5b8:	10a25304 	addi	r2,r2,-30388
8111c5bc:	10c00515 	stw	r3,20(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiroll = inteiroll;
8111c5c0:	e0bff904 	addi	r2,fp,-28
8111c5c4:	e0bff415 	stw	r2,-48(fp)

						break;
8111c5c8:	00016e06 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'B':

						do {
							c = cGetNextChar(siFile);
8111c5cc:	e0bff60f 	ldh	r2,-40(fp)
8111c5d0:	1009883a 	mov	r4,r2
8111c5d4:	11209340 	call	81120934 <cGetNextChar>
8111c5d8:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c5dc:	d0e00317 	ldw	r3,-32756(gp)
8111c5e0:	e0bff247 	ldb	r2,-55(fp)
8111c5e4:	10800044 	addi	r2,r2,1
8111c5e8:	1885883a 	add	r2,r3,r2
8111c5ec:	10800003 	ldbu	r2,0(r2)
8111c5f0:	10803fcc 	andi	r2,r2,255
8111c5f4:	1080010c 	andi	r2,r2,4
8111c5f8:	10000626 	beq	r2,zero,8111c614 <vLoadDebugConfs+0xa20>
								(*p_inteiro) = c;
8111c5fc:	e0bff317 	ldw	r2,-52(fp)
8111c600:	e0fff243 	ldbu	r3,-55(fp)
8111c604:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c608:	e0bff317 	ldw	r2,-52(fp)
8111c60c:	10800044 	addi	r2,r2,1
8111c610:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c614:	e0bff247 	ldb	r2,-55(fp)
8111c618:	10800ed8 	cmpnei	r2,r2,59
8111c61c:	103feb1e 	bne	r2,zero,8111c5cc <__reset+0xfb0fc5cc>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c620:	e0bff317 	ldw	r2,-52(fp)
8111c624:	00c00284 	movi	r3,10
8111c628:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiLinkNFEE0 = (unsigned short int)atoi( inteiro );
8111c62c:	e0bff704 	addi	r2,fp,-36
8111c630:	1009883a 	mov	r4,r2
8111c634:	112312c0 	call	8112312c <atoi>
8111c638:	1007883a 	mov	r3,r2
8111c63c:	00a045f4 	movhi	r2,33047
8111c640:	10a25304 	addi	r2,r2,-30388
8111c644:	10c00a0d 	sth	r3,40(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c648:	e0bff704 	addi	r2,fp,-36
8111c64c:	e0bff315 	stw	r2,-52(fp)

						break;
8111c650:	00014c06 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'F':

						do {
							c = cGetNextChar(siFile);
8111c654:	e0bff60f 	ldh	r2,-40(fp)
8111c658:	1009883a 	mov	r4,r2
8111c65c:	11209340 	call	81120934 <cGetNextChar>
8111c660:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c664:	d0e00317 	ldw	r3,-32756(gp)
8111c668:	e0bff247 	ldb	r2,-55(fp)
8111c66c:	10800044 	addi	r2,r2,1
8111c670:	1885883a 	add	r2,r3,r2
8111c674:	10800003 	ldbu	r2,0(r2)
8111c678:	10803fcc 	andi	r2,r2,255
8111c67c:	1080010c 	andi	r2,r2,4
8111c680:	10000626 	beq	r2,zero,8111c69c <vLoadDebugConfs+0xaa8>
								(*p_inteiro) = c;
8111c684:	e0bff317 	ldw	r2,-52(fp)
8111c688:	e0fff243 	ldbu	r3,-55(fp)
8111c68c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c690:	e0bff317 	ldw	r2,-52(fp)
8111c694:	10800044 	addi	r2,r2,1
8111c698:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c69c:	e0bff247 	ldb	r2,-55(fp)
8111c6a0:	10800ed8 	cmpnei	r2,r2,59
8111c6a4:	103feb1e 	bne	r2,zero,8111c654 <__reset+0xfb0fc654>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c6a8:	e0bff317 	ldw	r2,-52(fp)
8111c6ac:	00c00284 	movi	r3,10
8111c6b0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDebugLevel = (unsigned short int)atoi( inteiro );
8111c6b4:	e0bff704 	addi	r2,fp,-36
8111c6b8:	1009883a 	mov	r4,r2
8111c6bc:	112312c0 	call	8112312c <atoi>
8111c6c0:	1007883a 	mov	r3,r2
8111c6c4:	00a045f4 	movhi	r2,33047
8111c6c8:	10a25304 	addi	r2,r2,-30388
8111c6cc:	10c00a8d 	sth	r3,42(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c6d0:	e0bff704 	addi	r2,fp,-36
8111c6d4:	e0bff315 	stw	r2,-52(fp)

						break;
8111c6d8:	00012a06 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'Q':

						do {
							c = cGetNextChar(siFile);
8111c6dc:	e0bff60f 	ldh	r2,-40(fp)
8111c6e0:	1009883a 	mov	r4,r2
8111c6e4:	11209340 	call	81120934 <cGetNextChar>
8111c6e8:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c6ec:	d0e00317 	ldw	r3,-32756(gp)
8111c6f0:	e0bff247 	ldb	r2,-55(fp)
8111c6f4:	10800044 	addi	r2,r2,1
8111c6f8:	1885883a 	add	r2,r3,r2
8111c6fc:	10800003 	ldbu	r2,0(r2)
8111c700:	10803fcc 	andi	r2,r2,255
8111c704:	1080010c 	andi	r2,r2,4
8111c708:	10000626 	beq	r2,zero,8111c724 <vLoadDebugConfs+0xb30>
								(*p_inteiro) = c;
8111c70c:	e0bff317 	ldw	r2,-52(fp)
8111c710:	e0fff243 	ldbu	r3,-55(fp)
8111c714:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c718:	e0bff317 	ldw	r2,-52(fp)
8111c71c:	10800044 	addi	r2,r2,1
8111c720:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c724:	e0bff247 	ldb	r2,-55(fp)
8111c728:	10800ed8 	cmpnei	r2,r2,59
8111c72c:	103feb1e 	bne	r2,zero,8111c6dc <__reset+0xfb0fc6dc>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c730:	e0bff317 	ldw	r2,-52(fp)
8111c734:	00c00284 	movi	r3,10
8111c738:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiPatternType = (unsigned short int)atoi( inteiro );
8111c73c:	e0bff704 	addi	r2,fp,-36
8111c740:	1009883a 	mov	r4,r2
8111c744:	112312c0 	call	8112312c <atoi>
8111c748:	1007883a 	mov	r3,r2
8111c74c:	00a045f4 	movhi	r2,33047
8111c750:	10a25304 	addi	r2,r2,-30388
8111c754:	10c00b0d 	sth	r3,44(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c758:	e0bff704 	addi	r2,fp,-36
8111c75c:	e0bff315 	stw	r2,-52(fp)

						break;
8111c760:	00010806 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'Y':

						do {
							c = cGetNextChar(siFile);
8111c764:	e0bff60f 	ldh	r2,-40(fp)
8111c768:	1009883a 	mov	r4,r2
8111c76c:	11209340 	call	81120934 <cGetNextChar>
8111c770:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c774:	d0e00317 	ldw	r3,-32756(gp)
8111c778:	e0bff247 	ldb	r2,-55(fp)
8111c77c:	10800044 	addi	r2,r2,1
8111c780:	1885883a 	add	r2,r3,r2
8111c784:	10800003 	ldbu	r2,0(r2)
8111c788:	10803fcc 	andi	r2,r2,255
8111c78c:	1080010c 	andi	r2,r2,4
8111c790:	10000626 	beq	r2,zero,8111c7ac <vLoadDebugConfs+0xbb8>
								(*p_inteiro) = c;
8111c794:	e0bff317 	ldw	r2,-52(fp)
8111c798:	e0fff243 	ldbu	r3,-55(fp)
8111c79c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c7a0:	e0bff317 	ldw	r2,-52(fp)
8111c7a4:	10800044 	addi	r2,r2,1
8111c7a8:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c7ac:	e0bff247 	ldb	r2,-55(fp)
8111c7b0:	10800ed8 	cmpnei	r2,r2,59
8111c7b4:	103feb1e 	bne	r2,zero,8111c764 <__reset+0xfb0fc764>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c7b8:	e0bff317 	ldw	r2,-52(fp)
8111c7bc:	00c00284 	movi	r3,10
8111c7c0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiGuardNFEEDelay = (unsigned short int)atoi( inteiro );
8111c7c4:	e0bff704 	addi	r2,fp,-36
8111c7c8:	1009883a 	mov	r4,r2
8111c7cc:	112312c0 	call	8112312c <atoi>
8111c7d0:	1007883a 	mov	r3,r2
8111c7d4:	00a045f4 	movhi	r2,33047
8111c7d8:	10a25304 	addi	r2,r2,-30388
8111c7dc:	10c00b8d 	sth	r3,46(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c7e0:	e0bff704 	addi	r2,fp,-36
8111c7e4:	e0bff315 	stw	r2,-52(fp)

						break;
8111c7e8:	0000e606 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'D':

						do {
							c = cGetNextChar(siFile);
8111c7ec:	e0bff60f 	ldh	r2,-40(fp)
8111c7f0:	1009883a 	mov	r4,r2
8111c7f4:	11209340 	call	81120934 <cGetNextChar>
8111c7f8:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c7fc:	d0e00317 	ldw	r3,-32756(gp)
8111c800:	e0bff247 	ldb	r2,-55(fp)
8111c804:	10800044 	addi	r2,r2,1
8111c808:	1885883a 	add	r2,r3,r2
8111c80c:	10800003 	ldbu	r2,0(r2)
8111c810:	10803fcc 	andi	r2,r2,255
8111c814:	1080010c 	andi	r2,r2,4
8111c818:	10000626 	beq	r2,zero,8111c834 <vLoadDebugConfs+0xc40>
								(*p_inteiro) = c;
8111c81c:	e0bff317 	ldw	r2,-52(fp)
8111c820:	e0fff243 	ldbu	r3,-55(fp)
8111c824:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c828:	e0bff317 	ldw	r2,-52(fp)
8111c82c:	10800044 	addi	r2,r2,1
8111c830:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c834:	e0bff247 	ldb	r2,-55(fp)
8111c838:	10800ed8 	cmpnei	r2,r2,59
8111c83c:	103feb1e 	bne	r2,zero,8111c7ec <__reset+0xfb0fc7ec>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c840:	e0bff317 	ldw	r2,-52(fp)
8111c844:	00c00284 	movi	r3,10
8111c848:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDataProtId = (unsigned short int)atoi( inteiro );
8111c84c:	e0bff704 	addi	r2,fp,-36
8111c850:	1009883a 	mov	r4,r2
8111c854:	112312c0 	call	8112312c <atoi>
8111c858:	1007883a 	mov	r3,r2
8111c85c:	00a045f4 	movhi	r2,33047
8111c860:	10a25304 	addi	r2,r2,-30388
8111c864:	10c00c0d 	sth	r3,48(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c868:	e0bff704 	addi	r2,fp,-36
8111c86c:	e0bff315 	stw	r2,-52(fp)

						break;
8111c870:	0000c406 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'H':

						do {
							c = cGetNextChar(siFile);
8111c874:	e0bff60f 	ldh	r2,-40(fp)
8111c878:	1009883a 	mov	r4,r2
8111c87c:	11209340 	call	81120934 <cGetNextChar>
8111c880:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c884:	d0e00317 	ldw	r3,-32756(gp)
8111c888:	e0bff247 	ldb	r2,-55(fp)
8111c88c:	10800044 	addi	r2,r2,1
8111c890:	1885883a 	add	r2,r3,r2
8111c894:	10800003 	ldbu	r2,0(r2)
8111c898:	10803fcc 	andi	r2,r2,255
8111c89c:	1080010c 	andi	r2,r2,4
8111c8a0:	10000626 	beq	r2,zero,8111c8bc <vLoadDebugConfs+0xcc8>
								(*p_inteiro) = c;
8111c8a4:	e0bff317 	ldw	r2,-52(fp)
8111c8a8:	e0fff243 	ldbu	r3,-55(fp)
8111c8ac:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c8b0:	e0bff317 	ldw	r2,-52(fp)
8111c8b4:	10800044 	addi	r2,r2,1
8111c8b8:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c8bc:	e0bff247 	ldb	r2,-55(fp)
8111c8c0:	10800ed8 	cmpnei	r2,r2,59
8111c8c4:	103feb1e 	bne	r2,zero,8111c874 <__reset+0xfb0fc874>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c8c8:	e0bff317 	ldw	r2,-52(fp)
8111c8cc:	00c00284 	movi	r3,10
8111c8d0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDpuLogicalAddr = (unsigned short int)atoi( inteiro );
8111c8d4:	e0bff704 	addi	r2,fp,-36
8111c8d8:	1009883a 	mov	r4,r2
8111c8dc:	112312c0 	call	8112312c <atoi>
8111c8e0:	1007883a 	mov	r3,r2
8111c8e4:	00a045f4 	movhi	r2,33047
8111c8e8:	10a25304 	addi	r2,r2,-30388
8111c8ec:	10c00c8d 	sth	r3,50(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c8f0:	e0bff704 	addi	r2,fp,-36
8111c8f4:	e0bff315 	stw	r2,-52(fp)

						break;
8111c8f8:	0000a206 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'E':

						ucParser = 0;
8111c8fc:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111c900:	e0bff60f 	ldh	r2,-40(fp)
8111c904:	1009883a 	mov	r4,r2
8111c908:	11209340 	call	81120934 <cGetNextChar>
8111c90c:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8111c910:	d0e00317 	ldw	r3,-32756(gp)
8111c914:	e0bff247 	ldb	r2,-55(fp)
8111c918:	10800044 	addi	r2,r2,1
8111c91c:	1885883a 	add	r2,r3,r2
8111c920:	10800003 	ldbu	r2,0(r2)
8111c924:	10803fcc 	andi	r2,r2,255
8111c928:	1080010c 	andi	r2,r2,4
8111c92c:	10000626 	beq	r2,zero,8111c948 <vLoadDebugConfs+0xd54>
									(*p_inteiro) = c;
8111c930:	e0bff317 	ldw	r2,-52(fp)
8111c934:	e0fff243 	ldbu	r3,-55(fp)
8111c938:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111c93c:	e0bff317 	ldw	r2,-52(fp)
8111c940:	10800044 	addi	r2,r2,1
8111c944:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111c948:	e0bff247 	ldb	r2,-55(fp)
8111c94c:	10800ba0 	cmpeqi	r2,r2,46
8111c950:	1000031e 	bne	r2,zero,8111c960 <vLoadDebugConfs+0xd6c>
8111c954:	e0bff247 	ldb	r2,-55(fp)
8111c958:	10800ed8 	cmpnei	r2,r2,59
8111c95c:	103fe81e 	bne	r2,zero,8111c900 <__reset+0xfb0fc900>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c960:	e0bff317 	ldw	r2,-52(fp)
8111c964:	00c00284 	movi	r3,10
8111c968:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucReadOutOrder[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8111c96c:	e0bff203 	ldbu	r2,-56(fp)
8111c970:	108000e8 	cmpgeui	r2,r2,3
8111c974:	1000021e 	bne	r2,zero,8111c980 <vLoadDebugConfs+0xd8c>
8111c978:	e43ff203 	ldbu	r16,-56(fp)
8111c97c:	00000106 	br	8111c984 <vLoadDebugConfs+0xd90>
8111c980:	040000c4 	movi	r16,3
8111c984:	e0bff704 	addi	r2,fp,-36
8111c988:	1009883a 	mov	r4,r2
8111c98c:	112312c0 	call	8112312c <atoi>
8111c990:	1007883a 	mov	r3,r2
8111c994:	00a045f4 	movhi	r2,33047
8111c998:	10a25304 	addi	r2,r2,-30388
8111c99c:	1405883a 	add	r2,r2,r16
8111c9a0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111c9a4:	e0bff704 	addi	r2,fp,-36
8111c9a8:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8111c9ac:	e0bff203 	ldbu	r2,-56(fp)
8111c9b0:	10800044 	addi	r2,r2,1
8111c9b4:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8111c9b8:	e0bff247 	ldb	r2,-55(fp)
8111c9bc:	10800ed8 	cmpnei	r2,r2,59
8111c9c0:	103fcf1e 	bne	r2,zero,8111c900 <__reset+0xfb0fc900>

						break;
8111c9c4:	00006f06 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'T':

						do {
							c = cGetNextChar(siFile);
8111c9c8:	e0bff60f 	ldh	r2,-40(fp)
8111c9cc:	1009883a 	mov	r4,r2
8111c9d0:	11209340 	call	81120934 <cGetNextChar>
8111c9d4:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111c9d8:	d0e00317 	ldw	r3,-32756(gp)
8111c9dc:	e0bff247 	ldb	r2,-55(fp)
8111c9e0:	10800044 	addi	r2,r2,1
8111c9e4:	1885883a 	add	r2,r3,r2
8111c9e8:	10800003 	ldbu	r2,0(r2)
8111c9ec:	10803fcc 	andi	r2,r2,255
8111c9f0:	1080010c 	andi	r2,r2,4
8111c9f4:	10000626 	beq	r2,zero,8111ca10 <vLoadDebugConfs+0xe1c>
								(*p_inteiro) = c;
8111c9f8:	e0bff317 	ldw	r2,-52(fp)
8111c9fc:	e0fff243 	ldbu	r3,-55(fp)
8111ca00:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111ca04:	e0bff317 	ldw	r2,-52(fp)
8111ca08:	10800044 	addi	r2,r2,1
8111ca0c:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111ca10:	e0bff247 	ldb	r2,-55(fp)
8111ca14:	10800ed8 	cmpnei	r2,r2,59
8111ca18:	103feb1e 	bne	r2,zero,8111c9c8 <__reset+0xfb0fc9c8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ca1c:	e0bff317 	ldw	r2,-52(fp)
8111ca20:	00c00284 	movi	r3,10
8111ca24:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111ca28:	e0bff704 	addi	r2,fp,-36
8111ca2c:	1009883a 	mov	r4,r2
8111ca30:	112312c0 	call	8112312c <atoi>
8111ca34:	e0bff68d 	sth	r2,-38(fp)
						if (sidhcpTemp == 1)
8111ca38:	e0bff68f 	ldh	r2,-38(fp)
8111ca3c:	10800058 	cmpnei	r2,r2,1
8111ca40:	1000051e 	bne	r2,zero,8111ca58 <vLoadDebugConfs+0xe64>
							xDefaults.bDataPacket = TRUE;
8111ca44:	00a045f4 	movhi	r2,33047
8111ca48:	10a25304 	addi	r2,r2,-30388
8111ca4c:	00c00044 	movi	r3,1
8111ca50:	10c00415 	stw	r3,16(r2)
8111ca54:	00000306 	br	8111ca64 <vLoadDebugConfs+0xe70>
						else
							xDefaults.bDataPacket = FALSE;
8111ca58:	00a045f4 	movhi	r2,33047
8111ca5c:	10a25304 	addi	r2,r2,-30388
8111ca60:	10000415 	stw	zero,16(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111ca64:	e0bff704 	addi	r2,fp,-36
8111ca68:	e0bff315 	stw	r2,-52(fp)

						break;
8111ca6c:	00004506 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 'Z':

						do {
							c = cGetNextChar(siFile);
8111ca70:	e0bff60f 	ldh	r2,-40(fp)
8111ca74:	1009883a 	mov	r4,r2
8111ca78:	11209340 	call	81120934 <cGetNextChar>
8111ca7c:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8111ca80:	d0e00317 	ldw	r3,-32756(gp)
8111ca84:	e0bff247 	ldb	r2,-55(fp)
8111ca88:	10800044 	addi	r2,r2,1
8111ca8c:	1885883a 	add	r2,r3,r2
8111ca90:	10800003 	ldbu	r2,0(r2)
8111ca94:	10803fcc 	andi	r2,r2,255
8111ca98:	1080010c 	andi	r2,r2,4
8111ca9c:	10000626 	beq	r2,zero,8111cab8 <vLoadDebugConfs+0xec4>
								(*p_inteiro) = c;
8111caa0:	e0bff317 	ldw	r2,-52(fp)
8111caa4:	e0fff243 	ldbu	r3,-55(fp)
8111caa8:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111caac:	e0bff317 	ldw	r2,-52(fp)
8111cab0:	10800044 	addi	r2,r2,1
8111cab4:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111cab8:	e0bff247 	ldb	r2,-55(fp)
8111cabc:	10800ed8 	cmpnei	r2,r2,59
8111cac0:	103feb1e 	bne	r2,zero,8111ca70 <__reset+0xfb0fca70>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111cac4:	e0bff317 	ldw	r2,-52(fp)
8111cac8:	00c00284 	movi	r3,10
8111cacc:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111cad0:	e0bff704 	addi	r2,fp,-36
8111cad4:	1009883a 	mov	r4,r2
8111cad8:	112312c0 	call	8112312c <atoi>
8111cadc:	e0bff68d 	sth	r2,-38(fp)
						if (sidhcpTemp == 1)
8111cae0:	e0bff68f 	ldh	r2,-38(fp)
8111cae4:	10800058 	cmpnei	r2,r2,1
8111cae8:	1000051e 	bne	r2,zero,8111cb00 <vLoadDebugConfs+0xf0c>
							xDefaults.bOneShot = TRUE;
8111caec:	00a045f4 	movhi	r2,33047
8111caf0:	10a25304 	addi	r2,r2,-30388
8111caf4:	00c00044 	movi	r3,1
8111caf8:	10c00915 	stw	r3,36(r2)
8111cafc:	00000306 	br	8111cb0c <vLoadDebugConfs+0xf18>
						else
							xDefaults.bOneShot = FALSE;
8111cb00:	00a045f4 	movhi	r2,33047
8111cb04:	10a25304 	addi	r2,r2,-30388
8111cb08:	10000915 	stw	zero,36(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111cb0c:	e0bff704 	addi	r2,fp,-36
8111cb10:	e0bff315 	stw	r2,-52(fp)

						break;
8111cb14:	00001b06 	br	8111cb84 <vLoadDebugConfs+0xf90>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111cb18:	e0bff60f 	ldh	r2,-40(fp)
8111cb1c:	1009883a 	mov	r4,r2
8111cb20:	11208f40 	call	811208f4 <siCloseFile>
8111cb24:	e0bff515 	stw	r2,-44(fp)
						if (close == FALSE){
8111cb28:	e0bff517 	ldw	r2,-44(fp)
8111cb2c:	1000071e 	bne	r2,zero,8111cb4c <vLoadDebugConfs+0xf58>
							#if DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
8111cb30:	d0a06217 	ldw	r2,-32376(gp)
8111cb34:	100f883a 	mov	r7,r2
8111cb38:	01800784 	movi	r6,30
8111cb3c:	01400044 	movi	r5,1
8111cb40:	01204574 	movhi	r4,33045
8111cb44:	2101ff04 	addi	r4,r4,2044
8111cb48:	112393c0 	call	8112393c <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111cb4c:	00800044 	movi	r2,1
8111cb50:	e0bff115 	stw	r2,-60(fp)
						bSuccess = TRUE; //pensar melhor
8111cb54:	00800044 	movi	r2,1
8111cb58:	e0bff015 	stw	r2,-64(fp)
						break;
8111cb5c:	00000906 	br	8111cb84 <vLoadDebugConfs+0xf90>
					default:
						#if DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser. (%hhu)\n",c);
8111cb60:	d0a06217 	ldw	r2,-32376(gp)
8111cb64:	e0fff247 	ldb	r3,-55(fp)
8111cb68:	180d883a 	mov	r6,r3
8111cb6c:	01604574 	movhi	r5,33045
8111cb70:	29424f04 	addi	r5,r5,2364
8111cb74:	1009883a 	mov	r4,r2
8111cb78:	11232a00 	call	811232a0 <fprintf>
						#endif
						break;
8111cb7c:	00000106 	br	8111cb84 <vLoadDebugConfs+0xf90>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111cb80:	0001883a 	nop
						#if DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser. (%hhu)\n",c);
						#endif
						break;
				}
			} while ( bEOF == FALSE );
8111cb84:	e0bff117 	ldw	r2,-60(fp)
8111cb88:	103c3f26 	beq	r2,zero,8111bc88 <__reset+0xfb0fbc88>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111cb8c:	00000f06 	br	8111cbcc <vLoadDebugConfs+0xfd8>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#if DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
8111cb90:	d0a06217 	ldw	r2,-32376(gp)
8111cb94:	100f883a 	mov	r7,r2
8111cb98:	01800604 	movi	r6,24
8111cb9c:	01400044 	movi	r5,1
8111cba0:	01204574 	movhi	r4,33045
8111cba4:	21021004 	addi	r4,r4,2112
8111cba8:	112393c0 	call	8112393c <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111cbac:	00000706 	br	8111cbcc <vLoadDebugConfs+0xfd8>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#if DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
8111cbb0:	d0a06217 	ldw	r2,-32376(gp)
8111cbb4:	100f883a 	mov	r7,r2
8111cbb8:	018004c4 	movi	r6,19
8111cbbc:	01400044 	movi	r5,1
8111cbc0:	01204574 	movhi	r4,33045
8111cbc4:	21021704 	addi	r4,r4,2140
8111cbc8:	112393c0 	call	8112393c <fwrite>
	if ( bSuccess == FALSE ) {
		/* Load default? */

	}

	return bSuccess;
8111cbcc:	e0bff017 	ldw	r2,-64(fp)
}
8111cbd0:	e6ffff04 	addi	sp,fp,-4
8111cbd4:	dfc00217 	ldw	ra,8(sp)
8111cbd8:	df000117 	ldw	fp,4(sp)
8111cbdc:	dc000017 	ldw	r16,0(sp)
8111cbe0:	dec00304 	addi	sp,sp,12
8111cbe4:	f800283a 	ret

8111cbe8 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
8111cbe8:	defffb04 	addi	sp,sp,-20
8111cbec:	de00012e 	bgeu	sp,et,8111cbf4 <ucCrc8+0xc>
8111cbf0:	003b68fa 	trap	3
8111cbf4:	df000415 	stw	fp,16(sp)
8111cbf8:	df000404 	addi	fp,sp,16
8111cbfc:	e13ffd15 	stw	r4,-12(fp)
8111cc00:	e17ffe15 	stw	r5,-8(fp)
8111cc04:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
8111cc08:	e0bffe17 	ldw	r2,-8(fp)
8111cc0c:	1000021e 	bne	r2,zero,8111cc18 <ucCrc8+0x30>
        return 0;
8111cc10:	0005883a 	mov	r2,zero
8111cc14:	00001906 	br	8111cc7c <ucCrc8+0x94>
    crc &= 0xff;
8111cc18:	e0bffd17 	ldw	r2,-12(fp)
8111cc1c:	10803fcc 	andi	r2,r2,255
8111cc20:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
8111cc24:	e0fffe17 	ldw	r3,-8(fp)
8111cc28:	e0bfff17 	ldw	r2,-4(fp)
8111cc2c:	1885883a 	add	r2,r3,r2
8111cc30:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
8111cc34:	00000d06 	br	8111cc6c <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
8111cc38:	e0bffe17 	ldw	r2,-8(fp)
8111cc3c:	10c00044 	addi	r3,r2,1
8111cc40:	e0fffe15 	stw	r3,-8(fp)
8111cc44:	10800003 	ldbu	r2,0(r2)
8111cc48:	10c03fcc 	andi	r3,r2,255
8111cc4c:	e0bffd17 	ldw	r2,-12(fp)
8111cc50:	1886f03a 	xor	r3,r3,r2
8111cc54:	00a04574 	movhi	r2,33045
8111cc58:	10825944 	addi	r2,r2,2405
8111cc5c:	10c5883a 	add	r2,r2,r3
8111cc60:	10800003 	ldbu	r2,0(r2)
8111cc64:	10803fcc 	andi	r2,r2,255
8111cc68:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
8111cc6c:	e0fffe17 	ldw	r3,-8(fp)
8111cc70:	e0bffc17 	ldw	r2,-16(fp)
8111cc74:	18bff036 	bltu	r3,r2,8111cc38 <__reset+0xfb0fcc38>
        crc = crc8_table[crc ^ *data++];
    return crc;
8111cc78:	e0bffd17 	ldw	r2,-12(fp)
}
8111cc7c:	e037883a 	mov	sp,fp
8111cc80:	df000017 	ldw	fp,0(sp)
8111cc84:	dec00104 	addi	sp,sp,4
8111cc88:	f800283a 	ret

8111cc8c <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8111cc8c:	defffb04 	addi	sp,sp,-20
8111cc90:	de00012e 	bgeu	sp,et,8111cc98 <ucCrc8wInit+0xc>
8111cc94:	003b68fa 	trap	3
8111cc98:	dfc00415 	stw	ra,16(sp)
8111cc9c:	df000315 	stw	fp,12(sp)
8111cca0:	df000304 	addi	fp,sp,12
8111cca4:	e13ffe15 	stw	r4,-8(fp)
8111cca8:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
8111ccac:	000d883a 	mov	r6,zero
8111ccb0:	000b883a 	mov	r5,zero
8111ccb4:	0009883a 	mov	r4,zero
8111ccb8:	111cbe80 	call	8111cbe8 <ucCrc8>
8111ccbc:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
8111ccc0:	e0bffd03 	ldbu	r2,-12(fp)
8111ccc4:	e1bfff17 	ldw	r6,-4(fp)
8111ccc8:	e17ffe17 	ldw	r5,-8(fp)
8111cccc:	1009883a 	mov	r4,r2
8111ccd0:	111cbe80 	call	8111cbe8 <ucCrc8>
}
8111ccd4:	e037883a 	mov	sp,fp
8111ccd8:	dfc00117 	ldw	ra,4(sp)
8111ccdc:	df000017 	ldw	fp,0(sp)
8111cce0:	dec00204 	addi	sp,sp,8
8111cce4:	f800283a 	ret

8111cce8 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
8111cce8:	defffc04 	addi	sp,sp,-16
8111ccec:	de00012e 	bgeu	sp,et,8111ccf4 <vDataControllerInit+0xc>
8111ccf0:	003b68fa 	trap	3
8111ccf4:	df000315 	stw	fp,12(sp)
8111ccf8:	df000304 	addi	fp,sp,12
8111ccfc:	e13ffe15 	stw	r4,-8(fp)
8111cd00:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
8111cd04:	e0bffe17 	ldw	r2,-8(fp)
8111cd08:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111cd0c:	e03ffd05 	stb	zero,-12(fp)
8111cd10:	00001c06 	br	8111cd84 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
8111cd14:	e0bffd03 	ldbu	r2,-12(fp)
8111cd18:	e0fffd03 	ldbu	r3,-12(fp)
8111cd1c:	18c09824 	muli	r3,r3,608
8111cd20:	e13fff17 	ldw	r4,-4(fp)
8111cd24:	20c7883a 	add	r3,r4,r3
8111cd28:	e13ffe17 	ldw	r4,-8(fp)
8111cd2c:	10800084 	addi	r2,r2,2
8111cd30:	1085883a 	add	r2,r2,r2
8111cd34:	1085883a 	add	r2,r2,r2
8111cd38:	2085883a 	add	r2,r4,r2
8111cd3c:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
8111cd40:	e17ffd03 	ldbu	r5,-12(fp)
8111cd44:	e0bffd03 	ldbu	r2,-12(fp)
8111cd48:	e0ffff17 	ldw	r3,-4(fp)
8111cd4c:	10802644 	addi	r2,r2,153
8111cd50:	1085883a 	add	r2,r2,r2
8111cd54:	1085883a 	add	r2,r2,r2
8111cd58:	1885883a 	add	r2,r3,r2
8111cd5c:	10c00017 	ldw	r3,0(r2)
8111cd60:	e13ffe17 	ldw	r4,-8(fp)
8111cd64:	288000c4 	addi	r2,r5,3
8111cd68:	1085883a 	add	r2,r2,r2
8111cd6c:	1085883a 	add	r2,r2,r2
8111cd70:	2085883a 	add	r2,r4,r2
8111cd74:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111cd78:	e0bffd03 	ldbu	r2,-12(fp)
8111cd7c:	10800044 	addi	r2,r2,1
8111cd80:	e0bffd05 	stb	r2,-12(fp)
8111cd84:	e0bffd03 	ldbu	r2,-12(fp)
8111cd88:	103fe226 	beq	r2,zero,8111cd14 <__reset+0xfb0fcd14>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
8111cd8c:	e0bfff17 	ldw	r2,-4(fp)
8111cd90:	10c09b04 	addi	r3,r2,620
8111cd94:	e0bffe17 	ldw	r2,-8(fp)
8111cd98:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
8111cd9c:	e0bffe17 	ldw	r2,-8(fp)
8111cda0:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
8111cda4:	e0bffe17 	ldw	r2,-8(fp)
8111cda8:	10c00504 	addi	r3,r2,20
8111cdac:	e0bfff17 	ldw	r2,-4(fp)
8111cdb0:	10c09d15 	stw	r3,628(r2)
}
8111cdb4:	0001883a 	nop
8111cdb8:	e037883a 	mov	sp,fp
8111cdbc:	df000017 	ldw	fp,0(sp)
8111cdc0:	dec00104 	addi	sp,sp,4
8111cdc4:	f800283a 	ret

8111cdc8 <printErrorTask>:

#include "error_handler_simucam.h"


#if DEBUG_ON
    void printErrorTask( INT8U error_code ) {
8111cdc8:	defff904 	addi	sp,sp,-28
8111cdcc:	de00012e 	bgeu	sp,et,8111cdd4 <printErrorTask+0xc>
8111cdd0:	003b68fa 	trap	3
8111cdd4:	dfc00615 	stw	ra,24(sp)
8111cdd8:	df000515 	stw	fp,20(sp)
8111cddc:	df000504 	addi	fp,sp,20
8111cde0:	2005883a 	mov	r2,r4
8111cde4:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
8111cde8:	e03ffb15 	stw	zero,-20(fp)
8111cdec:	e03ffc15 	stw	zero,-16(fp)
8111cdf0:	e03ffd15 	stw	zero,-12(fp)
8111cdf4:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
8111cdf8:	e0bfff03 	ldbu	r2,-4(fp)
8111cdfc:	100d883a 	mov	r6,r2
8111ce00:	01604574 	movhi	r5,33045
8111ce04:	29429a04 	addi	r5,r5,2664
8111ce08:	e13ffb04 	addi	r4,fp,-20
8111ce0c:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, buffer);
8111ce10:	d0a06217 	ldw	r2,-32376(gp)
8111ce14:	e17ffb04 	addi	r5,fp,-20
8111ce18:	1009883a 	mov	r4,r2
8111ce1c:	11232a00 	call	811232a0 <fprintf>
	}
8111ce20:	0001883a 	nop
8111ce24:	e037883a 	mov	sp,fp
8111ce28:	dfc00117 	ldw	ra,4(sp)
8111ce2c:	df000017 	ldw	fp,0(sp)
8111ce30:	dec00204 	addi	sp,sp,8
8111ce34:	f800283a 	ret

8111ce38 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
8111ce38:	defffd04 	addi	sp,sp,-12
8111ce3c:	de00012e 	bgeu	sp,et,8111ce44 <vFailCreateMutexSResources+0xc>
8111ce40:	003b68fa 	trap	3
8111ce44:	dfc00215 	stw	ra,8(sp)
8111ce48:	df000115 	stw	fp,4(sp)
8111ce4c:	df000104 	addi	fp,sp,4
8111ce50:	2005883a 	mov	r2,r4
8111ce54:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ce58:	00a045f4 	movhi	r2,33047
8111ce5c:	10a25304 	addi	r2,r2,-30388
8111ce60:	10800a8b 	ldhu	r2,42(r2)
8111ce64:	10bfffcc 	andi	r2,r2,65535
8111ce68:	10800228 	cmpgeui	r2,r2,8
8111ce6c:	10000a1e 	bne	r2,zero,8111ce98 <vFailCreateMutexSResources+0x60>
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
8111ce70:	d0a06217 	ldw	r2,-32376(gp)
8111ce74:	100f883a 	mov	r7,r2
8111ce78:	018008c4 	movi	r6,35
8111ce7c:	01400044 	movi	r5,1
8111ce80:	01204574 	movhi	r4,33045
8111ce84:	21029d04 	addi	r4,r4,2676
8111ce88:	112393c0 	call	8112393c <fwrite>
		printErrorTask(error_code);
8111ce8c:	e0bfff03 	ldbu	r2,-4(fp)
8111ce90:	1009883a 	mov	r4,r2
8111ce94:	111cdc80 	call	8111cdc8 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ce98:	0001883a 	nop
8111ce9c:	e037883a 	mov	sp,fp
8111cea0:	dfc00117 	ldw	ra,4(sp)
8111cea4:	df000017 	ldw	fp,0(sp)
8111cea8:	dec00204 	addi	sp,sp,8
8111ceac:	f800283a 	ret

8111ceb0 <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
8111ceb0:	defffe04 	addi	sp,sp,-8
8111ceb4:	de00012e 	bgeu	sp,et,8111cebc <vFailCreateMutexDMA+0xc>
8111ceb8:	003b68fa 	trap	3
8111cebc:	dfc00115 	stw	ra,4(sp)
8111cec0:	df000015 	stw	fp,0(sp)
8111cec4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cec8:	00a045f4 	movhi	r2,33047
8111cecc:	10a25304 	addi	r2,r2,-30388
8111ced0:	10800a8b 	ldhu	r2,42(r2)
8111ced4:	10bfffcc 	andi	r2,r2,65535
8111ced8:	10800228 	cmpgeui	r2,r2,8
8111cedc:	1000071e 	bne	r2,zero,8111cefc <vFailCreateMutexDMA+0x4c>
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
8111cee0:	d0a06217 	ldw	r2,-32376(gp)
8111cee4:	100f883a 	mov	r7,r2
8111cee8:	018009c4 	movi	r6,39
8111ceec:	01400044 	movi	r5,1
8111cef0:	01204574 	movhi	r4,33045
8111cef4:	2102a604 	addi	r4,r4,2712
8111cef8:	112393c0 	call	8112393c <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cefc:	0001883a 	nop
8111cf00:	e037883a 	mov	sp,fp
8111cf04:	dfc00117 	ldw	ra,4(sp)
8111cf08:	df000017 	ldw	fp,0(sp)
8111cf0c:	dec00204 	addi	sp,sp,8
8111cf10:	f800283a 	ret

8111cf14 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
8111cf14:	defffe04 	addi	sp,sp,-8
8111cf18:	de00012e 	bgeu	sp,et,8111cf20 <vFailCreateSemaphoreResources+0xc>
8111cf1c:	003b68fa 	trap	3
8111cf20:	dfc00115 	stw	ra,4(sp)
8111cf24:	df000015 	stw	fp,0(sp)
8111cf28:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cf2c:	00a045f4 	movhi	r2,33047
8111cf30:	10a25304 	addi	r2,r2,-30388
8111cf34:	10800a8b 	ldhu	r2,42(r2)
8111cf38:	10bfffcc 	andi	r2,r2,65535
8111cf3c:	10800228 	cmpgeui	r2,r2,8
8111cf40:	1000071e 	bne	r2,zero,8111cf60 <vFailCreateSemaphoreResources+0x4c>
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
8111cf44:	d0a06217 	ldw	r2,-32376(gp)
8111cf48:	100f883a 	mov	r7,r2
8111cf4c:	01800984 	movi	r6,38
8111cf50:	01400044 	movi	r5,1
8111cf54:	01204574 	movhi	r4,33045
8111cf58:	2102b004 	addi	r4,r4,2752
8111cf5c:	112393c0 	call	8112393c <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cf60:	0001883a 	nop
8111cf64:	e037883a 	mov	sp,fp
8111cf68:	dfc00117 	ldw	ra,4(sp)
8111cf6c:	df000017 	ldw	fp,0(sp)
8111cf70:	dec00204 	addi	sp,sp,8
8111cf74:	f800283a 	ret

8111cf78 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
8111cf78:	defffe04 	addi	sp,sp,-8
8111cf7c:	de00012e 	bgeu	sp,et,8111cf84 <vFailTestCriticasParts+0xc>
8111cf80:	003b68fa 	trap	3
8111cf84:	dfc00115 	stw	ra,4(sp)
8111cf88:	df000015 	stw	fp,0(sp)
8111cf8c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cf90:	00a045f4 	movhi	r2,33047
8111cf94:	10a25304 	addi	r2,r2,-30388
8111cf98:	10800a8b 	ldhu	r2,42(r2)
8111cf9c:	10bfffcc 	andi	r2,r2,65535
8111cfa0:	10800228 	cmpgeui	r2,r2,8
8111cfa4:	1000071e 	bne	r2,zero,8111cfc4 <vFailTestCriticasParts+0x4c>
		debug(fp,"vFailTestCriticasParts. (exit)\n");
8111cfa8:	d0a06217 	ldw	r2,-32376(gp)
8111cfac:	100f883a 	mov	r7,r2
8111cfb0:	018007c4 	movi	r6,31
8111cfb4:	01400044 	movi	r5,1
8111cfb8:	01204574 	movhi	r4,33045
8111cfbc:	2102ba04 	addi	r4,r4,2792
8111cfc0:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cfc4:	0001883a 	nop
8111cfc8:	e037883a 	mov	sp,fp
8111cfcc:	dfc00117 	ldw	ra,4(sp)
8111cfd0:	df000017 	ldw	fp,0(sp)
8111cfd4:	dec00204 	addi	sp,sp,8
8111cfd8:	f800283a 	ret

8111cfdc <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
8111cfdc:	defffe04 	addi	sp,sp,-8
8111cfe0:	de00012e 	bgeu	sp,et,8111cfe8 <vFailSendxSemCommInit+0xc>
8111cfe4:	003b68fa 	trap	3
8111cfe8:	dfc00115 	stw	ra,4(sp)
8111cfec:	df000015 	stw	fp,0(sp)
8111cff0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cff4:	00a045f4 	movhi	r2,33047
8111cff8:	10a25304 	addi	r2,r2,-30388
8111cffc:	10800a8b 	ldhu	r2,42(r2)
8111d000:	10bfffcc 	andi	r2,r2,65535
8111d004:	10800228 	cmpgeui	r2,r2,8
8111d008:	10000e1e 	bne	r2,zero,8111d044 <vFailSendxSemCommInit+0x68>
		debug(fp,"vFailSendxSemCommInit. (exit)");
8111d00c:	d0a06217 	ldw	r2,-32376(gp)
8111d010:	100f883a 	mov	r7,r2
8111d014:	01800744 	movi	r6,29
8111d018:	01400044 	movi	r5,1
8111d01c:	01204574 	movhi	r4,33045
8111d020:	2102c204 	addi	r4,r4,2824
8111d024:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
8111d028:	d0a06217 	ldw	r2,-32376(gp)
8111d02c:	100f883a 	mov	r7,r2
8111d030:	01800a44 	movi	r6,41
8111d034:	01400044 	movi	r5,1
8111d038:	01204574 	movhi	r4,33045
8111d03c:	2102ca04 	addi	r4,r4,2856
8111d040:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d044:	0001883a 	nop
8111d048:	e037883a 	mov	sp,fp
8111d04c:	dfc00117 	ldw	ra,4(sp)
8111d050:	df000017 	ldw	fp,0(sp)
8111d054:	dec00204 	addi	sp,sp,8
8111d058:	f800283a 	ret

8111d05c <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
8111d05c:	defffe04 	addi	sp,sp,-8
8111d060:	de00012e 	bgeu	sp,et,8111d068 <vFailSendPreParsedSemaphore+0xc>
8111d064:	003b68fa 	trap	3
8111d068:	dfc00115 	stw	ra,4(sp)
8111d06c:	df000015 	stw	fp,0(sp)
8111d070:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d074:	00a045f4 	movhi	r2,33047
8111d078:	10a25304 	addi	r2,r2,-30388
8111d07c:	10800a8b 	ldhu	r2,42(r2)
8111d080:	10bfffcc 	andi	r2,r2,65535
8111d084:	10800228 	cmpgeui	r2,r2,8
8111d088:	1000071e 	bne	r2,zero,8111d0a8 <vFailSendPreParsedSemaphore+0x4c>
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
8111d08c:	d0a06217 	ldw	r2,-32376(gp)
8111d090:	100f883a 	mov	r7,r2
8111d094:	01800904 	movi	r6,36
8111d098:	01400044 	movi	r5,1
8111d09c:	01204574 	movhi	r4,33045
8111d0a0:	2102d504 	addi	r4,r4,2900
8111d0a4:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d0a8:	0001883a 	nop
8111d0ac:	e037883a 	mov	sp,fp
8111d0b0:	dfc00117 	ldw	ra,4(sp)
8111d0b4:	df000017 	ldw	fp,0(sp)
8111d0b8:	dec00204 	addi	sp,sp,8
8111d0bc:	f800283a 	ret

8111d0c0 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
8111d0c0:	defffe04 	addi	sp,sp,-8
8111d0c4:	de00012e 	bgeu	sp,et,8111d0cc <vFailSendPreAckReceiverSemaphore+0xc>
8111d0c8:	003b68fa 	trap	3
8111d0cc:	dfc00115 	stw	ra,4(sp)
8111d0d0:	df000015 	stw	fp,0(sp)
8111d0d4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d0d8:	00a045f4 	movhi	r2,33047
8111d0dc:	10a25304 	addi	r2,r2,-30388
8111d0e0:	10800a8b 	ldhu	r2,42(r2)
8111d0e4:	10bfffcc 	andi	r2,r2,65535
8111d0e8:	10800228 	cmpgeui	r2,r2,8
8111d0ec:	1000071e 	bne	r2,zero,8111d10c <vFailSendPreAckReceiverSemaphore+0x4c>
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
8111d0f0:	d0a06217 	ldw	r2,-32376(gp)
8111d0f4:	100f883a 	mov	r7,r2
8111d0f8:	01800a44 	movi	r6,41
8111d0fc:	01400044 	movi	r5,1
8111d100:	01204574 	movhi	r4,33045
8111d104:	2102df04 	addi	r4,r4,2940
8111d108:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d10c:	0001883a 	nop
8111d110:	e037883a 	mov	sp,fp
8111d114:	dfc00117 	ldw	ra,4(sp)
8111d118:	df000017 	ldw	fp,0(sp)
8111d11c:	dec00204 	addi	sp,sp,8
8111d120:	f800283a 	ret

8111d124 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
8111d124:	defffe04 	addi	sp,sp,-8
8111d128:	de00012e 	bgeu	sp,et,8111d130 <vFailSendPreAckSenderSemaphore+0xc>
8111d12c:	003b68fa 	trap	3
8111d130:	dfc00115 	stw	ra,4(sp)
8111d134:	df000015 	stw	fp,0(sp)
8111d138:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d13c:	00a045f4 	movhi	r2,33047
8111d140:	10a25304 	addi	r2,r2,-30388
8111d144:	10800a8b 	ldhu	r2,42(r2)
8111d148:	10bfffcc 	andi	r2,r2,65535
8111d14c:	10800228 	cmpgeui	r2,r2,8
8111d150:	1000071e 	bne	r2,zero,8111d170 <vFailSendPreAckSenderSemaphore+0x4c>
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
8111d154:	d0a06217 	ldw	r2,-32376(gp)
8111d158:	100f883a 	mov	r7,r2
8111d15c:	018009c4 	movi	r6,39
8111d160:	01400044 	movi	r5,1
8111d164:	01204574 	movhi	r4,33045
8111d168:	2102ea04 	addi	r4,r4,2984
8111d16c:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d170:	0001883a 	nop
8111d174:	e037883a 	mov	sp,fp
8111d178:	dfc00117 	ldw	ra,4(sp)
8111d17c:	df000017 	ldw	fp,0(sp)
8111d180:	dec00204 	addi	sp,sp,8
8111d184:	f800283a 	ret

8111d188 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
8111d188:	defffe04 	addi	sp,sp,-8
8111d18c:	de00012e 	bgeu	sp,et,8111d194 <vFailGetCountSemaphoreSenderTask+0xc>
8111d190:	003b68fa 	trap	3
8111d194:	dfc00115 	stw	ra,4(sp)
8111d198:	df000015 	stw	fp,0(sp)
8111d19c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d1a0:	00a045f4 	movhi	r2,33047
8111d1a4:	10a25304 	addi	r2,r2,-30388
8111d1a8:	10800a8b 	ldhu	r2,42(r2)
8111d1ac:	10bfffcc 	andi	r2,r2,65535
8111d1b0:	10800228 	cmpgeui	r2,r2,8
8111d1b4:	10000e1e 	bne	r2,zero,8111d1f0 <vFailGetCountSemaphoreSenderTask+0x68>
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
8111d1b8:	d0a06217 	ldw	r2,-32376(gp)
8111d1bc:	100f883a 	mov	r7,r2
8111d1c0:	01800a44 	movi	r6,41
8111d1c4:	01400044 	movi	r5,1
8111d1c8:	01204574 	movhi	r4,33045
8111d1cc:	2102f404 	addi	r4,r4,3024
8111d1d0:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
8111d1d4:	d0a06217 	ldw	r2,-32376(gp)
8111d1d8:	100f883a 	mov	r7,r2
8111d1dc:	01801104 	movi	r6,68
8111d1e0:	01400044 	movi	r5,1
8111d1e4:	01204574 	movhi	r4,33045
8111d1e8:	2102ff04 	addi	r4,r4,3068
8111d1ec:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d1f0:	0001883a 	nop
8111d1f4:	e037883a 	mov	sp,fp
8111d1f8:	dfc00117 	ldw	ra,4(sp)
8111d1fc:	df000017 	ldw	fp,0(sp)
8111d200:	dec00204 	addi	sp,sp,8
8111d204:	f800283a 	ret

8111d208 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
8111d208:	defffe04 	addi	sp,sp,-8
8111d20c:	de00012e 	bgeu	sp,et,8111d214 <vFailGetMutexSenderTask+0xc>
8111d210:	003b68fa 	trap	3
8111d214:	dfc00115 	stw	ra,4(sp)
8111d218:	df000015 	stw	fp,0(sp)
8111d21c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d220:	00a045f4 	movhi	r2,33047
8111d224:	10a25304 	addi	r2,r2,-30388
8111d228:	10800a8b 	ldhu	r2,42(r2)
8111d22c:	10bfffcc 	andi	r2,r2,65535
8111d230:	10800228 	cmpgeui	r2,r2,8
8111d234:	10000e1e 	bne	r2,zero,8111d270 <vFailGetMutexSenderTask+0x68>
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
8111d238:	d0a06217 	ldw	r2,-32376(gp)
8111d23c:	100f883a 	mov	r7,r2
8111d240:	01800804 	movi	r6,32
8111d244:	01400044 	movi	r5,1
8111d248:	01204574 	movhi	r4,33045
8111d24c:	21031104 	addi	r4,r4,3140
8111d250:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
8111d254:	d0a06217 	ldw	r2,-32376(gp)
8111d258:	100f883a 	mov	r7,r2
8111d25c:	01801084 	movi	r6,66
8111d260:	01400044 	movi	r5,1
8111d264:	01204574 	movhi	r4,33045
8111d268:	21031a04 	addi	r4,r4,3176
8111d26c:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d270:	0001883a 	nop
8111d274:	e037883a 	mov	sp,fp
8111d278:	dfc00117 	ldw	ra,4(sp)
8111d27c:	df000017 	ldw	fp,0(sp)
8111d280:	dec00204 	addi	sp,sp,8
8111d284:	f800283a 	ret

8111d288 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
8111d288:	defffe04 	addi	sp,sp,-8
8111d28c:	de00012e 	bgeu	sp,et,8111d294 <vFailGetCountSemaphoreReceiverTask+0xc>
8111d290:	003b68fa 	trap	3
8111d294:	dfc00115 	stw	ra,4(sp)
8111d298:	df000015 	stw	fp,0(sp)
8111d29c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d2a0:	00a045f4 	movhi	r2,33047
8111d2a4:	10a25304 	addi	r2,r2,-30388
8111d2a8:	10800a8b 	ldhu	r2,42(r2)
8111d2ac:	10bfffcc 	andi	r2,r2,65535
8111d2b0:	10800228 	cmpgeui	r2,r2,8
8111d2b4:	10000e1e 	bne	r2,zero,8111d2f0 <vFailGetCountSemaphoreReceiverTask+0x68>
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
8111d2b8:	d0a06217 	ldw	r2,-32376(gp)
8111d2bc:	100f883a 	mov	r7,r2
8111d2c0:	01800ac4 	movi	r6,43
8111d2c4:	01400044 	movi	r5,1
8111d2c8:	01204574 	movhi	r4,33045
8111d2cc:	21032b04 	addi	r4,r4,3244
8111d2d0:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
8111d2d4:	d0a06217 	ldw	r2,-32376(gp)
8111d2d8:	100f883a 	mov	r7,r2
8111d2dc:	01801184 	movi	r6,70
8111d2e0:	01400044 	movi	r5,1
8111d2e4:	01204574 	movhi	r4,33045
8111d2e8:	21033604 	addi	r4,r4,3288
8111d2ec:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d2f0:	0001883a 	nop
8111d2f4:	e037883a 	mov	sp,fp
8111d2f8:	dfc00117 	ldw	ra,4(sp)
8111d2fc:	df000017 	ldw	fp,0(sp)
8111d300:	dec00204 	addi	sp,sp,8
8111d304:	f800283a 	ret

8111d308 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
8111d308:	defffe04 	addi	sp,sp,-8
8111d30c:	de00012e 	bgeu	sp,et,8111d314 <vFailGetMutexReceiverTask+0xc>
8111d310:	003b68fa 	trap	3
8111d314:	dfc00115 	stw	ra,4(sp)
8111d318:	df000015 	stw	fp,0(sp)
8111d31c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d320:	00a045f4 	movhi	r2,33047
8111d324:	10a25304 	addi	r2,r2,-30388
8111d328:	10800a8b 	ldhu	r2,42(r2)
8111d32c:	10bfffcc 	andi	r2,r2,65535
8111d330:	10800228 	cmpgeui	r2,r2,8
8111d334:	10000e1e 	bne	r2,zero,8111d370 <vFailGetMutexReceiverTask+0x68>
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
8111d338:	d0a06217 	ldw	r2,-32376(gp)
8111d33c:	100f883a 	mov	r7,r2
8111d340:	01800884 	movi	r6,34
8111d344:	01400044 	movi	r5,1
8111d348:	01204574 	movhi	r4,33045
8111d34c:	21034804 	addi	r4,r4,3360
8111d350:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
8111d354:	d0a06217 	ldw	r2,-32376(gp)
8111d358:	100f883a 	mov	r7,r2
8111d35c:	01801104 	movi	r6,68
8111d360:	01400044 	movi	r5,1
8111d364:	01204574 	movhi	r4,33045
8111d368:	21035104 	addi	r4,r4,3396
8111d36c:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d370:	0001883a 	nop
8111d374:	e037883a 	mov	sp,fp
8111d378:	dfc00117 	ldw	ra,4(sp)
8111d37c:	df000017 	ldw	fp,0(sp)
8111d380:	dec00204 	addi	sp,sp,8
8111d384:	f800283a 	ret

8111d388 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
8111d388:	defffe04 	addi	sp,sp,-8
8111d38c:	de00012e 	bgeu	sp,et,8111d394 <vFailGetMutexTxUARTSenderTask+0xc>
8111d390:	003b68fa 	trap	3
8111d394:	dfc00115 	stw	ra,4(sp)
8111d398:	df000015 	stw	fp,0(sp)
8111d39c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d3a0:	00a045f4 	movhi	r2,33047
8111d3a4:	10a25304 	addi	r2,r2,-30388
8111d3a8:	10800a8b 	ldhu	r2,42(r2)
8111d3ac:	10bfffcc 	andi	r2,r2,65535
8111d3b0:	10800228 	cmpgeui	r2,r2,8
8111d3b4:	10000e1e 	bne	r2,zero,8111d3f0 <vFailGetMutexTxUARTSenderTask+0x68>
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
8111d3b8:	d0a06217 	ldw	r2,-32376(gp)
8111d3bc:	100f883a 	mov	r7,r2
8111d3c0:	01800984 	movi	r6,38
8111d3c4:	01400044 	movi	r5,1
8111d3c8:	01204574 	movhi	r4,33045
8111d3cc:	21036304 	addi	r4,r4,3468
8111d3d0:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
8111d3d4:	d0a06217 	ldw	r2,-32376(gp)
8111d3d8:	100f883a 	mov	r7,r2
8111d3dc:	01801044 	movi	r6,65
8111d3e0:	01400044 	movi	r5,1
8111d3e4:	01204574 	movhi	r4,33045
8111d3e8:	21036d04 	addi	r4,r4,3508
8111d3ec:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d3f0:	0001883a 	nop
8111d3f4:	e037883a 	mov	sp,fp
8111d3f8:	dfc00117 	ldw	ra,4(sp)
8111d3fc:	df000017 	ldw	fp,0(sp)
8111d400:	dec00204 	addi	sp,sp,8
8111d404:	f800283a 	ret

8111d408 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
8111d408:	defffe04 	addi	sp,sp,-8
8111d40c:	de00012e 	bgeu	sp,et,8111d414 <vFailGetMacRTC+0xc>
8111d410:	003b68fa 	trap	3
8111d414:	dfc00115 	stw	ra,4(sp)
8111d418:	df000015 	stw	fp,0(sp)
8111d41c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d420:	00a045f4 	movhi	r2,33047
8111d424:	10a25304 	addi	r2,r2,-30388
8111d428:	10800a8b 	ldhu	r2,42(r2)
8111d42c:	10bfffcc 	andi	r2,r2,65535
8111d430:	10800228 	cmpgeui	r2,r2,8
8111d434:	1000071e 	bne	r2,zero,8111d454 <vFailGetMacRTC+0x4c>
		debug(fp,"vFailGetMacRTC\n");
8111d438:	d0a06217 	ldw	r2,-32376(gp)
8111d43c:	100f883a 	mov	r7,r2
8111d440:	018003c4 	movi	r6,15
8111d444:	01400044 	movi	r5,1
8111d448:	01204574 	movhi	r4,33045
8111d44c:	21037e04 	addi	r4,r4,3576
8111d450:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d454:	0001883a 	nop
8111d458:	e037883a 	mov	sp,fp
8111d45c:	dfc00117 	ldw	ra,4(sp)
8111d460:	df000017 	ldw	fp,0(sp)
8111d464:	dec00204 	addi	sp,sp,8
8111d468:	f800283a 	ret

8111d46c <vFailInitialization>:


void vFailInitialization( void )
{
8111d46c:	defffe04 	addi	sp,sp,-8
8111d470:	de00012e 	bgeu	sp,et,8111d478 <vFailInitialization+0xc>
8111d474:	003b68fa 	trap	3
8111d478:	dfc00115 	stw	ra,4(sp)
8111d47c:	df000015 	stw	fp,0(sp)
8111d480:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d484:	00a045f4 	movhi	r2,33047
8111d488:	10a25304 	addi	r2,r2,-30388
8111d48c:	10800a8b 	ldhu	r2,42(r2)
8111d490:	10bfffcc 	andi	r2,r2,65535
8111d494:	10800228 	cmpgeui	r2,r2,8
8111d498:	1000071e 	bne	r2,zero,8111d4b8 <vFailInitialization+0x4c>
		debug(fp,"vFailInitialization\n");
8111d49c:	d0a06217 	ldw	r2,-32376(gp)
8111d4a0:	100f883a 	mov	r7,r2
8111d4a4:	01800504 	movi	r6,20
8111d4a8:	01400044 	movi	r5,1
8111d4ac:	01204574 	movhi	r4,33045
8111d4b0:	21038204 	addi	r4,r4,3592
8111d4b4:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d4b8:	0001883a 	nop
8111d4bc:	e037883a 	mov	sp,fp
8111d4c0:	dfc00117 	ldw	ra,4(sp)
8111d4c4:	df000017 	ldw	fp,0(sp)
8111d4c8:	dec00204 	addi	sp,sp,8
8111d4cc:	f800283a 	ret

8111d4d0 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
8111d4d0:	defffe04 	addi	sp,sp,-8
8111d4d4:	de00012e 	bgeu	sp,et,8111d4dc <vFailReceiverCreate+0xc>
8111d4d8:	003b68fa 	trap	3
8111d4dc:	dfc00115 	stw	ra,4(sp)
8111d4e0:	df000015 	stw	fp,0(sp)
8111d4e4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d4e8:	00a045f4 	movhi	r2,33047
8111d4ec:	10a25304 	addi	r2,r2,-30388
8111d4f0:	10800a8b 	ldhu	r2,42(r2)
8111d4f4:	10bfffcc 	andi	r2,r2,65535
8111d4f8:	10800228 	cmpgeui	r2,r2,8
8111d4fc:	1000071e 	bne	r2,zero,8111d51c <vFailReceiverCreate+0x4c>
		debug(fp,"vReceiverUartTask\n");
8111d500:	d0a06217 	ldw	r2,-32376(gp)
8111d504:	100f883a 	mov	r7,r2
8111d508:	01800484 	movi	r6,18
8111d50c:	01400044 	movi	r5,1
8111d510:	01204574 	movhi	r4,33045
8111d514:	21038804 	addi	r4,r4,3616
8111d518:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d51c:	0001883a 	nop
8111d520:	e037883a 	mov	sp,fp
8111d524:	dfc00117 	ldw	ra,4(sp)
8111d528:	df000017 	ldw	fp,0(sp)
8111d52c:	dec00204 	addi	sp,sp,8
8111d530:	f800283a 	ret

8111d534 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
8111d534:	defffe04 	addi	sp,sp,-8
8111d538:	de00012e 	bgeu	sp,et,8111d540 <vFailSenderCreate+0xc>
8111d53c:	003b68fa 	trap	3
8111d540:	dfc00115 	stw	ra,4(sp)
8111d544:	df000015 	stw	fp,0(sp)
8111d548:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d54c:	00a045f4 	movhi	r2,33047
8111d550:	10a25304 	addi	r2,r2,-30388
8111d554:	10800a8b 	ldhu	r2,42(r2)
8111d558:	10bfffcc 	andi	r2,r2,65535
8111d55c:	10800228 	cmpgeui	r2,r2,8
8111d560:	1000071e 	bne	r2,zero,8111d580 <vFailSenderCreate+0x4c>
		debug(fp,"vFailSenderCreate\n");
8111d564:	d0a06217 	ldw	r2,-32376(gp)
8111d568:	100f883a 	mov	r7,r2
8111d56c:	01800484 	movi	r6,18
8111d570:	01400044 	movi	r5,1
8111d574:	01204574 	movhi	r4,33045
8111d578:	21038d04 	addi	r4,r4,3636
8111d57c:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d580:	0001883a 	nop
8111d584:	e037883a 	mov	sp,fp
8111d588:	dfc00117 	ldw	ra,4(sp)
8111d58c:	df000017 	ldw	fp,0(sp)
8111d590:	dec00204 	addi	sp,sp,8
8111d594:	f800283a 	ret

8111d598 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
8111d598:	defffe04 	addi	sp,sp,-8
8111d59c:	de00012e 	bgeu	sp,et,8111d5a4 <vFailDeleteInitialization+0xc>
8111d5a0:	003b68fa 	trap	3
8111d5a4:	dfc00115 	stw	ra,4(sp)
8111d5a8:	df000015 	stw	fp,0(sp)
8111d5ac:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d5b0:	00a045f4 	movhi	r2,33047
8111d5b4:	10a25304 	addi	r2,r2,-30388
8111d5b8:	10800a8b 	ldhu	r2,42(r2)
8111d5bc:	10bfffcc 	andi	r2,r2,65535
8111d5c0:	10800228 	cmpgeui	r2,r2,8
8111d5c4:	1000071e 	bne	r2,zero,8111d5e4 <vFailDeleteInitialization+0x4c>
		debug(fp,"vFailDeleteInitialization\n");
8111d5c8:	d0a06217 	ldw	r2,-32376(gp)
8111d5cc:	100f883a 	mov	r7,r2
8111d5d0:	01800684 	movi	r6,26
8111d5d4:	01400044 	movi	r5,1
8111d5d8:	01204574 	movhi	r4,33045
8111d5dc:	21039204 	addi	r4,r4,3656
8111d5e0:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d5e4:	0001883a 	nop
8111d5e8:	e037883a 	mov	sp,fp
8111d5ec:	dfc00117 	ldw	ra,4(sp)
8111d5f0:	df000017 	ldw	fp,0(sp)
8111d5f4:	dec00204 	addi	sp,sp,8
8111d5f8:	f800283a 	ret

8111d5fc <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
8111d5fc:	defffe04 	addi	sp,sp,-8
8111d600:	de00012e 	bgeu	sp,et,8111d608 <vFailSetCountSemaphorexBuffer32+0xc>
8111d604:	003b68fa 	trap	3
8111d608:	dfc00115 	stw	ra,4(sp)
8111d60c:	df000015 	stw	fp,0(sp)
8111d610:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d614:	00a045f4 	movhi	r2,33047
8111d618:	10a25304 	addi	r2,r2,-30388
8111d61c:	10800a8b 	ldhu	r2,42(r2)
8111d620:	10bfffcc 	andi	r2,r2,65535
8111d624:	10800228 	cmpgeui	r2,r2,8
8111d628:	10000e1e 	bne	r2,zero,8111d664 <vFailSetCountSemaphorexBuffer32+0x68>
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
8111d62c:	d0a06217 	ldw	r2,-32376(gp)
8111d630:	100f883a 	mov	r7,r2
8111d634:	01800a04 	movi	r6,40
8111d638:	01400044 	movi	r5,1
8111d63c:	01204574 	movhi	r4,33045
8111d640:	21039904 	addi	r4,r4,3684
8111d644:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not post to the semaphore.()\n");
8111d648:	d0a06217 	ldw	r2,-32376(gp)
8111d64c:	100f883a 	mov	r7,r2
8111d650:	018008c4 	movi	r6,35
8111d654:	01400044 	movi	r5,1
8111d658:	01204574 	movhi	r4,33045
8111d65c:	2103a404 	addi	r4,r4,3728
8111d660:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d664:	0001883a 	nop
8111d668:	e037883a 	mov	sp,fp
8111d66c:	dfc00117 	ldw	ra,4(sp)
8111d670:	df000017 	ldw	fp,0(sp)
8111d674:	dec00204 	addi	sp,sp,8
8111d678:	f800283a 	ret

8111d67c <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
8111d67c:	defffe04 	addi	sp,sp,-8
8111d680:	de00012e 	bgeu	sp,et,8111d688 <vFailSetCountSemaphorexBuffer64+0xc>
8111d684:	003b68fa 	trap	3
8111d688:	dfc00115 	stw	ra,4(sp)
8111d68c:	df000015 	stw	fp,0(sp)
8111d690:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d694:	00a045f4 	movhi	r2,33047
8111d698:	10a25304 	addi	r2,r2,-30388
8111d69c:	10800a8b 	ldhu	r2,42(r2)
8111d6a0:	10bfffcc 	andi	r2,r2,65535
8111d6a4:	10800228 	cmpgeui	r2,r2,8
8111d6a8:	10000e1e 	bne	r2,zero,8111d6e4 <vFailSetCountSemaphorexBuffer64+0x68>
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
8111d6ac:	d0a06217 	ldw	r2,-32376(gp)
8111d6b0:	100f883a 	mov	r7,r2
8111d6b4:	01800a04 	movi	r6,40
8111d6b8:	01400044 	movi	r5,1
8111d6bc:	01204574 	movhi	r4,33045
8111d6c0:	2103ad04 	addi	r4,r4,3764
8111d6c4:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not post to the semaphore.()\n");
8111d6c8:	d0a06217 	ldw	r2,-32376(gp)
8111d6cc:	100f883a 	mov	r7,r2
8111d6d0:	018008c4 	movi	r6,35
8111d6d4:	01400044 	movi	r5,1
8111d6d8:	01204574 	movhi	r4,33045
8111d6dc:	2103a404 	addi	r4,r4,3728
8111d6e0:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d6e4:	0001883a 	nop
8111d6e8:	e037883a 	mov	sp,fp
8111d6ec:	dfc00117 	ldw	ra,4(sp)
8111d6f0:	df000017 	ldw	fp,0(sp)
8111d6f4:	dec00204 	addi	sp,sp,8
8111d6f8:	f800283a 	ret

8111d6fc <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
8111d6fc:	defffe04 	addi	sp,sp,-8
8111d700:	de00012e 	bgeu	sp,et,8111d708 <vFailSetCountSemaphorexBuffer128+0xc>
8111d704:	003b68fa 	trap	3
8111d708:	dfc00115 	stw	ra,4(sp)
8111d70c:	df000015 	stw	fp,0(sp)
8111d710:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d714:	00a045f4 	movhi	r2,33047
8111d718:	10a25304 	addi	r2,r2,-30388
8111d71c:	10800a8b 	ldhu	r2,42(r2)
8111d720:	10bfffcc 	andi	r2,r2,65535
8111d724:	10800228 	cmpgeui	r2,r2,8
8111d728:	10000e1e 	bne	r2,zero,8111d764 <vFailSetCountSemaphorexBuffer128+0x68>
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
8111d72c:	d0a06217 	ldw	r2,-32376(gp)
8111d730:	100f883a 	mov	r7,r2
8111d734:	01800a44 	movi	r6,41
8111d738:	01400044 	movi	r5,1
8111d73c:	01204574 	movhi	r4,33045
8111d740:	2103b804 	addi	r4,r4,3808
8111d744:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not post to the semaphore.()\n");
8111d748:	d0a06217 	ldw	r2,-32376(gp)
8111d74c:	100f883a 	mov	r7,r2
8111d750:	018008c4 	movi	r6,35
8111d754:	01400044 	movi	r5,1
8111d758:	01204574 	movhi	r4,33045
8111d75c:	2103a404 	addi	r4,r4,3728
8111d760:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d764:	0001883a 	nop
8111d768:	e037883a 	mov	sp,fp
8111d76c:	dfc00117 	ldw	ra,4(sp)
8111d770:	df000017 	ldw	fp,0(sp)
8111d774:	dec00204 	addi	sp,sp,8
8111d778:	f800283a 	ret

8111d77c <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
8111d77c:	defffe04 	addi	sp,sp,-8
8111d780:	de00012e 	bgeu	sp,et,8111d788 <vFailGetCountSemaphorexBuffer128+0xc>
8111d784:	003b68fa 	trap	3
8111d788:	dfc00115 	stw	ra,4(sp)
8111d78c:	df000015 	stw	fp,0(sp)
8111d790:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d794:	00a045f4 	movhi	r2,33047
8111d798:	10a25304 	addi	r2,r2,-30388
8111d79c:	10800a8b 	ldhu	r2,42(r2)
8111d7a0:	10bfffcc 	andi	r2,r2,65535
8111d7a4:	10800228 	cmpgeui	r2,r2,8
8111d7a8:	10000e1e 	bne	r2,zero,8111d7e4 <vFailGetCountSemaphorexBuffer128+0x68>
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
8111d7ac:	d0a06217 	ldw	r2,-32376(gp)
8111d7b0:	100f883a 	mov	r7,r2
8111d7b4:	01800a44 	movi	r6,41
8111d7b8:	01400044 	movi	r5,1
8111d7bc:	01204574 	movhi	r4,33045
8111d7c0:	2103c304 	addi	r4,r4,3852
8111d7c4:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get to the semaphore.()\n");
8111d7c8:	d0a06217 	ldw	r2,-32376(gp)
8111d7cc:	100f883a 	mov	r7,r2
8111d7d0:	01800884 	movi	r6,34
8111d7d4:	01400044 	movi	r5,1
8111d7d8:	01204574 	movhi	r4,33045
8111d7dc:	2103ce04 	addi	r4,r4,3896
8111d7e0:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d7e4:	0001883a 	nop
8111d7e8:	e037883a 	mov	sp,fp
8111d7ec:	dfc00117 	ldw	ra,4(sp)
8111d7f0:	df000017 	ldw	fp,0(sp)
8111d7f4:	dec00204 	addi	sp,sp,8
8111d7f8:	f800283a 	ret

8111d7fc <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
8111d7fc:	defffe04 	addi	sp,sp,-8
8111d800:	de00012e 	bgeu	sp,et,8111d808 <vFailGetCountSemaphorexBuffer64+0xc>
8111d804:	003b68fa 	trap	3
8111d808:	dfc00115 	stw	ra,4(sp)
8111d80c:	df000015 	stw	fp,0(sp)
8111d810:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d814:	00a045f4 	movhi	r2,33047
8111d818:	10a25304 	addi	r2,r2,-30388
8111d81c:	10800a8b 	ldhu	r2,42(r2)
8111d820:	10bfffcc 	andi	r2,r2,65535
8111d824:	10800228 	cmpgeui	r2,r2,8
8111d828:	10000e1e 	bne	r2,zero,8111d864 <vFailGetCountSemaphorexBuffer64+0x68>
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
8111d82c:	d0a06217 	ldw	r2,-32376(gp)
8111d830:	100f883a 	mov	r7,r2
8111d834:	01800a04 	movi	r6,40
8111d838:	01400044 	movi	r5,1
8111d83c:	01204574 	movhi	r4,33045
8111d840:	2103d704 	addi	r4,r4,3932
8111d844:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get to the semaphore.()\n");
8111d848:	d0a06217 	ldw	r2,-32376(gp)
8111d84c:	100f883a 	mov	r7,r2
8111d850:	01800884 	movi	r6,34
8111d854:	01400044 	movi	r5,1
8111d858:	01204574 	movhi	r4,33045
8111d85c:	2103ce04 	addi	r4,r4,3896
8111d860:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d864:	0001883a 	nop
8111d868:	e037883a 	mov	sp,fp
8111d86c:	dfc00117 	ldw	ra,4(sp)
8111d870:	df000017 	ldw	fp,0(sp)
8111d874:	dec00204 	addi	sp,sp,8
8111d878:	f800283a 	ret

8111d87c <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
8111d87c:	defffe04 	addi	sp,sp,-8
8111d880:	de00012e 	bgeu	sp,et,8111d888 <vFailGetCountSemaphorexBuffer32+0xc>
8111d884:	003b68fa 	trap	3
8111d888:	dfc00115 	stw	ra,4(sp)
8111d88c:	df000015 	stw	fp,0(sp)
8111d890:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d894:	00a045f4 	movhi	r2,33047
8111d898:	10a25304 	addi	r2,r2,-30388
8111d89c:	10800a8b 	ldhu	r2,42(r2)
8111d8a0:	10bfffcc 	andi	r2,r2,65535
8111d8a4:	10800228 	cmpgeui	r2,r2,8
8111d8a8:	10000e1e 	bne	r2,zero,8111d8e4 <vFailGetCountSemaphorexBuffer32+0x68>
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
8111d8ac:	d0a06217 	ldw	r2,-32376(gp)
8111d8b0:	100f883a 	mov	r7,r2
8111d8b4:	01800a04 	movi	r6,40
8111d8b8:	01400044 	movi	r5,1
8111d8bc:	01204574 	movhi	r4,33045
8111d8c0:	2103e204 	addi	r4,r4,3976
8111d8c4:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get to the semaphore.()\n");
8111d8c8:	d0a06217 	ldw	r2,-32376(gp)
8111d8cc:	100f883a 	mov	r7,r2
8111d8d0:	01800884 	movi	r6,34
8111d8d4:	01400044 	movi	r5,1
8111d8d8:	01204574 	movhi	r4,33045
8111d8dc:	2103ce04 	addi	r4,r4,3896
8111d8e0:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d8e4:	0001883a 	nop
8111d8e8:	e037883a 	mov	sp,fp
8111d8ec:	dfc00117 	ldw	ra,4(sp)
8111d8f0:	df000017 	ldw	fp,0(sp)
8111d8f4:	dec00204 	addi	sp,sp,8
8111d8f8:	f800283a 	ret

8111d8fc <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
8111d8fc:	defffe04 	addi	sp,sp,-8
8111d900:	de00012e 	bgeu	sp,et,8111d908 <vFailFoundBufferRetransmission+0xc>
8111d904:	003b68fa 	trap	3
8111d908:	dfc00115 	stw	ra,4(sp)
8111d90c:	df000015 	stw	fp,0(sp)
8111d910:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d914:	00a045f4 	movhi	r2,33047
8111d918:	10a25304 	addi	r2,r2,-30388
8111d91c:	10800a8b 	ldhu	r2,42(r2)
8111d920:	10bfffcc 	andi	r2,r2,65535
8111d924:	10800228 	cmpgeui	r2,r2,8
8111d928:	10000e1e 	bne	r2,zero,8111d964 <vFailFoundBufferRetransmission+0x68>
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
8111d92c:	d0a06217 	ldw	r2,-32376(gp)
8111d930:	100f883a 	mov	r7,r2
8111d934:	01800a84 	movi	r6,42
8111d938:	01400044 	movi	r5,1
8111d93c:	01204574 	movhi	r4,33045
8111d940:	2103ed04 	addi	r4,r4,4020
8111d944:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
8111d948:	d0a06217 	ldw	r2,-32376(gp)
8111d94c:	100f883a 	mov	r7,r2
8111d950:	01801204 	movi	r6,72
8111d954:	01400044 	movi	r5,1
8111d958:	01204574 	movhi	r4,33045
8111d95c:	2103f804 	addi	r4,r4,4064
8111d960:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d964:	0001883a 	nop
8111d968:	e037883a 	mov	sp,fp
8111d96c:	dfc00117 	ldw	ra,4(sp)
8111d970:	df000017 	ldw	fp,0(sp)
8111d974:	dec00204 	addi	sp,sp,8
8111d978:	f800283a 	ret

8111d97c <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
8111d97c:	defffe04 	addi	sp,sp,-8
8111d980:	de00012e 	bgeu	sp,et,8111d988 <vFailGetCountSemaphorePreParsedBuffer+0xc>
8111d984:	003b68fa 	trap	3
8111d988:	dfc00115 	stw	ra,4(sp)
8111d98c:	df000015 	stw	fp,0(sp)
8111d990:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d994:	00a045f4 	movhi	r2,33047
8111d998:	10a25304 	addi	r2,r2,-30388
8111d99c:	10800a8b 	ldhu	r2,42(r2)
8111d9a0:	10bfffcc 	andi	r2,r2,65535
8111d9a4:	10800228 	cmpgeui	r2,r2,8
8111d9a8:	10000e1e 	bne	r2,zero,8111d9e4 <vFailGetCountSemaphorePreParsedBuffer+0x68>
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
8111d9ac:	d0a06217 	ldw	r2,-32376(gp)
8111d9b0:	100f883a 	mov	r7,r2
8111d9b4:	01800b84 	movi	r6,46
8111d9b8:	01400044 	movi	r5,1
8111d9bc:	01204574 	movhi	r4,33045
8111d9c0:	21040b04 	addi	r4,r4,4140
8111d9c4:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
8111d9c8:	d0a06217 	ldw	r2,-32376(gp)
8111d9cc:	100f883a 	mov	r7,r2
8111d9d0:	018010c4 	movi	r6,67
8111d9d4:	01400044 	movi	r5,1
8111d9d8:	01204574 	movhi	r4,33045
8111d9dc:	21041704 	addi	r4,r4,4188
8111d9e0:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d9e4:	0001883a 	nop
8111d9e8:	e037883a 	mov	sp,fp
8111d9ec:	dfc00117 	ldw	ra,4(sp)
8111d9f0:	df000017 	ldw	fp,0(sp)
8111d9f4:	dec00204 	addi	sp,sp,8
8111d9f8:	f800283a 	ret

8111d9fc <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
8111d9fc:	defffe04 	addi	sp,sp,-8
8111da00:	de00012e 	bgeu	sp,et,8111da08 <vFailGetxMutexPreParsedParserRxTask+0xc>
8111da04:	003b68fa 	trap	3
8111da08:	dfc00115 	stw	ra,4(sp)
8111da0c:	df000015 	stw	fp,0(sp)
8111da10:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111da14:	00a045f4 	movhi	r2,33047
8111da18:	10a25304 	addi	r2,r2,-30388
8111da1c:	10800a8b 	ldhu	r2,42(r2)
8111da20:	10bfffcc 	andi	r2,r2,65535
8111da24:	10800228 	cmpgeui	r2,r2,8
8111da28:	10000e1e 	bne	r2,zero,8111da64 <vFailGetxMutexPreParsedParserRxTask+0x68>
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
8111da2c:	d0a06217 	ldw	r2,-32376(gp)
8111da30:	100f883a 	mov	r7,r2
8111da34:	01800b04 	movi	r6,44
8111da38:	01400044 	movi	r5,1
8111da3c:	01204574 	movhi	r4,33045
8111da40:	21042804 	addi	r4,r4,4256
8111da44:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
8111da48:	d0a06217 	ldw	r2,-32376(gp)
8111da4c:	100f883a 	mov	r7,r2
8111da50:	01800fc4 	movi	r6,63
8111da54:	01400044 	movi	r5,1
8111da58:	01204574 	movhi	r4,33045
8111da5c:	21043404 	addi	r4,r4,4304
8111da60:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111da64:	0001883a 	nop
8111da68:	e037883a 	mov	sp,fp
8111da6c:	dfc00117 	ldw	ra,4(sp)
8111da70:	df000017 	ldw	fp,0(sp)
8111da74:	dec00204 	addi	sp,sp,8
8111da78:	f800283a 	ret

8111da7c <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
8111da7c:	defffe04 	addi	sp,sp,-8
8111da80:	de00012e 	bgeu	sp,et,8111da88 <vNoContentInPreParsedBuffer+0xc>
8111da84:	003b68fa 	trap	3
8111da88:	dfc00115 	stw	ra,4(sp)
8111da8c:	df000015 	stw	fp,0(sp)
8111da90:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111da94:	00a045f4 	movhi	r2,33047
8111da98:	10a25304 	addi	r2,r2,-30388
8111da9c:	10800a8b 	ldhu	r2,42(r2)
8111daa0:	10bfffcc 	andi	r2,r2,65535
8111daa4:	10800228 	cmpgeui	r2,r2,8
8111daa8:	10000e1e 	bne	r2,zero,8111dae4 <vNoContentInPreParsedBuffer+0x68>
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
8111daac:	d0a06217 	ldw	r2,-32376(gp)
8111dab0:	100f883a 	mov	r7,r2
8111dab4:	01800904 	movi	r6,36
8111dab8:	01400044 	movi	r5,1
8111dabc:	01204574 	movhi	r4,33045
8111dac0:	21044404 	addi	r4,r4,4368
8111dac4:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
8111dac8:	d0a06217 	ldw	r2,-32376(gp)
8111dacc:	100f883a 	mov	r7,r2
8111dad0:	01801684 	movi	r6,90
8111dad4:	01400044 	movi	r5,1
8111dad8:	01204574 	movhi	r4,33045
8111dadc:	21044e04 	addi	r4,r4,4408
8111dae0:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dae4:	0001883a 	nop
8111dae8:	e037883a 	mov	sp,fp
8111daec:	dfc00117 	ldw	ra,4(sp)
8111daf0:	df000017 	ldw	fp,0(sp)
8111daf4:	dec00204 	addi	sp,sp,8
8111daf8:	f800283a 	ret

8111dafc <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
8111dafc:	defffe04 	addi	sp,sp,-8
8111db00:	de00012e 	bgeu	sp,et,8111db08 <vCouldNotSendEthConfUART+0xc>
8111db04:	003b68fa 	trap	3
8111db08:	dfc00115 	stw	ra,4(sp)
8111db0c:	df000015 	stw	fp,0(sp)
8111db10:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111db14:	00a045f4 	movhi	r2,33047
8111db18:	10a25304 	addi	r2,r2,-30388
8111db1c:	10800a8b 	ldhu	r2,42(r2)
8111db20:	10bfffcc 	andi	r2,r2,65535
8111db24:	10800228 	cmpgeui	r2,r2,8
8111db28:	10000e1e 	bne	r2,zero,8111db64 <vCouldNotSendEthConfUART+0x68>
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
8111db2c:	d0a06217 	ldw	r2,-32376(gp)
8111db30:	100f883a 	mov	r7,r2
8111db34:	01800844 	movi	r6,33
8111db38:	01400044 	movi	r5,1
8111db3c:	01204574 	movhi	r4,33045
8111db40:	21046504 	addi	r4,r4,4500
8111db44:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
8111db48:	d0a06217 	ldw	r2,-32376(gp)
8111db4c:	100f883a 	mov	r7,r2
8111db50:	01801784 	movi	r6,94
8111db54:	01400044 	movi	r5,1
8111db58:	01204574 	movhi	r4,33045
8111db5c:	21046e04 	addi	r4,r4,4536
8111db60:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111db64:	0001883a 	nop
8111db68:	e037883a 	mov	sp,fp
8111db6c:	dfc00117 	ldw	ra,4(sp)
8111db70:	df000017 	ldw	fp,0(sp)
8111db74:	dec00204 	addi	sp,sp,8
8111db78:	f800283a 	ret

8111db7c <vFailSendNack>:

void vFailSendNack( void )
{
8111db7c:	defffe04 	addi	sp,sp,-8
8111db80:	de00012e 	bgeu	sp,et,8111db88 <vFailSendNack+0xc>
8111db84:	003b68fa 	trap	3
8111db88:	dfc00115 	stw	ra,4(sp)
8111db8c:	df000015 	stw	fp,0(sp)
8111db90:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111db94:	00a045f4 	movhi	r2,33047
8111db98:	10a25304 	addi	r2,r2,-30388
8111db9c:	10800a8b 	ldhu	r2,42(r2)
8111dba0:	10bfffcc 	andi	r2,r2,65535
8111dba4:	10800228 	cmpgeui	r2,r2,8
8111dba8:	10000e1e 	bne	r2,zero,8111dbe4 <vFailSendNack+0x68>
		debug(fp,"vFailSendNack. (exit)\n");
8111dbac:	d0a06217 	ldw	r2,-32376(gp)
8111dbb0:	100f883a 	mov	r7,r2
8111dbb4:	01800584 	movi	r6,22
8111dbb8:	01400044 	movi	r5,1
8111dbbc:	01204574 	movhi	r4,33045
8111dbc0:	21048604 	addi	r4,r4,4632
8111dbc4:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
8111dbc8:	d0a06217 	ldw	r2,-32376(gp)
8111dbcc:	100f883a 	mov	r7,r2
8111dbd0:	01800a84 	movi	r6,42
8111dbd4:	01400044 	movi	r5,1
8111dbd8:	01204574 	movhi	r4,33045
8111dbdc:	21048c04 	addi	r4,r4,4656
8111dbe0:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dbe4:	0001883a 	nop
8111dbe8:	e037883a 	mov	sp,fp
8111dbec:	dfc00117 	ldw	ra,4(sp)
8111dbf0:	df000017 	ldw	fp,0(sp)
8111dbf4:	dec00204 	addi	sp,sp,8
8111dbf8:	f800283a 	ret

8111dbfc <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
8111dbfc:	defffe04 	addi	sp,sp,-8
8111dc00:	de00012e 	bgeu	sp,et,8111dc08 <vFailSetPreAckSenderBuffer+0xc>
8111dc04:	003b68fa 	trap	3
8111dc08:	dfc00115 	stw	ra,4(sp)
8111dc0c:	df000015 	stw	fp,0(sp)
8111dc10:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dc14:	00a045f4 	movhi	r2,33047
8111dc18:	10a25304 	addi	r2,r2,-30388
8111dc1c:	10800a8b 	ldhu	r2,42(r2)
8111dc20:	10bfffcc 	andi	r2,r2,65535
8111dc24:	10800228 	cmpgeui	r2,r2,8
8111dc28:	10000e1e 	bne	r2,zero,8111dc64 <vFailSetPreAckSenderBuffer+0x68>
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
8111dc2c:	d0a06217 	ldw	r2,-32376(gp)
8111dc30:	100f883a 	mov	r7,r2
8111dc34:	018008c4 	movi	r6,35
8111dc38:	01400044 	movi	r5,1
8111dc3c:	01204574 	movhi	r4,33045
8111dc40:	21049704 	addi	r4,r4,4700
8111dc44:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
8111dc48:	d0a06217 	ldw	r2,-32376(gp)
8111dc4c:	100f883a 	mov	r7,r2
8111dc50:	01801584 	movi	r6,86
8111dc54:	01400044 	movi	r5,1
8111dc58:	01204574 	movhi	r4,33045
8111dc5c:	2104a004 	addi	r4,r4,4736
8111dc60:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dc64:	0001883a 	nop
8111dc68:	e037883a 	mov	sp,fp
8111dc6c:	dfc00117 	ldw	ra,4(sp)
8111dc70:	df000017 	ldw	fp,0(sp)
8111dc74:	dec00204 	addi	sp,sp,8
8111dc78:	f800283a 	ret

8111dc7c <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
8111dc7c:	defffe04 	addi	sp,sp,-8
8111dc80:	de00012e 	bgeu	sp,et,8111dc88 <vFailSetPreParsedBuffer+0xc>
8111dc84:	003b68fa 	trap	3
8111dc88:	dfc00115 	stw	ra,4(sp)
8111dc8c:	df000015 	stw	fp,0(sp)
8111dc90:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dc94:	00a045f4 	movhi	r2,33047
8111dc98:	10a25304 	addi	r2,r2,-30388
8111dc9c:	10800a8b 	ldhu	r2,42(r2)
8111dca0:	10bfffcc 	andi	r2,r2,65535
8111dca4:	10800228 	cmpgeui	r2,r2,8
8111dca8:	10000e1e 	bne	r2,zero,8111dce4 <vFailSetPreParsedBuffer+0x68>
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
8111dcac:	d0a06217 	ldw	r2,-32376(gp)
8111dcb0:	100f883a 	mov	r7,r2
8111dcb4:	01800804 	movi	r6,32
8111dcb8:	01400044 	movi	r5,1
8111dcbc:	01204574 	movhi	r4,33045
8111dcc0:	2104b604 	addi	r4,r4,4824
8111dcc4:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
8111dcc8:	d0a06217 	ldw	r2,-32376(gp)
8111dccc:	100f883a 	mov	r7,r2
8111dcd0:	018013c4 	movi	r6,79
8111dcd4:	01400044 	movi	r5,1
8111dcd8:	01204574 	movhi	r4,33045
8111dcdc:	2104bf04 	addi	r4,r4,4860
8111dce0:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dce4:	0001883a 	nop
8111dce8:	e037883a 	mov	sp,fp
8111dcec:	dfc00117 	ldw	ra,4(sp)
8111dcf0:	df000017 	ldw	fp,0(sp)
8111dcf4:	dec00204 	addi	sp,sp,8
8111dcf8:	f800283a 	ret

8111dcfc <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
8111dcfc:	defffe04 	addi	sp,sp,-8
8111dd00:	de00012e 	bgeu	sp,et,8111dd08 <vFailSetPreAckReceiverBuffer+0xc>
8111dd04:	003b68fa 	trap	3
8111dd08:	dfc00115 	stw	ra,4(sp)
8111dd0c:	df000015 	stw	fp,0(sp)
8111dd10:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dd14:	00a045f4 	movhi	r2,33047
8111dd18:	10a25304 	addi	r2,r2,-30388
8111dd1c:	10800a8b 	ldhu	r2,42(r2)
8111dd20:	10bfffcc 	andi	r2,r2,65535
8111dd24:	10800228 	cmpgeui	r2,r2,8
8111dd28:	10000e1e 	bne	r2,zero,8111dd64 <vFailSetPreAckReceiverBuffer+0x68>
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
8111dd2c:	d0a06217 	ldw	r2,-32376(gp)
8111dd30:	100f883a 	mov	r7,r2
8111dd34:	01800944 	movi	r6,37
8111dd38:	01400044 	movi	r5,1
8111dd3c:	01204574 	movhi	r4,33045
8111dd40:	2104d304 	addi	r4,r4,4940
8111dd44:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
8111dd48:	d0a06217 	ldw	r2,-32376(gp)
8111dd4c:	100f883a 	mov	r7,r2
8111dd50:	018015c4 	movi	r6,87
8111dd54:	01400044 	movi	r5,1
8111dd58:	01204574 	movhi	r4,33045
8111dd5c:	2104dd04 	addi	r4,r4,4980
8111dd60:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dd64:	0001883a 	nop
8111dd68:	e037883a 	mov	sp,fp
8111dd6c:	dfc00117 	ldw	ra,4(sp)
8111dd70:	df000017 	ldw	fp,0(sp)
8111dd74:	dec00204 	addi	sp,sp,8
8111dd78:	f800283a 	ret

8111dd7c <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
8111dd7c:	defffe04 	addi	sp,sp,-8
8111dd80:	de00012e 	bgeu	sp,et,8111dd88 <vFailParserCommTaskCreate+0xc>
8111dd84:	003b68fa 	trap	3
8111dd88:	dfc00115 	stw	ra,4(sp)
8111dd8c:	df000015 	stw	fp,0(sp)
8111dd90:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dd94:	00a045f4 	movhi	r2,33047
8111dd98:	10a25304 	addi	r2,r2,-30388
8111dd9c:	10800a8b 	ldhu	r2,42(r2)
8111dda0:	10bfffcc 	andi	r2,r2,65535
8111dda4:	10800228 	cmpgeui	r2,r2,8
8111dda8:	1000071e 	bne	r2,zero,8111ddc8 <vFailParserCommTaskCreate+0x4c>
		debug(fp,"vFailParserCommTaskCreate\n");
8111ddac:	d0a06217 	ldw	r2,-32376(gp)
8111ddb0:	100f883a 	mov	r7,r2
8111ddb4:	01800684 	movi	r6,26
8111ddb8:	01400044 	movi	r5,1
8111ddbc:	01204574 	movhi	r4,33045
8111ddc0:	2104f304 	addi	r4,r4,5068
8111ddc4:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ddc8:	0001883a 	nop
8111ddcc:	e037883a 	mov	sp,fp
8111ddd0:	dfc00117 	ldw	ra,4(sp)
8111ddd4:	df000017 	ldw	fp,0(sp)
8111ddd8:	dec00204 	addi	sp,sp,8
8111dddc:	f800283a 	ret

8111dde0 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8111dde0:	defffe04 	addi	sp,sp,-8
8111dde4:	de00012e 	bgeu	sp,et,8111ddec <vFailInAckHandlerTaskCreate+0xc>
8111dde8:	003b68fa 	trap	3
8111ddec:	dfc00115 	stw	ra,4(sp)
8111ddf0:	df000015 	stw	fp,0(sp)
8111ddf4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ddf8:	00a045f4 	movhi	r2,33047
8111ddfc:	10a25304 	addi	r2,r2,-30388
8111de00:	10800a8b 	ldhu	r2,42(r2)
8111de04:	10bfffcc 	andi	r2,r2,65535
8111de08:	10800228 	cmpgeui	r2,r2,8
8111de0c:	1000071e 	bne	r2,zero,8111de2c <vFailInAckHandlerTaskCreate+0x4c>
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111de10:	d0a06217 	ldw	r2,-32376(gp)
8111de14:	100f883a 	mov	r7,r2
8111de18:	01800704 	movi	r6,28
8111de1c:	01400044 	movi	r5,1
8111de20:	01204574 	movhi	r4,33045
8111de24:	2104fa04 	addi	r4,r4,5096
8111de28:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111de2c:	0001883a 	nop
8111de30:	e037883a 	mov	sp,fp
8111de34:	dfc00117 	ldw	ra,4(sp)
8111de38:	df000017 	ldw	fp,0(sp)
8111de3c:	dec00204 	addi	sp,sp,8
8111de40:	f800283a 	ret

8111de44 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
8111de44:	defffe04 	addi	sp,sp,-8
8111de48:	de00012e 	bgeu	sp,et,8111de50 <vFailOutAckHandlerTaskCreate+0xc>
8111de4c:	003b68fa 	trap	3
8111de50:	dfc00115 	stw	ra,4(sp)
8111de54:	df000015 	stw	fp,0(sp)
8111de58:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111de5c:	00a045f4 	movhi	r2,33047
8111de60:	10a25304 	addi	r2,r2,-30388
8111de64:	10800a8b 	ldhu	r2,42(r2)
8111de68:	10bfffcc 	andi	r2,r2,65535
8111de6c:	10800228 	cmpgeui	r2,r2,8
8111de70:	1000071e 	bne	r2,zero,8111de90 <vFailOutAckHandlerTaskCreate+0x4c>
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111de74:	d0a06217 	ldw	r2,-32376(gp)
8111de78:	100f883a 	mov	r7,r2
8111de7c:	01800704 	movi	r6,28
8111de80:	01400044 	movi	r5,1
8111de84:	01204574 	movhi	r4,33045
8111de88:	2104fa04 	addi	r4,r4,5096
8111de8c:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111de90:	0001883a 	nop
8111de94:	e037883a 	mov	sp,fp
8111de98:	dfc00117 	ldw	ra,4(sp)
8111de9c:	df000017 	ldw	fp,0(sp)
8111dea0:	dec00204 	addi	sp,sp,8
8111dea4:	f800283a 	ret

8111dea8 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8111dea8:	defffe04 	addi	sp,sp,-8
8111deac:	de00012e 	bgeu	sp,et,8111deb4 <vFailCreateTimerRetransmisison+0xc>
8111deb0:	003b68fa 	trap	3
8111deb4:	dfc00115 	stw	ra,4(sp)
8111deb8:	df000015 	stw	fp,0(sp)
8111debc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dec0:	00a045f4 	movhi	r2,33047
8111dec4:	10a25304 	addi	r2,r2,-30388
8111dec8:	10800a8b 	ldhu	r2,42(r2)
8111decc:	10bfffcc 	andi	r2,r2,65535
8111ded0:	10800228 	cmpgeui	r2,r2,8
8111ded4:	1000071e 	bne	r2,zero,8111def4 <vFailCreateTimerRetransmisison+0x4c>
		debug(fp,"vFailCreateTimerRetransmisison\n");
8111ded8:	d0a06217 	ldw	r2,-32376(gp)
8111dedc:	100f883a 	mov	r7,r2
8111dee0:	018007c4 	movi	r6,31
8111dee4:	01400044 	movi	r5,1
8111dee8:	01204574 	movhi	r4,33045
8111deec:	21050204 	addi	r4,r4,5128
8111def0:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111def4:	0001883a 	nop
8111def8:	e037883a 	mov	sp,fp
8111defc:	dfc00117 	ldw	ra,4(sp)
8111df00:	df000017 	ldw	fp,0(sp)
8111df04:	dec00204 	addi	sp,sp,8
8111df08:	f800283a 	ret

8111df0c <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
8111df0c:	defffe04 	addi	sp,sp,-8
8111df10:	de00012e 	bgeu	sp,et,8111df18 <vCouldNotCheckBufferTimeOutFunction+0xc>
8111df14:	003b68fa 	trap	3
8111df18:	dfc00115 	stw	ra,4(sp)
8111df1c:	df000015 	stw	fp,0(sp)
8111df20:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111df24:	00a045f4 	movhi	r2,33047
8111df28:	10a25304 	addi	r2,r2,-30388
8111df2c:	10800a8b 	ldhu	r2,42(r2)
8111df30:	10bfffcc 	andi	r2,r2,65535
8111df34:	10800228 	cmpgeui	r2,r2,8
8111df38:	1000071e 	bne	r2,zero,8111df58 <vCouldNotCheckBufferTimeOutFunction+0x4c>
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
8111df3c:	d0a06217 	ldw	r2,-32376(gp)
8111df40:	100f883a 	mov	r7,r2
8111df44:	01800904 	movi	r6,36
8111df48:	01400044 	movi	r5,1
8111df4c:	01204574 	movhi	r4,33045
8111df50:	21050a04 	addi	r4,r4,5160
8111df54:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111df58:	0001883a 	nop
8111df5c:	e037883a 	mov	sp,fp
8111df60:	dfc00117 	ldw	ra,4(sp)
8111df64:	df000017 	ldw	fp,0(sp)
8111df68:	dec00204 	addi	sp,sp,8
8111df6c:	f800283a 	ret

8111df70 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
8111df70:	defffe04 	addi	sp,sp,-8
8111df74:	de00012e 	bgeu	sp,et,8111df7c <vFailTimeoutCheckerTaskCreate+0xc>
8111df78:	003b68fa 	trap	3
8111df7c:	dfc00115 	stw	ra,4(sp)
8111df80:	df000015 	stw	fp,0(sp)
8111df84:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111df88:	00a045f4 	movhi	r2,33047
8111df8c:	10a25304 	addi	r2,r2,-30388
8111df90:	10800a8b 	ldhu	r2,42(r2)
8111df94:	10bfffcc 	andi	r2,r2,65535
8111df98:	10800228 	cmpgeui	r2,r2,8
8111df9c:	1000071e 	bne	r2,zero,8111dfbc <vFailTimeoutCheckerTaskCreate+0x4c>
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
8111dfa0:	d0a06217 	ldw	r2,-32376(gp)
8111dfa4:	100f883a 	mov	r7,r2
8111dfa8:	01800a04 	movi	r6,40
8111dfac:	01400044 	movi	r5,1
8111dfb0:	01204574 	movhi	r4,33045
8111dfb4:	21051404 	addi	r4,r4,5200
8111dfb8:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dfbc:	0001883a 	nop
8111dfc0:	e037883a 	mov	sp,fp
8111dfc4:	dfc00117 	ldw	ra,4(sp)
8111dfc8:	df000017 	ldw	fp,0(sp)
8111dfcc:	dec00204 	addi	sp,sp,8
8111dfd0:	f800283a 	ret

8111dfd4 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
8111dfd4:	defffe04 	addi	sp,sp,-8
8111dfd8:	de00012e 	bgeu	sp,et,8111dfe0 <vFailGetBlockingSemTimeoutTask+0xc>
8111dfdc:	003b68fa 	trap	3
8111dfe0:	dfc00115 	stw	ra,4(sp)
8111dfe4:	df000015 	stw	fp,0(sp)
8111dfe8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dfec:	00a045f4 	movhi	r2,33047
8111dff0:	10a25304 	addi	r2,r2,-30388
8111dff4:	10800a8b 	ldhu	r2,42(r2)
8111dff8:	10bfffcc 	andi	r2,r2,65535
8111dffc:	10800228 	cmpgeui	r2,r2,8
8111e000:	10000e1e 	bne	r2,zero,8111e03c <vFailGetBlockingSemTimeoutTask+0x68>
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
8111e004:	d0a06217 	ldw	r2,-32376(gp)
8111e008:	100f883a 	mov	r7,r2
8111e00c:	018009c4 	movi	r6,39
8111e010:	01400044 	movi	r5,1
8111e014:	01204574 	movhi	r4,33045
8111e018:	21051f04 	addi	r4,r4,5244
8111e01c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
8111e020:	d0a06217 	ldw	r2,-32376(gp)
8111e024:	100f883a 	mov	r7,r2
8111e028:	01800cc4 	movi	r6,51
8111e02c:	01400044 	movi	r5,1
8111e030:	01204574 	movhi	r4,33045
8111e034:	21052904 	addi	r4,r4,5284
8111e038:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e03c:	0001883a 	nop
8111e040:	e037883a 	mov	sp,fp
8111e044:	dfc00117 	ldw	ra,4(sp)
8111e048:	df000017 	ldw	fp,0(sp)
8111e04c:	dec00204 	addi	sp,sp,8
8111e050:	f800283a 	ret

8111e054 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
8111e054:	defffe04 	addi	sp,sp,-8
8111e058:	de00012e 	bgeu	sp,et,8111e060 <vFailPostBlockingSemTimeoutTask+0xc>
8111e05c:	003b68fa 	trap	3
8111e060:	dfc00115 	stw	ra,4(sp)
8111e064:	df000015 	stw	fp,0(sp)
8111e068:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e06c:	00a045f4 	movhi	r2,33047
8111e070:	10a25304 	addi	r2,r2,-30388
8111e074:	10800a8b 	ldhu	r2,42(r2)
8111e078:	10bfffcc 	andi	r2,r2,65535
8111e07c:	10800228 	cmpgeui	r2,r2,8
8111e080:	10000e1e 	bne	r2,zero,8111e0bc <vFailPostBlockingSemTimeoutTask+0x68>
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
8111e084:	d0a06217 	ldw	r2,-32376(gp)
8111e088:	100f883a 	mov	r7,r2
8111e08c:	01800a04 	movi	r6,40
8111e090:	01400044 	movi	r5,1
8111e094:	01204574 	movhi	r4,33045
8111e098:	21053604 	addi	r4,r4,5336
8111e09c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
8111e0a0:	d0a06217 	ldw	r2,-32376(gp)
8111e0a4:	100f883a 	mov	r7,r2
8111e0a8:	01800c84 	movi	r6,50
8111e0ac:	01400044 	movi	r5,1
8111e0b0:	01204574 	movhi	r4,33045
8111e0b4:	21054104 	addi	r4,r4,5380
8111e0b8:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e0bc:	0001883a 	nop
8111e0c0:	e037883a 	mov	sp,fp
8111e0c4:	dfc00117 	ldw	ra,4(sp)
8111e0c8:	df000017 	ldw	fp,0(sp)
8111e0cc:	dec00204 	addi	sp,sp,8
8111e0d0:	f800283a 	ret

8111e0d4 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
8111e0d4:	defffe04 	addi	sp,sp,-8
8111e0d8:	de00012e 	bgeu	sp,et,8111e0e0 <vFailCouldNotRetransmitTimeoutTask+0xc>
8111e0dc:	003b68fa 	trap	3
8111e0e0:	dfc00115 	stw	ra,4(sp)
8111e0e4:	df000015 	stw	fp,0(sp)
8111e0e8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e0ec:	00a045f4 	movhi	r2,33047
8111e0f0:	10a25304 	addi	r2,r2,-30388
8111e0f4:	10800a8b 	ldhu	r2,42(r2)
8111e0f8:	10bfffcc 	andi	r2,r2,65535
8111e0fc:	10800228 	cmpgeui	r2,r2,8
8111e100:	10000e1e 	bne	r2,zero,8111e13c <vFailCouldNotRetransmitTimeoutTask+0x68>
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
8111e104:	d0a06217 	ldw	r2,-32376(gp)
8111e108:	100f883a 	mov	r7,r2
8111e10c:	01800ac4 	movi	r6,43
8111e110:	01400044 	movi	r5,1
8111e114:	01204574 	movhi	r4,33045
8111e118:	21054e04 	addi	r4,r4,5432
8111e11c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
8111e120:	d0a06217 	ldw	r2,-32376(gp)
8111e124:	100f883a 	mov	r7,r2
8111e128:	01801644 	movi	r6,89
8111e12c:	01400044 	movi	r5,1
8111e130:	01204574 	movhi	r4,33045
8111e134:	21055904 	addi	r4,r4,5476
8111e138:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e13c:	0001883a 	nop
8111e140:	e037883a 	mov	sp,fp
8111e144:	dfc00117 	ldw	ra,4(sp)
8111e148:	df000017 	ldw	fp,0(sp)
8111e14c:	dec00204 	addi	sp,sp,8
8111e150:	f800283a 	ret

8111e154 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
8111e154:	defffe04 	addi	sp,sp,-8
8111e158:	de00012e 	bgeu	sp,et,8111e160 <vCouldNotRetransmitB32TimeoutTask+0xc>
8111e15c:	003b68fa 	trap	3
8111e160:	dfc00115 	stw	ra,4(sp)
8111e164:	df000015 	stw	fp,0(sp)
8111e168:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e16c:	00a045f4 	movhi	r2,33047
8111e170:	10a25304 	addi	r2,r2,-30388
8111e174:	10800a8b 	ldhu	r2,42(r2)
8111e178:	10bfffcc 	andi	r2,r2,65535
8111e17c:	10800228 	cmpgeui	r2,r2,8
8111e180:	10000e1e 	bne	r2,zero,8111e1bc <vCouldNotRetransmitB32TimeoutTask+0x68>
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
8111e184:	d0a06217 	ldw	r2,-32376(gp)
8111e188:	100f883a 	mov	r7,r2
8111e18c:	01800a84 	movi	r6,42
8111e190:	01400044 	movi	r5,1
8111e194:	01204574 	movhi	r4,33045
8111e198:	21057004 	addi	r4,r4,5568
8111e19c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
8111e1a0:	d0a06217 	ldw	r2,-32376(gp)
8111e1a4:	100f883a 	mov	r7,r2
8111e1a8:	01801444 	movi	r6,81
8111e1ac:	01400044 	movi	r5,1
8111e1b0:	01204574 	movhi	r4,33045
8111e1b4:	21057b04 	addi	r4,r4,5612
8111e1b8:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e1bc:	0001883a 	nop
8111e1c0:	e037883a 	mov	sp,fp
8111e1c4:	dfc00117 	ldw	ra,4(sp)
8111e1c8:	df000017 	ldw	fp,0(sp)
8111e1cc:	dec00204 	addi	sp,sp,8
8111e1d0:	f800283a 	ret

8111e1d4 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
8111e1d4:	defffe04 	addi	sp,sp,-8
8111e1d8:	de00012e 	bgeu	sp,et,8111e1e0 <vCouldNotRetransmitB64TimeoutTask+0xc>
8111e1dc:	003b68fa 	trap	3
8111e1e0:	dfc00115 	stw	ra,4(sp)
8111e1e4:	df000015 	stw	fp,0(sp)
8111e1e8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e1ec:	00a045f4 	movhi	r2,33047
8111e1f0:	10a25304 	addi	r2,r2,-30388
8111e1f4:	10800a8b 	ldhu	r2,42(r2)
8111e1f8:	10bfffcc 	andi	r2,r2,65535
8111e1fc:	10800228 	cmpgeui	r2,r2,8
8111e200:	10000e1e 	bne	r2,zero,8111e23c <vCouldNotRetransmitB64TimeoutTask+0x68>
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
8111e204:	d0a06217 	ldw	r2,-32376(gp)
8111e208:	100f883a 	mov	r7,r2
8111e20c:	01800a84 	movi	r6,42
8111e210:	01400044 	movi	r5,1
8111e214:	01204574 	movhi	r4,33045
8111e218:	21059004 	addi	r4,r4,5696
8111e21c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
8111e220:	d0a06217 	ldw	r2,-32376(gp)
8111e224:	100f883a 	mov	r7,r2
8111e228:	01801444 	movi	r6,81
8111e22c:	01400044 	movi	r5,1
8111e230:	01204574 	movhi	r4,33045
8111e234:	21059b04 	addi	r4,r4,5740
8111e238:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e23c:	0001883a 	nop
8111e240:	e037883a 	mov	sp,fp
8111e244:	dfc00117 	ldw	ra,4(sp)
8111e248:	df000017 	ldw	fp,0(sp)
8111e24c:	dec00204 	addi	sp,sp,8
8111e250:	f800283a 	ret

8111e254 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
8111e254:	defffe04 	addi	sp,sp,-8
8111e258:	de00012e 	bgeu	sp,et,8111e260 <vCouldNotRetransmitB128TimeoutTask+0xc>
8111e25c:	003b68fa 	trap	3
8111e260:	dfc00115 	stw	ra,4(sp)
8111e264:	df000015 	stw	fp,0(sp)
8111e268:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e26c:	00a045f4 	movhi	r2,33047
8111e270:	10a25304 	addi	r2,r2,-30388
8111e274:	10800a8b 	ldhu	r2,42(r2)
8111e278:	10bfffcc 	andi	r2,r2,65535
8111e27c:	10800228 	cmpgeui	r2,r2,8
8111e280:	10000e1e 	bne	r2,zero,8111e2bc <vCouldNotRetransmitB128TimeoutTask+0x68>
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
8111e284:	d0a06217 	ldw	r2,-32376(gp)
8111e288:	100f883a 	mov	r7,r2
8111e28c:	01800ac4 	movi	r6,43
8111e290:	01400044 	movi	r5,1
8111e294:	01204574 	movhi	r4,33045
8111e298:	2105b004 	addi	r4,r4,5824
8111e29c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
8111e2a0:	d0a06217 	ldw	r2,-32376(gp)
8111e2a4:	100f883a 	mov	r7,r2
8111e2a8:	01801484 	movi	r6,82
8111e2ac:	01400044 	movi	r5,1
8111e2b0:	01204574 	movhi	r4,33045
8111e2b4:	2105bb04 	addi	r4,r4,5868
8111e2b8:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e2bc:	0001883a 	nop
8111e2c0:	e037883a 	mov	sp,fp
8111e2c4:	dfc00117 	ldw	ra,4(sp)
8111e2c8:	df000017 	ldw	fp,0(sp)
8111e2cc:	dec00204 	addi	sp,sp,8
8111e2d0:	f800283a 	ret

8111e2d4 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
8111e2d4:	defffe04 	addi	sp,sp,-8
8111e2d8:	de00012e 	bgeu	sp,et,8111e2e0 <vFailStartTimerRetransmission+0xc>
8111e2dc:	003b68fa 	trap	3
8111e2e0:	dfc00115 	stw	ra,4(sp)
8111e2e4:	df000015 	stw	fp,0(sp)
8111e2e8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e2ec:	00a045f4 	movhi	r2,33047
8111e2f0:	10a25304 	addi	r2,r2,-30388
8111e2f4:	10800a8b 	ldhu	r2,42(r2)
8111e2f8:	10bfffcc 	andi	r2,r2,65535
8111e2fc:	10800228 	cmpgeui	r2,r2,8
8111e300:	10000e1e 	bne	r2,zero,8111e33c <vFailStartTimerRetransmission+0x68>
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
8111e304:	d0a06217 	ldw	r2,-32376(gp)
8111e308:	100f883a 	mov	r7,r2
8111e30c:	01800984 	movi	r6,38
8111e310:	01400044 	movi	r5,1
8111e314:	01204574 	movhi	r4,33045
8111e318:	2105d004 	addi	r4,r4,5952
8111e31c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
8111e320:	d0a06217 	ldw	r2,-32376(gp)
8111e324:	100f883a 	mov	r7,r2
8111e328:	01800d44 	movi	r6,53
8111e32c:	01400044 	movi	r5,1
8111e330:	01204574 	movhi	r4,33045
8111e334:	2105da04 	addi	r4,r4,5992
8111e338:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e33c:	0001883a 	nop
8111e340:	e037883a 	mov	sp,fp
8111e344:	dfc00117 	ldw	ra,4(sp)
8111e348:	df000017 	ldw	fp,0(sp)
8111e34c:	dec00204 	addi	sp,sp,8
8111e350:	f800283a 	ret

8111e354 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
8111e354:	defffe04 	addi	sp,sp,-8
8111e358:	de00012e 	bgeu	sp,et,8111e360 <vCouldNotSendTurnOff+0xc>
8111e35c:	003b68fa 	trap	3
8111e360:	dfc00115 	stw	ra,4(sp)
8111e364:	df000015 	stw	fp,0(sp)
8111e368:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e36c:	00a045f4 	movhi	r2,33047
8111e370:	10a25304 	addi	r2,r2,-30388
8111e374:	10800a8b 	ldhu	r2,42(r2)
8111e378:	10bfffcc 	andi	r2,r2,65535
8111e37c:	10800228 	cmpgeui	r2,r2,8
8111e380:	10000e1e 	bne	r2,zero,8111e3bc <vCouldNotSendTurnOff+0x68>
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
8111e384:	d0a06217 	ldw	r2,-32376(gp)
8111e388:	100f883a 	mov	r7,r2
8111e38c:	01800744 	movi	r6,29
8111e390:	01400044 	movi	r5,1
8111e394:	01204574 	movhi	r4,33045
8111e398:	2105e804 	addi	r4,r4,6048
8111e39c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not send the turn off command. \n");
8111e3a0:	d0a06217 	ldw	r2,-32376(gp)
8111e3a4:	100f883a 	mov	r7,r2
8111e3a8:	01800984 	movi	r6,38
8111e3ac:	01400044 	movi	r5,1
8111e3b0:	01204574 	movhi	r4,33045
8111e3b4:	2105f004 	addi	r4,r4,6080
8111e3b8:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e3bc:	0001883a 	nop
8111e3c0:	e037883a 	mov	sp,fp
8111e3c4:	dfc00117 	ldw	ra,4(sp)
8111e3c8:	df000017 	ldw	fp,0(sp)
8111e3cc:	dec00204 	addi	sp,sp,8
8111e3d0:	f800283a 	ret

8111e3d4 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
8111e3d4:	defffe04 	addi	sp,sp,-8
8111e3d8:	de00012e 	bgeu	sp,et,8111e3e0 <vCouldNotSendReset+0xc>
8111e3dc:	003b68fa 	trap	3
8111e3e0:	dfc00115 	stw	ra,4(sp)
8111e3e4:	df000015 	stw	fp,0(sp)
8111e3e8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e3ec:	00a045f4 	movhi	r2,33047
8111e3f0:	10a25304 	addi	r2,r2,-30388
8111e3f4:	10800a8b 	ldhu	r2,42(r2)
8111e3f8:	10bfffcc 	andi	r2,r2,65535
8111e3fc:	10800228 	cmpgeui	r2,r2,8
8111e400:	10000e1e 	bne	r2,zero,8111e43c <vCouldNotSendReset+0x68>
		debug(fp,"vCouldNotSendReset. (exit)\n");
8111e404:	d0a06217 	ldw	r2,-32376(gp)
8111e408:	100f883a 	mov	r7,r2
8111e40c:	018006c4 	movi	r6,27
8111e410:	01400044 	movi	r5,1
8111e414:	01204574 	movhi	r4,33045
8111e418:	2105fa04 	addi	r4,r4,6120
8111e41c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not send the reset command. \n");
8111e420:	d0a06217 	ldw	r2,-32376(gp)
8111e424:	100f883a 	mov	r7,r2
8111e428:	018008c4 	movi	r6,35
8111e42c:	01400044 	movi	r5,1
8111e430:	01204574 	movhi	r4,33045
8111e434:	21060104 	addi	r4,r4,6148
8111e438:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e43c:	0001883a 	nop
8111e440:	e037883a 	mov	sp,fp
8111e444:	dfc00117 	ldw	ra,4(sp)
8111e448:	df000017 	ldw	fp,0(sp)
8111e44c:	dec00204 	addi	sp,sp,8
8111e450:	f800283a 	ret

8111e454 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
8111e454:	defffe04 	addi	sp,sp,-8
8111e458:	de00012e 	bgeu	sp,et,8111e460 <vCouldNotSendLog+0xc>
8111e45c:	003b68fa 	trap	3
8111e460:	dfc00115 	stw	ra,4(sp)
8111e464:	df000015 	stw	fp,0(sp)
8111e468:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e46c:	00a045f4 	movhi	r2,33047
8111e470:	10a25304 	addi	r2,r2,-30388
8111e474:	10800a8b 	ldhu	r2,42(r2)
8111e478:	10bfffcc 	andi	r2,r2,65535
8111e47c:	10800228 	cmpgeui	r2,r2,8
8111e480:	10000e1e 	bne	r2,zero,8111e4bc <vCouldNotSendLog+0x68>
		debug(fp,"vCouldNotSendLog. (exit)\n");
8111e484:	d0a06217 	ldw	r2,-32376(gp)
8111e488:	100f883a 	mov	r7,r2
8111e48c:	01800644 	movi	r6,25
8111e490:	01400044 	movi	r5,1
8111e494:	01204574 	movhi	r4,33045
8111e498:	21060a04 	addi	r4,r4,6184
8111e49c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not send log packet to NUC. \n");
8111e4a0:	d0a06217 	ldw	r2,-32376(gp)
8111e4a4:	100f883a 	mov	r7,r2
8111e4a8:	018008c4 	movi	r6,35
8111e4ac:	01400044 	movi	r5,1
8111e4b0:	01204574 	movhi	r4,33045
8111e4b4:	21061104 	addi	r4,r4,6212
8111e4b8:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e4bc:	0001883a 	nop
8111e4c0:	e037883a 	mov	sp,fp
8111e4c4:	dfc00117 	ldw	ra,4(sp)
8111e4c8:	df000017 	ldw	fp,0(sp)
8111e4cc:	dec00204 	addi	sp,sp,8
8111e4d0:	f800283a 	ret

8111e4d4 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
8111e4d4:	defffd04 	addi	sp,sp,-12
8111e4d8:	de00012e 	bgeu	sp,et,8111e4e0 <vCouldNotSendTMPusCommand+0xc>
8111e4dc:	003b68fa 	trap	3
8111e4e0:	dfc00215 	stw	ra,8(sp)
8111e4e4:	df000115 	stw	fp,4(sp)
8111e4e8:	df000104 	addi	fp,sp,4
8111e4ec:	e13fff15 	stw	r4,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e4f0:	00a045f4 	movhi	r2,33047
8111e4f4:	10a25304 	addi	r2,r2,-30388
8111e4f8:	10800a8b 	ldhu	r2,42(r2)
8111e4fc:	10bfffcc 	andi	r2,r2,65535
8111e500:	10800228 	cmpgeui	r2,r2,8
8111e504:	1000151e 	bne	r2,zero,8111e55c <vCouldNotSendTMPusCommand+0x88>
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
8111e508:	d0a06217 	ldw	r2,-32376(gp)
8111e50c:	100f883a 	mov	r7,r2
8111e510:	01800884 	movi	r6,34
8111e514:	01400044 	movi	r5,1
8111e518:	01204574 	movhi	r4,33045
8111e51c:	21061a04 	addi	r4,r4,6248
8111e520:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not send the TM PUS command to NUC. \n");
8111e524:	d0a06217 	ldw	r2,-32376(gp)
8111e528:	100f883a 	mov	r7,r2
8111e52c:	01800ac4 	movi	r6,43
8111e530:	01400044 	movi	r5,1
8111e534:	01204574 	movhi	r4,33045
8111e538:	21062304 	addi	r4,r4,6284
8111e53c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"cData");
8111e540:	d0a06217 	ldw	r2,-32376(gp)
8111e544:	100f883a 	mov	r7,r2
8111e548:	01800144 	movi	r6,5
8111e54c:	01400044 	movi	r5,1
8111e550:	01204574 	movhi	r4,33045
8111e554:	21062e04 	addi	r4,r4,6328
8111e558:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e55c:	0001883a 	nop
8111e560:	e037883a 	mov	sp,fp
8111e564:	dfc00117 	ldw	ra,4(sp)
8111e568:	df000017 	ldw	fp,0(sp)
8111e56c:	dec00204 	addi	sp,sp,8
8111e570:	f800283a 	ret

8111e574 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
8111e574:	defffe04 	addi	sp,sp,-8
8111e578:	de00012e 	bgeu	sp,et,8111e580 <vWarnCouldNotgetMutexRetrans128+0xc>
8111e57c:	003b68fa 	trap	3
8111e580:	dfc00115 	stw	ra,4(sp)
8111e584:	df000015 	stw	fp,0(sp)
8111e588:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e58c:	00a045f4 	movhi	r2,33047
8111e590:	10a25304 	addi	r2,r2,-30388
8111e594:	10800a8b 	ldhu	r2,42(r2)
8111e598:	10bfffcc 	andi	r2,r2,65535
8111e59c:	10800228 	cmpgeui	r2,r2,8
8111e5a0:	10000e1e 	bne	r2,zero,8111e5dc <vWarnCouldNotgetMutexRetrans128+0x68>
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
8111e5a4:	d0a06217 	ldw	r2,-32376(gp)
8111e5a8:	100f883a 	mov	r7,r2
8111e5ac:	01800a04 	movi	r6,40
8111e5b0:	01400044 	movi	r5,1
8111e5b4:	01204574 	movhi	r4,33045
8111e5b8:	21063004 	addi	r4,r4,6336
8111e5bc:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
8111e5c0:	d0a06217 	ldw	r2,-32376(gp)
8111e5c4:	100f883a 	mov	r7,r2
8111e5c8:	018014c4 	movi	r6,83
8111e5cc:	01400044 	movi	r5,1
8111e5d0:	01204574 	movhi	r4,33045
8111e5d4:	21063b04 	addi	r4,r4,6380
8111e5d8:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e5dc:	0001883a 	nop
8111e5e0:	e037883a 	mov	sp,fp
8111e5e4:	dfc00117 	ldw	ra,4(sp)
8111e5e8:	df000017 	ldw	fp,0(sp)
8111e5ec:	dec00204 	addi	sp,sp,8
8111e5f0:	f800283a 	ret

8111e5f4 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
8111e5f4:	defffe04 	addi	sp,sp,-8
8111e5f8:	de00012e 	bgeu	sp,et,8111e600 <vFailCreateScheduleQueue+0xc>
8111e5fc:	003b68fa 	trap	3
8111e600:	dfc00115 	stw	ra,4(sp)
8111e604:	df000015 	stw	fp,0(sp)
8111e608:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e60c:	00a045f4 	movhi	r2,33047
8111e610:	10a25304 	addi	r2,r2,-30388
8111e614:	10800a8b 	ldhu	r2,42(r2)
8111e618:	10bfffcc 	andi	r2,r2,65535
8111e61c:	10800228 	cmpgeui	r2,r2,8
8111e620:	10000e1e 	bne	r2,zero,8111e65c <vFailCreateScheduleQueue+0x68>
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
8111e624:	d0a06217 	ldw	r2,-32376(gp)
8111e628:	100f883a 	mov	r7,r2
8111e62c:	01800844 	movi	r6,33
8111e630:	01400044 	movi	r5,1
8111e634:	01204574 	movhi	r4,33045
8111e638:	21065004 	addi	r4,r4,6464
8111e63c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
8111e640:	d0a06217 	ldw	r2,-32376(gp)
8111e644:	100f883a 	mov	r7,r2
8111e648:	01801204 	movi	r6,72
8111e64c:	01400044 	movi	r5,1
8111e650:	01204574 	movhi	r4,33045
8111e654:	21065904 	addi	r4,r4,6500
8111e658:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e65c:	0001883a 	nop
8111e660:	e037883a 	mov	sp,fp
8111e664:	dfc00117 	ldw	ra,4(sp)
8111e668:	df000017 	ldw	fp,0(sp)
8111e66c:	dec00204 	addi	sp,sp,8
8111e670:	f800283a 	ret

8111e674 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
8111e674:	defffd04 	addi	sp,sp,-12
8111e678:	de00012e 	bgeu	sp,et,8111e680 <vFailCreateNFEEQueue+0xc>
8111e67c:	003b68fa 	trap	3
8111e680:	dfc00215 	stw	ra,8(sp)
8111e684:	df000115 	stw	fp,4(sp)
8111e688:	df000104 	addi	fp,sp,4
8111e68c:	2005883a 	mov	r2,r4
8111e690:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e694:	00a045f4 	movhi	r2,33047
8111e698:	10a25304 	addi	r2,r2,-30388
8111e69c:	10800a8b 	ldhu	r2,42(r2)
8111e6a0:	10bfffcc 	andi	r2,r2,65535
8111e6a4:	10800228 	cmpgeui	r2,r2,8
8111e6a8:	10000e1e 	bne	r2,zero,8111e6e4 <vFailCreateNFEEQueue+0x70>
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
8111e6ac:	d0a06217 	ldw	r2,-32376(gp)
8111e6b0:	100f883a 	mov	r7,r2
8111e6b4:	01800744 	movi	r6,29
8111e6b8:	01400044 	movi	r5,1
8111e6bc:	01204574 	movhi	r4,33045
8111e6c0:	21066c04 	addi	r4,r4,6576
8111e6c4:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
8111e6c8:	d0a06217 	ldw	r2,-32376(gp)
8111e6cc:	e0ffff03 	ldbu	r3,-4(fp)
8111e6d0:	180d883a 	mov	r6,r3
8111e6d4:	01604574 	movhi	r5,33045
8111e6d8:	29467404 	addi	r5,r5,6608
8111e6dc:	1009883a 	mov	r4,r2
8111e6e0:	11232a00 	call	811232a0 <fprintf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e6e4:	0001883a 	nop
8111e6e8:	e037883a 	mov	sp,fp
8111e6ec:	dfc00117 	ldw	ra,4(sp)
8111e6f0:	df000017 	ldw	fp,0(sp)
8111e6f4:	dec00204 	addi	sp,sp,8
8111e6f8:	f800283a 	ret

8111e6fc <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
8111e6fc:	defffd04 	addi	sp,sp,-12
8111e700:	de00012e 	bgeu	sp,et,8111e708 <vFailCreateNFEESyncQueue+0xc>
8111e704:	003b68fa 	trap	3
8111e708:	dfc00215 	stw	ra,8(sp)
8111e70c:	df000115 	stw	fp,4(sp)
8111e710:	df000104 	addi	fp,sp,4
8111e714:	2005883a 	mov	r2,r4
8111e718:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e71c:	00a045f4 	movhi	r2,33047
8111e720:	10a25304 	addi	r2,r2,-30388
8111e724:	10800a8b 	ldhu	r2,42(r2)
8111e728:	10bfffcc 	andi	r2,r2,65535
8111e72c:	10800228 	cmpgeui	r2,r2,8
8111e730:	10000e1e 	bne	r2,zero,8111e76c <vFailCreateNFEESyncQueue+0x70>
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
8111e734:	d0a06217 	ldw	r2,-32376(gp)
8111e738:	100f883a 	mov	r7,r2
8111e73c:	01800844 	movi	r6,33
8111e740:	01400044 	movi	r5,1
8111e744:	01204574 	movhi	r4,33045
8111e748:	21068204 	addi	r4,r4,6664
8111e74c:	112393c0 	call	8112393c <fwrite>
		fprintf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
8111e750:	d0a06217 	ldw	r2,-32376(gp)
8111e754:	e0ffff03 	ldbu	r3,-4(fp)
8111e758:	180d883a 	mov	r6,r3
8111e75c:	01604574 	movhi	r5,33045
8111e760:	29468b04 	addi	r5,r5,6700
8111e764:	1009883a 	mov	r4,r2
8111e768:	11232a00 	call	811232a0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e76c:	0001883a 	nop
8111e770:	e037883a 	mov	sp,fp
8111e774:	dfc00117 	ldw	ra,4(sp)
8111e778:	df000017 	ldw	fp,0(sp)
8111e77c:	dec00204 	addi	sp,sp,8
8111e780:	f800283a 	ret

8111e784 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
8111e784:	defffe04 	addi	sp,sp,-8
8111e788:	de00012e 	bgeu	sp,et,8111e790 <vCoudlNotCreateNFee0Task+0xc>
8111e78c:	003b68fa 	trap	3
8111e790:	dfc00115 	stw	ra,4(sp)
8111e794:	df000015 	stw	fp,0(sp)
8111e798:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e79c:	00a045f4 	movhi	r2,33047
8111e7a0:	10a25304 	addi	r2,r2,-30388
8111e7a4:	10800a8b 	ldhu	r2,42(r2)
8111e7a8:	10bfffcc 	andi	r2,r2,65535
8111e7ac:	10800228 	cmpgeui	r2,r2,8
8111e7b0:	10000e1e 	bne	r2,zero,8111e7ec <vCoudlNotCreateNFee0Task+0x68>
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
8111e7b4:	d0a06217 	ldw	r2,-32376(gp)
8111e7b8:	100f883a 	mov	r7,r2
8111e7bc:	01800844 	movi	r6,33
8111e7c0:	01400044 	movi	r5,1
8111e7c4:	01204574 	movhi	r4,33045
8111e7c8:	21069904 	addi	r4,r4,6756
8111e7cc:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not create NFEE 0 Task.\n");
8111e7d0:	d0a06217 	ldw	r2,-32376(gp)
8111e7d4:	100f883a 	mov	r7,r2
8111e7d8:	01800784 	movi	r6,30
8111e7dc:	01400044 	movi	r5,1
8111e7e0:	01204574 	movhi	r4,33045
8111e7e4:	2106a204 	addi	r4,r4,6792
8111e7e8:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e7ec:	0001883a 	nop
8111e7f0:	e037883a 	mov	sp,fp
8111e7f4:	dfc00117 	ldw	ra,4(sp)
8111e7f8:	df000017 	ldw	fp,0(sp)
8111e7fc:	dec00204 	addi	sp,sp,8
8111e800:	f800283a 	ret

8111e804 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
8111e804:	defffe04 	addi	sp,sp,-8
8111e808:	de00012e 	bgeu	sp,et,8111e810 <vCoudlNotCreateNFee1Task+0xc>
8111e80c:	003b68fa 	trap	3
8111e810:	dfc00115 	stw	ra,4(sp)
8111e814:	df000015 	stw	fp,0(sp)
8111e818:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e81c:	00a045f4 	movhi	r2,33047
8111e820:	10a25304 	addi	r2,r2,-30388
8111e824:	10800a8b 	ldhu	r2,42(r2)
8111e828:	10bfffcc 	andi	r2,r2,65535
8111e82c:	10800228 	cmpgeui	r2,r2,8
8111e830:	10000e1e 	bne	r2,zero,8111e86c <vCoudlNotCreateNFee1Task+0x68>
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
8111e834:	d0a06217 	ldw	r2,-32376(gp)
8111e838:	100f883a 	mov	r7,r2
8111e83c:	01800844 	movi	r6,33
8111e840:	01400044 	movi	r5,1
8111e844:	01204574 	movhi	r4,33045
8111e848:	2106aa04 	addi	r4,r4,6824
8111e84c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not create NFEE 1 Task.\n");
8111e850:	d0a06217 	ldw	r2,-32376(gp)
8111e854:	100f883a 	mov	r7,r2
8111e858:	01800784 	movi	r6,30
8111e85c:	01400044 	movi	r5,1
8111e860:	01204574 	movhi	r4,33045
8111e864:	2106b304 	addi	r4,r4,6860
8111e868:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e86c:	0001883a 	nop
8111e870:	e037883a 	mov	sp,fp
8111e874:	dfc00117 	ldw	ra,4(sp)
8111e878:	df000017 	ldw	fp,0(sp)
8111e87c:	dec00204 	addi	sp,sp,8
8111e880:	f800283a 	ret

8111e884 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
8111e884:	defffe04 	addi	sp,sp,-8
8111e888:	de00012e 	bgeu	sp,et,8111e890 <vCoudlNotCreateNFee2Task+0xc>
8111e88c:	003b68fa 	trap	3
8111e890:	dfc00115 	stw	ra,4(sp)
8111e894:	df000015 	stw	fp,0(sp)
8111e898:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e89c:	00a045f4 	movhi	r2,33047
8111e8a0:	10a25304 	addi	r2,r2,-30388
8111e8a4:	10800a8b 	ldhu	r2,42(r2)
8111e8a8:	10bfffcc 	andi	r2,r2,65535
8111e8ac:	10800228 	cmpgeui	r2,r2,8
8111e8b0:	10000e1e 	bne	r2,zero,8111e8ec <vCoudlNotCreateNFee2Task+0x68>
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
8111e8b4:	d0a06217 	ldw	r2,-32376(gp)
8111e8b8:	100f883a 	mov	r7,r2
8111e8bc:	01800844 	movi	r6,33
8111e8c0:	01400044 	movi	r5,1
8111e8c4:	01204574 	movhi	r4,33045
8111e8c8:	2106bb04 	addi	r4,r4,6892
8111e8cc:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not create NFEE 2 Task.\n");
8111e8d0:	d0a06217 	ldw	r2,-32376(gp)
8111e8d4:	100f883a 	mov	r7,r2
8111e8d8:	01800784 	movi	r6,30
8111e8dc:	01400044 	movi	r5,1
8111e8e0:	01204574 	movhi	r4,33045
8111e8e4:	2106c404 	addi	r4,r4,6928
8111e8e8:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e8ec:	0001883a 	nop
8111e8f0:	e037883a 	mov	sp,fp
8111e8f4:	dfc00117 	ldw	ra,4(sp)
8111e8f8:	df000017 	ldw	fp,0(sp)
8111e8fc:	dec00204 	addi	sp,sp,8
8111e900:	f800283a 	ret

8111e904 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
8111e904:	defffe04 	addi	sp,sp,-8
8111e908:	de00012e 	bgeu	sp,et,8111e910 <vCoudlNotCreateNFee3Task+0xc>
8111e90c:	003b68fa 	trap	3
8111e910:	dfc00115 	stw	ra,4(sp)
8111e914:	df000015 	stw	fp,0(sp)
8111e918:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e91c:	00a045f4 	movhi	r2,33047
8111e920:	10a25304 	addi	r2,r2,-30388
8111e924:	10800a8b 	ldhu	r2,42(r2)
8111e928:	10bfffcc 	andi	r2,r2,65535
8111e92c:	10800228 	cmpgeui	r2,r2,8
8111e930:	10000e1e 	bne	r2,zero,8111e96c <vCoudlNotCreateNFee3Task+0x68>
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
8111e934:	d0a06217 	ldw	r2,-32376(gp)
8111e938:	100f883a 	mov	r7,r2
8111e93c:	01800844 	movi	r6,33
8111e940:	01400044 	movi	r5,1
8111e944:	01204574 	movhi	r4,33045
8111e948:	2106cc04 	addi	r4,r4,6960
8111e94c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not create NFEE 3 Task.\n");
8111e950:	d0a06217 	ldw	r2,-32376(gp)
8111e954:	100f883a 	mov	r7,r2
8111e958:	01800784 	movi	r6,30
8111e95c:	01400044 	movi	r5,1
8111e960:	01204574 	movhi	r4,33045
8111e964:	2106d504 	addi	r4,r4,6996
8111e968:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e96c:	0001883a 	nop
8111e970:	e037883a 	mov	sp,fp
8111e974:	dfc00117 	ldw	ra,4(sp)
8111e978:	df000017 	ldw	fp,0(sp)
8111e97c:	dec00204 	addi	sp,sp,8
8111e980:	f800283a 	ret

8111e984 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
8111e984:	defffe04 	addi	sp,sp,-8
8111e988:	de00012e 	bgeu	sp,et,8111e990 <vCoudlNotCreateNFee4Task+0xc>
8111e98c:	003b68fa 	trap	3
8111e990:	dfc00115 	stw	ra,4(sp)
8111e994:	df000015 	stw	fp,0(sp)
8111e998:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e99c:	00a045f4 	movhi	r2,33047
8111e9a0:	10a25304 	addi	r2,r2,-30388
8111e9a4:	10800a8b 	ldhu	r2,42(r2)
8111e9a8:	10bfffcc 	andi	r2,r2,65535
8111e9ac:	10800228 	cmpgeui	r2,r2,8
8111e9b0:	10000e1e 	bne	r2,zero,8111e9ec <vCoudlNotCreateNFee4Task+0x68>
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
8111e9b4:	d0a06217 	ldw	r2,-32376(gp)
8111e9b8:	100f883a 	mov	r7,r2
8111e9bc:	01800844 	movi	r6,33
8111e9c0:	01400044 	movi	r5,1
8111e9c4:	01204574 	movhi	r4,33045
8111e9c8:	2106dd04 	addi	r4,r4,7028
8111e9cc:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not create NFEE 4 Task.\n");
8111e9d0:	d0a06217 	ldw	r2,-32376(gp)
8111e9d4:	100f883a 	mov	r7,r2
8111e9d8:	01800784 	movi	r6,30
8111e9dc:	01400044 	movi	r5,1
8111e9e0:	01204574 	movhi	r4,33045
8111e9e4:	2106e604 	addi	r4,r4,7064
8111e9e8:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e9ec:	0001883a 	nop
8111e9f0:	e037883a 	mov	sp,fp
8111e9f4:	dfc00117 	ldw	ra,4(sp)
8111e9f8:	df000017 	ldw	fp,0(sp)
8111e9fc:	dec00204 	addi	sp,sp,8
8111ea00:	f800283a 	ret

8111ea04 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
8111ea04:	defffe04 	addi	sp,sp,-8
8111ea08:	de00012e 	bgeu	sp,et,8111ea10 <vCoudlNotCreateNFee5Task+0xc>
8111ea0c:	003b68fa 	trap	3
8111ea10:	dfc00115 	stw	ra,4(sp)
8111ea14:	df000015 	stw	fp,0(sp)
8111ea18:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ea1c:	00a045f4 	movhi	r2,33047
8111ea20:	10a25304 	addi	r2,r2,-30388
8111ea24:	10800a8b 	ldhu	r2,42(r2)
8111ea28:	10bfffcc 	andi	r2,r2,65535
8111ea2c:	10800228 	cmpgeui	r2,r2,8
8111ea30:	10000e1e 	bne	r2,zero,8111ea6c <vCoudlNotCreateNFee5Task+0x68>
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
8111ea34:	d0a06217 	ldw	r2,-32376(gp)
8111ea38:	100f883a 	mov	r7,r2
8111ea3c:	01800844 	movi	r6,33
8111ea40:	01400044 	movi	r5,1
8111ea44:	01204574 	movhi	r4,33045
8111ea48:	2106ee04 	addi	r4,r4,7096
8111ea4c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not create NFEE 5 Task.\n");
8111ea50:	d0a06217 	ldw	r2,-32376(gp)
8111ea54:	100f883a 	mov	r7,r2
8111ea58:	01800784 	movi	r6,30
8111ea5c:	01400044 	movi	r5,1
8111ea60:	01204574 	movhi	r4,33045
8111ea64:	2106f704 	addi	r4,r4,7132
8111ea68:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ea6c:	0001883a 	nop
8111ea70:	e037883a 	mov	sp,fp
8111ea74:	dfc00117 	ldw	ra,4(sp)
8111ea78:	df000017 	ldw	fp,0(sp)
8111ea7c:	dec00204 	addi	sp,sp,8
8111ea80:	f800283a 	ret

8111ea84 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
8111ea84:	defffe04 	addi	sp,sp,-8
8111ea88:	de00012e 	bgeu	sp,et,8111ea90 <vCoudlNotCreateNFeeControllerTask+0xc>
8111ea8c:	003b68fa 	trap	3
8111ea90:	dfc00115 	stw	ra,4(sp)
8111ea94:	df000015 	stw	fp,0(sp)
8111ea98:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ea9c:	00a045f4 	movhi	r2,33047
8111eaa0:	10a25304 	addi	r2,r2,-30388
8111eaa4:	10800a8b 	ldhu	r2,42(r2)
8111eaa8:	10bfffcc 	andi	r2,r2,65535
8111eaac:	10800228 	cmpgeui	r2,r2,8
8111eab0:	10000e1e 	bne	r2,zero,8111eaec <vCoudlNotCreateNFeeControllerTask+0x68>
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
8111eab4:	d0a06217 	ldw	r2,-32376(gp)
8111eab8:	100f883a 	mov	r7,r2
8111eabc:	01800a84 	movi	r6,42
8111eac0:	01400044 	movi	r5,1
8111eac4:	01204574 	movhi	r4,33045
8111eac8:	2106ff04 	addi	r4,r4,7164
8111eacc:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not create NFEE Controller Task.\n");
8111ead0:	d0a06217 	ldw	r2,-32376(gp)
8111ead4:	100f883a 	mov	r7,r2
8111ead8:	018009c4 	movi	r6,39
8111eadc:	01400044 	movi	r5,1
8111eae0:	01204574 	movhi	r4,33045
8111eae4:	21070a04 	addi	r4,r4,7208
8111eae8:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111eaec:	0001883a 	nop
8111eaf0:	e037883a 	mov	sp,fp
8111eaf4:	dfc00117 	ldw	ra,4(sp)
8111eaf8:	df000017 	ldw	fp,0(sp)
8111eafc:	dec00204 	addi	sp,sp,8
8111eb00:	f800283a 	ret

8111eb04 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8111eb04:	defffe04 	addi	sp,sp,-8
8111eb08:	de00012e 	bgeu	sp,et,8111eb10 <vCoudlNotCreateDataControllerTask+0xc>
8111eb0c:	003b68fa 	trap	3
8111eb10:	dfc00115 	stw	ra,4(sp)
8111eb14:	df000015 	stw	fp,0(sp)
8111eb18:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111eb1c:	00a045f4 	movhi	r2,33047
8111eb20:	10a25304 	addi	r2,r2,-30388
8111eb24:	10800a8b 	ldhu	r2,42(r2)
8111eb28:	10bfffcc 	andi	r2,r2,65535
8111eb2c:	10800228 	cmpgeui	r2,r2,8
8111eb30:	10000e1e 	bne	r2,zero,8111eb6c <vCoudlNotCreateDataControllerTask+0x68>
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
8111eb34:	d0a06217 	ldw	r2,-32376(gp)
8111eb38:	100f883a 	mov	r7,r2
8111eb3c:	01800a84 	movi	r6,42
8111eb40:	01400044 	movi	r5,1
8111eb44:	01204574 	movhi	r4,33045
8111eb48:	21071404 	addi	r4,r4,7248
8111eb4c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not create Data Controller Task.\n");
8111eb50:	d0a06217 	ldw	r2,-32376(gp)
8111eb54:	100f883a 	mov	r7,r2
8111eb58:	018009c4 	movi	r6,39
8111eb5c:	01400044 	movi	r5,1
8111eb60:	01204574 	movhi	r4,33045
8111eb64:	21071f04 	addi	r4,r4,7292
8111eb68:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111eb6c:	0001883a 	nop
8111eb70:	e037883a 	mov	sp,fp
8111eb74:	dfc00117 	ldw	ra,4(sp)
8111eb78:	df000017 	ldw	fp,0(sp)
8111eb7c:	dec00204 	addi	sp,sp,8
8111eb80:	f800283a 	ret

8111eb84 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
8111eb84:	defffe04 	addi	sp,sp,-8
8111eb88:	de00012e 	bgeu	sp,et,8111eb90 <vCoudlNotCreateMebTask+0xc>
8111eb8c:	003b68fa 	trap	3
8111eb90:	dfc00115 	stw	ra,4(sp)
8111eb94:	df000015 	stw	fp,0(sp)
8111eb98:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111eb9c:	00a045f4 	movhi	r2,33047
8111eba0:	10a25304 	addi	r2,r2,-30388
8111eba4:	10800a8b 	ldhu	r2,42(r2)
8111eba8:	10bfffcc 	andi	r2,r2,65535
8111ebac:	10800228 	cmpgeui	r2,r2,8
8111ebb0:	10000e1e 	bne	r2,zero,8111ebec <vCoudlNotCreateMebTask+0x68>
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
8111ebb4:	d0a06217 	ldw	r2,-32376(gp)
8111ebb8:	100f883a 	mov	r7,r2
8111ebbc:	018007c4 	movi	r6,31
8111ebc0:	01400044 	movi	r5,1
8111ebc4:	01204574 	movhi	r4,33045
8111ebc8:	21072904 	addi	r4,r4,7332
8111ebcc:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not create Meb Task.\n");
8111ebd0:	d0a06217 	ldw	r2,-32376(gp)
8111ebd4:	100f883a 	mov	r7,r2
8111ebd8:	018006c4 	movi	r6,27
8111ebdc:	01400044 	movi	r5,1
8111ebe0:	01204574 	movhi	r4,33045
8111ebe4:	21073104 	addi	r4,r4,7364
8111ebe8:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ebec:	0001883a 	nop
8111ebf0:	e037883a 	mov	sp,fp
8111ebf4:	dfc00117 	ldw	ra,4(sp)
8111ebf8:	df000017 	ldw	fp,0(sp)
8111ebfc:	dec00204 	addi	sp,sp,8
8111ec00:	f800283a 	ret

8111ec04 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
8111ec04:	defffd04 	addi	sp,sp,-12
8111ec08:	de00012e 	bgeu	sp,et,8111ec10 <vFailCreateMutexSPUSQueueMeb+0xc>
8111ec0c:	003b68fa 	trap	3
8111ec10:	dfc00215 	stw	ra,8(sp)
8111ec14:	df000115 	stw	fp,4(sp)
8111ec18:	df000104 	addi	fp,sp,4
8111ec1c:	2005883a 	mov	r2,r4
8111ec20:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ec24:	00a045f4 	movhi	r2,33047
8111ec28:	10a25304 	addi	r2,r2,-30388
8111ec2c:	10800a8b 	ldhu	r2,42(r2)
8111ec30:	10bfffcc 	andi	r2,r2,65535
8111ec34:	10800228 	cmpgeui	r2,r2,8
8111ec38:	10000a1e 	bne	r2,zero,8111ec64 <vFailCreateMutexSPUSQueueMeb+0x60>
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
8111ec3c:	d0a06217 	ldw	r2,-32376(gp)
8111ec40:	100f883a 	mov	r7,r2
8111ec44:	01800944 	movi	r6,37
8111ec48:	01400044 	movi	r5,1
8111ec4c:	01204574 	movhi	r4,33045
8111ec50:	21073804 	addi	r4,r4,7392
8111ec54:	112393c0 	call	8112393c <fwrite>
		printErrorTask(error_code);
8111ec58:	e0bfff03 	ldbu	r2,-4(fp)
8111ec5c:	1009883a 	mov	r4,r2
8111ec60:	111cdc80 	call	8111cdc8 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ec64:	0001883a 	nop
8111ec68:	e037883a 	mov	sp,fp
8111ec6c:	dfc00117 	ldw	ra,4(sp)
8111ec70:	df000017 	ldw	fp,0(sp)
8111ec74:	dec00204 	addi	sp,sp,8
8111ec78:	f800283a 	ret

8111ec7c <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
8111ec7c:	defffe04 	addi	sp,sp,-8
8111ec80:	de00012e 	bgeu	sp,et,8111ec88 <vFailSendPUStoMebTask+0xc>
8111ec84:	003b68fa 	trap	3
8111ec88:	dfc00115 	stw	ra,4(sp)
8111ec8c:	df000015 	stw	fp,0(sp)
8111ec90:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ec94:	00a045f4 	movhi	r2,33047
8111ec98:	10a25304 	addi	r2,r2,-30388
8111ec9c:	10800a8b 	ldhu	r2,42(r2)
8111eca0:	10bfffcc 	andi	r2,r2,65535
8111eca4:	10800228 	cmpgeui	r2,r2,8
8111eca8:	1000071e 	bne	r2,zero,8111ecc8 <vFailSendPUStoMebTask+0x4c>
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
8111ecac:	d0a06217 	ldw	r2,-32376(gp)
8111ecb0:	100f883a 	mov	r7,r2
8111ecb4:	01800784 	movi	r6,30
8111ecb8:	01400044 	movi	r5,1
8111ecbc:	01204574 	movhi	r4,33045
8111ecc0:	21074204 	addi	r4,r4,7432
8111ecc4:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ecc8:	0001883a 	nop
8111eccc:	e037883a 	mov	sp,fp
8111ecd0:	dfc00117 	ldw	ra,4(sp)
8111ecd4:	df000017 	ldw	fp,0(sp)
8111ecd8:	dec00204 	addi	sp,sp,8
8111ecdc:	f800283a 	ret

8111ece0 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
8111ece0:	defffe04 	addi	sp,sp,-8
8111ece4:	de00012e 	bgeu	sp,et,8111ecec <vCouldNotGetCmdQueueMeb+0xc>
8111ece8:	003b68fa 	trap	3
8111ecec:	dfc00115 	stw	ra,4(sp)
8111ecf0:	df000015 	stw	fp,0(sp)
8111ecf4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ecf8:	00a045f4 	movhi	r2,33047
8111ecfc:	10a25304 	addi	r2,r2,-30388
8111ed00:	10800a8b 	ldhu	r2,42(r2)
8111ed04:	10bfffcc 	andi	r2,r2,65535
8111ed08:	10800228 	cmpgeui	r2,r2,8
8111ed0c:	10000e1e 	bne	r2,zero,8111ed48 <vCouldNotGetCmdQueueMeb+0x68>
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
8111ed10:	d0a06217 	ldw	r2,-32376(gp)
8111ed14:	100f883a 	mov	r7,r2
8111ed18:	01800a84 	movi	r6,42
8111ed1c:	01400044 	movi	r5,1
8111ed20:	01204574 	movhi	r4,33045
8111ed24:	21074a04 	addi	r4,r4,7464
8111ed28:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
8111ed2c:	d0a06217 	ldw	r2,-32376(gp)
8111ed30:	100f883a 	mov	r7,r2
8111ed34:	01800cc4 	movi	r6,51
8111ed38:	01400044 	movi	r5,1
8111ed3c:	01204574 	movhi	r4,33045
8111ed40:	21075504 	addi	r4,r4,7508
8111ed44:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ed48:	0001883a 	nop
8111ed4c:	e037883a 	mov	sp,fp
8111ed50:	dfc00117 	ldw	ra,4(sp)
8111ed54:	df000017 	ldw	fp,0(sp)
8111ed58:	dec00204 	addi	sp,sp,8
8111ed5c:	f800283a 	ret

8111ed60 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
8111ed60:	defffe04 	addi	sp,sp,-8
8111ed64:	de00012e 	bgeu	sp,et,8111ed6c <vCouldNotGetMutexMebPus+0xc>
8111ed68:	003b68fa 	trap	3
8111ed6c:	dfc00115 	stw	ra,4(sp)
8111ed70:	df000015 	stw	fp,0(sp)
8111ed74:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ed78:	00a045f4 	movhi	r2,33047
8111ed7c:	10a25304 	addi	r2,r2,-30388
8111ed80:	10800a8b 	ldhu	r2,42(r2)
8111ed84:	10bfffcc 	andi	r2,r2,65535
8111ed88:	10800228 	cmpgeui	r2,r2,8
8111ed8c:	1000071e 	bne	r2,zero,8111edac <vCouldNotGetMutexMebPus+0x4c>
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
8111ed90:	d0a06217 	ldw	r2,-32376(gp)
8111ed94:	100f883a 	mov	r7,r2
8111ed98:	01800804 	movi	r6,32
8111ed9c:	01400044 	movi	r5,1
8111eda0:	01204574 	movhi	r4,33045
8111eda4:	21076204 	addi	r4,r4,7560
8111eda8:	112393c0 	call	8112393c <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111edac:	0001883a 	nop
8111edb0:	e037883a 	mov	sp,fp
8111edb4:	dfc00117 	ldw	ra,4(sp)
8111edb8:	df000017 	ldw	fp,0(sp)
8111edbc:	dec00204 	addi	sp,sp,8
8111edc0:	f800283a 	ret

8111edc4 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
8111edc4:	defffe04 	addi	sp,sp,-8
8111edc8:	de00012e 	bgeu	sp,et,8111edd0 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
8111edcc:	003b68fa 	trap	3
8111edd0:	dfc00115 	stw	ra,4(sp)
8111edd4:	df000015 	stw	fp,0(sp)
8111edd8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111eddc:	00a045f4 	movhi	r2,33047
8111ede0:	10a25304 	addi	r2,r2,-30388
8111ede4:	10800a8b 	ldhu	r2,42(r2)
8111ede8:	10bfffcc 	andi	r2,r2,65535
8111edec:	10800228 	cmpgeui	r2,r2,8
8111edf0:	10000e1e 	bne	r2,zero,8111ee2c <vCouldNotCreateQueueMaskNfeeCtrl+0x68>
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
8111edf4:	d0a06217 	ldw	r2,-32376(gp)
8111edf8:	100f883a 	mov	r7,r2
8111edfc:	01800a44 	movi	r6,41
8111ee00:	01400044 	movi	r5,1
8111ee04:	01204574 	movhi	r4,33045
8111ee08:	21076b04 	addi	r4,r4,7596
8111ee0c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
8111ee10:	d0a06217 	ldw	r2,-32376(gp)
8111ee14:	100f883a 	mov	r7,r2
8111ee18:	01800c84 	movi	r6,50
8111ee1c:	01400044 	movi	r5,1
8111ee20:	01204574 	movhi	r4,33045
8111ee24:	21077604 	addi	r4,r4,7640
8111ee28:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ee2c:	0001883a 	nop
8111ee30:	e037883a 	mov	sp,fp
8111ee34:	dfc00117 	ldw	ra,4(sp)
8111ee38:	df000017 	ldw	fp,0(sp)
8111ee3c:	dec00204 	addi	sp,sp,8
8111ee40:	f800283a 	ret

8111ee44 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
8111ee44:	defffe04 	addi	sp,sp,-8
8111ee48:	de00012e 	bgeu	sp,et,8111ee50 <vCouldNotCreateQueueMaskDataCtrl+0xc>
8111ee4c:	003b68fa 	trap	3
8111ee50:	dfc00115 	stw	ra,4(sp)
8111ee54:	df000015 	stw	fp,0(sp)
8111ee58:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ee5c:	00a045f4 	movhi	r2,33047
8111ee60:	10a25304 	addi	r2,r2,-30388
8111ee64:	10800a8b 	ldhu	r2,42(r2)
8111ee68:	10bfffcc 	andi	r2,r2,65535
8111ee6c:	10800228 	cmpgeui	r2,r2,8
8111ee70:	10000e1e 	bne	r2,zero,8111eeac <vCouldNotCreateQueueMaskDataCtrl+0x68>
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
8111ee74:	d0a06217 	ldw	r2,-32376(gp)
8111ee78:	100f883a 	mov	r7,r2
8111ee7c:	01800a44 	movi	r6,41
8111ee80:	01400044 	movi	r5,1
8111ee84:	01204574 	movhi	r4,33045
8111ee88:	21078304 	addi	r4,r4,7692
8111ee8c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
8111ee90:	d0a06217 	ldw	r2,-32376(gp)
8111ee94:	100f883a 	mov	r7,r2
8111ee98:	01800c84 	movi	r6,50
8111ee9c:	01400044 	movi	r5,1
8111eea0:	01204574 	movhi	r4,33045
8111eea4:	21078e04 	addi	r4,r4,7736
8111eea8:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111eeac:	0001883a 	nop
8111eeb0:	e037883a 	mov	sp,fp
8111eeb4:	dfc00117 	ldw	ra,4(sp)
8111eeb8:	df000017 	ldw	fp,0(sp)
8111eebc:	dec00204 	addi	sp,sp,8
8111eec0:	f800283a 	ret

8111eec4 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
8111eec4:	defffe04 	addi	sp,sp,-8
8111eec8:	de00012e 	bgeu	sp,et,8111eed0 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
8111eecc:	003b68fa 	trap	3
8111eed0:	dfc00115 	stw	ra,4(sp)
8111eed4:	df000015 	stw	fp,0(sp)
8111eed8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111eedc:	00a045f4 	movhi	r2,33047
8111eee0:	10a25304 	addi	r2,r2,-30388
8111eee4:	10800a8b 	ldhu	r2,42(r2)
8111eee8:	10bfffcc 	andi	r2,r2,65535
8111eeec:	10800228 	cmpgeui	r2,r2,8
8111eef0:	10000e1e 	bne	r2,zero,8111ef2c <vCouldNotGetQueueMaskNfeeCtrl+0x68>
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
8111eef4:	d0a06217 	ldw	r2,-32376(gp)
8111eef8:	100f883a 	mov	r7,r2
8111eefc:	01800984 	movi	r6,38
8111ef00:	01400044 	movi	r5,1
8111ef04:	01204574 	movhi	r4,33045
8111ef08:	21079b04 	addi	r4,r4,7788
8111ef0c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
8111ef10:	d0a06217 	ldw	r2,-32376(gp)
8111ef14:	100f883a 	mov	r7,r2
8111ef18:	01800bc4 	movi	r6,47
8111ef1c:	01400044 	movi	r5,1
8111ef20:	01204574 	movhi	r4,33045
8111ef24:	2107a504 	addi	r4,r4,7828
8111ef28:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ef2c:	0001883a 	nop
8111ef30:	e037883a 	mov	sp,fp
8111ef34:	dfc00117 	ldw	ra,4(sp)
8111ef38:	df000017 	ldw	fp,0(sp)
8111ef3c:	dec00204 	addi	sp,sp,8
8111ef40:	f800283a 	ret

8111ef44 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8111ef44:	defffe04 	addi	sp,sp,-8
8111ef48:	de00012e 	bgeu	sp,et,8111ef50 <vCouldNotGetQueueMaskDataCtrl+0xc>
8111ef4c:	003b68fa 	trap	3
8111ef50:	dfc00115 	stw	ra,4(sp)
8111ef54:	df000015 	stw	fp,0(sp)
8111ef58:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ef5c:	00a045f4 	movhi	r2,33047
8111ef60:	10a25304 	addi	r2,r2,-30388
8111ef64:	10800a8b 	ldhu	r2,42(r2)
8111ef68:	10bfffcc 	andi	r2,r2,65535
8111ef6c:	10800228 	cmpgeui	r2,r2,8
8111ef70:	10000e1e 	bne	r2,zero,8111efac <vCouldNotGetQueueMaskDataCtrl+0x68>
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
8111ef74:	d0a06217 	ldw	r2,-32376(gp)
8111ef78:	100f883a 	mov	r7,r2
8111ef7c:	01800984 	movi	r6,38
8111ef80:	01400044 	movi	r5,1
8111ef84:	01204574 	movhi	r4,33045
8111ef88:	2107b104 	addi	r4,r4,7876
8111ef8c:	112393c0 	call	8112393c <fwrite>
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
8111ef90:	d0a06217 	ldw	r2,-32376(gp)
8111ef94:	100f883a 	mov	r7,r2
8111ef98:	01800bc4 	movi	r6,47
8111ef9c:	01400044 	movi	r5,1
8111efa0:	01204574 	movhi	r4,33045
8111efa4:	2107bb04 	addi	r4,r4,7916
8111efa8:	112393c0 	call	8112393c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111efac:	0001883a 	nop
8111efb0:	e037883a 	mov	sp,fp
8111efb4:	dfc00117 	ldw	ra,4(sp)
8111efb8:	df000017 	ldw	fp,0(sp)
8111efbc:	dec00204 	addi	sp,sp,8
8111efc0:	f800283a 	ret

8111efc4 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
8111efc4:	defffd04 	addi	sp,sp,-12
8111efc8:	de00012e 	bgeu	sp,et,8111efd0 <vFailSendMsgAccessDMA+0xc>
8111efcc:	003b68fa 	trap	3
8111efd0:	dfc00215 	stw	ra,8(sp)
8111efd4:	df000115 	stw	fp,4(sp)
8111efd8:	df000104 	addi	fp,sp,4
8111efdc:	2005883a 	mov	r2,r4
8111efe0:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111efe4:	00a045f4 	movhi	r2,33047
8111efe8:	10a25304 	addi	r2,r2,-30388
8111efec:	10800a8b 	ldhu	r2,42(r2)
8111eff0:	10bfffcc 	andi	r2,r2,65535
8111eff4:	10800228 	cmpgeui	r2,r2,8
8111eff8:	1000071e 	bne	r2,zero,8111f018 <vFailSendMsgAccessDMA+0x54>
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n:%hhu \n", ucTemp);
8111effc:	d0a06217 	ldw	r2,-32376(gp)
8111f000:	e0ffff03 	ldbu	r3,-4(fp)
8111f004:	180d883a 	mov	r6,r3
8111f008:	01604574 	movhi	r5,33045
8111f00c:	2947c704 	addi	r5,r5,7964
8111f010:	1009883a 	mov	r4,r2
8111f014:	11232a00 	call	811232a0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f018:	0001883a 	nop
8111f01c:	e037883a 	mov	sp,fp
8111f020:	dfc00117 	ldw	ra,4(sp)
8111f024:	df000017 	ldw	fp,0(sp)
8111f028:	dec00204 	addi	sp,sp,8
8111f02c:	f800283a 	ret

8111f030 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
8111f030:	defffd04 	addi	sp,sp,-12
8111f034:	de00012e 	bgeu	sp,et,8111f03c <vFailRequestDMA+0xc>
8111f038:	003b68fa 	trap	3
8111f03c:	dfc00215 	stw	ra,8(sp)
8111f040:	df000115 	stw	fp,4(sp)
8111f044:	df000104 	addi	fp,sp,4
8111f048:	2005883a 	mov	r2,r4
8111f04c:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f050:	00a045f4 	movhi	r2,33047
8111f054:	10a25304 	addi	r2,r2,-30388
8111f058:	10800a8b 	ldhu	r2,42(r2)
8111f05c:	10bfffcc 	andi	r2,r2,65535
8111f060:	10800228 	cmpgeui	r2,r2,8
8111f064:	1000071e 	bne	r2,zero,8111f084 <vFailRequestDMA+0x54>
		fprintf(fp,"vFailRequestDMA. FEE n:%hhu \n", ucTemp);
8111f068:	d0a06217 	ldw	r2,-32376(gp)
8111f06c:	e0ffff03 	ldbu	r3,-4(fp)
8111f070:	180d883a 	mov	r6,r3
8111f074:	01604574 	movhi	r5,33045
8111f078:	2947d004 	addi	r5,r5,8000
8111f07c:	1009883a 	mov	r4,r2
8111f080:	11232a00 	call	811232a0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f084:	0001883a 	nop
8111f088:	e037883a 	mov	sp,fp
8111f08c:	dfc00117 	ldw	ra,4(sp)
8111f090:	df000017 	ldw	fp,0(sp)
8111f094:	dec00204 	addi	sp,sp,8
8111f098:	f800283a 	ret

8111f09c <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
8111f09c:	defffd04 	addi	sp,sp,-12
8111f0a0:	de00012e 	bgeu	sp,et,8111f0a8 <vFailRequestDMAFromIRQ+0xc>
8111f0a4:	003b68fa 	trap	3
8111f0a8:	dfc00215 	stw	ra,8(sp)
8111f0ac:	df000115 	stw	fp,4(sp)
8111f0b0:	df000104 	addi	fp,sp,4
8111f0b4:	2005883a 	mov	r2,r4
8111f0b8:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f0bc:	00a045f4 	movhi	r2,33047
8111f0c0:	10a25304 	addi	r2,r2,-30388
8111f0c4:	10800a8b 	ldhu	r2,42(r2)
8111f0c8:	10bfffcc 	andi	r2,r2,65535
8111f0cc:	10800228 	cmpgeui	r2,r2,8
8111f0d0:	1000071e 	bne	r2,zero,8111f0f0 <vFailRequestDMAFromIRQ+0x54>
		fprintf(fp,"vFailRequestDMA. FEE n:%hhu \n", ucTemp);
8111f0d4:	d0a06217 	ldw	r2,-32376(gp)
8111f0d8:	e0ffff03 	ldbu	r3,-4(fp)
8111f0dc:	180d883a 	mov	r6,r3
8111f0e0:	01604574 	movhi	r5,33045
8111f0e4:	2947d004 	addi	r5,r5,8000
8111f0e8:	1009883a 	mov	r4,r2
8111f0ec:	11232a00 	call	811232a0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f0f0:	0001883a 	nop
8111f0f4:	e037883a 	mov	sp,fp
8111f0f8:	dfc00117 	ldw	ra,4(sp)
8111f0fc:	df000017 	ldw	fp,0(sp)
8111f100:	dec00204 	addi	sp,sp,8
8111f104:	f800283a 	ret

8111f108 <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
8111f108:	defffd04 	addi	sp,sp,-12
8111f10c:	de00012e 	bgeu	sp,et,8111f114 <vFailSendRMAPFromIRQ+0xc>
8111f110:	003b68fa 	trap	3
8111f114:	dfc00215 	stw	ra,8(sp)
8111f118:	df000115 	stw	fp,4(sp)
8111f11c:	df000104 	addi	fp,sp,4
8111f120:	2005883a 	mov	r2,r4
8111f124:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f128:	00a045f4 	movhi	r2,33047
8111f12c:	10a25304 	addi	r2,r2,-30388
8111f130:	10800a8b 	ldhu	r2,42(r2)
8111f134:	10bfffcc 	andi	r2,r2,65535
8111f138:	10800228 	cmpgeui	r2,r2,8
8111f13c:	1000071e 	bne	r2,zero,8111f15c <vFailSendRMAPFromIRQ+0x54>
		fprintf(fp,"vFailSendRMAPFromIRQ. FEE n:%hhu \n", ucTemp);
8111f140:	d0a06217 	ldw	r2,-32376(gp)
8111f144:	e0ffff03 	ldbu	r3,-4(fp)
8111f148:	180d883a 	mov	r6,r3
8111f14c:	01604574 	movhi	r5,33045
8111f150:	2947d804 	addi	r5,r5,8032
8111f154:	1009883a 	mov	r4,r2
8111f158:	11232a00 	call	811232a0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f15c:	0001883a 	nop
8111f160:	e037883a 	mov	sp,fp
8111f164:	dfc00117 	ldw	ra,4(sp)
8111f168:	df000017 	ldw	fp,0(sp)
8111f16c:	dec00204 	addi	sp,sp,8
8111f170:	f800283a 	ret

8111f174 <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
8111f174:	defffd04 	addi	sp,sp,-12
8111f178:	de00012e 	bgeu	sp,et,8111f180 <vFailSendMsgSync+0xc>
8111f17c:	003b68fa 	trap	3
8111f180:	dfc00215 	stw	ra,8(sp)
8111f184:	df000115 	stw	fp,4(sp)
8111f188:	df000104 	addi	fp,sp,4
8111f18c:	2005883a 	mov	r2,r4
8111f190:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f194:	00a045f4 	movhi	r2,33047
8111f198:	10a25304 	addi	r2,r2,-30388
8111f19c:	10800a8b 	ldhu	r2,42(r2)
8111f1a0:	10bfffcc 	andi	r2,r2,65535
8111f1a4:	10800228 	cmpgeui	r2,r2,8
8111f1a8:	1000071e 	bne	r2,zero,8111f1c8 <vFailSendMsgSync+0x54>
		fprintf(fp,"vFailSendMsgSync. FEE n:%hhu \n", ucTemp);
8111f1ac:	d0a06217 	ldw	r2,-32376(gp)
8111f1b0:	e0ffff03 	ldbu	r3,-4(fp)
8111f1b4:	180d883a 	mov	r6,r3
8111f1b8:	01604574 	movhi	r5,33045
8111f1bc:	2947e104 	addi	r5,r5,8068
8111f1c0:	1009883a 	mov	r4,r2
8111f1c4:	11232a00 	call	811232a0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f1c8:	0001883a 	nop
8111f1cc:	e037883a 	mov	sp,fp
8111f1d0:	dfc00117 	ldw	ra,4(sp)
8111f1d4:	df000017 	ldw	fp,0(sp)
8111f1d8:	dec00204 	addi	sp,sp,8
8111f1dc:	f800283a 	ret

8111f1e0 <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
8111f1e0:	defffd04 	addi	sp,sp,-12
8111f1e4:	de00012e 	bgeu	sp,et,8111f1ec <vFailSendMsgSyncRMAPTRIGGER+0xc>
8111f1e8:	003b68fa 	trap	3
8111f1ec:	dfc00215 	stw	ra,8(sp)
8111f1f0:	df000115 	stw	fp,4(sp)
8111f1f4:	df000104 	addi	fp,sp,4
8111f1f8:	2005883a 	mov	r2,r4
8111f1fc:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f200:	00a045f4 	movhi	r2,33047
8111f204:	10a25304 	addi	r2,r2,-30388
8111f208:	10800a8b 	ldhu	r2,42(r2)
8111f20c:	10bfffcc 	andi	r2,r2,65535
8111f210:	10800228 	cmpgeui	r2,r2,8
8111f214:	1000071e 	bne	r2,zero,8111f234 <vFailSendMsgSyncRMAPTRIGGER+0x54>
		fprintf(fp,"vFailSendMsgSyncRMAPTRIGGER (FORCED MODE). FEE n:%hhu \n", ucTemp);
8111f218:	d0a06217 	ldw	r2,-32376(gp)
8111f21c:	e0ffff03 	ldbu	r3,-4(fp)
8111f220:	180d883a 	mov	r6,r3
8111f224:	01604574 	movhi	r5,33045
8111f228:	2947e904 	addi	r5,r5,8100
8111f22c:	1009883a 	mov	r4,r2
8111f230:	11232a00 	call	811232a0 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f234:	0001883a 	nop
8111f238:	e037883a 	mov	sp,fp
8111f23c:	dfc00117 	ldw	ra,4(sp)
8111f240:	df000017 	ldw	fp,0(sp)
8111f244:	dec00204 	addi	sp,sp,8
8111f248:	f800283a 	ret

8111f24c <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
8111f24c:	defffe04 	addi	sp,sp,-8
8111f250:	de00012e 	bgeu	sp,et,8111f258 <vFailSendMsgMasterSyncMeb+0xc>
8111f254:	003b68fa 	trap	3
8111f258:	dfc00115 	stw	ra,4(sp)
8111f25c:	df000015 	stw	fp,0(sp)
8111f260:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f264:	00a045f4 	movhi	r2,33047
8111f268:	10a25304 	addi	r2,r2,-30388
8111f26c:	10800a8b 	ldhu	r2,42(r2)
8111f270:	10bfffcc 	andi	r2,r2,65535
8111f274:	10800228 	cmpgeui	r2,r2,8
8111f278:	1000071e 	bne	r2,zero,8111f298 <vFailSendMsgMasterSyncMeb+0x4c>
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
8111f27c:	d0a06217 	ldw	r2,-32376(gp)
8111f280:	100f883a 	mov	r7,r2
8111f284:	018006c4 	movi	r6,27
8111f288:	01400044 	movi	r5,1
8111f28c:	01204574 	movhi	r4,33045
8111f290:	2107f704 	addi	r4,r4,8156
8111f294:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f298:	0001883a 	nop
8111f29c:	e037883a 	mov	sp,fp
8111f2a0:	dfc00117 	ldw	ra,4(sp)
8111f2a4:	df000017 	ldw	fp,0(sp)
8111f2a8:	dec00204 	addi	sp,sp,8
8111f2ac:	f800283a 	ret

8111f2b0 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
8111f2b0:	defffe04 	addi	sp,sp,-8
8111f2b4:	de00012e 	bgeu	sp,et,8111f2bc <vFailSendMsgFeeCTRL+0xc>
8111f2b8:	003b68fa 	trap	3
8111f2bc:	dfc00115 	stw	ra,4(sp)
8111f2c0:	df000015 	stw	fp,0(sp)
8111f2c4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f2c8:	00a045f4 	movhi	r2,33047
8111f2cc:	10a25304 	addi	r2,r2,-30388
8111f2d0:	10800a8b 	ldhu	r2,42(r2)
8111f2d4:	10bfffcc 	andi	r2,r2,65535
8111f2d8:	10800228 	cmpgeui	r2,r2,8
8111f2dc:	1000071e 	bne	r2,zero,8111f2fc <vFailSendMsgFeeCTRL+0x4c>
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
8111f2e0:	d0a06217 	ldw	r2,-32376(gp)
8111f2e4:	100f883a 	mov	r7,r2
8111f2e8:	018005c4 	movi	r6,23
8111f2ec:	01400044 	movi	r5,1
8111f2f0:	01204574 	movhi	r4,33045
8111f2f4:	2107fe04 	addi	r4,r4,8184
8111f2f8:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f2fc:	0001883a 	nop
8111f300:	e037883a 	mov	sp,fp
8111f304:	dfc00117 	ldw	ra,4(sp)
8111f308:	df000017 	ldw	fp,0(sp)
8111f30c:	dec00204 	addi	sp,sp,8
8111f310:	f800283a 	ret

8111f314 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
8111f314:	defffe04 	addi	sp,sp,-8
8111f318:	de00012e 	bgeu	sp,et,8111f320 <vFailSendMsgDataCTRL+0xc>
8111f31c:	003b68fa 	trap	3
8111f320:	dfc00115 	stw	ra,4(sp)
8111f324:	df000015 	stw	fp,0(sp)
8111f328:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f32c:	00a045f4 	movhi	r2,33047
8111f330:	10a25304 	addi	r2,r2,-30388
8111f334:	10800a8b 	ldhu	r2,42(r2)
8111f338:	10bfffcc 	andi	r2,r2,65535
8111f33c:	10800228 	cmpgeui	r2,r2,8
8111f340:	1000071e 	bne	r2,zero,8111f360 <vFailSendMsgDataCTRL+0x4c>
		debug(fp,"vFailSendMsgDataCTRL.  \n");
8111f344:	d0a06217 	ldw	r2,-32376(gp)
8111f348:	100f883a 	mov	r7,r2
8111f34c:	01800604 	movi	r6,24
8111f350:	01400044 	movi	r5,1
8111f354:	01204574 	movhi	r4,33045
8111f358:	21080404 	addi	r4,r4,8208
8111f35c:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f360:	0001883a 	nop
8111f364:	e037883a 	mov	sp,fp
8111f368:	dfc00117 	ldw	ra,4(sp)
8111f36c:	df000017 	ldw	fp,0(sp)
8111f370:	dec00204 	addi	sp,sp,8
8111f374:	f800283a 	ret

8111f378 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8111f378:	defffe04 	addi	sp,sp,-8
8111f37c:	de00012e 	bgeu	sp,et,8111f384 <vFailFlushQueue+0xc>
8111f380:	003b68fa 	trap	3
8111f384:	dfc00115 	stw	ra,4(sp)
8111f388:	df000015 	stw	fp,0(sp)
8111f38c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f390:	00a045f4 	movhi	r2,33047
8111f394:	10a25304 	addi	r2,r2,-30388
8111f398:	10800a8b 	ldhu	r2,42(r2)
8111f39c:	10bfffcc 	andi	r2,r2,65535
8111f3a0:	10800228 	cmpgeui	r2,r2,8
8111f3a4:	1000071e 	bne	r2,zero,8111f3c4 <vFailFlushQueue+0x4c>
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
8111f3a8:	d0a06217 	ldw	r2,-32376(gp)
8111f3ac:	100f883a 	mov	r7,r2
8111f3b0:	01800744 	movi	r6,29
8111f3b4:	01400044 	movi	r5,1
8111f3b8:	01204574 	movhi	r4,33045
8111f3bc:	21080b04 	addi	r4,r4,8236
8111f3c0:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f3c4:	0001883a 	nop
8111f3c8:	e037883a 	mov	sp,fp
8111f3cc:	dfc00117 	ldw	ra,4(sp)
8111f3d0:	df000017 	ldw	fp,0(sp)
8111f3d4:	dec00204 	addi	sp,sp,8
8111f3d8:	f800283a 	ret

8111f3dc <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
8111f3dc:	defffe04 	addi	sp,sp,-8
8111f3e0:	de00012e 	bgeu	sp,et,8111f3e8 <vFailFlushQueueData+0xc>
8111f3e4:	003b68fa 	trap	3
8111f3e8:	dfc00115 	stw	ra,4(sp)
8111f3ec:	df000015 	stw	fp,0(sp)
8111f3f0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f3f4:	00a045f4 	movhi	r2,33047
8111f3f8:	10a25304 	addi	r2,r2,-30388
8111f3fc:	10800a8b 	ldhu	r2,42(r2)
8111f400:	10bfffcc 	andi	r2,r2,65535
8111f404:	10800228 	cmpgeui	r2,r2,8
8111f408:	1000071e 	bne	r2,zero,8111f428 <vFailFlushQueueData+0x4c>
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
8111f40c:	d0a06217 	ldw	r2,-32376(gp)
8111f410:	100f883a 	mov	r7,r2
8111f414:	01800844 	movi	r6,33
8111f418:	01400044 	movi	r5,1
8111f41c:	01204574 	movhi	r4,33045
8111f420:	21081304 	addi	r4,r4,8268
8111f424:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f428:	0001883a 	nop
8111f42c:	e037883a 	mov	sp,fp
8111f430:	dfc00117 	ldw	ra,4(sp)
8111f434:	df000017 	ldw	fp,0(sp)
8111f438:	dec00204 	addi	sp,sp,8
8111f43c:	f800283a 	ret

8111f440 <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8111f440:	defffe04 	addi	sp,sp,-8
8111f444:	de00012e 	bgeu	sp,et,8111f44c <vFailFlushMEBQueue+0xc>
8111f448:	003b68fa 	trap	3
8111f44c:	dfc00115 	stw	ra,4(sp)
8111f450:	df000015 	stw	fp,0(sp)
8111f454:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f458:	00a045f4 	movhi	r2,33047
8111f45c:	10a25304 	addi	r2,r2,-30388
8111f460:	10800a8b 	ldhu	r2,42(r2)
8111f464:	10bfffcc 	andi	r2,r2,65535
8111f468:	10800228 	cmpgeui	r2,r2,8
8111f46c:	1000071e 	bne	r2,zero,8111f48c <vFailFlushMEBQueue+0x4c>
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
8111f470:	d0a06217 	ldw	r2,-32376(gp)
8111f474:	100f883a 	mov	r7,r2
8111f478:	01800804 	movi	r6,32
8111f47c:	01400044 	movi	r5,1
8111f480:	01204574 	movhi	r4,33045
8111f484:	21081c04 	addi	r4,r4,8304
8111f488:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f48c:	0001883a 	nop
8111f490:	e037883a 	mov	sp,fp
8111f494:	dfc00117 	ldw	ra,4(sp)
8111f498:	df000017 	ldw	fp,0(sp)
8111f49c:	dec00204 	addi	sp,sp,8
8111f4a0:	f800283a 	ret

8111f4a4 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
8111f4a4:	defffe04 	addi	sp,sp,-8
8111f4a8:	de00012e 	bgeu	sp,et,8111f4b0 <vFailFlushNFEEQueue+0xc>
8111f4ac:	003b68fa 	trap	3
8111f4b0:	dfc00115 	stw	ra,4(sp)
8111f4b4:	df000015 	stw	fp,0(sp)
8111f4b8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f4bc:	00a045f4 	movhi	r2,33047
8111f4c0:	10a25304 	addi	r2,r2,-30388
8111f4c4:	10800a8b 	ldhu	r2,42(r2)
8111f4c8:	10bfffcc 	andi	r2,r2,65535
8111f4cc:	10800228 	cmpgeui	r2,r2,8
8111f4d0:	1000071e 	bne	r2,zero,8111f4f0 <vFailFlushNFEEQueue+0x4c>
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
8111f4d4:	d0a06217 	ldw	r2,-32376(gp)
8111f4d8:	100f883a 	mov	r7,r2
8111f4dc:	01800844 	movi	r6,33
8111f4e0:	01400044 	movi	r5,1
8111f4e4:	01204574 	movhi	r4,33045
8111f4e8:	21082504 	addi	r4,r4,8340
8111f4ec:	112393c0 	call	8112393c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111f4f0:	0001883a 	nop
8111f4f4:	e037883a 	mov	sp,fp
8111f4f8:	dfc00117 	ldw	ra,4(sp)
8111f4fc:	df000017 	ldw	fp,0(sp)
8111f500:	dec00204 	addi	sp,sp,8
8111f504:	f800283a 	ret

8111f508 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
8111f508:	deffff04 	addi	sp,sp,-4
8111f50c:	de00012e 	bgeu	sp,et,8111f514 <vEvtChangeMebMode+0xc>
8111f510:	003b68fa 	trap	3
8111f514:	df000015 	stw	fp,0(sp)
8111f518:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111f51c:	0001883a 	nop
8111f520:	e037883a 	mov	sp,fp
8111f524:	df000017 	ldw	fp,0(sp)
8111f528:	dec00104 	addi	sp,sp,4
8111f52c:	f800283a 	ret

8111f530 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
8111f530:	deffff04 	addi	sp,sp,-4
8111f534:	de00012e 	bgeu	sp,et,8111f53c <vEvtChangeFeeControllerMode+0xc>
8111f538:	003b68fa 	trap	3
8111f53c:	df000015 	stw	fp,0(sp)
8111f540:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111f544:	0001883a 	nop
8111f548:	e037883a 	mov	sp,fp
8111f54c:	df000017 	ldw	fp,0(sp)
8111f550:	dec00104 	addi	sp,sp,4
8111f554:	f800283a 	ret

8111f558 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
8111f558:	deffff04 	addi	sp,sp,-4
8111f55c:	de00012e 	bgeu	sp,et,8111f564 <vEvtChangeDataControllerMode+0xc>
8111f560:	003b68fa 	trap	3
8111f564:	df000015 	stw	fp,0(sp)
8111f568:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111f56c:	0001883a 	nop
8111f570:	e037883a 	mov	sp,fp
8111f574:	df000017 	ldw	fp,0(sp)
8111f578:	dec00104 	addi	sp,sp,4
8111f57c:	f800283a 	ret

8111f580 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111f580:	defffd04 	addi	sp,sp,-12
8111f584:	de00012e 	bgeu	sp,et,8111f58c <vNFeeNotInUse+0xc>
8111f588:	003b68fa 	trap	3
8111f58c:	df000215 	stw	fp,8(sp)
8111f590:	df000204 	addi	fp,sp,8
8111f594:	e13ffe15 	stw	r4,-8(fp)
8111f598:	2805883a 	mov	r2,r5
8111f59c:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8111f5a0:	e0bffe17 	ldw	r2,-8(fp)
8111f5a4:	e0ffff03 	ldbu	r3,-4(fp)
8111f5a8:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
8111f5ac:	e0bffe17 	ldw	r2,-8(fp)
8111f5b0:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111f5b4:	e0bffe17 	ldw	r2,-8(fp)
8111f5b8:	10002315 	stw	zero,140(r2)
}
8111f5bc:	0001883a 	nop
8111f5c0:	e037883a 	mov	sp,fp
8111f5c4:	df000017 	ldw	fp,0(sp)
8111f5c8:	dec00104 	addi	sp,sp,4
8111f5cc:	f800283a 	ret

8111f5d0 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111f5d0:	defffb04 	addi	sp,sp,-20
8111f5d4:	de00012e 	bgeu	sp,et,8111f5dc <vNFeeStructureInit+0xc>
8111f5d8:	003b68fa 	trap	3
8111f5dc:	dfc00415 	stw	ra,16(sp)
8111f5e0:	df000315 	stw	fp,12(sp)
8111f5e4:	df000304 	addi	fp,sp,12
8111f5e8:	e13ffe15 	stw	r4,-8(fp)
8111f5ec:	2805883a 	mov	r2,r5
8111f5f0:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8111f5f4:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
8111f5f8:	e0bffe17 	ldw	r2,-8(fp)
8111f5fc:	e0ffff03 	ldbu	r3,-4(fp)
8111f600:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8111f604:	e0bffe17 	ldw	r2,-8(fp)
8111f608:	10802f04 	addi	r2,r2,188
8111f60c:	1009883a 	mov	r4,r2
8111f610:	11198980 	call	81119898 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8111f614:	e13ffe17 	ldw	r4,-8(fp)
8111f618:	111f8540 	call	8111f854 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
8111f61c:	e0bffe17 	ldw	r2,-8(fp)
8111f620:	00c00044 	movi	r3,1
8111f624:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111f628:	e0bffe17 	ldw	r2,-8(fp)
8111f62c:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
8111f630:	e0bffe17 	ldw	r2,-8(fp)
8111f634:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
8111f638:	e0bffe17 	ldw	r2,-8(fp)
8111f63c:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
8111f640:	e0bffe17 	ldw	r2,-8(fp)
8111f644:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8111f648:	e0bffe17 	ldw	r2,-8(fp)
8111f64c:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
8111f650:	e0bffe17 	ldw	r2,-8(fp)
8111f654:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
8111f658:	e0bffe17 	ldw	r2,-8(fp)
8111f65c:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
8111f660:	e0bffe17 	ldw	r2,-8(fp)
8111f664:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
8111f668:	e0bffe17 	ldw	r2,-8(fp)
8111f66c:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
8111f670:	e0bffe17 	ldw	r2,-8(fp)
8111f674:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
8111f678:	e0bffe17 	ldw	r2,-8(fp)
8111f67c:	10002d15 	stw	zero,180(r2)

    switch (ucIdNFEE) {
8111f680:	e0bfff03 	ldbu	r2,-4(fp)
8111f684:	1000071e 	bne	r2,zero,8111f6a4 <vNFeeStructureInit+0xd4>
		case 0:
			pxNfeeL->ucSPWId = (unsigned char)xDefaults.usiLinkNFEE0;
8111f688:	00a045f4 	movhi	r2,33047
8111f68c:	10a25304 	addi	r2,r2,-30388
8111f690:	10800a0b 	ldhu	r2,40(r2)
8111f694:	1007883a 	mov	r3,r2
8111f698:	e0bffe17 	ldw	r2,-8(fp)
8111f69c:	10c00045 	stb	r3,1(r2)
			break;
8111f6a0:	00001006 	br	8111f6e4 <vNFeeStructureInit+0x114>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f6a4:	00a045f4 	movhi	r2,33047
8111f6a8:	10a25304 	addi	r2,r2,-30388
8111f6ac:	10800a8b 	ldhu	r2,42(r2)
8111f6b0:	10bfffcc 	andi	r2,r2,65535
8111f6b4:	10800228 	cmpgeui	r2,r2,8
8111f6b8:	1000091e 	bne	r2,zero,8111f6e0 <vNFeeStructureInit+0x110>
				fprintf(fp, "\n CRITICAL! Can't bind the SPW channel with the NFEE %i \n", pxNfeeL->ucId);
8111f6bc:	d0e06217 	ldw	r3,-32376(gp)
8111f6c0:	e0bffe17 	ldw	r2,-8(fp)
8111f6c4:	10800003 	ldbu	r2,0(r2)
8111f6c8:	10803fcc 	andi	r2,r2,255
8111f6cc:	100d883a 	mov	r6,r2
8111f6d0:	01604574 	movhi	r5,33045
8111f6d4:	29482e04 	addi	r5,r5,8376
8111f6d8:	1809883a 	mov	r4,r3
8111f6dc:	11232a00 	call	811232a0 <fprintf>
			}
			#endif
			break;
8111f6e0:	0001883a 	nop

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111f6e4:	e03ffd05 	stb	zero,-12(fp)
8111f6e8:	00000906 	br	8111f710 <vNFeeStructureInit+0x140>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
8111f6ec:	e0bffd03 	ldbu	r2,-12(fp)
8111f6f0:	e0fffe17 	ldw	r3,-8(fp)
8111f6f4:	1885883a 	add	r2,r3,r2
8111f6f8:	10802a44 	addi	r2,r2,169
8111f6fc:	e0fffd03 	ldbu	r3,-12(fp)
8111f700:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111f704:	e0bffd03 	ldbu	r2,-12(fp)
8111f708:	10800044 	addi	r2,r2,1
8111f70c:	e0bffd05 	stb	r2,-12(fp)
8111f710:	e0bffd03 	ldbu	r2,-12(fp)
8111f714:	10800130 	cmpltui	r2,r2,4
8111f718:	103ff41e 	bne	r2,zero,8111f6ec <__reset+0xfb0ff6ec>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, pxNfeeL->ucSPWId ) == FALSE ) {
8111f71c:	e0bffe17 	ldw	r2,-8(fp)
8111f720:	10c03204 	addi	r3,r2,200
8111f724:	e0bffe17 	ldw	r2,-8(fp)
8111f728:	10800043 	ldbu	r2,1(r2)
8111f72c:	10803fcc 	andi	r2,r2,255
8111f730:	100b883a 	mov	r5,r2
8111f734:	1809883a 	mov	r4,r3
8111f738:	110476c0 	call	8110476c <bCommInitCh>
8111f73c:	10000f1e 	bne	r2,zero,8111f77c <vNFeeStructureInit+0x1ac>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f740:	00a045f4 	movhi	r2,33047
8111f744:	10a25304 	addi	r2,r2,-30388
8111f748:	10800a8b 	ldhu	r2,42(r2)
8111f74c:	10bfffcc 	andi	r2,r2,65535
8111f750:	10800228 	cmpgeui	r2,r2,8
8111f754:	1000091e 	bne	r2,zero,8111f77c <vNFeeStructureInit+0x1ac>
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
8111f758:	d0e06217 	ldw	r3,-32376(gp)
8111f75c:	e0bffe17 	ldw	r2,-8(fp)
8111f760:	10800003 	ldbu	r2,0(r2)
8111f764:	10803fcc 	andi	r2,r2,255
8111f768:	100d883a 	mov	r6,r2
8111f76c:	01604574 	movhi	r5,33045
8111f770:	29483d04 	addi	r5,r5,8436
8111f774:	1809883a 	mov	r4,r3
8111f778:	11232a00 	call	811232a0 <fprintf>
    	}
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, pxNfeeL->ucSPWId ) == FALSE ) {
8111f77c:	e0bffe17 	ldw	r2,-8(fp)
8111f780:	10800043 	ldbu	r2,1(r2)
8111f784:	10803fcc 	andi	r2,r2,255
8111f788:	100b883a 	mov	r5,r2
8111f78c:	01000044 	movi	r4,1
8111f790:	11045b40 	call	811045b4 <bCommSetGlobalIrqEn>
8111f794:	10000f1e 	bne	r2,zero,8111f7d4 <vNFeeStructureInit+0x204>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111f798:	00a045f4 	movhi	r2,33047
8111f79c:	10a25304 	addi	r2,r2,-30388
8111f7a0:	10800a8b 	ldhu	r2,42(r2)
8111f7a4:	10bfffcc 	andi	r2,r2,65535
8111f7a8:	10800228 	cmpgeui	r2,r2,8
8111f7ac:	1000091e 	bne	r2,zero,8111f7d4 <vNFeeStructureInit+0x204>
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
8111f7b0:	d0e06217 	ldw	r3,-32376(gp)
8111f7b4:	e0bffe17 	ldw	r2,-8(fp)
8111f7b8:	10800003 	ldbu	r2,0(r2)
8111f7bc:	10803fcc 	andi	r2,r2,255
8111f7c0:	100d883a 	mov	r6,r2
8111f7c4:	01604574 	movhi	r5,33045
8111f7c8:	29484904 	addi	r5,r5,8484
8111f7cc:	1809883a 	mov	r4,r3
8111f7d0:	11232a00 	call	811232a0 <fprintf>
    	}
		#endif
    }

    bDpktGetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111f7d4:	e0bffe17 	ldw	r2,-8(fp)
8111f7d8:	10803304 	addi	r2,r2,204
8111f7dc:	1009883a 	mov	r4,r2
8111f7e0:	1104f200 	call	81104f20 <bDpktGetPixelDelay>
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiAdcDelay = usiAdcPxDelayCalcPeriodNs(xDefaults.ulADCPixelDelay);
8111f7e4:	00a045f4 	movhi	r2,33047
8111f7e8:	10a25304 	addi	r2,r2,-30388
8111f7ec:	10800717 	ldw	r2,28(r2)
8111f7f0:	1009883a 	mov	r4,r2
8111f7f4:	11052580 	call	81105258 <usiAdcPxDelayCalcPeriodNs>
8111f7f8:	1007883a 	mov	r3,r2
8111f7fc:	e0bffe17 	ldw	r2,-8(fp)
8111f800:	10c03a8d 	sth	r3,234(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiColumnDelay = 0 ;
8111f804:	e0bffe17 	ldw	r2,-8(fp)
8111f808:	10003a0d 	sth	zero,232(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiLineDelay = usiLineTrDelayCalcPeriodNs(xDefaults.ulLineDelay);
8111f80c:	00a045f4 	movhi	r2,33047
8111f810:	10a25304 	addi	r2,r2,-30388
8111f814:	10800517 	ldw	r2,20(r2)
8111f818:	1009883a 	mov	r4,r2
8111f81c:	11052e40 	call	811052e4 <usiLineTrDelayCalcPeriodNs>
8111f820:	1007883a 	mov	r3,r2
8111f824:	e0bffe17 	ldw	r2,-8(fp)
8111f828:	10c0398d 	sth	r3,230(r2)
    bDpktSetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111f82c:	e0bffe17 	ldw	r2,-8(fp)
8111f830:	10803304 	addi	r2,r2,204
8111f834:	1009883a 	mov	r4,r2
8111f838:	1104dcc0 	call	81104dcc <bDpktSetPixelDelay>

}
8111f83c:	0001883a 	nop
8111f840:	e037883a 	mov	sp,fp
8111f844:	dfc00117 	ldw	ra,4(sp)
8111f848:	df000017 	ldw	fp,0(sp)
8111f84c:	dec00204 	addi	sp,sp,8
8111f850:	f800283a 	ret

8111f854 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8111f854:	defff404 	addi	sp,sp,-48
8111f858:	de00012e 	bgeu	sp,et,8111f860 <vUpdateMemMapFEE+0xc>
8111f85c:	003b68fa 	trap	3
8111f860:	df000b15 	stw	fp,44(sp)
8111f864:	df000b04 	addi	fp,sp,44
8111f868:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
8111f86c:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8111f870:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8111f874:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
8111f878:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
8111f87c:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8111f880:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8111f884:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
8111f888:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
8111f88c:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
8111f890:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
8111f894:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
8111f898:	e17fff17 	ldw	r5,-4(fp)
8111f89c:	01035a34 	movhi	r4,3432
8111f8a0:	21348c04 	addi	r4,r4,-11728
8111f8a4:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
8111f8a8:	e13fff17 	ldw	r4,-4(fp)
8111f8ac:	21000003 	ldbu	r4,0(r4)
8111f8b0:	21403fcc 	andi	r5,r4,255
8111f8b4:	01035a34 	movhi	r4,3432
8111f8b8:	21348c04 	addi	r4,r4,-11728
8111f8bc:	2909383a 	mul	r4,r5,r4
8111f8c0:	200b883a 	mov	r5,r4
8111f8c4:	e13fff17 	ldw	r4,-4(fp)
8111f8c8:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
8111f8cc:	e13fff17 	ldw	r4,-4(fp)
8111f8d0:	21400117 	ldw	r5,4(r4)
8111f8d4:	01033234 	movhi	r4,3272
8111f8d8:	21348c04 	addi	r4,r4,-11728
8111f8dc:	290b883a 	add	r5,r5,r4
8111f8e0:	e13fff17 	ldw	r4,-4(fp)
8111f8e4:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111f8e8:	e13fff17 	ldw	r4,-4(fp)
8111f8ec:	2100310b 	ldhu	r4,196(r4)
8111f8f0:	217fffcc 	andi	r5,r4,65535
8111f8f4:	e13fff17 	ldw	r4,-4(fp)
8111f8f8:	2100300b 	ldhu	r4,192(r4)
8111f8fc:	213fffcc 	andi	r4,r4,65535
8111f900:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8111f904:	e13fff17 	ldw	r4,-4(fp)
8111f908:	2100308b 	ldhu	r4,194(r4)
8111f90c:	21bfffcc 	andi	r6,r4,65535
8111f910:	e13fff17 	ldw	r4,-4(fp)
8111f914:	21002f8b 	ldhu	r4,190(r4)
8111f918:	213fffcc 	andi	r4,r4,65535
8111f91c:	310d883a 	add	r6,r6,r4
8111f920:	e13fff17 	ldw	r4,-4(fp)
8111f924:	21002f0b 	ldhu	r4,188(r4)
8111f928:	213fffcc 	andi	r4,r4,65535
8111f92c:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111f930:	2909383a 	mul	r4,r5,r4
8111f934:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
8111f938:	e13ffa17 	ldw	r4,-24(fp)
8111f93c:	2109883a 	add	r4,r4,r4
8111f940:	200b883a 	mov	r5,r4
8111f944:	e13fff17 	ldw	r4,-4(fp)
8111f948:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
8111f94c:	e13fff17 	ldw	r4,-4(fp)
8111f950:	21000517 	ldw	r4,20(r4)
8111f954:	2008d0fa 	srli	r4,r4,3
8111f958:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
8111f95c:	e13fff17 	ldw	r4,-4(fp)
8111f960:	21000517 	ldw	r4,20(r4)
8111f964:	210001cc 	andi	r4,r4,7
8111f968:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
8111f96c:	e13ffb17 	ldw	r4,-20(fp)
8111f970:	20001226 	beq	r4,zero,8111f9bc <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
8111f974:	e13ff517 	ldw	r4,-44(fp)
8111f978:	21000044 	addi	r4,r4,1
8111f97c:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8111f980:	e13fff17 	ldw	r4,-4(fp)
8111f984:	21400517 	ldw	r5,20(r4)
8111f988:	e13ffb17 	ldw	r4,-20(fp)
8111f98c:	2909c83a 	sub	r4,r5,r4
8111f990:	21400204 	addi	r5,r4,8
8111f994:	e13fff17 	ldw	r4,-4(fp)
8111f998:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
8111f99c:	e13ffb17 	ldw	r4,-20(fp)
8111f9a0:	200b883a 	mov	r5,r4
8111f9a4:	01000204 	movi	r4,8
8111f9a8:	2149c83a 	sub	r4,r4,r5
8111f9ac:	200b883a 	mov	r5,r4
8111f9b0:	e13fff17 	ldw	r4,-4(fp)
8111f9b4:	21400605 	stb	r5,24(r4)
8111f9b8:	00000206 	br	8111f9c4 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
8111f9bc:	e13fff17 	ldw	r4,-4(fp)
8111f9c0:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8111f9c4:	e13ff517 	ldw	r4,-44(fp)
8111f9c8:	2008d13a 	srli	r4,r4,4
8111f9cc:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8111f9d0:	e13ff517 	ldw	r4,-44(fp)
8111f9d4:	210003cc 	andi	r4,r4,15
8111f9d8:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
8111f9dc:	e13ffc17 	ldw	r4,-16(fp)
8111f9e0:	20000b26 	beq	r4,zero,8111fa10 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8111f9e4:	e13ff717 	ldw	r4,-36(fp)
8111f9e8:	21000044 	addi	r4,r4,1
8111f9ec:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
8111f9f0:	e17ff517 	ldw	r5,-44(fp)
8111f9f4:	e13ffc17 	ldw	r4,-16(fp)
8111f9f8:	290bc83a 	sub	r5,r5,r4
8111f9fc:	e13ff717 	ldw	r4,-36(fp)
8111fa00:	2909883a 	add	r4,r5,r4
8111fa04:	21000404 	addi	r4,r4,16
8111fa08:	e13ff615 	stw	r4,-40(fp)
8111fa0c:	00000406 	br	8111fa20 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8111fa10:	e17ff517 	ldw	r5,-44(fp)
8111fa14:	e13ff717 	ldw	r4,-36(fp)
8111fa18:	2909883a 	add	r4,r5,r4
8111fa1c:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8111fa20:	e13ff617 	ldw	r4,-40(fp)
8111fa24:	200a90fa 	slli	r5,r4,3
8111fa28:	e13fff17 	ldw	r4,-4(fp)
8111fa2c:	21400515 	stw	r5,20(r4)


    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8111fa30:	e13ffb17 	ldw	r4,-20(fp)
8111fa34:	20000926 	beq	r4,zero,8111fa5c <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
8111fa38:	e13ffc17 	ldw	r4,-16(fp)
8111fa3c:	2109883a 	add	r4,r4,r4
8111fa40:	2109883a 	add	r4,r4,r4
8111fa44:	200b883a 	mov	r5,r4
8111fa48:	e13ffb17 	ldw	r4,-20(fp)
8111fa4c:	2008d07a 	srli	r4,r4,1
8111fa50:	2909883a 	add	r4,r5,r4
8111fa54:	e13ff805 	stb	r4,-32(fp)
8111fa58:	00000406 	br	8111fa6c <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
8111fa5c:	e13ffc17 	ldw	r4,-16(fp)
8111fa60:	2109883a 	add	r4,r4,r4
8111fa64:	2109883a 	add	r4,r4,r4
8111fa68:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
8111fa6c:	e13ff803 	ldbu	r4,-32(fp)
8111fa70:	01401004 	movi	r5,64
8111fa74:	2909c83a 	sub	r4,r5,r4
8111fa78:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF << ucShiftsL);
8111fa7c:	e13ffd03 	ldbu	r4,-12(fp)
8111fa80:	217ff804 	addi	r5,r4,-32
8111fa84:	28000416 	blt	r5,zero,8111fa98 <vUpdateMemMapFEE+0x244>
8111fa88:	013fffc4 	movi	r4,-1
8111fa8c:	2146983a 	sll	r3,r4,r5
8111fa90:	0005883a 	mov	r2,zero
8111fa94:	00000a06 	br	8111fac0 <vUpdateMemMapFEE+0x26c>
8111fa98:	017fffc4 	movi	r5,-1
8111fa9c:	280cd07a 	srli	r6,r5,1
8111faa0:	014007c4 	movi	r5,31
8111faa4:	290bc83a 	sub	r5,r5,r4
8111faa8:	314ad83a 	srl	r5,r6,r5
8111faac:	01bfffc4 	movi	r6,-1
8111fab0:	3106983a 	sll	r3,r6,r4
8111fab4:	28c6b03a 	or	r3,r5,r3
8111fab8:	017fffc4 	movi	r5,-1
8111fabc:	2904983a 	sll	r2,r5,r4
8111fac0:	e13fff17 	ldw	r4,-4(fp)
8111fac4:	20800715 	stw	r2,28(r4)
8111fac8:	20c00815 	stw	r3,32(r4)
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF);


    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
8111facc:	e0bfff17 	ldw	r2,-4(fp)
8111fad0:	e0fff717 	ldw	r3,-36(fp)
8111fad4:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
8111fad8:	e0bfff17 	ldw	r2,-4(fp)
8111fadc:	10c00117 	ldw	r3,4(r2)
8111fae0:	008004b4 	movhi	r2,18
8111fae4:	10a40004 	addi	r2,r2,-28672
8111fae8:	1885883a 	add	r2,r3,r2
8111faec:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
8111faf0:	e0bfff17 	ldw	r2,-4(fp)
8111faf4:	10c00517 	ldw	r3,20(r2)
8111faf8:	008000b4 	movhi	r2,2
8111fafc:	10a40004 	addi	r2,r2,-28672
8111fb00:	1885883a 	add	r2,r3,r2
8111fb04:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111fb08:	e03ff845 	stb	zero,-31(fp)
8111fb0c:	00001906 	br	8111fb74 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111fb10:	e0bff843 	ldbu	r2,-31(fp)
8111fb14:	e0ffff17 	ldw	r3,-4(fp)
8111fb18:	10800624 	muli	r2,r2,24
8111fb1c:	1885883a 	add	r2,r3,r2
8111fb20:	10800904 	addi	r2,r2,36
8111fb24:	e0fff917 	ldw	r3,-28(fp)
8111fb28:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111fb2c:	e0fff917 	ldw	r3,-28(fp)
8111fb30:	e0bffe17 	ldw	r2,-8(fp)
8111fb34:	1885883a 	add	r2,r3,r2
8111fb38:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
8111fb3c:	e0bff843 	ldbu	r2,-31(fp)
8111fb40:	e0ffff17 	ldw	r3,-4(fp)
8111fb44:	10800624 	muli	r2,r2,24
8111fb48:	1885883a 	add	r2,r3,r2
8111fb4c:	10800c04 	addi	r2,r2,48
8111fb50:	e0fff917 	ldw	r3,-28(fp)
8111fb54:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111fb58:	e0fff917 	ldw	r3,-28(fp)
8111fb5c:	e0bffe17 	ldw	r2,-8(fp)
8111fb60:	1885883a 	add	r2,r3,r2
8111fb64:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111fb68:	e0bff843 	ldbu	r2,-31(fp)
8111fb6c:	10800044 	addi	r2,r2,1
8111fb70:	e0bff845 	stb	r2,-31(fp)
8111fb74:	e0bff843 	ldbu	r2,-31(fp)
8111fb78:	10800130 	cmpltui	r2,r2,4
8111fb7c:	103fe41e 	bne	r2,zero,8111fb10 <__reset+0xfb0ffb10>
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }

}
8111fb80:	0001883a 	nop
8111fb84:	e037883a 	mov	sp,fp
8111fb88:	df000017 	ldw	fp,0(sp)
8111fb8c:	dec00104 	addi	sp,sp,4
8111fb90:	f800283a 	ret

8111fb94 <vResetMemCCDFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
8111fb94:	defffd04 	addi	sp,sp,-12
8111fb98:	de00012e 	bgeu	sp,et,8111fba0 <vResetMemCCDFEE+0xc>
8111fb9c:	003b68fa 	trap	3
8111fba0:	df000215 	stw	fp,8(sp)
8111fba4:	df000204 	addi	fp,sp,8
8111fba8:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL = 0;
8111fbac:	e03ffe05 	stb	zero,-8(fp)

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111fbb0:	e03ffe05 	stb	zero,-8(fp)
8111fbb4:	00001b06 	br	8111fc24 <vResetMemCCDFEE+0x90>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
8111fbb8:	e0bffe03 	ldbu	r2,-8(fp)
8111fbbc:	e0ffff17 	ldw	r3,-4(fp)
8111fbc0:	10800624 	muli	r2,r2,24
8111fbc4:	1885883a 	add	r2,r3,r2
8111fbc8:	10800b04 	addi	r2,r2,44
8111fbcc:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
8111fbd0:	e0bffe03 	ldbu	r2,-8(fp)
8111fbd4:	e0ffff17 	ldw	r3,-4(fp)
8111fbd8:	10800624 	muli	r2,r2,24
8111fbdc:	1885883a 	add	r2,r3,r2
8111fbe0:	10800a04 	addi	r2,r2,40
8111fbe4:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
8111fbe8:	e0bffe03 	ldbu	r2,-8(fp)
8111fbec:	e0ffff17 	ldw	r3,-4(fp)
8111fbf0:	10800624 	muli	r2,r2,24
8111fbf4:	1885883a 	add	r2,r3,r2
8111fbf8:	10800e04 	addi	r2,r2,56
8111fbfc:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
8111fc00:	e0bffe03 	ldbu	r2,-8(fp)
8111fc04:	e0ffff17 	ldw	r3,-4(fp)
8111fc08:	10800624 	muli	r2,r2,24
8111fc0c:	1885883a 	add	r2,r3,r2
8111fc10:	10800d04 	addi	r2,r2,52
8111fc14:	10000015 	stw	zero,0(r2)

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
	unsigned char ucIL = 0;

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111fc18:	e0bffe03 	ldbu	r2,-8(fp)
8111fc1c:	10800044 	addi	r2,r2,1
8111fc20:	e0bffe05 	stb	r2,-8(fp)
8111fc24:	e0bffe03 	ldbu	r2,-8(fp)
8111fc28:	10800130 	cmpltui	r2,r2,4
8111fc2c:	103fe21e 	bne	r2,zero,8111fbb8 <__reset+0xfb0ffbb8>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
    }
}
8111fc30:	0001883a 	nop
8111fc34:	e037883a 	mov	sp,fp
8111fc38:	df000017 	ldw	fp,0(sp)
8111fc3c:	dec00104 	addi	sp,sp,4
8111fc40:	f800283a 	ret

8111fc44 <vFeeSpwRMAPLoadDefault>:



/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
8111fc44:	defffe04 	addi	sp,sp,-8
8111fc48:	de00012e 	bgeu	sp,et,8111fc50 <vFeeSpwRMAPLoadDefault+0xc>
8111fc4c:	003b68fa 	trap	3
8111fc50:	df000115 	stw	fp,4(sp)
8111fc54:	df000104 	addi	fp,sp,4
8111fc58:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111fc5c:	0001883a 	nop
8111fc60:	e037883a 	mov	sp,fp
8111fc64:	df000017 	ldw	fp,0(sp)
8111fc68:	dec00104 	addi	sp,sp,4
8111fc6c:	f800283a 	ret

8111fc70 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
8111fc70:	defffe04 	addi	sp,sp,-8
8111fc74:	de00012e 	bgeu	sp,et,8111fc7c <vFeeSpwRMAPChangeConfig+0xc>
8111fc78:	003b68fa 	trap	3
8111fc7c:	df000115 	stw	fp,4(sp)
8111fc80:	df000104 	addi	fp,sp,4
8111fc84:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111fc88:	0001883a 	nop
8111fc8c:	e037883a 	mov	sp,fp
8111fc90:	df000017 	ldw	fp,0(sp)
8111fc94:	dec00104 	addi	sp,sp,4
8111fc98:	f800283a 	ret

8111fc9c <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
8111fc9c:	defffe04 	addi	sp,sp,-8
8111fca0:	de00012e 	bgeu	sp,et,8111fca8 <vFeeSpwRMAPChangeDefault+0xc>
8111fca4:	003b68fa 	trap	3
8111fca8:	df000115 	stw	fp,4(sp)
8111fcac:	df000104 	addi	fp,sp,4
8111fcb0:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
8111fcb4:	0001883a 	nop
8111fcb8:	e037883a 	mov	sp,fp
8111fcbc:	df000017 	ldw	fp,0(sp)
8111fcc0:	dec00104 	addi	sp,sp,4
8111fcc4:	f800283a 	ret

8111fcc8 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
8111fcc8:	defffe04 	addi	sp,sp,-8
8111fccc:	de00012e 	bgeu	sp,et,8111fcd4 <cFeeSpwChannelEnable+0xc>
8111fcd0:	003b68fa 	trap	3
8111fcd4:	df000115 	stw	fp,4(sp)
8111fcd8:	df000104 	addi	fp,sp,4
8111fcdc:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111fce0:	0001883a 	nop
8111fce4:	e037883a 	mov	sp,fp
8111fce8:	df000017 	ldw	fp,0(sp)
8111fcec:	dec00104 	addi	sp,sp,4
8111fcf0:	f800283a 	ret

8111fcf4 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
8111fcf4:	defffe04 	addi	sp,sp,-8
8111fcf8:	de00012e 	bgeu	sp,et,8111fd00 <cFeeSpwChannelDisable+0xc>
8111fcfc:	003b68fa 	trap	3
8111fd00:	df000115 	stw	fp,4(sp)
8111fd04:	df000104 	addi	fp,sp,4
8111fd08:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111fd0c:	0001883a 	nop
8111fd10:	e037883a 	mov	sp,fp
8111fd14:	df000017 	ldw	fp,0(sp)
8111fd18:	dec00104 	addi	sp,sp,4
8111fd1c:	f800283a 	ret

8111fd20 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
8111fd20:	defffe04 	addi	sp,sp,-8
8111fd24:	de00012e 	bgeu	sp,et,8111fd2c <cFeeRMAPDump+0xc>
8111fd28:	003b68fa 	trap	3
8111fd2c:	df000115 	stw	fp,4(sp)
8111fd30:	df000104 	addi	fp,sp,4
8111fd34:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
8111fd38:	0001883a 	nop
8111fd3c:	e037883a 	mov	sp,fp
8111fd40:	df000017 	ldw	fp,0(sp)
8111fd44:	dec00104 	addi	sp,sp,4
8111fd48:	f800283a 	ret

8111fd4c <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
8111fd4c:	defffe04 	addi	sp,sp,-8
8111fd50:	de00012e 	bgeu	sp,et,8111fd58 <cFeeRMAPEchoingEnable+0xc>
8111fd54:	003b68fa 	trap	3
8111fd58:	df000115 	stw	fp,4(sp)
8111fd5c:	df000104 	addi	fp,sp,4
8111fd60:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
8111fd64:	e0bfff17 	ldw	r2,-4(fp)
8111fd68:	00c00044 	movi	r3,1
8111fd6c:	10c02515 	stw	r3,148(r2)
}
8111fd70:	0001883a 	nop
8111fd74:	e037883a 	mov	sp,fp
8111fd78:	df000017 	ldw	fp,0(sp)
8111fd7c:	dec00104 	addi	sp,sp,4
8111fd80:	f800283a 	ret

8111fd84 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
8111fd84:	defffe04 	addi	sp,sp,-8
8111fd88:	de00012e 	bgeu	sp,et,8111fd90 <cFeeRMAPEchoingDisable+0xc>
8111fd8c:	003b68fa 	trap	3
8111fd90:	df000115 	stw	fp,4(sp)
8111fd94:	df000104 	addi	fp,sp,4
8111fd98:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
8111fd9c:	e0bfff17 	ldw	r2,-4(fp)
8111fda0:	10002515 	stw	zero,148(r2)
}
8111fda4:	0001883a 	nop
8111fda8:	e037883a 	mov	sp,fp
8111fdac:	df000017 	ldw	fp,0(sp)
8111fdb0:	dec00104 	addi	sp,sp,4
8111fdb4:	f800283a 	ret

8111fdb8 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
8111fdb8:	defffe04 	addi	sp,sp,-8
8111fdbc:	de00012e 	bgeu	sp,et,8111fdc4 <cFeeRMAPLogEnable+0xc>
8111fdc0:	003b68fa 	trap	3
8111fdc4:	df000115 	stw	fp,4(sp)
8111fdc8:	df000104 	addi	fp,sp,4
8111fdcc:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111fdd0:	e0bfff17 	ldw	r2,-4(fp)
8111fdd4:	00c00044 	movi	r3,1
8111fdd8:	10c02415 	stw	r3,144(r2)
}
8111fddc:	0001883a 	nop
8111fde0:	e037883a 	mov	sp,fp
8111fde4:	df000017 	ldw	fp,0(sp)
8111fde8:	dec00104 	addi	sp,sp,4
8111fdec:	f800283a 	ret

8111fdf0 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111fdf0:	defffe04 	addi	sp,sp,-8
8111fdf4:	de00012e 	bgeu	sp,et,8111fdfc <cFeeRMAPLogDisable+0xc>
8111fdf8:	003b68fa 	trap	3
8111fdfc:	df000115 	stw	fp,4(sp)
8111fe00:	df000104 	addi	fp,sp,4
8111fe04:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8111fe08:	e0bfff17 	ldw	r2,-4(fp)
8111fe0c:	10002415 	stw	zero,144(r2)
}
8111fe10:	0001883a 	nop
8111fe14:	e037883a 	mov	sp,fp
8111fe18:	df000017 	ldw	fp,0(sp)
8111fe1c:	dec00104 	addi	sp,sp,4
8111fe20:	f800283a 	ret

8111fe24 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
8111fe24:	defffc04 	addi	sp,sp,-16
8111fe28:	de00012e 	bgeu	sp,et,8111fe30 <vNFeeControlInit+0xc>
8111fe2c:	003b68fa 	trap	3
8111fe30:	dfc00315 	stw	ra,12(sp)
8111fe34:	df000215 	stw	fp,8(sp)
8111fe38:	df000204 	addi	fp,sp,8
8111fe3c:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
8111fe40:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
8111fe44:	e13fff17 	ldw	r4,-4(fp)
8111fe48:	111ff700 	call	8111ff70 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
8111fe4c:	e13fff17 	ldw	r4,-4(fp)
8111fe50:	111ffa40 	call	8111ffa4 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
8111fe54:	e0bfff17 	ldw	r2,-4(fp)
8111fe58:	10009c15 	stw	zero,624(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111fe5c:	e03ffe05 	stb	zero,-8(fp)
8111fe60:	00002b06 	br	8111ff10 <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
8111fe64:	e0bffe03 	ldbu	r2,-8(fp)
8111fe68:	10809824 	muli	r2,r2,608
8111fe6c:	e0ffff17 	ldw	r3,-4(fp)
8111fe70:	1885883a 	add	r2,r3,r2
8111fe74:	e0fffe03 	ldbu	r3,-8(fp)
8111fe78:	180b883a 	mov	r5,r3
8111fe7c:	1009883a 	mov	r4,r2
8111fe80:	111f5d00 	call	8111f5d0 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
8111fe84:	e0bffe03 	ldbu	r2,-8(fp)
8111fe88:	e0fffe03 	ldbu	r3,-8(fp)
8111fe8c:	18c09824 	muli	r3,r3,608
8111fe90:	18c02104 	addi	r3,r3,132
8111fe94:	e13fff17 	ldw	r4,-4(fp)
8111fe98:	20c7883a 	add	r3,r4,r3
8111fe9c:	e13fff17 	ldw	r4,-4(fp)
8111fea0:	10802644 	addi	r2,r2,153
8111fea4:	1085883a 	add	r2,r2,r2
8111fea8:	1085883a 	add	r2,r2,r2
8111feac:	2085883a 	add	r2,r4,r2
8111feb0:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
8111feb4:	e0bffe03 	ldbu	r2,-8(fp)
8111feb8:	e0fffe03 	ldbu	r3,-8(fp)
8111febc:	18c09824 	muli	r3,r3,608
8111fec0:	18c02704 	addi	r3,r3,156
8111fec4:	e13fff17 	ldw	r4,-4(fp)
8111fec8:	20c7883a 	add	r3,r4,r3
8111fecc:	e13fff17 	ldw	r4,-4(fp)
8111fed0:	10802684 	addi	r2,r2,154
8111fed4:	1085883a 	add	r2,r2,r2
8111fed8:	1085883a 	add	r2,r2,r2
8111fedc:	2085883a 	add	r2,r4,r2
8111fee0:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
8111fee4:	e0bffe03 	ldbu	r2,-8(fp)
8111fee8:	e0ffff17 	ldw	r3,-4(fp)
8111feec:	18c09817 	ldw	r3,608(r3)
8111fef0:	e13fff17 	ldw	r4,-4(fp)
8111fef4:	10809824 	muli	r2,r2,608
8111fef8:	2085883a 	add	r2,r4,r2
8111fefc:	10802904 	addi	r2,r2,164
8111ff00:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111ff04:	e0bffe03 	ldbu	r2,-8(fp)
8111ff08:	10800044 	addi	r2,r2,1
8111ff0c:	e0bffe05 	stb	r2,-8(fp)
8111ff10:	e0bffe03 	ldbu	r2,-8(fp)
8111ff14:	103fd326 	beq	r2,zero,8111fe64 <__reset+0xfb0ffe64>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
8111ff18:	0001883a 	nop
8111ff1c:	e037883a 	mov	sp,fp
8111ff20:	dfc00117 	ldw	ra,4(sp)
8111ff24:	df000017 	ldw	fp,0(sp)
8111ff28:	dec00204 	addi	sp,sp,8
8111ff2c:	f800283a 	ret

8111ff30 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
8111ff30:	defffd04 	addi	sp,sp,-12
8111ff34:	de00012e 	bgeu	sp,et,8111ff3c <vSetTimeCode+0xc>
8111ff38:	003b68fa 	trap	3
8111ff3c:	df000215 	stw	fp,8(sp)
8111ff40:	df000204 	addi	fp,sp,8
8111ff44:	e13ffe15 	stw	r4,-8(fp)
8111ff48:	2805883a 	mov	r2,r5
8111ff4c:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
8111ff50:	e0bffe17 	ldw	r2,-8(fp)
8111ff54:	e0ffff03 	ldbu	r3,-4(fp)
8111ff58:	10c09b05 	stb	r3,620(r2)
}
8111ff5c:	0001883a 	nop
8111ff60:	e037883a 	mov	sp,fp
8111ff64:	df000017 	ldw	fp,0(sp)
8111ff68:	dec00104 	addi	sp,sp,4
8111ff6c:	f800283a 	ret

8111ff70 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
8111ff70:	defffe04 	addi	sp,sp,-8
8111ff74:	de00012e 	bgeu	sp,et,8111ff7c <vResetTimeCode+0xc>
8111ff78:	003b68fa 	trap	3
8111ff7c:	df000115 	stw	fp,4(sp)
8111ff80:	df000104 	addi	fp,sp,4
8111ff84:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8111ff88:	e0bfff17 	ldw	r2,-4(fp)
8111ff8c:	10009b05 	stb	zero,620(r2)
}
8111ff90:	0001883a 	nop
8111ff94:	e037883a 	mov	sp,fp
8111ff98:	df000017 	ldw	fp,0(sp)
8111ff9c:	dec00104 	addi	sp,sp,4
8111ffa0:	f800283a 	ret

8111ffa4 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
8111ffa4:	defffe04 	addi	sp,sp,-8
8111ffa8:	de00012e 	bgeu	sp,et,8111ffb0 <vLoadDefaultIdNFEEMaster+0xc>
8111ffac:	003b68fa 	trap	3
8111ffb0:	df000115 	stw	fp,4(sp)
8111ffb4:	df000104 	addi	fp,sp,4
8111ffb8:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
8111ffbc:	e0bfff17 	ldw	r2,-4(fp)
8111ffc0:	10009b45 	stb	zero,621(r2)
}
8111ffc4:	0001883a 	nop
8111ffc8:	e037883a 	mov	sp,fp
8111ffcc:	df000017 	ldw	fp,0(sp)
8111ffd0:	dec00104 	addi	sp,sp,4
8111ffd4:	f800283a 	ret

8111ffd8 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111ffd8:	defffd04 	addi	sp,sp,-12
8111ffdc:	de00012e 	bgeu	sp,et,8111ffe4 <vChangeIdNFEEMaster+0xc>
8111ffe0:	003b68fa 	trap	3
8111ffe4:	df000215 	stw	fp,8(sp)
8111ffe8:	df000204 	addi	fp,sp,8
8111ffec:	e13ffe15 	stw	r4,-8(fp)
8111fff0:	2805883a 	mov	r2,r5
8111fff4:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
8111fff8:	e0bffe17 	ldw	r2,-8(fp)
8111fffc:	e0ffff03 	ldbu	r3,-4(fp)
81120000:	10c09b45 	stb	r3,621(r2)
}
81120004:	0001883a 	nop
81120008:	e037883a 	mov	sp,fp
8112000c:	df000017 	ldw	fp,0(sp)
81120010:	dec00104 	addi	sp,sp,4
81120014:	f800283a 	ret

81120018 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
81120018:	defffd04 	addi	sp,sp,-12
8112001c:	de00012e 	bgeu	sp,et,81120024 <vChangeDefaultIdNFEEMaster+0xc>
81120020:	003b68fa 	trap	3
81120024:	df000215 	stw	fp,8(sp)
81120028:	df000204 	addi	fp,sp,8
8112002c:	e13ffe15 	stw	r4,-8(fp)
81120030:	2805883a 	mov	r2,r5
81120034:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
81120038:	0001883a 	nop
8112003c:	e037883a 	mov	sp,fp
81120040:	df000017 	ldw	fp,0(sp)
81120044:	dec00104 	addi	sp,sp,4
81120048:	f800283a 	ret

8112004c <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
8112004c:	defffe04 	addi	sp,sp,-8
81120050:	de00012e 	bgeu	sp,et,81120058 <vInitSimucamBasicHW+0xc>
81120054:	003b68fa 	trap	3
81120058:	dfc00115 	stw	ra,4(sp)
8112005c:	df000015 	stw	fp,0(sp)
81120060:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
81120064:	01403fc4 	movi	r5,255
81120068:	0009883a 	mov	r4,zero
8112006c:	110b87c0 	call	8110b87c <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
81120070:	01400834 	movhi	r5,32
81120074:	297fffc4 	addi	r5,r5,-1
81120078:	0009883a 	mov	r4,zero
8112007c:	110b8fc0 	call	8110b8fc <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
81120080:	01400074 	movhi	r5,1
81120084:	01000044 	movi	r4,1
81120088:	110b8fc0 	call	8110b8fc <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
8112008c:	0009883a 	mov	r4,zero
81120090:	110cfb40 	call	8110cfb4 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
81120094:	0009883a 	mov	r4,zero
81120098:	110d0840 	call	8110d084 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8112009c:	01008004 	movi	r4,512
811200a0:	110cafc0 	call	8110cafc <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
811200a4:	01008004 	movi	r4,512
811200a8:	110ca880 	call	8110ca88 <vRstcReleaseDeviceReset>

}
811200ac:	0001883a 	nop
811200b0:	e037883a 	mov	sp,fp
811200b4:	dfc00117 	ldw	ra,4(sp)
811200b8:	df000017 	ldw	fp,0(sp)
811200bc:	dec00204 	addi	sp,sp,8
811200c0:	f800283a 	ret

811200c4 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
811200c4:	defffd04 	addi	sp,sp,-12
811200c8:	de00012e 	bgeu	sp,et,811200d0 <bLogWriteSDCard+0xc>
811200cc:	003b68fa 	trap	3
811200d0:	df000215 	stw	fp,8(sp)
811200d4:	df000204 	addi	fp,sp,8
811200d8:	e13ffe15 	stw	r4,-8(fp)
811200dc:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
811200e0:	00800044 	movi	r2,1
}
811200e4:	e037883a 	mov	sp,fp
811200e8:	df000017 	ldw	fp,0(sp)
811200ec:	dec00104 	addi	sp,sp,4
811200f0:	f800283a 	ret

811200f4 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
811200f4:	deffe004 	addi	sp,sp,-128
811200f8:	de00012e 	bgeu	sp,et,81120100 <vLogWriteNUC+0xc>
811200fc:	003b68fa 	trap	3
81120100:	dfc01f15 	stw	ra,124(sp)
81120104:	df001e15 	stw	fp,120(sp)
81120108:	df001e04 	addi	fp,sp,120
8112010c:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
81120110:	e03fe215 	stw	zero,-120(fp)
81120114:	e0bfe304 	addi	r2,fp,-116
81120118:	00c01b84 	movi	r3,110
8112011c:	180d883a 	mov	r6,r3
81120120:	000b883a 	mov	r5,zero
81120124:	1009883a 	mov	r4,r2
81120128:	11244a00 	call	811244a0 <memset>
	memset(cTemp,0,114);
8112012c:	01801c84 	movi	r6,114
81120130:	000b883a 	mov	r5,zero
81120134:	e13fe204 	addi	r4,fp,-120
81120138:	11244a00 	call	811244a0 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
8112013c:	e13fff17 	ldw	r4,-4(fp)
81120140:	1124dc80 	call	81124dc8 <strlen>
81120144:	10801c68 	cmpgeui	r2,r2,113
81120148:	1000031e 	bne	r2,zero,81120158 <vLogWriteNUC+0x64>
8112014c:	e13fff17 	ldw	r4,-4(fp)
81120150:	1124dc80 	call	81124dc8 <strlen>
81120154:	00000106 	br	8112015c <vLogWriteNUC+0x68>
81120158:	00801c44 	movi	r2,113
8112015c:	100d883a 	mov	r6,r2
81120160:	e17fff17 	ldw	r5,-4(fp)
81120164:	e13fe204 	addi	r4,fp,-120
81120168:	11243500 	call	81124350 <memcpy>
	vSendLog ( cDataIn );
8112016c:	e13fff17 	ldw	r4,-4(fp)
81120170:	111a8bc0 	call	8111a8bc <vSendLog>
}
81120174:	0001883a 	nop
81120178:	e037883a 	mov	sp,fp
8112017c:	dfc00117 	ldw	ra,4(sp)
81120180:	df000017 	ldw	fp,0(sp)
81120184:	dec00204 	addi	sp,sp,8
81120188:	f800283a 	ret

8112018c <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
8112018c:	defffd04 	addi	sp,sp,-12
81120190:	de00012e 	bgeu	sp,et,81120198 <vSimucamStructureInit+0xc>
81120194:	003b68fa 	trap	3
81120198:	dfc00215 	stw	ra,8(sp)
8112019c:	df000115 	stw	fp,4(sp)
811201a0:	df000104 	addi	fp,sp,4
811201a4:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
811201a8:	e0bfff17 	ldw	r2,-4(fp)
811201ac:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
811201b0:	e0bfff17 	ldw	r2,-4(fp)
811201b4:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
811201b8:	e13fff17 	ldw	r4,-4(fp)
811201bc:	11202780 	call	81120278 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
811201c0:	e13fff17 	ldw	r4,-4(fp)
811201c4:	112031c0 	call	8112031c <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
811201c8:	e13fff17 	ldw	r4,-4(fp)
811201cc:	11203c40 	call	811203c4 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
811201d0:	e13fff17 	ldw	r4,-4(fp)
811201d4:	11204640 	call	81120464 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
811201d8:	e0bfff17 	ldw	r2,-4(fp)
811201dc:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
811201e0:	e0bfff17 	ldw	r2,-4(fp)
811201e4:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
811201e8:	e0bfff17 	ldw	r2,-4(fp)
811201ec:	00c07d04 	movi	r3,500
811201f0:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
811201f4:	e0bfff17 	ldw	r2,-4(fp)
811201f8:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
811201fc:	e0bfff17 	ldw	r2,-4(fp)
81120200:	00c00044 	movi	r3,1
81120204:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
81120208:	e0bfff17 	ldw	r2,-4(fp)
8112020c:	10c00204 	addi	r3,r2,8
81120210:	e0bfff17 	ldw	r2,-4(fp)
81120214:	10c0aa15 	stw	r3,680(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
81120218:	e0bfff17 	ldw	r2,-4(fp)
8112021c:	10c00244 	addi	r3,r2,9
81120220:	e0bfff17 	ldw	r2,-4(fp)
81120224:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
81120228:	e0bfff17 	ldw	r2,-4(fp)
8112022c:	10800017 	ldw	r2,0(r2)
81120230:	10000b1e 	bne	r2,zero,81120260 <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
81120234:	e0bfff17 	ldw	r2,-4(fp)
81120238:	10801204 	addi	r2,r2,72
8112023c:	1009883a 	mov	r4,r2
81120240:	111fe240 	call	8111fe24 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
81120244:	e0bfff17 	ldw	r2,-4(fp)
81120248:	10c00a04 	addi	r3,r2,40
8112024c:	e0bfff17 	ldw	r2,-4(fp)
81120250:	10801204 	addi	r2,r2,72
81120254:	100b883a 	mov	r5,r2
81120258:	1809883a 	mov	r4,r3
8112025c:	111cce80 	call	8111cce8 <vDataControllerInit>
        /* Are Fast Fee instances */
        /* todo: Not in use yet */
    }

    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */
}
81120260:	0001883a 	nop
81120264:	e037883a 	mov	sp,fp
81120268:	dfc00117 	ldw	ra,4(sp)
8112026c:	df000017 	ldw	fp,0(sp)
81120270:	dec00204 	addi	sp,sp,8
81120274:	f800283a 	ret

81120278 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
81120278:	defffe04 	addi	sp,sp,-8
8112027c:	de00012e 	bgeu	sp,et,81120284 <vLoadDefaultEPValue+0xc>
81120280:	003b68fa 	trap	3
81120284:	df000115 	stw	fp,4(sp)
81120288:	df000104 	addi	fp,sp,4
8112028c:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
81120290:	e0bfff17 	ldw	r2,-4(fp)
81120294:	00d07234 	movhi	r3,16840
81120298:	10c00315 	stw	r3,12(r2)
}
8112029c:	0001883a 	nop
811202a0:	e037883a 	mov	sp,fp
811202a4:	df000017 	ldw	fp,0(sp)
811202a8:	dec00104 	addi	sp,sp,4
811202ac:	f800283a 	ret

811202b0 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
811202b0:	defffd04 	addi	sp,sp,-12
811202b4:	de00012e 	bgeu	sp,et,811202bc <vChangeEPValue+0xc>
811202b8:	003b68fa 	trap	3
811202bc:	df000215 	stw	fp,8(sp)
811202c0:	df000204 	addi	fp,sp,8
811202c4:	e13ffe15 	stw	r4,-8(fp)
811202c8:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
811202cc:	e0bffe17 	ldw	r2,-8(fp)
811202d0:	e0ffff17 	ldw	r3,-4(fp)
811202d4:	10c00315 	stw	r3,12(r2)
}
811202d8:	0001883a 	nop
811202dc:	e037883a 	mov	sp,fp
811202e0:	df000017 	ldw	fp,0(sp)
811202e4:	dec00104 	addi	sp,sp,4
811202e8:	f800283a 	ret

811202ec <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
811202ec:	defffd04 	addi	sp,sp,-12
811202f0:	de00012e 	bgeu	sp,et,811202f8 <vChangeDefaultEPValue+0xc>
811202f4:	003b68fa 	trap	3
811202f8:	df000215 	stw	fp,8(sp)
811202fc:	df000204 	addi	fp,sp,8
81120300:	e13ffe15 	stw	r4,-8(fp)
81120304:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
81120308:	0001883a 	nop
8112030c:	e037883a 	mov	sp,fp
81120310:	df000017 	ldw	fp,0(sp)
81120314:	dec00104 	addi	sp,sp,4
81120318:	f800283a 	ret

8112031c <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
8112031c:	defffe04 	addi	sp,sp,-8
81120320:	de00012e 	bgeu	sp,et,81120328 <vLoadDefaultRTValue+0xc>
81120324:	003b68fa 	trap	3
81120328:	df000115 	stw	fp,4(sp)
8112032c:	df000104 	addi	fp,sp,4
81120330:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
81120334:	e0ffff17 	ldw	r3,-4(fp)
81120338:	00901eb4 	movhi	r2,16506
8112033c:	10a66684 	addi	r2,r2,-26214
81120340:	18800415 	stw	r2,16(r3)
}
81120344:	0001883a 	nop
81120348:	e037883a 	mov	sp,fp
8112034c:	df000017 	ldw	fp,0(sp)
81120350:	dec00104 	addi	sp,sp,4
81120354:	f800283a 	ret

81120358 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81120358:	defffd04 	addi	sp,sp,-12
8112035c:	de00012e 	bgeu	sp,et,81120364 <vChangeRTValue+0xc>
81120360:	003b68fa 	trap	3
81120364:	df000215 	stw	fp,8(sp)
81120368:	df000204 	addi	fp,sp,8
8112036c:	e13ffe15 	stw	r4,-8(fp)
81120370:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
81120374:	e0bffe17 	ldw	r2,-8(fp)
81120378:	e0ffff17 	ldw	r3,-4(fp)
8112037c:	10c00415 	stw	r3,16(r2)
}
81120380:	0001883a 	nop
81120384:	e037883a 	mov	sp,fp
81120388:	df000017 	ldw	fp,0(sp)
8112038c:	dec00104 	addi	sp,sp,4
81120390:	f800283a 	ret

81120394 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81120394:	defffd04 	addi	sp,sp,-12
81120398:	de00012e 	bgeu	sp,et,811203a0 <vChangeDefaultRTValue+0xc>
8112039c:	003b68fa 	trap	3
811203a0:	df000215 	stw	fp,8(sp)
811203a4:	df000204 	addi	fp,sp,8
811203a8:	e13ffe15 	stw	r4,-8(fp)
811203ac:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
811203b0:	0001883a 	nop
811203b4:	e037883a 	mov	sp,fp
811203b8:	df000017 	ldw	fp,0(sp)
811203bc:	dec00104 	addi	sp,sp,4
811203c0:	f800283a 	ret

811203c4 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
811203c4:	defffe04 	addi	sp,sp,-8
811203c8:	de00012e 	bgeu	sp,et,811203d0 <vLoadDefaultSyncSource+0xc>
811203cc:	003b68fa 	trap	3
811203d0:	df000115 	stw	fp,4(sp)
811203d4:	df000104 	addi	fp,sp,4
811203d8:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
811203dc:	e0bfff17 	ldw	r2,-4(fp)
811203e0:	10000815 	stw	zero,32(r2)
}
811203e4:	0001883a 	nop
811203e8:	e037883a 	mov	sp,fp
811203ec:	df000017 	ldw	fp,0(sp)
811203f0:	dec00104 	addi	sp,sp,4
811203f4:	f800283a 	ret

811203f8 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
811203f8:	defffd04 	addi	sp,sp,-12
811203fc:	de00012e 	bgeu	sp,et,81120404 <vChangeSyncSource+0xc>
81120400:	003b68fa 	trap	3
81120404:	df000215 	stw	fp,8(sp)
81120408:	df000204 	addi	fp,sp,8
8112040c:	e13ffe15 	stw	r4,-8(fp)
81120410:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
81120414:	e0bffe17 	ldw	r2,-8(fp)
81120418:	e0ffff17 	ldw	r3,-4(fp)
8112041c:	10c00815 	stw	r3,32(r2)
}
81120420:	0001883a 	nop
81120424:	e037883a 	mov	sp,fp
81120428:	df000017 	ldw	fp,0(sp)
8112042c:	dec00104 	addi	sp,sp,4
81120430:	f800283a 	ret

81120434 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
81120434:	defffd04 	addi	sp,sp,-12
81120438:	de00012e 	bgeu	sp,et,81120440 <vChangeDefaultSyncSource+0xc>
8112043c:	003b68fa 	trap	3
81120440:	df000215 	stw	fp,8(sp)
81120444:	df000204 	addi	fp,sp,8
81120448:	e13ffe15 	stw	r4,-8(fp)
8112044c:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
81120450:	0001883a 	nop
81120454:	e037883a 	mov	sp,fp
81120458:	df000017 	ldw	fp,0(sp)
8112045c:	dec00104 	addi	sp,sp,4
81120460:	f800283a 	ret

81120464 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
81120464:	defffe04 	addi	sp,sp,-8
81120468:	de00012e 	bgeu	sp,et,81120470 <vLoadDefaultAutoResetSync+0xc>
8112046c:	003b68fa 	trap	3
81120470:	df000115 	stw	fp,4(sp)
81120474:	df000104 	addi	fp,sp,4
81120478:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
8112047c:	e0bfff17 	ldw	r2,-4(fp)
81120480:	00c00044 	movi	r3,1
81120484:	10c00915 	stw	r3,36(r2)
}
81120488:	0001883a 	nop
8112048c:	e037883a 	mov	sp,fp
81120490:	df000017 	ldw	fp,0(sp)
81120494:	dec00104 	addi	sp,sp,4
81120498:	f800283a 	ret

8112049c <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8112049c:	defffd04 	addi	sp,sp,-12
811204a0:	de00012e 	bgeu	sp,et,811204a8 <vChangeAutoResetSync+0xc>
811204a4:	003b68fa 	trap	3
811204a8:	df000215 	stw	fp,8(sp)
811204ac:	df000204 	addi	fp,sp,8
811204b0:	e13ffe15 	stw	r4,-8(fp)
811204b4:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
811204b8:	e0bffe17 	ldw	r2,-8(fp)
811204bc:	e0ffff17 	ldw	r3,-4(fp)
811204c0:	10c00915 	stw	r3,36(r2)
}
811204c4:	0001883a 	nop
811204c8:	e037883a 	mov	sp,fp
811204cc:	df000017 	ldw	fp,0(sp)
811204d0:	dec00104 	addi	sp,sp,4
811204d4:	f800283a 	ret

811204d8 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
811204d8:	defffd04 	addi	sp,sp,-12
811204dc:	de00012e 	bgeu	sp,et,811204e4 <vChangeDefaultAutoResetSync+0xc>
811204e0:	003b68fa 	trap	3
811204e4:	df000215 	stw	fp,8(sp)
811204e8:	df000204 	addi	fp,sp,8
811204ec:	e13ffe15 	stw	r4,-8(fp)
811204f0:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
811204f4:	0001883a 	nop
811204f8:	e037883a 	mov	sp,fp
811204fc:	df000017 	ldw	fp,0(sp)
81120500:	dec00104 	addi	sp,sp,4
81120504:	f800283a 	ret

81120508 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
81120508:	defffc04 	addi	sp,sp,-16
8112050c:	de00012e 	bgeu	sp,et,81120514 <vSyncReset+0xc>
81120510:	003b68fa 	trap	3
81120514:	dfc00315 	stw	ra,12(sp)
81120518:	df000215 	stw	fp,8(sp)
8112051c:	df000204 	addi	fp,sp,8
81120520:	e13ffe15 	stw	r4,-8(fp)
81120524:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
81120528:	e0bffe17 	ldw	r2,-8(fp)
8112052c:	10801204 	addi	r2,r2,72
81120530:	1009883a 	mov	r4,r2
81120534:	111ff700 	call	8111ff70 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
81120538:	0001883a 	nop
8112053c:	e037883a 	mov	sp,fp
81120540:	dfc00117 	ldw	ra,4(sp)
81120544:	df000017 	ldw	fp,0(sp)
81120548:	dec00204 	addi	sp,sp,8
8112054c:	f800283a 	ret

81120550 <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
81120550:	defff004 	addi	sp,sp,-64
81120554:	de00012e 	bgeu	sp,et,8112055c <pattern_createPattern+0xc>
81120558:	003b68fa 	trap	3
8112055c:	dfc00f15 	stw	ra,60(sp)
81120560:	df000e15 	stw	fp,56(sp)
81120564:	dcc00d15 	stw	r19,52(sp)
81120568:	dc800c15 	stw	r18,48(sp)
8112056c:	dc400b15 	stw	r17,44(sp)
81120570:	dc000a15 	stw	r16,40(sp)
81120574:	df000e04 	addi	fp,sp,56
81120578:	e17ff915 	stw	r5,-28(fp)
8112057c:	3007883a 	mov	r3,r6
81120580:	3805883a 	mov	r2,r7
81120584:	e13ff805 	stb	r4,-32(fp)
81120588:	e0fffa05 	stb	r3,-24(fp)
8112058c:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
81120590:	e0bff803 	ldbu	r2,-32(fp)
81120594:	1009883a 	mov	r4,r2
81120598:	11014e00 	call	811014e0 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
8112059c:	e0bff917 	ldw	r2,-28(fp)
811205a0:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
811205a4:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
811205a8:	e0bff217 	ldw	r2,-56(fp)
811205ac:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
811205b0:	e03ff515 	stw	zero,-44(fp)
811205b4:	00003606 	br	81120690 <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
811205b8:	e03ff615 	stw	zero,-40(fp)
811205bc:	00002e06 	br	81120678 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
811205c0:	e0bff303 	ldbu	r2,-52(fp)
811205c4:	10801018 	cmpnei	r2,r2,64
811205c8:	10000b1e 	bne	r2,zero,811205f8 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
811205cc:	e0bff417 	ldw	r2,-48(fp)
811205d0:	00ffffc4 	movi	r3,-1
811205d4:	10c02015 	stw	r3,128(r2)
811205d8:	00ffffc4 	movi	r3,-1
811205dc:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
811205e0:	e0bff217 	ldw	r2,-56(fp)
811205e4:	10802204 	addi	r2,r2,136
811205e8:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
811205ec:	e0bff217 	ldw	r2,-56(fp)
811205f0:	e0bff415 	stw	r2,-48(fp)
				i = 0;
811205f4:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
811205f8:	e0bff303 	ldbu	r2,-52(fp)
811205fc:	10c00044 	addi	r3,r2,1
81120600:	e0fff305 	stb	r3,-52(fp)
81120604:	10803fcc 	andi	r2,r2,255
81120608:	e0fffa03 	ldbu	r3,-24(fp)
8112060c:	18c000cc 	andi	r3,r3,3
81120610:	180692fa 	slli	r3,r3,11
81120614:	1809883a 	mov	r4,r3
81120618:	00f80004 	movi	r3,-8192
8112061c:	20c6b03a 	or	r3,r4,r3
81120620:	1809883a 	mov	r4,r3
81120624:	e0fffb03 	ldbu	r3,-20(fp)
81120628:	18c0004c 	andi	r3,r3,1
8112062c:	180692ba 	slli	r3,r3,10
81120630:	20c6b03a 	or	r3,r4,r3
81120634:	1809883a 	mov	r4,r3
81120638:	e0fff517 	ldw	r3,-44(fp)
8112063c:	18c007cc 	andi	r3,r3,31
81120640:	1806917a 	slli	r3,r3,5
81120644:	20c6b03a 	or	r3,r4,r3
81120648:	1809883a 	mov	r4,r3
8112064c:	e0fff617 	ldw	r3,-40(fp)
81120650:	18c007cc 	andi	r3,r3,31
81120654:	20c6b03a 	or	r3,r4,r3
81120658:	1809883a 	mov	r4,r3
8112065c:	e0fff417 	ldw	r3,-48(fp)
81120660:	1085883a 	add	r2,r2,r2
81120664:	1885883a 	add	r2,r3,r2
81120668:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8112066c:	e0bff617 	ldw	r2,-40(fp)
81120670:	10800044 	addi	r2,r2,1
81120674:	e0bff615 	stw	r2,-40(fp)
81120678:	e0fff617 	ldw	r3,-40(fp)
8112067c:	e0800217 	ldw	r2,8(fp)
81120680:	18bfcf36 	bltu	r3,r2,811205c0 <__reset+0xfb1005c0>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
81120684:	e0bff517 	ldw	r2,-44(fp)
81120688:	10800044 	addi	r2,r2,1
8112068c:	e0bff515 	stw	r2,-44(fp)
81120690:	e0fff517 	ldw	r3,-44(fp)
81120694:	e0800317 	ldw	r2,12(fp)
81120698:	18bfc736 	bltu	r3,r2,811205b8 <__reset+0xfb1005b8>
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
8112069c:	e0bff417 	ldw	r2,-48(fp)
811206a0:	10002015 	stw	zero,128(r2)
811206a4:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
811206a8:	e03ff705 	stb	zero,-36(fp)
811206ac:	00001c06 	br	81120720 <pattern_createPattern+0x1d0>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
811206b0:	e13ff417 	ldw	r4,-48(fp)
811206b4:	20802017 	ldw	r2,128(r4)
811206b8:	20c02117 	ldw	r3,132(r4)
811206bc:	e13ff703 	ldbu	r4,-36(fp)
811206c0:	217ff804 	addi	r5,r4,-32
811206c4:	28000416 	blt	r5,zero,811206d8 <pattern_createPattern+0x188>
811206c8:	01200034 	movhi	r4,32768
811206cc:	2160d83a 	srl	r16,r4,r5
811206d0:	0023883a 	mov	r17,zero
811206d4:	00000a06 	br	81120700 <pattern_createPattern+0x1b0>
811206d8:	01600034 	movhi	r5,32768
811206dc:	280c907a 	slli	r6,r5,1
811206e0:	014007c4 	movi	r5,31
811206e4:	290bc83a 	sub	r5,r5,r4
811206e8:	314a983a 	sll	r5,r6,r5
811206ec:	000d883a 	mov	r6,zero
811206f0:	3120d83a 	srl	r16,r6,r4
811206f4:	2c20b03a 	or	r16,r5,r16
811206f8:	01600034 	movhi	r5,32768
811206fc:	2922d83a 	srl	r17,r5,r4
81120700:	1424b03a 	or	r18,r2,r16
81120704:	1c66b03a 	or	r19,r3,r17
81120708:	e0bff417 	ldw	r2,-48(fp)
8112070c:	14802015 	stw	r18,128(r2)
81120710:	14c02115 	stw	r19,132(r2)
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
81120714:	e0bff703 	ldbu	r2,-36(fp)
81120718:	10800044 	addi	r2,r2,1
8112071c:	e0bff705 	stb	r2,-36(fp)
81120720:	e0fff703 	ldbu	r3,-36(fp)
81120724:	e0bff303 	ldbu	r2,-52(fp)
81120728:	18bfe136 	bltu	r3,r2,811206b0 <__reset+0xfb1006b0>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
	}

	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
8112072c:	e0bff217 	ldw	r2,-56(fp)
81120730:	10802204 	addi	r2,r2,136
81120734:	e0bff215 	stw	r2,-56(fp)
	return offset;
81120738:	e0bff217 	ldw	r2,-56(fp)
}
8112073c:	e6fffc04 	addi	sp,fp,-16
81120740:	dfc00517 	ldw	ra,20(sp)
81120744:	df000417 	ldw	fp,16(sp)
81120748:	dcc00317 	ldw	r19,12(sp)
8112074c:	dc800217 	ldw	r18,8(sp)
81120750:	dc400117 	ldw	r17,4(sp)
81120754:	dc000017 	ldw	r16,0(sp)
81120758:	dec00604 	addi	sp,sp,24
8112075c:	f800283a 	ret

81120760 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
81120760:	defffe04 	addi	sp,sp,-8
81120764:	de00012e 	bgeu	sp,et,8112076c <bSDcardIsPresent+0xc>
81120768:	003b68fa 	trap	3
8112076c:	dfc00115 	stw	ra,4(sp)
81120770:	df000015 	stw	fp,0(sp)
81120774:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
81120778:	1146b9c0 	call	81146b9c <alt_up_sd_card_is_Present>
}
8112077c:	e037883a 	mov	sp,fp
81120780:	dfc00117 	ldw	ra,4(sp)
81120784:	df000017 	ldw	fp,0(sp)
81120788:	dec00204 	addi	sp,sp,8
8112078c:	f800283a 	ret

81120790 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
81120790:	defffe04 	addi	sp,sp,-8
81120794:	de00012e 	bgeu	sp,et,8112079c <bSDcardFAT16Check+0xc>
81120798:	003b68fa 	trap	3
8112079c:	dfc00115 	stw	ra,4(sp)
811207a0:	df000015 	stw	fp,0(sp)
811207a4:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
811207a8:	1146c680 	call	81146c68 <alt_up_sd_card_is_FAT16>
}
811207ac:	e037883a 	mov	sp,fp
811207b0:	dfc00117 	ldw	ra,4(sp)
811207b4:	df000017 	ldw	fp,0(sp)
811207b8:	dec00204 	addi	sp,sp,8
811207bc:	f800283a 	ret

811207c0 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
811207c0:	defffd04 	addi	sp,sp,-12
811207c4:	de00012e 	bgeu	sp,et,811207cc <bInitializeSDCard+0xc>
811207c8:	003b68fa 	trap	3
811207cc:	dfc00215 	stw	ra,8(sp)
811207d0:	df000115 	stw	fp,4(sp)
811207d4:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
811207d8:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
811207dc:	d0207715 	stw	zero,-32292(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
811207e0:	01204574 	movhi	r4,33045
811207e4:	21085904 	addi	r4,r4,8548
811207e8:	1146ad80 	call	81146ad8 <alt_up_sd_card_open_dev>
811207ec:	d0a07715 	stw	r2,-32292(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
811207f0:	d0a07717 	ldw	r2,-32292(gp)
811207f4:	10002226 	beq	r2,zero,81120880 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
811207f8:	11207600 	call	81120760 <bSDcardIsPresent>
811207fc:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
81120800:	e0bfff17 	ldw	r2,-4(fp)
81120804:	10001626 	beq	r2,zero,81120860 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
81120808:	11207900 	call	81120790 <bSDcardFAT16Check>
8112080c:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
81120810:	e0bfff17 	ldw	r2,-4(fp)
81120814:	10000a26 	beq	r2,zero,81120840 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
81120818:	00800044 	movi	r2,1
8112081c:	d0a07615 	stw	r2,-32296(gp)
				#if DEBUG_ON
					debug(fp, "SD is up.\r\n");
81120820:	d0a06217 	ldw	r2,-32376(gp)
81120824:	100f883a 	mov	r7,r2
81120828:	018002c4 	movi	r6,11
8112082c:	01400044 	movi	r5,1
81120830:	01204574 	movhi	r4,33045
81120834:	21086404 	addi	r4,r4,8592
81120838:	112393c0 	call	8112393c <fwrite>
8112083c:	00001806 	br	811208a0 <bInitializeSDCard+0xe0>
				#endif

			} else {
				/* SD isn't in FAT16 format*/
				#if DEBUG_ON
					debug(fp, "SD Card should be formated in FAT16.\r\n");
81120840:	d0a06217 	ldw	r2,-32376(gp)
81120844:	100f883a 	mov	r7,r2
81120848:	01800984 	movi	r6,38
8112084c:	01400044 	movi	r5,1
81120850:	01204574 	movhi	r4,33045
81120854:	21086704 	addi	r4,r4,8604
81120858:	112393c0 	call	8112393c <fwrite>
8112085c:	00001006 	br	811208a0 <bInitializeSDCard+0xe0>
				#endif
			}
		} else {
			/* There's no SDCard in the slot */
			#if DEBUG_ON
				debug(fp, "There is no SD in the slot.\r\n");
81120860:	d0a06217 	ldw	r2,-32376(gp)
81120864:	100f883a 	mov	r7,r2
81120868:	01800744 	movi	r6,29
8112086c:	01400044 	movi	r5,1
81120870:	01204574 	movhi	r4,33045
81120874:	21087104 	addi	r4,r4,8644
81120878:	112393c0 	call	8112393c <fwrite>
8112087c:	00000806 	br	811208a0 <bInitializeSDCard+0xe0>
			#endif
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
81120880:	e03fff15 	stw	zero,-4(fp)
		#if DEBUG_ON
			debug(fp, "Unable to open the SDCard device.\r\n");
81120884:	d0a06217 	ldw	r2,-32376(gp)
81120888:	100f883a 	mov	r7,r2
8112088c:	018008c4 	movi	r6,35
81120890:	01400044 	movi	r5,1
81120894:	01204574 	movhi	r4,33045
81120898:	21087904 	addi	r4,r4,8676
8112089c:	112393c0 	call	8112393c <fwrite>
		#endif
	}

	return bSucess;
811208a0:	e0bfff17 	ldw	r2,-4(fp)
}
811208a4:	e037883a 	mov	sp,fp
811208a8:	dfc00117 	ldw	ra,4(sp)
811208ac:	df000017 	ldw	fp,0(sp)
811208b0:	dec00204 	addi	sp,sp,8
811208b4:	f800283a 	ret

811208b8 <siOpenFile>:

short int siOpenFile( char *filename ) {
811208b8:	defffd04 	addi	sp,sp,-12
811208bc:	de00012e 	bgeu	sp,et,811208c4 <siOpenFile+0xc>
811208c0:	003b68fa 	trap	3
811208c4:	dfc00215 	stw	ra,8(sp)
811208c8:	df000115 	stw	fp,4(sp)
811208cc:	df000104 	addi	fp,sp,4
811208d0:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
811208d4:	000b883a 	mov	r5,zero
811208d8:	e13fff17 	ldw	r4,-4(fp)
811208dc:	11471740 	call	81147174 <alt_up_sd_card_fopen>
}
811208e0:	e037883a 	mov	sp,fp
811208e4:	dfc00117 	ldw	ra,4(sp)
811208e8:	df000017 	ldw	fp,0(sp)
811208ec:	dec00204 	addi	sp,sp,8
811208f0:	f800283a 	ret

811208f4 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
811208f4:	defffd04 	addi	sp,sp,-12
811208f8:	de00012e 	bgeu	sp,et,81120900 <siCloseFile+0xc>
811208fc:	003b68fa 	trap	3
81120900:	dfc00215 	stw	ra,8(sp)
81120904:	df000115 	stw	fp,4(sp)
81120908:	df000104 	addi	fp,sp,4
8112090c:	2005883a 	mov	r2,r4
81120910:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
81120914:	e0bfff0f 	ldh	r2,-4(fp)
81120918:	1009883a 	mov	r4,r2
8112091c:	1147fc00 	call	81147fc0 <alt_up_sd_card_fclose>
}
81120920:	e037883a 	mov	sp,fp
81120924:	dfc00117 	ldw	ra,4(sp)
81120928:	df000017 	ldw	fp,0(sp)
8112092c:	dec00204 	addi	sp,sp,8
81120930:	f800283a 	ret

81120934 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
81120934:	defffd04 	addi	sp,sp,-12
81120938:	de00012e 	bgeu	sp,et,81120940 <cGetNextChar+0xc>
8112093c:	003b68fa 	trap	3
81120940:	dfc00215 	stw	ra,8(sp)
81120944:	df000115 	stw	fp,4(sp)
81120948:	df000104 	addi	fp,sp,4
8112094c:	2005883a 	mov	r2,r4
81120950:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
81120954:	e0bfff0f 	ldh	r2,-4(fp)
81120958:	1009883a 	mov	r4,r2
8112095c:	11476180 	call	81147618 <alt_up_sd_card_read>
}
81120960:	e037883a 	mov	sp,fp
81120964:	dfc00117 	ldw	ra,4(sp)
81120968:	df000017 	ldw	fp,0(sp)
8112096c:	dec00204 	addi	sp,sp,8
81120970:	f800283a 	ret

81120974 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
81120974:	defffd04 	addi	sp,sp,-12
81120978:	de00012e 	bgeu	sp,et,81120980 <bInitSync+0xc>
8112097c:	003b68fa 	trap	3
81120980:	dfc00215 	stw	ra,8(sp)
81120984:	df000115 	stw	fp,4(sp)
81120988:	df000104 	addi	fp,sp,4
	bool	bSuccess;

	vSyncInitIrq();
8112098c:	110d2080 	call	8110d208 <vSyncInitIrq>

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81120990:	00a045f4 	movhi	r2,33047
81120994:	10a25304 	addi	r2,r2,-30388
81120998:	10800a8b 	ldhu	r2,42(r2)
8112099c:	10bfffcc 	andi	r2,r2,65535
811209a0:	108000e8 	cmpgeui	r2,r2,3
811209a4:	1000071e 	bne	r2,zero,811209c4 <bInitSync+0x50>
		debug(fp, "Initializing Sync Module.\n");
811209a8:	d0a06217 	ldw	r2,-32376(gp)
811209ac:	100f883a 	mov	r7,r2
811209b0:	01800684 	movi	r6,26
811209b4:	01400044 	movi	r5,1
811209b8:	01204574 	movhi	r4,33045
811209bc:	21088204 	addi	r4,r4,8712
811209c0:	112393c0 	call	8112393c <fwrite>
	}
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
811209c4:	01004c74 	movhi	r4,305
811209c8:	210b4004 	addi	r4,r4,11520
811209cc:	110d4100 	call	8110d410 <bSyncSetMbt>
811209d0:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
811209d4:	e0bfff17 	ldw	r2,-4(fp)
811209d8:	1000021e 	bne	r2,zero,811209e4 <bInitSync+0x70>
		return bSuccess;
811209dc:	e0bfff17 	ldw	r2,-4(fp)
811209e0:	00004d06 	br	81120b18 <bInitSync+0x1a4>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
811209e4:	01002674 	movhi	r4,153
811209e8:	2125a004 	addi	r4,r4,-27008
811209ec:	110d4500 	call	8110d450 <bSyncSetBt>
811209f0:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
811209f4:	e0bfff17 	ldw	r2,-4(fp)
811209f8:	1000021e 	bne	r2,zero,81120a04 <bInitSync+0x90>
		return bSuccess;
811209fc:	e0bfff17 	ldw	r2,-4(fp)
81120a00:	00004506 	br	81120b18 <bInitSync+0x1a4>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer(  uliPerCalcPeriodMs( xDefaults.usiSyncPeriod ) );
81120a04:	00a045f4 	movhi	r2,33047
81120a08:	10a25304 	addi	r2,r2,-30388
81120a0c:	1080038b 	ldhu	r2,14(r2)
81120a10:	10bfffcc 	andi	r2,r2,65535
81120a14:	1009883a 	mov	r4,r2
81120a18:	110e0e80 	call	8110e0e8 <uliPerCalcPeriodMs>
81120a1c:	1009883a 	mov	r4,r2
81120a20:	110d4900 	call	8110d490 <bSyncSetPer>
81120a24:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120a28:	e0bfff17 	ldw	r2,-4(fp)
81120a2c:	1000021e 	bne	r2,zero,81120a38 <bInitSync+0xc4>
		return bSuccess;
81120a30:	e0bfff17 	ldw	r2,-4(fp)
81120a34:	00003806 	br	81120b18 <bInitSync+0x1a4>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
81120a38:	01005f74 	movhi	r4,381
81120a3c:	211e1004 	addi	r4,r4,30784
81120a40:	110d4d00 	call	8110d4d0 <bSyncSetOst>
81120a44:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120a48:	e0bfff17 	ldw	r2,-4(fp)
81120a4c:	1000021e 	bne	r2,zero,81120a58 <bInitSync+0xe4>
		return bSuccess;
81120a50:	e0bfff17 	ldw	r2,-4(fp)
81120a54:	00003006 	br	81120b18 <bInitSync+0x1a4>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
81120a58:	0009883a 	mov	r4,zero
81120a5c:	110d5100 	call	8110d510 <bSyncSetPolarity>
81120a60:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120a64:	e0bfff17 	ldw	r2,-4(fp)
81120a68:	1000021e 	bne	r2,zero,81120a74 <bInitSync+0x100>
		return bSuccess;
81120a6c:	e0bfff17 	ldw	r2,-4(fp)
81120a70:	00002906 	br	81120b18 <bInitSync+0x1a4>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
81120a74:	01000104 	movi	r4,4
81120a78:	110d5840 	call	8110d584 <bSyncSetNCycles>
81120a7c:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120a80:	e0bfff17 	ldw	r2,-4(fp)
81120a84:	1000021e 	bne	r2,zero,81120a90 <bInitSync+0x11c>
		return bSuccess;
81120a88:	e0bfff17 	ldw	r2,-4(fp)
81120a8c:	00002206 	br	81120b18 <bInitSync+0x1a4>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
81120a90:	01000044 	movi	r4,1
81120a94:	110d7600 	call	8110d760 <bSyncCtrExtnIrq>
81120a98:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120a9c:	e0bfff17 	ldw	r2,-4(fp)
81120aa0:	1000021e 	bne	r2,zero,81120aac <bInitSync+0x138>
		return bSuccess;
81120aa4:	e0bfff17 	ldw	r2,-4(fp)
81120aa8:	00001b06 	br	81120b18 <bInitSync+0x1a4>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
81120aac:	01000044 	movi	r4,1
81120ab0:	110d9280 	call	8110d928 <bSyncCtrSyncOutEnable>
81120ab4:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120ab8:	e0bfff17 	ldw	r2,-4(fp)
81120abc:	1000021e 	bne	r2,zero,81120ac8 <bInitSync+0x154>
		return bSuccess;
81120ac0:	e0bfff17 	ldw	r2,-4(fp)
81120ac4:	00001406 	br	81120b18 <bInitSync+0x1a4>
	}


	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
81120ac8:	01000044 	movi	r4,1
81120acc:	110d99c0 	call	8110d99c <bSyncCtrCh1OutEnable>
81120ad0:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120ad4:	e0bfff17 	ldw	r2,-4(fp)
81120ad8:	1000021e 	bne	r2,zero,81120ae4 <bInitSync+0x170>
		return bSuccess;
81120adc:	e0bfff17 	ldw	r2,-4(fp)
81120ae0:	00000d06 	br	81120b18 <bInitSync+0x1a4>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh2OutEnable(TRUE);
81120ae4:	01000044 	movi	r4,1
81120ae8:	110da100 	call	8110da10 <bSyncCtrCh2OutEnable>
81120aec:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120af0:	e0bfff17 	ldw	r2,-4(fp)
81120af4:	1000021e 	bne	r2,zero,81120b00 <bInitSync+0x18c>
		return bSuccess;
81120af8:	e0bfff17 	ldw	r2,-4(fp)
81120afc:	00000606 	br	81120b18 <bInitSync+0x1a4>
	}

	bSuccess = bSyncCtrStart();
81120b00:	110d7d80 	call	8110d7d8 <bSyncCtrStart>
81120b04:	e0bfff15 	stw	r2,-4(fp)
	bSyncCtrReset();
81120b08:	110d82c0 	call	8110d82c <bSyncCtrReset>
	bSyncIrqEnableBlank(TRUE);
81120b0c:	01000044 	movi	r4,1
81120b10:	110ddb00 	call	8110ddb0 <bSyncIrqEnableBlank>


	return bSuccess;
81120b14:	e0bfff17 	ldw	r2,-4(fp)
}
81120b18:	e037883a 	mov	sp,fp
81120b1c:	dfc00117 	ldw	ra,4(sp)
81120b20:	df000017 	ldw	fp,0(sp)
81120b24:	dec00204 	addi	sp,sp,8
81120b28:	f800283a 	ret

81120b2c <bStartSync>:


bool bStartSync(void) {
81120b2c:	defffd04 	addi	sp,sp,-12
81120b30:	de00012e 	bgeu	sp,et,81120b38 <bStartSync+0xc>
81120b34:	003b68fa 	trap	3
81120b38:	dfc00215 	stw	ra,8(sp)
81120b3c:	df000115 	stw	fp,4(sp)
81120b40:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSyncCtrReset();
81120b44:	110d82c0 	call	8110d82c <bSyncCtrReset>
	bSuccess = bSyncCtrStart();
81120b48:	110d7d80 	call	8110d7d8 <bSyncCtrStart>
81120b4c:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
81120b50:	e0bfff17 	ldw	r2,-4(fp)
}
81120b54:	e037883a 	mov	sp,fp
81120b58:	dfc00117 	ldw	ra,4(sp)
81120b5c:	df000017 	ldw	fp,0(sp)
81120b60:	dec00204 	addi	sp,sp,8
81120b64:	f800283a 	ret

81120b68 <bStopSync>:

bool bStopSync(void) {
81120b68:	defffe04 	addi	sp,sp,-8
81120b6c:	de00012e 	bgeu	sp,et,81120b74 <bStopSync+0xc>
81120b70:	003b68fa 	trap	3
81120b74:	dfc00115 	stw	ra,4(sp)
81120b78:	df000015 	stw	fp,0(sp)
81120b7c:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
81120b80:	110d82c0 	call	8110d82c <bSyncCtrReset>
}
81120b84:	e037883a 	mov	sp,fp
81120b88:	dfc00117 	ldw	ra,4(sp)
81120b8c:	df000017 	ldw	fp,0(sp)
81120b90:	dec00204 	addi	sp,sp,8
81120b94:	f800283a 	ret

81120b98 <bClearCounterSync>:

void bClearCounterSync(void) {
81120b98:	defffe04 	addi	sp,sp,-8
81120b9c:	de00012e 	bgeu	sp,et,81120ba4 <bClearCounterSync+0xc>
81120ba0:	003b68fa 	trap	3
81120ba4:	dfc00115 	stw	ra,4(sp)
81120ba8:	df000015 	stw	fp,0(sp)
81120bac:	d839883a 	mov	fp,sp
	vSyncClearCounter();
81120bb0:	110d1dc0 	call	8110d1dc <vSyncClearCounter>
}
81120bb4:	0001883a 	nop
81120bb8:	e037883a 	mov	sp,fp
81120bbc:	dfc00117 	ldw	ra,4(sp)
81120bc0:	df000017 	ldw	fp,0(sp)
81120bc4:	dec00204 	addi	sp,sp,8
81120bc8:	f800283a 	ret

81120bcc <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
81120bcc:	defffd04 	addi	sp,sp,-12
81120bd0:	de00012e 	bgeu	sp,et,81120bd8 <bTestSimucamCriticalHW+0xc>
81120bd4:	003b68fa 	trap	3
81120bd8:	dfc00215 	stw	ra,8(sp)
81120bdc:	df000115 	stw	fp,4(sp)
81120be0:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
81120be4:	1103b840 	call	81103b84 <bSdmaInitM1Dma>
81120be8:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
81120bec:	e0bfff17 	ldw	r2,-4(fp)
81120bf0:	1000021e 	bne	r2,zero,81120bfc <bTestSimucamCriticalHW+0x30>
		return bSuccess;
81120bf4:	e0bfff17 	ldw	r2,-4(fp)
81120bf8:	00000706 	br	81120c18 <bTestSimucamCriticalHW+0x4c>
	}

	bSuccess = bSdmaInitM2Dma();
81120bfc:	1103c400 	call	81103c40 <bSdmaInitM2Dma>
81120c00:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
81120c04:	e0bfff17 	ldw	r2,-4(fp)
81120c08:	1000021e 	bne	r2,zero,81120c14 <bTestSimucamCriticalHW+0x48>
		return bSuccess;
81120c0c:	e0bfff17 	ldw	r2,-4(fp)
81120c10:	00000106 	br	81120c18 <bTestSimucamCriticalHW+0x4c>

	//xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
	//xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;


	return TRUE;
81120c14:	00800044 	movi	r2,1
}
81120c18:	e037883a 	mov	sp,fp
81120c1c:	dfc00117 	ldw	ra,4(sp)
81120c20:	df000017 	ldw	fp,0(sp)
81120c24:	dec00204 	addi	sp,sp,8
81120c28:	f800283a 	ret

81120c2c <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
81120c2c:	defffc04 	addi	sp,sp,-16
81120c30:	de00012e 	bgeu	sp,et,81120c38 <_reg_write+0xc>
81120c34:	003b68fa 	trap	3
81120c38:	df000315 	stw	fp,12(sp)
81120c3c:	df000304 	addi	fp,sp,12
81120c40:	e13ffd15 	stw	r4,-12(fp)
81120c44:	e17ffe15 	stw	r5,-8(fp)
81120c48:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
81120c4c:	e0bffe17 	ldw	r2,-8(fp)
81120c50:	1085883a 	add	r2,r2,r2
81120c54:	1085883a 	add	r2,r2,r2
81120c58:	1007883a 	mov	r3,r2
81120c5c:	e0bffd17 	ldw	r2,-12(fp)
81120c60:	1885883a 	add	r2,r3,r2
81120c64:	1007883a 	mov	r3,r2
81120c68:	e0bfff17 	ldw	r2,-4(fp)
81120c6c:	18800035 	stwio	r2,0(r3)
	return 1;
81120c70:	00800044 	movi	r2,1

}
81120c74:	e037883a 	mov	sp,fp
81120c78:	df000017 	ldw	fp,0(sp)
81120c7c:	dec00104 	addi	sp,sp,4
81120c80:	f800283a 	ret

81120c84 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
81120c84:	defffc04 	addi	sp,sp,-16
81120c88:	de00012e 	bgeu	sp,et,81120c90 <_reg_read+0xc>
81120c8c:	003b68fa 	trap	3
81120c90:	df000315 	stw	fp,12(sp)
81120c94:	df000304 	addi	fp,sp,12
81120c98:	e13ffd15 	stw	r4,-12(fp)
81120c9c:	e17ffe15 	stw	r5,-8(fp)
81120ca0:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
81120ca4:	e0bffe17 	ldw	r2,-8(fp)
81120ca8:	1085883a 	add	r2,r2,r2
81120cac:	1085883a 	add	r2,r2,r2
81120cb0:	1007883a 	mov	r3,r2
81120cb4:	e0bffd17 	ldw	r2,-12(fp)
81120cb8:	1885883a 	add	r2,r3,r2
81120cbc:	10c00037 	ldwio	r3,0(r2)
81120cc0:	e0bfff17 	ldw	r2,-4(fp)
81120cc4:	10c00015 	stw	r3,0(r2)
	return 1;
81120cc8:	00800044 	movi	r2,1

}
81120ccc:	e037883a 	mov	sp,fp
81120cd0:	df000017 	ldw	fp,0(sp)
81120cd4:	dec00104 	addi	sp,sp,4
81120cd8:	f800283a 	ret

81120cdc <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
81120cdc:	defffa04 	addi	sp,sp,-24
81120ce0:	de00012e 	bgeu	sp,et,81120ce8 <_print_codec_status+0xc>
81120ce4:	003b68fa 	trap	3
81120ce8:	dfc00515 	stw	ra,20(sp)
81120cec:	df000415 	stw	fp,16(sp)
81120cf0:	df000404 	addi	fp,sp,16
81120cf4:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
81120cf8:	e0bfff17 	ldw	r2,-4(fp)
81120cfc:	1005d1ba 	srai	r2,r2,6
81120d00:	1080004c 	andi	r2,r2,1
81120d04:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
81120d08:	e0bfff17 	ldw	r2,-4(fp)
81120d0c:	1005d17a 	srai	r2,r2,5
81120d10:	1080004c 	andi	r2,r2,1
81120d14:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
81120d18:	e0bfff17 	ldw	r2,-4(fp)
81120d1c:	1005d13a 	srai	r2,r2,4
81120d20:	1080004c 	andi	r2,r2,1
81120d24:	e0bffe15 	stw	r2,-8(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81120d28:	00a045f4 	movhi	r2,33047
81120d2c:	10a25304 	addi	r2,r2,-30388
81120d30:	10800a8b 	ldhu	r2,42(r2)
81120d34:	10bfffcc 	andi	r2,r2,65535
81120d38:	108000e8 	cmpgeui	r2,r2,3
81120d3c:	1000661e 	bne	r2,zero,81120ed8 <_print_codec_status+0x1fc>
		sprintf(cDebugBuffer, "-------- link status \n");
81120d40:	00e04574 	movhi	r3,33045
81120d44:	18d46d04 	addi	r3,r3,20916
81120d48:	00a04574 	movhi	r2,33045
81120d4c:	10888904 	addi	r2,r2,8740
81120d50:	1009883a 	mov	r4,r2
81120d54:	008005c4 	movi	r2,23
81120d58:	100d883a 	mov	r6,r2
81120d5c:	200b883a 	mov	r5,r4
81120d60:	1809883a 	mov	r4,r3
81120d64:	11243500 	call	81124350 <memcpy>
		debug(fp, cDebugBuffer);
81120d68:	d0a06217 	ldw	r2,-32376(gp)
81120d6c:	01604574 	movhi	r5,33045
81120d70:	29546d04 	addi	r5,r5,20916
81120d74:	1009883a 	mov	r4,r2
81120d78:	11232a00 	call	811232a0 <fprintf>
		sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
81120d7c:	e0bffc17 	ldw	r2,-16(fp)
81120d80:	10800058 	cmpnei	r2,r2,1
81120d84:	1000031e 	bne	r2,zero,81120d94 <_print_codec_status+0xb8>
81120d88:	00a04574 	movhi	r2,33045
81120d8c:	10888f04 	addi	r2,r2,8764
81120d90:	00000206 	br	81120d9c <_print_codec_status+0xc0>
81120d94:	00a04574 	movhi	r2,33045
81120d98:	10889004 	addi	r2,r2,8768
81120d9c:	100d883a 	mov	r6,r2
81120da0:	01604574 	movhi	r5,33045
81120da4:	29489104 	addi	r5,r5,8772
81120da8:	01204574 	movhi	r4,33045
81120dac:	21146d04 	addi	r4,r4,20916
81120db0:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, cDebugBuffer);
81120db4:	d0a06217 	ldw	r2,-32376(gp)
81120db8:	01604574 	movhi	r5,33045
81120dbc:	29546d04 	addi	r5,r5,20916
81120dc0:	1009883a 	mov	r4,r2
81120dc4:	11232a00 	call	811232a0 <fprintf>
		sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
81120dc8:	e0bffd17 	ldw	r2,-12(fp)
81120dcc:	10800058 	cmpnei	r2,r2,1
81120dd0:	1000031e 	bne	r2,zero,81120de0 <_print_codec_status+0x104>
81120dd4:	00a04574 	movhi	r2,33045
81120dd8:	10888f04 	addi	r2,r2,8764
81120ddc:	00000206 	br	81120de8 <_print_codec_status+0x10c>
81120de0:	00a04574 	movhi	r2,33045
81120de4:	10889004 	addi	r2,r2,8768
81120de8:	100d883a 	mov	r6,r2
81120dec:	01604574 	movhi	r5,33045
81120df0:	29489704 	addi	r5,r5,8796
81120df4:	01204574 	movhi	r4,33045
81120df8:	21146d04 	addi	r4,r4,20916
81120dfc:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, cDebugBuffer);
81120e00:	d0a06217 	ldw	r2,-32376(gp)
81120e04:	01604574 	movhi	r5,33045
81120e08:	29546d04 	addi	r5,r5,20916
81120e0c:	1009883a 	mov	r4,r2
81120e10:	11232a00 	call	811232a0 <fprintf>
		sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
81120e14:	e0bffe17 	ldw	r2,-8(fp)
81120e18:	10800058 	cmpnei	r2,r2,1
81120e1c:	1000031e 	bne	r2,zero,81120e2c <_print_codec_status+0x150>
81120e20:	00a04574 	movhi	r2,33045
81120e24:	10888f04 	addi	r2,r2,8764
81120e28:	00000206 	br	81120e34 <_print_codec_status+0x158>
81120e2c:	00a04574 	movhi	r2,33045
81120e30:	10889004 	addi	r2,r2,8768
81120e34:	100d883a 	mov	r6,r2
81120e38:	01604574 	movhi	r5,33045
81120e3c:	29489d04 	addi	r5,r5,8820
81120e40:	01204574 	movhi	r4,33045
81120e44:	21146d04 	addi	r4,r4,20916
81120e48:	1124bb40 	call	81124bb4 <sprintf>
		debug(fp, cDebugBuffer);
81120e4c:	d0a06217 	ldw	r2,-32376(gp)
81120e50:	01604574 	movhi	r5,33045
81120e54:	29546d04 	addi	r5,r5,20916
81120e58:	1009883a 	mov	r4,r2
81120e5c:	11232a00 	call	811232a0 <fprintf>
		sprintf(cDebugBuffer, "--------  \n");
81120e60:	00a04574 	movhi	r2,33045
81120e64:	10946d04 	addi	r2,r2,20916
81120e68:	00c00b44 	movi	r3,45
81120e6c:	10c00005 	stb	r3,0(r2)
81120e70:	00c00b44 	movi	r3,45
81120e74:	10c00045 	stb	r3,1(r2)
81120e78:	00c00b44 	movi	r3,45
81120e7c:	10c00085 	stb	r3,2(r2)
81120e80:	00c00b44 	movi	r3,45
81120e84:	10c000c5 	stb	r3,3(r2)
81120e88:	00c00b44 	movi	r3,45
81120e8c:	10c00105 	stb	r3,4(r2)
81120e90:	00c00b44 	movi	r3,45
81120e94:	10c00145 	stb	r3,5(r2)
81120e98:	00c00b44 	movi	r3,45
81120e9c:	10c00185 	stb	r3,6(r2)
81120ea0:	00c00b44 	movi	r3,45
81120ea4:	10c001c5 	stb	r3,7(r2)
81120ea8:	00c00804 	movi	r3,32
81120eac:	10c00205 	stb	r3,8(r2)
81120eb0:	00c00804 	movi	r3,32
81120eb4:	10c00245 	stb	r3,9(r2)
81120eb8:	00c00284 	movi	r3,10
81120ebc:	10c00285 	stb	r3,10(r2)
81120ec0:	100002c5 	stb	zero,11(r2)
		debug(fp, cDebugBuffer);
81120ec4:	d0a06217 	ldw	r2,-32376(gp)
81120ec8:	01604574 	movhi	r5,33045
81120ecc:	29546d04 	addi	r5,r5,20916
81120ed0:	1009883a 	mov	r4,r2
81120ed4:	11232a00 	call	811232a0 <fprintf>
	}
#endif
}
81120ed8:	0001883a 	nop
81120edc:	e037883a 	mov	sp,fp
81120ee0:	dfc00117 	ldw	ra,4(sp)
81120ee4:	df000017 	ldw	fp,0(sp)
81120ee8:	dec00204 	addi	sp,sp,8
81120eec:	f800283a 	ret

81120ef0 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
81120ef0:	defffb04 	addi	sp,sp,-20
81120ef4:	de00012e 	bgeu	sp,et,81120efc <_split_codec_status+0xc>
81120ef8:	003b68fa 	trap	3
81120efc:	df000415 	stw	fp,16(sp)
81120f00:	df000404 	addi	fp,sp,16
81120f04:	e13ffc15 	stw	r4,-16(fp)
81120f08:	e17ffd15 	stw	r5,-12(fp)
81120f0c:	e1bffe15 	stw	r6,-8(fp)
81120f10:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
81120f14:	e0bffc17 	ldw	r2,-16(fp)
81120f18:	1005d1ba 	srai	r2,r2,6
81120f1c:	10c0004c 	andi	r3,r2,1
81120f20:	e0bffd17 	ldw	r2,-12(fp)
81120f24:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
81120f28:	e0bffc17 	ldw	r2,-16(fp)
81120f2c:	1005d17a 	srai	r2,r2,5
81120f30:	10c0004c 	andi	r3,r2,1
81120f34:	e0bffe17 	ldw	r2,-8(fp)
81120f38:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
81120f3c:	e0bffc17 	ldw	r2,-16(fp)
81120f40:	1005d13a 	srai	r2,r2,4
81120f44:	10c0004c 	andi	r3,r2,1
81120f48:	e0bfff17 	ldw	r2,-4(fp)
81120f4c:	10c00015 	stw	r3,0(r2)
}
81120f50:	0001883a 	nop
81120f54:	e037883a 	mov	sp,fp
81120f58:	df000017 	ldw	fp,0(sp)
81120f5c:	dec00104 	addi	sp,sp,4
81120f60:	f800283a 	ret

81120f64 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
81120f64:	defffc04 	addi	sp,sp,-16
81120f68:	de00012e 	bgeu	sp,et,81120f70 <aatoh+0xc>
81120f6c:	003b68fa 	trap	3
81120f70:	df000315 	stw	fp,12(sp)
81120f74:	df000304 	addi	fp,sp,12
81120f78:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
81120f7c:	e0bfff17 	ldw	r2,-4(fp)
81120f80:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81120f84:	e0bffd17 	ldw	r2,-12(fp)
81120f88:	10c00003 	ldbu	r3,0(r2)
81120f8c:	e0bffd17 	ldw	r2,-12(fp)
81120f90:	10800003 	ldbu	r2,0(r2)
81120f94:	10803fcc 	andi	r2,r2,255
81120f98:	10800eb0 	cmpltui	r2,r2,58
81120f9c:	1000021e 	bne	r2,zero,81120fa8 <aatoh+0x44>
81120fa0:	00800dc4 	movi	r2,55
81120fa4:	00000106 	br	81120fac <aatoh+0x48>
81120fa8:	00800c04 	movi	r2,48
81120fac:	1885c83a 	sub	r2,r3,r2
81120fb0:	1004913a 	slli	r2,r2,4
81120fb4:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
81120fb8:	e0bffd17 	ldw	r2,-12(fp)
81120fbc:	10800044 	addi	r2,r2,1
81120fc0:	10c00003 	ldbu	r3,0(r2)
81120fc4:	e0bffd17 	ldw	r2,-12(fp)
81120fc8:	10800044 	addi	r2,r2,1
81120fcc:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81120fd0:	10803fcc 	andi	r2,r2,255
81120fd4:	10800eb0 	cmpltui	r2,r2,58
81120fd8:	1000021e 	bne	r2,zero,81120fe4 <aatoh+0x80>
81120fdc:	00800dc4 	movi	r2,55
81120fe0:	00000106 	br	81120fe8 <aatoh+0x84>
81120fe4:	00800c04 	movi	r2,48
81120fe8:	1885c83a 	sub	r2,r3,r2
81120fec:	2085883a 	add	r2,r4,r2
81120ff0:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
81120ff4:	e0bffe03 	ldbu	r2,-8(fp)
}
81120ff8:	e037883a 	mov	sp,fp
81120ffc:	df000017 	ldw	fp,0(sp)
81121000:	dec00104 	addi	sp,sp,4
81121004:	f800283a 	ret

81121008 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
81121008:	defffd04 	addi	sp,sp,-12
8112100c:	de00012e 	bgeu	sp,et,81121014 <Verif_Error+0xc>
81121010:	003b68fa 	trap	3
81121014:	dfc00215 	stw	ra,8(sp)
81121018:	df000115 	stw	fp,4(sp)
8112101c:	df000104 	addi	fp,sp,4
81121020:	2005883a 	mov	r2,r4
81121024:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
81121028:	e0bfff03 	ldbu	r2,-4(fp)
8112102c:	10000f1e 	bne	r2,zero,8112106c <Verif_Error+0x64>
#if DEBUG_ON
if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81121030:	00a045f4 	movhi	r2,33047
81121034:	10a25304 	addi	r2,r2,-30388
81121038:	10800a8b 	ldhu	r2,42(r2)
8112103c:	10bfffcc 	andi	r2,r2,65535
81121040:	10800228 	cmpgeui	r2,r2,8
81121044:	1000071e 	bne	r2,zero,81121064 <Verif_Error+0x5c>
	debug(fp, "ERROR\n\r");
81121048:	d0a06217 	ldw	r2,-32376(gp)
8112104c:	100f883a 	mov	r7,r2
81121050:	018001c4 	movi	r6,7
81121054:	01400044 	movi	r5,1
81121058:	01204574 	movhi	r4,33045
8112105c:	2108a304 	addi	r4,r4,8844
81121060:	112393c0 	call	8112393c <fwrite>
}
#endif
		return 0;
81121064:	0005883a 	mov	r2,zero
81121068:	00000106 	br	81121070 <Verif_Error+0x68>
	} else
		return 1;
8112106c:	00800044 	movi	r2,1
}
81121070:	e037883a 	mov	sp,fp
81121074:	dfc00117 	ldw	ra,4(sp)
81121078:	df000017 	ldw	fp,0(sp)
8112107c:	dec00204 	addi	sp,sp,8
81121080:	f800283a 	ret

81121084 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
81121084:	defffe04 	addi	sp,sp,-8
81121088:	de00012e 	bgeu	sp,et,81121090 <toInt+0xc>
8112108c:	003b68fa 	trap	3
81121090:	df000115 	stw	fp,4(sp)
81121094:	df000104 	addi	fp,sp,4
81121098:	2005883a 	mov	r2,r4
8112109c:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
811210a0:	e0bfff03 	ldbu	r2,-4(fp)
811210a4:	10bff404 	addi	r2,r2,-48
}
811210a8:	e037883a 	mov	sp,fp
811210ac:	df000017 	ldw	fp,0(sp)
811210b0:	dec00104 	addi	sp,sp,4
811210b4:	f800283a 	ret

811210b8 <__fixunsdfsi>:
811210b8:	defffd04 	addi	sp,sp,-12
811210bc:	000d883a 	mov	r6,zero
811210c0:	01d07834 	movhi	r7,16864
811210c4:	de00012e 	bgeu	sp,et,811210cc <__fixunsdfsi+0x14>
811210c8:	003b68fa 	trap	3
811210cc:	dc400115 	stw	r17,4(sp)
811210d0:	dc000015 	stw	r16,0(sp)
811210d4:	dfc00215 	stw	ra,8(sp)
811210d8:	2023883a 	mov	r17,r4
811210dc:	2821883a 	mov	r16,r5
811210e0:	1121ba40 	call	81121ba4 <__gedf2>
811210e4:	1000080e 	bge	r2,zero,81121108 <__fixunsdfsi+0x50>
811210e8:	8809883a 	mov	r4,r17
811210ec:	800b883a 	mov	r5,r16
811210f0:	1122ca40 	call	81122ca4 <__fixdfsi>
811210f4:	dfc00217 	ldw	ra,8(sp)
811210f8:	dc400117 	ldw	r17,4(sp)
811210fc:	dc000017 	ldw	r16,0(sp)
81121100:	dec00304 	addi	sp,sp,12
81121104:	f800283a 	ret
81121108:	000d883a 	mov	r6,zero
8112110c:	01d07834 	movhi	r7,16864
81121110:	8809883a 	mov	r4,r17
81121114:	800b883a 	mov	r5,r16
81121118:	11223a00 	call	811223a0 <__subdf3>
8112111c:	180b883a 	mov	r5,r3
81121120:	1009883a 	mov	r4,r2
81121124:	1122ca40 	call	81122ca4 <__fixdfsi>
81121128:	00e00034 	movhi	r3,32768
8112112c:	10c5883a 	add	r2,r2,r3
81121130:	003ff006 	br	811210f4 <__reset+0xfb1010f4>

81121134 <__divsf3>:
81121134:	defff504 	addi	sp,sp,-44
81121138:	200cd5fa 	srli	r6,r4,23
8112113c:	de00012e 	bgeu	sp,et,81121144 <__divsf3+0x10>
81121140:	003b68fa 	trap	3
81121144:	dcc00415 	stw	r19,16(sp)
81121148:	2026d7fa 	srli	r19,r4,31
8112114c:	00c02034 	movhi	r3,128
81121150:	dd800715 	stw	r22,28(sp)
81121154:	dd000515 	stw	r20,20(sp)
81121158:	dc800315 	stw	r18,12(sp)
8112115c:	18ffffc4 	addi	r3,r3,-1
81121160:	dfc00a15 	stw	ra,40(sp)
81121164:	df000915 	stw	fp,36(sp)
81121168:	ddc00815 	stw	r23,32(sp)
8112116c:	dd400615 	stw	r21,24(sp)
81121170:	dc400215 	stw	r17,8(sp)
81121174:	dc000115 	stw	r16,4(sp)
81121178:	35003fcc 	andi	r20,r6,255
8112117c:	1924703a 	and	r18,r3,r4
81121180:	9d803fcc 	andi	r22,r19,255
81121184:	a0005226 	beq	r20,zero,811212d0 <__divsf3+0x19c>
81121188:	00803fc4 	movi	r2,255
8112118c:	a0802e26 	beq	r20,r2,81121248 <__divsf3+0x114>
81121190:	91002034 	orhi	r4,r18,128
81121194:	202490fa 	slli	r18,r4,3
81121198:	a53fe044 	addi	r20,r20,-127
8112119c:	0021883a 	mov	r16,zero
811211a0:	002f883a 	mov	r23,zero
811211a4:	280cd5fa 	srli	r6,r5,23
811211a8:	282ad7fa 	srli	r21,r5,31
811211ac:	00c02034 	movhi	r3,128
811211b0:	18ffffc4 	addi	r3,r3,-1
811211b4:	31803fcc 	andi	r6,r6,255
811211b8:	1962703a 	and	r17,r3,r5
811211bc:	af003fcc 	andi	fp,r21,255
811211c0:	30004a26 	beq	r6,zero,811212ec <__divsf3+0x1b8>
811211c4:	00803fc4 	movi	r2,255
811211c8:	30804526 	beq	r6,r2,811212e0 <__divsf3+0x1ac>
811211cc:	89402034 	orhi	r5,r17,128
811211d0:	282290fa 	slli	r17,r5,3
811211d4:	31bfe044 	addi	r6,r6,-127
811211d8:	000b883a 	mov	r5,zero
811211dc:	2c20b03a 	or	r16,r5,r16
811211e0:	802090ba 	slli	r16,r16,2
811211e4:	00a044b4 	movhi	r2,33042
811211e8:	10848204 	addi	r2,r2,4616
811211ec:	80a1883a 	add	r16,r16,r2
811211f0:	81000017 	ldw	r4,0(r16)
811211f4:	9d46f03a 	xor	r3,r19,r21
811211f8:	180f883a 	mov	r7,r3
811211fc:	18803fcc 	andi	r2,r3,255
81121200:	a18dc83a 	sub	r6,r20,r6
81121204:	2000683a 	jmp	r4
81121208:	811213ec 	andhi	r4,r16,18511
8112120c:	81121270 	cmpltui	r4,r16,18505
81121210:	811213e0 	cmpeqi	r4,r16,18511
81121214:	8112125c 	xori	r4,r16,18505
81121218:	811213e0 	cmpeqi	r4,r16,18511
8112121c:	811213b8 	rdprs	r4,r16,18510
81121220:	811213e0 	cmpeqi	r4,r16,18511
81121224:	8112125c 	xori	r4,r16,18505
81121228:	81121270 	cmpltui	r4,r16,18505
8112122c:	81121270 	cmpltui	r4,r16,18505
81121230:	811213b8 	rdprs	r4,r16,18510
81121234:	8112125c 	xori	r4,r16,18505
81121238:	811214cc 	andi	r4,r16,18515
8112123c:	811214cc 	andi	r4,r16,18515
81121240:	811214cc 	andi	r4,r16,18515
81121244:	81121480 	call	88112148 <__reset+0x20f2148>
81121248:	9000581e 	bne	r18,zero,811213ac <__divsf3+0x278>
8112124c:	04000204 	movi	r16,8
81121250:	05c00084 	movi	r23,2
81121254:	003fd306 	br	811211a4 <__reset+0xfb1011a4>
81121258:	0023883a 	mov	r17,zero
8112125c:	e02d883a 	mov	r22,fp
81121260:	282f883a 	mov	r23,r5
81121264:	00800084 	movi	r2,2
81121268:	b8808f1e 	bne	r23,r2,811214a8 <__divsf3+0x374>
8112126c:	b005883a 	mov	r2,r22
81121270:	11c0004c 	andi	r7,r2,1
81121274:	013fffc4 	movi	r4,-1
81121278:	000d883a 	mov	r6,zero
8112127c:	21003fcc 	andi	r4,r4,255
81121280:	200895fa 	slli	r4,r4,23
81121284:	38803fcc 	andi	r2,r7,255
81121288:	00c02034 	movhi	r3,128
8112128c:	100497fa 	slli	r2,r2,31
81121290:	18ffffc4 	addi	r3,r3,-1
81121294:	30c6703a 	and	r3,r6,r3
81121298:	1906b03a 	or	r3,r3,r4
8112129c:	1884b03a 	or	r2,r3,r2
811212a0:	dfc00a17 	ldw	ra,40(sp)
811212a4:	df000917 	ldw	fp,36(sp)
811212a8:	ddc00817 	ldw	r23,32(sp)
811212ac:	dd800717 	ldw	r22,28(sp)
811212b0:	dd400617 	ldw	r21,24(sp)
811212b4:	dd000517 	ldw	r20,20(sp)
811212b8:	dcc00417 	ldw	r19,16(sp)
811212bc:	dc800317 	ldw	r18,12(sp)
811212c0:	dc400217 	ldw	r17,8(sp)
811212c4:	dc000117 	ldw	r16,4(sp)
811212c8:	dec00b04 	addi	sp,sp,44
811212cc:	f800283a 	ret
811212d0:	90002b1e 	bne	r18,zero,81121380 <__divsf3+0x24c>
811212d4:	04000104 	movi	r16,4
811212d8:	05c00044 	movi	r23,1
811212dc:	003fb106 	br	811211a4 <__reset+0xfb1011a4>
811212e0:	8800251e 	bne	r17,zero,81121378 <__divsf3+0x244>
811212e4:	01400084 	movi	r5,2
811212e8:	00000206 	br	811212f4 <__divsf3+0x1c0>
811212ec:	88001a1e 	bne	r17,zero,81121358 <__divsf3+0x224>
811212f0:	01400044 	movi	r5,1
811212f4:	8160b03a 	or	r16,r16,r5
811212f8:	802090ba 	slli	r16,r16,2
811212fc:	00e044b4 	movhi	r3,33042
81121300:	18c4c604 	addi	r3,r3,4888
81121304:	80e1883a 	add	r16,r16,r3
81121308:	80c00017 	ldw	r3,0(r16)
8112130c:	9d44f03a 	xor	r2,r19,r21
81121310:	a18dc83a 	sub	r6,r20,r6
81121314:	1800683a 	jmp	r3
81121318:	81121270 	cmpltui	r4,r16,18505
8112131c:	81121270 	cmpltui	r4,r16,18505
81121320:	811214bc 	xorhi	r4,r16,18514
81121324:	81121258 	cmpnei	r4,r16,18505
81121328:	811214bc 	xorhi	r4,r16,18514
8112132c:	811213b8 	rdprs	r4,r16,18510
81121330:	811214bc 	xorhi	r4,r16,18514
81121334:	81121258 	cmpnei	r4,r16,18505
81121338:	81121270 	cmpltui	r4,r16,18505
8112133c:	81121270 	cmpltui	r4,r16,18505
81121340:	811213b8 	rdprs	r4,r16,18510
81121344:	81121258 	cmpnei	r4,r16,18505
81121348:	811214cc 	andi	r4,r16,18515
8112134c:	811214cc 	andi	r4,r16,18515
81121350:	811214cc 	andi	r4,r16,18515
81121354:	811214e4 	muli	r4,r16,18515
81121358:	8809883a 	mov	r4,r17
8112135c:	11230c80 	call	811230c8 <__clzsi2>
81121360:	10fffec4 	addi	r3,r2,-5
81121364:	10801d84 	addi	r2,r2,118
81121368:	88e2983a 	sll	r17,r17,r3
8112136c:	008dc83a 	sub	r6,zero,r2
81121370:	000b883a 	mov	r5,zero
81121374:	003f9906 	br	811211dc <__reset+0xfb1011dc>
81121378:	014000c4 	movi	r5,3
8112137c:	003f9706 	br	811211dc <__reset+0xfb1011dc>
81121380:	9009883a 	mov	r4,r18
81121384:	d9400015 	stw	r5,0(sp)
81121388:	11230c80 	call	811230c8 <__clzsi2>
8112138c:	10fffec4 	addi	r3,r2,-5
81121390:	11801d84 	addi	r6,r2,118
81121394:	90e4983a 	sll	r18,r18,r3
81121398:	01a9c83a 	sub	r20,zero,r6
8112139c:	0021883a 	mov	r16,zero
811213a0:	002f883a 	mov	r23,zero
811213a4:	d9400017 	ldw	r5,0(sp)
811213a8:	003f7e06 	br	811211a4 <__reset+0xfb1011a4>
811213ac:	04000304 	movi	r16,12
811213b0:	05c000c4 	movi	r23,3
811213b4:	003f7b06 	br	811211a4 <__reset+0xfb1011a4>
811213b8:	01802034 	movhi	r6,128
811213bc:	000f883a 	mov	r7,zero
811213c0:	31bfffc4 	addi	r6,r6,-1
811213c4:	013fffc4 	movi	r4,-1
811213c8:	003fac06 	br	8112127c <__reset+0xfb10127c>
811213cc:	01400044 	movi	r5,1
811213d0:	2909c83a 	sub	r4,r5,r4
811213d4:	00c006c4 	movi	r3,27
811213d8:	19004b0e 	bge	r3,r4,81121508 <__divsf3+0x3d4>
811213dc:	114e703a 	and	r7,r2,r5
811213e0:	0009883a 	mov	r4,zero
811213e4:	000d883a 	mov	r6,zero
811213e8:	003fa406 	br	8112127c <__reset+0xfb10127c>
811213ec:	9006917a 	slli	r3,r18,5
811213f0:	8822917a 	slli	r17,r17,5
811213f4:	1c40372e 	bgeu	r3,r17,811214d4 <__divsf3+0x3a0>
811213f8:	31bfffc4 	addi	r6,r6,-1
811213fc:	010006c4 	movi	r4,27
81121400:	000b883a 	mov	r5,zero
81121404:	180f883a 	mov	r7,r3
81121408:	294b883a 	add	r5,r5,r5
8112140c:	18c7883a 	add	r3,r3,r3
81121410:	38000116 	blt	r7,zero,81121418 <__divsf3+0x2e4>
81121414:	1c400236 	bltu	r3,r17,81121420 <__divsf3+0x2ec>
81121418:	1c47c83a 	sub	r3,r3,r17
8112141c:	29400054 	ori	r5,r5,1
81121420:	213fffc4 	addi	r4,r4,-1
81121424:	203ff71e 	bne	r4,zero,81121404 <__reset+0xfb101404>
81121428:	1806c03a 	cmpne	r3,r3,zero
8112142c:	1962b03a 	or	r17,r3,r5
81121430:	31001fc4 	addi	r4,r6,127
81121434:	013fe50e 	bge	zero,r4,811213cc <__reset+0xfb1013cc>
81121438:	88c001cc 	andi	r3,r17,7
8112143c:	18000426 	beq	r3,zero,81121450 <__divsf3+0x31c>
81121440:	88c003cc 	andi	r3,r17,15
81121444:	01400104 	movi	r5,4
81121448:	19400126 	beq	r3,r5,81121450 <__divsf3+0x31c>
8112144c:	8963883a 	add	r17,r17,r5
81121450:	88c2002c 	andhi	r3,r17,2048
81121454:	18000426 	beq	r3,zero,81121468 <__divsf3+0x334>
81121458:	00fe0034 	movhi	r3,63488
8112145c:	18ffffc4 	addi	r3,r3,-1
81121460:	31002004 	addi	r4,r6,128
81121464:	88e2703a 	and	r17,r17,r3
81121468:	00c03f84 	movi	r3,254
8112146c:	193f8016 	blt	r3,r4,81121270 <__reset+0xfb101270>
81121470:	880c91ba 	slli	r6,r17,6
81121474:	11c0004c 	andi	r7,r2,1
81121478:	300cd27a 	srli	r6,r6,9
8112147c:	003f7f06 	br	8112127c <__reset+0xfb10127c>
81121480:	9080102c 	andhi	r2,r18,64
81121484:	10000226 	beq	r2,zero,81121490 <__divsf3+0x35c>
81121488:	8880102c 	andhi	r2,r17,64
8112148c:	10001826 	beq	r2,zero,811214f0 <__divsf3+0x3bc>
81121490:	00802034 	movhi	r2,128
81121494:	91801034 	orhi	r6,r18,64
81121498:	10bfffc4 	addi	r2,r2,-1
8112149c:	980f883a 	mov	r7,r19
811214a0:	308c703a 	and	r6,r6,r2
811214a4:	003fc706 	br	811213c4 <__reset+0xfb1013c4>
811214a8:	008000c4 	movi	r2,3
811214ac:	b8802d26 	beq	r23,r2,81121564 <__divsf3+0x430>
811214b0:	00c00044 	movi	r3,1
811214b4:	b005883a 	mov	r2,r22
811214b8:	b8ffdd1e 	bne	r23,r3,81121430 <__reset+0xfb101430>
811214bc:	11c0004c 	andi	r7,r2,1
811214c0:	0009883a 	mov	r4,zero
811214c4:	000d883a 	mov	r6,zero
811214c8:	003f6c06 	br	8112127c <__reset+0xfb10127c>
811214cc:	9023883a 	mov	r17,r18
811214d0:	003f6406 	br	81121264 <__reset+0xfb101264>
811214d4:	1c47c83a 	sub	r3,r3,r17
811214d8:	01000684 	movi	r4,26
811214dc:	01400044 	movi	r5,1
811214e0:	003fc806 	br	81121404 <__reset+0xfb101404>
811214e4:	9080102c 	andhi	r2,r18,64
811214e8:	103fe926 	beq	r2,zero,81121490 <__reset+0xfb101490>
811214ec:	0023883a 	mov	r17,zero
811214f0:	00802034 	movhi	r2,128
811214f4:	89801034 	orhi	r6,r17,64
811214f8:	10bfffc4 	addi	r2,r2,-1
811214fc:	a80f883a 	mov	r7,r21
81121500:	308c703a 	and	r6,r6,r2
81121504:	003faf06 	br	811213c4 <__reset+0xfb1013c4>
81121508:	01c00804 	movi	r7,32
8112150c:	390fc83a 	sub	r7,r7,r4
81121510:	89ce983a 	sll	r7,r17,r7
81121514:	890ad83a 	srl	r5,r17,r4
81121518:	380ec03a 	cmpne	r7,r7,zero
8112151c:	29cab03a 	or	r5,r5,r7
81121520:	28c001cc 	andi	r3,r5,7
81121524:	18000426 	beq	r3,zero,81121538 <__divsf3+0x404>
81121528:	28c003cc 	andi	r3,r5,15
8112152c:	01000104 	movi	r4,4
81121530:	19000126 	beq	r3,r4,81121538 <__divsf3+0x404>
81121534:	290b883a 	add	r5,r5,r4
81121538:	28c1002c 	andhi	r3,r5,1024
8112153c:	18000426 	beq	r3,zero,81121550 <__divsf3+0x41c>
81121540:	11c0004c 	andi	r7,r2,1
81121544:	01000044 	movi	r4,1
81121548:	000d883a 	mov	r6,zero
8112154c:	003f4b06 	br	8112127c <__reset+0xfb10127c>
81121550:	280a91ba 	slli	r5,r5,6
81121554:	11c0004c 	andi	r7,r2,1
81121558:	0009883a 	mov	r4,zero
8112155c:	280cd27a 	srli	r6,r5,9
81121560:	003f4606 	br	8112127c <__reset+0xfb10127c>
81121564:	00802034 	movhi	r2,128
81121568:	89801034 	orhi	r6,r17,64
8112156c:	10bfffc4 	addi	r2,r2,-1
81121570:	b00f883a 	mov	r7,r22
81121574:	308c703a 	and	r6,r6,r2
81121578:	003f9206 	br	811213c4 <__reset+0xfb1013c4>

8112157c <__mulsf3>:
8112157c:	defff504 	addi	sp,sp,-44
81121580:	de00012e 	bgeu	sp,et,81121588 <__mulsf3+0xc>
81121584:	003b68fa 	trap	3
81121588:	dc000115 	stw	r16,4(sp)
8112158c:	2020d5fa 	srli	r16,r4,23
81121590:	dd400615 	stw	r21,24(sp)
81121594:	202ad7fa 	srli	r21,r4,31
81121598:	dc800315 	stw	r18,12(sp)
8112159c:	04802034 	movhi	r18,128
811215a0:	df000915 	stw	fp,36(sp)
811215a4:	dd000515 	stw	r20,20(sp)
811215a8:	94bfffc4 	addi	r18,r18,-1
811215ac:	dfc00a15 	stw	ra,40(sp)
811215b0:	ddc00815 	stw	r23,32(sp)
811215b4:	dd800715 	stw	r22,28(sp)
811215b8:	dcc00415 	stw	r19,16(sp)
811215bc:	dc400215 	stw	r17,8(sp)
811215c0:	84003fcc 	andi	r16,r16,255
811215c4:	9124703a 	and	r18,r18,r4
811215c8:	a829883a 	mov	r20,r21
811215cc:	af003fcc 	andi	fp,r21,255
811215d0:	80005426 	beq	r16,zero,81121724 <__mulsf3+0x1a8>
811215d4:	00803fc4 	movi	r2,255
811215d8:	80802f26 	beq	r16,r2,81121698 <__mulsf3+0x11c>
811215dc:	91002034 	orhi	r4,r18,128
811215e0:	202490fa 	slli	r18,r4,3
811215e4:	843fe044 	addi	r16,r16,-127
811215e8:	0023883a 	mov	r17,zero
811215ec:	002f883a 	mov	r23,zero
811215f0:	2804d5fa 	srli	r2,r5,23
811215f4:	282cd7fa 	srli	r22,r5,31
811215f8:	01002034 	movhi	r4,128
811215fc:	213fffc4 	addi	r4,r4,-1
81121600:	10803fcc 	andi	r2,r2,255
81121604:	2166703a 	and	r19,r4,r5
81121608:	b1803fcc 	andi	r6,r22,255
8112160c:	10004c26 	beq	r2,zero,81121740 <__mulsf3+0x1c4>
81121610:	00c03fc4 	movi	r3,255
81121614:	10c04726 	beq	r2,r3,81121734 <__mulsf3+0x1b8>
81121618:	99002034 	orhi	r4,r19,128
8112161c:	202690fa 	slli	r19,r4,3
81121620:	10bfe044 	addi	r2,r2,-127
81121624:	0007883a 	mov	r3,zero
81121628:	80a1883a 	add	r16,r16,r2
8112162c:	010003c4 	movi	r4,15
81121630:	1c44b03a 	or	r2,r3,r17
81121634:	b56af03a 	xor	r21,r22,r21
81121638:	81c00044 	addi	r7,r16,1
8112163c:	20806b36 	bltu	r4,r2,811217ec <__mulsf3+0x270>
81121640:	100490ba 	slli	r2,r2,2
81121644:	012044b4 	movhi	r4,33042
81121648:	21059604 	addi	r4,r4,5720
8112164c:	1105883a 	add	r2,r2,r4
81121650:	10800017 	ldw	r2,0(r2)
81121654:	1000683a 	jmp	r2
81121658:	811217ec 	andhi	r4,r16,18527
8112165c:	811216ac 	andhi	r4,r16,18522
81121660:	811216ac 	andhi	r4,r16,18522
81121664:	811216a8 	cmpgeui	r4,r16,18522
81121668:	811217d0 	cmplti	r4,r16,18527
8112166c:	811217d0 	cmplti	r4,r16,18527
81121670:	811217bc 	xorhi	r4,r16,18526
81121674:	811216a8 	cmpgeui	r4,r16,18522
81121678:	811217d0 	cmplti	r4,r16,18527
8112167c:	811217bc 	xorhi	r4,r16,18526
81121680:	811217d0 	cmplti	r4,r16,18527
81121684:	811216a8 	cmpgeui	r4,r16,18522
81121688:	811217dc 	xori	r4,r16,18527
8112168c:	811217dc 	xori	r4,r16,18527
81121690:	811217dc 	xori	r4,r16,18527
81121694:	811218b8 	rdprs	r4,r16,18530
81121698:	90003b1e 	bne	r18,zero,81121788 <__mulsf3+0x20c>
8112169c:	04400204 	movi	r17,8
811216a0:	05c00084 	movi	r23,2
811216a4:	003fd206 	br	811215f0 <__reset+0xfb1015f0>
811216a8:	302b883a 	mov	r21,r6
811216ac:	00800084 	movi	r2,2
811216b0:	18802626 	beq	r3,r2,8112174c <__mulsf3+0x1d0>
811216b4:	008000c4 	movi	r2,3
811216b8:	1880ab26 	beq	r3,r2,81121968 <__mulsf3+0x3ec>
811216bc:	00800044 	movi	r2,1
811216c0:	1880a21e 	bne	r3,r2,8112194c <__mulsf3+0x3d0>
811216c4:	a829883a 	mov	r20,r21
811216c8:	0007883a 	mov	r3,zero
811216cc:	0009883a 	mov	r4,zero
811216d0:	18803fcc 	andi	r2,r3,255
811216d4:	100695fa 	slli	r3,r2,23
811216d8:	a0803fcc 	andi	r2,r20,255
811216dc:	100a97fa 	slli	r5,r2,31
811216e0:	00802034 	movhi	r2,128
811216e4:	10bfffc4 	addi	r2,r2,-1
811216e8:	2084703a 	and	r2,r4,r2
811216ec:	10c4b03a 	or	r2,r2,r3
811216f0:	1144b03a 	or	r2,r2,r5
811216f4:	dfc00a17 	ldw	ra,40(sp)
811216f8:	df000917 	ldw	fp,36(sp)
811216fc:	ddc00817 	ldw	r23,32(sp)
81121700:	dd800717 	ldw	r22,28(sp)
81121704:	dd400617 	ldw	r21,24(sp)
81121708:	dd000517 	ldw	r20,20(sp)
8112170c:	dcc00417 	ldw	r19,16(sp)
81121710:	dc800317 	ldw	r18,12(sp)
81121714:	dc400217 	ldw	r17,8(sp)
81121718:	dc000117 	ldw	r16,4(sp)
8112171c:	dec00b04 	addi	sp,sp,44
81121720:	f800283a 	ret
81121724:	90000d1e 	bne	r18,zero,8112175c <__mulsf3+0x1e0>
81121728:	04400104 	movi	r17,4
8112172c:	05c00044 	movi	r23,1
81121730:	003faf06 	br	811215f0 <__reset+0xfb1015f0>
81121734:	9806c03a 	cmpne	r3,r19,zero
81121738:	18c00084 	addi	r3,r3,2
8112173c:	003fba06 	br	81121628 <__reset+0xfb101628>
81121740:	9800141e 	bne	r19,zero,81121794 <__mulsf3+0x218>
81121744:	00c00044 	movi	r3,1
81121748:	003fb706 	br	81121628 <__reset+0xfb101628>
8112174c:	a829883a 	mov	r20,r21
81121750:	00ffffc4 	movi	r3,-1
81121754:	0009883a 	mov	r4,zero
81121758:	003fdd06 	br	811216d0 <__reset+0xfb1016d0>
8112175c:	9009883a 	mov	r4,r18
81121760:	d9400015 	stw	r5,0(sp)
81121764:	11230c80 	call	811230c8 <__clzsi2>
81121768:	10fffec4 	addi	r3,r2,-5
8112176c:	10801d84 	addi	r2,r2,118
81121770:	90e4983a 	sll	r18,r18,r3
81121774:	00a1c83a 	sub	r16,zero,r2
81121778:	0023883a 	mov	r17,zero
8112177c:	002f883a 	mov	r23,zero
81121780:	d9400017 	ldw	r5,0(sp)
81121784:	003f9a06 	br	811215f0 <__reset+0xfb1015f0>
81121788:	04400304 	movi	r17,12
8112178c:	05c000c4 	movi	r23,3
81121790:	003f9706 	br	811215f0 <__reset+0xfb1015f0>
81121794:	9809883a 	mov	r4,r19
81121798:	d9800015 	stw	r6,0(sp)
8112179c:	11230c80 	call	811230c8 <__clzsi2>
811217a0:	10fffec4 	addi	r3,r2,-5
811217a4:	10801d84 	addi	r2,r2,118
811217a8:	98e6983a 	sll	r19,r19,r3
811217ac:	0085c83a 	sub	r2,zero,r2
811217b0:	0007883a 	mov	r3,zero
811217b4:	d9800017 	ldw	r6,0(sp)
811217b8:	003f9b06 	br	81121628 <__reset+0xfb101628>
811217bc:	01002034 	movhi	r4,128
811217c0:	0029883a 	mov	r20,zero
811217c4:	213fffc4 	addi	r4,r4,-1
811217c8:	00ffffc4 	movi	r3,-1
811217cc:	003fc006 	br	811216d0 <__reset+0xfb1016d0>
811217d0:	9027883a 	mov	r19,r18
811217d4:	b807883a 	mov	r3,r23
811217d8:	003fb406 	br	811216ac <__reset+0xfb1016ac>
811217dc:	9027883a 	mov	r19,r18
811217e0:	e02b883a 	mov	r21,fp
811217e4:	b807883a 	mov	r3,r23
811217e8:	003fb006 	br	811216ac <__reset+0xfb1016ac>
811217ec:	9004d43a 	srli	r2,r18,16
811217f0:	9810d43a 	srli	r8,r19,16
811217f4:	94bfffcc 	andi	r18,r18,65535
811217f8:	993fffcc 	andi	r4,r19,65535
811217fc:	910d383a 	mul	r6,r18,r4
81121800:	20a7383a 	mul	r19,r4,r2
81121804:	9225383a 	mul	r18,r18,r8
81121808:	3006d43a 	srli	r3,r6,16
8112180c:	1211383a 	mul	r8,r2,r8
81121810:	94e5883a 	add	r18,r18,r19
81121814:	1c87883a 	add	r3,r3,r18
81121818:	1cc0022e 	bgeu	r3,r19,81121824 <__mulsf3+0x2a8>
8112181c:	00800074 	movhi	r2,1
81121820:	4091883a 	add	r8,r8,r2
81121824:	1804943a 	slli	r2,r3,16
81121828:	31bfffcc 	andi	r6,r6,65535
8112182c:	1806d43a 	srli	r3,r3,16
81121830:	1185883a 	add	r2,r2,r6
81121834:	102691ba 	slli	r19,r2,6
81121838:	1a07883a 	add	r3,r3,r8
8112183c:	1004d6ba 	srli	r2,r2,26
81121840:	180891ba 	slli	r4,r3,6
81121844:	9826c03a 	cmpne	r19,r19,zero
81121848:	9884b03a 	or	r2,r19,r2
8112184c:	1126b03a 	or	r19,r2,r4
81121850:	9882002c 	andhi	r2,r19,2048
81121854:	10000426 	beq	r2,zero,81121868 <__mulsf3+0x2ec>
81121858:	9804d07a 	srli	r2,r19,1
8112185c:	9900004c 	andi	r4,r19,1
81121860:	3821883a 	mov	r16,r7
81121864:	1126b03a 	or	r19,r2,r4
81121868:	80c01fc4 	addi	r3,r16,127
8112186c:	00c0210e 	bge	zero,r3,811218f4 <__mulsf3+0x378>
81121870:	988001cc 	andi	r2,r19,7
81121874:	10000426 	beq	r2,zero,81121888 <__mulsf3+0x30c>
81121878:	988003cc 	andi	r2,r19,15
8112187c:	01000104 	movi	r4,4
81121880:	11000126 	beq	r2,r4,81121888 <__mulsf3+0x30c>
81121884:	9927883a 	add	r19,r19,r4
81121888:	9882002c 	andhi	r2,r19,2048
8112188c:	10000426 	beq	r2,zero,811218a0 <__mulsf3+0x324>
81121890:	00be0034 	movhi	r2,63488
81121894:	10bfffc4 	addi	r2,r2,-1
81121898:	80c02004 	addi	r3,r16,128
8112189c:	98a6703a 	and	r19,r19,r2
811218a0:	00803f84 	movi	r2,254
811218a4:	10ffa916 	blt	r2,r3,8112174c <__reset+0xfb10174c>
811218a8:	980891ba 	slli	r4,r19,6
811218ac:	a829883a 	mov	r20,r21
811218b0:	2008d27a 	srli	r4,r4,9
811218b4:	003f8606 	br	811216d0 <__reset+0xfb1016d0>
811218b8:	9080102c 	andhi	r2,r18,64
811218bc:	10000826 	beq	r2,zero,811218e0 <__mulsf3+0x364>
811218c0:	9880102c 	andhi	r2,r19,64
811218c4:	1000061e 	bne	r2,zero,811218e0 <__mulsf3+0x364>
811218c8:	00802034 	movhi	r2,128
811218cc:	99001034 	orhi	r4,r19,64
811218d0:	10bfffc4 	addi	r2,r2,-1
811218d4:	b029883a 	mov	r20,r22
811218d8:	2088703a 	and	r4,r4,r2
811218dc:	003fba06 	br	811217c8 <__reset+0xfb1017c8>
811218e0:	00802034 	movhi	r2,128
811218e4:	91001034 	orhi	r4,r18,64
811218e8:	10bfffc4 	addi	r2,r2,-1
811218ec:	2088703a 	and	r4,r4,r2
811218f0:	003fb506 	br	811217c8 <__reset+0xfb1017c8>
811218f4:	00800044 	movi	r2,1
811218f8:	10c7c83a 	sub	r3,r2,r3
811218fc:	008006c4 	movi	r2,27
81121900:	10ff7016 	blt	r2,r3,811216c4 <__reset+0xfb1016c4>
81121904:	00800804 	movi	r2,32
81121908:	10c5c83a 	sub	r2,r2,r3
8112190c:	9884983a 	sll	r2,r19,r2
81121910:	98c6d83a 	srl	r3,r19,r3
81121914:	1004c03a 	cmpne	r2,r2,zero
81121918:	1884b03a 	or	r2,r3,r2
8112191c:	10c001cc 	andi	r3,r2,7
81121920:	18000426 	beq	r3,zero,81121934 <__mulsf3+0x3b8>
81121924:	10c003cc 	andi	r3,r2,15
81121928:	01000104 	movi	r4,4
8112192c:	19000126 	beq	r3,r4,81121934 <__mulsf3+0x3b8>
81121930:	1105883a 	add	r2,r2,r4
81121934:	10c1002c 	andhi	r3,r2,1024
81121938:	18000626 	beq	r3,zero,81121954 <__mulsf3+0x3d8>
8112193c:	a829883a 	mov	r20,r21
81121940:	00c00044 	movi	r3,1
81121944:	0009883a 	mov	r4,zero
81121948:	003f6106 	br	811216d0 <__reset+0xfb1016d0>
8112194c:	3821883a 	mov	r16,r7
81121950:	003fc506 	br	81121868 <__reset+0xfb101868>
81121954:	100491ba 	slli	r2,r2,6
81121958:	a829883a 	mov	r20,r21
8112195c:	0007883a 	mov	r3,zero
81121960:	1008d27a 	srli	r4,r2,9
81121964:	003f5a06 	br	811216d0 <__reset+0xfb1016d0>
81121968:	00802034 	movhi	r2,128
8112196c:	99001034 	orhi	r4,r19,64
81121970:	10bfffc4 	addi	r2,r2,-1
81121974:	a829883a 	mov	r20,r21
81121978:	2088703a 	and	r4,r4,r2
8112197c:	003f9206 	br	811217c8 <__reset+0xfb1017c8>

81121980 <__floatsisf>:
81121980:	defffd04 	addi	sp,sp,-12
81121984:	de00012e 	bgeu	sp,et,8112198c <__floatsisf+0xc>
81121988:	003b68fa 	trap	3
8112198c:	dfc00215 	stw	ra,8(sp)
81121990:	dc400115 	stw	r17,4(sp)
81121994:	dc000015 	stw	r16,0(sp)
81121998:	20003526 	beq	r4,zero,81121a70 <__floatsisf+0xf0>
8112199c:	2021883a 	mov	r16,r4
811219a0:	2022d7fa 	srli	r17,r4,31
811219a4:	20003616 	blt	r4,zero,81121a80 <__floatsisf+0x100>
811219a8:	8009883a 	mov	r4,r16
811219ac:	11230c80 	call	811230c8 <__clzsi2>
811219b0:	00c02784 	movi	r3,158
811219b4:	1887c83a 	sub	r3,r3,r2
811219b8:	01002584 	movi	r4,150
811219bc:	20c01416 	blt	r4,r3,81121a10 <__floatsisf+0x90>
811219c0:	20c9c83a 	sub	r4,r4,r3
811219c4:	8120983a 	sll	r16,r16,r4
811219c8:	00802034 	movhi	r2,128
811219cc:	10bfffc4 	addi	r2,r2,-1
811219d0:	8809883a 	mov	r4,r17
811219d4:	80a0703a 	and	r16,r16,r2
811219d8:	18803fcc 	andi	r2,r3,255
811219dc:	100695fa 	slli	r3,r2,23
811219e0:	20803fcc 	andi	r2,r4,255
811219e4:	100897fa 	slli	r4,r2,31
811219e8:	00802034 	movhi	r2,128
811219ec:	10bfffc4 	addi	r2,r2,-1
811219f0:	8084703a 	and	r2,r16,r2
811219f4:	10c4b03a 	or	r2,r2,r3
811219f8:	1104b03a 	or	r2,r2,r4
811219fc:	dfc00217 	ldw	ra,8(sp)
81121a00:	dc400117 	ldw	r17,4(sp)
81121a04:	dc000017 	ldw	r16,0(sp)
81121a08:	dec00304 	addi	sp,sp,12
81121a0c:	f800283a 	ret
81121a10:	01002644 	movi	r4,153
81121a14:	20c01c16 	blt	r4,r3,81121a88 <__floatsisf+0x108>
81121a18:	20c9c83a 	sub	r4,r4,r3
81121a1c:	8120983a 	sll	r16,r16,r4
81121a20:	013f0034 	movhi	r4,64512
81121a24:	213fffc4 	addi	r4,r4,-1
81121a28:	814001cc 	andi	r5,r16,7
81121a2c:	8108703a 	and	r4,r16,r4
81121a30:	28000426 	beq	r5,zero,81121a44 <__floatsisf+0xc4>
81121a34:	840003cc 	andi	r16,r16,15
81121a38:	01400104 	movi	r5,4
81121a3c:	81400126 	beq	r16,r5,81121a44 <__floatsisf+0xc4>
81121a40:	2149883a 	add	r4,r4,r5
81121a44:	2141002c 	andhi	r5,r4,1024
81121a48:	28000526 	beq	r5,zero,81121a60 <__floatsisf+0xe0>
81121a4c:	00c027c4 	movi	r3,159
81121a50:	1887c83a 	sub	r3,r3,r2
81121a54:	00bf0034 	movhi	r2,64512
81121a58:	10bfffc4 	addi	r2,r2,-1
81121a5c:	2088703a 	and	r4,r4,r2
81121a60:	202091ba 	slli	r16,r4,6
81121a64:	8809883a 	mov	r4,r17
81121a68:	8020d27a 	srli	r16,r16,9
81121a6c:	003fda06 	br	811219d8 <__reset+0xfb1019d8>
81121a70:	0009883a 	mov	r4,zero
81121a74:	0007883a 	mov	r3,zero
81121a78:	0021883a 	mov	r16,zero
81121a7c:	003fd606 	br	811219d8 <__reset+0xfb1019d8>
81121a80:	0121c83a 	sub	r16,zero,r4
81121a84:	003fc806 	br	811219a8 <__reset+0xfb1019a8>
81121a88:	01002e44 	movi	r4,185
81121a8c:	20c9c83a 	sub	r4,r4,r3
81121a90:	01400144 	movi	r5,5
81121a94:	8108983a 	sll	r4,r16,r4
81121a98:	288bc83a 	sub	r5,r5,r2
81121a9c:	8160d83a 	srl	r16,r16,r5
81121aa0:	2008c03a 	cmpne	r4,r4,zero
81121aa4:	8120b03a 	or	r16,r16,r4
81121aa8:	003fdd06 	br	81121a20 <__reset+0xfb101a20>

81121aac <__floatunsisf>:
81121aac:	defffe04 	addi	sp,sp,-8
81121ab0:	de00012e 	bgeu	sp,et,81121ab8 <__floatunsisf+0xc>
81121ab4:	003b68fa 	trap	3
81121ab8:	dfc00115 	stw	ra,4(sp)
81121abc:	dc000015 	stw	r16,0(sp)
81121ac0:	20002c26 	beq	r4,zero,81121b74 <__floatunsisf+0xc8>
81121ac4:	2021883a 	mov	r16,r4
81121ac8:	11230c80 	call	811230c8 <__clzsi2>
81121acc:	00c02784 	movi	r3,158
81121ad0:	1887c83a 	sub	r3,r3,r2
81121ad4:	01002584 	movi	r4,150
81121ad8:	20c00f16 	blt	r4,r3,81121b18 <__floatunsisf+0x6c>
81121adc:	20c9c83a 	sub	r4,r4,r3
81121ae0:	8108983a 	sll	r4,r16,r4
81121ae4:	00802034 	movhi	r2,128
81121ae8:	10bfffc4 	addi	r2,r2,-1
81121aec:	2088703a 	and	r4,r4,r2
81121af0:	18803fcc 	andi	r2,r3,255
81121af4:	100695fa 	slli	r3,r2,23
81121af8:	00802034 	movhi	r2,128
81121afc:	10bfffc4 	addi	r2,r2,-1
81121b00:	2084703a 	and	r2,r4,r2
81121b04:	10c4b03a 	or	r2,r2,r3
81121b08:	dfc00117 	ldw	ra,4(sp)
81121b0c:	dc000017 	ldw	r16,0(sp)
81121b10:	dec00204 	addi	sp,sp,8
81121b14:	f800283a 	ret
81121b18:	01002644 	movi	r4,153
81121b1c:	20c01816 	blt	r4,r3,81121b80 <__floatunsisf+0xd4>
81121b20:	20c9c83a 	sub	r4,r4,r3
81121b24:	8108983a 	sll	r4,r16,r4
81121b28:	017f0034 	movhi	r5,64512
81121b2c:	297fffc4 	addi	r5,r5,-1
81121b30:	218001cc 	andi	r6,r4,7
81121b34:	214a703a 	and	r5,r4,r5
81121b38:	30000426 	beq	r6,zero,81121b4c <__floatunsisf+0xa0>
81121b3c:	210003cc 	andi	r4,r4,15
81121b40:	01800104 	movi	r6,4
81121b44:	21800126 	beq	r4,r6,81121b4c <__floatunsisf+0xa0>
81121b48:	298b883a 	add	r5,r5,r6
81121b4c:	2901002c 	andhi	r4,r5,1024
81121b50:	20000526 	beq	r4,zero,81121b68 <__floatunsisf+0xbc>
81121b54:	00c027c4 	movi	r3,159
81121b58:	1887c83a 	sub	r3,r3,r2
81121b5c:	00bf0034 	movhi	r2,64512
81121b60:	10bfffc4 	addi	r2,r2,-1
81121b64:	288a703a 	and	r5,r5,r2
81121b68:	280891ba 	slli	r4,r5,6
81121b6c:	2008d27a 	srli	r4,r4,9
81121b70:	003fdf06 	br	81121af0 <__reset+0xfb101af0>
81121b74:	0007883a 	mov	r3,zero
81121b78:	0009883a 	mov	r4,zero
81121b7c:	003fdc06 	br	81121af0 <__reset+0xfb101af0>
81121b80:	01402e44 	movi	r5,185
81121b84:	28cbc83a 	sub	r5,r5,r3
81121b88:	01000144 	movi	r4,5
81121b8c:	2089c83a 	sub	r4,r4,r2
81121b90:	814a983a 	sll	r5,r16,r5
81121b94:	8108d83a 	srl	r4,r16,r4
81121b98:	2820c03a 	cmpne	r16,r5,zero
81121b9c:	2408b03a 	or	r4,r4,r16
81121ba0:	003fe106 	br	81121b28 <__reset+0xfb101b28>

81121ba4 <__gedf2>:
81121ba4:	2804d53a 	srli	r2,r5,20
81121ba8:	3806d53a 	srli	r3,r7,20
81121bac:	02000434 	movhi	r8,16
81121bb0:	423fffc4 	addi	r8,r8,-1
81121bb4:	1081ffcc 	andi	r2,r2,2047
81121bb8:	0241ffc4 	movi	r9,2047
81121bbc:	2a14703a 	and	r10,r5,r8
81121bc0:	18c1ffcc 	andi	r3,r3,2047
81121bc4:	3a10703a 	and	r8,r7,r8
81121bc8:	280ad7fa 	srli	r5,r5,31
81121bcc:	380ed7fa 	srli	r7,r7,31
81121bd0:	12401d26 	beq	r2,r9,81121c48 <__gedf2+0xa4>
81121bd4:	0241ffc4 	movi	r9,2047
81121bd8:	1a401226 	beq	r3,r9,81121c24 <__gedf2+0x80>
81121bdc:	1000081e 	bne	r2,zero,81121c00 <__gedf2+0x5c>
81121be0:	2296b03a 	or	r11,r4,r10
81121be4:	5813003a 	cmpeq	r9,r11,zero
81121be8:	1800091e 	bne	r3,zero,81121c10 <__gedf2+0x6c>
81121bec:	3218b03a 	or	r12,r6,r8
81121bf0:	6000071e 	bne	r12,zero,81121c10 <__gedf2+0x6c>
81121bf4:	0005883a 	mov	r2,zero
81121bf8:	5800101e 	bne	r11,zero,81121c3c <__gedf2+0x98>
81121bfc:	f800283a 	ret
81121c00:	18000c1e 	bne	r3,zero,81121c34 <__gedf2+0x90>
81121c04:	3212b03a 	or	r9,r6,r8
81121c08:	48000c26 	beq	r9,zero,81121c3c <__gedf2+0x98>
81121c0c:	0013883a 	mov	r9,zero
81121c10:	39c03fcc 	andi	r7,r7,255
81121c14:	48000826 	beq	r9,zero,81121c38 <__gedf2+0x94>
81121c18:	38000926 	beq	r7,zero,81121c40 <__gedf2+0x9c>
81121c1c:	00800044 	movi	r2,1
81121c20:	f800283a 	ret
81121c24:	3212b03a 	or	r9,r6,r8
81121c28:	483fec26 	beq	r9,zero,81121bdc <__reset+0xfb101bdc>
81121c2c:	00bfff84 	movi	r2,-2
81121c30:	f800283a 	ret
81121c34:	39c03fcc 	andi	r7,r7,255
81121c38:	29c00626 	beq	r5,r7,81121c54 <__gedf2+0xb0>
81121c3c:	283ff726 	beq	r5,zero,81121c1c <__reset+0xfb101c1c>
81121c40:	00bfffc4 	movi	r2,-1
81121c44:	f800283a 	ret
81121c48:	2292b03a 	or	r9,r4,r10
81121c4c:	483fe126 	beq	r9,zero,81121bd4 <__reset+0xfb101bd4>
81121c50:	003ff606 	br	81121c2c <__reset+0xfb101c2c>
81121c54:	18bff916 	blt	r3,r2,81121c3c <__reset+0xfb101c3c>
81121c58:	10c00316 	blt	r2,r3,81121c68 <__gedf2+0xc4>
81121c5c:	42bff736 	bltu	r8,r10,81121c3c <__reset+0xfb101c3c>
81121c60:	52000326 	beq	r10,r8,81121c70 <__gedf2+0xcc>
81121c64:	5200042e 	bgeu	r10,r8,81121c78 <__gedf2+0xd4>
81121c68:	283fec1e 	bne	r5,zero,81121c1c <__reset+0xfb101c1c>
81121c6c:	003ff406 	br	81121c40 <__reset+0xfb101c40>
81121c70:	313ff236 	bltu	r6,r4,81121c3c <__reset+0xfb101c3c>
81121c74:	21bffc36 	bltu	r4,r6,81121c68 <__reset+0xfb101c68>
81121c78:	0005883a 	mov	r2,zero
81121c7c:	f800283a 	ret

81121c80 <__muldf3>:
81121c80:	defff304 	addi	sp,sp,-52
81121c84:	2804d53a 	srli	r2,r5,20
81121c88:	de00012e 	bgeu	sp,et,81121c90 <__muldf3+0x10>
81121c8c:	003b68fa 	trap	3
81121c90:	dd800915 	stw	r22,36(sp)
81121c94:	282cd7fa 	srli	r22,r5,31
81121c98:	dc000315 	stw	r16,12(sp)
81121c9c:	04000434 	movhi	r16,16
81121ca0:	dd400815 	stw	r21,32(sp)
81121ca4:	dc800515 	stw	r18,20(sp)
81121ca8:	843fffc4 	addi	r16,r16,-1
81121cac:	dfc00c15 	stw	ra,48(sp)
81121cb0:	df000b15 	stw	fp,44(sp)
81121cb4:	ddc00a15 	stw	r23,40(sp)
81121cb8:	dd000715 	stw	r20,28(sp)
81121cbc:	dcc00615 	stw	r19,24(sp)
81121cc0:	dc400415 	stw	r17,16(sp)
81121cc4:	1481ffcc 	andi	r18,r2,2047
81121cc8:	2c20703a 	and	r16,r5,r16
81121ccc:	b02b883a 	mov	r21,r22
81121cd0:	b2403fcc 	andi	r9,r22,255
81121cd4:	90006026 	beq	r18,zero,81121e58 <__muldf3+0x1d8>
81121cd8:	0081ffc4 	movi	r2,2047
81121cdc:	2029883a 	mov	r20,r4
81121ce0:	90803626 	beq	r18,r2,81121dbc <__muldf3+0x13c>
81121ce4:	80800434 	orhi	r2,r16,16
81121ce8:	100490fa 	slli	r2,r2,3
81121cec:	2020d77a 	srli	r16,r4,29
81121cf0:	202890fa 	slli	r20,r4,3
81121cf4:	94bf0044 	addi	r18,r18,-1023
81121cf8:	80a0b03a 	or	r16,r16,r2
81121cfc:	0027883a 	mov	r19,zero
81121d00:	0039883a 	mov	fp,zero
81121d04:	3804d53a 	srli	r2,r7,20
81121d08:	382ed7fa 	srli	r23,r7,31
81121d0c:	04400434 	movhi	r17,16
81121d10:	8c7fffc4 	addi	r17,r17,-1
81121d14:	1081ffcc 	andi	r2,r2,2047
81121d18:	3011883a 	mov	r8,r6
81121d1c:	3c62703a 	and	r17,r7,r17
81121d20:	ba803fcc 	andi	r10,r23,255
81121d24:	10006d26 	beq	r2,zero,81121edc <__muldf3+0x25c>
81121d28:	00c1ffc4 	movi	r3,2047
81121d2c:	10c06526 	beq	r2,r3,81121ec4 <__muldf3+0x244>
81121d30:	88c00434 	orhi	r3,r17,16
81121d34:	180690fa 	slli	r3,r3,3
81121d38:	3022d77a 	srli	r17,r6,29
81121d3c:	301090fa 	slli	r8,r6,3
81121d40:	10bf0044 	addi	r2,r2,-1023
81121d44:	88e2b03a 	or	r17,r17,r3
81121d48:	000b883a 	mov	r5,zero
81121d4c:	9085883a 	add	r2,r18,r2
81121d50:	2cc8b03a 	or	r4,r5,r19
81121d54:	00c003c4 	movi	r3,15
81121d58:	bdacf03a 	xor	r22,r23,r22
81121d5c:	12c00044 	addi	r11,r2,1
81121d60:	19009936 	bltu	r3,r4,81121fc8 <__muldf3+0x348>
81121d64:	200890ba 	slli	r4,r4,2
81121d68:	00e044b4 	movhi	r3,33042
81121d6c:	18c75f04 	addi	r3,r3,7548
81121d70:	20c9883a 	add	r4,r4,r3
81121d74:	20c00017 	ldw	r3,0(r4)
81121d78:	1800683a 	jmp	r3
81121d7c:	81121fc8 	cmpgei	r4,r16,18559
81121d80:	81121ddc 	xori	r4,r16,18551
81121d84:	81121ddc 	xori	r4,r16,18551
81121d88:	81121dd8 	cmpnei	r4,r16,18551
81121d8c:	81121fa4 	muli	r4,r16,18558
81121d90:	81121fa4 	muli	r4,r16,18558
81121d94:	81121f8c 	andi	r4,r16,18558
81121d98:	81121dd8 	cmpnei	r4,r16,18551
81121d9c:	81121fa4 	muli	r4,r16,18558
81121da0:	81121f8c 	andi	r4,r16,18558
81121da4:	81121fa4 	muli	r4,r16,18558
81121da8:	81121dd8 	cmpnei	r4,r16,18551
81121dac:	81121fb4 	orhi	r4,r16,18558
81121db0:	81121fb4 	orhi	r4,r16,18558
81121db4:	81121fb4 	orhi	r4,r16,18558
81121db8:	811221d0 	cmplti	r4,r16,18567
81121dbc:	2404b03a 	or	r2,r4,r16
81121dc0:	10006f1e 	bne	r2,zero,81121f80 <__muldf3+0x300>
81121dc4:	04c00204 	movi	r19,8
81121dc8:	0021883a 	mov	r16,zero
81121dcc:	0029883a 	mov	r20,zero
81121dd0:	07000084 	movi	fp,2
81121dd4:	003fcb06 	br	81121d04 <__reset+0xfb101d04>
81121dd8:	502d883a 	mov	r22,r10
81121ddc:	00800084 	movi	r2,2
81121de0:	28805726 	beq	r5,r2,81121f40 <__muldf3+0x2c0>
81121de4:	008000c4 	movi	r2,3
81121de8:	28816626 	beq	r5,r2,81122384 <__muldf3+0x704>
81121dec:	00800044 	movi	r2,1
81121df0:	2881411e 	bne	r5,r2,811222f8 <__muldf3+0x678>
81121df4:	b02b883a 	mov	r21,r22
81121df8:	0005883a 	mov	r2,zero
81121dfc:	000b883a 	mov	r5,zero
81121e00:	0029883a 	mov	r20,zero
81121e04:	1004953a 	slli	r2,r2,20
81121e08:	a8c03fcc 	andi	r3,r21,255
81121e0c:	04400434 	movhi	r17,16
81121e10:	8c7fffc4 	addi	r17,r17,-1
81121e14:	180697fa 	slli	r3,r3,31
81121e18:	2c4a703a 	and	r5,r5,r17
81121e1c:	288ab03a 	or	r5,r5,r2
81121e20:	28c6b03a 	or	r3,r5,r3
81121e24:	a005883a 	mov	r2,r20
81121e28:	dfc00c17 	ldw	ra,48(sp)
81121e2c:	df000b17 	ldw	fp,44(sp)
81121e30:	ddc00a17 	ldw	r23,40(sp)
81121e34:	dd800917 	ldw	r22,36(sp)
81121e38:	dd400817 	ldw	r21,32(sp)
81121e3c:	dd000717 	ldw	r20,28(sp)
81121e40:	dcc00617 	ldw	r19,24(sp)
81121e44:	dc800517 	ldw	r18,20(sp)
81121e48:	dc400417 	ldw	r17,16(sp)
81121e4c:	dc000317 	ldw	r16,12(sp)
81121e50:	dec00d04 	addi	sp,sp,52
81121e54:	f800283a 	ret
81121e58:	2404b03a 	or	r2,r4,r16
81121e5c:	2027883a 	mov	r19,r4
81121e60:	10004226 	beq	r2,zero,81121f6c <__muldf3+0x2ec>
81121e64:	8000fc26 	beq	r16,zero,81122258 <__muldf3+0x5d8>
81121e68:	8009883a 	mov	r4,r16
81121e6c:	d9800215 	stw	r6,8(sp)
81121e70:	d9c00015 	stw	r7,0(sp)
81121e74:	da400115 	stw	r9,4(sp)
81121e78:	11230c80 	call	811230c8 <__clzsi2>
81121e7c:	d9800217 	ldw	r6,8(sp)
81121e80:	d9c00017 	ldw	r7,0(sp)
81121e84:	da400117 	ldw	r9,4(sp)
81121e88:	113ffd44 	addi	r4,r2,-11
81121e8c:	00c00704 	movi	r3,28
81121e90:	1900ed16 	blt	r3,r4,81122248 <__muldf3+0x5c8>
81121e94:	00c00744 	movi	r3,29
81121e98:	147ffe04 	addi	r17,r2,-8
81121e9c:	1907c83a 	sub	r3,r3,r4
81121ea0:	8460983a 	sll	r16,r16,r17
81121ea4:	98c6d83a 	srl	r3,r19,r3
81121ea8:	9c68983a 	sll	r20,r19,r17
81121eac:	1c20b03a 	or	r16,r3,r16
81121eb0:	1080fcc4 	addi	r2,r2,1011
81121eb4:	00a5c83a 	sub	r18,zero,r2
81121eb8:	0027883a 	mov	r19,zero
81121ebc:	0039883a 	mov	fp,zero
81121ec0:	003f9006 	br	81121d04 <__reset+0xfb101d04>
81121ec4:	3446b03a 	or	r3,r6,r17
81121ec8:	1800261e 	bne	r3,zero,81121f64 <__muldf3+0x2e4>
81121ecc:	0023883a 	mov	r17,zero
81121ed0:	0011883a 	mov	r8,zero
81121ed4:	01400084 	movi	r5,2
81121ed8:	003f9c06 	br	81121d4c <__reset+0xfb101d4c>
81121edc:	3446b03a 	or	r3,r6,r17
81121ee0:	18001c26 	beq	r3,zero,81121f54 <__muldf3+0x2d4>
81121ee4:	8800ce26 	beq	r17,zero,81122220 <__muldf3+0x5a0>
81121ee8:	8809883a 	mov	r4,r17
81121eec:	d9800215 	stw	r6,8(sp)
81121ef0:	da400115 	stw	r9,4(sp)
81121ef4:	da800015 	stw	r10,0(sp)
81121ef8:	11230c80 	call	811230c8 <__clzsi2>
81121efc:	d9800217 	ldw	r6,8(sp)
81121f00:	da400117 	ldw	r9,4(sp)
81121f04:	da800017 	ldw	r10,0(sp)
81121f08:	113ffd44 	addi	r4,r2,-11
81121f0c:	00c00704 	movi	r3,28
81121f10:	1900bf16 	blt	r3,r4,81122210 <__muldf3+0x590>
81121f14:	00c00744 	movi	r3,29
81121f18:	123ffe04 	addi	r8,r2,-8
81121f1c:	1907c83a 	sub	r3,r3,r4
81121f20:	8a22983a 	sll	r17,r17,r8
81121f24:	30c6d83a 	srl	r3,r6,r3
81121f28:	3210983a 	sll	r8,r6,r8
81121f2c:	1c62b03a 	or	r17,r3,r17
81121f30:	1080fcc4 	addi	r2,r2,1011
81121f34:	0085c83a 	sub	r2,zero,r2
81121f38:	000b883a 	mov	r5,zero
81121f3c:	003f8306 	br	81121d4c <__reset+0xfb101d4c>
81121f40:	b02b883a 	mov	r21,r22
81121f44:	0081ffc4 	movi	r2,2047
81121f48:	000b883a 	mov	r5,zero
81121f4c:	0029883a 	mov	r20,zero
81121f50:	003fac06 	br	81121e04 <__reset+0xfb101e04>
81121f54:	0023883a 	mov	r17,zero
81121f58:	0011883a 	mov	r8,zero
81121f5c:	01400044 	movi	r5,1
81121f60:	003f7a06 	br	81121d4c <__reset+0xfb101d4c>
81121f64:	014000c4 	movi	r5,3
81121f68:	003f7806 	br	81121d4c <__reset+0xfb101d4c>
81121f6c:	04c00104 	movi	r19,4
81121f70:	0021883a 	mov	r16,zero
81121f74:	0029883a 	mov	r20,zero
81121f78:	07000044 	movi	fp,1
81121f7c:	003f6106 	br	81121d04 <__reset+0xfb101d04>
81121f80:	04c00304 	movi	r19,12
81121f84:	070000c4 	movi	fp,3
81121f88:	003f5e06 	br	81121d04 <__reset+0xfb101d04>
81121f8c:	01400434 	movhi	r5,16
81121f90:	002b883a 	mov	r21,zero
81121f94:	297fffc4 	addi	r5,r5,-1
81121f98:	053fffc4 	movi	r20,-1
81121f9c:	0081ffc4 	movi	r2,2047
81121fa0:	003f9806 	br	81121e04 <__reset+0xfb101e04>
81121fa4:	8023883a 	mov	r17,r16
81121fa8:	a011883a 	mov	r8,r20
81121fac:	e00b883a 	mov	r5,fp
81121fb0:	003f8a06 	br	81121ddc <__reset+0xfb101ddc>
81121fb4:	8023883a 	mov	r17,r16
81121fb8:	a011883a 	mov	r8,r20
81121fbc:	482d883a 	mov	r22,r9
81121fc0:	e00b883a 	mov	r5,fp
81121fc4:	003f8506 	br	81121ddc <__reset+0xfb101ddc>
81121fc8:	a00ad43a 	srli	r5,r20,16
81121fcc:	401ad43a 	srli	r13,r8,16
81121fd0:	a53fffcc 	andi	r20,r20,65535
81121fd4:	423fffcc 	andi	r8,r8,65535
81121fd8:	4519383a 	mul	r12,r8,r20
81121fdc:	4147383a 	mul	r3,r8,r5
81121fe0:	6d09383a 	mul	r4,r13,r20
81121fe4:	600cd43a 	srli	r6,r12,16
81121fe8:	2b5d383a 	mul	r14,r5,r13
81121fec:	20c9883a 	add	r4,r4,r3
81121ff0:	310d883a 	add	r6,r6,r4
81121ff4:	30c0022e 	bgeu	r6,r3,81122000 <__muldf3+0x380>
81121ff8:	00c00074 	movhi	r3,1
81121ffc:	70dd883a 	add	r14,r14,r3
81122000:	8826d43a 	srli	r19,r17,16
81122004:	8bffffcc 	andi	r15,r17,65535
81122008:	7d23383a 	mul	r17,r15,r20
8112200c:	7949383a 	mul	r4,r15,r5
81122010:	9d29383a 	mul	r20,r19,r20
81122014:	8814d43a 	srli	r10,r17,16
81122018:	3012943a 	slli	r9,r6,16
8112201c:	a129883a 	add	r20,r20,r4
81122020:	633fffcc 	andi	r12,r12,65535
81122024:	5515883a 	add	r10,r10,r20
81122028:	3006d43a 	srli	r3,r6,16
8112202c:	4b13883a 	add	r9,r9,r12
81122030:	2ccb383a 	mul	r5,r5,r19
81122034:	5100022e 	bgeu	r10,r4,81122040 <__muldf3+0x3c0>
81122038:	01000074 	movhi	r4,1
8112203c:	290b883a 	add	r5,r5,r4
81122040:	802ad43a 	srli	r21,r16,16
81122044:	843fffcc 	andi	r16,r16,65535
81122048:	440d383a 	mul	r6,r8,r16
8112204c:	4565383a 	mul	r18,r8,r21
81122050:	8349383a 	mul	r4,r16,r13
81122054:	500e943a 	slli	r7,r10,16
81122058:	3010d43a 	srli	r8,r6,16
8112205c:	5028d43a 	srli	r20,r10,16
81122060:	2489883a 	add	r4,r4,r18
81122064:	8abfffcc 	andi	r10,r17,65535
81122068:	3a95883a 	add	r10,r7,r10
8112206c:	4119883a 	add	r12,r8,r4
81122070:	a169883a 	add	r20,r20,r5
81122074:	1a87883a 	add	r3,r3,r10
81122078:	6d5b383a 	mul	r13,r13,r21
8112207c:	6480022e 	bgeu	r12,r18,81122088 <__muldf3+0x408>
81122080:	01000074 	movhi	r4,1
81122084:	691b883a 	add	r13,r13,r4
81122088:	7c25383a 	mul	r18,r15,r16
8112208c:	7d4b383a 	mul	r5,r15,r21
81122090:	84cf383a 	mul	r7,r16,r19
81122094:	901ed43a 	srli	r15,r18,16
81122098:	6008d43a 	srli	r4,r12,16
8112209c:	6010943a 	slli	r8,r12,16
811220a0:	394f883a 	add	r7,r7,r5
811220a4:	333fffcc 	andi	r12,r6,65535
811220a8:	79df883a 	add	r15,r15,r7
811220ac:	235b883a 	add	r13,r4,r13
811220b0:	9d63383a 	mul	r17,r19,r21
811220b4:	4309883a 	add	r4,r8,r12
811220b8:	7940022e 	bgeu	r15,r5,811220c4 <__muldf3+0x444>
811220bc:	01400074 	movhi	r5,1
811220c0:	8963883a 	add	r17,r17,r5
811220c4:	780a943a 	slli	r5,r15,16
811220c8:	91bfffcc 	andi	r6,r18,65535
811220cc:	70c7883a 	add	r3,r14,r3
811220d0:	298d883a 	add	r6,r5,r6
811220d4:	1a8f803a 	cmpltu	r7,r3,r10
811220d8:	350b883a 	add	r5,r6,r20
811220dc:	20c7883a 	add	r3,r4,r3
811220e0:	3955883a 	add	r10,r7,r5
811220e4:	1909803a 	cmpltu	r4,r3,r4
811220e8:	6a91883a 	add	r8,r13,r10
811220ec:	780cd43a 	srli	r6,r15,16
811220f0:	2219883a 	add	r12,r4,r8
811220f4:	2d0b803a 	cmpltu	r5,r5,r20
811220f8:	51cf803a 	cmpltu	r7,r10,r7
811220fc:	29ceb03a 	or	r7,r5,r7
81122100:	4351803a 	cmpltu	r8,r8,r13
81122104:	610b803a 	cmpltu	r5,r12,r4
81122108:	4148b03a 	or	r4,r8,r5
8112210c:	398f883a 	add	r7,r7,r6
81122110:	3909883a 	add	r4,r7,r4
81122114:	1810927a 	slli	r8,r3,9
81122118:	2449883a 	add	r4,r4,r17
8112211c:	2008927a 	slli	r4,r4,9
81122120:	6022d5fa 	srli	r17,r12,23
81122124:	1806d5fa 	srli	r3,r3,23
81122128:	4252b03a 	or	r9,r8,r9
8112212c:	600a927a 	slli	r5,r12,9
81122130:	4810c03a 	cmpne	r8,r9,zero
81122134:	2462b03a 	or	r17,r4,r17
81122138:	40c6b03a 	or	r3,r8,r3
8112213c:	8900402c 	andhi	r4,r17,256
81122140:	1950b03a 	or	r8,r3,r5
81122144:	20000726 	beq	r4,zero,81122164 <__muldf3+0x4e4>
81122148:	4006d07a 	srli	r3,r8,1
8112214c:	880497fa 	slli	r2,r17,31
81122150:	4200004c 	andi	r8,r8,1
81122154:	8822d07a 	srli	r17,r17,1
81122158:	1a10b03a 	or	r8,r3,r8
8112215c:	1210b03a 	or	r8,r2,r8
81122160:	5805883a 	mov	r2,r11
81122164:	1140ffc4 	addi	r5,r2,1023
81122168:	0140440e 	bge	zero,r5,8112227c <__muldf3+0x5fc>
8112216c:	40c001cc 	andi	r3,r8,7
81122170:	18000726 	beq	r3,zero,81122190 <__muldf3+0x510>
81122174:	40c003cc 	andi	r3,r8,15
81122178:	01000104 	movi	r4,4
8112217c:	19000426 	beq	r3,r4,81122190 <__muldf3+0x510>
81122180:	4107883a 	add	r3,r8,r4
81122184:	1a11803a 	cmpltu	r8,r3,r8
81122188:	8a23883a 	add	r17,r17,r8
8112218c:	1811883a 	mov	r8,r3
81122190:	88c0402c 	andhi	r3,r17,256
81122194:	18000426 	beq	r3,zero,811221a8 <__muldf3+0x528>
81122198:	11410004 	addi	r5,r2,1024
8112219c:	00bfc034 	movhi	r2,65280
811221a0:	10bfffc4 	addi	r2,r2,-1
811221a4:	88a2703a 	and	r17,r17,r2
811221a8:	0081ff84 	movi	r2,2046
811221ac:	117f6416 	blt	r2,r5,81121f40 <__reset+0xfb101f40>
811221b0:	8828977a 	slli	r20,r17,29
811221b4:	4010d0fa 	srli	r8,r8,3
811221b8:	8822927a 	slli	r17,r17,9
811221bc:	2881ffcc 	andi	r2,r5,2047
811221c0:	a228b03a 	or	r20,r20,r8
811221c4:	880ad33a 	srli	r5,r17,12
811221c8:	b02b883a 	mov	r21,r22
811221cc:	003f0d06 	br	81121e04 <__reset+0xfb101e04>
811221d0:	8080022c 	andhi	r2,r16,8
811221d4:	10000926 	beq	r2,zero,811221fc <__muldf3+0x57c>
811221d8:	8880022c 	andhi	r2,r17,8
811221dc:	1000071e 	bne	r2,zero,811221fc <__muldf3+0x57c>
811221e0:	00800434 	movhi	r2,16
811221e4:	89400234 	orhi	r5,r17,8
811221e8:	10bfffc4 	addi	r2,r2,-1
811221ec:	b82b883a 	mov	r21,r23
811221f0:	288a703a 	and	r5,r5,r2
811221f4:	4029883a 	mov	r20,r8
811221f8:	003f6806 	br	81121f9c <__reset+0xfb101f9c>
811221fc:	00800434 	movhi	r2,16
81122200:	81400234 	orhi	r5,r16,8
81122204:	10bfffc4 	addi	r2,r2,-1
81122208:	288a703a 	and	r5,r5,r2
8112220c:	003f6306 	br	81121f9c <__reset+0xfb101f9c>
81122210:	147ff604 	addi	r17,r2,-40
81122214:	3462983a 	sll	r17,r6,r17
81122218:	0011883a 	mov	r8,zero
8112221c:	003f4406 	br	81121f30 <__reset+0xfb101f30>
81122220:	3009883a 	mov	r4,r6
81122224:	d9800215 	stw	r6,8(sp)
81122228:	da400115 	stw	r9,4(sp)
8112222c:	da800015 	stw	r10,0(sp)
81122230:	11230c80 	call	811230c8 <__clzsi2>
81122234:	10800804 	addi	r2,r2,32
81122238:	da800017 	ldw	r10,0(sp)
8112223c:	da400117 	ldw	r9,4(sp)
81122240:	d9800217 	ldw	r6,8(sp)
81122244:	003f3006 	br	81121f08 <__reset+0xfb101f08>
81122248:	143ff604 	addi	r16,r2,-40
8112224c:	9c20983a 	sll	r16,r19,r16
81122250:	0029883a 	mov	r20,zero
81122254:	003f1606 	br	81121eb0 <__reset+0xfb101eb0>
81122258:	d9800215 	stw	r6,8(sp)
8112225c:	d9c00015 	stw	r7,0(sp)
81122260:	da400115 	stw	r9,4(sp)
81122264:	11230c80 	call	811230c8 <__clzsi2>
81122268:	10800804 	addi	r2,r2,32
8112226c:	da400117 	ldw	r9,4(sp)
81122270:	d9c00017 	ldw	r7,0(sp)
81122274:	d9800217 	ldw	r6,8(sp)
81122278:	003f0306 	br	81121e88 <__reset+0xfb101e88>
8112227c:	00c00044 	movi	r3,1
81122280:	1947c83a 	sub	r3,r3,r5
81122284:	00800e04 	movi	r2,56
81122288:	10feda16 	blt	r2,r3,81121df4 <__reset+0xfb101df4>
8112228c:	008007c4 	movi	r2,31
81122290:	10c01b16 	blt	r2,r3,81122300 <__muldf3+0x680>
81122294:	00800804 	movi	r2,32
81122298:	10c5c83a 	sub	r2,r2,r3
8112229c:	888a983a 	sll	r5,r17,r2
811222a0:	40c8d83a 	srl	r4,r8,r3
811222a4:	4084983a 	sll	r2,r8,r2
811222a8:	88e2d83a 	srl	r17,r17,r3
811222ac:	2906b03a 	or	r3,r5,r4
811222b0:	1004c03a 	cmpne	r2,r2,zero
811222b4:	1886b03a 	or	r3,r3,r2
811222b8:	188001cc 	andi	r2,r3,7
811222bc:	10000726 	beq	r2,zero,811222dc <__muldf3+0x65c>
811222c0:	188003cc 	andi	r2,r3,15
811222c4:	01000104 	movi	r4,4
811222c8:	11000426 	beq	r2,r4,811222dc <__muldf3+0x65c>
811222cc:	1805883a 	mov	r2,r3
811222d0:	10c00104 	addi	r3,r2,4
811222d4:	1885803a 	cmpltu	r2,r3,r2
811222d8:	88a3883a 	add	r17,r17,r2
811222dc:	8880202c 	andhi	r2,r17,128
811222e0:	10001c26 	beq	r2,zero,81122354 <__muldf3+0x6d4>
811222e4:	b02b883a 	mov	r21,r22
811222e8:	00800044 	movi	r2,1
811222ec:	000b883a 	mov	r5,zero
811222f0:	0029883a 	mov	r20,zero
811222f4:	003ec306 	br	81121e04 <__reset+0xfb101e04>
811222f8:	5805883a 	mov	r2,r11
811222fc:	003f9906 	br	81122164 <__reset+0xfb102164>
81122300:	00bff844 	movi	r2,-31
81122304:	1145c83a 	sub	r2,r2,r5
81122308:	8888d83a 	srl	r4,r17,r2
8112230c:	00800804 	movi	r2,32
81122310:	18801a26 	beq	r3,r2,8112237c <__muldf3+0x6fc>
81122314:	00801004 	movi	r2,64
81122318:	10c5c83a 	sub	r2,r2,r3
8112231c:	8884983a 	sll	r2,r17,r2
81122320:	1204b03a 	or	r2,r2,r8
81122324:	1004c03a 	cmpne	r2,r2,zero
81122328:	2084b03a 	or	r2,r4,r2
8112232c:	144001cc 	andi	r17,r2,7
81122330:	88000d1e 	bne	r17,zero,81122368 <__muldf3+0x6e8>
81122334:	000b883a 	mov	r5,zero
81122338:	1028d0fa 	srli	r20,r2,3
8112233c:	b02b883a 	mov	r21,r22
81122340:	0005883a 	mov	r2,zero
81122344:	a468b03a 	or	r20,r20,r17
81122348:	003eae06 	br	81121e04 <__reset+0xfb101e04>
8112234c:	1007883a 	mov	r3,r2
81122350:	0023883a 	mov	r17,zero
81122354:	880a927a 	slli	r5,r17,9
81122358:	1805883a 	mov	r2,r3
8112235c:	8822977a 	slli	r17,r17,29
81122360:	280ad33a 	srli	r5,r5,12
81122364:	003ff406 	br	81122338 <__reset+0xfb102338>
81122368:	10c003cc 	andi	r3,r2,15
8112236c:	01000104 	movi	r4,4
81122370:	193ff626 	beq	r3,r4,8112234c <__reset+0xfb10234c>
81122374:	0023883a 	mov	r17,zero
81122378:	003fd506 	br	811222d0 <__reset+0xfb1022d0>
8112237c:	0005883a 	mov	r2,zero
81122380:	003fe706 	br	81122320 <__reset+0xfb102320>
81122384:	00800434 	movhi	r2,16
81122388:	89400234 	orhi	r5,r17,8
8112238c:	10bfffc4 	addi	r2,r2,-1
81122390:	b02b883a 	mov	r21,r22
81122394:	288a703a 	and	r5,r5,r2
81122398:	4029883a 	mov	r20,r8
8112239c:	003eff06 	br	81121f9c <__reset+0xfb101f9c>

811223a0 <__subdf3>:
811223a0:	02000434 	movhi	r8,16
811223a4:	423fffc4 	addi	r8,r8,-1
811223a8:	defffb04 	addi	sp,sp,-20
811223ac:	2a14703a 	and	r10,r5,r8
811223b0:	3812d53a 	srli	r9,r7,20
811223b4:	3a10703a 	and	r8,r7,r8
811223b8:	de00012e 	bgeu	sp,et,811223c0 <__subdf3+0x20>
811223bc:	003b68fa 	trap	3
811223c0:	2006d77a 	srli	r3,r4,29
811223c4:	3004d77a 	srli	r2,r6,29
811223c8:	dc000015 	stw	r16,0(sp)
811223cc:	501490fa 	slli	r10,r10,3
811223d0:	2820d53a 	srli	r16,r5,20
811223d4:	401090fa 	slli	r8,r8,3
811223d8:	dc800215 	stw	r18,8(sp)
811223dc:	dc400115 	stw	r17,4(sp)
811223e0:	dfc00415 	stw	ra,16(sp)
811223e4:	202290fa 	slli	r17,r4,3
811223e8:	dcc00315 	stw	r19,12(sp)
811223ec:	4a41ffcc 	andi	r9,r9,2047
811223f0:	0101ffc4 	movi	r4,2047
811223f4:	2824d7fa 	srli	r18,r5,31
811223f8:	8401ffcc 	andi	r16,r16,2047
811223fc:	50c6b03a 	or	r3,r10,r3
81122400:	380ed7fa 	srli	r7,r7,31
81122404:	408ab03a 	or	r5,r8,r2
81122408:	300c90fa 	slli	r6,r6,3
8112240c:	49009626 	beq	r9,r4,81122668 <__subdf3+0x2c8>
81122410:	39c0005c 	xori	r7,r7,1
81122414:	8245c83a 	sub	r2,r16,r9
81122418:	3c807426 	beq	r7,r18,811225ec <__subdf3+0x24c>
8112241c:	0080af0e 	bge	zero,r2,811226dc <__subdf3+0x33c>
81122420:	48002a1e 	bne	r9,zero,811224cc <__subdf3+0x12c>
81122424:	2988b03a 	or	r4,r5,r6
81122428:	20009a1e 	bne	r4,zero,81122694 <__subdf3+0x2f4>
8112242c:	888001cc 	andi	r2,r17,7
81122430:	10000726 	beq	r2,zero,81122450 <__subdf3+0xb0>
81122434:	888003cc 	andi	r2,r17,15
81122438:	01000104 	movi	r4,4
8112243c:	11000426 	beq	r2,r4,81122450 <__subdf3+0xb0>
81122440:	890b883a 	add	r5,r17,r4
81122444:	2c63803a 	cmpltu	r17,r5,r17
81122448:	1c47883a 	add	r3,r3,r17
8112244c:	2823883a 	mov	r17,r5
81122450:	1880202c 	andhi	r2,r3,128
81122454:	10005926 	beq	r2,zero,811225bc <__subdf3+0x21c>
81122458:	84000044 	addi	r16,r16,1
8112245c:	0081ffc4 	movi	r2,2047
81122460:	8080be26 	beq	r16,r2,8112275c <__subdf3+0x3bc>
81122464:	017fe034 	movhi	r5,65408
81122468:	297fffc4 	addi	r5,r5,-1
8112246c:	1946703a 	and	r3,r3,r5
81122470:	1804977a 	slli	r2,r3,29
81122474:	1806927a 	slli	r3,r3,9
81122478:	8822d0fa 	srli	r17,r17,3
8112247c:	8401ffcc 	andi	r16,r16,2047
81122480:	180ad33a 	srli	r5,r3,12
81122484:	9100004c 	andi	r4,r18,1
81122488:	1444b03a 	or	r2,r2,r17
8112248c:	80c1ffcc 	andi	r3,r16,2047
81122490:	1820953a 	slli	r16,r3,20
81122494:	20c03fcc 	andi	r3,r4,255
81122498:	180897fa 	slli	r4,r3,31
8112249c:	00c00434 	movhi	r3,16
811224a0:	18ffffc4 	addi	r3,r3,-1
811224a4:	28c6703a 	and	r3,r5,r3
811224a8:	1c06b03a 	or	r3,r3,r16
811224ac:	1906b03a 	or	r3,r3,r4
811224b0:	dfc00417 	ldw	ra,16(sp)
811224b4:	dcc00317 	ldw	r19,12(sp)
811224b8:	dc800217 	ldw	r18,8(sp)
811224bc:	dc400117 	ldw	r17,4(sp)
811224c0:	dc000017 	ldw	r16,0(sp)
811224c4:	dec00504 	addi	sp,sp,20
811224c8:	f800283a 	ret
811224cc:	0101ffc4 	movi	r4,2047
811224d0:	813fd626 	beq	r16,r4,8112242c <__reset+0xfb10242c>
811224d4:	29402034 	orhi	r5,r5,128
811224d8:	01000e04 	movi	r4,56
811224dc:	2080a316 	blt	r4,r2,8112276c <__subdf3+0x3cc>
811224e0:	010007c4 	movi	r4,31
811224e4:	2080c616 	blt	r4,r2,81122800 <__subdf3+0x460>
811224e8:	01000804 	movi	r4,32
811224ec:	2089c83a 	sub	r4,r4,r2
811224f0:	2910983a 	sll	r8,r5,r4
811224f4:	308ed83a 	srl	r7,r6,r2
811224f8:	3108983a 	sll	r4,r6,r4
811224fc:	2884d83a 	srl	r2,r5,r2
81122500:	41ccb03a 	or	r6,r8,r7
81122504:	2008c03a 	cmpne	r4,r4,zero
81122508:	310cb03a 	or	r6,r6,r4
8112250c:	898dc83a 	sub	r6,r17,r6
81122510:	89a3803a 	cmpltu	r17,r17,r6
81122514:	1887c83a 	sub	r3,r3,r2
81122518:	1c47c83a 	sub	r3,r3,r17
8112251c:	3023883a 	mov	r17,r6
81122520:	1880202c 	andhi	r2,r3,128
81122524:	10002326 	beq	r2,zero,811225b4 <__subdf3+0x214>
81122528:	04c02034 	movhi	r19,128
8112252c:	9cffffc4 	addi	r19,r19,-1
81122530:	1ce6703a 	and	r19,r3,r19
81122534:	98007a26 	beq	r19,zero,81122720 <__subdf3+0x380>
81122538:	9809883a 	mov	r4,r19
8112253c:	11230c80 	call	811230c8 <__clzsi2>
81122540:	113ffe04 	addi	r4,r2,-8
81122544:	00c007c4 	movi	r3,31
81122548:	19007b16 	blt	r3,r4,81122738 <__subdf3+0x398>
8112254c:	00800804 	movi	r2,32
81122550:	1105c83a 	sub	r2,r2,r4
81122554:	8884d83a 	srl	r2,r17,r2
81122558:	9906983a 	sll	r3,r19,r4
8112255c:	8922983a 	sll	r17,r17,r4
81122560:	10c4b03a 	or	r2,r2,r3
81122564:	24007816 	blt	r4,r16,81122748 <__subdf3+0x3a8>
81122568:	2421c83a 	sub	r16,r4,r16
8112256c:	80c00044 	addi	r3,r16,1
81122570:	010007c4 	movi	r4,31
81122574:	20c09516 	blt	r4,r3,811227cc <__subdf3+0x42c>
81122578:	01400804 	movi	r5,32
8112257c:	28cbc83a 	sub	r5,r5,r3
81122580:	88c8d83a 	srl	r4,r17,r3
81122584:	8962983a 	sll	r17,r17,r5
81122588:	114a983a 	sll	r5,r2,r5
8112258c:	10c6d83a 	srl	r3,r2,r3
81122590:	8804c03a 	cmpne	r2,r17,zero
81122594:	290ab03a 	or	r5,r5,r4
81122598:	28a2b03a 	or	r17,r5,r2
8112259c:	0021883a 	mov	r16,zero
811225a0:	003fa206 	br	8112242c <__reset+0xfb10242c>
811225a4:	2090b03a 	or	r8,r4,r2
811225a8:	40018e26 	beq	r8,zero,81122be4 <__subdf3+0x844>
811225ac:	1007883a 	mov	r3,r2
811225b0:	2023883a 	mov	r17,r4
811225b4:	888001cc 	andi	r2,r17,7
811225b8:	103f9e1e 	bne	r2,zero,81122434 <__reset+0xfb102434>
811225bc:	1804977a 	slli	r2,r3,29
811225c0:	8822d0fa 	srli	r17,r17,3
811225c4:	1810d0fa 	srli	r8,r3,3
811225c8:	9100004c 	andi	r4,r18,1
811225cc:	1444b03a 	or	r2,r2,r17
811225d0:	00c1ffc4 	movi	r3,2047
811225d4:	80c02826 	beq	r16,r3,81122678 <__subdf3+0x2d8>
811225d8:	01400434 	movhi	r5,16
811225dc:	297fffc4 	addi	r5,r5,-1
811225e0:	80e0703a 	and	r16,r16,r3
811225e4:	414a703a 	and	r5,r8,r5
811225e8:	003fa806 	br	8112248c <__reset+0xfb10248c>
811225ec:	0080630e 	bge	zero,r2,8112277c <__subdf3+0x3dc>
811225f0:	48003026 	beq	r9,zero,811226b4 <__subdf3+0x314>
811225f4:	0101ffc4 	movi	r4,2047
811225f8:	813f8c26 	beq	r16,r4,8112242c <__reset+0xfb10242c>
811225fc:	29402034 	orhi	r5,r5,128
81122600:	01000e04 	movi	r4,56
81122604:	2080a90e 	bge	r4,r2,811228ac <__subdf3+0x50c>
81122608:	298cb03a 	or	r6,r5,r6
8112260c:	3012c03a 	cmpne	r9,r6,zero
81122610:	0005883a 	mov	r2,zero
81122614:	4c53883a 	add	r9,r9,r17
81122618:	4c63803a 	cmpltu	r17,r9,r17
8112261c:	10c7883a 	add	r3,r2,r3
81122620:	88c7883a 	add	r3,r17,r3
81122624:	4823883a 	mov	r17,r9
81122628:	1880202c 	andhi	r2,r3,128
8112262c:	1000d026 	beq	r2,zero,81122970 <__subdf3+0x5d0>
81122630:	84000044 	addi	r16,r16,1
81122634:	0081ffc4 	movi	r2,2047
81122638:	8080fe26 	beq	r16,r2,81122a34 <__subdf3+0x694>
8112263c:	00bfe034 	movhi	r2,65408
81122640:	10bfffc4 	addi	r2,r2,-1
81122644:	1886703a 	and	r3,r3,r2
81122648:	880ad07a 	srli	r5,r17,1
8112264c:	180497fa 	slli	r2,r3,31
81122650:	8900004c 	andi	r4,r17,1
81122654:	2922b03a 	or	r17,r5,r4
81122658:	1806d07a 	srli	r3,r3,1
8112265c:	1462b03a 	or	r17,r2,r17
81122660:	3825883a 	mov	r18,r7
81122664:	003f7106 	br	8112242c <__reset+0xfb10242c>
81122668:	2984b03a 	or	r2,r5,r6
8112266c:	103f6826 	beq	r2,zero,81122410 <__reset+0xfb102410>
81122670:	39c03fcc 	andi	r7,r7,255
81122674:	003f6706 	br	81122414 <__reset+0xfb102414>
81122678:	4086b03a 	or	r3,r8,r2
8112267c:	18015226 	beq	r3,zero,81122bc8 <__subdf3+0x828>
81122680:	00c00434 	movhi	r3,16
81122684:	41400234 	orhi	r5,r8,8
81122688:	18ffffc4 	addi	r3,r3,-1
8112268c:	28ca703a 	and	r5,r5,r3
81122690:	003f7e06 	br	8112248c <__reset+0xfb10248c>
81122694:	10bfffc4 	addi	r2,r2,-1
81122698:	1000491e 	bne	r2,zero,811227c0 <__subdf3+0x420>
8112269c:	898fc83a 	sub	r7,r17,r6
811226a0:	89e3803a 	cmpltu	r17,r17,r7
811226a4:	1947c83a 	sub	r3,r3,r5
811226a8:	1c47c83a 	sub	r3,r3,r17
811226ac:	3823883a 	mov	r17,r7
811226b0:	003f9b06 	br	81122520 <__reset+0xfb102520>
811226b4:	2988b03a 	or	r4,r5,r6
811226b8:	203f5c26 	beq	r4,zero,8112242c <__reset+0xfb10242c>
811226bc:	10bfffc4 	addi	r2,r2,-1
811226c0:	1000931e 	bne	r2,zero,81122910 <__subdf3+0x570>
811226c4:	898d883a 	add	r6,r17,r6
811226c8:	3463803a 	cmpltu	r17,r6,r17
811226cc:	1947883a 	add	r3,r3,r5
811226d0:	88c7883a 	add	r3,r17,r3
811226d4:	3023883a 	mov	r17,r6
811226d8:	003fd306 	br	81122628 <__reset+0xfb102628>
811226dc:	1000541e 	bne	r2,zero,81122830 <__subdf3+0x490>
811226e0:	80800044 	addi	r2,r16,1
811226e4:	1081ffcc 	andi	r2,r2,2047
811226e8:	01000044 	movi	r4,1
811226ec:	2080a20e 	bge	r4,r2,81122978 <__subdf3+0x5d8>
811226f0:	8989c83a 	sub	r4,r17,r6
811226f4:	8905803a 	cmpltu	r2,r17,r4
811226f8:	1967c83a 	sub	r19,r3,r5
811226fc:	98a7c83a 	sub	r19,r19,r2
81122700:	9880202c 	andhi	r2,r19,128
81122704:	10006326 	beq	r2,zero,81122894 <__subdf3+0x4f4>
81122708:	3463c83a 	sub	r17,r6,r17
8112270c:	28c7c83a 	sub	r3,r5,r3
81122710:	344d803a 	cmpltu	r6,r6,r17
81122714:	19a7c83a 	sub	r19,r3,r6
81122718:	3825883a 	mov	r18,r7
8112271c:	983f861e 	bne	r19,zero,81122538 <__reset+0xfb102538>
81122720:	8809883a 	mov	r4,r17
81122724:	11230c80 	call	811230c8 <__clzsi2>
81122728:	10800804 	addi	r2,r2,32
8112272c:	113ffe04 	addi	r4,r2,-8
81122730:	00c007c4 	movi	r3,31
81122734:	193f850e 	bge	r3,r4,8112254c <__reset+0xfb10254c>
81122738:	10bff604 	addi	r2,r2,-40
8112273c:	8884983a 	sll	r2,r17,r2
81122740:	0023883a 	mov	r17,zero
81122744:	243f880e 	bge	r4,r16,81122568 <__reset+0xfb102568>
81122748:	00ffe034 	movhi	r3,65408
8112274c:	18ffffc4 	addi	r3,r3,-1
81122750:	8121c83a 	sub	r16,r16,r4
81122754:	10c6703a 	and	r3,r2,r3
81122758:	003f3406 	br	8112242c <__reset+0xfb10242c>
8112275c:	9100004c 	andi	r4,r18,1
81122760:	000b883a 	mov	r5,zero
81122764:	0005883a 	mov	r2,zero
81122768:	003f4806 	br	8112248c <__reset+0xfb10248c>
8112276c:	298cb03a 	or	r6,r5,r6
81122770:	300cc03a 	cmpne	r6,r6,zero
81122774:	0005883a 	mov	r2,zero
81122778:	003f6406 	br	8112250c <__reset+0xfb10250c>
8112277c:	10009a1e 	bne	r2,zero,811229e8 <__subdf3+0x648>
81122780:	82400044 	addi	r9,r16,1
81122784:	4881ffcc 	andi	r2,r9,2047
81122788:	02800044 	movi	r10,1
8112278c:	5080670e 	bge	r10,r2,8112292c <__subdf3+0x58c>
81122790:	0081ffc4 	movi	r2,2047
81122794:	4880af26 	beq	r9,r2,81122a54 <__subdf3+0x6b4>
81122798:	898d883a 	add	r6,r17,r6
8112279c:	1945883a 	add	r2,r3,r5
811227a0:	3447803a 	cmpltu	r3,r6,r17
811227a4:	1887883a 	add	r3,r3,r2
811227a8:	182297fa 	slli	r17,r3,31
811227ac:	300cd07a 	srli	r6,r6,1
811227b0:	1806d07a 	srli	r3,r3,1
811227b4:	4821883a 	mov	r16,r9
811227b8:	89a2b03a 	or	r17,r17,r6
811227bc:	003f1b06 	br	8112242c <__reset+0xfb10242c>
811227c0:	0101ffc4 	movi	r4,2047
811227c4:	813f441e 	bne	r16,r4,811224d8 <__reset+0xfb1024d8>
811227c8:	003f1806 	br	8112242c <__reset+0xfb10242c>
811227cc:	843ff844 	addi	r16,r16,-31
811227d0:	01400804 	movi	r5,32
811227d4:	1408d83a 	srl	r4,r2,r16
811227d8:	19405026 	beq	r3,r5,8112291c <__subdf3+0x57c>
811227dc:	01401004 	movi	r5,64
811227e0:	28c7c83a 	sub	r3,r5,r3
811227e4:	10c4983a 	sll	r2,r2,r3
811227e8:	88a2b03a 	or	r17,r17,r2
811227ec:	8822c03a 	cmpne	r17,r17,zero
811227f0:	2462b03a 	or	r17,r4,r17
811227f4:	0007883a 	mov	r3,zero
811227f8:	0021883a 	mov	r16,zero
811227fc:	003f6d06 	br	811225b4 <__reset+0xfb1025b4>
81122800:	11fff804 	addi	r7,r2,-32
81122804:	01000804 	movi	r4,32
81122808:	29ced83a 	srl	r7,r5,r7
8112280c:	11004526 	beq	r2,r4,81122924 <__subdf3+0x584>
81122810:	01001004 	movi	r4,64
81122814:	2089c83a 	sub	r4,r4,r2
81122818:	2904983a 	sll	r2,r5,r4
8112281c:	118cb03a 	or	r6,r2,r6
81122820:	300cc03a 	cmpne	r6,r6,zero
81122824:	398cb03a 	or	r6,r7,r6
81122828:	0005883a 	mov	r2,zero
8112282c:	003f3706 	br	8112250c <__reset+0xfb10250c>
81122830:	80002a26 	beq	r16,zero,811228dc <__subdf3+0x53c>
81122834:	0101ffc4 	movi	r4,2047
81122838:	49006626 	beq	r9,r4,811229d4 <__subdf3+0x634>
8112283c:	0085c83a 	sub	r2,zero,r2
81122840:	18c02034 	orhi	r3,r3,128
81122844:	01000e04 	movi	r4,56
81122848:	20807e16 	blt	r4,r2,81122a44 <__subdf3+0x6a4>
8112284c:	010007c4 	movi	r4,31
81122850:	2080e716 	blt	r4,r2,81122bf0 <__subdf3+0x850>
81122854:	01000804 	movi	r4,32
81122858:	2089c83a 	sub	r4,r4,r2
8112285c:	1914983a 	sll	r10,r3,r4
81122860:	8890d83a 	srl	r8,r17,r2
81122864:	8908983a 	sll	r4,r17,r4
81122868:	1884d83a 	srl	r2,r3,r2
8112286c:	5222b03a 	or	r17,r10,r8
81122870:	2006c03a 	cmpne	r3,r4,zero
81122874:	88e2b03a 	or	r17,r17,r3
81122878:	3463c83a 	sub	r17,r6,r17
8112287c:	2885c83a 	sub	r2,r5,r2
81122880:	344d803a 	cmpltu	r6,r6,r17
81122884:	1187c83a 	sub	r3,r2,r6
81122888:	4821883a 	mov	r16,r9
8112288c:	3825883a 	mov	r18,r7
81122890:	003f2306 	br	81122520 <__reset+0xfb102520>
81122894:	24d0b03a 	or	r8,r4,r19
81122898:	40001b1e 	bne	r8,zero,81122908 <__subdf3+0x568>
8112289c:	0005883a 	mov	r2,zero
811228a0:	0009883a 	mov	r4,zero
811228a4:	0021883a 	mov	r16,zero
811228a8:	003f4906 	br	811225d0 <__reset+0xfb1025d0>
811228ac:	010007c4 	movi	r4,31
811228b0:	20803a16 	blt	r4,r2,8112299c <__subdf3+0x5fc>
811228b4:	01000804 	movi	r4,32
811228b8:	2089c83a 	sub	r4,r4,r2
811228bc:	2912983a 	sll	r9,r5,r4
811228c0:	3090d83a 	srl	r8,r6,r2
811228c4:	3108983a 	sll	r4,r6,r4
811228c8:	2884d83a 	srl	r2,r5,r2
811228cc:	4a12b03a 	or	r9,r9,r8
811228d0:	2008c03a 	cmpne	r4,r4,zero
811228d4:	4912b03a 	or	r9,r9,r4
811228d8:	003f4e06 	br	81122614 <__reset+0xfb102614>
811228dc:	1c48b03a 	or	r4,r3,r17
811228e0:	20003c26 	beq	r4,zero,811229d4 <__subdf3+0x634>
811228e4:	0084303a 	nor	r2,zero,r2
811228e8:	1000381e 	bne	r2,zero,811229cc <__subdf3+0x62c>
811228ec:	3463c83a 	sub	r17,r6,r17
811228f0:	28c5c83a 	sub	r2,r5,r3
811228f4:	344d803a 	cmpltu	r6,r6,r17
811228f8:	1187c83a 	sub	r3,r2,r6
811228fc:	4821883a 	mov	r16,r9
81122900:	3825883a 	mov	r18,r7
81122904:	003f0606 	br	81122520 <__reset+0xfb102520>
81122908:	2023883a 	mov	r17,r4
8112290c:	003f0906 	br	81122534 <__reset+0xfb102534>
81122910:	0101ffc4 	movi	r4,2047
81122914:	813f3a1e 	bne	r16,r4,81122600 <__reset+0xfb102600>
81122918:	003ec406 	br	8112242c <__reset+0xfb10242c>
8112291c:	0005883a 	mov	r2,zero
81122920:	003fb106 	br	811227e8 <__reset+0xfb1027e8>
81122924:	0005883a 	mov	r2,zero
81122928:	003fbc06 	br	8112281c <__reset+0xfb10281c>
8112292c:	1c44b03a 	or	r2,r3,r17
81122930:	80008e1e 	bne	r16,zero,81122b6c <__subdf3+0x7cc>
81122934:	1000c826 	beq	r2,zero,81122c58 <__subdf3+0x8b8>
81122938:	2984b03a 	or	r2,r5,r6
8112293c:	103ebb26 	beq	r2,zero,8112242c <__reset+0xfb10242c>
81122940:	8989883a 	add	r4,r17,r6
81122944:	1945883a 	add	r2,r3,r5
81122948:	2447803a 	cmpltu	r3,r4,r17
8112294c:	1887883a 	add	r3,r3,r2
81122950:	1880202c 	andhi	r2,r3,128
81122954:	2023883a 	mov	r17,r4
81122958:	103f1626 	beq	r2,zero,811225b4 <__reset+0xfb1025b4>
8112295c:	00bfe034 	movhi	r2,65408
81122960:	10bfffc4 	addi	r2,r2,-1
81122964:	5021883a 	mov	r16,r10
81122968:	1886703a 	and	r3,r3,r2
8112296c:	003eaf06 	br	8112242c <__reset+0xfb10242c>
81122970:	3825883a 	mov	r18,r7
81122974:	003f0f06 	br	811225b4 <__reset+0xfb1025b4>
81122978:	1c44b03a 	or	r2,r3,r17
8112297c:	8000251e 	bne	r16,zero,81122a14 <__subdf3+0x674>
81122980:	1000661e 	bne	r2,zero,81122b1c <__subdf3+0x77c>
81122984:	2990b03a 	or	r8,r5,r6
81122988:	40009626 	beq	r8,zero,81122be4 <__subdf3+0x844>
8112298c:	2807883a 	mov	r3,r5
81122990:	3023883a 	mov	r17,r6
81122994:	3825883a 	mov	r18,r7
81122998:	003ea406 	br	8112242c <__reset+0xfb10242c>
8112299c:	127ff804 	addi	r9,r2,-32
811229a0:	01000804 	movi	r4,32
811229a4:	2a52d83a 	srl	r9,r5,r9
811229a8:	11008c26 	beq	r2,r4,81122bdc <__subdf3+0x83c>
811229ac:	01001004 	movi	r4,64
811229b0:	2085c83a 	sub	r2,r4,r2
811229b4:	2884983a 	sll	r2,r5,r2
811229b8:	118cb03a 	or	r6,r2,r6
811229bc:	300cc03a 	cmpne	r6,r6,zero
811229c0:	4992b03a 	or	r9,r9,r6
811229c4:	0005883a 	mov	r2,zero
811229c8:	003f1206 	br	81122614 <__reset+0xfb102614>
811229cc:	0101ffc4 	movi	r4,2047
811229d0:	493f9c1e 	bne	r9,r4,81122844 <__reset+0xfb102844>
811229d4:	2807883a 	mov	r3,r5
811229d8:	3023883a 	mov	r17,r6
811229dc:	4821883a 	mov	r16,r9
811229e0:	3825883a 	mov	r18,r7
811229e4:	003e9106 	br	8112242c <__reset+0xfb10242c>
811229e8:	80001f1e 	bne	r16,zero,81122a68 <__subdf3+0x6c8>
811229ec:	1c48b03a 	or	r4,r3,r17
811229f0:	20005a26 	beq	r4,zero,81122b5c <__subdf3+0x7bc>
811229f4:	0084303a 	nor	r2,zero,r2
811229f8:	1000561e 	bne	r2,zero,81122b54 <__subdf3+0x7b4>
811229fc:	89a3883a 	add	r17,r17,r6
81122a00:	1945883a 	add	r2,r3,r5
81122a04:	898d803a 	cmpltu	r6,r17,r6
81122a08:	3087883a 	add	r3,r6,r2
81122a0c:	4821883a 	mov	r16,r9
81122a10:	003f0506 	br	81122628 <__reset+0xfb102628>
81122a14:	10002b1e 	bne	r2,zero,81122ac4 <__subdf3+0x724>
81122a18:	2984b03a 	or	r2,r5,r6
81122a1c:	10008026 	beq	r2,zero,81122c20 <__subdf3+0x880>
81122a20:	2807883a 	mov	r3,r5
81122a24:	3023883a 	mov	r17,r6
81122a28:	3825883a 	mov	r18,r7
81122a2c:	0401ffc4 	movi	r16,2047
81122a30:	003e7e06 	br	8112242c <__reset+0xfb10242c>
81122a34:	3809883a 	mov	r4,r7
81122a38:	0011883a 	mov	r8,zero
81122a3c:	0005883a 	mov	r2,zero
81122a40:	003ee306 	br	811225d0 <__reset+0xfb1025d0>
81122a44:	1c62b03a 	or	r17,r3,r17
81122a48:	8822c03a 	cmpne	r17,r17,zero
81122a4c:	0005883a 	mov	r2,zero
81122a50:	003f8906 	br	81122878 <__reset+0xfb102878>
81122a54:	3809883a 	mov	r4,r7
81122a58:	4821883a 	mov	r16,r9
81122a5c:	0011883a 	mov	r8,zero
81122a60:	0005883a 	mov	r2,zero
81122a64:	003eda06 	br	811225d0 <__reset+0xfb1025d0>
81122a68:	0101ffc4 	movi	r4,2047
81122a6c:	49003b26 	beq	r9,r4,81122b5c <__subdf3+0x7bc>
81122a70:	0085c83a 	sub	r2,zero,r2
81122a74:	18c02034 	orhi	r3,r3,128
81122a78:	01000e04 	movi	r4,56
81122a7c:	20806e16 	blt	r4,r2,81122c38 <__subdf3+0x898>
81122a80:	010007c4 	movi	r4,31
81122a84:	20807716 	blt	r4,r2,81122c64 <__subdf3+0x8c4>
81122a88:	01000804 	movi	r4,32
81122a8c:	2089c83a 	sub	r4,r4,r2
81122a90:	1914983a 	sll	r10,r3,r4
81122a94:	8890d83a 	srl	r8,r17,r2
81122a98:	8908983a 	sll	r4,r17,r4
81122a9c:	1884d83a 	srl	r2,r3,r2
81122aa0:	5222b03a 	or	r17,r10,r8
81122aa4:	2006c03a 	cmpne	r3,r4,zero
81122aa8:	88e2b03a 	or	r17,r17,r3
81122aac:	89a3883a 	add	r17,r17,r6
81122ab0:	1145883a 	add	r2,r2,r5
81122ab4:	898d803a 	cmpltu	r6,r17,r6
81122ab8:	3087883a 	add	r3,r6,r2
81122abc:	4821883a 	mov	r16,r9
81122ac0:	003ed906 	br	81122628 <__reset+0xfb102628>
81122ac4:	2984b03a 	or	r2,r5,r6
81122ac8:	10004226 	beq	r2,zero,81122bd4 <__subdf3+0x834>
81122acc:	1808d0fa 	srli	r4,r3,3
81122ad0:	8822d0fa 	srli	r17,r17,3
81122ad4:	1806977a 	slli	r3,r3,29
81122ad8:	2080022c 	andhi	r2,r4,8
81122adc:	1c62b03a 	or	r17,r3,r17
81122ae0:	10000826 	beq	r2,zero,81122b04 <__subdf3+0x764>
81122ae4:	2812d0fa 	srli	r9,r5,3
81122ae8:	4880022c 	andhi	r2,r9,8
81122aec:	1000051e 	bne	r2,zero,81122b04 <__subdf3+0x764>
81122af0:	300cd0fa 	srli	r6,r6,3
81122af4:	2804977a 	slli	r2,r5,29
81122af8:	4809883a 	mov	r4,r9
81122afc:	3825883a 	mov	r18,r7
81122b00:	11a2b03a 	or	r17,r2,r6
81122b04:	8806d77a 	srli	r3,r17,29
81122b08:	200890fa 	slli	r4,r4,3
81122b0c:	882290fa 	slli	r17,r17,3
81122b10:	0401ffc4 	movi	r16,2047
81122b14:	1906b03a 	or	r3,r3,r4
81122b18:	003e4406 	br	8112242c <__reset+0xfb10242c>
81122b1c:	2984b03a 	or	r2,r5,r6
81122b20:	103e4226 	beq	r2,zero,8112242c <__reset+0xfb10242c>
81122b24:	8989c83a 	sub	r4,r17,r6
81122b28:	8911803a 	cmpltu	r8,r17,r4
81122b2c:	1945c83a 	sub	r2,r3,r5
81122b30:	1205c83a 	sub	r2,r2,r8
81122b34:	1200202c 	andhi	r8,r2,128
81122b38:	403e9a26 	beq	r8,zero,811225a4 <__reset+0xfb1025a4>
81122b3c:	3463c83a 	sub	r17,r6,r17
81122b40:	28c5c83a 	sub	r2,r5,r3
81122b44:	344d803a 	cmpltu	r6,r6,r17
81122b48:	1187c83a 	sub	r3,r2,r6
81122b4c:	3825883a 	mov	r18,r7
81122b50:	003e3606 	br	8112242c <__reset+0xfb10242c>
81122b54:	0101ffc4 	movi	r4,2047
81122b58:	493fc71e 	bne	r9,r4,81122a78 <__reset+0xfb102a78>
81122b5c:	2807883a 	mov	r3,r5
81122b60:	3023883a 	mov	r17,r6
81122b64:	4821883a 	mov	r16,r9
81122b68:	003e3006 	br	8112242c <__reset+0xfb10242c>
81122b6c:	10003626 	beq	r2,zero,81122c48 <__subdf3+0x8a8>
81122b70:	2984b03a 	or	r2,r5,r6
81122b74:	10001726 	beq	r2,zero,81122bd4 <__subdf3+0x834>
81122b78:	1808d0fa 	srli	r4,r3,3
81122b7c:	8822d0fa 	srli	r17,r17,3
81122b80:	1806977a 	slli	r3,r3,29
81122b84:	2080022c 	andhi	r2,r4,8
81122b88:	1c62b03a 	or	r17,r3,r17
81122b8c:	10000726 	beq	r2,zero,81122bac <__subdf3+0x80c>
81122b90:	2812d0fa 	srli	r9,r5,3
81122b94:	4880022c 	andhi	r2,r9,8
81122b98:	1000041e 	bne	r2,zero,81122bac <__subdf3+0x80c>
81122b9c:	300cd0fa 	srli	r6,r6,3
81122ba0:	2804977a 	slli	r2,r5,29
81122ba4:	4809883a 	mov	r4,r9
81122ba8:	11a2b03a 	or	r17,r2,r6
81122bac:	8806d77a 	srli	r3,r17,29
81122bb0:	200890fa 	slli	r4,r4,3
81122bb4:	882290fa 	slli	r17,r17,3
81122bb8:	3825883a 	mov	r18,r7
81122bbc:	1906b03a 	or	r3,r3,r4
81122bc0:	0401ffc4 	movi	r16,2047
81122bc4:	003e1906 	br	8112242c <__reset+0xfb10242c>
81122bc8:	000b883a 	mov	r5,zero
81122bcc:	0005883a 	mov	r2,zero
81122bd0:	003e2e06 	br	8112248c <__reset+0xfb10248c>
81122bd4:	0401ffc4 	movi	r16,2047
81122bd8:	003e1406 	br	8112242c <__reset+0xfb10242c>
81122bdc:	0005883a 	mov	r2,zero
81122be0:	003f7506 	br	811229b8 <__reset+0xfb1029b8>
81122be4:	0005883a 	mov	r2,zero
81122be8:	0009883a 	mov	r4,zero
81122bec:	003e7806 	br	811225d0 <__reset+0xfb1025d0>
81122bf0:	123ff804 	addi	r8,r2,-32
81122bf4:	01000804 	movi	r4,32
81122bf8:	1a10d83a 	srl	r8,r3,r8
81122bfc:	11002526 	beq	r2,r4,81122c94 <__subdf3+0x8f4>
81122c00:	01001004 	movi	r4,64
81122c04:	2085c83a 	sub	r2,r4,r2
81122c08:	1884983a 	sll	r2,r3,r2
81122c0c:	1444b03a 	or	r2,r2,r17
81122c10:	1004c03a 	cmpne	r2,r2,zero
81122c14:	40a2b03a 	or	r17,r8,r2
81122c18:	0005883a 	mov	r2,zero
81122c1c:	003f1606 	br	81122878 <__reset+0xfb102878>
81122c20:	02000434 	movhi	r8,16
81122c24:	0009883a 	mov	r4,zero
81122c28:	423fffc4 	addi	r8,r8,-1
81122c2c:	00bfffc4 	movi	r2,-1
81122c30:	0401ffc4 	movi	r16,2047
81122c34:	003e6606 	br	811225d0 <__reset+0xfb1025d0>
81122c38:	1c62b03a 	or	r17,r3,r17
81122c3c:	8822c03a 	cmpne	r17,r17,zero
81122c40:	0005883a 	mov	r2,zero
81122c44:	003f9906 	br	81122aac <__reset+0xfb102aac>
81122c48:	2807883a 	mov	r3,r5
81122c4c:	3023883a 	mov	r17,r6
81122c50:	0401ffc4 	movi	r16,2047
81122c54:	003df506 	br	8112242c <__reset+0xfb10242c>
81122c58:	2807883a 	mov	r3,r5
81122c5c:	3023883a 	mov	r17,r6
81122c60:	003df206 	br	8112242c <__reset+0xfb10242c>
81122c64:	123ff804 	addi	r8,r2,-32
81122c68:	01000804 	movi	r4,32
81122c6c:	1a10d83a 	srl	r8,r3,r8
81122c70:	11000a26 	beq	r2,r4,81122c9c <__subdf3+0x8fc>
81122c74:	01001004 	movi	r4,64
81122c78:	2085c83a 	sub	r2,r4,r2
81122c7c:	1884983a 	sll	r2,r3,r2
81122c80:	1444b03a 	or	r2,r2,r17
81122c84:	1004c03a 	cmpne	r2,r2,zero
81122c88:	40a2b03a 	or	r17,r8,r2
81122c8c:	0005883a 	mov	r2,zero
81122c90:	003f8606 	br	81122aac <__reset+0xfb102aac>
81122c94:	0005883a 	mov	r2,zero
81122c98:	003fdc06 	br	81122c0c <__reset+0xfb102c0c>
81122c9c:	0005883a 	mov	r2,zero
81122ca0:	003ff706 	br	81122c80 <__reset+0xfb102c80>

81122ca4 <__fixdfsi>:
81122ca4:	280cd53a 	srli	r6,r5,20
81122ca8:	00c00434 	movhi	r3,16
81122cac:	18ffffc4 	addi	r3,r3,-1
81122cb0:	3181ffcc 	andi	r6,r6,2047
81122cb4:	01c0ff84 	movi	r7,1022
81122cb8:	28c6703a 	and	r3,r5,r3
81122cbc:	280ad7fa 	srli	r5,r5,31
81122cc0:	3980120e 	bge	r7,r6,81122d0c <__fixdfsi+0x68>
81122cc4:	00810744 	movi	r2,1053
81122cc8:	11800c16 	blt	r2,r6,81122cfc <__fixdfsi+0x58>
81122ccc:	00810cc4 	movi	r2,1075
81122cd0:	1185c83a 	sub	r2,r2,r6
81122cd4:	01c007c4 	movi	r7,31
81122cd8:	18c00434 	orhi	r3,r3,16
81122cdc:	38800d16 	blt	r7,r2,81122d14 <__fixdfsi+0x70>
81122ce0:	31befb44 	addi	r6,r6,-1043
81122ce4:	2084d83a 	srl	r2,r4,r2
81122ce8:	1986983a 	sll	r3,r3,r6
81122cec:	1884b03a 	or	r2,r3,r2
81122cf0:	28000726 	beq	r5,zero,81122d10 <__fixdfsi+0x6c>
81122cf4:	0085c83a 	sub	r2,zero,r2
81122cf8:	f800283a 	ret
81122cfc:	00a00034 	movhi	r2,32768
81122d00:	10bfffc4 	addi	r2,r2,-1
81122d04:	2885883a 	add	r2,r5,r2
81122d08:	f800283a 	ret
81122d0c:	0005883a 	mov	r2,zero
81122d10:	f800283a 	ret
81122d14:	008104c4 	movi	r2,1043
81122d18:	1185c83a 	sub	r2,r2,r6
81122d1c:	1884d83a 	srl	r2,r3,r2
81122d20:	003ff306 	br	81122cf0 <__reset+0xfb102cf0>

81122d24 <__floatsidf>:
81122d24:	defffd04 	addi	sp,sp,-12
81122d28:	de00012e 	bgeu	sp,et,81122d30 <__floatsidf+0xc>
81122d2c:	003b68fa 	trap	3
81122d30:	dfc00215 	stw	ra,8(sp)
81122d34:	dc400115 	stw	r17,4(sp)
81122d38:	dc000015 	stw	r16,0(sp)
81122d3c:	20002b26 	beq	r4,zero,81122dec <__floatsidf+0xc8>
81122d40:	2023883a 	mov	r17,r4
81122d44:	2020d7fa 	srli	r16,r4,31
81122d48:	20002d16 	blt	r4,zero,81122e00 <__floatsidf+0xdc>
81122d4c:	8809883a 	mov	r4,r17
81122d50:	11230c80 	call	811230c8 <__clzsi2>
81122d54:	01410784 	movi	r5,1054
81122d58:	288bc83a 	sub	r5,r5,r2
81122d5c:	01010cc4 	movi	r4,1075
81122d60:	2149c83a 	sub	r4,r4,r5
81122d64:	00c007c4 	movi	r3,31
81122d68:	1900160e 	bge	r3,r4,81122dc4 <__floatsidf+0xa0>
81122d6c:	00c104c4 	movi	r3,1043
81122d70:	1947c83a 	sub	r3,r3,r5
81122d74:	88c6983a 	sll	r3,r17,r3
81122d78:	00800434 	movhi	r2,16
81122d7c:	10bfffc4 	addi	r2,r2,-1
81122d80:	1886703a 	and	r3,r3,r2
81122d84:	2941ffcc 	andi	r5,r5,2047
81122d88:	800d883a 	mov	r6,r16
81122d8c:	0005883a 	mov	r2,zero
81122d90:	280a953a 	slli	r5,r5,20
81122d94:	31803fcc 	andi	r6,r6,255
81122d98:	01000434 	movhi	r4,16
81122d9c:	300c97fa 	slli	r6,r6,31
81122da0:	213fffc4 	addi	r4,r4,-1
81122da4:	1906703a 	and	r3,r3,r4
81122da8:	1946b03a 	or	r3,r3,r5
81122dac:	1986b03a 	or	r3,r3,r6
81122db0:	dfc00217 	ldw	ra,8(sp)
81122db4:	dc400117 	ldw	r17,4(sp)
81122db8:	dc000017 	ldw	r16,0(sp)
81122dbc:	dec00304 	addi	sp,sp,12
81122dc0:	f800283a 	ret
81122dc4:	00c002c4 	movi	r3,11
81122dc8:	1887c83a 	sub	r3,r3,r2
81122dcc:	88c6d83a 	srl	r3,r17,r3
81122dd0:	8904983a 	sll	r2,r17,r4
81122dd4:	01000434 	movhi	r4,16
81122dd8:	213fffc4 	addi	r4,r4,-1
81122ddc:	2941ffcc 	andi	r5,r5,2047
81122de0:	1906703a 	and	r3,r3,r4
81122de4:	800d883a 	mov	r6,r16
81122de8:	003fe906 	br	81122d90 <__reset+0xfb102d90>
81122dec:	000d883a 	mov	r6,zero
81122df0:	000b883a 	mov	r5,zero
81122df4:	0007883a 	mov	r3,zero
81122df8:	0005883a 	mov	r2,zero
81122dfc:	003fe406 	br	81122d90 <__reset+0xfb102d90>
81122e00:	0123c83a 	sub	r17,zero,r4
81122e04:	003fd106 	br	81122d4c <__reset+0xfb102d4c>

81122e08 <__extendsfdf2>:
81122e08:	200ad5fa 	srli	r5,r4,23
81122e0c:	defffd04 	addi	sp,sp,-12
81122e10:	de00012e 	bgeu	sp,et,81122e18 <__extendsfdf2+0x10>
81122e14:	003b68fa 	trap	3
81122e18:	29403fcc 	andi	r5,r5,255
81122e1c:	dc400115 	stw	r17,4(sp)
81122e20:	29800044 	addi	r6,r5,1
81122e24:	04402034 	movhi	r17,128
81122e28:	dc000015 	stw	r16,0(sp)
81122e2c:	8c7fffc4 	addi	r17,r17,-1
81122e30:	dfc00215 	stw	ra,8(sp)
81122e34:	31803fcc 	andi	r6,r6,255
81122e38:	00800044 	movi	r2,1
81122e3c:	8922703a 	and	r17,r17,r4
81122e40:	2020d7fa 	srli	r16,r4,31
81122e44:	1180110e 	bge	r2,r6,81122e8c <__extendsfdf2+0x84>
81122e48:	880cd0fa 	srli	r6,r17,3
81122e4c:	8822977a 	slli	r17,r17,29
81122e50:	2940e004 	addi	r5,r5,896
81122e54:	2941ffcc 	andi	r5,r5,2047
81122e58:	2804953a 	slli	r2,r5,20
81122e5c:	01400434 	movhi	r5,16
81122e60:	800697fa 	slli	r3,r16,31
81122e64:	297fffc4 	addi	r5,r5,-1
81122e68:	314a703a 	and	r5,r6,r5
81122e6c:	288ab03a 	or	r5,r5,r2
81122e70:	28c6b03a 	or	r3,r5,r3
81122e74:	8805883a 	mov	r2,r17
81122e78:	dfc00217 	ldw	ra,8(sp)
81122e7c:	dc400117 	ldw	r17,4(sp)
81122e80:	dc000017 	ldw	r16,0(sp)
81122e84:	dec00304 	addi	sp,sp,12
81122e88:	f800283a 	ret
81122e8c:	2800111e 	bne	r5,zero,81122ed4 <__extendsfdf2+0xcc>
81122e90:	88001c26 	beq	r17,zero,81122f04 <__extendsfdf2+0xfc>
81122e94:	8809883a 	mov	r4,r17
81122e98:	11230c80 	call	811230c8 <__clzsi2>
81122e9c:	00c00284 	movi	r3,10
81122ea0:	18801b16 	blt	r3,r2,81122f10 <__extendsfdf2+0x108>
81122ea4:	018002c4 	movi	r6,11
81122ea8:	308dc83a 	sub	r6,r6,r2
81122eac:	11000544 	addi	r4,r2,21
81122eb0:	8986d83a 	srl	r3,r17,r6
81122eb4:	8922983a 	sll	r17,r17,r4
81122eb8:	0180e244 	movi	r6,905
81122ebc:	01400434 	movhi	r5,16
81122ec0:	3085c83a 	sub	r2,r6,r2
81122ec4:	297fffc4 	addi	r5,r5,-1
81122ec8:	194c703a 	and	r6,r3,r5
81122ecc:	1141ffcc 	andi	r5,r2,2047
81122ed0:	003fe006 	br	81122e54 <__reset+0xfb102e54>
81122ed4:	88000826 	beq	r17,zero,81122ef8 <__extendsfdf2+0xf0>
81122ed8:	880cd0fa 	srli	r6,r17,3
81122edc:	00800434 	movhi	r2,16
81122ee0:	10bfffc4 	addi	r2,r2,-1
81122ee4:	31800234 	orhi	r6,r6,8
81122ee8:	8822977a 	slli	r17,r17,29
81122eec:	308c703a 	and	r6,r6,r2
81122ef0:	0141ffc4 	movi	r5,2047
81122ef4:	003fd706 	br	81122e54 <__reset+0xfb102e54>
81122ef8:	0141ffc4 	movi	r5,2047
81122efc:	000d883a 	mov	r6,zero
81122f00:	003fd406 	br	81122e54 <__reset+0xfb102e54>
81122f04:	000b883a 	mov	r5,zero
81122f08:	000d883a 	mov	r6,zero
81122f0c:	003fd106 	br	81122e54 <__reset+0xfb102e54>
81122f10:	11bffd44 	addi	r6,r2,-11
81122f14:	8986983a 	sll	r3,r17,r6
81122f18:	0023883a 	mov	r17,zero
81122f1c:	003fe606 	br	81122eb8 <__reset+0xfb102eb8>

81122f20 <__truncdfsf2>:
81122f20:	2810d53a 	srli	r8,r5,20
81122f24:	01c00434 	movhi	r7,16
81122f28:	39ffffc4 	addi	r7,r7,-1
81122f2c:	29ce703a 	and	r7,r5,r7
81122f30:	4201ffcc 	andi	r8,r8,2047
81122f34:	380e90fa 	slli	r7,r7,3
81122f38:	200cd77a 	srli	r6,r4,29
81122f3c:	42400044 	addi	r9,r8,1
81122f40:	4a41ffcc 	andi	r9,r9,2047
81122f44:	00c00044 	movi	r3,1
81122f48:	280ad7fa 	srli	r5,r5,31
81122f4c:	31ceb03a 	or	r7,r6,r7
81122f50:	200490fa 	slli	r2,r4,3
81122f54:	1a40230e 	bge	r3,r9,81122fe4 <__truncdfsf2+0xc4>
81122f58:	40ff2004 	addi	r3,r8,-896
81122f5c:	01803f84 	movi	r6,254
81122f60:	30c01516 	blt	r6,r3,81122fb8 <__truncdfsf2+0x98>
81122f64:	00c0380e 	bge	zero,r3,81123048 <__truncdfsf2+0x128>
81122f68:	200c91ba 	slli	r6,r4,6
81122f6c:	380e90fa 	slli	r7,r7,3
81122f70:	1004d77a 	srli	r2,r2,29
81122f74:	300cc03a 	cmpne	r6,r6,zero
81122f78:	31ccb03a 	or	r6,r6,r7
81122f7c:	308cb03a 	or	r6,r6,r2
81122f80:	308001cc 	andi	r2,r6,7
81122f84:	10000426 	beq	r2,zero,81122f98 <__truncdfsf2+0x78>
81122f88:	308003cc 	andi	r2,r6,15
81122f8c:	01000104 	movi	r4,4
81122f90:	11000126 	beq	r2,r4,81122f98 <__truncdfsf2+0x78>
81122f94:	31800104 	addi	r6,r6,4
81122f98:	3081002c 	andhi	r2,r6,1024
81122f9c:	10001626 	beq	r2,zero,81122ff8 <__truncdfsf2+0xd8>
81122fa0:	18c00044 	addi	r3,r3,1
81122fa4:	00803fc4 	movi	r2,255
81122fa8:	18800326 	beq	r3,r2,81122fb8 <__truncdfsf2+0x98>
81122fac:	300c91ba 	slli	r6,r6,6
81122fb0:	300cd27a 	srli	r6,r6,9
81122fb4:	00000206 	br	81122fc0 <__truncdfsf2+0xa0>
81122fb8:	00ffffc4 	movi	r3,-1
81122fbc:	000d883a 	mov	r6,zero
81122fc0:	18c03fcc 	andi	r3,r3,255
81122fc4:	180895fa 	slli	r4,r3,23
81122fc8:	00c02034 	movhi	r3,128
81122fcc:	280a97fa 	slli	r5,r5,31
81122fd0:	18ffffc4 	addi	r3,r3,-1
81122fd4:	30c6703a 	and	r3,r6,r3
81122fd8:	1906b03a 	or	r3,r3,r4
81122fdc:	1944b03a 	or	r2,r3,r5
81122fe0:	f800283a 	ret
81122fe4:	40000b1e 	bne	r8,zero,81123014 <__truncdfsf2+0xf4>
81122fe8:	388cb03a 	or	r6,r7,r2
81122fec:	0007883a 	mov	r3,zero
81122ff0:	30000426 	beq	r6,zero,81123004 <__truncdfsf2+0xe4>
81122ff4:	01800144 	movi	r6,5
81122ff8:	00803fc4 	movi	r2,255
81122ffc:	300cd0fa 	srli	r6,r6,3
81123000:	18800a26 	beq	r3,r2,8112302c <__truncdfsf2+0x10c>
81123004:	00802034 	movhi	r2,128
81123008:	10bfffc4 	addi	r2,r2,-1
8112300c:	308c703a 	and	r6,r6,r2
81123010:	003feb06 	br	81122fc0 <__reset+0xfb102fc0>
81123014:	3888b03a 	or	r4,r7,r2
81123018:	203fe726 	beq	r4,zero,81122fb8 <__reset+0xfb102fb8>
8112301c:	380c90fa 	slli	r6,r7,3
81123020:	00c03fc4 	movi	r3,255
81123024:	31808034 	orhi	r6,r6,512
81123028:	003fd506 	br	81122f80 <__reset+0xfb102f80>
8112302c:	303fe226 	beq	r6,zero,81122fb8 <__reset+0xfb102fb8>
81123030:	00802034 	movhi	r2,128
81123034:	31801034 	orhi	r6,r6,64
81123038:	10bfffc4 	addi	r2,r2,-1
8112303c:	00ffffc4 	movi	r3,-1
81123040:	308c703a 	and	r6,r6,r2
81123044:	003fde06 	br	81122fc0 <__reset+0xfb102fc0>
81123048:	013ffa44 	movi	r4,-23
8112304c:	19000e16 	blt	r3,r4,81123088 <__truncdfsf2+0x168>
81123050:	01000784 	movi	r4,30
81123054:	20c9c83a 	sub	r4,r4,r3
81123058:	018007c4 	movi	r6,31
8112305c:	39c02034 	orhi	r7,r7,128
81123060:	31000b16 	blt	r6,r4,81123090 <__truncdfsf2+0x170>
81123064:	423f2084 	addi	r8,r8,-894
81123068:	120c983a 	sll	r6,r2,r8
8112306c:	3a0e983a 	sll	r7,r7,r8
81123070:	1104d83a 	srl	r2,r2,r4
81123074:	300cc03a 	cmpne	r6,r6,zero
81123078:	31ceb03a 	or	r7,r6,r7
8112307c:	388cb03a 	or	r6,r7,r2
81123080:	0007883a 	mov	r3,zero
81123084:	003fbe06 	br	81122f80 <__reset+0xfb102f80>
81123088:	0007883a 	mov	r3,zero
8112308c:	003fd906 	br	81122ff4 <__reset+0xfb102ff4>
81123090:	01bfff84 	movi	r6,-2
81123094:	30cdc83a 	sub	r6,r6,r3
81123098:	00c00804 	movi	r3,32
8112309c:	398cd83a 	srl	r6,r7,r6
811230a0:	20c00726 	beq	r4,r3,811230c0 <__truncdfsf2+0x1a0>
811230a4:	423f2884 	addi	r8,r8,-862
811230a8:	3a0e983a 	sll	r7,r7,r8
811230ac:	3884b03a 	or	r2,r7,r2
811230b0:	1004c03a 	cmpne	r2,r2,zero
811230b4:	118cb03a 	or	r6,r2,r6
811230b8:	0007883a 	mov	r3,zero
811230bc:	003fb006 	br	81122f80 <__reset+0xfb102f80>
811230c0:	000f883a 	mov	r7,zero
811230c4:	003ff906 	br	811230ac <__reset+0xfb1030ac>

811230c8 <__clzsi2>:
811230c8:	00bfffd4 	movui	r2,65535
811230cc:	11000536 	bltu	r2,r4,811230e4 <__clzsi2+0x1c>
811230d0:	00803fc4 	movi	r2,255
811230d4:	11000f36 	bltu	r2,r4,81123114 <__clzsi2+0x4c>
811230d8:	00800804 	movi	r2,32
811230dc:	0007883a 	mov	r3,zero
811230e0:	00000506 	br	811230f8 <__clzsi2+0x30>
811230e4:	00804034 	movhi	r2,256
811230e8:	10bfffc4 	addi	r2,r2,-1
811230ec:	11000c2e 	bgeu	r2,r4,81123120 <__clzsi2+0x58>
811230f0:	00800204 	movi	r2,8
811230f4:	00c00604 	movi	r3,24
811230f8:	20c8d83a 	srl	r4,r4,r3
811230fc:	00e04574 	movhi	r3,33045
81123100:	18c8a504 	addi	r3,r3,8852
81123104:	1909883a 	add	r4,r3,r4
81123108:	20c00003 	ldbu	r3,0(r4)
8112310c:	10c5c83a 	sub	r2,r2,r3
81123110:	f800283a 	ret
81123114:	00800604 	movi	r2,24
81123118:	00c00204 	movi	r3,8
8112311c:	003ff606 	br	811230f8 <__reset+0xfb1030f8>
81123120:	00800404 	movi	r2,16
81123124:	1007883a 	mov	r3,r2
81123128:	003ff306 	br	811230f8 <__reset+0xfb1030f8>

8112312c <atoi>:
8112312c:	01800284 	movi	r6,10
81123130:	000b883a 	mov	r5,zero
81123134:	11250e41 	jmpi	811250e4 <strtol>

81123138 <_atoi_r>:
81123138:	01c00284 	movi	r7,10
8112313c:	000d883a 	mov	r6,zero
81123140:	1124ea41 	jmpi	81124ea4 <_strtol_r>

81123144 <atoll>:
81123144:	01800284 	movi	r6,10
81123148:	000b883a 	mov	r5,zero
8112314c:	11251001 	jmpi	81125100 <strtoll>

81123150 <_atoll_r>:
81123150:	01c00284 	movi	r7,10
81123154:	000d883a 	mov	r6,zero
81123158:	112511c1 	jmpi	8112511c <_strtoll_r>

8112315c <_fopen_r>:
8112315c:	defffa04 	addi	sp,sp,-24
81123160:	3005883a 	mov	r2,r6
81123164:	de00012e 	bgeu	sp,et,8112316c <_fopen_r+0x10>
81123168:	003b68fa 	trap	3
8112316c:	d80d883a 	mov	r6,sp
81123170:	dcc00415 	stw	r19,16(sp)
81123174:	2827883a 	mov	r19,r5
81123178:	100b883a 	mov	r5,r2
8112317c:	dc800315 	stw	r18,12(sp)
81123180:	dfc00515 	stw	ra,20(sp)
81123184:	dc400215 	stw	r17,8(sp)
81123188:	dc000115 	stw	r16,4(sp)
8112318c:	2025883a 	mov	r18,r4
81123190:	112d3f00 	call	8112d3f0 <__sflags>
81123194:	10002726 	beq	r2,zero,81123234 <_fopen_r+0xd8>
81123198:	9009883a 	mov	r4,r18
8112319c:	1023883a 	mov	r17,r2
811231a0:	112d2680 	call	8112d268 <__sfp>
811231a4:	1021883a 	mov	r16,r2
811231a8:	10002226 	beq	r2,zero,81123234 <_fopen_r+0xd8>
811231ac:	d9800017 	ldw	r6,0(sp)
811231b0:	01c06d84 	movi	r7,438
811231b4:	980b883a 	mov	r5,r19
811231b8:	9009883a 	mov	r4,r18
811231bc:	11245c80 	call	811245c8 <_open_r>
811231c0:	10001916 	blt	r2,zero,81123228 <_fopen_r+0xcc>
811231c4:	8080038d 	sth	r2,14(r16)
811231c8:	00a044b4 	movhi	r2,33042
811231cc:	10930a04 	addi	r2,r2,19496
811231d0:	80800815 	stw	r2,32(r16)
811231d4:	00a044b4 	movhi	r2,33042
811231d8:	10932304 	addi	r2,r2,19596
811231dc:	80800915 	stw	r2,36(r16)
811231e0:	00a044b4 	movhi	r2,33042
811231e4:	10934404 	addi	r2,r2,19728
811231e8:	80800a15 	stw	r2,40(r16)
811231ec:	00a044b4 	movhi	r2,33042
811231f0:	10935d04 	addi	r2,r2,19828
811231f4:	8440030d 	sth	r17,12(r16)
811231f8:	84000715 	stw	r16,28(r16)
811231fc:	80800b15 	stw	r2,44(r16)
81123200:	8c40400c 	andi	r17,r17,256
81123204:	88000d1e 	bne	r17,zero,8112323c <_fopen_r+0xe0>
81123208:	8005883a 	mov	r2,r16
8112320c:	dfc00517 	ldw	ra,20(sp)
81123210:	dcc00417 	ldw	r19,16(sp)
81123214:	dc800317 	ldw	r18,12(sp)
81123218:	dc400217 	ldw	r17,8(sp)
8112321c:	dc000117 	ldw	r16,4(sp)
81123220:	dec00604 	addi	sp,sp,24
81123224:	f800283a 	ret
81123228:	112d3b00 	call	8112d3b0 <__sfp_lock_acquire>
8112322c:	8000030d 	sth	zero,12(r16)
81123230:	112d3b40 	call	8112d3b4 <__sfp_lock_release>
81123234:	0005883a 	mov	r2,zero
81123238:	003ff406 	br	8112320c <__reset+0xfb10320c>
8112323c:	01c00084 	movi	r7,2
81123240:	000d883a 	mov	r6,zero
81123244:	800b883a 	mov	r5,r16
81123248:	9009883a 	mov	r4,r18
8112324c:	112337c0 	call	8112337c <_fseek_r>
81123250:	8005883a 	mov	r2,r16
81123254:	003fed06 	br	8112320c <__reset+0xfb10320c>

81123258 <fopen>:
81123258:	00a04574 	movhi	r2,33045
8112325c:	10936004 	addi	r2,r2,19840
81123260:	280d883a 	mov	r6,r5
81123264:	200b883a 	mov	r5,r4
81123268:	11000017 	ldw	r4,0(r2)
8112326c:	112315c1 	jmpi	8112315c <_fopen_r>

81123270 <_fprintf_r>:
81123270:	defffe04 	addi	sp,sp,-8
81123274:	2809883a 	mov	r4,r5
81123278:	300b883a 	mov	r5,r6
8112327c:	de00012e 	bgeu	sp,et,81123284 <_fprintf_r+0x14>
81123280:	003b68fa 	trap	3
81123284:	dfc00015 	stw	ra,0(sp)
81123288:	d9c00115 	stw	r7,4(sp)
8112328c:	d9800104 	addi	r6,sp,4
81123290:	11297e40 	call	811297e4 <__vfprintf_internal>
81123294:	dfc00017 	ldw	ra,0(sp)
81123298:	dec00204 	addi	sp,sp,8
8112329c:	f800283a 	ret

811232a0 <fprintf>:
811232a0:	defffd04 	addi	sp,sp,-12
811232a4:	de00012e 	bgeu	sp,et,811232ac <fprintf+0xc>
811232a8:	003b68fa 	trap	3
811232ac:	dfc00015 	stw	ra,0(sp)
811232b0:	d9800115 	stw	r6,4(sp)
811232b4:	d9c00215 	stw	r7,8(sp)
811232b8:	d9800104 	addi	r6,sp,4
811232bc:	11297e40 	call	811297e4 <__vfprintf_internal>
811232c0:	dfc00017 	ldw	ra,0(sp)
811232c4:	dec00304 	addi	sp,sp,12
811232c8:	f800283a 	ret

811232cc <_fputc_r>:
811232cc:	defffc04 	addi	sp,sp,-16
811232d0:	de00012e 	bgeu	sp,et,811232d8 <_fputc_r+0xc>
811232d4:	003b68fa 	trap	3
811232d8:	dc000215 	stw	r16,8(sp)
811232dc:	dfc00315 	stw	ra,12(sp)
811232e0:	2021883a 	mov	r16,r4
811232e4:	20000726 	beq	r4,zero,81123304 <_fputc_r+0x38>
811232e8:	20800e17 	ldw	r2,56(r4)
811232ec:	1000051e 	bne	r2,zero,81123304 <_fputc_r+0x38>
811232f0:	d9400015 	stw	r5,0(sp)
811232f4:	d9800115 	stw	r6,4(sp)
811232f8:	112d3a00 	call	8112d3a0 <__sinit>
811232fc:	d9800117 	ldw	r6,4(sp)
81123300:	d9400017 	ldw	r5,0(sp)
81123304:	8009883a 	mov	r4,r16
81123308:	dfc00317 	ldw	ra,12(sp)
8112330c:	dc000217 	ldw	r16,8(sp)
81123310:	dec00404 	addi	sp,sp,16
81123314:	11246301 	jmpi	81124630 <_putc_r>

81123318 <fputc>:
81123318:	00a04574 	movhi	r2,33045
8112331c:	defffc04 	addi	sp,sp,-16
81123320:	10936004 	addi	r2,r2,19840
81123324:	de00012e 	bgeu	sp,et,8112332c <fputc+0x14>
81123328:	003b68fa 	trap	3
8112332c:	dc000115 	stw	r16,4(sp)
81123330:	14000017 	ldw	r16,0(r2)
81123334:	dc400215 	stw	r17,8(sp)
81123338:	dfc00315 	stw	ra,12(sp)
8112333c:	2023883a 	mov	r17,r4
81123340:	80000626 	beq	r16,zero,8112335c <fputc+0x44>
81123344:	80800e17 	ldw	r2,56(r16)
81123348:	1000041e 	bne	r2,zero,8112335c <fputc+0x44>
8112334c:	8009883a 	mov	r4,r16
81123350:	d9400015 	stw	r5,0(sp)
81123354:	112d3a00 	call	8112d3a0 <__sinit>
81123358:	d9400017 	ldw	r5,0(sp)
8112335c:	280d883a 	mov	r6,r5
81123360:	8009883a 	mov	r4,r16
81123364:	880b883a 	mov	r5,r17
81123368:	dfc00317 	ldw	ra,12(sp)
8112336c:	dc400217 	ldw	r17,8(sp)
81123370:	dc000117 	ldw	r16,4(sp)
81123374:	dec00404 	addi	sp,sp,16
81123378:	11246301 	jmpi	81124630 <_putc_r>

8112337c <_fseek_r>:
8112337c:	112339c1 	jmpi	8112339c <_fseeko_r>

81123380 <fseek>:
81123380:	00a04574 	movhi	r2,33045
81123384:	10936004 	addi	r2,r2,19840
81123388:	300f883a 	mov	r7,r6
8112338c:	280d883a 	mov	r6,r5
81123390:	200b883a 	mov	r5,r4
81123394:	11000017 	ldw	r4,0(r2)
81123398:	112339c1 	jmpi	8112339c <_fseeko_r>

8112339c <_fseeko_r>:
8112339c:	deffe804 	addi	sp,sp,-96
811233a0:	de00012e 	bgeu	sp,et,811233a8 <_fseeko_r+0xc>
811233a4:	003b68fa 	trap	3
811233a8:	dd401415 	stw	r21,80(sp)
811233ac:	dc801115 	stw	r18,68(sp)
811233b0:	dc401015 	stw	r17,64(sp)
811233b4:	dc000f15 	stw	r16,60(sp)
811233b8:	dfc01715 	stw	ra,92(sp)
811233bc:	ddc01615 	stw	r23,88(sp)
811233c0:	dd801515 	stw	r22,84(sp)
811233c4:	dd001315 	stw	r20,76(sp)
811233c8:	dcc01215 	stw	r19,72(sp)
811233cc:	2023883a 	mov	r17,r4
811233d0:	2821883a 	mov	r16,r5
811233d4:	302b883a 	mov	r21,r6
811233d8:	3825883a 	mov	r18,r7
811233dc:	20000226 	beq	r4,zero,811233e8 <_fseeko_r+0x4c>
811233e0:	20800e17 	ldw	r2,56(r4)
811233e4:	10005a26 	beq	r2,zero,81123550 <_fseeko_r+0x1b4>
811233e8:	8080030b 	ldhu	r2,12(r16)
811233ec:	00c04204 	movi	r3,264
811233f0:	1080420c 	andi	r2,r2,264
811233f4:	10c05b26 	beq	r2,r3,81123564 <_fseeko_r+0x1c8>
811233f8:	85000a17 	ldw	r20,40(r16)
811233fc:	a000f626 	beq	r20,zero,811237d8 <_fseeko_r+0x43c>
81123400:	00800044 	movi	r2,1
81123404:	90803e26 	beq	r18,r2,81123500 <_fseeko_r+0x164>
81123408:	00800084 	movi	r2,2
8112340c:	90801026 	beq	r18,r2,81123450 <_fseeko_r+0xb4>
81123410:	90000f26 	beq	r18,zero,81123450 <_fseeko_r+0xb4>
81123414:	00800584 	movi	r2,22
81123418:	88800015 	stw	r2,0(r17)
8112341c:	04ffffc4 	movi	r19,-1
81123420:	9805883a 	mov	r2,r19
81123424:	dfc01717 	ldw	ra,92(sp)
81123428:	ddc01617 	ldw	r23,88(sp)
8112342c:	dd801517 	ldw	r22,84(sp)
81123430:	dd401417 	ldw	r21,80(sp)
81123434:	dd001317 	ldw	r20,76(sp)
81123438:	dcc01217 	ldw	r19,72(sp)
8112343c:	dc801117 	ldw	r18,68(sp)
81123440:	dc401017 	ldw	r17,64(sp)
81123444:	dc000f17 	ldw	r16,60(sp)
81123448:	dec01804 	addi	sp,sp,96
8112344c:	f800283a 	ret
81123450:	80800417 	ldw	r2,16(r16)
81123454:	002f883a 	mov	r23,zero
81123458:	0027883a 	mov	r19,zero
8112345c:	1000cb26 	beq	r2,zero,8112378c <_fseeko_r+0x3f0>
81123460:	8080030b 	ldhu	r2,12(r16)
81123464:	10c2068c 	andi	r3,r2,2074
81123468:	1800071e 	bne	r3,zero,81123488 <_fseeko_r+0xec>
8112346c:	10c1000c 	andi	r3,r2,1024
81123470:	1800451e 	bne	r3,zero,81123588 <_fseeko_r+0x1ec>
81123474:	00e044b4 	movhi	r3,33042
81123478:	18d34404 	addi	r3,r3,19728
8112347c:	a0c0b726 	beq	r20,r3,8112375c <_fseeko_r+0x3c0>
81123480:	10820014 	ori	r2,r2,2048
81123484:	8080030d 	sth	r2,12(r16)
81123488:	800b883a 	mov	r5,r16
8112348c:	8809883a 	mov	r4,r17
81123490:	112cfa40 	call	8112cfa4 <_fflush_r>
81123494:	1027883a 	mov	r19,r2
81123498:	103fe01e 	bne	r2,zero,8112341c <__reset+0xfb10341c>
8112349c:	81400717 	ldw	r5,28(r16)
811234a0:	900f883a 	mov	r7,r18
811234a4:	a80d883a 	mov	r6,r21
811234a8:	8809883a 	mov	r4,r17
811234ac:	a03ee83a 	callr	r20
811234b0:	00ffffc4 	movi	r3,-1
811234b4:	10ffd926 	beq	r2,r3,8112341c <__reset+0xfb10341c>
811234b8:	81400c17 	ldw	r5,48(r16)
811234bc:	28000526 	beq	r5,zero,811234d4 <_fseeko_r+0x138>
811234c0:	80801004 	addi	r2,r16,64
811234c4:	28800226 	beq	r5,r2,811234d0 <_fseeko_r+0x134>
811234c8:	8809883a 	mov	r4,r17
811234cc:	112d8380 	call	8112d838 <_free_r>
811234d0:	80000c15 	stw	zero,48(r16)
811234d4:	8080030b 	ldhu	r2,12(r16)
811234d8:	80c00417 	ldw	r3,16(r16)
811234dc:	80000115 	stw	zero,4(r16)
811234e0:	10bdf7cc 	andi	r2,r2,63455
811234e4:	80c00015 	stw	r3,0(r16)
811234e8:	8080030d 	sth	r2,12(r16)
811234ec:	01800204 	movi	r6,8
811234f0:	000b883a 	mov	r5,zero
811234f4:	81001704 	addi	r4,r16,92
811234f8:	11244a00 	call	811244a0 <memset>
811234fc:	003fc806 	br	81123420 <__reset+0xfb103420>
81123500:	800b883a 	mov	r5,r16
81123504:	8809883a 	mov	r4,r17
81123508:	112cfa40 	call	8112cfa4 <_fflush_r>
8112350c:	8080030b 	ldhu	r2,12(r16)
81123510:	10c4000c 	andi	r3,r2,4096
81123514:	18008726 	beq	r3,zero,81123734 <_fseeko_r+0x398>
81123518:	84c01417 	ldw	r19,80(r16)
8112351c:	10c0010c 	andi	r3,r2,4
81123520:	1800431e 	bne	r3,zero,81123630 <_fseeko_r+0x294>
81123524:	1080020c 	andi	r2,r2,8
81123528:	10008026 	beq	r2,zero,8112372c <_fseeko_r+0x390>
8112352c:	80c00017 	ldw	r3,0(r16)
81123530:	80800417 	ldw	r2,16(r16)
81123534:	18000226 	beq	r3,zero,81123540 <_fseeko_r+0x1a4>
81123538:	1887c83a 	sub	r3,r3,r2
8112353c:	98e7883a 	add	r19,r19,r3
81123540:	aceb883a 	add	r21,r21,r19
81123544:	05c00044 	movi	r23,1
81123548:	0025883a 	mov	r18,zero
8112354c:	003fc306 	br	8112345c <__reset+0xfb10345c>
81123550:	112d3a00 	call	8112d3a0 <__sinit>
81123554:	8080030b 	ldhu	r2,12(r16)
81123558:	00c04204 	movi	r3,264
8112355c:	1080420c 	andi	r2,r2,264
81123560:	10ffa51e 	bne	r2,r3,811233f8 <__reset+0xfb1033f8>
81123564:	800b883a 	mov	r5,r16
81123568:	8809883a 	mov	r4,r17
8112356c:	112cfa40 	call	8112cfa4 <_fflush_r>
81123570:	003fa106 	br	811233f8 <__reset+0xfb1033f8>
81123574:	8080030b 	ldhu	r2,12(r16)
81123578:	00c10004 	movi	r3,1024
8112357c:	80c01315 	stw	r3,76(r16)
81123580:	10c4b03a 	or	r2,r2,r3
81123584:	8080030d 	sth	r2,12(r16)
81123588:	9000311e 	bne	r18,zero,81123650 <_fseeko_r+0x2b4>
8112358c:	a82d883a 	mov	r22,r21
81123590:	b800371e 	bne	r23,zero,81123670 <_fseeko_r+0x2d4>
81123594:	8080030b 	ldhu	r2,12(r16)
81123598:	1084000c 	andi	r2,r2,4096
8112359c:	10007f26 	beq	r2,zero,8112379c <_fseeko_r+0x400>
811235a0:	80801417 	ldw	r2,80(r16)
811235a4:	81800117 	ldw	r6,4(r16)
811235a8:	81400c17 	ldw	r5,48(r16)
811235ac:	11a7c83a 	sub	r19,r2,r6
811235b0:	28008226 	beq	r5,zero,811237bc <_fseeko_r+0x420>
811235b4:	81c00f17 	ldw	r7,60(r16)
811235b8:	99e7c83a 	sub	r19,r19,r7
811235bc:	81000e17 	ldw	r4,56(r16)
811235c0:	80800417 	ldw	r2,16(r16)
811235c4:	99a7883a 	add	r19,r19,r6
811235c8:	2087c83a 	sub	r3,r4,r2
811235cc:	98e7c83a 	sub	r19,r19,r3
811235d0:	38c7883a 	add	r3,r7,r3
811235d4:	b4c02b16 	blt	r22,r19,81123684 <_fseeko_r+0x2e8>
811235d8:	98c9883a 	add	r4,r19,r3
811235dc:	b100292e 	bgeu	r22,r4,81123684 <_fseeko_r+0x2e8>
811235e0:	b4e7c83a 	sub	r19,r22,r19
811235e4:	14c5883a 	add	r2,r2,r19
811235e8:	1ce7c83a 	sub	r19,r3,r19
811235ec:	80800015 	stw	r2,0(r16)
811235f0:	84c00115 	stw	r19,4(r16)
811235f4:	28000526 	beq	r5,zero,8112360c <_fseeko_r+0x270>
811235f8:	80801004 	addi	r2,r16,64
811235fc:	28800226 	beq	r5,r2,81123608 <_fseeko_r+0x26c>
81123600:	8809883a 	mov	r4,r17
81123604:	112d8380 	call	8112d838 <_free_r>
81123608:	80000c15 	stw	zero,48(r16)
8112360c:	8080030b 	ldhu	r2,12(r16)
81123610:	01800204 	movi	r6,8
81123614:	000b883a 	mov	r5,zero
81123618:	10bff7cc 	andi	r2,r2,65503
8112361c:	8080030d 	sth	r2,12(r16)
81123620:	81001704 	addi	r4,r16,92
81123624:	11244a00 	call	811244a0 <memset>
81123628:	0027883a 	mov	r19,zero
8112362c:	003f7c06 	br	81123420 <__reset+0xfb103420>
81123630:	80c00117 	ldw	r3,4(r16)
81123634:	80800c17 	ldw	r2,48(r16)
81123638:	98e7c83a 	sub	r19,r19,r3
8112363c:	10003b26 	beq	r2,zero,8112372c <_fseeko_r+0x390>
81123640:	80c00f17 	ldw	r3,60(r16)
81123644:	80800417 	ldw	r2,16(r16)
81123648:	98e7c83a 	sub	r19,r19,r3
8112364c:	003fbc06 	br	81123540 <__reset+0xfb103540>
81123650:	8140038f 	ldh	r5,14(r16)
81123654:	d80d883a 	mov	r6,sp
81123658:	8809883a 	mov	r4,r17
8112365c:	11238040 	call	81123804 <_fstat_r>
81123660:	103f891e 	bne	r2,zero,81123488 <__reset+0xfb103488>
81123664:	dd800417 	ldw	r22,16(sp)
81123668:	adad883a 	add	r22,r21,r22
8112366c:	b83fc926 	beq	r23,zero,81123594 <__reset+0xfb103594>
81123670:	81400c17 	ldw	r5,48(r16)
81123674:	81800117 	ldw	r6,4(r16)
81123678:	28005026 	beq	r5,zero,811237bc <_fseeko_r+0x420>
8112367c:	81c00f17 	ldw	r7,60(r16)
81123680:	003fce06 	br	811235bc <__reset+0xfb1035bc>
81123684:	84c01317 	ldw	r19,76(r16)
81123688:	81400717 	ldw	r5,28(r16)
8112368c:	000f883a 	mov	r7,zero
81123690:	04e7c83a 	sub	r19,zero,r19
81123694:	9da6703a 	and	r19,r19,r22
81123698:	980d883a 	mov	r6,r19
8112369c:	8809883a 	mov	r4,r17
811236a0:	a03ee83a 	callr	r20
811236a4:	00ffffc4 	movi	r3,-1
811236a8:	10ff7726 	beq	r2,r3,81123488 <__reset+0xfb103488>
811236ac:	80800417 	ldw	r2,16(r16)
811236b0:	81400c17 	ldw	r5,48(r16)
811236b4:	80000115 	stw	zero,4(r16)
811236b8:	80800015 	stw	r2,0(r16)
811236bc:	28000526 	beq	r5,zero,811236d4 <_fseeko_r+0x338>
811236c0:	80801004 	addi	r2,r16,64
811236c4:	28800226 	beq	r5,r2,811236d0 <_fseeko_r+0x334>
811236c8:	8809883a 	mov	r4,r17
811236cc:	112d8380 	call	8112d838 <_free_r>
811236d0:	80000c15 	stw	zero,48(r16)
811236d4:	8080030b 	ldhu	r2,12(r16)
811236d8:	b4e7c83a 	sub	r19,r22,r19
811236dc:	10bff7cc 	andi	r2,r2,65503
811236e0:	8080030d 	sth	r2,12(r16)
811236e4:	98000b26 	beq	r19,zero,81123714 <_fseeko_r+0x378>
811236e8:	800b883a 	mov	r5,r16
811236ec:	8809883a 	mov	r4,r17
811236f0:	11248a00 	call	811248a0 <__srefill_r>
811236f4:	103f641e 	bne	r2,zero,81123488 <__reset+0xfb103488>
811236f8:	80800117 	ldw	r2,4(r16)
811236fc:	14ff6236 	bltu	r2,r19,81123488 <__reset+0xfb103488>
81123700:	80c00017 	ldw	r3,0(r16)
81123704:	14c5c83a 	sub	r2,r2,r19
81123708:	80800115 	stw	r2,4(r16)
8112370c:	1ce7883a 	add	r19,r3,r19
81123710:	84c00015 	stw	r19,0(r16)
81123714:	01800204 	movi	r6,8
81123718:	000b883a 	mov	r5,zero
8112371c:	81001704 	addi	r4,r16,92
81123720:	11244a00 	call	811244a0 <memset>
81123724:	0027883a 	mov	r19,zero
81123728:	003f3d06 	br	81123420 <__reset+0xfb103420>
8112372c:	80800417 	ldw	r2,16(r16)
81123730:	003f8306 	br	81123540 <__reset+0xfb103540>
81123734:	81400717 	ldw	r5,28(r16)
81123738:	900f883a 	mov	r7,r18
8112373c:	000d883a 	mov	r6,zero
81123740:	8809883a 	mov	r4,r17
81123744:	a03ee83a 	callr	r20
81123748:	1027883a 	mov	r19,r2
8112374c:	00bfffc4 	movi	r2,-1
81123750:	98bf3226 	beq	r19,r2,8112341c <__reset+0xfb10341c>
81123754:	8080030b 	ldhu	r2,12(r16)
81123758:	003f7006 	br	8112351c <__reset+0xfb10351c>
8112375c:	8140038f 	ldh	r5,14(r16)
81123760:	283f4716 	blt	r5,zero,81123480 <__reset+0xfb103480>
81123764:	d80d883a 	mov	r6,sp
81123768:	8809883a 	mov	r4,r17
8112376c:	11238040 	call	81123804 <_fstat_r>
81123770:	1000041e 	bne	r2,zero,81123784 <_fseeko_r+0x3e8>
81123774:	d8800117 	ldw	r2,4(sp)
81123778:	00e00014 	movui	r3,32768
8112377c:	10bc000c 	andi	r2,r2,61440
81123780:	10ff7c26 	beq	r2,r3,81123574 <__reset+0xfb103574>
81123784:	8080030b 	ldhu	r2,12(r16)
81123788:	003f3d06 	br	81123480 <__reset+0xfb103480>
8112378c:	800b883a 	mov	r5,r16
81123790:	8809883a 	mov	r4,r17
81123794:	11239780 	call	81123978 <__smakebuf_r>
81123798:	003f3106 	br	81123460 <__reset+0xfb103460>
8112379c:	81400717 	ldw	r5,28(r16)
811237a0:	01c00044 	movi	r7,1
811237a4:	000d883a 	mov	r6,zero
811237a8:	8809883a 	mov	r4,r17
811237ac:	a03ee83a 	callr	r20
811237b0:	00ffffc4 	movi	r3,-1
811237b4:	10ff7b1e 	bne	r2,r3,811235a4 <__reset+0xfb1035a4>
811237b8:	003f3306 	br	81123488 <__reset+0xfb103488>
811237bc:	80c00017 	ldw	r3,0(r16)
811237c0:	80800417 	ldw	r2,16(r16)
811237c4:	000b883a 	mov	r5,zero
811237c8:	1887c83a 	sub	r3,r3,r2
811237cc:	98e7c83a 	sub	r19,r19,r3
811237d0:	30c7883a 	add	r3,r6,r3
811237d4:	003f7f06 	br	811235d4 <__reset+0xfb1035d4>
811237d8:	00800744 	movi	r2,29
811237dc:	88800015 	stw	r2,0(r17)
811237e0:	04ffffc4 	movi	r19,-1
811237e4:	003f0e06 	br	81123420 <__reset+0xfb103420>

811237e8 <fseeko>:
811237e8:	00a04574 	movhi	r2,33045
811237ec:	10936004 	addi	r2,r2,19840
811237f0:	300f883a 	mov	r7,r6
811237f4:	280d883a 	mov	r6,r5
811237f8:	200b883a 	mov	r5,r4
811237fc:	11000017 	ldw	r4,0(r2)
81123800:	112339c1 	jmpi	8112339c <_fseeko_r>

81123804 <_fstat_r>:
81123804:	defffd04 	addi	sp,sp,-12
81123808:	de00012e 	bgeu	sp,et,81123810 <_fstat_r+0xc>
8112380c:	003b68fa 	trap	3
81123810:	2805883a 	mov	r2,r5
81123814:	dc000015 	stw	r16,0(sp)
81123818:	04204574 	movhi	r16,33045
8112381c:	dc400115 	stw	r17,4(sp)
81123820:	8413d304 	addi	r16,r16,20300
81123824:	2023883a 	mov	r17,r4
81123828:	300b883a 	mov	r5,r6
8112382c:	1009883a 	mov	r4,r2
81123830:	dfc00215 	stw	ra,8(sp)
81123834:	80000015 	stw	zero,0(r16)
81123838:	11381d00 	call	811381d0 <fstat>
8112383c:	00ffffc4 	movi	r3,-1
81123840:	10c00526 	beq	r2,r3,81123858 <_fstat_r+0x54>
81123844:	dfc00217 	ldw	ra,8(sp)
81123848:	dc400117 	ldw	r17,4(sp)
8112384c:	dc000017 	ldw	r16,0(sp)
81123850:	dec00304 	addi	sp,sp,12
81123854:	f800283a 	ret
81123858:	80c00017 	ldw	r3,0(r16)
8112385c:	183ff926 	beq	r3,zero,81123844 <__reset+0xfb103844>
81123860:	88c00015 	stw	r3,0(r17)
81123864:	003ff706 	br	81123844 <__reset+0xfb103844>

81123868 <_fwrite_r>:
81123868:	defff504 	addi	sp,sp,-44
8112386c:	de00012e 	bgeu	sp,et,81123874 <_fwrite_r+0xc>
81123870:	003b68fa 	trap	3
81123874:	dc800815 	stw	r18,32(sp)
81123878:	39a5383a 	mul	r18,r7,r6
8112387c:	d8800304 	addi	r2,sp,12
81123880:	d8800015 	stw	r2,0(sp)
81123884:	00800044 	movi	r2,1
81123888:	dcc00915 	stw	r19,36(sp)
8112388c:	dc400715 	stw	r17,28(sp)
81123890:	dc000615 	stw	r16,24(sp)
81123894:	d9400315 	stw	r5,12(sp)
81123898:	dfc00a15 	stw	ra,40(sp)
8112389c:	dc800415 	stw	r18,16(sp)
811238a0:	dc800215 	stw	r18,8(sp)
811238a4:	d8800115 	stw	r2,4(sp)
811238a8:	3027883a 	mov	r19,r6
811238ac:	3821883a 	mov	r16,r7
811238b0:	2023883a 	mov	r17,r4
811238b4:	d9400b17 	ldw	r5,44(sp)
811238b8:	20000226 	beq	r4,zero,811238c4 <_fwrite_r+0x5c>
811238bc:	20800e17 	ldw	r2,56(r4)
811238c0:	10001a26 	beq	r2,zero,8112392c <_fwrite_r+0xc4>
811238c4:	2880030b 	ldhu	r2,12(r5)
811238c8:	10c8000c 	andi	r3,r2,8192
811238cc:	1800061e 	bne	r3,zero,811238e8 <_fwrite_r+0x80>
811238d0:	29001917 	ldw	r4,100(r5)
811238d4:	00f7ffc4 	movi	r3,-8193
811238d8:	10880014 	ori	r2,r2,8192
811238dc:	20c6703a 	and	r3,r4,r3
811238e0:	2880030d 	sth	r2,12(r5)
811238e4:	28c01915 	stw	r3,100(r5)
811238e8:	d80d883a 	mov	r6,sp
811238ec:	8809883a 	mov	r4,r17
811238f0:	112db500 	call	8112db50 <__sfvwrite_r>
811238f4:	10000b26 	beq	r2,zero,81123924 <_fwrite_r+0xbc>
811238f8:	d9000217 	ldw	r4,8(sp)
811238fc:	980b883a 	mov	r5,r19
81123900:	9109c83a 	sub	r4,r18,r4
81123904:	113685c0 	call	8113685c <__udivsi3>
81123908:	dfc00a17 	ldw	ra,40(sp)
8112390c:	dcc00917 	ldw	r19,36(sp)
81123910:	dc800817 	ldw	r18,32(sp)
81123914:	dc400717 	ldw	r17,28(sp)
81123918:	dc000617 	ldw	r16,24(sp)
8112391c:	dec00b04 	addi	sp,sp,44
81123920:	f800283a 	ret
81123924:	8005883a 	mov	r2,r16
81123928:	003ff706 	br	81123908 <__reset+0xfb103908>
8112392c:	d9400515 	stw	r5,20(sp)
81123930:	112d3a00 	call	8112d3a0 <__sinit>
81123934:	d9400517 	ldw	r5,20(sp)
81123938:	003fe206 	br	811238c4 <__reset+0xfb1038c4>

8112393c <fwrite>:
8112393c:	defffe04 	addi	sp,sp,-8
81123940:	00a04574 	movhi	r2,33045
81123944:	de00012e 	bgeu	sp,et,8112394c <fwrite+0x10>
81123948:	003b68fa 	trap	3
8112394c:	10936004 	addi	r2,r2,19840
81123950:	d9c00015 	stw	r7,0(sp)
81123954:	300f883a 	mov	r7,r6
81123958:	280d883a 	mov	r6,r5
8112395c:	200b883a 	mov	r5,r4
81123960:	11000017 	ldw	r4,0(r2)
81123964:	dfc00115 	stw	ra,4(sp)
81123968:	11238680 	call	81123868 <_fwrite_r>
8112396c:	dfc00117 	ldw	ra,4(sp)
81123970:	dec00204 	addi	sp,sp,8
81123974:	f800283a 	ret

81123978 <__smakebuf_r>:
81123978:	2880030b 	ldhu	r2,12(r5)
8112397c:	10c0008c 	andi	r3,r2,2
81123980:	1800431e 	bne	r3,zero,81123a90 <__smakebuf_r+0x118>
81123984:	deffec04 	addi	sp,sp,-80
81123988:	de00012e 	bgeu	sp,et,81123990 <__smakebuf_r+0x18>
8112398c:	003b68fa 	trap	3
81123990:	dc000f15 	stw	r16,60(sp)
81123994:	2821883a 	mov	r16,r5
81123998:	2940038f 	ldh	r5,14(r5)
8112399c:	dc401015 	stw	r17,64(sp)
811239a0:	dfc01315 	stw	ra,76(sp)
811239a4:	dcc01215 	stw	r19,72(sp)
811239a8:	dc801115 	stw	r18,68(sp)
811239ac:	2023883a 	mov	r17,r4
811239b0:	28001c16 	blt	r5,zero,81123a24 <__smakebuf_r+0xac>
811239b4:	d80d883a 	mov	r6,sp
811239b8:	11238040 	call	81123804 <_fstat_r>
811239bc:	10001816 	blt	r2,zero,81123a20 <__smakebuf_r+0xa8>
811239c0:	d8800117 	ldw	r2,4(sp)
811239c4:	00e00014 	movui	r3,32768
811239c8:	10bc000c 	andi	r2,r2,61440
811239cc:	14c80020 	cmpeqi	r19,r2,8192
811239d0:	10c03726 	beq	r2,r3,81123ab0 <__smakebuf_r+0x138>
811239d4:	80c0030b 	ldhu	r3,12(r16)
811239d8:	18c20014 	ori	r3,r3,2048
811239dc:	80c0030d 	sth	r3,12(r16)
811239e0:	00c80004 	movi	r3,8192
811239e4:	10c0521e 	bne	r2,r3,81123b30 <__smakebuf_r+0x1b8>
811239e8:	8140038f 	ldh	r5,14(r16)
811239ec:	8809883a 	mov	r4,r17
811239f0:	112e1ac0 	call	8112e1ac <_isatty_r>
811239f4:	10004c26 	beq	r2,zero,81123b28 <__smakebuf_r+0x1b0>
811239f8:	8080030b 	ldhu	r2,12(r16)
811239fc:	80c010c4 	addi	r3,r16,67
81123a00:	80c00015 	stw	r3,0(r16)
81123a04:	10800054 	ori	r2,r2,1
81123a08:	8080030d 	sth	r2,12(r16)
81123a0c:	00800044 	movi	r2,1
81123a10:	80c00415 	stw	r3,16(r16)
81123a14:	80800515 	stw	r2,20(r16)
81123a18:	04810004 	movi	r18,1024
81123a1c:	00000706 	br	81123a3c <__smakebuf_r+0xc4>
81123a20:	8080030b 	ldhu	r2,12(r16)
81123a24:	10c0200c 	andi	r3,r2,128
81123a28:	18001f1e 	bne	r3,zero,81123aa8 <__smakebuf_r+0x130>
81123a2c:	04810004 	movi	r18,1024
81123a30:	10820014 	ori	r2,r2,2048
81123a34:	8080030d 	sth	r2,12(r16)
81123a38:	0027883a 	mov	r19,zero
81123a3c:	900b883a 	mov	r5,r18
81123a40:	8809883a 	mov	r4,r17
81123a44:	1123b3c0 	call	81123b3c <_malloc_r>
81123a48:	10002c26 	beq	r2,zero,81123afc <__smakebuf_r+0x184>
81123a4c:	80c0030b 	ldhu	r3,12(r16)
81123a50:	012044f4 	movhi	r4,33043
81123a54:	21341004 	addi	r4,r4,-12224
81123a58:	89000f15 	stw	r4,60(r17)
81123a5c:	18c02014 	ori	r3,r3,128
81123a60:	80c0030d 	sth	r3,12(r16)
81123a64:	80800015 	stw	r2,0(r16)
81123a68:	80800415 	stw	r2,16(r16)
81123a6c:	84800515 	stw	r18,20(r16)
81123a70:	98001a1e 	bne	r19,zero,81123adc <__smakebuf_r+0x164>
81123a74:	dfc01317 	ldw	ra,76(sp)
81123a78:	dcc01217 	ldw	r19,72(sp)
81123a7c:	dc801117 	ldw	r18,68(sp)
81123a80:	dc401017 	ldw	r17,64(sp)
81123a84:	dc000f17 	ldw	r16,60(sp)
81123a88:	dec01404 	addi	sp,sp,80
81123a8c:	f800283a 	ret
81123a90:	288010c4 	addi	r2,r5,67
81123a94:	28800015 	stw	r2,0(r5)
81123a98:	28800415 	stw	r2,16(r5)
81123a9c:	00800044 	movi	r2,1
81123aa0:	28800515 	stw	r2,20(r5)
81123aa4:	f800283a 	ret
81123aa8:	04801004 	movi	r18,64
81123aac:	003fe006 	br	81123a30 <__reset+0xfb103a30>
81123ab0:	81000a17 	ldw	r4,40(r16)
81123ab4:	00e044b4 	movhi	r3,33042
81123ab8:	18d34404 	addi	r3,r3,19728
81123abc:	20ffc51e 	bne	r4,r3,811239d4 <__reset+0xfb1039d4>
81123ac0:	8080030b 	ldhu	r2,12(r16)
81123ac4:	04810004 	movi	r18,1024
81123ac8:	84801315 	stw	r18,76(r16)
81123acc:	1484b03a 	or	r2,r2,r18
81123ad0:	8080030d 	sth	r2,12(r16)
81123ad4:	0027883a 	mov	r19,zero
81123ad8:	003fd806 	br	81123a3c <__reset+0xfb103a3c>
81123adc:	8140038f 	ldh	r5,14(r16)
81123ae0:	8809883a 	mov	r4,r17
81123ae4:	112e1ac0 	call	8112e1ac <_isatty_r>
81123ae8:	103fe226 	beq	r2,zero,81123a74 <__reset+0xfb103a74>
81123aec:	8080030b 	ldhu	r2,12(r16)
81123af0:	10800054 	ori	r2,r2,1
81123af4:	8080030d 	sth	r2,12(r16)
81123af8:	003fde06 	br	81123a74 <__reset+0xfb103a74>
81123afc:	8080030b 	ldhu	r2,12(r16)
81123b00:	10c0800c 	andi	r3,r2,512
81123b04:	183fdb1e 	bne	r3,zero,81123a74 <__reset+0xfb103a74>
81123b08:	10800094 	ori	r2,r2,2
81123b0c:	80c010c4 	addi	r3,r16,67
81123b10:	8080030d 	sth	r2,12(r16)
81123b14:	00800044 	movi	r2,1
81123b18:	80c00015 	stw	r3,0(r16)
81123b1c:	80c00415 	stw	r3,16(r16)
81123b20:	80800515 	stw	r2,20(r16)
81123b24:	003fd306 	br	81123a74 <__reset+0xfb103a74>
81123b28:	04810004 	movi	r18,1024
81123b2c:	003fc306 	br	81123a3c <__reset+0xfb103a3c>
81123b30:	0027883a 	mov	r19,zero
81123b34:	04810004 	movi	r18,1024
81123b38:	003fc006 	br	81123a3c <__reset+0xfb103a3c>

81123b3c <_malloc_r>:
81123b3c:	defff504 	addi	sp,sp,-44
81123b40:	de00012e 	bgeu	sp,et,81123b48 <_malloc_r+0xc>
81123b44:	003b68fa 	trap	3
81123b48:	288002c4 	addi	r2,r5,11
81123b4c:	dc800315 	stw	r18,12(sp)
81123b50:	dfc00a15 	stw	ra,40(sp)
81123b54:	df000915 	stw	fp,36(sp)
81123b58:	ddc00815 	stw	r23,32(sp)
81123b5c:	dd800715 	stw	r22,28(sp)
81123b60:	dd400615 	stw	r21,24(sp)
81123b64:	dd000515 	stw	r20,20(sp)
81123b68:	dcc00415 	stw	r19,16(sp)
81123b6c:	dc400215 	stw	r17,8(sp)
81123b70:	dc000115 	stw	r16,4(sp)
81123b74:	00c00584 	movi	r3,22
81123b78:	2025883a 	mov	r18,r4
81123b7c:	18807f2e 	bgeu	r3,r2,81123d7c <_malloc_r+0x240>
81123b80:	047ffe04 	movi	r17,-8
81123b84:	1462703a 	and	r17,r2,r17
81123b88:	8800a316 	blt	r17,zero,81123e18 <_malloc_r+0x2dc>
81123b8c:	8940a236 	bltu	r17,r5,81123e18 <_malloc_r+0x2dc>
81123b90:	1139d180 	call	81139d18 <__malloc_lock>
81123b94:	00807dc4 	movi	r2,503
81123b98:	1441e92e 	bgeu	r2,r17,81124340 <_malloc_r+0x804>
81123b9c:	8804d27a 	srli	r2,r17,9
81123ba0:	1000a126 	beq	r2,zero,81123e28 <_malloc_r+0x2ec>
81123ba4:	00c00104 	movi	r3,4
81123ba8:	18811e36 	bltu	r3,r2,81124024 <_malloc_r+0x4e8>
81123bac:	8804d1ba 	srli	r2,r17,6
81123bb0:	12000e44 	addi	r8,r2,57
81123bb4:	11c00e04 	addi	r7,r2,56
81123bb8:	4209883a 	add	r4,r8,r8
81123bbc:	04e04574 	movhi	r19,33045
81123bc0:	2109883a 	add	r4,r4,r4
81123bc4:	9ccd1e04 	addi	r19,r19,13432
81123bc8:	2109883a 	add	r4,r4,r4
81123bcc:	9909883a 	add	r4,r19,r4
81123bd0:	24000117 	ldw	r16,4(r4)
81123bd4:	213ffe04 	addi	r4,r4,-8
81123bd8:	24009726 	beq	r4,r16,81123e38 <_malloc_r+0x2fc>
81123bdc:	80800117 	ldw	r2,4(r16)
81123be0:	01bfff04 	movi	r6,-4
81123be4:	014003c4 	movi	r5,15
81123be8:	1184703a 	and	r2,r2,r6
81123bec:	1447c83a 	sub	r3,r2,r17
81123bf0:	28c00716 	blt	r5,r3,81123c10 <_malloc_r+0xd4>
81123bf4:	1800920e 	bge	r3,zero,81123e40 <_malloc_r+0x304>
81123bf8:	84000317 	ldw	r16,12(r16)
81123bfc:	24008e26 	beq	r4,r16,81123e38 <_malloc_r+0x2fc>
81123c00:	80800117 	ldw	r2,4(r16)
81123c04:	1184703a 	and	r2,r2,r6
81123c08:	1447c83a 	sub	r3,r2,r17
81123c0c:	28fff90e 	bge	r5,r3,81123bf4 <__reset+0xfb103bf4>
81123c10:	3809883a 	mov	r4,r7
81123c14:	01a04574 	movhi	r6,33045
81123c18:	9c000417 	ldw	r16,16(r19)
81123c1c:	318d1e04 	addi	r6,r6,13432
81123c20:	32000204 	addi	r8,r6,8
81123c24:	82013426 	beq	r16,r8,811240f8 <_malloc_r+0x5bc>
81123c28:	80c00117 	ldw	r3,4(r16)
81123c2c:	00bfff04 	movi	r2,-4
81123c30:	188e703a 	and	r7,r3,r2
81123c34:	3c45c83a 	sub	r2,r7,r17
81123c38:	00c003c4 	movi	r3,15
81123c3c:	18811f16 	blt	r3,r2,811240bc <_malloc_r+0x580>
81123c40:	32000515 	stw	r8,20(r6)
81123c44:	32000415 	stw	r8,16(r6)
81123c48:	10007f0e 	bge	r2,zero,81123e48 <_malloc_r+0x30c>
81123c4c:	00807fc4 	movi	r2,511
81123c50:	11c0fd36 	bltu	r2,r7,81124048 <_malloc_r+0x50c>
81123c54:	3806d0fa 	srli	r3,r7,3
81123c58:	01c00044 	movi	r7,1
81123c5c:	30800117 	ldw	r2,4(r6)
81123c60:	19400044 	addi	r5,r3,1
81123c64:	294b883a 	add	r5,r5,r5
81123c68:	1807d0ba 	srai	r3,r3,2
81123c6c:	294b883a 	add	r5,r5,r5
81123c70:	294b883a 	add	r5,r5,r5
81123c74:	298b883a 	add	r5,r5,r6
81123c78:	38c6983a 	sll	r3,r7,r3
81123c7c:	29c00017 	ldw	r7,0(r5)
81123c80:	2a7ffe04 	addi	r9,r5,-8
81123c84:	1886b03a 	or	r3,r3,r2
81123c88:	82400315 	stw	r9,12(r16)
81123c8c:	81c00215 	stw	r7,8(r16)
81123c90:	30c00115 	stw	r3,4(r6)
81123c94:	2c000015 	stw	r16,0(r5)
81123c98:	3c000315 	stw	r16,12(r7)
81123c9c:	2005d0ba 	srai	r2,r4,2
81123ca0:	01400044 	movi	r5,1
81123ca4:	288a983a 	sll	r5,r5,r2
81123ca8:	19406f36 	bltu	r3,r5,81123e68 <_malloc_r+0x32c>
81123cac:	28c4703a 	and	r2,r5,r3
81123cb0:	10000a1e 	bne	r2,zero,81123cdc <_malloc_r+0x1a0>
81123cb4:	00bfff04 	movi	r2,-4
81123cb8:	294b883a 	add	r5,r5,r5
81123cbc:	2088703a 	and	r4,r4,r2
81123cc0:	28c4703a 	and	r2,r5,r3
81123cc4:	21000104 	addi	r4,r4,4
81123cc8:	1000041e 	bne	r2,zero,81123cdc <_malloc_r+0x1a0>
81123ccc:	294b883a 	add	r5,r5,r5
81123cd0:	28c4703a 	and	r2,r5,r3
81123cd4:	21000104 	addi	r4,r4,4
81123cd8:	103ffc26 	beq	r2,zero,81123ccc <__reset+0xfb103ccc>
81123cdc:	02bfff04 	movi	r10,-4
81123ce0:	024003c4 	movi	r9,15
81123ce4:	21800044 	addi	r6,r4,1
81123ce8:	318d883a 	add	r6,r6,r6
81123cec:	318d883a 	add	r6,r6,r6
81123cf0:	318d883a 	add	r6,r6,r6
81123cf4:	998d883a 	add	r6,r19,r6
81123cf8:	333ffe04 	addi	r12,r6,-8
81123cfc:	2017883a 	mov	r11,r4
81123d00:	31800104 	addi	r6,r6,4
81123d04:	34000017 	ldw	r16,0(r6)
81123d08:	31fffd04 	addi	r7,r6,-12
81123d0c:	81c0041e 	bne	r16,r7,81123d20 <_malloc_r+0x1e4>
81123d10:	0000fb06 	br	81124100 <_malloc_r+0x5c4>
81123d14:	1801030e 	bge	r3,zero,81124124 <_malloc_r+0x5e8>
81123d18:	84000317 	ldw	r16,12(r16)
81123d1c:	81c0f826 	beq	r16,r7,81124100 <_malloc_r+0x5c4>
81123d20:	80800117 	ldw	r2,4(r16)
81123d24:	1284703a 	and	r2,r2,r10
81123d28:	1447c83a 	sub	r3,r2,r17
81123d2c:	48fff90e 	bge	r9,r3,81123d14 <__reset+0xfb103d14>
81123d30:	80800317 	ldw	r2,12(r16)
81123d34:	81000217 	ldw	r4,8(r16)
81123d38:	89400054 	ori	r5,r17,1
81123d3c:	81400115 	stw	r5,4(r16)
81123d40:	20800315 	stw	r2,12(r4)
81123d44:	11000215 	stw	r4,8(r2)
81123d48:	8463883a 	add	r17,r16,r17
81123d4c:	9c400515 	stw	r17,20(r19)
81123d50:	9c400415 	stw	r17,16(r19)
81123d54:	18800054 	ori	r2,r3,1
81123d58:	88800115 	stw	r2,4(r17)
81123d5c:	8a000315 	stw	r8,12(r17)
81123d60:	8a000215 	stw	r8,8(r17)
81123d64:	88e3883a 	add	r17,r17,r3
81123d68:	88c00015 	stw	r3,0(r17)
81123d6c:	9009883a 	mov	r4,r18
81123d70:	1139e400 	call	81139e40 <__malloc_unlock>
81123d74:	80800204 	addi	r2,r16,8
81123d78:	00001b06 	br	81123de8 <_malloc_r+0x2ac>
81123d7c:	04400404 	movi	r17,16
81123d80:	89402536 	bltu	r17,r5,81123e18 <_malloc_r+0x2dc>
81123d84:	1139d180 	call	81139d18 <__malloc_lock>
81123d88:	00800184 	movi	r2,6
81123d8c:	01000084 	movi	r4,2
81123d90:	04e04574 	movhi	r19,33045
81123d94:	1085883a 	add	r2,r2,r2
81123d98:	9ccd1e04 	addi	r19,r19,13432
81123d9c:	1085883a 	add	r2,r2,r2
81123da0:	9885883a 	add	r2,r19,r2
81123da4:	14000117 	ldw	r16,4(r2)
81123da8:	10fffe04 	addi	r3,r2,-8
81123dac:	80c0d926 	beq	r16,r3,81124114 <_malloc_r+0x5d8>
81123db0:	80c00117 	ldw	r3,4(r16)
81123db4:	81000317 	ldw	r4,12(r16)
81123db8:	00bfff04 	movi	r2,-4
81123dbc:	1884703a 	and	r2,r3,r2
81123dc0:	81400217 	ldw	r5,8(r16)
81123dc4:	8085883a 	add	r2,r16,r2
81123dc8:	10c00117 	ldw	r3,4(r2)
81123dcc:	29000315 	stw	r4,12(r5)
81123dd0:	21400215 	stw	r5,8(r4)
81123dd4:	18c00054 	ori	r3,r3,1
81123dd8:	10c00115 	stw	r3,4(r2)
81123ddc:	9009883a 	mov	r4,r18
81123de0:	1139e400 	call	81139e40 <__malloc_unlock>
81123de4:	80800204 	addi	r2,r16,8
81123de8:	dfc00a17 	ldw	ra,40(sp)
81123dec:	df000917 	ldw	fp,36(sp)
81123df0:	ddc00817 	ldw	r23,32(sp)
81123df4:	dd800717 	ldw	r22,28(sp)
81123df8:	dd400617 	ldw	r21,24(sp)
81123dfc:	dd000517 	ldw	r20,20(sp)
81123e00:	dcc00417 	ldw	r19,16(sp)
81123e04:	dc800317 	ldw	r18,12(sp)
81123e08:	dc400217 	ldw	r17,8(sp)
81123e0c:	dc000117 	ldw	r16,4(sp)
81123e10:	dec00b04 	addi	sp,sp,44
81123e14:	f800283a 	ret
81123e18:	00800304 	movi	r2,12
81123e1c:	90800015 	stw	r2,0(r18)
81123e20:	0005883a 	mov	r2,zero
81123e24:	003ff006 	br	81123de8 <__reset+0xfb103de8>
81123e28:	01002004 	movi	r4,128
81123e2c:	02001004 	movi	r8,64
81123e30:	01c00fc4 	movi	r7,63
81123e34:	003f6106 	br	81123bbc <__reset+0xfb103bbc>
81123e38:	4009883a 	mov	r4,r8
81123e3c:	003f7506 	br	81123c14 <__reset+0xfb103c14>
81123e40:	81000317 	ldw	r4,12(r16)
81123e44:	003fde06 	br	81123dc0 <__reset+0xfb103dc0>
81123e48:	81c5883a 	add	r2,r16,r7
81123e4c:	11400117 	ldw	r5,4(r2)
81123e50:	9009883a 	mov	r4,r18
81123e54:	29400054 	ori	r5,r5,1
81123e58:	11400115 	stw	r5,4(r2)
81123e5c:	1139e400 	call	81139e40 <__malloc_unlock>
81123e60:	80800204 	addi	r2,r16,8
81123e64:	003fe006 	br	81123de8 <__reset+0xfb103de8>
81123e68:	9c000217 	ldw	r16,8(r19)
81123e6c:	00bfff04 	movi	r2,-4
81123e70:	85800117 	ldw	r22,4(r16)
81123e74:	b0ac703a 	and	r22,r22,r2
81123e78:	b4400336 	bltu	r22,r17,81123e88 <_malloc_r+0x34c>
81123e7c:	b445c83a 	sub	r2,r22,r17
81123e80:	00c003c4 	movi	r3,15
81123e84:	18805d16 	blt	r3,r2,81123ffc <_malloc_r+0x4c0>
81123e88:	05e04574 	movhi	r23,33045
81123e8c:	00a04574 	movhi	r2,33045
81123e90:	1093d604 	addi	r2,r2,20312
81123e94:	bdd36104 	addi	r23,r23,19844
81123e98:	15400017 	ldw	r21,0(r2)
81123e9c:	b8c00017 	ldw	r3,0(r23)
81123ea0:	00bfffc4 	movi	r2,-1
81123ea4:	858d883a 	add	r6,r16,r22
81123ea8:	8d6b883a 	add	r21,r17,r21
81123eac:	1880ea26 	beq	r3,r2,81124258 <_malloc_r+0x71c>
81123eb0:	ad4403c4 	addi	r21,r21,4111
81123eb4:	00bc0004 	movi	r2,-4096
81123eb8:	a8aa703a 	and	r21,r21,r2
81123ebc:	a80b883a 	mov	r5,r21
81123ec0:	9009883a 	mov	r4,r18
81123ec4:	d9800015 	stw	r6,0(sp)
81123ec8:	1124a7c0 	call	81124a7c <_sbrk_r>
81123ecc:	1029883a 	mov	r20,r2
81123ed0:	00bfffc4 	movi	r2,-1
81123ed4:	d9800017 	ldw	r6,0(sp)
81123ed8:	a080e826 	beq	r20,r2,8112427c <_malloc_r+0x740>
81123edc:	a180a636 	bltu	r20,r6,81124178 <_malloc_r+0x63c>
81123ee0:	07204574 	movhi	fp,33045
81123ee4:	e7146304 	addi	fp,fp,20876
81123ee8:	e0800017 	ldw	r2,0(fp)
81123eec:	a887883a 	add	r3,r21,r2
81123ef0:	e0c00015 	stw	r3,0(fp)
81123ef4:	3500e626 	beq	r6,r20,81124290 <_malloc_r+0x754>
81123ef8:	b9000017 	ldw	r4,0(r23)
81123efc:	00bfffc4 	movi	r2,-1
81123f00:	2080ee26 	beq	r4,r2,811242bc <_malloc_r+0x780>
81123f04:	a185c83a 	sub	r2,r20,r6
81123f08:	10c5883a 	add	r2,r2,r3
81123f0c:	e0800015 	stw	r2,0(fp)
81123f10:	a0c001cc 	andi	r3,r20,7
81123f14:	1800bc26 	beq	r3,zero,81124208 <_malloc_r+0x6cc>
81123f18:	a0e9c83a 	sub	r20,r20,r3
81123f1c:	00840204 	movi	r2,4104
81123f20:	a5000204 	addi	r20,r20,8
81123f24:	10c7c83a 	sub	r3,r2,r3
81123f28:	a545883a 	add	r2,r20,r21
81123f2c:	1083ffcc 	andi	r2,r2,4095
81123f30:	18abc83a 	sub	r21,r3,r2
81123f34:	a80b883a 	mov	r5,r21
81123f38:	9009883a 	mov	r4,r18
81123f3c:	1124a7c0 	call	81124a7c <_sbrk_r>
81123f40:	00ffffc4 	movi	r3,-1
81123f44:	10c0e126 	beq	r2,r3,811242cc <_malloc_r+0x790>
81123f48:	1505c83a 	sub	r2,r2,r20
81123f4c:	1545883a 	add	r2,r2,r21
81123f50:	10800054 	ori	r2,r2,1
81123f54:	e0c00017 	ldw	r3,0(fp)
81123f58:	9d000215 	stw	r20,8(r19)
81123f5c:	a0800115 	stw	r2,4(r20)
81123f60:	a8c7883a 	add	r3,r21,r3
81123f64:	e0c00015 	stw	r3,0(fp)
81123f68:	84c00e26 	beq	r16,r19,81123fa4 <_malloc_r+0x468>
81123f6c:	018003c4 	movi	r6,15
81123f70:	3580a72e 	bgeu	r6,r22,81124210 <_malloc_r+0x6d4>
81123f74:	81400117 	ldw	r5,4(r16)
81123f78:	013ffe04 	movi	r4,-8
81123f7c:	b0bffd04 	addi	r2,r22,-12
81123f80:	1104703a 	and	r2,r2,r4
81123f84:	2900004c 	andi	r4,r5,1
81123f88:	2088b03a 	or	r4,r4,r2
81123f8c:	81000115 	stw	r4,4(r16)
81123f90:	01400144 	movi	r5,5
81123f94:	8089883a 	add	r4,r16,r2
81123f98:	21400115 	stw	r5,4(r4)
81123f9c:	21400215 	stw	r5,8(r4)
81123fa0:	3080cd36 	bltu	r6,r2,811242d8 <_malloc_r+0x79c>
81123fa4:	00a04574 	movhi	r2,33045
81123fa8:	1093d504 	addi	r2,r2,20308
81123fac:	11000017 	ldw	r4,0(r2)
81123fb0:	20c0012e 	bgeu	r4,r3,81123fb8 <_malloc_r+0x47c>
81123fb4:	10c00015 	stw	r3,0(r2)
81123fb8:	00a04574 	movhi	r2,33045
81123fbc:	1093d404 	addi	r2,r2,20304
81123fc0:	11000017 	ldw	r4,0(r2)
81123fc4:	9c000217 	ldw	r16,8(r19)
81123fc8:	20c0012e 	bgeu	r4,r3,81123fd0 <_malloc_r+0x494>
81123fcc:	10c00015 	stw	r3,0(r2)
81123fd0:	80c00117 	ldw	r3,4(r16)
81123fd4:	00bfff04 	movi	r2,-4
81123fd8:	1886703a 	and	r3,r3,r2
81123fdc:	1c45c83a 	sub	r2,r3,r17
81123fe0:	1c400236 	bltu	r3,r17,81123fec <_malloc_r+0x4b0>
81123fe4:	00c003c4 	movi	r3,15
81123fe8:	18800416 	blt	r3,r2,81123ffc <_malloc_r+0x4c0>
81123fec:	9009883a 	mov	r4,r18
81123ff0:	1139e400 	call	81139e40 <__malloc_unlock>
81123ff4:	0005883a 	mov	r2,zero
81123ff8:	003f7b06 	br	81123de8 <__reset+0xfb103de8>
81123ffc:	88c00054 	ori	r3,r17,1
81124000:	80c00115 	stw	r3,4(r16)
81124004:	8463883a 	add	r17,r16,r17
81124008:	10800054 	ori	r2,r2,1
8112400c:	9c400215 	stw	r17,8(r19)
81124010:	88800115 	stw	r2,4(r17)
81124014:	9009883a 	mov	r4,r18
81124018:	1139e400 	call	81139e40 <__malloc_unlock>
8112401c:	80800204 	addi	r2,r16,8
81124020:	003f7106 	br	81123de8 <__reset+0xfb103de8>
81124024:	00c00504 	movi	r3,20
81124028:	18804a2e 	bgeu	r3,r2,81124154 <_malloc_r+0x618>
8112402c:	00c01504 	movi	r3,84
81124030:	18806e36 	bltu	r3,r2,811241ec <_malloc_r+0x6b0>
81124034:	8804d33a 	srli	r2,r17,12
81124038:	12001bc4 	addi	r8,r2,111
8112403c:	11c01b84 	addi	r7,r2,110
81124040:	4209883a 	add	r4,r8,r8
81124044:	003edd06 	br	81123bbc <__reset+0xfb103bbc>
81124048:	3804d27a 	srli	r2,r7,9
8112404c:	00c00104 	movi	r3,4
81124050:	1880442e 	bgeu	r3,r2,81124164 <_malloc_r+0x628>
81124054:	00c00504 	movi	r3,20
81124058:	18808136 	bltu	r3,r2,81124260 <_malloc_r+0x724>
8112405c:	11401704 	addi	r5,r2,92
81124060:	10c016c4 	addi	r3,r2,91
81124064:	294b883a 	add	r5,r5,r5
81124068:	294b883a 	add	r5,r5,r5
8112406c:	294b883a 	add	r5,r5,r5
81124070:	994b883a 	add	r5,r19,r5
81124074:	28800017 	ldw	r2,0(r5)
81124078:	01a04574 	movhi	r6,33045
8112407c:	297ffe04 	addi	r5,r5,-8
81124080:	318d1e04 	addi	r6,r6,13432
81124084:	28806526 	beq	r5,r2,8112421c <_malloc_r+0x6e0>
81124088:	01bfff04 	movi	r6,-4
8112408c:	10c00117 	ldw	r3,4(r2)
81124090:	1986703a 	and	r3,r3,r6
81124094:	38c0022e 	bgeu	r7,r3,811240a0 <_malloc_r+0x564>
81124098:	10800217 	ldw	r2,8(r2)
8112409c:	28bffb1e 	bne	r5,r2,8112408c <__reset+0xfb10408c>
811240a0:	11400317 	ldw	r5,12(r2)
811240a4:	98c00117 	ldw	r3,4(r19)
811240a8:	81400315 	stw	r5,12(r16)
811240ac:	80800215 	stw	r2,8(r16)
811240b0:	2c000215 	stw	r16,8(r5)
811240b4:	14000315 	stw	r16,12(r2)
811240b8:	003ef806 	br	81123c9c <__reset+0xfb103c9c>
811240bc:	88c00054 	ori	r3,r17,1
811240c0:	80c00115 	stw	r3,4(r16)
811240c4:	8463883a 	add	r17,r16,r17
811240c8:	34400515 	stw	r17,20(r6)
811240cc:	34400415 	stw	r17,16(r6)
811240d0:	10c00054 	ori	r3,r2,1
811240d4:	8a000315 	stw	r8,12(r17)
811240d8:	8a000215 	stw	r8,8(r17)
811240dc:	88c00115 	stw	r3,4(r17)
811240e0:	88a3883a 	add	r17,r17,r2
811240e4:	88800015 	stw	r2,0(r17)
811240e8:	9009883a 	mov	r4,r18
811240ec:	1139e400 	call	81139e40 <__malloc_unlock>
811240f0:	80800204 	addi	r2,r16,8
811240f4:	003f3c06 	br	81123de8 <__reset+0xfb103de8>
811240f8:	30c00117 	ldw	r3,4(r6)
811240fc:	003ee706 	br	81123c9c <__reset+0xfb103c9c>
81124100:	5ac00044 	addi	r11,r11,1
81124104:	588000cc 	andi	r2,r11,3
81124108:	31800204 	addi	r6,r6,8
8112410c:	103efd1e 	bne	r2,zero,81123d04 <__reset+0xfb103d04>
81124110:	00002406 	br	811241a4 <_malloc_r+0x668>
81124114:	14000317 	ldw	r16,12(r2)
81124118:	143f251e 	bne	r2,r16,81123db0 <__reset+0xfb103db0>
8112411c:	21000084 	addi	r4,r4,2
81124120:	003ebc06 	br	81123c14 <__reset+0xfb103c14>
81124124:	8085883a 	add	r2,r16,r2
81124128:	10c00117 	ldw	r3,4(r2)
8112412c:	81000317 	ldw	r4,12(r16)
81124130:	81400217 	ldw	r5,8(r16)
81124134:	18c00054 	ori	r3,r3,1
81124138:	10c00115 	stw	r3,4(r2)
8112413c:	29000315 	stw	r4,12(r5)
81124140:	21400215 	stw	r5,8(r4)
81124144:	9009883a 	mov	r4,r18
81124148:	1139e400 	call	81139e40 <__malloc_unlock>
8112414c:	80800204 	addi	r2,r16,8
81124150:	003f2506 	br	81123de8 <__reset+0xfb103de8>
81124154:	12001704 	addi	r8,r2,92
81124158:	11c016c4 	addi	r7,r2,91
8112415c:	4209883a 	add	r4,r8,r8
81124160:	003e9606 	br	81123bbc <__reset+0xfb103bbc>
81124164:	3804d1ba 	srli	r2,r7,6
81124168:	11400e44 	addi	r5,r2,57
8112416c:	10c00e04 	addi	r3,r2,56
81124170:	294b883a 	add	r5,r5,r5
81124174:	003fbc06 	br	81124068 <__reset+0xfb104068>
81124178:	84ff5926 	beq	r16,r19,81123ee0 <__reset+0xfb103ee0>
8112417c:	00a04574 	movhi	r2,33045
81124180:	108d1e04 	addi	r2,r2,13432
81124184:	14000217 	ldw	r16,8(r2)
81124188:	00bfff04 	movi	r2,-4
8112418c:	80c00117 	ldw	r3,4(r16)
81124190:	1886703a 	and	r3,r3,r2
81124194:	003f9106 	br	81123fdc <__reset+0xfb103fdc>
81124198:	60800217 	ldw	r2,8(r12)
8112419c:	213fffc4 	addi	r4,r4,-1
811241a0:	1300651e 	bne	r2,r12,81124338 <_malloc_r+0x7fc>
811241a4:	208000cc 	andi	r2,r4,3
811241a8:	633ffe04 	addi	r12,r12,-8
811241ac:	103ffa1e 	bne	r2,zero,81124198 <__reset+0xfb104198>
811241b0:	98800117 	ldw	r2,4(r19)
811241b4:	0146303a 	nor	r3,zero,r5
811241b8:	1884703a 	and	r2,r3,r2
811241bc:	98800115 	stw	r2,4(r19)
811241c0:	294b883a 	add	r5,r5,r5
811241c4:	117f2836 	bltu	r2,r5,81123e68 <__reset+0xfb103e68>
811241c8:	283f2726 	beq	r5,zero,81123e68 <__reset+0xfb103e68>
811241cc:	2886703a 	and	r3,r5,r2
811241d0:	5809883a 	mov	r4,r11
811241d4:	183ec31e 	bne	r3,zero,81123ce4 <__reset+0xfb103ce4>
811241d8:	294b883a 	add	r5,r5,r5
811241dc:	2886703a 	and	r3,r5,r2
811241e0:	21000104 	addi	r4,r4,4
811241e4:	183ffc26 	beq	r3,zero,811241d8 <__reset+0xfb1041d8>
811241e8:	003ebe06 	br	81123ce4 <__reset+0xfb103ce4>
811241ec:	00c05504 	movi	r3,340
811241f0:	18801236 	bltu	r3,r2,8112423c <_malloc_r+0x700>
811241f4:	8804d3fa 	srli	r2,r17,15
811241f8:	12001e04 	addi	r8,r2,120
811241fc:	11c01dc4 	addi	r7,r2,119
81124200:	4209883a 	add	r4,r8,r8
81124204:	003e6d06 	br	81123bbc <__reset+0xfb103bbc>
81124208:	00c40004 	movi	r3,4096
8112420c:	003f4606 	br	81123f28 <__reset+0xfb103f28>
81124210:	00800044 	movi	r2,1
81124214:	a0800115 	stw	r2,4(r20)
81124218:	003f7406 	br	81123fec <__reset+0xfb103fec>
8112421c:	1805d0ba 	srai	r2,r3,2
81124220:	01c00044 	movi	r7,1
81124224:	30c00117 	ldw	r3,4(r6)
81124228:	388e983a 	sll	r7,r7,r2
8112422c:	2805883a 	mov	r2,r5
81124230:	38c6b03a 	or	r3,r7,r3
81124234:	30c00115 	stw	r3,4(r6)
81124238:	003f9b06 	br	811240a8 <__reset+0xfb1040a8>
8112423c:	00c15504 	movi	r3,1364
81124240:	18801a36 	bltu	r3,r2,811242ac <_malloc_r+0x770>
81124244:	8804d4ba 	srli	r2,r17,18
81124248:	12001f44 	addi	r8,r2,125
8112424c:	11c01f04 	addi	r7,r2,124
81124250:	4209883a 	add	r4,r8,r8
81124254:	003e5906 	br	81123bbc <__reset+0xfb103bbc>
81124258:	ad400404 	addi	r21,r21,16
8112425c:	003f1706 	br	81123ebc <__reset+0xfb103ebc>
81124260:	00c01504 	movi	r3,84
81124264:	18802336 	bltu	r3,r2,811242f4 <_malloc_r+0x7b8>
81124268:	3804d33a 	srli	r2,r7,12
8112426c:	11401bc4 	addi	r5,r2,111
81124270:	10c01b84 	addi	r3,r2,110
81124274:	294b883a 	add	r5,r5,r5
81124278:	003f7b06 	br	81124068 <__reset+0xfb104068>
8112427c:	9c000217 	ldw	r16,8(r19)
81124280:	00bfff04 	movi	r2,-4
81124284:	80c00117 	ldw	r3,4(r16)
81124288:	1886703a 	and	r3,r3,r2
8112428c:	003f5306 	br	81123fdc <__reset+0xfb103fdc>
81124290:	3083ffcc 	andi	r2,r6,4095
81124294:	103f181e 	bne	r2,zero,81123ef8 <__reset+0xfb103ef8>
81124298:	99000217 	ldw	r4,8(r19)
8112429c:	b545883a 	add	r2,r22,r21
811242a0:	10800054 	ori	r2,r2,1
811242a4:	20800115 	stw	r2,4(r4)
811242a8:	003f3e06 	br	81123fa4 <__reset+0xfb103fa4>
811242ac:	01003f84 	movi	r4,254
811242b0:	02001fc4 	movi	r8,127
811242b4:	01c01f84 	movi	r7,126
811242b8:	003e4006 	br	81123bbc <__reset+0xfb103bbc>
811242bc:	00a04574 	movhi	r2,33045
811242c0:	10936104 	addi	r2,r2,19844
811242c4:	15000015 	stw	r20,0(r2)
811242c8:	003f1106 	br	81123f10 <__reset+0xfb103f10>
811242cc:	00800044 	movi	r2,1
811242d0:	002b883a 	mov	r21,zero
811242d4:	003f1f06 	br	81123f54 <__reset+0xfb103f54>
811242d8:	81400204 	addi	r5,r16,8
811242dc:	9009883a 	mov	r4,r18
811242e0:	112d8380 	call	8112d838 <_free_r>
811242e4:	00a04574 	movhi	r2,33045
811242e8:	10946304 	addi	r2,r2,20876
811242ec:	10c00017 	ldw	r3,0(r2)
811242f0:	003f2c06 	br	81123fa4 <__reset+0xfb103fa4>
811242f4:	00c05504 	movi	r3,340
811242f8:	18800536 	bltu	r3,r2,81124310 <_malloc_r+0x7d4>
811242fc:	3804d3fa 	srli	r2,r7,15
81124300:	11401e04 	addi	r5,r2,120
81124304:	10c01dc4 	addi	r3,r2,119
81124308:	294b883a 	add	r5,r5,r5
8112430c:	003f5606 	br	81124068 <__reset+0xfb104068>
81124310:	00c15504 	movi	r3,1364
81124314:	18800536 	bltu	r3,r2,8112432c <_malloc_r+0x7f0>
81124318:	3804d4ba 	srli	r2,r7,18
8112431c:	11401f44 	addi	r5,r2,125
81124320:	10c01f04 	addi	r3,r2,124
81124324:	294b883a 	add	r5,r5,r5
81124328:	003f4f06 	br	81124068 <__reset+0xfb104068>
8112432c:	01403f84 	movi	r5,254
81124330:	00c01f84 	movi	r3,126
81124334:	003f4c06 	br	81124068 <__reset+0xfb104068>
81124338:	98800117 	ldw	r2,4(r19)
8112433c:	003fa006 	br	811241c0 <__reset+0xfb1041c0>
81124340:	8808d0fa 	srli	r4,r17,3
81124344:	20800044 	addi	r2,r4,1
81124348:	1085883a 	add	r2,r2,r2
8112434c:	003e9006 	br	81123d90 <__reset+0xfb103d90>

81124350 <memcpy>:
81124350:	defffd04 	addi	sp,sp,-12
81124354:	de00012e 	bgeu	sp,et,8112435c <memcpy+0xc>
81124358:	003b68fa 	trap	3
8112435c:	00c003c4 	movi	r3,15
81124360:	dfc00215 	stw	ra,8(sp)
81124364:	dc400115 	stw	r17,4(sp)
81124368:	dc000015 	stw	r16,0(sp)
8112436c:	2005883a 	mov	r2,r4
81124370:	1980452e 	bgeu	r3,r6,81124488 <memcpy+0x138>
81124374:	2906b03a 	or	r3,r5,r4
81124378:	18c000cc 	andi	r3,r3,3
8112437c:	1800441e 	bne	r3,zero,81124490 <memcpy+0x140>
81124380:	347ffc04 	addi	r17,r6,-16
81124384:	8822d13a 	srli	r17,r17,4
81124388:	28c00104 	addi	r3,r5,4
8112438c:	23400104 	addi	r13,r4,4
81124390:	8820913a 	slli	r16,r17,4
81124394:	2b000204 	addi	r12,r5,8
81124398:	22c00204 	addi	r11,r4,8
8112439c:	84000504 	addi	r16,r16,20
811243a0:	2a800304 	addi	r10,r5,12
811243a4:	22400304 	addi	r9,r4,12
811243a8:	2c21883a 	add	r16,r5,r16
811243ac:	2811883a 	mov	r8,r5
811243b0:	200f883a 	mov	r7,r4
811243b4:	41000017 	ldw	r4,0(r8)
811243b8:	1fc00017 	ldw	ra,0(r3)
811243bc:	63c00017 	ldw	r15,0(r12)
811243c0:	39000015 	stw	r4,0(r7)
811243c4:	53800017 	ldw	r14,0(r10)
811243c8:	6fc00015 	stw	ra,0(r13)
811243cc:	5bc00015 	stw	r15,0(r11)
811243d0:	4b800015 	stw	r14,0(r9)
811243d4:	18c00404 	addi	r3,r3,16
811243d8:	39c00404 	addi	r7,r7,16
811243dc:	42000404 	addi	r8,r8,16
811243e0:	6b400404 	addi	r13,r13,16
811243e4:	63000404 	addi	r12,r12,16
811243e8:	5ac00404 	addi	r11,r11,16
811243ec:	52800404 	addi	r10,r10,16
811243f0:	4a400404 	addi	r9,r9,16
811243f4:	1c3fef1e 	bne	r3,r16,811243b4 <__reset+0xfb1043b4>
811243f8:	89c00044 	addi	r7,r17,1
811243fc:	380e913a 	slli	r7,r7,4
81124400:	310003cc 	andi	r4,r6,15
81124404:	02c000c4 	movi	r11,3
81124408:	11c7883a 	add	r3,r2,r7
8112440c:	29cb883a 	add	r5,r5,r7
81124410:	5900212e 	bgeu	r11,r4,81124498 <memcpy+0x148>
81124414:	1813883a 	mov	r9,r3
81124418:	2811883a 	mov	r8,r5
8112441c:	200f883a 	mov	r7,r4
81124420:	42800017 	ldw	r10,0(r8)
81124424:	4a400104 	addi	r9,r9,4
81124428:	39ffff04 	addi	r7,r7,-4
8112442c:	4abfff15 	stw	r10,-4(r9)
81124430:	42000104 	addi	r8,r8,4
81124434:	59fffa36 	bltu	r11,r7,81124420 <__reset+0xfb104420>
81124438:	213fff04 	addi	r4,r4,-4
8112443c:	2008d0ba 	srli	r4,r4,2
81124440:	318000cc 	andi	r6,r6,3
81124444:	21000044 	addi	r4,r4,1
81124448:	2109883a 	add	r4,r4,r4
8112444c:	2109883a 	add	r4,r4,r4
81124450:	1907883a 	add	r3,r3,r4
81124454:	290b883a 	add	r5,r5,r4
81124458:	30000626 	beq	r6,zero,81124474 <memcpy+0x124>
8112445c:	198d883a 	add	r6,r3,r6
81124460:	29c00003 	ldbu	r7,0(r5)
81124464:	18c00044 	addi	r3,r3,1
81124468:	29400044 	addi	r5,r5,1
8112446c:	19ffffc5 	stb	r7,-1(r3)
81124470:	19bffb1e 	bne	r3,r6,81124460 <__reset+0xfb104460>
81124474:	dfc00217 	ldw	ra,8(sp)
81124478:	dc400117 	ldw	r17,4(sp)
8112447c:	dc000017 	ldw	r16,0(sp)
81124480:	dec00304 	addi	sp,sp,12
81124484:	f800283a 	ret
81124488:	2007883a 	mov	r3,r4
8112448c:	003ff206 	br	81124458 <__reset+0xfb104458>
81124490:	2007883a 	mov	r3,r4
81124494:	003ff106 	br	8112445c <__reset+0xfb10445c>
81124498:	200d883a 	mov	r6,r4
8112449c:	003fee06 	br	81124458 <__reset+0xfb104458>

811244a0 <memset>:
811244a0:	20c000cc 	andi	r3,r4,3
811244a4:	2005883a 	mov	r2,r4
811244a8:	18004426 	beq	r3,zero,811245bc <memset+0x11c>
811244ac:	31ffffc4 	addi	r7,r6,-1
811244b0:	30004026 	beq	r6,zero,811245b4 <memset+0x114>
811244b4:	2813883a 	mov	r9,r5
811244b8:	200d883a 	mov	r6,r4
811244bc:	2007883a 	mov	r3,r4
811244c0:	00000406 	br	811244d4 <memset+0x34>
811244c4:	3a3fffc4 	addi	r8,r7,-1
811244c8:	31800044 	addi	r6,r6,1
811244cc:	38003926 	beq	r7,zero,811245b4 <memset+0x114>
811244d0:	400f883a 	mov	r7,r8
811244d4:	18c00044 	addi	r3,r3,1
811244d8:	32400005 	stb	r9,0(r6)
811244dc:	1a0000cc 	andi	r8,r3,3
811244e0:	403ff81e 	bne	r8,zero,811244c4 <__reset+0xfb1044c4>
811244e4:	010000c4 	movi	r4,3
811244e8:	21c02d2e 	bgeu	r4,r7,811245a0 <memset+0x100>
811244ec:	29003fcc 	andi	r4,r5,255
811244f0:	200c923a 	slli	r6,r4,8
811244f4:	3108b03a 	or	r4,r6,r4
811244f8:	200c943a 	slli	r6,r4,16
811244fc:	218cb03a 	or	r6,r4,r6
81124500:	010003c4 	movi	r4,15
81124504:	21c0182e 	bgeu	r4,r7,81124568 <memset+0xc8>
81124508:	3b3ffc04 	addi	r12,r7,-16
8112450c:	6018d13a 	srli	r12,r12,4
81124510:	1a000104 	addi	r8,r3,4
81124514:	1ac00204 	addi	r11,r3,8
81124518:	6008913a 	slli	r4,r12,4
8112451c:	1a800304 	addi	r10,r3,12
81124520:	1813883a 	mov	r9,r3
81124524:	21000504 	addi	r4,r4,20
81124528:	1909883a 	add	r4,r3,r4
8112452c:	49800015 	stw	r6,0(r9)
81124530:	41800015 	stw	r6,0(r8)
81124534:	59800015 	stw	r6,0(r11)
81124538:	51800015 	stw	r6,0(r10)
8112453c:	42000404 	addi	r8,r8,16
81124540:	4a400404 	addi	r9,r9,16
81124544:	5ac00404 	addi	r11,r11,16
81124548:	52800404 	addi	r10,r10,16
8112454c:	413ff71e 	bne	r8,r4,8112452c <__reset+0xfb10452c>
81124550:	63000044 	addi	r12,r12,1
81124554:	6018913a 	slli	r12,r12,4
81124558:	39c003cc 	andi	r7,r7,15
8112455c:	010000c4 	movi	r4,3
81124560:	1b07883a 	add	r3,r3,r12
81124564:	21c00e2e 	bgeu	r4,r7,811245a0 <memset+0x100>
81124568:	1813883a 	mov	r9,r3
8112456c:	3811883a 	mov	r8,r7
81124570:	010000c4 	movi	r4,3
81124574:	49800015 	stw	r6,0(r9)
81124578:	423fff04 	addi	r8,r8,-4
8112457c:	4a400104 	addi	r9,r9,4
81124580:	223ffc36 	bltu	r4,r8,81124574 <__reset+0xfb104574>
81124584:	393fff04 	addi	r4,r7,-4
81124588:	2008d0ba 	srli	r4,r4,2
8112458c:	39c000cc 	andi	r7,r7,3
81124590:	21000044 	addi	r4,r4,1
81124594:	2109883a 	add	r4,r4,r4
81124598:	2109883a 	add	r4,r4,r4
8112459c:	1907883a 	add	r3,r3,r4
811245a0:	38000526 	beq	r7,zero,811245b8 <memset+0x118>
811245a4:	19cf883a 	add	r7,r3,r7
811245a8:	19400005 	stb	r5,0(r3)
811245ac:	18c00044 	addi	r3,r3,1
811245b0:	38fffd1e 	bne	r7,r3,811245a8 <__reset+0xfb1045a8>
811245b4:	f800283a 	ret
811245b8:	f800283a 	ret
811245bc:	2007883a 	mov	r3,r4
811245c0:	300f883a 	mov	r7,r6
811245c4:	003fc706 	br	811244e4 <__reset+0xfb1044e4>

811245c8 <_open_r>:
811245c8:	defffd04 	addi	sp,sp,-12
811245cc:	de00012e 	bgeu	sp,et,811245d4 <_open_r+0xc>
811245d0:	003b68fa 	trap	3
811245d4:	2805883a 	mov	r2,r5
811245d8:	dc000015 	stw	r16,0(sp)
811245dc:	04204574 	movhi	r16,33045
811245e0:	dc400115 	stw	r17,4(sp)
811245e4:	300b883a 	mov	r5,r6
811245e8:	8413d304 	addi	r16,r16,20300
811245ec:	2023883a 	mov	r17,r4
811245f0:	380d883a 	mov	r6,r7
811245f4:	1009883a 	mov	r4,r2
811245f8:	dfc00215 	stw	ra,8(sp)
811245fc:	80000015 	stw	zero,0(r16)
81124600:	11393980 	call	81139398 <open>
81124604:	00ffffc4 	movi	r3,-1
81124608:	10c00526 	beq	r2,r3,81124620 <_open_r+0x58>
8112460c:	dfc00217 	ldw	ra,8(sp)
81124610:	dc400117 	ldw	r17,4(sp)
81124614:	dc000017 	ldw	r16,0(sp)
81124618:	dec00304 	addi	sp,sp,12
8112461c:	f800283a 	ret
81124620:	80c00017 	ldw	r3,0(r16)
81124624:	183ff926 	beq	r3,zero,8112460c <__reset+0xfb10460c>
81124628:	88c00015 	stw	r3,0(r17)
8112462c:	003ff706 	br	8112460c <__reset+0xfb10460c>

81124630 <_putc_r>:
81124630:	defffc04 	addi	sp,sp,-16
81124634:	de00012e 	bgeu	sp,et,8112463c <_putc_r+0xc>
81124638:	003b68fa 	trap	3
8112463c:	dc000215 	stw	r16,8(sp)
81124640:	dfc00315 	stw	ra,12(sp)
81124644:	2021883a 	mov	r16,r4
81124648:	20000226 	beq	r4,zero,81124654 <_putc_r+0x24>
8112464c:	20800e17 	ldw	r2,56(r4)
81124650:	10001b26 	beq	r2,zero,811246c0 <_putc_r+0x90>
81124654:	30800217 	ldw	r2,8(r6)
81124658:	10bfffc4 	addi	r2,r2,-1
8112465c:	30800215 	stw	r2,8(r6)
81124660:	10000a16 	blt	r2,zero,8112468c <_putc_r+0x5c>
81124664:	30800017 	ldw	r2,0(r6)
81124668:	11400005 	stb	r5,0(r2)
8112466c:	30800017 	ldw	r2,0(r6)
81124670:	10c00044 	addi	r3,r2,1
81124674:	30c00015 	stw	r3,0(r6)
81124678:	10800003 	ldbu	r2,0(r2)
8112467c:	dfc00317 	ldw	ra,12(sp)
81124680:	dc000217 	ldw	r16,8(sp)
81124684:	dec00404 	addi	sp,sp,16
81124688:	f800283a 	ret
8112468c:	30c00617 	ldw	r3,24(r6)
81124690:	10c00616 	blt	r2,r3,811246ac <_putc_r+0x7c>
81124694:	30800017 	ldw	r2,0(r6)
81124698:	00c00284 	movi	r3,10
8112469c:	11400005 	stb	r5,0(r2)
811246a0:	30800017 	ldw	r2,0(r6)
811246a4:	11400003 	ldbu	r5,0(r2)
811246a8:	28fff11e 	bne	r5,r3,81124670 <__reset+0xfb104670>
811246ac:	8009883a 	mov	r4,r16
811246b0:	dfc00317 	ldw	ra,12(sp)
811246b4:	dc000217 	ldw	r16,8(sp)
811246b8:	dec00404 	addi	sp,sp,16
811246bc:	112b1681 	jmpi	8112b168 <__swbuf_r>
811246c0:	d9400015 	stw	r5,0(sp)
811246c4:	d9800115 	stw	r6,4(sp)
811246c8:	112d3a00 	call	8112d3a0 <__sinit>
811246cc:	d9800117 	ldw	r6,4(sp)
811246d0:	d9400017 	ldw	r5,0(sp)
811246d4:	003fdf06 	br	81124654 <__reset+0xfb104654>

811246d8 <putc>:
811246d8:	00a04574 	movhi	r2,33045
811246dc:	defffc04 	addi	sp,sp,-16
811246e0:	10936004 	addi	r2,r2,19840
811246e4:	de00012e 	bgeu	sp,et,811246ec <putc+0x14>
811246e8:	003b68fa 	trap	3
811246ec:	dc000115 	stw	r16,4(sp)
811246f0:	14000017 	ldw	r16,0(r2)
811246f4:	dc400215 	stw	r17,8(sp)
811246f8:	dfc00315 	stw	ra,12(sp)
811246fc:	2023883a 	mov	r17,r4
81124700:	80000226 	beq	r16,zero,8112470c <putc+0x34>
81124704:	80800e17 	ldw	r2,56(r16)
81124708:	10001a26 	beq	r2,zero,81124774 <putc+0x9c>
8112470c:	28800217 	ldw	r2,8(r5)
81124710:	10bfffc4 	addi	r2,r2,-1
81124714:	28800215 	stw	r2,8(r5)
81124718:	10000b16 	blt	r2,zero,81124748 <putc+0x70>
8112471c:	28800017 	ldw	r2,0(r5)
81124720:	14400005 	stb	r17,0(r2)
81124724:	28800017 	ldw	r2,0(r5)
81124728:	10c00044 	addi	r3,r2,1
8112472c:	28c00015 	stw	r3,0(r5)
81124730:	10800003 	ldbu	r2,0(r2)
81124734:	dfc00317 	ldw	ra,12(sp)
81124738:	dc400217 	ldw	r17,8(sp)
8112473c:	dc000117 	ldw	r16,4(sp)
81124740:	dec00404 	addi	sp,sp,16
81124744:	f800283a 	ret
81124748:	28c00617 	ldw	r3,24(r5)
8112474c:	10c00e16 	blt	r2,r3,81124788 <putc+0xb0>
81124750:	28800017 	ldw	r2,0(r5)
81124754:	01000284 	movi	r4,10
81124758:	14400005 	stb	r17,0(r2)
8112475c:	28800017 	ldw	r2,0(r5)
81124760:	10c00003 	ldbu	r3,0(r2)
81124764:	193ff01e 	bne	r3,r4,81124728 <__reset+0xfb104728>
81124768:	280d883a 	mov	r6,r5
8112476c:	180b883a 	mov	r5,r3
81124770:	00000706 	br	81124790 <putc+0xb8>
81124774:	8009883a 	mov	r4,r16
81124778:	d9400015 	stw	r5,0(sp)
8112477c:	112d3a00 	call	8112d3a0 <__sinit>
81124780:	d9400017 	ldw	r5,0(sp)
81124784:	003fe106 	br	8112470c <__reset+0xfb10470c>
81124788:	280d883a 	mov	r6,r5
8112478c:	880b883a 	mov	r5,r17
81124790:	8009883a 	mov	r4,r16
81124794:	dfc00317 	ldw	ra,12(sp)
81124798:	dc400217 	ldw	r17,8(sp)
8112479c:	dc000117 	ldw	r16,4(sp)
811247a0:	dec00404 	addi	sp,sp,16
811247a4:	112b1681 	jmpi	8112b168 <__swbuf_r>

811247a8 <_puts_r>:
811247a8:	defff604 	addi	sp,sp,-40
811247ac:	de00012e 	bgeu	sp,et,811247b4 <_puts_r+0xc>
811247b0:	003b68fa 	trap	3
811247b4:	dc000715 	stw	r16,28(sp)
811247b8:	2021883a 	mov	r16,r4
811247bc:	2809883a 	mov	r4,r5
811247c0:	dc400815 	stw	r17,32(sp)
811247c4:	dfc00915 	stw	ra,36(sp)
811247c8:	2823883a 	mov	r17,r5
811247cc:	1124dc80 	call	81124dc8 <strlen>
811247d0:	10c00044 	addi	r3,r2,1
811247d4:	d8800115 	stw	r2,4(sp)
811247d8:	00a04574 	movhi	r2,33045
811247dc:	10898704 	addi	r2,r2,9756
811247e0:	d8800215 	stw	r2,8(sp)
811247e4:	00800044 	movi	r2,1
811247e8:	d8800315 	stw	r2,12(sp)
811247ec:	00800084 	movi	r2,2
811247f0:	dc400015 	stw	r17,0(sp)
811247f4:	d8c00615 	stw	r3,24(sp)
811247f8:	dec00415 	stw	sp,16(sp)
811247fc:	d8800515 	stw	r2,20(sp)
81124800:	80000226 	beq	r16,zero,8112480c <_puts_r+0x64>
81124804:	80800e17 	ldw	r2,56(r16)
81124808:	10001426 	beq	r2,zero,8112485c <_puts_r+0xb4>
8112480c:	81400217 	ldw	r5,8(r16)
81124810:	2880030b 	ldhu	r2,12(r5)
81124814:	10c8000c 	andi	r3,r2,8192
81124818:	1800061e 	bne	r3,zero,81124834 <_puts_r+0x8c>
8112481c:	29001917 	ldw	r4,100(r5)
81124820:	00f7ffc4 	movi	r3,-8193
81124824:	10880014 	ori	r2,r2,8192
81124828:	20c6703a 	and	r3,r4,r3
8112482c:	2880030d 	sth	r2,12(r5)
81124830:	28c01915 	stw	r3,100(r5)
81124834:	d9800404 	addi	r6,sp,16
81124838:	8009883a 	mov	r4,r16
8112483c:	112db500 	call	8112db50 <__sfvwrite_r>
81124840:	1000091e 	bne	r2,zero,81124868 <_puts_r+0xc0>
81124844:	00800284 	movi	r2,10
81124848:	dfc00917 	ldw	ra,36(sp)
8112484c:	dc400817 	ldw	r17,32(sp)
81124850:	dc000717 	ldw	r16,28(sp)
81124854:	dec00a04 	addi	sp,sp,40
81124858:	f800283a 	ret
8112485c:	8009883a 	mov	r4,r16
81124860:	112d3a00 	call	8112d3a0 <__sinit>
81124864:	003fe906 	br	8112480c <__reset+0xfb10480c>
81124868:	00bfffc4 	movi	r2,-1
8112486c:	003ff606 	br	81124848 <__reset+0xfb104848>

81124870 <puts>:
81124870:	00a04574 	movhi	r2,33045
81124874:	10936004 	addi	r2,r2,19840
81124878:	200b883a 	mov	r5,r4
8112487c:	11000017 	ldw	r4,0(r2)
81124880:	11247a81 	jmpi	811247a8 <_puts_r>

81124884 <lflush>:
81124884:	2080030b 	ldhu	r2,12(r4)
81124888:	00c00244 	movi	r3,9
8112488c:	1080024c 	andi	r2,r2,9
81124890:	10c00226 	beq	r2,r3,8112489c <lflush+0x18>
81124894:	0005883a 	mov	r2,zero
81124898:	f800283a 	ret
8112489c:	112d0081 	jmpi	8112d008 <fflush>

811248a0 <__srefill_r>:
811248a0:	defffc04 	addi	sp,sp,-16
811248a4:	de00012e 	bgeu	sp,et,811248ac <__srefill_r+0xc>
811248a8:	003b68fa 	trap	3
811248ac:	dc400115 	stw	r17,4(sp)
811248b0:	dc000015 	stw	r16,0(sp)
811248b4:	dfc00315 	stw	ra,12(sp)
811248b8:	dc800215 	stw	r18,8(sp)
811248bc:	2023883a 	mov	r17,r4
811248c0:	2821883a 	mov	r16,r5
811248c4:	20000226 	beq	r4,zero,811248d0 <__srefill_r+0x30>
811248c8:	20800e17 	ldw	r2,56(r4)
811248cc:	10003c26 	beq	r2,zero,811249c0 <__srefill_r+0x120>
811248d0:	80c0030b 	ldhu	r3,12(r16)
811248d4:	1908000c 	andi	r4,r3,8192
811248d8:	1805883a 	mov	r2,r3
811248dc:	2000071e 	bne	r4,zero,811248fc <__srefill_r+0x5c>
811248e0:	81001917 	ldw	r4,100(r16)
811248e4:	18880014 	ori	r2,r3,8192
811248e8:	00f7ffc4 	movi	r3,-8193
811248ec:	20c8703a 	and	r4,r4,r3
811248f0:	8080030d 	sth	r2,12(r16)
811248f4:	1007883a 	mov	r3,r2
811248f8:	81001915 	stw	r4,100(r16)
811248fc:	80000115 	stw	zero,4(r16)
81124900:	1100080c 	andi	r4,r2,32
81124904:	2000571e 	bne	r4,zero,81124a64 <__srefill_r+0x1c4>
81124908:	1100010c 	andi	r4,r2,4
8112490c:	20001f26 	beq	r4,zero,8112498c <__srefill_r+0xec>
81124910:	81400c17 	ldw	r5,48(r16)
81124914:	28000826 	beq	r5,zero,81124938 <__srefill_r+0x98>
81124918:	80801004 	addi	r2,r16,64
8112491c:	28800226 	beq	r5,r2,81124928 <__srefill_r+0x88>
81124920:	8809883a 	mov	r4,r17
81124924:	112d8380 	call	8112d838 <_free_r>
81124928:	80800f17 	ldw	r2,60(r16)
8112492c:	80000c15 	stw	zero,48(r16)
81124930:	80800115 	stw	r2,4(r16)
81124934:	1000391e 	bne	r2,zero,81124a1c <__srefill_r+0x17c>
81124938:	80800417 	ldw	r2,16(r16)
8112493c:	10004b26 	beq	r2,zero,81124a6c <__srefill_r+0x1cc>
81124940:	8480030b 	ldhu	r18,12(r16)
81124944:	908000cc 	andi	r2,r18,3
81124948:	10001f1e 	bne	r2,zero,811249c8 <__srefill_r+0x128>
8112494c:	81800417 	ldw	r6,16(r16)
81124950:	80800817 	ldw	r2,32(r16)
81124954:	81c00517 	ldw	r7,20(r16)
81124958:	81400717 	ldw	r5,28(r16)
8112495c:	81800015 	stw	r6,0(r16)
81124960:	8809883a 	mov	r4,r17
81124964:	103ee83a 	callr	r2
81124968:	80800115 	stw	r2,4(r16)
8112496c:	00800e0e 	bge	zero,r2,811249a8 <__srefill_r+0x108>
81124970:	0005883a 	mov	r2,zero
81124974:	dfc00317 	ldw	ra,12(sp)
81124978:	dc800217 	ldw	r18,8(sp)
8112497c:	dc400117 	ldw	r17,4(sp)
81124980:	dc000017 	ldw	r16,0(sp)
81124984:	dec00404 	addi	sp,sp,16
81124988:	f800283a 	ret
8112498c:	1100040c 	andi	r4,r2,16
81124990:	20003026 	beq	r4,zero,81124a54 <__srefill_r+0x1b4>
81124994:	1080020c 	andi	r2,r2,8
81124998:	1000241e 	bne	r2,zero,81124a2c <__srefill_r+0x18c>
8112499c:	18c00114 	ori	r3,r3,4
811249a0:	80c0030d 	sth	r3,12(r16)
811249a4:	003fe406 	br	81124938 <__reset+0xfb104938>
811249a8:	80c0030b 	ldhu	r3,12(r16)
811249ac:	1000161e 	bne	r2,zero,81124a08 <__srefill_r+0x168>
811249b0:	18c00814 	ori	r3,r3,32
811249b4:	00bfffc4 	movi	r2,-1
811249b8:	80c0030d 	sth	r3,12(r16)
811249bc:	003fed06 	br	81124974 <__reset+0xfb104974>
811249c0:	112d3a00 	call	8112d3a0 <__sinit>
811249c4:	003fc206 	br	811248d0 <__reset+0xfb1048d0>
811249c8:	00a04574 	movhi	r2,33045
811249cc:	10935f04 	addi	r2,r2,19836
811249d0:	11000017 	ldw	r4,0(r2)
811249d4:	016044b4 	movhi	r5,33042
811249d8:	00800044 	movi	r2,1
811249dc:	29522104 	addi	r5,r5,18564
811249e0:	8080030d 	sth	r2,12(r16)
811249e4:	112e0140 	call	8112e014 <_fwalk>
811249e8:	00800244 	movi	r2,9
811249ec:	8480030d 	sth	r18,12(r16)
811249f0:	9480024c 	andi	r18,r18,9
811249f4:	90bfd51e 	bne	r18,r2,8112494c <__reset+0xfb10494c>
811249f8:	800b883a 	mov	r5,r16
811249fc:	8809883a 	mov	r4,r17
81124a00:	112cd800 	call	8112cd80 <__sflush_r>
81124a04:	003fd106 	br	8112494c <__reset+0xfb10494c>
81124a08:	18c01014 	ori	r3,r3,64
81124a0c:	80000115 	stw	zero,4(r16)
81124a10:	00bfffc4 	movi	r2,-1
81124a14:	80c0030d 	sth	r3,12(r16)
81124a18:	003fd606 	br	81124974 <__reset+0xfb104974>
81124a1c:	80c00e17 	ldw	r3,56(r16)
81124a20:	0005883a 	mov	r2,zero
81124a24:	80c00015 	stw	r3,0(r16)
81124a28:	003fd206 	br	81124974 <__reset+0xfb104974>
81124a2c:	800b883a 	mov	r5,r16
81124a30:	8809883a 	mov	r4,r17
81124a34:	112cfa40 	call	8112cfa4 <_fflush_r>
81124a38:	10000a1e 	bne	r2,zero,81124a64 <__srefill_r+0x1c4>
81124a3c:	8080030b 	ldhu	r2,12(r16)
81124a40:	00fffdc4 	movi	r3,-9
81124a44:	80000215 	stw	zero,8(r16)
81124a48:	1886703a 	and	r3,r3,r2
81124a4c:	80000615 	stw	zero,24(r16)
81124a50:	003fd206 	br	8112499c <__reset+0xfb10499c>
81124a54:	00800244 	movi	r2,9
81124a58:	88800015 	stw	r2,0(r17)
81124a5c:	18c01014 	ori	r3,r3,64
81124a60:	80c0030d 	sth	r3,12(r16)
81124a64:	00bfffc4 	movi	r2,-1
81124a68:	003fc206 	br	81124974 <__reset+0xfb104974>
81124a6c:	800b883a 	mov	r5,r16
81124a70:	8809883a 	mov	r4,r17
81124a74:	11239780 	call	81123978 <__smakebuf_r>
81124a78:	003fb106 	br	81124940 <__reset+0xfb104940>

81124a7c <_sbrk_r>:
81124a7c:	defffd04 	addi	sp,sp,-12
81124a80:	de00012e 	bgeu	sp,et,81124a88 <_sbrk_r+0xc>
81124a84:	003b68fa 	trap	3
81124a88:	dc000015 	stw	r16,0(sp)
81124a8c:	04204574 	movhi	r16,33045
81124a90:	dc400115 	stw	r17,4(sp)
81124a94:	8413d304 	addi	r16,r16,20300
81124a98:	2023883a 	mov	r17,r4
81124a9c:	2809883a 	mov	r4,r5
81124aa0:	dfc00215 	stw	ra,8(sp)
81124aa4:	80000015 	stw	zero,0(r16)
81124aa8:	11396a80 	call	811396a8 <sbrk>
81124aac:	00ffffc4 	movi	r3,-1
81124ab0:	10c00526 	beq	r2,r3,81124ac8 <_sbrk_r+0x4c>
81124ab4:	dfc00217 	ldw	ra,8(sp)
81124ab8:	dc400117 	ldw	r17,4(sp)
81124abc:	dc000017 	ldw	r16,0(sp)
81124ac0:	dec00304 	addi	sp,sp,12
81124ac4:	f800283a 	ret
81124ac8:	80c00017 	ldw	r3,0(r16)
81124acc:	183ff926 	beq	r3,zero,81124ab4 <__reset+0xfb104ab4>
81124ad0:	88c00015 	stw	r3,0(r17)
81124ad4:	003ff706 	br	81124ab4 <__reset+0xfb104ab4>

81124ad8 <scanf>:
81124ad8:	defffc04 	addi	sp,sp,-16
81124adc:	de00012e 	bgeu	sp,et,81124ae4 <scanf+0xc>
81124ae0:	003b68fa 	trap	3
81124ae4:	dfc00015 	stw	ra,0(sp)
81124ae8:	d9400115 	stw	r5,4(sp)
81124aec:	d9800215 	stw	r6,8(sp)
81124af0:	d9c00315 	stw	r7,12(sp)
81124af4:	00a04574 	movhi	r2,33045
81124af8:	10936004 	addi	r2,r2,19840
81124afc:	200d883a 	mov	r6,r4
81124b00:	11000017 	ldw	r4,0(r2)
81124b04:	d9c00104 	addi	r7,sp,4
81124b08:	21400117 	ldw	r5,4(r4)
81124b0c:	112b1140 	call	8112b114 <_vfscanf_r>
81124b10:	dfc00017 	ldw	ra,0(sp)
81124b14:	dec00404 	addi	sp,sp,16
81124b18:	f800283a 	ret

81124b1c <_scanf_r>:
81124b1c:	defffd04 	addi	sp,sp,-12
81124b20:	2805883a 	mov	r2,r5
81124b24:	de00012e 	bgeu	sp,et,81124b2c <_scanf_r+0x10>
81124b28:	003b68fa 	trap	3
81124b2c:	dfc00015 	stw	ra,0(sp)
81124b30:	d9800115 	stw	r6,4(sp)
81124b34:	d9c00215 	stw	r7,8(sp)
81124b38:	21400117 	ldw	r5,4(r4)
81124b3c:	d9c00104 	addi	r7,sp,4
81124b40:	100d883a 	mov	r6,r2
81124b44:	112b1140 	call	8112b114 <_vfscanf_r>
81124b48:	dfc00017 	ldw	ra,0(sp)
81124b4c:	dec00304 	addi	sp,sp,12
81124b50:	f800283a 	ret

81124b54 <_sprintf_r>:
81124b54:	deffe404 	addi	sp,sp,-112
81124b58:	2807883a 	mov	r3,r5
81124b5c:	de00012e 	bgeu	sp,et,81124b64 <_sprintf_r+0x10>
81124b60:	003b68fa 	trap	3
81124b64:	dfc01a15 	stw	ra,104(sp)
81124b68:	d9c01b15 	stw	r7,108(sp)
81124b6c:	00a00034 	movhi	r2,32768
81124b70:	10bfffc4 	addi	r2,r2,-1
81124b74:	02008204 	movi	r8,520
81124b78:	d8800215 	stw	r2,8(sp)
81124b7c:	d8800515 	stw	r2,20(sp)
81124b80:	d9c01b04 	addi	r7,sp,108
81124b84:	d80b883a 	mov	r5,sp
81124b88:	00bfffc4 	movi	r2,-1
81124b8c:	d8c00015 	stw	r3,0(sp)
81124b90:	d8c00415 	stw	r3,16(sp)
81124b94:	da00030d 	sth	r8,12(sp)
81124b98:	d880038d 	sth	r2,14(sp)
81124b9c:	11254040 	call	81125404 <___svfprintf_internal_r>
81124ba0:	d8c00017 	ldw	r3,0(sp)
81124ba4:	18000005 	stb	zero,0(r3)
81124ba8:	dfc01a17 	ldw	ra,104(sp)
81124bac:	dec01c04 	addi	sp,sp,112
81124bb0:	f800283a 	ret

81124bb4 <sprintf>:
81124bb4:	deffe304 	addi	sp,sp,-116
81124bb8:	2007883a 	mov	r3,r4
81124bbc:	de00012e 	bgeu	sp,et,81124bc4 <sprintf+0x10>
81124bc0:	003b68fa 	trap	3
81124bc4:	dfc01a15 	stw	ra,104(sp)
81124bc8:	d9801b15 	stw	r6,108(sp)
81124bcc:	d9c01c15 	stw	r7,112(sp)
81124bd0:	01204574 	movhi	r4,33045
81124bd4:	21136004 	addi	r4,r4,19840
81124bd8:	21000017 	ldw	r4,0(r4)
81124bdc:	00a00034 	movhi	r2,32768
81124be0:	10bfffc4 	addi	r2,r2,-1
81124be4:	280d883a 	mov	r6,r5
81124be8:	02008204 	movi	r8,520
81124bec:	d8800215 	stw	r2,8(sp)
81124bf0:	d8800515 	stw	r2,20(sp)
81124bf4:	d9c01b04 	addi	r7,sp,108
81124bf8:	d80b883a 	mov	r5,sp
81124bfc:	00bfffc4 	movi	r2,-1
81124c00:	d8c00015 	stw	r3,0(sp)
81124c04:	d8c00415 	stw	r3,16(sp)
81124c08:	da00030d 	sth	r8,12(sp)
81124c0c:	d880038d 	sth	r2,14(sp)
81124c10:	11254040 	call	81125404 <___svfprintf_internal_r>
81124c14:	d8c00017 	ldw	r3,0(sp)
81124c18:	18000005 	stb	zero,0(r3)
81124c1c:	dfc01a17 	ldw	ra,104(sp)
81124c20:	dec01d04 	addi	sp,sp,116
81124c24:	f800283a 	ret

81124c28 <__sread>:
81124c28:	defffe04 	addi	sp,sp,-8
81124c2c:	de00012e 	bgeu	sp,et,81124c34 <__sread+0xc>
81124c30:	003b68fa 	trap	3
81124c34:	dc000015 	stw	r16,0(sp)
81124c38:	2821883a 	mov	r16,r5
81124c3c:	2940038f 	ldh	r5,14(r5)
81124c40:	dfc00115 	stw	ra,4(sp)
81124c44:	112f8640 	call	8112f864 <_read_r>
81124c48:	10000716 	blt	r2,zero,81124c68 <__sread+0x40>
81124c4c:	80c01417 	ldw	r3,80(r16)
81124c50:	1887883a 	add	r3,r3,r2
81124c54:	80c01415 	stw	r3,80(r16)
81124c58:	dfc00117 	ldw	ra,4(sp)
81124c5c:	dc000017 	ldw	r16,0(sp)
81124c60:	dec00204 	addi	sp,sp,8
81124c64:	f800283a 	ret
81124c68:	80c0030b 	ldhu	r3,12(r16)
81124c6c:	18fbffcc 	andi	r3,r3,61439
81124c70:	80c0030d 	sth	r3,12(r16)
81124c74:	dfc00117 	ldw	ra,4(sp)
81124c78:	dc000017 	ldw	r16,0(sp)
81124c7c:	dec00204 	addi	sp,sp,8
81124c80:	f800283a 	ret

81124c84 <__seofread>:
81124c84:	0005883a 	mov	r2,zero
81124c88:	f800283a 	ret

81124c8c <__swrite>:
81124c8c:	defffb04 	addi	sp,sp,-20
81124c90:	de00012e 	bgeu	sp,et,81124c98 <__swrite+0xc>
81124c94:	003b68fa 	trap	3
81124c98:	2880030b 	ldhu	r2,12(r5)
81124c9c:	dcc00315 	stw	r19,12(sp)
81124ca0:	dc800215 	stw	r18,8(sp)
81124ca4:	dc400115 	stw	r17,4(sp)
81124ca8:	dc000015 	stw	r16,0(sp)
81124cac:	dfc00415 	stw	ra,16(sp)
81124cb0:	10c0400c 	andi	r3,r2,256
81124cb4:	2821883a 	mov	r16,r5
81124cb8:	2023883a 	mov	r17,r4
81124cbc:	3025883a 	mov	r18,r6
81124cc0:	3827883a 	mov	r19,r7
81124cc4:	18000526 	beq	r3,zero,81124cdc <__swrite+0x50>
81124cc8:	2940038f 	ldh	r5,14(r5)
81124ccc:	01c00084 	movi	r7,2
81124cd0:	000d883a 	mov	r6,zero
81124cd4:	112e31c0 	call	8112e31c <_lseek_r>
81124cd8:	8080030b 	ldhu	r2,12(r16)
81124cdc:	8140038f 	ldh	r5,14(r16)
81124ce0:	10bbffcc 	andi	r2,r2,61439
81124ce4:	980f883a 	mov	r7,r19
81124ce8:	900d883a 	mov	r6,r18
81124cec:	8809883a 	mov	r4,r17
81124cf0:	8080030d 	sth	r2,12(r16)
81124cf4:	dfc00417 	ldw	ra,16(sp)
81124cf8:	dcc00317 	ldw	r19,12(sp)
81124cfc:	dc800217 	ldw	r18,8(sp)
81124d00:	dc400117 	ldw	r17,4(sp)
81124d04:	dc000017 	ldw	r16,0(sp)
81124d08:	dec00504 	addi	sp,sp,20
81124d0c:	112b2c81 	jmpi	8112b2c8 <_write_r>

81124d10 <__sseek>:
81124d10:	defffe04 	addi	sp,sp,-8
81124d14:	de00012e 	bgeu	sp,et,81124d1c <__sseek+0xc>
81124d18:	003b68fa 	trap	3
81124d1c:	dc000015 	stw	r16,0(sp)
81124d20:	2821883a 	mov	r16,r5
81124d24:	2940038f 	ldh	r5,14(r5)
81124d28:	dfc00115 	stw	ra,4(sp)
81124d2c:	112e31c0 	call	8112e31c <_lseek_r>
81124d30:	00ffffc4 	movi	r3,-1
81124d34:	10c00826 	beq	r2,r3,81124d58 <__sseek+0x48>
81124d38:	80c0030b 	ldhu	r3,12(r16)
81124d3c:	80801415 	stw	r2,80(r16)
81124d40:	18c40014 	ori	r3,r3,4096
81124d44:	80c0030d 	sth	r3,12(r16)
81124d48:	dfc00117 	ldw	ra,4(sp)
81124d4c:	dc000017 	ldw	r16,0(sp)
81124d50:	dec00204 	addi	sp,sp,8
81124d54:	f800283a 	ret
81124d58:	80c0030b 	ldhu	r3,12(r16)
81124d5c:	18fbffcc 	andi	r3,r3,61439
81124d60:	80c0030d 	sth	r3,12(r16)
81124d64:	dfc00117 	ldw	ra,4(sp)
81124d68:	dc000017 	ldw	r16,0(sp)
81124d6c:	dec00204 	addi	sp,sp,8
81124d70:	f800283a 	ret

81124d74 <__sclose>:
81124d74:	2940038f 	ldh	r5,14(r5)
81124d78:	112b48c1 	jmpi	8112b48c <_close_r>

81124d7c <strcspn>:
81124d7c:	21c00007 	ldb	r7,0(r4)
81124d80:	38000f26 	beq	r7,zero,81124dc0 <strcspn+0x44>
81124d84:	2a000007 	ldb	r8,0(r5)
81124d88:	2005883a 	mov	r2,r4
81124d8c:	40000726 	beq	r8,zero,81124dac <strcspn+0x30>
81124d90:	3a000926 	beq	r7,r8,81124db8 <strcspn+0x3c>
81124d94:	2807883a 	mov	r3,r5
81124d98:	00000106 	br	81124da0 <strcspn+0x24>
81124d9c:	31c00626 	beq	r6,r7,81124db8 <strcspn+0x3c>
81124da0:	18c00044 	addi	r3,r3,1
81124da4:	19800007 	ldb	r6,0(r3)
81124da8:	303ffc1e 	bne	r6,zero,81124d9c <__reset+0xfb104d9c>
81124dac:	10800044 	addi	r2,r2,1
81124db0:	11c00007 	ldb	r7,0(r2)
81124db4:	383ff51e 	bne	r7,zero,81124d8c <__reset+0xfb104d8c>
81124db8:	1105c83a 	sub	r2,r2,r4
81124dbc:	f800283a 	ret
81124dc0:	0005883a 	mov	r2,zero
81124dc4:	f800283a 	ret

81124dc8 <strlen>:
81124dc8:	208000cc 	andi	r2,r4,3
81124dcc:	10002026 	beq	r2,zero,81124e50 <strlen+0x88>
81124dd0:	20800007 	ldb	r2,0(r4)
81124dd4:	10002026 	beq	r2,zero,81124e58 <strlen+0x90>
81124dd8:	2005883a 	mov	r2,r4
81124ddc:	00000206 	br	81124de8 <strlen+0x20>
81124de0:	10c00007 	ldb	r3,0(r2)
81124de4:	18001826 	beq	r3,zero,81124e48 <strlen+0x80>
81124de8:	10800044 	addi	r2,r2,1
81124dec:	10c000cc 	andi	r3,r2,3
81124df0:	183ffb1e 	bne	r3,zero,81124de0 <__reset+0xfb104de0>
81124df4:	10c00017 	ldw	r3,0(r2)
81124df8:	01ffbff4 	movhi	r7,65279
81124dfc:	39ffbfc4 	addi	r7,r7,-257
81124e00:	00ca303a 	nor	r5,zero,r3
81124e04:	01a02074 	movhi	r6,32897
81124e08:	19c7883a 	add	r3,r3,r7
81124e0c:	31a02004 	addi	r6,r6,-32640
81124e10:	1946703a 	and	r3,r3,r5
81124e14:	1986703a 	and	r3,r3,r6
81124e18:	1800091e 	bne	r3,zero,81124e40 <strlen+0x78>
81124e1c:	10800104 	addi	r2,r2,4
81124e20:	10c00017 	ldw	r3,0(r2)
81124e24:	19cb883a 	add	r5,r3,r7
81124e28:	00c6303a 	nor	r3,zero,r3
81124e2c:	28c6703a 	and	r3,r5,r3
81124e30:	1986703a 	and	r3,r3,r6
81124e34:	183ff926 	beq	r3,zero,81124e1c <__reset+0xfb104e1c>
81124e38:	00000106 	br	81124e40 <strlen+0x78>
81124e3c:	10800044 	addi	r2,r2,1
81124e40:	10c00007 	ldb	r3,0(r2)
81124e44:	183ffd1e 	bne	r3,zero,81124e3c <__reset+0xfb104e3c>
81124e48:	1105c83a 	sub	r2,r2,r4
81124e4c:	f800283a 	ret
81124e50:	2005883a 	mov	r2,r4
81124e54:	003fe706 	br	81124df4 <__reset+0xfb104df4>
81124e58:	0005883a 	mov	r2,zero
81124e5c:	f800283a 	ret

81124e60 <strnlen>:
81124e60:	28000e26 	beq	r5,zero,81124e9c <strnlen+0x3c>
81124e64:	20800007 	ldb	r2,0(r4)
81124e68:	10000c26 	beq	r2,zero,81124e9c <strnlen+0x3c>
81124e6c:	20c00044 	addi	r3,r4,1
81124e70:	214b883a 	add	r5,r4,r5
81124e74:	28c00526 	beq	r5,r3,81124e8c <strnlen+0x2c>
81124e78:	19800007 	ldb	r6,0(r3)
81124e7c:	19c00044 	addi	r7,r3,1
81124e80:	30000426 	beq	r6,zero,81124e94 <strnlen+0x34>
81124e84:	3807883a 	mov	r3,r7
81124e88:	28fffb1e 	bne	r5,r3,81124e78 <__reset+0xfb104e78>
81124e8c:	2905c83a 	sub	r2,r5,r4
81124e90:	f800283a 	ret
81124e94:	1905c83a 	sub	r2,r3,r4
81124e98:	f800283a 	ret
81124e9c:	0005883a 	mov	r2,zero
81124ea0:	f800283a 	ret

81124ea4 <_strtol_r>:
81124ea4:	00a04574 	movhi	r2,33045
81124ea8:	defff404 	addi	sp,sp,-48
81124eac:	10935e04 	addi	r2,r2,19832
81124eb0:	de00012e 	bgeu	sp,et,81124eb8 <_strtol_r+0x14>
81124eb4:	003b68fa 	trap	3
81124eb8:	dd400715 	stw	r21,28(sp)
81124ebc:	15400017 	ldw	r21,0(r2)
81124ec0:	dd800815 	stw	r22,32(sp)
81124ec4:	dd000615 	stw	r20,24(sp)
81124ec8:	dcc00515 	stw	r19,20(sp)
81124ecc:	d9000015 	stw	r4,0(sp)
81124ed0:	dfc00b15 	stw	ra,44(sp)
81124ed4:	df000a15 	stw	fp,40(sp)
81124ed8:	ddc00915 	stw	r23,36(sp)
81124edc:	dc800415 	stw	r18,16(sp)
81124ee0:	dc400315 	stw	r17,12(sp)
81124ee4:	dc000215 	stw	r16,8(sp)
81124ee8:	2829883a 	mov	r20,r5
81124eec:	3027883a 	mov	r19,r6
81124ef0:	382d883a 	mov	r22,r7
81124ef4:	2809883a 	mov	r4,r5
81124ef8:	24000003 	ldbu	r16,0(r4)
81124efc:	24400044 	addi	r17,r4,1
81124f00:	2007883a 	mov	r3,r4
81124f04:	ac05883a 	add	r2,r21,r16
81124f08:	10800043 	ldbu	r2,1(r2)
81124f0c:	8809883a 	mov	r4,r17
81124f10:	1080020c 	andi	r2,r2,8
81124f14:	103ff81e 	bne	r2,zero,81124ef8 <__reset+0xfb104ef8>
81124f18:	00800b44 	movi	r2,45
81124f1c:	80805826 	beq	r16,r2,81125080 <_strtol_r+0x1dc>
81124f20:	00800ac4 	movi	r2,43
81124f24:	80805a26 	beq	r16,r2,81125090 <_strtol_r+0x1ec>
81124f28:	0039883a 	mov	fp,zero
81124f2c:	b0004426 	beq	r22,zero,81125040 <_strtol_r+0x19c>
81124f30:	00800404 	movi	r2,16
81124f34:	b0806026 	beq	r22,r2,811250b8 <_strtol_r+0x214>
81124f38:	b02f883a 	mov	r23,r22
81124f3c:	00a00034 	movhi	r2,32768
81124f40:	e025003a 	cmpeq	r18,fp,zero
81124f44:	14a5c83a 	sub	r18,r2,r18
81124f48:	b80b883a 	mov	r5,r23
81124f4c:	9009883a 	mov	r4,r18
81124f50:	11368c00 	call	811368c0 <__umodsi3>
81124f54:	b80b883a 	mov	r5,r23
81124f58:	9009883a 	mov	r4,r18
81124f5c:	d8800115 	stw	r2,4(sp)
81124f60:	113685c0 	call	8113685c <__udivsi3>
81124f64:	ac07883a 	add	r3,r21,r16
81124f68:	18c00043 	ldbu	r3,1(r3)
81124f6c:	880b883a 	mov	r5,r17
81124f70:	000d883a 	mov	r6,zero
81124f74:	1a00010c 	andi	r8,r3,4
81124f78:	0009883a 	mov	r4,zero
81124f7c:	02800044 	movi	r10,1
81124f80:	027fffc4 	movi	r9,-1
81124f84:	d9c00117 	ldw	r7,4(sp)
81124f88:	40000e26 	beq	r8,zero,81124fc4 <_strtol_r+0x120>
81124f8c:	843ff404 	addi	r16,r16,-48
81124f90:	8580120e 	bge	r16,r22,81124fdc <_strtol_r+0x138>
81124f94:	32400526 	beq	r6,r9,81124fac <_strtol_r+0x108>
81124f98:	11002536 	bltu	r2,r4,81125030 <_strtol_r+0x18c>
81124f9c:	20802326 	beq	r4,r2,8112502c <_strtol_r+0x188>
81124fa0:	25c9383a 	mul	r4,r4,r23
81124fa4:	01800044 	movi	r6,1
81124fa8:	8109883a 	add	r4,r16,r4
81124fac:	2c000003 	ldbu	r16,0(r5)
81124fb0:	29400044 	addi	r5,r5,1
81124fb4:	ac07883a 	add	r3,r21,r16
81124fb8:	18c00043 	ldbu	r3,1(r3)
81124fbc:	1a00010c 	andi	r8,r3,4
81124fc0:	403ff21e 	bne	r8,zero,81124f8c <__reset+0xfb104f8c>
81124fc4:	18c000cc 	andi	r3,r3,3
81124fc8:	18000426 	beq	r3,zero,81124fdc <_strtol_r+0x138>
81124fcc:	1a801a26 	beq	r3,r10,81125038 <_strtol_r+0x194>
81124fd0:	00c015c4 	movi	r3,87
81124fd4:	80e1c83a 	sub	r16,r16,r3
81124fd8:	85bfee16 	blt	r16,r22,81124f94 <__reset+0xfb104f94>
81124fdc:	00bfffc4 	movi	r2,-1
81124fe0:	30801e26 	beq	r6,r2,8112505c <_strtol_r+0x1b8>
81124fe4:	e0001b1e 	bne	fp,zero,81125054 <_strtol_r+0x1b0>
81124fe8:	2005883a 	mov	r2,r4
81124fec:	98000326 	beq	r19,zero,81124ffc <_strtol_r+0x158>
81124ff0:	3000211e 	bne	r6,zero,81125078 <_strtol_r+0x1d4>
81124ff4:	a00b883a 	mov	r5,r20
81124ff8:	99400015 	stw	r5,0(r19)
81124ffc:	dfc00b17 	ldw	ra,44(sp)
81125000:	df000a17 	ldw	fp,40(sp)
81125004:	ddc00917 	ldw	r23,36(sp)
81125008:	dd800817 	ldw	r22,32(sp)
8112500c:	dd400717 	ldw	r21,28(sp)
81125010:	dd000617 	ldw	r20,24(sp)
81125014:	dcc00517 	ldw	r19,20(sp)
81125018:	dc800417 	ldw	r18,16(sp)
8112501c:	dc400317 	ldw	r17,12(sp)
81125020:	dc000217 	ldw	r16,8(sp)
81125024:	dec00c04 	addi	sp,sp,48
81125028:	f800283a 	ret
8112502c:	3c3fdc0e 	bge	r7,r16,81124fa0 <__reset+0xfb104fa0>
81125030:	01bfffc4 	movi	r6,-1
81125034:	003fdd06 	br	81124fac <__reset+0xfb104fac>
81125038:	00c00dc4 	movi	r3,55
8112503c:	003fe506 	br	81124fd4 <__reset+0xfb104fd4>
81125040:	00800c04 	movi	r2,48
81125044:	80801626 	beq	r16,r2,811250a0 <_strtol_r+0x1fc>
81125048:	05800284 	movi	r22,10
8112504c:	b02f883a 	mov	r23,r22
81125050:	003fba06 	br	81124f3c <__reset+0xfb104f3c>
81125054:	0109c83a 	sub	r4,zero,r4
81125058:	003fe306 	br	81124fe8 <__reset+0xfb104fe8>
8112505c:	d9000017 	ldw	r4,0(sp)
81125060:	00c00884 	movi	r3,34
81125064:	e005003a 	cmpeq	r2,fp,zero
81125068:	20c00015 	stw	r3,0(r4)
8112506c:	00e00034 	movhi	r3,32768
81125070:	1885c83a 	sub	r2,r3,r2
81125074:	983fe126 	beq	r19,zero,81124ffc <__reset+0xfb104ffc>
81125078:	297fffc4 	addi	r5,r5,-1
8112507c:	003fde06 	br	81124ff8 <__reset+0xfb104ff8>
81125080:	1c400084 	addi	r17,r3,2
81125084:	1c000043 	ldbu	r16,1(r3)
81125088:	07000044 	movi	fp,1
8112508c:	003fa706 	br	81124f2c <__reset+0xfb104f2c>
81125090:	1c400084 	addi	r17,r3,2
81125094:	1c000043 	ldbu	r16,1(r3)
81125098:	0039883a 	mov	fp,zero
8112509c:	003fa306 	br	81124f2c <__reset+0xfb104f2c>
811250a0:	88800003 	ldbu	r2,0(r17)
811250a4:	00c01604 	movi	r3,88
811250a8:	108037cc 	andi	r2,r2,223
811250ac:	10c00826 	beq	r2,r3,811250d0 <_strtol_r+0x22c>
811250b0:	05800204 	movi	r22,8
811250b4:	003fa006 	br	81124f38 <__reset+0xfb104f38>
811250b8:	00800c04 	movi	r2,48
811250bc:	80bf9e1e 	bne	r16,r2,81124f38 <__reset+0xfb104f38>
811250c0:	88800003 	ldbu	r2,0(r17)
811250c4:	00c01604 	movi	r3,88
811250c8:	108037cc 	andi	r2,r2,223
811250cc:	10ff9a1e 	bne	r2,r3,81124f38 <__reset+0xfb104f38>
811250d0:	05c00404 	movi	r23,16
811250d4:	8c000043 	ldbu	r16,1(r17)
811250d8:	b82d883a 	mov	r22,r23
811250dc:	8c400084 	addi	r17,r17,2
811250e0:	003f9606 	br	81124f3c <__reset+0xfb104f3c>

811250e4 <strtol>:
811250e4:	00a04574 	movhi	r2,33045
811250e8:	10936004 	addi	r2,r2,19840
811250ec:	300f883a 	mov	r7,r6
811250f0:	280d883a 	mov	r6,r5
811250f4:	200b883a 	mov	r5,r4
811250f8:	11000017 	ldw	r4,0(r2)
811250fc:	1124ea41 	jmpi	81124ea4 <_strtol_r>

81125100 <strtoll>:
81125100:	00a04574 	movhi	r2,33045
81125104:	10936004 	addi	r2,r2,19840
81125108:	300f883a 	mov	r7,r6
8112510c:	280d883a 	mov	r6,r5
81125110:	200b883a 	mov	r5,r4
81125114:	11000017 	ldw	r4,0(r2)
81125118:	112511c1 	jmpi	8112511c <_strtoll_r>

8112511c <_strtoll_r>:
8112511c:	00a04574 	movhi	r2,33045
81125120:	defff304 	addi	sp,sp,-52
81125124:	10935e04 	addi	r2,r2,19832
81125128:	de00012e 	bgeu	sp,et,81125130 <_strtoll_r+0x14>
8112512c:	003b68fa 	trap	3
81125130:	dc800515 	stw	r18,20(sp)
81125134:	14800017 	ldw	r18,0(r2)
81125138:	dd800915 	stw	r22,36(sp)
8112513c:	dd400815 	stw	r21,32(sp)
81125140:	dcc00615 	stw	r19,24(sp)
81125144:	d9000015 	stw	r4,0(sp)
81125148:	dfc00c15 	stw	ra,48(sp)
8112514c:	df000b15 	stw	fp,44(sp)
81125150:	ddc00a15 	stw	r23,40(sp)
81125154:	dd000715 	stw	r20,28(sp)
81125158:	dc400415 	stw	r17,16(sp)
8112515c:	dc000315 	stw	r16,12(sp)
81125160:	282d883a 	mov	r22,r5
81125164:	302b883a 	mov	r21,r6
81125168:	3827883a 	mov	r19,r7
8112516c:	2809883a 	mov	r4,r5
81125170:	24000003 	ldbu	r16,0(r4)
81125174:	24400044 	addi	r17,r4,1
81125178:	2007883a 	mov	r3,r4
8112517c:	9405883a 	add	r2,r18,r16
81125180:	10800043 	ldbu	r2,1(r2)
81125184:	8809883a 	mov	r4,r17
81125188:	1080020c 	andi	r2,r2,8
8112518c:	103ff81e 	bne	r2,zero,81125170 <__reset+0xfb105170>
81125190:	00800b44 	movi	r2,45
81125194:	80807826 	beq	r16,r2,81125378 <_strtoll_r+0x25c>
81125198:	00800ac4 	movi	r2,43
8112519c:	80807a26 	beq	r16,r2,81125388 <_strtoll_r+0x26c>
811251a0:	0039883a 	mov	fp,zero
811251a4:	98004e26 	beq	r19,zero,811252e0 <_strtoll_r+0x1c4>
811251a8:	00800404 	movi	r2,16
811251ac:	98808226 	beq	r19,r2,811253b8 <_strtoll_r+0x29c>
811251b0:	982fd7fa 	srai	r23,r19,31
811251b4:	9829883a 	mov	r20,r19
811251b8:	e0004f26 	beq	fp,zero,811252f8 <_strtoll_r+0x1dc>
811251bc:	0017883a 	mov	r11,zero
811251c0:	02a00034 	movhi	r10,32768
811251c4:	5809883a 	mov	r4,r11
811251c8:	500b883a 	mov	r5,r10
811251cc:	a00d883a 	mov	r6,r20
811251d0:	b80f883a 	mov	r7,r23
811251d4:	da800215 	stw	r10,8(sp)
811251d8:	dac00115 	stw	r11,4(sp)
811251dc:	11362240 	call	81136224 <__umoddi3>
811251e0:	dac00117 	ldw	r11,4(sp)
811251e4:	da800217 	ldw	r10,8(sp)
811251e8:	a00d883a 	mov	r6,r20
811251ec:	5809883a 	mov	r4,r11
811251f0:	500b883a 	mov	r5,r10
811251f4:	b80f883a 	mov	r7,r23
811251f8:	d8800115 	stw	r2,4(sp)
811251fc:	1135ca40 	call	81135ca4 <__udivdi3>
81125200:	9409883a 	add	r4,r18,r16
81125204:	21000043 	ldbu	r4,1(r4)
81125208:	1019883a 	mov	r12,r2
8112520c:	880b883a 	mov	r5,r17
81125210:	2240010c 	andi	r9,r4,4
81125214:	0015883a 	mov	r10,zero
81125218:	000d883a 	mov	r6,zero
8112521c:	000f883a 	mov	r7,zero
81125220:	03400044 	movi	r13,1
81125224:	02ffffc4 	movi	r11,-1
81125228:	da000117 	ldw	r8,4(sp)
8112522c:	48000d26 	beq	r9,zero,81125264 <_strtoll_r+0x148>
81125230:	843ff404 	addi	r16,r16,-48
81125234:	84c0110e 	bge	r16,r19,8112527c <_strtoll_r+0x160>
81125238:	52c00426 	beq	r10,r11,8112524c <_strtoll_r+0x130>
8112523c:	19c00236 	bltu	r3,r7,81125248 <_strtoll_r+0x12c>
81125240:	38c0311e 	bne	r7,r3,81125308 <_strtoll_r+0x1ec>
81125244:	6180302e 	bgeu	r12,r6,81125308 <_strtoll_r+0x1ec>
81125248:	02bfffc4 	movi	r10,-1
8112524c:	2c000003 	ldbu	r16,0(r5)
81125250:	29400044 	addi	r5,r5,1
81125254:	9409883a 	add	r4,r18,r16
81125258:	21000043 	ldbu	r4,1(r4)
8112525c:	2240010c 	andi	r9,r4,4
81125260:	483ff31e 	bne	r9,zero,81125230 <__reset+0xfb105230>
81125264:	210000cc 	andi	r4,r4,3
81125268:	20000426 	beq	r4,zero,8112527c <_strtoll_r+0x160>
8112526c:	23403426 	beq	r4,r13,81125340 <_strtoll_r+0x224>
81125270:	008015c4 	movi	r2,87
81125274:	80a1c83a 	sub	r16,r16,r2
81125278:	84ffef16 	blt	r16,r19,81125238 <__reset+0xfb105238>
8112527c:	00bfffc4 	movi	r2,-1
81125280:	50803426 	beq	r10,r2,81125354 <_strtoll_r+0x238>
81125284:	e0000426 	beq	fp,zero,81125298 <_strtoll_r+0x17c>
81125288:	018dc83a 	sub	r6,zero,r6
8112528c:	3004c03a 	cmpne	r2,r6,zero
81125290:	01e1c83a 	sub	r16,zero,r7
81125294:	808fc83a 	sub	r7,r16,r2
81125298:	3005883a 	mov	r2,r6
8112529c:	3807883a 	mov	r3,r7
811252a0:	a8000326 	beq	r21,zero,811252b0 <_strtoll_r+0x194>
811252a4:	5000321e 	bne	r10,zero,81125370 <_strtoll_r+0x254>
811252a8:	b00b883a 	mov	r5,r22
811252ac:	a9400015 	stw	r5,0(r21)
811252b0:	dfc00c17 	ldw	ra,48(sp)
811252b4:	df000b17 	ldw	fp,44(sp)
811252b8:	ddc00a17 	ldw	r23,40(sp)
811252bc:	dd800917 	ldw	r22,36(sp)
811252c0:	dd400817 	ldw	r21,32(sp)
811252c4:	dd000717 	ldw	r20,28(sp)
811252c8:	dcc00617 	ldw	r19,24(sp)
811252cc:	dc800517 	ldw	r18,20(sp)
811252d0:	dc400417 	ldw	r17,16(sp)
811252d4:	dc000317 	ldw	r16,12(sp)
811252d8:	dec00d04 	addi	sp,sp,52
811252dc:	f800283a 	ret
811252e0:	00800c04 	movi	r2,48
811252e4:	80802c26 	beq	r16,r2,81125398 <_strtoll_r+0x27c>
811252e8:	05000284 	movi	r20,10
811252ec:	002f883a 	mov	r23,zero
811252f0:	a027883a 	mov	r19,r20
811252f4:	e03fb11e 	bne	fp,zero,811251bc <__reset+0xfb1051bc>
811252f8:	02a00034 	movhi	r10,32768
811252fc:	52bfffc4 	addi	r10,r10,-1
81125300:	02ffffc4 	movi	r11,-1
81125304:	003faf06 	br	811251c4 <__reset+0xfb1051c4>
81125308:	33000f26 	beq	r6,r12,81125348 <_strtoll_r+0x22c>
8112530c:	b985383a 	mul	r2,r23,r6
81125310:	3d0f383a 	mul	r7,r7,r20
81125314:	3508383a 	mulxuu	r4,r6,r20
81125318:	350d383a 	mul	r6,r6,r20
8112531c:	8013d7fa 	srai	r9,r16,31
81125320:	388f883a 	add	r7,r7,r2
81125324:	818d883a 	add	r6,r16,r6
81125328:	390f883a 	add	r7,r7,r4
8112532c:	3421803a 	cmpltu	r16,r6,r16
81125330:	49cf883a 	add	r7,r9,r7
81125334:	81cf883a 	add	r7,r16,r7
81125338:	02800044 	movi	r10,1
8112533c:	003fc306 	br	8112524c <__reset+0xfb10524c>
81125340:	00800dc4 	movi	r2,55
81125344:	003fcb06 	br	81125274 <__reset+0xfb105274>
81125348:	38fff01e 	bne	r7,r3,8112530c <__reset+0xfb10530c>
8112534c:	443fbe16 	blt	r8,r16,81125248 <__reset+0xfb105248>
81125350:	003fee06 	br	8112530c <__reset+0xfb10530c>
81125354:	e0002426 	beq	fp,zero,811253e8 <_strtoll_r+0x2cc>
81125358:	0005883a 	mov	r2,zero
8112535c:	00e00034 	movhi	r3,32768
81125360:	d9800017 	ldw	r6,0(sp)
81125364:	01000884 	movi	r4,34
81125368:	31000015 	stw	r4,0(r6)
8112536c:	a83fd026 	beq	r21,zero,811252b0 <__reset+0xfb1052b0>
81125370:	297fffc4 	addi	r5,r5,-1
81125374:	003fcd06 	br	811252ac <__reset+0xfb1052ac>
81125378:	1c400084 	addi	r17,r3,2
8112537c:	1c000043 	ldbu	r16,1(r3)
81125380:	07000044 	movi	fp,1
81125384:	003f8706 	br	811251a4 <__reset+0xfb1051a4>
81125388:	1c400084 	addi	r17,r3,2
8112538c:	1c000043 	ldbu	r16,1(r3)
81125390:	0039883a 	mov	fp,zero
81125394:	003f8306 	br	811251a4 <__reset+0xfb1051a4>
81125398:	88800003 	ldbu	r2,0(r17)
8112539c:	00c01604 	movi	r3,88
811253a0:	108037cc 	andi	r2,r2,223
811253a4:	10c00a26 	beq	r2,r3,811253d0 <_strtoll_r+0x2b4>
811253a8:	05000204 	movi	r20,8
811253ac:	002f883a 	mov	r23,zero
811253b0:	a027883a 	mov	r19,r20
811253b4:	003f8006 	br	811251b8 <__reset+0xfb1051b8>
811253b8:	00800c04 	movi	r2,48
811253bc:	80800e1e 	bne	r16,r2,811253f8 <_strtoll_r+0x2dc>
811253c0:	88800003 	ldbu	r2,0(r17)
811253c4:	00c01604 	movi	r3,88
811253c8:	108037cc 	andi	r2,r2,223
811253cc:	10c00a1e 	bne	r2,r3,811253f8 <_strtoll_r+0x2dc>
811253d0:	05000404 	movi	r20,16
811253d4:	8c000043 	ldbu	r16,1(r17)
811253d8:	002f883a 	mov	r23,zero
811253dc:	8c400084 	addi	r17,r17,2
811253e0:	a027883a 	mov	r19,r20
811253e4:	003f7406 	br	811251b8 <__reset+0xfb1051b8>
811253e8:	00e00034 	movhi	r3,32768
811253ec:	18ffffc4 	addi	r3,r3,-1
811253f0:	5005883a 	mov	r2,r10
811253f4:	003fda06 	br	81125360 <__reset+0xfb105360>
811253f8:	9829883a 	mov	r20,r19
811253fc:	002f883a 	mov	r23,zero
81125400:	003f6d06 	br	811251b8 <__reset+0xfb1051b8>

81125404 <___svfprintf_internal_r>:
81125404:	deffb704 	addi	sp,sp,-292
81125408:	de00012e 	bgeu	sp,et,81125410 <___svfprintf_internal_r+0xc>
8112540c:	003b68fa 	trap	3
81125410:	dfc04815 	stw	ra,288(sp)
81125414:	ddc04615 	stw	r23,280(sp)
81125418:	d9402c15 	stw	r5,176(sp)
8112541c:	d9003915 	stw	r4,228(sp)
81125420:	302f883a 	mov	r23,r6
81125424:	d9c02d15 	stw	r7,180(sp)
81125428:	df004715 	stw	fp,284(sp)
8112542c:	dd804515 	stw	r22,276(sp)
81125430:	dd404415 	stw	r21,272(sp)
81125434:	dd004315 	stw	r20,268(sp)
81125438:	dcc04215 	stw	r19,264(sp)
8112543c:	dc804115 	stw	r18,260(sp)
81125440:	dc404015 	stw	r17,256(sp)
81125444:	dc003f15 	stw	r16,252(sp)
81125448:	112e2ec0 	call	8112e2ec <_localeconv_r>
8112544c:	10800017 	ldw	r2,0(r2)
81125450:	1009883a 	mov	r4,r2
81125454:	d8803415 	stw	r2,208(sp)
81125458:	1124dc80 	call	81124dc8 <strlen>
8112545c:	d8c02c17 	ldw	r3,176(sp)
81125460:	d8803815 	stw	r2,224(sp)
81125464:	1880030b 	ldhu	r2,12(r3)
81125468:	1080200c 	andi	r2,r2,128
8112546c:	10000226 	beq	r2,zero,81125478 <___svfprintf_internal_r+0x74>
81125470:	18800417 	ldw	r2,16(r3)
81125474:	10067f26 	beq	r2,zero,81126e74 <___svfprintf_internal_r+0x1a70>
81125478:	dcc03917 	ldw	r19,228(sp)
8112547c:	d8c00404 	addi	r3,sp,16
81125480:	05604574 	movhi	r21,33045
81125484:	d9001e04 	addi	r4,sp,120
81125488:	ad499884 	addi	r21,r21,9826
8112548c:	d8c01e15 	stw	r3,120(sp)
81125490:	d8002015 	stw	zero,128(sp)
81125494:	d8001f15 	stw	zero,124(sp)
81125498:	d8003315 	stw	zero,204(sp)
8112549c:	d8003615 	stw	zero,216(sp)
811254a0:	d8003715 	stw	zero,220(sp)
811254a4:	1811883a 	mov	r8,r3
811254a8:	d8003a15 	stw	zero,232(sp)
811254ac:	d8003b15 	stw	zero,236(sp)
811254b0:	d8002f15 	stw	zero,188(sp)
811254b4:	d9002815 	stw	r4,160(sp)
811254b8:	b8800007 	ldb	r2,0(r23)
811254bc:	10026726 	beq	r2,zero,81125e5c <___svfprintf_internal_r+0xa58>
811254c0:	00c00944 	movi	r3,37
811254c4:	b821883a 	mov	r16,r23
811254c8:	10c0021e 	bne	r2,r3,811254d4 <___svfprintf_internal_r+0xd0>
811254cc:	00001406 	br	81125520 <___svfprintf_internal_r+0x11c>
811254d0:	10c00326 	beq	r2,r3,811254e0 <___svfprintf_internal_r+0xdc>
811254d4:	84000044 	addi	r16,r16,1
811254d8:	80800007 	ldb	r2,0(r16)
811254dc:	103ffc1e 	bne	r2,zero,811254d0 <__reset+0xfb1054d0>
811254e0:	85e3c83a 	sub	r17,r16,r23
811254e4:	88000e26 	beq	r17,zero,81125520 <___svfprintf_internal_r+0x11c>
811254e8:	d8c02017 	ldw	r3,128(sp)
811254ec:	d8801f17 	ldw	r2,124(sp)
811254f0:	45c00015 	stw	r23,0(r8)
811254f4:	1c47883a 	add	r3,r3,r17
811254f8:	10800044 	addi	r2,r2,1
811254fc:	d8c02015 	stw	r3,128(sp)
81125500:	44400115 	stw	r17,4(r8)
81125504:	d8801f15 	stw	r2,124(sp)
81125508:	00c001c4 	movi	r3,7
8112550c:	18809716 	blt	r3,r2,8112576c <___svfprintf_internal_r+0x368>
81125510:	42000204 	addi	r8,r8,8
81125514:	d9402f17 	ldw	r5,188(sp)
81125518:	2c4b883a 	add	r5,r5,r17
8112551c:	d9402f15 	stw	r5,188(sp)
81125520:	80800007 	ldb	r2,0(r16)
81125524:	10009826 	beq	r2,zero,81125788 <___svfprintf_internal_r+0x384>
81125528:	84400047 	ldb	r17,1(r16)
8112552c:	00bfffc4 	movi	r2,-1
81125530:	85c00044 	addi	r23,r16,1
81125534:	d8002785 	stb	zero,158(sp)
81125538:	0007883a 	mov	r3,zero
8112553c:	000f883a 	mov	r7,zero
81125540:	d8802915 	stw	r2,164(sp)
81125544:	d8003115 	stw	zero,196(sp)
81125548:	0025883a 	mov	r18,zero
8112554c:	01401604 	movi	r5,88
81125550:	01800244 	movi	r6,9
81125554:	02800a84 	movi	r10,42
81125558:	02401b04 	movi	r9,108
8112555c:	bdc00044 	addi	r23,r23,1
81125560:	88bff804 	addi	r2,r17,-32
81125564:	2882f036 	bltu	r5,r2,81126128 <___svfprintf_internal_r+0xd24>
81125568:	100490ba 	slli	r2,r2,2
8112556c:	012044b4 	movhi	r4,33042
81125570:	21156004 	addi	r4,r4,21888
81125574:	1105883a 	add	r2,r2,r4
81125578:	10800017 	ldw	r2,0(r2)
8112557c:	1000683a 	jmp	r2
81125580:	81126090 	cmplti	r4,r16,18818
81125584:	81126128 	cmpgeui	r4,r16,18820
81125588:	81126128 	cmpgeui	r4,r16,18820
8112558c:	81126084 	addi	r4,r16,18818
81125590:	81126128 	cmpgeui	r4,r16,18820
81125594:	81126128 	cmpgeui	r4,r16,18820
81125598:	81126128 	cmpgeui	r4,r16,18820
8112559c:	81126128 	cmpgeui	r4,r16,18820
811255a0:	81126128 	cmpgeui	r4,r16,18820
811255a4:	81126128 	cmpgeui	r4,r16,18820
811255a8:	811257e4 	muli	r4,r16,18783
811255ac:	81125fc0 	call	881125fc <__reset+0x20f25fc>
811255b0:	81126128 	cmpgeui	r4,r16,18820
811255b4:	811256f4 	orhi	r4,r16,18779
811255b8:	8112580c 	andi	r4,r16,18784
811255bc:	81126128 	cmpgeui	r4,r16,18820
811255c0:	81125880 	call	88112588 <__reset+0x20f2588>
811255c4:	8112584c 	andi	r4,r16,18785
811255c8:	8112584c 	andi	r4,r16,18785
811255cc:	8112584c 	andi	r4,r16,18785
811255d0:	8112584c 	andi	r4,r16,18785
811255d4:	8112584c 	andi	r4,r16,18785
811255d8:	8112584c 	andi	r4,r16,18785
811255dc:	8112584c 	andi	r4,r16,18785
811255e0:	8112584c 	andi	r4,r16,18785
811255e4:	8112584c 	andi	r4,r16,18785
811255e8:	81126128 	cmpgeui	r4,r16,18820
811255ec:	81126128 	cmpgeui	r4,r16,18820
811255f0:	81126128 	cmpgeui	r4,r16,18820
811255f4:	81126128 	cmpgeui	r4,r16,18820
811255f8:	81126128 	cmpgeui	r4,r16,18820
811255fc:	81126128 	cmpgeui	r4,r16,18820
81125600:	81126128 	cmpgeui	r4,r16,18820
81125604:	81126128 	cmpgeui	r4,r16,18820
81125608:	81126128 	cmpgeui	r4,r16,18820
8112560c:	81126128 	cmpgeui	r4,r16,18820
81125610:	81125938 	rdprs	r4,r16,18788
81125614:	8112588c 	andi	r4,r16,18786
81125618:	81126128 	cmpgeui	r4,r16,18820
8112561c:	8112588c 	andi	r4,r16,18786
81125620:	81126128 	cmpgeui	r4,r16,18820
81125624:	81126128 	cmpgeui	r4,r16,18820
81125628:	81126128 	cmpgeui	r4,r16,18820
8112562c:	81126128 	cmpgeui	r4,r16,18820
81125630:	8112592c 	andhi	r4,r16,18788
81125634:	81126128 	cmpgeui	r4,r16,18820
81125638:	81126128 	cmpgeui	r4,r16,18820
8112563c:	811259f4 	orhi	r4,r16,18791
81125640:	81126128 	cmpgeui	r4,r16,18820
81125644:	81126128 	cmpgeui	r4,r16,18820
81125648:	81126128 	cmpgeui	r4,r16,18820
8112564c:	81126128 	cmpgeui	r4,r16,18820
81125650:	81126128 	cmpgeui	r4,r16,18820
81125654:	81125e64 	muli	r4,r16,18809
81125658:	81126128 	cmpgeui	r4,r16,18820
8112565c:	81126128 	cmpgeui	r4,r16,18820
81125660:	81125ec4 	addi	r4,r16,18811
81125664:	81126128 	cmpgeui	r4,r16,18820
81125668:	81126128 	cmpgeui	r4,r16,18820
8112566c:	81126128 	cmpgeui	r4,r16,18820
81125670:	81126128 	cmpgeui	r4,r16,18820
81125674:	81126128 	cmpgeui	r4,r16,18820
81125678:	81126128 	cmpgeui	r4,r16,18820
8112567c:	81126128 	cmpgeui	r4,r16,18820
81125680:	81126128 	cmpgeui	r4,r16,18820
81125684:	81126128 	cmpgeui	r4,r16,18820
81125688:	81126128 	cmpgeui	r4,r16,18820
8112568c:	81125f74 	orhi	r4,r16,18813
81125690:	811260b0 	cmpltui	r4,r16,18818
81125694:	8112588c 	andi	r4,r16,18786
81125698:	8112588c 	andi	r4,r16,18786
8112569c:	8112588c 	andi	r4,r16,18786
811256a0:	81126104 	addi	r4,r16,18820
811256a4:	811260b0 	cmpltui	r4,r16,18818
811256a8:	81126128 	cmpgeui	r4,r16,18820
811256ac:	81126128 	cmpgeui	r4,r16,18820
811256b0:	811260c0 	call	8811260c <__reset+0x20f260c>
811256b4:	81126128 	cmpgeui	r4,r16,18820
811256b8:	811260d0 	cmplti	r4,r16,18819
811256bc:	81125fb0 	cmpltui	r4,r16,18814
811256c0:	81125700 	call	88112570 <__reset+0x20f2570>
811256c4:	81125fd0 	cmplti	r4,r16,18815
811256c8:	81126128 	cmpgeui	r4,r16,18820
811256cc:	81125fdc 	xori	r4,r16,18815
811256d0:	81126128 	cmpgeui	r4,r16,18820
811256d4:	81126038 	rdprs	r4,r16,18816
811256d8:	81126128 	cmpgeui	r4,r16,18820
811256dc:	81126128 	cmpgeui	r4,r16,18820
811256e0:	81126048 	cmpgei	r4,r16,18817
811256e4:	d9003117 	ldw	r4,196(sp)
811256e8:	d8802d15 	stw	r2,180(sp)
811256ec:	0109c83a 	sub	r4,zero,r4
811256f0:	d9003115 	stw	r4,196(sp)
811256f4:	94800114 	ori	r18,r18,4
811256f8:	bc400007 	ldb	r17,0(r23)
811256fc:	003f9706 	br	8112555c <__reset+0xfb10555c>
81125700:	00800c04 	movi	r2,48
81125704:	d9002d17 	ldw	r4,180(sp)
81125708:	d9402917 	ldw	r5,164(sp)
8112570c:	d8802705 	stb	r2,156(sp)
81125710:	00801e04 	movi	r2,120
81125714:	d8802745 	stb	r2,157(sp)
81125718:	d8002785 	stb	zero,158(sp)
8112571c:	20c00104 	addi	r3,r4,4
81125720:	25000017 	ldw	r20,0(r4)
81125724:	002d883a 	mov	r22,zero
81125728:	90800094 	ori	r2,r18,2
8112572c:	28028616 	blt	r5,zero,81126148 <___svfprintf_internal_r+0xd44>
81125730:	00bfdfc4 	movi	r2,-129
81125734:	90a4703a 	and	r18,r18,r2
81125738:	d8c02d15 	stw	r3,180(sp)
8112573c:	94800094 	ori	r18,r18,2
81125740:	a002731e 	bne	r20,zero,81126110 <___svfprintf_internal_r+0xd0c>
81125744:	00a04574 	movhi	r2,33045
81125748:	10899104 	addi	r2,r2,9796
8112574c:	d8803a15 	stw	r2,232(sp)
81125750:	04401e04 	movi	r17,120
81125754:	d8c02917 	ldw	r3,164(sp)
81125758:	0039883a 	mov	fp,zero
8112575c:	1801d526 	beq	r3,zero,81125eb4 <___svfprintf_internal_r+0xab0>
81125760:	0029883a 	mov	r20,zero
81125764:	002d883a 	mov	r22,zero
81125768:	0001f106 	br	81125f30 <___svfprintf_internal_r+0xb2c>
8112576c:	d9402c17 	ldw	r5,176(sp)
81125770:	d9801e04 	addi	r6,sp,120
81125774:	9809883a 	mov	r4,r19
81125778:	1131d3c0 	call	81131d3c <__ssprint_r>
8112577c:	1000081e 	bne	r2,zero,811257a0 <___svfprintf_internal_r+0x39c>
81125780:	da000404 	addi	r8,sp,16
81125784:	003f6306 	br	81125514 <__reset+0xfb105514>
81125788:	d8802017 	ldw	r2,128(sp)
8112578c:	10000426 	beq	r2,zero,811257a0 <___svfprintf_internal_r+0x39c>
81125790:	d9402c17 	ldw	r5,176(sp)
81125794:	d9003917 	ldw	r4,228(sp)
81125798:	d9801e04 	addi	r6,sp,120
8112579c:	1131d3c0 	call	81131d3c <__ssprint_r>
811257a0:	d8802c17 	ldw	r2,176(sp)
811257a4:	10c0030b 	ldhu	r3,12(r2)
811257a8:	d8802f17 	ldw	r2,188(sp)
811257ac:	18c0100c 	andi	r3,r3,64
811257b0:	1805f51e 	bne	r3,zero,81126f88 <___svfprintf_internal_r+0x1b84>
811257b4:	dfc04817 	ldw	ra,288(sp)
811257b8:	df004717 	ldw	fp,284(sp)
811257bc:	ddc04617 	ldw	r23,280(sp)
811257c0:	dd804517 	ldw	r22,276(sp)
811257c4:	dd404417 	ldw	r21,272(sp)
811257c8:	dd004317 	ldw	r20,268(sp)
811257cc:	dcc04217 	ldw	r19,264(sp)
811257d0:	dc804117 	ldw	r18,260(sp)
811257d4:	dc404017 	ldw	r17,256(sp)
811257d8:	dc003f17 	ldw	r16,252(sp)
811257dc:	dec04904 	addi	sp,sp,292
811257e0:	f800283a 	ret
811257e4:	d8802d17 	ldw	r2,180(sp)
811257e8:	d9002d17 	ldw	r4,180(sp)
811257ec:	10800017 	ldw	r2,0(r2)
811257f0:	d8803115 	stw	r2,196(sp)
811257f4:	20800104 	addi	r2,r4,4
811257f8:	d9003117 	ldw	r4,196(sp)
811257fc:	203fb916 	blt	r4,zero,811256e4 <__reset+0xfb1056e4>
81125800:	d8802d15 	stw	r2,180(sp)
81125804:	bc400007 	ldb	r17,0(r23)
81125808:	003f5406 	br	8112555c <__reset+0xfb10555c>
8112580c:	bc400007 	ldb	r17,0(r23)
81125810:	bac00044 	addi	r11,r23,1
81125814:	8a873926 	beq	r17,r10,811274fc <___svfprintf_internal_r+0x20f8>
81125818:	88bff404 	addi	r2,r17,-48
8112581c:	0009883a 	mov	r4,zero
81125820:	30868836 	bltu	r6,r2,81127244 <___svfprintf_internal_r+0x1e40>
81125824:	5c400007 	ldb	r17,0(r11)
81125828:	210002a4 	muli	r4,r4,10
8112582c:	5dc00044 	addi	r23,r11,1
81125830:	b817883a 	mov	r11,r23
81125834:	2089883a 	add	r4,r4,r2
81125838:	88bff404 	addi	r2,r17,-48
8112583c:	30bff92e 	bgeu	r6,r2,81125824 <__reset+0xfb105824>
81125840:	2005d716 	blt	r4,zero,81126fa0 <___svfprintf_internal_r+0x1b9c>
81125844:	d9002915 	stw	r4,164(sp)
81125848:	003f4506 	br	81125560 <__reset+0xfb105560>
8112584c:	b809883a 	mov	r4,r23
81125850:	d8003115 	stw	zero,196(sp)
81125854:	88bff404 	addi	r2,r17,-48
81125858:	0017883a 	mov	r11,zero
8112585c:	24400007 	ldb	r17,0(r4)
81125860:	5ac002a4 	muli	r11,r11,10
81125864:	bdc00044 	addi	r23,r23,1
81125868:	b809883a 	mov	r4,r23
8112586c:	12d7883a 	add	r11,r2,r11
81125870:	88bff404 	addi	r2,r17,-48
81125874:	30bff92e 	bgeu	r6,r2,8112585c <__reset+0xfb10585c>
81125878:	dac03115 	stw	r11,196(sp)
8112587c:	003f3806 	br	81125560 <__reset+0xfb105560>
81125880:	94802014 	ori	r18,r18,128
81125884:	bc400007 	ldb	r17,0(r23)
81125888:	003f3406 	br	8112555c <__reset+0xfb10555c>
8112588c:	18c03fcc 	andi	r3,r3,255
81125890:	1807471e 	bne	r3,zero,811275b0 <___svfprintf_internal_r+0x21ac>
81125894:	9080020c 	andi	r2,r18,8
81125898:	10047d26 	beq	r2,zero,81126a90 <___svfprintf_internal_r+0x168c>
8112589c:	d8c02d17 	ldw	r3,180(sp)
811258a0:	d9002d17 	ldw	r4,180(sp)
811258a4:	d9402d17 	ldw	r5,180(sp)
811258a8:	18c00017 	ldw	r3,0(r3)
811258ac:	21000117 	ldw	r4,4(r4)
811258b0:	29400204 	addi	r5,r5,8
811258b4:	d8c03615 	stw	r3,216(sp)
811258b8:	d9003715 	stw	r4,220(sp)
811258bc:	d9402d15 	stw	r5,180(sp)
811258c0:	d9003617 	ldw	r4,216(sp)
811258c4:	d9403717 	ldw	r5,220(sp)
811258c8:	da003e15 	stw	r8,248(sp)
811258cc:	04000044 	movi	r16,1
811258d0:	112fe380 	call	8112fe38 <__fpclassifyd>
811258d4:	da003e17 	ldw	r8,248(sp)
811258d8:	14044b1e 	bne	r2,r16,81126a08 <___svfprintf_internal_r+0x1604>
811258dc:	d9003617 	ldw	r4,216(sp)
811258e0:	d9403717 	ldw	r5,220(sp)
811258e4:	000d883a 	mov	r6,zero
811258e8:	000f883a 	mov	r7,zero
811258ec:	1137d400 	call	81137d40 <__ledf2>
811258f0:	da003e17 	ldw	r8,248(sp)
811258f4:	1005f316 	blt	r2,zero,811270c4 <___svfprintf_internal_r+0x1cc0>
811258f8:	df002783 	ldbu	fp,158(sp)
811258fc:	008011c4 	movi	r2,71
81125900:	1445590e 	bge	r2,r17,81126e68 <___svfprintf_internal_r+0x1a64>
81125904:	04204574 	movhi	r16,33045
81125908:	84098904 	addi	r16,r16,9764
8112590c:	00c000c4 	movi	r3,3
81125910:	00bfdfc4 	movi	r2,-129
81125914:	d8c02a15 	stw	r3,168(sp)
81125918:	90a4703a 	and	r18,r18,r2
8112591c:	d8c02e15 	stw	r3,184(sp)
81125920:	d8002915 	stw	zero,164(sp)
81125924:	d8003215 	stw	zero,200(sp)
81125928:	00006606 	br	81125ac4 <___svfprintf_internal_r+0x6c0>
8112592c:	94800214 	ori	r18,r18,8
81125930:	bc400007 	ldb	r17,0(r23)
81125934:	003f0906 	br	8112555c <__reset+0xfb10555c>
81125938:	18c03fcc 	andi	r3,r3,255
8112593c:	1807181e 	bne	r3,zero,811275a0 <___svfprintf_internal_r+0x219c>
81125940:	94800414 	ori	r18,r18,16
81125944:	9080080c 	andi	r2,r18,32
81125948:	10039626 	beq	r2,zero,811267a4 <___svfprintf_internal_r+0x13a0>
8112594c:	d9402d17 	ldw	r5,180(sp)
81125950:	28800117 	ldw	r2,4(r5)
81125954:	2d000017 	ldw	r20,0(r5)
81125958:	29400204 	addi	r5,r5,8
8112595c:	d9402d15 	stw	r5,180(sp)
81125960:	102d883a 	mov	r22,r2
81125964:	10039816 	blt	r2,zero,811267c8 <___svfprintf_internal_r+0x13c4>
81125968:	d9402917 	ldw	r5,164(sp)
8112596c:	df002783 	ldbu	fp,158(sp)
81125970:	2803ab16 	blt	r5,zero,81126820 <___svfprintf_internal_r+0x141c>
81125974:	00ffdfc4 	movi	r3,-129
81125978:	a584b03a 	or	r2,r20,r22
8112597c:	90e4703a 	and	r18,r18,r3
81125980:	10014a26 	beq	r2,zero,81125eac <___svfprintf_internal_r+0xaa8>
81125984:	b0034b26 	beq	r22,zero,811266b4 <___svfprintf_internal_r+0x12b0>
81125988:	dc402a15 	stw	r17,168(sp)
8112598c:	dc001e04 	addi	r16,sp,120
81125990:	b023883a 	mov	r17,r22
81125994:	402d883a 	mov	r22,r8
81125998:	a009883a 	mov	r4,r20
8112599c:	880b883a 	mov	r5,r17
811259a0:	01800284 	movi	r6,10
811259a4:	000f883a 	mov	r7,zero
811259a8:	11362240 	call	81136224 <__umoddi3>
811259ac:	10800c04 	addi	r2,r2,48
811259b0:	843fffc4 	addi	r16,r16,-1
811259b4:	a009883a 	mov	r4,r20
811259b8:	880b883a 	mov	r5,r17
811259bc:	80800005 	stb	r2,0(r16)
811259c0:	01800284 	movi	r6,10
811259c4:	000f883a 	mov	r7,zero
811259c8:	1135ca40 	call	81135ca4 <__udivdi3>
811259cc:	1029883a 	mov	r20,r2
811259d0:	10c4b03a 	or	r2,r2,r3
811259d4:	1823883a 	mov	r17,r3
811259d8:	103fef1e 	bne	r2,zero,81125998 <__reset+0xfb105998>
811259dc:	d8c02817 	ldw	r3,160(sp)
811259e0:	dc402a17 	ldw	r17,168(sp)
811259e4:	b011883a 	mov	r8,r22
811259e8:	1c07c83a 	sub	r3,r3,r16
811259ec:	d8c02e15 	stw	r3,184(sp)
811259f0:	00002e06 	br	81125aac <___svfprintf_internal_r+0x6a8>
811259f4:	18c03fcc 	andi	r3,r3,255
811259f8:	1806e71e 	bne	r3,zero,81127598 <___svfprintf_internal_r+0x2194>
811259fc:	94800414 	ori	r18,r18,16
81125a00:	9080080c 	andi	r2,r18,32
81125a04:	1002d426 	beq	r2,zero,81126558 <___svfprintf_internal_r+0x1154>
81125a08:	d9402d17 	ldw	r5,180(sp)
81125a0c:	d8c02917 	ldw	r3,164(sp)
81125a10:	d8002785 	stb	zero,158(sp)
81125a14:	28800204 	addi	r2,r5,8
81125a18:	2d000017 	ldw	r20,0(r5)
81125a1c:	2d800117 	ldw	r22,4(r5)
81125a20:	18041516 	blt	r3,zero,81126a78 <___svfprintf_internal_r+0x1674>
81125a24:	013fdfc4 	movi	r4,-129
81125a28:	a586b03a 	or	r3,r20,r22
81125a2c:	d8802d15 	stw	r2,180(sp)
81125a30:	9124703a 	and	r18,r18,r4
81125a34:	1802d51e 	bne	r3,zero,8112658c <___svfprintf_internal_r+0x1188>
81125a38:	d9402917 	ldw	r5,164(sp)
81125a3c:	0039883a 	mov	fp,zero
81125a40:	2806be26 	beq	r5,zero,8112753c <___svfprintf_internal_r+0x2138>
81125a44:	0029883a 	mov	r20,zero
81125a48:	002d883a 	mov	r22,zero
81125a4c:	dc001e04 	addi	r16,sp,120
81125a50:	a006d0fa 	srli	r3,r20,3
81125a54:	b008977a 	slli	r4,r22,29
81125a58:	b02cd0fa 	srli	r22,r22,3
81125a5c:	a50001cc 	andi	r20,r20,7
81125a60:	a0800c04 	addi	r2,r20,48
81125a64:	843fffc4 	addi	r16,r16,-1
81125a68:	20e8b03a 	or	r20,r4,r3
81125a6c:	80800005 	stb	r2,0(r16)
81125a70:	a586b03a 	or	r3,r20,r22
81125a74:	183ff61e 	bne	r3,zero,81125a50 <__reset+0xfb105a50>
81125a78:	90c0004c 	andi	r3,r18,1
81125a7c:	18013926 	beq	r3,zero,81125f64 <___svfprintf_internal_r+0xb60>
81125a80:	10803fcc 	andi	r2,r2,255
81125a84:	1080201c 	xori	r2,r2,128
81125a88:	10bfe004 	addi	r2,r2,-128
81125a8c:	00c00c04 	movi	r3,48
81125a90:	10c13426 	beq	r2,r3,81125f64 <___svfprintf_internal_r+0xb60>
81125a94:	80ffffc5 	stb	r3,-1(r16)
81125a98:	d8c02817 	ldw	r3,160(sp)
81125a9c:	80bfffc4 	addi	r2,r16,-1
81125aa0:	1021883a 	mov	r16,r2
81125aa4:	1887c83a 	sub	r3,r3,r2
81125aa8:	d8c02e15 	stw	r3,184(sp)
81125aac:	d8802e17 	ldw	r2,184(sp)
81125ab0:	d9002917 	ldw	r4,164(sp)
81125ab4:	1100010e 	bge	r2,r4,81125abc <___svfprintf_internal_r+0x6b8>
81125ab8:	2005883a 	mov	r2,r4
81125abc:	d8802a15 	stw	r2,168(sp)
81125ac0:	d8003215 	stw	zero,200(sp)
81125ac4:	e7003fcc 	andi	fp,fp,255
81125ac8:	e700201c 	xori	fp,fp,128
81125acc:	e73fe004 	addi	fp,fp,-128
81125ad0:	e0000326 	beq	fp,zero,81125ae0 <___svfprintf_internal_r+0x6dc>
81125ad4:	d8c02a17 	ldw	r3,168(sp)
81125ad8:	18c00044 	addi	r3,r3,1
81125adc:	d8c02a15 	stw	r3,168(sp)
81125ae0:	90c0008c 	andi	r3,r18,2
81125ae4:	d8c02b15 	stw	r3,172(sp)
81125ae8:	18000326 	beq	r3,zero,81125af8 <___svfprintf_internal_r+0x6f4>
81125aec:	d8c02a17 	ldw	r3,168(sp)
81125af0:	18c00084 	addi	r3,r3,2
81125af4:	d8c02a15 	stw	r3,168(sp)
81125af8:	90c0210c 	andi	r3,r18,132
81125afc:	d8c03015 	stw	r3,192(sp)
81125b00:	1801a11e 	bne	r3,zero,81126188 <___svfprintf_internal_r+0xd84>
81125b04:	d9003117 	ldw	r4,196(sp)
81125b08:	d8c02a17 	ldw	r3,168(sp)
81125b0c:	20e9c83a 	sub	r20,r4,r3
81125b10:	05019d0e 	bge	zero,r20,81126188 <___svfprintf_internal_r+0xd84>
81125b14:	02400404 	movi	r9,16
81125b18:	d8c02017 	ldw	r3,128(sp)
81125b1c:	d8801f17 	ldw	r2,124(sp)
81125b20:	4d051b0e 	bge	r9,r20,81126f90 <___svfprintf_internal_r+0x1b8c>
81125b24:	01604574 	movhi	r5,33045
81125b28:	29499c84 	addi	r5,r5,9842
81125b2c:	dc403c15 	stw	r17,240(sp)
81125b30:	d9403515 	stw	r5,212(sp)
81125b34:	a023883a 	mov	r17,r20
81125b38:	482d883a 	mov	r22,r9
81125b3c:	9029883a 	mov	r20,r18
81125b40:	070001c4 	movi	fp,7
81125b44:	8025883a 	mov	r18,r16
81125b48:	dc002c17 	ldw	r16,176(sp)
81125b4c:	00000306 	br	81125b5c <___svfprintf_internal_r+0x758>
81125b50:	8c7ffc04 	addi	r17,r17,-16
81125b54:	42000204 	addi	r8,r8,8
81125b58:	b440130e 	bge	r22,r17,81125ba8 <___svfprintf_internal_r+0x7a4>
81125b5c:	01204574 	movhi	r4,33045
81125b60:	18c00404 	addi	r3,r3,16
81125b64:	10800044 	addi	r2,r2,1
81125b68:	21099c84 	addi	r4,r4,9842
81125b6c:	41000015 	stw	r4,0(r8)
81125b70:	45800115 	stw	r22,4(r8)
81125b74:	d8c02015 	stw	r3,128(sp)
81125b78:	d8801f15 	stw	r2,124(sp)
81125b7c:	e0bff40e 	bge	fp,r2,81125b50 <__reset+0xfb105b50>
81125b80:	d9801e04 	addi	r6,sp,120
81125b84:	800b883a 	mov	r5,r16
81125b88:	9809883a 	mov	r4,r19
81125b8c:	1131d3c0 	call	81131d3c <__ssprint_r>
81125b90:	103f031e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81125b94:	8c7ffc04 	addi	r17,r17,-16
81125b98:	d8c02017 	ldw	r3,128(sp)
81125b9c:	d8801f17 	ldw	r2,124(sp)
81125ba0:	da000404 	addi	r8,sp,16
81125ba4:	b47fed16 	blt	r22,r17,81125b5c <__reset+0xfb105b5c>
81125ba8:	9021883a 	mov	r16,r18
81125bac:	a025883a 	mov	r18,r20
81125bb0:	8829883a 	mov	r20,r17
81125bb4:	dc403c17 	ldw	r17,240(sp)
81125bb8:	d9403517 	ldw	r5,212(sp)
81125bbc:	a0c7883a 	add	r3,r20,r3
81125bc0:	10800044 	addi	r2,r2,1
81125bc4:	41400015 	stw	r5,0(r8)
81125bc8:	45000115 	stw	r20,4(r8)
81125bcc:	d8c02015 	stw	r3,128(sp)
81125bd0:	d8801f15 	stw	r2,124(sp)
81125bd4:	010001c4 	movi	r4,7
81125bd8:	20829f16 	blt	r4,r2,81126658 <___svfprintf_internal_r+0x1254>
81125bdc:	df002787 	ldb	fp,158(sp)
81125be0:	42000204 	addi	r8,r8,8
81125be4:	e0000c26 	beq	fp,zero,81125c18 <___svfprintf_internal_r+0x814>
81125be8:	d8801f17 	ldw	r2,124(sp)
81125bec:	d9002784 	addi	r4,sp,158
81125bf0:	18c00044 	addi	r3,r3,1
81125bf4:	10800044 	addi	r2,r2,1
81125bf8:	41000015 	stw	r4,0(r8)
81125bfc:	01000044 	movi	r4,1
81125c00:	41000115 	stw	r4,4(r8)
81125c04:	d8c02015 	stw	r3,128(sp)
81125c08:	d8801f15 	stw	r2,124(sp)
81125c0c:	010001c4 	movi	r4,7
81125c10:	20823816 	blt	r4,r2,811264f4 <___svfprintf_internal_r+0x10f0>
81125c14:	42000204 	addi	r8,r8,8
81125c18:	d8802b17 	ldw	r2,172(sp)
81125c1c:	10000c26 	beq	r2,zero,81125c50 <___svfprintf_internal_r+0x84c>
81125c20:	d8801f17 	ldw	r2,124(sp)
81125c24:	d9002704 	addi	r4,sp,156
81125c28:	18c00084 	addi	r3,r3,2
81125c2c:	10800044 	addi	r2,r2,1
81125c30:	41000015 	stw	r4,0(r8)
81125c34:	01000084 	movi	r4,2
81125c38:	41000115 	stw	r4,4(r8)
81125c3c:	d8c02015 	stw	r3,128(sp)
81125c40:	d8801f15 	stw	r2,124(sp)
81125c44:	010001c4 	movi	r4,7
81125c48:	20823216 	blt	r4,r2,81126514 <___svfprintf_internal_r+0x1110>
81125c4c:	42000204 	addi	r8,r8,8
81125c50:	d9003017 	ldw	r4,192(sp)
81125c54:	00802004 	movi	r2,128
81125c58:	20819726 	beq	r4,r2,811262b8 <___svfprintf_internal_r+0xeb4>
81125c5c:	d9402917 	ldw	r5,164(sp)
81125c60:	d8802e17 	ldw	r2,184(sp)
81125c64:	28adc83a 	sub	r22,r5,r2
81125c68:	05802f0e 	bge	zero,r22,81125d28 <___svfprintf_internal_r+0x924>
81125c6c:	07000404 	movi	fp,16
81125c70:	d8801f17 	ldw	r2,124(sp)
81125c74:	e583c00e 	bge	fp,r22,81126b78 <___svfprintf_internal_r+0x1774>
81125c78:	01604574 	movhi	r5,33045
81125c7c:	29499884 	addi	r5,r5,9826
81125c80:	dc402915 	stw	r17,164(sp)
81125c84:	d9402b15 	stw	r5,172(sp)
81125c88:	b023883a 	mov	r17,r22
81125c8c:	050001c4 	movi	r20,7
81125c90:	902d883a 	mov	r22,r18
81125c94:	8025883a 	mov	r18,r16
81125c98:	dc002c17 	ldw	r16,176(sp)
81125c9c:	00000306 	br	81125cac <___svfprintf_internal_r+0x8a8>
81125ca0:	8c7ffc04 	addi	r17,r17,-16
81125ca4:	42000204 	addi	r8,r8,8
81125ca8:	e440110e 	bge	fp,r17,81125cf0 <___svfprintf_internal_r+0x8ec>
81125cac:	18c00404 	addi	r3,r3,16
81125cb0:	10800044 	addi	r2,r2,1
81125cb4:	45400015 	stw	r21,0(r8)
81125cb8:	47000115 	stw	fp,4(r8)
81125cbc:	d8c02015 	stw	r3,128(sp)
81125cc0:	d8801f15 	stw	r2,124(sp)
81125cc4:	a0bff60e 	bge	r20,r2,81125ca0 <__reset+0xfb105ca0>
81125cc8:	d9801e04 	addi	r6,sp,120
81125ccc:	800b883a 	mov	r5,r16
81125cd0:	9809883a 	mov	r4,r19
81125cd4:	1131d3c0 	call	81131d3c <__ssprint_r>
81125cd8:	103eb11e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81125cdc:	8c7ffc04 	addi	r17,r17,-16
81125ce0:	d8c02017 	ldw	r3,128(sp)
81125ce4:	d8801f17 	ldw	r2,124(sp)
81125ce8:	da000404 	addi	r8,sp,16
81125cec:	e47fef16 	blt	fp,r17,81125cac <__reset+0xfb105cac>
81125cf0:	9021883a 	mov	r16,r18
81125cf4:	b025883a 	mov	r18,r22
81125cf8:	882d883a 	mov	r22,r17
81125cfc:	dc402917 	ldw	r17,164(sp)
81125d00:	d9002b17 	ldw	r4,172(sp)
81125d04:	1d87883a 	add	r3,r3,r22
81125d08:	10800044 	addi	r2,r2,1
81125d0c:	41000015 	stw	r4,0(r8)
81125d10:	45800115 	stw	r22,4(r8)
81125d14:	d8c02015 	stw	r3,128(sp)
81125d18:	d8801f15 	stw	r2,124(sp)
81125d1c:	010001c4 	movi	r4,7
81125d20:	2081ec16 	blt	r4,r2,811264d4 <___svfprintf_internal_r+0x10d0>
81125d24:	42000204 	addi	r8,r8,8
81125d28:	9080400c 	andi	r2,r18,256
81125d2c:	1001181e 	bne	r2,zero,81126190 <___svfprintf_internal_r+0xd8c>
81125d30:	d9402e17 	ldw	r5,184(sp)
81125d34:	d8801f17 	ldw	r2,124(sp)
81125d38:	44000015 	stw	r16,0(r8)
81125d3c:	1947883a 	add	r3,r3,r5
81125d40:	10800044 	addi	r2,r2,1
81125d44:	41400115 	stw	r5,4(r8)
81125d48:	d8c02015 	stw	r3,128(sp)
81125d4c:	d8801f15 	stw	r2,124(sp)
81125d50:	010001c4 	movi	r4,7
81125d54:	2081d116 	blt	r4,r2,8112649c <___svfprintf_internal_r+0x1098>
81125d58:	42000204 	addi	r8,r8,8
81125d5c:	9480010c 	andi	r18,r18,4
81125d60:	90003226 	beq	r18,zero,81125e2c <___svfprintf_internal_r+0xa28>
81125d64:	d9403117 	ldw	r5,196(sp)
81125d68:	d8802a17 	ldw	r2,168(sp)
81125d6c:	28a1c83a 	sub	r16,r5,r2
81125d70:	04002e0e 	bge	zero,r16,81125e2c <___svfprintf_internal_r+0xa28>
81125d74:	04400404 	movi	r17,16
81125d78:	d8801f17 	ldw	r2,124(sp)
81125d7c:	8c04b90e 	bge	r17,r16,81127064 <___svfprintf_internal_r+0x1c60>
81125d80:	01604574 	movhi	r5,33045
81125d84:	29499c84 	addi	r5,r5,9842
81125d88:	d9403515 	stw	r5,212(sp)
81125d8c:	048001c4 	movi	r18,7
81125d90:	dd002c17 	ldw	r20,176(sp)
81125d94:	00000306 	br	81125da4 <___svfprintf_internal_r+0x9a0>
81125d98:	843ffc04 	addi	r16,r16,-16
81125d9c:	42000204 	addi	r8,r8,8
81125da0:	8c00130e 	bge	r17,r16,81125df0 <___svfprintf_internal_r+0x9ec>
81125da4:	01204574 	movhi	r4,33045
81125da8:	18c00404 	addi	r3,r3,16
81125dac:	10800044 	addi	r2,r2,1
81125db0:	21099c84 	addi	r4,r4,9842
81125db4:	41000015 	stw	r4,0(r8)
81125db8:	44400115 	stw	r17,4(r8)
81125dbc:	d8c02015 	stw	r3,128(sp)
81125dc0:	d8801f15 	stw	r2,124(sp)
81125dc4:	90bff40e 	bge	r18,r2,81125d98 <__reset+0xfb105d98>
81125dc8:	d9801e04 	addi	r6,sp,120
81125dcc:	a00b883a 	mov	r5,r20
81125dd0:	9809883a 	mov	r4,r19
81125dd4:	1131d3c0 	call	81131d3c <__ssprint_r>
81125dd8:	103e711e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81125ddc:	843ffc04 	addi	r16,r16,-16
81125de0:	d8c02017 	ldw	r3,128(sp)
81125de4:	d8801f17 	ldw	r2,124(sp)
81125de8:	da000404 	addi	r8,sp,16
81125dec:	8c3fed16 	blt	r17,r16,81125da4 <__reset+0xfb105da4>
81125df0:	d9403517 	ldw	r5,212(sp)
81125df4:	1c07883a 	add	r3,r3,r16
81125df8:	10800044 	addi	r2,r2,1
81125dfc:	41400015 	stw	r5,0(r8)
81125e00:	44000115 	stw	r16,4(r8)
81125e04:	d8c02015 	stw	r3,128(sp)
81125e08:	d8801f15 	stw	r2,124(sp)
81125e0c:	010001c4 	movi	r4,7
81125e10:	2080060e 	bge	r4,r2,81125e2c <___svfprintf_internal_r+0xa28>
81125e14:	d9402c17 	ldw	r5,176(sp)
81125e18:	d9801e04 	addi	r6,sp,120
81125e1c:	9809883a 	mov	r4,r19
81125e20:	1131d3c0 	call	81131d3c <__ssprint_r>
81125e24:	103e5e1e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81125e28:	d8c02017 	ldw	r3,128(sp)
81125e2c:	d8803117 	ldw	r2,196(sp)
81125e30:	d9002a17 	ldw	r4,168(sp)
81125e34:	1100010e 	bge	r2,r4,81125e3c <___svfprintf_internal_r+0xa38>
81125e38:	2005883a 	mov	r2,r4
81125e3c:	d9402f17 	ldw	r5,188(sp)
81125e40:	288b883a 	add	r5,r5,r2
81125e44:	d9402f15 	stw	r5,188(sp)
81125e48:	18019c1e 	bne	r3,zero,811264bc <___svfprintf_internal_r+0x10b8>
81125e4c:	b8800007 	ldb	r2,0(r23)
81125e50:	d8001f15 	stw	zero,124(sp)
81125e54:	da000404 	addi	r8,sp,16
81125e58:	103d991e 	bne	r2,zero,811254c0 <__reset+0xfb1054c0>
81125e5c:	b821883a 	mov	r16,r23
81125e60:	003daf06 	br	81125520 <__reset+0xfb105520>
81125e64:	18c03fcc 	andi	r3,r3,255
81125e68:	1805c71e 	bne	r3,zero,81127588 <___svfprintf_internal_r+0x2184>
81125e6c:	94800414 	ori	r18,r18,16
81125e70:	9080080c 	andi	r2,r18,32
81125e74:	10020126 	beq	r2,zero,8112667c <___svfprintf_internal_r+0x1278>
81125e78:	d8802d17 	ldw	r2,180(sp)
81125e7c:	d9002917 	ldw	r4,164(sp)
81125e80:	d8002785 	stb	zero,158(sp)
81125e84:	10c00204 	addi	r3,r2,8
81125e88:	15000017 	ldw	r20,0(r2)
81125e8c:	15800117 	ldw	r22,4(r2)
81125e90:	20038e16 	blt	r4,zero,81126ccc <___svfprintf_internal_r+0x18c8>
81125e94:	013fdfc4 	movi	r4,-129
81125e98:	a584b03a 	or	r2,r20,r22
81125e9c:	d8c02d15 	stw	r3,180(sp)
81125ea0:	9124703a 	and	r18,r18,r4
81125ea4:	0039883a 	mov	fp,zero
81125ea8:	103eb61e 	bne	r2,zero,81125984 <__reset+0xfb105984>
81125eac:	d8802917 	ldw	r2,164(sp)
81125eb0:	1002c81e 	bne	r2,zero,811269d4 <___svfprintf_internal_r+0x15d0>
81125eb4:	d8002915 	stw	zero,164(sp)
81125eb8:	d8002e15 	stw	zero,184(sp)
81125ebc:	dc001e04 	addi	r16,sp,120
81125ec0:	003efa06 	br	81125aac <__reset+0xfb105aac>
81125ec4:	18c03fcc 	andi	r3,r3,255
81125ec8:	1805ad1e 	bne	r3,zero,81127580 <___svfprintf_internal_r+0x217c>
81125ecc:	01604574 	movhi	r5,33045
81125ed0:	29498c04 	addi	r5,r5,9776
81125ed4:	d9403a15 	stw	r5,232(sp)
81125ed8:	9080080c 	andi	r2,r18,32
81125edc:	10006126 	beq	r2,zero,81126064 <___svfprintf_internal_r+0xc60>
81125ee0:	d8802d17 	ldw	r2,180(sp)
81125ee4:	15000017 	ldw	r20,0(r2)
81125ee8:	15800117 	ldw	r22,4(r2)
81125eec:	10800204 	addi	r2,r2,8
81125ef0:	d8802d15 	stw	r2,180(sp)
81125ef4:	9080004c 	andi	r2,r18,1
81125ef8:	10018e26 	beq	r2,zero,81126534 <___svfprintf_internal_r+0x1130>
81125efc:	a584b03a 	or	r2,r20,r22
81125f00:	10030926 	beq	r2,zero,81126b28 <___svfprintf_internal_r+0x1724>
81125f04:	d8c02917 	ldw	r3,164(sp)
81125f08:	00800c04 	movi	r2,48
81125f0c:	d8802705 	stb	r2,156(sp)
81125f10:	dc402745 	stb	r17,157(sp)
81125f14:	d8002785 	stb	zero,158(sp)
81125f18:	90800094 	ori	r2,r18,2
81125f1c:	18048716 	blt	r3,zero,8112713c <___svfprintf_internal_r+0x1d38>
81125f20:	00bfdfc4 	movi	r2,-129
81125f24:	90a4703a 	and	r18,r18,r2
81125f28:	94800094 	ori	r18,r18,2
81125f2c:	0039883a 	mov	fp,zero
81125f30:	d9003a17 	ldw	r4,232(sp)
81125f34:	dc001e04 	addi	r16,sp,120
81125f38:	a08003cc 	andi	r2,r20,15
81125f3c:	b006973a 	slli	r3,r22,28
81125f40:	2085883a 	add	r2,r4,r2
81125f44:	a028d13a 	srli	r20,r20,4
81125f48:	10800003 	ldbu	r2,0(r2)
81125f4c:	b02cd13a 	srli	r22,r22,4
81125f50:	843fffc4 	addi	r16,r16,-1
81125f54:	1d28b03a 	or	r20,r3,r20
81125f58:	80800005 	stb	r2,0(r16)
81125f5c:	a584b03a 	or	r2,r20,r22
81125f60:	103ff51e 	bne	r2,zero,81125f38 <__reset+0xfb105f38>
81125f64:	d8c02817 	ldw	r3,160(sp)
81125f68:	1c07c83a 	sub	r3,r3,r16
81125f6c:	d8c02e15 	stw	r3,184(sp)
81125f70:	003ece06 	br	81125aac <__reset+0xfb105aac>
81125f74:	d8c02d17 	ldw	r3,180(sp)
81125f78:	d9002d17 	ldw	r4,180(sp)
81125f7c:	d8002785 	stb	zero,158(sp)
81125f80:	18800017 	ldw	r2,0(r3)
81125f84:	21000104 	addi	r4,r4,4
81125f88:	00c00044 	movi	r3,1
81125f8c:	d8c02a15 	stw	r3,168(sp)
81125f90:	d8801405 	stb	r2,80(sp)
81125f94:	d9002d15 	stw	r4,180(sp)
81125f98:	d8c02e15 	stw	r3,184(sp)
81125f9c:	d8002915 	stw	zero,164(sp)
81125fa0:	d8003215 	stw	zero,200(sp)
81125fa4:	dc001404 	addi	r16,sp,80
81125fa8:	0039883a 	mov	fp,zero
81125fac:	003ecc06 	br	81125ae0 <__reset+0xfb105ae0>
81125fb0:	18c03fcc 	andi	r3,r3,255
81125fb4:	183e9226 	beq	r3,zero,81125a00 <__reset+0xfb105a00>
81125fb8:	d9c02785 	stb	r7,158(sp)
81125fbc:	003e9006 	br	81125a00 <__reset+0xfb105a00>
81125fc0:	00c00044 	movi	r3,1
81125fc4:	01c00ac4 	movi	r7,43
81125fc8:	bc400007 	ldb	r17,0(r23)
81125fcc:	003d6306 	br	8112555c <__reset+0xfb10555c>
81125fd0:	94800814 	ori	r18,r18,32
81125fd4:	bc400007 	ldb	r17,0(r23)
81125fd8:	003d6006 	br	8112555c <__reset+0xfb10555c>
81125fdc:	d8c02d17 	ldw	r3,180(sp)
81125fe0:	d8002785 	stb	zero,158(sp)
81125fe4:	1c000017 	ldw	r16,0(r3)
81125fe8:	1d000104 	addi	r20,r3,4
81125fec:	80040f26 	beq	r16,zero,8112702c <___svfprintf_internal_r+0x1c28>
81125ff0:	d9002917 	ldw	r4,164(sp)
81125ff4:	2003dc16 	blt	r4,zero,81126f68 <___svfprintf_internal_r+0x1b64>
81125ff8:	200d883a 	mov	r6,r4
81125ffc:	000b883a 	mov	r5,zero
81126000:	8009883a 	mov	r4,r16
81126004:	da003e15 	stw	r8,248(sp)
81126008:	112e5c80 	call	8112e5c8 <memchr>
8112600c:	da003e17 	ldw	r8,248(sp)
81126010:	10045826 	beq	r2,zero,81127174 <___svfprintf_internal_r+0x1d70>
81126014:	1405c83a 	sub	r2,r2,r16
81126018:	d8802e15 	stw	r2,184(sp)
8112601c:	1003d816 	blt	r2,zero,81126f80 <___svfprintf_internal_r+0x1b7c>
81126020:	df002783 	ldbu	fp,158(sp)
81126024:	d8802a15 	stw	r2,168(sp)
81126028:	dd002d15 	stw	r20,180(sp)
8112602c:	d8002915 	stw	zero,164(sp)
81126030:	d8003215 	stw	zero,200(sp)
81126034:	003ea306 	br	81125ac4 <__reset+0xfb105ac4>
81126038:	18c03fcc 	andi	r3,r3,255
8112603c:	183f8c26 	beq	r3,zero,81125e70 <__reset+0xfb105e70>
81126040:	d9c02785 	stb	r7,158(sp)
81126044:	003f8a06 	br	81125e70 <__reset+0xfb105e70>
81126048:	18c03fcc 	andi	r3,r3,255
8112604c:	1805631e 	bne	r3,zero,811275dc <___svfprintf_internal_r+0x21d8>
81126050:	01604574 	movhi	r5,33045
81126054:	29499104 	addi	r5,r5,9796
81126058:	d9403a15 	stw	r5,232(sp)
8112605c:	9080080c 	andi	r2,r18,32
81126060:	103f9f1e 	bne	r2,zero,81125ee0 <__reset+0xfb105ee0>
81126064:	9080040c 	andi	r2,r18,16
81126068:	10029c26 	beq	r2,zero,81126adc <___svfprintf_internal_r+0x16d8>
8112606c:	d8c02d17 	ldw	r3,180(sp)
81126070:	002d883a 	mov	r22,zero
81126074:	1d000017 	ldw	r20,0(r3)
81126078:	18c00104 	addi	r3,r3,4
8112607c:	d8c02d15 	stw	r3,180(sp)
81126080:	003f9c06 	br	81125ef4 <__reset+0xfb105ef4>
81126084:	94800054 	ori	r18,r18,1
81126088:	bc400007 	ldb	r17,0(r23)
8112608c:	003d3306 	br	8112555c <__reset+0xfb10555c>
81126090:	38803fcc 	andi	r2,r7,255
81126094:	1080201c 	xori	r2,r2,128
81126098:	10bfe004 	addi	r2,r2,-128
8112609c:	1002971e 	bne	r2,zero,81126afc <___svfprintf_internal_r+0x16f8>
811260a0:	00c00044 	movi	r3,1
811260a4:	01c00804 	movi	r7,32
811260a8:	bc400007 	ldb	r17,0(r23)
811260ac:	003d2b06 	br	8112555c <__reset+0xfb10555c>
811260b0:	18c03fcc 	andi	r3,r3,255
811260b4:	183e2326 	beq	r3,zero,81125944 <__reset+0xfb105944>
811260b8:	d9c02785 	stb	r7,158(sp)
811260bc:	003e2106 	br	81125944 <__reset+0xfb105944>
811260c0:	bc400007 	ldb	r17,0(r23)
811260c4:	8a430426 	beq	r17,r9,81126cd8 <___svfprintf_internal_r+0x18d4>
811260c8:	94800414 	ori	r18,r18,16
811260cc:	003d2306 	br	8112555c <__reset+0xfb10555c>
811260d0:	18c03fcc 	andi	r3,r3,255
811260d4:	18053f1e 	bne	r3,zero,811275d4 <___svfprintf_internal_r+0x21d0>
811260d8:	9080080c 	andi	r2,r18,32
811260dc:	10028926 	beq	r2,zero,81126b04 <___svfprintf_internal_r+0x1700>
811260e0:	d9402d17 	ldw	r5,180(sp)
811260e4:	d9002f17 	ldw	r4,188(sp)
811260e8:	28800017 	ldw	r2,0(r5)
811260ec:	2007d7fa 	srai	r3,r4,31
811260f0:	29400104 	addi	r5,r5,4
811260f4:	d9402d15 	stw	r5,180(sp)
811260f8:	11000015 	stw	r4,0(r2)
811260fc:	10c00115 	stw	r3,4(r2)
81126100:	003ced06 	br	811254b8 <__reset+0xfb1054b8>
81126104:	94801014 	ori	r18,r18,64
81126108:	bc400007 	ldb	r17,0(r23)
8112610c:	003d1306 	br	8112555c <__reset+0xfb10555c>
81126110:	01204574 	movhi	r4,33045
81126114:	21099104 	addi	r4,r4,9796
81126118:	0039883a 	mov	fp,zero
8112611c:	d9003a15 	stw	r4,232(sp)
81126120:	04401e04 	movi	r17,120
81126124:	003f8206 	br	81125f30 <__reset+0xfb105f30>
81126128:	18c03fcc 	andi	r3,r3,255
8112612c:	1805221e 	bne	r3,zero,811275b8 <___svfprintf_internal_r+0x21b4>
81126130:	883d9526 	beq	r17,zero,81125788 <__reset+0xfb105788>
81126134:	00c00044 	movi	r3,1
81126138:	d8c02a15 	stw	r3,168(sp)
8112613c:	dc401405 	stb	r17,80(sp)
81126140:	d8002785 	stb	zero,158(sp)
81126144:	003f9406 	br	81125f98 <__reset+0xfb105f98>
81126148:	01204574 	movhi	r4,33045
8112614c:	21099104 	addi	r4,r4,9796
81126150:	d9003a15 	stw	r4,232(sp)
81126154:	d8c02d15 	stw	r3,180(sp)
81126158:	1025883a 	mov	r18,r2
8112615c:	04401e04 	movi	r17,120
81126160:	a584b03a 	or	r2,r20,r22
81126164:	1000fa1e 	bne	r2,zero,81126550 <___svfprintf_internal_r+0x114c>
81126168:	0039883a 	mov	fp,zero
8112616c:	00800084 	movi	r2,2
81126170:	10803fcc 	andi	r2,r2,255
81126174:	00c00044 	movi	r3,1
81126178:	10c21626 	beq	r2,r3,811269d4 <___svfprintf_internal_r+0x15d0>
8112617c:	00c00084 	movi	r3,2
81126180:	10fe301e 	bne	r2,r3,81125a44 <__reset+0xfb105a44>
81126184:	003d7606 	br	81125760 <__reset+0xfb105760>
81126188:	d8c02017 	ldw	r3,128(sp)
8112618c:	003e9506 	br	81125be4 <__reset+0xfb105be4>
81126190:	00801944 	movi	r2,101
81126194:	14407c0e 	bge	r2,r17,81126388 <___svfprintf_internal_r+0xf84>
81126198:	d9003617 	ldw	r4,216(sp)
8112619c:	d9403717 	ldw	r5,220(sp)
811261a0:	000d883a 	mov	r6,zero
811261a4:	000f883a 	mov	r7,zero
811261a8:	d8c03d15 	stw	r3,244(sp)
811261ac:	da003e15 	stw	r8,248(sp)
811261b0:	1137cb80 	call	81137cb8 <__eqdf2>
811261b4:	d8c03d17 	ldw	r3,244(sp)
811261b8:	da003e17 	ldw	r8,248(sp)
811261bc:	1000f51e 	bne	r2,zero,81126594 <___svfprintf_internal_r+0x1190>
811261c0:	d8801f17 	ldw	r2,124(sp)
811261c4:	01204574 	movhi	r4,33045
811261c8:	21099804 	addi	r4,r4,9824
811261cc:	18c00044 	addi	r3,r3,1
811261d0:	10800044 	addi	r2,r2,1
811261d4:	41000015 	stw	r4,0(r8)
811261d8:	01000044 	movi	r4,1
811261dc:	41000115 	stw	r4,4(r8)
811261e0:	d8c02015 	stw	r3,128(sp)
811261e4:	d8801f15 	stw	r2,124(sp)
811261e8:	010001c4 	movi	r4,7
811261ec:	20826616 	blt	r4,r2,81126b88 <___svfprintf_internal_r+0x1784>
811261f0:	42000204 	addi	r8,r8,8
811261f4:	d8802617 	ldw	r2,152(sp)
811261f8:	d9403317 	ldw	r5,204(sp)
811261fc:	11400216 	blt	r2,r5,81126208 <___svfprintf_internal_r+0xe04>
81126200:	9080004c 	andi	r2,r18,1
81126204:	103ed526 	beq	r2,zero,81125d5c <__reset+0xfb105d5c>
81126208:	d8803817 	ldw	r2,224(sp)
8112620c:	d9003417 	ldw	r4,208(sp)
81126210:	d9403817 	ldw	r5,224(sp)
81126214:	1887883a 	add	r3,r3,r2
81126218:	d8801f17 	ldw	r2,124(sp)
8112621c:	41000015 	stw	r4,0(r8)
81126220:	41400115 	stw	r5,4(r8)
81126224:	10800044 	addi	r2,r2,1
81126228:	d8c02015 	stw	r3,128(sp)
8112622c:	d8801f15 	stw	r2,124(sp)
81126230:	010001c4 	movi	r4,7
81126234:	2082af16 	blt	r4,r2,81126cf4 <___svfprintf_internal_r+0x18f0>
81126238:	42000204 	addi	r8,r8,8
8112623c:	d8803317 	ldw	r2,204(sp)
81126240:	143fffc4 	addi	r16,r2,-1
81126244:	043ec50e 	bge	zero,r16,81125d5c <__reset+0xfb105d5c>
81126248:	04400404 	movi	r17,16
8112624c:	d8801f17 	ldw	r2,124(sp)
81126250:	8c00860e 	bge	r17,r16,8112646c <___svfprintf_internal_r+0x1068>
81126254:	01604574 	movhi	r5,33045
81126258:	29499884 	addi	r5,r5,9826
8112625c:	d9402b15 	stw	r5,172(sp)
81126260:	058001c4 	movi	r22,7
81126264:	dd002c17 	ldw	r20,176(sp)
81126268:	00000306 	br	81126278 <___svfprintf_internal_r+0xe74>
8112626c:	42000204 	addi	r8,r8,8
81126270:	843ffc04 	addi	r16,r16,-16
81126274:	8c00800e 	bge	r17,r16,81126478 <___svfprintf_internal_r+0x1074>
81126278:	18c00404 	addi	r3,r3,16
8112627c:	10800044 	addi	r2,r2,1
81126280:	45400015 	stw	r21,0(r8)
81126284:	44400115 	stw	r17,4(r8)
81126288:	d8c02015 	stw	r3,128(sp)
8112628c:	d8801f15 	stw	r2,124(sp)
81126290:	b0bff60e 	bge	r22,r2,8112626c <__reset+0xfb10626c>
81126294:	d9801e04 	addi	r6,sp,120
81126298:	a00b883a 	mov	r5,r20
8112629c:	9809883a 	mov	r4,r19
811262a0:	1131d3c0 	call	81131d3c <__ssprint_r>
811262a4:	103d3e1e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
811262a8:	d8c02017 	ldw	r3,128(sp)
811262ac:	d8801f17 	ldw	r2,124(sp)
811262b0:	da000404 	addi	r8,sp,16
811262b4:	003fee06 	br	81126270 <__reset+0xfb106270>
811262b8:	d9403117 	ldw	r5,196(sp)
811262bc:	d8802a17 	ldw	r2,168(sp)
811262c0:	28adc83a 	sub	r22,r5,r2
811262c4:	05be650e 	bge	zero,r22,81125c5c <__reset+0xfb105c5c>
811262c8:	07000404 	movi	fp,16
811262cc:	d8801f17 	ldw	r2,124(sp)
811262d0:	e583a20e 	bge	fp,r22,8112715c <___svfprintf_internal_r+0x1d58>
811262d4:	01604574 	movhi	r5,33045
811262d8:	29499884 	addi	r5,r5,9826
811262dc:	dc403015 	stw	r17,192(sp)
811262e0:	d9402b15 	stw	r5,172(sp)
811262e4:	b023883a 	mov	r17,r22
811262e8:	050001c4 	movi	r20,7
811262ec:	902d883a 	mov	r22,r18
811262f0:	8025883a 	mov	r18,r16
811262f4:	dc002c17 	ldw	r16,176(sp)
811262f8:	00000306 	br	81126308 <___svfprintf_internal_r+0xf04>
811262fc:	8c7ffc04 	addi	r17,r17,-16
81126300:	42000204 	addi	r8,r8,8
81126304:	e440110e 	bge	fp,r17,8112634c <___svfprintf_internal_r+0xf48>
81126308:	18c00404 	addi	r3,r3,16
8112630c:	10800044 	addi	r2,r2,1
81126310:	45400015 	stw	r21,0(r8)
81126314:	47000115 	stw	fp,4(r8)
81126318:	d8c02015 	stw	r3,128(sp)
8112631c:	d8801f15 	stw	r2,124(sp)
81126320:	a0bff60e 	bge	r20,r2,811262fc <__reset+0xfb1062fc>
81126324:	d9801e04 	addi	r6,sp,120
81126328:	800b883a 	mov	r5,r16
8112632c:	9809883a 	mov	r4,r19
81126330:	1131d3c0 	call	81131d3c <__ssprint_r>
81126334:	103d1a1e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126338:	8c7ffc04 	addi	r17,r17,-16
8112633c:	d8c02017 	ldw	r3,128(sp)
81126340:	d8801f17 	ldw	r2,124(sp)
81126344:	da000404 	addi	r8,sp,16
81126348:	e47fef16 	blt	fp,r17,81126308 <__reset+0xfb106308>
8112634c:	9021883a 	mov	r16,r18
81126350:	b025883a 	mov	r18,r22
81126354:	882d883a 	mov	r22,r17
81126358:	dc403017 	ldw	r17,192(sp)
8112635c:	d9002b17 	ldw	r4,172(sp)
81126360:	1d87883a 	add	r3,r3,r22
81126364:	10800044 	addi	r2,r2,1
81126368:	41000015 	stw	r4,0(r8)
8112636c:	45800115 	stw	r22,4(r8)
81126370:	d8c02015 	stw	r3,128(sp)
81126374:	d8801f15 	stw	r2,124(sp)
81126378:	010001c4 	movi	r4,7
8112637c:	20819a16 	blt	r4,r2,811269e8 <___svfprintf_internal_r+0x15e4>
81126380:	42000204 	addi	r8,r8,8
81126384:	003e3506 	br	81125c5c <__reset+0xfb105c5c>
81126388:	d9403317 	ldw	r5,204(sp)
8112638c:	00800044 	movi	r2,1
81126390:	18c00044 	addi	r3,r3,1
81126394:	1141710e 	bge	r2,r5,8112695c <___svfprintf_internal_r+0x1558>
81126398:	dc401f17 	ldw	r17,124(sp)
8112639c:	00800044 	movi	r2,1
811263a0:	40800115 	stw	r2,4(r8)
811263a4:	8c400044 	addi	r17,r17,1
811263a8:	44000015 	stw	r16,0(r8)
811263ac:	d8c02015 	stw	r3,128(sp)
811263b0:	dc401f15 	stw	r17,124(sp)
811263b4:	008001c4 	movi	r2,7
811263b8:	14417416 	blt	r2,r17,8112698c <___svfprintf_internal_r+0x1588>
811263bc:	42000204 	addi	r8,r8,8
811263c0:	d8803817 	ldw	r2,224(sp)
811263c4:	d9003417 	ldw	r4,208(sp)
811263c8:	8c400044 	addi	r17,r17,1
811263cc:	10c7883a 	add	r3,r2,r3
811263d0:	40800115 	stw	r2,4(r8)
811263d4:	41000015 	stw	r4,0(r8)
811263d8:	d8c02015 	stw	r3,128(sp)
811263dc:	dc401f15 	stw	r17,124(sp)
811263e0:	008001c4 	movi	r2,7
811263e4:	14417216 	blt	r2,r17,811269b0 <___svfprintf_internal_r+0x15ac>
811263e8:	45800204 	addi	r22,r8,8
811263ec:	d9003617 	ldw	r4,216(sp)
811263f0:	d9403717 	ldw	r5,220(sp)
811263f4:	000d883a 	mov	r6,zero
811263f8:	000f883a 	mov	r7,zero
811263fc:	d8c03d15 	stw	r3,244(sp)
81126400:	1137cb80 	call	81137cb8 <__eqdf2>
81126404:	d8c03d17 	ldw	r3,244(sp)
81126408:	1000b326 	beq	r2,zero,811266d8 <___svfprintf_internal_r+0x12d4>
8112640c:	d9403317 	ldw	r5,204(sp)
81126410:	84000044 	addi	r16,r16,1
81126414:	8c400044 	addi	r17,r17,1
81126418:	28bfffc4 	addi	r2,r5,-1
8112641c:	1887883a 	add	r3,r3,r2
81126420:	b0800115 	stw	r2,4(r22)
81126424:	b4000015 	stw	r16,0(r22)
81126428:	d8c02015 	stw	r3,128(sp)
8112642c:	dc401f15 	stw	r17,124(sp)
81126430:	008001c4 	movi	r2,7
81126434:	1440d216 	blt	r2,r17,81126780 <___svfprintf_internal_r+0x137c>
81126438:	b5800204 	addi	r22,r22,8
8112643c:	d9003b17 	ldw	r4,236(sp)
81126440:	df0022c4 	addi	fp,sp,139
81126444:	8c400044 	addi	r17,r17,1
81126448:	20c7883a 	add	r3,r4,r3
8112644c:	b7000015 	stw	fp,0(r22)
81126450:	b1000115 	stw	r4,4(r22)
81126454:	d8c02015 	stw	r3,128(sp)
81126458:	dc401f15 	stw	r17,124(sp)
8112645c:	008001c4 	movi	r2,7
81126460:	14400e16 	blt	r2,r17,8112649c <___svfprintf_internal_r+0x1098>
81126464:	b2000204 	addi	r8,r22,8
81126468:	003e3c06 	br	81125d5c <__reset+0xfb105d5c>
8112646c:	01204574 	movhi	r4,33045
81126470:	21099884 	addi	r4,r4,9826
81126474:	d9002b15 	stw	r4,172(sp)
81126478:	d9002b17 	ldw	r4,172(sp)
8112647c:	1c07883a 	add	r3,r3,r16
81126480:	44000115 	stw	r16,4(r8)
81126484:	41000015 	stw	r4,0(r8)
81126488:	10800044 	addi	r2,r2,1
8112648c:	d8c02015 	stw	r3,128(sp)
81126490:	d8801f15 	stw	r2,124(sp)
81126494:	010001c4 	movi	r4,7
81126498:	20be2f0e 	bge	r4,r2,81125d58 <__reset+0xfb105d58>
8112649c:	d9402c17 	ldw	r5,176(sp)
811264a0:	d9801e04 	addi	r6,sp,120
811264a4:	9809883a 	mov	r4,r19
811264a8:	1131d3c0 	call	81131d3c <__ssprint_r>
811264ac:	103cbc1e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
811264b0:	d8c02017 	ldw	r3,128(sp)
811264b4:	da000404 	addi	r8,sp,16
811264b8:	003e2806 	br	81125d5c <__reset+0xfb105d5c>
811264bc:	d9402c17 	ldw	r5,176(sp)
811264c0:	d9801e04 	addi	r6,sp,120
811264c4:	9809883a 	mov	r4,r19
811264c8:	1131d3c0 	call	81131d3c <__ssprint_r>
811264cc:	103e5f26 	beq	r2,zero,81125e4c <__reset+0xfb105e4c>
811264d0:	003cb306 	br	811257a0 <__reset+0xfb1057a0>
811264d4:	d9402c17 	ldw	r5,176(sp)
811264d8:	d9801e04 	addi	r6,sp,120
811264dc:	9809883a 	mov	r4,r19
811264e0:	1131d3c0 	call	81131d3c <__ssprint_r>
811264e4:	103cae1e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
811264e8:	d8c02017 	ldw	r3,128(sp)
811264ec:	da000404 	addi	r8,sp,16
811264f0:	003e0d06 	br	81125d28 <__reset+0xfb105d28>
811264f4:	d9402c17 	ldw	r5,176(sp)
811264f8:	d9801e04 	addi	r6,sp,120
811264fc:	9809883a 	mov	r4,r19
81126500:	1131d3c0 	call	81131d3c <__ssprint_r>
81126504:	103ca61e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126508:	d8c02017 	ldw	r3,128(sp)
8112650c:	da000404 	addi	r8,sp,16
81126510:	003dc106 	br	81125c18 <__reset+0xfb105c18>
81126514:	d9402c17 	ldw	r5,176(sp)
81126518:	d9801e04 	addi	r6,sp,120
8112651c:	9809883a 	mov	r4,r19
81126520:	1131d3c0 	call	81131d3c <__ssprint_r>
81126524:	103c9e1e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126528:	d8c02017 	ldw	r3,128(sp)
8112652c:	da000404 	addi	r8,sp,16
81126530:	003dc706 	br	81125c50 <__reset+0xfb105c50>
81126534:	d8802917 	ldw	r2,164(sp)
81126538:	d8002785 	stb	zero,158(sp)
8112653c:	103f0816 	blt	r2,zero,81126160 <__reset+0xfb106160>
81126540:	00ffdfc4 	movi	r3,-129
81126544:	a584b03a 	or	r2,r20,r22
81126548:	90e4703a 	and	r18,r18,r3
8112654c:	103c8126 	beq	r2,zero,81125754 <__reset+0xfb105754>
81126550:	0039883a 	mov	fp,zero
81126554:	003e7606 	br	81125f30 <__reset+0xfb105f30>
81126558:	9080040c 	andi	r2,r18,16
8112655c:	10013d26 	beq	r2,zero,81126a54 <___svfprintf_internal_r+0x1650>
81126560:	d9002d17 	ldw	r4,180(sp)
81126564:	d9402917 	ldw	r5,164(sp)
81126568:	d8002785 	stb	zero,158(sp)
8112656c:	20800104 	addi	r2,r4,4
81126570:	25000017 	ldw	r20,0(r4)
81126574:	002d883a 	mov	r22,zero
81126578:	28013f16 	blt	r5,zero,81126a78 <___svfprintf_internal_r+0x1674>
8112657c:	00ffdfc4 	movi	r3,-129
81126580:	d8802d15 	stw	r2,180(sp)
81126584:	90e4703a 	and	r18,r18,r3
81126588:	a03d2b26 	beq	r20,zero,81125a38 <__reset+0xfb105a38>
8112658c:	0039883a 	mov	fp,zero
81126590:	003d2e06 	br	81125a4c <__reset+0xfb105a4c>
81126594:	dc402617 	ldw	r17,152(sp)
81126598:	0441830e 	bge	zero,r17,81126ba8 <___svfprintf_internal_r+0x17a4>
8112659c:	dc403217 	ldw	r17,200(sp)
811265a0:	d8803317 	ldw	r2,204(sp)
811265a4:	1440010e 	bge	r2,r17,811265ac <___svfprintf_internal_r+0x11a8>
811265a8:	1023883a 	mov	r17,r2
811265ac:	04400a0e 	bge	zero,r17,811265d8 <___svfprintf_internal_r+0x11d4>
811265b0:	d8801f17 	ldw	r2,124(sp)
811265b4:	1c47883a 	add	r3,r3,r17
811265b8:	44000015 	stw	r16,0(r8)
811265bc:	10800044 	addi	r2,r2,1
811265c0:	44400115 	stw	r17,4(r8)
811265c4:	d8c02015 	stw	r3,128(sp)
811265c8:	d8801f15 	stw	r2,124(sp)
811265cc:	010001c4 	movi	r4,7
811265d0:	20827516 	blt	r4,r2,81126fa8 <___svfprintf_internal_r+0x1ba4>
811265d4:	42000204 	addi	r8,r8,8
811265d8:	88027b16 	blt	r17,zero,81126fc8 <___svfprintf_internal_r+0x1bc4>
811265dc:	d9003217 	ldw	r4,200(sp)
811265e0:	2463c83a 	sub	r17,r4,r17
811265e4:	0440990e 	bge	zero,r17,8112684c <___svfprintf_internal_r+0x1448>
811265e8:	05800404 	movi	r22,16
811265ec:	d8801f17 	ldw	r2,124(sp)
811265f0:	b441530e 	bge	r22,r17,81126b40 <___svfprintf_internal_r+0x173c>
811265f4:	01204574 	movhi	r4,33045
811265f8:	21099884 	addi	r4,r4,9826
811265fc:	d9002b15 	stw	r4,172(sp)
81126600:	070001c4 	movi	fp,7
81126604:	dd002c17 	ldw	r20,176(sp)
81126608:	00000306 	br	81126618 <___svfprintf_internal_r+0x1214>
8112660c:	42000204 	addi	r8,r8,8
81126610:	8c7ffc04 	addi	r17,r17,-16
81126614:	b4414d0e 	bge	r22,r17,81126b4c <___svfprintf_internal_r+0x1748>
81126618:	18c00404 	addi	r3,r3,16
8112661c:	10800044 	addi	r2,r2,1
81126620:	45400015 	stw	r21,0(r8)
81126624:	45800115 	stw	r22,4(r8)
81126628:	d8c02015 	stw	r3,128(sp)
8112662c:	d8801f15 	stw	r2,124(sp)
81126630:	e0bff60e 	bge	fp,r2,8112660c <__reset+0xfb10660c>
81126634:	d9801e04 	addi	r6,sp,120
81126638:	a00b883a 	mov	r5,r20
8112663c:	9809883a 	mov	r4,r19
81126640:	1131d3c0 	call	81131d3c <__ssprint_r>
81126644:	103c561e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126648:	d8c02017 	ldw	r3,128(sp)
8112664c:	d8801f17 	ldw	r2,124(sp)
81126650:	da000404 	addi	r8,sp,16
81126654:	003fee06 	br	81126610 <__reset+0xfb106610>
81126658:	d9402c17 	ldw	r5,176(sp)
8112665c:	d9801e04 	addi	r6,sp,120
81126660:	9809883a 	mov	r4,r19
81126664:	1131d3c0 	call	81131d3c <__ssprint_r>
81126668:	103c4d1e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
8112666c:	d8c02017 	ldw	r3,128(sp)
81126670:	df002787 	ldb	fp,158(sp)
81126674:	da000404 	addi	r8,sp,16
81126678:	003d5a06 	br	81125be4 <__reset+0xfb105be4>
8112667c:	9080040c 	andi	r2,r18,16
81126680:	10005c26 	beq	r2,zero,811267f4 <___svfprintf_internal_r+0x13f0>
81126684:	d9402d17 	ldw	r5,180(sp)
81126688:	d8c02917 	ldw	r3,164(sp)
8112668c:	d8002785 	stb	zero,158(sp)
81126690:	28800104 	addi	r2,r5,4
81126694:	2d000017 	ldw	r20,0(r5)
81126698:	002d883a 	mov	r22,zero
8112669c:	18005e16 	blt	r3,zero,81126818 <___svfprintf_internal_r+0x1414>
811266a0:	00ffdfc4 	movi	r3,-129
811266a4:	d8802d15 	stw	r2,180(sp)
811266a8:	90e4703a 	and	r18,r18,r3
811266ac:	0039883a 	mov	fp,zero
811266b0:	a03dfe26 	beq	r20,zero,81125eac <__reset+0xfb105eac>
811266b4:	00800244 	movi	r2,9
811266b8:	153cb336 	bltu	r2,r20,81125988 <__reset+0xfb105988>
811266bc:	a5000c04 	addi	r20,r20,48
811266c0:	dc001dc4 	addi	r16,sp,119
811266c4:	dd001dc5 	stb	r20,119(sp)
811266c8:	d8c02817 	ldw	r3,160(sp)
811266cc:	1c07c83a 	sub	r3,r3,r16
811266d0:	d8c02e15 	stw	r3,184(sp)
811266d4:	003cf506 	br	81125aac <__reset+0xfb105aac>
811266d8:	d8803317 	ldw	r2,204(sp)
811266dc:	143fffc4 	addi	r16,r2,-1
811266e0:	043f560e 	bge	zero,r16,8112643c <__reset+0xfb10643c>
811266e4:	07000404 	movi	fp,16
811266e8:	e403530e 	bge	fp,r16,81127438 <___svfprintf_internal_r+0x2034>
811266ec:	01604574 	movhi	r5,33045
811266f0:	29499884 	addi	r5,r5,9826
811266f4:	d9402b15 	stw	r5,172(sp)
811266f8:	01c001c4 	movi	r7,7
811266fc:	dd002c17 	ldw	r20,176(sp)
81126700:	00000306 	br	81126710 <___svfprintf_internal_r+0x130c>
81126704:	843ffc04 	addi	r16,r16,-16
81126708:	b5800204 	addi	r22,r22,8
8112670c:	e400130e 	bge	fp,r16,8112675c <___svfprintf_internal_r+0x1358>
81126710:	18c00404 	addi	r3,r3,16
81126714:	8c400044 	addi	r17,r17,1
81126718:	b5400015 	stw	r21,0(r22)
8112671c:	b7000115 	stw	fp,4(r22)
81126720:	d8c02015 	stw	r3,128(sp)
81126724:	dc401f15 	stw	r17,124(sp)
81126728:	3c7ff60e 	bge	r7,r17,81126704 <__reset+0xfb106704>
8112672c:	d9801e04 	addi	r6,sp,120
81126730:	a00b883a 	mov	r5,r20
81126734:	9809883a 	mov	r4,r19
81126738:	d9c03d15 	stw	r7,244(sp)
8112673c:	1131d3c0 	call	81131d3c <__ssprint_r>
81126740:	d9c03d17 	ldw	r7,244(sp)
81126744:	103c161e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126748:	843ffc04 	addi	r16,r16,-16
8112674c:	d8c02017 	ldw	r3,128(sp)
81126750:	dc401f17 	ldw	r17,124(sp)
81126754:	dd800404 	addi	r22,sp,16
81126758:	e43fed16 	blt	fp,r16,81126710 <__reset+0xfb106710>
8112675c:	d8802b17 	ldw	r2,172(sp)
81126760:	1c07883a 	add	r3,r3,r16
81126764:	8c400044 	addi	r17,r17,1
81126768:	b0800015 	stw	r2,0(r22)
8112676c:	b4000115 	stw	r16,4(r22)
81126770:	d8c02015 	stw	r3,128(sp)
81126774:	dc401f15 	stw	r17,124(sp)
81126778:	008001c4 	movi	r2,7
8112677c:	147f2e0e 	bge	r2,r17,81126438 <__reset+0xfb106438>
81126780:	d9402c17 	ldw	r5,176(sp)
81126784:	d9801e04 	addi	r6,sp,120
81126788:	9809883a 	mov	r4,r19
8112678c:	1131d3c0 	call	81131d3c <__ssprint_r>
81126790:	103c031e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126794:	d8c02017 	ldw	r3,128(sp)
81126798:	dc401f17 	ldw	r17,124(sp)
8112679c:	dd800404 	addi	r22,sp,16
811267a0:	003f2606 	br	8112643c <__reset+0xfb10643c>
811267a4:	9080040c 	andi	r2,r18,16
811267a8:	1000c326 	beq	r2,zero,81126ab8 <___svfprintf_internal_r+0x16b4>
811267ac:	d8802d17 	ldw	r2,180(sp)
811267b0:	15000017 	ldw	r20,0(r2)
811267b4:	10800104 	addi	r2,r2,4
811267b8:	d8802d15 	stw	r2,180(sp)
811267bc:	a02dd7fa 	srai	r22,r20,31
811267c0:	b005883a 	mov	r2,r22
811267c4:	103c680e 	bge	r2,zero,81125968 <__reset+0xfb105968>
811267c8:	0529c83a 	sub	r20,zero,r20
811267cc:	a004c03a 	cmpne	r2,r20,zero
811267d0:	05adc83a 	sub	r22,zero,r22
811267d4:	b0adc83a 	sub	r22,r22,r2
811267d8:	d8802917 	ldw	r2,164(sp)
811267dc:	07000b44 	movi	fp,45
811267e0:	df002785 	stb	fp,158(sp)
811267e4:	10022e16 	blt	r2,zero,811270a0 <___svfprintf_internal_r+0x1c9c>
811267e8:	00bfdfc4 	movi	r2,-129
811267ec:	90a4703a 	and	r18,r18,r2
811267f0:	003c6406 	br	81125984 <__reset+0xfb105984>
811267f4:	9080100c 	andi	r2,r18,64
811267f8:	d8002785 	stb	zero,158(sp)
811267fc:	10012526 	beq	r2,zero,81126c94 <___svfprintf_internal_r+0x1890>
81126800:	d9002d17 	ldw	r4,180(sp)
81126804:	d9402917 	ldw	r5,164(sp)
81126808:	002d883a 	mov	r22,zero
8112680c:	20800104 	addi	r2,r4,4
81126810:	2500000b 	ldhu	r20,0(r4)
81126814:	283fa20e 	bge	r5,zero,811266a0 <__reset+0xfb1066a0>
81126818:	d8802d15 	stw	r2,180(sp)
8112681c:	0039883a 	mov	fp,zero
81126820:	a584b03a 	or	r2,r20,r22
81126824:	103c571e 	bne	r2,zero,81125984 <__reset+0xfb105984>
81126828:	00800044 	movi	r2,1
8112682c:	003e5006 	br	81126170 <__reset+0xfb106170>
81126830:	d9402c17 	ldw	r5,176(sp)
81126834:	d9801e04 	addi	r6,sp,120
81126838:	9809883a 	mov	r4,r19
8112683c:	1131d3c0 	call	81131d3c <__ssprint_r>
81126840:	103bd71e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126844:	d8c02017 	ldw	r3,128(sp)
81126848:	da000404 	addi	r8,sp,16
8112684c:	d9003217 	ldw	r4,200(sp)
81126850:	d8802617 	ldw	r2,152(sp)
81126854:	d9403317 	ldw	r5,204(sp)
81126858:	8123883a 	add	r17,r16,r4
8112685c:	11400216 	blt	r2,r5,81126868 <___svfprintf_internal_r+0x1464>
81126860:	9100004c 	andi	r4,r18,1
81126864:	20000d26 	beq	r4,zero,8112689c <___svfprintf_internal_r+0x1498>
81126868:	d9003817 	ldw	r4,224(sp)
8112686c:	d9403417 	ldw	r5,208(sp)
81126870:	1907883a 	add	r3,r3,r4
81126874:	d9001f17 	ldw	r4,124(sp)
81126878:	41400015 	stw	r5,0(r8)
8112687c:	d9403817 	ldw	r5,224(sp)
81126880:	21000044 	addi	r4,r4,1
81126884:	d8c02015 	stw	r3,128(sp)
81126888:	41400115 	stw	r5,4(r8)
8112688c:	d9001f15 	stw	r4,124(sp)
81126890:	014001c4 	movi	r5,7
81126894:	2901dc16 	blt	r5,r4,81127008 <___svfprintf_internal_r+0x1c04>
81126898:	42000204 	addi	r8,r8,8
8112689c:	d9003317 	ldw	r4,204(sp)
811268a0:	8121883a 	add	r16,r16,r4
811268a4:	2085c83a 	sub	r2,r4,r2
811268a8:	8461c83a 	sub	r16,r16,r17
811268ac:	1400010e 	bge	r2,r16,811268b4 <___svfprintf_internal_r+0x14b0>
811268b0:	1021883a 	mov	r16,r2
811268b4:	04000a0e 	bge	zero,r16,811268e0 <___svfprintf_internal_r+0x14dc>
811268b8:	d9001f17 	ldw	r4,124(sp)
811268bc:	1c07883a 	add	r3,r3,r16
811268c0:	44400015 	stw	r17,0(r8)
811268c4:	21000044 	addi	r4,r4,1
811268c8:	44000115 	stw	r16,4(r8)
811268cc:	d8c02015 	stw	r3,128(sp)
811268d0:	d9001f15 	stw	r4,124(sp)
811268d4:	014001c4 	movi	r5,7
811268d8:	2901e616 	blt	r5,r4,81127074 <___svfprintf_internal_r+0x1c70>
811268dc:	42000204 	addi	r8,r8,8
811268e0:	8001f616 	blt	r16,zero,811270bc <___svfprintf_internal_r+0x1cb8>
811268e4:	1421c83a 	sub	r16,r2,r16
811268e8:	043d1c0e 	bge	zero,r16,81125d5c <__reset+0xfb105d5c>
811268ec:	04400404 	movi	r17,16
811268f0:	d8801f17 	ldw	r2,124(sp)
811268f4:	8c3edd0e 	bge	r17,r16,8112646c <__reset+0xfb10646c>
811268f8:	01604574 	movhi	r5,33045
811268fc:	29499884 	addi	r5,r5,9826
81126900:	d9402b15 	stw	r5,172(sp)
81126904:	058001c4 	movi	r22,7
81126908:	dd002c17 	ldw	r20,176(sp)
8112690c:	00000306 	br	8112691c <___svfprintf_internal_r+0x1518>
81126910:	42000204 	addi	r8,r8,8
81126914:	843ffc04 	addi	r16,r16,-16
81126918:	8c3ed70e 	bge	r17,r16,81126478 <__reset+0xfb106478>
8112691c:	18c00404 	addi	r3,r3,16
81126920:	10800044 	addi	r2,r2,1
81126924:	45400015 	stw	r21,0(r8)
81126928:	44400115 	stw	r17,4(r8)
8112692c:	d8c02015 	stw	r3,128(sp)
81126930:	d8801f15 	stw	r2,124(sp)
81126934:	b0bff60e 	bge	r22,r2,81126910 <__reset+0xfb106910>
81126938:	d9801e04 	addi	r6,sp,120
8112693c:	a00b883a 	mov	r5,r20
81126940:	9809883a 	mov	r4,r19
81126944:	1131d3c0 	call	81131d3c <__ssprint_r>
81126948:	103b951e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
8112694c:	d8c02017 	ldw	r3,128(sp)
81126950:	d8801f17 	ldw	r2,124(sp)
81126954:	da000404 	addi	r8,sp,16
81126958:	003fee06 	br	81126914 <__reset+0xfb106914>
8112695c:	9088703a 	and	r4,r18,r2
81126960:	203e8d1e 	bne	r4,zero,81126398 <__reset+0xfb106398>
81126964:	dc401f17 	ldw	r17,124(sp)
81126968:	40800115 	stw	r2,4(r8)
8112696c:	44000015 	stw	r16,0(r8)
81126970:	8c400044 	addi	r17,r17,1
81126974:	d8c02015 	stw	r3,128(sp)
81126978:	dc401f15 	stw	r17,124(sp)
8112697c:	008001c4 	movi	r2,7
81126980:	147f7f16 	blt	r2,r17,81126780 <__reset+0xfb106780>
81126984:	45800204 	addi	r22,r8,8
81126988:	003eac06 	br	8112643c <__reset+0xfb10643c>
8112698c:	d9402c17 	ldw	r5,176(sp)
81126990:	d9801e04 	addi	r6,sp,120
81126994:	9809883a 	mov	r4,r19
81126998:	1131d3c0 	call	81131d3c <__ssprint_r>
8112699c:	103b801e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
811269a0:	d8c02017 	ldw	r3,128(sp)
811269a4:	dc401f17 	ldw	r17,124(sp)
811269a8:	da000404 	addi	r8,sp,16
811269ac:	003e8406 	br	811263c0 <__reset+0xfb1063c0>
811269b0:	d9402c17 	ldw	r5,176(sp)
811269b4:	d9801e04 	addi	r6,sp,120
811269b8:	9809883a 	mov	r4,r19
811269bc:	1131d3c0 	call	81131d3c <__ssprint_r>
811269c0:	103b771e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
811269c4:	d8c02017 	ldw	r3,128(sp)
811269c8:	dc401f17 	ldw	r17,124(sp)
811269cc:	dd800404 	addi	r22,sp,16
811269d0:	003e8606 	br	811263ec <__reset+0xfb1063ec>
811269d4:	0029883a 	mov	r20,zero
811269d8:	a5000c04 	addi	r20,r20,48
811269dc:	dc001dc4 	addi	r16,sp,119
811269e0:	dd001dc5 	stb	r20,119(sp)
811269e4:	003f3806 	br	811266c8 <__reset+0xfb1066c8>
811269e8:	d9402c17 	ldw	r5,176(sp)
811269ec:	d9801e04 	addi	r6,sp,120
811269f0:	9809883a 	mov	r4,r19
811269f4:	1131d3c0 	call	81131d3c <__ssprint_r>
811269f8:	103b691e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
811269fc:	d8c02017 	ldw	r3,128(sp)
81126a00:	da000404 	addi	r8,sp,16
81126a04:	003c9506 	br	81125c5c <__reset+0xfb105c5c>
81126a08:	d9003617 	ldw	r4,216(sp)
81126a0c:	d9403717 	ldw	r5,220(sp)
81126a10:	da003e15 	stw	r8,248(sp)
81126a14:	112fe380 	call	8112fe38 <__fpclassifyd>
81126a18:	da003e17 	ldw	r8,248(sp)
81126a1c:	1000bd1e 	bne	r2,zero,81126d14 <___svfprintf_internal_r+0x1910>
81126a20:	008011c4 	movi	r2,71
81126a24:	14411e0e 	bge	r2,r17,81126ea0 <___svfprintf_internal_r+0x1a9c>
81126a28:	04204574 	movhi	r16,33045
81126a2c:	84098b04 	addi	r16,r16,9772
81126a30:	00c000c4 	movi	r3,3
81126a34:	00bfdfc4 	movi	r2,-129
81126a38:	d8c02a15 	stw	r3,168(sp)
81126a3c:	90a4703a 	and	r18,r18,r2
81126a40:	df002783 	ldbu	fp,158(sp)
81126a44:	d8c02e15 	stw	r3,184(sp)
81126a48:	d8002915 	stw	zero,164(sp)
81126a4c:	d8003215 	stw	zero,200(sp)
81126a50:	003c1c06 	br	81125ac4 <__reset+0xfb105ac4>
81126a54:	9080100c 	andi	r2,r18,64
81126a58:	d8002785 	stb	zero,158(sp)
81126a5c:	10009426 	beq	r2,zero,81126cb0 <___svfprintf_internal_r+0x18ac>
81126a60:	d8c02d17 	ldw	r3,180(sp)
81126a64:	d9002917 	ldw	r4,164(sp)
81126a68:	002d883a 	mov	r22,zero
81126a6c:	18800104 	addi	r2,r3,4
81126a70:	1d00000b 	ldhu	r20,0(r3)
81126a74:	203ec10e 	bge	r4,zero,8112657c <__reset+0xfb10657c>
81126a78:	a586b03a 	or	r3,r20,r22
81126a7c:	d8802d15 	stw	r2,180(sp)
81126a80:	183ec21e 	bne	r3,zero,8112658c <__reset+0xfb10658c>
81126a84:	0039883a 	mov	fp,zero
81126a88:	0005883a 	mov	r2,zero
81126a8c:	003db806 	br	81126170 <__reset+0xfb106170>
81126a90:	d8802d17 	ldw	r2,180(sp)
81126a94:	d8c02d17 	ldw	r3,180(sp)
81126a98:	d9002d17 	ldw	r4,180(sp)
81126a9c:	10800017 	ldw	r2,0(r2)
81126aa0:	18c00117 	ldw	r3,4(r3)
81126aa4:	21000204 	addi	r4,r4,8
81126aa8:	d8803615 	stw	r2,216(sp)
81126aac:	d8c03715 	stw	r3,220(sp)
81126ab0:	d9002d15 	stw	r4,180(sp)
81126ab4:	003b8206 	br	811258c0 <__reset+0xfb1058c0>
81126ab8:	9080100c 	andi	r2,r18,64
81126abc:	10010726 	beq	r2,zero,81126edc <___svfprintf_internal_r+0x1ad8>
81126ac0:	d8c02d17 	ldw	r3,180(sp)
81126ac4:	1d00000f 	ldh	r20,0(r3)
81126ac8:	18c00104 	addi	r3,r3,4
81126acc:	d8c02d15 	stw	r3,180(sp)
81126ad0:	a02dd7fa 	srai	r22,r20,31
81126ad4:	b005883a 	mov	r2,r22
81126ad8:	003ba206 	br	81125964 <__reset+0xfb105964>
81126adc:	9080100c 	andi	r2,r18,64
81126ae0:	10010526 	beq	r2,zero,81126ef8 <___svfprintf_internal_r+0x1af4>
81126ae4:	d9002d17 	ldw	r4,180(sp)
81126ae8:	002d883a 	mov	r22,zero
81126aec:	2500000b 	ldhu	r20,0(r4)
81126af0:	21000104 	addi	r4,r4,4
81126af4:	d9002d15 	stw	r4,180(sp)
81126af8:	003cfe06 	br	81125ef4 <__reset+0xfb105ef4>
81126afc:	bc400007 	ldb	r17,0(r23)
81126b00:	003a9606 	br	8112555c <__reset+0xfb10555c>
81126b04:	9080040c 	andi	r2,r18,16
81126b08:	10010126 	beq	r2,zero,81126f10 <___svfprintf_internal_r+0x1b0c>
81126b0c:	d9402d17 	ldw	r5,180(sp)
81126b10:	d8c02f17 	ldw	r3,188(sp)
81126b14:	28800017 	ldw	r2,0(r5)
81126b18:	29400104 	addi	r5,r5,4
81126b1c:	d9402d15 	stw	r5,180(sp)
81126b20:	10c00015 	stw	r3,0(r2)
81126b24:	003a6406 	br	811254b8 <__reset+0xfb1054b8>
81126b28:	d9002917 	ldw	r4,164(sp)
81126b2c:	d8002785 	stb	zero,158(sp)
81126b30:	203d8d16 	blt	r4,zero,81126168 <__reset+0xfb106168>
81126b34:	00bfdfc4 	movi	r2,-129
81126b38:	90a4703a 	and	r18,r18,r2
81126b3c:	003b0506 	br	81125754 <__reset+0xfb105754>
81126b40:	01604574 	movhi	r5,33045
81126b44:	29499884 	addi	r5,r5,9826
81126b48:	d9402b15 	stw	r5,172(sp)
81126b4c:	d9402b17 	ldw	r5,172(sp)
81126b50:	1c47883a 	add	r3,r3,r17
81126b54:	10800044 	addi	r2,r2,1
81126b58:	41400015 	stw	r5,0(r8)
81126b5c:	44400115 	stw	r17,4(r8)
81126b60:	d8c02015 	stw	r3,128(sp)
81126b64:	d8801f15 	stw	r2,124(sp)
81126b68:	010001c4 	movi	r4,7
81126b6c:	20bf3016 	blt	r4,r2,81126830 <__reset+0xfb106830>
81126b70:	42000204 	addi	r8,r8,8
81126b74:	003f3506 	br	8112684c <__reset+0xfb10684c>
81126b78:	01204574 	movhi	r4,33045
81126b7c:	21099884 	addi	r4,r4,9826
81126b80:	d9002b15 	stw	r4,172(sp)
81126b84:	003c5e06 	br	81125d00 <__reset+0xfb105d00>
81126b88:	d9402c17 	ldw	r5,176(sp)
81126b8c:	d9801e04 	addi	r6,sp,120
81126b90:	9809883a 	mov	r4,r19
81126b94:	1131d3c0 	call	81131d3c <__ssprint_r>
81126b98:	103b011e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126b9c:	d8c02017 	ldw	r3,128(sp)
81126ba0:	da000404 	addi	r8,sp,16
81126ba4:	003d9306 	br	811261f4 <__reset+0xfb1061f4>
81126ba8:	d8801f17 	ldw	r2,124(sp)
81126bac:	01604574 	movhi	r5,33045
81126bb0:	01000044 	movi	r4,1
81126bb4:	18c00044 	addi	r3,r3,1
81126bb8:	10800044 	addi	r2,r2,1
81126bbc:	29499804 	addi	r5,r5,9824
81126bc0:	41000115 	stw	r4,4(r8)
81126bc4:	41400015 	stw	r5,0(r8)
81126bc8:	d8c02015 	stw	r3,128(sp)
81126bcc:	d8801f15 	stw	r2,124(sp)
81126bd0:	010001c4 	movi	r4,7
81126bd4:	2080b516 	blt	r4,r2,81126eac <___svfprintf_internal_r+0x1aa8>
81126bd8:	42000204 	addi	r8,r8,8
81126bdc:	8800041e 	bne	r17,zero,81126bf0 <___svfprintf_internal_r+0x17ec>
81126be0:	d8803317 	ldw	r2,204(sp)
81126be4:	1000021e 	bne	r2,zero,81126bf0 <___svfprintf_internal_r+0x17ec>
81126be8:	9080004c 	andi	r2,r18,1
81126bec:	103c5b26 	beq	r2,zero,81125d5c <__reset+0xfb105d5c>
81126bf0:	d9003817 	ldw	r4,224(sp)
81126bf4:	d8801f17 	ldw	r2,124(sp)
81126bf8:	d9403417 	ldw	r5,208(sp)
81126bfc:	20c7883a 	add	r3,r4,r3
81126c00:	10800044 	addi	r2,r2,1
81126c04:	41000115 	stw	r4,4(r8)
81126c08:	41400015 	stw	r5,0(r8)
81126c0c:	d8c02015 	stw	r3,128(sp)
81126c10:	d8801f15 	stw	r2,124(sp)
81126c14:	010001c4 	movi	r4,7
81126c18:	20818016 	blt	r4,r2,8112721c <___svfprintf_internal_r+0x1e18>
81126c1c:	42000204 	addi	r8,r8,8
81126c20:	0463c83a 	sub	r17,zero,r17
81126c24:	0440cb0e 	bge	zero,r17,81126f54 <___svfprintf_internal_r+0x1b50>
81126c28:	05800404 	movi	r22,16
81126c2c:	b440e80e 	bge	r22,r17,81126fd0 <___svfprintf_internal_r+0x1bcc>
81126c30:	01604574 	movhi	r5,33045
81126c34:	29499884 	addi	r5,r5,9826
81126c38:	d9402b15 	stw	r5,172(sp)
81126c3c:	070001c4 	movi	fp,7
81126c40:	dd002c17 	ldw	r20,176(sp)
81126c44:	00000306 	br	81126c54 <___svfprintf_internal_r+0x1850>
81126c48:	42000204 	addi	r8,r8,8
81126c4c:	8c7ffc04 	addi	r17,r17,-16
81126c50:	b440e20e 	bge	r22,r17,81126fdc <___svfprintf_internal_r+0x1bd8>
81126c54:	18c00404 	addi	r3,r3,16
81126c58:	10800044 	addi	r2,r2,1
81126c5c:	45400015 	stw	r21,0(r8)
81126c60:	45800115 	stw	r22,4(r8)
81126c64:	d8c02015 	stw	r3,128(sp)
81126c68:	d8801f15 	stw	r2,124(sp)
81126c6c:	e0bff60e 	bge	fp,r2,81126c48 <__reset+0xfb106c48>
81126c70:	d9801e04 	addi	r6,sp,120
81126c74:	a00b883a 	mov	r5,r20
81126c78:	9809883a 	mov	r4,r19
81126c7c:	1131d3c0 	call	81131d3c <__ssprint_r>
81126c80:	103ac71e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126c84:	d8c02017 	ldw	r3,128(sp)
81126c88:	d8801f17 	ldw	r2,124(sp)
81126c8c:	da000404 	addi	r8,sp,16
81126c90:	003fee06 	br	81126c4c <__reset+0xfb106c4c>
81126c94:	d8c02d17 	ldw	r3,180(sp)
81126c98:	d9002917 	ldw	r4,164(sp)
81126c9c:	002d883a 	mov	r22,zero
81126ca0:	18800104 	addi	r2,r3,4
81126ca4:	1d000017 	ldw	r20,0(r3)
81126ca8:	203e7d0e 	bge	r4,zero,811266a0 <__reset+0xfb1066a0>
81126cac:	003eda06 	br	81126818 <__reset+0xfb106818>
81126cb0:	d9402d17 	ldw	r5,180(sp)
81126cb4:	d8c02917 	ldw	r3,164(sp)
81126cb8:	002d883a 	mov	r22,zero
81126cbc:	28800104 	addi	r2,r5,4
81126cc0:	2d000017 	ldw	r20,0(r5)
81126cc4:	183e2d0e 	bge	r3,zero,8112657c <__reset+0xfb10657c>
81126cc8:	003f6b06 	br	81126a78 <__reset+0xfb106a78>
81126ccc:	d8c02d15 	stw	r3,180(sp)
81126cd0:	0039883a 	mov	fp,zero
81126cd4:	003ed206 	br	81126820 <__reset+0xfb106820>
81126cd8:	bc400043 	ldbu	r17,1(r23)
81126cdc:	94800814 	ori	r18,r18,32
81126ce0:	bdc00044 	addi	r23,r23,1
81126ce4:	8c403fcc 	andi	r17,r17,255
81126ce8:	8c40201c 	xori	r17,r17,128
81126cec:	8c7fe004 	addi	r17,r17,-128
81126cf0:	003a1a06 	br	8112555c <__reset+0xfb10555c>
81126cf4:	d9402c17 	ldw	r5,176(sp)
81126cf8:	d9801e04 	addi	r6,sp,120
81126cfc:	9809883a 	mov	r4,r19
81126d00:	1131d3c0 	call	81131d3c <__ssprint_r>
81126d04:	103aa61e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126d08:	d8c02017 	ldw	r3,128(sp)
81126d0c:	da000404 	addi	r8,sp,16
81126d10:	003d4a06 	br	8112623c <__reset+0xfb10623c>
81126d14:	d9002917 	ldw	r4,164(sp)
81126d18:	05bff7c4 	movi	r22,-33
81126d1c:	00bfffc4 	movi	r2,-1
81126d20:	8dac703a 	and	r22,r17,r22
81126d24:	20806a26 	beq	r4,r2,81126ed0 <___svfprintf_internal_r+0x1acc>
81126d28:	008011c4 	movi	r2,71
81126d2c:	b0813726 	beq	r22,r2,8112720c <___svfprintf_internal_r+0x1e08>
81126d30:	d9003717 	ldw	r4,220(sp)
81126d34:	90c04014 	ori	r3,r18,256
81126d38:	d8c02b15 	stw	r3,172(sp)
81126d3c:	20015d16 	blt	r4,zero,811272b4 <___svfprintf_internal_r+0x1eb0>
81126d40:	dd003717 	ldw	r20,220(sp)
81126d44:	d8002a05 	stb	zero,168(sp)
81126d48:	00801984 	movi	r2,102
81126d4c:	88814026 	beq	r17,r2,81127250 <___svfprintf_internal_r+0x1e4c>
81126d50:	00801184 	movi	r2,70
81126d54:	88817126 	beq	r17,r2,8112731c <___svfprintf_internal_r+0x1f18>
81126d58:	00801144 	movi	r2,69
81126d5c:	b0816226 	beq	r22,r2,811272e8 <___svfprintf_internal_r+0x1ee4>
81126d60:	d8c02917 	ldw	r3,164(sp)
81126d64:	d8802104 	addi	r2,sp,132
81126d68:	d8800315 	stw	r2,12(sp)
81126d6c:	d9403617 	ldw	r5,216(sp)
81126d70:	d8802504 	addi	r2,sp,148
81126d74:	d8800215 	stw	r2,8(sp)
81126d78:	d8802604 	addi	r2,sp,152
81126d7c:	d8c00015 	stw	r3,0(sp)
81126d80:	d8800115 	stw	r2,4(sp)
81126d84:	01c00084 	movi	r7,2
81126d88:	a00d883a 	mov	r6,r20
81126d8c:	9809883a 	mov	r4,r19
81126d90:	d8c03d15 	stw	r3,244(sp)
81126d94:	da003e15 	stw	r8,248(sp)
81126d98:	112b6f00 	call	8112b6f0 <_dtoa_r>
81126d9c:	1021883a 	mov	r16,r2
81126da0:	008019c4 	movi	r2,103
81126da4:	d8c03d17 	ldw	r3,244(sp)
81126da8:	da003e17 	ldw	r8,248(sp)
81126dac:	8880e726 	beq	r17,r2,8112714c <___svfprintf_internal_r+0x1d48>
81126db0:	008011c4 	movi	r2,71
81126db4:	8880d426 	beq	r17,r2,81127108 <___svfprintf_internal_r+0x1d04>
81126db8:	80f9883a 	add	fp,r16,r3
81126dbc:	d9003617 	ldw	r4,216(sp)
81126dc0:	000d883a 	mov	r6,zero
81126dc4:	000f883a 	mov	r7,zero
81126dc8:	a00b883a 	mov	r5,r20
81126dcc:	da003e15 	stw	r8,248(sp)
81126dd0:	1137cb80 	call	81137cb8 <__eqdf2>
81126dd4:	da003e17 	ldw	r8,248(sp)
81126dd8:	1000e426 	beq	r2,zero,8112716c <___svfprintf_internal_r+0x1d68>
81126ddc:	d8802117 	ldw	r2,132(sp)
81126de0:	1700062e 	bgeu	r2,fp,81126dfc <___svfprintf_internal_r+0x19f8>
81126de4:	01000c04 	movi	r4,48
81126de8:	10c00044 	addi	r3,r2,1
81126dec:	d8c02115 	stw	r3,132(sp)
81126df0:	11000005 	stb	r4,0(r2)
81126df4:	d8802117 	ldw	r2,132(sp)
81126df8:	173ffb36 	bltu	r2,fp,81126de8 <__reset+0xfb106de8>
81126dfc:	1405c83a 	sub	r2,r2,r16
81126e00:	d8803315 	stw	r2,204(sp)
81126e04:	008011c4 	movi	r2,71
81126e08:	b080c526 	beq	r22,r2,81127120 <___svfprintf_internal_r+0x1d1c>
81126e0c:	00801944 	movi	r2,101
81126e10:	1441d90e 	bge	r2,r17,81127578 <___svfprintf_internal_r+0x2174>
81126e14:	d8c02617 	ldw	r3,152(sp)
81126e18:	00801984 	movi	r2,102
81126e1c:	d8c03215 	stw	r3,200(sp)
81126e20:	88813426 	beq	r17,r2,811272f4 <___svfprintf_internal_r+0x1ef0>
81126e24:	d8c03217 	ldw	r3,200(sp)
81126e28:	d9003317 	ldw	r4,204(sp)
81126e2c:	19012516 	blt	r3,r4,811272c4 <___svfprintf_internal_r+0x1ec0>
81126e30:	9480004c 	andi	r18,r18,1
81126e34:	9001841e 	bne	r18,zero,81127448 <___svfprintf_internal_r+0x2044>
81126e38:	1805883a 	mov	r2,r3
81126e3c:	1801cc16 	blt	r3,zero,81127570 <___svfprintf_internal_r+0x216c>
81126e40:	d8c03217 	ldw	r3,200(sp)
81126e44:	044019c4 	movi	r17,103
81126e48:	d8c02e15 	stw	r3,184(sp)
81126e4c:	df002a07 	ldb	fp,168(sp)
81126e50:	e000a61e 	bne	fp,zero,811270ec <___svfprintf_internal_r+0x1ce8>
81126e54:	df002783 	ldbu	fp,158(sp)
81126e58:	d8802a15 	stw	r2,168(sp)
81126e5c:	dc802b17 	ldw	r18,172(sp)
81126e60:	d8002915 	stw	zero,164(sp)
81126e64:	003b1706 	br	81125ac4 <__reset+0xfb105ac4>
81126e68:	04204574 	movhi	r16,33045
81126e6c:	84098804 	addi	r16,r16,9760
81126e70:	003aa606 	br	8112590c <__reset+0xfb10590c>
81126e74:	d9003917 	ldw	r4,228(sp)
81126e78:	04001004 	movi	r16,64
81126e7c:	800b883a 	mov	r5,r16
81126e80:	1123b3c0 	call	81123b3c <_malloc_r>
81126e84:	d9002c17 	ldw	r4,176(sp)
81126e88:	20800015 	stw	r2,0(r4)
81126e8c:	20800415 	stw	r2,16(r4)
81126e90:	1001cb26 	beq	r2,zero,811275c0 <___svfprintf_internal_r+0x21bc>
81126e94:	d8802c17 	ldw	r2,176(sp)
81126e98:	14000515 	stw	r16,20(r2)
81126e9c:	00397606 	br	81125478 <__reset+0xfb105478>
81126ea0:	04204574 	movhi	r16,33045
81126ea4:	84098a04 	addi	r16,r16,9768
81126ea8:	003ee106 	br	81126a30 <__reset+0xfb106a30>
81126eac:	d9402c17 	ldw	r5,176(sp)
81126eb0:	d9801e04 	addi	r6,sp,120
81126eb4:	9809883a 	mov	r4,r19
81126eb8:	1131d3c0 	call	81131d3c <__ssprint_r>
81126ebc:	103a381e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126ec0:	dc402617 	ldw	r17,152(sp)
81126ec4:	d8c02017 	ldw	r3,128(sp)
81126ec8:	da000404 	addi	r8,sp,16
81126ecc:	003f4306 	br	81126bdc <__reset+0xfb106bdc>
81126ed0:	01400184 	movi	r5,6
81126ed4:	d9402915 	stw	r5,164(sp)
81126ed8:	003f9506 	br	81126d30 <__reset+0xfb106d30>
81126edc:	d9002d17 	ldw	r4,180(sp)
81126ee0:	25000017 	ldw	r20,0(r4)
81126ee4:	21000104 	addi	r4,r4,4
81126ee8:	d9002d15 	stw	r4,180(sp)
81126eec:	a02dd7fa 	srai	r22,r20,31
81126ef0:	b005883a 	mov	r2,r22
81126ef4:	003a9b06 	br	81125964 <__reset+0xfb105964>
81126ef8:	d9402d17 	ldw	r5,180(sp)
81126efc:	002d883a 	mov	r22,zero
81126f00:	2d000017 	ldw	r20,0(r5)
81126f04:	29400104 	addi	r5,r5,4
81126f08:	d9402d15 	stw	r5,180(sp)
81126f0c:	003bf906 	br	81125ef4 <__reset+0xfb105ef4>
81126f10:	9480100c 	andi	r18,r18,64
81126f14:	90006e26 	beq	r18,zero,811270d0 <___svfprintf_internal_r+0x1ccc>
81126f18:	d9002d17 	ldw	r4,180(sp)
81126f1c:	d9402f17 	ldw	r5,188(sp)
81126f20:	20800017 	ldw	r2,0(r4)
81126f24:	21000104 	addi	r4,r4,4
81126f28:	d9002d15 	stw	r4,180(sp)
81126f2c:	1140000d 	sth	r5,0(r2)
81126f30:	00396106 	br	811254b8 <__reset+0xfb1054b8>
81126f34:	d9402c17 	ldw	r5,176(sp)
81126f38:	d9801e04 	addi	r6,sp,120
81126f3c:	9809883a 	mov	r4,r19
81126f40:	1131d3c0 	call	81131d3c <__ssprint_r>
81126f44:	103a161e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126f48:	d8c02017 	ldw	r3,128(sp)
81126f4c:	d8801f17 	ldw	r2,124(sp)
81126f50:	da000404 	addi	r8,sp,16
81126f54:	d9403317 	ldw	r5,204(sp)
81126f58:	10800044 	addi	r2,r2,1
81126f5c:	44000015 	stw	r16,0(r8)
81126f60:	28c7883a 	add	r3,r5,r3
81126f64:	003b7706 	br	81125d44 <__reset+0xfb105d44>
81126f68:	8009883a 	mov	r4,r16
81126f6c:	da003e15 	stw	r8,248(sp)
81126f70:	1124dc80 	call	81124dc8 <strlen>
81126f74:	d8802e15 	stw	r2,184(sp)
81126f78:	da003e17 	ldw	r8,248(sp)
81126f7c:	103c280e 	bge	r2,zero,81126020 <__reset+0xfb106020>
81126f80:	0005883a 	mov	r2,zero
81126f84:	003c2606 	br	81126020 <__reset+0xfb106020>
81126f88:	00bfffc4 	movi	r2,-1
81126f8c:	003a0906 	br	811257b4 <__reset+0xfb1057b4>
81126f90:	01204574 	movhi	r4,33045
81126f94:	21099c84 	addi	r4,r4,9842
81126f98:	d9003515 	stw	r4,212(sp)
81126f9c:	003b0606 	br	81125bb8 <__reset+0xfb105bb8>
81126fa0:	013fffc4 	movi	r4,-1
81126fa4:	003a2706 	br	81125844 <__reset+0xfb105844>
81126fa8:	d9402c17 	ldw	r5,176(sp)
81126fac:	d9801e04 	addi	r6,sp,120
81126fb0:	9809883a 	mov	r4,r19
81126fb4:	1131d3c0 	call	81131d3c <__ssprint_r>
81126fb8:	1039f91e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81126fbc:	d8c02017 	ldw	r3,128(sp)
81126fc0:	da000404 	addi	r8,sp,16
81126fc4:	003d8406 	br	811265d8 <__reset+0xfb1065d8>
81126fc8:	0023883a 	mov	r17,zero
81126fcc:	003d8306 	br	811265dc <__reset+0xfb1065dc>
81126fd0:	01204574 	movhi	r4,33045
81126fd4:	21099884 	addi	r4,r4,9826
81126fd8:	d9002b15 	stw	r4,172(sp)
81126fdc:	d9002b17 	ldw	r4,172(sp)
81126fe0:	1c47883a 	add	r3,r3,r17
81126fe4:	10800044 	addi	r2,r2,1
81126fe8:	41000015 	stw	r4,0(r8)
81126fec:	44400115 	stw	r17,4(r8)
81126ff0:	d8c02015 	stw	r3,128(sp)
81126ff4:	d8801f15 	stw	r2,124(sp)
81126ff8:	010001c4 	movi	r4,7
81126ffc:	20bfcd16 	blt	r4,r2,81126f34 <__reset+0xfb106f34>
81127000:	42000204 	addi	r8,r8,8
81127004:	003fd306 	br	81126f54 <__reset+0xfb106f54>
81127008:	d9402c17 	ldw	r5,176(sp)
8112700c:	d9801e04 	addi	r6,sp,120
81127010:	9809883a 	mov	r4,r19
81127014:	1131d3c0 	call	81131d3c <__ssprint_r>
81127018:	1039e11e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
8112701c:	d8802617 	ldw	r2,152(sp)
81127020:	d8c02017 	ldw	r3,128(sp)
81127024:	da000404 	addi	r8,sp,16
81127028:	003e1c06 	br	8112689c <__reset+0xfb10689c>
8112702c:	d8802917 	ldw	r2,164(sp)
81127030:	00c00184 	movi	r3,6
81127034:	1880012e 	bgeu	r3,r2,8112703c <___svfprintf_internal_r+0x1c38>
81127038:	1805883a 	mov	r2,r3
8112703c:	d8802e15 	stw	r2,184(sp)
81127040:	1000f316 	blt	r2,zero,81127410 <___svfprintf_internal_r+0x200c>
81127044:	04204574 	movhi	r16,33045
81127048:	d8802a15 	stw	r2,168(sp)
8112704c:	dd002d15 	stw	r20,180(sp)
81127050:	d8002915 	stw	zero,164(sp)
81127054:	d8003215 	stw	zero,200(sp)
81127058:	84099604 	addi	r16,r16,9816
8112705c:	0039883a 	mov	fp,zero
81127060:	003a9f06 	br	81125ae0 <__reset+0xfb105ae0>
81127064:	01204574 	movhi	r4,33045
81127068:	21099c84 	addi	r4,r4,9842
8112706c:	d9003515 	stw	r4,212(sp)
81127070:	003b5f06 	br	81125df0 <__reset+0xfb105df0>
81127074:	d9402c17 	ldw	r5,176(sp)
81127078:	d9801e04 	addi	r6,sp,120
8112707c:	9809883a 	mov	r4,r19
81127080:	1131d3c0 	call	81131d3c <__ssprint_r>
81127084:	1039c61e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81127088:	d8802617 	ldw	r2,152(sp)
8112708c:	d9403317 	ldw	r5,204(sp)
81127090:	d8c02017 	ldw	r3,128(sp)
81127094:	da000404 	addi	r8,sp,16
81127098:	2885c83a 	sub	r2,r5,r2
8112709c:	003e1006 	br	811268e0 <__reset+0xfb1068e0>
811270a0:	00800044 	movi	r2,1
811270a4:	10803fcc 	andi	r2,r2,255
811270a8:	00c00044 	movi	r3,1
811270ac:	10fa3526 	beq	r2,r3,81125984 <__reset+0xfb105984>
811270b0:	00c00084 	movi	r3,2
811270b4:	10fb9e26 	beq	r2,r3,81125f30 <__reset+0xfb105f30>
811270b8:	003a6406 	br	81125a4c <__reset+0xfb105a4c>
811270bc:	0021883a 	mov	r16,zero
811270c0:	003e0806 	br	811268e4 <__reset+0xfb1068e4>
811270c4:	07000b44 	movi	fp,45
811270c8:	df002785 	stb	fp,158(sp)
811270cc:	003a0b06 	br	811258fc <__reset+0xfb1058fc>
811270d0:	d8c02d17 	ldw	r3,180(sp)
811270d4:	d9002f17 	ldw	r4,188(sp)
811270d8:	18800017 	ldw	r2,0(r3)
811270dc:	18c00104 	addi	r3,r3,4
811270e0:	d8c02d15 	stw	r3,180(sp)
811270e4:	11000015 	stw	r4,0(r2)
811270e8:	0038f306 	br	811254b8 <__reset+0xfb1054b8>
811270ec:	00c00b44 	movi	r3,45
811270f0:	d8c02785 	stb	r3,158(sp)
811270f4:	d8802a15 	stw	r2,168(sp)
811270f8:	dc802b17 	ldw	r18,172(sp)
811270fc:	d8002915 	stw	zero,164(sp)
81127100:	07000b44 	movi	fp,45
81127104:	003a7306 	br	81125ad4 <__reset+0xfb105ad4>
81127108:	9080004c 	andi	r2,r18,1
8112710c:	1000941e 	bne	r2,zero,81127360 <___svfprintf_internal_r+0x1f5c>
81127110:	d8802117 	ldw	r2,132(sp)
81127114:	1405c83a 	sub	r2,r2,r16
81127118:	d8803315 	stw	r2,204(sp)
8112711c:	b441161e 	bne	r22,r17,81127578 <___svfprintf_internal_r+0x2174>
81127120:	dd802617 	ldw	r22,152(sp)
81127124:	00bfff44 	movi	r2,-3
81127128:	b0801a16 	blt	r22,r2,81127194 <___svfprintf_internal_r+0x1d90>
8112712c:	d9402917 	ldw	r5,164(sp)
81127130:	2d801816 	blt	r5,r22,81127194 <___svfprintf_internal_r+0x1d90>
81127134:	dd803215 	stw	r22,200(sp)
81127138:	003f3a06 	br	81126e24 <__reset+0xfb106e24>
8112713c:	1025883a 	mov	r18,r2
81127140:	0039883a 	mov	fp,zero
81127144:	00800084 	movi	r2,2
81127148:	003fd606 	br	811270a4 <__reset+0xfb1070a4>
8112714c:	9080004c 	andi	r2,r18,1
81127150:	103f191e 	bne	r2,zero,81126db8 <__reset+0xfb106db8>
81127154:	d8802117 	ldw	r2,132(sp)
81127158:	003f2806 	br	81126dfc <__reset+0xfb106dfc>
8112715c:	01204574 	movhi	r4,33045
81127160:	21099884 	addi	r4,r4,9826
81127164:	d9002b15 	stw	r4,172(sp)
81127168:	003c7c06 	br	8112635c <__reset+0xfb10635c>
8112716c:	e005883a 	mov	r2,fp
81127170:	003f2206 	br	81126dfc <__reset+0xfb106dfc>
81127174:	d9402917 	ldw	r5,164(sp)
81127178:	df002783 	ldbu	fp,158(sp)
8112717c:	dd002d15 	stw	r20,180(sp)
81127180:	d9402a15 	stw	r5,168(sp)
81127184:	d9402e15 	stw	r5,184(sp)
81127188:	d8002915 	stw	zero,164(sp)
8112718c:	d8003215 	stw	zero,200(sp)
81127190:	003a4c06 	br	81125ac4 <__reset+0xfb105ac4>
81127194:	8c7fff84 	addi	r17,r17,-2
81127198:	b5bfffc4 	addi	r22,r22,-1
8112719c:	dd802615 	stw	r22,152(sp)
811271a0:	dc4022c5 	stb	r17,139(sp)
811271a4:	b000c316 	blt	r22,zero,811274b4 <___svfprintf_internal_r+0x20b0>
811271a8:	00800ac4 	movi	r2,43
811271ac:	d8802305 	stb	r2,140(sp)
811271b0:	00800244 	movi	r2,9
811271b4:	15806e16 	blt	r2,r22,81127370 <___svfprintf_internal_r+0x1f6c>
811271b8:	00800c04 	movi	r2,48
811271bc:	b5800c04 	addi	r22,r22,48
811271c0:	d8802345 	stb	r2,141(sp)
811271c4:	dd802385 	stb	r22,142(sp)
811271c8:	d88023c4 	addi	r2,sp,143
811271cc:	df0022c4 	addi	fp,sp,139
811271d0:	d8c03317 	ldw	r3,204(sp)
811271d4:	1739c83a 	sub	fp,r2,fp
811271d8:	d9003317 	ldw	r4,204(sp)
811271dc:	e0c7883a 	add	r3,fp,r3
811271e0:	df003b15 	stw	fp,236(sp)
811271e4:	d8c02e15 	stw	r3,184(sp)
811271e8:	00800044 	movi	r2,1
811271ec:	1100b70e 	bge	r2,r4,811274cc <___svfprintf_internal_r+0x20c8>
811271f0:	d8c02e17 	ldw	r3,184(sp)
811271f4:	18c00044 	addi	r3,r3,1
811271f8:	d8c02e15 	stw	r3,184(sp)
811271fc:	1805883a 	mov	r2,r3
81127200:	1800b016 	blt	r3,zero,811274c4 <___svfprintf_internal_r+0x20c0>
81127204:	d8003215 	stw	zero,200(sp)
81127208:	003f1006 	br	81126e4c <__reset+0xfb106e4c>
8112720c:	d8802917 	ldw	r2,164(sp)
81127210:	103ec71e 	bne	r2,zero,81126d30 <__reset+0xfb106d30>
81127214:	dc002915 	stw	r16,164(sp)
81127218:	003ec506 	br	81126d30 <__reset+0xfb106d30>
8112721c:	d9402c17 	ldw	r5,176(sp)
81127220:	d9801e04 	addi	r6,sp,120
81127224:	9809883a 	mov	r4,r19
81127228:	1131d3c0 	call	81131d3c <__ssprint_r>
8112722c:	10395c1e 	bne	r2,zero,811257a0 <__reset+0xfb1057a0>
81127230:	dc402617 	ldw	r17,152(sp)
81127234:	d8c02017 	ldw	r3,128(sp)
81127238:	d8801f17 	ldw	r2,124(sp)
8112723c:	da000404 	addi	r8,sp,16
81127240:	003e7706 	br	81126c20 <__reset+0xfb106c20>
81127244:	582f883a 	mov	r23,r11
81127248:	d8002915 	stw	zero,164(sp)
8112724c:	0038c406 	br	81125560 <__reset+0xfb105560>
81127250:	d8c02917 	ldw	r3,164(sp)
81127254:	d8802104 	addi	r2,sp,132
81127258:	d8800315 	stw	r2,12(sp)
8112725c:	d9403617 	ldw	r5,216(sp)
81127260:	d8802504 	addi	r2,sp,148
81127264:	d8800215 	stw	r2,8(sp)
81127268:	d8802604 	addi	r2,sp,152
8112726c:	d8c00015 	stw	r3,0(sp)
81127270:	9809883a 	mov	r4,r19
81127274:	d8800115 	stw	r2,4(sp)
81127278:	01c000c4 	movi	r7,3
8112727c:	a00d883a 	mov	r6,r20
81127280:	da003e15 	stw	r8,248(sp)
81127284:	112b6f00 	call	8112b6f0 <_dtoa_r>
81127288:	d9002917 	ldw	r4,164(sp)
8112728c:	da003e17 	ldw	r8,248(sp)
81127290:	1021883a 	mov	r16,r2
81127294:	1139883a 	add	fp,r2,r4
81127298:	2007883a 	mov	r3,r4
8112729c:	81000007 	ldb	r4,0(r16)
811272a0:	00800c04 	movi	r2,48
811272a4:	20806f26 	beq	r4,r2,81127464 <___svfprintf_internal_r+0x2060>
811272a8:	d8c02617 	ldw	r3,152(sp)
811272ac:	e0f9883a 	add	fp,fp,r3
811272b0:	003ec206 	br	81126dbc <__reset+0xfb106dbc>
811272b4:	00c00b44 	movi	r3,45
811272b8:	2520003c 	xorhi	r20,r4,32768
811272bc:	d8c02a05 	stb	r3,168(sp)
811272c0:	003ea106 	br	81126d48 <__reset+0xfb106d48>
811272c4:	d8c03217 	ldw	r3,200(sp)
811272c8:	00c0890e 	bge	zero,r3,811274f0 <___svfprintf_internal_r+0x20ec>
811272cc:	00800044 	movi	r2,1
811272d0:	d9003317 	ldw	r4,204(sp)
811272d4:	1105883a 	add	r2,r2,r4
811272d8:	d8802e15 	stw	r2,184(sp)
811272dc:	10005f16 	blt	r2,zero,8112745c <___svfprintf_internal_r+0x2058>
811272e0:	044019c4 	movi	r17,103
811272e4:	003ed906 	br	81126e4c <__reset+0xfb106e4c>
811272e8:	d9002917 	ldw	r4,164(sp)
811272ec:	20c00044 	addi	r3,r4,1
811272f0:	003e9c06 	br	81126d64 <__reset+0xfb106d64>
811272f4:	d9002917 	ldw	r4,164(sp)
811272f8:	00c0680e 	bge	zero,r3,8112749c <___svfprintf_internal_r+0x2098>
811272fc:	2000461e 	bne	r4,zero,81127418 <___svfprintf_internal_r+0x2014>
81127300:	9480004c 	andi	r18,r18,1
81127304:	9000441e 	bne	r18,zero,81127418 <___svfprintf_internal_r+0x2014>
81127308:	1805883a 	mov	r2,r3
8112730c:	1800a016 	blt	r3,zero,81127590 <___svfprintf_internal_r+0x218c>
81127310:	d8c03217 	ldw	r3,200(sp)
81127314:	d8c02e15 	stw	r3,184(sp)
81127318:	003ecc06 	br	81126e4c <__reset+0xfb106e4c>
8112731c:	d9402917 	ldw	r5,164(sp)
81127320:	d8802104 	addi	r2,sp,132
81127324:	d8800315 	stw	r2,12(sp)
81127328:	d9400015 	stw	r5,0(sp)
8112732c:	d8802504 	addi	r2,sp,148
81127330:	d9403617 	ldw	r5,216(sp)
81127334:	d8800215 	stw	r2,8(sp)
81127338:	d8802604 	addi	r2,sp,152
8112733c:	d8800115 	stw	r2,4(sp)
81127340:	01c000c4 	movi	r7,3
81127344:	a00d883a 	mov	r6,r20
81127348:	9809883a 	mov	r4,r19
8112734c:	da003e15 	stw	r8,248(sp)
81127350:	112b6f00 	call	8112b6f0 <_dtoa_r>
81127354:	d8c02917 	ldw	r3,164(sp)
81127358:	da003e17 	ldw	r8,248(sp)
8112735c:	1021883a 	mov	r16,r2
81127360:	00801184 	movi	r2,70
81127364:	80f9883a 	add	fp,r16,r3
81127368:	88bfcc26 	beq	r17,r2,8112729c <__reset+0xfb10729c>
8112736c:	003e9306 	br	81126dbc <__reset+0xfb106dbc>
81127370:	df0022c4 	addi	fp,sp,139
81127374:	dc002915 	stw	r16,164(sp)
81127378:	9829883a 	mov	r20,r19
8112737c:	e021883a 	mov	r16,fp
81127380:	4027883a 	mov	r19,r8
81127384:	b009883a 	mov	r4,r22
81127388:	01400284 	movi	r5,10
8112738c:	11367e80 	call	811367e8 <__modsi3>
81127390:	10800c04 	addi	r2,r2,48
81127394:	843fffc4 	addi	r16,r16,-1
81127398:	b009883a 	mov	r4,r22
8112739c:	01400284 	movi	r5,10
811273a0:	80800005 	stb	r2,0(r16)
811273a4:	11367640 	call	81136764 <__divsi3>
811273a8:	102d883a 	mov	r22,r2
811273ac:	00800244 	movi	r2,9
811273b0:	15bff416 	blt	r2,r22,81127384 <__reset+0xfb107384>
811273b4:	9811883a 	mov	r8,r19
811273b8:	b0800c04 	addi	r2,r22,48
811273bc:	a027883a 	mov	r19,r20
811273c0:	8029883a 	mov	r20,r16
811273c4:	a17fffc4 	addi	r5,r20,-1
811273c8:	a0bfffc5 	stb	r2,-1(r20)
811273cc:	dc002917 	ldw	r16,164(sp)
811273d0:	2f00752e 	bgeu	r5,fp,811275a8 <___svfprintf_internal_r+0x21a4>
811273d4:	d9c02384 	addi	r7,sp,142
811273d8:	3d0fc83a 	sub	r7,r7,r20
811273dc:	d9002344 	addi	r4,sp,141
811273e0:	e1cf883a 	add	r7,fp,r7
811273e4:	00000106 	br	811273ec <___svfprintf_internal_r+0x1fe8>
811273e8:	28800003 	ldbu	r2,0(r5)
811273ec:	20800005 	stb	r2,0(r4)
811273f0:	21000044 	addi	r4,r4,1
811273f4:	29400044 	addi	r5,r5,1
811273f8:	21fffb1e 	bne	r4,r7,811273e8 <__reset+0xfb1073e8>
811273fc:	d8802304 	addi	r2,sp,140
81127400:	1505c83a 	sub	r2,r2,r20
81127404:	d8c02344 	addi	r3,sp,141
81127408:	1885883a 	add	r2,r3,r2
8112740c:	003f7006 	br	811271d0 <__reset+0xfb1071d0>
81127410:	0005883a 	mov	r2,zero
81127414:	003f0b06 	br	81127044 <__reset+0xfb107044>
81127418:	d9002917 	ldw	r4,164(sp)
8112741c:	d8c03217 	ldw	r3,200(sp)
81127420:	20800044 	addi	r2,r4,1
81127424:	1885883a 	add	r2,r3,r2
81127428:	d8802e15 	stw	r2,184(sp)
8112742c:	103e870e 	bge	r2,zero,81126e4c <__reset+0xfb106e4c>
81127430:	0005883a 	mov	r2,zero
81127434:	003e8506 	br	81126e4c <__reset+0xfb106e4c>
81127438:	01204574 	movhi	r4,33045
8112743c:	21099884 	addi	r4,r4,9826
81127440:	d9002b15 	stw	r4,172(sp)
81127444:	003cc506 	br	8112675c <__reset+0xfb10675c>
81127448:	d8c03217 	ldw	r3,200(sp)
8112744c:	18c00044 	addi	r3,r3,1
81127450:	d8c02e15 	stw	r3,184(sp)
81127454:	1805883a 	mov	r2,r3
81127458:	183fa10e 	bge	r3,zero,811272e0 <__reset+0xfb1072e0>
8112745c:	0005883a 	mov	r2,zero
81127460:	003f9f06 	br	811272e0 <__reset+0xfb1072e0>
81127464:	d9003617 	ldw	r4,216(sp)
81127468:	000d883a 	mov	r6,zero
8112746c:	000f883a 	mov	r7,zero
81127470:	a00b883a 	mov	r5,r20
81127474:	d8c03d15 	stw	r3,244(sp)
81127478:	da003e15 	stw	r8,248(sp)
8112747c:	1137cb80 	call	81137cb8 <__eqdf2>
81127480:	d8c03d17 	ldw	r3,244(sp)
81127484:	da003e17 	ldw	r8,248(sp)
81127488:	103f8726 	beq	r2,zero,811272a8 <__reset+0xfb1072a8>
8112748c:	00800044 	movi	r2,1
81127490:	10c7c83a 	sub	r3,r2,r3
81127494:	d8c02615 	stw	r3,152(sp)
81127498:	003f8406 	br	811272ac <__reset+0xfb1072ac>
8112749c:	20000e1e 	bne	r4,zero,811274d8 <___svfprintf_internal_r+0x20d4>
811274a0:	9480004c 	andi	r18,r18,1
811274a4:	90000c1e 	bne	r18,zero,811274d8 <___svfprintf_internal_r+0x20d4>
811274a8:	00800044 	movi	r2,1
811274ac:	d8802e15 	stw	r2,184(sp)
811274b0:	003e6606 	br	81126e4c <__reset+0xfb106e4c>
811274b4:	00800b44 	movi	r2,45
811274b8:	05adc83a 	sub	r22,zero,r22
811274bc:	d8802305 	stb	r2,140(sp)
811274c0:	003f3b06 	br	811271b0 <__reset+0xfb1071b0>
811274c4:	0005883a 	mov	r2,zero
811274c8:	003f4e06 	br	81127204 <__reset+0xfb107204>
811274cc:	90a4703a 	and	r18,r18,r2
811274d0:	903f4a26 	beq	r18,zero,811271fc <__reset+0xfb1071fc>
811274d4:	003f4606 	br	811271f0 <__reset+0xfb1071f0>
811274d8:	d8c02917 	ldw	r3,164(sp)
811274dc:	18c00084 	addi	r3,r3,2
811274e0:	d8c02e15 	stw	r3,184(sp)
811274e4:	1805883a 	mov	r2,r3
811274e8:	183e580e 	bge	r3,zero,81126e4c <__reset+0xfb106e4c>
811274ec:	003fd006 	br	81127430 <__reset+0xfb107430>
811274f0:	00800084 	movi	r2,2
811274f4:	10c5c83a 	sub	r2,r2,r3
811274f8:	003f7506 	br	811272d0 <__reset+0xfb1072d0>
811274fc:	d8802d17 	ldw	r2,180(sp)
81127500:	d9002d17 	ldw	r4,180(sp)
81127504:	bc400043 	ldbu	r17,1(r23)
81127508:	10800017 	ldw	r2,0(r2)
8112750c:	582f883a 	mov	r23,r11
81127510:	d8802915 	stw	r2,164(sp)
81127514:	20800104 	addi	r2,r4,4
81127518:	d9002917 	ldw	r4,164(sp)
8112751c:	d8802d15 	stw	r2,180(sp)
81127520:	203df00e 	bge	r4,zero,81126ce4 <__reset+0xfb106ce4>
81127524:	8c403fcc 	andi	r17,r17,255
81127528:	00bfffc4 	movi	r2,-1
8112752c:	8c40201c 	xori	r17,r17,128
81127530:	d8802915 	stw	r2,164(sp)
81127534:	8c7fe004 	addi	r17,r17,-128
81127538:	00380806 	br	8112555c <__reset+0xfb10555c>
8112753c:	9080004c 	andi	r2,r18,1
81127540:	0039883a 	mov	fp,zero
81127544:	10000726 	beq	r2,zero,81127564 <___svfprintf_internal_r+0x2160>
81127548:	d8c02817 	ldw	r3,160(sp)
8112754c:	dc001dc4 	addi	r16,sp,119
81127550:	00800c04 	movi	r2,48
81127554:	1c07c83a 	sub	r3,r3,r16
81127558:	d8801dc5 	stb	r2,119(sp)
8112755c:	d8c02e15 	stw	r3,184(sp)
81127560:	00395206 	br	81125aac <__reset+0xfb105aac>
81127564:	d8002e15 	stw	zero,184(sp)
81127568:	dc001e04 	addi	r16,sp,120
8112756c:	00394f06 	br	81125aac <__reset+0xfb105aac>
81127570:	0005883a 	mov	r2,zero
81127574:	003e3206 	br	81126e40 <__reset+0xfb106e40>
81127578:	dd802617 	ldw	r22,152(sp)
8112757c:	003f0606 	br	81127198 <__reset+0xfb107198>
81127580:	d9c02785 	stb	r7,158(sp)
81127584:	003a5106 	br	81125ecc <__reset+0xfb105ecc>
81127588:	d9c02785 	stb	r7,158(sp)
8112758c:	003a3706 	br	81125e6c <__reset+0xfb105e6c>
81127590:	0005883a 	mov	r2,zero
81127594:	003f5e06 	br	81127310 <__reset+0xfb107310>
81127598:	d9c02785 	stb	r7,158(sp)
8112759c:	00391706 	br	811259fc <__reset+0xfb1059fc>
811275a0:	d9c02785 	stb	r7,158(sp)
811275a4:	0038e606 	br	81125940 <__reset+0xfb105940>
811275a8:	d8802344 	addi	r2,sp,141
811275ac:	003f0806 	br	811271d0 <__reset+0xfb1071d0>
811275b0:	d9c02785 	stb	r7,158(sp)
811275b4:	0038b706 	br	81125894 <__reset+0xfb105894>
811275b8:	d9c02785 	stb	r7,158(sp)
811275bc:	003adc06 	br	81126130 <__reset+0xfb106130>
811275c0:	d9403917 	ldw	r5,228(sp)
811275c4:	00800304 	movi	r2,12
811275c8:	28800015 	stw	r2,0(r5)
811275cc:	00bfffc4 	movi	r2,-1
811275d0:	00387806 	br	811257b4 <__reset+0xfb1057b4>
811275d4:	d9c02785 	stb	r7,158(sp)
811275d8:	003abf06 	br	811260d8 <__reset+0xfb1060d8>
811275dc:	d9c02785 	stb	r7,158(sp)
811275e0:	003a9b06 	br	81126050 <__reset+0xfb106050>

811275e4 <___vfprintf_internal_r>:
811275e4:	deffb804 	addi	sp,sp,-288
811275e8:	de00012e 	bgeu	sp,et,811275f0 <___vfprintf_internal_r+0xc>
811275ec:	003b68fa 	trap	3
811275f0:	dfc04715 	stw	ra,284(sp)
811275f4:	ddc04515 	stw	r23,276(sp)
811275f8:	dd404315 	stw	r21,268(sp)
811275fc:	d9002c15 	stw	r4,176(sp)
81127600:	282f883a 	mov	r23,r5
81127604:	302b883a 	mov	r21,r6
81127608:	d9c02d15 	stw	r7,180(sp)
8112760c:	df004615 	stw	fp,280(sp)
81127610:	dd804415 	stw	r22,272(sp)
81127614:	dd004215 	stw	r20,264(sp)
81127618:	dcc04115 	stw	r19,260(sp)
8112761c:	dc804015 	stw	r18,256(sp)
81127620:	dc403f15 	stw	r17,252(sp)
81127624:	dc003e15 	stw	r16,248(sp)
81127628:	112e2ec0 	call	8112e2ec <_localeconv_r>
8112762c:	10800017 	ldw	r2,0(r2)
81127630:	1009883a 	mov	r4,r2
81127634:	d8803415 	stw	r2,208(sp)
81127638:	1124dc80 	call	81124dc8 <strlen>
8112763c:	d8803715 	stw	r2,220(sp)
81127640:	d8802c17 	ldw	r2,176(sp)
81127644:	10000226 	beq	r2,zero,81127650 <___vfprintf_internal_r+0x6c>
81127648:	10800e17 	ldw	r2,56(r2)
8112764c:	1000f926 	beq	r2,zero,81127a34 <___vfprintf_internal_r+0x450>
81127650:	b880030b 	ldhu	r2,12(r23)
81127654:	10c8000c 	andi	r3,r2,8192
81127658:	1800061e 	bne	r3,zero,81127674 <___vfprintf_internal_r+0x90>
8112765c:	b9001917 	ldw	r4,100(r23)
81127660:	00f7ffc4 	movi	r3,-8193
81127664:	10880014 	ori	r2,r2,8192
81127668:	20c6703a 	and	r3,r4,r3
8112766c:	b880030d 	sth	r2,12(r23)
81127670:	b8c01915 	stw	r3,100(r23)
81127674:	10c0020c 	andi	r3,r2,8
81127678:	1800c126 	beq	r3,zero,81127980 <___vfprintf_internal_r+0x39c>
8112767c:	b8c00417 	ldw	r3,16(r23)
81127680:	1800bf26 	beq	r3,zero,81127980 <___vfprintf_internal_r+0x39c>
81127684:	1080068c 	andi	r2,r2,26
81127688:	00c00284 	movi	r3,10
8112768c:	10c0c426 	beq	r2,r3,811279a0 <___vfprintf_internal_r+0x3bc>
81127690:	d8c00404 	addi	r3,sp,16
81127694:	05204574 	movhi	r20,33045
81127698:	d9001e04 	addi	r4,sp,120
8112769c:	a509a084 	addi	r20,r20,9858
811276a0:	d8c01e15 	stw	r3,120(sp)
811276a4:	d8002015 	stw	zero,128(sp)
811276a8:	d8001f15 	stw	zero,124(sp)
811276ac:	d8003315 	stw	zero,204(sp)
811276b0:	d8003615 	stw	zero,216(sp)
811276b4:	d8003815 	stw	zero,224(sp)
811276b8:	1811883a 	mov	r8,r3
811276bc:	d8003915 	stw	zero,228(sp)
811276c0:	d8003a15 	stw	zero,232(sp)
811276c4:	d8002f15 	stw	zero,188(sp)
811276c8:	d9002815 	stw	r4,160(sp)
811276cc:	a8800007 	ldb	r2,0(r21)
811276d0:	10027b26 	beq	r2,zero,811280c0 <___vfprintf_internal_r+0xadc>
811276d4:	00c00944 	movi	r3,37
811276d8:	a821883a 	mov	r16,r21
811276dc:	10c0021e 	bne	r2,r3,811276e8 <___vfprintf_internal_r+0x104>
811276e0:	00001406 	br	81127734 <___vfprintf_internal_r+0x150>
811276e4:	10c00326 	beq	r2,r3,811276f4 <___vfprintf_internal_r+0x110>
811276e8:	84000044 	addi	r16,r16,1
811276ec:	80800007 	ldb	r2,0(r16)
811276f0:	103ffc1e 	bne	r2,zero,811276e4 <__reset+0xfb1076e4>
811276f4:	8563c83a 	sub	r17,r16,r21
811276f8:	88000e26 	beq	r17,zero,81127734 <___vfprintf_internal_r+0x150>
811276fc:	d8c02017 	ldw	r3,128(sp)
81127700:	d8801f17 	ldw	r2,124(sp)
81127704:	45400015 	stw	r21,0(r8)
81127708:	1c47883a 	add	r3,r3,r17
8112770c:	10800044 	addi	r2,r2,1
81127710:	d8c02015 	stw	r3,128(sp)
81127714:	44400115 	stw	r17,4(r8)
81127718:	d8801f15 	stw	r2,124(sp)
8112771c:	00c001c4 	movi	r3,7
81127720:	1880a716 	blt	r3,r2,811279c0 <___vfprintf_internal_r+0x3dc>
81127724:	42000204 	addi	r8,r8,8
81127728:	d9402f17 	ldw	r5,188(sp)
8112772c:	2c4b883a 	add	r5,r5,r17
81127730:	d9402f15 	stw	r5,188(sp)
81127734:	80800007 	ldb	r2,0(r16)
81127738:	1000a826 	beq	r2,zero,811279dc <___vfprintf_internal_r+0x3f8>
8112773c:	84400047 	ldb	r17,1(r16)
81127740:	00bfffc4 	movi	r2,-1
81127744:	85400044 	addi	r21,r16,1
81127748:	d8002785 	stb	zero,158(sp)
8112774c:	0007883a 	mov	r3,zero
81127750:	000f883a 	mov	r7,zero
81127754:	d8802915 	stw	r2,164(sp)
81127758:	d8003115 	stw	zero,196(sp)
8112775c:	0025883a 	mov	r18,zero
81127760:	01401604 	movi	r5,88
81127764:	01800244 	movi	r6,9
81127768:	02800a84 	movi	r10,42
8112776c:	02401b04 	movi	r9,108
81127770:	ad400044 	addi	r21,r21,1
81127774:	88bff804 	addi	r2,r17,-32
81127778:	28830436 	bltu	r5,r2,8112838c <___vfprintf_internal_r+0xda8>
8112777c:	100490ba 	slli	r2,r2,2
81127780:	012044b4 	movhi	r4,33042
81127784:	211de504 	addi	r4,r4,30612
81127788:	1105883a 	add	r2,r2,r4
8112778c:	10800017 	ldw	r2,0(r2)
81127790:	1000683a 	jmp	r2
81127794:	811282ac 	andhi	r4,r16,18954
81127798:	8112838c 	andi	r4,r16,18958
8112779c:	8112838c 	andi	r4,r16,18958
811277a0:	811282cc 	andi	r4,r16,18955
811277a4:	8112838c 	andi	r4,r16,18958
811277a8:	8112838c 	andi	r4,r16,18958
811277ac:	8112838c 	andi	r4,r16,18958
811277b0:	8112838c 	andi	r4,r16,18958
811277b4:	8112838c 	andi	r4,r16,18958
811277b8:	8112838c 	andi	r4,r16,18958
811277bc:	81127a40 	call	881127a4 <__reset+0x20f27a4>
811277c0:	811281e8 	cmpgeui	r4,r16,18951
811277c4:	8112838c 	andi	r4,r16,18958
811277c8:	81127908 	cmpgei	r4,r16,18916
811277cc:	81127a68 	cmpgeui	r4,r16,18921
811277d0:	8112838c 	andi	r4,r16,18958
811277d4:	81127aa8 	cmpgeui	r4,r16,18922
811277d8:	81127ab4 	orhi	r4,r16,18922
811277dc:	81127ab4 	orhi	r4,r16,18922
811277e0:	81127ab4 	orhi	r4,r16,18922
811277e4:	81127ab4 	orhi	r4,r16,18922
811277e8:	81127ab4 	orhi	r4,r16,18922
811277ec:	81127ab4 	orhi	r4,r16,18922
811277f0:	81127ab4 	orhi	r4,r16,18922
811277f4:	81127ab4 	orhi	r4,r16,18922
811277f8:	81127ab4 	orhi	r4,r16,18922
811277fc:	8112838c 	andi	r4,r16,18958
81127800:	8112838c 	andi	r4,r16,18958
81127804:	8112838c 	andi	r4,r16,18958
81127808:	8112838c 	andi	r4,r16,18958
8112780c:	8112838c 	andi	r4,r16,18958
81127810:	8112838c 	andi	r4,r16,18958
81127814:	8112838c 	andi	r4,r16,18958
81127818:	8112838c 	andi	r4,r16,18958
8112781c:	8112838c 	andi	r4,r16,18958
81127820:	8112838c 	andi	r4,r16,18958
81127824:	81127ae8 	cmpgeui	r4,r16,18923
81127828:	81127ba4 	muli	r4,r16,18926
8112782c:	8112838c 	andi	r4,r16,18958
81127830:	81127ba4 	muli	r4,r16,18926
81127834:	8112838c 	andi	r4,r16,18958
81127838:	8112838c 	andi	r4,r16,18958
8112783c:	8112838c 	andi	r4,r16,18958
81127840:	8112838c 	andi	r4,r16,18958
81127844:	81127c44 	addi	r4,r16,18929
81127848:	8112838c 	andi	r4,r16,18958
8112784c:	8112838c 	andi	r4,r16,18958
81127850:	81127c50 	cmplti	r4,r16,18929
81127854:	8112838c 	andi	r4,r16,18958
81127858:	8112838c 	andi	r4,r16,18958
8112785c:	8112838c 	andi	r4,r16,18958
81127860:	8112838c 	andi	r4,r16,18958
81127864:	8112838c 	andi	r4,r16,18958
81127868:	811280c8 	cmpgei	r4,r16,18947
8112786c:	8112838c 	andi	r4,r16,18958
81127870:	8112838c 	andi	r4,r16,18958
81127874:	81128128 	cmpgeui	r4,r16,18948
81127878:	8112838c 	andi	r4,r16,18958
8112787c:	8112838c 	andi	r4,r16,18958
81127880:	8112838c 	andi	r4,r16,18958
81127884:	8112838c 	andi	r4,r16,18958
81127888:	8112838c 	andi	r4,r16,18958
8112788c:	8112838c 	andi	r4,r16,18958
81127890:	8112838c 	andi	r4,r16,18958
81127894:	8112838c 	andi	r4,r16,18958
81127898:	8112838c 	andi	r4,r16,18958
8112789c:	8112838c 	andi	r4,r16,18958
811278a0:	81128338 	rdprs	r4,r16,18956
811278a4:	811282d8 	cmpnei	r4,r16,18955
811278a8:	81127ba4 	muli	r4,r16,18926
811278ac:	81127ba4 	muli	r4,r16,18926
811278b0:	81127ba4 	muli	r4,r16,18926
811278b4:	811282e8 	cmpgeui	r4,r16,18955
811278b8:	811282d8 	cmpnei	r4,r16,18955
811278bc:	8112838c 	andi	r4,r16,18958
811278c0:	8112838c 	andi	r4,r16,18958
811278c4:	811282f4 	orhi	r4,r16,18955
811278c8:	8112838c 	andi	r4,r16,18958
811278cc:	81128304 	addi	r4,r16,18956
811278d0:	811281d8 	cmpnei	r4,r16,18951
811278d4:	81127914 	ori	r4,r16,18916
811278d8:	811281f8 	rdprs	r4,r16,18951
811278dc:	8112838c 	andi	r4,r16,18958
811278e0:	81128204 	addi	r4,r16,18952
811278e4:	8112838c 	andi	r4,r16,18958
811278e8:	81128260 	cmpeqi	r4,r16,18953
811278ec:	8112838c 	andi	r4,r16,18958
811278f0:	8112838c 	andi	r4,r16,18958
811278f4:	81128270 	cmpltui	r4,r16,18953
811278f8:	d9003117 	ldw	r4,196(sp)
811278fc:	d8802d15 	stw	r2,180(sp)
81127900:	0109c83a 	sub	r4,zero,r4
81127904:	d9003115 	stw	r4,196(sp)
81127908:	94800114 	ori	r18,r18,4
8112790c:	ac400007 	ldb	r17,0(r21)
81127910:	003f9706 	br	81127770 <__reset+0xfb107770>
81127914:	00800c04 	movi	r2,48
81127918:	d9002d17 	ldw	r4,180(sp)
8112791c:	d9402917 	ldw	r5,164(sp)
81127920:	d8802705 	stb	r2,156(sp)
81127924:	00801e04 	movi	r2,120
81127928:	d8802745 	stb	r2,157(sp)
8112792c:	d8002785 	stb	zero,158(sp)
81127930:	20c00104 	addi	r3,r4,4
81127934:	24c00017 	ldw	r19,0(r4)
81127938:	002d883a 	mov	r22,zero
8112793c:	90800094 	ori	r2,r18,2
81127940:	28029a16 	blt	r5,zero,811283ac <___vfprintf_internal_r+0xdc8>
81127944:	00bfdfc4 	movi	r2,-129
81127948:	90a4703a 	and	r18,r18,r2
8112794c:	d8c02d15 	stw	r3,180(sp)
81127950:	94800094 	ori	r18,r18,2
81127954:	9802871e 	bne	r19,zero,81128374 <___vfprintf_internal_r+0xd90>
81127958:	00a04574 	movhi	r2,33045
8112795c:	10899104 	addi	r2,r2,9796
81127960:	d8803915 	stw	r2,228(sp)
81127964:	04401e04 	movi	r17,120
81127968:	d8802917 	ldw	r2,164(sp)
8112796c:	0039883a 	mov	fp,zero
81127970:	1001e926 	beq	r2,zero,81128118 <___vfprintf_internal_r+0xb34>
81127974:	0027883a 	mov	r19,zero
81127978:	002d883a 	mov	r22,zero
8112797c:	00020506 	br	81128194 <___vfprintf_internal_r+0xbb0>
81127980:	d9002c17 	ldw	r4,176(sp)
81127984:	b80b883a 	mov	r5,r23
81127988:	112b3300 	call	8112b330 <__swsetup_r>
8112798c:	1005ac1e 	bne	r2,zero,81129040 <___vfprintf_internal_r+0x1a5c>
81127990:	b880030b 	ldhu	r2,12(r23)
81127994:	00c00284 	movi	r3,10
81127998:	1080068c 	andi	r2,r2,26
8112799c:	10ff3c1e 	bne	r2,r3,81127690 <__reset+0xfb107690>
811279a0:	b880038f 	ldh	r2,14(r23)
811279a4:	103f3a16 	blt	r2,zero,81127690 <__reset+0xfb107690>
811279a8:	d9c02d17 	ldw	r7,180(sp)
811279ac:	d9002c17 	ldw	r4,176(sp)
811279b0:	a80d883a 	mov	r6,r21
811279b4:	b80b883a 	mov	r5,r23
811279b8:	11298000 	call	81129800 <__sbprintf>
811279bc:	00001106 	br	81127a04 <___vfprintf_internal_r+0x420>
811279c0:	d9002c17 	ldw	r4,176(sp)
811279c4:	d9801e04 	addi	r6,sp,120
811279c8:	b80b883a 	mov	r5,r23
811279cc:	11334ec0 	call	811334ec <__sprint_r>
811279d0:	1000081e 	bne	r2,zero,811279f4 <___vfprintf_internal_r+0x410>
811279d4:	da000404 	addi	r8,sp,16
811279d8:	003f5306 	br	81127728 <__reset+0xfb107728>
811279dc:	d8802017 	ldw	r2,128(sp)
811279e0:	10000426 	beq	r2,zero,811279f4 <___vfprintf_internal_r+0x410>
811279e4:	d9002c17 	ldw	r4,176(sp)
811279e8:	d9801e04 	addi	r6,sp,120
811279ec:	b80b883a 	mov	r5,r23
811279f0:	11334ec0 	call	811334ec <__sprint_r>
811279f4:	b880030b 	ldhu	r2,12(r23)
811279f8:	1080100c 	andi	r2,r2,64
811279fc:	1005901e 	bne	r2,zero,81129040 <___vfprintf_internal_r+0x1a5c>
81127a00:	d8802f17 	ldw	r2,188(sp)
81127a04:	dfc04717 	ldw	ra,284(sp)
81127a08:	df004617 	ldw	fp,280(sp)
81127a0c:	ddc04517 	ldw	r23,276(sp)
81127a10:	dd804417 	ldw	r22,272(sp)
81127a14:	dd404317 	ldw	r21,268(sp)
81127a18:	dd004217 	ldw	r20,264(sp)
81127a1c:	dcc04117 	ldw	r19,260(sp)
81127a20:	dc804017 	ldw	r18,256(sp)
81127a24:	dc403f17 	ldw	r17,252(sp)
81127a28:	dc003e17 	ldw	r16,248(sp)
81127a2c:	dec04804 	addi	sp,sp,288
81127a30:	f800283a 	ret
81127a34:	d9002c17 	ldw	r4,176(sp)
81127a38:	112d3a00 	call	8112d3a0 <__sinit>
81127a3c:	003f0406 	br	81127650 <__reset+0xfb107650>
81127a40:	d8802d17 	ldw	r2,180(sp)
81127a44:	d9002d17 	ldw	r4,180(sp)
81127a48:	10800017 	ldw	r2,0(r2)
81127a4c:	d8803115 	stw	r2,196(sp)
81127a50:	20800104 	addi	r2,r4,4
81127a54:	d9003117 	ldw	r4,196(sp)
81127a58:	203fa716 	blt	r4,zero,811278f8 <__reset+0xfb1078f8>
81127a5c:	d8802d15 	stw	r2,180(sp)
81127a60:	ac400007 	ldb	r17,0(r21)
81127a64:	003f4206 	br	81127770 <__reset+0xfb107770>
81127a68:	ac400007 	ldb	r17,0(r21)
81127a6c:	aac00044 	addi	r11,r21,1
81127a70:	8a872826 	beq	r17,r10,81129714 <___vfprintf_internal_r+0x2130>
81127a74:	88bff404 	addi	r2,r17,-48
81127a78:	0009883a 	mov	r4,zero
81127a7c:	30867d36 	bltu	r6,r2,81129474 <___vfprintf_internal_r+0x1e90>
81127a80:	5c400007 	ldb	r17,0(r11)
81127a84:	210002a4 	muli	r4,r4,10
81127a88:	5d400044 	addi	r21,r11,1
81127a8c:	a817883a 	mov	r11,r21
81127a90:	2089883a 	add	r4,r4,r2
81127a94:	88bff404 	addi	r2,r17,-48
81127a98:	30bff92e 	bgeu	r6,r2,81127a80 <__reset+0xfb107a80>
81127a9c:	2005c916 	blt	r4,zero,811291c4 <___vfprintf_internal_r+0x1be0>
81127aa0:	d9002915 	stw	r4,164(sp)
81127aa4:	003f3306 	br	81127774 <__reset+0xfb107774>
81127aa8:	94802014 	ori	r18,r18,128
81127aac:	ac400007 	ldb	r17,0(r21)
81127ab0:	003f2f06 	br	81127770 <__reset+0xfb107770>
81127ab4:	a809883a 	mov	r4,r21
81127ab8:	d8003115 	stw	zero,196(sp)
81127abc:	88bff404 	addi	r2,r17,-48
81127ac0:	0017883a 	mov	r11,zero
81127ac4:	24400007 	ldb	r17,0(r4)
81127ac8:	5ac002a4 	muli	r11,r11,10
81127acc:	ad400044 	addi	r21,r21,1
81127ad0:	a809883a 	mov	r4,r21
81127ad4:	12d7883a 	add	r11,r2,r11
81127ad8:	88bff404 	addi	r2,r17,-48
81127adc:	30bff92e 	bgeu	r6,r2,81127ac4 <__reset+0xfb107ac4>
81127ae0:	dac03115 	stw	r11,196(sp)
81127ae4:	003f2306 	br	81127774 <__reset+0xfb107774>
81127ae8:	18c03fcc 	andi	r3,r3,255
81127aec:	18072b1e 	bne	r3,zero,8112979c <___vfprintf_internal_r+0x21b8>
81127af0:	94800414 	ori	r18,r18,16
81127af4:	9080080c 	andi	r2,r18,32
81127af8:	10037b26 	beq	r2,zero,811288e8 <___vfprintf_internal_r+0x1304>
81127afc:	d9402d17 	ldw	r5,180(sp)
81127b00:	28800117 	ldw	r2,4(r5)
81127b04:	2cc00017 	ldw	r19,0(r5)
81127b08:	29400204 	addi	r5,r5,8
81127b0c:	d9402d15 	stw	r5,180(sp)
81127b10:	102d883a 	mov	r22,r2
81127b14:	10044b16 	blt	r2,zero,81128c44 <___vfprintf_internal_r+0x1660>
81127b18:	d9402917 	ldw	r5,164(sp)
81127b1c:	df002783 	ldbu	fp,158(sp)
81127b20:	2803bc16 	blt	r5,zero,81128a14 <___vfprintf_internal_r+0x1430>
81127b24:	00ffdfc4 	movi	r3,-129
81127b28:	9d84b03a 	or	r2,r19,r22
81127b2c:	90e4703a 	and	r18,r18,r3
81127b30:	10017726 	beq	r2,zero,81128110 <___vfprintf_internal_r+0xb2c>
81127b34:	b0038326 	beq	r22,zero,81128944 <___vfprintf_internal_r+0x1360>
81127b38:	dc402a15 	stw	r17,168(sp)
81127b3c:	dc001e04 	addi	r16,sp,120
81127b40:	b023883a 	mov	r17,r22
81127b44:	402d883a 	mov	r22,r8
81127b48:	9809883a 	mov	r4,r19
81127b4c:	880b883a 	mov	r5,r17
81127b50:	01800284 	movi	r6,10
81127b54:	000f883a 	mov	r7,zero
81127b58:	11362240 	call	81136224 <__umoddi3>
81127b5c:	10800c04 	addi	r2,r2,48
81127b60:	843fffc4 	addi	r16,r16,-1
81127b64:	9809883a 	mov	r4,r19
81127b68:	880b883a 	mov	r5,r17
81127b6c:	80800005 	stb	r2,0(r16)
81127b70:	01800284 	movi	r6,10
81127b74:	000f883a 	mov	r7,zero
81127b78:	1135ca40 	call	81135ca4 <__udivdi3>
81127b7c:	1027883a 	mov	r19,r2
81127b80:	10c4b03a 	or	r2,r2,r3
81127b84:	1823883a 	mov	r17,r3
81127b88:	103fef1e 	bne	r2,zero,81127b48 <__reset+0xfb107b48>
81127b8c:	d8c02817 	ldw	r3,160(sp)
81127b90:	dc402a17 	ldw	r17,168(sp)
81127b94:	b011883a 	mov	r8,r22
81127b98:	1c07c83a 	sub	r3,r3,r16
81127b9c:	d8c02e15 	stw	r3,184(sp)
81127ba0:	00005906 	br	81127d08 <___vfprintf_internal_r+0x724>
81127ba4:	18c03fcc 	andi	r3,r3,255
81127ba8:	1806fa1e 	bne	r3,zero,81129794 <___vfprintf_internal_r+0x21b0>
81127bac:	9080020c 	andi	r2,r18,8
81127bb0:	10048a26 	beq	r2,zero,81128ddc <___vfprintf_internal_r+0x17f8>
81127bb4:	d8c02d17 	ldw	r3,180(sp)
81127bb8:	d9002d17 	ldw	r4,180(sp)
81127bbc:	d9402d17 	ldw	r5,180(sp)
81127bc0:	18c00017 	ldw	r3,0(r3)
81127bc4:	21000117 	ldw	r4,4(r4)
81127bc8:	29400204 	addi	r5,r5,8
81127bcc:	d8c03615 	stw	r3,216(sp)
81127bd0:	d9003815 	stw	r4,224(sp)
81127bd4:	d9402d15 	stw	r5,180(sp)
81127bd8:	d9003617 	ldw	r4,216(sp)
81127bdc:	d9403817 	ldw	r5,224(sp)
81127be0:	da003d15 	stw	r8,244(sp)
81127be4:	04000044 	movi	r16,1
81127be8:	112fe380 	call	8112fe38 <__fpclassifyd>
81127bec:	da003d17 	ldw	r8,244(sp)
81127bf0:	14041f1e 	bne	r2,r16,81128c70 <___vfprintf_internal_r+0x168c>
81127bf4:	d9003617 	ldw	r4,216(sp)
81127bf8:	d9403817 	ldw	r5,224(sp)
81127bfc:	000d883a 	mov	r6,zero
81127c00:	000f883a 	mov	r7,zero
81127c04:	1137d400 	call	81137d40 <__ledf2>
81127c08:	da003d17 	ldw	r8,244(sp)
81127c0c:	1005be16 	blt	r2,zero,81129308 <___vfprintf_internal_r+0x1d24>
81127c10:	df002783 	ldbu	fp,158(sp)
81127c14:	008011c4 	movi	r2,71
81127c18:	1445330e 	bge	r2,r17,811290e8 <___vfprintf_internal_r+0x1b04>
81127c1c:	04204574 	movhi	r16,33045
81127c20:	84098904 	addi	r16,r16,9764
81127c24:	00c000c4 	movi	r3,3
81127c28:	00bfdfc4 	movi	r2,-129
81127c2c:	d8c02a15 	stw	r3,168(sp)
81127c30:	90a4703a 	and	r18,r18,r2
81127c34:	d8c02e15 	stw	r3,184(sp)
81127c38:	d8002915 	stw	zero,164(sp)
81127c3c:	d8003215 	stw	zero,200(sp)
81127c40:	00003706 	br	81127d20 <___vfprintf_internal_r+0x73c>
81127c44:	94800214 	ori	r18,r18,8
81127c48:	ac400007 	ldb	r17,0(r21)
81127c4c:	003ec806 	br	81127770 <__reset+0xfb107770>
81127c50:	18c03fcc 	andi	r3,r3,255
81127c54:	1806db1e 	bne	r3,zero,811297c4 <___vfprintf_internal_r+0x21e0>
81127c58:	94800414 	ori	r18,r18,16
81127c5c:	9080080c 	andi	r2,r18,32
81127c60:	1002d826 	beq	r2,zero,811287c4 <___vfprintf_internal_r+0x11e0>
81127c64:	d9402d17 	ldw	r5,180(sp)
81127c68:	d8c02917 	ldw	r3,164(sp)
81127c6c:	d8002785 	stb	zero,158(sp)
81127c70:	28800204 	addi	r2,r5,8
81127c74:	2cc00017 	ldw	r19,0(r5)
81127c78:	2d800117 	ldw	r22,4(r5)
81127c7c:	18048f16 	blt	r3,zero,81128ebc <___vfprintf_internal_r+0x18d8>
81127c80:	013fdfc4 	movi	r4,-129
81127c84:	9d86b03a 	or	r3,r19,r22
81127c88:	d8802d15 	stw	r2,180(sp)
81127c8c:	9124703a 	and	r18,r18,r4
81127c90:	1802d91e 	bne	r3,zero,811287f8 <___vfprintf_internal_r+0x1214>
81127c94:	d8c02917 	ldw	r3,164(sp)
81127c98:	0039883a 	mov	fp,zero
81127c9c:	1805c326 	beq	r3,zero,811293ac <___vfprintf_internal_r+0x1dc8>
81127ca0:	0027883a 	mov	r19,zero
81127ca4:	002d883a 	mov	r22,zero
81127ca8:	dc001e04 	addi	r16,sp,120
81127cac:	9806d0fa 	srli	r3,r19,3
81127cb0:	b008977a 	slli	r4,r22,29
81127cb4:	b02cd0fa 	srli	r22,r22,3
81127cb8:	9cc001cc 	andi	r19,r19,7
81127cbc:	98800c04 	addi	r2,r19,48
81127cc0:	843fffc4 	addi	r16,r16,-1
81127cc4:	20e6b03a 	or	r19,r4,r3
81127cc8:	80800005 	stb	r2,0(r16)
81127ccc:	9d86b03a 	or	r3,r19,r22
81127cd0:	183ff61e 	bne	r3,zero,81127cac <__reset+0xfb107cac>
81127cd4:	90c0004c 	andi	r3,r18,1
81127cd8:	18013b26 	beq	r3,zero,811281c8 <___vfprintf_internal_r+0xbe4>
81127cdc:	10803fcc 	andi	r2,r2,255
81127ce0:	1080201c 	xori	r2,r2,128
81127ce4:	10bfe004 	addi	r2,r2,-128
81127ce8:	00c00c04 	movi	r3,48
81127cec:	10c13626 	beq	r2,r3,811281c8 <___vfprintf_internal_r+0xbe4>
81127cf0:	80ffffc5 	stb	r3,-1(r16)
81127cf4:	d8c02817 	ldw	r3,160(sp)
81127cf8:	80bfffc4 	addi	r2,r16,-1
81127cfc:	1021883a 	mov	r16,r2
81127d00:	1887c83a 	sub	r3,r3,r2
81127d04:	d8c02e15 	stw	r3,184(sp)
81127d08:	d8802e17 	ldw	r2,184(sp)
81127d0c:	d9002917 	ldw	r4,164(sp)
81127d10:	1100010e 	bge	r2,r4,81127d18 <___vfprintf_internal_r+0x734>
81127d14:	2005883a 	mov	r2,r4
81127d18:	d8802a15 	stw	r2,168(sp)
81127d1c:	d8003215 	stw	zero,200(sp)
81127d20:	e7003fcc 	andi	fp,fp,255
81127d24:	e700201c 	xori	fp,fp,128
81127d28:	e73fe004 	addi	fp,fp,-128
81127d2c:	e0000326 	beq	fp,zero,81127d3c <___vfprintf_internal_r+0x758>
81127d30:	d8c02a17 	ldw	r3,168(sp)
81127d34:	18c00044 	addi	r3,r3,1
81127d38:	d8c02a15 	stw	r3,168(sp)
81127d3c:	90c0008c 	andi	r3,r18,2
81127d40:	d8c02b15 	stw	r3,172(sp)
81127d44:	18000326 	beq	r3,zero,81127d54 <___vfprintf_internal_r+0x770>
81127d48:	d8c02a17 	ldw	r3,168(sp)
81127d4c:	18c00084 	addi	r3,r3,2
81127d50:	d8c02a15 	stw	r3,168(sp)
81127d54:	90c0210c 	andi	r3,r18,132
81127d58:	d8c03015 	stw	r3,192(sp)
81127d5c:	1801a31e 	bne	r3,zero,811283ec <___vfprintf_internal_r+0xe08>
81127d60:	d9003117 	ldw	r4,196(sp)
81127d64:	d8c02a17 	ldw	r3,168(sp)
81127d68:	20e7c83a 	sub	r19,r4,r3
81127d6c:	04c19f0e 	bge	zero,r19,811283ec <___vfprintf_internal_r+0xe08>
81127d70:	02400404 	movi	r9,16
81127d74:	d8c02017 	ldw	r3,128(sp)
81127d78:	d8801f17 	ldw	r2,124(sp)
81127d7c:	4cc50d0e 	bge	r9,r19,811291b4 <___vfprintf_internal_r+0x1bd0>
81127d80:	01604574 	movhi	r5,33045
81127d84:	2949a484 	addi	r5,r5,9874
81127d88:	dc403b15 	stw	r17,236(sp)
81127d8c:	d9403515 	stw	r5,212(sp)
81127d90:	9823883a 	mov	r17,r19
81127d94:	482d883a 	mov	r22,r9
81127d98:	9027883a 	mov	r19,r18
81127d9c:	070001c4 	movi	fp,7
81127da0:	8025883a 	mov	r18,r16
81127da4:	dc002c17 	ldw	r16,176(sp)
81127da8:	00000306 	br	81127db8 <___vfprintf_internal_r+0x7d4>
81127dac:	8c7ffc04 	addi	r17,r17,-16
81127db0:	42000204 	addi	r8,r8,8
81127db4:	b440130e 	bge	r22,r17,81127e04 <___vfprintf_internal_r+0x820>
81127db8:	01204574 	movhi	r4,33045
81127dbc:	18c00404 	addi	r3,r3,16
81127dc0:	10800044 	addi	r2,r2,1
81127dc4:	2109a484 	addi	r4,r4,9874
81127dc8:	41000015 	stw	r4,0(r8)
81127dcc:	45800115 	stw	r22,4(r8)
81127dd0:	d8c02015 	stw	r3,128(sp)
81127dd4:	d8801f15 	stw	r2,124(sp)
81127dd8:	e0bff40e 	bge	fp,r2,81127dac <__reset+0xfb107dac>
81127ddc:	d9801e04 	addi	r6,sp,120
81127de0:	b80b883a 	mov	r5,r23
81127de4:	8009883a 	mov	r4,r16
81127de8:	11334ec0 	call	811334ec <__sprint_r>
81127dec:	103f011e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81127df0:	8c7ffc04 	addi	r17,r17,-16
81127df4:	d8c02017 	ldw	r3,128(sp)
81127df8:	d8801f17 	ldw	r2,124(sp)
81127dfc:	da000404 	addi	r8,sp,16
81127e00:	b47fed16 	blt	r22,r17,81127db8 <__reset+0xfb107db8>
81127e04:	9021883a 	mov	r16,r18
81127e08:	9825883a 	mov	r18,r19
81127e0c:	8827883a 	mov	r19,r17
81127e10:	dc403b17 	ldw	r17,236(sp)
81127e14:	d9403517 	ldw	r5,212(sp)
81127e18:	98c7883a 	add	r3,r19,r3
81127e1c:	10800044 	addi	r2,r2,1
81127e20:	41400015 	stw	r5,0(r8)
81127e24:	44c00115 	stw	r19,4(r8)
81127e28:	d8c02015 	stw	r3,128(sp)
81127e2c:	d8801f15 	stw	r2,124(sp)
81127e30:	010001c4 	movi	r4,7
81127e34:	2082a316 	blt	r4,r2,811288c4 <___vfprintf_internal_r+0x12e0>
81127e38:	df002787 	ldb	fp,158(sp)
81127e3c:	42000204 	addi	r8,r8,8
81127e40:	e0000c26 	beq	fp,zero,81127e74 <___vfprintf_internal_r+0x890>
81127e44:	d8801f17 	ldw	r2,124(sp)
81127e48:	d9002784 	addi	r4,sp,158
81127e4c:	18c00044 	addi	r3,r3,1
81127e50:	10800044 	addi	r2,r2,1
81127e54:	41000015 	stw	r4,0(r8)
81127e58:	01000044 	movi	r4,1
81127e5c:	41000115 	stw	r4,4(r8)
81127e60:	d8c02015 	stw	r3,128(sp)
81127e64:	d8801f15 	stw	r2,124(sp)
81127e68:	010001c4 	movi	r4,7
81127e6c:	20823c16 	blt	r4,r2,81128760 <___vfprintf_internal_r+0x117c>
81127e70:	42000204 	addi	r8,r8,8
81127e74:	d8802b17 	ldw	r2,172(sp)
81127e78:	10000c26 	beq	r2,zero,81127eac <___vfprintf_internal_r+0x8c8>
81127e7c:	d8801f17 	ldw	r2,124(sp)
81127e80:	d9002704 	addi	r4,sp,156
81127e84:	18c00084 	addi	r3,r3,2
81127e88:	10800044 	addi	r2,r2,1
81127e8c:	41000015 	stw	r4,0(r8)
81127e90:	01000084 	movi	r4,2
81127e94:	41000115 	stw	r4,4(r8)
81127e98:	d8c02015 	stw	r3,128(sp)
81127e9c:	d8801f15 	stw	r2,124(sp)
81127ea0:	010001c4 	movi	r4,7
81127ea4:	20823616 	blt	r4,r2,81128780 <___vfprintf_internal_r+0x119c>
81127ea8:	42000204 	addi	r8,r8,8
81127eac:	d9003017 	ldw	r4,192(sp)
81127eb0:	00802004 	movi	r2,128
81127eb4:	20819926 	beq	r4,r2,8112851c <___vfprintf_internal_r+0xf38>
81127eb8:	d9402917 	ldw	r5,164(sp)
81127ebc:	d8802e17 	ldw	r2,184(sp)
81127ec0:	28adc83a 	sub	r22,r5,r2
81127ec4:	0580310e 	bge	zero,r22,81127f8c <___vfprintf_internal_r+0x9a8>
81127ec8:	07000404 	movi	fp,16
81127ecc:	d8801f17 	ldw	r2,124(sp)
81127ed0:	e584140e 	bge	fp,r22,81128f24 <___vfprintf_internal_r+0x1940>
81127ed4:	01604574 	movhi	r5,33045
81127ed8:	2949a084 	addi	r5,r5,9858
81127edc:	dc402915 	stw	r17,164(sp)
81127ee0:	d9402b15 	stw	r5,172(sp)
81127ee4:	b023883a 	mov	r17,r22
81127ee8:	04c001c4 	movi	r19,7
81127eec:	a82d883a 	mov	r22,r21
81127ef0:	902b883a 	mov	r21,r18
81127ef4:	8025883a 	mov	r18,r16
81127ef8:	dc002c17 	ldw	r16,176(sp)
81127efc:	00000306 	br	81127f0c <___vfprintf_internal_r+0x928>
81127f00:	8c7ffc04 	addi	r17,r17,-16
81127f04:	42000204 	addi	r8,r8,8
81127f08:	e440110e 	bge	fp,r17,81127f50 <___vfprintf_internal_r+0x96c>
81127f0c:	18c00404 	addi	r3,r3,16
81127f10:	10800044 	addi	r2,r2,1
81127f14:	45000015 	stw	r20,0(r8)
81127f18:	47000115 	stw	fp,4(r8)
81127f1c:	d8c02015 	stw	r3,128(sp)
81127f20:	d8801f15 	stw	r2,124(sp)
81127f24:	98bff60e 	bge	r19,r2,81127f00 <__reset+0xfb107f00>
81127f28:	d9801e04 	addi	r6,sp,120
81127f2c:	b80b883a 	mov	r5,r23
81127f30:	8009883a 	mov	r4,r16
81127f34:	11334ec0 	call	811334ec <__sprint_r>
81127f38:	103eae1e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81127f3c:	8c7ffc04 	addi	r17,r17,-16
81127f40:	d8c02017 	ldw	r3,128(sp)
81127f44:	d8801f17 	ldw	r2,124(sp)
81127f48:	da000404 	addi	r8,sp,16
81127f4c:	e47fef16 	blt	fp,r17,81127f0c <__reset+0xfb107f0c>
81127f50:	9021883a 	mov	r16,r18
81127f54:	a825883a 	mov	r18,r21
81127f58:	b02b883a 	mov	r21,r22
81127f5c:	882d883a 	mov	r22,r17
81127f60:	dc402917 	ldw	r17,164(sp)
81127f64:	d9002b17 	ldw	r4,172(sp)
81127f68:	1d87883a 	add	r3,r3,r22
81127f6c:	10800044 	addi	r2,r2,1
81127f70:	41000015 	stw	r4,0(r8)
81127f74:	45800115 	stw	r22,4(r8)
81127f78:	d8c02015 	stw	r3,128(sp)
81127f7c:	d8801f15 	stw	r2,124(sp)
81127f80:	010001c4 	movi	r4,7
81127f84:	2081ee16 	blt	r4,r2,81128740 <___vfprintf_internal_r+0x115c>
81127f88:	42000204 	addi	r8,r8,8
81127f8c:	9080400c 	andi	r2,r18,256
81127f90:	1001181e 	bne	r2,zero,811283f4 <___vfprintf_internal_r+0xe10>
81127f94:	d9402e17 	ldw	r5,184(sp)
81127f98:	d8801f17 	ldw	r2,124(sp)
81127f9c:	44000015 	stw	r16,0(r8)
81127fa0:	1947883a 	add	r3,r3,r5
81127fa4:	10800044 	addi	r2,r2,1
81127fa8:	41400115 	stw	r5,4(r8)
81127fac:	d8c02015 	stw	r3,128(sp)
81127fb0:	d8801f15 	stw	r2,124(sp)
81127fb4:	010001c4 	movi	r4,7
81127fb8:	2081d316 	blt	r4,r2,81128708 <___vfprintf_internal_r+0x1124>
81127fbc:	42000204 	addi	r8,r8,8
81127fc0:	9480010c 	andi	r18,r18,4
81127fc4:	90003226 	beq	r18,zero,81128090 <___vfprintf_internal_r+0xaac>
81127fc8:	d9403117 	ldw	r5,196(sp)
81127fcc:	d8802a17 	ldw	r2,168(sp)
81127fd0:	28a1c83a 	sub	r16,r5,r2
81127fd4:	04002e0e 	bge	zero,r16,81128090 <___vfprintf_internal_r+0xaac>
81127fd8:	04400404 	movi	r17,16
81127fdc:	d8801f17 	ldw	r2,124(sp)
81127fe0:	8c04a20e 	bge	r17,r16,8112926c <___vfprintf_internal_r+0x1c88>
81127fe4:	01604574 	movhi	r5,33045
81127fe8:	2949a484 	addi	r5,r5,9874
81127fec:	d9403515 	stw	r5,212(sp)
81127ff0:	048001c4 	movi	r18,7
81127ff4:	dcc02c17 	ldw	r19,176(sp)
81127ff8:	00000306 	br	81128008 <___vfprintf_internal_r+0xa24>
81127ffc:	843ffc04 	addi	r16,r16,-16
81128000:	42000204 	addi	r8,r8,8
81128004:	8c00130e 	bge	r17,r16,81128054 <___vfprintf_internal_r+0xa70>
81128008:	01204574 	movhi	r4,33045
8112800c:	18c00404 	addi	r3,r3,16
81128010:	10800044 	addi	r2,r2,1
81128014:	2109a484 	addi	r4,r4,9874
81128018:	41000015 	stw	r4,0(r8)
8112801c:	44400115 	stw	r17,4(r8)
81128020:	d8c02015 	stw	r3,128(sp)
81128024:	d8801f15 	stw	r2,124(sp)
81128028:	90bff40e 	bge	r18,r2,81127ffc <__reset+0xfb107ffc>
8112802c:	d9801e04 	addi	r6,sp,120
81128030:	b80b883a 	mov	r5,r23
81128034:	9809883a 	mov	r4,r19
81128038:	11334ec0 	call	811334ec <__sprint_r>
8112803c:	103e6d1e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81128040:	843ffc04 	addi	r16,r16,-16
81128044:	d8c02017 	ldw	r3,128(sp)
81128048:	d8801f17 	ldw	r2,124(sp)
8112804c:	da000404 	addi	r8,sp,16
81128050:	8c3fed16 	blt	r17,r16,81128008 <__reset+0xfb108008>
81128054:	d9403517 	ldw	r5,212(sp)
81128058:	1c07883a 	add	r3,r3,r16
8112805c:	10800044 	addi	r2,r2,1
81128060:	41400015 	stw	r5,0(r8)
81128064:	44000115 	stw	r16,4(r8)
81128068:	d8c02015 	stw	r3,128(sp)
8112806c:	d8801f15 	stw	r2,124(sp)
81128070:	010001c4 	movi	r4,7
81128074:	2080060e 	bge	r4,r2,81128090 <___vfprintf_internal_r+0xaac>
81128078:	d9002c17 	ldw	r4,176(sp)
8112807c:	d9801e04 	addi	r6,sp,120
81128080:	b80b883a 	mov	r5,r23
81128084:	11334ec0 	call	811334ec <__sprint_r>
81128088:	103e5a1e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
8112808c:	d8c02017 	ldw	r3,128(sp)
81128090:	d8803117 	ldw	r2,196(sp)
81128094:	d9002a17 	ldw	r4,168(sp)
81128098:	1100010e 	bge	r2,r4,811280a0 <___vfprintf_internal_r+0xabc>
8112809c:	2005883a 	mov	r2,r4
811280a0:	d9402f17 	ldw	r5,188(sp)
811280a4:	288b883a 	add	r5,r5,r2
811280a8:	d9402f15 	stw	r5,188(sp)
811280ac:	18019e1e 	bne	r3,zero,81128728 <___vfprintf_internal_r+0x1144>
811280b0:	a8800007 	ldb	r2,0(r21)
811280b4:	d8001f15 	stw	zero,124(sp)
811280b8:	da000404 	addi	r8,sp,16
811280bc:	103d851e 	bne	r2,zero,811276d4 <__reset+0xfb1076d4>
811280c0:	a821883a 	mov	r16,r21
811280c4:	003d9b06 	br	81127734 <__reset+0xfb107734>
811280c8:	18c03fcc 	andi	r3,r3,255
811280cc:	1805c11e 	bne	r3,zero,811297d4 <___vfprintf_internal_r+0x21f0>
811280d0:	94800414 	ori	r18,r18,16
811280d4:	9080080c 	andi	r2,r18,32
811280d8:	10020c26 	beq	r2,zero,8112890c <___vfprintf_internal_r+0x1328>
811280dc:	d8802d17 	ldw	r2,180(sp)
811280e0:	d9002917 	ldw	r4,164(sp)
811280e4:	d8002785 	stb	zero,158(sp)
811280e8:	10c00204 	addi	r3,r2,8
811280ec:	14c00017 	ldw	r19,0(r2)
811280f0:	15800117 	ldw	r22,4(r2)
811280f4:	20040f16 	blt	r4,zero,81129134 <___vfprintf_internal_r+0x1b50>
811280f8:	013fdfc4 	movi	r4,-129
811280fc:	9d84b03a 	or	r2,r19,r22
81128100:	d8c02d15 	stw	r3,180(sp)
81128104:	9124703a 	and	r18,r18,r4
81128108:	0039883a 	mov	fp,zero
8112810c:	103e891e 	bne	r2,zero,81127b34 <__reset+0xfb107b34>
81128110:	d9002917 	ldw	r4,164(sp)
81128114:	2002c11e 	bne	r4,zero,81128c1c <___vfprintf_internal_r+0x1638>
81128118:	d8002915 	stw	zero,164(sp)
8112811c:	d8002e15 	stw	zero,184(sp)
81128120:	dc001e04 	addi	r16,sp,120
81128124:	003ef806 	br	81127d08 <__reset+0xfb107d08>
81128128:	18c03fcc 	andi	r3,r3,255
8112812c:	18059d1e 	bne	r3,zero,811297a4 <___vfprintf_internal_r+0x21c0>
81128130:	01604574 	movhi	r5,33045
81128134:	29498c04 	addi	r5,r5,9776
81128138:	d9403915 	stw	r5,228(sp)
8112813c:	9080080c 	andi	r2,r18,32
81128140:	10005226 	beq	r2,zero,8112828c <___vfprintf_internal_r+0xca8>
81128144:	d8802d17 	ldw	r2,180(sp)
81128148:	14c00017 	ldw	r19,0(r2)
8112814c:	15800117 	ldw	r22,4(r2)
81128150:	10800204 	addi	r2,r2,8
81128154:	d8802d15 	stw	r2,180(sp)
81128158:	9080004c 	andi	r2,r18,1
8112815c:	10019026 	beq	r2,zero,811287a0 <___vfprintf_internal_r+0x11bc>
81128160:	9d84b03a 	or	r2,r19,r22
81128164:	10036926 	beq	r2,zero,81128f0c <___vfprintf_internal_r+0x1928>
81128168:	d8c02917 	ldw	r3,164(sp)
8112816c:	00800c04 	movi	r2,48
81128170:	d8802705 	stb	r2,156(sp)
81128174:	dc402745 	stb	r17,157(sp)
81128178:	d8002785 	stb	zero,158(sp)
8112817c:	90800094 	ori	r2,r18,2
81128180:	18045d16 	blt	r3,zero,811292f8 <___vfprintf_internal_r+0x1d14>
81128184:	00bfdfc4 	movi	r2,-129
81128188:	90a4703a 	and	r18,r18,r2
8112818c:	94800094 	ori	r18,r18,2
81128190:	0039883a 	mov	fp,zero
81128194:	d9003917 	ldw	r4,228(sp)
81128198:	dc001e04 	addi	r16,sp,120
8112819c:	988003cc 	andi	r2,r19,15
811281a0:	b006973a 	slli	r3,r22,28
811281a4:	2085883a 	add	r2,r4,r2
811281a8:	9826d13a 	srli	r19,r19,4
811281ac:	10800003 	ldbu	r2,0(r2)
811281b0:	b02cd13a 	srli	r22,r22,4
811281b4:	843fffc4 	addi	r16,r16,-1
811281b8:	1ce6b03a 	or	r19,r3,r19
811281bc:	80800005 	stb	r2,0(r16)
811281c0:	9d84b03a 	or	r2,r19,r22
811281c4:	103ff51e 	bne	r2,zero,8112819c <__reset+0xfb10819c>
811281c8:	d8c02817 	ldw	r3,160(sp)
811281cc:	1c07c83a 	sub	r3,r3,r16
811281d0:	d8c02e15 	stw	r3,184(sp)
811281d4:	003ecc06 	br	81127d08 <__reset+0xfb107d08>
811281d8:	18c03fcc 	andi	r3,r3,255
811281dc:	183e9f26 	beq	r3,zero,81127c5c <__reset+0xfb107c5c>
811281e0:	d9c02785 	stb	r7,158(sp)
811281e4:	003e9d06 	br	81127c5c <__reset+0xfb107c5c>
811281e8:	00c00044 	movi	r3,1
811281ec:	01c00ac4 	movi	r7,43
811281f0:	ac400007 	ldb	r17,0(r21)
811281f4:	003d5e06 	br	81127770 <__reset+0xfb107770>
811281f8:	94800814 	ori	r18,r18,32
811281fc:	ac400007 	ldb	r17,0(r21)
81128200:	003d5b06 	br	81127770 <__reset+0xfb107770>
81128204:	d8c02d17 	ldw	r3,180(sp)
81128208:	d8002785 	stb	zero,158(sp)
8112820c:	1c000017 	ldw	r16,0(r3)
81128210:	1cc00104 	addi	r19,r3,4
81128214:	80041926 	beq	r16,zero,8112927c <___vfprintf_internal_r+0x1c98>
81128218:	d9002917 	ldw	r4,164(sp)
8112821c:	2003d016 	blt	r4,zero,81129160 <___vfprintf_internal_r+0x1b7c>
81128220:	200d883a 	mov	r6,r4
81128224:	000b883a 	mov	r5,zero
81128228:	8009883a 	mov	r4,r16
8112822c:	da003d15 	stw	r8,244(sp)
81128230:	112e5c80 	call	8112e5c8 <memchr>
81128234:	da003d17 	ldw	r8,244(sp)
81128238:	10045426 	beq	r2,zero,8112938c <___vfprintf_internal_r+0x1da8>
8112823c:	1405c83a 	sub	r2,r2,r16
81128240:	d8802e15 	stw	r2,184(sp)
81128244:	1003cc16 	blt	r2,zero,81129178 <___vfprintf_internal_r+0x1b94>
81128248:	df002783 	ldbu	fp,158(sp)
8112824c:	d8802a15 	stw	r2,168(sp)
81128250:	dcc02d15 	stw	r19,180(sp)
81128254:	d8002915 	stw	zero,164(sp)
81128258:	d8003215 	stw	zero,200(sp)
8112825c:	003eb006 	br	81127d20 <__reset+0xfb107d20>
81128260:	18c03fcc 	andi	r3,r3,255
81128264:	183f9b26 	beq	r3,zero,811280d4 <__reset+0xfb1080d4>
81128268:	d9c02785 	stb	r7,158(sp)
8112826c:	003f9906 	br	811280d4 <__reset+0xfb1080d4>
81128270:	18c03fcc 	andi	r3,r3,255
81128274:	1805551e 	bne	r3,zero,811297cc <___vfprintf_internal_r+0x21e8>
81128278:	01604574 	movhi	r5,33045
8112827c:	29499104 	addi	r5,r5,9796
81128280:	d9403915 	stw	r5,228(sp)
81128284:	9080080c 	andi	r2,r18,32
81128288:	103fae1e 	bne	r2,zero,81128144 <__reset+0xfb108144>
8112828c:	9080040c 	andi	r2,r18,16
81128290:	1002de26 	beq	r2,zero,81128e0c <___vfprintf_internal_r+0x1828>
81128294:	d8c02d17 	ldw	r3,180(sp)
81128298:	002d883a 	mov	r22,zero
8112829c:	1cc00017 	ldw	r19,0(r3)
811282a0:	18c00104 	addi	r3,r3,4
811282a4:	d8c02d15 	stw	r3,180(sp)
811282a8:	003fab06 	br	81128158 <__reset+0xfb108158>
811282ac:	38803fcc 	andi	r2,r7,255
811282b0:	1080201c 	xori	r2,r2,128
811282b4:	10bfe004 	addi	r2,r2,-128
811282b8:	1002d21e 	bne	r2,zero,81128e04 <___vfprintf_internal_r+0x1820>
811282bc:	00c00044 	movi	r3,1
811282c0:	01c00804 	movi	r7,32
811282c4:	ac400007 	ldb	r17,0(r21)
811282c8:	003d2906 	br	81127770 <__reset+0xfb107770>
811282cc:	94800054 	ori	r18,r18,1
811282d0:	ac400007 	ldb	r17,0(r21)
811282d4:	003d2606 	br	81127770 <__reset+0xfb107770>
811282d8:	18c03fcc 	andi	r3,r3,255
811282dc:	183e0526 	beq	r3,zero,81127af4 <__reset+0xfb107af4>
811282e0:	d9c02785 	stb	r7,158(sp)
811282e4:	003e0306 	br	81127af4 <__reset+0xfb107af4>
811282e8:	94801014 	ori	r18,r18,64
811282ec:	ac400007 	ldb	r17,0(r21)
811282f0:	003d1f06 	br	81127770 <__reset+0xfb107770>
811282f4:	ac400007 	ldb	r17,0(r21)
811282f8:	8a438726 	beq	r17,r9,81129118 <___vfprintf_internal_r+0x1b34>
811282fc:	94800414 	ori	r18,r18,16
81128300:	003d1b06 	br	81127770 <__reset+0xfb107770>
81128304:	18c03fcc 	andi	r3,r3,255
81128308:	1805341e 	bne	r3,zero,811297dc <___vfprintf_internal_r+0x21f8>
8112830c:	9080080c 	andi	r2,r18,32
81128310:	1002cd26 	beq	r2,zero,81128e48 <___vfprintf_internal_r+0x1864>
81128314:	d9402d17 	ldw	r5,180(sp)
81128318:	d9002f17 	ldw	r4,188(sp)
8112831c:	28800017 	ldw	r2,0(r5)
81128320:	2007d7fa 	srai	r3,r4,31
81128324:	29400104 	addi	r5,r5,4
81128328:	d9402d15 	stw	r5,180(sp)
8112832c:	11000015 	stw	r4,0(r2)
81128330:	10c00115 	stw	r3,4(r2)
81128334:	003ce506 	br	811276cc <__reset+0xfb1076cc>
81128338:	d8c02d17 	ldw	r3,180(sp)
8112833c:	d9002d17 	ldw	r4,180(sp)
81128340:	d8002785 	stb	zero,158(sp)
81128344:	18800017 	ldw	r2,0(r3)
81128348:	21000104 	addi	r4,r4,4
8112834c:	00c00044 	movi	r3,1
81128350:	d8c02a15 	stw	r3,168(sp)
81128354:	d8801405 	stb	r2,80(sp)
81128358:	d9002d15 	stw	r4,180(sp)
8112835c:	d8c02e15 	stw	r3,184(sp)
81128360:	d8002915 	stw	zero,164(sp)
81128364:	d8003215 	stw	zero,200(sp)
81128368:	dc001404 	addi	r16,sp,80
8112836c:	0039883a 	mov	fp,zero
81128370:	003e7206 	br	81127d3c <__reset+0xfb107d3c>
81128374:	01204574 	movhi	r4,33045
81128378:	21099104 	addi	r4,r4,9796
8112837c:	0039883a 	mov	fp,zero
81128380:	d9003915 	stw	r4,228(sp)
81128384:	04401e04 	movi	r17,120
81128388:	003f8206 	br	81128194 <__reset+0xfb108194>
8112838c:	18c03fcc 	andi	r3,r3,255
81128390:	1805061e 	bne	r3,zero,811297ac <___vfprintf_internal_r+0x21c8>
81128394:	883d9126 	beq	r17,zero,811279dc <__reset+0xfb1079dc>
81128398:	00c00044 	movi	r3,1
8112839c:	d8c02a15 	stw	r3,168(sp)
811283a0:	dc401405 	stb	r17,80(sp)
811283a4:	d8002785 	stb	zero,158(sp)
811283a8:	003fec06 	br	8112835c <__reset+0xfb10835c>
811283ac:	01604574 	movhi	r5,33045
811283b0:	29499104 	addi	r5,r5,9796
811283b4:	d9403915 	stw	r5,228(sp)
811283b8:	d8c02d15 	stw	r3,180(sp)
811283bc:	1025883a 	mov	r18,r2
811283c0:	04401e04 	movi	r17,120
811283c4:	9d84b03a 	or	r2,r19,r22
811283c8:	1000fc1e 	bne	r2,zero,811287bc <___vfprintf_internal_r+0x11d8>
811283cc:	0039883a 	mov	fp,zero
811283d0:	00800084 	movi	r2,2
811283d4:	10803fcc 	andi	r2,r2,255
811283d8:	00c00044 	movi	r3,1
811283dc:	10c20f26 	beq	r2,r3,81128c1c <___vfprintf_internal_r+0x1638>
811283e0:	00c00084 	movi	r3,2
811283e4:	10fd6326 	beq	r2,r3,81127974 <__reset+0xfb107974>
811283e8:	003e2d06 	br	81127ca0 <__reset+0xfb107ca0>
811283ec:	d8c02017 	ldw	r3,128(sp)
811283f0:	003e9306 	br	81127e40 <__reset+0xfb107e40>
811283f4:	00801944 	movi	r2,101
811283f8:	14407e0e 	bge	r2,r17,811285f4 <___vfprintf_internal_r+0x1010>
811283fc:	d9003617 	ldw	r4,216(sp)
81128400:	d9403817 	ldw	r5,224(sp)
81128404:	000d883a 	mov	r6,zero
81128408:	000f883a 	mov	r7,zero
8112840c:	d8c03c15 	stw	r3,240(sp)
81128410:	da003d15 	stw	r8,244(sp)
81128414:	1137cb80 	call	81137cb8 <__eqdf2>
81128418:	d8c03c17 	ldw	r3,240(sp)
8112841c:	da003d17 	ldw	r8,244(sp)
81128420:	1000f71e 	bne	r2,zero,81128800 <___vfprintf_internal_r+0x121c>
81128424:	d8801f17 	ldw	r2,124(sp)
81128428:	01204574 	movhi	r4,33045
8112842c:	21099804 	addi	r4,r4,9824
81128430:	18c00044 	addi	r3,r3,1
81128434:	10800044 	addi	r2,r2,1
81128438:	41000015 	stw	r4,0(r8)
8112843c:	01000044 	movi	r4,1
81128440:	41000115 	stw	r4,4(r8)
81128444:	d8c02015 	stw	r3,128(sp)
81128448:	d8801f15 	stw	r2,124(sp)
8112844c:	010001c4 	movi	r4,7
81128450:	2082b816 	blt	r4,r2,81128f34 <___vfprintf_internal_r+0x1950>
81128454:	42000204 	addi	r8,r8,8
81128458:	d8802617 	ldw	r2,152(sp)
8112845c:	d9403317 	ldw	r5,204(sp)
81128460:	11400216 	blt	r2,r5,8112846c <___vfprintf_internal_r+0xe88>
81128464:	9080004c 	andi	r2,r18,1
81128468:	103ed526 	beq	r2,zero,81127fc0 <__reset+0xfb107fc0>
8112846c:	d8803717 	ldw	r2,220(sp)
81128470:	d9003417 	ldw	r4,208(sp)
81128474:	d9403717 	ldw	r5,220(sp)
81128478:	1887883a 	add	r3,r3,r2
8112847c:	d8801f17 	ldw	r2,124(sp)
81128480:	41000015 	stw	r4,0(r8)
81128484:	41400115 	stw	r5,4(r8)
81128488:	10800044 	addi	r2,r2,1
8112848c:	d8c02015 	stw	r3,128(sp)
81128490:	d8801f15 	stw	r2,124(sp)
81128494:	010001c4 	movi	r4,7
81128498:	20832916 	blt	r4,r2,81129140 <___vfprintf_internal_r+0x1b5c>
8112849c:	42000204 	addi	r8,r8,8
811284a0:	d8803317 	ldw	r2,204(sp)
811284a4:	143fffc4 	addi	r16,r2,-1
811284a8:	043ec50e 	bge	zero,r16,81127fc0 <__reset+0xfb107fc0>
811284ac:	04400404 	movi	r17,16
811284b0:	d8801f17 	ldw	r2,124(sp)
811284b4:	8c00880e 	bge	r17,r16,811286d8 <___vfprintf_internal_r+0x10f4>
811284b8:	01604574 	movhi	r5,33045
811284bc:	2949a084 	addi	r5,r5,9858
811284c0:	d9402b15 	stw	r5,172(sp)
811284c4:	058001c4 	movi	r22,7
811284c8:	dcc02c17 	ldw	r19,176(sp)
811284cc:	00000306 	br	811284dc <___vfprintf_internal_r+0xef8>
811284d0:	42000204 	addi	r8,r8,8
811284d4:	843ffc04 	addi	r16,r16,-16
811284d8:	8c00820e 	bge	r17,r16,811286e4 <___vfprintf_internal_r+0x1100>
811284dc:	18c00404 	addi	r3,r3,16
811284e0:	10800044 	addi	r2,r2,1
811284e4:	45000015 	stw	r20,0(r8)
811284e8:	44400115 	stw	r17,4(r8)
811284ec:	d8c02015 	stw	r3,128(sp)
811284f0:	d8801f15 	stw	r2,124(sp)
811284f4:	b0bff60e 	bge	r22,r2,811284d0 <__reset+0xfb1084d0>
811284f8:	d9801e04 	addi	r6,sp,120
811284fc:	b80b883a 	mov	r5,r23
81128500:	9809883a 	mov	r4,r19
81128504:	11334ec0 	call	811334ec <__sprint_r>
81128508:	103d3a1e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
8112850c:	d8c02017 	ldw	r3,128(sp)
81128510:	d8801f17 	ldw	r2,124(sp)
81128514:	da000404 	addi	r8,sp,16
81128518:	003fee06 	br	811284d4 <__reset+0xfb1084d4>
8112851c:	d9403117 	ldw	r5,196(sp)
81128520:	d8802a17 	ldw	r2,168(sp)
81128524:	28adc83a 	sub	r22,r5,r2
81128528:	05be630e 	bge	zero,r22,81127eb8 <__reset+0xfb107eb8>
8112852c:	07000404 	movi	fp,16
81128530:	d8801f17 	ldw	r2,124(sp)
81128534:	e5838f0e 	bge	fp,r22,81129374 <___vfprintf_internal_r+0x1d90>
81128538:	01604574 	movhi	r5,33045
8112853c:	2949a084 	addi	r5,r5,9858
81128540:	dc403015 	stw	r17,192(sp)
81128544:	d9402b15 	stw	r5,172(sp)
81128548:	b023883a 	mov	r17,r22
8112854c:	04c001c4 	movi	r19,7
81128550:	a82d883a 	mov	r22,r21
81128554:	902b883a 	mov	r21,r18
81128558:	8025883a 	mov	r18,r16
8112855c:	dc002c17 	ldw	r16,176(sp)
81128560:	00000306 	br	81128570 <___vfprintf_internal_r+0xf8c>
81128564:	8c7ffc04 	addi	r17,r17,-16
81128568:	42000204 	addi	r8,r8,8
8112856c:	e440110e 	bge	fp,r17,811285b4 <___vfprintf_internal_r+0xfd0>
81128570:	18c00404 	addi	r3,r3,16
81128574:	10800044 	addi	r2,r2,1
81128578:	45000015 	stw	r20,0(r8)
8112857c:	47000115 	stw	fp,4(r8)
81128580:	d8c02015 	stw	r3,128(sp)
81128584:	d8801f15 	stw	r2,124(sp)
81128588:	98bff60e 	bge	r19,r2,81128564 <__reset+0xfb108564>
8112858c:	d9801e04 	addi	r6,sp,120
81128590:	b80b883a 	mov	r5,r23
81128594:	8009883a 	mov	r4,r16
81128598:	11334ec0 	call	811334ec <__sprint_r>
8112859c:	103d151e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
811285a0:	8c7ffc04 	addi	r17,r17,-16
811285a4:	d8c02017 	ldw	r3,128(sp)
811285a8:	d8801f17 	ldw	r2,124(sp)
811285ac:	da000404 	addi	r8,sp,16
811285b0:	e47fef16 	blt	fp,r17,81128570 <__reset+0xfb108570>
811285b4:	9021883a 	mov	r16,r18
811285b8:	a825883a 	mov	r18,r21
811285bc:	b02b883a 	mov	r21,r22
811285c0:	882d883a 	mov	r22,r17
811285c4:	dc403017 	ldw	r17,192(sp)
811285c8:	d9002b17 	ldw	r4,172(sp)
811285cc:	1d87883a 	add	r3,r3,r22
811285d0:	10800044 	addi	r2,r2,1
811285d4:	41000015 	stw	r4,0(r8)
811285d8:	45800115 	stw	r22,4(r8)
811285dc:	d8c02015 	stw	r3,128(sp)
811285e0:	d8801f15 	stw	r2,124(sp)
811285e4:	010001c4 	movi	r4,7
811285e8:	20818e16 	blt	r4,r2,81128c24 <___vfprintf_internal_r+0x1640>
811285ec:	42000204 	addi	r8,r8,8
811285f0:	003e3106 	br	81127eb8 <__reset+0xfb107eb8>
811285f4:	d9403317 	ldw	r5,204(sp)
811285f8:	00800044 	movi	r2,1
811285fc:	18c00044 	addi	r3,r3,1
81128600:	1141530e 	bge	r2,r5,81128b50 <___vfprintf_internal_r+0x156c>
81128604:	dc401f17 	ldw	r17,124(sp)
81128608:	00800044 	movi	r2,1
8112860c:	40800115 	stw	r2,4(r8)
81128610:	8c400044 	addi	r17,r17,1
81128614:	44000015 	stw	r16,0(r8)
81128618:	d8c02015 	stw	r3,128(sp)
8112861c:	dc401f15 	stw	r17,124(sp)
81128620:	008001c4 	movi	r2,7
81128624:	14416b16 	blt	r2,r17,81128bd4 <___vfprintf_internal_r+0x15f0>
81128628:	42000204 	addi	r8,r8,8
8112862c:	d8803717 	ldw	r2,220(sp)
81128630:	d9003417 	ldw	r4,208(sp)
81128634:	8c400044 	addi	r17,r17,1
81128638:	10c7883a 	add	r3,r2,r3
8112863c:	40800115 	stw	r2,4(r8)
81128640:	41000015 	stw	r4,0(r8)
81128644:	d8c02015 	stw	r3,128(sp)
81128648:	dc401f15 	stw	r17,124(sp)
8112864c:	008001c4 	movi	r2,7
81128650:	14416916 	blt	r2,r17,81128bf8 <___vfprintf_internal_r+0x1614>
81128654:	45800204 	addi	r22,r8,8
81128658:	d9003617 	ldw	r4,216(sp)
8112865c:	d9403817 	ldw	r5,224(sp)
81128660:	000d883a 	mov	r6,zero
81128664:	000f883a 	mov	r7,zero
81128668:	d8c03c15 	stw	r3,240(sp)
8112866c:	1137cb80 	call	81137cb8 <__eqdf2>
81128670:	d8c03c17 	ldw	r3,240(sp)
81128674:	1000bc26 	beq	r2,zero,81128968 <___vfprintf_internal_r+0x1384>
81128678:	d9403317 	ldw	r5,204(sp)
8112867c:	84000044 	addi	r16,r16,1
81128680:	8c400044 	addi	r17,r17,1
81128684:	28bfffc4 	addi	r2,r5,-1
81128688:	1887883a 	add	r3,r3,r2
8112868c:	b0800115 	stw	r2,4(r22)
81128690:	b4000015 	stw	r16,0(r22)
81128694:	d8c02015 	stw	r3,128(sp)
81128698:	dc401f15 	stw	r17,124(sp)
8112869c:	008001c4 	movi	r2,7
811286a0:	14414316 	blt	r2,r17,81128bb0 <___vfprintf_internal_r+0x15cc>
811286a4:	b5800204 	addi	r22,r22,8
811286a8:	d9003a17 	ldw	r4,232(sp)
811286ac:	df0022c4 	addi	fp,sp,139
811286b0:	8c400044 	addi	r17,r17,1
811286b4:	20c7883a 	add	r3,r4,r3
811286b8:	b7000015 	stw	fp,0(r22)
811286bc:	b1000115 	stw	r4,4(r22)
811286c0:	d8c02015 	stw	r3,128(sp)
811286c4:	dc401f15 	stw	r17,124(sp)
811286c8:	008001c4 	movi	r2,7
811286cc:	14400e16 	blt	r2,r17,81128708 <___vfprintf_internal_r+0x1124>
811286d0:	b2000204 	addi	r8,r22,8
811286d4:	003e3a06 	br	81127fc0 <__reset+0xfb107fc0>
811286d8:	01204574 	movhi	r4,33045
811286dc:	2109a084 	addi	r4,r4,9858
811286e0:	d9002b15 	stw	r4,172(sp)
811286e4:	d9002b17 	ldw	r4,172(sp)
811286e8:	1c07883a 	add	r3,r3,r16
811286ec:	44000115 	stw	r16,4(r8)
811286f0:	41000015 	stw	r4,0(r8)
811286f4:	10800044 	addi	r2,r2,1
811286f8:	d8c02015 	stw	r3,128(sp)
811286fc:	d8801f15 	stw	r2,124(sp)
81128700:	010001c4 	movi	r4,7
81128704:	20be2d0e 	bge	r4,r2,81127fbc <__reset+0xfb107fbc>
81128708:	d9002c17 	ldw	r4,176(sp)
8112870c:	d9801e04 	addi	r6,sp,120
81128710:	b80b883a 	mov	r5,r23
81128714:	11334ec0 	call	811334ec <__sprint_r>
81128718:	103cb61e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
8112871c:	d8c02017 	ldw	r3,128(sp)
81128720:	da000404 	addi	r8,sp,16
81128724:	003e2606 	br	81127fc0 <__reset+0xfb107fc0>
81128728:	d9002c17 	ldw	r4,176(sp)
8112872c:	d9801e04 	addi	r6,sp,120
81128730:	b80b883a 	mov	r5,r23
81128734:	11334ec0 	call	811334ec <__sprint_r>
81128738:	103e5d26 	beq	r2,zero,811280b0 <__reset+0xfb1080b0>
8112873c:	003cad06 	br	811279f4 <__reset+0xfb1079f4>
81128740:	d9002c17 	ldw	r4,176(sp)
81128744:	d9801e04 	addi	r6,sp,120
81128748:	b80b883a 	mov	r5,r23
8112874c:	11334ec0 	call	811334ec <__sprint_r>
81128750:	103ca81e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81128754:	d8c02017 	ldw	r3,128(sp)
81128758:	da000404 	addi	r8,sp,16
8112875c:	003e0b06 	br	81127f8c <__reset+0xfb107f8c>
81128760:	d9002c17 	ldw	r4,176(sp)
81128764:	d9801e04 	addi	r6,sp,120
81128768:	b80b883a 	mov	r5,r23
8112876c:	11334ec0 	call	811334ec <__sprint_r>
81128770:	103ca01e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81128774:	d8c02017 	ldw	r3,128(sp)
81128778:	da000404 	addi	r8,sp,16
8112877c:	003dbd06 	br	81127e74 <__reset+0xfb107e74>
81128780:	d9002c17 	ldw	r4,176(sp)
81128784:	d9801e04 	addi	r6,sp,120
81128788:	b80b883a 	mov	r5,r23
8112878c:	11334ec0 	call	811334ec <__sprint_r>
81128790:	103c981e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81128794:	d8c02017 	ldw	r3,128(sp)
81128798:	da000404 	addi	r8,sp,16
8112879c:	003dc306 	br	81127eac <__reset+0xfb107eac>
811287a0:	d8802917 	ldw	r2,164(sp)
811287a4:	d8002785 	stb	zero,158(sp)
811287a8:	103f0616 	blt	r2,zero,811283c4 <__reset+0xfb1083c4>
811287ac:	00ffdfc4 	movi	r3,-129
811287b0:	9d84b03a 	or	r2,r19,r22
811287b4:	90e4703a 	and	r18,r18,r3
811287b8:	103c6b26 	beq	r2,zero,81127968 <__reset+0xfb107968>
811287bc:	0039883a 	mov	fp,zero
811287c0:	003e7406 	br	81128194 <__reset+0xfb108194>
811287c4:	9080040c 	andi	r2,r18,16
811287c8:	1001b326 	beq	r2,zero,81128e98 <___vfprintf_internal_r+0x18b4>
811287cc:	d9002d17 	ldw	r4,180(sp)
811287d0:	d9402917 	ldw	r5,164(sp)
811287d4:	d8002785 	stb	zero,158(sp)
811287d8:	20800104 	addi	r2,r4,4
811287dc:	24c00017 	ldw	r19,0(r4)
811287e0:	002d883a 	mov	r22,zero
811287e4:	2801b516 	blt	r5,zero,81128ebc <___vfprintf_internal_r+0x18d8>
811287e8:	00ffdfc4 	movi	r3,-129
811287ec:	d8802d15 	stw	r2,180(sp)
811287f0:	90e4703a 	and	r18,r18,r3
811287f4:	983d2726 	beq	r19,zero,81127c94 <__reset+0xfb107c94>
811287f8:	0039883a 	mov	fp,zero
811287fc:	003d2a06 	br	81127ca8 <__reset+0xfb107ca8>
81128800:	dc402617 	ldw	r17,152(sp)
81128804:	0441d30e 	bge	zero,r17,81128f54 <___vfprintf_internal_r+0x1970>
81128808:	dc403217 	ldw	r17,200(sp)
8112880c:	d8803317 	ldw	r2,204(sp)
81128810:	1440010e 	bge	r2,r17,81128818 <___vfprintf_internal_r+0x1234>
81128814:	1023883a 	mov	r17,r2
81128818:	04400a0e 	bge	zero,r17,81128844 <___vfprintf_internal_r+0x1260>
8112881c:	d8801f17 	ldw	r2,124(sp)
81128820:	1c47883a 	add	r3,r3,r17
81128824:	44000015 	stw	r16,0(r8)
81128828:	10800044 	addi	r2,r2,1
8112882c:	44400115 	stw	r17,4(r8)
81128830:	d8c02015 	stw	r3,128(sp)
81128834:	d8801f15 	stw	r2,124(sp)
81128838:	010001c4 	movi	r4,7
8112883c:	20826516 	blt	r4,r2,811291d4 <___vfprintf_internal_r+0x1bf0>
81128840:	42000204 	addi	r8,r8,8
81128844:	88026116 	blt	r17,zero,811291cc <___vfprintf_internal_r+0x1be8>
81128848:	d9003217 	ldw	r4,200(sp)
8112884c:	2463c83a 	sub	r17,r4,r17
81128850:	04407b0e 	bge	zero,r17,81128a40 <___vfprintf_internal_r+0x145c>
81128854:	05800404 	movi	r22,16
81128858:	d8801f17 	ldw	r2,124(sp)
8112885c:	b4419d0e 	bge	r22,r17,81128ed4 <___vfprintf_internal_r+0x18f0>
81128860:	01204574 	movhi	r4,33045
81128864:	2109a084 	addi	r4,r4,9858
81128868:	d9002b15 	stw	r4,172(sp)
8112886c:	070001c4 	movi	fp,7
81128870:	dcc02c17 	ldw	r19,176(sp)
81128874:	00000306 	br	81128884 <___vfprintf_internal_r+0x12a0>
81128878:	42000204 	addi	r8,r8,8
8112887c:	8c7ffc04 	addi	r17,r17,-16
81128880:	b441970e 	bge	r22,r17,81128ee0 <___vfprintf_internal_r+0x18fc>
81128884:	18c00404 	addi	r3,r3,16
81128888:	10800044 	addi	r2,r2,1
8112888c:	45000015 	stw	r20,0(r8)
81128890:	45800115 	stw	r22,4(r8)
81128894:	d8c02015 	stw	r3,128(sp)
81128898:	d8801f15 	stw	r2,124(sp)
8112889c:	e0bff60e 	bge	fp,r2,81128878 <__reset+0xfb108878>
811288a0:	d9801e04 	addi	r6,sp,120
811288a4:	b80b883a 	mov	r5,r23
811288a8:	9809883a 	mov	r4,r19
811288ac:	11334ec0 	call	811334ec <__sprint_r>
811288b0:	103c501e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
811288b4:	d8c02017 	ldw	r3,128(sp)
811288b8:	d8801f17 	ldw	r2,124(sp)
811288bc:	da000404 	addi	r8,sp,16
811288c0:	003fee06 	br	8112887c <__reset+0xfb10887c>
811288c4:	d9002c17 	ldw	r4,176(sp)
811288c8:	d9801e04 	addi	r6,sp,120
811288cc:	b80b883a 	mov	r5,r23
811288d0:	11334ec0 	call	811334ec <__sprint_r>
811288d4:	103c471e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
811288d8:	d8c02017 	ldw	r3,128(sp)
811288dc:	df002787 	ldb	fp,158(sp)
811288e0:	da000404 	addi	r8,sp,16
811288e4:	003d5606 	br	81127e40 <__reset+0xfb107e40>
811288e8:	9080040c 	andi	r2,r18,16
811288ec:	10016126 	beq	r2,zero,81128e74 <___vfprintf_internal_r+0x1890>
811288f0:	d8802d17 	ldw	r2,180(sp)
811288f4:	14c00017 	ldw	r19,0(r2)
811288f8:	10800104 	addi	r2,r2,4
811288fc:	d8802d15 	stw	r2,180(sp)
81128900:	982dd7fa 	srai	r22,r19,31
81128904:	b005883a 	mov	r2,r22
81128908:	003c8206 	br	81127b14 <__reset+0xfb107b14>
8112890c:	9080040c 	andi	r2,r18,16
81128910:	10003526 	beq	r2,zero,811289e8 <___vfprintf_internal_r+0x1404>
81128914:	d9402d17 	ldw	r5,180(sp)
81128918:	d8c02917 	ldw	r3,164(sp)
8112891c:	d8002785 	stb	zero,158(sp)
81128920:	28800104 	addi	r2,r5,4
81128924:	2cc00017 	ldw	r19,0(r5)
81128928:	002d883a 	mov	r22,zero
8112892c:	18003716 	blt	r3,zero,81128a0c <___vfprintf_internal_r+0x1428>
81128930:	00ffdfc4 	movi	r3,-129
81128934:	d8802d15 	stw	r2,180(sp)
81128938:	90e4703a 	and	r18,r18,r3
8112893c:	0039883a 	mov	fp,zero
81128940:	983df326 	beq	r19,zero,81128110 <__reset+0xfb108110>
81128944:	00800244 	movi	r2,9
81128948:	14fc7b36 	bltu	r2,r19,81127b38 <__reset+0xfb107b38>
8112894c:	d8c02817 	ldw	r3,160(sp)
81128950:	dc001dc4 	addi	r16,sp,119
81128954:	9cc00c04 	addi	r19,r19,48
81128958:	1c07c83a 	sub	r3,r3,r16
8112895c:	dcc01dc5 	stb	r19,119(sp)
81128960:	d8c02e15 	stw	r3,184(sp)
81128964:	003ce806 	br	81127d08 <__reset+0xfb107d08>
81128968:	d8803317 	ldw	r2,204(sp)
8112896c:	143fffc4 	addi	r16,r2,-1
81128970:	043f4d0e 	bge	zero,r16,811286a8 <__reset+0xfb1086a8>
81128974:	07000404 	movi	fp,16
81128978:	e400810e 	bge	fp,r16,81128b80 <___vfprintf_internal_r+0x159c>
8112897c:	01604574 	movhi	r5,33045
81128980:	2949a084 	addi	r5,r5,9858
81128984:	d9402b15 	stw	r5,172(sp)
81128988:	01c001c4 	movi	r7,7
8112898c:	dcc02c17 	ldw	r19,176(sp)
81128990:	00000306 	br	811289a0 <___vfprintf_internal_r+0x13bc>
81128994:	b5800204 	addi	r22,r22,8
81128998:	843ffc04 	addi	r16,r16,-16
8112899c:	e4007b0e 	bge	fp,r16,81128b8c <___vfprintf_internal_r+0x15a8>
811289a0:	18c00404 	addi	r3,r3,16
811289a4:	8c400044 	addi	r17,r17,1
811289a8:	b5000015 	stw	r20,0(r22)
811289ac:	b7000115 	stw	fp,4(r22)
811289b0:	d8c02015 	stw	r3,128(sp)
811289b4:	dc401f15 	stw	r17,124(sp)
811289b8:	3c7ff60e 	bge	r7,r17,81128994 <__reset+0xfb108994>
811289bc:	d9801e04 	addi	r6,sp,120
811289c0:	b80b883a 	mov	r5,r23
811289c4:	9809883a 	mov	r4,r19
811289c8:	d9c03c15 	stw	r7,240(sp)
811289cc:	11334ec0 	call	811334ec <__sprint_r>
811289d0:	d9c03c17 	ldw	r7,240(sp)
811289d4:	103c071e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
811289d8:	d8c02017 	ldw	r3,128(sp)
811289dc:	dc401f17 	ldw	r17,124(sp)
811289e0:	dd800404 	addi	r22,sp,16
811289e4:	003fec06 	br	81128998 <__reset+0xfb108998>
811289e8:	9080100c 	andi	r2,r18,64
811289ec:	d8002785 	stb	zero,158(sp)
811289f0:	10010e26 	beq	r2,zero,81128e2c <___vfprintf_internal_r+0x1848>
811289f4:	d9002d17 	ldw	r4,180(sp)
811289f8:	d9402917 	ldw	r5,164(sp)
811289fc:	002d883a 	mov	r22,zero
81128a00:	20800104 	addi	r2,r4,4
81128a04:	24c0000b 	ldhu	r19,0(r4)
81128a08:	283fc90e 	bge	r5,zero,81128930 <__reset+0xfb108930>
81128a0c:	d8802d15 	stw	r2,180(sp)
81128a10:	0039883a 	mov	fp,zero
81128a14:	9d84b03a 	or	r2,r19,r22
81128a18:	103c461e 	bne	r2,zero,81127b34 <__reset+0xfb107b34>
81128a1c:	00800044 	movi	r2,1
81128a20:	003e6c06 	br	811283d4 <__reset+0xfb1083d4>
81128a24:	d9002c17 	ldw	r4,176(sp)
81128a28:	d9801e04 	addi	r6,sp,120
81128a2c:	b80b883a 	mov	r5,r23
81128a30:	11334ec0 	call	811334ec <__sprint_r>
81128a34:	103bef1e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81128a38:	d8c02017 	ldw	r3,128(sp)
81128a3c:	da000404 	addi	r8,sp,16
81128a40:	d9003217 	ldw	r4,200(sp)
81128a44:	d8802617 	ldw	r2,152(sp)
81128a48:	d9403317 	ldw	r5,204(sp)
81128a4c:	8123883a 	add	r17,r16,r4
81128a50:	11400216 	blt	r2,r5,81128a5c <___vfprintf_internal_r+0x1478>
81128a54:	9100004c 	andi	r4,r18,1
81128a58:	20000d26 	beq	r4,zero,81128a90 <___vfprintf_internal_r+0x14ac>
81128a5c:	d9003717 	ldw	r4,220(sp)
81128a60:	d9403417 	ldw	r5,208(sp)
81128a64:	1907883a 	add	r3,r3,r4
81128a68:	d9001f17 	ldw	r4,124(sp)
81128a6c:	41400015 	stw	r5,0(r8)
81128a70:	d9403717 	ldw	r5,220(sp)
81128a74:	21000044 	addi	r4,r4,1
81128a78:	d8c02015 	stw	r3,128(sp)
81128a7c:	41400115 	stw	r5,4(r8)
81128a80:	d9001f15 	stw	r4,124(sp)
81128a84:	014001c4 	movi	r5,7
81128a88:	2901e816 	blt	r5,r4,8112922c <___vfprintf_internal_r+0x1c48>
81128a8c:	42000204 	addi	r8,r8,8
81128a90:	d9003317 	ldw	r4,204(sp)
81128a94:	8121883a 	add	r16,r16,r4
81128a98:	2085c83a 	sub	r2,r4,r2
81128a9c:	8461c83a 	sub	r16,r16,r17
81128aa0:	1400010e 	bge	r2,r16,81128aa8 <___vfprintf_internal_r+0x14c4>
81128aa4:	1021883a 	mov	r16,r2
81128aa8:	04000a0e 	bge	zero,r16,81128ad4 <___vfprintf_internal_r+0x14f0>
81128aac:	d9001f17 	ldw	r4,124(sp)
81128ab0:	1c07883a 	add	r3,r3,r16
81128ab4:	44400015 	stw	r17,0(r8)
81128ab8:	21000044 	addi	r4,r4,1
81128abc:	44000115 	stw	r16,4(r8)
81128ac0:	d8c02015 	stw	r3,128(sp)
81128ac4:	d9001f15 	stw	r4,124(sp)
81128ac8:	014001c4 	movi	r5,7
81128acc:	2901fb16 	blt	r5,r4,811292bc <___vfprintf_internal_r+0x1cd8>
81128ad0:	42000204 	addi	r8,r8,8
81128ad4:	8001f716 	blt	r16,zero,811292b4 <___vfprintf_internal_r+0x1cd0>
81128ad8:	1421c83a 	sub	r16,r2,r16
81128adc:	043d380e 	bge	zero,r16,81127fc0 <__reset+0xfb107fc0>
81128ae0:	04400404 	movi	r17,16
81128ae4:	d8801f17 	ldw	r2,124(sp)
81128ae8:	8c3efb0e 	bge	r17,r16,811286d8 <__reset+0xfb1086d8>
81128aec:	01604574 	movhi	r5,33045
81128af0:	2949a084 	addi	r5,r5,9858
81128af4:	d9402b15 	stw	r5,172(sp)
81128af8:	058001c4 	movi	r22,7
81128afc:	dcc02c17 	ldw	r19,176(sp)
81128b00:	00000306 	br	81128b10 <___vfprintf_internal_r+0x152c>
81128b04:	42000204 	addi	r8,r8,8
81128b08:	843ffc04 	addi	r16,r16,-16
81128b0c:	8c3ef50e 	bge	r17,r16,811286e4 <__reset+0xfb1086e4>
81128b10:	18c00404 	addi	r3,r3,16
81128b14:	10800044 	addi	r2,r2,1
81128b18:	45000015 	stw	r20,0(r8)
81128b1c:	44400115 	stw	r17,4(r8)
81128b20:	d8c02015 	stw	r3,128(sp)
81128b24:	d8801f15 	stw	r2,124(sp)
81128b28:	b0bff60e 	bge	r22,r2,81128b04 <__reset+0xfb108b04>
81128b2c:	d9801e04 	addi	r6,sp,120
81128b30:	b80b883a 	mov	r5,r23
81128b34:	9809883a 	mov	r4,r19
81128b38:	11334ec0 	call	811334ec <__sprint_r>
81128b3c:	103bad1e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81128b40:	d8c02017 	ldw	r3,128(sp)
81128b44:	d8801f17 	ldw	r2,124(sp)
81128b48:	da000404 	addi	r8,sp,16
81128b4c:	003fee06 	br	81128b08 <__reset+0xfb108b08>
81128b50:	9088703a 	and	r4,r18,r2
81128b54:	203eab1e 	bne	r4,zero,81128604 <__reset+0xfb108604>
81128b58:	dc401f17 	ldw	r17,124(sp)
81128b5c:	40800115 	stw	r2,4(r8)
81128b60:	44000015 	stw	r16,0(r8)
81128b64:	8c400044 	addi	r17,r17,1
81128b68:	d8c02015 	stw	r3,128(sp)
81128b6c:	dc401f15 	stw	r17,124(sp)
81128b70:	008001c4 	movi	r2,7
81128b74:	14400e16 	blt	r2,r17,81128bb0 <___vfprintf_internal_r+0x15cc>
81128b78:	45800204 	addi	r22,r8,8
81128b7c:	003eca06 	br	811286a8 <__reset+0xfb1086a8>
81128b80:	01204574 	movhi	r4,33045
81128b84:	2109a084 	addi	r4,r4,9858
81128b88:	d9002b15 	stw	r4,172(sp)
81128b8c:	d8802b17 	ldw	r2,172(sp)
81128b90:	1c07883a 	add	r3,r3,r16
81128b94:	8c400044 	addi	r17,r17,1
81128b98:	b0800015 	stw	r2,0(r22)
81128b9c:	b4000115 	stw	r16,4(r22)
81128ba0:	d8c02015 	stw	r3,128(sp)
81128ba4:	dc401f15 	stw	r17,124(sp)
81128ba8:	008001c4 	movi	r2,7
81128bac:	147ebd0e 	bge	r2,r17,811286a4 <__reset+0xfb1086a4>
81128bb0:	d9002c17 	ldw	r4,176(sp)
81128bb4:	d9801e04 	addi	r6,sp,120
81128bb8:	b80b883a 	mov	r5,r23
81128bbc:	11334ec0 	call	811334ec <__sprint_r>
81128bc0:	103b8c1e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81128bc4:	d8c02017 	ldw	r3,128(sp)
81128bc8:	dc401f17 	ldw	r17,124(sp)
81128bcc:	dd800404 	addi	r22,sp,16
81128bd0:	003eb506 	br	811286a8 <__reset+0xfb1086a8>
81128bd4:	d9002c17 	ldw	r4,176(sp)
81128bd8:	d9801e04 	addi	r6,sp,120
81128bdc:	b80b883a 	mov	r5,r23
81128be0:	11334ec0 	call	811334ec <__sprint_r>
81128be4:	103b831e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81128be8:	d8c02017 	ldw	r3,128(sp)
81128bec:	dc401f17 	ldw	r17,124(sp)
81128bf0:	da000404 	addi	r8,sp,16
81128bf4:	003e8d06 	br	8112862c <__reset+0xfb10862c>
81128bf8:	d9002c17 	ldw	r4,176(sp)
81128bfc:	d9801e04 	addi	r6,sp,120
81128c00:	b80b883a 	mov	r5,r23
81128c04:	11334ec0 	call	811334ec <__sprint_r>
81128c08:	103b7a1e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81128c0c:	d8c02017 	ldw	r3,128(sp)
81128c10:	dc401f17 	ldw	r17,124(sp)
81128c14:	dd800404 	addi	r22,sp,16
81128c18:	003e8f06 	br	81128658 <__reset+0xfb108658>
81128c1c:	0027883a 	mov	r19,zero
81128c20:	003f4a06 	br	8112894c <__reset+0xfb10894c>
81128c24:	d9002c17 	ldw	r4,176(sp)
81128c28:	d9801e04 	addi	r6,sp,120
81128c2c:	b80b883a 	mov	r5,r23
81128c30:	11334ec0 	call	811334ec <__sprint_r>
81128c34:	103b6f1e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81128c38:	d8c02017 	ldw	r3,128(sp)
81128c3c:	da000404 	addi	r8,sp,16
81128c40:	003c9d06 	br	81127eb8 <__reset+0xfb107eb8>
81128c44:	04e7c83a 	sub	r19,zero,r19
81128c48:	9804c03a 	cmpne	r2,r19,zero
81128c4c:	05adc83a 	sub	r22,zero,r22
81128c50:	b0adc83a 	sub	r22,r22,r2
81128c54:	d8802917 	ldw	r2,164(sp)
81128c58:	07000b44 	movi	fp,45
81128c5c:	df002785 	stb	fp,158(sp)
81128c60:	10017b16 	blt	r2,zero,81129250 <___vfprintf_internal_r+0x1c6c>
81128c64:	00bfdfc4 	movi	r2,-129
81128c68:	90a4703a 	and	r18,r18,r2
81128c6c:	003bb106 	br	81127b34 <__reset+0xfb107b34>
81128c70:	d9003617 	ldw	r4,216(sp)
81128c74:	d9403817 	ldw	r5,224(sp)
81128c78:	da003d15 	stw	r8,244(sp)
81128c7c:	112fe380 	call	8112fe38 <__fpclassifyd>
81128c80:	da003d17 	ldw	r8,244(sp)
81128c84:	1000f026 	beq	r2,zero,81129048 <___vfprintf_internal_r+0x1a64>
81128c88:	d9002917 	ldw	r4,164(sp)
81128c8c:	05bff7c4 	movi	r22,-33
81128c90:	00bfffc4 	movi	r2,-1
81128c94:	8dac703a 	and	r22,r17,r22
81128c98:	20820026 	beq	r4,r2,8112949c <___vfprintf_internal_r+0x1eb8>
81128c9c:	008011c4 	movi	r2,71
81128ca0:	b081f726 	beq	r22,r2,81129480 <___vfprintf_internal_r+0x1e9c>
81128ca4:	d9003817 	ldw	r4,224(sp)
81128ca8:	90c04014 	ori	r3,r18,256
81128cac:	d8c02b15 	stw	r3,172(sp)
81128cb0:	20021516 	blt	r4,zero,81129508 <___vfprintf_internal_r+0x1f24>
81128cb4:	dcc03817 	ldw	r19,224(sp)
81128cb8:	d8002a05 	stb	zero,168(sp)
81128cbc:	00801984 	movi	r2,102
81128cc0:	8881f926 	beq	r17,r2,811294a8 <___vfprintf_internal_r+0x1ec4>
81128cc4:	00801184 	movi	r2,70
81128cc8:	88821c26 	beq	r17,r2,8112953c <___vfprintf_internal_r+0x1f58>
81128ccc:	00801144 	movi	r2,69
81128cd0:	b081ef26 	beq	r22,r2,81129490 <___vfprintf_internal_r+0x1eac>
81128cd4:	d8c02917 	ldw	r3,164(sp)
81128cd8:	d8802104 	addi	r2,sp,132
81128cdc:	d8800315 	stw	r2,12(sp)
81128ce0:	d9403617 	ldw	r5,216(sp)
81128ce4:	d8802504 	addi	r2,sp,148
81128ce8:	d9002c17 	ldw	r4,176(sp)
81128cec:	d8800215 	stw	r2,8(sp)
81128cf0:	d8802604 	addi	r2,sp,152
81128cf4:	d8c00015 	stw	r3,0(sp)
81128cf8:	d8800115 	stw	r2,4(sp)
81128cfc:	01c00084 	movi	r7,2
81128d00:	980d883a 	mov	r6,r19
81128d04:	d8c03c15 	stw	r3,240(sp)
81128d08:	da003d15 	stw	r8,244(sp)
81128d0c:	112b6f00 	call	8112b6f0 <_dtoa_r>
81128d10:	1021883a 	mov	r16,r2
81128d14:	008019c4 	movi	r2,103
81128d18:	d8c03c17 	ldw	r3,240(sp)
81128d1c:	da003d17 	ldw	r8,244(sp)
81128d20:	88817126 	beq	r17,r2,811292e8 <___vfprintf_internal_r+0x1d04>
81128d24:	008011c4 	movi	r2,71
81128d28:	88829226 	beq	r17,r2,81129774 <___vfprintf_internal_r+0x2190>
81128d2c:	80f9883a 	add	fp,r16,r3
81128d30:	d9003617 	ldw	r4,216(sp)
81128d34:	000d883a 	mov	r6,zero
81128d38:	000f883a 	mov	r7,zero
81128d3c:	980b883a 	mov	r5,r19
81128d40:	da003d15 	stw	r8,244(sp)
81128d44:	1137cb80 	call	81137cb8 <__eqdf2>
81128d48:	da003d17 	ldw	r8,244(sp)
81128d4c:	10018d26 	beq	r2,zero,81129384 <___vfprintf_internal_r+0x1da0>
81128d50:	d8802117 	ldw	r2,132(sp)
81128d54:	1700062e 	bgeu	r2,fp,81128d70 <___vfprintf_internal_r+0x178c>
81128d58:	01000c04 	movi	r4,48
81128d5c:	10c00044 	addi	r3,r2,1
81128d60:	d8c02115 	stw	r3,132(sp)
81128d64:	11000005 	stb	r4,0(r2)
81128d68:	d8802117 	ldw	r2,132(sp)
81128d6c:	173ffb36 	bltu	r2,fp,81128d5c <__reset+0xfb108d5c>
81128d70:	1405c83a 	sub	r2,r2,r16
81128d74:	d8803315 	stw	r2,204(sp)
81128d78:	008011c4 	movi	r2,71
81128d7c:	b0817626 	beq	r22,r2,81129358 <___vfprintf_internal_r+0x1d74>
81128d80:	00801944 	movi	r2,101
81128d84:	1442810e 	bge	r2,r17,8112978c <___vfprintf_internal_r+0x21a8>
81128d88:	d8c02617 	ldw	r3,152(sp)
81128d8c:	00801984 	movi	r2,102
81128d90:	d8c03215 	stw	r3,200(sp)
81128d94:	8881fe26 	beq	r17,r2,81129590 <___vfprintf_internal_r+0x1fac>
81128d98:	d8c03217 	ldw	r3,200(sp)
81128d9c:	d9003317 	ldw	r4,204(sp)
81128da0:	1901dd16 	blt	r3,r4,81129518 <___vfprintf_internal_r+0x1f34>
81128da4:	9480004c 	andi	r18,r18,1
81128da8:	90022b1e 	bne	r18,zero,81129658 <___vfprintf_internal_r+0x2074>
81128dac:	1805883a 	mov	r2,r3
81128db0:	18028016 	blt	r3,zero,811297b4 <___vfprintf_internal_r+0x21d0>
81128db4:	d8c03217 	ldw	r3,200(sp)
81128db8:	044019c4 	movi	r17,103
81128dbc:	d8c02e15 	stw	r3,184(sp)
81128dc0:	df002a07 	ldb	fp,168(sp)
81128dc4:	e001531e 	bne	fp,zero,81129314 <___vfprintf_internal_r+0x1d30>
81128dc8:	df002783 	ldbu	fp,158(sp)
81128dcc:	d8802a15 	stw	r2,168(sp)
81128dd0:	dc802b17 	ldw	r18,172(sp)
81128dd4:	d8002915 	stw	zero,164(sp)
81128dd8:	003bd106 	br	81127d20 <__reset+0xfb107d20>
81128ddc:	d8802d17 	ldw	r2,180(sp)
81128de0:	d8c02d17 	ldw	r3,180(sp)
81128de4:	d9002d17 	ldw	r4,180(sp)
81128de8:	10800017 	ldw	r2,0(r2)
81128dec:	18c00117 	ldw	r3,4(r3)
81128df0:	21000204 	addi	r4,r4,8
81128df4:	d8803615 	stw	r2,216(sp)
81128df8:	d8c03815 	stw	r3,224(sp)
81128dfc:	d9002d15 	stw	r4,180(sp)
81128e00:	003b7506 	br	81127bd8 <__reset+0xfb107bd8>
81128e04:	ac400007 	ldb	r17,0(r21)
81128e08:	003a5906 	br	81127770 <__reset+0xfb107770>
81128e0c:	9080100c 	andi	r2,r18,64
81128e10:	1000a826 	beq	r2,zero,811290b4 <___vfprintf_internal_r+0x1ad0>
81128e14:	d9002d17 	ldw	r4,180(sp)
81128e18:	002d883a 	mov	r22,zero
81128e1c:	24c0000b 	ldhu	r19,0(r4)
81128e20:	21000104 	addi	r4,r4,4
81128e24:	d9002d15 	stw	r4,180(sp)
81128e28:	003ccb06 	br	81128158 <__reset+0xfb108158>
81128e2c:	d8c02d17 	ldw	r3,180(sp)
81128e30:	d9002917 	ldw	r4,164(sp)
81128e34:	002d883a 	mov	r22,zero
81128e38:	18800104 	addi	r2,r3,4
81128e3c:	1cc00017 	ldw	r19,0(r3)
81128e40:	203ebb0e 	bge	r4,zero,81128930 <__reset+0xfb108930>
81128e44:	003ef106 	br	81128a0c <__reset+0xfb108a0c>
81128e48:	9080040c 	andi	r2,r18,16
81128e4c:	1000921e 	bne	r2,zero,81129098 <___vfprintf_internal_r+0x1ab4>
81128e50:	9480100c 	andi	r18,r18,64
81128e54:	90013926 	beq	r18,zero,8112933c <___vfprintf_internal_r+0x1d58>
81128e58:	d9002d17 	ldw	r4,180(sp)
81128e5c:	d9402f17 	ldw	r5,188(sp)
81128e60:	20800017 	ldw	r2,0(r4)
81128e64:	21000104 	addi	r4,r4,4
81128e68:	d9002d15 	stw	r4,180(sp)
81128e6c:	1140000d 	sth	r5,0(r2)
81128e70:	003a1606 	br	811276cc <__reset+0xfb1076cc>
81128e74:	9080100c 	andi	r2,r18,64
81128e78:	10008026 	beq	r2,zero,8112907c <___vfprintf_internal_r+0x1a98>
81128e7c:	d8c02d17 	ldw	r3,180(sp)
81128e80:	1cc0000f 	ldh	r19,0(r3)
81128e84:	18c00104 	addi	r3,r3,4
81128e88:	d8c02d15 	stw	r3,180(sp)
81128e8c:	982dd7fa 	srai	r22,r19,31
81128e90:	b005883a 	mov	r2,r22
81128e94:	003b1f06 	br	81127b14 <__reset+0xfb107b14>
81128e98:	9080100c 	andi	r2,r18,64
81128e9c:	d8002785 	stb	zero,158(sp)
81128ea0:	10008a1e 	bne	r2,zero,811290cc <___vfprintf_internal_r+0x1ae8>
81128ea4:	d9402d17 	ldw	r5,180(sp)
81128ea8:	d8c02917 	ldw	r3,164(sp)
81128eac:	002d883a 	mov	r22,zero
81128eb0:	28800104 	addi	r2,r5,4
81128eb4:	2cc00017 	ldw	r19,0(r5)
81128eb8:	183e4b0e 	bge	r3,zero,811287e8 <__reset+0xfb1087e8>
81128ebc:	9d86b03a 	or	r3,r19,r22
81128ec0:	d8802d15 	stw	r2,180(sp)
81128ec4:	183e4c1e 	bne	r3,zero,811287f8 <__reset+0xfb1087f8>
81128ec8:	0039883a 	mov	fp,zero
81128ecc:	0005883a 	mov	r2,zero
81128ed0:	003d4006 	br	811283d4 <__reset+0xfb1083d4>
81128ed4:	01604574 	movhi	r5,33045
81128ed8:	2949a084 	addi	r5,r5,9858
81128edc:	d9402b15 	stw	r5,172(sp)
81128ee0:	d9402b17 	ldw	r5,172(sp)
81128ee4:	1c47883a 	add	r3,r3,r17
81128ee8:	10800044 	addi	r2,r2,1
81128eec:	41400015 	stw	r5,0(r8)
81128ef0:	44400115 	stw	r17,4(r8)
81128ef4:	d8c02015 	stw	r3,128(sp)
81128ef8:	d8801f15 	stw	r2,124(sp)
81128efc:	010001c4 	movi	r4,7
81128f00:	20bec816 	blt	r4,r2,81128a24 <__reset+0xfb108a24>
81128f04:	42000204 	addi	r8,r8,8
81128f08:	003ecd06 	br	81128a40 <__reset+0xfb108a40>
81128f0c:	d9002917 	ldw	r4,164(sp)
81128f10:	d8002785 	stb	zero,158(sp)
81128f14:	203d2d16 	blt	r4,zero,811283cc <__reset+0xfb1083cc>
81128f18:	00bfdfc4 	movi	r2,-129
81128f1c:	90a4703a 	and	r18,r18,r2
81128f20:	003a9106 	br	81127968 <__reset+0xfb107968>
81128f24:	01204574 	movhi	r4,33045
81128f28:	2109a084 	addi	r4,r4,9858
81128f2c:	d9002b15 	stw	r4,172(sp)
81128f30:	003c0c06 	br	81127f64 <__reset+0xfb107f64>
81128f34:	d9002c17 	ldw	r4,176(sp)
81128f38:	d9801e04 	addi	r6,sp,120
81128f3c:	b80b883a 	mov	r5,r23
81128f40:	11334ec0 	call	811334ec <__sprint_r>
81128f44:	103aab1e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81128f48:	d8c02017 	ldw	r3,128(sp)
81128f4c:	da000404 	addi	r8,sp,16
81128f50:	003d4106 	br	81128458 <__reset+0xfb108458>
81128f54:	d8801f17 	ldw	r2,124(sp)
81128f58:	01604574 	movhi	r5,33045
81128f5c:	01000044 	movi	r4,1
81128f60:	18c00044 	addi	r3,r3,1
81128f64:	10800044 	addi	r2,r2,1
81128f68:	29499804 	addi	r5,r5,9824
81128f6c:	41000115 	stw	r4,4(r8)
81128f70:	41400015 	stw	r5,0(r8)
81128f74:	d8c02015 	stw	r3,128(sp)
81128f78:	d8801f15 	stw	r2,124(sp)
81128f7c:	010001c4 	movi	r4,7
81128f80:	20805c16 	blt	r4,r2,811290f4 <___vfprintf_internal_r+0x1b10>
81128f84:	42000204 	addi	r8,r8,8
81128f88:	8800041e 	bne	r17,zero,81128f9c <___vfprintf_internal_r+0x19b8>
81128f8c:	d8803317 	ldw	r2,204(sp)
81128f90:	1000021e 	bne	r2,zero,81128f9c <___vfprintf_internal_r+0x19b8>
81128f94:	9080004c 	andi	r2,r18,1
81128f98:	103c0926 	beq	r2,zero,81127fc0 <__reset+0xfb107fc0>
81128f9c:	d9003717 	ldw	r4,220(sp)
81128fa0:	d8801f17 	ldw	r2,124(sp)
81128fa4:	d9403417 	ldw	r5,208(sp)
81128fa8:	20c7883a 	add	r3,r4,r3
81128fac:	10800044 	addi	r2,r2,1
81128fb0:	41000115 	stw	r4,4(r8)
81128fb4:	41400015 	stw	r5,0(r8)
81128fb8:	d8c02015 	stw	r3,128(sp)
81128fbc:	d8801f15 	stw	r2,124(sp)
81128fc0:	010001c4 	movi	r4,7
81128fc4:	20812116 	blt	r4,r2,8112944c <___vfprintf_internal_r+0x1e68>
81128fc8:	42000204 	addi	r8,r8,8
81128fcc:	0463c83a 	sub	r17,zero,r17
81128fd0:	0440730e 	bge	zero,r17,811291a0 <___vfprintf_internal_r+0x1bbc>
81128fd4:	05800404 	movi	r22,16
81128fd8:	b440860e 	bge	r22,r17,811291f4 <___vfprintf_internal_r+0x1c10>
81128fdc:	01604574 	movhi	r5,33045
81128fe0:	2949a084 	addi	r5,r5,9858
81128fe4:	d9402b15 	stw	r5,172(sp)
81128fe8:	070001c4 	movi	fp,7
81128fec:	dcc02c17 	ldw	r19,176(sp)
81128ff0:	00000306 	br	81129000 <___vfprintf_internal_r+0x1a1c>
81128ff4:	42000204 	addi	r8,r8,8
81128ff8:	8c7ffc04 	addi	r17,r17,-16
81128ffc:	b440800e 	bge	r22,r17,81129200 <___vfprintf_internal_r+0x1c1c>
81129000:	18c00404 	addi	r3,r3,16
81129004:	10800044 	addi	r2,r2,1
81129008:	45000015 	stw	r20,0(r8)
8112900c:	45800115 	stw	r22,4(r8)
81129010:	d8c02015 	stw	r3,128(sp)
81129014:	d8801f15 	stw	r2,124(sp)
81129018:	e0bff60e 	bge	fp,r2,81128ff4 <__reset+0xfb108ff4>
8112901c:	d9801e04 	addi	r6,sp,120
81129020:	b80b883a 	mov	r5,r23
81129024:	9809883a 	mov	r4,r19
81129028:	11334ec0 	call	811334ec <__sprint_r>
8112902c:	103a711e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81129030:	d8c02017 	ldw	r3,128(sp)
81129034:	d8801f17 	ldw	r2,124(sp)
81129038:	da000404 	addi	r8,sp,16
8112903c:	003fee06 	br	81128ff8 <__reset+0xfb108ff8>
81129040:	00bfffc4 	movi	r2,-1
81129044:	003a6f06 	br	81127a04 <__reset+0xfb107a04>
81129048:	008011c4 	movi	r2,71
8112904c:	1440b816 	blt	r2,r17,81129330 <___vfprintf_internal_r+0x1d4c>
81129050:	04204574 	movhi	r16,33045
81129054:	84098a04 	addi	r16,r16,9768
81129058:	00c000c4 	movi	r3,3
8112905c:	00bfdfc4 	movi	r2,-129
81129060:	d8c02a15 	stw	r3,168(sp)
81129064:	90a4703a 	and	r18,r18,r2
81129068:	df002783 	ldbu	fp,158(sp)
8112906c:	d8c02e15 	stw	r3,184(sp)
81129070:	d8002915 	stw	zero,164(sp)
81129074:	d8003215 	stw	zero,200(sp)
81129078:	003b2906 	br	81127d20 <__reset+0xfb107d20>
8112907c:	d9002d17 	ldw	r4,180(sp)
81129080:	24c00017 	ldw	r19,0(r4)
81129084:	21000104 	addi	r4,r4,4
81129088:	d9002d15 	stw	r4,180(sp)
8112908c:	982dd7fa 	srai	r22,r19,31
81129090:	b005883a 	mov	r2,r22
81129094:	003a9f06 	br	81127b14 <__reset+0xfb107b14>
81129098:	d9402d17 	ldw	r5,180(sp)
8112909c:	d8c02f17 	ldw	r3,188(sp)
811290a0:	28800017 	ldw	r2,0(r5)
811290a4:	29400104 	addi	r5,r5,4
811290a8:	d9402d15 	stw	r5,180(sp)
811290ac:	10c00015 	stw	r3,0(r2)
811290b0:	00398606 	br	811276cc <__reset+0xfb1076cc>
811290b4:	d9402d17 	ldw	r5,180(sp)
811290b8:	002d883a 	mov	r22,zero
811290bc:	2cc00017 	ldw	r19,0(r5)
811290c0:	29400104 	addi	r5,r5,4
811290c4:	d9402d15 	stw	r5,180(sp)
811290c8:	003c2306 	br	81128158 <__reset+0xfb108158>
811290cc:	d8c02d17 	ldw	r3,180(sp)
811290d0:	d9002917 	ldw	r4,164(sp)
811290d4:	002d883a 	mov	r22,zero
811290d8:	18800104 	addi	r2,r3,4
811290dc:	1cc0000b 	ldhu	r19,0(r3)
811290e0:	203dc10e 	bge	r4,zero,811287e8 <__reset+0xfb1087e8>
811290e4:	003f7506 	br	81128ebc <__reset+0xfb108ebc>
811290e8:	04204574 	movhi	r16,33045
811290ec:	84098804 	addi	r16,r16,9760
811290f0:	003acc06 	br	81127c24 <__reset+0xfb107c24>
811290f4:	d9002c17 	ldw	r4,176(sp)
811290f8:	d9801e04 	addi	r6,sp,120
811290fc:	b80b883a 	mov	r5,r23
81129100:	11334ec0 	call	811334ec <__sprint_r>
81129104:	103a3b1e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81129108:	dc402617 	ldw	r17,152(sp)
8112910c:	d8c02017 	ldw	r3,128(sp)
81129110:	da000404 	addi	r8,sp,16
81129114:	003f9c06 	br	81128f88 <__reset+0xfb108f88>
81129118:	ac400043 	ldbu	r17,1(r21)
8112911c:	94800814 	ori	r18,r18,32
81129120:	ad400044 	addi	r21,r21,1
81129124:	8c403fcc 	andi	r17,r17,255
81129128:	8c40201c 	xori	r17,r17,128
8112912c:	8c7fe004 	addi	r17,r17,-128
81129130:	00398f06 	br	81127770 <__reset+0xfb107770>
81129134:	d8c02d15 	stw	r3,180(sp)
81129138:	0039883a 	mov	fp,zero
8112913c:	003e3506 	br	81128a14 <__reset+0xfb108a14>
81129140:	d9002c17 	ldw	r4,176(sp)
81129144:	d9801e04 	addi	r6,sp,120
81129148:	b80b883a 	mov	r5,r23
8112914c:	11334ec0 	call	811334ec <__sprint_r>
81129150:	103a281e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81129154:	d8c02017 	ldw	r3,128(sp)
81129158:	da000404 	addi	r8,sp,16
8112915c:	003cd006 	br	811284a0 <__reset+0xfb1084a0>
81129160:	8009883a 	mov	r4,r16
81129164:	da003d15 	stw	r8,244(sp)
81129168:	1124dc80 	call	81124dc8 <strlen>
8112916c:	d8802e15 	stw	r2,184(sp)
81129170:	da003d17 	ldw	r8,244(sp)
81129174:	103c340e 	bge	r2,zero,81128248 <__reset+0xfb108248>
81129178:	0005883a 	mov	r2,zero
8112917c:	003c3206 	br	81128248 <__reset+0xfb108248>
81129180:	d9002c17 	ldw	r4,176(sp)
81129184:	d9801e04 	addi	r6,sp,120
81129188:	b80b883a 	mov	r5,r23
8112918c:	11334ec0 	call	811334ec <__sprint_r>
81129190:	103a181e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81129194:	d8c02017 	ldw	r3,128(sp)
81129198:	d8801f17 	ldw	r2,124(sp)
8112919c:	da000404 	addi	r8,sp,16
811291a0:	d9403317 	ldw	r5,204(sp)
811291a4:	10800044 	addi	r2,r2,1
811291a8:	44000015 	stw	r16,0(r8)
811291ac:	28c7883a 	add	r3,r5,r3
811291b0:	003b7d06 	br	81127fa8 <__reset+0xfb107fa8>
811291b4:	01204574 	movhi	r4,33045
811291b8:	2109a484 	addi	r4,r4,9874
811291bc:	d9003515 	stw	r4,212(sp)
811291c0:	003b1406 	br	81127e14 <__reset+0xfb107e14>
811291c4:	013fffc4 	movi	r4,-1
811291c8:	003a3506 	br	81127aa0 <__reset+0xfb107aa0>
811291cc:	0023883a 	mov	r17,zero
811291d0:	003d9d06 	br	81128848 <__reset+0xfb108848>
811291d4:	d9002c17 	ldw	r4,176(sp)
811291d8:	d9801e04 	addi	r6,sp,120
811291dc:	b80b883a 	mov	r5,r23
811291e0:	11334ec0 	call	811334ec <__sprint_r>
811291e4:	103a031e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
811291e8:	d8c02017 	ldw	r3,128(sp)
811291ec:	da000404 	addi	r8,sp,16
811291f0:	003d9406 	br	81128844 <__reset+0xfb108844>
811291f4:	01204574 	movhi	r4,33045
811291f8:	2109a084 	addi	r4,r4,9858
811291fc:	d9002b15 	stw	r4,172(sp)
81129200:	d9002b17 	ldw	r4,172(sp)
81129204:	1c47883a 	add	r3,r3,r17
81129208:	10800044 	addi	r2,r2,1
8112920c:	41000015 	stw	r4,0(r8)
81129210:	44400115 	stw	r17,4(r8)
81129214:	d8c02015 	stw	r3,128(sp)
81129218:	d8801f15 	stw	r2,124(sp)
8112921c:	010001c4 	movi	r4,7
81129220:	20bfd716 	blt	r4,r2,81129180 <__reset+0xfb109180>
81129224:	42000204 	addi	r8,r8,8
81129228:	003fdd06 	br	811291a0 <__reset+0xfb1091a0>
8112922c:	d9002c17 	ldw	r4,176(sp)
81129230:	d9801e04 	addi	r6,sp,120
81129234:	b80b883a 	mov	r5,r23
81129238:	11334ec0 	call	811334ec <__sprint_r>
8112923c:	1039ed1e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81129240:	d8802617 	ldw	r2,152(sp)
81129244:	d8c02017 	ldw	r3,128(sp)
81129248:	da000404 	addi	r8,sp,16
8112924c:	003e1006 	br	81128a90 <__reset+0xfb108a90>
81129250:	00800044 	movi	r2,1
81129254:	10803fcc 	andi	r2,r2,255
81129258:	00c00044 	movi	r3,1
8112925c:	10fa3526 	beq	r2,r3,81127b34 <__reset+0xfb107b34>
81129260:	00c00084 	movi	r3,2
81129264:	10fbcb26 	beq	r2,r3,81128194 <__reset+0xfb108194>
81129268:	003a8f06 	br	81127ca8 <__reset+0xfb107ca8>
8112926c:	01204574 	movhi	r4,33045
81129270:	2109a484 	addi	r4,r4,9874
81129274:	d9003515 	stw	r4,212(sp)
81129278:	003b7606 	br	81128054 <__reset+0xfb108054>
8112927c:	d8802917 	ldw	r2,164(sp)
81129280:	00c00184 	movi	r3,6
81129284:	1880012e 	bgeu	r3,r2,8112928c <___vfprintf_internal_r+0x1ca8>
81129288:	1805883a 	mov	r2,r3
8112928c:	d8802e15 	stw	r2,184(sp)
81129290:	1000ef16 	blt	r2,zero,81129650 <___vfprintf_internal_r+0x206c>
81129294:	04204574 	movhi	r16,33045
81129298:	d8802a15 	stw	r2,168(sp)
8112929c:	dcc02d15 	stw	r19,180(sp)
811292a0:	d8002915 	stw	zero,164(sp)
811292a4:	d8003215 	stw	zero,200(sp)
811292a8:	84099604 	addi	r16,r16,9816
811292ac:	0039883a 	mov	fp,zero
811292b0:	003aa206 	br	81127d3c <__reset+0xfb107d3c>
811292b4:	0021883a 	mov	r16,zero
811292b8:	003e0706 	br	81128ad8 <__reset+0xfb108ad8>
811292bc:	d9002c17 	ldw	r4,176(sp)
811292c0:	d9801e04 	addi	r6,sp,120
811292c4:	b80b883a 	mov	r5,r23
811292c8:	11334ec0 	call	811334ec <__sprint_r>
811292cc:	1039c91e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
811292d0:	d8802617 	ldw	r2,152(sp)
811292d4:	d9403317 	ldw	r5,204(sp)
811292d8:	d8c02017 	ldw	r3,128(sp)
811292dc:	da000404 	addi	r8,sp,16
811292e0:	2885c83a 	sub	r2,r5,r2
811292e4:	003dfb06 	br	81128ad4 <__reset+0xfb108ad4>
811292e8:	9080004c 	andi	r2,r18,1
811292ec:	103e8f1e 	bne	r2,zero,81128d2c <__reset+0xfb108d2c>
811292f0:	d8802117 	ldw	r2,132(sp)
811292f4:	003e9e06 	br	81128d70 <__reset+0xfb108d70>
811292f8:	1025883a 	mov	r18,r2
811292fc:	0039883a 	mov	fp,zero
81129300:	00800084 	movi	r2,2
81129304:	003fd306 	br	81129254 <__reset+0xfb109254>
81129308:	07000b44 	movi	fp,45
8112930c:	df002785 	stb	fp,158(sp)
81129310:	003a4006 	br	81127c14 <__reset+0xfb107c14>
81129314:	00c00b44 	movi	r3,45
81129318:	d8c02785 	stb	r3,158(sp)
8112931c:	d8802a15 	stw	r2,168(sp)
81129320:	dc802b17 	ldw	r18,172(sp)
81129324:	d8002915 	stw	zero,164(sp)
81129328:	07000b44 	movi	fp,45
8112932c:	003a8006 	br	81127d30 <__reset+0xfb107d30>
81129330:	04204574 	movhi	r16,33045
81129334:	84098b04 	addi	r16,r16,9772
81129338:	003f4706 	br	81129058 <__reset+0xfb109058>
8112933c:	d8c02d17 	ldw	r3,180(sp)
81129340:	d9002f17 	ldw	r4,188(sp)
81129344:	18800017 	ldw	r2,0(r3)
81129348:	18c00104 	addi	r3,r3,4
8112934c:	d8c02d15 	stw	r3,180(sp)
81129350:	11000015 	stw	r4,0(r2)
81129354:	0038dd06 	br	811276cc <__reset+0xfb1076cc>
81129358:	dd802617 	ldw	r22,152(sp)
8112935c:	00bfff44 	movi	r2,-3
81129360:	b0801c16 	blt	r22,r2,811293d4 <___vfprintf_internal_r+0x1df0>
81129364:	d9402917 	ldw	r5,164(sp)
81129368:	2d801a16 	blt	r5,r22,811293d4 <___vfprintf_internal_r+0x1df0>
8112936c:	dd803215 	stw	r22,200(sp)
81129370:	003e8906 	br	81128d98 <__reset+0xfb108d98>
81129374:	01204574 	movhi	r4,33045
81129378:	2109a084 	addi	r4,r4,9858
8112937c:	d9002b15 	stw	r4,172(sp)
81129380:	003c9106 	br	811285c8 <__reset+0xfb1085c8>
81129384:	e005883a 	mov	r2,fp
81129388:	003e7906 	br	81128d70 <__reset+0xfb108d70>
8112938c:	d9402917 	ldw	r5,164(sp)
81129390:	df002783 	ldbu	fp,158(sp)
81129394:	dcc02d15 	stw	r19,180(sp)
81129398:	d9402a15 	stw	r5,168(sp)
8112939c:	d9402e15 	stw	r5,184(sp)
811293a0:	d8002915 	stw	zero,164(sp)
811293a4:	d8003215 	stw	zero,200(sp)
811293a8:	003a5d06 	br	81127d20 <__reset+0xfb107d20>
811293ac:	9080004c 	andi	r2,r18,1
811293b0:	0039883a 	mov	fp,zero
811293b4:	10000426 	beq	r2,zero,811293c8 <___vfprintf_internal_r+0x1de4>
811293b8:	00800c04 	movi	r2,48
811293bc:	dc001dc4 	addi	r16,sp,119
811293c0:	d8801dc5 	stb	r2,119(sp)
811293c4:	003b8006 	br	811281c8 <__reset+0xfb1081c8>
811293c8:	d8002e15 	stw	zero,184(sp)
811293cc:	dc001e04 	addi	r16,sp,120
811293d0:	003a4d06 	br	81127d08 <__reset+0xfb107d08>
811293d4:	8c7fff84 	addi	r17,r17,-2
811293d8:	b5bfffc4 	addi	r22,r22,-1
811293dc:	dd802615 	stw	r22,152(sp)
811293e0:	dc4022c5 	stb	r17,139(sp)
811293e4:	b000bf16 	blt	r22,zero,811296e4 <___vfprintf_internal_r+0x2100>
811293e8:	00800ac4 	movi	r2,43
811293ec:	d8802305 	stb	r2,140(sp)
811293f0:	00800244 	movi	r2,9
811293f4:	15807016 	blt	r2,r22,811295b8 <___vfprintf_internal_r+0x1fd4>
811293f8:	00800c04 	movi	r2,48
811293fc:	b5800c04 	addi	r22,r22,48
81129400:	d8802345 	stb	r2,141(sp)
81129404:	dd802385 	stb	r22,142(sp)
81129408:	d88023c4 	addi	r2,sp,143
8112940c:	df0022c4 	addi	fp,sp,139
81129410:	d8c03317 	ldw	r3,204(sp)
81129414:	1739c83a 	sub	fp,r2,fp
81129418:	d9003317 	ldw	r4,204(sp)
8112941c:	e0c7883a 	add	r3,fp,r3
81129420:	df003a15 	stw	fp,232(sp)
81129424:	d8c02e15 	stw	r3,184(sp)
81129428:	00800044 	movi	r2,1
8112942c:	1100b30e 	bge	r2,r4,811296fc <___vfprintf_internal_r+0x2118>
81129430:	d8c02e17 	ldw	r3,184(sp)
81129434:	18c00044 	addi	r3,r3,1
81129438:	d8c02e15 	stw	r3,184(sp)
8112943c:	1805883a 	mov	r2,r3
81129440:	1800ac16 	blt	r3,zero,811296f4 <___vfprintf_internal_r+0x2110>
81129444:	d8003215 	stw	zero,200(sp)
81129448:	003e5d06 	br	81128dc0 <__reset+0xfb108dc0>
8112944c:	d9002c17 	ldw	r4,176(sp)
81129450:	d9801e04 	addi	r6,sp,120
81129454:	b80b883a 	mov	r5,r23
81129458:	11334ec0 	call	811334ec <__sprint_r>
8112945c:	1039651e 	bne	r2,zero,811279f4 <__reset+0xfb1079f4>
81129460:	dc402617 	ldw	r17,152(sp)
81129464:	d8c02017 	ldw	r3,128(sp)
81129468:	d8801f17 	ldw	r2,124(sp)
8112946c:	da000404 	addi	r8,sp,16
81129470:	003ed606 	br	81128fcc <__reset+0xfb108fcc>
81129474:	582b883a 	mov	r21,r11
81129478:	d8002915 	stw	zero,164(sp)
8112947c:	0038bd06 	br	81127774 <__reset+0xfb107774>
81129480:	d8802917 	ldw	r2,164(sp)
81129484:	103e071e 	bne	r2,zero,81128ca4 <__reset+0xfb108ca4>
81129488:	dc002915 	stw	r16,164(sp)
8112948c:	003e0506 	br	81128ca4 <__reset+0xfb108ca4>
81129490:	d9002917 	ldw	r4,164(sp)
81129494:	20c00044 	addi	r3,r4,1
81129498:	003e0f06 	br	81128cd8 <__reset+0xfb108cd8>
8112949c:	01400184 	movi	r5,6
811294a0:	d9402915 	stw	r5,164(sp)
811294a4:	003dff06 	br	81128ca4 <__reset+0xfb108ca4>
811294a8:	d8802104 	addi	r2,sp,132
811294ac:	d8800315 	stw	r2,12(sp)
811294b0:	d8802504 	addi	r2,sp,148
811294b4:	d8800215 	stw	r2,8(sp)
811294b8:	d8802604 	addi	r2,sp,152
811294bc:	d8800115 	stw	r2,4(sp)
811294c0:	d8802917 	ldw	r2,164(sp)
811294c4:	d9403617 	ldw	r5,216(sp)
811294c8:	d9002c17 	ldw	r4,176(sp)
811294cc:	d8800015 	stw	r2,0(sp)
811294d0:	01c000c4 	movi	r7,3
811294d4:	980d883a 	mov	r6,r19
811294d8:	da003d15 	stw	r8,244(sp)
811294dc:	112b6f00 	call	8112b6f0 <_dtoa_r>
811294e0:	d8c02917 	ldw	r3,164(sp)
811294e4:	da003d17 	ldw	r8,244(sp)
811294e8:	1021883a 	mov	r16,r2
811294ec:	10f9883a 	add	fp,r2,r3
811294f0:	81000007 	ldb	r4,0(r16)
811294f4:	00800c04 	movi	r2,48
811294f8:	20805e26 	beq	r4,r2,81129674 <___vfprintf_internal_r+0x2090>
811294fc:	d8c02617 	ldw	r3,152(sp)
81129500:	e0f9883a 	add	fp,fp,r3
81129504:	003e0a06 	br	81128d30 <__reset+0xfb108d30>
81129508:	00c00b44 	movi	r3,45
8112950c:	24e0003c 	xorhi	r19,r4,32768
81129510:	d8c02a05 	stb	r3,168(sp)
81129514:	003de906 	br	81128cbc <__reset+0xfb108cbc>
81129518:	d8c03217 	ldw	r3,200(sp)
8112951c:	00c07a0e 	bge	zero,r3,81129708 <___vfprintf_internal_r+0x2124>
81129520:	00800044 	movi	r2,1
81129524:	d9003317 	ldw	r4,204(sp)
81129528:	1105883a 	add	r2,r2,r4
8112952c:	d8802e15 	stw	r2,184(sp)
81129530:	10004e16 	blt	r2,zero,8112966c <___vfprintf_internal_r+0x2088>
81129534:	044019c4 	movi	r17,103
81129538:	003e2106 	br	81128dc0 <__reset+0xfb108dc0>
8112953c:	d9002917 	ldw	r4,164(sp)
81129540:	d8802104 	addi	r2,sp,132
81129544:	d8800315 	stw	r2,12(sp)
81129548:	d9000015 	stw	r4,0(sp)
8112954c:	d8802504 	addi	r2,sp,148
81129550:	d9403617 	ldw	r5,216(sp)
81129554:	d9002c17 	ldw	r4,176(sp)
81129558:	d8800215 	stw	r2,8(sp)
8112955c:	d8802604 	addi	r2,sp,152
81129560:	d8800115 	stw	r2,4(sp)
81129564:	01c000c4 	movi	r7,3
81129568:	980d883a 	mov	r6,r19
8112956c:	da003d15 	stw	r8,244(sp)
81129570:	112b6f00 	call	8112b6f0 <_dtoa_r>
81129574:	d8c02917 	ldw	r3,164(sp)
81129578:	da003d17 	ldw	r8,244(sp)
8112957c:	1021883a 	mov	r16,r2
81129580:	00801184 	movi	r2,70
81129584:	80f9883a 	add	fp,r16,r3
81129588:	88bfd926 	beq	r17,r2,811294f0 <__reset+0xfb1094f0>
8112958c:	003de806 	br	81128d30 <__reset+0xfb108d30>
81129590:	d9002917 	ldw	r4,164(sp)
81129594:	00c04d0e 	bge	zero,r3,811296cc <___vfprintf_internal_r+0x20e8>
81129598:	2000441e 	bne	r4,zero,811296ac <___vfprintf_internal_r+0x20c8>
8112959c:	9480004c 	andi	r18,r18,1
811295a0:	9000421e 	bne	r18,zero,811296ac <___vfprintf_internal_r+0x20c8>
811295a4:	1805883a 	mov	r2,r3
811295a8:	18007016 	blt	r3,zero,8112976c <___vfprintf_internal_r+0x2188>
811295ac:	d8c03217 	ldw	r3,200(sp)
811295b0:	d8c02e15 	stw	r3,184(sp)
811295b4:	003e0206 	br	81128dc0 <__reset+0xfb108dc0>
811295b8:	df0022c4 	addi	fp,sp,139
811295bc:	dc002915 	stw	r16,164(sp)
811295c0:	4027883a 	mov	r19,r8
811295c4:	e021883a 	mov	r16,fp
811295c8:	b009883a 	mov	r4,r22
811295cc:	01400284 	movi	r5,10
811295d0:	11367e80 	call	811367e8 <__modsi3>
811295d4:	10800c04 	addi	r2,r2,48
811295d8:	843fffc4 	addi	r16,r16,-1
811295dc:	b009883a 	mov	r4,r22
811295e0:	01400284 	movi	r5,10
811295e4:	80800005 	stb	r2,0(r16)
811295e8:	11367640 	call	81136764 <__divsi3>
811295ec:	102d883a 	mov	r22,r2
811295f0:	00800244 	movi	r2,9
811295f4:	15bff416 	blt	r2,r22,811295c8 <__reset+0xfb1095c8>
811295f8:	9811883a 	mov	r8,r19
811295fc:	b0800c04 	addi	r2,r22,48
81129600:	8027883a 	mov	r19,r16
81129604:	997fffc4 	addi	r5,r19,-1
81129608:	98bfffc5 	stb	r2,-1(r19)
8112960c:	dc002917 	ldw	r16,164(sp)
81129610:	2f006a2e 	bgeu	r5,fp,811297bc <___vfprintf_internal_r+0x21d8>
81129614:	d9c02384 	addi	r7,sp,142
81129618:	3ccfc83a 	sub	r7,r7,r19
8112961c:	d9002344 	addi	r4,sp,141
81129620:	e1cf883a 	add	r7,fp,r7
81129624:	00000106 	br	8112962c <___vfprintf_internal_r+0x2048>
81129628:	28800003 	ldbu	r2,0(r5)
8112962c:	20800005 	stb	r2,0(r4)
81129630:	21000044 	addi	r4,r4,1
81129634:	29400044 	addi	r5,r5,1
81129638:	393ffb1e 	bne	r7,r4,81129628 <__reset+0xfb109628>
8112963c:	d8802304 	addi	r2,sp,140
81129640:	14c5c83a 	sub	r2,r2,r19
81129644:	d8c02344 	addi	r3,sp,141
81129648:	1885883a 	add	r2,r3,r2
8112964c:	003f7006 	br	81129410 <__reset+0xfb109410>
81129650:	0005883a 	mov	r2,zero
81129654:	003f0f06 	br	81129294 <__reset+0xfb109294>
81129658:	d8c03217 	ldw	r3,200(sp)
8112965c:	18c00044 	addi	r3,r3,1
81129660:	d8c02e15 	stw	r3,184(sp)
81129664:	1805883a 	mov	r2,r3
81129668:	183fb20e 	bge	r3,zero,81129534 <__reset+0xfb109534>
8112966c:	0005883a 	mov	r2,zero
81129670:	003fb006 	br	81129534 <__reset+0xfb109534>
81129674:	d9003617 	ldw	r4,216(sp)
81129678:	000d883a 	mov	r6,zero
8112967c:	000f883a 	mov	r7,zero
81129680:	980b883a 	mov	r5,r19
81129684:	d8c03c15 	stw	r3,240(sp)
81129688:	da003d15 	stw	r8,244(sp)
8112968c:	1137cb80 	call	81137cb8 <__eqdf2>
81129690:	d8c03c17 	ldw	r3,240(sp)
81129694:	da003d17 	ldw	r8,244(sp)
81129698:	103f9826 	beq	r2,zero,811294fc <__reset+0xfb1094fc>
8112969c:	00800044 	movi	r2,1
811296a0:	10c7c83a 	sub	r3,r2,r3
811296a4:	d8c02615 	stw	r3,152(sp)
811296a8:	003f9506 	br	81129500 <__reset+0xfb109500>
811296ac:	d9002917 	ldw	r4,164(sp)
811296b0:	d8c03217 	ldw	r3,200(sp)
811296b4:	20800044 	addi	r2,r4,1
811296b8:	1885883a 	add	r2,r3,r2
811296bc:	d8802e15 	stw	r2,184(sp)
811296c0:	103dbf0e 	bge	r2,zero,81128dc0 <__reset+0xfb108dc0>
811296c4:	0005883a 	mov	r2,zero
811296c8:	003dbd06 	br	81128dc0 <__reset+0xfb108dc0>
811296cc:	2000211e 	bne	r4,zero,81129754 <___vfprintf_internal_r+0x2170>
811296d0:	9480004c 	andi	r18,r18,1
811296d4:	90001f1e 	bne	r18,zero,81129754 <___vfprintf_internal_r+0x2170>
811296d8:	00800044 	movi	r2,1
811296dc:	d8802e15 	stw	r2,184(sp)
811296e0:	003db706 	br	81128dc0 <__reset+0xfb108dc0>
811296e4:	00800b44 	movi	r2,45
811296e8:	05adc83a 	sub	r22,zero,r22
811296ec:	d8802305 	stb	r2,140(sp)
811296f0:	003f3f06 	br	811293f0 <__reset+0xfb1093f0>
811296f4:	0005883a 	mov	r2,zero
811296f8:	003f5206 	br	81129444 <__reset+0xfb109444>
811296fc:	90a4703a 	and	r18,r18,r2
81129700:	903f4e26 	beq	r18,zero,8112943c <__reset+0xfb10943c>
81129704:	003f4a06 	br	81129430 <__reset+0xfb109430>
81129708:	00800084 	movi	r2,2
8112970c:	10c5c83a 	sub	r2,r2,r3
81129710:	003f8406 	br	81129524 <__reset+0xfb109524>
81129714:	d8802d17 	ldw	r2,180(sp)
81129718:	d9002d17 	ldw	r4,180(sp)
8112971c:	ac400043 	ldbu	r17,1(r21)
81129720:	10800017 	ldw	r2,0(r2)
81129724:	582b883a 	mov	r21,r11
81129728:	d8802915 	stw	r2,164(sp)
8112972c:	20800104 	addi	r2,r4,4
81129730:	d9002917 	ldw	r4,164(sp)
81129734:	d8802d15 	stw	r2,180(sp)
81129738:	203e7a0e 	bge	r4,zero,81129124 <__reset+0xfb109124>
8112973c:	8c403fcc 	andi	r17,r17,255
81129740:	00bfffc4 	movi	r2,-1
81129744:	8c40201c 	xori	r17,r17,128
81129748:	d8802915 	stw	r2,164(sp)
8112974c:	8c7fe004 	addi	r17,r17,-128
81129750:	00380706 	br	81127770 <__reset+0xfb107770>
81129754:	d8c02917 	ldw	r3,164(sp)
81129758:	18c00084 	addi	r3,r3,2
8112975c:	d8c02e15 	stw	r3,184(sp)
81129760:	1805883a 	mov	r2,r3
81129764:	183d960e 	bge	r3,zero,81128dc0 <__reset+0xfb108dc0>
81129768:	003fd606 	br	811296c4 <__reset+0xfb1096c4>
8112976c:	0005883a 	mov	r2,zero
81129770:	003f8e06 	br	811295ac <__reset+0xfb1095ac>
81129774:	9080004c 	andi	r2,r18,1
81129778:	103f811e 	bne	r2,zero,81129580 <__reset+0xfb109580>
8112977c:	d8802117 	ldw	r2,132(sp)
81129780:	1405c83a 	sub	r2,r2,r16
81129784:	d8803315 	stw	r2,204(sp)
81129788:	b47ef326 	beq	r22,r17,81129358 <__reset+0xfb109358>
8112978c:	dd802617 	ldw	r22,152(sp)
81129790:	003f1106 	br	811293d8 <__reset+0xfb1093d8>
81129794:	d9c02785 	stb	r7,158(sp)
81129798:	00390406 	br	81127bac <__reset+0xfb107bac>
8112979c:	d9c02785 	stb	r7,158(sp)
811297a0:	0038d306 	br	81127af0 <__reset+0xfb107af0>
811297a4:	d9c02785 	stb	r7,158(sp)
811297a8:	003a6106 	br	81128130 <__reset+0xfb108130>
811297ac:	d9c02785 	stb	r7,158(sp)
811297b0:	003af806 	br	81128394 <__reset+0xfb108394>
811297b4:	0005883a 	mov	r2,zero
811297b8:	003d7e06 	br	81128db4 <__reset+0xfb108db4>
811297bc:	d8802344 	addi	r2,sp,141
811297c0:	003f1306 	br	81129410 <__reset+0xfb109410>
811297c4:	d9c02785 	stb	r7,158(sp)
811297c8:	00392306 	br	81127c58 <__reset+0xfb107c58>
811297cc:	d9c02785 	stb	r7,158(sp)
811297d0:	003aa906 	br	81128278 <__reset+0xfb108278>
811297d4:	d9c02785 	stb	r7,158(sp)
811297d8:	003a3d06 	br	811280d0 <__reset+0xfb1080d0>
811297dc:	d9c02785 	stb	r7,158(sp)
811297e0:	003aca06 	br	8112830c <__reset+0xfb10830c>

811297e4 <__vfprintf_internal>:
811297e4:	00a04574 	movhi	r2,33045
811297e8:	10936004 	addi	r2,r2,19840
811297ec:	300f883a 	mov	r7,r6
811297f0:	280d883a 	mov	r6,r5
811297f4:	200b883a 	mov	r5,r4
811297f8:	11000017 	ldw	r4,0(r2)
811297fc:	11275e41 	jmpi	811275e4 <___vfprintf_internal_r>

81129800 <__sbprintf>:
81129800:	defee204 	addi	sp,sp,-1144
81129804:	de00012e 	bgeu	sp,et,8112980c <__sbprintf+0xc>
81129808:	003b68fa 	trap	3
8112980c:	2880030b 	ldhu	r2,12(r5)
81129810:	2ac01917 	ldw	r11,100(r5)
81129814:	2a80038b 	ldhu	r10,14(r5)
81129818:	2a400717 	ldw	r9,28(r5)
8112981c:	2a000917 	ldw	r8,36(r5)
81129820:	00c10004 	movi	r3,1024
81129824:	dc011a15 	stw	r16,1128(sp)
81129828:	10bfff4c 	andi	r2,r2,65533
8112982c:	2821883a 	mov	r16,r5
81129830:	d8cb883a 	add	r5,sp,r3
81129834:	dc811c15 	stw	r18,1136(sp)
81129838:	dc411b15 	stw	r17,1132(sp)
8112983c:	dfc11d15 	stw	ra,1140(sp)
81129840:	2025883a 	mov	r18,r4
81129844:	d881030d 	sth	r2,1036(sp)
81129848:	dac11915 	stw	r11,1124(sp)
8112984c:	da81038d 	sth	r10,1038(sp)
81129850:	da410715 	stw	r9,1052(sp)
81129854:	da010915 	stw	r8,1060(sp)
81129858:	dec10015 	stw	sp,1024(sp)
8112985c:	dec10415 	stw	sp,1040(sp)
81129860:	d8c10215 	stw	r3,1032(sp)
81129864:	d8c10515 	stw	r3,1044(sp)
81129868:	d8010615 	stw	zero,1048(sp)
8112986c:	11275e40 	call	811275e4 <___vfprintf_internal_r>
81129870:	1023883a 	mov	r17,r2
81129874:	10000416 	blt	r2,zero,81129888 <__sbprintf+0x88>
81129878:	d9410004 	addi	r5,sp,1024
8112987c:	9009883a 	mov	r4,r18
81129880:	112cfa40 	call	8112cfa4 <_fflush_r>
81129884:	10000d1e 	bne	r2,zero,811298bc <__sbprintf+0xbc>
81129888:	d881030b 	ldhu	r2,1036(sp)
8112988c:	1080100c 	andi	r2,r2,64
81129890:	10000326 	beq	r2,zero,811298a0 <__sbprintf+0xa0>
81129894:	8080030b 	ldhu	r2,12(r16)
81129898:	10801014 	ori	r2,r2,64
8112989c:	8080030d 	sth	r2,12(r16)
811298a0:	8805883a 	mov	r2,r17
811298a4:	dfc11d17 	ldw	ra,1140(sp)
811298a8:	dc811c17 	ldw	r18,1136(sp)
811298ac:	dc411b17 	ldw	r17,1132(sp)
811298b0:	dc011a17 	ldw	r16,1128(sp)
811298b4:	dec11e04 	addi	sp,sp,1144
811298b8:	f800283a 	ret
811298bc:	047fffc4 	movi	r17,-1
811298c0:	003ff106 	br	81129888 <__reset+0xfb109888>

811298c4 <__svfscanf_r>:
811298c4:	deff4b04 	addi	sp,sp,-724
811298c8:	de00012e 	bgeu	sp,et,811298d0 <__svfscanf_r+0xc>
811298cc:	003b68fa 	trap	3
811298d0:	2880030b 	ldhu	r2,12(r5)
811298d4:	df00b315 	stw	fp,716(sp)
811298d8:	dd80b115 	stw	r22,708(sp)
811298dc:	dfc0b415 	stw	ra,720(sp)
811298e0:	ddc0b215 	stw	r23,712(sp)
811298e4:	dd40b015 	stw	r21,704(sp)
811298e8:	dd00af15 	stw	r20,700(sp)
811298ec:	dcc0ae15 	stw	r19,696(sp)
811298f0:	dc80ad15 	stw	r18,692(sp)
811298f4:	dc40ac15 	stw	r17,688(sp)
811298f8:	dc00ab15 	stw	r16,684(sp)
811298fc:	10c8000c 	andi	r3,r2,8192
81129900:	d9c09c15 	stw	r7,624(sp)
81129904:	2839883a 	mov	fp,r5
81129908:	202d883a 	mov	r22,r4
8112990c:	1800061e 	bne	r3,zero,81129928 <__svfscanf_r+0x64>
81129910:	29001917 	ldw	r4,100(r5)
81129914:	00f7ffc4 	movi	r3,-8193
81129918:	10880014 	ori	r2,r2,8192
8112991c:	20c6703a 	and	r3,r4,r3
81129920:	2880030d 	sth	r2,12(r5)
81129924:	28c01915 	stw	r3,100(r5)
81129928:	30800003 	ldbu	r2,0(r6)
8112992c:	0021883a 	mov	r16,zero
81129930:	05e04574 	movhi	r23,33045
81129934:	d800a115 	stw	zero,644(sp)
81129938:	d8009e15 	stw	zero,632(sp)
8112993c:	d800a015 	stw	zero,640(sp)
81129940:	d8809b15 	stw	r2,620(sp)
81129944:	bdd35e04 	addi	r23,r23,19832
81129948:	8025883a 	mov	r18,r16
8112994c:	35000044 	addi	r20,r6,1
81129950:	10001e26 	beq	r2,zero,811299cc <__svfscanf_r+0x108>
81129954:	b9c00017 	ldw	r7,0(r23)
81129958:	3887883a 	add	r3,r7,r2
8112995c:	18c00043 	ldbu	r3,1(r3)
81129960:	18c0020c 	andi	r3,r3,8
81129964:	18001b26 	beq	r3,zero,811299d4 <__svfscanf_r+0x110>
81129968:	e0800117 	ldw	r2,4(fp)
8112996c:	00800e0e 	bge	zero,r2,811299a8 <__svfscanf_r+0xe4>
81129970:	e0c00017 	ldw	r3,0(fp)
81129974:	b9000017 	ldw	r4,0(r23)
81129978:	18800003 	ldbu	r2,0(r3)
8112997c:	2085883a 	add	r2,r4,r2
81129980:	10800043 	ldbu	r2,1(r2)
81129984:	1080020c 	andi	r2,r2,8
81129988:	10000b26 	beq	r2,zero,811299b8 <__svfscanf_r+0xf4>
8112998c:	e0800117 	ldw	r2,4(fp)
81129990:	18c00044 	addi	r3,r3,1
81129994:	e0c00015 	stw	r3,0(fp)
81129998:	10bfffc4 	addi	r2,r2,-1
8112999c:	e0800115 	stw	r2,4(fp)
811299a0:	94800044 	addi	r18,r18,1
811299a4:	00bff216 	blt	zero,r2,81129970 <__reset+0xfb109970>
811299a8:	e00b883a 	mov	r5,fp
811299ac:	b009883a 	mov	r4,r22
811299b0:	11248a00 	call	811248a0 <__srefill_r>
811299b4:	103fee26 	beq	r2,zero,81129970 <__reset+0xfb109970>
811299b8:	a00d883a 	mov	r6,r20
811299bc:	30800003 	ldbu	r2,0(r6)
811299c0:	35000044 	addi	r20,r6,1
811299c4:	d8809b15 	stw	r2,620(sp)
811299c8:	103fe21e 	bne	r2,zero,81129954 <__reset+0xfb109954>
811299cc:	d880a017 	ldw	r2,640(sp)
811299d0:	00009906 	br	81129c38 <__svfscanf_r+0x374>
811299d4:	00c00944 	movi	r3,37
811299d8:	10c0881e 	bne	r2,r3,81129bfc <__svfscanf_r+0x338>
811299dc:	30c00043 	ldbu	r3,1(r6)
811299e0:	0023883a 	mov	r17,zero
811299e4:	0027883a 	mov	r19,zero
811299e8:	01001e04 	movi	r4,120
811299ec:	01401b04 	movi	r5,108
811299f0:	a1800044 	addi	r6,r20,1
811299f4:	20c0a236 	bltu	r4,r3,81129c80 <__svfscanf_r+0x3bc>
811299f8:	180490ba 	slli	r2,r3,2
811299fc:	022044f4 	movhi	r8,33043
81129a00:	42268404 	addi	r8,r8,-26096
81129a04:	1205883a 	add	r2,r2,r8
81129a08:	10800017 	ldw	r2,0(r2)
81129a0c:	1000683a 	jmp	r2
81129a10:	81129c34 	orhi	r4,r16,19056
81129a14:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a18:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a1c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a20:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a24:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a28:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a2c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a30:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a34:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a38:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a3c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a40:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a44:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a48:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a4c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a50:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a54:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a58:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a5c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a60:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a64:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a68:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a6c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a70:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a74:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a78:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a7c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a80:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a84:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a88:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a8c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a90:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a94:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a98:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129a9c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129aa0:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129aa4:	81129bf4 	orhi	r4,r16,19055
81129aa8:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129aac:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129ab0:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129ab4:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129ab8:	81129c68 	cmpgeui	r4,r16,19057
81129abc:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129ac0:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129ac4:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129ac8:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129acc:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129ad0:	81129d9c 	xori	r4,r16,19062
81129ad4:	81129d9c 	xori	r4,r16,19062
81129ad8:	81129d9c 	xori	r4,r16,19062
81129adc:	81129d9c 	xori	r4,r16,19062
81129ae0:	81129d9c 	xori	r4,r16,19062
81129ae4:	81129d9c 	xori	r4,r16,19062
81129ae8:	81129d9c 	xori	r4,r16,19062
81129aec:	81129d9c 	xori	r4,r16,19062
81129af0:	81129d9c 	xori	r4,r16,19062
81129af4:	81129d9c 	xori	r4,r16,19062
81129af8:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129afc:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b00:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b04:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b08:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b0c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b10:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b14:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b18:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b1c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b20:	81129d70 	cmpltui	r4,r16,19061
81129b24:	81129e20 	cmpeqi	r4,r16,19064
81129b28:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b2c:	81129e20 	cmpeqi	r4,r16,19064
81129b30:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b34:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b38:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b3c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b40:	81129e0c 	andi	r4,r16,19064
81129b44:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b48:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b4c:	81129de0 	cmpeqi	r4,r16,19063
81129b50:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b54:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b58:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b5c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b60:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b64:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b68:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b6c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b70:	81129db8 	rdprs	r4,r16,19062
81129b74:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b78:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b7c:	81129f54 	ori	r4,r16,19069
81129b80:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b84:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b88:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b8c:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b90:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b94:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b98:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129b9c:	81129ed8 	cmpnei	r4,r16,19067
81129ba0:	81129eb0 	cmpltui	r4,r16,19066
81129ba4:	81129e20 	cmpeqi	r4,r16,19064
81129ba8:	81129e20 	cmpeqi	r4,r16,19064
81129bac:	81129e20 	cmpeqi	r4,r16,19064
81129bb0:	81129e9c 	xori	r4,r16,19066
81129bb4:	81129fe0 	cmpeqi	r4,r16,19071
81129bb8:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129bbc:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129bc0:	81129e88 	cmpgei	r4,r16,19066
81129bc4:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129bc8:	81129e58 	cmpnei	r4,r16,19065
81129bcc:	81129e34 	orhi	r4,r16,19064
81129bd0:	81129d44 	addi	r4,r16,19061
81129bd4:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129bd8:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129bdc:	81129d30 	cmpltui	r4,r16,19060
81129be0:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129be4:	81129cb8 	rdprs	r4,r16,19058
81129be8:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129bec:	81129c80 	call	881129c8 <__reset+0x20f29c8>
81129bf0:	81129db8 	rdprs	r4,r16,19062
81129bf4:	d9809d15 	stw	r6,628(sp)
81129bf8:	3029883a 	mov	r20,r6
81129bfc:	e0800117 	ldw	r2,4(fp)
81129c00:	0081aa0e 	bge	zero,r2,8112a2ac <__svfscanf_r+0x9e8>
81129c04:	e0800017 	ldw	r2,0(fp)
81129c08:	a0ffffc3 	ldbu	r3,-1(r20)
81129c0c:	11000003 	ldbu	r4,0(r2)
81129c10:	20ff6e1e 	bne	r4,r3,811299cc <__reset+0xfb1099cc>
81129c14:	e0c00117 	ldw	r3,4(fp)
81129c18:	10800044 	addi	r2,r2,1
81129c1c:	e0800015 	stw	r2,0(fp)
81129c20:	18bfffc4 	addi	r2,r3,-1
81129c24:	e0800115 	stw	r2,4(fp)
81129c28:	94800044 	addi	r18,r18,1
81129c2c:	a00d883a 	mov	r6,r20
81129c30:	003f6206 	br	811299bc <__reset+0xfb1099bc>
81129c34:	00bfffc4 	movi	r2,-1
81129c38:	dfc0b417 	ldw	ra,720(sp)
81129c3c:	df00b317 	ldw	fp,716(sp)
81129c40:	ddc0b217 	ldw	r23,712(sp)
81129c44:	dd80b117 	ldw	r22,708(sp)
81129c48:	dd40b017 	ldw	r21,704(sp)
81129c4c:	dd00af17 	ldw	r20,700(sp)
81129c50:	dcc0ae17 	ldw	r19,696(sp)
81129c54:	dc80ad17 	ldw	r18,692(sp)
81129c58:	dc40ac17 	ldw	r17,688(sp)
81129c5c:	dc00ab17 	ldw	r16,684(sp)
81129c60:	dec0b504 	addi	sp,sp,724
81129c64:	f800283a 	ret
81129c68:	a0800043 	ldbu	r2,1(r20)
81129c6c:	3029883a 	mov	r20,r6
81129c70:	8c400414 	ori	r17,r17,16
81129c74:	10c03fcc 	andi	r3,r2,255
81129c78:	a1800044 	addi	r6,r20,1
81129c7c:	20ff5e2e 	bgeu	r4,r3,811299f8 <__reset+0xfb1099f8>
81129c80:	38c7883a 	add	r3,r7,r3
81129c84:	18800043 	ldbu	r2,1(r3)
81129c88:	d9809d15 	stw	r6,628(sp)
81129c8c:	00c00044 	movi	r3,1
81129c90:	108000cc 	andi	r2,r2,3
81129c94:	10c18f26 	beq	r2,r3,8112a2d4 <__svfscanf_r+0xa10>
81129c98:	e0800117 	ldw	r2,4(fp)
81129c9c:	00808716 	blt	zero,r2,81129ebc <__svfscanf_r+0x5f8>
81129ca0:	e00b883a 	mov	r5,fp
81129ca4:	b009883a 	mov	r4,r22
81129ca8:	11248a00 	call	811248a0 <__srefill_r>
81129cac:	1001431e 	bne	r2,zero,8112a1bc <__svfscanf_r+0x8f8>
81129cb0:	b9c00017 	ldw	r7,0(r23)
81129cb4:	00008106 	br	81129ebc <__svfscanf_r+0x5f8>
81129cb8:	e0800117 	ldw	r2,4(fp)
81129cbc:	d9809d15 	stw	r6,628(sp)
81129cc0:	0081a30e 	bge	zero,r2,8112a350 <__svfscanf_r+0xa8c>
81129cc4:	00a044f4 	movhi	r2,33043
81129cc8:	1085fb04 	addi	r2,r2,6124
81129ccc:	02000284 	movi	r8,10
81129cd0:	d880a115 	stw	r2,644(sp)
81129cd4:	da009e15 	stw	r8,632(sp)
81129cd8:	050000c4 	movi	r20,3
81129cdc:	e0c00017 	ldw	r3,0(fp)
81129ce0:	00000206 	br	81129cec <__svfscanf_r+0x428>
81129ce4:	18c00044 	addi	r3,r3,1
81129ce8:	e0c00015 	stw	r3,0(fp)
81129cec:	19000003 	ldbu	r4,0(r3)
81129cf0:	20803fcc 	andi	r2,r4,255
81129cf4:	3885883a 	add	r2,r7,r2
81129cf8:	10800043 	ldbu	r2,1(r2)
81129cfc:	1140020c 	andi	r5,r2,8
81129d00:	2801ab26 	beq	r5,zero,8112a3b0 <__svfscanf_r+0xaec>
81129d04:	e0800117 	ldw	r2,4(fp)
81129d08:	94800044 	addi	r18,r18,1
81129d0c:	10bfffc4 	addi	r2,r2,-1
81129d10:	e0800115 	stw	r2,4(fp)
81129d14:	00bff316 	blt	zero,r2,81129ce4 <__reset+0xfb109ce4>
81129d18:	e00b883a 	mov	r5,fp
81129d1c:	b009883a 	mov	r4,r22
81129d20:	11248a00 	call	811248a0 <__srefill_r>
81129d24:	1001251e 	bne	r2,zero,8112a1bc <__svfscanf_r+0x8f8>
81129d28:	b9c00017 	ldw	r7,0(r23)
81129d2c:	003feb06 	br	81129cdc <__reset+0xfb109cdc>
81129d30:	e0800117 	ldw	r2,4(fp)
81129d34:	d9809d15 	stw	r6,628(sp)
81129d38:	00818b0e 	bge	zero,r2,8112a368 <__svfscanf_r+0xaa4>
81129d3c:	05000084 	movi	r20,2
81129d40:	003fe606 	br	81129cdc <__reset+0xfb109cdc>
81129d44:	e0800117 	ldw	r2,4(fp)
81129d48:	d9809d15 	stw	r6,628(sp)
81129d4c:	8c408814 	ori	r17,r17,544
81129d50:	00801d0e 	bge	zero,r2,81129dc8 <__svfscanf_r+0x504>
81129d54:	00a044f4 	movhi	r2,33043
81129d58:	1085fb04 	addi	r2,r2,6124
81129d5c:	02000404 	movi	r8,16
81129d60:	d880a115 	stw	r2,644(sp)
81129d64:	da009e15 	stw	r8,632(sp)
81129d68:	050000c4 	movi	r20,3
81129d6c:	003fdb06 	br	81129cdc <__reset+0xfb109cdc>
81129d70:	e0800117 	ldw	r2,4(fp)
81129d74:	d9809d15 	stw	r6,628(sp)
81129d78:	8c400054 	ori	r17,r17,1
81129d7c:	00bfc80e 	bge	zero,r2,81129ca0 <__reset+0xfb109ca0>
81129d80:	00e044b4 	movhi	r3,33042
81129d84:	18d3a904 	addi	r3,r3,20132
81129d88:	02000284 	movi	r8,10
81129d8c:	d8c0a115 	stw	r3,644(sp)
81129d90:	da009e15 	stw	r8,632(sp)
81129d94:	050000c4 	movi	r20,3
81129d98:	003fd006 	br	81129cdc <__reset+0xfb109cdc>
81129d9c:	9cc002a4 	muli	r19,r19,10
81129da0:	a0800043 	ldbu	r2,1(r20)
81129da4:	3029883a 	mov	r20,r6
81129da8:	98e7883a 	add	r19,r19,r3
81129dac:	9cfff404 	addi	r19,r19,-48
81129db0:	10c03fcc 	andi	r3,r2,255
81129db4:	003f0e06 	br	811299f0 <__reset+0xfb1099f0>
81129db8:	e0800117 	ldw	r2,4(fp)
81129dbc:	d9809d15 	stw	r6,628(sp)
81129dc0:	8c408014 	ori	r17,r17,512
81129dc4:	00bfe316 	blt	zero,r2,81129d54 <__reset+0xfb109d54>
81129dc8:	e00b883a 	mov	r5,fp
81129dcc:	b009883a 	mov	r4,r22
81129dd0:	11248a00 	call	811248a0 <__srefill_r>
81129dd4:	1000f91e 	bne	r2,zero,8112a1bc <__svfscanf_r+0x8f8>
81129dd8:	b9c00017 	ldw	r7,0(r23)
81129ddc:	003fdd06 	br	81129d54 <__reset+0xfb109d54>
81129de0:	e0800117 	ldw	r2,4(fp)
81129de4:	d9809d15 	stw	r6,628(sp)
81129de8:	8c400054 	ori	r17,r17,1
81129dec:	0080140e 	bge	zero,r2,81129e40 <__svfscanf_r+0x57c>
81129df0:	00a044f4 	movhi	r2,33043
81129df4:	1085fb04 	addi	r2,r2,6124
81129df8:	02000204 	movi	r8,8
81129dfc:	d880a115 	stw	r2,644(sp)
81129e00:	da009e15 	stw	r8,632(sp)
81129e04:	050000c4 	movi	r20,3
81129e08:	003fb406 	br	81129cdc <__reset+0xfb109cdc>
81129e0c:	a0800043 	ldbu	r2,1(r20)
81129e10:	8c400094 	ori	r17,r17,2
81129e14:	3029883a 	mov	r20,r6
81129e18:	10c03fcc 	andi	r3,r2,255
81129e1c:	003ef406 	br	811299f0 <__reset+0xfb1099f0>
81129e20:	e0800117 	ldw	r2,4(fp)
81129e24:	d9809d15 	stw	r6,628(sp)
81129e28:	0081420e 	bge	zero,r2,8112a334 <__svfscanf_r+0xa70>
81129e2c:	05000104 	movi	r20,4
81129e30:	003faa06 	br	81129cdc <__reset+0xfb109cdc>
81129e34:	e0800117 	ldw	r2,4(fp)
81129e38:	d9809d15 	stw	r6,628(sp)
81129e3c:	00bfec16 	blt	zero,r2,81129df0 <__reset+0xfb109df0>
81129e40:	e00b883a 	mov	r5,fp
81129e44:	b009883a 	mov	r4,r22
81129e48:	11248a00 	call	811248a0 <__srefill_r>
81129e4c:	1000db1e 	bne	r2,zero,8112a1bc <__svfscanf_r+0x8f8>
81129e50:	b9c00017 	ldw	r7,0(r23)
81129e54:	003fe606 	br	81129df0 <__reset+0xfb109df0>
81129e58:	d9809d15 	stw	r6,628(sp)
81129e5c:	8880040c 	andi	r2,r17,16
81129e60:	10009c1e 	bne	r2,zero,8112a0d4 <__svfscanf_r+0x810>
81129e64:	8880010c 	andi	r2,r17,4
81129e68:	10011e26 	beq	r2,zero,8112a2e4 <__svfscanf_r+0xa20>
81129e6c:	da009c17 	ldw	r8,624(sp)
81129e70:	3029883a 	mov	r20,r6
81129e74:	40800017 	ldw	r2,0(r8)
81129e78:	42000104 	addi	r8,r8,4
81129e7c:	da009c15 	stw	r8,624(sp)
81129e80:	1480000d 	sth	r18,0(r2)
81129e84:	003ecc06 	br	811299b8 <__reset+0xfb1099b8>
81129e88:	a0c00043 	ldbu	r3,1(r20)
81129e8c:	19410c26 	beq	r3,r5,8112a2c0 <__svfscanf_r+0x9fc>
81129e90:	8c400054 	ori	r17,r17,1
81129e94:	3029883a 	mov	r20,r6
81129e98:	003ed506 	br	811299f0 <__reset+0xfb1099f0>
81129e9c:	a0800043 	ldbu	r2,1(r20)
81129ea0:	8c400114 	ori	r17,r17,4
81129ea4:	3029883a 	mov	r20,r6
81129ea8:	10c03fcc 	andi	r3,r2,255
81129eac:	003ed006 	br	811299f0 <__reset+0xfb1099f0>
81129eb0:	e0800117 	ldw	r2,4(fp)
81129eb4:	d9809d15 	stw	r6,628(sp)
81129eb8:	00bf790e 	bge	zero,r2,81129ca0 <__reset+0xfb109ca0>
81129ebc:	00a044b4 	movhi	r2,33042
81129ec0:	1093a904 	addi	r2,r2,20132
81129ec4:	02000284 	movi	r8,10
81129ec8:	d880a115 	stw	r2,644(sp)
81129ecc:	da009e15 	stw	r8,632(sp)
81129ed0:	050000c4 	movi	r20,3
81129ed4:	003f8106 	br	81129cdc <__reset+0xfb109cdc>
81129ed8:	e0800117 	ldw	r2,4(fp)
81129edc:	d9809d15 	stw	r6,628(sp)
81129ee0:	0080c40e 	bge	zero,r2,8112a1f4 <__svfscanf_r+0x930>
81129ee4:	9800011e 	bne	r19,zero,81129eec <__svfscanf_r+0x628>
81129ee8:	04c00044 	movi	r19,1
81129eec:	8880004c 	andi	r2,r17,1
81129ef0:	1000441e 	bne	r2,zero,8112a004 <__svfscanf_r+0x740>
81129ef4:	8c40040c 	andi	r17,r17,16
81129ef8:	8800da26 	beq	r17,zero,8112a264 <__svfscanf_r+0x9a0>
81129efc:	0021883a 	mov	r16,zero
81129f00:	00000806 	br	81129f24 <__svfscanf_r+0x660>
81129f04:	1887883a 	add	r3,r3,r2
81129f08:	e00b883a 	mov	r5,fp
81129f0c:	b009883a 	mov	r4,r22
81129f10:	e0c00015 	stw	r3,0(fp)
81129f14:	80a1883a 	add	r16,r16,r2
81129f18:	98a7c83a 	sub	r19,r19,r2
81129f1c:	11248a00 	call	811248a0 <__srefill_r>
81129f20:	1000ca1e 	bne	r2,zero,8112a24c <__svfscanf_r+0x988>
81129f24:	e0800117 	ldw	r2,4(fp)
81129f28:	e0c00017 	ldw	r3,0(fp)
81129f2c:	14fff516 	blt	r2,r19,81129f04 <__reset+0xfb109f04>
81129f30:	14c5c83a 	sub	r2,r2,r19
81129f34:	1cd5883a 	add	r10,r3,r19
81129f38:	84e1883a 	add	r16,r16,r19
81129f3c:	e0800115 	stw	r2,4(fp)
81129f40:	e2800015 	stw	r10,0(fp)
81129f44:	dd009d17 	ldw	r20,628(sp)
81129f48:	9425883a 	add	r18,r18,r16
81129f4c:	a00d883a 	mov	r6,r20
81129f50:	003e9a06 	br	811299bc <__reset+0xfb1099bc>
81129f54:	300b883a 	mov	r5,r6
81129f58:	d9005884 	addi	r4,sp,354
81129f5c:	d9809d15 	stw	r6,628(sp)
81129f60:	112feac0 	call	8112feac <__sccl>
81129f64:	1029883a 	mov	r20,r2
81129f68:	e0800117 	ldw	r2,4(fp)
81129f6c:	0081050e 	bge	zero,r2,8112a384 <__svfscanf_r+0xac0>
81129f70:	e1000017 	ldw	r4,0(fp)
81129f74:	20800003 	ldbu	r2,0(r4)
81129f78:	98005926 	beq	r19,zero,8112a0e0 <__svfscanf_r+0x81c>
81129f7c:	8c40040c 	andi	r17,r17,16
81129f80:	88005a26 	beq	r17,zero,8112a0ec <__svfscanf_r+0x828>
81129f84:	9823883a 	mov	r17,r19
81129f88:	0021883a 	mov	r16,zero
81129f8c:	00000106 	br	81129f94 <__svfscanf_r+0x6d0>
81129f90:	20800003 	ldbu	r2,0(r4)
81129f94:	10803fcc 	andi	r2,r2,255
81129f98:	d8c05884 	addi	r3,sp,354
81129f9c:	1885883a 	add	r2,r3,r2
81129fa0:	10800007 	ldb	r2,0(r2)
81129fa4:	1000ad26 	beq	r2,zero,8112a25c <__svfscanf_r+0x998>
81129fa8:	e0800117 	ldw	r2,4(fp)
81129fac:	21000044 	addi	r4,r4,1
81129fb0:	84000044 	addi	r16,r16,1
81129fb4:	10bfffc4 	addi	r2,r2,-1
81129fb8:	e0800115 	stw	r2,4(fp)
81129fbc:	e1000015 	stw	r4,0(fp)
81129fc0:	84c0a026 	beq	r16,r19,8112a244 <__svfscanf_r+0x980>
81129fc4:	00bff216 	blt	zero,r2,81129f90 <__reset+0xfb109f90>
81129fc8:	e00b883a 	mov	r5,fp
81129fcc:	b009883a 	mov	r4,r22
81129fd0:	11248a00 	call	811248a0 <__srefill_r>
81129fd4:	10009a1e 	bne	r2,zero,8112a240 <__svfscanf_r+0x97c>
81129fd8:	e1000017 	ldw	r4,0(fp)
81129fdc:	003fec06 	br	81129f90 <__reset+0xfb109f90>
81129fe0:	e0800117 	ldw	r2,4(fp)
81129fe4:	d9809d15 	stw	r6,628(sp)
81129fe8:	0080eb0e 	bge	zero,r2,8112a398 <__svfscanf_r+0xad4>
81129fec:	00a044b4 	movhi	r2,33042
81129ff0:	1093a904 	addi	r2,r2,20132
81129ff4:	d880a115 	stw	r2,644(sp)
81129ff8:	d8009e15 	stw	zero,632(sp)
81129ffc:	050000c4 	movi	r20,3
8112a000:	003f3606 	br	81129cdc <__reset+0xfb109cdc>
8112a004:	dd409904 	addi	r21,sp,612
8112a008:	8c40040c 	andi	r17,r17,16
8112a00c:	01800204 	movi	r6,8
8112a010:	000b883a 	mov	r5,zero
8112a014:	a809883a 	mov	r4,r21
8112a018:	dc409f15 	stw	r17,636(sp)
8112a01c:	11244a00 	call	811244a0 <memset>
8112a020:	dc409f17 	ldw	r17,636(sp)
8112a024:	88006e26 	beq	r17,zero,8112a1e0 <__svfscanf_r+0x91c>
8112a028:	0029883a 	mov	r20,zero
8112a02c:	0023883a 	mov	r17,zero
8112a030:	112e2c80 	call	8112e2c8 <__locale_mb_cur_max>
8112a034:	14406126 	beq	r2,r17,8112a1bc <__svfscanf_r+0x8f8>
8112a038:	e0800017 	ldw	r2,0(fp)
8112a03c:	e0c00117 	ldw	r3,4(fp)
8112a040:	d9000104 	addi	r4,sp,4
8112a044:	12000003 	ldbu	r8,0(r2)
8112a048:	18ffffc4 	addi	r3,r3,-1
8112a04c:	10800044 	addi	r2,r2,1
8112a050:	e0c00115 	stw	r3,4(fp)
8112a054:	e0800015 	stw	r2,0(fp)
8112a058:	8c000044 	addi	r16,r17,1
8112a05c:	dd400015 	stw	r21,0(sp)
8112a060:	2463883a 	add	r17,r4,r17
8112a064:	200d883a 	mov	r6,r4
8112a068:	a00b883a 	mov	r5,r20
8112a06c:	800f883a 	mov	r7,r16
8112a070:	b009883a 	mov	r4,r22
8112a074:	8a000005 	stb	r8,0(r17)
8112a078:	112e3840 	call	8112e384 <_mbrtowc_r>
8112a07c:	017fffc4 	movi	r5,-1
8112a080:	11404e26 	beq	r2,r5,8112a1bc <__svfscanf_r+0x8f8>
8112a084:	1000601e 	bne	r2,zero,8112a208 <__svfscanf_r+0x944>
8112a088:	da009f17 	ldw	r8,636(sp)
8112a08c:	4000641e 	bne	r8,zero,8112a220 <__svfscanf_r+0x95c>
8112a090:	a0000015 	stw	zero,0(r20)
8112a094:	9425883a 	add	r18,r18,r16
8112a098:	9967883a 	add	r19,r19,r5
8112a09c:	a5000104 	addi	r20,r20,4
8112a0a0:	e0800117 	ldw	r2,4(fp)
8112a0a4:	0023883a 	mov	r17,zero
8112a0a8:	00804b16 	blt	zero,r2,8112a1d8 <__svfscanf_r+0x914>
8112a0ac:	e00b883a 	mov	r5,fp
8112a0b0:	b009883a 	mov	r4,r22
8112a0b4:	11248a00 	call	811248a0 <__srefill_r>
8112a0b8:	10004726 	beq	r2,zero,8112a1d8 <__svfscanf_r+0x914>
8112a0bc:	88003f1e 	bne	r17,zero,8112a1bc <__svfscanf_r+0x8f8>
8112a0c0:	d8c09f17 	ldw	r3,636(sp)
8112a0c4:	1800031e 	bne	r3,zero,8112a0d4 <__svfscanf_r+0x810>
8112a0c8:	da00a017 	ldw	r8,640(sp)
8112a0cc:	42000044 	addi	r8,r8,1
8112a0d0:	da00a015 	stw	r8,640(sp)
8112a0d4:	dd009d17 	ldw	r20,628(sp)
8112a0d8:	a00d883a 	mov	r6,r20
8112a0dc:	003e3706 	br	811299bc <__reset+0xfb1099bc>
8112a0e0:	8c40040c 	andi	r17,r17,16
8112a0e4:	04ffffc4 	movi	r19,-1
8112a0e8:	883fa61e 	bne	r17,zero,81129f84 <__reset+0xfb109f84>
8112a0ec:	da009c17 	ldw	r8,624(sp)
8112a0f0:	9abfffc4 	addi	r10,r19,-1
8112a0f4:	44000017 	ldw	r16,0(r8)
8112a0f8:	44400104 	addi	r17,r8,4
8112a0fc:	8007883a 	mov	r3,r16
8112a100:	82ab883a 	add	r21,r16,r10
8112a104:	00000306 	br	8112a114 <__svfscanf_r+0x850>
8112a108:	e1000017 	ldw	r4,0(fp)
8112a10c:	9807883a 	mov	r3,r19
8112a110:	20800003 	ldbu	r2,0(r4)
8112a114:	10803fcc 	andi	r2,r2,255
8112a118:	d9405884 	addi	r5,sp,354
8112a11c:	2885883a 	add	r2,r5,r2
8112a120:	10800007 	ldb	r2,0(r2)
8112a124:	10004b26 	beq	r2,zero,8112a254 <__svfscanf_r+0x990>
8112a128:	e0800117 	ldw	r2,4(fp)
8112a12c:	21400044 	addi	r5,r4,1
8112a130:	e1400015 	stw	r5,0(fp)
8112a134:	10bfffc4 	addi	r2,r2,-1
8112a138:	e0800115 	stw	r2,4(fp)
8112a13c:	20800003 	ldbu	r2,0(r4)
8112a140:	1cc00044 	addi	r19,r3,1
8112a144:	18800005 	stb	r2,0(r3)
8112a148:	1d400726 	beq	r3,r21,8112a168 <__svfscanf_r+0x8a4>
8112a14c:	e0800117 	ldw	r2,4(fp)
8112a150:	00bfed16 	blt	zero,r2,8112a108 <__reset+0xfb10a108>
8112a154:	e00b883a 	mov	r5,fp
8112a158:	b009883a 	mov	r4,r22
8112a15c:	11248a00 	call	811248a0 <__srefill_r>
8112a160:	103fe926 	beq	r2,zero,8112a108 <__reset+0xfb10a108>
8112a164:	84c01526 	beq	r16,r19,8112a1bc <__svfscanf_r+0x8f8>
8112a168:	9c21c83a 	sub	r16,r19,r16
8112a16c:	803e1726 	beq	r16,zero,811299cc <__reset+0xfb1099cc>
8112a170:	da00a017 	ldw	r8,640(sp)
8112a174:	98000005 	stb	zero,0(r19)
8112a178:	dc409c15 	stw	r17,624(sp)
8112a17c:	42000044 	addi	r8,r8,1
8112a180:	da00a015 	stw	r8,640(sp)
8112a184:	9425883a 	add	r18,r18,r16
8112a188:	a00d883a 	mov	r6,r20
8112a18c:	003e0b06 	br	811299bc <__reset+0xfb1099bc>
8112a190:	017fff84 	movi	r5,-2
8112a194:	11439b1e 	bne	r2,r5,8112b004 <__svfscanf_r+0x1740>
8112a198:	8821883a 	mov	r16,r17
8112a19c:	e0800117 	ldw	r2,4(fp)
8112a1a0:	0082e516 	blt	zero,r2,8112ad38 <__svfscanf_r+0x1474>
8112a1a4:	e00b883a 	mov	r5,fp
8112a1a8:	b009883a 	mov	r4,r22
8112a1ac:	11248a00 	call	811248a0 <__srefill_r>
8112a1b0:	1002e126 	beq	r2,zero,8112ad38 <__svfscanf_r+0x1474>
8112a1b4:	dc409f17 	ldw	r17,636(sp)
8112a1b8:	8002e826 	beq	r16,zero,8112ad5c <__svfscanf_r+0x1498>
8112a1bc:	da00a017 	ldw	r8,640(sp)
8112a1c0:	403e9c26 	beq	r8,zero,81129c34 <__reset+0xfb109c34>
8112a1c4:	e080030b 	ldhu	r2,12(fp)
8112a1c8:	1080100c 	andi	r2,r2,64
8112a1cc:	103e991e 	bne	r2,zero,81129c34 <__reset+0xfb109c34>
8112a1d0:	4005883a 	mov	r2,r8
8112a1d4:	003e9806 	br	81129c38 <__reset+0xfb109c38>
8112a1d8:	983f951e 	bne	r19,zero,8112a030 <__reset+0xfb10a030>
8112a1dc:	003fb806 	br	8112a0c0 <__reset+0xfb10a0c0>
8112a1e0:	da009c17 	ldw	r8,624(sp)
8112a1e4:	45000017 	ldw	r20,0(r8)
8112a1e8:	42000104 	addi	r8,r8,4
8112a1ec:	da009c15 	stw	r8,624(sp)
8112a1f0:	003f8e06 	br	8112a02c <__reset+0xfb10a02c>
8112a1f4:	e00b883a 	mov	r5,fp
8112a1f8:	b009883a 	mov	r4,r22
8112a1fc:	11248a00 	call	811248a0 <__srefill_r>
8112a200:	103f3826 	beq	r2,zero,81129ee4 <__reset+0xfb109ee4>
8112a204:	003fed06 	br	8112a1bc <__reset+0xfb10a1bc>
8112a208:	00ffff84 	movi	r3,-2
8112a20c:	10c0071e 	bne	r2,r3,8112a22c <__svfscanf_r+0x968>
8112a210:	e0800117 	ldw	r2,4(fp)
8112a214:	8023883a 	mov	r17,r16
8112a218:	00bf8516 	blt	zero,r2,8112a030 <__reset+0xfb10a030>
8112a21c:	003fa306 	br	8112a0ac <__reset+0xfb10a0ac>
8112a220:	9425883a 	add	r18,r18,r16
8112a224:	9cffffc4 	addi	r19,r19,-1
8112a228:	003f9d06 	br	8112a0a0 <__reset+0xfb10a0a0>
8112a22c:	da009f17 	ldw	r8,636(sp)
8112a230:	9425883a 	add	r18,r18,r16
8112a234:	9cffffc4 	addi	r19,r19,-1
8112a238:	403f9826 	beq	r8,zero,8112a09c <__reset+0xfb10a09c>
8112a23c:	003f9806 	br	8112a0a0 <__reset+0xfb10a0a0>
8112a240:	8023883a 	mov	r17,r16
8112a244:	8821883a 	mov	r16,r17
8112a248:	003fce06 	br	8112a184 <__reset+0xfb10a184>
8112a24c:	803f3d1e 	bne	r16,zero,81129f44 <__reset+0xfb109f44>
8112a250:	003fda06 	br	8112a1bc <__reset+0xfb10a1bc>
8112a254:	1827883a 	mov	r19,r3
8112a258:	003fc306 	br	8112a168 <__reset+0xfb10a168>
8112a25c:	803fc91e 	bne	r16,zero,8112a184 <__reset+0xfb10a184>
8112a260:	003dda06 	br	811299cc <__reset+0xfb1099cc>
8112a264:	da009c17 	ldw	r8,624(sp)
8112a268:	df000015 	stw	fp,0(sp)
8112a26c:	980f883a 	mov	r7,r19
8112a270:	41400017 	ldw	r5,0(r8)
8112a274:	01800044 	movi	r6,1
8112a278:	b009883a 	mov	r4,r22
8112a27c:	112d49c0 	call	8112d49c <_fread_r>
8112a280:	da009c17 	ldw	r8,624(sp)
8112a284:	40c00104 	addi	r3,r8,4
8112a288:	103fcc26 	beq	r2,zero,8112a1bc <__reset+0xfb10a1bc>
8112a28c:	da00a017 	ldw	r8,640(sp)
8112a290:	dd009d17 	ldw	r20,628(sp)
8112a294:	90a5883a 	add	r18,r18,r2
8112a298:	42000044 	addi	r8,r8,1
8112a29c:	da00a015 	stw	r8,640(sp)
8112a2a0:	d8c09c15 	stw	r3,624(sp)
8112a2a4:	a00d883a 	mov	r6,r20
8112a2a8:	003dc406 	br	811299bc <__reset+0xfb1099bc>
8112a2ac:	e00b883a 	mov	r5,fp
8112a2b0:	b009883a 	mov	r4,r22
8112a2b4:	11248a00 	call	811248a0 <__srefill_r>
8112a2b8:	103e5226 	beq	r2,zero,81129c04 <__reset+0xfb109c04>
8112a2bc:	003fbf06 	br	8112a1bc <__reset+0xfb10a1bc>
8112a2c0:	a0800083 	ldbu	r2,2(r20)
8112a2c4:	8c400094 	ori	r17,r17,2
8112a2c8:	a5000084 	addi	r20,r20,2
8112a2cc:	10c03fcc 	andi	r3,r2,255
8112a2d0:	003dc706 	br	811299f0 <__reset+0xfb1099f0>
8112a2d4:	e0800117 	ldw	r2,4(fp)
8112a2d8:	88e2b03a 	or	r17,r17,r3
8112a2dc:	00bef716 	blt	zero,r2,81129ebc <__reset+0xfb109ebc>
8112a2e0:	003e6f06 	br	81129ca0 <__reset+0xfb109ca0>
8112a2e4:	8880004c 	andi	r2,r17,1
8112a2e8:	10000b1e 	bne	r2,zero,8112a318 <__svfscanf_r+0xa54>
8112a2ec:	8c40008c 	andi	r17,r17,2
8112a2f0:	88000926 	beq	r17,zero,8112a318 <__svfscanf_r+0xa54>
8112a2f4:	da009c17 	ldw	r8,624(sp)
8112a2f8:	9007d7fa 	srai	r3,r18,31
8112a2fc:	dd009d17 	ldw	r20,628(sp)
8112a300:	40800017 	ldw	r2,0(r8)
8112a304:	42000104 	addi	r8,r8,4
8112a308:	da009c15 	stw	r8,624(sp)
8112a30c:	14800015 	stw	r18,0(r2)
8112a310:	10c00115 	stw	r3,4(r2)
8112a314:	003da806 	br	811299b8 <__reset+0xfb1099b8>
8112a318:	da009c17 	ldw	r8,624(sp)
8112a31c:	dd009d17 	ldw	r20,628(sp)
8112a320:	40800017 	ldw	r2,0(r8)
8112a324:	42000104 	addi	r8,r8,4
8112a328:	da009c15 	stw	r8,624(sp)
8112a32c:	14800015 	stw	r18,0(r2)
8112a330:	003da106 	br	811299b8 <__reset+0xfb1099b8>
8112a334:	e00b883a 	mov	r5,fp
8112a338:	b009883a 	mov	r4,r22
8112a33c:	11248a00 	call	811248a0 <__srefill_r>
8112a340:	103f9e1e 	bne	r2,zero,8112a1bc <__reset+0xfb10a1bc>
8112a344:	b9c00017 	ldw	r7,0(r23)
8112a348:	05000104 	movi	r20,4
8112a34c:	003e6306 	br	81129cdc <__reset+0xfb109cdc>
8112a350:	e00b883a 	mov	r5,fp
8112a354:	b009883a 	mov	r4,r22
8112a358:	11248a00 	call	811248a0 <__srefill_r>
8112a35c:	103f971e 	bne	r2,zero,8112a1bc <__reset+0xfb10a1bc>
8112a360:	b9c00017 	ldw	r7,0(r23)
8112a364:	003e5706 	br	81129cc4 <__reset+0xfb109cc4>
8112a368:	e00b883a 	mov	r5,fp
8112a36c:	b009883a 	mov	r4,r22
8112a370:	11248a00 	call	811248a0 <__srefill_r>
8112a374:	103f911e 	bne	r2,zero,8112a1bc <__reset+0xfb10a1bc>
8112a378:	b9c00017 	ldw	r7,0(r23)
8112a37c:	05000084 	movi	r20,2
8112a380:	003e5606 	br	81129cdc <__reset+0xfb109cdc>
8112a384:	e00b883a 	mov	r5,fp
8112a388:	b009883a 	mov	r4,r22
8112a38c:	11248a00 	call	811248a0 <__srefill_r>
8112a390:	103ef726 	beq	r2,zero,81129f70 <__reset+0xfb109f70>
8112a394:	003f8906 	br	8112a1bc <__reset+0xfb10a1bc>
8112a398:	e00b883a 	mov	r5,fp
8112a39c:	b009883a 	mov	r4,r22
8112a3a0:	11248a00 	call	811248a0 <__srefill_r>
8112a3a4:	103f851e 	bne	r2,zero,8112a1bc <__reset+0xfb10a1bc>
8112a3a8:	b9c00017 	ldw	r7,0(r23)
8112a3ac:	003f0f06 	br	81129fec <__reset+0xfb109fec>
8112a3b0:	014000c4 	movi	r5,3
8112a3b4:	a1414a26 	beq	r20,r5,8112a8e0 <__svfscanf_r+0x101c>
8112a3b8:	01000104 	movi	r4,4
8112a3bc:	a101f11e 	bne	r20,r4,8112ab84 <__svfscanf_r+0x12c0>
8112a3c0:	b009883a 	mov	r4,r22
8112a3c4:	112e2ec0 	call	8112e2ec <_localeconv_r>
8112a3c8:	10800017 	ldw	r2,0(r2)
8112a3cc:	98ffffc4 	addi	r3,r19,-1
8112a3d0:	d880a315 	stw	r2,652(sp)
8112a3d4:	00805704 	movi	r2,348
8112a3d8:	10c21e2e 	bgeu	r2,r3,8112ac54 <__svfscanf_r+0x1390>
8112a3dc:	9cffa8c4 	addi	r19,r19,-349
8112a3e0:	dcc0a215 	stw	r19,648(sp)
8112a3e4:	04c05744 	movi	r19,349
8112a3e8:	8d01e014 	ori	r20,r17,1920
8112a3ec:	0023883a 	mov	r17,zero
8112a3f0:	dc000104 	addi	r16,sp,4
8112a3f4:	8805883a 	mov	r2,r17
8112a3f8:	0019883a 	mov	r12,zero
8112a3fc:	8023883a 	mov	r17,r16
8112a400:	b007883a 	mov	r3,r22
8112a404:	9821883a 	mov	r16,r19
8112a408:	002b883a 	mov	r21,zero
8112a40c:	d800a515 	stw	zero,660(sp)
8112a410:	d800a415 	stw	zero,656(sp)
8112a414:	d8009f15 	stw	zero,636(sp)
8112a418:	01c01384 	movi	r7,78
8112a41c:	602d883a 	mov	r22,r12
8112a420:	1027883a 	mov	r19,r2
8112a424:	e1000017 	ldw	r4,0(fp)
8112a428:	21400003 	ldbu	r5,0(r4)
8112a42c:	28bff544 	addi	r2,r5,-43
8112a430:	10803fcc 	andi	r2,r2,255
8112a434:	38810e36 	bltu	r7,r2,8112a870 <__svfscanf_r+0xfac>
8112a438:	100490ba 	slli	r2,r2,2
8112a43c:	01a044f4 	movhi	r6,33043
8112a440:	31a91404 	addi	r6,r6,-23472
8112a444:	1185883a 	add	r2,r2,r6
8112a448:	10800017 	ldw	r2,0(r2)
8112a44c:	1000683a 	jmp	r2
8112a450:	8112a748 	cmpgei	r4,r16,19101
8112a454:	8112a870 	cmpltui	r4,r16,19105
8112a458:	8112a748 	cmpgei	r4,r16,19101
8112a45c:	8112a870 	cmpltui	r4,r16,19105
8112a460:	8112a870 	cmpltui	r4,r16,19105
8112a464:	8112a71c 	xori	r4,r16,19100
8112a468:	8112a58c 	andi	r4,r16,19094
8112a46c:	8112a58c 	andi	r4,r16,19094
8112a470:	8112a58c 	andi	r4,r16,19094
8112a474:	8112a58c 	andi	r4,r16,19094
8112a478:	8112a58c 	andi	r4,r16,19094
8112a47c:	8112a58c 	andi	r4,r16,19094
8112a480:	8112a58c 	andi	r4,r16,19094
8112a484:	8112a58c 	andi	r4,r16,19094
8112a488:	8112a58c 	andi	r4,r16,19094
8112a48c:	8112a870 	cmpltui	r4,r16,19105
8112a490:	8112a870 	cmpltui	r4,r16,19105
8112a494:	8112a870 	cmpltui	r4,r16,19105
8112a498:	8112a870 	cmpltui	r4,r16,19105
8112a49c:	8112a870 	cmpltui	r4,r16,19105
8112a4a0:	8112a870 	cmpltui	r4,r16,19105
8112a4a4:	8112a870 	cmpltui	r4,r16,19105
8112a4a8:	8112a860 	cmpeqi	r4,r16,19105
8112a4ac:	8112a870 	cmpltui	r4,r16,19105
8112a4b0:	8112a870 	cmpltui	r4,r16,19105
8112a4b4:	8112a870 	cmpltui	r4,r16,19105
8112a4b8:	8112a81c 	xori	r4,r16,19104
8112a4bc:	8112a800 	call	88112a80 <__reset+0x20f2a80>
8112a4c0:	8112a870 	cmpltui	r4,r16,19105
8112a4c4:	8112a870 	cmpltui	r4,r16,19105
8112a4c8:	8112a7cc 	andi	r4,r16,19103
8112a4cc:	8112a870 	cmpltui	r4,r16,19105
8112a4d0:	8112a870 	cmpltui	r4,r16,19105
8112a4d4:	8112a870 	cmpltui	r4,r16,19105
8112a4d8:	8112a870 	cmpltui	r4,r16,19105
8112a4dc:	8112a794 	ori	r4,r16,19102
8112a4e0:	8112a870 	cmpltui	r4,r16,19105
8112a4e4:	8112a870 	cmpltui	r4,r16,19105
8112a4e8:	8112a870 	cmpltui	r4,r16,19105
8112a4ec:	8112a870 	cmpltui	r4,r16,19105
8112a4f0:	8112a870 	cmpltui	r4,r16,19105
8112a4f4:	8112a778 	rdprs	r4,r16,19101
8112a4f8:	8112a870 	cmpltui	r4,r16,19105
8112a4fc:	8112a870 	cmpltui	r4,r16,19105
8112a500:	8112a870 	cmpltui	r4,r16,19105
8112a504:	8112a870 	cmpltui	r4,r16,19105
8112a508:	8112a75c 	xori	r4,r16,19101
8112a50c:	8112a870 	cmpltui	r4,r16,19105
8112a510:	8112a870 	cmpltui	r4,r16,19105
8112a514:	8112a870 	cmpltui	r4,r16,19105
8112a518:	8112a870 	cmpltui	r4,r16,19105
8112a51c:	8112a870 	cmpltui	r4,r16,19105
8112a520:	8112a870 	cmpltui	r4,r16,19105
8112a524:	8112a870 	cmpltui	r4,r16,19105
8112a528:	8112a860 	cmpeqi	r4,r16,19105
8112a52c:	8112a870 	cmpltui	r4,r16,19105
8112a530:	8112a870 	cmpltui	r4,r16,19105
8112a534:	8112a870 	cmpltui	r4,r16,19105
8112a538:	8112a81c 	xori	r4,r16,19104
8112a53c:	8112a800 	call	88112a80 <__reset+0x20f2a80>
8112a540:	8112a870 	cmpltui	r4,r16,19105
8112a544:	8112a870 	cmpltui	r4,r16,19105
8112a548:	8112a7cc 	andi	r4,r16,19103
8112a54c:	8112a870 	cmpltui	r4,r16,19105
8112a550:	8112a870 	cmpltui	r4,r16,19105
8112a554:	8112a870 	cmpltui	r4,r16,19105
8112a558:	8112a870 	cmpltui	r4,r16,19105
8112a55c:	8112a794 	ori	r4,r16,19102
8112a560:	8112a870 	cmpltui	r4,r16,19105
8112a564:	8112a870 	cmpltui	r4,r16,19105
8112a568:	8112a870 	cmpltui	r4,r16,19105
8112a56c:	8112a870 	cmpltui	r4,r16,19105
8112a570:	8112a870 	cmpltui	r4,r16,19105
8112a574:	8112a778 	rdprs	r4,r16,19101
8112a578:	8112a870 	cmpltui	r4,r16,19105
8112a57c:	8112a870 	cmpltui	r4,r16,19105
8112a580:	8112a870 	cmpltui	r4,r16,19105
8112a584:	8112a870 	cmpltui	r4,r16,19105
8112a588:	8112a75c 	xori	r4,r16,19101
8112a58c:	a8803fcc 	andi	r2,r21,255
8112a590:	1080201c 	xori	r2,r2,128
8112a594:	10bfe004 	addi	r2,r2,-128
8112a598:	b085883a 	add	r2,r22,r2
8112a59c:	10000d1e 	bne	r2,zero,8112a5d4 <__svfscanf_r+0xd10>
8112a5a0:	00bf9fc4 	movi	r2,-385
8112a5a4:	a0a8703a 	and	r20,r20,r2
8112a5a8:	89400005 	stb	r5,0(r17)
8112a5ac:	8c400044 	addi	r17,r17,1
8112a5b0:	e0800117 	ldw	r2,4(fp)
8112a5b4:	843fffc4 	addi	r16,r16,-1
8112a5b8:	94800044 	addi	r18,r18,1
8112a5bc:	10bfffc4 	addi	r2,r2,-1
8112a5c0:	e0800115 	stw	r2,4(fp)
8112a5c4:	0080b40e 	bge	zero,r2,8112a898 <__svfscanf_r+0xfd4>
8112a5c8:	21000044 	addi	r4,r4,1
8112a5cc:	e1000015 	stw	r4,0(fp)
8112a5d0:	803f941e 	bne	r16,zero,8112a424 <__reset+0xfb10a424>
8112a5d4:	8821883a 	mov	r16,r17
8112a5d8:	b019883a 	mov	r12,r22
8112a5dc:	9823883a 	mov	r17,r19
8112a5e0:	182d883a 	mov	r22,r3
8112a5e4:	9801961e 	bne	r19,zero,8112ac40 <__svfscanf_r+0x137c>
8112a5e8:	633fffc4 	addi	r12,r12,-1
8112a5ec:	00800044 	movi	r2,1
8112a5f0:	1302882e 	bgeu	r2,r12,8112b014 <__svfscanf_r+0x1750>
8112a5f4:	a8803fcc 	andi	r2,r21,255
8112a5f8:	1080201c 	xori	r2,r2,128
8112a5fc:	10bfe004 	addi	r2,r2,-128
8112a600:	113fffc4 	addi	r4,r2,-1
8112a604:	01400184 	movi	r5,6
8112a608:	29001136 	bltu	r5,r4,8112a650 <__svfscanf_r+0xd8c>
8112a60c:	01000084 	movi	r4,2
8112a610:	2082900e 	bge	r4,r2,8112b054 <__svfscanf_r+0x1790>
8112a614:	00c000c4 	movi	r3,3
8112a618:	10c00d26 	beq	r2,r3,8112a650 <__svfscanf_r+0xd8c>
8112a61c:	9425c83a 	sub	r18,r18,r16
8112a620:	1827883a 	mov	r19,r3
8112a624:	843fffc4 	addi	r16,r16,-1
8112a628:	81400007 	ldb	r5,0(r16)
8112a62c:	e00d883a 	mov	r6,fp
8112a630:	b009883a 	mov	r4,r22
8112a634:	11332340 	call	81133234 <_ungetc_r>
8112a638:	a8bfffc4 	addi	r2,r21,-1
8112a63c:	10c03fcc 	andi	r3,r2,255
8112a640:	8493883a 	add	r9,r16,r18
8112a644:	102b883a 	mov	r21,r2
8112a648:	98fff636 	bltu	r19,r3,8112a624 <__reset+0xfb10a624>
8112a64c:	4825883a 	mov	r18,r9
8112a650:	a080400c 	andi	r2,r20,256
8112a654:	10001426 	beq	r2,zero,8112a6a8 <__svfscanf_r+0xde4>
8112a658:	a081000c 	andi	r2,r20,1024
8112a65c:	1002571e 	bne	r2,zero,8112afbc <__svfscanf_r+0x16f8>
8112a660:	817fffc7 	ldb	r5,-1(r16)
8112a664:	00801944 	movi	r2,101
8112a668:	84ffffc4 	addi	r19,r16,-1
8112a66c:	957fffc4 	addi	r21,r18,-1
8112a670:	28800826 	beq	r5,r2,8112a694 <__svfscanf_r+0xdd0>
8112a674:	00801144 	movi	r2,69
8112a678:	28800626 	beq	r5,r2,8112a694 <__svfscanf_r+0xdd0>
8112a67c:	e00d883a 	mov	r6,fp
8112a680:	b009883a 	mov	r4,r22
8112a684:	11332340 	call	81133234 <_ungetc_r>
8112a688:	817fff87 	ldb	r5,-2(r16)
8112a68c:	84ffff84 	addi	r19,r16,-2
8112a690:	957fff84 	addi	r21,r18,-2
8112a694:	e00d883a 	mov	r6,fp
8112a698:	b009883a 	mov	r4,r22
8112a69c:	11332340 	call	81133234 <_ungetc_r>
8112a6a0:	a825883a 	mov	r18,r21
8112a6a4:	9821883a 	mov	r16,r19
8112a6a8:	a080040c 	andi	r2,r20,16
8112a6ac:	103e891e 	bne	r2,zero,8112a0d4 <__reset+0xfb10a0d4>
8112a6b0:	80000005 	stb	zero,0(r16)
8112a6b4:	a081800c 	andi	r2,r20,1536
8112a6b8:	01010004 	movi	r4,1024
8112a6bc:	1101dd26 	beq	r2,r4,8112ae34 <__svfscanf_r+0x1570>
8112a6c0:	da00a417 	ldw	r8,656(sp)
8112a6c4:	4001e71e 	bne	r8,zero,8112ae64 <__svfscanf_r+0x15a0>
8112a6c8:	000d883a 	mov	r6,zero
8112a6cc:	d9400104 	addi	r5,sp,4
8112a6d0:	b009883a 	mov	r4,r22
8112a6d4:	11300cc0 	call	811300cc <_strtod_r>
8112a6d8:	1021883a 	mov	r16,r2
8112a6dc:	a080004c 	andi	r2,r20,1
8112a6e0:	1000021e 	bne	r2,zero,8112a6ec <__svfscanf_r+0xe28>
8112a6e4:	a2c0008c 	andi	r11,r20,2
8112a6e8:	5801e826 	beq	r11,zero,8112ae8c <__svfscanf_r+0x15c8>
8112a6ec:	da009c17 	ldw	r8,624(sp)
8112a6f0:	40800017 	ldw	r2,0(r8)
8112a6f4:	42000104 	addi	r8,r8,4
8112a6f8:	da009c15 	stw	r8,624(sp)
8112a6fc:	14000015 	stw	r16,0(r2)
8112a700:	10c00115 	stw	r3,4(r2)
8112a704:	da00a017 	ldw	r8,640(sp)
8112a708:	dd009d17 	ldw	r20,628(sp)
8112a70c:	42000044 	addi	r8,r8,1
8112a710:	da00a015 	stw	r8,640(sp)
8112a714:	a00d883a 	mov	r6,r20
8112a718:	003ca806 	br	811299bc <__reset+0xfb1099bc>
8112a71c:	a080400c 	andi	r2,r20,256
8112a720:	103f9a26 	beq	r2,zero,8112a58c <__reset+0xfb10a58c>
8112a724:	da00a217 	ldw	r8,648(sp)
8112a728:	00bfdfc4 	movi	r2,-129
8112a72c:	a0a8703a 	and	r20,r20,r2
8112a730:	9cc00044 	addi	r19,r19,1
8112a734:	403f9e26 	beq	r8,zero,8112a5b0 <__reset+0xfb10a5b0>
8112a738:	423fffc4 	addi	r8,r8,-1
8112a73c:	da00a215 	stw	r8,648(sp)
8112a740:	84000044 	addi	r16,r16,1
8112a744:	003f9a06 	br	8112a5b0 <__reset+0xfb10a5b0>
8112a748:	a080200c 	andi	r2,r20,128
8112a74c:	103fa126 	beq	r2,zero,8112a5d4 <__reset+0xfb10a5d4>
8112a750:	00bfdfc4 	movi	r2,-129
8112a754:	a0a8703a 	and	r20,r20,r2
8112a758:	003f9306 	br	8112a5a8 <__reset+0xfb10a5a8>
8112a75c:	a8803fcc 	andi	r2,r21,255
8112a760:	1080201c 	xori	r2,r2,128
8112a764:	10bfe004 	addi	r2,r2,-128
8112a768:	020001c4 	movi	r8,7
8112a76c:	123f991e 	bne	r2,r8,8112a5d4 <__reset+0xfb10a5d4>
8112a770:	05400204 	movi	r21,8
8112a774:	003f8c06 	br	8112a5a8 <__reset+0xfb10a5a8>
8112a778:	a8803fcc 	andi	r2,r21,255
8112a77c:	1080201c 	xori	r2,r2,128
8112a780:	10bfe004 	addi	r2,r2,-128
8112a784:	01800184 	movi	r6,6
8112a788:	11bf921e 	bne	r2,r6,8112a5d4 <__reset+0xfb10a5d4>
8112a78c:	054001c4 	movi	r21,7
8112a790:	003f8506 	br	8112a5a8 <__reset+0xfb10a5a8>
8112a794:	b000491e 	bne	r22,zero,8112a8bc <__svfscanf_r+0xff8>
8112a798:	9800031e 	bne	r19,zero,8112a7a8 <__svfscanf_r+0xee4>
8112a79c:	a081c00c 	andi	r2,r20,1792
8112a7a0:	0181c004 	movi	r6,1792
8112a7a4:	11819f26 	beq	r2,r6,8112ae24 <__svfscanf_r+0x1560>
8112a7a8:	a8803fcc 	andi	r2,r21,255
8112a7ac:	1080201c 	xori	r2,r2,128
8112a7b0:	10bfe004 	addi	r2,r2,-128
8112a7b4:	01800044 	movi	r6,1
8112a7b8:	11800226 	beq	r2,r6,8112a7c4 <__svfscanf_r+0xf00>
8112a7bc:	01800104 	movi	r6,4
8112a7c0:	11bf841e 	bne	r2,r6,8112a5d4 <__reset+0xfb10a5d4>
8112a7c4:	ad400044 	addi	r21,r21,1
8112a7c8:	003f7706 	br	8112a5a8 <__reset+0xfb10a5a8>
8112a7cc:	a8803fcc 	andi	r2,r21,255
8112a7d0:	1080201c 	xori	r2,r2,128
8112a7d4:	10bfe004 	addi	r2,r2,-128
8112a7d8:	10003c1e 	bne	r2,zero,8112a8cc <__svfscanf_r+0x1008>
8112a7dc:	9801141e 	bne	r19,zero,8112ac30 <__svfscanf_r+0x136c>
8112a7e0:	a081c00c 	andi	r2,r20,1792
8112a7e4:	0181c004 	movi	r6,1792
8112a7e8:	11818226 	beq	r2,r6,8112adf4 <__svfscanf_r+0x1530>
8112a7ec:	8821883a 	mov	r16,r17
8112a7f0:	b019883a 	mov	r12,r22
8112a7f4:	9823883a 	mov	r17,r19
8112a7f8:	182d883a 	mov	r22,r3
8112a7fc:	003f7a06 	br	8112a5e8 <__reset+0xfb10a5e8>
8112a800:	a8803fcc 	andi	r2,r21,255
8112a804:	1080201c 	xori	r2,r2,128
8112a808:	10bfe004 	addi	r2,r2,-128
8112a80c:	01800084 	movi	r6,2
8112a810:	11bf701e 	bne	r2,r6,8112a5d4 <__reset+0xfb10a5d4>
8112a814:	054000c4 	movi	r21,3
8112a818:	003f6306 	br	8112a5a8 <__reset+0xfb10a5a8>
8112a81c:	a081400c 	andi	r2,r20,1280
8112a820:	01810004 	movi	r6,1024
8112a824:	11800326 	beq	r2,r6,8112a834 <__svfscanf_r+0xf70>
8112a828:	a184703a 	and	r2,r20,r6
8112a82c:	103f6926 	beq	r2,zero,8112a5d4 <__reset+0xfb10a5d4>
8112a830:	983fee26 	beq	r19,zero,8112a7ec <__reset+0xfb10a7ec>
8112a834:	a080800c 	andi	r2,r20,512
8112a838:	1000041e 	bne	r2,zero,8112a84c <__svfscanf_r+0xf88>
8112a83c:	da009f17 	ldw	r8,636(sp)
8112a840:	dc40a515 	stw	r17,660(sp)
8112a844:	9a27c83a 	sub	r19,r19,r8
8112a848:	dcc0a415 	stw	r19,656(sp)
8112a84c:	00be1fc4 	movi	r2,-1921
8112a850:	a0a8703a 	and	r20,r20,r2
8112a854:	a5006014 	ori	r20,r20,384
8112a858:	0027883a 	mov	r19,zero
8112a85c:	003f5206 	br	8112a5a8 <__reset+0xfb10a5a8>
8112a860:	00800044 	movi	r2,1
8112a864:	b0bf5b1e 	bne	r22,r2,8112a5d4 <__reset+0xfb10a5d4>
8112a868:	05800084 	movi	r22,2
8112a86c:	003f4e06 	br	8112a5a8 <__reset+0xfb10a5a8>
8112a870:	d980a317 	ldw	r6,652(sp)
8112a874:	30800003 	ldbu	r2,0(r6)
8112a878:	29803fcc 	andi	r6,r5,255
8112a87c:	30bf551e 	bne	r6,r2,8112a5d4 <__reset+0xfb10a5d4>
8112a880:	a080800c 	andi	r2,r20,512
8112a884:	103f5326 	beq	r2,zero,8112a5d4 <__reset+0xfb10a5d4>
8112a888:	023f5fc4 	movi	r8,-641
8112a88c:	a228703a 	and	r20,r20,r8
8112a890:	dcc09f15 	stw	r19,636(sp)
8112a894:	003f4406 	br	8112a5a8 <__reset+0xfb10a5a8>
8112a898:	1809883a 	mov	r4,r3
8112a89c:	e00b883a 	mov	r5,fp
8112a8a0:	d8c0a615 	stw	r3,664(sp)
8112a8a4:	d9c0aa15 	stw	r7,680(sp)
8112a8a8:	11248a00 	call	811248a0 <__srefill_r>
8112a8ac:	d8c0a617 	ldw	r3,664(sp)
8112a8b0:	d9c0aa17 	ldw	r7,680(sp)
8112a8b4:	103f4626 	beq	r2,zero,8112a5d0 <__reset+0xfb10a5d0>
8112a8b8:	003f4606 	br	8112a5d4 <__reset+0xfb10a5d4>
8112a8bc:	00800084 	movi	r2,2
8112a8c0:	b0bfb91e 	bne	r22,r2,8112a7a8 <__reset+0xfb10a7a8>
8112a8c4:	058000c4 	movi	r22,3
8112a8c8:	003f3706 	br	8112a5a8 <__reset+0xfb10a5a8>
8112a8cc:	018000c4 	movi	r6,3
8112a8d0:	11bfbc26 	beq	r2,r6,8112a7c4 <__reset+0xfb10a7c4>
8112a8d4:	01800144 	movi	r6,5
8112a8d8:	11bfba26 	beq	r2,r6,8112a7c4 <__reset+0xfb10a7c4>
8112a8dc:	003f3d06 	br	8112a5d4 <__reset+0xfb10a5d4>
8112a8e0:	98bfffc4 	addi	r2,r19,-1
8112a8e4:	01405704 	movi	r5,348
8112a8e8:	2880d82e 	bgeu	r5,r2,8112ac4c <__svfscanf_r+0x1388>
8112a8ec:	99ffa8c4 	addi	r7,r19,-349
8112a8f0:	04c05744 	movi	r19,349
8112a8f4:	8c436014 	ori	r17,r17,3456
8112a8f8:	9013883a 	mov	r9,r18
8112a8fc:	8825883a 	mov	r18,r17
8112a900:	dc409e17 	ldw	r17,632(sp)
8112a904:	0029883a 	mov	r20,zero
8112a908:	dc000104 	addi	r16,sp,4
8112a90c:	05401344 	movi	r21,77
8112a910:	02c08004 	movi	r11,512
8112a914:	01bf7fc4 	movi	r6,-513
8112a918:	023fdfc4 	movi	r8,-129
8112a91c:	20bff544 	addi	r2,r4,-43
8112a920:	10803fcc 	andi	r2,r2,255
8112a924:	a8807236 	bltu	r21,r2,8112aaf0 <__svfscanf_r+0x122c>
8112a928:	100490ba 	slli	r2,r2,2
8112a92c:	016044f4 	movhi	r5,33043
8112a930:	296a5004 	addi	r5,r5,-22208
8112a934:	1145883a 	add	r2,r2,r5
8112a938:	10800017 	ldw	r2,0(r2)
8112a93c:	1000683a 	jmp	r2
8112a940:	8112ab74 	orhi	r4,r16,19117
8112a944:	8112aaf0 	cmpltui	r4,r16,19115
8112a948:	8112ab74 	orhi	r4,r16,19117
8112a94c:	8112aaf0 	cmpltui	r4,r16,19115
8112a950:	8112aaf0 	cmpltui	r4,r16,19115
8112a954:	8112ab4c 	andi	r4,r16,19117
8112a958:	8112ab2c 	andhi	r4,r16,19116
8112a95c:	8112ab2c 	andhi	r4,r16,19116
8112a960:	8112ab2c 	andhi	r4,r16,19116
8112a964:	8112ab2c 	andhi	r4,r16,19116
8112a968:	8112ab2c 	andhi	r4,r16,19116
8112a96c:	8112ab2c 	andhi	r4,r16,19116
8112a970:	8112ab2c 	andhi	r4,r16,19116
8112a974:	8112aad4 	ori	r4,r16,19115
8112a978:	8112aad4 	ori	r4,r16,19115
8112a97c:	8112aaf0 	cmpltui	r4,r16,19115
8112a980:	8112aaf0 	cmpltui	r4,r16,19115
8112a984:	8112aaf0 	cmpltui	r4,r16,19115
8112a988:	8112aaf0 	cmpltui	r4,r16,19115
8112a98c:	8112aaf0 	cmpltui	r4,r16,19115
8112a990:	8112aaf0 	cmpltui	r4,r16,19115
8112a994:	8112aaf0 	cmpltui	r4,r16,19115
8112a998:	8112aac0 	call	88112aac <__reset+0x20f2aac>
8112a99c:	8112aac0 	call	88112aac <__reset+0x20f2aac>
8112a9a0:	8112aac0 	call	88112aac <__reset+0x20f2aac>
8112a9a4:	8112aac0 	call	88112aac <__reset+0x20f2aac>
8112a9a8:	8112aac0 	call	88112aac <__reset+0x20f2aac>
8112a9ac:	8112aac0 	call	88112aac <__reset+0x20f2aac>
8112a9b0:	8112aaf0 	cmpltui	r4,r16,19115
8112a9b4:	8112aaf0 	cmpltui	r4,r16,19115
8112a9b8:	8112aaf0 	cmpltui	r4,r16,19115
8112a9bc:	8112aaf0 	cmpltui	r4,r16,19115
8112a9c0:	8112aaf0 	cmpltui	r4,r16,19115
8112a9c4:	8112aaf0 	cmpltui	r4,r16,19115
8112a9c8:	8112aaf0 	cmpltui	r4,r16,19115
8112a9cc:	8112aaf0 	cmpltui	r4,r16,19115
8112a9d0:	8112aaf0 	cmpltui	r4,r16,19115
8112a9d4:	8112aaf0 	cmpltui	r4,r16,19115
8112a9d8:	8112aaf0 	cmpltui	r4,r16,19115
8112a9dc:	8112aaf0 	cmpltui	r4,r16,19115
8112a9e0:	8112aaf0 	cmpltui	r4,r16,19115
8112a9e4:	8112aaf0 	cmpltui	r4,r16,19115
8112a9e8:	8112aaf0 	cmpltui	r4,r16,19115
8112a9ec:	8112aaf0 	cmpltui	r4,r16,19115
8112a9f0:	8112aaf0 	cmpltui	r4,r16,19115
8112a9f4:	8112aa78 	rdprs	r4,r16,19113
8112a9f8:	8112aaf0 	cmpltui	r4,r16,19115
8112a9fc:	8112aaf0 	cmpltui	r4,r16,19115
8112aa00:	8112aaf0 	cmpltui	r4,r16,19115
8112aa04:	8112aaf0 	cmpltui	r4,r16,19115
8112aa08:	8112aaf0 	cmpltui	r4,r16,19115
8112aa0c:	8112aaf0 	cmpltui	r4,r16,19115
8112aa10:	8112aaf0 	cmpltui	r4,r16,19115
8112aa14:	8112aaf0 	cmpltui	r4,r16,19115
8112aa18:	8112aac0 	call	88112aac <__reset+0x20f2aac>
8112aa1c:	8112aac0 	call	88112aac <__reset+0x20f2aac>
8112aa20:	8112aac0 	call	88112aac <__reset+0x20f2aac>
8112aa24:	8112aac0 	call	88112aac <__reset+0x20f2aac>
8112aa28:	8112aac0 	call	88112aac <__reset+0x20f2aac>
8112aa2c:	8112aac0 	call	88112aac <__reset+0x20f2aac>
8112aa30:	8112aaf0 	cmpltui	r4,r16,19115
8112aa34:	8112aaf0 	cmpltui	r4,r16,19115
8112aa38:	8112aaf0 	cmpltui	r4,r16,19115
8112aa3c:	8112aaf0 	cmpltui	r4,r16,19115
8112aa40:	8112aaf0 	cmpltui	r4,r16,19115
8112aa44:	8112aaf0 	cmpltui	r4,r16,19115
8112aa48:	8112aaf0 	cmpltui	r4,r16,19115
8112aa4c:	8112aaf0 	cmpltui	r4,r16,19115
8112aa50:	8112aaf0 	cmpltui	r4,r16,19115
8112aa54:	8112aaf0 	cmpltui	r4,r16,19115
8112aa58:	8112aaf0 	cmpltui	r4,r16,19115
8112aa5c:	8112aaf0 	cmpltui	r4,r16,19115
8112aa60:	8112aaf0 	cmpltui	r4,r16,19115
8112aa64:	8112aaf0 	cmpltui	r4,r16,19115
8112aa68:	8112aaf0 	cmpltui	r4,r16,19115
8112aa6c:	8112aaf0 	cmpltui	r4,r16,19115
8112aa70:	8112aaf0 	cmpltui	r4,r16,19115
8112aa74:	8112aa78 	rdprs	r4,r16,19113
8112aa78:	9081800c 	andi	r2,r18,1536
8112aa7c:	12c01c1e 	bne	r2,r11,8112aaf0 <__svfscanf_r+0x122c>
8112aa80:	91a4703a 	and	r18,r18,r6
8112aa84:	94814014 	ori	r18,r18,1280
8112aa88:	04400404 	movi	r17,16
8112aa8c:	81000005 	stb	r4,0(r16)
8112aa90:	84000044 	addi	r16,r16,1
8112aa94:	e0800117 	ldw	r2,4(fp)
8112aa98:	10bfffc4 	addi	r2,r2,-1
8112aa9c:	e0800115 	stw	r2,4(fp)
8112aaa0:	0080540e 	bge	zero,r2,8112abf4 <__svfscanf_r+0x1330>
8112aaa4:	18c00044 	addi	r3,r3,1
8112aaa8:	e0c00015 	stw	r3,0(fp)
8112aaac:	9cffffc4 	addi	r19,r19,-1
8112aab0:	98000f26 	beq	r19,zero,8112aaf0 <__svfscanf_r+0x122c>
8112aab4:	e0c00017 	ldw	r3,0(fp)
8112aab8:	19000003 	ldbu	r4,0(r3)
8112aabc:	003f9706 	br	8112a91c <__reset+0xfb10a91c>
8112aac0:	00800284 	movi	r2,10
8112aac4:	14400a0e 	bge	r2,r17,8112aaf0 <__svfscanf_r+0x122c>
8112aac8:	00bd1fc4 	movi	r2,-2945
8112aacc:	90a4703a 	and	r18,r18,r2
8112aad0:	003fee06 	br	8112aa8c <__reset+0xfb10aa8c>
8112aad4:	01604574 	movhi	r5,33045
8112aad8:	8c63883a 	add	r17,r17,r17
8112aadc:	2949aa84 	addi	r5,r5,9898
8112aae0:	2c45883a 	add	r2,r5,r17
8112aae4:	1440000f 	ldh	r17,0(r2)
8112aae8:	00800204 	movi	r2,8
8112aaec:	147ff616 	blt	r2,r17,8112aac8 <__reset+0xfb10aac8>
8112aaf0:	dc409e15 	stw	r17,632(sp)
8112aaf4:	9023883a 	mov	r17,r18
8112aaf8:	8880400c 	andi	r2,r17,256
8112aafc:	4825883a 	mov	r18,r9
8112ab00:	10000426 	beq	r2,zero,8112ab14 <__svfscanf_r+0x1250>
8112ab04:	d9800104 	addi	r6,sp,4
8112ab08:	3400be36 	bltu	r6,r16,8112ae04 <__svfscanf_r+0x1540>
8112ab0c:	da000104 	addi	r8,sp,4
8112ab10:	443bae26 	beq	r8,r16,811299cc <__reset+0xfb1099cc>
8112ab14:	8880040c 	andi	r2,r17,16
8112ab18:	10009326 	beq	r2,zero,8112ad68 <__svfscanf_r+0x14a4>
8112ab1c:	d8800104 	addi	r2,sp,4
8112ab20:	80a1c83a 	sub	r16,r16,r2
8112ab24:	8521883a 	add	r16,r16,r20
8112ab28:	003d0606 	br	81129f44 <__reset+0xfb109f44>
8112ab2c:	01604574 	movhi	r5,33045
8112ab30:	8c63883a 	add	r17,r17,r17
8112ab34:	2949aa84 	addi	r5,r5,9898
8112ab38:	2c45883a 	add	r2,r5,r17
8112ab3c:	1440000f 	ldh	r17,0(r2)
8112ab40:	00bd1fc4 	movi	r2,-2945
8112ab44:	90a4703a 	and	r18,r18,r2
8112ab48:	003fd006 	br	8112aa8c <__reset+0xfb10aa8c>
8112ab4c:	9082000c 	andi	r2,r18,2048
8112ab50:	103fce26 	beq	r2,zero,8112aa8c <__reset+0xfb10aa8c>
8112ab54:	8800021e 	bne	r17,zero,8112ab60 <__svfscanf_r+0x129c>
8112ab58:	94808014 	ori	r18,r18,512
8112ab5c:	04400204 	movi	r17,8
8112ab60:	9081000c 	andi	r2,r18,1024
8112ab64:	10009426 	beq	r2,zero,8112adb8 <__svfscanf_r+0x14f4>
8112ab68:	00be9fc4 	movi	r2,-1409
8112ab6c:	90a4703a 	and	r18,r18,r2
8112ab70:	003fc606 	br	8112aa8c <__reset+0xfb10aa8c>
8112ab74:	9080200c 	andi	r2,r18,128
8112ab78:	103fdd26 	beq	r2,zero,8112aaf0 <__reset+0xfb10aaf0>
8112ab7c:	9224703a 	and	r18,r18,r8
8112ab80:	003fc206 	br	8112aa8c <__reset+0xfb10aa8c>
8112ab84:	9800011e 	bne	r19,zero,8112ab8c <__svfscanf_r+0x12c8>
8112ab88:	04ffffc4 	movi	r19,-1
8112ab8c:	8900004c 	andi	r4,r17,1
8112ab90:	20005b1e 	bne	r4,zero,8112ad00 <__svfscanf_r+0x143c>
8112ab94:	8c40040c 	andi	r17,r17,16
8112ab98:	88003026 	beq	r17,zero,8112ac5c <__svfscanf_r+0x1398>
8112ab9c:	0021883a 	mov	r16,zero
8112aba0:	00000306 	br	8112abb0 <__svfscanf_r+0x12ec>
8112aba4:	18800003 	ldbu	r2,0(r3)
8112aba8:	3885883a 	add	r2,r7,r2
8112abac:	10800043 	ldbu	r2,1(r2)
8112abb0:	1080020c 	andi	r2,r2,8
8112abb4:	103ce31e 	bne	r2,zero,81129f44 <__reset+0xfb109f44>
8112abb8:	e0800117 	ldw	r2,4(fp)
8112abbc:	18c00044 	addi	r3,r3,1
8112abc0:	84000044 	addi	r16,r16,1
8112abc4:	10bfffc4 	addi	r2,r2,-1
8112abc8:	e0800115 	stw	r2,4(fp)
8112abcc:	e0c00015 	stw	r3,0(fp)
8112abd0:	84fcdc26 	beq	r16,r19,81129f44 <__reset+0xfb109f44>
8112abd4:	00bff316 	blt	zero,r2,8112aba4 <__reset+0xfb10aba4>
8112abd8:	e00b883a 	mov	r5,fp
8112abdc:	b009883a 	mov	r4,r22
8112abe0:	11248a00 	call	811248a0 <__srefill_r>
8112abe4:	103cd71e 	bne	r2,zero,81129f44 <__reset+0xfb109f44>
8112abe8:	b9c00017 	ldw	r7,0(r23)
8112abec:	e0c00017 	ldw	r3,0(fp)
8112abf0:	003fec06 	br	8112aba4 <__reset+0xfb10aba4>
8112abf4:	e00b883a 	mov	r5,fp
8112abf8:	b009883a 	mov	r4,r22
8112abfc:	d980a715 	stw	r6,668(sp)
8112ac00:	d9c0aa15 	stw	r7,680(sp)
8112ac04:	da00a815 	stw	r8,672(sp)
8112ac08:	da40a915 	stw	r9,676(sp)
8112ac0c:	dac0a615 	stw	r11,664(sp)
8112ac10:	11248a00 	call	811248a0 <__srefill_r>
8112ac14:	d980a717 	ldw	r6,668(sp)
8112ac18:	d9c0aa17 	ldw	r7,680(sp)
8112ac1c:	da00a817 	ldw	r8,672(sp)
8112ac20:	da40a917 	ldw	r9,676(sp)
8112ac24:	dac0a617 	ldw	r11,664(sp)
8112ac28:	103fa026 	beq	r2,zero,8112aaac <__reset+0xfb10aaac>
8112ac2c:	003fb006 	br	8112aaf0 <__reset+0xfb10aaf0>
8112ac30:	8821883a 	mov	r16,r17
8112ac34:	b019883a 	mov	r12,r22
8112ac38:	9823883a 	mov	r17,r19
8112ac3c:	182d883a 	mov	r22,r3
8112ac40:	00bfbfc4 	movi	r2,-257
8112ac44:	a0a8703a 	and	r20,r20,r2
8112ac48:	003e6706 	br	8112a5e8 <__reset+0xfb10a5e8>
8112ac4c:	000f883a 	mov	r7,zero
8112ac50:	003f2806 	br	8112a8f4 <__reset+0xfb10a8f4>
8112ac54:	d800a215 	stw	zero,648(sp)
8112ac58:	003de306 	br	8112a3e8 <__reset+0xfb10a3e8>
8112ac5c:	da009c17 	ldw	r8,624(sp)
8112ac60:	9abfffc4 	addi	r10,r19,-1
8112ac64:	44400017 	ldw	r17,0(r8)
8112ac68:	44000104 	addi	r16,r8,4
8112ac6c:	880b883a 	mov	r5,r17
8112ac70:	8aa9883a 	add	r20,r17,r10
8112ac74:	00000606 	br	8112ac90 <__svfscanf_r+0x13cc>
8112ac78:	e0c00017 	ldw	r3,0(fp)
8112ac7c:	b9000017 	ldw	r4,0(r23)
8112ac80:	a80b883a 	mov	r5,r21
8112ac84:	18800003 	ldbu	r2,0(r3)
8112ac88:	2085883a 	add	r2,r4,r2
8112ac8c:	10800043 	ldbu	r2,1(r2)
8112ac90:	1080020c 	andi	r2,r2,8
8112ac94:	1000551e 	bne	r2,zero,8112adec <__svfscanf_r+0x1528>
8112ac98:	e0800117 	ldw	r2,4(fp)
8112ac9c:	19000044 	addi	r4,r3,1
8112aca0:	e1000015 	stw	r4,0(fp)
8112aca4:	10bfffc4 	addi	r2,r2,-1
8112aca8:	e0800115 	stw	r2,4(fp)
8112acac:	18800003 	ldbu	r2,0(r3)
8112acb0:	2d400044 	addi	r21,r5,1
8112acb4:	a827883a 	mov	r19,r21
8112acb8:	28800005 	stb	r2,0(r5)
8112acbc:	2d000626 	beq	r5,r20,8112acd8 <__svfscanf_r+0x1414>
8112acc0:	e0800117 	ldw	r2,4(fp)
8112acc4:	00bfec16 	blt	zero,r2,8112ac78 <__reset+0xfb10ac78>
8112acc8:	e00b883a 	mov	r5,fp
8112accc:	b009883a 	mov	r4,r22
8112acd0:	11248a00 	call	811248a0 <__srefill_r>
8112acd4:	103fe826 	beq	r2,zero,8112ac78 <__reset+0xfb10ac78>
8112acd8:	da00a017 	ldw	r8,640(sp)
8112acdc:	dd009d17 	ldw	r20,628(sp)
8112ace0:	9c63c83a 	sub	r17,r19,r17
8112ace4:	42000044 	addi	r8,r8,1
8112ace8:	98000005 	stb	zero,0(r19)
8112acec:	9465883a 	add	r18,r18,r17
8112acf0:	da00a015 	stw	r8,640(sp)
8112acf4:	dc009c15 	stw	r16,624(sp)
8112acf8:	a00d883a 	mov	r6,r20
8112acfc:	003b2f06 	br	811299bc <__reset+0xfb1099bc>
8112ad00:	dd409904 	addi	r21,sp,612
8112ad04:	8c40040c 	andi	r17,r17,16
8112ad08:	01800204 	movi	r6,8
8112ad0c:	000b883a 	mov	r5,zero
8112ad10:	a809883a 	mov	r4,r21
8112ad14:	11244a00 	call	811244a0 <memset>
8112ad18:	8800401e 	bne	r17,zero,8112ae1c <__svfscanf_r+0x1558>
8112ad1c:	da009c17 	ldw	r8,624(sp)
8112ad20:	45000017 	ldw	r20,0(r8)
8112ad24:	42000104 	addi	r8,r8,4
8112ad28:	da009c15 	stw	r8,624(sp)
8112ad2c:	000d883a 	mov	r6,zero
8112ad30:	3021883a 	mov	r16,r6
8112ad34:	dc409f15 	stw	r17,636(sp)
8112ad38:	e0800017 	ldw	r2,0(fp)
8112ad3c:	b8c00017 	ldw	r3,0(r23)
8112ad40:	10800003 	ldbu	r2,0(r2)
8112ad44:	1885883a 	add	r2,r3,r2
8112ad48:	10800043 	ldbu	r2,1(r2)
8112ad4c:	1080020c 	andi	r2,r2,8
8112ad50:	1000011e 	bne	r2,zero,8112ad58 <__svfscanf_r+0x1494>
8112ad54:	9800701e 	bne	r19,zero,8112af18 <__svfscanf_r+0x1654>
8112ad58:	dc409f17 	ldw	r17,636(sp)
8112ad5c:	883cdd1e 	bne	r17,zero,8112a0d4 <__reset+0xfb10a0d4>
8112ad60:	a0000015 	stw	zero,0(r20)
8112ad64:	003cd806 	br	8112a0c8 <__reset+0xfb10a0c8>
8112ad68:	d9c09e17 	ldw	r7,632(sp)
8112ad6c:	da00a117 	ldw	r8,644(sp)
8112ad70:	000d883a 	mov	r6,zero
8112ad74:	d9400104 	addi	r5,sp,4
8112ad78:	b009883a 	mov	r4,r22
8112ad7c:	80000005 	stb	zero,0(r16)
8112ad80:	403ee83a 	callr	r8
8112ad84:	88c0080c 	andi	r3,r17,32
8112ad88:	1800121e 	bne	r3,zero,8112add4 <__svfscanf_r+0x1510>
8112ad8c:	88c0010c 	andi	r3,r17,4
8112ad90:	18004d26 	beq	r3,zero,8112aec8 <__svfscanf_r+0x1604>
8112ad94:	da009c17 	ldw	r8,624(sp)
8112ad98:	40c00017 	ldw	r3,0(r8)
8112ad9c:	42000104 	addi	r8,r8,4
8112ada0:	da009c15 	stw	r8,624(sp)
8112ada4:	1880000d 	sth	r2,0(r3)
8112ada8:	da00a017 	ldw	r8,640(sp)
8112adac:	42000044 	addi	r8,r8,1
8112adb0:	da00a015 	stw	r8,640(sp)
8112adb4:	003f5906 	br	8112ab1c <__reset+0xfb10ab1c>
8112adb8:	00bf1fc4 	movi	r2,-897
8112adbc:	90a4703a 	and	r18,r18,r2
8112adc0:	38000226 	beq	r7,zero,8112adcc <__svfscanf_r+0x1508>
8112adc4:	39ffffc4 	addi	r7,r7,-1
8112adc8:	9cc00044 	addi	r19,r19,1
8112adcc:	a5000044 	addi	r20,r20,1
8112add0:	003f3006 	br	8112aa94 <__reset+0xfb10aa94>
8112add4:	da009c17 	ldw	r8,624(sp)
8112add8:	40c00017 	ldw	r3,0(r8)
8112addc:	42000104 	addi	r8,r8,4
8112ade0:	da009c15 	stw	r8,624(sp)
8112ade4:	18800015 	stw	r2,0(r3)
8112ade8:	003fef06 	br	8112ada8 <__reset+0xfb10ada8>
8112adec:	2827883a 	mov	r19,r5
8112adf0:	003fb906 	br	8112acd8 <__reset+0xfb10acd8>
8112adf4:	01be1fc4 	movi	r6,-1921
8112adf8:	a1a8703a 	and	r20,r20,r6
8112adfc:	05400044 	movi	r21,1
8112ae00:	003de906 	br	8112a5a8 <__reset+0xfb10a5a8>
8112ae04:	817fffc7 	ldb	r5,-1(r16)
8112ae08:	e00d883a 	mov	r6,fp
8112ae0c:	b009883a 	mov	r4,r22
8112ae10:	843fffc4 	addi	r16,r16,-1
8112ae14:	11332340 	call	81133234 <_ungetc_r>
8112ae18:	003f3c06 	br	8112ab0c <__reset+0xfb10ab0c>
8112ae1c:	dd009b04 	addi	r20,sp,620
8112ae20:	003fc206 	br	8112ad2c <__reset+0xfb10ad2c>
8112ae24:	00be1fc4 	movi	r2,-1921
8112ae28:	a0a8703a 	and	r20,r20,r2
8112ae2c:	05800044 	movi	r22,1
8112ae30:	003ddd06 	br	8112a5a8 <__reset+0xfb10a5a8>
8112ae34:	d8c09f17 	ldw	r3,636(sp)
8112ae38:	88e3c83a 	sub	r17,r17,r3
8112ae3c:	044dc83a 	sub	r6,zero,r17
8112ae40:	883e2126 	beq	r17,zero,8112a6c8 <__reset+0xfb10a6c8>
8112ae44:	d88055c4 	addi	r2,sp,343
8112ae48:	80800136 	bltu	r16,r2,8112ae50 <__svfscanf_r+0x158c>
8112ae4c:	dc005584 	addi	r16,sp,342
8112ae50:	01604574 	movhi	r5,33045
8112ae54:	2949a904 	addi	r5,r5,9892
8112ae58:	8009883a 	mov	r4,r16
8112ae5c:	1124bb40 	call	81124bb4 <sprintf>
8112ae60:	003e1906 	br	8112a6c8 <__reset+0xfb10a6c8>
8112ae64:	d8c0a517 	ldw	r3,660(sp)
8112ae68:	000d883a 	mov	r6,zero
8112ae6c:	01c00284 	movi	r7,10
8112ae70:	19400044 	addi	r5,r3,1
8112ae74:	b009883a 	mov	r4,r22
8112ae78:	1124ea40 	call	81124ea4 <_strtol_r>
8112ae7c:	da00a417 	ldw	r8,656(sp)
8112ae80:	dc00a517 	ldw	r16,660(sp)
8112ae84:	120dc83a 	sub	r6,r2,r8
8112ae88:	003fee06 	br	8112ae44 <__reset+0xfb10ae44>
8112ae8c:	da009c17 	ldw	r8,624(sp)
8112ae90:	180b883a 	mov	r5,r3
8112ae94:	8009883a 	mov	r4,r16
8112ae98:	45000017 	ldw	r20,0(r8)
8112ae9c:	44400104 	addi	r17,r8,4
8112aea0:	d8c0a615 	stw	r3,664(sp)
8112aea4:	112fe380 	call	8112fe38 <__fpclassifyd>
8112aea8:	d8c0a617 	ldw	r3,664(sp)
8112aeac:	10006426 	beq	r2,zero,8112b040 <__svfscanf_r+0x177c>
8112aeb0:	8009883a 	mov	r4,r16
8112aeb4:	180b883a 	mov	r5,r3
8112aeb8:	1122f200 	call	81122f20 <__truncdfsf2>
8112aebc:	a0800015 	stw	r2,0(r20)
8112aec0:	dc409c15 	stw	r17,624(sp)
8112aec4:	003e0f06 	br	8112a704 <__reset+0xfb10a704>
8112aec8:	88c0004c 	andi	r3,r17,1
8112aecc:	183fc11e 	bne	r3,zero,8112add4 <__reset+0xfb10add4>
8112aed0:	8c40008c 	andi	r17,r17,2
8112aed4:	883fbf26 	beq	r17,zero,8112add4 <__reset+0xfb10add4>
8112aed8:	da00a117 	ldw	r8,644(sp)
8112aedc:	00a044f4 	movhi	r2,33043
8112aee0:	1085fb04 	addi	r2,r2,6124
8112aee4:	d9c09e17 	ldw	r7,632(sp)
8112aee8:	000d883a 	mov	r6,zero
8112aeec:	d9400104 	addi	r5,sp,4
8112aef0:	b009883a 	mov	r4,r22
8112aef4:	40806226 	beq	r8,r2,8112b080 <__svfscanf_r+0x17bc>
8112aef8:	112511c0 	call	8112511c <_strtoll_r>
8112aefc:	da009c17 	ldw	r8,624(sp)
8112af00:	41000017 	ldw	r4,0(r8)
8112af04:	42000104 	addi	r8,r8,4
8112af08:	da009c15 	stw	r8,624(sp)
8112af0c:	20800015 	stw	r2,0(r4)
8112af10:	20c00115 	stw	r3,4(r4)
8112af14:	003fa406 	br	8112ada8 <__reset+0xfb10ada8>
8112af18:	112e2c80 	call	8112e2c8 <__locale_mb_cur_max>
8112af1c:	80bca726 	beq	r16,r2,8112a1bc <__reset+0xfb10a1bc>
8112af20:	e0800017 	ldw	r2,0(fp)
8112af24:	e1000117 	ldw	r4,4(fp)
8112af28:	d8c00104 	addi	r3,sp,4
8112af2c:	12000003 	ldbu	r8,0(r2)
8112af30:	213fffc4 	addi	r4,r4,-1
8112af34:	10800044 	addi	r2,r2,1
8112af38:	e1000115 	stw	r4,4(fp)
8112af3c:	e0800015 	stw	r2,0(fp)
8112af40:	84400044 	addi	r17,r16,1
8112af44:	dd400015 	stw	r21,0(sp)
8112af48:	1c21883a 	add	r16,r3,r16
8112af4c:	b009883a 	mov	r4,r22
8112af50:	880f883a 	mov	r7,r17
8112af54:	180d883a 	mov	r6,r3
8112af58:	a00b883a 	mov	r5,r20
8112af5c:	82000005 	stb	r8,0(r16)
8112af60:	112e3840 	call	8112e384 <_mbrtowc_r>
8112af64:	013fffc4 	movi	r4,-1
8112af68:	113c9426 	beq	r2,r4,8112a1bc <__reset+0xfb10a1bc>
8112af6c:	103c881e 	bne	r2,zero,8112a190 <__reset+0xfb10a190>
8112af70:	a0000015 	stw	zero,0(r20)
8112af74:	0009883a 	mov	r4,zero
8112af78:	112e2080 	call	8112e208 <iswspace>
8112af7c:	10001a26 	beq	r2,zero,8112afe8 <__svfscanf_r+0x1724>
8112af80:	8821883a 	mov	r16,r17
8112af84:	dc409f17 	ldw	r17,636(sp)
8112af88:	803f7426 	beq	r16,zero,8112ad5c <__reset+0xfb10ad5c>
8112af8c:	843fffc4 	addi	r16,r16,-1
8112af90:	d9800104 	addi	r6,sp,4
8112af94:	342b883a 	add	r21,r6,r16
8112af98:	00000106 	br	8112afa0 <__svfscanf_r+0x16dc>
8112af9c:	843fffc4 	addi	r16,r16,-1
8112afa0:	a9400003 	ldbu	r5,0(r21)
8112afa4:	e00d883a 	mov	r6,fp
8112afa8:	b009883a 	mov	r4,r22
8112afac:	11332340 	call	81133234 <_ungetc_r>
8112afb0:	ad7fffc4 	addi	r21,r21,-1
8112afb4:	803ff91e 	bne	r16,zero,8112af9c <__reset+0xfb10af9c>
8112afb8:	003f6806 	br	8112ad5c <__reset+0xfb10ad5c>
8112afbc:	d9800104 	addi	r6,sp,4
8112afc0:	802b883a 	mov	r21,r16
8112afc4:	343a812e 	bgeu	r6,r16,811299cc <__reset+0xfb1099cc>
8112afc8:	ad7fffc4 	addi	r21,r21,-1
8112afcc:	a9400007 	ldb	r5,0(r21)
8112afd0:	e00d883a 	mov	r6,fp
8112afd4:	b009883a 	mov	r4,r22
8112afd8:	11332340 	call	81133234 <_ungetc_r>
8112afdc:	da000104 	addi	r8,sp,4
8112afe0:	457ff91e 	bne	r8,r21,8112afc8 <__reset+0xfb10afc8>
8112afe4:	003a7906 	br	811299cc <__reset+0xfb1099cc>
8112afe8:	da009f17 	ldw	r8,636(sp)
8112afec:	9465883a 	add	r18,r18,r17
8112aff0:	9cffffc4 	addi	r19,r19,-1
8112aff4:	4000051e 	bne	r8,zero,8112b00c <__svfscanf_r+0x1748>
8112aff8:	a5000104 	addi	r20,r20,4
8112affc:	0021883a 	mov	r16,zero
8112b000:	003c6606 	br	8112a19c <__reset+0xfb10a19c>
8112b004:	a1000017 	ldw	r4,0(r20)
8112b008:	003fdb06 	br	8112af78 <__reset+0xfb10af78>
8112b00c:	0021883a 	mov	r16,zero
8112b010:	003c6206 	br	8112a19c <__reset+0xfb10a19c>
8112b014:	d8800104 	addi	r2,sp,4
8112b018:	802b883a 	mov	r21,r16
8112b01c:	143a6b2e 	bgeu	r2,r16,811299cc <__reset+0xfb1099cc>
8112b020:	ad7fffc4 	addi	r21,r21,-1
8112b024:	a9400007 	ldb	r5,0(r21)
8112b028:	e00d883a 	mov	r6,fp
8112b02c:	b009883a 	mov	r4,r22
8112b030:	11332340 	call	81133234 <_ungetc_r>
8112b034:	d8c00104 	addi	r3,sp,4
8112b038:	1d7ff91e 	bne	r3,r21,8112b020 <__reset+0xfb10b020>
8112b03c:	003a6306 	br	811299cc <__reset+0xfb1099cc>
8112b040:	0009883a 	mov	r4,zero
8112b044:	112ff7c0 	call	8112ff7c <nanf>
8112b048:	a0800015 	stw	r2,0(r20)
8112b04c:	dc409c15 	stw	r17,624(sp)
8112b050:	003dac06 	br	8112a704 <__reset+0xfb10a704>
8112b054:	d9000104 	addi	r4,sp,4
8112b058:	802b883a 	mov	r21,r16
8112b05c:	243a5b2e 	bgeu	r4,r16,811299cc <__reset+0xfb1099cc>
8112b060:	ad7fffc4 	addi	r21,r21,-1
8112b064:	a9400007 	ldb	r5,0(r21)
8112b068:	e00d883a 	mov	r6,fp
8112b06c:	b009883a 	mov	r4,r22
8112b070:	11332340 	call	81133234 <_ungetc_r>
8112b074:	d9400104 	addi	r5,sp,4
8112b078:	2d7ff91e 	bne	r5,r21,8112b060 <__reset+0xfb10b060>
8112b07c:	003a5306 	br	811299cc <__reset+0xfb1099cc>
8112b080:	1131a5c0 	call	81131a5c <_strtoull_r>
8112b084:	003f9d06 	br	8112aefc <__reset+0xfb10aefc>

8112b088 <vfscanf>:
8112b088:	00a04574 	movhi	r2,33045
8112b08c:	defffb04 	addi	sp,sp,-20
8112b090:	10936004 	addi	r2,r2,19840
8112b094:	de00012e 	bgeu	sp,et,8112b09c <vfscanf+0x14>
8112b098:	003b68fa 	trap	3
8112b09c:	dc000215 	stw	r16,8(sp)
8112b0a0:	14000017 	ldw	r16,0(r2)
8112b0a4:	dc400315 	stw	r17,12(sp)
8112b0a8:	dfc00415 	stw	ra,16(sp)
8112b0ac:	2023883a 	mov	r17,r4
8112b0b0:	80000826 	beq	r16,zero,8112b0d4 <vfscanf+0x4c>
8112b0b4:	80800e17 	ldw	r2,56(r16)
8112b0b8:	1000061e 	bne	r2,zero,8112b0d4 <vfscanf+0x4c>
8112b0bc:	8009883a 	mov	r4,r16
8112b0c0:	d9400015 	stw	r5,0(sp)
8112b0c4:	d9800115 	stw	r6,4(sp)
8112b0c8:	112d3a00 	call	8112d3a0 <__sinit>
8112b0cc:	d9800117 	ldw	r6,4(sp)
8112b0d0:	d9400017 	ldw	r5,0(sp)
8112b0d4:	300f883a 	mov	r7,r6
8112b0d8:	8009883a 	mov	r4,r16
8112b0dc:	280d883a 	mov	r6,r5
8112b0e0:	880b883a 	mov	r5,r17
8112b0e4:	dfc00417 	ldw	ra,16(sp)
8112b0e8:	dc400317 	ldw	r17,12(sp)
8112b0ec:	dc000217 	ldw	r16,8(sp)
8112b0f0:	dec00504 	addi	sp,sp,20
8112b0f4:	11298c41 	jmpi	811298c4 <__svfscanf_r>

8112b0f8 <__svfscanf>:
8112b0f8:	00a04574 	movhi	r2,33045
8112b0fc:	10936004 	addi	r2,r2,19840
8112b100:	300f883a 	mov	r7,r6
8112b104:	280d883a 	mov	r6,r5
8112b108:	200b883a 	mov	r5,r4
8112b10c:	11000017 	ldw	r4,0(r2)
8112b110:	11298c41 	jmpi	811298c4 <__svfscanf_r>

8112b114 <_vfscanf_r>:
8112b114:	defffb04 	addi	sp,sp,-20
8112b118:	de00012e 	bgeu	sp,et,8112b120 <_vfscanf_r+0xc>
8112b11c:	003b68fa 	trap	3
8112b120:	dc000315 	stw	r16,12(sp)
8112b124:	dfc00415 	stw	ra,16(sp)
8112b128:	2021883a 	mov	r16,r4
8112b12c:	20000926 	beq	r4,zero,8112b154 <_vfscanf_r+0x40>
8112b130:	20800e17 	ldw	r2,56(r4)
8112b134:	1000071e 	bne	r2,zero,8112b154 <_vfscanf_r+0x40>
8112b138:	d9400015 	stw	r5,0(sp)
8112b13c:	d9800115 	stw	r6,4(sp)
8112b140:	d9c00215 	stw	r7,8(sp)
8112b144:	112d3a00 	call	8112d3a0 <__sinit>
8112b148:	d9c00217 	ldw	r7,8(sp)
8112b14c:	d9800117 	ldw	r6,4(sp)
8112b150:	d9400017 	ldw	r5,0(sp)
8112b154:	8009883a 	mov	r4,r16
8112b158:	dfc00417 	ldw	ra,16(sp)
8112b15c:	dc000317 	ldw	r16,12(sp)
8112b160:	dec00504 	addi	sp,sp,20
8112b164:	11298c41 	jmpi	811298c4 <__svfscanf_r>

8112b168 <__swbuf_r>:
8112b168:	defffb04 	addi	sp,sp,-20
8112b16c:	de00012e 	bgeu	sp,et,8112b174 <__swbuf_r+0xc>
8112b170:	003b68fa 	trap	3
8112b174:	dcc00315 	stw	r19,12(sp)
8112b178:	dc800215 	stw	r18,8(sp)
8112b17c:	dc000015 	stw	r16,0(sp)
8112b180:	dfc00415 	stw	ra,16(sp)
8112b184:	dc400115 	stw	r17,4(sp)
8112b188:	2025883a 	mov	r18,r4
8112b18c:	2827883a 	mov	r19,r5
8112b190:	3021883a 	mov	r16,r6
8112b194:	20000226 	beq	r4,zero,8112b1a0 <__swbuf_r+0x38>
8112b198:	20800e17 	ldw	r2,56(r4)
8112b19c:	10004226 	beq	r2,zero,8112b2a8 <__swbuf_r+0x140>
8112b1a0:	80800617 	ldw	r2,24(r16)
8112b1a4:	8100030b 	ldhu	r4,12(r16)
8112b1a8:	80800215 	stw	r2,8(r16)
8112b1ac:	2080020c 	andi	r2,r4,8
8112b1b0:	10003626 	beq	r2,zero,8112b28c <__swbuf_r+0x124>
8112b1b4:	80c00417 	ldw	r3,16(r16)
8112b1b8:	18003426 	beq	r3,zero,8112b28c <__swbuf_r+0x124>
8112b1bc:	2088000c 	andi	r2,r4,8192
8112b1c0:	9c403fcc 	andi	r17,r19,255
8112b1c4:	10001a26 	beq	r2,zero,8112b230 <__swbuf_r+0xc8>
8112b1c8:	80800017 	ldw	r2,0(r16)
8112b1cc:	81000517 	ldw	r4,20(r16)
8112b1d0:	10c7c83a 	sub	r3,r2,r3
8112b1d4:	1900200e 	bge	r3,r4,8112b258 <__swbuf_r+0xf0>
8112b1d8:	18c00044 	addi	r3,r3,1
8112b1dc:	81000217 	ldw	r4,8(r16)
8112b1e0:	11400044 	addi	r5,r2,1
8112b1e4:	81400015 	stw	r5,0(r16)
8112b1e8:	213fffc4 	addi	r4,r4,-1
8112b1ec:	81000215 	stw	r4,8(r16)
8112b1f0:	14c00005 	stb	r19,0(r2)
8112b1f4:	80800517 	ldw	r2,20(r16)
8112b1f8:	10c01e26 	beq	r2,r3,8112b274 <__swbuf_r+0x10c>
8112b1fc:	8080030b 	ldhu	r2,12(r16)
8112b200:	1080004c 	andi	r2,r2,1
8112b204:	10000226 	beq	r2,zero,8112b210 <__swbuf_r+0xa8>
8112b208:	00800284 	movi	r2,10
8112b20c:	88801926 	beq	r17,r2,8112b274 <__swbuf_r+0x10c>
8112b210:	8805883a 	mov	r2,r17
8112b214:	dfc00417 	ldw	ra,16(sp)
8112b218:	dcc00317 	ldw	r19,12(sp)
8112b21c:	dc800217 	ldw	r18,8(sp)
8112b220:	dc400117 	ldw	r17,4(sp)
8112b224:	dc000017 	ldw	r16,0(sp)
8112b228:	dec00504 	addi	sp,sp,20
8112b22c:	f800283a 	ret
8112b230:	81401917 	ldw	r5,100(r16)
8112b234:	00b7ffc4 	movi	r2,-8193
8112b238:	21080014 	ori	r4,r4,8192
8112b23c:	2884703a 	and	r2,r5,r2
8112b240:	80801915 	stw	r2,100(r16)
8112b244:	80800017 	ldw	r2,0(r16)
8112b248:	8100030d 	sth	r4,12(r16)
8112b24c:	81000517 	ldw	r4,20(r16)
8112b250:	10c7c83a 	sub	r3,r2,r3
8112b254:	193fe016 	blt	r3,r4,8112b1d8 <__reset+0xfb10b1d8>
8112b258:	800b883a 	mov	r5,r16
8112b25c:	9009883a 	mov	r4,r18
8112b260:	112cfa40 	call	8112cfa4 <_fflush_r>
8112b264:	1000071e 	bne	r2,zero,8112b284 <__swbuf_r+0x11c>
8112b268:	80800017 	ldw	r2,0(r16)
8112b26c:	00c00044 	movi	r3,1
8112b270:	003fda06 	br	8112b1dc <__reset+0xfb10b1dc>
8112b274:	800b883a 	mov	r5,r16
8112b278:	9009883a 	mov	r4,r18
8112b27c:	112cfa40 	call	8112cfa4 <_fflush_r>
8112b280:	103fe326 	beq	r2,zero,8112b210 <__reset+0xfb10b210>
8112b284:	00bfffc4 	movi	r2,-1
8112b288:	003fe206 	br	8112b214 <__reset+0xfb10b214>
8112b28c:	800b883a 	mov	r5,r16
8112b290:	9009883a 	mov	r4,r18
8112b294:	112b3300 	call	8112b330 <__swsetup_r>
8112b298:	103ffa1e 	bne	r2,zero,8112b284 <__reset+0xfb10b284>
8112b29c:	8100030b 	ldhu	r4,12(r16)
8112b2a0:	80c00417 	ldw	r3,16(r16)
8112b2a4:	003fc506 	br	8112b1bc <__reset+0xfb10b1bc>
8112b2a8:	112d3a00 	call	8112d3a0 <__sinit>
8112b2ac:	003fbc06 	br	8112b1a0 <__reset+0xfb10b1a0>

8112b2b0 <__swbuf>:
8112b2b0:	00a04574 	movhi	r2,33045
8112b2b4:	10936004 	addi	r2,r2,19840
8112b2b8:	280d883a 	mov	r6,r5
8112b2bc:	200b883a 	mov	r5,r4
8112b2c0:	11000017 	ldw	r4,0(r2)
8112b2c4:	112b1681 	jmpi	8112b168 <__swbuf_r>

8112b2c8 <_write_r>:
8112b2c8:	defffd04 	addi	sp,sp,-12
8112b2cc:	de00012e 	bgeu	sp,et,8112b2d4 <_write_r+0xc>
8112b2d0:	003b68fa 	trap	3
8112b2d4:	2805883a 	mov	r2,r5
8112b2d8:	dc000015 	stw	r16,0(sp)
8112b2dc:	04204574 	movhi	r16,33045
8112b2e0:	dc400115 	stw	r17,4(sp)
8112b2e4:	300b883a 	mov	r5,r6
8112b2e8:	8413d304 	addi	r16,r16,20300
8112b2ec:	2023883a 	mov	r17,r4
8112b2f0:	380d883a 	mov	r6,r7
8112b2f4:	1009883a 	mov	r4,r2
8112b2f8:	dfc00215 	stw	ra,8(sp)
8112b2fc:	80000015 	stw	zero,0(r16)
8112b300:	1139ad80 	call	81139ad8 <write>
8112b304:	00ffffc4 	movi	r3,-1
8112b308:	10c00526 	beq	r2,r3,8112b320 <_write_r+0x58>
8112b30c:	dfc00217 	ldw	ra,8(sp)
8112b310:	dc400117 	ldw	r17,4(sp)
8112b314:	dc000017 	ldw	r16,0(sp)
8112b318:	dec00304 	addi	sp,sp,12
8112b31c:	f800283a 	ret
8112b320:	80c00017 	ldw	r3,0(r16)
8112b324:	183ff926 	beq	r3,zero,8112b30c <__reset+0xfb10b30c>
8112b328:	88c00015 	stw	r3,0(r17)
8112b32c:	003ff706 	br	8112b30c <__reset+0xfb10b30c>

8112b330 <__swsetup_r>:
8112b330:	00a04574 	movhi	r2,33045
8112b334:	defffd04 	addi	sp,sp,-12
8112b338:	10936004 	addi	r2,r2,19840
8112b33c:	de00012e 	bgeu	sp,et,8112b344 <__swsetup_r+0x14>
8112b340:	003b68fa 	trap	3
8112b344:	dc400115 	stw	r17,4(sp)
8112b348:	2023883a 	mov	r17,r4
8112b34c:	11000017 	ldw	r4,0(r2)
8112b350:	dc000015 	stw	r16,0(sp)
8112b354:	dfc00215 	stw	ra,8(sp)
8112b358:	2821883a 	mov	r16,r5
8112b35c:	20000226 	beq	r4,zero,8112b368 <__swsetup_r+0x38>
8112b360:	20800e17 	ldw	r2,56(r4)
8112b364:	10003126 	beq	r2,zero,8112b42c <__swsetup_r+0xfc>
8112b368:	8080030b 	ldhu	r2,12(r16)
8112b36c:	10c0020c 	andi	r3,r2,8
8112b370:	1009883a 	mov	r4,r2
8112b374:	18000f26 	beq	r3,zero,8112b3b4 <__swsetup_r+0x84>
8112b378:	80c00417 	ldw	r3,16(r16)
8112b37c:	18001526 	beq	r3,zero,8112b3d4 <__swsetup_r+0xa4>
8112b380:	1100004c 	andi	r4,r2,1
8112b384:	20001c1e 	bne	r4,zero,8112b3f8 <__swsetup_r+0xc8>
8112b388:	1080008c 	andi	r2,r2,2
8112b38c:	1000291e 	bne	r2,zero,8112b434 <__swsetup_r+0x104>
8112b390:	80800517 	ldw	r2,20(r16)
8112b394:	80800215 	stw	r2,8(r16)
8112b398:	18001c26 	beq	r3,zero,8112b40c <__swsetup_r+0xdc>
8112b39c:	0005883a 	mov	r2,zero
8112b3a0:	dfc00217 	ldw	ra,8(sp)
8112b3a4:	dc400117 	ldw	r17,4(sp)
8112b3a8:	dc000017 	ldw	r16,0(sp)
8112b3ac:	dec00304 	addi	sp,sp,12
8112b3b0:	f800283a 	ret
8112b3b4:	2080040c 	andi	r2,r4,16
8112b3b8:	10002e26 	beq	r2,zero,8112b474 <__swsetup_r+0x144>
8112b3bc:	2080010c 	andi	r2,r4,4
8112b3c0:	10001e1e 	bne	r2,zero,8112b43c <__swsetup_r+0x10c>
8112b3c4:	80c00417 	ldw	r3,16(r16)
8112b3c8:	20800214 	ori	r2,r4,8
8112b3cc:	8080030d 	sth	r2,12(r16)
8112b3d0:	183feb1e 	bne	r3,zero,8112b380 <__reset+0xfb10b380>
8112b3d4:	1100a00c 	andi	r4,r2,640
8112b3d8:	01408004 	movi	r5,512
8112b3dc:	217fe826 	beq	r4,r5,8112b380 <__reset+0xfb10b380>
8112b3e0:	800b883a 	mov	r5,r16
8112b3e4:	8809883a 	mov	r4,r17
8112b3e8:	11239780 	call	81123978 <__smakebuf_r>
8112b3ec:	8080030b 	ldhu	r2,12(r16)
8112b3f0:	80c00417 	ldw	r3,16(r16)
8112b3f4:	003fe206 	br	8112b380 <__reset+0xfb10b380>
8112b3f8:	80800517 	ldw	r2,20(r16)
8112b3fc:	80000215 	stw	zero,8(r16)
8112b400:	0085c83a 	sub	r2,zero,r2
8112b404:	80800615 	stw	r2,24(r16)
8112b408:	183fe41e 	bne	r3,zero,8112b39c <__reset+0xfb10b39c>
8112b40c:	80c0030b 	ldhu	r3,12(r16)
8112b410:	0005883a 	mov	r2,zero
8112b414:	1900200c 	andi	r4,r3,128
8112b418:	203fe126 	beq	r4,zero,8112b3a0 <__reset+0xfb10b3a0>
8112b41c:	18c01014 	ori	r3,r3,64
8112b420:	80c0030d 	sth	r3,12(r16)
8112b424:	00bfffc4 	movi	r2,-1
8112b428:	003fdd06 	br	8112b3a0 <__reset+0xfb10b3a0>
8112b42c:	112d3a00 	call	8112d3a0 <__sinit>
8112b430:	003fcd06 	br	8112b368 <__reset+0xfb10b368>
8112b434:	0005883a 	mov	r2,zero
8112b438:	003fd606 	br	8112b394 <__reset+0xfb10b394>
8112b43c:	81400c17 	ldw	r5,48(r16)
8112b440:	28000626 	beq	r5,zero,8112b45c <__swsetup_r+0x12c>
8112b444:	80801004 	addi	r2,r16,64
8112b448:	28800326 	beq	r5,r2,8112b458 <__swsetup_r+0x128>
8112b44c:	8809883a 	mov	r4,r17
8112b450:	112d8380 	call	8112d838 <_free_r>
8112b454:	8100030b 	ldhu	r4,12(r16)
8112b458:	80000c15 	stw	zero,48(r16)
8112b45c:	80c00417 	ldw	r3,16(r16)
8112b460:	00bff6c4 	movi	r2,-37
8112b464:	1108703a 	and	r4,r2,r4
8112b468:	80000115 	stw	zero,4(r16)
8112b46c:	80c00015 	stw	r3,0(r16)
8112b470:	003fd506 	br	8112b3c8 <__reset+0xfb10b3c8>
8112b474:	00800244 	movi	r2,9
8112b478:	88800015 	stw	r2,0(r17)
8112b47c:	20801014 	ori	r2,r4,64
8112b480:	8080030d 	sth	r2,12(r16)
8112b484:	00bfffc4 	movi	r2,-1
8112b488:	003fc506 	br	8112b3a0 <__reset+0xfb10b3a0>

8112b48c <_close_r>:
8112b48c:	defffd04 	addi	sp,sp,-12
8112b490:	de00012e 	bgeu	sp,et,8112b498 <_close_r+0xc>
8112b494:	003b68fa 	trap	3
8112b498:	dc000015 	stw	r16,0(sp)
8112b49c:	04204574 	movhi	r16,33045
8112b4a0:	dc400115 	stw	r17,4(sp)
8112b4a4:	8413d304 	addi	r16,r16,20300
8112b4a8:	2023883a 	mov	r17,r4
8112b4ac:	2809883a 	mov	r4,r5
8112b4b0:	dfc00215 	stw	ra,8(sp)
8112b4b4:	80000015 	stw	zero,0(r16)
8112b4b8:	11380580 	call	81138058 <close>
8112b4bc:	00ffffc4 	movi	r3,-1
8112b4c0:	10c00526 	beq	r2,r3,8112b4d8 <_close_r+0x4c>
8112b4c4:	dfc00217 	ldw	ra,8(sp)
8112b4c8:	dc400117 	ldw	r17,4(sp)
8112b4cc:	dc000017 	ldw	r16,0(sp)
8112b4d0:	dec00304 	addi	sp,sp,12
8112b4d4:	f800283a 	ret
8112b4d8:	80c00017 	ldw	r3,0(r16)
8112b4dc:	183ff926 	beq	r3,zero,8112b4c4 <__reset+0xfb10b4c4>
8112b4e0:	88c00015 	stw	r3,0(r17)
8112b4e4:	003ff706 	br	8112b4c4 <__reset+0xfb10b4c4>

8112b4e8 <quorem>:
8112b4e8:	defff704 	addi	sp,sp,-36
8112b4ec:	de00012e 	bgeu	sp,et,8112b4f4 <quorem+0xc>
8112b4f0:	003b68fa 	trap	3
8112b4f4:	dc800215 	stw	r18,8(sp)
8112b4f8:	20800417 	ldw	r2,16(r4)
8112b4fc:	2c800417 	ldw	r18,16(r5)
8112b500:	dfc00815 	stw	ra,32(sp)
8112b504:	ddc00715 	stw	r23,28(sp)
8112b508:	dd800615 	stw	r22,24(sp)
8112b50c:	dd400515 	stw	r21,20(sp)
8112b510:	dd000415 	stw	r20,16(sp)
8112b514:	dcc00315 	stw	r19,12(sp)
8112b518:	dc400115 	stw	r17,4(sp)
8112b51c:	dc000015 	stw	r16,0(sp)
8112b520:	14807116 	blt	r2,r18,8112b6e8 <quorem+0x200>
8112b524:	94bfffc4 	addi	r18,r18,-1
8112b528:	94ad883a 	add	r22,r18,r18
8112b52c:	b5ad883a 	add	r22,r22,r22
8112b530:	2c400504 	addi	r17,r5,20
8112b534:	8da9883a 	add	r20,r17,r22
8112b538:	25400504 	addi	r21,r4,20
8112b53c:	282f883a 	mov	r23,r5
8112b540:	adad883a 	add	r22,r21,r22
8112b544:	a1400017 	ldw	r5,0(r20)
8112b548:	2021883a 	mov	r16,r4
8112b54c:	b1000017 	ldw	r4,0(r22)
8112b550:	29400044 	addi	r5,r5,1
8112b554:	113685c0 	call	8113685c <__udivsi3>
8112b558:	1027883a 	mov	r19,r2
8112b55c:	10002c26 	beq	r2,zero,8112b610 <quorem+0x128>
8112b560:	a813883a 	mov	r9,r21
8112b564:	880b883a 	mov	r5,r17
8112b568:	0009883a 	mov	r4,zero
8112b56c:	000d883a 	mov	r6,zero
8112b570:	2a000017 	ldw	r8,0(r5)
8112b574:	49c00017 	ldw	r7,0(r9)
8112b578:	29400104 	addi	r5,r5,4
8112b57c:	40bfffcc 	andi	r2,r8,65535
8112b580:	14c5383a 	mul	r2,r2,r19
8112b584:	4010d43a 	srli	r8,r8,16
8112b588:	38ffffcc 	andi	r3,r7,65535
8112b58c:	1105883a 	add	r2,r2,r4
8112b590:	1008d43a 	srli	r4,r2,16
8112b594:	44d1383a 	mul	r8,r8,r19
8112b598:	198d883a 	add	r6,r3,r6
8112b59c:	10ffffcc 	andi	r3,r2,65535
8112b5a0:	30c7c83a 	sub	r3,r6,r3
8112b5a4:	380ed43a 	srli	r7,r7,16
8112b5a8:	4105883a 	add	r2,r8,r4
8112b5ac:	180dd43a 	srai	r6,r3,16
8112b5b0:	113fffcc 	andi	r4,r2,65535
8112b5b4:	390fc83a 	sub	r7,r7,r4
8112b5b8:	398d883a 	add	r6,r7,r6
8112b5bc:	300e943a 	slli	r7,r6,16
8112b5c0:	18ffffcc 	andi	r3,r3,65535
8112b5c4:	1008d43a 	srli	r4,r2,16
8112b5c8:	38ceb03a 	or	r7,r7,r3
8112b5cc:	49c00015 	stw	r7,0(r9)
8112b5d0:	300dd43a 	srai	r6,r6,16
8112b5d4:	4a400104 	addi	r9,r9,4
8112b5d8:	a17fe52e 	bgeu	r20,r5,8112b570 <__reset+0xfb10b570>
8112b5dc:	b0800017 	ldw	r2,0(r22)
8112b5e0:	10000b1e 	bne	r2,zero,8112b610 <quorem+0x128>
8112b5e4:	b0bfff04 	addi	r2,r22,-4
8112b5e8:	a880082e 	bgeu	r21,r2,8112b60c <quorem+0x124>
8112b5ec:	b0ffff17 	ldw	r3,-4(r22)
8112b5f0:	18000326 	beq	r3,zero,8112b600 <quorem+0x118>
8112b5f4:	00000506 	br	8112b60c <quorem+0x124>
8112b5f8:	10c00017 	ldw	r3,0(r2)
8112b5fc:	1800031e 	bne	r3,zero,8112b60c <quorem+0x124>
8112b600:	10bfff04 	addi	r2,r2,-4
8112b604:	94bfffc4 	addi	r18,r18,-1
8112b608:	a8bffb36 	bltu	r21,r2,8112b5f8 <__reset+0xfb10b5f8>
8112b60c:	84800415 	stw	r18,16(r16)
8112b610:	b80b883a 	mov	r5,r23
8112b614:	8009883a 	mov	r4,r16
8112b618:	112f1080 	call	8112f108 <__mcmp>
8112b61c:	10002616 	blt	r2,zero,8112b6b8 <quorem+0x1d0>
8112b620:	9cc00044 	addi	r19,r19,1
8112b624:	a805883a 	mov	r2,r21
8112b628:	000b883a 	mov	r5,zero
8112b62c:	11000017 	ldw	r4,0(r2)
8112b630:	89800017 	ldw	r6,0(r17)
8112b634:	10800104 	addi	r2,r2,4
8112b638:	20ffffcc 	andi	r3,r4,65535
8112b63c:	194b883a 	add	r5,r3,r5
8112b640:	30ffffcc 	andi	r3,r6,65535
8112b644:	28c7c83a 	sub	r3,r5,r3
8112b648:	300cd43a 	srli	r6,r6,16
8112b64c:	2008d43a 	srli	r4,r4,16
8112b650:	180bd43a 	srai	r5,r3,16
8112b654:	18ffffcc 	andi	r3,r3,65535
8112b658:	2189c83a 	sub	r4,r4,r6
8112b65c:	2149883a 	add	r4,r4,r5
8112b660:	200c943a 	slli	r6,r4,16
8112b664:	8c400104 	addi	r17,r17,4
8112b668:	200bd43a 	srai	r5,r4,16
8112b66c:	30c6b03a 	or	r3,r6,r3
8112b670:	10ffff15 	stw	r3,-4(r2)
8112b674:	a47fed2e 	bgeu	r20,r17,8112b62c <__reset+0xfb10b62c>
8112b678:	9485883a 	add	r2,r18,r18
8112b67c:	1085883a 	add	r2,r2,r2
8112b680:	a887883a 	add	r3,r21,r2
8112b684:	18800017 	ldw	r2,0(r3)
8112b688:	10000b1e 	bne	r2,zero,8112b6b8 <quorem+0x1d0>
8112b68c:	18bfff04 	addi	r2,r3,-4
8112b690:	a880082e 	bgeu	r21,r2,8112b6b4 <quorem+0x1cc>
8112b694:	18ffff17 	ldw	r3,-4(r3)
8112b698:	18000326 	beq	r3,zero,8112b6a8 <quorem+0x1c0>
8112b69c:	00000506 	br	8112b6b4 <quorem+0x1cc>
8112b6a0:	10c00017 	ldw	r3,0(r2)
8112b6a4:	1800031e 	bne	r3,zero,8112b6b4 <quorem+0x1cc>
8112b6a8:	10bfff04 	addi	r2,r2,-4
8112b6ac:	94bfffc4 	addi	r18,r18,-1
8112b6b0:	a8bffb36 	bltu	r21,r2,8112b6a0 <__reset+0xfb10b6a0>
8112b6b4:	84800415 	stw	r18,16(r16)
8112b6b8:	9805883a 	mov	r2,r19
8112b6bc:	dfc00817 	ldw	ra,32(sp)
8112b6c0:	ddc00717 	ldw	r23,28(sp)
8112b6c4:	dd800617 	ldw	r22,24(sp)
8112b6c8:	dd400517 	ldw	r21,20(sp)
8112b6cc:	dd000417 	ldw	r20,16(sp)
8112b6d0:	dcc00317 	ldw	r19,12(sp)
8112b6d4:	dc800217 	ldw	r18,8(sp)
8112b6d8:	dc400117 	ldw	r17,4(sp)
8112b6dc:	dc000017 	ldw	r16,0(sp)
8112b6e0:	dec00904 	addi	sp,sp,36
8112b6e4:	f800283a 	ret
8112b6e8:	0005883a 	mov	r2,zero
8112b6ec:	003ff306 	br	8112b6bc <__reset+0xfb10b6bc>

8112b6f0 <_dtoa_r>:
8112b6f0:	deffde04 	addi	sp,sp,-136
8112b6f4:	de00012e 	bgeu	sp,et,8112b6fc <_dtoa_r+0xc>
8112b6f8:	003b68fa 	trap	3
8112b6fc:	20801017 	ldw	r2,64(r4)
8112b700:	df002015 	stw	fp,128(sp)
8112b704:	dcc01b15 	stw	r19,108(sp)
8112b708:	dc801a15 	stw	r18,104(sp)
8112b70c:	dc401915 	stw	r17,100(sp)
8112b710:	dc001815 	stw	r16,96(sp)
8112b714:	dfc02115 	stw	ra,132(sp)
8112b718:	ddc01f15 	stw	r23,124(sp)
8112b71c:	dd801e15 	stw	r22,120(sp)
8112b720:	dd401d15 	stw	r21,116(sp)
8112b724:	dd001c15 	stw	r20,112(sp)
8112b728:	d9c00315 	stw	r7,12(sp)
8112b72c:	2039883a 	mov	fp,r4
8112b730:	3023883a 	mov	r17,r6
8112b734:	2825883a 	mov	r18,r5
8112b738:	dc002417 	ldw	r16,144(sp)
8112b73c:	3027883a 	mov	r19,r6
8112b740:	10000826 	beq	r2,zero,8112b764 <_dtoa_r+0x74>
8112b744:	21801117 	ldw	r6,68(r4)
8112b748:	00c00044 	movi	r3,1
8112b74c:	100b883a 	mov	r5,r2
8112b750:	1986983a 	sll	r3,r3,r6
8112b754:	11800115 	stw	r6,4(r2)
8112b758:	10c00215 	stw	r3,8(r2)
8112b75c:	112e8b80 	call	8112e8b8 <_Bfree>
8112b760:	e0001015 	stw	zero,64(fp)
8112b764:	88002e16 	blt	r17,zero,8112b820 <_dtoa_r+0x130>
8112b768:	80000015 	stw	zero,0(r16)
8112b76c:	889ffc2c 	andhi	r2,r17,32752
8112b770:	00dffc34 	movhi	r3,32752
8112b774:	10c01c26 	beq	r2,r3,8112b7e8 <_dtoa_r+0xf8>
8112b778:	000d883a 	mov	r6,zero
8112b77c:	000f883a 	mov	r7,zero
8112b780:	9009883a 	mov	r4,r18
8112b784:	980b883a 	mov	r5,r19
8112b788:	1137cb80 	call	81137cb8 <__eqdf2>
8112b78c:	10002b1e 	bne	r2,zero,8112b83c <_dtoa_r+0x14c>
8112b790:	d9c02317 	ldw	r7,140(sp)
8112b794:	00800044 	movi	r2,1
8112b798:	38800015 	stw	r2,0(r7)
8112b79c:	d8802517 	ldw	r2,148(sp)
8112b7a0:	10019e26 	beq	r2,zero,8112be1c <_dtoa_r+0x72c>
8112b7a4:	d8c02517 	ldw	r3,148(sp)
8112b7a8:	00a04574 	movhi	r2,33045
8112b7ac:	10899844 	addi	r2,r2,9825
8112b7b0:	18800015 	stw	r2,0(r3)
8112b7b4:	10bfffc4 	addi	r2,r2,-1
8112b7b8:	dfc02117 	ldw	ra,132(sp)
8112b7bc:	df002017 	ldw	fp,128(sp)
8112b7c0:	ddc01f17 	ldw	r23,124(sp)
8112b7c4:	dd801e17 	ldw	r22,120(sp)
8112b7c8:	dd401d17 	ldw	r21,116(sp)
8112b7cc:	dd001c17 	ldw	r20,112(sp)
8112b7d0:	dcc01b17 	ldw	r19,108(sp)
8112b7d4:	dc801a17 	ldw	r18,104(sp)
8112b7d8:	dc401917 	ldw	r17,100(sp)
8112b7dc:	dc001817 	ldw	r16,96(sp)
8112b7e0:	dec02204 	addi	sp,sp,136
8112b7e4:	f800283a 	ret
8112b7e8:	d8c02317 	ldw	r3,140(sp)
8112b7ec:	0089c3c4 	movi	r2,9999
8112b7f0:	18800015 	stw	r2,0(r3)
8112b7f4:	90017726 	beq	r18,zero,8112bdd4 <_dtoa_r+0x6e4>
8112b7f8:	00a04574 	movhi	r2,33045
8112b7fc:	1089b604 	addi	r2,r2,9944
8112b800:	d9002517 	ldw	r4,148(sp)
8112b804:	203fec26 	beq	r4,zero,8112b7b8 <__reset+0xfb10b7b8>
8112b808:	10c000c7 	ldb	r3,3(r2)
8112b80c:	1801781e 	bne	r3,zero,8112bdf0 <_dtoa_r+0x700>
8112b810:	10c000c4 	addi	r3,r2,3
8112b814:	d9802517 	ldw	r6,148(sp)
8112b818:	30c00015 	stw	r3,0(r6)
8112b81c:	003fe606 	br	8112b7b8 <__reset+0xfb10b7b8>
8112b820:	04e00034 	movhi	r19,32768
8112b824:	9cffffc4 	addi	r19,r19,-1
8112b828:	00800044 	movi	r2,1
8112b82c:	8ce6703a 	and	r19,r17,r19
8112b830:	80800015 	stw	r2,0(r16)
8112b834:	9823883a 	mov	r17,r19
8112b838:	003fcc06 	br	8112b76c <__reset+0xfb10b76c>
8112b83c:	d8800204 	addi	r2,sp,8
8112b840:	d8800015 	stw	r2,0(sp)
8112b844:	d9c00104 	addi	r7,sp,4
8112b848:	900b883a 	mov	r5,r18
8112b84c:	980d883a 	mov	r6,r19
8112b850:	e009883a 	mov	r4,fp
8112b854:	8820d53a 	srli	r16,r17,20
8112b858:	112f4e40 	call	8112f4e4 <__d2b>
8112b85c:	d8800915 	stw	r2,36(sp)
8112b860:	8001651e 	bne	r16,zero,8112bdf8 <_dtoa_r+0x708>
8112b864:	dd800217 	ldw	r22,8(sp)
8112b868:	dc000117 	ldw	r16,4(sp)
8112b86c:	00800804 	movi	r2,32
8112b870:	b421883a 	add	r16,r22,r16
8112b874:	80c10c84 	addi	r3,r16,1074
8112b878:	10c2d10e 	bge	r2,r3,8112c3c0 <_dtoa_r+0xcd0>
8112b87c:	00801004 	movi	r2,64
8112b880:	81010484 	addi	r4,r16,1042
8112b884:	10c7c83a 	sub	r3,r2,r3
8112b888:	9108d83a 	srl	r4,r18,r4
8112b88c:	88e2983a 	sll	r17,r17,r3
8112b890:	2448b03a 	or	r4,r4,r17
8112b894:	1137e340 	call	81137e34 <__floatunsidf>
8112b898:	017f8434 	movhi	r5,65040
8112b89c:	01800044 	movi	r6,1
8112b8a0:	1009883a 	mov	r4,r2
8112b8a4:	194b883a 	add	r5,r3,r5
8112b8a8:	843fffc4 	addi	r16,r16,-1
8112b8ac:	d9801115 	stw	r6,68(sp)
8112b8b0:	000d883a 	mov	r6,zero
8112b8b4:	01cffe34 	movhi	r7,16376
8112b8b8:	11223a00 	call	811223a0 <__subdf3>
8112b8bc:	0198dbf4 	movhi	r6,25455
8112b8c0:	01cff4f4 	movhi	r7,16339
8112b8c4:	3190d844 	addi	r6,r6,17249
8112b8c8:	39e1e9c4 	addi	r7,r7,-30809
8112b8cc:	1009883a 	mov	r4,r2
8112b8d0:	180b883a 	mov	r5,r3
8112b8d4:	1121c800 	call	81121c80 <__muldf3>
8112b8d8:	01a2d874 	movhi	r6,35681
8112b8dc:	01cff1f4 	movhi	r7,16327
8112b8e0:	31b22cc4 	addi	r6,r6,-14157
8112b8e4:	39e28a04 	addi	r7,r7,-30168
8112b8e8:	180b883a 	mov	r5,r3
8112b8ec:	1009883a 	mov	r4,r2
8112b8f0:	1136b140 	call	81136b14 <__adddf3>
8112b8f4:	8009883a 	mov	r4,r16
8112b8f8:	1029883a 	mov	r20,r2
8112b8fc:	1823883a 	mov	r17,r3
8112b900:	1122d240 	call	81122d24 <__floatsidf>
8112b904:	019427f4 	movhi	r6,20639
8112b908:	01cff4f4 	movhi	r7,16339
8112b90c:	319e7ec4 	addi	r6,r6,31227
8112b910:	39d104c4 	addi	r7,r7,17427
8112b914:	1009883a 	mov	r4,r2
8112b918:	180b883a 	mov	r5,r3
8112b91c:	1121c800 	call	81121c80 <__muldf3>
8112b920:	100d883a 	mov	r6,r2
8112b924:	180f883a 	mov	r7,r3
8112b928:	a009883a 	mov	r4,r20
8112b92c:	880b883a 	mov	r5,r17
8112b930:	1136b140 	call	81136b14 <__adddf3>
8112b934:	1009883a 	mov	r4,r2
8112b938:	180b883a 	mov	r5,r3
8112b93c:	1029883a 	mov	r20,r2
8112b940:	1823883a 	mov	r17,r3
8112b944:	1122ca40 	call	81122ca4 <__fixdfsi>
8112b948:	000d883a 	mov	r6,zero
8112b94c:	000f883a 	mov	r7,zero
8112b950:	a009883a 	mov	r4,r20
8112b954:	880b883a 	mov	r5,r17
8112b958:	d8800515 	stw	r2,20(sp)
8112b95c:	1137d400 	call	81137d40 <__ledf2>
8112b960:	10028716 	blt	r2,zero,8112c380 <_dtoa_r+0xc90>
8112b964:	d8c00517 	ldw	r3,20(sp)
8112b968:	00800584 	movi	r2,22
8112b96c:	10c27536 	bltu	r2,r3,8112c344 <_dtoa_r+0xc54>
8112b970:	180490fa 	slli	r2,r3,3
8112b974:	00e04574 	movhi	r3,33045
8112b978:	18c9d104 	addi	r3,r3,10052
8112b97c:	1885883a 	add	r2,r3,r2
8112b980:	11000017 	ldw	r4,0(r2)
8112b984:	11400117 	ldw	r5,4(r2)
8112b988:	900d883a 	mov	r6,r18
8112b98c:	980f883a 	mov	r7,r19
8112b990:	1121ba40 	call	81121ba4 <__gedf2>
8112b994:	00828d0e 	bge	zero,r2,8112c3cc <_dtoa_r+0xcdc>
8112b998:	d9000517 	ldw	r4,20(sp)
8112b99c:	d8000e15 	stw	zero,56(sp)
8112b9a0:	213fffc4 	addi	r4,r4,-1
8112b9a4:	d9000515 	stw	r4,20(sp)
8112b9a8:	b42dc83a 	sub	r22,r22,r16
8112b9ac:	b5bfffc4 	addi	r22,r22,-1
8112b9b0:	b0026f16 	blt	r22,zero,8112c370 <_dtoa_r+0xc80>
8112b9b4:	d8000815 	stw	zero,32(sp)
8112b9b8:	d9c00517 	ldw	r7,20(sp)
8112b9bc:	38026416 	blt	r7,zero,8112c350 <_dtoa_r+0xc60>
8112b9c0:	b1ed883a 	add	r22,r22,r7
8112b9c4:	d9c00d15 	stw	r7,52(sp)
8112b9c8:	d8000a15 	stw	zero,40(sp)
8112b9cc:	d9800317 	ldw	r6,12(sp)
8112b9d0:	00800244 	movi	r2,9
8112b9d4:	11811436 	bltu	r2,r6,8112be28 <_dtoa_r+0x738>
8112b9d8:	00800144 	movi	r2,5
8112b9dc:	1184e10e 	bge	r2,r6,8112cd64 <_dtoa_r+0x1674>
8112b9e0:	31bfff04 	addi	r6,r6,-4
8112b9e4:	d9800315 	stw	r6,12(sp)
8112b9e8:	0023883a 	mov	r17,zero
8112b9ec:	d9800317 	ldw	r6,12(sp)
8112b9f0:	008000c4 	movi	r2,3
8112b9f4:	30836726 	beq	r6,r2,8112c794 <_dtoa_r+0x10a4>
8112b9f8:	1183410e 	bge	r2,r6,8112c700 <_dtoa_r+0x1010>
8112b9fc:	d9c00317 	ldw	r7,12(sp)
8112ba00:	00800104 	movi	r2,4
8112ba04:	38827c26 	beq	r7,r2,8112c3f8 <_dtoa_r+0xd08>
8112ba08:	00800144 	movi	r2,5
8112ba0c:	3884c41e 	bne	r7,r2,8112cd20 <_dtoa_r+0x1630>
8112ba10:	00800044 	movi	r2,1
8112ba14:	d8800b15 	stw	r2,44(sp)
8112ba18:	d8c00517 	ldw	r3,20(sp)
8112ba1c:	d9002217 	ldw	r4,136(sp)
8112ba20:	1907883a 	add	r3,r3,r4
8112ba24:	19800044 	addi	r6,r3,1
8112ba28:	d8c00c15 	stw	r3,48(sp)
8112ba2c:	d9800615 	stw	r6,24(sp)
8112ba30:	0183a40e 	bge	zero,r6,8112c8c4 <_dtoa_r+0x11d4>
8112ba34:	d9800617 	ldw	r6,24(sp)
8112ba38:	3021883a 	mov	r16,r6
8112ba3c:	e0001115 	stw	zero,68(fp)
8112ba40:	008005c4 	movi	r2,23
8112ba44:	1184c92e 	bgeu	r2,r6,8112cd6c <_dtoa_r+0x167c>
8112ba48:	00c00044 	movi	r3,1
8112ba4c:	00800104 	movi	r2,4
8112ba50:	1085883a 	add	r2,r2,r2
8112ba54:	11000504 	addi	r4,r2,20
8112ba58:	180b883a 	mov	r5,r3
8112ba5c:	18c00044 	addi	r3,r3,1
8112ba60:	313ffb2e 	bgeu	r6,r4,8112ba50 <__reset+0xfb10ba50>
8112ba64:	e1401115 	stw	r5,68(fp)
8112ba68:	e009883a 	mov	r4,fp
8112ba6c:	112e8080 	call	8112e808 <_Balloc>
8112ba70:	d8800715 	stw	r2,28(sp)
8112ba74:	e0801015 	stw	r2,64(fp)
8112ba78:	00800384 	movi	r2,14
8112ba7c:	1400f736 	bltu	r2,r16,8112be5c <_dtoa_r+0x76c>
8112ba80:	8800f626 	beq	r17,zero,8112be5c <_dtoa_r+0x76c>
8112ba84:	d9c00517 	ldw	r7,20(sp)
8112ba88:	01c39a0e 	bge	zero,r7,8112c8f4 <_dtoa_r+0x1204>
8112ba8c:	388003cc 	andi	r2,r7,15
8112ba90:	100490fa 	slli	r2,r2,3
8112ba94:	382bd13a 	srai	r21,r7,4
8112ba98:	00e04574 	movhi	r3,33045
8112ba9c:	18c9d104 	addi	r3,r3,10052
8112baa0:	1885883a 	add	r2,r3,r2
8112baa4:	a8c0040c 	andi	r3,r21,16
8112baa8:	12400017 	ldw	r9,0(r2)
8112baac:	12000117 	ldw	r8,4(r2)
8112bab0:	18037926 	beq	r3,zero,8112c898 <_dtoa_r+0x11a8>
8112bab4:	00a04574 	movhi	r2,33045
8112bab8:	1089c704 	addi	r2,r2,10012
8112babc:	11800817 	ldw	r6,32(r2)
8112bac0:	11c00917 	ldw	r7,36(r2)
8112bac4:	9009883a 	mov	r4,r18
8112bac8:	980b883a 	mov	r5,r19
8112bacc:	da001715 	stw	r8,92(sp)
8112bad0:	da401615 	stw	r9,88(sp)
8112bad4:	11373c80 	call	811373c8 <__divdf3>
8112bad8:	da001717 	ldw	r8,92(sp)
8112badc:	da401617 	ldw	r9,88(sp)
8112bae0:	ad4003cc 	andi	r21,r21,15
8112bae4:	040000c4 	movi	r16,3
8112bae8:	1023883a 	mov	r17,r2
8112baec:	1829883a 	mov	r20,r3
8112baf0:	a8001126 	beq	r21,zero,8112bb38 <_dtoa_r+0x448>
8112baf4:	05e04574 	movhi	r23,33045
8112baf8:	bdc9c704 	addi	r23,r23,10012
8112bafc:	4805883a 	mov	r2,r9
8112bb00:	4007883a 	mov	r3,r8
8112bb04:	a980004c 	andi	r6,r21,1
8112bb08:	1009883a 	mov	r4,r2
8112bb0c:	a82bd07a 	srai	r21,r21,1
8112bb10:	180b883a 	mov	r5,r3
8112bb14:	30000426 	beq	r6,zero,8112bb28 <_dtoa_r+0x438>
8112bb18:	b9800017 	ldw	r6,0(r23)
8112bb1c:	b9c00117 	ldw	r7,4(r23)
8112bb20:	84000044 	addi	r16,r16,1
8112bb24:	1121c800 	call	81121c80 <__muldf3>
8112bb28:	bdc00204 	addi	r23,r23,8
8112bb2c:	a83ff51e 	bne	r21,zero,8112bb04 <__reset+0xfb10bb04>
8112bb30:	1013883a 	mov	r9,r2
8112bb34:	1811883a 	mov	r8,r3
8112bb38:	480d883a 	mov	r6,r9
8112bb3c:	400f883a 	mov	r7,r8
8112bb40:	8809883a 	mov	r4,r17
8112bb44:	a00b883a 	mov	r5,r20
8112bb48:	11373c80 	call	811373c8 <__divdf3>
8112bb4c:	d8800f15 	stw	r2,60(sp)
8112bb50:	d8c01015 	stw	r3,64(sp)
8112bb54:	d8c00e17 	ldw	r3,56(sp)
8112bb58:	18000626 	beq	r3,zero,8112bb74 <_dtoa_r+0x484>
8112bb5c:	d9000f17 	ldw	r4,60(sp)
8112bb60:	d9401017 	ldw	r5,64(sp)
8112bb64:	000d883a 	mov	r6,zero
8112bb68:	01cffc34 	movhi	r7,16368
8112bb6c:	1137d400 	call	81137d40 <__ledf2>
8112bb70:	10040b16 	blt	r2,zero,8112cba0 <_dtoa_r+0x14b0>
8112bb74:	8009883a 	mov	r4,r16
8112bb78:	1122d240 	call	81122d24 <__floatsidf>
8112bb7c:	d9800f17 	ldw	r6,60(sp)
8112bb80:	d9c01017 	ldw	r7,64(sp)
8112bb84:	1009883a 	mov	r4,r2
8112bb88:	180b883a 	mov	r5,r3
8112bb8c:	1121c800 	call	81121c80 <__muldf3>
8112bb90:	000d883a 	mov	r6,zero
8112bb94:	01d00734 	movhi	r7,16412
8112bb98:	1009883a 	mov	r4,r2
8112bb9c:	180b883a 	mov	r5,r3
8112bba0:	1136b140 	call	81136b14 <__adddf3>
8112bba4:	1021883a 	mov	r16,r2
8112bba8:	d8800617 	ldw	r2,24(sp)
8112bbac:	047f3034 	movhi	r17,64704
8112bbb0:	1c63883a 	add	r17,r3,r17
8112bbb4:	10031826 	beq	r2,zero,8112c818 <_dtoa_r+0x1128>
8112bbb8:	d8c00517 	ldw	r3,20(sp)
8112bbbc:	db000617 	ldw	r12,24(sp)
8112bbc0:	d8c01315 	stw	r3,76(sp)
8112bbc4:	d9000b17 	ldw	r4,44(sp)
8112bbc8:	20038f26 	beq	r4,zero,8112ca08 <_dtoa_r+0x1318>
8112bbcc:	60bfffc4 	addi	r2,r12,-1
8112bbd0:	100490fa 	slli	r2,r2,3
8112bbd4:	00e04574 	movhi	r3,33045
8112bbd8:	18c9d104 	addi	r3,r3,10052
8112bbdc:	1885883a 	add	r2,r3,r2
8112bbe0:	11800017 	ldw	r6,0(r2)
8112bbe4:	11c00117 	ldw	r7,4(r2)
8112bbe8:	d8800717 	ldw	r2,28(sp)
8112bbec:	0009883a 	mov	r4,zero
8112bbf0:	014ff834 	movhi	r5,16352
8112bbf4:	db001615 	stw	r12,88(sp)
8112bbf8:	15c00044 	addi	r23,r2,1
8112bbfc:	11373c80 	call	811373c8 <__divdf3>
8112bc00:	800d883a 	mov	r6,r16
8112bc04:	880f883a 	mov	r7,r17
8112bc08:	1009883a 	mov	r4,r2
8112bc0c:	180b883a 	mov	r5,r3
8112bc10:	11223a00 	call	811223a0 <__subdf3>
8112bc14:	d9401017 	ldw	r5,64(sp)
8112bc18:	d9000f17 	ldw	r4,60(sp)
8112bc1c:	102b883a 	mov	r21,r2
8112bc20:	d8c01215 	stw	r3,72(sp)
8112bc24:	1122ca40 	call	81122ca4 <__fixdfsi>
8112bc28:	1009883a 	mov	r4,r2
8112bc2c:	1029883a 	mov	r20,r2
8112bc30:	1122d240 	call	81122d24 <__floatsidf>
8112bc34:	d9000f17 	ldw	r4,60(sp)
8112bc38:	d9401017 	ldw	r5,64(sp)
8112bc3c:	100d883a 	mov	r6,r2
8112bc40:	180f883a 	mov	r7,r3
8112bc44:	11223a00 	call	811223a0 <__subdf3>
8112bc48:	1823883a 	mov	r17,r3
8112bc4c:	d8c00717 	ldw	r3,28(sp)
8112bc50:	d9401217 	ldw	r5,72(sp)
8112bc54:	a2000c04 	addi	r8,r20,48
8112bc58:	1021883a 	mov	r16,r2
8112bc5c:	1a000005 	stb	r8,0(r3)
8112bc60:	800d883a 	mov	r6,r16
8112bc64:	880f883a 	mov	r7,r17
8112bc68:	a809883a 	mov	r4,r21
8112bc6c:	4029883a 	mov	r20,r8
8112bc70:	1121ba40 	call	81121ba4 <__gedf2>
8112bc74:	00841d16 	blt	zero,r2,8112ccec <_dtoa_r+0x15fc>
8112bc78:	800d883a 	mov	r6,r16
8112bc7c:	880f883a 	mov	r7,r17
8112bc80:	0009883a 	mov	r4,zero
8112bc84:	014ffc34 	movhi	r5,16368
8112bc88:	11223a00 	call	811223a0 <__subdf3>
8112bc8c:	d9401217 	ldw	r5,72(sp)
8112bc90:	100d883a 	mov	r6,r2
8112bc94:	180f883a 	mov	r7,r3
8112bc98:	a809883a 	mov	r4,r21
8112bc9c:	1121ba40 	call	81121ba4 <__gedf2>
8112bca0:	db001617 	ldw	r12,88(sp)
8112bca4:	00840e16 	blt	zero,r2,8112cce0 <_dtoa_r+0x15f0>
8112bca8:	00800044 	movi	r2,1
8112bcac:	13006b0e 	bge	r2,r12,8112be5c <_dtoa_r+0x76c>
8112bcb0:	d9000717 	ldw	r4,28(sp)
8112bcb4:	dd800f15 	stw	r22,60(sp)
8112bcb8:	dcc01015 	stw	r19,64(sp)
8112bcbc:	2319883a 	add	r12,r4,r12
8112bcc0:	dcc01217 	ldw	r19,72(sp)
8112bcc4:	602d883a 	mov	r22,r12
8112bcc8:	dc801215 	stw	r18,72(sp)
8112bccc:	b825883a 	mov	r18,r23
8112bcd0:	00000906 	br	8112bcf8 <_dtoa_r+0x608>
8112bcd4:	11223a00 	call	811223a0 <__subdf3>
8112bcd8:	a80d883a 	mov	r6,r21
8112bcdc:	980f883a 	mov	r7,r19
8112bce0:	1009883a 	mov	r4,r2
8112bce4:	180b883a 	mov	r5,r3
8112bce8:	1137d400 	call	81137d40 <__ledf2>
8112bcec:	1003e816 	blt	r2,zero,8112cc90 <_dtoa_r+0x15a0>
8112bcf0:	b825883a 	mov	r18,r23
8112bcf4:	bd83e926 	beq	r23,r22,8112cc9c <_dtoa_r+0x15ac>
8112bcf8:	a809883a 	mov	r4,r21
8112bcfc:	980b883a 	mov	r5,r19
8112bd00:	000d883a 	mov	r6,zero
8112bd04:	01d00934 	movhi	r7,16420
8112bd08:	1121c800 	call	81121c80 <__muldf3>
8112bd0c:	000d883a 	mov	r6,zero
8112bd10:	01d00934 	movhi	r7,16420
8112bd14:	8009883a 	mov	r4,r16
8112bd18:	880b883a 	mov	r5,r17
8112bd1c:	102b883a 	mov	r21,r2
8112bd20:	1827883a 	mov	r19,r3
8112bd24:	1121c800 	call	81121c80 <__muldf3>
8112bd28:	180b883a 	mov	r5,r3
8112bd2c:	1009883a 	mov	r4,r2
8112bd30:	1821883a 	mov	r16,r3
8112bd34:	1023883a 	mov	r17,r2
8112bd38:	1122ca40 	call	81122ca4 <__fixdfsi>
8112bd3c:	1009883a 	mov	r4,r2
8112bd40:	1029883a 	mov	r20,r2
8112bd44:	1122d240 	call	81122d24 <__floatsidf>
8112bd48:	8809883a 	mov	r4,r17
8112bd4c:	800b883a 	mov	r5,r16
8112bd50:	100d883a 	mov	r6,r2
8112bd54:	180f883a 	mov	r7,r3
8112bd58:	11223a00 	call	811223a0 <__subdf3>
8112bd5c:	a5000c04 	addi	r20,r20,48
8112bd60:	a80d883a 	mov	r6,r21
8112bd64:	980f883a 	mov	r7,r19
8112bd68:	1009883a 	mov	r4,r2
8112bd6c:	180b883a 	mov	r5,r3
8112bd70:	95000005 	stb	r20,0(r18)
8112bd74:	1021883a 	mov	r16,r2
8112bd78:	1823883a 	mov	r17,r3
8112bd7c:	1137d400 	call	81137d40 <__ledf2>
8112bd80:	bdc00044 	addi	r23,r23,1
8112bd84:	800d883a 	mov	r6,r16
8112bd88:	880f883a 	mov	r7,r17
8112bd8c:	0009883a 	mov	r4,zero
8112bd90:	014ffc34 	movhi	r5,16368
8112bd94:	103fcf0e 	bge	r2,zero,8112bcd4 <__reset+0xfb10bcd4>
8112bd98:	d8c01317 	ldw	r3,76(sp)
8112bd9c:	d8c00515 	stw	r3,20(sp)
8112bda0:	d9400917 	ldw	r5,36(sp)
8112bda4:	e009883a 	mov	r4,fp
8112bda8:	112e8b80 	call	8112e8b8 <_Bfree>
8112bdac:	d9000517 	ldw	r4,20(sp)
8112bdb0:	d9802317 	ldw	r6,140(sp)
8112bdb4:	d9c02517 	ldw	r7,148(sp)
8112bdb8:	b8000005 	stb	zero,0(r23)
8112bdbc:	20800044 	addi	r2,r4,1
8112bdc0:	30800015 	stw	r2,0(r6)
8112bdc4:	3802aa26 	beq	r7,zero,8112c870 <_dtoa_r+0x1180>
8112bdc8:	3dc00015 	stw	r23,0(r7)
8112bdcc:	d8800717 	ldw	r2,28(sp)
8112bdd0:	003e7906 	br	8112b7b8 <__reset+0xfb10b7b8>
8112bdd4:	00800434 	movhi	r2,16
8112bdd8:	10bfffc4 	addi	r2,r2,-1
8112bddc:	88a2703a 	and	r17,r17,r2
8112bde0:	883e851e 	bne	r17,zero,8112b7f8 <__reset+0xfb10b7f8>
8112bde4:	00a04574 	movhi	r2,33045
8112bde8:	1089b304 	addi	r2,r2,9932
8112bdec:	003e8406 	br	8112b800 <__reset+0xfb10b800>
8112bdf0:	10c00204 	addi	r3,r2,8
8112bdf4:	003e8706 	br	8112b814 <__reset+0xfb10b814>
8112bdf8:	01400434 	movhi	r5,16
8112bdfc:	297fffc4 	addi	r5,r5,-1
8112be00:	994a703a 	and	r5,r19,r5
8112be04:	9009883a 	mov	r4,r18
8112be08:	843f0044 	addi	r16,r16,-1023
8112be0c:	294ffc34 	orhi	r5,r5,16368
8112be10:	dd800217 	ldw	r22,8(sp)
8112be14:	d8001115 	stw	zero,68(sp)
8112be18:	003ea506 	br	8112b8b0 <__reset+0xfb10b8b0>
8112be1c:	00a04574 	movhi	r2,33045
8112be20:	10899804 	addi	r2,r2,9824
8112be24:	003e6406 	br	8112b7b8 <__reset+0xfb10b7b8>
8112be28:	e0001115 	stw	zero,68(fp)
8112be2c:	000b883a 	mov	r5,zero
8112be30:	e009883a 	mov	r4,fp
8112be34:	112e8080 	call	8112e808 <_Balloc>
8112be38:	01bfffc4 	movi	r6,-1
8112be3c:	01c00044 	movi	r7,1
8112be40:	d8800715 	stw	r2,28(sp)
8112be44:	d9800c15 	stw	r6,48(sp)
8112be48:	e0801015 	stw	r2,64(fp)
8112be4c:	d8000315 	stw	zero,12(sp)
8112be50:	d9c00b15 	stw	r7,44(sp)
8112be54:	d9800615 	stw	r6,24(sp)
8112be58:	d8002215 	stw	zero,136(sp)
8112be5c:	d8800117 	ldw	r2,4(sp)
8112be60:	10008916 	blt	r2,zero,8112c088 <_dtoa_r+0x998>
8112be64:	d9000517 	ldw	r4,20(sp)
8112be68:	00c00384 	movi	r3,14
8112be6c:	19008616 	blt	r3,r4,8112c088 <_dtoa_r+0x998>
8112be70:	200490fa 	slli	r2,r4,3
8112be74:	00e04574 	movhi	r3,33045
8112be78:	d9802217 	ldw	r6,136(sp)
8112be7c:	18c9d104 	addi	r3,r3,10052
8112be80:	1885883a 	add	r2,r3,r2
8112be84:	14000017 	ldw	r16,0(r2)
8112be88:	14400117 	ldw	r17,4(r2)
8112be8c:	30016316 	blt	r6,zero,8112c41c <_dtoa_r+0xd2c>
8112be90:	800d883a 	mov	r6,r16
8112be94:	880f883a 	mov	r7,r17
8112be98:	9009883a 	mov	r4,r18
8112be9c:	980b883a 	mov	r5,r19
8112bea0:	11373c80 	call	811373c8 <__divdf3>
8112bea4:	180b883a 	mov	r5,r3
8112bea8:	1009883a 	mov	r4,r2
8112beac:	1122ca40 	call	81122ca4 <__fixdfsi>
8112beb0:	1009883a 	mov	r4,r2
8112beb4:	102b883a 	mov	r21,r2
8112beb8:	1122d240 	call	81122d24 <__floatsidf>
8112bebc:	800d883a 	mov	r6,r16
8112bec0:	880f883a 	mov	r7,r17
8112bec4:	1009883a 	mov	r4,r2
8112bec8:	180b883a 	mov	r5,r3
8112becc:	1121c800 	call	81121c80 <__muldf3>
8112bed0:	100d883a 	mov	r6,r2
8112bed4:	180f883a 	mov	r7,r3
8112bed8:	9009883a 	mov	r4,r18
8112bedc:	980b883a 	mov	r5,r19
8112bee0:	11223a00 	call	811223a0 <__subdf3>
8112bee4:	d9c00717 	ldw	r7,28(sp)
8112bee8:	1009883a 	mov	r4,r2
8112beec:	a8800c04 	addi	r2,r21,48
8112bef0:	38800005 	stb	r2,0(r7)
8112bef4:	3dc00044 	addi	r23,r7,1
8112bef8:	d9c00617 	ldw	r7,24(sp)
8112befc:	01800044 	movi	r6,1
8112bf00:	180b883a 	mov	r5,r3
8112bf04:	2005883a 	mov	r2,r4
8112bf08:	39803826 	beq	r7,r6,8112bfec <_dtoa_r+0x8fc>
8112bf0c:	000d883a 	mov	r6,zero
8112bf10:	01d00934 	movhi	r7,16420
8112bf14:	1121c800 	call	81121c80 <__muldf3>
8112bf18:	000d883a 	mov	r6,zero
8112bf1c:	000f883a 	mov	r7,zero
8112bf20:	1009883a 	mov	r4,r2
8112bf24:	180b883a 	mov	r5,r3
8112bf28:	1025883a 	mov	r18,r2
8112bf2c:	1827883a 	mov	r19,r3
8112bf30:	1137cb80 	call	81137cb8 <__eqdf2>
8112bf34:	103f9a26 	beq	r2,zero,8112bda0 <__reset+0xfb10bda0>
8112bf38:	d9c00617 	ldw	r7,24(sp)
8112bf3c:	d8c00717 	ldw	r3,28(sp)
8112bf40:	b829883a 	mov	r20,r23
8112bf44:	38bfffc4 	addi	r2,r7,-1
8112bf48:	18ad883a 	add	r22,r3,r2
8112bf4c:	00000a06 	br	8112bf78 <_dtoa_r+0x888>
8112bf50:	1121c800 	call	81121c80 <__muldf3>
8112bf54:	000d883a 	mov	r6,zero
8112bf58:	000f883a 	mov	r7,zero
8112bf5c:	1009883a 	mov	r4,r2
8112bf60:	180b883a 	mov	r5,r3
8112bf64:	1025883a 	mov	r18,r2
8112bf68:	1827883a 	mov	r19,r3
8112bf6c:	b829883a 	mov	r20,r23
8112bf70:	1137cb80 	call	81137cb8 <__eqdf2>
8112bf74:	103f8a26 	beq	r2,zero,8112bda0 <__reset+0xfb10bda0>
8112bf78:	800d883a 	mov	r6,r16
8112bf7c:	880f883a 	mov	r7,r17
8112bf80:	9009883a 	mov	r4,r18
8112bf84:	980b883a 	mov	r5,r19
8112bf88:	11373c80 	call	811373c8 <__divdf3>
8112bf8c:	180b883a 	mov	r5,r3
8112bf90:	1009883a 	mov	r4,r2
8112bf94:	1122ca40 	call	81122ca4 <__fixdfsi>
8112bf98:	1009883a 	mov	r4,r2
8112bf9c:	102b883a 	mov	r21,r2
8112bfa0:	1122d240 	call	81122d24 <__floatsidf>
8112bfa4:	800d883a 	mov	r6,r16
8112bfa8:	880f883a 	mov	r7,r17
8112bfac:	1009883a 	mov	r4,r2
8112bfb0:	180b883a 	mov	r5,r3
8112bfb4:	1121c800 	call	81121c80 <__muldf3>
8112bfb8:	100d883a 	mov	r6,r2
8112bfbc:	180f883a 	mov	r7,r3
8112bfc0:	9009883a 	mov	r4,r18
8112bfc4:	980b883a 	mov	r5,r19
8112bfc8:	11223a00 	call	811223a0 <__subdf3>
8112bfcc:	aa000c04 	addi	r8,r21,48
8112bfd0:	a2000005 	stb	r8,0(r20)
8112bfd4:	000d883a 	mov	r6,zero
8112bfd8:	01d00934 	movhi	r7,16420
8112bfdc:	1009883a 	mov	r4,r2
8112bfe0:	180b883a 	mov	r5,r3
8112bfe4:	a5c00044 	addi	r23,r20,1
8112bfe8:	b53fd91e 	bne	r22,r20,8112bf50 <__reset+0xfb10bf50>
8112bfec:	100d883a 	mov	r6,r2
8112bff0:	180f883a 	mov	r7,r3
8112bff4:	1009883a 	mov	r4,r2
8112bff8:	180b883a 	mov	r5,r3
8112bffc:	1136b140 	call	81136b14 <__adddf3>
8112c000:	100d883a 	mov	r6,r2
8112c004:	180f883a 	mov	r7,r3
8112c008:	8009883a 	mov	r4,r16
8112c00c:	880b883a 	mov	r5,r17
8112c010:	1027883a 	mov	r19,r2
8112c014:	1825883a 	mov	r18,r3
8112c018:	1137d400 	call	81137d40 <__ledf2>
8112c01c:	10000816 	blt	r2,zero,8112c040 <_dtoa_r+0x950>
8112c020:	980d883a 	mov	r6,r19
8112c024:	900f883a 	mov	r7,r18
8112c028:	8009883a 	mov	r4,r16
8112c02c:	880b883a 	mov	r5,r17
8112c030:	1137cb80 	call	81137cb8 <__eqdf2>
8112c034:	103f5a1e 	bne	r2,zero,8112bda0 <__reset+0xfb10bda0>
8112c038:	ad40004c 	andi	r21,r21,1
8112c03c:	a83f5826 	beq	r21,zero,8112bda0 <__reset+0xfb10bda0>
8112c040:	bd3fffc3 	ldbu	r20,-1(r23)
8112c044:	b8bfffc4 	addi	r2,r23,-1
8112c048:	1007883a 	mov	r3,r2
8112c04c:	01400e44 	movi	r5,57
8112c050:	d9800717 	ldw	r6,28(sp)
8112c054:	00000506 	br	8112c06c <_dtoa_r+0x97c>
8112c058:	18ffffc4 	addi	r3,r3,-1
8112c05c:	11824726 	beq	r2,r6,8112c97c <_dtoa_r+0x128c>
8112c060:	1d000003 	ldbu	r20,0(r3)
8112c064:	102f883a 	mov	r23,r2
8112c068:	10bfffc4 	addi	r2,r2,-1
8112c06c:	a1003fcc 	andi	r4,r20,255
8112c070:	2100201c 	xori	r4,r4,128
8112c074:	213fe004 	addi	r4,r4,-128
8112c078:	217ff726 	beq	r4,r5,8112c058 <__reset+0xfb10c058>
8112c07c:	a2000044 	addi	r8,r20,1
8112c080:	12000005 	stb	r8,0(r2)
8112c084:	003f4606 	br	8112bda0 <__reset+0xfb10bda0>
8112c088:	d9000b17 	ldw	r4,44(sp)
8112c08c:	2000c826 	beq	r4,zero,8112c3b0 <_dtoa_r+0xcc0>
8112c090:	d9800317 	ldw	r6,12(sp)
8112c094:	00c00044 	movi	r3,1
8112c098:	1980f90e 	bge	r3,r6,8112c480 <_dtoa_r+0xd90>
8112c09c:	d8800617 	ldw	r2,24(sp)
8112c0a0:	d8c00a17 	ldw	r3,40(sp)
8112c0a4:	157fffc4 	addi	r21,r2,-1
8112c0a8:	1d41f316 	blt	r3,r21,8112c878 <_dtoa_r+0x1188>
8112c0ac:	1d6bc83a 	sub	r21,r3,r21
8112c0b0:	d9c00617 	ldw	r7,24(sp)
8112c0b4:	3802aa16 	blt	r7,zero,8112cb60 <_dtoa_r+0x1470>
8112c0b8:	dd000817 	ldw	r20,32(sp)
8112c0bc:	d8800617 	ldw	r2,24(sp)
8112c0c0:	d8c00817 	ldw	r3,32(sp)
8112c0c4:	01400044 	movi	r5,1
8112c0c8:	e009883a 	mov	r4,fp
8112c0cc:	1887883a 	add	r3,r3,r2
8112c0d0:	d8c00815 	stw	r3,32(sp)
8112c0d4:	b0ad883a 	add	r22,r22,r2
8112c0d8:	112ec2c0 	call	8112ec2c <__i2b>
8112c0dc:	1023883a 	mov	r17,r2
8112c0e0:	a0000826 	beq	r20,zero,8112c104 <_dtoa_r+0xa14>
8112c0e4:	0580070e 	bge	zero,r22,8112c104 <_dtoa_r+0xa14>
8112c0e8:	a005883a 	mov	r2,r20
8112c0ec:	b500b916 	blt	r22,r20,8112c3d4 <_dtoa_r+0xce4>
8112c0f0:	d9000817 	ldw	r4,32(sp)
8112c0f4:	a0a9c83a 	sub	r20,r20,r2
8112c0f8:	b0adc83a 	sub	r22,r22,r2
8112c0fc:	2089c83a 	sub	r4,r4,r2
8112c100:	d9000815 	stw	r4,32(sp)
8112c104:	d9800a17 	ldw	r6,40(sp)
8112c108:	0181810e 	bge	zero,r6,8112c710 <_dtoa_r+0x1020>
8112c10c:	d9c00b17 	ldw	r7,44(sp)
8112c110:	3800b326 	beq	r7,zero,8112c3e0 <_dtoa_r+0xcf0>
8112c114:	a800b226 	beq	r21,zero,8112c3e0 <_dtoa_r+0xcf0>
8112c118:	880b883a 	mov	r5,r17
8112c11c:	a80d883a 	mov	r6,r21
8112c120:	e009883a 	mov	r4,fp
8112c124:	112ee700 	call	8112ee70 <__pow5mult>
8112c128:	d9800917 	ldw	r6,36(sp)
8112c12c:	100b883a 	mov	r5,r2
8112c130:	e009883a 	mov	r4,fp
8112c134:	1023883a 	mov	r17,r2
8112c138:	112ec700 	call	8112ec70 <__multiply>
8112c13c:	1021883a 	mov	r16,r2
8112c140:	d8800a17 	ldw	r2,40(sp)
8112c144:	d9400917 	ldw	r5,36(sp)
8112c148:	e009883a 	mov	r4,fp
8112c14c:	1545c83a 	sub	r2,r2,r21
8112c150:	d8800a15 	stw	r2,40(sp)
8112c154:	112e8b80 	call	8112e8b8 <_Bfree>
8112c158:	d8c00a17 	ldw	r3,40(sp)
8112c15c:	18009f1e 	bne	r3,zero,8112c3dc <_dtoa_r+0xcec>
8112c160:	05c00044 	movi	r23,1
8112c164:	e009883a 	mov	r4,fp
8112c168:	b80b883a 	mov	r5,r23
8112c16c:	112ec2c0 	call	8112ec2c <__i2b>
8112c170:	d9000d17 	ldw	r4,52(sp)
8112c174:	102b883a 	mov	r21,r2
8112c178:	2000ce26 	beq	r4,zero,8112c4b4 <_dtoa_r+0xdc4>
8112c17c:	200d883a 	mov	r6,r4
8112c180:	100b883a 	mov	r5,r2
8112c184:	e009883a 	mov	r4,fp
8112c188:	112ee700 	call	8112ee70 <__pow5mult>
8112c18c:	d9800317 	ldw	r6,12(sp)
8112c190:	102b883a 	mov	r21,r2
8112c194:	b981810e 	bge	r23,r6,8112c79c <_dtoa_r+0x10ac>
8112c198:	0027883a 	mov	r19,zero
8112c19c:	a8800417 	ldw	r2,16(r21)
8112c1a0:	05c00804 	movi	r23,32
8112c1a4:	10800104 	addi	r2,r2,4
8112c1a8:	1085883a 	add	r2,r2,r2
8112c1ac:	1085883a 	add	r2,r2,r2
8112c1b0:	a885883a 	add	r2,r21,r2
8112c1b4:	11000017 	ldw	r4,0(r2)
8112c1b8:	112eb140 	call	8112eb14 <__hi0bits>
8112c1bc:	b885c83a 	sub	r2,r23,r2
8112c1c0:	1585883a 	add	r2,r2,r22
8112c1c4:	108007cc 	andi	r2,r2,31
8112c1c8:	1000b326 	beq	r2,zero,8112c498 <_dtoa_r+0xda8>
8112c1cc:	00c00804 	movi	r3,32
8112c1d0:	1887c83a 	sub	r3,r3,r2
8112c1d4:	01000104 	movi	r4,4
8112c1d8:	20c2cd0e 	bge	r4,r3,8112cd10 <_dtoa_r+0x1620>
8112c1dc:	00c00704 	movi	r3,28
8112c1e0:	1885c83a 	sub	r2,r3,r2
8112c1e4:	d8c00817 	ldw	r3,32(sp)
8112c1e8:	a0a9883a 	add	r20,r20,r2
8112c1ec:	b0ad883a 	add	r22,r22,r2
8112c1f0:	1887883a 	add	r3,r3,r2
8112c1f4:	d8c00815 	stw	r3,32(sp)
8112c1f8:	d9800817 	ldw	r6,32(sp)
8112c1fc:	0180040e 	bge	zero,r6,8112c210 <_dtoa_r+0xb20>
8112c200:	800b883a 	mov	r5,r16
8112c204:	e009883a 	mov	r4,fp
8112c208:	112efb80 	call	8112efb8 <__lshift>
8112c20c:	1021883a 	mov	r16,r2
8112c210:	0580050e 	bge	zero,r22,8112c228 <_dtoa_r+0xb38>
8112c214:	a80b883a 	mov	r5,r21
8112c218:	b00d883a 	mov	r6,r22
8112c21c:	e009883a 	mov	r4,fp
8112c220:	112efb80 	call	8112efb8 <__lshift>
8112c224:	102b883a 	mov	r21,r2
8112c228:	d9c00e17 	ldw	r7,56(sp)
8112c22c:	3801211e 	bne	r7,zero,8112c6b4 <_dtoa_r+0xfc4>
8112c230:	d9800617 	ldw	r6,24(sp)
8112c234:	0181380e 	bge	zero,r6,8112c718 <_dtoa_r+0x1028>
8112c238:	d8c00b17 	ldw	r3,44(sp)
8112c23c:	1800ab1e 	bne	r3,zero,8112c4ec <_dtoa_r+0xdfc>
8112c240:	dc800717 	ldw	r18,28(sp)
8112c244:	dcc00617 	ldw	r19,24(sp)
8112c248:	9029883a 	mov	r20,r18
8112c24c:	00000206 	br	8112c258 <_dtoa_r+0xb68>
8112c250:	112e8e00 	call	8112e8e0 <__multadd>
8112c254:	1021883a 	mov	r16,r2
8112c258:	a80b883a 	mov	r5,r21
8112c25c:	8009883a 	mov	r4,r16
8112c260:	112b4e80 	call	8112b4e8 <quorem>
8112c264:	10800c04 	addi	r2,r2,48
8112c268:	90800005 	stb	r2,0(r18)
8112c26c:	94800044 	addi	r18,r18,1
8112c270:	9507c83a 	sub	r3,r18,r20
8112c274:	000f883a 	mov	r7,zero
8112c278:	01800284 	movi	r6,10
8112c27c:	800b883a 	mov	r5,r16
8112c280:	e009883a 	mov	r4,fp
8112c284:	1cfff216 	blt	r3,r19,8112c250 <__reset+0xfb10c250>
8112c288:	1011883a 	mov	r8,r2
8112c28c:	d8800617 	ldw	r2,24(sp)
8112c290:	0082370e 	bge	zero,r2,8112cb70 <_dtoa_r+0x1480>
8112c294:	d9000717 	ldw	r4,28(sp)
8112c298:	0025883a 	mov	r18,zero
8112c29c:	20af883a 	add	r23,r4,r2
8112c2a0:	01800044 	movi	r6,1
8112c2a4:	800b883a 	mov	r5,r16
8112c2a8:	e009883a 	mov	r4,fp
8112c2ac:	da001715 	stw	r8,92(sp)
8112c2b0:	112efb80 	call	8112efb8 <__lshift>
8112c2b4:	a80b883a 	mov	r5,r21
8112c2b8:	1009883a 	mov	r4,r2
8112c2bc:	d8800915 	stw	r2,36(sp)
8112c2c0:	112f1080 	call	8112f108 <__mcmp>
8112c2c4:	da001717 	ldw	r8,92(sp)
8112c2c8:	0081800e 	bge	zero,r2,8112c8cc <_dtoa_r+0x11dc>
8112c2cc:	b93fffc3 	ldbu	r4,-1(r23)
8112c2d0:	b8bfffc4 	addi	r2,r23,-1
8112c2d4:	1007883a 	mov	r3,r2
8112c2d8:	01800e44 	movi	r6,57
8112c2dc:	d9c00717 	ldw	r7,28(sp)
8112c2e0:	00000506 	br	8112c2f8 <_dtoa_r+0xc08>
8112c2e4:	18ffffc4 	addi	r3,r3,-1
8112c2e8:	11c12326 	beq	r2,r7,8112c778 <_dtoa_r+0x1088>
8112c2ec:	19000003 	ldbu	r4,0(r3)
8112c2f0:	102f883a 	mov	r23,r2
8112c2f4:	10bfffc4 	addi	r2,r2,-1
8112c2f8:	21403fcc 	andi	r5,r4,255
8112c2fc:	2940201c 	xori	r5,r5,128
8112c300:	297fe004 	addi	r5,r5,-128
8112c304:	29bff726 	beq	r5,r6,8112c2e4 <__reset+0xfb10c2e4>
8112c308:	21000044 	addi	r4,r4,1
8112c30c:	11000005 	stb	r4,0(r2)
8112c310:	a80b883a 	mov	r5,r21
8112c314:	e009883a 	mov	r4,fp
8112c318:	112e8b80 	call	8112e8b8 <_Bfree>
8112c31c:	883ea026 	beq	r17,zero,8112bda0 <__reset+0xfb10bda0>
8112c320:	90000426 	beq	r18,zero,8112c334 <_dtoa_r+0xc44>
8112c324:	94400326 	beq	r18,r17,8112c334 <_dtoa_r+0xc44>
8112c328:	900b883a 	mov	r5,r18
8112c32c:	e009883a 	mov	r4,fp
8112c330:	112e8b80 	call	8112e8b8 <_Bfree>
8112c334:	880b883a 	mov	r5,r17
8112c338:	e009883a 	mov	r4,fp
8112c33c:	112e8b80 	call	8112e8b8 <_Bfree>
8112c340:	003e9706 	br	8112bda0 <__reset+0xfb10bda0>
8112c344:	01800044 	movi	r6,1
8112c348:	d9800e15 	stw	r6,56(sp)
8112c34c:	003d9606 	br	8112b9a8 <__reset+0xfb10b9a8>
8112c350:	d8800817 	ldw	r2,32(sp)
8112c354:	d8c00517 	ldw	r3,20(sp)
8112c358:	d8000d15 	stw	zero,52(sp)
8112c35c:	10c5c83a 	sub	r2,r2,r3
8112c360:	00c9c83a 	sub	r4,zero,r3
8112c364:	d8800815 	stw	r2,32(sp)
8112c368:	d9000a15 	stw	r4,40(sp)
8112c36c:	003d9706 	br	8112b9cc <__reset+0xfb10b9cc>
8112c370:	05adc83a 	sub	r22,zero,r22
8112c374:	dd800815 	stw	r22,32(sp)
8112c378:	002d883a 	mov	r22,zero
8112c37c:	003d8e06 	br	8112b9b8 <__reset+0xfb10b9b8>
8112c380:	d9000517 	ldw	r4,20(sp)
8112c384:	1122d240 	call	81122d24 <__floatsidf>
8112c388:	100d883a 	mov	r6,r2
8112c38c:	180f883a 	mov	r7,r3
8112c390:	a009883a 	mov	r4,r20
8112c394:	880b883a 	mov	r5,r17
8112c398:	1137cb80 	call	81137cb8 <__eqdf2>
8112c39c:	103d7126 	beq	r2,zero,8112b964 <__reset+0xfb10b964>
8112c3a0:	d9c00517 	ldw	r7,20(sp)
8112c3a4:	39ffffc4 	addi	r7,r7,-1
8112c3a8:	d9c00515 	stw	r7,20(sp)
8112c3ac:	003d6d06 	br	8112b964 <__reset+0xfb10b964>
8112c3b0:	dd400a17 	ldw	r21,40(sp)
8112c3b4:	dd000817 	ldw	r20,32(sp)
8112c3b8:	0023883a 	mov	r17,zero
8112c3bc:	003f4806 	br	8112c0e0 <__reset+0xfb10c0e0>
8112c3c0:	10e3c83a 	sub	r17,r2,r3
8112c3c4:	9448983a 	sll	r4,r18,r17
8112c3c8:	003d3206 	br	8112b894 <__reset+0xfb10b894>
8112c3cc:	d8000e15 	stw	zero,56(sp)
8112c3d0:	003d7506 	br	8112b9a8 <__reset+0xfb10b9a8>
8112c3d4:	b005883a 	mov	r2,r22
8112c3d8:	003f4506 	br	8112c0f0 <__reset+0xfb10c0f0>
8112c3dc:	dc000915 	stw	r16,36(sp)
8112c3e0:	d9800a17 	ldw	r6,40(sp)
8112c3e4:	d9400917 	ldw	r5,36(sp)
8112c3e8:	e009883a 	mov	r4,fp
8112c3ec:	112ee700 	call	8112ee70 <__pow5mult>
8112c3f0:	1021883a 	mov	r16,r2
8112c3f4:	003f5a06 	br	8112c160 <__reset+0xfb10c160>
8112c3f8:	01c00044 	movi	r7,1
8112c3fc:	d9c00b15 	stw	r7,44(sp)
8112c400:	d8802217 	ldw	r2,136(sp)
8112c404:	0081280e 	bge	zero,r2,8112c8a8 <_dtoa_r+0x11b8>
8112c408:	100d883a 	mov	r6,r2
8112c40c:	1021883a 	mov	r16,r2
8112c410:	d8800c15 	stw	r2,48(sp)
8112c414:	d8800615 	stw	r2,24(sp)
8112c418:	003d8806 	br	8112ba3c <__reset+0xfb10ba3c>
8112c41c:	d8800617 	ldw	r2,24(sp)
8112c420:	00be9b16 	blt	zero,r2,8112be90 <__reset+0xfb10be90>
8112c424:	10010f1e 	bne	r2,zero,8112c864 <_dtoa_r+0x1174>
8112c428:	880b883a 	mov	r5,r17
8112c42c:	000d883a 	mov	r6,zero
8112c430:	01d00534 	movhi	r7,16404
8112c434:	8009883a 	mov	r4,r16
8112c438:	1121c800 	call	81121c80 <__muldf3>
8112c43c:	900d883a 	mov	r6,r18
8112c440:	980f883a 	mov	r7,r19
8112c444:	1009883a 	mov	r4,r2
8112c448:	180b883a 	mov	r5,r3
8112c44c:	1121ba40 	call	81121ba4 <__gedf2>
8112c450:	002b883a 	mov	r21,zero
8112c454:	0023883a 	mov	r17,zero
8112c458:	1000bf16 	blt	r2,zero,8112c758 <_dtoa_r+0x1068>
8112c45c:	d9802217 	ldw	r6,136(sp)
8112c460:	ddc00717 	ldw	r23,28(sp)
8112c464:	018c303a 	nor	r6,zero,r6
8112c468:	d9800515 	stw	r6,20(sp)
8112c46c:	a80b883a 	mov	r5,r21
8112c470:	e009883a 	mov	r4,fp
8112c474:	112e8b80 	call	8112e8b8 <_Bfree>
8112c478:	883e4926 	beq	r17,zero,8112bda0 <__reset+0xfb10bda0>
8112c47c:	003fad06 	br	8112c334 <__reset+0xfb10c334>
8112c480:	d9c01117 	ldw	r7,68(sp)
8112c484:	3801bc26 	beq	r7,zero,8112cb78 <_dtoa_r+0x1488>
8112c488:	10810cc4 	addi	r2,r2,1075
8112c48c:	dd400a17 	ldw	r21,40(sp)
8112c490:	dd000817 	ldw	r20,32(sp)
8112c494:	003f0a06 	br	8112c0c0 <__reset+0xfb10c0c0>
8112c498:	00800704 	movi	r2,28
8112c49c:	d9000817 	ldw	r4,32(sp)
8112c4a0:	a0a9883a 	add	r20,r20,r2
8112c4a4:	b0ad883a 	add	r22,r22,r2
8112c4a8:	2089883a 	add	r4,r4,r2
8112c4ac:	d9000815 	stw	r4,32(sp)
8112c4b0:	003f5106 	br	8112c1f8 <__reset+0xfb10c1f8>
8112c4b4:	d8c00317 	ldw	r3,12(sp)
8112c4b8:	b8c1fc0e 	bge	r23,r3,8112ccac <_dtoa_r+0x15bc>
8112c4bc:	0027883a 	mov	r19,zero
8112c4c0:	b805883a 	mov	r2,r23
8112c4c4:	003f3e06 	br	8112c1c0 <__reset+0xfb10c1c0>
8112c4c8:	880b883a 	mov	r5,r17
8112c4cc:	e009883a 	mov	r4,fp
8112c4d0:	000f883a 	mov	r7,zero
8112c4d4:	01800284 	movi	r6,10
8112c4d8:	112e8e00 	call	8112e8e0 <__multadd>
8112c4dc:	d9000c17 	ldw	r4,48(sp)
8112c4e0:	1023883a 	mov	r17,r2
8112c4e4:	0102040e 	bge	zero,r4,8112ccf8 <_dtoa_r+0x1608>
8112c4e8:	d9000615 	stw	r4,24(sp)
8112c4ec:	0500050e 	bge	zero,r20,8112c504 <_dtoa_r+0xe14>
8112c4f0:	880b883a 	mov	r5,r17
8112c4f4:	a00d883a 	mov	r6,r20
8112c4f8:	e009883a 	mov	r4,fp
8112c4fc:	112efb80 	call	8112efb8 <__lshift>
8112c500:	1023883a 	mov	r17,r2
8112c504:	9801241e 	bne	r19,zero,8112c998 <_dtoa_r+0x12a8>
8112c508:	8829883a 	mov	r20,r17
8112c50c:	d9000617 	ldw	r4,24(sp)
8112c510:	dcc00717 	ldw	r19,28(sp)
8112c514:	9480004c 	andi	r18,r18,1
8112c518:	20bfffc4 	addi	r2,r4,-1
8112c51c:	9885883a 	add	r2,r19,r2
8112c520:	d8800415 	stw	r2,16(sp)
8112c524:	dc800615 	stw	r18,24(sp)
8112c528:	a80b883a 	mov	r5,r21
8112c52c:	8009883a 	mov	r4,r16
8112c530:	112b4e80 	call	8112b4e8 <quorem>
8112c534:	880b883a 	mov	r5,r17
8112c538:	8009883a 	mov	r4,r16
8112c53c:	102f883a 	mov	r23,r2
8112c540:	112f1080 	call	8112f108 <__mcmp>
8112c544:	a80b883a 	mov	r5,r21
8112c548:	a00d883a 	mov	r6,r20
8112c54c:	e009883a 	mov	r4,fp
8112c550:	102d883a 	mov	r22,r2
8112c554:	112f1680 	call	8112f168 <__mdiff>
8112c558:	1007883a 	mov	r3,r2
8112c55c:	10800317 	ldw	r2,12(r2)
8112c560:	bc800c04 	addi	r18,r23,48
8112c564:	180b883a 	mov	r5,r3
8112c568:	10004e1e 	bne	r2,zero,8112c6a4 <_dtoa_r+0xfb4>
8112c56c:	8009883a 	mov	r4,r16
8112c570:	d8c01615 	stw	r3,88(sp)
8112c574:	112f1080 	call	8112f108 <__mcmp>
8112c578:	d8c01617 	ldw	r3,88(sp)
8112c57c:	e009883a 	mov	r4,fp
8112c580:	d8801615 	stw	r2,88(sp)
8112c584:	180b883a 	mov	r5,r3
8112c588:	112e8b80 	call	8112e8b8 <_Bfree>
8112c58c:	d8801617 	ldw	r2,88(sp)
8112c590:	1000041e 	bne	r2,zero,8112c5a4 <_dtoa_r+0xeb4>
8112c594:	d9800317 	ldw	r6,12(sp)
8112c598:	3000021e 	bne	r6,zero,8112c5a4 <_dtoa_r+0xeb4>
8112c59c:	d8c00617 	ldw	r3,24(sp)
8112c5a0:	18003726 	beq	r3,zero,8112c680 <_dtoa_r+0xf90>
8112c5a4:	b0002016 	blt	r22,zero,8112c628 <_dtoa_r+0xf38>
8112c5a8:	b000041e 	bne	r22,zero,8112c5bc <_dtoa_r+0xecc>
8112c5ac:	d9000317 	ldw	r4,12(sp)
8112c5b0:	2000021e 	bne	r4,zero,8112c5bc <_dtoa_r+0xecc>
8112c5b4:	d8c00617 	ldw	r3,24(sp)
8112c5b8:	18001b26 	beq	r3,zero,8112c628 <_dtoa_r+0xf38>
8112c5bc:	00810716 	blt	zero,r2,8112c9dc <_dtoa_r+0x12ec>
8112c5c0:	d8c00417 	ldw	r3,16(sp)
8112c5c4:	9d800044 	addi	r22,r19,1
8112c5c8:	9c800005 	stb	r18,0(r19)
8112c5cc:	b02f883a 	mov	r23,r22
8112c5d0:	98c10626 	beq	r19,r3,8112c9ec <_dtoa_r+0x12fc>
8112c5d4:	800b883a 	mov	r5,r16
8112c5d8:	000f883a 	mov	r7,zero
8112c5dc:	01800284 	movi	r6,10
8112c5e0:	e009883a 	mov	r4,fp
8112c5e4:	112e8e00 	call	8112e8e0 <__multadd>
8112c5e8:	1021883a 	mov	r16,r2
8112c5ec:	000f883a 	mov	r7,zero
8112c5f0:	01800284 	movi	r6,10
8112c5f4:	880b883a 	mov	r5,r17
8112c5f8:	e009883a 	mov	r4,fp
8112c5fc:	8d002526 	beq	r17,r20,8112c694 <_dtoa_r+0xfa4>
8112c600:	112e8e00 	call	8112e8e0 <__multadd>
8112c604:	a00b883a 	mov	r5,r20
8112c608:	000f883a 	mov	r7,zero
8112c60c:	01800284 	movi	r6,10
8112c610:	e009883a 	mov	r4,fp
8112c614:	1023883a 	mov	r17,r2
8112c618:	112e8e00 	call	8112e8e0 <__multadd>
8112c61c:	1029883a 	mov	r20,r2
8112c620:	b027883a 	mov	r19,r22
8112c624:	003fc006 	br	8112c528 <__reset+0xfb10c528>
8112c628:	9011883a 	mov	r8,r18
8112c62c:	00800e0e 	bge	zero,r2,8112c668 <_dtoa_r+0xf78>
8112c630:	800b883a 	mov	r5,r16
8112c634:	01800044 	movi	r6,1
8112c638:	e009883a 	mov	r4,fp
8112c63c:	da001715 	stw	r8,92(sp)
8112c640:	112efb80 	call	8112efb8 <__lshift>
8112c644:	a80b883a 	mov	r5,r21
8112c648:	1009883a 	mov	r4,r2
8112c64c:	1021883a 	mov	r16,r2
8112c650:	112f1080 	call	8112f108 <__mcmp>
8112c654:	da001717 	ldw	r8,92(sp)
8112c658:	0081960e 	bge	zero,r2,8112ccb4 <_dtoa_r+0x15c4>
8112c65c:	00800e44 	movi	r2,57
8112c660:	40817026 	beq	r8,r2,8112cc24 <_dtoa_r+0x1534>
8112c664:	ba000c44 	addi	r8,r23,49
8112c668:	8825883a 	mov	r18,r17
8112c66c:	9dc00044 	addi	r23,r19,1
8112c670:	9a000005 	stb	r8,0(r19)
8112c674:	a023883a 	mov	r17,r20
8112c678:	dc000915 	stw	r16,36(sp)
8112c67c:	003f2406 	br	8112c310 <__reset+0xfb10c310>
8112c680:	00800e44 	movi	r2,57
8112c684:	9011883a 	mov	r8,r18
8112c688:	90816626 	beq	r18,r2,8112cc24 <_dtoa_r+0x1534>
8112c68c:	05bff516 	blt	zero,r22,8112c664 <__reset+0xfb10c664>
8112c690:	003ff506 	br	8112c668 <__reset+0xfb10c668>
8112c694:	112e8e00 	call	8112e8e0 <__multadd>
8112c698:	1023883a 	mov	r17,r2
8112c69c:	1029883a 	mov	r20,r2
8112c6a0:	003fdf06 	br	8112c620 <__reset+0xfb10c620>
8112c6a4:	e009883a 	mov	r4,fp
8112c6a8:	112e8b80 	call	8112e8b8 <_Bfree>
8112c6ac:	00800044 	movi	r2,1
8112c6b0:	003fbc06 	br	8112c5a4 <__reset+0xfb10c5a4>
8112c6b4:	a80b883a 	mov	r5,r21
8112c6b8:	8009883a 	mov	r4,r16
8112c6bc:	112f1080 	call	8112f108 <__mcmp>
8112c6c0:	103edb0e 	bge	r2,zero,8112c230 <__reset+0xfb10c230>
8112c6c4:	800b883a 	mov	r5,r16
8112c6c8:	000f883a 	mov	r7,zero
8112c6cc:	01800284 	movi	r6,10
8112c6d0:	e009883a 	mov	r4,fp
8112c6d4:	112e8e00 	call	8112e8e0 <__multadd>
8112c6d8:	1021883a 	mov	r16,r2
8112c6dc:	d8800517 	ldw	r2,20(sp)
8112c6e0:	d8c00b17 	ldw	r3,44(sp)
8112c6e4:	10bfffc4 	addi	r2,r2,-1
8112c6e8:	d8800515 	stw	r2,20(sp)
8112c6ec:	183f761e 	bne	r3,zero,8112c4c8 <__reset+0xfb10c4c8>
8112c6f0:	d9000c17 	ldw	r4,48(sp)
8112c6f4:	0101730e 	bge	zero,r4,8112ccc4 <_dtoa_r+0x15d4>
8112c6f8:	d9000615 	stw	r4,24(sp)
8112c6fc:	003ed006 	br	8112c240 <__reset+0xfb10c240>
8112c700:	00800084 	movi	r2,2
8112c704:	3081861e 	bne	r6,r2,8112cd20 <_dtoa_r+0x1630>
8112c708:	d8000b15 	stw	zero,44(sp)
8112c70c:	003f3c06 	br	8112c400 <__reset+0xfb10c400>
8112c710:	dc000917 	ldw	r16,36(sp)
8112c714:	003e9206 	br	8112c160 <__reset+0xfb10c160>
8112c718:	d9c00317 	ldw	r7,12(sp)
8112c71c:	00800084 	movi	r2,2
8112c720:	11fec50e 	bge	r2,r7,8112c238 <__reset+0xfb10c238>
8112c724:	d9000617 	ldw	r4,24(sp)
8112c728:	20013c1e 	bne	r4,zero,8112cc1c <_dtoa_r+0x152c>
8112c72c:	a80b883a 	mov	r5,r21
8112c730:	000f883a 	mov	r7,zero
8112c734:	01800144 	movi	r6,5
8112c738:	e009883a 	mov	r4,fp
8112c73c:	112e8e00 	call	8112e8e0 <__multadd>
8112c740:	100b883a 	mov	r5,r2
8112c744:	8009883a 	mov	r4,r16
8112c748:	102b883a 	mov	r21,r2
8112c74c:	112f1080 	call	8112f108 <__mcmp>
8112c750:	dc000915 	stw	r16,36(sp)
8112c754:	00bf410e 	bge	zero,r2,8112c45c <__reset+0xfb10c45c>
8112c758:	d9c00717 	ldw	r7,28(sp)
8112c75c:	00800c44 	movi	r2,49
8112c760:	38800005 	stb	r2,0(r7)
8112c764:	d8800517 	ldw	r2,20(sp)
8112c768:	3dc00044 	addi	r23,r7,1
8112c76c:	10800044 	addi	r2,r2,1
8112c770:	d8800515 	stw	r2,20(sp)
8112c774:	003f3d06 	br	8112c46c <__reset+0xfb10c46c>
8112c778:	d9800517 	ldw	r6,20(sp)
8112c77c:	d9c00717 	ldw	r7,28(sp)
8112c780:	00800c44 	movi	r2,49
8112c784:	31800044 	addi	r6,r6,1
8112c788:	d9800515 	stw	r6,20(sp)
8112c78c:	38800005 	stb	r2,0(r7)
8112c790:	003edf06 	br	8112c310 <__reset+0xfb10c310>
8112c794:	d8000b15 	stw	zero,44(sp)
8112c798:	003c9f06 	br	8112ba18 <__reset+0xfb10ba18>
8112c79c:	903e7e1e 	bne	r18,zero,8112c198 <__reset+0xfb10c198>
8112c7a0:	00800434 	movhi	r2,16
8112c7a4:	10bfffc4 	addi	r2,r2,-1
8112c7a8:	9884703a 	and	r2,r19,r2
8112c7ac:	1000ea1e 	bne	r2,zero,8112cb58 <_dtoa_r+0x1468>
8112c7b0:	9cdffc2c 	andhi	r19,r19,32752
8112c7b4:	9800e826 	beq	r19,zero,8112cb58 <_dtoa_r+0x1468>
8112c7b8:	d9c00817 	ldw	r7,32(sp)
8112c7bc:	b5800044 	addi	r22,r22,1
8112c7c0:	04c00044 	movi	r19,1
8112c7c4:	39c00044 	addi	r7,r7,1
8112c7c8:	d9c00815 	stw	r7,32(sp)
8112c7cc:	d8800d17 	ldw	r2,52(sp)
8112c7d0:	103e721e 	bne	r2,zero,8112c19c <__reset+0xfb10c19c>
8112c7d4:	00800044 	movi	r2,1
8112c7d8:	003e7906 	br	8112c1c0 <__reset+0xfb10c1c0>
8112c7dc:	8009883a 	mov	r4,r16
8112c7e0:	1122d240 	call	81122d24 <__floatsidf>
8112c7e4:	d9800f17 	ldw	r6,60(sp)
8112c7e8:	d9c01017 	ldw	r7,64(sp)
8112c7ec:	1009883a 	mov	r4,r2
8112c7f0:	180b883a 	mov	r5,r3
8112c7f4:	1121c800 	call	81121c80 <__muldf3>
8112c7f8:	000d883a 	mov	r6,zero
8112c7fc:	01d00734 	movhi	r7,16412
8112c800:	1009883a 	mov	r4,r2
8112c804:	180b883a 	mov	r5,r3
8112c808:	1136b140 	call	81136b14 <__adddf3>
8112c80c:	047f3034 	movhi	r17,64704
8112c810:	1021883a 	mov	r16,r2
8112c814:	1c63883a 	add	r17,r3,r17
8112c818:	d9000f17 	ldw	r4,60(sp)
8112c81c:	d9401017 	ldw	r5,64(sp)
8112c820:	000d883a 	mov	r6,zero
8112c824:	01d00534 	movhi	r7,16404
8112c828:	11223a00 	call	811223a0 <__subdf3>
8112c82c:	800d883a 	mov	r6,r16
8112c830:	880f883a 	mov	r7,r17
8112c834:	1009883a 	mov	r4,r2
8112c838:	180b883a 	mov	r5,r3
8112c83c:	102b883a 	mov	r21,r2
8112c840:	1829883a 	mov	r20,r3
8112c844:	1121ba40 	call	81121ba4 <__gedf2>
8112c848:	00806c16 	blt	zero,r2,8112c9fc <_dtoa_r+0x130c>
8112c84c:	89e0003c 	xorhi	r7,r17,32768
8112c850:	800d883a 	mov	r6,r16
8112c854:	a809883a 	mov	r4,r21
8112c858:	a00b883a 	mov	r5,r20
8112c85c:	1137d400 	call	81137d40 <__ledf2>
8112c860:	103d7e0e 	bge	r2,zero,8112be5c <__reset+0xfb10be5c>
8112c864:	002b883a 	mov	r21,zero
8112c868:	0023883a 	mov	r17,zero
8112c86c:	003efb06 	br	8112c45c <__reset+0xfb10c45c>
8112c870:	d8800717 	ldw	r2,28(sp)
8112c874:	003bd006 	br	8112b7b8 <__reset+0xfb10b7b8>
8112c878:	d9000a17 	ldw	r4,40(sp)
8112c87c:	d9800d17 	ldw	r6,52(sp)
8112c880:	dd400a15 	stw	r21,40(sp)
8112c884:	a905c83a 	sub	r2,r21,r4
8112c888:	308d883a 	add	r6,r6,r2
8112c88c:	d9800d15 	stw	r6,52(sp)
8112c890:	002b883a 	mov	r21,zero
8112c894:	003e0606 	br	8112c0b0 <__reset+0xfb10c0b0>
8112c898:	9023883a 	mov	r17,r18
8112c89c:	9829883a 	mov	r20,r19
8112c8a0:	04000084 	movi	r16,2
8112c8a4:	003c9206 	br	8112baf0 <__reset+0xfb10baf0>
8112c8a8:	04000044 	movi	r16,1
8112c8ac:	dc000c15 	stw	r16,48(sp)
8112c8b0:	dc000615 	stw	r16,24(sp)
8112c8b4:	dc002215 	stw	r16,136(sp)
8112c8b8:	e0001115 	stw	zero,68(fp)
8112c8bc:	000b883a 	mov	r5,zero
8112c8c0:	003c6906 	br	8112ba68 <__reset+0xfb10ba68>
8112c8c4:	3021883a 	mov	r16,r6
8112c8c8:	003ffb06 	br	8112c8b8 <__reset+0xfb10c8b8>
8112c8cc:	1000021e 	bne	r2,zero,8112c8d8 <_dtoa_r+0x11e8>
8112c8d0:	4200004c 	andi	r8,r8,1
8112c8d4:	403e7d1e 	bne	r8,zero,8112c2cc <__reset+0xfb10c2cc>
8112c8d8:	01000c04 	movi	r4,48
8112c8dc:	00000106 	br	8112c8e4 <_dtoa_r+0x11f4>
8112c8e0:	102f883a 	mov	r23,r2
8112c8e4:	b8bfffc4 	addi	r2,r23,-1
8112c8e8:	10c00007 	ldb	r3,0(r2)
8112c8ec:	193ffc26 	beq	r3,r4,8112c8e0 <__reset+0xfb10c8e0>
8112c8f0:	003e8706 	br	8112c310 <__reset+0xfb10c310>
8112c8f4:	d8800517 	ldw	r2,20(sp)
8112c8f8:	00a3c83a 	sub	r17,zero,r2
8112c8fc:	8800a426 	beq	r17,zero,8112cb90 <_dtoa_r+0x14a0>
8112c900:	888003cc 	andi	r2,r17,15
8112c904:	100490fa 	slli	r2,r2,3
8112c908:	00e04574 	movhi	r3,33045
8112c90c:	18c9d104 	addi	r3,r3,10052
8112c910:	1885883a 	add	r2,r3,r2
8112c914:	11800017 	ldw	r6,0(r2)
8112c918:	11c00117 	ldw	r7,4(r2)
8112c91c:	9009883a 	mov	r4,r18
8112c920:	980b883a 	mov	r5,r19
8112c924:	8823d13a 	srai	r17,r17,4
8112c928:	1121c800 	call	81121c80 <__muldf3>
8112c92c:	d8800f15 	stw	r2,60(sp)
8112c930:	d8c01015 	stw	r3,64(sp)
8112c934:	8800e826 	beq	r17,zero,8112ccd8 <_dtoa_r+0x15e8>
8112c938:	05204574 	movhi	r20,33045
8112c93c:	a509c704 	addi	r20,r20,10012
8112c940:	04000084 	movi	r16,2
8112c944:	8980004c 	andi	r6,r17,1
8112c948:	1009883a 	mov	r4,r2
8112c94c:	8823d07a 	srai	r17,r17,1
8112c950:	180b883a 	mov	r5,r3
8112c954:	30000426 	beq	r6,zero,8112c968 <_dtoa_r+0x1278>
8112c958:	a1800017 	ldw	r6,0(r20)
8112c95c:	a1c00117 	ldw	r7,4(r20)
8112c960:	84000044 	addi	r16,r16,1
8112c964:	1121c800 	call	81121c80 <__muldf3>
8112c968:	a5000204 	addi	r20,r20,8
8112c96c:	883ff51e 	bne	r17,zero,8112c944 <__reset+0xfb10c944>
8112c970:	d8800f15 	stw	r2,60(sp)
8112c974:	d8c01015 	stw	r3,64(sp)
8112c978:	003c7606 	br	8112bb54 <__reset+0xfb10bb54>
8112c97c:	00c00c04 	movi	r3,48
8112c980:	10c00005 	stb	r3,0(r2)
8112c984:	d8c00517 	ldw	r3,20(sp)
8112c988:	bd3fffc3 	ldbu	r20,-1(r23)
8112c98c:	18c00044 	addi	r3,r3,1
8112c990:	d8c00515 	stw	r3,20(sp)
8112c994:	003db906 	br	8112c07c <__reset+0xfb10c07c>
8112c998:	89400117 	ldw	r5,4(r17)
8112c99c:	e009883a 	mov	r4,fp
8112c9a0:	112e8080 	call	8112e808 <_Balloc>
8112c9a4:	89800417 	ldw	r6,16(r17)
8112c9a8:	89400304 	addi	r5,r17,12
8112c9ac:	11000304 	addi	r4,r2,12
8112c9b0:	31800084 	addi	r6,r6,2
8112c9b4:	318d883a 	add	r6,r6,r6
8112c9b8:	318d883a 	add	r6,r6,r6
8112c9bc:	1027883a 	mov	r19,r2
8112c9c0:	11243500 	call	81124350 <memcpy>
8112c9c4:	01800044 	movi	r6,1
8112c9c8:	980b883a 	mov	r5,r19
8112c9cc:	e009883a 	mov	r4,fp
8112c9d0:	112efb80 	call	8112efb8 <__lshift>
8112c9d4:	1029883a 	mov	r20,r2
8112c9d8:	003ecc06 	br	8112c50c <__reset+0xfb10c50c>
8112c9dc:	00800e44 	movi	r2,57
8112c9e0:	90809026 	beq	r18,r2,8112cc24 <_dtoa_r+0x1534>
8112c9e4:	92000044 	addi	r8,r18,1
8112c9e8:	003f1f06 	br	8112c668 <__reset+0xfb10c668>
8112c9ec:	9011883a 	mov	r8,r18
8112c9f0:	8825883a 	mov	r18,r17
8112c9f4:	a023883a 	mov	r17,r20
8112c9f8:	003e2906 	br	8112c2a0 <__reset+0xfb10c2a0>
8112c9fc:	002b883a 	mov	r21,zero
8112ca00:	0023883a 	mov	r17,zero
8112ca04:	003f5406 	br	8112c758 <__reset+0xfb10c758>
8112ca08:	61bfffc4 	addi	r6,r12,-1
8112ca0c:	300490fa 	slli	r2,r6,3
8112ca10:	00e04574 	movhi	r3,33045
8112ca14:	18c9d104 	addi	r3,r3,10052
8112ca18:	1885883a 	add	r2,r3,r2
8112ca1c:	11000017 	ldw	r4,0(r2)
8112ca20:	11400117 	ldw	r5,4(r2)
8112ca24:	d8800717 	ldw	r2,28(sp)
8112ca28:	880f883a 	mov	r7,r17
8112ca2c:	d9801215 	stw	r6,72(sp)
8112ca30:	800d883a 	mov	r6,r16
8112ca34:	db001615 	stw	r12,88(sp)
8112ca38:	15c00044 	addi	r23,r2,1
8112ca3c:	1121c800 	call	81121c80 <__muldf3>
8112ca40:	d9401017 	ldw	r5,64(sp)
8112ca44:	d9000f17 	ldw	r4,60(sp)
8112ca48:	d8c01515 	stw	r3,84(sp)
8112ca4c:	d8801415 	stw	r2,80(sp)
8112ca50:	1122ca40 	call	81122ca4 <__fixdfsi>
8112ca54:	1009883a 	mov	r4,r2
8112ca58:	1021883a 	mov	r16,r2
8112ca5c:	1122d240 	call	81122d24 <__floatsidf>
8112ca60:	d9000f17 	ldw	r4,60(sp)
8112ca64:	d9401017 	ldw	r5,64(sp)
8112ca68:	100d883a 	mov	r6,r2
8112ca6c:	180f883a 	mov	r7,r3
8112ca70:	11223a00 	call	811223a0 <__subdf3>
8112ca74:	1829883a 	mov	r20,r3
8112ca78:	d8c00717 	ldw	r3,28(sp)
8112ca7c:	84000c04 	addi	r16,r16,48
8112ca80:	1023883a 	mov	r17,r2
8112ca84:	1c000005 	stb	r16,0(r3)
8112ca88:	db001617 	ldw	r12,88(sp)
8112ca8c:	00800044 	movi	r2,1
8112ca90:	60802226 	beq	r12,r2,8112cb1c <_dtoa_r+0x142c>
8112ca94:	d9c00717 	ldw	r7,28(sp)
8112ca98:	8805883a 	mov	r2,r17
8112ca9c:	b82b883a 	mov	r21,r23
8112caa0:	3b19883a 	add	r12,r7,r12
8112caa4:	6023883a 	mov	r17,r12
8112caa8:	a007883a 	mov	r3,r20
8112caac:	dc800f15 	stw	r18,60(sp)
8112cab0:	000d883a 	mov	r6,zero
8112cab4:	01d00934 	movhi	r7,16420
8112cab8:	1009883a 	mov	r4,r2
8112cabc:	180b883a 	mov	r5,r3
8112cac0:	1121c800 	call	81121c80 <__muldf3>
8112cac4:	180b883a 	mov	r5,r3
8112cac8:	1009883a 	mov	r4,r2
8112cacc:	1829883a 	mov	r20,r3
8112cad0:	1025883a 	mov	r18,r2
8112cad4:	1122ca40 	call	81122ca4 <__fixdfsi>
8112cad8:	1009883a 	mov	r4,r2
8112cadc:	1021883a 	mov	r16,r2
8112cae0:	1122d240 	call	81122d24 <__floatsidf>
8112cae4:	100d883a 	mov	r6,r2
8112cae8:	180f883a 	mov	r7,r3
8112caec:	9009883a 	mov	r4,r18
8112caf0:	a00b883a 	mov	r5,r20
8112caf4:	84000c04 	addi	r16,r16,48
8112caf8:	11223a00 	call	811223a0 <__subdf3>
8112cafc:	ad400044 	addi	r21,r21,1
8112cb00:	ac3fffc5 	stb	r16,-1(r21)
8112cb04:	ac7fea1e 	bne	r21,r17,8112cab0 <__reset+0xfb10cab0>
8112cb08:	1023883a 	mov	r17,r2
8112cb0c:	d8801217 	ldw	r2,72(sp)
8112cb10:	dc800f17 	ldw	r18,60(sp)
8112cb14:	1829883a 	mov	r20,r3
8112cb18:	b8af883a 	add	r23,r23,r2
8112cb1c:	d9001417 	ldw	r4,80(sp)
8112cb20:	d9401517 	ldw	r5,84(sp)
8112cb24:	000d883a 	mov	r6,zero
8112cb28:	01cff834 	movhi	r7,16352
8112cb2c:	1136b140 	call	81136b14 <__adddf3>
8112cb30:	880d883a 	mov	r6,r17
8112cb34:	a00f883a 	mov	r7,r20
8112cb38:	1009883a 	mov	r4,r2
8112cb3c:	180b883a 	mov	r5,r3
8112cb40:	1137d400 	call	81137d40 <__ledf2>
8112cb44:	10003e0e 	bge	r2,zero,8112cc40 <_dtoa_r+0x1550>
8112cb48:	d9001317 	ldw	r4,76(sp)
8112cb4c:	bd3fffc3 	ldbu	r20,-1(r23)
8112cb50:	d9000515 	stw	r4,20(sp)
8112cb54:	003d3b06 	br	8112c044 <__reset+0xfb10c044>
8112cb58:	0027883a 	mov	r19,zero
8112cb5c:	003f1b06 	br	8112c7cc <__reset+0xfb10c7cc>
8112cb60:	d8800817 	ldw	r2,32(sp)
8112cb64:	11e9c83a 	sub	r20,r2,r7
8112cb68:	0005883a 	mov	r2,zero
8112cb6c:	003d5406 	br	8112c0c0 <__reset+0xfb10c0c0>
8112cb70:	00800044 	movi	r2,1
8112cb74:	003dc706 	br	8112c294 <__reset+0xfb10c294>
8112cb78:	d8c00217 	ldw	r3,8(sp)
8112cb7c:	00800d84 	movi	r2,54
8112cb80:	dd400a17 	ldw	r21,40(sp)
8112cb84:	10c5c83a 	sub	r2,r2,r3
8112cb88:	dd000817 	ldw	r20,32(sp)
8112cb8c:	003d4c06 	br	8112c0c0 <__reset+0xfb10c0c0>
8112cb90:	dc800f15 	stw	r18,60(sp)
8112cb94:	dcc01015 	stw	r19,64(sp)
8112cb98:	04000084 	movi	r16,2
8112cb9c:	003bed06 	br	8112bb54 <__reset+0xfb10bb54>
8112cba0:	d9000617 	ldw	r4,24(sp)
8112cba4:	203f0d26 	beq	r4,zero,8112c7dc <__reset+0xfb10c7dc>
8112cba8:	d9800c17 	ldw	r6,48(sp)
8112cbac:	01bcab0e 	bge	zero,r6,8112be5c <__reset+0xfb10be5c>
8112cbb0:	d9401017 	ldw	r5,64(sp)
8112cbb4:	d9000f17 	ldw	r4,60(sp)
8112cbb8:	000d883a 	mov	r6,zero
8112cbbc:	01d00934 	movhi	r7,16420
8112cbc0:	1121c800 	call	81121c80 <__muldf3>
8112cbc4:	81000044 	addi	r4,r16,1
8112cbc8:	d8800f15 	stw	r2,60(sp)
8112cbcc:	d8c01015 	stw	r3,64(sp)
8112cbd0:	1122d240 	call	81122d24 <__floatsidf>
8112cbd4:	d9800f17 	ldw	r6,60(sp)
8112cbd8:	d9c01017 	ldw	r7,64(sp)
8112cbdc:	1009883a 	mov	r4,r2
8112cbe0:	180b883a 	mov	r5,r3
8112cbe4:	1121c800 	call	81121c80 <__muldf3>
8112cbe8:	01d00734 	movhi	r7,16412
8112cbec:	000d883a 	mov	r6,zero
8112cbf0:	1009883a 	mov	r4,r2
8112cbf4:	180b883a 	mov	r5,r3
8112cbf8:	1136b140 	call	81136b14 <__adddf3>
8112cbfc:	d9c00517 	ldw	r7,20(sp)
8112cc00:	047f3034 	movhi	r17,64704
8112cc04:	1021883a 	mov	r16,r2
8112cc08:	39ffffc4 	addi	r7,r7,-1
8112cc0c:	d9c01315 	stw	r7,76(sp)
8112cc10:	1c63883a 	add	r17,r3,r17
8112cc14:	db000c17 	ldw	r12,48(sp)
8112cc18:	003bea06 	br	8112bbc4 <__reset+0xfb10bbc4>
8112cc1c:	dc000915 	stw	r16,36(sp)
8112cc20:	003e0e06 	br	8112c45c <__reset+0xfb10c45c>
8112cc24:	01000e44 	movi	r4,57
8112cc28:	8825883a 	mov	r18,r17
8112cc2c:	9dc00044 	addi	r23,r19,1
8112cc30:	99000005 	stb	r4,0(r19)
8112cc34:	a023883a 	mov	r17,r20
8112cc38:	dc000915 	stw	r16,36(sp)
8112cc3c:	003da406 	br	8112c2d0 <__reset+0xfb10c2d0>
8112cc40:	d9801417 	ldw	r6,80(sp)
8112cc44:	d9c01517 	ldw	r7,84(sp)
8112cc48:	0009883a 	mov	r4,zero
8112cc4c:	014ff834 	movhi	r5,16352
8112cc50:	11223a00 	call	811223a0 <__subdf3>
8112cc54:	880d883a 	mov	r6,r17
8112cc58:	a00f883a 	mov	r7,r20
8112cc5c:	1009883a 	mov	r4,r2
8112cc60:	180b883a 	mov	r5,r3
8112cc64:	1121ba40 	call	81121ba4 <__gedf2>
8112cc68:	00bc7c0e 	bge	zero,r2,8112be5c <__reset+0xfb10be5c>
8112cc6c:	01000c04 	movi	r4,48
8112cc70:	00000106 	br	8112cc78 <_dtoa_r+0x1588>
8112cc74:	102f883a 	mov	r23,r2
8112cc78:	b8bfffc4 	addi	r2,r23,-1
8112cc7c:	10c00007 	ldb	r3,0(r2)
8112cc80:	193ffc26 	beq	r3,r4,8112cc74 <__reset+0xfb10cc74>
8112cc84:	d9801317 	ldw	r6,76(sp)
8112cc88:	d9800515 	stw	r6,20(sp)
8112cc8c:	003c4406 	br	8112bda0 <__reset+0xfb10bda0>
8112cc90:	d9801317 	ldw	r6,76(sp)
8112cc94:	d9800515 	stw	r6,20(sp)
8112cc98:	003cea06 	br	8112c044 <__reset+0xfb10c044>
8112cc9c:	dd800f17 	ldw	r22,60(sp)
8112cca0:	dcc01017 	ldw	r19,64(sp)
8112cca4:	dc801217 	ldw	r18,72(sp)
8112cca8:	003c6c06 	br	8112be5c <__reset+0xfb10be5c>
8112ccac:	903e031e 	bne	r18,zero,8112c4bc <__reset+0xfb10c4bc>
8112ccb0:	003ebb06 	br	8112c7a0 <__reset+0xfb10c7a0>
8112ccb4:	103e6c1e 	bne	r2,zero,8112c668 <__reset+0xfb10c668>
8112ccb8:	4080004c 	andi	r2,r8,1
8112ccbc:	103e6a26 	beq	r2,zero,8112c668 <__reset+0xfb10c668>
8112ccc0:	003e6606 	br	8112c65c <__reset+0xfb10c65c>
8112ccc4:	d8c00317 	ldw	r3,12(sp)
8112ccc8:	00800084 	movi	r2,2
8112cccc:	10c02916 	blt	r2,r3,8112cd74 <_dtoa_r+0x1684>
8112ccd0:	d9000c17 	ldw	r4,48(sp)
8112ccd4:	003e8806 	br	8112c6f8 <__reset+0xfb10c6f8>
8112ccd8:	04000084 	movi	r16,2
8112ccdc:	003b9d06 	br	8112bb54 <__reset+0xfb10bb54>
8112cce0:	d9001317 	ldw	r4,76(sp)
8112cce4:	d9000515 	stw	r4,20(sp)
8112cce8:	003cd606 	br	8112c044 <__reset+0xfb10c044>
8112ccec:	d8801317 	ldw	r2,76(sp)
8112ccf0:	d8800515 	stw	r2,20(sp)
8112ccf4:	003c2a06 	br	8112bda0 <__reset+0xfb10bda0>
8112ccf8:	d9800317 	ldw	r6,12(sp)
8112ccfc:	00800084 	movi	r2,2
8112cd00:	11801516 	blt	r2,r6,8112cd58 <_dtoa_r+0x1668>
8112cd04:	d9c00c17 	ldw	r7,48(sp)
8112cd08:	d9c00615 	stw	r7,24(sp)
8112cd0c:	003df706 	br	8112c4ec <__reset+0xfb10c4ec>
8112cd10:	193d3926 	beq	r3,r4,8112c1f8 <__reset+0xfb10c1f8>
8112cd14:	00c00f04 	movi	r3,60
8112cd18:	1885c83a 	sub	r2,r3,r2
8112cd1c:	003ddf06 	br	8112c49c <__reset+0xfb10c49c>
8112cd20:	e009883a 	mov	r4,fp
8112cd24:	e0001115 	stw	zero,68(fp)
8112cd28:	000b883a 	mov	r5,zero
8112cd2c:	112e8080 	call	8112e808 <_Balloc>
8112cd30:	d8800715 	stw	r2,28(sp)
8112cd34:	d8c00717 	ldw	r3,28(sp)
8112cd38:	00bfffc4 	movi	r2,-1
8112cd3c:	01000044 	movi	r4,1
8112cd40:	d8800c15 	stw	r2,48(sp)
8112cd44:	e0c01015 	stw	r3,64(fp)
8112cd48:	d9000b15 	stw	r4,44(sp)
8112cd4c:	d8800615 	stw	r2,24(sp)
8112cd50:	d8002215 	stw	zero,136(sp)
8112cd54:	003c4106 	br	8112be5c <__reset+0xfb10be5c>
8112cd58:	d8c00c17 	ldw	r3,48(sp)
8112cd5c:	d8c00615 	stw	r3,24(sp)
8112cd60:	003e7006 	br	8112c724 <__reset+0xfb10c724>
8112cd64:	04400044 	movi	r17,1
8112cd68:	003b2006 	br	8112b9ec <__reset+0xfb10b9ec>
8112cd6c:	000b883a 	mov	r5,zero
8112cd70:	003b3d06 	br	8112ba68 <__reset+0xfb10ba68>
8112cd74:	d8800c17 	ldw	r2,48(sp)
8112cd78:	d8800615 	stw	r2,24(sp)
8112cd7c:	003e6906 	br	8112c724 <__reset+0xfb10c724>

8112cd80 <__sflush_r>:
8112cd80:	defffb04 	addi	sp,sp,-20
8112cd84:	de00012e 	bgeu	sp,et,8112cd8c <__sflush_r+0xc>
8112cd88:	003b68fa 	trap	3
8112cd8c:	2880030b 	ldhu	r2,12(r5)
8112cd90:	dcc00315 	stw	r19,12(sp)
8112cd94:	dc400115 	stw	r17,4(sp)
8112cd98:	dfc00415 	stw	ra,16(sp)
8112cd9c:	dc800215 	stw	r18,8(sp)
8112cda0:	dc000015 	stw	r16,0(sp)
8112cda4:	10c0020c 	andi	r3,r2,8
8112cda8:	2823883a 	mov	r17,r5
8112cdac:	2027883a 	mov	r19,r4
8112cdb0:	1800311e 	bne	r3,zero,8112ce78 <__sflush_r+0xf8>
8112cdb4:	28c00117 	ldw	r3,4(r5)
8112cdb8:	10820014 	ori	r2,r2,2048
8112cdbc:	2880030d 	sth	r2,12(r5)
8112cdc0:	00c04b0e 	bge	zero,r3,8112cef0 <__sflush_r+0x170>
8112cdc4:	8a000a17 	ldw	r8,40(r17)
8112cdc8:	40002326 	beq	r8,zero,8112ce58 <__sflush_r+0xd8>
8112cdcc:	9c000017 	ldw	r16,0(r19)
8112cdd0:	10c4000c 	andi	r3,r2,4096
8112cdd4:	98000015 	stw	zero,0(r19)
8112cdd8:	18004826 	beq	r3,zero,8112cefc <__sflush_r+0x17c>
8112cddc:	89801417 	ldw	r6,80(r17)
8112cde0:	10c0010c 	andi	r3,r2,4
8112cde4:	18000626 	beq	r3,zero,8112ce00 <__sflush_r+0x80>
8112cde8:	88c00117 	ldw	r3,4(r17)
8112cdec:	88800c17 	ldw	r2,48(r17)
8112cdf0:	30cdc83a 	sub	r6,r6,r3
8112cdf4:	10000226 	beq	r2,zero,8112ce00 <__sflush_r+0x80>
8112cdf8:	88800f17 	ldw	r2,60(r17)
8112cdfc:	308dc83a 	sub	r6,r6,r2
8112ce00:	89400717 	ldw	r5,28(r17)
8112ce04:	000f883a 	mov	r7,zero
8112ce08:	9809883a 	mov	r4,r19
8112ce0c:	403ee83a 	callr	r8
8112ce10:	00ffffc4 	movi	r3,-1
8112ce14:	10c04426 	beq	r2,r3,8112cf28 <__sflush_r+0x1a8>
8112ce18:	88c0030b 	ldhu	r3,12(r17)
8112ce1c:	89000417 	ldw	r4,16(r17)
8112ce20:	88000115 	stw	zero,4(r17)
8112ce24:	197dffcc 	andi	r5,r3,63487
8112ce28:	8940030d 	sth	r5,12(r17)
8112ce2c:	89000015 	stw	r4,0(r17)
8112ce30:	18c4000c 	andi	r3,r3,4096
8112ce34:	18002c1e 	bne	r3,zero,8112cee8 <__sflush_r+0x168>
8112ce38:	89400c17 	ldw	r5,48(r17)
8112ce3c:	9c000015 	stw	r16,0(r19)
8112ce40:	28000526 	beq	r5,zero,8112ce58 <__sflush_r+0xd8>
8112ce44:	88801004 	addi	r2,r17,64
8112ce48:	28800226 	beq	r5,r2,8112ce54 <__sflush_r+0xd4>
8112ce4c:	9809883a 	mov	r4,r19
8112ce50:	112d8380 	call	8112d838 <_free_r>
8112ce54:	88000c15 	stw	zero,48(r17)
8112ce58:	0005883a 	mov	r2,zero
8112ce5c:	dfc00417 	ldw	ra,16(sp)
8112ce60:	dcc00317 	ldw	r19,12(sp)
8112ce64:	dc800217 	ldw	r18,8(sp)
8112ce68:	dc400117 	ldw	r17,4(sp)
8112ce6c:	dc000017 	ldw	r16,0(sp)
8112ce70:	dec00504 	addi	sp,sp,20
8112ce74:	f800283a 	ret
8112ce78:	2c800417 	ldw	r18,16(r5)
8112ce7c:	903ff626 	beq	r18,zero,8112ce58 <__reset+0xfb10ce58>
8112ce80:	2c000017 	ldw	r16,0(r5)
8112ce84:	108000cc 	andi	r2,r2,3
8112ce88:	2c800015 	stw	r18,0(r5)
8112ce8c:	84a1c83a 	sub	r16,r16,r18
8112ce90:	1000131e 	bne	r2,zero,8112cee0 <__sflush_r+0x160>
8112ce94:	28800517 	ldw	r2,20(r5)
8112ce98:	88800215 	stw	r2,8(r17)
8112ce9c:	04000316 	blt	zero,r16,8112ceac <__sflush_r+0x12c>
8112cea0:	003fed06 	br	8112ce58 <__reset+0xfb10ce58>
8112cea4:	90a5883a 	add	r18,r18,r2
8112cea8:	043feb0e 	bge	zero,r16,8112ce58 <__reset+0xfb10ce58>
8112ceac:	88800917 	ldw	r2,36(r17)
8112ceb0:	89400717 	ldw	r5,28(r17)
8112ceb4:	800f883a 	mov	r7,r16
8112ceb8:	900d883a 	mov	r6,r18
8112cebc:	9809883a 	mov	r4,r19
8112cec0:	103ee83a 	callr	r2
8112cec4:	80a1c83a 	sub	r16,r16,r2
8112cec8:	00bff616 	blt	zero,r2,8112cea4 <__reset+0xfb10cea4>
8112cecc:	88c0030b 	ldhu	r3,12(r17)
8112ced0:	00bfffc4 	movi	r2,-1
8112ced4:	18c01014 	ori	r3,r3,64
8112ced8:	88c0030d 	sth	r3,12(r17)
8112cedc:	003fdf06 	br	8112ce5c <__reset+0xfb10ce5c>
8112cee0:	0005883a 	mov	r2,zero
8112cee4:	003fec06 	br	8112ce98 <__reset+0xfb10ce98>
8112cee8:	88801415 	stw	r2,80(r17)
8112ceec:	003fd206 	br	8112ce38 <__reset+0xfb10ce38>
8112cef0:	28c00f17 	ldw	r3,60(r5)
8112cef4:	00ffb316 	blt	zero,r3,8112cdc4 <__reset+0xfb10cdc4>
8112cef8:	003fd706 	br	8112ce58 <__reset+0xfb10ce58>
8112cefc:	89400717 	ldw	r5,28(r17)
8112cf00:	000d883a 	mov	r6,zero
8112cf04:	01c00044 	movi	r7,1
8112cf08:	9809883a 	mov	r4,r19
8112cf0c:	403ee83a 	callr	r8
8112cf10:	100d883a 	mov	r6,r2
8112cf14:	00bfffc4 	movi	r2,-1
8112cf18:	30801426 	beq	r6,r2,8112cf6c <__sflush_r+0x1ec>
8112cf1c:	8880030b 	ldhu	r2,12(r17)
8112cf20:	8a000a17 	ldw	r8,40(r17)
8112cf24:	003fae06 	br	8112cde0 <__reset+0xfb10cde0>
8112cf28:	98c00017 	ldw	r3,0(r19)
8112cf2c:	183fba26 	beq	r3,zero,8112ce18 <__reset+0xfb10ce18>
8112cf30:	01000744 	movi	r4,29
8112cf34:	19000626 	beq	r3,r4,8112cf50 <__sflush_r+0x1d0>
8112cf38:	01000584 	movi	r4,22
8112cf3c:	19000426 	beq	r3,r4,8112cf50 <__sflush_r+0x1d0>
8112cf40:	88c0030b 	ldhu	r3,12(r17)
8112cf44:	18c01014 	ori	r3,r3,64
8112cf48:	88c0030d 	sth	r3,12(r17)
8112cf4c:	003fc306 	br	8112ce5c <__reset+0xfb10ce5c>
8112cf50:	8880030b 	ldhu	r2,12(r17)
8112cf54:	88c00417 	ldw	r3,16(r17)
8112cf58:	88000115 	stw	zero,4(r17)
8112cf5c:	10bdffcc 	andi	r2,r2,63487
8112cf60:	8880030d 	sth	r2,12(r17)
8112cf64:	88c00015 	stw	r3,0(r17)
8112cf68:	003fb306 	br	8112ce38 <__reset+0xfb10ce38>
8112cf6c:	98800017 	ldw	r2,0(r19)
8112cf70:	103fea26 	beq	r2,zero,8112cf1c <__reset+0xfb10cf1c>
8112cf74:	00c00744 	movi	r3,29
8112cf78:	10c00226 	beq	r2,r3,8112cf84 <__sflush_r+0x204>
8112cf7c:	00c00584 	movi	r3,22
8112cf80:	10c0031e 	bne	r2,r3,8112cf90 <__sflush_r+0x210>
8112cf84:	9c000015 	stw	r16,0(r19)
8112cf88:	0005883a 	mov	r2,zero
8112cf8c:	003fb306 	br	8112ce5c <__reset+0xfb10ce5c>
8112cf90:	88c0030b 	ldhu	r3,12(r17)
8112cf94:	3005883a 	mov	r2,r6
8112cf98:	18c01014 	ori	r3,r3,64
8112cf9c:	88c0030d 	sth	r3,12(r17)
8112cfa0:	003fae06 	br	8112ce5c <__reset+0xfb10ce5c>

8112cfa4 <_fflush_r>:
8112cfa4:	defffd04 	addi	sp,sp,-12
8112cfa8:	de00012e 	bgeu	sp,et,8112cfb0 <_fflush_r+0xc>
8112cfac:	003b68fa 	trap	3
8112cfb0:	dc000115 	stw	r16,4(sp)
8112cfb4:	dfc00215 	stw	ra,8(sp)
8112cfb8:	2021883a 	mov	r16,r4
8112cfbc:	20000226 	beq	r4,zero,8112cfc8 <_fflush_r+0x24>
8112cfc0:	20800e17 	ldw	r2,56(r4)
8112cfc4:	10000c26 	beq	r2,zero,8112cff8 <_fflush_r+0x54>
8112cfc8:	2880030f 	ldh	r2,12(r5)
8112cfcc:	1000051e 	bne	r2,zero,8112cfe4 <_fflush_r+0x40>
8112cfd0:	0005883a 	mov	r2,zero
8112cfd4:	dfc00217 	ldw	ra,8(sp)
8112cfd8:	dc000117 	ldw	r16,4(sp)
8112cfdc:	dec00304 	addi	sp,sp,12
8112cfe0:	f800283a 	ret
8112cfe4:	8009883a 	mov	r4,r16
8112cfe8:	dfc00217 	ldw	ra,8(sp)
8112cfec:	dc000117 	ldw	r16,4(sp)
8112cff0:	dec00304 	addi	sp,sp,12
8112cff4:	112cd801 	jmpi	8112cd80 <__sflush_r>
8112cff8:	d9400015 	stw	r5,0(sp)
8112cffc:	112d3a00 	call	8112d3a0 <__sinit>
8112d000:	d9400017 	ldw	r5,0(sp)
8112d004:	003ff006 	br	8112cfc8 <__reset+0xfb10cfc8>

8112d008 <fflush>:
8112d008:	20000526 	beq	r4,zero,8112d020 <fflush+0x18>
8112d00c:	00a04574 	movhi	r2,33045
8112d010:	10936004 	addi	r2,r2,19840
8112d014:	200b883a 	mov	r5,r4
8112d018:	11000017 	ldw	r4,0(r2)
8112d01c:	112cfa41 	jmpi	8112cfa4 <_fflush_r>
8112d020:	00a04574 	movhi	r2,33045
8112d024:	10935f04 	addi	r2,r2,19836
8112d028:	11000017 	ldw	r4,0(r2)
8112d02c:	016044f4 	movhi	r5,33043
8112d030:	2973e904 	addi	r5,r5,-12380
8112d034:	112e0e01 	jmpi	8112e0e0 <_fwalk_reent>

8112d038 <__fp_unlock>:
8112d038:	0005883a 	mov	r2,zero
8112d03c:	f800283a 	ret

8112d040 <_cleanup_r>:
8112d040:	016044f4 	movhi	r5,33043
8112d044:	2952c504 	addi	r5,r5,19220
8112d048:	112e0e01 	jmpi	8112e0e0 <_fwalk_reent>

8112d04c <__sinit.part.1>:
8112d04c:	defff704 	addi	sp,sp,-36
8112d050:	00e044f4 	movhi	r3,33043
8112d054:	de00012e 	bgeu	sp,et,8112d05c <__sinit.part.1+0x10>
8112d058:	003b68fa 	trap	3
8112d05c:	18f41004 	addi	r3,r3,-12224
8112d060:	dfc00815 	stw	ra,32(sp)
8112d064:	ddc00715 	stw	r23,28(sp)
8112d068:	dd800615 	stw	r22,24(sp)
8112d06c:	dd400515 	stw	r21,20(sp)
8112d070:	dd000415 	stw	r20,16(sp)
8112d074:	dcc00315 	stw	r19,12(sp)
8112d078:	dc800215 	stw	r18,8(sp)
8112d07c:	dc400115 	stw	r17,4(sp)
8112d080:	dc000015 	stw	r16,0(sp)
8112d084:	24000117 	ldw	r16,4(r4)
8112d088:	20c00f15 	stw	r3,60(r4)
8112d08c:	2080bb04 	addi	r2,r4,748
8112d090:	00c000c4 	movi	r3,3
8112d094:	20c0b915 	stw	r3,740(r4)
8112d098:	2080ba15 	stw	r2,744(r4)
8112d09c:	2000b815 	stw	zero,736(r4)
8112d0a0:	05c00204 	movi	r23,8
8112d0a4:	00800104 	movi	r2,4
8112d0a8:	2025883a 	mov	r18,r4
8112d0ac:	b80d883a 	mov	r6,r23
8112d0b0:	81001704 	addi	r4,r16,92
8112d0b4:	000b883a 	mov	r5,zero
8112d0b8:	80000015 	stw	zero,0(r16)
8112d0bc:	80000115 	stw	zero,4(r16)
8112d0c0:	80000215 	stw	zero,8(r16)
8112d0c4:	8080030d 	sth	r2,12(r16)
8112d0c8:	80001915 	stw	zero,100(r16)
8112d0cc:	8000038d 	sth	zero,14(r16)
8112d0d0:	80000415 	stw	zero,16(r16)
8112d0d4:	80000515 	stw	zero,20(r16)
8112d0d8:	80000615 	stw	zero,24(r16)
8112d0dc:	11244a00 	call	811244a0 <memset>
8112d0e0:	05a044b4 	movhi	r22,33042
8112d0e4:	94400217 	ldw	r17,8(r18)
8112d0e8:	056044b4 	movhi	r21,33042
8112d0ec:	052044b4 	movhi	r20,33042
8112d0f0:	04e044b4 	movhi	r19,33042
8112d0f4:	b5930a04 	addi	r22,r22,19496
8112d0f8:	ad532304 	addi	r21,r21,19596
8112d0fc:	a5134404 	addi	r20,r20,19728
8112d100:	9cd35d04 	addi	r19,r19,19828
8112d104:	85800815 	stw	r22,32(r16)
8112d108:	85400915 	stw	r21,36(r16)
8112d10c:	85000a15 	stw	r20,40(r16)
8112d110:	84c00b15 	stw	r19,44(r16)
8112d114:	84000715 	stw	r16,28(r16)
8112d118:	00800284 	movi	r2,10
8112d11c:	8880030d 	sth	r2,12(r17)
8112d120:	00800044 	movi	r2,1
8112d124:	b80d883a 	mov	r6,r23
8112d128:	89001704 	addi	r4,r17,92
8112d12c:	000b883a 	mov	r5,zero
8112d130:	88000015 	stw	zero,0(r17)
8112d134:	88000115 	stw	zero,4(r17)
8112d138:	88000215 	stw	zero,8(r17)
8112d13c:	88001915 	stw	zero,100(r17)
8112d140:	8880038d 	sth	r2,14(r17)
8112d144:	88000415 	stw	zero,16(r17)
8112d148:	88000515 	stw	zero,20(r17)
8112d14c:	88000615 	stw	zero,24(r17)
8112d150:	11244a00 	call	811244a0 <memset>
8112d154:	94000317 	ldw	r16,12(r18)
8112d158:	00800484 	movi	r2,18
8112d15c:	8c400715 	stw	r17,28(r17)
8112d160:	8d800815 	stw	r22,32(r17)
8112d164:	8d400915 	stw	r21,36(r17)
8112d168:	8d000a15 	stw	r20,40(r17)
8112d16c:	8cc00b15 	stw	r19,44(r17)
8112d170:	8080030d 	sth	r2,12(r16)
8112d174:	00800084 	movi	r2,2
8112d178:	80000015 	stw	zero,0(r16)
8112d17c:	80000115 	stw	zero,4(r16)
8112d180:	80000215 	stw	zero,8(r16)
8112d184:	80001915 	stw	zero,100(r16)
8112d188:	8080038d 	sth	r2,14(r16)
8112d18c:	80000415 	stw	zero,16(r16)
8112d190:	80000515 	stw	zero,20(r16)
8112d194:	80000615 	stw	zero,24(r16)
8112d198:	b80d883a 	mov	r6,r23
8112d19c:	000b883a 	mov	r5,zero
8112d1a0:	81001704 	addi	r4,r16,92
8112d1a4:	11244a00 	call	811244a0 <memset>
8112d1a8:	00800044 	movi	r2,1
8112d1ac:	84000715 	stw	r16,28(r16)
8112d1b0:	85800815 	stw	r22,32(r16)
8112d1b4:	85400915 	stw	r21,36(r16)
8112d1b8:	85000a15 	stw	r20,40(r16)
8112d1bc:	84c00b15 	stw	r19,44(r16)
8112d1c0:	90800e15 	stw	r2,56(r18)
8112d1c4:	dfc00817 	ldw	ra,32(sp)
8112d1c8:	ddc00717 	ldw	r23,28(sp)
8112d1cc:	dd800617 	ldw	r22,24(sp)
8112d1d0:	dd400517 	ldw	r21,20(sp)
8112d1d4:	dd000417 	ldw	r20,16(sp)
8112d1d8:	dcc00317 	ldw	r19,12(sp)
8112d1dc:	dc800217 	ldw	r18,8(sp)
8112d1e0:	dc400117 	ldw	r17,4(sp)
8112d1e4:	dc000017 	ldw	r16,0(sp)
8112d1e8:	dec00904 	addi	sp,sp,36
8112d1ec:	f800283a 	ret

8112d1f0 <__fp_lock>:
8112d1f0:	0005883a 	mov	r2,zero
8112d1f4:	f800283a 	ret

8112d1f8 <__sfmoreglue>:
8112d1f8:	defffc04 	addi	sp,sp,-16
8112d1fc:	de00012e 	bgeu	sp,et,8112d204 <__sfmoreglue+0xc>
8112d200:	003b68fa 	trap	3
8112d204:	dc400115 	stw	r17,4(sp)
8112d208:	2c7fffc4 	addi	r17,r5,-1
8112d20c:	8c401a24 	muli	r17,r17,104
8112d210:	dc800215 	stw	r18,8(sp)
8112d214:	2825883a 	mov	r18,r5
8112d218:	89401d04 	addi	r5,r17,116
8112d21c:	dc000015 	stw	r16,0(sp)
8112d220:	dfc00315 	stw	ra,12(sp)
8112d224:	1123b3c0 	call	81123b3c <_malloc_r>
8112d228:	1021883a 	mov	r16,r2
8112d22c:	10000726 	beq	r2,zero,8112d24c <__sfmoreglue+0x54>
8112d230:	11000304 	addi	r4,r2,12
8112d234:	10000015 	stw	zero,0(r2)
8112d238:	14800115 	stw	r18,4(r2)
8112d23c:	11000215 	stw	r4,8(r2)
8112d240:	89801a04 	addi	r6,r17,104
8112d244:	000b883a 	mov	r5,zero
8112d248:	11244a00 	call	811244a0 <memset>
8112d24c:	8005883a 	mov	r2,r16
8112d250:	dfc00317 	ldw	ra,12(sp)
8112d254:	dc800217 	ldw	r18,8(sp)
8112d258:	dc400117 	ldw	r17,4(sp)
8112d25c:	dc000017 	ldw	r16,0(sp)
8112d260:	dec00404 	addi	sp,sp,16
8112d264:	f800283a 	ret

8112d268 <__sfp>:
8112d268:	defffb04 	addi	sp,sp,-20
8112d26c:	de00012e 	bgeu	sp,et,8112d274 <__sfp+0xc>
8112d270:	003b68fa 	trap	3
8112d274:	dc000015 	stw	r16,0(sp)
8112d278:	04204574 	movhi	r16,33045
8112d27c:	84135f04 	addi	r16,r16,19836
8112d280:	dcc00315 	stw	r19,12(sp)
8112d284:	2027883a 	mov	r19,r4
8112d288:	81000017 	ldw	r4,0(r16)
8112d28c:	dfc00415 	stw	ra,16(sp)
8112d290:	dc800215 	stw	r18,8(sp)
8112d294:	20800e17 	ldw	r2,56(r4)
8112d298:	dc400115 	stw	r17,4(sp)
8112d29c:	1000021e 	bne	r2,zero,8112d2a8 <__sfp+0x40>
8112d2a0:	112d04c0 	call	8112d04c <__sinit.part.1>
8112d2a4:	81000017 	ldw	r4,0(r16)
8112d2a8:	2480b804 	addi	r18,r4,736
8112d2ac:	047fffc4 	movi	r17,-1
8112d2b0:	91000117 	ldw	r4,4(r18)
8112d2b4:	94000217 	ldw	r16,8(r18)
8112d2b8:	213fffc4 	addi	r4,r4,-1
8112d2bc:	20000a16 	blt	r4,zero,8112d2e8 <__sfp+0x80>
8112d2c0:	8080030f 	ldh	r2,12(r16)
8112d2c4:	10000c26 	beq	r2,zero,8112d2f8 <__sfp+0x90>
8112d2c8:	80c01d04 	addi	r3,r16,116
8112d2cc:	00000206 	br	8112d2d8 <__sfp+0x70>
8112d2d0:	18bfe60f 	ldh	r2,-104(r3)
8112d2d4:	10000826 	beq	r2,zero,8112d2f8 <__sfp+0x90>
8112d2d8:	213fffc4 	addi	r4,r4,-1
8112d2dc:	1c3ffd04 	addi	r16,r3,-12
8112d2e0:	18c01a04 	addi	r3,r3,104
8112d2e4:	247ffa1e 	bne	r4,r17,8112d2d0 <__reset+0xfb10d2d0>
8112d2e8:	90800017 	ldw	r2,0(r18)
8112d2ec:	10001d26 	beq	r2,zero,8112d364 <__sfp+0xfc>
8112d2f0:	1025883a 	mov	r18,r2
8112d2f4:	003fee06 	br	8112d2b0 <__reset+0xfb10d2b0>
8112d2f8:	00bfffc4 	movi	r2,-1
8112d2fc:	8080038d 	sth	r2,14(r16)
8112d300:	00800044 	movi	r2,1
8112d304:	8080030d 	sth	r2,12(r16)
8112d308:	80001915 	stw	zero,100(r16)
8112d30c:	80000015 	stw	zero,0(r16)
8112d310:	80000215 	stw	zero,8(r16)
8112d314:	80000115 	stw	zero,4(r16)
8112d318:	80000415 	stw	zero,16(r16)
8112d31c:	80000515 	stw	zero,20(r16)
8112d320:	80000615 	stw	zero,24(r16)
8112d324:	01800204 	movi	r6,8
8112d328:	000b883a 	mov	r5,zero
8112d32c:	81001704 	addi	r4,r16,92
8112d330:	11244a00 	call	811244a0 <memset>
8112d334:	8005883a 	mov	r2,r16
8112d338:	80000c15 	stw	zero,48(r16)
8112d33c:	80000d15 	stw	zero,52(r16)
8112d340:	80001115 	stw	zero,68(r16)
8112d344:	80001215 	stw	zero,72(r16)
8112d348:	dfc00417 	ldw	ra,16(sp)
8112d34c:	dcc00317 	ldw	r19,12(sp)
8112d350:	dc800217 	ldw	r18,8(sp)
8112d354:	dc400117 	ldw	r17,4(sp)
8112d358:	dc000017 	ldw	r16,0(sp)
8112d35c:	dec00504 	addi	sp,sp,20
8112d360:	f800283a 	ret
8112d364:	01400104 	movi	r5,4
8112d368:	9809883a 	mov	r4,r19
8112d36c:	112d1f80 	call	8112d1f8 <__sfmoreglue>
8112d370:	90800015 	stw	r2,0(r18)
8112d374:	103fde1e 	bne	r2,zero,8112d2f0 <__reset+0xfb10d2f0>
8112d378:	00800304 	movi	r2,12
8112d37c:	98800015 	stw	r2,0(r19)
8112d380:	0005883a 	mov	r2,zero
8112d384:	003ff006 	br	8112d348 <__reset+0xfb10d348>

8112d388 <_cleanup>:
8112d388:	00a04574 	movhi	r2,33045
8112d38c:	10935f04 	addi	r2,r2,19836
8112d390:	11000017 	ldw	r4,0(r2)
8112d394:	016044f4 	movhi	r5,33043
8112d398:	2952c504 	addi	r5,r5,19220
8112d39c:	112e0e01 	jmpi	8112e0e0 <_fwalk_reent>

8112d3a0 <__sinit>:
8112d3a0:	20800e17 	ldw	r2,56(r4)
8112d3a4:	10000126 	beq	r2,zero,8112d3ac <__sinit+0xc>
8112d3a8:	f800283a 	ret
8112d3ac:	112d04c1 	jmpi	8112d04c <__sinit.part.1>

8112d3b0 <__sfp_lock_acquire>:
8112d3b0:	f800283a 	ret

8112d3b4 <__sfp_lock_release>:
8112d3b4:	f800283a 	ret

8112d3b8 <__sinit_lock_acquire>:
8112d3b8:	f800283a 	ret

8112d3bc <__sinit_lock_release>:
8112d3bc:	f800283a 	ret

8112d3c0 <__fp_lock_all>:
8112d3c0:	00a04574 	movhi	r2,33045
8112d3c4:	10936004 	addi	r2,r2,19840
8112d3c8:	11000017 	ldw	r4,0(r2)
8112d3cc:	016044f4 	movhi	r5,33043
8112d3d0:	29747c04 	addi	r5,r5,-11792
8112d3d4:	112e0141 	jmpi	8112e014 <_fwalk>

8112d3d8 <__fp_unlock_all>:
8112d3d8:	00a04574 	movhi	r2,33045
8112d3dc:	10936004 	addi	r2,r2,19840
8112d3e0:	11000017 	ldw	r4,0(r2)
8112d3e4:	016044f4 	movhi	r5,33043
8112d3e8:	29740e04 	addi	r5,r5,-12232
8112d3ec:	112e0141 	jmpi	8112e014 <_fwalk>

8112d3f0 <__sflags>:
8112d3f0:	28800007 	ldb	r2,0(r5)
8112d3f4:	00c01c84 	movi	r3,114
8112d3f8:	10c02426 	beq	r2,r3,8112d48c <__sflags+0x9c>
8112d3fc:	00c01dc4 	movi	r3,119
8112d400:	10c01e26 	beq	r2,r3,8112d47c <__sflags+0x8c>
8112d404:	00c01844 	movi	r3,97
8112d408:	10c00426 	beq	r2,r3,8112d41c <__sflags+0x2c>
8112d40c:	00800584 	movi	r2,22
8112d410:	20800015 	stw	r2,0(r4)
8112d414:	0005883a 	mov	r2,zero
8112d418:	f800283a 	ret
8112d41c:	02c08204 	movi	r11,520
8112d420:	01000044 	movi	r4,1
8112d424:	00804204 	movi	r2,264
8112d428:	01c00ac4 	movi	r7,43
8112d42c:	02bff8c4 	movi	r10,-29
8112d430:	027fff04 	movi	r9,-4
8112d434:	02001e04 	movi	r8,120
8112d438:	29400044 	addi	r5,r5,1
8112d43c:	28c00007 	ldb	r3,0(r5)
8112d440:	18000626 	beq	r3,zero,8112d45c <__sflags+0x6c>
8112d444:	19c00826 	beq	r3,r7,8112d468 <__sflags+0x78>
8112d448:	1a3ffb1e 	bne	r3,r8,8112d438 <__reset+0xfb10d438>
8112d44c:	29400044 	addi	r5,r5,1
8112d450:	28c00007 	ldb	r3,0(r5)
8112d454:	21020014 	ori	r4,r4,2048
8112d458:	183ffa1e 	bne	r3,zero,8112d444 <__reset+0xfb10d444>
8112d45c:	22c8b03a 	or	r4,r4,r11
8112d460:	31000015 	stw	r4,0(r6)
8112d464:	f800283a 	ret
8112d468:	1284703a 	and	r2,r2,r10
8112d46c:	2248703a 	and	r4,r4,r9
8112d470:	10800414 	ori	r2,r2,16
8112d474:	21000094 	ori	r4,r4,2
8112d478:	003fef06 	br	8112d438 <__reset+0xfb10d438>
8112d47c:	02c18004 	movi	r11,1536
8112d480:	01000044 	movi	r4,1
8112d484:	00800204 	movi	r2,8
8112d488:	003fe706 	br	8112d428 <__reset+0xfb10d428>
8112d48c:	0017883a 	mov	r11,zero
8112d490:	0009883a 	mov	r4,zero
8112d494:	00800104 	movi	r2,4
8112d498:	003fe306 	br	8112d428 <__reset+0xfb10d428>

8112d49c <_fread_r>:
8112d49c:	defff404 	addi	sp,sp,-48
8112d4a0:	de00012e 	bgeu	sp,et,8112d4a8 <_fread_r+0xc>
8112d4a4:	003b68fa 	trap	3
8112d4a8:	dd800815 	stw	r22,32(sp)
8112d4ac:	39ad383a 	mul	r22,r7,r6
8112d4b0:	dc000215 	stw	r16,8(sp)
8112d4b4:	dfc00b15 	stw	ra,44(sp)
8112d4b8:	df000a15 	stw	fp,40(sp)
8112d4bc:	ddc00915 	stw	r23,36(sp)
8112d4c0:	dd400715 	stw	r21,28(sp)
8112d4c4:	dd000615 	stw	r20,24(sp)
8112d4c8:	dcc00515 	stw	r19,20(sp)
8112d4cc:	dc800415 	stw	r18,16(sp)
8112d4d0:	dc400315 	stw	r17,12(sp)
8112d4d4:	dc000c17 	ldw	r16,48(sp)
8112d4d8:	b0003b26 	beq	r22,zero,8112d5c8 <_fread_r+0x12c>
8112d4dc:	302f883a 	mov	r23,r6
8112d4e0:	382b883a 	mov	r21,r7
8112d4e4:	2029883a 	mov	r20,r4
8112d4e8:	2827883a 	mov	r19,r5
8112d4ec:	20000226 	beq	r4,zero,8112d4f8 <_fread_r+0x5c>
8112d4f0:	20800e17 	ldw	r2,56(r4)
8112d4f4:	10006e26 	beq	r2,zero,8112d6b0 <_fread_r+0x214>
8112d4f8:	8080030b 	ldhu	r2,12(r16)
8112d4fc:	10c8000c 	andi	r3,r2,8192
8112d500:	1800061e 	bne	r3,zero,8112d51c <_fread_r+0x80>
8112d504:	81001917 	ldw	r4,100(r16)
8112d508:	00f7ffc4 	movi	r3,-8193
8112d50c:	10880014 	ori	r2,r2,8192
8112d510:	20c6703a 	and	r3,r4,r3
8112d514:	8080030d 	sth	r2,12(r16)
8112d518:	80c01915 	stw	r3,100(r16)
8112d51c:	84400117 	ldw	r17,4(r16)
8112d520:	88005f16 	blt	r17,zero,8112d6a0 <_fread_r+0x204>
8112d524:	8809883a 	mov	r4,r17
8112d528:	1080008c 	andi	r2,r2,2
8112d52c:	1000281e 	bne	r2,zero,8112d5d0 <_fread_r+0x134>
8112d530:	b025883a 	mov	r18,r22
8112d534:	00000b06 	br	8112d564 <_fread_r+0xc8>
8112d538:	11243500 	call	81124350 <memcpy>
8112d53c:	80800017 	ldw	r2,0(r16)
8112d540:	9c67883a 	add	r19,r19,r17
8112d544:	9465c83a 	sub	r18,r18,r17
8112d548:	1463883a 	add	r17,r2,r17
8112d54c:	800b883a 	mov	r5,r16
8112d550:	a009883a 	mov	r4,r20
8112d554:	84400015 	stw	r17,0(r16)
8112d558:	11248a00 	call	811248a0 <__srefill_r>
8112d55c:	10004c1e 	bne	r2,zero,8112d690 <_fread_r+0x1f4>
8112d560:	84400117 	ldw	r17,4(r16)
8112d564:	880d883a 	mov	r6,r17
8112d568:	9809883a 	mov	r4,r19
8112d56c:	81400017 	ldw	r5,0(r16)
8112d570:	8cbff136 	bltu	r17,r18,8112d538 <__reset+0xfb10d538>
8112d574:	900d883a 	mov	r6,r18
8112d578:	11243500 	call	81124350 <memcpy>
8112d57c:	80c00117 	ldw	r3,4(r16)
8112d580:	81000017 	ldw	r4,0(r16)
8112d584:	a805883a 	mov	r2,r21
8112d588:	1c87c83a 	sub	r3,r3,r18
8112d58c:	24a5883a 	add	r18,r4,r18
8112d590:	80c00115 	stw	r3,4(r16)
8112d594:	84800015 	stw	r18,0(r16)
8112d598:	dfc00b17 	ldw	ra,44(sp)
8112d59c:	df000a17 	ldw	fp,40(sp)
8112d5a0:	ddc00917 	ldw	r23,36(sp)
8112d5a4:	dd800817 	ldw	r22,32(sp)
8112d5a8:	dd400717 	ldw	r21,28(sp)
8112d5ac:	dd000617 	ldw	r20,24(sp)
8112d5b0:	dcc00517 	ldw	r19,20(sp)
8112d5b4:	dc800417 	ldw	r18,16(sp)
8112d5b8:	dc400317 	ldw	r17,12(sp)
8112d5bc:	dc000217 	ldw	r16,8(sp)
8112d5c0:	dec00c04 	addi	sp,sp,48
8112d5c4:	f800283a 	ret
8112d5c8:	0005883a 	mov	r2,zero
8112d5cc:	003ff206 	br	8112d598 <__reset+0xfb10d598>
8112d5d0:	b007883a 	mov	r3,r22
8112d5d4:	2580012e 	bgeu	r4,r22,8112d5dc <_fread_r+0x140>
8112d5d8:	2007883a 	mov	r3,r4
8112d5dc:	81400017 	ldw	r5,0(r16)
8112d5e0:	180d883a 	mov	r6,r3
8112d5e4:	9809883a 	mov	r4,r19
8112d5e8:	d8c00115 	stw	r3,4(sp)
8112d5ec:	11243500 	call	81124350 <memcpy>
8112d5f0:	d8c00117 	ldw	r3,4(sp)
8112d5f4:	84400017 	ldw	r17,0(r16)
8112d5f8:	80800117 	ldw	r2,4(r16)
8112d5fc:	81400c17 	ldw	r5,48(r16)
8112d600:	88e3883a 	add	r17,r17,r3
8112d604:	10c5c83a 	sub	r2,r2,r3
8112d608:	84400015 	stw	r17,0(r16)
8112d60c:	80800115 	stw	r2,4(r16)
8112d610:	b0e5c83a 	sub	r18,r22,r3
8112d614:	28002b26 	beq	r5,zero,8112d6c4 <_fread_r+0x228>
8112d618:	90002b26 	beq	r18,zero,8112d6c8 <_fread_r+0x22c>
8112d61c:	80801004 	addi	r2,r16,64
8112d620:	28800526 	beq	r5,r2,8112d638 <_fread_r+0x19c>
8112d624:	a009883a 	mov	r4,r20
8112d628:	d8c00115 	stw	r3,4(sp)
8112d62c:	112d8380 	call	8112d838 <_free_r>
8112d630:	d8c00117 	ldw	r3,4(sp)
8112d634:	84400017 	ldw	r17,0(r16)
8112d638:	80000c15 	stw	zero,48(r16)
8112d63c:	80800517 	ldw	r2,20(r16)
8112d640:	87000417 	ldw	fp,16(r16)
8112d644:	98e7883a 	add	r19,r19,r3
8112d648:	d8800015 	stw	r2,0(sp)
8112d64c:	00000106 	br	8112d654 <_fread_r+0x1b8>
8112d650:	90001d26 	beq	r18,zero,8112d6c8 <_fread_r+0x22c>
8112d654:	84c00415 	stw	r19,16(r16)
8112d658:	84800515 	stw	r18,20(r16)
8112d65c:	84c00015 	stw	r19,0(r16)
8112d660:	a009883a 	mov	r4,r20
8112d664:	800b883a 	mov	r5,r16
8112d668:	11248a00 	call	811248a0 <__srefill_r>
8112d66c:	d9000017 	ldw	r4,0(sp)
8112d670:	80c00117 	ldw	r3,4(r16)
8112d674:	87000415 	stw	fp,16(r16)
8112d678:	81000515 	stw	r4,20(r16)
8112d67c:	84400015 	stw	r17,0(r16)
8112d680:	80000115 	stw	zero,4(r16)
8112d684:	90e5c83a 	sub	r18,r18,r3
8112d688:	98e7883a 	add	r19,r19,r3
8112d68c:	103ff026 	beq	r2,zero,8112d650 <__reset+0xfb10d650>
8112d690:	b80b883a 	mov	r5,r23
8112d694:	b489c83a 	sub	r4,r22,r18
8112d698:	113685c0 	call	8113685c <__udivsi3>
8112d69c:	003fbe06 	br	8112d598 <__reset+0xfb10d598>
8112d6a0:	80000115 	stw	zero,4(r16)
8112d6a4:	0009883a 	mov	r4,zero
8112d6a8:	0023883a 	mov	r17,zero
8112d6ac:	003f9e06 	br	8112d528 <__reset+0xfb10d528>
8112d6b0:	112d3a00 	call	8112d3a0 <__sinit>
8112d6b4:	8080030b 	ldhu	r2,12(r16)
8112d6b8:	10c8000c 	andi	r3,r2,8192
8112d6bc:	183f971e 	bne	r3,zero,8112d51c <__reset+0xfb10d51c>
8112d6c0:	003f9006 	br	8112d504 <__reset+0xfb10d504>
8112d6c4:	903fdd1e 	bne	r18,zero,8112d63c <__reset+0xfb10d63c>
8112d6c8:	a805883a 	mov	r2,r21
8112d6cc:	003fb206 	br	8112d598 <__reset+0xfb10d598>

8112d6d0 <fread>:
8112d6d0:	defffe04 	addi	sp,sp,-8
8112d6d4:	00a04574 	movhi	r2,33045
8112d6d8:	de00012e 	bgeu	sp,et,8112d6e0 <fread+0x10>
8112d6dc:	003b68fa 	trap	3
8112d6e0:	10936004 	addi	r2,r2,19840
8112d6e4:	d9c00015 	stw	r7,0(sp)
8112d6e8:	300f883a 	mov	r7,r6
8112d6ec:	280d883a 	mov	r6,r5
8112d6f0:	200b883a 	mov	r5,r4
8112d6f4:	11000017 	ldw	r4,0(r2)
8112d6f8:	dfc00115 	stw	ra,4(sp)
8112d6fc:	112d49c0 	call	8112d49c <_fread_r>
8112d700:	dfc00117 	ldw	ra,4(sp)
8112d704:	dec00204 	addi	sp,sp,8
8112d708:	f800283a 	ret

8112d70c <_malloc_trim_r>:
8112d70c:	defffb04 	addi	sp,sp,-20
8112d710:	de00012e 	bgeu	sp,et,8112d718 <_malloc_trim_r+0xc>
8112d714:	003b68fa 	trap	3
8112d718:	dcc00315 	stw	r19,12(sp)
8112d71c:	04e04574 	movhi	r19,33045
8112d720:	dc800215 	stw	r18,8(sp)
8112d724:	dc400115 	stw	r17,4(sp)
8112d728:	dc000015 	stw	r16,0(sp)
8112d72c:	dfc00415 	stw	ra,16(sp)
8112d730:	2821883a 	mov	r16,r5
8112d734:	9ccd1e04 	addi	r19,r19,13432
8112d738:	2025883a 	mov	r18,r4
8112d73c:	1139d180 	call	81139d18 <__malloc_lock>
8112d740:	98800217 	ldw	r2,8(r19)
8112d744:	14400117 	ldw	r17,4(r2)
8112d748:	00bfff04 	movi	r2,-4
8112d74c:	88a2703a 	and	r17,r17,r2
8112d750:	8c21c83a 	sub	r16,r17,r16
8112d754:	8403fbc4 	addi	r16,r16,4079
8112d758:	8020d33a 	srli	r16,r16,12
8112d75c:	0083ffc4 	movi	r2,4095
8112d760:	843fffc4 	addi	r16,r16,-1
8112d764:	8020933a 	slli	r16,r16,12
8112d768:	1400060e 	bge	r2,r16,8112d784 <_malloc_trim_r+0x78>
8112d76c:	000b883a 	mov	r5,zero
8112d770:	9009883a 	mov	r4,r18
8112d774:	1124a7c0 	call	81124a7c <_sbrk_r>
8112d778:	98c00217 	ldw	r3,8(r19)
8112d77c:	1c47883a 	add	r3,r3,r17
8112d780:	10c00a26 	beq	r2,r3,8112d7ac <_malloc_trim_r+0xa0>
8112d784:	9009883a 	mov	r4,r18
8112d788:	1139e400 	call	81139e40 <__malloc_unlock>
8112d78c:	0005883a 	mov	r2,zero
8112d790:	dfc00417 	ldw	ra,16(sp)
8112d794:	dcc00317 	ldw	r19,12(sp)
8112d798:	dc800217 	ldw	r18,8(sp)
8112d79c:	dc400117 	ldw	r17,4(sp)
8112d7a0:	dc000017 	ldw	r16,0(sp)
8112d7a4:	dec00504 	addi	sp,sp,20
8112d7a8:	f800283a 	ret
8112d7ac:	040bc83a 	sub	r5,zero,r16
8112d7b0:	9009883a 	mov	r4,r18
8112d7b4:	1124a7c0 	call	81124a7c <_sbrk_r>
8112d7b8:	00ffffc4 	movi	r3,-1
8112d7bc:	10c00d26 	beq	r2,r3,8112d7f4 <_malloc_trim_r+0xe8>
8112d7c0:	00e04574 	movhi	r3,33045
8112d7c4:	18d46304 	addi	r3,r3,20876
8112d7c8:	18800017 	ldw	r2,0(r3)
8112d7cc:	99000217 	ldw	r4,8(r19)
8112d7d0:	8c23c83a 	sub	r17,r17,r16
8112d7d4:	8c400054 	ori	r17,r17,1
8112d7d8:	1421c83a 	sub	r16,r2,r16
8112d7dc:	24400115 	stw	r17,4(r4)
8112d7e0:	9009883a 	mov	r4,r18
8112d7e4:	1c000015 	stw	r16,0(r3)
8112d7e8:	1139e400 	call	81139e40 <__malloc_unlock>
8112d7ec:	00800044 	movi	r2,1
8112d7f0:	003fe706 	br	8112d790 <__reset+0xfb10d790>
8112d7f4:	000b883a 	mov	r5,zero
8112d7f8:	9009883a 	mov	r4,r18
8112d7fc:	1124a7c0 	call	81124a7c <_sbrk_r>
8112d800:	99000217 	ldw	r4,8(r19)
8112d804:	014003c4 	movi	r5,15
8112d808:	1107c83a 	sub	r3,r2,r4
8112d80c:	28ffdd0e 	bge	r5,r3,8112d784 <__reset+0xfb10d784>
8112d810:	01604574 	movhi	r5,33045
8112d814:	29536104 	addi	r5,r5,19844
8112d818:	29400017 	ldw	r5,0(r5)
8112d81c:	18c00054 	ori	r3,r3,1
8112d820:	20c00115 	stw	r3,4(r4)
8112d824:	00e04574 	movhi	r3,33045
8112d828:	1145c83a 	sub	r2,r2,r5
8112d82c:	18d46304 	addi	r3,r3,20876
8112d830:	18800015 	stw	r2,0(r3)
8112d834:	003fd306 	br	8112d784 <__reset+0xfb10d784>

8112d838 <_free_r>:
8112d838:	28004326 	beq	r5,zero,8112d948 <_free_r+0x110>
8112d83c:	defffd04 	addi	sp,sp,-12
8112d840:	de00012e 	bgeu	sp,et,8112d848 <_free_r+0x10>
8112d844:	003b68fa 	trap	3
8112d848:	dc400115 	stw	r17,4(sp)
8112d84c:	dc000015 	stw	r16,0(sp)
8112d850:	2023883a 	mov	r17,r4
8112d854:	2821883a 	mov	r16,r5
8112d858:	dfc00215 	stw	ra,8(sp)
8112d85c:	1139d180 	call	81139d18 <__malloc_lock>
8112d860:	81ffff17 	ldw	r7,-4(r16)
8112d864:	00bfff84 	movi	r2,-2
8112d868:	01204574 	movhi	r4,33045
8112d86c:	81bffe04 	addi	r6,r16,-8
8112d870:	3884703a 	and	r2,r7,r2
8112d874:	210d1e04 	addi	r4,r4,13432
8112d878:	308b883a 	add	r5,r6,r2
8112d87c:	2a400117 	ldw	r9,4(r5)
8112d880:	22000217 	ldw	r8,8(r4)
8112d884:	00ffff04 	movi	r3,-4
8112d888:	48c6703a 	and	r3,r9,r3
8112d88c:	2a005726 	beq	r5,r8,8112d9ec <_free_r+0x1b4>
8112d890:	28c00115 	stw	r3,4(r5)
8112d894:	39c0004c 	andi	r7,r7,1
8112d898:	3800091e 	bne	r7,zero,8112d8c0 <_free_r+0x88>
8112d89c:	823ffe17 	ldw	r8,-8(r16)
8112d8a0:	22400204 	addi	r9,r4,8
8112d8a4:	320dc83a 	sub	r6,r6,r8
8112d8a8:	31c00217 	ldw	r7,8(r6)
8112d8ac:	1205883a 	add	r2,r2,r8
8112d8b0:	3a406526 	beq	r7,r9,8112da48 <_free_r+0x210>
8112d8b4:	32000317 	ldw	r8,12(r6)
8112d8b8:	3a000315 	stw	r8,12(r7)
8112d8bc:	41c00215 	stw	r7,8(r8)
8112d8c0:	28cf883a 	add	r7,r5,r3
8112d8c4:	39c00117 	ldw	r7,4(r7)
8112d8c8:	39c0004c 	andi	r7,r7,1
8112d8cc:	38003a26 	beq	r7,zero,8112d9b8 <_free_r+0x180>
8112d8d0:	10c00054 	ori	r3,r2,1
8112d8d4:	30c00115 	stw	r3,4(r6)
8112d8d8:	3087883a 	add	r3,r6,r2
8112d8dc:	18800015 	stw	r2,0(r3)
8112d8e0:	00c07fc4 	movi	r3,511
8112d8e4:	18801936 	bltu	r3,r2,8112d94c <_free_r+0x114>
8112d8e8:	1004d0fa 	srli	r2,r2,3
8112d8ec:	01c00044 	movi	r7,1
8112d8f0:	21400117 	ldw	r5,4(r4)
8112d8f4:	10c00044 	addi	r3,r2,1
8112d8f8:	18c7883a 	add	r3,r3,r3
8112d8fc:	1005d0ba 	srai	r2,r2,2
8112d900:	18c7883a 	add	r3,r3,r3
8112d904:	18c7883a 	add	r3,r3,r3
8112d908:	1907883a 	add	r3,r3,r4
8112d90c:	3884983a 	sll	r2,r7,r2
8112d910:	19c00017 	ldw	r7,0(r3)
8112d914:	1a3ffe04 	addi	r8,r3,-8
8112d918:	1144b03a 	or	r2,r2,r5
8112d91c:	32000315 	stw	r8,12(r6)
8112d920:	31c00215 	stw	r7,8(r6)
8112d924:	20800115 	stw	r2,4(r4)
8112d928:	19800015 	stw	r6,0(r3)
8112d92c:	39800315 	stw	r6,12(r7)
8112d930:	8809883a 	mov	r4,r17
8112d934:	dfc00217 	ldw	ra,8(sp)
8112d938:	dc400117 	ldw	r17,4(sp)
8112d93c:	dc000017 	ldw	r16,0(sp)
8112d940:	dec00304 	addi	sp,sp,12
8112d944:	1139e401 	jmpi	81139e40 <__malloc_unlock>
8112d948:	f800283a 	ret
8112d94c:	100ad27a 	srli	r5,r2,9
8112d950:	00c00104 	movi	r3,4
8112d954:	19404a36 	bltu	r3,r5,8112da80 <_free_r+0x248>
8112d958:	100ad1ba 	srli	r5,r2,6
8112d95c:	28c00e44 	addi	r3,r5,57
8112d960:	18c7883a 	add	r3,r3,r3
8112d964:	29400e04 	addi	r5,r5,56
8112d968:	18c7883a 	add	r3,r3,r3
8112d96c:	18c7883a 	add	r3,r3,r3
8112d970:	1909883a 	add	r4,r3,r4
8112d974:	20c00017 	ldw	r3,0(r4)
8112d978:	01e04574 	movhi	r7,33045
8112d97c:	213ffe04 	addi	r4,r4,-8
8112d980:	39cd1e04 	addi	r7,r7,13432
8112d984:	20c04426 	beq	r4,r3,8112da98 <_free_r+0x260>
8112d988:	01ffff04 	movi	r7,-4
8112d98c:	19400117 	ldw	r5,4(r3)
8112d990:	29ca703a 	and	r5,r5,r7
8112d994:	1140022e 	bgeu	r2,r5,8112d9a0 <_free_r+0x168>
8112d998:	18c00217 	ldw	r3,8(r3)
8112d99c:	20fffb1e 	bne	r4,r3,8112d98c <__reset+0xfb10d98c>
8112d9a0:	19000317 	ldw	r4,12(r3)
8112d9a4:	31000315 	stw	r4,12(r6)
8112d9a8:	30c00215 	stw	r3,8(r6)
8112d9ac:	21800215 	stw	r6,8(r4)
8112d9b0:	19800315 	stw	r6,12(r3)
8112d9b4:	003fde06 	br	8112d930 <__reset+0xfb10d930>
8112d9b8:	29c00217 	ldw	r7,8(r5)
8112d9bc:	10c5883a 	add	r2,r2,r3
8112d9c0:	00e04574 	movhi	r3,33045
8112d9c4:	18cd2004 	addi	r3,r3,13440
8112d9c8:	38c03b26 	beq	r7,r3,8112dab8 <_free_r+0x280>
8112d9cc:	2a000317 	ldw	r8,12(r5)
8112d9d0:	11400054 	ori	r5,r2,1
8112d9d4:	3087883a 	add	r3,r6,r2
8112d9d8:	3a000315 	stw	r8,12(r7)
8112d9dc:	41c00215 	stw	r7,8(r8)
8112d9e0:	31400115 	stw	r5,4(r6)
8112d9e4:	18800015 	stw	r2,0(r3)
8112d9e8:	003fbd06 	br	8112d8e0 <__reset+0xfb10d8e0>
8112d9ec:	39c0004c 	andi	r7,r7,1
8112d9f0:	10c5883a 	add	r2,r2,r3
8112d9f4:	3800071e 	bne	r7,zero,8112da14 <_free_r+0x1dc>
8112d9f8:	81fffe17 	ldw	r7,-8(r16)
8112d9fc:	31cdc83a 	sub	r6,r6,r7
8112da00:	30c00317 	ldw	r3,12(r6)
8112da04:	31400217 	ldw	r5,8(r6)
8112da08:	11c5883a 	add	r2,r2,r7
8112da0c:	28c00315 	stw	r3,12(r5)
8112da10:	19400215 	stw	r5,8(r3)
8112da14:	10c00054 	ori	r3,r2,1
8112da18:	30c00115 	stw	r3,4(r6)
8112da1c:	00e04574 	movhi	r3,33045
8112da20:	18d36204 	addi	r3,r3,19848
8112da24:	18c00017 	ldw	r3,0(r3)
8112da28:	21800215 	stw	r6,8(r4)
8112da2c:	10ffc036 	bltu	r2,r3,8112d930 <__reset+0xfb10d930>
8112da30:	00a04574 	movhi	r2,33045
8112da34:	1093d604 	addi	r2,r2,20312
8112da38:	11400017 	ldw	r5,0(r2)
8112da3c:	8809883a 	mov	r4,r17
8112da40:	112d70c0 	call	8112d70c <_malloc_trim_r>
8112da44:	003fba06 	br	8112d930 <__reset+0xfb10d930>
8112da48:	28c9883a 	add	r4,r5,r3
8112da4c:	21000117 	ldw	r4,4(r4)
8112da50:	2100004c 	andi	r4,r4,1
8112da54:	2000391e 	bne	r4,zero,8112db3c <_free_r+0x304>
8112da58:	29c00217 	ldw	r7,8(r5)
8112da5c:	29000317 	ldw	r4,12(r5)
8112da60:	1885883a 	add	r2,r3,r2
8112da64:	10c00054 	ori	r3,r2,1
8112da68:	39000315 	stw	r4,12(r7)
8112da6c:	21c00215 	stw	r7,8(r4)
8112da70:	30c00115 	stw	r3,4(r6)
8112da74:	308d883a 	add	r6,r6,r2
8112da78:	30800015 	stw	r2,0(r6)
8112da7c:	003fac06 	br	8112d930 <__reset+0xfb10d930>
8112da80:	00c00504 	movi	r3,20
8112da84:	19401536 	bltu	r3,r5,8112dadc <_free_r+0x2a4>
8112da88:	28c01704 	addi	r3,r5,92
8112da8c:	18c7883a 	add	r3,r3,r3
8112da90:	294016c4 	addi	r5,r5,91
8112da94:	003fb406 	br	8112d968 <__reset+0xfb10d968>
8112da98:	280bd0ba 	srai	r5,r5,2
8112da9c:	00c00044 	movi	r3,1
8112daa0:	38800117 	ldw	r2,4(r7)
8112daa4:	194a983a 	sll	r5,r3,r5
8112daa8:	2007883a 	mov	r3,r4
8112daac:	2884b03a 	or	r2,r5,r2
8112dab0:	38800115 	stw	r2,4(r7)
8112dab4:	003fbb06 	br	8112d9a4 <__reset+0xfb10d9a4>
8112dab8:	21800515 	stw	r6,20(r4)
8112dabc:	21800415 	stw	r6,16(r4)
8112dac0:	10c00054 	ori	r3,r2,1
8112dac4:	31c00315 	stw	r7,12(r6)
8112dac8:	31c00215 	stw	r7,8(r6)
8112dacc:	30c00115 	stw	r3,4(r6)
8112dad0:	308d883a 	add	r6,r6,r2
8112dad4:	30800015 	stw	r2,0(r6)
8112dad8:	003f9506 	br	8112d930 <__reset+0xfb10d930>
8112dadc:	00c01504 	movi	r3,84
8112dae0:	19400536 	bltu	r3,r5,8112daf8 <_free_r+0x2c0>
8112dae4:	100ad33a 	srli	r5,r2,12
8112dae8:	28c01bc4 	addi	r3,r5,111
8112daec:	18c7883a 	add	r3,r3,r3
8112daf0:	29401b84 	addi	r5,r5,110
8112daf4:	003f9c06 	br	8112d968 <__reset+0xfb10d968>
8112daf8:	00c05504 	movi	r3,340
8112dafc:	19400536 	bltu	r3,r5,8112db14 <_free_r+0x2dc>
8112db00:	100ad3fa 	srli	r5,r2,15
8112db04:	28c01e04 	addi	r3,r5,120
8112db08:	18c7883a 	add	r3,r3,r3
8112db0c:	29401dc4 	addi	r5,r5,119
8112db10:	003f9506 	br	8112d968 <__reset+0xfb10d968>
8112db14:	00c15504 	movi	r3,1364
8112db18:	19400536 	bltu	r3,r5,8112db30 <_free_r+0x2f8>
8112db1c:	100ad4ba 	srli	r5,r2,18
8112db20:	28c01f44 	addi	r3,r5,125
8112db24:	18c7883a 	add	r3,r3,r3
8112db28:	29401f04 	addi	r5,r5,124
8112db2c:	003f8e06 	br	8112d968 <__reset+0xfb10d968>
8112db30:	00c03f84 	movi	r3,254
8112db34:	01401f84 	movi	r5,126
8112db38:	003f8b06 	br	8112d968 <__reset+0xfb10d968>
8112db3c:	10c00054 	ori	r3,r2,1
8112db40:	30c00115 	stw	r3,4(r6)
8112db44:	308d883a 	add	r6,r6,r2
8112db48:	30800015 	stw	r2,0(r6)
8112db4c:	003f7806 	br	8112d930 <__reset+0xfb10d930>

8112db50 <__sfvwrite_r>:
8112db50:	30800217 	ldw	r2,8(r6)
8112db54:	10006926 	beq	r2,zero,8112dcfc <__sfvwrite_r+0x1ac>
8112db58:	defff404 	addi	sp,sp,-48
8112db5c:	de00012e 	bgeu	sp,et,8112db64 <__sfvwrite_r+0x14>
8112db60:	003b68fa 	trap	3
8112db64:	28c0030b 	ldhu	r3,12(r5)
8112db68:	dd400715 	stw	r21,28(sp)
8112db6c:	dd000615 	stw	r20,24(sp)
8112db70:	dc000215 	stw	r16,8(sp)
8112db74:	dfc00b15 	stw	ra,44(sp)
8112db78:	df000a15 	stw	fp,40(sp)
8112db7c:	ddc00915 	stw	r23,36(sp)
8112db80:	dd800815 	stw	r22,32(sp)
8112db84:	dcc00515 	stw	r19,20(sp)
8112db88:	dc800415 	stw	r18,16(sp)
8112db8c:	dc400315 	stw	r17,12(sp)
8112db90:	1880020c 	andi	r2,r3,8
8112db94:	2821883a 	mov	r16,r5
8112db98:	202b883a 	mov	r21,r4
8112db9c:	3029883a 	mov	r20,r6
8112dba0:	10002726 	beq	r2,zero,8112dc40 <__sfvwrite_r+0xf0>
8112dba4:	28800417 	ldw	r2,16(r5)
8112dba8:	10002526 	beq	r2,zero,8112dc40 <__sfvwrite_r+0xf0>
8112dbac:	1880008c 	andi	r2,r3,2
8112dbb0:	a4400017 	ldw	r17,0(r20)
8112dbb4:	10002a26 	beq	r2,zero,8112dc60 <__sfvwrite_r+0x110>
8112dbb8:	05a00034 	movhi	r22,32768
8112dbbc:	0027883a 	mov	r19,zero
8112dbc0:	0025883a 	mov	r18,zero
8112dbc4:	b5bf0004 	addi	r22,r22,-1024
8112dbc8:	980d883a 	mov	r6,r19
8112dbcc:	a809883a 	mov	r4,r21
8112dbd0:	90004626 	beq	r18,zero,8112dcec <__sfvwrite_r+0x19c>
8112dbd4:	900f883a 	mov	r7,r18
8112dbd8:	b480022e 	bgeu	r22,r18,8112dbe4 <__sfvwrite_r+0x94>
8112dbdc:	01e00034 	movhi	r7,32768
8112dbe0:	39ff0004 	addi	r7,r7,-1024
8112dbe4:	80800917 	ldw	r2,36(r16)
8112dbe8:	81400717 	ldw	r5,28(r16)
8112dbec:	103ee83a 	callr	r2
8112dbf0:	0080570e 	bge	zero,r2,8112dd50 <__sfvwrite_r+0x200>
8112dbf4:	a0c00217 	ldw	r3,8(r20)
8112dbf8:	98a7883a 	add	r19,r19,r2
8112dbfc:	90a5c83a 	sub	r18,r18,r2
8112dc00:	1885c83a 	sub	r2,r3,r2
8112dc04:	a0800215 	stw	r2,8(r20)
8112dc08:	103fef1e 	bne	r2,zero,8112dbc8 <__reset+0xfb10dbc8>
8112dc0c:	0005883a 	mov	r2,zero
8112dc10:	dfc00b17 	ldw	ra,44(sp)
8112dc14:	df000a17 	ldw	fp,40(sp)
8112dc18:	ddc00917 	ldw	r23,36(sp)
8112dc1c:	dd800817 	ldw	r22,32(sp)
8112dc20:	dd400717 	ldw	r21,28(sp)
8112dc24:	dd000617 	ldw	r20,24(sp)
8112dc28:	dcc00517 	ldw	r19,20(sp)
8112dc2c:	dc800417 	ldw	r18,16(sp)
8112dc30:	dc400317 	ldw	r17,12(sp)
8112dc34:	dc000217 	ldw	r16,8(sp)
8112dc38:	dec00c04 	addi	sp,sp,48
8112dc3c:	f800283a 	ret
8112dc40:	800b883a 	mov	r5,r16
8112dc44:	a809883a 	mov	r4,r21
8112dc48:	112b3300 	call	8112b330 <__swsetup_r>
8112dc4c:	1000eb1e 	bne	r2,zero,8112dffc <__sfvwrite_r+0x4ac>
8112dc50:	80c0030b 	ldhu	r3,12(r16)
8112dc54:	a4400017 	ldw	r17,0(r20)
8112dc58:	1880008c 	andi	r2,r3,2
8112dc5c:	103fd61e 	bne	r2,zero,8112dbb8 <__reset+0xfb10dbb8>
8112dc60:	1880004c 	andi	r2,r3,1
8112dc64:	10003f1e 	bne	r2,zero,8112dd64 <__sfvwrite_r+0x214>
8112dc68:	0039883a 	mov	fp,zero
8112dc6c:	0025883a 	mov	r18,zero
8112dc70:	90001a26 	beq	r18,zero,8112dcdc <__sfvwrite_r+0x18c>
8112dc74:	1880800c 	andi	r2,r3,512
8112dc78:	84c00217 	ldw	r19,8(r16)
8112dc7c:	10002126 	beq	r2,zero,8112dd04 <__sfvwrite_r+0x1b4>
8112dc80:	982f883a 	mov	r23,r19
8112dc84:	94c09336 	bltu	r18,r19,8112ded4 <__sfvwrite_r+0x384>
8112dc88:	1881200c 	andi	r2,r3,1152
8112dc8c:	10009e1e 	bne	r2,zero,8112df08 <__sfvwrite_r+0x3b8>
8112dc90:	81000017 	ldw	r4,0(r16)
8112dc94:	b80d883a 	mov	r6,r23
8112dc98:	e00b883a 	mov	r5,fp
8112dc9c:	112e6ac0 	call	8112e6ac <memmove>
8112dca0:	80c00217 	ldw	r3,8(r16)
8112dca4:	81000017 	ldw	r4,0(r16)
8112dca8:	9005883a 	mov	r2,r18
8112dcac:	1ce7c83a 	sub	r19,r3,r19
8112dcb0:	25cf883a 	add	r7,r4,r23
8112dcb4:	84c00215 	stw	r19,8(r16)
8112dcb8:	81c00015 	stw	r7,0(r16)
8112dcbc:	a0c00217 	ldw	r3,8(r20)
8112dcc0:	e0b9883a 	add	fp,fp,r2
8112dcc4:	90a5c83a 	sub	r18,r18,r2
8112dcc8:	18a7c83a 	sub	r19,r3,r2
8112dccc:	a4c00215 	stw	r19,8(r20)
8112dcd0:	983fce26 	beq	r19,zero,8112dc0c <__reset+0xfb10dc0c>
8112dcd4:	80c0030b 	ldhu	r3,12(r16)
8112dcd8:	903fe61e 	bne	r18,zero,8112dc74 <__reset+0xfb10dc74>
8112dcdc:	8f000017 	ldw	fp,0(r17)
8112dce0:	8c800117 	ldw	r18,4(r17)
8112dce4:	8c400204 	addi	r17,r17,8
8112dce8:	003fe106 	br	8112dc70 <__reset+0xfb10dc70>
8112dcec:	8cc00017 	ldw	r19,0(r17)
8112dcf0:	8c800117 	ldw	r18,4(r17)
8112dcf4:	8c400204 	addi	r17,r17,8
8112dcf8:	003fb306 	br	8112dbc8 <__reset+0xfb10dbc8>
8112dcfc:	0005883a 	mov	r2,zero
8112dd00:	f800283a 	ret
8112dd04:	81000017 	ldw	r4,0(r16)
8112dd08:	80800417 	ldw	r2,16(r16)
8112dd0c:	11005736 	bltu	r2,r4,8112de6c <__sfvwrite_r+0x31c>
8112dd10:	85c00517 	ldw	r23,20(r16)
8112dd14:	95c05536 	bltu	r18,r23,8112de6c <__sfvwrite_r+0x31c>
8112dd18:	00a00034 	movhi	r2,32768
8112dd1c:	10bfffc4 	addi	r2,r2,-1
8112dd20:	9009883a 	mov	r4,r18
8112dd24:	1480012e 	bgeu	r2,r18,8112dd2c <__sfvwrite_r+0x1dc>
8112dd28:	1009883a 	mov	r4,r2
8112dd2c:	b80b883a 	mov	r5,r23
8112dd30:	11367640 	call	81136764 <__divsi3>
8112dd34:	15cf383a 	mul	r7,r2,r23
8112dd38:	81400717 	ldw	r5,28(r16)
8112dd3c:	80800917 	ldw	r2,36(r16)
8112dd40:	e00d883a 	mov	r6,fp
8112dd44:	a809883a 	mov	r4,r21
8112dd48:	103ee83a 	callr	r2
8112dd4c:	00bfdb16 	blt	zero,r2,8112dcbc <__reset+0xfb10dcbc>
8112dd50:	8080030b 	ldhu	r2,12(r16)
8112dd54:	10801014 	ori	r2,r2,64
8112dd58:	8080030d 	sth	r2,12(r16)
8112dd5c:	00bfffc4 	movi	r2,-1
8112dd60:	003fab06 	br	8112dc10 <__reset+0xfb10dc10>
8112dd64:	0027883a 	mov	r19,zero
8112dd68:	0011883a 	mov	r8,zero
8112dd6c:	0039883a 	mov	fp,zero
8112dd70:	0025883a 	mov	r18,zero
8112dd74:	90001f26 	beq	r18,zero,8112ddf4 <__sfvwrite_r+0x2a4>
8112dd78:	40005a26 	beq	r8,zero,8112dee4 <__sfvwrite_r+0x394>
8112dd7c:	982d883a 	mov	r22,r19
8112dd80:	94c0012e 	bgeu	r18,r19,8112dd88 <__sfvwrite_r+0x238>
8112dd84:	902d883a 	mov	r22,r18
8112dd88:	81000017 	ldw	r4,0(r16)
8112dd8c:	80800417 	ldw	r2,16(r16)
8112dd90:	b02f883a 	mov	r23,r22
8112dd94:	81c00517 	ldw	r7,20(r16)
8112dd98:	1100032e 	bgeu	r2,r4,8112dda8 <__sfvwrite_r+0x258>
8112dd9c:	80c00217 	ldw	r3,8(r16)
8112dda0:	38c7883a 	add	r3,r7,r3
8112dda4:	1d801816 	blt	r3,r22,8112de08 <__sfvwrite_r+0x2b8>
8112dda8:	b1c03e16 	blt	r22,r7,8112dea4 <__sfvwrite_r+0x354>
8112ddac:	80800917 	ldw	r2,36(r16)
8112ddb0:	81400717 	ldw	r5,28(r16)
8112ddb4:	e00d883a 	mov	r6,fp
8112ddb8:	da000115 	stw	r8,4(sp)
8112ddbc:	a809883a 	mov	r4,r21
8112ddc0:	103ee83a 	callr	r2
8112ddc4:	102f883a 	mov	r23,r2
8112ddc8:	da000117 	ldw	r8,4(sp)
8112ddcc:	00bfe00e 	bge	zero,r2,8112dd50 <__reset+0xfb10dd50>
8112ddd0:	9de7c83a 	sub	r19,r19,r23
8112ddd4:	98001f26 	beq	r19,zero,8112de54 <__sfvwrite_r+0x304>
8112ddd8:	a0800217 	ldw	r2,8(r20)
8112dddc:	e5f9883a 	add	fp,fp,r23
8112dde0:	95e5c83a 	sub	r18,r18,r23
8112dde4:	15efc83a 	sub	r23,r2,r23
8112dde8:	a5c00215 	stw	r23,8(r20)
8112ddec:	b83f8726 	beq	r23,zero,8112dc0c <__reset+0xfb10dc0c>
8112ddf0:	903fe11e 	bne	r18,zero,8112dd78 <__reset+0xfb10dd78>
8112ddf4:	8f000017 	ldw	fp,0(r17)
8112ddf8:	8c800117 	ldw	r18,4(r17)
8112ddfc:	0011883a 	mov	r8,zero
8112de00:	8c400204 	addi	r17,r17,8
8112de04:	003fdb06 	br	8112dd74 <__reset+0xfb10dd74>
8112de08:	180d883a 	mov	r6,r3
8112de0c:	e00b883a 	mov	r5,fp
8112de10:	da000115 	stw	r8,4(sp)
8112de14:	d8c00015 	stw	r3,0(sp)
8112de18:	112e6ac0 	call	8112e6ac <memmove>
8112de1c:	d8c00017 	ldw	r3,0(sp)
8112de20:	80800017 	ldw	r2,0(r16)
8112de24:	800b883a 	mov	r5,r16
8112de28:	a809883a 	mov	r4,r21
8112de2c:	10c5883a 	add	r2,r2,r3
8112de30:	80800015 	stw	r2,0(r16)
8112de34:	d8c00015 	stw	r3,0(sp)
8112de38:	112cfa40 	call	8112cfa4 <_fflush_r>
8112de3c:	d8c00017 	ldw	r3,0(sp)
8112de40:	da000117 	ldw	r8,4(sp)
8112de44:	103fc21e 	bne	r2,zero,8112dd50 <__reset+0xfb10dd50>
8112de48:	182f883a 	mov	r23,r3
8112de4c:	9de7c83a 	sub	r19,r19,r23
8112de50:	983fe11e 	bne	r19,zero,8112ddd8 <__reset+0xfb10ddd8>
8112de54:	800b883a 	mov	r5,r16
8112de58:	a809883a 	mov	r4,r21
8112de5c:	112cfa40 	call	8112cfa4 <_fflush_r>
8112de60:	103fbb1e 	bne	r2,zero,8112dd50 <__reset+0xfb10dd50>
8112de64:	0011883a 	mov	r8,zero
8112de68:	003fdb06 	br	8112ddd8 <__reset+0xfb10ddd8>
8112de6c:	94c0012e 	bgeu	r18,r19,8112de74 <__sfvwrite_r+0x324>
8112de70:	9027883a 	mov	r19,r18
8112de74:	980d883a 	mov	r6,r19
8112de78:	e00b883a 	mov	r5,fp
8112de7c:	112e6ac0 	call	8112e6ac <memmove>
8112de80:	80800217 	ldw	r2,8(r16)
8112de84:	80c00017 	ldw	r3,0(r16)
8112de88:	14c5c83a 	sub	r2,r2,r19
8112de8c:	1cc7883a 	add	r3,r3,r19
8112de90:	80800215 	stw	r2,8(r16)
8112de94:	80c00015 	stw	r3,0(r16)
8112de98:	10004326 	beq	r2,zero,8112dfa8 <__sfvwrite_r+0x458>
8112de9c:	9805883a 	mov	r2,r19
8112dea0:	003f8606 	br	8112dcbc <__reset+0xfb10dcbc>
8112dea4:	b00d883a 	mov	r6,r22
8112dea8:	e00b883a 	mov	r5,fp
8112deac:	da000115 	stw	r8,4(sp)
8112deb0:	112e6ac0 	call	8112e6ac <memmove>
8112deb4:	80800217 	ldw	r2,8(r16)
8112deb8:	80c00017 	ldw	r3,0(r16)
8112debc:	da000117 	ldw	r8,4(sp)
8112dec0:	1585c83a 	sub	r2,r2,r22
8112dec4:	1dad883a 	add	r22,r3,r22
8112dec8:	80800215 	stw	r2,8(r16)
8112decc:	85800015 	stw	r22,0(r16)
8112ded0:	003fbf06 	br	8112ddd0 <__reset+0xfb10ddd0>
8112ded4:	81000017 	ldw	r4,0(r16)
8112ded8:	9027883a 	mov	r19,r18
8112dedc:	902f883a 	mov	r23,r18
8112dee0:	003f6c06 	br	8112dc94 <__reset+0xfb10dc94>
8112dee4:	900d883a 	mov	r6,r18
8112dee8:	01400284 	movi	r5,10
8112deec:	e009883a 	mov	r4,fp
8112def0:	112e5c80 	call	8112e5c8 <memchr>
8112def4:	10003e26 	beq	r2,zero,8112dff0 <__sfvwrite_r+0x4a0>
8112def8:	10800044 	addi	r2,r2,1
8112defc:	1727c83a 	sub	r19,r2,fp
8112df00:	02000044 	movi	r8,1
8112df04:	003f9d06 	br	8112dd7c <__reset+0xfb10dd7c>
8112df08:	80800517 	ldw	r2,20(r16)
8112df0c:	81400417 	ldw	r5,16(r16)
8112df10:	81c00017 	ldw	r7,0(r16)
8112df14:	10a7883a 	add	r19,r2,r2
8112df18:	9885883a 	add	r2,r19,r2
8112df1c:	1026d7fa 	srli	r19,r2,31
8112df20:	396dc83a 	sub	r22,r7,r5
8112df24:	b1000044 	addi	r4,r22,1
8112df28:	9885883a 	add	r2,r19,r2
8112df2c:	1027d07a 	srai	r19,r2,1
8112df30:	2485883a 	add	r2,r4,r18
8112df34:	980d883a 	mov	r6,r19
8112df38:	9880022e 	bgeu	r19,r2,8112df44 <__sfvwrite_r+0x3f4>
8112df3c:	1027883a 	mov	r19,r2
8112df40:	100d883a 	mov	r6,r2
8112df44:	18c1000c 	andi	r3,r3,1024
8112df48:	18001c26 	beq	r3,zero,8112dfbc <__sfvwrite_r+0x46c>
8112df4c:	300b883a 	mov	r5,r6
8112df50:	a809883a 	mov	r4,r21
8112df54:	1123b3c0 	call	81123b3c <_malloc_r>
8112df58:	102f883a 	mov	r23,r2
8112df5c:	10002926 	beq	r2,zero,8112e004 <__sfvwrite_r+0x4b4>
8112df60:	81400417 	ldw	r5,16(r16)
8112df64:	b00d883a 	mov	r6,r22
8112df68:	1009883a 	mov	r4,r2
8112df6c:	11243500 	call	81124350 <memcpy>
8112df70:	8080030b 	ldhu	r2,12(r16)
8112df74:	00fedfc4 	movi	r3,-1153
8112df78:	10c4703a 	and	r2,r2,r3
8112df7c:	10802014 	ori	r2,r2,128
8112df80:	8080030d 	sth	r2,12(r16)
8112df84:	bd89883a 	add	r4,r23,r22
8112df88:	9d8fc83a 	sub	r7,r19,r22
8112df8c:	85c00415 	stw	r23,16(r16)
8112df90:	84c00515 	stw	r19,20(r16)
8112df94:	81000015 	stw	r4,0(r16)
8112df98:	9027883a 	mov	r19,r18
8112df9c:	81c00215 	stw	r7,8(r16)
8112dfa0:	902f883a 	mov	r23,r18
8112dfa4:	003f3b06 	br	8112dc94 <__reset+0xfb10dc94>
8112dfa8:	800b883a 	mov	r5,r16
8112dfac:	a809883a 	mov	r4,r21
8112dfb0:	112cfa40 	call	8112cfa4 <_fflush_r>
8112dfb4:	103fb926 	beq	r2,zero,8112de9c <__reset+0xfb10de9c>
8112dfb8:	003f6506 	br	8112dd50 <__reset+0xfb10dd50>
8112dfbc:	a809883a 	mov	r4,r21
8112dfc0:	112f8cc0 	call	8112f8cc <_realloc_r>
8112dfc4:	102f883a 	mov	r23,r2
8112dfc8:	103fee1e 	bne	r2,zero,8112df84 <__reset+0xfb10df84>
8112dfcc:	81400417 	ldw	r5,16(r16)
8112dfd0:	a809883a 	mov	r4,r21
8112dfd4:	112d8380 	call	8112d838 <_free_r>
8112dfd8:	8080030b 	ldhu	r2,12(r16)
8112dfdc:	00ffdfc4 	movi	r3,-129
8112dfe0:	1884703a 	and	r2,r3,r2
8112dfe4:	00c00304 	movi	r3,12
8112dfe8:	a8c00015 	stw	r3,0(r21)
8112dfec:	003f5906 	br	8112dd54 <__reset+0xfb10dd54>
8112dff0:	94c00044 	addi	r19,r18,1
8112dff4:	02000044 	movi	r8,1
8112dff8:	003f6006 	br	8112dd7c <__reset+0xfb10dd7c>
8112dffc:	00bfffc4 	movi	r2,-1
8112e000:	003f0306 	br	8112dc10 <__reset+0xfb10dc10>
8112e004:	00800304 	movi	r2,12
8112e008:	a8800015 	stw	r2,0(r21)
8112e00c:	8080030b 	ldhu	r2,12(r16)
8112e010:	003f5006 	br	8112dd54 <__reset+0xfb10dd54>

8112e014 <_fwalk>:
8112e014:	defff704 	addi	sp,sp,-36
8112e018:	de00012e 	bgeu	sp,et,8112e020 <_fwalk+0xc>
8112e01c:	003b68fa 	trap	3
8112e020:	dd000415 	stw	r20,16(sp)
8112e024:	dfc00815 	stw	ra,32(sp)
8112e028:	ddc00715 	stw	r23,28(sp)
8112e02c:	dd800615 	stw	r22,24(sp)
8112e030:	dd400515 	stw	r21,20(sp)
8112e034:	dcc00315 	stw	r19,12(sp)
8112e038:	dc800215 	stw	r18,8(sp)
8112e03c:	dc400115 	stw	r17,4(sp)
8112e040:	dc000015 	stw	r16,0(sp)
8112e044:	2500b804 	addi	r20,r4,736
8112e048:	a0002326 	beq	r20,zero,8112e0d8 <_fwalk+0xc4>
8112e04c:	282b883a 	mov	r21,r5
8112e050:	002f883a 	mov	r23,zero
8112e054:	05800044 	movi	r22,1
8112e058:	04ffffc4 	movi	r19,-1
8112e05c:	a4400117 	ldw	r17,4(r20)
8112e060:	a4800217 	ldw	r18,8(r20)
8112e064:	8c7fffc4 	addi	r17,r17,-1
8112e068:	88000d16 	blt	r17,zero,8112e0a0 <_fwalk+0x8c>
8112e06c:	94000304 	addi	r16,r18,12
8112e070:	94800384 	addi	r18,r18,14
8112e074:	8080000b 	ldhu	r2,0(r16)
8112e078:	8c7fffc4 	addi	r17,r17,-1
8112e07c:	813ffd04 	addi	r4,r16,-12
8112e080:	b080042e 	bgeu	r22,r2,8112e094 <_fwalk+0x80>
8112e084:	9080000f 	ldh	r2,0(r18)
8112e088:	14c00226 	beq	r2,r19,8112e094 <_fwalk+0x80>
8112e08c:	a83ee83a 	callr	r21
8112e090:	b8aeb03a 	or	r23,r23,r2
8112e094:	84001a04 	addi	r16,r16,104
8112e098:	94801a04 	addi	r18,r18,104
8112e09c:	8cfff51e 	bne	r17,r19,8112e074 <__reset+0xfb10e074>
8112e0a0:	a5000017 	ldw	r20,0(r20)
8112e0a4:	a03fed1e 	bne	r20,zero,8112e05c <__reset+0xfb10e05c>
8112e0a8:	b805883a 	mov	r2,r23
8112e0ac:	dfc00817 	ldw	ra,32(sp)
8112e0b0:	ddc00717 	ldw	r23,28(sp)
8112e0b4:	dd800617 	ldw	r22,24(sp)
8112e0b8:	dd400517 	ldw	r21,20(sp)
8112e0bc:	dd000417 	ldw	r20,16(sp)
8112e0c0:	dcc00317 	ldw	r19,12(sp)
8112e0c4:	dc800217 	ldw	r18,8(sp)
8112e0c8:	dc400117 	ldw	r17,4(sp)
8112e0cc:	dc000017 	ldw	r16,0(sp)
8112e0d0:	dec00904 	addi	sp,sp,36
8112e0d4:	f800283a 	ret
8112e0d8:	002f883a 	mov	r23,zero
8112e0dc:	003ff206 	br	8112e0a8 <__reset+0xfb10e0a8>

8112e0e0 <_fwalk_reent>:
8112e0e0:	defff704 	addi	sp,sp,-36
8112e0e4:	de00012e 	bgeu	sp,et,8112e0ec <_fwalk_reent+0xc>
8112e0e8:	003b68fa 	trap	3
8112e0ec:	dd000415 	stw	r20,16(sp)
8112e0f0:	dfc00815 	stw	ra,32(sp)
8112e0f4:	ddc00715 	stw	r23,28(sp)
8112e0f8:	dd800615 	stw	r22,24(sp)
8112e0fc:	dd400515 	stw	r21,20(sp)
8112e100:	dcc00315 	stw	r19,12(sp)
8112e104:	dc800215 	stw	r18,8(sp)
8112e108:	dc400115 	stw	r17,4(sp)
8112e10c:	dc000015 	stw	r16,0(sp)
8112e110:	2500b804 	addi	r20,r4,736
8112e114:	a0002326 	beq	r20,zero,8112e1a4 <_fwalk_reent+0xc4>
8112e118:	282b883a 	mov	r21,r5
8112e11c:	2027883a 	mov	r19,r4
8112e120:	002f883a 	mov	r23,zero
8112e124:	05800044 	movi	r22,1
8112e128:	04bfffc4 	movi	r18,-1
8112e12c:	a4400117 	ldw	r17,4(r20)
8112e130:	a4000217 	ldw	r16,8(r20)
8112e134:	8c7fffc4 	addi	r17,r17,-1
8112e138:	88000c16 	blt	r17,zero,8112e16c <_fwalk_reent+0x8c>
8112e13c:	84000304 	addi	r16,r16,12
8112e140:	8080000b 	ldhu	r2,0(r16)
8112e144:	8c7fffc4 	addi	r17,r17,-1
8112e148:	817ffd04 	addi	r5,r16,-12
8112e14c:	b080052e 	bgeu	r22,r2,8112e164 <_fwalk_reent+0x84>
8112e150:	8080008f 	ldh	r2,2(r16)
8112e154:	9809883a 	mov	r4,r19
8112e158:	14800226 	beq	r2,r18,8112e164 <_fwalk_reent+0x84>
8112e15c:	a83ee83a 	callr	r21
8112e160:	b8aeb03a 	or	r23,r23,r2
8112e164:	84001a04 	addi	r16,r16,104
8112e168:	8cbff51e 	bne	r17,r18,8112e140 <__reset+0xfb10e140>
8112e16c:	a5000017 	ldw	r20,0(r20)
8112e170:	a03fee1e 	bne	r20,zero,8112e12c <__reset+0xfb10e12c>
8112e174:	b805883a 	mov	r2,r23
8112e178:	dfc00817 	ldw	ra,32(sp)
8112e17c:	ddc00717 	ldw	r23,28(sp)
8112e180:	dd800617 	ldw	r22,24(sp)
8112e184:	dd400517 	ldw	r21,20(sp)
8112e188:	dd000417 	ldw	r20,16(sp)
8112e18c:	dcc00317 	ldw	r19,12(sp)
8112e190:	dc800217 	ldw	r18,8(sp)
8112e194:	dc400117 	ldw	r17,4(sp)
8112e198:	dc000017 	ldw	r16,0(sp)
8112e19c:	dec00904 	addi	sp,sp,36
8112e1a0:	f800283a 	ret
8112e1a4:	002f883a 	mov	r23,zero
8112e1a8:	003ff206 	br	8112e174 <__reset+0xfb10e174>

8112e1ac <_isatty_r>:
8112e1ac:	defffd04 	addi	sp,sp,-12
8112e1b0:	de00012e 	bgeu	sp,et,8112e1b8 <_isatty_r+0xc>
8112e1b4:	003b68fa 	trap	3
8112e1b8:	dc000015 	stw	r16,0(sp)
8112e1bc:	04204574 	movhi	r16,33045
8112e1c0:	dc400115 	stw	r17,4(sp)
8112e1c4:	8413d304 	addi	r16,r16,20300
8112e1c8:	2023883a 	mov	r17,r4
8112e1cc:	2809883a 	mov	r4,r5
8112e1d0:	dfc00215 	stw	ra,8(sp)
8112e1d4:	80000015 	stw	zero,0(r16)
8112e1d8:	11384540 	call	81138454 <isatty>
8112e1dc:	00ffffc4 	movi	r3,-1
8112e1e0:	10c00526 	beq	r2,r3,8112e1f8 <_isatty_r+0x4c>
8112e1e4:	dfc00217 	ldw	ra,8(sp)
8112e1e8:	dc400117 	ldw	r17,4(sp)
8112e1ec:	dc000017 	ldw	r16,0(sp)
8112e1f0:	dec00304 	addi	sp,sp,12
8112e1f4:	f800283a 	ret
8112e1f8:	80c00017 	ldw	r3,0(r16)
8112e1fc:	183ff926 	beq	r3,zero,8112e1e4 <__reset+0xfb10e1e4>
8112e200:	88c00015 	stw	r3,0(r17)
8112e204:	003ff706 	br	8112e1e4 <__reset+0xfb10e1e4>

8112e208 <iswspace>:
8112e208:	00803fc4 	movi	r2,255
8112e20c:	11000836 	bltu	r2,r4,8112e230 <iswspace+0x28>
8112e210:	00a04574 	movhi	r2,33045
8112e214:	10935e04 	addi	r2,r2,19832
8112e218:	10800017 	ldw	r2,0(r2)
8112e21c:	1109883a 	add	r4,r2,r4
8112e220:	20800043 	ldbu	r2,1(r4)
8112e224:	1080020c 	andi	r2,r2,8
8112e228:	10803fcc 	andi	r2,r2,255
8112e22c:	f800283a 	ret
8112e230:	0005883a 	mov	r2,zero
8112e234:	f800283a 	ret

8112e238 <_setlocale_r>:
8112e238:	30001d26 	beq	r6,zero,8112e2b0 <_setlocale_r+0x78>
8112e23c:	01604574 	movhi	r5,33045
8112e240:	defffe04 	addi	sp,sp,-8
8112e244:	2949b704 	addi	r5,r5,9948
8112e248:	3009883a 	mov	r4,r6
8112e24c:	de00012e 	bgeu	sp,et,8112e254 <_setlocale_r+0x1c>
8112e250:	003b68fa 	trap	3
8112e254:	dc000015 	stw	r16,0(sp)
8112e258:	dfc00115 	stw	ra,4(sp)
8112e25c:	3021883a 	mov	r16,r6
8112e260:	112ff840 	call	8112ff84 <strcmp>
8112e264:	1000061e 	bne	r2,zero,8112e280 <_setlocale_r+0x48>
8112e268:	00a04574 	movhi	r2,33045
8112e26c:	10898604 	addi	r2,r2,9752
8112e270:	dfc00117 	ldw	ra,4(sp)
8112e274:	dc000017 	ldw	r16,0(sp)
8112e278:	dec00204 	addi	sp,sp,8
8112e27c:	f800283a 	ret
8112e280:	01604574 	movhi	r5,33045
8112e284:	29498604 	addi	r5,r5,9752
8112e288:	8009883a 	mov	r4,r16
8112e28c:	112ff840 	call	8112ff84 <strcmp>
8112e290:	103ff526 	beq	r2,zero,8112e268 <__reset+0xfb10e268>
8112e294:	01604574 	movhi	r5,33045
8112e298:	29499004 	addi	r5,r5,9792
8112e29c:	8009883a 	mov	r4,r16
8112e2a0:	112ff840 	call	8112ff84 <strcmp>
8112e2a4:	103ff026 	beq	r2,zero,8112e268 <__reset+0xfb10e268>
8112e2a8:	0005883a 	mov	r2,zero
8112e2ac:	003ff006 	br	8112e270 <__reset+0xfb10e270>
8112e2b0:	00a04574 	movhi	r2,33045
8112e2b4:	10898604 	addi	r2,r2,9752
8112e2b8:	f800283a 	ret

8112e2bc <__locale_charset>:
8112e2bc:	00a04574 	movhi	r2,33045
8112e2c0:	108e2804 	addi	r2,r2,14496
8112e2c4:	f800283a 	ret

8112e2c8 <__locale_mb_cur_max>:
8112e2c8:	00a04574 	movhi	r2,33045
8112e2cc:	10936304 	addi	r2,r2,19852
8112e2d0:	10800017 	ldw	r2,0(r2)
8112e2d4:	f800283a 	ret

8112e2d8 <__locale_msgcharset>:
8112e2d8:	00a04574 	movhi	r2,33045
8112e2dc:	108e2004 	addi	r2,r2,14464
8112e2e0:	f800283a 	ret

8112e2e4 <__locale_cjk_lang>:
8112e2e4:	0005883a 	mov	r2,zero
8112e2e8:	f800283a 	ret

8112e2ec <_localeconv_r>:
8112e2ec:	00a04574 	movhi	r2,33045
8112e2f0:	108e3004 	addi	r2,r2,14528
8112e2f4:	f800283a 	ret

8112e2f8 <setlocale>:
8112e2f8:	00a04574 	movhi	r2,33045
8112e2fc:	10936004 	addi	r2,r2,19840
8112e300:	280d883a 	mov	r6,r5
8112e304:	200b883a 	mov	r5,r4
8112e308:	11000017 	ldw	r4,0(r2)
8112e30c:	112e2381 	jmpi	8112e238 <_setlocale_r>

8112e310 <localeconv>:
8112e310:	00a04574 	movhi	r2,33045
8112e314:	108e3004 	addi	r2,r2,14528
8112e318:	f800283a 	ret

8112e31c <_lseek_r>:
8112e31c:	defffd04 	addi	sp,sp,-12
8112e320:	de00012e 	bgeu	sp,et,8112e328 <_lseek_r+0xc>
8112e324:	003b68fa 	trap	3
8112e328:	2805883a 	mov	r2,r5
8112e32c:	dc000015 	stw	r16,0(sp)
8112e330:	04204574 	movhi	r16,33045
8112e334:	dc400115 	stw	r17,4(sp)
8112e338:	300b883a 	mov	r5,r6
8112e33c:	8413d304 	addi	r16,r16,20300
8112e340:	2023883a 	mov	r17,r4
8112e344:	380d883a 	mov	r6,r7
8112e348:	1009883a 	mov	r4,r2
8112e34c:	dfc00215 	stw	ra,8(sp)
8112e350:	80000015 	stw	zero,0(r16)
8112e354:	11390500 	call	81139050 <lseek>
8112e358:	00ffffc4 	movi	r3,-1
8112e35c:	10c00526 	beq	r2,r3,8112e374 <_lseek_r+0x58>
8112e360:	dfc00217 	ldw	ra,8(sp)
8112e364:	dc400117 	ldw	r17,4(sp)
8112e368:	dc000017 	ldw	r16,0(sp)
8112e36c:	dec00304 	addi	sp,sp,12
8112e370:	f800283a 	ret
8112e374:	80c00017 	ldw	r3,0(r16)
8112e378:	183ff926 	beq	r3,zero,8112e360 <__reset+0xfb10e360>
8112e37c:	88c00015 	stw	r3,0(r17)
8112e380:	003ff706 	br	8112e360 <__reset+0xfb10e360>

8112e384 <_mbrtowc_r>:
8112e384:	defff704 	addi	sp,sp,-36
8112e388:	00a04574 	movhi	r2,33045
8112e38c:	de00012e 	bgeu	sp,et,8112e394 <_mbrtowc_r+0x10>
8112e390:	003b68fa 	trap	3
8112e394:	10936404 	addi	r2,r2,19856
8112e398:	dc800715 	stw	r18,28(sp)
8112e39c:	dc400615 	stw	r17,24(sp)
8112e3a0:	dc000515 	stw	r16,20(sp)
8112e3a4:	dfc00815 	stw	ra,32(sp)
8112e3a8:	2021883a 	mov	r16,r4
8112e3ac:	dc400917 	ldw	r17,36(sp)
8112e3b0:	14800017 	ldw	r18,0(r2)
8112e3b4:	30001626 	beq	r6,zero,8112e410 <_mbrtowc_r+0x8c>
8112e3b8:	d9400215 	stw	r5,8(sp)
8112e3bc:	d9800315 	stw	r6,12(sp)
8112e3c0:	d9c00415 	stw	r7,16(sp)
8112e3c4:	112e2bc0 	call	8112e2bc <__locale_charset>
8112e3c8:	d9c00417 	ldw	r7,16(sp)
8112e3cc:	d9800317 	ldw	r6,12(sp)
8112e3d0:	d9400217 	ldw	r5,8(sp)
8112e3d4:	d8800015 	stw	r2,0(sp)
8112e3d8:	dc400115 	stw	r17,4(sp)
8112e3dc:	8009883a 	mov	r4,r16
8112e3e0:	903ee83a 	callr	r18
8112e3e4:	00ffffc4 	movi	r3,-1
8112e3e8:	10c0031e 	bne	r2,r3,8112e3f8 <_mbrtowc_r+0x74>
8112e3ec:	88000015 	stw	zero,0(r17)
8112e3f0:	00c02284 	movi	r3,138
8112e3f4:	80c00015 	stw	r3,0(r16)
8112e3f8:	dfc00817 	ldw	ra,32(sp)
8112e3fc:	dc800717 	ldw	r18,28(sp)
8112e400:	dc400617 	ldw	r17,24(sp)
8112e404:	dc000517 	ldw	r16,20(sp)
8112e408:	dec00904 	addi	sp,sp,36
8112e40c:	f800283a 	ret
8112e410:	112e2bc0 	call	8112e2bc <__locale_charset>
8112e414:	01a04574 	movhi	r6,33045
8112e418:	31899004 	addi	r6,r6,9792
8112e41c:	dc400115 	stw	r17,4(sp)
8112e420:	d8800015 	stw	r2,0(sp)
8112e424:	01c00044 	movi	r7,1
8112e428:	000b883a 	mov	r5,zero
8112e42c:	8009883a 	mov	r4,r16
8112e430:	903ee83a 	callr	r18
8112e434:	003feb06 	br	8112e3e4 <__reset+0xfb10e3e4>

8112e438 <mbrtowc>:
8112e438:	defff704 	addi	sp,sp,-36
8112e43c:	00a04574 	movhi	r2,33045
8112e440:	de00012e 	bgeu	sp,et,8112e448 <mbrtowc+0x10>
8112e444:	003b68fa 	trap	3
8112e448:	10936004 	addi	r2,r2,19840
8112e44c:	dc800415 	stw	r18,16(sp)
8112e450:	dc400315 	stw	r17,12(sp)
8112e454:	dfc00815 	stw	ra,32(sp)
8112e458:	dd400715 	stw	r21,28(sp)
8112e45c:	dd000615 	stw	r20,24(sp)
8112e460:	dcc00515 	stw	r19,20(sp)
8112e464:	dc000215 	stw	r16,8(sp)
8112e468:	3825883a 	mov	r18,r7
8112e46c:	14400017 	ldw	r17,0(r2)
8112e470:	28001c26 	beq	r5,zero,8112e4e4 <mbrtowc+0xac>
8112e474:	00a04574 	movhi	r2,33045
8112e478:	10936404 	addi	r2,r2,19856
8112e47c:	15400017 	ldw	r21,0(r2)
8112e480:	2821883a 	mov	r16,r5
8112e484:	2027883a 	mov	r19,r4
8112e488:	3029883a 	mov	r20,r6
8112e48c:	112e2bc0 	call	8112e2bc <__locale_charset>
8112e490:	d8800015 	stw	r2,0(sp)
8112e494:	dc800115 	stw	r18,4(sp)
8112e498:	a00f883a 	mov	r7,r20
8112e49c:	800d883a 	mov	r6,r16
8112e4a0:	980b883a 	mov	r5,r19
8112e4a4:	8809883a 	mov	r4,r17
8112e4a8:	a83ee83a 	callr	r21
8112e4ac:	00ffffc4 	movi	r3,-1
8112e4b0:	10c0031e 	bne	r2,r3,8112e4c0 <mbrtowc+0x88>
8112e4b4:	90000015 	stw	zero,0(r18)
8112e4b8:	00c02284 	movi	r3,138
8112e4bc:	88c00015 	stw	r3,0(r17)
8112e4c0:	dfc00817 	ldw	ra,32(sp)
8112e4c4:	dd400717 	ldw	r21,28(sp)
8112e4c8:	dd000617 	ldw	r20,24(sp)
8112e4cc:	dcc00517 	ldw	r19,20(sp)
8112e4d0:	dc800417 	ldw	r18,16(sp)
8112e4d4:	dc400317 	ldw	r17,12(sp)
8112e4d8:	dc000217 	ldw	r16,8(sp)
8112e4dc:	dec00904 	addi	sp,sp,36
8112e4e0:	f800283a 	ret
8112e4e4:	00a04574 	movhi	r2,33045
8112e4e8:	10936404 	addi	r2,r2,19856
8112e4ec:	14000017 	ldw	r16,0(r2)
8112e4f0:	112e2bc0 	call	8112e2bc <__locale_charset>
8112e4f4:	01a04574 	movhi	r6,33045
8112e4f8:	31899004 	addi	r6,r6,9792
8112e4fc:	dc800115 	stw	r18,4(sp)
8112e500:	d8800015 	stw	r2,0(sp)
8112e504:	01c00044 	movi	r7,1
8112e508:	000b883a 	mov	r5,zero
8112e50c:	8809883a 	mov	r4,r17
8112e510:	803ee83a 	callr	r16
8112e514:	003fe506 	br	8112e4ac <__reset+0xfb10e4ac>

8112e518 <__ascii_mbtowc>:
8112e518:	deffff04 	addi	sp,sp,-4
8112e51c:	de00012e 	bgeu	sp,et,8112e524 <__ascii_mbtowc+0xc>
8112e520:	003b68fa 	trap	3
8112e524:	28000826 	beq	r5,zero,8112e548 <__ascii_mbtowc+0x30>
8112e528:	30000926 	beq	r6,zero,8112e550 <__ascii_mbtowc+0x38>
8112e52c:	38000b26 	beq	r7,zero,8112e55c <__ascii_mbtowc+0x44>
8112e530:	30800003 	ldbu	r2,0(r6)
8112e534:	28800015 	stw	r2,0(r5)
8112e538:	30800003 	ldbu	r2,0(r6)
8112e53c:	1004c03a 	cmpne	r2,r2,zero
8112e540:	dec00104 	addi	sp,sp,4
8112e544:	f800283a 	ret
8112e548:	d80b883a 	mov	r5,sp
8112e54c:	303ff71e 	bne	r6,zero,8112e52c <__reset+0xfb10e52c>
8112e550:	0005883a 	mov	r2,zero
8112e554:	dec00104 	addi	sp,sp,4
8112e558:	f800283a 	ret
8112e55c:	00bfff84 	movi	r2,-2
8112e560:	003ff706 	br	8112e540 <__reset+0xfb10e540>

8112e564 <_mbtowc_r>:
8112e564:	00a04574 	movhi	r2,33045
8112e568:	defff804 	addi	sp,sp,-32
8112e56c:	10936404 	addi	r2,r2,19856
8112e570:	de00012e 	bgeu	sp,et,8112e578 <_mbtowc_r+0x14>
8112e574:	003b68fa 	trap	3
8112e578:	dfc00715 	stw	ra,28(sp)
8112e57c:	dc000615 	stw	r16,24(sp)
8112e580:	14000017 	ldw	r16,0(r2)
8112e584:	d9000215 	stw	r4,8(sp)
8112e588:	d9400315 	stw	r5,12(sp)
8112e58c:	d9800415 	stw	r6,16(sp)
8112e590:	d9c00515 	stw	r7,20(sp)
8112e594:	112e2bc0 	call	8112e2bc <__locale_charset>
8112e598:	d8800015 	stw	r2,0(sp)
8112e59c:	d8800817 	ldw	r2,32(sp)
8112e5a0:	d9c00517 	ldw	r7,20(sp)
8112e5a4:	d9800417 	ldw	r6,16(sp)
8112e5a8:	d9400317 	ldw	r5,12(sp)
8112e5ac:	d9000217 	ldw	r4,8(sp)
8112e5b0:	d8800115 	stw	r2,4(sp)
8112e5b4:	803ee83a 	callr	r16
8112e5b8:	dfc00717 	ldw	ra,28(sp)
8112e5bc:	dc000617 	ldw	r16,24(sp)
8112e5c0:	dec00804 	addi	sp,sp,32
8112e5c4:	f800283a 	ret

8112e5c8 <memchr>:
8112e5c8:	208000cc 	andi	r2,r4,3
8112e5cc:	280f883a 	mov	r7,r5
8112e5d0:	10003426 	beq	r2,zero,8112e6a4 <memchr+0xdc>
8112e5d4:	30bfffc4 	addi	r2,r6,-1
8112e5d8:	30001a26 	beq	r6,zero,8112e644 <memchr+0x7c>
8112e5dc:	20c00003 	ldbu	r3,0(r4)
8112e5e0:	29803fcc 	andi	r6,r5,255
8112e5e4:	30c0051e 	bne	r6,r3,8112e5fc <memchr+0x34>
8112e5e8:	00001806 	br	8112e64c <memchr+0x84>
8112e5ec:	10001526 	beq	r2,zero,8112e644 <memchr+0x7c>
8112e5f0:	20c00003 	ldbu	r3,0(r4)
8112e5f4:	10bfffc4 	addi	r2,r2,-1
8112e5f8:	30c01426 	beq	r6,r3,8112e64c <memchr+0x84>
8112e5fc:	21000044 	addi	r4,r4,1
8112e600:	20c000cc 	andi	r3,r4,3
8112e604:	183ff91e 	bne	r3,zero,8112e5ec <__reset+0xfb10e5ec>
8112e608:	020000c4 	movi	r8,3
8112e60c:	40801136 	bltu	r8,r2,8112e654 <memchr+0x8c>
8112e610:	10000c26 	beq	r2,zero,8112e644 <memchr+0x7c>
8112e614:	20c00003 	ldbu	r3,0(r4)
8112e618:	29403fcc 	andi	r5,r5,255
8112e61c:	28c00b26 	beq	r5,r3,8112e64c <memchr+0x84>
8112e620:	20c00044 	addi	r3,r4,1
8112e624:	39803fcc 	andi	r6,r7,255
8112e628:	2089883a 	add	r4,r4,r2
8112e62c:	00000306 	br	8112e63c <memchr+0x74>
8112e630:	18c00044 	addi	r3,r3,1
8112e634:	197fffc3 	ldbu	r5,-1(r3)
8112e638:	31400526 	beq	r6,r5,8112e650 <memchr+0x88>
8112e63c:	1805883a 	mov	r2,r3
8112e640:	20fffb1e 	bne	r4,r3,8112e630 <__reset+0xfb10e630>
8112e644:	0005883a 	mov	r2,zero
8112e648:	f800283a 	ret
8112e64c:	2005883a 	mov	r2,r4
8112e650:	f800283a 	ret
8112e654:	28c03fcc 	andi	r3,r5,255
8112e658:	1812923a 	slli	r9,r3,8
8112e65c:	02ffbff4 	movhi	r11,65279
8112e660:	02a02074 	movhi	r10,32897
8112e664:	48d2b03a 	or	r9,r9,r3
8112e668:	4806943a 	slli	r3,r9,16
8112e66c:	5affbfc4 	addi	r11,r11,-257
8112e670:	52a02004 	addi	r10,r10,-32640
8112e674:	48d2b03a 	or	r9,r9,r3
8112e678:	20c00017 	ldw	r3,0(r4)
8112e67c:	48c6f03a 	xor	r3,r9,r3
8112e680:	1acd883a 	add	r6,r3,r11
8112e684:	00c6303a 	nor	r3,zero,r3
8112e688:	30c6703a 	and	r3,r6,r3
8112e68c:	1a86703a 	and	r3,r3,r10
8112e690:	183fe01e 	bne	r3,zero,8112e614 <__reset+0xfb10e614>
8112e694:	10bfff04 	addi	r2,r2,-4
8112e698:	21000104 	addi	r4,r4,4
8112e69c:	40bff636 	bltu	r8,r2,8112e678 <__reset+0xfb10e678>
8112e6a0:	003fdb06 	br	8112e610 <__reset+0xfb10e610>
8112e6a4:	3005883a 	mov	r2,r6
8112e6a8:	003fd706 	br	8112e608 <__reset+0xfb10e608>

8112e6ac <memmove>:
8112e6ac:	2005883a 	mov	r2,r4
8112e6b0:	29000b2e 	bgeu	r5,r4,8112e6e0 <memmove+0x34>
8112e6b4:	298f883a 	add	r7,r5,r6
8112e6b8:	21c0092e 	bgeu	r4,r7,8112e6e0 <memmove+0x34>
8112e6bc:	2187883a 	add	r3,r4,r6
8112e6c0:	198bc83a 	sub	r5,r3,r6
8112e6c4:	30004826 	beq	r6,zero,8112e7e8 <memmove+0x13c>
8112e6c8:	39ffffc4 	addi	r7,r7,-1
8112e6cc:	39000003 	ldbu	r4,0(r7)
8112e6d0:	18ffffc4 	addi	r3,r3,-1
8112e6d4:	19000005 	stb	r4,0(r3)
8112e6d8:	28fffb1e 	bne	r5,r3,8112e6c8 <__reset+0xfb10e6c8>
8112e6dc:	f800283a 	ret
8112e6e0:	00c003c4 	movi	r3,15
8112e6e4:	1980412e 	bgeu	r3,r6,8112e7ec <memmove+0x140>
8112e6e8:	2886b03a 	or	r3,r5,r2
8112e6ec:	18c000cc 	andi	r3,r3,3
8112e6f0:	1800401e 	bne	r3,zero,8112e7f4 <memmove+0x148>
8112e6f4:	33fffc04 	addi	r15,r6,-16
8112e6f8:	781ed13a 	srli	r15,r15,4
8112e6fc:	28c00104 	addi	r3,r5,4
8112e700:	13400104 	addi	r13,r2,4
8112e704:	781c913a 	slli	r14,r15,4
8112e708:	2b000204 	addi	r12,r5,8
8112e70c:	12c00204 	addi	r11,r2,8
8112e710:	73800504 	addi	r14,r14,20
8112e714:	2a800304 	addi	r10,r5,12
8112e718:	12400304 	addi	r9,r2,12
8112e71c:	2b9d883a 	add	r14,r5,r14
8112e720:	2811883a 	mov	r8,r5
8112e724:	100f883a 	mov	r7,r2
8112e728:	41000017 	ldw	r4,0(r8)
8112e72c:	39c00404 	addi	r7,r7,16
8112e730:	18c00404 	addi	r3,r3,16
8112e734:	393ffc15 	stw	r4,-16(r7)
8112e738:	193ffc17 	ldw	r4,-16(r3)
8112e73c:	6b400404 	addi	r13,r13,16
8112e740:	5ac00404 	addi	r11,r11,16
8112e744:	693ffc15 	stw	r4,-16(r13)
8112e748:	61000017 	ldw	r4,0(r12)
8112e74c:	4a400404 	addi	r9,r9,16
8112e750:	42000404 	addi	r8,r8,16
8112e754:	593ffc15 	stw	r4,-16(r11)
8112e758:	51000017 	ldw	r4,0(r10)
8112e75c:	63000404 	addi	r12,r12,16
8112e760:	52800404 	addi	r10,r10,16
8112e764:	493ffc15 	stw	r4,-16(r9)
8112e768:	1bbfef1e 	bne	r3,r14,8112e728 <__reset+0xfb10e728>
8112e76c:	79000044 	addi	r4,r15,1
8112e770:	2008913a 	slli	r4,r4,4
8112e774:	328003cc 	andi	r10,r6,15
8112e778:	02c000c4 	movi	r11,3
8112e77c:	1107883a 	add	r3,r2,r4
8112e780:	290b883a 	add	r5,r5,r4
8112e784:	5a801e2e 	bgeu	r11,r10,8112e800 <memmove+0x154>
8112e788:	1813883a 	mov	r9,r3
8112e78c:	2811883a 	mov	r8,r5
8112e790:	500f883a 	mov	r7,r10
8112e794:	41000017 	ldw	r4,0(r8)
8112e798:	4a400104 	addi	r9,r9,4
8112e79c:	39ffff04 	addi	r7,r7,-4
8112e7a0:	493fff15 	stw	r4,-4(r9)
8112e7a4:	42000104 	addi	r8,r8,4
8112e7a8:	59fffa36 	bltu	r11,r7,8112e794 <__reset+0xfb10e794>
8112e7ac:	513fff04 	addi	r4,r10,-4
8112e7b0:	2008d0ba 	srli	r4,r4,2
8112e7b4:	318000cc 	andi	r6,r6,3
8112e7b8:	21000044 	addi	r4,r4,1
8112e7bc:	2109883a 	add	r4,r4,r4
8112e7c0:	2109883a 	add	r4,r4,r4
8112e7c4:	1907883a 	add	r3,r3,r4
8112e7c8:	290b883a 	add	r5,r5,r4
8112e7cc:	30000b26 	beq	r6,zero,8112e7fc <memmove+0x150>
8112e7d0:	198d883a 	add	r6,r3,r6
8112e7d4:	29c00003 	ldbu	r7,0(r5)
8112e7d8:	18c00044 	addi	r3,r3,1
8112e7dc:	29400044 	addi	r5,r5,1
8112e7e0:	19ffffc5 	stb	r7,-1(r3)
8112e7e4:	19bffb1e 	bne	r3,r6,8112e7d4 <__reset+0xfb10e7d4>
8112e7e8:	f800283a 	ret
8112e7ec:	1007883a 	mov	r3,r2
8112e7f0:	003ff606 	br	8112e7cc <__reset+0xfb10e7cc>
8112e7f4:	1007883a 	mov	r3,r2
8112e7f8:	003ff506 	br	8112e7d0 <__reset+0xfb10e7d0>
8112e7fc:	f800283a 	ret
8112e800:	500d883a 	mov	r6,r10
8112e804:	003ff106 	br	8112e7cc <__reset+0xfb10e7cc>

8112e808 <_Balloc>:
8112e808:	defffc04 	addi	sp,sp,-16
8112e80c:	de00012e 	bgeu	sp,et,8112e814 <_Balloc+0xc>
8112e810:	003b68fa 	trap	3
8112e814:	20801317 	ldw	r2,76(r4)
8112e818:	dc400115 	stw	r17,4(sp)
8112e81c:	dc000015 	stw	r16,0(sp)
8112e820:	dfc00315 	stw	ra,12(sp)
8112e824:	dc800215 	stw	r18,8(sp)
8112e828:	2023883a 	mov	r17,r4
8112e82c:	2821883a 	mov	r16,r5
8112e830:	10000f26 	beq	r2,zero,8112e870 <_Balloc+0x68>
8112e834:	8407883a 	add	r3,r16,r16
8112e838:	18c7883a 	add	r3,r3,r3
8112e83c:	10c7883a 	add	r3,r2,r3
8112e840:	18800017 	ldw	r2,0(r3)
8112e844:	10001126 	beq	r2,zero,8112e88c <_Balloc+0x84>
8112e848:	11000017 	ldw	r4,0(r2)
8112e84c:	19000015 	stw	r4,0(r3)
8112e850:	10000415 	stw	zero,16(r2)
8112e854:	10000315 	stw	zero,12(r2)
8112e858:	dfc00317 	ldw	ra,12(sp)
8112e85c:	dc800217 	ldw	r18,8(sp)
8112e860:	dc400117 	ldw	r17,4(sp)
8112e864:	dc000017 	ldw	r16,0(sp)
8112e868:	dec00404 	addi	sp,sp,16
8112e86c:	f800283a 	ret
8112e870:	01800844 	movi	r6,33
8112e874:	01400104 	movi	r5,4
8112e878:	1134a480 	call	81134a48 <_calloc_r>
8112e87c:	88801315 	stw	r2,76(r17)
8112e880:	103fec1e 	bne	r2,zero,8112e834 <__reset+0xfb10e834>
8112e884:	0005883a 	mov	r2,zero
8112e888:	003ff306 	br	8112e858 <__reset+0xfb10e858>
8112e88c:	01400044 	movi	r5,1
8112e890:	2c24983a 	sll	r18,r5,r16
8112e894:	8809883a 	mov	r4,r17
8112e898:	91800144 	addi	r6,r18,5
8112e89c:	318d883a 	add	r6,r6,r6
8112e8a0:	318d883a 	add	r6,r6,r6
8112e8a4:	1134a480 	call	81134a48 <_calloc_r>
8112e8a8:	103ff626 	beq	r2,zero,8112e884 <__reset+0xfb10e884>
8112e8ac:	14000115 	stw	r16,4(r2)
8112e8b0:	14800215 	stw	r18,8(r2)
8112e8b4:	003fe606 	br	8112e850 <__reset+0xfb10e850>

8112e8b8 <_Bfree>:
8112e8b8:	28000826 	beq	r5,zero,8112e8dc <_Bfree+0x24>
8112e8bc:	28c00117 	ldw	r3,4(r5)
8112e8c0:	20801317 	ldw	r2,76(r4)
8112e8c4:	18c7883a 	add	r3,r3,r3
8112e8c8:	18c7883a 	add	r3,r3,r3
8112e8cc:	10c5883a 	add	r2,r2,r3
8112e8d0:	10c00017 	ldw	r3,0(r2)
8112e8d4:	28c00015 	stw	r3,0(r5)
8112e8d8:	11400015 	stw	r5,0(r2)
8112e8dc:	f800283a 	ret

8112e8e0 <__multadd>:
8112e8e0:	defffa04 	addi	sp,sp,-24
8112e8e4:	de00012e 	bgeu	sp,et,8112e8ec <__multadd+0xc>
8112e8e8:	003b68fa 	trap	3
8112e8ec:	0011883a 	mov	r8,zero
8112e8f0:	dc800315 	stw	r18,12(sp)
8112e8f4:	dc400215 	stw	r17,8(sp)
8112e8f8:	dc000115 	stw	r16,4(sp)
8112e8fc:	2823883a 	mov	r17,r5
8112e900:	2c000417 	ldw	r16,16(r5)
8112e904:	dfc00515 	stw	ra,20(sp)
8112e908:	dcc00415 	stw	r19,16(sp)
8112e90c:	2025883a 	mov	r18,r4
8112e910:	29400504 	addi	r5,r5,20
8112e914:	28c00017 	ldw	r3,0(r5)
8112e918:	29400104 	addi	r5,r5,4
8112e91c:	42000044 	addi	r8,r8,1
8112e920:	18bfffcc 	andi	r2,r3,65535
8112e924:	1185383a 	mul	r2,r2,r6
8112e928:	1806d43a 	srli	r3,r3,16
8112e92c:	11cf883a 	add	r7,r2,r7
8112e930:	3808d43a 	srli	r4,r7,16
8112e934:	1987383a 	mul	r3,r3,r6
8112e938:	38bfffcc 	andi	r2,r7,65535
8112e93c:	1907883a 	add	r3,r3,r4
8112e940:	1808943a 	slli	r4,r3,16
8112e944:	180ed43a 	srli	r7,r3,16
8112e948:	2085883a 	add	r2,r4,r2
8112e94c:	28bfff15 	stw	r2,-4(r5)
8112e950:	443ff016 	blt	r8,r16,8112e914 <__reset+0xfb10e914>
8112e954:	38000926 	beq	r7,zero,8112e97c <__multadd+0x9c>
8112e958:	88800217 	ldw	r2,8(r17)
8112e95c:	80800f0e 	bge	r16,r2,8112e99c <__multadd+0xbc>
8112e960:	80800144 	addi	r2,r16,5
8112e964:	1085883a 	add	r2,r2,r2
8112e968:	1085883a 	add	r2,r2,r2
8112e96c:	8885883a 	add	r2,r17,r2
8112e970:	11c00015 	stw	r7,0(r2)
8112e974:	84000044 	addi	r16,r16,1
8112e978:	8c000415 	stw	r16,16(r17)
8112e97c:	8805883a 	mov	r2,r17
8112e980:	dfc00517 	ldw	ra,20(sp)
8112e984:	dcc00417 	ldw	r19,16(sp)
8112e988:	dc800317 	ldw	r18,12(sp)
8112e98c:	dc400217 	ldw	r17,8(sp)
8112e990:	dc000117 	ldw	r16,4(sp)
8112e994:	dec00604 	addi	sp,sp,24
8112e998:	f800283a 	ret
8112e99c:	89400117 	ldw	r5,4(r17)
8112e9a0:	9009883a 	mov	r4,r18
8112e9a4:	d9c00015 	stw	r7,0(sp)
8112e9a8:	29400044 	addi	r5,r5,1
8112e9ac:	112e8080 	call	8112e808 <_Balloc>
8112e9b0:	89800417 	ldw	r6,16(r17)
8112e9b4:	89400304 	addi	r5,r17,12
8112e9b8:	11000304 	addi	r4,r2,12
8112e9bc:	31800084 	addi	r6,r6,2
8112e9c0:	318d883a 	add	r6,r6,r6
8112e9c4:	318d883a 	add	r6,r6,r6
8112e9c8:	1027883a 	mov	r19,r2
8112e9cc:	11243500 	call	81124350 <memcpy>
8112e9d0:	d9c00017 	ldw	r7,0(sp)
8112e9d4:	88000a26 	beq	r17,zero,8112ea00 <__multadd+0x120>
8112e9d8:	88c00117 	ldw	r3,4(r17)
8112e9dc:	90801317 	ldw	r2,76(r18)
8112e9e0:	18c7883a 	add	r3,r3,r3
8112e9e4:	18c7883a 	add	r3,r3,r3
8112e9e8:	10c5883a 	add	r2,r2,r3
8112e9ec:	10c00017 	ldw	r3,0(r2)
8112e9f0:	88c00015 	stw	r3,0(r17)
8112e9f4:	14400015 	stw	r17,0(r2)
8112e9f8:	9823883a 	mov	r17,r19
8112e9fc:	003fd806 	br	8112e960 <__reset+0xfb10e960>
8112ea00:	9823883a 	mov	r17,r19
8112ea04:	003fd606 	br	8112e960 <__reset+0xfb10e960>

8112ea08 <__s2b>:
8112ea08:	defff904 	addi	sp,sp,-28
8112ea0c:	de00012e 	bgeu	sp,et,8112ea14 <__s2b+0xc>
8112ea10:	003b68fa 	trap	3
8112ea14:	dc400115 	stw	r17,4(sp)
8112ea18:	dc000015 	stw	r16,0(sp)
8112ea1c:	2023883a 	mov	r17,r4
8112ea20:	2821883a 	mov	r16,r5
8112ea24:	39000204 	addi	r4,r7,8
8112ea28:	01400244 	movi	r5,9
8112ea2c:	dcc00315 	stw	r19,12(sp)
8112ea30:	dc800215 	stw	r18,8(sp)
8112ea34:	dfc00615 	stw	ra,24(sp)
8112ea38:	dd400515 	stw	r21,20(sp)
8112ea3c:	dd000415 	stw	r20,16(sp)
8112ea40:	3825883a 	mov	r18,r7
8112ea44:	3027883a 	mov	r19,r6
8112ea48:	11367640 	call	81136764 <__divsi3>
8112ea4c:	00c00044 	movi	r3,1
8112ea50:	000b883a 	mov	r5,zero
8112ea54:	1880030e 	bge	r3,r2,8112ea64 <__s2b+0x5c>
8112ea58:	18c7883a 	add	r3,r3,r3
8112ea5c:	29400044 	addi	r5,r5,1
8112ea60:	18bffd16 	blt	r3,r2,8112ea58 <__reset+0xfb10ea58>
8112ea64:	8809883a 	mov	r4,r17
8112ea68:	112e8080 	call	8112e808 <_Balloc>
8112ea6c:	d8c00717 	ldw	r3,28(sp)
8112ea70:	10c00515 	stw	r3,20(r2)
8112ea74:	00c00044 	movi	r3,1
8112ea78:	10c00415 	stw	r3,16(r2)
8112ea7c:	00c00244 	movi	r3,9
8112ea80:	1cc0210e 	bge	r3,r19,8112eb08 <__s2b+0x100>
8112ea84:	80eb883a 	add	r21,r16,r3
8112ea88:	a829883a 	mov	r20,r21
8112ea8c:	84e1883a 	add	r16,r16,r19
8112ea90:	a1c00007 	ldb	r7,0(r20)
8112ea94:	01800284 	movi	r6,10
8112ea98:	a5000044 	addi	r20,r20,1
8112ea9c:	100b883a 	mov	r5,r2
8112eaa0:	39fff404 	addi	r7,r7,-48
8112eaa4:	8809883a 	mov	r4,r17
8112eaa8:	112e8e00 	call	8112e8e0 <__multadd>
8112eaac:	a43ff81e 	bne	r20,r16,8112ea90 <__reset+0xfb10ea90>
8112eab0:	ace1883a 	add	r16,r21,r19
8112eab4:	843ffe04 	addi	r16,r16,-8
8112eab8:	9c800a0e 	bge	r19,r18,8112eae4 <__s2b+0xdc>
8112eabc:	94e5c83a 	sub	r18,r18,r19
8112eac0:	84a5883a 	add	r18,r16,r18
8112eac4:	81c00007 	ldb	r7,0(r16)
8112eac8:	01800284 	movi	r6,10
8112eacc:	84000044 	addi	r16,r16,1
8112ead0:	100b883a 	mov	r5,r2
8112ead4:	39fff404 	addi	r7,r7,-48
8112ead8:	8809883a 	mov	r4,r17
8112eadc:	112e8e00 	call	8112e8e0 <__multadd>
8112eae0:	84bff81e 	bne	r16,r18,8112eac4 <__reset+0xfb10eac4>
8112eae4:	dfc00617 	ldw	ra,24(sp)
8112eae8:	dd400517 	ldw	r21,20(sp)
8112eaec:	dd000417 	ldw	r20,16(sp)
8112eaf0:	dcc00317 	ldw	r19,12(sp)
8112eaf4:	dc800217 	ldw	r18,8(sp)
8112eaf8:	dc400117 	ldw	r17,4(sp)
8112eafc:	dc000017 	ldw	r16,0(sp)
8112eb00:	dec00704 	addi	sp,sp,28
8112eb04:	f800283a 	ret
8112eb08:	84000284 	addi	r16,r16,10
8112eb0c:	1827883a 	mov	r19,r3
8112eb10:	003fe906 	br	8112eab8 <__reset+0xfb10eab8>

8112eb14 <__hi0bits>:
8112eb14:	20bfffec 	andhi	r2,r4,65535
8112eb18:	1000141e 	bne	r2,zero,8112eb6c <__hi0bits+0x58>
8112eb1c:	2008943a 	slli	r4,r4,16
8112eb20:	00800404 	movi	r2,16
8112eb24:	20ffc02c 	andhi	r3,r4,65280
8112eb28:	1800021e 	bne	r3,zero,8112eb34 <__hi0bits+0x20>
8112eb2c:	2008923a 	slli	r4,r4,8
8112eb30:	10800204 	addi	r2,r2,8
8112eb34:	20fc002c 	andhi	r3,r4,61440
8112eb38:	1800021e 	bne	r3,zero,8112eb44 <__hi0bits+0x30>
8112eb3c:	2008913a 	slli	r4,r4,4
8112eb40:	10800104 	addi	r2,r2,4
8112eb44:	20f0002c 	andhi	r3,r4,49152
8112eb48:	1800031e 	bne	r3,zero,8112eb58 <__hi0bits+0x44>
8112eb4c:	2109883a 	add	r4,r4,r4
8112eb50:	10800084 	addi	r2,r2,2
8112eb54:	2109883a 	add	r4,r4,r4
8112eb58:	20000316 	blt	r4,zero,8112eb68 <__hi0bits+0x54>
8112eb5c:	2110002c 	andhi	r4,r4,16384
8112eb60:	2000041e 	bne	r4,zero,8112eb74 <__hi0bits+0x60>
8112eb64:	00800804 	movi	r2,32
8112eb68:	f800283a 	ret
8112eb6c:	0005883a 	mov	r2,zero
8112eb70:	003fec06 	br	8112eb24 <__reset+0xfb10eb24>
8112eb74:	10800044 	addi	r2,r2,1
8112eb78:	f800283a 	ret

8112eb7c <__lo0bits>:
8112eb7c:	20c00017 	ldw	r3,0(r4)
8112eb80:	188001cc 	andi	r2,r3,7
8112eb84:	10000826 	beq	r2,zero,8112eba8 <__lo0bits+0x2c>
8112eb88:	1880004c 	andi	r2,r3,1
8112eb8c:	1000211e 	bne	r2,zero,8112ec14 <__lo0bits+0x98>
8112eb90:	1880008c 	andi	r2,r3,2
8112eb94:	1000211e 	bne	r2,zero,8112ec1c <__lo0bits+0xa0>
8112eb98:	1806d0ba 	srli	r3,r3,2
8112eb9c:	00800084 	movi	r2,2
8112eba0:	20c00015 	stw	r3,0(r4)
8112eba4:	f800283a 	ret
8112eba8:	18bfffcc 	andi	r2,r3,65535
8112ebac:	10001326 	beq	r2,zero,8112ebfc <__lo0bits+0x80>
8112ebb0:	0005883a 	mov	r2,zero
8112ebb4:	19403fcc 	andi	r5,r3,255
8112ebb8:	2800021e 	bne	r5,zero,8112ebc4 <__lo0bits+0x48>
8112ebbc:	1806d23a 	srli	r3,r3,8
8112ebc0:	10800204 	addi	r2,r2,8
8112ebc4:	194003cc 	andi	r5,r3,15
8112ebc8:	2800021e 	bne	r5,zero,8112ebd4 <__lo0bits+0x58>
8112ebcc:	1806d13a 	srli	r3,r3,4
8112ebd0:	10800104 	addi	r2,r2,4
8112ebd4:	194000cc 	andi	r5,r3,3
8112ebd8:	2800021e 	bne	r5,zero,8112ebe4 <__lo0bits+0x68>
8112ebdc:	1806d0ba 	srli	r3,r3,2
8112ebe0:	10800084 	addi	r2,r2,2
8112ebe4:	1940004c 	andi	r5,r3,1
8112ebe8:	2800081e 	bne	r5,zero,8112ec0c <__lo0bits+0x90>
8112ebec:	1806d07a 	srli	r3,r3,1
8112ebf0:	1800051e 	bne	r3,zero,8112ec08 <__lo0bits+0x8c>
8112ebf4:	00800804 	movi	r2,32
8112ebf8:	f800283a 	ret
8112ebfc:	1806d43a 	srli	r3,r3,16
8112ec00:	00800404 	movi	r2,16
8112ec04:	003feb06 	br	8112ebb4 <__reset+0xfb10ebb4>
8112ec08:	10800044 	addi	r2,r2,1
8112ec0c:	20c00015 	stw	r3,0(r4)
8112ec10:	f800283a 	ret
8112ec14:	0005883a 	mov	r2,zero
8112ec18:	f800283a 	ret
8112ec1c:	1806d07a 	srli	r3,r3,1
8112ec20:	00800044 	movi	r2,1
8112ec24:	20c00015 	stw	r3,0(r4)
8112ec28:	f800283a 	ret

8112ec2c <__i2b>:
8112ec2c:	defffd04 	addi	sp,sp,-12
8112ec30:	de00012e 	bgeu	sp,et,8112ec38 <__i2b+0xc>
8112ec34:	003b68fa 	trap	3
8112ec38:	dc000015 	stw	r16,0(sp)
8112ec3c:	04000044 	movi	r16,1
8112ec40:	dc400115 	stw	r17,4(sp)
8112ec44:	2823883a 	mov	r17,r5
8112ec48:	800b883a 	mov	r5,r16
8112ec4c:	dfc00215 	stw	ra,8(sp)
8112ec50:	112e8080 	call	8112e808 <_Balloc>
8112ec54:	14400515 	stw	r17,20(r2)
8112ec58:	14000415 	stw	r16,16(r2)
8112ec5c:	dfc00217 	ldw	ra,8(sp)
8112ec60:	dc400117 	ldw	r17,4(sp)
8112ec64:	dc000017 	ldw	r16,0(sp)
8112ec68:	dec00304 	addi	sp,sp,12
8112ec6c:	f800283a 	ret

8112ec70 <__multiply>:
8112ec70:	defffa04 	addi	sp,sp,-24
8112ec74:	de00012e 	bgeu	sp,et,8112ec7c <__multiply+0xc>
8112ec78:	003b68fa 	trap	3
8112ec7c:	dcc00315 	stw	r19,12(sp)
8112ec80:	dc800215 	stw	r18,8(sp)
8112ec84:	34c00417 	ldw	r19,16(r6)
8112ec88:	2c800417 	ldw	r18,16(r5)
8112ec8c:	dd000415 	stw	r20,16(sp)
8112ec90:	dc400115 	stw	r17,4(sp)
8112ec94:	dfc00515 	stw	ra,20(sp)
8112ec98:	dc000015 	stw	r16,0(sp)
8112ec9c:	2829883a 	mov	r20,r5
8112eca0:	3023883a 	mov	r17,r6
8112eca4:	94c0050e 	bge	r18,r19,8112ecbc <__multiply+0x4c>
8112eca8:	9007883a 	mov	r3,r18
8112ecac:	3029883a 	mov	r20,r6
8112ecb0:	9825883a 	mov	r18,r19
8112ecb4:	2823883a 	mov	r17,r5
8112ecb8:	1827883a 	mov	r19,r3
8112ecbc:	a0800217 	ldw	r2,8(r20)
8112ecc0:	94e1883a 	add	r16,r18,r19
8112ecc4:	a1400117 	ldw	r5,4(r20)
8112ecc8:	1400010e 	bge	r2,r16,8112ecd0 <__multiply+0x60>
8112eccc:	29400044 	addi	r5,r5,1
8112ecd0:	112e8080 	call	8112e808 <_Balloc>
8112ecd4:	8415883a 	add	r10,r16,r16
8112ecd8:	12c00504 	addi	r11,r2,20
8112ecdc:	5295883a 	add	r10,r10,r10
8112ece0:	5a95883a 	add	r10,r11,r10
8112ece4:	5807883a 	mov	r3,r11
8112ece8:	5a80032e 	bgeu	r11,r10,8112ecf8 <__multiply+0x88>
8112ecec:	18000015 	stw	zero,0(r3)
8112ecf0:	18c00104 	addi	r3,r3,4
8112ecf4:	1abffd36 	bltu	r3,r10,8112ecec <__reset+0xfb10ecec>
8112ecf8:	9ce7883a 	add	r19,r19,r19
8112ecfc:	94a5883a 	add	r18,r18,r18
8112ed00:	89800504 	addi	r6,r17,20
8112ed04:	9ce7883a 	add	r19,r19,r19
8112ed08:	a3400504 	addi	r13,r20,20
8112ed0c:	94a5883a 	add	r18,r18,r18
8112ed10:	34d9883a 	add	r12,r6,r19
8112ed14:	6c93883a 	add	r9,r13,r18
8112ed18:	3300422e 	bgeu	r6,r12,8112ee24 <__multiply+0x1b4>
8112ed1c:	37c00017 	ldw	ra,0(r6)
8112ed20:	fbffffcc 	andi	r15,ra,65535
8112ed24:	78001b26 	beq	r15,zero,8112ed94 <__multiply+0x124>
8112ed28:	5811883a 	mov	r8,r11
8112ed2c:	681d883a 	mov	r14,r13
8112ed30:	000f883a 	mov	r7,zero
8112ed34:	71000017 	ldw	r4,0(r14)
8112ed38:	40c00017 	ldw	r3,0(r8)
8112ed3c:	73800104 	addi	r14,r14,4
8112ed40:	217fffcc 	andi	r5,r4,65535
8112ed44:	2bcb383a 	mul	r5,r5,r15
8112ed48:	2008d43a 	srli	r4,r4,16
8112ed4c:	1c7fffcc 	andi	r17,r3,65535
8112ed50:	2c4b883a 	add	r5,r5,r17
8112ed54:	29cb883a 	add	r5,r5,r7
8112ed58:	23c9383a 	mul	r4,r4,r15
8112ed5c:	1806d43a 	srli	r3,r3,16
8112ed60:	280ed43a 	srli	r7,r5,16
8112ed64:	297fffcc 	andi	r5,r5,65535
8112ed68:	20c7883a 	add	r3,r4,r3
8112ed6c:	19c7883a 	add	r3,r3,r7
8112ed70:	1808943a 	slli	r4,r3,16
8112ed74:	4023883a 	mov	r17,r8
8112ed78:	180ed43a 	srli	r7,r3,16
8112ed7c:	214ab03a 	or	r5,r4,r5
8112ed80:	41400015 	stw	r5,0(r8)
8112ed84:	42000104 	addi	r8,r8,4
8112ed88:	727fea36 	bltu	r14,r9,8112ed34 <__reset+0xfb10ed34>
8112ed8c:	89c00115 	stw	r7,4(r17)
8112ed90:	37c00017 	ldw	ra,0(r6)
8112ed94:	f83ed43a 	srli	ra,ra,16
8112ed98:	f8001f26 	beq	ra,zero,8112ee18 <__multiply+0x1a8>
8112ed9c:	58c00017 	ldw	r3,0(r11)
8112eda0:	681d883a 	mov	r14,r13
8112eda4:	581f883a 	mov	r15,r11
8112eda8:	1811883a 	mov	r8,r3
8112edac:	5825883a 	mov	r18,r11
8112edb0:	000f883a 	mov	r7,zero
8112edb4:	00000106 	br	8112edbc <__multiply+0x14c>
8112edb8:	8825883a 	mov	r18,r17
8112edbc:	7140000b 	ldhu	r5,0(r14)
8112edc0:	4010d43a 	srli	r8,r8,16
8112edc4:	193fffcc 	andi	r4,r3,65535
8112edc8:	2fcb383a 	mul	r5,r5,ra
8112edcc:	7bc00104 	addi	r15,r15,4
8112edd0:	73800104 	addi	r14,r14,4
8112edd4:	2a0b883a 	add	r5,r5,r8
8112edd8:	29cb883a 	add	r5,r5,r7
8112eddc:	2806943a 	slli	r3,r5,16
8112ede0:	94400104 	addi	r17,r18,4
8112ede4:	280ad43a 	srli	r5,r5,16
8112ede8:	1908b03a 	or	r4,r3,r4
8112edec:	793fff15 	stw	r4,-4(r15)
8112edf0:	70ffff17 	ldw	r3,-4(r14)
8112edf4:	8a000017 	ldw	r8,0(r17)
8112edf8:	1806d43a 	srli	r3,r3,16
8112edfc:	413fffcc 	andi	r4,r8,65535
8112ee00:	1fc7383a 	mul	r3,r3,ra
8112ee04:	1907883a 	add	r3,r3,r4
8112ee08:	1947883a 	add	r3,r3,r5
8112ee0c:	180ed43a 	srli	r7,r3,16
8112ee10:	727fe936 	bltu	r14,r9,8112edb8 <__reset+0xfb10edb8>
8112ee14:	90c00115 	stw	r3,4(r18)
8112ee18:	31800104 	addi	r6,r6,4
8112ee1c:	5ac00104 	addi	r11,r11,4
8112ee20:	333fbe36 	bltu	r6,r12,8112ed1c <__reset+0xfb10ed1c>
8112ee24:	0400090e 	bge	zero,r16,8112ee4c <__multiply+0x1dc>
8112ee28:	50ffff17 	ldw	r3,-4(r10)
8112ee2c:	52bfff04 	addi	r10,r10,-4
8112ee30:	18000326 	beq	r3,zero,8112ee40 <__multiply+0x1d0>
8112ee34:	00000506 	br	8112ee4c <__multiply+0x1dc>
8112ee38:	50c00017 	ldw	r3,0(r10)
8112ee3c:	1800031e 	bne	r3,zero,8112ee4c <__multiply+0x1dc>
8112ee40:	843fffc4 	addi	r16,r16,-1
8112ee44:	52bfff04 	addi	r10,r10,-4
8112ee48:	803ffb1e 	bne	r16,zero,8112ee38 <__reset+0xfb10ee38>
8112ee4c:	14000415 	stw	r16,16(r2)
8112ee50:	dfc00517 	ldw	ra,20(sp)
8112ee54:	dd000417 	ldw	r20,16(sp)
8112ee58:	dcc00317 	ldw	r19,12(sp)
8112ee5c:	dc800217 	ldw	r18,8(sp)
8112ee60:	dc400117 	ldw	r17,4(sp)
8112ee64:	dc000017 	ldw	r16,0(sp)
8112ee68:	dec00604 	addi	sp,sp,24
8112ee6c:	f800283a 	ret

8112ee70 <__pow5mult>:
8112ee70:	defffa04 	addi	sp,sp,-24
8112ee74:	de00012e 	bgeu	sp,et,8112ee7c <__pow5mult+0xc>
8112ee78:	003b68fa 	trap	3
8112ee7c:	308000cc 	andi	r2,r6,3
8112ee80:	dcc00315 	stw	r19,12(sp)
8112ee84:	dc000015 	stw	r16,0(sp)
8112ee88:	dfc00515 	stw	ra,20(sp)
8112ee8c:	dd000415 	stw	r20,16(sp)
8112ee90:	dc800215 	stw	r18,8(sp)
8112ee94:	dc400115 	stw	r17,4(sp)
8112ee98:	3021883a 	mov	r16,r6
8112ee9c:	2027883a 	mov	r19,r4
8112eea0:	10002f1e 	bne	r2,zero,8112ef60 <__pow5mult+0xf0>
8112eea4:	2825883a 	mov	r18,r5
8112eea8:	8021d0ba 	srai	r16,r16,2
8112eeac:	80001a26 	beq	r16,zero,8112ef18 <__pow5mult+0xa8>
8112eeb0:	9c401217 	ldw	r17,72(r19)
8112eeb4:	8800061e 	bne	r17,zero,8112eed0 <__pow5mult+0x60>
8112eeb8:	00003406 	br	8112ef8c <__pow5mult+0x11c>
8112eebc:	8021d07a 	srai	r16,r16,1
8112eec0:	80001526 	beq	r16,zero,8112ef18 <__pow5mult+0xa8>
8112eec4:	88800017 	ldw	r2,0(r17)
8112eec8:	10001c26 	beq	r2,zero,8112ef3c <__pow5mult+0xcc>
8112eecc:	1023883a 	mov	r17,r2
8112eed0:	8080004c 	andi	r2,r16,1
8112eed4:	103ff926 	beq	r2,zero,8112eebc <__reset+0xfb10eebc>
8112eed8:	880d883a 	mov	r6,r17
8112eedc:	900b883a 	mov	r5,r18
8112eee0:	9809883a 	mov	r4,r19
8112eee4:	112ec700 	call	8112ec70 <__multiply>
8112eee8:	90001b26 	beq	r18,zero,8112ef58 <__pow5mult+0xe8>
8112eeec:	91000117 	ldw	r4,4(r18)
8112eef0:	98c01317 	ldw	r3,76(r19)
8112eef4:	8021d07a 	srai	r16,r16,1
8112eef8:	2109883a 	add	r4,r4,r4
8112eefc:	2109883a 	add	r4,r4,r4
8112ef00:	1907883a 	add	r3,r3,r4
8112ef04:	19000017 	ldw	r4,0(r3)
8112ef08:	91000015 	stw	r4,0(r18)
8112ef0c:	1c800015 	stw	r18,0(r3)
8112ef10:	1025883a 	mov	r18,r2
8112ef14:	803feb1e 	bne	r16,zero,8112eec4 <__reset+0xfb10eec4>
8112ef18:	9005883a 	mov	r2,r18
8112ef1c:	dfc00517 	ldw	ra,20(sp)
8112ef20:	dd000417 	ldw	r20,16(sp)
8112ef24:	dcc00317 	ldw	r19,12(sp)
8112ef28:	dc800217 	ldw	r18,8(sp)
8112ef2c:	dc400117 	ldw	r17,4(sp)
8112ef30:	dc000017 	ldw	r16,0(sp)
8112ef34:	dec00604 	addi	sp,sp,24
8112ef38:	f800283a 	ret
8112ef3c:	880d883a 	mov	r6,r17
8112ef40:	880b883a 	mov	r5,r17
8112ef44:	9809883a 	mov	r4,r19
8112ef48:	112ec700 	call	8112ec70 <__multiply>
8112ef4c:	88800015 	stw	r2,0(r17)
8112ef50:	10000015 	stw	zero,0(r2)
8112ef54:	003fdd06 	br	8112eecc <__reset+0xfb10eecc>
8112ef58:	1025883a 	mov	r18,r2
8112ef5c:	003fd706 	br	8112eebc <__reset+0xfb10eebc>
8112ef60:	10bfffc4 	addi	r2,r2,-1
8112ef64:	1085883a 	add	r2,r2,r2
8112ef68:	00e04574 	movhi	r3,33045
8112ef6c:	18c9ba04 	addi	r3,r3,9960
8112ef70:	1085883a 	add	r2,r2,r2
8112ef74:	1885883a 	add	r2,r3,r2
8112ef78:	11800017 	ldw	r6,0(r2)
8112ef7c:	000f883a 	mov	r7,zero
8112ef80:	112e8e00 	call	8112e8e0 <__multadd>
8112ef84:	1025883a 	mov	r18,r2
8112ef88:	003fc706 	br	8112eea8 <__reset+0xfb10eea8>
8112ef8c:	05000044 	movi	r20,1
8112ef90:	a00b883a 	mov	r5,r20
8112ef94:	9809883a 	mov	r4,r19
8112ef98:	112e8080 	call	8112e808 <_Balloc>
8112ef9c:	1023883a 	mov	r17,r2
8112efa0:	00809c44 	movi	r2,625
8112efa4:	88800515 	stw	r2,20(r17)
8112efa8:	8d000415 	stw	r20,16(r17)
8112efac:	9c401215 	stw	r17,72(r19)
8112efb0:	88000015 	stw	zero,0(r17)
8112efb4:	003fc606 	br	8112eed0 <__reset+0xfb10eed0>

8112efb8 <__lshift>:
8112efb8:	defff904 	addi	sp,sp,-28
8112efbc:	de00012e 	bgeu	sp,et,8112efc4 <__lshift+0xc>
8112efc0:	003b68fa 	trap	3
8112efc4:	dd400515 	stw	r21,20(sp)
8112efc8:	dcc00315 	stw	r19,12(sp)
8112efcc:	302bd17a 	srai	r21,r6,5
8112efd0:	2cc00417 	ldw	r19,16(r5)
8112efd4:	28800217 	ldw	r2,8(r5)
8112efd8:	dd000415 	stw	r20,16(sp)
8112efdc:	ace7883a 	add	r19,r21,r19
8112efe0:	dc800215 	stw	r18,8(sp)
8112efe4:	dc400115 	stw	r17,4(sp)
8112efe8:	dc000015 	stw	r16,0(sp)
8112efec:	dfc00615 	stw	ra,24(sp)
8112eff0:	9c000044 	addi	r16,r19,1
8112eff4:	2823883a 	mov	r17,r5
8112eff8:	3029883a 	mov	r20,r6
8112effc:	2025883a 	mov	r18,r4
8112f000:	29400117 	ldw	r5,4(r5)
8112f004:	1400030e 	bge	r2,r16,8112f014 <__lshift+0x5c>
8112f008:	1085883a 	add	r2,r2,r2
8112f00c:	29400044 	addi	r5,r5,1
8112f010:	143ffd16 	blt	r2,r16,8112f008 <__reset+0xfb10f008>
8112f014:	9009883a 	mov	r4,r18
8112f018:	112e8080 	call	8112e808 <_Balloc>
8112f01c:	10c00504 	addi	r3,r2,20
8112f020:	0540070e 	bge	zero,r21,8112f040 <__lshift+0x88>
8112f024:	ad6b883a 	add	r21,r21,r21
8112f028:	ad6b883a 	add	r21,r21,r21
8112f02c:	1809883a 	mov	r4,r3
8112f030:	1d47883a 	add	r3,r3,r21
8112f034:	20000015 	stw	zero,0(r4)
8112f038:	21000104 	addi	r4,r4,4
8112f03c:	193ffd1e 	bne	r3,r4,8112f034 <__reset+0xfb10f034>
8112f040:	8a000417 	ldw	r8,16(r17)
8112f044:	89000504 	addi	r4,r17,20
8112f048:	a18007cc 	andi	r6,r20,31
8112f04c:	4211883a 	add	r8,r8,r8
8112f050:	4211883a 	add	r8,r8,r8
8112f054:	2211883a 	add	r8,r4,r8
8112f058:	30002326 	beq	r6,zero,8112f0e8 <__lshift+0x130>
8112f05c:	02400804 	movi	r9,32
8112f060:	4993c83a 	sub	r9,r9,r6
8112f064:	000b883a 	mov	r5,zero
8112f068:	21c00017 	ldw	r7,0(r4)
8112f06c:	1815883a 	mov	r10,r3
8112f070:	18c00104 	addi	r3,r3,4
8112f074:	398e983a 	sll	r7,r7,r6
8112f078:	21000104 	addi	r4,r4,4
8112f07c:	394ab03a 	or	r5,r7,r5
8112f080:	197fff15 	stw	r5,-4(r3)
8112f084:	217fff17 	ldw	r5,-4(r4)
8112f088:	2a4ad83a 	srl	r5,r5,r9
8112f08c:	223ff636 	bltu	r4,r8,8112f068 <__reset+0xfb10f068>
8112f090:	51400115 	stw	r5,4(r10)
8112f094:	28001a1e 	bne	r5,zero,8112f100 <__lshift+0x148>
8112f098:	843fffc4 	addi	r16,r16,-1
8112f09c:	14000415 	stw	r16,16(r2)
8112f0a0:	88000826 	beq	r17,zero,8112f0c4 <__lshift+0x10c>
8112f0a4:	89000117 	ldw	r4,4(r17)
8112f0a8:	90c01317 	ldw	r3,76(r18)
8112f0ac:	2109883a 	add	r4,r4,r4
8112f0b0:	2109883a 	add	r4,r4,r4
8112f0b4:	1907883a 	add	r3,r3,r4
8112f0b8:	19000017 	ldw	r4,0(r3)
8112f0bc:	89000015 	stw	r4,0(r17)
8112f0c0:	1c400015 	stw	r17,0(r3)
8112f0c4:	dfc00617 	ldw	ra,24(sp)
8112f0c8:	dd400517 	ldw	r21,20(sp)
8112f0cc:	dd000417 	ldw	r20,16(sp)
8112f0d0:	dcc00317 	ldw	r19,12(sp)
8112f0d4:	dc800217 	ldw	r18,8(sp)
8112f0d8:	dc400117 	ldw	r17,4(sp)
8112f0dc:	dc000017 	ldw	r16,0(sp)
8112f0e0:	dec00704 	addi	sp,sp,28
8112f0e4:	f800283a 	ret
8112f0e8:	21400017 	ldw	r5,0(r4)
8112f0ec:	18c00104 	addi	r3,r3,4
8112f0f0:	21000104 	addi	r4,r4,4
8112f0f4:	197fff15 	stw	r5,-4(r3)
8112f0f8:	223ffb36 	bltu	r4,r8,8112f0e8 <__reset+0xfb10f0e8>
8112f0fc:	003fe606 	br	8112f098 <__reset+0xfb10f098>
8112f100:	9c000084 	addi	r16,r19,2
8112f104:	003fe406 	br	8112f098 <__reset+0xfb10f098>

8112f108 <__mcmp>:
8112f108:	20800417 	ldw	r2,16(r4)
8112f10c:	28c00417 	ldw	r3,16(r5)
8112f110:	10c5c83a 	sub	r2,r2,r3
8112f114:	1000111e 	bne	r2,zero,8112f15c <__mcmp+0x54>
8112f118:	18c7883a 	add	r3,r3,r3
8112f11c:	18c7883a 	add	r3,r3,r3
8112f120:	21000504 	addi	r4,r4,20
8112f124:	29400504 	addi	r5,r5,20
8112f128:	20c5883a 	add	r2,r4,r3
8112f12c:	28cb883a 	add	r5,r5,r3
8112f130:	00000106 	br	8112f138 <__mcmp+0x30>
8112f134:	20800a2e 	bgeu	r4,r2,8112f160 <__mcmp+0x58>
8112f138:	10bfff04 	addi	r2,r2,-4
8112f13c:	297fff04 	addi	r5,r5,-4
8112f140:	11800017 	ldw	r6,0(r2)
8112f144:	28c00017 	ldw	r3,0(r5)
8112f148:	30fffa26 	beq	r6,r3,8112f134 <__reset+0xfb10f134>
8112f14c:	30c00236 	bltu	r6,r3,8112f158 <__mcmp+0x50>
8112f150:	00800044 	movi	r2,1
8112f154:	f800283a 	ret
8112f158:	00bfffc4 	movi	r2,-1
8112f15c:	f800283a 	ret
8112f160:	0005883a 	mov	r2,zero
8112f164:	f800283a 	ret

8112f168 <__mdiff>:
8112f168:	defffa04 	addi	sp,sp,-24
8112f16c:	de00012e 	bgeu	sp,et,8112f174 <__mdiff+0xc>
8112f170:	003b68fa 	trap	3
8112f174:	28c00417 	ldw	r3,16(r5)
8112f178:	30800417 	ldw	r2,16(r6)
8112f17c:	dcc00315 	stw	r19,12(sp)
8112f180:	dc800215 	stw	r18,8(sp)
8112f184:	dfc00515 	stw	ra,20(sp)
8112f188:	dd000415 	stw	r20,16(sp)
8112f18c:	dc400115 	stw	r17,4(sp)
8112f190:	dc000015 	stw	r16,0(sp)
8112f194:	1887c83a 	sub	r3,r3,r2
8112f198:	2825883a 	mov	r18,r5
8112f19c:	3027883a 	mov	r19,r6
8112f1a0:	1800141e 	bne	r3,zero,8112f1f4 <__mdiff+0x8c>
8112f1a4:	1085883a 	add	r2,r2,r2
8112f1a8:	1085883a 	add	r2,r2,r2
8112f1ac:	2a000504 	addi	r8,r5,20
8112f1b0:	34000504 	addi	r16,r6,20
8112f1b4:	4087883a 	add	r3,r8,r2
8112f1b8:	8085883a 	add	r2,r16,r2
8112f1bc:	00000106 	br	8112f1c4 <__mdiff+0x5c>
8112f1c0:	40c0592e 	bgeu	r8,r3,8112f328 <__mdiff+0x1c0>
8112f1c4:	18ffff04 	addi	r3,r3,-4
8112f1c8:	10bfff04 	addi	r2,r2,-4
8112f1cc:	19c00017 	ldw	r7,0(r3)
8112f1d0:	11400017 	ldw	r5,0(r2)
8112f1d4:	397ffa26 	beq	r7,r5,8112f1c0 <__reset+0xfb10f1c0>
8112f1d8:	3940592e 	bgeu	r7,r5,8112f340 <__mdiff+0x1d8>
8112f1dc:	9005883a 	mov	r2,r18
8112f1e0:	4023883a 	mov	r17,r8
8112f1e4:	9825883a 	mov	r18,r19
8112f1e8:	05000044 	movi	r20,1
8112f1ec:	1027883a 	mov	r19,r2
8112f1f0:	00000406 	br	8112f204 <__mdiff+0x9c>
8112f1f4:	18005616 	blt	r3,zero,8112f350 <__mdiff+0x1e8>
8112f1f8:	34400504 	addi	r17,r6,20
8112f1fc:	2c000504 	addi	r16,r5,20
8112f200:	0029883a 	mov	r20,zero
8112f204:	91400117 	ldw	r5,4(r18)
8112f208:	112e8080 	call	8112e808 <_Balloc>
8112f20c:	92400417 	ldw	r9,16(r18)
8112f210:	9b000417 	ldw	r12,16(r19)
8112f214:	12c00504 	addi	r11,r2,20
8112f218:	4a51883a 	add	r8,r9,r9
8112f21c:	6319883a 	add	r12,r12,r12
8112f220:	4211883a 	add	r8,r8,r8
8112f224:	6319883a 	add	r12,r12,r12
8112f228:	15000315 	stw	r20,12(r2)
8112f22c:	8211883a 	add	r8,r16,r8
8112f230:	8b19883a 	add	r12,r17,r12
8112f234:	0007883a 	mov	r3,zero
8112f238:	81400017 	ldw	r5,0(r16)
8112f23c:	89c00017 	ldw	r7,0(r17)
8112f240:	59800104 	addi	r6,r11,4
8112f244:	293fffcc 	andi	r4,r5,65535
8112f248:	20c7883a 	add	r3,r4,r3
8112f24c:	393fffcc 	andi	r4,r7,65535
8112f250:	1909c83a 	sub	r4,r3,r4
8112f254:	280ad43a 	srli	r5,r5,16
8112f258:	380ed43a 	srli	r7,r7,16
8112f25c:	2007d43a 	srai	r3,r4,16
8112f260:	213fffcc 	andi	r4,r4,65535
8112f264:	29cbc83a 	sub	r5,r5,r7
8112f268:	28c7883a 	add	r3,r5,r3
8112f26c:	180a943a 	slli	r5,r3,16
8112f270:	8c400104 	addi	r17,r17,4
8112f274:	84000104 	addi	r16,r16,4
8112f278:	2908b03a 	or	r4,r5,r4
8112f27c:	59000015 	stw	r4,0(r11)
8112f280:	1807d43a 	srai	r3,r3,16
8112f284:	3015883a 	mov	r10,r6
8112f288:	3017883a 	mov	r11,r6
8112f28c:	8b3fea36 	bltu	r17,r12,8112f238 <__reset+0xfb10f238>
8112f290:	8200162e 	bgeu	r16,r8,8112f2ec <__mdiff+0x184>
8112f294:	8017883a 	mov	r11,r16
8112f298:	59400017 	ldw	r5,0(r11)
8112f29c:	31800104 	addi	r6,r6,4
8112f2a0:	5ac00104 	addi	r11,r11,4
8112f2a4:	293fffcc 	andi	r4,r5,65535
8112f2a8:	20c7883a 	add	r3,r4,r3
8112f2ac:	280ed43a 	srli	r7,r5,16
8112f2b0:	180bd43a 	srai	r5,r3,16
8112f2b4:	193fffcc 	andi	r4,r3,65535
8112f2b8:	3947883a 	add	r3,r7,r5
8112f2bc:	180a943a 	slli	r5,r3,16
8112f2c0:	1807d43a 	srai	r3,r3,16
8112f2c4:	2908b03a 	or	r4,r5,r4
8112f2c8:	313fff15 	stw	r4,-4(r6)
8112f2cc:	5a3ff236 	bltu	r11,r8,8112f298 <__reset+0xfb10f298>
8112f2d0:	0406303a 	nor	r3,zero,r16
8112f2d4:	1a07883a 	add	r3,r3,r8
8112f2d8:	1806d0ba 	srli	r3,r3,2
8112f2dc:	18c00044 	addi	r3,r3,1
8112f2e0:	18c7883a 	add	r3,r3,r3
8112f2e4:	18c7883a 	add	r3,r3,r3
8112f2e8:	50d5883a 	add	r10,r10,r3
8112f2ec:	50ffff04 	addi	r3,r10,-4
8112f2f0:	2000041e 	bne	r4,zero,8112f304 <__mdiff+0x19c>
8112f2f4:	18ffff04 	addi	r3,r3,-4
8112f2f8:	19000017 	ldw	r4,0(r3)
8112f2fc:	4a7fffc4 	addi	r9,r9,-1
8112f300:	203ffc26 	beq	r4,zero,8112f2f4 <__reset+0xfb10f2f4>
8112f304:	12400415 	stw	r9,16(r2)
8112f308:	dfc00517 	ldw	ra,20(sp)
8112f30c:	dd000417 	ldw	r20,16(sp)
8112f310:	dcc00317 	ldw	r19,12(sp)
8112f314:	dc800217 	ldw	r18,8(sp)
8112f318:	dc400117 	ldw	r17,4(sp)
8112f31c:	dc000017 	ldw	r16,0(sp)
8112f320:	dec00604 	addi	sp,sp,24
8112f324:	f800283a 	ret
8112f328:	000b883a 	mov	r5,zero
8112f32c:	112e8080 	call	8112e808 <_Balloc>
8112f330:	00c00044 	movi	r3,1
8112f334:	10c00415 	stw	r3,16(r2)
8112f338:	10000515 	stw	zero,20(r2)
8112f33c:	003ff206 	br	8112f308 <__reset+0xfb10f308>
8112f340:	8023883a 	mov	r17,r16
8112f344:	0029883a 	mov	r20,zero
8112f348:	4021883a 	mov	r16,r8
8112f34c:	003fad06 	br	8112f204 <__reset+0xfb10f204>
8112f350:	9005883a 	mov	r2,r18
8112f354:	94400504 	addi	r17,r18,20
8112f358:	9c000504 	addi	r16,r19,20
8112f35c:	9825883a 	mov	r18,r19
8112f360:	05000044 	movi	r20,1
8112f364:	1027883a 	mov	r19,r2
8112f368:	003fa606 	br	8112f204 <__reset+0xfb10f204>

8112f36c <__ulp>:
8112f36c:	295ffc2c 	andhi	r5,r5,32752
8112f370:	00bf3034 	movhi	r2,64704
8112f374:	2887883a 	add	r3,r5,r2
8112f378:	00c0020e 	bge	zero,r3,8112f384 <__ulp+0x18>
8112f37c:	0005883a 	mov	r2,zero
8112f380:	f800283a 	ret
8112f384:	00c7c83a 	sub	r3,zero,r3
8112f388:	1807d53a 	srai	r3,r3,20
8112f38c:	008004c4 	movi	r2,19
8112f390:	10c00b0e 	bge	r2,r3,8112f3c0 <__ulp+0x54>
8112f394:	18bffb04 	addi	r2,r3,-20
8112f398:	01000784 	movi	r4,30
8112f39c:	0007883a 	mov	r3,zero
8112f3a0:	20800516 	blt	r4,r2,8112f3b8 <__ulp+0x4c>
8112f3a4:	010007c4 	movi	r4,31
8112f3a8:	2089c83a 	sub	r4,r4,r2
8112f3ac:	00800044 	movi	r2,1
8112f3b0:	1104983a 	sll	r2,r2,r4
8112f3b4:	f800283a 	ret
8112f3b8:	00800044 	movi	r2,1
8112f3bc:	f800283a 	ret
8112f3c0:	01400234 	movhi	r5,8
8112f3c4:	28c7d83a 	sra	r3,r5,r3
8112f3c8:	0005883a 	mov	r2,zero
8112f3cc:	f800283a 	ret

8112f3d0 <__b2d>:
8112f3d0:	defffa04 	addi	sp,sp,-24
8112f3d4:	de00012e 	bgeu	sp,et,8112f3dc <__b2d+0xc>
8112f3d8:	003b68fa 	trap	3
8112f3dc:	dc000015 	stw	r16,0(sp)
8112f3e0:	24000417 	ldw	r16,16(r4)
8112f3e4:	dc400115 	stw	r17,4(sp)
8112f3e8:	24400504 	addi	r17,r4,20
8112f3ec:	8421883a 	add	r16,r16,r16
8112f3f0:	8421883a 	add	r16,r16,r16
8112f3f4:	8c21883a 	add	r16,r17,r16
8112f3f8:	dc800215 	stw	r18,8(sp)
8112f3fc:	84bfff17 	ldw	r18,-4(r16)
8112f400:	dd000415 	stw	r20,16(sp)
8112f404:	dcc00315 	stw	r19,12(sp)
8112f408:	9009883a 	mov	r4,r18
8112f40c:	2829883a 	mov	r20,r5
8112f410:	dfc00515 	stw	ra,20(sp)
8112f414:	112eb140 	call	8112eb14 <__hi0bits>
8112f418:	00c00804 	movi	r3,32
8112f41c:	1889c83a 	sub	r4,r3,r2
8112f420:	a1000015 	stw	r4,0(r20)
8112f424:	01000284 	movi	r4,10
8112f428:	84ffff04 	addi	r19,r16,-4
8112f42c:	20801216 	blt	r4,r2,8112f478 <__b2d+0xa8>
8112f430:	018002c4 	movi	r6,11
8112f434:	308dc83a 	sub	r6,r6,r2
8112f438:	9186d83a 	srl	r3,r18,r6
8112f43c:	18cffc34 	orhi	r3,r3,16368
8112f440:	8cc0212e 	bgeu	r17,r19,8112f4c8 <__b2d+0xf8>
8112f444:	813ffe17 	ldw	r4,-8(r16)
8112f448:	218cd83a 	srl	r6,r4,r6
8112f44c:	10800544 	addi	r2,r2,21
8112f450:	9084983a 	sll	r2,r18,r2
8112f454:	1184b03a 	or	r2,r2,r6
8112f458:	dfc00517 	ldw	ra,20(sp)
8112f45c:	dd000417 	ldw	r20,16(sp)
8112f460:	dcc00317 	ldw	r19,12(sp)
8112f464:	dc800217 	ldw	r18,8(sp)
8112f468:	dc400117 	ldw	r17,4(sp)
8112f46c:	dc000017 	ldw	r16,0(sp)
8112f470:	dec00604 	addi	sp,sp,24
8112f474:	f800283a 	ret
8112f478:	8cc00f2e 	bgeu	r17,r19,8112f4b8 <__b2d+0xe8>
8112f47c:	117ffd44 	addi	r5,r2,-11
8112f480:	80bffe17 	ldw	r2,-8(r16)
8112f484:	28000e26 	beq	r5,zero,8112f4c0 <__b2d+0xf0>
8112f488:	1949c83a 	sub	r4,r3,r5
8112f48c:	9164983a 	sll	r18,r18,r5
8112f490:	1106d83a 	srl	r3,r2,r4
8112f494:	81bffe04 	addi	r6,r16,-8
8112f498:	948ffc34 	orhi	r18,r18,16368
8112f49c:	90c6b03a 	or	r3,r18,r3
8112f4a0:	89800e2e 	bgeu	r17,r6,8112f4dc <__b2d+0x10c>
8112f4a4:	81bffd17 	ldw	r6,-12(r16)
8112f4a8:	1144983a 	sll	r2,r2,r5
8112f4ac:	310ad83a 	srl	r5,r6,r4
8112f4b0:	2884b03a 	or	r2,r5,r2
8112f4b4:	003fe806 	br	8112f458 <__reset+0xfb10f458>
8112f4b8:	10bffd44 	addi	r2,r2,-11
8112f4bc:	1000041e 	bne	r2,zero,8112f4d0 <__b2d+0x100>
8112f4c0:	90cffc34 	orhi	r3,r18,16368
8112f4c4:	003fe406 	br	8112f458 <__reset+0xfb10f458>
8112f4c8:	000d883a 	mov	r6,zero
8112f4cc:	003fdf06 	br	8112f44c <__reset+0xfb10f44c>
8112f4d0:	90a4983a 	sll	r18,r18,r2
8112f4d4:	0005883a 	mov	r2,zero
8112f4d8:	003ff906 	br	8112f4c0 <__reset+0xfb10f4c0>
8112f4dc:	1144983a 	sll	r2,r2,r5
8112f4e0:	003fdd06 	br	8112f458 <__reset+0xfb10f458>

8112f4e4 <__d2b>:
8112f4e4:	defff804 	addi	sp,sp,-32
8112f4e8:	de00012e 	bgeu	sp,et,8112f4f0 <__d2b+0xc>
8112f4ec:	003b68fa 	trap	3
8112f4f0:	dc000215 	stw	r16,8(sp)
8112f4f4:	3021883a 	mov	r16,r6
8112f4f8:	dc400315 	stw	r17,12(sp)
8112f4fc:	8022907a 	slli	r17,r16,1
8112f500:	dd000615 	stw	r20,24(sp)
8112f504:	2829883a 	mov	r20,r5
8112f508:	01400044 	movi	r5,1
8112f50c:	dcc00515 	stw	r19,20(sp)
8112f510:	dc800415 	stw	r18,16(sp)
8112f514:	dfc00715 	stw	ra,28(sp)
8112f518:	3825883a 	mov	r18,r7
8112f51c:	8822d57a 	srli	r17,r17,21
8112f520:	112e8080 	call	8112e808 <_Balloc>
8112f524:	1027883a 	mov	r19,r2
8112f528:	00800434 	movhi	r2,16
8112f52c:	10bfffc4 	addi	r2,r2,-1
8112f530:	808c703a 	and	r6,r16,r2
8112f534:	88000126 	beq	r17,zero,8112f53c <__d2b+0x58>
8112f538:	31800434 	orhi	r6,r6,16
8112f53c:	d9800015 	stw	r6,0(sp)
8112f540:	a0002426 	beq	r20,zero,8112f5d4 <__d2b+0xf0>
8112f544:	d9000104 	addi	r4,sp,4
8112f548:	dd000115 	stw	r20,4(sp)
8112f54c:	112eb7c0 	call	8112eb7c <__lo0bits>
8112f550:	d8c00017 	ldw	r3,0(sp)
8112f554:	10002f1e 	bne	r2,zero,8112f614 <__d2b+0x130>
8112f558:	d9000117 	ldw	r4,4(sp)
8112f55c:	99000515 	stw	r4,20(r19)
8112f560:	1821003a 	cmpeq	r16,r3,zero
8112f564:	01000084 	movi	r4,2
8112f568:	2421c83a 	sub	r16,r4,r16
8112f56c:	98c00615 	stw	r3,24(r19)
8112f570:	9c000415 	stw	r16,16(r19)
8112f574:	88001f1e 	bne	r17,zero,8112f5f4 <__d2b+0x110>
8112f578:	10bef384 	addi	r2,r2,-1074
8112f57c:	90800015 	stw	r2,0(r18)
8112f580:	00900034 	movhi	r2,16384
8112f584:	10bfffc4 	addi	r2,r2,-1
8112f588:	8085883a 	add	r2,r16,r2
8112f58c:	1085883a 	add	r2,r2,r2
8112f590:	1085883a 	add	r2,r2,r2
8112f594:	9885883a 	add	r2,r19,r2
8112f598:	11000517 	ldw	r4,20(r2)
8112f59c:	8020917a 	slli	r16,r16,5
8112f5a0:	112eb140 	call	8112eb14 <__hi0bits>
8112f5a4:	d8c00817 	ldw	r3,32(sp)
8112f5a8:	8085c83a 	sub	r2,r16,r2
8112f5ac:	18800015 	stw	r2,0(r3)
8112f5b0:	9805883a 	mov	r2,r19
8112f5b4:	dfc00717 	ldw	ra,28(sp)
8112f5b8:	dd000617 	ldw	r20,24(sp)
8112f5bc:	dcc00517 	ldw	r19,20(sp)
8112f5c0:	dc800417 	ldw	r18,16(sp)
8112f5c4:	dc400317 	ldw	r17,12(sp)
8112f5c8:	dc000217 	ldw	r16,8(sp)
8112f5cc:	dec00804 	addi	sp,sp,32
8112f5d0:	f800283a 	ret
8112f5d4:	d809883a 	mov	r4,sp
8112f5d8:	112eb7c0 	call	8112eb7c <__lo0bits>
8112f5dc:	d8c00017 	ldw	r3,0(sp)
8112f5e0:	04000044 	movi	r16,1
8112f5e4:	9c000415 	stw	r16,16(r19)
8112f5e8:	98c00515 	stw	r3,20(r19)
8112f5ec:	10800804 	addi	r2,r2,32
8112f5f0:	883fe126 	beq	r17,zero,8112f578 <__reset+0xfb10f578>
8112f5f4:	00c00d44 	movi	r3,53
8112f5f8:	8c7ef344 	addi	r17,r17,-1075
8112f5fc:	88a3883a 	add	r17,r17,r2
8112f600:	1885c83a 	sub	r2,r3,r2
8112f604:	d8c00817 	ldw	r3,32(sp)
8112f608:	94400015 	stw	r17,0(r18)
8112f60c:	18800015 	stw	r2,0(r3)
8112f610:	003fe706 	br	8112f5b0 <__reset+0xfb10f5b0>
8112f614:	01000804 	movi	r4,32
8112f618:	2089c83a 	sub	r4,r4,r2
8112f61c:	1908983a 	sll	r4,r3,r4
8112f620:	d9400117 	ldw	r5,4(sp)
8112f624:	1886d83a 	srl	r3,r3,r2
8112f628:	2148b03a 	or	r4,r4,r5
8112f62c:	99000515 	stw	r4,20(r19)
8112f630:	d8c00015 	stw	r3,0(sp)
8112f634:	003fca06 	br	8112f560 <__reset+0xfb10f560>

8112f638 <__ratio>:
8112f638:	defff904 	addi	sp,sp,-28
8112f63c:	de00012e 	bgeu	sp,et,8112f644 <__ratio+0xc>
8112f640:	003b68fa 	trap	3
8112f644:	dc400315 	stw	r17,12(sp)
8112f648:	2823883a 	mov	r17,r5
8112f64c:	d9400104 	addi	r5,sp,4
8112f650:	dfc00615 	stw	ra,24(sp)
8112f654:	dcc00515 	stw	r19,20(sp)
8112f658:	dc800415 	stw	r18,16(sp)
8112f65c:	2027883a 	mov	r19,r4
8112f660:	dc000215 	stw	r16,8(sp)
8112f664:	112f3d00 	call	8112f3d0 <__b2d>
8112f668:	d80b883a 	mov	r5,sp
8112f66c:	8809883a 	mov	r4,r17
8112f670:	1025883a 	mov	r18,r2
8112f674:	1821883a 	mov	r16,r3
8112f678:	112f3d00 	call	8112f3d0 <__b2d>
8112f67c:	8a000417 	ldw	r8,16(r17)
8112f680:	99000417 	ldw	r4,16(r19)
8112f684:	d9400117 	ldw	r5,4(sp)
8112f688:	2209c83a 	sub	r4,r4,r8
8112f68c:	2010917a 	slli	r8,r4,5
8112f690:	d9000017 	ldw	r4,0(sp)
8112f694:	2909c83a 	sub	r4,r5,r4
8112f698:	4109883a 	add	r4,r8,r4
8112f69c:	01000e0e 	bge	zero,r4,8112f6d8 <__ratio+0xa0>
8112f6a0:	2008953a 	slli	r4,r4,20
8112f6a4:	2421883a 	add	r16,r4,r16
8112f6a8:	100d883a 	mov	r6,r2
8112f6ac:	180f883a 	mov	r7,r3
8112f6b0:	9009883a 	mov	r4,r18
8112f6b4:	800b883a 	mov	r5,r16
8112f6b8:	11373c80 	call	811373c8 <__divdf3>
8112f6bc:	dfc00617 	ldw	ra,24(sp)
8112f6c0:	dcc00517 	ldw	r19,20(sp)
8112f6c4:	dc800417 	ldw	r18,16(sp)
8112f6c8:	dc400317 	ldw	r17,12(sp)
8112f6cc:	dc000217 	ldw	r16,8(sp)
8112f6d0:	dec00704 	addi	sp,sp,28
8112f6d4:	f800283a 	ret
8112f6d8:	2008953a 	slli	r4,r4,20
8112f6dc:	1907c83a 	sub	r3,r3,r4
8112f6e0:	003ff106 	br	8112f6a8 <__reset+0xfb10f6a8>

8112f6e4 <_mprec_log10>:
8112f6e4:	defffe04 	addi	sp,sp,-8
8112f6e8:	de00012e 	bgeu	sp,et,8112f6f0 <_mprec_log10+0xc>
8112f6ec:	003b68fa 	trap	3
8112f6f0:	008005c4 	movi	r2,23
8112f6f4:	dc000015 	stw	r16,0(sp)
8112f6f8:	dfc00115 	stw	ra,4(sp)
8112f6fc:	2021883a 	mov	r16,r4
8112f700:	11000d0e 	bge	r2,r4,8112f738 <_mprec_log10+0x54>
8112f704:	0005883a 	mov	r2,zero
8112f708:	00cffc34 	movhi	r3,16368
8112f70c:	843fffc4 	addi	r16,r16,-1
8112f710:	000d883a 	mov	r6,zero
8112f714:	01d00934 	movhi	r7,16420
8112f718:	1009883a 	mov	r4,r2
8112f71c:	180b883a 	mov	r5,r3
8112f720:	1121c800 	call	81121c80 <__muldf3>
8112f724:	803ff91e 	bne	r16,zero,8112f70c <__reset+0xfb10f70c>
8112f728:	dfc00117 	ldw	ra,4(sp)
8112f72c:	dc000017 	ldw	r16,0(sp)
8112f730:	dec00204 	addi	sp,sp,8
8112f734:	f800283a 	ret
8112f738:	202090fa 	slli	r16,r4,3
8112f73c:	00a04574 	movhi	r2,33045
8112f740:	1089d104 	addi	r2,r2,10052
8112f744:	1421883a 	add	r16,r2,r16
8112f748:	80800017 	ldw	r2,0(r16)
8112f74c:	80c00117 	ldw	r3,4(r16)
8112f750:	dfc00117 	ldw	ra,4(sp)
8112f754:	dc000017 	ldw	r16,0(sp)
8112f758:	dec00204 	addi	sp,sp,8
8112f75c:	f800283a 	ret

8112f760 <__copybits>:
8112f760:	297fffc4 	addi	r5,r5,-1
8112f764:	280fd17a 	srai	r7,r5,5
8112f768:	30c00417 	ldw	r3,16(r6)
8112f76c:	30800504 	addi	r2,r6,20
8112f770:	39c00044 	addi	r7,r7,1
8112f774:	18c7883a 	add	r3,r3,r3
8112f778:	39cf883a 	add	r7,r7,r7
8112f77c:	18c7883a 	add	r3,r3,r3
8112f780:	39cf883a 	add	r7,r7,r7
8112f784:	10c7883a 	add	r3,r2,r3
8112f788:	21cf883a 	add	r7,r4,r7
8112f78c:	10c00d2e 	bgeu	r2,r3,8112f7c4 <__copybits+0x64>
8112f790:	200b883a 	mov	r5,r4
8112f794:	12000017 	ldw	r8,0(r2)
8112f798:	29400104 	addi	r5,r5,4
8112f79c:	10800104 	addi	r2,r2,4
8112f7a0:	2a3fff15 	stw	r8,-4(r5)
8112f7a4:	10fffb36 	bltu	r2,r3,8112f794 <__reset+0xfb10f794>
8112f7a8:	1985c83a 	sub	r2,r3,r6
8112f7ac:	10bffac4 	addi	r2,r2,-21
8112f7b0:	1004d0ba 	srli	r2,r2,2
8112f7b4:	10800044 	addi	r2,r2,1
8112f7b8:	1085883a 	add	r2,r2,r2
8112f7bc:	1085883a 	add	r2,r2,r2
8112f7c0:	2089883a 	add	r4,r4,r2
8112f7c4:	21c0032e 	bgeu	r4,r7,8112f7d4 <__copybits+0x74>
8112f7c8:	20000015 	stw	zero,0(r4)
8112f7cc:	21000104 	addi	r4,r4,4
8112f7d0:	21fffd36 	bltu	r4,r7,8112f7c8 <__reset+0xfb10f7c8>
8112f7d4:	f800283a 	ret

8112f7d8 <__any_on>:
8112f7d8:	20c00417 	ldw	r3,16(r4)
8112f7dc:	2805d17a 	srai	r2,r5,5
8112f7e0:	21000504 	addi	r4,r4,20
8112f7e4:	18800d0e 	bge	r3,r2,8112f81c <__any_on+0x44>
8112f7e8:	18c7883a 	add	r3,r3,r3
8112f7ec:	18c7883a 	add	r3,r3,r3
8112f7f0:	20c7883a 	add	r3,r4,r3
8112f7f4:	20c0192e 	bgeu	r4,r3,8112f85c <__any_on+0x84>
8112f7f8:	18bfff17 	ldw	r2,-4(r3)
8112f7fc:	18ffff04 	addi	r3,r3,-4
8112f800:	1000041e 	bne	r2,zero,8112f814 <__any_on+0x3c>
8112f804:	20c0142e 	bgeu	r4,r3,8112f858 <__any_on+0x80>
8112f808:	18ffff04 	addi	r3,r3,-4
8112f80c:	19400017 	ldw	r5,0(r3)
8112f810:	283ffc26 	beq	r5,zero,8112f804 <__reset+0xfb10f804>
8112f814:	00800044 	movi	r2,1
8112f818:	f800283a 	ret
8112f81c:	10c00a0e 	bge	r2,r3,8112f848 <__any_on+0x70>
8112f820:	1085883a 	add	r2,r2,r2
8112f824:	1085883a 	add	r2,r2,r2
8112f828:	294007cc 	andi	r5,r5,31
8112f82c:	2087883a 	add	r3,r4,r2
8112f830:	283ff026 	beq	r5,zero,8112f7f4 <__reset+0xfb10f7f4>
8112f834:	19800017 	ldw	r6,0(r3)
8112f838:	3144d83a 	srl	r2,r6,r5
8112f83c:	114a983a 	sll	r5,r2,r5
8112f840:	317ff41e 	bne	r6,r5,8112f814 <__reset+0xfb10f814>
8112f844:	003feb06 	br	8112f7f4 <__reset+0xfb10f7f4>
8112f848:	1085883a 	add	r2,r2,r2
8112f84c:	1085883a 	add	r2,r2,r2
8112f850:	2087883a 	add	r3,r4,r2
8112f854:	003fe706 	br	8112f7f4 <__reset+0xfb10f7f4>
8112f858:	f800283a 	ret
8112f85c:	0005883a 	mov	r2,zero
8112f860:	f800283a 	ret

8112f864 <_read_r>:
8112f864:	defffd04 	addi	sp,sp,-12
8112f868:	de00012e 	bgeu	sp,et,8112f870 <_read_r+0xc>
8112f86c:	003b68fa 	trap	3
8112f870:	2805883a 	mov	r2,r5
8112f874:	dc000015 	stw	r16,0(sp)
8112f878:	04204574 	movhi	r16,33045
8112f87c:	dc400115 	stw	r17,4(sp)
8112f880:	300b883a 	mov	r5,r6
8112f884:	8413d304 	addi	r16,r16,20300
8112f888:	2023883a 	mov	r17,r4
8112f88c:	380d883a 	mov	r6,r7
8112f890:	1009883a 	mov	r4,r2
8112f894:	dfc00215 	stw	ra,8(sp)
8112f898:	80000015 	stw	zero,0(r16)
8112f89c:	11395380 	call	81139538 <read>
8112f8a0:	00ffffc4 	movi	r3,-1
8112f8a4:	10c00526 	beq	r2,r3,8112f8bc <_read_r+0x58>
8112f8a8:	dfc00217 	ldw	ra,8(sp)
8112f8ac:	dc400117 	ldw	r17,4(sp)
8112f8b0:	dc000017 	ldw	r16,0(sp)
8112f8b4:	dec00304 	addi	sp,sp,12
8112f8b8:	f800283a 	ret
8112f8bc:	80c00017 	ldw	r3,0(r16)
8112f8c0:	183ff926 	beq	r3,zero,8112f8a8 <__reset+0xfb10f8a8>
8112f8c4:	88c00015 	stw	r3,0(r17)
8112f8c8:	003ff706 	br	8112f8a8 <__reset+0xfb10f8a8>

8112f8cc <_realloc_r>:
8112f8cc:	defff604 	addi	sp,sp,-40
8112f8d0:	de00012e 	bgeu	sp,et,8112f8d8 <_realloc_r+0xc>
8112f8d4:	003b68fa 	trap	3
8112f8d8:	dc800215 	stw	r18,8(sp)
8112f8dc:	dfc00915 	stw	ra,36(sp)
8112f8e0:	df000815 	stw	fp,32(sp)
8112f8e4:	ddc00715 	stw	r23,28(sp)
8112f8e8:	dd800615 	stw	r22,24(sp)
8112f8ec:	dd400515 	stw	r21,20(sp)
8112f8f0:	dd000415 	stw	r20,16(sp)
8112f8f4:	dcc00315 	stw	r19,12(sp)
8112f8f8:	dc400115 	stw	r17,4(sp)
8112f8fc:	dc000015 	stw	r16,0(sp)
8112f900:	3025883a 	mov	r18,r6
8112f904:	2800b726 	beq	r5,zero,8112fbe4 <_realloc_r+0x318>
8112f908:	282b883a 	mov	r21,r5
8112f90c:	2029883a 	mov	r20,r4
8112f910:	1139d180 	call	81139d18 <__malloc_lock>
8112f914:	a8bfff17 	ldw	r2,-4(r21)
8112f918:	043fff04 	movi	r16,-4
8112f91c:	90c002c4 	addi	r3,r18,11
8112f920:	01000584 	movi	r4,22
8112f924:	acfffe04 	addi	r19,r21,-8
8112f928:	1420703a 	and	r16,r2,r16
8112f92c:	20c0332e 	bgeu	r4,r3,8112f9fc <_realloc_r+0x130>
8112f930:	047ffe04 	movi	r17,-8
8112f934:	1c62703a 	and	r17,r3,r17
8112f938:	8807883a 	mov	r3,r17
8112f93c:	88005816 	blt	r17,zero,8112faa0 <_realloc_r+0x1d4>
8112f940:	8c805736 	bltu	r17,r18,8112faa0 <_realloc_r+0x1d4>
8112f944:	80c0300e 	bge	r16,r3,8112fa08 <_realloc_r+0x13c>
8112f948:	07204574 	movhi	fp,33045
8112f94c:	e70d1e04 	addi	fp,fp,13432
8112f950:	e1c00217 	ldw	r7,8(fp)
8112f954:	9c09883a 	add	r4,r19,r16
8112f958:	22000117 	ldw	r8,4(r4)
8112f95c:	21c06326 	beq	r4,r7,8112faec <_realloc_r+0x220>
8112f960:	017fff84 	movi	r5,-2
8112f964:	414a703a 	and	r5,r8,r5
8112f968:	214b883a 	add	r5,r4,r5
8112f96c:	29800117 	ldw	r6,4(r5)
8112f970:	3180004c 	andi	r6,r6,1
8112f974:	30003f26 	beq	r6,zero,8112fa74 <_realloc_r+0x1a8>
8112f978:	1080004c 	andi	r2,r2,1
8112f97c:	10008326 	beq	r2,zero,8112fb8c <_realloc_r+0x2c0>
8112f980:	900b883a 	mov	r5,r18
8112f984:	a009883a 	mov	r4,r20
8112f988:	1123b3c0 	call	81123b3c <_malloc_r>
8112f98c:	1025883a 	mov	r18,r2
8112f990:	10011e26 	beq	r2,zero,8112fe0c <_realloc_r+0x540>
8112f994:	a93fff17 	ldw	r4,-4(r21)
8112f998:	10fffe04 	addi	r3,r2,-8
8112f99c:	00bfff84 	movi	r2,-2
8112f9a0:	2084703a 	and	r2,r4,r2
8112f9a4:	9885883a 	add	r2,r19,r2
8112f9a8:	1880ee26 	beq	r3,r2,8112fd64 <_realloc_r+0x498>
8112f9ac:	81bfff04 	addi	r6,r16,-4
8112f9b0:	00800904 	movi	r2,36
8112f9b4:	1180b836 	bltu	r2,r6,8112fc98 <_realloc_r+0x3cc>
8112f9b8:	00c004c4 	movi	r3,19
8112f9bc:	19809636 	bltu	r3,r6,8112fc18 <_realloc_r+0x34c>
8112f9c0:	9005883a 	mov	r2,r18
8112f9c4:	a807883a 	mov	r3,r21
8112f9c8:	19000017 	ldw	r4,0(r3)
8112f9cc:	11000015 	stw	r4,0(r2)
8112f9d0:	19000117 	ldw	r4,4(r3)
8112f9d4:	11000115 	stw	r4,4(r2)
8112f9d8:	18c00217 	ldw	r3,8(r3)
8112f9dc:	10c00215 	stw	r3,8(r2)
8112f9e0:	a80b883a 	mov	r5,r21
8112f9e4:	a009883a 	mov	r4,r20
8112f9e8:	112d8380 	call	8112d838 <_free_r>
8112f9ec:	a009883a 	mov	r4,r20
8112f9f0:	1139e400 	call	81139e40 <__malloc_unlock>
8112f9f4:	9005883a 	mov	r2,r18
8112f9f8:	00001206 	br	8112fa44 <_realloc_r+0x178>
8112f9fc:	00c00404 	movi	r3,16
8112fa00:	1823883a 	mov	r17,r3
8112fa04:	003fce06 	br	8112f940 <__reset+0xfb10f940>
8112fa08:	a825883a 	mov	r18,r21
8112fa0c:	8445c83a 	sub	r2,r16,r17
8112fa10:	00c003c4 	movi	r3,15
8112fa14:	18802636 	bltu	r3,r2,8112fab0 <_realloc_r+0x1e4>
8112fa18:	99800117 	ldw	r6,4(r19)
8112fa1c:	9c07883a 	add	r3,r19,r16
8112fa20:	3180004c 	andi	r6,r6,1
8112fa24:	3420b03a 	or	r16,r6,r16
8112fa28:	9c000115 	stw	r16,4(r19)
8112fa2c:	18800117 	ldw	r2,4(r3)
8112fa30:	10800054 	ori	r2,r2,1
8112fa34:	18800115 	stw	r2,4(r3)
8112fa38:	a009883a 	mov	r4,r20
8112fa3c:	1139e400 	call	81139e40 <__malloc_unlock>
8112fa40:	9005883a 	mov	r2,r18
8112fa44:	dfc00917 	ldw	ra,36(sp)
8112fa48:	df000817 	ldw	fp,32(sp)
8112fa4c:	ddc00717 	ldw	r23,28(sp)
8112fa50:	dd800617 	ldw	r22,24(sp)
8112fa54:	dd400517 	ldw	r21,20(sp)
8112fa58:	dd000417 	ldw	r20,16(sp)
8112fa5c:	dcc00317 	ldw	r19,12(sp)
8112fa60:	dc800217 	ldw	r18,8(sp)
8112fa64:	dc400117 	ldw	r17,4(sp)
8112fa68:	dc000017 	ldw	r16,0(sp)
8112fa6c:	dec00a04 	addi	sp,sp,40
8112fa70:	f800283a 	ret
8112fa74:	017fff04 	movi	r5,-4
8112fa78:	414a703a 	and	r5,r8,r5
8112fa7c:	814d883a 	add	r6,r16,r5
8112fa80:	30c01f16 	blt	r6,r3,8112fb00 <_realloc_r+0x234>
8112fa84:	20800317 	ldw	r2,12(r4)
8112fa88:	20c00217 	ldw	r3,8(r4)
8112fa8c:	a825883a 	mov	r18,r21
8112fa90:	3021883a 	mov	r16,r6
8112fa94:	18800315 	stw	r2,12(r3)
8112fa98:	10c00215 	stw	r3,8(r2)
8112fa9c:	003fdb06 	br	8112fa0c <__reset+0xfb10fa0c>
8112faa0:	00800304 	movi	r2,12
8112faa4:	a0800015 	stw	r2,0(r20)
8112faa8:	0005883a 	mov	r2,zero
8112faac:	003fe506 	br	8112fa44 <__reset+0xfb10fa44>
8112fab0:	98c00117 	ldw	r3,4(r19)
8112fab4:	9c4b883a 	add	r5,r19,r17
8112fab8:	11000054 	ori	r4,r2,1
8112fabc:	18c0004c 	andi	r3,r3,1
8112fac0:	1c62b03a 	or	r17,r3,r17
8112fac4:	9c400115 	stw	r17,4(r19)
8112fac8:	29000115 	stw	r4,4(r5)
8112facc:	2885883a 	add	r2,r5,r2
8112fad0:	10c00117 	ldw	r3,4(r2)
8112fad4:	29400204 	addi	r5,r5,8
8112fad8:	a009883a 	mov	r4,r20
8112fadc:	18c00054 	ori	r3,r3,1
8112fae0:	10c00115 	stw	r3,4(r2)
8112fae4:	112d8380 	call	8112d838 <_free_r>
8112fae8:	003fd306 	br	8112fa38 <__reset+0xfb10fa38>
8112faec:	017fff04 	movi	r5,-4
8112faf0:	414a703a 	and	r5,r8,r5
8112faf4:	89800404 	addi	r6,r17,16
8112faf8:	8151883a 	add	r8,r16,r5
8112fafc:	4180590e 	bge	r8,r6,8112fc64 <_realloc_r+0x398>
8112fb00:	1080004c 	andi	r2,r2,1
8112fb04:	103f9e1e 	bne	r2,zero,8112f980 <__reset+0xfb10f980>
8112fb08:	adbffe17 	ldw	r22,-8(r21)
8112fb0c:	00bfff04 	movi	r2,-4
8112fb10:	9dadc83a 	sub	r22,r19,r22
8112fb14:	b1800117 	ldw	r6,4(r22)
8112fb18:	3084703a 	and	r2,r6,r2
8112fb1c:	20002026 	beq	r4,zero,8112fba0 <_realloc_r+0x2d4>
8112fb20:	80af883a 	add	r23,r16,r2
8112fb24:	b96f883a 	add	r23,r23,r5
8112fb28:	21c05f26 	beq	r4,r7,8112fca8 <_realloc_r+0x3dc>
8112fb2c:	b8c01c16 	blt	r23,r3,8112fba0 <_realloc_r+0x2d4>
8112fb30:	20800317 	ldw	r2,12(r4)
8112fb34:	20c00217 	ldw	r3,8(r4)
8112fb38:	81bfff04 	addi	r6,r16,-4
8112fb3c:	01000904 	movi	r4,36
8112fb40:	18800315 	stw	r2,12(r3)
8112fb44:	10c00215 	stw	r3,8(r2)
8112fb48:	b0c00217 	ldw	r3,8(r22)
8112fb4c:	b0800317 	ldw	r2,12(r22)
8112fb50:	b4800204 	addi	r18,r22,8
8112fb54:	18800315 	stw	r2,12(r3)
8112fb58:	10c00215 	stw	r3,8(r2)
8112fb5c:	21801b36 	bltu	r4,r6,8112fbcc <_realloc_r+0x300>
8112fb60:	008004c4 	movi	r2,19
8112fb64:	1180352e 	bgeu	r2,r6,8112fc3c <_realloc_r+0x370>
8112fb68:	a8800017 	ldw	r2,0(r21)
8112fb6c:	b0800215 	stw	r2,8(r22)
8112fb70:	a8800117 	ldw	r2,4(r21)
8112fb74:	b0800315 	stw	r2,12(r22)
8112fb78:	008006c4 	movi	r2,27
8112fb7c:	11807f36 	bltu	r2,r6,8112fd7c <_realloc_r+0x4b0>
8112fb80:	b0800404 	addi	r2,r22,16
8112fb84:	ad400204 	addi	r21,r21,8
8112fb88:	00002d06 	br	8112fc40 <_realloc_r+0x374>
8112fb8c:	adbffe17 	ldw	r22,-8(r21)
8112fb90:	00bfff04 	movi	r2,-4
8112fb94:	9dadc83a 	sub	r22,r19,r22
8112fb98:	b1000117 	ldw	r4,4(r22)
8112fb9c:	2084703a 	and	r2,r4,r2
8112fba0:	b03f7726 	beq	r22,zero,8112f980 <__reset+0xfb10f980>
8112fba4:	80af883a 	add	r23,r16,r2
8112fba8:	b8ff7516 	blt	r23,r3,8112f980 <__reset+0xfb10f980>
8112fbac:	b0800317 	ldw	r2,12(r22)
8112fbb0:	b0c00217 	ldw	r3,8(r22)
8112fbb4:	81bfff04 	addi	r6,r16,-4
8112fbb8:	01000904 	movi	r4,36
8112fbbc:	18800315 	stw	r2,12(r3)
8112fbc0:	10c00215 	stw	r3,8(r2)
8112fbc4:	b4800204 	addi	r18,r22,8
8112fbc8:	21bfe52e 	bgeu	r4,r6,8112fb60 <__reset+0xfb10fb60>
8112fbcc:	a80b883a 	mov	r5,r21
8112fbd0:	9009883a 	mov	r4,r18
8112fbd4:	112e6ac0 	call	8112e6ac <memmove>
8112fbd8:	b821883a 	mov	r16,r23
8112fbdc:	b027883a 	mov	r19,r22
8112fbe0:	003f8a06 	br	8112fa0c <__reset+0xfb10fa0c>
8112fbe4:	300b883a 	mov	r5,r6
8112fbe8:	dfc00917 	ldw	ra,36(sp)
8112fbec:	df000817 	ldw	fp,32(sp)
8112fbf0:	ddc00717 	ldw	r23,28(sp)
8112fbf4:	dd800617 	ldw	r22,24(sp)
8112fbf8:	dd400517 	ldw	r21,20(sp)
8112fbfc:	dd000417 	ldw	r20,16(sp)
8112fc00:	dcc00317 	ldw	r19,12(sp)
8112fc04:	dc800217 	ldw	r18,8(sp)
8112fc08:	dc400117 	ldw	r17,4(sp)
8112fc0c:	dc000017 	ldw	r16,0(sp)
8112fc10:	dec00a04 	addi	sp,sp,40
8112fc14:	1123b3c1 	jmpi	81123b3c <_malloc_r>
8112fc18:	a8c00017 	ldw	r3,0(r21)
8112fc1c:	90c00015 	stw	r3,0(r18)
8112fc20:	a8c00117 	ldw	r3,4(r21)
8112fc24:	90c00115 	stw	r3,4(r18)
8112fc28:	00c006c4 	movi	r3,27
8112fc2c:	19804536 	bltu	r3,r6,8112fd44 <_realloc_r+0x478>
8112fc30:	90800204 	addi	r2,r18,8
8112fc34:	a8c00204 	addi	r3,r21,8
8112fc38:	003f6306 	br	8112f9c8 <__reset+0xfb10f9c8>
8112fc3c:	9005883a 	mov	r2,r18
8112fc40:	a8c00017 	ldw	r3,0(r21)
8112fc44:	b821883a 	mov	r16,r23
8112fc48:	b027883a 	mov	r19,r22
8112fc4c:	10c00015 	stw	r3,0(r2)
8112fc50:	a8c00117 	ldw	r3,4(r21)
8112fc54:	10c00115 	stw	r3,4(r2)
8112fc58:	a8c00217 	ldw	r3,8(r21)
8112fc5c:	10c00215 	stw	r3,8(r2)
8112fc60:	003f6a06 	br	8112fa0c <__reset+0xfb10fa0c>
8112fc64:	9c67883a 	add	r19,r19,r17
8112fc68:	4445c83a 	sub	r2,r8,r17
8112fc6c:	e4c00215 	stw	r19,8(fp)
8112fc70:	10800054 	ori	r2,r2,1
8112fc74:	98800115 	stw	r2,4(r19)
8112fc78:	a8bfff17 	ldw	r2,-4(r21)
8112fc7c:	a009883a 	mov	r4,r20
8112fc80:	1080004c 	andi	r2,r2,1
8112fc84:	1462b03a 	or	r17,r2,r17
8112fc88:	ac7fff15 	stw	r17,-4(r21)
8112fc8c:	1139e400 	call	81139e40 <__malloc_unlock>
8112fc90:	a805883a 	mov	r2,r21
8112fc94:	003f6b06 	br	8112fa44 <__reset+0xfb10fa44>
8112fc98:	a80b883a 	mov	r5,r21
8112fc9c:	9009883a 	mov	r4,r18
8112fca0:	112e6ac0 	call	8112e6ac <memmove>
8112fca4:	003f4e06 	br	8112f9e0 <__reset+0xfb10f9e0>
8112fca8:	89000404 	addi	r4,r17,16
8112fcac:	b93fbc16 	blt	r23,r4,8112fba0 <__reset+0xfb10fba0>
8112fcb0:	b0800317 	ldw	r2,12(r22)
8112fcb4:	b0c00217 	ldw	r3,8(r22)
8112fcb8:	81bfff04 	addi	r6,r16,-4
8112fcbc:	01000904 	movi	r4,36
8112fcc0:	18800315 	stw	r2,12(r3)
8112fcc4:	10c00215 	stw	r3,8(r2)
8112fcc8:	b4800204 	addi	r18,r22,8
8112fccc:	21804336 	bltu	r4,r6,8112fddc <_realloc_r+0x510>
8112fcd0:	008004c4 	movi	r2,19
8112fcd4:	11803f2e 	bgeu	r2,r6,8112fdd4 <_realloc_r+0x508>
8112fcd8:	a8800017 	ldw	r2,0(r21)
8112fcdc:	b0800215 	stw	r2,8(r22)
8112fce0:	a8800117 	ldw	r2,4(r21)
8112fce4:	b0800315 	stw	r2,12(r22)
8112fce8:	008006c4 	movi	r2,27
8112fcec:	11803f36 	bltu	r2,r6,8112fdec <_realloc_r+0x520>
8112fcf0:	b0800404 	addi	r2,r22,16
8112fcf4:	ad400204 	addi	r21,r21,8
8112fcf8:	a8c00017 	ldw	r3,0(r21)
8112fcfc:	10c00015 	stw	r3,0(r2)
8112fd00:	a8c00117 	ldw	r3,4(r21)
8112fd04:	10c00115 	stw	r3,4(r2)
8112fd08:	a8c00217 	ldw	r3,8(r21)
8112fd0c:	10c00215 	stw	r3,8(r2)
8112fd10:	b447883a 	add	r3,r22,r17
8112fd14:	bc45c83a 	sub	r2,r23,r17
8112fd18:	e0c00215 	stw	r3,8(fp)
8112fd1c:	10800054 	ori	r2,r2,1
8112fd20:	18800115 	stw	r2,4(r3)
8112fd24:	b0800117 	ldw	r2,4(r22)
8112fd28:	a009883a 	mov	r4,r20
8112fd2c:	1080004c 	andi	r2,r2,1
8112fd30:	1462b03a 	or	r17,r2,r17
8112fd34:	b4400115 	stw	r17,4(r22)
8112fd38:	1139e400 	call	81139e40 <__malloc_unlock>
8112fd3c:	9005883a 	mov	r2,r18
8112fd40:	003f4006 	br	8112fa44 <__reset+0xfb10fa44>
8112fd44:	a8c00217 	ldw	r3,8(r21)
8112fd48:	90c00215 	stw	r3,8(r18)
8112fd4c:	a8c00317 	ldw	r3,12(r21)
8112fd50:	90c00315 	stw	r3,12(r18)
8112fd54:	30801126 	beq	r6,r2,8112fd9c <_realloc_r+0x4d0>
8112fd58:	90800404 	addi	r2,r18,16
8112fd5c:	a8c00404 	addi	r3,r21,16
8112fd60:	003f1906 	br	8112f9c8 <__reset+0xfb10f9c8>
8112fd64:	90ffff17 	ldw	r3,-4(r18)
8112fd68:	00bfff04 	movi	r2,-4
8112fd6c:	a825883a 	mov	r18,r21
8112fd70:	1884703a 	and	r2,r3,r2
8112fd74:	80a1883a 	add	r16,r16,r2
8112fd78:	003f2406 	br	8112fa0c <__reset+0xfb10fa0c>
8112fd7c:	a8800217 	ldw	r2,8(r21)
8112fd80:	b0800415 	stw	r2,16(r22)
8112fd84:	a8800317 	ldw	r2,12(r21)
8112fd88:	b0800515 	stw	r2,20(r22)
8112fd8c:	31000a26 	beq	r6,r4,8112fdb8 <_realloc_r+0x4ec>
8112fd90:	b0800604 	addi	r2,r22,24
8112fd94:	ad400404 	addi	r21,r21,16
8112fd98:	003fa906 	br	8112fc40 <__reset+0xfb10fc40>
8112fd9c:	a9000417 	ldw	r4,16(r21)
8112fda0:	90800604 	addi	r2,r18,24
8112fda4:	a8c00604 	addi	r3,r21,24
8112fda8:	91000415 	stw	r4,16(r18)
8112fdac:	a9000517 	ldw	r4,20(r21)
8112fdb0:	91000515 	stw	r4,20(r18)
8112fdb4:	003f0406 	br	8112f9c8 <__reset+0xfb10f9c8>
8112fdb8:	a8c00417 	ldw	r3,16(r21)
8112fdbc:	ad400604 	addi	r21,r21,24
8112fdc0:	b0800804 	addi	r2,r22,32
8112fdc4:	b0c00615 	stw	r3,24(r22)
8112fdc8:	a8ffff17 	ldw	r3,-4(r21)
8112fdcc:	b0c00715 	stw	r3,28(r22)
8112fdd0:	003f9b06 	br	8112fc40 <__reset+0xfb10fc40>
8112fdd4:	9005883a 	mov	r2,r18
8112fdd8:	003fc706 	br	8112fcf8 <__reset+0xfb10fcf8>
8112fddc:	a80b883a 	mov	r5,r21
8112fde0:	9009883a 	mov	r4,r18
8112fde4:	112e6ac0 	call	8112e6ac <memmove>
8112fde8:	003fc906 	br	8112fd10 <__reset+0xfb10fd10>
8112fdec:	a8800217 	ldw	r2,8(r21)
8112fdf0:	b0800415 	stw	r2,16(r22)
8112fdf4:	a8800317 	ldw	r2,12(r21)
8112fdf8:	b0800515 	stw	r2,20(r22)
8112fdfc:	31000726 	beq	r6,r4,8112fe1c <_realloc_r+0x550>
8112fe00:	b0800604 	addi	r2,r22,24
8112fe04:	ad400404 	addi	r21,r21,16
8112fe08:	003fbb06 	br	8112fcf8 <__reset+0xfb10fcf8>
8112fe0c:	a009883a 	mov	r4,r20
8112fe10:	1139e400 	call	81139e40 <__malloc_unlock>
8112fe14:	0005883a 	mov	r2,zero
8112fe18:	003f0a06 	br	8112fa44 <__reset+0xfb10fa44>
8112fe1c:	a8c00417 	ldw	r3,16(r21)
8112fe20:	ad400604 	addi	r21,r21,24
8112fe24:	b0800804 	addi	r2,r22,32
8112fe28:	b0c00615 	stw	r3,24(r22)
8112fe2c:	a8ffff17 	ldw	r3,-4(r21)
8112fe30:	b0c00715 	stw	r3,28(r22)
8112fe34:	003fb006 	br	8112fcf8 <__reset+0xfb10fcf8>

8112fe38 <__fpclassifyd>:
8112fe38:	00a00034 	movhi	r2,32768
8112fe3c:	10bfffc4 	addi	r2,r2,-1
8112fe40:	2884703a 	and	r2,r5,r2
8112fe44:	10000726 	beq	r2,zero,8112fe64 <__fpclassifyd+0x2c>
8112fe48:	00fffc34 	movhi	r3,65520
8112fe4c:	019ff834 	movhi	r6,32736
8112fe50:	28c7883a 	add	r3,r5,r3
8112fe54:	31bfffc4 	addi	r6,r6,-1
8112fe58:	30c00536 	bltu	r6,r3,8112fe70 <__fpclassifyd+0x38>
8112fe5c:	00800104 	movi	r2,4
8112fe60:	f800283a 	ret
8112fe64:	2000021e 	bne	r4,zero,8112fe70 <__fpclassifyd+0x38>
8112fe68:	00800084 	movi	r2,2
8112fe6c:	f800283a 	ret
8112fe70:	00dffc34 	movhi	r3,32752
8112fe74:	019ff834 	movhi	r6,32736
8112fe78:	28cb883a 	add	r5,r5,r3
8112fe7c:	31bfffc4 	addi	r6,r6,-1
8112fe80:	317ff62e 	bgeu	r6,r5,8112fe5c <__reset+0xfb10fe5c>
8112fe84:	01400434 	movhi	r5,16
8112fe88:	297fffc4 	addi	r5,r5,-1
8112fe8c:	28800236 	bltu	r5,r2,8112fe98 <__fpclassifyd+0x60>
8112fe90:	008000c4 	movi	r2,3
8112fe94:	f800283a 	ret
8112fe98:	10c00226 	beq	r2,r3,8112fea4 <__fpclassifyd+0x6c>
8112fe9c:	0005883a 	mov	r2,zero
8112fea0:	f800283a 	ret
8112fea4:	2005003a 	cmpeq	r2,r4,zero
8112fea8:	f800283a 	ret

8112feac <__sccl>:
8112feac:	2a000003 	ldbu	r8,0(r5)
8112feb0:	00801784 	movi	r2,94
8112feb4:	40802a26 	beq	r8,r2,8112ff60 <__sccl+0xb4>
8112feb8:	29400044 	addi	r5,r5,1
8112febc:	000f883a 	mov	r7,zero
8112fec0:	0013883a 	mov	r9,zero
8112fec4:	2007883a 	mov	r3,r4
8112fec8:	21804004 	addi	r6,r4,256
8112fecc:	19c00005 	stb	r7,0(r3)
8112fed0:	18c00044 	addi	r3,r3,1
8112fed4:	19bffd1e 	bne	r3,r6,8112fecc <__reset+0xfb10fecc>
8112fed8:	40001126 	beq	r8,zero,8112ff20 <__sccl+0x74>
8112fedc:	00800044 	movi	r2,1
8112fee0:	124fc83a 	sub	r7,r2,r9
8112fee4:	02800b44 	movi	r10,45
8112fee8:	02c01744 	movi	r11,93
8112feec:	2205883a 	add	r2,r4,r8
8112fef0:	11c00005 	stb	r7,0(r2)
8112fef4:	28800044 	addi	r2,r5,1
8112fef8:	28c00003 	ldbu	r3,0(r5)
8112fefc:	1a800a26 	beq	r3,r10,8112ff28 <__sccl+0x7c>
8112ff00:	1ac00426 	beq	r3,r11,8112ff14 <__sccl+0x68>
8112ff04:	18000426 	beq	r3,zero,8112ff18 <__sccl+0x6c>
8112ff08:	1811883a 	mov	r8,r3
8112ff0c:	100b883a 	mov	r5,r2
8112ff10:	003ff606 	br	8112feec <__reset+0xfb10feec>
8112ff14:	f800283a 	ret
8112ff18:	2805883a 	mov	r2,r5
8112ff1c:	f800283a 	ret
8112ff20:	28bfffc4 	addi	r2,r5,-1
8112ff24:	f800283a 	ret
8112ff28:	12400003 	ldbu	r9,0(r2)
8112ff2c:	4ac01126 	beq	r9,r11,8112ff74 <__sccl+0xc8>
8112ff30:	4a001016 	blt	r9,r8,8112ff74 <__sccl+0xc8>
8112ff34:	41800044 	addi	r6,r8,1
8112ff38:	29400084 	addi	r5,r5,2
8112ff3c:	2187883a 	add	r3,r4,r6
8112ff40:	00000106 	br	8112ff48 <__sccl+0x9c>
8112ff44:	31800044 	addi	r6,r6,1
8112ff48:	19c00005 	stb	r7,0(r3)
8112ff4c:	3011883a 	mov	r8,r6
8112ff50:	18c00044 	addi	r3,r3,1
8112ff54:	327ffb16 	blt	r6,r9,8112ff44 <__reset+0xfb10ff44>
8112ff58:	10800084 	addi	r2,r2,2
8112ff5c:	003fe606 	br	8112fef8 <__reset+0xfb10fef8>
8112ff60:	2a000043 	ldbu	r8,1(r5)
8112ff64:	01c00044 	movi	r7,1
8112ff68:	29400084 	addi	r5,r5,2
8112ff6c:	02400044 	movi	r9,1
8112ff70:	003fd406 	br	8112fec4 <__reset+0xfb10fec4>
8112ff74:	5011883a 	mov	r8,r10
8112ff78:	003fe406 	br	8112ff0c <__reset+0xfb10ff0c>

8112ff7c <nanf>:
8112ff7c:	009ff034 	movhi	r2,32704
8112ff80:	f800283a 	ret

8112ff84 <strcmp>:
8112ff84:	2144b03a 	or	r2,r4,r5
8112ff88:	108000cc 	andi	r2,r2,3
8112ff8c:	1000171e 	bne	r2,zero,8112ffec <strcmp+0x68>
8112ff90:	20800017 	ldw	r2,0(r4)
8112ff94:	28c00017 	ldw	r3,0(r5)
8112ff98:	10c0141e 	bne	r2,r3,8112ffec <strcmp+0x68>
8112ff9c:	027fbff4 	movhi	r9,65279
8112ffa0:	4a7fbfc4 	addi	r9,r9,-257
8112ffa4:	0086303a 	nor	r3,zero,r2
8112ffa8:	02202074 	movhi	r8,32897
8112ffac:	1245883a 	add	r2,r2,r9
8112ffb0:	42202004 	addi	r8,r8,-32640
8112ffb4:	10c4703a 	and	r2,r2,r3
8112ffb8:	1204703a 	and	r2,r2,r8
8112ffbc:	10000226 	beq	r2,zero,8112ffc8 <strcmp+0x44>
8112ffc0:	00002306 	br	81130050 <strcmp+0xcc>
8112ffc4:	1000221e 	bne	r2,zero,81130050 <strcmp+0xcc>
8112ffc8:	21000104 	addi	r4,r4,4
8112ffcc:	20c00017 	ldw	r3,0(r4)
8112ffd0:	29400104 	addi	r5,r5,4
8112ffd4:	29800017 	ldw	r6,0(r5)
8112ffd8:	1a4f883a 	add	r7,r3,r9
8112ffdc:	00c4303a 	nor	r2,zero,r3
8112ffe0:	3884703a 	and	r2,r7,r2
8112ffe4:	1204703a 	and	r2,r2,r8
8112ffe8:	19bff626 	beq	r3,r6,8112ffc4 <__reset+0xfb10ffc4>
8112ffec:	20800003 	ldbu	r2,0(r4)
8112fff0:	10c03fcc 	andi	r3,r2,255
8112fff4:	18c0201c 	xori	r3,r3,128
8112fff8:	18ffe004 	addi	r3,r3,-128
8112fffc:	18000c26 	beq	r3,zero,81130030 <strcmp+0xac>
81130000:	29800007 	ldb	r6,0(r5)
81130004:	19800326 	beq	r3,r6,81130014 <strcmp+0x90>
81130008:	00001306 	br	81130058 <strcmp+0xd4>
8113000c:	29800007 	ldb	r6,0(r5)
81130010:	11800b1e 	bne	r2,r6,81130040 <strcmp+0xbc>
81130014:	21000044 	addi	r4,r4,1
81130018:	20c00003 	ldbu	r3,0(r4)
8113001c:	29400044 	addi	r5,r5,1
81130020:	18803fcc 	andi	r2,r3,255
81130024:	1080201c 	xori	r2,r2,128
81130028:	10bfe004 	addi	r2,r2,-128
8113002c:	103ff71e 	bne	r2,zero,8113000c <__reset+0xfb11000c>
81130030:	0007883a 	mov	r3,zero
81130034:	28800003 	ldbu	r2,0(r5)
81130038:	1885c83a 	sub	r2,r3,r2
8113003c:	f800283a 	ret
81130040:	28800003 	ldbu	r2,0(r5)
81130044:	18c03fcc 	andi	r3,r3,255
81130048:	1885c83a 	sub	r2,r3,r2
8113004c:	f800283a 	ret
81130050:	0005883a 	mov	r2,zero
81130054:	f800283a 	ret
81130058:	10c03fcc 	andi	r3,r2,255
8113005c:	003ff506 	br	81130034 <__reset+0xfb110034>

81130060 <sulp>:
81130060:	defffd04 	addi	sp,sp,-12
81130064:	de00012e 	bgeu	sp,et,8113006c <sulp+0xc>
81130068:	003b68fa 	trap	3
8113006c:	dc400115 	stw	r17,4(sp)
81130070:	3023883a 	mov	r17,r6
81130074:	dc000015 	stw	r16,0(sp)
81130078:	dfc00215 	stw	ra,8(sp)
8113007c:	2821883a 	mov	r16,r5
81130080:	112f36c0 	call	8112f36c <__ulp>
81130084:	88000c26 	beq	r17,zero,811300b8 <sulp+0x58>
81130088:	841ffc2c 	andhi	r16,r16,32752
8113008c:	8020d53a 	srli	r16,r16,20
81130090:	01c01ac4 	movi	r7,107
81130094:	3c21c83a 	sub	r16,r7,r16
81130098:	0400070e 	bge	zero,r16,811300b8 <sulp+0x58>
8113009c:	8020953a 	slli	r16,r16,20
811300a0:	01cffc34 	movhi	r7,16368
811300a4:	000d883a 	mov	r6,zero
811300a8:	81cf883a 	add	r7,r16,r7
811300ac:	1009883a 	mov	r4,r2
811300b0:	180b883a 	mov	r5,r3
811300b4:	1121c800 	call	81121c80 <__muldf3>
811300b8:	dfc00217 	ldw	ra,8(sp)
811300bc:	dc400117 	ldw	r17,4(sp)
811300c0:	dc000017 	ldw	r16,0(sp)
811300c4:	dec00304 	addi	sp,sp,12
811300c8:	f800283a 	ret

811300cc <_strtod_r>:
811300cc:	deffe204 	addi	sp,sp,-120
811300d0:	de00012e 	bgeu	sp,et,811300d8 <_strtod_r+0xc>
811300d4:	003b68fa 	trap	3
811300d8:	ddc01b15 	stw	r23,108(sp)
811300dc:	dd001815 	stw	r20,96(sp)
811300e0:	dc801615 	stw	r18,88(sp)
811300e4:	dc401515 	stw	r17,84(sp)
811300e8:	dc001415 	stw	r16,80(sp)
811300ec:	d9400615 	stw	r5,24(sp)
811300f0:	dfc01d15 	stw	ra,116(sp)
811300f4:	df001c15 	stw	fp,112(sp)
811300f8:	dd801a15 	stw	r22,104(sp)
811300fc:	dd401915 	stw	r21,100(sp)
81130100:	dcc01715 	stw	r19,92(sp)
81130104:	2021883a 	mov	r16,r4
81130108:	d8000515 	stw	zero,20(sp)
8113010c:	2809883a 	mov	r4,r5
81130110:	20800003 	ldbu	r2,0(r4)
81130114:	01e044f4 	movhi	r7,33043
81130118:	282f883a 	mov	r23,r5
8113011c:	10c03fcc 	andi	r3,r2,255
81130120:	01400b44 	movi	r5,45
81130124:	39c05204 	addi	r7,r7,328
81130128:	3029883a 	mov	r20,r6
8113012c:	0025883a 	mov	r18,zero
81130130:	0023883a 	mov	r17,zero
81130134:	28c0ba36 	bltu	r5,r3,81130420 <_strtod_r+0x354>
81130138:	180690ba 	slli	r3,r3,2
8113013c:	19c7883a 	add	r3,r3,r7
81130140:	18c00017 	ldw	r3,0(r3)
81130144:	1800683a 	jmp	r3
81130148:	81130208 	cmpgei	r4,r16,19464
8113014c:	81130420 	cmpeqi	r4,r16,19472
81130150:	81130420 	cmpeqi	r4,r16,19472
81130154:	81130420 	cmpeqi	r4,r16,19472
81130158:	81130420 	cmpeqi	r4,r16,19472
8113015c:	81130420 	cmpeqi	r4,r16,19472
81130160:	81130420 	cmpeqi	r4,r16,19472
81130164:	81130420 	cmpeqi	r4,r16,19472
81130168:	81130420 	cmpeqi	r4,r16,19472
8113016c:	8113040c 	andi	r4,r16,19472
81130170:	8113040c 	andi	r4,r16,19472
81130174:	8113040c 	andi	r4,r16,19472
81130178:	8113040c 	andi	r4,r16,19472
8113017c:	8113040c 	andi	r4,r16,19472
81130180:	81130420 	cmpeqi	r4,r16,19472
81130184:	81130420 	cmpeqi	r4,r16,19472
81130188:	81130420 	cmpeqi	r4,r16,19472
8113018c:	81130420 	cmpeqi	r4,r16,19472
81130190:	81130420 	cmpeqi	r4,r16,19472
81130194:	81130420 	cmpeqi	r4,r16,19472
81130198:	81130420 	cmpeqi	r4,r16,19472
8113019c:	81130420 	cmpeqi	r4,r16,19472
811301a0:	81130420 	cmpeqi	r4,r16,19472
811301a4:	81130420 	cmpeqi	r4,r16,19472
811301a8:	81130420 	cmpeqi	r4,r16,19472
811301ac:	81130420 	cmpeqi	r4,r16,19472
811301b0:	81130420 	cmpeqi	r4,r16,19472
811301b4:	81130420 	cmpeqi	r4,r16,19472
811301b8:	81130420 	cmpeqi	r4,r16,19472
811301bc:	81130420 	cmpeqi	r4,r16,19472
811301c0:	81130420 	cmpeqi	r4,r16,19472
811301c4:	81130420 	cmpeqi	r4,r16,19472
811301c8:	8113040c 	andi	r4,r16,19472
811301cc:	81130420 	cmpeqi	r4,r16,19472
811301d0:	81130420 	cmpeqi	r4,r16,19472
811301d4:	81130420 	cmpeqi	r4,r16,19472
811301d8:	81130420 	cmpeqi	r4,r16,19472
811301dc:	81130420 	cmpeqi	r4,r16,19472
811301e0:	81130420 	cmpeqi	r4,r16,19472
811301e4:	81130420 	cmpeqi	r4,r16,19472
811301e8:	81130420 	cmpeqi	r4,r16,19472
811301ec:	81130420 	cmpeqi	r4,r16,19472
811301f0:	81130420 	cmpeqi	r4,r16,19472
811301f4:	81130260 	cmpeqi	r4,r16,19465
811301f8:	81130420 	cmpeqi	r4,r16,19472
811301fc:	81130400 	call	88113040 <__reset+0x20f3040>
81130200:	00801244 	movi	r2,73
81130204:	88843526 	beq	r17,r2,811312dc <_strtod_r+0x1210>
81130208:	002b883a 	mov	r21,zero
8113020c:	002d883a 	mov	r22,zero
81130210:	a0000526 	beq	r20,zero,81130228 <_strtod_r+0x15c>
81130214:	d8000715 	stw	zero,28(sp)
81130218:	a5c00015 	stw	r23,0(r20)
8113021c:	d9000717 	ldw	r4,28(sp)
81130220:	20000126 	beq	r4,zero,81130228 <_strtod_r+0x15c>
81130224:	b5a0003c 	xorhi	r22,r22,32768
81130228:	a805883a 	mov	r2,r21
8113022c:	b007883a 	mov	r3,r22
81130230:	dfc01d17 	ldw	ra,116(sp)
81130234:	df001c17 	ldw	fp,112(sp)
81130238:	ddc01b17 	ldw	r23,108(sp)
8113023c:	dd801a17 	ldw	r22,104(sp)
81130240:	dd401917 	ldw	r21,100(sp)
81130244:	dd001817 	ldw	r20,96(sp)
81130248:	dcc01717 	ldw	r19,92(sp)
8113024c:	dc801617 	ldw	r18,88(sp)
81130250:	dc401517 	ldw	r17,84(sp)
81130254:	dc001417 	ldw	r16,80(sp)
81130258:	dec01e04 	addi	sp,sp,120
8113025c:	f800283a 	ret
81130260:	d8000715 	stw	zero,28(sp)
81130264:	24c00044 	addi	r19,r4,1
81130268:	dcc00615 	stw	r19,24(sp)
8113026c:	20800043 	ldbu	r2,1(r4)
81130270:	10c03fcc 	andi	r3,r2,255
81130274:	18c0201c 	xori	r3,r3,128
81130278:	18ffe004 	addi	r3,r3,-128
8113027c:	183fe226 	beq	r3,zero,81130208 <__reset+0xfb110208>
81130280:	11403fcc 	andi	r5,r2,255
81130284:	2940201c 	xori	r5,r5,128
81130288:	297fe004 	addi	r5,r5,-128
8113028c:	00c00c04 	movi	r3,48
81130290:	28c0e526 	beq	r5,r3,81130628 <_strtod_r+0x55c>
81130294:	dcc00815 	stw	r19,32(sp)
81130298:	0025883a 	mov	r18,zero
8113029c:	10fff404 	addi	r3,r2,-48
811302a0:	18c03fcc 	andi	r3,r3,255
811302a4:	01000244 	movi	r4,9
811302a8:	20c37536 	bltu	r4,r3,81131080 <_strtod_r+0xfb4>
811302ac:	dd400817 	ldw	r21,32(sp)
811302b0:	0027883a 	mov	r19,zero
811302b4:	0039883a 	mov	fp,zero
811302b8:	002d883a 	mov	r22,zero
811302bc:	01400204 	movi	r5,8
811302c0:	2d805a16 	blt	r5,r22,8113042c <_strtod_r+0x360>
811302c4:	e70002a4 	muli	fp,fp,10
811302c8:	10c03fcc 	andi	r3,r2,255
811302cc:	18c0201c 	xori	r3,r3,128
811302d0:	18ffe004 	addi	r3,r3,-128
811302d4:	e0f9883a 	add	fp,fp,r3
811302d8:	e73ff404 	addi	fp,fp,-48
811302dc:	ad400044 	addi	r21,r21,1
811302e0:	dd400615 	stw	r21,24(sp)
811302e4:	a8800003 	ldbu	r2,0(r21)
811302e8:	b5800044 	addi	r22,r22,1
811302ec:	10fff404 	addi	r3,r2,-48
811302f0:	18c03fcc 	andi	r3,r3,255
811302f4:	20fff22e 	bgeu	r4,r3,811302c0 <__reset+0xfb1102c0>
811302f8:	14403fcc 	andi	r17,r2,255
811302fc:	8c40201c 	xori	r17,r17,128
81130300:	8c7fe004 	addi	r17,r17,-128
81130304:	8009883a 	mov	r4,r16
81130308:	112e2ec0 	call	8112e2ec <_localeconv_r>
8113030c:	11400017 	ldw	r5,0(r2)
81130310:	8009883a 	mov	r4,r16
81130314:	d9401315 	stw	r5,76(sp)
81130318:	112e2ec0 	call	8112e2ec <_localeconv_r>
8113031c:	11000017 	ldw	r4,0(r2)
81130320:	1124dc80 	call	81124dc8 <strlen>
81130324:	d9401317 	ldw	r5,76(sp)
81130328:	100d883a 	mov	r6,r2
8113032c:	a809883a 	mov	r4,r21
81130330:	11359d40 	call	811359d4 <strncmp>
81130334:	1000ce26 	beq	r2,zero,81130670 <_strtod_r+0x5a4>
81130338:	b013883a 	mov	r9,r22
8113033c:	000b883a 	mov	r5,zero
81130340:	0015883a 	mov	r10,zero
81130344:	0017883a 	mov	r11,zero
81130348:	00801944 	movi	r2,101
8113034c:	88807826 	beq	r17,r2,81130530 <_strtod_r+0x464>
81130350:	00801144 	movi	r2,69
81130354:	88807626 	beq	r17,r2,81130530 <_strtod_r+0x464>
81130358:	002b883a 	mov	r21,zero
8113035c:	48003d1e 	bne	r9,zero,81130454 <_strtod_r+0x388>
81130360:	2800391e 	bne	r5,zero,81130448 <_strtod_r+0x37c>
81130364:	9000381e 	bne	r18,zero,81130448 <_strtod_r+0x37c>
81130368:	583fa71e 	bne	r11,zero,81130208 <__reset+0xfb110208>
8113036c:	00801384 	movi	r2,78
81130370:	88800526 	beq	r17,r2,81130388 <_strtod_r+0x2bc>
81130374:	147fa20e 	bge	r2,r17,81130200 <__reset+0xfb110200>
81130378:	00801a44 	movi	r2,105
8113037c:	8883d726 	beq	r17,r2,811312dc <_strtod_r+0x1210>
81130380:	00801b84 	movi	r2,110
81130384:	88bfa01e 	bne	r17,r2,81130208 <__reset+0xfb110208>
81130388:	01604574 	movhi	r5,33045
8113038c:	d9000617 	ldw	r4,24(sp)
81130390:	294a0604 	addi	r5,r5,10264
81130394:	01c00644 	movi	r7,25
81130398:	00000b06 	br	811303c8 <_strtod_r+0x2fc>
8113039c:	21000044 	addi	r4,r4,1
811303a0:	20800003 	ldbu	r2,0(r4)
811303a4:	10ffefc4 	addi	r3,r2,-65
811303a8:	10803fcc 	andi	r2,r2,255
811303ac:	1080201c 	xori	r2,r2,128
811303b0:	18c03fcc 	andi	r3,r3,255
811303b4:	10bfe004 	addi	r2,r2,-128
811303b8:	38c00136 	bltu	r7,r3,811303c0 <_strtod_r+0x2f4>
811303bc:	10800804 	addi	r2,r2,32
811303c0:	29400044 	addi	r5,r5,1
811303c4:	11bf901e 	bne	r2,r6,81130208 <__reset+0xfb110208>
811303c8:	29800007 	ldb	r6,0(r5)
811303cc:	303ff31e 	bne	r6,zero,8113039c <__reset+0xfb11039c>
811303d0:	20800044 	addi	r2,r4,1
811303d4:	d8800615 	stw	r2,24(sp)
811303d8:	20c00047 	ldb	r3,1(r4)
811303dc:	00800a04 	movi	r2,40
811303e0:	18849d26 	beq	r3,r2,81131658 <_strtod_r+0x158c>
811303e4:	047ffe34 	movhi	r17,65528
811303e8:	0025883a 	mov	r18,zero
811303ec:	902b883a 	mov	r21,r18
811303f0:	882d883a 	mov	r22,r17
811303f4:	a03f8926 	beq	r20,zero,8113021c <__reset+0xfb11021c>
811303f8:	ddc00617 	ldw	r23,24(sp)
811303fc:	003f8606 	br	81130218 <__reset+0xfb110218>
81130400:	00800044 	movi	r2,1
81130404:	d8800715 	stw	r2,28(sp)
81130408:	003f9606 	br	81130264 <__reset+0xfb110264>
8113040c:	21000044 	addi	r4,r4,1
81130410:	d9000615 	stw	r4,24(sp)
81130414:	20800003 	ldbu	r2,0(r4)
81130418:	10c03fcc 	andi	r3,r2,255
8113041c:	28ff462e 	bgeu	r5,r3,81130138 <__reset+0xfb110138>
81130420:	2027883a 	mov	r19,r4
81130424:	d8000715 	stw	zero,28(sp)
81130428:	003f9506 	br	81130280 <__reset+0xfb110280>
8113042c:	9cc002a4 	muli	r19,r19,10
81130430:	10803fcc 	andi	r2,r2,255
81130434:	1080201c 	xori	r2,r2,128
81130438:	10bfe004 	addi	r2,r2,-128
8113043c:	9885883a 	add	r2,r19,r2
81130440:	14fff404 	addi	r19,r2,-48
81130444:	003fa506 	br	811302dc <__reset+0xfb1102dc>
81130448:	002b883a 	mov	r21,zero
8113044c:	002d883a 	mov	r22,zero
81130450:	003fe806 	br	811303f4 <__reset+0xfb1103f4>
81130454:	aaabc83a 	sub	r21,r21,r10
81130458:	b000011e 	bne	r22,zero,81130460 <_strtod_r+0x394>
8113045c:	482d883a 	mov	r22,r9
81130460:	00800404 	movi	r2,16
81130464:	482f883a 	mov	r23,r9
81130468:	1240010e 	bge	r2,r9,81130470 <_strtod_r+0x3a4>
8113046c:	102f883a 	mov	r23,r2
81130470:	e009883a 	mov	r4,fp
81130474:	da401315 	stw	r9,76(sp)
81130478:	1137e340 	call	81137e34 <__floatunsidf>
8113047c:	1025883a 	mov	r18,r2
81130480:	00800244 	movi	r2,9
81130484:	1823883a 	mov	r17,r3
81130488:	da401317 	ldw	r9,76(sp)
8113048c:	15c0160e 	bge	r2,r23,811304e8 <_strtod_r+0x41c>
81130490:	b8bffdc4 	addi	r2,r23,-9
81130494:	100490fa 	slli	r2,r2,3
81130498:	180b883a 	mov	r5,r3
8113049c:	00e04574 	movhi	r3,33045
811304a0:	18c9d104 	addi	r3,r3,10052
811304a4:	1885883a 	add	r2,r3,r2
811304a8:	11800017 	ldw	r6,0(r2)
811304ac:	11c00117 	ldw	r7,4(r2)
811304b0:	9009883a 	mov	r4,r18
811304b4:	1121c800 	call	81121c80 <__muldf3>
811304b8:	9809883a 	mov	r4,r19
811304bc:	1025883a 	mov	r18,r2
811304c0:	1823883a 	mov	r17,r3
811304c4:	1137e340 	call	81137e34 <__floatunsidf>
811304c8:	9009883a 	mov	r4,r18
811304cc:	880b883a 	mov	r5,r17
811304d0:	100d883a 	mov	r6,r2
811304d4:	180f883a 	mov	r7,r3
811304d8:	1136b140 	call	81136b14 <__adddf3>
811304dc:	da401317 	ldw	r9,76(sp)
811304e0:	1025883a 	mov	r18,r2
811304e4:	1823883a 	mov	r17,r3
811304e8:	008003c4 	movi	r2,15
811304ec:	12407b16 	blt	r2,r9,811306dc <_strtod_r+0x610>
811304f0:	a83fbe26 	beq	r21,zero,811303ec <__reset+0xfb1103ec>
811304f4:	0543670e 	bge	zero,r21,81131294 <_strtod_r+0x11c8>
811304f8:	00c00584 	movi	r3,22
811304fc:	1d42e816 	blt	r3,r21,811310a0 <_strtod_r+0xfd4>
81130500:	a82a90fa 	slli	r21,r21,3
81130504:	00a04574 	movhi	r2,33045
81130508:	1089d104 	addi	r2,r2,10052
8113050c:	1545883a 	add	r2,r2,r21
81130510:	11000017 	ldw	r4,0(r2)
81130514:	11400117 	ldw	r5,4(r2)
81130518:	900d883a 	mov	r6,r18
8113051c:	880f883a 	mov	r7,r17
81130520:	1121c800 	call	81121c80 <__muldf3>
81130524:	102b883a 	mov	r21,r2
81130528:	182d883a 	mov	r22,r3
8113052c:	003fb106 	br	811303f4 <__reset+0xfb1103f4>
81130530:	4801b526 	beq	r9,zero,81130c08 <_strtod_r+0xb3c>
81130534:	ddc00617 	ldw	r23,24(sp)
81130538:	00c00ac4 	movi	r3,43
8113053c:	b8800044 	addi	r2,r23,1
81130540:	d8800615 	stw	r2,24(sp)
81130544:	b8800047 	ldb	r2,1(r23)
81130548:	10c1e926 	beq	r2,r3,81130cf0 <_strtod_r+0xc24>
8113054c:	00c00b44 	movi	r3,45
81130550:	10c1ec26 	beq	r2,r3,81130d04 <_strtod_r+0xc38>
81130554:	1023883a 	mov	r17,r2
81130558:	0019883a 	mov	r12,zero
8113055c:	88bff404 	addi	r2,r17,-48
81130560:	00c00244 	movi	r3,9
81130564:	1881b736 	bltu	r3,r2,81130c44 <_strtod_r+0xb78>
81130568:	00800c04 	movi	r2,48
8113056c:	8880071e 	bne	r17,r2,8113058c <_strtod_r+0x4c0>
81130570:	d8800617 	ldw	r2,24(sp)
81130574:	8807883a 	mov	r3,r17
81130578:	10800044 	addi	r2,r2,1
8113057c:	d8800615 	stw	r2,24(sp)
81130580:	14400007 	ldb	r17,0(r2)
81130584:	10800044 	addi	r2,r2,1
81130588:	88fffc26 	beq	r17,r3,8113057c <__reset+0xfb11057c>
8113058c:	88bff3c4 	addi	r2,r17,-49
81130590:	00c00204 	movi	r3,8
81130594:	18bf7036 	bltu	r3,r2,81130358 <__reset+0xfb110358>
81130598:	db800617 	ldw	r14,24(sp)
8113059c:	88bff404 	addi	r2,r17,-48
811305a0:	03400244 	movi	r13,9
811305a4:	71c00044 	addi	r7,r14,1
811305a8:	d9c00615 	stw	r7,24(sp)
811305ac:	74400043 	ldbu	r17,1(r14)
811305b0:	88fff404 	addi	r3,r17,-48
811305b4:	8c403fcc 	andi	r17,r17,255
811305b8:	8c40201c 	xori	r17,r17,128
811305bc:	18c03fcc 	andi	r3,r3,255
811305c0:	8c7fe004 	addi	r17,r17,-128
811305c4:	68c00e36 	bltu	r13,r3,81130600 <_strtod_r+0x534>
811305c8:	71000084 	addi	r4,r14,2
811305cc:	d9000615 	stw	r4,24(sp)
811305d0:	108002a4 	muli	r2,r2,10
811305d4:	21800003 	ldbu	r6,0(r4)
811305d8:	200f883a 	mov	r7,r4
811305dc:	1463883a 	add	r17,r2,r17
811305e0:	30fff404 	addi	r3,r6,-48
811305e4:	88bff404 	addi	r2,r17,-48
811305e8:	34403fcc 	andi	r17,r6,255
811305ec:	8c40201c 	xori	r17,r17,128
811305f0:	18c03fcc 	andi	r3,r3,255
811305f4:	8c7fe004 	addi	r17,r17,-128
811305f8:	21000044 	addi	r4,r4,1
811305fc:	68fff32e 	bgeu	r13,r3,811305cc <__reset+0xfb1105cc>
81130600:	3b8fc83a 	sub	r7,r7,r14
81130604:	00c00204 	movi	r3,8
81130608:	19c29716 	blt	r3,r7,81131068 <_strtod_r+0xf9c>
8113060c:	102b883a 	mov	r21,r2
81130610:	009387c4 	movi	r2,19999
81130614:	1540010e 	bge	r2,r21,8113061c <_strtod_r+0x550>
81130618:	102b883a 	mov	r21,r2
8113061c:	603f4f26 	beq	r12,zero,8113035c <__reset+0xfb11035c>
81130620:	056bc83a 	sub	r21,zero,r21
81130624:	003f4d06 	br	8113035c <__reset+0xfb11035c>
81130628:	98800047 	ldb	r2,1(r19)
8113062c:	00c01604 	movi	r3,88
81130630:	10c1de26 	beq	r2,r3,81130dac <_strtod_r+0xce0>
81130634:	00c01e04 	movi	r3,120
81130638:	10c1dc26 	beq	r2,r3,81130dac <_strtod_r+0xce0>
8113063c:	98c00044 	addi	r3,r19,1
81130640:	1827883a 	mov	r19,r3
81130644:	d8c00615 	stw	r3,24(sp)
81130648:	18c00044 	addi	r3,r3,1
8113064c:	18bfffc3 	ldbu	r2,-1(r3)
81130650:	11003fcc 	andi	r4,r2,255
81130654:	2100201c 	xori	r4,r4,128
81130658:	213fe004 	addi	r4,r4,-128
8113065c:	217ff826 	beq	r4,r5,81130640 <__reset+0xfb110640>
81130660:	203f7926 	beq	r4,zero,81130448 <__reset+0xfb110448>
81130664:	dcc00815 	stw	r19,32(sp)
81130668:	04800044 	movi	r18,1
8113066c:	003f0b06 	br	8113029c <__reset+0xfb11029c>
81130670:	8009883a 	mov	r4,r16
81130674:	112e2ec0 	call	8112e2ec <_localeconv_r>
81130678:	11000017 	ldw	r4,0(r2)
8113067c:	1124dc80 	call	81124dc8 <strlen>
81130680:	d8c00617 	ldw	r3,24(sp)
81130684:	1885883a 	add	r2,r3,r2
81130688:	d8800615 	stw	r2,24(sp)
8113068c:	14400007 	ldb	r17,0(r2)
81130690:	b001881e 	bne	r22,zero,81130cb4 <_strtod_r+0xbe8>
81130694:	00c00c04 	movi	r3,48
81130698:	88c3391e 	bne	r17,r3,81131380 <_strtod_r+0x12b4>
8113069c:	10c00044 	addi	r3,r2,1
811306a0:	8809883a 	mov	r4,r17
811306a4:	d8c00615 	stw	r3,24(sp)
811306a8:	1c400007 	ldb	r17,0(r3)
811306ac:	188bc83a 	sub	r5,r3,r2
811306b0:	18c00044 	addi	r3,r3,1
811306b4:	893ffb26 	beq	r17,r4,811306a4 <__reset+0xfb1106a4>
811306b8:	88bff3c4 	addi	r2,r17,-49
811306bc:	00c00204 	movi	r3,8
811306c0:	1882e72e 	bgeu	r3,r2,81131260 <_strtod_r+0x1194>
811306c4:	00801944 	movi	r2,101
811306c8:	88814d26 	beq	r17,r2,81130c00 <_strtod_r+0xb34>
811306cc:	0013883a 	mov	r9,zero
811306d0:	0015883a 	mov	r10,zero
811306d4:	02c00044 	movi	r11,1
811306d8:	003f1d06 	br	81130350 <__reset+0xfb110350>
811306dc:	4defc83a 	sub	r23,r9,r23
811306e0:	bd6f883a 	add	r23,r23,r21
811306e4:	05c21e0e 	bge	zero,r23,81130f60 <_strtod_r+0xe94>
811306e8:	b88003cc 	andi	r2,r23,15
811306ec:	10000d26 	beq	r2,zero,81130724 <_strtod_r+0x658>
811306f0:	100490fa 	slli	r2,r2,3
811306f4:	00e04574 	movhi	r3,33045
811306f8:	18c9d104 	addi	r3,r3,10052
811306fc:	1885883a 	add	r2,r3,r2
81130700:	11000017 	ldw	r4,0(r2)
81130704:	11400117 	ldw	r5,4(r2)
81130708:	900d883a 	mov	r6,r18
8113070c:	880f883a 	mov	r7,r17
81130710:	da401315 	stw	r9,76(sp)
81130714:	1121c800 	call	81121c80 <__muldf3>
81130718:	da401317 	ldw	r9,76(sp)
8113071c:	1025883a 	mov	r18,r2
81130720:	1823883a 	mov	r17,r3
81130724:	023ffc04 	movi	r8,-16
81130728:	ba10703a 	and	r8,r23,r8
8113072c:	40003c26 	beq	r8,zero,81130820 <_strtod_r+0x754>
81130730:	00804d04 	movi	r2,308
81130734:	1201cd16 	blt	r2,r8,81130e6c <_strtod_r+0xda0>
81130738:	4011d13a 	srai	r8,r8,4
8113073c:	03000044 	movi	r12,1
81130740:	62037c0e 	bge	r12,r8,81131534 <_strtod_r+0x1468>
81130744:	01204574 	movhi	r4,33045
81130748:	2109c704 	addi	r4,r4,10012
8113074c:	2015883a 	mov	r10,r4
81130750:	0027883a 	mov	r19,zero
81130754:	d9000915 	stw	r4,36(sp)
81130758:	9005883a 	mov	r2,r18
8113075c:	8807883a 	mov	r3,r17
81130760:	dc000c15 	stw	r16,48(sp)
81130764:	dc800e15 	stw	r18,56(sp)
81130768:	9821883a 	mov	r16,r19
8113076c:	0009883a 	mov	r4,zero
81130770:	8827883a 	mov	r19,r17
81130774:	602f883a 	mov	r23,r12
81130778:	da400a15 	stw	r9,40(sp)
8113077c:	5025883a 	mov	r18,r10
81130780:	4023883a 	mov	r17,r8
81130784:	8980004c 	andi	r6,r17,1
81130788:	30000626 	beq	r6,zero,811307a4 <_strtod_r+0x6d8>
8113078c:	91800017 	ldw	r6,0(r18)
81130790:	91c00117 	ldw	r7,4(r18)
81130794:	1009883a 	mov	r4,r2
81130798:	180b883a 	mov	r5,r3
8113079c:	1121c800 	call	81121c80 <__muldf3>
811307a0:	01000044 	movi	r4,1
811307a4:	8823d07a 	srai	r17,r17,1
811307a8:	84000044 	addi	r16,r16,1
811307ac:	94800204 	addi	r18,r18,8
811307b0:	8dfff41e 	bne	r17,r23,81130784 <__reset+0xfb110784>
811307b4:	21003fcc 	andi	r4,r4,255
811307b8:	9823883a 	mov	r17,r19
811307bc:	da400a17 	ldw	r9,40(sp)
811307c0:	8027883a 	mov	r19,r16
811307c4:	dc800e17 	ldw	r18,56(sp)
811307c8:	dc000c17 	ldw	r16,48(sp)
811307cc:	2003b11e 	bne	r4,zero,81131694 <_strtod_r+0x15c8>
811307d0:	981690fa 	slli	r11,r19,3
811307d4:	d8800917 	ldw	r2,36(sp)
811307d8:	01ff2c34 	movhi	r7,64688
811307dc:	900d883a 	mov	r6,r18
811307e0:	12ef883a 	add	r23,r2,r11
811307e4:	b9000017 	ldw	r4,0(r23)
811307e8:	b9400117 	ldw	r5,4(r23)
811307ec:	89cf883a 	add	r7,r17,r7
811307f0:	da401315 	stw	r9,76(sp)
811307f4:	1121c800 	call	81121c80 <__muldf3>
811307f8:	1025883a 	mov	r18,r2
811307fc:	011f2834 	movhi	r4,31904
81130800:	189ffc2c 	andhi	r2,r3,32752
81130804:	da401317 	ldw	r9,76(sp)
81130808:	20819836 	bltu	r4,r2,81130e6c <_strtod_r+0xda0>
8113080c:	011f2434 	movhi	r4,31888
81130810:	2083382e 	bgeu	r4,r2,811314f4 <_strtod_r+0x1428>
81130814:	045ffc34 	movhi	r17,32752
81130818:	8c7fffc4 	addi	r17,r17,-1
8113081c:	04bfffc4 	movi	r18,-1
81130820:	d8000915 	stw	zero,36(sp)
81130824:	d9400817 	ldw	r5,32(sp)
81130828:	df000015 	stw	fp,0(sp)
8113082c:	480f883a 	mov	r7,r9
81130830:	b00d883a 	mov	r6,r22
81130834:	8009883a 	mov	r4,r16
81130838:	112ea080 	call	8112ea08 <__s2b>
8113083c:	d8800815 	stw	r2,32(sp)
81130840:	10018a26 	beq	r2,zero,81130e6c <_strtod_r+0xda0>
81130844:	a807d7fa 	srai	r3,r21,31
81130848:	0545c83a 	sub	r2,zero,r21
8113084c:	dd400a15 	stw	r21,40(sp)
81130850:	1886703a 	and	r3,r3,r2
81130854:	d8c00c15 	stw	r3,48(sp)
81130858:	a8013516 	blt	r21,zero,81130d30 <_strtod_r+0xc64>
8113085c:	d9400817 	ldw	r5,32(sp)
81130860:	0011883a 	mov	r8,zero
81130864:	0027883a 	mov	r19,zero
81130868:	29400304 	addi	r5,r5,12
8113086c:	d9400f15 	stw	r5,60(sp)
81130870:	402b883a 	mov	r21,r8
81130874:	dd001215 	stw	r20,72(sp)
81130878:	d8800817 	ldw	r2,32(sp)
8113087c:	8009883a 	mov	r4,r16
81130880:	11400117 	ldw	r5,4(r2)
81130884:	112e8080 	call	8112e808 <_Balloc>
81130888:	1029883a 	mov	r20,r2
8113088c:	10012d26 	beq	r2,zero,81130d44 <_strtod_r+0xc78>
81130890:	d8c00817 	ldw	r3,32(sp)
81130894:	d9400f17 	ldw	r5,60(sp)
81130898:	11000304 	addi	r4,r2,12
8113089c:	19800417 	ldw	r6,16(r3)
811308a0:	31800084 	addi	r6,r6,2
811308a4:	318d883a 	add	r6,r6,r6
811308a8:	318d883a 	add	r6,r6,r6
811308ac:	11243500 	call	81124350 <memcpy>
811308b0:	d9000204 	addi	r4,sp,8
811308b4:	d9000015 	stw	r4,0(sp)
811308b8:	d9c00404 	addi	r7,sp,16
811308bc:	900b883a 	mov	r5,r18
811308c0:	880d883a 	mov	r6,r17
811308c4:	8009883a 	mov	r4,r16
811308c8:	112f4e40 	call	8112f4e4 <__d2b>
811308cc:	d8800515 	stw	r2,20(sp)
811308d0:	dc801115 	stw	r18,68(sp)
811308d4:	dc401015 	stw	r17,64(sp)
811308d8:	10027c26 	beq	r2,zero,811312cc <_strtod_r+0x1200>
811308dc:	01400044 	movi	r5,1
811308e0:	8009883a 	mov	r4,r16
811308e4:	112ec2c0 	call	8112ec2c <__i2b>
811308e8:	1027883a 	mov	r19,r2
811308ec:	10011526 	beq	r2,zero,81130d44 <_strtod_r+0xc78>
811308f0:	d8800417 	ldw	r2,16(sp)
811308f4:	1000c816 	blt	r2,zero,81130c18 <_strtod_r+0xb4c>
811308f8:	d9400c17 	ldw	r5,48(sp)
811308fc:	d9000a17 	ldw	r4,40(sp)
81130900:	28ad883a 	add	r22,r5,r2
81130904:	d9400917 	ldw	r5,36(sp)
81130908:	df000217 	ldw	fp,8(sp)
8113090c:	05ff0084 	movi	r23,-1022
81130910:	1147c83a 	sub	r3,r2,r5
81130914:	1f07883a 	add	r3,r3,fp
81130918:	00800d84 	movi	r2,54
8113091c:	18ffffc4 	addi	r3,r3,-1
81130920:	1739c83a 	sub	fp,r2,fp
81130924:	1dc0a50e 	bge	r3,r23,81130bbc <_strtod_r+0xaf0>
81130928:	b8efc83a 	sub	r23,r23,r3
8113092c:	008007c4 	movi	r2,31
81130930:	e5f9c83a 	sub	fp,fp,r23
81130934:	15c0bc16 	blt	r2,r23,81130c28 <_strtod_r+0xb5c>
81130938:	00800044 	movi	r2,1
8113093c:	15c4983a 	sll	r2,r2,r23
81130940:	d8000b15 	stw	zero,44(sp)
81130944:	d8800d15 	stw	r2,52(sp)
81130948:	2707883a 	add	r3,r4,fp
8113094c:	d9000917 	ldw	r4,36(sp)
81130950:	b739883a 	add	fp,r22,fp
81130954:	20ef883a 	add	r23,r4,r3
81130958:	b009883a 	mov	r4,r22
8113095c:	e580010e 	bge	fp,r22,81130964 <_strtod_r+0x898>
81130960:	e009883a 	mov	r4,fp
81130964:	b805883a 	mov	r2,r23
81130968:	25c0010e 	bge	r4,r23,81130970 <_strtod_r+0x8a4>
8113096c:	2005883a 	mov	r2,r4
81130970:	0080030e 	bge	zero,r2,81130980 <_strtod_r+0x8b4>
81130974:	e0b9c83a 	sub	fp,fp,r2
81130978:	b8afc83a 	sub	r23,r23,r2
8113097c:	b0adc83a 	sub	r22,r22,r2
81130980:	d9400c17 	ldw	r5,48(sp)
81130984:	28001126 	beq	r5,zero,811309cc <_strtod_r+0x900>
81130988:	280d883a 	mov	r6,r5
8113098c:	8009883a 	mov	r4,r16
81130990:	980b883a 	mov	r5,r19
81130994:	112ee700 	call	8112ee70 <__pow5mult>
81130998:	1027883a 	mov	r19,r2
8113099c:	1000e926 	beq	r2,zero,81130d44 <_strtod_r+0xc78>
811309a0:	d9800517 	ldw	r6,20(sp)
811309a4:	100b883a 	mov	r5,r2
811309a8:	8009883a 	mov	r4,r16
811309ac:	112ec700 	call	8112ec70 <__multiply>
811309b0:	1000e426 	beq	r2,zero,81130d44 <_strtod_r+0xc78>
811309b4:	d9400517 	ldw	r5,20(sp)
811309b8:	8009883a 	mov	r4,r16
811309bc:	d8801315 	stw	r2,76(sp)
811309c0:	112e8b80 	call	8112e8b8 <_Bfree>
811309c4:	d8801317 	ldw	r2,76(sp)
811309c8:	d8800515 	stw	r2,20(sp)
811309cc:	0700060e 	bge	zero,fp,811309e8 <_strtod_r+0x91c>
811309d0:	d9400517 	ldw	r5,20(sp)
811309d4:	e00d883a 	mov	r6,fp
811309d8:	8009883a 	mov	r4,r16
811309dc:	112efb80 	call	8112efb8 <__lshift>
811309e0:	d8800515 	stw	r2,20(sp)
811309e4:	10023926 	beq	r2,zero,811312cc <_strtod_r+0x1200>
811309e8:	d8800a17 	ldw	r2,40(sp)
811309ec:	10000626 	beq	r2,zero,81130a08 <_strtod_r+0x93c>
811309f0:	d9800a17 	ldw	r6,40(sp)
811309f4:	a00b883a 	mov	r5,r20
811309f8:	8009883a 	mov	r4,r16
811309fc:	112ee700 	call	8112ee70 <__pow5mult>
81130a00:	1029883a 	mov	r20,r2
81130a04:	1000cf26 	beq	r2,zero,81130d44 <_strtod_r+0xc78>
81130a08:	05c0060e 	bge	zero,r23,81130a24 <_strtod_r+0x958>
81130a0c:	a00b883a 	mov	r5,r20
81130a10:	b80d883a 	mov	r6,r23
81130a14:	8009883a 	mov	r4,r16
81130a18:	112efb80 	call	8112efb8 <__lshift>
81130a1c:	1029883a 	mov	r20,r2
81130a20:	1000c826 	beq	r2,zero,81130d44 <_strtod_r+0xc78>
81130a24:	0580060e 	bge	zero,r22,81130a40 <_strtod_r+0x974>
81130a28:	980b883a 	mov	r5,r19
81130a2c:	b00d883a 	mov	r6,r22
81130a30:	8009883a 	mov	r4,r16
81130a34:	112efb80 	call	8112efb8 <__lshift>
81130a38:	1027883a 	mov	r19,r2
81130a3c:	1000c126 	beq	r2,zero,81130d44 <_strtod_r+0xc78>
81130a40:	d9400517 	ldw	r5,20(sp)
81130a44:	a00d883a 	mov	r6,r20
81130a48:	8009883a 	mov	r4,r16
81130a4c:	112f1680 	call	8112f168 <__mdiff>
81130a50:	102b883a 	mov	r21,r2
81130a54:	1000bb26 	beq	r2,zero,81130d44 <_strtod_r+0xc78>
81130a58:	10c00317 	ldw	r3,12(r2)
81130a5c:	980b883a 	mov	r5,r19
81130a60:	10000315 	stw	zero,12(r2)
81130a64:	1009883a 	mov	r4,r2
81130a68:	d8c00e15 	stw	r3,56(sp)
81130a6c:	112f1080 	call	8112f108 <__mcmp>
81130a70:	10027616 	blt	r2,zero,8113144c <_strtod_r+0x1380>
81130a74:	10024426 	beq	r2,zero,81131388 <_strtod_r+0x12bc>
81130a78:	980b883a 	mov	r5,r19
81130a7c:	a809883a 	mov	r4,r21
81130a80:	112f6380 	call	8112f638 <__ratio>
81130a84:	000d883a 	mov	r6,zero
81130a88:	01d00034 	movhi	r7,16384
81130a8c:	1009883a 	mov	r4,r2
81130a90:	180b883a 	mov	r5,r3
81130a94:	102f883a 	mov	r23,r2
81130a98:	182d883a 	mov	r22,r3
81130a9c:	1137d400 	call	81137d40 <__ledf2>
81130aa0:	00804a16 	blt	zero,r2,81130bcc <_strtod_r+0xb00>
81130aa4:	d9400e17 	ldw	r5,56(sp)
81130aa8:	28006b26 	beq	r5,zero,81130c58 <_strtod_r+0xb8c>
81130aac:	058ffc34 	movhi	r22,16368
81130ab0:	d8000b15 	stw	zero,44(sp)
81130ab4:	d8000d15 	stw	zero,52(sp)
81130ab8:	b02f883a 	mov	r23,r22
81130abc:	8f1ffc2c 	andhi	fp,r17,32752
81130ac0:	009ff834 	movhi	r2,32736
81130ac4:	e080cd26 	beq	fp,r2,81130dfc <_strtod_r+0xd30>
81130ac8:	d9400917 	ldw	r5,36(sp)
81130acc:	28001a26 	beq	r5,zero,81130b38 <_strtod_r+0xa6c>
81130ad0:	0081a834 	movhi	r2,1696
81130ad4:	17001836 	bltu	r2,fp,81130b38 <_strtod_r+0xa6c>
81130ad8:	d9000d17 	ldw	r4,52(sp)
81130adc:	01d07834 	movhi	r7,16864
81130ae0:	39ffffc4 	addi	r7,r7,-1
81130ae4:	01bff034 	movhi	r6,65472
81130ae8:	b80b883a 	mov	r5,r23
81130aec:	1137d400 	call	81137d40 <__ledf2>
81130af0:	00800e16 	blt	zero,r2,81130b2c <_strtod_r+0xa60>
81130af4:	d9000d17 	ldw	r4,52(sp)
81130af8:	b80b883a 	mov	r5,r23
81130afc:	11210b80 	call	811210b8 <__fixunsdfsi>
81130b00:	10018126 	beq	r2,zero,81131108 <_strtod_r+0x103c>
81130b04:	1009883a 	mov	r4,r2
81130b08:	1137e340 	call	81137e34 <__floatunsidf>
81130b0c:	d8800d15 	stw	r2,52(sp)
81130b10:	182f883a 	mov	r23,r3
81130b14:	d8800e17 	ldw	r2,56(sp)
81130b18:	1001791e 	bne	r2,zero,81131100 <_strtod_r+0x1034>
81130b1c:	ba20003c 	xorhi	r8,r23,32768
81130b20:	d8c00d17 	ldw	r3,52(sp)
81130b24:	402d883a 	mov	r22,r8
81130b28:	d8c00b15 	stw	r3,44(sp)
81130b2c:	0081ac34 	movhi	r2,1712
81130b30:	b091883a 	add	r8,r22,r2
81130b34:	472dc83a 	sub	r22,r8,fp
81130b38:	9009883a 	mov	r4,r18
81130b3c:	880b883a 	mov	r5,r17
81130b40:	112f36c0 	call	8112f36c <__ulp>
81130b44:	d9000b17 	ldw	r4,44(sp)
81130b48:	b00b883a 	mov	r5,r22
81130b4c:	100d883a 	mov	r6,r2
81130b50:	180f883a 	mov	r7,r3
81130b54:	1121c800 	call	81121c80 <__muldf3>
81130b58:	900d883a 	mov	r6,r18
81130b5c:	880f883a 	mov	r7,r17
81130b60:	1009883a 	mov	r4,r2
81130b64:	180b883a 	mov	r5,r3
81130b68:	1136b140 	call	81136b14 <__adddf3>
81130b6c:	1025883a 	mov	r18,r2
81130b70:	1823883a 	mov	r17,r3
81130b74:	182d883a 	mov	r22,r3
81130b78:	d9000917 	ldw	r4,36(sp)
81130b7c:	2000021e 	bne	r4,zero,81130b88 <_strtod_r+0xabc>
81130b80:	b09ffc2c 	andhi	r2,r22,32752
81130b84:	e080be26 	beq	fp,r2,81130e80 <_strtod_r+0xdb4>
81130b88:	d9400517 	ldw	r5,20(sp)
81130b8c:	8009883a 	mov	r4,r16
81130b90:	112e8b80 	call	8112e8b8 <_Bfree>
81130b94:	a00b883a 	mov	r5,r20
81130b98:	8009883a 	mov	r4,r16
81130b9c:	112e8b80 	call	8112e8b8 <_Bfree>
81130ba0:	980b883a 	mov	r5,r19
81130ba4:	8009883a 	mov	r4,r16
81130ba8:	112e8b80 	call	8112e8b8 <_Bfree>
81130bac:	a80b883a 	mov	r5,r21
81130bb0:	8009883a 	mov	r4,r16
81130bb4:	112e8b80 	call	8112e8b8 <_Bfree>
81130bb8:	003f2f06 	br	81130878 <__reset+0xfb110878>
81130bbc:	00c00044 	movi	r3,1
81130bc0:	d8000b15 	stw	zero,44(sp)
81130bc4:	d8c00d15 	stw	r3,52(sp)
81130bc8:	003f5f06 	br	81130948 <__reset+0xfb110948>
81130bcc:	b809883a 	mov	r4,r23
81130bd0:	000d883a 	mov	r6,zero
81130bd4:	01cff834 	movhi	r7,16352
81130bd8:	b00b883a 	mov	r5,r22
81130bdc:	1121c800 	call	81121c80 <__muldf3>
81130be0:	d9000e17 	ldw	r4,56(sp)
81130be4:	d8800d15 	stw	r2,52(sp)
81130be8:	182f883a 	mov	r23,r3
81130bec:	2000181e 	bne	r4,zero,81130c50 <_strtod_r+0xb84>
81130bf0:	1a20003c 	xorhi	r8,r3,32768
81130bf4:	d8800b15 	stw	r2,44(sp)
81130bf8:	402d883a 	mov	r22,r8
81130bfc:	003faf06 	br	81130abc <__reset+0xfb110abc>
81130c00:	0015883a 	mov	r10,zero
81130c04:	02c00044 	movi	r11,1
81130c08:	2800011e 	bne	r5,zero,81130c10 <_strtod_r+0xb44>
81130c0c:	903d7e26 	beq	r18,zero,81130208 <__reset+0xfb110208>
81130c10:	0013883a 	mov	r9,zero
81130c14:	003e4706 	br	81130534 <__reset+0xfb110534>
81130c18:	d8c00a17 	ldw	r3,40(sp)
81130c1c:	dd800c17 	ldw	r22,48(sp)
81130c20:	1889c83a 	sub	r4,r3,r2
81130c24:	003f3706 	br	81130904 <__reset+0xfb110904>
81130c28:	00bef884 	movi	r2,-1054
81130c2c:	05c00044 	movi	r23,1
81130c30:	10c5c83a 	sub	r2,r2,r3
81130c34:	b884983a 	sll	r2,r23,r2
81130c38:	ddc00d15 	stw	r23,52(sp)
81130c3c:	d8800b15 	stw	r2,44(sp)
81130c40:	003f4106 	br	81130948 <__reset+0xfb110948>
81130c44:	ddc00615 	stw	r23,24(sp)
81130c48:	002b883a 	mov	r21,zero
81130c4c:	003dc306 	br	8113035c <__reset+0xfb11035c>
81130c50:	1811883a 	mov	r8,r3
81130c54:	003fe706 	br	81130bf4 <__reset+0xfb110bf4>
81130c58:	90002e1e 	bne	r18,zero,81130d14 <_strtod_r+0xc48>
81130c5c:	00c00434 	movhi	r3,16
81130c60:	18ffffc4 	addi	r3,r3,-1
81130c64:	88c4703a 	and	r2,r17,r3
81130c68:	10002c1e 	bne	r2,zero,81130d1c <_strtod_r+0xc50>
81130c6c:	000d883a 	mov	r6,zero
81130c70:	01cffc34 	movhi	r7,16368
81130c74:	b809883a 	mov	r4,r23
81130c78:	b00b883a 	mov	r5,r22
81130c7c:	1137d400 	call	81137d40 <__ledf2>
81130c80:	10021716 	blt	r2,zero,811314e0 <_strtod_r+0x1414>
81130c84:	b809883a 	mov	r4,r23
81130c88:	b00b883a 	mov	r5,r22
81130c8c:	000d883a 	mov	r6,zero
81130c90:	01cff834 	movhi	r7,16352
81130c94:	1121c800 	call	81121c80 <__muldf3>
81130c98:	d8800d15 	stw	r2,52(sp)
81130c9c:	182f883a 	mov	r23,r3
81130ca0:	102d883a 	mov	r22,r2
81130ca4:	1a20003c 	xorhi	r8,r3,32768
81130ca8:	dd800b15 	stw	r22,44(sp)
81130cac:	402d883a 	mov	r22,r8
81130cb0:	003f8206 	br	81130abc <__reset+0xfb110abc>
81130cb4:	b013883a 	mov	r9,r22
81130cb8:	000b883a 	mov	r5,zero
81130cbc:	0015883a 	mov	r10,zero
81130cc0:	893ff404 	addi	r4,r17,-48
81130cc4:	00800244 	movi	r2,9
81130cc8:	11001036 	bltu	r2,r4,81130d0c <_strtod_r+0xc40>
81130ccc:	28c00044 	addi	r3,r5,1
81130cd0:	2023883a 	mov	r17,r4
81130cd4:	20014d1e 	bne	r4,zero,8113120c <_strtod_r+0x1140>
81130cd8:	d9800617 	ldw	r6,24(sp)
81130cdc:	180b883a 	mov	r5,r3
81130ce0:	30800044 	addi	r2,r6,1
81130ce4:	d8800615 	stw	r2,24(sp)
81130ce8:	34400047 	ldb	r17,1(r6)
81130cec:	003ff406 	br	81130cc0 <__reset+0xfb110cc0>
81130cf0:	0019883a 	mov	r12,zero
81130cf4:	b8800084 	addi	r2,r23,2
81130cf8:	d8800615 	stw	r2,24(sp)
81130cfc:	bc400087 	ldb	r17,2(r23)
81130d00:	003e1606 	br	8113055c <__reset+0xfb11055c>
81130d04:	03000044 	movi	r12,1
81130d08:	003ffa06 	br	81130cf4 <__reset+0xfb110cf4>
81130d0c:	02c00044 	movi	r11,1
81130d10:	003d8d06 	br	81130348 <__reset+0xfb110348>
81130d14:	00800044 	movi	r2,1
81130d18:	9080fe26 	beq	r18,r2,81131114 <_strtod_r+0x1048>
81130d1c:	d8000b15 	stw	zero,44(sp)
81130d20:	05affc34 	movhi	r22,49136
81130d24:	d8000d15 	stw	zero,52(sp)
81130d28:	05cffc34 	movhi	r23,16368
81130d2c:	003f6306 	br	81130abc <__reset+0xfb110abc>
81130d30:	d8000a15 	stw	zero,40(sp)
81130d34:	003ec906 	br	8113085c <__reset+0xfb11085c>
81130d38:	d9001117 	ldw	r4,68(sp)
81130d3c:	00bfffc4 	movi	r2,-1
81130d40:	2080461e 	bne	r4,r2,81130e5c <_strtod_r+0xd90>
81130d44:	dd000a15 	stw	r20,40(sp)
81130d48:	dd001217 	ldw	r20,72(sp)
81130d4c:	a811883a 	mov	r8,r21
81130d50:	d8800517 	ldw	r2,20(sp)
81130d54:	00c00884 	movi	r3,34
81130d58:	80c00015 	stw	r3,0(r16)
81130d5c:	002b883a 	mov	r21,zero
81130d60:	059ffc34 	movhi	r22,32752
81130d64:	100b883a 	mov	r5,r2
81130d68:	8009883a 	mov	r4,r16
81130d6c:	da001315 	stw	r8,76(sp)
81130d70:	112e8b80 	call	8112e8b8 <_Bfree>
81130d74:	d9400a17 	ldw	r5,40(sp)
81130d78:	8009883a 	mov	r4,r16
81130d7c:	112e8b80 	call	8112e8b8 <_Bfree>
81130d80:	980b883a 	mov	r5,r19
81130d84:	8009883a 	mov	r4,r16
81130d88:	112e8b80 	call	8112e8b8 <_Bfree>
81130d8c:	d9400817 	ldw	r5,32(sp)
81130d90:	8009883a 	mov	r4,r16
81130d94:	112e8b80 	call	8112e8b8 <_Bfree>
81130d98:	da001317 	ldw	r8,76(sp)
81130d9c:	8009883a 	mov	r4,r16
81130da0:	400b883a 	mov	r5,r8
81130da4:	112e8b80 	call	8112e8b8 <_Bfree>
81130da8:	003d9206 	br	811303f4 <__reset+0xfb1103f4>
81130dac:	d8c00717 	ldw	r3,28(sp)
81130db0:	d8800504 	addi	r2,sp,20
81130db4:	01a04574 	movhi	r6,33045
81130db8:	318a0c04 	addi	r6,r6,10288
81130dbc:	d8c00115 	stw	r3,4(sp)
81130dc0:	d8800015 	stw	r2,0(sp)
81130dc4:	d9c00404 	addi	r7,sp,16
81130dc8:	d9400604 	addi	r5,sp,24
81130dcc:	8009883a 	mov	r4,r16
81130dd0:	1134f380 	call	81134f38 <__gethex>
81130dd4:	154001cc 	andi	r21,r2,7
81130dd8:	a83d9b26 	beq	r21,zero,81130448 <__reset+0xfb110448>
81130ddc:	00c00184 	movi	r3,6
81130de0:	a8c0d61e 	bne	r21,r3,8113113c <_strtod_r+0x1070>
81130de4:	9cc00044 	addi	r19,r19,1
81130de8:	dcc00615 	stw	r19,24(sp)
81130dec:	002b883a 	mov	r21,zero
81130df0:	002d883a 	mov	r22,zero
81130df4:	d8000715 	stw	zero,28(sp)
81130df8:	003d7e06 	br	811303f4 <__reset+0xfb1103f4>
81130dfc:	00bf2c34 	movhi	r2,64688
81130e00:	88a3883a 	add	r17,r17,r2
81130e04:	9009883a 	mov	r4,r18
81130e08:	880b883a 	mov	r5,r17
81130e0c:	112f36c0 	call	8112f36c <__ulp>
81130e10:	d9000b17 	ldw	r4,44(sp)
81130e14:	100d883a 	mov	r6,r2
81130e18:	180f883a 	mov	r7,r3
81130e1c:	b00b883a 	mov	r5,r22
81130e20:	1121c800 	call	81121c80 <__muldf3>
81130e24:	900d883a 	mov	r6,r18
81130e28:	180b883a 	mov	r5,r3
81130e2c:	880f883a 	mov	r7,r17
81130e30:	1009883a 	mov	r4,r2
81130e34:	1136b140 	call	81136b14 <__adddf3>
81130e38:	015f2834 	movhi	r5,31904
81130e3c:	1025883a 	mov	r18,r2
81130e40:	297fffc4 	addi	r5,r5,-1
81130e44:	189ffc2c 	andhi	r2,r3,32752
81130e48:	2880892e 	bgeu	r5,r2,81131070 <_strtod_r+0xfa4>
81130e4c:	d8801017 	ldw	r2,64(sp)
81130e50:	00dffc34 	movhi	r3,32752
81130e54:	18ffffc4 	addi	r3,r3,-1
81130e58:	10ffb726 	beq	r2,r3,81130d38 <__reset+0xfb110d38>
81130e5c:	045ffc34 	movhi	r17,32752
81130e60:	8c7fffc4 	addi	r17,r17,-1
81130e64:	04bfffc4 	movi	r18,-1
81130e68:	003f4706 	br	81130b88 <__reset+0xfb110b88>
81130e6c:	00800884 	movi	r2,34
81130e70:	80800015 	stw	r2,0(r16)
81130e74:	002b883a 	mov	r21,zero
81130e78:	059ffc34 	movhi	r22,32752
81130e7c:	003d5d06 	br	811303f4 <__reset+0xfb1103f4>
81130e80:	d9000d17 	ldw	r4,52(sp)
81130e84:	b80b883a 	mov	r5,r23
81130e88:	1122ca40 	call	81122ca4 <__fixdfsi>
81130e8c:	1009883a 	mov	r4,r2
81130e90:	1122d240 	call	81122d24 <__floatsidf>
81130e94:	d9000d17 	ldw	r4,52(sp)
81130e98:	b80b883a 	mov	r5,r23
81130e9c:	100d883a 	mov	r6,r2
81130ea0:	180f883a 	mov	r7,r3
81130ea4:	11223a00 	call	811223a0 <__subdf3>
81130ea8:	d9400e17 	ldw	r5,56(sp)
81130eac:	1039883a 	mov	fp,r2
81130eb0:	182f883a 	mov	r23,r3
81130eb4:	2800141e 	bne	r5,zero,81130f08 <_strtod_r+0xe3c>
81130eb8:	9000131e 	bne	r18,zero,81130f08 <_strtod_r+0xe3c>
81130ebc:	00800434 	movhi	r2,16
81130ec0:	10bfffc4 	addi	r2,r2,-1
81130ec4:	b0ac703a 	and	r22,r22,r2
81130ec8:	b0000f1e 	bne	r22,zero,81130f08 <_strtod_r+0xe3c>
81130ecc:	01a52834 	movhi	r6,38048
81130ed0:	01cff434 	movhi	r7,16336
81130ed4:	318d6544 	addi	r6,r6,13717
81130ed8:	39ffffc4 	addi	r7,r7,-1
81130edc:	e009883a 	mov	r4,fp
81130ee0:	180b883a 	mov	r5,r3
81130ee4:	1137d400 	call	81137d40 <__ledf2>
81130ee8:	103f270e 	bge	r2,zero,81130b88 <__reset+0xfb110b88>
81130eec:	dd000a15 	stw	r20,40(sp)
81130ef0:	a811883a 	mov	r8,r21
81130ef4:	dd001217 	ldw	r20,72(sp)
81130ef8:	d8800517 	ldw	r2,20(sp)
81130efc:	002b883a 	mov	r21,zero
81130f00:	882d883a 	mov	r22,r17
81130f04:	003f9706 	br	81130d64 <__reset+0xfb110d64>
81130f08:	01a52834 	movhi	r6,38048
81130f0c:	01cff834 	movhi	r7,16352
81130f10:	318d6544 	addi	r6,r6,13717
81130f14:	39ffffc4 	addi	r7,r7,-1
81130f18:	e009883a 	mov	r4,fp
81130f1c:	b80b883a 	mov	r5,r23
81130f20:	1137d400 	call	81137d40 <__ledf2>
81130f24:	10000716 	blt	r2,zero,81130f44 <_strtod_r+0xe78>
81130f28:	018d6c34 	movhi	r6,13744
81130f2c:	31b94d44 	addi	r6,r6,-6859
81130f30:	01cff834 	movhi	r7,16352
81130f34:	e009883a 	mov	r4,fp
81130f38:	b80b883a 	mov	r5,r23
81130f3c:	1121ba40 	call	81121ba4 <__gedf2>
81130f40:	00bf110e 	bge	zero,r2,81130b88 <__reset+0xfb110b88>
81130f44:	dd000a15 	stw	r20,40(sp)
81130f48:	a811883a 	mov	r8,r21
81130f4c:	dd001217 	ldw	r20,72(sp)
81130f50:	d8800517 	ldw	r2,20(sp)
81130f54:	902b883a 	mov	r21,r18
81130f58:	882d883a 	mov	r22,r17
81130f5c:	003f8106 	br	81130d64 <__reset+0xfb110d64>
81130f60:	b83e2f26 	beq	r23,zero,81130820 <__reset+0xfb110820>
81130f64:	05efc83a 	sub	r23,zero,r23
81130f68:	b88003cc 	andi	r2,r23,15
81130f6c:	10000d26 	beq	r2,zero,81130fa4 <_strtod_r+0xed8>
81130f70:	100490fa 	slli	r2,r2,3
81130f74:	00e04574 	movhi	r3,33045
81130f78:	18c9d104 	addi	r3,r3,10052
81130f7c:	1885883a 	add	r2,r3,r2
81130f80:	11800017 	ldw	r6,0(r2)
81130f84:	11c00117 	ldw	r7,4(r2)
81130f88:	9009883a 	mov	r4,r18
81130f8c:	880b883a 	mov	r5,r17
81130f90:	da401315 	stw	r9,76(sp)
81130f94:	11373c80 	call	811373c8 <__divdf3>
81130f98:	da401317 	ldw	r9,76(sp)
81130f9c:	1025883a 	mov	r18,r2
81130fa0:	1823883a 	mov	r17,r3
81130fa4:	b82fd13a 	srai	r23,r23,4
81130fa8:	b83e1d26 	beq	r23,zero,81130820 <__reset+0xfb110820>
81130fac:	008007c4 	movi	r2,31
81130fb0:	15c02816 	blt	r2,r23,81131054 <_strtod_r+0xf88>
81130fb4:	b880040c 	andi	r2,r23,16
81130fb8:	10019726 	beq	r2,zero,81131618 <_strtod_r+0x154c>
81130fbc:	05c1880e 	bge	zero,r23,811315e0 <_strtod_r+0x1514>
81130fc0:	00c01a84 	movi	r3,106
81130fc4:	d8c00915 	stw	r3,36(sp)
81130fc8:	04e04574 	movhi	r19,33045
81130fcc:	9cca1104 	addi	r19,r19,10308
81130fd0:	8807883a 	mov	r3,r17
81130fd4:	9005883a 	mov	r2,r18
81130fd8:	8023883a 	mov	r17,r16
81130fdc:	0009883a 	mov	r4,zero
81130fe0:	9821883a 	mov	r16,r19
81130fe4:	da400a15 	stw	r9,40(sp)
81130fe8:	1827883a 	mov	r19,r3
81130fec:	b980004c 	andi	r6,r23,1
81130ff0:	30000626 	beq	r6,zero,8113100c <_strtod_r+0xf40>
81130ff4:	81800017 	ldw	r6,0(r16)
81130ff8:	81c00117 	ldw	r7,4(r16)
81130ffc:	1009883a 	mov	r4,r2
81131000:	180b883a 	mov	r5,r3
81131004:	1121c800 	call	81121c80 <__muldf3>
81131008:	01000044 	movi	r4,1
8113100c:	b82fd07a 	srai	r23,r23,1
81131010:	84000204 	addi	r16,r16,8
81131014:	b83ff51e 	bne	r23,zero,81130fec <__reset+0xfb110fec>
81131018:	21003fcc 	andi	r4,r4,255
8113101c:	8821883a 	mov	r16,r17
81131020:	da400a17 	ldw	r9,40(sp)
81131024:	9823883a 	mov	r17,r19
81131028:	2001a51e 	bne	r4,zero,811316c0 <_strtod_r+0x15f4>
8113102c:	d9000917 	ldw	r4,36(sp)
81131030:	20016d1e 	bne	r4,zero,811315e8 <_strtod_r+0x151c>
81131034:	000d883a 	mov	r6,zero
81131038:	000f883a 	mov	r7,zero
8113103c:	9009883a 	mov	r4,r18
81131040:	880b883a 	mov	r5,r17
81131044:	da401315 	stw	r9,76(sp)
81131048:	1137cb80 	call	81137cb8 <__eqdf2>
8113104c:	da401317 	ldw	r9,76(sp)
81131050:	103df41e 	bne	r2,zero,81130824 <__reset+0xfb110824>
81131054:	00800884 	movi	r2,34
81131058:	80800015 	stw	r2,0(r16)
8113105c:	002b883a 	mov	r21,zero
81131060:	002d883a 	mov	r22,zero
81131064:	003ce306 	br	811303f4 <__reset+0xfb1103f4>
81131068:	055387c4 	movi	r21,19999
8113106c:	003d6b06 	br	8113061c <__reset+0xfb11061c>
81131070:	0440d434 	movhi	r17,848
81131074:	1c63883a 	add	r17,r3,r17
81131078:	882d883a 	mov	r22,r17
8113107c:	003ebe06 	br	81130b78 <__reset+0xfb110b78>
81131080:	14403fcc 	andi	r17,r2,255
81131084:	8c40201c 	xori	r17,r17,128
81131088:	8c7fe004 	addi	r17,r17,-128
8113108c:	dd400817 	ldw	r21,32(sp)
81131090:	0027883a 	mov	r19,zero
81131094:	0039883a 	mov	fp,zero
81131098:	002d883a 	mov	r22,zero
8113109c:	003c9906 	br	81130304 <__reset+0xfb110304>
811310a0:	00c00944 	movi	r3,37
811310a4:	1a47c83a 	sub	r3,r3,r9
811310a8:	1d7d8c16 	blt	r3,r21,811306dc <__reset+0xfb1106dc>
811310ac:	1261c83a 	sub	r16,r2,r9
811310b0:	800490fa 	slli	r2,r16,3
811310b4:	04e04574 	movhi	r19,33045
811310b8:	9cc9d104 	addi	r19,r19,10052
811310bc:	9885883a 	add	r2,r19,r2
811310c0:	11000017 	ldw	r4,0(r2)
811310c4:	11400117 	ldw	r5,4(r2)
811310c8:	900d883a 	mov	r6,r18
811310cc:	880f883a 	mov	r7,r17
811310d0:	1121c800 	call	81121c80 <__muldf3>
811310d4:	ac0dc83a 	sub	r6,r21,r16
811310d8:	300c90fa 	slli	r6,r6,3
811310dc:	1009883a 	mov	r4,r2
811310e0:	180b883a 	mov	r5,r3
811310e4:	9985883a 	add	r2,r19,r6
811310e8:	11800017 	ldw	r6,0(r2)
811310ec:	11c00117 	ldw	r7,4(r2)
811310f0:	1121c800 	call	81121c80 <__muldf3>
811310f4:	102b883a 	mov	r21,r2
811310f8:	182d883a 	mov	r22,r3
811310fc:	003cbd06 	br	811303f4 <__reset+0xfb1103f4>
81131100:	b811883a 	mov	r8,r23
81131104:	003e8606 	br	81130b20 <__reset+0xfb110b20>
81131108:	d8000d15 	stw	zero,52(sp)
8113110c:	05cffc34 	movhi	r23,16368
81131110:	003e8006 	br	81130b14 <__reset+0xfb110b14>
81131114:	883f011e 	bne	r17,zero,81130d1c <__reset+0xfb110d1c>
81131118:	dd000a15 	stw	r20,40(sp)
8113111c:	dd001217 	ldw	r20,72(sp)
81131120:	a811883a 	mov	r8,r21
81131124:	00800884 	movi	r2,34
81131128:	80800015 	stw	r2,0(r16)
8113112c:	002b883a 	mov	r21,zero
81131130:	d8800517 	ldw	r2,20(sp)
81131134:	002d883a 	mov	r22,zero
81131138:	003f0a06 	br	81130d64 <__reset+0xfb110d64>
8113113c:	d9800517 	ldw	r6,20(sp)
81131140:	30000826 	beq	r6,zero,81131164 <_strtod_r+0x1098>
81131144:	01400d44 	movi	r5,53
81131148:	d9000204 	addi	r4,sp,8
8113114c:	d8801315 	stw	r2,76(sp)
81131150:	112f7600 	call	8112f760 <__copybits>
81131154:	d9400517 	ldw	r5,20(sp)
81131158:	8009883a 	mov	r4,r16
8113115c:	112e8b80 	call	8112e8b8 <_Bfree>
81131160:	d8801317 	ldw	r2,76(sp)
81131164:	00c00184 	movi	r3,6
81131168:	1d400f36 	bltu	r3,r21,811311a8 <_strtod_r+0x10dc>
8113116c:	a82a90ba 	slli	r21,r21,2
81131170:	00e044f4 	movhi	r3,33043
81131174:	18c46104 	addi	r3,r3,4484
81131178:	a8eb883a 	add	r21,r21,r3
8113117c:	a8c00017 	ldw	r3,0(r21)
81131180:	1800683a 	jmp	r3
81131184:	81131200 	call	88113120 <__reset+0x20f3120>
81131188:	811311d8 	cmpnei	r4,r16,19527
8113118c:	811311bc 	xorhi	r4,r16,19526
81131190:	811311a0 	cmpeqi	r4,r16,19526
81131194:	811311c8 	cmpgei	r4,r16,19527
81131198:	811311d8 	cmpnei	r4,r16,19527
8113119c:	81131200 	call	88113120 <__reset+0x20f3120>
811311a0:	045ffc34 	movhi	r17,32752
811311a4:	0025883a 	mov	r18,zero
811311a8:	1080020c 	andi	r2,r2,8
811311ac:	902b883a 	mov	r21,r18
811311b0:	103c8f26 	beq	r2,zero,811303f0 <__reset+0xfb1103f0>
811311b4:	8da00034 	orhi	r22,r17,32768
811311b8:	003c8e06 	br	811303f4 <__reset+0xfb1103f4>
811311bc:	dc800217 	ldw	r18,8(sp)
811311c0:	dc400317 	ldw	r17,12(sp)
811311c4:	003ff806 	br	811311a8 <__reset+0xfb1111a8>
811311c8:	04600034 	movhi	r17,32768
811311cc:	8c7fffc4 	addi	r17,r17,-1
811311d0:	04bfffc4 	movi	r18,-1
811311d4:	003ff406 	br	811311a8 <__reset+0xfb1111a8>
811311d8:	d8c00417 	ldw	r3,16(sp)
811311dc:	dc400317 	ldw	r17,12(sp)
811311e0:	013ffc34 	movhi	r4,65520
811311e4:	18c10cc4 	addi	r3,r3,1075
811311e8:	1806953a 	slli	r3,r3,20
811311ec:	213fffc4 	addi	r4,r4,-1
811311f0:	8922703a 	and	r17,r17,r4
811311f4:	dc800217 	ldw	r18,8(sp)
811311f8:	88e2b03a 	or	r17,r17,r3
811311fc:	003fea06 	br	811311a8 <__reset+0xfb1111a8>
81131200:	0023883a 	mov	r17,zero
81131204:	0025883a 	mov	r18,zero
81131208:	003fe706 	br	811311a8 <__reset+0xfb1111a8>
8113120c:	01800044 	movi	r6,1
81131210:	50d5883a 	add	r10,r10,r3
81131214:	2a4b883a 	add	r5,r5,r9
81131218:	19811a26 	beq	r3,r6,81131684 <_strtod_r+0x15b8>
8113121c:	01800204 	movi	r6,8
81131220:	01c00404 	movi	r7,16
81131224:	4a400044 	addi	r9,r9,1
81131228:	48bfffc4 	addi	r2,r9,-1
8113122c:	30801616 	blt	r6,r2,81131288 <_strtod_r+0x11bc>
81131230:	e70002a4 	muli	fp,fp,10
81131234:	497ffb1e 	bne	r9,r5,81131224 <__reset+0xfb111224>
81131238:	d9800617 	ldw	r6,24(sp)
8113123c:	4a400044 	addi	r9,r9,1
81131240:	00c00204 	movi	r3,8
81131244:	19400c0e 	bge	r3,r5,81131278 <_strtod_r+0x11ac>
81131248:	00800404 	movi	r2,16
8113124c:	000b883a 	mov	r5,zero
81131250:	127ea316 	blt	r2,r9,81130ce0 <__reset+0xfb110ce0>
81131254:	988002a4 	muli	r2,r19,10
81131258:	20a7883a 	add	r19,r4,r2
8113125c:	003ea006 	br	81130ce0 <__reset+0xfb110ce0>
81131260:	d8800617 	ldw	r2,24(sp)
81131264:	8c7ff404 	addi	r17,r17,-48
81131268:	2a800044 	addi	r10,r5,1
8113126c:	d8800815 	stw	r2,32(sp)
81131270:	100d883a 	mov	r6,r2
81131274:	02400044 	movi	r9,1
81131278:	e08002a4 	muli	r2,fp,10
8113127c:	000b883a 	mov	r5,zero
81131280:	88b9883a 	add	fp,r17,r2
81131284:	003e9606 	br	81130ce0 <__reset+0xfb110ce0>
81131288:	3a7fea16 	blt	r7,r9,81131234 <__reset+0xfb111234>
8113128c:	9cc002a4 	muli	r19,r19,10
81131290:	003fe806 	br	81131234 <__reset+0xfb111234>
81131294:	00bffa84 	movi	r2,-22
81131298:	a8bd1016 	blt	r21,r2,811306dc <__reset+0xfb1106dc>
8113129c:	a82a90fa 	slli	r21,r21,3
811312a0:	00a04574 	movhi	r2,33045
811312a4:	1089d104 	addi	r2,r2,10052
811312a8:	1545c83a 	sub	r2,r2,r21
811312ac:	11800017 	ldw	r6,0(r2)
811312b0:	11c00117 	ldw	r7,4(r2)
811312b4:	9009883a 	mov	r4,r18
811312b8:	880b883a 	mov	r5,r17
811312bc:	11373c80 	call	811373c8 <__divdf3>
811312c0:	102b883a 	mov	r21,r2
811312c4:	182d883a 	mov	r22,r3
811312c8:	003c4a06 	br	811303f4 <__reset+0xfb1103f4>
811312cc:	dd000a15 	stw	r20,40(sp)
811312d0:	a811883a 	mov	r8,r21
811312d4:	dd001217 	ldw	r20,72(sp)
811312d8:	003e9e06 	br	81130d54 <__reset+0xfb110d54>
811312dc:	01604574 	movhi	r5,33045
811312e0:	d9000617 	ldw	r4,24(sp)
811312e4:	294a0304 	addi	r5,r5,10252
811312e8:	01c00644 	movi	r7,25
811312ec:	00000b06 	br	8113131c <_strtod_r+0x1250>
811312f0:	21000044 	addi	r4,r4,1
811312f4:	20800003 	ldbu	r2,0(r4)
811312f8:	10ffefc4 	addi	r3,r2,-65
811312fc:	10803fcc 	andi	r2,r2,255
81131300:	1080201c 	xori	r2,r2,128
81131304:	18c03fcc 	andi	r3,r3,255
81131308:	10bfe004 	addi	r2,r2,-128
8113130c:	38c00136 	bltu	r7,r3,81131314 <_strtod_r+0x1248>
81131310:	10800804 	addi	r2,r2,32
81131314:	29400044 	addi	r5,r5,1
81131318:	11bbbb1e 	bne	r2,r6,81130208 <__reset+0xfb110208>
8113131c:	29800007 	ldb	r6,0(r5)
81131320:	303ff31e 	bne	r6,zero,811312f0 <__reset+0xfb1112f0>
81131324:	01a04574 	movhi	r6,33045
81131328:	d9000615 	stw	r4,24(sp)
8113132c:	318a0404 	addi	r6,r6,10256
81131330:	200b883a 	mov	r5,r4
81131334:	02000644 	movi	r8,25
81131338:	00000a06 	br	81131364 <_strtod_r+0x1298>
8113133c:	28800003 	ldbu	r2,0(r5)
81131340:	10ffefc4 	addi	r3,r2,-65
81131344:	10803fcc 	andi	r2,r2,255
81131348:	1080201c 	xori	r2,r2,128
8113134c:	18c03fcc 	andi	r3,r3,255
81131350:	10bfe004 	addi	r2,r2,-128
81131354:	40c00136 	bltu	r8,r3,8113135c <_strtod_r+0x1290>
81131358:	10800804 	addi	r2,r2,32
8113135c:	31800044 	addi	r6,r6,1
81131360:	11c0711e 	bne	r2,r7,81131528 <_strtod_r+0x145c>
81131364:	31c00007 	ldb	r7,0(r6)
81131368:	29400044 	addi	r5,r5,1
8113136c:	383ff31e 	bne	r7,zero,8113133c <__reset+0xfb11133c>
81131370:	d9400615 	stw	r5,24(sp)
81131374:	045ffc34 	movhi	r17,32752
81131378:	0025883a 	mov	r18,zero
8113137c:	003c1b06 	br	811303ec <__reset+0xfb1103ec>
81131380:	000b883a 	mov	r5,zero
81131384:	003ccc06 	br	811306b8 <__reset+0xfb1106b8>
81131388:	d9400e17 	ldw	r5,56(sp)
8113138c:	dd000a15 	stw	r20,40(sp)
81131390:	00800434 	movhi	r2,16
81131394:	a811883a 	mov	r8,r21
81131398:	dd001217 	ldw	r20,72(sp)
8113139c:	dd401117 	ldw	r21,68(sp)
811313a0:	dd801017 	ldw	r22,64(sp)
811313a4:	10bfffc4 	addi	r2,r2,-1
811313a8:	28005626 	beq	r5,zero,81131504 <_strtod_r+0x1438>
811313ac:	8886703a 	and	r3,r17,r2
811313b0:	18807826 	beq	r3,r2,81131594 <_strtod_r+0x14c8>
811313b4:	d8c00b17 	ldw	r3,44(sp)
811313b8:	18005726 	beq	r3,zero,81131518 <_strtod_r+0x144c>
811313bc:	1c44703a 	and	r2,r3,r17
811313c0:	10000f26 	beq	r2,zero,81131400 <_strtod_r+0x1334>
811313c4:	d9000e17 	ldw	r4,56(sp)
811313c8:	d9800917 	ldw	r6,36(sp)
811313cc:	20005e26 	beq	r4,zero,81131548 <_strtod_r+0x147c>
811313d0:	9009883a 	mov	r4,r18
811313d4:	880b883a 	mov	r5,r17
811313d8:	da001315 	stw	r8,76(sp)
811313dc:	11300600 	call	81130060 <sulp>
811313e0:	100d883a 	mov	r6,r2
811313e4:	180f883a 	mov	r7,r3
811313e8:	9009883a 	mov	r4,r18
811313ec:	880b883a 	mov	r5,r17
811313f0:	1136b140 	call	81136b14 <__adddf3>
811313f4:	da001317 	ldw	r8,76(sp)
811313f8:	102b883a 	mov	r21,r2
811313fc:	182d883a 	mov	r22,r3
81131400:	d8c00917 	ldw	r3,36(sp)
81131404:	18000f26 	beq	r3,zero,81131444 <_strtod_r+0x1378>
81131408:	a809883a 	mov	r4,r21
8113140c:	b00b883a 	mov	r5,r22
81131410:	000d883a 	mov	r6,zero
81131414:	01ce5434 	movhi	r7,14672
81131418:	da001315 	stw	r8,76(sp)
8113141c:	1121c800 	call	81121c80 <__muldf3>
81131420:	102b883a 	mov	r21,r2
81131424:	182d883a 	mov	r22,r3
81131428:	da001317 	ldw	r8,76(sp)
8113142c:	1800051e 	bne	r3,zero,81131444 <_strtod_r+0x1378>
81131430:	d8800517 	ldw	r2,20(sp)
81131434:	a83e4b1e 	bne	r21,zero,81130d64 <__reset+0xfb110d64>
81131438:	00c00884 	movi	r3,34
8113143c:	80c00015 	stw	r3,0(r16)
81131440:	003e4806 	br	81130d64 <__reset+0xfb110d64>
81131444:	d8800517 	ldw	r2,20(sp)
81131448:	003e4606 	br	81130d64 <__reset+0xfb110d64>
8113144c:	d9000e17 	ldw	r4,56(sp)
81131450:	dd000a15 	stw	r20,40(sp)
81131454:	a811883a 	mov	r8,r21
81131458:	dd001217 	ldw	r20,72(sp)
8113145c:	dd401117 	ldw	r21,68(sp)
81131460:	dd801017 	ldw	r22,64(sp)
81131464:	203fe61e 	bne	r4,zero,81131400 <__reset+0xfb111400>
81131468:	903fe51e 	bne	r18,zero,81131400 <__reset+0xfb111400>
8113146c:	00800434 	movhi	r2,16
81131470:	10bfffc4 	addi	r2,r2,-1
81131474:	8884703a 	and	r2,r17,r2
81131478:	103fe11e 	bne	r2,zero,81131400 <__reset+0xfb111400>
8113147c:	8ddffc2c 	andhi	r23,r17,32752
81131480:	0081ac34 	movhi	r2,1712
81131484:	15ffde2e 	bgeu	r2,r23,81131400 <__reset+0xfb111400>
81131488:	40800517 	ldw	r2,20(r8)
8113148c:	1000031e 	bne	r2,zero,8113149c <_strtod_r+0x13d0>
81131490:	40800417 	ldw	r2,16(r8)
81131494:	00c00044 	movi	r3,1
81131498:	18bfd90e 	bge	r3,r2,81131400 <__reset+0xfb111400>
8113149c:	400b883a 	mov	r5,r8
811314a0:	01800044 	movi	r6,1
811314a4:	8009883a 	mov	r4,r16
811314a8:	112efb80 	call	8112efb8 <__lshift>
811314ac:	980b883a 	mov	r5,r19
811314b0:	1009883a 	mov	r4,r2
811314b4:	d8801315 	stw	r2,76(sp)
811314b8:	112f1080 	call	8112f108 <__mcmp>
811314bc:	da001317 	ldw	r8,76(sp)
811314c0:	00bfcf0e 	bge	zero,r2,81131400 <__reset+0xfb111400>
811314c4:	d8c00917 	ldw	r3,36(sp)
811314c8:	18005c26 	beq	r3,zero,8113163c <_strtod_r+0x1570>
811314cc:	0081ac34 	movhi	r2,1712
811314d0:	15c05a16 	blt	r2,r23,8113163c <_strtod_r+0x1570>
811314d4:	0080dc34 	movhi	r2,880
811314d8:	15ffcb16 	blt	r2,r23,81131408 <__reset+0xfb111408>
811314dc:	003f1106 	br	81131124 <__reset+0xfb111124>
811314e0:	002d883a 	mov	r22,zero
811314e4:	022ff834 	movhi	r8,49120
811314e8:	d8000d15 	stw	zero,52(sp)
811314ec:	05cff834 	movhi	r23,16352
811314f0:	003ded06 	br	81130ca8 <__reset+0xfb110ca8>
811314f4:	0440d434 	movhi	r17,848
811314f8:	1c63883a 	add	r17,r3,r17
811314fc:	d8000915 	stw	zero,36(sp)
81131500:	003cc806 	br	81130824 <__reset+0xfb110824>
81131504:	8884703a 	and	r2,r17,r2
81131508:	103faa1e 	bne	r2,zero,811313b4 <__reset+0xfb1113b4>
8113150c:	903fa91e 	bne	r18,zero,811313b4 <__reset+0xfb1113b4>
81131510:	8ddffc2c 	andhi	r23,r17,32752
81131514:	003feb06 	br	811314c4 <__reset+0xfb1114c4>
81131518:	d8c00d17 	ldw	r3,52(sp)
8113151c:	1cae703a 	and	r23,r3,r18
81131520:	b83fb726 	beq	r23,zero,81131400 <__reset+0xfb111400>
81131524:	003fa706 	br	811313c4 <__reset+0xfb1113c4>
81131528:	21000044 	addi	r4,r4,1
8113152c:	d9000615 	stw	r4,24(sp)
81131530:	003f9006 	br	81131374 <__reset+0xfb111374>
81131534:	01604574 	movhi	r5,33045
81131538:	2949c704 	addi	r5,r5,10012
8113153c:	d9400915 	stw	r5,36(sp)
81131540:	0027883a 	mov	r19,zero
81131544:	003ca206 	br	811307d0 <__reset+0xfb1107d0>
81131548:	9009883a 	mov	r4,r18
8113154c:	880b883a 	mov	r5,r17
81131550:	da001315 	stw	r8,76(sp)
81131554:	11300600 	call	81130060 <sulp>
81131558:	100d883a 	mov	r6,r2
8113155c:	180f883a 	mov	r7,r3
81131560:	9009883a 	mov	r4,r18
81131564:	880b883a 	mov	r5,r17
81131568:	11223a00 	call	811223a0 <__subdf3>
8113156c:	000d883a 	mov	r6,zero
81131570:	000f883a 	mov	r7,zero
81131574:	1009883a 	mov	r4,r2
81131578:	180b883a 	mov	r5,r3
8113157c:	102b883a 	mov	r21,r2
81131580:	182d883a 	mov	r22,r3
81131584:	1137cb80 	call	81137cb8 <__eqdf2>
81131588:	da001317 	ldw	r8,76(sp)
8113158c:	103ee526 	beq	r2,zero,81131124 <__reset+0xfb111124>
81131590:	003f9b06 	br	81131400 <__reset+0xfb111400>
81131594:	d8800917 	ldw	r2,36(sp)
81131598:	10002226 	beq	r2,zero,81131624 <_strtod_r+0x1558>
8113159c:	889ffc2c 	andhi	r2,r17,32752
811315a0:	00c1a834 	movhi	r3,1696
811315a4:	18801f36 	bltu	r3,r2,81131624 <_strtod_r+0x1558>
811315a8:	1004d53a 	srli	r2,r2,20
811315ac:	00c01ac4 	movi	r3,107
811315b0:	1887c83a 	sub	r3,r3,r2
811315b4:	00bfffc4 	movi	r2,-1
811315b8:	10c4983a 	sll	r2,r2,r3
811315bc:	14bf7d1e 	bne	r2,r18,811313b4 <__reset+0xfb1113b4>
811315c0:	00dffc34 	movhi	r3,32752
811315c4:	18ffffc4 	addi	r3,r3,-1
811315c8:	88c03526 	beq	r17,r3,811316a0 <_strtod_r+0x15d4>
811315cc:	8c5ffc2c 	andhi	r17,r17,32752
811315d0:	00800434 	movhi	r2,16
811315d4:	002b883a 	mov	r21,zero
811315d8:	88ad883a 	add	r22,r17,r2
811315dc:	003f8806 	br	81131400 <__reset+0xfb111400>
811315e0:	01401a84 	movi	r5,106
811315e4:	d9400915 	stw	r5,36(sp)
811315e8:	8ddffc2c 	andhi	r23,r17,32752
811315ec:	b82ed53a 	srli	r23,r23,20
811315f0:	00801ac4 	movi	r2,107
811315f4:	15c5c83a 	sub	r2,r2,r23
811315f8:	00be8e0e 	bge	zero,r2,81131034 <__reset+0xfb111034>
811315fc:	00c007c4 	movi	r3,31
81131600:	18800a0e 	bge	r3,r2,8113162c <_strtod_r+0x1560>
81131604:	00c00d04 	movi	r3,52
81131608:	0025883a 	mov	r18,zero
8113160c:	1880270e 	bge	r3,r2,811316ac <_strtod_r+0x15e0>
81131610:	0440dc34 	movhi	r17,880
81131614:	003e8706 	br	81131034 <__reset+0xfb111034>
81131618:	d8000915 	stw	zero,36(sp)
8113161c:	05fe6a16 	blt	zero,r23,81130fc8 <__reset+0xfb110fc8>
81131620:	003e8406 	br	81131034 <__reset+0xfb111034>
81131624:	00bfffc4 	movi	r2,-1
81131628:	003fe406 	br	811315bc <__reset+0xfb1115bc>
8113162c:	00ffffc4 	movi	r3,-1
81131630:	1884983a 	sll	r2,r3,r2
81131634:	14a4703a 	and	r18,r2,r18
81131638:	003e7e06 	br	81131034 <__reset+0xfb111034>
8113163c:	00bffc34 	movhi	r2,65520
81131640:	b8af883a 	add	r23,r23,r2
81131644:	057fffc4 	movi	r21,-1
81131648:	00800434 	movhi	r2,16
8113164c:	1545883a 	add	r2,r2,r21
81131650:	b8acb03a 	or	r22,r23,r2
81131654:	003f6a06 	br	81131400 <__reset+0xfb111400>
81131658:	01604574 	movhi	r5,33045
8113165c:	294a0704 	addi	r5,r5,10268
81131660:	d9800204 	addi	r6,sp,8
81131664:	d9000604 	addi	r4,sp,24
81131668:	11357700 	call	81135770 <__hexnan>
8113166c:	00c00144 	movi	r3,5
81131670:	10fb5c1e 	bne	r2,r3,811303e4 <__reset+0xfb1103e4>
81131674:	dc400317 	ldw	r17,12(sp)
81131678:	dc800217 	ldw	r18,8(sp)
8113167c:	8c5ffc34 	orhi	r17,r17,32752
81131680:	003b5a06 	br	811303ec <__reset+0xfb1103ec>
81131684:	480b883a 	mov	r5,r9
81131688:	d9800617 	ldw	r6,24(sp)
8113168c:	4a400044 	addi	r9,r9,1
81131690:	003eeb06 	br	81131240 <__reset+0xfb111240>
81131694:	1025883a 	mov	r18,r2
81131698:	1823883a 	mov	r17,r3
8113169c:	003c4c06 	br	811307d0 <__reset+0xfb1107d0>
811316a0:	00ffffc4 	movi	r3,-1
811316a4:	10ffc91e 	bne	r2,r3,811315cc <__reset+0xfb1115cc>
811316a8:	003da906 	br	81130d50 <__reset+0xfb110d50>
811316ac:	10bff804 	addi	r2,r2,-32
811316b0:	00ffffc4 	movi	r3,-1
811316b4:	1884983a 	sll	r2,r3,r2
811316b8:	1462703a 	and	r17,r2,r17
811316bc:	003e5d06 	br	81131034 <__reset+0xfb111034>
811316c0:	1025883a 	mov	r18,r2
811316c4:	1823883a 	mov	r17,r3
811316c8:	003e5806 	br	8113102c <__reset+0xfb11102c>

811316cc <strtod>:
811316cc:	00a04574 	movhi	r2,33045
811316d0:	10936004 	addi	r2,r2,19840
811316d4:	280d883a 	mov	r6,r5
811316d8:	200b883a 	mov	r5,r4
811316dc:	11000017 	ldw	r4,0(r2)
811316e0:	11300cc1 	jmpi	811300cc <_strtod_r>

811316e4 <strtof>:
811316e4:	defffb04 	addi	sp,sp,-20
811316e8:	de00012e 	bgeu	sp,et,811316f0 <strtof+0xc>
811316ec:	003b68fa 	trap	3
811316f0:	dcc00315 	stw	r19,12(sp)
811316f4:	04e04574 	movhi	r19,33045
811316f8:	9cd36004 	addi	r19,r19,19840
811316fc:	280d883a 	mov	r6,r5
81131700:	200b883a 	mov	r5,r4
81131704:	99000017 	ldw	r4,0(r19)
81131708:	dfc00415 	stw	ra,16(sp)
8113170c:	dc800215 	stw	r18,8(sp)
81131710:	dc400115 	stw	r17,4(sp)
81131714:	dc000015 	stw	r16,0(sp)
81131718:	11300cc0 	call	811300cc <_strtod_r>
8113171c:	1009883a 	mov	r4,r2
81131720:	180b883a 	mov	r5,r3
81131724:	1025883a 	mov	r18,r2
81131728:	1823883a 	mov	r17,r3
8113172c:	1122f200 	call	81122f20 <__truncdfsf2>
81131730:	000b883a 	mov	r5,zero
81131734:	1009883a 	mov	r4,r2
81131738:	1021883a 	mov	r16,r2
8113173c:	11369180 	call	81136918 <__eqsf2>
81131740:	1000111e 	bne	r2,zero,81131788 <strtof+0xa4>
81131744:	000d883a 	mov	r6,zero
81131748:	000f883a 	mov	r7,zero
8113174c:	9009883a 	mov	r4,r18
81131750:	880b883a 	mov	r5,r17
81131754:	1137cb80 	call	81137cb8 <__eqdf2>
81131758:	10000b26 	beq	r2,zero,81131788 <strtof+0xa4>
8113175c:	98800017 	ldw	r2,0(r19)
81131760:	00c00884 	movi	r3,34
81131764:	10c00015 	stw	r3,0(r2)
81131768:	8005883a 	mov	r2,r16
8113176c:	dfc00417 	ldw	ra,16(sp)
81131770:	dcc00317 	ldw	r19,12(sp)
81131774:	dc800217 	ldw	r18,8(sp)
81131778:	dc400117 	ldw	r17,4(sp)
8113177c:	dc000017 	ldw	r16,0(sp)
81131780:	dec00504 	addi	sp,sp,20
81131784:	f800283a 	ret
81131788:	015fe034 	movhi	r5,32640
8113178c:	297fffc4 	addi	r5,r5,-1
81131790:	8009883a 	mov	r4,r16
81131794:	11369900 	call	81136990 <__gesf2>
81131798:	0080070e 	bge	zero,r2,811317b8 <strtof+0xd4>
8113179c:	01dffc34 	movhi	r7,32752
811317a0:	39ffffc4 	addi	r7,r7,-1
811317a4:	01bfffc4 	movi	r6,-1
811317a8:	9009883a 	mov	r4,r18
811317ac:	880b883a 	mov	r5,r17
811317b0:	1121ba40 	call	81121ba4 <__gedf2>
811317b4:	00bfe90e 	bge	zero,r2,8113175c <__reset+0xfb11175c>
811317b8:	017fe034 	movhi	r5,65408
811317bc:	297fffc4 	addi	r5,r5,-1
811317c0:	8009883a 	mov	r4,r16
811317c4:	1136a4c0 	call	81136a4c <__lesf2>
811317c8:	103fe70e 	bge	r2,zero,81131768 <__reset+0xfb111768>
811317cc:	01fffc34 	movhi	r7,65520
811317d0:	39ffffc4 	addi	r7,r7,-1
811317d4:	01bfffc4 	movi	r6,-1
811317d8:	9009883a 	mov	r4,r18
811317dc:	880b883a 	mov	r5,r17
811317e0:	1137d400 	call	81137d40 <__ledf2>
811317e4:	103fdd0e 	bge	r2,zero,8113175c <__reset+0xfb11175c>
811317e8:	003fdf06 	br	81131768 <__reset+0xfb111768>

811317ec <_strtoul_r>:
811317ec:	00a04574 	movhi	r2,33045
811317f0:	defff604 	addi	sp,sp,-40
811317f4:	10935e04 	addi	r2,r2,19832
811317f8:	de00012e 	bgeu	sp,et,81131800 <_strtoul_r+0x14>
811317fc:	003b68fa 	trap	3
81131800:	dc800315 	stw	r18,12(sp)
81131804:	14800017 	ldw	r18,0(r2)
81131808:	dd400615 	stw	r21,24(sp)
8113180c:	dd000515 	stw	r20,20(sp)
81131810:	dcc00415 	stw	r19,16(sp)
81131814:	2029883a 	mov	r20,r4
81131818:	dfc00915 	stw	ra,36(sp)
8113181c:	ddc00815 	stw	r23,32(sp)
81131820:	dd800715 	stw	r22,28(sp)
81131824:	dc400215 	stw	r17,8(sp)
81131828:	dc000115 	stw	r16,4(sp)
8113182c:	2827883a 	mov	r19,r5
81131830:	382b883a 	mov	r21,r7
81131834:	2809883a 	mov	r4,r5
81131838:	24000003 	ldbu	r16,0(r4)
8113183c:	24400044 	addi	r17,r4,1
81131840:	2007883a 	mov	r3,r4
81131844:	9405883a 	add	r2,r18,r16
81131848:	10800043 	ldbu	r2,1(r2)
8113184c:	8809883a 	mov	r4,r17
81131850:	1080020c 	andi	r2,r2,8
81131854:	103ff81e 	bne	r2,zero,81131838 <__reset+0xfb111838>
81131858:	00800b44 	movi	r2,45
8113185c:	80805326 	beq	r16,r2,811319ac <_strtoul_r+0x1c0>
81131860:	00800ac4 	movi	r2,43
81131864:	80805526 	beq	r16,r2,811319bc <_strtoul_r+0x1d0>
81131868:	002f883a 	mov	r23,zero
8113186c:	a8000f26 	beq	r21,zero,811318ac <_strtoul_r+0xc0>
81131870:	00800404 	movi	r2,16
81131874:	a8805f26 	beq	r21,r2,811319f4 <_strtoul_r+0x208>
81131878:	013fffc4 	movi	r4,-1
8113187c:	a80b883a 	mov	r5,r21
81131880:	d9800015 	stw	r6,0(sp)
81131884:	113685c0 	call	8113685c <__udivsi3>
81131888:	a80b883a 	mov	r5,r21
8113188c:	013fffc4 	movi	r4,-1
81131890:	102d883a 	mov	r22,r2
81131894:	11368c00 	call	811368c0 <__umodsi3>
81131898:	d9800017 	ldw	r6,0(sp)
8113189c:	1019883a 	mov	r12,r2
811318a0:	a817883a 	mov	r11,r21
811318a4:	b00f883a 	mov	r7,r22
811318a8:	00000706 	br	811318c8 <_strtoul_r+0xdc>
811318ac:	00800c04 	movi	r2,48
811318b0:	80804626 	beq	r16,r2,811319cc <_strtoul_r+0x1e0>
811318b4:	05400284 	movi	r21,10
811318b8:	01c666b4 	movhi	r7,6554
811318bc:	03000144 	movi	r12,5
811318c0:	39e66644 	addi	r7,r7,-26215
811318c4:	a817883a 	mov	r11,r21
811318c8:	9407883a 	add	r3,r18,r16
811318cc:	18c00043 	ldbu	r3,1(r3)
811318d0:	8809883a 	mov	r4,r17
811318d4:	0011883a 	mov	r8,zero
811318d8:	1940010c 	andi	r5,r3,4
811318dc:	0005883a 	mov	r2,zero
811318e0:	02800044 	movi	r10,1
811318e4:	027fffc4 	movi	r9,-1
811318e8:	28000e26 	beq	r5,zero,81131924 <_strtoul_r+0x138>
811318ec:	843ff404 	addi	r16,r16,-48
811318f0:	8540120e 	bge	r16,r21,8113193c <_strtoul_r+0x150>
811318f4:	42400526 	beq	r8,r9,8113190c <_strtoul_r+0x120>
811318f8:	38802236 	bltu	r7,r2,81131984 <_strtoul_r+0x198>
811318fc:	11c02026 	beq	r2,r7,81131980 <_strtoul_r+0x194>
81131900:	12c5383a 	mul	r2,r2,r11
81131904:	02000044 	movi	r8,1
81131908:	8085883a 	add	r2,r16,r2
8113190c:	24000003 	ldbu	r16,0(r4)
81131910:	21000044 	addi	r4,r4,1
81131914:	9407883a 	add	r3,r18,r16
81131918:	18c00043 	ldbu	r3,1(r3)
8113191c:	1940010c 	andi	r5,r3,4
81131920:	283ff21e 	bne	r5,zero,811318ec <__reset+0xfb1118ec>
81131924:	18c000cc 	andi	r3,r3,3
81131928:	18000426 	beq	r3,zero,8113193c <_strtoul_r+0x150>
8113192c:	1a801726 	beq	r3,r10,8113198c <_strtoul_r+0x1a0>
81131930:	00c015c4 	movi	r3,87
81131934:	80e1c83a 	sub	r16,r16,r3
81131938:	857fee16 	blt	r16,r21,811318f4 <__reset+0xfb1118f4>
8113193c:	40001516 	blt	r8,zero,81131994 <_strtoul_r+0x1a8>
81131940:	b8000126 	beq	r23,zero,81131948 <_strtoul_r+0x15c>
81131944:	0085c83a 	sub	r2,zero,r2
81131948:	30000226 	beq	r6,zero,81131954 <_strtoul_r+0x168>
8113194c:	4000151e 	bne	r8,zero,811319a4 <_strtoul_r+0x1b8>
81131950:	34c00015 	stw	r19,0(r6)
81131954:	dfc00917 	ldw	ra,36(sp)
81131958:	ddc00817 	ldw	r23,32(sp)
8113195c:	dd800717 	ldw	r22,28(sp)
81131960:	dd400617 	ldw	r21,24(sp)
81131964:	dd000517 	ldw	r20,20(sp)
81131968:	dcc00417 	ldw	r19,16(sp)
8113196c:	dc800317 	ldw	r18,12(sp)
81131970:	dc400217 	ldw	r17,8(sp)
81131974:	dc000117 	ldw	r16,4(sp)
81131978:	dec00a04 	addi	sp,sp,40
8113197c:	f800283a 	ret
81131980:	643fdf0e 	bge	r12,r16,81131900 <__reset+0xfb111900>
81131984:	023fffc4 	movi	r8,-1
81131988:	003fe006 	br	8113190c <__reset+0xfb11190c>
8113198c:	00c00dc4 	movi	r3,55
81131990:	003fe806 	br	81131934 <__reset+0xfb111934>
81131994:	00800884 	movi	r2,34
81131998:	a0800015 	stw	r2,0(r20)
8113199c:	00bfffc4 	movi	r2,-1
811319a0:	303fec26 	beq	r6,zero,81131954 <__reset+0xfb111954>
811319a4:	24ffffc4 	addi	r19,r4,-1
811319a8:	003fe906 	br	81131950 <__reset+0xfb111950>
811319ac:	1c400084 	addi	r17,r3,2
811319b0:	1c000043 	ldbu	r16,1(r3)
811319b4:	05c00044 	movi	r23,1
811319b8:	003fac06 	br	8113186c <__reset+0xfb11186c>
811319bc:	1c400084 	addi	r17,r3,2
811319c0:	1c000043 	ldbu	r16,1(r3)
811319c4:	002f883a 	mov	r23,zero
811319c8:	003fa806 	br	8113186c <__reset+0xfb11186c>
811319cc:	88800003 	ldbu	r2,0(r17)
811319d0:	00c01604 	movi	r3,88
811319d4:	108037cc 	andi	r2,r2,223
811319d8:	10c00c26 	beq	r2,r3,81131a0c <_strtoul_r+0x220>
811319dc:	05400204 	movi	r21,8
811319e0:	01c80034 	movhi	r7,8192
811319e4:	030001c4 	movi	r12,7
811319e8:	39ffffc4 	addi	r7,r7,-1
811319ec:	a817883a 	mov	r11,r21
811319f0:	003fb506 	br	811318c8 <__reset+0xfb1118c8>
811319f4:	00800c04 	movi	r2,48
811319f8:	80800c1e 	bne	r16,r2,81131a2c <_strtoul_r+0x240>
811319fc:	88800003 	ldbu	r2,0(r17)
81131a00:	00c01604 	movi	r3,88
81131a04:	108037cc 	andi	r2,r2,223
81131a08:	10c0081e 	bne	r2,r3,81131a2c <_strtoul_r+0x240>
81131a0c:	02c00404 	movi	r11,16
81131a10:	05840034 	movhi	r22,4096
81131a14:	8c000043 	ldbu	r16,1(r17)
81131a18:	030003c4 	movi	r12,15
81131a1c:	8c400084 	addi	r17,r17,2
81131a20:	b5bfffc4 	addi	r22,r22,-1
81131a24:	582b883a 	mov	r21,r11
81131a28:	003f9e06 	br	811318a4 <__reset+0xfb1118a4>
81131a2c:	01c40034 	movhi	r7,4096
81131a30:	030003c4 	movi	r12,15
81131a34:	39ffffc4 	addi	r7,r7,-1
81131a38:	a817883a 	mov	r11,r21
81131a3c:	003fa206 	br	811318c8 <__reset+0xfb1118c8>

81131a40 <strtoul>:
81131a40:	00a04574 	movhi	r2,33045
81131a44:	10936004 	addi	r2,r2,19840
81131a48:	300f883a 	mov	r7,r6
81131a4c:	280d883a 	mov	r6,r5
81131a50:	200b883a 	mov	r5,r4
81131a54:	11000017 	ldw	r4,0(r2)
81131a58:	11317ec1 	jmpi	811317ec <_strtoul_r>

81131a5c <_strtoull_r>:
81131a5c:	00a04574 	movhi	r2,33045
81131a60:	defff404 	addi	sp,sp,-48
81131a64:	10935e04 	addi	r2,r2,19832
81131a68:	de00012e 	bgeu	sp,et,81131a70 <_strtoull_r+0x14>
81131a6c:	003b68fa 	trap	3
81131a70:	dc400315 	stw	r17,12(sp)
81131a74:	14400017 	ldw	r17,0(r2)
81131a78:	dd400715 	stw	r21,28(sp)
81131a7c:	dd000615 	stw	r20,24(sp)
81131a80:	dcc00515 	stw	r19,20(sp)
81131a84:	dc800415 	stw	r18,16(sp)
81131a88:	dfc00b15 	stw	ra,44(sp)
81131a8c:	df000a15 	stw	fp,40(sp)
81131a90:	ddc00915 	stw	r23,36(sp)
81131a94:	dd800815 	stw	r22,32(sp)
81131a98:	dc000215 	stw	r16,8(sp)
81131a9c:	2827883a 	mov	r19,r5
81131aa0:	202b883a 	mov	r21,r4
81131aa4:	3029883a 	mov	r20,r6
81131aa8:	3825883a 	mov	r18,r7
81131aac:	2807883a 	mov	r3,r5
81131ab0:	1c000003 	ldbu	r16,0(r3)
81131ab4:	1f000044 	addi	fp,r3,1
81131ab8:	1809883a 	mov	r4,r3
81131abc:	8c05883a 	add	r2,r17,r16
81131ac0:	10800043 	ldbu	r2,1(r2)
81131ac4:	e007883a 	mov	r3,fp
81131ac8:	1080020c 	andi	r2,r2,8
81131acc:	103ff81e 	bne	r2,zero,81131ab0 <__reset+0xfb111ab0>
81131ad0:	00800b44 	movi	r2,45
81131ad4:	80806e26 	beq	r16,r2,81131c90 <_strtoull_r+0x234>
81131ad8:	00800ac4 	movi	r2,43
81131adc:	80807026 	beq	r16,r2,81131ca0 <_strtoull_r+0x244>
81131ae0:	002f883a 	mov	r23,zero
81131ae4:	90001426 	beq	r18,zero,81131b38 <_strtoull_r+0xdc>
81131ae8:	00800404 	movi	r2,16
81131aec:	90807c26 	beq	r18,r2,81131ce0 <_strtoull_r+0x284>
81131af0:	902dd7fa 	srai	r22,r18,31
81131af4:	013fffc4 	movi	r4,-1
81131af8:	200b883a 	mov	r5,r4
81131afc:	900d883a 	mov	r6,r18
81131b00:	b00f883a 	mov	r7,r22
81131b04:	1135ca40 	call	81135ca4 <__udivdi3>
81131b08:	013fffc4 	movi	r4,-1
81131b0c:	900d883a 	mov	r6,r18
81131b10:	b00f883a 	mov	r7,r22
81131b14:	200b883a 	mov	r5,r4
81131b18:	d8c00115 	stw	r3,4(sp)
81131b1c:	d8800015 	stw	r2,0(sp)
81131b20:	11362240 	call	81136224 <__umoddi3>
81131b24:	101b883a 	mov	r13,r2
81131b28:	9015883a 	mov	r10,r18
81131b2c:	dac00017 	ldw	r11,0(sp)
81131b30:	da000117 	ldw	r8,4(sp)
81131b34:	00000a06 	br	81131b60 <_strtoull_r+0x104>
81131b38:	00800c04 	movi	r2,48
81131b3c:	80805c26 	beq	r16,r2,81131cb0 <_strtoull_r+0x254>
81131b40:	02800284 	movi	r10,10
81131b44:	02e666b4 	movhi	r11,39322
81131b48:	020666b4 	movhi	r8,6554
81131b4c:	03400144 	movi	r13,5
81131b50:	5ae66644 	addi	r11,r11,-26215
81131b54:	42266644 	addi	r8,r8,-26215
81131b58:	002d883a 	mov	r22,zero
81131b5c:	5025883a 	mov	r18,r10
81131b60:	8c0b883a 	add	r5,r17,r16
81131b64:	29400043 	ldbu	r5,1(r5)
81131b68:	e009883a 	mov	r4,fp
81131b6c:	000f883a 	mov	r7,zero
81131b70:	2980010c 	andi	r6,r5,4
81131b74:	0005883a 	mov	r2,zero
81131b78:	0007883a 	mov	r3,zero
81131b7c:	03000044 	movi	r12,1
81131b80:	027fffc4 	movi	r9,-1
81131b84:	30000d26 	beq	r6,zero,81131bbc <_strtoull_r+0x160>
81131b88:	843ff404 	addi	r16,r16,-48
81131b8c:	8480110e 	bge	r16,r18,81131bd4 <_strtoull_r+0x178>
81131b90:	3a400426 	beq	r7,r9,81131ba4 <_strtoull_r+0x148>
81131b94:	40c00236 	bltu	r8,r3,81131ba0 <_strtoull_r+0x144>
81131b98:	1a00231e 	bne	r3,r8,81131c28 <_strtoull_r+0x1cc>
81131b9c:	5880222e 	bgeu	r11,r2,81131c28 <_strtoull_r+0x1cc>
81131ba0:	01ffffc4 	movi	r7,-1
81131ba4:	24000003 	ldbu	r16,0(r4)
81131ba8:	21000044 	addi	r4,r4,1
81131bac:	8c0b883a 	add	r5,r17,r16
81131bb0:	29400043 	ldbu	r5,1(r5)
81131bb4:	2980010c 	andi	r6,r5,4
81131bb8:	303ff31e 	bne	r6,zero,81131b88 <__reset+0xfb111b88>
81131bbc:	294000cc 	andi	r5,r5,3
81131bc0:	28000426 	beq	r5,zero,81131bd4 <_strtoull_r+0x178>
81131bc4:	2b002626 	beq	r5,r12,81131c60 <_strtoull_r+0x204>
81131bc8:	014015c4 	movi	r5,87
81131bcc:	8161c83a 	sub	r16,r16,r5
81131bd0:	84bfef16 	blt	r16,r18,81131b90 <__reset+0xfb111b90>
81131bd4:	38002716 	blt	r7,zero,81131c74 <_strtoull_r+0x218>
81131bd8:	b8000426 	beq	r23,zero,81131bec <_strtoull_r+0x190>
81131bdc:	0085c83a 	sub	r2,zero,r2
81131be0:	100ac03a 	cmpne	r5,r2,zero
81131be4:	00e1c83a 	sub	r16,zero,r3
81131be8:	8147c83a 	sub	r3,r16,r5
81131bec:	a0000226 	beq	r20,zero,81131bf8 <_strtoull_r+0x19c>
81131bf0:	3800251e 	bne	r7,zero,81131c88 <_strtoull_r+0x22c>
81131bf4:	a4c00015 	stw	r19,0(r20)
81131bf8:	dfc00b17 	ldw	ra,44(sp)
81131bfc:	df000a17 	ldw	fp,40(sp)
81131c00:	ddc00917 	ldw	r23,36(sp)
81131c04:	dd800817 	ldw	r22,32(sp)
81131c08:	dd400717 	ldw	r21,28(sp)
81131c0c:	dd000617 	ldw	r20,24(sp)
81131c10:	dcc00517 	ldw	r19,20(sp)
81131c14:	dc800417 	ldw	r18,16(sp)
81131c18:	dc400317 	ldw	r17,12(sp)
81131c1c:	dc000217 	ldw	r16,8(sp)
81131c20:	dec00c04 	addi	sp,sp,48
81131c24:	f800283a 	ret
81131c28:	12c00f26 	beq	r2,r11,81131c68 <_strtoull_r+0x20c>
81131c2c:	b08d383a 	mul	r6,r22,r2
81131c30:	1a87383a 	mul	r3,r3,r10
81131c34:	128a383a 	mulxuu	r5,r2,r10
81131c38:	1285383a 	mul	r2,r2,r10
81131c3c:	800fd7fa 	srai	r7,r16,31
81131c40:	1987883a 	add	r3,r3,r6
81131c44:	8085883a 	add	r2,r16,r2
81131c48:	1947883a 	add	r3,r3,r5
81131c4c:	38c7883a 	add	r3,r7,r3
81131c50:	1421803a 	cmpltu	r16,r2,r16
81131c54:	80c7883a 	add	r3,r16,r3
81131c58:	01c00044 	movi	r7,1
81131c5c:	003fd106 	br	81131ba4 <__reset+0xfb111ba4>
81131c60:	01400dc4 	movi	r5,55
81131c64:	003fd906 	br	81131bcc <__reset+0xfb111bcc>
81131c68:	1a3ff01e 	bne	r3,r8,81131c2c <__reset+0xfb111c2c>
81131c6c:	6c3fcc16 	blt	r13,r16,81131ba0 <__reset+0xfb111ba0>
81131c70:	003fee06 	br	81131c2c <__reset+0xfb111c2c>
81131c74:	00800884 	movi	r2,34
81131c78:	a8800015 	stw	r2,0(r21)
81131c7c:	00bfffc4 	movi	r2,-1
81131c80:	1007883a 	mov	r3,r2
81131c84:	a03fdc26 	beq	r20,zero,81131bf8 <__reset+0xfb111bf8>
81131c88:	24ffffc4 	addi	r19,r4,-1
81131c8c:	003fd906 	br	81131bf4 <__reset+0xfb111bf4>
81131c90:	27000084 	addi	fp,r4,2
81131c94:	24000043 	ldbu	r16,1(r4)
81131c98:	05c00044 	movi	r23,1
81131c9c:	003f9106 	br	81131ae4 <__reset+0xfb111ae4>
81131ca0:	27000084 	addi	fp,r4,2
81131ca4:	24000043 	ldbu	r16,1(r4)
81131ca8:	002f883a 	mov	r23,zero
81131cac:	003f8d06 	br	81131ae4 <__reset+0xfb111ae4>
81131cb0:	e0800003 	ldbu	r2,0(fp)
81131cb4:	00c01604 	movi	r3,88
81131cb8:	108037cc 	andi	r2,r2,223
81131cbc:	10c00e26 	beq	r2,r3,81131cf8 <_strtoull_r+0x29c>
81131cc0:	02800204 	movi	r10,8
81131cc4:	02ffffc4 	movi	r11,-1
81131cc8:	02080034 	movhi	r8,8192
81131ccc:	034001c4 	movi	r13,7
81131cd0:	42d1883a 	add	r8,r8,r11
81131cd4:	002d883a 	mov	r22,zero
81131cd8:	5025883a 	mov	r18,r10
81131cdc:	003fa006 	br	81131b60 <__reset+0xfb111b60>
81131ce0:	00800c04 	movi	r2,48
81131ce4:	80800e1e 	bne	r16,r2,81131d20 <_strtoull_r+0x2c4>
81131ce8:	e0800003 	ldbu	r2,0(fp)
81131cec:	00c01604 	movi	r3,88
81131cf0:	108037cc 	andi	r2,r2,223
81131cf4:	10c00a1e 	bne	r2,r3,81131d20 <_strtoull_r+0x2c4>
81131cf8:	02800404 	movi	r10,16
81131cfc:	02ffffc4 	movi	r11,-1
81131d00:	02040034 	movhi	r8,4096
81131d04:	e4000043 	ldbu	r16,1(fp)
81131d08:	034003c4 	movi	r13,15
81131d0c:	e7000084 	addi	fp,fp,2
81131d10:	42d1883a 	add	r8,r8,r11
81131d14:	002d883a 	mov	r22,zero
81131d18:	5025883a 	mov	r18,r10
81131d1c:	003f9006 	br	81131b60 <__reset+0xfb111b60>
81131d20:	02ffffc4 	movi	r11,-1
81131d24:	02040034 	movhi	r8,4096
81131d28:	034003c4 	movi	r13,15
81131d2c:	42d1883a 	add	r8,r8,r11
81131d30:	9015883a 	mov	r10,r18
81131d34:	002d883a 	mov	r22,zero
81131d38:	003f8906 	br	81131b60 <__reset+0xfb111b60>

81131d3c <__ssprint_r>:
81131d3c:	defff604 	addi	sp,sp,-40
81131d40:	de00012e 	bgeu	sp,et,81131d48 <__ssprint_r+0xc>
81131d44:	003b68fa 	trap	3
81131d48:	30800217 	ldw	r2,8(r6)
81131d4c:	dc800215 	stw	r18,8(sp)
81131d50:	dfc00915 	stw	ra,36(sp)
81131d54:	df000815 	stw	fp,32(sp)
81131d58:	ddc00715 	stw	r23,28(sp)
81131d5c:	dd800615 	stw	r22,24(sp)
81131d60:	dd400515 	stw	r21,20(sp)
81131d64:	dd000415 	stw	r20,16(sp)
81131d68:	dcc00315 	stw	r19,12(sp)
81131d6c:	dc400115 	stw	r17,4(sp)
81131d70:	dc000015 	stw	r16,0(sp)
81131d74:	3025883a 	mov	r18,r6
81131d78:	10005826 	beq	r2,zero,81131edc <__ssprint_r+0x1a0>
81131d7c:	2027883a 	mov	r19,r4
81131d80:	35c00017 	ldw	r23,0(r6)
81131d84:	29000017 	ldw	r4,0(r5)
81131d88:	28800217 	ldw	r2,8(r5)
81131d8c:	2823883a 	mov	r17,r5
81131d90:	0039883a 	mov	fp,zero
81131d94:	0021883a 	mov	r16,zero
81131d98:	80003926 	beq	r16,zero,81131e80 <__ssprint_r+0x144>
81131d9c:	102b883a 	mov	r21,r2
81131da0:	102d883a 	mov	r22,r2
81131da4:	80803a36 	bltu	r16,r2,81131e90 <__ssprint_r+0x154>
81131da8:	88c0030b 	ldhu	r3,12(r17)
81131dac:	1881200c 	andi	r2,r3,1152
81131db0:	10002626 	beq	r2,zero,81131e4c <__ssprint_r+0x110>
81131db4:	88800517 	ldw	r2,20(r17)
81131db8:	89400417 	ldw	r5,16(r17)
81131dbc:	81800044 	addi	r6,r16,1
81131dc0:	108f883a 	add	r7,r2,r2
81131dc4:	3885883a 	add	r2,r7,r2
81131dc8:	100ed7fa 	srli	r7,r2,31
81131dcc:	216dc83a 	sub	r22,r4,r5
81131dd0:	3589883a 	add	r4,r6,r22
81131dd4:	3885883a 	add	r2,r7,r2
81131dd8:	102bd07a 	srai	r21,r2,1
81131ddc:	a80d883a 	mov	r6,r21
81131de0:	a900022e 	bgeu	r21,r4,81131dec <__ssprint_r+0xb0>
81131de4:	202b883a 	mov	r21,r4
81131de8:	200d883a 	mov	r6,r4
81131dec:	18c1000c 	andi	r3,r3,1024
81131df0:	18002a26 	beq	r3,zero,81131e9c <__ssprint_r+0x160>
81131df4:	300b883a 	mov	r5,r6
81131df8:	9809883a 	mov	r4,r19
81131dfc:	1123b3c0 	call	81123b3c <_malloc_r>
81131e00:	1029883a 	mov	r20,r2
81131e04:	10002c26 	beq	r2,zero,81131eb8 <__ssprint_r+0x17c>
81131e08:	89400417 	ldw	r5,16(r17)
81131e0c:	b00d883a 	mov	r6,r22
81131e10:	1009883a 	mov	r4,r2
81131e14:	11243500 	call	81124350 <memcpy>
81131e18:	8880030b 	ldhu	r2,12(r17)
81131e1c:	00fedfc4 	movi	r3,-1153
81131e20:	10c4703a 	and	r2,r2,r3
81131e24:	10802014 	ori	r2,r2,128
81131e28:	8880030d 	sth	r2,12(r17)
81131e2c:	a589883a 	add	r4,r20,r22
81131e30:	adadc83a 	sub	r22,r21,r22
81131e34:	8d400515 	stw	r21,20(r17)
81131e38:	8d800215 	stw	r22,8(r17)
81131e3c:	8d000415 	stw	r20,16(r17)
81131e40:	89000015 	stw	r4,0(r17)
81131e44:	802b883a 	mov	r21,r16
81131e48:	802d883a 	mov	r22,r16
81131e4c:	b00d883a 	mov	r6,r22
81131e50:	e00b883a 	mov	r5,fp
81131e54:	112e6ac0 	call	8112e6ac <memmove>
81131e58:	88800217 	ldw	r2,8(r17)
81131e5c:	89000017 	ldw	r4,0(r17)
81131e60:	90c00217 	ldw	r3,8(r18)
81131e64:	1545c83a 	sub	r2,r2,r21
81131e68:	2589883a 	add	r4,r4,r22
81131e6c:	88800215 	stw	r2,8(r17)
81131e70:	89000015 	stw	r4,0(r17)
81131e74:	1c21c83a 	sub	r16,r3,r16
81131e78:	94000215 	stw	r16,8(r18)
81131e7c:	80001726 	beq	r16,zero,81131edc <__ssprint_r+0x1a0>
81131e80:	bf000017 	ldw	fp,0(r23)
81131e84:	bc000117 	ldw	r16,4(r23)
81131e88:	bdc00204 	addi	r23,r23,8
81131e8c:	003fc206 	br	81131d98 <__reset+0xfb111d98>
81131e90:	802b883a 	mov	r21,r16
81131e94:	802d883a 	mov	r22,r16
81131e98:	003fec06 	br	81131e4c <__reset+0xfb111e4c>
81131e9c:	9809883a 	mov	r4,r19
81131ea0:	112f8cc0 	call	8112f8cc <_realloc_r>
81131ea4:	1029883a 	mov	r20,r2
81131ea8:	103fe01e 	bne	r2,zero,81131e2c <__reset+0xfb111e2c>
81131eac:	89400417 	ldw	r5,16(r17)
81131eb0:	9809883a 	mov	r4,r19
81131eb4:	112d8380 	call	8112d838 <_free_r>
81131eb8:	88c0030b 	ldhu	r3,12(r17)
81131ebc:	00800304 	movi	r2,12
81131ec0:	98800015 	stw	r2,0(r19)
81131ec4:	18c01014 	ori	r3,r3,64
81131ec8:	88c0030d 	sth	r3,12(r17)
81131ecc:	00bfffc4 	movi	r2,-1
81131ed0:	90000215 	stw	zero,8(r18)
81131ed4:	90000115 	stw	zero,4(r18)
81131ed8:	00000206 	br	81131ee4 <__ssprint_r+0x1a8>
81131edc:	90000115 	stw	zero,4(r18)
81131ee0:	0005883a 	mov	r2,zero
81131ee4:	dfc00917 	ldw	ra,36(sp)
81131ee8:	df000817 	ldw	fp,32(sp)
81131eec:	ddc00717 	ldw	r23,28(sp)
81131ef0:	dd800617 	ldw	r22,24(sp)
81131ef4:	dd400517 	ldw	r21,20(sp)
81131ef8:	dd000417 	ldw	r20,16(sp)
81131efc:	dcc00317 	ldw	r19,12(sp)
81131f00:	dc800217 	ldw	r18,8(sp)
81131f04:	dc400117 	ldw	r17,4(sp)
81131f08:	dc000017 	ldw	r16,0(sp)
81131f0c:	dec00a04 	addi	sp,sp,40
81131f10:	f800283a 	ret

81131f14 <___svfiprintf_internal_r>:
81131f14:	deffc804 	addi	sp,sp,-224
81131f18:	de00012e 	bgeu	sp,et,81131f20 <___svfiprintf_internal_r+0xc>
81131f1c:	003b68fa 	trap	3
81131f20:	2880030b 	ldhu	r2,12(r5)
81131f24:	dcc03115 	stw	r19,196(sp)
81131f28:	dfc03715 	stw	ra,220(sp)
81131f2c:	df003615 	stw	fp,216(sp)
81131f30:	ddc03515 	stw	r23,212(sp)
81131f34:	dd803415 	stw	r22,208(sp)
81131f38:	dd403315 	stw	r21,204(sp)
81131f3c:	dd003215 	stw	r20,200(sp)
81131f40:	dc803015 	stw	r18,192(sp)
81131f44:	dc402f15 	stw	r17,188(sp)
81131f48:	dc002e15 	stw	r16,184(sp)
81131f4c:	d9402715 	stw	r5,156(sp)
81131f50:	d9002a15 	stw	r4,168(sp)
81131f54:	1080200c 	andi	r2,r2,128
81131f58:	d9c02315 	stw	r7,140(sp)
81131f5c:	3027883a 	mov	r19,r6
81131f60:	10000226 	beq	r2,zero,81131f6c <___svfiprintf_internal_r+0x58>
81131f64:	28800417 	ldw	r2,16(r5)
81131f68:	10041d26 	beq	r2,zero,81132fe0 <___svfiprintf_internal_r+0x10cc>
81131f6c:	dac01a04 	addi	r11,sp,104
81131f70:	dac01e15 	stw	r11,120(sp)
81131f74:	d8801e17 	ldw	r2,120(sp)
81131f78:	dac019c4 	addi	r11,sp,103
81131f7c:	dd402a17 	ldw	r21,168(sp)
81131f80:	ddc02717 	ldw	r23,156(sp)
81131f84:	05a04574 	movhi	r22,33045
81131f88:	05204574 	movhi	r20,33045
81131f8c:	dac01f15 	stw	r11,124(sp)
81131f90:	12d7c83a 	sub	r11,r2,r11
81131f94:	b58a1f04 	addi	r22,r22,10364
81131f98:	a50a1b04 	addi	r20,r20,10348
81131f9c:	dec01a15 	stw	sp,104(sp)
81131fa0:	d8001c15 	stw	zero,112(sp)
81131fa4:	d8001b15 	stw	zero,108(sp)
81131fa8:	d811883a 	mov	r8,sp
81131fac:	d8002915 	stw	zero,164(sp)
81131fb0:	d8002515 	stw	zero,148(sp)
81131fb4:	dac02b15 	stw	r11,172(sp)
81131fb8:	98800007 	ldb	r2,0(r19)
81131fbc:	1002dd26 	beq	r2,zero,81132b34 <___svfiprintf_internal_r+0xc20>
81131fc0:	00c00944 	movi	r3,37
81131fc4:	9823883a 	mov	r17,r19
81131fc8:	10c0021e 	bne	r2,r3,81131fd4 <___svfiprintf_internal_r+0xc0>
81131fcc:	00001406 	br	81132020 <___svfiprintf_internal_r+0x10c>
81131fd0:	10c00326 	beq	r2,r3,81131fe0 <___svfiprintf_internal_r+0xcc>
81131fd4:	8c400044 	addi	r17,r17,1
81131fd8:	88800007 	ldb	r2,0(r17)
81131fdc:	103ffc1e 	bne	r2,zero,81131fd0 <__reset+0xfb111fd0>
81131fe0:	8ce1c83a 	sub	r16,r17,r19
81131fe4:	80000e26 	beq	r16,zero,81132020 <___svfiprintf_internal_r+0x10c>
81131fe8:	d8c01c17 	ldw	r3,112(sp)
81131fec:	d8801b17 	ldw	r2,108(sp)
81131ff0:	44c00015 	stw	r19,0(r8)
81131ff4:	1c07883a 	add	r3,r3,r16
81131ff8:	10800044 	addi	r2,r2,1
81131ffc:	d8c01c15 	stw	r3,112(sp)
81132000:	44000115 	stw	r16,4(r8)
81132004:	d8801b15 	stw	r2,108(sp)
81132008:	00c001c4 	movi	r3,7
8113200c:	18831e16 	blt	r3,r2,81132c88 <___svfiprintf_internal_r+0xd74>
81132010:	42000204 	addi	r8,r8,8
81132014:	dac02517 	ldw	r11,148(sp)
81132018:	5c17883a 	add	r11,r11,r16
8113201c:	dac02515 	stw	r11,148(sp)
81132020:	88800007 	ldb	r2,0(r17)
81132024:	1002c526 	beq	r2,zero,81132b3c <___svfiprintf_internal_r+0xc28>
81132028:	88c00047 	ldb	r3,1(r17)
8113202c:	8cc00044 	addi	r19,r17,1
81132030:	d8001d85 	stb	zero,118(sp)
81132034:	0009883a 	mov	r4,zero
81132038:	000f883a 	mov	r7,zero
8113203c:	043fffc4 	movi	r16,-1
81132040:	d8002415 	stw	zero,144(sp)
81132044:	0025883a 	mov	r18,zero
81132048:	01401604 	movi	r5,88
8113204c:	01800244 	movi	r6,9
81132050:	02800a84 	movi	r10,42
81132054:	02401b04 	movi	r9,108
81132058:	9cc00044 	addi	r19,r19,1
8113205c:	18bff804 	addi	r2,r3,-32
81132060:	2881dd36 	bltu	r5,r2,811327d8 <___svfiprintf_internal_r+0x8c4>
81132064:	100490ba 	slli	r2,r2,2
81132068:	02e044f4 	movhi	r11,33043
8113206c:	5ac81f04 	addi	r11,r11,8316
81132070:	12c5883a 	add	r2,r2,r11
81132074:	10800017 	ldw	r2,0(r2)
81132078:	1000683a 	jmp	r2
8113207c:	81132278 	rdprs	r4,r16,19593
81132080:	811327d8 	cmpnei	r4,r16,19615
81132084:	811327d8 	cmpnei	r4,r16,19615
81132088:	8113226c 	andhi	r4,r16,19593
8113208c:	811327d8 	cmpnei	r4,r16,19615
81132090:	811327d8 	cmpnei	r4,r16,19615
81132094:	811327d8 	cmpnei	r4,r16,19615
81132098:	811327d8 	cmpnei	r4,r16,19615
8113209c:	811327d8 	cmpnei	r4,r16,19615
811320a0:	811327d8 	cmpnei	r4,r16,19615
811320a4:	811321e0 	cmpeqi	r4,r16,19591
811320a8:	811323bc 	xorhi	r4,r16,19598
811320ac:	811327d8 	cmpnei	r4,r16,19615
811320b0:	8113220c 	andi	r4,r16,19592
811320b4:	8113280c 	andi	r4,r16,19616
811320b8:	811327d8 	cmpnei	r4,r16,19615
811320bc:	81132800 	call	88113280 <__reset+0x20f3280>
811320c0:	811327a0 	cmpeqi	r4,r16,19614
811320c4:	811327a0 	cmpeqi	r4,r16,19614
811320c8:	811327a0 	cmpeqi	r4,r16,19614
811320cc:	811327a0 	cmpeqi	r4,r16,19614
811320d0:	811327a0 	cmpeqi	r4,r16,19614
811320d4:	811327a0 	cmpeqi	r4,r16,19614
811320d8:	811327a0 	cmpeqi	r4,r16,19614
811320dc:	811327a0 	cmpeqi	r4,r16,19614
811320e0:	811327a0 	cmpeqi	r4,r16,19614
811320e4:	811327d8 	cmpnei	r4,r16,19615
811320e8:	811327d8 	cmpnei	r4,r16,19615
811320ec:	811327d8 	cmpnei	r4,r16,19615
811320f0:	811327d8 	cmpnei	r4,r16,19615
811320f4:	811327d8 	cmpnei	r4,r16,19615
811320f8:	811327d8 	cmpnei	r4,r16,19615
811320fc:	811327d8 	cmpnei	r4,r16,19615
81132100:	811327d8 	cmpnei	r4,r16,19615
81132104:	811327d8 	cmpnei	r4,r16,19615
81132108:	811327d8 	cmpnei	r4,r16,19615
8113210c:	8113273c 	xorhi	r4,r16,19612
81132110:	811327d8 	cmpnei	r4,r16,19615
81132114:	811327d8 	cmpnei	r4,r16,19615
81132118:	811327d8 	cmpnei	r4,r16,19615
8113211c:	811327d8 	cmpnei	r4,r16,19615
81132120:	811327d8 	cmpnei	r4,r16,19615
81132124:	811327d8 	cmpnei	r4,r16,19615
81132128:	811327d8 	cmpnei	r4,r16,19615
8113212c:	811327d8 	cmpnei	r4,r16,19615
81132130:	811327d8 	cmpnei	r4,r16,19615
81132134:	811327d8 	cmpnei	r4,r16,19615
81132138:	811328b4 	orhi	r4,r16,19618
8113213c:	811327d8 	cmpnei	r4,r16,19615
81132140:	811327d8 	cmpnei	r4,r16,19615
81132144:	811327d8 	cmpnei	r4,r16,19615
81132148:	811327d8 	cmpnei	r4,r16,19615
8113214c:	811327d8 	cmpnei	r4,r16,19615
81132150:	8113284c 	andi	r4,r16,19617
81132154:	811327d8 	cmpnei	r4,r16,19615
81132158:	811327d8 	cmpnei	r4,r16,19615
8113215c:	81132580 	call	88113258 <__reset+0x20f3258>
81132160:	811327d8 	cmpnei	r4,r16,19615
81132164:	811327d8 	cmpnei	r4,r16,19615
81132168:	811327d8 	cmpnei	r4,r16,19615
8113216c:	811327d8 	cmpnei	r4,r16,19615
81132170:	811327d8 	cmpnei	r4,r16,19615
81132174:	811327d8 	cmpnei	r4,r16,19615
81132178:	811327d8 	cmpnei	r4,r16,19615
8113217c:	811327d8 	cmpnei	r4,r16,19615
81132180:	811327d8 	cmpnei	r4,r16,19615
81132184:	811327d8 	cmpnei	r4,r16,19615
81132188:	81132470 	cmpltui	r4,r16,19601
8113218c:	8113261c 	xori	r4,r16,19608
81132190:	811327d8 	cmpnei	r4,r16,19615
81132194:	811327d8 	cmpnei	r4,r16,19615
81132198:	811327d8 	cmpnei	r4,r16,19615
8113219c:	81132610 	cmplti	r4,r16,19608
811321a0:	8113261c 	xori	r4,r16,19608
811321a4:	811327d8 	cmpnei	r4,r16,19615
811321a8:	811327d8 	cmpnei	r4,r16,19615
811321ac:	81132600 	call	88113260 <__reset+0x20f3260>
811321b0:	811327d8 	cmpnei	r4,r16,19615
811321b4:	811325c4 	addi	r4,r16,19607
811321b8:	811323cc 	andi	r4,r16,19599
811321bc:	81132218 	cmpnei	r4,r16,19592
811321c0:	81132730 	cmpltui	r4,r16,19612
811321c4:	811327d8 	cmpnei	r4,r16,19615
811321c8:	811326e4 	muli	r4,r16,19611
811321cc:	811327d8 	cmpnei	r4,r16,19615
811321d0:	8113233c 	xorhi	r4,r16,19596
811321d4:	811327d8 	cmpnei	r4,r16,19615
811321d8:	811327d8 	cmpnei	r4,r16,19615
811321dc:	81132298 	cmpnei	r4,r16,19594
811321e0:	dac02317 	ldw	r11,140(sp)
811321e4:	5ac00017 	ldw	r11,0(r11)
811321e8:	dac02415 	stw	r11,144(sp)
811321ec:	dac02317 	ldw	r11,140(sp)
811321f0:	58800104 	addi	r2,r11,4
811321f4:	dac02417 	ldw	r11,144(sp)
811321f8:	5802e90e 	bge	r11,zero,81132da0 <___svfiprintf_internal_r+0xe8c>
811321fc:	dac02417 	ldw	r11,144(sp)
81132200:	d8802315 	stw	r2,140(sp)
81132204:	02d7c83a 	sub	r11,zero,r11
81132208:	dac02415 	stw	r11,144(sp)
8113220c:	94800114 	ori	r18,r18,4
81132210:	98c00007 	ldb	r3,0(r19)
81132214:	003f9006 	br	81132058 <__reset+0xfb112058>
81132218:	00800c04 	movi	r2,48
8113221c:	dac02317 	ldw	r11,140(sp)
81132220:	d8801d05 	stb	r2,116(sp)
81132224:	00801e04 	movi	r2,120
81132228:	d8801d45 	stb	r2,117(sp)
8113222c:	d8001d85 	stb	zero,118(sp)
81132230:	58c00104 	addi	r3,r11,4
81132234:	5f000017 	ldw	fp,0(r11)
81132238:	0013883a 	mov	r9,zero
8113223c:	90800094 	ori	r2,r18,2
81132240:	80032b16 	blt	r16,zero,81132ef0 <___svfiprintf_internal_r+0xfdc>
81132244:	00bfdfc4 	movi	r2,-129
81132248:	90a4703a 	and	r18,r18,r2
8113224c:	d8c02315 	stw	r3,140(sp)
81132250:	94800094 	ori	r18,r18,2
81132254:	e002dc26 	beq	fp,zero,81132dc8 <___svfiprintf_internal_r+0xeb4>
81132258:	01204574 	movhi	r4,33045
8113225c:	21099104 	addi	r4,r4,9796
81132260:	0015883a 	mov	r10,zero
81132264:	d9002915 	stw	r4,164(sp)
81132268:	00002306 	br	811322f8 <___svfiprintf_internal_r+0x3e4>
8113226c:	94800054 	ori	r18,r18,1
81132270:	98c00007 	ldb	r3,0(r19)
81132274:	003f7806 	br	81132058 <__reset+0xfb112058>
81132278:	38803fcc 	andi	r2,r7,255
8113227c:	1080201c 	xori	r2,r2,128
81132280:	10bfe004 	addi	r2,r2,-128
81132284:	1002f31e 	bne	r2,zero,81132e54 <___svfiprintf_internal_r+0xf40>
81132288:	01000044 	movi	r4,1
8113228c:	01c00804 	movi	r7,32
81132290:	98c00007 	ldb	r3,0(r19)
81132294:	003f7006 	br	81132058 <__reset+0xfb112058>
81132298:	21003fcc 	andi	r4,r4,255
8113229c:	2003aa1e 	bne	r4,zero,81133148 <___svfiprintf_internal_r+0x1234>
811322a0:	00a04574 	movhi	r2,33045
811322a4:	10899104 	addi	r2,r2,9796
811322a8:	d8802915 	stw	r2,164(sp)
811322ac:	9080080c 	andi	r2,r18,32
811322b0:	1000ba26 	beq	r2,zero,8113259c <___svfiprintf_internal_r+0x688>
811322b4:	dac02317 	ldw	r11,140(sp)
811322b8:	5f000017 	ldw	fp,0(r11)
811322bc:	5a400117 	ldw	r9,4(r11)
811322c0:	5ac00204 	addi	r11,r11,8
811322c4:	dac02315 	stw	r11,140(sp)
811322c8:	9080004c 	andi	r2,r18,1
811322cc:	10029026 	beq	r2,zero,81132d10 <___svfiprintf_internal_r+0xdfc>
811322d0:	e244b03a 	or	r2,fp,r9
811322d4:	1002d41e 	bne	r2,zero,81132e28 <___svfiprintf_internal_r+0xf14>
811322d8:	d8001d85 	stb	zero,118(sp)
811322dc:	80030b16 	blt	r16,zero,81132f0c <___svfiprintf_internal_r+0xff8>
811322e0:	00bfdfc4 	movi	r2,-129
811322e4:	90a4703a 	and	r18,r18,r2
811322e8:	0015883a 	mov	r10,zero
811322ec:	80002426 	beq	r16,zero,81132380 <___svfiprintf_internal_r+0x46c>
811322f0:	0039883a 	mov	fp,zero
811322f4:	0013883a 	mov	r9,zero
811322f8:	d9002917 	ldw	r4,164(sp)
811322fc:	dc401a04 	addi	r17,sp,104
81132300:	e08003cc 	andi	r2,fp,15
81132304:	4806973a 	slli	r3,r9,28
81132308:	2085883a 	add	r2,r4,r2
8113230c:	e038d13a 	srli	fp,fp,4
81132310:	10800003 	ldbu	r2,0(r2)
81132314:	4812d13a 	srli	r9,r9,4
81132318:	8c7fffc4 	addi	r17,r17,-1
8113231c:	1f38b03a 	or	fp,r3,fp
81132320:	88800005 	stb	r2,0(r17)
81132324:	e244b03a 	or	r2,fp,r9
81132328:	103ff51e 	bne	r2,zero,81132300 <__reset+0xfb112300>
8113232c:	dac01e17 	ldw	r11,120(sp)
81132330:	5c57c83a 	sub	r11,r11,r17
81132334:	dac02115 	stw	r11,132(sp)
81132338:	00001406 	br	8113238c <___svfiprintf_internal_r+0x478>
8113233c:	21003fcc 	andi	r4,r4,255
81132340:	2003741e 	bne	r4,zero,81133114 <___svfiprintf_internal_r+0x1200>
81132344:	9080080c 	andi	r2,r18,32
81132348:	10014526 	beq	r2,zero,81132860 <___svfiprintf_internal_r+0x94c>
8113234c:	dac02317 	ldw	r11,140(sp)
81132350:	d8001d85 	stb	zero,118(sp)
81132354:	58c00204 	addi	r3,r11,8
81132358:	5f000017 	ldw	fp,0(r11)
8113235c:	5a400117 	ldw	r9,4(r11)
81132360:	8002d916 	blt	r16,zero,81132ec8 <___svfiprintf_internal_r+0xfb4>
81132364:	013fdfc4 	movi	r4,-129
81132368:	e244b03a 	or	r2,fp,r9
8113236c:	d8c02315 	stw	r3,140(sp)
81132370:	9124703a 	and	r18,r18,r4
81132374:	0015883a 	mov	r10,zero
81132378:	1000b91e 	bne	r2,zero,81132660 <___svfiprintf_internal_r+0x74c>
8113237c:	8002e61e 	bne	r16,zero,81132f18 <___svfiprintf_internal_r+0x1004>
81132380:	0021883a 	mov	r16,zero
81132384:	d8002115 	stw	zero,132(sp)
81132388:	dc401a04 	addi	r17,sp,104
8113238c:	d8c02117 	ldw	r3,132(sp)
81132390:	dc002015 	stw	r16,128(sp)
81132394:	80c0010e 	bge	r16,r3,8113239c <___svfiprintf_internal_r+0x488>
81132398:	d8c02015 	stw	r3,128(sp)
8113239c:	52803fcc 	andi	r10,r10,255
811323a0:	5280201c 	xori	r10,r10,128
811323a4:	52bfe004 	addi	r10,r10,-128
811323a8:	50003c26 	beq	r10,zero,8113249c <___svfiprintf_internal_r+0x588>
811323ac:	dac02017 	ldw	r11,128(sp)
811323b0:	5ac00044 	addi	r11,r11,1
811323b4:	dac02015 	stw	r11,128(sp)
811323b8:	00003806 	br	8113249c <___svfiprintf_internal_r+0x588>
811323bc:	01000044 	movi	r4,1
811323c0:	01c00ac4 	movi	r7,43
811323c4:	98c00007 	ldb	r3,0(r19)
811323c8:	003f2306 	br	81132058 <__reset+0xfb112058>
811323cc:	21003fcc 	andi	r4,r4,255
811323d0:	2003481e 	bne	r4,zero,811330f4 <___svfiprintf_internal_r+0x11e0>
811323d4:	9080080c 	andi	r2,r18,32
811323d8:	10013b26 	beq	r2,zero,811328c8 <___svfiprintf_internal_r+0x9b4>
811323dc:	dac02317 	ldw	r11,140(sp)
811323e0:	d8001d85 	stb	zero,118(sp)
811323e4:	58800204 	addi	r2,r11,8
811323e8:	5f000017 	ldw	fp,0(r11)
811323ec:	5a400117 	ldw	r9,4(r11)
811323f0:	8002a816 	blt	r16,zero,81132e94 <___svfiprintf_internal_r+0xf80>
811323f4:	013fdfc4 	movi	r4,-129
811323f8:	e246b03a 	or	r3,fp,r9
811323fc:	d8802315 	stw	r2,140(sp)
81132400:	9124703a 	and	r18,r18,r4
81132404:	18013c26 	beq	r3,zero,811328f8 <___svfiprintf_internal_r+0x9e4>
81132408:	0015883a 	mov	r10,zero
8113240c:	dc401a04 	addi	r17,sp,104
81132410:	e006d0fa 	srli	r3,fp,3
81132414:	4808977a 	slli	r4,r9,29
81132418:	4812d0fa 	srli	r9,r9,3
8113241c:	e70001cc 	andi	fp,fp,7
81132420:	e0800c04 	addi	r2,fp,48
81132424:	8c7fffc4 	addi	r17,r17,-1
81132428:	20f8b03a 	or	fp,r4,r3
8113242c:	88800005 	stb	r2,0(r17)
81132430:	e246b03a 	or	r3,fp,r9
81132434:	183ff61e 	bne	r3,zero,81132410 <__reset+0xfb112410>
81132438:	90c0004c 	andi	r3,r18,1
8113243c:	1800a526 	beq	r3,zero,811326d4 <___svfiprintf_internal_r+0x7c0>
81132440:	10803fcc 	andi	r2,r2,255
81132444:	1080201c 	xori	r2,r2,128
81132448:	10bfe004 	addi	r2,r2,-128
8113244c:	00c00c04 	movi	r3,48
81132450:	10ffb626 	beq	r2,r3,8113232c <__reset+0xfb11232c>
81132454:	88ffffc5 	stb	r3,-1(r17)
81132458:	d8c01e17 	ldw	r3,120(sp)
8113245c:	88bfffc4 	addi	r2,r17,-1
81132460:	1023883a 	mov	r17,r2
81132464:	1887c83a 	sub	r3,r3,r2
81132468:	d8c02115 	stw	r3,132(sp)
8113246c:	003fc706 	br	8113238c <__reset+0xfb11238c>
81132470:	dac02317 	ldw	r11,140(sp)
81132474:	00c00044 	movi	r3,1
81132478:	d8c02015 	stw	r3,128(sp)
8113247c:	58800017 	ldw	r2,0(r11)
81132480:	5ac00104 	addi	r11,r11,4
81132484:	d8001d85 	stb	zero,118(sp)
81132488:	d8801005 	stb	r2,64(sp)
8113248c:	dac02315 	stw	r11,140(sp)
81132490:	d8c02115 	stw	r3,132(sp)
81132494:	dc401004 	addi	r17,sp,64
81132498:	0021883a 	mov	r16,zero
8113249c:	90c0008c 	andi	r3,r18,2
811324a0:	d8c02215 	stw	r3,136(sp)
811324a4:	18000326 	beq	r3,zero,811324b4 <___svfiprintf_internal_r+0x5a0>
811324a8:	dac02017 	ldw	r11,128(sp)
811324ac:	5ac00084 	addi	r11,r11,2
811324b0:	dac02015 	stw	r11,128(sp)
811324b4:	90c0210c 	andi	r3,r18,132
811324b8:	d8c02615 	stw	r3,152(sp)
811324bc:	1801131e 	bne	r3,zero,8113290c <___svfiprintf_internal_r+0x9f8>
811324c0:	dac02417 	ldw	r11,144(sp)
811324c4:	d8c02017 	ldw	r3,128(sp)
811324c8:	58f9c83a 	sub	fp,r11,r3
811324cc:	07010f0e 	bge	zero,fp,8113290c <___svfiprintf_internal_r+0x9f8>
811324d0:	02400404 	movi	r9,16
811324d4:	d8c01c17 	ldw	r3,112(sp)
811324d8:	d8801b17 	ldw	r2,108(sp)
811324dc:	4f02d60e 	bge	r9,fp,81133038 <___svfiprintf_internal_r+0x1124>
811324e0:	01604574 	movhi	r5,33045
811324e4:	294a1f04 	addi	r5,r5,10364
811324e8:	d9402815 	stw	r5,160(sp)
811324ec:	028001c4 	movi	r10,7
811324f0:	00000306 	br	81132500 <___svfiprintf_internal_r+0x5ec>
811324f4:	e73ffc04 	addi	fp,fp,-16
811324f8:	42000204 	addi	r8,r8,8
811324fc:	4f00150e 	bge	r9,fp,81132554 <___svfiprintf_internal_r+0x640>
81132500:	18c00404 	addi	r3,r3,16
81132504:	10800044 	addi	r2,r2,1
81132508:	45800015 	stw	r22,0(r8)
8113250c:	42400115 	stw	r9,4(r8)
81132510:	d8c01c15 	stw	r3,112(sp)
81132514:	d8801b15 	stw	r2,108(sp)
81132518:	50bff60e 	bge	r10,r2,811324f4 <__reset+0xfb1124f4>
8113251c:	d9801a04 	addi	r6,sp,104
81132520:	b80b883a 	mov	r5,r23
81132524:	a809883a 	mov	r4,r21
81132528:	da402c15 	stw	r9,176(sp)
8113252c:	da802d15 	stw	r10,180(sp)
81132530:	1131d3c0 	call	81131d3c <__ssprint_r>
81132534:	da402c17 	ldw	r9,176(sp)
81132538:	da802d17 	ldw	r10,180(sp)
8113253c:	1001851e 	bne	r2,zero,81132b54 <___svfiprintf_internal_r+0xc40>
81132540:	e73ffc04 	addi	fp,fp,-16
81132544:	d8c01c17 	ldw	r3,112(sp)
81132548:	d8801b17 	ldw	r2,108(sp)
8113254c:	d811883a 	mov	r8,sp
81132550:	4f3feb16 	blt	r9,fp,81132500 <__reset+0xfb112500>
81132554:	dac02817 	ldw	r11,160(sp)
81132558:	e0c7883a 	add	r3,fp,r3
8113255c:	10800044 	addi	r2,r2,1
81132560:	42c00015 	stw	r11,0(r8)
81132564:	47000115 	stw	fp,4(r8)
81132568:	d8c01c15 	stw	r3,112(sp)
8113256c:	d8801b15 	stw	r2,108(sp)
81132570:	010001c4 	movi	r4,7
81132574:	2081ee16 	blt	r4,r2,81132d30 <___svfiprintf_internal_r+0xe1c>
81132578:	42000204 	addi	r8,r8,8
8113257c:	0000e506 	br	81132914 <___svfiprintf_internal_r+0xa00>
81132580:	21003fcc 	andi	r4,r4,255
81132584:	2002dd1e 	bne	r4,zero,811330fc <___svfiprintf_internal_r+0x11e8>
81132588:	00a04574 	movhi	r2,33045
8113258c:	10898c04 	addi	r2,r2,9776
81132590:	d8802915 	stw	r2,164(sp)
81132594:	9080080c 	andi	r2,r18,32
81132598:	103f461e 	bne	r2,zero,811322b4 <__reset+0xfb1122b4>
8113259c:	9080040c 	andi	r2,r18,16
811325a0:	10022e1e 	bne	r2,zero,81132e5c <___svfiprintf_internal_r+0xf48>
811325a4:	9080100c 	andi	r2,r18,64
811325a8:	dac02317 	ldw	r11,140(sp)
811325ac:	10027326 	beq	r2,zero,81132f7c <___svfiprintf_internal_r+0x1068>
811325b0:	5f00000b 	ldhu	fp,0(r11)
811325b4:	5ac00104 	addi	r11,r11,4
811325b8:	0013883a 	mov	r9,zero
811325bc:	dac02315 	stw	r11,140(sp)
811325c0:	003f4106 	br	811322c8 <__reset+0xfb1122c8>
811325c4:	21003fcc 	andi	r4,r4,255
811325c8:	2002e11e 	bne	r4,zero,81133150 <___svfiprintf_internal_r+0x123c>
811325cc:	9080080c 	andi	r2,r18,32
811325d0:	1002011e 	bne	r2,zero,81132dd8 <___svfiprintf_internal_r+0xec4>
811325d4:	9080040c 	andi	r2,r18,16
811325d8:	10023e1e 	bne	r2,zero,81132ed4 <___svfiprintf_internal_r+0xfc0>
811325dc:	9480100c 	andi	r18,r18,64
811325e0:	90023c26 	beq	r18,zero,81132ed4 <___svfiprintf_internal_r+0xfc0>
811325e4:	dac02317 	ldw	r11,140(sp)
811325e8:	58800017 	ldw	r2,0(r11)
811325ec:	5ac00104 	addi	r11,r11,4
811325f0:	dac02315 	stw	r11,140(sp)
811325f4:	dac02517 	ldw	r11,148(sp)
811325f8:	12c0000d 	sth	r11,0(r2)
811325fc:	003e6e06 	br	81131fb8 <__reset+0xfb111fb8>
81132600:	98c00007 	ldb	r3,0(r19)
81132604:	1a422926 	beq	r3,r9,81132eac <___svfiprintf_internal_r+0xf98>
81132608:	94800414 	ori	r18,r18,16
8113260c:	003e9206 	br	81132058 <__reset+0xfb112058>
81132610:	94801014 	ori	r18,r18,64
81132614:	98c00007 	ldb	r3,0(r19)
81132618:	003e8f06 	br	81132058 <__reset+0xfb112058>
8113261c:	21003fcc 	andi	r4,r4,255
81132620:	2002c71e 	bne	r4,zero,81133140 <___svfiprintf_internal_r+0x122c>
81132624:	9080080c 	andi	r2,r18,32
81132628:	10004926 	beq	r2,zero,81132750 <___svfiprintf_internal_r+0x83c>
8113262c:	dac02317 	ldw	r11,140(sp)
81132630:	58800117 	ldw	r2,4(r11)
81132634:	5f000017 	ldw	fp,0(r11)
81132638:	5ac00204 	addi	r11,r11,8
8113263c:	dac02315 	stw	r11,140(sp)
81132640:	1013883a 	mov	r9,r2
81132644:	10004b16 	blt	r2,zero,81132774 <___svfiprintf_internal_r+0x860>
81132648:	da801d83 	ldbu	r10,118(sp)
8113264c:	8001cb16 	blt	r16,zero,81132d7c <___svfiprintf_internal_r+0xe68>
81132650:	00ffdfc4 	movi	r3,-129
81132654:	e244b03a 	or	r2,fp,r9
81132658:	90e4703a 	and	r18,r18,r3
8113265c:	103f4726 	beq	r2,zero,8113237c <__reset+0xfb11237c>
81132660:	48008c26 	beq	r9,zero,81132894 <___svfiprintf_internal_r+0x980>
81132664:	dc802015 	stw	r18,128(sp)
81132668:	dc002115 	stw	r16,132(sp)
8113266c:	dc401a04 	addi	r17,sp,104
81132670:	e021883a 	mov	r16,fp
81132674:	da002215 	stw	r8,136(sp)
81132678:	5039883a 	mov	fp,r10
8113267c:	4825883a 	mov	r18,r9
81132680:	8009883a 	mov	r4,r16
81132684:	900b883a 	mov	r5,r18
81132688:	01800284 	movi	r6,10
8113268c:	000f883a 	mov	r7,zero
81132690:	11362240 	call	81136224 <__umoddi3>
81132694:	10800c04 	addi	r2,r2,48
81132698:	8c7fffc4 	addi	r17,r17,-1
8113269c:	8009883a 	mov	r4,r16
811326a0:	900b883a 	mov	r5,r18
811326a4:	88800005 	stb	r2,0(r17)
811326a8:	01800284 	movi	r6,10
811326ac:	000f883a 	mov	r7,zero
811326b0:	1135ca40 	call	81135ca4 <__udivdi3>
811326b4:	1021883a 	mov	r16,r2
811326b8:	10c4b03a 	or	r2,r2,r3
811326bc:	1825883a 	mov	r18,r3
811326c0:	103fef1e 	bne	r2,zero,81132680 <__reset+0xfb112680>
811326c4:	dc802017 	ldw	r18,128(sp)
811326c8:	dc002117 	ldw	r16,132(sp)
811326cc:	da002217 	ldw	r8,136(sp)
811326d0:	e015883a 	mov	r10,fp
811326d4:	d8c01e17 	ldw	r3,120(sp)
811326d8:	1c47c83a 	sub	r3,r3,r17
811326dc:	d8c02115 	stw	r3,132(sp)
811326e0:	003f2a06 	br	8113238c <__reset+0xfb11238c>
811326e4:	dac02317 	ldw	r11,140(sp)
811326e8:	d8001d85 	stb	zero,118(sp)
811326ec:	5c400017 	ldw	r17,0(r11)
811326f0:	5f000104 	addi	fp,r11,4
811326f4:	88022f26 	beq	r17,zero,81132fb4 <___svfiprintf_internal_r+0x10a0>
811326f8:	80022516 	blt	r16,zero,81132f90 <___svfiprintf_internal_r+0x107c>
811326fc:	800d883a 	mov	r6,r16
81132700:	000b883a 	mov	r5,zero
81132704:	8809883a 	mov	r4,r17
81132708:	da002c15 	stw	r8,176(sp)
8113270c:	112e5c80 	call	8112e5c8 <memchr>
81132710:	da002c17 	ldw	r8,176(sp)
81132714:	10026426 	beq	r2,zero,811330a8 <___svfiprintf_internal_r+0x1194>
81132718:	1445c83a 	sub	r2,r2,r17
8113271c:	d8802115 	stw	r2,132(sp)
81132720:	da801d83 	ldbu	r10,118(sp)
81132724:	df002315 	stw	fp,140(sp)
81132728:	0021883a 	mov	r16,zero
8113272c:	003f1706 	br	8113238c <__reset+0xfb11238c>
81132730:	94800814 	ori	r18,r18,32
81132734:	98c00007 	ldb	r3,0(r19)
81132738:	003e4706 	br	81132058 <__reset+0xfb112058>
8113273c:	21003fcc 	andi	r4,r4,255
81132740:	2002701e 	bne	r4,zero,81133104 <___svfiprintf_internal_r+0x11f0>
81132744:	94800414 	ori	r18,r18,16
81132748:	9080080c 	andi	r2,r18,32
8113274c:	103fb71e 	bne	r2,zero,8113262c <__reset+0xfb11262c>
81132750:	9080040c 	andi	r2,r18,16
81132754:	1001ab26 	beq	r2,zero,81132e04 <___svfiprintf_internal_r+0xef0>
81132758:	dac02317 	ldw	r11,140(sp)
8113275c:	5f000017 	ldw	fp,0(r11)
81132760:	5ac00104 	addi	r11,r11,4
81132764:	dac02315 	stw	r11,140(sp)
81132768:	e013d7fa 	srai	r9,fp,31
8113276c:	4805883a 	mov	r2,r9
81132770:	103fb50e 	bge	r2,zero,81132648 <__reset+0xfb112648>
81132774:	0739c83a 	sub	fp,zero,fp
81132778:	02800b44 	movi	r10,45
8113277c:	e004c03a 	cmpne	r2,fp,zero
81132780:	0253c83a 	sub	r9,zero,r9
81132784:	da801d85 	stb	r10,118(sp)
81132788:	4893c83a 	sub	r9,r9,r2
8113278c:	80023016 	blt	r16,zero,81133050 <___svfiprintf_internal_r+0x113c>
81132790:	00bfdfc4 	movi	r2,-129
81132794:	90a4703a 	and	r18,r18,r2
81132798:	483fb21e 	bne	r9,zero,81132664 <__reset+0xfb112664>
8113279c:	00003d06 	br	81132894 <___svfiprintf_internal_r+0x980>
811327a0:	9817883a 	mov	r11,r19
811327a4:	d8002415 	stw	zero,144(sp)
811327a8:	18bff404 	addi	r2,r3,-48
811327ac:	0019883a 	mov	r12,zero
811327b0:	58c00007 	ldb	r3,0(r11)
811327b4:	630002a4 	muli	r12,r12,10
811327b8:	9cc00044 	addi	r19,r19,1
811327bc:	9817883a 	mov	r11,r19
811327c0:	1319883a 	add	r12,r2,r12
811327c4:	18bff404 	addi	r2,r3,-48
811327c8:	30bff92e 	bgeu	r6,r2,811327b0 <__reset+0xfb1127b0>
811327cc:	db002415 	stw	r12,144(sp)
811327d0:	18bff804 	addi	r2,r3,-32
811327d4:	28be232e 	bgeu	r5,r2,81132064 <__reset+0xfb112064>
811327d8:	21003fcc 	andi	r4,r4,255
811327dc:	20024b1e 	bne	r4,zero,8113310c <___svfiprintf_internal_r+0x11f8>
811327e0:	1800d626 	beq	r3,zero,81132b3c <___svfiprintf_internal_r+0xc28>
811327e4:	02c00044 	movi	r11,1
811327e8:	dac02015 	stw	r11,128(sp)
811327ec:	d8c01005 	stb	r3,64(sp)
811327f0:	d8001d85 	stb	zero,118(sp)
811327f4:	dac02115 	stw	r11,132(sp)
811327f8:	dc401004 	addi	r17,sp,64
811327fc:	003f2606 	br	81132498 <__reset+0xfb112498>
81132800:	94802014 	ori	r18,r18,128
81132804:	98c00007 	ldb	r3,0(r19)
81132808:	003e1306 	br	81132058 <__reset+0xfb112058>
8113280c:	98c00007 	ldb	r3,0(r19)
81132810:	9ac00044 	addi	r11,r19,1
81132814:	1a822b26 	beq	r3,r10,811330c4 <___svfiprintf_internal_r+0x11b0>
81132818:	18bff404 	addi	r2,r3,-48
8113281c:	0021883a 	mov	r16,zero
81132820:	30821e36 	bltu	r6,r2,8113309c <___svfiprintf_internal_r+0x1188>
81132824:	58c00007 	ldb	r3,0(r11)
81132828:	840002a4 	muli	r16,r16,10
8113282c:	5cc00044 	addi	r19,r11,1
81132830:	9817883a 	mov	r11,r19
81132834:	80a1883a 	add	r16,r16,r2
81132838:	18bff404 	addi	r2,r3,-48
8113283c:	30bff92e 	bgeu	r6,r2,81132824 <__reset+0xfb112824>
81132840:	803e060e 	bge	r16,zero,8113205c <__reset+0xfb11205c>
81132844:	043fffc4 	movi	r16,-1
81132848:	003e0406 	br	8113205c <__reset+0xfb11205c>
8113284c:	21003fcc 	andi	r4,r4,255
81132850:	2002371e 	bne	r4,zero,81133130 <___svfiprintf_internal_r+0x121c>
81132854:	94800414 	ori	r18,r18,16
81132858:	9080080c 	andi	r2,r18,32
8113285c:	103ebb1e 	bne	r2,zero,8113234c <__reset+0xfb11234c>
81132860:	9080040c 	andi	r2,r18,16
81132864:	10013b26 	beq	r2,zero,81132d54 <___svfiprintf_internal_r+0xe40>
81132868:	dac02317 	ldw	r11,140(sp)
8113286c:	d8001d85 	stb	zero,118(sp)
81132870:	0013883a 	mov	r9,zero
81132874:	58800104 	addi	r2,r11,4
81132878:	5f000017 	ldw	fp,0(r11)
8113287c:	80013d16 	blt	r16,zero,81132d74 <___svfiprintf_internal_r+0xe60>
81132880:	00ffdfc4 	movi	r3,-129
81132884:	d8802315 	stw	r2,140(sp)
81132888:	90e4703a 	and	r18,r18,r3
8113288c:	0015883a 	mov	r10,zero
81132890:	e03eba26 	beq	fp,zero,8113237c <__reset+0xfb11237c>
81132894:	00800244 	movi	r2,9
81132898:	173f7236 	bltu	r2,fp,81132664 <__reset+0xfb112664>
8113289c:	dac02b17 	ldw	r11,172(sp)
811328a0:	e7000c04 	addi	fp,fp,48
811328a4:	df0019c5 	stb	fp,103(sp)
811328a8:	dac02115 	stw	r11,132(sp)
811328ac:	dc4019c4 	addi	r17,sp,103
811328b0:	003eb606 	br	8113238c <__reset+0xfb11238c>
811328b4:	21003fcc 	andi	r4,r4,255
811328b8:	20021f1e 	bne	r4,zero,81133138 <___svfiprintf_internal_r+0x1224>
811328bc:	94800414 	ori	r18,r18,16
811328c0:	9080080c 	andi	r2,r18,32
811328c4:	103ec51e 	bne	r2,zero,811323dc <__reset+0xfb1123dc>
811328c8:	9080040c 	andi	r2,r18,16
811328cc:	10016926 	beq	r2,zero,81132e74 <___svfiprintf_internal_r+0xf60>
811328d0:	dac02317 	ldw	r11,140(sp)
811328d4:	d8001d85 	stb	zero,118(sp)
811328d8:	0013883a 	mov	r9,zero
811328dc:	58800104 	addi	r2,r11,4
811328e0:	5f000017 	ldw	fp,0(r11)
811328e4:	80016b16 	blt	r16,zero,81132e94 <___svfiprintf_internal_r+0xf80>
811328e8:	00ffdfc4 	movi	r3,-129
811328ec:	d8802315 	stw	r2,140(sp)
811328f0:	90e4703a 	and	r18,r18,r3
811328f4:	e03ec41e 	bne	fp,zero,81132408 <__reset+0xfb112408>
811328f8:	0015883a 	mov	r10,zero
811328fc:	8001c226 	beq	r16,zero,81133008 <___svfiprintf_internal_r+0x10f4>
81132900:	0039883a 	mov	fp,zero
81132904:	0013883a 	mov	r9,zero
81132908:	003ec006 	br	8113240c <__reset+0xfb11240c>
8113290c:	d8c01c17 	ldw	r3,112(sp)
81132910:	d8801b17 	ldw	r2,108(sp)
81132914:	d9001d87 	ldb	r4,118(sp)
81132918:	20000b26 	beq	r4,zero,81132948 <___svfiprintf_internal_r+0xa34>
8113291c:	d9001d84 	addi	r4,sp,118
81132920:	18c00044 	addi	r3,r3,1
81132924:	10800044 	addi	r2,r2,1
81132928:	41000015 	stw	r4,0(r8)
8113292c:	01000044 	movi	r4,1
81132930:	41000115 	stw	r4,4(r8)
81132934:	d8c01c15 	stw	r3,112(sp)
81132938:	d8801b15 	stw	r2,108(sp)
8113293c:	010001c4 	movi	r4,7
81132940:	2080e116 	blt	r4,r2,81132cc8 <___svfiprintf_internal_r+0xdb4>
81132944:	42000204 	addi	r8,r8,8
81132948:	dac02217 	ldw	r11,136(sp)
8113294c:	58000b26 	beq	r11,zero,8113297c <___svfiprintf_internal_r+0xa68>
81132950:	d9001d04 	addi	r4,sp,116
81132954:	18c00084 	addi	r3,r3,2
81132958:	10800044 	addi	r2,r2,1
8113295c:	41000015 	stw	r4,0(r8)
81132960:	01000084 	movi	r4,2
81132964:	41000115 	stw	r4,4(r8)
81132968:	d8c01c15 	stw	r3,112(sp)
8113296c:	d8801b15 	stw	r2,108(sp)
81132970:	010001c4 	movi	r4,7
81132974:	2080dd16 	blt	r4,r2,81132cec <___svfiprintf_internal_r+0xdd8>
81132978:	42000204 	addi	r8,r8,8
8113297c:	dac02617 	ldw	r11,152(sp)
81132980:	01002004 	movi	r4,128
81132984:	59008426 	beq	r11,r4,81132b98 <___svfiprintf_internal_r+0xc84>
81132988:	dac02117 	ldw	r11,132(sp)
8113298c:	82e1c83a 	sub	r16,r16,r11
81132990:	0400270e 	bge	zero,r16,81132a30 <___svfiprintf_internal_r+0xb1c>
81132994:	01c00404 	movi	r7,16
81132998:	3c016a0e 	bge	r7,r16,81132f44 <___svfiprintf_internal_r+0x1030>
8113299c:	01604574 	movhi	r5,33045
811329a0:	294a1b04 	addi	r5,r5,10348
811329a4:	d9402215 	stw	r5,136(sp)
811329a8:	070001c4 	movi	fp,7
811329ac:	00000306 	br	811329bc <___svfiprintf_internal_r+0xaa8>
811329b0:	843ffc04 	addi	r16,r16,-16
811329b4:	42000204 	addi	r8,r8,8
811329b8:	3c00130e 	bge	r7,r16,81132a08 <___svfiprintf_internal_r+0xaf4>
811329bc:	18c00404 	addi	r3,r3,16
811329c0:	10800044 	addi	r2,r2,1
811329c4:	45000015 	stw	r20,0(r8)
811329c8:	41c00115 	stw	r7,4(r8)
811329cc:	d8c01c15 	stw	r3,112(sp)
811329d0:	d8801b15 	stw	r2,108(sp)
811329d4:	e0bff60e 	bge	fp,r2,811329b0 <__reset+0xfb1129b0>
811329d8:	d9801a04 	addi	r6,sp,104
811329dc:	b80b883a 	mov	r5,r23
811329e0:	a809883a 	mov	r4,r21
811329e4:	d9c02c15 	stw	r7,176(sp)
811329e8:	1131d3c0 	call	81131d3c <__ssprint_r>
811329ec:	d9c02c17 	ldw	r7,176(sp)
811329f0:	1000581e 	bne	r2,zero,81132b54 <___svfiprintf_internal_r+0xc40>
811329f4:	843ffc04 	addi	r16,r16,-16
811329f8:	d8c01c17 	ldw	r3,112(sp)
811329fc:	d8801b17 	ldw	r2,108(sp)
81132a00:	d811883a 	mov	r8,sp
81132a04:	3c3fed16 	blt	r7,r16,811329bc <__reset+0xfb1129bc>
81132a08:	dac02217 	ldw	r11,136(sp)
81132a0c:	1c07883a 	add	r3,r3,r16
81132a10:	10800044 	addi	r2,r2,1
81132a14:	42c00015 	stw	r11,0(r8)
81132a18:	44000115 	stw	r16,4(r8)
81132a1c:	d8c01c15 	stw	r3,112(sp)
81132a20:	d8801b15 	stw	r2,108(sp)
81132a24:	010001c4 	movi	r4,7
81132a28:	20809e16 	blt	r4,r2,81132ca4 <___svfiprintf_internal_r+0xd90>
81132a2c:	42000204 	addi	r8,r8,8
81132a30:	dac02117 	ldw	r11,132(sp)
81132a34:	10800044 	addi	r2,r2,1
81132a38:	44400015 	stw	r17,0(r8)
81132a3c:	58c7883a 	add	r3,r11,r3
81132a40:	42c00115 	stw	r11,4(r8)
81132a44:	d8c01c15 	stw	r3,112(sp)
81132a48:	d8801b15 	stw	r2,108(sp)
81132a4c:	010001c4 	movi	r4,7
81132a50:	20807f16 	blt	r4,r2,81132c50 <___svfiprintf_internal_r+0xd3c>
81132a54:	42000204 	addi	r8,r8,8
81132a58:	9480010c 	andi	r18,r18,4
81132a5c:	90002926 	beq	r18,zero,81132b04 <___svfiprintf_internal_r+0xbf0>
81132a60:	dac02417 	ldw	r11,144(sp)
81132a64:	d8802017 	ldw	r2,128(sp)
81132a68:	58a1c83a 	sub	r16,r11,r2
81132a6c:	0400250e 	bge	zero,r16,81132b04 <___svfiprintf_internal_r+0xbf0>
81132a70:	04400404 	movi	r17,16
81132a74:	d8801b17 	ldw	r2,108(sp)
81132a78:	8c017c0e 	bge	r17,r16,8113306c <___svfiprintf_internal_r+0x1158>
81132a7c:	01604574 	movhi	r5,33045
81132a80:	294a1f04 	addi	r5,r5,10364
81132a84:	d9402815 	stw	r5,160(sp)
81132a88:	048001c4 	movi	r18,7
81132a8c:	00000306 	br	81132a9c <___svfiprintf_internal_r+0xb88>
81132a90:	843ffc04 	addi	r16,r16,-16
81132a94:	42000204 	addi	r8,r8,8
81132a98:	8c00110e 	bge	r17,r16,81132ae0 <___svfiprintf_internal_r+0xbcc>
81132a9c:	18c00404 	addi	r3,r3,16
81132aa0:	10800044 	addi	r2,r2,1
81132aa4:	45800015 	stw	r22,0(r8)
81132aa8:	44400115 	stw	r17,4(r8)
81132aac:	d8c01c15 	stw	r3,112(sp)
81132ab0:	d8801b15 	stw	r2,108(sp)
81132ab4:	90bff60e 	bge	r18,r2,81132a90 <__reset+0xfb112a90>
81132ab8:	d9801a04 	addi	r6,sp,104
81132abc:	b80b883a 	mov	r5,r23
81132ac0:	a809883a 	mov	r4,r21
81132ac4:	1131d3c0 	call	81131d3c <__ssprint_r>
81132ac8:	1000221e 	bne	r2,zero,81132b54 <___svfiprintf_internal_r+0xc40>
81132acc:	843ffc04 	addi	r16,r16,-16
81132ad0:	d8c01c17 	ldw	r3,112(sp)
81132ad4:	d8801b17 	ldw	r2,108(sp)
81132ad8:	d811883a 	mov	r8,sp
81132adc:	8c3fef16 	blt	r17,r16,81132a9c <__reset+0xfb112a9c>
81132ae0:	dac02817 	ldw	r11,160(sp)
81132ae4:	1c07883a 	add	r3,r3,r16
81132ae8:	10800044 	addi	r2,r2,1
81132aec:	42c00015 	stw	r11,0(r8)
81132af0:	44000115 	stw	r16,4(r8)
81132af4:	d8c01c15 	stw	r3,112(sp)
81132af8:	d8801b15 	stw	r2,108(sp)
81132afc:	010001c4 	movi	r4,7
81132b00:	2080aa16 	blt	r4,r2,81132dac <___svfiprintf_internal_r+0xe98>
81132b04:	d8802417 	ldw	r2,144(sp)
81132b08:	dac02017 	ldw	r11,128(sp)
81132b0c:	12c0010e 	bge	r2,r11,81132b14 <___svfiprintf_internal_r+0xc00>
81132b10:	5805883a 	mov	r2,r11
81132b14:	dac02517 	ldw	r11,148(sp)
81132b18:	5897883a 	add	r11,r11,r2
81132b1c:	dac02515 	stw	r11,148(sp)
81132b20:	1800531e 	bne	r3,zero,81132c70 <___svfiprintf_internal_r+0xd5c>
81132b24:	98800007 	ldb	r2,0(r19)
81132b28:	d8001b15 	stw	zero,108(sp)
81132b2c:	d811883a 	mov	r8,sp
81132b30:	103d231e 	bne	r2,zero,81131fc0 <__reset+0xfb111fc0>
81132b34:	9823883a 	mov	r17,r19
81132b38:	003d3906 	br	81132020 <__reset+0xfb112020>
81132b3c:	d8801c17 	ldw	r2,112(sp)
81132b40:	10000426 	beq	r2,zero,81132b54 <___svfiprintf_internal_r+0xc40>
81132b44:	d9402717 	ldw	r5,156(sp)
81132b48:	d9002a17 	ldw	r4,168(sp)
81132b4c:	d9801a04 	addi	r6,sp,104
81132b50:	1131d3c0 	call	81131d3c <__ssprint_r>
81132b54:	dac02717 	ldw	r11,156(sp)
81132b58:	d8802517 	ldw	r2,148(sp)
81132b5c:	58c0030b 	ldhu	r3,12(r11)
81132b60:	18c0100c 	andi	r3,r3,64
81132b64:	1801381e 	bne	r3,zero,81133048 <___svfiprintf_internal_r+0x1134>
81132b68:	dfc03717 	ldw	ra,220(sp)
81132b6c:	df003617 	ldw	fp,216(sp)
81132b70:	ddc03517 	ldw	r23,212(sp)
81132b74:	dd803417 	ldw	r22,208(sp)
81132b78:	dd403317 	ldw	r21,204(sp)
81132b7c:	dd003217 	ldw	r20,200(sp)
81132b80:	dcc03117 	ldw	r19,196(sp)
81132b84:	dc803017 	ldw	r18,192(sp)
81132b88:	dc402f17 	ldw	r17,188(sp)
81132b8c:	dc002e17 	ldw	r16,184(sp)
81132b90:	dec03804 	addi	sp,sp,224
81132b94:	f800283a 	ret
81132b98:	dac02417 	ldw	r11,144(sp)
81132b9c:	d9002017 	ldw	r4,128(sp)
81132ba0:	5939c83a 	sub	fp,r11,r4
81132ba4:	073f780e 	bge	zero,fp,81132988 <__reset+0xfb112988>
81132ba8:	02400404 	movi	r9,16
81132bac:	4f01370e 	bge	r9,fp,8113308c <___svfiprintf_internal_r+0x1178>
81132bb0:	02e04574 	movhi	r11,33045
81132bb4:	5aca1b04 	addi	r11,r11,10348
81132bb8:	dac02215 	stw	r11,136(sp)
81132bbc:	028001c4 	movi	r10,7
81132bc0:	00000306 	br	81132bd0 <___svfiprintf_internal_r+0xcbc>
81132bc4:	e73ffc04 	addi	fp,fp,-16
81132bc8:	42000204 	addi	r8,r8,8
81132bcc:	4f00150e 	bge	r9,fp,81132c24 <___svfiprintf_internal_r+0xd10>
81132bd0:	18c00404 	addi	r3,r3,16
81132bd4:	10800044 	addi	r2,r2,1
81132bd8:	45000015 	stw	r20,0(r8)
81132bdc:	42400115 	stw	r9,4(r8)
81132be0:	d8c01c15 	stw	r3,112(sp)
81132be4:	d8801b15 	stw	r2,108(sp)
81132be8:	50bff60e 	bge	r10,r2,81132bc4 <__reset+0xfb112bc4>
81132bec:	d9801a04 	addi	r6,sp,104
81132bf0:	b80b883a 	mov	r5,r23
81132bf4:	a809883a 	mov	r4,r21
81132bf8:	da402c15 	stw	r9,176(sp)
81132bfc:	da802d15 	stw	r10,180(sp)
81132c00:	1131d3c0 	call	81131d3c <__ssprint_r>
81132c04:	da402c17 	ldw	r9,176(sp)
81132c08:	da802d17 	ldw	r10,180(sp)
81132c0c:	103fd11e 	bne	r2,zero,81132b54 <__reset+0xfb112b54>
81132c10:	e73ffc04 	addi	fp,fp,-16
81132c14:	d8c01c17 	ldw	r3,112(sp)
81132c18:	d8801b17 	ldw	r2,108(sp)
81132c1c:	d811883a 	mov	r8,sp
81132c20:	4f3feb16 	blt	r9,fp,81132bd0 <__reset+0xfb112bd0>
81132c24:	dac02217 	ldw	r11,136(sp)
81132c28:	1f07883a 	add	r3,r3,fp
81132c2c:	10800044 	addi	r2,r2,1
81132c30:	42c00015 	stw	r11,0(r8)
81132c34:	47000115 	stw	fp,4(r8)
81132c38:	d8c01c15 	stw	r3,112(sp)
81132c3c:	d8801b15 	stw	r2,108(sp)
81132c40:	010001c4 	movi	r4,7
81132c44:	2080b616 	blt	r4,r2,81132f20 <___svfiprintf_internal_r+0x100c>
81132c48:	42000204 	addi	r8,r8,8
81132c4c:	003f4e06 	br	81132988 <__reset+0xfb112988>
81132c50:	d9801a04 	addi	r6,sp,104
81132c54:	b80b883a 	mov	r5,r23
81132c58:	a809883a 	mov	r4,r21
81132c5c:	1131d3c0 	call	81131d3c <__ssprint_r>
81132c60:	103fbc1e 	bne	r2,zero,81132b54 <__reset+0xfb112b54>
81132c64:	d8c01c17 	ldw	r3,112(sp)
81132c68:	d811883a 	mov	r8,sp
81132c6c:	003f7a06 	br	81132a58 <__reset+0xfb112a58>
81132c70:	d9801a04 	addi	r6,sp,104
81132c74:	b80b883a 	mov	r5,r23
81132c78:	a809883a 	mov	r4,r21
81132c7c:	1131d3c0 	call	81131d3c <__ssprint_r>
81132c80:	103fa826 	beq	r2,zero,81132b24 <__reset+0xfb112b24>
81132c84:	003fb306 	br	81132b54 <__reset+0xfb112b54>
81132c88:	d9801a04 	addi	r6,sp,104
81132c8c:	b80b883a 	mov	r5,r23
81132c90:	a809883a 	mov	r4,r21
81132c94:	1131d3c0 	call	81131d3c <__ssprint_r>
81132c98:	103fae1e 	bne	r2,zero,81132b54 <__reset+0xfb112b54>
81132c9c:	d811883a 	mov	r8,sp
81132ca0:	003cdc06 	br	81132014 <__reset+0xfb112014>
81132ca4:	d9801a04 	addi	r6,sp,104
81132ca8:	b80b883a 	mov	r5,r23
81132cac:	a809883a 	mov	r4,r21
81132cb0:	1131d3c0 	call	81131d3c <__ssprint_r>
81132cb4:	103fa71e 	bne	r2,zero,81132b54 <__reset+0xfb112b54>
81132cb8:	d8c01c17 	ldw	r3,112(sp)
81132cbc:	d8801b17 	ldw	r2,108(sp)
81132cc0:	d811883a 	mov	r8,sp
81132cc4:	003f5a06 	br	81132a30 <__reset+0xfb112a30>
81132cc8:	d9801a04 	addi	r6,sp,104
81132ccc:	b80b883a 	mov	r5,r23
81132cd0:	a809883a 	mov	r4,r21
81132cd4:	1131d3c0 	call	81131d3c <__ssprint_r>
81132cd8:	103f9e1e 	bne	r2,zero,81132b54 <__reset+0xfb112b54>
81132cdc:	d8c01c17 	ldw	r3,112(sp)
81132ce0:	d8801b17 	ldw	r2,108(sp)
81132ce4:	d811883a 	mov	r8,sp
81132ce8:	003f1706 	br	81132948 <__reset+0xfb112948>
81132cec:	d9801a04 	addi	r6,sp,104
81132cf0:	b80b883a 	mov	r5,r23
81132cf4:	a809883a 	mov	r4,r21
81132cf8:	1131d3c0 	call	81131d3c <__ssprint_r>
81132cfc:	103f951e 	bne	r2,zero,81132b54 <__reset+0xfb112b54>
81132d00:	d8c01c17 	ldw	r3,112(sp)
81132d04:	d8801b17 	ldw	r2,108(sp)
81132d08:	d811883a 	mov	r8,sp
81132d0c:	003f1b06 	br	8113297c <__reset+0xfb11297c>
81132d10:	d8001d85 	stb	zero,118(sp)
81132d14:	80007b16 	blt	r16,zero,81132f04 <___svfiprintf_internal_r+0xff0>
81132d18:	00ffdfc4 	movi	r3,-129
81132d1c:	e244b03a 	or	r2,fp,r9
81132d20:	90e4703a 	and	r18,r18,r3
81132d24:	103d7026 	beq	r2,zero,811322e8 <__reset+0xfb1122e8>
81132d28:	0015883a 	mov	r10,zero
81132d2c:	003d7206 	br	811322f8 <__reset+0xfb1122f8>
81132d30:	d9801a04 	addi	r6,sp,104
81132d34:	b80b883a 	mov	r5,r23
81132d38:	a809883a 	mov	r4,r21
81132d3c:	1131d3c0 	call	81131d3c <__ssprint_r>
81132d40:	103f841e 	bne	r2,zero,81132b54 <__reset+0xfb112b54>
81132d44:	d8c01c17 	ldw	r3,112(sp)
81132d48:	d8801b17 	ldw	r2,108(sp)
81132d4c:	d811883a 	mov	r8,sp
81132d50:	003ef006 	br	81132914 <__reset+0xfb112914>
81132d54:	9080100c 	andi	r2,r18,64
81132d58:	d8001d85 	stb	zero,118(sp)
81132d5c:	dac02317 	ldw	r11,140(sp)
81132d60:	10008126 	beq	r2,zero,81132f68 <___svfiprintf_internal_r+0x1054>
81132d64:	58800104 	addi	r2,r11,4
81132d68:	5f00000b 	ldhu	fp,0(r11)
81132d6c:	0013883a 	mov	r9,zero
81132d70:	803ec30e 	bge	r16,zero,81132880 <__reset+0xfb112880>
81132d74:	d8802315 	stw	r2,140(sp)
81132d78:	0015883a 	mov	r10,zero
81132d7c:	e244b03a 	or	r2,fp,r9
81132d80:	103e371e 	bne	r2,zero,81132660 <__reset+0xfb112660>
81132d84:	00800044 	movi	r2,1
81132d88:	10803fcc 	andi	r2,r2,255
81132d8c:	00c00044 	movi	r3,1
81132d90:	10c06126 	beq	r2,r3,81132f18 <___svfiprintf_internal_r+0x1004>
81132d94:	00c00084 	movi	r3,2
81132d98:	10fd5526 	beq	r2,r3,811322f0 <__reset+0xfb1122f0>
81132d9c:	003ed806 	br	81132900 <__reset+0xfb112900>
81132da0:	d8802315 	stw	r2,140(sp)
81132da4:	98c00007 	ldb	r3,0(r19)
81132da8:	003cab06 	br	81132058 <__reset+0xfb112058>
81132dac:	d9801a04 	addi	r6,sp,104
81132db0:	b80b883a 	mov	r5,r23
81132db4:	a809883a 	mov	r4,r21
81132db8:	1131d3c0 	call	81131d3c <__ssprint_r>
81132dbc:	103f651e 	bne	r2,zero,81132b54 <__reset+0xfb112b54>
81132dc0:	d8c01c17 	ldw	r3,112(sp)
81132dc4:	003f4f06 	br	81132b04 <__reset+0xfb112b04>
81132dc8:	00a04574 	movhi	r2,33045
81132dcc:	10899104 	addi	r2,r2,9796
81132dd0:	d8802915 	stw	r2,164(sp)
81132dd4:	003d4406 	br	811322e8 <__reset+0xfb1122e8>
81132dd8:	dac02317 	ldw	r11,140(sp)
81132ddc:	58800017 	ldw	r2,0(r11)
81132de0:	dac02517 	ldw	r11,148(sp)
81132de4:	5807d7fa 	srai	r3,r11,31
81132de8:	dac02317 	ldw	r11,140(sp)
81132dec:	10c00115 	stw	r3,4(r2)
81132df0:	5ac00104 	addi	r11,r11,4
81132df4:	dac02315 	stw	r11,140(sp)
81132df8:	dac02517 	ldw	r11,148(sp)
81132dfc:	12c00015 	stw	r11,0(r2)
81132e00:	003c6d06 	br	81131fb8 <__reset+0xfb111fb8>
81132e04:	9080100c 	andi	r2,r18,64
81132e08:	dac02317 	ldw	r11,140(sp)
81132e0c:	103e5326 	beq	r2,zero,8113275c <__reset+0xfb11275c>
81132e10:	5f00000f 	ldh	fp,0(r11)
81132e14:	5ac00104 	addi	r11,r11,4
81132e18:	dac02315 	stw	r11,140(sp)
81132e1c:	e013d7fa 	srai	r9,fp,31
81132e20:	4805883a 	mov	r2,r9
81132e24:	003e0706 	br	81132644 <__reset+0xfb112644>
81132e28:	00800c04 	movi	r2,48
81132e2c:	d8801d05 	stb	r2,116(sp)
81132e30:	d8c01d45 	stb	r3,117(sp)
81132e34:	d8001d85 	stb	zero,118(sp)
81132e38:	90800094 	ori	r2,r18,2
81132e3c:	80008f16 	blt	r16,zero,8113307c <___svfiprintf_internal_r+0x1168>
81132e40:	00bfdfc4 	movi	r2,-129
81132e44:	90a4703a 	and	r18,r18,r2
81132e48:	94800094 	ori	r18,r18,2
81132e4c:	0015883a 	mov	r10,zero
81132e50:	003d2906 	br	811322f8 <__reset+0xfb1122f8>
81132e54:	98c00007 	ldb	r3,0(r19)
81132e58:	003c7f06 	br	81132058 <__reset+0xfb112058>
81132e5c:	dac02317 	ldw	r11,140(sp)
81132e60:	0013883a 	mov	r9,zero
81132e64:	5f000017 	ldw	fp,0(r11)
81132e68:	5ac00104 	addi	r11,r11,4
81132e6c:	dac02315 	stw	r11,140(sp)
81132e70:	003d1506 	br	811322c8 <__reset+0xfb1122c8>
81132e74:	9080100c 	andi	r2,r18,64
81132e78:	d8001d85 	stb	zero,118(sp)
81132e7c:	dac02317 	ldw	r11,140(sp)
81132e80:	10003426 	beq	r2,zero,81132f54 <___svfiprintf_internal_r+0x1040>
81132e84:	58800104 	addi	r2,r11,4
81132e88:	5f00000b 	ldhu	fp,0(r11)
81132e8c:	0013883a 	mov	r9,zero
81132e90:	803e950e 	bge	r16,zero,811328e8 <__reset+0xfb1128e8>
81132e94:	e246b03a 	or	r3,fp,r9
81132e98:	d8802315 	stw	r2,140(sp)
81132e9c:	183d5a1e 	bne	r3,zero,81132408 <__reset+0xfb112408>
81132ea0:	0015883a 	mov	r10,zero
81132ea4:	0005883a 	mov	r2,zero
81132ea8:	003fb706 	br	81132d88 <__reset+0xfb112d88>
81132eac:	98c00043 	ldbu	r3,1(r19)
81132eb0:	94800814 	ori	r18,r18,32
81132eb4:	9cc00044 	addi	r19,r19,1
81132eb8:	18c03fcc 	andi	r3,r3,255
81132ebc:	18c0201c 	xori	r3,r3,128
81132ec0:	18ffe004 	addi	r3,r3,-128
81132ec4:	003c6406 	br	81132058 <__reset+0xfb112058>
81132ec8:	d8c02315 	stw	r3,140(sp)
81132ecc:	0015883a 	mov	r10,zero
81132ed0:	003faa06 	br	81132d7c <__reset+0xfb112d7c>
81132ed4:	dac02317 	ldw	r11,140(sp)
81132ed8:	58800017 	ldw	r2,0(r11)
81132edc:	5ac00104 	addi	r11,r11,4
81132ee0:	dac02315 	stw	r11,140(sp)
81132ee4:	dac02517 	ldw	r11,148(sp)
81132ee8:	12c00015 	stw	r11,0(r2)
81132eec:	003c3206 	br	81131fb8 <__reset+0xfb111fb8>
81132ef0:	01204574 	movhi	r4,33045
81132ef4:	21099104 	addi	r4,r4,9796
81132ef8:	d9002915 	stw	r4,164(sp)
81132efc:	d8c02315 	stw	r3,140(sp)
81132f00:	1025883a 	mov	r18,r2
81132f04:	e244b03a 	or	r2,fp,r9
81132f08:	103f871e 	bne	r2,zero,81132d28 <__reset+0xfb112d28>
81132f0c:	0015883a 	mov	r10,zero
81132f10:	00800084 	movi	r2,2
81132f14:	003f9c06 	br	81132d88 <__reset+0xfb112d88>
81132f18:	0039883a 	mov	fp,zero
81132f1c:	003e5f06 	br	8113289c <__reset+0xfb11289c>
81132f20:	d9801a04 	addi	r6,sp,104
81132f24:	b80b883a 	mov	r5,r23
81132f28:	a809883a 	mov	r4,r21
81132f2c:	1131d3c0 	call	81131d3c <__ssprint_r>
81132f30:	103f081e 	bne	r2,zero,81132b54 <__reset+0xfb112b54>
81132f34:	d8c01c17 	ldw	r3,112(sp)
81132f38:	d8801b17 	ldw	r2,108(sp)
81132f3c:	d811883a 	mov	r8,sp
81132f40:	003e9106 	br	81132988 <__reset+0xfb112988>
81132f44:	01204574 	movhi	r4,33045
81132f48:	210a1b04 	addi	r4,r4,10348
81132f4c:	d9002215 	stw	r4,136(sp)
81132f50:	003ead06 	br	81132a08 <__reset+0xfb112a08>
81132f54:	58800104 	addi	r2,r11,4
81132f58:	5f000017 	ldw	fp,0(r11)
81132f5c:	0013883a 	mov	r9,zero
81132f60:	803e610e 	bge	r16,zero,811328e8 <__reset+0xfb1128e8>
81132f64:	003fcb06 	br	81132e94 <__reset+0xfb112e94>
81132f68:	58800104 	addi	r2,r11,4
81132f6c:	5f000017 	ldw	fp,0(r11)
81132f70:	0013883a 	mov	r9,zero
81132f74:	803e420e 	bge	r16,zero,81132880 <__reset+0xfb112880>
81132f78:	003f7e06 	br	81132d74 <__reset+0xfb112d74>
81132f7c:	5f000017 	ldw	fp,0(r11)
81132f80:	5ac00104 	addi	r11,r11,4
81132f84:	0013883a 	mov	r9,zero
81132f88:	dac02315 	stw	r11,140(sp)
81132f8c:	003cce06 	br	811322c8 <__reset+0xfb1122c8>
81132f90:	8809883a 	mov	r4,r17
81132f94:	da002c15 	stw	r8,176(sp)
81132f98:	1124dc80 	call	81124dc8 <strlen>
81132f9c:	d8802115 	stw	r2,132(sp)
81132fa0:	da801d83 	ldbu	r10,118(sp)
81132fa4:	df002315 	stw	fp,140(sp)
81132fa8:	0021883a 	mov	r16,zero
81132fac:	da002c17 	ldw	r8,176(sp)
81132fb0:	003cf606 	br	8113238c <__reset+0xfb11238c>
81132fb4:	00800184 	movi	r2,6
81132fb8:	1400012e 	bgeu	r2,r16,81132fc0 <___svfiprintf_internal_r+0x10ac>
81132fbc:	1021883a 	mov	r16,r2
81132fc0:	dc002115 	stw	r16,132(sp)
81132fc4:	8005883a 	mov	r2,r16
81132fc8:	80003c16 	blt	r16,zero,811330bc <___svfiprintf_internal_r+0x11a8>
81132fcc:	04604574 	movhi	r17,33045
81132fd0:	d8802015 	stw	r2,128(sp)
81132fd4:	df002315 	stw	fp,140(sp)
81132fd8:	8c499604 	addi	r17,r17,9816
81132fdc:	003d2e06 	br	81132498 <__reset+0xfb112498>
81132fe0:	04001004 	movi	r16,64
81132fe4:	800b883a 	mov	r5,r16
81132fe8:	1123b3c0 	call	81123b3c <_malloc_r>
81132fec:	dac02717 	ldw	r11,156(sp)
81132ff0:	58800015 	stw	r2,0(r11)
81132ff4:	58800415 	stw	r2,16(r11)
81132ff8:	10004826 	beq	r2,zero,8113311c <___svfiprintf_internal_r+0x1208>
81132ffc:	dac02717 	ldw	r11,156(sp)
81133000:	5c000515 	stw	r16,20(r11)
81133004:	003bd906 	br	81131f6c <__reset+0xfb111f6c>
81133008:	9080004c 	andi	r2,r18,1
8113300c:	0015883a 	mov	r10,zero
81133010:	10000626 	beq	r2,zero,8113302c <___svfiprintf_internal_r+0x1118>
81133014:	dac02b17 	ldw	r11,172(sp)
81133018:	00800c04 	movi	r2,48
8113301c:	d88019c5 	stb	r2,103(sp)
81133020:	dac02115 	stw	r11,132(sp)
81133024:	dc4019c4 	addi	r17,sp,103
81133028:	003cd806 	br	8113238c <__reset+0xfb11238c>
8113302c:	d8002115 	stw	zero,132(sp)
81133030:	dc401a04 	addi	r17,sp,104
81133034:	003cd506 	br	8113238c <__reset+0xfb11238c>
81133038:	01204574 	movhi	r4,33045
8113303c:	210a1f04 	addi	r4,r4,10364
81133040:	d9002815 	stw	r4,160(sp)
81133044:	003d4306 	br	81132554 <__reset+0xfb112554>
81133048:	00bfffc4 	movi	r2,-1
8113304c:	003ec606 	br	81132b68 <__reset+0xfb112b68>
81133050:	00800044 	movi	r2,1
81133054:	10803fcc 	andi	r2,r2,255
81133058:	00c00044 	movi	r3,1
8113305c:	10fd8026 	beq	r2,r3,81132660 <__reset+0xfb112660>
81133060:	00c00084 	movi	r3,2
81133064:	10fca426 	beq	r2,r3,811322f8 <__reset+0xfb1122f8>
81133068:	003ce806 	br	8113240c <__reset+0xfb11240c>
8113306c:	01204574 	movhi	r4,33045
81133070:	210a1f04 	addi	r4,r4,10364
81133074:	d9002815 	stw	r4,160(sp)
81133078:	003e9906 	br	81132ae0 <__reset+0xfb112ae0>
8113307c:	1025883a 	mov	r18,r2
81133080:	0015883a 	mov	r10,zero
81133084:	00800084 	movi	r2,2
81133088:	003ff206 	br	81133054 <__reset+0xfb113054>
8113308c:	01604574 	movhi	r5,33045
81133090:	294a1b04 	addi	r5,r5,10348
81133094:	d9402215 	stw	r5,136(sp)
81133098:	003ee206 	br	81132c24 <__reset+0xfb112c24>
8113309c:	5827883a 	mov	r19,r11
811330a0:	0021883a 	mov	r16,zero
811330a4:	003bed06 	br	8113205c <__reset+0xfb11205c>
811330a8:	dc002115 	stw	r16,132(sp)
811330ac:	da801d83 	ldbu	r10,118(sp)
811330b0:	df002315 	stw	fp,140(sp)
811330b4:	0021883a 	mov	r16,zero
811330b8:	003cb406 	br	8113238c <__reset+0xfb11238c>
811330bc:	0005883a 	mov	r2,zero
811330c0:	003fc206 	br	81132fcc <__reset+0xfb112fcc>
811330c4:	d8802317 	ldw	r2,140(sp)
811330c8:	98c00043 	ldbu	r3,1(r19)
811330cc:	5827883a 	mov	r19,r11
811330d0:	14000017 	ldw	r16,0(r2)
811330d4:	10800104 	addi	r2,r2,4
811330d8:	d8802315 	stw	r2,140(sp)
811330dc:	803f760e 	bge	r16,zero,81132eb8 <__reset+0xfb112eb8>
811330e0:	18c03fcc 	andi	r3,r3,255
811330e4:	18c0201c 	xori	r3,r3,128
811330e8:	043fffc4 	movi	r16,-1
811330ec:	18ffe004 	addi	r3,r3,-128
811330f0:	003bd906 	br	81132058 <__reset+0xfb112058>
811330f4:	d9c01d85 	stb	r7,118(sp)
811330f8:	003cb606 	br	811323d4 <__reset+0xfb1123d4>
811330fc:	d9c01d85 	stb	r7,118(sp)
81133100:	003d2106 	br	81132588 <__reset+0xfb112588>
81133104:	d9c01d85 	stb	r7,118(sp)
81133108:	003d8e06 	br	81132744 <__reset+0xfb112744>
8113310c:	d9c01d85 	stb	r7,118(sp)
81133110:	003db306 	br	811327e0 <__reset+0xfb1127e0>
81133114:	d9c01d85 	stb	r7,118(sp)
81133118:	003c8a06 	br	81132344 <__reset+0xfb112344>
8113311c:	dac02a17 	ldw	r11,168(sp)
81133120:	00800304 	movi	r2,12
81133124:	58800015 	stw	r2,0(r11)
81133128:	00bfffc4 	movi	r2,-1
8113312c:	003e8e06 	br	81132b68 <__reset+0xfb112b68>
81133130:	d9c01d85 	stb	r7,118(sp)
81133134:	003dc706 	br	81132854 <__reset+0xfb112854>
81133138:	d9c01d85 	stb	r7,118(sp)
8113313c:	003ddf06 	br	811328bc <__reset+0xfb1128bc>
81133140:	d9c01d85 	stb	r7,118(sp)
81133144:	003d3706 	br	81132624 <__reset+0xfb112624>
81133148:	d9c01d85 	stb	r7,118(sp)
8113314c:	003c5406 	br	811322a0 <__reset+0xfb1122a0>
81133150:	d9c01d85 	stb	r7,118(sp)
81133154:	003d1d06 	br	811325cc <__reset+0xfb1125cc>

81133158 <__submore>:
81133158:	defffa04 	addi	sp,sp,-24
8113315c:	de00012e 	bgeu	sp,et,81133164 <__submore+0xc>
81133160:	003b68fa 	trap	3
81133164:	dc000015 	stw	r16,0(sp)
81133168:	2821883a 	mov	r16,r5
8113316c:	29400c17 	ldw	r5,48(r5)
81133170:	dfc00515 	stw	ra,20(sp)
81133174:	dd000415 	stw	r20,16(sp)
81133178:	dcc00315 	stw	r19,12(sp)
8113317c:	dc800215 	stw	r18,8(sp)
81133180:	dc400115 	stw	r17,4(sp)
81133184:	80801004 	addi	r2,r16,64
81133188:	28801726 	beq	r5,r2,811331e8 <__submore+0x90>
8113318c:	84400d17 	ldw	r17,52(r16)
81133190:	8c67883a 	add	r19,r17,r17
81133194:	980d883a 	mov	r6,r19
81133198:	112f8cc0 	call	8112f8cc <_realloc_r>
8113319c:	1025883a 	mov	r18,r2
811331a0:	10002226 	beq	r2,zero,8113322c <__submore+0xd4>
811331a4:	1469883a 	add	r20,r2,r17
811331a8:	880d883a 	mov	r6,r17
811331ac:	100b883a 	mov	r5,r2
811331b0:	a009883a 	mov	r4,r20
811331b4:	11243500 	call	81124350 <memcpy>
811331b8:	0005883a 	mov	r2,zero
811331bc:	85000015 	stw	r20,0(r16)
811331c0:	84800c15 	stw	r18,48(r16)
811331c4:	84c00d15 	stw	r19,52(r16)
811331c8:	dfc00517 	ldw	ra,20(sp)
811331cc:	dd000417 	ldw	r20,16(sp)
811331d0:	dcc00317 	ldw	r19,12(sp)
811331d4:	dc800217 	ldw	r18,8(sp)
811331d8:	dc400117 	ldw	r17,4(sp)
811331dc:	dc000017 	ldw	r16,0(sp)
811331e0:	dec00604 	addi	sp,sp,24
811331e4:	f800283a 	ret
811331e8:	04410004 	movi	r17,1024
811331ec:	880b883a 	mov	r5,r17
811331f0:	1123b3c0 	call	81123b3c <_malloc_r>
811331f4:	1007883a 	mov	r3,r2
811331f8:	10000c26 	beq	r2,zero,8113322c <__submore+0xd4>
811331fc:	80801083 	ldbu	r2,66(r16)
81133200:	80c00c15 	stw	r3,48(r16)
81133204:	84400d15 	stw	r17,52(r16)
81133208:	1880ffc5 	stb	r2,1023(r3)
8113320c:	81401043 	ldbu	r5,65(r16)
81133210:	1900ff44 	addi	r4,r3,1021
81133214:	0005883a 	mov	r2,zero
81133218:	1940ff85 	stb	r5,1022(r3)
8113321c:	81401003 	ldbu	r5,64(r16)
81133220:	1940ff45 	stb	r5,1021(r3)
81133224:	81000015 	stw	r4,0(r16)
81133228:	003fe706 	br	811331c8 <__reset+0xfb1131c8>
8113322c:	00bfffc4 	movi	r2,-1
81133230:	003fe506 	br	811331c8 <__reset+0xfb1131c8>

81133234 <_ungetc_r>:
81133234:	00bfffc4 	movi	r2,-1
81133238:	28806326 	beq	r5,r2,811333c8 <_ungetc_r+0x194>
8113323c:	defffb04 	addi	sp,sp,-20
81133240:	de00012e 	bgeu	sp,et,81133248 <_ungetc_r+0x14>
81133244:	003b68fa 	trap	3
81133248:	dcc00315 	stw	r19,12(sp)
8113324c:	dc400115 	stw	r17,4(sp)
81133250:	dc000015 	stw	r16,0(sp)
81133254:	dfc00415 	stw	ra,16(sp)
81133258:	dc800215 	stw	r18,8(sp)
8113325c:	2023883a 	mov	r17,r4
81133260:	3021883a 	mov	r16,r6
81133264:	2827883a 	mov	r19,r5
81133268:	20000226 	beq	r4,zero,81133274 <_ungetc_r+0x40>
8113326c:	20800e17 	ldw	r2,56(r4)
81133270:	10002e26 	beq	r2,zero,8113332c <_ungetc_r+0xf8>
81133274:	80c0030b 	ldhu	r3,12(r16)
81133278:	1888000c 	andi	r2,r3,8192
8113327c:	1000051e 	bne	r2,zero,81133294 <_ungetc_r+0x60>
81133280:	81001917 	ldw	r4,100(r16)
81133284:	00b7ffc4 	movi	r2,-8193
81133288:	18c80014 	ori	r3,r3,8192
8113328c:	2084703a 	and	r2,r4,r2
81133290:	80801915 	stw	r2,100(r16)
81133294:	00bff7c4 	movi	r2,-33
81133298:	1884703a 	and	r2,r3,r2
8113329c:	8080030d 	sth	r2,12(r16)
811332a0:	1900010c 	andi	r4,r3,4
811332a4:	2000061e 	bne	r4,zero,811332c0 <_ungetc_r+0x8c>
811332a8:	1900040c 	andi	r4,r3,16
811332ac:	20001d26 	beq	r4,zero,81133324 <_ungetc_r+0xf0>
811332b0:	18c0020c 	andi	r3,r3,8
811332b4:	1800331e 	bne	r3,zero,81133384 <_ungetc_r+0x150>
811332b8:	10800114 	ori	r2,r2,4
811332bc:	8080030d 	sth	r2,12(r16)
811332c0:	80800c17 	ldw	r2,48(r16)
811332c4:	9c803fcc 	andi	r18,r19,255
811332c8:	10001a26 	beq	r2,zero,81133334 <_ungetc_r+0x100>
811332cc:	80c00117 	ldw	r3,4(r16)
811332d0:	80800d17 	ldw	r2,52(r16)
811332d4:	18800f0e 	bge	r3,r2,81133314 <_ungetc_r+0xe0>
811332d8:	80c00017 	ldw	r3,0(r16)
811332dc:	9005883a 	mov	r2,r18
811332e0:	193fffc4 	addi	r4,r3,-1
811332e4:	81000015 	stw	r4,0(r16)
811332e8:	1cffffc5 	stb	r19,-1(r3)
811332ec:	80c00117 	ldw	r3,4(r16)
811332f0:	18c00044 	addi	r3,r3,1
811332f4:	80c00115 	stw	r3,4(r16)
811332f8:	dfc00417 	ldw	ra,16(sp)
811332fc:	dcc00317 	ldw	r19,12(sp)
81133300:	dc800217 	ldw	r18,8(sp)
81133304:	dc400117 	ldw	r17,4(sp)
81133308:	dc000017 	ldw	r16,0(sp)
8113330c:	dec00504 	addi	sp,sp,20
81133310:	f800283a 	ret
81133314:	800b883a 	mov	r5,r16
81133318:	8809883a 	mov	r4,r17
8113331c:	11331580 	call	81133158 <__submore>
81133320:	103fed26 	beq	r2,zero,811332d8 <__reset+0xfb1132d8>
81133324:	00bfffc4 	movi	r2,-1
81133328:	003ff306 	br	811332f8 <__reset+0xfb1132f8>
8113332c:	112d3a00 	call	8112d3a0 <__sinit>
81133330:	003fd006 	br	81133274 <__reset+0xfb113274>
81133334:	80c00417 	ldw	r3,16(r16)
81133338:	80800017 	ldw	r2,0(r16)
8113333c:	18000326 	beq	r3,zero,8113334c <_ungetc_r+0x118>
81133340:	1880022e 	bgeu	r3,r2,8113334c <_ungetc_r+0x118>
81133344:	10ffffc3 	ldbu	r3,-1(r2)
81133348:	90c01826 	beq	r18,r3,811333ac <_ungetc_r+0x178>
8113334c:	81400117 	ldw	r5,4(r16)
81133350:	80800e15 	stw	r2,56(r16)
81133354:	008000c4 	movi	r2,3
81133358:	81001004 	addi	r4,r16,64
8113335c:	80c01084 	addi	r3,r16,66
81133360:	80800d15 	stw	r2,52(r16)
81133364:	00800044 	movi	r2,1
81133368:	80800115 	stw	r2,4(r16)
8113336c:	81400f15 	stw	r5,60(r16)
81133370:	81000c15 	stw	r4,48(r16)
81133374:	84c01085 	stb	r19,66(r16)
81133378:	80c00015 	stw	r3,0(r16)
8113337c:	9005883a 	mov	r2,r18
81133380:	003fdd06 	br	811332f8 <__reset+0xfb1132f8>
81133384:	800b883a 	mov	r5,r16
81133388:	8809883a 	mov	r4,r17
8113338c:	112cfa40 	call	8112cfa4 <_fflush_r>
81133390:	103fe41e 	bne	r2,zero,81133324 <__reset+0xfb113324>
81133394:	8080030b 	ldhu	r2,12(r16)
81133398:	00fffdc4 	movi	r3,-9
8113339c:	80000215 	stw	zero,8(r16)
811333a0:	1884703a 	and	r2,r3,r2
811333a4:	80000615 	stw	zero,24(r16)
811333a8:	003fc306 	br	811332b8 <__reset+0xfb1132b8>
811333ac:	80c00117 	ldw	r3,4(r16)
811333b0:	10bfffc4 	addi	r2,r2,-1
811333b4:	80800015 	stw	r2,0(r16)
811333b8:	18800044 	addi	r2,r3,1
811333bc:	80800115 	stw	r2,4(r16)
811333c0:	9005883a 	mov	r2,r18
811333c4:	003fcc06 	br	811332f8 <__reset+0xfb1132f8>
811333c8:	00bfffc4 	movi	r2,-1
811333cc:	f800283a 	ret

811333d0 <ungetc>:
811333d0:	00a04574 	movhi	r2,33045
811333d4:	10936004 	addi	r2,r2,19840
811333d8:	280d883a 	mov	r6,r5
811333dc:	200b883a 	mov	r5,r4
811333e0:	11000017 	ldw	r4,0(r2)
811333e4:	11332341 	jmpi	81133234 <_ungetc_r>

811333e8 <__sprint_r.part.0>:
811333e8:	defff604 	addi	sp,sp,-40
811333ec:	de00012e 	bgeu	sp,et,811333f4 <__sprint_r.part.0+0xc>
811333f0:	003b68fa 	trap	3
811333f4:	28801917 	ldw	r2,100(r5)
811333f8:	dd400515 	stw	r21,20(sp)
811333fc:	dfc00915 	stw	ra,36(sp)
81133400:	df000815 	stw	fp,32(sp)
81133404:	ddc00715 	stw	r23,28(sp)
81133408:	dd800615 	stw	r22,24(sp)
8113340c:	dd000415 	stw	r20,16(sp)
81133410:	dcc00315 	stw	r19,12(sp)
81133414:	dc800215 	stw	r18,8(sp)
81133418:	dc400115 	stw	r17,4(sp)
8113341c:	dc000015 	stw	r16,0(sp)
81133420:	1088000c 	andi	r2,r2,8192
81133424:	302b883a 	mov	r21,r6
81133428:	10002e26 	beq	r2,zero,811334e4 <__sprint_r.part.0+0xfc>
8113342c:	30800217 	ldw	r2,8(r6)
81133430:	35800017 	ldw	r22,0(r6)
81133434:	10002926 	beq	r2,zero,811334dc <__sprint_r.part.0+0xf4>
81133438:	2827883a 	mov	r19,r5
8113343c:	2029883a 	mov	r20,r4
81133440:	b5c00104 	addi	r23,r22,4
81133444:	04bfffc4 	movi	r18,-1
81133448:	bc400017 	ldw	r17,0(r23)
8113344c:	b4000017 	ldw	r16,0(r22)
81133450:	0039883a 	mov	fp,zero
81133454:	8822d0ba 	srli	r17,r17,2
81133458:	8800031e 	bne	r17,zero,81133468 <__sprint_r.part.0+0x80>
8113345c:	00001806 	br	811334c0 <__sprint_r.part.0+0xd8>
81133460:	84000104 	addi	r16,r16,4
81133464:	8f001526 	beq	r17,fp,811334bc <__sprint_r.part.0+0xd4>
81133468:	81400017 	ldw	r5,0(r16)
8113346c:	980d883a 	mov	r6,r19
81133470:	a009883a 	mov	r4,r20
81133474:	1134d8c0 	call	81134d8c <_fputwc_r>
81133478:	e7000044 	addi	fp,fp,1
8113347c:	14bff81e 	bne	r2,r18,81133460 <__reset+0xfb113460>
81133480:	9005883a 	mov	r2,r18
81133484:	a8000215 	stw	zero,8(r21)
81133488:	a8000115 	stw	zero,4(r21)
8113348c:	dfc00917 	ldw	ra,36(sp)
81133490:	df000817 	ldw	fp,32(sp)
81133494:	ddc00717 	ldw	r23,28(sp)
81133498:	dd800617 	ldw	r22,24(sp)
8113349c:	dd400517 	ldw	r21,20(sp)
811334a0:	dd000417 	ldw	r20,16(sp)
811334a4:	dcc00317 	ldw	r19,12(sp)
811334a8:	dc800217 	ldw	r18,8(sp)
811334ac:	dc400117 	ldw	r17,4(sp)
811334b0:	dc000017 	ldw	r16,0(sp)
811334b4:	dec00a04 	addi	sp,sp,40
811334b8:	f800283a 	ret
811334bc:	a8800217 	ldw	r2,8(r21)
811334c0:	8c63883a 	add	r17,r17,r17
811334c4:	8c63883a 	add	r17,r17,r17
811334c8:	1445c83a 	sub	r2,r2,r17
811334cc:	a8800215 	stw	r2,8(r21)
811334d0:	b5800204 	addi	r22,r22,8
811334d4:	bdc00204 	addi	r23,r23,8
811334d8:	103fdb1e 	bne	r2,zero,81133448 <__reset+0xfb113448>
811334dc:	0005883a 	mov	r2,zero
811334e0:	003fe806 	br	81133484 <__reset+0xfb113484>
811334e4:	112db500 	call	8112db50 <__sfvwrite_r>
811334e8:	003fe606 	br	81133484 <__reset+0xfb113484>

811334ec <__sprint_r>:
811334ec:	30c00217 	ldw	r3,8(r6)
811334f0:	18000126 	beq	r3,zero,811334f8 <__sprint_r+0xc>
811334f4:	11333e81 	jmpi	811333e8 <__sprint_r.part.0>
811334f8:	30000115 	stw	zero,4(r6)
811334fc:	0005883a 	mov	r2,zero
81133500:	f800283a 	ret

81133504 <___vfiprintf_internal_r>:
81133504:	deffc904 	addi	sp,sp,-220
81133508:	de00012e 	bgeu	sp,et,81133510 <___vfiprintf_internal_r+0xc>
8113350c:	003b68fa 	trap	3
81133510:	df003515 	stw	fp,212(sp)
81133514:	dd003115 	stw	r20,196(sp)
81133518:	dfc03615 	stw	ra,216(sp)
8113351c:	ddc03415 	stw	r23,208(sp)
81133520:	dd803315 	stw	r22,204(sp)
81133524:	dd403215 	stw	r21,200(sp)
81133528:	dcc03015 	stw	r19,192(sp)
8113352c:	dc802f15 	stw	r18,188(sp)
81133530:	dc402e15 	stw	r17,184(sp)
81133534:	dc002d15 	stw	r16,180(sp)
81133538:	d9002015 	stw	r4,128(sp)
8113353c:	d9c02215 	stw	r7,136(sp)
81133540:	2829883a 	mov	r20,r5
81133544:	3039883a 	mov	fp,r6
81133548:	20000226 	beq	r4,zero,81133554 <___vfiprintf_internal_r+0x50>
8113354c:	20800e17 	ldw	r2,56(r4)
81133550:	1000cf26 	beq	r2,zero,81133890 <___vfiprintf_internal_r+0x38c>
81133554:	a080030b 	ldhu	r2,12(r20)
81133558:	10c8000c 	andi	r3,r2,8192
8113355c:	1800061e 	bne	r3,zero,81133578 <___vfiprintf_internal_r+0x74>
81133560:	a1001917 	ldw	r4,100(r20)
81133564:	00f7ffc4 	movi	r3,-8193
81133568:	10880014 	ori	r2,r2,8192
8113356c:	20c6703a 	and	r3,r4,r3
81133570:	a080030d 	sth	r2,12(r20)
81133574:	a0c01915 	stw	r3,100(r20)
81133578:	10c0020c 	andi	r3,r2,8
8113357c:	1800a926 	beq	r3,zero,81133824 <___vfiprintf_internal_r+0x320>
81133580:	a0c00417 	ldw	r3,16(r20)
81133584:	1800a726 	beq	r3,zero,81133824 <___vfiprintf_internal_r+0x320>
81133588:	1080068c 	andi	r2,r2,26
8113358c:	00c00284 	movi	r3,10
81133590:	10c0ac26 	beq	r2,r3,81133844 <___vfiprintf_internal_r+0x340>
81133594:	da801a04 	addi	r10,sp,104
81133598:	da801e15 	stw	r10,120(sp)
8113359c:	d8801e17 	ldw	r2,120(sp)
811335a0:	da8019c4 	addi	r10,sp,103
811335a4:	05a04574 	movhi	r22,33045
811335a8:	05e04574 	movhi	r23,33045
811335ac:	da801f15 	stw	r10,124(sp)
811335b0:	1295c83a 	sub	r10,r2,r10
811335b4:	b58a2704 	addi	r22,r22,10396
811335b8:	bdca2304 	addi	r23,r23,10380
811335bc:	dec01a15 	stw	sp,104(sp)
811335c0:	d8001c15 	stw	zero,112(sp)
811335c4:	d8001b15 	stw	zero,108(sp)
811335c8:	d8002615 	stw	zero,152(sp)
811335cc:	d8002315 	stw	zero,140(sp)
811335d0:	da802715 	stw	r10,156(sp)
811335d4:	d811883a 	mov	r8,sp
811335d8:	dd002115 	stw	r20,132(sp)
811335dc:	e021883a 	mov	r16,fp
811335e0:	80800007 	ldb	r2,0(r16)
811335e4:	1003ea26 	beq	r2,zero,81134590 <___vfiprintf_internal_r+0x108c>
811335e8:	00c00944 	movi	r3,37
811335ec:	8025883a 	mov	r18,r16
811335f0:	10c0021e 	bne	r2,r3,811335fc <___vfiprintf_internal_r+0xf8>
811335f4:	00001606 	br	81133650 <___vfiprintf_internal_r+0x14c>
811335f8:	10c00326 	beq	r2,r3,81133608 <___vfiprintf_internal_r+0x104>
811335fc:	94800044 	addi	r18,r18,1
81133600:	90800007 	ldb	r2,0(r18)
81133604:	103ffc1e 	bne	r2,zero,811335f8 <__reset+0xfb1135f8>
81133608:	9423c83a 	sub	r17,r18,r16
8113360c:	88001026 	beq	r17,zero,81133650 <___vfiprintf_internal_r+0x14c>
81133610:	d8c01c17 	ldw	r3,112(sp)
81133614:	d8801b17 	ldw	r2,108(sp)
81133618:	44000015 	stw	r16,0(r8)
8113361c:	88c7883a 	add	r3,r17,r3
81133620:	10800044 	addi	r2,r2,1
81133624:	44400115 	stw	r17,4(r8)
81133628:	d8c01c15 	stw	r3,112(sp)
8113362c:	d8801b15 	stw	r2,108(sp)
81133630:	010001c4 	movi	r4,7
81133634:	2080760e 	bge	r4,r2,81133810 <___vfiprintf_internal_r+0x30c>
81133638:	1803821e 	bne	r3,zero,81134444 <___vfiprintf_internal_r+0xf40>
8113363c:	da802317 	ldw	r10,140(sp)
81133640:	d8001b15 	stw	zero,108(sp)
81133644:	d811883a 	mov	r8,sp
81133648:	5455883a 	add	r10,r10,r17
8113364c:	da802315 	stw	r10,140(sp)
81133650:	90800007 	ldb	r2,0(r18)
81133654:	10044626 	beq	r2,zero,81134770 <___vfiprintf_internal_r+0x126c>
81133658:	90c00047 	ldb	r3,1(r18)
8113365c:	94000044 	addi	r16,r18,1
81133660:	d8001d85 	stb	zero,118(sp)
81133664:	0009883a 	mov	r4,zero
81133668:	000f883a 	mov	r7,zero
8113366c:	027fffc4 	movi	r9,-1
81133670:	0023883a 	mov	r17,zero
81133674:	0029883a 	mov	r20,zero
81133678:	01401604 	movi	r5,88
8113367c:	01800244 	movi	r6,9
81133680:	03400a84 	movi	r13,42
81133684:	03001b04 	movi	r12,108
81133688:	84000044 	addi	r16,r16,1
8113368c:	18bff804 	addi	r2,r3,-32
81133690:	28827336 	bltu	r5,r2,81134060 <___vfiprintf_internal_r+0xb5c>
81133694:	100490ba 	slli	r2,r2,2
81133698:	02a044f4 	movhi	r10,33043
8113369c:	528dab04 	addi	r10,r10,13996
811336a0:	1285883a 	add	r2,r2,r10
811336a4:	10800017 	ldw	r2,0(r2)
811336a8:	1000683a 	jmp	r2
811336ac:	81133d94 	ori	r4,r16,19702
811336b0:	81134060 	cmpeqi	r4,r16,19713
811336b4:	81134060 	cmpeqi	r4,r16,19713
811336b8:	81133db4 	orhi	r4,r16,19702
811336bc:	81134060 	cmpeqi	r4,r16,19713
811336c0:	81134060 	cmpeqi	r4,r16,19713
811336c4:	81134060 	cmpeqi	r4,r16,19713
811336c8:	81134060 	cmpeqi	r4,r16,19713
811336cc:	81134060 	cmpeqi	r4,r16,19713
811336d0:	81134060 	cmpeqi	r4,r16,19713
811336d4:	81133f9c 	xori	r4,r16,19710
811336d8:	81133fb8 	rdprs	r4,r16,19710
811336dc:	81134060 	cmpeqi	r4,r16,19713
811336e0:	811338a0 	cmpeqi	r4,r16,19682
811336e4:	81133fc8 	cmpgei	r4,r16,19711
811336e8:	81134060 	cmpeqi	r4,r16,19713
811336ec:	81133dc0 	call	881133dc <__reset+0x20f33dc>
811336f0:	81133dcc 	andi	r4,r16,19703
811336f4:	81133dcc 	andi	r4,r16,19703
811336f8:	81133dcc 	andi	r4,r16,19703
811336fc:	81133dcc 	andi	r4,r16,19703
81133700:	81133dcc 	andi	r4,r16,19703
81133704:	81133dcc 	andi	r4,r16,19703
81133708:	81133dcc 	andi	r4,r16,19703
8113370c:	81133dcc 	andi	r4,r16,19703
81133710:	81133dcc 	andi	r4,r16,19703
81133714:	81134060 	cmpeqi	r4,r16,19713
81133718:	81134060 	cmpeqi	r4,r16,19713
8113371c:	81134060 	cmpeqi	r4,r16,19713
81133720:	81134060 	cmpeqi	r4,r16,19713
81133724:	81134060 	cmpeqi	r4,r16,19713
81133728:	81134060 	cmpeqi	r4,r16,19713
8113372c:	81134060 	cmpeqi	r4,r16,19713
81133730:	81134060 	cmpeqi	r4,r16,19713
81133734:	81134060 	cmpeqi	r4,r16,19713
81133738:	81134060 	cmpeqi	r4,r16,19713
8113373c:	81133df8 	rdprs	r4,r16,19703
81133740:	81134060 	cmpeqi	r4,r16,19713
81133744:	81134060 	cmpeqi	r4,r16,19713
81133748:	81134060 	cmpeqi	r4,r16,19713
8113374c:	81134060 	cmpeqi	r4,r16,19713
81133750:	81134060 	cmpeqi	r4,r16,19713
81133754:	81134060 	cmpeqi	r4,r16,19713
81133758:	81134060 	cmpeqi	r4,r16,19713
8113375c:	81134060 	cmpeqi	r4,r16,19713
81133760:	81134060 	cmpeqi	r4,r16,19713
81133764:	81134060 	cmpeqi	r4,r16,19713
81133768:	81133e30 	cmpltui	r4,r16,19704
8113376c:	81134060 	cmpeqi	r4,r16,19713
81133770:	81134060 	cmpeqi	r4,r16,19713
81133774:	81134060 	cmpeqi	r4,r16,19713
81133778:	81134060 	cmpeqi	r4,r16,19713
8113377c:	81134060 	cmpeqi	r4,r16,19713
81133780:	81133e88 	cmpgei	r4,r16,19706
81133784:	81134060 	cmpeqi	r4,r16,19713
81133788:	81134060 	cmpeqi	r4,r16,19713
8113378c:	81133ef8 	rdprs	r4,r16,19707
81133790:	81134060 	cmpeqi	r4,r16,19713
81133794:	81134060 	cmpeqi	r4,r16,19713
81133798:	81134060 	cmpeqi	r4,r16,19713
8113379c:	81134060 	cmpeqi	r4,r16,19713
811337a0:	81134060 	cmpeqi	r4,r16,19713
811337a4:	81134060 	cmpeqi	r4,r16,19713
811337a8:	81134060 	cmpeqi	r4,r16,19713
811337ac:	81134060 	cmpeqi	r4,r16,19713
811337b0:	81134060 	cmpeqi	r4,r16,19713
811337b4:	81134060 	cmpeqi	r4,r16,19713
811337b8:	81133ca4 	muli	r4,r16,19698
811337bc:	81133cd0 	cmplti	r4,r16,19699
811337c0:	81134060 	cmpeqi	r4,r16,19713
811337c4:	81134060 	cmpeqi	r4,r16,19713
811337c8:	81134060 	cmpeqi	r4,r16,19713
811337cc:	81134008 	cmpgei	r4,r16,19712
811337d0:	81133cd0 	cmplti	r4,r16,19699
811337d4:	81134060 	cmpeqi	r4,r16,19713
811337d8:	81134060 	cmpeqi	r4,r16,19713
811337dc:	81133b64 	muli	r4,r16,19693
811337e0:	81134060 	cmpeqi	r4,r16,19713
811337e4:	81133b74 	orhi	r4,r16,19693
811337e8:	81133bb0 	cmpltui	r4,r16,19694
811337ec:	811338ac 	andhi	r4,r16,19682
811337f0:	81133b58 	cmpnei	r4,r16,19693
811337f4:	81134060 	cmpeqi	r4,r16,19713
811337f8:	81133f34 	orhi	r4,r16,19708
811337fc:	81134060 	cmpeqi	r4,r16,19713
81133800:	81133f8c 	andi	r4,r16,19710
81133804:	81134060 	cmpeqi	r4,r16,19713
81133808:	81134060 	cmpeqi	r4,r16,19713
8113380c:	81133c50 	cmplti	r4,r16,19697
81133810:	42000204 	addi	r8,r8,8
81133814:	da802317 	ldw	r10,140(sp)
81133818:	5455883a 	add	r10,r10,r17
8113381c:	da802315 	stw	r10,140(sp)
81133820:	003f8b06 	br	81133650 <__reset+0xfb113650>
81133824:	d9002017 	ldw	r4,128(sp)
81133828:	a00b883a 	mov	r5,r20
8113382c:	112b3300 	call	8112b330 <__swsetup_r>
81133830:	1003b11e 	bne	r2,zero,811346f8 <___vfiprintf_internal_r+0x11f4>
81133834:	a080030b 	ldhu	r2,12(r20)
81133838:	00c00284 	movi	r3,10
8113383c:	1080068c 	andi	r2,r2,26
81133840:	10ff541e 	bne	r2,r3,81133594 <__reset+0xfb113594>
81133844:	a080038f 	ldh	r2,14(r20)
81133848:	103f5216 	blt	r2,zero,81133594 <__reset+0xfb113594>
8113384c:	d9c02217 	ldw	r7,136(sp)
81133850:	d9002017 	ldw	r4,128(sp)
81133854:	e00d883a 	mov	r6,fp
81133858:	a00b883a 	mov	r5,r20
8113385c:	11349840 	call	81134984 <__sbprintf>
81133860:	dfc03617 	ldw	ra,216(sp)
81133864:	df003517 	ldw	fp,212(sp)
81133868:	ddc03417 	ldw	r23,208(sp)
8113386c:	dd803317 	ldw	r22,204(sp)
81133870:	dd403217 	ldw	r21,200(sp)
81133874:	dd003117 	ldw	r20,196(sp)
81133878:	dcc03017 	ldw	r19,192(sp)
8113387c:	dc802f17 	ldw	r18,188(sp)
81133880:	dc402e17 	ldw	r17,184(sp)
81133884:	dc002d17 	ldw	r16,180(sp)
81133888:	dec03704 	addi	sp,sp,220
8113388c:	f800283a 	ret
81133890:	112d3a00 	call	8112d3a0 <__sinit>
81133894:	003f2f06 	br	81133554 <__reset+0xfb113554>
81133898:	0463c83a 	sub	r17,zero,r17
8113389c:	d8802215 	stw	r2,136(sp)
811338a0:	a5000114 	ori	r20,r20,4
811338a4:	80c00007 	ldb	r3,0(r16)
811338a8:	003f7706 	br	81133688 <__reset+0xfb113688>
811338ac:	00800c04 	movi	r2,48
811338b0:	da802217 	ldw	r10,136(sp)
811338b4:	d8801d05 	stb	r2,116(sp)
811338b8:	00801e04 	movi	r2,120
811338bc:	d8801d45 	stb	r2,117(sp)
811338c0:	d8001d85 	stb	zero,118(sp)
811338c4:	50c00104 	addi	r3,r10,4
811338c8:	54800017 	ldw	r18,0(r10)
811338cc:	0027883a 	mov	r19,zero
811338d0:	a0800094 	ori	r2,r20,2
811338d4:	48030b16 	blt	r9,zero,81134504 <___vfiprintf_internal_r+0x1000>
811338d8:	00bfdfc4 	movi	r2,-129
811338dc:	a096703a 	and	r11,r20,r2
811338e0:	d8c02215 	stw	r3,136(sp)
811338e4:	5d000094 	ori	r20,r11,2
811338e8:	90032b1e 	bne	r18,zero,81134598 <___vfiprintf_internal_r+0x1094>
811338ec:	00a04574 	movhi	r2,33045
811338f0:	10899104 	addi	r2,r2,9796
811338f4:	d8802615 	stw	r2,152(sp)
811338f8:	0039883a 	mov	fp,zero
811338fc:	48017b1e 	bne	r9,zero,81133eec <___vfiprintf_internal_r+0x9e8>
81133900:	0013883a 	mov	r9,zero
81133904:	0027883a 	mov	r19,zero
81133908:	dd401a04 	addi	r21,sp,104
8113390c:	4825883a 	mov	r18,r9
81133910:	4cc0010e 	bge	r9,r19,81133918 <___vfiprintf_internal_r+0x414>
81133914:	9825883a 	mov	r18,r19
81133918:	e7003fcc 	andi	fp,fp,255
8113391c:	e700201c 	xori	fp,fp,128
81133920:	e73fe004 	addi	fp,fp,-128
81133924:	e0000126 	beq	fp,zero,8113392c <___vfiprintf_internal_r+0x428>
81133928:	94800044 	addi	r18,r18,1
8113392c:	a380008c 	andi	r14,r20,2
81133930:	70000126 	beq	r14,zero,81133938 <___vfiprintf_internal_r+0x434>
81133934:	94800084 	addi	r18,r18,2
81133938:	a700210c 	andi	fp,r20,132
8113393c:	e001df1e 	bne	fp,zero,811340bc <___vfiprintf_internal_r+0xbb8>
81133940:	8c87c83a 	sub	r3,r17,r18
81133944:	00c1dd0e 	bge	zero,r3,811340bc <___vfiprintf_internal_r+0xbb8>
81133948:	01c00404 	movi	r7,16
8113394c:	d8801c17 	ldw	r2,112(sp)
81133950:	38c3ad0e 	bge	r7,r3,81134808 <___vfiprintf_internal_r+0x1304>
81133954:	02a04574 	movhi	r10,33045
81133958:	528a2704 	addi	r10,r10,10396
8113395c:	dc002915 	stw	r16,164(sp)
81133960:	d9801b17 	ldw	r6,108(sp)
81133964:	da802415 	stw	r10,144(sp)
81133968:	03c001c4 	movi	r15,7
8113396c:	da402515 	stw	r9,148(sp)
81133970:	db802815 	stw	r14,160(sp)
81133974:	1821883a 	mov	r16,r3
81133978:	00000506 	br	81133990 <___vfiprintf_internal_r+0x48c>
8113397c:	31400084 	addi	r5,r6,2
81133980:	42000204 	addi	r8,r8,8
81133984:	200d883a 	mov	r6,r4
81133988:	843ffc04 	addi	r16,r16,-16
8113398c:	3c000d0e 	bge	r7,r16,811339c4 <___vfiprintf_internal_r+0x4c0>
81133990:	10800404 	addi	r2,r2,16
81133994:	31000044 	addi	r4,r6,1
81133998:	45800015 	stw	r22,0(r8)
8113399c:	41c00115 	stw	r7,4(r8)
811339a0:	d8801c15 	stw	r2,112(sp)
811339a4:	d9001b15 	stw	r4,108(sp)
811339a8:	793ff40e 	bge	r15,r4,8113397c <__reset+0xfb11397c>
811339ac:	1001b51e 	bne	r2,zero,81134084 <___vfiprintf_internal_r+0xb80>
811339b0:	843ffc04 	addi	r16,r16,-16
811339b4:	000d883a 	mov	r6,zero
811339b8:	01400044 	movi	r5,1
811339bc:	d811883a 	mov	r8,sp
811339c0:	3c3ff316 	blt	r7,r16,81133990 <__reset+0xfb113990>
811339c4:	8007883a 	mov	r3,r16
811339c8:	da402517 	ldw	r9,148(sp)
811339cc:	db802817 	ldw	r14,160(sp)
811339d0:	dc002917 	ldw	r16,164(sp)
811339d4:	da802417 	ldw	r10,144(sp)
811339d8:	1885883a 	add	r2,r3,r2
811339dc:	40c00115 	stw	r3,4(r8)
811339e0:	42800015 	stw	r10,0(r8)
811339e4:	d8801c15 	stw	r2,112(sp)
811339e8:	d9401b15 	stw	r5,108(sp)
811339ec:	00c001c4 	movi	r3,7
811339f0:	19426016 	blt	r3,r5,81134374 <___vfiprintf_internal_r+0xe70>
811339f4:	d8c01d87 	ldb	r3,118(sp)
811339f8:	42000204 	addi	r8,r8,8
811339fc:	29000044 	addi	r4,r5,1
81133a00:	1801b31e 	bne	r3,zero,811340d0 <___vfiprintf_internal_r+0xbcc>
81133a04:	7001c026 	beq	r14,zero,81134108 <___vfiprintf_internal_r+0xc04>
81133a08:	d8c01d04 	addi	r3,sp,116
81133a0c:	10800084 	addi	r2,r2,2
81133a10:	40c00015 	stw	r3,0(r8)
81133a14:	00c00084 	movi	r3,2
81133a18:	40c00115 	stw	r3,4(r8)
81133a1c:	d8801c15 	stw	r2,112(sp)
81133a20:	d9001b15 	stw	r4,108(sp)
81133a24:	00c001c4 	movi	r3,7
81133a28:	1902650e 	bge	r3,r4,811343c0 <___vfiprintf_internal_r+0xebc>
81133a2c:	10029a1e 	bne	r2,zero,81134498 <___vfiprintf_internal_r+0xf94>
81133a30:	00c02004 	movi	r3,128
81133a34:	01000044 	movi	r4,1
81133a38:	000b883a 	mov	r5,zero
81133a3c:	d811883a 	mov	r8,sp
81133a40:	e0c1b31e 	bne	fp,r3,81134110 <___vfiprintf_internal_r+0xc0c>
81133a44:	8cb9c83a 	sub	fp,r17,r18
81133a48:	0701b10e 	bge	zero,fp,81134110 <___vfiprintf_internal_r+0xc0c>
81133a4c:	01c00404 	movi	r7,16
81133a50:	3f03890e 	bge	r7,fp,81134878 <___vfiprintf_internal_r+0x1374>
81133a54:	00e04574 	movhi	r3,33045
81133a58:	18ca2304 	addi	r3,r3,10380
81133a5c:	d8c02415 	stw	r3,144(sp)
81133a60:	8007883a 	mov	r3,r16
81133a64:	034001c4 	movi	r13,7
81133a68:	e021883a 	mov	r16,fp
81133a6c:	da402515 	stw	r9,148(sp)
81133a70:	1839883a 	mov	fp,r3
81133a74:	00000506 	br	81133a8c <___vfiprintf_internal_r+0x588>
81133a78:	29800084 	addi	r6,r5,2
81133a7c:	42000204 	addi	r8,r8,8
81133a80:	180b883a 	mov	r5,r3
81133a84:	843ffc04 	addi	r16,r16,-16
81133a88:	3c000d0e 	bge	r7,r16,81133ac0 <___vfiprintf_internal_r+0x5bc>
81133a8c:	10800404 	addi	r2,r2,16
81133a90:	28c00044 	addi	r3,r5,1
81133a94:	45c00015 	stw	r23,0(r8)
81133a98:	41c00115 	stw	r7,4(r8)
81133a9c:	d8801c15 	stw	r2,112(sp)
81133aa0:	d8c01b15 	stw	r3,108(sp)
81133aa4:	68fff40e 	bge	r13,r3,81133a78 <__reset+0xfb113a78>
81133aa8:	1002241e 	bne	r2,zero,8113433c <___vfiprintf_internal_r+0xe38>
81133aac:	843ffc04 	addi	r16,r16,-16
81133ab0:	01800044 	movi	r6,1
81133ab4:	000b883a 	mov	r5,zero
81133ab8:	d811883a 	mov	r8,sp
81133abc:	3c3ff316 	blt	r7,r16,81133a8c <__reset+0xfb113a8c>
81133ac0:	da402517 	ldw	r9,148(sp)
81133ac4:	e007883a 	mov	r3,fp
81133ac8:	8039883a 	mov	fp,r16
81133acc:	1821883a 	mov	r16,r3
81133ad0:	d8c02417 	ldw	r3,144(sp)
81133ad4:	1705883a 	add	r2,r2,fp
81133ad8:	47000115 	stw	fp,4(r8)
81133adc:	40c00015 	stw	r3,0(r8)
81133ae0:	d8801c15 	stw	r2,112(sp)
81133ae4:	d9801b15 	stw	r6,108(sp)
81133ae8:	00c001c4 	movi	r3,7
81133aec:	19827616 	blt	r3,r6,811344c8 <___vfiprintf_internal_r+0xfc4>
81133af0:	4cf9c83a 	sub	fp,r9,r19
81133af4:	42000204 	addi	r8,r8,8
81133af8:	31000044 	addi	r4,r6,1
81133afc:	300b883a 	mov	r5,r6
81133b00:	07018516 	blt	zero,fp,81134118 <___vfiprintf_internal_r+0xc14>
81133b04:	9885883a 	add	r2,r19,r2
81133b08:	45400015 	stw	r21,0(r8)
81133b0c:	44c00115 	stw	r19,4(r8)
81133b10:	d8801c15 	stw	r2,112(sp)
81133b14:	d9001b15 	stw	r4,108(sp)
81133b18:	00c001c4 	movi	r3,7
81133b1c:	1901dd0e 	bge	r3,r4,81134294 <___vfiprintf_internal_r+0xd90>
81133b20:	1002401e 	bne	r2,zero,81134424 <___vfiprintf_internal_r+0xf20>
81133b24:	d8001b15 	stw	zero,108(sp)
81133b28:	a2c0010c 	andi	r11,r20,4
81133b2c:	58000226 	beq	r11,zero,81133b38 <___vfiprintf_internal_r+0x634>
81133b30:	8ca7c83a 	sub	r19,r17,r18
81133b34:	04c2f216 	blt	zero,r19,81134700 <___vfiprintf_internal_r+0x11fc>
81133b38:	8c80010e 	bge	r17,r18,81133b40 <___vfiprintf_internal_r+0x63c>
81133b3c:	9023883a 	mov	r17,r18
81133b40:	da802317 	ldw	r10,140(sp)
81133b44:	5455883a 	add	r10,r10,r17
81133b48:	da802315 	stw	r10,140(sp)
81133b4c:	d8001b15 	stw	zero,108(sp)
81133b50:	d811883a 	mov	r8,sp
81133b54:	003ea206 	br	811335e0 <__reset+0xfb1135e0>
81133b58:	a5000814 	ori	r20,r20,32
81133b5c:	80c00007 	ldb	r3,0(r16)
81133b60:	003ec906 	br	81133688 <__reset+0xfb113688>
81133b64:	80c00007 	ldb	r3,0(r16)
81133b68:	1b030926 	beq	r3,r12,81134790 <___vfiprintf_internal_r+0x128c>
81133b6c:	a5000414 	ori	r20,r20,16
81133b70:	003ec506 	br	81133688 <__reset+0xfb113688>
81133b74:	21003fcc 	andi	r4,r4,255
81133b78:	20035e1e 	bne	r4,zero,811348f4 <___vfiprintf_internal_r+0x13f0>
81133b7c:	a080080c 	andi	r2,r20,32
81133b80:	1002a526 	beq	r2,zero,81134618 <___vfiprintf_internal_r+0x1114>
81133b84:	da802217 	ldw	r10,136(sp)
81133b88:	50800017 	ldw	r2,0(r10)
81133b8c:	da802317 	ldw	r10,140(sp)
81133b90:	5007d7fa 	srai	r3,r10,31
81133b94:	da802217 	ldw	r10,136(sp)
81133b98:	10c00115 	stw	r3,4(r2)
81133b9c:	52800104 	addi	r10,r10,4
81133ba0:	da802215 	stw	r10,136(sp)
81133ba4:	da802317 	ldw	r10,140(sp)
81133ba8:	12800015 	stw	r10,0(r2)
81133bac:	003e8c06 	br	811335e0 <__reset+0xfb1135e0>
81133bb0:	21003fcc 	andi	r4,r4,255
81133bb4:	2003511e 	bne	r4,zero,811348fc <___vfiprintf_internal_r+0x13f8>
81133bb8:	a080080c 	andi	r2,r20,32
81133bbc:	1000a126 	beq	r2,zero,81133e44 <___vfiprintf_internal_r+0x940>
81133bc0:	da802217 	ldw	r10,136(sp)
81133bc4:	d8001d85 	stb	zero,118(sp)
81133bc8:	50800204 	addi	r2,r10,8
81133bcc:	54800017 	ldw	r18,0(r10)
81133bd0:	54c00117 	ldw	r19,4(r10)
81133bd4:	4802b416 	blt	r9,zero,811346a8 <___vfiprintf_internal_r+0x11a4>
81133bd8:	013fdfc4 	movi	r4,-129
81133bdc:	94c6b03a 	or	r3,r18,r19
81133be0:	d8802215 	stw	r2,136(sp)
81133be4:	a128703a 	and	r20,r20,r4
81133be8:	1800a226 	beq	r3,zero,81133e74 <___vfiprintf_internal_r+0x970>
81133bec:	0039883a 	mov	fp,zero
81133bf0:	dd401a04 	addi	r21,sp,104
81133bf4:	9006d0fa 	srli	r3,r18,3
81133bf8:	9808977a 	slli	r4,r19,29
81133bfc:	9826d0fa 	srli	r19,r19,3
81133c00:	948001cc 	andi	r18,r18,7
81133c04:	90800c04 	addi	r2,r18,48
81133c08:	ad7fffc4 	addi	r21,r21,-1
81133c0c:	20e4b03a 	or	r18,r4,r3
81133c10:	a8800005 	stb	r2,0(r21)
81133c14:	94c6b03a 	or	r3,r18,r19
81133c18:	183ff61e 	bne	r3,zero,81133bf4 <__reset+0xfb113bf4>
81133c1c:	a0c0004c 	andi	r3,r20,1
81133c20:	18005926 	beq	r3,zero,81133d88 <___vfiprintf_internal_r+0x884>
81133c24:	10803fcc 	andi	r2,r2,255
81133c28:	1080201c 	xori	r2,r2,128
81133c2c:	10bfe004 	addi	r2,r2,-128
81133c30:	00c00c04 	movi	r3,48
81133c34:	10c05426 	beq	r2,r3,81133d88 <___vfiprintf_internal_r+0x884>
81133c38:	da801e17 	ldw	r10,120(sp)
81133c3c:	a8bfffc4 	addi	r2,r21,-1
81133c40:	a8ffffc5 	stb	r3,-1(r21)
81133c44:	50a7c83a 	sub	r19,r10,r2
81133c48:	102b883a 	mov	r21,r2
81133c4c:	003f2f06 	br	8113390c <__reset+0xfb11390c>
81133c50:	21003fcc 	andi	r4,r4,255
81133c54:	2003421e 	bne	r4,zero,81134960 <___vfiprintf_internal_r+0x145c>
81133c58:	00a04574 	movhi	r2,33045
81133c5c:	10899104 	addi	r2,r2,9796
81133c60:	d8802615 	stw	r2,152(sp)
81133c64:	a080080c 	andi	r2,r20,32
81133c68:	1000aa26 	beq	r2,zero,81133f14 <___vfiprintf_internal_r+0xa10>
81133c6c:	da802217 	ldw	r10,136(sp)
81133c70:	54800017 	ldw	r18,0(r10)
81133c74:	54c00117 	ldw	r19,4(r10)
81133c78:	52800204 	addi	r10,r10,8
81133c7c:	da802215 	stw	r10,136(sp)
81133c80:	a080004c 	andi	r2,r20,1
81133c84:	1001d226 	beq	r2,zero,811343d0 <___vfiprintf_internal_r+0xecc>
81133c88:	94c4b03a 	or	r2,r18,r19
81133c8c:	1002351e 	bne	r2,zero,81134564 <___vfiprintf_internal_r+0x1060>
81133c90:	d8001d85 	stb	zero,118(sp)
81133c94:	48022216 	blt	r9,zero,81134520 <___vfiprintf_internal_r+0x101c>
81133c98:	00bfdfc4 	movi	r2,-129
81133c9c:	a0a8703a 	and	r20,r20,r2
81133ca0:	003f1506 	br	811338f8 <__reset+0xfb1138f8>
81133ca4:	da802217 	ldw	r10,136(sp)
81133ca8:	04800044 	movi	r18,1
81133cac:	d8001d85 	stb	zero,118(sp)
81133cb0:	50800017 	ldw	r2,0(r10)
81133cb4:	52800104 	addi	r10,r10,4
81133cb8:	da802215 	stw	r10,136(sp)
81133cbc:	d8801005 	stb	r2,64(sp)
81133cc0:	9027883a 	mov	r19,r18
81133cc4:	dd401004 	addi	r21,sp,64
81133cc8:	0013883a 	mov	r9,zero
81133ccc:	003f1706 	br	8113392c <__reset+0xfb11392c>
81133cd0:	21003fcc 	andi	r4,r4,255
81133cd4:	2003201e 	bne	r4,zero,81134958 <___vfiprintf_internal_r+0x1454>
81133cd8:	a080080c 	andi	r2,r20,32
81133cdc:	10004b26 	beq	r2,zero,81133e0c <___vfiprintf_internal_r+0x908>
81133ce0:	da802217 	ldw	r10,136(sp)
81133ce4:	50800117 	ldw	r2,4(r10)
81133ce8:	54800017 	ldw	r18,0(r10)
81133cec:	52800204 	addi	r10,r10,8
81133cf0:	da802215 	stw	r10,136(sp)
81133cf4:	1027883a 	mov	r19,r2
81133cf8:	10022c16 	blt	r2,zero,811345ac <___vfiprintf_internal_r+0x10a8>
81133cfc:	df001d83 	ldbu	fp,118(sp)
81133d00:	48007216 	blt	r9,zero,81133ecc <___vfiprintf_internal_r+0x9c8>
81133d04:	00ffdfc4 	movi	r3,-129
81133d08:	94c4b03a 	or	r2,r18,r19
81133d0c:	a0e8703a 	and	r20,r20,r3
81133d10:	1000cc26 	beq	r2,zero,81134044 <___vfiprintf_internal_r+0xb40>
81133d14:	98021026 	beq	r19,zero,81134558 <___vfiprintf_internal_r+0x1054>
81133d18:	dc402415 	stw	r17,144(sp)
81133d1c:	dc002515 	stw	r16,148(sp)
81133d20:	9823883a 	mov	r17,r19
81133d24:	9021883a 	mov	r16,r18
81133d28:	dd401a04 	addi	r21,sp,104
81133d2c:	4825883a 	mov	r18,r9
81133d30:	4027883a 	mov	r19,r8
81133d34:	8009883a 	mov	r4,r16
81133d38:	880b883a 	mov	r5,r17
81133d3c:	01800284 	movi	r6,10
81133d40:	000f883a 	mov	r7,zero
81133d44:	11362240 	call	81136224 <__umoddi3>
81133d48:	10800c04 	addi	r2,r2,48
81133d4c:	ad7fffc4 	addi	r21,r21,-1
81133d50:	8009883a 	mov	r4,r16
81133d54:	880b883a 	mov	r5,r17
81133d58:	a8800005 	stb	r2,0(r21)
81133d5c:	01800284 	movi	r6,10
81133d60:	000f883a 	mov	r7,zero
81133d64:	1135ca40 	call	81135ca4 <__udivdi3>
81133d68:	1021883a 	mov	r16,r2
81133d6c:	10c4b03a 	or	r2,r2,r3
81133d70:	1823883a 	mov	r17,r3
81133d74:	103fef1e 	bne	r2,zero,81133d34 <__reset+0xfb113d34>
81133d78:	dc402417 	ldw	r17,144(sp)
81133d7c:	dc002517 	ldw	r16,148(sp)
81133d80:	9013883a 	mov	r9,r18
81133d84:	9811883a 	mov	r8,r19
81133d88:	da801e17 	ldw	r10,120(sp)
81133d8c:	5567c83a 	sub	r19,r10,r21
81133d90:	003ede06 	br	8113390c <__reset+0xfb11390c>
81133d94:	38803fcc 	andi	r2,r7,255
81133d98:	1080201c 	xori	r2,r2,128
81133d9c:	10bfe004 	addi	r2,r2,-128
81133da0:	1002371e 	bne	r2,zero,81134680 <___vfiprintf_internal_r+0x117c>
81133da4:	01000044 	movi	r4,1
81133da8:	01c00804 	movi	r7,32
81133dac:	80c00007 	ldb	r3,0(r16)
81133db0:	003e3506 	br	81133688 <__reset+0xfb113688>
81133db4:	a5000054 	ori	r20,r20,1
81133db8:	80c00007 	ldb	r3,0(r16)
81133dbc:	003e3206 	br	81133688 <__reset+0xfb113688>
81133dc0:	a5002014 	ori	r20,r20,128
81133dc4:	80c00007 	ldb	r3,0(r16)
81133dc8:	003e2f06 	br	81133688 <__reset+0xfb113688>
81133dcc:	8015883a 	mov	r10,r16
81133dd0:	0023883a 	mov	r17,zero
81133dd4:	18bff404 	addi	r2,r3,-48
81133dd8:	50c00007 	ldb	r3,0(r10)
81133ddc:	8c4002a4 	muli	r17,r17,10
81133de0:	84000044 	addi	r16,r16,1
81133de4:	8015883a 	mov	r10,r16
81133de8:	1463883a 	add	r17,r2,r17
81133dec:	18bff404 	addi	r2,r3,-48
81133df0:	30bff92e 	bgeu	r6,r2,81133dd8 <__reset+0xfb113dd8>
81133df4:	003e2506 	br	8113368c <__reset+0xfb11368c>
81133df8:	21003fcc 	andi	r4,r4,255
81133dfc:	2002d41e 	bne	r4,zero,81134950 <___vfiprintf_internal_r+0x144c>
81133e00:	a5000414 	ori	r20,r20,16
81133e04:	a080080c 	andi	r2,r20,32
81133e08:	103fb51e 	bne	r2,zero,81133ce0 <__reset+0xfb113ce0>
81133e0c:	a080040c 	andi	r2,r20,16
81133e10:	1001f826 	beq	r2,zero,811345f4 <___vfiprintf_internal_r+0x10f0>
81133e14:	da802217 	ldw	r10,136(sp)
81133e18:	54800017 	ldw	r18,0(r10)
81133e1c:	52800104 	addi	r10,r10,4
81133e20:	da802215 	stw	r10,136(sp)
81133e24:	9027d7fa 	srai	r19,r18,31
81133e28:	9805883a 	mov	r2,r19
81133e2c:	003fb206 	br	81133cf8 <__reset+0xfb113cf8>
81133e30:	21003fcc 	andi	r4,r4,255
81133e34:	2002c41e 	bne	r4,zero,81134948 <___vfiprintf_internal_r+0x1444>
81133e38:	a5000414 	ori	r20,r20,16
81133e3c:	a080080c 	andi	r2,r20,32
81133e40:	103f5f1e 	bne	r2,zero,81133bc0 <__reset+0xfb113bc0>
81133e44:	a080040c 	andi	r2,r20,16
81133e48:	10020f26 	beq	r2,zero,81134688 <___vfiprintf_internal_r+0x1184>
81133e4c:	da802217 	ldw	r10,136(sp)
81133e50:	d8001d85 	stb	zero,118(sp)
81133e54:	0027883a 	mov	r19,zero
81133e58:	50800104 	addi	r2,r10,4
81133e5c:	54800017 	ldw	r18,0(r10)
81133e60:	48021116 	blt	r9,zero,811346a8 <___vfiprintf_internal_r+0x11a4>
81133e64:	00ffdfc4 	movi	r3,-129
81133e68:	d8802215 	stw	r2,136(sp)
81133e6c:	a0e8703a 	and	r20,r20,r3
81133e70:	903f5e1e 	bne	r18,zero,81133bec <__reset+0xfb113bec>
81133e74:	0039883a 	mov	fp,zero
81133e78:	4802a626 	beq	r9,zero,81134914 <___vfiprintf_internal_r+0x1410>
81133e7c:	0025883a 	mov	r18,zero
81133e80:	0027883a 	mov	r19,zero
81133e84:	003f5a06 	br	81133bf0 <__reset+0xfb113bf0>
81133e88:	21003fcc 	andi	r4,r4,255
81133e8c:	20029f1e 	bne	r4,zero,8113490c <___vfiprintf_internal_r+0x1408>
81133e90:	a5000414 	ori	r20,r20,16
81133e94:	a080080c 	andi	r2,r20,32
81133e98:	10005e1e 	bne	r2,zero,81134014 <___vfiprintf_internal_r+0xb10>
81133e9c:	a080040c 	andi	r2,r20,16
81133ea0:	1001a21e 	bne	r2,zero,8113452c <___vfiprintf_internal_r+0x1028>
81133ea4:	a080100c 	andi	r2,r20,64
81133ea8:	d8001d85 	stb	zero,118(sp)
81133eac:	da802217 	ldw	r10,136(sp)
81133eb0:	1002231e 	bne	r2,zero,81134740 <___vfiprintf_internal_r+0x123c>
81133eb4:	50800104 	addi	r2,r10,4
81133eb8:	54800017 	ldw	r18,0(r10)
81133ebc:	0027883a 	mov	r19,zero
81133ec0:	4801a00e 	bge	r9,zero,81134544 <___vfiprintf_internal_r+0x1040>
81133ec4:	d8802215 	stw	r2,136(sp)
81133ec8:	0039883a 	mov	fp,zero
81133ecc:	94c4b03a 	or	r2,r18,r19
81133ed0:	103f901e 	bne	r2,zero,81133d14 <__reset+0xfb113d14>
81133ed4:	00800044 	movi	r2,1
81133ed8:	10803fcc 	andi	r2,r2,255
81133edc:	00c00044 	movi	r3,1
81133ee0:	10c05926 	beq	r2,r3,81134048 <___vfiprintf_internal_r+0xb44>
81133ee4:	00c00084 	movi	r3,2
81133ee8:	10ffe41e 	bne	r2,r3,81133e7c <__reset+0xfb113e7c>
81133eec:	0025883a 	mov	r18,zero
81133ef0:	0027883a 	mov	r19,zero
81133ef4:	00013d06 	br	811343ec <___vfiprintf_internal_r+0xee8>
81133ef8:	21003fcc 	andi	r4,r4,255
81133efc:	2002811e 	bne	r4,zero,81134904 <___vfiprintf_internal_r+0x1400>
81133f00:	00a04574 	movhi	r2,33045
81133f04:	10898c04 	addi	r2,r2,9776
81133f08:	d8802615 	stw	r2,152(sp)
81133f0c:	a080080c 	andi	r2,r20,32
81133f10:	103f561e 	bne	r2,zero,81133c6c <__reset+0xfb113c6c>
81133f14:	a080040c 	andi	r2,r20,16
81133f18:	1001d126 	beq	r2,zero,81134660 <___vfiprintf_internal_r+0x115c>
81133f1c:	da802217 	ldw	r10,136(sp)
81133f20:	0027883a 	mov	r19,zero
81133f24:	54800017 	ldw	r18,0(r10)
81133f28:	52800104 	addi	r10,r10,4
81133f2c:	da802215 	stw	r10,136(sp)
81133f30:	003f5306 	br	81133c80 <__reset+0xfb113c80>
81133f34:	da802217 	ldw	r10,136(sp)
81133f38:	d8001d85 	stb	zero,118(sp)
81133f3c:	55400017 	ldw	r21,0(r10)
81133f40:	50c00104 	addi	r3,r10,4
81133f44:	a8024226 	beq	r21,zero,81134850 <___vfiprintf_internal_r+0x134c>
81133f48:	48021816 	blt	r9,zero,811347ac <___vfiprintf_internal_r+0x12a8>
81133f4c:	480d883a 	mov	r6,r9
81133f50:	000b883a 	mov	r5,zero
81133f54:	a809883a 	mov	r4,r21
81133f58:	d8c02a15 	stw	r3,168(sp)
81133f5c:	da002b15 	stw	r8,172(sp)
81133f60:	da402c15 	stw	r9,176(sp)
81133f64:	112e5c80 	call	8112e5c8 <memchr>
81133f68:	d8c02a17 	ldw	r3,168(sp)
81133f6c:	da002b17 	ldw	r8,172(sp)
81133f70:	da402c17 	ldw	r9,176(sp)
81133f74:	10024826 	beq	r2,zero,81134898 <___vfiprintf_internal_r+0x1394>
81133f78:	1567c83a 	sub	r19,r2,r21
81133f7c:	df001d83 	ldbu	fp,118(sp)
81133f80:	d8c02215 	stw	r3,136(sp)
81133f84:	0013883a 	mov	r9,zero
81133f88:	003e6006 	br	8113390c <__reset+0xfb11390c>
81133f8c:	21003fcc 	andi	r4,r4,255
81133f90:	203fc026 	beq	r4,zero,81133e94 <__reset+0xfb113e94>
81133f94:	d9c01d85 	stb	r7,118(sp)
81133f98:	003fbe06 	br	81133e94 <__reset+0xfb113e94>
81133f9c:	da802217 	ldw	r10,136(sp)
81133fa0:	54400017 	ldw	r17,0(r10)
81133fa4:	50800104 	addi	r2,r10,4
81133fa8:	883e3b16 	blt	r17,zero,81133898 <__reset+0xfb113898>
81133fac:	d8802215 	stw	r2,136(sp)
81133fb0:	80c00007 	ldb	r3,0(r16)
81133fb4:	003db406 	br	81133688 <__reset+0xfb113688>
81133fb8:	01000044 	movi	r4,1
81133fbc:	01c00ac4 	movi	r7,43
81133fc0:	80c00007 	ldb	r3,0(r16)
81133fc4:	003db006 	br	81133688 <__reset+0xfb113688>
81133fc8:	80c00007 	ldb	r3,0(r16)
81133fcc:	82800044 	addi	r10,r16,1
81133fd0:	1b423c26 	beq	r3,r13,811348c4 <___vfiprintf_internal_r+0x13c0>
81133fd4:	18bff404 	addi	r2,r3,-48
81133fd8:	0013883a 	mov	r9,zero
81133fdc:	30822b36 	bltu	r6,r2,8113488c <___vfiprintf_internal_r+0x1388>
81133fe0:	50c00007 	ldb	r3,0(r10)
81133fe4:	4a4002a4 	muli	r9,r9,10
81133fe8:	54000044 	addi	r16,r10,1
81133fec:	8015883a 	mov	r10,r16
81133ff0:	4893883a 	add	r9,r9,r2
81133ff4:	18bff404 	addi	r2,r3,-48
81133ff8:	30bff92e 	bgeu	r6,r2,81133fe0 <__reset+0xfb113fe0>
81133ffc:	483da30e 	bge	r9,zero,8113368c <__reset+0xfb11368c>
81134000:	027fffc4 	movi	r9,-1
81134004:	003da106 	br	8113368c <__reset+0xfb11368c>
81134008:	a5001014 	ori	r20,r20,64
8113400c:	80c00007 	ldb	r3,0(r16)
81134010:	003d9d06 	br	81133688 <__reset+0xfb113688>
81134014:	da802217 	ldw	r10,136(sp)
81134018:	d8001d85 	stb	zero,118(sp)
8113401c:	50c00204 	addi	r3,r10,8
81134020:	54800017 	ldw	r18,0(r10)
81134024:	54c00117 	ldw	r19,4(r10)
81134028:	4801ca16 	blt	r9,zero,81134754 <___vfiprintf_internal_r+0x1250>
8113402c:	013fdfc4 	movi	r4,-129
81134030:	94c4b03a 	or	r2,r18,r19
81134034:	d8c02215 	stw	r3,136(sp)
81134038:	a128703a 	and	r20,r20,r4
8113403c:	0039883a 	mov	fp,zero
81134040:	103f341e 	bne	r2,zero,81133d14 <__reset+0xfb113d14>
81134044:	483e2e26 	beq	r9,zero,81133900 <__reset+0xfb113900>
81134048:	0025883a 	mov	r18,zero
8113404c:	94800c04 	addi	r18,r18,48
81134050:	dc8019c5 	stb	r18,103(sp)
81134054:	dcc02717 	ldw	r19,156(sp)
81134058:	dd4019c4 	addi	r21,sp,103
8113405c:	003e2b06 	br	8113390c <__reset+0xfb11390c>
81134060:	21003fcc 	andi	r4,r4,255
81134064:	2002361e 	bne	r4,zero,81134940 <___vfiprintf_internal_r+0x143c>
81134068:	1801c126 	beq	r3,zero,81134770 <___vfiprintf_internal_r+0x126c>
8113406c:	04800044 	movi	r18,1
81134070:	d8c01005 	stb	r3,64(sp)
81134074:	d8001d85 	stb	zero,118(sp)
81134078:	9027883a 	mov	r19,r18
8113407c:	dd401004 	addi	r21,sp,64
81134080:	003f1106 	br	81133cc8 <__reset+0xfb113cc8>
81134084:	d9402117 	ldw	r5,132(sp)
81134088:	d9002017 	ldw	r4,128(sp)
8113408c:	d9801a04 	addi	r6,sp,104
81134090:	d9c02b15 	stw	r7,172(sp)
81134094:	dbc02a15 	stw	r15,168(sp)
81134098:	11333e80 	call	811333e8 <__sprint_r.part.0>
8113409c:	d9c02b17 	ldw	r7,172(sp)
811340a0:	dbc02a17 	ldw	r15,168(sp)
811340a4:	10006d1e 	bne	r2,zero,8113425c <___vfiprintf_internal_r+0xd58>
811340a8:	d9801b17 	ldw	r6,108(sp)
811340ac:	d8801c17 	ldw	r2,112(sp)
811340b0:	d811883a 	mov	r8,sp
811340b4:	31400044 	addi	r5,r6,1
811340b8:	003e3306 	br	81133988 <__reset+0xfb113988>
811340bc:	d9401b17 	ldw	r5,108(sp)
811340c0:	d8801c17 	ldw	r2,112(sp)
811340c4:	29000044 	addi	r4,r5,1
811340c8:	d8c01d87 	ldb	r3,118(sp)
811340cc:	183e4d26 	beq	r3,zero,81133a04 <__reset+0xfb113a04>
811340d0:	00c00044 	movi	r3,1
811340d4:	d9401d84 	addi	r5,sp,118
811340d8:	10c5883a 	add	r2,r2,r3
811340dc:	41400015 	stw	r5,0(r8)
811340e0:	40c00115 	stw	r3,4(r8)
811340e4:	d8801c15 	stw	r2,112(sp)
811340e8:	d9001b15 	stw	r4,108(sp)
811340ec:	014001c4 	movi	r5,7
811340f0:	2900a90e 	bge	r5,r4,81134398 <___vfiprintf_internal_r+0xe94>
811340f4:	1000da1e 	bne	r2,zero,81134460 <___vfiprintf_internal_r+0xf5c>
811340f8:	7000ab1e 	bne	r14,zero,811343a8 <___vfiprintf_internal_r+0xea4>
811340fc:	000b883a 	mov	r5,zero
81134100:	1809883a 	mov	r4,r3
81134104:	d811883a 	mov	r8,sp
81134108:	00c02004 	movi	r3,128
8113410c:	e0fe4d26 	beq	fp,r3,81133a44 <__reset+0xfb113a44>
81134110:	4cf9c83a 	sub	fp,r9,r19
81134114:	073e7b0e 	bge	zero,fp,81133b04 <__reset+0xfb113b04>
81134118:	01c00404 	movi	r7,16
8113411c:	3f01900e 	bge	r7,fp,81134760 <___vfiprintf_internal_r+0x125c>
81134120:	00e04574 	movhi	r3,33045
81134124:	18ca2304 	addi	r3,r3,10380
81134128:	d8c02415 	stw	r3,144(sp)
8113412c:	034001c4 	movi	r13,7
81134130:	00000506 	br	81134148 <___vfiprintf_internal_r+0xc44>
81134134:	29000084 	addi	r4,r5,2
81134138:	42000204 	addi	r8,r8,8
8113413c:	180b883a 	mov	r5,r3
81134140:	e73ffc04 	addi	fp,fp,-16
81134144:	3f000d0e 	bge	r7,fp,8113417c <___vfiprintf_internal_r+0xc78>
81134148:	10800404 	addi	r2,r2,16
8113414c:	28c00044 	addi	r3,r5,1
81134150:	45c00015 	stw	r23,0(r8)
81134154:	41c00115 	stw	r7,4(r8)
81134158:	d8801c15 	stw	r2,112(sp)
8113415c:	d8c01b15 	stw	r3,108(sp)
81134160:	68fff40e 	bge	r13,r3,81134134 <__reset+0xfb114134>
81134164:	1000101e 	bne	r2,zero,811341a8 <___vfiprintf_internal_r+0xca4>
81134168:	e73ffc04 	addi	fp,fp,-16
8113416c:	01000044 	movi	r4,1
81134170:	000b883a 	mov	r5,zero
81134174:	d811883a 	mov	r8,sp
81134178:	3f3ff316 	blt	r7,fp,81134148 <__reset+0xfb114148>
8113417c:	da802417 	ldw	r10,144(sp)
81134180:	1705883a 	add	r2,r2,fp
81134184:	47000115 	stw	fp,4(r8)
81134188:	42800015 	stw	r10,0(r8)
8113418c:	d8801c15 	stw	r2,112(sp)
81134190:	d9001b15 	stw	r4,108(sp)
81134194:	00c001c4 	movi	r3,7
81134198:	19003616 	blt	r3,r4,81134274 <___vfiprintf_internal_r+0xd70>
8113419c:	42000204 	addi	r8,r8,8
811341a0:	21000044 	addi	r4,r4,1
811341a4:	003e5706 	br	81133b04 <__reset+0xfb113b04>
811341a8:	d9402117 	ldw	r5,132(sp)
811341ac:	d9002017 	ldw	r4,128(sp)
811341b0:	d9801a04 	addi	r6,sp,104
811341b4:	d9c02b15 	stw	r7,172(sp)
811341b8:	db402a15 	stw	r13,168(sp)
811341bc:	11333e80 	call	811333e8 <__sprint_r.part.0>
811341c0:	d9c02b17 	ldw	r7,172(sp)
811341c4:	db402a17 	ldw	r13,168(sp)
811341c8:	1000241e 	bne	r2,zero,8113425c <___vfiprintf_internal_r+0xd58>
811341cc:	d9401b17 	ldw	r5,108(sp)
811341d0:	d8801c17 	ldw	r2,112(sp)
811341d4:	d811883a 	mov	r8,sp
811341d8:	29000044 	addi	r4,r5,1
811341dc:	003fd806 	br	81134140 <__reset+0xfb114140>
811341e0:	d9401b17 	ldw	r5,108(sp)
811341e4:	00e04574 	movhi	r3,33045
811341e8:	18ca2704 	addi	r3,r3,10396
811341ec:	d8c02415 	stw	r3,144(sp)
811341f0:	29400044 	addi	r5,r5,1
811341f4:	d8c02417 	ldw	r3,144(sp)
811341f8:	14c5883a 	add	r2,r2,r19
811341fc:	44c00115 	stw	r19,4(r8)
81134200:	40c00015 	stw	r3,0(r8)
81134204:	d8801c15 	stw	r2,112(sp)
81134208:	d9401b15 	stw	r5,108(sp)
8113420c:	00c001c4 	movi	r3,7
81134210:	1940070e 	bge	r3,r5,81134230 <___vfiprintf_internal_r+0xd2c>
81134214:	103e4826 	beq	r2,zero,81133b38 <__reset+0xfb113b38>
81134218:	d9402117 	ldw	r5,132(sp)
8113421c:	d9002017 	ldw	r4,128(sp)
81134220:	d9801a04 	addi	r6,sp,104
81134224:	11333e80 	call	811333e8 <__sprint_r.part.0>
81134228:	10000c1e 	bne	r2,zero,8113425c <___vfiprintf_internal_r+0xd58>
8113422c:	d8801c17 	ldw	r2,112(sp)
81134230:	8c80010e 	bge	r17,r18,81134238 <___vfiprintf_internal_r+0xd34>
81134234:	9023883a 	mov	r17,r18
81134238:	da802317 	ldw	r10,140(sp)
8113423c:	5455883a 	add	r10,r10,r17
81134240:	da802315 	stw	r10,140(sp)
81134244:	103e4126 	beq	r2,zero,81133b4c <__reset+0xfb113b4c>
81134248:	d9402117 	ldw	r5,132(sp)
8113424c:	d9002017 	ldw	r4,128(sp)
81134250:	d9801a04 	addi	r6,sp,104
81134254:	11333e80 	call	811333e8 <__sprint_r.part.0>
81134258:	103e3c26 	beq	r2,zero,81133b4c <__reset+0xfb113b4c>
8113425c:	dd002117 	ldw	r20,132(sp)
81134260:	a080030b 	ldhu	r2,12(r20)
81134264:	1080100c 	andi	r2,r2,64
81134268:	1001231e 	bne	r2,zero,811346f8 <___vfiprintf_internal_r+0x11f4>
8113426c:	d8802317 	ldw	r2,140(sp)
81134270:	003d7b06 	br	81133860 <__reset+0xfb113860>
81134274:	1000991e 	bne	r2,zero,811344dc <___vfiprintf_internal_r+0xfd8>
81134278:	00c00044 	movi	r3,1
8113427c:	9805883a 	mov	r2,r19
81134280:	dd400015 	stw	r21,0(sp)
81134284:	dcc00115 	stw	r19,4(sp)
81134288:	dcc01c15 	stw	r19,112(sp)
8113428c:	d8c01b15 	stw	r3,108(sp)
81134290:	d811883a 	mov	r8,sp
81134294:	42000204 	addi	r8,r8,8
81134298:	a2c0010c 	andi	r11,r20,4
8113429c:	583fe426 	beq	r11,zero,81134230 <__reset+0xfb114230>
811342a0:	8ca7c83a 	sub	r19,r17,r18
811342a4:	04ffe20e 	bge	zero,r19,81134230 <__reset+0xfb114230>
811342a8:	01c00404 	movi	r7,16
811342ac:	3cffcc0e 	bge	r7,r19,811341e0 <__reset+0xfb1141e0>
811342b0:	02a04574 	movhi	r10,33045
811342b4:	528a2704 	addi	r10,r10,10396
811342b8:	d9001b17 	ldw	r4,108(sp)
811342bc:	da802415 	stw	r10,144(sp)
811342c0:	382b883a 	mov	r21,r7
811342c4:	050001c4 	movi	r20,7
811342c8:	df002017 	ldw	fp,128(sp)
811342cc:	00000506 	br	811342e4 <___vfiprintf_internal_r+0xde0>
811342d0:	21400084 	addi	r5,r4,2
811342d4:	42000204 	addi	r8,r8,8
811342d8:	1809883a 	mov	r4,r3
811342dc:	9cfffc04 	addi	r19,r19,-16
811342e0:	acffc40e 	bge	r21,r19,811341f4 <__reset+0xfb1141f4>
811342e4:	10800404 	addi	r2,r2,16
811342e8:	20c00044 	addi	r3,r4,1
811342ec:	45800015 	stw	r22,0(r8)
811342f0:	45400115 	stw	r21,4(r8)
811342f4:	d8801c15 	stw	r2,112(sp)
811342f8:	d8c01b15 	stw	r3,108(sp)
811342fc:	a0fff40e 	bge	r20,r3,811342d0 <__reset+0xfb1142d0>
81134300:	1000041e 	bne	r2,zero,81134314 <___vfiprintf_internal_r+0xe10>
81134304:	01400044 	movi	r5,1
81134308:	0009883a 	mov	r4,zero
8113430c:	d811883a 	mov	r8,sp
81134310:	003ff206 	br	811342dc <__reset+0xfb1142dc>
81134314:	d9402117 	ldw	r5,132(sp)
81134318:	d9801a04 	addi	r6,sp,104
8113431c:	e009883a 	mov	r4,fp
81134320:	11333e80 	call	811333e8 <__sprint_r.part.0>
81134324:	103fcd1e 	bne	r2,zero,8113425c <__reset+0xfb11425c>
81134328:	d9001b17 	ldw	r4,108(sp)
8113432c:	d8801c17 	ldw	r2,112(sp)
81134330:	d811883a 	mov	r8,sp
81134334:	21400044 	addi	r5,r4,1
81134338:	003fe806 	br	811342dc <__reset+0xfb1142dc>
8113433c:	d9402117 	ldw	r5,132(sp)
81134340:	d9002017 	ldw	r4,128(sp)
81134344:	d9801a04 	addi	r6,sp,104
81134348:	d9c02b15 	stw	r7,172(sp)
8113434c:	db402a15 	stw	r13,168(sp)
81134350:	11333e80 	call	811333e8 <__sprint_r.part.0>
81134354:	d9c02b17 	ldw	r7,172(sp)
81134358:	db402a17 	ldw	r13,168(sp)
8113435c:	103fbf1e 	bne	r2,zero,8113425c <__reset+0xfb11425c>
81134360:	d9401b17 	ldw	r5,108(sp)
81134364:	d8801c17 	ldw	r2,112(sp)
81134368:	d811883a 	mov	r8,sp
8113436c:	29800044 	addi	r6,r5,1
81134370:	003dc406 	br	81133a84 <__reset+0xfb113a84>
81134374:	1000d21e 	bne	r2,zero,811346c0 <___vfiprintf_internal_r+0x11bc>
81134378:	d8c01d87 	ldb	r3,118(sp)
8113437c:	18009526 	beq	r3,zero,811345d4 <___vfiprintf_internal_r+0x10d0>
81134380:	00800044 	movi	r2,1
81134384:	d8c01d84 	addi	r3,sp,118
81134388:	1009883a 	mov	r4,r2
8113438c:	d8c00015 	stw	r3,0(sp)
81134390:	d8800115 	stw	r2,4(sp)
81134394:	d811883a 	mov	r8,sp
81134398:	200b883a 	mov	r5,r4
8113439c:	42000204 	addi	r8,r8,8
811343a0:	21000044 	addi	r4,r4,1
811343a4:	003d9706 	br	81133a04 <__reset+0xfb113a04>
811343a8:	d9001d04 	addi	r4,sp,116
811343ac:	00800084 	movi	r2,2
811343b0:	d9000015 	stw	r4,0(sp)
811343b4:	d8800115 	stw	r2,4(sp)
811343b8:	1809883a 	mov	r4,r3
811343bc:	d811883a 	mov	r8,sp
811343c0:	200b883a 	mov	r5,r4
811343c4:	42000204 	addi	r8,r8,8
811343c8:	21000044 	addi	r4,r4,1
811343cc:	003f4e06 	br	81134108 <__reset+0xfb114108>
811343d0:	d8001d85 	stb	zero,118(sp)
811343d4:	48005016 	blt	r9,zero,81134518 <___vfiprintf_internal_r+0x1014>
811343d8:	00ffdfc4 	movi	r3,-129
811343dc:	94c4b03a 	or	r2,r18,r19
811343e0:	a0e8703a 	and	r20,r20,r3
811343e4:	103d4426 	beq	r2,zero,811338f8 <__reset+0xfb1138f8>
811343e8:	0039883a 	mov	fp,zero
811343ec:	d9002617 	ldw	r4,152(sp)
811343f0:	dd401a04 	addi	r21,sp,104
811343f4:	908003cc 	andi	r2,r18,15
811343f8:	9806973a 	slli	r3,r19,28
811343fc:	2085883a 	add	r2,r4,r2
81134400:	9024d13a 	srli	r18,r18,4
81134404:	10800003 	ldbu	r2,0(r2)
81134408:	9826d13a 	srli	r19,r19,4
8113440c:	ad7fffc4 	addi	r21,r21,-1
81134410:	1ca4b03a 	or	r18,r3,r18
81134414:	a8800005 	stb	r2,0(r21)
81134418:	94c4b03a 	or	r2,r18,r19
8113441c:	103ff51e 	bne	r2,zero,811343f4 <__reset+0xfb1143f4>
81134420:	003e5906 	br	81133d88 <__reset+0xfb113d88>
81134424:	d9402117 	ldw	r5,132(sp)
81134428:	d9002017 	ldw	r4,128(sp)
8113442c:	d9801a04 	addi	r6,sp,104
81134430:	11333e80 	call	811333e8 <__sprint_r.part.0>
81134434:	103f891e 	bne	r2,zero,8113425c <__reset+0xfb11425c>
81134438:	d8801c17 	ldw	r2,112(sp)
8113443c:	d811883a 	mov	r8,sp
81134440:	003f9506 	br	81134298 <__reset+0xfb114298>
81134444:	d9402117 	ldw	r5,132(sp)
81134448:	d9002017 	ldw	r4,128(sp)
8113444c:	d9801a04 	addi	r6,sp,104
81134450:	11333e80 	call	811333e8 <__sprint_r.part.0>
81134454:	103f811e 	bne	r2,zero,8113425c <__reset+0xfb11425c>
81134458:	d811883a 	mov	r8,sp
8113445c:	003ced06 	br	81133814 <__reset+0xfb113814>
81134460:	d9402117 	ldw	r5,132(sp)
81134464:	d9002017 	ldw	r4,128(sp)
81134468:	d9801a04 	addi	r6,sp,104
8113446c:	da402c15 	stw	r9,176(sp)
81134470:	db802a15 	stw	r14,168(sp)
81134474:	11333e80 	call	811333e8 <__sprint_r.part.0>
81134478:	da402c17 	ldw	r9,176(sp)
8113447c:	db802a17 	ldw	r14,168(sp)
81134480:	103f761e 	bne	r2,zero,8113425c <__reset+0xfb11425c>
81134484:	d9401b17 	ldw	r5,108(sp)
81134488:	d8801c17 	ldw	r2,112(sp)
8113448c:	d811883a 	mov	r8,sp
81134490:	29000044 	addi	r4,r5,1
81134494:	003d5b06 	br	81133a04 <__reset+0xfb113a04>
81134498:	d9402117 	ldw	r5,132(sp)
8113449c:	d9002017 	ldw	r4,128(sp)
811344a0:	d9801a04 	addi	r6,sp,104
811344a4:	da402c15 	stw	r9,176(sp)
811344a8:	11333e80 	call	811333e8 <__sprint_r.part.0>
811344ac:	da402c17 	ldw	r9,176(sp)
811344b0:	103f6a1e 	bne	r2,zero,8113425c <__reset+0xfb11425c>
811344b4:	d9401b17 	ldw	r5,108(sp)
811344b8:	d8801c17 	ldw	r2,112(sp)
811344bc:	d811883a 	mov	r8,sp
811344c0:	29000044 	addi	r4,r5,1
811344c4:	003f1006 	br	81134108 <__reset+0xfb114108>
811344c8:	1000c31e 	bne	r2,zero,811347d8 <___vfiprintf_internal_r+0x12d4>
811344cc:	01000044 	movi	r4,1
811344d0:	000b883a 	mov	r5,zero
811344d4:	d811883a 	mov	r8,sp
811344d8:	003f0d06 	br	81134110 <__reset+0xfb114110>
811344dc:	d9402117 	ldw	r5,132(sp)
811344e0:	d9002017 	ldw	r4,128(sp)
811344e4:	d9801a04 	addi	r6,sp,104
811344e8:	11333e80 	call	811333e8 <__sprint_r.part.0>
811344ec:	103f5b1e 	bne	r2,zero,8113425c <__reset+0xfb11425c>
811344f0:	d9001b17 	ldw	r4,108(sp)
811344f4:	d8801c17 	ldw	r2,112(sp)
811344f8:	d811883a 	mov	r8,sp
811344fc:	21000044 	addi	r4,r4,1
81134500:	003d8006 	br	81133b04 <__reset+0xfb113b04>
81134504:	01204574 	movhi	r4,33045
81134508:	21099104 	addi	r4,r4,9796
8113450c:	d9002615 	stw	r4,152(sp)
81134510:	d8c02215 	stw	r3,136(sp)
81134514:	1029883a 	mov	r20,r2
81134518:	94c4b03a 	or	r2,r18,r19
8113451c:	103fb21e 	bne	r2,zero,811343e8 <__reset+0xfb1143e8>
81134520:	0039883a 	mov	fp,zero
81134524:	00800084 	movi	r2,2
81134528:	003e6b06 	br	81133ed8 <__reset+0xfb113ed8>
8113452c:	da802217 	ldw	r10,136(sp)
81134530:	d8001d85 	stb	zero,118(sp)
81134534:	0027883a 	mov	r19,zero
81134538:	50800104 	addi	r2,r10,4
8113453c:	54800017 	ldw	r18,0(r10)
81134540:	483e6016 	blt	r9,zero,81133ec4 <__reset+0xfb113ec4>
81134544:	00ffdfc4 	movi	r3,-129
81134548:	d8802215 	stw	r2,136(sp)
8113454c:	a0e8703a 	and	r20,r20,r3
81134550:	0039883a 	mov	fp,zero
81134554:	903ebb26 	beq	r18,zero,81134044 <__reset+0xfb114044>
81134558:	00800244 	movi	r2,9
8113455c:	14bdee36 	bltu	r2,r18,81133d18 <__reset+0xfb113d18>
81134560:	003eba06 	br	8113404c <__reset+0xfb11404c>
81134564:	00800c04 	movi	r2,48
81134568:	d8c01d45 	stb	r3,117(sp)
8113456c:	d8801d05 	stb	r2,116(sp)
81134570:	d8001d85 	stb	zero,118(sp)
81134574:	a0c00094 	ori	r3,r20,2
81134578:	4800a916 	blt	r9,zero,81134820 <___vfiprintf_internal_r+0x131c>
8113457c:	00bfdfc4 	movi	r2,-129
81134580:	a096703a 	and	r11,r20,r2
81134584:	5d000094 	ori	r20,r11,2
81134588:	0039883a 	mov	fp,zero
8113458c:	003f9706 	br	811343ec <__reset+0xfb1143ec>
81134590:	8025883a 	mov	r18,r16
81134594:	003c2e06 	br	81133650 <__reset+0xfb113650>
81134598:	00a04574 	movhi	r2,33045
8113459c:	10899104 	addi	r2,r2,9796
811345a0:	0039883a 	mov	fp,zero
811345a4:	d8802615 	stw	r2,152(sp)
811345a8:	003f9006 	br	811343ec <__reset+0xfb1143ec>
811345ac:	04a5c83a 	sub	r18,zero,r18
811345b0:	07000b44 	movi	fp,45
811345b4:	9004c03a 	cmpne	r2,r18,zero
811345b8:	04e7c83a 	sub	r19,zero,r19
811345bc:	df001d85 	stb	fp,118(sp)
811345c0:	98a7c83a 	sub	r19,r19,r2
811345c4:	48009f16 	blt	r9,zero,81134844 <___vfiprintf_internal_r+0x1340>
811345c8:	00bfdfc4 	movi	r2,-129
811345cc:	a0a8703a 	and	r20,r20,r2
811345d0:	003dd006 	br	81133d14 <__reset+0xfb113d14>
811345d4:	70004c26 	beq	r14,zero,81134708 <___vfiprintf_internal_r+0x1204>
811345d8:	00800084 	movi	r2,2
811345dc:	d8c01d04 	addi	r3,sp,116
811345e0:	d8c00015 	stw	r3,0(sp)
811345e4:	d8800115 	stw	r2,4(sp)
811345e8:	01000044 	movi	r4,1
811345ec:	d811883a 	mov	r8,sp
811345f0:	003f7306 	br	811343c0 <__reset+0xfb1143c0>
811345f4:	a080100c 	andi	r2,r20,64
811345f8:	da802217 	ldw	r10,136(sp)
811345fc:	103e0626 	beq	r2,zero,81133e18 <__reset+0xfb113e18>
81134600:	5480000f 	ldh	r18,0(r10)
81134604:	52800104 	addi	r10,r10,4
81134608:	da802215 	stw	r10,136(sp)
8113460c:	9027d7fa 	srai	r19,r18,31
81134610:	9805883a 	mov	r2,r19
81134614:	003db806 	br	81133cf8 <__reset+0xfb113cf8>
81134618:	a080040c 	andi	r2,r20,16
8113461c:	1000091e 	bne	r2,zero,81134644 <___vfiprintf_internal_r+0x1140>
81134620:	a2c0100c 	andi	r11,r20,64
81134624:	58000726 	beq	r11,zero,81134644 <___vfiprintf_internal_r+0x1140>
81134628:	da802217 	ldw	r10,136(sp)
8113462c:	50800017 	ldw	r2,0(r10)
81134630:	52800104 	addi	r10,r10,4
81134634:	da802215 	stw	r10,136(sp)
81134638:	da802317 	ldw	r10,140(sp)
8113463c:	1280000d 	sth	r10,0(r2)
81134640:	003be706 	br	811335e0 <__reset+0xfb1135e0>
81134644:	da802217 	ldw	r10,136(sp)
81134648:	50800017 	ldw	r2,0(r10)
8113464c:	52800104 	addi	r10,r10,4
81134650:	da802215 	stw	r10,136(sp)
81134654:	da802317 	ldw	r10,140(sp)
81134658:	12800015 	stw	r10,0(r2)
8113465c:	003be006 	br	811335e0 <__reset+0xfb1135e0>
81134660:	a080100c 	andi	r2,r20,64
81134664:	da802217 	ldw	r10,136(sp)
81134668:	10003026 	beq	r2,zero,8113472c <___vfiprintf_internal_r+0x1228>
8113466c:	5480000b 	ldhu	r18,0(r10)
81134670:	52800104 	addi	r10,r10,4
81134674:	0027883a 	mov	r19,zero
81134678:	da802215 	stw	r10,136(sp)
8113467c:	003d8006 	br	81133c80 <__reset+0xfb113c80>
81134680:	80c00007 	ldb	r3,0(r16)
81134684:	003c0006 	br	81133688 <__reset+0xfb113688>
81134688:	a080100c 	andi	r2,r20,64
8113468c:	d8001d85 	stb	zero,118(sp)
81134690:	da802217 	ldw	r10,136(sp)
81134694:	1000201e 	bne	r2,zero,81134718 <___vfiprintf_internal_r+0x1214>
81134698:	50800104 	addi	r2,r10,4
8113469c:	54800017 	ldw	r18,0(r10)
811346a0:	0027883a 	mov	r19,zero
811346a4:	483def0e 	bge	r9,zero,81133e64 <__reset+0xfb113e64>
811346a8:	94c6b03a 	or	r3,r18,r19
811346ac:	d8802215 	stw	r2,136(sp)
811346b0:	183d4e1e 	bne	r3,zero,81133bec <__reset+0xfb113bec>
811346b4:	0039883a 	mov	fp,zero
811346b8:	0005883a 	mov	r2,zero
811346bc:	003e0606 	br	81133ed8 <__reset+0xfb113ed8>
811346c0:	d9402117 	ldw	r5,132(sp)
811346c4:	d9002017 	ldw	r4,128(sp)
811346c8:	d9801a04 	addi	r6,sp,104
811346cc:	da402c15 	stw	r9,176(sp)
811346d0:	db802a15 	stw	r14,168(sp)
811346d4:	11333e80 	call	811333e8 <__sprint_r.part.0>
811346d8:	da402c17 	ldw	r9,176(sp)
811346dc:	db802a17 	ldw	r14,168(sp)
811346e0:	103ede1e 	bne	r2,zero,8113425c <__reset+0xfb11425c>
811346e4:	d9401b17 	ldw	r5,108(sp)
811346e8:	d8801c17 	ldw	r2,112(sp)
811346ec:	d811883a 	mov	r8,sp
811346f0:	29000044 	addi	r4,r5,1
811346f4:	003e7406 	br	811340c8 <__reset+0xfb1140c8>
811346f8:	00bfffc4 	movi	r2,-1
811346fc:	003c5806 	br	81133860 <__reset+0xfb113860>
81134700:	d811883a 	mov	r8,sp
81134704:	003ee806 	br	811342a8 <__reset+0xfb1142a8>
81134708:	000b883a 	mov	r5,zero
8113470c:	01000044 	movi	r4,1
81134710:	d811883a 	mov	r8,sp
81134714:	003e7c06 	br	81134108 <__reset+0xfb114108>
81134718:	50800104 	addi	r2,r10,4
8113471c:	5480000b 	ldhu	r18,0(r10)
81134720:	0027883a 	mov	r19,zero
81134724:	483dcf0e 	bge	r9,zero,81133e64 <__reset+0xfb113e64>
81134728:	003fdf06 	br	811346a8 <__reset+0xfb1146a8>
8113472c:	54800017 	ldw	r18,0(r10)
81134730:	52800104 	addi	r10,r10,4
81134734:	0027883a 	mov	r19,zero
81134738:	da802215 	stw	r10,136(sp)
8113473c:	003d5006 	br	81133c80 <__reset+0xfb113c80>
81134740:	50800104 	addi	r2,r10,4
81134744:	5480000b 	ldhu	r18,0(r10)
81134748:	0027883a 	mov	r19,zero
8113474c:	483f7d0e 	bge	r9,zero,81134544 <__reset+0xfb114544>
81134750:	003ddc06 	br	81133ec4 <__reset+0xfb113ec4>
81134754:	d8c02215 	stw	r3,136(sp)
81134758:	0039883a 	mov	fp,zero
8113475c:	003ddb06 	br	81133ecc <__reset+0xfb113ecc>
81134760:	02a04574 	movhi	r10,33045
81134764:	528a2304 	addi	r10,r10,10380
81134768:	da802415 	stw	r10,144(sp)
8113476c:	003e8306 	br	8113417c <__reset+0xfb11417c>
81134770:	d8801c17 	ldw	r2,112(sp)
81134774:	dd002117 	ldw	r20,132(sp)
81134778:	103eb926 	beq	r2,zero,81134260 <__reset+0xfb114260>
8113477c:	d9002017 	ldw	r4,128(sp)
81134780:	d9801a04 	addi	r6,sp,104
81134784:	a00b883a 	mov	r5,r20
81134788:	11333e80 	call	811333e8 <__sprint_r.part.0>
8113478c:	003eb406 	br	81134260 <__reset+0xfb114260>
81134790:	80c00043 	ldbu	r3,1(r16)
81134794:	a5000814 	ori	r20,r20,32
81134798:	84000044 	addi	r16,r16,1
8113479c:	18c03fcc 	andi	r3,r3,255
811347a0:	18c0201c 	xori	r3,r3,128
811347a4:	18ffe004 	addi	r3,r3,-128
811347a8:	003bb706 	br	81133688 <__reset+0xfb113688>
811347ac:	a809883a 	mov	r4,r21
811347b0:	d8c02a15 	stw	r3,168(sp)
811347b4:	da002b15 	stw	r8,172(sp)
811347b8:	1124dc80 	call	81124dc8 <strlen>
811347bc:	d8c02a17 	ldw	r3,168(sp)
811347c0:	1027883a 	mov	r19,r2
811347c4:	df001d83 	ldbu	fp,118(sp)
811347c8:	d8c02215 	stw	r3,136(sp)
811347cc:	0013883a 	mov	r9,zero
811347d0:	da002b17 	ldw	r8,172(sp)
811347d4:	003c4d06 	br	8113390c <__reset+0xfb11390c>
811347d8:	d9402117 	ldw	r5,132(sp)
811347dc:	d9002017 	ldw	r4,128(sp)
811347e0:	d9801a04 	addi	r6,sp,104
811347e4:	da402c15 	stw	r9,176(sp)
811347e8:	11333e80 	call	811333e8 <__sprint_r.part.0>
811347ec:	da402c17 	ldw	r9,176(sp)
811347f0:	103e9a1e 	bne	r2,zero,8113425c <__reset+0xfb11425c>
811347f4:	d9401b17 	ldw	r5,108(sp)
811347f8:	d8801c17 	ldw	r2,112(sp)
811347fc:	d811883a 	mov	r8,sp
81134800:	29000044 	addi	r4,r5,1
81134804:	003e4206 	br	81134110 <__reset+0xfb114110>
81134808:	d9401b17 	ldw	r5,108(sp)
8113480c:	01204574 	movhi	r4,33045
81134810:	210a2704 	addi	r4,r4,10396
81134814:	d9002415 	stw	r4,144(sp)
81134818:	29400044 	addi	r5,r5,1
8113481c:	003c6d06 	br	811339d4 <__reset+0xfb1139d4>
81134820:	0039883a 	mov	fp,zero
81134824:	00800084 	movi	r2,2
81134828:	10803fcc 	andi	r2,r2,255
8113482c:	01000044 	movi	r4,1
81134830:	11001e26 	beq	r2,r4,811348ac <___vfiprintf_internal_r+0x13a8>
81134834:	01000084 	movi	r4,2
81134838:	11001e1e 	bne	r2,r4,811348b4 <___vfiprintf_internal_r+0x13b0>
8113483c:	1829883a 	mov	r20,r3
81134840:	003eea06 	br	811343ec <__reset+0xfb1143ec>
81134844:	a007883a 	mov	r3,r20
81134848:	00800044 	movi	r2,1
8113484c:	003ff606 	br	81134828 <__reset+0xfb114828>
81134850:	00800184 	movi	r2,6
81134854:	1240012e 	bgeu	r2,r9,8113485c <___vfiprintf_internal_r+0x1358>
81134858:	1013883a 	mov	r9,r2
8113485c:	4827883a 	mov	r19,r9
81134860:	4825883a 	mov	r18,r9
81134864:	48001516 	blt	r9,zero,811348bc <___vfiprintf_internal_r+0x13b8>
81134868:	05604574 	movhi	r21,33045
8113486c:	d8c02215 	stw	r3,136(sp)
81134870:	ad499604 	addi	r21,r21,9816
81134874:	003d1406 	br	81133cc8 <__reset+0xfb113cc8>
81134878:	02a04574 	movhi	r10,33045
8113487c:	528a2304 	addi	r10,r10,10380
81134880:	da802415 	stw	r10,144(sp)
81134884:	200d883a 	mov	r6,r4
81134888:	003c9106 	br	81133ad0 <__reset+0xfb113ad0>
8113488c:	5021883a 	mov	r16,r10
81134890:	0013883a 	mov	r9,zero
81134894:	003b7d06 	br	8113368c <__reset+0xfb11368c>
81134898:	4827883a 	mov	r19,r9
8113489c:	df001d83 	ldbu	fp,118(sp)
811348a0:	d8c02215 	stw	r3,136(sp)
811348a4:	0013883a 	mov	r9,zero
811348a8:	003c1806 	br	8113390c <__reset+0xfb11390c>
811348ac:	1829883a 	mov	r20,r3
811348b0:	003d1806 	br	81133d14 <__reset+0xfb113d14>
811348b4:	1829883a 	mov	r20,r3
811348b8:	003ccd06 	br	81133bf0 <__reset+0xfb113bf0>
811348bc:	0025883a 	mov	r18,zero
811348c0:	003fe906 	br	81134868 <__reset+0xfb114868>
811348c4:	d8802217 	ldw	r2,136(sp)
811348c8:	80c00043 	ldbu	r3,1(r16)
811348cc:	5021883a 	mov	r16,r10
811348d0:	12400017 	ldw	r9,0(r2)
811348d4:	10800104 	addi	r2,r2,4
811348d8:	d8802215 	stw	r2,136(sp)
811348dc:	483faf0e 	bge	r9,zero,8113479c <__reset+0xfb11479c>
811348e0:	18c03fcc 	andi	r3,r3,255
811348e4:	18c0201c 	xori	r3,r3,128
811348e8:	027fffc4 	movi	r9,-1
811348ec:	18ffe004 	addi	r3,r3,-128
811348f0:	003b6506 	br	81133688 <__reset+0xfb113688>
811348f4:	d9c01d85 	stb	r7,118(sp)
811348f8:	003ca006 	br	81133b7c <__reset+0xfb113b7c>
811348fc:	d9c01d85 	stb	r7,118(sp)
81134900:	003cad06 	br	81133bb8 <__reset+0xfb113bb8>
81134904:	d9c01d85 	stb	r7,118(sp)
81134908:	003d7d06 	br	81133f00 <__reset+0xfb113f00>
8113490c:	d9c01d85 	stb	r7,118(sp)
81134910:	003d5f06 	br	81133e90 <__reset+0xfb113e90>
81134914:	a080004c 	andi	r2,r20,1
81134918:	0039883a 	mov	fp,zero
8113491c:	10000526 	beq	r2,zero,81134934 <___vfiprintf_internal_r+0x1430>
81134920:	00800c04 	movi	r2,48
81134924:	d88019c5 	stb	r2,103(sp)
81134928:	dcc02717 	ldw	r19,156(sp)
8113492c:	dd4019c4 	addi	r21,sp,103
81134930:	003bf606 	br	8113390c <__reset+0xfb11390c>
81134934:	0027883a 	mov	r19,zero
81134938:	dd401a04 	addi	r21,sp,104
8113493c:	003bf306 	br	8113390c <__reset+0xfb11390c>
81134940:	d9c01d85 	stb	r7,118(sp)
81134944:	003dc806 	br	81134068 <__reset+0xfb114068>
81134948:	d9c01d85 	stb	r7,118(sp)
8113494c:	003d3a06 	br	81133e38 <__reset+0xfb113e38>
81134950:	d9c01d85 	stb	r7,118(sp)
81134954:	003d2a06 	br	81133e00 <__reset+0xfb113e00>
81134958:	d9c01d85 	stb	r7,118(sp)
8113495c:	003cde06 	br	81133cd8 <__reset+0xfb113cd8>
81134960:	d9c01d85 	stb	r7,118(sp)
81134964:	003cbc06 	br	81133c58 <__reset+0xfb113c58>

81134968 <__vfiprintf_internal>:
81134968:	00a04574 	movhi	r2,33045
8113496c:	10936004 	addi	r2,r2,19840
81134970:	300f883a 	mov	r7,r6
81134974:	280d883a 	mov	r6,r5
81134978:	200b883a 	mov	r5,r4
8113497c:	11000017 	ldw	r4,0(r2)
81134980:	11335041 	jmpi	81133504 <___vfiprintf_internal_r>

81134984 <__sbprintf>:
81134984:	defee204 	addi	sp,sp,-1144
81134988:	de00012e 	bgeu	sp,et,81134990 <__sbprintf+0xc>
8113498c:	003b68fa 	trap	3
81134990:	2880030b 	ldhu	r2,12(r5)
81134994:	2ac01917 	ldw	r11,100(r5)
81134998:	2a80038b 	ldhu	r10,14(r5)
8113499c:	2a400717 	ldw	r9,28(r5)
811349a0:	2a000917 	ldw	r8,36(r5)
811349a4:	00c10004 	movi	r3,1024
811349a8:	dc011a15 	stw	r16,1128(sp)
811349ac:	10bfff4c 	andi	r2,r2,65533
811349b0:	2821883a 	mov	r16,r5
811349b4:	d8cb883a 	add	r5,sp,r3
811349b8:	dc811c15 	stw	r18,1136(sp)
811349bc:	dc411b15 	stw	r17,1132(sp)
811349c0:	dfc11d15 	stw	ra,1140(sp)
811349c4:	2025883a 	mov	r18,r4
811349c8:	d881030d 	sth	r2,1036(sp)
811349cc:	dac11915 	stw	r11,1124(sp)
811349d0:	da81038d 	sth	r10,1038(sp)
811349d4:	da410715 	stw	r9,1052(sp)
811349d8:	da010915 	stw	r8,1060(sp)
811349dc:	dec10015 	stw	sp,1024(sp)
811349e0:	dec10415 	stw	sp,1040(sp)
811349e4:	d8c10215 	stw	r3,1032(sp)
811349e8:	d8c10515 	stw	r3,1044(sp)
811349ec:	d8010615 	stw	zero,1048(sp)
811349f0:	11335040 	call	81133504 <___vfiprintf_internal_r>
811349f4:	1023883a 	mov	r17,r2
811349f8:	10000416 	blt	r2,zero,81134a0c <__sbprintf+0x88>
811349fc:	d9410004 	addi	r5,sp,1024
81134a00:	9009883a 	mov	r4,r18
81134a04:	112cfa40 	call	8112cfa4 <_fflush_r>
81134a08:	10000d1e 	bne	r2,zero,81134a40 <__sbprintf+0xbc>
81134a0c:	d881030b 	ldhu	r2,1036(sp)
81134a10:	1080100c 	andi	r2,r2,64
81134a14:	10000326 	beq	r2,zero,81134a24 <__sbprintf+0xa0>
81134a18:	8080030b 	ldhu	r2,12(r16)
81134a1c:	10801014 	ori	r2,r2,64
81134a20:	8080030d 	sth	r2,12(r16)
81134a24:	8805883a 	mov	r2,r17
81134a28:	dfc11d17 	ldw	ra,1140(sp)
81134a2c:	dc811c17 	ldw	r18,1136(sp)
81134a30:	dc411b17 	ldw	r17,1132(sp)
81134a34:	dc011a17 	ldw	r16,1128(sp)
81134a38:	dec11e04 	addi	sp,sp,1144
81134a3c:	f800283a 	ret
81134a40:	047fffc4 	movi	r17,-1
81134a44:	003ff106 	br	81134a0c <__reset+0xfb114a0c>

81134a48 <_calloc_r>:
81134a48:	298b383a 	mul	r5,r5,r6
81134a4c:	defffe04 	addi	sp,sp,-8
81134a50:	de00012e 	bgeu	sp,et,81134a58 <_calloc_r+0x10>
81134a54:	003b68fa 	trap	3
81134a58:	dfc00115 	stw	ra,4(sp)
81134a5c:	dc000015 	stw	r16,0(sp)
81134a60:	1123b3c0 	call	81123b3c <_malloc_r>
81134a64:	10002926 	beq	r2,zero,81134b0c <_calloc_r+0xc4>
81134a68:	11bfff17 	ldw	r6,-4(r2)
81134a6c:	1021883a 	mov	r16,r2
81134a70:	00bfff04 	movi	r2,-4
81134a74:	308c703a 	and	r6,r6,r2
81134a78:	00c00904 	movi	r3,36
81134a7c:	308d883a 	add	r6,r6,r2
81134a80:	19801636 	bltu	r3,r6,81134adc <_calloc_r+0x94>
81134a84:	008004c4 	movi	r2,19
81134a88:	11800b2e 	bgeu	r2,r6,81134ab8 <_calloc_r+0x70>
81134a8c:	80000015 	stw	zero,0(r16)
81134a90:	80000115 	stw	zero,4(r16)
81134a94:	008006c4 	movi	r2,27
81134a98:	11801a2e 	bgeu	r2,r6,81134b04 <_calloc_r+0xbc>
81134a9c:	80000215 	stw	zero,8(r16)
81134aa0:	80000315 	stw	zero,12(r16)
81134aa4:	30c0151e 	bne	r6,r3,81134afc <_calloc_r+0xb4>
81134aa8:	80000415 	stw	zero,16(r16)
81134aac:	80800604 	addi	r2,r16,24
81134ab0:	80000515 	stw	zero,20(r16)
81134ab4:	00000106 	br	81134abc <_calloc_r+0x74>
81134ab8:	8005883a 	mov	r2,r16
81134abc:	10000015 	stw	zero,0(r2)
81134ac0:	10000115 	stw	zero,4(r2)
81134ac4:	10000215 	stw	zero,8(r2)
81134ac8:	8005883a 	mov	r2,r16
81134acc:	dfc00117 	ldw	ra,4(sp)
81134ad0:	dc000017 	ldw	r16,0(sp)
81134ad4:	dec00204 	addi	sp,sp,8
81134ad8:	f800283a 	ret
81134adc:	000b883a 	mov	r5,zero
81134ae0:	8009883a 	mov	r4,r16
81134ae4:	11244a00 	call	811244a0 <memset>
81134ae8:	8005883a 	mov	r2,r16
81134aec:	dfc00117 	ldw	ra,4(sp)
81134af0:	dc000017 	ldw	r16,0(sp)
81134af4:	dec00204 	addi	sp,sp,8
81134af8:	f800283a 	ret
81134afc:	80800404 	addi	r2,r16,16
81134b00:	003fee06 	br	81134abc <__reset+0xfb114abc>
81134b04:	80800204 	addi	r2,r16,8
81134b08:	003fec06 	br	81134abc <__reset+0xfb114abc>
81134b0c:	0005883a 	mov	r2,zero
81134b10:	003fee06 	br	81134acc <__reset+0xfb114acc>

81134b14 <_fclose_r>:
81134b14:	28003b26 	beq	r5,zero,81134c04 <_fclose_r+0xf0>
81134b18:	defffc04 	addi	sp,sp,-16
81134b1c:	de00012e 	bgeu	sp,et,81134b24 <_fclose_r+0x10>
81134b20:	003b68fa 	trap	3
81134b24:	dc400115 	stw	r17,4(sp)
81134b28:	dc000015 	stw	r16,0(sp)
81134b2c:	dfc00315 	stw	ra,12(sp)
81134b30:	dc800215 	stw	r18,8(sp)
81134b34:	2023883a 	mov	r17,r4
81134b38:	2821883a 	mov	r16,r5
81134b3c:	20000226 	beq	r4,zero,81134b48 <_fclose_r+0x34>
81134b40:	20800e17 	ldw	r2,56(r4)
81134b44:	10002726 	beq	r2,zero,81134be4 <_fclose_r+0xd0>
81134b48:	8080030f 	ldh	r2,12(r16)
81134b4c:	1000071e 	bne	r2,zero,81134b6c <_fclose_r+0x58>
81134b50:	0005883a 	mov	r2,zero
81134b54:	dfc00317 	ldw	ra,12(sp)
81134b58:	dc800217 	ldw	r18,8(sp)
81134b5c:	dc400117 	ldw	r17,4(sp)
81134b60:	dc000017 	ldw	r16,0(sp)
81134b64:	dec00404 	addi	sp,sp,16
81134b68:	f800283a 	ret
81134b6c:	800b883a 	mov	r5,r16
81134b70:	8809883a 	mov	r4,r17
81134b74:	112cd800 	call	8112cd80 <__sflush_r>
81134b78:	1025883a 	mov	r18,r2
81134b7c:	80800b17 	ldw	r2,44(r16)
81134b80:	10000426 	beq	r2,zero,81134b94 <_fclose_r+0x80>
81134b84:	81400717 	ldw	r5,28(r16)
81134b88:	8809883a 	mov	r4,r17
81134b8c:	103ee83a 	callr	r2
81134b90:	10001616 	blt	r2,zero,81134bec <_fclose_r+0xd8>
81134b94:	8080030b 	ldhu	r2,12(r16)
81134b98:	1080200c 	andi	r2,r2,128
81134b9c:	1000151e 	bne	r2,zero,81134bf4 <_fclose_r+0xe0>
81134ba0:	81400c17 	ldw	r5,48(r16)
81134ba4:	28000526 	beq	r5,zero,81134bbc <_fclose_r+0xa8>
81134ba8:	80801004 	addi	r2,r16,64
81134bac:	28800226 	beq	r5,r2,81134bb8 <_fclose_r+0xa4>
81134bb0:	8809883a 	mov	r4,r17
81134bb4:	112d8380 	call	8112d838 <_free_r>
81134bb8:	80000c15 	stw	zero,48(r16)
81134bbc:	81401117 	ldw	r5,68(r16)
81134bc0:	28000326 	beq	r5,zero,81134bd0 <_fclose_r+0xbc>
81134bc4:	8809883a 	mov	r4,r17
81134bc8:	112d8380 	call	8112d838 <_free_r>
81134bcc:	80001115 	stw	zero,68(r16)
81134bd0:	112d3b00 	call	8112d3b0 <__sfp_lock_acquire>
81134bd4:	8000030d 	sth	zero,12(r16)
81134bd8:	112d3b40 	call	8112d3b4 <__sfp_lock_release>
81134bdc:	9005883a 	mov	r2,r18
81134be0:	003fdc06 	br	81134b54 <__reset+0xfb114b54>
81134be4:	112d3a00 	call	8112d3a0 <__sinit>
81134be8:	003fd706 	br	81134b48 <__reset+0xfb114b48>
81134bec:	04bfffc4 	movi	r18,-1
81134bf0:	003fe806 	br	81134b94 <__reset+0xfb114b94>
81134bf4:	81400417 	ldw	r5,16(r16)
81134bf8:	8809883a 	mov	r4,r17
81134bfc:	112d8380 	call	8112d838 <_free_r>
81134c00:	003fe706 	br	81134ba0 <__reset+0xfb114ba0>
81134c04:	0005883a 	mov	r2,zero
81134c08:	f800283a 	ret

81134c0c <fclose>:
81134c0c:	00a04574 	movhi	r2,33045
81134c10:	10936004 	addi	r2,r2,19840
81134c14:	200b883a 	mov	r5,r4
81134c18:	11000017 	ldw	r4,0(r2)
81134c1c:	1134b141 	jmpi	81134b14 <_fclose_r>

81134c20 <__fputwc>:
81134c20:	defff804 	addi	sp,sp,-32
81134c24:	de00012e 	bgeu	sp,et,81134c2c <__fputwc+0xc>
81134c28:	003b68fa 	trap	3
81134c2c:	dcc00415 	stw	r19,16(sp)
81134c30:	dc800315 	stw	r18,12(sp)
81134c34:	dc000115 	stw	r16,4(sp)
81134c38:	dfc00715 	stw	ra,28(sp)
81134c3c:	dd400615 	stw	r21,24(sp)
81134c40:	dd000515 	stw	r20,20(sp)
81134c44:	dc400215 	stw	r17,8(sp)
81134c48:	2027883a 	mov	r19,r4
81134c4c:	2825883a 	mov	r18,r5
81134c50:	3021883a 	mov	r16,r6
81134c54:	112e2c80 	call	8112e2c8 <__locale_mb_cur_max>
81134c58:	00c00044 	movi	r3,1
81134c5c:	10c03e26 	beq	r2,r3,81134d58 <__fputwc+0x138>
81134c60:	81c01704 	addi	r7,r16,92
81134c64:	900d883a 	mov	r6,r18
81134c68:	d80b883a 	mov	r5,sp
81134c6c:	9809883a 	mov	r4,r19
81134c70:	1135aa40 	call	81135aa4 <_wcrtomb_r>
81134c74:	1029883a 	mov	r20,r2
81134c78:	00bfffc4 	movi	r2,-1
81134c7c:	a0802026 	beq	r20,r2,81134d00 <__fputwc+0xe0>
81134c80:	d9400003 	ldbu	r5,0(sp)
81134c84:	a0001c26 	beq	r20,zero,81134cf8 <__fputwc+0xd8>
81134c88:	0023883a 	mov	r17,zero
81134c8c:	05400284 	movi	r21,10
81134c90:	00000906 	br	81134cb8 <__fputwc+0x98>
81134c94:	80800017 	ldw	r2,0(r16)
81134c98:	11400005 	stb	r5,0(r2)
81134c9c:	80c00017 	ldw	r3,0(r16)
81134ca0:	18c00044 	addi	r3,r3,1
81134ca4:	80c00015 	stw	r3,0(r16)
81134ca8:	8c400044 	addi	r17,r17,1
81134cac:	dc45883a 	add	r2,sp,r17
81134cb0:	8d00112e 	bgeu	r17,r20,81134cf8 <__fputwc+0xd8>
81134cb4:	11400003 	ldbu	r5,0(r2)
81134cb8:	80c00217 	ldw	r3,8(r16)
81134cbc:	18ffffc4 	addi	r3,r3,-1
81134cc0:	80c00215 	stw	r3,8(r16)
81134cc4:	183ff30e 	bge	r3,zero,81134c94 <__reset+0xfb114c94>
81134cc8:	80800617 	ldw	r2,24(r16)
81134ccc:	18801916 	blt	r3,r2,81134d34 <__fputwc+0x114>
81134cd0:	80800017 	ldw	r2,0(r16)
81134cd4:	11400005 	stb	r5,0(r2)
81134cd8:	80800017 	ldw	r2,0(r16)
81134cdc:	10c00003 	ldbu	r3,0(r2)
81134ce0:	10800044 	addi	r2,r2,1
81134ce4:	1d402326 	beq	r3,r21,81134d74 <__fputwc+0x154>
81134ce8:	80800015 	stw	r2,0(r16)
81134cec:	8c400044 	addi	r17,r17,1
81134cf0:	dc45883a 	add	r2,sp,r17
81134cf4:	8d3fef36 	bltu	r17,r20,81134cb4 <__reset+0xfb114cb4>
81134cf8:	9005883a 	mov	r2,r18
81134cfc:	00000406 	br	81134d10 <__fputwc+0xf0>
81134d00:	80c0030b 	ldhu	r3,12(r16)
81134d04:	a005883a 	mov	r2,r20
81134d08:	18c01014 	ori	r3,r3,64
81134d0c:	80c0030d 	sth	r3,12(r16)
81134d10:	dfc00717 	ldw	ra,28(sp)
81134d14:	dd400617 	ldw	r21,24(sp)
81134d18:	dd000517 	ldw	r20,20(sp)
81134d1c:	dcc00417 	ldw	r19,16(sp)
81134d20:	dc800317 	ldw	r18,12(sp)
81134d24:	dc400217 	ldw	r17,8(sp)
81134d28:	dc000117 	ldw	r16,4(sp)
81134d2c:	dec00804 	addi	sp,sp,32
81134d30:	f800283a 	ret
81134d34:	800d883a 	mov	r6,r16
81134d38:	29403fcc 	andi	r5,r5,255
81134d3c:	9809883a 	mov	r4,r19
81134d40:	112b1680 	call	8112b168 <__swbuf_r>
81134d44:	10bfffe0 	cmpeqi	r2,r2,-1
81134d48:	10803fcc 	andi	r2,r2,255
81134d4c:	103fd626 	beq	r2,zero,81134ca8 <__reset+0xfb114ca8>
81134d50:	00bfffc4 	movi	r2,-1
81134d54:	003fee06 	br	81134d10 <__reset+0xfb114d10>
81134d58:	90ffffc4 	addi	r3,r18,-1
81134d5c:	01003f84 	movi	r4,254
81134d60:	20ffbf36 	bltu	r4,r3,81134c60 <__reset+0xfb114c60>
81134d64:	900b883a 	mov	r5,r18
81134d68:	dc800005 	stb	r18,0(sp)
81134d6c:	1029883a 	mov	r20,r2
81134d70:	003fc506 	br	81134c88 <__reset+0xfb114c88>
81134d74:	800d883a 	mov	r6,r16
81134d78:	a80b883a 	mov	r5,r21
81134d7c:	9809883a 	mov	r4,r19
81134d80:	112b1680 	call	8112b168 <__swbuf_r>
81134d84:	10bfffe0 	cmpeqi	r2,r2,-1
81134d88:	003fef06 	br	81134d48 <__reset+0xfb114d48>

81134d8c <_fputwc_r>:
81134d8c:	3080030b 	ldhu	r2,12(r6)
81134d90:	10c8000c 	andi	r3,r2,8192
81134d94:	1800051e 	bne	r3,zero,81134dac <_fputwc_r+0x20>
81134d98:	30c01917 	ldw	r3,100(r6)
81134d9c:	10880014 	ori	r2,r2,8192
81134da0:	3080030d 	sth	r2,12(r6)
81134da4:	18880014 	ori	r2,r3,8192
81134da8:	30801915 	stw	r2,100(r6)
81134dac:	1134c201 	jmpi	81134c20 <__fputwc>

81134db0 <fputwc>:
81134db0:	00a04574 	movhi	r2,33045
81134db4:	defffc04 	addi	sp,sp,-16
81134db8:	10936004 	addi	r2,r2,19840
81134dbc:	de00012e 	bgeu	sp,et,81134dc4 <fputwc+0x14>
81134dc0:	003b68fa 	trap	3
81134dc4:	dc000115 	stw	r16,4(sp)
81134dc8:	14000017 	ldw	r16,0(r2)
81134dcc:	dc400215 	stw	r17,8(sp)
81134dd0:	dfc00315 	stw	ra,12(sp)
81134dd4:	2023883a 	mov	r17,r4
81134dd8:	80000226 	beq	r16,zero,81134de4 <fputwc+0x34>
81134ddc:	80800e17 	ldw	r2,56(r16)
81134de0:	10001026 	beq	r2,zero,81134e24 <fputwc+0x74>
81134de4:	2880030b 	ldhu	r2,12(r5)
81134de8:	10c8000c 	andi	r3,r2,8192
81134dec:	1800051e 	bne	r3,zero,81134e04 <fputwc+0x54>
81134df0:	28c01917 	ldw	r3,100(r5)
81134df4:	10880014 	ori	r2,r2,8192
81134df8:	2880030d 	sth	r2,12(r5)
81134dfc:	18880014 	ori	r2,r3,8192
81134e00:	28801915 	stw	r2,100(r5)
81134e04:	280d883a 	mov	r6,r5
81134e08:	8009883a 	mov	r4,r16
81134e0c:	880b883a 	mov	r5,r17
81134e10:	dfc00317 	ldw	ra,12(sp)
81134e14:	dc400217 	ldw	r17,8(sp)
81134e18:	dc000117 	ldw	r16,4(sp)
81134e1c:	dec00404 	addi	sp,sp,16
81134e20:	1134c201 	jmpi	81134c20 <__fputwc>
81134e24:	8009883a 	mov	r4,r16
81134e28:	d9400015 	stw	r5,0(sp)
81134e2c:	112d3a00 	call	8112d3a0 <__sinit>
81134e30:	d9400017 	ldw	r5,0(sp)
81134e34:	003feb06 	br	81134de4 <__reset+0xfb114de4>

81134e38 <rshift>:
81134e38:	2807d17a 	srai	r3,r5,5
81134e3c:	20800417 	ldw	r2,16(r4)
81134e40:	22000504 	addi	r8,r4,20
81134e44:	1880250e 	bge	r3,r2,81134edc <rshift+0xa4>
81134e48:	1085883a 	add	r2,r2,r2
81134e4c:	18c7883a 	add	r3,r3,r3
81134e50:	1085883a 	add	r2,r2,r2
81134e54:	18c7883a 	add	r3,r3,r3
81134e58:	294007cc 	andi	r5,r5,31
81134e5c:	4085883a 	add	r2,r8,r2
81134e60:	40c7883a 	add	r3,r8,r3
81134e64:	28002026 	beq	r5,zero,81134ee8 <rshift+0xb0>
81134e68:	19800017 	ldw	r6,0(r3)
81134e6c:	02c00804 	movi	r11,32
81134e70:	19c00104 	addi	r7,r3,4
81134e74:	5957c83a 	sub	r11,r11,r5
81134e78:	314cd83a 	srl	r6,r6,r5
81134e7c:	38802c2e 	bgeu	r7,r2,81134f30 <rshift+0xf8>
81134e80:	4015883a 	mov	r10,r8
81134e84:	3a400017 	ldw	r9,0(r7)
81134e88:	52800104 	addi	r10,r10,4
81134e8c:	39c00104 	addi	r7,r7,4
81134e90:	4ad2983a 	sll	r9,r9,r11
81134e94:	498cb03a 	or	r6,r9,r6
81134e98:	51bfff15 	stw	r6,-4(r10)
81134e9c:	39bfff17 	ldw	r6,-4(r7)
81134ea0:	314cd83a 	srl	r6,r6,r5
81134ea4:	38bff736 	bltu	r7,r2,81134e84 <__reset+0xfb114e84>
81134ea8:	10c7c83a 	sub	r3,r2,r3
81134eac:	18fffec4 	addi	r3,r3,-5
81134eb0:	1806d0ba 	srli	r3,r3,2
81134eb4:	18c00044 	addi	r3,r3,1
81134eb8:	18c7883a 	add	r3,r3,r3
81134ebc:	18c7883a 	add	r3,r3,r3
81134ec0:	40c7883a 	add	r3,r8,r3
81134ec4:	19800015 	stw	r6,0(r3)
81134ec8:	30000126 	beq	r6,zero,81134ed0 <rshift+0x98>
81134ecc:	18c00104 	addi	r3,r3,4
81134ed0:	1a05c83a 	sub	r2,r3,r8
81134ed4:	1005d0ba 	srai	r2,r2,2
81134ed8:	00001206 	br	81134f24 <rshift+0xec>
81134edc:	20000415 	stw	zero,16(r4)
81134ee0:	20000515 	stw	zero,20(r4)
81134ee4:	f800283a 	ret
81134ee8:	18bffc2e 	bgeu	r3,r2,81134edc <__reset+0xfb114edc>
81134eec:	180d883a 	mov	r6,r3
81134ef0:	400b883a 	mov	r5,r8
81134ef4:	31c00017 	ldw	r7,0(r6)
81134ef8:	29400104 	addi	r5,r5,4
81134efc:	31800104 	addi	r6,r6,4
81134f00:	29ffff15 	stw	r7,-4(r5)
81134f04:	30bffb36 	bltu	r6,r2,81134ef4 <__reset+0xfb114ef4>
81134f08:	00c6303a 	nor	r3,zero,r3
81134f0c:	1885883a 	add	r2,r3,r2
81134f10:	1004d0ba 	srli	r2,r2,2
81134f14:	10800044 	addi	r2,r2,1
81134f18:	1085883a 	add	r2,r2,r2
81134f1c:	1085883a 	add	r2,r2,r2
81134f20:	1005d0ba 	srai	r2,r2,2
81134f24:	20800415 	stw	r2,16(r4)
81134f28:	103fed26 	beq	r2,zero,81134ee0 <__reset+0xfb114ee0>
81134f2c:	f800283a 	ret
81134f30:	4007883a 	mov	r3,r8
81134f34:	003fe306 	br	81134ec4 <__reset+0xfb114ec4>

81134f38 <__gethex>:
81134f38:	deffeb04 	addi	sp,sp,-84
81134f3c:	de00012e 	bgeu	sp,et,81134f44 <__gethex+0xc>
81134f40:	003b68fa 	trap	3
81134f44:	dfc01415 	stw	ra,80(sp)
81134f48:	dd801115 	stw	r22,68(sp)
81134f4c:	dcc00e15 	stw	r19,56(sp)
81134f50:	dc800d15 	stw	r18,52(sp)
81134f54:	2827883a 	mov	r19,r5
81134f58:	d9000115 	stw	r4,4(sp)
81134f5c:	d9800015 	stw	r6,0(sp)
81134f60:	d9c00415 	stw	r7,16(sp)
81134f64:	df001315 	stw	fp,76(sp)
81134f68:	ddc01215 	stw	r23,72(sp)
81134f6c:	dd401015 	stw	r21,64(sp)
81134f70:	dd000f15 	stw	r20,60(sp)
81134f74:	dc400c15 	stw	r17,48(sp)
81134f78:	dc000b15 	stw	r16,44(sp)
81134f7c:	112e2ec0 	call	8112e2ec <_localeconv_r>
81134f80:	14800017 	ldw	r18,0(r2)
81134f84:	9009883a 	mov	r4,r18
81134f88:	1124dc80 	call	81124dc8 <strlen>
81134f8c:	98c00017 	ldw	r3,0(r19)
81134f90:	102d883a 	mov	r22,r2
81134f94:	9085883a 	add	r2,r18,r2
81134f98:	10bfffc3 	ldbu	r2,-1(r2)
81134f9c:	19000083 	ldbu	r4,2(r3)
81134fa0:	d8800305 	stb	r2,12(sp)
81134fa4:	00800c04 	movi	r2,48
81134fa8:	2081521e 	bne	r4,r2,811354f4 <__gethex+0x5bc>
81134fac:	017fff84 	movi	r5,-2
81134fb0:	188000c4 	addi	r2,r3,3
81134fb4:	28cbc83a 	sub	r5,r5,r3
81134fb8:	200d883a 	mov	r6,r4
81134fbc:	28a3883a 	add	r17,r5,r2
81134fc0:	102b883a 	mov	r21,r2
81134fc4:	10800044 	addi	r2,r2,1
81134fc8:	113fffc3 	ldbu	r4,-1(r2)
81134fcc:	21bffb26 	beq	r4,r6,81134fbc <__reset+0xfb114fbc>
81134fd0:	05204574 	movhi	r20,33045
81134fd4:	a50a2b04 	addi	r20,r20,10412
81134fd8:	a109883a 	add	r4,r20,r4
81134fdc:	20800003 	ldbu	r2,0(r4)
81134fe0:	10008826 	beq	r2,zero,81135204 <__gethex+0x2cc>
81134fe4:	a8800003 	ldbu	r2,0(r21)
81134fe8:	0015883a 	mov	r10,zero
81134fec:	002f883a 	mov	r23,zero
81134ff0:	a085883a 	add	r2,r20,r2
81134ff4:	10800003 	ldbu	r2,0(r2)
81134ff8:	a821883a 	mov	r16,r21
81134ffc:	10000526 	beq	r2,zero,81135014 <__gethex+0xdc>
81135000:	84000044 	addi	r16,r16,1
81135004:	80800003 	ldbu	r2,0(r16)
81135008:	a085883a 	add	r2,r20,r2
8113500c:	10800003 	ldbu	r2,0(r2)
81135010:	103ffb1e 	bne	r2,zero,81135000 <__reset+0xfb115000>
81135014:	b00d883a 	mov	r6,r22
81135018:	900b883a 	mov	r5,r18
8113501c:	8009883a 	mov	r4,r16
81135020:	da800a15 	stw	r10,40(sp)
81135024:	11359d40 	call	811359d4 <strncmp>
81135028:	da800a17 	ldw	r10,40(sp)
8113502c:	1000031e 	bne	r2,zero,8113503c <__gethex+0x104>
81135030:	b8015226 	beq	r23,zero,8113557c <__gethex+0x644>
81135034:	80800003 	ldbu	r2,0(r16)
81135038:	00000206 	br	81135044 <__gethex+0x10c>
8113503c:	80800003 	ldbu	r2,0(r16)
81135040:	b8011f26 	beq	r23,zero,811354c0 <__gethex+0x588>
81135044:	85efc83a 	sub	r23,r16,r23
81135048:	bdef883a 	add	r23,r23,r23
8113504c:	bdef883a 	add	r23,r23,r23
81135050:	05efc83a 	sub	r23,zero,r23
81135054:	10803fcc 	andi	r2,r2,255
81135058:	01001404 	movi	r4,80
8113505c:	11008626 	beq	r2,r4,81135278 <__gethex+0x340>
81135060:	01001c04 	movi	r4,112
81135064:	11008426 	beq	r2,r4,81135278 <__gethex+0x340>
81135068:	8039883a 	mov	fp,r16
8113506c:	9c000015 	stw	r16,0(r19)
81135070:	5000711e 	bne	r10,zero,81135238 <__gethex+0x300>
81135074:	e545c83a 	sub	r2,fp,r21
81135078:	10bfffc4 	addi	r2,r2,-1
8113507c:	010001c4 	movi	r4,7
81135080:	000b883a 	mov	r5,zero
81135084:	2080030e 	bge	r4,r2,81135094 <__gethex+0x15c>
81135088:	1005d07a 	srai	r2,r2,1
8113508c:	29400044 	addi	r5,r5,1
81135090:	20bffd16 	blt	r4,r2,81135088 <__reset+0xfb115088>
81135094:	d9000117 	ldw	r4,4(sp)
81135098:	112e8080 	call	8112e808 <_Balloc>
8113509c:	10c00504 	addi	r3,r2,20
811350a0:	d8c00215 	stw	r3,8(sp)
811350a4:	1021883a 	mov	r16,r2
811350a8:	af01732e 	bgeu	r21,fp,81135678 <__gethex+0x740>
811350ac:	dc400303 	ldbu	r17,12(sp)
811350b0:	03400044 	movi	r13,1
811350b4:	1815883a 	mov	r10,r3
811350b8:	0013883a 	mov	r9,zero
811350bc:	0027883a 	mov	r19,zero
811350c0:	6d9bc83a 	sub	r13,r13,r22
811350c4:	02c00804 	movi	r11,32
811350c8:	e0bfffc3 	ldbu	r2,-1(fp)
811350cc:	e3bfffc4 	addi	r14,fp,-1
811350d0:	88803026 	beq	r17,r2,81135194 <__gethex+0x25c>
811350d4:	9ac04526 	beq	r19,r11,811351ec <__gethex+0x2b4>
811350d8:	980b883a 	mov	r5,r19
811350dc:	9cc00104 	addi	r19,r19,4
811350e0:	e13fffc3 	ldbu	r4,-1(fp)
811350e4:	7039883a 	mov	fp,r14
811350e8:	a109883a 	add	r4,r20,r4
811350ec:	20800003 	ldbu	r2,0(r4)
811350f0:	108003cc 	andi	r2,r2,15
811350f4:	1144983a 	sll	r2,r2,r5
811350f8:	4892b03a 	or	r9,r9,r2
811350fc:	af3ff236 	bltu	r21,fp,811350c8 <__reset+0xfb1150c8>
81135100:	d8c00217 	ldw	r3,8(sp)
81135104:	50800104 	addi	r2,r10,4
81135108:	52400015 	stw	r9,0(r10)
8113510c:	10c5c83a 	sub	r2,r2,r3
81135110:	1005d0ba 	srai	r2,r2,2
81135114:	4809883a 	mov	r4,r9
81135118:	80800415 	stw	r2,16(r16)
8113511c:	1022917a 	slli	r17,r2,5
81135120:	112eb140 	call	8112eb14 <__hi0bits>
81135124:	d8c00017 	ldw	r3,0(sp)
81135128:	8885c83a 	sub	r2,r17,r2
8113512c:	1c800017 	ldw	r18,0(r3)
81135130:	9080c716 	blt	r18,r2,81135450 <__gethex+0x518>
81135134:	1480e416 	blt	r2,r18,811354c8 <__gethex+0x590>
81135138:	0027883a 	mov	r19,zero
8113513c:	d8c00017 	ldw	r3,0(sp)
81135140:	18800217 	ldw	r2,8(r3)
81135144:	15c08d16 	blt	r2,r23,8113537c <__gethex+0x444>
81135148:	d8c00017 	ldw	r3,0(sp)
8113514c:	18800117 	ldw	r2,4(r3)
81135150:	b880aa0e 	bge	r23,r2,811353fc <__gethex+0x4c4>
81135154:	15efc83a 	sub	r23,r2,r23
81135158:	bc80ed16 	blt	r23,r18,81135510 <__gethex+0x5d8>
8113515c:	18c00317 	ldw	r3,12(r3)
81135160:	01000084 	movi	r4,2
81135164:	19014926 	beq	r3,r4,8113568c <__gethex+0x754>
81135168:	010000c4 	movi	r4,3
8113516c:	19012e26 	beq	r3,r4,81135628 <__gethex+0x6f0>
81135170:	01000044 	movi	r4,1
81135174:	19014826 	beq	r3,r4,81135698 <__gethex+0x760>
81135178:	d9000117 	ldw	r4,4(sp)
8113517c:	800b883a 	mov	r5,r16
81135180:	112e8b80 	call	8112e8b8 <_Bfree>
81135184:	d8801517 	ldw	r2,84(sp)
81135188:	10000015 	stw	zero,0(r2)
8113518c:	00801404 	movi	r2,80
81135190:	00002b06 	br	81135240 <__gethex+0x308>
81135194:	735f883a 	add	r15,r14,r13
81135198:	7d7fce36 	bltu	r15,r21,811350d4 <__reset+0xfb1150d4>
8113519c:	7809883a 	mov	r4,r15
811351a0:	b00d883a 	mov	r6,r22
811351a4:	900b883a 	mov	r5,r18
811351a8:	da400515 	stw	r9,20(sp)
811351ac:	da800a15 	stw	r10,40(sp)
811351b0:	dac00915 	stw	r11,36(sp)
811351b4:	db400815 	stw	r13,32(sp)
811351b8:	db800615 	stw	r14,24(sp)
811351bc:	dbc00715 	stw	r15,28(sp)
811351c0:	11359d40 	call	811359d4 <strncmp>
811351c4:	da400517 	ldw	r9,20(sp)
811351c8:	da800a17 	ldw	r10,40(sp)
811351cc:	dac00917 	ldw	r11,36(sp)
811351d0:	db400817 	ldw	r13,32(sp)
811351d4:	db800617 	ldw	r14,24(sp)
811351d8:	dbc00717 	ldw	r15,28(sp)
811351dc:	103fbd1e 	bne	r2,zero,811350d4 <__reset+0xfb1150d4>
811351e0:	7839883a 	mov	fp,r15
811351e4:	af3fb836 	bltu	r21,fp,811350c8 <__reset+0xfb1150c8>
811351e8:	003fc506 	br	81135100 <__reset+0xfb115100>
811351ec:	04c00104 	movi	r19,4
811351f0:	52400015 	stw	r9,0(r10)
811351f4:	000b883a 	mov	r5,zero
811351f8:	54d5883a 	add	r10,r10,r19
811351fc:	0013883a 	mov	r9,zero
81135200:	003fb706 	br	811350e0 <__reset+0xfb1150e0>
81135204:	b00d883a 	mov	r6,r22
81135208:	900b883a 	mov	r5,r18
8113520c:	a809883a 	mov	r4,r21
81135210:	11359d40 	call	811359d4 <strncmp>
81135214:	10006426 	beq	r2,zero,811353a8 <__gethex+0x470>
81135218:	a8800003 	ldbu	r2,0(r21)
8113521c:	a821883a 	mov	r16,r21
81135220:	10803fcc 	andi	r2,r2,255
81135224:	01001404 	movi	r4,80
81135228:	11001126 	beq	r2,r4,81135270 <__gethex+0x338>
8113522c:	01001c04 	movi	r4,112
81135230:	11000f26 	beq	r2,r4,81135270 <__gethex+0x338>
81135234:	9c000015 	stw	r16,0(r19)
81135238:	8800831e 	bne	r17,zero,81135448 <__gethex+0x510>
8113523c:	00800184 	movi	r2,6
81135240:	dfc01417 	ldw	ra,80(sp)
81135244:	df001317 	ldw	fp,76(sp)
81135248:	ddc01217 	ldw	r23,72(sp)
8113524c:	dd801117 	ldw	r22,68(sp)
81135250:	dd401017 	ldw	r21,64(sp)
81135254:	dd000f17 	ldw	r20,60(sp)
81135258:	dcc00e17 	ldw	r19,56(sp)
8113525c:	dc800d17 	ldw	r18,52(sp)
81135260:	dc400c17 	ldw	r17,48(sp)
81135264:	dc000b17 	ldw	r16,44(sp)
81135268:	dec01504 	addi	sp,sp,84
8113526c:	f800283a 	ret
81135270:	002f883a 	mov	r23,zero
81135274:	02800044 	movi	r10,1
81135278:	80800043 	ldbu	r2,1(r16)
8113527c:	01400ac4 	movi	r5,43
81135280:	11003fcc 	andi	r4,r2,255
81135284:	21406e26 	beq	r4,r5,81135440 <__gethex+0x508>
81135288:	01400b44 	movi	r5,45
8113528c:	21404226 	beq	r4,r5,81135398 <__gethex+0x460>
81135290:	81400044 	addi	r5,r16,1
81135294:	000d883a 	mov	r6,zero
81135298:	10803fcc 	andi	r2,r2,255
8113529c:	a085883a 	add	r2,r20,r2
811352a0:	11000003 	ldbu	r4,0(r2)
811352a4:	03000604 	movi	r12,24
811352a8:	20bfffc4 	addi	r2,r4,-1
811352ac:	10803fcc 	andi	r2,r2,255
811352b0:	60bf6d36 	bltu	r12,r2,81135068 <__reset+0xfb115068>
811352b4:	2ac00043 	ldbu	r11,1(r5)
811352b8:	20803fcc 	andi	r2,r4,255
811352bc:	01204574 	movhi	r4,33045
811352c0:	210a2b04 	addi	r4,r4,10412
811352c4:	22c9883a 	add	r4,r4,r11
811352c8:	23400003 	ldbu	r13,0(r4)
811352cc:	10bffc04 	addi	r2,r2,-16
811352d0:	29400044 	addi	r5,r5,1
811352d4:	693fffc4 	addi	r4,r13,-1
811352d8:	21003fcc 	andi	r4,r4,255
811352dc:	6b403fcc 	andi	r13,r13,255
811352e0:	61000b36 	bltu	r12,r4,81135310 <__gethex+0x3d8>
811352e4:	29400044 	addi	r5,r5,1
811352e8:	29000003 	ldbu	r4,0(r5)
811352ec:	108002a4 	muli	r2,r2,10
811352f0:	a109883a 	add	r4,r20,r4
811352f4:	22c00003 	ldbu	r11,0(r4)
811352f8:	1345883a 	add	r2,r2,r13
811352fc:	10bffc04 	addi	r2,r2,-16
81135300:	593fffc4 	addi	r4,r11,-1
81135304:	21003fcc 	andi	r4,r4,255
81135308:	5b403fcc 	andi	r13,r11,255
8113530c:	613ff52e 	bgeu	r12,r4,811352e4 <__reset+0xfb1152e4>
81135310:	30000126 	beq	r6,zero,81135318 <__gethex+0x3e0>
81135314:	0085c83a 	sub	r2,zero,r2
81135318:	8039883a 	mov	fp,r16
8113531c:	b8af883a 	add	r23,r23,r2
81135320:	2821883a 	mov	r16,r5
81135324:	003f5106 	br	8113506c <__reset+0xfb11506c>
81135328:	80800217 	ldw	r2,8(r16)
8113532c:	e080f00e 	bge	fp,r2,811356f0 <__gethex+0x7b8>
81135330:	e007883a 	mov	r3,fp
81135334:	18800144 	addi	r2,r3,5
81135338:	1085883a 	add	r2,r2,r2
8113533c:	18c00044 	addi	r3,r3,1
81135340:	1085883a 	add	r2,r2,r2
81135344:	8085883a 	add	r2,r16,r2
81135348:	80c00415 	stw	r3,16(r16)
8113534c:	01000044 	movi	r4,1
81135350:	11000015 	stw	r4,0(r2)
81135354:	00800084 	movi	r2,2
81135358:	8880d826 	beq	r17,r2,811356bc <__gethex+0x784>
8113535c:	e0c0ac0e 	bge	fp,r3,81135610 <__gethex+0x6d8>
81135360:	01400044 	movi	r5,1
81135364:	8009883a 	mov	r4,r16
81135368:	1134e380 	call	81134e38 <rshift>
8113536c:	d8c00017 	ldw	r3,0(sp)
81135370:	bdc00044 	addi	r23,r23,1
81135374:	18800217 	ldw	r2,8(r3)
81135378:	15c0a70e 	bge	r2,r23,81135618 <__gethex+0x6e0>
8113537c:	d9000117 	ldw	r4,4(sp)
81135380:	800b883a 	mov	r5,r16
81135384:	112e8b80 	call	8112e8b8 <_Bfree>
81135388:	d9001517 	ldw	r4,84(sp)
8113538c:	008028c4 	movi	r2,163
81135390:	20000015 	stw	zero,0(r4)
81135394:	003faa06 	br	81135240 <__reset+0xfb115240>
81135398:	01800044 	movi	r6,1
8113539c:	80800083 	ldbu	r2,2(r16)
811353a0:	81400084 	addi	r5,r16,2
811353a4:	003fbc06 	br	81135298 <__reset+0xfb115298>
811353a8:	ada1883a 	add	r16,r21,r22
811353ac:	81000003 	ldbu	r4,0(r16)
811353b0:	21403fcc 	andi	r5,r4,255
811353b4:	a145883a 	add	r2,r20,r5
811353b8:	10800003 	ldbu	r2,0(r2)
811353bc:	11803fcc 	andi	r6,r2,255
811353c0:	30004f26 	beq	r6,zero,81135500 <__gethex+0x5c8>
811353c4:	00c00c04 	movi	r3,48
811353c8:	802b883a 	mov	r21,r16
811353cc:	28c0061e 	bne	r5,r3,811353e8 <__gethex+0x4b0>
811353d0:	2809883a 	mov	r4,r5
811353d4:	ad400044 	addi	r21,r21,1
811353d8:	a8800003 	ldbu	r2,0(r21)
811353dc:	113ffd26 	beq	r2,r4,811353d4 <__reset+0xfb1153d4>
811353e0:	a085883a 	add	r2,r20,r2
811353e4:	10800003 	ldbu	r2,0(r2)
811353e8:	10803fcc 	andi	r2,r2,255
811353ec:	1015003a 	cmpeq	r10,r2,zero
811353f0:	802f883a 	mov	r23,r16
811353f4:	04400044 	movi	r17,1
811353f8:	003eff06 	br	81134ff8 <__reset+0xfb114ff8>
811353fc:	04400044 	movi	r17,1
81135400:	98000926 	beq	r19,zero,81135428 <__gethex+0x4f0>
81135404:	d8c00017 	ldw	r3,0(sp)
81135408:	18800317 	ldw	r2,12(r3)
8113540c:	00c00084 	movi	r3,2
81135410:	10c06826 	beq	r2,r3,811355b4 <__gethex+0x67c>
81135414:	00c000c4 	movi	r3,3
81135418:	10c06a26 	beq	r2,r3,811355c4 <__gethex+0x68c>
8113541c:	00c00044 	movi	r3,1
81135420:	10c08d26 	beq	r2,r3,81135658 <__gethex+0x720>
81135424:	8c400414 	ori	r17,r17,16
81135428:	d9001517 	ldw	r4,84(sp)
8113542c:	d8c00417 	ldw	r3,16(sp)
81135430:	8805883a 	mov	r2,r17
81135434:	24000015 	stw	r16,0(r4)
81135438:	1dc00015 	stw	r23,0(r3)
8113543c:	003f8006 	br	81135240 <__reset+0xfb115240>
81135440:	000d883a 	mov	r6,zero
81135444:	003fd506 	br	8113539c <__reset+0xfb11539c>
81135448:	0005883a 	mov	r2,zero
8113544c:	003f7c06 	br	81135240 <__reset+0xfb115240>
81135450:	14a3c83a 	sub	r17,r2,r18
81135454:	880b883a 	mov	r5,r17
81135458:	8009883a 	mov	r4,r16
8113545c:	112f7d80 	call	8112f7d8 <__any_on>
81135460:	10002926 	beq	r2,zero,81135508 <__gethex+0x5d0>
81135464:	897fffc4 	addi	r5,r17,-1
81135468:	2807d17a 	srai	r3,r5,5
8113546c:	d8800217 	ldw	r2,8(sp)
81135470:	290007cc 	andi	r4,r5,31
81135474:	18c7883a 	add	r3,r3,r3
81135478:	18c7883a 	add	r3,r3,r3
8113547c:	04c00044 	movi	r19,1
81135480:	10c7883a 	add	r3,r2,r3
81135484:	9908983a 	sll	r4,r19,r4
81135488:	18c00017 	ldw	r3,0(r3)
8113548c:	20c6703a 	and	r3,r4,r3
81135490:	18000626 	beq	r3,zero,811354ac <__gethex+0x574>
81135494:	99407b0e 	bge	r19,r5,81135684 <__gethex+0x74c>
81135498:	897fff84 	addi	r5,r17,-2
8113549c:	8009883a 	mov	r4,r16
811354a0:	112f7d80 	call	8112f7d8 <__any_on>
811354a4:	10007726 	beq	r2,zero,81135684 <__gethex+0x74c>
811354a8:	04c000c4 	movi	r19,3
811354ac:	880b883a 	mov	r5,r17
811354b0:	8009883a 	mov	r4,r16
811354b4:	1134e380 	call	81134e38 <rshift>
811354b8:	bc6f883a 	add	r23,r23,r17
811354bc:	003f1f06 	br	8113513c <__reset+0xfb11513c>
811354c0:	002f883a 	mov	r23,zero
811354c4:	003ee306 	br	81135054 <__reset+0xfb115054>
811354c8:	d9000117 	ldw	r4,4(sp)
811354cc:	90a3c83a 	sub	r17,r18,r2
811354d0:	800b883a 	mov	r5,r16
811354d4:	880d883a 	mov	r6,r17
811354d8:	112efb80 	call	8112efb8 <__lshift>
811354dc:	10c00504 	addi	r3,r2,20
811354e0:	1021883a 	mov	r16,r2
811354e4:	bc6fc83a 	sub	r23,r23,r17
811354e8:	d8c00215 	stw	r3,8(sp)
811354ec:	0027883a 	mov	r19,zero
811354f0:	003f1206 	br	8113513c <__reset+0xfb11513c>
811354f4:	1d400084 	addi	r21,r3,2
811354f8:	0023883a 	mov	r17,zero
811354fc:	003eb406 	br	81134fd0 <__reset+0xfb114fd0>
81135500:	2005883a 	mov	r2,r4
81135504:	003f4606 	br	81135220 <__reset+0xfb115220>
81135508:	0027883a 	mov	r19,zero
8113550c:	003fe706 	br	811354ac <__reset+0xfb1154ac>
81135510:	bc7fffc4 	addi	r17,r23,-1
81135514:	9800421e 	bne	r19,zero,81135620 <__gethex+0x6e8>
81135518:	88000426 	beq	r17,zero,8113552c <__gethex+0x5f4>
8113551c:	880b883a 	mov	r5,r17
81135520:	8009883a 	mov	r4,r16
81135524:	112f7d80 	call	8112f7d8 <__any_on>
81135528:	1027883a 	mov	r19,r2
8113552c:	8805d17a 	srai	r2,r17,5
81135530:	d8c00217 	ldw	r3,8(sp)
81135534:	8c4007cc 	andi	r17,r17,31
81135538:	1085883a 	add	r2,r2,r2
8113553c:	1085883a 	add	r2,r2,r2
81135540:	1885883a 	add	r2,r3,r2
81135544:	00c00044 	movi	r3,1
81135548:	1c62983a 	sll	r17,r3,r17
8113554c:	10800017 	ldw	r2,0(r2)
81135550:	8884703a 	and	r2,r17,r2
81135554:	10000126 	beq	r2,zero,8113555c <__gethex+0x624>
81135558:	9cc00094 	ori	r19,r19,2
8113555c:	b80b883a 	mov	r5,r23
81135560:	8009883a 	mov	r4,r16
81135564:	1134e380 	call	81134e38 <rshift>
81135568:	d8c00017 	ldw	r3,0(sp)
8113556c:	95e5c83a 	sub	r18,r18,r23
81135570:	04400084 	movi	r17,2
81135574:	1dc00117 	ldw	r23,4(r3)
81135578:	003fa106 	br	81135400 <__reset+0xfb115400>
8113557c:	85af883a 	add	r23,r16,r22
81135580:	b8800003 	ldbu	r2,0(r23)
81135584:	b821883a 	mov	r16,r23
81135588:	11003fcc 	andi	r4,r2,255
8113558c:	a109883a 	add	r4,r20,r4
81135590:	21000003 	ldbu	r4,0(r4)
81135594:	203eaa26 	beq	r4,zero,81135040 <__reset+0xfb115040>
81135598:	84000044 	addi	r16,r16,1
8113559c:	80800003 	ldbu	r2,0(r16)
811355a0:	11003fcc 	andi	r4,r2,255
811355a4:	a109883a 	add	r4,r20,r4
811355a8:	21000003 	ldbu	r4,0(r4)
811355ac:	203ffa1e 	bne	r4,zero,81135598 <__reset+0xfb115598>
811355b0:	003ea306 	br	81135040 <__reset+0xfb115040>
811355b4:	d9001617 	ldw	r4,88(sp)
811355b8:	00800044 	movi	r2,1
811355bc:	1109c83a 	sub	r4,r2,r4
811355c0:	d9001615 	stw	r4,88(sp)
811355c4:	d8801617 	ldw	r2,88(sp)
811355c8:	103f9626 	beq	r2,zero,81135424 <__reset+0xfb115424>
811355cc:	87000417 	ldw	fp,16(r16)
811355d0:	d9800217 	ldw	r6,8(sp)
811355d4:	013fffc4 	movi	r4,-1
811355d8:	e727883a 	add	r19,fp,fp
811355dc:	9ce7883a 	add	r19,r19,r19
811355e0:	3005883a 	mov	r2,r6
811355e4:	34cb883a 	add	r5,r6,r19
811355e8:	00000306 	br	811355f8 <__gethex+0x6c0>
811355ec:	10000015 	stw	zero,0(r2)
811355f0:	10800104 	addi	r2,r2,4
811355f4:	117f4c2e 	bgeu	r2,r5,81135328 <__reset+0xfb115328>
811355f8:	10c00017 	ldw	r3,0(r2)
811355fc:	193ffb26 	beq	r3,r4,811355ec <__reset+0xfb1155ec>
81135600:	18c00044 	addi	r3,r3,1
81135604:	10c00015 	stw	r3,0(r2)
81135608:	00800084 	movi	r2,2
8113560c:	88802b26 	beq	r17,r2,811356bc <__gethex+0x784>
81135610:	948007cc 	andi	r18,r18,31
81135614:	90002f1e 	bne	r18,zero,811356d4 <__gethex+0x79c>
81135618:	04400844 	movi	r17,33
8113561c:	003f8206 	br	81135428 <__reset+0xfb115428>
81135620:	04c00044 	movi	r19,1
81135624:	003fc106 	br	8113552c <__reset+0xfb11552c>
81135628:	d8c01617 	ldw	r3,88(sp)
8113562c:	183ed226 	beq	r3,zero,81135178 <__reset+0xfb115178>
81135630:	d8c00417 	ldw	r3,16(sp)
81135634:	d9001517 	ldw	r4,84(sp)
81135638:	18800015 	stw	r2,0(r3)
8113563c:	d8c00217 	ldw	r3,8(sp)
81135640:	00800044 	movi	r2,1
81135644:	80800415 	stw	r2,16(r16)
81135648:	18800015 	stw	r2,0(r3)
8113564c:	24000015 	stw	r16,0(r4)
81135650:	00801884 	movi	r2,98
81135654:	003efa06 	br	81135240 <__reset+0xfb115240>
81135658:	9880008c 	andi	r2,r19,2
8113565c:	103f7126 	beq	r2,zero,81135424 <__reset+0xfb115424>
81135660:	d8c00217 	ldw	r3,8(sp)
81135664:	18800017 	ldw	r2,0(r3)
81135668:	9884b03a 	or	r2,r19,r2
8113566c:	1080004c 	andi	r2,r2,1
81135670:	103fd61e 	bne	r2,zero,811355cc <__reset+0xfb1155cc>
81135674:	003f6b06 	br	81135424 <__reset+0xfb115424>
81135678:	da800217 	ldw	r10,8(sp)
8113567c:	0013883a 	mov	r9,zero
81135680:	003e9f06 	br	81135100 <__reset+0xfb115100>
81135684:	04c00084 	movi	r19,2
81135688:	003f8806 	br	811354ac <__reset+0xfb1154ac>
8113568c:	d9001617 	ldw	r4,88(sp)
81135690:	203fe726 	beq	r4,zero,81135630 <__reset+0xfb115630>
81135694:	003eb806 	br	81135178 <__reset+0xfb115178>
81135698:	95feb71e 	bne	r18,r23,81135178 <__reset+0xfb115178>
8113569c:	1cbfe40e 	bge	r3,r18,81135630 <__reset+0xfb115630>
811356a0:	917fffc4 	addi	r5,r18,-1
811356a4:	8009883a 	mov	r4,r16
811356a8:	112f7d80 	call	8112f7d8 <__any_on>
811356ac:	103eb226 	beq	r2,zero,81135178 <__reset+0xfb115178>
811356b0:	d8c00017 	ldw	r3,0(sp)
811356b4:	18800117 	ldw	r2,4(r3)
811356b8:	003fdd06 	br	81135630 <__reset+0xfb115630>
811356bc:	d8c00017 	ldw	r3,0(sp)
811356c0:	18800017 	ldw	r2,0(r3)
811356c4:	10bfffc4 	addi	r2,r2,-1
811356c8:	90801c26 	beq	r18,r2,8113573c <__gethex+0x804>
811356cc:	04400884 	movi	r17,34
811356d0:	003f5506 	br	81135428 <__reset+0xfb115428>
811356d4:	34c5883a 	add	r2,r6,r19
811356d8:	113fff17 	ldw	r4,-4(r2)
811356dc:	112eb140 	call	8112eb14 <__hi0bits>
811356e0:	00c00804 	movi	r3,32
811356e4:	1ca5c83a 	sub	r18,r3,r18
811356e8:	14bfcb0e 	bge	r2,r18,81135618 <__reset+0xfb115618>
811356ec:	003f1c06 	br	81135360 <__reset+0xfb115360>
811356f0:	81400117 	ldw	r5,4(r16)
811356f4:	d9000117 	ldw	r4,4(sp)
811356f8:	29400044 	addi	r5,r5,1
811356fc:	112e8080 	call	8112e808 <_Balloc>
81135700:	81800417 	ldw	r6,16(r16)
81135704:	81400304 	addi	r5,r16,12
81135708:	11000304 	addi	r4,r2,12
8113570c:	31800084 	addi	r6,r6,2
81135710:	318d883a 	add	r6,r6,r6
81135714:	318d883a 	add	r6,r6,r6
81135718:	1029883a 	mov	r20,r2
8113571c:	11243500 	call	81124350 <memcpy>
81135720:	d9000117 	ldw	r4,4(sp)
81135724:	800b883a 	mov	r5,r16
81135728:	a021883a 	mov	r16,r20
8113572c:	112e8b80 	call	8112e8b8 <_Bfree>
81135730:	a0c00417 	ldw	r3,16(r20)
81135734:	a1800504 	addi	r6,r20,20
81135738:	003efe06 	br	81135334 <__reset+0xfb115334>
8113573c:	9005d17a 	srai	r2,r18,5
81135740:	944007cc 	andi	r17,r18,31
81135744:	1085883a 	add	r2,r2,r2
81135748:	1085883a 	add	r2,r2,r2
8113574c:	3087883a 	add	r3,r6,r2
81135750:	00800044 	movi	r2,1
81135754:	1462983a 	sll	r17,r2,r17
81135758:	18800017 	ldw	r2,0(r3)
8113575c:	8884703a 	and	r2,r17,r2
81135760:	1022c03a 	cmpne	r17,r2,zero
81135764:	00800884 	movi	r2,34
81135768:	1463c83a 	sub	r17,r2,r17
8113576c:	003f2e06 	br	81135428 <__reset+0xfb115428>

81135770 <__hexnan>:
81135770:	defff904 	addi	sp,sp,-28
81135774:	de00012e 	bgeu	sp,et,8113577c <__hexnan+0xc>
81135778:	003b68fa 	trap	3
8113577c:	dc800215 	stw	r18,8(sp)
81135780:	2c800017 	ldw	r18,0(r5)
81135784:	dfc00615 	stw	ra,24(sp)
81135788:	dd400515 	stw	r21,20(sp)
8113578c:	901fd17a 	srai	r15,r18,5
81135790:	dd000415 	stw	r20,16(sp)
81135794:	dcc00315 	stw	r19,12(sp)
81135798:	7bdf883a 	add	r15,r15,r15
8113579c:	7bdf883a 	add	r15,r15,r15
811357a0:	dc400115 	stw	r17,4(sp)
811357a4:	dc000015 	stw	r16,0(sp)
811357a8:	948007cc 	andi	r18,r18,31
811357ac:	33df883a 	add	r15,r6,r15
811357b0:	90000126 	beq	r18,zero,811357b8 <__hexnan+0x48>
811357b4:	7bc00104 	addi	r15,r15,4
811357b8:	22000017 	ldw	r8,0(r4)
811357bc:	7affff04 	addi	r11,r15,-4
811357c0:	03a04574 	movhi	r14,33045
811357c4:	783fff15 	stw	zero,-4(r15)
811357c8:	581b883a 	mov	r13,r11
811357cc:	580b883a 	mov	r5,r11
811357d0:	000f883a 	mov	r7,zero
811357d4:	003f883a 	mov	ra,zero
811357d8:	0019883a 	mov	r12,zero
811357dc:	738a2b04 	addi	r14,r14,10412
811357e0:	04400204 	movi	r17,8
811357e4:	04000804 	movi	r16,32
811357e8:	04c001c4 	movi	r19,7
811357ec:	42000044 	addi	r8,r8,1
811357f0:	40c00003 	ldbu	r3,0(r8)
811357f4:	18001d26 	beq	r3,zero,8113586c <__hexnan+0xfc>
811357f8:	70c5883a 	add	r2,r14,r3
811357fc:	10800003 	ldbu	r2,0(r2)
81135800:	12403fcc 	andi	r9,r2,255
81135804:	4800301e 	bne	r9,zero,811358c8 <__hexnan+0x158>
81135808:	80c04236 	bltu	r16,r3,81135914 <__hexnan+0x1a4>
8113580c:	fb3ff70e 	bge	ra,r12,811357ec <__reset+0xfb1157ec>
81135810:	2b40112e 	bgeu	r5,r13,81135858 <__hexnan+0xe8>
81135814:	99c01016 	blt	r19,r7,81135858 <__hexnan+0xe8>
81135818:	89e9c83a 	sub	r20,r17,r7
8113581c:	a529883a 	add	r20,r20,r20
81135820:	2a800017 	ldw	r10,0(r5)
81135824:	a529883a 	add	r20,r20,r20
81135828:	852bc83a 	sub	r21,r16,r20
8113582c:	28c00104 	addi	r3,r5,4
81135830:	2805883a 	mov	r2,r5
81135834:	19c00017 	ldw	r7,0(r3)
81135838:	10800104 	addi	r2,r2,4
8113583c:	18c00104 	addi	r3,r3,4
81135840:	3d52983a 	sll	r9,r7,r21
81135844:	4a92b03a 	or	r9,r9,r10
81135848:	3d14d83a 	srl	r10,r7,r20
8113584c:	127fff15 	stw	r9,-4(r2)
81135850:	1abfff15 	stw	r10,-4(r3)
81135854:	137ff736 	bltu	r2,r13,81135834 <__reset+0xfb115834>
81135858:	31402836 	bltu	r6,r5,811358fc <__hexnan+0x18c>
8113585c:	42000044 	addi	r8,r8,1
81135860:	40c00003 	ldbu	r3,0(r8)
81135864:	01c00204 	movi	r7,8
81135868:	183fe31e 	bne	r3,zero,811357f8 <__reset+0xfb1157f8>
8113586c:	60002b26 	beq	r12,zero,8113591c <__hexnan+0x1ac>
81135870:	2b40022e 	bgeu	r5,r13,8113587c <__hexnan+0x10c>
81135874:	008001c4 	movi	r2,7
81135878:	11c0430e 	bge	r2,r7,81135988 <__hexnan+0x218>
8113587c:	3140312e 	bgeu	r6,r5,81135944 <__hexnan+0x1d4>
81135880:	3007883a 	mov	r3,r6
81135884:	29000017 	ldw	r4,0(r5)
81135888:	18800104 	addi	r2,r3,4
8113588c:	29400104 	addi	r5,r5,4
81135890:	19000015 	stw	r4,0(r3)
81135894:	1007883a 	mov	r3,r2
81135898:	597ffa2e 	bgeu	r11,r5,81135884 <__reset+0xfb115884>
8113589c:	10000015 	stw	zero,0(r2)
811358a0:	10800104 	addi	r2,r2,4
811358a4:	58bffd2e 	bgeu	r11,r2,8113589c <__reset+0xfb11589c>
811358a8:	78bfff17 	ldw	r2,-4(r15)
811358ac:	1000041e 	bne	r2,zero,811358c0 <__hexnan+0x150>
811358b0:	32c02d26 	beq	r6,r11,81135968 <__hexnan+0x1f8>
811358b4:	5affff04 	addi	r11,r11,-4
811358b8:	58800017 	ldw	r2,0(r11)
811358bc:	103ffc26 	beq	r2,zero,811358b0 <__reset+0xfb1158b0>
811358c0:	00800144 	movi	r2,5
811358c4:	00001606 	br	81135920 <__hexnan+0x1b0>
811358c8:	39c00044 	addi	r7,r7,1
811358cc:	63000044 	addi	r12,r12,1
811358d0:	89c0040e 	bge	r17,r7,811358e4 <__hexnan+0x174>
811358d4:	317fc52e 	bgeu	r6,r5,811357ec <__reset+0xfb1157ec>
811358d8:	283fff15 	stw	zero,-4(r5)
811358dc:	01c00044 	movi	r7,1
811358e0:	297fff04 	addi	r5,r5,-4
811358e4:	28c00017 	ldw	r3,0(r5)
811358e8:	108003cc 	andi	r2,r2,15
811358ec:	1806913a 	slli	r3,r3,4
811358f0:	1884b03a 	or	r2,r3,r2
811358f4:	28800015 	stw	r2,0(r5)
811358f8:	003fbc06 	br	811357ec <__reset+0xfb1157ec>
811358fc:	2b7fff04 	addi	r13,r5,-4
81135900:	283fff15 	stw	zero,-4(r5)
81135904:	603f883a 	mov	ra,r12
81135908:	680b883a 	mov	r5,r13
8113590c:	000f883a 	mov	r7,zero
81135910:	003fb606 	br	811357ec <__reset+0xfb1157ec>
81135914:	00800a44 	movi	r2,41
81135918:	18801726 	beq	r3,r2,81135978 <__hexnan+0x208>
8113591c:	00800104 	movi	r2,4
81135920:	dfc00617 	ldw	ra,24(sp)
81135924:	dd400517 	ldw	r21,20(sp)
81135928:	dd000417 	ldw	r20,16(sp)
8113592c:	dcc00317 	ldw	r19,12(sp)
81135930:	dc800217 	ldw	r18,8(sp)
81135934:	dc400117 	ldw	r17,4(sp)
81135938:	dc000017 	ldw	r16,0(sp)
8113593c:	dec00704 	addi	sp,sp,28
81135940:	f800283a 	ret
81135944:	903fd826 	beq	r18,zero,811358a8 <__reset+0xfb1158a8>
81135948:	00c00804 	movi	r3,32
8113594c:	1ca5c83a 	sub	r18,r3,r18
81135950:	00ffffc4 	movi	r3,-1
81135954:	78bfff17 	ldw	r2,-4(r15)
81135958:	1c86d83a 	srl	r3,r3,r18
8113595c:	1884703a 	and	r2,r3,r2
81135960:	78bfff15 	stw	r2,-4(r15)
81135964:	003fd106 	br	811358ac <__reset+0xfb1158ac>
81135968:	00800044 	movi	r2,1
8113596c:	58800015 	stw	r2,0(r11)
81135970:	00800144 	movi	r2,5
81135974:	003fea06 	br	81135920 <__reset+0xfb115920>
81135978:	42000044 	addi	r8,r8,1
8113597c:	22000015 	stw	r8,0(r4)
81135980:	603fbb1e 	bne	r12,zero,81135870 <__reset+0xfb115870>
81135984:	003fe506 	br	8113591c <__reset+0xfb11591c>
81135988:	02400204 	movi	r9,8
8113598c:	49d3c83a 	sub	r9,r9,r7
81135990:	4a53883a 	add	r9,r9,r9
81135994:	2a000017 	ldw	r8,0(r5)
81135998:	4a53883a 	add	r9,r9,r9
8113599c:	02800804 	movi	r10,32
811359a0:	5255c83a 	sub	r10,r10,r9
811359a4:	28c00104 	addi	r3,r5,4
811359a8:	2805883a 	mov	r2,r5
811359ac:	19c00017 	ldw	r7,0(r3)
811359b0:	10800104 	addi	r2,r2,4
811359b4:	18c00104 	addi	r3,r3,4
811359b8:	3a88983a 	sll	r4,r7,r10
811359bc:	2208b03a 	or	r4,r4,r8
811359c0:	3a50d83a 	srl	r8,r7,r9
811359c4:	113fff15 	stw	r4,-4(r2)
811359c8:	1a3fff15 	stw	r8,-4(r3)
811359cc:	137ff736 	bltu	r2,r13,811359ac <__reset+0xfb1159ac>
811359d0:	003faa06 	br	8113587c <__reset+0xfb11587c>

811359d4 <strncmp>:
811359d4:	30003126 	beq	r6,zero,81135a9c <strncmp+0xc8>
811359d8:	2144b03a 	or	r2,r4,r5
811359dc:	108000cc 	andi	r2,r2,3
811359e0:	10001e1e 	bne	r2,zero,81135a5c <strncmp+0x88>
811359e4:	024000c4 	movi	r9,3
811359e8:	49801c2e 	bgeu	r9,r6,81135a5c <strncmp+0x88>
811359ec:	20800017 	ldw	r2,0(r4)
811359f0:	28c00017 	ldw	r3,0(r5)
811359f4:	10c0191e 	bne	r2,r3,81135a5c <strncmp+0x88>
811359f8:	31bfff04 	addi	r6,r6,-4
811359fc:	30002726 	beq	r6,zero,81135a9c <strncmp+0xc8>
81135a00:	02ffbff4 	movhi	r11,65279
81135a04:	5affbfc4 	addi	r11,r11,-257
81135a08:	0086303a 	nor	r3,zero,r2
81135a0c:	02a02074 	movhi	r10,32897
81135a10:	12c5883a 	add	r2,r2,r11
81135a14:	52a02004 	addi	r10,r10,-32640
81135a18:	10c4703a 	and	r2,r2,r3
81135a1c:	1284703a 	and	r2,r2,r10
81135a20:	10000b26 	beq	r2,zero,81135a50 <strncmp+0x7c>
81135a24:	00001d06 	br	81135a9c <strncmp+0xc8>
81135a28:	20c00017 	ldw	r3,0(r4)
81135a2c:	29c00017 	ldw	r7,0(r5)
81135a30:	1ad1883a 	add	r8,r3,r11
81135a34:	00c4303a 	nor	r2,zero,r3
81135a38:	4084703a 	and	r2,r8,r2
81135a3c:	1284703a 	and	r2,r2,r10
81135a40:	19c0061e 	bne	r3,r7,81135a5c <strncmp+0x88>
81135a44:	31bfff04 	addi	r6,r6,-4
81135a48:	30001426 	beq	r6,zero,81135a9c <strncmp+0xc8>
81135a4c:	1000131e 	bne	r2,zero,81135a9c <strncmp+0xc8>
81135a50:	21000104 	addi	r4,r4,4
81135a54:	29400104 	addi	r5,r5,4
81135a58:	49bff336 	bltu	r9,r6,81135a28 <__reset+0xfb115a28>
81135a5c:	28800007 	ldb	r2,0(r5)
81135a60:	20c00007 	ldb	r3,0(r4)
81135a64:	31bfffc4 	addi	r6,r6,-1
81135a68:	10c0081e 	bne	r2,r3,81135a8c <strncmp+0xb8>
81135a6c:	30000b26 	beq	r6,zero,81135a9c <strncmp+0xc8>
81135a70:	10000a26 	beq	r2,zero,81135a9c <strncmp+0xc8>
81135a74:	21000044 	addi	r4,r4,1
81135a78:	29400044 	addi	r5,r5,1
81135a7c:	20800007 	ldb	r2,0(r4)
81135a80:	28c00007 	ldb	r3,0(r5)
81135a84:	31bfffc4 	addi	r6,r6,-1
81135a88:	10fff826 	beq	r2,r3,81135a6c <__reset+0xfb115a6c>
81135a8c:	20800003 	ldbu	r2,0(r4)
81135a90:	28c00003 	ldbu	r3,0(r5)
81135a94:	10c5c83a 	sub	r2,r2,r3
81135a98:	f800283a 	ret
81135a9c:	0005883a 	mov	r2,zero
81135aa0:	f800283a 	ret

81135aa4 <_wcrtomb_r>:
81135aa4:	defff604 	addi	sp,sp,-40
81135aa8:	00a04574 	movhi	r2,33045
81135aac:	de00012e 	bgeu	sp,et,81135ab4 <_wcrtomb_r+0x10>
81135ab0:	003b68fa 	trap	3
81135ab4:	10936504 	addi	r2,r2,19860
81135ab8:	dc800815 	stw	r18,32(sp)
81135abc:	dc400715 	stw	r17,28(sp)
81135ac0:	dc000615 	stw	r16,24(sp)
81135ac4:	dfc00915 	stw	ra,36(sp)
81135ac8:	2021883a 	mov	r16,r4
81135acc:	3823883a 	mov	r17,r7
81135ad0:	14800017 	ldw	r18,0(r2)
81135ad4:	28001426 	beq	r5,zero,81135b28 <_wcrtomb_r+0x84>
81135ad8:	d9400415 	stw	r5,16(sp)
81135adc:	d9800515 	stw	r6,20(sp)
81135ae0:	112e2bc0 	call	8112e2bc <__locale_charset>
81135ae4:	d9800517 	ldw	r6,20(sp)
81135ae8:	d9400417 	ldw	r5,16(sp)
81135aec:	100f883a 	mov	r7,r2
81135af0:	dc400015 	stw	r17,0(sp)
81135af4:	8009883a 	mov	r4,r16
81135af8:	903ee83a 	callr	r18
81135afc:	00ffffc4 	movi	r3,-1
81135b00:	10c0031e 	bne	r2,r3,81135b10 <_wcrtomb_r+0x6c>
81135b04:	88000015 	stw	zero,0(r17)
81135b08:	00c02284 	movi	r3,138
81135b0c:	80c00015 	stw	r3,0(r16)
81135b10:	dfc00917 	ldw	ra,36(sp)
81135b14:	dc800817 	ldw	r18,32(sp)
81135b18:	dc400717 	ldw	r17,28(sp)
81135b1c:	dc000617 	ldw	r16,24(sp)
81135b20:	dec00a04 	addi	sp,sp,40
81135b24:	f800283a 	ret
81135b28:	112e2bc0 	call	8112e2bc <__locale_charset>
81135b2c:	100f883a 	mov	r7,r2
81135b30:	dc400015 	stw	r17,0(sp)
81135b34:	000d883a 	mov	r6,zero
81135b38:	d9400104 	addi	r5,sp,4
81135b3c:	8009883a 	mov	r4,r16
81135b40:	903ee83a 	callr	r18
81135b44:	003fed06 	br	81135afc <__reset+0xfb115afc>

81135b48 <wcrtomb>:
81135b48:	defff604 	addi	sp,sp,-40
81135b4c:	00a04574 	movhi	r2,33045
81135b50:	de00012e 	bgeu	sp,et,81135b58 <wcrtomb+0x10>
81135b54:	003b68fa 	trap	3
81135b58:	10936004 	addi	r2,r2,19840
81135b5c:	dc800615 	stw	r18,24(sp)
81135b60:	dc400515 	stw	r17,20(sp)
81135b64:	dfc00915 	stw	ra,36(sp)
81135b68:	dd000815 	stw	r20,32(sp)
81135b6c:	dcc00715 	stw	r19,28(sp)
81135b70:	dc000415 	stw	r16,16(sp)
81135b74:	3025883a 	mov	r18,r6
81135b78:	14400017 	ldw	r17,0(r2)
81135b7c:	20001926 	beq	r4,zero,81135be4 <wcrtomb+0x9c>
81135b80:	00a04574 	movhi	r2,33045
81135b84:	10936504 	addi	r2,r2,19860
81135b88:	15000017 	ldw	r20,0(r2)
81135b8c:	2021883a 	mov	r16,r4
81135b90:	2827883a 	mov	r19,r5
81135b94:	112e2bc0 	call	8112e2bc <__locale_charset>
81135b98:	100f883a 	mov	r7,r2
81135b9c:	dc800015 	stw	r18,0(sp)
81135ba0:	980d883a 	mov	r6,r19
81135ba4:	800b883a 	mov	r5,r16
81135ba8:	8809883a 	mov	r4,r17
81135bac:	a03ee83a 	callr	r20
81135bb0:	00ffffc4 	movi	r3,-1
81135bb4:	10c0031e 	bne	r2,r3,81135bc4 <wcrtomb+0x7c>
81135bb8:	90000015 	stw	zero,0(r18)
81135bbc:	00c02284 	movi	r3,138
81135bc0:	88c00015 	stw	r3,0(r17)
81135bc4:	dfc00917 	ldw	ra,36(sp)
81135bc8:	dd000817 	ldw	r20,32(sp)
81135bcc:	dcc00717 	ldw	r19,28(sp)
81135bd0:	dc800617 	ldw	r18,24(sp)
81135bd4:	dc400517 	ldw	r17,20(sp)
81135bd8:	dc000417 	ldw	r16,16(sp)
81135bdc:	dec00a04 	addi	sp,sp,40
81135be0:	f800283a 	ret
81135be4:	00a04574 	movhi	r2,33045
81135be8:	10936504 	addi	r2,r2,19860
81135bec:	14000017 	ldw	r16,0(r2)
81135bf0:	112e2bc0 	call	8112e2bc <__locale_charset>
81135bf4:	100f883a 	mov	r7,r2
81135bf8:	dc800015 	stw	r18,0(sp)
81135bfc:	000d883a 	mov	r6,zero
81135c00:	d9400104 	addi	r5,sp,4
81135c04:	8809883a 	mov	r4,r17
81135c08:	803ee83a 	callr	r16
81135c0c:	003fe806 	br	81135bb0 <__reset+0xfb115bb0>

81135c10 <__ascii_wctomb>:
81135c10:	28000526 	beq	r5,zero,81135c28 <__ascii_wctomb+0x18>
81135c14:	00803fc4 	movi	r2,255
81135c18:	11800536 	bltu	r2,r6,81135c30 <__ascii_wctomb+0x20>
81135c1c:	29800005 	stb	r6,0(r5)
81135c20:	00800044 	movi	r2,1
81135c24:	f800283a 	ret
81135c28:	0005883a 	mov	r2,zero
81135c2c:	f800283a 	ret
81135c30:	00802284 	movi	r2,138
81135c34:	20800015 	stw	r2,0(r4)
81135c38:	00bfffc4 	movi	r2,-1
81135c3c:	f800283a 	ret

81135c40 <_wctomb_r>:
81135c40:	00a04574 	movhi	r2,33045
81135c44:	defff904 	addi	sp,sp,-28
81135c48:	10936504 	addi	r2,r2,19860
81135c4c:	de00012e 	bgeu	sp,et,81135c54 <_wctomb_r+0x14>
81135c50:	003b68fa 	trap	3
81135c54:	dfc00615 	stw	ra,24(sp)
81135c58:	dc400515 	stw	r17,20(sp)
81135c5c:	dc000415 	stw	r16,16(sp)
81135c60:	3823883a 	mov	r17,r7
81135c64:	14000017 	ldw	r16,0(r2)
81135c68:	d9000115 	stw	r4,4(sp)
81135c6c:	d9400215 	stw	r5,8(sp)
81135c70:	d9800315 	stw	r6,12(sp)
81135c74:	112e2bc0 	call	8112e2bc <__locale_charset>
81135c78:	d9800317 	ldw	r6,12(sp)
81135c7c:	d9400217 	ldw	r5,8(sp)
81135c80:	d9000117 	ldw	r4,4(sp)
81135c84:	100f883a 	mov	r7,r2
81135c88:	dc400015 	stw	r17,0(sp)
81135c8c:	803ee83a 	callr	r16
81135c90:	dfc00617 	ldw	ra,24(sp)
81135c94:	dc400517 	ldw	r17,20(sp)
81135c98:	dc000417 	ldw	r16,16(sp)
81135c9c:	dec00704 	addi	sp,sp,28
81135ca0:	f800283a 	ret

81135ca4 <__udivdi3>:
81135ca4:	defff504 	addi	sp,sp,-44
81135ca8:	de00012e 	bgeu	sp,et,81135cb0 <__udivdi3+0xc>
81135cac:	003b68fa 	trap	3
81135cb0:	dcc00415 	stw	r19,16(sp)
81135cb4:	dc000115 	stw	r16,4(sp)
81135cb8:	dfc00a15 	stw	ra,40(sp)
81135cbc:	df000915 	stw	fp,36(sp)
81135cc0:	ddc00815 	stw	r23,32(sp)
81135cc4:	dd800715 	stw	r22,28(sp)
81135cc8:	dd400615 	stw	r21,24(sp)
81135ccc:	dd000515 	stw	r20,20(sp)
81135cd0:	dc800315 	stw	r18,12(sp)
81135cd4:	dc400215 	stw	r17,8(sp)
81135cd8:	2027883a 	mov	r19,r4
81135cdc:	2821883a 	mov	r16,r5
81135ce0:	3800411e 	bne	r7,zero,81135de8 <__udivdi3+0x144>
81135ce4:	3023883a 	mov	r17,r6
81135ce8:	2025883a 	mov	r18,r4
81135cec:	2980522e 	bgeu	r5,r6,81135e38 <__udivdi3+0x194>
81135cf0:	00bfffd4 	movui	r2,65535
81135cf4:	282d883a 	mov	r22,r5
81135cf8:	1180a836 	bltu	r2,r6,81135f9c <__udivdi3+0x2f8>
81135cfc:	00803fc4 	movi	r2,255
81135d00:	1185803a 	cmpltu	r2,r2,r6
81135d04:	100490fa 	slli	r2,r2,3
81135d08:	3086d83a 	srl	r3,r6,r2
81135d0c:	01204574 	movhi	r4,33045
81135d10:	2108a504 	addi	r4,r4,8852
81135d14:	20c7883a 	add	r3,r4,r3
81135d18:	18c00003 	ldbu	r3,0(r3)
81135d1c:	1885883a 	add	r2,r3,r2
81135d20:	00c00804 	movi	r3,32
81135d24:	1887c83a 	sub	r3,r3,r2
81135d28:	18000526 	beq	r3,zero,81135d40 <__udivdi3+0x9c>
81135d2c:	80e0983a 	sll	r16,r16,r3
81135d30:	9884d83a 	srl	r2,r19,r2
81135d34:	30e2983a 	sll	r17,r6,r3
81135d38:	98e4983a 	sll	r18,r19,r3
81135d3c:	142cb03a 	or	r22,r2,r16
81135d40:	882ad43a 	srli	r21,r17,16
81135d44:	b009883a 	mov	r4,r22
81135d48:	8d3fffcc 	andi	r20,r17,65535
81135d4c:	a80b883a 	mov	r5,r21
81135d50:	11368c00 	call	811368c0 <__umodsi3>
81135d54:	b009883a 	mov	r4,r22
81135d58:	a80b883a 	mov	r5,r21
81135d5c:	1027883a 	mov	r19,r2
81135d60:	113685c0 	call	8113685c <__udivsi3>
81135d64:	102d883a 	mov	r22,r2
81135d68:	9826943a 	slli	r19,r19,16
81135d6c:	9004d43a 	srli	r2,r18,16
81135d70:	a5a1383a 	mul	r16,r20,r22
81135d74:	14c4b03a 	or	r2,r2,r19
81135d78:	1400052e 	bgeu	r2,r16,81135d90 <__udivdi3+0xec>
81135d7c:	1445883a 	add	r2,r2,r17
81135d80:	b0ffffc4 	addi	r3,r22,-1
81135d84:	14400136 	bltu	r2,r17,81135d8c <__udivdi3+0xe8>
81135d88:	14012336 	bltu	r2,r16,81136218 <__udivdi3+0x574>
81135d8c:	182d883a 	mov	r22,r3
81135d90:	1421c83a 	sub	r16,r2,r16
81135d94:	a80b883a 	mov	r5,r21
81135d98:	8009883a 	mov	r4,r16
81135d9c:	11368c00 	call	811368c0 <__umodsi3>
81135da0:	1027883a 	mov	r19,r2
81135da4:	a80b883a 	mov	r5,r21
81135da8:	8009883a 	mov	r4,r16
81135dac:	113685c0 	call	8113685c <__udivsi3>
81135db0:	9826943a 	slli	r19,r19,16
81135db4:	a0a9383a 	mul	r20,r20,r2
81135db8:	94bfffcc 	andi	r18,r18,65535
81135dbc:	94e4b03a 	or	r18,r18,r19
81135dc0:	9500052e 	bgeu	r18,r20,81135dd8 <__udivdi3+0x134>
81135dc4:	8ca5883a 	add	r18,r17,r18
81135dc8:	10ffffc4 	addi	r3,r2,-1
81135dcc:	9440f136 	bltu	r18,r17,81136194 <__udivdi3+0x4f0>
81135dd0:	9500f02e 	bgeu	r18,r20,81136194 <__udivdi3+0x4f0>
81135dd4:	10bfff84 	addi	r2,r2,-2
81135dd8:	b00c943a 	slli	r6,r22,16
81135ddc:	0007883a 	mov	r3,zero
81135de0:	3084b03a 	or	r2,r6,r2
81135de4:	00005906 	br	81135f4c <__udivdi3+0x2a8>
81135de8:	29c05636 	bltu	r5,r7,81135f44 <__udivdi3+0x2a0>
81135dec:	00bfffd4 	movui	r2,65535
81135df0:	11c0622e 	bgeu	r2,r7,81135f7c <__udivdi3+0x2d8>
81135df4:	00804034 	movhi	r2,256
81135df8:	10bfffc4 	addi	r2,r2,-1
81135dfc:	11c0ee36 	bltu	r2,r7,811361b8 <__udivdi3+0x514>
81135e00:	00800404 	movi	r2,16
81135e04:	3886d83a 	srl	r3,r7,r2
81135e08:	01204574 	movhi	r4,33045
81135e0c:	2108a504 	addi	r4,r4,8852
81135e10:	20c7883a 	add	r3,r4,r3
81135e14:	18c00003 	ldbu	r3,0(r3)
81135e18:	05400804 	movi	r21,32
81135e1c:	1885883a 	add	r2,r3,r2
81135e20:	a8abc83a 	sub	r21,r21,r2
81135e24:	a800621e 	bne	r21,zero,81135fb0 <__udivdi3+0x30c>
81135e28:	3c00e936 	bltu	r7,r16,811361d0 <__udivdi3+0x52c>
81135e2c:	9985403a 	cmpgeu	r2,r19,r6
81135e30:	0007883a 	mov	r3,zero
81135e34:	00004506 	br	81135f4c <__udivdi3+0x2a8>
81135e38:	3000041e 	bne	r6,zero,81135e4c <__udivdi3+0x1a8>
81135e3c:	000b883a 	mov	r5,zero
81135e40:	01000044 	movi	r4,1
81135e44:	113685c0 	call	8113685c <__udivsi3>
81135e48:	1023883a 	mov	r17,r2
81135e4c:	00bfffd4 	movui	r2,65535
81135e50:	14404e2e 	bgeu	r2,r17,81135f8c <__udivdi3+0x2e8>
81135e54:	00804034 	movhi	r2,256
81135e58:	10bfffc4 	addi	r2,r2,-1
81135e5c:	1440d836 	bltu	r2,r17,811361c0 <__udivdi3+0x51c>
81135e60:	00800404 	movi	r2,16
81135e64:	8886d83a 	srl	r3,r17,r2
81135e68:	01204574 	movhi	r4,33045
81135e6c:	2108a504 	addi	r4,r4,8852
81135e70:	20c7883a 	add	r3,r4,r3
81135e74:	18c00003 	ldbu	r3,0(r3)
81135e78:	1885883a 	add	r2,r3,r2
81135e7c:	00c00804 	movi	r3,32
81135e80:	1887c83a 	sub	r3,r3,r2
81135e84:	18008f1e 	bne	r3,zero,811360c4 <__udivdi3+0x420>
81135e88:	882ad43a 	srli	r21,r17,16
81135e8c:	8461c83a 	sub	r16,r16,r17
81135e90:	8d3fffcc 	andi	r20,r17,65535
81135e94:	00c00044 	movi	r3,1
81135e98:	8009883a 	mov	r4,r16
81135e9c:	a80b883a 	mov	r5,r21
81135ea0:	d8c00015 	stw	r3,0(sp)
81135ea4:	11368c00 	call	811368c0 <__umodsi3>
81135ea8:	8009883a 	mov	r4,r16
81135eac:	a80b883a 	mov	r5,r21
81135eb0:	1027883a 	mov	r19,r2
81135eb4:	113685c0 	call	8113685c <__udivsi3>
81135eb8:	9826943a 	slli	r19,r19,16
81135ebc:	9008d43a 	srli	r4,r18,16
81135ec0:	1521383a 	mul	r16,r2,r20
81135ec4:	102d883a 	mov	r22,r2
81135ec8:	24c8b03a 	or	r4,r4,r19
81135ecc:	d8c00017 	ldw	r3,0(sp)
81135ed0:	2400052e 	bgeu	r4,r16,81135ee8 <__udivdi3+0x244>
81135ed4:	2449883a 	add	r4,r4,r17
81135ed8:	b0bfffc4 	addi	r2,r22,-1
81135edc:	24400136 	bltu	r4,r17,81135ee4 <__udivdi3+0x240>
81135ee0:	2400ca36 	bltu	r4,r16,8113620c <__udivdi3+0x568>
81135ee4:	102d883a 	mov	r22,r2
81135ee8:	2421c83a 	sub	r16,r4,r16
81135eec:	a80b883a 	mov	r5,r21
81135ef0:	8009883a 	mov	r4,r16
81135ef4:	d8c00015 	stw	r3,0(sp)
81135ef8:	11368c00 	call	811368c0 <__umodsi3>
81135efc:	1027883a 	mov	r19,r2
81135f00:	a80b883a 	mov	r5,r21
81135f04:	8009883a 	mov	r4,r16
81135f08:	113685c0 	call	8113685c <__udivsi3>
81135f0c:	9826943a 	slli	r19,r19,16
81135f10:	1529383a 	mul	r20,r2,r20
81135f14:	94bfffcc 	andi	r18,r18,65535
81135f18:	94e4b03a 	or	r18,r18,r19
81135f1c:	d8c00017 	ldw	r3,0(sp)
81135f20:	9500052e 	bgeu	r18,r20,81135f38 <__udivdi3+0x294>
81135f24:	8ca5883a 	add	r18,r17,r18
81135f28:	113fffc4 	addi	r4,r2,-1
81135f2c:	94409736 	bltu	r18,r17,8113618c <__udivdi3+0x4e8>
81135f30:	9500962e 	bgeu	r18,r20,8113618c <__udivdi3+0x4e8>
81135f34:	10bfff84 	addi	r2,r2,-2
81135f38:	b00c943a 	slli	r6,r22,16
81135f3c:	3084b03a 	or	r2,r6,r2
81135f40:	00000206 	br	81135f4c <__udivdi3+0x2a8>
81135f44:	0007883a 	mov	r3,zero
81135f48:	0005883a 	mov	r2,zero
81135f4c:	dfc00a17 	ldw	ra,40(sp)
81135f50:	df000917 	ldw	fp,36(sp)
81135f54:	ddc00817 	ldw	r23,32(sp)
81135f58:	dd800717 	ldw	r22,28(sp)
81135f5c:	dd400617 	ldw	r21,24(sp)
81135f60:	dd000517 	ldw	r20,20(sp)
81135f64:	dcc00417 	ldw	r19,16(sp)
81135f68:	dc800317 	ldw	r18,12(sp)
81135f6c:	dc400217 	ldw	r17,8(sp)
81135f70:	dc000117 	ldw	r16,4(sp)
81135f74:	dec00b04 	addi	sp,sp,44
81135f78:	f800283a 	ret
81135f7c:	00803fc4 	movi	r2,255
81135f80:	11c5803a 	cmpltu	r2,r2,r7
81135f84:	100490fa 	slli	r2,r2,3
81135f88:	003f9e06 	br	81135e04 <__reset+0xfb115e04>
81135f8c:	00803fc4 	movi	r2,255
81135f90:	1445803a 	cmpltu	r2,r2,r17
81135f94:	100490fa 	slli	r2,r2,3
81135f98:	003fb206 	br	81135e64 <__reset+0xfb115e64>
81135f9c:	00804034 	movhi	r2,256
81135fa0:	10bfffc4 	addi	r2,r2,-1
81135fa4:	11808836 	bltu	r2,r6,811361c8 <__udivdi3+0x524>
81135fa8:	00800404 	movi	r2,16
81135fac:	003f5606 	br	81135d08 <__reset+0xfb115d08>
81135fb0:	30aed83a 	srl	r23,r6,r2
81135fb4:	3d4e983a 	sll	r7,r7,r21
81135fb8:	80acd83a 	srl	r22,r16,r2
81135fbc:	9884d83a 	srl	r2,r19,r2
81135fc0:	3deeb03a 	or	r23,r7,r23
81135fc4:	b824d43a 	srli	r18,r23,16
81135fc8:	8560983a 	sll	r16,r16,r21
81135fcc:	b009883a 	mov	r4,r22
81135fd0:	900b883a 	mov	r5,r18
81135fd4:	3568983a 	sll	r20,r6,r21
81135fd8:	1420b03a 	or	r16,r2,r16
81135fdc:	11368c00 	call	811368c0 <__umodsi3>
81135fe0:	b009883a 	mov	r4,r22
81135fe4:	900b883a 	mov	r5,r18
81135fe8:	1023883a 	mov	r17,r2
81135fec:	113685c0 	call	8113685c <__udivsi3>
81135ff0:	8808943a 	slli	r4,r17,16
81135ff4:	bf3fffcc 	andi	fp,r23,65535
81135ff8:	8006d43a 	srli	r3,r16,16
81135ffc:	e0a3383a 	mul	r17,fp,r2
81136000:	100d883a 	mov	r6,r2
81136004:	1906b03a 	or	r3,r3,r4
81136008:	1c40042e 	bgeu	r3,r17,8113601c <__udivdi3+0x378>
8113600c:	1dc7883a 	add	r3,r3,r23
81136010:	10bfffc4 	addi	r2,r2,-1
81136014:	1dc0752e 	bgeu	r3,r23,811361ec <__udivdi3+0x548>
81136018:	100d883a 	mov	r6,r2
8113601c:	1c63c83a 	sub	r17,r3,r17
81136020:	900b883a 	mov	r5,r18
81136024:	8809883a 	mov	r4,r17
81136028:	d9800015 	stw	r6,0(sp)
8113602c:	11368c00 	call	811368c0 <__umodsi3>
81136030:	102d883a 	mov	r22,r2
81136034:	8809883a 	mov	r4,r17
81136038:	900b883a 	mov	r5,r18
8113603c:	113685c0 	call	8113685c <__udivsi3>
81136040:	b02c943a 	slli	r22,r22,16
81136044:	e089383a 	mul	r4,fp,r2
81136048:	843fffcc 	andi	r16,r16,65535
8113604c:	85a0b03a 	or	r16,r16,r22
81136050:	d9800017 	ldw	r6,0(sp)
81136054:	8100042e 	bgeu	r16,r4,81136068 <__udivdi3+0x3c4>
81136058:	85e1883a 	add	r16,r16,r23
8113605c:	10ffffc4 	addi	r3,r2,-1
81136060:	85c05e2e 	bgeu	r16,r23,811361dc <__udivdi3+0x538>
81136064:	1805883a 	mov	r2,r3
81136068:	300c943a 	slli	r6,r6,16
8113606c:	a17fffcc 	andi	r5,r20,65535
81136070:	a028d43a 	srli	r20,r20,16
81136074:	3084b03a 	or	r2,r6,r2
81136078:	10ffffcc 	andi	r3,r2,65535
8113607c:	100cd43a 	srli	r6,r2,16
81136080:	194f383a 	mul	r7,r3,r5
81136084:	1d07383a 	mul	r3,r3,r20
81136088:	314b383a 	mul	r5,r6,r5
8113608c:	3810d43a 	srli	r8,r7,16
81136090:	8121c83a 	sub	r16,r16,r4
81136094:	1947883a 	add	r3,r3,r5
81136098:	40c7883a 	add	r3,r8,r3
8113609c:	350d383a 	mul	r6,r6,r20
811360a0:	1940022e 	bgeu	r3,r5,811360ac <__udivdi3+0x408>
811360a4:	01000074 	movhi	r4,1
811360a8:	310d883a 	add	r6,r6,r4
811360ac:	1828d43a 	srli	r20,r3,16
811360b0:	a18d883a 	add	r6,r20,r6
811360b4:	81803e36 	bltu	r16,r6,811361b0 <__udivdi3+0x50c>
811360b8:	81803826 	beq	r16,r6,8113619c <__udivdi3+0x4f8>
811360bc:	0007883a 	mov	r3,zero
811360c0:	003fa206 	br	81135f4c <__reset+0xfb115f4c>
811360c4:	88e2983a 	sll	r17,r17,r3
811360c8:	80a8d83a 	srl	r20,r16,r2
811360cc:	80e0983a 	sll	r16,r16,r3
811360d0:	882ad43a 	srli	r21,r17,16
811360d4:	9884d83a 	srl	r2,r19,r2
811360d8:	a009883a 	mov	r4,r20
811360dc:	a80b883a 	mov	r5,r21
811360e0:	142eb03a 	or	r23,r2,r16
811360e4:	98e4983a 	sll	r18,r19,r3
811360e8:	11368c00 	call	811368c0 <__umodsi3>
811360ec:	a009883a 	mov	r4,r20
811360f0:	a80b883a 	mov	r5,r21
811360f4:	1021883a 	mov	r16,r2
811360f8:	113685c0 	call	8113685c <__udivsi3>
811360fc:	1039883a 	mov	fp,r2
81136100:	8d3fffcc 	andi	r20,r17,65535
81136104:	8020943a 	slli	r16,r16,16
81136108:	b804d43a 	srli	r2,r23,16
8113610c:	a72d383a 	mul	r22,r20,fp
81136110:	1404b03a 	or	r2,r2,r16
81136114:	1580062e 	bgeu	r2,r22,81136130 <__udivdi3+0x48c>
81136118:	1445883a 	add	r2,r2,r17
8113611c:	e0ffffc4 	addi	r3,fp,-1
81136120:	14403836 	bltu	r2,r17,81136204 <__udivdi3+0x560>
81136124:	1580372e 	bgeu	r2,r22,81136204 <__udivdi3+0x560>
81136128:	e73fff84 	addi	fp,fp,-2
8113612c:	1445883a 	add	r2,r2,r17
81136130:	15adc83a 	sub	r22,r2,r22
81136134:	a80b883a 	mov	r5,r21
81136138:	b009883a 	mov	r4,r22
8113613c:	11368c00 	call	811368c0 <__umodsi3>
81136140:	1027883a 	mov	r19,r2
81136144:	b009883a 	mov	r4,r22
81136148:	a80b883a 	mov	r5,r21
8113614c:	113685c0 	call	8113685c <__udivsi3>
81136150:	9826943a 	slli	r19,r19,16
81136154:	a0a1383a 	mul	r16,r20,r2
81136158:	b93fffcc 	andi	r4,r23,65535
8113615c:	24c8b03a 	or	r4,r4,r19
81136160:	2400062e 	bgeu	r4,r16,8113617c <__udivdi3+0x4d8>
81136164:	2449883a 	add	r4,r4,r17
81136168:	10ffffc4 	addi	r3,r2,-1
8113616c:	24402336 	bltu	r4,r17,811361fc <__udivdi3+0x558>
81136170:	2400222e 	bgeu	r4,r16,811361fc <__udivdi3+0x558>
81136174:	10bfff84 	addi	r2,r2,-2
81136178:	2449883a 	add	r4,r4,r17
8113617c:	e038943a 	slli	fp,fp,16
81136180:	2421c83a 	sub	r16,r4,r16
81136184:	e086b03a 	or	r3,fp,r2
81136188:	003f4306 	br	81135e98 <__reset+0xfb115e98>
8113618c:	2005883a 	mov	r2,r4
81136190:	003f6906 	br	81135f38 <__reset+0xfb115f38>
81136194:	1805883a 	mov	r2,r3
81136198:	003f0f06 	br	81135dd8 <__reset+0xfb115dd8>
8113619c:	1806943a 	slli	r3,r3,16
811361a0:	9d66983a 	sll	r19,r19,r21
811361a4:	39ffffcc 	andi	r7,r7,65535
811361a8:	19c7883a 	add	r3,r3,r7
811361ac:	98ffc32e 	bgeu	r19,r3,811360bc <__reset+0xfb1160bc>
811361b0:	10bfffc4 	addi	r2,r2,-1
811361b4:	003fc106 	br	811360bc <__reset+0xfb1160bc>
811361b8:	00800604 	movi	r2,24
811361bc:	003f1106 	br	81135e04 <__reset+0xfb115e04>
811361c0:	00800604 	movi	r2,24
811361c4:	003f2706 	br	81135e64 <__reset+0xfb115e64>
811361c8:	00800604 	movi	r2,24
811361cc:	003ece06 	br	81135d08 <__reset+0xfb115d08>
811361d0:	0007883a 	mov	r3,zero
811361d4:	00800044 	movi	r2,1
811361d8:	003f5c06 	br	81135f4c <__reset+0xfb115f4c>
811361dc:	813fa12e 	bgeu	r16,r4,81136064 <__reset+0xfb116064>
811361e0:	10bfff84 	addi	r2,r2,-2
811361e4:	85e1883a 	add	r16,r16,r23
811361e8:	003f9f06 	br	81136068 <__reset+0xfb116068>
811361ec:	1c7f8a2e 	bgeu	r3,r17,81136018 <__reset+0xfb116018>
811361f0:	31bfff84 	addi	r6,r6,-2
811361f4:	1dc7883a 	add	r3,r3,r23
811361f8:	003f8806 	br	8113601c <__reset+0xfb11601c>
811361fc:	1805883a 	mov	r2,r3
81136200:	003fde06 	br	8113617c <__reset+0xfb11617c>
81136204:	1839883a 	mov	fp,r3
81136208:	003fc906 	br	81136130 <__reset+0xfb116130>
8113620c:	b5bfff84 	addi	r22,r22,-2
81136210:	2449883a 	add	r4,r4,r17
81136214:	003f3406 	br	81135ee8 <__reset+0xfb115ee8>
81136218:	b5bfff84 	addi	r22,r22,-2
8113621c:	1445883a 	add	r2,r2,r17
81136220:	003edb06 	br	81135d90 <__reset+0xfb115d90>

81136224 <__umoddi3>:
81136224:	defff404 	addi	sp,sp,-48
81136228:	de00012e 	bgeu	sp,et,81136230 <__umoddi3+0xc>
8113622c:	003b68fa 	trap	3
81136230:	df000a15 	stw	fp,40(sp)
81136234:	dc400315 	stw	r17,12(sp)
81136238:	dc000215 	stw	r16,8(sp)
8113623c:	dfc00b15 	stw	ra,44(sp)
81136240:	ddc00915 	stw	r23,36(sp)
81136244:	dd800815 	stw	r22,32(sp)
81136248:	dd400715 	stw	r21,28(sp)
8113624c:	dd000615 	stw	r20,24(sp)
81136250:	dcc00515 	stw	r19,20(sp)
81136254:	dc800415 	stw	r18,16(sp)
81136258:	2021883a 	mov	r16,r4
8113625c:	2823883a 	mov	r17,r5
81136260:	2839883a 	mov	fp,r5
81136264:	38003c1e 	bne	r7,zero,81136358 <__umoddi3+0x134>
81136268:	3027883a 	mov	r19,r6
8113626c:	2029883a 	mov	r20,r4
81136270:	2980512e 	bgeu	r5,r6,811363b8 <__umoddi3+0x194>
81136274:	00bfffd4 	movui	r2,65535
81136278:	11809a36 	bltu	r2,r6,811364e4 <__umoddi3+0x2c0>
8113627c:	01003fc4 	movi	r4,255
81136280:	2189803a 	cmpltu	r4,r4,r6
81136284:	200890fa 	slli	r4,r4,3
81136288:	3104d83a 	srl	r2,r6,r4
8113628c:	00e04574 	movhi	r3,33045
81136290:	18c8a504 	addi	r3,r3,8852
81136294:	1885883a 	add	r2,r3,r2
81136298:	10c00003 	ldbu	r3,0(r2)
8113629c:	00800804 	movi	r2,32
811362a0:	1909883a 	add	r4,r3,r4
811362a4:	1125c83a 	sub	r18,r2,r4
811362a8:	90000526 	beq	r18,zero,811362c0 <__umoddi3+0x9c>
811362ac:	8ca2983a 	sll	r17,r17,r18
811362b0:	8108d83a 	srl	r4,r16,r4
811362b4:	34a6983a 	sll	r19,r6,r18
811362b8:	84a8983a 	sll	r20,r16,r18
811362bc:	2478b03a 	or	fp,r4,r17
811362c0:	982ed43a 	srli	r23,r19,16
811362c4:	e009883a 	mov	r4,fp
811362c8:	9dbfffcc 	andi	r22,r19,65535
811362cc:	b80b883a 	mov	r5,r23
811362d0:	11368c00 	call	811368c0 <__umodsi3>
811362d4:	e009883a 	mov	r4,fp
811362d8:	b80b883a 	mov	r5,r23
811362dc:	102b883a 	mov	r21,r2
811362e0:	113685c0 	call	8113685c <__udivsi3>
811362e4:	a806943a 	slli	r3,r21,16
811362e8:	a008d43a 	srli	r4,r20,16
811362ec:	b085383a 	mul	r2,r22,r2
811362f0:	20c8b03a 	or	r4,r4,r3
811362f4:	2080032e 	bgeu	r4,r2,81136304 <__umoddi3+0xe0>
811362f8:	24c9883a 	add	r4,r4,r19
811362fc:	24c00136 	bltu	r4,r19,81136304 <__umoddi3+0xe0>
81136300:	20811036 	bltu	r4,r2,81136744 <__umoddi3+0x520>
81136304:	20abc83a 	sub	r21,r4,r2
81136308:	b80b883a 	mov	r5,r23
8113630c:	a809883a 	mov	r4,r21
81136310:	11368c00 	call	811368c0 <__umodsi3>
81136314:	1023883a 	mov	r17,r2
81136318:	b80b883a 	mov	r5,r23
8113631c:	a809883a 	mov	r4,r21
81136320:	113685c0 	call	8113685c <__udivsi3>
81136324:	8822943a 	slli	r17,r17,16
81136328:	b085383a 	mul	r2,r22,r2
8113632c:	a0ffffcc 	andi	r3,r20,65535
81136330:	1c46b03a 	or	r3,r3,r17
81136334:	1880042e 	bgeu	r3,r2,81136348 <__umoddi3+0x124>
81136338:	1cc7883a 	add	r3,r3,r19
8113633c:	1cc00236 	bltu	r3,r19,81136348 <__umoddi3+0x124>
81136340:	1880012e 	bgeu	r3,r2,81136348 <__umoddi3+0x124>
81136344:	1cc7883a 	add	r3,r3,r19
81136348:	1885c83a 	sub	r2,r3,r2
8113634c:	1484d83a 	srl	r2,r2,r18
81136350:	0007883a 	mov	r3,zero
81136354:	00004f06 	br	81136494 <__umoddi3+0x270>
81136358:	29c04c36 	bltu	r5,r7,8113648c <__umoddi3+0x268>
8113635c:	00bfffd4 	movui	r2,65535
81136360:	11c0582e 	bgeu	r2,r7,811364c4 <__umoddi3+0x2a0>
81136364:	00804034 	movhi	r2,256
81136368:	10bfffc4 	addi	r2,r2,-1
8113636c:	11c0e736 	bltu	r2,r7,8113670c <__umoddi3+0x4e8>
81136370:	01000404 	movi	r4,16
81136374:	3904d83a 	srl	r2,r7,r4
81136378:	00e04574 	movhi	r3,33045
8113637c:	18c8a504 	addi	r3,r3,8852
81136380:	1885883a 	add	r2,r3,r2
81136384:	14c00003 	ldbu	r19,0(r2)
81136388:	00c00804 	movi	r3,32
8113638c:	9927883a 	add	r19,r19,r4
81136390:	1ce9c83a 	sub	r20,r3,r19
81136394:	a000581e 	bne	r20,zero,811364f8 <__umoddi3+0x2d4>
81136398:	3c400136 	bltu	r7,r17,811363a0 <__umoddi3+0x17c>
8113639c:	8180eb36 	bltu	r16,r6,8113674c <__umoddi3+0x528>
811363a0:	8185c83a 	sub	r2,r16,r6
811363a4:	89e3c83a 	sub	r17,r17,r7
811363a8:	8089803a 	cmpltu	r4,r16,r2
811363ac:	8939c83a 	sub	fp,r17,r4
811363b0:	e007883a 	mov	r3,fp
811363b4:	00003706 	br	81136494 <__umoddi3+0x270>
811363b8:	3000041e 	bne	r6,zero,811363cc <__umoddi3+0x1a8>
811363bc:	000b883a 	mov	r5,zero
811363c0:	01000044 	movi	r4,1
811363c4:	113685c0 	call	8113685c <__udivsi3>
811363c8:	1027883a 	mov	r19,r2
811363cc:	00bfffd4 	movui	r2,65535
811363d0:	14c0402e 	bgeu	r2,r19,811364d4 <__umoddi3+0x2b0>
811363d4:	00804034 	movhi	r2,256
811363d8:	10bfffc4 	addi	r2,r2,-1
811363dc:	14c0cd36 	bltu	r2,r19,81136714 <__umoddi3+0x4f0>
811363e0:	00800404 	movi	r2,16
811363e4:	9886d83a 	srl	r3,r19,r2
811363e8:	01204574 	movhi	r4,33045
811363ec:	2108a504 	addi	r4,r4,8852
811363f0:	20c7883a 	add	r3,r4,r3
811363f4:	18c00003 	ldbu	r3,0(r3)
811363f8:	1887883a 	add	r3,r3,r2
811363fc:	00800804 	movi	r2,32
81136400:	10e5c83a 	sub	r18,r2,r3
81136404:	9000901e 	bne	r18,zero,81136648 <__umoddi3+0x424>
81136408:	982cd43a 	srli	r22,r19,16
8113640c:	8ce3c83a 	sub	r17,r17,r19
81136410:	9d7fffcc 	andi	r21,r19,65535
81136414:	b00b883a 	mov	r5,r22
81136418:	8809883a 	mov	r4,r17
8113641c:	11368c00 	call	811368c0 <__umodsi3>
81136420:	8809883a 	mov	r4,r17
81136424:	b00b883a 	mov	r5,r22
81136428:	1021883a 	mov	r16,r2
8113642c:	113685c0 	call	8113685c <__udivsi3>
81136430:	8006943a 	slli	r3,r16,16
81136434:	a008d43a 	srli	r4,r20,16
81136438:	1545383a 	mul	r2,r2,r21
8113643c:	20c8b03a 	or	r4,r4,r3
81136440:	2080042e 	bgeu	r4,r2,81136454 <__umoddi3+0x230>
81136444:	24c9883a 	add	r4,r4,r19
81136448:	24c00236 	bltu	r4,r19,81136454 <__umoddi3+0x230>
8113644c:	2080012e 	bgeu	r4,r2,81136454 <__umoddi3+0x230>
81136450:	24c9883a 	add	r4,r4,r19
81136454:	20a1c83a 	sub	r16,r4,r2
81136458:	b00b883a 	mov	r5,r22
8113645c:	8009883a 	mov	r4,r16
81136460:	11368c00 	call	811368c0 <__umodsi3>
81136464:	1023883a 	mov	r17,r2
81136468:	b00b883a 	mov	r5,r22
8113646c:	8009883a 	mov	r4,r16
81136470:	113685c0 	call	8113685c <__udivsi3>
81136474:	8822943a 	slli	r17,r17,16
81136478:	1545383a 	mul	r2,r2,r21
8113647c:	a53fffcc 	andi	r20,r20,65535
81136480:	a446b03a 	or	r3,r20,r17
81136484:	18bfb02e 	bgeu	r3,r2,81136348 <__reset+0xfb116348>
81136488:	003fab06 	br	81136338 <__reset+0xfb116338>
8113648c:	2005883a 	mov	r2,r4
81136490:	2807883a 	mov	r3,r5
81136494:	dfc00b17 	ldw	ra,44(sp)
81136498:	df000a17 	ldw	fp,40(sp)
8113649c:	ddc00917 	ldw	r23,36(sp)
811364a0:	dd800817 	ldw	r22,32(sp)
811364a4:	dd400717 	ldw	r21,28(sp)
811364a8:	dd000617 	ldw	r20,24(sp)
811364ac:	dcc00517 	ldw	r19,20(sp)
811364b0:	dc800417 	ldw	r18,16(sp)
811364b4:	dc400317 	ldw	r17,12(sp)
811364b8:	dc000217 	ldw	r16,8(sp)
811364bc:	dec00c04 	addi	sp,sp,48
811364c0:	f800283a 	ret
811364c4:	04c03fc4 	movi	r19,255
811364c8:	99c9803a 	cmpltu	r4,r19,r7
811364cc:	200890fa 	slli	r4,r4,3
811364d0:	003fa806 	br	81136374 <__reset+0xfb116374>
811364d4:	00803fc4 	movi	r2,255
811364d8:	14c5803a 	cmpltu	r2,r2,r19
811364dc:	100490fa 	slli	r2,r2,3
811364e0:	003fc006 	br	811363e4 <__reset+0xfb1163e4>
811364e4:	00804034 	movhi	r2,256
811364e8:	10bfffc4 	addi	r2,r2,-1
811364ec:	11808b36 	bltu	r2,r6,8113671c <__umoddi3+0x4f8>
811364f0:	01000404 	movi	r4,16
811364f4:	003f6406 	br	81136288 <__reset+0xfb116288>
811364f8:	34c4d83a 	srl	r2,r6,r19
811364fc:	3d0e983a 	sll	r7,r7,r20
81136500:	8cf8d83a 	srl	fp,r17,r19
81136504:	8d10983a 	sll	r8,r17,r20
81136508:	38aab03a 	or	r21,r7,r2
8113650c:	a82cd43a 	srli	r22,r21,16
81136510:	84e2d83a 	srl	r17,r16,r19
81136514:	e009883a 	mov	r4,fp
81136518:	b00b883a 	mov	r5,r22
8113651c:	8a22b03a 	or	r17,r17,r8
81136520:	3524983a 	sll	r18,r6,r20
81136524:	11368c00 	call	811368c0 <__umodsi3>
81136528:	e009883a 	mov	r4,fp
8113652c:	b00b883a 	mov	r5,r22
81136530:	102f883a 	mov	r23,r2
81136534:	113685c0 	call	8113685c <__udivsi3>
81136538:	100d883a 	mov	r6,r2
8113653c:	b808943a 	slli	r4,r23,16
81136540:	aa3fffcc 	andi	r8,r21,65535
81136544:	8804d43a 	srli	r2,r17,16
81136548:	41af383a 	mul	r23,r8,r6
8113654c:	8520983a 	sll	r16,r16,r20
81136550:	1104b03a 	or	r2,r2,r4
81136554:	15c0042e 	bgeu	r2,r23,81136568 <__umoddi3+0x344>
81136558:	1545883a 	add	r2,r2,r21
8113655c:	30ffffc4 	addi	r3,r6,-1
81136560:	1540742e 	bgeu	r2,r21,81136734 <__umoddi3+0x510>
81136564:	180d883a 	mov	r6,r3
81136568:	15efc83a 	sub	r23,r2,r23
8113656c:	b00b883a 	mov	r5,r22
81136570:	b809883a 	mov	r4,r23
81136574:	d9800115 	stw	r6,4(sp)
81136578:	da000015 	stw	r8,0(sp)
8113657c:	11368c00 	call	811368c0 <__umodsi3>
81136580:	b00b883a 	mov	r5,r22
81136584:	b809883a 	mov	r4,r23
81136588:	1039883a 	mov	fp,r2
8113658c:	113685c0 	call	8113685c <__udivsi3>
81136590:	da000017 	ldw	r8,0(sp)
81136594:	e038943a 	slli	fp,fp,16
81136598:	100b883a 	mov	r5,r2
8113659c:	4089383a 	mul	r4,r8,r2
811365a0:	8a3fffcc 	andi	r8,r17,65535
811365a4:	4710b03a 	or	r8,r8,fp
811365a8:	d9800117 	ldw	r6,4(sp)
811365ac:	4100042e 	bgeu	r8,r4,811365c0 <__umoddi3+0x39c>
811365b0:	4551883a 	add	r8,r8,r21
811365b4:	10bfffc4 	addi	r2,r2,-1
811365b8:	45405a2e 	bgeu	r8,r21,81136724 <__umoddi3+0x500>
811365bc:	100b883a 	mov	r5,r2
811365c0:	300c943a 	slli	r6,r6,16
811365c4:	91ffffcc 	andi	r7,r18,65535
811365c8:	9004d43a 	srli	r2,r18,16
811365cc:	314cb03a 	or	r6,r6,r5
811365d0:	317fffcc 	andi	r5,r6,65535
811365d4:	300cd43a 	srli	r6,r6,16
811365d8:	29d3383a 	mul	r9,r5,r7
811365dc:	288b383a 	mul	r5,r5,r2
811365e0:	31cf383a 	mul	r7,r6,r7
811365e4:	4806d43a 	srli	r3,r9,16
811365e8:	4111c83a 	sub	r8,r8,r4
811365ec:	29cb883a 	add	r5,r5,r7
811365f0:	194b883a 	add	r5,r3,r5
811365f4:	3085383a 	mul	r2,r6,r2
811365f8:	29c0022e 	bgeu	r5,r7,81136604 <__umoddi3+0x3e0>
811365fc:	00c00074 	movhi	r3,1
81136600:	10c5883a 	add	r2,r2,r3
81136604:	2808d43a 	srli	r4,r5,16
81136608:	280a943a 	slli	r5,r5,16
8113660c:	4a7fffcc 	andi	r9,r9,65535
81136610:	2085883a 	add	r2,r4,r2
81136614:	2a4b883a 	add	r5,r5,r9
81136618:	40803636 	bltu	r8,r2,811366f4 <__umoddi3+0x4d0>
8113661c:	40804d26 	beq	r8,r2,81136754 <__umoddi3+0x530>
81136620:	4089c83a 	sub	r4,r8,r2
81136624:	280f883a 	mov	r7,r5
81136628:	81cfc83a 	sub	r7,r16,r7
8113662c:	81c7803a 	cmpltu	r3,r16,r7
81136630:	20c7c83a 	sub	r3,r4,r3
81136634:	1cc4983a 	sll	r2,r3,r19
81136638:	3d0ed83a 	srl	r7,r7,r20
8113663c:	1d06d83a 	srl	r3,r3,r20
81136640:	11c4b03a 	or	r2,r2,r7
81136644:	003f9306 	br	81136494 <__reset+0xfb116494>
81136648:	9ca6983a 	sll	r19,r19,r18
8113664c:	88e8d83a 	srl	r20,r17,r3
81136650:	80c4d83a 	srl	r2,r16,r3
81136654:	982cd43a 	srli	r22,r19,16
81136658:	8ca2983a 	sll	r17,r17,r18
8113665c:	a009883a 	mov	r4,r20
81136660:	b00b883a 	mov	r5,r22
81136664:	1478b03a 	or	fp,r2,r17
81136668:	11368c00 	call	811368c0 <__umodsi3>
8113666c:	a009883a 	mov	r4,r20
81136670:	b00b883a 	mov	r5,r22
81136674:	1023883a 	mov	r17,r2
81136678:	113685c0 	call	8113685c <__udivsi3>
8113667c:	9d7fffcc 	andi	r21,r19,65535
81136680:	880a943a 	slli	r5,r17,16
81136684:	e008d43a 	srli	r4,fp,16
81136688:	a885383a 	mul	r2,r21,r2
8113668c:	84a8983a 	sll	r20,r16,r18
81136690:	2148b03a 	or	r4,r4,r5
81136694:	2080042e 	bgeu	r4,r2,811366a8 <__umoddi3+0x484>
81136698:	24c9883a 	add	r4,r4,r19
8113669c:	24c00236 	bltu	r4,r19,811366a8 <__umoddi3+0x484>
811366a0:	2080012e 	bgeu	r4,r2,811366a8 <__umoddi3+0x484>
811366a4:	24c9883a 	add	r4,r4,r19
811366a8:	20a3c83a 	sub	r17,r4,r2
811366ac:	b00b883a 	mov	r5,r22
811366b0:	8809883a 	mov	r4,r17
811366b4:	11368c00 	call	811368c0 <__umodsi3>
811366b8:	102f883a 	mov	r23,r2
811366bc:	8809883a 	mov	r4,r17
811366c0:	b00b883a 	mov	r5,r22
811366c4:	113685c0 	call	8113685c <__udivsi3>
811366c8:	b82e943a 	slli	r23,r23,16
811366cc:	a885383a 	mul	r2,r21,r2
811366d0:	e13fffcc 	andi	r4,fp,65535
811366d4:	25c8b03a 	or	r4,r4,r23
811366d8:	2080042e 	bgeu	r4,r2,811366ec <__umoddi3+0x4c8>
811366dc:	24c9883a 	add	r4,r4,r19
811366e0:	24c00236 	bltu	r4,r19,811366ec <__umoddi3+0x4c8>
811366e4:	2080012e 	bgeu	r4,r2,811366ec <__umoddi3+0x4c8>
811366e8:	24c9883a 	add	r4,r4,r19
811366ec:	20a3c83a 	sub	r17,r4,r2
811366f0:	003f4806 	br	81136414 <__reset+0xfb116414>
811366f4:	2c8fc83a 	sub	r7,r5,r18
811366f8:	1545c83a 	sub	r2,r2,r21
811366fc:	29cb803a 	cmpltu	r5,r5,r7
81136700:	1145c83a 	sub	r2,r2,r5
81136704:	4089c83a 	sub	r4,r8,r2
81136708:	003fc706 	br	81136628 <__reset+0xfb116628>
8113670c:	01000604 	movi	r4,24
81136710:	003f1806 	br	81136374 <__reset+0xfb116374>
81136714:	00800604 	movi	r2,24
81136718:	003f3206 	br	811363e4 <__reset+0xfb1163e4>
8113671c:	01000604 	movi	r4,24
81136720:	003ed906 	br	81136288 <__reset+0xfb116288>
81136724:	413fa52e 	bgeu	r8,r4,811365bc <__reset+0xfb1165bc>
81136728:	297fff84 	addi	r5,r5,-2
8113672c:	4551883a 	add	r8,r8,r21
81136730:	003fa306 	br	811365c0 <__reset+0xfb1165c0>
81136734:	15ff8b2e 	bgeu	r2,r23,81136564 <__reset+0xfb116564>
81136738:	31bfff84 	addi	r6,r6,-2
8113673c:	1545883a 	add	r2,r2,r21
81136740:	003f8906 	br	81136568 <__reset+0xfb116568>
81136744:	24c9883a 	add	r4,r4,r19
81136748:	003eee06 	br	81136304 <__reset+0xfb116304>
8113674c:	8005883a 	mov	r2,r16
81136750:	003f1706 	br	811363b0 <__reset+0xfb1163b0>
81136754:	817fe736 	bltu	r16,r5,811366f4 <__reset+0xfb1166f4>
81136758:	280f883a 	mov	r7,r5
8113675c:	0009883a 	mov	r4,zero
81136760:	003fb106 	br	81136628 <__reset+0xfb116628>

81136764 <__divsi3>:
81136764:	20001b16 	blt	r4,zero,811367d4 <__divsi3+0x70>
81136768:	000f883a 	mov	r7,zero
8113676c:	28001616 	blt	r5,zero,811367c8 <__divsi3+0x64>
81136770:	200d883a 	mov	r6,r4
81136774:	29001a2e 	bgeu	r5,r4,811367e0 <__divsi3+0x7c>
81136778:	00800804 	movi	r2,32
8113677c:	00c00044 	movi	r3,1
81136780:	00000106 	br	81136788 <__divsi3+0x24>
81136784:	10000d26 	beq	r2,zero,811367bc <__divsi3+0x58>
81136788:	294b883a 	add	r5,r5,r5
8113678c:	10bfffc4 	addi	r2,r2,-1
81136790:	18c7883a 	add	r3,r3,r3
81136794:	293ffb36 	bltu	r5,r4,81136784 <__reset+0xfb116784>
81136798:	0005883a 	mov	r2,zero
8113679c:	18000726 	beq	r3,zero,811367bc <__divsi3+0x58>
811367a0:	0005883a 	mov	r2,zero
811367a4:	31400236 	bltu	r6,r5,811367b0 <__divsi3+0x4c>
811367a8:	314dc83a 	sub	r6,r6,r5
811367ac:	10c4b03a 	or	r2,r2,r3
811367b0:	1806d07a 	srli	r3,r3,1
811367b4:	280ad07a 	srli	r5,r5,1
811367b8:	183ffa1e 	bne	r3,zero,811367a4 <__reset+0xfb1167a4>
811367bc:	38000126 	beq	r7,zero,811367c4 <__divsi3+0x60>
811367c0:	0085c83a 	sub	r2,zero,r2
811367c4:	f800283a 	ret
811367c8:	014bc83a 	sub	r5,zero,r5
811367cc:	39c0005c 	xori	r7,r7,1
811367d0:	003fe706 	br	81136770 <__reset+0xfb116770>
811367d4:	0109c83a 	sub	r4,zero,r4
811367d8:	01c00044 	movi	r7,1
811367dc:	003fe306 	br	8113676c <__reset+0xfb11676c>
811367e0:	00c00044 	movi	r3,1
811367e4:	003fee06 	br	811367a0 <__reset+0xfb1167a0>

811367e8 <__modsi3>:
811367e8:	20001716 	blt	r4,zero,81136848 <__modsi3+0x60>
811367ec:	000f883a 	mov	r7,zero
811367f0:	2005883a 	mov	r2,r4
811367f4:	28001216 	blt	r5,zero,81136840 <__modsi3+0x58>
811367f8:	2900162e 	bgeu	r5,r4,81136854 <__modsi3+0x6c>
811367fc:	01800804 	movi	r6,32
81136800:	00c00044 	movi	r3,1
81136804:	00000106 	br	8113680c <__modsi3+0x24>
81136808:	30000a26 	beq	r6,zero,81136834 <__modsi3+0x4c>
8113680c:	294b883a 	add	r5,r5,r5
81136810:	31bfffc4 	addi	r6,r6,-1
81136814:	18c7883a 	add	r3,r3,r3
81136818:	293ffb36 	bltu	r5,r4,81136808 <__reset+0xfb116808>
8113681c:	18000526 	beq	r3,zero,81136834 <__modsi3+0x4c>
81136820:	1806d07a 	srli	r3,r3,1
81136824:	11400136 	bltu	r2,r5,8113682c <__modsi3+0x44>
81136828:	1145c83a 	sub	r2,r2,r5
8113682c:	280ad07a 	srli	r5,r5,1
81136830:	183ffb1e 	bne	r3,zero,81136820 <__reset+0xfb116820>
81136834:	38000126 	beq	r7,zero,8113683c <__modsi3+0x54>
81136838:	0085c83a 	sub	r2,zero,r2
8113683c:	f800283a 	ret
81136840:	014bc83a 	sub	r5,zero,r5
81136844:	003fec06 	br	811367f8 <__reset+0xfb1167f8>
81136848:	0109c83a 	sub	r4,zero,r4
8113684c:	01c00044 	movi	r7,1
81136850:	003fe706 	br	811367f0 <__reset+0xfb1167f0>
81136854:	00c00044 	movi	r3,1
81136858:	003ff106 	br	81136820 <__reset+0xfb116820>

8113685c <__udivsi3>:
8113685c:	200d883a 	mov	r6,r4
81136860:	2900152e 	bgeu	r5,r4,811368b8 <__udivsi3+0x5c>
81136864:	28001416 	blt	r5,zero,811368b8 <__udivsi3+0x5c>
81136868:	00800804 	movi	r2,32
8113686c:	00c00044 	movi	r3,1
81136870:	00000206 	br	8113687c <__udivsi3+0x20>
81136874:	10000e26 	beq	r2,zero,811368b0 <__udivsi3+0x54>
81136878:	28000516 	blt	r5,zero,81136890 <__udivsi3+0x34>
8113687c:	294b883a 	add	r5,r5,r5
81136880:	10bfffc4 	addi	r2,r2,-1
81136884:	18c7883a 	add	r3,r3,r3
81136888:	293ffa36 	bltu	r5,r4,81136874 <__reset+0xfb116874>
8113688c:	18000826 	beq	r3,zero,811368b0 <__udivsi3+0x54>
81136890:	0005883a 	mov	r2,zero
81136894:	31400236 	bltu	r6,r5,811368a0 <__udivsi3+0x44>
81136898:	314dc83a 	sub	r6,r6,r5
8113689c:	10c4b03a 	or	r2,r2,r3
811368a0:	1806d07a 	srli	r3,r3,1
811368a4:	280ad07a 	srli	r5,r5,1
811368a8:	183ffa1e 	bne	r3,zero,81136894 <__reset+0xfb116894>
811368ac:	f800283a 	ret
811368b0:	0005883a 	mov	r2,zero
811368b4:	f800283a 	ret
811368b8:	00c00044 	movi	r3,1
811368bc:	003ff406 	br	81136890 <__reset+0xfb116890>

811368c0 <__umodsi3>:
811368c0:	2005883a 	mov	r2,r4
811368c4:	2900122e 	bgeu	r5,r4,81136910 <__umodsi3+0x50>
811368c8:	28001116 	blt	r5,zero,81136910 <__umodsi3+0x50>
811368cc:	01800804 	movi	r6,32
811368d0:	00c00044 	movi	r3,1
811368d4:	00000206 	br	811368e0 <__umodsi3+0x20>
811368d8:	30000c26 	beq	r6,zero,8113690c <__umodsi3+0x4c>
811368dc:	28000516 	blt	r5,zero,811368f4 <__umodsi3+0x34>
811368e0:	294b883a 	add	r5,r5,r5
811368e4:	31bfffc4 	addi	r6,r6,-1
811368e8:	18c7883a 	add	r3,r3,r3
811368ec:	293ffa36 	bltu	r5,r4,811368d8 <__reset+0xfb1168d8>
811368f0:	18000626 	beq	r3,zero,8113690c <__umodsi3+0x4c>
811368f4:	1806d07a 	srli	r3,r3,1
811368f8:	11400136 	bltu	r2,r5,81136900 <__umodsi3+0x40>
811368fc:	1145c83a 	sub	r2,r2,r5
81136900:	280ad07a 	srli	r5,r5,1
81136904:	183ffb1e 	bne	r3,zero,811368f4 <__reset+0xfb1168f4>
81136908:	f800283a 	ret
8113690c:	f800283a 	ret
81136910:	00c00044 	movi	r3,1
81136914:	003ff706 	br	811368f4 <__reset+0xfb1168f4>

81136918 <__eqsf2>:
81136918:	2006d5fa 	srli	r3,r4,23
8113691c:	280cd5fa 	srli	r6,r5,23
81136920:	01c02034 	movhi	r7,128
81136924:	39ffffc4 	addi	r7,r7,-1
81136928:	18c03fcc 	andi	r3,r3,255
8113692c:	02003fc4 	movi	r8,255
81136930:	3904703a 	and	r2,r7,r4
81136934:	31803fcc 	andi	r6,r6,255
81136938:	394e703a 	and	r7,r7,r5
8113693c:	2008d7fa 	srli	r4,r4,31
81136940:	280ad7fa 	srli	r5,r5,31
81136944:	1a000d26 	beq	r3,r8,8113697c <__eqsf2+0x64>
81136948:	02003fc4 	movi	r8,255
8113694c:	32000826 	beq	r6,r8,81136970 <__eqsf2+0x58>
81136950:	19800226 	beq	r3,r6,8113695c <__eqsf2+0x44>
81136954:	00800044 	movi	r2,1
81136958:	f800283a 	ret
8113695c:	11fffd1e 	bne	r2,r7,81136954 <__reset+0xfb116954>
81136960:	21400926 	beq	r4,r5,81136988 <__eqsf2+0x70>
81136964:	183ffb1e 	bne	r3,zero,81136954 <__reset+0xfb116954>
81136968:	1004c03a 	cmpne	r2,r2,zero
8113696c:	f800283a 	ret
81136970:	383ff726 	beq	r7,zero,81136950 <__reset+0xfb116950>
81136974:	00800044 	movi	r2,1
81136978:	f800283a 	ret
8113697c:	103ff226 	beq	r2,zero,81136948 <__reset+0xfb116948>
81136980:	00800044 	movi	r2,1
81136984:	f800283a 	ret
81136988:	0005883a 	mov	r2,zero
8113698c:	f800283a 	ret

81136990 <__gesf2>:
81136990:	2004d5fa 	srli	r2,r4,23
81136994:	2806d5fa 	srli	r3,r5,23
81136998:	01802034 	movhi	r6,128
8113699c:	31bfffc4 	addi	r6,r6,-1
811369a0:	10803fcc 	andi	r2,r2,255
811369a4:	01c03fc4 	movi	r7,255
811369a8:	3110703a 	and	r8,r6,r4
811369ac:	18c03fcc 	andi	r3,r3,255
811369b0:	314c703a 	and	r6,r6,r5
811369b4:	2008d7fa 	srli	r4,r4,31
811369b8:	280ad7fa 	srli	r5,r5,31
811369bc:	11c01926 	beq	r2,r7,81136a24 <__gesf2+0x94>
811369c0:	01c03fc4 	movi	r7,255
811369c4:	19c00f26 	beq	r3,r7,81136a04 <__gesf2+0x74>
811369c8:	1000061e 	bne	r2,zero,811369e4 <__gesf2+0x54>
811369cc:	400f003a 	cmpeq	r7,r8,zero
811369d0:	1800071e 	bne	r3,zero,811369f0 <__gesf2+0x60>
811369d4:	3000061e 	bne	r6,zero,811369f0 <__gesf2+0x60>
811369d8:	0005883a 	mov	r2,zero
811369dc:	40000e1e 	bne	r8,zero,81136a18 <__gesf2+0x88>
811369e0:	f800283a 	ret
811369e4:	18000a1e 	bne	r3,zero,81136a10 <__gesf2+0x80>
811369e8:	30000b26 	beq	r6,zero,81136a18 <__gesf2+0x88>
811369ec:	000f883a 	mov	r7,zero
811369f0:	29403fcc 	andi	r5,r5,255
811369f4:	38000726 	beq	r7,zero,81136a14 <__gesf2+0x84>
811369f8:	28000826 	beq	r5,zero,81136a1c <__gesf2+0x8c>
811369fc:	00800044 	movi	r2,1
81136a00:	f800283a 	ret
81136a04:	303ff026 	beq	r6,zero,811369c8 <__reset+0xfb1169c8>
81136a08:	00bfff84 	movi	r2,-2
81136a0c:	f800283a 	ret
81136a10:	29403fcc 	andi	r5,r5,255
81136a14:	21400526 	beq	r4,r5,81136a2c <__gesf2+0x9c>
81136a18:	203ff826 	beq	r4,zero,811369fc <__reset+0xfb1169fc>
81136a1c:	00bfffc4 	movi	r2,-1
81136a20:	f800283a 	ret
81136a24:	403fe626 	beq	r8,zero,811369c0 <__reset+0xfb1169c0>
81136a28:	003ff706 	br	81136a08 <__reset+0xfb116a08>
81136a2c:	18bffa16 	blt	r3,r2,81136a18 <__reset+0xfb116a18>
81136a30:	10c00216 	blt	r2,r3,81136a3c <__gesf2+0xac>
81136a34:	323ff836 	bltu	r6,r8,81136a18 <__reset+0xfb116a18>
81136a38:	4180022e 	bgeu	r8,r6,81136a44 <__gesf2+0xb4>
81136a3c:	203fef1e 	bne	r4,zero,811369fc <__reset+0xfb1169fc>
81136a40:	003ff606 	br	81136a1c <__reset+0xfb116a1c>
81136a44:	0005883a 	mov	r2,zero
81136a48:	f800283a 	ret

81136a4c <__lesf2>:
81136a4c:	2004d5fa 	srli	r2,r4,23
81136a50:	280cd5fa 	srli	r6,r5,23
81136a54:	00c02034 	movhi	r3,128
81136a58:	18ffffc4 	addi	r3,r3,-1
81136a5c:	10803fcc 	andi	r2,r2,255
81136a60:	01c03fc4 	movi	r7,255
81136a64:	1910703a 	and	r8,r3,r4
81136a68:	31803fcc 	andi	r6,r6,255
81136a6c:	1946703a 	and	r3,r3,r5
81136a70:	2008d7fa 	srli	r4,r4,31
81136a74:	280ad7fa 	srli	r5,r5,31
81136a78:	11c01b26 	beq	r2,r7,81136ae8 <__lesf2+0x9c>
81136a7c:	01c03fc4 	movi	r7,255
81136a80:	31c01126 	beq	r6,r7,81136ac8 <__lesf2+0x7c>
81136a84:	1000071e 	bne	r2,zero,81136aa4 <__lesf2+0x58>
81136a88:	400f003a 	cmpeq	r7,r8,zero
81136a8c:	21003fcc 	andi	r4,r4,255
81136a90:	3000081e 	bne	r6,zero,81136ab4 <__lesf2+0x68>
81136a94:	1800071e 	bne	r3,zero,81136ab4 <__lesf2+0x68>
81136a98:	0005883a 	mov	r2,zero
81136a9c:	40000f1e 	bne	r8,zero,81136adc <__lesf2+0x90>
81136aa0:	f800283a 	ret
81136aa4:	21003fcc 	andi	r4,r4,255
81136aa8:	30000a1e 	bne	r6,zero,81136ad4 <__lesf2+0x88>
81136aac:	18000b26 	beq	r3,zero,81136adc <__lesf2+0x90>
81136ab0:	000f883a 	mov	r7,zero
81136ab4:	29403fcc 	andi	r5,r5,255
81136ab8:	38000726 	beq	r7,zero,81136ad8 <__lesf2+0x8c>
81136abc:	28000826 	beq	r5,zero,81136ae0 <__lesf2+0x94>
81136ac0:	00800044 	movi	r2,1
81136ac4:	f800283a 	ret
81136ac8:	183fee26 	beq	r3,zero,81136a84 <__reset+0xfb116a84>
81136acc:	00800084 	movi	r2,2
81136ad0:	f800283a 	ret
81136ad4:	29403fcc 	andi	r5,r5,255
81136ad8:	21400626 	beq	r4,r5,81136af4 <__lesf2+0xa8>
81136adc:	203ff826 	beq	r4,zero,81136ac0 <__reset+0xfb116ac0>
81136ae0:	00bfffc4 	movi	r2,-1
81136ae4:	f800283a 	ret
81136ae8:	403fe426 	beq	r8,zero,81136a7c <__reset+0xfb116a7c>
81136aec:	00800084 	movi	r2,2
81136af0:	f800283a 	ret
81136af4:	30bff916 	blt	r6,r2,81136adc <__reset+0xfb116adc>
81136af8:	11800216 	blt	r2,r6,81136b04 <__lesf2+0xb8>
81136afc:	1a3ff736 	bltu	r3,r8,81136adc <__reset+0xfb116adc>
81136b00:	40c0022e 	bgeu	r8,r3,81136b0c <__lesf2+0xc0>
81136b04:	203fee1e 	bne	r4,zero,81136ac0 <__reset+0xfb116ac0>
81136b08:	003ff506 	br	81136ae0 <__reset+0xfb116ae0>
81136b0c:	0005883a 	mov	r2,zero
81136b10:	f800283a 	ret

81136b14 <__adddf3>:
81136b14:	02c00434 	movhi	r11,16
81136b18:	5affffc4 	addi	r11,r11,-1
81136b1c:	2806d7fa 	srli	r3,r5,31
81136b20:	2ad4703a 	and	r10,r5,r11
81136b24:	3ad2703a 	and	r9,r7,r11
81136b28:	3804d53a 	srli	r2,r7,20
81136b2c:	3018d77a 	srli	r12,r6,29
81136b30:	280ad53a 	srli	r5,r5,20
81136b34:	501490fa 	slli	r10,r10,3
81136b38:	2010d77a 	srli	r8,r4,29
81136b3c:	481290fa 	slli	r9,r9,3
81136b40:	380ed7fa 	srli	r7,r7,31
81136b44:	defffb04 	addi	sp,sp,-20
81136b48:	de00012e 	bgeu	sp,et,81136b50 <__adddf3+0x3c>
81136b4c:	003b68fa 	trap	3
81136b50:	dc800215 	stw	r18,8(sp)
81136b54:	dc400115 	stw	r17,4(sp)
81136b58:	dc000015 	stw	r16,0(sp)
81136b5c:	dfc00415 	stw	ra,16(sp)
81136b60:	dcc00315 	stw	r19,12(sp)
81136b64:	1c803fcc 	andi	r18,r3,255
81136b68:	2c01ffcc 	andi	r16,r5,2047
81136b6c:	5210b03a 	or	r8,r10,r8
81136b70:	202290fa 	slli	r17,r4,3
81136b74:	1081ffcc 	andi	r2,r2,2047
81136b78:	4b12b03a 	or	r9,r9,r12
81136b7c:	300c90fa 	slli	r6,r6,3
81136b80:	91c07526 	beq	r18,r7,81136d58 <__adddf3+0x244>
81136b84:	8087c83a 	sub	r3,r16,r2
81136b88:	00c0ab0e 	bge	zero,r3,81136e38 <__adddf3+0x324>
81136b8c:	10002a1e 	bne	r2,zero,81136c38 <__adddf3+0x124>
81136b90:	4984b03a 	or	r2,r9,r6
81136b94:	1000961e 	bne	r2,zero,81136df0 <__adddf3+0x2dc>
81136b98:	888001cc 	andi	r2,r17,7
81136b9c:	10000726 	beq	r2,zero,81136bbc <__adddf3+0xa8>
81136ba0:	888003cc 	andi	r2,r17,15
81136ba4:	00c00104 	movi	r3,4
81136ba8:	10c00426 	beq	r2,r3,81136bbc <__adddf3+0xa8>
81136bac:	88c7883a 	add	r3,r17,r3
81136bb0:	1c63803a 	cmpltu	r17,r3,r17
81136bb4:	4451883a 	add	r8,r8,r17
81136bb8:	1823883a 	mov	r17,r3
81136bbc:	4080202c 	andhi	r2,r8,128
81136bc0:	10005926 	beq	r2,zero,81136d28 <__adddf3+0x214>
81136bc4:	84000044 	addi	r16,r16,1
81136bc8:	0081ffc4 	movi	r2,2047
81136bcc:	8080ba26 	beq	r16,r2,81136eb8 <__adddf3+0x3a4>
81136bd0:	00bfe034 	movhi	r2,65408
81136bd4:	10bfffc4 	addi	r2,r2,-1
81136bd8:	4090703a 	and	r8,r8,r2
81136bdc:	4004977a 	slli	r2,r8,29
81136be0:	4010927a 	slli	r8,r8,9
81136be4:	8822d0fa 	srli	r17,r17,3
81136be8:	8401ffcc 	andi	r16,r16,2047
81136bec:	4010d33a 	srli	r8,r8,12
81136bf0:	9007883a 	mov	r3,r18
81136bf4:	1444b03a 	or	r2,r2,r17
81136bf8:	8401ffcc 	andi	r16,r16,2047
81136bfc:	8020953a 	slli	r16,r16,20
81136c00:	18c03fcc 	andi	r3,r3,255
81136c04:	01000434 	movhi	r4,16
81136c08:	213fffc4 	addi	r4,r4,-1
81136c0c:	180697fa 	slli	r3,r3,31
81136c10:	4110703a 	and	r8,r8,r4
81136c14:	4410b03a 	or	r8,r8,r16
81136c18:	40c6b03a 	or	r3,r8,r3
81136c1c:	dfc00417 	ldw	ra,16(sp)
81136c20:	dcc00317 	ldw	r19,12(sp)
81136c24:	dc800217 	ldw	r18,8(sp)
81136c28:	dc400117 	ldw	r17,4(sp)
81136c2c:	dc000017 	ldw	r16,0(sp)
81136c30:	dec00504 	addi	sp,sp,20
81136c34:	f800283a 	ret
81136c38:	0081ffc4 	movi	r2,2047
81136c3c:	80bfd626 	beq	r16,r2,81136b98 <__reset+0xfb116b98>
81136c40:	4a402034 	orhi	r9,r9,128
81136c44:	00800e04 	movi	r2,56
81136c48:	10c09f16 	blt	r2,r3,81136ec8 <__adddf3+0x3b4>
81136c4c:	008007c4 	movi	r2,31
81136c50:	10c0c216 	blt	r2,r3,81136f5c <__adddf3+0x448>
81136c54:	00800804 	movi	r2,32
81136c58:	10c5c83a 	sub	r2,r2,r3
81136c5c:	488a983a 	sll	r5,r9,r2
81136c60:	30c8d83a 	srl	r4,r6,r3
81136c64:	3084983a 	sll	r2,r6,r2
81136c68:	48c6d83a 	srl	r3,r9,r3
81136c6c:	290cb03a 	or	r6,r5,r4
81136c70:	1004c03a 	cmpne	r2,r2,zero
81136c74:	308cb03a 	or	r6,r6,r2
81136c78:	898dc83a 	sub	r6,r17,r6
81136c7c:	89a3803a 	cmpltu	r17,r17,r6
81136c80:	40d1c83a 	sub	r8,r8,r3
81136c84:	4451c83a 	sub	r8,r8,r17
81136c88:	3023883a 	mov	r17,r6
81136c8c:	4080202c 	andhi	r2,r8,128
81136c90:	10002326 	beq	r2,zero,81136d20 <__adddf3+0x20c>
81136c94:	04c02034 	movhi	r19,128
81136c98:	9cffffc4 	addi	r19,r19,-1
81136c9c:	44e6703a 	and	r19,r8,r19
81136ca0:	98007626 	beq	r19,zero,81136e7c <__adddf3+0x368>
81136ca4:	9809883a 	mov	r4,r19
81136ca8:	11230c80 	call	811230c8 <__clzsi2>
81136cac:	10fffe04 	addi	r3,r2,-8
81136cb0:	010007c4 	movi	r4,31
81136cb4:	20c07716 	blt	r4,r3,81136e94 <__adddf3+0x380>
81136cb8:	00800804 	movi	r2,32
81136cbc:	10c5c83a 	sub	r2,r2,r3
81136cc0:	8884d83a 	srl	r2,r17,r2
81136cc4:	98d0983a 	sll	r8,r19,r3
81136cc8:	88e2983a 	sll	r17,r17,r3
81136ccc:	1204b03a 	or	r2,r2,r8
81136cd0:	1c007416 	blt	r3,r16,81136ea4 <__adddf3+0x390>
81136cd4:	1c21c83a 	sub	r16,r3,r16
81136cd8:	82000044 	addi	r8,r16,1
81136cdc:	00c007c4 	movi	r3,31
81136ce0:	1a009116 	blt	r3,r8,81136f28 <__adddf3+0x414>
81136ce4:	00c00804 	movi	r3,32
81136ce8:	1a07c83a 	sub	r3,r3,r8
81136cec:	8a08d83a 	srl	r4,r17,r8
81136cf0:	88e2983a 	sll	r17,r17,r3
81136cf4:	10c6983a 	sll	r3,r2,r3
81136cf8:	1210d83a 	srl	r8,r2,r8
81136cfc:	8804c03a 	cmpne	r2,r17,zero
81136d00:	1906b03a 	or	r3,r3,r4
81136d04:	18a2b03a 	or	r17,r3,r2
81136d08:	0021883a 	mov	r16,zero
81136d0c:	003fa206 	br	81136b98 <__reset+0xfb116b98>
81136d10:	1890b03a 	or	r8,r3,r2
81136d14:	40017d26 	beq	r8,zero,8113730c <__adddf3+0x7f8>
81136d18:	1011883a 	mov	r8,r2
81136d1c:	1823883a 	mov	r17,r3
81136d20:	888001cc 	andi	r2,r17,7
81136d24:	103f9e1e 	bne	r2,zero,81136ba0 <__reset+0xfb116ba0>
81136d28:	4004977a 	slli	r2,r8,29
81136d2c:	8822d0fa 	srli	r17,r17,3
81136d30:	4010d0fa 	srli	r8,r8,3
81136d34:	9007883a 	mov	r3,r18
81136d38:	1444b03a 	or	r2,r2,r17
81136d3c:	0101ffc4 	movi	r4,2047
81136d40:	81002426 	beq	r16,r4,81136dd4 <__adddf3+0x2c0>
81136d44:	8120703a 	and	r16,r16,r4
81136d48:	01000434 	movhi	r4,16
81136d4c:	213fffc4 	addi	r4,r4,-1
81136d50:	4110703a 	and	r8,r8,r4
81136d54:	003fa806 	br	81136bf8 <__reset+0xfb116bf8>
81136d58:	8089c83a 	sub	r4,r16,r2
81136d5c:	01005e0e 	bge	zero,r4,81136ed8 <__adddf3+0x3c4>
81136d60:	10002b26 	beq	r2,zero,81136e10 <__adddf3+0x2fc>
81136d64:	0081ffc4 	movi	r2,2047
81136d68:	80bf8b26 	beq	r16,r2,81136b98 <__reset+0xfb116b98>
81136d6c:	4a402034 	orhi	r9,r9,128
81136d70:	00800e04 	movi	r2,56
81136d74:	1100a40e 	bge	r2,r4,81137008 <__adddf3+0x4f4>
81136d78:	498cb03a 	or	r6,r9,r6
81136d7c:	300ac03a 	cmpne	r5,r6,zero
81136d80:	0013883a 	mov	r9,zero
81136d84:	2c4b883a 	add	r5,r5,r17
81136d88:	2c63803a 	cmpltu	r17,r5,r17
81136d8c:	4a11883a 	add	r8,r9,r8
81136d90:	8a11883a 	add	r8,r17,r8
81136d94:	2823883a 	mov	r17,r5
81136d98:	4080202c 	andhi	r2,r8,128
81136d9c:	103fe026 	beq	r2,zero,81136d20 <__reset+0xfb116d20>
81136da0:	84000044 	addi	r16,r16,1
81136da4:	0081ffc4 	movi	r2,2047
81136da8:	8080d226 	beq	r16,r2,811370f4 <__adddf3+0x5e0>
81136dac:	00bfe034 	movhi	r2,65408
81136db0:	10bfffc4 	addi	r2,r2,-1
81136db4:	4090703a 	and	r8,r8,r2
81136db8:	880ad07a 	srli	r5,r17,1
81136dbc:	400897fa 	slli	r4,r8,31
81136dc0:	88c0004c 	andi	r3,r17,1
81136dc4:	28e2b03a 	or	r17,r5,r3
81136dc8:	4010d07a 	srli	r8,r8,1
81136dcc:	2462b03a 	or	r17,r4,r17
81136dd0:	003f7106 	br	81136b98 <__reset+0xfb116b98>
81136dd4:	4088b03a 	or	r4,r8,r2
81136dd8:	20014526 	beq	r4,zero,811372f0 <__adddf3+0x7dc>
81136ddc:	01000434 	movhi	r4,16
81136de0:	42000234 	orhi	r8,r8,8
81136de4:	213fffc4 	addi	r4,r4,-1
81136de8:	4110703a 	and	r8,r8,r4
81136dec:	003f8206 	br	81136bf8 <__reset+0xfb116bf8>
81136df0:	18ffffc4 	addi	r3,r3,-1
81136df4:	1800491e 	bne	r3,zero,81136f1c <__adddf3+0x408>
81136df8:	898bc83a 	sub	r5,r17,r6
81136dfc:	8963803a 	cmpltu	r17,r17,r5
81136e00:	4251c83a 	sub	r8,r8,r9
81136e04:	4451c83a 	sub	r8,r8,r17
81136e08:	2823883a 	mov	r17,r5
81136e0c:	003f9f06 	br	81136c8c <__reset+0xfb116c8c>
81136e10:	4984b03a 	or	r2,r9,r6
81136e14:	103f6026 	beq	r2,zero,81136b98 <__reset+0xfb116b98>
81136e18:	213fffc4 	addi	r4,r4,-1
81136e1c:	2000931e 	bne	r4,zero,8113706c <__adddf3+0x558>
81136e20:	898d883a 	add	r6,r17,r6
81136e24:	3463803a 	cmpltu	r17,r6,r17
81136e28:	4251883a 	add	r8,r8,r9
81136e2c:	8a11883a 	add	r8,r17,r8
81136e30:	3023883a 	mov	r17,r6
81136e34:	003fd806 	br	81136d98 <__reset+0xfb116d98>
81136e38:	1800541e 	bne	r3,zero,81136f8c <__adddf3+0x478>
81136e3c:	80800044 	addi	r2,r16,1
81136e40:	1081ffcc 	andi	r2,r2,2047
81136e44:	00c00044 	movi	r3,1
81136e48:	1880a00e 	bge	r3,r2,811370cc <__adddf3+0x5b8>
81136e4c:	8989c83a 	sub	r4,r17,r6
81136e50:	8905803a 	cmpltu	r2,r17,r4
81136e54:	4267c83a 	sub	r19,r8,r9
81136e58:	98a7c83a 	sub	r19,r19,r2
81136e5c:	9880202c 	andhi	r2,r19,128
81136e60:	10006326 	beq	r2,zero,81136ff0 <__adddf3+0x4dc>
81136e64:	3463c83a 	sub	r17,r6,r17
81136e68:	4a07c83a 	sub	r3,r9,r8
81136e6c:	344d803a 	cmpltu	r6,r6,r17
81136e70:	19a7c83a 	sub	r19,r3,r6
81136e74:	3825883a 	mov	r18,r7
81136e78:	983f8a1e 	bne	r19,zero,81136ca4 <__reset+0xfb116ca4>
81136e7c:	8809883a 	mov	r4,r17
81136e80:	11230c80 	call	811230c8 <__clzsi2>
81136e84:	10800804 	addi	r2,r2,32
81136e88:	10fffe04 	addi	r3,r2,-8
81136e8c:	010007c4 	movi	r4,31
81136e90:	20ff890e 	bge	r4,r3,81136cb8 <__reset+0xfb116cb8>
81136e94:	10bff604 	addi	r2,r2,-40
81136e98:	8884983a 	sll	r2,r17,r2
81136e9c:	0023883a 	mov	r17,zero
81136ea0:	1c3f8c0e 	bge	r3,r16,81136cd4 <__reset+0xfb116cd4>
81136ea4:	023fe034 	movhi	r8,65408
81136ea8:	423fffc4 	addi	r8,r8,-1
81136eac:	80e1c83a 	sub	r16,r16,r3
81136eb0:	1210703a 	and	r8,r2,r8
81136eb4:	003f3806 	br	81136b98 <__reset+0xfb116b98>
81136eb8:	9007883a 	mov	r3,r18
81136ebc:	0011883a 	mov	r8,zero
81136ec0:	0005883a 	mov	r2,zero
81136ec4:	003f4c06 	br	81136bf8 <__reset+0xfb116bf8>
81136ec8:	498cb03a 	or	r6,r9,r6
81136ecc:	300cc03a 	cmpne	r6,r6,zero
81136ed0:	0007883a 	mov	r3,zero
81136ed4:	003f6806 	br	81136c78 <__reset+0xfb116c78>
81136ed8:	20009c1e 	bne	r4,zero,8113714c <__adddf3+0x638>
81136edc:	80800044 	addi	r2,r16,1
81136ee0:	1141ffcc 	andi	r5,r2,2047
81136ee4:	01000044 	movi	r4,1
81136ee8:	2140670e 	bge	r4,r5,81137088 <__adddf3+0x574>
81136eec:	0101ffc4 	movi	r4,2047
81136ef0:	11007f26 	beq	r2,r4,811370f0 <__adddf3+0x5dc>
81136ef4:	898d883a 	add	r6,r17,r6
81136ef8:	4247883a 	add	r3,r8,r9
81136efc:	3451803a 	cmpltu	r8,r6,r17
81136f00:	40d1883a 	add	r8,r8,r3
81136f04:	402297fa 	slli	r17,r8,31
81136f08:	300cd07a 	srli	r6,r6,1
81136f0c:	4010d07a 	srli	r8,r8,1
81136f10:	1021883a 	mov	r16,r2
81136f14:	89a2b03a 	or	r17,r17,r6
81136f18:	003f1f06 	br	81136b98 <__reset+0xfb116b98>
81136f1c:	0081ffc4 	movi	r2,2047
81136f20:	80bf481e 	bne	r16,r2,81136c44 <__reset+0xfb116c44>
81136f24:	003f1c06 	br	81136b98 <__reset+0xfb116b98>
81136f28:	843ff844 	addi	r16,r16,-31
81136f2c:	01000804 	movi	r4,32
81136f30:	1406d83a 	srl	r3,r2,r16
81136f34:	41005026 	beq	r8,r4,81137078 <__adddf3+0x564>
81136f38:	01001004 	movi	r4,64
81136f3c:	2211c83a 	sub	r8,r4,r8
81136f40:	1204983a 	sll	r2,r2,r8
81136f44:	88a2b03a 	or	r17,r17,r2
81136f48:	8822c03a 	cmpne	r17,r17,zero
81136f4c:	1c62b03a 	or	r17,r3,r17
81136f50:	0011883a 	mov	r8,zero
81136f54:	0021883a 	mov	r16,zero
81136f58:	003f7106 	br	81136d20 <__reset+0xfb116d20>
81136f5c:	193ff804 	addi	r4,r3,-32
81136f60:	00800804 	movi	r2,32
81136f64:	4908d83a 	srl	r4,r9,r4
81136f68:	18804526 	beq	r3,r2,81137080 <__adddf3+0x56c>
81136f6c:	00801004 	movi	r2,64
81136f70:	10c5c83a 	sub	r2,r2,r3
81136f74:	4886983a 	sll	r3,r9,r2
81136f78:	198cb03a 	or	r6,r3,r6
81136f7c:	300cc03a 	cmpne	r6,r6,zero
81136f80:	218cb03a 	or	r6,r4,r6
81136f84:	0007883a 	mov	r3,zero
81136f88:	003f3b06 	br	81136c78 <__reset+0xfb116c78>
81136f8c:	80002a26 	beq	r16,zero,81137038 <__adddf3+0x524>
81136f90:	0101ffc4 	movi	r4,2047
81136f94:	11006826 	beq	r2,r4,81137138 <__adddf3+0x624>
81136f98:	00c7c83a 	sub	r3,zero,r3
81136f9c:	42002034 	orhi	r8,r8,128
81136fa0:	01000e04 	movi	r4,56
81136fa4:	20c07c16 	blt	r4,r3,81137198 <__adddf3+0x684>
81136fa8:	010007c4 	movi	r4,31
81136fac:	20c0da16 	blt	r4,r3,81137318 <__adddf3+0x804>
81136fb0:	01000804 	movi	r4,32
81136fb4:	20c9c83a 	sub	r4,r4,r3
81136fb8:	4114983a 	sll	r10,r8,r4
81136fbc:	88cad83a 	srl	r5,r17,r3
81136fc0:	8908983a 	sll	r4,r17,r4
81136fc4:	40c6d83a 	srl	r3,r8,r3
81136fc8:	5162b03a 	or	r17,r10,r5
81136fcc:	2008c03a 	cmpne	r4,r4,zero
81136fd0:	8922b03a 	or	r17,r17,r4
81136fd4:	3463c83a 	sub	r17,r6,r17
81136fd8:	48c7c83a 	sub	r3,r9,r3
81136fdc:	344d803a 	cmpltu	r6,r6,r17
81136fe0:	1991c83a 	sub	r8,r3,r6
81136fe4:	1021883a 	mov	r16,r2
81136fe8:	3825883a 	mov	r18,r7
81136fec:	003f2706 	br	81136c8c <__reset+0xfb116c8c>
81136ff0:	24d0b03a 	or	r8,r4,r19
81136ff4:	40001b1e 	bne	r8,zero,81137064 <__adddf3+0x550>
81136ff8:	0005883a 	mov	r2,zero
81136ffc:	0007883a 	mov	r3,zero
81137000:	0021883a 	mov	r16,zero
81137004:	003f4d06 	br	81136d3c <__reset+0xfb116d3c>
81137008:	008007c4 	movi	r2,31
8113700c:	11003c16 	blt	r2,r4,81137100 <__adddf3+0x5ec>
81137010:	00800804 	movi	r2,32
81137014:	1105c83a 	sub	r2,r2,r4
81137018:	488e983a 	sll	r7,r9,r2
8113701c:	310ad83a 	srl	r5,r6,r4
81137020:	3084983a 	sll	r2,r6,r2
81137024:	4912d83a 	srl	r9,r9,r4
81137028:	394ab03a 	or	r5,r7,r5
8113702c:	1004c03a 	cmpne	r2,r2,zero
81137030:	288ab03a 	or	r5,r5,r2
81137034:	003f5306 	br	81136d84 <__reset+0xfb116d84>
81137038:	4448b03a 	or	r4,r8,r17
8113703c:	20003e26 	beq	r4,zero,81137138 <__adddf3+0x624>
81137040:	00c6303a 	nor	r3,zero,r3
81137044:	18003a1e 	bne	r3,zero,81137130 <__adddf3+0x61c>
81137048:	3463c83a 	sub	r17,r6,r17
8113704c:	4a07c83a 	sub	r3,r9,r8
81137050:	344d803a 	cmpltu	r6,r6,r17
81137054:	1991c83a 	sub	r8,r3,r6
81137058:	1021883a 	mov	r16,r2
8113705c:	3825883a 	mov	r18,r7
81137060:	003f0a06 	br	81136c8c <__reset+0xfb116c8c>
81137064:	2023883a 	mov	r17,r4
81137068:	003f0d06 	br	81136ca0 <__reset+0xfb116ca0>
8113706c:	0081ffc4 	movi	r2,2047
81137070:	80bf3f1e 	bne	r16,r2,81136d70 <__reset+0xfb116d70>
81137074:	003ec806 	br	81136b98 <__reset+0xfb116b98>
81137078:	0005883a 	mov	r2,zero
8113707c:	003fb106 	br	81136f44 <__reset+0xfb116f44>
81137080:	0007883a 	mov	r3,zero
81137084:	003fbc06 	br	81136f78 <__reset+0xfb116f78>
81137088:	4444b03a 	or	r2,r8,r17
8113708c:	8000871e 	bne	r16,zero,811372ac <__adddf3+0x798>
81137090:	1000ba26 	beq	r2,zero,8113737c <__adddf3+0x868>
81137094:	4984b03a 	or	r2,r9,r6
81137098:	103ebf26 	beq	r2,zero,81136b98 <__reset+0xfb116b98>
8113709c:	8985883a 	add	r2,r17,r6
811370a0:	4247883a 	add	r3,r8,r9
811370a4:	1451803a 	cmpltu	r8,r2,r17
811370a8:	40d1883a 	add	r8,r8,r3
811370ac:	40c0202c 	andhi	r3,r8,128
811370b0:	1023883a 	mov	r17,r2
811370b4:	183f1a26 	beq	r3,zero,81136d20 <__reset+0xfb116d20>
811370b8:	00bfe034 	movhi	r2,65408
811370bc:	10bfffc4 	addi	r2,r2,-1
811370c0:	2021883a 	mov	r16,r4
811370c4:	4090703a 	and	r8,r8,r2
811370c8:	003eb306 	br	81136b98 <__reset+0xfb116b98>
811370cc:	4444b03a 	or	r2,r8,r17
811370d0:	8000291e 	bne	r16,zero,81137178 <__adddf3+0x664>
811370d4:	10004b1e 	bne	r2,zero,81137204 <__adddf3+0x6f0>
811370d8:	4990b03a 	or	r8,r9,r6
811370dc:	40008b26 	beq	r8,zero,8113730c <__adddf3+0x7f8>
811370e0:	4811883a 	mov	r8,r9
811370e4:	3023883a 	mov	r17,r6
811370e8:	3825883a 	mov	r18,r7
811370ec:	003eaa06 	br	81136b98 <__reset+0xfb116b98>
811370f0:	1021883a 	mov	r16,r2
811370f4:	0011883a 	mov	r8,zero
811370f8:	0005883a 	mov	r2,zero
811370fc:	003f0f06 	br	81136d3c <__reset+0xfb116d3c>
81137100:	217ff804 	addi	r5,r4,-32
81137104:	00800804 	movi	r2,32
81137108:	494ad83a 	srl	r5,r9,r5
8113710c:	20807d26 	beq	r4,r2,81137304 <__adddf3+0x7f0>
81137110:	00801004 	movi	r2,64
81137114:	1109c83a 	sub	r4,r2,r4
81137118:	4912983a 	sll	r9,r9,r4
8113711c:	498cb03a 	or	r6,r9,r6
81137120:	300cc03a 	cmpne	r6,r6,zero
81137124:	298ab03a 	or	r5,r5,r6
81137128:	0013883a 	mov	r9,zero
8113712c:	003f1506 	br	81136d84 <__reset+0xfb116d84>
81137130:	0101ffc4 	movi	r4,2047
81137134:	113f9a1e 	bne	r2,r4,81136fa0 <__reset+0xfb116fa0>
81137138:	4811883a 	mov	r8,r9
8113713c:	3023883a 	mov	r17,r6
81137140:	1021883a 	mov	r16,r2
81137144:	3825883a 	mov	r18,r7
81137148:	003e9306 	br	81136b98 <__reset+0xfb116b98>
8113714c:	8000161e 	bne	r16,zero,811371a8 <__adddf3+0x694>
81137150:	444ab03a 	or	r5,r8,r17
81137154:	28005126 	beq	r5,zero,8113729c <__adddf3+0x788>
81137158:	0108303a 	nor	r4,zero,r4
8113715c:	20004d1e 	bne	r4,zero,81137294 <__adddf3+0x780>
81137160:	89a3883a 	add	r17,r17,r6
81137164:	4253883a 	add	r9,r8,r9
81137168:	898d803a 	cmpltu	r6,r17,r6
8113716c:	3251883a 	add	r8,r6,r9
81137170:	1021883a 	mov	r16,r2
81137174:	003f0806 	br	81136d98 <__reset+0xfb116d98>
81137178:	1000301e 	bne	r2,zero,8113723c <__adddf3+0x728>
8113717c:	4984b03a 	or	r2,r9,r6
81137180:	10007126 	beq	r2,zero,81137348 <__adddf3+0x834>
81137184:	4811883a 	mov	r8,r9
81137188:	3023883a 	mov	r17,r6
8113718c:	3825883a 	mov	r18,r7
81137190:	0401ffc4 	movi	r16,2047
81137194:	003e8006 	br	81136b98 <__reset+0xfb116b98>
81137198:	4462b03a 	or	r17,r8,r17
8113719c:	8822c03a 	cmpne	r17,r17,zero
811371a0:	0007883a 	mov	r3,zero
811371a4:	003f8b06 	br	81136fd4 <__reset+0xfb116fd4>
811371a8:	0141ffc4 	movi	r5,2047
811371ac:	11403b26 	beq	r2,r5,8113729c <__adddf3+0x788>
811371b0:	0109c83a 	sub	r4,zero,r4
811371b4:	42002034 	orhi	r8,r8,128
811371b8:	01400e04 	movi	r5,56
811371bc:	29006716 	blt	r5,r4,8113735c <__adddf3+0x848>
811371c0:	014007c4 	movi	r5,31
811371c4:	29007016 	blt	r5,r4,81137388 <__adddf3+0x874>
811371c8:	01400804 	movi	r5,32
811371cc:	290bc83a 	sub	r5,r5,r4
811371d0:	4154983a 	sll	r10,r8,r5
811371d4:	890ed83a 	srl	r7,r17,r4
811371d8:	894a983a 	sll	r5,r17,r5
811371dc:	4108d83a 	srl	r4,r8,r4
811371e0:	51e2b03a 	or	r17,r10,r7
811371e4:	280ac03a 	cmpne	r5,r5,zero
811371e8:	8962b03a 	or	r17,r17,r5
811371ec:	89a3883a 	add	r17,r17,r6
811371f0:	2253883a 	add	r9,r4,r9
811371f4:	898d803a 	cmpltu	r6,r17,r6
811371f8:	3251883a 	add	r8,r6,r9
811371fc:	1021883a 	mov	r16,r2
81137200:	003ee506 	br	81136d98 <__reset+0xfb116d98>
81137204:	4984b03a 	or	r2,r9,r6
81137208:	103e6326 	beq	r2,zero,81136b98 <__reset+0xfb116b98>
8113720c:	8987c83a 	sub	r3,r17,r6
81137210:	88c9803a 	cmpltu	r4,r17,r3
81137214:	4245c83a 	sub	r2,r8,r9
81137218:	1105c83a 	sub	r2,r2,r4
8113721c:	1100202c 	andhi	r4,r2,128
81137220:	203ebb26 	beq	r4,zero,81136d10 <__reset+0xfb116d10>
81137224:	3463c83a 	sub	r17,r6,r17
81137228:	4a07c83a 	sub	r3,r9,r8
8113722c:	344d803a 	cmpltu	r6,r6,r17
81137230:	1991c83a 	sub	r8,r3,r6
81137234:	3825883a 	mov	r18,r7
81137238:	003e5706 	br	81136b98 <__reset+0xfb116b98>
8113723c:	4984b03a 	or	r2,r9,r6
81137240:	10002e26 	beq	r2,zero,811372fc <__adddf3+0x7e8>
81137244:	4004d0fa 	srli	r2,r8,3
81137248:	8822d0fa 	srli	r17,r17,3
8113724c:	4010977a 	slli	r8,r8,29
81137250:	10c0022c 	andhi	r3,r2,8
81137254:	4462b03a 	or	r17,r8,r17
81137258:	18000826 	beq	r3,zero,8113727c <__adddf3+0x768>
8113725c:	4808d0fa 	srli	r4,r9,3
81137260:	20c0022c 	andhi	r3,r4,8
81137264:	1800051e 	bne	r3,zero,8113727c <__adddf3+0x768>
81137268:	300cd0fa 	srli	r6,r6,3
8113726c:	4806977a 	slli	r3,r9,29
81137270:	2005883a 	mov	r2,r4
81137274:	3825883a 	mov	r18,r7
81137278:	19a2b03a 	or	r17,r3,r6
8113727c:	8810d77a 	srli	r8,r17,29
81137280:	100490fa 	slli	r2,r2,3
81137284:	882290fa 	slli	r17,r17,3
81137288:	0401ffc4 	movi	r16,2047
8113728c:	4090b03a 	or	r8,r8,r2
81137290:	003e4106 	br	81136b98 <__reset+0xfb116b98>
81137294:	0141ffc4 	movi	r5,2047
81137298:	117fc71e 	bne	r2,r5,811371b8 <__reset+0xfb1171b8>
8113729c:	4811883a 	mov	r8,r9
811372a0:	3023883a 	mov	r17,r6
811372a4:	1021883a 	mov	r16,r2
811372a8:	003e3b06 	br	81136b98 <__reset+0xfb116b98>
811372ac:	10002f26 	beq	r2,zero,8113736c <__adddf3+0x858>
811372b0:	4984b03a 	or	r2,r9,r6
811372b4:	10001126 	beq	r2,zero,811372fc <__adddf3+0x7e8>
811372b8:	4004d0fa 	srli	r2,r8,3
811372bc:	8822d0fa 	srli	r17,r17,3
811372c0:	4010977a 	slli	r8,r8,29
811372c4:	10c0022c 	andhi	r3,r2,8
811372c8:	4462b03a 	or	r17,r8,r17
811372cc:	183feb26 	beq	r3,zero,8113727c <__reset+0xfb11727c>
811372d0:	4808d0fa 	srli	r4,r9,3
811372d4:	20c0022c 	andhi	r3,r4,8
811372d8:	183fe81e 	bne	r3,zero,8113727c <__reset+0xfb11727c>
811372dc:	300cd0fa 	srli	r6,r6,3
811372e0:	4806977a 	slli	r3,r9,29
811372e4:	2005883a 	mov	r2,r4
811372e8:	19a2b03a 	or	r17,r3,r6
811372ec:	003fe306 	br	8113727c <__reset+0xfb11727c>
811372f0:	0011883a 	mov	r8,zero
811372f4:	0005883a 	mov	r2,zero
811372f8:	003e3f06 	br	81136bf8 <__reset+0xfb116bf8>
811372fc:	0401ffc4 	movi	r16,2047
81137300:	003e2506 	br	81136b98 <__reset+0xfb116b98>
81137304:	0013883a 	mov	r9,zero
81137308:	003f8406 	br	8113711c <__reset+0xfb11711c>
8113730c:	0005883a 	mov	r2,zero
81137310:	0007883a 	mov	r3,zero
81137314:	003e8906 	br	81136d3c <__reset+0xfb116d3c>
81137318:	197ff804 	addi	r5,r3,-32
8113731c:	01000804 	movi	r4,32
81137320:	414ad83a 	srl	r5,r8,r5
81137324:	19002426 	beq	r3,r4,811373b8 <__adddf3+0x8a4>
81137328:	01001004 	movi	r4,64
8113732c:	20c7c83a 	sub	r3,r4,r3
81137330:	40c6983a 	sll	r3,r8,r3
81137334:	1c46b03a 	or	r3,r3,r17
81137338:	1806c03a 	cmpne	r3,r3,zero
8113733c:	28e2b03a 	or	r17,r5,r3
81137340:	0007883a 	mov	r3,zero
81137344:	003f2306 	br	81136fd4 <__reset+0xfb116fd4>
81137348:	0007883a 	mov	r3,zero
8113734c:	5811883a 	mov	r8,r11
81137350:	00bfffc4 	movi	r2,-1
81137354:	0401ffc4 	movi	r16,2047
81137358:	003e7806 	br	81136d3c <__reset+0xfb116d3c>
8113735c:	4462b03a 	or	r17,r8,r17
81137360:	8822c03a 	cmpne	r17,r17,zero
81137364:	0009883a 	mov	r4,zero
81137368:	003fa006 	br	811371ec <__reset+0xfb1171ec>
8113736c:	4811883a 	mov	r8,r9
81137370:	3023883a 	mov	r17,r6
81137374:	0401ffc4 	movi	r16,2047
81137378:	003e0706 	br	81136b98 <__reset+0xfb116b98>
8113737c:	4811883a 	mov	r8,r9
81137380:	3023883a 	mov	r17,r6
81137384:	003e0406 	br	81136b98 <__reset+0xfb116b98>
81137388:	21fff804 	addi	r7,r4,-32
8113738c:	01400804 	movi	r5,32
81137390:	41ced83a 	srl	r7,r8,r7
81137394:	21400a26 	beq	r4,r5,811373c0 <__adddf3+0x8ac>
81137398:	01401004 	movi	r5,64
8113739c:	2909c83a 	sub	r4,r5,r4
811373a0:	4108983a 	sll	r4,r8,r4
811373a4:	2448b03a 	or	r4,r4,r17
811373a8:	2008c03a 	cmpne	r4,r4,zero
811373ac:	3922b03a 	or	r17,r7,r4
811373b0:	0009883a 	mov	r4,zero
811373b4:	003f8d06 	br	811371ec <__reset+0xfb1171ec>
811373b8:	0007883a 	mov	r3,zero
811373bc:	003fdd06 	br	81137334 <__reset+0xfb117334>
811373c0:	0009883a 	mov	r4,zero
811373c4:	003ff706 	br	811373a4 <__reset+0xfb1173a4>

811373c8 <__divdf3>:
811373c8:	defff204 	addi	sp,sp,-56
811373cc:	de00012e 	bgeu	sp,et,811373d4 <__divdf3+0xc>
811373d0:	003b68fa 	trap	3
811373d4:	dd400915 	stw	r21,36(sp)
811373d8:	282ad53a 	srli	r21,r5,20
811373dc:	dd000815 	stw	r20,32(sp)
811373e0:	2828d7fa 	srli	r20,r5,31
811373e4:	dc000415 	stw	r16,16(sp)
811373e8:	04000434 	movhi	r16,16
811373ec:	df000c15 	stw	fp,48(sp)
811373f0:	843fffc4 	addi	r16,r16,-1
811373f4:	dfc00d15 	stw	ra,52(sp)
811373f8:	ddc00b15 	stw	r23,44(sp)
811373fc:	dd800a15 	stw	r22,40(sp)
81137400:	dcc00715 	stw	r19,28(sp)
81137404:	dc800615 	stw	r18,24(sp)
81137408:	dc400515 	stw	r17,20(sp)
8113740c:	ad41ffcc 	andi	r21,r21,2047
81137410:	2c20703a 	and	r16,r5,r16
81137414:	a7003fcc 	andi	fp,r20,255
81137418:	a8006126 	beq	r21,zero,811375a0 <__divdf3+0x1d8>
8113741c:	0081ffc4 	movi	r2,2047
81137420:	2025883a 	mov	r18,r4
81137424:	a8803726 	beq	r21,r2,81137504 <__divdf3+0x13c>
81137428:	80800434 	orhi	r2,r16,16
8113742c:	100490fa 	slli	r2,r2,3
81137430:	2020d77a 	srli	r16,r4,29
81137434:	202490fa 	slli	r18,r4,3
81137438:	ad7f0044 	addi	r21,r21,-1023
8113743c:	80a0b03a 	or	r16,r16,r2
81137440:	0027883a 	mov	r19,zero
81137444:	0013883a 	mov	r9,zero
81137448:	3804d53a 	srli	r2,r7,20
8113744c:	382cd7fa 	srli	r22,r7,31
81137450:	04400434 	movhi	r17,16
81137454:	8c7fffc4 	addi	r17,r17,-1
81137458:	1081ffcc 	andi	r2,r2,2047
8113745c:	3011883a 	mov	r8,r6
81137460:	3c62703a 	and	r17,r7,r17
81137464:	b5c03fcc 	andi	r23,r22,255
81137468:	10006c26 	beq	r2,zero,8113761c <__divdf3+0x254>
8113746c:	00c1ffc4 	movi	r3,2047
81137470:	10c06426 	beq	r2,r3,81137604 <__divdf3+0x23c>
81137474:	88c00434 	orhi	r3,r17,16
81137478:	180690fa 	slli	r3,r3,3
8113747c:	3022d77a 	srli	r17,r6,29
81137480:	301090fa 	slli	r8,r6,3
81137484:	10bf0044 	addi	r2,r2,-1023
81137488:	88e2b03a 	or	r17,r17,r3
8113748c:	000f883a 	mov	r7,zero
81137490:	a58cf03a 	xor	r6,r20,r22
81137494:	3cc8b03a 	or	r4,r7,r19
81137498:	a8abc83a 	sub	r21,r21,r2
8113749c:	008003c4 	movi	r2,15
811374a0:	3007883a 	mov	r3,r6
811374a4:	34c03fcc 	andi	r19,r6,255
811374a8:	11009036 	bltu	r2,r4,811376ec <__divdf3+0x324>
811374ac:	200890ba 	slli	r4,r4,2
811374b0:	00a044f4 	movhi	r2,33043
811374b4:	109d3104 	addi	r2,r2,29892
811374b8:	2089883a 	add	r4,r4,r2
811374bc:	20800017 	ldw	r2,0(r4)
811374c0:	1000683a 	jmp	r2
811374c4:	811376ec 	andhi	r4,r16,19931
811374c8:	8113753c 	xorhi	r4,r16,19924
811374cc:	811376dc 	xori	r4,r16,19931
811374d0:	81137530 	cmpltui	r4,r16,19924
811374d4:	811376dc 	xori	r4,r16,19931
811374d8:	811376b0 	cmpltui	r4,r16,19930
811374dc:	811376dc 	xori	r4,r16,19931
811374e0:	81137530 	cmpltui	r4,r16,19924
811374e4:	8113753c 	xorhi	r4,r16,19924
811374e8:	8113753c 	xorhi	r4,r16,19924
811374ec:	811376b0 	cmpltui	r4,r16,19930
811374f0:	81137530 	cmpltui	r4,r16,19924
811374f4:	81137520 	cmpeqi	r4,r16,19924
811374f8:	81137520 	cmpeqi	r4,r16,19924
811374fc:	81137520 	cmpeqi	r4,r16,19924
81137500:	811379d0 	cmplti	r4,r16,19943
81137504:	2404b03a 	or	r2,r4,r16
81137508:	1000661e 	bne	r2,zero,811376a4 <__divdf3+0x2dc>
8113750c:	04c00204 	movi	r19,8
81137510:	0021883a 	mov	r16,zero
81137514:	0025883a 	mov	r18,zero
81137518:	02400084 	movi	r9,2
8113751c:	003fca06 	br	81137448 <__reset+0xfb117448>
81137520:	8023883a 	mov	r17,r16
81137524:	9011883a 	mov	r8,r18
81137528:	e02f883a 	mov	r23,fp
8113752c:	480f883a 	mov	r7,r9
81137530:	00800084 	movi	r2,2
81137534:	3881311e 	bne	r7,r2,811379fc <__divdf3+0x634>
81137538:	b827883a 	mov	r19,r23
8113753c:	98c0004c 	andi	r3,r19,1
81137540:	0081ffc4 	movi	r2,2047
81137544:	000b883a 	mov	r5,zero
81137548:	0025883a 	mov	r18,zero
8113754c:	1004953a 	slli	r2,r2,20
81137550:	18c03fcc 	andi	r3,r3,255
81137554:	04400434 	movhi	r17,16
81137558:	8c7fffc4 	addi	r17,r17,-1
8113755c:	180697fa 	slli	r3,r3,31
81137560:	2c4a703a 	and	r5,r5,r17
81137564:	288ab03a 	or	r5,r5,r2
81137568:	28c6b03a 	or	r3,r5,r3
8113756c:	9005883a 	mov	r2,r18
81137570:	dfc00d17 	ldw	ra,52(sp)
81137574:	df000c17 	ldw	fp,48(sp)
81137578:	ddc00b17 	ldw	r23,44(sp)
8113757c:	dd800a17 	ldw	r22,40(sp)
81137580:	dd400917 	ldw	r21,36(sp)
81137584:	dd000817 	ldw	r20,32(sp)
81137588:	dcc00717 	ldw	r19,28(sp)
8113758c:	dc800617 	ldw	r18,24(sp)
81137590:	dc400517 	ldw	r17,20(sp)
81137594:	dc000417 	ldw	r16,16(sp)
81137598:	dec00e04 	addi	sp,sp,56
8113759c:	f800283a 	ret
811375a0:	2404b03a 	or	r2,r4,r16
811375a4:	2027883a 	mov	r19,r4
811375a8:	10003926 	beq	r2,zero,81137690 <__divdf3+0x2c8>
811375ac:	80012e26 	beq	r16,zero,81137a68 <__divdf3+0x6a0>
811375b0:	8009883a 	mov	r4,r16
811375b4:	d9800315 	stw	r6,12(sp)
811375b8:	d9c00215 	stw	r7,8(sp)
811375bc:	11230c80 	call	811230c8 <__clzsi2>
811375c0:	d9800317 	ldw	r6,12(sp)
811375c4:	d9c00217 	ldw	r7,8(sp)
811375c8:	113ffd44 	addi	r4,r2,-11
811375cc:	00c00704 	movi	r3,28
811375d0:	19012116 	blt	r3,r4,81137a58 <__divdf3+0x690>
811375d4:	00c00744 	movi	r3,29
811375d8:	147ffe04 	addi	r17,r2,-8
811375dc:	1907c83a 	sub	r3,r3,r4
811375e0:	8460983a 	sll	r16,r16,r17
811375e4:	98c6d83a 	srl	r3,r19,r3
811375e8:	9c64983a 	sll	r18,r19,r17
811375ec:	1c20b03a 	or	r16,r3,r16
811375f0:	1080fcc4 	addi	r2,r2,1011
811375f4:	00abc83a 	sub	r21,zero,r2
811375f8:	0027883a 	mov	r19,zero
811375fc:	0013883a 	mov	r9,zero
81137600:	003f9106 	br	81137448 <__reset+0xfb117448>
81137604:	3446b03a 	or	r3,r6,r17
81137608:	18001f1e 	bne	r3,zero,81137688 <__divdf3+0x2c0>
8113760c:	0023883a 	mov	r17,zero
81137610:	0011883a 	mov	r8,zero
81137614:	01c00084 	movi	r7,2
81137618:	003f9d06 	br	81137490 <__reset+0xfb117490>
8113761c:	3446b03a 	or	r3,r6,r17
81137620:	18001526 	beq	r3,zero,81137678 <__divdf3+0x2b0>
81137624:	88011b26 	beq	r17,zero,81137a94 <__divdf3+0x6cc>
81137628:	8809883a 	mov	r4,r17
8113762c:	d9800315 	stw	r6,12(sp)
81137630:	da400115 	stw	r9,4(sp)
81137634:	11230c80 	call	811230c8 <__clzsi2>
81137638:	d9800317 	ldw	r6,12(sp)
8113763c:	da400117 	ldw	r9,4(sp)
81137640:	113ffd44 	addi	r4,r2,-11
81137644:	00c00704 	movi	r3,28
81137648:	19010e16 	blt	r3,r4,81137a84 <__divdf3+0x6bc>
8113764c:	00c00744 	movi	r3,29
81137650:	123ffe04 	addi	r8,r2,-8
81137654:	1907c83a 	sub	r3,r3,r4
81137658:	8a22983a 	sll	r17,r17,r8
8113765c:	30c6d83a 	srl	r3,r6,r3
81137660:	3210983a 	sll	r8,r6,r8
81137664:	1c62b03a 	or	r17,r3,r17
81137668:	1080fcc4 	addi	r2,r2,1011
8113766c:	0085c83a 	sub	r2,zero,r2
81137670:	000f883a 	mov	r7,zero
81137674:	003f8606 	br	81137490 <__reset+0xfb117490>
81137678:	0023883a 	mov	r17,zero
8113767c:	0011883a 	mov	r8,zero
81137680:	01c00044 	movi	r7,1
81137684:	003f8206 	br	81137490 <__reset+0xfb117490>
81137688:	01c000c4 	movi	r7,3
8113768c:	003f8006 	br	81137490 <__reset+0xfb117490>
81137690:	04c00104 	movi	r19,4
81137694:	0021883a 	mov	r16,zero
81137698:	0025883a 	mov	r18,zero
8113769c:	02400044 	movi	r9,1
811376a0:	003f6906 	br	81137448 <__reset+0xfb117448>
811376a4:	04c00304 	movi	r19,12
811376a8:	024000c4 	movi	r9,3
811376ac:	003f6606 	br	81137448 <__reset+0xfb117448>
811376b0:	01400434 	movhi	r5,16
811376b4:	0007883a 	mov	r3,zero
811376b8:	297fffc4 	addi	r5,r5,-1
811376bc:	04bfffc4 	movi	r18,-1
811376c0:	0081ffc4 	movi	r2,2047
811376c4:	003fa106 	br	8113754c <__reset+0xfb11754c>
811376c8:	00c00044 	movi	r3,1
811376cc:	1887c83a 	sub	r3,r3,r2
811376d0:	01000e04 	movi	r4,56
811376d4:	20c1210e 	bge	r4,r3,81137b5c <__divdf3+0x794>
811376d8:	98c0004c 	andi	r3,r19,1
811376dc:	0005883a 	mov	r2,zero
811376e0:	000b883a 	mov	r5,zero
811376e4:	0025883a 	mov	r18,zero
811376e8:	003f9806 	br	8113754c <__reset+0xfb11754c>
811376ec:	8c00fd36 	bltu	r17,r16,81137ae4 <__divdf3+0x71c>
811376f0:	8440fb26 	beq	r16,r17,81137ae0 <__divdf3+0x718>
811376f4:	8007883a 	mov	r3,r16
811376f8:	ad7fffc4 	addi	r21,r21,-1
811376fc:	0021883a 	mov	r16,zero
81137700:	4004d63a 	srli	r2,r8,24
81137704:	8822923a 	slli	r17,r17,8
81137708:	1809883a 	mov	r4,r3
8113770c:	402c923a 	slli	r22,r8,8
81137710:	88b8b03a 	or	fp,r17,r2
81137714:	e028d43a 	srli	r20,fp,16
81137718:	d8c00015 	stw	r3,0(sp)
8113771c:	e5ffffcc 	andi	r23,fp,65535
81137720:	a00b883a 	mov	r5,r20
81137724:	113685c0 	call	8113685c <__udivsi3>
81137728:	d8c00017 	ldw	r3,0(sp)
8113772c:	a00b883a 	mov	r5,r20
81137730:	d8800315 	stw	r2,12(sp)
81137734:	1809883a 	mov	r4,r3
81137738:	11368c00 	call	811368c0 <__umodsi3>
8113773c:	d9800317 	ldw	r6,12(sp)
81137740:	1006943a 	slli	r3,r2,16
81137744:	9004d43a 	srli	r2,r18,16
81137748:	b9a3383a 	mul	r17,r23,r6
8113774c:	10c4b03a 	or	r2,r2,r3
81137750:	1440062e 	bgeu	r2,r17,8113776c <__divdf3+0x3a4>
81137754:	1705883a 	add	r2,r2,fp
81137758:	30ffffc4 	addi	r3,r6,-1
8113775c:	1700ee36 	bltu	r2,fp,81137b18 <__divdf3+0x750>
81137760:	1440ed2e 	bgeu	r2,r17,81137b18 <__divdf3+0x750>
81137764:	31bfff84 	addi	r6,r6,-2
81137768:	1705883a 	add	r2,r2,fp
8113776c:	1463c83a 	sub	r17,r2,r17
81137770:	a00b883a 	mov	r5,r20
81137774:	8809883a 	mov	r4,r17
81137778:	d9800315 	stw	r6,12(sp)
8113777c:	113685c0 	call	8113685c <__udivsi3>
81137780:	a00b883a 	mov	r5,r20
81137784:	8809883a 	mov	r4,r17
81137788:	d8800215 	stw	r2,8(sp)
8113778c:	11368c00 	call	811368c0 <__umodsi3>
81137790:	d9c00217 	ldw	r7,8(sp)
81137794:	1004943a 	slli	r2,r2,16
81137798:	94bfffcc 	andi	r18,r18,65535
8113779c:	b9d1383a 	mul	r8,r23,r7
811377a0:	90a4b03a 	or	r18,r18,r2
811377a4:	d9800317 	ldw	r6,12(sp)
811377a8:	9200062e 	bgeu	r18,r8,811377c4 <__divdf3+0x3fc>
811377ac:	9725883a 	add	r18,r18,fp
811377b0:	38bfffc4 	addi	r2,r7,-1
811377b4:	9700d636 	bltu	r18,fp,81137b10 <__divdf3+0x748>
811377b8:	9200d52e 	bgeu	r18,r8,81137b10 <__divdf3+0x748>
811377bc:	39ffff84 	addi	r7,r7,-2
811377c0:	9725883a 	add	r18,r18,fp
811377c4:	3004943a 	slli	r2,r6,16
811377c8:	b012d43a 	srli	r9,r22,16
811377cc:	b1bfffcc 	andi	r6,r22,65535
811377d0:	11e2b03a 	or	r17,r2,r7
811377d4:	8806d43a 	srli	r3,r17,16
811377d8:	893fffcc 	andi	r4,r17,65535
811377dc:	218b383a 	mul	r5,r4,r6
811377e0:	30c5383a 	mul	r2,r6,r3
811377e4:	2249383a 	mul	r4,r4,r9
811377e8:	280ed43a 	srli	r7,r5,16
811377ec:	9225c83a 	sub	r18,r18,r8
811377f0:	2089883a 	add	r4,r4,r2
811377f4:	3909883a 	add	r4,r7,r4
811377f8:	1a47383a 	mul	r3,r3,r9
811377fc:	2080022e 	bgeu	r4,r2,81137808 <__divdf3+0x440>
81137800:	00800074 	movhi	r2,1
81137804:	1887883a 	add	r3,r3,r2
81137808:	2004d43a 	srli	r2,r4,16
8113780c:	2008943a 	slli	r4,r4,16
81137810:	297fffcc 	andi	r5,r5,65535
81137814:	10c7883a 	add	r3,r2,r3
81137818:	2149883a 	add	r4,r4,r5
8113781c:	90c0a536 	bltu	r18,r3,81137ab4 <__divdf3+0x6ec>
81137820:	90c0bf26 	beq	r18,r3,81137b20 <__divdf3+0x758>
81137824:	90c7c83a 	sub	r3,r18,r3
81137828:	810fc83a 	sub	r7,r16,r4
8113782c:	81e5803a 	cmpltu	r18,r16,r7
81137830:	1ca5c83a 	sub	r18,r3,r18
81137834:	e480c126 	beq	fp,r18,81137b3c <__divdf3+0x774>
81137838:	a00b883a 	mov	r5,r20
8113783c:	9009883a 	mov	r4,r18
81137840:	d9800315 	stw	r6,12(sp)
81137844:	d9c00215 	stw	r7,8(sp)
81137848:	da400115 	stw	r9,4(sp)
8113784c:	113685c0 	call	8113685c <__udivsi3>
81137850:	a00b883a 	mov	r5,r20
81137854:	9009883a 	mov	r4,r18
81137858:	d8800015 	stw	r2,0(sp)
8113785c:	11368c00 	call	811368c0 <__umodsi3>
81137860:	d9c00217 	ldw	r7,8(sp)
81137864:	da000017 	ldw	r8,0(sp)
81137868:	1006943a 	slli	r3,r2,16
8113786c:	3804d43a 	srli	r2,r7,16
81137870:	ba21383a 	mul	r16,r23,r8
81137874:	d9800317 	ldw	r6,12(sp)
81137878:	10c4b03a 	or	r2,r2,r3
8113787c:	da400117 	ldw	r9,4(sp)
81137880:	1400062e 	bgeu	r2,r16,8113789c <__divdf3+0x4d4>
81137884:	1705883a 	add	r2,r2,fp
81137888:	40ffffc4 	addi	r3,r8,-1
8113788c:	1700ad36 	bltu	r2,fp,81137b44 <__divdf3+0x77c>
81137890:	1400ac2e 	bgeu	r2,r16,81137b44 <__divdf3+0x77c>
81137894:	423fff84 	addi	r8,r8,-2
81137898:	1705883a 	add	r2,r2,fp
8113789c:	1421c83a 	sub	r16,r2,r16
811378a0:	a00b883a 	mov	r5,r20
811378a4:	8009883a 	mov	r4,r16
811378a8:	d9800315 	stw	r6,12(sp)
811378ac:	d9c00215 	stw	r7,8(sp)
811378b0:	da000015 	stw	r8,0(sp)
811378b4:	da400115 	stw	r9,4(sp)
811378b8:	113685c0 	call	8113685c <__udivsi3>
811378bc:	8009883a 	mov	r4,r16
811378c0:	a00b883a 	mov	r5,r20
811378c4:	1025883a 	mov	r18,r2
811378c8:	11368c00 	call	811368c0 <__umodsi3>
811378cc:	d9c00217 	ldw	r7,8(sp)
811378d0:	1004943a 	slli	r2,r2,16
811378d4:	bcaf383a 	mul	r23,r23,r18
811378d8:	393fffcc 	andi	r4,r7,65535
811378dc:	2088b03a 	or	r4,r4,r2
811378e0:	d9800317 	ldw	r6,12(sp)
811378e4:	da000017 	ldw	r8,0(sp)
811378e8:	da400117 	ldw	r9,4(sp)
811378ec:	25c0062e 	bgeu	r4,r23,81137908 <__divdf3+0x540>
811378f0:	2709883a 	add	r4,r4,fp
811378f4:	90bfffc4 	addi	r2,r18,-1
811378f8:	27009436 	bltu	r4,fp,81137b4c <__divdf3+0x784>
811378fc:	25c0932e 	bgeu	r4,r23,81137b4c <__divdf3+0x784>
81137900:	94bfff84 	addi	r18,r18,-2
81137904:	2709883a 	add	r4,r4,fp
81137908:	4004943a 	slli	r2,r8,16
8113790c:	25efc83a 	sub	r23,r4,r23
81137910:	1490b03a 	or	r8,r2,r18
81137914:	4008d43a 	srli	r4,r8,16
81137918:	40ffffcc 	andi	r3,r8,65535
8113791c:	30c5383a 	mul	r2,r6,r3
81137920:	1a47383a 	mul	r3,r3,r9
81137924:	310d383a 	mul	r6,r6,r4
81137928:	100ad43a 	srli	r5,r2,16
8113792c:	4913383a 	mul	r9,r9,r4
81137930:	1987883a 	add	r3,r3,r6
81137934:	28c7883a 	add	r3,r5,r3
81137938:	1980022e 	bgeu	r3,r6,81137944 <__divdf3+0x57c>
8113793c:	01000074 	movhi	r4,1
81137940:	4913883a 	add	r9,r9,r4
81137944:	1808d43a 	srli	r4,r3,16
81137948:	1806943a 	slli	r3,r3,16
8113794c:	10bfffcc 	andi	r2,r2,65535
81137950:	2253883a 	add	r9,r4,r9
81137954:	1887883a 	add	r3,r3,r2
81137958:	ba403836 	bltu	r23,r9,81137a3c <__divdf3+0x674>
8113795c:	ba403626 	beq	r23,r9,81137a38 <__divdf3+0x670>
81137960:	42000054 	ori	r8,r8,1
81137964:	a880ffc4 	addi	r2,r21,1023
81137968:	00bf570e 	bge	zero,r2,811376c8 <__reset+0xfb1176c8>
8113796c:	40c001cc 	andi	r3,r8,7
81137970:	18000726 	beq	r3,zero,81137990 <__divdf3+0x5c8>
81137974:	40c003cc 	andi	r3,r8,15
81137978:	01000104 	movi	r4,4
8113797c:	19000426 	beq	r3,r4,81137990 <__divdf3+0x5c8>
81137980:	4107883a 	add	r3,r8,r4
81137984:	1a11803a 	cmpltu	r8,r3,r8
81137988:	8a23883a 	add	r17,r17,r8
8113798c:	1811883a 	mov	r8,r3
81137990:	88c0402c 	andhi	r3,r17,256
81137994:	18000426 	beq	r3,zero,811379a8 <__divdf3+0x5e0>
81137998:	00ffc034 	movhi	r3,65280
8113799c:	18ffffc4 	addi	r3,r3,-1
811379a0:	a8810004 	addi	r2,r21,1024
811379a4:	88e2703a 	and	r17,r17,r3
811379a8:	00c1ff84 	movi	r3,2046
811379ac:	18bee316 	blt	r3,r2,8113753c <__reset+0xfb11753c>
811379b0:	8824977a 	slli	r18,r17,29
811379b4:	4010d0fa 	srli	r8,r8,3
811379b8:	8822927a 	slli	r17,r17,9
811379bc:	1081ffcc 	andi	r2,r2,2047
811379c0:	9224b03a 	or	r18,r18,r8
811379c4:	880ad33a 	srli	r5,r17,12
811379c8:	98c0004c 	andi	r3,r19,1
811379cc:	003edf06 	br	8113754c <__reset+0xfb11754c>
811379d0:	8080022c 	andhi	r2,r16,8
811379d4:	10001226 	beq	r2,zero,81137a20 <__divdf3+0x658>
811379d8:	8880022c 	andhi	r2,r17,8
811379dc:	1000101e 	bne	r2,zero,81137a20 <__divdf3+0x658>
811379e0:	00800434 	movhi	r2,16
811379e4:	89400234 	orhi	r5,r17,8
811379e8:	10bfffc4 	addi	r2,r2,-1
811379ec:	b007883a 	mov	r3,r22
811379f0:	288a703a 	and	r5,r5,r2
811379f4:	4025883a 	mov	r18,r8
811379f8:	003f3106 	br	811376c0 <__reset+0xfb1176c0>
811379fc:	008000c4 	movi	r2,3
81137a00:	3880a626 	beq	r7,r2,81137c9c <__divdf3+0x8d4>
81137a04:	00800044 	movi	r2,1
81137a08:	3880521e 	bne	r7,r2,81137b54 <__divdf3+0x78c>
81137a0c:	b807883a 	mov	r3,r23
81137a10:	0005883a 	mov	r2,zero
81137a14:	000b883a 	mov	r5,zero
81137a18:	0025883a 	mov	r18,zero
81137a1c:	003ecb06 	br	8113754c <__reset+0xfb11754c>
81137a20:	00800434 	movhi	r2,16
81137a24:	81400234 	orhi	r5,r16,8
81137a28:	10bfffc4 	addi	r2,r2,-1
81137a2c:	a007883a 	mov	r3,r20
81137a30:	288a703a 	and	r5,r5,r2
81137a34:	003f2206 	br	811376c0 <__reset+0xfb1176c0>
81137a38:	183fca26 	beq	r3,zero,81137964 <__reset+0xfb117964>
81137a3c:	e5ef883a 	add	r23,fp,r23
81137a40:	40bfffc4 	addi	r2,r8,-1
81137a44:	bf00392e 	bgeu	r23,fp,81137b2c <__divdf3+0x764>
81137a48:	1011883a 	mov	r8,r2
81137a4c:	ba7fc41e 	bne	r23,r9,81137960 <__reset+0xfb117960>
81137a50:	b0ffc31e 	bne	r22,r3,81137960 <__reset+0xfb117960>
81137a54:	003fc306 	br	81137964 <__reset+0xfb117964>
81137a58:	143ff604 	addi	r16,r2,-40
81137a5c:	9c20983a 	sll	r16,r19,r16
81137a60:	0025883a 	mov	r18,zero
81137a64:	003ee206 	br	811375f0 <__reset+0xfb1175f0>
81137a68:	d9800315 	stw	r6,12(sp)
81137a6c:	d9c00215 	stw	r7,8(sp)
81137a70:	11230c80 	call	811230c8 <__clzsi2>
81137a74:	10800804 	addi	r2,r2,32
81137a78:	d9c00217 	ldw	r7,8(sp)
81137a7c:	d9800317 	ldw	r6,12(sp)
81137a80:	003ed106 	br	811375c8 <__reset+0xfb1175c8>
81137a84:	147ff604 	addi	r17,r2,-40
81137a88:	3462983a 	sll	r17,r6,r17
81137a8c:	0011883a 	mov	r8,zero
81137a90:	003ef506 	br	81137668 <__reset+0xfb117668>
81137a94:	3009883a 	mov	r4,r6
81137a98:	d9800315 	stw	r6,12(sp)
81137a9c:	da400115 	stw	r9,4(sp)
81137aa0:	11230c80 	call	811230c8 <__clzsi2>
81137aa4:	10800804 	addi	r2,r2,32
81137aa8:	da400117 	ldw	r9,4(sp)
81137aac:	d9800317 	ldw	r6,12(sp)
81137ab0:	003ee306 	br	81137640 <__reset+0xfb117640>
81137ab4:	85a1883a 	add	r16,r16,r22
81137ab8:	8585803a 	cmpltu	r2,r16,r22
81137abc:	1705883a 	add	r2,r2,fp
81137ac0:	14a5883a 	add	r18,r2,r18
81137ac4:	88bfffc4 	addi	r2,r17,-1
81137ac8:	e4800c2e 	bgeu	fp,r18,81137afc <__divdf3+0x734>
81137acc:	90c03e36 	bltu	r18,r3,81137bc8 <__divdf3+0x800>
81137ad0:	1c806926 	beq	r3,r18,81137c78 <__divdf3+0x8b0>
81137ad4:	90c7c83a 	sub	r3,r18,r3
81137ad8:	1023883a 	mov	r17,r2
81137adc:	003f5206 	br	81137828 <__reset+0xfb117828>
81137ae0:	923f0436 	bltu	r18,r8,811376f4 <__reset+0xfb1176f4>
81137ae4:	800897fa 	slli	r4,r16,31
81137ae8:	9004d07a 	srli	r2,r18,1
81137aec:	8006d07a 	srli	r3,r16,1
81137af0:	902097fa 	slli	r16,r18,31
81137af4:	20a4b03a 	or	r18,r4,r2
81137af8:	003f0106 	br	81137700 <__reset+0xfb117700>
81137afc:	e4bff51e 	bne	fp,r18,81137ad4 <__reset+0xfb117ad4>
81137b00:	85bff22e 	bgeu	r16,r22,81137acc <__reset+0xfb117acc>
81137b04:	e0c7c83a 	sub	r3,fp,r3
81137b08:	1023883a 	mov	r17,r2
81137b0c:	003f4606 	br	81137828 <__reset+0xfb117828>
81137b10:	100f883a 	mov	r7,r2
81137b14:	003f2b06 	br	811377c4 <__reset+0xfb1177c4>
81137b18:	180d883a 	mov	r6,r3
81137b1c:	003f1306 	br	8113776c <__reset+0xfb11776c>
81137b20:	813fe436 	bltu	r16,r4,81137ab4 <__reset+0xfb117ab4>
81137b24:	0007883a 	mov	r3,zero
81137b28:	003f3f06 	br	81137828 <__reset+0xfb117828>
81137b2c:	ba402c36 	bltu	r23,r9,81137be0 <__divdf3+0x818>
81137b30:	4dc05426 	beq	r9,r23,81137c84 <__divdf3+0x8bc>
81137b34:	1011883a 	mov	r8,r2
81137b38:	003f8906 	br	81137960 <__reset+0xfb117960>
81137b3c:	023fffc4 	movi	r8,-1
81137b40:	003f8806 	br	81137964 <__reset+0xfb117964>
81137b44:	1811883a 	mov	r8,r3
81137b48:	003f5406 	br	8113789c <__reset+0xfb11789c>
81137b4c:	1025883a 	mov	r18,r2
81137b50:	003f6d06 	br	81137908 <__reset+0xfb117908>
81137b54:	b827883a 	mov	r19,r23
81137b58:	003f8206 	br	81137964 <__reset+0xfb117964>
81137b5c:	010007c4 	movi	r4,31
81137b60:	20c02616 	blt	r4,r3,81137bfc <__divdf3+0x834>
81137b64:	00800804 	movi	r2,32
81137b68:	10c5c83a 	sub	r2,r2,r3
81137b6c:	888a983a 	sll	r5,r17,r2
81137b70:	40c8d83a 	srl	r4,r8,r3
81137b74:	4084983a 	sll	r2,r8,r2
81137b78:	88e2d83a 	srl	r17,r17,r3
81137b7c:	2906b03a 	or	r3,r5,r4
81137b80:	1004c03a 	cmpne	r2,r2,zero
81137b84:	1886b03a 	or	r3,r3,r2
81137b88:	188001cc 	andi	r2,r3,7
81137b8c:	10000726 	beq	r2,zero,81137bac <__divdf3+0x7e4>
81137b90:	188003cc 	andi	r2,r3,15
81137b94:	01000104 	movi	r4,4
81137b98:	11000426 	beq	r2,r4,81137bac <__divdf3+0x7e4>
81137b9c:	1805883a 	mov	r2,r3
81137ba0:	10c00104 	addi	r3,r2,4
81137ba4:	1885803a 	cmpltu	r2,r3,r2
81137ba8:	88a3883a 	add	r17,r17,r2
81137bac:	8880202c 	andhi	r2,r17,128
81137bb0:	10002726 	beq	r2,zero,81137c50 <__divdf3+0x888>
81137bb4:	98c0004c 	andi	r3,r19,1
81137bb8:	00800044 	movi	r2,1
81137bbc:	000b883a 	mov	r5,zero
81137bc0:	0025883a 	mov	r18,zero
81137bc4:	003e6106 	br	8113754c <__reset+0xfb11754c>
81137bc8:	85a1883a 	add	r16,r16,r22
81137bcc:	8585803a 	cmpltu	r2,r16,r22
81137bd0:	1705883a 	add	r2,r2,fp
81137bd4:	14a5883a 	add	r18,r2,r18
81137bd8:	8c7fff84 	addi	r17,r17,-2
81137bdc:	003f1106 	br	81137824 <__reset+0xfb117824>
81137be0:	b589883a 	add	r4,r22,r22
81137be4:	25ad803a 	cmpltu	r22,r4,r22
81137be8:	b739883a 	add	fp,r22,fp
81137bec:	40bfff84 	addi	r2,r8,-2
81137bf0:	bf2f883a 	add	r23,r23,fp
81137bf4:	202d883a 	mov	r22,r4
81137bf8:	003f9306 	br	81137a48 <__reset+0xfb117a48>
81137bfc:	013ff844 	movi	r4,-31
81137c00:	2085c83a 	sub	r2,r4,r2
81137c04:	8888d83a 	srl	r4,r17,r2
81137c08:	00800804 	movi	r2,32
81137c0c:	18802126 	beq	r3,r2,81137c94 <__divdf3+0x8cc>
81137c10:	00801004 	movi	r2,64
81137c14:	10c5c83a 	sub	r2,r2,r3
81137c18:	8884983a 	sll	r2,r17,r2
81137c1c:	1204b03a 	or	r2,r2,r8
81137c20:	1004c03a 	cmpne	r2,r2,zero
81137c24:	2084b03a 	or	r2,r4,r2
81137c28:	144001cc 	andi	r17,r2,7
81137c2c:	88000d1e 	bne	r17,zero,81137c64 <__divdf3+0x89c>
81137c30:	000b883a 	mov	r5,zero
81137c34:	1024d0fa 	srli	r18,r2,3
81137c38:	98c0004c 	andi	r3,r19,1
81137c3c:	0005883a 	mov	r2,zero
81137c40:	9464b03a 	or	r18,r18,r17
81137c44:	003e4106 	br	8113754c <__reset+0xfb11754c>
81137c48:	1007883a 	mov	r3,r2
81137c4c:	0023883a 	mov	r17,zero
81137c50:	880a927a 	slli	r5,r17,9
81137c54:	1805883a 	mov	r2,r3
81137c58:	8822977a 	slli	r17,r17,29
81137c5c:	280ad33a 	srli	r5,r5,12
81137c60:	003ff406 	br	81137c34 <__reset+0xfb117c34>
81137c64:	10c003cc 	andi	r3,r2,15
81137c68:	01000104 	movi	r4,4
81137c6c:	193ff626 	beq	r3,r4,81137c48 <__reset+0xfb117c48>
81137c70:	0023883a 	mov	r17,zero
81137c74:	003fca06 	br	81137ba0 <__reset+0xfb117ba0>
81137c78:	813fd336 	bltu	r16,r4,81137bc8 <__reset+0xfb117bc8>
81137c7c:	1023883a 	mov	r17,r2
81137c80:	003fa806 	br	81137b24 <__reset+0xfb117b24>
81137c84:	b0ffd636 	bltu	r22,r3,81137be0 <__reset+0xfb117be0>
81137c88:	1011883a 	mov	r8,r2
81137c8c:	b0ff341e 	bne	r22,r3,81137960 <__reset+0xfb117960>
81137c90:	003f3406 	br	81137964 <__reset+0xfb117964>
81137c94:	0005883a 	mov	r2,zero
81137c98:	003fe006 	br	81137c1c <__reset+0xfb117c1c>
81137c9c:	00800434 	movhi	r2,16
81137ca0:	89400234 	orhi	r5,r17,8
81137ca4:	10bfffc4 	addi	r2,r2,-1
81137ca8:	b807883a 	mov	r3,r23
81137cac:	288a703a 	and	r5,r5,r2
81137cb0:	4025883a 	mov	r18,r8
81137cb4:	003e8206 	br	811376c0 <__reset+0xfb1176c0>

81137cb8 <__eqdf2>:
81137cb8:	2804d53a 	srli	r2,r5,20
81137cbc:	3806d53a 	srli	r3,r7,20
81137cc0:	02000434 	movhi	r8,16
81137cc4:	423fffc4 	addi	r8,r8,-1
81137cc8:	1081ffcc 	andi	r2,r2,2047
81137ccc:	0281ffc4 	movi	r10,2047
81137cd0:	2a12703a 	and	r9,r5,r8
81137cd4:	18c1ffcc 	andi	r3,r3,2047
81137cd8:	3a10703a 	and	r8,r7,r8
81137cdc:	280ad7fa 	srli	r5,r5,31
81137ce0:	380ed7fa 	srli	r7,r7,31
81137ce4:	12801026 	beq	r2,r10,81137d28 <__eqdf2+0x70>
81137ce8:	0281ffc4 	movi	r10,2047
81137cec:	1a800a26 	beq	r3,r10,81137d18 <__eqdf2+0x60>
81137cf0:	10c00226 	beq	r2,r3,81137cfc <__eqdf2+0x44>
81137cf4:	00800044 	movi	r2,1
81137cf8:	f800283a 	ret
81137cfc:	4a3ffd1e 	bne	r9,r8,81137cf4 <__reset+0xfb117cf4>
81137d00:	21bffc1e 	bne	r4,r6,81137cf4 <__reset+0xfb117cf4>
81137d04:	29c00c26 	beq	r5,r7,81137d38 <__eqdf2+0x80>
81137d08:	103ffa1e 	bne	r2,zero,81137cf4 <__reset+0xfb117cf4>
81137d0c:	2244b03a 	or	r2,r4,r9
81137d10:	1004c03a 	cmpne	r2,r2,zero
81137d14:	f800283a 	ret
81137d18:	3214b03a 	or	r10,r6,r8
81137d1c:	503ff426 	beq	r10,zero,81137cf0 <__reset+0xfb117cf0>
81137d20:	00800044 	movi	r2,1
81137d24:	f800283a 	ret
81137d28:	2254b03a 	or	r10,r4,r9
81137d2c:	503fee26 	beq	r10,zero,81137ce8 <__reset+0xfb117ce8>
81137d30:	00800044 	movi	r2,1
81137d34:	f800283a 	ret
81137d38:	0005883a 	mov	r2,zero
81137d3c:	f800283a 	ret

81137d40 <__ledf2>:
81137d40:	2804d53a 	srli	r2,r5,20
81137d44:	3810d53a 	srli	r8,r7,20
81137d48:	00c00434 	movhi	r3,16
81137d4c:	18ffffc4 	addi	r3,r3,-1
81137d50:	1081ffcc 	andi	r2,r2,2047
81137d54:	0241ffc4 	movi	r9,2047
81137d58:	28d4703a 	and	r10,r5,r3
81137d5c:	4201ffcc 	andi	r8,r8,2047
81137d60:	38c6703a 	and	r3,r7,r3
81137d64:	280ad7fa 	srli	r5,r5,31
81137d68:	380ed7fa 	srli	r7,r7,31
81137d6c:	12401f26 	beq	r2,r9,81137dec <__ledf2+0xac>
81137d70:	0241ffc4 	movi	r9,2047
81137d74:	42401426 	beq	r8,r9,81137dc8 <__ledf2+0x88>
81137d78:	1000091e 	bne	r2,zero,81137da0 <__ledf2+0x60>
81137d7c:	2296b03a 	or	r11,r4,r10
81137d80:	5813003a 	cmpeq	r9,r11,zero
81137d84:	29403fcc 	andi	r5,r5,255
81137d88:	40000a1e 	bne	r8,zero,81137db4 <__ledf2+0x74>
81137d8c:	30d8b03a 	or	r12,r6,r3
81137d90:	6000081e 	bne	r12,zero,81137db4 <__ledf2+0x74>
81137d94:	0005883a 	mov	r2,zero
81137d98:	5800111e 	bne	r11,zero,81137de0 <__ledf2+0xa0>
81137d9c:	f800283a 	ret
81137da0:	29403fcc 	andi	r5,r5,255
81137da4:	40000c1e 	bne	r8,zero,81137dd8 <__ledf2+0x98>
81137da8:	30d2b03a 	or	r9,r6,r3
81137dac:	48000c26 	beq	r9,zero,81137de0 <__ledf2+0xa0>
81137db0:	0013883a 	mov	r9,zero
81137db4:	39c03fcc 	andi	r7,r7,255
81137db8:	48000826 	beq	r9,zero,81137ddc <__ledf2+0x9c>
81137dbc:	38001126 	beq	r7,zero,81137e04 <__ledf2+0xc4>
81137dc0:	00800044 	movi	r2,1
81137dc4:	f800283a 	ret
81137dc8:	30d2b03a 	or	r9,r6,r3
81137dcc:	483fea26 	beq	r9,zero,81137d78 <__reset+0xfb117d78>
81137dd0:	00800084 	movi	r2,2
81137dd4:	f800283a 	ret
81137dd8:	39c03fcc 	andi	r7,r7,255
81137ddc:	39400726 	beq	r7,r5,81137dfc <__ledf2+0xbc>
81137de0:	2800081e 	bne	r5,zero,81137e04 <__ledf2+0xc4>
81137de4:	00800044 	movi	r2,1
81137de8:	f800283a 	ret
81137dec:	2292b03a 	or	r9,r4,r10
81137df0:	483fdf26 	beq	r9,zero,81137d70 <__reset+0xfb117d70>
81137df4:	00800084 	movi	r2,2
81137df8:	f800283a 	ret
81137dfc:	4080030e 	bge	r8,r2,81137e0c <__ledf2+0xcc>
81137e00:	383fef26 	beq	r7,zero,81137dc0 <__reset+0xfb117dc0>
81137e04:	00bfffc4 	movi	r2,-1
81137e08:	f800283a 	ret
81137e0c:	123feb16 	blt	r2,r8,81137dbc <__reset+0xfb117dbc>
81137e10:	1abff336 	bltu	r3,r10,81137de0 <__reset+0xfb117de0>
81137e14:	50c00326 	beq	r10,r3,81137e24 <__ledf2+0xe4>
81137e18:	50c0042e 	bgeu	r10,r3,81137e2c <__ledf2+0xec>
81137e1c:	283fe81e 	bne	r5,zero,81137dc0 <__reset+0xfb117dc0>
81137e20:	003ff806 	br	81137e04 <__reset+0xfb117e04>
81137e24:	313fee36 	bltu	r6,r4,81137de0 <__reset+0xfb117de0>
81137e28:	21bffc36 	bltu	r4,r6,81137e1c <__reset+0xfb117e1c>
81137e2c:	0005883a 	mov	r2,zero
81137e30:	f800283a 	ret

81137e34 <__floatunsidf>:
81137e34:	defffe04 	addi	sp,sp,-8
81137e38:	de00012e 	bgeu	sp,et,81137e40 <__floatunsidf+0xc>
81137e3c:	003b68fa 	trap	3
81137e40:	dc000015 	stw	r16,0(sp)
81137e44:	dfc00115 	stw	ra,4(sp)
81137e48:	2021883a 	mov	r16,r4
81137e4c:	20002226 	beq	r4,zero,81137ed8 <__floatunsidf+0xa4>
81137e50:	11230c80 	call	811230c8 <__clzsi2>
81137e54:	01010784 	movi	r4,1054
81137e58:	2089c83a 	sub	r4,r4,r2
81137e5c:	01810cc4 	movi	r6,1075
81137e60:	310dc83a 	sub	r6,r6,r4
81137e64:	00c007c4 	movi	r3,31
81137e68:	1980120e 	bge	r3,r6,81137eb4 <__floatunsidf+0x80>
81137e6c:	00c104c4 	movi	r3,1043
81137e70:	1907c83a 	sub	r3,r3,r4
81137e74:	80ca983a 	sll	r5,r16,r3
81137e78:	00800434 	movhi	r2,16
81137e7c:	10bfffc4 	addi	r2,r2,-1
81137e80:	2101ffcc 	andi	r4,r4,2047
81137e84:	0021883a 	mov	r16,zero
81137e88:	288a703a 	and	r5,r5,r2
81137e8c:	2008953a 	slli	r4,r4,20
81137e90:	00c00434 	movhi	r3,16
81137e94:	18ffffc4 	addi	r3,r3,-1
81137e98:	28c6703a 	and	r3,r5,r3
81137e9c:	8005883a 	mov	r2,r16
81137ea0:	1906b03a 	or	r3,r3,r4
81137ea4:	dfc00117 	ldw	ra,4(sp)
81137ea8:	dc000017 	ldw	r16,0(sp)
81137eac:	dec00204 	addi	sp,sp,8
81137eb0:	f800283a 	ret
81137eb4:	00c002c4 	movi	r3,11
81137eb8:	188bc83a 	sub	r5,r3,r2
81137ebc:	814ad83a 	srl	r5,r16,r5
81137ec0:	00c00434 	movhi	r3,16
81137ec4:	18ffffc4 	addi	r3,r3,-1
81137ec8:	81a0983a 	sll	r16,r16,r6
81137ecc:	2101ffcc 	andi	r4,r4,2047
81137ed0:	28ca703a 	and	r5,r5,r3
81137ed4:	003fed06 	br	81137e8c <__reset+0xfb117e8c>
81137ed8:	0009883a 	mov	r4,zero
81137edc:	000b883a 	mov	r5,zero
81137ee0:	003fea06 	br	81137e8c <__reset+0xfb117e8c>

81137ee4 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
81137ee4:	defffb04 	addi	sp,sp,-20
81137ee8:	de00012e 	bgeu	sp,et,81137ef0 <alt_busy_sleep+0xc>
81137eec:	003b68fa 	trap	3
81137ef0:	df000415 	stw	fp,16(sp)
81137ef4:	df000404 	addi	fp,sp,16
81137ef8:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
81137efc:	008000c4 	movi	r2,3
81137f00:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
81137f04:	e0fffd17 	ldw	r3,-12(fp)
81137f08:	008003f4 	movhi	r2,15
81137f0c:	10909004 	addi	r2,r2,16960
81137f10:	1887383a 	mul	r3,r3,r2
81137f14:	00817db4 	movhi	r2,1526
81137f18:	10b84004 	addi	r2,r2,-7936
81137f1c:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
81137f20:	00a00034 	movhi	r2,32768
81137f24:	10bfffc4 	addi	r2,r2,-1
81137f28:	10c5203a 	divu	r2,r2,r3
81137f2c:	e0ffff17 	ldw	r3,-4(fp)
81137f30:	1885203a 	divu	r2,r3,r2
81137f34:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
81137f38:	e0bffe17 	ldw	r2,-8(fp)
81137f3c:	10002526 	beq	r2,zero,81137fd4 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
81137f40:	e03ffc15 	stw	zero,-16(fp)
81137f44:	00001406 	br	81137f98 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
81137f48:	00a00034 	movhi	r2,32768
81137f4c:	10bfffc4 	addi	r2,r2,-1
81137f50:	10bfffc4 	addi	r2,r2,-1
81137f54:	103ffe1e 	bne	r2,zero,81137f50 <__reset+0xfb117f50>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
81137f58:	e0fffd17 	ldw	r3,-12(fp)
81137f5c:	008003f4 	movhi	r2,15
81137f60:	10909004 	addi	r2,r2,16960
81137f64:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81137f68:	00817db4 	movhi	r2,1526
81137f6c:	10b84004 	addi	r2,r2,-7936
81137f70:	10c7203a 	divu	r3,r2,r3
81137f74:	00a00034 	movhi	r2,32768
81137f78:	10bfffc4 	addi	r2,r2,-1
81137f7c:	10c5203a 	divu	r2,r2,r3
81137f80:	e0ffff17 	ldw	r3,-4(fp)
81137f84:	1885c83a 	sub	r2,r3,r2
81137f88:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
81137f8c:	e0bffc17 	ldw	r2,-16(fp)
81137f90:	10800044 	addi	r2,r2,1
81137f94:	e0bffc15 	stw	r2,-16(fp)
81137f98:	e0fffc17 	ldw	r3,-16(fp)
81137f9c:	e0bffe17 	ldw	r2,-8(fp)
81137fa0:	18bfe916 	blt	r3,r2,81137f48 <__reset+0xfb117f48>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81137fa4:	e0fffd17 	ldw	r3,-12(fp)
81137fa8:	008003f4 	movhi	r2,15
81137fac:	10909004 	addi	r2,r2,16960
81137fb0:	1887383a 	mul	r3,r3,r2
81137fb4:	00817db4 	movhi	r2,1526
81137fb8:	10b84004 	addi	r2,r2,-7936
81137fbc:	10c7203a 	divu	r3,r2,r3
81137fc0:	e0bfff17 	ldw	r2,-4(fp)
81137fc4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81137fc8:	10bfffc4 	addi	r2,r2,-1
81137fcc:	103ffe1e 	bne	r2,zero,81137fc8 <__reset+0xfb117fc8>
81137fd0:	00000b06 	br	81138000 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81137fd4:	e0fffd17 	ldw	r3,-12(fp)
81137fd8:	008003f4 	movhi	r2,15
81137fdc:	10909004 	addi	r2,r2,16960
81137fe0:	1887383a 	mul	r3,r3,r2
81137fe4:	00817db4 	movhi	r2,1526
81137fe8:	10b84004 	addi	r2,r2,-7936
81137fec:	10c7203a 	divu	r3,r2,r3
81137ff0:	e0bfff17 	ldw	r2,-4(fp)
81137ff4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81137ff8:	10bfffc4 	addi	r2,r2,-1
81137ffc:	00bffe16 	blt	zero,r2,81137ff8 <__reset+0xfb117ff8>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
81138000:	0005883a 	mov	r2,zero
}
81138004:	e037883a 	mov	sp,fp
81138008:	df000017 	ldw	fp,0(sp)
8113800c:	dec00104 	addi	sp,sp,4
81138010:	f800283a 	ret

81138014 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81138014:	defffe04 	addi	sp,sp,-8
81138018:	de00012e 	bgeu	sp,et,81138020 <alt_get_errno+0xc>
8113801c:	003b68fa 	trap	3
81138020:	dfc00115 	stw	ra,4(sp)
81138024:	df000015 	stw	fp,0(sp)
81138028:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113802c:	d0a01017 	ldw	r2,-32704(gp)
81138030:	10000326 	beq	r2,zero,81138040 <alt_get_errno+0x2c>
81138034:	d0a01017 	ldw	r2,-32704(gp)
81138038:	103ee83a 	callr	r2
8113803c:	00000106 	br	81138044 <alt_get_errno+0x30>
81138040:	d0a07804 	addi	r2,gp,-32288
}
81138044:	e037883a 	mov	sp,fp
81138048:	dfc00117 	ldw	ra,4(sp)
8113804c:	df000017 	ldw	fp,0(sp)
81138050:	dec00204 	addi	sp,sp,8
81138054:	f800283a 	ret

81138058 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81138058:	defffb04 	addi	sp,sp,-20
8113805c:	de00012e 	bgeu	sp,et,81138064 <close+0xc>
81138060:	003b68fa 	trap	3
81138064:	dfc00415 	stw	ra,16(sp)
81138068:	df000315 	stw	fp,12(sp)
8113806c:	df000304 	addi	fp,sp,12
81138070:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
81138074:	e0bfff17 	ldw	r2,-4(fp)
81138078:	10000616 	blt	r2,zero,81138094 <close+0x3c>
8113807c:	e0bfff17 	ldw	r2,-4(fp)
81138080:	10c00324 	muli	r3,r2,12
81138084:	00a04574 	movhi	r2,33045
81138088:	108e4804 	addi	r2,r2,14624
8113808c:	1885883a 	add	r2,r3,r2
81138090:	00000106 	br	81138098 <close+0x40>
81138094:	0005883a 	mov	r2,zero
81138098:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
8113809c:	e0bffd17 	ldw	r2,-12(fp)
811380a0:	10001926 	beq	r2,zero,81138108 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
811380a4:	e0bffd17 	ldw	r2,-12(fp)
811380a8:	10800017 	ldw	r2,0(r2)
811380ac:	10800417 	ldw	r2,16(r2)
811380b0:	10000626 	beq	r2,zero,811380cc <close+0x74>
811380b4:	e0bffd17 	ldw	r2,-12(fp)
811380b8:	10800017 	ldw	r2,0(r2)
811380bc:	10800417 	ldw	r2,16(r2)
811380c0:	e13ffd17 	ldw	r4,-12(fp)
811380c4:	103ee83a 	callr	r2
811380c8:	00000106 	br	811380d0 <close+0x78>
811380cc:	0005883a 	mov	r2,zero
811380d0:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
811380d4:	e13fff17 	ldw	r4,-4(fp)
811380d8:	113963c0 	call	8113963c <alt_release_fd>
    if (rval < 0)
811380dc:	e0bffe17 	ldw	r2,-8(fp)
811380e0:	1000070e 	bge	r2,zero,81138100 <close+0xa8>
    {
      ALT_ERRNO = -rval;
811380e4:	11380140 	call	81138014 <alt_get_errno>
811380e8:	1007883a 	mov	r3,r2
811380ec:	e0bffe17 	ldw	r2,-8(fp)
811380f0:	0085c83a 	sub	r2,zero,r2
811380f4:	18800015 	stw	r2,0(r3)
      return -1;
811380f8:	00bfffc4 	movi	r2,-1
811380fc:	00000706 	br	8113811c <close+0xc4>
    }
    return 0;
81138100:	0005883a 	mov	r2,zero
81138104:	00000506 	br	8113811c <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
81138108:	11380140 	call	81138014 <alt_get_errno>
8113810c:	1007883a 	mov	r3,r2
81138110:	00801444 	movi	r2,81
81138114:	18800015 	stw	r2,0(r3)
    return -1;
81138118:	00bfffc4 	movi	r2,-1
  }
}
8113811c:	e037883a 	mov	sp,fp
81138120:	dfc00117 	ldw	ra,4(sp)
81138124:	df000017 	ldw	fp,0(sp)
81138128:	dec00204 	addi	sp,sp,8
8113812c:	f800283a 	ret

81138130 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
81138130:	deffff04 	addi	sp,sp,-4
81138134:	de00012e 	bgeu	sp,et,8113813c <alt_dcache_flush_all+0xc>
81138138:	003b68fa 	trap	3
8113813c:	df000015 	stw	fp,0(sp)
81138140:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
81138144:	0001883a 	nop
81138148:	e037883a 	mov	sp,fp
8113814c:	df000017 	ldw	fp,0(sp)
81138150:	dec00104 	addi	sp,sp,4
81138154:	f800283a 	ret

81138158 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
81138158:	defffc04 	addi	sp,sp,-16
8113815c:	de00012e 	bgeu	sp,et,81138164 <alt_dev_null_write+0xc>
81138160:	003b68fa 	trap	3
81138164:	df000315 	stw	fp,12(sp)
81138168:	df000304 	addi	fp,sp,12
8113816c:	e13ffd15 	stw	r4,-12(fp)
81138170:	e17ffe15 	stw	r5,-8(fp)
81138174:	e1bfff15 	stw	r6,-4(fp)
  return len;
81138178:	e0bfff17 	ldw	r2,-4(fp)
}
8113817c:	e037883a 	mov	sp,fp
81138180:	df000017 	ldw	fp,0(sp)
81138184:	dec00104 	addi	sp,sp,4
81138188:	f800283a 	ret

8113818c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113818c:	defffe04 	addi	sp,sp,-8
81138190:	de00012e 	bgeu	sp,et,81138198 <alt_get_errno+0xc>
81138194:	003b68fa 	trap	3
81138198:	dfc00115 	stw	ra,4(sp)
8113819c:	df000015 	stw	fp,0(sp)
811381a0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811381a4:	d0a01017 	ldw	r2,-32704(gp)
811381a8:	10000326 	beq	r2,zero,811381b8 <alt_get_errno+0x2c>
811381ac:	d0a01017 	ldw	r2,-32704(gp)
811381b0:	103ee83a 	callr	r2
811381b4:	00000106 	br	811381bc <alt_get_errno+0x30>
811381b8:	d0a07804 	addi	r2,gp,-32288
}
811381bc:	e037883a 	mov	sp,fp
811381c0:	dfc00117 	ldw	ra,4(sp)
811381c4:	df000017 	ldw	fp,0(sp)
811381c8:	dec00204 	addi	sp,sp,8
811381cc:	f800283a 	ret

811381d0 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
811381d0:	defffb04 	addi	sp,sp,-20
811381d4:	de00012e 	bgeu	sp,et,811381dc <fstat+0xc>
811381d8:	003b68fa 	trap	3
811381dc:	dfc00415 	stw	ra,16(sp)
811381e0:	df000315 	stw	fp,12(sp)
811381e4:	df000304 	addi	fp,sp,12
811381e8:	e13ffe15 	stw	r4,-8(fp)
811381ec:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811381f0:	e0bffe17 	ldw	r2,-8(fp)
811381f4:	10000616 	blt	r2,zero,81138210 <fstat+0x40>
811381f8:	e0bffe17 	ldw	r2,-8(fp)
811381fc:	10c00324 	muli	r3,r2,12
81138200:	00a04574 	movhi	r2,33045
81138204:	108e4804 	addi	r2,r2,14624
81138208:	1885883a 	add	r2,r3,r2
8113820c:	00000106 	br	81138214 <fstat+0x44>
81138210:	0005883a 	mov	r2,zero
81138214:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
81138218:	e0bffd17 	ldw	r2,-12(fp)
8113821c:	10001026 	beq	r2,zero,81138260 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
81138220:	e0bffd17 	ldw	r2,-12(fp)
81138224:	10800017 	ldw	r2,0(r2)
81138228:	10800817 	ldw	r2,32(r2)
8113822c:	10000726 	beq	r2,zero,8113824c <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
81138230:	e0bffd17 	ldw	r2,-12(fp)
81138234:	10800017 	ldw	r2,0(r2)
81138238:	10800817 	ldw	r2,32(r2)
8113823c:	e17fff17 	ldw	r5,-4(fp)
81138240:	e13ffd17 	ldw	r4,-12(fp)
81138244:	103ee83a 	callr	r2
81138248:	00000a06 	br	81138274 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
8113824c:	e0bfff17 	ldw	r2,-4(fp)
81138250:	00c80004 	movi	r3,8192
81138254:	10c00115 	stw	r3,4(r2)
      return 0;
81138258:	0005883a 	mov	r2,zero
8113825c:	00000506 	br	81138274 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81138260:	113818c0 	call	8113818c <alt_get_errno>
81138264:	1007883a 	mov	r3,r2
81138268:	00801444 	movi	r2,81
8113826c:	18800015 	stw	r2,0(r3)
    return -1;
81138270:	00bfffc4 	movi	r2,-1
  }
}
81138274:	e037883a 	mov	sp,fp
81138278:	dfc00117 	ldw	ra,4(sp)
8113827c:	df000017 	ldw	fp,0(sp)
81138280:	dec00204 	addi	sp,sp,8
81138284:	f800283a 	ret

81138288 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
81138288:	defff004 	addi	sp,sp,-64
8113828c:	de00012e 	bgeu	sp,et,81138294 <alt_irq_register+0xc>
81138290:	003b68fa 	trap	3
81138294:	df000f15 	stw	fp,60(sp)
81138298:	df000f04 	addi	fp,sp,60
8113829c:	e13ffd15 	stw	r4,-12(fp)
811382a0:	e17ffe15 	stw	r5,-8(fp)
811382a4:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
811382a8:	00bffa84 	movi	r2,-22
811382ac:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
811382b0:	e0bffd17 	ldw	r2,-12(fp)
811382b4:	10800828 	cmpgeui	r2,r2,32
811382b8:	1000501e 	bne	r2,zero,811383fc <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811382bc:	0005303a 	rdctl	r2,status
811382c0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811382c4:	e0fff617 	ldw	r3,-40(fp)
811382c8:	00bfff84 	movi	r2,-2
811382cc:	1884703a 	and	r2,r3,r2
811382d0:	1001703a 	wrctl	status,r2
  
  return context;
811382d4:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
811382d8:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
811382dc:	00a045f4 	movhi	r2,33047
811382e0:	10bbed04 	addi	r2,r2,-4172
811382e4:	e0fffd17 	ldw	r3,-12(fp)
811382e8:	180690fa 	slli	r3,r3,3
811382ec:	10c5883a 	add	r2,r2,r3
811382f0:	e0ffff17 	ldw	r3,-4(fp)
811382f4:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
811382f8:	00a045f4 	movhi	r2,33047
811382fc:	10bbed04 	addi	r2,r2,-4172
81138300:	e0fffd17 	ldw	r3,-12(fp)
81138304:	180690fa 	slli	r3,r3,3
81138308:	10c5883a 	add	r2,r2,r3
8113830c:	10800104 	addi	r2,r2,4
81138310:	e0fffe17 	ldw	r3,-8(fp)
81138314:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
81138318:	e0bfff17 	ldw	r2,-4(fp)
8113831c:	10001926 	beq	r2,zero,81138384 <alt_irq_register+0xfc>
81138320:	e0bffd17 	ldw	r2,-12(fp)
81138324:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138328:	0005303a 	rdctl	r2,status
8113832c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138330:	e0fff717 	ldw	r3,-36(fp)
81138334:	00bfff84 	movi	r2,-2
81138338:	1884703a 	and	r2,r3,r2
8113833c:	1001703a 	wrctl	status,r2
  
  return context;
81138340:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81138344:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
81138348:	00c00044 	movi	r3,1
8113834c:	e0bff217 	ldw	r2,-56(fp)
81138350:	1884983a 	sll	r2,r3,r2
81138354:	1007883a 	mov	r3,r2
81138358:	d0a08017 	ldw	r2,-32256(gp)
8113835c:	1884b03a 	or	r2,r3,r2
81138360:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81138364:	d0a08017 	ldw	r2,-32256(gp)
81138368:	100170fa 	wrctl	ienable,r2
8113836c:	e0bff817 	ldw	r2,-32(fp)
81138370:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138374:	e0bff917 	ldw	r2,-28(fp)
81138378:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8113837c:	0005883a 	mov	r2,zero
81138380:	00001906 	br	811383e8 <alt_irq_register+0x160>
81138384:	e0bffd17 	ldw	r2,-12(fp)
81138388:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113838c:	0005303a 	rdctl	r2,status
81138390:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138394:	e0fffa17 	ldw	r3,-24(fp)
81138398:	00bfff84 	movi	r2,-2
8113839c:	1884703a 	and	r2,r3,r2
811383a0:	1001703a 	wrctl	status,r2
  
  return context;
811383a4:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811383a8:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
811383ac:	00c00044 	movi	r3,1
811383b0:	e0bff417 	ldw	r2,-48(fp)
811383b4:	1884983a 	sll	r2,r3,r2
811383b8:	0084303a 	nor	r2,zero,r2
811383bc:	1007883a 	mov	r3,r2
811383c0:	d0a08017 	ldw	r2,-32256(gp)
811383c4:	1884703a 	and	r2,r3,r2
811383c8:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811383cc:	d0a08017 	ldw	r2,-32256(gp)
811383d0:	100170fa 	wrctl	ienable,r2
811383d4:	e0bffb17 	ldw	r2,-20(fp)
811383d8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811383dc:	e0bffc17 	ldw	r2,-16(fp)
811383e0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811383e4:	0005883a 	mov	r2,zero
811383e8:	e0bff115 	stw	r2,-60(fp)
811383ec:	e0bff317 	ldw	r2,-52(fp)
811383f0:	e0bff515 	stw	r2,-44(fp)
811383f4:	e0bff517 	ldw	r2,-44(fp)
811383f8:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
811383fc:	e0bff117 	ldw	r2,-60(fp)
}
81138400:	e037883a 	mov	sp,fp
81138404:	df000017 	ldw	fp,0(sp)
81138408:	dec00104 	addi	sp,sp,4
8113840c:	f800283a 	ret

81138410 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81138410:	defffe04 	addi	sp,sp,-8
81138414:	de00012e 	bgeu	sp,et,8113841c <alt_get_errno+0xc>
81138418:	003b68fa 	trap	3
8113841c:	dfc00115 	stw	ra,4(sp)
81138420:	df000015 	stw	fp,0(sp)
81138424:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81138428:	d0a01017 	ldw	r2,-32704(gp)
8113842c:	10000326 	beq	r2,zero,8113843c <alt_get_errno+0x2c>
81138430:	d0a01017 	ldw	r2,-32704(gp)
81138434:	103ee83a 	callr	r2
81138438:	00000106 	br	81138440 <alt_get_errno+0x30>
8113843c:	d0a07804 	addi	r2,gp,-32288
}
81138440:	e037883a 	mov	sp,fp
81138444:	dfc00117 	ldw	ra,4(sp)
81138448:	df000017 	ldw	fp,0(sp)
8113844c:	dec00204 	addi	sp,sp,8
81138450:	f800283a 	ret

81138454 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
81138454:	deffed04 	addi	sp,sp,-76
81138458:	de00012e 	bgeu	sp,et,81138460 <isatty+0xc>
8113845c:	003b68fa 	trap	3
81138460:	dfc01215 	stw	ra,72(sp)
81138464:	df001115 	stw	fp,68(sp)
81138468:	df001104 	addi	fp,sp,68
8113846c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81138470:	e0bfff17 	ldw	r2,-4(fp)
81138474:	10000616 	blt	r2,zero,81138490 <isatty+0x3c>
81138478:	e0bfff17 	ldw	r2,-4(fp)
8113847c:	10c00324 	muli	r3,r2,12
81138480:	00a04574 	movhi	r2,33045
81138484:	108e4804 	addi	r2,r2,14624
81138488:	1885883a 	add	r2,r3,r2
8113848c:	00000106 	br	81138494 <isatty+0x40>
81138490:	0005883a 	mov	r2,zero
81138494:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
81138498:	e0bfef17 	ldw	r2,-68(fp)
8113849c:	10000e26 	beq	r2,zero,811384d8 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
811384a0:	e0bfef17 	ldw	r2,-68(fp)
811384a4:	10800017 	ldw	r2,0(r2)
811384a8:	10800817 	ldw	r2,32(r2)
811384ac:	1000021e 	bne	r2,zero,811384b8 <isatty+0x64>
    {
      return 1;
811384b0:	00800044 	movi	r2,1
811384b4:	00000d06 	br	811384ec <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
811384b8:	e0bff004 	addi	r2,fp,-64
811384bc:	100b883a 	mov	r5,r2
811384c0:	e13fff17 	ldw	r4,-4(fp)
811384c4:	11381d00 	call	811381d0 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
811384c8:	e0bff117 	ldw	r2,-60(fp)
811384cc:	10880020 	cmpeqi	r2,r2,8192
811384d0:	10803fcc 	andi	r2,r2,255
811384d4:	00000506 	br	811384ec <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
811384d8:	11384100 	call	81138410 <alt_get_errno>
811384dc:	1007883a 	mov	r3,r2
811384e0:	00801444 	movi	r2,81
811384e4:	18800015 	stw	r2,0(r3)
    return 0;
811384e8:	0005883a 	mov	r2,zero
  }
}
811384ec:	e037883a 	mov	sp,fp
811384f0:	dfc00117 	ldw	ra,4(sp)
811384f4:	df000017 	ldw	fp,0(sp)
811384f8:	dec00204 	addi	sp,sp,8
811384fc:	f800283a 	ret

81138500 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
81138500:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
81138504:	318c2404 	addi	r6,r6,12432

81138508 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
81138508:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
8113850c:	01c00826 	beq	zero,r7,81138530 <end_tx>

81138510 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
81138510:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
81138514:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
81138518:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
8113851c:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
81138520:	283ffb26 	beq	r5,zero,81138510 <__reset+0xfb118510>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
81138524:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
81138528:	21000044 	addi	r4,r4,1
	br tx_next_char
8113852c:	003ff606 	br	81138508 <__reset+0xfb118508>

81138530 <end_tx>:
end_tx:	
        ret
81138530:	f800283a 	ret

81138534 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
81138534:	defffd04 	addi	sp,sp,-12
81138538:	de00012e 	bgeu	sp,et,81138540 <alt_log_txchar+0xc>
8113853c:	003b68fa 	trap	3
81138540:	df000215 	stw	fp,8(sp)
81138544:	df000204 	addi	fp,sp,8
81138548:	e13ffe15 	stw	r4,-8(fp)
8113854c:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
81138550:	0001883a 	nop
81138554:	e0bfff17 	ldw	r2,-4(fp)
81138558:	10800104 	addi	r2,r2,4
8113855c:	10800037 	ldwio	r2,0(r2)
81138560:	10bfffec 	andhi	r2,r2,65535
81138564:	103ffb26 	beq	r2,zero,81138554 <__reset+0xfb118554>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81138568:	e0bfff17 	ldw	r2,-4(fp)
8113856c:	e0fffe17 	ldw	r3,-8(fp)
81138570:	10c00035 	stwio	r3,0(r2)
}
81138574:	0001883a 	nop
81138578:	e037883a 	mov	sp,fp
8113857c:	df000017 	ldw	fp,0(sp)
81138580:	dec00104 	addi	sp,sp,4
81138584:	f800283a 	ret

81138588 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
81138588:	defffb04 	addi	sp,sp,-20
8113858c:	de00012e 	bgeu	sp,et,81138594 <alt_log_repchar+0xc>
81138590:	003b68fa 	trap	3
81138594:	dfc00415 	stw	ra,16(sp)
81138598:	df000315 	stw	fp,12(sp)
8113859c:	df000304 	addi	fp,sp,12
811385a0:	2005883a 	mov	r2,r4
811385a4:	e17ffe15 	stw	r5,-8(fp)
811385a8:	e1bfff15 	stw	r6,-4(fp)
811385ac:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
811385b0:	00000506 	br	811385c8 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
811385b4:	e0bffd07 	ldb	r2,-12(fp)
811385b8:	e0ffff17 	ldw	r3,-4(fp)
811385bc:	180b883a 	mov	r5,r3
811385c0:	1009883a 	mov	r4,r2
811385c4:	11385340 	call	81138534 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
811385c8:	e0bffe17 	ldw	r2,-8(fp)
811385cc:	10ffffc4 	addi	r3,r2,-1
811385d0:	e0fffe15 	stw	r3,-8(fp)
811385d4:	00bff716 	blt	zero,r2,811385b4 <__reset+0xfb1185b4>
    alt_log_txchar(c,(char*) base);
}
811385d8:	0001883a 	nop
811385dc:	e037883a 	mov	sp,fp
811385e0:	dfc00117 	ldw	ra,4(sp)
811385e4:	df000017 	ldw	fp,0(sp)
811385e8:	dec00204 	addi	sp,sp,8
811385ec:	f800283a 	ret

811385f0 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
811385f0:	deffe904 	addi	sp,sp,-92
811385f4:	de00012e 	bgeu	sp,et,811385fc <alt_log_private_printf+0xc>
811385f8:	003b68fa 	trap	3
811385fc:	dfc01615 	stw	ra,88(sp)
81138600:	df001515 	stw	fp,84(sp)
81138604:	dc001415 	stw	r16,80(sp)
81138608:	df001504 	addi	fp,sp,84
8113860c:	e13ffc15 	stw	r4,-16(fp)
81138610:	e17ffd15 	stw	r5,-12(fp)
81138614:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
81138618:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
8113861c:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
81138620:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
81138624:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
81138628:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
8113862c:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
81138630:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
81138634:	e0bffc17 	ldw	r2,-16(fp)
81138638:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
8113863c:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
81138640:	00014b06 	br	81138b70 <alt_log_private_printf+0x580>
    {
    switch(state)
81138644:	e0bfec17 	ldw	r2,-80(fp)
81138648:	10c00060 	cmpeqi	r3,r2,1
8113864c:	18001b1e 	bne	r3,zero,811386bc <alt_log_private_printf+0xcc>
81138650:	10c000a0 	cmpeqi	r3,r2,2
81138654:	18002d1e 	bne	r3,zero,8113870c <alt_log_private_printf+0x11c>
81138658:	10000126 	beq	r2,zero,81138660 <alt_log_private_printf+0x70>
8113865c:	00014406 	br	81138b70 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
81138660:	e0bffb07 	ldb	r2,-20(fp)
81138664:	10800958 	cmpnei	r2,r2,37
81138668:	10000e1e 	bne	r2,zero,811386a4 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
8113866c:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81138670:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81138674:	00800284 	movi	r2,10
81138678:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
8113867c:	00800044 	movi	r2,1
81138680:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81138684:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
81138688:	00bfffc4 	movi	r2,-1
8113868c:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
81138690:	00bfffc4 	movi	r2,-1
81138694:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
81138698:	00800044 	movi	r2,1
8113869c:	e0bfec15 	stw	r2,-80(fp)
811386a0:	00013306 	br	81138b70 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
811386a4:	e0bffb07 	ldb	r2,-20(fp)
811386a8:	e0fffd17 	ldw	r3,-12(fp)
811386ac:	180b883a 	mov	r5,r3
811386b0:	1009883a 	mov	r4,r2
811386b4:	11385340 	call	81138534 <alt_log_txchar>
        }
        break;
811386b8:	00012d06 	br	81138b70 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
811386bc:	e0bffb07 	ldb	r2,-20(fp)
811386c0:	10800c18 	cmpnei	r2,r2,48
811386c4:	1000051e 	bne	r2,zero,811386dc <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
811386c8:	00800044 	movi	r2,1
811386cc:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
811386d0:	00800084 	movi	r2,2
811386d4:	e0bfec15 	stw	r2,-80(fp)
811386d8:	00012506 	br	81138b70 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
811386dc:	e0bffb07 	ldb	r2,-20(fp)
811386e0:	10800958 	cmpnei	r2,r2,37
811386e4:	1000071e 	bne	r2,zero,81138704 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
811386e8:	e0bffb07 	ldb	r2,-20(fp)
811386ec:	e0fffd17 	ldw	r3,-12(fp)
811386f0:	180b883a 	mov	r5,r3
811386f4:	1009883a 	mov	r4,r2
811386f8:	11385340 	call	81138534 <alt_log_txchar>
          state = pfState_chars;
811386fc:	e03fec15 	stw	zero,-80(fp)
81138700:	00011b06 	br	81138b70 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81138704:	00800084 	movi	r2,2
81138708:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
8113870c:	e0bffb07 	ldb	r2,-20(fp)
81138710:	10800b98 	cmpnei	r2,r2,46
81138714:	1000021e 	bne	r2,zero,81138720 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
81138718:	e03ff015 	stw	zero,-64(fp)
8113871c:	00011306 	br	81138b6c <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81138720:	e0bffb07 	ldb	r2,-20(fp)
81138724:	10800c10 	cmplti	r2,r2,48
81138728:	10001a1e 	bne	r2,zero,81138794 <alt_log_private_printf+0x1a4>
8113872c:	e0bffb07 	ldb	r2,-20(fp)
81138730:	10800e88 	cmpgei	r2,r2,58
81138734:	1000171e 	bne	r2,zero,81138794 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
81138738:	e0bffb03 	ldbu	r2,-20(fp)
8113873c:	10bff404 	addi	r2,r2,-48
81138740:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
81138744:	e0bff017 	ldw	r2,-64(fp)
81138748:	10000c0e 	bge	r2,zero,8113877c <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
8113874c:	e0bfef17 	ldw	r2,-68(fp)
81138750:	1000020e 	bge	r2,zero,8113875c <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
81138754:	e03fef15 	stw	zero,-68(fp)
81138758:	00000306 	br	81138768 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
8113875c:	e0bfef17 	ldw	r2,-68(fp)
81138760:	108002a4 	muli	r2,r2,10
81138764:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81138768:	e0bffb07 	ldb	r2,-20(fp)
8113876c:	e0ffef17 	ldw	r3,-68(fp)
81138770:	1885883a 	add	r2,r3,r2
81138774:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81138778:	0000fc06 	br	81138b6c <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
8113877c:	e0bff017 	ldw	r2,-64(fp)
81138780:	10c002a4 	muli	r3,r2,10
81138784:	e0bffb07 	ldb	r2,-20(fp)
81138788:	1885883a 	add	r2,r3,r2
8113878c:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81138790:	0000f606 	br	81138b6c <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
81138794:	e0bffb07 	ldb	r2,-20(fp)
81138798:	10801b18 	cmpnei	r2,r2,108
8113879c:	1000031e 	bne	r2,zero,811387ac <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
811387a0:	00800044 	movi	r2,1
811387a4:	e0bfee15 	stw	r2,-72(fp)
811387a8:	0000f006 	br	81138b6c <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
811387ac:	e0bffb07 	ldb	r2,-20(fp)
811387b0:	10bfea04 	addi	r2,r2,-88
811387b4:	10c00868 	cmpgeui	r3,r2,33
811387b8:	1800eb1e 	bne	r3,zero,81138b68 <alt_log_private_printf+0x578>
811387bc:	100690ba 	slli	r3,r2,2
811387c0:	00a04534 	movhi	r2,33044
811387c4:	10a1f504 	addi	r2,r2,-30764
811387c8:	1885883a 	add	r2,r3,r2
811387cc:	10800017 	ldw	r2,0(r2)
811387d0:	1000683a 	jmp	r2
811387d4:	81138a94 	ori	r4,r16,20010
811387d8:	81138b68 	cmpgeui	r4,r16,20013
811387dc:	81138b68 	cmpgeui	r4,r16,20013
811387e0:	81138b68 	cmpgeui	r4,r16,20013
811387e4:	81138b68 	cmpgeui	r4,r16,20013
811387e8:	81138b68 	cmpgeui	r4,r16,20013
811387ec:	81138b68 	cmpgeui	r4,r16,20013
811387f0:	81138b68 	cmpgeui	r4,r16,20013
811387f4:	81138b68 	cmpgeui	r4,r16,20013
811387f8:	81138b68 	cmpgeui	r4,r16,20013
811387fc:	81138b68 	cmpgeui	r4,r16,20013
81138800:	81138aac 	andhi	r4,r16,20010
81138804:	81138858 	cmpnei	r4,r16,20001
81138808:	81138b68 	cmpgeui	r4,r16,20013
8113880c:	81138b68 	cmpgeui	r4,r16,20013
81138810:	81138b68 	cmpgeui	r4,r16,20013
81138814:	81138b68 	cmpgeui	r4,r16,20013
81138818:	81138858 	cmpnei	r4,r16,20001
8113881c:	81138b68 	cmpgeui	r4,r16,20013
81138820:	81138b68 	cmpgeui	r4,r16,20013
81138824:	81138b68 	cmpgeui	r4,r16,20013
81138828:	81138b68 	cmpgeui	r4,r16,20013
8113882c:	81138b68 	cmpgeui	r4,r16,20013
81138830:	81138a74 	orhi	r4,r16,20009
81138834:	81138b68 	cmpgeui	r4,r16,20013
81138838:	81138b68 	cmpgeui	r4,r16,20013
8113883c:	81138b68 	cmpgeui	r4,r16,20013
81138840:	81138ae8 	cmpgeui	r4,r16,20011
81138844:	81138b68 	cmpgeui	r4,r16,20013
81138848:	81138a6c 	andhi	r4,r16,20009
8113884c:	81138b68 	cmpgeui	r4,r16,20013
81138850:	81138b68 	cmpgeui	r4,r16,20013
81138854:	81138a84 	addi	r4,r16,20010
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
81138858:	e0bfee17 	ldw	r2,-72(fp)
8113885c:	10000e26 	beq	r2,zero,81138898 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
81138860:	e0bff217 	ldw	r2,-56(fp)
81138864:	10000626 	beq	r2,zero,81138880 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81138868:	e0bffe17 	ldw	r2,-8(fp)
8113886c:	10c00104 	addi	r3,r2,4
81138870:	e0fffe15 	stw	r3,-8(fp)
81138874:	10800017 	ldw	r2,0(r2)
81138878:	e0bff415 	stw	r2,-48(fp)
8113887c:	00001306 	br	811388cc <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
81138880:	e0bffe17 	ldw	r2,-8(fp)
81138884:	10c00104 	addi	r3,r2,4
81138888:	e0fffe15 	stw	r3,-8(fp)
8113888c:	10800017 	ldw	r2,0(r2)
81138890:	e0bff415 	stw	r2,-48(fp)
81138894:	00000d06 	br	811388cc <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
81138898:	e0bff217 	ldw	r2,-56(fp)
8113889c:	10000626 	beq	r2,zero,811388b8 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
811388a0:	e0bffe17 	ldw	r2,-8(fp)
811388a4:	10c00104 	addi	r3,r2,4
811388a8:	e0fffe15 	stw	r3,-8(fp)
811388ac:	10800017 	ldw	r2,0(r2)
811388b0:	e0bff415 	stw	r2,-48(fp)
811388b4:	00000506 	br	811388cc <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
811388b8:	e0bffe17 	ldw	r2,-8(fp)
811388bc:	10c00104 	addi	r3,r2,4
811388c0:	e0fffe15 	stw	r3,-8(fp)
811388c4:	10800017 	ldw	r2,0(r2)
811388c8:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
811388cc:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
811388d0:	e0bff217 	ldw	r2,-56(fp)
811388d4:	10000726 	beq	r2,zero,811388f4 <alt_log_private_printf+0x304>
811388d8:	e0bff417 	ldw	r2,-48(fp)
811388dc:	1000050e 	bge	r2,zero,811388f4 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
811388e0:	e0bff417 	ldw	r2,-48(fp)
811388e4:	0085c83a 	sub	r2,zero,r2
811388e8:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
811388ec:	00800044 	movi	r2,1
811388f0:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
811388f4:	e0bff417 	ldw	r2,-48(fp)
811388f8:	e0bff615 	stw	r2,-40(fp)
                p = 1;
811388fc:	00800044 	movi	r2,1
81138900:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81138904:	00800044 	movi	r2,1
81138908:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
8113890c:	00000706 	br	8113892c <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81138910:	e0bff817 	ldw	r2,-32(fp)
81138914:	10800044 	addi	r2,r2,1
81138918:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
8113891c:	e0bff117 	ldw	r2,-60(fp)
81138920:	e0fff517 	ldw	r3,-44(fp)
81138924:	1885383a 	mul	r2,r3,r2
81138928:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
8113892c:	e0bff117 	ldw	r2,-60(fp)
81138930:	e0fff617 	ldw	r3,-40(fp)
81138934:	1885203a 	divu	r2,r3,r2
81138938:	e0bff615 	stw	r2,-40(fp)
8113893c:	e0bff617 	ldw	r2,-40(fp)
81138940:	103ff31e 	bne	r2,zero,81138910 <__reset+0xfb118910>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
81138944:	e0ffef17 	ldw	r3,-68(fp)
81138948:	e0bff817 	ldw	r2,-32(fp)
8113894c:	1885c83a 	sub	r2,r3,r2
81138950:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
81138954:	e0bfed17 	ldw	r2,-76(fp)
81138958:	10000e26 	beq	r2,zero,81138994 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
8113895c:	e0bff717 	ldw	r2,-36(fp)
81138960:	10000726 	beq	r2,zero,81138980 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
81138964:	e0bffd17 	ldw	r2,-12(fp)
81138968:	100b883a 	mov	r5,r2
8113896c:	01000b44 	movi	r4,45
81138970:	11385340 	call	81138534 <alt_log_txchar>
                    fmtBeforeDecimal--;
81138974:	e0bfef17 	ldw	r2,-68(fp)
81138978:	10bfffc4 	addi	r2,r2,-1
8113897c:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81138980:	e1bffd17 	ldw	r6,-12(fp)
81138984:	e17fef17 	ldw	r5,-68(fp)
81138988:	01000c04 	movi	r4,48
8113898c:	11385880 	call	81138588 <alt_log_repchar>
81138990:	00003206 	br	81138a5c <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
81138994:	e0bff717 	ldw	r2,-36(fp)
81138998:	10000326 	beq	r2,zero,811389a8 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
8113899c:	e0bfef17 	ldw	r2,-68(fp)
811389a0:	10bfffc4 	addi	r2,r2,-1
811389a4:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
811389a8:	e1bffd17 	ldw	r6,-12(fp)
811389ac:	e17fef17 	ldw	r5,-68(fp)
811389b0:	01000804 	movi	r4,32
811389b4:	11385880 	call	81138588 <alt_log_repchar>
                    if(sign)
811389b8:	e0bff717 	ldw	r2,-36(fp)
811389bc:	10002726 	beq	r2,zero,81138a5c <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
811389c0:	e0bffd17 	ldw	r2,-12(fp)
811389c4:	100b883a 	mov	r5,r2
811389c8:	01000b44 	movi	r4,45
811389cc:	11385340 	call	81138534 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
811389d0:	00002206 	br	81138a5c <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
811389d4:	e0fff417 	ldw	r3,-48(fp)
811389d8:	e0bff517 	ldw	r2,-44(fp)
811389dc:	1885203a 	divu	r2,r3,r2
811389e0:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
811389e4:	e0bff903 	ldbu	r2,-28(fp)
811389e8:	10800c04 	addi	r2,r2,48
811389ec:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
811389f0:	e0bff903 	ldbu	r2,-28(fp)
811389f4:	10800eb0 	cmpltui	r2,r2,58
811389f8:	1000081e 	bne	r2,zero,81138a1c <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
811389fc:	e0bff317 	ldw	r2,-52(fp)
81138a00:	10000226 	beq	r2,zero,81138a0c <alt_log_private_printf+0x41c>
81138a04:	008001c4 	movi	r2,7
81138a08:	00000106 	br	81138a10 <alt_log_private_printf+0x420>
81138a0c:	008009c4 	movi	r2,39
81138a10:	e0fff903 	ldbu	r3,-28(fp)
81138a14:	10c5883a 	add	r2,r2,r3
81138a18:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
81138a1c:	e0bff903 	ldbu	r2,-28(fp)
81138a20:	e0fffd17 	ldw	r3,-12(fp)
81138a24:	180b883a 	mov	r5,r3
81138a28:	1009883a 	mov	r4,r2
81138a2c:	11385340 	call	81138534 <alt_log_txchar>

                  v = v % p;
81138a30:	e0bff417 	ldw	r2,-48(fp)
81138a34:	e0fff517 	ldw	r3,-44(fp)
81138a38:	10c9203a 	divu	r4,r2,r3
81138a3c:	e0fff517 	ldw	r3,-44(fp)
81138a40:	20c7383a 	mul	r3,r4,r3
81138a44:	10c5c83a 	sub	r2,r2,r3
81138a48:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
81138a4c:	e0bff117 	ldw	r2,-60(fp)
81138a50:	e0fff517 	ldw	r3,-44(fp)
81138a54:	1885203a 	divu	r2,r3,r2
81138a58:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
81138a5c:	e0bff517 	ldw	r2,-44(fp)
81138a60:	103fdc1e 	bne	r2,zero,811389d4 <__reset+0xfb1189d4>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
81138a64:	e03fec15 	stw	zero,-80(fp)
              break;
81138a68:	00003f06 	br	81138b68 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
81138a6c:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
81138a70:	003f7906 	br	81138858 <__reset+0xfb118858>
            case 'o':
              fmtSigned = 0;
81138a74:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81138a78:	00800204 	movi	r2,8
81138a7c:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81138a80:	003f7506 	br	81138858 <__reset+0xfb118858>
            case 'x':
              fmtSigned = 0;
81138a84:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81138a88:	00800404 	movi	r2,16
81138a8c:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81138a90:	003f7106 	br	81138858 <__reset+0xfb118858>
            case 'X':
              fmtSigned = 0;
81138a94:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81138a98:	00800404 	movi	r2,16
81138a9c:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81138aa0:	00800044 	movi	r2,1
81138aa4:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81138aa8:	003f6b06 	br	81138858 <__reset+0xfb118858>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81138aac:	e0bfef17 	ldw	r2,-68(fp)
81138ab0:	10bfffc4 	addi	r2,r2,-1
81138ab4:	e1bffd17 	ldw	r6,-12(fp)
81138ab8:	100b883a 	mov	r5,r2
81138abc:	01000804 	movi	r4,32
81138ac0:	11385880 	call	81138588 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
81138ac4:	e0bffe17 	ldw	r2,-8(fp)
81138ac8:	10c00104 	addi	r3,r2,4
81138acc:	e0fffe15 	stw	r3,-8(fp)
81138ad0:	10800017 	ldw	r2,0(r2)
81138ad4:	e0fffd17 	ldw	r3,-12(fp)
81138ad8:	180b883a 	mov	r5,r3
81138adc:	1009883a 	mov	r4,r2
81138ae0:	11385340 	call	81138534 <alt_log_txchar>
              break;
81138ae4:	00002006 	br	81138b68 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
81138ae8:	e0bffe17 	ldw	r2,-8(fp)
81138aec:	10c00104 	addi	r3,r2,4
81138af0:	e0fffe15 	stw	r3,-8(fp)
81138af4:	10800017 	ldw	r2,0(r2)
81138af8:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
81138afc:	e43fef17 	ldw	r16,-68(fp)
81138b00:	e13ffa17 	ldw	r4,-24(fp)
81138b04:	1124dc80 	call	81124dc8 <strlen>
81138b08:	8085c83a 	sub	r2,r16,r2
81138b0c:	e1bffd17 	ldw	r6,-12(fp)
81138b10:	100b883a 	mov	r5,r2
81138b14:	01000804 	movi	r4,32
81138b18:	11385880 	call	81138588 <alt_log_repchar>

                while(*s)
81138b1c:	00000b06 	br	81138b4c <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81138b20:	e0bffa17 	ldw	r2,-24(fp)
81138b24:	10c00044 	addi	r3,r2,1
81138b28:	e0fffa15 	stw	r3,-24(fp)
81138b2c:	10800003 	ldbu	r2,0(r2)
81138b30:	10803fcc 	andi	r2,r2,255
81138b34:	1080201c 	xori	r2,r2,128
81138b38:	10bfe004 	addi	r2,r2,-128
81138b3c:	e0fffd17 	ldw	r3,-12(fp)
81138b40:	180b883a 	mov	r5,r3
81138b44:	1009883a 	mov	r4,r2
81138b48:	11385340 	call	81138534 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
81138b4c:	e0bffa17 	ldw	r2,-24(fp)
81138b50:	10800003 	ldbu	r2,0(r2)
81138b54:	10803fcc 	andi	r2,r2,255
81138b58:	1080201c 	xori	r2,r2,128
81138b5c:	10bfe004 	addi	r2,r2,-128
81138b60:	103fef1e 	bne	r2,zero,81138b20 <__reset+0xfb118b20>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
81138b64:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
81138b68:	e03fec15 	stw	zero,-80(fp)
          }
        break;
81138b6c:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
81138b70:	e0bfeb17 	ldw	r2,-84(fp)
81138b74:	10c00044 	addi	r3,r2,1
81138b78:	e0ffeb15 	stw	r3,-84(fp)
81138b7c:	10800003 	ldbu	r2,0(r2)
81138b80:	e0bffb05 	stb	r2,-20(fp)
81138b84:	e0bffb07 	ldb	r2,-20(fp)
81138b88:	103eae1e 	bne	r2,zero,81138644 <__reset+0xfb118644>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
81138b8c:	0001883a 	nop
81138b90:	e6ffff04 	addi	sp,fp,-4
81138b94:	dfc00217 	ldw	ra,8(sp)
81138b98:	df000117 	ldw	fp,4(sp)
81138b9c:	dc000017 	ldw	r16,0(sp)
81138ba0:	dec00304 	addi	sp,sp,12
81138ba4:	f800283a 	ret

81138ba8 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81138ba8:	defff904 	addi	sp,sp,-28
81138bac:	de00012e 	bgeu	sp,et,81138bb4 <alt_log_printf_proc+0xc>
81138bb0:	003b68fa 	trap	3
81138bb4:	dfc00315 	stw	ra,12(sp)
81138bb8:	df000215 	stw	fp,8(sp)
81138bbc:	df000204 	addi	fp,sp,8
81138bc0:	e13fff15 	stw	r4,-4(fp)
81138bc4:	e1400215 	stw	r5,8(fp)
81138bc8:	e1800315 	stw	r6,12(fp)
81138bcc:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
81138bd0:	e0800204 	addi	r2,fp,8
81138bd4:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
81138bd8:	e0bffe17 	ldw	r2,-8(fp)
81138bdc:	100d883a 	mov	r6,r2
81138be0:	01604834 	movhi	r5,33056
81138be4:	294c2404 	addi	r5,r5,12432
81138be8:	e13fff17 	ldw	r4,-4(fp)
81138bec:	11385f00 	call	811385f0 <alt_log_private_printf>
    return (0);
81138bf0:	0005883a 	mov	r2,zero
}
81138bf4:	e037883a 	mov	sp,fp
81138bf8:	dfc00117 	ldw	ra,4(sp)
81138bfc:	df000017 	ldw	fp,0(sp)
81138c00:	dec00504 	addi	sp,sp,20
81138c04:	f800283a 	ret

81138c08 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
81138c08:	defff904 	addi	sp,sp,-28
81138c0c:	de00012e 	bgeu	sp,et,81138c14 <altera_avalon_jtag_uart_report_log+0xc>
81138c10:	003b68fa 	trap	3
81138c14:	dfc00615 	stw	ra,24(sp)
81138c18:	df000515 	stw	fp,20(sp)
81138c1c:	dc400415 	stw	r17,16(sp)
81138c20:	dc000315 	stw	r16,12(sp)
81138c24:	df000504 	addi	fp,sp,20
81138c28:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
81138c2c:	d0a08183 	ldbu	r2,-32250(gp)
81138c30:	10803fcc 	andi	r2,r2,255
81138c34:	10001426 	beq	r2,zero,81138c88 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
81138c38:	e0bffd17 	ldw	r2,-12(fp)
81138c3c:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
81138c40:	00a04574 	movhi	r2,33045
81138c44:	108a6e04 	addi	r2,r2,10680
81138c48:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
81138c4c:	e0bffb17 	ldw	r2,-20(fp)
81138c50:	10800017 	ldw	r2,0(r2)
81138c54:	e1bffc17 	ldw	r6,-16(fp)
81138c58:	100b883a 	mov	r5,r2
81138c5c:	e13ffb17 	ldw	r4,-20(fp)
81138c60:	1138ca80 	call	81138ca8 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81138c64:	d0e08817 	ldw	r3,-32224(gp)
        return ALT_LOG_JTAG_UART_TICKS;
81138c68:	00b33374 	movhi	r2,52429
81138c6c:	10b33344 	addi	r2,r2,-13107
81138c70:	1888383a 	mulxuu	r4,r3,r2
81138c74:	1885383a 	mul	r2,r3,r2
81138c78:	1021883a 	mov	r16,r2
81138c7c:	2023883a 	mov	r17,r4
81138c80:	8804d0fa 	srli	r2,r17,3
81138c84:	00000106 	br	81138c8c <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
81138c88:	0005883a 	mov	r2,zero
    }
}
81138c8c:	e6fffe04 	addi	sp,fp,-8
81138c90:	dfc00317 	ldw	ra,12(sp)
81138c94:	df000217 	ldw	fp,8(sp)
81138c98:	dc400117 	ldw	r17,4(sp)
81138c9c:	dc000017 	ldw	r16,0(sp)
81138ca0:	dec00404 	addi	sp,sp,16
81138ca4:	f800283a 	ret

81138ca8 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81138ca8:	deffef04 	addi	sp,sp,-68
81138cac:	de00012e 	bgeu	sp,et,81138cb4 <alt_log_jtag_uart_print_control_reg+0xc>
81138cb0:	003b68fa 	trap	3
81138cb4:	dfc01015 	stw	ra,64(sp)
81138cb8:	df000f15 	stw	fp,60(sp)
81138cbc:	df000f04 	addi	fp,sp,60
81138cc0:	e13ffd15 	stw	r4,-12(fp)
81138cc4:	e17ffe15 	stw	r5,-8(fp)
81138cc8:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81138ccc:	e0bffe17 	ldw	r2,-8(fp)
81138cd0:	10800104 	addi	r2,r2,4
81138cd4:	10800037 	ldwio	r2,0(r2)
81138cd8:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
81138cdc:	e0bff617 	ldw	r2,-40(fp)
81138ce0:	1004d43a 	srli	r2,r2,16
81138ce4:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
81138ce8:	e0bff617 	ldw	r2,-40(fp)
81138cec:	1080008c 	andi	r2,r2,2
81138cf0:	1004d07a 	srli	r2,r2,1
81138cf4:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
81138cf8:	e0bff617 	ldw	r2,-40(fp)
81138cfc:	1080004c 	andi	r2,r2,1
81138d00:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
81138d04:	e0bff617 	ldw	r2,-40(fp)
81138d08:	1080400c 	andi	r2,r2,256
81138d0c:	1004d23a 	srli	r2,r2,8
81138d10:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
81138d14:	e0bff617 	ldw	r2,-40(fp)
81138d18:	1080800c 	andi	r2,r2,512
81138d1c:	1004d27a 	srli	r2,r2,9
81138d20:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
81138d24:	e0bff617 	ldw	r2,-40(fp)
81138d28:	1081000c 	andi	r2,r2,1024
81138d2c:	1004d2ba 	srli	r2,r2,10
81138d30:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
81138d34:	e0bffd17 	ldw	r2,-12(fp)
81138d38:	10c01017 	ldw	r3,64(r2)
81138d3c:	e0bffd17 	ldw	r2,-12(fp)
81138d40:	10800f17 	ldw	r2,60(r2)
81138d44:	1887c83a 	sub	r3,r3,r2
81138d48:	e0bff917 	ldw	r2,-28(fp)
81138d4c:	d8800415 	stw	r2,16(sp)
81138d50:	e0bff817 	ldw	r2,-32(fp)
81138d54:	d8800315 	stw	r2,12(sp)
81138d58:	e0bffa17 	ldw	r2,-24(fp)
81138d5c:	d8800215 	stw	r2,8(sp)
81138d60:	e0bffb17 	ldw	r2,-20(fp)
81138d64:	d8800115 	stw	r2,4(sp)
81138d68:	e0bffc17 	ldw	r2,-16(fp)
81138d6c:	d8800015 	stw	r2,0(sp)
81138d70:	e1fff717 	ldw	r7,-36(fp)
81138d74:	180d883a 	mov	r6,r3
81138d78:	e17fff17 	ldw	r5,-4(fp)
81138d7c:	01204574 	movhi	r4,33045
81138d80:	210a7104 	addi	r4,r4,10692
81138d84:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81138d88:	0001883a 	nop

}
81138d8c:	e037883a 	mov	sp,fp
81138d90:	dfc00117 	ldw	ra,4(sp)
81138d94:	df000017 	ldw	fp,0(sp)
81138d98:	dec00204 	addi	sp,sp,8
81138d9c:	f800283a 	ret

81138da0 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
81138da0:	defffb04 	addi	sp,sp,-20
81138da4:	de00012e 	bgeu	sp,et,81138dac <alt_log_jtag_uart_startup_info+0xc>
81138da8:	003b68fa 	trap	3
81138dac:	dfc00415 	stw	ra,16(sp)
81138db0:	df000315 	stw	fp,12(sp)
81138db4:	df000304 	addi	fp,sp,12
81138db8:	e13ffe15 	stw	r4,-8(fp)
81138dbc:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
81138dc0:	00a04574 	movhi	r2,33045
81138dc4:	108a8304 	addi	r2,r2,10764
81138dc8:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
81138dcc:	e1bffd17 	ldw	r6,-12(fp)
81138dd0:	e17fff17 	ldw	r5,-4(fp)
81138dd4:	e13ffe17 	ldw	r4,-8(fp)
81138dd8:	1138ca80 	call	81138ca8 <alt_log_jtag_uart_print_control_reg>
     return;
81138ddc:	0001883a 	nop
}
81138de0:	e037883a 	mov	sp,fp
81138de4:	dfc00117 	ldw	ra,4(sp)
81138de8:	df000017 	ldw	fp,0(sp)
81138dec:	dec00204 	addi	sp,sp,8
81138df0:	f800283a 	ret

81138df4 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
81138df4:	defffb04 	addi	sp,sp,-20
81138df8:	de00012e 	bgeu	sp,et,81138e00 <alt_log_jtag_uart_isr_proc+0xc>
81138dfc:	003b68fa 	trap	3
81138e00:	dfc00415 	stw	ra,16(sp)
81138e04:	df000315 	stw	fp,12(sp)
81138e08:	df000304 	addi	fp,sp,12
81138e0c:	e13ffe15 	stw	r4,-8(fp)
81138e10:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
81138e14:	d0a081c3 	ldbu	r2,-32249(gp)
81138e18:	10803fcc 	andi	r2,r2,255
81138e1c:	10000826 	beq	r2,zero,81138e40 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
81138e20:	00a04574 	movhi	r2,33045
81138e24:	108a8804 	addi	r2,r2,10784
81138e28:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
81138e2c:	e1bffd17 	ldw	r6,-12(fp)
81138e30:	e17ffe17 	ldw	r5,-8(fp)
81138e34:	e13fff17 	ldw	r4,-4(fp)
81138e38:	1138ca80 	call	81138ca8 <alt_log_jtag_uart_print_control_reg>
    }
    return;
81138e3c:	0001883a 	nop
81138e40:	0001883a 	nop
}
81138e44:	e037883a 	mov	sp,fp
81138e48:	dfc00117 	ldw	ra,4(sp)
81138e4c:	df000017 	ldw	fp,0(sp)
81138e50:	dec00204 	addi	sp,sp,8
81138e54:	f800283a 	ret

81138e58 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
81138e58:	defffa04 	addi	sp,sp,-24
81138e5c:	de00012e 	bgeu	sp,et,81138e64 <alt_log_write+0xc>
81138e60:	003b68fa 	trap	3
81138e64:	dfc00515 	stw	ra,20(sp)
81138e68:	df000415 	stw	fp,16(sp)
81138e6c:	df000404 	addi	fp,sp,16
81138e70:	e13ffe15 	stw	r4,-8(fp)
81138e74:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81138e78:	d0a08103 	ldbu	r2,-32252(gp)
81138e7c:	10803fcc 	andi	r2,r2,255
81138e80:	10004026 	beq	r2,zero,81138f84 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
81138e84:	e0bfff17 	ldw	r2,-4(fp)
81138e88:	10c00430 	cmpltui	r3,r2,16
81138e8c:	1800011e 	bne	r3,zero,81138e94 <alt_log_write+0x3c>
81138e90:	008003c4 	movi	r2,15
81138e94:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81138e98:	e0bffd17 	ldw	r2,-12(fp)
81138e9c:	10800088 	cmpgei	r2,r2,2
81138ea0:	10003726 	beq	r2,zero,81138f80 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
81138ea4:	e0bffd17 	ldw	r2,-12(fp)
81138ea8:	100d883a 	mov	r6,r2
81138eac:	e17ffe17 	ldw	r5,-8(fp)
81138eb0:	012045f4 	movhi	r4,33047
81138eb4:	21226704 	addi	r4,r4,-30308
81138eb8:	114ce240 	call	8114ce24 <strncpy>
    alt_log_write_buf[length-1]='\n';
81138ebc:	e0bffd17 	ldw	r2,-12(fp)
81138ec0:	10ffffc4 	addi	r3,r2,-1
81138ec4:	00a045f4 	movhi	r2,33047
81138ec8:	10a26704 	addi	r2,r2,-30308
81138ecc:	10c5883a 	add	r2,r2,r3
81138ed0:	00c00284 	movi	r3,10
81138ed4:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
81138ed8:	00a045f4 	movhi	r2,33047
81138edc:	10a26704 	addi	r2,r2,-30308
81138ee0:	e0fffd17 	ldw	r3,-12(fp)
81138ee4:	10c5883a 	add	r2,r2,r3
81138ee8:	00c00344 	movi	r3,13
81138eec:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
81138ef0:	e0bffd17 	ldw	r2,-12(fp)
81138ef4:	10c00044 	addi	r3,r2,1
81138ef8:	00a045f4 	movhi	r2,33047
81138efc:	10a26704 	addi	r2,r2,-30308
81138f00:	10c5883a 	add	r2,r2,r3
81138f04:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81138f08:	e03ffc15 	stw	zero,-16(fp)
81138f0c:	00001306 	br	81138f5c <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
81138f10:	00a045f4 	movhi	r2,33047
81138f14:	10a26704 	addi	r2,r2,-30308
81138f18:	e0fffc17 	ldw	r3,-16(fp)
81138f1c:	10c5883a 	add	r2,r2,r3
81138f20:	10800003 	ldbu	r2,0(r2)
81138f24:	10803fcc 	andi	r2,r2,255
81138f28:	1080201c 	xori	r2,r2,128
81138f2c:	10bfe004 	addi	r2,r2,-128
81138f30:	10800118 	cmpnei	r2,r2,4
81138f34:	1000061e 	bne	r2,zero,81138f50 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
81138f38:	00a045f4 	movhi	r2,33047
81138f3c:	10a26704 	addi	r2,r2,-30308
81138f40:	e0fffc17 	ldw	r3,-16(fp)
81138f44:	10c5883a 	add	r2,r2,r3
81138f48:	00c01104 	movi	r3,68
81138f4c:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81138f50:	e0bffc17 	ldw	r2,-16(fp)
81138f54:	10800044 	addi	r2,r2,1
81138f58:	e0bffc15 	stw	r2,-16(fp)
81138f5c:	e0fffc17 	ldw	r3,-16(fp)
81138f60:	e0bffd17 	ldw	r2,-12(fp)
81138f64:	18bfea16 	blt	r3,r2,81138f10 <__reset+0xfb118f10>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81138f68:	016045f4 	movhi	r5,33047
81138f6c:	29626704 	addi	r5,r5,-30308
81138f70:	01204574 	movhi	r4,33045
81138f74:	210a8b04 	addi	r4,r4,10796
81138f78:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
81138f7c:	00000106 	br	81138f84 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
81138f80:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
81138f84:	e037883a 	mov	sp,fp
81138f88:	dfc00117 	ldw	ra,4(sp)
81138f8c:	df000017 	ldw	fp,0(sp)
81138f90:	dec00204 	addi	sp,sp,8
81138f94:	f800283a 	ret

81138f98 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81138f98:	defffe04 	addi	sp,sp,-8
81138f9c:	de00012e 	bgeu	sp,et,81138fa4 <alt_log_system_clock+0xc>
81138fa0:	003b68fa 	trap	3
81138fa4:	dfc00115 	stw	ra,4(sp)
81138fa8:	df000015 	stw	fp,0(sp)
81138fac:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
81138fb0:	d0a08143 	ldbu	r2,-32251(gp)
81138fb4:	10803fcc 	andi	r2,r2,255
81138fb8:	10000e26 	beq	r2,zero,81138ff4 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
81138fbc:	d0a08417 	ldw	r2,-32240(gp)
81138fc0:	10800044 	addi	r2,r2,1
81138fc4:	d0a08415 	stw	r2,-32240(gp)
81138fc8:	d0a08817 	ldw	r2,-32224(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
81138fcc:	d0e08417 	ldw	r3,-32240(gp)
81138fd0:	10c0082e 	bgeu	r2,r3,81138ff4 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
81138fd4:	d0208415 	stw	zero,-32240(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
81138fd8:	d0a08317 	ldw	r2,-32244(gp)
81138fdc:	10c00044 	addi	r3,r2,1
81138fe0:	d0e08315 	stw	r3,-32244(gp)
81138fe4:	100b883a 	mov	r5,r2
81138fe8:	01204574 	movhi	r4,33045
81138fec:	210a8f04 	addi	r4,r4,10812
81138ff0:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
        }
    }
}
81138ff4:	0001883a 	nop
81138ff8:	e037883a 	mov	sp,fp
81138ffc:	dfc00117 	ldw	ra,4(sp)
81139000:	df000017 	ldw	fp,0(sp)
81139004:	dec00204 	addi	sp,sp,8
81139008:	f800283a 	ret

8113900c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113900c:	defffe04 	addi	sp,sp,-8
81139010:	de00012e 	bgeu	sp,et,81139018 <alt_get_errno+0xc>
81139014:	003b68fa 	trap	3
81139018:	dfc00115 	stw	ra,4(sp)
8113901c:	df000015 	stw	fp,0(sp)
81139020:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81139024:	d0a01017 	ldw	r2,-32704(gp)
81139028:	10000326 	beq	r2,zero,81139038 <alt_get_errno+0x2c>
8113902c:	d0a01017 	ldw	r2,-32704(gp)
81139030:	103ee83a 	callr	r2
81139034:	00000106 	br	8113903c <alt_get_errno+0x30>
81139038:	d0a07804 	addi	r2,gp,-32288
}
8113903c:	e037883a 	mov	sp,fp
81139040:	dfc00117 	ldw	ra,4(sp)
81139044:	df000017 	ldw	fp,0(sp)
81139048:	dec00204 	addi	sp,sp,8
8113904c:	f800283a 	ret

81139050 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
81139050:	defff904 	addi	sp,sp,-28
81139054:	de00012e 	bgeu	sp,et,8113905c <lseek+0xc>
81139058:	003b68fa 	trap	3
8113905c:	dfc00615 	stw	ra,24(sp)
81139060:	df000515 	stw	fp,20(sp)
81139064:	df000504 	addi	fp,sp,20
81139068:	e13ffd15 	stw	r4,-12(fp)
8113906c:	e17ffe15 	stw	r5,-8(fp)
81139070:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
81139074:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81139078:	e0bffd17 	ldw	r2,-12(fp)
8113907c:	10000616 	blt	r2,zero,81139098 <lseek+0x48>
81139080:	e0bffd17 	ldw	r2,-12(fp)
81139084:	10c00324 	muli	r3,r2,12
81139088:	00a04574 	movhi	r2,33045
8113908c:	108e4804 	addi	r2,r2,14624
81139090:	1885883a 	add	r2,r3,r2
81139094:	00000106 	br	8113909c <lseek+0x4c>
81139098:	0005883a 	mov	r2,zero
8113909c:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
811390a0:	e0bffc17 	ldw	r2,-16(fp)
811390a4:	10001026 	beq	r2,zero,811390e8 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
811390a8:	e0bffc17 	ldw	r2,-16(fp)
811390ac:	10800017 	ldw	r2,0(r2)
811390b0:	10800717 	ldw	r2,28(r2)
811390b4:	10000926 	beq	r2,zero,811390dc <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
811390b8:	e0bffc17 	ldw	r2,-16(fp)
811390bc:	10800017 	ldw	r2,0(r2)
811390c0:	10800717 	ldw	r2,28(r2)
811390c4:	e1bfff17 	ldw	r6,-4(fp)
811390c8:	e17ffe17 	ldw	r5,-8(fp)
811390cc:	e13ffc17 	ldw	r4,-16(fp)
811390d0:	103ee83a 	callr	r2
811390d4:	e0bffb15 	stw	r2,-20(fp)
811390d8:	00000506 	br	811390f0 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
811390dc:	00bfde84 	movi	r2,-134
811390e0:	e0bffb15 	stw	r2,-20(fp)
811390e4:	00000206 	br	811390f0 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
811390e8:	00bfebc4 	movi	r2,-81
811390ec:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
811390f0:	e0bffb17 	ldw	r2,-20(fp)
811390f4:	1000070e 	bge	r2,zero,81139114 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
811390f8:	113900c0 	call	8113900c <alt_get_errno>
811390fc:	1007883a 	mov	r3,r2
81139100:	e0bffb17 	ldw	r2,-20(fp)
81139104:	0085c83a 	sub	r2,zero,r2
81139108:	18800015 	stw	r2,0(r3)
    rc = -1;
8113910c:	00bfffc4 	movi	r2,-1
81139110:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
81139114:	e0bffb17 	ldw	r2,-20(fp)
}
81139118:	e037883a 	mov	sp,fp
8113911c:	dfc00117 	ldw	ra,4(sp)
81139120:	df000017 	ldw	fp,0(sp)
81139124:	dec00204 	addi	sp,sp,8
81139128:	f800283a 	ret

8113912c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
8113912c:	defff904 	addi	sp,sp,-28
81139130:	de00012e 	bgeu	sp,et,81139138 <alt_main+0xc>
81139134:	003b68fa 	trap	3
81139138:	dfc00615 	stw	ra,24(sp)
8113913c:	df000515 	stw	fp,20(sp)
81139140:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
81139144:	d0a01217 	ldw	r2,-32696(gp)
81139148:	10800058 	cmpnei	r2,r2,1
8113914c:	1000031e 	bne	r2,zero,8113915c <alt_main+0x30>
81139150:	01204574 	movhi	r4,33045
81139154:	210a9504 	addi	r4,r4,10836
81139158:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
8113915c:	0009883a 	mov	r4,zero
81139160:	1143c840 	call	81143c84 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
81139164:	d0a01217 	ldw	r2,-32696(gp)
81139168:	10800058 	cmpnei	r2,r2,1
8113916c:	1000031e 	bne	r2,zero,8113917c <alt_main+0x50>
81139170:	01204574 	movhi	r4,33045
81139174:	210aa304 	addi	r4,r4,10892
81139178:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
  ALT_OS_INIT();
8113917c:	113a7180 	call	8113a718 <OSInit>
81139180:	01000044 	movi	r4,1
81139184:	11404340 	call	81140434 <OSSemCreate>
81139188:	d0a08b15 	stw	r2,-32212(gp)
8113918c:	01000044 	movi	r4,1
81139190:	11404340 	call	81140434 <OSSemCreate>
81139194:	d0a08d15 	stw	r2,-32204(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81139198:	d0a01217 	ldw	r2,-32696(gp)
8113919c:	10800058 	cmpnei	r2,r2,1
811391a0:	1000031e 	bne	r2,zero,811391b0 <alt_main+0x84>
811391a4:	01204574 	movhi	r4,33045
811391a8:	210ab104 	addi	r4,r4,10948
811391ac:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
811391b0:	d0a07f04 	addi	r2,gp,-32260
811391b4:	e0bffc15 	stw	r2,-16(fp)
811391b8:	00800044 	movi	r2,1
811391bc:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811391c0:	e0bffd0b 	ldhu	r2,-12(fp)
811391c4:	1009883a 	mov	r4,r2
811391c8:	11404340 	call	81140434 <OSSemCreate>
811391cc:	1007883a 	mov	r3,r2
811391d0:	e0bffc17 	ldw	r2,-16(fp)
811391d4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
811391d8:	d0a01217 	ldw	r2,-32696(gp)
811391dc:	10800058 	cmpnei	r2,r2,1
811391e0:	1000031e 	bne	r2,zero,811391f0 <alt_main+0xc4>
811391e4:	01204574 	movhi	r4,33045
811391e8:	210abf04 	addi	r4,r4,11004
811391ec:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
  alt_sys_init();
811391f0:	1143cc40 	call	81143cc4 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
811391f4:	d0a01217 	ldw	r2,-32696(gp)
811391f8:	10800058 	cmpnei	r2,r2,1
811391fc:	1000031e 	bne	r2,zero,8113920c <alt_main+0xe0>
81139200:	01204574 	movhi	r4,33045
81139204:	210ac904 	addi	r4,r4,11044
81139208:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
8113920c:	d0a01217 	ldw	r2,-32696(gp)
81139210:	10800058 	cmpnei	r2,r2,1
81139214:	1000031e 	bne	r2,zero,81139224 <alt_main+0xf8>
81139218:	01204574 	movhi	r4,33045
8113921c:	210ad204 	addi	r4,r4,11080
81139220:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
81139224:	01a04574 	movhi	r6,33045
81139228:	318ada04 	addi	r6,r6,11112
8113922c:	01604574 	movhi	r5,33045
81139230:	294adf04 	addi	r5,r5,11132
81139234:	01204574 	movhi	r4,33045
81139238:	210adf04 	addi	r4,r4,11132
8113923c:	114c5b40 	call	8114c5b4 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
81139240:	d0a01217 	ldw	r2,-32696(gp)
81139244:	10800058 	cmpnei	r2,r2,1
81139248:	1000031e 	bne	r2,zero,81139258 <alt_main+0x12c>
8113924c:	01204574 	movhi	r4,33045
81139250:	210ae304 	addi	r4,r4,11148
81139254:	1138ba80 	call	81138ba8 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
81139258:	d0a08517 	ldw	r2,-32236(gp)
8113925c:	d0e08617 	ldw	r3,-32232(gp)
81139260:	d1208717 	ldw	r4,-32228(gp)
81139264:	200d883a 	mov	r6,r4
81139268:	180b883a 	mov	r5,r3
8113926c:	1009883a 	mov	r4,r2
81139270:	11193240 	call	81119324 <main>
81139274:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81139278:	01000044 	movi	r4,1
8113927c:	11380580 	call	81138058 <close>
  exit (result);
81139280:	e13ffb17 	ldw	r4,-20(fp)
81139284:	114cd680 	call	8114cd68 <exit>

81139288 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81139288:	defffe04 	addi	sp,sp,-8
8113928c:	de00012e 	bgeu	sp,et,81139294 <alt_get_errno+0xc>
81139290:	003b68fa 	trap	3
81139294:	dfc00115 	stw	ra,4(sp)
81139298:	df000015 	stw	fp,0(sp)
8113929c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811392a0:	d0a01017 	ldw	r2,-32704(gp)
811392a4:	10000326 	beq	r2,zero,811392b4 <alt_get_errno+0x2c>
811392a8:	d0a01017 	ldw	r2,-32704(gp)
811392ac:	103ee83a 	callr	r2
811392b0:	00000106 	br	811392b8 <alt_get_errno+0x30>
811392b4:	d0a07804 	addi	r2,gp,-32288
}
811392b8:	e037883a 	mov	sp,fp
811392bc:	dfc00117 	ldw	ra,4(sp)
811392c0:	df000017 	ldw	fp,0(sp)
811392c4:	dec00204 	addi	sp,sp,8
811392c8:	f800283a 	ret

811392cc <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
811392cc:	defffd04 	addi	sp,sp,-12
811392d0:	de00012e 	bgeu	sp,et,811392d8 <alt_file_locked+0xc>
811392d4:	003b68fa 	trap	3
811392d8:	df000215 	stw	fp,8(sp)
811392dc:	df000204 	addi	fp,sp,8
811392e0:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
811392e4:	e0bfff17 	ldw	r2,-4(fp)
811392e8:	10800217 	ldw	r2,8(r2)
811392ec:	10d00034 	orhi	r3,r2,16384
811392f0:	e0bfff17 	ldw	r2,-4(fp)
811392f4:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
811392f8:	e03ffe15 	stw	zero,-8(fp)
811392fc:	00001d06 	br	81139374 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81139300:	00a04574 	movhi	r2,33045
81139304:	108e4804 	addi	r2,r2,14624
81139308:	e0fffe17 	ldw	r3,-8(fp)
8113930c:	18c00324 	muli	r3,r3,12
81139310:	10c5883a 	add	r2,r2,r3
81139314:	10c00017 	ldw	r3,0(r2)
81139318:	e0bfff17 	ldw	r2,-4(fp)
8113931c:	10800017 	ldw	r2,0(r2)
81139320:	1880111e 	bne	r3,r2,81139368 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81139324:	00a04574 	movhi	r2,33045
81139328:	108e4804 	addi	r2,r2,14624
8113932c:	e0fffe17 	ldw	r3,-8(fp)
81139330:	18c00324 	muli	r3,r3,12
81139334:	10c5883a 	add	r2,r2,r3
81139338:	10800204 	addi	r2,r2,8
8113933c:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81139340:	1000090e 	bge	r2,zero,81139368 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
81139344:	e0bffe17 	ldw	r2,-8(fp)
81139348:	10c00324 	muli	r3,r2,12
8113934c:	00a04574 	movhi	r2,33045
81139350:	108e4804 	addi	r2,r2,14624
81139354:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81139358:	e0bfff17 	ldw	r2,-4(fp)
8113935c:	18800226 	beq	r3,r2,81139368 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
81139360:	00bffcc4 	movi	r2,-13
81139364:	00000806 	br	81139388 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81139368:	e0bffe17 	ldw	r2,-8(fp)
8113936c:	10800044 	addi	r2,r2,1
81139370:	e0bffe15 	stw	r2,-8(fp)
81139374:	d0a00f17 	ldw	r2,-32708(gp)
81139378:	1007883a 	mov	r3,r2
8113937c:	e0bffe17 	ldw	r2,-8(fp)
81139380:	18bfdf2e 	bgeu	r3,r2,81139300 <__reset+0xfb119300>
    }
  }
  
  /* The device is not locked */
 
  return 0;
81139384:	0005883a 	mov	r2,zero
}
81139388:	e037883a 	mov	sp,fp
8113938c:	df000017 	ldw	fp,0(sp)
81139390:	dec00104 	addi	sp,sp,4
81139394:	f800283a 	ret

81139398 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
81139398:	defff604 	addi	sp,sp,-40
8113939c:	de00012e 	bgeu	sp,et,811393a4 <open+0xc>
811393a0:	003b68fa 	trap	3
811393a4:	dfc00915 	stw	ra,36(sp)
811393a8:	df000815 	stw	fp,32(sp)
811393ac:	df000804 	addi	fp,sp,32
811393b0:	e13ffd15 	stw	r4,-12(fp)
811393b4:	e17ffe15 	stw	r5,-8(fp)
811393b8:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
811393bc:	00bfffc4 	movi	r2,-1
811393c0:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
811393c4:	00bffb44 	movi	r2,-19
811393c8:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
811393cc:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
811393d0:	d1600d04 	addi	r5,gp,-32716
811393d4:	e13ffd17 	ldw	r4,-12(fp)
811393d8:	114bf940 	call	8114bf94 <alt_find_dev>
811393dc:	e0bff815 	stw	r2,-32(fp)
811393e0:	e0bff817 	ldw	r2,-32(fp)
811393e4:	1000051e 	bne	r2,zero,811393fc <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
811393e8:	e13ffd17 	ldw	r4,-12(fp)
811393ec:	114c02c0 	call	8114c02c <alt_find_file>
811393f0:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
811393f4:	00800044 	movi	r2,1
811393f8:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
811393fc:	e0bff817 	ldw	r2,-32(fp)
81139400:	10002926 	beq	r2,zero,811394a8 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
81139404:	e13ff817 	ldw	r4,-32(fp)
81139408:	114c13c0 	call	8114c13c <alt_get_fd>
8113940c:	e0bff915 	stw	r2,-28(fp)
81139410:	e0bff917 	ldw	r2,-28(fp)
81139414:	1000030e 	bge	r2,zero,81139424 <open+0x8c>
    {
      status = index;
81139418:	e0bff917 	ldw	r2,-28(fp)
8113941c:	e0bffa15 	stw	r2,-24(fp)
81139420:	00002306 	br	811394b0 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
81139424:	e0bff917 	ldw	r2,-28(fp)
81139428:	10c00324 	muli	r3,r2,12
8113942c:	00a04574 	movhi	r2,33045
81139430:	108e4804 	addi	r2,r2,14624
81139434:	1885883a 	add	r2,r3,r2
81139438:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
8113943c:	e0fffe17 	ldw	r3,-8(fp)
81139440:	00900034 	movhi	r2,16384
81139444:	10bfffc4 	addi	r2,r2,-1
81139448:	1886703a 	and	r3,r3,r2
8113944c:	e0bffc17 	ldw	r2,-16(fp)
81139450:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
81139454:	e0bffb17 	ldw	r2,-20(fp)
81139458:	1000051e 	bne	r2,zero,81139470 <open+0xd8>
8113945c:	e13ffc17 	ldw	r4,-16(fp)
81139460:	11392cc0 	call	811392cc <alt_file_locked>
81139464:	e0bffa15 	stw	r2,-24(fp)
81139468:	e0bffa17 	ldw	r2,-24(fp)
8113946c:	10001016 	blt	r2,zero,811394b0 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
81139470:	e0bff817 	ldw	r2,-32(fp)
81139474:	10800317 	ldw	r2,12(r2)
81139478:	10000826 	beq	r2,zero,8113949c <open+0x104>
8113947c:	e0bff817 	ldw	r2,-32(fp)
81139480:	10800317 	ldw	r2,12(r2)
81139484:	e1ffff17 	ldw	r7,-4(fp)
81139488:	e1bffe17 	ldw	r6,-8(fp)
8113948c:	e17ffd17 	ldw	r5,-12(fp)
81139490:	e13ffc17 	ldw	r4,-16(fp)
81139494:	103ee83a 	callr	r2
81139498:	00000106 	br	811394a0 <open+0x108>
8113949c:	0005883a 	mov	r2,zero
811394a0:	e0bffa15 	stw	r2,-24(fp)
811394a4:	00000206 	br	811394b0 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
811394a8:	00bffb44 	movi	r2,-19
811394ac:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
811394b0:	e0bffa17 	ldw	r2,-24(fp)
811394b4:	1000090e 	bge	r2,zero,811394dc <open+0x144>
  {
    alt_release_fd (index);  
811394b8:	e13ff917 	ldw	r4,-28(fp)
811394bc:	113963c0 	call	8113963c <alt_release_fd>
    ALT_ERRNO = -status;
811394c0:	11392880 	call	81139288 <alt_get_errno>
811394c4:	1007883a 	mov	r3,r2
811394c8:	e0bffa17 	ldw	r2,-24(fp)
811394cc:	0085c83a 	sub	r2,zero,r2
811394d0:	18800015 	stw	r2,0(r3)
    return -1;
811394d4:	00bfffc4 	movi	r2,-1
811394d8:	00000106 	br	811394e0 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
811394dc:	e0bff917 	ldw	r2,-28(fp)
}
811394e0:	e037883a 	mov	sp,fp
811394e4:	dfc00117 	ldw	ra,4(sp)
811394e8:	df000017 	ldw	fp,0(sp)
811394ec:	dec00204 	addi	sp,sp,8
811394f0:	f800283a 	ret

811394f4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811394f4:	defffe04 	addi	sp,sp,-8
811394f8:	de00012e 	bgeu	sp,et,81139500 <alt_get_errno+0xc>
811394fc:	003b68fa 	trap	3
81139500:	dfc00115 	stw	ra,4(sp)
81139504:	df000015 	stw	fp,0(sp)
81139508:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113950c:	d0a01017 	ldw	r2,-32704(gp)
81139510:	10000326 	beq	r2,zero,81139520 <alt_get_errno+0x2c>
81139514:	d0a01017 	ldw	r2,-32704(gp)
81139518:	103ee83a 	callr	r2
8113951c:	00000106 	br	81139524 <alt_get_errno+0x30>
81139520:	d0a07804 	addi	r2,gp,-32288
}
81139524:	e037883a 	mov	sp,fp
81139528:	dfc00117 	ldw	ra,4(sp)
8113952c:	df000017 	ldw	fp,0(sp)
81139530:	dec00204 	addi	sp,sp,8
81139534:	f800283a 	ret

81139538 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
81139538:	defff904 	addi	sp,sp,-28
8113953c:	de00012e 	bgeu	sp,et,81139544 <read+0xc>
81139540:	003b68fa 	trap	3
81139544:	dfc00615 	stw	ra,24(sp)
81139548:	df000515 	stw	fp,20(sp)
8113954c:	df000504 	addi	fp,sp,20
81139550:	e13ffd15 	stw	r4,-12(fp)
81139554:	e17ffe15 	stw	r5,-8(fp)
81139558:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8113955c:	e0bffd17 	ldw	r2,-12(fp)
81139560:	10000616 	blt	r2,zero,8113957c <read+0x44>
81139564:	e0bffd17 	ldw	r2,-12(fp)
81139568:	10c00324 	muli	r3,r2,12
8113956c:	00a04574 	movhi	r2,33045
81139570:	108e4804 	addi	r2,r2,14624
81139574:	1885883a 	add	r2,r3,r2
81139578:	00000106 	br	81139580 <read+0x48>
8113957c:	0005883a 	mov	r2,zero
81139580:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81139584:	e0bffb17 	ldw	r2,-20(fp)
81139588:	10002226 	beq	r2,zero,81139614 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
8113958c:	e0bffb17 	ldw	r2,-20(fp)
81139590:	10800217 	ldw	r2,8(r2)
81139594:	108000cc 	andi	r2,r2,3
81139598:	10800060 	cmpeqi	r2,r2,1
8113959c:	1000181e 	bne	r2,zero,81139600 <read+0xc8>
        (fd->dev->read))
811395a0:	e0bffb17 	ldw	r2,-20(fp)
811395a4:	10800017 	ldw	r2,0(r2)
811395a8:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
811395ac:	10001426 	beq	r2,zero,81139600 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
811395b0:	e0bffb17 	ldw	r2,-20(fp)
811395b4:	10800017 	ldw	r2,0(r2)
811395b8:	10800517 	ldw	r2,20(r2)
811395bc:	e0ffff17 	ldw	r3,-4(fp)
811395c0:	180d883a 	mov	r6,r3
811395c4:	e17ffe17 	ldw	r5,-8(fp)
811395c8:	e13ffb17 	ldw	r4,-20(fp)
811395cc:	103ee83a 	callr	r2
811395d0:	e0bffc15 	stw	r2,-16(fp)
811395d4:	e0bffc17 	ldw	r2,-16(fp)
811395d8:	1000070e 	bge	r2,zero,811395f8 <read+0xc0>
        {
          ALT_ERRNO = -rval;
811395dc:	11394f40 	call	811394f4 <alt_get_errno>
811395e0:	1007883a 	mov	r3,r2
811395e4:	e0bffc17 	ldw	r2,-16(fp)
811395e8:	0085c83a 	sub	r2,zero,r2
811395ec:	18800015 	stw	r2,0(r3)
          return -1;
811395f0:	00bfffc4 	movi	r2,-1
811395f4:	00000c06 	br	81139628 <read+0xf0>
        }
        return rval;
811395f8:	e0bffc17 	ldw	r2,-16(fp)
811395fc:	00000a06 	br	81139628 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
81139600:	11394f40 	call	811394f4 <alt_get_errno>
81139604:	1007883a 	mov	r3,r2
81139608:	00800344 	movi	r2,13
8113960c:	18800015 	stw	r2,0(r3)
81139610:	00000406 	br	81139624 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
81139614:	11394f40 	call	811394f4 <alt_get_errno>
81139618:	1007883a 	mov	r3,r2
8113961c:	00801444 	movi	r2,81
81139620:	18800015 	stw	r2,0(r3)
  }
  return -1;
81139624:	00bfffc4 	movi	r2,-1
}
81139628:	e037883a 	mov	sp,fp
8113962c:	dfc00117 	ldw	ra,4(sp)
81139630:	df000017 	ldw	fp,0(sp)
81139634:	dec00204 	addi	sp,sp,8
81139638:	f800283a 	ret

8113963c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
8113963c:	defffe04 	addi	sp,sp,-8
81139640:	de00012e 	bgeu	sp,et,81139648 <alt_release_fd+0xc>
81139644:	003b68fa 	trap	3
81139648:	df000115 	stw	fp,4(sp)
8113964c:	df000104 	addi	fp,sp,4
81139650:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
81139654:	e0bfff17 	ldw	r2,-4(fp)
81139658:	108000d0 	cmplti	r2,r2,3
8113965c:	10000d1e 	bne	r2,zero,81139694 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
81139660:	00a04574 	movhi	r2,33045
81139664:	108e4804 	addi	r2,r2,14624
81139668:	e0ffff17 	ldw	r3,-4(fp)
8113966c:	18c00324 	muli	r3,r3,12
81139670:	10c5883a 	add	r2,r2,r3
81139674:	10800204 	addi	r2,r2,8
81139678:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
8113967c:	00a04574 	movhi	r2,33045
81139680:	108e4804 	addi	r2,r2,14624
81139684:	e0ffff17 	ldw	r3,-4(fp)
81139688:	18c00324 	muli	r3,r3,12
8113968c:	10c5883a 	add	r2,r2,r3
81139690:	10000015 	stw	zero,0(r2)
  }
}
81139694:	0001883a 	nop
81139698:	e037883a 	mov	sp,fp
8113969c:	df000017 	ldw	fp,0(sp)
811396a0:	dec00104 	addi	sp,sp,4
811396a4:	f800283a 	ret

811396a8 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
811396a8:	defff604 	addi	sp,sp,-40
811396ac:	de00012e 	bgeu	sp,et,811396b4 <sbrk+0xc>
811396b0:	003b68fa 	trap	3
811396b4:	df000915 	stw	fp,36(sp)
811396b8:	df000904 	addi	fp,sp,36
811396bc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811396c0:	0005303a 	rdctl	r2,status
811396c4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811396c8:	e0fffe17 	ldw	r3,-8(fp)
811396cc:	00bfff84 	movi	r2,-2
811396d0:	1884703a 	and	r2,r3,r2
811396d4:	1001703a 	wrctl	status,r2
  
  return context;
811396d8:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
811396dc:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
811396e0:	d0a01317 	ldw	r2,-32692(gp)
811396e4:	10c000c4 	addi	r3,r2,3
811396e8:	00bfff04 	movi	r2,-4
811396ec:	1884703a 	and	r2,r3,r2
811396f0:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
811396f4:	d0e01317 	ldw	r3,-32692(gp)
811396f8:	e0bfff17 	ldw	r2,-4(fp)
811396fc:	1887883a 	add	r3,r3,r2
81139700:	00a04834 	movhi	r2,33056
81139704:	10a80004 	addi	r2,r2,-24576
81139708:	10c0062e 	bgeu	r2,r3,81139724 <sbrk+0x7c>
8113970c:	e0bff817 	ldw	r2,-32(fp)
81139710:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139714:	e0bff717 	ldw	r2,-36(fp)
81139718:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
8113971c:	00bfffc4 	movi	r2,-1
81139720:	00001c06 	br	81139794 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81139724:	d0a01317 	ldw	r2,-32692(gp)
81139728:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
8113972c:	d0e01317 	ldw	r3,-32692(gp)
81139730:	e0bfff17 	ldw	r2,-4(fp)
81139734:	1885883a 	add	r2,r3,r2
81139738:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
8113973c:	c005883a 	mov	r2,et
81139740:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81139744:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81139748:	e0bffa17 	ldw	r2,-24(fp)
8113974c:	18800c1e 	bne	r3,r2,81139780 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
81139750:	d805883a 	mov	r2,sp
81139754:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81139758:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
8113975c:	d0e01317 	ldw	r3,-32692(gp)
81139760:	18800136 	bltu	r3,r2,81139768 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81139764:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81139768:	d0a01317 	ldw	r2,-32692(gp)
8113976c:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81139770:	e0bffc17 	ldw	r2,-16(fp)
81139774:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81139778:	e0bffc17 	ldw	r2,-16(fp)
8113977c:	1031883a 	mov	et,r2
81139780:	e0bff817 	ldw	r2,-32(fp)
81139784:	e0bffd15 	stw	r2,-12(fp)
81139788:	e0bffd17 	ldw	r2,-12(fp)
8113978c:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
81139790:	e0bffa17 	ldw	r2,-24(fp)
} 
81139794:	e037883a 	mov	sp,fp
81139798:	df000017 	ldw	fp,0(sp)
8113979c:	dec00104 	addi	sp,sp,4
811397a0:	f800283a 	ret

811397a4 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
811397a4:	defffa04 	addi	sp,sp,-24
811397a8:	de00012e 	bgeu	sp,et,811397b0 <alt_alarm_stop+0xc>
811397ac:	003b68fa 	trap	3
811397b0:	df000515 	stw	fp,20(sp)
811397b4:	df000504 	addi	fp,sp,20
811397b8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811397bc:	0005303a 	rdctl	r2,status
811397c0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811397c4:	e0fffc17 	ldw	r3,-16(fp)
811397c8:	00bfff84 	movi	r2,-2
811397cc:	1884703a 	and	r2,r3,r2
811397d0:	1001703a 	wrctl	status,r2
  
  return context;
811397d4:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
811397d8:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
811397dc:	e0bfff17 	ldw	r2,-4(fp)
811397e0:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
811397e4:	e0bffd17 	ldw	r2,-12(fp)
811397e8:	10800017 	ldw	r2,0(r2)
811397ec:	e0fffd17 	ldw	r3,-12(fp)
811397f0:	18c00117 	ldw	r3,4(r3)
811397f4:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
811397f8:	e0bffd17 	ldw	r2,-12(fp)
811397fc:	10800117 	ldw	r2,4(r2)
81139800:	e0fffd17 	ldw	r3,-12(fp)
81139804:	18c00017 	ldw	r3,0(r3)
81139808:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
8113980c:	e0bffd17 	ldw	r2,-12(fp)
81139810:	e0fffd17 	ldw	r3,-12(fp)
81139814:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81139818:	e0bffd17 	ldw	r2,-12(fp)
8113981c:	e0fffd17 	ldw	r3,-12(fp)
81139820:	10c00015 	stw	r3,0(r2)
81139824:	e0bffb17 	ldw	r2,-20(fp)
81139828:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113982c:	e0bffe17 	ldw	r2,-8(fp)
81139830:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81139834:	0001883a 	nop
81139838:	e037883a 	mov	sp,fp
8113983c:	df000017 	ldw	fp,0(sp)
81139840:	dec00104 	addi	sp,sp,4
81139844:	f800283a 	ret

81139848 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81139848:	defffb04 	addi	sp,sp,-20
8113984c:	de00012e 	bgeu	sp,et,81139854 <alt_tick+0xc>
81139850:	003b68fa 	trap	3
81139854:	dfc00415 	stw	ra,16(sp)
81139858:	df000315 	stw	fp,12(sp)
8113985c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81139860:	d0a01417 	ldw	r2,-32688(gp)
81139864:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81139868:	d0a08917 	ldw	r2,-32220(gp)
8113986c:	10800044 	addi	r2,r2,1
81139870:	d0a08915 	stw	r2,-32220(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81139874:	00002e06 	br	81139930 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81139878:	e0bffd17 	ldw	r2,-12(fp)
8113987c:	10800017 	ldw	r2,0(r2)
81139880:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81139884:	e0bffd17 	ldw	r2,-12(fp)
81139888:	10800403 	ldbu	r2,16(r2)
8113988c:	10803fcc 	andi	r2,r2,255
81139890:	10000426 	beq	r2,zero,811398a4 <alt_tick+0x5c>
81139894:	d0a08917 	ldw	r2,-32220(gp)
81139898:	1000021e 	bne	r2,zero,811398a4 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
8113989c:	e0bffd17 	ldw	r2,-12(fp)
811398a0:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
811398a4:	e0bffd17 	ldw	r2,-12(fp)
811398a8:	10800217 	ldw	r2,8(r2)
811398ac:	d0e08917 	ldw	r3,-32220(gp)
811398b0:	18801d36 	bltu	r3,r2,81139928 <alt_tick+0xe0>
811398b4:	e0bffd17 	ldw	r2,-12(fp)
811398b8:	10800403 	ldbu	r2,16(r2)
811398bc:	10803fcc 	andi	r2,r2,255
811398c0:	1000191e 	bne	r2,zero,81139928 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
811398c4:	e0bffd17 	ldw	r2,-12(fp)
811398c8:	10800317 	ldw	r2,12(r2)
811398cc:	e0fffd17 	ldw	r3,-12(fp)
811398d0:	18c00517 	ldw	r3,20(r3)
811398d4:	1809883a 	mov	r4,r3
811398d8:	103ee83a 	callr	r2
811398dc:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
811398e0:	e0bfff17 	ldw	r2,-4(fp)
811398e4:	1000031e 	bne	r2,zero,811398f4 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
811398e8:	e13ffd17 	ldw	r4,-12(fp)
811398ec:	11397a40 	call	811397a4 <alt_alarm_stop>
811398f0:	00000d06 	br	81139928 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
811398f4:	e0bffd17 	ldw	r2,-12(fp)
811398f8:	10c00217 	ldw	r3,8(r2)
811398fc:	e0bfff17 	ldw	r2,-4(fp)
81139900:	1887883a 	add	r3,r3,r2
81139904:	e0bffd17 	ldw	r2,-12(fp)
81139908:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
8113990c:	e0bffd17 	ldw	r2,-12(fp)
81139910:	10c00217 	ldw	r3,8(r2)
81139914:	d0a08917 	ldw	r2,-32220(gp)
81139918:	1880032e 	bgeu	r3,r2,81139928 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
8113991c:	e0bffd17 	ldw	r2,-12(fp)
81139920:	00c00044 	movi	r3,1
81139924:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81139928:	e0bffe17 	ldw	r2,-8(fp)
8113992c:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81139930:	e0fffd17 	ldw	r3,-12(fp)
81139934:	d0a01404 	addi	r2,gp,-32688
81139938:	18bfcf1e 	bne	r3,r2,81139878 <__reset+0xfb119878>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
8113993c:	113ab780 	call	8113ab78 <OSTimeTick>
}
81139940:	0001883a 	nop
81139944:	e037883a 	mov	sp,fp
81139948:	dfc00117 	ldw	ra,4(sp)
8113994c:	df000017 	ldw	fp,0(sp)
81139950:	dec00204 	addi	sp,sp,8
81139954:	f800283a 	ret

81139958 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81139958:	defffb04 	addi	sp,sp,-20
8113995c:	de00012e 	bgeu	sp,et,81139964 <usleep+0xc>
81139960:	003b68fa 	trap	3
81139964:	dfc00415 	stw	ra,16(sp)
81139968:	df000315 	stw	fp,12(sp)
8113996c:	df000304 	addi	fp,sp,12
81139970:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81139974:	d0a09103 	ldbu	r2,-32188(gp)
81139978:	10803fcc 	andi	r2,r2,255
8113997c:	1000031e 	bne	r2,zero,8113998c <usleep+0x34>
  {
    return alt_busy_sleep (us);
81139980:	e13fff17 	ldw	r4,-4(fp)
81139984:	1137ee40 	call	81137ee4 <alt_busy_sleep>
81139988:	00003d06 	br	81139a80 <usleep+0x128>
8113998c:	d0a08817 	ldw	r2,-32224(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81139990:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81139994:	e0ffff17 	ldw	r3,-4(fp)
81139998:	0090c734 	movhi	r2,17180
8113999c:	10b7a0c4 	addi	r2,r2,-8573
811399a0:	1888383a 	mulxuu	r4,r3,r2
811399a4:	1885383a 	mul	r2,r3,r2
811399a8:	1013883a 	mov	r9,r2
811399ac:	2015883a 	mov	r10,r4
811399b0:	5006d4ba 	srli	r3,r10,18
811399b4:	e0bffe17 	ldw	r2,-8(fp)
811399b8:	1893383a 	mul	r9,r3,r2
811399bc:	e0ffff17 	ldw	r3,-4(fp)
811399c0:	0090c734 	movhi	r2,17180
811399c4:	10b7a0c4 	addi	r2,r2,-8573
811399c8:	1888383a 	mulxuu	r4,r3,r2
811399cc:	1885383a 	mul	r2,r3,r2
811399d0:	100f883a 	mov	r7,r2
811399d4:	2011883a 	mov	r8,r4
811399d8:	4004d4ba 	srli	r2,r8,18
811399dc:	010003f4 	movhi	r4,15
811399e0:	21109004 	addi	r4,r4,16960
811399e4:	1105383a 	mul	r2,r2,r4
811399e8:	1885c83a 	sub	r2,r3,r2
811399ec:	e0fffe17 	ldw	r3,-8(fp)
811399f0:	10c7383a 	mul	r3,r2,r3
811399f4:	0090c734 	movhi	r2,17180
811399f8:	10b7a0c4 	addi	r2,r2,-8573
811399fc:	1888383a 	mulxuu	r4,r3,r2
81139a00:	1885383a 	mul	r2,r3,r2
81139a04:	100b883a 	mov	r5,r2
81139a08:	200d883a 	mov	r6,r4
81139a0c:	3004d4ba 	srli	r2,r6,18
81139a10:	4885883a 	add	r2,r9,r2
81139a14:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81139a18:	00000706 	br	81139a38 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
81139a1c:	013fffd4 	movui	r4,65535
81139a20:	11425e80 	call	811425e8 <OSTimeDly>
    ticks -= 0xffff;
81139a24:	e0fffd17 	ldw	r3,-12(fp)
81139a28:	00bffff4 	movhi	r2,65535
81139a2c:	10800044 	addi	r2,r2,1
81139a30:	1885883a 	add	r2,r3,r2
81139a34:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81139a38:	e0bffd17 	ldw	r2,-12(fp)
81139a3c:	00ffffd4 	movui	r3,65535
81139a40:	18bff636 	bltu	r3,r2,81139a1c <__reset+0xfb119a1c>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
81139a44:	e0bffd17 	ldw	r2,-12(fp)
81139a48:	10bfffcc 	andi	r2,r2,65535
81139a4c:	1009883a 	mov	r4,r2
81139a50:	11425e80 	call	811425e8 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
81139a54:	008003f4 	movhi	r2,15
81139a58:	10909004 	addi	r2,r2,16960
81139a5c:	e0fffe17 	ldw	r3,-8(fp)
81139a60:	10c7203a 	divu	r3,r2,r3
81139a64:	e0bfff17 	ldw	r2,-4(fp)
81139a68:	10c9203a 	divu	r4,r2,r3
81139a6c:	20c7383a 	mul	r3,r4,r3
81139a70:	10c5c83a 	sub	r2,r2,r3
81139a74:	1009883a 	mov	r4,r2
81139a78:	1137ee40 	call	81137ee4 <alt_busy_sleep>

  return 0;  
81139a7c:	0005883a 	mov	r2,zero
}
81139a80:	e037883a 	mov	sp,fp
81139a84:	dfc00117 	ldw	ra,4(sp)
81139a88:	df000017 	ldw	fp,0(sp)
81139a8c:	dec00204 	addi	sp,sp,8
81139a90:	f800283a 	ret

81139a94 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81139a94:	defffe04 	addi	sp,sp,-8
81139a98:	de00012e 	bgeu	sp,et,81139aa0 <alt_get_errno+0xc>
81139a9c:	003b68fa 	trap	3
81139aa0:	dfc00115 	stw	ra,4(sp)
81139aa4:	df000015 	stw	fp,0(sp)
81139aa8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81139aac:	d0a01017 	ldw	r2,-32704(gp)
81139ab0:	10000326 	beq	r2,zero,81139ac0 <alt_get_errno+0x2c>
81139ab4:	d0a01017 	ldw	r2,-32704(gp)
81139ab8:	103ee83a 	callr	r2
81139abc:	00000106 	br	81139ac4 <alt_get_errno+0x30>
81139ac0:	d0a07804 	addi	r2,gp,-32288
}
81139ac4:	e037883a 	mov	sp,fp
81139ac8:	dfc00117 	ldw	ra,4(sp)
81139acc:	df000017 	ldw	fp,0(sp)
81139ad0:	dec00204 	addi	sp,sp,8
81139ad4:	f800283a 	ret

81139ad8 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81139ad8:	defff904 	addi	sp,sp,-28
81139adc:	de00012e 	bgeu	sp,et,81139ae4 <write+0xc>
81139ae0:	003b68fa 	trap	3
81139ae4:	dfc00615 	stw	ra,24(sp)
81139ae8:	df000515 	stw	fp,20(sp)
81139aec:	df000504 	addi	fp,sp,20
81139af0:	e13ffd15 	stw	r4,-12(fp)
81139af4:	e17ffe15 	stw	r5,-8(fp)
81139af8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81139afc:	e0bffd17 	ldw	r2,-12(fp)
81139b00:	10000616 	blt	r2,zero,81139b1c <write+0x44>
81139b04:	e0bffd17 	ldw	r2,-12(fp)
81139b08:	10c00324 	muli	r3,r2,12
81139b0c:	00a04574 	movhi	r2,33045
81139b10:	108e4804 	addi	r2,r2,14624
81139b14:	1885883a 	add	r2,r3,r2
81139b18:	00000106 	br	81139b20 <write+0x48>
81139b1c:	0005883a 	mov	r2,zero
81139b20:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81139b24:	e0bffb17 	ldw	r2,-20(fp)
81139b28:	10002426 	beq	r2,zero,81139bbc <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81139b2c:	e0bffb17 	ldw	r2,-20(fp)
81139b30:	10800217 	ldw	r2,8(r2)
81139b34:	108000cc 	andi	r2,r2,3
81139b38:	10001b26 	beq	r2,zero,81139ba8 <write+0xd0>
81139b3c:	e0bffb17 	ldw	r2,-20(fp)
81139b40:	10800017 	ldw	r2,0(r2)
81139b44:	10800617 	ldw	r2,24(r2)
81139b48:	10001726 	beq	r2,zero,81139ba8 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
81139b4c:	e17fff17 	ldw	r5,-4(fp)
81139b50:	e13ffe17 	ldw	r4,-8(fp)
81139b54:	1138e580 	call	81138e58 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81139b58:	e0bffb17 	ldw	r2,-20(fp)
81139b5c:	10800017 	ldw	r2,0(r2)
81139b60:	10800617 	ldw	r2,24(r2)
81139b64:	e0ffff17 	ldw	r3,-4(fp)
81139b68:	180d883a 	mov	r6,r3
81139b6c:	e17ffe17 	ldw	r5,-8(fp)
81139b70:	e13ffb17 	ldw	r4,-20(fp)
81139b74:	103ee83a 	callr	r2
81139b78:	e0bffc15 	stw	r2,-16(fp)
81139b7c:	e0bffc17 	ldw	r2,-16(fp)
81139b80:	1000070e 	bge	r2,zero,81139ba0 <write+0xc8>
      {
        ALT_ERRNO = -rval;
81139b84:	1139a940 	call	81139a94 <alt_get_errno>
81139b88:	1007883a 	mov	r3,r2
81139b8c:	e0bffc17 	ldw	r2,-16(fp)
81139b90:	0085c83a 	sub	r2,zero,r2
81139b94:	18800015 	stw	r2,0(r3)
        return -1;
81139b98:	00bfffc4 	movi	r2,-1
81139b9c:	00000c06 	br	81139bd0 <write+0xf8>
      }
      return rval;
81139ba0:	e0bffc17 	ldw	r2,-16(fp)
81139ba4:	00000a06 	br	81139bd0 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81139ba8:	1139a940 	call	81139a94 <alt_get_errno>
81139bac:	1007883a 	mov	r3,r2
81139bb0:	00800344 	movi	r2,13
81139bb4:	18800015 	stw	r2,0(r3)
81139bb8:	00000406 	br	81139bcc <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81139bbc:	1139a940 	call	81139a94 <alt_get_errno>
81139bc0:	1007883a 	mov	r3,r2
81139bc4:	00801444 	movi	r2,81
81139bc8:	18800015 	stw	r2,0(r3)
  }
  return -1;
81139bcc:	00bfffc4 	movi	r2,-1
}
81139bd0:	e037883a 	mov	sp,fp
81139bd4:	dfc00117 	ldw	ra,4(sp)
81139bd8:	df000017 	ldw	fp,0(sp)
81139bdc:	dec00204 	addi	sp,sp,8
81139be0:	f800283a 	ret

81139be4 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81139be4:	deffde04 	addi	sp,sp,-136
81139be8:	de00012e 	bgeu	sp,et,81139bf0 <__env_lock+0xc>
81139bec:	003b68fa 	trap	3
81139bf0:	dfc02115 	stw	ra,132(sp)
81139bf4:	df002015 	stw	fp,128(sp)
81139bf8:	df002004 	addi	fp,sp,128
81139bfc:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81139c00:	e0bfe104 	addi	r2,fp,-124
81139c04:	100b883a 	mov	r5,r2
81139c08:	01003fc4 	movi	r4,255
81139c0c:	11424440 	call	81142444 <OSTaskQuery>
81139c10:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81139c14:	e0bffe83 	ldbu	r2,-6(fp)
81139c18:	10803fcc 	andi	r2,r2,255
81139c1c:	10001e1e 	bne	r2,zero,81139c98 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81139c20:	e0bfed83 	ldbu	r2,-74(fp)
81139c24:	10803fcc 	andi	r2,r2,255
81139c28:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81139c2c:	d0a08b17 	ldw	r2,-32212(gp)
81139c30:	e0fffc04 	addi	r3,fp,-16
81139c34:	180b883a 	mov	r5,r3
81139c38:	1009883a 	mov	r4,r2
81139c3c:	1140bfc0 	call	81140bfc <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
81139c40:	e0bffe03 	ldbu	r2,-8(fp)
81139c44:	10803fcc 	andi	r2,r2,255
81139c48:	10000726 	beq	r2,zero,81139c68 <__env_lock+0x84>
81139c4c:	d0a01617 	ldw	r2,-32680(gp)
81139c50:	e0ffe017 	ldw	r3,-128(fp)
81139c54:	1880041e 	bne	r3,r2,81139c68 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
81139c58:	d0a08a17 	ldw	r2,-32216(gp)
81139c5c:	10800044 	addi	r2,r2,1
81139c60:	d0a08a15 	stw	r2,-32216(gp)
81139c64:	00000a06 	br	81139c90 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81139c68:	d0a08b17 	ldw	r2,-32212(gp)
81139c6c:	e0fffe84 	addi	r3,fp,-6
81139c70:	180d883a 	mov	r6,r3
81139c74:	000b883a 	mov	r5,zero
81139c78:	1009883a 	mov	r4,r2
81139c7c:	114075c0 	call	8114075c <OSSemPend>
    locks  = 1;
81139c80:	00800044 	movi	r2,1
81139c84:	d0a08a15 	stw	r2,-32216(gp)
    lockid = id;
81139c88:	e0bfe017 	ldw	r2,-128(fp)
81139c8c:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81139c90:	0001883a 	nop
81139c94:	00000106 	br	81139c9c <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81139c98:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81139c9c:	e037883a 	mov	sp,fp
81139ca0:	dfc00117 	ldw	ra,4(sp)
81139ca4:	df000017 	ldw	fp,0(sp)
81139ca8:	dec00204 	addi	sp,sp,8
81139cac:	f800283a 	ret

81139cb0 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
81139cb0:	defffd04 	addi	sp,sp,-12
81139cb4:	de00012e 	bgeu	sp,et,81139cbc <__env_unlock+0xc>
81139cb8:	003b68fa 	trap	3
81139cbc:	dfc00215 	stw	ra,8(sp)
81139cc0:	df000115 	stw	fp,4(sp)
81139cc4:	df000104 	addi	fp,sp,4
81139cc8:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
81139ccc:	d0a08a17 	ldw	r2,-32216(gp)
81139cd0:	10000b26 	beq	r2,zero,81139d00 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
81139cd4:	d0a08a17 	ldw	r2,-32216(gp)
81139cd8:	10bfffc4 	addi	r2,r2,-1
81139cdc:	d0a08a15 	stw	r2,-32216(gp)
81139ce0:	d0a08a17 	ldw	r2,-32216(gp)
81139ce4:	1000071e 	bne	r2,zero,81139d04 <__env_unlock+0x54>
  {
    lockid = -1;
81139ce8:	00bfffc4 	movi	r2,-1
81139cec:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
81139cf0:	d0a08b17 	ldw	r2,-32212(gp)
81139cf4:	1009883a 	mov	r4,r2
81139cf8:	1140ae40 	call	81140ae4 <OSSemPost>
81139cfc:	00000106 	br	81139d04 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
81139d00:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81139d04:	e037883a 	mov	sp,fp
81139d08:	dfc00117 	ldw	ra,4(sp)
81139d0c:	df000017 	ldw	fp,0(sp)
81139d10:	dec00204 	addi	sp,sp,8
81139d14:	f800283a 	ret

81139d18 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
81139d18:	deffda04 	addi	sp,sp,-152
81139d1c:	de00012e 	bgeu	sp,et,81139d24 <__malloc_lock+0xc>
81139d20:	003b68fa 	trap	3
81139d24:	dfc02515 	stw	ra,148(sp)
81139d28:	df002415 	stw	fp,144(sp)
81139d2c:	df002404 	addi	fp,sp,144
81139d30:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139d34:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
81139d38:	d0a09103 	ldbu	r2,-32188(gp)
81139d3c:	10803fcc 	andi	r2,r2,255
81139d40:	10800060 	cmpeqi	r2,r2,1
81139d44:	10003626 	beq	r2,zero,81139e20 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81139d48:	e0bfe104 	addi	r2,fp,-124
81139d4c:	100b883a 	mov	r5,r2
81139d50:	01003fc4 	movi	r4,255
81139d54:	11424440 	call	81142444 <OSTaskQuery>
81139d58:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81139d5c:	e0bffe83 	ldbu	r2,-6(fp)
81139d60:	10803fcc 	andi	r2,r2,255
81139d64:	1000301e 	bne	r2,zero,81139e28 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81139d68:	e0bfed83 	ldbu	r2,-74(fp)
81139d6c:	10803fcc 	andi	r2,r2,255
81139d70:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
81139d74:	d0a08d17 	ldw	r2,-32204(gp)
81139d78:	e0fffc04 	addi	r3,fp,-16
81139d7c:	180b883a 	mov	r5,r3
81139d80:	1009883a 	mov	r4,r2
81139d84:	1140bfc0 	call	81140bfc <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139d88:	0005303a 	rdctl	r2,status
81139d8c:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139d90:	e0ffe017 	ldw	r3,-128(fp)
81139d94:	00bfff84 	movi	r2,-2
81139d98:	1884703a 	and	r2,r3,r2
81139d9c:	1001703a 	wrctl	status,r2
  
  return context;
81139da0:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
81139da4:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81139da8:	e0bffc0b 	ldhu	r2,-16(fp)
81139dac:	10bfffcc 	andi	r2,r2,65535
81139db0:	10000b1e 	bne	r2,zero,81139de0 <__malloc_lock+0xc8>
81139db4:	d0a01717 	ldw	r2,-32676(gp)
81139db8:	e0ffdd17 	ldw	r3,-140(fp)
81139dbc:	1880081e 	bne	r3,r2,81139de0 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
81139dc0:	d0a08c17 	ldw	r2,-32208(gp)
81139dc4:	10800044 	addi	r2,r2,1
81139dc8:	d0a08c15 	stw	r2,-32208(gp)
81139dcc:	e0bfdc17 	ldw	r2,-144(fp)
81139dd0:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139dd4:	e0bfde17 	ldw	r2,-136(fp)
81139dd8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
81139ddc:	00000e06 	br	81139e18 <__malloc_lock+0x100>
81139de0:	e0bfdc17 	ldw	r2,-144(fp)
81139de4:	e0bfdf15 	stw	r2,-132(fp)
81139de8:	e0bfdf17 	ldw	r2,-132(fp)
81139dec:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
81139df0:	d0a08d17 	ldw	r2,-32204(gp)
81139df4:	e0fffe84 	addi	r3,fp,-6
81139df8:	180d883a 	mov	r6,r3
81139dfc:	000b883a 	mov	r5,zero
81139e00:	1009883a 	mov	r4,r2
81139e04:	114075c0 	call	8114075c <OSSemPend>
    locks  = 1;
81139e08:	00800044 	movi	r2,1
81139e0c:	d0a08c15 	stw	r2,-32208(gp)
    lockid = id;
81139e10:	e0bfdd17 	ldw	r2,-140(fp)
81139e14:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81139e18:	0001883a 	nop
81139e1c:	00000306 	br	81139e2c <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
81139e20:	0001883a 	nop
81139e24:	00000106 	br	81139e2c <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81139e28:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81139e2c:	e037883a 	mov	sp,fp
81139e30:	dfc00117 	ldw	ra,4(sp)
81139e34:	df000017 	ldw	fp,0(sp)
81139e38:	dec00204 	addi	sp,sp,8
81139e3c:	f800283a 	ret

81139e40 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
81139e40:	defff804 	addi	sp,sp,-32
81139e44:	de00012e 	bgeu	sp,et,81139e4c <__malloc_unlock+0xc>
81139e48:	003b68fa 	trap	3
81139e4c:	dfc00715 	stw	ra,28(sp)
81139e50:	df000615 	stw	fp,24(sp)
81139e54:	df000604 	addi	fp,sp,24
81139e58:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139e5c:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
81139e60:	d0a09103 	ldbu	r2,-32188(gp)
81139e64:	10803fcc 	andi	r2,r2,255
81139e68:	10800060 	cmpeqi	r2,r2,1
81139e6c:	10002326 	beq	r2,zero,81139efc <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139e70:	0005303a 	rdctl	r2,status
81139e74:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139e78:	e0fffe17 	ldw	r3,-8(fp)
81139e7c:	00bfff84 	movi	r2,-2
81139e80:	1884703a 	and	r2,r3,r2
81139e84:	1001703a 	wrctl	status,r2
  
  return context;
81139e88:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81139e8c:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
81139e90:	d0a08c17 	ldw	r2,-32208(gp)
81139e94:	1000051e 	bne	r2,zero,81139eac <__malloc_unlock+0x6c>
81139e98:	e0bffa17 	ldw	r2,-24(fp)
81139e9c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139ea0:	e0bffb17 	ldw	r2,-20(fp)
81139ea4:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81139ea8:	00001506 	br	81139f00 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81139eac:	d0a08c17 	ldw	r2,-32208(gp)
81139eb0:	10bfffc4 	addi	r2,r2,-1
81139eb4:	d0a08c15 	stw	r2,-32208(gp)
81139eb8:	d0a08c17 	ldw	r2,-32208(gp)
81139ebc:	10000a1e 	bne	r2,zero,81139ee8 <__malloc_unlock+0xa8>
  {
    lockid = -1;
81139ec0:	00bfffc4 	movi	r2,-1
81139ec4:	d0a01715 	stw	r2,-32676(gp)
81139ec8:	e0bffa17 	ldw	r2,-24(fp)
81139ecc:	e0bffc15 	stw	r2,-16(fp)
81139ed0:	e0bffc17 	ldw	r2,-16(fp)
81139ed4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81139ed8:	d0a08d17 	ldw	r2,-32204(gp)
81139edc:	1009883a 	mov	r4,r2
81139ee0:	1140ae40 	call	81140ae4 <OSSemPost>
81139ee4:	00000606 	br	81139f00 <__malloc_unlock+0xc0>
81139ee8:	e0bffa17 	ldw	r2,-24(fp)
81139eec:	e0bffd15 	stw	r2,-12(fp)
81139ef0:	e0bffd17 	ldw	r2,-12(fp)
81139ef4:	1001703a 	wrctl	status,r2
81139ef8:	00000106 	br	81139f00 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
81139efc:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81139f00:	e037883a 	mov	sp,fp
81139f04:	dfc00117 	ldw	ra,4(sp)
81139f08:	df000017 	ldw	fp,0(sp)
81139f0c:	dec00204 	addi	sp,sp,8
81139f10:	f800283a 	ret

81139f14 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81139f14:	defff704 	addi	sp,sp,-36
81139f18:	de00012e 	bgeu	sp,et,81139f20 <OSEventNameGet+0xc>
81139f1c:	003b68fa 	trap	3
81139f20:	dfc00815 	stw	ra,32(sp)
81139f24:	df000715 	stw	fp,28(sp)
81139f28:	df000704 	addi	fp,sp,28
81139f2c:	e13ffd15 	stw	r4,-12(fp)
81139f30:	e17ffe15 	stw	r5,-8(fp)
81139f34:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139f38:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81139f3c:	e0bfff17 	ldw	r2,-4(fp)
81139f40:	1000021e 	bne	r2,zero,81139f4c <OSEventNameGet+0x38>
        return (0);
81139f44:	0005883a 	mov	r2,zero
81139f48:	00003706 	br	8113a028 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81139f4c:	e0bffd17 	ldw	r2,-12(fp)
81139f50:	1000051e 	bne	r2,zero,81139f68 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
81139f54:	e0bfff17 	ldw	r2,-4(fp)
81139f58:	00c00104 	movi	r3,4
81139f5c:	10c00005 	stb	r3,0(r2)
        return (0);
81139f60:	0005883a 	mov	r2,zero
81139f64:	00003006 	br	8113a028 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81139f68:	e0bffe17 	ldw	r2,-8(fp)
81139f6c:	1000051e 	bne	r2,zero,81139f84 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81139f70:	e0bfff17 	ldw	r2,-4(fp)
81139f74:	00c00304 	movi	r3,12
81139f78:	10c00005 	stb	r3,0(r2)
        return (0);
81139f7c:	0005883a 	mov	r2,zero
81139f80:	00002906 	br	8113a028 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81139f84:	d0a0a103 	ldbu	r2,-32124(gp)
81139f88:	10803fcc 	andi	r2,r2,255
81139f8c:	10000526 	beq	r2,zero,81139fa4 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
81139f90:	e0bfff17 	ldw	r2,-4(fp)
81139f94:	00c00444 	movi	r3,17
81139f98:	10c00005 	stb	r3,0(r2)
        return (0);
81139f9c:	0005883a 	mov	r2,zero
81139fa0:	00002106 	br	8113a028 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
81139fa4:	e0bffd17 	ldw	r2,-12(fp)
81139fa8:	10800003 	ldbu	r2,0(r2)
81139fac:	10803fcc 	andi	r2,r2,255
81139fb0:	10bfffc4 	addi	r2,r2,-1
81139fb4:	10800128 	cmpgeui	r2,r2,4
81139fb8:	10000526 	beq	r2,zero,81139fd0 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81139fbc:	e0bfff17 	ldw	r2,-4(fp)
81139fc0:	00c00044 	movi	r3,1
81139fc4:	10c00005 	stb	r3,0(r2)
             return (0);
81139fc8:	0005883a 	mov	r2,zero
81139fcc:	00001606 	br	8113a028 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81139fd0:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139fd4:	0005303a 	rdctl	r2,status
81139fd8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139fdc:	e0fffb17 	ldw	r3,-20(fp)
81139fe0:	00bfff84 	movi	r2,-2
81139fe4:	1884703a 	and	r2,r3,r2
81139fe8:	1001703a 	wrctl	status,r2
  
  return context;
81139fec:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
81139ff0:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
81139ff4:	e0bffd17 	ldw	r2,-12(fp)
81139ff8:	10800444 	addi	r2,r2,17
81139ffc:	100b883a 	mov	r5,r2
8113a000:	e13ffe17 	ldw	r4,-8(fp)
8113a004:	113ba000 	call	8113ba00 <OS_StrCopy>
8113a008:	e0bffa05 	stb	r2,-24(fp)
8113a00c:	e0bff917 	ldw	r2,-28(fp)
8113a010:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a014:	e0bffc17 	ldw	r2,-16(fp)
8113a018:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a01c:	e0bfff17 	ldw	r2,-4(fp)
8113a020:	10000005 	stb	zero,0(r2)
    return (len);
8113a024:	e0bffa03 	ldbu	r2,-24(fp)
}
8113a028:	e037883a 	mov	sp,fp
8113a02c:	dfc00117 	ldw	ra,4(sp)
8113a030:	df000017 	ldw	fp,0(sp)
8113a034:	dec00204 	addi	sp,sp,8
8113a038:	f800283a 	ret

8113a03c <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
8113a03c:	defff604 	addi	sp,sp,-40
8113a040:	de00012e 	bgeu	sp,et,8113a048 <OSEventNameSet+0xc>
8113a044:	003b68fa 	trap	3
8113a048:	dfc00915 	stw	ra,36(sp)
8113a04c:	df000815 	stw	fp,32(sp)
8113a050:	df000804 	addi	fp,sp,32
8113a054:	e13ffd15 	stw	r4,-12(fp)
8113a058:	e17ffe15 	stw	r5,-8(fp)
8113a05c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a060:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113a064:	e0bfff17 	ldw	r2,-4(fp)
8113a068:	10004026 	beq	r2,zero,8113a16c <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
8113a06c:	e0bffd17 	ldw	r2,-12(fp)
8113a070:	1000041e 	bne	r2,zero,8113a084 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113a074:	e0bfff17 	ldw	r2,-4(fp)
8113a078:	00c00104 	movi	r3,4
8113a07c:	10c00005 	stb	r3,0(r2)
        return;
8113a080:	00003b06 	br	8113a170 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113a084:	e0bffe17 	ldw	r2,-8(fp)
8113a088:	1000041e 	bne	r2,zero,8113a09c <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113a08c:	e0bfff17 	ldw	r2,-4(fp)
8113a090:	00c00304 	movi	r3,12
8113a094:	10c00005 	stb	r3,0(r2)
        return;
8113a098:	00003506 	br	8113a170 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113a09c:	d0a0a103 	ldbu	r2,-32124(gp)
8113a0a0:	10803fcc 	andi	r2,r2,255
8113a0a4:	10000426 	beq	r2,zero,8113a0b8 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113a0a8:	e0bfff17 	ldw	r2,-4(fp)
8113a0ac:	00c00484 	movi	r3,18
8113a0b0:	10c00005 	stb	r3,0(r2)
        return;
8113a0b4:	00002e06 	br	8113a170 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
8113a0b8:	e0bffd17 	ldw	r2,-12(fp)
8113a0bc:	10800003 	ldbu	r2,0(r2)
8113a0c0:	10803fcc 	andi	r2,r2,255
8113a0c4:	10bfffc4 	addi	r2,r2,-1
8113a0c8:	10800128 	cmpgeui	r2,r2,4
8113a0cc:	10000426 	beq	r2,zero,8113a0e0 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
8113a0d0:	e0bfff17 	ldw	r2,-4(fp)
8113a0d4:	00c00044 	movi	r3,1
8113a0d8:	10c00005 	stb	r3,0(r2)
             return;
8113a0dc:	00002406 	br	8113a170 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
8113a0e0:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a0e4:	0005303a 	rdctl	r2,status
8113a0e8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a0ec:	e0fffc17 	ldw	r3,-16(fp)
8113a0f0:	00bfff84 	movi	r2,-2
8113a0f4:	1884703a 	and	r2,r3,r2
8113a0f8:	1001703a 	wrctl	status,r2
  
  return context;
8113a0fc:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
8113a100:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
8113a104:	e13ffe17 	ldw	r4,-8(fp)
8113a108:	113ba7c0 	call	8113ba7c <OS_StrLen>
8113a10c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
8113a110:	e0bffa03 	ldbu	r2,-24(fp)
8113a114:	10800830 	cmpltui	r2,r2,32
8113a118:	1000081e 	bne	r2,zero,8113a13c <OSEventNameSet+0x100>
8113a11c:	e0bff817 	ldw	r2,-32(fp)
8113a120:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a124:	e0bff917 	ldw	r2,-28(fp)
8113a128:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
8113a12c:	e0bfff17 	ldw	r2,-4(fp)
8113a130:	00c002c4 	movi	r3,11
8113a134:	10c00005 	stb	r3,0(r2)
        return;
8113a138:	00000d06 	br	8113a170 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
8113a13c:	e0bffd17 	ldw	r2,-12(fp)
8113a140:	10800444 	addi	r2,r2,17
8113a144:	e17ffe17 	ldw	r5,-8(fp)
8113a148:	1009883a 	mov	r4,r2
8113a14c:	113ba000 	call	8113ba00 <OS_StrCopy>
8113a150:	e0bff817 	ldw	r2,-32(fp)
8113a154:	e0bffb15 	stw	r2,-20(fp)
8113a158:	e0bffb17 	ldw	r2,-20(fp)
8113a15c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a160:	e0bfff17 	ldw	r2,-4(fp)
8113a164:	10000005 	stb	zero,0(r2)
8113a168:	00000106 	br	8113a170 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113a16c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113a170:	e037883a 	mov	sp,fp
8113a174:	dfc00117 	ldw	ra,4(sp)
8113a178:	df000017 	ldw	fp,0(sp)
8113a17c:	dec00204 	addi	sp,sp,8
8113a180:	f800283a 	ret

8113a184 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
8113a184:	deffed04 	addi	sp,sp,-76
8113a188:	de00012e 	bgeu	sp,et,8113a190 <OSEventPendMulti+0xc>
8113a18c:	003b68fa 	trap	3
8113a190:	dfc01215 	stw	ra,72(sp)
8113a194:	df001115 	stw	fp,68(sp)
8113a198:	df001104 	addi	fp,sp,68
8113a19c:	e13ffc15 	stw	r4,-16(fp)
8113a1a0:	e17ffd15 	stw	r5,-12(fp)
8113a1a4:	e1bffe15 	stw	r6,-8(fp)
8113a1a8:	3805883a 	mov	r2,r7
8113a1ac:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
8113a1b0:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
8113a1b4:	e0800217 	ldw	r2,8(fp)
8113a1b8:	1000021e 	bne	r2,zero,8113a1c4 <OSEventPendMulti+0x40>
        return (0);
8113a1bc:	0005883a 	mov	r2,zero
8113a1c0:	00015006 	br	8113a704 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
8113a1c4:	e0bffc17 	ldw	r2,-16(fp)
8113a1c8:	1000051e 	bne	r2,zero,8113a1e0 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
8113a1cc:	e0800217 	ldw	r2,8(fp)
8113a1d0:	00c00104 	movi	r3,4
8113a1d4:	10c00005 	stb	r3,0(r2)
        return (0);
8113a1d8:	0005883a 	mov	r2,zero
8113a1dc:	00014906 	br	8113a704 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
8113a1e0:	e0bffd17 	ldw	r2,-12(fp)
8113a1e4:	1000051e 	bne	r2,zero,8113a1fc <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
8113a1e8:	e0800217 	ldw	r2,8(fp)
8113a1ec:	00c00104 	movi	r3,4
8113a1f0:	10c00005 	stb	r3,0(r2)
        return (0);
8113a1f4:	0005883a 	mov	r2,zero
8113a1f8:	00014206 	br	8113a704 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
8113a1fc:	e0bffe17 	ldw	r2,-8(fp)
8113a200:	1000051e 	bne	r2,zero,8113a218 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
8113a204:	e0800217 	ldw	r2,8(fp)
8113a208:	00c00104 	movi	r3,4
8113a20c:	10c00005 	stb	r3,0(r2)
        return (0);
8113a210:	0005883a 	mov	r2,zero
8113a214:	00013b06 	br	8113a704 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
8113a218:	e0bffd17 	ldw	r2,-12(fp)
8113a21c:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
8113a220:	e0bffc17 	ldw	r2,-16(fp)
8113a224:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
8113a228:	e0bfef17 	ldw	r2,-68(fp)
8113a22c:	10800017 	ldw	r2,0(r2)
8113a230:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
8113a234:	00001506 	br	8113a28c <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
8113a238:	e0bff017 	ldw	r2,-64(fp)
8113a23c:	10800003 	ldbu	r2,0(r2)
8113a240:	10803fcc 	andi	r2,r2,255
8113a244:	10c000a0 	cmpeqi	r3,r2,2
8113a248:	1800071e 	bne	r3,zero,8113a268 <OSEventPendMulti+0xe4>
8113a24c:	108000e0 	cmpeqi	r2,r2,3
8113a250:	1000071e 	bne	r2,zero,8113a270 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
8113a254:	e0800217 	ldw	r2,8(fp)
8113a258:	00c00044 	movi	r3,1
8113a25c:	10c00005 	stb	r3,0(r2)
                 return (0);
8113a260:	0005883a 	mov	r2,zero
8113a264:	00012706 	br	8113a704 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
8113a268:	0001883a 	nop
8113a26c:	00000106 	br	8113a274 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
8113a270:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
8113a274:	e0bfef17 	ldw	r2,-68(fp)
8113a278:	10800104 	addi	r2,r2,4
8113a27c:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8113a280:	e0bfef17 	ldw	r2,-68(fp)
8113a284:	10800017 	ldw	r2,0(r2)
8113a288:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
8113a28c:	e0bff017 	ldw	r2,-64(fp)
8113a290:	103fe91e 	bne	r2,zero,8113a238 <__reset+0xfb11a238>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
8113a294:	d0a0a103 	ldbu	r2,-32124(gp)
8113a298:	10803fcc 	andi	r2,r2,255
8113a29c:	10000526 	beq	r2,zero,8113a2b4 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
8113a2a0:	e0800217 	ldw	r2,8(fp)
8113a2a4:	00c00084 	movi	r3,2
8113a2a8:	10c00005 	stb	r3,0(r2)
        return (0);
8113a2ac:	0005883a 	mov	r2,zero
8113a2b0:	00011406 	br	8113a704 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
8113a2b4:	d0a08f03 	ldbu	r2,-32196(gp)
8113a2b8:	10803fcc 	andi	r2,r2,255
8113a2bc:	10000526 	beq	r2,zero,8113a2d4 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
8113a2c0:	e0800217 	ldw	r2,8(fp)
8113a2c4:	00c00344 	movi	r3,13
8113a2c8:	10c00005 	stb	r3,0(r2)
        return (0);
8113a2cc:	0005883a 	mov	r2,zero
8113a2d0:	00010c06 	br	8113a704 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a2d4:	0005303a 	rdctl	r2,status
8113a2d8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a2dc:	e0fffb17 	ldw	r3,-20(fp)
8113a2e0:	00bfff84 	movi	r2,-2
8113a2e4:	1884703a 	and	r2,r3,r2
8113a2e8:	1001703a 	wrctl	status,r2
  
  return context;
8113a2ec:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113a2f0:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
8113a2f4:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
8113a2f8:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
8113a2fc:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
8113a300:	e0bffc17 	ldw	r2,-16(fp)
8113a304:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
8113a308:	e0bfef17 	ldw	r2,-68(fp)
8113a30c:	10800017 	ldw	r2,0(r2)
8113a310:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
8113a314:	00006406 	br	8113a4a8 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
8113a318:	e0bff017 	ldw	r2,-64(fp)
8113a31c:	10800003 	ldbu	r2,0(r2)
8113a320:	10803fcc 	andi	r2,r2,255
8113a324:	10c000a0 	cmpeqi	r3,r2,2
8113a328:	18001f1e 	bne	r3,zero,8113a3a8 <OSEventPendMulti+0x224>
8113a32c:	108000e0 	cmpeqi	r2,r2,3
8113a330:	10004c26 	beq	r2,zero,8113a464 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
8113a334:	e0bff017 	ldw	r2,-64(fp)
8113a338:	1080020b 	ldhu	r2,8(r2)
8113a33c:	10bfffcc 	andi	r2,r2,65535
8113a340:	10001526 	beq	r2,zero,8113a398 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
8113a344:	e0bff017 	ldw	r2,-64(fp)
8113a348:	1080020b 	ldhu	r2,8(r2)
8113a34c:	10bfffc4 	addi	r2,r2,-1
8113a350:	1007883a 	mov	r3,r2
8113a354:	e0bff017 	ldw	r2,-64(fp)
8113a358:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
8113a35c:	e0bffd17 	ldw	r2,-12(fp)
8113a360:	10c00104 	addi	r3,r2,4
8113a364:	e0fffd15 	stw	r3,-12(fp)
8113a368:	e0fff017 	ldw	r3,-64(fp)
8113a36c:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
8113a370:	00800044 	movi	r2,1
8113a374:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
8113a378:	e0bffe17 	ldw	r2,-8(fp)
8113a37c:	10c00104 	addi	r3,r2,4
8113a380:	e0fffe15 	stw	r3,-8(fp)
8113a384:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
8113a388:	e0bff18b 	ldhu	r2,-58(fp)
8113a38c:	10800044 	addi	r2,r2,1
8113a390:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
8113a394:	00003e06 	br	8113a490 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
8113a398:	e0bff203 	ldbu	r2,-56(fp)
8113a39c:	10800054 	ori	r2,r2,1
8113a3a0:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8113a3a4:	00003a06 	br	8113a490 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
8113a3a8:	e0bff017 	ldw	r2,-64(fp)
8113a3ac:	10800117 	ldw	r2,4(r2)
8113a3b0:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
8113a3b4:	e0bff517 	ldw	r2,-44(fp)
8113a3b8:	1080058b 	ldhu	r2,22(r2)
8113a3bc:	10bfffcc 	andi	r2,r2,65535
8113a3c0:	10002426 	beq	r2,zero,8113a454 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
8113a3c4:	e0bffe17 	ldw	r2,-8(fp)
8113a3c8:	10c00104 	addi	r3,r2,4
8113a3cc:	e0fffe15 	stw	r3,-8(fp)
8113a3d0:	e0fff517 	ldw	r3,-44(fp)
8113a3d4:	18c00417 	ldw	r3,16(r3)
8113a3d8:	19400104 	addi	r5,r3,4
8113a3dc:	e13ff517 	ldw	r4,-44(fp)
8113a3e0:	21400415 	stw	r5,16(r4)
8113a3e4:	18c00017 	ldw	r3,0(r3)
8113a3e8:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
8113a3ec:	e0bff517 	ldw	r2,-44(fp)
8113a3f0:	10c00417 	ldw	r3,16(r2)
8113a3f4:	e0bff517 	ldw	r2,-44(fp)
8113a3f8:	10800217 	ldw	r2,8(r2)
8113a3fc:	1880041e 	bne	r3,r2,8113a410 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
8113a400:	e0bff517 	ldw	r2,-44(fp)
8113a404:	10c00117 	ldw	r3,4(r2)
8113a408:	e0bff517 	ldw	r2,-44(fp)
8113a40c:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
8113a410:	e0bff517 	ldw	r2,-44(fp)
8113a414:	1080058b 	ldhu	r2,22(r2)
8113a418:	10bfffc4 	addi	r2,r2,-1
8113a41c:	1007883a 	mov	r3,r2
8113a420:	e0bff517 	ldw	r2,-44(fp)
8113a424:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
8113a428:	e0bffd17 	ldw	r2,-12(fp)
8113a42c:	10c00104 	addi	r3,r2,4
8113a430:	e0fffd15 	stw	r3,-12(fp)
8113a434:	e0fff017 	ldw	r3,-64(fp)
8113a438:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
8113a43c:	00800044 	movi	r2,1
8113a440:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
8113a444:	e0bff18b 	ldhu	r2,-58(fp)
8113a448:	10800044 	addi	r2,r2,1
8113a44c:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
8113a450:	00000f06 	br	8113a490 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
8113a454:	e0bff203 	ldbu	r2,-56(fp)
8113a458:	10800114 	ori	r2,r2,4
8113a45c:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8113a460:	00000b06 	br	8113a490 <OSEventPendMulti+0x30c>
8113a464:	e0bff317 	ldw	r2,-52(fp)
8113a468:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a46c:	e0bff417 	ldw	r2,-48(fp)
8113a470:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
8113a474:	e0bffd17 	ldw	r2,-12(fp)
8113a478:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
8113a47c:	e0800217 	ldw	r2,8(fp)
8113a480:	00c00044 	movi	r3,1
8113a484:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
8113a488:	e0bff18b 	ldhu	r2,-58(fp)
8113a48c:	00009d06 	br	8113a704 <OSEventPendMulti+0x580>
        }
        pevents++;
8113a490:	e0bfef17 	ldw	r2,-68(fp)
8113a494:	10800104 	addi	r2,r2,4
8113a498:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8113a49c:	e0bfef17 	ldw	r2,-68(fp)
8113a4a0:	10800017 	ldw	r2,0(r2)
8113a4a4:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
8113a4a8:	e0bff017 	ldw	r2,-64(fp)
8113a4ac:	103f9a1e 	bne	r2,zero,8113a318 <__reset+0xfb11a318>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
8113a4b0:	e0bff103 	ldbu	r2,-60(fp)
8113a4b4:	10800058 	cmpnei	r2,r2,1
8113a4b8:	10000a1e 	bne	r2,zero,8113a4e4 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
8113a4bc:	e0bffd17 	ldw	r2,-12(fp)
8113a4c0:	10000015 	stw	zero,0(r2)
8113a4c4:	e0bff317 	ldw	r2,-52(fp)
8113a4c8:	e0bff615 	stw	r2,-40(fp)
8113a4cc:	e0bff617 	ldw	r2,-40(fp)
8113a4d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
8113a4d4:	e0800217 	ldw	r2,8(fp)
8113a4d8:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
8113a4dc:	e0bff18b 	ldhu	r2,-58(fp)
8113a4e0:	00008806 	br	8113a704 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
8113a4e4:	d0a0a217 	ldw	r2,-32120(gp)
8113a4e8:	d0e0a217 	ldw	r3,-32120(gp)
8113a4ec:	19000c03 	ldbu	r4,48(r3)
8113a4f0:	e0fff203 	ldbu	r3,-56(fp)
8113a4f4:	20c6b03a 	or	r3,r4,r3
8113a4f8:	1809883a 	mov	r4,r3
8113a4fc:	00ffe004 	movi	r3,-128
8113a500:	20c6b03a 	or	r3,r4,r3
8113a504:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113a508:	d0a0a217 	ldw	r2,-32120(gp)
8113a50c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
8113a510:	d0a0a217 	ldw	r2,-32120(gp)
8113a514:	e0ffff0b 	ldhu	r3,-4(fp)
8113a518:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
8113a51c:	e13ffc17 	ldw	r4,-16(fp)
8113a520:	113b0a80 	call	8113b0a8 <OS_EventTaskWaitMulti>
8113a524:	e0bff317 	ldw	r2,-52(fp)
8113a528:	e0bff915 	stw	r2,-28(fp)
8113a52c:	e0bff917 	ldw	r2,-28(fp)
8113a530:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
8113a534:	113b8ac0 	call	8113b8ac <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a538:	0005303a 	rdctl	r2,status
8113a53c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a540:	e0fff717 	ldw	r3,-36(fp)
8113a544:	00bfff84 	movi	r2,-2
8113a548:	1884703a 	and	r2,r3,r2
8113a54c:	1001703a 	wrctl	status,r2
  
  return context;
8113a550:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
8113a554:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
8113a558:	d0a0a217 	ldw	r2,-32120(gp)
8113a55c:	10800c43 	ldbu	r2,49(r2)
8113a560:	10803fcc 	andi	r2,r2,255
8113a564:	10000226 	beq	r2,zero,8113a570 <OSEventPendMulti+0x3ec>
8113a568:	108000a0 	cmpeqi	r2,r2,2
8113a56c:	10001826 	beq	r2,zero,8113a5d0 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
8113a570:	d0a0a217 	ldw	r2,-32120(gp)
8113a574:	10800717 	ldw	r2,28(r2)
8113a578:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
8113a57c:	e0bff017 	ldw	r2,-64(fp)
8113a580:	10000b26 	beq	r2,zero,8113a5b0 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
8113a584:	e0bffd17 	ldw	r2,-12(fp)
8113a588:	10c00104 	addi	r3,r2,4
8113a58c:	e0fffd15 	stw	r3,-12(fp)
8113a590:	e0fff017 	ldw	r3,-64(fp)
8113a594:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
8113a598:	e0bffd17 	ldw	r2,-12(fp)
8113a59c:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
8113a5a0:	e0bff18b 	ldhu	r2,-58(fp)
8113a5a4:	10800044 	addi	r2,r2,1
8113a5a8:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
8113a5ac:	00000d06 	br	8113a5e4 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
8113a5b0:	d0a0a217 	ldw	r2,-32120(gp)
8113a5b4:	00c00044 	movi	r3,1
8113a5b8:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
8113a5bc:	d0a0a217 	ldw	r2,-32120(gp)
8113a5c0:	e17ffc17 	ldw	r5,-16(fp)
8113a5c4:	1009883a 	mov	r4,r2
8113a5c8:	113b2c00 	call	8113b2c0 <OS_EventTaskRemoveMulti>
             }
			 break;
8113a5cc:	00000506 	br	8113a5e4 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
8113a5d0:	d0a0a217 	ldw	r2,-32120(gp)
8113a5d4:	e17ffc17 	ldw	r5,-16(fp)
8113a5d8:	1009883a 	mov	r4,r2
8113a5dc:	113b2c00 	call	8113b2c0 <OS_EventTaskRemoveMulti>
             break;
8113a5e0:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
8113a5e4:	d0a0a217 	ldw	r2,-32120(gp)
8113a5e8:	10800c43 	ldbu	r2,49(r2)
8113a5ec:	10803fcc 	andi	r2,r2,255
8113a5f0:	10000326 	beq	r2,zero,8113a600 <OSEventPendMulti+0x47c>
8113a5f4:	108000a0 	cmpeqi	r2,r2,2
8113a5f8:	1000231e 	bne	r2,zero,8113a688 <OSEventPendMulti+0x504>
8113a5fc:	00002a06 	br	8113a6a8 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
8113a600:	e0bff017 	ldw	r2,-64(fp)
8113a604:	10800003 	ldbu	r2,0(r2)
8113a608:	10803fcc 	andi	r2,r2,255
8113a60c:	0080100e 	bge	zero,r2,8113a650 <OSEventPendMulti+0x4cc>
8113a610:	10c000d0 	cmplti	r3,r2,3
8113a614:	1800071e 	bne	r3,zero,8113a634 <OSEventPendMulti+0x4b0>
8113a618:	108000e0 	cmpeqi	r2,r2,3
8113a61c:	10000c26 	beq	r2,zero,8113a650 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
8113a620:	e0bffe17 	ldw	r2,-8(fp)
8113a624:	10c00104 	addi	r3,r2,4
8113a628:	e0fffe15 	stw	r3,-8(fp)
8113a62c:	10000015 	stw	zero,0(r2)
                      break;
8113a630:	00001206 	br	8113a67c <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
8113a634:	e0bffe17 	ldw	r2,-8(fp)
8113a638:	10c00104 	addi	r3,r2,4
8113a63c:	e0fffe15 	stw	r3,-8(fp)
8113a640:	d0e0a217 	ldw	r3,-32120(gp)
8113a644:	18c00917 	ldw	r3,36(r3)
8113a648:	10c00015 	stw	r3,0(r2)
                      break;
8113a64c:	00000b06 	br	8113a67c <OSEventPendMulti+0x4f8>
8113a650:	e0bff317 	ldw	r2,-52(fp)
8113a654:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a658:	e0bff817 	ldw	r2,-32(fp)
8113a65c:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
8113a660:	e0bffd17 	ldw	r2,-12(fp)
8113a664:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
8113a668:	e0800217 	ldw	r2,8(fp)
8113a66c:	00c00044 	movi	r3,1
8113a670:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
8113a674:	e0bff18b 	ldhu	r2,-58(fp)
8113a678:	00002206 	br	8113a704 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
8113a67c:	e0800217 	ldw	r2,8(fp)
8113a680:	10000005 	stb	zero,0(r2)
             break;
8113a684:	00001006 	br	8113a6c8 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
8113a688:	e0bffe17 	ldw	r2,-8(fp)
8113a68c:	10c00104 	addi	r3,r2,4
8113a690:	e0fffe15 	stw	r3,-8(fp)
8113a694:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
8113a698:	e0800217 	ldw	r2,8(fp)
8113a69c:	00c00384 	movi	r3,14
8113a6a0:	10c00005 	stb	r3,0(r2)
             break;
8113a6a4:	00000806 	br	8113a6c8 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
8113a6a8:	e0bffe17 	ldw	r2,-8(fp)
8113a6ac:	10c00104 	addi	r3,r2,4
8113a6b0:	e0fffe15 	stw	r3,-8(fp)
8113a6b4:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
8113a6b8:	e0800217 	ldw	r2,8(fp)
8113a6bc:	00c00284 	movi	r3,10
8113a6c0:	10c00005 	stb	r3,0(r2)
             break;
8113a6c4:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
8113a6c8:	d0a0a217 	ldw	r2,-32120(gp)
8113a6cc:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
8113a6d0:	d0a0a217 	ldw	r2,-32120(gp)
8113a6d4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
8113a6d8:	d0a0a217 	ldw	r2,-32120(gp)
8113a6dc:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113a6e0:	d0a0a217 	ldw	r2,-32120(gp)
8113a6e4:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
8113a6e8:	d0a0a217 	ldw	r2,-32120(gp)
8113a6ec:	10000915 	stw	zero,36(r2)
8113a6f0:	e0bff317 	ldw	r2,-52(fp)
8113a6f4:	e0bffa15 	stw	r2,-24(fp)
8113a6f8:	e0bffa17 	ldw	r2,-24(fp)
8113a6fc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
8113a700:	e0bff18b 	ldhu	r2,-58(fp)
}
8113a704:	e037883a 	mov	sp,fp
8113a708:	dfc00117 	ldw	ra,4(sp)
8113a70c:	df000017 	ldw	fp,0(sp)
8113a710:	dec00204 	addi	sp,sp,8
8113a714:	f800283a 	ret

8113a718 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
8113a718:	defffe04 	addi	sp,sp,-8
8113a71c:	de00012e 	bgeu	sp,et,8113a724 <OSInit+0xc>
8113a720:	003b68fa 	trap	3
8113a724:	dfc00115 	stw	ra,4(sp)
8113a728:	df000015 	stw	fp,0(sp)
8113a72c:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
8113a730:	114cc1c0 	call	8114cc1c <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
8113a734:	113b5200 	call	8113b520 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
8113a738:	113b5700 	call	8113b570 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
8113a73c:	113b6f40 	call	8113b6f4 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
8113a740:	113b4380 	call	8113b438 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
8113a744:	113d6b40 	call	8113d6b4 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
8113a748:	113dffc0 	call	8113dffc <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
8113a74c:	11402cc0 	call	811402cc <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
8113a750:	113b5e40 	call	8113b5e4 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
8113a754:	113b66c0 	call	8113b66c <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
8113a758:	11436700 	call	81143670 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
8113a75c:	114cc480 	call	8114cc48 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
8113a760:	113bfd00 	call	8113bfd0 <OSDebugInit>
#endif
}
8113a764:	0001883a 	nop
8113a768:	e037883a 	mov	sp,fp
8113a76c:	dfc00117 	ldw	ra,4(sp)
8113a770:	df000017 	ldw	fp,0(sp)
8113a774:	dec00204 	addi	sp,sp,8
8113a778:	f800283a 	ret

8113a77c <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
8113a77c:	deffff04 	addi	sp,sp,-4
8113a780:	de00012e 	bgeu	sp,et,8113a788 <OSIntEnter+0xc>
8113a784:	003b68fa 	trap	3
8113a788:	df000015 	stw	fp,0(sp)
8113a78c:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
8113a790:	d0a09103 	ldbu	r2,-32188(gp)
8113a794:	10803fcc 	andi	r2,r2,255
8113a798:	10800058 	cmpnei	r2,r2,1
8113a79c:	1000071e 	bne	r2,zero,8113a7bc <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
8113a7a0:	d0a0a103 	ldbu	r2,-32124(gp)
8113a7a4:	10803fcc 	andi	r2,r2,255
8113a7a8:	10803fe0 	cmpeqi	r2,r2,255
8113a7ac:	1000031e 	bne	r2,zero,8113a7bc <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
8113a7b0:	d0a0a103 	ldbu	r2,-32124(gp)
8113a7b4:	10800044 	addi	r2,r2,1
8113a7b8:	d0a0a105 	stb	r2,-32124(gp)
        }
    }
}
8113a7bc:	0001883a 	nop
8113a7c0:	e037883a 	mov	sp,fp
8113a7c4:	df000017 	ldw	fp,0(sp)
8113a7c8:	dec00104 	addi	sp,sp,4
8113a7cc:	f800283a 	ret

8113a7d0 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
8113a7d0:	defffb04 	addi	sp,sp,-20
8113a7d4:	de00012e 	bgeu	sp,et,8113a7dc <OSIntExit+0xc>
8113a7d8:	003b68fa 	trap	3
8113a7dc:	dfc00415 	stw	ra,16(sp)
8113a7e0:	df000315 	stw	fp,12(sp)
8113a7e4:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113a7e8:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
8113a7ec:	d0a09103 	ldbu	r2,-32188(gp)
8113a7f0:	10803fcc 	andi	r2,r2,255
8113a7f4:	10800058 	cmpnei	r2,r2,1
8113a7f8:	10002f1e 	bne	r2,zero,8113a8b8 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a7fc:	0005303a 	rdctl	r2,status
8113a800:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a804:	e0ffff17 	ldw	r3,-4(fp)
8113a808:	00bfff84 	movi	r2,-2
8113a80c:	1884703a 	and	r2,r3,r2
8113a810:	1001703a 	wrctl	status,r2
  
  return context;
8113a814:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8113a818:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
8113a81c:	d0a0a103 	ldbu	r2,-32124(gp)
8113a820:	10803fcc 	andi	r2,r2,255
8113a824:	10000326 	beq	r2,zero,8113a834 <OSIntExit+0x64>
            OSIntNesting--;
8113a828:	d0a0a103 	ldbu	r2,-32124(gp)
8113a82c:	10bfffc4 	addi	r2,r2,-1
8113a830:	d0a0a105 	stb	r2,-32124(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
8113a834:	d0a0a103 	ldbu	r2,-32124(gp)
8113a838:	10803fcc 	andi	r2,r2,255
8113a83c:	10001a1e 	bne	r2,zero,8113a8a8 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
8113a840:	d0a08f03 	ldbu	r2,-32196(gp)
8113a844:	10803fcc 	andi	r2,r2,255
8113a848:	1000171e 	bne	r2,zero,8113a8a8 <OSIntExit+0xd8>
                OS_SchedNew();
8113a84c:	113b9840 	call	8113b984 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
8113a850:	d0e09383 	ldbu	r3,-32178(gp)
8113a854:	d0a093c3 	ldbu	r2,-32177(gp)
8113a858:	18c03fcc 	andi	r3,r3,255
8113a85c:	10803fcc 	andi	r2,r2,255
8113a860:	18801126 	beq	r3,r2,8113a8a8 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
8113a864:	d0a09383 	ldbu	r2,-32178(gp)
8113a868:	10c03fcc 	andi	r3,r2,255
8113a86c:	00a045f4 	movhi	r2,33047
8113a870:	10ba6804 	addi	r2,r2,-5728
8113a874:	18c7883a 	add	r3,r3,r3
8113a878:	18c7883a 	add	r3,r3,r3
8113a87c:	10c5883a 	add	r2,r2,r3
8113a880:	10800017 	ldw	r2,0(r2)
8113a884:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
8113a888:	d0a09c17 	ldw	r2,-32144(gp)
8113a88c:	10c00e17 	ldw	r3,56(r2)
8113a890:	18c00044 	addi	r3,r3,1
8113a894:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
8113a898:	d0a09617 	ldw	r2,-32168(gp)
8113a89c:	10800044 	addi	r2,r2,1
8113a8a0:	d0a09615 	stw	r2,-32168(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
8113a8a4:	114c8dc0 	call	8114c8dc <OSCtxSw>
8113a8a8:	e0bffd17 	ldw	r2,-12(fp)
8113a8ac:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a8b0:	e0bffe17 	ldw	r2,-8(fp)
8113a8b4:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
8113a8b8:	0001883a 	nop
8113a8bc:	e037883a 	mov	sp,fp
8113a8c0:	dfc00117 	ldw	ra,4(sp)
8113a8c4:	df000017 	ldw	fp,0(sp)
8113a8c8:	dec00204 	addi	sp,sp,8
8113a8cc:	f800283a 	ret

8113a8d0 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
8113a8d0:	defffc04 	addi	sp,sp,-16
8113a8d4:	de00012e 	bgeu	sp,et,8113a8dc <OSSchedLock+0xc>
8113a8d8:	003b68fa 	trap	3
8113a8dc:	df000315 	stw	fp,12(sp)
8113a8e0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a8e4:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
8113a8e8:	d0a09103 	ldbu	r2,-32188(gp)
8113a8ec:	10803fcc 	andi	r2,r2,255
8113a8f0:	10800058 	cmpnei	r2,r2,1
8113a8f4:	1000161e 	bne	r2,zero,8113a950 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a8f8:	0005303a 	rdctl	r2,status
8113a8fc:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a900:	e0ffff17 	ldw	r3,-4(fp)
8113a904:	00bfff84 	movi	r2,-2
8113a908:	1884703a 	and	r2,r3,r2
8113a90c:	1001703a 	wrctl	status,r2
  
  return context;
8113a910:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8113a914:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
8113a918:	d0a0a103 	ldbu	r2,-32124(gp)
8113a91c:	10803fcc 	andi	r2,r2,255
8113a920:	1000071e 	bne	r2,zero,8113a940 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
8113a924:	d0a08f03 	ldbu	r2,-32196(gp)
8113a928:	10803fcc 	andi	r2,r2,255
8113a92c:	10803fe0 	cmpeqi	r2,r2,255
8113a930:	1000031e 	bne	r2,zero,8113a940 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
8113a934:	d0a08f03 	ldbu	r2,-32196(gp)
8113a938:	10800044 	addi	r2,r2,1
8113a93c:	d0a08f05 	stb	r2,-32196(gp)
8113a940:	e0bffd17 	ldw	r2,-12(fp)
8113a944:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a948:	e0bffe17 	ldw	r2,-8(fp)
8113a94c:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
8113a950:	0001883a 	nop
8113a954:	e037883a 	mov	sp,fp
8113a958:	df000017 	ldw	fp,0(sp)
8113a95c:	dec00104 	addi	sp,sp,4
8113a960:	f800283a 	ret

8113a964 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
8113a964:	defff804 	addi	sp,sp,-32
8113a968:	de00012e 	bgeu	sp,et,8113a970 <OSSchedUnlock+0xc>
8113a96c:	003b68fa 	trap	3
8113a970:	dfc00715 	stw	ra,28(sp)
8113a974:	df000615 	stw	fp,24(sp)
8113a978:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113a97c:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
8113a980:	d0a09103 	ldbu	r2,-32188(gp)
8113a984:	10803fcc 	andi	r2,r2,255
8113a988:	10800058 	cmpnei	r2,r2,1
8113a98c:	1000281e 	bne	r2,zero,8113aa30 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a990:	0005303a 	rdctl	r2,status
8113a994:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a998:	e0ffff17 	ldw	r3,-4(fp)
8113a99c:	00bfff84 	movi	r2,-2
8113a9a0:	1884703a 	and	r2,r3,r2
8113a9a4:	1001703a 	wrctl	status,r2
  
  return context;
8113a9a8:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8113a9ac:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
8113a9b0:	d0a08f03 	ldbu	r2,-32196(gp)
8113a9b4:	10803fcc 	andi	r2,r2,255
8113a9b8:	10001926 	beq	r2,zero,8113aa20 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
8113a9bc:	d0a08f03 	ldbu	r2,-32196(gp)
8113a9c0:	10bfffc4 	addi	r2,r2,-1
8113a9c4:	d0a08f05 	stb	r2,-32196(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
8113a9c8:	d0a08f03 	ldbu	r2,-32196(gp)
8113a9cc:	10803fcc 	andi	r2,r2,255
8113a9d0:	10000e1e 	bne	r2,zero,8113aa0c <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
8113a9d4:	d0a0a103 	ldbu	r2,-32124(gp)
8113a9d8:	10803fcc 	andi	r2,r2,255
8113a9dc:	1000061e 	bne	r2,zero,8113a9f8 <OSSchedUnlock+0x94>
8113a9e0:	e0bffa17 	ldw	r2,-24(fp)
8113a9e4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a9e8:	e0bffb17 	ldw	r2,-20(fp)
8113a9ec:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
8113a9f0:	113b8ac0 	call	8113b8ac <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
8113a9f4:	00000e06 	br	8113aa30 <OSSchedUnlock+0xcc>
8113a9f8:	e0bffa17 	ldw	r2,-24(fp)
8113a9fc:	e0bffc15 	stw	r2,-16(fp)
8113aa00:	e0bffc17 	ldw	r2,-16(fp)
8113aa04:	1001703a 	wrctl	status,r2
8113aa08:	00000906 	br	8113aa30 <OSSchedUnlock+0xcc>
8113aa0c:	e0bffa17 	ldw	r2,-24(fp)
8113aa10:	e0bffd15 	stw	r2,-12(fp)
8113aa14:	e0bffd17 	ldw	r2,-12(fp)
8113aa18:	1001703a 	wrctl	status,r2
8113aa1c:	00000406 	br	8113aa30 <OSSchedUnlock+0xcc>
8113aa20:	e0bffa17 	ldw	r2,-24(fp)
8113aa24:	e0bffe15 	stw	r2,-8(fp)
8113aa28:	e0bffe17 	ldw	r2,-8(fp)
8113aa2c:	1001703a 	wrctl	status,r2
8113aa30:	0001883a 	nop
8113aa34:	e037883a 	mov	sp,fp
8113aa38:	dfc00117 	ldw	ra,4(sp)
8113aa3c:	df000017 	ldw	fp,0(sp)
8113aa40:	dec00204 	addi	sp,sp,8
8113aa44:	f800283a 	ret

8113aa48 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
8113aa48:	defffe04 	addi	sp,sp,-8
8113aa4c:	de00012e 	bgeu	sp,et,8113aa54 <OSStart+0xc>
8113aa50:	003b68fa 	trap	3
8113aa54:	dfc00115 	stw	ra,4(sp)
8113aa58:	df000015 	stw	fp,0(sp)
8113aa5c:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
8113aa60:	d0a09103 	ldbu	r2,-32188(gp)
8113aa64:	10803fcc 	andi	r2,r2,255
8113aa68:	10000f1e 	bne	r2,zero,8113aaa8 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
8113aa6c:	113b9840 	call	8113b984 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
8113aa70:	d0a09383 	ldbu	r2,-32178(gp)
8113aa74:	d0a093c5 	stb	r2,-32177(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
8113aa78:	d0a09383 	ldbu	r2,-32178(gp)
8113aa7c:	10c03fcc 	andi	r3,r2,255
8113aa80:	00a045f4 	movhi	r2,33047
8113aa84:	10ba6804 	addi	r2,r2,-5728
8113aa88:	18c7883a 	add	r3,r3,r3
8113aa8c:	18c7883a 	add	r3,r3,r3
8113aa90:	10c5883a 	add	r2,r2,r3
8113aa94:	10800017 	ldw	r2,0(r2)
8113aa98:	d0a09c15 	stw	r2,-32144(gp)
        OSTCBCur      = OSTCBHighRdy;
8113aa9c:	d0a09c17 	ldw	r2,-32144(gp)
8113aaa0:	d0a0a215 	stw	r2,-32120(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
8113aaa4:	114c9780 	call	8114c978 <OSStartHighRdy>
    }
}
8113aaa8:	0001883a 	nop
8113aaac:	e037883a 	mov	sp,fp
8113aab0:	dfc00117 	ldw	ra,4(sp)
8113aab4:	df000017 	ldw	fp,0(sp)
8113aab8:	dec00204 	addi	sp,sp,8
8113aabc:	f800283a 	ret

8113aac0 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
8113aac0:	defff904 	addi	sp,sp,-28
8113aac4:	de00012e 	bgeu	sp,et,8113aacc <OSStatInit+0xc>
8113aac8:	003b68fa 	trap	3
8113aacc:	dfc00615 	stw	ra,24(sp)
8113aad0:	df000515 	stw	fp,20(sp)
8113aad4:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113aad8:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
8113aadc:	01000084 	movi	r4,2
8113aae0:	11425e80 	call	811425e8 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aae4:	0005303a 	rdctl	r2,status
8113aae8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aaec:	e0fffc17 	ldw	r3,-16(fp)
8113aaf0:	00bfff84 	movi	r2,-2
8113aaf4:	1884703a 	and	r2,r3,r2
8113aaf8:	1001703a 	wrctl	status,r2
  
  return context;
8113aafc:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
8113ab00:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
8113ab04:	d0209215 	stw	zero,-32184(gp)
8113ab08:	e0bffb17 	ldw	r2,-20(fp)
8113ab0c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ab10:	e0bffd17 	ldw	r2,-12(fp)
8113ab14:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
8113ab18:	01001904 	movi	r4,100
8113ab1c:	11425e80 	call	811425e8 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ab20:	0005303a 	rdctl	r2,status
8113ab24:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ab28:	e0fffe17 	ldw	r3,-8(fp)
8113ab2c:	00bfff84 	movi	r2,-2
8113ab30:	1884703a 	and	r2,r3,r2
8113ab34:	1001703a 	wrctl	status,r2
  
  return context;
8113ab38:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
8113ab3c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
8113ab40:	d0a09217 	ldw	r2,-32184(gp)
8113ab44:	d0a09815 	stw	r2,-32160(gp)
    OSStatRdy    = OS_TRUE;
8113ab48:	00800044 	movi	r2,1
8113ab4c:	d0a0a705 	stb	r2,-32100(gp)
8113ab50:	e0bffb17 	ldw	r2,-20(fp)
8113ab54:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ab58:	e0bfff17 	ldw	r2,-4(fp)
8113ab5c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113ab60:	0001883a 	nop
8113ab64:	e037883a 	mov	sp,fp
8113ab68:	dfc00117 	ldw	ra,4(sp)
8113ab6c:	df000017 	ldw	fp,0(sp)
8113ab70:	dec00204 	addi	sp,sp,8
8113ab74:	f800283a 	ret

8113ab78 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
8113ab78:	defff704 	addi	sp,sp,-36
8113ab7c:	de00012e 	bgeu	sp,et,8113ab84 <OSTimeTick+0xc>
8113ab80:	003b68fa 	trap	3
8113ab84:	dfc00815 	stw	ra,32(sp)
8113ab88:	df000715 	stw	fp,28(sp)
8113ab8c:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113ab90:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
8113ab94:	114cbc80 	call	8114cbc8 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ab98:	0005303a 	rdctl	r2,status
8113ab9c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aba0:	e0fffd17 	ldw	r3,-12(fp)
8113aba4:	00bfff84 	movi	r2,-2
8113aba8:	1884703a 	and	r2,r3,r2
8113abac:	1001703a 	wrctl	status,r2
  
  return context;
8113abb0:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
8113abb4:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
8113abb8:	d0a0a417 	ldw	r2,-32112(gp)
8113abbc:	10800044 	addi	r2,r2,1
8113abc0:	d0a0a415 	stw	r2,-32112(gp)
8113abc4:	e0bffb17 	ldw	r2,-20(fp)
8113abc8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113abcc:	e0bfff17 	ldw	r2,-4(fp)
8113abd0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
8113abd4:	d0a09103 	ldbu	r2,-32188(gp)
8113abd8:	10803fcc 	andi	r2,r2,255
8113abdc:	10800058 	cmpnei	r2,r2,1
8113abe0:	10006a1e 	bne	r2,zero,8113ad8c <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
8113abe4:	d0a09503 	ldbu	r2,-32172(gp)
8113abe8:	10803fcc 	andi	r2,r2,255
8113abec:	10c00060 	cmpeqi	r3,r2,1
8113abf0:	1800061e 	bne	r3,zero,8113ac0c <OSTimeTick+0x94>
8113abf4:	10c000a0 	cmpeqi	r3,r2,2
8113abf8:	1800061e 	bne	r3,zero,8113ac14 <OSTimeTick+0x9c>
8113abfc:	10000a1e 	bne	r2,zero,8113ac28 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
8113ac00:	00800044 	movi	r2,1
8113ac04:	e0bffa05 	stb	r2,-24(fp)
                 break;
8113ac08:	00000b06 	br	8113ac38 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
8113ac0c:	e03ffa05 	stb	zero,-24(fp)
                 break;
8113ac10:	00000906 	br	8113ac38 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
8113ac14:	00800044 	movi	r2,1
8113ac18:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
8113ac1c:	00800044 	movi	r2,1
8113ac20:	d0a09505 	stb	r2,-32172(gp)
                 break;
8113ac24:	00000406 	br	8113ac38 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
8113ac28:	00800044 	movi	r2,1
8113ac2c:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
8113ac30:	d0209505 	stb	zero,-32172(gp)
                 break;
8113ac34:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
8113ac38:	e0bffa03 	ldbu	r2,-24(fp)
8113ac3c:	10005226 	beq	r2,zero,8113ad88 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
8113ac40:	d0a09417 	ldw	r2,-32176(gp)
8113ac44:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8113ac48:	00004906 	br	8113ad70 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ac4c:	0005303a 	rdctl	r2,status
8113ac50:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ac54:	e0fffc17 	ldw	r3,-16(fp)
8113ac58:	00bfff84 	movi	r2,-2
8113ac5c:	1884703a 	and	r2,r3,r2
8113ac60:	1001703a 	wrctl	status,r2
  
  return context;
8113ac64:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
8113ac68:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
8113ac6c:	e0bff917 	ldw	r2,-28(fp)
8113ac70:	10800b8b 	ldhu	r2,46(r2)
8113ac74:	10bfffcc 	andi	r2,r2,65535
8113ac78:	10003626 	beq	r2,zero,8113ad54 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
8113ac7c:	e0bff917 	ldw	r2,-28(fp)
8113ac80:	10800b8b 	ldhu	r2,46(r2)
8113ac84:	10bfffc4 	addi	r2,r2,-1
8113ac88:	1007883a 	mov	r3,r2
8113ac8c:	e0bff917 	ldw	r2,-28(fp)
8113ac90:	10c00b8d 	sth	r3,46(r2)
8113ac94:	e0bff917 	ldw	r2,-28(fp)
8113ac98:	10800b8b 	ldhu	r2,46(r2)
8113ac9c:	10bfffcc 	andi	r2,r2,65535
8113aca0:	10002c1e 	bne	r2,zero,8113ad54 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113aca4:	e0bff917 	ldw	r2,-28(fp)
8113aca8:	10800c03 	ldbu	r2,48(r2)
8113acac:	10803fcc 	andi	r2,r2,255
8113acb0:	10800dcc 	andi	r2,r2,55
8113acb4:	10000b26 	beq	r2,zero,8113ace4 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
8113acb8:	e0bff917 	ldw	r2,-28(fp)
8113acbc:	10c00c03 	ldbu	r3,48(r2)
8113acc0:	00bff204 	movi	r2,-56
8113acc4:	1884703a 	and	r2,r3,r2
8113acc8:	1007883a 	mov	r3,r2
8113accc:	e0bff917 	ldw	r2,-28(fp)
8113acd0:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
8113acd4:	e0bff917 	ldw	r2,-28(fp)
8113acd8:	00c00044 	movi	r3,1
8113acdc:	10c00c45 	stb	r3,49(r2)
8113ace0:	00000206 	br	8113acec <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113ace4:	e0bff917 	ldw	r2,-28(fp)
8113ace8:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
8113acec:	e0bff917 	ldw	r2,-28(fp)
8113acf0:	10800c03 	ldbu	r2,48(r2)
8113acf4:	10803fcc 	andi	r2,r2,255
8113acf8:	1080020c 	andi	r2,r2,8
8113acfc:	1000151e 	bne	r2,zero,8113ad54 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
8113ad00:	e0bff917 	ldw	r2,-28(fp)
8113ad04:	10c00d83 	ldbu	r3,54(r2)
8113ad08:	d0a09e03 	ldbu	r2,-32136(gp)
8113ad0c:	1884b03a 	or	r2,r3,r2
8113ad10:	d0a09e05 	stb	r2,-32136(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113ad14:	e0bff917 	ldw	r2,-28(fp)
8113ad18:	10800d03 	ldbu	r2,52(r2)
8113ad1c:	10c03fcc 	andi	r3,r2,255
8113ad20:	e0bff917 	ldw	r2,-28(fp)
8113ad24:	10800d03 	ldbu	r2,52(r2)
8113ad28:	11003fcc 	andi	r4,r2,255
8113ad2c:	d0a09e44 	addi	r2,gp,-32135
8113ad30:	2085883a 	add	r2,r4,r2
8113ad34:	11000003 	ldbu	r4,0(r2)
8113ad38:	e0bff917 	ldw	r2,-28(fp)
8113ad3c:	10800d43 	ldbu	r2,53(r2)
8113ad40:	2084b03a 	or	r2,r4,r2
8113ad44:	1009883a 	mov	r4,r2
8113ad48:	d0a09e44 	addi	r2,gp,-32135
8113ad4c:	1885883a 	add	r2,r3,r2
8113ad50:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
8113ad54:	e0bff917 	ldw	r2,-28(fp)
8113ad58:	10800517 	ldw	r2,20(r2)
8113ad5c:	e0bff915 	stw	r2,-28(fp)
8113ad60:	e0bffb17 	ldw	r2,-20(fp)
8113ad64:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ad68:	e0bffe17 	ldw	r2,-8(fp)
8113ad6c:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8113ad70:	e0bff917 	ldw	r2,-28(fp)
8113ad74:	10800c83 	ldbu	r2,50(r2)
8113ad78:	10803fcc 	andi	r2,r2,255
8113ad7c:	10800a98 	cmpnei	r2,r2,42
8113ad80:	103fb21e 	bne	r2,zero,8113ac4c <__reset+0xfb11ac4c>
8113ad84:	00000106 	br	8113ad8c <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
8113ad88:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
8113ad8c:	e037883a 	mov	sp,fp
8113ad90:	dfc00117 	ldw	ra,4(sp)
8113ad94:	df000017 	ldw	fp,0(sp)
8113ad98:	dec00204 	addi	sp,sp,8
8113ad9c:	f800283a 	ret

8113ada0 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
8113ada0:	deffff04 	addi	sp,sp,-4
8113ada4:	de00012e 	bgeu	sp,et,8113adac <OSVersion+0xc>
8113ada8:	003b68fa 	trap	3
8113adac:	df000015 	stw	fp,0(sp)
8113adb0:	d839883a 	mov	fp,sp
    return (OS_VERSION);
8113adb4:	00804784 	movi	r2,286
}
8113adb8:	e037883a 	mov	sp,fp
8113adbc:	df000017 	ldw	fp,0(sp)
8113adc0:	dec00104 	addi	sp,sp,4
8113adc4:	f800283a 	ret

8113adc8 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
8113adc8:	deffff04 	addi	sp,sp,-4
8113adcc:	de00012e 	bgeu	sp,et,8113add4 <OS_Dummy+0xc>
8113add0:	003b68fa 	trap	3
8113add4:	df000015 	stw	fp,0(sp)
8113add8:	d839883a 	mov	fp,sp
}
8113addc:	0001883a 	nop
8113ade0:	e037883a 	mov	sp,fp
8113ade4:	df000017 	ldw	fp,0(sp)
8113ade8:	dec00104 	addi	sp,sp,4
8113adec:	f800283a 	ret

8113adf0 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
8113adf0:	defff804 	addi	sp,sp,-32
8113adf4:	de00012e 	bgeu	sp,et,8113adfc <OS_EventTaskRdy+0xc>
8113adf8:	003b68fa 	trap	3
8113adfc:	dfc00715 	stw	ra,28(sp)
8113ae00:	df000615 	stw	fp,24(sp)
8113ae04:	df000604 	addi	fp,sp,24
8113ae08:	e13ffc15 	stw	r4,-16(fp)
8113ae0c:	e17ffd15 	stw	r5,-12(fp)
8113ae10:	3007883a 	mov	r3,r6
8113ae14:	3805883a 	mov	r2,r7
8113ae18:	e0fffe05 	stb	r3,-8(fp)
8113ae1c:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
8113ae20:	e0bffc17 	ldw	r2,-16(fp)
8113ae24:	10800283 	ldbu	r2,10(r2)
8113ae28:	10c03fcc 	andi	r3,r2,255
8113ae2c:	00a04574 	movhi	r2,33045
8113ae30:	108aeb04 	addi	r2,r2,11180
8113ae34:	10c5883a 	add	r2,r2,r3
8113ae38:	10800003 	ldbu	r2,0(r2)
8113ae3c:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
8113ae40:	e0bffa03 	ldbu	r2,-24(fp)
8113ae44:	e0fffc17 	ldw	r3,-16(fp)
8113ae48:	1885883a 	add	r2,r3,r2
8113ae4c:	108002c4 	addi	r2,r2,11
8113ae50:	10800003 	ldbu	r2,0(r2)
8113ae54:	10c03fcc 	andi	r3,r2,255
8113ae58:	00a04574 	movhi	r2,33045
8113ae5c:	108aeb04 	addi	r2,r2,11180
8113ae60:	10c5883a 	add	r2,r2,r3
8113ae64:	10800003 	ldbu	r2,0(r2)
8113ae68:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
8113ae6c:	e0bffa03 	ldbu	r2,-24(fp)
8113ae70:	100490fa 	slli	r2,r2,3
8113ae74:	1007883a 	mov	r3,r2
8113ae78:	e0bffa43 	ldbu	r2,-23(fp)
8113ae7c:	1885883a 	add	r2,r3,r2
8113ae80:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
8113ae84:	e0fffa83 	ldbu	r3,-22(fp)
8113ae88:	00a045f4 	movhi	r2,33047
8113ae8c:	10ba6804 	addi	r2,r2,-5728
8113ae90:	18c7883a 	add	r3,r3,r3
8113ae94:	18c7883a 	add	r3,r3,r3
8113ae98:	10c5883a 	add	r2,r2,r3
8113ae9c:	10800017 	ldw	r2,0(r2)
8113aea0:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
8113aea4:	e0bffb17 	ldw	r2,-20(fp)
8113aea8:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
8113aeac:	e0bffb17 	ldw	r2,-20(fp)
8113aeb0:	e0fffd17 	ldw	r3,-12(fp)
8113aeb4:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
8113aeb8:	e0bffb17 	ldw	r2,-20(fp)
8113aebc:	10800c03 	ldbu	r2,48(r2)
8113aec0:	1007883a 	mov	r3,r2
8113aec4:	e0bffe03 	ldbu	r2,-8(fp)
8113aec8:	0084303a 	nor	r2,zero,r2
8113aecc:	1884703a 	and	r2,r3,r2
8113aed0:	1007883a 	mov	r3,r2
8113aed4:	e0bffb17 	ldw	r2,-20(fp)
8113aed8:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
8113aedc:	e0bffb17 	ldw	r2,-20(fp)
8113aee0:	e0ffff03 	ldbu	r3,-4(fp)
8113aee4:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
8113aee8:	e0bffb17 	ldw	r2,-20(fp)
8113aeec:	10800c03 	ldbu	r2,48(r2)
8113aef0:	10803fcc 	andi	r2,r2,255
8113aef4:	1080020c 	andi	r2,r2,8
8113aef8:	1000111e 	bne	r2,zero,8113af40 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
8113aefc:	e0bffb17 	ldw	r2,-20(fp)
8113af00:	10c00d83 	ldbu	r3,54(r2)
8113af04:	d0a09e03 	ldbu	r2,-32136(gp)
8113af08:	1884b03a 	or	r2,r3,r2
8113af0c:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
8113af10:	e0fffa03 	ldbu	r3,-24(fp)
8113af14:	e13ffa03 	ldbu	r4,-24(fp)
8113af18:	d0a09e44 	addi	r2,gp,-32135
8113af1c:	2085883a 	add	r2,r4,r2
8113af20:	11000003 	ldbu	r4,0(r2)
8113af24:	e0bffb17 	ldw	r2,-20(fp)
8113af28:	10800d43 	ldbu	r2,53(r2)
8113af2c:	2084b03a 	or	r2,r4,r2
8113af30:	1009883a 	mov	r4,r2
8113af34:	d0a09e44 	addi	r2,gp,-32135
8113af38:	1885883a 	add	r2,r3,r2
8113af3c:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
8113af40:	e17ffc17 	ldw	r5,-16(fp)
8113af44:	e13ffb17 	ldw	r4,-20(fp)
8113af48:	113b2000 	call	8113b200 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
8113af4c:	e0bffb17 	ldw	r2,-20(fp)
8113af50:	10800817 	ldw	r2,32(r2)
8113af54:	10000826 	beq	r2,zero,8113af78 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113af58:	e0bffb17 	ldw	r2,-20(fp)
8113af5c:	10800817 	ldw	r2,32(r2)
8113af60:	100b883a 	mov	r5,r2
8113af64:	e13ffb17 	ldw	r4,-20(fp)
8113af68:	113b2c00 	call	8113b2c0 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
8113af6c:	e0bffb17 	ldw	r2,-20(fp)
8113af70:	e0fffc17 	ldw	r3,-16(fp)
8113af74:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
8113af78:	e0bffa83 	ldbu	r2,-22(fp)
}
8113af7c:	e037883a 	mov	sp,fp
8113af80:	dfc00117 	ldw	ra,4(sp)
8113af84:	df000017 	ldw	fp,0(sp)
8113af88:	dec00204 	addi	sp,sp,8
8113af8c:	f800283a 	ret

8113af90 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
8113af90:	defffd04 	addi	sp,sp,-12
8113af94:	de00012e 	bgeu	sp,et,8113af9c <OS_EventTaskWait+0xc>
8113af98:	003b68fa 	trap	3
8113af9c:	df000215 	stw	fp,8(sp)
8113afa0:	df000204 	addi	fp,sp,8
8113afa4:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
8113afa8:	d0a0a217 	ldw	r2,-32120(gp)
8113afac:	e0ffff17 	ldw	r3,-4(fp)
8113afb0:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
8113afb4:	d0a0a217 	ldw	r2,-32120(gp)
8113afb8:	10800d03 	ldbu	r2,52(r2)
8113afbc:	10803fcc 	andi	r2,r2,255
8113afc0:	d0e0a217 	ldw	r3,-32120(gp)
8113afc4:	18c00d03 	ldbu	r3,52(r3)
8113afc8:	18c03fcc 	andi	r3,r3,255
8113afcc:	e13fff17 	ldw	r4,-4(fp)
8113afd0:	20c7883a 	add	r3,r4,r3
8113afd4:	18c002c4 	addi	r3,r3,11
8113afd8:	19000003 	ldbu	r4,0(r3)
8113afdc:	d0e0a217 	ldw	r3,-32120(gp)
8113afe0:	18c00d43 	ldbu	r3,53(r3)
8113afe4:	20c6b03a 	or	r3,r4,r3
8113afe8:	1809883a 	mov	r4,r3
8113afec:	e0ffff17 	ldw	r3,-4(fp)
8113aff0:	1885883a 	add	r2,r3,r2
8113aff4:	108002c4 	addi	r2,r2,11
8113aff8:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8113affc:	e0bfff17 	ldw	r2,-4(fp)
8113b000:	10c00283 	ldbu	r3,10(r2)
8113b004:	d0a0a217 	ldw	r2,-32120(gp)
8113b008:	10800d83 	ldbu	r2,54(r2)
8113b00c:	1884b03a 	or	r2,r3,r2
8113b010:	1007883a 	mov	r3,r2
8113b014:	e0bfff17 	ldw	r2,-4(fp)
8113b018:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8113b01c:	d0a0a217 	ldw	r2,-32120(gp)
8113b020:	10800d03 	ldbu	r2,52(r2)
8113b024:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8113b028:	e0fffe03 	ldbu	r3,-8(fp)
8113b02c:	e13ffe03 	ldbu	r4,-8(fp)
8113b030:	d0a09e44 	addi	r2,gp,-32135
8113b034:	2085883a 	add	r2,r4,r2
8113b038:	10800003 	ldbu	r2,0(r2)
8113b03c:	1009883a 	mov	r4,r2
8113b040:	d0a0a217 	ldw	r2,-32120(gp)
8113b044:	10800d43 	ldbu	r2,53(r2)
8113b048:	0084303a 	nor	r2,zero,r2
8113b04c:	2084703a 	and	r2,r4,r2
8113b050:	1009883a 	mov	r4,r2
8113b054:	d0a09e44 	addi	r2,gp,-32135
8113b058:	1885883a 	add	r2,r3,r2
8113b05c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113b060:	e0fffe03 	ldbu	r3,-8(fp)
8113b064:	d0a09e44 	addi	r2,gp,-32135
8113b068:	1885883a 	add	r2,r3,r2
8113b06c:	10800003 	ldbu	r2,0(r2)
8113b070:	10803fcc 	andi	r2,r2,255
8113b074:	1000071e 	bne	r2,zero,8113b094 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8113b078:	d0a0a217 	ldw	r2,-32120(gp)
8113b07c:	10800d83 	ldbu	r2,54(r2)
8113b080:	0084303a 	nor	r2,zero,r2
8113b084:	1007883a 	mov	r3,r2
8113b088:	d0a09e03 	ldbu	r2,-32136(gp)
8113b08c:	1884703a 	and	r2,r3,r2
8113b090:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113b094:	0001883a 	nop
8113b098:	e037883a 	mov	sp,fp
8113b09c:	df000017 	ldw	fp,0(sp)
8113b0a0:	dec00104 	addi	sp,sp,4
8113b0a4:	f800283a 	ret

8113b0a8 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
8113b0a8:	defffb04 	addi	sp,sp,-20
8113b0ac:	de00012e 	bgeu	sp,et,8113b0b4 <OS_EventTaskWaitMulti+0xc>
8113b0b0:	003b68fa 	trap	3
8113b0b4:	df000415 	stw	fp,16(sp)
8113b0b8:	df000404 	addi	fp,sp,16
8113b0bc:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
8113b0c0:	d0a0a217 	ldw	r2,-32120(gp)
8113b0c4:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
8113b0c8:	d0a0a217 	ldw	r2,-32120(gp)
8113b0cc:	e0ffff17 	ldw	r3,-4(fp)
8113b0d0:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
8113b0d4:	e0bfff17 	ldw	r2,-4(fp)
8113b0d8:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
8113b0dc:	e0bffc17 	ldw	r2,-16(fp)
8113b0e0:	10800017 	ldw	r2,0(r2)
8113b0e4:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8113b0e8:	00002006 	br	8113b16c <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
8113b0ec:	d0a0a217 	ldw	r2,-32120(gp)
8113b0f0:	10800d03 	ldbu	r2,52(r2)
8113b0f4:	10803fcc 	andi	r2,r2,255
8113b0f8:	d0e0a217 	ldw	r3,-32120(gp)
8113b0fc:	18c00d03 	ldbu	r3,52(r3)
8113b100:	18c03fcc 	andi	r3,r3,255
8113b104:	e13ffd17 	ldw	r4,-12(fp)
8113b108:	20c7883a 	add	r3,r4,r3
8113b10c:	18c002c4 	addi	r3,r3,11
8113b110:	19000003 	ldbu	r4,0(r3)
8113b114:	d0e0a217 	ldw	r3,-32120(gp)
8113b118:	18c00d43 	ldbu	r3,53(r3)
8113b11c:	20c6b03a 	or	r3,r4,r3
8113b120:	1809883a 	mov	r4,r3
8113b124:	e0fffd17 	ldw	r3,-12(fp)
8113b128:	1885883a 	add	r2,r3,r2
8113b12c:	108002c4 	addi	r2,r2,11
8113b130:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8113b134:	e0bffd17 	ldw	r2,-12(fp)
8113b138:	10c00283 	ldbu	r3,10(r2)
8113b13c:	d0a0a217 	ldw	r2,-32120(gp)
8113b140:	10800d83 	ldbu	r2,54(r2)
8113b144:	1884b03a 	or	r2,r3,r2
8113b148:	1007883a 	mov	r3,r2
8113b14c:	e0bffd17 	ldw	r2,-12(fp)
8113b150:	10c00285 	stb	r3,10(r2)
        pevents++;
8113b154:	e0bffc17 	ldw	r2,-16(fp)
8113b158:	10800104 	addi	r2,r2,4
8113b15c:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
8113b160:	e0bffc17 	ldw	r2,-16(fp)
8113b164:	10800017 	ldw	r2,0(r2)
8113b168:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8113b16c:	e0bffd17 	ldw	r2,-12(fp)
8113b170:	103fde1e 	bne	r2,zero,8113b0ec <__reset+0xfb11b0ec>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8113b174:	d0a0a217 	ldw	r2,-32120(gp)
8113b178:	10800d03 	ldbu	r2,52(r2)
8113b17c:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8113b180:	e0fffe03 	ldbu	r3,-8(fp)
8113b184:	e13ffe03 	ldbu	r4,-8(fp)
8113b188:	d0a09e44 	addi	r2,gp,-32135
8113b18c:	2085883a 	add	r2,r4,r2
8113b190:	10800003 	ldbu	r2,0(r2)
8113b194:	1009883a 	mov	r4,r2
8113b198:	d0a0a217 	ldw	r2,-32120(gp)
8113b19c:	10800d43 	ldbu	r2,53(r2)
8113b1a0:	0084303a 	nor	r2,zero,r2
8113b1a4:	2084703a 	and	r2,r4,r2
8113b1a8:	1009883a 	mov	r4,r2
8113b1ac:	d0a09e44 	addi	r2,gp,-32135
8113b1b0:	1885883a 	add	r2,r3,r2
8113b1b4:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113b1b8:	e0fffe03 	ldbu	r3,-8(fp)
8113b1bc:	d0a09e44 	addi	r2,gp,-32135
8113b1c0:	1885883a 	add	r2,r3,r2
8113b1c4:	10800003 	ldbu	r2,0(r2)
8113b1c8:	10803fcc 	andi	r2,r2,255
8113b1cc:	1000071e 	bne	r2,zero,8113b1ec <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8113b1d0:	d0a0a217 	ldw	r2,-32120(gp)
8113b1d4:	10800d83 	ldbu	r2,54(r2)
8113b1d8:	0084303a 	nor	r2,zero,r2
8113b1dc:	1007883a 	mov	r3,r2
8113b1e0:	d0a09e03 	ldbu	r2,-32136(gp)
8113b1e4:	1884703a 	and	r2,r3,r2
8113b1e8:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113b1ec:	0001883a 	nop
8113b1f0:	e037883a 	mov	sp,fp
8113b1f4:	df000017 	ldw	fp,0(sp)
8113b1f8:	dec00104 	addi	sp,sp,4
8113b1fc:	f800283a 	ret

8113b200 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
8113b200:	defffc04 	addi	sp,sp,-16
8113b204:	de00012e 	bgeu	sp,et,8113b20c <OS_EventTaskRemove+0xc>
8113b208:	003b68fa 	trap	3
8113b20c:	df000315 	stw	fp,12(sp)
8113b210:	df000304 	addi	fp,sp,12
8113b214:	e13ffe15 	stw	r4,-8(fp)
8113b218:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
8113b21c:	e0bffe17 	ldw	r2,-8(fp)
8113b220:	10800d03 	ldbu	r2,52(r2)
8113b224:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
8113b228:	e0bffd03 	ldbu	r2,-12(fp)
8113b22c:	e0fffd03 	ldbu	r3,-12(fp)
8113b230:	e13fff17 	ldw	r4,-4(fp)
8113b234:	20c7883a 	add	r3,r4,r3
8113b238:	18c002c4 	addi	r3,r3,11
8113b23c:	18c00003 	ldbu	r3,0(r3)
8113b240:	1809883a 	mov	r4,r3
8113b244:	e0fffe17 	ldw	r3,-8(fp)
8113b248:	18c00d43 	ldbu	r3,53(r3)
8113b24c:	00c6303a 	nor	r3,zero,r3
8113b250:	20c6703a 	and	r3,r4,r3
8113b254:	1809883a 	mov	r4,r3
8113b258:	e0ffff17 	ldw	r3,-4(fp)
8113b25c:	1885883a 	add	r2,r3,r2
8113b260:	108002c4 	addi	r2,r2,11
8113b264:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
8113b268:	e0bffd03 	ldbu	r2,-12(fp)
8113b26c:	e0ffff17 	ldw	r3,-4(fp)
8113b270:	1885883a 	add	r2,r3,r2
8113b274:	108002c4 	addi	r2,r2,11
8113b278:	10800003 	ldbu	r2,0(r2)
8113b27c:	10803fcc 	andi	r2,r2,255
8113b280:	10000a1e 	bne	r2,zero,8113b2ac <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
8113b284:	e0bfff17 	ldw	r2,-4(fp)
8113b288:	10800283 	ldbu	r2,10(r2)
8113b28c:	1007883a 	mov	r3,r2
8113b290:	e0bffe17 	ldw	r2,-8(fp)
8113b294:	10800d83 	ldbu	r2,54(r2)
8113b298:	0084303a 	nor	r2,zero,r2
8113b29c:	1884703a 	and	r2,r3,r2
8113b2a0:	1007883a 	mov	r3,r2
8113b2a4:	e0bfff17 	ldw	r2,-4(fp)
8113b2a8:	10c00285 	stb	r3,10(r2)
    }
}
8113b2ac:	0001883a 	nop
8113b2b0:	e037883a 	mov	sp,fp
8113b2b4:	df000017 	ldw	fp,0(sp)
8113b2b8:	dec00104 	addi	sp,sp,4
8113b2bc:	f800283a 	ret

8113b2c0 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
8113b2c0:	defffa04 	addi	sp,sp,-24
8113b2c4:	de00012e 	bgeu	sp,et,8113b2cc <OS_EventTaskRemoveMulti+0xc>
8113b2c8:	003b68fa 	trap	3
8113b2cc:	df000515 	stw	fp,20(sp)
8113b2d0:	df000504 	addi	fp,sp,20
8113b2d4:	e13ffe15 	stw	r4,-8(fp)
8113b2d8:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
8113b2dc:	e0bffe17 	ldw	r2,-8(fp)
8113b2e0:	10800d03 	ldbu	r2,52(r2)
8113b2e4:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
8113b2e8:	e0bffe17 	ldw	r2,-8(fp)
8113b2ec:	10800d83 	ldbu	r2,54(r2)
8113b2f0:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
8113b2f4:	e0bffe17 	ldw	r2,-8(fp)
8113b2f8:	10800d43 	ldbu	r2,53(r2)
8113b2fc:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
8113b300:	e0bfff17 	ldw	r2,-4(fp)
8113b304:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
8113b308:	e0bffb17 	ldw	r2,-20(fp)
8113b30c:	10800017 	ldw	r2,0(r2)
8113b310:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8113b314:	00002506 	br	8113b3ac <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
8113b318:	e0bffd03 	ldbu	r2,-12(fp)
8113b31c:	e0fffd03 	ldbu	r3,-12(fp)
8113b320:	e13ffc17 	ldw	r4,-16(fp)
8113b324:	20c7883a 	add	r3,r4,r3
8113b328:	18c002c4 	addi	r3,r3,11
8113b32c:	18c00003 	ldbu	r3,0(r3)
8113b330:	1809883a 	mov	r4,r3
8113b334:	e0fffd83 	ldbu	r3,-10(fp)
8113b338:	00c6303a 	nor	r3,zero,r3
8113b33c:	20c6703a 	and	r3,r4,r3
8113b340:	1809883a 	mov	r4,r3
8113b344:	e0fffc17 	ldw	r3,-16(fp)
8113b348:	1885883a 	add	r2,r3,r2
8113b34c:	108002c4 	addi	r2,r2,11
8113b350:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
8113b354:	e0bffd03 	ldbu	r2,-12(fp)
8113b358:	e0fffc17 	ldw	r3,-16(fp)
8113b35c:	1885883a 	add	r2,r3,r2
8113b360:	108002c4 	addi	r2,r2,11
8113b364:	10800003 	ldbu	r2,0(r2)
8113b368:	10803fcc 	andi	r2,r2,255
8113b36c:	1000091e 	bne	r2,zero,8113b394 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
8113b370:	e0bffc17 	ldw	r2,-16(fp)
8113b374:	10800283 	ldbu	r2,10(r2)
8113b378:	1007883a 	mov	r3,r2
8113b37c:	e0bffd43 	ldbu	r2,-11(fp)
8113b380:	0084303a 	nor	r2,zero,r2
8113b384:	1884703a 	and	r2,r3,r2
8113b388:	1007883a 	mov	r3,r2
8113b38c:	e0bffc17 	ldw	r2,-16(fp)
8113b390:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
8113b394:	e0bffb17 	ldw	r2,-20(fp)
8113b398:	10800104 	addi	r2,r2,4
8113b39c:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
8113b3a0:	e0bffb17 	ldw	r2,-20(fp)
8113b3a4:	10800017 	ldw	r2,0(r2)
8113b3a8:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8113b3ac:	e0bffc17 	ldw	r2,-16(fp)
8113b3b0:	103fd91e 	bne	r2,zero,8113b318 <__reset+0xfb11b318>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
8113b3b4:	0001883a 	nop
8113b3b8:	e037883a 	mov	sp,fp
8113b3bc:	df000017 	ldw	fp,0(sp)
8113b3c0:	dec00104 	addi	sp,sp,4
8113b3c4:	f800283a 	ret

8113b3c8 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
8113b3c8:	defffc04 	addi	sp,sp,-16
8113b3cc:	de00012e 	bgeu	sp,et,8113b3d4 <OS_EventWaitListInit+0xc>
8113b3d0:	003b68fa 	trap	3
8113b3d4:	df000315 	stw	fp,12(sp)
8113b3d8:	df000304 	addi	fp,sp,12
8113b3dc:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
8113b3e0:	e0bfff17 	ldw	r2,-4(fp)
8113b3e4:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
8113b3e8:	e0bfff17 	ldw	r2,-4(fp)
8113b3ec:	108002c4 	addi	r2,r2,11
8113b3f0:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113b3f4:	e03ffe05 	stb	zero,-8(fp)
8113b3f8:	00000706 	br	8113b418 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
8113b3fc:	e0bffd17 	ldw	r2,-12(fp)
8113b400:	10c00044 	addi	r3,r2,1
8113b404:	e0fffd15 	stw	r3,-12(fp)
8113b408:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113b40c:	e0bffe03 	ldbu	r2,-8(fp)
8113b410:	10800044 	addi	r2,r2,1
8113b414:	e0bffe05 	stb	r2,-8(fp)
8113b418:	e0bffe03 	ldbu	r2,-8(fp)
8113b41c:	108001b0 	cmpltui	r2,r2,6
8113b420:	103ff61e 	bne	r2,zero,8113b3fc <__reset+0xfb11b3fc>
        *ptbl++ = 0;
    }
}
8113b424:	0001883a 	nop
8113b428:	e037883a 	mov	sp,fp
8113b42c:	df000017 	ldw	fp,0(sp)
8113b430:	dec00104 	addi	sp,sp,4
8113b434:	f800283a 	ret

8113b438 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
8113b438:	defffb04 	addi	sp,sp,-20
8113b43c:	de00012e 	bgeu	sp,et,8113b444 <OS_InitEventList+0xc>
8113b440:	003b68fa 	trap	3
8113b444:	dfc00415 	stw	ra,16(sp)
8113b448:	df000315 	stw	fp,12(sp)
8113b44c:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
8113b450:	01434004 	movi	r5,3328
8113b454:	012045f4 	movhi	r4,33047
8113b458:	2132ba04 	addi	r4,r4,-13592
8113b45c:	113b7e00 	call	8113b7e0 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
8113b460:	00a045f4 	movhi	r2,33047
8113b464:	10b2ba04 	addi	r2,r2,-13592
8113b468:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
8113b46c:	00a045f4 	movhi	r2,33047
8113b470:	10b2c704 	addi	r2,r2,-13540
8113b474:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8113b478:	e03ffd0d 	sth	zero,-12(fp)
8113b47c:	00001306 	br	8113b4cc <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113b480:	e0bffe17 	ldw	r2,-8(fp)
8113b484:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
8113b488:	e0bffe17 	ldw	r2,-8(fp)
8113b48c:	e0ffff17 	ldw	r3,-4(fp)
8113b490:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
8113b494:	e0bffe17 	ldw	r2,-8(fp)
8113b498:	00c00fc4 	movi	r3,63
8113b49c:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
8113b4a0:	e0bffe17 	ldw	r2,-8(fp)
8113b4a4:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
8113b4a8:	e0bffe17 	ldw	r2,-8(fp)
8113b4ac:	10800d04 	addi	r2,r2,52
8113b4b0:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
8113b4b4:	e0bfff17 	ldw	r2,-4(fp)
8113b4b8:	10800d04 	addi	r2,r2,52
8113b4bc:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8113b4c0:	e0bffd0b 	ldhu	r2,-12(fp)
8113b4c4:	10800044 	addi	r2,r2,1
8113b4c8:	e0bffd0d 	sth	r2,-12(fp)
8113b4cc:	e0bffd0b 	ldhu	r2,-12(fp)
8113b4d0:	10800ff0 	cmpltui	r2,r2,63
8113b4d4:	103fea1e 	bne	r2,zero,8113b480 <__reset+0xfb11b480>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
8113b4d8:	e0bffe17 	ldw	r2,-8(fp)
8113b4dc:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
8113b4e0:	e0bffe17 	ldw	r2,-8(fp)
8113b4e4:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
8113b4e8:	e0bffe17 	ldw	r2,-8(fp)
8113b4ec:	00c00fc4 	movi	r3,63
8113b4f0:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
8113b4f4:	e0bffe17 	ldw	r2,-8(fp)
8113b4f8:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
8113b4fc:	00a045f4 	movhi	r2,33047
8113b500:	10b2ba04 	addi	r2,r2,-13592
8113b504:	d0a0a015 	stw	r2,-32128(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
8113b508:	0001883a 	nop
8113b50c:	e037883a 	mov	sp,fp
8113b510:	dfc00117 	ldw	ra,4(sp)
8113b514:	df000017 	ldw	fp,0(sp)
8113b518:	dec00204 	addi	sp,sp,8
8113b51c:	f800283a 	ret

8113b520 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
8113b520:	deffff04 	addi	sp,sp,-4
8113b524:	de00012e 	bgeu	sp,et,8113b52c <OS_InitMisc+0xc>
8113b528:	003b68fa 	trap	3
8113b52c:	df000015 	stw	fp,0(sp)
8113b530:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
8113b534:	d020a415 	stw	zero,-32112(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
8113b538:	d020a105 	stb	zero,-32124(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
8113b53c:	d0208f05 	stb	zero,-32196(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
8113b540:	d0209a45 	stb	zero,-32151(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
8113b544:	d0209105 	stb	zero,-32188(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
8113b548:	d0209615 	stw	zero,-32168(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
8113b54c:	d0209215 	stw	zero,-32184(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
8113b550:	d020a815 	stw	zero,-32096(gp)
    OSIdleCtrMax  = 0L;
8113b554:	d0209815 	stw	zero,-32160(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
8113b558:	d020a705 	stb	zero,-32100(gp)
#endif
}
8113b55c:	0001883a 	nop
8113b560:	e037883a 	mov	sp,fp
8113b564:	df000017 	ldw	fp,0(sp)
8113b568:	dec00104 	addi	sp,sp,4
8113b56c:	f800283a 	ret

8113b570 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
8113b570:	defffd04 	addi	sp,sp,-12
8113b574:	de00012e 	bgeu	sp,et,8113b57c <OS_InitRdyList+0xc>
8113b578:	003b68fa 	trap	3
8113b57c:	df000215 	stw	fp,8(sp)
8113b580:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
8113b584:	d0209e05 	stb	zero,-32136(gp)
    prdytbl       = &OSRdyTbl[0];
8113b588:	d0a09e44 	addi	r2,gp,-32135
8113b58c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113b590:	e03ffe05 	stb	zero,-8(fp)
8113b594:	00000706 	br	8113b5b4 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
8113b598:	e0bfff17 	ldw	r2,-4(fp)
8113b59c:	10c00044 	addi	r3,r2,1
8113b5a0:	e0ffff15 	stw	r3,-4(fp)
8113b5a4:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113b5a8:	e0bffe03 	ldbu	r2,-8(fp)
8113b5ac:	10800044 	addi	r2,r2,1
8113b5b0:	e0bffe05 	stb	r2,-8(fp)
8113b5b4:	e0bffe03 	ldbu	r2,-8(fp)
8113b5b8:	108001b0 	cmpltui	r2,r2,6
8113b5bc:	103ff61e 	bne	r2,zero,8113b598 <__reset+0xfb11b598>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
8113b5c0:	d02093c5 	stb	zero,-32177(gp)
    OSPrioHighRdy = 0;
8113b5c4:	d0209385 	stb	zero,-32178(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
8113b5c8:	d0209c15 	stw	zero,-32144(gp)
    OSTCBCur      = (OS_TCB *)0;
8113b5cc:	d020a215 	stw	zero,-32120(gp)
}
8113b5d0:	0001883a 	nop
8113b5d4:	e037883a 	mov	sp,fp
8113b5d8:	df000017 	ldw	fp,0(sp)
8113b5dc:	dec00104 	addi	sp,sp,4
8113b5e0:	f800283a 	ret

8113b5e4 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
8113b5e4:	defff804 	addi	sp,sp,-32
8113b5e8:	de00012e 	bgeu	sp,et,8113b5f0 <OS_InitTaskIdle+0xc>
8113b5ec:	003b68fa 	trap	3
8113b5f0:	dfc00715 	stw	ra,28(sp)
8113b5f4:	df000615 	stw	fp,24(sp)
8113b5f8:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
8113b5fc:	008000c4 	movi	r2,3
8113b600:	d8800415 	stw	r2,16(sp)
8113b604:	d8000315 	stw	zero,12(sp)
8113b608:	00810004 	movi	r2,1024
8113b60c:	d8800215 	stw	r2,8(sp)
8113b610:	00a045f4 	movhi	r2,33047
8113b614:	10aeba04 	addi	r2,r2,-17688
8113b618:	d8800115 	stw	r2,4(sp)
8113b61c:	00bfffd4 	movui	r2,65535
8113b620:	d8800015 	stw	r2,0(sp)
8113b624:	01c00a84 	movi	r7,42
8113b628:	01a045f4 	movhi	r6,33047
8113b62c:	31b2b904 	addi	r6,r6,-13596
8113b630:	000b883a 	mov	r5,zero
8113b634:	01204534 	movhi	r4,33044
8113b638:	212eb604 	addi	r4,r4,-17704
8113b63c:	11414c80 	call	811414c8 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
8113b640:	e1bfff04 	addi	r6,fp,-4
8113b644:	01604574 	movhi	r5,33045
8113b648:	294b2b04 	addi	r5,r5,11436
8113b64c:	01000a84 	movi	r4,42
8113b650:	1141cf80 	call	81141cf8 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
8113b654:	0001883a 	nop
8113b658:	e037883a 	mov	sp,fp
8113b65c:	dfc00117 	ldw	ra,4(sp)
8113b660:	df000017 	ldw	fp,0(sp)
8113b664:	dec00204 	addi	sp,sp,8
8113b668:	f800283a 	ret

8113b66c <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
8113b66c:	defff804 	addi	sp,sp,-32
8113b670:	de00012e 	bgeu	sp,et,8113b678 <OS_InitTaskStat+0xc>
8113b674:	003b68fa 	trap	3
8113b678:	dfc00715 	stw	ra,28(sp)
8113b67c:	df000615 	stw	fp,24(sp)
8113b680:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
8113b684:	008000c4 	movi	r2,3
8113b688:	d8800415 	stw	r2,16(sp)
8113b68c:	d8000315 	stw	zero,12(sp)
8113b690:	00810004 	movi	r2,1024
8113b694:	d8800215 	stw	r2,8(sp)
8113b698:	00a045f4 	movhi	r2,33047
8113b69c:	10a7fa04 	addi	r2,r2,-24600
8113b6a0:	d8800115 	stw	r2,4(sp)
8113b6a4:	00bfff94 	movui	r2,65534
8113b6a8:	d8800015 	stw	r2,0(sp)
8113b6ac:	01c00a44 	movi	r7,41
8113b6b0:	01a045f4 	movhi	r6,33047
8113b6b4:	31abf904 	addi	r6,r6,-20508
8113b6b8:	000b883a 	mov	r5,zero
8113b6bc:	01204534 	movhi	r4,33044
8113b6c0:	212ecf04 	addi	r4,r4,-17604
8113b6c4:	11414c80 	call	811414c8 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
8113b6c8:	e1bfff04 	addi	r6,fp,-4
8113b6cc:	01604574 	movhi	r5,33045
8113b6d0:	294b2f04 	addi	r5,r5,11452
8113b6d4:	01000a44 	movi	r4,41
8113b6d8:	1141cf80 	call	81141cf8 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
8113b6dc:	0001883a 	nop
8113b6e0:	e037883a 	mov	sp,fp
8113b6e4:	dfc00117 	ldw	ra,4(sp)
8113b6e8:	df000017 	ldw	fp,0(sp)
8113b6ec:	dec00204 	addi	sp,sp,8
8113b6f0:	f800283a 	ret

8113b6f4 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
8113b6f4:	defffb04 	addi	sp,sp,-20
8113b6f8:	de00012e 	bgeu	sp,et,8113b700 <OS_InitTCBList+0xc>
8113b6fc:	003b68fa 	trap	3
8113b700:	dfc00415 	stw	ra,16(sp)
8113b704:	df000315 	stw	fp,12(sp)
8113b708:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
8113b70c:	01446e04 	movi	r5,4536
8113b710:	012045f4 	movhi	r4,33047
8113b714:	2135fa04 	addi	r4,r4,-10264
8113b718:	113b7e00 	call	8113b7e0 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
8113b71c:	01402b04 	movi	r5,172
8113b720:	012045f4 	movhi	r4,33047
8113b724:	213a6804 	addi	r4,r4,-5728
8113b728:	113b7e00 	call	8113b7e0 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
8113b72c:	00a045f4 	movhi	r2,33047
8113b730:	10b5fa04 	addi	r2,r2,-10264
8113b734:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
8113b738:	00a045f4 	movhi	r2,33047
8113b73c:	10b61504 	addi	r2,r2,-10156
8113b740:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8113b744:	e03ffd05 	stb	zero,-12(fp)
8113b748:	00001106 	br	8113b790 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
8113b74c:	e0bffe17 	ldw	r2,-8(fp)
8113b750:	e0ffff17 	ldw	r3,-4(fp)
8113b754:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
8113b758:	e0bffe17 	ldw	r2,-8(fp)
8113b75c:	00c00fc4 	movi	r3,63
8113b760:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8113b764:	e0bffe17 	ldw	r2,-8(fp)
8113b768:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
8113b76c:	e0bffe17 	ldw	r2,-8(fp)
8113b770:	10801b04 	addi	r2,r2,108
8113b774:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
8113b778:	e0bfff17 	ldw	r2,-4(fp)
8113b77c:	10801b04 	addi	r2,r2,108
8113b780:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8113b784:	e0bffd03 	ldbu	r2,-12(fp)
8113b788:	10800044 	addi	r2,r2,1
8113b78c:	e0bffd05 	stb	r2,-12(fp)
8113b790:	e0bffd03 	ldbu	r2,-12(fp)
8113b794:	10800a70 	cmpltui	r2,r2,41
8113b798:	103fec1e 	bne	r2,zero,8113b74c <__reset+0xfb11b74c>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
8113b79c:	e0bffe17 	ldw	r2,-8(fp)
8113b7a0:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
8113b7a4:	e0bffe17 	ldw	r2,-8(fp)
8113b7a8:	00c00fc4 	movi	r3,63
8113b7ac:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8113b7b0:	e0bffe17 	ldw	r2,-8(fp)
8113b7b4:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
8113b7b8:	d0209415 	stw	zero,-32176(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
8113b7bc:	00a045f4 	movhi	r2,33047
8113b7c0:	10b5fa04 	addi	r2,r2,-10264
8113b7c4:	d0a09915 	stw	r2,-32156(gp)
}
8113b7c8:	0001883a 	nop
8113b7cc:	e037883a 	mov	sp,fp
8113b7d0:	dfc00117 	ldw	ra,4(sp)
8113b7d4:	df000017 	ldw	fp,0(sp)
8113b7d8:	dec00204 	addi	sp,sp,8
8113b7dc:	f800283a 	ret

8113b7e0 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
8113b7e0:	defffd04 	addi	sp,sp,-12
8113b7e4:	de00012e 	bgeu	sp,et,8113b7ec <OS_MemClr+0xc>
8113b7e8:	003b68fa 	trap	3
8113b7ec:	df000215 	stw	fp,8(sp)
8113b7f0:	df000204 	addi	fp,sp,8
8113b7f4:	e13ffe15 	stw	r4,-8(fp)
8113b7f8:	2805883a 	mov	r2,r5
8113b7fc:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8113b800:	00000706 	br	8113b820 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
8113b804:	e0bffe17 	ldw	r2,-8(fp)
8113b808:	10c00044 	addi	r3,r2,1
8113b80c:	e0fffe15 	stw	r3,-8(fp)
8113b810:	10000005 	stb	zero,0(r2)
        size--;
8113b814:	e0bfff0b 	ldhu	r2,-4(fp)
8113b818:	10bfffc4 	addi	r2,r2,-1
8113b81c:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
8113b820:	e0bfff0b 	ldhu	r2,-4(fp)
8113b824:	103ff71e 	bne	r2,zero,8113b804 <__reset+0xfb11b804>
        *pdest++ = (INT8U)0;
        size--;
    }
}
8113b828:	0001883a 	nop
8113b82c:	e037883a 	mov	sp,fp
8113b830:	df000017 	ldw	fp,0(sp)
8113b834:	dec00104 	addi	sp,sp,4
8113b838:	f800283a 	ret

8113b83c <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
8113b83c:	defffc04 	addi	sp,sp,-16
8113b840:	de00012e 	bgeu	sp,et,8113b848 <OS_MemCopy+0xc>
8113b844:	003b68fa 	trap	3
8113b848:	df000315 	stw	fp,12(sp)
8113b84c:	df000304 	addi	fp,sp,12
8113b850:	e13ffd15 	stw	r4,-12(fp)
8113b854:	e17ffe15 	stw	r5,-8(fp)
8113b858:	3005883a 	mov	r2,r6
8113b85c:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8113b860:	00000b06 	br	8113b890 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
8113b864:	e0bffd17 	ldw	r2,-12(fp)
8113b868:	10c00044 	addi	r3,r2,1
8113b86c:	e0fffd15 	stw	r3,-12(fp)
8113b870:	e0fffe17 	ldw	r3,-8(fp)
8113b874:	19000044 	addi	r4,r3,1
8113b878:	e13ffe15 	stw	r4,-8(fp)
8113b87c:	18c00003 	ldbu	r3,0(r3)
8113b880:	10c00005 	stb	r3,0(r2)
        size--;
8113b884:	e0bfff0b 	ldhu	r2,-4(fp)
8113b888:	10bfffc4 	addi	r2,r2,-1
8113b88c:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
8113b890:	e0bfff0b 	ldhu	r2,-4(fp)
8113b894:	103ff31e 	bne	r2,zero,8113b864 <__reset+0xfb11b864>
        *pdest++ = *psrc++;
        size--;
    }
}
8113b898:	0001883a 	nop
8113b89c:	e037883a 	mov	sp,fp
8113b8a0:	df000017 	ldw	fp,0(sp)
8113b8a4:	dec00104 	addi	sp,sp,4
8113b8a8:	f800283a 	ret

8113b8ac <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
8113b8ac:	defffb04 	addi	sp,sp,-20
8113b8b0:	de00012e 	bgeu	sp,et,8113b8b8 <OS_Sched+0xc>
8113b8b4:	003b68fa 	trap	3
8113b8b8:	dfc00415 	stw	ra,16(sp)
8113b8bc:	df000315 	stw	fp,12(sp)
8113b8c0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113b8c4:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b8c8:	0005303a 	rdctl	r2,status
8113b8cc:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b8d0:	e0ffff17 	ldw	r3,-4(fp)
8113b8d4:	00bfff84 	movi	r2,-2
8113b8d8:	1884703a 	and	r2,r3,r2
8113b8dc:	1001703a 	wrctl	status,r2
  
  return context;
8113b8e0:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
8113b8e4:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
8113b8e8:	d0a0a103 	ldbu	r2,-32124(gp)
8113b8ec:	10803fcc 	andi	r2,r2,255
8113b8f0:	10001a1e 	bne	r2,zero,8113b95c <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
8113b8f4:	d0a08f03 	ldbu	r2,-32196(gp)
8113b8f8:	10803fcc 	andi	r2,r2,255
8113b8fc:	1000171e 	bne	r2,zero,8113b95c <OS_Sched+0xb0>
            OS_SchedNew();
8113b900:	113b9840 	call	8113b984 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
8113b904:	d0e09383 	ldbu	r3,-32178(gp)
8113b908:	d0a093c3 	ldbu	r2,-32177(gp)
8113b90c:	18c03fcc 	andi	r3,r3,255
8113b910:	10803fcc 	andi	r2,r2,255
8113b914:	18801126 	beq	r3,r2,8113b95c <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
8113b918:	d0a09383 	ldbu	r2,-32178(gp)
8113b91c:	10c03fcc 	andi	r3,r2,255
8113b920:	00a045f4 	movhi	r2,33047
8113b924:	10ba6804 	addi	r2,r2,-5728
8113b928:	18c7883a 	add	r3,r3,r3
8113b92c:	18c7883a 	add	r3,r3,r3
8113b930:	10c5883a 	add	r2,r2,r3
8113b934:	10800017 	ldw	r2,0(r2)
8113b938:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
8113b93c:	d0a09c17 	ldw	r2,-32144(gp)
8113b940:	10c00e17 	ldw	r3,56(r2)
8113b944:	18c00044 	addi	r3,r3,1
8113b948:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
8113b94c:	d0a09617 	ldw	r2,-32168(gp)
8113b950:	10800044 	addi	r2,r2,1
8113b954:	d0a09615 	stw	r2,-32168(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
8113b958:	114c8dc0 	call	8114c8dc <OSCtxSw>
8113b95c:	e0bffd17 	ldw	r2,-12(fp)
8113b960:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b964:	e0bffe17 	ldw	r2,-8(fp)
8113b968:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
8113b96c:	0001883a 	nop
8113b970:	e037883a 	mov	sp,fp
8113b974:	dfc00117 	ldw	ra,4(sp)
8113b978:	df000017 	ldw	fp,0(sp)
8113b97c:	dec00204 	addi	sp,sp,8
8113b980:	f800283a 	ret

8113b984 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
8113b984:	defffe04 	addi	sp,sp,-8
8113b988:	de00012e 	bgeu	sp,et,8113b990 <OS_SchedNew+0xc>
8113b98c:	003b68fa 	trap	3
8113b990:	df000115 	stw	fp,4(sp)
8113b994:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
8113b998:	d0a09e03 	ldbu	r2,-32136(gp)
8113b99c:	10c03fcc 	andi	r3,r2,255
8113b9a0:	00a04574 	movhi	r2,33045
8113b9a4:	108aeb04 	addi	r2,r2,11180
8113b9a8:	10c5883a 	add	r2,r2,r3
8113b9ac:	10800003 	ldbu	r2,0(r2)
8113b9b0:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
8113b9b4:	e0bfff03 	ldbu	r2,-4(fp)
8113b9b8:	100490fa 	slli	r2,r2,3
8113b9bc:	1009883a 	mov	r4,r2
8113b9c0:	e0ffff03 	ldbu	r3,-4(fp)
8113b9c4:	d0a09e44 	addi	r2,gp,-32135
8113b9c8:	1885883a 	add	r2,r3,r2
8113b9cc:	10800003 	ldbu	r2,0(r2)
8113b9d0:	10c03fcc 	andi	r3,r2,255
8113b9d4:	00a04574 	movhi	r2,33045
8113b9d8:	108aeb04 	addi	r2,r2,11180
8113b9dc:	10c5883a 	add	r2,r2,r3
8113b9e0:	10800003 	ldbu	r2,0(r2)
8113b9e4:	2085883a 	add	r2,r4,r2
8113b9e8:	d0a09385 	stb	r2,-32178(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
8113b9ec:	0001883a 	nop
8113b9f0:	e037883a 	mov	sp,fp
8113b9f4:	df000017 	ldw	fp,0(sp)
8113b9f8:	dec00104 	addi	sp,sp,4
8113b9fc:	f800283a 	ret

8113ba00 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
8113ba00:	defffc04 	addi	sp,sp,-16
8113ba04:	de00012e 	bgeu	sp,et,8113ba0c <OS_StrCopy+0xc>
8113ba08:	003b68fa 	trap	3
8113ba0c:	df000315 	stw	fp,12(sp)
8113ba10:	df000304 	addi	fp,sp,12
8113ba14:	e13ffe15 	stw	r4,-8(fp)
8113ba18:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
8113ba1c:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
8113ba20:	00000b06 	br	8113ba50 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
8113ba24:	e0bffe17 	ldw	r2,-8(fp)
8113ba28:	10c00044 	addi	r3,r2,1
8113ba2c:	e0fffe15 	stw	r3,-8(fp)
8113ba30:	e0ffff17 	ldw	r3,-4(fp)
8113ba34:	19000044 	addi	r4,r3,1
8113ba38:	e13fff15 	stw	r4,-4(fp)
8113ba3c:	18c00003 	ldbu	r3,0(r3)
8113ba40:	10c00005 	stb	r3,0(r2)
        len++;
8113ba44:	e0bffd03 	ldbu	r2,-12(fp)
8113ba48:	10800044 	addi	r2,r2,1
8113ba4c:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8113ba50:	e0bfff17 	ldw	r2,-4(fp)
8113ba54:	10800003 	ldbu	r2,0(r2)
8113ba58:	10803fcc 	andi	r2,r2,255
8113ba5c:	103ff11e 	bne	r2,zero,8113ba24 <__reset+0xfb11ba24>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
8113ba60:	e0bffe17 	ldw	r2,-8(fp)
8113ba64:	10000005 	stb	zero,0(r2)
    return (len);
8113ba68:	e0bffd03 	ldbu	r2,-12(fp)
}
8113ba6c:	e037883a 	mov	sp,fp
8113ba70:	df000017 	ldw	fp,0(sp)
8113ba74:	dec00104 	addi	sp,sp,4
8113ba78:	f800283a 	ret

8113ba7c <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
8113ba7c:	defffd04 	addi	sp,sp,-12
8113ba80:	de00012e 	bgeu	sp,et,8113ba88 <OS_StrLen+0xc>
8113ba84:	003b68fa 	trap	3
8113ba88:	df000215 	stw	fp,8(sp)
8113ba8c:	df000204 	addi	fp,sp,8
8113ba90:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
8113ba94:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
8113ba98:	00000606 	br	8113bab4 <OS_StrLen+0x38>
        psrc++;
8113ba9c:	e0bfff17 	ldw	r2,-4(fp)
8113baa0:	10800044 	addi	r2,r2,1
8113baa4:	e0bfff15 	stw	r2,-4(fp)
        len++;
8113baa8:	e0bffe03 	ldbu	r2,-8(fp)
8113baac:	10800044 	addi	r2,r2,1
8113bab0:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8113bab4:	e0bfff17 	ldw	r2,-4(fp)
8113bab8:	10800003 	ldbu	r2,0(r2)
8113babc:	10803fcc 	andi	r2,r2,255
8113bac0:	103ff61e 	bne	r2,zero,8113ba9c <__reset+0xfb11ba9c>
        psrc++;
        len++;
    }
    return (len);
8113bac4:	e0bffe03 	ldbu	r2,-8(fp)
}
8113bac8:	e037883a 	mov	sp,fp
8113bacc:	df000017 	ldw	fp,0(sp)
8113bad0:	dec00104 	addi	sp,sp,4
8113bad4:	f800283a 	ret

8113bad8 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
8113bad8:	defffa04 	addi	sp,sp,-24
8113badc:	de00012e 	bgeu	sp,et,8113bae4 <OS_TaskIdle+0xc>
8113bae0:	003b68fa 	trap	3
8113bae4:	dfc00515 	stw	ra,20(sp)
8113bae8:	df000415 	stw	fp,16(sp)
8113baec:	df000404 	addi	fp,sp,16
8113baf0:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113baf4:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113baf8:	0005303a 	rdctl	r2,status
8113bafc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bb00:	e0fffd17 	ldw	r3,-12(fp)
8113bb04:	00bfff84 	movi	r2,-2
8113bb08:	1884703a 	and	r2,r3,r2
8113bb0c:	1001703a 	wrctl	status,r2
  
  return context;
8113bb10:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
8113bb14:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
8113bb18:	d0a09217 	ldw	r2,-32184(gp)
8113bb1c:	10800044 	addi	r2,r2,1
8113bb20:	d0a09215 	stw	r2,-32184(gp)
8113bb24:	e0bffc17 	ldw	r2,-16(fp)
8113bb28:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bb2c:	e0bffe17 	ldw	r2,-8(fp)
8113bb30:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
8113bb34:	114cc700 	call	8114cc70 <OSTaskIdleHook>
    }
8113bb38:	003fef06 	br	8113baf8 <__reset+0xfb11baf8>

8113bb3c <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
8113bb3c:	defff804 	addi	sp,sp,-32
8113bb40:	de00012e 	bgeu	sp,et,8113bb48 <OS_TaskStat+0xc>
8113bb44:	003b68fa 	trap	3
8113bb48:	dfc00715 	stw	ra,28(sp)
8113bb4c:	df000615 	stw	fp,24(sp)
8113bb50:	dc400515 	stw	r17,20(sp)
8113bb54:	dc000415 	stw	r16,16(sp)
8113bb58:	df000604 	addi	fp,sp,24
8113bb5c:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bb60:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8113bb64:	00000206 	br	8113bb70 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
8113bb68:	01003204 	movi	r4,200
8113bb6c:	11425e80 	call	811425e8 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8113bb70:	d0a0a703 	ldbu	r2,-32100(gp)
8113bb74:	10803fcc 	andi	r2,r2,255
8113bb78:	103ffb26 	beq	r2,zero,8113bb68 <__reset+0xfb11bb68>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
8113bb7c:	d0e09817 	ldw	r3,-32160(gp)
8113bb80:	00947b34 	movhi	r2,20972
8113bb84:	10a147c4 	addi	r2,r2,-31457
8113bb88:	1888383a 	mulxuu	r4,r3,r2
8113bb8c:	1885383a 	mul	r2,r3,r2
8113bb90:	1021883a 	mov	r16,r2
8113bb94:	2023883a 	mov	r17,r4
8113bb98:	8804d17a 	srli	r2,r17,5
8113bb9c:	d0a09815 	stw	r2,-32160(gp)
    if (OSIdleCtrMax == 0L) {
8113bba0:	d0a09817 	ldw	r2,-32160(gp)
8113bba4:	1000031e 	bne	r2,zero,8113bbb4 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
8113bba8:	d0209a05 	stb	zero,-32152(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
8113bbac:	01003fc4 	movi	r4,255
8113bbb0:	11422580 	call	81142258 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bbb4:	0005303a 	rdctl	r2,status
8113bbb8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bbbc:	e0fffb17 	ldw	r3,-20(fp)
8113bbc0:	00bfff84 	movi	r2,-2
8113bbc4:	1884703a 	and	r2,r3,r2
8113bbc8:	1001703a 	wrctl	status,r2
  
  return context;
8113bbcc:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
8113bbd0:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
8113bbd4:	d0a09217 	ldw	r2,-32184(gp)
8113bbd8:	d0a0a815 	stw	r2,-32096(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
8113bbdc:	d0209215 	stw	zero,-32184(gp)
8113bbe0:	e0bffa17 	ldw	r2,-24(fp)
8113bbe4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bbe8:	e0bffc17 	ldw	r2,-16(fp)
8113bbec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
8113bbf0:	d0e0a817 	ldw	r3,-32096(gp)
8113bbf4:	d0a09817 	ldw	r2,-32160(gp)
8113bbf8:	1885203a 	divu	r2,r3,r2
8113bbfc:	1007883a 	mov	r3,r2
8113bc00:	00801904 	movi	r2,100
8113bc04:	10c5c83a 	sub	r2,r2,r3
8113bc08:	d0a09a05 	stb	r2,-32152(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
8113bc0c:	114cba00 	call	8114cba0 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
8113bc10:	113bc200 	call	8113bc20 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
8113bc14:	01001904 	movi	r4,100
8113bc18:	11425e80 	call	811425e8 <OSTimeDly>
    }
8113bc1c:	003fe506 	br	8113bbb4 <__reset+0xfb11bbb4>

8113bc20 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
8113bc20:	defffa04 	addi	sp,sp,-24
8113bc24:	de00012e 	bgeu	sp,et,8113bc2c <OS_TaskStatStkChk+0xc>
8113bc28:	003b68fa 	trap	3
8113bc2c:	dfc00515 	stw	ra,20(sp)
8113bc30:	df000415 	stw	fp,16(sp)
8113bc34:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8113bc38:	e03ffc05 	stb	zero,-16(fp)
8113bc3c:	00002406 	br	8113bcd0 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
8113bc40:	e0bffc03 	ldbu	r2,-16(fp)
8113bc44:	e0fffe04 	addi	r3,fp,-8
8113bc48:	180b883a 	mov	r5,r3
8113bc4c:	1009883a 	mov	r4,r2
8113bc50:	11420900 	call	81142090 <OSTaskStkChk>
8113bc54:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
8113bc58:	e0bffc43 	ldbu	r2,-15(fp)
8113bc5c:	1000191e 	bne	r2,zero,8113bcc4 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
8113bc60:	e0fffc03 	ldbu	r3,-16(fp)
8113bc64:	00a045f4 	movhi	r2,33047
8113bc68:	10ba6804 	addi	r2,r2,-5728
8113bc6c:	18c7883a 	add	r3,r3,r3
8113bc70:	18c7883a 	add	r3,r3,r3
8113bc74:	10c5883a 	add	r2,r2,r3
8113bc78:	10800017 	ldw	r2,0(r2)
8113bc7c:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
8113bc80:	e0bffd17 	ldw	r2,-12(fp)
8113bc84:	10000f26 	beq	r2,zero,8113bcc4 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
8113bc88:	e0bffd17 	ldw	r2,-12(fp)
8113bc8c:	10800060 	cmpeqi	r2,r2,1
8113bc90:	10000c1e 	bne	r2,zero,8113bcc4 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
8113bc94:	e0bffd17 	ldw	r2,-12(fp)
8113bc98:	10c00217 	ldw	r3,8(r2)
8113bc9c:	e0bffd17 	ldw	r2,-12(fp)
8113bca0:	10800317 	ldw	r2,12(r2)
8113bca4:	1085883a 	add	r2,r2,r2
8113bca8:	1085883a 	add	r2,r2,r2
8113bcac:	1887883a 	add	r3,r3,r2
8113bcb0:	e0bffd17 	ldw	r2,-12(fp)
8113bcb4:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
8113bcb8:	e0ffff17 	ldw	r3,-4(fp)
8113bcbc:	e0bffd17 	ldw	r2,-12(fp)
8113bcc0:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8113bcc4:	e0bffc03 	ldbu	r2,-16(fp)
8113bcc8:	10800044 	addi	r2,r2,1
8113bccc:	e0bffc05 	stb	r2,-16(fp)
8113bcd0:	e0bffc03 	ldbu	r2,-16(fp)
8113bcd4:	10800af0 	cmpltui	r2,r2,43
8113bcd8:	103fd91e 	bne	r2,zero,8113bc40 <__reset+0xfb11bc40>
#endif
                }
            }
        }
    }
}
8113bcdc:	0001883a 	nop
8113bce0:	e037883a 	mov	sp,fp
8113bce4:	dfc00117 	ldw	ra,4(sp)
8113bce8:	df000017 	ldw	fp,0(sp)
8113bcec:	dec00204 	addi	sp,sp,8
8113bcf0:	f800283a 	ret

8113bcf4 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
8113bcf4:	defff204 	addi	sp,sp,-56
8113bcf8:	de00012e 	bgeu	sp,et,8113bd00 <OS_TCBInit+0xc>
8113bcfc:	003b68fa 	trap	3
8113bd00:	dfc00d15 	stw	ra,52(sp)
8113bd04:	df000c15 	stw	fp,48(sp)
8113bd08:	df000c04 	addi	fp,sp,48
8113bd0c:	e17ffc15 	stw	r5,-16(fp)
8113bd10:	e1bffd15 	stw	r6,-12(fp)
8113bd14:	3807883a 	mov	r3,r7
8113bd18:	e0800417 	ldw	r2,16(fp)
8113bd1c:	e13ffb05 	stb	r4,-20(fp)
8113bd20:	e0fffe0d 	sth	r3,-8(fp)
8113bd24:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113bd28:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bd2c:	0005303a 	rdctl	r2,status
8113bd30:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bd34:	e0fffa17 	ldw	r3,-24(fp)
8113bd38:	00bfff84 	movi	r2,-2
8113bd3c:	1884703a 	and	r2,r3,r2
8113bd40:	1001703a 	wrctl	status,r2
  
  return context;
8113bd44:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
8113bd48:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
8113bd4c:	d0a09917 	ldw	r2,-32156(gp)
8113bd50:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
8113bd54:	e0bff617 	ldw	r2,-40(fp)
8113bd58:	10009326 	beq	r2,zero,8113bfa8 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
8113bd5c:	e0bff617 	ldw	r2,-40(fp)
8113bd60:	10800517 	ldw	r2,20(r2)
8113bd64:	d0a09915 	stw	r2,-32156(gp)
8113bd68:	e0bff417 	ldw	r2,-48(fp)
8113bd6c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bd70:	e0bff817 	ldw	r2,-32(fp)
8113bd74:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
8113bd78:	e0bff617 	ldw	r2,-40(fp)
8113bd7c:	e0fffc17 	ldw	r3,-16(fp)
8113bd80:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
8113bd84:	e0bff617 	ldw	r2,-40(fp)
8113bd88:	e0fffb03 	ldbu	r3,-20(fp)
8113bd8c:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
8113bd90:	e0bff617 	ldw	r2,-40(fp)
8113bd94:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
8113bd98:	e0bff617 	ldw	r2,-40(fp)
8113bd9c:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
8113bda0:	e0bff617 	ldw	r2,-40(fp)
8113bda4:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
8113bda8:	e0bff617 	ldw	r2,-40(fp)
8113bdac:	e0c00317 	ldw	r3,12(fp)
8113bdb0:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
8113bdb4:	e0bff617 	ldw	r2,-40(fp)
8113bdb8:	e0c00217 	ldw	r3,8(fp)
8113bdbc:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
8113bdc0:	e0bff617 	ldw	r2,-40(fp)
8113bdc4:	e0fffd17 	ldw	r3,-12(fp)
8113bdc8:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
8113bdcc:	e0bff617 	ldw	r2,-40(fp)
8113bdd0:	e0ffff0b 	ldhu	r3,-4(fp)
8113bdd4:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
8113bdd8:	e0bff617 	ldw	r2,-40(fp)
8113bddc:	e0fffe0b 	ldhu	r3,-8(fp)
8113bde0:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
8113bde4:	e0bff617 	ldw	r2,-40(fp)
8113bde8:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
8113bdec:	e0bffb03 	ldbu	r2,-20(fp)
8113bdf0:	1004d0fa 	srli	r2,r2,3
8113bdf4:	1007883a 	mov	r3,r2
8113bdf8:	e0bff617 	ldw	r2,-40(fp)
8113bdfc:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
8113be00:	e0bffb03 	ldbu	r2,-20(fp)
8113be04:	108001cc 	andi	r2,r2,7
8113be08:	1007883a 	mov	r3,r2
8113be0c:	e0bff617 	ldw	r2,-40(fp)
8113be10:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
8113be14:	e0bff617 	ldw	r2,-40(fp)
8113be18:	10800d03 	ldbu	r2,52(r2)
8113be1c:	10803fcc 	andi	r2,r2,255
8113be20:	00c00044 	movi	r3,1
8113be24:	1884983a 	sll	r2,r3,r2
8113be28:	1007883a 	mov	r3,r2
8113be2c:	e0bff617 	ldw	r2,-40(fp)
8113be30:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
8113be34:	e0bff617 	ldw	r2,-40(fp)
8113be38:	10800cc3 	ldbu	r2,51(r2)
8113be3c:	10803fcc 	andi	r2,r2,255
8113be40:	00c00044 	movi	r3,1
8113be44:	1884983a 	sll	r2,r3,r2
8113be48:	1007883a 	mov	r3,r2
8113be4c:	e0bff617 	ldw	r2,-40(fp)
8113be50:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
8113be54:	e0bff617 	ldw	r2,-40(fp)
8113be58:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
8113be5c:	e0bff617 	ldw	r2,-40(fp)
8113be60:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
8113be64:	e0bff617 	ldw	r2,-40(fp)
8113be68:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
8113be6c:	e0bff617 	ldw	r2,-40(fp)
8113be70:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
8113be74:	e0bff617 	ldw	r2,-40(fp)
8113be78:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
8113be7c:	e0bff617 	ldw	r2,-40(fp)
8113be80:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
8113be84:	e0bff617 	ldw	r2,-40(fp)
8113be88:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
8113be8c:	e0bff617 	ldw	r2,-40(fp)
8113be90:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
8113be94:	e0bff617 	ldw	r2,-40(fp)
8113be98:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
8113be9c:	e0bff617 	ldw	r2,-40(fp)
8113bea0:	00c00fc4 	movi	r3,63
8113bea4:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113bea8:	e0bff617 	ldw	r2,-40(fp)
8113beac:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
8113beb0:	e13ff617 	ldw	r4,-40(fp)
8113beb4:	114cc980 	call	8114cc98 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
8113beb8:	e13ff617 	ldw	r4,-40(fp)
8113bebc:	114cb200 	call	8114cb20 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bec0:	0005303a 	rdctl	r2,status
8113bec4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bec8:	e0fff517 	ldw	r3,-44(fp)
8113becc:	00bfff84 	movi	r2,-2
8113bed0:	1884703a 	and	r2,r3,r2
8113bed4:	1001703a 	wrctl	status,r2
  
  return context;
8113bed8:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
8113bedc:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
8113bee0:	e0fffb03 	ldbu	r3,-20(fp)
8113bee4:	00a045f4 	movhi	r2,33047
8113bee8:	10ba6804 	addi	r2,r2,-5728
8113beec:	18c7883a 	add	r3,r3,r3
8113bef0:	18c7883a 	add	r3,r3,r3
8113bef4:	10c5883a 	add	r2,r2,r3
8113bef8:	e0fff617 	ldw	r3,-40(fp)
8113befc:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
8113bf00:	d0e09417 	ldw	r3,-32176(gp)
8113bf04:	e0bff617 	ldw	r2,-40(fp)
8113bf08:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
8113bf0c:	e0bff617 	ldw	r2,-40(fp)
8113bf10:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
8113bf14:	d0a09417 	ldw	r2,-32176(gp)
8113bf18:	10000326 	beq	r2,zero,8113bf28 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
8113bf1c:	d0a09417 	ldw	r2,-32176(gp)
8113bf20:	e0fff617 	ldw	r3,-40(fp)
8113bf24:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
8113bf28:	e0bff617 	ldw	r2,-40(fp)
8113bf2c:	d0a09415 	stw	r2,-32176(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
8113bf30:	e0bff617 	ldw	r2,-40(fp)
8113bf34:	10c00d83 	ldbu	r3,54(r2)
8113bf38:	d0a09e03 	ldbu	r2,-32136(gp)
8113bf3c:	1884b03a 	or	r2,r3,r2
8113bf40:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113bf44:	e0bff617 	ldw	r2,-40(fp)
8113bf48:	10800d03 	ldbu	r2,52(r2)
8113bf4c:	10c03fcc 	andi	r3,r2,255
8113bf50:	e0bff617 	ldw	r2,-40(fp)
8113bf54:	10800d03 	ldbu	r2,52(r2)
8113bf58:	11003fcc 	andi	r4,r2,255
8113bf5c:	d0a09e44 	addi	r2,gp,-32135
8113bf60:	2085883a 	add	r2,r4,r2
8113bf64:	11000003 	ldbu	r4,0(r2)
8113bf68:	e0bff617 	ldw	r2,-40(fp)
8113bf6c:	10800d43 	ldbu	r2,53(r2)
8113bf70:	2084b03a 	or	r2,r4,r2
8113bf74:	1009883a 	mov	r4,r2
8113bf78:	d0a09e44 	addi	r2,gp,-32135
8113bf7c:	1885883a 	add	r2,r3,r2
8113bf80:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
8113bf84:	d0a09a43 	ldbu	r2,-32151(gp)
8113bf88:	10800044 	addi	r2,r2,1
8113bf8c:	d0a09a45 	stb	r2,-32151(gp)
8113bf90:	e0bff417 	ldw	r2,-48(fp)
8113bf94:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bf98:	e0bff717 	ldw	r2,-36(fp)
8113bf9c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113bfa0:	0005883a 	mov	r2,zero
8113bfa4:	00000506 	br	8113bfbc <OS_TCBInit+0x2c8>
8113bfa8:	e0bff417 	ldw	r2,-48(fp)
8113bfac:	e0bff915 	stw	r2,-28(fp)
8113bfb0:	e0bff917 	ldw	r2,-28(fp)
8113bfb4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
8113bfb8:	00801084 	movi	r2,66
}
8113bfbc:	e037883a 	mov	sp,fp
8113bfc0:	dfc00117 	ldw	ra,4(sp)
8113bfc4:	df000017 	ldw	fp,0(sp)
8113bfc8:	dec00204 	addi	sp,sp,8
8113bfcc:	f800283a 	ret

8113bfd0 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
8113bfd0:	defffe04 	addi	sp,sp,-8
8113bfd4:	de00012e 	bgeu	sp,et,8113bfdc <OSDebugInit+0xc>
8113bfd8:	003b68fa 	trap	3
8113bfdc:	df000115 	stw	fp,4(sp)
8113bfe0:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
8113bfe4:	d0a01804 	addi	r2,gp,-32672
8113bfe8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
8113bfec:	d0a01904 	addi	r2,gp,-32668
8113bff0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
8113bff4:	d0a01a84 	addi	r2,gp,-32662
8113bff8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
8113bffc:	d0a01b04 	addi	r2,gp,-32660
8113c000:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
8113c004:	d0a01a04 	addi	r2,gp,-32664
8113c008:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
8113c00c:	d0a01b84 	addi	r2,gp,-32658
8113c010:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
8113c014:	d0a01c04 	addi	r2,gp,-32656
8113c018:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
8113c01c:	d0a01c84 	addi	r2,gp,-32654
8113c020:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
8113c024:	d0a01d04 	addi	r2,gp,-32652
8113c028:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
8113c02c:	d0a01d84 	addi	r2,gp,-32650
8113c030:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
8113c034:	d0a01e04 	addi	r2,gp,-32648
8113c038:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
8113c03c:	d0a01e84 	addi	r2,gp,-32646
8113c040:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
8113c044:	d0a01f04 	addi	r2,gp,-32644
8113c048:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
8113c04c:	d0a01f84 	addi	r2,gp,-32642
8113c050:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
8113c054:	d0a02004 	addi	r2,gp,-32640
8113c058:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
8113c05c:	d0a02084 	addi	r2,gp,-32638
8113c060:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
8113c064:	d0a02104 	addi	r2,gp,-32636
8113c068:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
8113c06c:	d0a02184 	addi	r2,gp,-32634
8113c070:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
8113c074:	d0a02204 	addi	r2,gp,-32632
8113c078:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
8113c07c:	d0a02284 	addi	r2,gp,-32630
8113c080:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
8113c084:	d0a02304 	addi	r2,gp,-32628
8113c088:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
8113c08c:	d0a02384 	addi	r2,gp,-32626
8113c090:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
8113c094:	d0a02404 	addi	r2,gp,-32624
8113c098:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
8113c09c:	d0a02484 	addi	r2,gp,-32622
8113c0a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
8113c0a4:	d0a02504 	addi	r2,gp,-32620
8113c0a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
8113c0ac:	d0a02584 	addi	r2,gp,-32618
8113c0b0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
8113c0b4:	d0a02604 	addi	r2,gp,-32616
8113c0b8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
8113c0bc:	d0a02684 	addi	r2,gp,-32614
8113c0c0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
8113c0c4:	d0a02704 	addi	r2,gp,-32612
8113c0c8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
8113c0cc:	d0a02784 	addi	r2,gp,-32610
8113c0d0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
8113c0d4:	d0a02804 	addi	r2,gp,-32608
8113c0d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
8113c0dc:	d0a02884 	addi	r2,gp,-32606
8113c0e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
8113c0e4:	d0a02904 	addi	r2,gp,-32604
8113c0e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
8113c0ec:	d0a02984 	addi	r2,gp,-32602
8113c0f0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
8113c0f4:	d0a02a04 	addi	r2,gp,-32600
8113c0f8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
8113c0fc:	d0a02a84 	addi	r2,gp,-32598
8113c100:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
8113c104:	d0a02b04 	addi	r2,gp,-32596
8113c108:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
8113c10c:	d0a02b84 	addi	r2,gp,-32594
8113c110:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
8113c114:	d0a02c04 	addi	r2,gp,-32592
8113c118:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
8113c11c:	d0a02c84 	addi	r2,gp,-32590
8113c120:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
8113c124:	d0a02d04 	addi	r2,gp,-32588
8113c128:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
8113c12c:	d0a02d84 	addi	r2,gp,-32586
8113c130:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
8113c134:	d0a02e04 	addi	r2,gp,-32584
8113c138:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
8113c13c:	d0a02e84 	addi	r2,gp,-32582
8113c140:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
8113c144:	00a045f4 	movhi	r2,33047
8113c148:	10a48604 	addi	r2,r2,-28136
8113c14c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
8113c150:	00a045f4 	movhi	r2,33047
8113c154:	10a27204 	addi	r2,r2,-30264
8113c158:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
8113c15c:	d0a02f84 	addi	r2,gp,-32578
8113c160:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
8113c164:	d0a03004 	addi	r2,gp,-32576
8113c168:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
8113c16c:	d0a03084 	addi	r2,gp,-32574
8113c170:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
8113c174:	d0a03104 	addi	r2,gp,-32572
8113c178:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
8113c17c:	d0a03184 	addi	r2,gp,-32570
8113c180:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
8113c184:	d0a03204 	addi	r2,gp,-32568
8113c188:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
8113c18c:	d0a03284 	addi	r2,gp,-32566
8113c190:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
8113c194:	d0a03304 	addi	r2,gp,-32564
8113c198:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
8113c19c:	d0a03384 	addi	r2,gp,-32562
8113c1a0:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
8113c1a4:	d0a02f04 	addi	r2,gp,-32580
8113c1a8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
8113c1ac:	d0a03404 	addi	r2,gp,-32560
8113c1b0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
8113c1b4:	0001883a 	nop
8113c1b8:	e037883a 	mov	sp,fp
8113c1bc:	df000017 	ldw	fp,0(sp)
8113c1c0:	dec00104 	addi	sp,sp,4
8113c1c4:	f800283a 	ret

8113c1c8 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
8113c1c8:	defff204 	addi	sp,sp,-56
8113c1cc:	de00012e 	bgeu	sp,et,8113c1d4 <OSFlagAccept+0xc>
8113c1d0:	003b68fa 	trap	3
8113c1d4:	df000d15 	stw	fp,52(sp)
8113c1d8:	df000d04 	addi	fp,sp,52
8113c1dc:	e13ffc15 	stw	r4,-16(fp)
8113c1e0:	2807883a 	mov	r3,r5
8113c1e4:	3005883a 	mov	r2,r6
8113c1e8:	e1ffff15 	stw	r7,-4(fp)
8113c1ec:	e0fffd0d 	sth	r3,-12(fp)
8113c1f0:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113c1f4:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c1f8:	e0bfff17 	ldw	r2,-4(fp)
8113c1fc:	1000021e 	bne	r2,zero,8113c208 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
8113c200:	0005883a 	mov	r2,zero
8113c204:	0000b006 	br	8113c4c8 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113c208:	e0bffc17 	ldw	r2,-16(fp)
8113c20c:	1000051e 	bne	r2,zero,8113c224 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113c210:	e0bfff17 	ldw	r2,-4(fp)
8113c214:	00c01b84 	movi	r3,110
8113c218:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c21c:	0005883a 	mov	r2,zero
8113c220:	0000a906 	br	8113c4c8 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113c224:	e0bffc17 	ldw	r2,-16(fp)
8113c228:	10800003 	ldbu	r2,0(r2)
8113c22c:	10803fcc 	andi	r2,r2,255
8113c230:	10800160 	cmpeqi	r2,r2,5
8113c234:	1000051e 	bne	r2,zero,8113c24c <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
8113c238:	e0bfff17 	ldw	r2,-4(fp)
8113c23c:	00c00044 	movi	r3,1
8113c240:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c244:	0005883a 	mov	r2,zero
8113c248:	00009f06 	br	8113c4c8 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113c24c:	e0fffe03 	ldbu	r3,-8(fp)
8113c250:	00bfe004 	movi	r2,-128
8113c254:	1884703a 	and	r2,r3,r2
8113c258:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
8113c25c:	e0bff503 	ldbu	r2,-44(fp)
8113c260:	10000626 	beq	r2,zero,8113c27c <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
8113c264:	e0bffe03 	ldbu	r2,-8(fp)
8113c268:	10801fcc 	andi	r2,r2,127
8113c26c:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113c270:	00800044 	movi	r2,1
8113c274:	e0bff385 	stb	r2,-50(fp)
8113c278:	00000106 	br	8113c280 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
8113c27c:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
8113c280:	e0bfff17 	ldw	r2,-4(fp)
8113c284:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c288:	0005303a 	rdctl	r2,status
8113c28c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c290:	e0fffb17 	ldw	r3,-20(fp)
8113c294:	00bfff84 	movi	r2,-2
8113c298:	1884703a 	and	r2,r3,r2
8113c29c:	1001703a 	wrctl	status,r2
  
  return context;
8113c2a0:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
8113c2a4:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
8113c2a8:	e0bffe03 	ldbu	r2,-8(fp)
8113c2ac:	10c00060 	cmpeqi	r3,r2,1
8113c2b0:	18005f1e 	bne	r3,zero,8113c430 <OSFlagAccept+0x268>
8113c2b4:	10c00088 	cmpgei	r3,r2,2
8113c2b8:	1800021e 	bne	r3,zero,8113c2c4 <OSFlagAccept+0xfc>
8113c2bc:	10003f26 	beq	r2,zero,8113c3bc <OSFlagAccept+0x1f4>
8113c2c0:	00007706 	br	8113c4a0 <OSFlagAccept+0x2d8>
8113c2c4:	10c000a0 	cmpeqi	r3,r2,2
8113c2c8:	1800031e 	bne	r3,zero,8113c2d8 <OSFlagAccept+0x110>
8113c2cc:	108000e0 	cmpeqi	r2,r2,3
8113c2d0:	10001e1e 	bne	r2,zero,8113c34c <OSFlagAccept+0x184>
8113c2d4:	00007206 	br	8113c4a0 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113c2d8:	e0bffc17 	ldw	r2,-16(fp)
8113c2dc:	10c0020b 	ldhu	r3,8(r2)
8113c2e0:	e0bffd0b 	ldhu	r2,-12(fp)
8113c2e4:	1884703a 	and	r2,r3,r2
8113c2e8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113c2ec:	e0fff30b 	ldhu	r3,-52(fp)
8113c2f0:	e0bffd0b 	ldhu	r2,-12(fp)
8113c2f4:	18800d1e 	bne	r3,r2,8113c32c <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c2f8:	e0bff383 	ldbu	r2,-50(fp)
8113c2fc:	10800058 	cmpnei	r2,r2,1
8113c300:	10000d1e 	bne	r2,zero,8113c338 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113c304:	e0bffc17 	ldw	r2,-16(fp)
8113c308:	1080020b 	ldhu	r2,8(r2)
8113c30c:	1007883a 	mov	r3,r2
8113c310:	e0bff30b 	ldhu	r2,-52(fp)
8113c314:	0084303a 	nor	r2,zero,r2
8113c318:	1884703a 	and	r2,r3,r2
8113c31c:	1007883a 	mov	r3,r2
8113c320:	e0bffc17 	ldw	r2,-16(fp)
8113c324:	10c0020d 	sth	r3,8(r2)
8113c328:	00000306 	br	8113c338 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113c32c:	e0bfff17 	ldw	r2,-4(fp)
8113c330:	00c01c04 	movi	r3,112
8113c334:	10c00005 	stb	r3,0(r2)
8113c338:	e0bff417 	ldw	r2,-48(fp)
8113c33c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c340:	e0bff617 	ldw	r2,-40(fp)
8113c344:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113c348:	00005e06 	br	8113c4c4 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113c34c:	e0bffc17 	ldw	r2,-16(fp)
8113c350:	10c0020b 	ldhu	r3,8(r2)
8113c354:	e0bffd0b 	ldhu	r2,-12(fp)
8113c358:	1884703a 	and	r2,r3,r2
8113c35c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113c360:	e0bff30b 	ldhu	r2,-52(fp)
8113c364:	10000d26 	beq	r2,zero,8113c39c <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c368:	e0bff383 	ldbu	r2,-50(fp)
8113c36c:	10800058 	cmpnei	r2,r2,1
8113c370:	10000d1e 	bne	r2,zero,8113c3a8 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113c374:	e0bffc17 	ldw	r2,-16(fp)
8113c378:	1080020b 	ldhu	r2,8(r2)
8113c37c:	1007883a 	mov	r3,r2
8113c380:	e0bff30b 	ldhu	r2,-52(fp)
8113c384:	0084303a 	nor	r2,zero,r2
8113c388:	1884703a 	and	r2,r3,r2
8113c38c:	1007883a 	mov	r3,r2
8113c390:	e0bffc17 	ldw	r2,-16(fp)
8113c394:	10c0020d 	sth	r3,8(r2)
8113c398:	00000306 	br	8113c3a8 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113c39c:	e0bfff17 	ldw	r2,-4(fp)
8113c3a0:	00c01c04 	movi	r3,112
8113c3a4:	10c00005 	stb	r3,0(r2)
8113c3a8:	e0bff417 	ldw	r2,-48(fp)
8113c3ac:	e0bff715 	stw	r2,-36(fp)
8113c3b0:	e0bff717 	ldw	r2,-36(fp)
8113c3b4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113c3b8:	00004206 	br	8113c4c4 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113c3bc:	e0bffc17 	ldw	r2,-16(fp)
8113c3c0:	1080020b 	ldhu	r2,8(r2)
8113c3c4:	0084303a 	nor	r2,zero,r2
8113c3c8:	1007883a 	mov	r3,r2
8113c3cc:	e0bffd0b 	ldhu	r2,-12(fp)
8113c3d0:	1884703a 	and	r2,r3,r2
8113c3d4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113c3d8:	e0fff30b 	ldhu	r3,-52(fp)
8113c3dc:	e0bffd0b 	ldhu	r2,-12(fp)
8113c3e0:	18800b1e 	bne	r3,r2,8113c410 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c3e4:	e0bff383 	ldbu	r2,-50(fp)
8113c3e8:	10800058 	cmpnei	r2,r2,1
8113c3ec:	10000b1e 	bne	r2,zero,8113c41c <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113c3f0:	e0bffc17 	ldw	r2,-16(fp)
8113c3f4:	10c0020b 	ldhu	r3,8(r2)
8113c3f8:	e0bff30b 	ldhu	r2,-52(fp)
8113c3fc:	1884b03a 	or	r2,r3,r2
8113c400:	1007883a 	mov	r3,r2
8113c404:	e0bffc17 	ldw	r2,-16(fp)
8113c408:	10c0020d 	sth	r3,8(r2)
8113c40c:	00000306 	br	8113c41c <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113c410:	e0bfff17 	ldw	r2,-4(fp)
8113c414:	00c01c04 	movi	r3,112
8113c418:	10c00005 	stb	r3,0(r2)
8113c41c:	e0bff417 	ldw	r2,-48(fp)
8113c420:	e0bff815 	stw	r2,-32(fp)
8113c424:	e0bff817 	ldw	r2,-32(fp)
8113c428:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113c42c:	00002506 	br	8113c4c4 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113c430:	e0bffc17 	ldw	r2,-16(fp)
8113c434:	1080020b 	ldhu	r2,8(r2)
8113c438:	0084303a 	nor	r2,zero,r2
8113c43c:	1007883a 	mov	r3,r2
8113c440:	e0bffd0b 	ldhu	r2,-12(fp)
8113c444:	1884703a 	and	r2,r3,r2
8113c448:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113c44c:	e0bff30b 	ldhu	r2,-52(fp)
8113c450:	10000b26 	beq	r2,zero,8113c480 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c454:	e0bff383 	ldbu	r2,-50(fp)
8113c458:	10800058 	cmpnei	r2,r2,1
8113c45c:	10000b1e 	bne	r2,zero,8113c48c <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113c460:	e0bffc17 	ldw	r2,-16(fp)
8113c464:	10c0020b 	ldhu	r3,8(r2)
8113c468:	e0bff30b 	ldhu	r2,-52(fp)
8113c46c:	1884b03a 	or	r2,r3,r2
8113c470:	1007883a 	mov	r3,r2
8113c474:	e0bffc17 	ldw	r2,-16(fp)
8113c478:	10c0020d 	sth	r3,8(r2)
8113c47c:	00000306 	br	8113c48c <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113c480:	e0bfff17 	ldw	r2,-4(fp)
8113c484:	00c01c04 	movi	r3,112
8113c488:	10c00005 	stb	r3,0(r2)
8113c48c:	e0bff417 	ldw	r2,-48(fp)
8113c490:	e0bff915 	stw	r2,-28(fp)
8113c494:	e0bff917 	ldw	r2,-28(fp)
8113c498:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113c49c:	00000906 	br	8113c4c4 <OSFlagAccept+0x2fc>
8113c4a0:	e0bff417 	ldw	r2,-48(fp)
8113c4a4:	e0bffa15 	stw	r2,-24(fp)
8113c4a8:	e0bffa17 	ldw	r2,-24(fp)
8113c4ac:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113c4b0:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
8113c4b4:	e0bfff17 	ldw	r2,-4(fp)
8113c4b8:	00c01bc4 	movi	r3,111
8113c4bc:	10c00005 	stb	r3,0(r2)
             break;
8113c4c0:	0001883a 	nop
    }
    return (flags_rdy);
8113c4c4:	e0bff30b 	ldhu	r2,-52(fp)
}
8113c4c8:	e037883a 	mov	sp,fp
8113c4cc:	df000017 	ldw	fp,0(sp)
8113c4d0:	dec00104 	addi	sp,sp,4
8113c4d4:	f800283a 	ret

8113c4d8 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
8113c4d8:	defff804 	addi	sp,sp,-32
8113c4dc:	de00012e 	bgeu	sp,et,8113c4e4 <OSFlagCreate+0xc>
8113c4e0:	003b68fa 	trap	3
8113c4e4:	df000715 	stw	fp,28(sp)
8113c4e8:	df000704 	addi	fp,sp,28
8113c4ec:	2005883a 	mov	r2,r4
8113c4f0:	e17fff15 	stw	r5,-4(fp)
8113c4f4:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
8113c4f8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
8113c4fc:	e0bfff17 	ldw	r2,-4(fp)
8113c500:	1000021e 	bne	r2,zero,8113c50c <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
8113c504:	0005883a 	mov	r2,zero
8113c508:	00003306 	br	8113c5d8 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
8113c50c:	d0a0a103 	ldbu	r2,-32124(gp)
8113c510:	10803fcc 	andi	r2,r2,255
8113c514:	10000526 	beq	r2,zero,8113c52c <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
8113c518:	e0bfff17 	ldw	r2,-4(fp)
8113c51c:	00c00404 	movi	r3,16
8113c520:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
8113c524:	0005883a 	mov	r2,zero
8113c528:	00002b06 	br	8113c5d8 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c52c:	0005303a 	rdctl	r2,status
8113c530:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c534:	e0fffd17 	ldw	r3,-12(fp)
8113c538:	00bfff84 	movi	r2,-2
8113c53c:	1884703a 	and	r2,r3,r2
8113c540:	1001703a 	wrctl	status,r2
  
  return context;
8113c544:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113c548:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
8113c54c:	d0a0a617 	ldw	r2,-32104(gp)
8113c550:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
8113c554:	e0bffb17 	ldw	r2,-20(fp)
8113c558:	10001726 	beq	r2,zero,8113c5b8 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
8113c55c:	d0a0a617 	ldw	r2,-32104(gp)
8113c560:	10800117 	ldw	r2,4(r2)
8113c564:	d0a0a615 	stw	r2,-32104(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
8113c568:	e0bffb17 	ldw	r2,-20(fp)
8113c56c:	00c00144 	movi	r3,5
8113c570:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
8113c574:	e0bffb17 	ldw	r2,-20(fp)
8113c578:	e0fffe0b 	ldhu	r3,-8(fp)
8113c57c:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8113c580:	e0bffb17 	ldw	r2,-20(fp)
8113c584:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
8113c588:	e0bffb17 	ldw	r2,-20(fp)
8113c58c:	00c00fc4 	movi	r3,63
8113c590:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113c594:	e0bffb17 	ldw	r2,-20(fp)
8113c598:	100002c5 	stb	zero,11(r2)
8113c59c:	e0bff917 	ldw	r2,-28(fp)
8113c5a0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c5a4:	e0bffa17 	ldw	r2,-24(fp)
8113c5a8:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
8113c5ac:	e0bfff17 	ldw	r2,-4(fp)
8113c5b0:	10000005 	stb	zero,0(r2)
8113c5b4:	00000706 	br	8113c5d4 <OSFlagCreate+0xfc>
8113c5b8:	e0bff917 	ldw	r2,-28(fp)
8113c5bc:	e0bffc15 	stw	r2,-16(fp)
8113c5c0:	e0bffc17 	ldw	r2,-16(fp)
8113c5c4:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
8113c5c8:	e0bfff17 	ldw	r2,-4(fp)
8113c5cc:	00c01c84 	movi	r3,114
8113c5d0:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
8113c5d4:	e0bffb17 	ldw	r2,-20(fp)
}
8113c5d8:	e037883a 	mov	sp,fp
8113c5dc:	df000017 	ldw	fp,0(sp)
8113c5e0:	dec00104 	addi	sp,sp,4
8113c5e4:	f800283a 	ret

8113c5e8 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
8113c5e8:	defff204 	addi	sp,sp,-56
8113c5ec:	de00012e 	bgeu	sp,et,8113c5f4 <OSFlagDel+0xc>
8113c5f0:	003b68fa 	trap	3
8113c5f4:	dfc00d15 	stw	ra,52(sp)
8113c5f8:	df000c15 	stw	fp,48(sp)
8113c5fc:	df000c04 	addi	fp,sp,48
8113c600:	e13ffd15 	stw	r4,-12(fp)
8113c604:	2805883a 	mov	r2,r5
8113c608:	e1bfff15 	stw	r6,-4(fp)
8113c60c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113c610:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c614:	e0bfff17 	ldw	r2,-4(fp)
8113c618:	1000021e 	bne	r2,zero,8113c624 <OSFlagDel+0x3c>
        return (pgrp);
8113c61c:	e0bffd17 	ldw	r2,-12(fp)
8113c620:	00008006 	br	8113c824 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113c624:	e0bffd17 	ldw	r2,-12(fp)
8113c628:	1000051e 	bne	r2,zero,8113c640 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113c62c:	e0bfff17 	ldw	r2,-4(fp)
8113c630:	00c01b84 	movi	r3,110
8113c634:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113c638:	e0bffd17 	ldw	r2,-12(fp)
8113c63c:	00007906 	br	8113c824 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c640:	d0a0a103 	ldbu	r2,-32124(gp)
8113c644:	10803fcc 	andi	r2,r2,255
8113c648:	10000526 	beq	r2,zero,8113c660 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113c64c:	e0bfff17 	ldw	r2,-4(fp)
8113c650:	00c003c4 	movi	r3,15
8113c654:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113c658:	e0bffd17 	ldw	r2,-12(fp)
8113c65c:	00007106 	br	8113c824 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
8113c660:	e0bffd17 	ldw	r2,-12(fp)
8113c664:	10800003 	ldbu	r2,0(r2)
8113c668:	10803fcc 	andi	r2,r2,255
8113c66c:	10800160 	cmpeqi	r2,r2,5
8113c670:	1000051e 	bne	r2,zero,8113c688 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
8113c674:	e0bfff17 	ldw	r2,-4(fp)
8113c678:	00c00044 	movi	r3,1
8113c67c:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113c680:	e0bffd17 	ldw	r2,-12(fp)
8113c684:	00006706 	br	8113c824 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c688:	0005303a 	rdctl	r2,status
8113c68c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c690:	e0fffc17 	ldw	r3,-16(fp)
8113c694:	00bfff84 	movi	r2,-2
8113c698:	1884703a 	and	r2,r3,r2
8113c69c:	1001703a 	wrctl	status,r2
  
  return context;
8113c6a0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113c6a4:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
8113c6a8:	e0bffd17 	ldw	r2,-12(fp)
8113c6ac:	10800117 	ldw	r2,4(r2)
8113c6b0:	10000326 	beq	r2,zero,8113c6c0 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113c6b4:	00800044 	movi	r2,1
8113c6b8:	e0bff405 	stb	r2,-48(fp)
8113c6bc:	00000106 	br	8113c6c4 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113c6c0:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113c6c4:	e0bffe03 	ldbu	r2,-8(fp)
8113c6c8:	10000326 	beq	r2,zero,8113c6d8 <OSFlagDel+0xf0>
8113c6cc:	10800060 	cmpeqi	r2,r2,1
8113c6d0:	1000231e 	bne	r2,zero,8113c760 <OSFlagDel+0x178>
8113c6d4:	00004806 	br	8113c7f8 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
8113c6d8:	e0bff403 	ldbu	r2,-48(fp)
8113c6dc:	1000161e 	bne	r2,zero,8113c738 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
8113c6e0:	e0bffd17 	ldw	r2,-12(fp)
8113c6e4:	00c00fc4 	movi	r3,63
8113c6e8:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113c6ec:	e0bffd17 	ldw	r2,-12(fp)
8113c6f0:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113c6f4:	e0bffd17 	ldw	r2,-12(fp)
8113c6f8:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
8113c6fc:	d0e0a617 	ldw	r3,-32104(gp)
8113c700:	e0bffd17 	ldw	r2,-12(fp)
8113c704:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113c708:	e0bffd17 	ldw	r2,-12(fp)
8113c70c:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
8113c710:	e0bffd17 	ldw	r2,-12(fp)
8113c714:	d0a0a615 	stw	r2,-32104(gp)
8113c718:	e0bff717 	ldw	r2,-36(fp)
8113c71c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c720:	e0bff817 	ldw	r2,-32(fp)
8113c724:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
8113c728:	e0bfff17 	ldw	r2,-4(fp)
8113c72c:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
8113c730:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
8113c734:	00003a06 	br	8113c820 <OSFlagDel+0x238>
8113c738:	e0bff717 	ldw	r2,-36(fp)
8113c73c:	e0bff915 	stw	r2,-28(fp)
8113c740:	e0bff917 	ldw	r2,-28(fp)
8113c744:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
8113c748:	e0bfff17 	ldw	r2,-4(fp)
8113c74c:	00c01244 	movi	r3,73
8113c750:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
8113c754:	e0bffd17 	ldw	r2,-12(fp)
8113c758:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113c75c:	00003006 	br	8113c820 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113c760:	e0bffd17 	ldw	r2,-12(fp)
8113c764:	10800117 	ldw	r2,4(r2)
8113c768:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113c76c:	00000606 	br	8113c788 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
8113c770:	000b883a 	mov	r5,zero
8113c774:	e13ff517 	ldw	r4,-44(fp)
8113c778:	113d79c0 	call	8113d79c <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113c77c:	e0bff517 	ldw	r2,-44(fp)
8113c780:	10800017 	ldw	r2,0(r2)
8113c784:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113c788:	e0bff517 	ldw	r2,-44(fp)
8113c78c:	103ff81e 	bne	r2,zero,8113c770 <__reset+0xfb11c770>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
8113c790:	e0bffd17 	ldw	r2,-12(fp)
8113c794:	00c00fc4 	movi	r3,63
8113c798:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113c79c:	e0bffd17 	ldw	r2,-12(fp)
8113c7a0:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113c7a4:	e0bffd17 	ldw	r2,-12(fp)
8113c7a8:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
8113c7ac:	d0e0a617 	ldw	r3,-32104(gp)
8113c7b0:	e0bffd17 	ldw	r2,-12(fp)
8113c7b4:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113c7b8:	e0bffd17 	ldw	r2,-12(fp)
8113c7bc:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
8113c7c0:	e0bffd17 	ldw	r2,-12(fp)
8113c7c4:	d0a0a615 	stw	r2,-32104(gp)
8113c7c8:	e0bff717 	ldw	r2,-36(fp)
8113c7cc:	e0bffa15 	stw	r2,-24(fp)
8113c7d0:	e0bffa17 	ldw	r2,-24(fp)
8113c7d4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113c7d8:	e0bff403 	ldbu	r2,-48(fp)
8113c7dc:	10800058 	cmpnei	r2,r2,1
8113c7e0:	1000011e 	bne	r2,zero,8113c7e8 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113c7e4:	113b8ac0 	call	8113b8ac <OS_Sched>
             }
             *perr = OS_ERR_NONE;
8113c7e8:	e0bfff17 	ldw	r2,-4(fp)
8113c7ec:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
8113c7f0:	e03ff615 	stw	zero,-40(fp)
             break;
8113c7f4:	00000a06 	br	8113c820 <OSFlagDel+0x238>
8113c7f8:	e0bff717 	ldw	r2,-36(fp)
8113c7fc:	e0bffb15 	stw	r2,-20(fp)
8113c800:	e0bffb17 	ldw	r2,-20(fp)
8113c804:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
8113c808:	e0bfff17 	ldw	r2,-4(fp)
8113c80c:	00c001c4 	movi	r3,7
8113c810:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
8113c814:	e0bffd17 	ldw	r2,-12(fp)
8113c818:	e0bff615 	stw	r2,-40(fp)
             break;
8113c81c:	0001883a 	nop
    }
    return (pgrp_return);
8113c820:	e0bff617 	ldw	r2,-40(fp)
}
8113c824:	e037883a 	mov	sp,fp
8113c828:	dfc00117 	ldw	ra,4(sp)
8113c82c:	df000017 	ldw	fp,0(sp)
8113c830:	dec00204 	addi	sp,sp,8
8113c834:	f800283a 	ret

8113c838 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113c838:	defff604 	addi	sp,sp,-40
8113c83c:	de00012e 	bgeu	sp,et,8113c844 <OSFlagNameGet+0xc>
8113c840:	003b68fa 	trap	3
8113c844:	dfc00915 	stw	ra,36(sp)
8113c848:	df000815 	stw	fp,32(sp)
8113c84c:	df000804 	addi	fp,sp,32
8113c850:	e13ffd15 	stw	r4,-12(fp)
8113c854:	e17ffe15 	stw	r5,-8(fp)
8113c858:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c85c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113c860:	e0bfff17 	ldw	r2,-4(fp)
8113c864:	1000021e 	bne	r2,zero,8113c870 <OSFlagNameGet+0x38>
        return (0);
8113c868:	0005883a 	mov	r2,zero
8113c86c:	00003906 	br	8113c954 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113c870:	e0bffd17 	ldw	r2,-12(fp)
8113c874:	1000051e 	bne	r2,zero,8113c88c <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113c878:	e0bfff17 	ldw	r2,-4(fp)
8113c87c:	00c01b84 	movi	r3,110
8113c880:	10c00005 	stb	r3,0(r2)
        return (0);
8113c884:	0005883a 	mov	r2,zero
8113c888:	00003206 	br	8113c954 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113c88c:	e0bffe17 	ldw	r2,-8(fp)
8113c890:	1000051e 	bne	r2,zero,8113c8a8 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113c894:	e0bfff17 	ldw	r2,-4(fp)
8113c898:	00c00304 	movi	r3,12
8113c89c:	10c00005 	stb	r3,0(r2)
        return (0);
8113c8a0:	0005883a 	mov	r2,zero
8113c8a4:	00002b06 	br	8113c954 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113c8a8:	d0a0a103 	ldbu	r2,-32124(gp)
8113c8ac:	10803fcc 	andi	r2,r2,255
8113c8b0:	10000526 	beq	r2,zero,8113c8c8 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113c8b4:	e0bfff17 	ldw	r2,-4(fp)
8113c8b8:	00c00444 	movi	r3,17
8113c8bc:	10c00005 	stb	r3,0(r2)
        return (0);
8113c8c0:	0005883a 	mov	r2,zero
8113c8c4:	00002306 	br	8113c954 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c8c8:	0005303a 	rdctl	r2,status
8113c8cc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c8d0:	e0fffc17 	ldw	r3,-16(fp)
8113c8d4:	00bfff84 	movi	r2,-2
8113c8d8:	1884703a 	and	r2,r3,r2
8113c8dc:	1001703a 	wrctl	status,r2
  
  return context;
8113c8e0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113c8e4:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113c8e8:	e0bffd17 	ldw	r2,-12(fp)
8113c8ec:	10800003 	ldbu	r2,0(r2)
8113c8f0:	10803fcc 	andi	r2,r2,255
8113c8f4:	10800160 	cmpeqi	r2,r2,5
8113c8f8:	1000091e 	bne	r2,zero,8113c920 <OSFlagNameGet+0xe8>
8113c8fc:	e0bff817 	ldw	r2,-32(fp)
8113c900:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c904:	e0bff917 	ldw	r2,-28(fp)
8113c908:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113c90c:	e0bfff17 	ldw	r2,-4(fp)
8113c910:	00c00044 	movi	r3,1
8113c914:	10c00005 	stb	r3,0(r2)
        return (0);
8113c918:	0005883a 	mov	r2,zero
8113c91c:	00000d06 	br	8113c954 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
8113c920:	e0bffd17 	ldw	r2,-12(fp)
8113c924:	10800284 	addi	r2,r2,10
8113c928:	100b883a 	mov	r5,r2
8113c92c:	e13ffe17 	ldw	r4,-8(fp)
8113c930:	113ba000 	call	8113ba00 <OS_StrCopy>
8113c934:	e0bffb05 	stb	r2,-20(fp)
8113c938:	e0bff817 	ldw	r2,-32(fp)
8113c93c:	e0bffa15 	stw	r2,-24(fp)
8113c940:	e0bffa17 	ldw	r2,-24(fp)
8113c944:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113c948:	e0bfff17 	ldw	r2,-4(fp)
8113c94c:	10000005 	stb	zero,0(r2)
    return (len);
8113c950:	e0bffb03 	ldbu	r2,-20(fp)
}
8113c954:	e037883a 	mov	sp,fp
8113c958:	dfc00117 	ldw	ra,4(sp)
8113c95c:	df000017 	ldw	fp,0(sp)
8113c960:	dec00204 	addi	sp,sp,8
8113c964:	f800283a 	ret

8113c968 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113c968:	defff504 	addi	sp,sp,-44
8113c96c:	de00012e 	bgeu	sp,et,8113c974 <OSFlagNameSet+0xc>
8113c970:	003b68fa 	trap	3
8113c974:	dfc00a15 	stw	ra,40(sp)
8113c978:	df000915 	stw	fp,36(sp)
8113c97c:	df000904 	addi	fp,sp,36
8113c980:	e13ffd15 	stw	r4,-12(fp)
8113c984:	e17ffe15 	stw	r5,-8(fp)
8113c988:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c98c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113c990:	e0bfff17 	ldw	r2,-4(fp)
8113c994:	10004326 	beq	r2,zero,8113caa4 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113c998:	e0bffd17 	ldw	r2,-12(fp)
8113c99c:	1000041e 	bne	r2,zero,8113c9b0 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113c9a0:	e0bfff17 	ldw	r2,-4(fp)
8113c9a4:	00c01b84 	movi	r3,110
8113c9a8:	10c00005 	stb	r3,0(r2)
        return;
8113c9ac:	00003e06 	br	8113caa8 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113c9b0:	e0bffe17 	ldw	r2,-8(fp)
8113c9b4:	1000041e 	bne	r2,zero,8113c9c8 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113c9b8:	e0bfff17 	ldw	r2,-4(fp)
8113c9bc:	00c00304 	movi	r3,12
8113c9c0:	10c00005 	stb	r3,0(r2)
        return;
8113c9c4:	00003806 	br	8113caa8 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113c9c8:	d0a0a103 	ldbu	r2,-32124(gp)
8113c9cc:	10803fcc 	andi	r2,r2,255
8113c9d0:	10000426 	beq	r2,zero,8113c9e4 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113c9d4:	e0bfff17 	ldw	r2,-4(fp)
8113c9d8:	00c00484 	movi	r3,18
8113c9dc:	10c00005 	stb	r3,0(r2)
        return;
8113c9e0:	00003106 	br	8113caa8 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c9e4:	0005303a 	rdctl	r2,status
8113c9e8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c9ec:	e0fffc17 	ldw	r3,-16(fp)
8113c9f0:	00bfff84 	movi	r2,-2
8113c9f4:	1884703a 	and	r2,r3,r2
8113c9f8:	1001703a 	wrctl	status,r2
  
  return context;
8113c9fc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ca00:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113ca04:	e0bffd17 	ldw	r2,-12(fp)
8113ca08:	10800003 	ldbu	r2,0(r2)
8113ca0c:	10803fcc 	andi	r2,r2,255
8113ca10:	10800160 	cmpeqi	r2,r2,5
8113ca14:	1000081e 	bne	r2,zero,8113ca38 <OSFlagNameSet+0xd0>
8113ca18:	e0bff717 	ldw	r2,-36(fp)
8113ca1c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ca20:	e0bff817 	ldw	r2,-32(fp)
8113ca24:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113ca28:	e0bfff17 	ldw	r2,-4(fp)
8113ca2c:	00c00044 	movi	r3,1
8113ca30:	10c00005 	stb	r3,0(r2)
        return;
8113ca34:	00001c06 	br	8113caa8 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113ca38:	e13ffe17 	ldw	r4,-8(fp)
8113ca3c:	113ba7c0 	call	8113ba7c <OS_StrLen>
8113ca40:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
8113ca44:	e0bffa03 	ldbu	r2,-24(fp)
8113ca48:	10800830 	cmpltui	r2,r2,32
8113ca4c:	1000081e 	bne	r2,zero,8113ca70 <OSFlagNameSet+0x108>
8113ca50:	e0bff717 	ldw	r2,-36(fp)
8113ca54:	e0bff915 	stw	r2,-28(fp)
8113ca58:	e0bff917 	ldw	r2,-28(fp)
8113ca5c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
8113ca60:	e0bfff17 	ldw	r2,-4(fp)
8113ca64:	00c01cc4 	movi	r3,115
8113ca68:	10c00005 	stb	r3,0(r2)
        return;
8113ca6c:	00000e06 	br	8113caa8 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
8113ca70:	e0bffd17 	ldw	r2,-12(fp)
8113ca74:	10800284 	addi	r2,r2,10
8113ca78:	e17ffe17 	ldw	r5,-8(fp)
8113ca7c:	1009883a 	mov	r4,r2
8113ca80:	113ba000 	call	8113ba00 <OS_StrCopy>
8113ca84:	e0bff717 	ldw	r2,-36(fp)
8113ca88:	e0bffb15 	stw	r2,-20(fp)
8113ca8c:	e0bffb17 	ldw	r2,-20(fp)
8113ca90:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ca94:	e0bfff17 	ldw	r2,-4(fp)
8113ca98:	10000005 	stb	zero,0(r2)
    return;
8113ca9c:	0001883a 	nop
8113caa0:	00000106 	br	8113caa8 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113caa4:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
8113caa8:	e037883a 	mov	sp,fp
8113caac:	dfc00117 	ldw	ra,4(sp)
8113cab0:	df000017 	ldw	fp,0(sp)
8113cab4:	dec00204 	addi	sp,sp,8
8113cab8:	f800283a 	ret

8113cabc <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
8113cabc:	deffe104 	addi	sp,sp,-124
8113cac0:	de00012e 	bgeu	sp,et,8113cac8 <OSFlagPend+0xc>
8113cac4:	003b68fa 	trap	3
8113cac8:	dfc01e15 	stw	ra,120(sp)
8113cacc:	df001d15 	stw	fp,116(sp)
8113cad0:	df001d04 	addi	fp,sp,116
8113cad4:	e13ffc15 	stw	r4,-16(fp)
8113cad8:	2809883a 	mov	r4,r5
8113cadc:	3007883a 	mov	r3,r6
8113cae0:	3805883a 	mov	r2,r7
8113cae4:	e13ffd0d 	sth	r4,-12(fp)
8113cae8:	e0fffe05 	stb	r3,-8(fp)
8113caec:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113caf0:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113caf4:	e0800217 	ldw	r2,8(fp)
8113caf8:	1000021e 	bne	r2,zero,8113cb04 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
8113cafc:	0005883a 	mov	r2,zero
8113cb00:	00015906 	br	8113d068 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113cb04:	e0bffc17 	ldw	r2,-16(fp)
8113cb08:	1000051e 	bne	r2,zero,8113cb20 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113cb0c:	e0800217 	ldw	r2,8(fp)
8113cb10:	00c01b84 	movi	r3,110
8113cb14:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113cb18:	0005883a 	mov	r2,zero
8113cb1c:	00015206 	br	8113d068 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113cb20:	d0a0a103 	ldbu	r2,-32124(gp)
8113cb24:	10803fcc 	andi	r2,r2,255
8113cb28:	10000526 	beq	r2,zero,8113cb40 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113cb2c:	e0800217 	ldw	r2,8(fp)
8113cb30:	00c00084 	movi	r3,2
8113cb34:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113cb38:	0005883a 	mov	r2,zero
8113cb3c:	00014a06 	br	8113d068 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113cb40:	d0a08f03 	ldbu	r2,-32196(gp)
8113cb44:	10803fcc 	andi	r2,r2,255
8113cb48:	10000526 	beq	r2,zero,8113cb60 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113cb4c:	e0800217 	ldw	r2,8(fp)
8113cb50:	00c00344 	movi	r3,13
8113cb54:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113cb58:	0005883a 	mov	r2,zero
8113cb5c:	00014206 	br	8113d068 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113cb60:	e0bffc17 	ldw	r2,-16(fp)
8113cb64:	10800003 	ldbu	r2,0(r2)
8113cb68:	10803fcc 	andi	r2,r2,255
8113cb6c:	10800160 	cmpeqi	r2,r2,5
8113cb70:	1000051e 	bne	r2,zero,8113cb88 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
8113cb74:	e0800217 	ldw	r2,8(fp)
8113cb78:	00c00044 	movi	r3,1
8113cb7c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113cb80:	0005883a 	mov	r2,zero
8113cb84:	00013806 	br	8113d068 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113cb88:	e0fffe03 	ldbu	r3,-8(fp)
8113cb8c:	00bfe004 	movi	r2,-128
8113cb90:	1884703a 	and	r2,r3,r2
8113cb94:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
8113cb98:	e0bfe603 	ldbu	r2,-104(fp)
8113cb9c:	10000626 	beq	r2,zero,8113cbb8 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
8113cba0:	e0bffe03 	ldbu	r2,-8(fp)
8113cba4:	10801fcc 	andi	r2,r2,127
8113cba8:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113cbac:	00800044 	movi	r2,1
8113cbb0:	e0bfe405 	stb	r2,-112(fp)
8113cbb4:	00000106 	br	8113cbbc <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
8113cbb8:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cbbc:	0005303a 	rdctl	r2,status
8113cbc0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cbc4:	e0fff617 	ldw	r3,-40(fp)
8113cbc8:	00bfff84 	movi	r2,-2
8113cbcc:	1884703a 	and	r2,r3,r2
8113cbd0:	1001703a 	wrctl	status,r2
  
  return context;
8113cbd4:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113cbd8:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
8113cbdc:	e0bffe03 	ldbu	r2,-8(fp)
8113cbe0:	10c00060 	cmpeqi	r3,r2,1
8113cbe4:	1800921e 	bne	r3,zero,8113ce30 <OSFlagPend+0x374>
8113cbe8:	10c00088 	cmpgei	r3,r2,2
8113cbec:	1800021e 	bne	r3,zero,8113cbf8 <OSFlagPend+0x13c>
8113cbf0:	10006126 	beq	r2,zero,8113cd78 <OSFlagPend+0x2bc>
8113cbf4:	0000bb06 	br	8113cee4 <OSFlagPend+0x428>
8113cbf8:	10c000a0 	cmpeqi	r3,r2,2
8113cbfc:	1800031e 	bne	r3,zero,8113cc0c <OSFlagPend+0x150>
8113cc00:	108000e0 	cmpeqi	r2,r2,3
8113cc04:	10002f1e 	bne	r2,zero,8113ccc4 <OSFlagPend+0x208>
8113cc08:	0000b606 	br	8113cee4 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
8113cc0c:	e0bffc17 	ldw	r2,-16(fp)
8113cc10:	10c0020b 	ldhu	r3,8(r2)
8113cc14:	e0bffd0b 	ldhu	r2,-12(fp)
8113cc18:	1884703a 	and	r2,r3,r2
8113cc1c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113cc20:	e0ffe80b 	ldhu	r3,-96(fp)
8113cc24:	e0bffd0b 	ldhu	r2,-12(fp)
8113cc28:	1880171e 	bne	r3,r2,8113cc88 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113cc2c:	e0bfe403 	ldbu	r2,-112(fp)
8113cc30:	10800058 	cmpnei	r2,r2,1
8113cc34:	1000091e 	bne	r2,zero,8113cc5c <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113cc38:	e0bffc17 	ldw	r2,-16(fp)
8113cc3c:	1080020b 	ldhu	r2,8(r2)
8113cc40:	1007883a 	mov	r3,r2
8113cc44:	e0bfe80b 	ldhu	r2,-96(fp)
8113cc48:	0084303a 	nor	r2,zero,r2
8113cc4c:	1884703a 	and	r2,r3,r2
8113cc50:	1007883a 	mov	r3,r2
8113cc54:	e0bffc17 	ldw	r2,-16(fp)
8113cc58:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113cc5c:	d0a0a217 	ldw	r2,-32120(gp)
8113cc60:	e0ffe80b 	ldhu	r3,-96(fp)
8113cc64:	10c00b0d 	sth	r3,44(r2)
8113cc68:	e0bfe517 	ldw	r2,-108(fp)
8113cc6c:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cc70:	e0bfe717 	ldw	r2,-100(fp)
8113cc74:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113cc78:	e0800217 	ldw	r2,8(fp)
8113cc7c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113cc80:	e0bfe80b 	ldhu	r2,-96(fp)
8113cc84:	0000f806 	br	8113d068 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113cc88:	e13ffd0b 	ldhu	r4,-12(fp)
8113cc8c:	e17ffe03 	ldbu	r5,-8(fp)
8113cc90:	e0bfff0b 	ldhu	r2,-4(fp)
8113cc94:	e0fff704 	addi	r3,fp,-36
8113cc98:	d8800015 	stw	r2,0(sp)
8113cc9c:	280f883a 	mov	r7,r5
8113cca0:	200d883a 	mov	r6,r4
8113cca4:	180b883a 	mov	r5,r3
8113cca8:	e13ffc17 	ldw	r4,-16(fp)
8113ccac:	113d54c0 	call	8113d54c <OS_FlagBlock>
8113ccb0:	e0bfe517 	ldw	r2,-108(fp)
8113ccb4:	e0bfe915 	stw	r2,-92(fp)
8113ccb8:	e0bfe917 	ldw	r2,-92(fp)
8113ccbc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113ccc0:	00009206 	br	8113cf0c <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
8113ccc4:	e0bffc17 	ldw	r2,-16(fp)
8113ccc8:	10c0020b 	ldhu	r3,8(r2)
8113cccc:	e0bffd0b 	ldhu	r2,-12(fp)
8113ccd0:	1884703a 	and	r2,r3,r2
8113ccd4:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113ccd8:	e0bfe80b 	ldhu	r2,-96(fp)
8113ccdc:	10001726 	beq	r2,zero,8113cd3c <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113cce0:	e0bfe403 	ldbu	r2,-112(fp)
8113cce4:	10800058 	cmpnei	r2,r2,1
8113cce8:	1000091e 	bne	r2,zero,8113cd10 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113ccec:	e0bffc17 	ldw	r2,-16(fp)
8113ccf0:	1080020b 	ldhu	r2,8(r2)
8113ccf4:	1007883a 	mov	r3,r2
8113ccf8:	e0bfe80b 	ldhu	r2,-96(fp)
8113ccfc:	0084303a 	nor	r2,zero,r2
8113cd00:	1884703a 	and	r2,r3,r2
8113cd04:	1007883a 	mov	r3,r2
8113cd08:	e0bffc17 	ldw	r2,-16(fp)
8113cd0c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113cd10:	d0a0a217 	ldw	r2,-32120(gp)
8113cd14:	e0ffe80b 	ldhu	r3,-96(fp)
8113cd18:	10c00b0d 	sth	r3,44(r2)
8113cd1c:	e0bfe517 	ldw	r2,-108(fp)
8113cd20:	e0bfea15 	stw	r2,-88(fp)
8113cd24:	e0bfea17 	ldw	r2,-88(fp)
8113cd28:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113cd2c:	e0800217 	ldw	r2,8(fp)
8113cd30:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113cd34:	e0bfe80b 	ldhu	r2,-96(fp)
8113cd38:	0000cb06 	br	8113d068 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113cd3c:	e13ffd0b 	ldhu	r4,-12(fp)
8113cd40:	e17ffe03 	ldbu	r5,-8(fp)
8113cd44:	e0bfff0b 	ldhu	r2,-4(fp)
8113cd48:	e0fff704 	addi	r3,fp,-36
8113cd4c:	d8800015 	stw	r2,0(sp)
8113cd50:	280f883a 	mov	r7,r5
8113cd54:	200d883a 	mov	r6,r4
8113cd58:	180b883a 	mov	r5,r3
8113cd5c:	e13ffc17 	ldw	r4,-16(fp)
8113cd60:	113d54c0 	call	8113d54c <OS_FlagBlock>
8113cd64:	e0bfe517 	ldw	r2,-108(fp)
8113cd68:	e0bfeb15 	stw	r2,-84(fp)
8113cd6c:	e0bfeb17 	ldw	r2,-84(fp)
8113cd70:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113cd74:	00006506 	br	8113cf0c <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113cd78:	e0bffc17 	ldw	r2,-16(fp)
8113cd7c:	1080020b 	ldhu	r2,8(r2)
8113cd80:	0084303a 	nor	r2,zero,r2
8113cd84:	1007883a 	mov	r3,r2
8113cd88:	e0bffd0b 	ldhu	r2,-12(fp)
8113cd8c:	1884703a 	and	r2,r3,r2
8113cd90:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113cd94:	e0ffe80b 	ldhu	r3,-96(fp)
8113cd98:	e0bffd0b 	ldhu	r2,-12(fp)
8113cd9c:	1880151e 	bne	r3,r2,8113cdf4 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113cda0:	e0bfe403 	ldbu	r2,-112(fp)
8113cda4:	10800058 	cmpnei	r2,r2,1
8113cda8:	1000071e 	bne	r2,zero,8113cdc8 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113cdac:	e0bffc17 	ldw	r2,-16(fp)
8113cdb0:	10c0020b 	ldhu	r3,8(r2)
8113cdb4:	e0bfe80b 	ldhu	r2,-96(fp)
8113cdb8:	1884b03a 	or	r2,r3,r2
8113cdbc:	1007883a 	mov	r3,r2
8113cdc0:	e0bffc17 	ldw	r2,-16(fp)
8113cdc4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113cdc8:	d0a0a217 	ldw	r2,-32120(gp)
8113cdcc:	e0ffe80b 	ldhu	r3,-96(fp)
8113cdd0:	10c00b0d 	sth	r3,44(r2)
8113cdd4:	e0bfe517 	ldw	r2,-108(fp)
8113cdd8:	e0bfec15 	stw	r2,-80(fp)
8113cddc:	e0bfec17 	ldw	r2,-80(fp)
8113cde0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113cde4:	e0800217 	ldw	r2,8(fp)
8113cde8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113cdec:	e0bfe80b 	ldhu	r2,-96(fp)
8113cdf0:	00009d06 	br	8113d068 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113cdf4:	e13ffd0b 	ldhu	r4,-12(fp)
8113cdf8:	e17ffe03 	ldbu	r5,-8(fp)
8113cdfc:	e0bfff0b 	ldhu	r2,-4(fp)
8113ce00:	e0fff704 	addi	r3,fp,-36
8113ce04:	d8800015 	stw	r2,0(sp)
8113ce08:	280f883a 	mov	r7,r5
8113ce0c:	200d883a 	mov	r6,r4
8113ce10:	180b883a 	mov	r5,r3
8113ce14:	e13ffc17 	ldw	r4,-16(fp)
8113ce18:	113d54c0 	call	8113d54c <OS_FlagBlock>
8113ce1c:	e0bfe517 	ldw	r2,-108(fp)
8113ce20:	e0bfed15 	stw	r2,-76(fp)
8113ce24:	e0bfed17 	ldw	r2,-76(fp)
8113ce28:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113ce2c:	00003706 	br	8113cf0c <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113ce30:	e0bffc17 	ldw	r2,-16(fp)
8113ce34:	1080020b 	ldhu	r2,8(r2)
8113ce38:	0084303a 	nor	r2,zero,r2
8113ce3c:	1007883a 	mov	r3,r2
8113ce40:	e0bffd0b 	ldhu	r2,-12(fp)
8113ce44:	1884703a 	and	r2,r3,r2
8113ce48:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113ce4c:	e0bfe80b 	ldhu	r2,-96(fp)
8113ce50:	10001526 	beq	r2,zero,8113cea8 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113ce54:	e0bfe403 	ldbu	r2,-112(fp)
8113ce58:	10800058 	cmpnei	r2,r2,1
8113ce5c:	1000071e 	bne	r2,zero,8113ce7c <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113ce60:	e0bffc17 	ldw	r2,-16(fp)
8113ce64:	10c0020b 	ldhu	r3,8(r2)
8113ce68:	e0bfe80b 	ldhu	r2,-96(fp)
8113ce6c:	1884b03a 	or	r2,r3,r2
8113ce70:	1007883a 	mov	r3,r2
8113ce74:	e0bffc17 	ldw	r2,-16(fp)
8113ce78:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113ce7c:	d0a0a217 	ldw	r2,-32120(gp)
8113ce80:	e0ffe80b 	ldhu	r3,-96(fp)
8113ce84:	10c00b0d 	sth	r3,44(r2)
8113ce88:	e0bfe517 	ldw	r2,-108(fp)
8113ce8c:	e0bfee15 	stw	r2,-72(fp)
8113ce90:	e0bfee17 	ldw	r2,-72(fp)
8113ce94:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113ce98:	e0800217 	ldw	r2,8(fp)
8113ce9c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113cea0:	e0bfe80b 	ldhu	r2,-96(fp)
8113cea4:	00007006 	br	8113d068 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113cea8:	e13ffd0b 	ldhu	r4,-12(fp)
8113ceac:	e17ffe03 	ldbu	r5,-8(fp)
8113ceb0:	e0bfff0b 	ldhu	r2,-4(fp)
8113ceb4:	e0fff704 	addi	r3,fp,-36
8113ceb8:	d8800015 	stw	r2,0(sp)
8113cebc:	280f883a 	mov	r7,r5
8113cec0:	200d883a 	mov	r6,r4
8113cec4:	180b883a 	mov	r5,r3
8113cec8:	e13ffc17 	ldw	r4,-16(fp)
8113cecc:	113d54c0 	call	8113d54c <OS_FlagBlock>
8113ced0:	e0bfe517 	ldw	r2,-108(fp)
8113ced4:	e0bfef15 	stw	r2,-68(fp)
8113ced8:	e0bfef17 	ldw	r2,-68(fp)
8113cedc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113cee0:	00000a06 	br	8113cf0c <OSFlagPend+0x450>
8113cee4:	e0bfe517 	ldw	r2,-108(fp)
8113cee8:	e0bff015 	stw	r2,-64(fp)
8113ceec:	e0bff017 	ldw	r2,-64(fp)
8113cef0:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113cef4:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
8113cef8:	e0800217 	ldw	r2,8(fp)
8113cefc:	00c01bc4 	movi	r3,111
8113cf00:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
8113cf04:	e0bfe80b 	ldhu	r2,-96(fp)
8113cf08:	00005706 	br	8113d068 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
8113cf0c:	113b8ac0 	call	8113b8ac <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cf10:	0005303a 	rdctl	r2,status
8113cf14:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cf18:	e0fff117 	ldw	r3,-60(fp)
8113cf1c:	00bfff84 	movi	r2,-2
8113cf20:	1884703a 	and	r2,r3,r2
8113cf24:	1001703a 	wrctl	status,r2
  
  return context;
8113cf28:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
8113cf2c:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
8113cf30:	d0a0a217 	ldw	r2,-32120(gp)
8113cf34:	10800c43 	ldbu	r2,49(r2)
8113cf38:	10803fcc 	andi	r2,r2,255
8113cf3c:	10001c26 	beq	r2,zero,8113cfb0 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
8113cf40:	d0a0a217 	ldw	r2,-32120(gp)
8113cf44:	10800c43 	ldbu	r2,49(r2)
8113cf48:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113cf4c:	d0a0a217 	ldw	r2,-32120(gp)
8113cf50:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
8113cf54:	e0bff704 	addi	r2,fp,-36
8113cf58:	1009883a 	mov	r4,r2
8113cf5c:	113d8980 	call	8113d898 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
8113cf60:	d0a0a217 	ldw	r2,-32120(gp)
8113cf64:	10000c05 	stb	zero,48(r2)
8113cf68:	e0bfe517 	ldw	r2,-108(fp)
8113cf6c:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cf70:	e0bff217 	ldw	r2,-56(fp)
8113cf74:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
8113cf78:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
8113cf7c:	e0bff303 	ldbu	r2,-52(fp)
8113cf80:	108000a0 	cmpeqi	r2,r2,2
8113cf84:	10000426 	beq	r2,zero,8113cf98 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
8113cf88:	e0800217 	ldw	r2,8(fp)
8113cf8c:	00c00384 	movi	r3,14
8113cf90:	10c00005 	stb	r3,0(r2)
                 break;
8113cf94:	00000406 	br	8113cfa8 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
8113cf98:	e0800217 	ldw	r2,8(fp)
8113cf9c:	00c00284 	movi	r3,10
8113cfa0:	10c00005 	stb	r3,0(r2)
                 break;
8113cfa4:	0001883a 	nop
        }
        return (flags_rdy);
8113cfa8:	e0bfe80b 	ldhu	r2,-96(fp)
8113cfac:	00002e06 	br	8113d068 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
8113cfb0:	d0a0a217 	ldw	r2,-32120(gp)
8113cfb4:	10800b0b 	ldhu	r2,44(r2)
8113cfb8:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
8113cfbc:	e0bfe403 	ldbu	r2,-112(fp)
8113cfc0:	10800058 	cmpnei	r2,r2,1
8113cfc4:	1000211e 	bne	r2,zero,8113d04c <OSFlagPend+0x590>
        switch (wait_type) {
8113cfc8:	e0bffe03 	ldbu	r2,-8(fp)
8113cfcc:	10001616 	blt	r2,zero,8113d028 <OSFlagPend+0x56c>
8113cfd0:	10c00090 	cmplti	r3,r2,2
8113cfd4:	18000c1e 	bne	r3,zero,8113d008 <OSFlagPend+0x54c>
8113cfd8:	10800108 	cmpgei	r2,r2,4
8113cfdc:	1000121e 	bne	r2,zero,8113d028 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
8113cfe0:	e0bffc17 	ldw	r2,-16(fp)
8113cfe4:	1080020b 	ldhu	r2,8(r2)
8113cfe8:	1007883a 	mov	r3,r2
8113cfec:	e0bfe80b 	ldhu	r2,-96(fp)
8113cff0:	0084303a 	nor	r2,zero,r2
8113cff4:	1884703a 	and	r2,r3,r2
8113cff8:	1007883a 	mov	r3,r2
8113cffc:	e0bffc17 	ldw	r2,-16(fp)
8113d000:	10c0020d 	sth	r3,8(r2)
                 break;
8113d004:	00001106 	br	8113d04c <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
8113d008:	e0bffc17 	ldw	r2,-16(fp)
8113d00c:	10c0020b 	ldhu	r3,8(r2)
8113d010:	e0bfe80b 	ldhu	r2,-96(fp)
8113d014:	1884b03a 	or	r2,r3,r2
8113d018:	1007883a 	mov	r3,r2
8113d01c:	e0bffc17 	ldw	r2,-16(fp)
8113d020:	10c0020d 	sth	r3,8(r2)
                 break;
8113d024:	00000906 	br	8113d04c <OSFlagPend+0x590>
8113d028:	e0bfe517 	ldw	r2,-108(fp)
8113d02c:	e0bff415 	stw	r2,-48(fp)
8113d030:	e0bff417 	ldw	r2,-48(fp)
8113d034:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113d038:	e0800217 	ldw	r2,8(fp)
8113d03c:	00c01bc4 	movi	r3,111
8113d040:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113d044:	0005883a 	mov	r2,zero
8113d048:	00000706 	br	8113d068 <OSFlagPend+0x5ac>
8113d04c:	e0bfe517 	ldw	r2,-108(fp)
8113d050:	e0bff515 	stw	r2,-44(fp)
8113d054:	e0bff517 	ldw	r2,-44(fp)
8113d058:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
8113d05c:	e0800217 	ldw	r2,8(fp)
8113d060:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
8113d064:	e0bfe80b 	ldhu	r2,-96(fp)
}
8113d068:	e037883a 	mov	sp,fp
8113d06c:	dfc00117 	ldw	ra,4(sp)
8113d070:	df000017 	ldw	fp,0(sp)
8113d074:	dec00204 	addi	sp,sp,8
8113d078:	f800283a 	ret

8113d07c <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
8113d07c:	defffb04 	addi	sp,sp,-20
8113d080:	de00012e 	bgeu	sp,et,8113d088 <OSFlagPendGetFlagsRdy+0xc>
8113d084:	003b68fa 	trap	3
8113d088:	df000415 	stw	fp,16(sp)
8113d08c:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113d090:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d094:	0005303a 	rdctl	r2,status
8113d098:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d09c:	e0fffe17 	ldw	r3,-8(fp)
8113d0a0:	00bfff84 	movi	r2,-2
8113d0a4:	1884703a 	and	r2,r3,r2
8113d0a8:	1001703a 	wrctl	status,r2
  
  return context;
8113d0ac:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113d0b0:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
8113d0b4:	d0a0a217 	ldw	r2,-32120(gp)
8113d0b8:	10800b0b 	ldhu	r2,44(r2)
8113d0bc:	e0bffd0d 	sth	r2,-12(fp)
8113d0c0:	e0bffc17 	ldw	r2,-16(fp)
8113d0c4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d0c8:	e0bfff17 	ldw	r2,-4(fp)
8113d0cc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
8113d0d0:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113d0d4:	e037883a 	mov	sp,fp
8113d0d8:	df000017 	ldw	fp,0(sp)
8113d0dc:	dec00104 	addi	sp,sp,4
8113d0e0:	f800283a 	ret

8113d0e4 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
8113d0e4:	deffef04 	addi	sp,sp,-68
8113d0e8:	de00012e 	bgeu	sp,et,8113d0f0 <OSFlagPost+0xc>
8113d0ec:	003b68fa 	trap	3
8113d0f0:	dfc01015 	stw	ra,64(sp)
8113d0f4:	df000f15 	stw	fp,60(sp)
8113d0f8:	df000f04 	addi	fp,sp,60
8113d0fc:	e13ffc15 	stw	r4,-16(fp)
8113d100:	2807883a 	mov	r3,r5
8113d104:	3005883a 	mov	r2,r6
8113d108:	e1ffff15 	stw	r7,-4(fp)
8113d10c:	e0fffd0d 	sth	r3,-12(fp)
8113d110:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
8113d114:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113d118:	e0bfff17 	ldw	r2,-4(fp)
8113d11c:	1000021e 	bne	r2,zero,8113d128 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
8113d120:	0005883a 	mov	r2,zero
8113d124:	0000d106 	br	8113d46c <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
8113d128:	e0bffc17 	ldw	r2,-16(fp)
8113d12c:	1000051e 	bne	r2,zero,8113d144 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113d130:	e0bfff17 	ldw	r2,-4(fp)
8113d134:	00c01b84 	movi	r3,110
8113d138:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113d13c:	0005883a 	mov	r2,zero
8113d140:	0000ca06 	br	8113d46c <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
8113d144:	e0bffc17 	ldw	r2,-16(fp)
8113d148:	10800003 	ldbu	r2,0(r2)
8113d14c:	10803fcc 	andi	r2,r2,255
8113d150:	10800160 	cmpeqi	r2,r2,5
8113d154:	1000051e 	bne	r2,zero,8113d16c <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
8113d158:	e0bfff17 	ldw	r2,-4(fp)
8113d15c:	00c00044 	movi	r3,1
8113d160:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113d164:	0005883a 	mov	r2,zero
8113d168:	0000c006 	br	8113d46c <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d16c:	0005303a 	rdctl	r2,status
8113d170:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d174:	e0fffb17 	ldw	r3,-20(fp)
8113d178:	00bfff84 	movi	r2,-2
8113d17c:	1884703a 	and	r2,r3,r2
8113d180:	1001703a 	wrctl	status,r2
  
  return context;
8113d184:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113d188:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
8113d18c:	e0bffe03 	ldbu	r2,-8(fp)
8113d190:	10000326 	beq	r2,zero,8113d1a0 <OSFlagPost+0xbc>
8113d194:	10800060 	cmpeqi	r2,r2,1
8113d198:	10000b1e 	bne	r2,zero,8113d1c8 <OSFlagPost+0xe4>
8113d19c:	00001206 	br	8113d1e8 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
8113d1a0:	e0bffc17 	ldw	r2,-16(fp)
8113d1a4:	1080020b 	ldhu	r2,8(r2)
8113d1a8:	1007883a 	mov	r3,r2
8113d1ac:	e0bffd0b 	ldhu	r2,-12(fp)
8113d1b0:	0084303a 	nor	r2,zero,r2
8113d1b4:	1884703a 	and	r2,r3,r2
8113d1b8:	1007883a 	mov	r3,r2
8113d1bc:	e0bffc17 	ldw	r2,-16(fp)
8113d1c0:	10c0020d 	sth	r3,8(r2)
             break;
8113d1c4:	00001106 	br	8113d20c <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
8113d1c8:	e0bffc17 	ldw	r2,-16(fp)
8113d1cc:	10c0020b 	ldhu	r3,8(r2)
8113d1d0:	e0bffd0b 	ldhu	r2,-12(fp)
8113d1d4:	1884b03a 	or	r2,r3,r2
8113d1d8:	1007883a 	mov	r3,r2
8113d1dc:	e0bffc17 	ldw	r2,-16(fp)
8113d1e0:	10c0020d 	sth	r3,8(r2)
             break;
8113d1e4:	00000906 	br	8113d20c <OSFlagPost+0x128>
8113d1e8:	e0bff317 	ldw	r2,-52(fp)
8113d1ec:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d1f0:	e0bff417 	ldw	r2,-48(fp)
8113d1f4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
8113d1f8:	e0bfff17 	ldw	r2,-4(fp)
8113d1fc:	00c01c44 	movi	r3,113
8113d200:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
8113d204:	0005883a 	mov	r2,zero
8113d208:	00009806 	br	8113d46c <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
8113d20c:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113d210:	e0bffc17 	ldw	r2,-16(fp)
8113d214:	10800117 	ldw	r2,4(r2)
8113d218:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113d21c:	00007706 	br	8113d3fc <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
8113d220:	e0bff117 	ldw	r2,-60(fp)
8113d224:	10800483 	ldbu	r2,18(r2)
8113d228:	10803fcc 	andi	r2,r2,255
8113d22c:	10c00060 	cmpeqi	r3,r2,1
8113d230:	18004a1e 	bne	r3,zero,8113d35c <OSFlagPost+0x278>
8113d234:	10c00088 	cmpgei	r3,r2,2
8113d238:	1800021e 	bne	r3,zero,8113d244 <OSFlagPost+0x160>
8113d23c:	10002f26 	beq	r2,zero,8113d2fc <OSFlagPost+0x218>
8113d240:	00005b06 	br	8113d3b0 <OSFlagPost+0x2cc>
8113d244:	10c000a0 	cmpeqi	r3,r2,2
8113d248:	1800031e 	bne	r3,zero,8113d258 <OSFlagPost+0x174>
8113d24c:	108000e0 	cmpeqi	r2,r2,3
8113d250:	1000171e 	bne	r2,zero,8113d2b0 <OSFlagPost+0x1cc>
8113d254:	00005606 	br	8113d3b0 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113d258:	e0bffc17 	ldw	r2,-16(fp)
8113d25c:	10c0020b 	ldhu	r3,8(r2)
8113d260:	e0bff117 	ldw	r2,-60(fp)
8113d264:	1080040b 	ldhu	r2,16(r2)
8113d268:	1884703a 	and	r2,r3,r2
8113d26c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113d270:	e0bff117 	ldw	r2,-60(fp)
8113d274:	1080040b 	ldhu	r2,16(r2)
8113d278:	10ffffcc 	andi	r3,r2,65535
8113d27c:	e0bff60b 	ldhu	r2,-40(fp)
8113d280:	1880541e 	bne	r3,r2,8113d3d4 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113d284:	e0bff60b 	ldhu	r2,-40(fp)
8113d288:	100b883a 	mov	r5,r2
8113d28c:	e13ff117 	ldw	r4,-60(fp)
8113d290:	113d79c0 	call	8113d79c <OS_FlagTaskRdy>
8113d294:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113d298:	e0bff683 	ldbu	r2,-38(fp)
8113d29c:	10800058 	cmpnei	r2,r2,1
8113d2a0:	10004c1e 	bne	r2,zero,8113d3d4 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113d2a4:	00800044 	movi	r2,1
8113d2a8:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113d2ac:	00004906 	br	8113d3d4 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113d2b0:	e0bffc17 	ldw	r2,-16(fp)
8113d2b4:	10c0020b 	ldhu	r3,8(r2)
8113d2b8:	e0bff117 	ldw	r2,-60(fp)
8113d2bc:	1080040b 	ldhu	r2,16(r2)
8113d2c0:	1884703a 	and	r2,r3,r2
8113d2c4:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113d2c8:	e0bff60b 	ldhu	r2,-40(fp)
8113d2cc:	10004326 	beq	r2,zero,8113d3dc <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113d2d0:	e0bff60b 	ldhu	r2,-40(fp)
8113d2d4:	100b883a 	mov	r5,r2
8113d2d8:	e13ff117 	ldw	r4,-60(fp)
8113d2dc:	113d79c0 	call	8113d79c <OS_FlagTaskRdy>
8113d2e0:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113d2e4:	e0bff683 	ldbu	r2,-38(fp)
8113d2e8:	10800058 	cmpnei	r2,r2,1
8113d2ec:	10003b1e 	bne	r2,zero,8113d3dc <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113d2f0:	00800044 	movi	r2,1
8113d2f4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113d2f8:	00003806 	br	8113d3dc <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113d2fc:	e0bffc17 	ldw	r2,-16(fp)
8113d300:	1080020b 	ldhu	r2,8(r2)
8113d304:	0084303a 	nor	r2,zero,r2
8113d308:	1007883a 	mov	r3,r2
8113d30c:	e0bff117 	ldw	r2,-60(fp)
8113d310:	1080040b 	ldhu	r2,16(r2)
8113d314:	1884703a 	and	r2,r3,r2
8113d318:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113d31c:	e0bff117 	ldw	r2,-60(fp)
8113d320:	1080040b 	ldhu	r2,16(r2)
8113d324:	10ffffcc 	andi	r3,r2,65535
8113d328:	e0bff60b 	ldhu	r2,-40(fp)
8113d32c:	18802d1e 	bne	r3,r2,8113d3e4 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113d330:	e0bff60b 	ldhu	r2,-40(fp)
8113d334:	100b883a 	mov	r5,r2
8113d338:	e13ff117 	ldw	r4,-60(fp)
8113d33c:	113d79c0 	call	8113d79c <OS_FlagTaskRdy>
8113d340:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113d344:	e0bff683 	ldbu	r2,-38(fp)
8113d348:	10800058 	cmpnei	r2,r2,1
8113d34c:	1000251e 	bne	r2,zero,8113d3e4 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113d350:	00800044 	movi	r2,1
8113d354:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113d358:	00002206 	br	8113d3e4 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113d35c:	e0bffc17 	ldw	r2,-16(fp)
8113d360:	1080020b 	ldhu	r2,8(r2)
8113d364:	0084303a 	nor	r2,zero,r2
8113d368:	1007883a 	mov	r3,r2
8113d36c:	e0bff117 	ldw	r2,-60(fp)
8113d370:	1080040b 	ldhu	r2,16(r2)
8113d374:	1884703a 	and	r2,r3,r2
8113d378:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113d37c:	e0bff60b 	ldhu	r2,-40(fp)
8113d380:	10001a26 	beq	r2,zero,8113d3ec <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113d384:	e0bff60b 	ldhu	r2,-40(fp)
8113d388:	100b883a 	mov	r5,r2
8113d38c:	e13ff117 	ldw	r4,-60(fp)
8113d390:	113d79c0 	call	8113d79c <OS_FlagTaskRdy>
8113d394:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113d398:	e0bff683 	ldbu	r2,-38(fp)
8113d39c:	10800058 	cmpnei	r2,r2,1
8113d3a0:	1000121e 	bne	r2,zero,8113d3ec <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113d3a4:	00800044 	movi	r2,1
8113d3a8:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113d3ac:	00000f06 	br	8113d3ec <OSFlagPost+0x308>
8113d3b0:	e0bff317 	ldw	r2,-52(fp)
8113d3b4:	e0bff515 	stw	r2,-44(fp)
8113d3b8:	e0bff517 	ldw	r2,-44(fp)
8113d3bc:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113d3c0:	e0bfff17 	ldw	r2,-4(fp)
8113d3c4:	00c01bc4 	movi	r3,111
8113d3c8:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113d3cc:	0005883a 	mov	r2,zero
8113d3d0:	00002606 	br	8113d46c <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113d3d4:	0001883a 	nop
8113d3d8:	00000506 	br	8113d3f0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113d3dc:	0001883a 	nop
8113d3e0:	00000306 	br	8113d3f0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113d3e4:	0001883a 	nop
8113d3e8:	00000106 	br	8113d3f0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113d3ec:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
8113d3f0:	e0bff117 	ldw	r2,-60(fp)
8113d3f4:	10800017 	ldw	r2,0(r2)
8113d3f8:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113d3fc:	e0bff117 	ldw	r2,-60(fp)
8113d400:	103f871e 	bne	r2,zero,8113d220 <__reset+0xfb11d220>
8113d404:	e0bff317 	ldw	r2,-52(fp)
8113d408:	e0bff715 	stw	r2,-36(fp)
8113d40c:	e0bff717 	ldw	r2,-36(fp)
8113d410:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
8113d414:	e0bff203 	ldbu	r2,-56(fp)
8113d418:	10800058 	cmpnei	r2,r2,1
8113d41c:	1000011e 	bne	r2,zero,8113d424 <OSFlagPost+0x340>
        OS_Sched();
8113d420:	113b8ac0 	call	8113b8ac <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d424:	0005303a 	rdctl	r2,status
8113d428:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d42c:	e0fffa17 	ldw	r3,-24(fp)
8113d430:	00bfff84 	movi	r2,-2
8113d434:	1884703a 	and	r2,r3,r2
8113d438:	1001703a 	wrctl	status,r2
  
  return context;
8113d43c:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
8113d440:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
8113d444:	e0bffc17 	ldw	r2,-16(fp)
8113d448:	1080020b 	ldhu	r2,8(r2)
8113d44c:	e0bff90d 	sth	r2,-28(fp)
8113d450:	e0bff317 	ldw	r2,-52(fp)
8113d454:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d458:	e0bff817 	ldw	r2,-32(fp)
8113d45c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
8113d460:	e0bfff17 	ldw	r2,-4(fp)
8113d464:	10000005 	stb	zero,0(r2)
    return (flags_cur);
8113d468:	e0bff90b 	ldhu	r2,-28(fp)
}
8113d46c:	e037883a 	mov	sp,fp
8113d470:	dfc00117 	ldw	ra,4(sp)
8113d474:	df000017 	ldw	fp,0(sp)
8113d478:	dec00204 	addi	sp,sp,8
8113d47c:	f800283a 	ret

8113d480 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
8113d480:	defff904 	addi	sp,sp,-28
8113d484:	de00012e 	bgeu	sp,et,8113d48c <OSFlagQuery+0xc>
8113d488:	003b68fa 	trap	3
8113d48c:	df000615 	stw	fp,24(sp)
8113d490:	df000604 	addi	fp,sp,24
8113d494:	e13ffe15 	stw	r4,-8(fp)
8113d498:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
8113d49c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
8113d4a0:	e0bfff17 	ldw	r2,-4(fp)
8113d4a4:	1000021e 	bne	r2,zero,8113d4b0 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
8113d4a8:	0005883a 	mov	r2,zero
8113d4ac:	00002306 	br	8113d53c <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
8113d4b0:	e0bffe17 	ldw	r2,-8(fp)
8113d4b4:	1000051e 	bne	r2,zero,8113d4cc <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113d4b8:	e0bfff17 	ldw	r2,-4(fp)
8113d4bc:	00c01b84 	movi	r3,110
8113d4c0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113d4c4:	0005883a 	mov	r2,zero
8113d4c8:	00001c06 	br	8113d53c <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
8113d4cc:	e0bffe17 	ldw	r2,-8(fp)
8113d4d0:	10800003 	ldbu	r2,0(r2)
8113d4d4:	10803fcc 	andi	r2,r2,255
8113d4d8:	10800160 	cmpeqi	r2,r2,5
8113d4dc:	1000051e 	bne	r2,zero,8113d4f4 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113d4e0:	e0bfff17 	ldw	r2,-4(fp)
8113d4e4:	00c00044 	movi	r3,1
8113d4e8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113d4ec:	0005883a 	mov	r2,zero
8113d4f0:	00001206 	br	8113d53c <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d4f4:	0005303a 	rdctl	r2,status
8113d4f8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d4fc:	e0fffc17 	ldw	r3,-16(fp)
8113d500:	00bfff84 	movi	r2,-2
8113d504:	1884703a 	and	r2,r3,r2
8113d508:	1001703a 	wrctl	status,r2
  
  return context;
8113d50c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113d510:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
8113d514:	e0bffe17 	ldw	r2,-8(fp)
8113d518:	1080020b 	ldhu	r2,8(r2)
8113d51c:	e0bffb0d 	sth	r2,-20(fp)
8113d520:	e0bffa17 	ldw	r2,-24(fp)
8113d524:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d528:	e0bffd17 	ldw	r2,-12(fp)
8113d52c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113d530:	e0bfff17 	ldw	r2,-4(fp)
8113d534:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
8113d538:	e0bffb0b 	ldhu	r2,-20(fp)
}
8113d53c:	e037883a 	mov	sp,fp
8113d540:	df000017 	ldw	fp,0(sp)
8113d544:	dec00104 	addi	sp,sp,4
8113d548:	f800283a 	ret

8113d54c <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
8113d54c:	defff804 	addi	sp,sp,-32
8113d550:	de00012e 	bgeu	sp,et,8113d558 <OS_FlagBlock+0xc>
8113d554:	003b68fa 	trap	3
8113d558:	df000715 	stw	fp,28(sp)
8113d55c:	df000704 	addi	fp,sp,28
8113d560:	e13ffb15 	stw	r4,-20(fp)
8113d564:	e17ffc15 	stw	r5,-16(fp)
8113d568:	3009883a 	mov	r4,r6
8113d56c:	3807883a 	mov	r3,r7
8113d570:	e0800117 	ldw	r2,4(fp)
8113d574:	e13ffd0d 	sth	r4,-12(fp)
8113d578:	e0fffe05 	stb	r3,-8(fp)
8113d57c:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8113d580:	d0a0a217 	ldw	r2,-32120(gp)
8113d584:	d0e0a217 	ldw	r3,-32120(gp)
8113d588:	18c00c03 	ldbu	r3,48(r3)
8113d58c:	18c00814 	ori	r3,r3,32
8113d590:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
8113d594:	d0a0a217 	ldw	r2,-32120(gp)
8113d598:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
8113d59c:	d0a0a217 	ldw	r2,-32120(gp)
8113d5a0:	e0ffff0b 	ldhu	r3,-4(fp)
8113d5a4:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
8113d5a8:	d0a0a217 	ldw	r2,-32120(gp)
8113d5ac:	e0fffc17 	ldw	r3,-16(fp)
8113d5b0:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
8113d5b4:	e0bffc17 	ldw	r2,-16(fp)
8113d5b8:	e0fffd0b 	ldhu	r3,-12(fp)
8113d5bc:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
8113d5c0:	e0bffc17 	ldw	r2,-16(fp)
8113d5c4:	e0fffe03 	ldbu	r3,-8(fp)
8113d5c8:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
8113d5cc:	d0e0a217 	ldw	r3,-32120(gp)
8113d5d0:	e0bffc17 	ldw	r2,-16(fp)
8113d5d4:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
8113d5d8:	e0bffb17 	ldw	r2,-20(fp)
8113d5dc:	10c00117 	ldw	r3,4(r2)
8113d5e0:	e0bffc17 	ldw	r2,-16(fp)
8113d5e4:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
8113d5e8:	e0bffc17 	ldw	r2,-16(fp)
8113d5ec:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
8113d5f0:	e0bffc17 	ldw	r2,-16(fp)
8113d5f4:	e0fffb17 	ldw	r3,-20(fp)
8113d5f8:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113d5fc:	e0bffb17 	ldw	r2,-20(fp)
8113d600:	10800117 	ldw	r2,4(r2)
8113d604:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
8113d608:	e0bff917 	ldw	r2,-28(fp)
8113d60c:	10000326 	beq	r2,zero,8113d61c <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
8113d610:	e0bff917 	ldw	r2,-28(fp)
8113d614:	e0fffc17 	ldw	r3,-16(fp)
8113d618:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
8113d61c:	e0bffb17 	ldw	r2,-20(fp)
8113d620:	e0fffc17 	ldw	r3,-16(fp)
8113d624:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
8113d628:	d0a0a217 	ldw	r2,-32120(gp)
8113d62c:	10800d03 	ldbu	r2,52(r2)
8113d630:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113d634:	e0fffa03 	ldbu	r3,-24(fp)
8113d638:	e13ffa03 	ldbu	r4,-24(fp)
8113d63c:	d0a09e44 	addi	r2,gp,-32135
8113d640:	2085883a 	add	r2,r4,r2
8113d644:	10800003 	ldbu	r2,0(r2)
8113d648:	1009883a 	mov	r4,r2
8113d64c:	d0a0a217 	ldw	r2,-32120(gp)
8113d650:	10800d43 	ldbu	r2,53(r2)
8113d654:	0084303a 	nor	r2,zero,r2
8113d658:	2084703a 	and	r2,r4,r2
8113d65c:	1009883a 	mov	r4,r2
8113d660:	d0a09e44 	addi	r2,gp,-32135
8113d664:	1885883a 	add	r2,r3,r2
8113d668:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
8113d66c:	e0fffa03 	ldbu	r3,-24(fp)
8113d670:	d0a09e44 	addi	r2,gp,-32135
8113d674:	1885883a 	add	r2,r3,r2
8113d678:	10800003 	ldbu	r2,0(r2)
8113d67c:	10803fcc 	andi	r2,r2,255
8113d680:	1000071e 	bne	r2,zero,8113d6a0 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113d684:	d0a0a217 	ldw	r2,-32120(gp)
8113d688:	10800d83 	ldbu	r2,54(r2)
8113d68c:	0084303a 	nor	r2,zero,r2
8113d690:	1007883a 	mov	r3,r2
8113d694:	d0a09e03 	ldbu	r2,-32136(gp)
8113d698:	1884703a 	and	r2,r3,r2
8113d69c:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113d6a0:	0001883a 	nop
8113d6a4:	e037883a 	mov	sp,fp
8113d6a8:	df000017 	ldw	fp,0(sp)
8113d6ac:	dec00104 	addi	sp,sp,4
8113d6b0:	f800283a 	ret

8113d6b4 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
8113d6b4:	defffb04 	addi	sp,sp,-20
8113d6b8:	de00012e 	bgeu	sp,et,8113d6c0 <OS_FlagInit+0xc>
8113d6bc:	003b68fa 	trap	3
8113d6c0:	dfc00415 	stw	ra,16(sp)
8113d6c4:	df000315 	stw	fp,12(sp)
8113d6c8:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
8113d6cc:	01421004 	movi	r5,2112
8113d6d0:	012045f4 	movhi	r4,33047
8113d6d4:	21227604 	addi	r4,r4,-30248
8113d6d8:	113b7e00 	call	8113b7e0 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
8113d6dc:	00a045f4 	movhi	r2,33047
8113d6e0:	10a27604 	addi	r2,r2,-30248
8113d6e4:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
8113d6e8:	00a045f4 	movhi	r2,33047
8113d6ec:	10a28104 	addi	r2,r2,-30204
8113d6f0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113d6f4:	e03ffd0d 	sth	zero,-12(fp)
8113d6f8:	00001306 	br	8113d748 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113d6fc:	e0bffe17 	ldw	r2,-8(fp)
8113d700:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
8113d704:	e0bffe17 	ldw	r2,-8(fp)
8113d708:	e0ffff17 	ldw	r3,-4(fp)
8113d70c:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
8113d710:	e0bffe17 	ldw	r2,-8(fp)
8113d714:	00c00fc4 	movi	r3,63
8113d718:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113d71c:	e0bffe17 	ldw	r2,-8(fp)
8113d720:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
8113d724:	e0bffe17 	ldw	r2,-8(fp)
8113d728:	10800b04 	addi	r2,r2,44
8113d72c:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
8113d730:	e0bfff17 	ldw	r2,-4(fp)
8113d734:	10800b04 	addi	r2,r2,44
8113d738:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113d73c:	e0bffd0b 	ldhu	r2,-12(fp)
8113d740:	10800044 	addi	r2,r2,1
8113d744:	e0bffd0d 	sth	r2,-12(fp)
8113d748:	e0bffd0b 	ldhu	r2,-12(fp)
8113d74c:	10800bf0 	cmpltui	r2,r2,47
8113d750:	103fea1e 	bne	r2,zero,8113d6fc <__reset+0xfb11d6fc>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113d754:	e0bffe17 	ldw	r2,-8(fp)
8113d758:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
8113d75c:	e0bffe17 	ldw	r2,-8(fp)
8113d760:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
8113d764:	e0bffe17 	ldw	r2,-8(fp)
8113d768:	00c00fc4 	movi	r3,63
8113d76c:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113d770:	e0bffe17 	ldw	r2,-8(fp)
8113d774:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
8113d778:	00a045f4 	movhi	r2,33047
8113d77c:	10a27604 	addi	r2,r2,-30248
8113d780:	d0a0a615 	stw	r2,-32104(gp)
#endif
}
8113d784:	0001883a 	nop
8113d788:	e037883a 	mov	sp,fp
8113d78c:	dfc00117 	ldw	ra,4(sp)
8113d790:	df000017 	ldw	fp,0(sp)
8113d794:	dec00204 	addi	sp,sp,8
8113d798:	f800283a 	ret

8113d79c <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
8113d79c:	defffa04 	addi	sp,sp,-24
8113d7a0:	de00012e 	bgeu	sp,et,8113d7a8 <OS_FlagTaskRdy+0xc>
8113d7a4:	003b68fa 	trap	3
8113d7a8:	dfc00515 	stw	ra,20(sp)
8113d7ac:	df000415 	stw	fp,16(sp)
8113d7b0:	df000404 	addi	fp,sp,16
8113d7b4:	e13ffe15 	stw	r4,-8(fp)
8113d7b8:	2805883a 	mov	r2,r5
8113d7bc:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
8113d7c0:	e0bffe17 	ldw	r2,-8(fp)
8113d7c4:	10800217 	ldw	r2,8(r2)
8113d7c8:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
8113d7cc:	e0bffd17 	ldw	r2,-12(fp)
8113d7d0:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
8113d7d4:	e0bffd17 	ldw	r2,-12(fp)
8113d7d8:	e0ffff0b 	ldhu	r3,-4(fp)
8113d7dc:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
8113d7e0:	e0bffd17 	ldw	r2,-12(fp)
8113d7e4:	10c00c03 	ldbu	r3,48(r2)
8113d7e8:	00bff7c4 	movi	r2,-33
8113d7ec:	1884703a 	and	r2,r3,r2
8113d7f0:	1007883a 	mov	r3,r2
8113d7f4:	e0bffd17 	ldw	r2,-12(fp)
8113d7f8:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
8113d7fc:	e0bffd17 	ldw	r2,-12(fp)
8113d800:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
8113d804:	e0bffd17 	ldw	r2,-12(fp)
8113d808:	10800c03 	ldbu	r2,48(r2)
8113d80c:	10803fcc 	andi	r2,r2,255
8113d810:	1000181e 	bne	r2,zero,8113d874 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
8113d814:	e0bffd17 	ldw	r2,-12(fp)
8113d818:	10c00d83 	ldbu	r3,54(r2)
8113d81c:	d0a09e03 	ldbu	r2,-32136(gp)
8113d820:	1884b03a 	or	r2,r3,r2
8113d824:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113d828:	e0bffd17 	ldw	r2,-12(fp)
8113d82c:	10800d03 	ldbu	r2,52(r2)
8113d830:	10c03fcc 	andi	r3,r2,255
8113d834:	e0bffd17 	ldw	r2,-12(fp)
8113d838:	10800d03 	ldbu	r2,52(r2)
8113d83c:	11003fcc 	andi	r4,r2,255
8113d840:	d0a09e44 	addi	r2,gp,-32135
8113d844:	2085883a 	add	r2,r4,r2
8113d848:	11000003 	ldbu	r4,0(r2)
8113d84c:	e0bffd17 	ldw	r2,-12(fp)
8113d850:	10800d43 	ldbu	r2,53(r2)
8113d854:	2084b03a 	or	r2,r4,r2
8113d858:	1009883a 	mov	r4,r2
8113d85c:	d0a09e44 	addi	r2,gp,-32135
8113d860:	1885883a 	add	r2,r3,r2
8113d864:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
8113d868:	00800044 	movi	r2,1
8113d86c:	e0bffc05 	stb	r2,-16(fp)
8113d870:	00000106 	br	8113d878 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
8113d874:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
8113d878:	e13ffe17 	ldw	r4,-8(fp)
8113d87c:	113d8980 	call	8113d898 <OS_FlagUnlink>
    return (sched);
8113d880:	e0bffc03 	ldbu	r2,-16(fp)
}
8113d884:	e037883a 	mov	sp,fp
8113d888:	dfc00117 	ldw	ra,4(sp)
8113d88c:	df000017 	ldw	fp,0(sp)
8113d890:	dec00204 	addi	sp,sp,8
8113d894:	f800283a 	ret

8113d898 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
8113d898:	defffa04 	addi	sp,sp,-24
8113d89c:	de00012e 	bgeu	sp,et,8113d8a4 <OS_FlagUnlink+0xc>
8113d8a0:	003b68fa 	trap	3
8113d8a4:	df000515 	stw	fp,20(sp)
8113d8a8:	df000504 	addi	fp,sp,20
8113d8ac:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
8113d8b0:	e0bfff17 	ldw	r2,-4(fp)
8113d8b4:	10800117 	ldw	r2,4(r2)
8113d8b8:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113d8bc:	e0bfff17 	ldw	r2,-4(fp)
8113d8c0:	10800017 	ldw	r2,0(r2)
8113d8c4:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
8113d8c8:	e0bffb17 	ldw	r2,-20(fp)
8113d8cc:	10000b1e 	bne	r2,zero,8113d8fc <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
8113d8d0:	e0bfff17 	ldw	r2,-4(fp)
8113d8d4:	10800317 	ldw	r2,12(r2)
8113d8d8:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
8113d8dc:	e0bffd17 	ldw	r2,-12(fp)
8113d8e0:	e0fffc17 	ldw	r3,-16(fp)
8113d8e4:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
8113d8e8:	e0bffc17 	ldw	r2,-16(fp)
8113d8ec:	10000b26 	beq	r2,zero,8113d91c <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
8113d8f0:	e0bffc17 	ldw	r2,-16(fp)
8113d8f4:	10000115 	stw	zero,4(r2)
8113d8f8:	00000806 	br	8113d91c <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
8113d8fc:	e0bffb17 	ldw	r2,-20(fp)
8113d900:	e0fffc17 	ldw	r3,-16(fp)
8113d904:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
8113d908:	e0bffc17 	ldw	r2,-16(fp)
8113d90c:	10000326 	beq	r2,zero,8113d91c <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
8113d910:	e0bffc17 	ldw	r2,-16(fp)
8113d914:	e0fffb17 	ldw	r3,-20(fp)
8113d918:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
8113d91c:	e0bfff17 	ldw	r2,-4(fp)
8113d920:	10800217 	ldw	r2,8(r2)
8113d924:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
8113d928:	e0bffe17 	ldw	r2,-8(fp)
8113d92c:	10000a15 	stw	zero,40(r2)
#endif
}
8113d930:	0001883a 	nop
8113d934:	e037883a 	mov	sp,fp
8113d938:	df000017 	ldw	fp,0(sp)
8113d93c:	dec00104 	addi	sp,sp,4
8113d940:	f800283a 	ret

8113d944 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
8113d944:	defff404 	addi	sp,sp,-48
8113d948:	de00012e 	bgeu	sp,et,8113d950 <OSMemCreate+0xc>
8113d94c:	003b68fa 	trap	3
8113d950:	df000b15 	stw	fp,44(sp)
8113d954:	df000b04 	addi	fp,sp,44
8113d958:	e13ffc15 	stw	r4,-16(fp)
8113d95c:	e17ffd15 	stw	r5,-12(fp)
8113d960:	e1bffe15 	stw	r6,-8(fp)
8113d964:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113d968:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113d96c:	e0bfff17 	ldw	r2,-4(fp)
8113d970:	1000021e 	bne	r2,zero,8113d97c <OSMemCreate+0x38>
        return ((OS_MEM *)0);
8113d974:	0005883a 	mov	r2,zero
8113d978:	00006506 	br	8113db10 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
8113d97c:	e0bffc17 	ldw	r2,-16(fp)
8113d980:	1000051e 	bne	r2,zero,8113d998 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113d984:	e0bfff17 	ldw	r2,-4(fp)
8113d988:	00c01884 	movi	r3,98
8113d98c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d990:	0005883a 	mov	r2,zero
8113d994:	00005e06 	br	8113db10 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
8113d998:	e0bffc17 	ldw	r2,-16(fp)
8113d99c:	108000cc 	andi	r2,r2,3
8113d9a0:	10000526 	beq	r2,zero,8113d9b8 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113d9a4:	e0bfff17 	ldw	r2,-4(fp)
8113d9a8:	00c01884 	movi	r3,98
8113d9ac:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d9b0:	0005883a 	mov	r2,zero
8113d9b4:	00005606 	br	8113db10 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
8113d9b8:	e0bffd17 	ldw	r2,-12(fp)
8113d9bc:	108000a8 	cmpgeui	r2,r2,2
8113d9c0:	1000051e 	bne	r2,zero,8113d9d8 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
8113d9c4:	e0bfff17 	ldw	r2,-4(fp)
8113d9c8:	00c016c4 	movi	r3,91
8113d9cc:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d9d0:	0005883a 	mov	r2,zero
8113d9d4:	00004e06 	br	8113db10 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
8113d9d8:	e0bffe17 	ldw	r2,-8(fp)
8113d9dc:	10800128 	cmpgeui	r2,r2,4
8113d9e0:	1000051e 	bne	r2,zero,8113d9f8 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
8113d9e4:	e0bfff17 	ldw	r2,-4(fp)
8113d9e8:	00c01704 	movi	r3,92
8113d9ec:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d9f0:	0005883a 	mov	r2,zero
8113d9f4:	00004606 	br	8113db10 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d9f8:	0005303a 	rdctl	r2,status
8113d9fc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113da00:	e0fffb17 	ldw	r3,-20(fp)
8113da04:	00bfff84 	movi	r2,-2
8113da08:	1884703a 	and	r2,r3,r2
8113da0c:	1001703a 	wrctl	status,r2
  
  return context;
8113da10:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113da14:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
8113da18:	d0a09b17 	ldw	r2,-32148(gp)
8113da1c:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
8113da20:	d0a09b17 	ldw	r2,-32148(gp)
8113da24:	10000326 	beq	r2,zero,8113da34 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
8113da28:	d0a09b17 	ldw	r2,-32148(gp)
8113da2c:	10800117 	ldw	r2,4(r2)
8113da30:	d0a09b15 	stw	r2,-32148(gp)
8113da34:	e0bff817 	ldw	r2,-32(fp)
8113da38:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113da3c:	e0bff917 	ldw	r2,-28(fp)
8113da40:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
8113da44:	e0bffa17 	ldw	r2,-24(fp)
8113da48:	1000051e 	bne	r2,zero,8113da60 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
8113da4c:	e0bfff17 	ldw	r2,-4(fp)
8113da50:	00c01684 	movi	r3,90
8113da54:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113da58:	0005883a 	mov	r2,zero
8113da5c:	00002c06 	br	8113db10 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
8113da60:	e0bffc17 	ldw	r2,-16(fp)
8113da64:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
8113da68:	e0fffc17 	ldw	r3,-16(fp)
8113da6c:	e0bffe17 	ldw	r2,-8(fp)
8113da70:	1885883a 	add	r2,r3,r2
8113da74:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
8113da78:	e03ff715 	stw	zero,-36(fp)
8113da7c:	00000c06 	br	8113dab0 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
8113da80:	e0bff617 	ldw	r2,-40(fp)
8113da84:	e0fff517 	ldw	r3,-44(fp)
8113da88:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
8113da8c:	e0bff517 	ldw	r2,-44(fp)
8113da90:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
8113da94:	e0fff517 	ldw	r3,-44(fp)
8113da98:	e0bffe17 	ldw	r2,-8(fp)
8113da9c:	1885883a 	add	r2,r3,r2
8113daa0:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
8113daa4:	e0bff717 	ldw	r2,-36(fp)
8113daa8:	10800044 	addi	r2,r2,1
8113daac:	e0bff715 	stw	r2,-36(fp)
8113dab0:	e0bffd17 	ldw	r2,-12(fp)
8113dab4:	10bfffc4 	addi	r2,r2,-1
8113dab8:	e0fff717 	ldw	r3,-36(fp)
8113dabc:	18bff036 	bltu	r3,r2,8113da80 <__reset+0xfb11da80>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
8113dac0:	e0bff617 	ldw	r2,-40(fp)
8113dac4:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
8113dac8:	e0bffa17 	ldw	r2,-24(fp)
8113dacc:	e0fffc17 	ldw	r3,-16(fp)
8113dad0:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
8113dad4:	e0bffa17 	ldw	r2,-24(fp)
8113dad8:	e0fffc17 	ldw	r3,-16(fp)
8113dadc:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
8113dae0:	e0bffa17 	ldw	r2,-24(fp)
8113dae4:	e0fffd17 	ldw	r3,-12(fp)
8113dae8:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
8113daec:	e0bffa17 	ldw	r2,-24(fp)
8113daf0:	e0fffd17 	ldw	r3,-12(fp)
8113daf4:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
8113daf8:	e0bffa17 	ldw	r2,-24(fp)
8113dafc:	e0fffe17 	ldw	r3,-8(fp)
8113db00:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
8113db04:	e0bfff17 	ldw	r2,-4(fp)
8113db08:	10000005 	stb	zero,0(r2)
    return (pmem);
8113db0c:	e0bffa17 	ldw	r2,-24(fp)
}
8113db10:	e037883a 	mov	sp,fp
8113db14:	df000017 	ldw	fp,0(sp)
8113db18:	dec00104 	addi	sp,sp,4
8113db1c:	f800283a 	ret

8113db20 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
8113db20:	defff804 	addi	sp,sp,-32
8113db24:	de00012e 	bgeu	sp,et,8113db2c <OSMemGet+0xc>
8113db28:	003b68fa 	trap	3
8113db2c:	df000715 	stw	fp,28(sp)
8113db30:	df000704 	addi	fp,sp,28
8113db34:	e13ffe15 	stw	r4,-8(fp)
8113db38:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113db3c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113db40:	e0bfff17 	ldw	r2,-4(fp)
8113db44:	1000021e 	bne	r2,zero,8113db50 <OSMemGet+0x30>
        return ((void *)0);
8113db48:	0005883a 	mov	r2,zero
8113db4c:	00002e06 	br	8113dc08 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
8113db50:	e0bffe17 	ldw	r2,-8(fp)
8113db54:	1000051e 	bne	r2,zero,8113db6c <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113db58:	e0bfff17 	ldw	r2,-4(fp)
8113db5c:	00c01804 	movi	r3,96
8113db60:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113db64:	0005883a 	mov	r2,zero
8113db68:	00002706 	br	8113dc08 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113db6c:	0005303a 	rdctl	r2,status
8113db70:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113db74:	e0fffd17 	ldw	r3,-12(fp)
8113db78:	00bfff84 	movi	r2,-2
8113db7c:	1884703a 	and	r2,r3,r2
8113db80:	1001703a 	wrctl	status,r2
  
  return context;
8113db84:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113db88:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
8113db8c:	e0bffe17 	ldw	r2,-8(fp)
8113db90:	10800417 	ldw	r2,16(r2)
8113db94:	10001426 	beq	r2,zero,8113dbe8 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
8113db98:	e0bffe17 	ldw	r2,-8(fp)
8113db9c:	10800117 	ldw	r2,4(r2)
8113dba0:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
8113dba4:	e0bffb17 	ldw	r2,-20(fp)
8113dba8:	10c00017 	ldw	r3,0(r2)
8113dbac:	e0bffe17 	ldw	r2,-8(fp)
8113dbb0:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
8113dbb4:	e0bffe17 	ldw	r2,-8(fp)
8113dbb8:	10800417 	ldw	r2,16(r2)
8113dbbc:	10ffffc4 	addi	r3,r2,-1
8113dbc0:	e0bffe17 	ldw	r2,-8(fp)
8113dbc4:	10c00415 	stw	r3,16(r2)
8113dbc8:	e0bff917 	ldw	r2,-28(fp)
8113dbcc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dbd0:	e0bffa17 	ldw	r2,-24(fp)
8113dbd4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
8113dbd8:	e0bfff17 	ldw	r2,-4(fp)
8113dbdc:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
8113dbe0:	e0bffb17 	ldw	r2,-20(fp)
8113dbe4:	00000806 	br	8113dc08 <OSMemGet+0xe8>
8113dbe8:	e0bff917 	ldw	r2,-28(fp)
8113dbec:	e0bffc15 	stw	r2,-16(fp)
8113dbf0:	e0bffc17 	ldw	r2,-16(fp)
8113dbf4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
8113dbf8:	e0bfff17 	ldw	r2,-4(fp)
8113dbfc:	00c01744 	movi	r3,93
8113dc00:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
8113dc04:	0005883a 	mov	r2,zero
}
8113dc08:	e037883a 	mov	sp,fp
8113dc0c:	df000017 	ldw	fp,0(sp)
8113dc10:	dec00104 	addi	sp,sp,4
8113dc14:	f800283a 	ret

8113dc18 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113dc18:	defff704 	addi	sp,sp,-36
8113dc1c:	de00012e 	bgeu	sp,et,8113dc24 <OSMemNameGet+0xc>
8113dc20:	003b68fa 	trap	3
8113dc24:	dfc00815 	stw	ra,32(sp)
8113dc28:	df000715 	stw	fp,28(sp)
8113dc2c:	df000704 	addi	fp,sp,28
8113dc30:	e13ffd15 	stw	r4,-12(fp)
8113dc34:	e17ffe15 	stw	r5,-8(fp)
8113dc38:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113dc3c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113dc40:	e0bfff17 	ldw	r2,-4(fp)
8113dc44:	1000021e 	bne	r2,zero,8113dc50 <OSMemNameGet+0x38>
        return (0);
8113dc48:	0005883a 	mov	r2,zero
8113dc4c:	00002b06 	br	8113dcfc <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113dc50:	e0bffd17 	ldw	r2,-12(fp)
8113dc54:	1000051e 	bne	r2,zero,8113dc6c <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113dc58:	e0bfff17 	ldw	r2,-4(fp)
8113dc5c:	00c01804 	movi	r3,96
8113dc60:	10c00005 	stb	r3,0(r2)
        return (0);
8113dc64:	0005883a 	mov	r2,zero
8113dc68:	00002406 	br	8113dcfc <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113dc6c:	e0bffe17 	ldw	r2,-8(fp)
8113dc70:	1000051e 	bne	r2,zero,8113dc88 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113dc74:	e0bfff17 	ldw	r2,-4(fp)
8113dc78:	00c00304 	movi	r3,12
8113dc7c:	10c00005 	stb	r3,0(r2)
        return (0);
8113dc80:	0005883a 	mov	r2,zero
8113dc84:	00001d06 	br	8113dcfc <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113dc88:	d0a0a103 	ldbu	r2,-32124(gp)
8113dc8c:	10803fcc 	andi	r2,r2,255
8113dc90:	10000526 	beq	r2,zero,8113dca8 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113dc94:	e0bfff17 	ldw	r2,-4(fp)
8113dc98:	00c00444 	movi	r3,17
8113dc9c:	10c00005 	stb	r3,0(r2)
        return (0);
8113dca0:	0005883a 	mov	r2,zero
8113dca4:	00001506 	br	8113dcfc <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dca8:	0005303a 	rdctl	r2,status
8113dcac:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dcb0:	e0fffb17 	ldw	r3,-20(fp)
8113dcb4:	00bfff84 	movi	r2,-2
8113dcb8:	1884703a 	and	r2,r3,r2
8113dcbc:	1001703a 	wrctl	status,r2
  
  return context;
8113dcc0:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
8113dcc4:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
8113dcc8:	e0bffd17 	ldw	r2,-12(fp)
8113dccc:	10800504 	addi	r2,r2,20
8113dcd0:	100b883a 	mov	r5,r2
8113dcd4:	e13ffe17 	ldw	r4,-8(fp)
8113dcd8:	113ba000 	call	8113ba00 <OS_StrCopy>
8113dcdc:	e0bffa05 	stb	r2,-24(fp)
8113dce0:	e0bff917 	ldw	r2,-28(fp)
8113dce4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dce8:	e0bffc17 	ldw	r2,-16(fp)
8113dcec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113dcf0:	e0bfff17 	ldw	r2,-4(fp)
8113dcf4:	10000005 	stb	zero,0(r2)
    return (len);
8113dcf8:	e0bffa03 	ldbu	r2,-24(fp)
}
8113dcfc:	e037883a 	mov	sp,fp
8113dd00:	dfc00117 	ldw	ra,4(sp)
8113dd04:	df000017 	ldw	fp,0(sp)
8113dd08:	dec00204 	addi	sp,sp,8
8113dd0c:	f800283a 	ret

8113dd10 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113dd10:	defff604 	addi	sp,sp,-40
8113dd14:	de00012e 	bgeu	sp,et,8113dd1c <OSMemNameSet+0xc>
8113dd18:	003b68fa 	trap	3
8113dd1c:	dfc00915 	stw	ra,36(sp)
8113dd20:	df000815 	stw	fp,32(sp)
8113dd24:	df000804 	addi	fp,sp,32
8113dd28:	e13ffd15 	stw	r4,-12(fp)
8113dd2c:	e17ffe15 	stw	r5,-8(fp)
8113dd30:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113dd34:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113dd38:	e0bfff17 	ldw	r2,-4(fp)
8113dd3c:	10003526 	beq	r2,zero,8113de14 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113dd40:	e0bffd17 	ldw	r2,-12(fp)
8113dd44:	1000041e 	bne	r2,zero,8113dd58 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113dd48:	e0bfff17 	ldw	r2,-4(fp)
8113dd4c:	00c01804 	movi	r3,96
8113dd50:	10c00005 	stb	r3,0(r2)
        return;
8113dd54:	00003006 	br	8113de18 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113dd58:	e0bffe17 	ldw	r2,-8(fp)
8113dd5c:	1000041e 	bne	r2,zero,8113dd70 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113dd60:	e0bfff17 	ldw	r2,-4(fp)
8113dd64:	00c00304 	movi	r3,12
8113dd68:	10c00005 	stb	r3,0(r2)
        return;
8113dd6c:	00002a06 	br	8113de18 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113dd70:	d0a0a103 	ldbu	r2,-32124(gp)
8113dd74:	10803fcc 	andi	r2,r2,255
8113dd78:	10000426 	beq	r2,zero,8113dd8c <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113dd7c:	e0bfff17 	ldw	r2,-4(fp)
8113dd80:	00c00484 	movi	r3,18
8113dd84:	10c00005 	stb	r3,0(r2)
        return;
8113dd88:	00002306 	br	8113de18 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dd8c:	0005303a 	rdctl	r2,status
8113dd90:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dd94:	e0fffc17 	ldw	r3,-16(fp)
8113dd98:	00bfff84 	movi	r2,-2
8113dd9c:	1884703a 	and	r2,r3,r2
8113dda0:	1001703a 	wrctl	status,r2
  
  return context;
8113dda4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113dda8:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113ddac:	e13ffe17 	ldw	r4,-8(fp)
8113ddb0:	113ba7c0 	call	8113ba7c <OS_StrLen>
8113ddb4:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
8113ddb8:	e0bffa03 	ldbu	r2,-24(fp)
8113ddbc:	10800830 	cmpltui	r2,r2,32
8113ddc0:	1000081e 	bne	r2,zero,8113dde4 <OSMemNameSet+0xd4>
8113ddc4:	e0bff817 	ldw	r2,-32(fp)
8113ddc8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ddcc:	e0bff917 	ldw	r2,-28(fp)
8113ddd0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
8113ddd4:	e0bfff17 	ldw	r2,-4(fp)
8113ddd8:	00c018c4 	movi	r3,99
8113dddc:	10c00005 	stb	r3,0(r2)
        return;
8113dde0:	00000d06 	br	8113de18 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
8113dde4:	e0bffd17 	ldw	r2,-12(fp)
8113dde8:	10800504 	addi	r2,r2,20
8113ddec:	e17ffe17 	ldw	r5,-8(fp)
8113ddf0:	1009883a 	mov	r4,r2
8113ddf4:	113ba000 	call	8113ba00 <OS_StrCopy>
8113ddf8:	e0bff817 	ldw	r2,-32(fp)
8113ddfc:	e0bffb15 	stw	r2,-20(fp)
8113de00:	e0bffb17 	ldw	r2,-20(fp)
8113de04:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113de08:	e0bfff17 	ldw	r2,-4(fp)
8113de0c:	10000005 	stb	zero,0(r2)
8113de10:	00000106 	br	8113de18 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113de14:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113de18:	e037883a 	mov	sp,fp
8113de1c:	dfc00117 	ldw	ra,4(sp)
8113de20:	df000017 	ldw	fp,0(sp)
8113de24:	dec00204 	addi	sp,sp,8
8113de28:	f800283a 	ret

8113de2c <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
8113de2c:	defff904 	addi	sp,sp,-28
8113de30:	de00012e 	bgeu	sp,et,8113de38 <OSMemPut+0xc>
8113de34:	003b68fa 	trap	3
8113de38:	df000615 	stw	fp,24(sp)
8113de3c:	df000604 	addi	fp,sp,24
8113de40:	e13ffe15 	stw	r4,-8(fp)
8113de44:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113de48:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113de4c:	e0bffe17 	ldw	r2,-8(fp)
8113de50:	1000021e 	bne	r2,zero,8113de5c <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113de54:	00801804 	movi	r2,96
8113de58:	00002806 	br	8113defc <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
8113de5c:	e0bfff17 	ldw	r2,-4(fp)
8113de60:	1000021e 	bne	r2,zero,8113de6c <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
8113de64:	008017c4 	movi	r2,95
8113de68:	00002406 	br	8113defc <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113de6c:	0005303a 	rdctl	r2,status
8113de70:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113de74:	e0fffd17 	ldw	r3,-12(fp)
8113de78:	00bfff84 	movi	r2,-2
8113de7c:	1884703a 	and	r2,r3,r2
8113de80:	1001703a 	wrctl	status,r2
  
  return context;
8113de84:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113de88:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
8113de8c:	e0bffe17 	ldw	r2,-8(fp)
8113de90:	10c00417 	ldw	r3,16(r2)
8113de94:	e0bffe17 	ldw	r2,-8(fp)
8113de98:	10800317 	ldw	r2,12(r2)
8113de9c:	18800636 	bltu	r3,r2,8113deb8 <OSMemPut+0x8c>
8113dea0:	e0bffa17 	ldw	r2,-24(fp)
8113dea4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dea8:	e0bffb17 	ldw	r2,-20(fp)
8113deac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
8113deb0:	00801784 	movi	r2,94
8113deb4:	00001106 	br	8113defc <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
8113deb8:	e0bffe17 	ldw	r2,-8(fp)
8113debc:	10c00117 	ldw	r3,4(r2)
8113dec0:	e0bfff17 	ldw	r2,-4(fp)
8113dec4:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
8113dec8:	e0bffe17 	ldw	r2,-8(fp)
8113decc:	e0ffff17 	ldw	r3,-4(fp)
8113ded0:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
8113ded4:	e0bffe17 	ldw	r2,-8(fp)
8113ded8:	10800417 	ldw	r2,16(r2)
8113dedc:	10c00044 	addi	r3,r2,1
8113dee0:	e0bffe17 	ldw	r2,-8(fp)
8113dee4:	10c00415 	stw	r3,16(r2)
8113dee8:	e0bffa17 	ldw	r2,-24(fp)
8113deec:	e0bffc15 	stw	r2,-16(fp)
8113def0:	e0bffc17 	ldw	r2,-16(fp)
8113def4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
8113def8:	0005883a 	mov	r2,zero
}
8113defc:	e037883a 	mov	sp,fp
8113df00:	df000017 	ldw	fp,0(sp)
8113df04:	dec00104 	addi	sp,sp,4
8113df08:	f800283a 	ret

8113df0c <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
8113df0c:	defffa04 	addi	sp,sp,-24
8113df10:	de00012e 	bgeu	sp,et,8113df18 <OSMemQuery+0xc>
8113df14:	003b68fa 	trap	3
8113df18:	df000515 	stw	fp,20(sp)
8113df1c:	df000504 	addi	fp,sp,20
8113df20:	e13ffe15 	stw	r4,-8(fp)
8113df24:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113df28:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113df2c:	e0bffe17 	ldw	r2,-8(fp)
8113df30:	1000021e 	bne	r2,zero,8113df3c <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113df34:	00801804 	movi	r2,96
8113df38:	00002c06 	br	8113dfec <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
8113df3c:	e0bfff17 	ldw	r2,-4(fp)
8113df40:	1000021e 	bne	r2,zero,8113df4c <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
8113df44:	00801844 	movi	r2,97
8113df48:	00002806 	br	8113dfec <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113df4c:	0005303a 	rdctl	r2,status
8113df50:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113df54:	e0fffc17 	ldw	r3,-16(fp)
8113df58:	00bfff84 	movi	r2,-2
8113df5c:	1884703a 	and	r2,r3,r2
8113df60:	1001703a 	wrctl	status,r2
  
  return context;
8113df64:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113df68:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
8113df6c:	e0bffe17 	ldw	r2,-8(fp)
8113df70:	10c00017 	ldw	r3,0(r2)
8113df74:	e0bfff17 	ldw	r2,-4(fp)
8113df78:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
8113df7c:	e0bffe17 	ldw	r2,-8(fp)
8113df80:	10c00117 	ldw	r3,4(r2)
8113df84:	e0bfff17 	ldw	r2,-4(fp)
8113df88:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
8113df8c:	e0bffe17 	ldw	r2,-8(fp)
8113df90:	10c00217 	ldw	r3,8(r2)
8113df94:	e0bfff17 	ldw	r2,-4(fp)
8113df98:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
8113df9c:	e0bffe17 	ldw	r2,-8(fp)
8113dfa0:	10c00317 	ldw	r3,12(r2)
8113dfa4:	e0bfff17 	ldw	r2,-4(fp)
8113dfa8:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
8113dfac:	e0bffe17 	ldw	r2,-8(fp)
8113dfb0:	10c00417 	ldw	r3,16(r2)
8113dfb4:	e0bfff17 	ldw	r2,-4(fp)
8113dfb8:	10c00415 	stw	r3,16(r2)
8113dfbc:	e0bffb17 	ldw	r2,-20(fp)
8113dfc0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dfc4:	e0bffd17 	ldw	r2,-12(fp)
8113dfc8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
8113dfcc:	e0bfff17 	ldw	r2,-4(fp)
8113dfd0:	10c00317 	ldw	r3,12(r2)
8113dfd4:	e0bfff17 	ldw	r2,-4(fp)
8113dfd8:	10800417 	ldw	r2,16(r2)
8113dfdc:	1887c83a 	sub	r3,r3,r2
8113dfe0:	e0bfff17 	ldw	r2,-4(fp)
8113dfe4:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
8113dfe8:	0005883a 	mov	r2,zero
}
8113dfec:	e037883a 	mov	sp,fp
8113dff0:	df000017 	ldw	fp,0(sp)
8113dff4:	dec00104 	addi	sp,sp,4
8113dff8:	f800283a 	ret

8113dffc <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
8113dffc:	defffc04 	addi	sp,sp,-16
8113e000:	de00012e 	bgeu	sp,et,8113e008 <OS_MemInit+0xc>
8113e004:	003b68fa 	trap	3
8113e008:	dfc00315 	stw	ra,12(sp)
8113e00c:	df000215 	stw	fp,8(sp)
8113e010:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
8113e014:	01430c04 	movi	r5,3120
8113e018:	012045f4 	movhi	r4,33047
8113e01c:	2124ee04 	addi	r4,r4,-27720
8113e020:	113b7e00 	call	8113b7e0 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
8113e024:	00a045f4 	movhi	r2,33047
8113e028:	10a4ee04 	addi	r2,r2,-27720
8113e02c:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113e030:	e03fff0d 	sth	zero,-4(fp)
8113e034:	00001306 	br	8113e084 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
8113e038:	e0bfff0b 	ldhu	r2,-4(fp)
8113e03c:	10800044 	addi	r2,r2,1
8113e040:	10c00d24 	muli	r3,r2,52
8113e044:	00a045f4 	movhi	r2,33047
8113e048:	10a4ee04 	addi	r2,r2,-27720
8113e04c:	1887883a 	add	r3,r3,r2
8113e050:	e0bffe17 	ldw	r2,-8(fp)
8113e054:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
8113e058:	e0bffe17 	ldw	r2,-8(fp)
8113e05c:	00c00fc4 	movi	r3,63
8113e060:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
8113e064:	e0bffe17 	ldw	r2,-8(fp)
8113e068:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
8113e06c:	e0bffe17 	ldw	r2,-8(fp)
8113e070:	10800d04 	addi	r2,r2,52
8113e074:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113e078:	e0bfff0b 	ldhu	r2,-4(fp)
8113e07c:	10800044 	addi	r2,r2,1
8113e080:	e0bfff0d 	sth	r2,-4(fp)
8113e084:	e0bfff0b 	ldhu	r2,-4(fp)
8113e088:	10800ef0 	cmpltui	r2,r2,59
8113e08c:	103fea1e 	bne	r2,zero,8113e038 <__reset+0xfb11e038>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
8113e090:	e0bffe17 	ldw	r2,-8(fp)
8113e094:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
8113e098:	e0bffe17 	ldw	r2,-8(fp)
8113e09c:	00c00fc4 	movi	r3,63
8113e0a0:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
8113e0a4:	e0bffe17 	ldw	r2,-8(fp)
8113e0a8:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
8113e0ac:	00a045f4 	movhi	r2,33047
8113e0b0:	10a4ee04 	addi	r2,r2,-27720
8113e0b4:	d0a09b15 	stw	r2,-32148(gp)
#endif
}
8113e0b8:	0001883a 	nop
8113e0bc:	e037883a 	mov	sp,fp
8113e0c0:	dfc00117 	ldw	ra,4(sp)
8113e0c4:	df000017 	ldw	fp,0(sp)
8113e0c8:	dec00204 	addi	sp,sp,8
8113e0cc:	f800283a 	ret

8113e0d0 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
8113e0d0:	defff704 	addi	sp,sp,-36
8113e0d4:	de00012e 	bgeu	sp,et,8113e0dc <OSMutexAccept+0xc>
8113e0d8:	003b68fa 	trap	3
8113e0dc:	df000815 	stw	fp,32(sp)
8113e0e0:	df000804 	addi	fp,sp,32
8113e0e4:	e13ffe15 	stw	r4,-8(fp)
8113e0e8:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113e0ec:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
8113e0f0:	e0bfff17 	ldw	r2,-4(fp)
8113e0f4:	1000021e 	bne	r2,zero,8113e100 <OSMutexAccept+0x30>
        return (OS_FALSE);
8113e0f8:	0005883a 	mov	r2,zero
8113e0fc:	00005b06 	br	8113e26c <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113e100:	e0bffe17 	ldw	r2,-8(fp)
8113e104:	1000051e 	bne	r2,zero,8113e11c <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113e108:	e0bfff17 	ldw	r2,-4(fp)
8113e10c:	00c00104 	movi	r3,4
8113e110:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113e114:	0005883a 	mov	r2,zero
8113e118:	00005406 	br	8113e26c <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
8113e11c:	e0bffe17 	ldw	r2,-8(fp)
8113e120:	10800003 	ldbu	r2,0(r2)
8113e124:	10803fcc 	andi	r2,r2,255
8113e128:	10800120 	cmpeqi	r2,r2,4
8113e12c:	1000051e 	bne	r2,zero,8113e144 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113e130:	e0bfff17 	ldw	r2,-4(fp)
8113e134:	00c00044 	movi	r3,1
8113e138:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113e13c:	0005883a 	mov	r2,zero
8113e140:	00004a06 	br	8113e26c <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
8113e144:	d0a0a103 	ldbu	r2,-32124(gp)
8113e148:	10803fcc 	andi	r2,r2,255
8113e14c:	10000526 	beq	r2,zero,8113e164 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
8113e150:	e0bfff17 	ldw	r2,-4(fp)
8113e154:	00c00084 	movi	r3,2
8113e158:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113e15c:	0005883a 	mov	r2,zero
8113e160:	00004206 	br	8113e26c <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e164:	0005303a 	rdctl	r2,status
8113e168:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e16c:	e0fffd17 	ldw	r3,-12(fp)
8113e170:	00bfff84 	movi	r2,-2
8113e174:	1884703a 	and	r2,r3,r2
8113e178:	1001703a 	wrctl	status,r2
  
  return context;
8113e17c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
8113e180:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
8113e184:	e0bffe17 	ldw	r2,-8(fp)
8113e188:	1080020b 	ldhu	r2,8(r2)
8113e18c:	10bfffcc 	andi	r2,r2,65535
8113e190:	1004d23a 	srli	r2,r2,8
8113e194:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113e198:	e0bffe17 	ldw	r2,-8(fp)
8113e19c:	1080020b 	ldhu	r2,8(r2)
8113e1a0:	10bfffcc 	andi	r2,r2,65535
8113e1a4:	10803fcc 	andi	r2,r2,255
8113e1a8:	10803fd8 	cmpnei	r2,r2,255
8113e1ac:	1000281e 	bne	r2,zero,8113e250 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
8113e1b0:	e0bffe17 	ldw	r2,-8(fp)
8113e1b4:	10c0020b 	ldhu	r3,8(r2)
8113e1b8:	00bfc004 	movi	r2,-256
8113e1bc:	1884703a 	and	r2,r3,r2
8113e1c0:	1007883a 	mov	r3,r2
8113e1c4:	e0bffe17 	ldw	r2,-8(fp)
8113e1c8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
8113e1cc:	e0bffe17 	ldw	r2,-8(fp)
8113e1d0:	10c0020b 	ldhu	r3,8(r2)
8113e1d4:	d0a0a217 	ldw	r2,-32120(gp)
8113e1d8:	10800c83 	ldbu	r2,50(r2)
8113e1dc:	10803fcc 	andi	r2,r2,255
8113e1e0:	1884b03a 	or	r2,r3,r2
8113e1e4:	1007883a 	mov	r3,r2
8113e1e8:	e0bffe17 	ldw	r2,-8(fp)
8113e1ec:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8113e1f0:	d0e0a217 	ldw	r3,-32120(gp)
8113e1f4:	e0bffe17 	ldw	r2,-8(fp)
8113e1f8:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
8113e1fc:	d0a0a217 	ldw	r2,-32120(gp)
8113e200:	10800c83 	ldbu	r2,50(r2)
8113e204:	10803fcc 	andi	r2,r2,255
8113e208:	e0fffa03 	ldbu	r3,-24(fp)
8113e20c:	18800836 	bltu	r3,r2,8113e230 <OSMutexAccept+0x160>
8113e210:	e0bff817 	ldw	r2,-32(fp)
8113e214:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e218:	e0bff917 	ldw	r2,-28(fp)
8113e21c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
8113e220:	e0bfff17 	ldw	r2,-4(fp)
8113e224:	00c01e04 	movi	r3,120
8113e228:	10c00005 	stb	r3,0(r2)
8113e22c:	00000606 	br	8113e248 <OSMutexAccept+0x178>
8113e230:	e0bff817 	ldw	r2,-32(fp)
8113e234:	e0bffb15 	stw	r2,-20(fp)
8113e238:	e0bffb17 	ldw	r2,-20(fp)
8113e23c:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113e240:	e0bfff17 	ldw	r2,-4(fp)
8113e244:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
8113e248:	00800044 	movi	r2,1
8113e24c:	00000706 	br	8113e26c <OSMutexAccept+0x19c>
8113e250:	e0bff817 	ldw	r2,-32(fp)
8113e254:	e0bffc15 	stw	r2,-16(fp)
8113e258:	e0bffc17 	ldw	r2,-16(fp)
8113e25c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113e260:	e0bfff17 	ldw	r2,-4(fp)
8113e264:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
8113e268:	0005883a 	mov	r2,zero
}
8113e26c:	e037883a 	mov	sp,fp
8113e270:	df000017 	ldw	fp,0(sp)
8113e274:	dec00104 	addi	sp,sp,4
8113e278:	f800283a 	ret

8113e27c <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
8113e27c:	defff604 	addi	sp,sp,-40
8113e280:	de00012e 	bgeu	sp,et,8113e288 <OSMutexCreate+0xc>
8113e284:	003b68fa 	trap	3
8113e288:	dfc00915 	stw	ra,36(sp)
8113e28c:	df000815 	stw	fp,32(sp)
8113e290:	df000804 	addi	fp,sp,32
8113e294:	2005883a 	mov	r2,r4
8113e298:	e17fff15 	stw	r5,-4(fp)
8113e29c:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e2a0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113e2a4:	e0bfff17 	ldw	r2,-4(fp)
8113e2a8:	1000021e 	bne	r2,zero,8113e2b4 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
8113e2ac:	0005883a 	mov	r2,zero
8113e2b0:	00006106 	br	8113e438 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
8113e2b4:	e0bffe03 	ldbu	r2,-8(fp)
8113e2b8:	10800ab0 	cmpltui	r2,r2,42
8113e2bc:	1000051e 	bne	r2,zero,8113e2d4 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
8113e2c0:	e0bfff17 	ldw	r2,-4(fp)
8113e2c4:	00c00a84 	movi	r3,42
8113e2c8:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113e2cc:	0005883a 	mov	r2,zero
8113e2d0:	00005906 	br	8113e438 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e2d4:	d0a0a103 	ldbu	r2,-32124(gp)
8113e2d8:	10803fcc 	andi	r2,r2,255
8113e2dc:	10000526 	beq	r2,zero,8113e2f4 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
8113e2e0:	e0bfff17 	ldw	r2,-4(fp)
8113e2e4:	00c00404 	movi	r3,16
8113e2e8:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113e2ec:	0005883a 	mov	r2,zero
8113e2f0:	00005106 	br	8113e438 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e2f4:	0005303a 	rdctl	r2,status
8113e2f8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e2fc:	e0fffd17 	ldw	r3,-12(fp)
8113e300:	00bfff84 	movi	r2,-2
8113e304:	1884703a 	and	r2,r3,r2
8113e308:	1001703a 	wrctl	status,r2
  
  return context;
8113e30c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113e310:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
8113e314:	e0fffe03 	ldbu	r3,-8(fp)
8113e318:	00a045f4 	movhi	r2,33047
8113e31c:	10ba6804 	addi	r2,r2,-5728
8113e320:	18c7883a 	add	r3,r3,r3
8113e324:	18c7883a 	add	r3,r3,r3
8113e328:	10c5883a 	add	r2,r2,r3
8113e32c:	10800017 	ldw	r2,0(r2)
8113e330:	10000926 	beq	r2,zero,8113e358 <OSMutexCreate+0xdc>
8113e334:	e0bff817 	ldw	r2,-32(fp)
8113e338:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e33c:	e0bff917 	ldw	r2,-28(fp)
8113e340:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
8113e344:	e0bfff17 	ldw	r2,-4(fp)
8113e348:	00c00a04 	movi	r3,40
8113e34c:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113e350:	0005883a 	mov	r2,zero
8113e354:	00003806 	br	8113e438 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
8113e358:	e0fffe03 	ldbu	r3,-8(fp)
8113e35c:	00a045f4 	movhi	r2,33047
8113e360:	10ba6804 	addi	r2,r2,-5728
8113e364:	18c7883a 	add	r3,r3,r3
8113e368:	18c7883a 	add	r3,r3,r3
8113e36c:	10c5883a 	add	r2,r2,r3
8113e370:	00c00044 	movi	r3,1
8113e374:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
8113e378:	d0a0a017 	ldw	r2,-32128(gp)
8113e37c:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8113e380:	e0bffb17 	ldw	r2,-20(fp)
8113e384:	1000101e 	bne	r2,zero,8113e3c8 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
8113e388:	e0fffe03 	ldbu	r3,-8(fp)
8113e38c:	00a045f4 	movhi	r2,33047
8113e390:	10ba6804 	addi	r2,r2,-5728
8113e394:	18c7883a 	add	r3,r3,r3
8113e398:	18c7883a 	add	r3,r3,r3
8113e39c:	10c5883a 	add	r2,r2,r3
8113e3a0:	10000015 	stw	zero,0(r2)
8113e3a4:	e0bff817 	ldw	r2,-32(fp)
8113e3a8:	e0bffa15 	stw	r2,-24(fp)
8113e3ac:	e0bffa17 	ldw	r2,-24(fp)
8113e3b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
8113e3b4:	e0bfff17 	ldw	r2,-4(fp)
8113e3b8:	00c00104 	movi	r3,4
8113e3bc:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e3c0:	e0bffb17 	ldw	r2,-20(fp)
8113e3c4:	00001c06 	br	8113e438 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
8113e3c8:	d0a0a017 	ldw	r2,-32128(gp)
8113e3cc:	10800117 	ldw	r2,4(r2)
8113e3d0:	d0a0a015 	stw	r2,-32128(gp)
8113e3d4:	e0bff817 	ldw	r2,-32(fp)
8113e3d8:	e0bffc15 	stw	r2,-16(fp)
8113e3dc:	e0bffc17 	ldw	r2,-16(fp)
8113e3e0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
8113e3e4:	e0bffb17 	ldw	r2,-20(fp)
8113e3e8:	00c00104 	movi	r3,4
8113e3ec:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8113e3f0:	e0bffe03 	ldbu	r2,-8(fp)
8113e3f4:	1004923a 	slli	r2,r2,8
8113e3f8:	10803fd4 	ori	r2,r2,255
8113e3fc:	1007883a 	mov	r3,r2
8113e400:	e0bffb17 	ldw	r2,-20(fp)
8113e404:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
8113e408:	e0bffb17 	ldw	r2,-20(fp)
8113e40c:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
8113e410:	e0bffb17 	ldw	r2,-20(fp)
8113e414:	00c00fc4 	movi	r3,63
8113e418:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
8113e41c:	e0bffb17 	ldw	r2,-20(fp)
8113e420:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
8113e424:	e13ffb17 	ldw	r4,-20(fp)
8113e428:	113b3c80 	call	8113b3c8 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
8113e42c:	e0bfff17 	ldw	r2,-4(fp)
8113e430:	10000005 	stb	zero,0(r2)
    return (pevent);
8113e434:	e0bffb17 	ldw	r2,-20(fp)
}
8113e438:	e037883a 	mov	sp,fp
8113e43c:	dfc00117 	ldw	ra,4(sp)
8113e440:	df000017 	ldw	fp,0(sp)
8113e444:	dec00204 	addi	sp,sp,8
8113e448:	f800283a 	ret

8113e44c <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113e44c:	defff004 	addi	sp,sp,-64
8113e450:	de00012e 	bgeu	sp,et,8113e458 <OSMutexDel+0xc>
8113e454:	003b68fa 	trap	3
8113e458:	dfc00f15 	stw	ra,60(sp)
8113e45c:	df000e15 	stw	fp,56(sp)
8113e460:	df000e04 	addi	fp,sp,56
8113e464:	e13ffd15 	stw	r4,-12(fp)
8113e468:	2805883a 	mov	r2,r5
8113e46c:	e1bfff15 	stw	r6,-4(fp)
8113e470:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e474:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113e478:	e0bfff17 	ldw	r2,-4(fp)
8113e47c:	1000021e 	bne	r2,zero,8113e488 <OSMutexDel+0x3c>
        return (pevent);
8113e480:	e0bffd17 	ldw	r2,-12(fp)
8113e484:	0000ad06 	br	8113e73c <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113e488:	e0bffd17 	ldw	r2,-12(fp)
8113e48c:	1000051e 	bne	r2,zero,8113e4a4 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113e490:	e0bfff17 	ldw	r2,-4(fp)
8113e494:	00c00104 	movi	r3,4
8113e498:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e49c:	e0bffd17 	ldw	r2,-12(fp)
8113e4a0:	0000a606 	br	8113e73c <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113e4a4:	e0bffd17 	ldw	r2,-12(fp)
8113e4a8:	10800003 	ldbu	r2,0(r2)
8113e4ac:	10803fcc 	andi	r2,r2,255
8113e4b0:	10800120 	cmpeqi	r2,r2,4
8113e4b4:	1000051e 	bne	r2,zero,8113e4cc <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113e4b8:	e0bfff17 	ldw	r2,-4(fp)
8113e4bc:	00c00044 	movi	r3,1
8113e4c0:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e4c4:	e0bffd17 	ldw	r2,-12(fp)
8113e4c8:	00009c06 	br	8113e73c <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e4cc:	d0a0a103 	ldbu	r2,-32124(gp)
8113e4d0:	10803fcc 	andi	r2,r2,255
8113e4d4:	10000526 	beq	r2,zero,8113e4ec <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113e4d8:	e0bfff17 	ldw	r2,-4(fp)
8113e4dc:	00c003c4 	movi	r3,15
8113e4e0:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e4e4:	e0bffd17 	ldw	r2,-12(fp)
8113e4e8:	00009406 	br	8113e73c <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e4ec:	0005303a 	rdctl	r2,status
8113e4f0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e4f4:	e0fffc17 	ldw	r3,-16(fp)
8113e4f8:	00bfff84 	movi	r2,-2
8113e4fc:	1884703a 	and	r2,r3,r2
8113e500:	1001703a 	wrctl	status,r2
  
  return context;
8113e504:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e508:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
8113e50c:	e0bffd17 	ldw	r2,-12(fp)
8113e510:	10800283 	ldbu	r2,10(r2)
8113e514:	10803fcc 	andi	r2,r2,255
8113e518:	10000326 	beq	r2,zero,8113e528 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113e51c:	00800044 	movi	r2,1
8113e520:	e0bff205 	stb	r2,-56(fp)
8113e524:	00000106 	br	8113e52c <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113e528:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
8113e52c:	e0bffe03 	ldbu	r2,-8(fp)
8113e530:	10000326 	beq	r2,zero,8113e540 <OSMutexDel+0xf4>
8113e534:	10800060 	cmpeqi	r2,r2,1
8113e538:	10002f1e 	bne	r2,zero,8113e5f8 <OSMutexDel+0x1ac>
8113e53c:	00007406 	br	8113e710 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
8113e540:	e0bff203 	ldbu	r2,-56(fp)
8113e544:	1000221e 	bne	r2,zero,8113e5d0 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113e548:	e0bffd17 	ldw	r2,-12(fp)
8113e54c:	00c00fc4 	movi	r3,63
8113e550:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113e554:	e0bffd17 	ldw	r2,-12(fp)
8113e558:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113e55c:	e0bffd17 	ldw	r2,-12(fp)
8113e560:	1080020b 	ldhu	r2,8(r2)
8113e564:	10bfffcc 	andi	r2,r2,65535
8113e568:	1004d23a 	srli	r2,r2,8
8113e56c:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8113e570:	e0fff603 	ldbu	r3,-40(fp)
8113e574:	00a045f4 	movhi	r2,33047
8113e578:	10ba6804 	addi	r2,r2,-5728
8113e57c:	18c7883a 	add	r3,r3,r3
8113e580:	18c7883a 	add	r3,r3,r3
8113e584:	10c5883a 	add	r2,r2,r3
8113e588:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113e58c:	e0bffd17 	ldw	r2,-12(fp)
8113e590:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
8113e594:	d0e0a017 	ldw	r3,-32128(gp)
8113e598:	e0bffd17 	ldw	r2,-12(fp)
8113e59c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
8113e5a0:	e0bffd17 	ldw	r2,-12(fp)
8113e5a4:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
8113e5a8:	e0bffd17 	ldw	r2,-12(fp)
8113e5ac:	d0a0a015 	stw	r2,-32128(gp)
8113e5b0:	e0bff417 	ldw	r2,-48(fp)
8113e5b4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e5b8:	e0bff517 	ldw	r2,-44(fp)
8113e5bc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
8113e5c0:	e0bfff17 	ldw	r2,-4(fp)
8113e5c4:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
8113e5c8:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
8113e5cc:	00005a06 	br	8113e738 <OSMutexDel+0x2ec>
8113e5d0:	e0bff417 	ldw	r2,-48(fp)
8113e5d4:	e0bff715 	stw	r2,-36(fp)
8113e5d8:	e0bff717 	ldw	r2,-36(fp)
8113e5dc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
8113e5e0:	e0bfff17 	ldw	r2,-4(fp)
8113e5e4:	00c01244 	movi	r3,73
8113e5e8:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
8113e5ec:	e0bffd17 	ldw	r2,-12(fp)
8113e5f0:	e0bff315 	stw	r2,-52(fp)
             }
             break;
8113e5f4:	00005006 	br	8113e738 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
8113e5f8:	e0bffd17 	ldw	r2,-12(fp)
8113e5fc:	1080020b 	ldhu	r2,8(r2)
8113e600:	10bfffcc 	andi	r2,r2,65535
8113e604:	1004d23a 	srli	r2,r2,8
8113e608:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
8113e60c:	e0bffd17 	ldw	r2,-12(fp)
8113e610:	1080020b 	ldhu	r2,8(r2)
8113e614:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
8113e618:	e0bffd17 	ldw	r2,-12(fp)
8113e61c:	10800117 	ldw	r2,4(r2)
8113e620:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
8113e624:	e0bffa17 	ldw	r2,-24(fp)
8113e628:	10000f26 	beq	r2,zero,8113e668 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
8113e62c:	e0bffa17 	ldw	r2,-24(fp)
8113e630:	10800c83 	ldbu	r2,50(r2)
8113e634:	10c03fcc 	andi	r3,r2,255
8113e638:	e0bff603 	ldbu	r2,-40(fp)
8113e63c:	18800a1e 	bne	r3,r2,8113e668 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
8113e640:	e0bff903 	ldbu	r2,-28(fp)
8113e644:	100b883a 	mov	r5,r2
8113e648:	e13ffa17 	ldw	r4,-24(fp)
8113e64c:	113f0880 	call	8113f088 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113e650:	00000506 	br	8113e668 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113e654:	000f883a 	mov	r7,zero
8113e658:	01800404 	movi	r6,16
8113e65c:	000b883a 	mov	r5,zero
8113e660:	e13ffd17 	ldw	r4,-12(fp)
8113e664:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113e668:	e0bffd17 	ldw	r2,-12(fp)
8113e66c:	10800283 	ldbu	r2,10(r2)
8113e670:	10803fcc 	andi	r2,r2,255
8113e674:	103ff71e 	bne	r2,zero,8113e654 <__reset+0xfb11e654>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113e678:	e0bffd17 	ldw	r2,-12(fp)
8113e67c:	00c00fc4 	movi	r3,63
8113e680:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113e684:	e0bffd17 	ldw	r2,-12(fp)
8113e688:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113e68c:	e0bffd17 	ldw	r2,-12(fp)
8113e690:	1080020b 	ldhu	r2,8(r2)
8113e694:	10bfffcc 	andi	r2,r2,65535
8113e698:	1004d23a 	srli	r2,r2,8
8113e69c:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
8113e6a0:	e0fff603 	ldbu	r3,-40(fp)
8113e6a4:	00a045f4 	movhi	r2,33047
8113e6a8:	10ba6804 	addi	r2,r2,-5728
8113e6ac:	18c7883a 	add	r3,r3,r3
8113e6b0:	18c7883a 	add	r3,r3,r3
8113e6b4:	10c5883a 	add	r2,r2,r3
8113e6b8:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113e6bc:	e0bffd17 	ldw	r2,-12(fp)
8113e6c0:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
8113e6c4:	d0e0a017 	ldw	r3,-32128(gp)
8113e6c8:	e0bffd17 	ldw	r2,-12(fp)
8113e6cc:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
8113e6d0:	e0bffd17 	ldw	r2,-12(fp)
8113e6d4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
8113e6d8:	e0bffd17 	ldw	r2,-12(fp)
8113e6dc:	d0a0a015 	stw	r2,-32128(gp)
8113e6e0:	e0bff417 	ldw	r2,-48(fp)
8113e6e4:	e0bff815 	stw	r2,-32(fp)
8113e6e8:	e0bff817 	ldw	r2,-32(fp)
8113e6ec:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113e6f0:	e0bff203 	ldbu	r2,-56(fp)
8113e6f4:	10800058 	cmpnei	r2,r2,1
8113e6f8:	1000011e 	bne	r2,zero,8113e700 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113e6fc:	113b8ac0 	call	8113b8ac <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
8113e700:	e0bfff17 	ldw	r2,-4(fp)
8113e704:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
8113e708:	e03ff315 	stw	zero,-52(fp)
             break;
8113e70c:	00000a06 	br	8113e738 <OSMutexDel+0x2ec>
8113e710:	e0bff417 	ldw	r2,-48(fp)
8113e714:	e0bffb15 	stw	r2,-20(fp)
8113e718:	e0bffb17 	ldw	r2,-20(fp)
8113e71c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
8113e720:	e0bfff17 	ldw	r2,-4(fp)
8113e724:	00c001c4 	movi	r3,7
8113e728:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
8113e72c:	e0bffd17 	ldw	r2,-12(fp)
8113e730:	e0bff315 	stw	r2,-52(fp)
             break;
8113e734:	0001883a 	nop
    }
    return (pevent_return);
8113e738:	e0bff317 	ldw	r2,-52(fp)
}
8113e73c:	e037883a 	mov	sp,fp
8113e740:	dfc00117 	ldw	ra,4(sp)
8113e744:	df000017 	ldw	fp,0(sp)
8113e748:	dec00204 	addi	sp,sp,8
8113e74c:	f800283a 	ret

8113e750 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113e750:	deffee04 	addi	sp,sp,-72
8113e754:	de00012e 	bgeu	sp,et,8113e75c <OSMutexPend+0xc>
8113e758:	003b68fa 	trap	3
8113e75c:	dfc01115 	stw	ra,68(sp)
8113e760:	df001015 	stw	fp,64(sp)
8113e764:	df001004 	addi	fp,sp,64
8113e768:	e13ffd15 	stw	r4,-12(fp)
8113e76c:	2805883a 	mov	r2,r5
8113e770:	e1bfff15 	stw	r6,-4(fp)
8113e774:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e778:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113e77c:	e0bfff17 	ldw	r2,-4(fp)
8113e780:	10015626 	beq	r2,zero,8113ecdc <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113e784:	e0bffd17 	ldw	r2,-12(fp)
8113e788:	1000041e 	bne	r2,zero,8113e79c <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113e78c:	e0bfff17 	ldw	r2,-4(fp)
8113e790:	00c00104 	movi	r3,4
8113e794:	10c00005 	stb	r3,0(r2)
        return;
8113e798:	00015106 	br	8113ece0 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113e79c:	e0bffd17 	ldw	r2,-12(fp)
8113e7a0:	10800003 	ldbu	r2,0(r2)
8113e7a4:	10803fcc 	andi	r2,r2,255
8113e7a8:	10800120 	cmpeqi	r2,r2,4
8113e7ac:	1000041e 	bne	r2,zero,8113e7c0 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113e7b0:	e0bfff17 	ldw	r2,-4(fp)
8113e7b4:	00c00044 	movi	r3,1
8113e7b8:	10c00005 	stb	r3,0(r2)
        return;
8113e7bc:	00014806 	br	8113ece0 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e7c0:	d0a0a103 	ldbu	r2,-32124(gp)
8113e7c4:	10803fcc 	andi	r2,r2,255
8113e7c8:	10000426 	beq	r2,zero,8113e7dc <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113e7cc:	e0bfff17 	ldw	r2,-4(fp)
8113e7d0:	00c00084 	movi	r3,2
8113e7d4:	10c00005 	stb	r3,0(r2)
        return;
8113e7d8:	00014106 	br	8113ece0 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113e7dc:	d0a08f03 	ldbu	r2,-32196(gp)
8113e7e0:	10803fcc 	andi	r2,r2,255
8113e7e4:	10000426 	beq	r2,zero,8113e7f8 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113e7e8:	e0bfff17 	ldw	r2,-4(fp)
8113e7ec:	00c00344 	movi	r3,13
8113e7f0:	10c00005 	stb	r3,0(r2)
        return;
8113e7f4:	00013a06 	br	8113ece0 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e7f8:	0005303a 	rdctl	r2,status
8113e7fc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e800:	e0fffc17 	ldw	r3,-16(fp)
8113e804:	00bfff84 	movi	r2,-2
8113e808:	1884703a 	and	r2,r3,r2
8113e80c:	1001703a 	wrctl	status,r2
  
  return context;
8113e810:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113e814:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
8113e818:	e0bffd17 	ldw	r2,-12(fp)
8113e81c:	1080020b 	ldhu	r2,8(r2)
8113e820:	10bfffcc 	andi	r2,r2,65535
8113e824:	1004d23a 	srli	r2,r2,8
8113e828:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113e82c:	e0bffd17 	ldw	r2,-12(fp)
8113e830:	1080020b 	ldhu	r2,8(r2)
8113e834:	10803fcc 	andi	r2,r2,255
8113e838:	10803fd8 	cmpnei	r2,r2,255
8113e83c:	1000271e 	bne	r2,zero,8113e8dc <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
8113e840:	e0bffd17 	ldw	r2,-12(fp)
8113e844:	10c0020b 	ldhu	r3,8(r2)
8113e848:	00bfc004 	movi	r2,-256
8113e84c:	1884703a 	and	r2,r3,r2
8113e850:	1007883a 	mov	r3,r2
8113e854:	e0bffd17 	ldw	r2,-12(fp)
8113e858:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
8113e85c:	e0bffd17 	ldw	r2,-12(fp)
8113e860:	10c0020b 	ldhu	r3,8(r2)
8113e864:	d0a0a217 	ldw	r2,-32120(gp)
8113e868:	10800c83 	ldbu	r2,50(r2)
8113e86c:	10803fcc 	andi	r2,r2,255
8113e870:	1884b03a 	or	r2,r3,r2
8113e874:	1007883a 	mov	r3,r2
8113e878:	e0bffd17 	ldw	r2,-12(fp)
8113e87c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
8113e880:	d0e0a217 	ldw	r3,-32120(gp)
8113e884:	e0bffd17 	ldw	r2,-12(fp)
8113e888:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
8113e88c:	d0a0a217 	ldw	r2,-32120(gp)
8113e890:	10800c83 	ldbu	r2,50(r2)
8113e894:	10803fcc 	andi	r2,r2,255
8113e898:	e0fff303 	ldbu	r3,-52(fp)
8113e89c:	18800836 	bltu	r3,r2,8113e8c0 <OSMutexPend+0x170>
8113e8a0:	e0bff117 	ldw	r2,-60(fp)
8113e8a4:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e8a8:	e0bff217 	ldw	r2,-56(fp)
8113e8ac:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
8113e8b0:	e0bfff17 	ldw	r2,-4(fp)
8113e8b4:	00c01e04 	movi	r3,120
8113e8b8:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
8113e8bc:	00010806 	br	8113ece0 <OSMutexPend+0x590>
8113e8c0:	e0bff117 	ldw	r2,-60(fp)
8113e8c4:	e0bff415 	stw	r2,-48(fp)
8113e8c8:	e0bff417 	ldw	r2,-48(fp)
8113e8cc:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113e8d0:	e0bfff17 	ldw	r2,-4(fp)
8113e8d4:	10000005 	stb	zero,0(r2)
        }
        return;
8113e8d8:	00010106 	br	8113ece0 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
8113e8dc:	e0bffd17 	ldw	r2,-12(fp)
8113e8e0:	1080020b 	ldhu	r2,8(r2)
8113e8e4:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
8113e8e8:	e0bffd17 	ldw	r2,-12(fp)
8113e8ec:	10800117 	ldw	r2,4(r2)
8113e8f0:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
8113e8f4:	e0bff717 	ldw	r2,-36(fp)
8113e8f8:	10800c83 	ldbu	r2,50(r2)
8113e8fc:	10803fcc 	andi	r2,r2,255
8113e900:	e0fff303 	ldbu	r3,-52(fp)
8113e904:	1880b92e 	bgeu	r3,r2,8113ebec <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
8113e908:	d0a0a217 	ldw	r2,-32120(gp)
8113e90c:	10800c83 	ldbu	r2,50(r2)
8113e910:	10c03fcc 	andi	r3,r2,255
8113e914:	e0bff603 	ldbu	r2,-40(fp)
8113e918:	1880b42e 	bgeu	r3,r2,8113ebec <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
8113e91c:	e0bff717 	ldw	r2,-36(fp)
8113e920:	10800d03 	ldbu	r2,52(r2)
8113e924:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
8113e928:	e0fff803 	ldbu	r3,-32(fp)
8113e92c:	d0a09e44 	addi	r2,gp,-32135
8113e930:	1885883a 	add	r2,r3,r2
8113e934:	10c00003 	ldbu	r3,0(r2)
8113e938:	e0bff717 	ldw	r2,-36(fp)
8113e93c:	10800d43 	ldbu	r2,53(r2)
8113e940:	1884703a 	and	r2,r3,r2
8113e944:	10803fcc 	andi	r2,r2,255
8113e948:	10001e26 	beq	r2,zero,8113e9c4 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
8113e94c:	e0fff803 	ldbu	r3,-32(fp)
8113e950:	e13ff803 	ldbu	r4,-32(fp)
8113e954:	d0a09e44 	addi	r2,gp,-32135
8113e958:	2085883a 	add	r2,r4,r2
8113e95c:	10800003 	ldbu	r2,0(r2)
8113e960:	1009883a 	mov	r4,r2
8113e964:	e0bff717 	ldw	r2,-36(fp)
8113e968:	10800d43 	ldbu	r2,53(r2)
8113e96c:	0084303a 	nor	r2,zero,r2
8113e970:	2084703a 	and	r2,r4,r2
8113e974:	1009883a 	mov	r4,r2
8113e978:	d0a09e44 	addi	r2,gp,-32135
8113e97c:	1885883a 	add	r2,r3,r2
8113e980:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
8113e984:	e0fff803 	ldbu	r3,-32(fp)
8113e988:	d0a09e44 	addi	r2,gp,-32135
8113e98c:	1885883a 	add	r2,r3,r2
8113e990:	10800003 	ldbu	r2,0(r2)
8113e994:	10803fcc 	andi	r2,r2,255
8113e998:	1000071e 	bne	r2,zero,8113e9b8 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
8113e99c:	e0bff717 	ldw	r2,-36(fp)
8113e9a0:	10800d83 	ldbu	r2,54(r2)
8113e9a4:	0084303a 	nor	r2,zero,r2
8113e9a8:	1007883a 	mov	r3,r2
8113e9ac:	d0a09e03 	ldbu	r2,-32136(gp)
8113e9b0:	1884703a 	and	r2,r3,r2
8113e9b4:	d0a09e05 	stb	r2,-32136(gp)
                }
                rdy = OS_TRUE;
8113e9b8:	00800044 	movi	r2,1
8113e9bc:	e0bff005 	stb	r2,-64(fp)
8113e9c0:	00002a06 	br	8113ea6c <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113e9c4:	e0bff717 	ldw	r2,-36(fp)
8113e9c8:	10800717 	ldw	r2,28(r2)
8113e9cc:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
8113e9d0:	e0bff917 	ldw	r2,-28(fp)
8113e9d4:	10002426 	beq	r2,zero,8113ea68 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
8113e9d8:	e0bff717 	ldw	r2,-36(fp)
8113e9dc:	10800d03 	ldbu	r2,52(r2)
8113e9e0:	10803fcc 	andi	r2,r2,255
8113e9e4:	e0fff717 	ldw	r3,-36(fp)
8113e9e8:	18c00d03 	ldbu	r3,52(r3)
8113e9ec:	18c03fcc 	andi	r3,r3,255
8113e9f0:	e13ff917 	ldw	r4,-28(fp)
8113e9f4:	20c7883a 	add	r3,r4,r3
8113e9f8:	18c002c4 	addi	r3,r3,11
8113e9fc:	18c00003 	ldbu	r3,0(r3)
8113ea00:	1809883a 	mov	r4,r3
8113ea04:	e0fff717 	ldw	r3,-36(fp)
8113ea08:	18c00d43 	ldbu	r3,53(r3)
8113ea0c:	00c6303a 	nor	r3,zero,r3
8113ea10:	20c6703a 	and	r3,r4,r3
8113ea14:	1809883a 	mov	r4,r3
8113ea18:	e0fff917 	ldw	r3,-28(fp)
8113ea1c:	1887883a 	add	r3,r3,r2
8113ea20:	18c002c4 	addi	r3,r3,11
8113ea24:	19000005 	stb	r4,0(r3)
8113ea28:	e0fff917 	ldw	r3,-28(fp)
8113ea2c:	1885883a 	add	r2,r3,r2
8113ea30:	108002c4 	addi	r2,r2,11
8113ea34:	10800003 	ldbu	r2,0(r2)
8113ea38:	10803fcc 	andi	r2,r2,255
8113ea3c:	10000a1e 	bne	r2,zero,8113ea68 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
8113ea40:	e0bff917 	ldw	r2,-28(fp)
8113ea44:	10800283 	ldbu	r2,10(r2)
8113ea48:	1007883a 	mov	r3,r2
8113ea4c:	e0bff717 	ldw	r2,-36(fp)
8113ea50:	10800d83 	ldbu	r2,54(r2)
8113ea54:	0084303a 	nor	r2,zero,r2
8113ea58:	1884703a 	and	r2,r3,r2
8113ea5c:	1007883a 	mov	r3,r2
8113ea60:	e0bff917 	ldw	r2,-28(fp)
8113ea64:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
8113ea68:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
8113ea6c:	e0bff717 	ldw	r2,-36(fp)
8113ea70:	e0fff303 	ldbu	r3,-52(fp)
8113ea74:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
8113ea78:	e0bff717 	ldw	r2,-36(fp)
8113ea7c:	10800c83 	ldbu	r2,50(r2)
8113ea80:	10803fcc 	andi	r2,r2,255
8113ea84:	1004d0fa 	srli	r2,r2,3
8113ea88:	1007883a 	mov	r3,r2
8113ea8c:	e0bff717 	ldw	r2,-36(fp)
8113ea90:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
8113ea94:	e0bff717 	ldw	r2,-36(fp)
8113ea98:	10800c83 	ldbu	r2,50(r2)
8113ea9c:	108001cc 	andi	r2,r2,7
8113eaa0:	1007883a 	mov	r3,r2
8113eaa4:	e0bff717 	ldw	r2,-36(fp)
8113eaa8:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
8113eaac:	e0bff717 	ldw	r2,-36(fp)
8113eab0:	10800d03 	ldbu	r2,52(r2)
8113eab4:	10803fcc 	andi	r2,r2,255
8113eab8:	00c00044 	movi	r3,1
8113eabc:	1884983a 	sll	r2,r3,r2
8113eac0:	1007883a 	mov	r3,r2
8113eac4:	e0bff717 	ldw	r2,-36(fp)
8113eac8:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
8113eacc:	e0bff717 	ldw	r2,-36(fp)
8113ead0:	10800cc3 	ldbu	r2,51(r2)
8113ead4:	10803fcc 	andi	r2,r2,255
8113ead8:	00c00044 	movi	r3,1
8113eadc:	1884983a 	sll	r2,r3,r2
8113eae0:	1007883a 	mov	r3,r2
8113eae4:	e0bff717 	ldw	r2,-36(fp)
8113eae8:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
8113eaec:	e0bff003 	ldbu	r2,-64(fp)
8113eaf0:	10800058 	cmpnei	r2,r2,1
8113eaf4:	1000161e 	bne	r2,zero,8113eb50 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
8113eaf8:	e0bff717 	ldw	r2,-36(fp)
8113eafc:	10c00d83 	ldbu	r3,54(r2)
8113eb00:	d0a09e03 	ldbu	r2,-32136(gp)
8113eb04:	1884b03a 	or	r2,r3,r2
8113eb08:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113eb0c:	e0bff717 	ldw	r2,-36(fp)
8113eb10:	10800d03 	ldbu	r2,52(r2)
8113eb14:	10c03fcc 	andi	r3,r2,255
8113eb18:	e0bff717 	ldw	r2,-36(fp)
8113eb1c:	10800d03 	ldbu	r2,52(r2)
8113eb20:	11003fcc 	andi	r4,r2,255
8113eb24:	d0a09e44 	addi	r2,gp,-32135
8113eb28:	2085883a 	add	r2,r4,r2
8113eb2c:	11000003 	ldbu	r4,0(r2)
8113eb30:	e0bff717 	ldw	r2,-36(fp)
8113eb34:	10800d43 	ldbu	r2,53(r2)
8113eb38:	2084b03a 	or	r2,r4,r2
8113eb3c:	1009883a 	mov	r4,r2
8113eb40:	d0a09e44 	addi	r2,gp,-32135
8113eb44:	1885883a 	add	r2,r3,r2
8113eb48:	11000005 	stb	r4,0(r2)
8113eb4c:	00001f06 	br	8113ebcc <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113eb50:	e0bff717 	ldw	r2,-36(fp)
8113eb54:	10800717 	ldw	r2,28(r2)
8113eb58:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
8113eb5c:	e0bff917 	ldw	r2,-28(fp)
8113eb60:	10001a26 	beq	r2,zero,8113ebcc <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
8113eb64:	e0bff917 	ldw	r2,-28(fp)
8113eb68:	10c00283 	ldbu	r3,10(r2)
8113eb6c:	e0bff717 	ldw	r2,-36(fp)
8113eb70:	10800d83 	ldbu	r2,54(r2)
8113eb74:	1884b03a 	or	r2,r3,r2
8113eb78:	1007883a 	mov	r3,r2
8113eb7c:	e0bff917 	ldw	r2,-28(fp)
8113eb80:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113eb84:	e0bff717 	ldw	r2,-36(fp)
8113eb88:	10800d03 	ldbu	r2,52(r2)
8113eb8c:	10803fcc 	andi	r2,r2,255
8113eb90:	e0fff717 	ldw	r3,-36(fp)
8113eb94:	18c00d03 	ldbu	r3,52(r3)
8113eb98:	18c03fcc 	andi	r3,r3,255
8113eb9c:	e13ff917 	ldw	r4,-28(fp)
8113eba0:	20c7883a 	add	r3,r4,r3
8113eba4:	18c002c4 	addi	r3,r3,11
8113eba8:	19000003 	ldbu	r4,0(r3)
8113ebac:	e0fff717 	ldw	r3,-36(fp)
8113ebb0:	18c00d43 	ldbu	r3,53(r3)
8113ebb4:	20c6b03a 	or	r3,r4,r3
8113ebb8:	1809883a 	mov	r4,r3
8113ebbc:	e0fff917 	ldw	r3,-28(fp)
8113ebc0:	1885883a 	add	r2,r3,r2
8113ebc4:	108002c4 	addi	r2,r2,11
8113ebc8:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
8113ebcc:	e0fff303 	ldbu	r3,-52(fp)
8113ebd0:	00a045f4 	movhi	r2,33047
8113ebd4:	10ba6804 	addi	r2,r2,-5728
8113ebd8:	18c7883a 	add	r3,r3,r3
8113ebdc:	18c7883a 	add	r3,r3,r3
8113ebe0:	10c5883a 	add	r2,r2,r3
8113ebe4:	e0fff717 	ldw	r3,-36(fp)
8113ebe8:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
8113ebec:	d0a0a217 	ldw	r2,-32120(gp)
8113ebf0:	d0e0a217 	ldw	r3,-32120(gp)
8113ebf4:	18c00c03 	ldbu	r3,48(r3)
8113ebf8:	18c00414 	ori	r3,r3,16
8113ebfc:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113ec00:	d0a0a217 	ldw	r2,-32120(gp)
8113ec04:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
8113ec08:	d0a0a217 	ldw	r2,-32120(gp)
8113ec0c:	e0fffe0b 	ldhu	r3,-8(fp)
8113ec10:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113ec14:	e13ffd17 	ldw	r4,-12(fp)
8113ec18:	113af900 	call	8113af90 <OS_EventTaskWait>
8113ec1c:	e0bff117 	ldw	r2,-60(fp)
8113ec20:	e0bffb15 	stw	r2,-20(fp)
8113ec24:	e0bffb17 	ldw	r2,-20(fp)
8113ec28:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113ec2c:	113b8ac0 	call	8113b8ac <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ec30:	0005303a 	rdctl	r2,status
8113ec34:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ec38:	e0fff517 	ldw	r3,-44(fp)
8113ec3c:	00bfff84 	movi	r2,-2
8113ec40:	1884703a 	and	r2,r3,r2
8113ec44:	1001703a 	wrctl	status,r2
  
  return context;
8113ec48:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
8113ec4c:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113ec50:	d0a0a217 	ldw	r2,-32120(gp)
8113ec54:	10800c43 	ldbu	r2,49(r2)
8113ec58:	10803fcc 	andi	r2,r2,255
8113ec5c:	10000326 	beq	r2,zero,8113ec6c <OSMutexPend+0x51c>
8113ec60:	108000a0 	cmpeqi	r2,r2,2
8113ec64:	1000041e 	bne	r2,zero,8113ec78 <OSMutexPend+0x528>
8113ec68:	00000706 	br	8113ec88 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113ec6c:	e0bfff17 	ldw	r2,-4(fp)
8113ec70:	10000005 	stb	zero,0(r2)
             break;
8113ec74:	00000c06 	br	8113eca8 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
8113ec78:	e0bfff17 	ldw	r2,-4(fp)
8113ec7c:	00c00384 	movi	r3,14
8113ec80:	10c00005 	stb	r3,0(r2)
             break;
8113ec84:	00000806 	br	8113eca8 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113ec88:	d0a0a217 	ldw	r2,-32120(gp)
8113ec8c:	e17ffd17 	ldw	r5,-12(fp)
8113ec90:	1009883a 	mov	r4,r2
8113ec94:	113b2000 	call	8113b200 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
8113ec98:	e0bfff17 	ldw	r2,-4(fp)
8113ec9c:	00c00284 	movi	r3,10
8113eca0:	10c00005 	stb	r3,0(r2)
             break;
8113eca4:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113eca8:	d0a0a217 	ldw	r2,-32120(gp)
8113ecac:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113ecb0:	d0a0a217 	ldw	r2,-32120(gp)
8113ecb4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113ecb8:	d0a0a217 	ldw	r2,-32120(gp)
8113ecbc:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113ecc0:	d0a0a217 	ldw	r2,-32120(gp)
8113ecc4:	10000815 	stw	zero,32(r2)
8113ecc8:	e0bff117 	ldw	r2,-60(fp)
8113eccc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ecd0:	e0bffa17 	ldw	r2,-24(fp)
8113ecd4:	1001703a 	wrctl	status,r2
8113ecd8:	00000106 	br	8113ece0 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
8113ecdc:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113ece0:	e037883a 	mov	sp,fp
8113ece4:	dfc00117 	ldw	ra,4(sp)
8113ece8:	df000017 	ldw	fp,0(sp)
8113ecec:	dec00204 	addi	sp,sp,8
8113ecf0:	f800283a 	ret

8113ecf4 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
8113ecf4:	defff604 	addi	sp,sp,-40
8113ecf8:	de00012e 	bgeu	sp,et,8113ed00 <OSMutexPost+0xc>
8113ecfc:	003b68fa 	trap	3
8113ed00:	dfc00915 	stw	ra,36(sp)
8113ed04:	df000815 	stw	fp,32(sp)
8113ed08:	df000804 	addi	fp,sp,32
8113ed0c:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ed10:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113ed14:	d0a0a103 	ldbu	r2,-32124(gp)
8113ed18:	10803fcc 	andi	r2,r2,255
8113ed1c:	10000226 	beq	r2,zero,8113ed28 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
8113ed20:	00800144 	movi	r2,5
8113ed24:	00007606 	br	8113ef00 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ed28:	e0bfff17 	ldw	r2,-4(fp)
8113ed2c:	1000021e 	bne	r2,zero,8113ed38 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
8113ed30:	00800104 	movi	r2,4
8113ed34:	00007206 	br	8113ef00 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
8113ed38:	e0bfff17 	ldw	r2,-4(fp)
8113ed3c:	10800003 	ldbu	r2,0(r2)
8113ed40:	10803fcc 	andi	r2,r2,255
8113ed44:	10800120 	cmpeqi	r2,r2,4
8113ed48:	1000021e 	bne	r2,zero,8113ed54 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
8113ed4c:	00800044 	movi	r2,1
8113ed50:	00006b06 	br	8113ef00 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ed54:	0005303a 	rdctl	r2,status
8113ed58:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ed5c:	e0fffe17 	ldw	r3,-8(fp)
8113ed60:	00bfff84 	movi	r2,-2
8113ed64:	1884703a 	and	r2,r3,r2
8113ed68:	1001703a 	wrctl	status,r2
  
  return context;
8113ed6c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113ed70:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
8113ed74:	e0bfff17 	ldw	r2,-4(fp)
8113ed78:	1080020b 	ldhu	r2,8(r2)
8113ed7c:	10bfffcc 	andi	r2,r2,65535
8113ed80:	1004d23a 	srli	r2,r2,8
8113ed84:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
8113ed88:	e0bfff17 	ldw	r2,-4(fp)
8113ed8c:	1080020b 	ldhu	r2,8(r2)
8113ed90:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
8113ed94:	e0bfff17 	ldw	r2,-4(fp)
8113ed98:	10c00117 	ldw	r3,4(r2)
8113ed9c:	d0a0a217 	ldw	r2,-32120(gp)
8113eda0:	18800626 	beq	r3,r2,8113edbc <OSMutexPost+0xc8>
8113eda4:	e0bff817 	ldw	r2,-32(fp)
8113eda8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113edac:	e0bff917 	ldw	r2,-28(fp)
8113edb0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
8113edb4:	00801904 	movi	r2,100
8113edb8:	00005106 	br	8113ef00 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
8113edbc:	d0a0a217 	ldw	r2,-32120(gp)
8113edc0:	10800c83 	ldbu	r2,50(r2)
8113edc4:	10c03fcc 	andi	r3,r2,255
8113edc8:	e0bffa03 	ldbu	r2,-24(fp)
8113edcc:	1880051e 	bne	r3,r2,8113ede4 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
8113edd0:	d0a0a217 	ldw	r2,-32120(gp)
8113edd4:	e0fffa43 	ldbu	r3,-23(fp)
8113edd8:	180b883a 	mov	r5,r3
8113eddc:	1009883a 	mov	r4,r2
8113ede0:	113f0880 	call	8113f088 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
8113ede4:	e0fffa03 	ldbu	r3,-24(fp)
8113ede8:	00a045f4 	movhi	r2,33047
8113edec:	10ba6804 	addi	r2,r2,-5728
8113edf0:	18c7883a 	add	r3,r3,r3
8113edf4:	18c7883a 	add	r3,r3,r3
8113edf8:	10c5883a 	add	r2,r2,r3
8113edfc:	00c00044 	movi	r3,1
8113ee00:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
8113ee04:	e0bfff17 	ldw	r2,-4(fp)
8113ee08:	10800283 	ldbu	r2,10(r2)
8113ee0c:	10803fcc 	andi	r2,r2,255
8113ee10:	10002e26 	beq	r2,zero,8113eecc <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113ee14:	000f883a 	mov	r7,zero
8113ee18:	01800404 	movi	r6,16
8113ee1c:	000b883a 	mov	r5,zero
8113ee20:	e13fff17 	ldw	r4,-4(fp)
8113ee24:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
8113ee28:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
8113ee2c:	e0bfff17 	ldw	r2,-4(fp)
8113ee30:	10c0020b 	ldhu	r3,8(r2)
8113ee34:	00bfc004 	movi	r2,-256
8113ee38:	1884703a 	and	r2,r3,r2
8113ee3c:	1007883a 	mov	r3,r2
8113ee40:	e0bfff17 	ldw	r2,-4(fp)
8113ee44:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
8113ee48:	e0bfff17 	ldw	r2,-4(fp)
8113ee4c:	10c0020b 	ldhu	r3,8(r2)
8113ee50:	e0bffa43 	ldbu	r2,-23(fp)
8113ee54:	1884b03a 	or	r2,r3,r2
8113ee58:	1007883a 	mov	r3,r2
8113ee5c:	e0bfff17 	ldw	r2,-4(fp)
8113ee60:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
8113ee64:	e0fffa43 	ldbu	r3,-23(fp)
8113ee68:	00a045f4 	movhi	r2,33047
8113ee6c:	10ba6804 	addi	r2,r2,-5728
8113ee70:	18c7883a 	add	r3,r3,r3
8113ee74:	18c7883a 	add	r3,r3,r3
8113ee78:	10c5883a 	add	r2,r2,r3
8113ee7c:	10c00017 	ldw	r3,0(r2)
8113ee80:	e0bfff17 	ldw	r2,-4(fp)
8113ee84:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
8113ee88:	e0bffa43 	ldbu	r2,-23(fp)
8113ee8c:	e0fffa03 	ldbu	r3,-24(fp)
8113ee90:	18800736 	bltu	r3,r2,8113eeb0 <OSMutexPost+0x1bc>
8113ee94:	e0bff817 	ldw	r2,-32(fp)
8113ee98:	e0bffb15 	stw	r2,-20(fp)
8113ee9c:	e0bffb17 	ldw	r2,-20(fp)
8113eea0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113eea4:	113b8ac0 	call	8113b8ac <OS_Sched>
            return (OS_ERR_PIP_LOWER);
8113eea8:	00801e04 	movi	r2,120
8113eeac:	00001406 	br	8113ef00 <OSMutexPost+0x20c>
8113eeb0:	e0bff817 	ldw	r2,-32(fp)
8113eeb4:	e0bffc15 	stw	r2,-16(fp)
8113eeb8:	e0bffc17 	ldw	r2,-16(fp)
8113eebc:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113eec0:	113b8ac0 	call	8113b8ac <OS_Sched>
            return (OS_ERR_NONE);
8113eec4:	0005883a 	mov	r2,zero
8113eec8:	00000d06 	br	8113ef00 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
8113eecc:	e0bfff17 	ldw	r2,-4(fp)
8113eed0:	1080020b 	ldhu	r2,8(r2)
8113eed4:	10803fd4 	ori	r2,r2,255
8113eed8:	1007883a 	mov	r3,r2
8113eedc:	e0bfff17 	ldw	r2,-4(fp)
8113eee0:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
8113eee4:	e0bfff17 	ldw	r2,-4(fp)
8113eee8:	10000115 	stw	zero,4(r2)
8113eeec:	e0bff817 	ldw	r2,-32(fp)
8113eef0:	e0bffd15 	stw	r2,-12(fp)
8113eef4:	e0bffd17 	ldw	r2,-12(fp)
8113eef8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113eefc:	0005883a 	mov	r2,zero
}
8113ef00:	e037883a 	mov	sp,fp
8113ef04:	dfc00117 	ldw	ra,4(sp)
8113ef08:	df000017 	ldw	fp,0(sp)
8113ef0c:	dec00204 	addi	sp,sp,8
8113ef10:	f800283a 	ret

8113ef14 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
8113ef14:	defff704 	addi	sp,sp,-36
8113ef18:	de00012e 	bgeu	sp,et,8113ef20 <OSMutexQuery+0xc>
8113ef1c:	003b68fa 	trap	3
8113ef20:	df000815 	stw	fp,32(sp)
8113ef24:	df000804 	addi	fp,sp,32
8113ef28:	e13ffe15 	stw	r4,-8(fp)
8113ef2c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ef30:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113ef34:	d0a0a103 	ldbu	r2,-32124(gp)
8113ef38:	10803fcc 	andi	r2,r2,255
8113ef3c:	10000226 	beq	r2,zero,8113ef48 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
8113ef40:	00800184 	movi	r2,6
8113ef44:	00004c06 	br	8113f078 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113ef48:	e0bffe17 	ldw	r2,-8(fp)
8113ef4c:	1000021e 	bne	r2,zero,8113ef58 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
8113ef50:	00800104 	movi	r2,4
8113ef54:	00004806 	br	8113f078 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
8113ef58:	e0bfff17 	ldw	r2,-4(fp)
8113ef5c:	1000021e 	bne	r2,zero,8113ef68 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
8113ef60:	00800244 	movi	r2,9
8113ef64:	00004406 	br	8113f078 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113ef68:	e0bffe17 	ldw	r2,-8(fp)
8113ef6c:	10800003 	ldbu	r2,0(r2)
8113ef70:	10803fcc 	andi	r2,r2,255
8113ef74:	10800120 	cmpeqi	r2,r2,4
8113ef78:	1000021e 	bne	r2,zero,8113ef84 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
8113ef7c:	00800044 	movi	r2,1
8113ef80:	00003d06 	br	8113f078 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ef84:	0005303a 	rdctl	r2,status
8113ef88:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ef8c:	e0fffd17 	ldw	r3,-12(fp)
8113ef90:	00bfff84 	movi	r2,-2
8113ef94:	1884703a 	and	r2,r3,r2
8113ef98:	1001703a 	wrctl	status,r2
  
  return context;
8113ef9c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113efa0:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
8113efa4:	e0bffe17 	ldw	r2,-8(fp)
8113efa8:	1080020b 	ldhu	r2,8(r2)
8113efac:	10bfffcc 	andi	r2,r2,65535
8113efb0:	1004d23a 	srli	r2,r2,8
8113efb4:	1007883a 	mov	r3,r2
8113efb8:	e0bfff17 	ldw	r2,-4(fp)
8113efbc:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
8113efc0:	e0bffe17 	ldw	r2,-8(fp)
8113efc4:	1080020b 	ldhu	r2,8(r2)
8113efc8:	1007883a 	mov	r3,r2
8113efcc:	e0bfff17 	ldw	r2,-4(fp)
8113efd0:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
8113efd4:	e0bfff17 	ldw	r2,-4(fp)
8113efd8:	10800203 	ldbu	r2,8(r2)
8113efdc:	10803fcc 	andi	r2,r2,255
8113efe0:	10803fd8 	cmpnei	r2,r2,255
8113efe4:	1000041e 	bne	r2,zero,8113eff8 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
8113efe8:	e0bfff17 	ldw	r2,-4(fp)
8113efec:	00c00044 	movi	r3,1
8113eff0:	10c001c5 	stb	r3,7(r2)
8113eff4:	00000206 	br	8113f000 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
8113eff8:	e0bfff17 	ldw	r2,-4(fp)
8113effc:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
8113f000:	e0bffe17 	ldw	r2,-8(fp)
8113f004:	10c00283 	ldbu	r3,10(r2)
8113f008:	e0bfff17 	ldw	r2,-4(fp)
8113f00c:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
8113f010:	e0bffe17 	ldw	r2,-8(fp)
8113f014:	108002c4 	addi	r2,r2,11
8113f018:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
8113f01c:	e0bfff17 	ldw	r2,-4(fp)
8113f020:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113f024:	e03ff805 	stb	zero,-32(fp)
8113f028:	00000b06 	br	8113f058 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
8113f02c:	e0bffa17 	ldw	r2,-24(fp)
8113f030:	10c00044 	addi	r3,r2,1
8113f034:	e0fffa15 	stw	r3,-24(fp)
8113f038:	e0fff917 	ldw	r3,-28(fp)
8113f03c:	19000044 	addi	r4,r3,1
8113f040:	e13ff915 	stw	r4,-28(fp)
8113f044:	18c00003 	ldbu	r3,0(r3)
8113f048:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113f04c:	e0bff803 	ldbu	r2,-32(fp)
8113f050:	10800044 	addi	r2,r2,1
8113f054:	e0bff805 	stb	r2,-32(fp)
8113f058:	e0bff803 	ldbu	r2,-32(fp)
8113f05c:	108001b0 	cmpltui	r2,r2,6
8113f060:	103ff21e 	bne	r2,zero,8113f02c <__reset+0xfb11f02c>
8113f064:	e0bffb17 	ldw	r2,-20(fp)
8113f068:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f06c:	e0bffc17 	ldw	r2,-16(fp)
8113f070:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f074:	0005883a 	mov	r2,zero
}
8113f078:	e037883a 	mov	sp,fp
8113f07c:	df000017 	ldw	fp,0(sp)
8113f080:	dec00104 	addi	sp,sp,4
8113f084:	f800283a 	ret

8113f088 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
8113f088:	defffc04 	addi	sp,sp,-16
8113f08c:	de00012e 	bgeu	sp,et,8113f094 <OSMutex_RdyAtPrio+0xc>
8113f090:	003b68fa 	trap	3
8113f094:	df000315 	stw	fp,12(sp)
8113f098:	df000304 	addi	fp,sp,12
8113f09c:	e13ffe15 	stw	r4,-8(fp)
8113f0a0:	2805883a 	mov	r2,r5
8113f0a4:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
8113f0a8:	e0bffe17 	ldw	r2,-8(fp)
8113f0ac:	10800d03 	ldbu	r2,52(r2)
8113f0b0:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
8113f0b4:	e0fffd03 	ldbu	r3,-12(fp)
8113f0b8:	e13ffd03 	ldbu	r4,-12(fp)
8113f0bc:	d0a09e44 	addi	r2,gp,-32135
8113f0c0:	2085883a 	add	r2,r4,r2
8113f0c4:	10800003 	ldbu	r2,0(r2)
8113f0c8:	1009883a 	mov	r4,r2
8113f0cc:	e0bffe17 	ldw	r2,-8(fp)
8113f0d0:	10800d43 	ldbu	r2,53(r2)
8113f0d4:	0084303a 	nor	r2,zero,r2
8113f0d8:	2084703a 	and	r2,r4,r2
8113f0dc:	1009883a 	mov	r4,r2
8113f0e0:	d0a09e44 	addi	r2,gp,-32135
8113f0e4:	1885883a 	add	r2,r3,r2
8113f0e8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113f0ec:	e0fffd03 	ldbu	r3,-12(fp)
8113f0f0:	d0a09e44 	addi	r2,gp,-32135
8113f0f4:	1885883a 	add	r2,r3,r2
8113f0f8:	10800003 	ldbu	r2,0(r2)
8113f0fc:	10803fcc 	andi	r2,r2,255
8113f100:	1000071e 	bne	r2,zero,8113f120 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113f104:	e0bffe17 	ldw	r2,-8(fp)
8113f108:	10800d83 	ldbu	r2,54(r2)
8113f10c:	0084303a 	nor	r2,zero,r2
8113f110:	1007883a 	mov	r3,r2
8113f114:	d0a09e03 	ldbu	r2,-32136(gp)
8113f118:	1884703a 	and	r2,r3,r2
8113f11c:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBPrio         = prio;
8113f120:	e0bffe17 	ldw	r2,-8(fp)
8113f124:	e0ffff03 	ldbu	r3,-4(fp)
8113f128:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
8113f12c:	e0bfff03 	ldbu	r2,-4(fp)
8113f130:	1004d0fa 	srli	r2,r2,3
8113f134:	108001cc 	andi	r2,r2,7
8113f138:	1007883a 	mov	r3,r2
8113f13c:	e0bffe17 	ldw	r2,-8(fp)
8113f140:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
8113f144:	e0bfff03 	ldbu	r2,-4(fp)
8113f148:	108001cc 	andi	r2,r2,7
8113f14c:	1007883a 	mov	r3,r2
8113f150:	e0bffe17 	ldw	r2,-8(fp)
8113f154:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
8113f158:	e0bffe17 	ldw	r2,-8(fp)
8113f15c:	10800d03 	ldbu	r2,52(r2)
8113f160:	10803fcc 	andi	r2,r2,255
8113f164:	00c00044 	movi	r3,1
8113f168:	1884983a 	sll	r2,r3,r2
8113f16c:	1007883a 	mov	r3,r2
8113f170:	e0bffe17 	ldw	r2,-8(fp)
8113f174:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
8113f178:	e0bffe17 	ldw	r2,-8(fp)
8113f17c:	10800cc3 	ldbu	r2,51(r2)
8113f180:	10803fcc 	andi	r2,r2,255
8113f184:	00c00044 	movi	r3,1
8113f188:	1884983a 	sll	r2,r3,r2
8113f18c:	1007883a 	mov	r3,r2
8113f190:	e0bffe17 	ldw	r2,-8(fp)
8113f194:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
8113f198:	e0bffe17 	ldw	r2,-8(fp)
8113f19c:	10c00d83 	ldbu	r3,54(r2)
8113f1a0:	d0a09e03 	ldbu	r2,-32136(gp)
8113f1a4:	1884b03a 	or	r2,r3,r2
8113f1a8:	d0a09e05 	stb	r2,-32136(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113f1ac:	e0bffe17 	ldw	r2,-8(fp)
8113f1b0:	10800d03 	ldbu	r2,52(r2)
8113f1b4:	10c03fcc 	andi	r3,r2,255
8113f1b8:	e0bffe17 	ldw	r2,-8(fp)
8113f1bc:	10800d03 	ldbu	r2,52(r2)
8113f1c0:	11003fcc 	andi	r4,r2,255
8113f1c4:	d0a09e44 	addi	r2,gp,-32135
8113f1c8:	2085883a 	add	r2,r4,r2
8113f1cc:	11000003 	ldbu	r4,0(r2)
8113f1d0:	e0bffe17 	ldw	r2,-8(fp)
8113f1d4:	10800d43 	ldbu	r2,53(r2)
8113f1d8:	2084b03a 	or	r2,r4,r2
8113f1dc:	1009883a 	mov	r4,r2
8113f1e0:	d0a09e44 	addi	r2,gp,-32135
8113f1e4:	1885883a 	add	r2,r3,r2
8113f1e8:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
8113f1ec:	e0ffff03 	ldbu	r3,-4(fp)
8113f1f0:	00a045f4 	movhi	r2,33047
8113f1f4:	10ba6804 	addi	r2,r2,-5728
8113f1f8:	18c7883a 	add	r3,r3,r3
8113f1fc:	18c7883a 	add	r3,r3,r3
8113f200:	10c5883a 	add	r2,r2,r3
8113f204:	e0fffe17 	ldw	r3,-8(fp)
8113f208:	10c00015 	stw	r3,0(r2)
}
8113f20c:	0001883a 	nop
8113f210:	e037883a 	mov	sp,fp
8113f214:	df000017 	ldw	fp,0(sp)
8113f218:	dec00104 	addi	sp,sp,4
8113f21c:	f800283a 	ret

8113f220 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8113f220:	defff804 	addi	sp,sp,-32
8113f224:	de00012e 	bgeu	sp,et,8113f22c <OSQAccept+0xc>
8113f228:	003b68fa 	trap	3
8113f22c:	df000715 	stw	fp,28(sp)
8113f230:	df000704 	addi	fp,sp,28
8113f234:	e13ffe15 	stw	r4,-8(fp)
8113f238:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113f23c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113f240:	e0bfff17 	ldw	r2,-4(fp)
8113f244:	1000021e 	bne	r2,zero,8113f250 <OSQAccept+0x30>
        return ((void *)0);
8113f248:	0005883a 	mov	r2,zero
8113f24c:	00004206 	br	8113f358 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113f250:	e0bffe17 	ldw	r2,-8(fp)
8113f254:	1000051e 	bne	r2,zero,8113f26c <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113f258:	e0bfff17 	ldw	r2,-4(fp)
8113f25c:	00c00104 	movi	r3,4
8113f260:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113f264:	0005883a 	mov	r2,zero
8113f268:	00003b06 	br	8113f358 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113f26c:	e0bffe17 	ldw	r2,-8(fp)
8113f270:	10800003 	ldbu	r2,0(r2)
8113f274:	10803fcc 	andi	r2,r2,255
8113f278:	108000a0 	cmpeqi	r2,r2,2
8113f27c:	1000051e 	bne	r2,zero,8113f294 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113f280:	e0bfff17 	ldw	r2,-4(fp)
8113f284:	00c00044 	movi	r3,1
8113f288:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113f28c:	0005883a 	mov	r2,zero
8113f290:	00003106 	br	8113f358 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f294:	0005303a 	rdctl	r2,status
8113f298:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f29c:	e0fffd17 	ldw	r3,-12(fp)
8113f2a0:	00bfff84 	movi	r2,-2
8113f2a4:	1884703a 	and	r2,r3,r2
8113f2a8:	1001703a 	wrctl	status,r2
  
  return context;
8113f2ac:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113f2b0:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113f2b4:	e0bffe17 	ldw	r2,-8(fp)
8113f2b8:	10800117 	ldw	r2,4(r2)
8113f2bc:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113f2c0:	e0bffc17 	ldw	r2,-16(fp)
8113f2c4:	1080058b 	ldhu	r2,22(r2)
8113f2c8:	10bfffcc 	andi	r2,r2,65535
8113f2cc:	10001926 	beq	r2,zero,8113f334 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113f2d0:	e0bffc17 	ldw	r2,-16(fp)
8113f2d4:	10800417 	ldw	r2,16(r2)
8113f2d8:	11000104 	addi	r4,r2,4
8113f2dc:	e0fffc17 	ldw	r3,-16(fp)
8113f2e0:	19000415 	stw	r4,16(r3)
8113f2e4:	10800017 	ldw	r2,0(r2)
8113f2e8:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113f2ec:	e0bffc17 	ldw	r2,-16(fp)
8113f2f0:	1080058b 	ldhu	r2,22(r2)
8113f2f4:	10bfffc4 	addi	r2,r2,-1
8113f2f8:	1007883a 	mov	r3,r2
8113f2fc:	e0bffc17 	ldw	r2,-16(fp)
8113f300:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113f304:	e0bffc17 	ldw	r2,-16(fp)
8113f308:	10c00417 	ldw	r3,16(r2)
8113f30c:	e0bffc17 	ldw	r2,-16(fp)
8113f310:	10800217 	ldw	r2,8(r2)
8113f314:	1880041e 	bne	r3,r2,8113f328 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
8113f318:	e0bffc17 	ldw	r2,-16(fp)
8113f31c:	10c00117 	ldw	r3,4(r2)
8113f320:	e0bffc17 	ldw	r2,-16(fp)
8113f324:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
8113f328:	e0bfff17 	ldw	r2,-4(fp)
8113f32c:	10000005 	stb	zero,0(r2)
8113f330:	00000406 	br	8113f344 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
8113f334:	e0bfff17 	ldw	r2,-4(fp)
8113f338:	00c007c4 	movi	r3,31
8113f33c:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8113f340:	e03ff915 	stw	zero,-28(fp)
8113f344:	e0bffa17 	ldw	r2,-24(fp)
8113f348:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f34c:	e0bffb17 	ldw	r2,-20(fp)
8113f350:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
8113f354:	e0bff917 	ldw	r2,-28(fp)
}
8113f358:	e037883a 	mov	sp,fp
8113f35c:	df000017 	ldw	fp,0(sp)
8113f360:	dec00104 	addi	sp,sp,4
8113f364:	f800283a 	ret

8113f368 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
8113f368:	defff404 	addi	sp,sp,-48
8113f36c:	de00012e 	bgeu	sp,et,8113f374 <OSQCreate+0xc>
8113f370:	003b68fa 	trap	3
8113f374:	dfc00b15 	stw	ra,44(sp)
8113f378:	df000a15 	stw	fp,40(sp)
8113f37c:	df000a04 	addi	fp,sp,40
8113f380:	e13ffe15 	stw	r4,-8(fp)
8113f384:	2805883a 	mov	r2,r5
8113f388:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113f38c:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113f390:	d0a0a103 	ldbu	r2,-32124(gp)
8113f394:	10803fcc 	andi	r2,r2,255
8113f398:	10000226 	beq	r2,zero,8113f3a4 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
8113f39c:	0005883a 	mov	r2,zero
8113f3a0:	00005906 	br	8113f508 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f3a4:	0005303a 	rdctl	r2,status
8113f3a8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f3ac:	e0fffd17 	ldw	r3,-12(fp)
8113f3b0:	00bfff84 	movi	r2,-2
8113f3b4:	1884703a 	and	r2,r3,r2
8113f3b8:	1001703a 	wrctl	status,r2
  
  return context;
8113f3bc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113f3c0:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
8113f3c4:	d0a0a017 	ldw	r2,-32128(gp)
8113f3c8:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
8113f3cc:	d0a0a017 	ldw	r2,-32128(gp)
8113f3d0:	10000326 	beq	r2,zero,8113f3e0 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113f3d4:	d0a0a017 	ldw	r2,-32128(gp)
8113f3d8:	10800117 	ldw	r2,4(r2)
8113f3dc:	d0a0a015 	stw	r2,-32128(gp)
8113f3e0:	e0bff717 	ldw	r2,-36(fp)
8113f3e4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f3e8:	e0bff817 	ldw	r2,-32(fp)
8113f3ec:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113f3f0:	e0bff617 	ldw	r2,-40(fp)
8113f3f4:	10004326 	beq	r2,zero,8113f504 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f3f8:	0005303a 	rdctl	r2,status
8113f3fc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f400:	e0fff917 	ldw	r3,-28(fp)
8113f404:	00bfff84 	movi	r2,-2
8113f408:	1884703a 	and	r2,r3,r2
8113f40c:	1001703a 	wrctl	status,r2
  
  return context;
8113f410:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
8113f414:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
8113f418:	d0a09d17 	ldw	r2,-32140(gp)
8113f41c:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8113f420:	e0bffb17 	ldw	r2,-20(fp)
8113f424:	10002d26 	beq	r2,zero,8113f4dc <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
8113f428:	d0a09d17 	ldw	r2,-32140(gp)
8113f42c:	10800017 	ldw	r2,0(r2)
8113f430:	d0a09d15 	stw	r2,-32140(gp)
8113f434:	e0bff717 	ldw	r2,-36(fp)
8113f438:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f43c:	e0bffa17 	ldw	r2,-24(fp)
8113f440:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
8113f444:	e0bffb17 	ldw	r2,-20(fp)
8113f448:	e0fffe17 	ldw	r3,-8(fp)
8113f44c:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8113f450:	e0bfff0b 	ldhu	r2,-4(fp)
8113f454:	1085883a 	add	r2,r2,r2
8113f458:	1085883a 	add	r2,r2,r2
8113f45c:	1007883a 	mov	r3,r2
8113f460:	e0bffe17 	ldw	r2,-8(fp)
8113f464:	10c7883a 	add	r3,r2,r3
8113f468:	e0bffb17 	ldw	r2,-20(fp)
8113f46c:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8113f470:	e0bffb17 	ldw	r2,-20(fp)
8113f474:	e0fffe17 	ldw	r3,-8(fp)
8113f478:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8113f47c:	e0bffb17 	ldw	r2,-20(fp)
8113f480:	e0fffe17 	ldw	r3,-8(fp)
8113f484:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
8113f488:	e0bffb17 	ldw	r2,-20(fp)
8113f48c:	e0ffff0b 	ldhu	r3,-4(fp)
8113f490:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
8113f494:	e0bffb17 	ldw	r2,-20(fp)
8113f498:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
8113f49c:	e0bff617 	ldw	r2,-40(fp)
8113f4a0:	00c00084 	movi	r3,2
8113f4a4:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
8113f4a8:	e0bff617 	ldw	r2,-40(fp)
8113f4ac:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
8113f4b0:	e0bff617 	ldw	r2,-40(fp)
8113f4b4:	e0fffb17 	ldw	r3,-20(fp)
8113f4b8:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
8113f4bc:	e0bff617 	ldw	r2,-40(fp)
8113f4c0:	00c00fc4 	movi	r3,63
8113f4c4:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
8113f4c8:	e0bff617 	ldw	r2,-40(fp)
8113f4cc:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
8113f4d0:	e13ff617 	ldw	r4,-40(fp)
8113f4d4:	113b3c80 	call	8113b3c8 <OS_EventWaitListInit>
8113f4d8:	00000a06 	br	8113f504 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
8113f4dc:	d0e0a017 	ldw	r3,-32128(gp)
8113f4e0:	e0bff617 	ldw	r2,-40(fp)
8113f4e4:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
8113f4e8:	e0bff617 	ldw	r2,-40(fp)
8113f4ec:	d0a0a015 	stw	r2,-32128(gp)
8113f4f0:	e0bff717 	ldw	r2,-36(fp)
8113f4f4:	e0bffc15 	stw	r2,-16(fp)
8113f4f8:	e0bffc17 	ldw	r2,-16(fp)
8113f4fc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8113f500:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
8113f504:	e0bff617 	ldw	r2,-40(fp)
}
8113f508:	e037883a 	mov	sp,fp
8113f50c:	dfc00117 	ldw	ra,4(sp)
8113f510:	df000017 	ldw	fp,0(sp)
8113f514:	dec00204 	addi	sp,sp,8
8113f518:	f800283a 	ret

8113f51c <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113f51c:	defff204 	addi	sp,sp,-56
8113f520:	de00012e 	bgeu	sp,et,8113f528 <OSQDel+0xc>
8113f524:	003b68fa 	trap	3
8113f528:	dfc00d15 	stw	ra,52(sp)
8113f52c:	df000c15 	stw	fp,48(sp)
8113f530:	df000c04 	addi	fp,sp,48
8113f534:	e13ffd15 	stw	r4,-12(fp)
8113f538:	2805883a 	mov	r2,r5
8113f53c:	e1bfff15 	stw	r6,-4(fp)
8113f540:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113f544:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113f548:	e0bfff17 	ldw	r2,-4(fp)
8113f54c:	1000021e 	bne	r2,zero,8113f558 <OSQDel+0x3c>
        return (pevent);
8113f550:	e0bffd17 	ldw	r2,-12(fp)
8113f554:	00008e06 	br	8113f790 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113f558:	e0bffd17 	ldw	r2,-12(fp)
8113f55c:	1000051e 	bne	r2,zero,8113f574 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113f560:	e0bfff17 	ldw	r2,-4(fp)
8113f564:	00c00104 	movi	r3,4
8113f568:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113f56c:	e0bffd17 	ldw	r2,-12(fp)
8113f570:	00008706 	br	8113f790 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113f574:	e0bffd17 	ldw	r2,-12(fp)
8113f578:	10800003 	ldbu	r2,0(r2)
8113f57c:	10803fcc 	andi	r2,r2,255
8113f580:	108000a0 	cmpeqi	r2,r2,2
8113f584:	1000051e 	bne	r2,zero,8113f59c <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113f588:	e0bfff17 	ldw	r2,-4(fp)
8113f58c:	00c00044 	movi	r3,1
8113f590:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113f594:	e0bffd17 	ldw	r2,-12(fp)
8113f598:	00007d06 	br	8113f790 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113f59c:	d0a0a103 	ldbu	r2,-32124(gp)
8113f5a0:	10803fcc 	andi	r2,r2,255
8113f5a4:	10000526 	beq	r2,zero,8113f5bc <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113f5a8:	e0bfff17 	ldw	r2,-4(fp)
8113f5ac:	00c003c4 	movi	r3,15
8113f5b0:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113f5b4:	e0bffd17 	ldw	r2,-12(fp)
8113f5b8:	00007506 	br	8113f790 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f5bc:	0005303a 	rdctl	r2,status
8113f5c0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f5c4:	e0fffc17 	ldw	r3,-16(fp)
8113f5c8:	00bfff84 	movi	r2,-2
8113f5cc:	1884703a 	and	r2,r3,r2
8113f5d0:	1001703a 	wrctl	status,r2
  
  return context;
8113f5d4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113f5d8:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
8113f5dc:	e0bffd17 	ldw	r2,-12(fp)
8113f5e0:	10800283 	ldbu	r2,10(r2)
8113f5e4:	10803fcc 	andi	r2,r2,255
8113f5e8:	10000326 	beq	r2,zero,8113f5f8 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113f5ec:	00800044 	movi	r2,1
8113f5f0:	e0bff405 	stb	r2,-48(fp)
8113f5f4:	00000106 	br	8113f5fc <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113f5f8:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113f5fc:	e0bffe03 	ldbu	r2,-8(fp)
8113f600:	10000326 	beq	r2,zero,8113f610 <OSQDel+0xf4>
8113f604:	10800060 	cmpeqi	r2,r2,1
8113f608:	1000301e 	bne	r2,zero,8113f6cc <OSQDel+0x1b0>
8113f60c:	00005506 	br	8113f764 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
8113f610:	e0bff403 	ldbu	r2,-48(fp)
8113f614:	10001e1e 	bne	r2,zero,8113f690 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113f618:	e0bffd17 	ldw	r2,-12(fp)
8113f61c:	00c00fc4 	movi	r3,63
8113f620:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113f624:	e0bffd17 	ldw	r2,-12(fp)
8113f628:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8113f62c:	e0bffd17 	ldw	r2,-12(fp)
8113f630:	10800117 	ldw	r2,4(r2)
8113f634:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
8113f638:	d0e09d17 	ldw	r3,-32140(gp)
8113f63c:	e0bff817 	ldw	r2,-32(fp)
8113f640:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
8113f644:	e0bff817 	ldw	r2,-32(fp)
8113f648:	d0a09d15 	stw	r2,-32140(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113f64c:	e0bffd17 	ldw	r2,-12(fp)
8113f650:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113f654:	d0e0a017 	ldw	r3,-32128(gp)
8113f658:	e0bffd17 	ldw	r2,-12(fp)
8113f65c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113f660:	e0bffd17 	ldw	r2,-12(fp)
8113f664:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113f668:	e0bffd17 	ldw	r2,-12(fp)
8113f66c:	d0a0a015 	stw	r2,-32128(gp)
8113f670:	e0bff617 	ldw	r2,-40(fp)
8113f674:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f678:	e0bff717 	ldw	r2,-36(fp)
8113f67c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113f680:	e0bfff17 	ldw	r2,-4(fp)
8113f684:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
8113f688:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113f68c:	00003f06 	br	8113f78c <OSQDel+0x270>
8113f690:	e0bff617 	ldw	r2,-40(fp)
8113f694:	e0bff915 	stw	r2,-28(fp)
8113f698:	e0bff917 	ldw	r2,-28(fp)
8113f69c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113f6a0:	e0bfff17 	ldw	r2,-4(fp)
8113f6a4:	00c01244 	movi	r3,73
8113f6a8:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113f6ac:	e0bffd17 	ldw	r2,-12(fp)
8113f6b0:	e0bff515 	stw	r2,-44(fp)
             }
             break;
8113f6b4:	00003506 	br	8113f78c <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
8113f6b8:	000f883a 	mov	r7,zero
8113f6bc:	01800104 	movi	r6,4
8113f6c0:	000b883a 	mov	r5,zero
8113f6c4:	e13ffd17 	ldw	r4,-12(fp)
8113f6c8:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
8113f6cc:	e0bffd17 	ldw	r2,-12(fp)
8113f6d0:	10800283 	ldbu	r2,10(r2)
8113f6d4:	10803fcc 	andi	r2,r2,255
8113f6d8:	103ff71e 	bne	r2,zero,8113f6b8 <__reset+0xfb11f6b8>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113f6dc:	e0bffd17 	ldw	r2,-12(fp)
8113f6e0:	00c00fc4 	movi	r3,63
8113f6e4:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113f6e8:	e0bffd17 	ldw	r2,-12(fp)
8113f6ec:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8113f6f0:	e0bffd17 	ldw	r2,-12(fp)
8113f6f4:	10800117 	ldw	r2,4(r2)
8113f6f8:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
8113f6fc:	d0e09d17 	ldw	r3,-32140(gp)
8113f700:	e0bff817 	ldw	r2,-32(fp)
8113f704:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
8113f708:	e0bff817 	ldw	r2,-32(fp)
8113f70c:	d0a09d15 	stw	r2,-32140(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113f710:	e0bffd17 	ldw	r2,-12(fp)
8113f714:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113f718:	d0e0a017 	ldw	r3,-32128(gp)
8113f71c:	e0bffd17 	ldw	r2,-12(fp)
8113f720:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113f724:	e0bffd17 	ldw	r2,-12(fp)
8113f728:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113f72c:	e0bffd17 	ldw	r2,-12(fp)
8113f730:	d0a0a015 	stw	r2,-32128(gp)
8113f734:	e0bff617 	ldw	r2,-40(fp)
8113f738:	e0bffa15 	stw	r2,-24(fp)
8113f73c:	e0bffa17 	ldw	r2,-24(fp)
8113f740:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113f744:	e0bff403 	ldbu	r2,-48(fp)
8113f748:	10800058 	cmpnei	r2,r2,1
8113f74c:	1000011e 	bne	r2,zero,8113f754 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113f750:	113b8ac0 	call	8113b8ac <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113f754:	e0bfff17 	ldw	r2,-4(fp)
8113f758:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
8113f75c:	e03ff515 	stw	zero,-44(fp)
             break;
8113f760:	00000a06 	br	8113f78c <OSQDel+0x270>
8113f764:	e0bff617 	ldw	r2,-40(fp)
8113f768:	e0bffb15 	stw	r2,-20(fp)
8113f76c:	e0bffb17 	ldw	r2,-20(fp)
8113f770:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113f774:	e0bfff17 	ldw	r2,-4(fp)
8113f778:	00c001c4 	movi	r3,7
8113f77c:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113f780:	e0bffd17 	ldw	r2,-12(fp)
8113f784:	e0bff515 	stw	r2,-44(fp)
             break;
8113f788:	0001883a 	nop
    }
    return (pevent_return);
8113f78c:	e0bff517 	ldw	r2,-44(fp)
}
8113f790:	e037883a 	mov	sp,fp
8113f794:	dfc00117 	ldw	ra,4(sp)
8113f798:	df000017 	ldw	fp,0(sp)
8113f79c:	dec00204 	addi	sp,sp,8
8113f7a0:	f800283a 	ret

8113f7a4 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
8113f7a4:	defffa04 	addi	sp,sp,-24
8113f7a8:	de00012e 	bgeu	sp,et,8113f7b0 <OSQFlush+0xc>
8113f7ac:	003b68fa 	trap	3
8113f7b0:	df000515 	stw	fp,20(sp)
8113f7b4:	df000504 	addi	fp,sp,20
8113f7b8:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113f7bc:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113f7c0:	e0bfff17 	ldw	r2,-4(fp)
8113f7c4:	1000021e 	bne	r2,zero,8113f7d0 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
8113f7c8:	00800104 	movi	r2,4
8113f7cc:	00002106 	br	8113f854 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113f7d0:	e0bfff17 	ldw	r2,-4(fp)
8113f7d4:	10800003 	ldbu	r2,0(r2)
8113f7d8:	10803fcc 	andi	r2,r2,255
8113f7dc:	108000a0 	cmpeqi	r2,r2,2
8113f7e0:	1000021e 	bne	r2,zero,8113f7ec <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
8113f7e4:	00800044 	movi	r2,1
8113f7e8:	00001a06 	br	8113f854 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f7ec:	0005303a 	rdctl	r2,status
8113f7f0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f7f4:	e0fffd17 	ldw	r3,-12(fp)
8113f7f8:	00bfff84 	movi	r2,-2
8113f7fc:	1884703a 	and	r2,r3,r2
8113f800:	1001703a 	wrctl	status,r2
  
  return context;
8113f804:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113f808:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
8113f80c:	e0bfff17 	ldw	r2,-4(fp)
8113f810:	10800117 	ldw	r2,4(r2)
8113f814:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
8113f818:	e0bffc17 	ldw	r2,-16(fp)
8113f81c:	10c00117 	ldw	r3,4(r2)
8113f820:	e0bffc17 	ldw	r2,-16(fp)
8113f824:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
8113f828:	e0bffc17 	ldw	r2,-16(fp)
8113f82c:	10c00117 	ldw	r3,4(r2)
8113f830:	e0bffc17 	ldw	r2,-16(fp)
8113f834:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
8113f838:	e0bffc17 	ldw	r2,-16(fp)
8113f83c:	1000058d 	sth	zero,22(r2)
8113f840:	e0bffb17 	ldw	r2,-20(fp)
8113f844:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f848:	e0bffe17 	ldw	r2,-8(fp)
8113f84c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f850:	0005883a 	mov	r2,zero
}
8113f854:	e037883a 	mov	sp,fp
8113f858:	df000017 	ldw	fp,0(sp)
8113f85c:	dec00104 	addi	sp,sp,4
8113f860:	f800283a 	ret

8113f864 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113f864:	defff304 	addi	sp,sp,-52
8113f868:	de00012e 	bgeu	sp,et,8113f870 <OSQPend+0xc>
8113f86c:	003b68fa 	trap	3
8113f870:	dfc00c15 	stw	ra,48(sp)
8113f874:	df000b15 	stw	fp,44(sp)
8113f878:	df000b04 	addi	fp,sp,44
8113f87c:	e13ffd15 	stw	r4,-12(fp)
8113f880:	2805883a 	mov	r2,r5
8113f884:	e1bfff15 	stw	r6,-4(fp)
8113f888:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113f88c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113f890:	e0bfff17 	ldw	r2,-4(fp)
8113f894:	1000021e 	bne	r2,zero,8113f8a0 <OSQPend+0x3c>
        return ((void *)0);
8113f898:	0005883a 	mov	r2,zero
8113f89c:	00009106 	br	8113fae4 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113f8a0:	e0bffd17 	ldw	r2,-12(fp)
8113f8a4:	1000051e 	bne	r2,zero,8113f8bc <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113f8a8:	e0bfff17 	ldw	r2,-4(fp)
8113f8ac:	00c00104 	movi	r3,4
8113f8b0:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113f8b4:	0005883a 	mov	r2,zero
8113f8b8:	00008a06 	br	8113fae4 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113f8bc:	e0bffd17 	ldw	r2,-12(fp)
8113f8c0:	10800003 	ldbu	r2,0(r2)
8113f8c4:	10803fcc 	andi	r2,r2,255
8113f8c8:	108000a0 	cmpeqi	r2,r2,2
8113f8cc:	1000051e 	bne	r2,zero,8113f8e4 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113f8d0:	e0bfff17 	ldw	r2,-4(fp)
8113f8d4:	00c00044 	movi	r3,1
8113f8d8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113f8dc:	0005883a 	mov	r2,zero
8113f8e0:	00008006 	br	8113fae4 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113f8e4:	d0a0a103 	ldbu	r2,-32124(gp)
8113f8e8:	10803fcc 	andi	r2,r2,255
8113f8ec:	10000526 	beq	r2,zero,8113f904 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8113f8f0:	e0bfff17 	ldw	r2,-4(fp)
8113f8f4:	00c00084 	movi	r3,2
8113f8f8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113f8fc:	0005883a 	mov	r2,zero
8113f900:	00007806 	br	8113fae4 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
8113f904:	d0a08f03 	ldbu	r2,-32196(gp)
8113f908:	10803fcc 	andi	r2,r2,255
8113f90c:	10000526 	beq	r2,zero,8113f924 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
8113f910:	e0bfff17 	ldw	r2,-4(fp)
8113f914:	00c00344 	movi	r3,13
8113f918:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113f91c:	0005883a 	mov	r2,zero
8113f920:	00007006 	br	8113fae4 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f924:	0005303a 	rdctl	r2,status
8113f928:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f92c:	e0fffc17 	ldw	r3,-16(fp)
8113f930:	00bfff84 	movi	r2,-2
8113f934:	1884703a 	and	r2,r3,r2
8113f938:	1001703a 	wrctl	status,r2
  
  return context;
8113f93c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113f940:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113f944:	e0bffd17 	ldw	r2,-12(fp)
8113f948:	10800117 	ldw	r2,4(r2)
8113f94c:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113f950:	e0bff817 	ldw	r2,-32(fp)
8113f954:	1080058b 	ldhu	r2,22(r2)
8113f958:	10bfffcc 	andi	r2,r2,65535
8113f95c:	10001e26 	beq	r2,zero,8113f9d8 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113f960:	e0bff817 	ldw	r2,-32(fp)
8113f964:	10800417 	ldw	r2,16(r2)
8113f968:	11000104 	addi	r4,r2,4
8113f96c:	e0fff817 	ldw	r3,-32(fp)
8113f970:	19000415 	stw	r4,16(r3)
8113f974:	10800017 	ldw	r2,0(r2)
8113f978:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113f97c:	e0bff817 	ldw	r2,-32(fp)
8113f980:	1080058b 	ldhu	r2,22(r2)
8113f984:	10bfffc4 	addi	r2,r2,-1
8113f988:	1007883a 	mov	r3,r2
8113f98c:	e0bff817 	ldw	r2,-32(fp)
8113f990:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113f994:	e0bff817 	ldw	r2,-32(fp)
8113f998:	10c00417 	ldw	r3,16(r2)
8113f99c:	e0bff817 	ldw	r2,-32(fp)
8113f9a0:	10800217 	ldw	r2,8(r2)
8113f9a4:	1880041e 	bne	r3,r2,8113f9b8 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
8113f9a8:	e0bff817 	ldw	r2,-32(fp)
8113f9ac:	10c00117 	ldw	r3,4(r2)
8113f9b0:	e0bff817 	ldw	r2,-32(fp)
8113f9b4:	10c00415 	stw	r3,16(r2)
8113f9b8:	e0bff617 	ldw	r2,-40(fp)
8113f9bc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f9c0:	e0bff717 	ldw	r2,-36(fp)
8113f9c4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113f9c8:	e0bfff17 	ldw	r2,-4(fp)
8113f9cc:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
8113f9d0:	e0bff517 	ldw	r2,-44(fp)
8113f9d4:	00004306 	br	8113fae4 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
8113f9d8:	d0a0a217 	ldw	r2,-32120(gp)
8113f9dc:	d0e0a217 	ldw	r3,-32120(gp)
8113f9e0:	18c00c03 	ldbu	r3,48(r3)
8113f9e4:	18c00114 	ori	r3,r3,4
8113f9e8:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113f9ec:	d0a0a217 	ldw	r2,-32120(gp)
8113f9f0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
8113f9f4:	d0a0a217 	ldw	r2,-32120(gp)
8113f9f8:	e0fffe0b 	ldhu	r3,-8(fp)
8113f9fc:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8113fa00:	e13ffd17 	ldw	r4,-12(fp)
8113fa04:	113af900 	call	8113af90 <OS_EventTaskWait>
8113fa08:	e0bff617 	ldw	r2,-40(fp)
8113fa0c:	e0bffb15 	stw	r2,-20(fp)
8113fa10:	e0bffb17 	ldw	r2,-20(fp)
8113fa14:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
8113fa18:	113b8ac0 	call	8113b8ac <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fa1c:	0005303a 	rdctl	r2,status
8113fa20:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fa24:	e0fff917 	ldw	r3,-28(fp)
8113fa28:	00bfff84 	movi	r2,-2
8113fa2c:	1884703a 	and	r2,r3,r2
8113fa30:	1001703a 	wrctl	status,r2
  
  return context;
8113fa34:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113fa38:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113fa3c:	d0a0a217 	ldw	r2,-32120(gp)
8113fa40:	10800c43 	ldbu	r2,49(r2)
8113fa44:	10803fcc 	andi	r2,r2,255
8113fa48:	10000326 	beq	r2,zero,8113fa58 <OSQPend+0x1f4>
8113fa4c:	108000a0 	cmpeqi	r2,r2,2
8113fa50:	1000071e 	bne	r2,zero,8113fa70 <OSQPend+0x20c>
8113fa54:	00000b06 	br	8113fa84 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
8113fa58:	d0a0a217 	ldw	r2,-32120(gp)
8113fa5c:	10800917 	ldw	r2,36(r2)
8113fa60:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
8113fa64:	e0bfff17 	ldw	r2,-4(fp)
8113fa68:	10000005 	stb	zero,0(r2)
             break;
8113fa6c:	00000e06 	br	8113faa8 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113fa70:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113fa74:	e0bfff17 	ldw	r2,-4(fp)
8113fa78:	00c00384 	movi	r3,14
8113fa7c:	10c00005 	stb	r3,0(r2)
             break;
8113fa80:	00000906 	br	8113faa8 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113fa84:	d0a0a217 	ldw	r2,-32120(gp)
8113fa88:	e17ffd17 	ldw	r5,-12(fp)
8113fa8c:	1009883a 	mov	r4,r2
8113fa90:	113b2000 	call	8113b200 <OS_EventTaskRemove>
             pmsg = (void *)0;
8113fa94:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113fa98:	e0bfff17 	ldw	r2,-4(fp)
8113fa9c:	00c00284 	movi	r3,10
8113faa0:	10c00005 	stb	r3,0(r2)
             break;
8113faa4:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113faa8:	d0a0a217 	ldw	r2,-32120(gp)
8113faac:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113fab0:	d0a0a217 	ldw	r2,-32120(gp)
8113fab4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113fab8:	d0a0a217 	ldw	r2,-32120(gp)
8113fabc:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113fac0:	d0a0a217 	ldw	r2,-32120(gp)
8113fac4:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
8113fac8:	d0a0a217 	ldw	r2,-32120(gp)
8113facc:	10000915 	stw	zero,36(r2)
8113fad0:	e0bff617 	ldw	r2,-40(fp)
8113fad4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fad8:	e0bffa17 	ldw	r2,-24(fp)
8113fadc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8113fae0:	e0bff517 	ldw	r2,-44(fp)
}
8113fae4:	e037883a 	mov	sp,fp
8113fae8:	dfc00117 	ldw	ra,4(sp)
8113faec:	df000017 	ldw	fp,0(sp)
8113faf0:	dec00204 	addi	sp,sp,8
8113faf4:	f800283a 	ret

8113faf8 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113faf8:	defff604 	addi	sp,sp,-40
8113fafc:	de00012e 	bgeu	sp,et,8113fb04 <OSQPendAbort+0xc>
8113fb00:	003b68fa 	trap	3
8113fb04:	dfc00915 	stw	ra,36(sp)
8113fb08:	df000815 	stw	fp,32(sp)
8113fb0c:	df000804 	addi	fp,sp,32
8113fb10:	e13ffd15 	stw	r4,-12(fp)
8113fb14:	2805883a 	mov	r2,r5
8113fb18:	e1bfff15 	stw	r6,-4(fp)
8113fb1c:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113fb20:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113fb24:	e0bfff17 	ldw	r2,-4(fp)
8113fb28:	1000021e 	bne	r2,zero,8113fb34 <OSQPendAbort+0x3c>
        return (0);
8113fb2c:	0005883a 	mov	r2,zero
8113fb30:	00004906 	br	8113fc58 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113fb34:	e0bffd17 	ldw	r2,-12(fp)
8113fb38:	1000051e 	bne	r2,zero,8113fb50 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113fb3c:	e0bfff17 	ldw	r2,-4(fp)
8113fb40:	00c00104 	movi	r3,4
8113fb44:	10c00005 	stb	r3,0(r2)
        return (0);
8113fb48:	0005883a 	mov	r2,zero
8113fb4c:	00004206 	br	8113fc58 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113fb50:	e0bffd17 	ldw	r2,-12(fp)
8113fb54:	10800003 	ldbu	r2,0(r2)
8113fb58:	10803fcc 	andi	r2,r2,255
8113fb5c:	108000a0 	cmpeqi	r2,r2,2
8113fb60:	1000051e 	bne	r2,zero,8113fb78 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113fb64:	e0bfff17 	ldw	r2,-4(fp)
8113fb68:	00c00044 	movi	r3,1
8113fb6c:	10c00005 	stb	r3,0(r2)
        return (0);
8113fb70:	0005883a 	mov	r2,zero
8113fb74:	00003806 	br	8113fc58 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fb78:	0005303a 	rdctl	r2,status
8113fb7c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fb80:	e0fffc17 	ldw	r3,-16(fp)
8113fb84:	00bfff84 	movi	r2,-2
8113fb88:	1884703a 	and	r2,r3,r2
8113fb8c:	1001703a 	wrctl	status,r2
  
  return context;
8113fb90:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113fb94:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
8113fb98:	e0bffd17 	ldw	r2,-12(fp)
8113fb9c:	10800283 	ldbu	r2,10(r2)
8113fba0:	10803fcc 	andi	r2,r2,255
8113fba4:	10002526 	beq	r2,zero,8113fc3c <OSQPendAbort+0x144>
        nbr_tasks = 0;
8113fba8:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113fbac:	e0bffe03 	ldbu	r2,-8(fp)
8113fbb0:	10800060 	cmpeqi	r2,r2,1
8113fbb4:	10000e26 	beq	r2,zero,8113fbf0 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113fbb8:	00000806 	br	8113fbdc <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113fbbc:	01c00084 	movi	r7,2
8113fbc0:	01800104 	movi	r6,4
8113fbc4:	000b883a 	mov	r5,zero
8113fbc8:	e13ffd17 	ldw	r4,-12(fp)
8113fbcc:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
                     nbr_tasks++;
8113fbd0:	e0bff803 	ldbu	r2,-32(fp)
8113fbd4:	10800044 	addi	r2,r2,1
8113fbd8:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113fbdc:	e0bffd17 	ldw	r2,-12(fp)
8113fbe0:	10800283 	ldbu	r2,10(r2)
8113fbe4:	10803fcc 	andi	r2,r2,255
8113fbe8:	103ff41e 	bne	r2,zero,8113fbbc <__reset+0xfb11fbbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113fbec:	00000906 	br	8113fc14 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113fbf0:	01c00084 	movi	r7,2
8113fbf4:	01800104 	movi	r6,4
8113fbf8:	000b883a 	mov	r5,zero
8113fbfc:	e13ffd17 	ldw	r4,-12(fp)
8113fc00:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
                 nbr_tasks++;
8113fc04:	e0bff803 	ldbu	r2,-32(fp)
8113fc08:	10800044 	addi	r2,r2,1
8113fc0c:	e0bff805 	stb	r2,-32(fp)
                 break;
8113fc10:	0001883a 	nop
8113fc14:	e0bff917 	ldw	r2,-28(fp)
8113fc18:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fc1c:	e0bffa17 	ldw	r2,-24(fp)
8113fc20:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
8113fc24:	113b8ac0 	call	8113b8ac <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113fc28:	e0bfff17 	ldw	r2,-4(fp)
8113fc2c:	00c00384 	movi	r3,14
8113fc30:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113fc34:	e0bff803 	ldbu	r2,-32(fp)
8113fc38:	00000706 	br	8113fc58 <OSQPendAbort+0x160>
8113fc3c:	e0bff917 	ldw	r2,-28(fp)
8113fc40:	e0bffb15 	stw	r2,-20(fp)
8113fc44:	e0bffb17 	ldw	r2,-20(fp)
8113fc48:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113fc4c:	e0bfff17 	ldw	r2,-4(fp)
8113fc50:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
8113fc54:	0005883a 	mov	r2,zero
}
8113fc58:	e037883a 	mov	sp,fp
8113fc5c:	dfc00117 	ldw	ra,4(sp)
8113fc60:	df000017 	ldw	fp,0(sp)
8113fc64:	dec00204 	addi	sp,sp,8
8113fc68:	f800283a 	ret

8113fc6c <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8113fc6c:	defff604 	addi	sp,sp,-40
8113fc70:	de00012e 	bgeu	sp,et,8113fc78 <OSQPost+0xc>
8113fc74:	003b68fa 	trap	3
8113fc78:	dfc00915 	stw	ra,36(sp)
8113fc7c:	df000815 	stw	fp,32(sp)
8113fc80:	df000804 	addi	fp,sp,32
8113fc84:	e13ffe15 	stw	r4,-8(fp)
8113fc88:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113fc8c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113fc90:	e0bffe17 	ldw	r2,-8(fp)
8113fc94:	1000021e 	bne	r2,zero,8113fca0 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
8113fc98:	00800104 	movi	r2,4
8113fc9c:	00004a06 	br	8113fdc8 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113fca0:	e0bffe17 	ldw	r2,-8(fp)
8113fca4:	10800003 	ldbu	r2,0(r2)
8113fca8:	10803fcc 	andi	r2,r2,255
8113fcac:	108000a0 	cmpeqi	r2,r2,2
8113fcb0:	1000021e 	bne	r2,zero,8113fcbc <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
8113fcb4:	00800044 	movi	r2,1
8113fcb8:	00004306 	br	8113fdc8 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fcbc:	0005303a 	rdctl	r2,status
8113fcc0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fcc4:	e0fffd17 	ldw	r3,-12(fp)
8113fcc8:	00bfff84 	movi	r2,-2
8113fccc:	1884703a 	and	r2,r3,r2
8113fcd0:	1001703a 	wrctl	status,r2
  
  return context;
8113fcd4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113fcd8:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8113fcdc:	e0bffe17 	ldw	r2,-8(fp)
8113fce0:	10800283 	ldbu	r2,10(r2)
8113fce4:	10803fcc 	andi	r2,r2,255
8113fce8:	10000c26 	beq	r2,zero,8113fd1c <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113fcec:	000f883a 	mov	r7,zero
8113fcf0:	01800104 	movi	r6,4
8113fcf4:	e17fff17 	ldw	r5,-4(fp)
8113fcf8:	e13ffe17 	ldw	r4,-8(fp)
8113fcfc:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
8113fd00:	e0bff817 	ldw	r2,-32(fp)
8113fd04:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fd08:	e0bff917 	ldw	r2,-28(fp)
8113fd0c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
8113fd10:	113b8ac0 	call	8113b8ac <OS_Sched>
        return (OS_ERR_NONE);
8113fd14:	0005883a 	mov	r2,zero
8113fd18:	00002b06 	br	8113fdc8 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
8113fd1c:	e0bffe17 	ldw	r2,-8(fp)
8113fd20:	10800117 	ldw	r2,4(r2)
8113fd24:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
8113fd28:	e0bffb17 	ldw	r2,-20(fp)
8113fd2c:	10c0058b 	ldhu	r3,22(r2)
8113fd30:	e0bffb17 	ldw	r2,-20(fp)
8113fd34:	1080050b 	ldhu	r2,20(r2)
8113fd38:	18ffffcc 	andi	r3,r3,65535
8113fd3c:	10bfffcc 	andi	r2,r2,65535
8113fd40:	18800636 	bltu	r3,r2,8113fd5c <OSQPost+0xf0>
8113fd44:	e0bff817 	ldw	r2,-32(fp)
8113fd48:	e0bffa15 	stw	r2,-24(fp)
8113fd4c:	e0bffa17 	ldw	r2,-24(fp)
8113fd50:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113fd54:	00800784 	movi	r2,30
8113fd58:	00001b06 	br	8113fdc8 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8113fd5c:	e0bffb17 	ldw	r2,-20(fp)
8113fd60:	10800317 	ldw	r2,12(r2)
8113fd64:	11000104 	addi	r4,r2,4
8113fd68:	e0fffb17 	ldw	r3,-20(fp)
8113fd6c:	19000315 	stw	r4,12(r3)
8113fd70:	e0ffff17 	ldw	r3,-4(fp)
8113fd74:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
8113fd78:	e0bffb17 	ldw	r2,-20(fp)
8113fd7c:	1080058b 	ldhu	r2,22(r2)
8113fd80:	10800044 	addi	r2,r2,1
8113fd84:	1007883a 	mov	r3,r2
8113fd88:	e0bffb17 	ldw	r2,-20(fp)
8113fd8c:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8113fd90:	e0bffb17 	ldw	r2,-20(fp)
8113fd94:	10c00317 	ldw	r3,12(r2)
8113fd98:	e0bffb17 	ldw	r2,-20(fp)
8113fd9c:	10800217 	ldw	r2,8(r2)
8113fda0:	1880041e 	bne	r3,r2,8113fdb4 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
8113fda4:	e0bffb17 	ldw	r2,-20(fp)
8113fda8:	10c00117 	ldw	r3,4(r2)
8113fdac:	e0bffb17 	ldw	r2,-20(fp)
8113fdb0:	10c00315 	stw	r3,12(r2)
8113fdb4:	e0bff817 	ldw	r2,-32(fp)
8113fdb8:	e0bffc15 	stw	r2,-16(fp)
8113fdbc:	e0bffc17 	ldw	r2,-16(fp)
8113fdc0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113fdc4:	0005883a 	mov	r2,zero
}
8113fdc8:	e037883a 	mov	sp,fp
8113fdcc:	dfc00117 	ldw	ra,4(sp)
8113fdd0:	df000017 	ldw	fp,0(sp)
8113fdd4:	dec00204 	addi	sp,sp,8
8113fdd8:	f800283a 	ret

8113fddc <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8113fddc:	defff604 	addi	sp,sp,-40
8113fde0:	de00012e 	bgeu	sp,et,8113fde8 <OSQPostFront+0xc>
8113fde4:	003b68fa 	trap	3
8113fde8:	dfc00915 	stw	ra,36(sp)
8113fdec:	df000815 	stw	fp,32(sp)
8113fdf0:	df000804 	addi	fp,sp,32
8113fdf4:	e13ffe15 	stw	r4,-8(fp)
8113fdf8:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113fdfc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113fe00:	e0bffe17 	ldw	r2,-8(fp)
8113fe04:	1000021e 	bne	r2,zero,8113fe10 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
8113fe08:	00800104 	movi	r2,4
8113fe0c:	00004c06 	br	8113ff40 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113fe10:	e0bffe17 	ldw	r2,-8(fp)
8113fe14:	10800003 	ldbu	r2,0(r2)
8113fe18:	10803fcc 	andi	r2,r2,255
8113fe1c:	108000a0 	cmpeqi	r2,r2,2
8113fe20:	1000021e 	bne	r2,zero,8113fe2c <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
8113fe24:	00800044 	movi	r2,1
8113fe28:	00004506 	br	8113ff40 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fe2c:	0005303a 	rdctl	r2,status
8113fe30:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fe34:	e0fffd17 	ldw	r3,-12(fp)
8113fe38:	00bfff84 	movi	r2,-2
8113fe3c:	1884703a 	and	r2,r3,r2
8113fe40:	1001703a 	wrctl	status,r2
  
  return context;
8113fe44:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113fe48:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
8113fe4c:	e0bffe17 	ldw	r2,-8(fp)
8113fe50:	10800283 	ldbu	r2,10(r2)
8113fe54:	10803fcc 	andi	r2,r2,255
8113fe58:	10000c26 	beq	r2,zero,8113fe8c <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113fe5c:	000f883a 	mov	r7,zero
8113fe60:	01800104 	movi	r6,4
8113fe64:	e17fff17 	ldw	r5,-4(fp)
8113fe68:	e13ffe17 	ldw	r4,-8(fp)
8113fe6c:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
8113fe70:	e0bff817 	ldw	r2,-32(fp)
8113fe74:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fe78:	e0bff917 	ldw	r2,-28(fp)
8113fe7c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113fe80:	113b8ac0 	call	8113b8ac <OS_Sched>
        return (OS_ERR_NONE);
8113fe84:	0005883a 	mov	r2,zero
8113fe88:	00002d06 	br	8113ff40 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113fe8c:	e0bffe17 	ldw	r2,-8(fp)
8113fe90:	10800117 	ldw	r2,4(r2)
8113fe94:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113fe98:	e0bffb17 	ldw	r2,-20(fp)
8113fe9c:	10c0058b 	ldhu	r3,22(r2)
8113fea0:	e0bffb17 	ldw	r2,-20(fp)
8113fea4:	1080050b 	ldhu	r2,20(r2)
8113fea8:	18ffffcc 	andi	r3,r3,65535
8113feac:	10bfffcc 	andi	r2,r2,65535
8113feb0:	18800636 	bltu	r3,r2,8113fecc <OSQPostFront+0xf0>
8113feb4:	e0bff817 	ldw	r2,-32(fp)
8113feb8:	e0bffa15 	stw	r2,-24(fp)
8113febc:	e0bffa17 	ldw	r2,-24(fp)
8113fec0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113fec4:	00800784 	movi	r2,30
8113fec8:	00001d06 	br	8113ff40 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8113fecc:	e0bffb17 	ldw	r2,-20(fp)
8113fed0:	10c00417 	ldw	r3,16(r2)
8113fed4:	e0bffb17 	ldw	r2,-20(fp)
8113fed8:	10800117 	ldw	r2,4(r2)
8113fedc:	1880041e 	bne	r3,r2,8113fef0 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8113fee0:	e0bffb17 	ldw	r2,-20(fp)
8113fee4:	10c00217 	ldw	r3,8(r2)
8113fee8:	e0bffb17 	ldw	r2,-20(fp)
8113feec:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113fef0:	e0bffb17 	ldw	r2,-20(fp)
8113fef4:	10800417 	ldw	r2,16(r2)
8113fef8:	10ffff04 	addi	r3,r2,-4
8113fefc:	e0bffb17 	ldw	r2,-20(fp)
8113ff00:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
8113ff04:	e0bffb17 	ldw	r2,-20(fp)
8113ff08:	10800417 	ldw	r2,16(r2)
8113ff0c:	e0ffff17 	ldw	r3,-4(fp)
8113ff10:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113ff14:	e0bffb17 	ldw	r2,-20(fp)
8113ff18:	1080058b 	ldhu	r2,22(r2)
8113ff1c:	10800044 	addi	r2,r2,1
8113ff20:	1007883a 	mov	r3,r2
8113ff24:	e0bffb17 	ldw	r2,-20(fp)
8113ff28:	10c0058d 	sth	r3,22(r2)
8113ff2c:	e0bff817 	ldw	r2,-32(fp)
8113ff30:	e0bffc15 	stw	r2,-16(fp)
8113ff34:	e0bffc17 	ldw	r2,-16(fp)
8113ff38:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113ff3c:	0005883a 	mov	r2,zero
}
8113ff40:	e037883a 	mov	sp,fp
8113ff44:	dfc00117 	ldw	ra,4(sp)
8113ff48:	df000017 	ldw	fp,0(sp)
8113ff4c:	dec00204 	addi	sp,sp,8
8113ff50:	f800283a 	ret

8113ff54 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
8113ff54:	defff504 	addi	sp,sp,-44
8113ff58:	de00012e 	bgeu	sp,et,8113ff60 <OSQPostOpt+0xc>
8113ff5c:	003b68fa 	trap	3
8113ff60:	dfc00a15 	stw	ra,40(sp)
8113ff64:	df000915 	stw	fp,36(sp)
8113ff68:	df000904 	addi	fp,sp,36
8113ff6c:	e13ffd15 	stw	r4,-12(fp)
8113ff70:	e17ffe15 	stw	r5,-8(fp)
8113ff74:	3005883a 	mov	r2,r6
8113ff78:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ff7c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ff80:	e0bffd17 	ldw	r2,-12(fp)
8113ff84:	1000021e 	bne	r2,zero,8113ff90 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
8113ff88:	00800104 	movi	r2,4
8113ff8c:	00007106 	br	81140154 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113ff90:	e0bffd17 	ldw	r2,-12(fp)
8113ff94:	10800003 	ldbu	r2,0(r2)
8113ff98:	10803fcc 	andi	r2,r2,255
8113ff9c:	108000a0 	cmpeqi	r2,r2,2
8113ffa0:	1000021e 	bne	r2,zero,8113ffac <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
8113ffa4:	00800044 	movi	r2,1
8113ffa8:	00006a06 	br	81140154 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ffac:	0005303a 	rdctl	r2,status
8113ffb0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ffb4:	e0fffc17 	ldw	r3,-16(fp)
8113ffb8:	00bfff84 	movi	r2,-2
8113ffbc:	1884703a 	and	r2,r3,r2
8113ffc0:	1001703a 	wrctl	status,r2
  
  return context;
8113ffc4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ffc8:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8113ffcc:	e0bffd17 	ldw	r2,-12(fp)
8113ffd0:	10800283 	ldbu	r2,10(r2)
8113ffd4:	10803fcc 	andi	r2,r2,255
8113ffd8:	10001d26 	beq	r2,zero,81140050 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8113ffdc:	e0bfff03 	ldbu	r2,-4(fp)
8113ffe0:	1080004c 	andi	r2,r2,1
8113ffe4:	10000b26 	beq	r2,zero,81140014 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113ffe8:	00000506 	br	81140000 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113ffec:	000f883a 	mov	r7,zero
8113fff0:	01800104 	movi	r6,4
8113fff4:	e17ffe17 	ldw	r5,-8(fp)
8113fff8:	e13ffd17 	ldw	r4,-12(fp)
8113fffc:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
81140000:	e0bffd17 	ldw	r2,-12(fp)
81140004:	10800283 	ldbu	r2,10(r2)
81140008:	10803fcc 	andi	r2,r2,255
8114000c:	103ff71e 	bne	r2,zero,8113ffec <__reset+0xfb11ffec>
81140010:	00000506 	br	81140028 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81140014:	000f883a 	mov	r7,zero
81140018:	01800104 	movi	r6,4
8114001c:	e17ffe17 	ldw	r5,-8(fp)
81140020:	e13ffd17 	ldw	r4,-12(fp)
81140024:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
81140028:	e0bff717 	ldw	r2,-36(fp)
8114002c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140030:	e0bff817 	ldw	r2,-32(fp)
81140034:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
81140038:	e0bfff03 	ldbu	r2,-4(fp)
8114003c:	1080010c 	andi	r2,r2,4
81140040:	1000011e 	bne	r2,zero,81140048 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
81140044:	113b8ac0 	call	8113b8ac <OS_Sched>
        }
        return (OS_ERR_NONE);
81140048:	0005883a 	mov	r2,zero
8114004c:	00004106 	br	81140154 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
81140050:	e0bffd17 	ldw	r2,-12(fp)
81140054:	10800117 	ldw	r2,4(r2)
81140058:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8114005c:	e0bffa17 	ldw	r2,-24(fp)
81140060:	10c0058b 	ldhu	r3,22(r2)
81140064:	e0bffa17 	ldw	r2,-24(fp)
81140068:	1080050b 	ldhu	r2,20(r2)
8114006c:	18ffffcc 	andi	r3,r3,65535
81140070:	10bfffcc 	andi	r2,r2,65535
81140074:	18800636 	bltu	r3,r2,81140090 <OSQPostOpt+0x13c>
81140078:	e0bff717 	ldw	r2,-36(fp)
8114007c:	e0bff915 	stw	r2,-28(fp)
81140080:	e0bff917 	ldw	r2,-28(fp)
81140084:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81140088:	00800784 	movi	r2,30
8114008c:	00003106 	br	81140154 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
81140090:	e0bfff03 	ldbu	r2,-4(fp)
81140094:	1080008c 	andi	r2,r2,2
81140098:	10001326 	beq	r2,zero,811400e8 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8114009c:	e0bffa17 	ldw	r2,-24(fp)
811400a0:	10c00417 	ldw	r3,16(r2)
811400a4:	e0bffa17 	ldw	r2,-24(fp)
811400a8:	10800117 	ldw	r2,4(r2)
811400ac:	1880041e 	bne	r3,r2,811400c0 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
811400b0:	e0bffa17 	ldw	r2,-24(fp)
811400b4:	10c00217 	ldw	r3,8(r2)
811400b8:	e0bffa17 	ldw	r2,-24(fp)
811400bc:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
811400c0:	e0bffa17 	ldw	r2,-24(fp)
811400c4:	10800417 	ldw	r2,16(r2)
811400c8:	10ffff04 	addi	r3,r2,-4
811400cc:	e0bffa17 	ldw	r2,-24(fp)
811400d0:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
811400d4:	e0bffa17 	ldw	r2,-24(fp)
811400d8:	10800417 	ldw	r2,16(r2)
811400dc:	e0fffe17 	ldw	r3,-8(fp)
811400e0:	10c00015 	stw	r3,0(r2)
811400e4:	00001006 	br	81140128 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
811400e8:	e0bffa17 	ldw	r2,-24(fp)
811400ec:	10800317 	ldw	r2,12(r2)
811400f0:	11000104 	addi	r4,r2,4
811400f4:	e0fffa17 	ldw	r3,-24(fp)
811400f8:	19000315 	stw	r4,12(r3)
811400fc:	e0fffe17 	ldw	r3,-8(fp)
81140100:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
81140104:	e0bffa17 	ldw	r2,-24(fp)
81140108:	10c00317 	ldw	r3,12(r2)
8114010c:	e0bffa17 	ldw	r2,-24(fp)
81140110:	10800217 	ldw	r2,8(r2)
81140114:	1880041e 	bne	r3,r2,81140128 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
81140118:	e0bffa17 	ldw	r2,-24(fp)
8114011c:	10c00117 	ldw	r3,4(r2)
81140120:	e0bffa17 	ldw	r2,-24(fp)
81140124:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
81140128:	e0bffa17 	ldw	r2,-24(fp)
8114012c:	1080058b 	ldhu	r2,22(r2)
81140130:	10800044 	addi	r2,r2,1
81140134:	1007883a 	mov	r3,r2
81140138:	e0bffa17 	ldw	r2,-24(fp)
8114013c:	10c0058d 	sth	r3,22(r2)
81140140:	e0bff717 	ldw	r2,-36(fp)
81140144:	e0bffb15 	stw	r2,-20(fp)
81140148:	e0bffb17 	ldw	r2,-20(fp)
8114014c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81140150:	0005883a 	mov	r2,zero
}
81140154:	e037883a 	mov	sp,fp
81140158:	dfc00117 	ldw	ra,4(sp)
8114015c:	df000017 	ldw	fp,0(sp)
81140160:	dec00204 	addi	sp,sp,8
81140164:	f800283a 	ret

81140168 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
81140168:	defff604 	addi	sp,sp,-40
8114016c:	de00012e 	bgeu	sp,et,81140174 <OSQQuery+0xc>
81140170:	003b68fa 	trap	3
81140174:	df000915 	stw	fp,36(sp)
81140178:	df000904 	addi	fp,sp,36
8114017c:	e13ffe15 	stw	r4,-8(fp)
81140180:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81140184:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81140188:	e0bffe17 	ldw	r2,-8(fp)
8114018c:	1000021e 	bne	r2,zero,81140198 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81140190:	00800104 	movi	r2,4
81140194:	00004906 	br	811402bc <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
81140198:	e0bfff17 	ldw	r2,-4(fp)
8114019c:	1000021e 	bne	r2,zero,811401a8 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
811401a0:	00800244 	movi	r2,9
811401a4:	00004506 	br	811402bc <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
811401a8:	e0bffe17 	ldw	r2,-8(fp)
811401ac:	10800003 	ldbu	r2,0(r2)
811401b0:	10803fcc 	andi	r2,r2,255
811401b4:	108000a0 	cmpeqi	r2,r2,2
811401b8:	1000021e 	bne	r2,zero,811401c4 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
811401bc:	00800044 	movi	r2,1
811401c0:	00003e06 	br	811402bc <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811401c4:	0005303a 	rdctl	r2,status
811401c8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811401cc:	e0fffd17 	ldw	r3,-12(fp)
811401d0:	00bfff84 	movi	r2,-2
811401d4:	1884703a 	and	r2,r3,r2
811401d8:	1001703a 	wrctl	status,r2
  
  return context;
811401dc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811401e0:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
811401e4:	e0bffe17 	ldw	r2,-8(fp)
811401e8:	10c00283 	ldbu	r3,10(r2)
811401ec:	e0bfff17 	ldw	r2,-4(fp)
811401f0:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
811401f4:	e0bffe17 	ldw	r2,-8(fp)
811401f8:	108002c4 	addi	r2,r2,11
811401fc:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
81140200:	e0bfff17 	ldw	r2,-4(fp)
81140204:	10800204 	addi	r2,r2,8
81140208:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8114020c:	e03ff705 	stb	zero,-36(fp)
81140210:	00000b06 	br	81140240 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
81140214:	e0bff917 	ldw	r2,-28(fp)
81140218:	10c00044 	addi	r3,r2,1
8114021c:	e0fff915 	stw	r3,-28(fp)
81140220:	e0fff817 	ldw	r3,-32(fp)
81140224:	19000044 	addi	r4,r3,1
81140228:	e13ff815 	stw	r4,-32(fp)
8114022c:	18c00003 	ldbu	r3,0(r3)
81140230:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81140234:	e0bff703 	ldbu	r2,-36(fp)
81140238:	10800044 	addi	r2,r2,1
8114023c:	e0bff705 	stb	r2,-36(fp)
81140240:	e0bff703 	ldbu	r2,-36(fp)
81140244:	108001b0 	cmpltui	r2,r2,6
81140248:	103ff21e 	bne	r2,zero,81140214 <__reset+0xfb120214>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
8114024c:	e0bffe17 	ldw	r2,-8(fp)
81140250:	10800117 	ldw	r2,4(r2)
81140254:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
81140258:	e0bffc17 	ldw	r2,-16(fp)
8114025c:	1080058b 	ldhu	r2,22(r2)
81140260:	10bfffcc 	andi	r2,r2,65535
81140264:	10000626 	beq	r2,zero,81140280 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
81140268:	e0bffc17 	ldw	r2,-16(fp)
8114026c:	10800417 	ldw	r2,16(r2)
81140270:	10c00017 	ldw	r3,0(r2)
81140274:	e0bfff17 	ldw	r2,-4(fp)
81140278:	10c00015 	stw	r3,0(r2)
8114027c:	00000206 	br	81140288 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
81140280:	e0bfff17 	ldw	r2,-4(fp)
81140284:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
81140288:	e0bffc17 	ldw	r2,-16(fp)
8114028c:	10c0058b 	ldhu	r3,22(r2)
81140290:	e0bfff17 	ldw	r2,-4(fp)
81140294:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
81140298:	e0bffc17 	ldw	r2,-16(fp)
8114029c:	10c0050b 	ldhu	r3,20(r2)
811402a0:	e0bfff17 	ldw	r2,-4(fp)
811402a4:	10c0018d 	sth	r3,6(r2)
811402a8:	e0bffa17 	ldw	r2,-24(fp)
811402ac:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811402b0:	e0bffb17 	ldw	r2,-20(fp)
811402b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811402b8:	0005883a 	mov	r2,zero
}
811402bc:	e037883a 	mov	sp,fp
811402c0:	df000017 	ldw	fp,0(sp)
811402c4:	dec00104 	addi	sp,sp,4
811402c8:	f800283a 	ret

811402cc <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
811402cc:	defffb04 	addi	sp,sp,-20
811402d0:	de00012e 	bgeu	sp,et,811402d8 <OS_QInit+0xc>
811402d4:	003b68fa 	trap	3
811402d8:	dfc00415 	stw	ra,16(sp)
811402dc:	df000315 	stw	fp,12(sp)
811402e0:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
811402e4:	0140c004 	movi	r5,768
811402e8:	012045f4 	movhi	r4,33047
811402ec:	212bfa04 	addi	r4,r4,-20504
811402f0:	113b7e00 	call	8113b7e0 <OS_MemClr>
    pq1 = &OSQTbl[0];
811402f4:	00a045f4 	movhi	r2,33047
811402f8:	10abfa04 	addi	r2,r2,-20504
811402fc:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
81140300:	00a045f4 	movhi	r2,33047
81140304:	10ac0004 	addi	r2,r2,-20480
81140308:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8114030c:	e03ffd0d 	sth	zero,-12(fp)
81140310:	00000c06 	br	81140344 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
81140314:	e0bffe17 	ldw	r2,-8(fp)
81140318:	e0ffff17 	ldw	r3,-4(fp)
8114031c:	10c00015 	stw	r3,0(r2)
        pq1++;
81140320:	e0bffe17 	ldw	r2,-8(fp)
81140324:	10800604 	addi	r2,r2,24
81140328:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8114032c:	e0bfff17 	ldw	r2,-4(fp)
81140330:	10800604 	addi	r2,r2,24
81140334:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
81140338:	e0bffd0b 	ldhu	r2,-12(fp)
8114033c:	10800044 	addi	r2,r2,1
81140340:	e0bffd0d 	sth	r2,-12(fp)
81140344:	e0bffd0b 	ldhu	r2,-12(fp)
81140348:	108007f0 	cmpltui	r2,r2,31
8114034c:	103ff11e 	bne	r2,zero,81140314 <__reset+0xfb120314>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
81140350:	e0bffe17 	ldw	r2,-8(fp)
81140354:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
81140358:	00a045f4 	movhi	r2,33047
8114035c:	10abfa04 	addi	r2,r2,-20504
81140360:	d0a09d15 	stw	r2,-32140(gp)
#endif
}
81140364:	0001883a 	nop
81140368:	e037883a 	mov	sp,fp
8114036c:	dfc00117 	ldw	ra,4(sp)
81140370:	df000017 	ldw	fp,0(sp)
81140374:	dec00204 	addi	sp,sp,8
81140378:	f800283a 	ret

8114037c <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8114037c:	defffa04 	addi	sp,sp,-24
81140380:	de00012e 	bgeu	sp,et,81140388 <OSSemAccept+0xc>
81140384:	003b68fa 	trap	3
81140388:	df000515 	stw	fp,20(sp)
8114038c:	df000504 	addi	fp,sp,20
81140390:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140394:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81140398:	e0bfff17 	ldw	r2,-4(fp)
8114039c:	1000021e 	bne	r2,zero,811403a8 <OSSemAccept+0x2c>
        return (0);
811403a0:	0005883a 	mov	r2,zero
811403a4:	00001f06 	br	81140424 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811403a8:	e0bfff17 	ldw	r2,-4(fp)
811403ac:	10800003 	ldbu	r2,0(r2)
811403b0:	10803fcc 	andi	r2,r2,255
811403b4:	108000e0 	cmpeqi	r2,r2,3
811403b8:	1000021e 	bne	r2,zero,811403c4 <OSSemAccept+0x48>
        return (0);
811403bc:	0005883a 	mov	r2,zero
811403c0:	00001806 	br	81140424 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811403c4:	0005303a 	rdctl	r2,status
811403c8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811403cc:	e0fffe17 	ldw	r3,-8(fp)
811403d0:	00bfff84 	movi	r2,-2
811403d4:	1884703a 	and	r2,r3,r2
811403d8:	1001703a 	wrctl	status,r2
  
  return context;
811403dc:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811403e0:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
811403e4:	e0bfff17 	ldw	r2,-4(fp)
811403e8:	1080020b 	ldhu	r2,8(r2)
811403ec:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
811403f0:	e0bffd0b 	ldhu	r2,-12(fp)
811403f4:	10000626 	beq	r2,zero,81140410 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
811403f8:	e0bfff17 	ldw	r2,-4(fp)
811403fc:	1080020b 	ldhu	r2,8(r2)
81140400:	10bfffc4 	addi	r2,r2,-1
81140404:	1007883a 	mov	r3,r2
81140408:	e0bfff17 	ldw	r2,-4(fp)
8114040c:	10c0020d 	sth	r3,8(r2)
81140410:	e0bffb17 	ldw	r2,-20(fp)
81140414:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140418:	e0bffc17 	ldw	r2,-16(fp)
8114041c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
81140420:	e0bffd0b 	ldhu	r2,-12(fp)
}
81140424:	e037883a 	mov	sp,fp
81140428:	df000017 	ldw	fp,0(sp)
8114042c:	dec00104 	addi	sp,sp,4
81140430:	f800283a 	ret

81140434 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
81140434:	defff904 	addi	sp,sp,-28
81140438:	de00012e 	bgeu	sp,et,81140440 <OSSemCreate+0xc>
8114043c:	003b68fa 	trap	3
81140440:	dfc00615 	stw	ra,24(sp)
81140444:	df000515 	stw	fp,20(sp)
81140448:	df000504 	addi	fp,sp,20
8114044c:	2005883a 	mov	r2,r4
81140450:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81140454:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81140458:	d0a0a103 	ldbu	r2,-32124(gp)
8114045c:	10803fcc 	andi	r2,r2,255
81140460:	10000226 	beq	r2,zero,8114046c <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
81140464:	0005883a 	mov	r2,zero
81140468:	00002506 	br	81140500 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114046c:	0005303a 	rdctl	r2,status
81140470:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140474:	e0fffe17 	ldw	r3,-8(fp)
81140478:	00bfff84 	movi	r2,-2
8114047c:	1884703a 	and	r2,r3,r2
81140480:	1001703a 	wrctl	status,r2
  
  return context;
81140484:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81140488:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8114048c:	d0a0a017 	ldw	r2,-32128(gp)
81140490:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
81140494:	d0a0a017 	ldw	r2,-32128(gp)
81140498:	10000326 	beq	r2,zero,811404a8 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8114049c:	d0a0a017 	ldw	r2,-32128(gp)
811404a0:	10800117 	ldw	r2,4(r2)
811404a4:	d0a0a015 	stw	r2,-32128(gp)
811404a8:	e0bffb17 	ldw	r2,-20(fp)
811404ac:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811404b0:	e0bffc17 	ldw	r2,-16(fp)
811404b4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
811404b8:	e0bffd17 	ldw	r2,-12(fp)
811404bc:	10000f26 	beq	r2,zero,811404fc <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
811404c0:	e0bffd17 	ldw	r2,-12(fp)
811404c4:	00c000c4 	movi	r3,3
811404c8:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
811404cc:	e0bffd17 	ldw	r2,-12(fp)
811404d0:	e0ffff0b 	ldhu	r3,-4(fp)
811404d4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
811404d8:	e0bffd17 	ldw	r2,-12(fp)
811404dc:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
811404e0:	e0bffd17 	ldw	r2,-12(fp)
811404e4:	00c00fc4 	movi	r3,63
811404e8:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
811404ec:	e0bffd17 	ldw	r2,-12(fp)
811404f0:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
811404f4:	e13ffd17 	ldw	r4,-12(fp)
811404f8:	113b3c80 	call	8113b3c8 <OS_EventWaitListInit>
    }
    return (pevent);
811404fc:	e0bffd17 	ldw	r2,-12(fp)
}
81140500:	e037883a 	mov	sp,fp
81140504:	dfc00117 	ldw	ra,4(sp)
81140508:	df000017 	ldw	fp,0(sp)
8114050c:	dec00204 	addi	sp,sp,8
81140510:	f800283a 	ret

81140514 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81140514:	defff304 	addi	sp,sp,-52
81140518:	de00012e 	bgeu	sp,et,81140520 <OSSemDel+0xc>
8114051c:	003b68fa 	trap	3
81140520:	dfc00c15 	stw	ra,48(sp)
81140524:	df000b15 	stw	fp,44(sp)
81140528:	df000b04 	addi	fp,sp,44
8114052c:	e13ffd15 	stw	r4,-12(fp)
81140530:	2805883a 	mov	r2,r5
81140534:	e1bfff15 	stw	r6,-4(fp)
81140538:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8114053c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81140540:	e0bfff17 	ldw	r2,-4(fp)
81140544:	1000021e 	bne	r2,zero,81140550 <OSSemDel+0x3c>
        return (pevent);
81140548:	e0bffd17 	ldw	r2,-12(fp)
8114054c:	00007e06 	br	81140748 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81140550:	e0bffd17 	ldw	r2,-12(fp)
81140554:	1000051e 	bne	r2,zero,8114056c <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81140558:	e0bfff17 	ldw	r2,-4(fp)
8114055c:	00c00104 	movi	r3,4
81140560:	10c00005 	stb	r3,0(r2)
        return (pevent);
81140564:	e0bffd17 	ldw	r2,-12(fp)
81140568:	00007706 	br	81140748 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8114056c:	e0bffd17 	ldw	r2,-12(fp)
81140570:	10800003 	ldbu	r2,0(r2)
81140574:	10803fcc 	andi	r2,r2,255
81140578:	108000e0 	cmpeqi	r2,r2,3
8114057c:	1000051e 	bne	r2,zero,81140594 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81140580:	e0bfff17 	ldw	r2,-4(fp)
81140584:	00c00044 	movi	r3,1
81140588:	10c00005 	stb	r3,0(r2)
        return (pevent);
8114058c:	e0bffd17 	ldw	r2,-12(fp)
81140590:	00006d06 	br	81140748 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81140594:	d0a0a103 	ldbu	r2,-32124(gp)
81140598:	10803fcc 	andi	r2,r2,255
8114059c:	10000526 	beq	r2,zero,811405b4 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
811405a0:	e0bfff17 	ldw	r2,-4(fp)
811405a4:	00c003c4 	movi	r3,15
811405a8:	10c00005 	stb	r3,0(r2)
        return (pevent);
811405ac:	e0bffd17 	ldw	r2,-12(fp)
811405b0:	00006506 	br	81140748 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811405b4:	0005303a 	rdctl	r2,status
811405b8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811405bc:	e0fffc17 	ldw	r3,-16(fp)
811405c0:	00bfff84 	movi	r2,-2
811405c4:	1884703a 	and	r2,r3,r2
811405c8:	1001703a 	wrctl	status,r2
  
  return context;
811405cc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811405d0:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
811405d4:	e0bffd17 	ldw	r2,-12(fp)
811405d8:	10800283 	ldbu	r2,10(r2)
811405dc:	10803fcc 	andi	r2,r2,255
811405e0:	10000326 	beq	r2,zero,811405f0 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
811405e4:	00800044 	movi	r2,1
811405e8:	e0bff505 	stb	r2,-44(fp)
811405ec:	00000106 	br	811405f4 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
811405f0:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
811405f4:	e0bffe03 	ldbu	r2,-8(fp)
811405f8:	10000326 	beq	r2,zero,81140608 <OSSemDel+0xf4>
811405fc:	10800060 	cmpeqi	r2,r2,1
81140600:	1000281e 	bne	r2,zero,811406a4 <OSSemDel+0x190>
81140604:	00004506 	br	8114071c <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
81140608:	e0bff503 	ldbu	r2,-44(fp)
8114060c:	1000161e 	bne	r2,zero,81140668 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81140610:	e0bffd17 	ldw	r2,-12(fp)
81140614:	00c00fc4 	movi	r3,63
81140618:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8114061c:	e0bffd17 	ldw	r2,-12(fp)
81140620:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81140624:	e0bffd17 	ldw	r2,-12(fp)
81140628:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8114062c:	d0e0a017 	ldw	r3,-32128(gp)
81140630:	e0bffd17 	ldw	r2,-12(fp)
81140634:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
81140638:	e0bffd17 	ldw	r2,-12(fp)
8114063c:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81140640:	e0bffd17 	ldw	r2,-12(fp)
81140644:	d0a0a015 	stw	r2,-32128(gp)
81140648:	e0bff717 	ldw	r2,-36(fp)
8114064c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140650:	e0bff817 	ldw	r2,-32(fp)
81140654:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81140658:	e0bfff17 	ldw	r2,-4(fp)
8114065c:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
81140660:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81140664:	00003706 	br	81140744 <OSSemDel+0x230>
81140668:	e0bff717 	ldw	r2,-36(fp)
8114066c:	e0bff915 	stw	r2,-28(fp)
81140670:	e0bff917 	ldw	r2,-28(fp)
81140674:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
81140678:	e0bfff17 	ldw	r2,-4(fp)
8114067c:	00c01244 	movi	r3,73
81140680:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
81140684:	e0bffd17 	ldw	r2,-12(fp)
81140688:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8114068c:	00002d06 	br	81140744 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81140690:	000f883a 	mov	r7,zero
81140694:	01800044 	movi	r6,1
81140698:	000b883a 	mov	r5,zero
8114069c:	e13ffd17 	ldw	r4,-12(fp)
811406a0:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
811406a4:	e0bffd17 	ldw	r2,-12(fp)
811406a8:	10800283 	ldbu	r2,10(r2)
811406ac:	10803fcc 	andi	r2,r2,255
811406b0:	103ff71e 	bne	r2,zero,81140690 <__reset+0xfb120690>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
811406b4:	e0bffd17 	ldw	r2,-12(fp)
811406b8:	00c00fc4 	movi	r3,63
811406bc:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
811406c0:	e0bffd17 	ldw	r2,-12(fp)
811406c4:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
811406c8:	e0bffd17 	ldw	r2,-12(fp)
811406cc:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
811406d0:	d0e0a017 	ldw	r3,-32128(gp)
811406d4:	e0bffd17 	ldw	r2,-12(fp)
811406d8:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
811406dc:	e0bffd17 	ldw	r2,-12(fp)
811406e0:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
811406e4:	e0bffd17 	ldw	r2,-12(fp)
811406e8:	d0a0a015 	stw	r2,-32128(gp)
811406ec:	e0bff717 	ldw	r2,-36(fp)
811406f0:	e0bffa15 	stw	r2,-24(fp)
811406f4:	e0bffa17 	ldw	r2,-24(fp)
811406f8:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
811406fc:	e0bff503 	ldbu	r2,-44(fp)
81140700:	10800058 	cmpnei	r2,r2,1
81140704:	1000011e 	bne	r2,zero,8114070c <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81140708:	113b8ac0 	call	8113b8ac <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8114070c:	e0bfff17 	ldw	r2,-4(fp)
81140710:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
81140714:	e03ff615 	stw	zero,-40(fp)
             break;
81140718:	00000a06 	br	81140744 <OSSemDel+0x230>
8114071c:	e0bff717 	ldw	r2,-36(fp)
81140720:	e0bffb15 	stw	r2,-20(fp)
81140724:	e0bffb17 	ldw	r2,-20(fp)
81140728:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8114072c:	e0bfff17 	ldw	r2,-4(fp)
81140730:	00c001c4 	movi	r3,7
81140734:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81140738:	e0bffd17 	ldw	r2,-12(fp)
8114073c:	e0bff615 	stw	r2,-40(fp)
             break;
81140740:	0001883a 	nop
    }
    return (pevent_return);
81140744:	e0bff617 	ldw	r2,-40(fp)
}
81140748:	e037883a 	mov	sp,fp
8114074c:	dfc00117 	ldw	ra,4(sp)
81140750:	df000017 	ldw	fp,0(sp)
81140754:	dec00204 	addi	sp,sp,8
81140758:	f800283a 	ret

8114075c <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8114075c:	defff504 	addi	sp,sp,-44
81140760:	de00012e 	bgeu	sp,et,81140768 <OSSemPend+0xc>
81140764:	003b68fa 	trap	3
81140768:	dfc00a15 	stw	ra,40(sp)
8114076c:	df000915 	stw	fp,36(sp)
81140770:	df000904 	addi	fp,sp,36
81140774:	e13ffd15 	stw	r4,-12(fp)
81140778:	2805883a 	mov	r2,r5
8114077c:	e1bfff15 	stw	r6,-4(fp)
81140780:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140784:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81140788:	e0bfff17 	ldw	r2,-4(fp)
8114078c:	10007226 	beq	r2,zero,81140958 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81140790:	e0bffd17 	ldw	r2,-12(fp)
81140794:	1000041e 	bne	r2,zero,811407a8 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81140798:	e0bfff17 	ldw	r2,-4(fp)
8114079c:	00c00104 	movi	r3,4
811407a0:	10c00005 	stb	r3,0(r2)
        return;
811407a4:	00006d06 	br	8114095c <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811407a8:	e0bffd17 	ldw	r2,-12(fp)
811407ac:	10800003 	ldbu	r2,0(r2)
811407b0:	10803fcc 	andi	r2,r2,255
811407b4:	108000e0 	cmpeqi	r2,r2,3
811407b8:	1000041e 	bne	r2,zero,811407cc <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
811407bc:	e0bfff17 	ldw	r2,-4(fp)
811407c0:	00c00044 	movi	r3,1
811407c4:	10c00005 	stb	r3,0(r2)
        return;
811407c8:	00006406 	br	8114095c <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
811407cc:	d0a0a103 	ldbu	r2,-32124(gp)
811407d0:	10803fcc 	andi	r2,r2,255
811407d4:	10000426 	beq	r2,zero,811407e8 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
811407d8:	e0bfff17 	ldw	r2,-4(fp)
811407dc:	00c00084 	movi	r3,2
811407e0:	10c00005 	stb	r3,0(r2)
        return;
811407e4:	00005d06 	br	8114095c <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
811407e8:	d0a08f03 	ldbu	r2,-32196(gp)
811407ec:	10803fcc 	andi	r2,r2,255
811407f0:	10000426 	beq	r2,zero,81140804 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
811407f4:	e0bfff17 	ldw	r2,-4(fp)
811407f8:	00c00344 	movi	r3,13
811407fc:	10c00005 	stb	r3,0(r2)
        return;
81140800:	00005606 	br	8114095c <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140804:	0005303a 	rdctl	r2,status
81140808:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114080c:	e0fffc17 	ldw	r3,-16(fp)
81140810:	00bfff84 	movi	r2,-2
81140814:	1884703a 	and	r2,r3,r2
81140818:	1001703a 	wrctl	status,r2
  
  return context;
8114081c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81140820:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
81140824:	e0bffd17 	ldw	r2,-12(fp)
81140828:	1080020b 	ldhu	r2,8(r2)
8114082c:	10bfffcc 	andi	r2,r2,65535
81140830:	10000d26 	beq	r2,zero,81140868 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
81140834:	e0bffd17 	ldw	r2,-12(fp)
81140838:	1080020b 	ldhu	r2,8(r2)
8114083c:	10bfffc4 	addi	r2,r2,-1
81140840:	1007883a 	mov	r3,r2
81140844:	e0bffd17 	ldw	r2,-12(fp)
81140848:	10c0020d 	sth	r3,8(r2)
8114084c:	e0bff717 	ldw	r2,-36(fp)
81140850:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140854:	e0bff817 	ldw	r2,-32(fp)
81140858:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8114085c:	e0bfff17 	ldw	r2,-4(fp)
81140860:	10000005 	stb	zero,0(r2)
        return;
81140864:	00003d06 	br	8114095c <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
81140868:	d0a0a217 	ldw	r2,-32120(gp)
8114086c:	d0e0a217 	ldw	r3,-32120(gp)
81140870:	18c00c03 	ldbu	r3,48(r3)
81140874:	18c00054 	ori	r3,r3,1
81140878:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8114087c:	d0a0a217 	ldw	r2,-32120(gp)
81140880:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
81140884:	d0a0a217 	ldw	r2,-32120(gp)
81140888:	e0fffe0b 	ldhu	r3,-8(fp)
8114088c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81140890:	e13ffd17 	ldw	r4,-12(fp)
81140894:	113af900 	call	8113af90 <OS_EventTaskWait>
81140898:	e0bff717 	ldw	r2,-36(fp)
8114089c:	e0bffb15 	stw	r2,-20(fp)
811408a0:	e0bffb17 	ldw	r2,-20(fp)
811408a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
811408a8:	113b8ac0 	call	8113b8ac <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811408ac:	0005303a 	rdctl	r2,status
811408b0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811408b4:	e0fff917 	ldw	r3,-28(fp)
811408b8:	00bfff84 	movi	r2,-2
811408bc:	1884703a 	and	r2,r3,r2
811408c0:	1001703a 	wrctl	status,r2
  
  return context;
811408c4:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
811408c8:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
811408cc:	d0a0a217 	ldw	r2,-32120(gp)
811408d0:	10800c43 	ldbu	r2,49(r2)
811408d4:	10803fcc 	andi	r2,r2,255
811408d8:	10000326 	beq	r2,zero,811408e8 <OSSemPend+0x18c>
811408dc:	108000a0 	cmpeqi	r2,r2,2
811408e0:	1000041e 	bne	r2,zero,811408f4 <OSSemPend+0x198>
811408e4:	00000706 	br	81140904 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
811408e8:	e0bfff17 	ldw	r2,-4(fp)
811408ec:	10000005 	stb	zero,0(r2)
             break;
811408f0:	00000c06 	br	81140924 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
811408f4:	e0bfff17 	ldw	r2,-4(fp)
811408f8:	00c00384 	movi	r3,14
811408fc:	10c00005 	stb	r3,0(r2)
             break;
81140900:	00000806 	br	81140924 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
81140904:	d0a0a217 	ldw	r2,-32120(gp)
81140908:	e17ffd17 	ldw	r5,-12(fp)
8114090c:	1009883a 	mov	r4,r2
81140910:	113b2000 	call	8113b200 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81140914:	e0bfff17 	ldw	r2,-4(fp)
81140918:	00c00284 	movi	r3,10
8114091c:	10c00005 	stb	r3,0(r2)
             break;
81140920:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81140924:	d0a0a217 	ldw	r2,-32120(gp)
81140928:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8114092c:	d0a0a217 	ldw	r2,-32120(gp)
81140930:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81140934:	d0a0a217 	ldw	r2,-32120(gp)
81140938:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8114093c:	d0a0a217 	ldw	r2,-32120(gp)
81140940:	10000815 	stw	zero,32(r2)
81140944:	e0bff717 	ldw	r2,-36(fp)
81140948:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114094c:	e0bffa17 	ldw	r2,-24(fp)
81140950:	1001703a 	wrctl	status,r2
81140954:	00000106 	br	8114095c <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81140958:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8114095c:	e037883a 	mov	sp,fp
81140960:	dfc00117 	ldw	ra,4(sp)
81140964:	df000017 	ldw	fp,0(sp)
81140968:	dec00204 	addi	sp,sp,8
8114096c:	f800283a 	ret

81140970 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81140970:	defff604 	addi	sp,sp,-40
81140974:	de00012e 	bgeu	sp,et,8114097c <OSSemPendAbort+0xc>
81140978:	003b68fa 	trap	3
8114097c:	dfc00915 	stw	ra,36(sp)
81140980:	df000815 	stw	fp,32(sp)
81140984:	df000804 	addi	fp,sp,32
81140988:	e13ffd15 	stw	r4,-12(fp)
8114098c:	2805883a 	mov	r2,r5
81140990:	e1bfff15 	stw	r6,-4(fp)
81140994:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140998:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8114099c:	e0bfff17 	ldw	r2,-4(fp)
811409a0:	1000021e 	bne	r2,zero,811409ac <OSSemPendAbort+0x3c>
        return (0);
811409a4:	0005883a 	mov	r2,zero
811409a8:	00004906 	br	81140ad0 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811409ac:	e0bffd17 	ldw	r2,-12(fp)
811409b0:	1000051e 	bne	r2,zero,811409c8 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811409b4:	e0bfff17 	ldw	r2,-4(fp)
811409b8:	00c00104 	movi	r3,4
811409bc:	10c00005 	stb	r3,0(r2)
        return (0);
811409c0:	0005883a 	mov	r2,zero
811409c4:	00004206 	br	81140ad0 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811409c8:	e0bffd17 	ldw	r2,-12(fp)
811409cc:	10800003 	ldbu	r2,0(r2)
811409d0:	10803fcc 	andi	r2,r2,255
811409d4:	108000e0 	cmpeqi	r2,r2,3
811409d8:	1000051e 	bne	r2,zero,811409f0 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811409dc:	e0bfff17 	ldw	r2,-4(fp)
811409e0:	00c00044 	movi	r3,1
811409e4:	10c00005 	stb	r3,0(r2)
        return (0);
811409e8:	0005883a 	mov	r2,zero
811409ec:	00003806 	br	81140ad0 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811409f0:	0005303a 	rdctl	r2,status
811409f4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811409f8:	e0fffc17 	ldw	r3,-16(fp)
811409fc:	00bfff84 	movi	r2,-2
81140a00:	1884703a 	and	r2,r3,r2
81140a04:	1001703a 	wrctl	status,r2
  
  return context;
81140a08:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81140a0c:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
81140a10:	e0bffd17 	ldw	r2,-12(fp)
81140a14:	10800283 	ldbu	r2,10(r2)
81140a18:	10803fcc 	andi	r2,r2,255
81140a1c:	10002526 	beq	r2,zero,81140ab4 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
81140a20:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81140a24:	e0bffe03 	ldbu	r2,-8(fp)
81140a28:	10800060 	cmpeqi	r2,r2,1
81140a2c:	10000e26 	beq	r2,zero,81140a68 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81140a30:	00000806 	br	81140a54 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81140a34:	01c00084 	movi	r7,2
81140a38:	01800044 	movi	r6,1
81140a3c:	000b883a 	mov	r5,zero
81140a40:	e13ffd17 	ldw	r4,-12(fp)
81140a44:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
                     nbr_tasks++;
81140a48:	e0bff803 	ldbu	r2,-32(fp)
81140a4c:	10800044 	addi	r2,r2,1
81140a50:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81140a54:	e0bffd17 	ldw	r2,-12(fp)
81140a58:	10800283 	ldbu	r2,10(r2)
81140a5c:	10803fcc 	andi	r2,r2,255
81140a60:	103ff41e 	bne	r2,zero,81140a34 <__reset+0xfb120a34>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81140a64:	00000906 	br	81140a8c <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81140a68:	01c00084 	movi	r7,2
81140a6c:	01800044 	movi	r6,1
81140a70:	000b883a 	mov	r5,zero
81140a74:	e13ffd17 	ldw	r4,-12(fp)
81140a78:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
                 nbr_tasks++;
81140a7c:	e0bff803 	ldbu	r2,-32(fp)
81140a80:	10800044 	addi	r2,r2,1
81140a84:	e0bff805 	stb	r2,-32(fp)
                 break;
81140a88:	0001883a 	nop
81140a8c:	e0bff917 	ldw	r2,-28(fp)
81140a90:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140a94:	e0bffa17 	ldw	r2,-24(fp)
81140a98:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81140a9c:	113b8ac0 	call	8113b8ac <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81140aa0:	e0bfff17 	ldw	r2,-4(fp)
81140aa4:	00c00384 	movi	r3,14
81140aa8:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81140aac:	e0bff803 	ldbu	r2,-32(fp)
81140ab0:	00000706 	br	81140ad0 <OSSemPendAbort+0x160>
81140ab4:	e0bff917 	ldw	r2,-28(fp)
81140ab8:	e0bffb15 	stw	r2,-20(fp)
81140abc:	e0bffb17 	ldw	r2,-20(fp)
81140ac0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81140ac4:	e0bfff17 	ldw	r2,-4(fp)
81140ac8:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
81140acc:	0005883a 	mov	r2,zero
}
81140ad0:	e037883a 	mov	sp,fp
81140ad4:	dfc00117 	ldw	ra,4(sp)
81140ad8:	df000017 	ldw	fp,0(sp)
81140adc:	dec00204 	addi	sp,sp,8
81140ae0:	f800283a 	ret

81140ae4 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
81140ae4:	defff804 	addi	sp,sp,-32
81140ae8:	de00012e 	bgeu	sp,et,81140af0 <OSSemPost+0xc>
81140aec:	003b68fa 	trap	3
81140af0:	dfc00715 	stw	ra,28(sp)
81140af4:	df000615 	stw	fp,24(sp)
81140af8:	df000604 	addi	fp,sp,24
81140afc:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140b00:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81140b04:	e0bfff17 	ldw	r2,-4(fp)
81140b08:	1000021e 	bne	r2,zero,81140b14 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
81140b0c:	00800104 	movi	r2,4
81140b10:	00003506 	br	81140be8 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81140b14:	e0bfff17 	ldw	r2,-4(fp)
81140b18:	10800003 	ldbu	r2,0(r2)
81140b1c:	10803fcc 	andi	r2,r2,255
81140b20:	108000e0 	cmpeqi	r2,r2,3
81140b24:	1000021e 	bne	r2,zero,81140b30 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
81140b28:	00800044 	movi	r2,1
81140b2c:	00002e06 	br	81140be8 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140b30:	0005303a 	rdctl	r2,status
81140b34:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140b38:	e0fffe17 	ldw	r3,-8(fp)
81140b3c:	00bfff84 	movi	r2,-2
81140b40:	1884703a 	and	r2,r3,r2
81140b44:	1001703a 	wrctl	status,r2
  
  return context;
81140b48:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81140b4c:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
81140b50:	e0bfff17 	ldw	r2,-4(fp)
81140b54:	10800283 	ldbu	r2,10(r2)
81140b58:	10803fcc 	andi	r2,r2,255
81140b5c:	10000c26 	beq	r2,zero,81140b90 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81140b60:	000f883a 	mov	r7,zero
81140b64:	01800044 	movi	r6,1
81140b68:	000b883a 	mov	r5,zero
81140b6c:	e13fff17 	ldw	r4,-4(fp)
81140b70:	113adf00 	call	8113adf0 <OS_EventTaskRdy>
81140b74:	e0bffa17 	ldw	r2,-24(fp)
81140b78:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140b7c:	e0bffb17 	ldw	r2,-20(fp)
81140b80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81140b84:	113b8ac0 	call	8113b8ac <OS_Sched>
        return (OS_ERR_NONE);
81140b88:	0005883a 	mov	r2,zero
81140b8c:	00001606 	br	81140be8 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
81140b90:	e0bfff17 	ldw	r2,-4(fp)
81140b94:	1080020b 	ldhu	r2,8(r2)
81140b98:	10ffffcc 	andi	r3,r2,65535
81140b9c:	00bfffd4 	movui	r2,65535
81140ba0:	18800c26 	beq	r3,r2,81140bd4 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
81140ba4:	e0bfff17 	ldw	r2,-4(fp)
81140ba8:	1080020b 	ldhu	r2,8(r2)
81140bac:	10800044 	addi	r2,r2,1
81140bb0:	1007883a 	mov	r3,r2
81140bb4:	e0bfff17 	ldw	r2,-4(fp)
81140bb8:	10c0020d 	sth	r3,8(r2)
81140bbc:	e0bffa17 	ldw	r2,-24(fp)
81140bc0:	e0bffc15 	stw	r2,-16(fp)
81140bc4:	e0bffc17 	ldw	r2,-16(fp)
81140bc8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81140bcc:	0005883a 	mov	r2,zero
81140bd0:	00000506 	br	81140be8 <OSSemPost+0x104>
81140bd4:	e0bffa17 	ldw	r2,-24(fp)
81140bd8:	e0bffd15 	stw	r2,-12(fp)
81140bdc:	e0bffd17 	ldw	r2,-12(fp)
81140be0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
81140be4:	00800c84 	movi	r2,50
}
81140be8:	e037883a 	mov	sp,fp
81140bec:	dfc00117 	ldw	ra,4(sp)
81140bf0:	df000017 	ldw	fp,0(sp)
81140bf4:	dec00204 	addi	sp,sp,8
81140bf8:	f800283a 	ret

81140bfc <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
81140bfc:	defff704 	addi	sp,sp,-36
81140c00:	de00012e 	bgeu	sp,et,81140c08 <OSSemQuery+0xc>
81140c04:	003b68fa 	trap	3
81140c08:	df000815 	stw	fp,32(sp)
81140c0c:	df000804 	addi	fp,sp,32
81140c10:	e13ffe15 	stw	r4,-8(fp)
81140c14:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81140c18:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81140c1c:	e0bffe17 	ldw	r2,-8(fp)
81140c20:	1000021e 	bne	r2,zero,81140c2c <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81140c24:	00800104 	movi	r2,4
81140c28:	00003606 	br	81140d04 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
81140c2c:	e0bfff17 	ldw	r2,-4(fp)
81140c30:	1000021e 	bne	r2,zero,81140c3c <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
81140c34:	00800244 	movi	r2,9
81140c38:	00003206 	br	81140d04 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
81140c3c:	e0bffe17 	ldw	r2,-8(fp)
81140c40:	10800003 	ldbu	r2,0(r2)
81140c44:	10803fcc 	andi	r2,r2,255
81140c48:	108000e0 	cmpeqi	r2,r2,3
81140c4c:	1000021e 	bne	r2,zero,81140c58 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
81140c50:	00800044 	movi	r2,1
81140c54:	00002b06 	br	81140d04 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140c58:	0005303a 	rdctl	r2,status
81140c5c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140c60:	e0fffd17 	ldw	r3,-12(fp)
81140c64:	00bfff84 	movi	r2,-2
81140c68:	1884703a 	and	r2,r3,r2
81140c6c:	1001703a 	wrctl	status,r2
  
  return context;
81140c70:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81140c74:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
81140c78:	e0bffe17 	ldw	r2,-8(fp)
81140c7c:	10c00283 	ldbu	r3,10(r2)
81140c80:	e0bfff17 	ldw	r2,-4(fp)
81140c84:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
81140c88:	e0bffe17 	ldw	r2,-8(fp)
81140c8c:	108002c4 	addi	r2,r2,11
81140c90:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
81140c94:	e0bfff17 	ldw	r2,-4(fp)
81140c98:	10800084 	addi	r2,r2,2
81140c9c:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81140ca0:	e03ffa05 	stb	zero,-24(fp)
81140ca4:	00000b06 	br	81140cd4 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
81140ca8:	e0bff917 	ldw	r2,-28(fp)
81140cac:	10c00044 	addi	r3,r2,1
81140cb0:	e0fff915 	stw	r3,-28(fp)
81140cb4:	e0fff817 	ldw	r3,-32(fp)
81140cb8:	19000044 	addi	r4,r3,1
81140cbc:	e13ff815 	stw	r4,-32(fp)
81140cc0:	18c00003 	ldbu	r3,0(r3)
81140cc4:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81140cc8:	e0bffa03 	ldbu	r2,-24(fp)
81140ccc:	10800044 	addi	r2,r2,1
81140cd0:	e0bffa05 	stb	r2,-24(fp)
81140cd4:	e0bffa03 	ldbu	r2,-24(fp)
81140cd8:	108001b0 	cmpltui	r2,r2,6
81140cdc:	103ff21e 	bne	r2,zero,81140ca8 <__reset+0xfb120ca8>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
81140ce0:	e0bffe17 	ldw	r2,-8(fp)
81140ce4:	10c0020b 	ldhu	r3,8(r2)
81140ce8:	e0bfff17 	ldw	r2,-4(fp)
81140cec:	10c0000d 	sth	r3,0(r2)
81140cf0:	e0bffb17 	ldw	r2,-20(fp)
81140cf4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140cf8:	e0bffc17 	ldw	r2,-16(fp)
81140cfc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81140d00:	0005883a 	mov	r2,zero
}
81140d04:	e037883a 	mov	sp,fp
81140d08:	df000017 	ldw	fp,0(sp)
81140d0c:	dec00104 	addi	sp,sp,4
81140d10:	f800283a 	ret

81140d14 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
81140d14:	defff904 	addi	sp,sp,-28
81140d18:	de00012e 	bgeu	sp,et,81140d20 <OSSemSet+0xc>
81140d1c:	003b68fa 	trap	3
81140d20:	df000615 	stw	fp,24(sp)
81140d24:	df000604 	addi	fp,sp,24
81140d28:	e13ffd15 	stw	r4,-12(fp)
81140d2c:	2805883a 	mov	r2,r5
81140d30:	e1bfff15 	stw	r6,-4(fp)
81140d34:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140d38:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81140d3c:	e0bfff17 	ldw	r2,-4(fp)
81140d40:	10003126 	beq	r2,zero,81140e08 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81140d44:	e0bffd17 	ldw	r2,-12(fp)
81140d48:	1000041e 	bne	r2,zero,81140d5c <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81140d4c:	e0bfff17 	ldw	r2,-4(fp)
81140d50:	00c00104 	movi	r3,4
81140d54:	10c00005 	stb	r3,0(r2)
        return;
81140d58:	00002c06 	br	81140e0c <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81140d5c:	e0bffd17 	ldw	r2,-12(fp)
81140d60:	10800003 	ldbu	r2,0(r2)
81140d64:	10803fcc 	andi	r2,r2,255
81140d68:	108000e0 	cmpeqi	r2,r2,3
81140d6c:	1000041e 	bne	r2,zero,81140d80 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
81140d70:	e0bfff17 	ldw	r2,-4(fp)
81140d74:	00c00044 	movi	r3,1
81140d78:	10c00005 	stb	r3,0(r2)
        return;
81140d7c:	00002306 	br	81140e0c <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140d80:	0005303a 	rdctl	r2,status
81140d84:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140d88:	e0fffc17 	ldw	r3,-16(fp)
81140d8c:	00bfff84 	movi	r2,-2
81140d90:	1884703a 	and	r2,r3,r2
81140d94:	1001703a 	wrctl	status,r2
  
  return context;
81140d98:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81140d9c:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
81140da0:	e0bfff17 	ldw	r2,-4(fp)
81140da4:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
81140da8:	e0bffd17 	ldw	r2,-12(fp)
81140dac:	1080020b 	ldhu	r2,8(r2)
81140db0:	10bfffcc 	andi	r2,r2,65535
81140db4:	10000426 	beq	r2,zero,81140dc8 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
81140db8:	e0bffd17 	ldw	r2,-12(fp)
81140dbc:	e0fffe0b 	ldhu	r3,-8(fp)
81140dc0:	10c0020d 	sth	r3,8(r2)
81140dc4:	00000b06 	br	81140df4 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
81140dc8:	e0bffd17 	ldw	r2,-12(fp)
81140dcc:	10800283 	ldbu	r2,10(r2)
81140dd0:	10803fcc 	andi	r2,r2,255
81140dd4:	1000041e 	bne	r2,zero,81140de8 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
81140dd8:	e0bffd17 	ldw	r2,-12(fp)
81140ddc:	e0fffe0b 	ldhu	r3,-8(fp)
81140de0:	10c0020d 	sth	r3,8(r2)
81140de4:	00000306 	br	81140df4 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
81140de8:	e0bfff17 	ldw	r2,-4(fp)
81140dec:	00c01244 	movi	r3,73
81140df0:	10c00005 	stb	r3,0(r2)
81140df4:	e0bffa17 	ldw	r2,-24(fp)
81140df8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140dfc:	e0bffb17 	ldw	r2,-20(fp)
81140e00:	1001703a 	wrctl	status,r2
81140e04:	00000106 	br	81140e0c <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81140e08:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
81140e0c:	e037883a 	mov	sp,fp
81140e10:	df000017 	ldw	fp,0(sp)
81140e14:	dec00104 	addi	sp,sp,4
81140e18:	f800283a 	ret

81140e1c <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
81140e1c:	defff104 	addi	sp,sp,-60
81140e20:	de00012e 	bgeu	sp,et,81140e28 <OSTaskChangePrio+0xc>
81140e24:	003b68fa 	trap	3
81140e28:	dfc00e15 	stw	ra,56(sp)
81140e2c:	df000d15 	stw	fp,52(sp)
81140e30:	df000d04 	addi	fp,sp,52
81140e34:	2007883a 	mov	r3,r4
81140e38:	2805883a 	mov	r2,r5
81140e3c:	e0fffe05 	stb	r3,-8(fp)
81140e40:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
81140e44:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
81140e48:	e0bffe03 	ldbu	r2,-8(fp)
81140e4c:	10800ab0 	cmpltui	r2,r2,42
81140e50:	1000051e 	bne	r2,zero,81140e68 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
81140e54:	e0bffe03 	ldbu	r2,-8(fp)
81140e58:	10803fe0 	cmpeqi	r2,r2,255
81140e5c:	1000021e 	bne	r2,zero,81140e68 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
81140e60:	00800a84 	movi	r2,42
81140e64:	00012606 	br	81141300 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
81140e68:	e0bfff03 	ldbu	r2,-4(fp)
81140e6c:	10800ab0 	cmpltui	r2,r2,42
81140e70:	1000021e 	bne	r2,zero,81140e7c <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
81140e74:	00800a84 	movi	r2,42
81140e78:	00012106 	br	81141300 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140e7c:	0005303a 	rdctl	r2,status
81140e80:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140e84:	e0fffd17 	ldw	r3,-12(fp)
81140e88:	00bfff84 	movi	r2,-2
81140e8c:	1884703a 	and	r2,r3,r2
81140e90:	1001703a 	wrctl	status,r2
  
  return context;
81140e94:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81140e98:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
81140e9c:	e0ffff03 	ldbu	r3,-4(fp)
81140ea0:	00a045f4 	movhi	r2,33047
81140ea4:	10ba6804 	addi	r2,r2,-5728
81140ea8:	18c7883a 	add	r3,r3,r3
81140eac:	18c7883a 	add	r3,r3,r3
81140eb0:	10c5883a 	add	r2,r2,r3
81140eb4:	10800017 	ldw	r2,0(r2)
81140eb8:	10000626 	beq	r2,zero,81140ed4 <OSTaskChangePrio+0xb8>
81140ebc:	e0bff517 	ldw	r2,-44(fp)
81140ec0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140ec4:	e0bff617 	ldw	r2,-40(fp)
81140ec8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
81140ecc:	00800a04 	movi	r2,40
81140ed0:	00010b06 	br	81141300 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
81140ed4:	e0bffe03 	ldbu	r2,-8(fp)
81140ed8:	10803fd8 	cmpnei	r2,r2,255
81140edc:	1000031e 	bne	r2,zero,81140eec <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
81140ee0:	d0a0a217 	ldw	r2,-32120(gp)
81140ee4:	10800c83 	ldbu	r2,50(r2)
81140ee8:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
81140eec:	e0fffe03 	ldbu	r3,-8(fp)
81140ef0:	00a045f4 	movhi	r2,33047
81140ef4:	10ba6804 	addi	r2,r2,-5728
81140ef8:	18c7883a 	add	r3,r3,r3
81140efc:	18c7883a 	add	r3,r3,r3
81140f00:	10c5883a 	add	r2,r2,r3
81140f04:	10800017 	ldw	r2,0(r2)
81140f08:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
81140f0c:	e0bff817 	ldw	r2,-32(fp)
81140f10:	1000061e 	bne	r2,zero,81140f2c <OSTaskChangePrio+0x110>
81140f14:	e0bff517 	ldw	r2,-44(fp)
81140f18:	e0bff715 	stw	r2,-36(fp)
81140f1c:	e0bff717 	ldw	r2,-36(fp)
81140f20:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
81140f24:	00800a44 	movi	r2,41
81140f28:	0000f506 	br	81141300 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
81140f2c:	e0bff817 	ldw	r2,-32(fp)
81140f30:	10800058 	cmpnei	r2,r2,1
81140f34:	1000061e 	bne	r2,zero,81140f50 <OSTaskChangePrio+0x134>
81140f38:	e0bff517 	ldw	r2,-44(fp)
81140f3c:	e0bff915 	stw	r2,-28(fp)
81140f40:	e0bff917 	ldw	r2,-28(fp)
81140f44:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
81140f48:	008010c4 	movi	r2,67
81140f4c:	0000ec06 	br	81141300 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
81140f50:	e0bfff03 	ldbu	r2,-4(fp)
81140f54:	1004d0fa 	srli	r2,r2,3
81140f58:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
81140f5c:	e0bfff03 	ldbu	r2,-4(fp)
81140f60:	108001cc 	andi	r2,r2,7
81140f64:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
81140f68:	e0bffb03 	ldbu	r2,-20(fp)
81140f6c:	00c00044 	movi	r3,1
81140f70:	1884983a 	sll	r2,r3,r2
81140f74:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
81140f78:	e0bffb43 	ldbu	r2,-19(fp)
81140f7c:	00c00044 	movi	r3,1
81140f80:	1884983a 	sll	r2,r3,r2
81140f84:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
81140f88:	e0fffe03 	ldbu	r3,-8(fp)
81140f8c:	00a045f4 	movhi	r2,33047
81140f90:	10ba6804 	addi	r2,r2,-5728
81140f94:	18c7883a 	add	r3,r3,r3
81140f98:	18c7883a 	add	r3,r3,r3
81140f9c:	10c5883a 	add	r2,r2,r3
81140fa0:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
81140fa4:	e0ffff03 	ldbu	r3,-4(fp)
81140fa8:	00a045f4 	movhi	r2,33047
81140fac:	10ba6804 	addi	r2,r2,-5728
81140fb0:	18c7883a 	add	r3,r3,r3
81140fb4:	18c7883a 	add	r3,r3,r3
81140fb8:	10c5883a 	add	r2,r2,r3
81140fbc:	e0fff817 	ldw	r3,-32(fp)
81140fc0:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
81140fc4:	e0bff817 	ldw	r2,-32(fp)
81140fc8:	10800d03 	ldbu	r2,52(r2)
81140fcc:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
81140fd0:	e0bff817 	ldw	r2,-32(fp)
81140fd4:	10800d83 	ldbu	r2,54(r2)
81140fd8:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
81140fdc:	e0bff817 	ldw	r2,-32(fp)
81140fe0:	10800d43 	ldbu	r2,53(r2)
81140fe4:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
81140fe8:	e0fffc03 	ldbu	r3,-16(fp)
81140fec:	d0a09e44 	addi	r2,gp,-32135
81140ff0:	1885883a 	add	r2,r3,r2
81140ff4:	10c00003 	ldbu	r3,0(r2)
81140ff8:	e0bffc83 	ldbu	r2,-14(fp)
81140ffc:	1884703a 	and	r2,r3,r2
81141000:	10803fcc 	andi	r2,r2,255
81141004:	10002826 	beq	r2,zero,811410a8 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
81141008:	e0fffc03 	ldbu	r3,-16(fp)
8114100c:	e13ffc03 	ldbu	r4,-16(fp)
81141010:	d0a09e44 	addi	r2,gp,-32135
81141014:	2085883a 	add	r2,r4,r2
81141018:	10800003 	ldbu	r2,0(r2)
8114101c:	1009883a 	mov	r4,r2
81141020:	e0bffc83 	ldbu	r2,-14(fp)
81141024:	0084303a 	nor	r2,zero,r2
81141028:	2084703a 	and	r2,r4,r2
8114102c:	1009883a 	mov	r4,r2
81141030:	d0a09e44 	addi	r2,gp,-32135
81141034:	1885883a 	add	r2,r3,r2
81141038:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
8114103c:	e0fffc03 	ldbu	r3,-16(fp)
81141040:	d0a09e44 	addi	r2,gp,-32135
81141044:	1885883a 	add	r2,r3,r2
81141048:	10800003 	ldbu	r2,0(r2)
8114104c:	10803fcc 	andi	r2,r2,255
81141050:	1000061e 	bne	r2,zero,8114106c <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
81141054:	e0bffc43 	ldbu	r2,-15(fp)
81141058:	0084303a 	nor	r2,zero,r2
8114105c:	1007883a 	mov	r3,r2
81141060:	d0a09e03 	ldbu	r2,-32136(gp)
81141064:	1884703a 	and	r2,r3,r2
81141068:	d0a09e05 	stb	r2,-32136(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8114106c:	d0e09e03 	ldbu	r3,-32136(gp)
81141070:	e0bffb83 	ldbu	r2,-18(fp)
81141074:	1884b03a 	or	r2,r3,r2
81141078:	d0a09e05 	stb	r2,-32136(gp)
         OSRdyTbl[y_new] |= bitx_new;
8114107c:	e0fffb03 	ldbu	r3,-20(fp)
81141080:	e13ffb03 	ldbu	r4,-20(fp)
81141084:	d0a09e44 	addi	r2,gp,-32135
81141088:	2085883a 	add	r2,r4,r2
8114108c:	11000003 	ldbu	r4,0(r2)
81141090:	e0bffbc3 	ldbu	r2,-17(fp)
81141094:	2084b03a 	or	r2,r4,r2
81141098:	1009883a 	mov	r4,r2
8114109c:	d0a09e44 	addi	r2,gp,-32135
811410a0:	1885883a 	add	r2,r3,r2
811410a4:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
811410a8:	e0bff817 	ldw	r2,-32(fp)
811410ac:	10800717 	ldw	r2,28(r2)
811410b0:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
811410b4:	e0bff317 	ldw	r2,-52(fp)
811410b8:	10003326 	beq	r2,zero,81141188 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
811410bc:	e0bffc03 	ldbu	r2,-16(fp)
811410c0:	e0fffc03 	ldbu	r3,-16(fp)
811410c4:	e13ff317 	ldw	r4,-52(fp)
811410c8:	20c7883a 	add	r3,r4,r3
811410cc:	18c002c4 	addi	r3,r3,11
811410d0:	18c00003 	ldbu	r3,0(r3)
811410d4:	1809883a 	mov	r4,r3
811410d8:	e0fffc83 	ldbu	r3,-14(fp)
811410dc:	00c6303a 	nor	r3,zero,r3
811410e0:	20c6703a 	and	r3,r4,r3
811410e4:	1809883a 	mov	r4,r3
811410e8:	e0fff317 	ldw	r3,-52(fp)
811410ec:	1885883a 	add	r2,r3,r2
811410f0:	108002c4 	addi	r2,r2,11
811410f4:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
811410f8:	e0bffc03 	ldbu	r2,-16(fp)
811410fc:	e0fff317 	ldw	r3,-52(fp)
81141100:	1885883a 	add	r2,r3,r2
81141104:	108002c4 	addi	r2,r2,11
81141108:	10800003 	ldbu	r2,0(r2)
8114110c:	10803fcc 	andi	r2,r2,255
81141110:	1000091e 	bne	r2,zero,81141138 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
81141114:	e0bff317 	ldw	r2,-52(fp)
81141118:	10800283 	ldbu	r2,10(r2)
8114111c:	1007883a 	mov	r3,r2
81141120:	e0bffc43 	ldbu	r2,-15(fp)
81141124:	0084303a 	nor	r2,zero,r2
81141128:	1884703a 	and	r2,r3,r2
8114112c:	1007883a 	mov	r3,r2
81141130:	e0bff317 	ldw	r2,-52(fp)
81141134:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
81141138:	e0bff317 	ldw	r2,-52(fp)
8114113c:	10c00283 	ldbu	r3,10(r2)
81141140:	e0bffb83 	ldbu	r2,-18(fp)
81141144:	1884b03a 	or	r2,r3,r2
81141148:	1007883a 	mov	r3,r2
8114114c:	e0bff317 	ldw	r2,-52(fp)
81141150:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
81141154:	e0bffb03 	ldbu	r2,-20(fp)
81141158:	e0fffb03 	ldbu	r3,-20(fp)
8114115c:	e13ff317 	ldw	r4,-52(fp)
81141160:	20c7883a 	add	r3,r4,r3
81141164:	18c002c4 	addi	r3,r3,11
81141168:	19000003 	ldbu	r4,0(r3)
8114116c:	e0fffbc3 	ldbu	r3,-17(fp)
81141170:	20c6b03a 	or	r3,r4,r3
81141174:	1809883a 	mov	r4,r3
81141178:	e0fff317 	ldw	r3,-52(fp)
8114117c:	1885883a 	add	r2,r3,r2
81141180:	108002c4 	addi	r2,r2,11
81141184:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
81141188:	e0bff817 	ldw	r2,-32(fp)
8114118c:	10800817 	ldw	r2,32(r2)
81141190:	10004226 	beq	r2,zero,8114129c <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
81141194:	e0bff817 	ldw	r2,-32(fp)
81141198:	10800817 	ldw	r2,32(r2)
8114119c:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
811411a0:	e0bff417 	ldw	r2,-48(fp)
811411a4:	10800017 	ldw	r2,0(r2)
811411a8:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
811411ac:	00003906 	br	81141294 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
811411b0:	e0bffc03 	ldbu	r2,-16(fp)
811411b4:	e0fffc03 	ldbu	r3,-16(fp)
811411b8:	e13ff317 	ldw	r4,-52(fp)
811411bc:	20c7883a 	add	r3,r4,r3
811411c0:	18c002c4 	addi	r3,r3,11
811411c4:	18c00003 	ldbu	r3,0(r3)
811411c8:	1809883a 	mov	r4,r3
811411cc:	e0fffc83 	ldbu	r3,-14(fp)
811411d0:	00c6303a 	nor	r3,zero,r3
811411d4:	20c6703a 	and	r3,r4,r3
811411d8:	1809883a 	mov	r4,r3
811411dc:	e0fff317 	ldw	r3,-52(fp)
811411e0:	1885883a 	add	r2,r3,r2
811411e4:	108002c4 	addi	r2,r2,11
811411e8:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
811411ec:	e0bffc03 	ldbu	r2,-16(fp)
811411f0:	e0fff317 	ldw	r3,-52(fp)
811411f4:	1885883a 	add	r2,r3,r2
811411f8:	108002c4 	addi	r2,r2,11
811411fc:	10800003 	ldbu	r2,0(r2)
81141200:	10803fcc 	andi	r2,r2,255
81141204:	1000091e 	bne	r2,zero,8114122c <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
81141208:	e0bff317 	ldw	r2,-52(fp)
8114120c:	10800283 	ldbu	r2,10(r2)
81141210:	1007883a 	mov	r3,r2
81141214:	e0bffc43 	ldbu	r2,-15(fp)
81141218:	0084303a 	nor	r2,zero,r2
8114121c:	1884703a 	and	r2,r3,r2
81141220:	1007883a 	mov	r3,r2
81141224:	e0bff317 	ldw	r2,-52(fp)
81141228:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8114122c:	e0bff317 	ldw	r2,-52(fp)
81141230:	10c00283 	ldbu	r3,10(r2)
81141234:	e0bffb83 	ldbu	r2,-18(fp)
81141238:	1884b03a 	or	r2,r3,r2
8114123c:	1007883a 	mov	r3,r2
81141240:	e0bff317 	ldw	r2,-52(fp)
81141244:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
81141248:	e0bffb03 	ldbu	r2,-20(fp)
8114124c:	e0fffb03 	ldbu	r3,-20(fp)
81141250:	e13ff317 	ldw	r4,-52(fp)
81141254:	20c7883a 	add	r3,r4,r3
81141258:	18c002c4 	addi	r3,r3,11
8114125c:	19000003 	ldbu	r4,0(r3)
81141260:	e0fffbc3 	ldbu	r3,-17(fp)
81141264:	20c6b03a 	or	r3,r4,r3
81141268:	1809883a 	mov	r4,r3
8114126c:	e0fff317 	ldw	r3,-52(fp)
81141270:	1885883a 	add	r2,r3,r2
81141274:	108002c4 	addi	r2,r2,11
81141278:	11000005 	stb	r4,0(r2)
            pevents++;
8114127c:	e0bff417 	ldw	r2,-48(fp)
81141280:	10800104 	addi	r2,r2,4
81141284:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
81141288:	e0bff417 	ldw	r2,-48(fp)
8114128c:	10800017 	ldw	r2,0(r2)
81141290:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
81141294:	e0bff317 	ldw	r2,-52(fp)
81141298:	103fc51e 	bne	r2,zero,811411b0 <__reset+0xfb1211b0>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8114129c:	e0bff817 	ldw	r2,-32(fp)
811412a0:	e0ffff03 	ldbu	r3,-4(fp)
811412a4:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
811412a8:	e0bff817 	ldw	r2,-32(fp)
811412ac:	e0fffb03 	ldbu	r3,-20(fp)
811412b0:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
811412b4:	e0bff817 	ldw	r2,-32(fp)
811412b8:	e0fffb43 	ldbu	r3,-19(fp)
811412bc:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
811412c0:	e0bff817 	ldw	r2,-32(fp)
811412c4:	e0fffb83 	ldbu	r3,-18(fp)
811412c8:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
811412cc:	e0bff817 	ldw	r2,-32(fp)
811412d0:	e0fffbc3 	ldbu	r3,-17(fp)
811412d4:	10c00d45 	stb	r3,53(r2)
811412d8:	e0bff517 	ldw	r2,-44(fp)
811412dc:	e0bffa15 	stw	r2,-24(fp)
811412e0:	e0bffa17 	ldw	r2,-24(fp)
811412e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
811412e8:	d0a09103 	ldbu	r2,-32188(gp)
811412ec:	10803fcc 	andi	r2,r2,255
811412f0:	10800058 	cmpnei	r2,r2,1
811412f4:	1000011e 	bne	r2,zero,811412fc <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
811412f8:	113b8ac0 	call	8113b8ac <OS_Sched>
    }
    return (OS_ERR_NONE);
811412fc:	0005883a 	mov	r2,zero
}
81141300:	e037883a 	mov	sp,fp
81141304:	dfc00117 	ldw	ra,4(sp)
81141308:	df000017 	ldw	fp,0(sp)
8114130c:	dec00204 	addi	sp,sp,8
81141310:	f800283a 	ret

81141314 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
81141314:	deffee04 	addi	sp,sp,-72
81141318:	de00012e 	bgeu	sp,et,81141320 <OSTaskCreate+0xc>
8114131c:	003b68fa 	trap	3
81141320:	dfc01115 	stw	ra,68(sp)
81141324:	df001015 	stw	fp,64(sp)
81141328:	df001004 	addi	fp,sp,64
8114132c:	e13ffc15 	stw	r4,-16(fp)
81141330:	e17ffd15 	stw	r5,-12(fp)
81141334:	e1bffe15 	stw	r6,-8(fp)
81141338:	3805883a 	mov	r2,r7
8114133c:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
81141340:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
81141344:	e0bfff03 	ldbu	r2,-4(fp)
81141348:	10800af0 	cmpltui	r2,r2,43
8114134c:	1000021e 	bne	r2,zero,81141358 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
81141350:	00800a84 	movi	r2,42
81141354:	00005706 	br	811414b4 <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141358:	0005303a 	rdctl	r2,status
8114135c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141360:	e0fffb17 	ldw	r3,-20(fp)
81141364:	00bfff84 	movi	r2,-2
81141368:	1884703a 	and	r2,r3,r2
8114136c:	1001703a 	wrctl	status,r2
  
  return context;
81141370:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81141374:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
81141378:	d0a0a103 	ldbu	r2,-32124(gp)
8114137c:	10803fcc 	andi	r2,r2,255
81141380:	10000626 	beq	r2,zero,8114139c <OSTaskCreate+0x88>
81141384:	e0bff317 	ldw	r2,-52(fp)
81141388:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114138c:	e0bff417 	ldw	r2,-48(fp)
81141390:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
81141394:	00800f04 	movi	r2,60
81141398:	00004606 	br	811414b4 <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8114139c:	e0ffff03 	ldbu	r3,-4(fp)
811413a0:	00a045f4 	movhi	r2,33047
811413a4:	10ba6804 	addi	r2,r2,-5728
811413a8:	18c7883a 	add	r3,r3,r3
811413ac:	18c7883a 	add	r3,r3,r3
811413b0:	10c5883a 	add	r2,r2,r3
811413b4:	10800017 	ldw	r2,0(r2)
811413b8:	1000391e 	bne	r2,zero,811414a0 <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
811413bc:	e0ffff03 	ldbu	r3,-4(fp)
811413c0:	00a045f4 	movhi	r2,33047
811413c4:	10ba6804 	addi	r2,r2,-5728
811413c8:	18c7883a 	add	r3,r3,r3
811413cc:	18c7883a 	add	r3,r3,r3
811413d0:	10c5883a 	add	r2,r2,r3
811413d4:	00c00044 	movi	r3,1
811413d8:	10c00015 	stw	r3,0(r2)
811413dc:	e0bff317 	ldw	r2,-52(fp)
811413e0:	e0bff515 	stw	r2,-44(fp)
811413e4:	e0bff517 	ldw	r2,-44(fp)
811413e8:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
811413ec:	000f883a 	mov	r7,zero
811413f0:	e1bffe17 	ldw	r6,-8(fp)
811413f4:	e17ffd17 	ldw	r5,-12(fp)
811413f8:	e13ffc17 	ldw	r4,-16(fp)
811413fc:	114c9bc0 	call	8114c9bc <OSTaskStkInit>
81141400:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
81141404:	e0bfff03 	ldbu	r2,-4(fp)
81141408:	d8000215 	stw	zero,8(sp)
8114140c:	d8000115 	stw	zero,4(sp)
81141410:	d8000015 	stw	zero,0(sp)
81141414:	000f883a 	mov	r7,zero
81141418:	000d883a 	mov	r6,zero
8114141c:	e17ff717 	ldw	r5,-36(fp)
81141420:	1009883a 	mov	r4,r2
81141424:	113bcf40 	call	8113bcf4 <OS_TCBInit>
81141428:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
8114142c:	e0bff803 	ldbu	r2,-32(fp)
81141430:	1000061e 	bne	r2,zero,8114144c <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
81141434:	d0a09103 	ldbu	r2,-32188(gp)
81141438:	10803fcc 	andi	r2,r2,255
8114143c:	10800058 	cmpnei	r2,r2,1
81141440:	1000151e 	bne	r2,zero,81141498 <OSTaskCreate+0x184>
                OS_Sched();
81141444:	113b8ac0 	call	8113b8ac <OS_Sched>
81141448:	00001306 	br	81141498 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114144c:	0005303a 	rdctl	r2,status
81141450:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141454:	e0fffa17 	ldw	r3,-24(fp)
81141458:	00bfff84 	movi	r2,-2
8114145c:	1884703a 	and	r2,r3,r2
81141460:	1001703a 	wrctl	status,r2
  
  return context;
81141464:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81141468:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
8114146c:	e0ffff03 	ldbu	r3,-4(fp)
81141470:	00a045f4 	movhi	r2,33047
81141474:	10ba6804 	addi	r2,r2,-5728
81141478:	18c7883a 	add	r3,r3,r3
8114147c:	18c7883a 	add	r3,r3,r3
81141480:	10c5883a 	add	r2,r2,r3
81141484:	10000015 	stw	zero,0(r2)
81141488:	e0bff317 	ldw	r2,-52(fp)
8114148c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141490:	e0bff617 	ldw	r2,-40(fp)
81141494:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
81141498:	e0bff803 	ldbu	r2,-32(fp)
8114149c:	00000506 	br	811414b4 <OSTaskCreate+0x1a0>
811414a0:	e0bff317 	ldw	r2,-52(fp)
811414a4:	e0bff915 	stw	r2,-28(fp)
811414a8:	e0bff917 	ldw	r2,-28(fp)
811414ac:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
811414b0:	00800a04 	movi	r2,40
}
811414b4:	e037883a 	mov	sp,fp
811414b8:	dfc00117 	ldw	ra,4(sp)
811414bc:	df000017 	ldw	fp,0(sp)
811414c0:	dec00204 	addi	sp,sp,8
811414c4:	f800283a 	ret

811414c8 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
811414c8:	deffec04 	addi	sp,sp,-80
811414cc:	de00012e 	bgeu	sp,et,811414d4 <OSTaskCreateExt+0xc>
811414d0:	003b68fa 	trap	3
811414d4:	dfc01315 	stw	ra,76(sp)
811414d8:	df001215 	stw	fp,72(sp)
811414dc:	df001204 	addi	fp,sp,72
811414e0:	e13ffa15 	stw	r4,-24(fp)
811414e4:	e17ffb15 	stw	r5,-20(fp)
811414e8:	e1bffc15 	stw	r6,-16(fp)
811414ec:	3809883a 	mov	r4,r7
811414f0:	e0c00217 	ldw	r3,8(fp)
811414f4:	e0800617 	ldw	r2,24(fp)
811414f8:	e13ffd05 	stb	r4,-12(fp)
811414fc:	e0fffe0d 	sth	r3,-8(fp)
81141500:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
81141504:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
81141508:	e0bffd03 	ldbu	r2,-12(fp)
8114150c:	10800af0 	cmpltui	r2,r2,43
81141510:	1000021e 	bne	r2,zero,8114151c <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
81141514:	00800a84 	movi	r2,42
81141518:	00006106 	br	811416a0 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114151c:	0005303a 	rdctl	r2,status
81141520:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141524:	e0fff917 	ldw	r3,-28(fp)
81141528:	00bfff84 	movi	r2,-2
8114152c:	1884703a 	and	r2,r3,r2
81141530:	1001703a 	wrctl	status,r2
  
  return context;
81141534:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81141538:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8114153c:	d0a0a103 	ldbu	r2,-32124(gp)
81141540:	10803fcc 	andi	r2,r2,255
81141544:	10000626 	beq	r2,zero,81141560 <OSTaskCreateExt+0x98>
81141548:	e0bff117 	ldw	r2,-60(fp)
8114154c:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141550:	e0bff217 	ldw	r2,-56(fp)
81141554:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
81141558:	00800f04 	movi	r2,60
8114155c:	00005006 	br	811416a0 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
81141560:	e0fffd03 	ldbu	r3,-12(fp)
81141564:	00a045f4 	movhi	r2,33047
81141568:	10ba6804 	addi	r2,r2,-5728
8114156c:	18c7883a 	add	r3,r3,r3
81141570:	18c7883a 	add	r3,r3,r3
81141574:	10c5883a 	add	r2,r2,r3
81141578:	10800017 	ldw	r2,0(r2)
8114157c:	1000431e 	bne	r2,zero,8114168c <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
81141580:	e0fffd03 	ldbu	r3,-12(fp)
81141584:	00a045f4 	movhi	r2,33047
81141588:	10ba6804 	addi	r2,r2,-5728
8114158c:	18c7883a 	add	r3,r3,r3
81141590:	18c7883a 	add	r3,r3,r3
81141594:	10c5883a 	add	r2,r2,r3
81141598:	00c00044 	movi	r3,1
8114159c:	10c00015 	stw	r3,0(r2)
811415a0:	e0bff117 	ldw	r2,-60(fp)
811415a4:	e0bff315 	stw	r2,-52(fp)
811415a8:	e0bff317 	ldw	r2,-52(fp)
811415ac:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
811415b0:	e0bfff0b 	ldhu	r2,-4(fp)
811415b4:	100d883a 	mov	r6,r2
811415b8:	e1400417 	ldw	r5,16(fp)
811415bc:	e1000317 	ldw	r4,12(fp)
811415c0:	11425700 	call	81142570 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
811415c4:	e0bfff0b 	ldhu	r2,-4(fp)
811415c8:	100f883a 	mov	r7,r2
811415cc:	e1bffc17 	ldw	r6,-16(fp)
811415d0:	e17ffb17 	ldw	r5,-20(fp)
811415d4:	e13ffa17 	ldw	r4,-24(fp)
811415d8:	114c9bc0 	call	8114c9bc <OSTaskStkInit>
811415dc:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
811415e0:	e0fffd03 	ldbu	r3,-12(fp)
811415e4:	e13ffe0b 	ldhu	r4,-8(fp)
811415e8:	e0bfff0b 	ldhu	r2,-4(fp)
811415ec:	d8800215 	stw	r2,8(sp)
811415f0:	e0800517 	ldw	r2,20(fp)
811415f4:	d8800115 	stw	r2,4(sp)
811415f8:	e0800417 	ldw	r2,16(fp)
811415fc:	d8800015 	stw	r2,0(sp)
81141600:	200f883a 	mov	r7,r4
81141604:	e1800317 	ldw	r6,12(fp)
81141608:	e17ff517 	ldw	r5,-44(fp)
8114160c:	1809883a 	mov	r4,r3
81141610:	113bcf40 	call	8113bcf4 <OS_TCBInit>
81141614:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
81141618:	e0bff603 	ldbu	r2,-40(fp)
8114161c:	1000061e 	bne	r2,zero,81141638 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
81141620:	d0a09103 	ldbu	r2,-32188(gp)
81141624:	10803fcc 	andi	r2,r2,255
81141628:	10800058 	cmpnei	r2,r2,1
8114162c:	1000151e 	bne	r2,zero,81141684 <OSTaskCreateExt+0x1bc>
                OS_Sched();
81141630:	113b8ac0 	call	8113b8ac <OS_Sched>
81141634:	00001306 	br	81141684 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141638:	0005303a 	rdctl	r2,status
8114163c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141640:	e0fff817 	ldw	r3,-32(fp)
81141644:	00bfff84 	movi	r2,-2
81141648:	1884703a 	and	r2,r3,r2
8114164c:	1001703a 	wrctl	status,r2
  
  return context;
81141650:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81141654:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
81141658:	e0fffd03 	ldbu	r3,-12(fp)
8114165c:	00a045f4 	movhi	r2,33047
81141660:	10ba6804 	addi	r2,r2,-5728
81141664:	18c7883a 	add	r3,r3,r3
81141668:	18c7883a 	add	r3,r3,r3
8114166c:	10c5883a 	add	r2,r2,r3
81141670:	10000015 	stw	zero,0(r2)
81141674:	e0bff117 	ldw	r2,-60(fp)
81141678:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114167c:	e0bff417 	ldw	r2,-48(fp)
81141680:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
81141684:	e0bff603 	ldbu	r2,-40(fp)
81141688:	00000506 	br	811416a0 <OSTaskCreateExt+0x1d8>
8114168c:	e0bff117 	ldw	r2,-60(fp)
81141690:	e0bff715 	stw	r2,-36(fp)
81141694:	e0bff717 	ldw	r2,-36(fp)
81141698:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8114169c:	00800a04 	movi	r2,40
}
811416a0:	e037883a 	mov	sp,fp
811416a4:	dfc00117 	ldw	ra,4(sp)
811416a8:	df000017 	ldw	fp,0(sp)
811416ac:	dec00204 	addi	sp,sp,8
811416b0:	f800283a 	ret

811416b4 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
811416b4:	defff404 	addi	sp,sp,-48
811416b8:	de00012e 	bgeu	sp,et,811416c0 <OSTaskDel+0xc>
811416bc:	003b68fa 	trap	3
811416c0:	dfc00b15 	stw	ra,44(sp)
811416c4:	df000a15 	stw	fp,40(sp)
811416c8:	df000a04 	addi	fp,sp,40
811416cc:	2005883a 	mov	r2,r4
811416d0:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
811416d4:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
811416d8:	d0a0a103 	ldbu	r2,-32124(gp)
811416dc:	10803fcc 	andi	r2,r2,255
811416e0:	10000226 	beq	r2,zero,811416ec <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
811416e4:	00801004 	movi	r2,64
811416e8:	0000c006 	br	811419ec <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
811416ec:	e0bfff03 	ldbu	r2,-4(fp)
811416f0:	10800a98 	cmpnei	r2,r2,42
811416f4:	1000021e 	bne	r2,zero,81141700 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
811416f8:	00800f84 	movi	r2,62
811416fc:	0000bb06 	br	811419ec <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
81141700:	e0bfff03 	ldbu	r2,-4(fp)
81141704:	10800ab0 	cmpltui	r2,r2,42
81141708:	1000051e 	bne	r2,zero,81141720 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8114170c:	e0bfff03 	ldbu	r2,-4(fp)
81141710:	10803fe0 	cmpeqi	r2,r2,255
81141714:	1000021e 	bne	r2,zero,81141720 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
81141718:	00800a84 	movi	r2,42
8114171c:	0000b306 	br	811419ec <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141720:	0005303a 	rdctl	r2,status
81141724:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141728:	e0fffe17 	ldw	r3,-8(fp)
8114172c:	00bfff84 	movi	r2,-2
81141730:	1884703a 	and	r2,r3,r2
81141734:	1001703a 	wrctl	status,r2
  
  return context;
81141738:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8114173c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
81141740:	e0bfff03 	ldbu	r2,-4(fp)
81141744:	10803fd8 	cmpnei	r2,r2,255
81141748:	1000031e 	bne	r2,zero,81141758 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8114174c:	d0a0a217 	ldw	r2,-32120(gp)
81141750:	10800c83 	ldbu	r2,50(r2)
81141754:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81141758:	e0ffff03 	ldbu	r3,-4(fp)
8114175c:	00a045f4 	movhi	r2,33047
81141760:	10ba6804 	addi	r2,r2,-5728
81141764:	18c7883a 	add	r3,r3,r3
81141768:	18c7883a 	add	r3,r3,r3
8114176c:	10c5883a 	add	r2,r2,r3
81141770:	10800017 	ldw	r2,0(r2)
81141774:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
81141778:	e0bff817 	ldw	r2,-32(fp)
8114177c:	1000061e 	bne	r2,zero,81141798 <OSTaskDel+0xe4>
81141780:	e0bff617 	ldw	r2,-40(fp)
81141784:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141788:	e0bff717 	ldw	r2,-36(fp)
8114178c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81141790:	008010c4 	movi	r2,67
81141794:	00009506 	br	811419ec <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
81141798:	e0bff817 	ldw	r2,-32(fp)
8114179c:	10800058 	cmpnei	r2,r2,1
811417a0:	1000061e 	bne	r2,zero,811417bc <OSTaskDel+0x108>
811417a4:	e0bff617 	ldw	r2,-40(fp)
811417a8:	e0bff915 	stw	r2,-28(fp)
811417ac:	e0bff917 	ldw	r2,-28(fp)
811417b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
811417b4:	00800f44 	movi	r2,61
811417b8:	00008c06 	br	811419ec <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
811417bc:	e0bff817 	ldw	r2,-32(fp)
811417c0:	10800d03 	ldbu	r2,52(r2)
811417c4:	10c03fcc 	andi	r3,r2,255
811417c8:	e0bff817 	ldw	r2,-32(fp)
811417cc:	10800d03 	ldbu	r2,52(r2)
811417d0:	11003fcc 	andi	r4,r2,255
811417d4:	d0a09e44 	addi	r2,gp,-32135
811417d8:	2085883a 	add	r2,r4,r2
811417dc:	10800003 	ldbu	r2,0(r2)
811417e0:	1009883a 	mov	r4,r2
811417e4:	e0bff817 	ldw	r2,-32(fp)
811417e8:	10800d43 	ldbu	r2,53(r2)
811417ec:	0084303a 	nor	r2,zero,r2
811417f0:	2084703a 	and	r2,r4,r2
811417f4:	1009883a 	mov	r4,r2
811417f8:	d0a09e44 	addi	r2,gp,-32135
811417fc:	1885883a 	add	r2,r3,r2
81141800:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
81141804:	e0bff817 	ldw	r2,-32(fp)
81141808:	10800d03 	ldbu	r2,52(r2)
8114180c:	10c03fcc 	andi	r3,r2,255
81141810:	d0a09e44 	addi	r2,gp,-32135
81141814:	1885883a 	add	r2,r3,r2
81141818:	10800003 	ldbu	r2,0(r2)
8114181c:	10803fcc 	andi	r2,r2,255
81141820:	1000071e 	bne	r2,zero,81141840 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
81141824:	e0bff817 	ldw	r2,-32(fp)
81141828:	10800d83 	ldbu	r2,54(r2)
8114182c:	0084303a 	nor	r2,zero,r2
81141830:	1007883a 	mov	r3,r2
81141834:	d0a09e03 	ldbu	r2,-32136(gp)
81141838:	1884703a 	and	r2,r3,r2
8114183c:	d0a09e05 	stb	r2,-32136(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
81141840:	e0bff817 	ldw	r2,-32(fp)
81141844:	10800717 	ldw	r2,28(r2)
81141848:	10000526 	beq	r2,zero,81141860 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8114184c:	e0bff817 	ldw	r2,-32(fp)
81141850:	10800717 	ldw	r2,28(r2)
81141854:	100b883a 	mov	r5,r2
81141858:	e13ff817 	ldw	r4,-32(fp)
8114185c:	113b2000 	call	8113b200 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
81141860:	e0bff817 	ldw	r2,-32(fp)
81141864:	10800817 	ldw	r2,32(r2)
81141868:	10000526 	beq	r2,zero,81141880 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8114186c:	e0bff817 	ldw	r2,-32(fp)
81141870:	10800817 	ldw	r2,32(r2)
81141874:	100b883a 	mov	r5,r2
81141878:	e13ff817 	ldw	r4,-32(fp)
8114187c:	113b2c00 	call	8113b2c0 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
81141880:	e0bff817 	ldw	r2,-32(fp)
81141884:	10800a17 	ldw	r2,40(r2)
81141888:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
8114188c:	e0bffb17 	ldw	r2,-20(fp)
81141890:	10000226 	beq	r2,zero,8114189c <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
81141894:	e13ffb17 	ldw	r4,-20(fp)
81141898:	113d8980 	call	8113d898 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
8114189c:	e0bff817 	ldw	r2,-32(fp)
811418a0:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
811418a4:	e0bff817 	ldw	r2,-32(fp)
811418a8:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
811418ac:	e0bff817 	ldw	r2,-32(fp)
811418b0:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
811418b4:	d0a08f03 	ldbu	r2,-32196(gp)
811418b8:	10803fcc 	andi	r2,r2,255
811418bc:	10803fe0 	cmpeqi	r2,r2,255
811418c0:	1000031e 	bne	r2,zero,811418d0 <OSTaskDel+0x21c>
        OSLockNesting++;
811418c4:	d0a08f03 	ldbu	r2,-32196(gp)
811418c8:	10800044 	addi	r2,r2,1
811418cc:	d0a08f05 	stb	r2,-32196(gp)
811418d0:	e0bff617 	ldw	r2,-40(fp)
811418d4:	e0bffd15 	stw	r2,-12(fp)
811418d8:	e0bffd17 	ldw	r2,-12(fp)
811418dc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
811418e0:	113adc80 	call	8113adc8 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811418e4:	0005303a 	rdctl	r2,status
811418e8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811418ec:	e0fffa17 	ldw	r3,-24(fp)
811418f0:	00bfff84 	movi	r2,-2
811418f4:	1884703a 	and	r2,r3,r2
811418f8:	1001703a 	wrctl	status,r2
  
  return context;
811418fc:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
81141900:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
81141904:	d0a08f03 	ldbu	r2,-32196(gp)
81141908:	10803fcc 	andi	r2,r2,255
8114190c:	10000326 	beq	r2,zero,8114191c <OSTaskDel+0x268>
        OSLockNesting--;
81141910:	d0a08f03 	ldbu	r2,-32196(gp)
81141914:	10bfffc4 	addi	r2,r2,-1
81141918:	d0a08f05 	stb	r2,-32196(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8114191c:	e13ff817 	ldw	r4,-32(fp)
81141920:	114cb4c0 	call	8114cb4c <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
81141924:	d0a09a43 	ldbu	r2,-32151(gp)
81141928:	10bfffc4 	addi	r2,r2,-1
8114192c:	d0a09a45 	stb	r2,-32151(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
81141930:	e0ffff03 	ldbu	r3,-4(fp)
81141934:	00a045f4 	movhi	r2,33047
81141938:	10ba6804 	addi	r2,r2,-5728
8114193c:	18c7883a 	add	r3,r3,r3
81141940:	18c7883a 	add	r3,r3,r3
81141944:	10c5883a 	add	r2,r2,r3
81141948:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8114194c:	e0bff817 	ldw	r2,-32(fp)
81141950:	10800617 	ldw	r2,24(r2)
81141954:	1000071e 	bne	r2,zero,81141974 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
81141958:	e0bff817 	ldw	r2,-32(fp)
8114195c:	10800517 	ldw	r2,20(r2)
81141960:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
81141964:	e0bff817 	ldw	r2,-32(fp)
81141968:	10800517 	ldw	r2,20(r2)
8114196c:	d0a09415 	stw	r2,-32176(gp)
81141970:	00000a06 	br	8114199c <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
81141974:	e0bff817 	ldw	r2,-32(fp)
81141978:	10800617 	ldw	r2,24(r2)
8114197c:	e0fff817 	ldw	r3,-32(fp)
81141980:	18c00517 	ldw	r3,20(r3)
81141984:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
81141988:	e0bff817 	ldw	r2,-32(fp)
8114198c:	10800517 	ldw	r2,20(r2)
81141990:	e0fff817 	ldw	r3,-32(fp)
81141994:	18c00617 	ldw	r3,24(r3)
81141998:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8114199c:	d0e09917 	ldw	r3,-32156(gp)
811419a0:	e0bff817 	ldw	r2,-32(fp)
811419a4:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
811419a8:	e0bff817 	ldw	r2,-32(fp)
811419ac:	d0a09915 	stw	r2,-32156(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
811419b0:	e0bff817 	ldw	r2,-32(fp)
811419b4:	00c00fc4 	movi	r3,63
811419b8:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
811419bc:	e0bff817 	ldw	r2,-32(fp)
811419c0:	10001345 	stb	zero,77(r2)
811419c4:	e0bff617 	ldw	r2,-40(fp)
811419c8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811419cc:	e0bffc17 	ldw	r2,-16(fp)
811419d0:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
811419d4:	d0a09103 	ldbu	r2,-32188(gp)
811419d8:	10803fcc 	andi	r2,r2,255
811419dc:	10800058 	cmpnei	r2,r2,1
811419e0:	1000011e 	bne	r2,zero,811419e8 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
811419e4:	113b8ac0 	call	8113b8ac <OS_Sched>
    }
    return (OS_ERR_NONE);
811419e8:	0005883a 	mov	r2,zero
}
811419ec:	e037883a 	mov	sp,fp
811419f0:	dfc00117 	ldw	ra,4(sp)
811419f4:	df000017 	ldw	fp,0(sp)
811419f8:	dec00204 	addi	sp,sp,8
811419fc:	f800283a 	ret

81141a00 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
81141a00:	defff504 	addi	sp,sp,-44
81141a04:	de00012e 	bgeu	sp,et,81141a0c <OSTaskDelReq+0xc>
81141a08:	003b68fa 	trap	3
81141a0c:	df000a15 	stw	fp,40(sp)
81141a10:	df000a04 	addi	fp,sp,40
81141a14:	2005883a 	mov	r2,r4
81141a18:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81141a1c:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
81141a20:	e0bfff03 	ldbu	r2,-4(fp)
81141a24:	10800a98 	cmpnei	r2,r2,42
81141a28:	1000021e 	bne	r2,zero,81141a34 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
81141a2c:	00800f84 	movi	r2,62
81141a30:	00004506 	br	81141b48 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
81141a34:	e0bfff03 	ldbu	r2,-4(fp)
81141a38:	10800ab0 	cmpltui	r2,r2,42
81141a3c:	1000051e 	bne	r2,zero,81141a54 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
81141a40:	e0bfff03 	ldbu	r2,-4(fp)
81141a44:	10803fe0 	cmpeqi	r2,r2,255
81141a48:	1000021e 	bne	r2,zero,81141a54 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
81141a4c:	00800a84 	movi	r2,42
81141a50:	00003d06 	br	81141b48 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
81141a54:	e0bfff03 	ldbu	r2,-4(fp)
81141a58:	10803fd8 	cmpnei	r2,r2,255
81141a5c:	1000111e 	bne	r2,zero,81141aa4 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141a60:	0005303a 	rdctl	r2,status
81141a64:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141a68:	e0fff917 	ldw	r3,-28(fp)
81141a6c:	00bfff84 	movi	r2,-2
81141a70:	1884703a 	and	r2,r3,r2
81141a74:	1001703a 	wrctl	status,r2
  
  return context;
81141a78:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
81141a7c:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
81141a80:	d0a0a217 	ldw	r2,-32120(gp)
81141a84:	10800dc3 	ldbu	r2,55(r2)
81141a88:	e0bff805 	stb	r2,-32(fp)
81141a8c:	e0bff617 	ldw	r2,-40(fp)
81141a90:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141a94:	e0bffe17 	ldw	r2,-8(fp)
81141a98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
81141a9c:	e0bff803 	ldbu	r2,-32(fp)
81141aa0:	00002906 	br	81141b48 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141aa4:	0005303a 	rdctl	r2,status
81141aa8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141aac:	e0fff717 	ldw	r3,-36(fp)
81141ab0:	00bfff84 	movi	r2,-2
81141ab4:	1884703a 	and	r2,r3,r2
81141ab8:	1001703a 	wrctl	status,r2
  
  return context;
81141abc:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
81141ac0:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
81141ac4:	e0ffff03 	ldbu	r3,-4(fp)
81141ac8:	00a045f4 	movhi	r2,33047
81141acc:	10ba6804 	addi	r2,r2,-5728
81141ad0:	18c7883a 	add	r3,r3,r3
81141ad4:	18c7883a 	add	r3,r3,r3
81141ad8:	10c5883a 	add	r2,r2,r3
81141adc:	10800017 	ldw	r2,0(r2)
81141ae0:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
81141ae4:	e0bffb17 	ldw	r2,-20(fp)
81141ae8:	1000061e 	bne	r2,zero,81141b04 <OSTaskDelReq+0x104>
81141aec:	e0bff617 	ldw	r2,-40(fp)
81141af0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141af4:	e0bffa17 	ldw	r2,-24(fp)
81141af8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
81141afc:	008010c4 	movi	r2,67
81141b00:	00001106 	br	81141b48 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
81141b04:	e0bffb17 	ldw	r2,-20(fp)
81141b08:	10800058 	cmpnei	r2,r2,1
81141b0c:	1000061e 	bne	r2,zero,81141b28 <OSTaskDelReq+0x128>
81141b10:	e0bff617 	ldw	r2,-40(fp)
81141b14:	e0bffc15 	stw	r2,-16(fp)
81141b18:	e0bffc17 	ldw	r2,-16(fp)
81141b1c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81141b20:	00800f44 	movi	r2,61
81141b24:	00000806 	br	81141b48 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
81141b28:	e0bffb17 	ldw	r2,-20(fp)
81141b2c:	00c00fc4 	movi	r3,63
81141b30:	10c00dc5 	stb	r3,55(r2)
81141b34:	e0bff617 	ldw	r2,-40(fp)
81141b38:	e0bffd15 	stw	r2,-12(fp)
81141b3c:	e0bffd17 	ldw	r2,-12(fp)
81141b40:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81141b44:	0005883a 	mov	r2,zero
}
81141b48:	e037883a 	mov	sp,fp
81141b4c:	df000017 	ldw	fp,0(sp)
81141b50:	dec00104 	addi	sp,sp,4
81141b54:	f800283a 	ret

81141b58 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
81141b58:	defff404 	addi	sp,sp,-48
81141b5c:	de00012e 	bgeu	sp,et,81141b64 <OSTaskNameGet+0xc>
81141b60:	003b68fa 	trap	3
81141b64:	dfc00b15 	stw	ra,44(sp)
81141b68:	df000a15 	stw	fp,40(sp)
81141b6c:	df000a04 	addi	fp,sp,40
81141b70:	2005883a 	mov	r2,r4
81141b74:	e17ffe15 	stw	r5,-8(fp)
81141b78:	e1bfff15 	stw	r6,-4(fp)
81141b7c:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
81141b80:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
81141b84:	e0bfff17 	ldw	r2,-4(fp)
81141b88:	1000021e 	bne	r2,zero,81141b94 <OSTaskNameGet+0x3c>
        return (0);
81141b8c:	0005883a 	mov	r2,zero
81141b90:	00005406 	br	81141ce4 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
81141b94:	e0bffd03 	ldbu	r2,-12(fp)
81141b98:	10800af0 	cmpltui	r2,r2,43
81141b9c:	1000081e 	bne	r2,zero,81141bc0 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
81141ba0:	e0bffd03 	ldbu	r2,-12(fp)
81141ba4:	10803fe0 	cmpeqi	r2,r2,255
81141ba8:	1000051e 	bne	r2,zero,81141bc0 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
81141bac:	e0bfff17 	ldw	r2,-4(fp)
81141bb0:	00c00a84 	movi	r3,42
81141bb4:	10c00005 	stb	r3,0(r2)
            return (0);
81141bb8:	0005883a 	mov	r2,zero
81141bbc:	00004906 	br	81141ce4 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
81141bc0:	e0bffe17 	ldw	r2,-8(fp)
81141bc4:	1000051e 	bne	r2,zero,81141bdc <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
81141bc8:	e0bfff17 	ldw	r2,-4(fp)
81141bcc:	00c00304 	movi	r3,12
81141bd0:	10c00005 	stb	r3,0(r2)
        return (0);
81141bd4:	0005883a 	mov	r2,zero
81141bd8:	00004206 	br	81141ce4 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
81141bdc:	d0a0a103 	ldbu	r2,-32124(gp)
81141be0:	10803fcc 	andi	r2,r2,255
81141be4:	10000526 	beq	r2,zero,81141bfc <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
81141be8:	e0bfff17 	ldw	r2,-4(fp)
81141bec:	00c00444 	movi	r3,17
81141bf0:	10c00005 	stb	r3,0(r2)
        return (0);
81141bf4:	0005883a 	mov	r2,zero
81141bf8:	00003a06 	br	81141ce4 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141bfc:	0005303a 	rdctl	r2,status
81141c00:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141c04:	e0fffc17 	ldw	r3,-16(fp)
81141c08:	00bfff84 	movi	r2,-2
81141c0c:	1884703a 	and	r2,r3,r2
81141c10:	1001703a 	wrctl	status,r2
  
  return context;
81141c14:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81141c18:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
81141c1c:	e0bffd03 	ldbu	r2,-12(fp)
81141c20:	10803fd8 	cmpnei	r2,r2,255
81141c24:	1000031e 	bne	r2,zero,81141c34 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
81141c28:	d0a0a217 	ldw	r2,-32120(gp)
81141c2c:	10800c83 	ldbu	r2,50(r2)
81141c30:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81141c34:	e0fffd03 	ldbu	r3,-12(fp)
81141c38:	00a045f4 	movhi	r2,33047
81141c3c:	10ba6804 	addi	r2,r2,-5728
81141c40:	18c7883a 	add	r3,r3,r3
81141c44:	18c7883a 	add	r3,r3,r3
81141c48:	10c5883a 	add	r2,r2,r3
81141c4c:	10800017 	ldw	r2,0(r2)
81141c50:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
81141c54:	e0bff817 	ldw	r2,-32(fp)
81141c58:	1000091e 	bne	r2,zero,81141c80 <OSTaskNameGet+0x128>
81141c5c:	e0bff617 	ldw	r2,-40(fp)
81141c60:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141c64:	e0bff717 	ldw	r2,-36(fp)
81141c68:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
81141c6c:	e0bfff17 	ldw	r2,-4(fp)
81141c70:	00c010c4 	movi	r3,67
81141c74:	10c00005 	stb	r3,0(r2)
        return (0);
81141c78:	0005883a 	mov	r2,zero
81141c7c:	00001906 	br	81141ce4 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
81141c80:	e0bff817 	ldw	r2,-32(fp)
81141c84:	10800058 	cmpnei	r2,r2,1
81141c88:	1000091e 	bne	r2,zero,81141cb0 <OSTaskNameGet+0x158>
81141c8c:	e0bff617 	ldw	r2,-40(fp)
81141c90:	e0bff915 	stw	r2,-28(fp)
81141c94:	e0bff917 	ldw	r2,-28(fp)
81141c98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
81141c9c:	e0bfff17 	ldw	r2,-4(fp)
81141ca0:	00c010c4 	movi	r3,67
81141ca4:	10c00005 	stb	r3,0(r2)
        return (0);
81141ca8:	0005883a 	mov	r2,zero
81141cac:	00000d06 	br	81141ce4 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
81141cb0:	e0bff817 	ldw	r2,-32(fp)
81141cb4:	10801304 	addi	r2,r2,76
81141cb8:	100b883a 	mov	r5,r2
81141cbc:	e13ffe17 	ldw	r4,-8(fp)
81141cc0:	113ba000 	call	8113ba00 <OS_StrCopy>
81141cc4:	e0bffb05 	stb	r2,-20(fp)
81141cc8:	e0bff617 	ldw	r2,-40(fp)
81141ccc:	e0bffa15 	stw	r2,-24(fp)
81141cd0:	e0bffa17 	ldw	r2,-24(fp)
81141cd4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81141cd8:	e0bfff17 	ldw	r2,-4(fp)
81141cdc:	10000005 	stb	zero,0(r2)
    return (len);
81141ce0:	e0bffb03 	ldbu	r2,-20(fp)
}
81141ce4:	e037883a 	mov	sp,fp
81141ce8:	dfc00117 	ldw	ra,4(sp)
81141cec:	df000017 	ldw	fp,0(sp)
81141cf0:	dec00204 	addi	sp,sp,8
81141cf4:	f800283a 	ret

81141cf8 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
81141cf8:	defff304 	addi	sp,sp,-52
81141cfc:	de00012e 	bgeu	sp,et,81141d04 <OSTaskNameSet+0xc>
81141d00:	003b68fa 	trap	3
81141d04:	dfc00c15 	stw	ra,48(sp)
81141d08:	df000b15 	stw	fp,44(sp)
81141d0c:	df000b04 	addi	fp,sp,44
81141d10:	2005883a 	mov	r2,r4
81141d14:	e17ffe15 	stw	r5,-8(fp)
81141d18:	e1bfff15 	stw	r6,-4(fp)
81141d1c:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
81141d20:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
81141d24:	e0bfff17 	ldw	r2,-4(fp)
81141d28:	10005c26 	beq	r2,zero,81141e9c <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
81141d2c:	e0bffd03 	ldbu	r2,-12(fp)
81141d30:	10800af0 	cmpltui	r2,r2,43
81141d34:	1000071e 	bne	r2,zero,81141d54 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
81141d38:	e0bffd03 	ldbu	r2,-12(fp)
81141d3c:	10803fe0 	cmpeqi	r2,r2,255
81141d40:	1000041e 	bne	r2,zero,81141d54 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
81141d44:	e0bfff17 	ldw	r2,-4(fp)
81141d48:	00c00a84 	movi	r3,42
81141d4c:	10c00005 	stb	r3,0(r2)
            return;
81141d50:	00005306 	br	81141ea0 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
81141d54:	e0bffe17 	ldw	r2,-8(fp)
81141d58:	1000041e 	bne	r2,zero,81141d6c <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
81141d5c:	e0bfff17 	ldw	r2,-4(fp)
81141d60:	00c00304 	movi	r3,12
81141d64:	10c00005 	stb	r3,0(r2)
        return;
81141d68:	00004d06 	br	81141ea0 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
81141d6c:	d0a0a103 	ldbu	r2,-32124(gp)
81141d70:	10803fcc 	andi	r2,r2,255
81141d74:	10000426 	beq	r2,zero,81141d88 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
81141d78:	e0bfff17 	ldw	r2,-4(fp)
81141d7c:	00c00484 	movi	r3,18
81141d80:	10c00005 	stb	r3,0(r2)
        return;
81141d84:	00004606 	br	81141ea0 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141d88:	0005303a 	rdctl	r2,status
81141d8c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141d90:	e0fffc17 	ldw	r3,-16(fp)
81141d94:	00bfff84 	movi	r2,-2
81141d98:	1884703a 	and	r2,r3,r2
81141d9c:	1001703a 	wrctl	status,r2
  
  return context;
81141da0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81141da4:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
81141da8:	e0bffd03 	ldbu	r2,-12(fp)
81141dac:	10803fd8 	cmpnei	r2,r2,255
81141db0:	1000031e 	bne	r2,zero,81141dc0 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
81141db4:	d0a0a217 	ldw	r2,-32120(gp)
81141db8:	10800c83 	ldbu	r2,50(r2)
81141dbc:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81141dc0:	e0fffd03 	ldbu	r3,-12(fp)
81141dc4:	00a045f4 	movhi	r2,33047
81141dc8:	10ba6804 	addi	r2,r2,-5728
81141dcc:	18c7883a 	add	r3,r3,r3
81141dd0:	18c7883a 	add	r3,r3,r3
81141dd4:	10c5883a 	add	r2,r2,r3
81141dd8:	10800017 	ldw	r2,0(r2)
81141ddc:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
81141de0:	e0bff717 	ldw	r2,-36(fp)
81141de4:	1000081e 	bne	r2,zero,81141e08 <OSTaskNameSet+0x110>
81141de8:	e0bff517 	ldw	r2,-44(fp)
81141dec:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141df0:	e0bff617 	ldw	r2,-40(fp)
81141df4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
81141df8:	e0bfff17 	ldw	r2,-4(fp)
81141dfc:	00c010c4 	movi	r3,67
81141e00:	10c00005 	stb	r3,0(r2)
        return;
81141e04:	00002606 	br	81141ea0 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
81141e08:	e0bff717 	ldw	r2,-36(fp)
81141e0c:	10800058 	cmpnei	r2,r2,1
81141e10:	1000081e 	bne	r2,zero,81141e34 <OSTaskNameSet+0x13c>
81141e14:	e0bff517 	ldw	r2,-44(fp)
81141e18:	e0bff815 	stw	r2,-32(fp)
81141e1c:	e0bff817 	ldw	r2,-32(fp)
81141e20:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
81141e24:	e0bfff17 	ldw	r2,-4(fp)
81141e28:	00c010c4 	movi	r3,67
81141e2c:	10c00005 	stb	r3,0(r2)
        return;
81141e30:	00001b06 	br	81141ea0 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
81141e34:	e13ffe17 	ldw	r4,-8(fp)
81141e38:	113ba7c0 	call	8113ba7c <OS_StrLen>
81141e3c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
81141e40:	e0bffa03 	ldbu	r2,-24(fp)
81141e44:	10800830 	cmpltui	r2,r2,32
81141e48:	1000081e 	bne	r2,zero,81141e6c <OSTaskNameSet+0x174>
81141e4c:	e0bff517 	ldw	r2,-44(fp)
81141e50:	e0bff915 	stw	r2,-28(fp)
81141e54:	e0bff917 	ldw	r2,-28(fp)
81141e58:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
81141e5c:	e0bfff17 	ldw	r2,-4(fp)
81141e60:	00c01044 	movi	r3,65
81141e64:	10c00005 	stb	r3,0(r2)
        return;
81141e68:	00000d06 	br	81141ea0 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
81141e6c:	e0bff717 	ldw	r2,-36(fp)
81141e70:	10801304 	addi	r2,r2,76
81141e74:	e17ffe17 	ldw	r5,-8(fp)
81141e78:	1009883a 	mov	r4,r2
81141e7c:	113ba000 	call	8113ba00 <OS_StrCopy>
81141e80:	e0bff517 	ldw	r2,-44(fp)
81141e84:	e0bffb15 	stw	r2,-20(fp)
81141e88:	e0bffb17 	ldw	r2,-20(fp)
81141e8c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81141e90:	e0bfff17 	ldw	r2,-4(fp)
81141e94:	10000005 	stb	zero,0(r2)
81141e98:	00000106 	br	81141ea0 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
81141e9c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81141ea0:	e037883a 	mov	sp,fp
81141ea4:	dfc00117 	ldw	ra,4(sp)
81141ea8:	df000017 	ldw	fp,0(sp)
81141eac:	dec00204 	addi	sp,sp,8
81141eb0:	f800283a 	ret

81141eb4 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
81141eb4:	defff404 	addi	sp,sp,-48
81141eb8:	de00012e 	bgeu	sp,et,81141ec0 <OSTaskResume+0xc>
81141ebc:	003b68fa 	trap	3
81141ec0:	dfc00b15 	stw	ra,44(sp)
81141ec4:	df000a15 	stw	fp,40(sp)
81141ec8:	df000a04 	addi	fp,sp,40
81141ecc:	2005883a 	mov	r2,r4
81141ed0:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
81141ed4:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
81141ed8:	e0bfff03 	ldbu	r2,-4(fp)
81141edc:	10800ab0 	cmpltui	r2,r2,42
81141ee0:	1000021e 	bne	r2,zero,81141eec <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81141ee4:	00800a84 	movi	r2,42
81141ee8:	00006406 	br	8114207c <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141eec:	0005303a 	rdctl	r2,status
81141ef0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141ef4:	e0fffe17 	ldw	r3,-8(fp)
81141ef8:	00bfff84 	movi	r2,-2
81141efc:	1884703a 	and	r2,r3,r2
81141f00:	1001703a 	wrctl	status,r2
  
  return context;
81141f04:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81141f08:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
81141f0c:	e0ffff03 	ldbu	r3,-4(fp)
81141f10:	00a045f4 	movhi	r2,33047
81141f14:	10ba6804 	addi	r2,r2,-5728
81141f18:	18c7883a 	add	r3,r3,r3
81141f1c:	18c7883a 	add	r3,r3,r3
81141f20:	10c5883a 	add	r2,r2,r3
81141f24:	10800017 	ldw	r2,0(r2)
81141f28:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
81141f2c:	e0bff817 	ldw	r2,-32(fp)
81141f30:	1000061e 	bne	r2,zero,81141f4c <OSTaskResume+0x98>
81141f34:	e0bff617 	ldw	r2,-40(fp)
81141f38:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141f3c:	e0bff717 	ldw	r2,-36(fp)
81141f40:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
81141f44:	00801184 	movi	r2,70
81141f48:	00004c06 	br	8114207c <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
81141f4c:	e0bff817 	ldw	r2,-32(fp)
81141f50:	10800058 	cmpnei	r2,r2,1
81141f54:	1000061e 	bne	r2,zero,81141f70 <OSTaskResume+0xbc>
81141f58:	e0bff617 	ldw	r2,-40(fp)
81141f5c:	e0bff915 	stw	r2,-28(fp)
81141f60:	e0bff917 	ldw	r2,-28(fp)
81141f64:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81141f68:	008010c4 	movi	r2,67
81141f6c:	00004306 	br	8114207c <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
81141f70:	e0bff817 	ldw	r2,-32(fp)
81141f74:	10800c03 	ldbu	r2,48(r2)
81141f78:	10803fcc 	andi	r2,r2,255
81141f7c:	1080020c 	andi	r2,r2,8
81141f80:	10003926 	beq	r2,zero,81142068 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
81141f84:	e0bff817 	ldw	r2,-32(fp)
81141f88:	10c00c03 	ldbu	r3,48(r2)
81141f8c:	00bffdc4 	movi	r2,-9
81141f90:	1884703a 	and	r2,r3,r2
81141f94:	1007883a 	mov	r3,r2
81141f98:	e0bff817 	ldw	r2,-32(fp)
81141f9c:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
81141fa0:	e0bff817 	ldw	r2,-32(fp)
81141fa4:	10800c03 	ldbu	r2,48(r2)
81141fa8:	10803fcc 	andi	r2,r2,255
81141fac:	1000281e 	bne	r2,zero,81142050 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
81141fb0:	e0bff817 	ldw	r2,-32(fp)
81141fb4:	10800b8b 	ldhu	r2,46(r2)
81141fb8:	10bfffcc 	andi	r2,r2,65535
81141fbc:	10001f1e 	bne	r2,zero,8114203c <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
81141fc0:	e0bff817 	ldw	r2,-32(fp)
81141fc4:	10c00d83 	ldbu	r3,54(r2)
81141fc8:	d0a09e03 	ldbu	r2,-32136(gp)
81141fcc:	1884b03a 	or	r2,r3,r2
81141fd0:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81141fd4:	e0bff817 	ldw	r2,-32(fp)
81141fd8:	10800d03 	ldbu	r2,52(r2)
81141fdc:	10c03fcc 	andi	r3,r2,255
81141fe0:	e0bff817 	ldw	r2,-32(fp)
81141fe4:	10800d03 	ldbu	r2,52(r2)
81141fe8:	11003fcc 	andi	r4,r2,255
81141fec:	d0a09e44 	addi	r2,gp,-32135
81141ff0:	2085883a 	add	r2,r4,r2
81141ff4:	11000003 	ldbu	r4,0(r2)
81141ff8:	e0bff817 	ldw	r2,-32(fp)
81141ffc:	10800d43 	ldbu	r2,53(r2)
81142000:	2084b03a 	or	r2,r4,r2
81142004:	1009883a 	mov	r4,r2
81142008:	d0a09e44 	addi	r2,gp,-32135
8114200c:	1885883a 	add	r2,r3,r2
81142010:	11000005 	stb	r4,0(r2)
81142014:	e0bff617 	ldw	r2,-40(fp)
81142018:	e0bffa15 	stw	r2,-24(fp)
8114201c:	e0bffa17 	ldw	r2,-24(fp)
81142020:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
81142024:	d0a09103 	ldbu	r2,-32188(gp)
81142028:	10803fcc 	andi	r2,r2,255
8114202c:	10800058 	cmpnei	r2,r2,1
81142030:	10000b1e 	bne	r2,zero,81142060 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
81142034:	113b8ac0 	call	8113b8ac <OS_Sched>
81142038:	00000906 	br	81142060 <OSTaskResume+0x1ac>
8114203c:	e0bff617 	ldw	r2,-40(fp)
81142040:	e0bffb15 	stw	r2,-20(fp)
81142044:	e0bffb17 	ldw	r2,-20(fp)
81142048:	1001703a 	wrctl	status,r2
8114204c:	00000406 	br	81142060 <OSTaskResume+0x1ac>
81142050:	e0bff617 	ldw	r2,-40(fp)
81142054:	e0bffc15 	stw	r2,-16(fp)
81142058:	e0bffc17 	ldw	r2,-16(fp)
8114205c:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
81142060:	0005883a 	mov	r2,zero
81142064:	00000506 	br	8114207c <OSTaskResume+0x1c8>
81142068:	e0bff617 	ldw	r2,-40(fp)
8114206c:	e0bffd15 	stw	r2,-12(fp)
81142070:	e0bffd17 	ldw	r2,-12(fp)
81142074:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
81142078:	00801104 	movi	r2,68
}
8114207c:	e037883a 	mov	sp,fp
81142080:	dfc00117 	ldw	ra,4(sp)
81142084:	df000017 	ldw	fp,0(sp)
81142088:	dec00204 	addi	sp,sp,8
8114208c:	f800283a 	ret

81142090 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
81142090:	defff304 	addi	sp,sp,-52
81142094:	de00012e 	bgeu	sp,et,8114209c <OSTaskStkChk+0xc>
81142098:	003b68fa 	trap	3
8114209c:	df000c15 	stw	fp,48(sp)
811420a0:	df000c04 	addi	fp,sp,48
811420a4:	2005883a 	mov	r2,r4
811420a8:	e17fff15 	stw	r5,-4(fp)
811420ac:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811420b0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
811420b4:	e0bffe03 	ldbu	r2,-8(fp)
811420b8:	10800af0 	cmpltui	r2,r2,43
811420bc:	1000051e 	bne	r2,zero,811420d4 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
811420c0:	e0bffe03 	ldbu	r2,-8(fp)
811420c4:	10803fe0 	cmpeqi	r2,r2,255
811420c8:	1000021e 	bne	r2,zero,811420d4 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
811420cc:	00800a84 	movi	r2,42
811420d0:	00005d06 	br	81142248 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
811420d4:	e0bfff17 	ldw	r2,-4(fp)
811420d8:	1000021e 	bne	r2,zero,811420e4 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
811420dc:	00800244 	movi	r2,9
811420e0:	00005906 	br	81142248 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
811420e4:	e0bfff17 	ldw	r2,-4(fp)
811420e8:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
811420ec:	e0bfff17 	ldw	r2,-4(fp)
811420f0:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811420f4:	0005303a 	rdctl	r2,status
811420f8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811420fc:	e0fffd17 	ldw	r3,-12(fp)
81142100:	00bfff84 	movi	r2,-2
81142104:	1884703a 	and	r2,r3,r2
81142108:	1001703a 	wrctl	status,r2
  
  return context;
8114210c:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
81142110:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
81142114:	e0bffe03 	ldbu	r2,-8(fp)
81142118:	10803fd8 	cmpnei	r2,r2,255
8114211c:	1000031e 	bne	r2,zero,8114212c <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
81142120:	d0a0a217 	ldw	r2,-32120(gp)
81142124:	10800c83 	ldbu	r2,50(r2)
81142128:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8114212c:	e0fffe03 	ldbu	r3,-8(fp)
81142130:	00a045f4 	movhi	r2,33047
81142134:	10ba6804 	addi	r2,r2,-5728
81142138:	18c7883a 	add	r3,r3,r3
8114213c:	18c7883a 	add	r3,r3,r3
81142140:	10c5883a 	add	r2,r2,r3
81142144:	10800017 	ldw	r2,0(r2)
81142148:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
8114214c:	e0bff817 	ldw	r2,-32(fp)
81142150:	1000061e 	bne	r2,zero,8114216c <OSTaskStkChk+0xdc>
81142154:	e0bff617 	ldw	r2,-40(fp)
81142158:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114215c:	e0bff717 	ldw	r2,-36(fp)
81142160:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81142164:	008010c4 	movi	r2,67
81142168:	00003706 	br	81142248 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8114216c:	e0bff817 	ldw	r2,-32(fp)
81142170:	10800058 	cmpnei	r2,r2,1
81142174:	1000061e 	bne	r2,zero,81142190 <OSTaskStkChk+0x100>
81142178:	e0bff617 	ldw	r2,-40(fp)
8114217c:	e0bff915 	stw	r2,-28(fp)
81142180:	e0bff917 	ldw	r2,-28(fp)
81142184:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81142188:	008010c4 	movi	r2,67
8114218c:	00002e06 	br	81142248 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
81142190:	e0bff817 	ldw	r2,-32(fp)
81142194:	1080040b 	ldhu	r2,16(r2)
81142198:	10bfffcc 	andi	r2,r2,65535
8114219c:	1080004c 	andi	r2,r2,1
811421a0:	1000061e 	bne	r2,zero,811421bc <OSTaskStkChk+0x12c>
811421a4:	e0bff617 	ldw	r2,-40(fp)
811421a8:	e0bffa15 	stw	r2,-24(fp)
811421ac:	e0bffa17 	ldw	r2,-24(fp)
811421b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
811421b4:	00801144 	movi	r2,69
811421b8:	00002306 	br	81142248 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
811421bc:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
811421c0:	e0bff817 	ldw	r2,-32(fp)
811421c4:	10800317 	ldw	r2,12(r2)
811421c8:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
811421cc:	e0bff817 	ldw	r2,-32(fp)
811421d0:	10800217 	ldw	r2,8(r2)
811421d4:	e0bff415 	stw	r2,-48(fp)
811421d8:	e0bff617 	ldw	r2,-40(fp)
811421dc:	e0bffb15 	stw	r2,-20(fp)
811421e0:	e0bffb17 	ldw	r2,-20(fp)
811421e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
811421e8:	00000306 	br	811421f8 <OSTaskStkChk+0x168>
        nfree++;
811421ec:	e0bff517 	ldw	r2,-44(fp)
811421f0:	10800044 	addi	r2,r2,1
811421f4:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
811421f8:	e0bff417 	ldw	r2,-48(fp)
811421fc:	10c00104 	addi	r3,r2,4
81142200:	e0fff415 	stw	r3,-48(fp)
81142204:	10800017 	ldw	r2,0(r2)
81142208:	103ff826 	beq	r2,zero,811421ec <__reset+0xfb1221ec>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8114220c:	e0bff517 	ldw	r2,-44(fp)
81142210:	1085883a 	add	r2,r2,r2
81142214:	1085883a 	add	r2,r2,r2
81142218:	1007883a 	mov	r3,r2
8114221c:	e0bfff17 	ldw	r2,-4(fp)
81142220:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
81142224:	e0fffc17 	ldw	r3,-16(fp)
81142228:	e0bff517 	ldw	r2,-44(fp)
8114222c:	1885c83a 	sub	r2,r3,r2
81142230:	1085883a 	add	r2,r2,r2
81142234:	1085883a 	add	r2,r2,r2
81142238:	1007883a 	mov	r3,r2
8114223c:	e0bfff17 	ldw	r2,-4(fp)
81142240:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
81142244:	0005883a 	mov	r2,zero
}
81142248:	e037883a 	mov	sp,fp
8114224c:	df000017 	ldw	fp,0(sp)
81142250:	dec00104 	addi	sp,sp,4
81142254:	f800283a 	ret

81142258 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
81142258:	defff504 	addi	sp,sp,-44
8114225c:	de00012e 	bgeu	sp,et,81142264 <OSTaskSuspend+0xc>
81142260:	003b68fa 	trap	3
81142264:	dfc00a15 	stw	ra,40(sp)
81142268:	df000915 	stw	fp,36(sp)
8114226c:	df000904 	addi	fp,sp,36
81142270:	2005883a 	mov	r2,r4
81142274:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81142278:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8114227c:	e0bfff03 	ldbu	r2,-4(fp)
81142280:	10800a98 	cmpnei	r2,r2,42
81142284:	1000021e 	bne	r2,zero,81142290 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
81142288:	008011c4 	movi	r2,71
8114228c:	00006806 	br	81142430 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
81142290:	e0bfff03 	ldbu	r2,-4(fp)
81142294:	10800ab0 	cmpltui	r2,r2,42
81142298:	1000051e 	bne	r2,zero,811422b0 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
8114229c:	e0bfff03 	ldbu	r2,-4(fp)
811422a0:	10803fe0 	cmpeqi	r2,r2,255
811422a4:	1000021e 	bne	r2,zero,811422b0 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
811422a8:	00800a84 	movi	r2,42
811422ac:	00006006 	br	81142430 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811422b0:	0005303a 	rdctl	r2,status
811422b4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811422b8:	e0fffe17 	ldw	r3,-8(fp)
811422bc:	00bfff84 	movi	r2,-2
811422c0:	1884703a 	and	r2,r3,r2
811422c4:	1001703a 	wrctl	status,r2
  
  return context;
811422c8:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
811422cc:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
811422d0:	e0bfff03 	ldbu	r2,-4(fp)
811422d4:	10803fd8 	cmpnei	r2,r2,255
811422d8:	1000061e 	bne	r2,zero,811422f4 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
811422dc:	d0a0a217 	ldw	r2,-32120(gp)
811422e0:	10800c83 	ldbu	r2,50(r2)
811422e4:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
811422e8:	00800044 	movi	r2,1
811422ec:	e0bff705 	stb	r2,-36(fp)
811422f0:	00000906 	br	81142318 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
811422f4:	d0a0a217 	ldw	r2,-32120(gp)
811422f8:	10800c83 	ldbu	r2,50(r2)
811422fc:	10c03fcc 	andi	r3,r2,255
81142300:	e0bfff03 	ldbu	r2,-4(fp)
81142304:	1880031e 	bne	r3,r2,81142314 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
81142308:	00800044 	movi	r2,1
8114230c:	e0bff705 	stb	r2,-36(fp)
81142310:	00000106 	br	81142318 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
81142314:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81142318:	e0ffff03 	ldbu	r3,-4(fp)
8114231c:	00a045f4 	movhi	r2,33047
81142320:	10ba6804 	addi	r2,r2,-5728
81142324:	18c7883a 	add	r3,r3,r3
81142328:	18c7883a 	add	r3,r3,r3
8114232c:	10c5883a 	add	r2,r2,r3
81142330:	10800017 	ldw	r2,0(r2)
81142334:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
81142338:	e0bffa17 	ldw	r2,-24(fp)
8114233c:	1000061e 	bne	r2,zero,81142358 <OSTaskSuspend+0x100>
81142340:	e0bff817 	ldw	r2,-32(fp)
81142344:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142348:	e0bff917 	ldw	r2,-28(fp)
8114234c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
81142350:	00801204 	movi	r2,72
81142354:	00003606 	br	81142430 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
81142358:	e0bffa17 	ldw	r2,-24(fp)
8114235c:	10800058 	cmpnei	r2,r2,1
81142360:	1000061e 	bne	r2,zero,8114237c <OSTaskSuspend+0x124>
81142364:	e0bff817 	ldw	r2,-32(fp)
81142368:	e0bffb15 	stw	r2,-20(fp)
8114236c:	e0bffb17 	ldw	r2,-20(fp)
81142370:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81142374:	008010c4 	movi	r2,67
81142378:	00002d06 	br	81142430 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
8114237c:	e0bffa17 	ldw	r2,-24(fp)
81142380:	10800d03 	ldbu	r2,52(r2)
81142384:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
81142388:	e0fffd03 	ldbu	r3,-12(fp)
8114238c:	e13ffd03 	ldbu	r4,-12(fp)
81142390:	d0a09e44 	addi	r2,gp,-32135
81142394:	2085883a 	add	r2,r4,r2
81142398:	10800003 	ldbu	r2,0(r2)
8114239c:	1009883a 	mov	r4,r2
811423a0:	e0bffa17 	ldw	r2,-24(fp)
811423a4:	10800d43 	ldbu	r2,53(r2)
811423a8:	0084303a 	nor	r2,zero,r2
811423ac:	2084703a 	and	r2,r4,r2
811423b0:	1009883a 	mov	r4,r2
811423b4:	d0a09e44 	addi	r2,gp,-32135
811423b8:	1885883a 	add	r2,r3,r2
811423bc:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
811423c0:	e0fffd03 	ldbu	r3,-12(fp)
811423c4:	d0a09e44 	addi	r2,gp,-32135
811423c8:	1885883a 	add	r2,r3,r2
811423cc:	10800003 	ldbu	r2,0(r2)
811423d0:	10803fcc 	andi	r2,r2,255
811423d4:	1000071e 	bne	r2,zero,811423f4 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
811423d8:	e0bffa17 	ldw	r2,-24(fp)
811423dc:	10800d83 	ldbu	r2,54(r2)
811423e0:	0084303a 	nor	r2,zero,r2
811423e4:	1007883a 	mov	r3,r2
811423e8:	d0a09e03 	ldbu	r2,-32136(gp)
811423ec:	1884703a 	and	r2,r3,r2
811423f0:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
811423f4:	e0bffa17 	ldw	r2,-24(fp)
811423f8:	10800c03 	ldbu	r2,48(r2)
811423fc:	10800214 	ori	r2,r2,8
81142400:	1007883a 	mov	r3,r2
81142404:	e0bffa17 	ldw	r2,-24(fp)
81142408:	10c00c05 	stb	r3,48(r2)
8114240c:	e0bff817 	ldw	r2,-32(fp)
81142410:	e0bffc15 	stw	r2,-16(fp)
81142414:	e0bffc17 	ldw	r2,-16(fp)
81142418:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
8114241c:	e0bff703 	ldbu	r2,-36(fp)
81142420:	10800058 	cmpnei	r2,r2,1
81142424:	1000011e 	bne	r2,zero,8114242c <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
81142428:	113b8ac0 	call	8113b8ac <OS_Sched>
    }
    return (OS_ERR_NONE);
8114242c:	0005883a 	mov	r2,zero
}
81142430:	e037883a 	mov	sp,fp
81142434:	dfc00117 	ldw	ra,4(sp)
81142438:	df000017 	ldw	fp,0(sp)
8114243c:	dec00204 	addi	sp,sp,8
81142440:	f800283a 	ret

81142444 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
81142444:	defff604 	addi	sp,sp,-40
81142448:	de00012e 	bgeu	sp,et,81142450 <OSTaskQuery+0xc>
8114244c:	003b68fa 	trap	3
81142450:	dfc00915 	stw	ra,36(sp)
81142454:	df000815 	stw	fp,32(sp)
81142458:	df000804 	addi	fp,sp,32
8114245c:	2005883a 	mov	r2,r4
81142460:	e17fff15 	stw	r5,-4(fp)
81142464:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81142468:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
8114246c:	e0bffe03 	ldbu	r2,-8(fp)
81142470:	10800af0 	cmpltui	r2,r2,43
81142474:	1000051e 	bne	r2,zero,8114248c <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
81142478:	e0bffe03 	ldbu	r2,-8(fp)
8114247c:	10803fe0 	cmpeqi	r2,r2,255
81142480:	1000021e 	bne	r2,zero,8114248c <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
81142484:	00800a84 	movi	r2,42
81142488:	00003406 	br	8114255c <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
8114248c:	e0bfff17 	ldw	r2,-4(fp)
81142490:	1000021e 	bne	r2,zero,8114249c <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
81142494:	00800244 	movi	r2,9
81142498:	00003006 	br	8114255c <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114249c:	0005303a 	rdctl	r2,status
811424a0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811424a4:	e0fffd17 	ldw	r3,-12(fp)
811424a8:	00bfff84 	movi	r2,-2
811424ac:	1884703a 	and	r2,r3,r2
811424b0:	1001703a 	wrctl	status,r2
  
  return context;
811424b4:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811424b8:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
811424bc:	e0bffe03 	ldbu	r2,-8(fp)
811424c0:	10803fd8 	cmpnei	r2,r2,255
811424c4:	1000031e 	bne	r2,zero,811424d4 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
811424c8:	d0a0a217 	ldw	r2,-32120(gp)
811424cc:	10800c83 	ldbu	r2,50(r2)
811424d0:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811424d4:	e0fffe03 	ldbu	r3,-8(fp)
811424d8:	00a045f4 	movhi	r2,33047
811424dc:	10ba6804 	addi	r2,r2,-5728
811424e0:	18c7883a 	add	r3,r3,r3
811424e4:	18c7883a 	add	r3,r3,r3
811424e8:	10c5883a 	add	r2,r2,r3
811424ec:	10800017 	ldw	r2,0(r2)
811424f0:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
811424f4:	e0bffa17 	ldw	r2,-24(fp)
811424f8:	1000061e 	bne	r2,zero,81142514 <OSTaskQuery+0xd0>
811424fc:	e0bff817 	ldw	r2,-32(fp)
81142500:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142504:	e0bff917 	ldw	r2,-28(fp)
81142508:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
8114250c:	00800a44 	movi	r2,41
81142510:	00001206 	br	8114255c <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
81142514:	e0bffa17 	ldw	r2,-24(fp)
81142518:	10800058 	cmpnei	r2,r2,1
8114251c:	1000061e 	bne	r2,zero,81142538 <OSTaskQuery+0xf4>
81142520:	e0bff817 	ldw	r2,-32(fp)
81142524:	e0bffb15 	stw	r2,-20(fp)
81142528:	e0bffb17 	ldw	r2,-20(fp)
8114252c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81142530:	008010c4 	movi	r2,67
81142534:	00000906 	br	8114255c <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
81142538:	01801b04 	movi	r6,108
8114253c:	e17ffa17 	ldw	r5,-24(fp)
81142540:	e13fff17 	ldw	r4,-4(fp)
81142544:	113b83c0 	call	8113b83c <OS_MemCopy>
81142548:	e0bff817 	ldw	r2,-32(fp)
8114254c:	e0bffc15 	stw	r2,-16(fp)
81142550:	e0bffc17 	ldw	r2,-16(fp)
81142554:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81142558:	0005883a 	mov	r2,zero
}
8114255c:	e037883a 	mov	sp,fp
81142560:	dfc00117 	ldw	ra,4(sp)
81142564:	df000017 	ldw	fp,0(sp)
81142568:	dec00204 	addi	sp,sp,8
8114256c:	f800283a 	ret

81142570 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
81142570:	defffc04 	addi	sp,sp,-16
81142574:	de00012e 	bgeu	sp,et,8114257c <OS_TaskStkClr+0xc>
81142578:	003b68fa 	trap	3
8114257c:	df000315 	stw	fp,12(sp)
81142580:	df000304 	addi	fp,sp,12
81142584:	e13ffd15 	stw	r4,-12(fp)
81142588:	e17ffe15 	stw	r5,-8(fp)
8114258c:	3005883a 	mov	r2,r6
81142590:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
81142594:	e0bfff0b 	ldhu	r2,-4(fp)
81142598:	1080004c 	andi	r2,r2,1
8114259c:	10000d26 	beq	r2,zero,811425d4 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
811425a0:	e0bfff0b 	ldhu	r2,-4(fp)
811425a4:	1080008c 	andi	r2,r2,2
811425a8:	10000a26 	beq	r2,zero,811425d4 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
811425ac:	00000706 	br	811425cc <OS_TaskStkClr+0x5c>
                size--;
811425b0:	e0bffe17 	ldw	r2,-8(fp)
811425b4:	10bfffc4 	addi	r2,r2,-1
811425b8:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
811425bc:	e0bffd17 	ldw	r2,-12(fp)
811425c0:	10c00104 	addi	r3,r2,4
811425c4:	e0fffd15 	stw	r3,-12(fp)
811425c8:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
811425cc:	e0bffe17 	ldw	r2,-8(fp)
811425d0:	103ff71e 	bne	r2,zero,811425b0 <__reset+0xfb1225b0>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
811425d4:	0001883a 	nop
811425d8:	e037883a 	mov	sp,fp
811425dc:	df000017 	ldw	fp,0(sp)
811425e0:	dec00104 	addi	sp,sp,4
811425e4:	f800283a 	ret

811425e8 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
811425e8:	defff904 	addi	sp,sp,-28
811425ec:	de00012e 	bgeu	sp,et,811425f4 <OSTimeDly+0xc>
811425f0:	003b68fa 	trap	3
811425f4:	dfc00615 	stw	ra,24(sp)
811425f8:	df000515 	stw	fp,20(sp)
811425fc:	df000504 	addi	fp,sp,20
81142600:	2005883a 	mov	r2,r4
81142604:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81142608:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8114260c:	d0a0a103 	ldbu	r2,-32124(gp)
81142610:	10803fcc 	andi	r2,r2,255
81142614:	1000311e 	bne	r2,zero,811426dc <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
81142618:	e0bfff0b 	ldhu	r2,-4(fp)
8114261c:	10003026 	beq	r2,zero,811426e0 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142620:	0005303a 	rdctl	r2,status
81142624:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142628:	e0fffe17 	ldw	r3,-8(fp)
8114262c:	00bfff84 	movi	r2,-2
81142630:	1884703a 	and	r2,r3,r2
81142634:	1001703a 	wrctl	status,r2
  
  return context;
81142638:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
8114263c:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
81142640:	d0a0a217 	ldw	r2,-32120(gp)
81142644:	10800d03 	ldbu	r2,52(r2)
81142648:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8114264c:	e0fffd03 	ldbu	r3,-12(fp)
81142650:	e13ffd03 	ldbu	r4,-12(fp)
81142654:	d0a09e44 	addi	r2,gp,-32135
81142658:	2085883a 	add	r2,r4,r2
8114265c:	10800003 	ldbu	r2,0(r2)
81142660:	1009883a 	mov	r4,r2
81142664:	d0a0a217 	ldw	r2,-32120(gp)
81142668:	10800d43 	ldbu	r2,53(r2)
8114266c:	0084303a 	nor	r2,zero,r2
81142670:	2084703a 	and	r2,r4,r2
81142674:	1009883a 	mov	r4,r2
81142678:	d0a09e44 	addi	r2,gp,-32135
8114267c:	1885883a 	add	r2,r3,r2
81142680:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
81142684:	e0fffd03 	ldbu	r3,-12(fp)
81142688:	d0a09e44 	addi	r2,gp,-32135
8114268c:	1885883a 	add	r2,r3,r2
81142690:	10800003 	ldbu	r2,0(r2)
81142694:	10803fcc 	andi	r2,r2,255
81142698:	1000071e 	bne	r2,zero,811426b8 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8114269c:	d0a0a217 	ldw	r2,-32120(gp)
811426a0:	10800d83 	ldbu	r2,54(r2)
811426a4:	0084303a 	nor	r2,zero,r2
811426a8:	1007883a 	mov	r3,r2
811426ac:	d0a09e03 	ldbu	r2,-32136(gp)
811426b0:	1884703a 	and	r2,r3,r2
811426b4:	d0a09e05 	stb	r2,-32136(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
811426b8:	d0a0a217 	ldw	r2,-32120(gp)
811426bc:	e0ffff0b 	ldhu	r3,-4(fp)
811426c0:	10c00b8d 	sth	r3,46(r2)
811426c4:	e0bffb17 	ldw	r2,-20(fp)
811426c8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811426cc:	e0bffc17 	ldw	r2,-16(fp)
811426d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
811426d4:	113b8ac0 	call	8113b8ac <OS_Sched>
811426d8:	00000106 	br	811426e0 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
811426dc:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
811426e0:	e037883a 	mov	sp,fp
811426e4:	dfc00117 	ldw	ra,4(sp)
811426e8:	df000017 	ldw	fp,0(sp)
811426ec:	dec00204 	addi	sp,sp,8
811426f0:	f800283a 	ret

811426f4 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
811426f4:	defff804 	addi	sp,sp,-32
811426f8:	de00012e 	bgeu	sp,et,81142700 <OSTimeDlyHMSM+0xc>
811426fc:	003b68fa 	trap	3
81142700:	dfc00715 	stw	ra,28(sp)
81142704:	df000615 	stw	fp,24(sp)
81142708:	df000604 	addi	fp,sp,24
8114270c:	2015883a 	mov	r10,r4
81142710:	2809883a 	mov	r4,r5
81142714:	3007883a 	mov	r3,r6
81142718:	3805883a 	mov	r2,r7
8114271c:	e2bffc05 	stb	r10,-16(fp)
81142720:	e13ffd05 	stb	r4,-12(fp)
81142724:	e0fffe05 	stb	r3,-8(fp)
81142728:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8114272c:	d0a0a103 	ldbu	r2,-32124(gp)
81142730:	10803fcc 	andi	r2,r2,255
81142734:	10000226 	beq	r2,zero,81142740 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
81142738:	00801544 	movi	r2,85
8114273c:	00004106 	br	81142844 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
81142740:	e0bffc03 	ldbu	r2,-16(fp)
81142744:	1000081e 	bne	r2,zero,81142768 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
81142748:	e0bffd03 	ldbu	r2,-12(fp)
8114274c:	1000061e 	bne	r2,zero,81142768 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
81142750:	e0bffe03 	ldbu	r2,-8(fp)
81142754:	1000041e 	bne	r2,zero,81142768 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
81142758:	e0bfff0b 	ldhu	r2,-4(fp)
8114275c:	1000021e 	bne	r2,zero,81142768 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
81142760:	00801504 	movi	r2,84
81142764:	00003706 	br	81142844 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
81142768:	e0bffd03 	ldbu	r2,-12(fp)
8114276c:	10800f30 	cmpltui	r2,r2,60
81142770:	1000021e 	bne	r2,zero,8114277c <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
81142774:	00801444 	movi	r2,81
81142778:	00003206 	br	81142844 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
8114277c:	e0bffe03 	ldbu	r2,-8(fp)
81142780:	10800f30 	cmpltui	r2,r2,60
81142784:	1000021e 	bne	r2,zero,81142790 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
81142788:	00801484 	movi	r2,82
8114278c:	00002d06 	br	81142844 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
81142790:	e0bfff0b 	ldhu	r2,-4(fp)
81142794:	1080fa30 	cmpltui	r2,r2,1000
81142798:	1000021e 	bne	r2,zero,811427a4 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
8114279c:	008014c4 	movi	r2,83
811427a0:	00002806 	br	81142844 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
811427a4:	e0bffc03 	ldbu	r2,-16(fp)
811427a8:	10c38424 	muli	r3,r2,3600
811427ac:	e0bffd03 	ldbu	r2,-12(fp)
811427b0:	10800f24 	muli	r2,r2,60
811427b4:	1887883a 	add	r3,r3,r2
811427b8:	e0bffe03 	ldbu	r2,-8(fp)
811427bc:	1885883a 	add	r2,r3,r2
811427c0:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
811427c4:	e0bfff0b 	ldhu	r2,-4(fp)
811427c8:	10c0fa24 	muli	r3,r2,1000
811427cc:	008418b4 	movhi	r2,4194
811427d0:	109374c4 	addi	r2,r2,19923
811427d4:	188a383a 	mulxuu	r5,r3,r2
811427d8:	1885383a 	mul	r2,r3,r2
811427dc:	1011883a 	mov	r8,r2
811427e0:	2813883a 	mov	r9,r5
811427e4:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
811427e8:	2085883a 	add	r2,r4,r2
811427ec:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
811427f0:	e0bffb17 	ldw	r2,-20(fp)
811427f4:	1004d43a 	srli	r2,r2,16
811427f8:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
811427fc:	e0bffb17 	ldw	r2,-20(fp)
81142800:	10bfffcc 	andi	r2,r2,65535
81142804:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
81142808:	e0bffb17 	ldw	r2,-20(fp)
8114280c:	10bfffcc 	andi	r2,r2,65535
81142810:	1009883a 	mov	r4,r2
81142814:	11425e80 	call	811425e8 <OSTimeDly>
    while (loops > 0) {
81142818:	00000706 	br	81142838 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
8114281c:	01200014 	movui	r4,32768
81142820:	11425e80 	call	811425e8 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
81142824:	01200014 	movui	r4,32768
81142828:	11425e80 	call	811425e8 <OSTimeDly>
        loops--;
8114282c:	e0bffa0b 	ldhu	r2,-24(fp)
81142830:	10bfffc4 	addi	r2,r2,-1
81142834:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
81142838:	e0bffa0b 	ldhu	r2,-24(fp)
8114283c:	103ff71e 	bne	r2,zero,8114281c <__reset+0xfb12281c>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
81142840:	0005883a 	mov	r2,zero
}
81142844:	e037883a 	mov	sp,fp
81142848:	dfc00117 	ldw	ra,4(sp)
8114284c:	df000017 	ldw	fp,0(sp)
81142850:	dec00204 	addi	sp,sp,8
81142854:	f800283a 	ret

81142858 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
81142858:	defff504 	addi	sp,sp,-44
8114285c:	de00012e 	bgeu	sp,et,81142864 <OSTimeDlyResume+0xc>
81142860:	003b68fa 	trap	3
81142864:	dfc00a15 	stw	ra,40(sp)
81142868:	df000915 	stw	fp,36(sp)
8114286c:	df000904 	addi	fp,sp,36
81142870:	2005883a 	mov	r2,r4
81142874:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81142878:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
8114287c:	e0bfff03 	ldbu	r2,-4(fp)
81142880:	10800ab0 	cmpltui	r2,r2,42
81142884:	1000021e 	bne	r2,zero,81142890 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81142888:	00800a84 	movi	r2,42
8114288c:	00006406 	br	81142a20 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142890:	0005303a 	rdctl	r2,status
81142894:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142898:	e0fffe17 	ldw	r3,-8(fp)
8114289c:	00bfff84 	movi	r2,-2
811428a0:	1884703a 	and	r2,r3,r2
811428a4:	1001703a 	wrctl	status,r2
  
  return context;
811428a8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811428ac:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
811428b0:	e0ffff03 	ldbu	r3,-4(fp)
811428b4:	00a045f4 	movhi	r2,33047
811428b8:	10ba6804 	addi	r2,r2,-5728
811428bc:	18c7883a 	add	r3,r3,r3
811428c0:	18c7883a 	add	r3,r3,r3
811428c4:	10c5883a 	add	r2,r2,r3
811428c8:	10800017 	ldw	r2,0(r2)
811428cc:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
811428d0:	e0bff917 	ldw	r2,-28(fp)
811428d4:	1000061e 	bne	r2,zero,811428f0 <OSTimeDlyResume+0x98>
811428d8:	e0bff717 	ldw	r2,-36(fp)
811428dc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811428e0:	e0bff817 	ldw	r2,-32(fp)
811428e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
811428e8:	008010c4 	movi	r2,67
811428ec:	00004c06 	br	81142a20 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
811428f0:	e0bff917 	ldw	r2,-28(fp)
811428f4:	10800058 	cmpnei	r2,r2,1
811428f8:	1000061e 	bne	r2,zero,81142914 <OSTimeDlyResume+0xbc>
811428fc:	e0bff717 	ldw	r2,-36(fp)
81142900:	e0bffa15 	stw	r2,-24(fp)
81142904:	e0bffa17 	ldw	r2,-24(fp)
81142908:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8114290c:	008010c4 	movi	r2,67
81142910:	00004306 	br	81142a20 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
81142914:	e0bff917 	ldw	r2,-28(fp)
81142918:	10800b8b 	ldhu	r2,46(r2)
8114291c:	10bfffcc 	andi	r2,r2,65535
81142920:	1000061e 	bne	r2,zero,8114293c <OSTimeDlyResume+0xe4>
81142924:	e0bff717 	ldw	r2,-36(fp)
81142928:	e0bffb15 	stw	r2,-20(fp)
8114292c:	e0bffb17 	ldw	r2,-20(fp)
81142930:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
81142934:	00801404 	movi	r2,80
81142938:	00003906 	br	81142a20 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
8114293c:	e0bff917 	ldw	r2,-28(fp)
81142940:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81142944:	e0bff917 	ldw	r2,-28(fp)
81142948:	10800c03 	ldbu	r2,48(r2)
8114294c:	10803fcc 	andi	r2,r2,255
81142950:	10800dcc 	andi	r2,r2,55
81142954:	10000b26 	beq	r2,zero,81142984 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
81142958:	e0bff917 	ldw	r2,-28(fp)
8114295c:	10c00c03 	ldbu	r3,48(r2)
81142960:	00bff204 	movi	r2,-56
81142964:	1884703a 	and	r2,r3,r2
81142968:	1007883a 	mov	r3,r2
8114296c:	e0bff917 	ldw	r2,-28(fp)
81142970:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
81142974:	e0bff917 	ldw	r2,-28(fp)
81142978:	00c00044 	movi	r3,1
8114297c:	10c00c45 	stb	r3,49(r2)
81142980:	00000206 	br	8114298c <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
81142984:	e0bff917 	ldw	r2,-28(fp)
81142988:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
8114298c:	e0bff917 	ldw	r2,-28(fp)
81142990:	10800c03 	ldbu	r2,48(r2)
81142994:	10803fcc 	andi	r2,r2,255
81142998:	1080020c 	andi	r2,r2,8
8114299c:	10001b1e 	bne	r2,zero,81142a0c <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
811429a0:	e0bff917 	ldw	r2,-28(fp)
811429a4:	10c00d83 	ldbu	r3,54(r2)
811429a8:	d0a09e03 	ldbu	r2,-32136(gp)
811429ac:	1884b03a 	or	r2,r3,r2
811429b0:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811429b4:	e0bff917 	ldw	r2,-28(fp)
811429b8:	10800d03 	ldbu	r2,52(r2)
811429bc:	10c03fcc 	andi	r3,r2,255
811429c0:	e0bff917 	ldw	r2,-28(fp)
811429c4:	10800d03 	ldbu	r2,52(r2)
811429c8:	11003fcc 	andi	r4,r2,255
811429cc:	d0a09e44 	addi	r2,gp,-32135
811429d0:	2085883a 	add	r2,r4,r2
811429d4:	11000003 	ldbu	r4,0(r2)
811429d8:	e0bff917 	ldw	r2,-28(fp)
811429dc:	10800d43 	ldbu	r2,53(r2)
811429e0:	2084b03a 	or	r2,r4,r2
811429e4:	1009883a 	mov	r4,r2
811429e8:	d0a09e44 	addi	r2,gp,-32135
811429ec:	1885883a 	add	r2,r3,r2
811429f0:	11000005 	stb	r4,0(r2)
811429f4:	e0bff717 	ldw	r2,-36(fp)
811429f8:	e0bffc15 	stw	r2,-16(fp)
811429fc:	e0bffc17 	ldw	r2,-16(fp)
81142a00:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
81142a04:	113b8ac0 	call	8113b8ac <OS_Sched>
81142a08:	00000406 	br	81142a1c <OSTimeDlyResume+0x1c4>
81142a0c:	e0bff717 	ldw	r2,-36(fp)
81142a10:	e0bffd15 	stw	r2,-12(fp)
81142a14:	e0bffd17 	ldw	r2,-12(fp)
81142a18:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
81142a1c:	0005883a 	mov	r2,zero
}
81142a20:	e037883a 	mov	sp,fp
81142a24:	dfc00117 	ldw	ra,4(sp)
81142a28:	df000017 	ldw	fp,0(sp)
81142a2c:	dec00204 	addi	sp,sp,8
81142a30:	f800283a 	ret

81142a34 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
81142a34:	defffb04 	addi	sp,sp,-20
81142a38:	de00012e 	bgeu	sp,et,81142a40 <OSTimeGet+0xc>
81142a3c:	003b68fa 	trap	3
81142a40:	df000415 	stw	fp,16(sp)
81142a44:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81142a48:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142a4c:	0005303a 	rdctl	r2,status
81142a50:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142a54:	e0fffe17 	ldw	r3,-8(fp)
81142a58:	00bfff84 	movi	r2,-2
81142a5c:	1884703a 	and	r2,r3,r2
81142a60:	1001703a 	wrctl	status,r2
  
  return context;
81142a64:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81142a68:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
81142a6c:	d0a0a417 	ldw	r2,-32112(gp)
81142a70:	e0bffd15 	stw	r2,-12(fp)
81142a74:	e0bffc17 	ldw	r2,-16(fp)
81142a78:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142a7c:	e0bfff17 	ldw	r2,-4(fp)
81142a80:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
81142a84:	e0bffd17 	ldw	r2,-12(fp)
}
81142a88:	e037883a 	mov	sp,fp
81142a8c:	df000017 	ldw	fp,0(sp)
81142a90:	dec00104 	addi	sp,sp,4
81142a94:	f800283a 	ret

81142a98 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
81142a98:	defffb04 	addi	sp,sp,-20
81142a9c:	de00012e 	bgeu	sp,et,81142aa4 <OSTimeSet+0xc>
81142aa0:	003b68fa 	trap	3
81142aa4:	df000415 	stw	fp,16(sp)
81142aa8:	df000404 	addi	fp,sp,16
81142aac:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81142ab0:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142ab4:	0005303a 	rdctl	r2,status
81142ab8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142abc:	e0fffd17 	ldw	r3,-12(fp)
81142ac0:	00bfff84 	movi	r2,-2
81142ac4:	1884703a 	and	r2,r3,r2
81142ac8:	1001703a 	wrctl	status,r2
  
  return context;
81142acc:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
81142ad0:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
81142ad4:	e0bfff17 	ldw	r2,-4(fp)
81142ad8:	d0a0a415 	stw	r2,-32112(gp)
81142adc:	e0bffc17 	ldw	r2,-16(fp)
81142ae0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142ae4:	e0bffe17 	ldw	r2,-8(fp)
81142ae8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81142aec:	0001883a 	nop
81142af0:	e037883a 	mov	sp,fp
81142af4:	df000017 	ldw	fp,0(sp)
81142af8:	dec00104 	addi	sp,sp,4
81142afc:	f800283a 	ret

81142b00 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
81142b00:	defff804 	addi	sp,sp,-32
81142b04:	de00012e 	bgeu	sp,et,81142b0c <OSTmrCreate+0xc>
81142b08:	003b68fa 	trap	3
81142b0c:	dfc00715 	stw	ra,28(sp)
81142b10:	df000615 	stw	fp,24(sp)
81142b14:	df000604 	addi	fp,sp,24
81142b18:	e13ffc15 	stw	r4,-16(fp)
81142b1c:	e17ffd15 	stw	r5,-12(fp)
81142b20:	3005883a 	mov	r2,r6
81142b24:	e1ffff15 	stw	r7,-4(fp)
81142b28:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81142b2c:	e0800417 	ldw	r2,16(fp)
81142b30:	1000021e 	bne	r2,zero,81142b3c <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
81142b34:	0005883a 	mov	r2,zero
81142b38:	00005d06 	br	81142cb0 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
81142b3c:	e0bffe03 	ldbu	r2,-8(fp)
81142b40:	10c00060 	cmpeqi	r3,r2,1
81142b44:	1800091e 	bne	r3,zero,81142b6c <OSTmrCreate+0x6c>
81142b48:	108000a0 	cmpeqi	r2,r2,2
81142b4c:	10000e26 	beq	r2,zero,81142b88 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
81142b50:	e0bffd17 	ldw	r2,-12(fp)
81142b54:	1000111e 	bne	r2,zero,81142b9c <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
81142b58:	e0800417 	ldw	r2,16(fp)
81142b5c:	00ffe0c4 	movi	r3,-125
81142b60:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81142b64:	0005883a 	mov	r2,zero
81142b68:	00005106 	br	81142cb0 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
81142b6c:	e0bffc17 	ldw	r2,-16(fp)
81142b70:	10000c1e 	bne	r2,zero,81142ba4 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
81142b74:	e0800417 	ldw	r2,16(fp)
81142b78:	00ffe084 	movi	r3,-126
81142b7c:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81142b80:	0005883a 	mov	r2,zero
81142b84:	00004a06 	br	81142cb0 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
81142b88:	e0800417 	ldw	r2,16(fp)
81142b8c:	00ffe104 	movi	r3,-124
81142b90:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
81142b94:	0005883a 	mov	r2,zero
81142b98:	00004506 	br	81142cb0 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
81142b9c:	0001883a 	nop
81142ba0:	00000106 	br	81142ba8 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
81142ba4:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81142ba8:	d0a0a103 	ldbu	r2,-32124(gp)
81142bac:	10803fcc 	andi	r2,r2,255
81142bb0:	10000526 	beq	r2,zero,81142bc8 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
81142bb4:	e0800417 	ldw	r2,16(fp)
81142bb8:	00ffe2c4 	movi	r3,-117
81142bbc:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81142bc0:	0005883a 	mov	r2,zero
81142bc4:	00003a06 	br	81142cb0 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
81142bc8:	1143ab80 	call	81143ab8 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
81142bcc:	11435580 	call	81143558 <OSTmr_Alloc>
81142bd0:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
81142bd4:	e0bffa17 	ldw	r2,-24(fp)
81142bd8:	1000061e 	bne	r2,zero,81142bf4 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
81142bdc:	1143afc0 	call	81143afc <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
81142be0:	e0800417 	ldw	r2,16(fp)
81142be4:	00ffe184 	movi	r3,-122
81142be8:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81142bec:	0005883a 	mov	r2,zero
81142bf0:	00002f06 	br	81142cb0 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
81142bf4:	e0bffa17 	ldw	r2,-24(fp)
81142bf8:	00c00044 	movi	r3,1
81142bfc:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
81142c00:	e0bffa17 	ldw	r2,-24(fp)
81142c04:	e0fffc17 	ldw	r3,-16(fp)
81142c08:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
81142c0c:	e0bffa17 	ldw	r2,-24(fp)
81142c10:	e0fffd17 	ldw	r3,-12(fp)
81142c14:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
81142c18:	e0bffa17 	ldw	r2,-24(fp)
81142c1c:	e0fffe03 	ldbu	r3,-8(fp)
81142c20:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
81142c24:	e0bffa17 	ldw	r2,-24(fp)
81142c28:	e0ffff17 	ldw	r3,-4(fp)
81142c2c:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
81142c30:	e0bffa17 	ldw	r2,-24(fp)
81142c34:	e0c00217 	ldw	r3,8(fp)
81142c38:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
81142c3c:	e0800317 	ldw	r2,12(fp)
81142c40:	10001726 	beq	r2,zero,81142ca0 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
81142c44:	e1000317 	ldw	r4,12(fp)
81142c48:	113ba7c0 	call	8113ba7c <OS_StrLen>
81142c4c:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
81142c50:	e0bffb03 	ldbu	r2,-20(fp)
81142c54:	10800428 	cmpgeui	r2,r2,16
81142c58:	1000061e 	bne	r2,zero,81142c74 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
81142c5c:	e0bffa17 	ldw	r2,-24(fp)
81142c60:	10800804 	addi	r2,r2,32
81142c64:	e1400317 	ldw	r5,12(fp)
81142c68:	1009883a 	mov	r4,r2
81142c6c:	113ba000 	call	8113ba00 <OS_StrCopy>
81142c70:	00000b06 	br	81142ca0 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
81142c74:	e0bffa17 	ldw	r2,-24(fp)
81142c78:	00c008c4 	movi	r3,35
81142c7c:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
81142c80:	e0bffa17 	ldw	r2,-24(fp)
81142c84:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
81142c88:	e0800417 	ldw	r2,16(fp)
81142c8c:	00ffe304 	movi	r3,-116
81142c90:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
81142c94:	1143afc0 	call	81143afc <OSTmr_Unlock>
            return (ptmr);
81142c98:	e0bffa17 	ldw	r2,-24(fp)
81142c9c:	00000406 	br	81142cb0 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
81142ca0:	1143afc0 	call	81143afc <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
81142ca4:	e0800417 	ldw	r2,16(fp)
81142ca8:	10000005 	stb	zero,0(r2)
    return (ptmr);
81142cac:	e0bffa17 	ldw	r2,-24(fp)
}
81142cb0:	e037883a 	mov	sp,fp
81142cb4:	dfc00117 	ldw	ra,4(sp)
81142cb8:	df000017 	ldw	fp,0(sp)
81142cbc:	dec00204 	addi	sp,sp,8
81142cc0:	f800283a 	ret

81142cc4 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
81142cc4:	defffc04 	addi	sp,sp,-16
81142cc8:	de00012e 	bgeu	sp,et,81142cd0 <OSTmrDel+0xc>
81142ccc:	003b68fa 	trap	3
81142cd0:	dfc00315 	stw	ra,12(sp)
81142cd4:	df000215 	stw	fp,8(sp)
81142cd8:	df000204 	addi	fp,sp,8
81142cdc:	e13ffe15 	stw	r4,-8(fp)
81142ce0:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81142ce4:	e0bfff17 	ldw	r2,-4(fp)
81142ce8:	1000021e 	bne	r2,zero,81142cf4 <OSTmrDel+0x30>
        return (OS_FALSE);
81142cec:	0005883a 	mov	r2,zero
81142cf0:	00003f06 	br	81142df0 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81142cf4:	e0bffe17 	ldw	r2,-8(fp)
81142cf8:	1000051e 	bne	r2,zero,81142d10 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81142cfc:	e0bfff17 	ldw	r2,-4(fp)
81142d00:	00ffe284 	movi	r3,-118
81142d04:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81142d08:	0005883a 	mov	r2,zero
81142d0c:	00003806 	br	81142df0 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
81142d10:	e0bffe17 	ldw	r2,-8(fp)
81142d14:	10800003 	ldbu	r2,0(r2)
81142d18:	10803fcc 	andi	r2,r2,255
81142d1c:	10801920 	cmpeqi	r2,r2,100
81142d20:	1000051e 	bne	r2,zero,81142d38 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81142d24:	e0bfff17 	ldw	r2,-4(fp)
81142d28:	00ffe244 	movi	r3,-119
81142d2c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81142d30:	0005883a 	mov	r2,zero
81142d34:	00002e06 	br	81142df0 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81142d38:	d0a0a103 	ldbu	r2,-32124(gp)
81142d3c:	10803fcc 	andi	r2,r2,255
81142d40:	10000526 	beq	r2,zero,81142d58 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
81142d44:	e0bfff17 	ldw	r2,-4(fp)
81142d48:	00ffe2c4 	movi	r3,-117
81142d4c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81142d50:	0005883a 	mov	r2,zero
81142d54:	00002606 	br	81142df0 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
81142d58:	1143ab80 	call	81143ab8 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81142d5c:	e0bffe17 	ldw	r2,-8(fp)
81142d60:	10800c43 	ldbu	r2,49(r2)
81142d64:	10803fcc 	andi	r2,r2,255
81142d68:	10c000c8 	cmpgei	r3,r2,3
81142d6c:	1800031e 	bne	r3,zero,81142d7c <OSTmrDel+0xb8>
81142d70:	00800d16 	blt	zero,r2,81142da8 <OSTmrDel+0xe4>
81142d74:	10001326 	beq	r2,zero,81142dc4 <OSTmrDel+0x100>
81142d78:	00001806 	br	81142ddc <OSTmrDel+0x118>
81142d7c:	108000e0 	cmpeqi	r2,r2,3
81142d80:	10001626 	beq	r2,zero,81142ddc <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
81142d84:	e13ffe17 	ldw	r4,-8(fp)
81142d88:	11439bc0 	call	811439bc <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81142d8c:	e13ffe17 	ldw	r4,-8(fp)
81142d90:	11435cc0 	call	811435cc <OSTmr_Free>
             OSTmr_Unlock();
81142d94:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81142d98:	e0bfff17 	ldw	r2,-4(fp)
81142d9c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81142da0:	00800044 	movi	r2,1
81142da4:	00001206 	br	81142df0 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81142da8:	e13ffe17 	ldw	r4,-8(fp)
81142dac:	11435cc0 	call	811435cc <OSTmr_Free>
             OSTmr_Unlock();
81142db0:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81142db4:	e0bfff17 	ldw	r2,-4(fp)
81142db8:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81142dbc:	00800044 	movi	r2,1
81142dc0:	00000b06 	br	81142df0 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
81142dc4:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81142dc8:	e0bfff17 	ldw	r2,-4(fp)
81142dcc:	00ffe1c4 	movi	r3,-121
81142dd0:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81142dd4:	0005883a 	mov	r2,zero
81142dd8:	00000506 	br	81142df0 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
81142ddc:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81142de0:	e0bfff17 	ldw	r2,-4(fp)
81142de4:	00ffe344 	movi	r3,-115
81142de8:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81142dec:	0005883a 	mov	r2,zero
    }
}
81142df0:	e037883a 	mov	sp,fp
81142df4:	dfc00117 	ldw	ra,4(sp)
81142df8:	df000017 	ldw	fp,0(sp)
81142dfc:	dec00204 	addi	sp,sp,8
81142e00:	f800283a 	ret

81142e04 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
81142e04:	defffa04 	addi	sp,sp,-24
81142e08:	de00012e 	bgeu	sp,et,81142e10 <OSTmrNameGet+0xc>
81142e0c:	003b68fa 	trap	3
81142e10:	dfc00515 	stw	ra,20(sp)
81142e14:	df000415 	stw	fp,16(sp)
81142e18:	df000404 	addi	fp,sp,16
81142e1c:	e13ffd15 	stw	r4,-12(fp)
81142e20:	e17ffe15 	stw	r5,-8(fp)
81142e24:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81142e28:	e0bfff17 	ldw	r2,-4(fp)
81142e2c:	1000021e 	bne	r2,zero,81142e38 <OSTmrNameGet+0x34>
        return (0);
81142e30:	0005883a 	mov	r2,zero
81142e34:	00003e06 	br	81142f30 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
81142e38:	e0bffe17 	ldw	r2,-8(fp)
81142e3c:	1000051e 	bne	r2,zero,81142e54 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
81142e40:	e0bfff17 	ldw	r2,-4(fp)
81142e44:	00ffe204 	movi	r3,-120
81142e48:	10c00005 	stb	r3,0(r2)
        return (0);
81142e4c:	0005883a 	mov	r2,zero
81142e50:	00003706 	br	81142f30 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81142e54:	e0bffd17 	ldw	r2,-12(fp)
81142e58:	1000051e 	bne	r2,zero,81142e70 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
81142e5c:	e0bfff17 	ldw	r2,-4(fp)
81142e60:	00ffe284 	movi	r3,-118
81142e64:	10c00005 	stb	r3,0(r2)
        return (0);
81142e68:	0005883a 	mov	r2,zero
81142e6c:	00003006 	br	81142f30 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81142e70:	e0bffd17 	ldw	r2,-12(fp)
81142e74:	10800003 	ldbu	r2,0(r2)
81142e78:	10803fcc 	andi	r2,r2,255
81142e7c:	10801920 	cmpeqi	r2,r2,100
81142e80:	1000051e 	bne	r2,zero,81142e98 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81142e84:	e0bfff17 	ldw	r2,-4(fp)
81142e88:	00ffe244 	movi	r3,-119
81142e8c:	10c00005 	stb	r3,0(r2)
        return (0);
81142e90:	0005883a 	mov	r2,zero
81142e94:	00002606 	br	81142f30 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81142e98:	d0a0a103 	ldbu	r2,-32124(gp)
81142e9c:	10803fcc 	andi	r2,r2,255
81142ea0:	10000526 	beq	r2,zero,81142eb8 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
81142ea4:	e0bfff17 	ldw	r2,-4(fp)
81142ea8:	00c00444 	movi	r3,17
81142eac:	10c00005 	stb	r3,0(r2)
        return (0);
81142eb0:	0005883a 	mov	r2,zero
81142eb4:	00001e06 	br	81142f30 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
81142eb8:	1143ab80 	call	81143ab8 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81142ebc:	e0bffd17 	ldw	r2,-12(fp)
81142ec0:	10800c43 	ldbu	r2,49(r2)
81142ec4:	10803fcc 	andi	r2,r2,255
81142ec8:	10000e26 	beq	r2,zero,81142f04 <OSTmrNameGet+0x100>
81142ecc:	10001316 	blt	r2,zero,81142f1c <OSTmrNameGet+0x118>
81142ed0:	10800108 	cmpgei	r2,r2,4
81142ed4:	1000111e 	bne	r2,zero,81142f1c <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
81142ed8:	e0bffd17 	ldw	r2,-12(fp)
81142edc:	10800804 	addi	r2,r2,32
81142ee0:	100b883a 	mov	r5,r2
81142ee4:	e13ffe17 	ldw	r4,-8(fp)
81142ee8:	113ba000 	call	8113ba00 <OS_StrCopy>
81142eec:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
81142ef0:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81142ef4:	e0bfff17 	ldw	r2,-4(fp)
81142ef8:	10000005 	stb	zero,0(r2)
             return (len);
81142efc:	e0bffc03 	ldbu	r2,-16(fp)
81142f00:	00000b06 	br	81142f30 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
81142f04:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81142f08:	e0bfff17 	ldw	r2,-4(fp)
81142f0c:	00ffe1c4 	movi	r3,-121
81142f10:	10c00005 	stb	r3,0(r2)
             return (0);
81142f14:	0005883a 	mov	r2,zero
81142f18:	00000506 	br	81142f30 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
81142f1c:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81142f20:	e0bfff17 	ldw	r2,-4(fp)
81142f24:	00ffe344 	movi	r3,-115
81142f28:	10c00005 	stb	r3,0(r2)
             return (0);
81142f2c:	0005883a 	mov	r2,zero
    }
}
81142f30:	e037883a 	mov	sp,fp
81142f34:	dfc00117 	ldw	ra,4(sp)
81142f38:	df000017 	ldw	fp,0(sp)
81142f3c:	dec00204 	addi	sp,sp,8
81142f40:	f800283a 	ret

81142f44 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
81142f44:	defffb04 	addi	sp,sp,-20
81142f48:	de00012e 	bgeu	sp,et,81142f50 <OSTmrRemainGet+0xc>
81142f4c:	003b68fa 	trap	3
81142f50:	dfc00415 	stw	ra,16(sp)
81142f54:	df000315 	stw	fp,12(sp)
81142f58:	df000304 	addi	fp,sp,12
81142f5c:	e13ffe15 	stw	r4,-8(fp)
81142f60:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81142f64:	e0bfff17 	ldw	r2,-4(fp)
81142f68:	1000021e 	bne	r2,zero,81142f74 <OSTmrRemainGet+0x30>
        return (0);
81142f6c:	0005883a 	mov	r2,zero
81142f70:	00005d06 	br	811430e8 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
81142f74:	e0bffe17 	ldw	r2,-8(fp)
81142f78:	1000051e 	bne	r2,zero,81142f90 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81142f7c:	e0bfff17 	ldw	r2,-4(fp)
81142f80:	00ffe284 	movi	r3,-118
81142f84:	10c00005 	stb	r3,0(r2)
        return (0);
81142f88:	0005883a 	mov	r2,zero
81142f8c:	00005606 	br	811430e8 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81142f90:	e0bffe17 	ldw	r2,-8(fp)
81142f94:	10800003 	ldbu	r2,0(r2)
81142f98:	10803fcc 	andi	r2,r2,255
81142f9c:	10801920 	cmpeqi	r2,r2,100
81142fa0:	1000051e 	bne	r2,zero,81142fb8 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81142fa4:	e0bfff17 	ldw	r2,-4(fp)
81142fa8:	00ffe244 	movi	r3,-119
81142fac:	10c00005 	stb	r3,0(r2)
        return (0);
81142fb0:	0005883a 	mov	r2,zero
81142fb4:	00004c06 	br	811430e8 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81142fb8:	d0a0a103 	ldbu	r2,-32124(gp)
81142fbc:	10803fcc 	andi	r2,r2,255
81142fc0:	10000526 	beq	r2,zero,81142fd8 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81142fc4:	e0bfff17 	ldw	r2,-4(fp)
81142fc8:	00ffe2c4 	movi	r3,-117
81142fcc:	10c00005 	stb	r3,0(r2)
        return (0);
81142fd0:	0005883a 	mov	r2,zero
81142fd4:	00004406 	br	811430e8 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
81142fd8:	1143ab80 	call	81143ab8 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81142fdc:	e0bffe17 	ldw	r2,-8(fp)
81142fe0:	10800c43 	ldbu	r2,49(r2)
81142fe4:	10803fcc 	andi	r2,r2,255
81142fe8:	10c00060 	cmpeqi	r3,r2,1
81142fec:	1800121e 	bne	r3,zero,81143038 <OSTmrRemainGet+0xf4>
81142ff0:	10c00088 	cmpgei	r3,r2,2
81142ff4:	1800021e 	bne	r3,zero,81143000 <OSTmrRemainGet+0xbc>
81142ff8:	10003026 	beq	r2,zero,811430bc <OSTmrRemainGet+0x178>
81142ffc:	00003506 	br	811430d4 <OSTmrRemainGet+0x190>
81143000:	10c000a0 	cmpeqi	r3,r2,2
81143004:	1800281e 	bne	r3,zero,811430a8 <OSTmrRemainGet+0x164>
81143008:	108000e0 	cmpeqi	r2,r2,3
8114300c:	10003126 	beq	r2,zero,811430d4 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
81143010:	e0bffe17 	ldw	r2,-8(fp)
81143014:	10c00517 	ldw	r3,20(r2)
81143018:	d0a0a317 	ldw	r2,-32116(gp)
8114301c:	1885c83a 	sub	r2,r3,r2
81143020:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
81143024:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
81143028:	e0bfff17 	ldw	r2,-4(fp)
8114302c:	10000005 	stb	zero,0(r2)
             return (remain);
81143030:	e0bffd17 	ldw	r2,-12(fp)
81143034:	00002c06 	br	811430e8 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
81143038:	e0bffe17 	ldw	r2,-8(fp)
8114303c:	10800c03 	ldbu	r2,48(r2)
81143040:	10803fcc 	andi	r2,r2,255
81143044:	108000a0 	cmpeqi	r2,r2,2
81143048:	10000e26 	beq	r2,zero,81143084 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
8114304c:	e0bffe17 	ldw	r2,-8(fp)
81143050:	10800617 	ldw	r2,24(r2)
81143054:	1000041e 	bne	r2,zero,81143068 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
81143058:	e0bffe17 	ldw	r2,-8(fp)
8114305c:	10800717 	ldw	r2,28(r2)
81143060:	e0bffd15 	stw	r2,-12(fp)
81143064:	00000306 	br	81143074 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
81143068:	e0bffe17 	ldw	r2,-8(fp)
8114306c:	10800617 	ldw	r2,24(r2)
81143070:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
81143074:	1143afc0 	call	81143afc <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81143078:	e0bfff17 	ldw	r2,-4(fp)
8114307c:	10000005 	stb	zero,0(r2)
                      break;
81143080:	00000706 	br	811430a0 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
81143084:	e0bffe17 	ldw	r2,-8(fp)
81143088:	10800617 	ldw	r2,24(r2)
8114308c:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
81143090:	1143afc0 	call	81143afc <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81143094:	e0bfff17 	ldw	r2,-4(fp)
81143098:	10000005 	stb	zero,0(r2)
                      break;
8114309c:	0001883a 	nop
             }
             return (remain);
811430a0:	e0bffd17 	ldw	r2,-12(fp)
811430a4:	00001006 	br	811430e8 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
811430a8:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811430ac:	e0bfff17 	ldw	r2,-4(fp)
811430b0:	10000005 	stb	zero,0(r2)
             return (0);
811430b4:	0005883a 	mov	r2,zero
811430b8:	00000b06 	br	811430e8 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
811430bc:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811430c0:	e0bfff17 	ldw	r2,-4(fp)
811430c4:	00ffe1c4 	movi	r3,-121
811430c8:	10c00005 	stb	r3,0(r2)
             return (0);
811430cc:	0005883a 	mov	r2,zero
811430d0:	00000506 	br	811430e8 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
811430d4:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811430d8:	e0bfff17 	ldw	r2,-4(fp)
811430dc:	00ffe344 	movi	r3,-115
811430e0:	10c00005 	stb	r3,0(r2)
             return (0);
811430e4:	0005883a 	mov	r2,zero
    }
}
811430e8:	e037883a 	mov	sp,fp
811430ec:	dfc00117 	ldw	ra,4(sp)
811430f0:	df000017 	ldw	fp,0(sp)
811430f4:	dec00204 	addi	sp,sp,8
811430f8:	f800283a 	ret

811430fc <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
811430fc:	defffb04 	addi	sp,sp,-20
81143100:	de00012e 	bgeu	sp,et,81143108 <OSTmrStateGet+0xc>
81143104:	003b68fa 	trap	3
81143108:	dfc00415 	stw	ra,16(sp)
8114310c:	df000315 	stw	fp,12(sp)
81143110:	df000304 	addi	fp,sp,12
81143114:	e13ffe15 	stw	r4,-8(fp)
81143118:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8114311c:	e0bfff17 	ldw	r2,-4(fp)
81143120:	1000021e 	bne	r2,zero,8114312c <OSTmrStateGet+0x30>
        return (0);
81143124:	0005883a 	mov	r2,zero
81143128:	00002a06 	br	811431d4 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
8114312c:	e0bffe17 	ldw	r2,-8(fp)
81143130:	1000051e 	bne	r2,zero,81143148 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81143134:	e0bfff17 	ldw	r2,-4(fp)
81143138:	00ffe284 	movi	r3,-118
8114313c:	10c00005 	stb	r3,0(r2)
        return (0);
81143140:	0005883a 	mov	r2,zero
81143144:	00002306 	br	811431d4 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81143148:	e0bffe17 	ldw	r2,-8(fp)
8114314c:	10800003 	ldbu	r2,0(r2)
81143150:	10803fcc 	andi	r2,r2,255
81143154:	10801920 	cmpeqi	r2,r2,100
81143158:	1000051e 	bne	r2,zero,81143170 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8114315c:	e0bfff17 	ldw	r2,-4(fp)
81143160:	00ffe244 	movi	r3,-119
81143164:	10c00005 	stb	r3,0(r2)
        return (0);
81143168:	0005883a 	mov	r2,zero
8114316c:	00001906 	br	811431d4 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81143170:	d0a0a103 	ldbu	r2,-32124(gp)
81143174:	10803fcc 	andi	r2,r2,255
81143178:	10000526 	beq	r2,zero,81143190 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8114317c:	e0bfff17 	ldw	r2,-4(fp)
81143180:	00ffe2c4 	movi	r3,-117
81143184:	10c00005 	stb	r3,0(r2)
        return (0);
81143188:	0005883a 	mov	r2,zero
8114318c:	00001106 	br	811431d4 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
81143190:	1143ab80 	call	81143ab8 <OSTmr_Lock>
    state = ptmr->OSTmrState;
81143194:	e0bffe17 	ldw	r2,-8(fp)
81143198:	10800c43 	ldbu	r2,49(r2)
8114319c:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
811431a0:	e0bffd03 	ldbu	r2,-12(fp)
811431a4:	1005883a 	mov	r2,r2
811431a8:	10800128 	cmpgeui	r2,r2,4
811431ac:	1000031e 	bne	r2,zero,811431bc <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
811431b0:	e0bfff17 	ldw	r2,-4(fp)
811431b4:	10000005 	stb	zero,0(r2)
             break;
811431b8:	00000406 	br	811431cc <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
811431bc:	e0bfff17 	ldw	r2,-4(fp)
811431c0:	00ffe344 	movi	r3,-115
811431c4:	10c00005 	stb	r3,0(r2)
             break;
811431c8:	0001883a 	nop
    }
    OSTmr_Unlock();
811431cc:	1143afc0 	call	81143afc <OSTmr_Unlock>
    return (state);
811431d0:	e0bffd03 	ldbu	r2,-12(fp)
}
811431d4:	e037883a 	mov	sp,fp
811431d8:	dfc00117 	ldw	ra,4(sp)
811431dc:	df000017 	ldw	fp,0(sp)
811431e0:	dec00204 	addi	sp,sp,8
811431e4:	f800283a 	ret

811431e8 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
811431e8:	defffc04 	addi	sp,sp,-16
811431ec:	de00012e 	bgeu	sp,et,811431f4 <OSTmrStart+0xc>
811431f0:	003b68fa 	trap	3
811431f4:	dfc00315 	stw	ra,12(sp)
811431f8:	df000215 	stw	fp,8(sp)
811431fc:	df000204 	addi	fp,sp,8
81143200:	e13ffe15 	stw	r4,-8(fp)
81143204:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81143208:	e0bfff17 	ldw	r2,-4(fp)
8114320c:	1000021e 	bne	r2,zero,81143218 <OSTmrStart+0x30>
        return (OS_FALSE);
81143210:	0005883a 	mov	r2,zero
81143214:	00004106 	br	8114331c <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
81143218:	e0bffe17 	ldw	r2,-8(fp)
8114321c:	1000051e 	bne	r2,zero,81143234 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81143220:	e0bfff17 	ldw	r2,-4(fp)
81143224:	00ffe284 	movi	r3,-118
81143228:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8114322c:	0005883a 	mov	r2,zero
81143230:	00003a06 	br	8114331c <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
81143234:	e0bffe17 	ldw	r2,-8(fp)
81143238:	10800003 	ldbu	r2,0(r2)
8114323c:	10803fcc 	andi	r2,r2,255
81143240:	10801920 	cmpeqi	r2,r2,100
81143244:	1000051e 	bne	r2,zero,8114325c <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81143248:	e0bfff17 	ldw	r2,-4(fp)
8114324c:	00ffe244 	movi	r3,-119
81143250:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81143254:	0005883a 	mov	r2,zero
81143258:	00003006 	br	8114331c <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8114325c:	d0a0a103 	ldbu	r2,-32124(gp)
81143260:	10803fcc 	andi	r2,r2,255
81143264:	10000526 	beq	r2,zero,8114327c <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
81143268:	e0bfff17 	ldw	r2,-4(fp)
8114326c:	00ffe2c4 	movi	r3,-117
81143270:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81143274:	0005883a 	mov	r2,zero
81143278:	00002806 	br	8114331c <OSTmrStart+0x134>
    }
    OSTmr_Lock();
8114327c:	1143ab80 	call	81143ab8 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81143280:	e0bffe17 	ldw	r2,-8(fp)
81143284:	10800c43 	ldbu	r2,49(r2)
81143288:	10803fcc 	andi	r2,r2,255
8114328c:	10c000c8 	cmpgei	r3,r2,3
81143290:	1800031e 	bne	r3,zero,811432a0 <OSTmrStart+0xb8>
81143294:	00800e16 	blt	zero,r2,811432d0 <OSTmrStart+0xe8>
81143298:	10001526 	beq	r2,zero,811432f0 <OSTmrStart+0x108>
8114329c:	00001a06 	br	81143308 <OSTmrStart+0x120>
811432a0:	108000e0 	cmpeqi	r2,r2,3
811432a4:	10001826 	beq	r2,zero,81143308 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
811432a8:	e13ffe17 	ldw	r4,-8(fp)
811432ac:	11439bc0 	call	811439bc <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
811432b0:	000b883a 	mov	r5,zero
811432b4:	e13ffe17 	ldw	r4,-8(fp)
811432b8:	114386c0 	call	8114386c <OSTmr_Link>
             OSTmr_Unlock();
811432bc:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811432c0:	e0bfff17 	ldw	r2,-4(fp)
811432c4:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811432c8:	00800044 	movi	r2,1
811432cc:	00001306 	br	8114331c <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
811432d0:	000b883a 	mov	r5,zero
811432d4:	e13ffe17 	ldw	r4,-8(fp)
811432d8:	114386c0 	call	8114386c <OSTmr_Link>
             OSTmr_Unlock();
811432dc:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811432e0:	e0bfff17 	ldw	r2,-4(fp)
811432e4:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811432e8:	00800044 	movi	r2,1
811432ec:	00000b06 	br	8114331c <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
811432f0:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811432f4:	e0bfff17 	ldw	r2,-4(fp)
811432f8:	00ffe1c4 	movi	r3,-121
811432fc:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81143300:	0005883a 	mov	r2,zero
81143304:	00000506 	br	8114331c <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
81143308:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8114330c:	e0bfff17 	ldw	r2,-4(fp)
81143310:	00ffe344 	movi	r3,-115
81143314:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81143318:	0005883a 	mov	r2,zero
    }
}
8114331c:	e037883a 	mov	sp,fp
81143320:	dfc00117 	ldw	ra,4(sp)
81143324:	df000017 	ldw	fp,0(sp)
81143328:	dec00204 	addi	sp,sp,8
8114332c:	f800283a 	ret

81143330 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
81143330:	defff904 	addi	sp,sp,-28
81143334:	de00012e 	bgeu	sp,et,8114333c <OSTmrStop+0xc>
81143338:	003b68fa 	trap	3
8114333c:	dfc00615 	stw	ra,24(sp)
81143340:	df000515 	stw	fp,20(sp)
81143344:	df000504 	addi	fp,sp,20
81143348:	e13ffc15 	stw	r4,-16(fp)
8114334c:	2805883a 	mov	r2,r5
81143350:	e1bffe15 	stw	r6,-8(fp)
81143354:	e1ffff15 	stw	r7,-4(fp)
81143358:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
8114335c:	e0bfff17 	ldw	r2,-4(fp)
81143360:	1000021e 	bne	r2,zero,8114336c <OSTmrStop+0x3c>
        return (OS_FALSE);
81143364:	0005883a 	mov	r2,zero
81143368:	00006606 	br	81143504 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
8114336c:	e0bffc17 	ldw	r2,-16(fp)
81143370:	1000051e 	bne	r2,zero,81143388 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
81143374:	e0bfff17 	ldw	r2,-4(fp)
81143378:	00ffe284 	movi	r3,-118
8114337c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81143380:	0005883a 	mov	r2,zero
81143384:	00005f06 	br	81143504 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
81143388:	e0bffc17 	ldw	r2,-16(fp)
8114338c:	10800003 	ldbu	r2,0(r2)
81143390:	10803fcc 	andi	r2,r2,255
81143394:	10801920 	cmpeqi	r2,r2,100
81143398:	1000051e 	bne	r2,zero,811433b0 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8114339c:	e0bfff17 	ldw	r2,-4(fp)
811433a0:	00ffe244 	movi	r3,-119
811433a4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811433a8:	0005883a 	mov	r2,zero
811433ac:	00005506 	br	81143504 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
811433b0:	d0a0a103 	ldbu	r2,-32124(gp)
811433b4:	10803fcc 	andi	r2,r2,255
811433b8:	10000526 	beq	r2,zero,811433d0 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
811433bc:	e0bfff17 	ldw	r2,-4(fp)
811433c0:	00ffe2c4 	movi	r3,-117
811433c4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811433c8:	0005883a 	mov	r2,zero
811433cc:	00004d06 	br	81143504 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
811433d0:	1143ab80 	call	81143ab8 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811433d4:	e0bffc17 	ldw	r2,-16(fp)
811433d8:	10800c43 	ldbu	r2,49(r2)
811433dc:	10803fcc 	andi	r2,r2,255
811433e0:	10c000c8 	cmpgei	r3,r2,3
811433e4:	1800031e 	bne	r3,zero,811433f4 <OSTmrStop+0xc4>
811433e8:	00803516 	blt	zero,r2,811434c0 <OSTmrStop+0x190>
811433ec:	10003a26 	beq	r2,zero,811434d8 <OSTmrStop+0x1a8>
811433f0:	00003f06 	br	811434f0 <OSTmrStop+0x1c0>
811433f4:	108000e0 	cmpeqi	r2,r2,3
811433f8:	10003d26 	beq	r2,zero,811434f0 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
811433fc:	e13ffc17 	ldw	r4,-16(fp)
81143400:	11439bc0 	call	811439bc <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
81143404:	e0bfff17 	ldw	r2,-4(fp)
81143408:	10000005 	stb	zero,0(r2)
             switch (opt) {
8114340c:	e0bffd03 	ldbu	r2,-12(fp)
81143410:	10c000e0 	cmpeqi	r3,r2,3
81143414:	1800041e 	bne	r3,zero,81143428 <OSTmrStop+0xf8>
81143418:	10c00120 	cmpeqi	r3,r2,4
8114341c:	1800121e 	bne	r3,zero,81143468 <OSTmrStop+0x138>
81143420:	10002326 	beq	r2,zero,811434b0 <OSTmrStop+0x180>
81143424:	00001e06 	br	811434a0 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81143428:	e0bffc17 	ldw	r2,-16(fp)
8114342c:	10800117 	ldw	r2,4(r2)
81143430:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81143434:	e0bffb17 	ldw	r2,-20(fp)
81143438:	10000726 	beq	r2,zero,81143458 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
8114343c:	e0bffc17 	ldw	r2,-16(fp)
81143440:	10c00217 	ldw	r3,8(r2)
81143444:	e0bffb17 	ldw	r2,-20(fp)
81143448:	180b883a 	mov	r5,r3
8114344c:	e13ffc17 	ldw	r4,-16(fp)
81143450:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81143454:	00001706 	br	811434b4 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81143458:	e0bfff17 	ldw	r2,-4(fp)
8114345c:	00ffe3c4 	movi	r3,-113
81143460:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81143464:	00001306 	br	811434b4 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81143468:	e0bffc17 	ldw	r2,-16(fp)
8114346c:	10800117 	ldw	r2,4(r2)
81143470:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81143474:	e0bffb17 	ldw	r2,-20(fp)
81143478:	10000526 	beq	r2,zero,81143490 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
8114347c:	e0bffb17 	ldw	r2,-20(fp)
81143480:	e17ffe17 	ldw	r5,-8(fp)
81143484:	e13ffc17 	ldw	r4,-16(fp)
81143488:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8114348c:	00000906 	br	811434b4 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81143490:	e0bfff17 	ldw	r2,-4(fp)
81143494:	00ffe3c4 	movi	r3,-113
81143498:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8114349c:	00000506 	br	811434b4 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
811434a0:	e0bfff17 	ldw	r2,-4(fp)
811434a4:	00ffe104 	movi	r3,-124
811434a8:	10c00005 	stb	r3,0(r2)
                     break;
811434ac:	00000106 	br	811434b4 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
811434b0:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
811434b4:	1143afc0 	call	81143afc <OSTmr_Unlock>
             return (OS_TRUE);
811434b8:	00800044 	movi	r2,1
811434bc:	00001106 	br	81143504 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
811434c0:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
811434c4:	e0bfff17 	ldw	r2,-4(fp)
811434c8:	00ffe384 	movi	r3,-114
811434cc:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
811434d0:	00800044 	movi	r2,1
811434d4:	00000b06 	br	81143504 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
811434d8:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811434dc:	e0bfff17 	ldw	r2,-4(fp)
811434e0:	00ffe1c4 	movi	r3,-121
811434e4:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811434e8:	0005883a 	mov	r2,zero
811434ec:	00000506 	br	81143504 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
811434f0:	1143afc0 	call	81143afc <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811434f4:	e0bfff17 	ldw	r2,-4(fp)
811434f8:	00ffe344 	movi	r3,-115
811434fc:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81143500:	0005883a 	mov	r2,zero
    }
}
81143504:	e037883a 	mov	sp,fp
81143508:	dfc00117 	ldw	ra,4(sp)
8114350c:	df000017 	ldw	fp,0(sp)
81143510:	dec00204 	addi	sp,sp,8
81143514:	f800283a 	ret

81143518 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
81143518:	defffd04 	addi	sp,sp,-12
8114351c:	de00012e 	bgeu	sp,et,81143524 <OSTmrSignal+0xc>
81143520:	003b68fa 	trap	3
81143524:	dfc00215 	stw	ra,8(sp)
81143528:	df000115 	stw	fp,4(sp)
8114352c:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
81143530:	d0a09017 	ldw	r2,-32192(gp)
81143534:	1009883a 	mov	r4,r2
81143538:	1140ae40 	call	81140ae4 <OSSemPost>
8114353c:	e0bfff05 	stb	r2,-4(fp)
    return (err);
81143540:	e0bfff03 	ldbu	r2,-4(fp)
}
81143544:	e037883a 	mov	sp,fp
81143548:	dfc00117 	ldw	ra,4(sp)
8114354c:	df000017 	ldw	fp,0(sp)
81143550:	dec00204 	addi	sp,sp,8
81143554:	f800283a 	ret

81143558 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
81143558:	defffe04 	addi	sp,sp,-8
8114355c:	de00012e 	bgeu	sp,et,81143564 <OSTmr_Alloc+0xc>
81143560:	003b68fa 	trap	3
81143564:	df000115 	stw	fp,4(sp)
81143568:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
8114356c:	d0a08e17 	ldw	r2,-32200(gp)
81143570:	1000021e 	bne	r2,zero,8114357c <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
81143574:	0005883a 	mov	r2,zero
81143578:	00001006 	br	811435bc <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
8114357c:	d0a08e17 	ldw	r2,-32200(gp)
81143580:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
81143584:	e0bfff17 	ldw	r2,-4(fp)
81143588:	10800317 	ldw	r2,12(r2)
8114358c:	d0a08e15 	stw	r2,-32200(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
81143590:	e0bfff17 	ldw	r2,-4(fp)
81143594:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
81143598:	e0bfff17 	ldw	r2,-4(fp)
8114359c:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
811435a0:	d0a0930b 	ldhu	r2,-32180(gp)
811435a4:	10800044 	addi	r2,r2,1
811435a8:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree--;
811435ac:	d0a0970b 	ldhu	r2,-32164(gp)
811435b0:	10bfffc4 	addi	r2,r2,-1
811435b4:	d0a0970d 	sth	r2,-32164(gp)
    return (ptmr);
811435b8:	e0bfff17 	ldw	r2,-4(fp)
}
811435bc:	e037883a 	mov	sp,fp
811435c0:	df000017 	ldw	fp,0(sp)
811435c4:	dec00104 	addi	sp,sp,4
811435c8:	f800283a 	ret

811435cc <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
811435cc:	defffe04 	addi	sp,sp,-8
811435d0:	de00012e 	bgeu	sp,et,811435d8 <OSTmr_Free+0xc>
811435d4:	003b68fa 	trap	3
811435d8:	df000115 	stw	fp,4(sp)
811435dc:	df000104 	addi	fp,sp,4
811435e0:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
811435e4:	e0bfff17 	ldw	r2,-4(fp)
811435e8:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
811435ec:	e0bfff17 	ldw	r2,-4(fp)
811435f0:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
811435f4:	e0bfff17 	ldw	r2,-4(fp)
811435f8:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
811435fc:	e0bfff17 	ldw	r2,-4(fp)
81143600:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
81143604:	e0bfff17 	ldw	r2,-4(fp)
81143608:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
8114360c:	e0bfff17 	ldw	r2,-4(fp)
81143610:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
81143614:	e0bfff17 	ldw	r2,-4(fp)
81143618:	00c00fc4 	movi	r3,63
8114361c:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
81143620:	e0bfff17 	ldw	r2,-4(fp)
81143624:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
81143628:	e0bfff17 	ldw	r2,-4(fp)
8114362c:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
81143630:	d0e08e17 	ldw	r3,-32200(gp)
81143634:	e0bfff17 	ldw	r2,-4(fp)
81143638:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
8114363c:	e0bfff17 	ldw	r2,-4(fp)
81143640:	d0a08e15 	stw	r2,-32200(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
81143644:	d0a0930b 	ldhu	r2,-32180(gp)
81143648:	10bfffc4 	addi	r2,r2,-1
8114364c:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree++;
81143650:	d0a0970b 	ldhu	r2,-32164(gp)
81143654:	10800044 	addi	r2,r2,1
81143658:	d0a0970d 	sth	r2,-32164(gp)
}
8114365c:	0001883a 	nop
81143660:	e037883a 	mov	sp,fp
81143664:	df000017 	ldw	fp,0(sp)
81143668:	dec00104 	addi	sp,sp,4
8114366c:	f800283a 	ret

81143670 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
81143670:	defffa04 	addi	sp,sp,-24
81143674:	de00012e 	bgeu	sp,et,8114367c <OSTmr_Init+0xc>
81143678:	003b68fa 	trap	3
8114367c:	dfc00515 	stw	ra,20(sp)
81143680:	df000415 	stw	fp,16(sp)
81143684:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
81143688:	01406804 	movi	r5,416
8114368c:	012045f4 	movhi	r4,33047
81143690:	21248604 	addi	r4,r4,-28136
81143694:	113b7e00 	call	8113b7e0 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
81143698:	01400404 	movi	r5,16
8114369c:	012045f4 	movhi	r4,33047
811436a0:	21227204 	addi	r4,r4,-30264
811436a4:	113b7e00 	call	8113b7e0 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
811436a8:	00a045f4 	movhi	r2,33047
811436ac:	10a48604 	addi	r2,r2,-28136
811436b0:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
811436b4:	00a045f4 	movhi	r2,33047
811436b8:	10a49304 	addi	r2,r2,-28084
811436bc:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
811436c0:	e03ffc0d 	sth	zero,-16(fp)
811436c4:	00001606 	br	81143720 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
811436c8:	e0bffd17 	ldw	r2,-12(fp)
811436cc:	00c01904 	movi	r3,100
811436d0:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
811436d4:	e0bffd17 	ldw	r2,-12(fp)
811436d8:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
811436dc:	e0bffd17 	ldw	r2,-12(fp)
811436e0:	e0fffe17 	ldw	r3,-8(fp)
811436e4:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
811436e8:	e0bffd17 	ldw	r2,-12(fp)
811436ec:	00c00fc4 	movi	r3,63
811436f0:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
811436f4:	e0bffd17 	ldw	r2,-12(fp)
811436f8:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
811436fc:	e0bffd17 	ldw	r2,-12(fp)
81143700:	10800d04 	addi	r2,r2,52
81143704:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
81143708:	e0bffe17 	ldw	r2,-8(fp)
8114370c:	10800d04 	addi	r2,r2,52
81143710:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81143714:	e0bffc0b 	ldhu	r2,-16(fp)
81143718:	10800044 	addi	r2,r2,1
8114371c:	e0bffc0d 	sth	r2,-16(fp)
81143720:	e0bffc0b 	ldhu	r2,-16(fp)
81143724:	108001f0 	cmpltui	r2,r2,7
81143728:	103fe71e 	bne	r2,zero,811436c8 <__reset+0xfb1236c8>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
8114372c:	e0bffd17 	ldw	r2,-12(fp)
81143730:	00c01904 	movi	r3,100
81143734:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
81143738:	e0bffd17 	ldw	r2,-12(fp)
8114373c:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
81143740:	e0bffd17 	ldw	r2,-12(fp)
81143744:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
81143748:	e0bffd17 	ldw	r2,-12(fp)
8114374c:	00c00fc4 	movi	r3,63
81143750:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81143754:	e0bffd17 	ldw	r2,-12(fp)
81143758:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
8114375c:	d020a315 	stw	zero,-32116(gp)
    OSTmrUsed           = 0;
81143760:	d020930d 	sth	zero,-32180(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
81143764:	00800204 	movi	r2,8
81143768:	d0a0970d 	sth	r2,-32164(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
8114376c:	00a045f4 	movhi	r2,33047
81143770:	10a48604 	addi	r2,r2,-28136
81143774:	d0a08e15 	stw	r2,-32200(gp)
    OSTmrSem            = OSSemCreate(1);
81143778:	01000044 	movi	r4,1
8114377c:	11404340 	call	81140434 <OSSemCreate>
81143780:	d0a0a515 	stw	r2,-32108(gp)
    OSTmrSemSignal      = OSSemCreate(0);
81143784:	0009883a 	mov	r4,zero
81143788:	11404340 	call	81140434 <OSSemCreate>
8114378c:	d0a09015 	stw	r2,-32192(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
81143790:	d0a0a517 	ldw	r2,-32108(gp)
81143794:	e0ffff04 	addi	r3,fp,-4
81143798:	180d883a 	mov	r6,r3
8114379c:	01604574 	movhi	r5,33045
811437a0:	294b3304 	addi	r5,r5,11468
811437a4:	1009883a 	mov	r4,r2
811437a8:	113a03c0 	call	8113a03c <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
811437ac:	d0a09017 	ldw	r2,-32192(gp)
811437b0:	e0ffff04 	addi	r3,fp,-4
811437b4:	180d883a 	mov	r6,r3
811437b8:	01604574 	movhi	r5,33045
811437bc:	294b3804 	addi	r5,r5,11488
811437c0:	1009883a 	mov	r4,r2
811437c4:	113a03c0 	call	8113a03c <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
811437c8:	11437e40 	call	811437e4 <OSTmr_InitTask>
}
811437cc:	0001883a 	nop
811437d0:	e037883a 	mov	sp,fp
811437d4:	dfc00117 	ldw	ra,4(sp)
811437d8:	df000017 	ldw	fp,0(sp)
811437dc:	dec00204 	addi	sp,sp,8
811437e0:	f800283a 	ret

811437e4 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
811437e4:	defff804 	addi	sp,sp,-32
811437e8:	de00012e 	bgeu	sp,et,811437f0 <OSTmr_InitTask+0xc>
811437ec:	003b68fa 	trap	3
811437f0:	dfc00715 	stw	ra,28(sp)
811437f4:	df000615 	stw	fp,24(sp)
811437f8:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
811437fc:	008000c4 	movi	r2,3
81143800:	d8800415 	stw	r2,16(sp)
81143804:	d8000315 	stw	zero,12(sp)
81143808:	00808004 	movi	r2,512
8114380c:	d8800215 	stw	r2,8(sp)
81143810:	00a045f4 	movhi	r2,33047
81143814:	10acba04 	addi	r2,r2,-19736
81143818:	d8800115 	stw	r2,4(sp)
8114381c:	00bfff54 	movui	r2,65533
81143820:	d8800015 	stw	r2,0(sp)
81143824:	01c00744 	movi	r7,29
81143828:	01a045f4 	movhi	r6,33047
8114382c:	31aeb904 	addi	r6,r6,-17692
81143830:	000b883a 	mov	r5,zero
81143834:	01204534 	movhi	r4,33044
81143838:	210ece04 	addi	r4,r4,15160
8114383c:	11414c80 	call	811414c8 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
81143840:	e1bfff04 	addi	r6,fp,-4
81143844:	01604574 	movhi	r5,33045
81143848:	294b3d04 	addi	r5,r5,11508
8114384c:	01000744 	movi	r4,29
81143850:	1141cf80 	call	81141cf8 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
81143854:	0001883a 	nop
81143858:	e037883a 	mov	sp,fp
8114385c:	dfc00117 	ldw	ra,4(sp)
81143860:	df000017 	ldw	fp,0(sp)
81143864:	dec00204 	addi	sp,sp,8
81143868:	f800283a 	ret

8114386c <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
8114386c:	defffa04 	addi	sp,sp,-24
81143870:	de00012e 	bgeu	sp,et,81143878 <OSTmr_Link+0xc>
81143874:	003b68fa 	trap	3
81143878:	df000515 	stw	fp,20(sp)
8114387c:	df000504 	addi	fp,sp,20
81143880:	e13ffe15 	stw	r4,-8(fp)
81143884:	2805883a 	mov	r2,r5
81143888:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
8114388c:	e0bffe17 	ldw	r2,-8(fp)
81143890:	00c000c4 	movi	r3,3
81143894:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
81143898:	e0bfff03 	ldbu	r2,-4(fp)
8114389c:	10800058 	cmpnei	r2,r2,1
811438a0:	1000071e 	bne	r2,zero,811438c0 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
811438a4:	e0bffe17 	ldw	r2,-8(fp)
811438a8:	10c00717 	ldw	r3,28(r2)
811438ac:	d0a0a317 	ldw	r2,-32116(gp)
811438b0:	1887883a 	add	r3,r3,r2
811438b4:	e0bffe17 	ldw	r2,-8(fp)
811438b8:	10c00515 	stw	r3,20(r2)
811438bc:	00001006 	br	81143900 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
811438c0:	e0bffe17 	ldw	r2,-8(fp)
811438c4:	10800617 	ldw	r2,24(r2)
811438c8:	1000071e 	bne	r2,zero,811438e8 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
811438cc:	e0bffe17 	ldw	r2,-8(fp)
811438d0:	10c00717 	ldw	r3,28(r2)
811438d4:	d0a0a317 	ldw	r2,-32116(gp)
811438d8:	1887883a 	add	r3,r3,r2
811438dc:	e0bffe17 	ldw	r2,-8(fp)
811438e0:	10c00515 	stw	r3,20(r2)
811438e4:	00000606 	br	81143900 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
811438e8:	e0bffe17 	ldw	r2,-8(fp)
811438ec:	10c00617 	ldw	r3,24(r2)
811438f0:	d0a0a317 	ldw	r2,-32116(gp)
811438f4:	1887883a 	add	r3,r3,r2
811438f8:	e0bffe17 	ldw	r2,-8(fp)
811438fc:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81143900:	e0bffe17 	ldw	r2,-8(fp)
81143904:	10800517 	ldw	r2,20(r2)
81143908:	1080004c 	andi	r2,r2,1
8114390c:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81143910:	e0bffb0b 	ldhu	r2,-20(fp)
81143914:	100690fa 	slli	r3,r2,3
81143918:	00a045f4 	movhi	r2,33047
8114391c:	10a27204 	addi	r2,r2,-30264
81143920:	1885883a 	add	r2,r3,r2
81143924:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
81143928:	e0bffc17 	ldw	r2,-16(fp)
8114392c:	10800017 	ldw	r2,0(r2)
81143930:	1000091e 	bne	r2,zero,81143958 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
81143934:	e0bffc17 	ldw	r2,-16(fp)
81143938:	e0fffe17 	ldw	r3,-8(fp)
8114393c:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
81143940:	e0bffe17 	ldw	r2,-8(fp)
81143944:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
81143948:	e0bffc17 	ldw	r2,-16(fp)
8114394c:	00c00044 	movi	r3,1
81143950:	10c0010d 	sth	r3,4(r2)
81143954:	00001206 	br	811439a0 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
81143958:	e0bffc17 	ldw	r2,-16(fp)
8114395c:	10800017 	ldw	r2,0(r2)
81143960:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
81143964:	e0bffc17 	ldw	r2,-16(fp)
81143968:	e0fffe17 	ldw	r3,-8(fp)
8114396c:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
81143970:	e0bffe17 	ldw	r2,-8(fp)
81143974:	e0fffd17 	ldw	r3,-12(fp)
81143978:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
8114397c:	e0bffd17 	ldw	r2,-12(fp)
81143980:	e0fffe17 	ldw	r3,-8(fp)
81143984:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
81143988:	e0bffc17 	ldw	r2,-16(fp)
8114398c:	1080010b 	ldhu	r2,4(r2)
81143990:	10800044 	addi	r2,r2,1
81143994:	1007883a 	mov	r3,r2
81143998:	e0bffc17 	ldw	r2,-16(fp)
8114399c:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
811439a0:	e0bffe17 	ldw	r2,-8(fp)
811439a4:	10000415 	stw	zero,16(r2)
}
811439a8:	0001883a 	nop
811439ac:	e037883a 	mov	sp,fp
811439b0:	df000017 	ldw	fp,0(sp)
811439b4:	dec00104 	addi	sp,sp,4
811439b8:	f800283a 	ret

811439bc <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
811439bc:	defffa04 	addi	sp,sp,-24
811439c0:	de00012e 	bgeu	sp,et,811439c8 <OSTmr_Unlink+0xc>
811439c4:	003b68fa 	trap	3
811439c8:	df000515 	stw	fp,20(sp)
811439cc:	df000504 	addi	fp,sp,20
811439d0:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
811439d4:	e0bfff17 	ldw	r2,-4(fp)
811439d8:	10800517 	ldw	r2,20(r2)
811439dc:	1080004c 	andi	r2,r2,1
811439e0:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
811439e4:	e0bffb0b 	ldhu	r2,-20(fp)
811439e8:	100690fa 	slli	r3,r2,3
811439ec:	00a045f4 	movhi	r2,33047
811439f0:	10a27204 	addi	r2,r2,-30264
811439f4:	1885883a 	add	r2,r3,r2
811439f8:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
811439fc:	e0bffc17 	ldw	r2,-16(fp)
81143a00:	10c00017 	ldw	r3,0(r2)
81143a04:	e0bfff17 	ldw	r2,-4(fp)
81143a08:	18800b1e 	bne	r3,r2,81143a38 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
81143a0c:	e0bfff17 	ldw	r2,-4(fp)
81143a10:	10800317 	ldw	r2,12(r2)
81143a14:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
81143a18:	e0bffc17 	ldw	r2,-16(fp)
81143a1c:	e0fffd17 	ldw	r3,-12(fp)
81143a20:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
81143a24:	e0bffd17 	ldw	r2,-12(fp)
81143a28:	10001126 	beq	r2,zero,81143a70 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
81143a2c:	e0bffd17 	ldw	r2,-12(fp)
81143a30:	10000415 	stw	zero,16(r2)
81143a34:	00000e06 	br	81143a70 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
81143a38:	e0bfff17 	ldw	r2,-4(fp)
81143a3c:	10800417 	ldw	r2,16(r2)
81143a40:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
81143a44:	e0bfff17 	ldw	r2,-4(fp)
81143a48:	10800317 	ldw	r2,12(r2)
81143a4c:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
81143a50:	e0bffd17 	ldw	r2,-12(fp)
81143a54:	e0fffe17 	ldw	r3,-8(fp)
81143a58:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
81143a5c:	e0bffe17 	ldw	r2,-8(fp)
81143a60:	10000326 	beq	r2,zero,81143a70 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
81143a64:	e0bffe17 	ldw	r2,-8(fp)
81143a68:	e0fffd17 	ldw	r3,-12(fp)
81143a6c:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
81143a70:	e0bfff17 	ldw	r2,-4(fp)
81143a74:	00c00044 	movi	r3,1
81143a78:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
81143a7c:	e0bfff17 	ldw	r2,-4(fp)
81143a80:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
81143a84:	e0bfff17 	ldw	r2,-4(fp)
81143a88:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
81143a8c:	e0bffc17 	ldw	r2,-16(fp)
81143a90:	1080010b 	ldhu	r2,4(r2)
81143a94:	10bfffc4 	addi	r2,r2,-1
81143a98:	1007883a 	mov	r3,r2
81143a9c:	e0bffc17 	ldw	r2,-16(fp)
81143aa0:	10c0010d 	sth	r3,4(r2)
}
81143aa4:	0001883a 	nop
81143aa8:	e037883a 	mov	sp,fp
81143aac:	df000017 	ldw	fp,0(sp)
81143ab0:	dec00104 	addi	sp,sp,4
81143ab4:	f800283a 	ret

81143ab8 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
81143ab8:	defffd04 	addi	sp,sp,-12
81143abc:	de00012e 	bgeu	sp,et,81143ac4 <OSTmr_Lock+0xc>
81143ac0:	003b68fa 	trap	3
81143ac4:	dfc00215 	stw	ra,8(sp)
81143ac8:	df000115 	stw	fp,4(sp)
81143acc:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
81143ad0:	d0a0a517 	ldw	r2,-32108(gp)
81143ad4:	e1bfff04 	addi	r6,fp,-4
81143ad8:	000b883a 	mov	r5,zero
81143adc:	1009883a 	mov	r4,r2
81143ae0:	114075c0 	call	8114075c <OSSemPend>
    (void)err;
}
81143ae4:	0001883a 	nop
81143ae8:	e037883a 	mov	sp,fp
81143aec:	dfc00117 	ldw	ra,4(sp)
81143af0:	df000017 	ldw	fp,0(sp)
81143af4:	dec00204 	addi	sp,sp,8
81143af8:	f800283a 	ret

81143afc <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
81143afc:	defffe04 	addi	sp,sp,-8
81143b00:	de00012e 	bgeu	sp,et,81143b08 <OSTmr_Unlock+0xc>
81143b04:	003b68fa 	trap	3
81143b08:	dfc00115 	stw	ra,4(sp)
81143b0c:	df000015 	stw	fp,0(sp)
81143b10:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
81143b14:	d0a0a517 	ldw	r2,-32108(gp)
81143b18:	1009883a 	mov	r4,r2
81143b1c:	1140ae40 	call	81140ae4 <OSSemPost>
}
81143b20:	0001883a 	nop
81143b24:	e037883a 	mov	sp,fp
81143b28:	dfc00117 	ldw	ra,4(sp)
81143b2c:	df000017 	ldw	fp,0(sp)
81143b30:	dec00204 	addi	sp,sp,8
81143b34:	f800283a 	ret

81143b38 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
81143b38:	defff704 	addi	sp,sp,-36
81143b3c:	de00012e 	bgeu	sp,et,81143b44 <OSTmr_Task+0xc>
81143b40:	003b68fa 	trap	3
81143b44:	dfc00815 	stw	ra,32(sp)
81143b48:	df000715 	stw	fp,28(sp)
81143b4c:	df000704 	addi	fp,sp,28
81143b50:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
81143b54:	d0a09017 	ldw	r2,-32192(gp)
81143b58:	e0fffe04 	addi	r3,fp,-8
81143b5c:	180d883a 	mov	r6,r3
81143b60:	000b883a 	mov	r5,zero
81143b64:	1009883a 	mov	r4,r2
81143b68:	114075c0 	call	8114075c <OSSemPend>
        OSTmr_Lock();
81143b6c:	1143ab80 	call	81143ab8 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
81143b70:	d0a0a317 	ldw	r2,-32116(gp)
81143b74:	10800044 	addi	r2,r2,1
81143b78:	d0a0a315 	stw	r2,-32116(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
81143b7c:	d0a0a317 	ldw	r2,-32116(gp)
81143b80:	1080004c 	andi	r2,r2,1
81143b84:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
81143b88:	e0bffa0b 	ldhu	r2,-24(fp)
81143b8c:	100690fa 	slli	r3,r2,3
81143b90:	00a045f4 	movhi	r2,33047
81143b94:	10a27204 	addi	r2,r2,-30264
81143b98:	1885883a 	add	r2,r3,r2
81143b9c:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
81143ba0:	e0bffb17 	ldw	r2,-20(fp)
81143ba4:	10800017 	ldw	r2,0(r2)
81143ba8:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
81143bac:	00002206 	br	81143c38 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
81143bb0:	e0bff917 	ldw	r2,-28(fp)
81143bb4:	10800317 	ldw	r2,12(r2)
81143bb8:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
81143bbc:	e0bff917 	ldw	r2,-28(fp)
81143bc0:	10c00517 	ldw	r3,20(r2)
81143bc4:	d0a0a317 	ldw	r2,-32116(gp)
81143bc8:	1880191e 	bne	r3,r2,81143c30 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
81143bcc:	e0bff917 	ldw	r2,-28(fp)
81143bd0:	10800117 	ldw	r2,4(r2)
81143bd4:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
81143bd8:	e0bffd17 	ldw	r2,-12(fp)
81143bdc:	10000626 	beq	r2,zero,81143bf8 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
81143be0:	e0bff917 	ldw	r2,-28(fp)
81143be4:	10c00217 	ldw	r3,8(r2)
81143be8:	e0bffd17 	ldw	r2,-12(fp)
81143bec:	180b883a 	mov	r5,r3
81143bf0:	e13ff917 	ldw	r4,-28(fp)
81143bf4:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
81143bf8:	e13ff917 	ldw	r4,-28(fp)
81143bfc:	11439bc0 	call	811439bc <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
81143c00:	e0bff917 	ldw	r2,-28(fp)
81143c04:	10800c03 	ldbu	r2,48(r2)
81143c08:	10803fcc 	andi	r2,r2,255
81143c0c:	10800098 	cmpnei	r2,r2,2
81143c10:	1000041e 	bne	r2,zero,81143c24 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
81143c14:	01400044 	movi	r5,1
81143c18:	e13ff917 	ldw	r4,-28(fp)
81143c1c:	114386c0 	call	8114386c <OSTmr_Link>
81143c20:	00000306 	br	81143c30 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
81143c24:	e0bff917 	ldw	r2,-28(fp)
81143c28:	00c00084 	movi	r3,2
81143c2c:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
81143c30:	e0bffc17 	ldw	r2,-16(fp)
81143c34:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
81143c38:	e0bff917 	ldw	r2,-28(fp)
81143c3c:	103fdc1e 	bne	r2,zero,81143bb0 <__reset+0xfb123bb0>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
81143c40:	1143afc0 	call	81143afc <OSTmr_Unlock>
    }
81143c44:	003fc306 	br	81143b54 <__reset+0xfb123b54>

81143c48 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
81143c48:	defffd04 	addi	sp,sp,-12
81143c4c:	de00012e 	bgeu	sp,et,81143c54 <alt_dev_reg+0xc>
81143c50:	003b68fa 	trap	3
81143c54:	dfc00215 	stw	ra,8(sp)
81143c58:	df000115 	stw	fp,4(sp)
81143c5c:	df000104 	addi	fp,sp,4
81143c60:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
81143c64:	d1600d04 	addi	r5,gp,-32716
81143c68:	e13fff17 	ldw	r4,-4(fp)
81143c6c:	114bee80 	call	8114bee8 <alt_dev_llist_insert>
}
81143c70:	e037883a 	mov	sp,fp
81143c74:	dfc00117 	ldw	ra,4(sp)
81143c78:	df000017 	ldw	fp,0(sp)
81143c7c:	dec00204 	addi	sp,sp,8
81143c80:	f800283a 	ret

81143c84 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
81143c84:	defffd04 	addi	sp,sp,-12
81143c88:	de00012e 	bgeu	sp,et,81143c90 <alt_irq_init+0xc>
81143c8c:	003b68fa 	trap	3
81143c90:	dfc00215 	stw	ra,8(sp)
81143c94:	df000115 	stw	fp,4(sp)
81143c98:	df000104 	addi	fp,sp,4
81143c9c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
81143ca0:	114c8b00 	call	8114c8b0 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
81143ca4:	00800044 	movi	r2,1
81143ca8:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
81143cac:	0001883a 	nop
81143cb0:	e037883a 	mov	sp,fp
81143cb4:	dfc00117 	ldw	ra,4(sp)
81143cb8:	df000017 	ldw	fp,0(sp)
81143cbc:	dec00204 	addi	sp,sp,8
81143cc0:	f800283a 	ret

81143cc4 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
81143cc4:	defffe04 	addi	sp,sp,-8
81143cc8:	de00012e 	bgeu	sp,et,81143cd0 <alt_sys_init+0xc>
81143ccc:	003b68fa 	trap	3
81143cd0:	dfc00115 	stw	ra,4(sp)
81143cd4:	df000015 	stw	fp,0(sp)
81143cd8:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
81143cdc:	01c0fa04 	movi	r7,1000
81143ce0:	01800304 	movi	r6,12
81143ce4:	000b883a 	mov	r5,zero
81143ce8:	01200034 	movhi	r4,32768
81143cec:	21022004 	addi	r4,r4,2176
81143cf0:	114901c0 	call	8114901c <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
81143cf4:	018002c4 	movi	r6,11
81143cf8:	000b883a 	mov	r5,zero
81143cfc:	01204574 	movhi	r4,33045
81143d00:	210ed904 	addi	r4,r4,15204
81143d04:	11483080 	call	81148308 <altera_avalon_jtag_uart_init>
81143d08:	01204574 	movhi	r4,33045
81143d0c:	210ecf04 	addi	r4,r4,15164
81143d10:	1143c480 	call	81143c48 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
81143d14:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
81143d18:	018003c4 	movi	r6,15
81143d1c:	000b883a 	mov	r5,zero
81143d20:	01204574 	movhi	r4,33045
81143d24:	2112f404 	addi	r4,r4,19408
81143d28:	11491c80 	call	811491c8 <altera_avalon_uart_init>
81143d2c:	01204574 	movhi	r4,33045
81143d30:	2112ea04 	addi	r4,r4,19368
81143d34:	1143c480 	call	81143c48 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
81143d38:	00a04574 	movhi	r2,33045
81143d3c:	10931e04 	addi	r2,r2,19576
81143d40:	10c00717 	ldw	r3,28(r2)
81143d44:	00a04574 	movhi	r2,33045
81143d48:	10931e04 	addi	r2,r2,19576
81143d4c:	10800817 	ldw	r2,32(r2)
81143d50:	100d883a 	mov	r6,r2
81143d54:	180b883a 	mov	r5,r3
81143d58:	01204574 	movhi	r4,33045
81143d5c:	21131e04 	addi	r4,r4,19576
81143d60:	114ba500 	call	8114ba50 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
81143d64:	00a04574 	movhi	r2,33045
81143d68:	10933704 	addi	r2,r2,19676
81143d6c:	10c00717 	ldw	r3,28(r2)
81143d70:	00a04574 	movhi	r2,33045
81143d74:	10933704 	addi	r2,r2,19676
81143d78:	10800817 	ldw	r2,32(r2)
81143d7c:	100d883a 	mov	r6,r2
81143d80:	180b883a 	mov	r5,r3
81143d84:	01204574 	movhi	r4,33045
81143d88:	21133704 	addi	r4,r4,19676
81143d8c:	114ba500 	call	8114ba50 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
81143d90:	01204574 	movhi	r4,33045
81143d94:	21135004 	addi	r4,r4,19776
81143d98:	1143c480 	call	81143c48 <alt_dev_reg>
}
81143d9c:	0001883a 	nop
81143da0:	e037883a 	mov	sp,fp
81143da4:	dfc00117 	ldw	ra,4(sp)
81143da8:	df000017 	ldw	fp,0(sp)
81143dac:	dec00204 	addi	sp,sp,8
81143db0:	f800283a 	ret

81143db4 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
81143db4:	defffa04 	addi	sp,sp,-24
81143db8:	de00012e 	bgeu	sp,et,81143dc0 <Write_Sector_Data+0xc>
81143dbc:	003b68fa 	trap	3
81143dc0:	dfc00515 	stw	ra,20(sp)
81143dc4:	df000415 	stw	fp,16(sp)
81143dc8:	df000404 	addi	fp,sp,16
81143dcc:	e13ffe15 	stw	r4,-8(fp)
81143dd0:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81143dd4:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
81143dd8:	1146b9c0 	call	81146b9c <alt_up_sd_card_is_Present>
81143ddc:	10001e26 	beq	r2,zero,81143e58 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
81143de0:	00803fc4 	movi	r2,255
81143de4:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81143de8:	d0a0af17 	ldw	r2,-32068(gp)
81143dec:	e13ffe17 	ldw	r4,-8(fp)
81143df0:	e0ffff17 	ldw	r3,-4(fp)
81143df4:	20c7883a 	add	r3,r4,r3
81143df8:	1806927a 	slli	r3,r3,9
81143dfc:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
81143e00:	d0a0ae17 	ldw	r2,-32072(gp)
81143e04:	00c00604 	movi	r3,24
81143e08:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
81143e0c:	d0a0ab17 	ldw	r2,-32084(gp)
81143e10:	1080002b 	ldhuio	r2,0(r2)
81143e14:	10bfffcc 	andi	r2,r2,65535
81143e18:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
81143e1c:	e0bffd0b 	ldhu	r2,-12(fp)
81143e20:	10bfffcc 	andi	r2,r2,65535
81143e24:	1080010c 	andi	r2,r2,4
81143e28:	103ff81e 	bne	r2,zero,81143e0c <__reset+0xfb123e0c>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
81143e2c:	e0bffd0b 	ldhu	r2,-12(fp)
81143e30:	10bfffcc 	andi	r2,r2,65535
81143e34:	1080040c 	andi	r2,r2,16
81143e38:	1000071e 	bne	r2,zero,81143e58 <Write_Sector_Data+0xa4>
        {
            result = true;
81143e3c:	00800044 	movi	r2,1
81143e40:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81143e44:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
81143e48:	e0fffe17 	ldw	r3,-8(fp)
81143e4c:	e0bfff17 	ldw	r2,-4(fp)
81143e50:	1885883a 	add	r2,r3,r2
81143e54:	d0a0b515 	stw	r2,-32044(gp)
        }
    }
    return result;
81143e58:	e0bffc17 	ldw	r2,-16(fp)
}
81143e5c:	e037883a 	mov	sp,fp
81143e60:	dfc00117 	ldw	ra,4(sp)
81143e64:	df000017 	ldw	fp,0(sp)
81143e68:	dec00204 	addi	sp,sp,8
81143e6c:	f800283a 	ret

81143e70 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
81143e70:	defffd04 	addi	sp,sp,-12
81143e74:	de00012e 	bgeu	sp,et,81143e7c <Save_Modified_Sector+0xc>
81143e78:	003b68fa 	trap	3
81143e7c:	dfc00215 	stw	ra,8(sp)
81143e80:	df000115 	stw	fp,4(sp)
81143e84:	df000104 	addi	fp,sp,4
    bool result = true;
81143e88:	00800044 	movi	r2,1
81143e8c:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
81143e90:	d0a0b417 	ldw	r2,-32048(gp)
81143e94:	10000526 	beq	r2,zero,81143eac <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
81143e98:	d0a0b517 	ldw	r2,-32044(gp)
81143e9c:	000b883a 	mov	r5,zero
81143ea0:	1009883a 	mov	r4,r2
81143ea4:	1143db40 	call	81143db4 <Write_Sector_Data>
81143ea8:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
81143eac:	e0bfff17 	ldw	r2,-4(fp)
}
81143eb0:	e037883a 	mov	sp,fp
81143eb4:	dfc00117 	ldw	ra,4(sp)
81143eb8:	df000017 	ldw	fp,0(sp)
81143ebc:	dec00204 	addi	sp,sp,8
81143ec0:	f800283a 	ret

81143ec4 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
81143ec4:	defffa04 	addi	sp,sp,-24
81143ec8:	de00012e 	bgeu	sp,et,81143ed0 <Read_Sector_Data+0xc>
81143ecc:	003b68fa 	trap	3
81143ed0:	dfc00515 	stw	ra,20(sp)
81143ed4:	df000415 	stw	fp,16(sp)
81143ed8:	df000404 	addi	fp,sp,16
81143edc:	e13ffe15 	stw	r4,-8(fp)
81143ee0:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
81143ee4:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
81143ee8:	1146b9c0 	call	81146b9c <alt_up_sd_card_is_Present>
81143eec:	10002726 	beq	r2,zero,81143f8c <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
81143ef0:	00803fc4 	movi	r2,255
81143ef4:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
81143ef8:	d0a0b417 	ldw	r2,-32048(gp)
81143efc:	10000726 	beq	r2,zero,81143f1c <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
81143f00:	d0a0b517 	ldw	r2,-32044(gp)
81143f04:	000b883a 	mov	r5,zero
81143f08:	1009883a 	mov	r4,r2
81143f0c:	1143db40 	call	81143db4 <Write_Sector_Data>
81143f10:	1000021e 	bne	r2,zero,81143f1c <Read_Sector_Data+0x58>
            {
                return false;
81143f14:	0005883a 	mov	r2,zero
81143f18:	00001d06 	br	81143f90 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81143f1c:	d0a0af17 	ldw	r2,-32068(gp)
81143f20:	e13ffe17 	ldw	r4,-8(fp)
81143f24:	e0ffff17 	ldw	r3,-4(fp)
81143f28:	20c7883a 	add	r3,r4,r3
81143f2c:	1806927a 	slli	r3,r3,9
81143f30:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
81143f34:	d0a0ae17 	ldw	r2,-32072(gp)
81143f38:	00c00444 	movi	r3,17
81143f3c:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
81143f40:	d0a0ab17 	ldw	r2,-32084(gp)
81143f44:	1080002b 	ldhuio	r2,0(r2)
81143f48:	10bfffcc 	andi	r2,r2,65535
81143f4c:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
81143f50:	e0bffd0b 	ldhu	r2,-12(fp)
81143f54:	10bfffcc 	andi	r2,r2,65535
81143f58:	1080010c 	andi	r2,r2,4
81143f5c:	103ff81e 	bne	r2,zero,81143f40 <__reset+0xfb123f40>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
81143f60:	e0bffd0b 	ldhu	r2,-12(fp)
81143f64:	10bfffcc 	andi	r2,r2,65535
81143f68:	1080040c 	andi	r2,r2,16
81143f6c:	1000071e 	bne	r2,zero,81143f8c <Read_Sector_Data+0xc8>
		{
			result = true;
81143f70:	00800044 	movi	r2,1
81143f74:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81143f78:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
81143f7c:	e0fffe17 	ldw	r3,-8(fp)
81143f80:	e0bfff17 	ldw	r2,-4(fp)
81143f84:	1885883a 	add	r2,r3,r2
81143f88:	d0a0b515 	stw	r2,-32044(gp)
		}
	}
	return result;
81143f8c:	e0bffc17 	ldw	r2,-16(fp)
}
81143f90:	e037883a 	mov	sp,fp
81143f94:	dfc00117 	ldw	ra,4(sp)
81143f98:	df000017 	ldw	fp,0(sp)
81143f9c:	dec00204 	addi	sp,sp,8
81143fa0:	f800283a 	ret

81143fa4 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
81143fa4:	defffb04 	addi	sp,sp,-20
81143fa8:	de00012e 	bgeu	sp,et,81143fb0 <get_cluster_flag+0xc>
81143fac:	003b68fa 	trap	3
81143fb0:	dfc00415 	stw	ra,16(sp)
81143fb4:	df000315 	stw	fp,12(sp)
81143fb8:	df000304 	addi	fp,sp,12
81143fbc:	e13ffe15 	stw	r4,-8(fp)
81143fc0:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
81143fc4:	e0bffe17 	ldw	r2,-8(fp)
81143fc8:	1004d23a 	srli	r2,r2,8
81143fcc:	d0e0b117 	ldw	r3,-32060(gp)
81143fd0:	10c5883a 	add	r2,r2,r3
81143fd4:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81143fd8:	00a045f4 	movhi	r2,33047
81143fdc:	10ba9804 	addi	r2,r2,-5536
81143fe0:	10801117 	ldw	r2,68(r2)
81143fe4:	e0fffd17 	ldw	r3,-12(fp)
81143fe8:	1885883a 	add	r2,r3,r2
81143fec:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
81143ff0:	d0a0b517 	ldw	r2,-32044(gp)
81143ff4:	e0fffd17 	ldw	r3,-12(fp)
81143ff8:	18800726 	beq	r3,r2,81144018 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
81143ffc:	e0bffd17 	ldw	r2,-12(fp)
81144000:	000b883a 	mov	r5,zero
81144004:	1009883a 	mov	r4,r2
81144008:	1143ec40 	call	81143ec4 <Read_Sector_Data>
8114400c:	1000021e 	bne	r2,zero,81144018 <get_cluster_flag+0x74>
        {
            return false;
81144010:	0005883a 	mov	r2,zero
81144014:	00000d06 	br	8114404c <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
81144018:	e0bffe17 	ldw	r2,-8(fp)
8114401c:	10803fcc 	andi	r2,r2,255
81144020:	1085883a 	add	r2,r2,r2
81144024:	1007883a 	mov	r3,r2
81144028:	d0a0b317 	ldw	r2,-32052(gp)
8114402c:	10800a17 	ldw	r2,40(r2)
81144030:	1885883a 	add	r2,r3,r2
81144034:	1080002b 	ldhuio	r2,0(r2)
81144038:	10bfffcc 	andi	r2,r2,65535
8114403c:	1007883a 	mov	r3,r2
81144040:	e0bfff17 	ldw	r2,-4(fp)
81144044:	10c0000d 	sth	r3,0(r2)
    return true;
81144048:	00800044 	movi	r2,1
}
8114404c:	e037883a 	mov	sp,fp
81144050:	dfc00117 	ldw	ra,4(sp)
81144054:	df000017 	ldw	fp,0(sp)
81144058:	dec00204 	addi	sp,sp,8
8114405c:	f800283a 	ret

81144060 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
81144060:	defffa04 	addi	sp,sp,-24
81144064:	de00012e 	bgeu	sp,et,8114406c <mark_cluster+0xc>
81144068:	003b68fa 	trap	3
8114406c:	dfc00515 	stw	ra,20(sp)
81144070:	df000415 	stw	fp,16(sp)
81144074:	df000404 	addi	fp,sp,16
81144078:	e13ffd15 	stw	r4,-12(fp)
8114407c:	2805883a 	mov	r2,r5
81144080:	e1bfff15 	stw	r6,-4(fp)
81144084:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
81144088:	e0bffd17 	ldw	r2,-12(fp)
8114408c:	1004d23a 	srli	r2,r2,8
81144090:	d0e0b117 	ldw	r3,-32060(gp)
81144094:	10c5883a 	add	r2,r2,r3
81144098:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
8114409c:	e0bfff17 	ldw	r2,-4(fp)
811440a0:	10000726 	beq	r2,zero,811440c0 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
811440a4:	00a045f4 	movhi	r2,33047
811440a8:	10ba9804 	addi	r2,r2,-5536
811440ac:	10801117 	ldw	r2,68(r2)
811440b0:	e0fffc17 	ldw	r3,-16(fp)
811440b4:	1885883a 	add	r2,r3,r2
811440b8:	e0bffc15 	stw	r2,-16(fp)
811440bc:	00000606 	br	811440d8 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
811440c0:	00a045f4 	movhi	r2,33047
811440c4:	10ba9804 	addi	r2,r2,-5536
811440c8:	10801217 	ldw	r2,72(r2)
811440cc:	e0fffc17 	ldw	r3,-16(fp)
811440d0:	1885883a 	add	r2,r3,r2
811440d4:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
811440d8:	d0a0b517 	ldw	r2,-32044(gp)
811440dc:	e0fffc17 	ldw	r3,-16(fp)
811440e0:	18800726 	beq	r3,r2,81144100 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
811440e4:	e0bffc17 	ldw	r2,-16(fp)
811440e8:	000b883a 	mov	r5,zero
811440ec:	1009883a 	mov	r4,r2
811440f0:	1143ec40 	call	81143ec4 <Read_Sector_Data>
811440f4:	1000021e 	bne	r2,zero,81144100 <mark_cluster+0xa0>
        {
            return false;
811440f8:	0005883a 	mov	r2,zero
811440fc:	00000d06 	br	81144134 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
81144100:	e0bffd17 	ldw	r2,-12(fp)
81144104:	10803fcc 	andi	r2,r2,255
81144108:	1085883a 	add	r2,r2,r2
8114410c:	1007883a 	mov	r3,r2
81144110:	d0a0b317 	ldw	r2,-32052(gp)
81144114:	10800a17 	ldw	r2,40(r2)
81144118:	1885883a 	add	r2,r3,r2
8114411c:	1007883a 	mov	r3,r2
81144120:	e0bffe0f 	ldh	r2,-8(fp)
81144124:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
81144128:	00800044 	movi	r2,1
8114412c:	d0a0b415 	stw	r2,-32048(gp)
    return true;
81144130:	00800044 	movi	r2,1
}
81144134:	e037883a 	mov	sp,fp
81144138:	dfc00117 	ldw	ra,4(sp)
8114413c:	df000017 	ldw	fp,0(sp)
81144140:	dec00204 	addi	sp,sp,8
81144144:	f800283a 	ret

81144148 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
81144148:	defff704 	addi	sp,sp,-36
8114414c:	de00012e 	bgeu	sp,et,81144154 <Check_for_Master_Boot_Record+0xc>
81144150:	003b68fa 	trap	3
81144154:	dfc00815 	stw	ra,32(sp)
81144158:	df000715 	stw	fp,28(sp)
8114415c:	df000704 	addi	fp,sp,28
	bool result = false;
81144160:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
81144164:	000b883a 	mov	r5,zero
81144168:	0009883a 	mov	r4,zero
8114416c:	1143ec40 	call	81143ec4 <Read_Sector_Data>
81144170:	10005a26 	beq	r2,zero,811442dc <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
81144174:	d0a0b317 	ldw	r2,-32052(gp)
81144178:	10800a17 	ldw	r2,40(r2)
8114417c:	10807f84 	addi	r2,r2,510
81144180:	1080002b 	ldhuio	r2,0(r2)
81144184:	10bfffcc 	andi	r2,r2,65535
81144188:	10bfffcc 	andi	r2,r2,65535
8114418c:	10a0001c 	xori	r2,r2,32768
81144190:	10a00004 	addi	r2,r2,-32768
81144194:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
81144198:	e0bffb17 	ldw	r2,-20(fp)
8114419c:	10ffffcc 	andi	r3,r2,65535
811441a0:	00aa9554 	movui	r2,43605
811441a4:	18804d1e 	bne	r3,r2,811442dc <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
811441a8:	e03ffa15 	stw	zero,-24(fp)
811441ac:	00004806 	br	811442d0 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
811441b0:	e0bffa17 	ldw	r2,-24(fp)
811441b4:	1004913a 	slli	r2,r2,4
811441b8:	10806f84 	addi	r2,r2,446
811441bc:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
811441c0:	d0a0b317 	ldw	r2,-32052(gp)
811441c4:	10c00a17 	ldw	r3,40(r2)
811441c8:	e0bffc17 	ldw	r2,-16(fp)
811441cc:	1885883a 	add	r2,r3,r2
811441d0:	10800104 	addi	r2,r2,4
811441d4:	10800023 	ldbuio	r2,0(r2)
811441d8:	10803fcc 	andi	r2,r2,255
811441dc:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
811441e0:	e0bffd07 	ldb	r2,-12(fp)
811441e4:	10800060 	cmpeqi	r2,r2,1
811441e8:	1000091e 	bne	r2,zero,81144210 <Check_for_Master_Boot_Record+0xc8>
811441ec:	e0bffd07 	ldb	r2,-12(fp)
811441f0:	10800120 	cmpeqi	r2,r2,4
811441f4:	1000061e 	bne	r2,zero,81144210 <Check_for_Master_Boot_Record+0xc8>
811441f8:	e0bffd07 	ldb	r2,-12(fp)
811441fc:	108001a0 	cmpeqi	r2,r2,6
81144200:	1000031e 	bne	r2,zero,81144210 <Check_for_Master_Boot_Record+0xc8>
81144204:	e0bffd07 	ldb	r2,-12(fp)
81144208:	10800398 	cmpnei	r2,r2,14
8114420c:	10002d1e 	bne	r2,zero,811442c4 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
81144210:	d0a0b317 	ldw	r2,-32052(gp)
81144214:	10c00a17 	ldw	r3,40(r2)
81144218:	e0bffc17 	ldw	r2,-16(fp)
8114421c:	1885883a 	add	r2,r3,r2
81144220:	10800284 	addi	r2,r2,10
81144224:	1080002b 	ldhuio	r2,0(r2)
81144228:	10bfffcc 	andi	r2,r2,65535
8114422c:	1006943a 	slli	r3,r2,16
81144230:	d0a0b317 	ldw	r2,-32052(gp)
81144234:	11000a17 	ldw	r4,40(r2)
81144238:	e0bffc17 	ldw	r2,-16(fp)
8114423c:	2085883a 	add	r2,r4,r2
81144240:	10800204 	addi	r2,r2,8
81144244:	1080002b 	ldhuio	r2,0(r2)
81144248:	10bfffcc 	andi	r2,r2,65535
8114424c:	10bfffcc 	andi	r2,r2,65535
81144250:	1884b03a 	or	r2,r3,r2
81144254:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
81144258:	d0a0b317 	ldw	r2,-32052(gp)
8114425c:	10c00a17 	ldw	r3,40(r2)
81144260:	e0bffc17 	ldw	r2,-16(fp)
81144264:	1885883a 	add	r2,r3,r2
81144268:	10800384 	addi	r2,r2,14
8114426c:	1080002b 	ldhuio	r2,0(r2)
81144270:	10bfffcc 	andi	r2,r2,65535
81144274:	1006943a 	slli	r3,r2,16
81144278:	d0a0b317 	ldw	r2,-32052(gp)
8114427c:	11000a17 	ldw	r4,40(r2)
81144280:	e0bffc17 	ldw	r2,-16(fp)
81144284:	2085883a 	add	r2,r4,r2
81144288:	10800304 	addi	r2,r2,12
8114428c:	1080002b 	ldhuio	r2,0(r2)
81144290:	10bfffcc 	andi	r2,r2,65535
81144294:	10bfffcc 	andi	r2,r2,65535
81144298:	1884b03a 	or	r2,r3,r2
8114429c:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
811442a0:	e0bfff17 	ldw	r2,-4(fp)
811442a4:	0080070e 	bge	zero,r2,811442c4 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
811442a8:	00800044 	movi	r2,1
811442ac:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
811442b0:	e0bfff17 	ldw	r2,-4(fp)
811442b4:	d0a0b215 	stw	r2,-32056(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
811442b8:	e0bffe17 	ldw	r2,-8(fp)
811442bc:	d0a0b115 	stw	r2,-32060(gp)
						break;
811442c0:	00000606 	br	811442dc <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
811442c4:	e0bffa17 	ldw	r2,-24(fp)
811442c8:	10800044 	addi	r2,r2,1
811442cc:	e0bffa15 	stw	r2,-24(fp)
811442d0:	e0bffa17 	ldw	r2,-24(fp)
811442d4:	10800110 	cmplti	r2,r2,4
811442d8:	103fb51e 	bne	r2,zero,811441b0 <__reset+0xfb1241b0>
				}
			}
		}
	}

	return result;
811442dc:	e0bff917 	ldw	r2,-28(fp)
}
811442e0:	e037883a 	mov	sp,fp
811442e4:	dfc00117 	ldw	ra,4(sp)
811442e8:	df000017 	ldw	fp,0(sp)
811442ec:	dec00204 	addi	sp,sp,8
811442f0:	f800283a 	ret

811442f4 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
811442f4:	defff804 	addi	sp,sp,-32
811442f8:	de00012e 	bgeu	sp,et,81144300 <Read_File_Record_At_Offset+0xc>
811442fc:	003b68fa 	trap	3
81144300:	dfc00715 	stw	ra,28(sp)
81144304:	df000615 	stw	fp,24(sp)
81144308:	df000604 	addi	fp,sp,24
8114430c:	e13ffc15 	stw	r4,-16(fp)
81144310:	e17ffd15 	stw	r5,-12(fp)
81144314:	e1bffe15 	stw	r6,-8(fp)
81144318:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
8114431c:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81144320:	e0bffc17 	ldw	r2,-16(fp)
81144324:	108007cc 	andi	r2,r2,31
81144328:	10008d1e 	bne	r2,zero,81144560 <Read_File_Record_At_Offset+0x26c>
8114432c:	1146b9c0 	call	81146b9c <alt_up_sd_card_is_Present>
81144330:	10008b26 	beq	r2,zero,81144560 <Read_File_Record_At_Offset+0x26c>
81144334:	d0a0aa17 	ldw	r2,-32088(gp)
81144338:	10008926 	beq	r2,zero,81144560 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8114433c:	e03ffb15 	stw	zero,-20(fp)
81144340:	00001106 	br	81144388 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
81144344:	e0fffc17 	ldw	r3,-16(fp)
81144348:	e0bffb17 	ldw	r2,-20(fp)
8114434c:	1885883a 	add	r2,r3,r2
81144350:	1007883a 	mov	r3,r2
81144354:	d0a0b317 	ldw	r2,-32052(gp)
81144358:	10800a17 	ldw	r2,40(r2)
8114435c:	1885883a 	add	r2,r3,r2
81144360:	10800023 	ldbuio	r2,0(r2)
81144364:	10803fcc 	andi	r2,r2,255
81144368:	1009883a 	mov	r4,r2
8114436c:	e0fffd17 	ldw	r3,-12(fp)
81144370:	e0bffb17 	ldw	r2,-20(fp)
81144374:	1885883a 	add	r2,r3,r2
81144378:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8114437c:	e0bffb17 	ldw	r2,-20(fp)
81144380:	10800044 	addi	r2,r2,1
81144384:	e0bffb15 	stw	r2,-20(fp)
81144388:	e0bffb17 	ldw	r2,-20(fp)
8114438c:	10800210 	cmplti	r2,r2,8
81144390:	103fec1e 	bne	r2,zero,81144344 <__reset+0xfb124344>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
81144394:	e03ffb15 	stw	zero,-20(fp)
81144398:	00001306 	br	811443e8 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
8114439c:	e0fffc17 	ldw	r3,-16(fp)
811443a0:	e0bffb17 	ldw	r2,-20(fp)
811443a4:	1885883a 	add	r2,r3,r2
811443a8:	1007883a 	mov	r3,r2
811443ac:	d0a0b317 	ldw	r2,-32052(gp)
811443b0:	10800a17 	ldw	r2,40(r2)
811443b4:	1885883a 	add	r2,r3,r2
811443b8:	10800204 	addi	r2,r2,8
811443bc:	10800023 	ldbuio	r2,0(r2)
811443c0:	10803fcc 	andi	r2,r2,255
811443c4:	1009883a 	mov	r4,r2
811443c8:	e0fffd17 	ldw	r3,-12(fp)
811443cc:	e0bffb17 	ldw	r2,-20(fp)
811443d0:	1885883a 	add	r2,r3,r2
811443d4:	10800204 	addi	r2,r2,8
811443d8:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
811443dc:	e0bffb17 	ldw	r2,-20(fp)
811443e0:	10800044 	addi	r2,r2,1
811443e4:	e0bffb15 	stw	r2,-20(fp)
811443e8:	e0bffb17 	ldw	r2,-20(fp)
811443ec:	108000d0 	cmplti	r2,r2,3
811443f0:	103fea1e 	bne	r2,zero,8114439c <__reset+0xfb12439c>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
811443f4:	d0a0b317 	ldw	r2,-32052(gp)
811443f8:	10c00a17 	ldw	r3,40(r2)
811443fc:	e0bffc17 	ldw	r2,-16(fp)
81144400:	1885883a 	add	r2,r3,r2
81144404:	108002c4 	addi	r2,r2,11
81144408:	10800023 	ldbuio	r2,0(r2)
8114440c:	10803fcc 	andi	r2,r2,255
81144410:	1007883a 	mov	r3,r2
81144414:	e0bffd17 	ldw	r2,-12(fp)
81144418:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
8114441c:	d0a0b317 	ldw	r2,-32052(gp)
81144420:	10c00a17 	ldw	r3,40(r2)
81144424:	e0bffc17 	ldw	r2,-16(fp)
81144428:	1885883a 	add	r2,r3,r2
8114442c:	10800384 	addi	r2,r2,14
81144430:	1080002b 	ldhuio	r2,0(r2)
81144434:	10bfffcc 	andi	r2,r2,65535
81144438:	1007883a 	mov	r3,r2
8114443c:	e0bffd17 	ldw	r2,-12(fp)
81144440:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
81144444:	d0a0b317 	ldw	r2,-32052(gp)
81144448:	10c00a17 	ldw	r3,40(r2)
8114444c:	e0bffc17 	ldw	r2,-16(fp)
81144450:	1885883a 	add	r2,r3,r2
81144454:	10800404 	addi	r2,r2,16
81144458:	1080002b 	ldhuio	r2,0(r2)
8114445c:	10bfffcc 	andi	r2,r2,65535
81144460:	1007883a 	mov	r3,r2
81144464:	e0bffd17 	ldw	r2,-12(fp)
81144468:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
8114446c:	d0a0b317 	ldw	r2,-32052(gp)
81144470:	10c00a17 	ldw	r3,40(r2)
81144474:	e0bffc17 	ldw	r2,-16(fp)
81144478:	1885883a 	add	r2,r3,r2
8114447c:	10800484 	addi	r2,r2,18
81144480:	1080002b 	ldhuio	r2,0(r2)
81144484:	10bfffcc 	andi	r2,r2,65535
81144488:	1007883a 	mov	r3,r2
8114448c:	e0bffd17 	ldw	r2,-12(fp)
81144490:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
81144494:	d0a0b317 	ldw	r2,-32052(gp)
81144498:	10c00a17 	ldw	r3,40(r2)
8114449c:	e0bffc17 	ldw	r2,-16(fp)
811444a0:	1885883a 	add	r2,r3,r2
811444a4:	10800584 	addi	r2,r2,22
811444a8:	1080002b 	ldhuio	r2,0(r2)
811444ac:	10bfffcc 	andi	r2,r2,65535
811444b0:	1007883a 	mov	r3,r2
811444b4:	e0bffd17 	ldw	r2,-12(fp)
811444b8:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
811444bc:	d0a0b317 	ldw	r2,-32052(gp)
811444c0:	10c00a17 	ldw	r3,40(r2)
811444c4:	e0bffc17 	ldw	r2,-16(fp)
811444c8:	1885883a 	add	r2,r3,r2
811444cc:	10800604 	addi	r2,r2,24
811444d0:	1080002b 	ldhuio	r2,0(r2)
811444d4:	10bfffcc 	andi	r2,r2,65535
811444d8:	1007883a 	mov	r3,r2
811444dc:	e0bffd17 	ldw	r2,-12(fp)
811444e0:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
811444e4:	d0a0b317 	ldw	r2,-32052(gp)
811444e8:	10c00a17 	ldw	r3,40(r2)
811444ec:	e0bffc17 	ldw	r2,-16(fp)
811444f0:	1885883a 	add	r2,r3,r2
811444f4:	10800684 	addi	r2,r2,26
811444f8:	1080002b 	ldhuio	r2,0(r2)
811444fc:	10bfffcc 	andi	r2,r2,65535
81144500:	1007883a 	mov	r3,r2
81144504:	e0bffd17 	ldw	r2,-12(fp)
81144508:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
8114450c:	d0a0b317 	ldw	r2,-32052(gp)
81144510:	10c00a17 	ldw	r3,40(r2)
81144514:	e0bffc17 	ldw	r2,-16(fp)
81144518:	1885883a 	add	r2,r3,r2
8114451c:	10800704 	addi	r2,r2,28
81144520:	10800037 	ldwio	r2,0(r2)
81144524:	1007883a 	mov	r3,r2
81144528:	e0bffd17 	ldw	r2,-12(fp)
8114452c:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
81144530:	e0bffd17 	ldw	r2,-12(fp)
81144534:	e0fffe17 	ldw	r3,-8(fp)
81144538:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
8114453c:	e0bffd17 	ldw	r2,-12(fp)
81144540:	e0ffff17 	ldw	r3,-4(fp)
81144544:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
81144548:	e0bffc17 	ldw	r2,-16(fp)
8114454c:	1007883a 	mov	r3,r2
81144550:	e0bffd17 	ldw	r2,-12(fp)
81144554:	10c00c0d 	sth	r3,48(r2)
		result = true;
81144558:	00800044 	movi	r2,1
8114455c:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
81144560:	e0bffa17 	ldw	r2,-24(fp)
}
81144564:	e037883a 	mov	sp,fp
81144568:	dfc00117 	ldw	ra,4(sp)
8114456c:	df000017 	ldw	fp,0(sp)
81144570:	dec00204 	addi	sp,sp,8
81144574:	f800283a 	ret

81144578 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
81144578:	defff904 	addi	sp,sp,-28
8114457c:	de00012e 	bgeu	sp,et,81144584 <Write_File_Record_At_Offset+0xc>
81144580:	003b68fa 	trap	3
81144584:	dfc00615 	stw	ra,24(sp)
81144588:	df000515 	stw	fp,20(sp)
8114458c:	df000504 	addi	fp,sp,20
81144590:	e13ffe15 	stw	r4,-8(fp)
81144594:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81144598:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8114459c:	e0bffe17 	ldw	r2,-8(fp)
811445a0:	108007cc 	andi	r2,r2,31
811445a4:	1000931e 	bne	r2,zero,811447f4 <Write_File_Record_At_Offset+0x27c>
811445a8:	1146b9c0 	call	81146b9c <alt_up_sd_card_is_Present>
811445ac:	10009126 	beq	r2,zero,811447f4 <Write_File_Record_At_Offset+0x27c>
811445b0:	d0a0aa17 	ldw	r2,-32088(gp)
811445b4:	10008f26 	beq	r2,zero,811447f4 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
811445b8:	e03ffc15 	stw	zero,-16(fp)
811445bc:	00001f06 	br	8114463c <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
811445c0:	e0bffc17 	ldw	r2,-16(fp)
811445c4:	10800044 	addi	r2,r2,1
811445c8:	e0ffff17 	ldw	r3,-4(fp)
811445cc:	1885883a 	add	r2,r3,r2
811445d0:	10800003 	ldbu	r2,0(r2)
811445d4:	10803fcc 	andi	r2,r2,255
811445d8:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
811445dc:	e0bffd0f 	ldh	r2,-12(fp)
811445e0:	1004923a 	slli	r2,r2,8
811445e4:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
811445e8:	e0ffff17 	ldw	r3,-4(fp)
811445ec:	e0bffc17 	ldw	r2,-16(fp)
811445f0:	1885883a 	add	r2,r3,r2
811445f4:	10800003 	ldbu	r2,0(r2)
811445f8:	10c03fcc 	andi	r3,r2,255
811445fc:	e0bffd0b 	ldhu	r2,-12(fp)
81144600:	1884b03a 	or	r2,r3,r2
81144604:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
81144608:	e0fffe17 	ldw	r3,-8(fp)
8114460c:	e0bffc17 	ldw	r2,-16(fp)
81144610:	1885883a 	add	r2,r3,r2
81144614:	1007883a 	mov	r3,r2
81144618:	d0a0b317 	ldw	r2,-32052(gp)
8114461c:	10800a17 	ldw	r2,40(r2)
81144620:	1885883a 	add	r2,r3,r2
81144624:	1007883a 	mov	r3,r2
81144628:	e0bffd0f 	ldh	r2,-12(fp)
8114462c:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81144630:	e0bffc17 	ldw	r2,-16(fp)
81144634:	10800084 	addi	r2,r2,2
81144638:	e0bffc15 	stw	r2,-16(fp)
8114463c:	e0bffc17 	ldw	r2,-16(fp)
81144640:	10800210 	cmplti	r2,r2,8
81144644:	103fde1e 	bne	r2,zero,811445c0 <__reset+0xfb1245c0>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81144648:	e03ffc15 	stw	zero,-16(fp)
8114464c:	00001306 	br	8114469c <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
81144650:	e0fffe17 	ldw	r3,-8(fp)
81144654:	e0bffc17 	ldw	r2,-16(fp)
81144658:	1885883a 	add	r2,r3,r2
8114465c:	1007883a 	mov	r3,r2
81144660:	d0a0b317 	ldw	r2,-32052(gp)
81144664:	10800a17 	ldw	r2,40(r2)
81144668:	1885883a 	add	r2,r3,r2
8114466c:	10800204 	addi	r2,r2,8
81144670:	1009883a 	mov	r4,r2
81144674:	e0ffff17 	ldw	r3,-4(fp)
81144678:	e0bffc17 	ldw	r2,-16(fp)
8114467c:	1885883a 	add	r2,r3,r2
81144680:	10800204 	addi	r2,r2,8
81144684:	10800003 	ldbu	r2,0(r2)
81144688:	10803fcc 	andi	r2,r2,255
8114468c:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81144690:	e0bffc17 	ldw	r2,-16(fp)
81144694:	10800044 	addi	r2,r2,1
81144698:	e0bffc15 	stw	r2,-16(fp)
8114469c:	e0bffc17 	ldw	r2,-16(fp)
811446a0:	108000d0 	cmplti	r2,r2,3
811446a4:	103fea1e 	bne	r2,zero,81144650 <__reset+0xfb124650>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
811446a8:	d0a0b317 	ldw	r2,-32052(gp)
811446ac:	10c00a17 	ldw	r3,40(r2)
811446b0:	e0bffe17 	ldw	r2,-8(fp)
811446b4:	1885883a 	add	r2,r3,r2
811446b8:	108002c4 	addi	r2,r2,11
811446bc:	1007883a 	mov	r3,r2
811446c0:	e0bfff17 	ldw	r2,-4(fp)
811446c4:	108002c3 	ldbu	r2,11(r2)
811446c8:	10803fcc 	andi	r2,r2,255
811446cc:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
811446d0:	d0a0b317 	ldw	r2,-32052(gp)
811446d4:	10c00a17 	ldw	r3,40(r2)
811446d8:	e0bffe17 	ldw	r2,-8(fp)
811446dc:	1885883a 	add	r2,r3,r2
811446e0:	10800384 	addi	r2,r2,14
811446e4:	1007883a 	mov	r3,r2
811446e8:	e0bfff17 	ldw	r2,-4(fp)
811446ec:	1080030b 	ldhu	r2,12(r2)
811446f0:	10bfffcc 	andi	r2,r2,65535
811446f4:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
811446f8:	d0a0b317 	ldw	r2,-32052(gp)
811446fc:	10c00a17 	ldw	r3,40(r2)
81144700:	e0bffe17 	ldw	r2,-8(fp)
81144704:	1885883a 	add	r2,r3,r2
81144708:	10800404 	addi	r2,r2,16
8114470c:	1007883a 	mov	r3,r2
81144710:	e0bfff17 	ldw	r2,-4(fp)
81144714:	1080038b 	ldhu	r2,14(r2)
81144718:	10bfffcc 	andi	r2,r2,65535
8114471c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
81144720:	d0a0b317 	ldw	r2,-32052(gp)
81144724:	10c00a17 	ldw	r3,40(r2)
81144728:	e0bffe17 	ldw	r2,-8(fp)
8114472c:	1885883a 	add	r2,r3,r2
81144730:	10800484 	addi	r2,r2,18
81144734:	1007883a 	mov	r3,r2
81144738:	e0bfff17 	ldw	r2,-4(fp)
8114473c:	1080040b 	ldhu	r2,16(r2)
81144740:	10bfffcc 	andi	r2,r2,65535
81144744:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
81144748:	d0a0b317 	ldw	r2,-32052(gp)
8114474c:	10c00a17 	ldw	r3,40(r2)
81144750:	e0bffe17 	ldw	r2,-8(fp)
81144754:	1885883a 	add	r2,r3,r2
81144758:	10800584 	addi	r2,r2,22
8114475c:	1007883a 	mov	r3,r2
81144760:	e0bfff17 	ldw	r2,-4(fp)
81144764:	1080048b 	ldhu	r2,18(r2)
81144768:	10bfffcc 	andi	r2,r2,65535
8114476c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
81144770:	d0a0b317 	ldw	r2,-32052(gp)
81144774:	10c00a17 	ldw	r3,40(r2)
81144778:	e0bffe17 	ldw	r2,-8(fp)
8114477c:	1885883a 	add	r2,r3,r2
81144780:	10800604 	addi	r2,r2,24
81144784:	1007883a 	mov	r3,r2
81144788:	e0bfff17 	ldw	r2,-4(fp)
8114478c:	1080050b 	ldhu	r2,20(r2)
81144790:	10bfffcc 	andi	r2,r2,65535
81144794:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
81144798:	d0a0b317 	ldw	r2,-32052(gp)
8114479c:	10c00a17 	ldw	r3,40(r2)
811447a0:	e0bffe17 	ldw	r2,-8(fp)
811447a4:	1885883a 	add	r2,r3,r2
811447a8:	10800684 	addi	r2,r2,26
811447ac:	1007883a 	mov	r3,r2
811447b0:	e0bfff17 	ldw	r2,-4(fp)
811447b4:	1080058b 	ldhu	r2,22(r2)
811447b8:	10bfffcc 	andi	r2,r2,65535
811447bc:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
811447c0:	d0a0b317 	ldw	r2,-32052(gp)
811447c4:	10c00a17 	ldw	r3,40(r2)
811447c8:	e0bffe17 	ldw	r2,-8(fp)
811447cc:	1885883a 	add	r2,r3,r2
811447d0:	10800704 	addi	r2,r2,28
811447d4:	1007883a 	mov	r3,r2
811447d8:	e0bfff17 	ldw	r2,-4(fp)
811447dc:	10800617 	ldw	r2,24(r2)
811447e0:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
811447e4:	00800044 	movi	r2,1
811447e8:	d0a0b415 	stw	r2,-32048(gp)
        result = true;
811447ec:	00800044 	movi	r2,1
811447f0:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
811447f4:	e0bffb17 	ldw	r2,-20(fp)
}
811447f8:	e037883a 	mov	sp,fp
811447fc:	dfc00117 	ldw	ra,4(sp)
81144800:	df000017 	ldw	fp,0(sp)
81144804:	dec00204 	addi	sp,sp,8
81144808:	f800283a 	ret

8114480c <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
8114480c:	defff904 	addi	sp,sp,-28
81144810:	de00012e 	bgeu	sp,et,81144818 <Check_for_DOS_FAT+0xc>
81144814:	003b68fa 	trap	3
81144818:	dfc00615 	stw	ra,24(sp)
8114481c:	df000515 	stw	fp,20(sp)
81144820:	df000504 	addi	fp,sp,20
81144824:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
81144828:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
8114482c:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
81144830:	e17fff17 	ldw	r5,-4(fp)
81144834:	0009883a 	mov	r4,zero
81144838:	1143ec40 	call	81143ec4 <Read_Sector_Data>
8114483c:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
81144840:	d0a0b317 	ldw	r2,-32052(gp)
81144844:	10800a17 	ldw	r2,40(r2)
81144848:	10807f84 	addi	r2,r2,510
8114484c:	1080002b 	ldhuio	r2,0(r2)
81144850:	10bfffcc 	andi	r2,r2,65535
81144854:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
81144858:	e0bffe0f 	ldh	r2,-8(fp)
8114485c:	10ffffcc 	andi	r3,r2,65535
81144860:	00aa9554 	movui	r2,43605
81144864:	1881841e 	bne	r3,r2,81144e78 <Check_for_DOS_FAT+0x66c>
81144868:	e0bffb17 	ldw	r2,-20(fp)
8114486c:	10018226 	beq	r2,zero,81144e78 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
81144870:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
81144874:	d0a0b317 	ldw	r2,-32052(gp)
81144878:	10800a17 	ldw	r2,40(r2)
8114487c:	10800023 	ldbuio	r2,0(r2)
81144880:	10803fcc 	andi	r2,r2,255
81144884:	1007883a 	mov	r3,r2
81144888:	00a045f4 	movhi	r2,33047
8114488c:	10ba9804 	addi	r2,r2,-5536
81144890:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
81144894:	d0a0b317 	ldw	r2,-32052(gp)
81144898:	10800a17 	ldw	r2,40(r2)
8114489c:	10800044 	addi	r2,r2,1
811448a0:	10800023 	ldbuio	r2,0(r2)
811448a4:	10803fcc 	andi	r2,r2,255
811448a8:	1007883a 	mov	r3,r2
811448ac:	00a045f4 	movhi	r2,33047
811448b0:	10ba9804 	addi	r2,r2,-5536
811448b4:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
811448b8:	d0a0b317 	ldw	r2,-32052(gp)
811448bc:	10800a17 	ldw	r2,40(r2)
811448c0:	10800084 	addi	r2,r2,2
811448c4:	10800023 	ldbuio	r2,0(r2)
811448c8:	10803fcc 	andi	r2,r2,255
811448cc:	1007883a 	mov	r3,r2
811448d0:	00a045f4 	movhi	r2,33047
811448d4:	10ba9804 	addi	r2,r2,-5536
811448d8:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
811448dc:	e03ffc15 	stw	zero,-16(fp)
811448e0:	00001106 	br	81144928 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
811448e4:	d0a0b317 	ldw	r2,-32052(gp)
811448e8:	10c00a17 	ldw	r3,40(r2)
811448ec:	e0bffc17 	ldw	r2,-16(fp)
811448f0:	1885883a 	add	r2,r3,r2
811448f4:	108000c4 	addi	r2,r2,3
811448f8:	10800023 	ldbuio	r2,0(r2)
811448fc:	10803fcc 	andi	r2,r2,255
81144900:	1009883a 	mov	r4,r2
81144904:	00a045f4 	movhi	r2,33047
81144908:	10ba9804 	addi	r2,r2,-5536
8114490c:	e0fffc17 	ldw	r3,-16(fp)
81144910:	10c5883a 	add	r2,r2,r3
81144914:	108000c4 	addi	r2,r2,3
81144918:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
8114491c:	e0bffc17 	ldw	r2,-16(fp)
81144920:	10800044 	addi	r2,r2,1
81144924:	e0bffc15 	stw	r2,-16(fp)
81144928:	e0bffc17 	ldw	r2,-16(fp)
8114492c:	10800210 	cmplti	r2,r2,8
81144930:	103fec1e 	bne	r2,zero,811448e4 <__reset+0xfb1248e4>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
81144934:	d0a0b317 	ldw	r2,-32052(gp)
81144938:	10800a17 	ldw	r2,40(r2)
8114493c:	10800304 	addi	r2,r2,12
81144940:	10800023 	ldbuio	r2,0(r2)
81144944:	10803fcc 	andi	r2,r2,255
81144948:	1004923a 	slli	r2,r2,8
8114494c:	1007883a 	mov	r3,r2
81144950:	d0a0b317 	ldw	r2,-32052(gp)
81144954:	10800a17 	ldw	r2,40(r2)
81144958:	108002c4 	addi	r2,r2,11
8114495c:	10800023 	ldbuio	r2,0(r2)
81144960:	10803fcc 	andi	r2,r2,255
81144964:	10803fcc 	andi	r2,r2,255
81144968:	1080201c 	xori	r2,r2,128
8114496c:	10bfe004 	addi	r2,r2,-128
81144970:	1884b03a 	or	r2,r3,r2
81144974:	1007883a 	mov	r3,r2
81144978:	00a045f4 	movhi	r2,33047
8114497c:	10ba9804 	addi	r2,r2,-5536
81144980:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
81144984:	d0a0b317 	ldw	r2,-32052(gp)
81144988:	10800a17 	ldw	r2,40(r2)
8114498c:	10800344 	addi	r2,r2,13
81144990:	10800023 	ldbuio	r2,0(r2)
81144994:	10803fcc 	andi	r2,r2,255
81144998:	1007883a 	mov	r3,r2
8114499c:	00a045f4 	movhi	r2,33047
811449a0:	10ba9804 	addi	r2,r2,-5536
811449a4:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
811449a8:	d0a0b317 	ldw	r2,-32052(gp)
811449ac:	10800a17 	ldw	r2,40(r2)
811449b0:	10800384 	addi	r2,r2,14
811449b4:	1080002b 	ldhuio	r2,0(r2)
811449b8:	10bfffcc 	andi	r2,r2,65535
811449bc:	1007883a 	mov	r3,r2
811449c0:	00a045f4 	movhi	r2,33047
811449c4:	10ba9804 	addi	r2,r2,-5536
811449c8:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
811449cc:	d0a0b317 	ldw	r2,-32052(gp)
811449d0:	10800a17 	ldw	r2,40(r2)
811449d4:	10800404 	addi	r2,r2,16
811449d8:	10800023 	ldbuio	r2,0(r2)
811449dc:	10803fcc 	andi	r2,r2,255
811449e0:	1007883a 	mov	r3,r2
811449e4:	00a045f4 	movhi	r2,33047
811449e8:	10ba9804 	addi	r2,r2,-5536
811449ec:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
811449f0:	d0a0b317 	ldw	r2,-32052(gp)
811449f4:	10800a17 	ldw	r2,40(r2)
811449f8:	10800484 	addi	r2,r2,18
811449fc:	10800023 	ldbuio	r2,0(r2)
81144a00:	10803fcc 	andi	r2,r2,255
81144a04:	1004923a 	slli	r2,r2,8
81144a08:	1007883a 	mov	r3,r2
81144a0c:	d0a0b317 	ldw	r2,-32052(gp)
81144a10:	10800a17 	ldw	r2,40(r2)
81144a14:	10800444 	addi	r2,r2,17
81144a18:	10800023 	ldbuio	r2,0(r2)
81144a1c:	10803fcc 	andi	r2,r2,255
81144a20:	10803fcc 	andi	r2,r2,255
81144a24:	1884b03a 	or	r2,r3,r2
81144a28:	1007883a 	mov	r3,r2
81144a2c:	00a045f4 	movhi	r2,33047
81144a30:	10ba9804 	addi	r2,r2,-5536
81144a34:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
81144a38:	d0a0b317 	ldw	r2,-32052(gp)
81144a3c:	10800a17 	ldw	r2,40(r2)
81144a40:	10800504 	addi	r2,r2,20
81144a44:	10800023 	ldbuio	r2,0(r2)
81144a48:	10803fcc 	andi	r2,r2,255
81144a4c:	1004923a 	slli	r2,r2,8
81144a50:	1007883a 	mov	r3,r2
81144a54:	d0a0b317 	ldw	r2,-32052(gp)
81144a58:	10800a17 	ldw	r2,40(r2)
81144a5c:	108004c4 	addi	r2,r2,19
81144a60:	10800023 	ldbuio	r2,0(r2)
81144a64:	10803fcc 	andi	r2,r2,255
81144a68:	10803fcc 	andi	r2,r2,255
81144a6c:	1884b03a 	or	r2,r3,r2
81144a70:	1007883a 	mov	r3,r2
81144a74:	00a045f4 	movhi	r2,33047
81144a78:	10ba9804 	addi	r2,r2,-5536
81144a7c:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
81144a80:	d0a0b317 	ldw	r2,-32052(gp)
81144a84:	10800a17 	ldw	r2,40(r2)
81144a88:	10800544 	addi	r2,r2,21
81144a8c:	10800023 	ldbuio	r2,0(r2)
81144a90:	10803fcc 	andi	r2,r2,255
81144a94:	1007883a 	mov	r3,r2
81144a98:	00a045f4 	movhi	r2,33047
81144a9c:	10ba9804 	addi	r2,r2,-5536
81144aa0:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
81144aa4:	d0a0b317 	ldw	r2,-32052(gp)
81144aa8:	10800a17 	ldw	r2,40(r2)
81144aac:	10800584 	addi	r2,r2,22
81144ab0:	1080002b 	ldhuio	r2,0(r2)
81144ab4:	10bfffcc 	andi	r2,r2,65535
81144ab8:	1007883a 	mov	r3,r2
81144abc:	00a045f4 	movhi	r2,33047
81144ac0:	10ba9804 	addi	r2,r2,-5536
81144ac4:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
81144ac8:	d0a0b317 	ldw	r2,-32052(gp)
81144acc:	10800a17 	ldw	r2,40(r2)
81144ad0:	10800604 	addi	r2,r2,24
81144ad4:	1080002b 	ldhuio	r2,0(r2)
81144ad8:	10bfffcc 	andi	r2,r2,65535
81144adc:	1007883a 	mov	r3,r2
81144ae0:	00a045f4 	movhi	r2,33047
81144ae4:	10ba9804 	addi	r2,r2,-5536
81144ae8:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
81144aec:	d0a0b317 	ldw	r2,-32052(gp)
81144af0:	10800a17 	ldw	r2,40(r2)
81144af4:	10800684 	addi	r2,r2,26
81144af8:	1080002b 	ldhuio	r2,0(r2)
81144afc:	10bfffcc 	andi	r2,r2,65535
81144b00:	1007883a 	mov	r3,r2
81144b04:	00a045f4 	movhi	r2,33047
81144b08:	10ba9804 	addi	r2,r2,-5536
81144b0c:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
81144b10:	d0a0b317 	ldw	r2,-32052(gp)
81144b14:	10800a17 	ldw	r2,40(r2)
81144b18:	10800704 	addi	r2,r2,28
81144b1c:	10800037 	ldwio	r2,0(r2)
81144b20:	1007883a 	mov	r3,r2
81144b24:	00a045f4 	movhi	r2,33047
81144b28:	10ba9804 	addi	r2,r2,-5536
81144b2c:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
81144b30:	d0a0b317 	ldw	r2,-32052(gp)
81144b34:	10800a17 	ldw	r2,40(r2)
81144b38:	10800804 	addi	r2,r2,32
81144b3c:	10800037 	ldwio	r2,0(r2)
81144b40:	1007883a 	mov	r3,r2
81144b44:	00a045f4 	movhi	r2,33047
81144b48:	10ba9804 	addi	r2,r2,-5536
81144b4c:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
81144b50:	d0a0b317 	ldw	r2,-32052(gp)
81144b54:	10800a17 	ldw	r2,40(r2)
81144b58:	10800904 	addi	r2,r2,36
81144b5c:	10800023 	ldbuio	r2,0(r2)
81144b60:	10803fcc 	andi	r2,r2,255
81144b64:	1007883a 	mov	r3,r2
81144b68:	00a045f4 	movhi	r2,33047
81144b6c:	10ba9804 	addi	r2,r2,-5536
81144b70:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
81144b74:	d0a0b317 	ldw	r2,-32052(gp)
81144b78:	10800a17 	ldw	r2,40(r2)
81144b7c:	10800944 	addi	r2,r2,37
81144b80:	10800023 	ldbuio	r2,0(r2)
81144b84:	10803fcc 	andi	r2,r2,255
81144b88:	1007883a 	mov	r3,r2
81144b8c:	00a045f4 	movhi	r2,33047
81144b90:	10ba9804 	addi	r2,r2,-5536
81144b94:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
81144b98:	d0a0b317 	ldw	r2,-32052(gp)
81144b9c:	10800a17 	ldw	r2,40(r2)
81144ba0:	10800984 	addi	r2,r2,38
81144ba4:	10800023 	ldbuio	r2,0(r2)
81144ba8:	10803fcc 	andi	r2,r2,255
81144bac:	1007883a 	mov	r3,r2
81144bb0:	00a045f4 	movhi	r2,33047
81144bb4:	10ba9804 	addi	r2,r2,-5536
81144bb8:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
81144bbc:	00a045f4 	movhi	r2,33047
81144bc0:	10ba9804 	addi	r2,r2,-5536
81144bc4:	1080040b 	ldhu	r2,16(r2)
81144bc8:	10ffffcc 	andi	r3,r2,65535
81144bcc:	00a045f4 	movhi	r2,33047
81144bd0:	10ba9804 	addi	r2,r2,-5536
81144bd4:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
81144bd8:	00a045f4 	movhi	r2,33047
81144bdc:	10ba9804 	addi	r2,r2,-5536
81144be0:	10c01117 	ldw	r3,68(r2)
81144be4:	00a045f4 	movhi	r2,33047
81144be8:	10ba9804 	addi	r2,r2,-5536
81144bec:	1080068b 	ldhu	r2,26(r2)
81144bf0:	10bfffcc 	andi	r2,r2,65535
81144bf4:	1887883a 	add	r3,r3,r2
81144bf8:	00a045f4 	movhi	r2,33047
81144bfc:	10ba9804 	addi	r2,r2,-5536
81144c00:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
81144c04:	00a045f4 	movhi	r2,33047
81144c08:	10ba9804 	addi	r2,r2,-5536
81144c0c:	10c01217 	ldw	r3,72(r2)
81144c10:	00a045f4 	movhi	r2,33047
81144c14:	10ba9804 	addi	r2,r2,-5536
81144c18:	1080068b 	ldhu	r2,26(r2)
81144c1c:	10bfffcc 	andi	r2,r2,65535
81144c20:	1887883a 	add	r3,r3,r2
81144c24:	00a045f4 	movhi	r2,33047
81144c28:	10ba9804 	addi	r2,r2,-5536
81144c2c:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
81144c30:	00a045f4 	movhi	r2,33047
81144c34:	10ba9804 	addi	r2,r2,-5536
81144c38:	10c01317 	ldw	r3,76(r2)
81144c3c:	00a045f4 	movhi	r2,33047
81144c40:	10ba9804 	addi	r2,r2,-5536
81144c44:	1080050b 	ldhu	r2,20(r2)
81144c48:	10bfffcc 	andi	r2,r2,65535
81144c4c:	1008917a 	slli	r4,r2,5
81144c50:	00a045f4 	movhi	r2,33047
81144c54:	10ba9804 	addi	r2,r2,-5536
81144c58:	1080030b 	ldhu	r2,12(r2)
81144c5c:	10bfffcc 	andi	r2,r2,65535
81144c60:	2085283a 	div	r2,r4,r2
81144c64:	1887883a 	add	r3,r3,r2
81144c68:	00a045f4 	movhi	r2,33047
81144c6c:	10ba9804 	addi	r2,r2,-5536
81144c70:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
81144c74:	00a045f4 	movhi	r2,33047
81144c78:	10ba9804 	addi	r2,r2,-5536
81144c7c:	1080058b 	ldhu	r2,22(r2)
81144c80:	10bfffcc 	andi	r2,r2,65535
81144c84:	10000b26 	beq	r2,zero,81144cb4 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
81144c88:	00a045f4 	movhi	r2,33047
81144c8c:	10ba9804 	addi	r2,r2,-5536
81144c90:	1080058b 	ldhu	r2,22(r2)
81144c94:	10ffffcc 	andi	r3,r2,65535
81144c98:	00a045f4 	movhi	r2,33047
81144c9c:	10ba9804 	addi	r2,r2,-5536
81144ca0:	10800383 	ldbu	r2,14(r2)
81144ca4:	10803fcc 	andi	r2,r2,255
81144ca8:	1885283a 	div	r2,r3,r2
81144cac:	e0bffd15 	stw	r2,-12(fp)
81144cb0:	00000906 	br	81144cd8 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
81144cb4:	00a045f4 	movhi	r2,33047
81144cb8:	10ba9804 	addi	r2,r2,-5536
81144cbc:	10c00917 	ldw	r3,36(r2)
81144cc0:	00a045f4 	movhi	r2,33047
81144cc4:	10ba9804 	addi	r2,r2,-5536
81144cc8:	10800383 	ldbu	r2,14(r2)
81144ccc:	10803fcc 	andi	r2,r2,255
81144cd0:	1885203a 	divu	r2,r3,r2
81144cd4:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
81144cd8:	e0bffd17 	ldw	r2,-12(fp)
81144cdc:	1083fdc8 	cmpgei	r2,r2,4087
81144ce0:	1000051e 	bne	r2,zero,81144cf8 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
81144ce4:	00a045f4 	movhi	r2,33047
81144ce8:	10ba9804 	addi	r2,r2,-5536
81144cec:	00c00304 	movi	r3,12
81144cf0:	10c01085 	stb	r3,66(r2)
81144cf4:	00000c06 	br	81144d28 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
81144cf8:	e0bffd17 	ldw	r2,-12(fp)
81144cfc:	00fffb54 	movui	r3,65517
81144d00:	18800516 	blt	r3,r2,81144d18 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
81144d04:	00a045f4 	movhi	r2,33047
81144d08:	10ba9804 	addi	r2,r2,-5536
81144d0c:	00c00404 	movi	r3,16
81144d10:	10c01085 	stb	r3,66(r2)
81144d14:	00000406 	br	81144d28 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
81144d18:	00a045f4 	movhi	r2,33047
81144d1c:	10ba9804 	addi	r2,r2,-5536
81144d20:	00c00804 	movi	r3,32
81144d24:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
81144d28:	e03ffc15 	stw	zero,-16(fp)
81144d2c:	00001106 	br	81144d74 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
81144d30:	d0a0b317 	ldw	r2,-32052(gp)
81144d34:	10c00a17 	ldw	r3,40(r2)
81144d38:	e0bffc17 	ldw	r2,-16(fp)
81144d3c:	1885883a 	add	r2,r3,r2
81144d40:	108009c4 	addi	r2,r2,39
81144d44:	10800023 	ldbuio	r2,0(r2)
81144d48:	10803fcc 	andi	r2,r2,255
81144d4c:	1009883a 	mov	r4,r2
81144d50:	00a045f4 	movhi	r2,33047
81144d54:	10ba9804 	addi	r2,r2,-5536
81144d58:	e0fffc17 	ldw	r3,-16(fp)
81144d5c:	10c5883a 	add	r2,r2,r3
81144d60:	10800ac4 	addi	r2,r2,43
81144d64:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
81144d68:	e0bffc17 	ldw	r2,-16(fp)
81144d6c:	10800044 	addi	r2,r2,1
81144d70:	e0bffc15 	stw	r2,-16(fp)
81144d74:	e0bffc17 	ldw	r2,-16(fp)
81144d78:	10800110 	cmplti	r2,r2,4
81144d7c:	103fec1e 	bne	r2,zero,81144d30 <__reset+0xfb124d30>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81144d80:	e03ffc15 	stw	zero,-16(fp)
81144d84:	00001106 	br	81144dcc <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
81144d88:	d0a0b317 	ldw	r2,-32052(gp)
81144d8c:	10c00a17 	ldw	r3,40(r2)
81144d90:	e0bffc17 	ldw	r2,-16(fp)
81144d94:	1885883a 	add	r2,r3,r2
81144d98:	10800ac4 	addi	r2,r2,43
81144d9c:	10800023 	ldbuio	r2,0(r2)
81144da0:	10803fcc 	andi	r2,r2,255
81144da4:	1009883a 	mov	r4,r2
81144da8:	00a045f4 	movhi	r2,33047
81144dac:	10ba9804 	addi	r2,r2,-5536
81144db0:	e0fffc17 	ldw	r3,-16(fp)
81144db4:	10c5883a 	add	r2,r2,r3
81144db8:	10800bc4 	addi	r2,r2,47
81144dbc:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81144dc0:	e0bffc17 	ldw	r2,-16(fp)
81144dc4:	10800044 	addi	r2,r2,1
81144dc8:	e0bffc15 	stw	r2,-16(fp)
81144dcc:	e0bffc17 	ldw	r2,-16(fp)
81144dd0:	108002d0 	cmplti	r2,r2,11
81144dd4:	103fec1e 	bne	r2,zero,81144d88 <__reset+0xfb124d88>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81144dd8:	e03ffc15 	stw	zero,-16(fp)
81144ddc:	00001106 	br	81144e24 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
81144de0:	d0a0b317 	ldw	r2,-32052(gp)
81144de4:	10c00a17 	ldw	r3,40(r2)
81144de8:	e0bffc17 	ldw	r2,-16(fp)
81144dec:	1885883a 	add	r2,r3,r2
81144df0:	10800d84 	addi	r2,r2,54
81144df4:	10800023 	ldbuio	r2,0(r2)
81144df8:	10803fcc 	andi	r2,r2,255
81144dfc:	1009883a 	mov	r4,r2
81144e00:	00a045f4 	movhi	r2,33047
81144e04:	10ba9804 	addi	r2,r2,-5536
81144e08:	e0fffc17 	ldw	r3,-16(fp)
81144e0c:	10c5883a 	add	r2,r2,r3
81144e10:	10800e84 	addi	r2,r2,58
81144e14:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81144e18:	e0bffc17 	ldw	r2,-16(fp)
81144e1c:	10800044 	addi	r2,r2,1
81144e20:	e0bffc15 	stw	r2,-16(fp)
81144e24:	e0bffc17 	ldw	r2,-16(fp)
81144e28:	10800210 	cmplti	r2,r2,8
81144e2c:	103fec1e 	bne	r2,zero,81144de0 <__reset+0xfb124de0>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81144e30:	e03ffc15 	stw	zero,-16(fp)
81144e34:	00000a06 	br	81144e60 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
81144e38:	00a045f4 	movhi	r2,33047
81144e3c:	10baad04 	addi	r2,r2,-5452
81144e40:	e0fffc17 	ldw	r3,-16(fp)
81144e44:	180691ba 	slli	r3,r3,6
81144e48:	10c5883a 	add	r2,r2,r3
81144e4c:	10800f04 	addi	r2,r2,60
81144e50:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81144e54:	e0bffc17 	ldw	r2,-16(fp)
81144e58:	10800044 	addi	r2,r2,1
81144e5c:	e0bffc15 	stw	r2,-16(fp)
81144e60:	e0bffc17 	ldw	r2,-16(fp)
81144e64:	10800510 	cmplti	r2,r2,20
81144e68:	103ff31e 	bne	r2,zero,81144e38 <__reset+0xfb124e38>
		{
			active_files[counter].in_use = false;
		}
		result = true;
81144e6c:	00800044 	movi	r2,1
81144e70:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
81144e74:	00000106 	br	81144e7c <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
81144e78:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
81144e7c:	e0bffb17 	ldw	r2,-20(fp)
}
81144e80:	e037883a 	mov	sp,fp
81144e84:	dfc00117 	ldw	ra,4(sp)
81144e88:	df000017 	ldw	fp,0(sp)
81144e8c:	dec00204 	addi	sp,sp,8
81144e90:	f800283a 	ret

81144e94 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
81144e94:	defffc04 	addi	sp,sp,-16
81144e98:	de00012e 	bgeu	sp,et,81144ea0 <Look_for_FAT16+0xc>
81144e9c:	003b68fa 	trap	3
81144ea0:	dfc00315 	stw	ra,12(sp)
81144ea4:	df000215 	stw	fp,8(sp)
81144ea8:	df000204 	addi	fp,sp,8
	bool result = false;
81144eac:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
81144eb0:	1146b9c0 	call	81146b9c <alt_up_sd_card_is_Present>
81144eb4:	10002e26 	beq	r2,zero,81144f70 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
81144eb8:	d0a0ad17 	ldw	r2,-32076(gp)
81144ebc:	1080000b 	ldhu	r2,0(r2)
81144ec0:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
81144ec4:	d020b115 	stw	zero,-32060(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
81144ec8:	d020b215 	stw	zero,-32056(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
81144ecc:	e0bfff0f 	ldh	r2,-4(fp)
81144ed0:	10002716 	blt	r2,zero,81144f70 <Look_for_FAT16+0xdc>
81144ed4:	e0bfff0b 	ldhu	r2,-4(fp)
81144ed8:	10bfffcc 	andi	r2,r2,65535
81144edc:	1083000c 	andi	r2,r2,3072
81144ee0:	10830020 	cmpeqi	r2,r2,3072
81144ee4:	1000221e 	bne	r2,zero,81144f70 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
81144ee8:	e0bfff0b 	ldhu	r2,-4(fp)
81144eec:	10bfffcc 	andi	r2,r2,65535
81144ef0:	1083000c 	andi	r2,r2,3072
81144ef4:	10810018 	cmpnei	r2,r2,1024
81144ef8:	1000031e 	bne	r2,zero,81144f08 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
81144efc:	0009883a 	mov	r4,zero
81144f00:	114480c0 	call	8114480c <Check_for_DOS_FAT>
81144f04:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
81144f08:	e0bfff0b 	ldhu	r2,-4(fp)
81144f0c:	10bfffcc 	andi	r2,r2,65535
81144f10:	1083000c 	andi	r2,r2,3072
81144f14:	1000061e 	bne	r2,zero,81144f30 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
81144f18:	11441480 	call	81144148 <Check_for_Master_Boot_Record>
81144f1c:	10000426 	beq	r2,zero,81144f30 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
81144f20:	d0a0b117 	ldw	r2,-32060(gp)
81144f24:	1009883a 	mov	r4,r2
81144f28:	114480c0 	call	8114480c <Check_for_DOS_FAT>
81144f2c:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
81144f30:	e0bffe17 	ldw	r2,-8(fp)
81144f34:	10800058 	cmpnei	r2,r2,1
81144f38:	10000d1e 	bne	r2,zero,81144f70 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
81144f3c:	00a045f4 	movhi	r2,33047
81144f40:	10ba9804 	addi	r2,r2,-5536
81144f44:	10801083 	ldbu	r2,66(r2)
81144f48:	10803fcc 	andi	r2,r2,255
81144f4c:	10800420 	cmpeqi	r2,r2,16
81144f50:	1000021e 	bne	r2,zero,81144f5c <Look_for_FAT16+0xc8>
				{
					result = false;
81144f54:	e03ffe15 	stw	zero,-8(fp)
81144f58:	00000506 	br	81144f70 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
81144f5c:	00a045f4 	movhi	r2,33047
81144f60:	10ba9804 	addi	r2,r2,-5536
81144f64:	1080058b 	ldhu	r2,22(r2)
81144f68:	10bfffcc 	andi	r2,r2,65535
81144f6c:	d0a0b215 	stw	r2,-32056(gp)
				}
			}
		}
	}
	return result;
81144f70:	e0bffe17 	ldw	r2,-8(fp)
}
81144f74:	e037883a 	mov	sp,fp
81144f78:	dfc00117 	ldw	ra,4(sp)
81144f7c:	df000017 	ldw	fp,0(sp)
81144f80:	dec00204 	addi	sp,sp,8
81144f84:	f800283a 	ret

81144f88 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
81144f88:	defffb04 	addi	sp,sp,-20
81144f8c:	de00012e 	bgeu	sp,et,81144f94 <filename_to_upper_case+0xc>
81144f90:	003b68fa 	trap	3
81144f94:	dfc00415 	stw	ra,16(sp)
81144f98:	df000315 	stw	fp,12(sp)
81144f9c:	df000304 	addi	fp,sp,12
81144fa0:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
81144fa4:	e13fff17 	ldw	r4,-4(fp)
81144fa8:	1124dc80 	call	81124dc8 <strlen>
81144fac:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
81144fb0:	e03ffd15 	stw	zero,-12(fp)
81144fb4:	00001e06 	br	81145030 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
81144fb8:	e0bffd17 	ldw	r2,-12(fp)
81144fbc:	e0ffff17 	ldw	r3,-4(fp)
81144fc0:	1885883a 	add	r2,r3,r2
81144fc4:	10800003 	ldbu	r2,0(r2)
81144fc8:	10803fcc 	andi	r2,r2,255
81144fcc:	1080201c 	xori	r2,r2,128
81144fd0:	10bfe004 	addi	r2,r2,-128
81144fd4:	10801850 	cmplti	r2,r2,97
81144fd8:	1000121e 	bne	r2,zero,81145024 <filename_to_upper_case+0x9c>
81144fdc:	e0bffd17 	ldw	r2,-12(fp)
81144fe0:	e0ffff17 	ldw	r3,-4(fp)
81144fe4:	1885883a 	add	r2,r3,r2
81144fe8:	10800003 	ldbu	r2,0(r2)
81144fec:	10803fcc 	andi	r2,r2,255
81144ff0:	1080201c 	xori	r2,r2,128
81144ff4:	10bfe004 	addi	r2,r2,-128
81144ff8:	10801ec8 	cmpgei	r2,r2,123
81144ffc:	1000091e 	bne	r2,zero,81145024 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
81145000:	e0bffd17 	ldw	r2,-12(fp)
81145004:	e0ffff17 	ldw	r3,-4(fp)
81145008:	1885883a 	add	r2,r3,r2
8114500c:	e0fffd17 	ldw	r3,-12(fp)
81145010:	e13fff17 	ldw	r4,-4(fp)
81145014:	20c7883a 	add	r3,r4,r3
81145018:	18c00003 	ldbu	r3,0(r3)
8114501c:	18fff804 	addi	r3,r3,-32
81145020:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
81145024:	e0bffd17 	ldw	r2,-12(fp)
81145028:	10800044 	addi	r2,r2,1
8114502c:	e0bffd15 	stw	r2,-12(fp)
81145030:	e0fffd17 	ldw	r3,-12(fp)
81145034:	e0bffe17 	ldw	r2,-8(fp)
81145038:	18bfdf16 	blt	r3,r2,81144fb8 <__reset+0xfb124fb8>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
8114503c:	0001883a 	nop
81145040:	e037883a 	mov	sp,fp
81145044:	dfc00117 	ldw	ra,4(sp)
81145048:	df000017 	ldw	fp,0(sp)
8114504c:	dec00204 	addi	sp,sp,8
81145050:	f800283a 	ret

81145054 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
81145054:	defff804 	addi	sp,sp,-32
81145058:	de00012e 	bgeu	sp,et,81145060 <check_file_name_for_FAT16_compliance+0xc>
8114505c:	003b68fa 	trap	3
81145060:	dfc00715 	stw	ra,28(sp)
81145064:	df000615 	stw	fp,24(sp)
81145068:	df000604 	addi	fp,sp,24
8114506c:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
81145070:	e13fff17 	ldw	r4,-4(fp)
81145074:	1124dc80 	call	81124dc8 <strlen>
81145078:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
8114507c:	00bfffc4 	movi	r2,-1
81145080:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
81145084:	00bfffc4 	movi	r2,-1
81145088:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
8114508c:	00800044 	movi	r2,1
81145090:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
81145094:	e03ffa15 	stw	zero,-24(fp)
81145098:	00006d06 	br	81145250 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
8114509c:	e0bffa17 	ldw	r2,-24(fp)
811450a0:	e0ffff17 	ldw	r3,-4(fp)
811450a4:	1885883a 	add	r2,r3,r2
811450a8:	10800003 	ldbu	r2,0(r2)
811450ac:	10803fcc 	andi	r2,r2,255
811450b0:	1080201c 	xori	r2,r2,128
811450b4:	10bfe004 	addi	r2,r2,-128
811450b8:	10800820 	cmpeqi	r2,r2,32
811450bc:	10003e1e 	bne	r2,zero,811451b8 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811450c0:	e0bffa17 	ldw	r2,-24(fp)
811450c4:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
811450c8:	e0bffb17 	ldw	r2,-20(fp)
811450cc:	1880121e 	bne	r3,r2,81145118 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811450d0:	e0bffa17 	ldw	r2,-24(fp)
811450d4:	e0ffff17 	ldw	r3,-4(fp)
811450d8:	1885883a 	add	r2,r3,r2
811450dc:	10800003 	ldbu	r2,0(r2)
811450e0:	10803fcc 	andi	r2,r2,255
811450e4:	1080201c 	xori	r2,r2,128
811450e8:	10bfe004 	addi	r2,r2,-128
811450ec:	10801720 	cmpeqi	r2,r2,92
811450f0:	1000311e 	bne	r2,zero,811451b8 <check_file_name_for_FAT16_compliance+0x164>
811450f4:	e0bffa17 	ldw	r2,-24(fp)
811450f8:	e0ffff17 	ldw	r3,-4(fp)
811450fc:	1885883a 	add	r2,r3,r2
81145100:	10800003 	ldbu	r2,0(r2)
81145104:	10803fcc 	andi	r2,r2,255
81145108:	1080201c 	xori	r2,r2,128
8114510c:	10bfe004 	addi	r2,r2,-128
81145110:	10800be0 	cmpeqi	r2,r2,47
81145114:	1000281e 	bne	r2,zero,811451b8 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81145118:	e0fffa17 	ldw	r3,-24(fp)
8114511c:	e0bffc17 	ldw	r2,-16(fp)
81145120:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81145124:	10800258 	cmpnei	r2,r2,9
81145128:	1000091e 	bne	r2,zero,81145150 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8114512c:	e0bffa17 	ldw	r2,-24(fp)
81145130:	e0ffff17 	ldw	r3,-4(fp)
81145134:	1885883a 	add	r2,r3,r2
81145138:	10800003 	ldbu	r2,0(r2)
8114513c:	10803fcc 	andi	r2,r2,255
81145140:	1080201c 	xori	r2,r2,128
81145144:	10bfe004 	addi	r2,r2,-128
81145148:	10800b98 	cmpnei	r2,r2,46
8114514c:	10001a1e 	bne	r2,zero,811451b8 <check_file_name_for_FAT16_compliance+0x164>
81145150:	e0fffb17 	ldw	r3,-20(fp)
81145154:	e0bffc17 	ldw	r2,-16(fp)
81145158:	18801926 	beq	r3,r2,811451c0 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8114515c:	e0fffa17 	ldw	r3,-24(fp)
81145160:	e0bffc17 	ldw	r2,-16(fp)
81145164:	1885c83a 	sub	r2,r3,r2
81145168:	10800110 	cmplti	r2,r2,4
8114516c:	1000141e 	bne	r2,zero,811451c0 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81145170:	e0bffa17 	ldw	r2,-24(fp)
81145174:	e0ffff17 	ldw	r3,-4(fp)
81145178:	1885883a 	add	r2,r3,r2
8114517c:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81145180:	10803fcc 	andi	r2,r2,255
81145184:	1080201c 	xori	r2,r2,128
81145188:	10bfe004 	addi	r2,r2,-128
8114518c:	10801720 	cmpeqi	r2,r2,92
81145190:	10000b1e 	bne	r2,zero,811451c0 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81145194:	e0bffa17 	ldw	r2,-24(fp)
81145198:	e0ffff17 	ldw	r3,-4(fp)
8114519c:	1885883a 	add	r2,r3,r2
811451a0:	10800003 	ldbu	r2,0(r2)
811451a4:	10803fcc 	andi	r2,r2,255
811451a8:	1080201c 	xori	r2,r2,128
811451ac:	10bfe004 	addi	r2,r2,-128
811451b0:	10800be0 	cmpeqi	r2,r2,47
811451b4:	1000021e 	bne	r2,zero,811451c0 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
811451b8:	e03ffd15 	stw	zero,-12(fp)
            break;
811451bc:	00002706 	br	8114525c <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
811451c0:	e0bffa17 	ldw	r2,-24(fp)
811451c4:	e0ffff17 	ldw	r3,-4(fp)
811451c8:	1885883a 	add	r2,r3,r2
811451cc:	10800003 	ldbu	r2,0(r2)
811451d0:	10803fcc 	andi	r2,r2,255
811451d4:	1080201c 	xori	r2,r2,128
811451d8:	10bfe004 	addi	r2,r2,-128
811451dc:	10801720 	cmpeqi	r2,r2,92
811451e0:	1000091e 	bne	r2,zero,81145208 <check_file_name_for_FAT16_compliance+0x1b4>
811451e4:	e0bffa17 	ldw	r2,-24(fp)
811451e8:	e0ffff17 	ldw	r3,-4(fp)
811451ec:	1885883a 	add	r2,r3,r2
811451f0:	10800003 	ldbu	r2,0(r2)
811451f4:	10803fcc 	andi	r2,r2,255
811451f8:	1080201c 	xori	r2,r2,128
811451fc:	10bfe004 	addi	r2,r2,-128
81145200:	10800bd8 	cmpnei	r2,r2,47
81145204:	1000041e 	bne	r2,zero,81145218 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
81145208:	e0bffa17 	ldw	r2,-24(fp)
8114520c:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
81145210:	e0bffa17 	ldw	r2,-24(fp)
81145214:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
81145218:	e0bffa17 	ldw	r2,-24(fp)
8114521c:	e0ffff17 	ldw	r3,-4(fp)
81145220:	1885883a 	add	r2,r3,r2
81145224:	10800003 	ldbu	r2,0(r2)
81145228:	10803fcc 	andi	r2,r2,255
8114522c:	1080201c 	xori	r2,r2,128
81145230:	10bfe004 	addi	r2,r2,-128
81145234:	10800b98 	cmpnei	r2,r2,46
81145238:	1000021e 	bne	r2,zero,81145244 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
8114523c:	e0bffa17 	ldw	r2,-24(fp)
81145240:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
81145244:	e0bffa17 	ldw	r2,-24(fp)
81145248:	10800044 	addi	r2,r2,1
8114524c:	e0bffa15 	stw	r2,-24(fp)
81145250:	e0fffa17 	ldw	r3,-24(fp)
81145254:	e0bffe17 	ldw	r2,-8(fp)
81145258:	18bf9016 	blt	r3,r2,8114509c <__reset+0xfb12509c>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
8114525c:	e0bffe17 	ldw	r2,-8(fp)
81145260:	10bfffc4 	addi	r2,r2,-1
81145264:	e0ffff17 	ldw	r3,-4(fp)
81145268:	1885883a 	add	r2,r3,r2
8114526c:	10800003 	ldbu	r2,0(r2)
81145270:	10803fcc 	andi	r2,r2,255
81145274:	1080201c 	xori	r2,r2,128
81145278:	10bfe004 	addi	r2,r2,-128
8114527c:	10801720 	cmpeqi	r2,r2,92
81145280:	10000a1e 	bne	r2,zero,811452ac <check_file_name_for_FAT16_compliance+0x258>
81145284:	e0bffe17 	ldw	r2,-8(fp)
81145288:	10bfffc4 	addi	r2,r2,-1
8114528c:	e0ffff17 	ldw	r3,-4(fp)
81145290:	1885883a 	add	r2,r3,r2
81145294:	10800003 	ldbu	r2,0(r2)
81145298:	10803fcc 	andi	r2,r2,255
8114529c:	1080201c 	xori	r2,r2,128
811452a0:	10bfe004 	addi	r2,r2,-128
811452a4:	10800bd8 	cmpnei	r2,r2,47
811452a8:	1000011e 	bne	r2,zero,811452b0 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
811452ac:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
811452b0:	e0bffd17 	ldw	r2,-12(fp)
}
811452b4:	e037883a 	mov	sp,fp
811452b8:	dfc00117 	ldw	ra,4(sp)
811452bc:	df000017 	ldw	fp,0(sp)
811452c0:	dec00204 	addi	sp,sp,8
811452c4:	f800283a 	ret

811452c8 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
811452c8:	defffb04 	addi	sp,sp,-20
811452cc:	de00012e 	bgeu	sp,et,811452d4 <get_dir_divider_location+0xc>
811452d0:	003b68fa 	trap	3
811452d4:	dfc00415 	stw	ra,16(sp)
811452d8:	df000315 	stw	fp,12(sp)
811452dc:	df000304 	addi	fp,sp,12
811452e0:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
811452e4:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
811452e8:	e13fff17 	ldw	r4,-4(fp)
811452ec:	1124dc80 	call	81124dc8 <strlen>
811452f0:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
811452f4:	e03ffd15 	stw	zero,-12(fp)
811452f8:	00001506 	br	81145350 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
811452fc:	e0bffd17 	ldw	r2,-12(fp)
81145300:	e0ffff17 	ldw	r3,-4(fp)
81145304:	1885883a 	add	r2,r3,r2
81145308:	10800003 	ldbu	r2,0(r2)
8114530c:	10803fcc 	andi	r2,r2,255
81145310:	1080201c 	xori	r2,r2,128
81145314:	10bfe004 	addi	r2,r2,-128
81145318:	10801720 	cmpeqi	r2,r2,92
8114531c:	10000f1e 	bne	r2,zero,8114535c <get_dir_divider_location+0x94>
81145320:	e0bffd17 	ldw	r2,-12(fp)
81145324:	e0ffff17 	ldw	r3,-4(fp)
81145328:	1885883a 	add	r2,r3,r2
8114532c:	10800003 	ldbu	r2,0(r2)
81145330:	10803fcc 	andi	r2,r2,255
81145334:	1080201c 	xori	r2,r2,128
81145338:	10bfe004 	addi	r2,r2,-128
8114533c:	10800be0 	cmpeqi	r2,r2,47
81145340:	1000061e 	bne	r2,zero,8114535c <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
81145344:	e0bffd17 	ldw	r2,-12(fp)
81145348:	10800044 	addi	r2,r2,1
8114534c:	e0bffd15 	stw	r2,-12(fp)
81145350:	e0fffd17 	ldw	r3,-12(fp)
81145354:	e0bffe17 	ldw	r2,-8(fp)
81145358:	18bfe816 	blt	r3,r2,811452fc <__reset+0xfb1252fc>
        {
            break;
        }
    }
    
    if (index == length)
8114535c:	e0fffd17 	ldw	r3,-12(fp)
81145360:	e0bffe17 	ldw	r2,-8(fp)
81145364:	1880021e 	bne	r3,r2,81145370 <get_dir_divider_location+0xa8>
    {
        index = -1;
81145368:	00bfffc4 	movi	r2,-1
8114536c:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
81145370:	e0bffd17 	ldw	r2,-12(fp)
}
81145374:	e037883a 	mov	sp,fp
81145378:	dfc00117 	ldw	ra,4(sp)
8114537c:	df000017 	ldw	fp,0(sp)
81145380:	dec00204 	addi	sp,sp,8
81145384:	f800283a 	ret

81145388 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
81145388:	defffa04 	addi	sp,sp,-24
8114538c:	de00012e 	bgeu	sp,et,81145394 <match_file_record_to_name_ext+0xc>
81145390:	003b68fa 	trap	3
81145394:	df000515 	stw	fp,20(sp)
81145398:	df000504 	addi	fp,sp,20
8114539c:	e13ffd15 	stw	r4,-12(fp)
811453a0:	e17ffe15 	stw	r5,-8(fp)
811453a4:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
811453a8:	00800044 	movi	r2,1
811453ac:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
811453b0:	e03ffc15 	stw	zero,-16(fp)
811453b4:	00004606 	br	811454d0 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
811453b8:	e0fffd17 	ldw	r3,-12(fp)
811453bc:	e0bffc17 	ldw	r2,-16(fp)
811453c0:	1885883a 	add	r2,r3,r2
811453c4:	10800003 	ldbu	r2,0(r2)
811453c8:	10803fcc 	andi	r2,r2,255
811453cc:	10801870 	cmpltui	r2,r2,97
811453d0:	1000101e 	bne	r2,zero,81145414 <match_file_record_to_name_ext+0x8c>
811453d4:	e0fffd17 	ldw	r3,-12(fp)
811453d8:	e0bffc17 	ldw	r2,-16(fp)
811453dc:	1885883a 	add	r2,r3,r2
811453e0:	10800003 	ldbu	r2,0(r2)
811453e4:	10803fcc 	andi	r2,r2,255
811453e8:	10801ee8 	cmpgeui	r2,r2,123
811453ec:	1000091e 	bne	r2,zero,81145414 <match_file_record_to_name_ext+0x8c>
811453f0:	e0fffd17 	ldw	r3,-12(fp)
811453f4:	e0bffc17 	ldw	r2,-16(fp)
811453f8:	1885883a 	add	r2,r3,r2
811453fc:	10800003 	ldbu	r2,0(r2)
81145400:	10bff804 	addi	r2,r2,-32
81145404:	10c03fcc 	andi	r3,r2,255
81145408:	18c0201c 	xori	r3,r3,128
8114540c:	18ffe004 	addi	r3,r3,-128
81145410:	00000706 	br	81145430 <match_file_record_to_name_ext+0xa8>
81145414:	e0fffd17 	ldw	r3,-12(fp)
81145418:	e0bffc17 	ldw	r2,-16(fp)
8114541c:	1885883a 	add	r2,r3,r2
81145420:	10800003 	ldbu	r2,0(r2)
81145424:	10c03fcc 	andi	r3,r2,255
81145428:	18c0201c 	xori	r3,r3,128
8114542c:	18ffe004 	addi	r3,r3,-128
81145430:	e0bffc17 	ldw	r2,-16(fp)
81145434:	e13ffe17 	ldw	r4,-8(fp)
81145438:	2085883a 	add	r2,r4,r2
8114543c:	10800003 	ldbu	r2,0(r2)
81145440:	10803fcc 	andi	r2,r2,255
81145444:	1080201c 	xori	r2,r2,128
81145448:	10bfe004 	addi	r2,r2,-128
8114544c:	10801850 	cmplti	r2,r2,97
81145450:	1000121e 	bne	r2,zero,8114549c <match_file_record_to_name_ext+0x114>
81145454:	e0bffc17 	ldw	r2,-16(fp)
81145458:	e13ffe17 	ldw	r4,-8(fp)
8114545c:	2085883a 	add	r2,r4,r2
81145460:	10800003 	ldbu	r2,0(r2)
81145464:	10803fcc 	andi	r2,r2,255
81145468:	1080201c 	xori	r2,r2,128
8114546c:	10bfe004 	addi	r2,r2,-128
81145470:	10801ec8 	cmpgei	r2,r2,123
81145474:	1000091e 	bne	r2,zero,8114549c <match_file_record_to_name_ext+0x114>
81145478:	e0bffc17 	ldw	r2,-16(fp)
8114547c:	e13ffe17 	ldw	r4,-8(fp)
81145480:	2085883a 	add	r2,r4,r2
81145484:	10800003 	ldbu	r2,0(r2)
81145488:	10bff804 	addi	r2,r2,-32
8114548c:	10803fcc 	andi	r2,r2,255
81145490:	1080201c 	xori	r2,r2,128
81145494:	10bfe004 	addi	r2,r2,-128
81145498:	00000706 	br	811454b8 <match_file_record_to_name_ext+0x130>
8114549c:	e0bffc17 	ldw	r2,-16(fp)
811454a0:	e13ffe17 	ldw	r4,-8(fp)
811454a4:	2085883a 	add	r2,r4,r2
811454a8:	10800003 	ldbu	r2,0(r2)
811454ac:	10803fcc 	andi	r2,r2,255
811454b0:	1080201c 	xori	r2,r2,128
811454b4:	10bfe004 	addi	r2,r2,-128
811454b8:	18800226 	beq	r3,r2,811454c4 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
811454bc:	e03ffb15 	stw	zero,-20(fp)
			break;
811454c0:	00000606 	br	811454dc <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
811454c4:	e0bffc17 	ldw	r2,-16(fp)
811454c8:	10800044 	addi	r2,r2,1
811454cc:	e0bffc15 	stw	r2,-16(fp)
811454d0:	e0bffc17 	ldw	r2,-16(fp)
811454d4:	10800210 	cmplti	r2,r2,8
811454d8:	103fb71e 	bne	r2,zero,811453b8 <__reset+0xfb1253b8>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
811454dc:	e03ffc15 	stw	zero,-16(fp)
811454e0:	00004a06 	br	8114560c <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
811454e4:	e0fffd17 	ldw	r3,-12(fp)
811454e8:	e0bffc17 	ldw	r2,-16(fp)
811454ec:	1885883a 	add	r2,r3,r2
811454f0:	10800204 	addi	r2,r2,8
811454f4:	10800003 	ldbu	r2,0(r2)
811454f8:	10803fcc 	andi	r2,r2,255
811454fc:	10801870 	cmpltui	r2,r2,97
81145500:	1000121e 	bne	r2,zero,8114554c <match_file_record_to_name_ext+0x1c4>
81145504:	e0fffd17 	ldw	r3,-12(fp)
81145508:	e0bffc17 	ldw	r2,-16(fp)
8114550c:	1885883a 	add	r2,r3,r2
81145510:	10800204 	addi	r2,r2,8
81145514:	10800003 	ldbu	r2,0(r2)
81145518:	10803fcc 	andi	r2,r2,255
8114551c:	10801ee8 	cmpgeui	r2,r2,123
81145520:	10000a1e 	bne	r2,zero,8114554c <match_file_record_to_name_ext+0x1c4>
81145524:	e0fffd17 	ldw	r3,-12(fp)
81145528:	e0bffc17 	ldw	r2,-16(fp)
8114552c:	1885883a 	add	r2,r3,r2
81145530:	10800204 	addi	r2,r2,8
81145534:	10800003 	ldbu	r2,0(r2)
81145538:	10bff804 	addi	r2,r2,-32
8114553c:	10c03fcc 	andi	r3,r2,255
81145540:	18c0201c 	xori	r3,r3,128
81145544:	18ffe004 	addi	r3,r3,-128
81145548:	00000806 	br	8114556c <match_file_record_to_name_ext+0x1e4>
8114554c:	e0fffd17 	ldw	r3,-12(fp)
81145550:	e0bffc17 	ldw	r2,-16(fp)
81145554:	1885883a 	add	r2,r3,r2
81145558:	10800204 	addi	r2,r2,8
8114555c:	10800003 	ldbu	r2,0(r2)
81145560:	10c03fcc 	andi	r3,r2,255
81145564:	18c0201c 	xori	r3,r3,128
81145568:	18ffe004 	addi	r3,r3,-128
8114556c:	e0bffc17 	ldw	r2,-16(fp)
81145570:	e13fff17 	ldw	r4,-4(fp)
81145574:	2085883a 	add	r2,r4,r2
81145578:	10800003 	ldbu	r2,0(r2)
8114557c:	10803fcc 	andi	r2,r2,255
81145580:	1080201c 	xori	r2,r2,128
81145584:	10bfe004 	addi	r2,r2,-128
81145588:	10801850 	cmplti	r2,r2,97
8114558c:	1000121e 	bne	r2,zero,811455d8 <match_file_record_to_name_ext+0x250>
81145590:	e0bffc17 	ldw	r2,-16(fp)
81145594:	e13fff17 	ldw	r4,-4(fp)
81145598:	2085883a 	add	r2,r4,r2
8114559c:	10800003 	ldbu	r2,0(r2)
811455a0:	10803fcc 	andi	r2,r2,255
811455a4:	1080201c 	xori	r2,r2,128
811455a8:	10bfe004 	addi	r2,r2,-128
811455ac:	10801ec8 	cmpgei	r2,r2,123
811455b0:	1000091e 	bne	r2,zero,811455d8 <match_file_record_to_name_ext+0x250>
811455b4:	e0bffc17 	ldw	r2,-16(fp)
811455b8:	e13fff17 	ldw	r4,-4(fp)
811455bc:	2085883a 	add	r2,r4,r2
811455c0:	10800003 	ldbu	r2,0(r2)
811455c4:	10bff804 	addi	r2,r2,-32
811455c8:	10803fcc 	andi	r2,r2,255
811455cc:	1080201c 	xori	r2,r2,128
811455d0:	10bfe004 	addi	r2,r2,-128
811455d4:	00000706 	br	811455f4 <match_file_record_to_name_ext+0x26c>
811455d8:	e0bffc17 	ldw	r2,-16(fp)
811455dc:	e13fff17 	ldw	r4,-4(fp)
811455e0:	2085883a 	add	r2,r4,r2
811455e4:	10800003 	ldbu	r2,0(r2)
811455e8:	10803fcc 	andi	r2,r2,255
811455ec:	1080201c 	xori	r2,r2,128
811455f0:	10bfe004 	addi	r2,r2,-128
811455f4:	18800226 	beq	r3,r2,81145600 <match_file_record_to_name_ext+0x278>
        {
            match = false;
811455f8:	e03ffb15 	stw	zero,-20(fp)
			break;
811455fc:	00000606 	br	81145618 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81145600:	e0bffc17 	ldw	r2,-16(fp)
81145604:	10800044 	addi	r2,r2,1
81145608:	e0bffc15 	stw	r2,-16(fp)
8114560c:	e0bffc17 	ldw	r2,-16(fp)
81145610:	108000d0 	cmplti	r2,r2,3
81145614:	103fb31e 	bne	r2,zero,811454e4 <__reset+0xfb1254e4>
        {
            match = false;
			break;
        }
    }
	return match;
81145618:	e0bffb17 	ldw	r2,-20(fp)
}
8114561c:	e037883a 	mov	sp,fp
81145620:	df000017 	ldw	fp,0(sp)
81145624:	dec00104 	addi	sp,sp,4
81145628:	f800283a 	ret

8114562c <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
8114562c:	deffe704 	addi	sp,sp,-100
81145630:	de00012e 	bgeu	sp,et,81145638 <get_home_directory_cluster_for_file+0xc>
81145634:	003b68fa 	trap	3
81145638:	dfc01815 	stw	ra,96(sp)
8114563c:	df001715 	stw	fp,92(sp)
81145640:	df001704 	addi	fp,sp,92
81145644:	e13ffd15 	stw	r4,-12(fp)
81145648:	e17ffe15 	stw	r5,-8(fp)
8114564c:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
81145650:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
81145654:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
81145658:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
8114565c:	e13ffd17 	ldw	r4,-12(fp)
81145660:	11452c80 	call	811452c8 <get_dir_divider_location>
81145664:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
81145668:	00012f06 	br	81145b28 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8114566c:	00800804 	movi	r2,32
81145670:	e0bff905 	stb	r2,-28(fp)
81145674:	00800804 	movi	r2,32
81145678:	e0bff945 	stb	r2,-27(fp)
8114567c:	00800804 	movi	r2,32
81145680:	e0bff985 	stb	r2,-26(fp)
81145684:	00800804 	movi	r2,32
81145688:	e0bff9c5 	stb	r2,-25(fp)
8114568c:	00800804 	movi	r2,32
81145690:	e0bffa05 	stb	r2,-24(fp)
81145694:	00800804 	movi	r2,32
81145698:	e0bffa45 	stb	r2,-23(fp)
8114569c:	00800804 	movi	r2,32
811456a0:	e0bffa85 	stb	r2,-22(fp)
811456a4:	00800804 	movi	r2,32
811456a8:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
811456ac:	00800804 	movi	r2,32
811456b0:	e0bffb05 	stb	r2,-20(fp)
811456b4:	00800804 	movi	r2,32
811456b8:	e0bffb45 	stb	r2,-19(fp)
811456bc:	00800804 	movi	r2,32
811456c0:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
811456c4:	00bfffc4 	movi	r2,-1
811456c8:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
811456cc:	e0bfea17 	ldw	r2,-88(fp)
811456d0:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
811456d4:	e03fec15 	stw	zero,-80(fp)
811456d8:	00002d06 	br	81145790 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
811456dc:	e0ffec17 	ldw	r3,-80(fp)
811456e0:	e0bfed17 	ldw	r2,-76(fp)
811456e4:	1885883a 	add	r2,r3,r2
811456e8:	1007883a 	mov	r3,r2
811456ec:	e0bffd17 	ldw	r2,-12(fp)
811456f0:	10c5883a 	add	r2,r2,r3
811456f4:	10800003 	ldbu	r2,0(r2)
811456f8:	10803fcc 	andi	r2,r2,255
811456fc:	1080201c 	xori	r2,r2,128
81145700:	10bfe004 	addi	r2,r2,-128
81145704:	10800b98 	cmpnei	r2,r2,46
81145708:	1000031e 	bne	r2,zero,81145718 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
8114570c:	e0bfec17 	ldw	r2,-80(fp)
81145710:	e0bfee15 	stw	r2,-72(fp)
81145714:	00001b06 	br	81145784 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
81145718:	e0bfee17 	ldw	r2,-72(fp)
8114571c:	10000c0e 	bge	r2,zero,81145750 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
81145720:	e0ffec17 	ldw	r3,-80(fp)
81145724:	e0bfed17 	ldw	r2,-76(fp)
81145728:	1885883a 	add	r2,r3,r2
8114572c:	1007883a 	mov	r3,r2
81145730:	e0bffd17 	ldw	r2,-12(fp)
81145734:	10c5883a 	add	r2,r2,r3
81145738:	10c00003 	ldbu	r3,0(r2)
8114573c:	e13ff904 	addi	r4,fp,-28
81145740:	e0bfec17 	ldw	r2,-80(fp)
81145744:	2085883a 	add	r2,r4,r2
81145748:	10c00005 	stb	r3,0(r2)
8114574c:	00000d06 	br	81145784 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
81145750:	e0ffec17 	ldw	r3,-80(fp)
81145754:	e0bfee17 	ldw	r2,-72(fp)
81145758:	1885c83a 	sub	r2,r3,r2
8114575c:	e13fec17 	ldw	r4,-80(fp)
81145760:	e0ffed17 	ldw	r3,-76(fp)
81145764:	20c7883a 	add	r3,r4,r3
81145768:	1809883a 	mov	r4,r3
8114576c:	e0fffd17 	ldw	r3,-12(fp)
81145770:	1907883a 	add	r3,r3,r4
81145774:	18c00003 	ldbu	r3,0(r3)
81145778:	e13ffb04 	addi	r4,fp,-20
8114577c:	2085883a 	add	r2,r4,r2
81145780:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81145784:	e0bfec17 	ldw	r2,-80(fp)
81145788:	10800044 	addi	r2,r2,1
8114578c:	e0bfec15 	stw	r2,-80(fp)
81145790:	e0ffec17 	ldw	r3,-80(fp)
81145794:	e0bfeb17 	ldw	r2,-84(fp)
81145798:	18bfd016 	blt	r3,r2,811456dc <__reset+0xfb1256dc>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
8114579c:	e0bfea17 	ldw	r2,-88(fp)
811457a0:	10005c1e 	bne	r2,zero,81145914 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811457a4:	00a045f4 	movhi	r2,33047
811457a8:	10ba9804 	addi	r2,r2,-5536
811457ac:	1080050b 	ldhu	r2,20(r2)
811457b0:	10bfffcc 	andi	r2,r2,65535
811457b4:	1006917a 	slli	r3,r2,5
811457b8:	00a045f4 	movhi	r2,33047
811457bc:	10ba9804 	addi	r2,r2,-5536
811457c0:	1080030b 	ldhu	r2,12(r2)
811457c4:	10bfffcc 	andi	r2,r2,65535
811457c8:	1885283a 	div	r2,r3,r2
811457cc:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811457d0:	e03ff015 	stw	zero,-64(fp)
811457d4:	00003b06 	br	811458c4 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
811457d8:	00a045f4 	movhi	r2,33047
811457dc:	10ba9804 	addi	r2,r2,-5536
811457e0:	10c01317 	ldw	r3,76(r2)
811457e4:	e0bff017 	ldw	r2,-64(fp)
811457e8:	1885883a 	add	r2,r3,r2
811457ec:	1007883a 	mov	r3,r2
811457f0:	d0a0b117 	ldw	r2,-32060(gp)
811457f4:	100b883a 	mov	r5,r2
811457f8:	1809883a 	mov	r4,r3
811457fc:	1143ec40 	call	81143ec4 <Read_Sector_Data>
81145800:	10003426 	beq	r2,zero,811458d4 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81145804:	e03ff115 	stw	zero,-60(fp)
81145808:	00002506 	br	811458a0 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8114580c:	e0bff117 	ldw	r2,-60(fp)
81145810:	1004917a 	slli	r2,r2,5
81145814:	e0fff017 	ldw	r3,-64(fp)
81145818:	180f883a 	mov	r7,r3
8114581c:	000d883a 	mov	r6,zero
81145820:	e17fff17 	ldw	r5,-4(fp)
81145824:	1009883a 	mov	r4,r2
81145828:	11442f40 	call	811442f4 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8114582c:	e0bfff17 	ldw	r2,-4(fp)
81145830:	10800003 	ldbu	r2,0(r2)
81145834:	10803fcc 	andi	r2,r2,255
81145838:	10803960 	cmpeqi	r2,r2,229
8114583c:	1000151e 	bne	r2,zero,81145894 <get_home_directory_cluster_for_file+0x268>
81145840:	e0bfff17 	ldw	r2,-4(fp)
81145844:	10800003 	ldbu	r2,0(r2)
81145848:	10803fcc 	andi	r2,r2,255
8114584c:	10001126 	beq	r2,zero,81145894 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81145850:	e0fffb04 	addi	r3,fp,-20
81145854:	e0bff904 	addi	r2,fp,-28
81145858:	180d883a 	mov	r6,r3
8114585c:	100b883a 	mov	r5,r2
81145860:	e13fff17 	ldw	r4,-4(fp)
81145864:	11453880 	call	81145388 <match_file_record_to_name_ext>
81145868:	e0bff815 	stw	r2,-32(fp)
                            if (match)
8114586c:	e0bff817 	ldw	r2,-32(fp)
81145870:	10000826 	beq	r2,zero,81145894 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
81145874:	e0bfff17 	ldw	r2,-4(fp)
81145878:	1080058b 	ldhu	r2,22(r2)
8114587c:	10bfffcc 	andi	r2,r2,65535
81145880:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
81145884:	e0bfff17 	ldw	r2,-4(fp)
81145888:	00c00044 	movi	r3,1
8114588c:	10c00a15 	stw	r3,40(r2)
                                break;
81145890:	00000606 	br	811458ac <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81145894:	e0bff117 	ldw	r2,-60(fp)
81145898:	10800044 	addi	r2,r2,1
8114589c:	e0bff115 	stw	r2,-60(fp)
811458a0:	e0bff117 	ldw	r2,-60(fp)
811458a4:	10800410 	cmplti	r2,r2,16
811458a8:	103fd81e 	bne	r2,zero,8114580c <__reset+0xfb12580c>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
811458ac:	e0ffef17 	ldw	r3,-68(fp)
811458b0:	e0bfea17 	ldw	r2,-88(fp)
811458b4:	1880091e 	bne	r3,r2,811458dc <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811458b8:	e0bff017 	ldw	r2,-64(fp)
811458bc:	10800044 	addi	r2,r2,1
811458c0:	e0bff015 	stw	r2,-64(fp)
811458c4:	e0fff017 	ldw	r3,-64(fp)
811458c8:	e0bff717 	ldw	r2,-36(fp)
811458cc:	18bfc216 	blt	r3,r2,811457d8 <__reset+0xfb1257d8>
811458d0:	00000306 	br	811458e0 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
811458d4:	0001883a 	nop
811458d8:	00000106 	br	811458e0 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
811458dc:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
811458e0:	e0ffef17 	ldw	r3,-68(fp)
811458e4:	e0bfea17 	ldw	r2,-88(fp)
811458e8:	18800826 	beq	r3,r2,8114590c <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
811458ec:	e0bfef17 	ldw	r2,-68(fp)
811458f0:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
811458f4:	e0ffed17 	ldw	r3,-76(fp)
811458f8:	e0bfeb17 	ldw	r2,-84(fp)
811458fc:	1885883a 	add	r2,r3,r2
81145900:	10800044 	addi	r2,r2,1
81145904:	e0bfed15 	stw	r2,-76(fp)
81145908:	00007d06 	br	81145b00 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8114590c:	0005883a 	mov	r2,zero
81145910:	00009106 	br	81145b58 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
81145914:	e0bfea17 	ldw	r2,-88(fp)
81145918:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8114591c:	e0bff417 	ldw	r2,-48(fp)
81145920:	10ffff84 	addi	r3,r2,-2
81145924:	00a045f4 	movhi	r2,33047
81145928:	10ba9804 	addi	r2,r2,-5536
8114592c:	10800383 	ldbu	r2,14(r2)
81145930:	10803fcc 	andi	r2,r2,255
81145934:	1885383a 	mul	r2,r3,r2
81145938:	1007883a 	mov	r3,r2
8114593c:	00a045f4 	movhi	r2,33047
81145940:	10ba9804 	addi	r2,r2,-5536
81145944:	10801417 	ldw	r2,80(r2)
81145948:	1885883a 	add	r2,r3,r2
8114594c:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145950:	e03ff215 	stw	zero,-56(fp)
81145954:	00003606 	br	81145a30 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81145958:	e0fff217 	ldw	r3,-56(fp)
8114595c:	e0bff517 	ldw	r2,-44(fp)
81145960:	1885883a 	add	r2,r3,r2
81145964:	d0e0b117 	ldw	r3,-32060(gp)
81145968:	180b883a 	mov	r5,r3
8114596c:	1009883a 	mov	r4,r2
81145970:	1143ec40 	call	81143ec4 <Read_Sector_Data>
81145974:	10003526 	beq	r2,zero,81145a4c <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81145978:	e03ff315 	stw	zero,-52(fp)
8114597c:	00002306 	br	81145a0c <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81145980:	e0bff317 	ldw	r2,-52(fp)
81145984:	1004917a 	slli	r2,r2,5
81145988:	e0fff417 	ldw	r3,-48(fp)
8114598c:	e13ff217 	ldw	r4,-56(fp)
81145990:	200f883a 	mov	r7,r4
81145994:	180d883a 	mov	r6,r3
81145998:	e17fff17 	ldw	r5,-4(fp)
8114599c:	1009883a 	mov	r4,r2
811459a0:	11442f40 	call	811442f4 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
811459a4:	e0bfff17 	ldw	r2,-4(fp)
811459a8:	10800003 	ldbu	r2,0(r2)
811459ac:	10803fcc 	andi	r2,r2,255
811459b0:	10803960 	cmpeqi	r2,r2,229
811459b4:	1000121e 	bne	r2,zero,81145a00 <get_home_directory_cluster_for_file+0x3d4>
811459b8:	e0bfff17 	ldw	r2,-4(fp)
811459bc:	10800003 	ldbu	r2,0(r2)
811459c0:	10803fcc 	andi	r2,r2,255
811459c4:	10000e26 	beq	r2,zero,81145a00 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
811459c8:	e0fffb04 	addi	r3,fp,-20
811459cc:	e0bff904 	addi	r2,fp,-28
811459d0:	180d883a 	mov	r6,r3
811459d4:	100b883a 	mov	r5,r2
811459d8:	e13fff17 	ldw	r4,-4(fp)
811459dc:	11453880 	call	81145388 <match_file_record_to_name_ext>
811459e0:	e0bff615 	stw	r2,-40(fp)
                                if (match)
811459e4:	e0bff617 	ldw	r2,-40(fp)
811459e8:	10000526 	beq	r2,zero,81145a00 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
811459ec:	e0bfff17 	ldw	r2,-4(fp)
811459f0:	1080058b 	ldhu	r2,22(r2)
811459f4:	10bfffcc 	andi	r2,r2,65535
811459f8:	e0bfef15 	stw	r2,-68(fp)
                                    break;
811459fc:	00000606 	br	81145a18 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81145a00:	e0bff317 	ldw	r2,-52(fp)
81145a04:	10800044 	addi	r2,r2,1
81145a08:	e0bff315 	stw	r2,-52(fp)
81145a0c:	e0bff317 	ldw	r2,-52(fp)
81145a10:	10800410 	cmplti	r2,r2,16
81145a14:	103fda1e 	bne	r2,zero,81145980 <__reset+0xfb125980>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
81145a18:	e0ffef17 	ldw	r3,-68(fp)
81145a1c:	e0bfea17 	ldw	r2,-88(fp)
81145a20:	18800c1e 	bne	r3,r2,81145a54 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145a24:	e0bff217 	ldw	r2,-56(fp)
81145a28:	10800044 	addi	r2,r2,1
81145a2c:	e0bff215 	stw	r2,-56(fp)
81145a30:	00a045f4 	movhi	r2,33047
81145a34:	10ba9804 	addi	r2,r2,-5536
81145a38:	10800383 	ldbu	r2,14(r2)
81145a3c:	10803fcc 	andi	r2,r2,255
81145a40:	e0fff217 	ldw	r3,-56(fp)
81145a44:	18bfc416 	blt	r3,r2,81145958 <__reset+0xfb125958>
81145a48:	00000306 	br	81145a58 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
81145a4c:	0001883a 	nop
81145a50:	00000106 	br	81145a58 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
81145a54:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
81145a58:	e0ffef17 	ldw	r3,-68(fp)
81145a5c:	e0bfea17 	ldw	r2,-88(fp)
81145a60:	1880141e 	bne	r3,r2,81145ab4 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
81145a64:	e0bfef17 	ldw	r2,-68(fp)
81145a68:	e0fffc04 	addi	r3,fp,-16
81145a6c:	180b883a 	mov	r5,r3
81145a70:	1009883a 	mov	r4,r2
81145a74:	1143fa40 	call	81143fa4 <get_cluster_flag>
81145a78:	10000c26 	beq	r2,zero,81145aac <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81145a7c:	e0bffc0b 	ldhu	r2,-16(fp)
81145a80:	10bfffcc 	andi	r2,r2,65535
81145a84:	10fffe0c 	andi	r3,r2,65528
81145a88:	00bffe14 	movui	r2,65528
81145a8c:	1880021e 	bne	r3,r2,81145a98 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
81145a90:	0005883a 	mov	r2,zero
81145a94:	00003006 	br	81145b58 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
81145a98:	e0bffc0b 	ldhu	r2,-16(fp)
81145a9c:	10bfffcc 	andi	r2,r2,65535
81145aa0:	10bffe0c 	andi	r2,r2,65528
81145aa4:	e0bfef15 	stw	r2,-68(fp)
81145aa8:	00000206 	br	81145ab4 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
81145aac:	0005883a 	mov	r2,zero
81145ab0:	00002906 	br	81145b58 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
81145ab4:	e0bff417 	ldw	r2,-48(fp)
81145ab8:	00fffdd4 	movui	r3,65527
81145abc:	18800316 	blt	r3,r2,81145acc <get_home_directory_cluster_for_file+0x4a0>
81145ac0:	e0ffef17 	ldw	r3,-68(fp)
81145ac4:	e0bfea17 	ldw	r2,-88(fp)
81145ac8:	18bf9426 	beq	r3,r2,8114591c <__reset+0xfb12591c>
            if (new_cluster != home_dir_cluster)
81145acc:	e0ffef17 	ldw	r3,-68(fp)
81145ad0:	e0bfea17 	ldw	r2,-88(fp)
81145ad4:	18800826 	beq	r3,r2,81145af8 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81145ad8:	e0bfef17 	ldw	r2,-68(fp)
81145adc:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81145ae0:	e0ffed17 	ldw	r3,-76(fp)
81145ae4:	e0bfeb17 	ldw	r2,-84(fp)
81145ae8:	1885883a 	add	r2,r3,r2
81145aec:	10800044 	addi	r2,r2,1
81145af0:	e0bfed15 	stw	r2,-76(fp)
81145af4:	00000206 	br	81145b00 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81145af8:	0005883a 	mov	r2,zero
81145afc:	00001606 	br	81145b58 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
81145b00:	e0bfed17 	ldw	r2,-76(fp)
81145b04:	e0fffd17 	ldw	r3,-12(fp)
81145b08:	1885883a 	add	r2,r3,r2
81145b0c:	1009883a 	mov	r4,r2
81145b10:	11452c80 	call	811452c8 <get_dir_divider_location>
81145b14:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
81145b18:	e0bfeb17 	ldw	r2,-84(fp)
81145b1c:	1000020e 	bge	r2,zero,81145b28 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
81145b20:	00800044 	movi	r2,1
81145b24:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
81145b28:	e0bfeb17 	ldw	r2,-84(fp)
81145b2c:	00becf16 	blt	zero,r2,8114566c <__reset+0xfb12566c>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
81145b30:	e0bffe17 	ldw	r2,-8(fp)
81145b34:	e0ffea17 	ldw	r3,-88(fp)
81145b38:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
81145b3c:	e0bfea17 	ldw	r2,-88(fp)
81145b40:	1000041e 	bne	r2,zero,81145b54 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
81145b44:	e0bfff17 	ldw	r2,-4(fp)
81145b48:	10000a15 	stw	zero,40(r2)
		result = true;
81145b4c:	00800044 	movi	r2,1
81145b50:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
81145b54:	e0bfe917 	ldw	r2,-92(fp)
}
81145b58:	e037883a 	mov	sp,fp
81145b5c:	dfc00117 	ldw	ra,4(sp)
81145b60:	df000017 	ldw	fp,0(sp)
81145b64:	dec00204 	addi	sp,sp,8
81145b68:	f800283a 	ret

81145b6c <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
81145b6c:	deffe804 	addi	sp,sp,-96
81145b70:	de00012e 	bgeu	sp,et,81145b78 <find_file_in_directory+0xc>
81145b74:	003b68fa 	trap	3
81145b78:	dfc01715 	stw	ra,92(sp)
81145b7c:	df001615 	stw	fp,88(sp)
81145b80:	df001604 	addi	fp,sp,88
81145b84:	e13ffd15 	stw	r4,-12(fp)
81145b88:	e17ffe15 	stw	r5,-8(fp)
81145b8c:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
81145b90:	e13ffe17 	ldw	r4,-8(fp)
81145b94:	11452c80 	call	811452c8 <get_dir_divider_location>
81145b98:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
81145b9c:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81145ba0:	00800804 	movi	r2,32
81145ba4:	e0bff905 	stb	r2,-28(fp)
81145ba8:	00800804 	movi	r2,32
81145bac:	e0bff945 	stb	r2,-27(fp)
81145bb0:	00800804 	movi	r2,32
81145bb4:	e0bff985 	stb	r2,-26(fp)
81145bb8:	00800804 	movi	r2,32
81145bbc:	e0bff9c5 	stb	r2,-25(fp)
81145bc0:	00800804 	movi	r2,32
81145bc4:	e0bffa05 	stb	r2,-24(fp)
81145bc8:	00800804 	movi	r2,32
81145bcc:	e0bffa45 	stb	r2,-23(fp)
81145bd0:	00800804 	movi	r2,32
81145bd4:	e0bffa85 	stb	r2,-22(fp)
81145bd8:	00800804 	movi	r2,32
81145bdc:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
81145be0:	00800804 	movi	r2,32
81145be4:	e0bffb05 	stb	r2,-20(fp)
81145be8:	00800804 	movi	r2,32
81145bec:	e0bffb45 	stb	r2,-19(fp)
81145bf0:	00800804 	movi	r2,32
81145bf4:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
81145bf8:	00bfffc4 	movi	r2,-1
81145bfc:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
81145c00:	e0bffd17 	ldw	r2,-12(fp)
81145c04:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
81145c08:	e13ffe17 	ldw	r4,-8(fp)
81145c0c:	1124dc80 	call	81124dc8 <strlen>
81145c10:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
81145c14:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
81145c18:	00000b06 	br	81145c48 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
81145c1c:	e0ffeb17 	ldw	r3,-84(fp)
81145c20:	e0bfea17 	ldw	r2,-88(fp)
81145c24:	1885883a 	add	r2,r3,r2
81145c28:	10800044 	addi	r2,r2,1
81145c2c:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
81145c30:	e0bfeb17 	ldw	r2,-84(fp)
81145c34:	e0fffe17 	ldw	r3,-8(fp)
81145c38:	1885883a 	add	r2,r3,r2
81145c3c:	1009883a 	mov	r4,r2
81145c40:	11452c80 	call	811452c8 <get_dir_divider_location>
81145c44:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
81145c48:	e0bfea17 	ldw	r2,-88(fp)
81145c4c:	00bff316 	blt	zero,r2,81145c1c <__reset+0xfb125c1c>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81145c50:	e0bfeb17 	ldw	r2,-84(fp)
81145c54:	e0bfee15 	stw	r2,-72(fp)
81145c58:	00002706 	br	81145cf8 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
81145c5c:	e0bfee17 	ldw	r2,-72(fp)
81145c60:	e0fffe17 	ldw	r3,-8(fp)
81145c64:	1885883a 	add	r2,r3,r2
81145c68:	10800003 	ldbu	r2,0(r2)
81145c6c:	10803fcc 	andi	r2,r2,255
81145c70:	1080201c 	xori	r2,r2,128
81145c74:	10bfe004 	addi	r2,r2,-128
81145c78:	10800b98 	cmpnei	r2,r2,46
81145c7c:	1000031e 	bne	r2,zero,81145c8c <find_file_in_directory+0x120>
        {
            ext_index = index;
81145c80:	e0bfee17 	ldw	r2,-72(fp)
81145c84:	e0bfec15 	stw	r2,-80(fp)
81145c88:	00001806 	br	81145cec <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
81145c8c:	e0bfec17 	ldw	r2,-80(fp)
81145c90:	10000b0e 	bge	r2,zero,81145cc0 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
81145c94:	e0ffee17 	ldw	r3,-72(fp)
81145c98:	e0bfeb17 	ldw	r2,-84(fp)
81145c9c:	1885c83a 	sub	r2,r3,r2
81145ca0:	e0ffee17 	ldw	r3,-72(fp)
81145ca4:	e13ffe17 	ldw	r4,-8(fp)
81145ca8:	20c7883a 	add	r3,r4,r3
81145cac:	18c00003 	ldbu	r3,0(r3)
81145cb0:	e13ff904 	addi	r4,fp,-28
81145cb4:	2085883a 	add	r2,r4,r2
81145cb8:	10c00005 	stb	r3,0(r2)
81145cbc:	00000b06 	br	81145cec <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
81145cc0:	e0ffee17 	ldw	r3,-72(fp)
81145cc4:	e0bfec17 	ldw	r2,-80(fp)
81145cc8:	1885c83a 	sub	r2,r3,r2
81145ccc:	10bfffc4 	addi	r2,r2,-1
81145cd0:	e0ffee17 	ldw	r3,-72(fp)
81145cd4:	e13ffe17 	ldw	r4,-8(fp)
81145cd8:	20c7883a 	add	r3,r4,r3
81145cdc:	18c00003 	ldbu	r3,0(r3)
81145ce0:	e13ffb04 	addi	r4,fp,-20
81145ce4:	2085883a 	add	r2,r4,r2
81145ce8:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81145cec:	e0bfee17 	ldw	r2,-72(fp)
81145cf0:	10800044 	addi	r2,r2,1
81145cf4:	e0bfee15 	stw	r2,-72(fp)
81145cf8:	e0ffee17 	ldw	r3,-72(fp)
81145cfc:	e0bff417 	ldw	r2,-48(fp)
81145d00:	18bfd616 	blt	r3,r2,81145c5c <__reset+0xfb125c5c>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
81145d04:	e0bffd17 	ldw	r2,-12(fp)
81145d08:	1000461e 	bne	r2,zero,81145e24 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81145d0c:	00a045f4 	movhi	r2,33047
81145d10:	10ba9804 	addi	r2,r2,-5536
81145d14:	1080050b 	ldhu	r2,20(r2)
81145d18:	10bfffcc 	andi	r2,r2,65535
81145d1c:	1006917a 	slli	r3,r2,5
81145d20:	00a045f4 	movhi	r2,33047
81145d24:	10ba9804 	addi	r2,r2,-5536
81145d28:	1080030b 	ldhu	r2,12(r2)
81145d2c:	10bfffcc 	andi	r2,r2,65535
81145d30:	1885283a 	div	r2,r3,r2
81145d34:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81145d38:	e03ff015 	stw	zero,-64(fp)
81145d3c:	00003506 	br	81145e14 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81145d40:	00a045f4 	movhi	r2,33047
81145d44:	10ba9804 	addi	r2,r2,-5536
81145d48:	10c01317 	ldw	r3,76(r2)
81145d4c:	e0bff017 	ldw	r2,-64(fp)
81145d50:	1885883a 	add	r2,r3,r2
81145d54:	1007883a 	mov	r3,r2
81145d58:	d0a0b117 	ldw	r2,-32060(gp)
81145d5c:	100b883a 	mov	r5,r2
81145d60:	1809883a 	mov	r4,r3
81145d64:	1143ec40 	call	81143ec4 <Read_Sector_Data>
81145d68:	10009626 	beq	r2,zero,81145fc4 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81145d6c:	e03ff115 	stw	zero,-60(fp)
81145d70:	00002006 	br	81145df4 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81145d74:	e0bff117 	ldw	r2,-60(fp)
81145d78:	1004917a 	slli	r2,r2,5
81145d7c:	e0fff017 	ldw	r3,-64(fp)
81145d80:	180f883a 	mov	r7,r3
81145d84:	000d883a 	mov	r6,zero
81145d88:	e17fff17 	ldw	r5,-4(fp)
81145d8c:	1009883a 	mov	r4,r2
81145d90:	11442f40 	call	811442f4 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81145d94:	e0bfff17 	ldw	r2,-4(fp)
81145d98:	10800003 	ldbu	r2,0(r2)
81145d9c:	10803fcc 	andi	r2,r2,255
81145da0:	10803960 	cmpeqi	r2,r2,229
81145da4:	1000101e 	bne	r2,zero,81145de8 <find_file_in_directory+0x27c>
81145da8:	e0bfff17 	ldw	r2,-4(fp)
81145dac:	10800003 	ldbu	r2,0(r2)
81145db0:	10803fcc 	andi	r2,r2,255
81145db4:	10000c26 	beq	r2,zero,81145de8 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
81145db8:	e0fffb04 	addi	r3,fp,-20
81145dbc:	e0bff904 	addi	r2,fp,-28
81145dc0:	180d883a 	mov	r6,r3
81145dc4:	100b883a 	mov	r5,r2
81145dc8:	e13fff17 	ldw	r4,-4(fp)
81145dcc:	11453880 	call	81145388 <match_file_record_to_name_ext>
81145dd0:	e0bff815 	stw	r2,-32(fp)

                        if (match)
81145dd4:	e0bff817 	ldw	r2,-32(fp)
81145dd8:	10000326 	beq	r2,zero,81145de8 <find_file_in_directory+0x27c>
                        {
                            result = true;
81145ddc:	00800044 	movi	r2,1
81145de0:	e0bfef15 	stw	r2,-68(fp)
                            break;
81145de4:	00000606 	br	81145e00 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81145de8:	e0bff117 	ldw	r2,-60(fp)
81145dec:	10800044 	addi	r2,r2,1
81145df0:	e0bff115 	stw	r2,-60(fp)
81145df4:	e0bff117 	ldw	r2,-60(fp)
81145df8:	10800410 	cmplti	r2,r2,16
81145dfc:	103fdd1e 	bne	r2,zero,81145d74 <__reset+0xfb125d74>
            }
            else
            {
                break;
            }
            if (result)
81145e00:	e0bfef17 	ldw	r2,-68(fp)
81145e04:	1000711e 	bne	r2,zero,81145fcc <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81145e08:	e0bff017 	ldw	r2,-64(fp)
81145e0c:	10800044 	addi	r2,r2,1
81145e10:	e0bff015 	stw	r2,-64(fp)
81145e14:	e0fff017 	ldw	r3,-64(fp)
81145e18:	e0bff717 	ldw	r2,-36(fp)
81145e1c:	18bfc816 	blt	r3,r2,81145d40 <__reset+0xfb125d40>
81145e20:	00006b06 	br	81145fd0 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81145e24:	e0bfed17 	ldw	r2,-76(fp)
81145e28:	10ffff84 	addi	r3,r2,-2
81145e2c:	00a045f4 	movhi	r2,33047
81145e30:	10ba9804 	addi	r2,r2,-5536
81145e34:	10800383 	ldbu	r2,14(r2)
81145e38:	10803fcc 	andi	r2,r2,255
81145e3c:	1885383a 	mul	r2,r3,r2
81145e40:	1007883a 	mov	r3,r2
81145e44:	00a045f4 	movhi	r2,33047
81145e48:	10ba9804 	addi	r2,r2,-5536
81145e4c:	10801417 	ldw	r2,80(r2)
81145e50:	1885883a 	add	r2,r3,r2
81145e54:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145e58:	e03ff215 	stw	zero,-56(fp)
81145e5c:	00003306 	br	81145f2c <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81145e60:	e0fff217 	ldw	r3,-56(fp)
81145e64:	e0bff517 	ldw	r2,-44(fp)
81145e68:	1885883a 	add	r2,r3,r2
81145e6c:	d0e0b117 	ldw	r3,-32060(gp)
81145e70:	180b883a 	mov	r5,r3
81145e74:	1009883a 	mov	r4,r2
81145e78:	1143ec40 	call	81143ec4 <Read_Sector_Data>
81145e7c:	10003226 	beq	r2,zero,81145f48 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81145e80:	e03ff315 	stw	zero,-52(fp)
81145e84:	00002106 	br	81145f0c <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81145e88:	e0bff317 	ldw	r2,-52(fp)
81145e8c:	1004917a 	slli	r2,r2,5
81145e90:	e0ffed17 	ldw	r3,-76(fp)
81145e94:	e13ff217 	ldw	r4,-56(fp)
81145e98:	200f883a 	mov	r7,r4
81145e9c:	180d883a 	mov	r6,r3
81145ea0:	e17fff17 	ldw	r5,-4(fp)
81145ea4:	1009883a 	mov	r4,r2
81145ea8:	11442f40 	call	811442f4 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81145eac:	e0bfff17 	ldw	r2,-4(fp)
81145eb0:	10800003 	ldbu	r2,0(r2)
81145eb4:	10803fcc 	andi	r2,r2,255
81145eb8:	10803960 	cmpeqi	r2,r2,229
81145ebc:	1000101e 	bne	r2,zero,81145f00 <find_file_in_directory+0x394>
81145ec0:	e0bfff17 	ldw	r2,-4(fp)
81145ec4:	10800003 	ldbu	r2,0(r2)
81145ec8:	10803fcc 	andi	r2,r2,255
81145ecc:	10000c26 	beq	r2,zero,81145f00 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81145ed0:	e0fffb04 	addi	r3,fp,-20
81145ed4:	e0bff904 	addi	r2,fp,-28
81145ed8:	180d883a 	mov	r6,r3
81145edc:	100b883a 	mov	r5,r2
81145ee0:	e13fff17 	ldw	r4,-4(fp)
81145ee4:	11453880 	call	81145388 <match_file_record_to_name_ext>
81145ee8:	e0bff615 	stw	r2,-40(fp)

                            if (match)
81145eec:	e0bff617 	ldw	r2,-40(fp)
81145ef0:	10000326 	beq	r2,zero,81145f00 <find_file_in_directory+0x394>
                            {                               
                                result = true;
81145ef4:	00800044 	movi	r2,1
81145ef8:	e0bfef15 	stw	r2,-68(fp)
                                break;
81145efc:	00000606 	br	81145f18 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81145f00:	e0bff317 	ldw	r2,-52(fp)
81145f04:	10800044 	addi	r2,r2,1
81145f08:	e0bff315 	stw	r2,-52(fp)
81145f0c:	e0bff317 	ldw	r2,-52(fp)
81145f10:	10800410 	cmplti	r2,r2,16
81145f14:	103fdc1e 	bne	r2,zero,81145e88 <__reset+0xfb125e88>
                }
                else
                {
                    break;
                }
                if (result)
81145f18:	e0bfef17 	ldw	r2,-68(fp)
81145f1c:	10000c1e 	bne	r2,zero,81145f50 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145f20:	e0bff217 	ldw	r2,-56(fp)
81145f24:	10800044 	addi	r2,r2,1
81145f28:	e0bff215 	stw	r2,-56(fp)
81145f2c:	00a045f4 	movhi	r2,33047
81145f30:	10ba9804 	addi	r2,r2,-5536
81145f34:	10800383 	ldbu	r2,14(r2)
81145f38:	10803fcc 	andi	r2,r2,255
81145f3c:	e0fff217 	ldw	r3,-56(fp)
81145f40:	18bfc716 	blt	r3,r2,81145e60 <__reset+0xfb125e60>
81145f44:	00000306 	br	81145f54 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
81145f48:	0001883a 	nop
81145f4c:	00000106 	br	81145f54 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
81145f50:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
81145f54:	e0bfef17 	ldw	r2,-68(fp)
81145f58:	1000141e 	bne	r2,zero,81145fac <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
81145f5c:	e0bfed17 	ldw	r2,-76(fp)
81145f60:	e0fffc04 	addi	r3,fp,-16
81145f64:	180b883a 	mov	r5,r3
81145f68:	1009883a 	mov	r4,r2
81145f6c:	1143fa40 	call	81143fa4 <get_cluster_flag>
81145f70:	10000c26 	beq	r2,zero,81145fa4 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81145f74:	e0bffc0b 	ldhu	r2,-16(fp)
81145f78:	10bfffcc 	andi	r2,r2,65535
81145f7c:	10fffe0c 	andi	r3,r2,65528
81145f80:	00bffe14 	movui	r2,65528
81145f84:	1880021e 	bne	r3,r2,81145f90 <find_file_in_directory+0x424>
					{
						return false;
81145f88:	0005883a 	mov	r2,zero
81145f8c:	00001106 	br	81145fd4 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
81145f90:	e0bffc0b 	ldhu	r2,-16(fp)
81145f94:	10bfffcc 	andi	r2,r2,65535
81145f98:	10bffe0c 	andi	r2,r2,65528
81145f9c:	e0bfed15 	stw	r2,-76(fp)
81145fa0:	00000206 	br	81145fac <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
81145fa4:	0005883a 	mov	r2,zero
81145fa8:	00000a06 	br	81145fd4 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
81145fac:	e0bfed17 	ldw	r2,-76(fp)
81145fb0:	00fffdd4 	movui	r3,65527
81145fb4:	18800616 	blt	r3,r2,81145fd0 <find_file_in_directory+0x464>
81145fb8:	e0bfef17 	ldw	r2,-68(fp)
81145fbc:	103f9926 	beq	r2,zero,81145e24 <__reset+0xfb125e24>
81145fc0:	00000306 	br	81145fd0 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
81145fc4:	0001883a 	nop
81145fc8:	00000106 	br	81145fd0 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
81145fcc:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
81145fd0:	e0bfef17 	ldw	r2,-68(fp)
}
81145fd4:	e037883a 	mov	sp,fp
81145fd8:	dfc00117 	ldw	ra,4(sp)
81145fdc:	df000017 	ldw	fp,0(sp)
81145fe0:	dec00204 	addi	sp,sp,8
81145fe4:	f800283a 	ret

81145fe8 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
81145fe8:	defff504 	addi	sp,sp,-44
81145fec:	de00012e 	bgeu	sp,et,81145ff4 <find_first_empty_cluster+0xc>
81145ff0:	003b68fa 	trap	3
81145ff4:	dfc00a15 	stw	ra,40(sp)
81145ff8:	df000915 	stw	fp,36(sp)
81145ffc:	df000904 	addi	fp,sp,36
81146000:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
81146004:	00a045f4 	movhi	r2,33047
81146008:	10ba9804 	addi	r2,r2,-5536
8114600c:	10801117 	ldw	r2,68(r2)
81146010:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
81146014:	00800084 	movi	r2,2
81146018:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
8114601c:	00bfffc4 	movi	r2,-1
81146020:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
81146024:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
81146028:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
8114602c:	00a045f4 	movhi	r2,33047
81146030:	10ba9804 	addi	r2,r2,-5536
81146034:	10801417 	ldw	r2,80(r2)
81146038:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
8114603c:	00a045f4 	movhi	r2,33047
81146040:	10ba9804 	addi	r2,r2,-5536
81146044:	1080058b 	ldhu	r2,22(r2)
81146048:	10bfffcc 	andi	r2,r2,65535
8114604c:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
81146050:	00a045f4 	movhi	r2,33047
81146054:	10ba9804 	addi	r2,r2,-5536
81146058:	10800917 	ldw	r2,36(r2)
8114605c:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
81146060:	e0bffd17 	ldw	r2,-12(fp)
81146064:	e0fffe17 	ldw	r3,-8(fp)
81146068:	18800b2e 	bgeu	r3,r2,81146098 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8114606c:	e0fffd17 	ldw	r3,-12(fp)
81146070:	e0bffc17 	ldw	r2,-16(fp)
81146074:	1887c83a 	sub	r3,r3,r2
81146078:	00a045f4 	movhi	r2,33047
8114607c:	10ba9804 	addi	r2,r2,-5536
81146080:	10800383 	ldbu	r2,14(r2)
81146084:	10803fcc 	andi	r2,r2,255
81146088:	1885203a 	divu	r2,r3,r2
8114608c:	10800044 	addi	r2,r2,1
81146090:	e0bffb15 	stw	r2,-20(fp)
81146094:	00002a06 	br	81146140 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81146098:	e0fffe17 	ldw	r3,-8(fp)
8114609c:	e0bffc17 	ldw	r2,-16(fp)
811460a0:	1887c83a 	sub	r3,r3,r2
811460a4:	00a045f4 	movhi	r2,33047
811460a8:	10ba9804 	addi	r2,r2,-5536
811460ac:	10800383 	ldbu	r2,14(r2)
811460b0:	10803fcc 	andi	r2,r2,255
811460b4:	1885203a 	divu	r2,r3,r2
811460b8:	10800044 	addi	r2,r2,1
811460bc:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
811460c0:	00001f06 	br	81146140 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
811460c4:	e0bff717 	ldw	r2,-36(fp)
811460c8:	d0e0b117 	ldw	r3,-32060(gp)
811460cc:	180b883a 	mov	r5,r3
811460d0:	1009883a 	mov	r4,r2
811460d4:	1143ec40 	call	81143ec4 <Read_Sector_Data>
811460d8:	10001426 	beq	r2,zero,8114612c <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
811460dc:	e0bff817 	ldw	r2,-32(fp)
811460e0:	10803fcc 	andi	r2,r2,255
811460e4:	1085883a 	add	r2,r2,r2
811460e8:	1007883a 	mov	r3,r2
811460ec:	d0a0b317 	ldw	r2,-32052(gp)
811460f0:	10800a17 	ldw	r2,40(r2)
811460f4:	1885883a 	add	r2,r3,r2
811460f8:	1080002b 	ldhuio	r2,0(r2)
811460fc:	10bfffcc 	andi	r2,r2,65535
81146100:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
81146104:	e0bff90f 	ldh	r2,-28(fp)
81146108:	10000726 	beq	r2,zero,81146128 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
8114610c:	e0bff817 	ldw	r2,-32(fp)
81146110:	10800044 	addi	r2,r2,1
81146114:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
81146118:	e0bff817 	ldw	r2,-32(fp)
8114611c:	10803fcc 	andi	r2,r2,255
81146120:	103fee1e 	bne	r2,zero,811460dc <__reset+0xfb1260dc>
81146124:	00000106 	br	8114612c <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
81146128:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
8114612c:	e0bff90f 	ldh	r2,-28(fp)
81146130:	10000926 	beq	r2,zero,81146158 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
81146134:	e0bff717 	ldw	r2,-36(fp)
81146138:	10800044 	addi	r2,r2,1
8114613c:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81146140:	00a045f4 	movhi	r2,33047
81146144:	10ba9804 	addi	r2,r2,-5536
81146148:	10c01217 	ldw	r3,72(r2)
8114614c:	e0bff717 	ldw	r2,-36(fp)
81146150:	18bfdc1e 	bne	r3,r2,811460c4 <__reset+0xfb1260c4>
81146154:	00000106 	br	8114615c <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
81146158:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
8114615c:	e0bff90f 	ldh	r2,-28(fp)
81146160:	1000081e 	bne	r2,zero,81146184 <find_first_empty_cluster+0x19c>
81146164:	e0bff90f 	ldh	r2,-28(fp)
81146168:	e0fffb17 	ldw	r3,-20(fp)
8114616c:	18800536 	bltu	r3,r2,81146184 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
81146170:	e0bfff17 	ldw	r2,-4(fp)
81146174:	e0fff817 	ldw	r3,-32(fp)
81146178:	10c00015 	stw	r3,0(r2)
		result = true;
8114617c:	00800044 	movi	r2,1
81146180:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
81146184:	e0bffa17 	ldw	r2,-24(fp)
}
81146188:	e037883a 	mov	sp,fp
8114618c:	dfc00117 	ldw	ra,4(sp)
81146190:	df000017 	ldw	fp,0(sp)
81146194:	dec00204 	addi	sp,sp,8
81146198:	f800283a 	ret

8114619c <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
8114619c:	defff604 	addi	sp,sp,-40
811461a0:	de00012e 	bgeu	sp,et,811461a8 <find_first_empty_record_in_a_subdirectory+0xc>
811461a4:	003b68fa 	trap	3
811461a8:	dfc00915 	stw	ra,36(sp)
811461ac:	df000815 	stw	fp,32(sp)
811461b0:	df000804 	addi	fp,sp,32
811461b4:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
811461b8:	00bfffc4 	movi	r2,-1
811461bc:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
811461c0:	e0bfff17 	ldw	r2,-4(fp)
811461c4:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811461c8:	e0bff917 	ldw	r2,-28(fp)
811461cc:	10ffff84 	addi	r3,r2,-2
811461d0:	00a045f4 	movhi	r2,33047
811461d4:	10ba9804 	addi	r2,r2,-5536
811461d8:	10800383 	ldbu	r2,14(r2)
811461dc:	10803fcc 	andi	r2,r2,255
811461e0:	1885383a 	mul	r2,r3,r2
811461e4:	1007883a 	mov	r3,r2
811461e8:	00a045f4 	movhi	r2,33047
811461ec:	10ba9804 	addi	r2,r2,-5536
811461f0:	10801417 	ldw	r2,80(r2)
811461f4:	1885883a 	add	r2,r3,r2
811461f8:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811461fc:	e03ffa15 	stw	zero,-24(fp)
81146200:	00002c06 	br	811462b4 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81146204:	e0fffa17 	ldw	r3,-24(fp)
81146208:	e0bffc17 	ldw	r2,-16(fp)
8114620c:	1885883a 	add	r2,r3,r2
81146210:	d0e0b117 	ldw	r3,-32060(gp)
81146214:	180b883a 	mov	r5,r3
81146218:	1009883a 	mov	r4,r2
8114621c:	1143ec40 	call	81143ec4 <Read_Sector_Data>
81146220:	10002b26 	beq	r2,zero,811462d0 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81146224:	e03ffb15 	stw	zero,-20(fp)
81146228:	00001c06 	br	8114629c <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8114622c:	e0bffb17 	ldw	r2,-20(fp)
81146230:	1004917a 	slli	r2,r2,5
81146234:	1007883a 	mov	r3,r2
81146238:	d0a0b317 	ldw	r2,-32052(gp)
8114623c:	10800a17 	ldw	r2,40(r2)
81146240:	1885883a 	add	r2,r3,r2
81146244:	10800023 	ldbuio	r2,0(r2)
81146248:	10803fcc 	andi	r2,r2,255
8114624c:	10803fcc 	andi	r2,r2,255
81146250:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
81146254:	e0bffd0b 	ldhu	r2,-12(fp)
81146258:	10803960 	cmpeqi	r2,r2,229
8114625c:	1000021e 	bne	r2,zero,81146268 <find_first_empty_record_in_a_subdirectory+0xcc>
81146260:	e0bffd0b 	ldhu	r2,-12(fp)
81146264:	10000a1e 	bne	r2,zero,81146290 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
81146268:	e0bffa17 	ldw	r2,-24(fp)
8114626c:	1006913a 	slli	r3,r2,4
81146270:	e0bffb17 	ldw	r2,-20(fp)
81146274:	1885883a 	add	r2,r3,r2
81146278:	1006943a 	slli	r3,r2,16
8114627c:	e0bff917 	ldw	r2,-28(fp)
81146280:	1884b03a 	or	r2,r3,r2
81146284:	e0bff815 	stw	r2,-32(fp)
                        return result;
81146288:	e0bff817 	ldw	r2,-32(fp)
8114628c:	00005306 	br	811463dc <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81146290:	e0bffb17 	ldw	r2,-20(fp)
81146294:	10800044 	addi	r2,r2,1
81146298:	e0bffb15 	stw	r2,-20(fp)
8114629c:	e0bffb17 	ldw	r2,-20(fp)
811462a0:	10800410 	cmplti	r2,r2,16
811462a4:	103fe11e 	bne	r2,zero,8114622c <__reset+0xfb12622c>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811462a8:	e0bffa17 	ldw	r2,-24(fp)
811462ac:	10800044 	addi	r2,r2,1
811462b0:	e0bffa15 	stw	r2,-24(fp)
811462b4:	00a045f4 	movhi	r2,33047
811462b8:	10ba9804 	addi	r2,r2,-5536
811462bc:	10800383 	ldbu	r2,14(r2)
811462c0:	10803fcc 	andi	r2,r2,255
811462c4:	e0fffa17 	ldw	r3,-24(fp)
811462c8:	18bfce16 	blt	r3,r2,81146204 <__reset+0xfb126204>
811462cc:	00000106 	br	811462d4 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
811462d0:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
811462d4:	e0bff817 	ldw	r2,-32(fp)
811462d8:	1000390e 	bge	r2,zero,811463c0 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
811462dc:	e0bff917 	ldw	r2,-28(fp)
811462e0:	e0fffd84 	addi	r3,fp,-10
811462e4:	180b883a 	mov	r5,r3
811462e8:	1009883a 	mov	r4,r2
811462ec:	1143fa40 	call	81143fa4 <get_cluster_flag>
811462f0:	10003126 	beq	r2,zero,811463b8 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
811462f4:	e0bffd8b 	ldhu	r2,-10(fp)
811462f8:	10bfffcc 	andi	r2,r2,65535
811462fc:	10fffe0c 	andi	r3,r2,65528
81146300:	00bffe14 	movui	r2,65528
81146304:	18802e1e 	bne	r3,r2,811463c0 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
81146308:	e0bffe04 	addi	r2,fp,-8
8114630c:	1009883a 	mov	r4,r2
81146310:	1145fe80 	call	81145fe8 <find_first_empty_cluster>
81146314:	10002326 	beq	r2,zero,811463a4 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81146318:	e0bff917 	ldw	r2,-28(fp)
8114631c:	e0fffe17 	ldw	r3,-8(fp)
81146320:	18ffffcc 	andi	r3,r3,65535
81146324:	18e0001c 	xori	r3,r3,32768
81146328:	18e00004 	addi	r3,r3,-32768
8114632c:	01800044 	movi	r6,1
81146330:	180b883a 	mov	r5,r3
81146334:	1009883a 	mov	r4,r2
81146338:	11440600 	call	81144060 <mark_cluster>
8114633c:	10001926 	beq	r2,zero,811463a4 <find_first_empty_record_in_a_subdirectory+0x208>
81146340:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81146344:	01800044 	movi	r6,1
81146348:	017fffc4 	movi	r5,-1
8114634c:	1009883a 	mov	r4,r2
81146350:	11440600 	call	81144060 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81146354:	10001326 	beq	r2,zero,811463a4 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81146358:	e0bff917 	ldw	r2,-28(fp)
8114635c:	e0fffe17 	ldw	r3,-8(fp)
81146360:	18ffffcc 	andi	r3,r3,65535
81146364:	18e0001c 	xori	r3,r3,32768
81146368:	18e00004 	addi	r3,r3,-32768
8114636c:	000d883a 	mov	r6,zero
81146370:	180b883a 	mov	r5,r3
81146374:	1009883a 	mov	r4,r2
81146378:	11440600 	call	81144060 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8114637c:	10000926 	beq	r2,zero,811463a4 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81146380:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
81146384:	000d883a 	mov	r6,zero
81146388:	017fffc4 	movi	r5,-1
8114638c:	1009883a 	mov	r4,r2
81146390:	11440600 	call	81144060 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81146394:	10000326 	beq	r2,zero,811463a4 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
81146398:	1143e700 	call	81143e70 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
8114639c:	e0bffe17 	ldw	r2,-8(fp)
811463a0:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
811463a4:	e0bffd8b 	ldhu	r2,-10(fp)
811463a8:	10bfffcc 	andi	r2,r2,65535
811463ac:	10bffe0c 	andi	r2,r2,65528
811463b0:	e0bff915 	stw	r2,-28(fp)
811463b4:	00000206 	br	811463c0 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
811463b8:	00bfffc4 	movi	r2,-1
811463bc:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
811463c0:	e0bff917 	ldw	r2,-28(fp)
811463c4:	00fffdd4 	movui	r3,65527
811463c8:	18800316 	blt	r3,r2,811463d8 <find_first_empty_record_in_a_subdirectory+0x23c>
811463cc:	e0bff817 	ldw	r2,-32(fp)
811463d0:	10bfffe0 	cmpeqi	r2,r2,-1
811463d4:	103f7c1e 	bne	r2,zero,811461c8 <__reset+0xfb1261c8>
    return result; 
811463d8:	e0bff817 	ldw	r2,-32(fp)
}
811463dc:	e037883a 	mov	sp,fp
811463e0:	dfc00117 	ldw	ra,4(sp)
811463e4:	df000017 	ldw	fp,0(sp)
811463e8:	dec00204 	addi	sp,sp,8
811463ec:	f800283a 	ret

811463f0 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
811463f0:	defff904 	addi	sp,sp,-28
811463f4:	de00012e 	bgeu	sp,et,811463fc <find_first_empty_record_in_root_directory+0xc>
811463f8:	003b68fa 	trap	3
811463fc:	dfc00615 	stw	ra,24(sp)
81146400:	df000515 	stw	fp,20(sp)
81146404:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81146408:	00a045f4 	movhi	r2,33047
8114640c:	10ba9804 	addi	r2,r2,-5536
81146410:	1080050b 	ldhu	r2,20(r2)
81146414:	10bfffcc 	andi	r2,r2,65535
81146418:	1006917a 	slli	r3,r2,5
8114641c:	00a045f4 	movhi	r2,33047
81146420:	10ba9804 	addi	r2,r2,-5536
81146424:	1080030b 	ldhu	r2,12(r2)
81146428:	10bfffcc 	andi	r2,r2,65535
8114642c:	1885283a 	div	r2,r3,r2
81146430:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
81146434:	00bfffc4 	movi	r2,-1
81146438:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8114643c:	e03ffb15 	stw	zero,-20(fp)
81146440:	00002d06 	br	811464f8 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81146444:	00a045f4 	movhi	r2,33047
81146448:	10ba9804 	addi	r2,r2,-5536
8114644c:	10c01317 	ldw	r3,76(r2)
81146450:	e0bffb17 	ldw	r2,-20(fp)
81146454:	1885883a 	add	r2,r3,r2
81146458:	1007883a 	mov	r3,r2
8114645c:	d0a0b117 	ldw	r2,-32060(gp)
81146460:	100b883a 	mov	r5,r2
81146464:	1809883a 	mov	r4,r3
81146468:	1143ec40 	call	81143ec4 <Read_Sector_Data>
8114646c:	10002626 	beq	r2,zero,81146508 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81146470:	e03ffc15 	stw	zero,-16(fp)
81146474:	00001a06 	br	811464e0 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
81146478:	e0bffc17 	ldw	r2,-16(fp)
8114647c:	1004917a 	slli	r2,r2,5
81146480:	1007883a 	mov	r3,r2
81146484:	d0a0b317 	ldw	r2,-32052(gp)
81146488:	10800a17 	ldw	r2,40(r2)
8114648c:	1885883a 	add	r2,r3,r2
81146490:	10800023 	ldbuio	r2,0(r2)
81146494:	10803fcc 	andi	r2,r2,255
81146498:	10803fcc 	andi	r2,r2,255
8114649c:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
811464a0:	e0bfff0b 	ldhu	r2,-4(fp)
811464a4:	10803960 	cmpeqi	r2,r2,229
811464a8:	1000021e 	bne	r2,zero,811464b4 <find_first_empty_record_in_root_directory+0xc4>
811464ac:	e0bfff0b 	ldhu	r2,-4(fp)
811464b0:	1000081e 	bne	r2,zero,811464d4 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
811464b4:	e0bffb17 	ldw	r2,-20(fp)
811464b8:	1006913a 	slli	r3,r2,4
811464bc:	e0bffc17 	ldw	r2,-16(fp)
811464c0:	1885883a 	add	r2,r3,r2
811464c4:	1004943a 	slli	r2,r2,16
811464c8:	e0bffe15 	stw	r2,-8(fp)
                    return result;
811464cc:	e0bffe17 	ldw	r2,-8(fp)
811464d0:	00000f06 	br	81146510 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
811464d4:	e0bffc17 	ldw	r2,-16(fp)
811464d8:	10800044 	addi	r2,r2,1
811464dc:	e0bffc15 	stw	r2,-16(fp)
811464e0:	e0bffc17 	ldw	r2,-16(fp)
811464e4:	10800410 	cmplti	r2,r2,16
811464e8:	103fe31e 	bne	r2,zero,81146478 <__reset+0xfb126478>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811464ec:	e0bffb17 	ldw	r2,-20(fp)
811464f0:	10800044 	addi	r2,r2,1
811464f4:	e0bffb15 	stw	r2,-20(fp)
811464f8:	e0fffb17 	ldw	r3,-20(fp)
811464fc:	e0bffd17 	ldw	r2,-12(fp)
81146500:	18bfd016 	blt	r3,r2,81146444 <__reset+0xfb126444>
81146504:	00000106 	br	8114650c <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
81146508:	0001883a 	nop
        }
    }
    return result;
8114650c:	e0bffe17 	ldw	r2,-8(fp)
}
81146510:	e037883a 	mov	sp,fp
81146514:	dfc00117 	ldw	ra,4(sp)
81146518:	df000017 	ldw	fp,0(sp)
8114651c:	dec00204 	addi	sp,sp,8
81146520:	f800283a 	ret

81146524 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
81146524:	defffa04 	addi	sp,sp,-24
81146528:	de00012e 	bgeu	sp,et,81146530 <convert_filename_to_name_extension+0xc>
8114652c:	003b68fa 	trap	3
81146530:	df000515 	stw	fp,20(sp)
81146534:	df000504 	addi	fp,sp,20
81146538:	e13ffd15 	stw	r4,-12(fp)
8114653c:	e17ffe15 	stw	r5,-8(fp)
81146540:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
81146544:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
81146548:	e03ffb15 	stw	zero,-20(fp)
8114654c:	00002506 	br	811465e4 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
81146550:	e0bffc17 	ldw	r2,-16(fp)
81146554:	e0fffd17 	ldw	r3,-12(fp)
81146558:	1885883a 	add	r2,r3,r2
8114655c:	10800003 	ldbu	r2,0(r2)
81146560:	10803fcc 	andi	r2,r2,255
81146564:	1080201c 	xori	r2,r2,128
81146568:	10bfe004 	addi	r2,r2,-128
8114656c:	10800ba0 	cmpeqi	r2,r2,46
81146570:	1000141e 	bne	r2,zero,811465c4 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
81146574:	e0bffb17 	ldw	r2,-20(fp)
81146578:	e0fffe17 	ldw	r3,-8(fp)
8114657c:	1885883a 	add	r2,r3,r2
81146580:	e0fffc17 	ldw	r3,-16(fp)
81146584:	e13ffd17 	ldw	r4,-12(fp)
81146588:	20c7883a 	add	r3,r4,r3
8114658c:	18c00003 	ldbu	r3,0(r3)
81146590:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
81146594:	e0bffc17 	ldw	r2,-16(fp)
81146598:	e0fffd17 	ldw	r3,-12(fp)
8114659c:	1885883a 	add	r2,r3,r2
811465a0:	10800003 	ldbu	r2,0(r2)
811465a4:	10803fcc 	andi	r2,r2,255
811465a8:	1080201c 	xori	r2,r2,128
811465ac:	10bfe004 	addi	r2,r2,-128
811465b0:	10000926 	beq	r2,zero,811465d8 <convert_filename_to_name_extension+0xb4>
811465b4:	e0bffc17 	ldw	r2,-16(fp)
811465b8:	10800044 	addi	r2,r2,1
811465bc:	e0bffc15 	stw	r2,-16(fp)
811465c0:	00000506 	br	811465d8 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
811465c4:	e0bffb17 	ldw	r2,-20(fp)
811465c8:	e0fffe17 	ldw	r3,-8(fp)
811465cc:	1885883a 	add	r2,r3,r2
811465d0:	00c00804 	movi	r3,32
811465d4:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
811465d8:	e0bffb17 	ldw	r2,-20(fp)
811465dc:	10800044 	addi	r2,r2,1
811465e0:	e0bffb15 	stw	r2,-20(fp)
811465e4:	e0bffb17 	ldw	r2,-20(fp)
811465e8:	10800210 	cmplti	r2,r2,8
811465ec:	103fd81e 	bne	r2,zero,81146550 <__reset+0xfb126550>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
811465f0:	e0bffc17 	ldw	r2,-16(fp)
811465f4:	e0fffd17 	ldw	r3,-12(fp)
811465f8:	1885883a 	add	r2,r3,r2
811465fc:	10800003 	ldbu	r2,0(r2)
81146600:	10803fcc 	andi	r2,r2,255
81146604:	1080201c 	xori	r2,r2,128
81146608:	10bfe004 	addi	r2,r2,-128
8114660c:	10800b98 	cmpnei	r2,r2,46
81146610:	1000031e 	bne	r2,zero,81146620 <convert_filename_to_name_extension+0xfc>
81146614:	e0bffc17 	ldw	r2,-16(fp)
81146618:	10800044 	addi	r2,r2,1
8114661c:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
81146620:	e03ffb15 	stw	zero,-20(fp)
81146624:	00001c06 	br	81146698 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
81146628:	e0bffc17 	ldw	r2,-16(fp)
8114662c:	e0fffd17 	ldw	r3,-12(fp)
81146630:	1885883a 	add	r2,r3,r2
81146634:	10800003 	ldbu	r2,0(r2)
81146638:	10803fcc 	andi	r2,r2,255
8114663c:	1080201c 	xori	r2,r2,128
81146640:	10bfe004 	addi	r2,r2,-128
81146644:	10000c26 	beq	r2,zero,81146678 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
81146648:	e0bffb17 	ldw	r2,-20(fp)
8114664c:	e0ffff17 	ldw	r3,-4(fp)
81146650:	1885883a 	add	r2,r3,r2
81146654:	e0fffc17 	ldw	r3,-16(fp)
81146658:	e13ffd17 	ldw	r4,-12(fp)
8114665c:	20c7883a 	add	r3,r4,r3
81146660:	18c00003 	ldbu	r3,0(r3)
81146664:	10c00005 	stb	r3,0(r2)
            local++;
81146668:	e0bffc17 	ldw	r2,-16(fp)
8114666c:	10800044 	addi	r2,r2,1
81146670:	e0bffc15 	stw	r2,-16(fp)
81146674:	00000506 	br	8114668c <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
81146678:	e0bffb17 	ldw	r2,-20(fp)
8114667c:	e0ffff17 	ldw	r3,-4(fp)
81146680:	1885883a 	add	r2,r3,r2
81146684:	00c00804 	movi	r3,32
81146688:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
8114668c:	e0bffb17 	ldw	r2,-20(fp)
81146690:	10800044 	addi	r2,r2,1
81146694:	e0bffb15 	stw	r2,-20(fp)
81146698:	e0bffb17 	ldw	r2,-20(fp)
8114669c:	108000d0 	cmplti	r2,r2,3
811466a0:	103fe11e 	bne	r2,zero,81146628 <__reset+0xfb126628>
        {
            extension[counter] = ' ';
        }
    }

}
811466a4:	0001883a 	nop
811466a8:	e037883a 	mov	sp,fp
811466ac:	df000017 	ldw	fp,0(sp)
811466b0:	dec00104 	addi	sp,sp,4
811466b4:	f800283a 	ret

811466b8 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
811466b8:	defff504 	addi	sp,sp,-44
811466bc:	de00012e 	bgeu	sp,et,811466c4 <create_file+0xc>
811466c0:	003b68fa 	trap	3
811466c4:	dfc00a15 	stw	ra,40(sp)
811466c8:	df000915 	stw	fp,36(sp)
811466cc:	df000904 	addi	fp,sp,36
811466d0:	e13ffd15 	stw	r4,-12(fp)
811466d4:	e17ffe15 	stw	r5,-8(fp)
811466d8:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
811466dc:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
811466e0:	e0bffc04 	addi	r2,fp,-16
811466e4:	1009883a 	mov	r4,r2
811466e8:	1145fe80 	call	81145fe8 <find_first_empty_cluster>
811466ec:	1000a026 	beq	r2,zero,81146970 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
811466f0:	e0bfff17 	ldw	r2,-4(fp)
811466f4:	10800a17 	ldw	r2,40(r2)
811466f8:	1000031e 	bne	r2,zero,81146708 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
811466fc:	11463f00 	call	811463f0 <find_first_empty_record_in_root_directory>
81146700:	e0bff815 	stw	r2,-32(fp)
81146704:	00000606 	br	81146720 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
81146708:	e0bfff17 	ldw	r2,-4(fp)
8114670c:	1080058b 	ldhu	r2,22(r2)
81146710:	10bfffcc 	andi	r2,r2,65535
81146714:	1009883a 	mov	r4,r2
81146718:	114619c0 	call	8114619c <find_first_empty_record_in_a_subdirectory>
8114671c:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
81146720:	e0bff817 	ldw	r2,-32(fp)
81146724:	10009216 	blt	r2,zero,81146970 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
81146728:	e13ffd17 	ldw	r4,-12(fp)
8114672c:	11452c80 	call	811452c8 <get_dir_divider_location>
81146730:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
81146734:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
81146738:	00000b06 	br	81146768 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
8114673c:	e0fffa17 	ldw	r3,-24(fp)
81146740:	e0bff917 	ldw	r2,-28(fp)
81146744:	1885883a 	add	r2,r3,r2
81146748:	10800044 	addi	r2,r2,1
8114674c:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
81146750:	e0bffa17 	ldw	r2,-24(fp)
81146754:	e0fffd17 	ldw	r3,-12(fp)
81146758:	1885883a 	add	r2,r3,r2
8114675c:	1009883a 	mov	r4,r2
81146760:	11452c80 	call	811452c8 <get_dir_divider_location>
81146764:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
81146768:	e0bff917 	ldw	r2,-28(fp)
8114676c:	00bff316 	blt	zero,r2,8114673c <__reset+0xfb12673c>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
81146770:	e0bffa17 	ldw	r2,-24(fp)
81146774:	e0fffd17 	ldw	r3,-12(fp)
81146778:	1887883a 	add	r3,r3,r2
8114677c:	e13ffe17 	ldw	r4,-8(fp)
81146780:	e0bffe17 	ldw	r2,-8(fp)
81146784:	10800204 	addi	r2,r2,8
81146788:	100d883a 	mov	r6,r2
8114678c:	200b883a 	mov	r5,r4
81146790:	1809883a 	mov	r4,r3
81146794:	11465240 	call	81146524 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
81146798:	e0bffe17 	ldw	r2,-8(fp)
8114679c:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
811467a0:	e0bffe17 	ldw	r2,-8(fp)
811467a4:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
811467a8:	e0bffe17 	ldw	r2,-8(fp)
811467ac:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
811467b0:	e0bffe17 	ldw	r2,-8(fp)
811467b4:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
811467b8:	e0bffe17 	ldw	r2,-8(fp)
811467bc:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
811467c0:	e0bffe17 	ldw	r2,-8(fp)
811467c4:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
811467c8:	e0bffc17 	ldw	r2,-16(fp)
811467cc:	1007883a 	mov	r3,r2
811467d0:	e0bffe17 	ldw	r2,-8(fp)
811467d4:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
811467d8:	e0bffe17 	ldw	r2,-8(fp)
811467dc:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
811467e0:	e0fffc17 	ldw	r3,-16(fp)
811467e4:	e0bffe17 	ldw	r2,-8(fp)
811467e8:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
811467ec:	e0bffe17 	ldw	r2,-8(fp)
811467f0:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
811467f4:	e0bffe17 	ldw	r2,-8(fp)
811467f8:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
811467fc:	e0bff817 	ldw	r2,-32(fp)
81146800:	10ffffcc 	andi	r3,r2,65535
81146804:	e0bffe17 	ldw	r2,-8(fp)
81146808:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
8114680c:	e0bff817 	ldw	r2,-32(fp)
81146810:	1004d43a 	srli	r2,r2,16
81146814:	1000010e 	bge	r2,zero,8114681c <create_file+0x164>
81146818:	108003c4 	addi	r2,r2,15
8114681c:	1005d13a 	srai	r2,r2,4
81146820:	1007883a 	mov	r3,r2
81146824:	e0bffe17 	ldw	r2,-8(fp)
81146828:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
8114682c:	e0bff817 	ldw	r2,-32(fp)
81146830:	1004d43a 	srli	r2,r2,16
81146834:	1007883a 	mov	r3,r2
81146838:	00a00034 	movhi	r2,32768
8114683c:	108003c4 	addi	r2,r2,15
81146840:	1884703a 	and	r2,r3,r2
81146844:	1000040e 	bge	r2,zero,81146858 <create_file+0x1a0>
81146848:	10bfffc4 	addi	r2,r2,-1
8114684c:	00fffc04 	movi	r3,-16
81146850:	10c4b03a 	or	r2,r2,r3
81146854:	10800044 	addi	r2,r2,1
81146858:	1004917a 	slli	r2,r2,5
8114685c:	1007883a 	mov	r3,r2
81146860:	e0bffe17 	ldw	r2,-8(fp)
81146864:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
81146868:	e0bfff17 	ldw	r2,-4(fp)
8114686c:	1080058b 	ldhu	r2,22(r2)
81146870:	10ffffcc 	andi	r3,r2,65535
81146874:	e0bffe17 	ldw	r2,-8(fp)
81146878:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
8114687c:	e0bffe17 	ldw	r2,-8(fp)
81146880:	00c00044 	movi	r3,1
81146884:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
81146888:	e0bffe17 	ldw	r2,-8(fp)
8114688c:	00c00044 	movi	r3,1
81146890:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81146894:	e0bffe17 	ldw	r2,-8(fp)
81146898:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
8114689c:	1000071e 	bne	r2,zero,811468bc <create_file+0x204>
811468a0:	00a045f4 	movhi	r2,33047
811468a4:	10ba9804 	addi	r2,r2,-5536
811468a8:	10c01317 	ldw	r3,76(r2)
811468ac:	e0bffe17 	ldw	r2,-8(fp)
811468b0:	10800b17 	ldw	r2,44(r2)
811468b4:	1885883a 	add	r2,r3,r2
811468b8:	00000f06 	br	811468f8 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
811468bc:	00a045f4 	movhi	r2,33047
811468c0:	10ba9804 	addi	r2,r2,-5536
811468c4:	10c01417 	ldw	r3,80(r2)
811468c8:	e0bffe17 	ldw	r2,-8(fp)
811468cc:	10800a17 	ldw	r2,40(r2)
811468d0:	113fff84 	addi	r4,r2,-2
811468d4:	00a045f4 	movhi	r2,33047
811468d8:	10ba9804 	addi	r2,r2,-5536
811468dc:	10800383 	ldbu	r2,14(r2)
811468e0:	10803fcc 	andi	r2,r2,255
811468e4:	2085383a 	mul	r2,r4,r2
811468e8:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
811468ec:	e0bffe17 	ldw	r2,-8(fp)
811468f0:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
811468f4:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
811468f8:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
811468fc:	e0bffb17 	ldw	r2,-20(fp)
81146900:	d0e0b117 	ldw	r3,-32060(gp)
81146904:	180b883a 	mov	r5,r3
81146908:	1009883a 	mov	r4,r2
8114690c:	1143ec40 	call	81143ec4 <Read_Sector_Data>
81146910:	10001726 	beq	r2,zero,81146970 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
81146914:	e0bffe17 	ldw	r2,-8(fp)
81146918:	10800c0b 	ldhu	r2,48(r2)
8114691c:	10bfffcc 	andi	r2,r2,65535
81146920:	10a0001c 	xori	r2,r2,32768
81146924:	10a00004 	addi	r2,r2,-32768
81146928:	e17ffe17 	ldw	r5,-8(fp)
8114692c:	1009883a 	mov	r4,r2
81146930:	11445780 	call	81144578 <Write_File_Record_At_Offset>
81146934:	10000e26 	beq	r2,zero,81146970 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
81146938:	1143e700 	call	81143e70 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
8114693c:	e0bffc17 	ldw	r2,-16(fp)
81146940:	01800044 	movi	r6,1
81146944:	017fffc4 	movi	r5,-1
81146948:	1009883a 	mov	r4,r2
8114694c:	11440600 	call	81144060 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
81146950:	e0bffc17 	ldw	r2,-16(fp)
81146954:	000d883a 	mov	r6,zero
81146958:	017fffc4 	movi	r5,-1
8114695c:	1009883a 	mov	r4,r2
81146960:	11440600 	call	81144060 <mark_cluster>
81146964:	10000226 	beq	r2,zero,81146970 <create_file+0x2b8>
                    {
                        result = true;
81146968:	00800044 	movi	r2,1
8114696c:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
81146970:	e0bff717 	ldw	r2,-36(fp)
}
81146974:	e037883a 	mov	sp,fp
81146978:	dfc00117 	ldw	ra,4(sp)
8114697c:	df000017 	ldw	fp,0(sp)
81146980:	dec00204 	addi	sp,sp,8
81146984:	f800283a 	ret

81146988 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
81146988:	defffb04 	addi	sp,sp,-20
8114698c:	de00012e 	bgeu	sp,et,81146994 <copy_file_record_name_to_string+0xc>
81146990:	003b68fa 	trap	3
81146994:	df000415 	stw	fp,16(sp)
81146998:	df000404 	addi	fp,sp,16
8114699c:	e13ffe15 	stw	r4,-8(fp)
811469a0:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
811469a4:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
811469a8:	e03ffc15 	stw	zero,-16(fp)
811469ac:	00001506 	br	81146a04 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
811469b0:	e0fffe17 	ldw	r3,-8(fp)
811469b4:	e0bffc17 	ldw	r2,-16(fp)
811469b8:	1885883a 	add	r2,r3,r2
811469bc:	10800003 	ldbu	r2,0(r2)
811469c0:	10803fcc 	andi	r2,r2,255
811469c4:	10800820 	cmpeqi	r2,r2,32
811469c8:	10000b1e 	bne	r2,zero,811469f8 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
811469cc:	e0bffd17 	ldw	r2,-12(fp)
811469d0:	e0ffff17 	ldw	r3,-4(fp)
811469d4:	1885883a 	add	r2,r3,r2
811469d8:	e13ffe17 	ldw	r4,-8(fp)
811469dc:	e0fffc17 	ldw	r3,-16(fp)
811469e0:	20c7883a 	add	r3,r4,r3
811469e4:	18c00003 	ldbu	r3,0(r3)
811469e8:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
811469ec:	e0bffd17 	ldw	r2,-12(fp)
811469f0:	10800044 	addi	r2,r2,1
811469f4:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
811469f8:	e0bffc17 	ldw	r2,-16(fp)
811469fc:	10800044 	addi	r2,r2,1
81146a00:	e0bffc15 	stw	r2,-16(fp)
81146a04:	e0bffc17 	ldw	r2,-16(fp)
81146a08:	10800210 	cmplti	r2,r2,8
81146a0c:	103fe81e 	bne	r2,zero,811469b0 <__reset+0xfb1269b0>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
81146a10:	e0bffe17 	ldw	r2,-8(fp)
81146a14:	10800203 	ldbu	r2,8(r2)
81146a18:	10803fcc 	andi	r2,r2,255
81146a1c:	10800820 	cmpeqi	r2,r2,32
81146a20:	1000241e 	bne	r2,zero,81146ab4 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
81146a24:	e0bffd17 	ldw	r2,-12(fp)
81146a28:	e0ffff17 	ldw	r3,-4(fp)
81146a2c:	1885883a 	add	r2,r3,r2
81146a30:	00c00b84 	movi	r3,46
81146a34:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
81146a38:	e0bffd17 	ldw	r2,-12(fp)
81146a3c:	10800044 	addi	r2,r2,1
81146a40:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
81146a44:	e03ffc15 	stw	zero,-16(fp)
81146a48:	00001706 	br	81146aa8 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
81146a4c:	e0fffe17 	ldw	r3,-8(fp)
81146a50:	e0bffc17 	ldw	r2,-16(fp)
81146a54:	1885883a 	add	r2,r3,r2
81146a58:	10800204 	addi	r2,r2,8
81146a5c:	10800003 	ldbu	r2,0(r2)
81146a60:	10803fcc 	andi	r2,r2,255
81146a64:	10800820 	cmpeqi	r2,r2,32
81146a68:	10000c1e 	bne	r2,zero,81146a9c <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
81146a6c:	e0bffd17 	ldw	r2,-12(fp)
81146a70:	e0ffff17 	ldw	r3,-4(fp)
81146a74:	1885883a 	add	r2,r3,r2
81146a78:	e13ffe17 	ldw	r4,-8(fp)
81146a7c:	e0fffc17 	ldw	r3,-16(fp)
81146a80:	20c7883a 	add	r3,r4,r3
81146a84:	18c00204 	addi	r3,r3,8
81146a88:	18c00003 	ldbu	r3,0(r3)
81146a8c:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
81146a90:	e0bffd17 	ldw	r2,-12(fp)
81146a94:	10800044 	addi	r2,r2,1
81146a98:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
81146a9c:	e0bffc17 	ldw	r2,-16(fp)
81146aa0:	10800044 	addi	r2,r2,1
81146aa4:	e0bffc15 	stw	r2,-16(fp)
81146aa8:	e0bffc17 	ldw	r2,-16(fp)
81146aac:	108000d0 	cmplti	r2,r2,3
81146ab0:	103fe61e 	bne	r2,zero,81146a4c <__reset+0xfb126a4c>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
81146ab4:	e0bffd17 	ldw	r2,-12(fp)
81146ab8:	e0ffff17 	ldw	r3,-4(fp)
81146abc:	1885883a 	add	r2,r3,r2
81146ac0:	10000005 	stb	zero,0(r2)
}
81146ac4:	0001883a 	nop
81146ac8:	e037883a 	mov	sp,fp
81146acc:	df000017 	ldw	fp,0(sp)
81146ad0:	dec00104 	addi	sp,sp,4
81146ad4:	f800283a 	ret

81146ad8 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
81146ad8:	defffc04 	addi	sp,sp,-16
81146adc:	de00012e 	bgeu	sp,et,81146ae4 <alt_up_sd_card_open_dev+0xc>
81146ae0:	003b68fa 	trap	3
81146ae4:	dfc00315 	stw	ra,12(sp)
81146ae8:	df000215 	stw	fp,8(sp)
81146aec:	df000204 	addi	fp,sp,8
81146af0:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
81146af4:	d1600d04 	addi	r5,gp,-32716
81146af8:	e13fff17 	ldw	r4,-4(fp)
81146afc:	114bf940 	call	8114bf94 <alt_find_dev>
81146b00:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
81146b04:	e0bffe17 	ldw	r2,-8(fp)
81146b08:	10001e26 	beq	r2,zero,81146b84 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
81146b0c:	e0bffe17 	ldw	r2,-8(fp)
81146b10:	10800a17 	ldw	r2,40(r2)
81146b14:	10808d04 	addi	r2,r2,564
81146b18:	d0a0ab15 	stw	r2,-32084(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
81146b1c:	e0bffe17 	ldw	r2,-8(fp)
81146b20:	10800a17 	ldw	r2,40(r2)
81146b24:	10808904 	addi	r2,r2,548
81146b28:	d0a0ac15 	stw	r2,-32080(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
81146b2c:	e0bffe17 	ldw	r2,-8(fp)
81146b30:	10800a17 	ldw	r2,40(r2)
81146b34:	10808404 	addi	r2,r2,528
81146b38:	d0a0ad15 	stw	r2,-32076(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
81146b3c:	e0bffe17 	ldw	r2,-8(fp)
81146b40:	10800a17 	ldw	r2,40(r2)
81146b44:	10808c04 	addi	r2,r2,560
81146b48:	d0a0ae15 	stw	r2,-32072(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
81146b4c:	e0bffe17 	ldw	r2,-8(fp)
81146b50:	10800a17 	ldw	r2,40(r2)
81146b54:	10808b04 	addi	r2,r2,556
81146b58:	d0a0af15 	stw	r2,-32068(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
81146b5c:	e0bffe17 	ldw	r2,-8(fp)
81146b60:	10800a17 	ldw	r2,40(r2)
81146b64:	d0a0b015 	stw	r2,-32064(gp)
		device_pointer = dev;
81146b68:	e0bffe17 	ldw	r2,-8(fp)
81146b6c:	d0a0b315 	stw	r2,-32052(gp)
		initialized = false;
81146b70:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
81146b74:	d020aa15 	stw	zero,-32088(gp)
		search_data.valid = false;
81146b78:	00a045f4 	movhi	r2,33047
81146b7c:	10ba9304 	addi	r2,r2,-5556
81146b80:	10000415 	stw	zero,16(r2)
	}
	return dev;
81146b84:	e0bffe17 	ldw	r2,-8(fp)
}
81146b88:	e037883a 	mov	sp,fp
81146b8c:	dfc00117 	ldw	ra,4(sp)
81146b90:	df000017 	ldw	fp,0(sp)
81146b94:	dec00204 	addi	sp,sp,8
81146b98:	f800283a 	ret

81146b9c <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
81146b9c:	defffd04 	addi	sp,sp,-12
81146ba0:	de00012e 	bgeu	sp,et,81146ba8 <alt_up_sd_card_is_Present+0xc>
81146ba4:	003b68fa 	trap	3
81146ba8:	df000215 	stw	fp,8(sp)
81146bac:	df000204 	addi	fp,sp,8
    bool result = false;
81146bb0:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
81146bb4:	d0a0b317 	ldw	r2,-32052(gp)
81146bb8:	10000826 	beq	r2,zero,81146bdc <alt_up_sd_card_is_Present+0x40>
81146bbc:	d0a0ab17 	ldw	r2,-32084(gp)
81146bc0:	1080002b 	ldhuio	r2,0(r2)
81146bc4:	10bfffcc 	andi	r2,r2,65535
81146bc8:	1080008c 	andi	r2,r2,2
81146bcc:	10000326 	beq	r2,zero,81146bdc <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
81146bd0:	00800044 	movi	r2,1
81146bd4:	e0bffe15 	stw	r2,-8(fp)
81146bd8:	00001e06 	br	81146c54 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
81146bdc:	d0a0a917 	ldw	r2,-32092(gp)
81146be0:	10800058 	cmpnei	r2,r2,1
81146be4:	10001b1e 	bne	r2,zero,81146c54 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
81146be8:	d020a915 	stw	zero,-32092(gp)
		search_data.valid = false;
81146bec:	00a045f4 	movhi	r2,33047
81146bf0:	10ba9304 	addi	r2,r2,-5556
81146bf4:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
81146bf8:	d020aa15 	stw	zero,-32088(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
81146bfc:	e03fff15 	stw	zero,-4(fp)
81146c00:	00001106 	br	81146c48 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
81146c04:	00a045f4 	movhi	r2,33047
81146c08:	10baad04 	addi	r2,r2,-5452
81146c0c:	e0ffff17 	ldw	r3,-4(fp)
81146c10:	180691ba 	slli	r3,r3,6
81146c14:	10c5883a 	add	r2,r2,r3
81146c18:	10800f04 	addi	r2,r2,60
81146c1c:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
81146c20:	00a045f4 	movhi	r2,33047
81146c24:	10baad04 	addi	r2,r2,-5452
81146c28:	e0ffff17 	ldw	r3,-4(fp)
81146c2c:	180691ba 	slli	r3,r3,6
81146c30:	10c5883a 	add	r2,r2,r3
81146c34:	10800e04 	addi	r2,r2,56
81146c38:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
81146c3c:	e0bfff17 	ldw	r2,-4(fp)
81146c40:	10800044 	addi	r2,r2,1
81146c44:	e0bfff15 	stw	r2,-4(fp)
81146c48:	e0bfff17 	ldw	r2,-4(fp)
81146c4c:	10800510 	cmplti	r2,r2,20
81146c50:	103fec1e 	bne	r2,zero,81146c04 <__reset+0xfb126c04>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
81146c54:	e0bffe17 	ldw	r2,-8(fp)
}
81146c58:	e037883a 	mov	sp,fp
81146c5c:	df000017 	ldw	fp,0(sp)
81146c60:	dec00104 	addi	sp,sp,4
81146c64:	f800283a 	ret

81146c68 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
81146c68:	defffd04 	addi	sp,sp,-12
81146c6c:	de00012e 	bgeu	sp,et,81146c74 <alt_up_sd_card_is_FAT16+0xc>
81146c70:	003b68fa 	trap	3
81146c74:	dfc00215 	stw	ra,8(sp)
81146c78:	df000115 	stw	fp,4(sp)
81146c7c:	df000104 	addi	fp,sp,4
	bool result = false;
81146c80:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
81146c84:	1146b9c0 	call	81146b9c <alt_up_sd_card_is_Present>
81146c88:	10000c26 	beq	r2,zero,81146cbc <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
81146c8c:	d0a0a917 	ldw	r2,-32092(gp)
81146c90:	1000071e 	bne	r2,zero,81146cb0 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
81146c94:	1144e940 	call	81144e94 <Look_for_FAT16>
81146c98:	d0a0aa15 	stw	r2,-32088(gp)
			initialized = is_sd_card_formated_as_FAT16;
81146c9c:	d0a0aa17 	ldw	r2,-32088(gp)
81146ca0:	d0a0a915 	stw	r2,-32092(gp)
			search_data.valid = false;
81146ca4:	00a045f4 	movhi	r2,33047
81146ca8:	10ba9304 	addi	r2,r2,-5556
81146cac:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
81146cb0:	d0a0aa17 	ldw	r2,-32088(gp)
81146cb4:	e0bfff15 	stw	r2,-4(fp)
81146cb8:	00000206 	br	81146cc4 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
81146cbc:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
81146cc0:	d020aa15 	stw	zero,-32088(gp)
	}

	return result;
81146cc4:	e0bfff17 	ldw	r2,-4(fp)
}
81146cc8:	e037883a 	mov	sp,fp
81146ccc:	dfc00117 	ldw	ra,4(sp)
81146cd0:	df000017 	ldw	fp,0(sp)
81146cd4:	dec00204 	addi	sp,sp,8
81146cd8:	f800283a 	ret

81146cdc <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
81146cdc:	deffea04 	addi	sp,sp,-88
81146ce0:	de00012e 	bgeu	sp,et,81146ce8 <alt_up_sd_card_find_first+0xc>
81146ce4:	003b68fa 	trap	3
81146ce8:	dfc01515 	stw	ra,84(sp)
81146cec:	df001415 	stw	fp,80(sp)
81146cf0:	df001404 	addi	fp,sp,80
81146cf4:	e13ffe15 	stw	r4,-8(fp)
81146cf8:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
81146cfc:	00800084 	movi	r2,2
81146d00:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81146d04:	1146b9c0 	call	81146b9c <alt_up_sd_card_is_Present>
81146d08:	10002426 	beq	r2,zero,81146d9c <alt_up_sd_card_find_first+0xc0>
81146d0c:	d0a0aa17 	ldw	r2,-32088(gp)
81146d10:	10002226 	beq	r2,zero,81146d9c <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
81146d14:	e0ffee04 	addi	r3,fp,-72
81146d18:	e0bfed04 	addi	r2,fp,-76
81146d1c:	180d883a 	mov	r6,r3
81146d20:	100b883a 	mov	r5,r2
81146d24:	e13ffe17 	ldw	r4,-8(fp)
81146d28:	114562c0 	call	8114562c <get_home_directory_cluster_for_file>
81146d2c:	10001926 	beq	r2,zero,81146d94 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
81146d30:	e0bfed17 	ldw	r2,-76(fp)
81146d34:	1007883a 	mov	r3,r2
81146d38:	00a045f4 	movhi	r2,33047
81146d3c:	10ba9304 	addi	r2,r2,-5556
81146d40:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
81146d44:	e0bfed17 	ldw	r2,-76(fp)
81146d48:	1007883a 	mov	r3,r2
81146d4c:	00a045f4 	movhi	r2,33047
81146d50:	10ba9304 	addi	r2,r2,-5556
81146d54:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
81146d58:	00a045f4 	movhi	r2,33047
81146d5c:	10ba9304 	addi	r2,r2,-5556
81146d60:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
81146d64:	00a045f4 	movhi	r2,33047
81146d68:	10ba9304 	addi	r2,r2,-5556
81146d6c:	00ffffc4 	movi	r3,-1
81146d70:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
81146d74:	00a045f4 	movhi	r2,33047
81146d78:	10ba9304 	addi	r2,r2,-5556
81146d7c:	00c00044 	movi	r3,1
81146d80:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
81146d84:	e13fff17 	ldw	r4,-4(fp)
81146d88:	1146db40 	call	81146db4 <alt_up_sd_card_find_next>
81146d8c:	e0bfec0d 	sth	r2,-80(fp)
81146d90:	00000206 	br	81146d9c <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
81146d94:	00800044 	movi	r2,1
81146d98:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
81146d9c:	e0bfec0b 	ldhu	r2,-80(fp)
}
81146da0:	e037883a 	mov	sp,fp
81146da4:	dfc00117 	ldw	ra,4(sp)
81146da8:	df000017 	ldw	fp,0(sp)
81146dac:	dec00204 	addi	sp,sp,8
81146db0:	f800283a 	ret

81146db4 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
81146db4:	deffe404 	addi	sp,sp,-112
81146db8:	de00012e 	bgeu	sp,et,81146dc0 <alt_up_sd_card_find_next+0xc>
81146dbc:	003b68fa 	trap	3
81146dc0:	dfc01b15 	stw	ra,108(sp)
81146dc4:	df001a15 	stw	fp,104(sp)
81146dc8:	df001a04 	addi	fp,sp,104
81146dcc:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
81146dd0:	00800084 	movi	r2,2
81146dd4:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81146dd8:	1146b9c0 	call	81146b9c <alt_up_sd_card_is_Present>
81146ddc:	1000df26 	beq	r2,zero,8114715c <alt_up_sd_card_find_next+0x3a8>
81146de0:	d0a0aa17 	ldw	r2,-32088(gp)
81146de4:	1000dd26 	beq	r2,zero,8114715c <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
81146de8:	00a045f4 	movhi	r2,33047
81146dec:	10ba9304 	addi	r2,r2,-5556
81146df0:	10800417 	ldw	r2,16(r2)
81146df4:	1000d726 	beq	r2,zero,81147154 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
81146df8:	00a045f4 	movhi	r2,33047
81146dfc:	10ba9304 	addi	r2,r2,-5556
81146e00:	10800117 	ldw	r2,4(r2)
81146e04:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
81146e08:	e0bfe717 	ldw	r2,-100(fp)
81146e0c:	1000561e 	bne	r2,zero,81146f68 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81146e10:	00a045f4 	movhi	r2,33047
81146e14:	10ba9804 	addi	r2,r2,-5536
81146e18:	1080050b 	ldhu	r2,20(r2)
81146e1c:	10bfffcc 	andi	r2,r2,65535
81146e20:	1006917a 	slli	r3,r2,5
81146e24:	00a045f4 	movhi	r2,33047
81146e28:	10ba9804 	addi	r2,r2,-5536
81146e2c:	1080030b 	ldhu	r2,12(r2)
81146e30:	10bfffcc 	andi	r2,r2,65535
81146e34:	1885283a 	div	r2,r3,r2
81146e38:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
81146e3c:	00a045f4 	movhi	r2,33047
81146e40:	10ba9304 	addi	r2,r2,-5556
81146e44:	10800217 	ldw	r2,8(r2)
81146e48:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
81146e4c:	00a045f4 	movhi	r2,33047
81146e50:	10ba9304 	addi	r2,r2,-5556
81146e54:	1080030b 	ldhu	r2,12(r2)
81146e58:	10bfffcc 	andi	r2,r2,65535
81146e5c:	10a0001c 	xori	r2,r2,32768
81146e60:	10a00004 	addi	r2,r2,-32768
81146e64:	10800044 	addi	r2,r2,1
81146e68:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81146e6c:	00003606 	br	81146f48 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81146e70:	00a045f4 	movhi	r2,33047
81146e74:	10ba9804 	addi	r2,r2,-5536
81146e78:	10c01317 	ldw	r3,76(r2)
81146e7c:	e0bfe817 	ldw	r2,-96(fp)
81146e80:	1885883a 	add	r2,r3,r2
81146e84:	1007883a 	mov	r3,r2
81146e88:	d0a0b117 	ldw	r2,-32060(gp)
81146e8c:	100b883a 	mov	r5,r2
81146e90:	1809883a 	mov	r4,r3
81146e94:	1143ec40 	call	81143ec4 <Read_Sector_Data>
81146e98:	10002f26 	beq	r2,zero,81146f58 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81146e9c:	00002306 	br	81146f2c <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
81146ea0:	e0bfe917 	ldw	r2,-92(fp)
81146ea4:	1004917a 	slli	r2,r2,5
81146ea8:	e13fe817 	ldw	r4,-96(fp)
81146eac:	e0ffef04 	addi	r3,fp,-68
81146eb0:	200f883a 	mov	r7,r4
81146eb4:	000d883a 	mov	r6,zero
81146eb8:	180b883a 	mov	r5,r3
81146ebc:	1009883a 	mov	r4,r2
81146ec0:	11442f40 	call	811442f4 <Read_File_Record_At_Offset>
81146ec4:	10001626 	beq	r2,zero,81146f20 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81146ec8:	e0bfef03 	ldbu	r2,-68(fp)
81146ecc:	10803fcc 	andi	r2,r2,255
81146ed0:	10001326 	beq	r2,zero,81146f20 <alt_up_sd_card_find_next+0x16c>
81146ed4:	e0bfef03 	ldbu	r2,-68(fp)
81146ed8:	10803fcc 	andi	r2,r2,255
81146edc:	10803960 	cmpeqi	r2,r2,229
81146ee0:	10000f1e 	bne	r2,zero,81146f20 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
81146ee4:	e0bfe917 	ldw	r2,-92(fp)
81146ee8:	1007883a 	mov	r3,r2
81146eec:	00a045f4 	movhi	r2,33047
81146ef0:	10ba9304 	addi	r2,r2,-5556
81146ef4:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
81146ef8:	e0ffe817 	ldw	r3,-96(fp)
81146efc:	00a045f4 	movhi	r2,33047
81146f00:	10ba9304 	addi	r2,r2,-5556
81146f04:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
81146f08:	e0bfef04 	addi	r2,fp,-68
81146f0c:	e17fff17 	ldw	r5,-4(fp)
81146f10:	1009883a 	mov	r4,r2
81146f14:	11469880 	call	81146988 <copy_file_record_name_to_string>
									return 0;
81146f18:	0005883a 	mov	r2,zero
81146f1c:	00009006 	br	81147160 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81146f20:	e0bfe917 	ldw	r2,-92(fp)
81146f24:	10800044 	addi	r2,r2,1
81146f28:	e0bfe915 	stw	r2,-92(fp)
81146f2c:	e0bfe917 	ldw	r2,-92(fp)
81146f30:	10800410 	cmplti	r2,r2,16
81146f34:	103fda1e 	bne	r2,zero,81146ea0 <__reset+0xfb126ea0>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
81146f38:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81146f3c:	e0bfe817 	ldw	r2,-96(fp)
81146f40:	10800044 	addi	r2,r2,1
81146f44:	e0bfe815 	stw	r2,-96(fp)
81146f48:	e0ffe817 	ldw	r3,-96(fp)
81146f4c:	e0bfec17 	ldw	r2,-80(fp)
81146f50:	18bfc716 	blt	r3,r2,81146e70 <__reset+0xfb126e70>
81146f54:	00000106 	br	81146f5c <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
81146f58:	0001883a 	nop
					}
				}
				result = -1;
81146f5c:	00bfffc4 	movi	r2,-1
81146f60:	e0bfe60d 	sth	r2,-104(fp)
81146f64:	00007d06 	br	8114715c <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
81146f68:	00a045f4 	movhi	r2,33047
81146f6c:	10ba9304 	addi	r2,r2,-5556
81146f70:	1080030b 	ldhu	r2,12(r2)
81146f74:	10bfffcc 	andi	r2,r2,65535
81146f78:	10a0001c 	xori	r2,r2,32768
81146f7c:	10a00004 	addi	r2,r2,-32768
81146f80:	10800044 	addi	r2,r2,1
81146f84:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81146f88:	e0bfe717 	ldw	r2,-100(fp)
81146f8c:	10ffff84 	addi	r3,r2,-2
81146f90:	00a045f4 	movhi	r2,33047
81146f94:	10ba9804 	addi	r2,r2,-5536
81146f98:	10800383 	ldbu	r2,14(r2)
81146f9c:	10803fcc 	andi	r2,r2,255
81146fa0:	1885383a 	mul	r2,r3,r2
81146fa4:	1007883a 	mov	r3,r2
81146fa8:	00a045f4 	movhi	r2,33047
81146fac:	10ba9804 	addi	r2,r2,-5536
81146fb0:	10801417 	ldw	r2,80(r2)
81146fb4:	1885883a 	add	r2,r3,r2
81146fb8:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
81146fbc:	00a045f4 	movhi	r2,33047
81146fc0:	10ba9304 	addi	r2,r2,-5556
81146fc4:	10800217 	ldw	r2,8(r2)
81146fc8:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81146fcc:	00003806 	br	811470b0 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81146fd0:	e0ffeb17 	ldw	r3,-84(fp)
81146fd4:	e0bfed17 	ldw	r2,-76(fp)
81146fd8:	1885883a 	add	r2,r3,r2
81146fdc:	d0e0b117 	ldw	r3,-32060(gp)
81146fe0:	180b883a 	mov	r5,r3
81146fe4:	1009883a 	mov	r4,r2
81146fe8:	1143ec40 	call	81143ec4 <Read_Sector_Data>
81146fec:	10003726 	beq	r2,zero,811470cc <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
81146ff0:	00002806 	br	81147094 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
81146ff4:	e0bfea17 	ldw	r2,-88(fp)
81146ff8:	1004917a 	slli	r2,r2,5
81146ffc:	e13fe717 	ldw	r4,-100(fp)
81147000:	e17feb17 	ldw	r5,-84(fp)
81147004:	e0ffef04 	addi	r3,fp,-68
81147008:	280f883a 	mov	r7,r5
8114700c:	200d883a 	mov	r6,r4
81147010:	180b883a 	mov	r5,r3
81147014:	1009883a 	mov	r4,r2
81147018:	11442f40 	call	811442f4 <Read_File_Record_At_Offset>
8114701c:	10001a26 	beq	r2,zero,81147088 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81147020:	e0bfef03 	ldbu	r2,-68(fp)
81147024:	10803fcc 	andi	r2,r2,255
81147028:	10001726 	beq	r2,zero,81147088 <alt_up_sd_card_find_next+0x2d4>
8114702c:	e0bfef03 	ldbu	r2,-68(fp)
81147030:	10803fcc 	andi	r2,r2,255
81147034:	10803960 	cmpeqi	r2,r2,229
81147038:	1000131e 	bne	r2,zero,81147088 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
8114703c:	e0ffe717 	ldw	r3,-100(fp)
81147040:	00a045f4 	movhi	r2,33047
81147044:	10ba9304 	addi	r2,r2,-5556
81147048:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
8114704c:	e0bfea17 	ldw	r2,-88(fp)
81147050:	1007883a 	mov	r3,r2
81147054:	00a045f4 	movhi	r2,33047
81147058:	10ba9304 	addi	r2,r2,-5556
8114705c:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
81147060:	e0ffeb17 	ldw	r3,-84(fp)
81147064:	00a045f4 	movhi	r2,33047
81147068:	10ba9304 	addi	r2,r2,-5556
8114706c:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
81147070:	e0bfef04 	addi	r2,fp,-68
81147074:	e17fff17 	ldw	r5,-4(fp)
81147078:	1009883a 	mov	r4,r2
8114707c:	11469880 	call	81146988 <copy_file_record_name_to_string>
										return 0;
81147080:	0005883a 	mov	r2,zero
81147084:	00003606 	br	81147160 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
81147088:	e0bfea17 	ldw	r2,-88(fp)
8114708c:	10800044 	addi	r2,r2,1
81147090:	e0bfea15 	stw	r2,-88(fp)
81147094:	e0bfea17 	ldw	r2,-88(fp)
81147098:	10800410 	cmplti	r2,r2,16
8114709c:	103fd51e 	bne	r2,zero,81146ff4 <__reset+0xfb126ff4>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
811470a0:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811470a4:	e0bfeb17 	ldw	r2,-84(fp)
811470a8:	10800044 	addi	r2,r2,1
811470ac:	e0bfeb15 	stw	r2,-84(fp)
811470b0:	00a045f4 	movhi	r2,33047
811470b4:	10ba9804 	addi	r2,r2,-5536
811470b8:	10800383 	ldbu	r2,14(r2)
811470bc:	10803fcc 	andi	r2,r2,255
811470c0:	e0ffeb17 	ldw	r3,-84(fp)
811470c4:	18bfc216 	blt	r3,r2,81146fd0 <__reset+0xfb126fd0>
811470c8:	00000106 	br	811470d0 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
811470cc:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
811470d0:	00a045f4 	movhi	r2,33047
811470d4:	10ba9804 	addi	r2,r2,-5536
811470d8:	10800383 	ldbu	r2,14(r2)
811470dc:	10803fcc 	andi	r2,r2,255
811470e0:	e0ffeb17 	ldw	r3,-84(fp)
811470e4:	18801716 	blt	r3,r2,81147144 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
811470e8:	e0bfe717 	ldw	r2,-100(fp)
811470ec:	e0ffee04 	addi	r3,fp,-72
811470f0:	180b883a 	mov	r5,r3
811470f4:	1009883a 	mov	r4,r2
811470f8:	1143fa40 	call	81143fa4 <get_cluster_flag>
811470fc:	10000f26 	beq	r2,zero,8114713c <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81147100:	e0bfee0b 	ldhu	r2,-72(fp)
81147104:	10bfffcc 	andi	r2,r2,65535
81147108:	10fffe0c 	andi	r3,r2,65528
8114710c:	00bffe14 	movui	r2,65528
81147110:	1880051e 	bne	r3,r2,81147128 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
81147114:	00bfffc4 	movi	r2,-1
81147118:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
8114711c:	00a045f4 	movhi	r2,33047
81147120:	10ba9304 	addi	r2,r2,-5556
81147124:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
81147128:	e0bfee0b 	ldhu	r2,-72(fp)
8114712c:	10bfffcc 	andi	r2,r2,65535
81147130:	10bffe0c 	andi	r2,r2,65528
81147134:	e0bfe715 	stw	r2,-100(fp)
81147138:	00000206 	br	81147144 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
8114713c:	00bfffc4 	movi	r2,-1
81147140:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
81147144:	e0bfe717 	ldw	r2,-100(fp)
81147148:	00fffdd4 	movui	r3,65527
8114714c:	18bf8e0e 	bge	r3,r2,81146f88 <__reset+0xfb126f88>
81147150:	00000206 	br	8114715c <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
81147154:	008000c4 	movi	r2,3
81147158:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
8114715c:	e0bfe60b 	ldhu	r2,-104(fp)
}
81147160:	e037883a 	mov	sp,fp
81147164:	dfc00117 	ldw	ra,4(sp)
81147168:	df000017 	ldw	fp,0(sp)
8114716c:	dec00204 	addi	sp,sp,8
81147170:	f800283a 	ret

81147174 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
81147174:	deffe904 	addi	sp,sp,-92
81147178:	de00012e 	bgeu	sp,et,81147180 <alt_up_sd_card_fopen+0xc>
8114717c:	003b68fa 	trap	3
81147180:	dfc01615 	stw	ra,88(sp)
81147184:	df001515 	stw	fp,84(sp)
81147188:	df001504 	addi	fp,sp,84
8114718c:	e13ffe15 	stw	r4,-8(fp)
81147190:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
81147194:	00bfffc4 	movi	r2,-1
81147198:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8114719c:	1146b9c0 	call	81146b9c <alt_up_sd_card_is_Present>
811471a0:	1000cf26 	beq	r2,zero,811474e0 <alt_up_sd_card_fopen+0x36c>
811471a4:	d0a0aa17 	ldw	r2,-32088(gp)
811471a8:	1000cd26 	beq	r2,zero,811474e0 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
811471ac:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
811471b0:	e13ffe17 	ldw	r4,-8(fp)
811471b4:	1144f880 	call	81144f88 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
811471b8:	e13ffe17 	ldw	r4,-8(fp)
811471bc:	11450540 	call	81145054 <check_file_name_for_FAT16_compliance>
811471c0:	1000c726 	beq	r2,zero,811474e0 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
811471c4:	e0ffee04 	addi	r3,fp,-72
811471c8:	e0bfed04 	addi	r2,fp,-76
811471cc:	180d883a 	mov	r6,r3
811471d0:	100b883a 	mov	r5,r2
811471d4:	e13ffe17 	ldw	r4,-8(fp)
811471d8:	114562c0 	call	8114562c <get_home_directory_cluster_for_file>
811471dc:	1000021e 	bne	r2,zero,811471e8 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
811471e0:	e0bfeb0b 	ldhu	r2,-84(fp)
811471e4:	0000bf06 	br	811474e4 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
811471e8:	e03fec15 	stw	zero,-80(fp)
811471ec:	00000e06 	br	81147228 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
811471f0:	00a045f4 	movhi	r2,33047
811471f4:	10baad04 	addi	r2,r2,-5452
811471f8:	e0ffec17 	ldw	r3,-80(fp)
811471fc:	180691ba 	slli	r3,r3,6
81147200:	10c5883a 	add	r2,r2,r3
81147204:	10800f04 	addi	r2,r2,60
81147208:	10800017 	ldw	r2,0(r2)
8114720c:	1000031e 	bne	r2,zero,8114721c <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
81147210:	e0bfec17 	ldw	r2,-80(fp)
81147214:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
81147218:	00000606 	br	81147234 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8114721c:	e0bfec17 	ldw	r2,-80(fp)
81147220:	10800044 	addi	r2,r2,1
81147224:	e0bfec15 	stw	r2,-80(fp)
81147228:	e0bfec17 	ldw	r2,-80(fp)
8114722c:	10800510 	cmplti	r2,r2,20
81147230:	103fef1e 	bne	r2,zero,811471f0 <__reset+0xfb1271f0>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
81147234:	e0bfeb0f 	ldh	r2,-84(fp)
81147238:	1000a916 	blt	r2,zero,811474e0 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
8114723c:	e0bfed17 	ldw	r2,-76(fp)
81147240:	1009883a 	mov	r4,r2
81147244:	e0bfeb0f 	ldh	r2,-84(fp)
81147248:	100691ba 	slli	r3,r2,6
8114724c:	00a045f4 	movhi	r2,33047
81147250:	10baad04 	addi	r2,r2,-5452
81147254:	1885883a 	add	r2,r3,r2
81147258:	100d883a 	mov	r6,r2
8114725c:	e17ffe17 	ldw	r5,-8(fp)
81147260:	1145b6c0 	call	81145b6c <find_file_in_directory>
81147264:	10007b26 	beq	r2,zero,81147454 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
81147268:	e0bfff17 	ldw	r2,-4(fp)
8114726c:	10000226 	beq	r2,zero,81147278 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
81147270:	00bfffc4 	movi	r2,-1
81147274:	00009b06 	br	811474e4 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
81147278:	e13feb0f 	ldh	r4,-84(fp)
8114727c:	e0ffeb0f 	ldh	r3,-84(fp)
81147280:	00a045f4 	movhi	r2,33047
81147284:	10baad04 	addi	r2,r2,-5452
81147288:	180691ba 	slli	r3,r3,6
8114728c:	10c5883a 	add	r2,r2,r3
81147290:	10800584 	addi	r2,r2,22
81147294:	1080000b 	ldhu	r2,0(r2)
81147298:	10ffffcc 	andi	r3,r2,65535
8114729c:	00a045f4 	movhi	r2,33047
811472a0:	10baad04 	addi	r2,r2,-5452
811472a4:	200891ba 	slli	r4,r4,6
811472a8:	1105883a 	add	r2,r2,r4
811472ac:	10800704 	addi	r2,r2,28
811472b0:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
811472b4:	e0ffeb0f 	ldh	r3,-84(fp)
811472b8:	00a045f4 	movhi	r2,33047
811472bc:	10baad04 	addi	r2,r2,-5452
811472c0:	180691ba 	slli	r3,r3,6
811472c4:	10c5883a 	add	r2,r2,r3
811472c8:	10800804 	addi	r2,r2,32
811472cc:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
811472d0:	e0ffeb0f 	ldh	r3,-84(fp)
811472d4:	00a045f4 	movhi	r2,33047
811472d8:	10baad04 	addi	r2,r2,-5452
811472dc:	180691ba 	slli	r3,r3,6
811472e0:	10c5883a 	add	r2,r2,r3
811472e4:	10800904 	addi	r2,r2,36
811472e8:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
811472ec:	e0ffeb0f 	ldh	r3,-84(fp)
811472f0:	00a045f4 	movhi	r2,33047
811472f4:	10baad04 	addi	r2,r2,-5452
811472f8:	180691ba 	slli	r3,r3,6
811472fc:	10c5883a 	add	r2,r2,r3
81147300:	10800f04 	addi	r2,r2,60
81147304:	00c00044 	movi	r3,1
81147308:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
8114730c:	e0ffeb0f 	ldh	r3,-84(fp)
81147310:	00a045f4 	movhi	r2,33047
81147314:	10baad04 	addi	r2,r2,-5452
81147318:	180691ba 	slli	r3,r3,6
8114731c:	10c5883a 	add	r2,r2,r3
81147320:	10800e04 	addi	r2,r2,56
81147324:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81147328:	e03fec15 	stw	zero,-80(fp)
8114732c:	00004506 	br	81147444 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
81147330:	e0ffeb0f 	ldh	r3,-84(fp)
81147334:	e0bfec17 	ldw	r2,-80(fp)
81147338:	18803f26 	beq	r3,r2,81147438 <alt_up_sd_card_fopen+0x2c4>
8114733c:	00a045f4 	movhi	r2,33047
81147340:	10baad04 	addi	r2,r2,-5452
81147344:	e0ffec17 	ldw	r3,-80(fp)
81147348:	180691ba 	slli	r3,r3,6
8114734c:	10c5883a 	add	r2,r2,r3
81147350:	10800f04 	addi	r2,r2,60
81147354:	10800017 	ldw	r2,0(r2)
81147358:	10800058 	cmpnei	r2,r2,1
8114735c:	1000361e 	bne	r2,zero,81147438 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81147360:	e0ffeb0f 	ldh	r3,-84(fp)
81147364:	00a045f4 	movhi	r2,33047
81147368:	10baad04 	addi	r2,r2,-5452
8114736c:	180691ba 	slli	r3,r3,6
81147370:	10c5883a 	add	r2,r2,r3
81147374:	10800a04 	addi	r2,r2,40
81147378:	10c00017 	ldw	r3,0(r2)
8114737c:	00a045f4 	movhi	r2,33047
81147380:	10baad04 	addi	r2,r2,-5452
81147384:	e13fec17 	ldw	r4,-80(fp)
81147388:	200891ba 	slli	r4,r4,6
8114738c:	1105883a 	add	r2,r2,r4
81147390:	10800a04 	addi	r2,r2,40
81147394:	10800017 	ldw	r2,0(r2)
81147398:	1880271e 	bne	r3,r2,81147438 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8114739c:	e0ffeb0f 	ldh	r3,-84(fp)
811473a0:	00a045f4 	movhi	r2,33047
811473a4:	10baad04 	addi	r2,r2,-5452
811473a8:	180691ba 	slli	r3,r3,6
811473ac:	10c5883a 	add	r2,r2,r3
811473b0:	10800b04 	addi	r2,r2,44
811473b4:	10c00017 	ldw	r3,0(r2)
811473b8:	00a045f4 	movhi	r2,33047
811473bc:	10baad04 	addi	r2,r2,-5452
811473c0:	e13fec17 	ldw	r4,-80(fp)
811473c4:	200891ba 	slli	r4,r4,6
811473c8:	1105883a 	add	r2,r2,r4
811473cc:	10800b04 	addi	r2,r2,44
811473d0:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
811473d4:	1880181e 	bne	r3,r2,81147438 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
811473d8:	e0ffeb0f 	ldh	r3,-84(fp)
811473dc:	00a045f4 	movhi	r2,33047
811473e0:	10baad04 	addi	r2,r2,-5452
811473e4:	180691ba 	slli	r3,r3,6
811473e8:	10c5883a 	add	r2,r2,r3
811473ec:	10800c04 	addi	r2,r2,48
811473f0:	1100000b 	ldhu	r4,0(r2)
811473f4:	00a045f4 	movhi	r2,33047
811473f8:	10baad04 	addi	r2,r2,-5452
811473fc:	e0ffec17 	ldw	r3,-80(fp)
81147400:	180691ba 	slli	r3,r3,6
81147404:	10c5883a 	add	r2,r2,r3
81147408:	10800c04 	addi	r2,r2,48
8114740c:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81147410:	20ffffcc 	andi	r3,r4,65535
81147414:	18e0001c 	xori	r3,r3,32768
81147418:	18e00004 	addi	r3,r3,-32768
8114741c:	10bfffcc 	andi	r2,r2,65535
81147420:	10a0001c 	xori	r2,r2,32768
81147424:	10a00004 	addi	r2,r2,-32768
81147428:	1880031e 	bne	r3,r2,81147438 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
8114742c:	00bfff84 	movi	r2,-2
81147430:	e0bfeb0d 	sth	r2,-84(fp)
								break;
81147434:	00002a06 	br	811474e0 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81147438:	e0bfec17 	ldw	r2,-80(fp)
8114743c:	10800044 	addi	r2,r2,1
81147440:	e0bfec15 	stw	r2,-80(fp)
81147444:	e0bfec17 	ldw	r2,-80(fp)
81147448:	10800510 	cmplti	r2,r2,20
8114744c:	103fb81e 	bne	r2,zero,81147330 <__reset+0xfb127330>
81147450:	00002306 	br	811474e0 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
81147454:	e0bfff17 	ldw	r2,-4(fp)
81147458:	10001f26 	beq	r2,zero,811474d8 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
8114745c:	e0bfeb0f 	ldh	r2,-84(fp)
81147460:	100691ba 	slli	r3,r2,6
81147464:	00a045f4 	movhi	r2,33047
81147468:	10baad04 	addi	r2,r2,-5452
8114746c:	1885883a 	add	r2,r3,r2
81147470:	e0ffee04 	addi	r3,fp,-72
81147474:	180d883a 	mov	r6,r3
81147478:	100b883a 	mov	r5,r2
8114747c:	e13ffe17 	ldw	r4,-8(fp)
81147480:	11466b80 	call	811466b8 <create_file>
81147484:	10001126 	beq	r2,zero,811474cc <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
81147488:	e0ffeb0f 	ldh	r3,-84(fp)
8114748c:	00a045f4 	movhi	r2,33047
81147490:	10baad04 	addi	r2,r2,-5452
81147494:	180691ba 	slli	r3,r3,6
81147498:	10c5883a 	add	r2,r2,r3
8114749c:	10800f04 	addi	r2,r2,60
811474a0:	00c00044 	movi	r3,1
811474a4:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
811474a8:	e0ffeb0f 	ldh	r3,-84(fp)
811474ac:	00a045f4 	movhi	r2,33047
811474b0:	10baad04 	addi	r2,r2,-5452
811474b4:	180691ba 	slli	r3,r3,6
811474b8:	10c5883a 	add	r2,r2,r3
811474bc:	10800e04 	addi	r2,r2,56
811474c0:	00c00044 	movi	r3,1
811474c4:	10c00015 	stw	r3,0(r2)
811474c8:	00000506 	br	811474e0 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
811474cc:	00bfffc4 	movi	r2,-1
811474d0:	e0bfeb0d 	sth	r2,-84(fp)
811474d4:	00000206 	br	811474e0 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
811474d8:	00bfffc4 	movi	r2,-1
811474dc:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
811474e0:	e0bfeb0b 	ldhu	r2,-84(fp)
}
811474e4:	e037883a 	mov	sp,fp
811474e8:	dfc00117 	ldw	ra,4(sp)
811474ec:	df000017 	ldw	fp,0(sp)
811474f0:	dec00204 	addi	sp,sp,8
811474f4:	f800283a 	ret

811474f8 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
811474f8:	defffd04 	addi	sp,sp,-12
811474fc:	de00012e 	bgeu	sp,et,81147504 <alt_up_sd_card_set_attributes+0xc>
81147500:	003b68fa 	trap	3
81147504:	df000215 	stw	fp,8(sp)
81147508:	df000204 	addi	fp,sp,8
8114750c:	2007883a 	mov	r3,r4
81147510:	2805883a 	mov	r2,r5
81147514:	e0fffe0d 	sth	r3,-8(fp)
81147518:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8114751c:	e0bffe0f 	ldh	r2,-8(fp)
81147520:	10001416 	blt	r2,zero,81147574 <alt_up_sd_card_set_attributes+0x7c>
81147524:	e0bffe0f 	ldh	r2,-8(fp)
81147528:	10800508 	cmpgei	r2,r2,20
8114752c:	1000111e 	bne	r2,zero,81147574 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81147530:	e0fffe0f 	ldh	r3,-8(fp)
81147534:	00a045f4 	movhi	r2,33047
81147538:	10baad04 	addi	r2,r2,-5452
8114753c:	180691ba 	slli	r3,r3,6
81147540:	10c5883a 	add	r2,r2,r3
81147544:	10800f04 	addi	r2,r2,60
81147548:	10800017 	ldw	r2,0(r2)
8114754c:	10000926 	beq	r2,zero,81147574 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
81147550:	e0fffe0f 	ldh	r3,-8(fp)
81147554:	e0bfff0b 	ldhu	r2,-4(fp)
81147558:	1009883a 	mov	r4,r2
8114755c:	00a045f4 	movhi	r2,33047
81147560:	10baad04 	addi	r2,r2,-5452
81147564:	180691ba 	slli	r3,r3,6
81147568:	10c5883a 	add	r2,r2,r3
8114756c:	108002c4 	addi	r2,r2,11
81147570:	11000005 	stb	r4,0(r2)
        }
    }
}
81147574:	0001883a 	nop
81147578:	e037883a 	mov	sp,fp
8114757c:	df000017 	ldw	fp,0(sp)
81147580:	dec00104 	addi	sp,sp,4
81147584:	f800283a 	ret

81147588 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81147588:	defffd04 	addi	sp,sp,-12
8114758c:	de00012e 	bgeu	sp,et,81147594 <alt_up_sd_card_get_attributes+0xc>
81147590:	003b68fa 	trap	3
81147594:	df000215 	stw	fp,8(sp)
81147598:	df000204 	addi	fp,sp,8
8114759c:	2005883a 	mov	r2,r4
811475a0:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
811475a4:	00bfffc4 	movi	r2,-1
811475a8:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811475ac:	e0bfff0f 	ldh	r2,-4(fp)
811475b0:	10001416 	blt	r2,zero,81147604 <alt_up_sd_card_get_attributes+0x7c>
811475b4:	e0bfff0f 	ldh	r2,-4(fp)
811475b8:	10800508 	cmpgei	r2,r2,20
811475bc:	1000111e 	bne	r2,zero,81147604 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
811475c0:	e0ffff0f 	ldh	r3,-4(fp)
811475c4:	00a045f4 	movhi	r2,33047
811475c8:	10baad04 	addi	r2,r2,-5452
811475cc:	180691ba 	slli	r3,r3,6
811475d0:	10c5883a 	add	r2,r2,r3
811475d4:	10800f04 	addi	r2,r2,60
811475d8:	10800017 	ldw	r2,0(r2)
811475dc:	10000926 	beq	r2,zero,81147604 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
811475e0:	e0ffff0f 	ldh	r3,-4(fp)
811475e4:	00a045f4 	movhi	r2,33047
811475e8:	10baad04 	addi	r2,r2,-5452
811475ec:	180691ba 	slli	r3,r3,6
811475f0:	10c5883a 	add	r2,r2,r3
811475f4:	108002c4 	addi	r2,r2,11
811475f8:	10800003 	ldbu	r2,0(r2)
811475fc:	10803fcc 	andi	r2,r2,255
81147600:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
81147604:	e0bffe0b 	ldhu	r2,-8(fp)
}
81147608:	e037883a 	mov	sp,fp
8114760c:	df000017 	ldw	fp,0(sp)
81147610:	dec00104 	addi	sp,sp,4
81147614:	f800283a 	ret

81147618 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
81147618:	defffa04 	addi	sp,sp,-24
8114761c:	de00012e 	bgeu	sp,et,81147624 <alt_up_sd_card_read+0xc>
81147620:	003b68fa 	trap	3
81147624:	dfc00515 	stw	ra,20(sp)
81147628:	df000415 	stw	fp,16(sp)
8114762c:	df000404 	addi	fp,sp,16
81147630:	2005883a 	mov	r2,r4
81147634:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
81147638:	00bfffc4 	movi	r2,-1
8114763c:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81147640:	e0bfff0f 	ldh	r2,-4(fp)
81147644:	1000ce16 	blt	r2,zero,81147980 <alt_up_sd_card_read+0x368>
81147648:	e0bfff0f 	ldh	r2,-4(fp)
8114764c:	10800508 	cmpgei	r2,r2,20
81147650:	1000cb1e 	bne	r2,zero,81147980 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
81147654:	e0ffff0f 	ldh	r3,-4(fp)
81147658:	00a045f4 	movhi	r2,33047
8114765c:	10baad04 	addi	r2,r2,-5452
81147660:	180691ba 	slli	r3,r3,6
81147664:	10c5883a 	add	r2,r2,r3
81147668:	10800f04 	addi	r2,r2,60
8114766c:	10800017 	ldw	r2,0(r2)
81147670:	1000c326 	beq	r2,zero,81147980 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81147674:	e0ffff0f 	ldh	r3,-4(fp)
81147678:	00a045f4 	movhi	r2,33047
8114767c:	10baad04 	addi	r2,r2,-5452
81147680:	180691ba 	slli	r3,r3,6
81147684:	10c5883a 	add	r2,r2,r3
81147688:	10800904 	addi	r2,r2,36
8114768c:	10c00017 	ldw	r3,0(r2)
81147690:	e13fff0f 	ldh	r4,-4(fp)
81147694:	00a045f4 	movhi	r2,33047
81147698:	10baad04 	addi	r2,r2,-5452
8114769c:	200891ba 	slli	r4,r4,6
811476a0:	1105883a 	add	r2,r2,r4
811476a4:	10800604 	addi	r2,r2,24
811476a8:	10800017 	ldw	r2,0(r2)
811476ac:	1880b42e 	bgeu	r3,r2,81147980 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811476b0:	00a045f4 	movhi	r2,33047
811476b4:	10ba9804 	addi	r2,r2,-5536
811476b8:	10c01417 	ldw	r3,80(r2)
811476bc:	e13fff0f 	ldh	r4,-4(fp)
811476c0:	00a045f4 	movhi	r2,33047
811476c4:	10baad04 	addi	r2,r2,-5452
811476c8:	200891ba 	slli	r4,r4,6
811476cc:	1105883a 	add	r2,r2,r4
811476d0:	10800704 	addi	r2,r2,28
811476d4:	10800017 	ldw	r2,0(r2)
811476d8:	113fff84 	addi	r4,r2,-2
811476dc:	00a045f4 	movhi	r2,33047
811476e0:	10ba9804 	addi	r2,r2,-5536
811476e4:	10800383 	ldbu	r2,14(r2)
811476e8:	10803fcc 	andi	r2,r2,255
811476ec:	2085383a 	mul	r2,r4,r2
811476f0:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
811476f4:	e13fff0f 	ldh	r4,-4(fp)
811476f8:	00a045f4 	movhi	r2,33047
811476fc:	10baad04 	addi	r2,r2,-5452
81147700:	200891ba 	slli	r4,r4,6
81147704:	1105883a 	add	r2,r2,r4
81147708:	10800804 	addi	r2,r2,32
8114770c:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147710:	1885883a 	add	r2,r3,r2
81147714:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
81147718:	e0ffff0f 	ldh	r3,-4(fp)
8114771c:	00a045f4 	movhi	r2,33047
81147720:	10baad04 	addi	r2,r2,-5452
81147724:	180691ba 	slli	r3,r3,6
81147728:	10c5883a 	add	r2,r2,r3
8114772c:	10800904 	addi	r2,r2,36
81147730:	10800017 	ldw	r2,0(r2)
81147734:	10006826 	beq	r2,zero,811478d8 <alt_up_sd_card_read+0x2c0>
81147738:	e0ffff0f 	ldh	r3,-4(fp)
8114773c:	00a045f4 	movhi	r2,33047
81147740:	10baad04 	addi	r2,r2,-5452
81147744:	180691ba 	slli	r3,r3,6
81147748:	10c5883a 	add	r2,r2,r3
8114774c:	10800904 	addi	r2,r2,36
81147750:	10800017 	ldw	r2,0(r2)
81147754:	10807fcc 	andi	r2,r2,511
81147758:	10005f1e 	bne	r2,zero,811478d8 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8114775c:	e0ffff0f 	ldh	r3,-4(fp)
81147760:	00a045f4 	movhi	r2,33047
81147764:	10baad04 	addi	r2,r2,-5452
81147768:	180691ba 	slli	r3,r3,6
8114776c:	10c5883a 	add	r2,r2,r3
81147770:	10800804 	addi	r2,r2,32
81147774:	10c00017 	ldw	r3,0(r2)
81147778:	00a045f4 	movhi	r2,33047
8114777c:	10ba9804 	addi	r2,r2,-5536
81147780:	10800383 	ldbu	r2,14(r2)
81147784:	10803fcc 	andi	r2,r2,255
81147788:	10bfffc4 	addi	r2,r2,-1
8114778c:	1880401e 	bne	r3,r2,81147890 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81147790:	e0ffff0f 	ldh	r3,-4(fp)
81147794:	00a045f4 	movhi	r2,33047
81147798:	10baad04 	addi	r2,r2,-5452
8114779c:	180691ba 	slli	r3,r3,6
811477a0:	10c5883a 	add	r2,r2,r3
811477a4:	10800704 	addi	r2,r2,28
811477a8:	10800017 	ldw	r2,0(r2)
811477ac:	e0fffe04 	addi	r3,fp,-8
811477b0:	180b883a 	mov	r5,r3
811477b4:	1009883a 	mov	r4,r2
811477b8:	1143fa40 	call	81143fa4 <get_cluster_flag>
811477bc:	10003226 	beq	r2,zero,81147888 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
811477c0:	e0bffe0b 	ldhu	r2,-8(fp)
811477c4:	10bfffcc 	andi	r2,r2,65535
811477c8:	10fffe0c 	andi	r3,r2,65528
811477cc:	00bffe14 	movui	r2,65528
811477d0:	1880021e 	bne	r3,r2,811477dc <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
811477d4:	00bfffc4 	movi	r2,-1
811477d8:	00006a06 	br	81147984 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
811477dc:	e13fff0f 	ldh	r4,-4(fp)
811477e0:	e0bffe0b 	ldhu	r2,-8(fp)
811477e4:	10ffffcc 	andi	r3,r2,65535
811477e8:	00a045f4 	movhi	r2,33047
811477ec:	10baad04 	addi	r2,r2,-5452
811477f0:	200891ba 	slli	r4,r4,6
811477f4:	1105883a 	add	r2,r2,r4
811477f8:	10800704 	addi	r2,r2,28
811477fc:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81147800:	e0ffff0f 	ldh	r3,-4(fp)
81147804:	00a045f4 	movhi	r2,33047
81147808:	10baad04 	addi	r2,r2,-5452
8114780c:	180691ba 	slli	r3,r3,6
81147810:	10c5883a 	add	r2,r2,r3
81147814:	10800804 	addi	r2,r2,32
81147818:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114781c:	00a045f4 	movhi	r2,33047
81147820:	10ba9804 	addi	r2,r2,-5536
81147824:	10c01417 	ldw	r3,80(r2)
81147828:	e13fff0f 	ldh	r4,-4(fp)
8114782c:	00a045f4 	movhi	r2,33047
81147830:	10baad04 	addi	r2,r2,-5452
81147834:	200891ba 	slli	r4,r4,6
81147838:	1105883a 	add	r2,r2,r4
8114783c:	10800704 	addi	r2,r2,28
81147840:	10800017 	ldw	r2,0(r2)
81147844:	113fff84 	addi	r4,r2,-2
81147848:	00a045f4 	movhi	r2,33047
8114784c:	10ba9804 	addi	r2,r2,-5536
81147850:	10800383 	ldbu	r2,14(r2)
81147854:	10803fcc 	andi	r2,r2,255
81147858:	2085383a 	mul	r2,r4,r2
8114785c:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81147860:	e13fff0f 	ldh	r4,-4(fp)
81147864:	00a045f4 	movhi	r2,33047
81147868:	10baad04 	addi	r2,r2,-5452
8114786c:	200891ba 	slli	r4,r4,6
81147870:	1105883a 	add	r2,r2,r4
81147874:	10800804 	addi	r2,r2,32
81147878:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114787c:	1885883a 	add	r2,r3,r2
81147880:	e0bffd15 	stw	r2,-12(fp)
81147884:	00001406 	br	811478d8 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
81147888:	00bfff84 	movi	r2,-2
8114788c:	00003d06 	br	81147984 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81147890:	e13fff0f 	ldh	r4,-4(fp)
81147894:	e0ffff0f 	ldh	r3,-4(fp)
81147898:	00a045f4 	movhi	r2,33047
8114789c:	10baad04 	addi	r2,r2,-5452
811478a0:	180691ba 	slli	r3,r3,6
811478a4:	10c5883a 	add	r2,r2,r3
811478a8:	10800804 	addi	r2,r2,32
811478ac:	10800017 	ldw	r2,0(r2)
811478b0:	10c00044 	addi	r3,r2,1
811478b4:	00a045f4 	movhi	r2,33047
811478b8:	10baad04 	addi	r2,r2,-5452
811478bc:	200891ba 	slli	r4,r4,6
811478c0:	1105883a 	add	r2,r2,r4
811478c4:	10800804 	addi	r2,r2,32
811478c8:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
811478cc:	e0bffd17 	ldw	r2,-12(fp)
811478d0:	10800044 	addi	r2,r2,1
811478d4:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
811478d8:	d0e0b117 	ldw	r3,-32060(gp)
811478dc:	e0bffd17 	ldw	r2,-12(fp)
811478e0:	1885883a 	add	r2,r3,r2
811478e4:	1007883a 	mov	r3,r2
811478e8:	d0a0b517 	ldw	r2,-32044(gp)
811478ec:	18800726 	beq	r3,r2,8114790c <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
811478f0:	d0a0b117 	ldw	r2,-32060(gp)
811478f4:	100b883a 	mov	r5,r2
811478f8:	e13ffd17 	ldw	r4,-12(fp)
811478fc:	1143ec40 	call	81143ec4 <Read_Sector_Data>
81147900:	1000021e 	bne	r2,zero,8114790c <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81147904:	00bfff84 	movi	r2,-2
81147908:	00001e06 	br	81147984 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
8114790c:	d0e0b017 	ldw	r3,-32064(gp)
81147910:	e13fff0f 	ldh	r4,-4(fp)
81147914:	00a045f4 	movhi	r2,33047
81147918:	10baad04 	addi	r2,r2,-5452
8114791c:	200891ba 	slli	r4,r4,6
81147920:	1105883a 	add	r2,r2,r4
81147924:	10800904 	addi	r2,r2,36
81147928:	10800017 	ldw	r2,0(r2)
8114792c:	10807fcc 	andi	r2,r2,511
81147930:	1885883a 	add	r2,r3,r2
81147934:	10800023 	ldbuio	r2,0(r2)
81147938:	10803fcc 	andi	r2,r2,255
8114793c:	10803fcc 	andi	r2,r2,255
81147940:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81147944:	e13fff0f 	ldh	r4,-4(fp)
81147948:	e0ffff0f 	ldh	r3,-4(fp)
8114794c:	00a045f4 	movhi	r2,33047
81147950:	10baad04 	addi	r2,r2,-5452
81147954:	180691ba 	slli	r3,r3,6
81147958:	10c5883a 	add	r2,r2,r3
8114795c:	10800904 	addi	r2,r2,36
81147960:	10800017 	ldw	r2,0(r2)
81147964:	10c00044 	addi	r3,r2,1
81147968:	00a045f4 	movhi	r2,33047
8114796c:	10baad04 	addi	r2,r2,-5452
81147970:	200891ba 	slli	r4,r4,6
81147974:	1105883a 	add	r2,r2,r4
81147978:	10800904 	addi	r2,r2,36
8114797c:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
81147980:	e0bffc0b 	ldhu	r2,-16(fp)
}
81147984:	e037883a 	mov	sp,fp
81147988:	dfc00117 	ldw	ra,4(sp)
8114798c:	df000017 	ldw	fp,0(sp)
81147990:	dec00204 	addi	sp,sp,8
81147994:	f800283a 	ret

81147998 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
81147998:	defff804 	addi	sp,sp,-32
8114799c:	de00012e 	bgeu	sp,et,811479a4 <alt_up_sd_card_write+0xc>
811479a0:	003b68fa 	trap	3
811479a4:	dfc00715 	stw	ra,28(sp)
811479a8:	df000615 	stw	fp,24(sp)
811479ac:	df000604 	addi	fp,sp,24
811479b0:	2007883a 	mov	r3,r4
811479b4:	2805883a 	mov	r2,r5
811479b8:	e0fffe0d 	sth	r3,-8(fp)
811479bc:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
811479c0:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811479c4:	e0bffe0f 	ldh	r2,-8(fp)
811479c8:	10017716 	blt	r2,zero,81147fa8 <alt_up_sd_card_write+0x610>
811479cc:	e0bffe0f 	ldh	r2,-8(fp)
811479d0:	10800508 	cmpgei	r2,r2,20
811479d4:	1001741e 	bne	r2,zero,81147fa8 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
811479d8:	e0fffe0f 	ldh	r3,-8(fp)
811479dc:	00a045f4 	movhi	r2,33047
811479e0:	10baad04 	addi	r2,r2,-5452
811479e4:	180691ba 	slli	r3,r3,6
811479e8:	10c5883a 	add	r2,r2,r3
811479ec:	10800f04 	addi	r2,r2,60
811479f0:	10800017 	ldw	r2,0(r2)
811479f4:	10016c26 	beq	r2,zero,81147fa8 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811479f8:	00a045f4 	movhi	r2,33047
811479fc:	10ba9804 	addi	r2,r2,-5536
81147a00:	10c01417 	ldw	r3,80(r2)
81147a04:	e13ffe0f 	ldh	r4,-8(fp)
81147a08:	00a045f4 	movhi	r2,33047
81147a0c:	10baad04 	addi	r2,r2,-5452
81147a10:	200891ba 	slli	r4,r4,6
81147a14:	1105883a 	add	r2,r2,r4
81147a18:	10800704 	addi	r2,r2,28
81147a1c:	10800017 	ldw	r2,0(r2)
81147a20:	113fff84 	addi	r4,r2,-2
81147a24:	00a045f4 	movhi	r2,33047
81147a28:	10ba9804 	addi	r2,r2,-5536
81147a2c:	10800383 	ldbu	r2,14(r2)
81147a30:	10803fcc 	andi	r2,r2,255
81147a34:	2085383a 	mul	r2,r4,r2
81147a38:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
81147a3c:	e13ffe0f 	ldh	r4,-8(fp)
81147a40:	00a045f4 	movhi	r2,33047
81147a44:	10baad04 	addi	r2,r2,-5452
81147a48:	200891ba 	slli	r4,r4,6
81147a4c:	1105883a 	add	r2,r2,r4
81147a50:	10800804 	addi	r2,r2,32
81147a54:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147a58:	1885883a 	add	r2,r3,r2
81147a5c:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
81147a60:	e0fffe0f 	ldh	r3,-8(fp)
81147a64:	00a045f4 	movhi	r2,33047
81147a68:	10baad04 	addi	r2,r2,-5452
81147a6c:	180691ba 	slli	r3,r3,6
81147a70:	10c5883a 	add	r2,r2,r3
81147a74:	10800904 	addi	r2,r2,36
81147a78:	10c00017 	ldw	r3,0(r2)
81147a7c:	00a045f4 	movhi	r2,33047
81147a80:	10ba9804 	addi	r2,r2,-5536
81147a84:	1080030b 	ldhu	r2,12(r2)
81147a88:	10bfffcc 	andi	r2,r2,65535
81147a8c:	1889203a 	divu	r4,r3,r2
81147a90:	2085383a 	mul	r2,r4,r2
81147a94:	1885c83a 	sub	r2,r3,r2
81147a98:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81147a9c:	e0fffe0f 	ldh	r3,-8(fp)
81147aa0:	00a045f4 	movhi	r2,33047
81147aa4:	10baad04 	addi	r2,r2,-5452
81147aa8:	180691ba 	slli	r3,r3,6
81147aac:	10c5883a 	add	r2,r2,r3
81147ab0:	10800904 	addi	r2,r2,36
81147ab4:	10c00017 	ldw	r3,0(r2)
81147ab8:	e13ffe0f 	ldh	r4,-8(fp)
81147abc:	00a045f4 	movhi	r2,33047
81147ac0:	10baad04 	addi	r2,r2,-5452
81147ac4:	200891ba 	slli	r4,r4,6
81147ac8:	1105883a 	add	r2,r2,r4
81147acc:	10800604 	addi	r2,r2,24
81147ad0:	10800017 	ldw	r2,0(r2)
81147ad4:	1880672e 	bgeu	r3,r2,81147c74 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81147ad8:	e0fffe0f 	ldh	r3,-8(fp)
81147adc:	00a045f4 	movhi	r2,33047
81147ae0:	10baad04 	addi	r2,r2,-5452
81147ae4:	180691ba 	slli	r3,r3,6
81147ae8:	10c5883a 	add	r2,r2,r3
81147aec:	10800904 	addi	r2,r2,36
81147af0:	10800017 	ldw	r2,0(r2)
81147af4:	1000e126 	beq	r2,zero,81147e7c <alt_up_sd_card_write+0x4e4>
81147af8:	e0bffc0f 	ldh	r2,-16(fp)
81147afc:	1000df1e 	bne	r2,zero,81147e7c <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81147b00:	e0fffe0f 	ldh	r3,-8(fp)
81147b04:	00a045f4 	movhi	r2,33047
81147b08:	10baad04 	addi	r2,r2,-5452
81147b0c:	180691ba 	slli	r3,r3,6
81147b10:	10c5883a 	add	r2,r2,r3
81147b14:	10800804 	addi	r2,r2,32
81147b18:	10c00017 	ldw	r3,0(r2)
81147b1c:	00a045f4 	movhi	r2,33047
81147b20:	10ba9804 	addi	r2,r2,-5536
81147b24:	10800383 	ldbu	r2,14(r2)
81147b28:	10803fcc 	andi	r2,r2,255
81147b2c:	10bfffc4 	addi	r2,r2,-1
81147b30:	18803d1e 	bne	r3,r2,81147c28 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81147b34:	e0fffe0f 	ldh	r3,-8(fp)
81147b38:	00a045f4 	movhi	r2,33047
81147b3c:	10baad04 	addi	r2,r2,-5452
81147b40:	180691ba 	slli	r3,r3,6
81147b44:	10c5883a 	add	r2,r2,r3
81147b48:	10800704 	addi	r2,r2,28
81147b4c:	10800017 	ldw	r2,0(r2)
81147b50:	e0fffc84 	addi	r3,fp,-14
81147b54:	180b883a 	mov	r5,r3
81147b58:	1009883a 	mov	r4,r2
81147b5c:	1143fa40 	call	81143fa4 <get_cluster_flag>
81147b60:	10002f26 	beq	r2,zero,81147c20 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
81147b64:	e0bffc8b 	ldhu	r2,-14(fp)
81147b68:	10bfffcc 	andi	r2,r2,65535
81147b6c:	10bffe28 	cmpgeui	r2,r2,65528
81147b70:	1000c21e 	bne	r2,zero,81147e7c <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81147b74:	e13ffe0f 	ldh	r4,-8(fp)
81147b78:	e0bffc8b 	ldhu	r2,-14(fp)
81147b7c:	10ffffcc 	andi	r3,r2,65535
81147b80:	00a045f4 	movhi	r2,33047
81147b84:	10baad04 	addi	r2,r2,-5452
81147b88:	200891ba 	slli	r4,r4,6
81147b8c:	1105883a 	add	r2,r2,r4
81147b90:	10800704 	addi	r2,r2,28
81147b94:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81147b98:	e0fffe0f 	ldh	r3,-8(fp)
81147b9c:	00a045f4 	movhi	r2,33047
81147ba0:	10baad04 	addi	r2,r2,-5452
81147ba4:	180691ba 	slli	r3,r3,6
81147ba8:	10c5883a 	add	r2,r2,r3
81147bac:	10800804 	addi	r2,r2,32
81147bb0:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147bb4:	00a045f4 	movhi	r2,33047
81147bb8:	10ba9804 	addi	r2,r2,-5536
81147bbc:	10c01417 	ldw	r3,80(r2)
81147bc0:	e13ffe0f 	ldh	r4,-8(fp)
81147bc4:	00a045f4 	movhi	r2,33047
81147bc8:	10baad04 	addi	r2,r2,-5452
81147bcc:	200891ba 	slli	r4,r4,6
81147bd0:	1105883a 	add	r2,r2,r4
81147bd4:	10800704 	addi	r2,r2,28
81147bd8:	10800017 	ldw	r2,0(r2)
81147bdc:	113fff84 	addi	r4,r2,-2
81147be0:	00a045f4 	movhi	r2,33047
81147be4:	10ba9804 	addi	r2,r2,-5536
81147be8:	10800383 	ldbu	r2,14(r2)
81147bec:	10803fcc 	andi	r2,r2,255
81147bf0:	2085383a 	mul	r2,r4,r2
81147bf4:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81147bf8:	e13ffe0f 	ldh	r4,-8(fp)
81147bfc:	00a045f4 	movhi	r2,33047
81147c00:	10baad04 	addi	r2,r2,-5452
81147c04:	200891ba 	slli	r4,r4,6
81147c08:	1105883a 	add	r2,r2,r4
81147c0c:	10800804 	addi	r2,r2,32
81147c10:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147c14:	1885883a 	add	r2,r3,r2
81147c18:	e0bffb15 	stw	r2,-20(fp)
81147c1c:	00009706 	br	81147e7c <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
81147c20:	0005883a 	mov	r2,zero
81147c24:	0000e106 	br	81147fac <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81147c28:	e13ffe0f 	ldh	r4,-8(fp)
81147c2c:	e0fffe0f 	ldh	r3,-8(fp)
81147c30:	00a045f4 	movhi	r2,33047
81147c34:	10baad04 	addi	r2,r2,-5452
81147c38:	180691ba 	slli	r3,r3,6
81147c3c:	10c5883a 	add	r2,r2,r3
81147c40:	10800804 	addi	r2,r2,32
81147c44:	10800017 	ldw	r2,0(r2)
81147c48:	10c00044 	addi	r3,r2,1
81147c4c:	00a045f4 	movhi	r2,33047
81147c50:	10baad04 	addi	r2,r2,-5452
81147c54:	200891ba 	slli	r4,r4,6
81147c58:	1105883a 	add	r2,r2,r4
81147c5c:	10800804 	addi	r2,r2,32
81147c60:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81147c64:	e0bffb17 	ldw	r2,-20(fp)
81147c68:	10800044 	addi	r2,r2,1
81147c6c:	e0bffb15 	stw	r2,-20(fp)
81147c70:	00008206 	br	81147e7c <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81147c74:	e0fffe0f 	ldh	r3,-8(fp)
81147c78:	00a045f4 	movhi	r2,33047
81147c7c:	10baad04 	addi	r2,r2,-5452
81147c80:	180691ba 	slli	r3,r3,6
81147c84:	10c5883a 	add	r2,r2,r3
81147c88:	10800904 	addi	r2,r2,36
81147c8c:	10800017 	ldw	r2,0(r2)
81147c90:	10007a26 	beq	r2,zero,81147e7c <alt_up_sd_card_write+0x4e4>
81147c94:	e0bffc0f 	ldh	r2,-16(fp)
81147c98:	1000781e 	bne	r2,zero,81147e7c <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81147c9c:	e0fffe0f 	ldh	r3,-8(fp)
81147ca0:	00a045f4 	movhi	r2,33047
81147ca4:	10baad04 	addi	r2,r2,-5452
81147ca8:	180691ba 	slli	r3,r3,6
81147cac:	10c5883a 	add	r2,r2,r3
81147cb0:	10800804 	addi	r2,r2,32
81147cb4:	10c00017 	ldw	r3,0(r2)
81147cb8:	00a045f4 	movhi	r2,33047
81147cbc:	10ba9804 	addi	r2,r2,-5536
81147cc0:	10800383 	ldbu	r2,14(r2)
81147cc4:	10803fcc 	andi	r2,r2,255
81147cc8:	10bfffc4 	addi	r2,r2,-1
81147ccc:	18803e1e 	bne	r3,r2,81147dc8 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
81147cd0:	e0bffd04 	addi	r2,fp,-12
81147cd4:	1009883a 	mov	r4,r2
81147cd8:	1145fe80 	call	81145fe8 <find_first_empty_cluster>
81147cdc:	10003826 	beq	r2,zero,81147dc0 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
81147ce0:	e0fffe0f 	ldh	r3,-8(fp)
81147ce4:	00a045f4 	movhi	r2,33047
81147ce8:	10baad04 	addi	r2,r2,-5452
81147cec:	180691ba 	slli	r3,r3,6
81147cf0:	10c5883a 	add	r2,r2,r3
81147cf4:	10800704 	addi	r2,r2,28
81147cf8:	10800017 	ldw	r2,0(r2)
81147cfc:	e0fffd17 	ldw	r3,-12(fp)
81147d00:	18ffffcc 	andi	r3,r3,65535
81147d04:	18e0001c 	xori	r3,r3,32768
81147d08:	18e00004 	addi	r3,r3,-32768
81147d0c:	01800044 	movi	r6,1
81147d10:	180b883a 	mov	r5,r3
81147d14:	1009883a 	mov	r4,r2
81147d18:	11440600 	call	81144060 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
81147d1c:	e0bffd17 	ldw	r2,-12(fp)
81147d20:	01800044 	movi	r6,1
81147d24:	017fffc4 	movi	r5,-1
81147d28:	1009883a 	mov	r4,r2
81147d2c:	11440600 	call	81144060 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
81147d30:	e0fffe0f 	ldh	r3,-8(fp)
81147d34:	00a045f4 	movhi	r2,33047
81147d38:	10baad04 	addi	r2,r2,-5452
81147d3c:	180691ba 	slli	r3,r3,6
81147d40:	10c5883a 	add	r2,r2,r3
81147d44:	10800704 	addi	r2,r2,28
81147d48:	10800017 	ldw	r2,0(r2)
81147d4c:	e0fffd17 	ldw	r3,-12(fp)
81147d50:	18ffffcc 	andi	r3,r3,65535
81147d54:	18e0001c 	xori	r3,r3,32768
81147d58:	18e00004 	addi	r3,r3,-32768
81147d5c:	000d883a 	mov	r6,zero
81147d60:	180b883a 	mov	r5,r3
81147d64:	1009883a 	mov	r4,r2
81147d68:	11440600 	call	81144060 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
81147d6c:	e0bffd17 	ldw	r2,-12(fp)
81147d70:	000d883a 	mov	r6,zero
81147d74:	017fffc4 	movi	r5,-1
81147d78:	1009883a 	mov	r4,r2
81147d7c:	11440600 	call	81144060 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
81147d80:	e13ffe0f 	ldh	r4,-8(fp)
81147d84:	e0fffd17 	ldw	r3,-12(fp)
81147d88:	00a045f4 	movhi	r2,33047
81147d8c:	10baad04 	addi	r2,r2,-5452
81147d90:	200891ba 	slli	r4,r4,6
81147d94:	1105883a 	add	r2,r2,r4
81147d98:	10800704 	addi	r2,r2,28
81147d9c:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
81147da0:	e0fffe0f 	ldh	r3,-8(fp)
81147da4:	00a045f4 	movhi	r2,33047
81147da8:	10baad04 	addi	r2,r2,-5452
81147dac:	180691ba 	slli	r3,r3,6
81147db0:	10c5883a 	add	r2,r2,r3
81147db4:	10800804 	addi	r2,r2,32
81147db8:	10000015 	stw	zero,0(r2)
81147dbc:	00001506 	br	81147e14 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
81147dc0:	0005883a 	mov	r2,zero
81147dc4:	00007906 	br	81147fac <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81147dc8:	e13ffe0f 	ldh	r4,-8(fp)
81147dcc:	e0fffe0f 	ldh	r3,-8(fp)
81147dd0:	00a045f4 	movhi	r2,33047
81147dd4:	10baad04 	addi	r2,r2,-5452
81147dd8:	180691ba 	slli	r3,r3,6
81147ddc:	10c5883a 	add	r2,r2,r3
81147de0:	10800904 	addi	r2,r2,36
81147de4:	10c00017 	ldw	r3,0(r2)
81147de8:	00a045f4 	movhi	r2,33047
81147dec:	10ba9804 	addi	r2,r2,-5536
81147df0:	1080030b 	ldhu	r2,12(r2)
81147df4:	10bfffcc 	andi	r2,r2,65535
81147df8:	1887203a 	divu	r3,r3,r2
81147dfc:	00a045f4 	movhi	r2,33047
81147e00:	10baad04 	addi	r2,r2,-5452
81147e04:	200891ba 	slli	r4,r4,6
81147e08:	1105883a 	add	r2,r2,r4
81147e0c:	10800804 	addi	r2,r2,32
81147e10:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147e14:	00a045f4 	movhi	r2,33047
81147e18:	10ba9804 	addi	r2,r2,-5536
81147e1c:	10c01417 	ldw	r3,80(r2)
81147e20:	e13ffe0f 	ldh	r4,-8(fp)
81147e24:	00a045f4 	movhi	r2,33047
81147e28:	10baad04 	addi	r2,r2,-5452
81147e2c:	200891ba 	slli	r4,r4,6
81147e30:	1105883a 	add	r2,r2,r4
81147e34:	10800704 	addi	r2,r2,28
81147e38:	10800017 	ldw	r2,0(r2)
81147e3c:	113fff84 	addi	r4,r2,-2
81147e40:	00a045f4 	movhi	r2,33047
81147e44:	10ba9804 	addi	r2,r2,-5536
81147e48:	10800383 	ldbu	r2,14(r2)
81147e4c:	10803fcc 	andi	r2,r2,255
81147e50:	2085383a 	mul	r2,r4,r2
81147e54:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
81147e58:	e13ffe0f 	ldh	r4,-8(fp)
81147e5c:	00a045f4 	movhi	r2,33047
81147e60:	10baad04 	addi	r2,r2,-5452
81147e64:	200891ba 	slli	r4,r4,6
81147e68:	1105883a 	add	r2,r2,r4
81147e6c:	10800804 	addi	r2,r2,32
81147e70:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147e74:	1885883a 	add	r2,r3,r2
81147e78:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
81147e7c:	d0e0b117 	ldw	r3,-32060(gp)
81147e80:	e0bffb17 	ldw	r2,-20(fp)
81147e84:	1885883a 	add	r2,r3,r2
81147e88:	1007883a 	mov	r3,r2
81147e8c:	d0a0b517 	ldw	r2,-32044(gp)
81147e90:	18800726 	beq	r3,r2,81147eb0 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81147e94:	d0a0b117 	ldw	r2,-32060(gp)
81147e98:	100b883a 	mov	r5,r2
81147e9c:	e13ffb17 	ldw	r4,-20(fp)
81147ea0:	1143ec40 	call	81143ec4 <Read_Sector_Data>
81147ea4:	1000021e 	bne	r2,zero,81147eb0 <alt_up_sd_card_write+0x518>
                {
					return false;
81147ea8:	0005883a 	mov	r2,zero
81147eac:	00003f06 	br	81147fac <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
81147eb0:	d0e0b017 	ldw	r3,-32064(gp)
81147eb4:	e0bffc0f 	ldh	r2,-16(fp)
81147eb8:	1885883a 	add	r2,r3,r2
81147ebc:	e0ffff07 	ldb	r3,-4(fp)
81147ec0:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81147ec4:	e13ffe0f 	ldh	r4,-8(fp)
81147ec8:	e0fffe0f 	ldh	r3,-8(fp)
81147ecc:	00a045f4 	movhi	r2,33047
81147ed0:	10baad04 	addi	r2,r2,-5452
81147ed4:	180691ba 	slli	r3,r3,6
81147ed8:	10c5883a 	add	r2,r2,r3
81147edc:	10800904 	addi	r2,r2,36
81147ee0:	10800017 	ldw	r2,0(r2)
81147ee4:	10c00044 	addi	r3,r2,1
81147ee8:	00a045f4 	movhi	r2,33047
81147eec:	10baad04 	addi	r2,r2,-5452
81147ef0:	200891ba 	slli	r4,r4,6
81147ef4:	1105883a 	add	r2,r2,r4
81147ef8:	10800904 	addi	r2,r2,36
81147efc:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
81147f00:	e0fffe0f 	ldh	r3,-8(fp)
81147f04:	00a045f4 	movhi	r2,33047
81147f08:	10baad04 	addi	r2,r2,-5452
81147f0c:	180691ba 	slli	r3,r3,6
81147f10:	10c5883a 	add	r2,r2,r3
81147f14:	10800904 	addi	r2,r2,36
81147f18:	10c00017 	ldw	r3,0(r2)
81147f1c:	e13ffe0f 	ldh	r4,-8(fp)
81147f20:	00a045f4 	movhi	r2,33047
81147f24:	10baad04 	addi	r2,r2,-5452
81147f28:	200891ba 	slli	r4,r4,6
81147f2c:	1105883a 	add	r2,r2,r4
81147f30:	10800604 	addi	r2,r2,24
81147f34:	10800017 	ldw	r2,0(r2)
81147f38:	18801736 	bltu	r3,r2,81147f98 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
81147f3c:	e13ffe0f 	ldh	r4,-8(fp)
81147f40:	e0fffe0f 	ldh	r3,-8(fp)
81147f44:	00a045f4 	movhi	r2,33047
81147f48:	10baad04 	addi	r2,r2,-5452
81147f4c:	180691ba 	slli	r3,r3,6
81147f50:	10c5883a 	add	r2,r2,r3
81147f54:	10800604 	addi	r2,r2,24
81147f58:	10800017 	ldw	r2,0(r2)
81147f5c:	10c00044 	addi	r3,r2,1
81147f60:	00a045f4 	movhi	r2,33047
81147f64:	10baad04 	addi	r2,r2,-5452
81147f68:	200891ba 	slli	r4,r4,6
81147f6c:	1105883a 	add	r2,r2,r4
81147f70:	10800604 	addi	r2,r2,24
81147f74:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
81147f78:	e0fffe0f 	ldh	r3,-8(fp)
81147f7c:	00a045f4 	movhi	r2,33047
81147f80:	10baad04 	addi	r2,r2,-5452
81147f84:	180691ba 	slli	r3,r3,6
81147f88:	10c5883a 	add	r2,r2,r3
81147f8c:	10800e04 	addi	r2,r2,56
81147f90:	00c00044 	movi	r3,1
81147f94:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81147f98:	00800044 	movi	r2,1
81147f9c:	d0a0b415 	stw	r2,-32048(gp)
			result = true;
81147fa0:	00800044 	movi	r2,1
81147fa4:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81147fa8:	e0bffa17 	ldw	r2,-24(fp)
}
81147fac:	e037883a 	mov	sp,fp
81147fb0:	dfc00117 	ldw	ra,4(sp)
81147fb4:	df000017 	ldw	fp,0(sp)
81147fb8:	dec00204 	addi	sp,sp,8
81147fbc:	f800283a 	ret

81147fc0 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
81147fc0:	defffb04 	addi	sp,sp,-20
81147fc4:	de00012e 	bgeu	sp,et,81147fcc <alt_up_sd_card_fclose+0xc>
81147fc8:	003b68fa 	trap	3
81147fcc:	dfc00415 	stw	ra,16(sp)
81147fd0:	df000315 	stw	fp,12(sp)
81147fd4:	df000304 	addi	fp,sp,12
81147fd8:	2005883a 	mov	r2,r4
81147fdc:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
81147fe0:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81147fe4:	1146b9c0 	call	81146b9c <alt_up_sd_card_is_Present>
81147fe8:	10006026 	beq	r2,zero,8114816c <alt_up_sd_card_fclose+0x1ac>
81147fec:	d0a0aa17 	ldw	r2,-32088(gp)
81147ff0:	10005e26 	beq	r2,zero,8114816c <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
81147ff4:	e0ffff0f 	ldh	r3,-4(fp)
81147ff8:	00a045f4 	movhi	r2,33047
81147ffc:	10baad04 	addi	r2,r2,-5452
81148000:	180691ba 	slli	r3,r3,6
81148004:	10c5883a 	add	r2,r2,r3
81148008:	10800f04 	addi	r2,r2,60
8114800c:	10800017 	ldw	r2,0(r2)
81148010:	10005626 	beq	r2,zero,8114816c <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
81148014:	e0ffff0f 	ldh	r3,-4(fp)
81148018:	00a045f4 	movhi	r2,33047
8114801c:	10baad04 	addi	r2,r2,-5452
81148020:	180691ba 	slli	r3,r3,6
81148024:	10c5883a 	add	r2,r2,r3
81148028:	10800e04 	addi	r2,r2,56
8114802c:	10800017 	ldw	r2,0(r2)
81148030:	10004526 	beq	r2,zero,81148148 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
81148034:	e0ffff0f 	ldh	r3,-4(fp)
81148038:	00a045f4 	movhi	r2,33047
8114803c:	10baad04 	addi	r2,r2,-5452
81148040:	180691ba 	slli	r3,r3,6
81148044:	10c5883a 	add	r2,r2,r3
81148048:	10800b04 	addi	r2,r2,44
8114804c:	10800017 	ldw	r2,0(r2)
81148050:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
81148054:	e0ffff0f 	ldh	r3,-4(fp)
81148058:	00a045f4 	movhi	r2,33047
8114805c:	10baad04 	addi	r2,r2,-5452
81148060:	180691ba 	slli	r3,r3,6
81148064:	10c5883a 	add	r2,r2,r3
81148068:	10800a04 	addi	r2,r2,40
8114806c:	10800017 	ldw	r2,0(r2)
81148070:	1000071e 	bne	r2,zero,81148090 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
81148074:	00a045f4 	movhi	r2,33047
81148078:	10ba9804 	addi	r2,r2,-5536
8114807c:	10801317 	ldw	r2,76(r2)
81148080:	e0fffe17 	ldw	r3,-8(fp)
81148084:	1885883a 	add	r2,r3,r2
81148088:	e0bffe15 	stw	r2,-8(fp)
8114808c:	00001406 	br	811480e0 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81148090:	00a045f4 	movhi	r2,33047
81148094:	10ba9804 	addi	r2,r2,-5536
81148098:	10c01417 	ldw	r3,80(r2)
8114809c:	e0bffe17 	ldw	r2,-8(fp)
811480a0:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
811480a4:	e13fff0f 	ldh	r4,-4(fp)
811480a8:	00a045f4 	movhi	r2,33047
811480ac:	10baad04 	addi	r2,r2,-5452
811480b0:	200891ba 	slli	r4,r4,6
811480b4:	1105883a 	add	r2,r2,r4
811480b8:	10800a04 	addi	r2,r2,40
811480bc:	10800017 	ldw	r2,0(r2)
811480c0:	113fff84 	addi	r4,r2,-2
811480c4:	00a045f4 	movhi	r2,33047
811480c8:	10ba9804 	addi	r2,r2,-5536
811480cc:	10800383 	ldbu	r2,14(r2)
811480d0:	10803fcc 	andi	r2,r2,255
811480d4:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
811480d8:	1885883a 	add	r2,r3,r2
811480dc:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
811480e0:	e0bffe17 	ldw	r2,-8(fp)
811480e4:	d0e0b117 	ldw	r3,-32060(gp)
811480e8:	180b883a 	mov	r5,r3
811480ec:	1009883a 	mov	r4,r2
811480f0:	1143ec40 	call	81143ec4 <Read_Sector_Data>
811480f4:	10001426 	beq	r2,zero,81148148 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
811480f8:	e0ffff0f 	ldh	r3,-4(fp)
811480fc:	00a045f4 	movhi	r2,33047
81148100:	10baad04 	addi	r2,r2,-5452
81148104:	180691ba 	slli	r3,r3,6
81148108:	10c5883a 	add	r2,r2,r3
8114810c:	10800c04 	addi	r2,r2,48
81148110:	1080000b 	ldhu	r2,0(r2)
81148114:	113fffcc 	andi	r4,r2,65535
81148118:	2120001c 	xori	r4,r4,32768
8114811c:	21200004 	addi	r4,r4,-32768
81148120:	e0bfff0f 	ldh	r2,-4(fp)
81148124:	100691ba 	slli	r3,r2,6
81148128:	00a045f4 	movhi	r2,33047
8114812c:	10baad04 	addi	r2,r2,-5452
81148130:	1885883a 	add	r2,r3,r2
81148134:	100b883a 	mov	r5,r2
81148138:	11445780 	call	81144578 <Write_File_Record_At_Offset>
8114813c:	10000226 	beq	r2,zero,81148148 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
81148140:	1143e700 	call	81143e70 <Save_Modified_Sector>
81148144:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
81148148:	e0ffff0f 	ldh	r3,-4(fp)
8114814c:	00a045f4 	movhi	r2,33047
81148150:	10baad04 	addi	r2,r2,-5452
81148154:	180691ba 	slli	r3,r3,6
81148158:	10c5883a 	add	r2,r2,r3
8114815c:	10800f04 	addi	r2,r2,60
81148160:	10000015 	stw	zero,0(r2)
			result = true;
81148164:	00800044 	movi	r2,1
81148168:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
8114816c:	e0bffd17 	ldw	r2,-12(fp)
}
81148170:	e037883a 	mov	sp,fp
81148174:	dfc00117 	ldw	ra,4(sp)
81148178:	df000017 	ldw	fp,0(sp)
8114817c:	dec00204 	addi	sp,sp,8
81148180:	f800283a 	ret

81148184 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81148184:	defffa04 	addi	sp,sp,-24
81148188:	de00012e 	bgeu	sp,et,81148190 <altera_avalon_jtag_uart_read_fd+0xc>
8114818c:	003b68fa 	trap	3
81148190:	dfc00515 	stw	ra,20(sp)
81148194:	df000415 	stw	fp,16(sp)
81148198:	df000404 	addi	fp,sp,16
8114819c:	e13ffd15 	stw	r4,-12(fp)
811481a0:	e17ffe15 	stw	r5,-8(fp)
811481a4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811481a8:	e0bffd17 	ldw	r2,-12(fp)
811481ac:	10800017 	ldw	r2,0(r2)
811481b0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
811481b4:	e0bffc17 	ldw	r2,-16(fp)
811481b8:	10c00a04 	addi	r3,r2,40
811481bc:	e0bffd17 	ldw	r2,-12(fp)
811481c0:	10800217 	ldw	r2,8(r2)
811481c4:	100f883a 	mov	r7,r2
811481c8:	e1bfff17 	ldw	r6,-4(fp)
811481cc:	e17ffe17 	ldw	r5,-8(fp)
811481d0:	1809883a 	mov	r4,r3
811481d4:	1148a080 	call	81148a08 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
811481d8:	e037883a 	mov	sp,fp
811481dc:	dfc00117 	ldw	ra,4(sp)
811481e0:	df000017 	ldw	fp,0(sp)
811481e4:	dec00204 	addi	sp,sp,8
811481e8:	f800283a 	ret

811481ec <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
811481ec:	defffa04 	addi	sp,sp,-24
811481f0:	de00012e 	bgeu	sp,et,811481f8 <altera_avalon_jtag_uart_write_fd+0xc>
811481f4:	003b68fa 	trap	3
811481f8:	dfc00515 	stw	ra,20(sp)
811481fc:	df000415 	stw	fp,16(sp)
81148200:	df000404 	addi	fp,sp,16
81148204:	e13ffd15 	stw	r4,-12(fp)
81148208:	e17ffe15 	stw	r5,-8(fp)
8114820c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81148210:	e0bffd17 	ldw	r2,-12(fp)
81148214:	10800017 	ldw	r2,0(r2)
81148218:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
8114821c:	e0bffc17 	ldw	r2,-16(fp)
81148220:	10c00a04 	addi	r3,r2,40
81148224:	e0bffd17 	ldw	r2,-12(fp)
81148228:	10800217 	ldw	r2,8(r2)
8114822c:	100f883a 	mov	r7,r2
81148230:	e1bfff17 	ldw	r6,-4(fp)
81148234:	e17ffe17 	ldw	r5,-8(fp)
81148238:	1809883a 	mov	r4,r3
8114823c:	1148ccc0 	call	81148ccc <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
81148240:	e037883a 	mov	sp,fp
81148244:	dfc00117 	ldw	ra,4(sp)
81148248:	df000017 	ldw	fp,0(sp)
8114824c:	dec00204 	addi	sp,sp,8
81148250:	f800283a 	ret

81148254 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
81148254:	defffc04 	addi	sp,sp,-16
81148258:	de00012e 	bgeu	sp,et,81148260 <altera_avalon_jtag_uart_close_fd+0xc>
8114825c:	003b68fa 	trap	3
81148260:	dfc00315 	stw	ra,12(sp)
81148264:	df000215 	stw	fp,8(sp)
81148268:	df000204 	addi	fp,sp,8
8114826c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81148270:	e0bfff17 	ldw	r2,-4(fp)
81148274:	10800017 	ldw	r2,0(r2)
81148278:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
8114827c:	e0bffe17 	ldw	r2,-8(fp)
81148280:	10c00a04 	addi	r3,r2,40
81148284:	e0bfff17 	ldw	r2,-4(fp)
81148288:	10800217 	ldw	r2,8(r2)
8114828c:	100b883a 	mov	r5,r2
81148290:	1809883a 	mov	r4,r3
81148294:	11488a00 	call	811488a0 <altera_avalon_jtag_uart_close>
}
81148298:	e037883a 	mov	sp,fp
8114829c:	dfc00117 	ldw	ra,4(sp)
811482a0:	df000017 	ldw	fp,0(sp)
811482a4:	dec00204 	addi	sp,sp,8
811482a8:	f800283a 	ret

811482ac <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
811482ac:	defffa04 	addi	sp,sp,-24
811482b0:	de00012e 	bgeu	sp,et,811482b8 <altera_avalon_jtag_uart_ioctl_fd+0xc>
811482b4:	003b68fa 	trap	3
811482b8:	dfc00515 	stw	ra,20(sp)
811482bc:	df000415 	stw	fp,16(sp)
811482c0:	df000404 	addi	fp,sp,16
811482c4:	e13ffd15 	stw	r4,-12(fp)
811482c8:	e17ffe15 	stw	r5,-8(fp)
811482cc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
811482d0:	e0bffd17 	ldw	r2,-12(fp)
811482d4:	10800017 	ldw	r2,0(r2)
811482d8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
811482dc:	e0bffc17 	ldw	r2,-16(fp)
811482e0:	10800a04 	addi	r2,r2,40
811482e4:	e1bfff17 	ldw	r6,-4(fp)
811482e8:	e17ffe17 	ldw	r5,-8(fp)
811482ec:	1009883a 	mov	r4,r2
811482f0:	11489100 	call	81148910 <altera_avalon_jtag_uart_ioctl>
}
811482f4:	e037883a 	mov	sp,fp
811482f8:	dfc00117 	ldw	ra,4(sp)
811482fc:	df000017 	ldw	fp,0(sp)
81148300:	dec00204 	addi	sp,sp,8
81148304:	f800283a 	ret

81148308 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
81148308:	deffef04 	addi	sp,sp,-68
8114830c:	de00012e 	bgeu	sp,et,81148314 <altera_avalon_jtag_uart_init+0xc>
81148310:	003b68fa 	trap	3
81148314:	dfc01015 	stw	ra,64(sp)
81148318:	df000f15 	stw	fp,60(sp)
8114831c:	dc400e15 	stw	r17,56(sp)
81148320:	dc000d15 	stw	r16,52(sp)
81148324:	df000f04 	addi	fp,sp,60
81148328:	e13ff715 	stw	r4,-36(fp)
8114832c:	e17ff815 	stw	r5,-32(fp)
81148330:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
81148334:	e0bff717 	ldw	r2,-36(fp)
81148338:	10800c04 	addi	r2,r2,48
8114833c:	e0bff215 	stw	r2,-56(fp)
81148340:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81148344:	e0bff60b 	ldhu	r2,-40(fp)
81148348:	e0fff684 	addi	r3,fp,-38
8114834c:	180b883a 	mov	r5,r3
81148350:	1009883a 	mov	r4,r2
81148354:	113c4d80 	call	8113c4d8 <OSFlagCreate>
81148358:	1007883a 	mov	r3,r2
8114835c:	e0bff217 	ldw	r2,-56(fp)
81148360:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
81148364:	e0bff717 	ldw	r2,-36(fp)
81148368:	10800a04 	addi	r2,r2,40
8114836c:	e0bff315 	stw	r2,-52(fp)
81148370:	00800044 	movi	r2,1
81148374:	e0bff58d 	sth	r2,-42(fp)
81148378:	e0bff58b 	ldhu	r2,-42(fp)
8114837c:	1009883a 	mov	r4,r2
81148380:	11404340 	call	81140434 <OSSemCreate>
81148384:	1007883a 	mov	r3,r2
81148388:	e0bff317 	ldw	r2,-52(fp)
8114838c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
81148390:	e0bff717 	ldw	r2,-36(fp)
81148394:	10800b04 	addi	r2,r2,44
81148398:	e0bff415 	stw	r2,-48(fp)
8114839c:	00800044 	movi	r2,1
811483a0:	e0bff50d 	sth	r2,-44(fp)
811483a4:	e0bff50b 	ldhu	r2,-44(fp)
811483a8:	1009883a 	mov	r4,r2
811483ac:	11404340 	call	81140434 <OSSemCreate>
811483b0:	1007883a 	mov	r3,r2
811483b4:	e0bff417 	ldw	r2,-48(fp)
811483b8:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811483bc:	e0bff717 	ldw	r2,-36(fp)
811483c0:	00c00044 	movi	r3,1
811483c4:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
811483c8:	e0bff717 	ldw	r2,-36(fp)
811483cc:	10800017 	ldw	r2,0(r2)
811483d0:	10800104 	addi	r2,r2,4
811483d4:	1007883a 	mov	r3,r2
811483d8:	e0bff717 	ldw	r2,-36(fp)
811483dc:	10800817 	ldw	r2,32(r2)
811483e0:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
811483e4:	e0bff817 	ldw	r2,-32(fp)
811483e8:	e0fff917 	ldw	r3,-28(fp)
811483ec:	d8000015 	stw	zero,0(sp)
811483f0:	e1fff717 	ldw	r7,-36(fp)
811483f4:	01a04574 	movhi	r6,33045
811483f8:	31a13604 	addi	r6,r6,-31528
811483fc:	180b883a 	mov	r5,r3
81148400:	1009883a 	mov	r4,r2
81148404:	114c2200 	call	8114c220 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
81148408:	e0bff717 	ldw	r2,-36(fp)
8114840c:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
81148410:	e0bff717 	ldw	r2,-36(fp)
81148414:	10800204 	addi	r2,r2,8
81148418:	d0e08817 	ldw	r3,-32224(gp)
8114841c:	e1fff717 	ldw	r7,-36(fp)
81148420:	01a04574 	movhi	r6,33045
81148424:	31a1e504 	addi	r6,r6,-30828
81148428:	180b883a 	mov	r5,r3
8114842c:	1009883a 	mov	r4,r2
81148430:	114bd700 	call	8114bd70 <alt_alarm_start>
81148434:	1000040e 	bge	r2,zero,81148448 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
81148438:	e0fff717 	ldw	r3,-36(fp)
8114843c:	00a00034 	movhi	r2,32768
81148440:	10bfffc4 	addi	r2,r2,-1
81148444:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
81148448:	d0a08183 	ldbu	r2,-32250(gp)
8114844c:	10803fcc 	andi	r2,r2,255
81148450:	10800058 	cmpnei	r2,r2,1
81148454:	10000f1e 	bne	r2,zero,81148494 <altera_avalon_jtag_uart_init+0x18c>
81148458:	d0e08817 	ldw	r3,-32224(gp)
8114845c:	00b33374 	movhi	r2,52429
81148460:	10b33344 	addi	r2,r2,-13107
81148464:	1888383a 	mulxuu	r4,r3,r2
81148468:	1885383a 	mul	r2,r3,r2
8114846c:	1021883a 	mov	r16,r2
81148470:	2023883a 	mov	r17,r4
81148474:	8804d0fa 	srli	r2,r17,3
81148478:	e1fff717 	ldw	r7,-36(fp)
8114847c:	01a04534 	movhi	r6,33044
81148480:	31a30204 	addi	r6,r6,-29688
81148484:	100b883a 	mov	r5,r2
81148488:	012045f4 	movhi	r4,33047
8114848c:	21226c04 	addi	r4,r4,-30288
81148490:	114bd700 	call	8114bd70 <alt_alarm_start>
81148494:	d0a08203 	ldbu	r2,-32248(gp)
81148498:	10803fcc 	andi	r2,r2,255
8114849c:	10800058 	cmpnei	r2,r2,1
811484a0:	1000051e 	bne	r2,zero,811484b8 <altera_avalon_jtag_uart_init+0x1b0>
811484a4:	e0bff717 	ldw	r2,-36(fp)
811484a8:	10800017 	ldw	r2,0(r2)
811484ac:	100b883a 	mov	r5,r2
811484b0:	e13ff717 	ldw	r4,-36(fp)
811484b4:	1138da00 	call	81138da0 <alt_log_jtag_uart_startup_info>
}
811484b8:	0001883a 	nop
811484bc:	e6fffe04 	addi	sp,fp,-8
811484c0:	dfc00317 	ldw	ra,12(sp)
811484c4:	df000217 	ldw	fp,8(sp)
811484c8:	dc400117 	ldw	r17,4(sp)
811484cc:	dc000017 	ldw	r16,0(sp)
811484d0:	dec00404 	addi	sp,sp,16
811484d4:	f800283a 	ret

811484d8 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
811484d8:	defff204 	addi	sp,sp,-56
811484dc:	de00012e 	bgeu	sp,et,811484e4 <altera_avalon_jtag_uart_irq+0xc>
811484e0:	003b68fa 	trap	3
811484e4:	dfc00d15 	stw	ra,52(sp)
811484e8:	df000c15 	stw	fp,48(sp)
811484ec:	df000c04 	addi	fp,sp,48
811484f0:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
811484f4:	e0bfff17 	ldw	r2,-4(fp)
811484f8:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
811484fc:	e0bff617 	ldw	r2,-40(fp)
81148500:	10800017 	ldw	r2,0(r2)
81148504:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
81148508:	e0bff717 	ldw	r2,-36(fp)
8114850c:	e17ff617 	ldw	r5,-40(fp)
81148510:	1009883a 	mov	r4,r2
81148514:	1138df40 	call	81138df4 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81148518:	e0bff717 	ldw	r2,-36(fp)
8114851c:	10800104 	addi	r2,r2,4
81148520:	10800037 	ldwio	r2,0(r2)
81148524:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
81148528:	e0bff817 	ldw	r2,-32(fp)
8114852c:	1080c00c 	andi	r2,r2,768
81148530:	10009126 	beq	r2,zero,81148778 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
81148534:	e0bff817 	ldw	r2,-32(fp)
81148538:	1080400c 	andi	r2,r2,256
8114853c:	10004726 	beq	r2,zero,8114865c <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
81148540:	00800074 	movhi	r2,1
81148544:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81148548:	e0bff617 	ldw	r2,-40(fp)
8114854c:	10800d17 	ldw	r2,52(r2)
81148550:	10800044 	addi	r2,r2,1
81148554:	1081ffcc 	andi	r2,r2,2047
81148558:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
8114855c:	e0bff617 	ldw	r2,-40(fp)
81148560:	10c00e17 	ldw	r3,56(r2)
81148564:	e0bff917 	ldw	r2,-28(fp)
81148568:	18802726 	beq	r3,r2,81148608 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
8114856c:	e0bff717 	ldw	r2,-36(fp)
81148570:	10800037 	ldwio	r2,0(r2)
81148574:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
81148578:	e0bff417 	ldw	r2,-48(fp)
8114857c:	10a0000c 	andi	r2,r2,32768
81148580:	10002326 	beq	r2,zero,81148610 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
81148584:	e0bff617 	ldw	r2,-40(fp)
81148588:	10800d17 	ldw	r2,52(r2)
8114858c:	e0fff417 	ldw	r3,-48(fp)
81148590:	1809883a 	mov	r4,r3
81148594:	e0fff617 	ldw	r3,-40(fp)
81148598:	1885883a 	add	r2,r3,r2
8114859c:	10801104 	addi	r2,r2,68
811485a0:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811485a4:	e0bff617 	ldw	r2,-40(fp)
811485a8:	10800d17 	ldw	r2,52(r2)
811485ac:	10800044 	addi	r2,r2,1
811485b0:	10c1ffcc 	andi	r3,r2,2047
811485b4:	e0bff617 	ldw	r2,-40(fp)
811485b8:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
811485bc:	e0bff617 	ldw	r2,-40(fp)
811485c0:	10800c17 	ldw	r2,48(r2)
811485c4:	e0bffb15 	stw	r2,-20(fp)
811485c8:	00800044 	movi	r2,1
811485cc:	e0bffc0d 	sth	r2,-16(fp)
811485d0:	00800044 	movi	r2,1
811485d4:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811485d8:	d0a09103 	ldbu	r2,-32188(gp)
811485dc:	10803fcc 	andi	r2,r2,255
811485e0:	103fd926 	beq	r2,zero,81148548 <__reset+0xfb128548>
  {
    OSFlagPost (group, flags, opt, &err);
811485e4:	e0bffc0b 	ldhu	r2,-16(fp)
811485e8:	e0fffc83 	ldbu	r3,-14(fp)
811485ec:	e13ffdc4 	addi	r4,fp,-9
811485f0:	200f883a 	mov	r7,r4
811485f4:	180d883a 	mov	r6,r3
811485f8:	100b883a 	mov	r5,r2
811485fc:	e13ffb17 	ldw	r4,-20(fp)
81148600:	113d0e40 	call	8113d0e4 <OSFlagPost>
      }
81148604:	003fd006 	br	81148548 <__reset+0xfb128548>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
81148608:	0001883a 	nop
8114860c:	00000106 	br	81148614 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
81148610:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
81148614:	e0bff417 	ldw	r2,-48(fp)
81148618:	10bfffec 	andhi	r2,r2,65535
8114861c:	10000f26 	beq	r2,zero,8114865c <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81148620:	e0bff617 	ldw	r2,-40(fp)
81148624:	10c00817 	ldw	r3,32(r2)
81148628:	00bfff84 	movi	r2,-2
8114862c:	1886703a 	and	r3,r3,r2
81148630:	e0bff617 	ldw	r2,-40(fp)
81148634:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
81148638:	e0bff717 	ldw	r2,-36(fp)
8114863c:	10800104 	addi	r2,r2,4
81148640:	1007883a 	mov	r3,r2
81148644:	e0bff617 	ldw	r2,-40(fp)
81148648:	10800817 	ldw	r2,32(r2)
8114864c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81148650:	e0bff717 	ldw	r2,-36(fp)
81148654:	10800104 	addi	r2,r2,4
81148658:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
8114865c:	e0bff817 	ldw	r2,-32(fp)
81148660:	1080800c 	andi	r2,r2,512
81148664:	103fac26 	beq	r2,zero,81148518 <__reset+0xfb128518>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
81148668:	e0bff817 	ldw	r2,-32(fp)
8114866c:	1004d43a 	srli	r2,r2,16
81148670:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
81148674:	00002606 	br	81148710 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
81148678:	e0bff717 	ldw	r2,-36(fp)
8114867c:	e0fff617 	ldw	r3,-40(fp)
81148680:	18c01017 	ldw	r3,64(r3)
81148684:	e13ff617 	ldw	r4,-40(fp)
81148688:	20c7883a 	add	r3,r4,r3
8114868c:	18c21104 	addi	r3,r3,2116
81148690:	18c00003 	ldbu	r3,0(r3)
81148694:	18c03fcc 	andi	r3,r3,255
81148698:	18c0201c 	xori	r3,r3,128
8114869c:	18ffe004 	addi	r3,r3,-128
811486a0:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811486a4:	e0bff617 	ldw	r2,-40(fp)
811486a8:	10801017 	ldw	r2,64(r2)
811486ac:	10800044 	addi	r2,r2,1
811486b0:	10c1ffcc 	andi	r3,r2,2047
811486b4:	e0bff617 	ldw	r2,-40(fp)
811486b8:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
811486bc:	e0bff617 	ldw	r2,-40(fp)
811486c0:	10800c17 	ldw	r2,48(r2)
811486c4:	e0bffa15 	stw	r2,-24(fp)
811486c8:	00800084 	movi	r2,2
811486cc:	e0bffd0d 	sth	r2,-12(fp)
811486d0:	00800044 	movi	r2,1
811486d4:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811486d8:	d0a09103 	ldbu	r2,-32188(gp)
811486dc:	10803fcc 	andi	r2,r2,255
811486e0:	10000826 	beq	r2,zero,81148704 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
811486e4:	e0bffd0b 	ldhu	r2,-12(fp)
811486e8:	e0fffd83 	ldbu	r3,-10(fp)
811486ec:	e13ffe04 	addi	r4,fp,-8
811486f0:	200f883a 	mov	r7,r4
811486f4:	180d883a 	mov	r6,r3
811486f8:	100b883a 	mov	r5,r2
811486fc:	e13ffa17 	ldw	r4,-24(fp)
81148700:	113d0e40 	call	8113d0e4 <OSFlagPost>

        space--;
81148704:	e0bff517 	ldw	r2,-44(fp)
81148708:	10bfffc4 	addi	r2,r2,-1
8114870c:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
81148710:	e0bff517 	ldw	r2,-44(fp)
81148714:	10000526 	beq	r2,zero,8114872c <altera_avalon_jtag_uart_irq+0x254>
81148718:	e0bff617 	ldw	r2,-40(fp)
8114871c:	10c01017 	ldw	r3,64(r2)
81148720:	e0bff617 	ldw	r2,-40(fp)
81148724:	10800f17 	ldw	r2,60(r2)
81148728:	18bfd31e 	bne	r3,r2,81148678 <__reset+0xfb128678>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
8114872c:	e0bff517 	ldw	r2,-44(fp)
81148730:	103f7926 	beq	r2,zero,81148518 <__reset+0xfb128518>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81148734:	e0bff617 	ldw	r2,-40(fp)
81148738:	10c00817 	ldw	r3,32(r2)
8114873c:	00bfff44 	movi	r2,-3
81148740:	1886703a 	and	r3,r3,r2
81148744:	e0bff617 	ldw	r2,-40(fp)
81148748:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
8114874c:	e0bff617 	ldw	r2,-40(fp)
81148750:	10800017 	ldw	r2,0(r2)
81148754:	10800104 	addi	r2,r2,4
81148758:	1007883a 	mov	r3,r2
8114875c:	e0bff617 	ldw	r2,-40(fp)
81148760:	10800817 	ldw	r2,32(r2)
81148764:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81148768:	e0bff717 	ldw	r2,-36(fp)
8114876c:	10800104 	addi	r2,r2,4
81148770:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
81148774:	003f6806 	br	81148518 <__reset+0xfb128518>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
81148778:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
8114877c:	0001883a 	nop
81148780:	e037883a 	mov	sp,fp
81148784:	dfc00117 	ldw	ra,4(sp)
81148788:	df000017 	ldw	fp,0(sp)
8114878c:	dec00204 	addi	sp,sp,8
81148790:	f800283a 	ret

81148794 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
81148794:	defff904 	addi	sp,sp,-28
81148798:	de00012e 	bgeu	sp,et,811487a0 <altera_avalon_jtag_uart_timeout+0xc>
8114879c:	003b68fa 	trap	3
811487a0:	dfc00615 	stw	ra,24(sp)
811487a4:	df000515 	stw	fp,20(sp)
811487a8:	df000504 	addi	fp,sp,20
811487ac:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
811487b0:	e0bfff17 	ldw	r2,-4(fp)
811487b4:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
811487b8:	e0bffb17 	ldw	r2,-20(fp)
811487bc:	10800017 	ldw	r2,0(r2)
811487c0:	10800104 	addi	r2,r2,4
811487c4:	10800037 	ldwio	r2,0(r2)
811487c8:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
811487cc:	e0bffc17 	ldw	r2,-16(fp)
811487d0:	1081000c 	andi	r2,r2,1024
811487d4:	10000b26 	beq	r2,zero,81148804 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
811487d8:	e0bffb17 	ldw	r2,-20(fp)
811487dc:	10800017 	ldw	r2,0(r2)
811487e0:	10800104 	addi	r2,r2,4
811487e4:	1007883a 	mov	r3,r2
811487e8:	e0bffb17 	ldw	r2,-20(fp)
811487ec:	10800817 	ldw	r2,32(r2)
811487f0:	10810014 	ori	r2,r2,1024
811487f4:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
811487f8:	e0bffb17 	ldw	r2,-20(fp)
811487fc:	10000915 	stw	zero,36(r2)
81148800:	00002106 	br	81148888 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81148804:	e0bffb17 	ldw	r2,-20(fp)
81148808:	10c00917 	ldw	r3,36(r2)
8114880c:	00a00034 	movhi	r2,32768
81148810:	10bfff04 	addi	r2,r2,-4
81148814:	10c01c36 	bltu	r2,r3,81148888 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81148818:	e0bffb17 	ldw	r2,-20(fp)
8114881c:	10800917 	ldw	r2,36(r2)
81148820:	10c00044 	addi	r3,r2,1
81148824:	e0bffb17 	ldw	r2,-20(fp)
81148828:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
8114882c:	e0bffb17 	ldw	r2,-20(fp)
81148830:	10c00917 	ldw	r3,36(r2)
81148834:	e0bffb17 	ldw	r2,-20(fp)
81148838:	10800117 	ldw	r2,4(r2)
8114883c:	18801236 	bltu	r3,r2,81148888 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
81148840:	e0bffb17 	ldw	r2,-20(fp)
81148844:	10800c17 	ldw	r2,48(r2)
81148848:	e0bffd15 	stw	r2,-12(fp)
8114884c:	00800104 	movi	r2,4
81148850:	e0bffe0d 	sth	r2,-8(fp)
81148854:	00800044 	movi	r2,1
81148858:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8114885c:	d0a09103 	ldbu	r2,-32188(gp)
81148860:	10803fcc 	andi	r2,r2,255
81148864:	10000826 	beq	r2,zero,81148888 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81148868:	e0bffe0b 	ldhu	r2,-8(fp)
8114886c:	e0fffe83 	ldbu	r3,-6(fp)
81148870:	e13ffec4 	addi	r4,fp,-5
81148874:	200f883a 	mov	r7,r4
81148878:	180d883a 	mov	r6,r3
8114887c:	100b883a 	mov	r5,r2
81148880:	e13ffd17 	ldw	r4,-12(fp)
81148884:	113d0e40 	call	8113d0e4 <OSFlagPost>
81148888:	d0a08817 	ldw	r2,-32224(gp)
    }
  }

  return alt_ticks_per_second();
}
8114888c:	e037883a 	mov	sp,fp
81148890:	dfc00117 	ldw	ra,4(sp)
81148894:	df000017 	ldw	fp,0(sp)
81148898:	dec00204 	addi	sp,sp,8
8114889c:	f800283a 	ret

811488a0 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
811488a0:	defffd04 	addi	sp,sp,-12
811488a4:	de00012e 	bgeu	sp,et,811488ac <altera_avalon_jtag_uart_close+0xc>
811488a8:	003b68fa 	trap	3
811488ac:	df000215 	stw	fp,8(sp)
811488b0:	df000204 	addi	fp,sp,8
811488b4:	e13ffe15 	stw	r4,-8(fp)
811488b8:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
811488bc:	00000506 	br	811488d4 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
811488c0:	e0bfff17 	ldw	r2,-4(fp)
811488c4:	1090000c 	andi	r2,r2,16384
811488c8:	10000226 	beq	r2,zero,811488d4 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
811488cc:	00bffd44 	movi	r2,-11
811488d0:	00000b06 	br	81148900 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
811488d4:	e0bffe17 	ldw	r2,-8(fp)
811488d8:	10c01017 	ldw	r3,64(r2)
811488dc:	e0bffe17 	ldw	r2,-8(fp)
811488e0:	10800f17 	ldw	r2,60(r2)
811488e4:	18800526 	beq	r3,r2,811488fc <altera_avalon_jtag_uart_close+0x5c>
811488e8:	e0bffe17 	ldw	r2,-8(fp)
811488ec:	10c00917 	ldw	r3,36(r2)
811488f0:	e0bffe17 	ldw	r2,-8(fp)
811488f4:	10800117 	ldw	r2,4(r2)
811488f8:	18bff136 	bltu	r3,r2,811488c0 <__reset+0xfb1288c0>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
811488fc:	0005883a 	mov	r2,zero
}
81148900:	e037883a 	mov	sp,fp
81148904:	df000017 	ldw	fp,0(sp)
81148908:	dec00104 	addi	sp,sp,4
8114890c:	f800283a 	ret

81148910 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81148910:	defffa04 	addi	sp,sp,-24
81148914:	de00012e 	bgeu	sp,et,8114891c <altera_avalon_jtag_uart_ioctl+0xc>
81148918:	003b68fa 	trap	3
8114891c:	df000515 	stw	fp,20(sp)
81148920:	df000504 	addi	fp,sp,20
81148924:	e13ffd15 	stw	r4,-12(fp)
81148928:	e17ffe15 	stw	r5,-8(fp)
8114892c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81148930:	00bff9c4 	movi	r2,-25
81148934:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81148938:	e0bffe17 	ldw	r2,-8(fp)
8114893c:	10da8060 	cmpeqi	r3,r2,27137
81148940:	1800031e 	bne	r3,zero,81148950 <altera_avalon_jtag_uart_ioctl+0x40>
81148944:	109a80a0 	cmpeqi	r2,r2,27138
81148948:	1000181e 	bne	r2,zero,811489ac <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
8114894c:	00002906 	br	811489f4 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
81148950:	e0bffd17 	ldw	r2,-12(fp)
81148954:	10c00117 	ldw	r3,4(r2)
81148958:	00a00034 	movhi	r2,32768
8114895c:	10bfffc4 	addi	r2,r2,-1
81148960:	18802126 	beq	r3,r2,811489e8 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
81148964:	e0bfff17 	ldw	r2,-4(fp)
81148968:	10800017 	ldw	r2,0(r2)
8114896c:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81148970:	e0bffc17 	ldw	r2,-16(fp)
81148974:	10800090 	cmplti	r2,r2,2
81148978:	1000061e 	bne	r2,zero,81148994 <altera_avalon_jtag_uart_ioctl+0x84>
8114897c:	e0fffc17 	ldw	r3,-16(fp)
81148980:	00a00034 	movhi	r2,32768
81148984:	10bfffc4 	addi	r2,r2,-1
81148988:	18800226 	beq	r3,r2,81148994 <altera_avalon_jtag_uart_ioctl+0x84>
8114898c:	e0bffc17 	ldw	r2,-16(fp)
81148990:	00000206 	br	8114899c <altera_avalon_jtag_uart_ioctl+0x8c>
81148994:	00a00034 	movhi	r2,32768
81148998:	10bfff84 	addi	r2,r2,-2
8114899c:	e0fffd17 	ldw	r3,-12(fp)
811489a0:	18800115 	stw	r2,4(r3)
      rc = 0;
811489a4:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
811489a8:	00000f06 	br	811489e8 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
811489ac:	e0bffd17 	ldw	r2,-12(fp)
811489b0:	10c00117 	ldw	r3,4(r2)
811489b4:	00a00034 	movhi	r2,32768
811489b8:	10bfffc4 	addi	r2,r2,-1
811489bc:	18800c26 	beq	r3,r2,811489f0 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
811489c0:	e0bffd17 	ldw	r2,-12(fp)
811489c4:	10c00917 	ldw	r3,36(r2)
811489c8:	e0bffd17 	ldw	r2,-12(fp)
811489cc:	10800117 	ldw	r2,4(r2)
811489d0:	1885803a 	cmpltu	r2,r3,r2
811489d4:	10c03fcc 	andi	r3,r2,255
811489d8:	e0bfff17 	ldw	r2,-4(fp)
811489dc:	10c00015 	stw	r3,0(r2)
      rc = 0;
811489e0:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
811489e4:	00000206 	br	811489f0 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
811489e8:	0001883a 	nop
811489ec:	00000106 	br	811489f4 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
811489f0:	0001883a 	nop

  default:
    break;
  }

  return rc;
811489f4:	e0bffb17 	ldw	r2,-20(fp)
}
811489f8:	e037883a 	mov	sp,fp
811489fc:	df000017 	ldw	fp,0(sp)
81148a00:	dec00104 	addi	sp,sp,4
81148a04:	f800283a 	ret

81148a08 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
81148a08:	deffed04 	addi	sp,sp,-76
81148a0c:	de00012e 	bgeu	sp,et,81148a14 <altera_avalon_jtag_uart_read+0xc>
81148a10:	003b68fa 	trap	3
81148a14:	dfc01215 	stw	ra,72(sp)
81148a18:	df001115 	stw	fp,68(sp)
81148a1c:	df001104 	addi	fp,sp,68
81148a20:	e13ffc15 	stw	r4,-16(fp)
81148a24:	e17ffd15 	stw	r5,-12(fp)
81148a28:	e1bffe15 	stw	r6,-8(fp)
81148a2c:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
81148a30:	e0bffd17 	ldw	r2,-12(fp)
81148a34:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
81148a38:	e0bffc17 	ldw	r2,-16(fp)
81148a3c:	10800a17 	ldw	r2,40(r2)
81148a40:	e0bff815 	stw	r2,-32(fp)
81148a44:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81148a48:	e0bff90b 	ldhu	r2,-28(fp)
81148a4c:	e0fffb04 	addi	r3,fp,-20
81148a50:	180d883a 	mov	r6,r3
81148a54:	100b883a 	mov	r5,r2
81148a58:	e13ff817 	ldw	r4,-32(fp)
81148a5c:	114075c0 	call	8114075c <OSSemPend>

  while (space > 0)
81148a60:	00006106 	br	81148be8 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
81148a64:	e0bffc17 	ldw	r2,-16(fp)
81148a68:	10800d17 	ldw	r2,52(r2)
81148a6c:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
81148a70:	e0bffc17 	ldw	r2,-16(fp)
81148a74:	10800e17 	ldw	r2,56(r2)
81148a78:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81148a7c:	e0fff317 	ldw	r3,-52(fp)
81148a80:	e0bff417 	ldw	r2,-48(fp)
81148a84:	18800536 	bltu	r3,r2,81148a9c <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81148a88:	e0fff317 	ldw	r3,-52(fp)
81148a8c:	e0bff417 	ldw	r2,-48(fp)
81148a90:	1885c83a 	sub	r2,r3,r2
81148a94:	e0bff115 	stw	r2,-60(fp)
81148a98:	00000406 	br	81148aac <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81148a9c:	00c20004 	movi	r3,2048
81148aa0:	e0bff417 	ldw	r2,-48(fp)
81148aa4:	1885c83a 	sub	r2,r3,r2
81148aa8:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81148aac:	e0bff117 	ldw	r2,-60(fp)
81148ab0:	10001e26 	beq	r2,zero,81148b2c <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81148ab4:	e0fffe17 	ldw	r3,-8(fp)
81148ab8:	e0bff117 	ldw	r2,-60(fp)
81148abc:	1880022e 	bgeu	r3,r2,81148ac8 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81148ac0:	e0bffe17 	ldw	r2,-8(fp)
81148ac4:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81148ac8:	e0bffc17 	ldw	r2,-16(fp)
81148acc:	10c01104 	addi	r3,r2,68
81148ad0:	e0bff417 	ldw	r2,-48(fp)
81148ad4:	1885883a 	add	r2,r3,r2
81148ad8:	e1bff117 	ldw	r6,-60(fp)
81148adc:	100b883a 	mov	r5,r2
81148ae0:	e13ff017 	ldw	r4,-64(fp)
81148ae4:	11243500 	call	81124350 <memcpy>
      ptr   += n;
81148ae8:	e0fff017 	ldw	r3,-64(fp)
81148aec:	e0bff117 	ldw	r2,-60(fp)
81148af0:	1885883a 	add	r2,r3,r2
81148af4:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81148af8:	e0fffe17 	ldw	r3,-8(fp)
81148afc:	e0bff117 	ldw	r2,-60(fp)
81148b00:	1885c83a 	sub	r2,r3,r2
81148b04:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81148b08:	e0fff417 	ldw	r3,-48(fp)
81148b0c:	e0bff117 	ldw	r2,-60(fp)
81148b10:	1885883a 	add	r2,r3,r2
81148b14:	10c1ffcc 	andi	r3,r2,2047
81148b18:	e0bffc17 	ldw	r2,-16(fp)
81148b1c:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81148b20:	e0bffe17 	ldw	r2,-8(fp)
81148b24:	00bfcf16 	blt	zero,r2,81148a64 <__reset+0xfb128a64>
81148b28:	00000106 	br	81148b30 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81148b2c:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
81148b30:	e0fff017 	ldw	r3,-64(fp)
81148b34:	e0bffd17 	ldw	r2,-12(fp)
81148b38:	18802e1e 	bne	r3,r2,81148bf4 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
81148b3c:	e0bfff17 	ldw	r2,-4(fp)
81148b40:	1090000c 	andi	r2,r2,16384
81148b44:	10002d1e 	bne	r2,zero,81148bfc <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
81148b48:	d0a09103 	ldbu	r2,-32188(gp)
81148b4c:	10803fcc 	andi	r2,r2,255
81148b50:	10800058 	cmpnei	r2,r2,1
81148b54:	1000161e 	bne	r2,zero,81148bb0 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
81148b58:	e0bffc17 	ldw	r2,-16(fp)
81148b5c:	10800c17 	ldw	r2,48(r2)
81148b60:	e0bff215 	stw	r2,-56(fp)
81148b64:	00800144 	movi	r2,5
81148b68:	e0bff98d 	sth	r2,-26(fp)
81148b6c:	00bfe0c4 	movi	r2,-125
81148b70:	e0bffa05 	stb	r2,-24(fp)
81148b74:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81148b78:	d0a09103 	ldbu	r2,-32188(gp)
81148b7c:	10803fcc 	andi	r2,r2,255
81148b80:	10001526 	beq	r2,zero,81148bd8 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81148b84:	e0fff98b 	ldhu	r3,-26(fp)
81148b88:	e13ffa03 	ldbu	r4,-24(fp)
81148b8c:	e17ffa8b 	ldhu	r5,-22(fp)
81148b90:	e0bffb44 	addi	r2,fp,-19
81148b94:	d8800015 	stw	r2,0(sp)
81148b98:	280f883a 	mov	r7,r5
81148b9c:	200d883a 	mov	r6,r4
81148ba0:	180b883a 	mov	r5,r3
81148ba4:	e13ff217 	ldw	r4,-56(fp)
81148ba8:	113cabc0 	call	8113cabc <OSFlagPend>
81148bac:	00000a06 	br	81148bd8 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81148bb0:	0001883a 	nop
81148bb4:	e0bffc17 	ldw	r2,-16(fp)
81148bb8:	10c00d17 	ldw	r3,52(r2)
81148bbc:	e0bff317 	ldw	r2,-52(fp)
81148bc0:	1880051e 	bne	r3,r2,81148bd8 <altera_avalon_jtag_uart_read+0x1d0>
81148bc4:	e0bffc17 	ldw	r2,-16(fp)
81148bc8:	10c00917 	ldw	r3,36(r2)
81148bcc:	e0bffc17 	ldw	r2,-16(fp)
81148bd0:	10800117 	ldw	r2,4(r2)
81148bd4:	18bff736 	bltu	r3,r2,81148bb4 <__reset+0xfb128bb4>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81148bd8:	e0bffc17 	ldw	r2,-16(fp)
81148bdc:	10c00d17 	ldw	r3,52(r2)
81148be0:	e0bff317 	ldw	r2,-52(fp)
81148be4:	18800726 	beq	r3,r2,81148c04 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81148be8:	e0bffe17 	ldw	r2,-8(fp)
81148bec:	00bf9d16 	blt	zero,r2,81148a64 <__reset+0xfb128a64>
81148bf0:	00000506 	br	81148c08 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81148bf4:	0001883a 	nop
81148bf8:	00000306 	br	81148c08 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81148bfc:	0001883a 	nop
81148c00:	00000106 	br	81148c08 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81148c04:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81148c08:	e0bffc17 	ldw	r2,-16(fp)
81148c0c:	10800a17 	ldw	r2,40(r2)
81148c10:	1009883a 	mov	r4,r2
81148c14:	1140ae40 	call	81140ae4 <OSSemPost>

  if (ptr != buffer)
81148c18:	e0fff017 	ldw	r3,-64(fp)
81148c1c:	e0bffd17 	ldw	r2,-12(fp)
81148c20:	18801826 	beq	r3,r2,81148c84 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148c24:	0005303a 	rdctl	r2,status
81148c28:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148c2c:	e0fff717 	ldw	r3,-36(fp)
81148c30:	00bfff84 	movi	r2,-2
81148c34:	1884703a 	and	r2,r3,r2
81148c38:	1001703a 	wrctl	status,r2
  
  return context;
81148c3c:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
81148c40:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81148c44:	e0bffc17 	ldw	r2,-16(fp)
81148c48:	10800817 	ldw	r2,32(r2)
81148c4c:	10c00054 	ori	r3,r2,1
81148c50:	e0bffc17 	ldw	r2,-16(fp)
81148c54:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81148c58:	e0bffc17 	ldw	r2,-16(fp)
81148c5c:	10800017 	ldw	r2,0(r2)
81148c60:	10800104 	addi	r2,r2,4
81148c64:	1007883a 	mov	r3,r2
81148c68:	e0bffc17 	ldw	r2,-16(fp)
81148c6c:	10800817 	ldw	r2,32(r2)
81148c70:	18800035 	stwio	r2,0(r3)
81148c74:	e0bff617 	ldw	r2,-40(fp)
81148c78:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148c7c:	e0bff517 	ldw	r2,-44(fp)
81148c80:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
81148c84:	e0fff017 	ldw	r3,-64(fp)
81148c88:	e0bffd17 	ldw	r2,-12(fp)
81148c8c:	18800426 	beq	r3,r2,81148ca0 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
81148c90:	e0fff017 	ldw	r3,-64(fp)
81148c94:	e0bffd17 	ldw	r2,-12(fp)
81148c98:	1885c83a 	sub	r2,r3,r2
81148c9c:	00000606 	br	81148cb8 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
81148ca0:	e0bfff17 	ldw	r2,-4(fp)
81148ca4:	1090000c 	andi	r2,r2,16384
81148ca8:	10000226 	beq	r2,zero,81148cb4 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81148cac:	00bffd44 	movi	r2,-11
81148cb0:	00000106 	br	81148cb8 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81148cb4:	00bffec4 	movi	r2,-5
}
81148cb8:	e037883a 	mov	sp,fp
81148cbc:	dfc00117 	ldw	ra,4(sp)
81148cc0:	df000017 	ldw	fp,0(sp)
81148cc4:	dec00204 	addi	sp,sp,8
81148cc8:	f800283a 	ret

81148ccc <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81148ccc:	deffed04 	addi	sp,sp,-76
81148cd0:	de00012e 	bgeu	sp,et,81148cd8 <altera_avalon_jtag_uart_write+0xc>
81148cd4:	003b68fa 	trap	3
81148cd8:	dfc01215 	stw	ra,72(sp)
81148cdc:	df001115 	stw	fp,68(sp)
81148ce0:	df001104 	addi	fp,sp,68
81148ce4:	e13ffc15 	stw	r4,-16(fp)
81148ce8:	e17ffd15 	stw	r5,-12(fp)
81148cec:	e1bffe15 	stw	r6,-8(fp)
81148cf0:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
81148cf4:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
81148cf8:	e0bffd17 	ldw	r2,-12(fp)
81148cfc:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
81148d00:	e0bffc17 	ldw	r2,-16(fp)
81148d04:	10800b17 	ldw	r2,44(r2)
81148d08:	e0bff815 	stw	r2,-32(fp)
81148d0c:	e03ff90d 	sth	zero,-28(fp)
81148d10:	e0bff90b 	ldhu	r2,-28(fp)
81148d14:	e0fffb44 	addi	r3,fp,-19
81148d18:	180d883a 	mov	r6,r3
81148d1c:	100b883a 	mov	r5,r2
81148d20:	e13ff817 	ldw	r4,-32(fp)
81148d24:	114075c0 	call	8114075c <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81148d28:	00003706 	br	81148e08 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
81148d2c:	e0bffc17 	ldw	r2,-16(fp)
81148d30:	10800f17 	ldw	r2,60(r2)
81148d34:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
81148d38:	e0bffc17 	ldw	r2,-16(fp)
81148d3c:	10801017 	ldw	r2,64(r2)
81148d40:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
81148d44:	e0fff417 	ldw	r3,-48(fp)
81148d48:	e0bff017 	ldw	r2,-64(fp)
81148d4c:	1880062e 	bgeu	r3,r2,81148d68 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
81148d50:	e0fff017 	ldw	r3,-64(fp)
81148d54:	e0bff417 	ldw	r2,-48(fp)
81148d58:	1885c83a 	sub	r2,r3,r2
81148d5c:	10bfffc4 	addi	r2,r2,-1
81148d60:	e0bff115 	stw	r2,-60(fp)
81148d64:	00000b06 	br	81148d94 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81148d68:	e0bff017 	ldw	r2,-64(fp)
81148d6c:	10000526 	beq	r2,zero,81148d84 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
81148d70:	00c20004 	movi	r3,2048
81148d74:	e0bff417 	ldw	r2,-48(fp)
81148d78:	1885c83a 	sub	r2,r3,r2
81148d7c:	e0bff115 	stw	r2,-60(fp)
81148d80:	00000406 	br	81148d94 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
81148d84:	00c1ffc4 	movi	r3,2047
81148d88:	e0bff417 	ldw	r2,-48(fp)
81148d8c:	1885c83a 	sub	r2,r3,r2
81148d90:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81148d94:	e0bff117 	ldw	r2,-60(fp)
81148d98:	10001e26 	beq	r2,zero,81148e14 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81148d9c:	e0fffe17 	ldw	r3,-8(fp)
81148da0:	e0bff117 	ldw	r2,-60(fp)
81148da4:	1880022e 	bgeu	r3,r2,81148db0 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81148da8:	e0bffe17 	ldw	r2,-8(fp)
81148dac:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
81148db0:	e0bffc17 	ldw	r2,-16(fp)
81148db4:	10c21104 	addi	r3,r2,2116
81148db8:	e0bff417 	ldw	r2,-48(fp)
81148dbc:	1885883a 	add	r2,r3,r2
81148dc0:	e1bff117 	ldw	r6,-60(fp)
81148dc4:	e17ffd17 	ldw	r5,-12(fp)
81148dc8:	1009883a 	mov	r4,r2
81148dcc:	11243500 	call	81124350 <memcpy>
      ptr   += n;
81148dd0:	e0fffd17 	ldw	r3,-12(fp)
81148dd4:	e0bff117 	ldw	r2,-60(fp)
81148dd8:	1885883a 	add	r2,r3,r2
81148ddc:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
81148de0:	e0fffe17 	ldw	r3,-8(fp)
81148de4:	e0bff117 	ldw	r2,-60(fp)
81148de8:	1885c83a 	sub	r2,r3,r2
81148dec:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81148df0:	e0fff417 	ldw	r3,-48(fp)
81148df4:	e0bff117 	ldw	r2,-60(fp)
81148df8:	1885883a 	add	r2,r3,r2
81148dfc:	10c1ffcc 	andi	r3,r2,2047
81148e00:	e0bffc17 	ldw	r2,-16(fp)
81148e04:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81148e08:	e0bffe17 	ldw	r2,-8(fp)
81148e0c:	00bfc716 	blt	zero,r2,81148d2c <__reset+0xfb128d2c>
81148e10:	00000106 	br	81148e18 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
81148e14:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148e18:	0005303a 	rdctl	r2,status
81148e1c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148e20:	e0fff717 	ldw	r3,-36(fp)
81148e24:	00bfff84 	movi	r2,-2
81148e28:	1884703a 	and	r2,r3,r2
81148e2c:	1001703a 	wrctl	status,r2
  
  return context;
81148e30:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
81148e34:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81148e38:	e0bffc17 	ldw	r2,-16(fp)
81148e3c:	10800817 	ldw	r2,32(r2)
81148e40:	10c00094 	ori	r3,r2,2
81148e44:	e0bffc17 	ldw	r2,-16(fp)
81148e48:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81148e4c:	e0bffc17 	ldw	r2,-16(fp)
81148e50:	10800017 	ldw	r2,0(r2)
81148e54:	10800104 	addi	r2,r2,4
81148e58:	1007883a 	mov	r3,r2
81148e5c:	e0bffc17 	ldw	r2,-16(fp)
81148e60:	10800817 	ldw	r2,32(r2)
81148e64:	18800035 	stwio	r2,0(r3)
81148e68:	e0bff617 	ldw	r2,-40(fp)
81148e6c:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148e70:	e0bff317 	ldw	r2,-52(fp)
81148e74:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
81148e78:	e0bffe17 	ldw	r2,-8(fp)
81148e7c:	00802a0e 	bge	zero,r2,81148f28 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
81148e80:	e0bfff17 	ldw	r2,-4(fp)
81148e84:	1090000c 	andi	r2,r2,16384
81148e88:	10002a1e 	bne	r2,zero,81148f34 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
81148e8c:	d0a09103 	ldbu	r2,-32188(gp)
81148e90:	10803fcc 	andi	r2,r2,255
81148e94:	10800058 	cmpnei	r2,r2,1
81148e98:	1000161e 	bne	r2,zero,81148ef4 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81148e9c:	e0bffc17 	ldw	r2,-16(fp)
81148ea0:	10800c17 	ldw	r2,48(r2)
81148ea4:	e0bff515 	stw	r2,-44(fp)
81148ea8:	00800184 	movi	r2,6
81148eac:	e0bff98d 	sth	r2,-26(fp)
81148eb0:	00bfe0c4 	movi	r2,-125
81148eb4:	e0bffa05 	stb	r2,-24(fp)
81148eb8:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81148ebc:	d0a09103 	ldbu	r2,-32188(gp)
81148ec0:	10803fcc 	andi	r2,r2,255
81148ec4:	10001526 	beq	r2,zero,81148f1c <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81148ec8:	e0fff98b 	ldhu	r3,-26(fp)
81148ecc:	e13ffa03 	ldbu	r4,-24(fp)
81148ed0:	e17ffa8b 	ldhu	r5,-22(fp)
81148ed4:	e0bffb04 	addi	r2,fp,-20
81148ed8:	d8800015 	stw	r2,0(sp)
81148edc:	280f883a 	mov	r7,r5
81148ee0:	200d883a 	mov	r6,r4
81148ee4:	180b883a 	mov	r5,r3
81148ee8:	e13ff517 	ldw	r4,-44(fp)
81148eec:	113cabc0 	call	8113cabc <OSFlagPend>
81148ef0:	00000a06 	br	81148f1c <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
81148ef4:	0001883a 	nop
81148ef8:	e0bffc17 	ldw	r2,-16(fp)
81148efc:	10c01017 	ldw	r3,64(r2)
81148f00:	e0bff017 	ldw	r2,-64(fp)
81148f04:	1880051e 	bne	r3,r2,81148f1c <altera_avalon_jtag_uart_write+0x250>
81148f08:	e0bffc17 	ldw	r2,-16(fp)
81148f0c:	10c00917 	ldw	r3,36(r2)
81148f10:	e0bffc17 	ldw	r2,-16(fp)
81148f14:	10800117 	ldw	r2,4(r2)
81148f18:	18bff736 	bltu	r3,r2,81148ef8 <__reset+0xfb128ef8>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
81148f1c:	e0bffc17 	ldw	r2,-16(fp)
81148f20:	10800917 	ldw	r2,36(r2)
81148f24:	1000051e 	bne	r2,zero,81148f3c <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
81148f28:	e0bffe17 	ldw	r2,-8(fp)
81148f2c:	00bfb616 	blt	zero,r2,81148e08 <__reset+0xfb128e08>
81148f30:	00000306 	br	81148f40 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
81148f34:	0001883a 	nop
81148f38:	00000106 	br	81148f40 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
81148f3c:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
81148f40:	e0bffc17 	ldw	r2,-16(fp)
81148f44:	10800b17 	ldw	r2,44(r2)
81148f48:	1009883a 	mov	r4,r2
81148f4c:	1140ae40 	call	81140ae4 <OSSemPost>

  if (ptr != start)
81148f50:	e0fffd17 	ldw	r3,-12(fp)
81148f54:	e0bff217 	ldw	r2,-56(fp)
81148f58:	18800426 	beq	r3,r2,81148f6c <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
81148f5c:	e0fffd17 	ldw	r3,-12(fp)
81148f60:	e0bff217 	ldw	r2,-56(fp)
81148f64:	1885c83a 	sub	r2,r3,r2
81148f68:	00000606 	br	81148f84 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
81148f6c:	e0bfff17 	ldw	r2,-4(fp)
81148f70:	1090000c 	andi	r2,r2,16384
81148f74:	10000226 	beq	r2,zero,81148f80 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
81148f78:	00bffd44 	movi	r2,-11
81148f7c:	00000106 	br	81148f84 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
81148f80:	00bffec4 	movi	r2,-5
}
81148f84:	e037883a 	mov	sp,fp
81148f88:	dfc00117 	ldw	ra,4(sp)
81148f8c:	df000017 	ldw	fp,0(sp)
81148f90:	dec00204 	addi	sp,sp,8
81148f94:	f800283a 	ret

81148f98 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81148f98:	defffa04 	addi	sp,sp,-24
81148f9c:	de00012e 	bgeu	sp,et,81148fa4 <alt_avalon_timer_sc_irq+0xc>
81148fa0:	003b68fa 	trap	3
81148fa4:	dfc00515 	stw	ra,20(sp)
81148fa8:	df000415 	stw	fp,16(sp)
81148fac:	df000404 	addi	fp,sp,16
81148fb0:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
81148fb4:	0007883a 	mov	r3,zero
81148fb8:	e0bfff17 	ldw	r2,-4(fp)
81148fbc:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
81148fc0:	e0bfff17 	ldw	r2,-4(fp)
81148fc4:	10800104 	addi	r2,r2,4
81148fc8:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
81148fcc:	1138f980 	call	81138f98 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148fd0:	0005303a 	rdctl	r2,status
81148fd4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148fd8:	e0fffd17 	ldw	r3,-12(fp)
81148fdc:	00bfff84 	movi	r2,-2
81148fe0:	1884703a 	and	r2,r3,r2
81148fe4:	1001703a 	wrctl	status,r2
  
  return context;
81148fe8:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
81148fec:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
81148ff0:	11398480 	call	81139848 <alt_tick>
81148ff4:	e0bffc17 	ldw	r2,-16(fp)
81148ff8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148ffc:	e0bffe17 	ldw	r2,-8(fp)
81149000:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
81149004:	0001883a 	nop
81149008:	e037883a 	mov	sp,fp
8114900c:	dfc00117 	ldw	ra,4(sp)
81149010:	df000017 	ldw	fp,0(sp)
81149014:	dec00204 	addi	sp,sp,8
81149018:	f800283a 	ret

8114901c <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
8114901c:	defff804 	addi	sp,sp,-32
81149020:	de00012e 	bgeu	sp,et,81149028 <alt_avalon_timer_sc_init+0xc>
81149024:	003b68fa 	trap	3
81149028:	dfc00715 	stw	ra,28(sp)
8114902c:	df000615 	stw	fp,24(sp)
81149030:	df000604 	addi	fp,sp,24
81149034:	e13ffc15 	stw	r4,-16(fp)
81149038:	e17ffd15 	stw	r5,-12(fp)
8114903c:	e1bffe15 	stw	r6,-8(fp)
81149040:	e1ffff15 	stw	r7,-4(fp)
81149044:	e0bfff17 	ldw	r2,-4(fp)
81149048:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
8114904c:	d0a08817 	ldw	r2,-32224(gp)
81149050:	1000021e 	bne	r2,zero,8114905c <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
81149054:	e0bffb17 	ldw	r2,-20(fp)
81149058:	d0a08815 	stw	r2,-32224(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
8114905c:	e0bffc17 	ldw	r2,-16(fp)
81149060:	10800104 	addi	r2,r2,4
81149064:	00c001c4 	movi	r3,7
81149068:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
8114906c:	d8000015 	stw	zero,0(sp)
81149070:	e1fffc17 	ldw	r7,-16(fp)
81149074:	01a04574 	movhi	r6,33045
81149078:	31a3e604 	addi	r6,r6,-28776
8114907c:	e17ffe17 	ldw	r5,-8(fp)
81149080:	e13ffd17 	ldw	r4,-12(fp)
81149084:	114c2200 	call	8114c220 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
81149088:	0001883a 	nop
8114908c:	e037883a 	mov	sp,fp
81149090:	dfc00117 	ldw	ra,4(sp)
81149094:	df000017 	ldw	fp,0(sp)
81149098:	dec00204 	addi	sp,sp,8
8114909c:	f800283a 	ret

811490a0 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
811490a0:	defffa04 	addi	sp,sp,-24
811490a4:	de00012e 	bgeu	sp,et,811490ac <altera_avalon_uart_read_fd+0xc>
811490a8:	003b68fa 	trap	3
811490ac:	dfc00515 	stw	ra,20(sp)
811490b0:	df000415 	stw	fp,16(sp)
811490b4:	df000404 	addi	fp,sp,16
811490b8:	e13ffd15 	stw	r4,-12(fp)
811490bc:	e17ffe15 	stw	r5,-8(fp)
811490c0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811490c4:	e0bffd17 	ldw	r2,-12(fp)
811490c8:	10800017 	ldw	r2,0(r2)
811490cc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
811490d0:	e0bffc17 	ldw	r2,-16(fp)
811490d4:	10c00a04 	addi	r3,r2,40
811490d8:	e0bffd17 	ldw	r2,-12(fp)
811490dc:	10800217 	ldw	r2,8(r2)
811490e0:	100f883a 	mov	r7,r2
811490e4:	e1bfff17 	ldw	r6,-4(fp)
811490e8:	e17ffe17 	ldw	r5,-8(fp)
811490ec:	1809883a 	mov	r4,r3
811490f0:	11497600 	call	81149760 <altera_avalon_uart_read>
      fd->fd_flags);
}
811490f4:	e037883a 	mov	sp,fp
811490f8:	dfc00117 	ldw	ra,4(sp)
811490fc:	df000017 	ldw	fp,0(sp)
81149100:	dec00204 	addi	sp,sp,8
81149104:	f800283a 	ret

81149108 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81149108:	defffa04 	addi	sp,sp,-24
8114910c:	de00012e 	bgeu	sp,et,81149114 <altera_avalon_uart_write_fd+0xc>
81149110:	003b68fa 	trap	3
81149114:	dfc00515 	stw	ra,20(sp)
81149118:	df000415 	stw	fp,16(sp)
8114911c:	df000404 	addi	fp,sp,16
81149120:	e13ffd15 	stw	r4,-12(fp)
81149124:	e17ffe15 	stw	r5,-8(fp)
81149128:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8114912c:	e0bffd17 	ldw	r2,-12(fp)
81149130:	10800017 	ldw	r2,0(r2)
81149134:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
81149138:	e0bffc17 	ldw	r2,-16(fp)
8114913c:	10c00a04 	addi	r3,r2,40
81149140:	e0bffd17 	ldw	r2,-12(fp)
81149144:	10800217 	ldw	r2,8(r2)
81149148:	100f883a 	mov	r7,r2
8114914c:	e1bfff17 	ldw	r6,-4(fp)
81149150:	e17ffe17 	ldw	r5,-8(fp)
81149154:	1809883a 	mov	r4,r3
81149158:	1149a140 	call	81149a14 <altera_avalon_uart_write>
      fd->fd_flags);
}
8114915c:	e037883a 	mov	sp,fp
81149160:	dfc00117 	ldw	ra,4(sp)
81149164:	df000017 	ldw	fp,0(sp)
81149168:	dec00204 	addi	sp,sp,8
8114916c:	f800283a 	ret

81149170 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
81149170:	defffc04 	addi	sp,sp,-16
81149174:	de00012e 	bgeu	sp,et,8114917c <altera_avalon_uart_close_fd+0xc>
81149178:	003b68fa 	trap	3
8114917c:	dfc00315 	stw	ra,12(sp)
81149180:	df000215 	stw	fp,8(sp)
81149184:	df000204 	addi	fp,sp,8
81149188:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8114918c:	e0bfff17 	ldw	r2,-4(fp)
81149190:	10800017 	ldw	r2,0(r2)
81149194:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81149198:	e0bffe17 	ldw	r2,-8(fp)
8114919c:	10c00a04 	addi	r3,r2,40
811491a0:	e0bfff17 	ldw	r2,-4(fp)
811491a4:	10800217 	ldw	r2,8(r2)
811491a8:	100b883a 	mov	r5,r2
811491ac:	1809883a 	mov	r4,r3
811491b0:	11496c00 	call	811496c0 <altera_avalon_uart_close>
}
811491b4:	e037883a 	mov	sp,fp
811491b8:	dfc00117 	ldw	ra,4(sp)
811491bc:	df000017 	ldw	fp,0(sp)
811491c0:	dec00204 	addi	sp,sp,8
811491c4:	f800283a 	ret

811491c8 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
811491c8:	defff304 	addi	sp,sp,-52
811491cc:	de00012e 	bgeu	sp,et,811491d4 <altera_avalon_uart_init+0xc>
811491d0:	003b68fa 	trap	3
811491d4:	dfc00c15 	stw	ra,48(sp)
811491d8:	df000b15 	stw	fp,44(sp)
811491dc:	df000b04 	addi	fp,sp,44
811491e0:	e13ffd15 	stw	r4,-12(fp)
811491e4:	e17ffe15 	stw	r5,-8(fp)
811491e8:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
811491ec:	e0bffd17 	ldw	r2,-12(fp)
811491f0:	10800017 	ldw	r2,0(r2)
811491f4:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811491f8:	e0bffd17 	ldw	r2,-12(fp)
811491fc:	10800704 	addi	r2,r2,28
81149200:	e0bffa15 	stw	r2,-24(fp)
81149204:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81149208:	e0bffb0b 	ldhu	r2,-20(fp)
8114920c:	e0fffc84 	addi	r3,fp,-14
81149210:	180b883a 	mov	r5,r3
81149214:	1009883a 	mov	r4,r2
81149218:	113c4d80 	call	8113c4d8 <OSFlagCreate>
8114921c:	1007883a 	mov	r3,r2
81149220:	e0bffa17 	ldw	r2,-24(fp)
81149224:	10c00015 	stw	r3,0(r2)
  return err;
81149228:	e0bffc83 	ldbu	r2,-14(fp)
8114922c:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81149230:	1000241e 	bne	r2,zero,811492c4 <altera_avalon_uart_init+0xfc>
81149234:	e0bffd17 	ldw	r2,-12(fp)
81149238:	10800804 	addi	r2,r2,32
8114923c:	e0bff715 	stw	r2,-36(fp)
81149240:	00800044 	movi	r2,1
81149244:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81149248:	e0bffb8b 	ldhu	r2,-18(fp)
8114924c:	1009883a 	mov	r4,r2
81149250:	11404340 	call	81140434 <OSSemCreate>
81149254:	1007883a 	mov	r3,r2
81149258:	e0bff717 	ldw	r2,-36(fp)
8114925c:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81149260:	e0bff717 	ldw	r2,-36(fp)
81149264:	10800017 	ldw	r2,0(r2)
81149268:	10000226 	beq	r2,zero,81149274 <altera_avalon_uart_init+0xac>
8114926c:	0005883a 	mov	r2,zero
81149270:	00000106 	br	81149278 <altera_avalon_uart_init+0xb0>
81149274:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81149278:	1000121e 	bne	r2,zero,811492c4 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
8114927c:	e0bffd17 	ldw	r2,-12(fp)
81149280:	10800904 	addi	r2,r2,36
81149284:	e0bff815 	stw	r2,-32(fp)
81149288:	00800044 	movi	r2,1
8114928c:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81149290:	e0bffc0b 	ldhu	r2,-16(fp)
81149294:	1009883a 	mov	r4,r2
81149298:	11404340 	call	81140434 <OSSemCreate>
8114929c:	1007883a 	mov	r3,r2
811492a0:	e0bff817 	ldw	r2,-32(fp)
811492a4:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
811492a8:	e0bff817 	ldw	r2,-32(fp)
811492ac:	10800017 	ldw	r2,0(r2)
811492b0:	10000226 	beq	r2,zero,811492bc <altera_avalon_uart_init+0xf4>
811492b4:	0005883a 	mov	r2,zero
811492b8:	00000106 	br	811492c0 <altera_avalon_uart_init+0xf8>
811492bc:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
811492c0:	10000226 	beq	r2,zero,811492cc <altera_avalon_uart_init+0x104>
811492c4:	00800044 	movi	r2,1
811492c8:	00000106 	br	811492d0 <altera_avalon_uart_init+0x108>
811492cc:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811492d0:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
811492d4:	e0bff917 	ldw	r2,-28(fp)
811492d8:	10000f1e 	bne	r2,zero,81149318 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
811492dc:	e0bffd17 	ldw	r2,-12(fp)
811492e0:	00c32004 	movi	r3,3200
811492e4:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
811492e8:	e0bff617 	ldw	r2,-40(fp)
811492ec:	10800304 	addi	r2,r2,12
811492f0:	e0fffd17 	ldw	r3,-12(fp)
811492f4:	18c00117 	ldw	r3,4(r3)
811492f8:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
811492fc:	d8000015 	stw	zero,0(sp)
81149300:	e1fffd17 	ldw	r7,-12(fp)
81149304:	01a04574 	movhi	r6,33045
81149308:	31a4cc04 	addi	r6,r6,-27856
8114930c:	e17fff17 	ldw	r5,-4(fp)
81149310:	e13ffe17 	ldw	r4,-8(fp)
81149314:	114c2200 	call	8114c220 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
81149318:	0001883a 	nop
8114931c:	e037883a 	mov	sp,fp
81149320:	dfc00117 	ldw	ra,4(sp)
81149324:	df000017 	ldw	fp,0(sp)
81149328:	dec00204 	addi	sp,sp,8
8114932c:	f800283a 	ret

81149330 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
81149330:	defffa04 	addi	sp,sp,-24
81149334:	de00012e 	bgeu	sp,et,8114933c <altera_avalon_uart_irq+0xc>
81149338:	003b68fa 	trap	3
8114933c:	dfc00515 	stw	ra,20(sp)
81149340:	df000415 	stw	fp,16(sp)
81149344:	df000404 	addi	fp,sp,16
81149348:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
8114934c:	e0bfff17 	ldw	r2,-4(fp)
81149350:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
81149354:	e0bffc17 	ldw	r2,-16(fp)
81149358:	10800017 	ldw	r2,0(r2)
8114935c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
81149360:	e0bffd17 	ldw	r2,-12(fp)
81149364:	10800204 	addi	r2,r2,8
81149368:	10800037 	ldwio	r2,0(r2)
8114936c:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
81149370:	e0bffd17 	ldw	r2,-12(fp)
81149374:	10800204 	addi	r2,r2,8
81149378:	0007883a 	mov	r3,zero
8114937c:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
81149380:	e0bffd17 	ldw	r2,-12(fp)
81149384:	10800204 	addi	r2,r2,8
81149388:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
8114938c:	e0bffe17 	ldw	r2,-8(fp)
81149390:	1080200c 	andi	r2,r2,128
81149394:	10000326 	beq	r2,zero,811493a4 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
81149398:	e17ffe17 	ldw	r5,-8(fp)
8114939c:	e13ffc17 	ldw	r4,-16(fp)
811493a0:	11493d40 	call	811493d4 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
811493a4:	e0bffe17 	ldw	r2,-8(fp)
811493a8:	1081100c 	andi	r2,r2,1088
811493ac:	10000326 	beq	r2,zero,811493bc <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
811493b0:	e17ffe17 	ldw	r5,-8(fp)
811493b4:	e13ffc17 	ldw	r4,-16(fp)
811493b8:	11495140 	call	81149514 <altera_avalon_uart_txirq>
  }
  

}
811493bc:	0001883a 	nop
811493c0:	e037883a 	mov	sp,fp
811493c4:	dfc00117 	ldw	ra,4(sp)
811493c8:	df000017 	ldw	fp,0(sp)
811493cc:	dec00204 	addi	sp,sp,8
811493d0:	f800283a 	ret

811493d4 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
811493d4:	defff904 	addi	sp,sp,-28
811493d8:	de00012e 	bgeu	sp,et,811493e0 <altera_avalon_uart_rxirq+0xc>
811493dc:	003b68fa 	trap	3
811493e0:	dfc00615 	stw	ra,24(sp)
811493e4:	df000515 	stw	fp,20(sp)
811493e8:	df000504 	addi	fp,sp,20
811493ec:	e13ffe15 	stw	r4,-8(fp)
811493f0:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
811493f4:	e0bfff17 	ldw	r2,-4(fp)
811493f8:	108000cc 	andi	r2,r2,3
811493fc:	10003f1e 	bne	r2,zero,811494fc <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
81149400:	e0bffe17 	ldw	r2,-8(fp)
81149404:	10c00317 	ldw	r3,12(r2)
81149408:	e0bffe17 	ldw	r2,-8(fp)
8114940c:	10800217 	ldw	r2,8(r2)
81149410:	1880121e 	bne	r3,r2,8114945c <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
81149414:	e0bffe17 	ldw	r2,-8(fp)
81149418:	10800717 	ldw	r2,28(r2)
8114941c:	e0bffc15 	stw	r2,-16(fp)
81149420:	00800044 	movi	r2,1
81149424:	e0bffd0d 	sth	r2,-12(fp)
81149428:	00800044 	movi	r2,1
8114942c:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81149430:	d0a09103 	ldbu	r2,-32188(gp)
81149434:	10803fcc 	andi	r2,r2,255
81149438:	10000826 	beq	r2,zero,8114945c <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
8114943c:	e0bffd0b 	ldhu	r2,-12(fp)
81149440:	e0fffd83 	ldbu	r3,-10(fp)
81149444:	e13ffdc4 	addi	r4,fp,-9
81149448:	200f883a 	mov	r7,r4
8114944c:	180d883a 	mov	r6,r3
81149450:	100b883a 	mov	r5,r2
81149454:	e13ffc17 	ldw	r4,-16(fp)
81149458:	113d0e40 	call	8113d0e4 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8114945c:	e0bffe17 	ldw	r2,-8(fp)
81149460:	10800317 	ldw	r2,12(r2)
81149464:	10800044 	addi	r2,r2,1
81149468:	10800fcc 	andi	r2,r2,63
8114946c:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
81149470:	e0bffe17 	ldw	r2,-8(fp)
81149474:	10800317 	ldw	r2,12(r2)
81149478:	e0fffe17 	ldw	r3,-8(fp)
8114947c:	18c00017 	ldw	r3,0(r3)
81149480:	18c00037 	ldwio	r3,0(r3)
81149484:	1809883a 	mov	r4,r3
81149488:	e0fffe17 	ldw	r3,-8(fp)
8114948c:	1885883a 	add	r2,r3,r2
81149490:	10800a04 	addi	r2,r2,40
81149494:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
81149498:	e0bffe17 	ldw	r2,-8(fp)
8114949c:	e0fffb17 	ldw	r3,-20(fp)
811494a0:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811494a4:	e0bffe17 	ldw	r2,-8(fp)
811494a8:	10800317 	ldw	r2,12(r2)
811494ac:	10800044 	addi	r2,r2,1
811494b0:	10800fcc 	andi	r2,r2,63
811494b4:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
811494b8:	e0bffe17 	ldw	r2,-8(fp)
811494bc:	10c00217 	ldw	r3,8(r2)
811494c0:	e0bffb17 	ldw	r2,-20(fp)
811494c4:	18800e1e 	bne	r3,r2,81149500 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
811494c8:	e0bffe17 	ldw	r2,-8(fp)
811494cc:	10c00117 	ldw	r3,4(r2)
811494d0:	00bfdfc4 	movi	r2,-129
811494d4:	1886703a 	and	r3,r3,r2
811494d8:	e0bffe17 	ldw	r2,-8(fp)
811494dc:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
811494e0:	e0bffe17 	ldw	r2,-8(fp)
811494e4:	10800017 	ldw	r2,0(r2)
811494e8:	10800304 	addi	r2,r2,12
811494ec:	e0fffe17 	ldw	r3,-8(fp)
811494f0:	18c00117 	ldw	r3,4(r3)
811494f4:	10c00035 	stwio	r3,0(r2)
811494f8:	00000106 	br	81149500 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
811494fc:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
81149500:	e037883a 	mov	sp,fp
81149504:	dfc00117 	ldw	ra,4(sp)
81149508:	df000017 	ldw	fp,0(sp)
8114950c:	dec00204 	addi	sp,sp,8
81149510:	f800283a 	ret

81149514 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81149514:	defffa04 	addi	sp,sp,-24
81149518:	de00012e 	bgeu	sp,et,81149520 <altera_avalon_uart_txirq+0xc>
8114951c:	003b68fa 	trap	3
81149520:	dfc00515 	stw	ra,20(sp)
81149524:	df000415 	stw	fp,16(sp)
81149528:	df000404 	addi	fp,sp,16
8114952c:	e13ffe15 	stw	r4,-8(fp)
81149530:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
81149534:	e0bffe17 	ldw	r2,-8(fp)
81149538:	10c00417 	ldw	r3,16(r2)
8114953c:	e0bffe17 	ldw	r2,-8(fp)
81149540:	10800517 	ldw	r2,20(r2)
81149544:	18804726 	beq	r3,r2,81149664 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81149548:	e0bffe17 	ldw	r2,-8(fp)
8114954c:	10800617 	ldw	r2,24(r2)
81149550:	1080008c 	andi	r2,r2,2
81149554:	10000326 	beq	r2,zero,81149564 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81149558:	e0bfff17 	ldw	r2,-4(fp)
8114955c:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81149560:	10003226 	beq	r2,zero,8114962c <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
81149564:	e0bffe17 	ldw	r2,-8(fp)
81149568:	10c00417 	ldw	r3,16(r2)
8114956c:	e0bffe17 	ldw	r2,-8(fp)
81149570:	10800517 	ldw	r2,20(r2)
81149574:	10800044 	addi	r2,r2,1
81149578:	10800fcc 	andi	r2,r2,63
8114957c:	1880121e 	bne	r3,r2,811495c8 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
81149580:	e0bffe17 	ldw	r2,-8(fp)
81149584:	10800717 	ldw	r2,28(r2)
81149588:	e0bffc15 	stw	r2,-16(fp)
8114958c:	00800084 	movi	r2,2
81149590:	e0bffd0d 	sth	r2,-12(fp)
81149594:	00800044 	movi	r2,1
81149598:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8114959c:	d0a09103 	ldbu	r2,-32188(gp)
811495a0:	10803fcc 	andi	r2,r2,255
811495a4:	10000826 	beq	r2,zero,811495c8 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
811495a8:	e0bffd0b 	ldhu	r2,-12(fp)
811495ac:	e0fffd83 	ldbu	r3,-10(fp)
811495b0:	e13ffdc4 	addi	r4,fp,-9
811495b4:	200f883a 	mov	r7,r4
811495b8:	180d883a 	mov	r6,r3
811495bc:	100b883a 	mov	r5,r2
811495c0:	e13ffc17 	ldw	r4,-16(fp)
811495c4:	113d0e40 	call	8113d0e4 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
811495c8:	e0bffe17 	ldw	r2,-8(fp)
811495cc:	10800017 	ldw	r2,0(r2)
811495d0:	10800104 	addi	r2,r2,4
811495d4:	e0fffe17 	ldw	r3,-8(fp)
811495d8:	18c00417 	ldw	r3,16(r3)
811495dc:	e13ffe17 	ldw	r4,-8(fp)
811495e0:	20c7883a 	add	r3,r4,r3
811495e4:	18c01a04 	addi	r3,r3,104
811495e8:	18c00003 	ldbu	r3,0(r3)
811495ec:	18c03fcc 	andi	r3,r3,255
811495f0:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
811495f4:	e0bffe17 	ldw	r2,-8(fp)
811495f8:	10800417 	ldw	r2,16(r2)
811495fc:	10800044 	addi	r2,r2,1
81149600:	e0fffe17 	ldw	r3,-8(fp)
81149604:	18800415 	stw	r2,16(r3)
81149608:	10c00fcc 	andi	r3,r2,63
8114960c:	e0bffe17 	ldw	r2,-8(fp)
81149610:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81149614:	e0bffe17 	ldw	r2,-8(fp)
81149618:	10800117 	ldw	r2,4(r2)
8114961c:	10c01014 	ori	r3,r2,64
81149620:	e0bffe17 	ldw	r2,-8(fp)
81149624:	10c00115 	stw	r3,4(r2)
81149628:	00000e06 	br	81149664 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
8114962c:	e0bffe17 	ldw	r2,-8(fp)
81149630:	10800017 	ldw	r2,0(r2)
81149634:	10800204 	addi	r2,r2,8
81149638:	10800037 	ldwio	r2,0(r2)
8114963c:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81149640:	e0bfff17 	ldw	r2,-4(fp)
81149644:	1082000c 	andi	r2,r2,2048
81149648:	1000061e 	bne	r2,zero,81149664 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
8114964c:	e0bffe17 	ldw	r2,-8(fp)
81149650:	10c00117 	ldw	r3,4(r2)
81149654:	00bfefc4 	movi	r2,-65
81149658:	1886703a 	and	r3,r3,r2
8114965c:	e0bffe17 	ldw	r2,-8(fp)
81149660:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
81149664:	e0bffe17 	ldw	r2,-8(fp)
81149668:	10c00417 	ldw	r3,16(r2)
8114966c:	e0bffe17 	ldw	r2,-8(fp)
81149670:	10800517 	ldw	r2,20(r2)
81149674:	1880061e 	bne	r3,r2,81149690 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81149678:	e0bffe17 	ldw	r2,-8(fp)
8114967c:	10c00117 	ldw	r3,4(r2)
81149680:	00beefc4 	movi	r2,-1089
81149684:	1886703a 	and	r3,r3,r2
81149688:	e0bffe17 	ldw	r2,-8(fp)
8114968c:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81149690:	e0bffe17 	ldw	r2,-8(fp)
81149694:	10800017 	ldw	r2,0(r2)
81149698:	10800304 	addi	r2,r2,12
8114969c:	e0fffe17 	ldw	r3,-8(fp)
811496a0:	18c00117 	ldw	r3,4(r3)
811496a4:	10c00035 	stwio	r3,0(r2)
}
811496a8:	0001883a 	nop
811496ac:	e037883a 	mov	sp,fp
811496b0:	dfc00117 	ldw	ra,4(sp)
811496b4:	df000017 	ldw	fp,0(sp)
811496b8:	dec00204 	addi	sp,sp,8
811496bc:	f800283a 	ret

811496c0 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
811496c0:	defffd04 	addi	sp,sp,-12
811496c4:	de00012e 	bgeu	sp,et,811496cc <altera_avalon_uart_close+0xc>
811496c8:	003b68fa 	trap	3
811496cc:	df000215 	stw	fp,8(sp)
811496d0:	df000204 	addi	fp,sp,8
811496d4:	e13ffe15 	stw	r4,-8(fp)
811496d8:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
811496dc:	00000506 	br	811496f4 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
811496e0:	e0bfff17 	ldw	r2,-4(fp)
811496e4:	1090000c 	andi	r2,r2,16384
811496e8:	10000226 	beq	r2,zero,811496f4 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
811496ec:	00bffd44 	movi	r2,-11
811496f0:	00000606 	br	8114970c <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
811496f4:	e0bffe17 	ldw	r2,-8(fp)
811496f8:	10c00417 	ldw	r3,16(r2)
811496fc:	e0bffe17 	ldw	r2,-8(fp)
81149700:	10800517 	ldw	r2,20(r2)
81149704:	18bff61e 	bne	r3,r2,811496e0 <__reset+0xfb1296e0>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81149708:	0005883a 	mov	r2,zero
}
8114970c:	e037883a 	mov	sp,fp
81149710:	df000017 	ldw	fp,0(sp)
81149714:	dec00104 	addi	sp,sp,4
81149718:	f800283a 	ret

8114971c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114971c:	defffe04 	addi	sp,sp,-8
81149720:	de00012e 	bgeu	sp,et,81149728 <alt_get_errno+0xc>
81149724:	003b68fa 	trap	3
81149728:	dfc00115 	stw	ra,4(sp)
8114972c:	df000015 	stw	fp,0(sp)
81149730:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81149734:	d0a01017 	ldw	r2,-32704(gp)
81149738:	10000326 	beq	r2,zero,81149748 <alt_get_errno+0x2c>
8114973c:	d0a01017 	ldw	r2,-32704(gp)
81149740:	103ee83a 	callr	r2
81149744:	00000106 	br	8114974c <alt_get_errno+0x30>
81149748:	d0a07804 	addi	r2,gp,-32288
}
8114974c:	e037883a 	mov	sp,fp
81149750:	dfc00117 	ldw	ra,4(sp)
81149754:	df000017 	ldw	fp,0(sp)
81149758:	dec00204 	addi	sp,sp,8
8114975c:	f800283a 	ret

81149760 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
81149760:	deffec04 	addi	sp,sp,-80
81149764:	de00012e 	bgeu	sp,et,8114976c <altera_avalon_uart_read+0xc>
81149768:	003b68fa 	trap	3
8114976c:	dfc01315 	stw	ra,76(sp)
81149770:	df001215 	stw	fp,72(sp)
81149774:	df001204 	addi	fp,sp,72
81149778:	e13ffc15 	stw	r4,-16(fp)
8114977c:	e17ffd15 	stw	r5,-12(fp)
81149780:	e1bffe15 	stw	r6,-8(fp)
81149784:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
81149788:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
8114978c:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
81149790:	e0bfff17 	ldw	r2,-4(fp)
81149794:	1090000c 	andi	r2,r2,16384
81149798:	1005003a 	cmpeq	r2,r2,zero
8114979c:	10803fcc 	andi	r2,r2,255
811497a0:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
811497a4:	e0bffc17 	ldw	r2,-16(fp)
811497a8:	10800817 	ldw	r2,32(r2)
811497ac:	e0bff815 	stw	r2,-32(fp)
811497b0:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
811497b4:	e0bff90b 	ldhu	r2,-28(fp)
811497b8:	e0fffb44 	addi	r3,fp,-19
811497bc:	180d883a 	mov	r6,r3
811497c0:	100b883a 	mov	r5,r2
811497c4:	e13ff817 	ldw	r4,-32(fp)
811497c8:	114075c0 	call	8114075c <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
811497cc:	00001306 	br	8114981c <altera_avalon_uart_read+0xbc>
    {
      count++;
811497d0:	e0bff017 	ldw	r2,-64(fp)
811497d4:	10800044 	addi	r2,r2,1
811497d8:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
811497dc:	e0bffd17 	ldw	r2,-12(fp)
811497e0:	10c00044 	addi	r3,r2,1
811497e4:	e0fffd15 	stw	r3,-12(fp)
811497e8:	e0fffc17 	ldw	r3,-16(fp)
811497ec:	18c00217 	ldw	r3,8(r3)
811497f0:	e13ffc17 	ldw	r4,-16(fp)
811497f4:	20c7883a 	add	r3,r4,r3
811497f8:	18c00a04 	addi	r3,r3,40
811497fc:	18c00003 	ldbu	r3,0(r3)
81149800:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81149804:	e0bffc17 	ldw	r2,-16(fp)
81149808:	10800217 	ldw	r2,8(r2)
8114980c:	10800044 	addi	r2,r2,1
81149810:	10c00fcc 	andi	r3,r2,63
81149814:	e0bffc17 	ldw	r2,-16(fp)
81149818:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
8114981c:	e0fff017 	ldw	r3,-64(fp)
81149820:	e0bffe17 	ldw	r2,-8(fp)
81149824:	1880050e 	bge	r3,r2,8114983c <altera_avalon_uart_read+0xdc>
81149828:	e0bffc17 	ldw	r2,-16(fp)
8114982c:	10c00217 	ldw	r3,8(r2)
81149830:	e0bffc17 	ldw	r2,-16(fp)
81149834:	10800317 	ldw	r2,12(r2)
81149838:	18bfe51e 	bne	r3,r2,811497d0 <__reset+0xfb1297d0>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
8114983c:	e0bff017 	ldw	r2,-64(fp)
81149840:	10003a1e 	bne	r2,zero,8114992c <altera_avalon_uart_read+0x1cc>
81149844:	e0bffc17 	ldw	r2,-16(fp)
81149848:	10c00217 	ldw	r3,8(r2)
8114984c:	e0bffc17 	ldw	r2,-16(fp)
81149850:	10800317 	ldw	r2,12(r2)
81149854:	1880351e 	bne	r3,r2,8114992c <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81149858:	e0bff117 	ldw	r2,-60(fp)
8114985c:	1000071e 	bne	r2,zero,8114987c <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
81149860:	114971c0 	call	8114971c <alt_get_errno>
81149864:	1007883a 	mov	r3,r2
81149868:	008002c4 	movi	r2,11
8114986c:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
81149870:	00800044 	movi	r2,1
81149874:	e0bfef05 	stb	r2,-68(fp)
        break;
81149878:	00003006 	br	8114993c <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114987c:	0005303a 	rdctl	r2,status
81149880:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149884:	e0fff517 	ldw	r3,-44(fp)
81149888:	00bfff84 	movi	r2,-2
8114988c:	1884703a 	and	r2,r3,r2
81149890:	1001703a 	wrctl	status,r2
  
  return context;
81149894:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
81149898:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
8114989c:	e0bffc17 	ldw	r2,-16(fp)
811498a0:	10800117 	ldw	r2,4(r2)
811498a4:	10c02014 	ori	r3,r2,128
811498a8:	e0bffc17 	ldw	r2,-16(fp)
811498ac:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811498b0:	e0bffc17 	ldw	r2,-16(fp)
811498b4:	10800017 	ldw	r2,0(r2)
811498b8:	10800304 	addi	r2,r2,12
811498bc:	e0fffc17 	ldw	r3,-16(fp)
811498c0:	18c00117 	ldw	r3,4(r3)
811498c4:	10c00035 	stwio	r3,0(r2)
811498c8:	e0bff417 	ldw	r2,-48(fp)
811498cc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811498d0:	e0bff617 	ldw	r2,-40(fp)
811498d4:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
811498d8:	e0bffc17 	ldw	r2,-16(fp)
811498dc:	10800717 	ldw	r2,28(r2)
811498e0:	e0bff215 	stw	r2,-56(fp)
811498e4:	00800044 	movi	r2,1
811498e8:	e0bff98d 	sth	r2,-26(fp)
811498ec:	00bfe0c4 	movi	r2,-125
811498f0:	e0bffa05 	stb	r2,-24(fp)
811498f4:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
811498f8:	d0a09103 	ldbu	r2,-32188(gp)
811498fc:	10803fcc 	andi	r2,r2,255
81149900:	10000a26 	beq	r2,zero,8114992c <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81149904:	e0fff98b 	ldhu	r3,-26(fp)
81149908:	e13ffa03 	ldbu	r4,-24(fp)
8114990c:	e17ffa8b 	ldhu	r5,-22(fp)
81149910:	e0bffb04 	addi	r2,fp,-20
81149914:	d8800015 	stw	r2,0(sp)
81149918:	280f883a 	mov	r7,r5
8114991c:	200d883a 	mov	r6,r4
81149920:	180b883a 	mov	r5,r3
81149924:	e13ff217 	ldw	r4,-56(fp)
81149928:	113cabc0 	call	8113cabc <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
8114992c:	e0bff017 	ldw	r2,-64(fp)
81149930:	1000021e 	bne	r2,zero,8114993c <altera_avalon_uart_read+0x1dc>
81149934:	e0bffe17 	ldw	r2,-8(fp)
81149938:	103fb81e 	bne	r2,zero,8114981c <__reset+0xfb12981c>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
8114993c:	e0bffc17 	ldw	r2,-16(fp)
81149940:	10800817 	ldw	r2,32(r2)
81149944:	1009883a 	mov	r4,r2
81149948:	1140ae40 	call	81140ae4 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114994c:	0005303a 	rdctl	r2,status
81149950:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149954:	e0fff717 	ldw	r3,-36(fp)
81149958:	00bfff84 	movi	r2,-2
8114995c:	1884703a 	and	r2,r3,r2
81149960:	1001703a 	wrctl	status,r2
  
  return context;
81149964:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81149968:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
8114996c:	e0bffc17 	ldw	r2,-16(fp)
81149970:	10800117 	ldw	r2,4(r2)
81149974:	10c02014 	ori	r3,r2,128
81149978:	e0bffc17 	ldw	r2,-16(fp)
8114997c:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81149980:	e0bffc17 	ldw	r2,-16(fp)
81149984:	10800017 	ldw	r2,0(r2)
81149988:	10800304 	addi	r2,r2,12
8114998c:	e0fffc17 	ldw	r3,-16(fp)
81149990:	18c00117 	ldw	r3,4(r3)
81149994:	10c00035 	stwio	r3,0(r2)
81149998:	e0bff417 	ldw	r2,-48(fp)
8114999c:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811499a0:	e0bff317 	ldw	r2,-52(fp)
811499a4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
811499a8:	e0bfef03 	ldbu	r2,-68(fp)
811499ac:	10000226 	beq	r2,zero,811499b8 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
811499b0:	00bffd44 	movi	r2,-11
811499b4:	00000106 	br	811499bc <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
811499b8:	e0bff017 	ldw	r2,-64(fp)
  }
}
811499bc:	e037883a 	mov	sp,fp
811499c0:	dfc00117 	ldw	ra,4(sp)
811499c4:	df000017 	ldw	fp,0(sp)
811499c8:	dec00204 	addi	sp,sp,8
811499cc:	f800283a 	ret

811499d0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811499d0:	defffe04 	addi	sp,sp,-8
811499d4:	de00012e 	bgeu	sp,et,811499dc <alt_get_errno+0xc>
811499d8:	003b68fa 	trap	3
811499dc:	dfc00115 	stw	ra,4(sp)
811499e0:	df000015 	stw	fp,0(sp)
811499e4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811499e8:	d0a01017 	ldw	r2,-32704(gp)
811499ec:	10000326 	beq	r2,zero,811499fc <alt_get_errno+0x2c>
811499f0:	d0a01017 	ldw	r2,-32704(gp)
811499f4:	103ee83a 	callr	r2
811499f8:	00000106 	br	81149a00 <alt_get_errno+0x30>
811499fc:	d0a07804 	addi	r2,gp,-32288
}
81149a00:	e037883a 	mov	sp,fp
81149a04:	dfc00117 	ldw	ra,4(sp)
81149a08:	df000017 	ldw	fp,0(sp)
81149a0c:	dec00204 	addi	sp,sp,8
81149a10:	f800283a 	ret

81149a14 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81149a14:	deffec04 	addi	sp,sp,-80
81149a18:	de00012e 	bgeu	sp,et,81149a20 <altera_avalon_uart_write+0xc>
81149a1c:	003b68fa 	trap	3
81149a20:	dfc01315 	stw	ra,76(sp)
81149a24:	df001215 	stw	fp,72(sp)
81149a28:	df001204 	addi	fp,sp,72
81149a2c:	e13ffc15 	stw	r4,-16(fp)
81149a30:	e17ffd15 	stw	r5,-12(fp)
81149a34:	e1bffe15 	stw	r6,-8(fp)
81149a38:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81149a3c:	e0bffe17 	ldw	r2,-8(fp)
81149a40:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
81149a44:	e0bfff17 	ldw	r2,-4(fp)
81149a48:	1090000c 	andi	r2,r2,16384
81149a4c:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
81149a50:	e0bffc17 	ldw	r2,-16(fp)
81149a54:	10800917 	ldw	r2,36(r2)
81149a58:	e0bff815 	stw	r2,-32(fp)
81149a5c:	e03ff90d 	sth	zero,-28(fp)
81149a60:	e0bff90b 	ldhu	r2,-28(fp)
81149a64:	e0fffb44 	addi	r3,fp,-19
81149a68:	180d883a 	mov	r6,r3
81149a6c:	100b883a 	mov	r5,r2
81149a70:	e13ff817 	ldw	r4,-32(fp)
81149a74:	114075c0 	call	8114075c <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81149a78:	00005106 	br	81149bc0 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81149a7c:	e0bffc17 	ldw	r2,-16(fp)
81149a80:	10800517 	ldw	r2,20(r2)
81149a84:	10800044 	addi	r2,r2,1
81149a88:	10800fcc 	andi	r2,r2,63
81149a8c:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81149a90:	e0bffc17 	ldw	r2,-16(fp)
81149a94:	10c00417 	ldw	r3,16(r2)
81149a98:	e0bff217 	ldw	r2,-56(fp)
81149a9c:	1880371e 	bne	r3,r2,81149b7c <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81149aa0:	e0bff017 	ldw	r2,-64(fp)
81149aa4:	10000526 	beq	r2,zero,81149abc <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81149aa8:	11499d00 	call	811499d0 <alt_get_errno>
81149aac:	1007883a 	mov	r3,r2
81149ab0:	008002c4 	movi	r2,11
81149ab4:	18800015 	stw	r2,0(r3)
        break;
81149ab8:	00004306 	br	81149bc8 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149abc:	0005303a 	rdctl	r2,status
81149ac0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149ac4:	e0fff517 	ldw	r3,-44(fp)
81149ac8:	00bfff84 	movi	r2,-2
81149acc:	1884703a 	and	r2,r3,r2
81149ad0:	1001703a 	wrctl	status,r2
  
  return context;
81149ad4:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81149ad8:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81149adc:	e0bffc17 	ldw	r2,-16(fp)
81149ae0:	10800117 	ldw	r2,4(r2)
81149ae4:	10c11014 	ori	r3,r2,1088
81149ae8:	e0bffc17 	ldw	r2,-16(fp)
81149aec:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81149af0:	e0bffc17 	ldw	r2,-16(fp)
81149af4:	10800017 	ldw	r2,0(r2)
81149af8:	10800304 	addi	r2,r2,12
81149afc:	e0fffc17 	ldw	r3,-16(fp)
81149b00:	18c00117 	ldw	r3,4(r3)
81149b04:	10c00035 	stwio	r3,0(r2)
81149b08:	e0bff417 	ldw	r2,-48(fp)
81149b0c:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149b10:	e0bff117 	ldw	r2,-60(fp)
81149b14:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81149b18:	e0bffc17 	ldw	r2,-16(fp)
81149b1c:	10800717 	ldw	r2,28(r2)
81149b20:	e0bff315 	stw	r2,-52(fp)
81149b24:	00800084 	movi	r2,2
81149b28:	e0bff98d 	sth	r2,-26(fp)
81149b2c:	00bfe0c4 	movi	r2,-125
81149b30:	e0bffa05 	stb	r2,-24(fp)
81149b34:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81149b38:	d0a09103 	ldbu	r2,-32188(gp)
81149b3c:	10803fcc 	andi	r2,r2,255
81149b40:	10000a26 	beq	r2,zero,81149b6c <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81149b44:	e0fff98b 	ldhu	r3,-26(fp)
81149b48:	e13ffa03 	ldbu	r4,-24(fp)
81149b4c:	e17ffa8b 	ldhu	r5,-22(fp)
81149b50:	e0bffb04 	addi	r2,fp,-20
81149b54:	d8800015 	stw	r2,0(sp)
81149b58:	280f883a 	mov	r7,r5
81149b5c:	200d883a 	mov	r6,r4
81149b60:	180b883a 	mov	r5,r3
81149b64:	e13ff317 	ldw	r4,-52(fp)
81149b68:	113cabc0 	call	8113cabc <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81149b6c:	e0bffc17 	ldw	r2,-16(fp)
81149b70:	10c00417 	ldw	r3,16(r2)
81149b74:	e0bff217 	ldw	r2,-56(fp)
81149b78:	18bfe726 	beq	r3,r2,81149b18 <__reset+0xfb129b18>
      }
    }

    count--;
81149b7c:	e0bfef17 	ldw	r2,-68(fp)
81149b80:	10bfffc4 	addi	r2,r2,-1
81149b84:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81149b88:	e0bffc17 	ldw	r2,-16(fp)
81149b8c:	10c00517 	ldw	r3,20(r2)
81149b90:	e0bffd17 	ldw	r2,-12(fp)
81149b94:	11000044 	addi	r4,r2,1
81149b98:	e13ffd15 	stw	r4,-12(fp)
81149b9c:	10800003 	ldbu	r2,0(r2)
81149ba0:	1009883a 	mov	r4,r2
81149ba4:	e0bffc17 	ldw	r2,-16(fp)
81149ba8:	10c5883a 	add	r2,r2,r3
81149bac:	10801a04 	addi	r2,r2,104
81149bb0:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81149bb4:	e0bffc17 	ldw	r2,-16(fp)
81149bb8:	e0fff217 	ldw	r3,-56(fp)
81149bbc:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81149bc0:	e0bfef17 	ldw	r2,-68(fp)
81149bc4:	103fad1e 	bne	r2,zero,81149a7c <__reset+0xfb129a7c>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81149bc8:	e0bffc17 	ldw	r2,-16(fp)
81149bcc:	10800917 	ldw	r2,36(r2)
81149bd0:	1009883a 	mov	r4,r2
81149bd4:	1140ae40 	call	81140ae4 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149bd8:	0005303a 	rdctl	r2,status
81149bdc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149be0:	e0fff717 	ldw	r3,-36(fp)
81149be4:	00bfff84 	movi	r2,-2
81149be8:	1884703a 	and	r2,r3,r2
81149bec:	1001703a 	wrctl	status,r2
  
  return context;
81149bf0:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81149bf4:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81149bf8:	e0bffc17 	ldw	r2,-16(fp)
81149bfc:	10800117 	ldw	r2,4(r2)
81149c00:	10c11014 	ori	r3,r2,1088
81149c04:	e0bffc17 	ldw	r2,-16(fp)
81149c08:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81149c0c:	e0bffc17 	ldw	r2,-16(fp)
81149c10:	10800017 	ldw	r2,0(r2)
81149c14:	10800304 	addi	r2,r2,12
81149c18:	e0fffc17 	ldw	r3,-16(fp)
81149c1c:	18c00117 	ldw	r3,4(r3)
81149c20:	10c00035 	stwio	r3,0(r2)
81149c24:	e0bff417 	ldw	r2,-48(fp)
81149c28:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149c2c:	e0bff617 	ldw	r2,-40(fp)
81149c30:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81149c34:	e0fffe17 	ldw	r3,-8(fp)
81149c38:	e0bfef17 	ldw	r2,-68(fp)
81149c3c:	1885c83a 	sub	r2,r3,r2
}
81149c40:	e037883a 	mov	sp,fp
81149c44:	dfc00117 	ldw	ra,4(sp)
81149c48:	df000017 	ldw	fp,0(sp)
81149c4c:	dec00204 	addi	sp,sp,8
81149c50:	f800283a 	ret

81149c54 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81149c54:	defffe04 	addi	sp,sp,-8
81149c58:	de00012e 	bgeu	sp,et,81149c60 <alt_get_errno+0xc>
81149c5c:	003b68fa 	trap	3
81149c60:	dfc00115 	stw	ra,4(sp)
81149c64:	df000015 	stw	fp,0(sp)
81149c68:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81149c6c:	d0a01017 	ldw	r2,-32704(gp)
81149c70:	10000326 	beq	r2,zero,81149c80 <alt_get_errno+0x2c>
81149c74:	d0a01017 	ldw	r2,-32704(gp)
81149c78:	103ee83a 	callr	r2
81149c7c:	00000106 	br	81149c84 <alt_get_errno+0x30>
81149c80:	d0a07804 	addi	r2,gp,-32288
}
81149c84:	e037883a 	mov	sp,fp
81149c88:	dfc00117 	ldw	ra,4(sp)
81149c8c:	df000017 	ldw	fp,0(sp)
81149c90:	dec00204 	addi	sp,sp,8
81149c94:	f800283a 	ret

81149c98 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81149c98:	defffc04 	addi	sp,sp,-16
81149c9c:	de00012e 	bgeu	sp,et,81149ca4 <alt_msgdma_write_standard_descriptor+0xc>
81149ca0:	003b68fa 	trap	3
81149ca4:	df000315 	stw	fp,12(sp)
81149ca8:	df000304 	addi	fp,sp,12
81149cac:	e13ffd15 	stw	r4,-12(fp)
81149cb0:	e17ffe15 	stw	r5,-8(fp)
81149cb4:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81149cb8:	e0bffd17 	ldw	r2,-12(fp)
81149cbc:	10800037 	ldwio	r2,0(r2)
81149cc0:	1080010c 	andi	r2,r2,4
81149cc4:	10000226 	beq	r2,zero,81149cd0 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81149cc8:	00bff904 	movi	r2,-28
81149ccc:	00001506 	br	81149d24 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
81149cd0:	e0bfff17 	ldw	r2,-4(fp)
81149cd4:	10800017 	ldw	r2,0(r2)
81149cd8:	1007883a 	mov	r3,r2
81149cdc:	e0bffe17 	ldw	r2,-8(fp)
81149ce0:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
81149ce4:	e0bffe17 	ldw	r2,-8(fp)
81149ce8:	10800104 	addi	r2,r2,4
81149cec:	e0ffff17 	ldw	r3,-4(fp)
81149cf0:	18c00117 	ldw	r3,4(r3)
81149cf4:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81149cf8:	e0bffe17 	ldw	r2,-8(fp)
81149cfc:	10800204 	addi	r2,r2,8
81149d00:	e0ffff17 	ldw	r3,-4(fp)
81149d04:	18c00217 	ldw	r3,8(r3)
81149d08:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
81149d0c:	e0bffe17 	ldw	r2,-8(fp)
81149d10:	10800304 	addi	r2,r2,12
81149d14:	e0ffff17 	ldw	r3,-4(fp)
81149d18:	18c00317 	ldw	r3,12(r3)
81149d1c:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
81149d20:	0005883a 	mov	r2,zero
}
81149d24:	e037883a 	mov	sp,fp
81149d28:	df000017 	ldw	fp,0(sp)
81149d2c:	dec00104 	addi	sp,sp,4
81149d30:	f800283a 	ret

81149d34 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
81149d34:	defffc04 	addi	sp,sp,-16
81149d38:	de00012e 	bgeu	sp,et,81149d40 <alt_msgdma_write_extended_descriptor+0xc>
81149d3c:	003b68fa 	trap	3
81149d40:	df000315 	stw	fp,12(sp)
81149d44:	df000304 	addi	fp,sp,12
81149d48:	e13ffd15 	stw	r4,-12(fp)
81149d4c:	e17ffe15 	stw	r5,-8(fp)
81149d50:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81149d54:	e0bffd17 	ldw	r2,-12(fp)
81149d58:	10800037 	ldwio	r2,0(r2)
81149d5c:	1080010c 	andi	r2,r2,4
81149d60:	10000226 	beq	r2,zero,81149d6c <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
81149d64:	00bff904 	movi	r2,-28
81149d68:	00003b06 	br	81149e58 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81149d6c:	e0bfff17 	ldw	r2,-4(fp)
81149d70:	10800017 	ldw	r2,0(r2)
81149d74:	1007883a 	mov	r3,r2
81149d78:	e0bffe17 	ldw	r2,-8(fp)
81149d7c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
81149d80:	e0bffe17 	ldw	r2,-8(fp)
81149d84:	10800104 	addi	r2,r2,4
81149d88:	e0ffff17 	ldw	r3,-4(fp)
81149d8c:	18c00117 	ldw	r3,4(r3)
81149d90:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
81149d94:	e0bffe17 	ldw	r2,-8(fp)
81149d98:	10800204 	addi	r2,r2,8
81149d9c:	e0ffff17 	ldw	r3,-4(fp)
81149da0:	18c00217 	ldw	r3,8(r3)
81149da4:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81149da8:	e0bffe17 	ldw	r2,-8(fp)
81149dac:	10800304 	addi	r2,r2,12
81149db0:	e0ffff17 	ldw	r3,-4(fp)
81149db4:	18c0030b 	ldhu	r3,12(r3)
81149db8:	18ffffcc 	andi	r3,r3,65535
81149dbc:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
81149dc0:	e0bffe17 	ldw	r2,-8(fp)
81149dc4:	10800384 	addi	r2,r2,14
81149dc8:	e0ffff17 	ldw	r3,-4(fp)
81149dcc:	18c00383 	ldbu	r3,14(r3)
81149dd0:	18c03fcc 	andi	r3,r3,255
81149dd4:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81149dd8:	e0bffe17 	ldw	r2,-8(fp)
81149ddc:	108003c4 	addi	r2,r2,15
81149de0:	e0ffff17 	ldw	r3,-4(fp)
81149de4:	18c003c3 	ldbu	r3,15(r3)
81149de8:	18c03fcc 	andi	r3,r3,255
81149dec:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
81149df0:	e0bffe17 	ldw	r2,-8(fp)
81149df4:	10800404 	addi	r2,r2,16
81149df8:	e0ffff17 	ldw	r3,-4(fp)
81149dfc:	18c0040b 	ldhu	r3,16(r3)
81149e00:	18ffffcc 	andi	r3,r3,65535
81149e04:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
81149e08:	e0bffe17 	ldw	r2,-8(fp)
81149e0c:	10800484 	addi	r2,r2,18
81149e10:	e0ffff17 	ldw	r3,-4(fp)
81149e14:	18c0048b 	ldhu	r3,18(r3)
81149e18:	18ffffcc 	andi	r3,r3,65535
81149e1c:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
81149e20:	e0bffe17 	ldw	r2,-8(fp)
81149e24:	10800504 	addi	r2,r2,20
81149e28:	0007883a 	mov	r3,zero
81149e2c:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
81149e30:	e0bffe17 	ldw	r2,-8(fp)
81149e34:	10800604 	addi	r2,r2,24
81149e38:	0007883a 	mov	r3,zero
81149e3c:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
81149e40:	e0bffe17 	ldw	r2,-8(fp)
81149e44:	10800704 	addi	r2,r2,28
81149e48:	e0ffff17 	ldw	r3,-4(fp)
81149e4c:	18c00717 	ldw	r3,28(r3)
81149e50:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
81149e54:	0005883a 	mov	r2,zero
}
81149e58:	e037883a 	mov	sp,fp
81149e5c:	df000017 	ldw	fp,0(sp)
81149e60:	dec00104 	addi	sp,sp,4
81149e64:	f800283a 	ret

81149e68 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
81149e68:	defff804 	addi	sp,sp,-32
81149e6c:	de00012e 	bgeu	sp,et,81149e74 <alt_msgdma_irq+0xc>
81149e70:	003b68fa 	trap	3
81149e74:	dfc00715 	stw	ra,28(sp)
81149e78:	df000615 	stw	fp,24(sp)
81149e7c:	df000604 	addi	fp,sp,24
81149e80:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
81149e84:	e0bfff17 	ldw	r2,-4(fp)
81149e88:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81149e8c:	e0bffa17 	ldw	r2,-24(fp)
81149e90:	10801783 	ldbu	r2,94(r2)
81149e94:	10803fcc 	andi	r2,r2,255
81149e98:	10001126 	beq	r2,zero,81149ee0 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81149e9c:	e0bffa17 	ldw	r2,-24(fp)
81149ea0:	10800617 	ldw	r2,24(r2)
81149ea4:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81149ea8:	1007883a 	mov	r3,r2
81149eac:	00bffdc4 	movi	r2,-9
81149eb0:	1884703a 	and	r2,r3,r2
81149eb4:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81149eb8:	e0bffa17 	ldw	r2,-24(fp)
81149ebc:	10800617 	ldw	r2,24(r2)
81149ec0:	e0fffb17 	ldw	r3,-20(fp)
81149ec4:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81149ec8:	e0bffa17 	ldw	r2,-24(fp)
81149ecc:	10800617 	ldw	r2,24(r2)
81149ed0:	10800404 	addi	r2,r2,16
81149ed4:	00c00044 	movi	r3,1
81149ed8:	10c00035 	stwio	r3,0(r2)
81149edc:	00001106 	br	81149f24 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81149ee0:	e0bffa17 	ldw	r2,-24(fp)
81149ee4:	10800317 	ldw	r2,12(r2)
81149ee8:	10800104 	addi	r2,r2,4
81149eec:	10800037 	ldwio	r2,0(r2)
81149ef0:	1007883a 	mov	r3,r2
81149ef4:	00bffbc4 	movi	r2,-17
81149ef8:	1884703a 	and	r2,r3,r2
81149efc:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81149f00:	e0bffa17 	ldw	r2,-24(fp)
81149f04:	10800317 	ldw	r2,12(r2)
81149f08:	10800104 	addi	r2,r2,4
81149f0c:	e0fffb17 	ldw	r3,-20(fp)
81149f10:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81149f14:	e0bffa17 	ldw	r2,-24(fp)
81149f18:	10800317 	ldw	r2,12(r2)
81149f1c:	00c08004 	movi	r3,512
81149f20:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
81149f24:	e0bffa17 	ldw	r2,-24(fp)
81149f28:	10800b17 	ldw	r2,44(r2)
81149f2c:	10001226 	beq	r2,zero,81149f78 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149f30:	0005303a 	rdctl	r2,status
81149f34:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149f38:	e0fffd17 	ldw	r3,-12(fp)
81149f3c:	00bfff84 	movi	r2,-2
81149f40:	1884703a 	and	r2,r3,r2
81149f44:	1001703a 	wrctl	status,r2
  
  return context;
81149f48:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
81149f4c:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
81149f50:	e0bffa17 	ldw	r2,-24(fp)
81149f54:	10800b17 	ldw	r2,44(r2)
81149f58:	e0fffa17 	ldw	r3,-24(fp)
81149f5c:	18c00c17 	ldw	r3,48(r3)
81149f60:	1809883a 	mov	r4,r3
81149f64:	103ee83a 	callr	r2
81149f68:	e0bffc17 	ldw	r2,-16(fp)
81149f6c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149f70:	e0bffe17 	ldw	r2,-8(fp)
81149f74:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
81149f78:	e0bffa17 	ldw	r2,-24(fp)
81149f7c:	10801783 	ldbu	r2,94(r2)
81149f80:	10803fcc 	andi	r2,r2,255
81149f84:	10000a26 	beq	r2,zero,81149fb0 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81149f88:	e0bffa17 	ldw	r2,-24(fp)
81149f8c:	10800617 	ldw	r2,24(r2)
81149f90:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81149f94:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81149f98:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81149f9c:	e0bffa17 	ldw	r2,-24(fp)
81149fa0:	10800617 	ldw	r2,24(r2)
81149fa4:	e0fffb17 	ldw	r3,-20(fp)
81149fa8:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81149fac:	00000c06 	br	81149fe0 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81149fb0:	e0bffa17 	ldw	r2,-24(fp)
81149fb4:	10800317 	ldw	r2,12(r2)
81149fb8:	10800104 	addi	r2,r2,4
81149fbc:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
81149fc0:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81149fc4:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81149fc8:	e0bffa17 	ldw	r2,-24(fp)
81149fcc:	10800317 	ldw	r2,12(r2)
81149fd0:	10800104 	addi	r2,r2,4
81149fd4:	e0fffb17 	ldw	r3,-20(fp)
81149fd8:	10c00035 	stwio	r3,0(r2)
    }

    return;
81149fdc:	0001883a 	nop
}
81149fe0:	e037883a 	mov	sp,fp
81149fe4:	dfc00117 	ldw	ra,4(sp)
81149fe8:	df000017 	ldw	fp,0(sp)
81149fec:	dec00204 	addi	sp,sp,8
81149ff0:	f800283a 	ret

81149ff4 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81149ff4:	defffb04 	addi	sp,sp,-20
81149ff8:	de00012e 	bgeu	sp,et,8114a000 <alt_msgdma_construct_standard_descriptor+0xc>
81149ffc:	003b68fa 	trap	3
8114a000:	df000415 	stw	fp,16(sp)
8114a004:	df000404 	addi	fp,sp,16
8114a008:	e13ffc15 	stw	r4,-16(fp)
8114a00c:	e17ffd15 	stw	r5,-12(fp)
8114a010:	e1bffe15 	stw	r6,-8(fp)
8114a014:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
8114a018:	e0bffc17 	ldw	r2,-16(fp)
8114a01c:	10c01217 	ldw	r3,72(r2)
8114a020:	e0800117 	ldw	r2,4(fp)
8114a024:	18800436 	bltu	r3,r2,8114a038 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
8114a028:	e0bffc17 	ldw	r2,-16(fp)
8114a02c:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
8114a030:	10803fcc 	andi	r2,r2,255
8114a034:	10000226 	beq	r2,zero,8114a040 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8114a038:	00bffa84 	movi	r2,-22
8114a03c:	00000e06 	br	8114a078 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
8114a040:	e0bffd17 	ldw	r2,-12(fp)
8114a044:	e0fffe17 	ldw	r3,-8(fp)
8114a048:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
8114a04c:	e0bffd17 	ldw	r2,-12(fp)
8114a050:	e0ffff17 	ldw	r3,-4(fp)
8114a054:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114a058:	e0bffd17 	ldw	r2,-12(fp)
8114a05c:	e0c00117 	ldw	r3,4(fp)
8114a060:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114a064:	e0800217 	ldw	r2,8(fp)
8114a068:	10e00034 	orhi	r3,r2,32768
8114a06c:	e0bffd17 	ldw	r2,-12(fp)
8114a070:	10c00315 	stw	r3,12(r2)
    
    return 0;
8114a074:	0005883a 	mov	r2,zero
}
8114a078:	e037883a 	mov	sp,fp
8114a07c:	df000017 	ldw	fp,0(sp)
8114a080:	dec00104 	addi	sp,sp,4
8114a084:	f800283a 	ret

8114a088 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8114a088:	defff604 	addi	sp,sp,-40
8114a08c:	de00012e 	bgeu	sp,et,8114a094 <alt_msgdma_construct_extended_descriptor+0xc>
8114a090:	003b68fa 	trap	3
8114a094:	df000915 	stw	fp,36(sp)
8114a098:	df000904 	addi	fp,sp,36
8114a09c:	e13ff715 	stw	r4,-36(fp)
8114a0a0:	e17ff815 	stw	r5,-32(fp)
8114a0a4:	e1bff915 	stw	r6,-28(fp)
8114a0a8:	e1fffa15 	stw	r7,-24(fp)
8114a0ac:	e1800317 	ldw	r6,12(fp)
8114a0b0:	e1400417 	ldw	r5,16(fp)
8114a0b4:	e1000517 	ldw	r4,20(fp)
8114a0b8:	e0c00617 	ldw	r3,24(fp)
8114a0bc:	e0800717 	ldw	r2,28(fp)
8114a0c0:	e1bffb0d 	sth	r6,-20(fp)
8114a0c4:	e17ffc05 	stb	r5,-16(fp)
8114a0c8:	e13ffd05 	stb	r4,-12(fp)
8114a0cc:	e0fffe0d 	sth	r3,-8(fp)
8114a0d0:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
8114a0d4:	e0bff717 	ldw	r2,-36(fp)
8114a0d8:	10c01217 	ldw	r3,72(r2)
8114a0dc:	e0800117 	ldw	r2,4(fp)
8114a0e0:	18801936 	bltu	r3,r2,8114a148 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8114a0e4:	e13ff717 	ldw	r4,-36(fp)
8114a0e8:	20801317 	ldw	r2,76(r4)
8114a0ec:	20c01417 	ldw	r3,80(r4)
8114a0f0:	e13ffe0b 	ldhu	r4,-8(fp)
8114a0f4:	213fffcc 	andi	r4,r4,65535
8114a0f8:	2015883a 	mov	r10,r4
8114a0fc:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
8114a100:	1ac01136 	bltu	r3,r11,8114a148 <alt_msgdma_construct_extended_descriptor+0xc0>
8114a104:	58c0011e 	bne	r11,r3,8114a10c <alt_msgdma_construct_extended_descriptor+0x84>
8114a108:	12800f36 	bltu	r2,r10,8114a148 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114a10c:	e13ff717 	ldw	r4,-36(fp)
8114a110:	20801317 	ldw	r2,76(r4)
8114a114:	20c01417 	ldw	r3,80(r4)
8114a118:	e13fff0b 	ldhu	r4,-4(fp)
8114a11c:	213fffcc 	andi	r4,r4,65535
8114a120:	2011883a 	mov	r8,r4
8114a124:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
8114a128:	1a400736 	bltu	r3,r9,8114a148 <alt_msgdma_construct_extended_descriptor+0xc0>
8114a12c:	48c0011e 	bne	r9,r3,8114a134 <alt_msgdma_construct_extended_descriptor+0xac>
8114a130:	12000536 	bltu	r2,r8,8114a148 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8114a134:	e0bff717 	ldw	r2,-36(fp)
8114a138:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114a13c:	10803fcc 	andi	r2,r2,255
8114a140:	10800060 	cmpeqi	r2,r2,1
8114a144:	1000021e 	bne	r2,zero,8114a150 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
8114a148:	00bffa84 	movi	r2,-22
8114a14c:	00002106 	br	8114a1d4 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
8114a150:	e0bff817 	ldw	r2,-32(fp)
8114a154:	e0fff917 	ldw	r3,-28(fp)
8114a158:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
8114a15c:	e0bff817 	ldw	r2,-32(fp)
8114a160:	e0fffa17 	ldw	r3,-24(fp)
8114a164:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114a168:	e0bff817 	ldw	r2,-32(fp)
8114a16c:	e0c00117 	ldw	r3,4(fp)
8114a170:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8114a174:	e0bff817 	ldw	r2,-32(fp)
8114a178:	e0fffb0b 	ldhu	r3,-20(fp)
8114a17c:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
8114a180:	e0bff817 	ldw	r2,-32(fp)
8114a184:	e0fffc03 	ldbu	r3,-16(fp)
8114a188:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
8114a18c:	e0bff817 	ldw	r2,-32(fp)
8114a190:	e0fffd03 	ldbu	r3,-12(fp)
8114a194:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
8114a198:	e0bff817 	ldw	r2,-32(fp)
8114a19c:	e0fffe0b 	ldhu	r3,-8(fp)
8114a1a0:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
8114a1a4:	e0bff817 	ldw	r2,-32(fp)
8114a1a8:	e0ffff0b 	ldhu	r3,-4(fp)
8114a1ac:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
8114a1b0:	e0bff817 	ldw	r2,-32(fp)
8114a1b4:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
8114a1b8:	e0bff817 	ldw	r2,-32(fp)
8114a1bc:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114a1c0:	e0800217 	ldw	r2,8(fp)
8114a1c4:	10e00034 	orhi	r3,r2,32768
8114a1c8:	e0bff817 	ldw	r2,-32(fp)
8114a1cc:	10c00715 	stw	r3,28(r2)

  return 0 ;
8114a1d0:	0005883a 	mov	r2,zero

}
8114a1d4:	e037883a 	mov	sp,fp
8114a1d8:	df000017 	ldw	fp,0(sp)
8114a1dc:	dec00104 	addi	sp,sp,4
8114a1e0:	f800283a 	ret

8114a1e4 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8114a1e4:	deffee04 	addi	sp,sp,-72
8114a1e8:	de00012e 	bgeu	sp,et,8114a1f0 <alt_msgdma_descriptor_async_transfer+0xc>
8114a1ec:	003b68fa 	trap	3
8114a1f0:	dfc01115 	stw	ra,68(sp)
8114a1f4:	df001015 	stw	fp,64(sp)
8114a1f8:	df001004 	addi	fp,sp,64
8114a1fc:	e13ffd15 	stw	r4,-12(fp)
8114a200:	e17ffe15 	stw	r5,-8(fp)
8114a204:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
8114a208:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
8114a20c:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
8114a210:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114a214:	e0bffd17 	ldw	r2,-12(fp)
8114a218:	10800317 	ldw	r2,12(r2)
8114a21c:	10800204 	addi	r2,r2,8
8114a220:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
8114a224:	10bfffcc 	andi	r2,r2,65535
8114a228:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114a22c:	e0bffd17 	ldw	r2,-12(fp)
8114a230:	10800317 	ldw	r2,12(r2)
8114a234:	10800204 	addi	r2,r2,8
8114a238:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8114a23c:	1004d43a 	srli	r2,r2,16
8114a240:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114a244:	e0bffd17 	ldw	r2,-12(fp)
8114a248:	10800917 	ldw	r2,36(r2)
8114a24c:	e0fff417 	ldw	r3,-48(fp)
8114a250:	1880042e 	bgeu	r3,r2,8114a264 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
8114a254:	e0bffd17 	ldw	r2,-12(fp)
8114a258:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114a25c:	e0fff317 	ldw	r3,-52(fp)
8114a260:	18800236 	bltu	r3,r2,8114a26c <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
8114a264:	00bff904 	movi	r2,-28
8114a268:	0000a906 	br	8114a510 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
8114a26c:	e0bffd17 	ldw	r2,-12(fp)
8114a270:	10801817 	ldw	r2,96(r2)
8114a274:	e0bff615 	stw	r2,-40(fp)
8114a278:	e03ffc0d 	sth	zero,-16(fp)
8114a27c:	e0bffc0b 	ldhu	r2,-16(fp)
8114a280:	e0fffc84 	addi	r3,fp,-14
8114a284:	180d883a 	mov	r6,r3
8114a288:	100b883a 	mov	r5,r2
8114a28c:	e13ff617 	ldw	r4,-40(fp)
8114a290:	114075c0 	call	8114075c <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114a294:	00800804 	movi	r2,32
8114a298:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a29c:	0005303a 	rdctl	r2,status
8114a2a0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a2a4:	e0fff717 	ldw	r3,-36(fp)
8114a2a8:	00bfff84 	movi	r2,-2
8114a2ac:	1884703a 	and	r2,r3,r2
8114a2b0:	1001703a 	wrctl	status,r2
  
  return context;
8114a2b4:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8114a2b8:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114a2bc:	e0bffd17 	ldw	r2,-12(fp)
8114a2c0:	10800317 	ldw	r2,12(r2)
8114a2c4:	10800104 	addi	r2,r2,4
8114a2c8:	e0fff117 	ldw	r3,-60(fp)
8114a2cc:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
8114a2d0:	e0bffd17 	ldw	r2,-12(fp)
8114a2d4:	10800317 	ldw	r2,12(r2)
8114a2d8:	e0fffd17 	ldw	r3,-12(fp)
8114a2dc:	18c00317 	ldw	r3,12(r3)
8114a2e0:	18c00037 	ldwio	r3,0(r3)
8114a2e4:	10c00035 	stwio	r3,0(r2)
8114a2e8:	e0bff217 	ldw	r2,-56(fp)
8114a2ec:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a2f0:	e0bffb17 	ldw	r2,-20(fp)
8114a2f4:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
8114a2f8:	e0bffe17 	ldw	r2,-8(fp)
8114a2fc:	10001e26 	beq	r2,zero,8114a378 <alt_msgdma_descriptor_async_transfer+0x194>
8114a300:	e0bfff17 	ldw	r2,-4(fp)
8114a304:	10001c1e 	bne	r2,zero,8114a378 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114a308:	00001106 	br	8114a350 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8114a30c:	01000044 	movi	r4,1
8114a310:	1137ee40 	call	81137ee4 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114a314:	e0bff00b 	ldhu	r2,-64(fp)
8114a318:	1084e230 	cmpltui	r2,r2,5000
8114a31c:	1000091e 	bne	r2,zero,8114a344 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
8114a320:	01204574 	movhi	r4,33045
8114a324:	210b6504 	addi	r4,r4,11668
8114a328:	114c6380 	call	8114c638 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114a32c:	e0bffd17 	ldw	r2,-12(fp)
8114a330:	10801817 	ldw	r2,96(r2)
8114a334:	1009883a 	mov	r4,r2
8114a338:	1140ae40 	call	81140ae4 <OSSemPost>
				
                return -ETIME;
8114a33c:	00bff084 	movi	r2,-62
8114a340:	00007306 	br	8114a510 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
8114a344:	e0bff00b 	ldhu	r2,-64(fp)
8114a348:	10800044 	addi	r2,r2,1
8114a34c:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114a350:	e0bffd17 	ldw	r2,-12(fp)
8114a354:	10c00317 	ldw	r3,12(r2)
8114a358:	e0bffd17 	ldw	r2,-12(fp)
8114a35c:	10800417 	ldw	r2,16(r2)
8114a360:	e1bffe17 	ldw	r6,-8(fp)
8114a364:	100b883a 	mov	r5,r2
8114a368:	1809883a 	mov	r4,r3
8114a36c:	1149c980 	call	81149c98 <alt_msgdma_write_standard_descriptor>
8114a370:	103fe61e 	bne	r2,zero,8114a30c <__reset+0xfb12a30c>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
8114a374:	00002706 	br	8114a414 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114a378:	e0bffe17 	ldw	r2,-8(fp)
8114a37c:	10001f1e 	bne	r2,zero,8114a3fc <alt_msgdma_descriptor_async_transfer+0x218>
8114a380:	e0bfff17 	ldw	r2,-4(fp)
8114a384:	10001d26 	beq	r2,zero,8114a3fc <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
8114a388:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114a38c:	00001106 	br	8114a3d4 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8114a390:	01000044 	movi	r4,1
8114a394:	1137ee40 	call	81137ee4 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114a398:	e0bff00b 	ldhu	r2,-64(fp)
8114a39c:	1084e230 	cmpltui	r2,r2,5000
8114a3a0:	1000091e 	bne	r2,zero,8114a3c8 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
8114a3a4:	01204574 	movhi	r4,33045
8114a3a8:	210b7b04 	addi	r4,r4,11756
8114a3ac:	114c6380 	call	8114c638 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114a3b0:	e0bffd17 	ldw	r2,-12(fp)
8114a3b4:	10801817 	ldw	r2,96(r2)
8114a3b8:	1009883a 	mov	r4,r2
8114a3bc:	1140ae40 	call	81140ae4 <OSSemPost>
				
                return -ETIME;
8114a3c0:	00bff084 	movi	r2,-62
8114a3c4:	00005206 	br	8114a510 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
8114a3c8:	e0bff00b 	ldhu	r2,-64(fp)
8114a3cc:	10800044 	addi	r2,r2,1
8114a3d0:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114a3d4:	e0bffd17 	ldw	r2,-12(fp)
8114a3d8:	10c00317 	ldw	r3,12(r2)
8114a3dc:	e0bffd17 	ldw	r2,-12(fp)
8114a3e0:	10800417 	ldw	r2,16(r2)
8114a3e4:	e1bfff17 	ldw	r6,-4(fp)
8114a3e8:	100b883a 	mov	r5,r2
8114a3ec:	1809883a 	mov	r4,r3
8114a3f0:	1149d340 	call	81149d34 <alt_msgdma_write_extended_descriptor>
8114a3f4:	103fe61e 	bne	r2,zero,8114a390 <__reset+0xfb12a390>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114a3f8:	00000606 	br	8114a414 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8114a3fc:	e0bffd17 	ldw	r2,-12(fp)
8114a400:	10801817 	ldw	r2,96(r2)
8114a404:	1009883a 	mov	r4,r2
8114a408:	1140ae40 	call	81140ae4 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
8114a40c:	00bfffc4 	movi	r2,-1
8114a410:	00003f06 	br	8114a510 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
8114a414:	e0bffd17 	ldw	r2,-12(fp)
8114a418:	10800b17 	ldw	r2,44(r2)
8114a41c:	10001c26 	beq	r2,zero,8114a490 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
8114a420:	e0bffd17 	ldw	r2,-12(fp)
8114a424:	10c00d17 	ldw	r3,52(r2)
8114a428:	e0bff117 	ldw	r2,-60(fp)
8114a42c:	1884b03a 	or	r2,r3,r2
8114a430:	10800514 	ori	r2,r2,20
8114a434:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8114a438:	e0fff117 	ldw	r3,-60(fp)
8114a43c:	00bff7c4 	movi	r2,-33
8114a440:	1884703a 	and	r2,r3,r2
8114a444:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a448:	0005303a 	rdctl	r2,status
8114a44c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a450:	e0fff917 	ldw	r3,-28(fp)
8114a454:	00bfff84 	movi	r2,-2
8114a458:	1884703a 	and	r2,r3,r2
8114a45c:	1001703a 	wrctl	status,r2
  
  return context;
8114a460:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
8114a464:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114a468:	e0bffd17 	ldw	r2,-12(fp)
8114a46c:	10800317 	ldw	r2,12(r2)
8114a470:	10800104 	addi	r2,r2,4
8114a474:	e0fff117 	ldw	r3,-60(fp)
8114a478:	10c00035 	stwio	r3,0(r2)
8114a47c:	e0bff217 	ldw	r2,-56(fp)
8114a480:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a484:	e0bff517 	ldw	r2,-44(fp)
8114a488:	1001703a 	wrctl	status,r2
8114a48c:	00001b06 	br	8114a4fc <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
8114a490:	e0bffd17 	ldw	r2,-12(fp)
8114a494:	10c00d17 	ldw	r3,52(r2)
8114a498:	e0bff117 	ldw	r2,-60(fp)
8114a49c:	1884b03a 	or	r2,r3,r2
8114a4a0:	10800114 	ori	r2,r2,4
8114a4a4:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
8114a4a8:	e0fff117 	ldw	r3,-60(fp)
8114a4ac:	00bff3c4 	movi	r2,-49
8114a4b0:	1884703a 	and	r2,r3,r2
8114a4b4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a4b8:	0005303a 	rdctl	r2,status
8114a4bc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a4c0:	e0fffa17 	ldw	r3,-24(fp)
8114a4c4:	00bfff84 	movi	r2,-2
8114a4c8:	1884703a 	and	r2,r3,r2
8114a4cc:	1001703a 	wrctl	status,r2
  
  return context;
8114a4d0:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
8114a4d4:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114a4d8:	e0bffd17 	ldw	r2,-12(fp)
8114a4dc:	10800317 	ldw	r2,12(r2)
8114a4e0:	10800104 	addi	r2,r2,4
8114a4e4:	e0fff117 	ldw	r3,-60(fp)
8114a4e8:	10c00035 	stwio	r3,0(r2)
8114a4ec:	e0bff217 	ldw	r2,-56(fp)
8114a4f0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a4f4:	e0bff817 	ldw	r2,-32(fp)
8114a4f8:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
8114a4fc:	e0bffd17 	ldw	r2,-12(fp)
8114a500:	10801817 	ldw	r2,96(r2)
8114a504:	1009883a 	mov	r4,r2
8114a508:	1140ae40 	call	81140ae4 <OSSemPost>
    
    return 0;
8114a50c:	0005883a 	mov	r2,zero
}
8114a510:	e037883a 	mov	sp,fp
8114a514:	dfc00117 	ldw	ra,4(sp)
8114a518:	df000017 	ldw	fp,0(sp)
8114a51c:	dec00204 	addi	sp,sp,8
8114a520:	f800283a 	ret

8114a524 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8114a524:	deffee04 	addi	sp,sp,-72
8114a528:	de00012e 	bgeu	sp,et,8114a530 <alt_msgdma_descriptor_sync_transfer+0xc>
8114a52c:	003b68fa 	trap	3
8114a530:	dfc01115 	stw	ra,68(sp)
8114a534:	df001015 	stw	fp,64(sp)
8114a538:	df001004 	addi	fp,sp,64
8114a53c:	e13ffd15 	stw	r4,-12(fp)
8114a540:	e17ffe15 	stw	r5,-8(fp)
8114a544:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
8114a548:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
8114a54c:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
8114a550:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
8114a554:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114a558:	e0bffd17 	ldw	r2,-12(fp)
8114a55c:	10800317 	ldw	r2,12(r2)
8114a560:	10800204 	addi	r2,r2,8
8114a564:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
8114a568:	10bfffcc 	andi	r2,r2,65535
8114a56c:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114a570:	e0bffd17 	ldw	r2,-12(fp)
8114a574:	10800317 	ldw	r2,12(r2)
8114a578:	10800204 	addi	r2,r2,8
8114a57c:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8114a580:	1004d43a 	srli	r2,r2,16
8114a584:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
8114a588:	00807804 	movi	r2,480
8114a58c:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114a590:	00001906 	br	8114a5f8 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
8114a594:	01000044 	movi	r4,1
8114a598:	1137ee40 	call	81137ee4 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114a59c:	e0bff10b 	ldhu	r2,-60(fp)
8114a5a0:	1084e230 	cmpltui	r2,r2,5000
8114a5a4:	1000051e 	bne	r2,zero,8114a5bc <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
8114a5a8:	01204574 	movhi	r4,33045
8114a5ac:	210b9104 	addi	r4,r4,11844
8114a5b0:	114c6380 	call	8114c638 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
8114a5b4:	00bff084 	movi	r2,-62
8114a5b8:	0000d706 	br	8114a918 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
8114a5bc:	e0bff10b 	ldhu	r2,-60(fp)
8114a5c0:	10800044 	addi	r2,r2,1
8114a5c4:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114a5c8:	e0bffd17 	ldw	r2,-12(fp)
8114a5cc:	10800317 	ldw	r2,12(r2)
8114a5d0:	10800204 	addi	r2,r2,8
8114a5d4:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
8114a5d8:	10bfffcc 	andi	r2,r2,65535
8114a5dc:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114a5e0:	e0bffd17 	ldw	r2,-12(fp)
8114a5e4:	10800317 	ldw	r2,12(r2)
8114a5e8:	10800204 	addi	r2,r2,8
8114a5ec:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
8114a5f0:	1004d43a 	srli	r2,r2,16
8114a5f4:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114a5f8:	e0bffd17 	ldw	r2,-12(fp)
8114a5fc:	10800917 	ldw	r2,36(r2)
8114a600:	e0fff317 	ldw	r3,-52(fp)
8114a604:	18bfe32e 	bgeu	r3,r2,8114a594 <__reset+0xfb12a594>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
8114a608:	e0bffd17 	ldw	r2,-12(fp)
8114a60c:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114a610:	e0fff217 	ldw	r3,-56(fp)
8114a614:	18bfdf2e 	bgeu	r3,r2,8114a594 <__reset+0xfb12a594>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
8114a618:	e0bffd17 	ldw	r2,-12(fp)
8114a61c:	10801817 	ldw	r2,96(r2)
8114a620:	e0bff815 	stw	r2,-32(fp)
8114a624:	e03ffc0d 	sth	zero,-16(fp)
8114a628:	e0bffc0b 	ldhu	r2,-16(fp)
8114a62c:	e0fffc84 	addi	r3,fp,-14
8114a630:	180d883a 	mov	r6,r3
8114a634:	100b883a 	mov	r5,r2
8114a638:	e13ff817 	ldw	r4,-32(fp)
8114a63c:	114075c0 	call	8114075c <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a640:	0005303a 	rdctl	r2,status
8114a644:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a648:	e0fffb17 	ldw	r3,-20(fp)
8114a64c:	00bfff84 	movi	r2,-2
8114a650:	1884703a 	and	r2,r3,r2
8114a654:	1001703a 	wrctl	status,r2
  
  return context;
8114a658:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
8114a65c:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8114a660:	e0bffd17 	ldw	r2,-12(fp)
8114a664:	10800317 	ldw	r2,12(r2)
8114a668:	10800104 	addi	r2,r2,4
8114a66c:	00c00804 	movi	r3,32
8114a670:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
8114a674:	e0bffd17 	ldw	r2,-12(fp)
8114a678:	10800317 	ldw	r2,12(r2)
8114a67c:	e0fffd17 	ldw	r3,-12(fp)
8114a680:	18c00317 	ldw	r3,12(r3)
8114a684:	18c00037 	ldwio	r3,0(r3)
8114a688:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
8114a68c:	e0bffe17 	ldw	r2,-8(fp)
8114a690:	10001f26 	beq	r2,zero,8114a710 <alt_msgdma_descriptor_sync_transfer+0x1ec>
8114a694:	e0bfff17 	ldw	r2,-4(fp)
8114a698:	10001d1e 	bne	r2,zero,8114a710 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
8114a69c:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114a6a0:	00001106 	br	8114a6e8 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
8114a6a4:	01000044 	movi	r4,1
8114a6a8:	1137ee40 	call	81137ee4 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114a6ac:	e0bff10b 	ldhu	r2,-60(fp)
8114a6b0:	1084e230 	cmpltui	r2,r2,5000
8114a6b4:	1000091e 	bne	r2,zero,8114a6dc <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
8114a6b8:	01204574 	movhi	r4,33045
8114a6bc:	210ba504 	addi	r4,r4,11924
8114a6c0:	114c6380 	call	8114c638 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114a6c4:	e0bffd17 	ldw	r2,-12(fp)
8114a6c8:	10801817 	ldw	r2,96(r2)
8114a6cc:	1009883a 	mov	r4,r2
8114a6d0:	1140ae40 	call	81140ae4 <OSSemPost>
				
                return -ETIME;
8114a6d4:	00bff084 	movi	r2,-62
8114a6d8:	00008f06 	br	8114a918 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
8114a6dc:	e0bff10b 	ldhu	r2,-60(fp)
8114a6e0:	10800044 	addi	r2,r2,1
8114a6e4:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114a6e8:	e0bffd17 	ldw	r2,-12(fp)
8114a6ec:	10c00317 	ldw	r3,12(r2)
8114a6f0:	e0bffd17 	ldw	r2,-12(fp)
8114a6f4:	10800417 	ldw	r2,16(r2)
8114a6f8:	e1bffe17 	ldw	r6,-8(fp)
8114a6fc:	100b883a 	mov	r5,r2
8114a700:	1809883a 	mov	r4,r3
8114a704:	1149c980 	call	81149c98 <alt_msgdma_write_standard_descriptor>
8114a708:	103fe61e 	bne	r2,zero,8114a6a4 <__reset+0xfb12a6a4>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
8114a70c:	00002706 	br	8114a7ac <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114a710:	e0bffe17 	ldw	r2,-8(fp)
8114a714:	10001f1e 	bne	r2,zero,8114a794 <alt_msgdma_descriptor_sync_transfer+0x270>
8114a718:	e0bfff17 	ldw	r2,-4(fp)
8114a71c:	10001d26 	beq	r2,zero,8114a794 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
8114a720:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114a724:	00001106 	br	8114a76c <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8114a728:	01000044 	movi	r4,1
8114a72c:	1137ee40 	call	81137ee4 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114a730:	e0bff10b 	ldhu	r2,-60(fp)
8114a734:	1084e230 	cmpltui	r2,r2,5000
8114a738:	1000091e 	bne	r2,zero,8114a760 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
8114a73c:	01204574 	movhi	r4,33045
8114a740:	210bb604 	addi	r4,r4,11992
8114a744:	114c6380 	call	8114c638 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114a748:	e0bffd17 	ldw	r2,-12(fp)
8114a74c:	10801817 	ldw	r2,96(r2)
8114a750:	1009883a 	mov	r4,r2
8114a754:	1140ae40 	call	81140ae4 <OSSemPost>
				
                return -ETIME;
8114a758:	00bff084 	movi	r2,-62
8114a75c:	00006e06 	br	8114a918 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
8114a760:	e0bff10b 	ldhu	r2,-60(fp)
8114a764:	10800044 	addi	r2,r2,1
8114a768:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114a76c:	e0bffd17 	ldw	r2,-12(fp)
8114a770:	10c00317 	ldw	r3,12(r2)
8114a774:	e0bffd17 	ldw	r2,-12(fp)
8114a778:	10800417 	ldw	r2,16(r2)
8114a77c:	e1bfff17 	ldw	r6,-4(fp)
8114a780:	100b883a 	mov	r5,r2
8114a784:	1809883a 	mov	r4,r3
8114a788:	1149d340 	call	81149d34 <alt_msgdma_write_extended_descriptor>
8114a78c:	103fe61e 	bne	r2,zero,8114a728 <__reset+0xfb12a728>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114a790:	00000606 	br	8114a7ac <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8114a794:	e0bffd17 	ldw	r2,-12(fp)
8114a798:	10801817 	ldw	r2,96(r2)
8114a79c:	1009883a 	mov	r4,r2
8114a7a0:	1140ae40 	call	81140ae4 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
8114a7a4:	00bfffc4 	movi	r2,-1
8114a7a8:	00005b06 	br	8114a918 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8114a7ac:	e0bffd17 	ldw	r2,-12(fp)
8114a7b0:	10800317 	ldw	r2,12(r2)
8114a7b4:	10800104 	addi	r2,r2,4
8114a7b8:	e0fffd17 	ldw	r3,-12(fp)
8114a7bc:	19000d17 	ldw	r4,52(r3)
8114a7c0:	00fff2c4 	movi	r3,-53
8114a7c4:	20c6703a 	and	r3,r4,r3
8114a7c8:	18c00114 	ori	r3,r3,4
8114a7cc:	10c00035 	stwio	r3,0(r2)
8114a7d0:	e0bff517 	ldw	r2,-44(fp)
8114a7d4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a7d8:	e0bff717 	ldw	r2,-36(fp)
8114a7dc:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
8114a7e0:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8114a7e4:	e0bffd17 	ldw	r2,-12(fp)
8114a7e8:	10800317 	ldw	r2,12(r2)
8114a7ec:	10800037 	ldwio	r2,0(r2)
8114a7f0:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
8114a7f4:	00001506 	br	8114a84c <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
8114a7f8:	01000044 	movi	r4,1
8114a7fc:	1137ee40 	call	81137ee4 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114a800:	e0bff10b 	ldhu	r2,-60(fp)
8114a804:	1084e230 	cmpltui	r2,r2,5000
8114a808:	1000091e 	bne	r2,zero,8114a830 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
8114a80c:	01204574 	movhi	r4,33045
8114a810:	210bc704 	addi	r4,r4,12060
8114a814:	114c6380 	call	8114c638 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
8114a818:	e0bffd17 	ldw	r2,-12(fp)
8114a81c:	10801817 	ldw	r2,96(r2)
8114a820:	1009883a 	mov	r4,r2
8114a824:	1140ae40 	call	81140ae4 <OSSemPost>
			
            return -ETIME;
8114a828:	00bff084 	movi	r2,-62
8114a82c:	00003a06 	br	8114a918 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
8114a830:	e0bff10b 	ldhu	r2,-60(fp)
8114a834:	10800044 	addi	r2,r2,1
8114a838:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8114a83c:	e0bffd17 	ldw	r2,-12(fp)
8114a840:	10800317 	ldw	r2,12(r2)
8114a844:	10800037 	ldwio	r2,0(r2)
8114a848:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
8114a84c:	e0fff017 	ldw	r3,-64(fp)
8114a850:	e0bff617 	ldw	r2,-40(fp)
8114a854:	1884703a 	and	r2,r3,r2
8114a858:	1000031e 	bne	r2,zero,8114a868 <alt_msgdma_descriptor_sync_transfer+0x344>
8114a85c:	e0bff017 	ldw	r2,-64(fp)
8114a860:	1080004c 	andi	r2,r2,1
8114a864:	103fe41e 	bne	r2,zero,8114a7f8 <__reset+0xfb12a7f8>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
8114a868:	e0fff017 	ldw	r3,-64(fp)
8114a86c:	e0bff617 	ldw	r2,-40(fp)
8114a870:	1884703a 	and	r2,r3,r2
8114a874:	10000626 	beq	r2,zero,8114a890 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8114a878:	e0bffd17 	ldw	r2,-12(fp)
8114a87c:	10801817 	ldw	r2,96(r2)
8114a880:	1009883a 	mov	r4,r2
8114a884:	1140ae40 	call	81140ae4 <OSSemPost>
		
        return error;
8114a888:	e0bff617 	ldw	r2,-40(fp)
8114a88c:	00002206 	br	8114a918 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
8114a890:	e0bffd17 	ldw	r2,-12(fp)
8114a894:	10800317 	ldw	r2,12(r2)
8114a898:	10800104 	addi	r2,r2,4
8114a89c:	10800037 	ldwio	r2,0(r2)
8114a8a0:	10800814 	ori	r2,r2,32
8114a8a4:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a8a8:	0005303a 	rdctl	r2,status
8114a8ac:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a8b0:	e0fffa17 	ldw	r3,-24(fp)
8114a8b4:	00bfff84 	movi	r2,-2
8114a8b8:	1884703a 	and	r2,r3,r2
8114a8bc:	1001703a 	wrctl	status,r2
  
  return context;
8114a8c0:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
8114a8c4:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114a8c8:	e0bffd17 	ldw	r2,-12(fp)
8114a8cc:	10800317 	ldw	r2,12(r2)
8114a8d0:	10800104 	addi	r2,r2,4
8114a8d4:	e0fff417 	ldw	r3,-48(fp)
8114a8d8:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
8114a8dc:	e0bffd17 	ldw	r2,-12(fp)
8114a8e0:	10800317 	ldw	r2,12(r2)
8114a8e4:	e0fffd17 	ldw	r3,-12(fp)
8114a8e8:	18c00317 	ldw	r3,12(r3)
8114a8ec:	18c00037 	ldwio	r3,0(r3)
8114a8f0:	10c00035 	stwio	r3,0(r2)
8114a8f4:	e0bff517 	ldw	r2,-44(fp)
8114a8f8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a8fc:	e0bff917 	ldw	r2,-28(fp)
8114a900:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
8114a904:	e0bffd17 	ldw	r2,-12(fp)
8114a908:	10801817 	ldw	r2,96(r2)
8114a90c:	1009883a 	mov	r4,r2
8114a910:	1140ae40 	call	81140ae4 <OSSemPost>
    
    return 0;
8114a914:	0005883a 	mov	r2,zero

}
8114a918:	e037883a 	mov	sp,fp
8114a91c:	dfc00117 	ldw	ra,4(sp)
8114a920:	df000017 	ldw	fp,0(sp)
8114a924:	dec00204 	addi	sp,sp,8
8114a928:	f800283a 	ret

8114a92c <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
8114a92c:	defff804 	addi	sp,sp,-32
8114a930:	de00012e 	bgeu	sp,et,8114a938 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
8114a934:	003b68fa 	trap	3
8114a938:	dfc00715 	stw	ra,28(sp)
8114a93c:	df000615 	stw	fp,24(sp)
8114a940:	df000604 	addi	fp,sp,24
8114a944:	e13ffc15 	stw	r4,-16(fp)
8114a948:	e17ffd15 	stw	r5,-12(fp)
8114a94c:	e1bffe15 	stw	r6,-8(fp)
8114a950:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
8114a954:	e0800217 	ldw	r2,8(fp)
8114a958:	d8800115 	stw	r2,4(sp)
8114a95c:	e0bfff17 	ldw	r2,-4(fp)
8114a960:	d8800015 	stw	r2,0(sp)
8114a964:	e1fffe17 	ldw	r7,-8(fp)
8114a968:	000d883a 	mov	r6,zero
8114a96c:	e17ffd17 	ldw	r5,-12(fp)
8114a970:	e13ffc17 	ldw	r4,-16(fp)
8114a974:	1149ff40 	call	81149ff4 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8114a978:	e037883a 	mov	sp,fp
8114a97c:	dfc00117 	ldw	ra,4(sp)
8114a980:	df000017 	ldw	fp,0(sp)
8114a984:	dec00204 	addi	sp,sp,8
8114a988:	f800283a 	ret

8114a98c <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
8114a98c:	defff804 	addi	sp,sp,-32
8114a990:	de00012e 	bgeu	sp,et,8114a998 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
8114a994:	003b68fa 	trap	3
8114a998:	dfc00715 	stw	ra,28(sp)
8114a99c:	df000615 	stw	fp,24(sp)
8114a9a0:	df000604 	addi	fp,sp,24
8114a9a4:	e13ffc15 	stw	r4,-16(fp)
8114a9a8:	e17ffd15 	stw	r5,-12(fp)
8114a9ac:	e1bffe15 	stw	r6,-8(fp)
8114a9b0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
8114a9b4:	e0800217 	ldw	r2,8(fp)
8114a9b8:	d8800115 	stw	r2,4(sp)
8114a9bc:	e0bfff17 	ldw	r2,-4(fp)
8114a9c0:	d8800015 	stw	r2,0(sp)
8114a9c4:	000f883a 	mov	r7,zero
8114a9c8:	e1bffe17 	ldw	r6,-8(fp)
8114a9cc:	e17ffd17 	ldw	r5,-12(fp)
8114a9d0:	e13ffc17 	ldw	r4,-16(fp)
8114a9d4:	1149ff40 	call	81149ff4 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
8114a9d8:	e037883a 	mov	sp,fp
8114a9dc:	dfc00117 	ldw	ra,4(sp)
8114a9e0:	df000017 	ldw	fp,0(sp)
8114a9e4:	dec00204 	addi	sp,sp,8
8114a9e8:	f800283a 	ret

8114a9ec <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114a9ec:	defff804 	addi	sp,sp,-32
8114a9f0:	de00012e 	bgeu	sp,et,8114a9f8 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
8114a9f4:	003b68fa 	trap	3
8114a9f8:	dfc00715 	stw	ra,28(sp)
8114a9fc:	df000615 	stw	fp,24(sp)
8114aa00:	df000604 	addi	fp,sp,24
8114aa04:	e13ffc15 	stw	r4,-16(fp)
8114aa08:	e17ffd15 	stw	r5,-12(fp)
8114aa0c:	e1bffe15 	stw	r6,-8(fp)
8114aa10:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
8114aa14:	e0800317 	ldw	r2,12(fp)
8114aa18:	d8800115 	stw	r2,4(sp)
8114aa1c:	e0800217 	ldw	r2,8(fp)
8114aa20:	d8800015 	stw	r2,0(sp)
8114aa24:	e1ffff17 	ldw	r7,-4(fp)
8114aa28:	e1bffe17 	ldw	r6,-8(fp)
8114aa2c:	e17ffd17 	ldw	r5,-12(fp)
8114aa30:	e13ffc17 	ldw	r4,-16(fp)
8114aa34:	1149ff40 	call	81149ff4 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8114aa38:	e037883a 	mov	sp,fp
8114aa3c:	dfc00117 	ldw	ra,4(sp)
8114aa40:	df000017 	ldw	fp,0(sp)
8114aa44:	dec00204 	addi	sp,sp,8
8114aa48:	f800283a 	ret

8114aa4c <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
8114aa4c:	defff004 	addi	sp,sp,-64
8114aa50:	de00012e 	bgeu	sp,et,8114aa58 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
8114aa54:	003b68fa 	trap	3
8114aa58:	dfc00f15 	stw	ra,60(sp)
8114aa5c:	df000e15 	stw	fp,56(sp)
8114aa60:	df000e04 	addi	fp,sp,56
8114aa64:	e13ff915 	stw	r4,-28(fp)
8114aa68:	e17ffa15 	stw	r5,-24(fp)
8114aa6c:	e1bffb15 	stw	r6,-20(fp)
8114aa70:	e1fffc15 	stw	r7,-16(fp)
8114aa74:	e1000317 	ldw	r4,12(fp)
8114aa78:	e0c00417 	ldw	r3,16(fp)
8114aa7c:	e0800517 	ldw	r2,20(fp)
8114aa80:	e13ffd0d 	sth	r4,-12(fp)
8114aa84:	e0fffe05 	stb	r3,-8(fp)
8114aa88:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8114aa8c:	e0bffd0b 	ldhu	r2,-12(fp)
8114aa90:	e0fffe03 	ldbu	r3,-8(fp)
8114aa94:	e13fff0b 	ldhu	r4,-4(fp)
8114aa98:	d9000615 	stw	r4,24(sp)
8114aa9c:	d8000515 	stw	zero,20(sp)
8114aaa0:	d8c00415 	stw	r3,16(sp)
8114aaa4:	d8000315 	stw	zero,12(sp)
8114aaa8:	d8800215 	stw	r2,8(sp)
8114aaac:	e0800217 	ldw	r2,8(fp)
8114aab0:	d8800115 	stw	r2,4(sp)
8114aab4:	e0bffc17 	ldw	r2,-16(fp)
8114aab8:	d8800015 	stw	r2,0(sp)
8114aabc:	e1fffb17 	ldw	r7,-20(fp)
8114aac0:	000d883a 	mov	r6,zero
8114aac4:	e17ffa17 	ldw	r5,-24(fp)
8114aac8:	e13ff917 	ldw	r4,-28(fp)
8114aacc:	114a0880 	call	8114a088 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
8114aad0:	e037883a 	mov	sp,fp
8114aad4:	dfc00117 	ldw	ra,4(sp)
8114aad8:	df000017 	ldw	fp,0(sp)
8114aadc:	dec00204 	addi	sp,sp,8
8114aae0:	f800283a 	ret

8114aae4 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8114aae4:	defff004 	addi	sp,sp,-64
8114aae8:	de00012e 	bgeu	sp,et,8114aaf0 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
8114aaec:	003b68fa 	trap	3
8114aaf0:	dfc00f15 	stw	ra,60(sp)
8114aaf4:	df000e15 	stw	fp,56(sp)
8114aaf8:	df000e04 	addi	fp,sp,56
8114aafc:	e13ff915 	stw	r4,-28(fp)
8114ab00:	e17ffa15 	stw	r5,-24(fp)
8114ab04:	e1bffb15 	stw	r6,-20(fp)
8114ab08:	e1fffc15 	stw	r7,-16(fp)
8114ab0c:	e1000317 	ldw	r4,12(fp)
8114ab10:	e0c00417 	ldw	r3,16(fp)
8114ab14:	e0800517 	ldw	r2,20(fp)
8114ab18:	e13ffd0d 	sth	r4,-12(fp)
8114ab1c:	e0fffe05 	stb	r3,-8(fp)
8114ab20:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
8114ab24:	e0bffd0b 	ldhu	r2,-12(fp)
8114ab28:	e0fffe03 	ldbu	r3,-8(fp)
8114ab2c:	e13fff0b 	ldhu	r4,-4(fp)
8114ab30:	d8000615 	stw	zero,24(sp)
8114ab34:	d9000515 	stw	r4,20(sp)
8114ab38:	d8000415 	stw	zero,16(sp)
8114ab3c:	d8c00315 	stw	r3,12(sp)
8114ab40:	d8800215 	stw	r2,8(sp)
8114ab44:	e0800217 	ldw	r2,8(fp)
8114ab48:	d8800115 	stw	r2,4(sp)
8114ab4c:	e0bffc17 	ldw	r2,-16(fp)
8114ab50:	d8800015 	stw	r2,0(sp)
8114ab54:	000f883a 	mov	r7,zero
8114ab58:	e1bffb17 	ldw	r6,-20(fp)
8114ab5c:	e17ffa17 	ldw	r5,-24(fp)
8114ab60:	e13ff917 	ldw	r4,-28(fp)
8114ab64:	114a0880 	call	8114a088 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
8114ab68:	e037883a 	mov	sp,fp
8114ab6c:	dfc00117 	ldw	ra,4(sp)
8114ab70:	df000017 	ldw	fp,0(sp)
8114ab74:	dec00204 	addi	sp,sp,8
8114ab78:	f800283a 	ret

8114ab7c <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
8114ab7c:	deffee04 	addi	sp,sp,-72
8114ab80:	de00012e 	bgeu	sp,et,8114ab88 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
8114ab84:	003b68fa 	trap	3
8114ab88:	dfc01115 	stw	ra,68(sp)
8114ab8c:	df001015 	stw	fp,64(sp)
8114ab90:	df001004 	addi	fp,sp,64
8114ab94:	e13ff715 	stw	r4,-36(fp)
8114ab98:	e17ff815 	stw	r5,-32(fp)
8114ab9c:	e1bff915 	stw	r6,-28(fp)
8114aba0:	e1fffa15 	stw	r7,-24(fp)
8114aba4:	e1800417 	ldw	r6,16(fp)
8114aba8:	e1400517 	ldw	r5,20(fp)
8114abac:	e1000617 	ldw	r4,24(fp)
8114abb0:	e0c00717 	ldw	r3,28(fp)
8114abb4:	e0800817 	ldw	r2,32(fp)
8114abb8:	e1bffb0d 	sth	r6,-20(fp)
8114abbc:	e17ffc05 	stb	r5,-16(fp)
8114abc0:	e13ffd05 	stb	r4,-12(fp)
8114abc4:	e0fffe0d 	sth	r3,-8(fp)
8114abc8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8114abcc:	e0bffb0b 	ldhu	r2,-20(fp)
8114abd0:	e0fffc03 	ldbu	r3,-16(fp)
8114abd4:	e13ffd03 	ldbu	r4,-12(fp)
8114abd8:	e17ffe0b 	ldhu	r5,-8(fp)
8114abdc:	e1bfff0b 	ldhu	r6,-4(fp)
8114abe0:	d9800615 	stw	r6,24(sp)
8114abe4:	d9400515 	stw	r5,20(sp)
8114abe8:	d9000415 	stw	r4,16(sp)
8114abec:	d8c00315 	stw	r3,12(sp)
8114abf0:	d8800215 	stw	r2,8(sp)
8114abf4:	e0800317 	ldw	r2,12(fp)
8114abf8:	d8800115 	stw	r2,4(sp)
8114abfc:	e0800217 	ldw	r2,8(fp)
8114ac00:	d8800015 	stw	r2,0(sp)
8114ac04:	e1fffa17 	ldw	r7,-24(fp)
8114ac08:	e1bff917 	ldw	r6,-28(fp)
8114ac0c:	e17ff817 	ldw	r5,-32(fp)
8114ac10:	e13ff717 	ldw	r4,-36(fp)
8114ac14:	114a0880 	call	8114a088 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
8114ac18:	e037883a 	mov	sp,fp
8114ac1c:	dfc00117 	ldw	ra,4(sp)
8114ac20:	df000017 	ldw	fp,0(sp)
8114ac24:	dec00204 	addi	sp,sp,8
8114ac28:	f800283a 	ret

8114ac2c <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114ac2c:	defffb04 	addi	sp,sp,-20
8114ac30:	de00012e 	bgeu	sp,et,8114ac38 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
8114ac34:	003b68fa 	trap	3
8114ac38:	df000415 	stw	fp,16(sp)
8114ac3c:	df000404 	addi	fp,sp,16
8114ac40:	e13ffc15 	stw	r4,-16(fp)
8114ac44:	e17ffd15 	stw	r5,-12(fp)
8114ac48:	e1bffe15 	stw	r6,-8(fp)
8114ac4c:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
8114ac50:	e0bffc17 	ldw	r2,-16(fp)
8114ac54:	10c01217 	ldw	r3,72(r2)
8114ac58:	e0800117 	ldw	r2,4(fp)
8114ac5c:	18800436 	bltu	r3,r2,8114ac70 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
8114ac60:	e0bffc17 	ldw	r2,-16(fp)
8114ac64:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
8114ac68:	10803fcc 	andi	r2,r2,255
8114ac6c:	10000226 	beq	r2,zero,8114ac78 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8114ac70:	00bffa84 	movi	r2,-22
8114ac74:	00001406 	br	8114acc8 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
8114ac78:	e0bffd17 	ldw	r2,-12(fp)
8114ac7c:	e0fffe17 	ldw	r3,-8(fp)
8114ac80:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
8114ac84:	e0bffd17 	ldw	r2,-12(fp)
8114ac88:	e0ffff17 	ldw	r3,-4(fp)
8114ac8c:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114ac90:	e0bffd17 	ldw	r2,-12(fp)
8114ac94:	e0c00117 	ldw	r3,4(fp)
8114ac98:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
8114ac9c:	e0fffd17 	ldw	r3,-12(fp)
8114aca0:	e0bffd17 	ldw	r2,-12(fp)
8114aca4:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114aca8:	e0c00217 	ldw	r3,8(fp)
8114acac:	00900034 	movhi	r2,16384
8114acb0:	10bfffc4 	addi	r2,r2,-1
8114acb4:	1884703a 	and	r2,r3,r2
8114acb8:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
8114acbc:	e0bffd17 	ldw	r2,-12(fp)
8114acc0:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
8114acc4:	0005883a 	mov	r2,zero
}
8114acc8:	e037883a 	mov	sp,fp
8114accc:	df000017 	ldw	fp,0(sp)
8114acd0:	dec00104 	addi	sp,sp,4
8114acd4:	f800283a 	ret

8114acd8 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8114acd8:	defff404 	addi	sp,sp,-48
8114acdc:	de00012e 	bgeu	sp,et,8114ace4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
8114ace0:	003b68fa 	trap	3
8114ace4:	df000b15 	stw	fp,44(sp)
8114ace8:	df000b04 	addi	fp,sp,44
8114acec:	e13ff715 	stw	r4,-36(fp)
8114acf0:	e17ff815 	stw	r5,-32(fp)
8114acf4:	e1bff915 	stw	r6,-28(fp)
8114acf8:	e1fffa15 	stw	r7,-24(fp)
8114acfc:	e1800517 	ldw	r6,20(fp)
8114ad00:	e1400617 	ldw	r5,24(fp)
8114ad04:	e1000717 	ldw	r4,28(fp)
8114ad08:	e0c00817 	ldw	r3,32(fp)
8114ad0c:	e0800917 	ldw	r2,36(fp)
8114ad10:	e1bffb0d 	sth	r6,-20(fp)
8114ad14:	e17ffc05 	stb	r5,-16(fp)
8114ad18:	e13ffd05 	stb	r4,-12(fp)
8114ad1c:	e0fffe0d 	sth	r3,-8(fp)
8114ad20:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8114ad24:	e0bff717 	ldw	r2,-36(fp)
8114ad28:	10c01217 	ldw	r3,72(r2)
8114ad2c:	e0800317 	ldw	r2,12(fp)
8114ad30:	18801936 	bltu	r3,r2,8114ad98 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8114ad34:	e13ff717 	ldw	r4,-36(fp)
8114ad38:	20801317 	ldw	r2,76(r4)
8114ad3c:	20c01417 	ldw	r3,80(r4)
8114ad40:	e13ffe0b 	ldhu	r4,-8(fp)
8114ad44:	213fffcc 	andi	r4,r4,65535
8114ad48:	2015883a 	mov	r10,r4
8114ad4c:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8114ad50:	1ac01136 	bltu	r3,r11,8114ad98 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8114ad54:	58c0011e 	bne	r11,r3,8114ad5c <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
8114ad58:	12800f36 	bltu	r2,r10,8114ad98 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114ad5c:	e13ff717 	ldw	r4,-36(fp)
8114ad60:	20801317 	ldw	r2,76(r4)
8114ad64:	20c01417 	ldw	r3,80(r4)
8114ad68:	e13fff0b 	ldhu	r4,-4(fp)
8114ad6c:	213fffcc 	andi	r4,r4,65535
8114ad70:	2011883a 	mov	r8,r4
8114ad74:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
8114ad78:	1a400736 	bltu	r3,r9,8114ad98 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8114ad7c:	48c0011e 	bne	r9,r3,8114ad84 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
8114ad80:	12000536 	bltu	r2,r8,8114ad98 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8114ad84:	e0bff717 	ldw	r2,-36(fp)
8114ad88:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114ad8c:	10803fcc 	andi	r2,r2,255
8114ad90:	10800060 	cmpeqi	r2,r2,1
8114ad94:	1000021e 	bne	r2,zero,8114ada0 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
8114ad98:	00bffa84 	movi	r2,-22
8114ad9c:	00003106 	br	8114ae64 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
8114ada0:	e0bff817 	ldw	r2,-32(fp)
8114ada4:	e0fff917 	ldw	r3,-28(fp)
8114ada8:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
8114adac:	e0bff817 	ldw	r2,-32(fp)
8114adb0:	e0fffa17 	ldw	r3,-24(fp)
8114adb4:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
8114adb8:	e0bff817 	ldw	r2,-32(fp)
8114adbc:	e0c00117 	ldw	r3,4(fp)
8114adc0:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
8114adc4:	e0bff817 	ldw	r2,-32(fp)
8114adc8:	e0c00217 	ldw	r3,8(fp)
8114adcc:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114add0:	e0bff817 	ldw	r2,-32(fp)
8114add4:	e0c00317 	ldw	r3,12(fp)
8114add8:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8114addc:	e0bff817 	ldw	r2,-32(fp)
8114ade0:	e0fffb0b 	ldhu	r3,-20(fp)
8114ade4:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
8114ade8:	e0bff817 	ldw	r2,-32(fp)
8114adec:	e0fffc03 	ldbu	r3,-16(fp)
8114adf0:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
8114adf4:	e0bff817 	ldw	r2,-32(fp)
8114adf8:	e0fffd03 	ldbu	r3,-12(fp)
8114adfc:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
8114ae00:	e0bff817 	ldw	r2,-32(fp)
8114ae04:	e0fffe0b 	ldhu	r3,-8(fp)
8114ae08:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
8114ae0c:	e0bff817 	ldw	r2,-32(fp)
8114ae10:	e0ffff0b 	ldhu	r3,-4(fp)
8114ae14:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
8114ae18:	e0bff817 	ldw	r2,-32(fp)
8114ae1c:	1019883a 	mov	r12,r2
8114ae20:	001b883a 	mov	r13,zero
8114ae24:	e33ff515 	stw	r12,-44(fp)
8114ae28:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
8114ae2c:	e0fff517 	ldw	r3,-44(fp)
8114ae30:	e0bff817 	ldw	r2,-32(fp)
8114ae34:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
8114ae38:	e0fff617 	ldw	r3,-40(fp)
8114ae3c:	e0bff817 	ldw	r2,-32(fp)
8114ae40:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114ae44:	e0c00417 	ldw	r3,16(fp)
8114ae48:	00900034 	movhi	r2,16384
8114ae4c:	10bfffc4 	addi	r2,r2,-1
8114ae50:	1884703a 	and	r2,r3,r2
8114ae54:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
8114ae58:	e0bff817 	ldw	r2,-32(fp)
8114ae5c:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
8114ae60:	0005883a 	mov	r2,zero
}
8114ae64:	e037883a 	mov	sp,fp
8114ae68:	df000017 	ldw	fp,0(sp)
8114ae6c:	dec00104 	addi	sp,sp,4
8114ae70:	f800283a 	ret

8114ae74 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
8114ae74:	defff804 	addi	sp,sp,-32
8114ae78:	de00012e 	bgeu	sp,et,8114ae80 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
8114ae7c:	003b68fa 	trap	3
8114ae80:	dfc00715 	stw	ra,28(sp)
8114ae84:	df000615 	stw	fp,24(sp)
8114ae88:	df000604 	addi	fp,sp,24
8114ae8c:	e13ffc15 	stw	r4,-16(fp)
8114ae90:	e17ffd15 	stw	r5,-12(fp)
8114ae94:	e1bffe15 	stw	r6,-8(fp)
8114ae98:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114ae9c:	e0800317 	ldw	r2,12(fp)
8114aea0:	d8800115 	stw	r2,4(sp)
8114aea4:	e0800217 	ldw	r2,8(fp)
8114aea8:	d8800015 	stw	r2,0(sp)
8114aeac:	e1ffff17 	ldw	r7,-4(fp)
8114aeb0:	e1bffe17 	ldw	r6,-8(fp)
8114aeb4:	e17ffd17 	ldw	r5,-12(fp)
8114aeb8:	e13ffc17 	ldw	r4,-16(fp)
8114aebc:	114ac2c0 	call	8114ac2c <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
8114aec0:	e037883a 	mov	sp,fp
8114aec4:	dfc00117 	ldw	ra,4(sp)
8114aec8:	df000017 	ldw	fp,0(sp)
8114aecc:	dec00204 	addi	sp,sp,8
8114aed0:	f800283a 	ret

8114aed4 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114aed4:	defff804 	addi	sp,sp,-32
8114aed8:	de00012e 	bgeu	sp,et,8114aee0 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
8114aedc:	003b68fa 	trap	3
8114aee0:	dfc00715 	stw	ra,28(sp)
8114aee4:	df000615 	stw	fp,24(sp)
8114aee8:	df000604 	addi	fp,sp,24
8114aeec:	e13ffc15 	stw	r4,-16(fp)
8114aef0:	e17ffd15 	stw	r5,-12(fp)
8114aef4:	e1bffe15 	stw	r6,-8(fp)
8114aef8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114aefc:	e0800217 	ldw	r2,8(fp)
8114af00:	d8800115 	stw	r2,4(sp)
8114af04:	e0bfff17 	ldw	r2,-4(fp)
8114af08:	d8800015 	stw	r2,0(sp)
8114af0c:	e1fffe17 	ldw	r7,-8(fp)
8114af10:	000d883a 	mov	r6,zero
8114af14:	e17ffd17 	ldw	r5,-12(fp)
8114af18:	e13ffc17 	ldw	r4,-16(fp)
8114af1c:	114ac2c0 	call	8114ac2c <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
8114af20:	e037883a 	mov	sp,fp
8114af24:	dfc00117 	ldw	ra,4(sp)
8114af28:	df000017 	ldw	fp,0(sp)
8114af2c:	dec00204 	addi	sp,sp,8
8114af30:	f800283a 	ret

8114af34 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114af34:	defff804 	addi	sp,sp,-32
8114af38:	de00012e 	bgeu	sp,et,8114af40 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
8114af3c:	003b68fa 	trap	3
8114af40:	dfc00715 	stw	ra,28(sp)
8114af44:	df000615 	stw	fp,24(sp)
8114af48:	df000604 	addi	fp,sp,24
8114af4c:	e13ffc15 	stw	r4,-16(fp)
8114af50:	e17ffd15 	stw	r5,-12(fp)
8114af54:	e1bffe15 	stw	r6,-8(fp)
8114af58:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114af5c:	e0800217 	ldw	r2,8(fp)
8114af60:	d8800115 	stw	r2,4(sp)
8114af64:	e0bfff17 	ldw	r2,-4(fp)
8114af68:	d8800015 	stw	r2,0(sp)
8114af6c:	000f883a 	mov	r7,zero
8114af70:	e1bffe17 	ldw	r6,-8(fp)
8114af74:	e17ffd17 	ldw	r5,-12(fp)
8114af78:	e13ffc17 	ldw	r4,-16(fp)
8114af7c:	114ac2c0 	call	8114ac2c <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
8114af80:	e037883a 	mov	sp,fp
8114af84:	dfc00117 	ldw	ra,4(sp)
8114af88:	df000017 	ldw	fp,0(sp)
8114af8c:	dec00204 	addi	sp,sp,8
8114af90:	f800283a 	ret

8114af94 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
8114af94:	deffee04 	addi	sp,sp,-72
8114af98:	de00012e 	bgeu	sp,et,8114afa0 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
8114af9c:	003b68fa 	trap	3
8114afa0:	dfc01115 	stw	ra,68(sp)
8114afa4:	df001015 	stw	fp,64(sp)
8114afa8:	df001004 	addi	fp,sp,64
8114afac:	e13ff915 	stw	r4,-28(fp)
8114afb0:	e17ffa15 	stw	r5,-24(fp)
8114afb4:	e1bffb15 	stw	r6,-20(fp)
8114afb8:	e1fffc15 	stw	r7,-16(fp)
8114afbc:	e1000417 	ldw	r4,16(fp)
8114afc0:	e0c00517 	ldw	r3,20(fp)
8114afc4:	e0800617 	ldw	r2,24(fp)
8114afc8:	e13ffd0d 	sth	r4,-12(fp)
8114afcc:	e0fffe05 	stb	r3,-8(fp)
8114afd0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
8114afd4:	e0bffd0b 	ldhu	r2,-12(fp)
8114afd8:	e0fffe03 	ldbu	r3,-8(fp)
8114afdc:	e13fff0b 	ldhu	r4,-4(fp)
8114afe0:	d9000815 	stw	r4,32(sp)
8114afe4:	d8000715 	stw	zero,28(sp)
8114afe8:	d8c00615 	stw	r3,24(sp)
8114afec:	d8000515 	stw	zero,20(sp)
8114aff0:	d8800415 	stw	r2,16(sp)
8114aff4:	e0800317 	ldw	r2,12(fp)
8114aff8:	d8800315 	stw	r2,12(sp)
8114affc:	e0800217 	ldw	r2,8(fp)
8114b000:	d8800215 	stw	r2,8(sp)
8114b004:	e0bffc17 	ldw	r2,-16(fp)
8114b008:	d8800115 	stw	r2,4(sp)
8114b00c:	e0bffb17 	ldw	r2,-20(fp)
8114b010:	d8800015 	stw	r2,0(sp)
8114b014:	000f883a 	mov	r7,zero
8114b018:	000d883a 	mov	r6,zero
8114b01c:	e17ffa17 	ldw	r5,-24(fp)
8114b020:	e13ff917 	ldw	r4,-28(fp)
8114b024:	114acd80 	call	8114acd8 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
8114b028:	e037883a 	mov	sp,fp
8114b02c:	dfc00117 	ldw	ra,4(sp)
8114b030:	df000017 	ldw	fp,0(sp)
8114b034:	dec00204 	addi	sp,sp,8
8114b038:	f800283a 	ret

8114b03c <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8114b03c:	deffee04 	addi	sp,sp,-72
8114b040:	de00012e 	bgeu	sp,et,8114b048 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
8114b044:	003b68fa 	trap	3
8114b048:	dfc01115 	stw	ra,68(sp)
8114b04c:	df001015 	stw	fp,64(sp)
8114b050:	df001004 	addi	fp,sp,64
8114b054:	e13ff915 	stw	r4,-28(fp)
8114b058:	e17ffa15 	stw	r5,-24(fp)
8114b05c:	e1bffb15 	stw	r6,-20(fp)
8114b060:	e1fffc15 	stw	r7,-16(fp)
8114b064:	e1000417 	ldw	r4,16(fp)
8114b068:	e0c00517 	ldw	r3,20(fp)
8114b06c:	e0800617 	ldw	r2,24(fp)
8114b070:	e13ffd0d 	sth	r4,-12(fp)
8114b074:	e0fffe05 	stb	r3,-8(fp)
8114b078:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8114b07c:	e0bffd0b 	ldhu	r2,-12(fp)
8114b080:	e0fffe03 	ldbu	r3,-8(fp)
8114b084:	e13fff0b 	ldhu	r4,-4(fp)
8114b088:	d8000815 	stw	zero,32(sp)
8114b08c:	d9000715 	stw	r4,28(sp)
8114b090:	d8000615 	stw	zero,24(sp)
8114b094:	d8c00515 	stw	r3,20(sp)
8114b098:	d8800415 	stw	r2,16(sp)
8114b09c:	e0800317 	ldw	r2,12(fp)
8114b0a0:	d8800315 	stw	r2,12(sp)
8114b0a4:	e0800217 	ldw	r2,8(fp)
8114b0a8:	d8800215 	stw	r2,8(sp)
8114b0ac:	d8000115 	stw	zero,4(sp)
8114b0b0:	d8000015 	stw	zero,0(sp)
8114b0b4:	e1fffc17 	ldw	r7,-16(fp)
8114b0b8:	e1bffb17 	ldw	r6,-20(fp)
8114b0bc:	e17ffa17 	ldw	r5,-24(fp)
8114b0c0:	e13ff917 	ldw	r4,-28(fp)
8114b0c4:	114acd80 	call	8114acd8 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
8114b0c8:	e037883a 	mov	sp,fp
8114b0cc:	dfc00117 	ldw	ra,4(sp)
8114b0d0:	df000017 	ldw	fp,0(sp)
8114b0d4:	dec00204 	addi	sp,sp,8
8114b0d8:	f800283a 	ret

8114b0dc <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8114b0dc:	deffec04 	addi	sp,sp,-80
8114b0e0:	de00012e 	bgeu	sp,et,8114b0e8 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
8114b0e4:	003b68fa 	trap	3
8114b0e8:	dfc01315 	stw	ra,76(sp)
8114b0ec:	df001215 	stw	fp,72(sp)
8114b0f0:	df001204 	addi	fp,sp,72
8114b0f4:	e13ff715 	stw	r4,-36(fp)
8114b0f8:	e17ff815 	stw	r5,-32(fp)
8114b0fc:	e1bff915 	stw	r6,-28(fp)
8114b100:	e1fffa15 	stw	r7,-24(fp)
8114b104:	e1800617 	ldw	r6,24(fp)
8114b108:	e1400717 	ldw	r5,28(fp)
8114b10c:	e1000817 	ldw	r4,32(fp)
8114b110:	e0c00917 	ldw	r3,36(fp)
8114b114:	e0800a17 	ldw	r2,40(fp)
8114b118:	e1bffb0d 	sth	r6,-20(fp)
8114b11c:	e17ffc05 	stb	r5,-16(fp)
8114b120:	e13ffd05 	stb	r4,-12(fp)
8114b124:	e0fffe0d 	sth	r3,-8(fp)
8114b128:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8114b12c:	e0bffb0b 	ldhu	r2,-20(fp)
8114b130:	e0fffc03 	ldbu	r3,-16(fp)
8114b134:	e13ffd03 	ldbu	r4,-12(fp)
8114b138:	e17ffe0b 	ldhu	r5,-8(fp)
8114b13c:	e1bfff0b 	ldhu	r6,-4(fp)
8114b140:	d9800815 	stw	r6,32(sp)
8114b144:	d9400715 	stw	r5,28(sp)
8114b148:	d9000615 	stw	r4,24(sp)
8114b14c:	d8c00515 	stw	r3,20(sp)
8114b150:	d8800415 	stw	r2,16(sp)
8114b154:	e0800517 	ldw	r2,20(fp)
8114b158:	d8800315 	stw	r2,12(sp)
8114b15c:	e0800417 	ldw	r2,16(fp)
8114b160:	d8800215 	stw	r2,8(sp)
8114b164:	e0800317 	ldw	r2,12(fp)
8114b168:	d8800115 	stw	r2,4(sp)
8114b16c:	e0800217 	ldw	r2,8(fp)
8114b170:	d8800015 	stw	r2,0(sp)
8114b174:	e1fffa17 	ldw	r7,-24(fp)
8114b178:	e1bff917 	ldw	r6,-28(fp)
8114b17c:	e17ff817 	ldw	r5,-32(fp)
8114b180:	e13ff717 	ldw	r4,-36(fp)
8114b184:	114acd80 	call	8114acd8 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
8114b188:	e037883a 	mov	sp,fp
8114b18c:	dfc00117 	ldw	ra,4(sp)
8114b190:	df000017 	ldw	fp,0(sp)
8114b194:	dec00204 	addi	sp,sp,8
8114b198:	f800283a 	ret

8114b19c <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
8114b19c:	defffc04 	addi	sp,sp,-16
8114b1a0:	de00012e 	bgeu	sp,et,8114b1a8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
8114b1a4:	003b68fa 	trap	3
8114b1a8:	df000315 	stw	fp,12(sp)
8114b1ac:	df000304 	addi	fp,sp,12
8114b1b0:	e13ffe15 	stw	r4,-8(fp)
8114b1b4:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
8114b1b8:	e0bfff17 	ldw	r2,-4(fp)
8114b1bc:	1000021e 	bne	r2,zero,8114b1c8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8114b1c0:	00bffa84 	movi	r2,-22
8114b1c4:	00002f06 	br	8114b284 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
8114b1c8:	e0bfff17 	ldw	r2,-4(fp)
8114b1cc:	10c00317 	ldw	r3,12(r2)
8114b1d0:	e0bfff17 	ldw	r2,-4(fp)
8114b1d4:	18800226 	beq	r3,r2,8114b1e0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8114b1d8:	00bffa84 	movi	r2,-22
8114b1dc:	00002906 	br	8114b284 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
8114b1e0:	e0bffe17 	ldw	r2,-8(fp)
8114b1e4:	10800017 	ldw	r2,0(r2)
8114b1e8:	1000051e 	bne	r2,zero,8114b200 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
8114b1ec:	e0bffe17 	ldw	r2,-8(fp)
8114b1f0:	e0ffff17 	ldw	r3,-4(fp)
8114b1f4:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
8114b1f8:	0005883a 	mov	r2,zero
8114b1fc:	00002106 	br	8114b284 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
8114b200:	e0bffe17 	ldw	r2,-8(fp)
8114b204:	10c00017 	ldw	r3,0(r2)
8114b208:	e0bfff17 	ldw	r2,-4(fp)
8114b20c:	1880021e 	bne	r3,r2,8114b218 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8114b210:	00bffa84 	movi	r2,-22
8114b214:	00001b06 	br	8114b284 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8114b218:	e0bffe17 	ldw	r2,-8(fp)
8114b21c:	10800017 	ldw	r2,0(r2)
8114b220:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8114b224:	00000906 	br	8114b24c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
8114b228:	e0bffd17 	ldw	r2,-12(fp)
8114b22c:	10c00317 	ldw	r3,12(r2)
8114b230:	e0bfff17 	ldw	r2,-4(fp)
8114b234:	1880021e 	bne	r3,r2,8114b240 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8114b238:	00bffa84 	movi	r2,-22
8114b23c:	00001106 	br	8114b284 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8114b240:	e0bffd17 	ldw	r2,-12(fp)
8114b244:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
8114b248:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8114b24c:	e0bffd17 	ldw	r2,-12(fp)
8114b250:	10800317 	ldw	r2,12(r2)
8114b254:	e0fffe17 	ldw	r3,-8(fp)
8114b258:	18c00017 	ldw	r3,0(r3)
8114b25c:	10fff21e 	bne	r2,r3,8114b228 <__reset+0xfb12b228>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
8114b260:	e0ffff17 	ldw	r3,-4(fp)
8114b264:	e0bffd17 	ldw	r2,-12(fp)
8114b268:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
8114b26c:	e0bffe17 	ldw	r2,-8(fp)
8114b270:	10800017 	ldw	r2,0(r2)
8114b274:	1007883a 	mov	r3,r2
8114b278:	e0bfff17 	ldw	r2,-4(fp)
8114b27c:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
8114b280:	0005883a 	mov	r2,zero
}
8114b284:	e037883a 	mov	sp,fp
8114b288:	df000017 	ldw	fp,0(sp)
8114b28c:	dec00104 	addi	sp,sp,4
8114b290:	f800283a 	ret

8114b294 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
8114b294:	defff804 	addi	sp,sp,-32
8114b298:	de00012e 	bgeu	sp,et,8114b2a0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
8114b29c:	003b68fa 	trap	3
8114b2a0:	df000715 	stw	fp,28(sp)
8114b2a4:	df000704 	addi	fp,sp,28
8114b2a8:	e13ffe15 	stw	r4,-8(fp)
8114b2ac:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
8114b2b0:	e13fff17 	ldw	r4,-4(fp)
8114b2b4:	2000021e 	bne	r4,zero,8114b2c0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8114b2b8:	00bffa84 	movi	r2,-22
8114b2bc:	00005906 	br	8114b424 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
8114b2c0:	e13fff17 	ldw	r4,-4(fp)
8114b2c4:	2015883a 	mov	r10,r4
8114b2c8:	0017883a 	mov	r11,zero
8114b2cc:	e2bffc15 	stw	r10,-16(fp)
8114b2d0:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114b2d4:	e13fff17 	ldw	r4,-4(fp)
8114b2d8:	21400317 	ldw	r5,12(r4)
8114b2dc:	e13ffc17 	ldw	r4,-16(fp)
8114b2e0:	29000626 	beq	r5,r4,8114b2fc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
8114b2e4:	e13fff17 	ldw	r4,-4(fp)
8114b2e8:	21400b17 	ldw	r5,44(r4)
8114b2ec:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114b2f0:	29000226 	beq	r5,r4,8114b2fc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8114b2f4:	00bffa84 	movi	r2,-22
8114b2f8:	00004a06 	br	8114b424 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
8114b2fc:	e13ffe17 	ldw	r4,-8(fp)
8114b300:	21000017 	ldw	r4,0(r4)
8114b304:	2000051e 	bne	r4,zero,8114b31c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
8114b308:	e0bffe17 	ldw	r2,-8(fp)
8114b30c:	e0ffff17 	ldw	r3,-4(fp)
8114b310:	10c00015 	stw	r3,0(r2)
		return 0;
8114b314:	0005883a 	mov	r2,zero
8114b318:	00004206 	br	8114b424 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
8114b31c:	e13ffe17 	ldw	r4,-8(fp)
8114b320:	21400017 	ldw	r5,0(r4)
8114b324:	e13fff17 	ldw	r4,-4(fp)
8114b328:	2900021e 	bne	r5,r4,8114b334 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8114b32c:	00bffa84 	movi	r2,-22
8114b330:	00003c06 	br	8114b424 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8114b334:	e13ffe17 	ldw	r4,-8(fp)
8114b338:	21000017 	ldw	r4,0(r4)
8114b33c:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
8114b340:	e13ffe17 	ldw	r4,-8(fp)
8114b344:	21000017 	ldw	r4,0(r4)
8114b348:	2011883a 	mov	r8,r4
8114b34c:	0013883a 	mov	r9,zero
8114b350:	e23ffa15 	stw	r8,-24(fp)
8114b354:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114b358:	00001806 	br	8114b3bc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
8114b35c:	e13fff17 	ldw	r4,-4(fp)
8114b360:	200d883a 	mov	r6,r4
8114b364:	000f883a 	mov	r7,zero
8114b368:	e1bffc15 	stw	r6,-16(fp)
8114b36c:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
8114b370:	e13ff917 	ldw	r4,-28(fp)
8114b374:	21400317 	ldw	r5,12(r4)
8114b378:	e13ffc17 	ldw	r4,-16(fp)
8114b37c:	2900061e 	bne	r5,r4,8114b398 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
8114b380:	e13ff917 	ldw	r4,-28(fp)
8114b384:	21400b17 	ldw	r5,44(r4)
8114b388:	e13ffd17 	ldw	r4,-12(fp)
8114b38c:	2900021e 	bne	r5,r4,8114b398 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8114b390:	00bffa84 	movi	r2,-22
8114b394:	00002306 	br	8114b424 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8114b398:	e13ff917 	ldw	r4,-28(fp)
8114b39c:	21000317 	ldw	r4,12(r4)
8114b3a0:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8114b3a4:	e13ff917 	ldw	r4,-28(fp)
8114b3a8:	21000b17 	ldw	r4,44(r4)
8114b3ac:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8114b3b0:	e13ffc17 	ldw	r4,-16(fp)
8114b3b4:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8114b3b8:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114b3bc:	e13ff917 	ldw	r4,-28(fp)
8114b3c0:	21400317 	ldw	r5,12(r4)
8114b3c4:	e13ffa17 	ldw	r4,-24(fp)
8114b3c8:	29000426 	beq	r5,r4,8114b3dc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114b3cc:	e13ff917 	ldw	r4,-28(fp)
8114b3d0:	21400b17 	ldw	r5,44(r4)
8114b3d4:	e13ffb17 	ldw	r4,-20(fp)
8114b3d8:	293fe01e 	bne	r5,r4,8114b35c <__reset+0xfb12b35c>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
8114b3dc:	e13fff17 	ldw	r4,-4(fp)
8114b3e0:	2005883a 	mov	r2,r4
8114b3e4:	0007883a 	mov	r3,zero
8114b3e8:	e0bffc15 	stw	r2,-16(fp)
8114b3ec:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
8114b3f0:	e0fffc17 	ldw	r3,-16(fp)
8114b3f4:	e0bff917 	ldw	r2,-28(fp)
8114b3f8:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
8114b3fc:	e0fffd17 	ldw	r3,-12(fp)
8114b400:	e0bff917 	ldw	r2,-28(fp)
8114b404:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
8114b408:	e0fffa17 	ldw	r3,-24(fp)
8114b40c:	e0bfff17 	ldw	r2,-4(fp)
8114b410:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
8114b414:	e0fffb17 	ldw	r3,-20(fp)
8114b418:	e0bfff17 	ldw	r2,-4(fp)
8114b41c:	10c00b15 	stw	r3,44(r2)
	return 0;
8114b420:	0005883a 	mov	r2,zero
}
8114b424:	e037883a 	mov	sp,fp
8114b428:	df000017 	ldw	fp,0(sp)
8114b42c:	dec00104 	addi	sp,sp,4
8114b430:	f800283a 	ret

8114b434 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
8114b434:	defffc04 	addi	sp,sp,-16
8114b438:	de00012e 	bgeu	sp,et,8114b440 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
8114b43c:	003b68fa 	trap	3
8114b440:	df000315 	stw	fp,12(sp)
8114b444:	df000304 	addi	fp,sp,12
8114b448:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8114b44c:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
8114b450:	e0bfff17 	ldw	r2,-4(fp)
8114b454:	1000021e 	bne	r2,zero,8114b460 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8114b458:	00bffa84 	movi	r2,-22
8114b45c:	00001906 	br	8114b4c4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114b460:	e0bfff17 	ldw	r2,-4(fp)
8114b464:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8114b468:	00000a06 	br	8114b494 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
8114b46c:	e0bffd17 	ldw	r2,-12(fp)
8114b470:	10800717 	ldw	r2,28(r2)
8114b474:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114b478:	e0bffe17 	ldw	r2,-8(fp)
8114b47c:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8114b480:	e0bffd17 	ldw	r2,-12(fp)
8114b484:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8114b488:	e0bffd17 	ldw	r2,-12(fp)
8114b48c:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
8114b490:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8114b494:	e0bffd17 	ldw	r2,-12(fp)
8114b498:	10c00317 	ldw	r3,12(r2)
8114b49c:	e0bfff17 	ldw	r2,-4(fp)
8114b4a0:	18bff21e 	bne	r3,r2,8114b46c <__reset+0xfb12b46c>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
8114b4a4:	e0bffd17 	ldw	r2,-12(fp)
8114b4a8:	10800717 	ldw	r2,28(r2)
8114b4ac:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114b4b0:	e0bffe17 	ldw	r2,-8(fp)
8114b4b4:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8114b4b8:	e0bffd17 	ldw	r2,-12(fp)
8114b4bc:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
8114b4c0:	0005883a 	mov	r2,zero
}
8114b4c4:	e037883a 	mov	sp,fp
8114b4c8:	df000017 	ldw	fp,0(sp)
8114b4cc:	dec00104 	addi	sp,sp,4
8114b4d0:	f800283a 	ret

8114b4d4 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
8114b4d4:	defff804 	addi	sp,sp,-32
8114b4d8:	de00012e 	bgeu	sp,et,8114b4e0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
8114b4dc:	003b68fa 	trap	3
8114b4e0:	df000715 	stw	fp,28(sp)
8114b4e4:	df000704 	addi	fp,sp,28
8114b4e8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8114b4ec:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
8114b4f0:	e13fff17 	ldw	r4,-4(fp)
8114b4f4:	2000021e 	bne	r4,zero,8114b500 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8114b4f8:	00bffa84 	movi	r2,-22
8114b4fc:	00002806 	br	8114b5a0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114b500:	e13fff17 	ldw	r4,-4(fp)
8114b504:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
8114b508:	e13fff17 	ldw	r4,-4(fp)
8114b50c:	2005883a 	mov	r2,r4
8114b510:	0007883a 	mov	r3,zero
8114b514:	e0bffb15 	stw	r2,-20(fp)
8114b518:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114b51c:	00001006 	br	8114b560 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
8114b520:	e0bff917 	ldw	r2,-28(fp)
8114b524:	10800f17 	ldw	r2,60(r2)
8114b528:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114b52c:	e0bffa17 	ldw	r2,-24(fp)
8114b530:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8114b534:	e0bff917 	ldw	r2,-28(fp)
8114b538:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8114b53c:	e0bff917 	ldw	r2,-28(fp)
8114b540:	10800317 	ldw	r2,12(r2)
8114b544:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8114b548:	e0bff917 	ldw	r2,-28(fp)
8114b54c:	10800b17 	ldw	r2,44(r2)
8114b550:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8114b554:	e0bffd17 	ldw	r2,-12(fp)
8114b558:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8114b55c:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114b560:	e0bff917 	ldw	r2,-28(fp)
8114b564:	10c00317 	ldw	r3,12(r2)
8114b568:	e0bffb17 	ldw	r2,-20(fp)
8114b56c:	18800426 	beq	r3,r2,8114b580 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114b570:	e0bff917 	ldw	r2,-28(fp)
8114b574:	10c00b17 	ldw	r3,44(r2)
8114b578:	e0bffc17 	ldw	r2,-16(fp)
8114b57c:	18bfe81e 	bne	r3,r2,8114b520 <__reset+0xfb12b520>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
8114b580:	e0bff917 	ldw	r2,-28(fp)
8114b584:	10800f17 	ldw	r2,60(r2)
8114b588:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114b58c:	e0bffa17 	ldw	r2,-24(fp)
8114b590:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8114b594:	e0bff917 	ldw	r2,-28(fp)
8114b598:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
8114b59c:	0005883a 	mov	r2,zero
}
8114b5a0:	e037883a 	mov	sp,fp
8114b5a4:	df000017 	ldw	fp,0(sp)
8114b5a8:	dec00104 	addi	sp,sp,4
8114b5ac:	f800283a 	ret

8114b5b0 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8114b5b0:	deffeb04 	addi	sp,sp,-84
8114b5b4:	de00012e 	bgeu	sp,et,8114b5bc <alt_msgdma_start_prefetcher_with_list_addr+0xc>
8114b5b8:	003b68fa 	trap	3
8114b5bc:	dfc01415 	stw	ra,80(sp)
8114b5c0:	df001315 	stw	fp,76(sp)
8114b5c4:	df001304 	addi	fp,sp,76
8114b5c8:	e13ffb15 	stw	r4,-20(fp)
8114b5cc:	e17ffc15 	stw	r5,-16(fp)
8114b5d0:	e1bffd15 	stw	r6,-12(fp)
8114b5d4:	3807883a 	mov	r3,r7
8114b5d8:	e0800217 	ldw	r2,8(fp)
8114b5dc:	e0fffe05 	stb	r3,-8(fp)
8114b5e0:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
8114b5e4:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
8114b5e8:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
8114b5ec:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
8114b5f0:	e0bffc17 	ldw	r2,-16(fp)
8114b5f4:	e0bff815 	stw	r2,-32(fp)
8114b5f8:	e0bffd17 	ldw	r2,-12(fp)
8114b5fc:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
8114b600:	e0bffb17 	ldw	r2,-20(fp)
8114b604:	10801817 	ldw	r2,96(r2)
8114b608:	e0bff615 	stw	r2,-40(fp)
8114b60c:	e03ff70d 	sth	zero,-36(fp)
8114b610:	e0bff70b 	ldhu	r2,-36(fp)
8114b614:	e0fffa04 	addi	r3,fp,-24
8114b618:	180d883a 	mov	r6,r3
8114b61c:	100b883a 	mov	r5,r2
8114b620:	e13ff617 	ldw	r4,-40(fp)
8114b624:	114075c0 	call	8114075c <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
8114b628:	e0bffb17 	ldw	r2,-20(fp)
8114b62c:	10800617 	ldw	r2,24(r2)
8114b630:	10800037 	ldwio	r2,0(r2)
8114b634:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
8114b638:	e0bfed17 	ldw	r2,-76(fp)
8114b63c:	1080004c 	andi	r2,r2,1
8114b640:	10000626 	beq	r2,zero,8114b65c <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
8114b644:	e0bffb17 	ldw	r2,-20(fp)
8114b648:	10801817 	ldw	r2,96(r2)
8114b64c:	1009883a 	mov	r4,r2
8114b650:	1140ae40 	call	81140ae4 <OSSemPost>
		return -EBUSY;
8114b654:	00bffc04 	movi	r2,-16
8114b658:	00009606 	br	8114b8b4 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114b65c:	00800804 	movi	r2,32
8114b660:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114b664:	0005303a 	rdctl	r2,status
8114b668:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114b66c:	e0fff217 	ldw	r3,-56(fp)
8114b670:	00bfff84 	movi	r2,-2
8114b674:	1884703a 	and	r2,r3,r2
8114b678:	1001703a 	wrctl	status,r2
  
  return context;
8114b67c:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8114b680:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114b684:	e0bffb17 	ldw	r2,-20(fp)
8114b688:	10800317 	ldw	r2,12(r2)
8114b68c:	10800104 	addi	r2,r2,4
8114b690:	e0ffee17 	ldw	r3,-72(fp)
8114b694:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
8114b698:	e0bffb17 	ldw	r2,-20(fp)
8114b69c:	10800317 	ldw	r2,12(r2)
8114b6a0:	e0fffb17 	ldw	r3,-20(fp)
8114b6a4:	18c00317 	ldw	r3,12(r3)
8114b6a8:	18c00037 	ldwio	r3,0(r3)
8114b6ac:	10c00035 	stwio	r3,0(r2)
8114b6b0:	e0bfef17 	ldw	r2,-68(fp)
8114b6b4:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114b6b8:	e0bff017 	ldw	r2,-64(fp)
8114b6bc:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
8114b6c0:	e0bffb17 	ldw	r2,-20(fp)
8114b6c4:	10800b17 	ldw	r2,44(r2)
8114b6c8:	10002326 	beq	r2,zero,8114b758 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
8114b6cc:	e0bffb17 	ldw	r2,-20(fp)
8114b6d0:	10c00d17 	ldw	r3,52(r2)
8114b6d4:	e0bfee17 	ldw	r2,-72(fp)
8114b6d8:	1884b03a 	or	r2,r3,r2
8114b6dc:	10800514 	ori	r2,r2,20
8114b6e0:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8114b6e4:	e0ffee17 	ldw	r3,-72(fp)
8114b6e8:	00bff7c4 	movi	r2,-33
8114b6ec:	1884703a 	and	r2,r3,r2
8114b6f0:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8114b6f4:	e0bfed17 	ldw	r2,-76(fp)
8114b6f8:	10800214 	ori	r2,r2,8
8114b6fc:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114b700:	0005303a 	rdctl	r2,status
8114b704:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114b708:	e0fff417 	ldw	r3,-48(fp)
8114b70c:	00bfff84 	movi	r2,-2
8114b710:	1884703a 	and	r2,r3,r2
8114b714:	1001703a 	wrctl	status,r2
  
  return context;
8114b718:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
8114b71c:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114b720:	e0bffb17 	ldw	r2,-20(fp)
8114b724:	10800317 	ldw	r2,12(r2)
8114b728:	10800104 	addi	r2,r2,4
8114b72c:	e0ffee17 	ldw	r3,-72(fp)
8114b730:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114b734:	e0bffb17 	ldw	r2,-20(fp)
8114b738:	10800617 	ldw	r2,24(r2)
8114b73c:	e0ffed17 	ldw	r3,-76(fp)
8114b740:	10c00035 	stwio	r3,0(r2)
8114b744:	e0bfef17 	ldw	r2,-68(fp)
8114b748:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114b74c:	e0bff117 	ldw	r2,-60(fp)
8114b750:	1001703a 	wrctl	status,r2
8114b754:	00002306 	br	8114b7e4 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
8114b758:	e0bffb17 	ldw	r2,-20(fp)
8114b75c:	10c00d17 	ldw	r3,52(r2)
8114b760:	e0bfee17 	ldw	r2,-72(fp)
8114b764:	1884b03a 	or	r2,r3,r2
8114b768:	10800114 	ori	r2,r2,4
8114b76c:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
8114b770:	e0ffee17 	ldw	r3,-72(fp)
8114b774:	00bff3c4 	movi	r2,-49
8114b778:	1884703a 	and	r2,r3,r2
8114b77c:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
8114b780:	e0ffed17 	ldw	r3,-76(fp)
8114b784:	00bffdc4 	movi	r2,-9
8114b788:	1884703a 	and	r2,r3,r2
8114b78c:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114b790:	0005303a 	rdctl	r2,status
8114b794:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114b798:	e0fff517 	ldw	r3,-44(fp)
8114b79c:	00bfff84 	movi	r2,-2
8114b7a0:	1884703a 	and	r2,r3,r2
8114b7a4:	1001703a 	wrctl	status,r2
  
  return context;
8114b7a8:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
8114b7ac:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114b7b0:	e0bffb17 	ldw	r2,-20(fp)
8114b7b4:	10800317 	ldw	r2,12(r2)
8114b7b8:	10800104 	addi	r2,r2,4
8114b7bc:	e0ffee17 	ldw	r3,-72(fp)
8114b7c0:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114b7c4:	e0bffb17 	ldw	r2,-20(fp)
8114b7c8:	10800617 	ldw	r2,24(r2)
8114b7cc:	e0ffed17 	ldw	r3,-76(fp)
8114b7d0:	10c00035 	stwio	r3,0(r2)
8114b7d4:	e0bfef17 	ldw	r2,-68(fp)
8114b7d8:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114b7dc:	e0bff317 	ldw	r2,-52(fp)
8114b7e0:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
8114b7e4:	e0bffb17 	ldw	r2,-20(fp)
8114b7e8:	10800617 	ldw	r2,24(r2)
8114b7ec:	10800104 	addi	r2,r2,4
8114b7f0:	e0fff817 	ldw	r3,-32(fp)
8114b7f4:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
8114b7f8:	e0bffb17 	ldw	r2,-20(fp)
8114b7fc:	10800617 	ldw	r2,24(r2)
8114b800:	10800204 	addi	r2,r2,8
8114b804:	e0fff917 	ldw	r3,-28(fp)
8114b808:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
8114b80c:	e0bffe03 	ldbu	r2,-8(fp)
8114b810:	10000426 	beq	r2,zero,8114b824 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
8114b814:	e0bfed17 	ldw	r2,-76(fp)
8114b818:	10800414 	ori	r2,r2,16
8114b81c:	e0bfed15 	stw	r2,-76(fp)
8114b820:	00000406 	br	8114b834 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
8114b824:	e0ffed17 	ldw	r3,-76(fp)
8114b828:	00bffbc4 	movi	r2,-17
8114b82c:	1884703a 	and	r2,r3,r2
8114b830:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
8114b834:	e0bfff03 	ldbu	r2,-4(fp)
8114b838:	10000e26 	beq	r2,zero,8114b874 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
8114b83c:	e0bfed17 	ldw	r2,-76(fp)
8114b840:	10800094 	ori	r2,r2,2
8114b844:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8114b848:	e0bffb17 	ldw	r2,-20(fp)
8114b84c:	10800617 	ldw	r2,24(r2)
8114b850:	10800304 	addi	r2,r2,12
8114b854:	10800037 	ldwio	r2,0(r2)
8114b858:	10000a1e 	bne	r2,zero,8114b884 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8114b85c:	e0bffb17 	ldw	r2,-20(fp)
8114b860:	10800617 	ldw	r2,24(r2)
8114b864:	10800304 	addi	r2,r2,12
8114b868:	00c03fc4 	movi	r3,255
8114b86c:	10c00035 	stwio	r3,0(r2)
8114b870:	00000406 	br	8114b884 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
8114b874:	e0ffed17 	ldw	r3,-76(fp)
8114b878:	00bfff44 	movi	r2,-3
8114b87c:	1884703a 	and	r2,r3,r2
8114b880:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
8114b884:	e0bfed17 	ldw	r2,-76(fp)
8114b888:	10800054 	ori	r2,r2,1
8114b88c:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114b890:	e0bffb17 	ldw	r2,-20(fp)
8114b894:	10800617 	ldw	r2,24(r2)
8114b898:	e0ffed17 	ldw	r3,-76(fp)
8114b89c:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
8114b8a0:	e0bffb17 	ldw	r2,-20(fp)
8114b8a4:	10801817 	ldw	r2,96(r2)
8114b8a8:	1009883a 	mov	r4,r2
8114b8ac:	1140ae40 	call	81140ae4 <OSSemPost>
	 
	 return 0;
8114b8b0:	0005883a 	mov	r2,zero
}
8114b8b4:	e037883a 	mov	sp,fp
8114b8b8:	dfc00117 	ldw	ra,4(sp)
8114b8bc:	df000017 	ldw	fp,0(sp)
8114b8c0:	dec00204 	addi	sp,sp,8
8114b8c4:	f800283a 	ret

8114b8c8 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
8114b8c8:	defff704 	addi	sp,sp,-36
8114b8cc:	de00012e 	bgeu	sp,et,8114b8d4 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
8114b8d0:	003b68fa 	trap	3
8114b8d4:	dfc00815 	stw	ra,32(sp)
8114b8d8:	df000715 	stw	fp,28(sp)
8114b8dc:	dc400615 	stw	r17,24(sp)
8114b8e0:	dc000515 	stw	r16,20(sp)
8114b8e4:	df000704 	addi	fp,sp,28
8114b8e8:	e13ffa15 	stw	r4,-24(fp)
8114b8ec:	e17ffb15 	stw	r5,-20(fp)
8114b8f0:	3007883a 	mov	r3,r6
8114b8f4:	3805883a 	mov	r2,r7
8114b8f8:	e0fffc05 	stb	r3,-16(fp)
8114b8fc:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
8114b900:	e13ffb17 	ldw	r4,-20(fp)
8114b904:	114b4340 	call	8114b434 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
8114b908:	10000226 	beq	r2,zero,8114b914 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
8114b90c:	00bffa84 	movi	r2,-22
8114b910:	00000b06 	br	8114b940 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
8114b914:	e0bffb17 	ldw	r2,-20(fp)
8114b918:	1021883a 	mov	r16,r2
8114b91c:	0023883a 	mov	r17,zero
8114b920:	e0fffc03 	ldbu	r3,-16(fp)
8114b924:	e0bffd03 	ldbu	r2,-12(fp)
8114b928:	d8800015 	stw	r2,0(sp)
8114b92c:	180f883a 	mov	r7,r3
8114b930:	800b883a 	mov	r5,r16
8114b934:	880d883a 	mov	r6,r17
8114b938:	e13ffa17 	ldw	r4,-24(fp)
8114b93c:	114b5b00 	call	8114b5b0 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8114b940:	e6fffe04 	addi	sp,fp,-8
8114b944:	dfc00317 	ldw	ra,12(sp)
8114b948:	df000217 	ldw	fp,8(sp)
8114b94c:	dc400117 	ldw	r17,4(sp)
8114b950:	dc000017 	ldw	r16,0(sp)
8114b954:	dec00404 	addi	sp,sp,16
8114b958:	f800283a 	ret

8114b95c <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8114b95c:	defff704 	addi	sp,sp,-36
8114b960:	de00012e 	bgeu	sp,et,8114b968 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
8114b964:	003b68fa 	trap	3
8114b968:	dfc00815 	stw	ra,32(sp)
8114b96c:	df000715 	stw	fp,28(sp)
8114b970:	dc400615 	stw	r17,24(sp)
8114b974:	dc000515 	stw	r16,20(sp)
8114b978:	df000704 	addi	fp,sp,28
8114b97c:	e13ffa15 	stw	r4,-24(fp)
8114b980:	e17ffb15 	stw	r5,-20(fp)
8114b984:	3007883a 	mov	r3,r6
8114b988:	3805883a 	mov	r2,r7
8114b98c:	e0fffc05 	stb	r3,-16(fp)
8114b990:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
8114b994:	e13ffb17 	ldw	r4,-20(fp)
8114b998:	114b4d40 	call	8114b4d4 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
8114b99c:	10000226 	beq	r2,zero,8114b9a8 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
8114b9a0:	00bffa84 	movi	r2,-22
8114b9a4:	00000b06 	br	8114b9d4 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
8114b9a8:	e0bffb17 	ldw	r2,-20(fp)
8114b9ac:	1021883a 	mov	r16,r2
8114b9b0:	0023883a 	mov	r17,zero
8114b9b4:	e0fffc03 	ldbu	r3,-16(fp)
8114b9b8:	e0bffd03 	ldbu	r2,-12(fp)
8114b9bc:	d8800015 	stw	r2,0(sp)
8114b9c0:	180f883a 	mov	r7,r3
8114b9c4:	800b883a 	mov	r5,r16
8114b9c8:	880d883a 	mov	r6,r17
8114b9cc:	e13ffa17 	ldw	r4,-24(fp)
8114b9d0:	114b5b00 	call	8114b5b0 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8114b9d4:	e6fffe04 	addi	sp,fp,-8
8114b9d8:	dfc00317 	ldw	ra,12(sp)
8114b9dc:	df000217 	ldw	fp,8(sp)
8114b9e0:	dc400117 	ldw	r17,4(sp)
8114b9e4:	dc000017 	ldw	r16,0(sp)
8114b9e8:	dec00404 	addi	sp,sp,16
8114b9ec:	f800283a 	ret

8114b9f0 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
8114b9f0:	defffc04 	addi	sp,sp,-16
8114b9f4:	de00012e 	bgeu	sp,et,8114b9fc <alt_msgdma_open+0xc>
8114b9f8:	003b68fa 	trap	3
8114b9fc:	dfc00315 	stw	ra,12(sp)
8114ba00:	df000215 	stw	fp,8(sp)
8114ba04:	df000204 	addi	fp,sp,8
8114ba08:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
8114ba0c:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
8114ba10:	d1603504 	addi	r5,gp,-32556
8114ba14:	e13fff17 	ldw	r4,-4(fp)
8114ba18:	114bf940 	call	8114bf94 <alt_find_dev>
8114ba1c:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
8114ba20:	e0bffe17 	ldw	r2,-8(fp)
8114ba24:	1000041e 	bne	r2,zero,8114ba38 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
8114ba28:	1149c540 	call	81149c54 <alt_get_errno>
8114ba2c:	1007883a 	mov	r3,r2
8114ba30:	008004c4 	movi	r2,19
8114ba34:	18800015 	stw	r2,0(r3)
    }

    return dev;
8114ba38:	e0bffe17 	ldw	r2,-8(fp)
}
8114ba3c:	e037883a 	mov	sp,fp
8114ba40:	dfc00117 	ldw	ra,4(sp)
8114ba44:	df000017 	ldw	fp,0(sp)
8114ba48:	dec00204 	addi	sp,sp,8
8114ba4c:	f800283a 	ret

8114ba50 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
8114ba50:	defff604 	addi	sp,sp,-40
8114ba54:	de00012e 	bgeu	sp,et,8114ba5c <alt_msgdma_init+0xc>
8114ba58:	003b68fa 	trap	3
8114ba5c:	dfc00915 	stw	ra,36(sp)
8114ba60:	df000815 	stw	fp,32(sp)
8114ba64:	df000804 	addi	fp,sp,32
8114ba68:	e13ffd15 	stw	r4,-12(fp)
8114ba6c:	e17ffe15 	stw	r5,-8(fp)
8114ba70:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
8114ba74:	e0bffd17 	ldw	r2,-12(fp)
8114ba78:	10801783 	ldbu	r2,94(r2)
8114ba7c:	10803fcc 	andi	r2,r2,255
8114ba80:	10000b26 	beq	r2,zero,8114bab0 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
8114ba84:	e0bffd17 	ldw	r2,-12(fp)
8114ba88:	10800617 	ldw	r2,24(r2)
8114ba8c:	00c00104 	movi	r3,4
8114ba90:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
8114ba94:	0001883a 	nop
8114ba98:	e0bffd17 	ldw	r2,-12(fp)
8114ba9c:	10800617 	ldw	r2,24(r2)
8114baa0:	10800037 	ldwio	r2,0(r2)
8114baa4:	1080010c 	andi	r2,r2,4
8114baa8:	1005d0ba 	srai	r2,r2,2
8114baac:	103ffa1e 	bne	r2,zero,8114ba98 <__reset+0xfb12ba98>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
8114bab0:	e0bffd17 	ldw	r2,-12(fp)
8114bab4:	10800317 	ldw	r2,12(r2)
8114bab8:	10800104 	addi	r2,r2,4
8114babc:	00c00084 	movi	r3,2
8114bac0:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8114bac4:	0001883a 	nop
8114bac8:	e0bffd17 	ldw	r2,-12(fp)
8114bacc:	10800317 	ldw	r2,12(r2)
8114bad0:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
8114bad4:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8114bad8:	103ffb1e 	bne	r2,zero,8114bac8 <__reset+0xfb12bac8>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8114badc:	e0bffd17 	ldw	r2,-12(fp)
8114bae0:	10800317 	ldw	r2,12(r2)
8114bae4:	10800104 	addi	r2,r2,4
8114bae8:	10800037 	ldwio	r2,0(r2)
8114baec:	1007883a 	mov	r3,r2
8114baf0:	00bffbc4 	movi	r2,-17
8114baf4:	1884703a 	and	r2,r3,r2
8114baf8:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114bafc:	e0bff917 	ldw	r2,-28(fp)
8114bb00:	10800814 	ori	r2,r2,32
8114bb04:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8114bb08:	e0bffd17 	ldw	r2,-12(fp)
8114bb0c:	10800317 	ldw	r2,12(r2)
8114bb10:	10800104 	addi	r2,r2,4
8114bb14:	e0fff917 	ldw	r3,-28(fp)
8114bb18:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
8114bb1c:	e0bffd17 	ldw	r2,-12(fp)
8114bb20:	10800317 	ldw	r2,12(r2)
8114bb24:	e0fffd17 	ldw	r3,-12(fp)
8114bb28:	18c00317 	ldw	r3,12(r3)
8114bb2c:	18c00037 	ldwio	r3,0(r3)
8114bb30:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
8114bb34:	e0bffd17 	ldw	r2,-12(fp)
8114bb38:	10801783 	ldbu	r2,94(r2)
8114bb3c:	10803fcc 	andi	r2,r2,255
8114bb40:	10000826 	beq	r2,zero,8114bb64 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
8114bb44:	e0bffd17 	ldw	r2,-12(fp)
8114bb48:	10800617 	ldw	r2,24(r2)
8114bb4c:	10800404 	addi	r2,r2,16
8114bb50:	e0fffd17 	ldw	r3,-12(fp)
8114bb54:	18c00617 	ldw	r3,24(r3)
8114bb58:	18c00404 	addi	r3,r3,16
8114bb5c:	18c00037 	ldwio	r3,0(r3)
8114bb60:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
8114bb64:	d1603504 	addi	r5,gp,-32556
8114bb68:	e13ffd17 	ldw	r4,-12(fp)
8114bb6c:	114bee80 	call	8114bee8 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
8114bb70:	e0bffd17 	ldw	r2,-12(fp)
8114bb74:	10801804 	addi	r2,r2,96
8114bb78:	e0bffb15 	stw	r2,-20(fp)
8114bb7c:	00800044 	movi	r2,1
8114bb80:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8114bb84:	e0bffc0b 	ldhu	r2,-16(fp)
8114bb88:	1009883a 	mov	r4,r2
8114bb8c:	11404340 	call	81140434 <OSSemCreate>
8114bb90:	1007883a 	mov	r3,r2
8114bb94:	e0bffb17 	ldw	r2,-20(fp)
8114bb98:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8114bb9c:	e0bffb17 	ldw	r2,-20(fp)
8114bba0:	10800017 	ldw	r2,0(r2)
8114bba4:	10000226 	beq	r2,zero,8114bbb0 <alt_msgdma_init+0x160>
8114bba8:	0005883a 	mov	r2,zero
8114bbac:	00000106 	br	8114bbb4 <alt_msgdma_init+0x164>
8114bbb0:	00bfffc4 	movi	r2,-1
8114bbb4:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
8114bbb8:	e0bffa17 	ldw	r2,-24(fp)
8114bbbc:	1000081e 	bne	r2,zero,8114bbe0 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
8114bbc0:	d8000015 	stw	zero,0(sp)
8114bbc4:	e1fffd17 	ldw	r7,-12(fp)
8114bbc8:	01a04574 	movhi	r6,33045
8114bbcc:	31a79a04 	addi	r6,r6,-24984
8114bbd0:	e17fff17 	ldw	r5,-4(fp)
8114bbd4:	e13ffe17 	ldw	r4,-8(fp)
8114bbd8:	114c2200 	call	8114c220 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
8114bbdc:	00000406 	br	8114bbf0 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
8114bbe0:	01204574 	movhi	r4,33045
8114bbe4:	210bd904 	addi	r4,r4,12132
8114bbe8:	114c6380 	call	8114c638 <alt_printf>
    }
    
    return;
8114bbec:	0001883a 	nop

}
8114bbf0:	e037883a 	mov	sp,fp
8114bbf4:	dfc00117 	ldw	ra,4(sp)
8114bbf8:	df000017 	ldw	fp,0(sp)
8114bbfc:	dec00204 	addi	sp,sp,8
8114bc00:	f800283a 	ret

8114bc04 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
8114bc04:	defffb04 	addi	sp,sp,-20
8114bc08:	de00012e 	bgeu	sp,et,8114bc10 <alt_msgdma_register_callback+0xc>
8114bc0c:	003b68fa 	trap	3
8114bc10:	df000415 	stw	fp,16(sp)
8114bc14:	df000404 	addi	fp,sp,16
8114bc18:	e13ffc15 	stw	r4,-16(fp)
8114bc1c:	e17ffd15 	stw	r5,-12(fp)
8114bc20:	e1bffe15 	stw	r6,-8(fp)
8114bc24:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
8114bc28:	e0bffc17 	ldw	r2,-16(fp)
8114bc2c:	e0fffd17 	ldw	r3,-12(fp)
8114bc30:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
8114bc34:	e0bffc17 	ldw	r2,-16(fp)
8114bc38:	e0ffff17 	ldw	r3,-4(fp)
8114bc3c:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
8114bc40:	e0bffc17 	ldw	r2,-16(fp)
8114bc44:	e0fffe17 	ldw	r3,-8(fp)
8114bc48:	10c00d15 	stw	r3,52(r2)

    return ;
8114bc4c:	0001883a 	nop
}
8114bc50:	e037883a 	mov	sp,fp
8114bc54:	df000017 	ldw	fp,0(sp)
8114bc58:	dec00104 	addi	sp,sp,4
8114bc5c:	f800283a 	ret

8114bc60 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8114bc60:	defffc04 	addi	sp,sp,-16
8114bc64:	de00012e 	bgeu	sp,et,8114bc6c <alt_msgdma_standard_descriptor_async_transfer+0xc>
8114bc68:	003b68fa 	trap	3
8114bc6c:	dfc00315 	stw	ra,12(sp)
8114bc70:	df000215 	stw	fp,8(sp)
8114bc74:	df000204 	addi	fp,sp,8
8114bc78:	e13ffe15 	stw	r4,-8(fp)
8114bc7c:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
8114bc80:	000d883a 	mov	r6,zero
8114bc84:	e17fff17 	ldw	r5,-4(fp)
8114bc88:	e13ffe17 	ldw	r4,-8(fp)
8114bc8c:	114a1e40 	call	8114a1e4 <alt_msgdma_descriptor_async_transfer>

}
8114bc90:	e037883a 	mov	sp,fp
8114bc94:	dfc00117 	ldw	ra,4(sp)
8114bc98:	df000017 	ldw	fp,0(sp)
8114bc9c:	dec00204 	addi	sp,sp,8
8114bca0:	f800283a 	ret

8114bca4 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114bca4:	defffc04 	addi	sp,sp,-16
8114bca8:	de00012e 	bgeu	sp,et,8114bcb0 <alt_msgdma_extended_descriptor_async_transfer+0xc>
8114bcac:	003b68fa 	trap	3
8114bcb0:	dfc00315 	stw	ra,12(sp)
8114bcb4:	df000215 	stw	fp,8(sp)
8114bcb8:	df000204 	addi	fp,sp,8
8114bcbc:	e13ffe15 	stw	r4,-8(fp)
8114bcc0:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
8114bcc4:	e1bfff17 	ldw	r6,-4(fp)
8114bcc8:	000b883a 	mov	r5,zero
8114bccc:	e13ffe17 	ldw	r4,-8(fp)
8114bcd0:	114a1e40 	call	8114a1e4 <alt_msgdma_descriptor_async_transfer>
}
8114bcd4:	e037883a 	mov	sp,fp
8114bcd8:	dfc00117 	ldw	ra,4(sp)
8114bcdc:	df000017 	ldw	fp,0(sp)
8114bce0:	dec00204 	addi	sp,sp,8
8114bce4:	f800283a 	ret

8114bce8 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8114bce8:	defffc04 	addi	sp,sp,-16
8114bcec:	de00012e 	bgeu	sp,et,8114bcf4 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
8114bcf0:	003b68fa 	trap	3
8114bcf4:	dfc00315 	stw	ra,12(sp)
8114bcf8:	df000215 	stw	fp,8(sp)
8114bcfc:	df000204 	addi	fp,sp,8
8114bd00:	e13ffe15 	stw	r4,-8(fp)
8114bd04:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
8114bd08:	000d883a 	mov	r6,zero
8114bd0c:	e17fff17 	ldw	r5,-4(fp)
8114bd10:	e13ffe17 	ldw	r4,-8(fp)
8114bd14:	114a5240 	call	8114a524 <alt_msgdma_descriptor_sync_transfer>
}
8114bd18:	e037883a 	mov	sp,fp
8114bd1c:	dfc00117 	ldw	ra,4(sp)
8114bd20:	df000017 	ldw	fp,0(sp)
8114bd24:	dec00204 	addi	sp,sp,8
8114bd28:	f800283a 	ret

8114bd2c <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114bd2c:	defffc04 	addi	sp,sp,-16
8114bd30:	de00012e 	bgeu	sp,et,8114bd38 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
8114bd34:	003b68fa 	trap	3
8114bd38:	dfc00315 	stw	ra,12(sp)
8114bd3c:	df000215 	stw	fp,8(sp)
8114bd40:	df000204 	addi	fp,sp,8
8114bd44:	e13ffe15 	stw	r4,-8(fp)
8114bd48:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
8114bd4c:	e1bfff17 	ldw	r6,-4(fp)
8114bd50:	000b883a 	mov	r5,zero
8114bd54:	e13ffe17 	ldw	r4,-8(fp)
8114bd58:	114a5240 	call	8114a524 <alt_msgdma_descriptor_sync_transfer>
}
8114bd5c:	e037883a 	mov	sp,fp
8114bd60:	dfc00117 	ldw	ra,4(sp)
8114bd64:	df000017 	ldw	fp,0(sp)
8114bd68:	dec00204 	addi	sp,sp,8
8114bd6c:	f800283a 	ret

8114bd70 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
8114bd70:	defff504 	addi	sp,sp,-44
8114bd74:	de00012e 	bgeu	sp,et,8114bd7c <alt_alarm_start+0xc>
8114bd78:	003b68fa 	trap	3
8114bd7c:	df000a15 	stw	fp,40(sp)
8114bd80:	df000a04 	addi	fp,sp,40
8114bd84:	e13ffc15 	stw	r4,-16(fp)
8114bd88:	e17ffd15 	stw	r5,-12(fp)
8114bd8c:	e1bffe15 	stw	r6,-8(fp)
8114bd90:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
8114bd94:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8114bd98:	d0a08817 	ldw	r2,-32224(gp)
  
  if (alt_ticks_per_second ())
8114bd9c:	10003c26 	beq	r2,zero,8114be90 <alt_alarm_start+0x120>
  {
    if (alarm)
8114bda0:	e0bffc17 	ldw	r2,-16(fp)
8114bda4:	10003826 	beq	r2,zero,8114be88 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
8114bda8:	e0bffc17 	ldw	r2,-16(fp)
8114bdac:	e0fffe17 	ldw	r3,-8(fp)
8114bdb0:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
8114bdb4:	e0bffc17 	ldw	r2,-16(fp)
8114bdb8:	e0ffff17 	ldw	r3,-4(fp)
8114bdbc:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114bdc0:	0005303a 	rdctl	r2,status
8114bdc4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114bdc8:	e0fff917 	ldw	r3,-28(fp)
8114bdcc:	00bfff84 	movi	r2,-2
8114bdd0:	1884703a 	and	r2,r3,r2
8114bdd4:	1001703a 	wrctl	status,r2
  
  return context;
8114bdd8:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
8114bddc:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8114bde0:	d0a08917 	ldw	r2,-32220(gp)
      
      current_nticks = alt_nticks();
8114bde4:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
8114bde8:	e0fffd17 	ldw	r3,-12(fp)
8114bdec:	e0bff617 	ldw	r2,-40(fp)
8114bdf0:	1885883a 	add	r2,r3,r2
8114bdf4:	10c00044 	addi	r3,r2,1
8114bdf8:	e0bffc17 	ldw	r2,-16(fp)
8114bdfc:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
8114be00:	e0bffc17 	ldw	r2,-16(fp)
8114be04:	10c00217 	ldw	r3,8(r2)
8114be08:	e0bff617 	ldw	r2,-40(fp)
8114be0c:	1880042e 	bgeu	r3,r2,8114be20 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
8114be10:	e0bffc17 	ldw	r2,-16(fp)
8114be14:	00c00044 	movi	r3,1
8114be18:	10c00405 	stb	r3,16(r2)
8114be1c:	00000206 	br	8114be28 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
8114be20:	e0bffc17 	ldw	r2,-16(fp)
8114be24:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
8114be28:	e0bffc17 	ldw	r2,-16(fp)
8114be2c:	d0e01404 	addi	r3,gp,-32688
8114be30:	e0fffa15 	stw	r3,-24(fp)
8114be34:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8114be38:	e0bffb17 	ldw	r2,-20(fp)
8114be3c:	e0fffa17 	ldw	r3,-24(fp)
8114be40:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114be44:	e0bffa17 	ldw	r2,-24(fp)
8114be48:	10c00017 	ldw	r3,0(r2)
8114be4c:	e0bffb17 	ldw	r2,-20(fp)
8114be50:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114be54:	e0bffa17 	ldw	r2,-24(fp)
8114be58:	10800017 	ldw	r2,0(r2)
8114be5c:	e0fffb17 	ldw	r3,-20(fp)
8114be60:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114be64:	e0bffa17 	ldw	r2,-24(fp)
8114be68:	e0fffb17 	ldw	r3,-20(fp)
8114be6c:	10c00015 	stw	r3,0(r2)
8114be70:	e0bff817 	ldw	r2,-32(fp)
8114be74:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114be78:	e0bff717 	ldw	r2,-36(fp)
8114be7c:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
8114be80:	0005883a 	mov	r2,zero
8114be84:	00000306 	br	8114be94 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
8114be88:	00bffa84 	movi	r2,-22
8114be8c:	00000106 	br	8114be94 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
8114be90:	00bfde84 	movi	r2,-134
  }
}
8114be94:	e037883a 	mov	sp,fp
8114be98:	df000017 	ldw	fp,0(sp)
8114be9c:	dec00104 	addi	sp,sp,4
8114bea0:	f800283a 	ret

8114bea4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114bea4:	defffe04 	addi	sp,sp,-8
8114bea8:	de00012e 	bgeu	sp,et,8114beb0 <alt_get_errno+0xc>
8114beac:	003b68fa 	trap	3
8114beb0:	dfc00115 	stw	ra,4(sp)
8114beb4:	df000015 	stw	fp,0(sp)
8114beb8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8114bebc:	d0a01017 	ldw	r2,-32704(gp)
8114bec0:	10000326 	beq	r2,zero,8114bed0 <alt_get_errno+0x2c>
8114bec4:	d0a01017 	ldw	r2,-32704(gp)
8114bec8:	103ee83a 	callr	r2
8114becc:	00000106 	br	8114bed4 <alt_get_errno+0x30>
8114bed0:	d0a07804 	addi	r2,gp,-32288
}
8114bed4:	e037883a 	mov	sp,fp
8114bed8:	dfc00117 	ldw	ra,4(sp)
8114bedc:	df000017 	ldw	fp,0(sp)
8114bee0:	dec00204 	addi	sp,sp,8
8114bee4:	f800283a 	ret

8114bee8 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
8114bee8:	defffa04 	addi	sp,sp,-24
8114beec:	de00012e 	bgeu	sp,et,8114bef4 <alt_dev_llist_insert+0xc>
8114bef0:	003b68fa 	trap	3
8114bef4:	dfc00515 	stw	ra,20(sp)
8114bef8:	df000415 	stw	fp,16(sp)
8114befc:	df000404 	addi	fp,sp,16
8114bf00:	e13ffe15 	stw	r4,-8(fp)
8114bf04:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
8114bf08:	e0bffe17 	ldw	r2,-8(fp)
8114bf0c:	10000326 	beq	r2,zero,8114bf1c <alt_dev_llist_insert+0x34>
8114bf10:	e0bffe17 	ldw	r2,-8(fp)
8114bf14:	10800217 	ldw	r2,8(r2)
8114bf18:	1000061e 	bne	r2,zero,8114bf34 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
8114bf1c:	114bea40 	call	8114bea4 <alt_get_errno>
8114bf20:	1007883a 	mov	r3,r2
8114bf24:	00800584 	movi	r2,22
8114bf28:	18800015 	stw	r2,0(r3)
    return -EINVAL;
8114bf2c:	00bffa84 	movi	r2,-22
8114bf30:	00001306 	br	8114bf80 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
8114bf34:	e0bffe17 	ldw	r2,-8(fp)
8114bf38:	e0ffff17 	ldw	r3,-4(fp)
8114bf3c:	e0fffc15 	stw	r3,-16(fp)
8114bf40:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8114bf44:	e0bffd17 	ldw	r2,-12(fp)
8114bf48:	e0fffc17 	ldw	r3,-16(fp)
8114bf4c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114bf50:	e0bffc17 	ldw	r2,-16(fp)
8114bf54:	10c00017 	ldw	r3,0(r2)
8114bf58:	e0bffd17 	ldw	r2,-12(fp)
8114bf5c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114bf60:	e0bffc17 	ldw	r2,-16(fp)
8114bf64:	10800017 	ldw	r2,0(r2)
8114bf68:	e0fffd17 	ldw	r3,-12(fp)
8114bf6c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114bf70:	e0bffc17 	ldw	r2,-16(fp)
8114bf74:	e0fffd17 	ldw	r3,-12(fp)
8114bf78:	10c00015 	stw	r3,0(r2)

  return 0;  
8114bf7c:	0005883a 	mov	r2,zero
}
8114bf80:	e037883a 	mov	sp,fp
8114bf84:	dfc00117 	ldw	ra,4(sp)
8114bf88:	df000017 	ldw	fp,0(sp)
8114bf8c:	dec00204 	addi	sp,sp,8
8114bf90:	f800283a 	ret

8114bf94 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
8114bf94:	defffa04 	addi	sp,sp,-24
8114bf98:	de00012e 	bgeu	sp,et,8114bfa0 <alt_find_dev+0xc>
8114bf9c:	003b68fa 	trap	3
8114bfa0:	dfc00515 	stw	ra,20(sp)
8114bfa4:	df000415 	stw	fp,16(sp)
8114bfa8:	df000404 	addi	fp,sp,16
8114bfac:	e13ffe15 	stw	r4,-8(fp)
8114bfb0:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
8114bfb4:	e0bfff17 	ldw	r2,-4(fp)
8114bfb8:	10800017 	ldw	r2,0(r2)
8114bfbc:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
8114bfc0:	e13ffe17 	ldw	r4,-8(fp)
8114bfc4:	1124dc80 	call	81124dc8 <strlen>
8114bfc8:	10800044 	addi	r2,r2,1
8114bfcc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114bfd0:	00000d06 	br	8114c008 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
8114bfd4:	e0bffc17 	ldw	r2,-16(fp)
8114bfd8:	10800217 	ldw	r2,8(r2)
8114bfdc:	e0fffd17 	ldw	r3,-12(fp)
8114bfe0:	180d883a 	mov	r6,r3
8114bfe4:	e17ffe17 	ldw	r5,-8(fp)
8114bfe8:	1009883a 	mov	r4,r2
8114bfec:	114cda80 	call	8114cda8 <memcmp>
8114bff0:	1000021e 	bne	r2,zero,8114bffc <alt_find_dev+0x68>
    {
      /* match found */

      return next;
8114bff4:	e0bffc17 	ldw	r2,-16(fp)
8114bff8:	00000706 	br	8114c018 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
8114bffc:	e0bffc17 	ldw	r2,-16(fp)
8114c000:	10800017 	ldw	r2,0(r2)
8114c004:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114c008:	e0fffc17 	ldw	r3,-16(fp)
8114c00c:	e0bfff17 	ldw	r2,-4(fp)
8114c010:	18bff01e 	bne	r3,r2,8114bfd4 <__reset+0xfb12bfd4>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
8114c014:	0005883a 	mov	r2,zero
}
8114c018:	e037883a 	mov	sp,fp
8114c01c:	dfc00117 	ldw	ra,4(sp)
8114c020:	df000017 	ldw	fp,0(sp)
8114c024:	dec00204 	addi	sp,sp,8
8114c028:	f800283a 	ret

8114c02c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
8114c02c:	defffb04 	addi	sp,sp,-20
8114c030:	de00012e 	bgeu	sp,et,8114c038 <alt_find_file+0xc>
8114c034:	003b68fa 	trap	3
8114c038:	dfc00415 	stw	ra,16(sp)
8114c03c:	df000315 	stw	fp,12(sp)
8114c040:	df000304 	addi	fp,sp,12
8114c044:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
8114c048:	d0a00b17 	ldw	r2,-32724(gp)
8114c04c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114c050:	00003106 	br	8114c118 <alt_find_file+0xec>
  {
    len = strlen(next->name);
8114c054:	e0bffd17 	ldw	r2,-12(fp)
8114c058:	10800217 	ldw	r2,8(r2)
8114c05c:	1009883a 	mov	r4,r2
8114c060:	1124dc80 	call	81124dc8 <strlen>
8114c064:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
8114c068:	e0bffd17 	ldw	r2,-12(fp)
8114c06c:	10c00217 	ldw	r3,8(r2)
8114c070:	e0bffe17 	ldw	r2,-8(fp)
8114c074:	10bfffc4 	addi	r2,r2,-1
8114c078:	1885883a 	add	r2,r3,r2
8114c07c:	10800003 	ldbu	r2,0(r2)
8114c080:	10803fcc 	andi	r2,r2,255
8114c084:	1080201c 	xori	r2,r2,128
8114c088:	10bfe004 	addi	r2,r2,-128
8114c08c:	10800bd8 	cmpnei	r2,r2,47
8114c090:	1000031e 	bne	r2,zero,8114c0a0 <alt_find_file+0x74>
    {
      len -= 1;
8114c094:	e0bffe17 	ldw	r2,-8(fp)
8114c098:	10bfffc4 	addi	r2,r2,-1
8114c09c:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114c0a0:	e0bffe17 	ldw	r2,-8(fp)
8114c0a4:	e0ffff17 	ldw	r3,-4(fp)
8114c0a8:	1885883a 	add	r2,r3,r2
8114c0ac:	10800003 	ldbu	r2,0(r2)
8114c0b0:	10803fcc 	andi	r2,r2,255
8114c0b4:	1080201c 	xori	r2,r2,128
8114c0b8:	10bfe004 	addi	r2,r2,-128
8114c0bc:	10800be0 	cmpeqi	r2,r2,47
8114c0c0:	1000081e 	bne	r2,zero,8114c0e4 <alt_find_file+0xb8>
8114c0c4:	e0bffe17 	ldw	r2,-8(fp)
8114c0c8:	e0ffff17 	ldw	r3,-4(fp)
8114c0cc:	1885883a 	add	r2,r3,r2
8114c0d0:	10800003 	ldbu	r2,0(r2)
8114c0d4:	10803fcc 	andi	r2,r2,255
8114c0d8:	1080201c 	xori	r2,r2,128
8114c0dc:	10bfe004 	addi	r2,r2,-128
8114c0e0:	10000a1e 	bne	r2,zero,8114c10c <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
8114c0e4:	e0bffd17 	ldw	r2,-12(fp)
8114c0e8:	10800217 	ldw	r2,8(r2)
8114c0ec:	e0fffe17 	ldw	r3,-8(fp)
8114c0f0:	180d883a 	mov	r6,r3
8114c0f4:	e17fff17 	ldw	r5,-4(fp)
8114c0f8:	1009883a 	mov	r4,r2
8114c0fc:	114cda80 	call	8114cda8 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114c100:	1000021e 	bne	r2,zero,8114c10c <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
8114c104:	e0bffd17 	ldw	r2,-12(fp)
8114c108:	00000706 	br	8114c128 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
8114c10c:	e0bffd17 	ldw	r2,-12(fp)
8114c110:	10800017 	ldw	r2,0(r2)
8114c114:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114c118:	e0fffd17 	ldw	r3,-12(fp)
8114c11c:	d0a00b04 	addi	r2,gp,-32724
8114c120:	18bfcc1e 	bne	r3,r2,8114c054 <__reset+0xfb12c054>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
8114c124:	0005883a 	mov	r2,zero
}
8114c128:	e037883a 	mov	sp,fp
8114c12c:	dfc00117 	ldw	ra,4(sp)
8114c130:	df000017 	ldw	fp,0(sp)
8114c134:	dec00204 	addi	sp,sp,8
8114c138:	f800283a 	ret

8114c13c <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
8114c13c:	defff904 	addi	sp,sp,-28
8114c140:	de00012e 	bgeu	sp,et,8114c148 <alt_get_fd+0xc>
8114c144:	003b68fa 	trap	3
8114c148:	dfc00615 	stw	ra,24(sp)
8114c14c:	df000515 	stw	fp,20(sp)
8114c150:	df000504 	addi	fp,sp,20
8114c154:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
8114c158:	00bffa04 	movi	r2,-24
8114c15c:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
8114c160:	d0a07f17 	ldw	r2,-32260(gp)
8114c164:	e0bffd15 	stw	r2,-12(fp)
8114c168:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8114c16c:	e0bffe0b 	ldhu	r2,-8(fp)
8114c170:	e0fffe84 	addi	r3,fp,-6
8114c174:	180d883a 	mov	r6,r3
8114c178:	100b883a 	mov	r5,r2
8114c17c:	e13ffd17 	ldw	r4,-12(fp)
8114c180:	114075c0 	call	8114075c <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114c184:	e03ffb15 	stw	zero,-20(fp)
8114c188:	00001906 	br	8114c1f0 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
8114c18c:	00a04574 	movhi	r2,33045
8114c190:	108e4804 	addi	r2,r2,14624
8114c194:	e0fffb17 	ldw	r3,-20(fp)
8114c198:	18c00324 	muli	r3,r3,12
8114c19c:	10c5883a 	add	r2,r2,r3
8114c1a0:	10800017 	ldw	r2,0(r2)
8114c1a4:	10000f1e 	bne	r2,zero,8114c1e4 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
8114c1a8:	00a04574 	movhi	r2,33045
8114c1ac:	108e4804 	addi	r2,r2,14624
8114c1b0:	e0fffb17 	ldw	r3,-20(fp)
8114c1b4:	18c00324 	muli	r3,r3,12
8114c1b8:	10c5883a 	add	r2,r2,r3
8114c1bc:	e0ffff17 	ldw	r3,-4(fp)
8114c1c0:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
8114c1c4:	d0e00f17 	ldw	r3,-32708(gp)
8114c1c8:	e0bffb17 	ldw	r2,-20(fp)
8114c1cc:	1880020e 	bge	r3,r2,8114c1d8 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
8114c1d0:	e0bffb17 	ldw	r2,-20(fp)
8114c1d4:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
8114c1d8:	e0bffb17 	ldw	r2,-20(fp)
8114c1dc:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
8114c1e0:	00000606 	br	8114c1fc <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114c1e4:	e0bffb17 	ldw	r2,-20(fp)
8114c1e8:	10800044 	addi	r2,r2,1
8114c1ec:	e0bffb15 	stw	r2,-20(fp)
8114c1f0:	e0bffb17 	ldw	r2,-20(fp)
8114c1f4:	10800810 	cmplti	r2,r2,32
8114c1f8:	103fe41e 	bne	r2,zero,8114c18c <__reset+0xfb12c18c>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
8114c1fc:	d0a07f17 	ldw	r2,-32260(gp)
8114c200:	1009883a 	mov	r4,r2
8114c204:	1140ae40 	call	81140ae4 <OSSemPost>

  return rc;
8114c208:	e0bffc17 	ldw	r2,-16(fp)
}
8114c20c:	e037883a 	mov	sp,fp
8114c210:	dfc00117 	ldw	ra,4(sp)
8114c214:	df000017 	ldw	fp,0(sp)
8114c218:	dec00204 	addi	sp,sp,8
8114c21c:	f800283a 	ret

8114c220 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114c220:	defff904 	addi	sp,sp,-28
8114c224:	de00012e 	bgeu	sp,et,8114c22c <alt_ic_isr_register+0xc>
8114c228:	003b68fa 	trap	3
8114c22c:	dfc00615 	stw	ra,24(sp)
8114c230:	df000515 	stw	fp,20(sp)
8114c234:	df000504 	addi	fp,sp,20
8114c238:	e13ffc15 	stw	r4,-16(fp)
8114c23c:	e17ffd15 	stw	r5,-12(fp)
8114c240:	e1bffe15 	stw	r6,-8(fp)
8114c244:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
8114c248:	e0800217 	ldw	r2,8(fp)
8114c24c:	d8800015 	stw	r2,0(sp)
8114c250:	e1ffff17 	ldw	r7,-4(fp)
8114c254:	e1bffe17 	ldw	r6,-8(fp)
8114c258:	e17ffd17 	ldw	r5,-12(fp)
8114c25c:	e13ffc17 	ldw	r4,-16(fp)
8114c260:	114c3f00 	call	8114c3f0 <alt_iic_isr_register>
}  
8114c264:	e037883a 	mov	sp,fp
8114c268:	dfc00117 	ldw	ra,4(sp)
8114c26c:	df000017 	ldw	fp,0(sp)
8114c270:	dec00204 	addi	sp,sp,8
8114c274:	f800283a 	ret

8114c278 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
8114c278:	defff904 	addi	sp,sp,-28
8114c27c:	de00012e 	bgeu	sp,et,8114c284 <alt_ic_irq_enable+0xc>
8114c280:	003b68fa 	trap	3
8114c284:	df000615 	stw	fp,24(sp)
8114c288:	df000604 	addi	fp,sp,24
8114c28c:	e13ffe15 	stw	r4,-8(fp)
8114c290:	e17fff15 	stw	r5,-4(fp)
8114c294:	e0bfff17 	ldw	r2,-4(fp)
8114c298:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114c29c:	0005303a 	rdctl	r2,status
8114c2a0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114c2a4:	e0fffb17 	ldw	r3,-20(fp)
8114c2a8:	00bfff84 	movi	r2,-2
8114c2ac:	1884703a 	and	r2,r3,r2
8114c2b0:	1001703a 	wrctl	status,r2
  
  return context;
8114c2b4:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114c2b8:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
8114c2bc:	00c00044 	movi	r3,1
8114c2c0:	e0bffa17 	ldw	r2,-24(fp)
8114c2c4:	1884983a 	sll	r2,r3,r2
8114c2c8:	1007883a 	mov	r3,r2
8114c2cc:	d0a08017 	ldw	r2,-32256(gp)
8114c2d0:	1884b03a 	or	r2,r3,r2
8114c2d4:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114c2d8:	d0a08017 	ldw	r2,-32256(gp)
8114c2dc:	100170fa 	wrctl	ienable,r2
8114c2e0:	e0bffc17 	ldw	r2,-16(fp)
8114c2e4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114c2e8:	e0bffd17 	ldw	r2,-12(fp)
8114c2ec:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114c2f0:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
8114c2f4:	0001883a 	nop
}
8114c2f8:	e037883a 	mov	sp,fp
8114c2fc:	df000017 	ldw	fp,0(sp)
8114c300:	dec00104 	addi	sp,sp,4
8114c304:	f800283a 	ret

8114c308 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
8114c308:	defff904 	addi	sp,sp,-28
8114c30c:	de00012e 	bgeu	sp,et,8114c314 <alt_ic_irq_disable+0xc>
8114c310:	003b68fa 	trap	3
8114c314:	df000615 	stw	fp,24(sp)
8114c318:	df000604 	addi	fp,sp,24
8114c31c:	e13ffe15 	stw	r4,-8(fp)
8114c320:	e17fff15 	stw	r5,-4(fp)
8114c324:	e0bfff17 	ldw	r2,-4(fp)
8114c328:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114c32c:	0005303a 	rdctl	r2,status
8114c330:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114c334:	e0fffb17 	ldw	r3,-20(fp)
8114c338:	00bfff84 	movi	r2,-2
8114c33c:	1884703a 	and	r2,r3,r2
8114c340:	1001703a 	wrctl	status,r2
  
  return context;
8114c344:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114c348:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
8114c34c:	00c00044 	movi	r3,1
8114c350:	e0bffa17 	ldw	r2,-24(fp)
8114c354:	1884983a 	sll	r2,r3,r2
8114c358:	0084303a 	nor	r2,zero,r2
8114c35c:	1007883a 	mov	r3,r2
8114c360:	d0a08017 	ldw	r2,-32256(gp)
8114c364:	1884703a 	and	r2,r3,r2
8114c368:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114c36c:	d0a08017 	ldw	r2,-32256(gp)
8114c370:	100170fa 	wrctl	ienable,r2
8114c374:	e0bffc17 	ldw	r2,-16(fp)
8114c378:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114c37c:	e0bffd17 	ldw	r2,-12(fp)
8114c380:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114c384:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
8114c388:	0001883a 	nop
}
8114c38c:	e037883a 	mov	sp,fp
8114c390:	df000017 	ldw	fp,0(sp)
8114c394:	dec00104 	addi	sp,sp,4
8114c398:	f800283a 	ret

8114c39c <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
8114c39c:	defffc04 	addi	sp,sp,-16
8114c3a0:	de00012e 	bgeu	sp,et,8114c3a8 <alt_ic_irq_enabled+0xc>
8114c3a4:	003b68fa 	trap	3
8114c3a8:	df000315 	stw	fp,12(sp)
8114c3ac:	df000304 	addi	fp,sp,12
8114c3b0:	e13ffe15 	stw	r4,-8(fp)
8114c3b4:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
8114c3b8:	000530fa 	rdctl	r2,ienable
8114c3bc:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
8114c3c0:	00c00044 	movi	r3,1
8114c3c4:	e0bfff17 	ldw	r2,-4(fp)
8114c3c8:	1884983a 	sll	r2,r3,r2
8114c3cc:	1007883a 	mov	r3,r2
8114c3d0:	e0bffd17 	ldw	r2,-12(fp)
8114c3d4:	1884703a 	and	r2,r3,r2
8114c3d8:	1004c03a 	cmpne	r2,r2,zero
8114c3dc:	10803fcc 	andi	r2,r2,255
}
8114c3e0:	e037883a 	mov	sp,fp
8114c3e4:	df000017 	ldw	fp,0(sp)
8114c3e8:	dec00104 	addi	sp,sp,4
8114c3ec:	f800283a 	ret

8114c3f0 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114c3f0:	defff504 	addi	sp,sp,-44
8114c3f4:	de00012e 	bgeu	sp,et,8114c3fc <alt_iic_isr_register+0xc>
8114c3f8:	003b68fa 	trap	3
8114c3fc:	dfc00a15 	stw	ra,40(sp)
8114c400:	df000915 	stw	fp,36(sp)
8114c404:	df000904 	addi	fp,sp,36
8114c408:	e13ffc15 	stw	r4,-16(fp)
8114c40c:	e17ffd15 	stw	r5,-12(fp)
8114c410:	e1bffe15 	stw	r6,-8(fp)
8114c414:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
8114c418:	00bffa84 	movi	r2,-22
8114c41c:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
8114c420:	e0bffd17 	ldw	r2,-12(fp)
8114c424:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8114c428:	e0bff817 	ldw	r2,-32(fp)
8114c42c:	10800808 	cmpgei	r2,r2,32
8114c430:	1000271e 	bne	r2,zero,8114c4d0 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114c434:	0005303a 	rdctl	r2,status
8114c438:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114c43c:	e0fffb17 	ldw	r3,-20(fp)
8114c440:	00bfff84 	movi	r2,-2
8114c444:	1884703a 	and	r2,r3,r2
8114c448:	1001703a 	wrctl	status,r2
  
  return context;
8114c44c:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
8114c450:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
8114c454:	00a045f4 	movhi	r2,33047
8114c458:	10bbed04 	addi	r2,r2,-4172
8114c45c:	e0fff817 	ldw	r3,-32(fp)
8114c460:	180690fa 	slli	r3,r3,3
8114c464:	10c5883a 	add	r2,r2,r3
8114c468:	e0fffe17 	ldw	r3,-8(fp)
8114c46c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
8114c470:	00a045f4 	movhi	r2,33047
8114c474:	10bbed04 	addi	r2,r2,-4172
8114c478:	e0fff817 	ldw	r3,-32(fp)
8114c47c:	180690fa 	slli	r3,r3,3
8114c480:	10c5883a 	add	r2,r2,r3
8114c484:	10800104 	addi	r2,r2,4
8114c488:	e0ffff17 	ldw	r3,-4(fp)
8114c48c:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
8114c490:	e0bffe17 	ldw	r2,-8(fp)
8114c494:	10000526 	beq	r2,zero,8114c4ac <alt_iic_isr_register+0xbc>
8114c498:	e0bff817 	ldw	r2,-32(fp)
8114c49c:	100b883a 	mov	r5,r2
8114c4a0:	e13ffc17 	ldw	r4,-16(fp)
8114c4a4:	114c2780 	call	8114c278 <alt_ic_irq_enable>
8114c4a8:	00000406 	br	8114c4bc <alt_iic_isr_register+0xcc>
8114c4ac:	e0bff817 	ldw	r2,-32(fp)
8114c4b0:	100b883a 	mov	r5,r2
8114c4b4:	e13ffc17 	ldw	r4,-16(fp)
8114c4b8:	114c3080 	call	8114c308 <alt_ic_irq_disable>
8114c4bc:	e0bff715 	stw	r2,-36(fp)
8114c4c0:	e0bffa17 	ldw	r2,-24(fp)
8114c4c4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114c4c8:	e0bff917 	ldw	r2,-28(fp)
8114c4cc:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
8114c4d0:	e0bff717 	ldw	r2,-36(fp)
}
8114c4d4:	e037883a 	mov	sp,fp
8114c4d8:	dfc00117 	ldw	ra,4(sp)
8114c4dc:	df000017 	ldw	fp,0(sp)
8114c4e0:	dec00204 	addi	sp,sp,8
8114c4e4:	f800283a 	ret

8114c4e8 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
8114c4e8:	defff904 	addi	sp,sp,-28
8114c4ec:	de00012e 	bgeu	sp,et,8114c4f4 <alt_open_fd+0xc>
8114c4f0:	003b68fa 	trap	3
8114c4f4:	dfc00615 	stw	ra,24(sp)
8114c4f8:	df000515 	stw	fp,20(sp)
8114c4fc:	df000504 	addi	fp,sp,20
8114c500:	e13ffc15 	stw	r4,-16(fp)
8114c504:	e17ffd15 	stw	r5,-12(fp)
8114c508:	e1bffe15 	stw	r6,-8(fp)
8114c50c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
8114c510:	e1bfff17 	ldw	r6,-4(fp)
8114c514:	e17ffe17 	ldw	r5,-8(fp)
8114c518:	e13ffd17 	ldw	r4,-12(fp)
8114c51c:	11393980 	call	81139398 <open>
8114c520:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
8114c524:	e0bffb17 	ldw	r2,-20(fp)
8114c528:	10001c16 	blt	r2,zero,8114c59c <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
8114c52c:	00a04574 	movhi	r2,33045
8114c530:	108e4804 	addi	r2,r2,14624
8114c534:	e0fffb17 	ldw	r3,-20(fp)
8114c538:	18c00324 	muli	r3,r3,12
8114c53c:	10c5883a 	add	r2,r2,r3
8114c540:	10c00017 	ldw	r3,0(r2)
8114c544:	e0bffc17 	ldw	r2,-16(fp)
8114c548:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
8114c54c:	00a04574 	movhi	r2,33045
8114c550:	108e4804 	addi	r2,r2,14624
8114c554:	e0fffb17 	ldw	r3,-20(fp)
8114c558:	18c00324 	muli	r3,r3,12
8114c55c:	10c5883a 	add	r2,r2,r3
8114c560:	10800104 	addi	r2,r2,4
8114c564:	10c00017 	ldw	r3,0(r2)
8114c568:	e0bffc17 	ldw	r2,-16(fp)
8114c56c:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
8114c570:	00a04574 	movhi	r2,33045
8114c574:	108e4804 	addi	r2,r2,14624
8114c578:	e0fffb17 	ldw	r3,-20(fp)
8114c57c:	18c00324 	muli	r3,r3,12
8114c580:	10c5883a 	add	r2,r2,r3
8114c584:	10800204 	addi	r2,r2,8
8114c588:	10c00017 	ldw	r3,0(r2)
8114c58c:	e0bffc17 	ldw	r2,-16(fp)
8114c590:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
8114c594:	e13ffb17 	ldw	r4,-20(fp)
8114c598:	113963c0 	call	8113963c <alt_release_fd>
  }
} 
8114c59c:	0001883a 	nop
8114c5a0:	e037883a 	mov	sp,fp
8114c5a4:	dfc00117 	ldw	ra,4(sp)
8114c5a8:	df000017 	ldw	fp,0(sp)
8114c5ac:	dec00204 	addi	sp,sp,8
8114c5b0:	f800283a 	ret

8114c5b4 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
8114c5b4:	defffb04 	addi	sp,sp,-20
8114c5b8:	de00012e 	bgeu	sp,et,8114c5c0 <alt_io_redirect+0xc>
8114c5bc:	003b68fa 	trap	3
8114c5c0:	dfc00415 	stw	ra,16(sp)
8114c5c4:	df000315 	stw	fp,12(sp)
8114c5c8:	df000304 	addi	fp,sp,12
8114c5cc:	e13ffd15 	stw	r4,-12(fp)
8114c5d0:	e17ffe15 	stw	r5,-8(fp)
8114c5d4:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
8114c5d8:	01c07fc4 	movi	r7,511
8114c5dc:	01800044 	movi	r6,1
8114c5e0:	e17ffd17 	ldw	r5,-12(fp)
8114c5e4:	01204574 	movhi	r4,33045
8114c5e8:	210e4b04 	addi	r4,r4,14636
8114c5ec:	114c4e80 	call	8114c4e8 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
8114c5f0:	01c07fc4 	movi	r7,511
8114c5f4:	000d883a 	mov	r6,zero
8114c5f8:	e17ffe17 	ldw	r5,-8(fp)
8114c5fc:	01204574 	movhi	r4,33045
8114c600:	210e4804 	addi	r4,r4,14624
8114c604:	114c4e80 	call	8114c4e8 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
8114c608:	01c07fc4 	movi	r7,511
8114c60c:	01800044 	movi	r6,1
8114c610:	e17fff17 	ldw	r5,-4(fp)
8114c614:	01204574 	movhi	r4,33045
8114c618:	210e4e04 	addi	r4,r4,14648
8114c61c:	114c4e80 	call	8114c4e8 <alt_open_fd>
}  
8114c620:	0001883a 	nop
8114c624:	e037883a 	mov	sp,fp
8114c628:	dfc00117 	ldw	ra,4(sp)
8114c62c:	df000017 	ldw	fp,0(sp)
8114c630:	dec00204 	addi	sp,sp,8
8114c634:	f800283a 	ret

8114c638 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
8114c638:	defff204 	addi	sp,sp,-56
8114c63c:	de00012e 	bgeu	sp,et,8114c644 <alt_printf+0xc>
8114c640:	003b68fa 	trap	3
8114c644:	dfc00a15 	stw	ra,40(sp)
8114c648:	df000915 	stw	fp,36(sp)
8114c64c:	df000904 	addi	fp,sp,36
8114c650:	e13fff15 	stw	r4,-4(fp)
8114c654:	e1400215 	stw	r5,8(fp)
8114c658:	e1800315 	stw	r6,12(fp)
8114c65c:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
8114c660:	e0800204 	addi	r2,fp,8
8114c664:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
8114c668:	e0bfff17 	ldw	r2,-4(fp)
8114c66c:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
8114c670:	00006f06 	br	8114c830 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
8114c674:	e0bff807 	ldb	r2,-32(fp)
8114c678:	10800960 	cmpeqi	r2,r2,37
8114c67c:	1000041e 	bne	r2,zero,8114c690 <alt_printf+0x58>
        {
            alt_putchar(c);
8114c680:	e0bff807 	ldb	r2,-32(fp)
8114c684:	1009883a 	mov	r4,r2
8114c688:	114c86c0 	call	8114c86c <alt_putchar>
8114c68c:	00006806 	br	8114c830 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
8114c690:	e0bff717 	ldw	r2,-36(fp)
8114c694:	10c00044 	addi	r3,r2,1
8114c698:	e0fff715 	stw	r3,-36(fp)
8114c69c:	10800003 	ldbu	r2,0(r2)
8114c6a0:	e0bff805 	stb	r2,-32(fp)
8114c6a4:	e0bff807 	ldb	r2,-32(fp)
8114c6a8:	10006926 	beq	r2,zero,8114c850 <alt_printf+0x218>
            {
                if (c == '%')
8114c6ac:	e0bff807 	ldb	r2,-32(fp)
8114c6b0:	10800958 	cmpnei	r2,r2,37
8114c6b4:	1000041e 	bne	r2,zero,8114c6c8 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
8114c6b8:	e0bff807 	ldb	r2,-32(fp)
8114c6bc:	1009883a 	mov	r4,r2
8114c6c0:	114c86c0 	call	8114c86c <alt_putchar>
8114c6c4:	00005a06 	br	8114c830 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
8114c6c8:	e0bff807 	ldb	r2,-32(fp)
8114c6cc:	108018d8 	cmpnei	r2,r2,99
8114c6d0:	1000081e 	bne	r2,zero,8114c6f4 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
8114c6d4:	e0bffe17 	ldw	r2,-8(fp)
8114c6d8:	10c00104 	addi	r3,r2,4
8114c6dc:	e0fffe15 	stw	r3,-8(fp)
8114c6e0:	10800017 	ldw	r2,0(r2)
8114c6e4:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
8114c6e8:	e13ffd17 	ldw	r4,-12(fp)
8114c6ec:	114c86c0 	call	8114c86c <alt_putchar>
8114c6f0:	00004f06 	br	8114c830 <alt_printf+0x1f8>
                }
                else if (c == 'x')
8114c6f4:	e0bff807 	ldb	r2,-32(fp)
8114c6f8:	10801e18 	cmpnei	r2,r2,120
8114c6fc:	1000341e 	bne	r2,zero,8114c7d0 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
8114c700:	e0bffe17 	ldw	r2,-8(fp)
8114c704:	10c00104 	addi	r3,r2,4
8114c708:	e0fffe15 	stw	r3,-8(fp)
8114c70c:	10800017 	ldw	r2,0(r2)
8114c710:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
8114c714:	e0bffb17 	ldw	r2,-20(fp)
8114c718:	1000031e 	bne	r2,zero,8114c728 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
8114c71c:	01000c04 	movi	r4,48
8114c720:	114c86c0 	call	8114c86c <alt_putchar>
                        continue;
8114c724:	00004206 	br	8114c830 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
8114c728:	00800704 	movi	r2,28
8114c72c:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
8114c730:	00000306 	br	8114c740 <alt_printf+0x108>
                        digit_shift -= 4;
8114c734:	e0bff917 	ldw	r2,-28(fp)
8114c738:	10bfff04 	addi	r2,r2,-4
8114c73c:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
8114c740:	00c003c4 	movi	r3,15
8114c744:	e0bff917 	ldw	r2,-28(fp)
8114c748:	1884983a 	sll	r2,r3,r2
8114c74c:	1007883a 	mov	r3,r2
8114c750:	e0bffb17 	ldw	r2,-20(fp)
8114c754:	1884703a 	and	r2,r3,r2
8114c758:	103ff626 	beq	r2,zero,8114c734 <__reset+0xfb12c734>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114c75c:	00001906 	br	8114c7c4 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
8114c760:	00c003c4 	movi	r3,15
8114c764:	e0bff917 	ldw	r2,-28(fp)
8114c768:	1884983a 	sll	r2,r3,r2
8114c76c:	1007883a 	mov	r3,r2
8114c770:	e0bffb17 	ldw	r2,-20(fp)
8114c774:	1886703a 	and	r3,r3,r2
8114c778:	e0bff917 	ldw	r2,-28(fp)
8114c77c:	1884d83a 	srl	r2,r3,r2
8114c780:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
8114c784:	e0bffc17 	ldw	r2,-16(fp)
8114c788:	108002a8 	cmpgeui	r2,r2,10
8114c78c:	1000041e 	bne	r2,zero,8114c7a0 <alt_printf+0x168>
                            c = '0' + digit;
8114c790:	e0bffc17 	ldw	r2,-16(fp)
8114c794:	10800c04 	addi	r2,r2,48
8114c798:	e0bff805 	stb	r2,-32(fp)
8114c79c:	00000306 	br	8114c7ac <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
8114c7a0:	e0bffc17 	ldw	r2,-16(fp)
8114c7a4:	108015c4 	addi	r2,r2,87
8114c7a8:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
8114c7ac:	e0bff807 	ldb	r2,-32(fp)
8114c7b0:	1009883a 	mov	r4,r2
8114c7b4:	114c86c0 	call	8114c86c <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114c7b8:	e0bff917 	ldw	r2,-28(fp)
8114c7bc:	10bfff04 	addi	r2,r2,-4
8114c7c0:	e0bff915 	stw	r2,-28(fp)
8114c7c4:	e0bff917 	ldw	r2,-28(fp)
8114c7c8:	103fe50e 	bge	r2,zero,8114c760 <__reset+0xfb12c760>
8114c7cc:	00001806 	br	8114c830 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
8114c7d0:	e0bff807 	ldb	r2,-32(fp)
8114c7d4:	10801cd8 	cmpnei	r2,r2,115
8114c7d8:	1000151e 	bne	r2,zero,8114c830 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
8114c7dc:	e0bffe17 	ldw	r2,-8(fp)
8114c7e0:	10c00104 	addi	r3,r2,4
8114c7e4:	e0fffe15 	stw	r3,-8(fp)
8114c7e8:	10800017 	ldw	r2,0(r2)
8114c7ec:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
8114c7f0:	00000906 	br	8114c818 <alt_printf+0x1e0>
                      alt_putchar(*s++);
8114c7f4:	e0bffa17 	ldw	r2,-24(fp)
8114c7f8:	10c00044 	addi	r3,r2,1
8114c7fc:	e0fffa15 	stw	r3,-24(fp)
8114c800:	10800003 	ldbu	r2,0(r2)
8114c804:	10803fcc 	andi	r2,r2,255
8114c808:	1080201c 	xori	r2,r2,128
8114c80c:	10bfe004 	addi	r2,r2,-128
8114c810:	1009883a 	mov	r4,r2
8114c814:	114c86c0 	call	8114c86c <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
8114c818:	e0bffa17 	ldw	r2,-24(fp)
8114c81c:	10800003 	ldbu	r2,0(r2)
8114c820:	10803fcc 	andi	r2,r2,255
8114c824:	1080201c 	xori	r2,r2,128
8114c828:	10bfe004 	addi	r2,r2,-128
8114c82c:	103ff11e 	bne	r2,zero,8114c7f4 <__reset+0xfb12c7f4>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
8114c830:	e0bff717 	ldw	r2,-36(fp)
8114c834:	10c00044 	addi	r3,r2,1
8114c838:	e0fff715 	stw	r3,-36(fp)
8114c83c:	10800003 	ldbu	r2,0(r2)
8114c840:	e0bff805 	stb	r2,-32(fp)
8114c844:	e0bff807 	ldb	r2,-32(fp)
8114c848:	103f8a1e 	bne	r2,zero,8114c674 <__reset+0xfb12c674>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114c84c:	00000106 	br	8114c854 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
8114c850:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114c854:	0001883a 	nop
8114c858:	e037883a 	mov	sp,fp
8114c85c:	dfc00117 	ldw	ra,4(sp)
8114c860:	df000017 	ldw	fp,0(sp)
8114c864:	dec00504 	addi	sp,sp,20
8114c868:	f800283a 	ret

8114c86c <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
8114c86c:	defffd04 	addi	sp,sp,-12
8114c870:	de00012e 	bgeu	sp,et,8114c878 <alt_putchar+0xc>
8114c874:	003b68fa 	trap	3
8114c878:	dfc00215 	stw	ra,8(sp)
8114c87c:	df000115 	stw	fp,4(sp)
8114c880:	df000104 	addi	fp,sp,4
8114c884:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
8114c888:	d0a00517 	ldw	r2,-32748(gp)
8114c88c:	10800217 	ldw	r2,8(r2)
8114c890:	100b883a 	mov	r5,r2
8114c894:	e13fff17 	ldw	r4,-4(fp)
8114c898:	11246d80 	call	811246d8 <putc>
#endif
#endif
}
8114c89c:	e037883a 	mov	sp,fp
8114c8a0:	dfc00117 	ldw	ra,4(sp)
8114c8a4:	df000017 	ldw	fp,0(sp)
8114c8a8:	dec00204 	addi	sp,sp,8
8114c8ac:	f800283a 	ret

8114c8b0 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
8114c8b0:	deffff04 	addi	sp,sp,-4
8114c8b4:	de00012e 	bgeu	sp,et,8114c8bc <altera_nios2_gen2_irq_init+0xc>
8114c8b8:	003b68fa 	trap	3
8114c8bc:	df000015 	stw	fp,0(sp)
8114c8c0:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
8114c8c4:	000170fa 	wrctl	ienable,zero
}
8114c8c8:	0001883a 	nop
8114c8cc:	e037883a 	mov	sp,fp
8114c8d0:	df000017 	ldw	fp,0(sp)
8114c8d4:	dec00104 	addi	sp,sp,4
8114c8d8:	f800283a 	ret

8114c8dc <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
8114c8dc:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
8114c8e0:	de002436 	bltu	sp,et,8114c974 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
8114c8e4:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
8114c8e8:	d120a217 	ldw	r4,-32120(gp)

      stw ra,  0(sp)
8114c8ec:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
8114c8f0:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
8114c8f4:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
8114c8f8:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
8114c8fc:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
8114c900:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
8114c904:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
8114c908:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
8114c90c:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
8114c910:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
8114c914:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
8114c918:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114c91c:	114cb780 	call	8114cb78 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
8114c920:	d1209c17 	ldw	r4,-32144(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
8114c924:	d1609387 	ldb	r5,-32178(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
8114c928:	d120a215 	stw	r4,-32120(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
8114c92c:	d16093c5 	stb	r5,-32177(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
8114c930:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
8114c934:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
8114c938:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
8114c93c:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
8114c940:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
8114c944:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
8114c948:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
8114c94c:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
8114c950:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
8114c954:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
8114c958:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
8114c95c:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
8114c960:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
8114c964:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
8114c968:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
8114c96c:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
8114c970:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
8114c974:	003da0fa 	break	3

8114c978 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
8114c978:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
8114c97c:	047fff84 	movi	r17,-2
      and   r18, r18, r17
8114c980:	9464703a 	and	r18,r18,r17
      wrctl status, r18
8114c984:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114c988:	114cb780 	call	8114cb78 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
8114c98c:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
8114c990:	d4a09105 	stb	r18,-32188(gp)

      /*
       * start execution of the new task.
       */

      br 9b
8114c994:	003fe206 	br	8114c920 <__reset+0xfb12c920>

8114c998 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
8114c998:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
8114c99c:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
8114c9a0:	10800054 	ori	r2,r2,1
      wrctl status, r2
8114c9a4:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
8114c9a8:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
8114c9ac:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
8114c9b0:	dec00204 	addi	sp,sp,8

      callr r2
8114c9b4:	103ee83a 	callr	r2

      nop
8114c9b8:	0001883a 	nop

8114c9bc <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
8114c9bc:	defff704 	addi	sp,sp,-36
8114c9c0:	de00012e 	bgeu	sp,et,8114c9c8 <OSTaskStkInit+0xc>
8114c9c4:	003b68fa 	trap	3
8114c9c8:	dfc00815 	stw	ra,32(sp)
8114c9cc:	df000715 	stw	fp,28(sp)
8114c9d0:	df000704 	addi	fp,sp,28
8114c9d4:	e13ffc15 	stw	r4,-16(fp)
8114c9d8:	e17ffd15 	stw	r5,-12(fp)
8114c9dc:	e1bffe15 	stw	r6,-8(fp)
8114c9e0:	3805883a 	mov	r2,r7
8114c9e4:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
8114c9e8:	e0fffe17 	ldw	r3,-8(fp)
8114c9ec:	00bfff04 	movi	r2,-4
8114c9f0:	1884703a 	and	r2,r3,r2
8114c9f4:	10bef704 	addi	r2,r2,-1060
8114c9f8:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
8114c9fc:	01810904 	movi	r6,1060
8114ca00:	000b883a 	mov	r5,zero
8114ca04:	e13ff917 	ldw	r4,-28(fp)
8114ca08:	11244a00 	call	811244a0 <memset>
8114ca0c:	e0bff917 	ldw	r2,-28(fp)
8114ca10:	10c0bb04 	addi	r3,r2,748
8114ca14:	e0bff917 	ldw	r2,-28(fp)
8114ca18:	10c00115 	stw	r3,4(r2)
8114ca1c:	e0bff917 	ldw	r2,-28(fp)
8114ca20:	10c0d504 	addi	r3,r2,852
8114ca24:	e0bff917 	ldw	r2,-28(fp)
8114ca28:	10c00215 	stw	r3,8(r2)
8114ca2c:	e0bff917 	ldw	r2,-28(fp)
8114ca30:	10c0ef04 	addi	r3,r2,956
8114ca34:	e0bff917 	ldw	r2,-28(fp)
8114ca38:	10c00315 	stw	r3,12(r2)
8114ca3c:	e0fff917 	ldw	r3,-28(fp)
8114ca40:	00a04574 	movhi	r2,33045
8114ca44:	108be104 	addi	r2,r2,12164
8114ca48:	18800d15 	stw	r2,52(r3)
8114ca4c:	e0bff917 	ldw	r2,-28(fp)
8114ca50:	00c00044 	movi	r3,1
8114ca54:	10c02915 	stw	r3,164(r2)
8114ca58:	10002a15 	stw	zero,168(r2)
8114ca5c:	e0bff917 	ldw	r2,-28(fp)
8114ca60:	00ccc384 	movi	r3,13070
8114ca64:	10c02b0d 	sth	r3,172(r2)
8114ca68:	e0bff917 	ldw	r2,-28(fp)
8114ca6c:	00eaf344 	movi	r3,-21555
8114ca70:	10c02b8d 	sth	r3,174(r2)
8114ca74:	e0bff917 	ldw	r2,-28(fp)
8114ca78:	00c48d04 	movi	r3,4660
8114ca7c:	10c02c0d 	sth	r3,176(r2)
8114ca80:	e0bff917 	ldw	r2,-28(fp)
8114ca84:	00f99b44 	movi	r3,-6547
8114ca88:	10c02c8d 	sth	r3,178(r2)
8114ca8c:	e0bff917 	ldw	r2,-28(fp)
8114ca90:	00f7bb04 	movi	r3,-8468
8114ca94:	10c02d0d 	sth	r3,180(r2)
8114ca98:	e0bff917 	ldw	r2,-28(fp)
8114ca9c:	00c00144 	movi	r3,5
8114caa0:	10c02d8d 	sth	r3,182(r2)
8114caa4:	e0bff917 	ldw	r2,-28(fp)
8114caa8:	00c002c4 	movi	r3,11
8114caac:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
8114cab0:	e0bff917 	ldw	r2,-28(fp)
8114cab4:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
8114cab8:	e0bffa17 	ldw	r2,-24(fp)
8114cabc:	10bff304 	addi	r2,r2,-52
8114cac0:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
8114cac4:	e0bffb17 	ldw	r2,-20(fp)
8114cac8:	10800c04 	addi	r2,r2,48
8114cacc:	e0fffc17 	ldw	r3,-16(fp)
8114cad0:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
8114cad4:	e0bffb17 	ldw	r2,-20(fp)
8114cad8:	10800b04 	addi	r2,r2,44
8114cadc:	e0fffd17 	ldw	r3,-12(fp)
8114cae0:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
8114cae4:	e0bffb17 	ldw	r2,-20(fp)
8114cae8:	10800a04 	addi	r2,r2,40
8114caec:	e0fff917 	ldw	r3,-28(fp)
8114caf0:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
8114caf4:	00a04574 	movhi	r2,33045
8114caf8:	10b26604 	addi	r2,r2,-13928
8114cafc:	10c00104 	addi	r3,r2,4
8114cb00:	e0bffb17 	ldw	r2,-20(fp)
8114cb04:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
8114cb08:	e0bffb17 	ldw	r2,-20(fp)
}
8114cb0c:	e037883a 	mov	sp,fp
8114cb10:	dfc00117 	ldw	ra,4(sp)
8114cb14:	df000017 	ldw	fp,0(sp)
8114cb18:	dec00204 	addi	sp,sp,8
8114cb1c:	f800283a 	ret

8114cb20 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
8114cb20:	defffe04 	addi	sp,sp,-8
8114cb24:	de00012e 	bgeu	sp,et,8114cb2c <OSTaskCreateHook+0xc>
8114cb28:	003b68fa 	trap	3
8114cb2c:	df000115 	stw	fp,4(sp)
8114cb30:	df000104 	addi	fp,sp,4
8114cb34:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
8114cb38:	0001883a 	nop
8114cb3c:	e037883a 	mov	sp,fp
8114cb40:	df000017 	ldw	fp,0(sp)
8114cb44:	dec00104 	addi	sp,sp,4
8114cb48:	f800283a 	ret

8114cb4c <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
8114cb4c:	defffe04 	addi	sp,sp,-8
8114cb50:	de00012e 	bgeu	sp,et,8114cb58 <OSTaskDelHook+0xc>
8114cb54:	003b68fa 	trap	3
8114cb58:	df000115 	stw	fp,4(sp)
8114cb5c:	df000104 	addi	fp,sp,4
8114cb60:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
8114cb64:	0001883a 	nop
8114cb68:	e037883a 	mov	sp,fp
8114cb6c:	df000017 	ldw	fp,0(sp)
8114cb70:	dec00104 	addi	sp,sp,4
8114cb74:	f800283a 	ret

8114cb78 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
8114cb78:	deffff04 	addi	sp,sp,-4
8114cb7c:	de00012e 	bgeu	sp,et,8114cb84 <OSTaskSwHook+0xc>
8114cb80:	003b68fa 	trap	3
8114cb84:	df000015 	stw	fp,0(sp)
8114cb88:	d839883a 	mov	fp,sp
}
8114cb8c:	0001883a 	nop
8114cb90:	e037883a 	mov	sp,fp
8114cb94:	df000017 	ldw	fp,0(sp)
8114cb98:	dec00104 	addi	sp,sp,4
8114cb9c:	f800283a 	ret

8114cba0 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
8114cba0:	deffff04 	addi	sp,sp,-4
8114cba4:	de00012e 	bgeu	sp,et,8114cbac <OSTaskStatHook+0xc>
8114cba8:	003b68fa 	trap	3
8114cbac:	df000015 	stw	fp,0(sp)
8114cbb0:	d839883a 	mov	fp,sp
}
8114cbb4:	0001883a 	nop
8114cbb8:	e037883a 	mov	sp,fp
8114cbbc:	df000017 	ldw	fp,0(sp)
8114cbc0:	dec00104 	addi	sp,sp,4
8114cbc4:	f800283a 	ret

8114cbc8 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
8114cbc8:	defffe04 	addi	sp,sp,-8
8114cbcc:	de00012e 	bgeu	sp,et,8114cbd4 <OSTimeTickHook+0xc>
8114cbd0:	003b68fa 	trap	3
8114cbd4:	dfc00115 	stw	ra,4(sp)
8114cbd8:	df000015 	stw	fp,0(sp)
8114cbdc:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
8114cbe0:	d0a0b60b 	ldhu	r2,-32040(gp)
8114cbe4:	10800044 	addi	r2,r2,1
8114cbe8:	d0a0b60d 	sth	r2,-32040(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
8114cbec:	d0a0b60b 	ldhu	r2,-32040(gp)
8114cbf0:	10bfffcc 	andi	r2,r2,65535
8114cbf4:	10807d30 	cmpltui	r2,r2,500
8114cbf8:	1000021e 	bne	r2,zero,8114cc04 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
8114cbfc:	d020b60d 	sth	zero,-32040(gp)
        OSTmrSignal();
8114cc00:	11435180 	call	81143518 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
8114cc04:	0001883a 	nop
8114cc08:	e037883a 	mov	sp,fp
8114cc0c:	dfc00117 	ldw	ra,4(sp)
8114cc10:	df000017 	ldw	fp,0(sp)
8114cc14:	dec00204 	addi	sp,sp,8
8114cc18:	f800283a 	ret

8114cc1c <OSInitHookBegin>:

void OSInitHookBegin(void)
{
8114cc1c:	deffff04 	addi	sp,sp,-4
8114cc20:	de00012e 	bgeu	sp,et,8114cc28 <OSInitHookBegin+0xc>
8114cc24:	003b68fa 	trap	3
8114cc28:	df000015 	stw	fp,0(sp)
8114cc2c:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
8114cc30:	d020b60d 	sth	zero,-32040(gp)
#endif
}
8114cc34:	0001883a 	nop
8114cc38:	e037883a 	mov	sp,fp
8114cc3c:	df000017 	ldw	fp,0(sp)
8114cc40:	dec00104 	addi	sp,sp,4
8114cc44:	f800283a 	ret

8114cc48 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
8114cc48:	deffff04 	addi	sp,sp,-4
8114cc4c:	de00012e 	bgeu	sp,et,8114cc54 <OSInitHookEnd+0xc>
8114cc50:	003b68fa 	trap	3
8114cc54:	df000015 	stw	fp,0(sp)
8114cc58:	d839883a 	mov	fp,sp
}
8114cc5c:	0001883a 	nop
8114cc60:	e037883a 	mov	sp,fp
8114cc64:	df000017 	ldw	fp,0(sp)
8114cc68:	dec00104 	addi	sp,sp,4
8114cc6c:	f800283a 	ret

8114cc70 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
8114cc70:	deffff04 	addi	sp,sp,-4
8114cc74:	de00012e 	bgeu	sp,et,8114cc7c <OSTaskIdleHook+0xc>
8114cc78:	003b68fa 	trap	3
8114cc7c:	df000015 	stw	fp,0(sp)
8114cc80:	d839883a 	mov	fp,sp
}
8114cc84:	0001883a 	nop
8114cc88:	e037883a 	mov	sp,fp
8114cc8c:	df000017 	ldw	fp,0(sp)
8114cc90:	dec00104 	addi	sp,sp,4
8114cc94:	f800283a 	ret

8114cc98 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
8114cc98:	defffe04 	addi	sp,sp,-8
8114cc9c:	de00012e 	bgeu	sp,et,8114cca4 <OSTCBInitHook+0xc>
8114cca0:	003b68fa 	trap	3
8114cca4:	df000115 	stw	fp,4(sp)
8114cca8:	df000104 	addi	fp,sp,4
8114ccac:	e13fff15 	stw	r4,-4(fp)
}
8114ccb0:	0001883a 	nop
8114ccb4:	e037883a 	mov	sp,fp
8114ccb8:	df000017 	ldw	fp,0(sp)
8114ccbc:	dec00104 	addi	sp,sp,4
8114ccc0:	f800283a 	ret

8114ccc4 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
8114ccc4:	defffe04 	addi	sp,sp,-8
8114ccc8:	de00012e 	bgeu	sp,et,8114ccd0 <alt_exception_cause_generated_bad_addr+0xc>
8114cccc:	003b68fa 	trap	3
8114ccd0:	df000115 	stw	fp,4(sp)
8114ccd4:	df000104 	addi	fp,sp,4
8114ccd8:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
8114ccdc:	e0bfff17 	ldw	r2,-4(fp)
8114cce0:	10bffe84 	addi	r2,r2,-6
8114cce4:	10c00428 	cmpgeui	r3,r2,16
8114cce8:	18001a1e 	bne	r3,zero,8114cd54 <alt_exception_cause_generated_bad_addr+0x90>
8114ccec:	100690ba 	slli	r3,r2,2
8114ccf0:	00a04574 	movhi	r2,33045
8114ccf4:	10b34104 	addi	r2,r2,-13052
8114ccf8:	1885883a 	add	r2,r3,r2
8114ccfc:	10800017 	ldw	r2,0(r2)
8114cd00:	1000683a 	jmp	r2
8114cd04:	8114cd44 	addi	r4,r16,21301
8114cd08:	8114cd44 	addi	r4,r16,21301
8114cd0c:	8114cd54 	ori	r4,r16,21301
8114cd10:	8114cd54 	ori	r4,r16,21301
8114cd14:	8114cd54 	ori	r4,r16,21301
8114cd18:	8114cd44 	addi	r4,r16,21301
8114cd1c:	8114cd4c 	andi	r4,r16,21301
8114cd20:	8114cd54 	ori	r4,r16,21301
8114cd24:	8114cd44 	addi	r4,r16,21301
8114cd28:	8114cd44 	addi	r4,r16,21301
8114cd2c:	8114cd54 	ori	r4,r16,21301
8114cd30:	8114cd44 	addi	r4,r16,21301
8114cd34:	8114cd4c 	andi	r4,r16,21301
8114cd38:	8114cd54 	ori	r4,r16,21301
8114cd3c:	8114cd54 	ori	r4,r16,21301
8114cd40:	8114cd44 	addi	r4,r16,21301
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
8114cd44:	00800044 	movi	r2,1
8114cd48:	00000306 	br	8114cd58 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
8114cd4c:	0005883a 	mov	r2,zero
8114cd50:	00000106 	br	8114cd58 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
8114cd54:	0005883a 	mov	r2,zero
  }
}
8114cd58:	e037883a 	mov	sp,fp
8114cd5c:	df000017 	ldw	fp,0(sp)
8114cd60:	dec00104 	addi	sp,sp,4
8114cd64:	f800283a 	ret

8114cd68 <exit>:
8114cd68:	defffe04 	addi	sp,sp,-8
8114cd6c:	000b883a 	mov	r5,zero
8114cd70:	de00012e 	bgeu	sp,et,8114cd78 <exit+0x10>
8114cd74:	003b68fa 	trap	3
8114cd78:	dc000015 	stw	r16,0(sp)
8114cd7c:	dfc00115 	stw	ra,4(sp)
8114cd80:	2021883a 	mov	r16,r4
8114cd84:	114cf100 	call	8114cf10 <__call_exitprocs>
8114cd88:	00a04574 	movhi	r2,33045
8114cd8c:	10935f04 	addi	r2,r2,19836
8114cd90:	11000017 	ldw	r4,0(r2)
8114cd94:	20800f17 	ldw	r2,60(r4)
8114cd98:	10000126 	beq	r2,zero,8114cda0 <exit+0x38>
8114cd9c:	103ee83a 	callr	r2
8114cda0:	8009883a 	mov	r4,r16
8114cda4:	114d0980 	call	8114d098 <_exit>

8114cda8 <memcmp>:
8114cda8:	01c000c4 	movi	r7,3
8114cdac:	3980192e 	bgeu	r7,r6,8114ce14 <memcmp+0x6c>
8114cdb0:	2144b03a 	or	r2,r4,r5
8114cdb4:	11c4703a 	and	r2,r2,r7
8114cdb8:	10000f26 	beq	r2,zero,8114cdf8 <memcmp+0x50>
8114cdbc:	20800003 	ldbu	r2,0(r4)
8114cdc0:	28c00003 	ldbu	r3,0(r5)
8114cdc4:	10c0151e 	bne	r2,r3,8114ce1c <memcmp+0x74>
8114cdc8:	31bfff84 	addi	r6,r6,-2
8114cdcc:	01ffffc4 	movi	r7,-1
8114cdd0:	00000406 	br	8114cde4 <memcmp+0x3c>
8114cdd4:	20800003 	ldbu	r2,0(r4)
8114cdd8:	28c00003 	ldbu	r3,0(r5)
8114cddc:	31bfffc4 	addi	r6,r6,-1
8114cde0:	10c00e1e 	bne	r2,r3,8114ce1c <memcmp+0x74>
8114cde4:	21000044 	addi	r4,r4,1
8114cde8:	29400044 	addi	r5,r5,1
8114cdec:	31fff91e 	bne	r6,r7,8114cdd4 <__reset+0xfb12cdd4>
8114cdf0:	0005883a 	mov	r2,zero
8114cdf4:	f800283a 	ret
8114cdf8:	20c00017 	ldw	r3,0(r4)
8114cdfc:	28800017 	ldw	r2,0(r5)
8114ce00:	18bfee1e 	bne	r3,r2,8114cdbc <__reset+0xfb12cdbc>
8114ce04:	31bfff04 	addi	r6,r6,-4
8114ce08:	21000104 	addi	r4,r4,4
8114ce0c:	29400104 	addi	r5,r5,4
8114ce10:	39bff936 	bltu	r7,r6,8114cdf8 <__reset+0xfb12cdf8>
8114ce14:	303fe91e 	bne	r6,zero,8114cdbc <__reset+0xfb12cdbc>
8114ce18:	003ff506 	br	8114cdf0 <__reset+0xfb12cdf0>
8114ce1c:	10c5c83a 	sub	r2,r2,r3
8114ce20:	f800283a 	ret

8114ce24 <strncpy>:
8114ce24:	2906b03a 	or	r3,r5,r4
8114ce28:	18c000cc 	andi	r3,r3,3
8114ce2c:	2005883a 	mov	r2,r4
8114ce30:	18002c1e 	bne	r3,zero,8114cee4 <strncpy+0xc0>
8114ce34:	010000c4 	movi	r4,3
8114ce38:	21802a2e 	bgeu	r4,r6,8114cee4 <strncpy+0xc0>
8114ce3c:	033fbff4 	movhi	r12,65279
8114ce40:	02e02074 	movhi	r11,32897
8114ce44:	633fbfc4 	addi	r12,r12,-257
8114ce48:	5ae02004 	addi	r11,r11,-32640
8114ce4c:	100f883a 	mov	r7,r2
8114ce50:	2a000017 	ldw	r8,0(r5)
8114ce54:	3815883a 	mov	r10,r7
8114ce58:	4313883a 	add	r9,r8,r12
8114ce5c:	0206303a 	nor	r3,zero,r8
8114ce60:	48c6703a 	and	r3,r9,r3
8114ce64:	1ac6703a 	and	r3,r3,r11
8114ce68:	1800261e 	bne	r3,zero,8114cf04 <strncpy+0xe0>
8114ce6c:	39c00104 	addi	r7,r7,4
8114ce70:	52000015 	stw	r8,0(r10)
8114ce74:	31bfff04 	addi	r6,r6,-4
8114ce78:	3811883a 	mov	r8,r7
8114ce7c:	29400104 	addi	r5,r5,4
8114ce80:	21bff336 	bltu	r4,r6,8114ce50 <__reset+0xfb12ce50>
8114ce84:	30001e26 	beq	r6,zero,8114cf00 <strncpy+0xdc>
8114ce88:	29c00003 	ldbu	r7,0(r5)
8114ce8c:	31bfffc4 	addi	r6,r6,-1
8114ce90:	40c00044 	addi	r3,r8,1
8114ce94:	41c00005 	stb	r7,0(r8)
8114ce98:	39c03fcc 	andi	r7,r7,255
8114ce9c:	39c0201c 	xori	r7,r7,128
8114cea0:	39ffe004 	addi	r7,r7,-128
8114cea4:	29400044 	addi	r5,r5,1
8114cea8:	38001026 	beq	r7,zero,8114ceec <strncpy+0xc8>
8114ceac:	1811883a 	mov	r8,r3
8114ceb0:	00000906 	br	8114ced8 <strncpy+0xb4>
8114ceb4:	29c00003 	ldbu	r7,0(r5)
8114ceb8:	31bfffc4 	addi	r6,r6,-1
8114cebc:	29400044 	addi	r5,r5,1
8114cec0:	41c00005 	stb	r7,0(r8)
8114cec4:	39c03fcc 	andi	r7,r7,255
8114cec8:	39c0201c 	xori	r7,r7,128
8114cecc:	39ffe004 	addi	r7,r7,-128
8114ced0:	1811883a 	mov	r8,r3
8114ced4:	38000526 	beq	r7,zero,8114ceec <strncpy+0xc8>
8114ced8:	18c00044 	addi	r3,r3,1
8114cedc:	303ff51e 	bne	r6,zero,8114ceb4 <__reset+0xfb12ceb4>
8114cee0:	f800283a 	ret
8114cee4:	1011883a 	mov	r8,r2
8114cee8:	003fe606 	br	8114ce84 <__reset+0xfb12ce84>
8114ceec:	30000726 	beq	r6,zero,8114cf0c <strncpy+0xe8>
8114cef0:	198d883a 	add	r6,r3,r6
8114cef4:	18000005 	stb	zero,0(r3)
8114cef8:	18c00044 	addi	r3,r3,1
8114cefc:	19bffd1e 	bne	r3,r6,8114cef4 <__reset+0xfb12cef4>
8114cf00:	f800283a 	ret
8114cf04:	3811883a 	mov	r8,r7
8114cf08:	003fdf06 	br	8114ce88 <__reset+0xfb12ce88>
8114cf0c:	f800283a 	ret

8114cf10 <__call_exitprocs>:
8114cf10:	defff504 	addi	sp,sp,-44
8114cf14:	de00012e 	bgeu	sp,et,8114cf1c <__call_exitprocs+0xc>
8114cf18:	003b68fa 	trap	3
8114cf1c:	df000915 	stw	fp,36(sp)
8114cf20:	dd400615 	stw	r21,24(sp)
8114cf24:	dc800315 	stw	r18,12(sp)
8114cf28:	dfc00a15 	stw	ra,40(sp)
8114cf2c:	ddc00815 	stw	r23,32(sp)
8114cf30:	dd800715 	stw	r22,28(sp)
8114cf34:	dd000515 	stw	r20,20(sp)
8114cf38:	dcc00415 	stw	r19,16(sp)
8114cf3c:	dc400215 	stw	r17,8(sp)
8114cf40:	dc000115 	stw	r16,4(sp)
8114cf44:	d9000015 	stw	r4,0(sp)
8114cf48:	2839883a 	mov	fp,r5
8114cf4c:	04800044 	movi	r18,1
8114cf50:	057fffc4 	movi	r21,-1
8114cf54:	00a04574 	movhi	r2,33045
8114cf58:	10935f04 	addi	r2,r2,19836
8114cf5c:	12000017 	ldw	r8,0(r2)
8114cf60:	45005217 	ldw	r20,328(r8)
8114cf64:	44c05204 	addi	r19,r8,328
8114cf68:	a0001c26 	beq	r20,zero,8114cfdc <__call_exitprocs+0xcc>
8114cf6c:	a0800117 	ldw	r2,4(r20)
8114cf70:	15ffffc4 	addi	r23,r2,-1
8114cf74:	b8000d16 	blt	r23,zero,8114cfac <__call_exitprocs+0x9c>
8114cf78:	14000044 	addi	r16,r2,1
8114cf7c:	8421883a 	add	r16,r16,r16
8114cf80:	8421883a 	add	r16,r16,r16
8114cf84:	84402004 	addi	r17,r16,128
8114cf88:	a463883a 	add	r17,r20,r17
8114cf8c:	a421883a 	add	r16,r20,r16
8114cf90:	e0001e26 	beq	fp,zero,8114d00c <__call_exitprocs+0xfc>
8114cf94:	80804017 	ldw	r2,256(r16)
8114cf98:	e0801c26 	beq	fp,r2,8114d00c <__call_exitprocs+0xfc>
8114cf9c:	bdffffc4 	addi	r23,r23,-1
8114cfa0:	843fff04 	addi	r16,r16,-4
8114cfa4:	8c7fff04 	addi	r17,r17,-4
8114cfa8:	bd7ff91e 	bne	r23,r21,8114cf90 <__reset+0xfb12cf90>
8114cfac:	00800034 	movhi	r2,0
8114cfb0:	10800004 	addi	r2,r2,0
8114cfb4:	10000926 	beq	r2,zero,8114cfdc <__call_exitprocs+0xcc>
8114cfb8:	a0800117 	ldw	r2,4(r20)
8114cfbc:	1000301e 	bne	r2,zero,8114d080 <__call_exitprocs+0x170>
8114cfc0:	a0800017 	ldw	r2,0(r20)
8114cfc4:	10003226 	beq	r2,zero,8114d090 <__call_exitprocs+0x180>
8114cfc8:	a009883a 	mov	r4,r20
8114cfcc:	98800015 	stw	r2,0(r19)
8114cfd0:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8114cfd4:	9d000017 	ldw	r20,0(r19)
8114cfd8:	a03fe41e 	bne	r20,zero,8114cf6c <__reset+0xfb12cf6c>
8114cfdc:	dfc00a17 	ldw	ra,40(sp)
8114cfe0:	df000917 	ldw	fp,36(sp)
8114cfe4:	ddc00817 	ldw	r23,32(sp)
8114cfe8:	dd800717 	ldw	r22,28(sp)
8114cfec:	dd400617 	ldw	r21,24(sp)
8114cff0:	dd000517 	ldw	r20,20(sp)
8114cff4:	dcc00417 	ldw	r19,16(sp)
8114cff8:	dc800317 	ldw	r18,12(sp)
8114cffc:	dc400217 	ldw	r17,8(sp)
8114d000:	dc000117 	ldw	r16,4(sp)
8114d004:	dec00b04 	addi	sp,sp,44
8114d008:	f800283a 	ret
8114d00c:	a0800117 	ldw	r2,4(r20)
8114d010:	80c00017 	ldw	r3,0(r16)
8114d014:	10bfffc4 	addi	r2,r2,-1
8114d018:	15c01426 	beq	r2,r23,8114d06c <__call_exitprocs+0x15c>
8114d01c:	80000015 	stw	zero,0(r16)
8114d020:	183fde26 	beq	r3,zero,8114cf9c <__reset+0xfb12cf9c>
8114d024:	95c8983a 	sll	r4,r18,r23
8114d028:	a0806217 	ldw	r2,392(r20)
8114d02c:	a5800117 	ldw	r22,4(r20)
8114d030:	2084703a 	and	r2,r4,r2
8114d034:	10000b26 	beq	r2,zero,8114d064 <__call_exitprocs+0x154>
8114d038:	a0806317 	ldw	r2,396(r20)
8114d03c:	2088703a 	and	r4,r4,r2
8114d040:	20000c1e 	bne	r4,zero,8114d074 <__call_exitprocs+0x164>
8114d044:	89400017 	ldw	r5,0(r17)
8114d048:	d9000017 	ldw	r4,0(sp)
8114d04c:	183ee83a 	callr	r3
8114d050:	a0800117 	ldw	r2,4(r20)
8114d054:	15bfbf1e 	bne	r2,r22,8114cf54 <__reset+0xfb12cf54>
8114d058:	98800017 	ldw	r2,0(r19)
8114d05c:	153fcf26 	beq	r2,r20,8114cf9c <__reset+0xfb12cf9c>
8114d060:	003fbc06 	br	8114cf54 <__reset+0xfb12cf54>
8114d064:	183ee83a 	callr	r3
8114d068:	003ff906 	br	8114d050 <__reset+0xfb12d050>
8114d06c:	a5c00115 	stw	r23,4(r20)
8114d070:	003feb06 	br	8114d020 <__reset+0xfb12d020>
8114d074:	89000017 	ldw	r4,0(r17)
8114d078:	183ee83a 	callr	r3
8114d07c:	003ff406 	br	8114d050 <__reset+0xfb12d050>
8114d080:	a0800017 	ldw	r2,0(r20)
8114d084:	a027883a 	mov	r19,r20
8114d088:	1029883a 	mov	r20,r2
8114d08c:	003fb606 	br	8114cf68 <__reset+0xfb12cf68>
8114d090:	0005883a 	mov	r2,zero
8114d094:	003ffb06 	br	8114d084 <__reset+0xfb12d084>

8114d098 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
8114d098:	defffc04 	addi	sp,sp,-16
8114d09c:	de00012e 	bgeu	sp,et,8114d0a4 <_exit+0xc>
8114d0a0:	003b68fa 	trap	3
8114d0a4:	dfc00315 	stw	ra,12(sp)
8114d0a8:	df000215 	stw	fp,8(sp)
8114d0ac:	df000204 	addi	fp,sp,8
8114d0b0:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
8114d0b4:	d0a01217 	ldw	r2,-32696(gp)
8114d0b8:	10800058 	cmpnei	r2,r2,1
8114d0bc:	1000031e 	bne	r2,zero,8114d0cc <_exit+0x34>
8114d0c0:	01204574 	movhi	r4,33045
8114d0c4:	210be204 	addi	r4,r4,12168
8114d0c8:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
8114d0cc:	d0a01217 	ldw	r2,-32696(gp)
8114d0d0:	10800058 	cmpnei	r2,r2,1
8114d0d4:	1000041e 	bne	r2,zero,8114d0e8 <_exit+0x50>
8114d0d8:	e17fff17 	ldw	r5,-4(fp)
8114d0dc:	01204574 	movhi	r4,33045
8114d0e0:	210bed04 	addi	r4,r4,12212
8114d0e4:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
8114d0e8:	d0a01217 	ldw	r2,-32696(gp)
8114d0ec:	10800058 	cmpnei	r2,r2,1
8114d0f0:	1000031e 	bne	r2,zero,8114d100 <_exit+0x68>
8114d0f4:	01204574 	movhi	r4,33045
8114d0f8:	210bf804 	addi	r4,r4,12256
8114d0fc:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
  ALT_OS_STOP();
8114d100:	d0209105 	stb	zero,-32188(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
8114d104:	d0a01217 	ldw	r2,-32696(gp)
8114d108:	10800058 	cmpnei	r2,r2,1
8114d10c:	1000031e 	bne	r2,zero,8114d11c <_exit+0x84>
8114d110:	01204574 	movhi	r4,33045
8114d114:	210c0204 	addi	r4,r4,12296
8114d118:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
8114d11c:	e0bfff17 	ldw	r2,-4(fp)
8114d120:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
8114d124:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
8114d128:	10000226 	beq	r2,zero,8114d134 <_exit+0x9c>
    ALT_SIM_FAIL();
8114d12c:	002af070 	cmpltui	zero,zero,43969
8114d130:	00000106 	br	8114d138 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
8114d134:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
8114d138:	d0a01217 	ldw	r2,-32696(gp)
8114d13c:	10800058 	cmpnei	r2,r2,1
8114d140:	1000031e 	bne	r2,zero,8114d150 <_exit+0xb8>
8114d144:	01204574 	movhi	r4,33045
8114d148:	210c0c04 	addi	r4,r4,12336
8114d14c:	1138ba80 	call	81138ba8 <alt_log_printf_proc>
  while (1);
8114d150:	003fff06 	br	8114d150 <__reset+0xfb12d150>
