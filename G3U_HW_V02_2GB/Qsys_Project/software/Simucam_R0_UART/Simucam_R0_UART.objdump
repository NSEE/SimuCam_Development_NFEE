
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x0005446c memsz 0x0006e6d8 flags rwx
    LOAD off    0x00056000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00056000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004c568  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00005ed4  8114c7c4  8114c7c4  0004d7c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  81152698  81152698  00053698  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a26c  8115448c  8115448c  0005548c  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  8116e6f8  8116e6f8  00056000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00056000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00056000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d30  00000000  00000000  00056028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0007117e  00000000  00000000  00057d58  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00016627  00000000  00000000  000c8ed6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00022ee4  00000000  00000000  000df4fd  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00009964  00000000  00000000  001023e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000cb1f  00000000  00000000  0010bd48  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026df9  00000000  00000000  00118867  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0013f660  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002378  00000000  00000000  0013f6a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  0014de21  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0014de27  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0014de33  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0014de34  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0014de35  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0014de39  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  0014de3d  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0014de41  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  0014de4c  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  0014de56  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  0014de60  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  0014de71  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00226f57  00000000  00000000  0014deb0  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
8114c7c4 l    d  .rodata	00000000 .rodata
81152698 l    d  .rwdata	00000000 .rwdata
8115448c l    d  .bss	00000000 .bss
8116e6f8 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
811047f0 l     F .text	00000050 uliCommReadReg
8110479c l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
81105030 l     F .text	00000050 uliDpktReadReg
81104fdc l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
811544b0 l     O .bss	00000004 viCh1HoldContext
811544b4 l     O .bss	00000004 viCh2HoldContext
811544b8 l     O .bss	00000004 viCh3HoldContext
811544bc l     O .bss	00000004 viCh4HoldContext
811544c0 l     O .bss	00000004 viCh5HoldContext
811544c4 l     O .bss	00000004 viCh6HoldContext
811544c8 l     O .bss	00000004 viCh7HoldContext
811544cc l     O .bss	00000004 viCh8HoldContext
81106b24 l     F .text	00000054 vFeebWriteReg
81106b78 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
811544d0 l     O .bss	00000004 viCh1HoldContext
811544d4 l     O .bss	00000004 viCh2HoldContext
811544d8 l     O .bss	00000004 viCh3HoldContext
811544dc l     O .bss	00000004 viCh4HoldContext
811544e0 l     O .bss	00000004 viCh5HoldContext
811544e4 l     O .bss	00000004 viCh6HoldContext
811544e8 l     O .bss	00000004 viCh7HoldContext
811544ec l     O .bss	00000004 viCh8HoldContext
81109db8 l     F .text	00000054 vRmapWriteReg
81109e5c l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
8110a790 l     F .text	00000050 uliSpwcReadReg
8110a73c l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
811543b4 l     O .rwdata	00000001 ucIoValue
8110a990 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110b280 l     F .text	0000013c msgdma_write_extended_descriptor
8110b3bc l     F .text	00000164 msgdma_construct_extended_descriptor
8110b520 l     F .text	00000348 msgdma_descriptor_async_transfer
8110b868 l     F .text	00000490 msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110c478 l     F .text	00000054 vRstcWriteReg
8110c4cc l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
811544f4 l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
811544fc l     O .bss	00000004 pxNFee.5687
81154500 l     O .bss	00000004 incrementador.5692
81154504 l     O .bss	00000004 tCodFeeTask.5690
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
8115450a l     O .bss	00000004 xRAckLocal.5617
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
81154510 l     O .bss	00000004 bDmaBack.5658
81154514 l     O .bss	00000001 ucWhoGetDMA.5659
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
81154516 l     O .bss	00000004 xSAckLocal.5602
00000000 l    df *ABS*	00000000 parser_comm_task.c
81154690 l     O .bss	0000004c PreParsedLocal.5655
811546dc l     O .bss	00000054 xTcPusL.5654
00000000 l    df *ABS*	00000000 receiver_uart_task.c
81154730 l     O .bss	0000004c xPreParsedReader.5647
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
8115477c l     O .bss	00000054 xPusLocal.5890
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
8114ffaa l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
81151ad9 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
81152698 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
81123f10 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
81151ca6 l     O .rodata	00000010 zeroes.4389
81151cb6 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
81151cc6 l     O .rodata	00000010 zeroes.4404
81128b88 l     F .text	000000c4 __sbprintf
81151cd6 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
81151cee l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
8112a870 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
8112c3c0 l     F .text	00000008 __fp_unlock
8112c3d4 l     F .text	000001a4 __sinit.part.1
8112c578 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
81152ee4 l     O .rwdata	00000020 lc_ctype_charset
81152ec4 l     O .rwdata	00000020 lc_message_charset
81152f04 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
81151d2c l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
8112f3e8 l     F .text	0000006c sulp
81151e74 l     O .rodata	00000014 fpi.2737
81151e88 l     O .rodata	00000028 tinytens
81151e60 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
81151ec0 l     O .rodata	00000010 blanks.4332
81151eb0 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
81132a58 l     F .text	00000104 __sprint_r.part.0
81151ee0 l     O .rodata	00000010 blanks.4348
81151ed0 l     O .rodata	00000010 zeroes.4349
81133ff4 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
811344a8 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
81137684 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
811377c8 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
811377fc l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
81137a80 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
81137b78 l       .text	00000000 tx_next_char
81137ba0 l       .text	00000000 end_tx
81137b80 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
8113867c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
811388f8 l     F .text	00000044 alt_get_errno
8113893c l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
81138b64 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
811543fc l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
81139104 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
81154408 l     O .rwdata	00000004 lockid
811545d8 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
8115440c l     O .rwdata	00000004 lockid
811545e0 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
8113ab90 l     F .text	00000050 OS_InitMisc
8113abe0 l     F .text	00000074 OS_InitRdyList
8113ad64 l     F .text	000000ec OS_InitTCBList
8113aaa8 l     F .text	000000e8 OS_InitEventList
8113ac54 l     F .text	00000088 OS_InitTaskIdle
8113acdc l     F .text	00000088 OS_InitTaskStat
8113aff4 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
8113ce0c l     F .text	000000fc OS_FlagTaskRdy
8113cbbc l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
8113e6f8 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
81143128 l     F .text	00000044 OSTmr_Lock
81142bc8 l     F .text	00000074 OSTmr_Alloc
8114316c l     F .text	0000003c OSTmr_Unlock
8114302c l     F .text	000000fc OSTmr_Unlink
81142c3c l     F .text	000000a4 OSTmr_Free
81142edc l     F .text	00000150 OSTmr_Link
81142e54 l     F .text	00000088 OSTmr_InitTask
811431a8 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
811432b8 l     F .text	0000003c alt_dev_reg
81153180 l     O .rwdata	0000106c jtag_uart_0
811541ec l     O .rwdata	000000d0 rs232_uart
811542bc l     O .rwdata	00000064 dma_DDR_M1
81154320 l     O .rwdata	00000064 dma_DDR_M2
81154384 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
81147b48 l     F .text	000002bc altera_avalon_jtag_uart_irq
81147e04 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81148608 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
811489a0 l     F .text	000000a4 altera_avalon_uart_irq
81148a44 l     F .text	00000140 altera_avalon_uart_rxirq
81148b84 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81148d8c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
81149040 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
811492c4 l     F .text	00000044 alt_get_errno
81149308 l     F .text	0000009c alt_msgdma_write_standard_descriptor
811493a4 l     F .text	00000134 alt_msgdma_write_extended_descriptor
811494d8 l     F .text	0000018c alt_msgdma_irq
81149664 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
811496f8 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
81149854 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
81149b94 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
8114a29c l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
8114a348 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
8114b514 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
8114bb58 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81154688 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
8115468c g     O .bss	00000004 alt_instruction_exception_handler
81107088 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
81154f10 g     O .bss	00001000 vFeeTask0_stk
8111cc3c g     F .text	00000064 vFailDeleteInitialization
8111b49c g     F .text	00000df0 vLoadDebugConfs
8115465c g     O .bss	00000004 aux_status_register
81155f10 g     O .bss	00001000 vInAckHandlerTask_stk
8114b2d0 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
811073d0 g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110cb0c g     F .text	0000004c vSyncInitIrq
81117c70 g     F .text	00000284 vCheckRetransmission128
8112ea6c g     F .text	0000007c _mprec_log10
8111e740 g     F .text	0000006c vFailRequestDMAFromIRQ
8110cd14 g     F .text	00000040 bSyncSetMbt
8110ab74 g     F .text	00000108 I2C_Read
8115445a g     O .rwdata	00000002 OSTaskNameSize
81154520 g     O .bss	00000004 xWaitSyncQFee
81156f10 g     O .bss	00000260 xBuffer64
8112eb60 g     F .text	0000008c __any_on
8112d534 g     F .text	0000005c _isatty_r
81151d38 g     O .rodata	00000028 __mprec_tinytens
81107378 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
8113879c g     F .text	0000015c alt_main
811063e0 g     F .text	00000078 bFeebGetRightBufferEmpty
81123e34 g     F .text	000000c8 _puts_r
81105628 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
811545e8 g     O .bss	00000004 OSTmrFreeList
8116e5f8 g     O .bss	00000100 alt_irq
8112d6a4 g     F .text	00000068 _lseek_r
8111fb7c g     F .text	00000030 vChangeDefaultAutoResetSync
8113d66c g     F .text	000000d4 OS_MemInit
8111e6d4 g     F .text	0000006c vFailRequestDMA
81106458 g     F .text	00000068 bFeebGetCh1LeftBufferEmpty
8111a72c g     F .text	00000a40 vLoadDefaultETHConf
811128e8 g     F .text	0000014c bCheckInAck64
81157170 g     O .bss	00000150 xPus
81142108 g     F .text	00000068 OSTimeSet
81116814 g     F .text	000000ac vPusType250run
8112c778 g     F .text	000000ac __sflags
8111df28 g     F .text	00000080 vCoudlNotCreateNFee2Task
8111e404 g     F .text	00000064 vCouldNotGetMutexMebPus
81137328 g     F .text	00000088 .hidden __eqdf2
81116fb0 g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
8111fa68 g     F .text	00000034 vLoadDefaultSyncSource
8111c554 g     F .text	00000064 vFailCreateMutexDMA
811437b8 g     F .text	000001ac Check_for_Master_Boot_Record
8116800c g     O .bss	00000010 OSTmrWheelTbl
81107470 g     F .text	00000050 uliRmapCh3WriteCmdAddress
8114a05c g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
811572c0 g     O .bss	00000020 xFeeQueueTBL3
811397f4 g     F .text	00000594 OSEventPendMulti
81154524 g     O .bss	00000004 xNfeeSchedule
8116e6f8 g       *ABS*	00000000 __alt_heap_start
8114c190 g     F .text	0000002c OSTaskCreateHook
81147630 g     F .text	000001c4 alt_up_sd_card_fclose
81154528 g     O .bss	00000004 xSemCountBuffer64
81104560 g     F .text	0000016c bCommSetGlobalIrqEn
81107874 g     F .text	00000088 bRmapGetIrqControl
811544f1 g     O .bss	00000001 SspdConfigControl
8110d130 g     F .text	00000054 bSyncCtrReset
81154432 g     O .rwdata	00000002 OSMboxEn
81110868 g     F .text	00000584 vQCmdFeeRMAPWaitingSync
81120608 g     F .text	000000a4 aatoh
81139dec g     F .text	00000054 OSIntEnter
81135114 g     F .text	000000a4 _wcrtomb_r
81105534 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
8111cb74 g     F .text	00000064 vFailReceiverCreate
8115452c g     O .bss	00000004 xQMaskDataCtrl
811051d0 g     F .text	00000038 vFeebCh2HandleIrq
8112439c g     F .text	00000064 __sseek
8112c728 g     F .text	00000010 __sinit
8110bdb8 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
8112a4f0 g     F .text	00000148 __swbuf_r
81118448 g     F .text	00000470 bResourcesInitRTOS
8110a2dc g     F .text	000000f4 bSpwcGetLinkError
81154442 g     O .rwdata	00000002 OSQEn
8110fc00 g     F .text	00000684 vQCmdFeeRMAPinStandBy
81106dd8 g     F .text	00000038 vRmapCh4HandleIrq
8112d5c0 g     F .text	00000084 _setlocale_r
811572e0 g     O .bss	00000020 SyncTBL2
811543b8 g     O .rwdata	00000004 LedsPainelControl
811547f8 g     O .bss	00000100 cDebugBuffer
8112c580 g     F .text	00000070 __sfmoreglue
81132a40 g     F .text	00000018 ungetc
81105838 g     F .text	000000d4 bFeebCh1SetBufferSize
811394b0 g     F .text	000000d4 __malloc_unlock
81102d88 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
8114c210 g     F .text	00000028 OSTaskStatHook
81116e0c g     F .text	00000088 vSendCmdQToNFeeCTRL
8111fad8 g     F .text	00000030 vChangeDefaultSyncSource
811545ec g     O .bss	00000001 OSLockNesting
811545f0 g     O .bss	00000004 OSTmrSemSignal
8111ec74 g     F .text	00000284 vNFeeStructureInit
81154530 g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
8112f454 g     F .text	00001600 _strtod_r
81154534 g     O .bss	00000004 xSemCountSenderACK
811207d8 g     F .text	00000448 .hidden __divsf3
81154680 g     O .bss	00000004 current_sector_modified
81154480 g     O .rwdata	00000002 OSDataSize
811545f4 g     O .bss	00000001 OSRunning
8110a5b8 g     F .text	00000184 bSpwcInitCh
81138464 g     F .text	00000064 alt_log_jtag_uart_isr_proc
81157300 g     O .bss	00001000 senderTask_stk
81108368 g     F .text	00000094 bRmapGetMemConfigStat
81154538 g     O .bss	00000004 fp
81158300 g     O .bss	00000048 xNfeeScheduleTBL
811127a0 g     F .text	00000148 bCheckInAck128
8112da34 g     F .text	0000015c memmove
8114c28c g     F .text	0000002c OSInitHookBegin
8110d5cc g     F .text	00000074 bSyncCtrCh8OutEnable
81110f58 g     F .text	00000098 bEnableDbBuffer
81154478 g     O .rwdata	00000002 OSTmrSize
8112c710 g     F .text	00000018 _cleanup
8111ff98 g     F .text	00000040 siCloseFile
811069a0 g     F .text	00000184 bFeebInitCh
8112db90 g     F .text	000000b0 _Balloc
8111fb08 g     F .text	00000038 vLoadDefaultAutoResetSync
81107984 g     F .text	000000d8 bRmapSetCodecConfig
8114620c g     F .text	000000cc alt_up_sd_card_is_Present
81149f9c g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
81154494 g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a8 DMA_DISPATCHER_STOP
811434e0 g     F .text	00000054 Save_Modified_Sector
81105788 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
811545f8 g     O .bss	00000004 OSIdleCtr
811545b4 g     O .bss	00000001 alt_log_write_on_flag
8110a7e0 g     F .text	0000003c bEnableIsoDrivers
81121248 g     F .text	000000dc .hidden __gtdf2
8114bf20 g     F .text	0000002c altera_nios2_gen2_irq_init
8114c008 g       .text	00000000 OSStartTsk
8110ce88 g     F .text	00000070 bSyncSetNCycles
8113b364 g     F .text	000002dc OS_TCBInit
811545b7 g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
8111f6f0 g     F .text	00000078 vInitSimucamBasicHW
81158348 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110d4e4 g     F .text	00000074 bSyncCtrCh6OutEnable
8110aef0 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
81154678 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
811545fc g     O .bss	00000002 OSTmrUsed
8115453c g     O .bss	00000004 xSemCountBuffer128
81103264 g     F .text	000000f8 TEMP_Read
811077cc g     F .text	000000a8 bRmapSetIrqControl
81105b88 g     F .text	000000d4 bFeebCh5SetBufferSize
81159348 g     O .bss	00001000 vDataControlTask_stk
81105240 g     F .text	00000038 vFeebCh4HandleIrq
8115447e g     O .rwdata	00000002 OSTmrWheelTblSize
8111f398 g     F .text	0000002c cFeeSpwChannelDisable
8115441e g     O .rwdata	00000002 OSEventSize
811545fe g     O .bss	00000001 OSPrioHighRdy
81122e90 g     F .text	00000064 _fstat_r
8114c1bc g     F .text	0000002c OSTaskDelHook
81154590 g     O .bss	00000004 errno
8110d8c0 g     F .text	0000003c uliSyncGetCtr
8112a480 g     F .text	0000001c __svfscanf
81124310 g     F .text	00000008 __seofread
8114bfe8 g       .text	00000000 OSStartHighRdy
8111ebd4 g     F .text	00000028 vEvtChangeFeeControllerMode
811111a4 g     F .text	00000968 vPrintConsoleNFee
811138c8 g     F .text	000000c8 bSendCmdQToNFeeInst
81106e80 g     F .text	00000038 vRmapCh7HandleIrq
81140b38 g     F .text	000001ec OSTaskCreateExt
81167fe0 g     O .bss	00000011 alt_log_write_buf
81104a6c g     F .text	0000012c bDpktGetPacketConfig
81107600 g     F .text	00000050 uliRmapCh8WriteCmdAddress
8111d020 g     F .text	00000080 vFailGetCountSemaphorePreParsedBuffer
81131584 g     F .text	00001244 ___svfiprintf_internal_r
811156b0 g     F .text	0000037c bPreParserV2
8113c6ec g     F .text	00000068 OSFlagPendGetFlagsRdy
8115445e g     O .rwdata	00000002 OSTaskStatStkSize
81106590 g     F .text	00000068 bFeebGetCh2RightBufferEmpty
8113b838 g     F .text	00000310 OSFlagAccept
8113ee14 g     F .text	000000c0 OSQFlush
81154cf8 g     O .bss	00000118 xRmap
8113e890 g     F .text	00000148 OSQAccept
811545c8 g     O .bss	00000004 alt_argv
8115c3b0 g       *ABS*	00000000 _gp
8111c764 g     F .text	00000064 vFailSendPreAckReceiverSemaphore
81138fc8 g     F .text	0000013c usleep
811467e4 g     F .text	00000384 alt_up_sd_card_fopen
8111fe04 g     F .text	00000030 bSDcardIsPresent
81115a2c g     F .text	00000210 vSenderComTask
8114634c g     F .text	000000d8 alt_up_sd_card_find_first
81140984 g     F .text	000001b4 OSTaskCreate
8111d220 g     F .text	00000080 vFailSendNack
8115466c g     O .bss	00000004 command_argument_register
8114048c g     F .text	000004f8 OSTaskChangePrio
81116314 g     F .text	000000c4 vPusMebInTaskConfigMode
8111db78 g     F .text	000000a0 vCouldNotSendTMPusCommand
811545e4 g     O .bss	00000004 alt_heapsem
8111f238 g     F .text	000000b0 vResetMemCCDFEE
8110b188 g     F .text	00000080 bSetBoardLeds
8113b640 g     F .text	000001f8 OSDebugInit
81140d24 g     F .text	0000034c OSTaskDel
8113d740 g     F .text	000001ac OSMutexAccept
8115a348 g     O .bss	000002b8 xSimMeb
8111f5d4 g     F .text	00000040 vSetTimeCode
8114ab44 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
81154540 g     O .bss	00000004 xSemCountPreParsed
81152f64 g     O .rwdata	00000180 alt_fd_list
811056d8 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
81153100 g     O .rwdata	0000001d alt_log_msg_alt_main
8116801c g     O .bss	00000840 OSFlagTbl
81107110 g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
8111c92c g     F .text	00000080 vFailGetCountSemaphoreReceiverTask
81107510 g     F .text	00000050 uliRmapCh5WriteCmdAddress
8111f9c0 g     F .text	0000003c vLoadDefaultRTValue
8113a870 g     F .text	000000c0 OS_EventTaskRemove
8115a600 g     O .bss	00001000 vFeeTask5_stk
811545b6 g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
81145a60 g     F .text	00000134 find_first_empty_record_in_root_directory
8114b604 g     F .text	00000098 alt_find_dev
811239dc g     F .text	00000150 memcpy
81134de0 g     F .text	00000264 __hexnan
81104e68 g     F .text	00000174 bDpktInitCh
8115b600 g     O .bss	00000160 xBuffer32
81154448 g     O .rwdata	00000002 OSRdyTblSize
8116885c g     O .bss	000001a0 OSTmrTbl
8112c3c8 g     F .text	0000000c _cleanup_r
811223c8 g     F .text	000000e4 .hidden __floatsidf
8111a354 g     F .text	000001a8 vSendPusTM64
8110cc84 g     F .text	0000004c ucSyncStatusErrorCode
81116f1c g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8111f494 g     F .text	00000034 cFeeRMAPLogDisable
81113d80 g     F .text	00000fc0 vParserCommTask
8114bc24 g     F .text	00000084 alt_io_redirect
8111f428 g     F .text	00000034 cFeeRMAPEchoingDisable
811373b0 g     F .text	000000f4 .hidden __ltdf2
8111e320 g     F .text	00000064 vFailSendPUStoMebTask
81107320 g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
81106054 g     F .text	000000d4 bFeebSetIrqControl
8111d8f8 g     F .text	00000080 vCouldNotRetransmitB128TimeoutTask
81154544 g     O .bss	00000004 xMutexReceivedACK
81103bec g     F .text	000000c4 bSdmaInitM2Dma
811544ac g     O .bss	00000004 EDpktMode
8114afcc g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
8114b314 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110d1d8 g     F .text	00000054 bSyncCtrErrInj
8114b274 g     F .text	0000005c alt_msgdma_register_callback
8111b16c g     F .text	00000330 vShowEthConfig
8111f768 g     F .text	00000030 bLogWriteSDCard
8111cd20 g     F .text	00000080 vFailSetCountSemaphorexBuffer64
81123efc g     F .text	00000014 puts
81120018 g     F .text	000001b8 bInitSync
8114c334 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110c9dc g     F .text	00000104 vSyncHandleIrq
81139584 g     F .text	00000128 OSEventNameGet
8110539c g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
8115442c g     O .rwdata	00000002 OSFlagMax
8112d7c0 g     F .text	000000e0 mbrtowc
81145658 g     F .text	000001b4 find_first_empty_cluster
81117038 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110d470 g     F .text	00000074 bSyncCtrCh5OutEnable
811544f8 g     O .bss	00000001 vucN
8112f1c0 g     F .text	00000074 __fpclassifyd
8110cbe4 g     F .text	00000054 bSyncStatusExtnIrq
8112a49c g     F .text	00000054 _vfscanf_r
8113ddc0 g     F .text	000005a4 OSMutexPend
8112e9c0 g     F .text	000000ac __ratio
81146148 g     F .text	000000c4 alt_up_sd_card_open_dev
8111dc18 g     F .text	00000080 vWarnCouldNotgetMutexRetrans128
81139e40 g     F .text	00000100 OSIntExit
8110cd54 g     F .text	00000040 bSyncSetBt
81133fd8 g     F .text	0000001c __vfiprintf_internal
8111e468 g     F .text	00000080 vCouldNotCreateQueueMaskNfeeCtrl
81154466 g     O .rwdata	00000002 OSTCBSize
81105358 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
811545ff g     O .bss	00000001 OSPrioCur
81148078 g     F .text	000002c4 altera_avalon_jtag_uart_read
8114a80c g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
81135ecc g     F .text	00000064 .hidden __udivsi3
81137ac4 g     F .text	000000ac isatty
811544f0 g     O .bss	00000001 LedsBoardControl
81154548 g     O .bss	00000004 xSemCountReceivedACK
8115444c g     O .rwdata	00000002 OSStkWidth
8112d590 g     F .text	00000030 iswspace
81151d88 g     O .rodata	000000c8 __mprec_tens
81154440 g     O .rwdata	00000002 OSPtrSize
8111e7ac g     F .text	0000006c vFailSendRMAPFromIRQ
8111e128 g     F .text	00000080 vCoudlNotCreateNFeeControllerTask
8112d644 g     F .text	0000000c __locale_charset
8110d388 g     F .text	00000074 bSyncCtrCh3OutEnable
811360bc g     F .text	000000c8 .hidden __lesf2
81154420 g     O .rwdata	00000002 OSEventTblSize
8112075c g     F .text	0000007c .hidden __fixunsdfsi
8114bf4c g       .text	00000000 OSCtxSw
8110ac7c g     F .text	00000160 I2C_MultipleRead
81138608 g     F .text	00000074 alt_log_system_clock
8115459c g     O .bss	00000004 __malloc_top_pad
81154600 g     O .bss	00000004 OSTCBList
81142b88 g     F .text	00000040 OSTmrSignal
811545ac g     O .bss	00000004 alt_fd_list_lock
811310b0 g     F .text	0000001c strtoul
811543d0 g     O .rwdata	00000004 __mb_cur_max
8112d674 g     F .text	0000000c _localeconv_r
811310cc g     F .text	000002e0 _strtoull_r
8110c408 g     F .text	00000070 vRstcHoldDeviceReset
8112dfb4 g     F .text	00000044 __i2b
8112ced8 g     F .text	000004c4 __sfvwrite_r
81144938 g     F .text	000000c0 get_dir_divider_location
81106fbc g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
811689fc g     O .bss	00000c30 OSMemTbl
81154604 g     O .bss	00000001 OSTickStepState
81138218 g     F .text	00000060 alt_log_printf_proc
81104da4 g     F .text	000000c4 bDpktGetPixelDelay
8115b760 g     O .bss	00001800 vReceiverUartTask_stk
81124108 g     F .text	0000005c _sbrk_r
8115454c g     O .bss	00000004 xSemTimeoutChecker
811445f8 g     F .text	000000cc filename_to_upper_case
811545b8 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
81154444 g     O .rwdata	00000002 OSQMax
81146b68 g     F .text	00000090 alt_up_sd_card_set_attributes
8113dabc g     F .text	00000304 OSMutexDel
8116962c g     O .bss	00001000 OSTaskStatStk
8111fe34 g     F .text	00000030 bSDcardFAT16Check
8113d288 g     F .text	000000f8 OSMemNameGet
8111c4dc g     F .text	00000078 vFailCreateMutexSResources
81143964 g     F .text	00000284 Read_File_Record_At_Offset
8115cf60 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
81154424 g     O .rwdata	00000002 OSFlagEn
8112ebec g     F .text	00000068 _read_r
8115446a g     O .rwdata	00000002 OSTimeTickHookEn
8113cf08 g     F .text	000000ac OS_FlagUnlink
8113f2dc g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
811543ec g     O .rwdata	00000004 alt_max_fd
8111d614 g     F .text	00000064 vFailTimeoutCheckerTaskCreate
8113aeac g     F .text	00000070 OS_MemCopy
8113af1c g     F .text	000000d8 OS_Sched
811451dc g     F .text	0000047c find_file_in_directory
81134184 g     F .text	000000f8 _fclose_r
8113d190 g     F .text	000000f8 OSMemGet
81141368 g     F .text	000001bc OSTaskNameSet
8112c390 g     F .text	00000030 fflush
81154598 g     O .bss	00000004 __malloc_max_sbrked_mem
81154608 g     O .bss	00000004 OSCtxSwCtr
81105c5c g     F .text	000000d4 bFeebCh6SetBufferSize
8114c238 g     F .text	00000054 OSTimeTickHook
8115cfa0 g     O .bss	00001000 vOutAckHandlerTask_stk
811378f8 g     F .text	00000188 alt_irq_register
8115442e g     O .rwdata	00000002 OSFlagNameSize
811224ac g     F .text	00000118 .hidden __extendsfdf2
8113a930 g     F .text	00000108 OS_EventTaskRemoveMulti
8111dda0 g     F .text	00000088 vFailCreateNFEESyncQueue
811462d8 g     F .text	00000074 alt_up_sd_card_is_FAT16
8110aa0c g     F .text	00000088 I2C_TestAdress
81136184 g     F .text	000008b4 .hidden __adddf3
81167ff4 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
81135f88 g     F .text	00000078 .hidden __nesf2
81106f78 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
8110510c g     F .text	0000008c usiLineTrDelayCalcPeriodNs
8113a718 g     F .text	00000158 OS_EventTaskWaitMulti
8115dfa0 g     O .bss	00000020 SyncTBL4
8112e758 g     F .text	00000114 __b2d
8114a544 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
81154446 g     O .rwdata	00000002 OSQSize
81135894 g     F .text	00000540 .hidden __umoddi3
811386c0 g     F .text	000000dc lseek
8113fdcc g     F .text	00000214 OSSemPend
8111e384 g     F .text	00000080 vCouldNotGetCmdQueueMeb
81107ae8 g     F .text	00000160 bRmapGetCodecStatus
8110a3d0 g     F .text	000000d0 bSpwcGetLinkStatus
81106780 g     F .text	00000088 bFeebGetWindowing
811543c0 g     O .rwdata	00000004 _global_impure_ptr
8110c990 g     F .text	0000004c bSSDisplayUpdate
81144c9c g     F .text	00000540 get_home_directory_cluster_for_file
8112ec54 g     F .text	0000056c _realloc_r
81154430 g     O .rwdata	00000002 OSLowestPrio
8116e6f8 g       *ABS*	00000000 __bss_end
8114ba60 g     F .text	000000f8 alt_iic_isr_register
8114c308 g     F .text	0000002c OSTCBInitHook
81154476 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81138eb8 g     F .text	00000110 alt_tick
81107650 g     F .text	0000017c vRmapInitIrq
8111c8ac g     F .text	00000080 vFailGetMutexSenderTask
8110c328 g     F .text	0000006c vRstcSimucamReset
8111105c g     F .text	000000a4 bSendRequestNFeeCtrl
81151ef0 g     O .rodata	00000100 __hexdig
8114b0c0 g     F .text	000001b4 alt_msgdma_init
81135314 g     F .text	00000580 .hidden __udivdi3
81115380 g     F .text	0000017c setPreAckSenderFreePos
811343fc g     F .text	00000024 _fputwc_r
81154418 g     O .rwdata	00000002 OSEventEn
81151d60 g     O .rodata	00000028 __mprec_bigtens
8112dd90 g     F .text	0000010c __s2b
81154472 g     O .rwdata	00000002 OSTmrCfgNameSize
8115dfc0 g     O .bss	00000020 xFeeQueueTBL4
8110ce14 g     F .text	00000074 bSyncSetPolarity
81117ef4 g     F .text	0000028c vCheckRetransmission64
811374a4 g     F .text	000000b0 .hidden __floatunsidf
811545bc g     O .bss	00000004 alt_system_clock_in_sec
81138410 g     F .text	00000054 alt_log_jtag_uart_startup_info
8111cfa0 g     F .text	00000080 vFailFoundBufferRetransmission
8112e490 g     F .text	00000060 __mcmp
81154684 g     O .bss	00000004 current_sector_index
81148838 g     F .text	00000168 altera_avalon_uart_init
8114b39c g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
81104104 g     F .text	0000045c bSdmaDmaM2Transfer
8111f614 g     F .text	00000034 vResetTimeCode
8111f36c g     F .text	0000002c cFeeSpwChannelEnable
8112c748 g     F .text	00000018 __fp_lock_all
8111e9b8 g     F .text	00000064 vFailSendMsgDataCTRL
8114ba0c g     F .text	00000054 alt_ic_irq_enabled
8110aa94 g     F .text	000000e0 I2C_Write
811071c0 g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
8115460c g     O .bss	00000002 OSTmrFree
8113cd24 g     F .text	000000e8 OS_FlagInit
81138e14 g     F .text	000000a4 alt_alarm_stop
81124770 g     F .text	0000001c strtol
811545b5 g     O .bss	00000001 alt_log_sys_clk_on_flag
81142334 g     F .text	00000140 OSTmrDel
811436d0 g     F .text	000000e8 mark_cluster
81154454 g     O .rwdata	00000002 OSTaskIdleStkSize
811545b0 g     O .bss	00000004 alt_irq_active
8113f9ec g     F .text	000000b8 OSSemAccept
81122a28 g     F .text	0000044c _fseeko_r
81118dec g     F .text	00000354 vFillMemmoryPattern
811244ec g     F .text	00000044 strnlen
8113d49c g     F .text	000000e0 OSMemPut
8113cfb4 g     F .text	000001dc OSMemCreate
81154610 g     O .bss	00000004 OSIdleCtrMax
8111a4fc g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
81137c60 g     F .text	000005b8 alt_log_private_printf
81152f3c g     O .rwdata	00000028 alt_dev_null
8114a154 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110cdd4 g     F .text	00000040 bSyncSetOst
81154468 g     O .rwdata	00000002 OSTicksPerSec
811530e4 g     O .rwdata	00000019 alt_log_msg_bss
81145b94 g     F .text	00000194 convert_filename_to_name_extension
811083fc g     F .text	0000104c bRmapSetRmapMemHKArea
811065f8 g     F .text	000000e0 bFeebSetBufferSize
81115c3c g     F .text	0000057c vSimMebTask
8110addc g     F .text	00000094 i2c_start
8114bf4c g       .text	00000000 OSIntCtxSw
8111e818 g     F .text	0000006c vFailSendMsgSync
8110d3fc g     F .text	00000074 bSyncCtrCh4OutEnable
8114af38 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
811377a0 g     F .text	00000028 alt_dcache_flush_all
8112de9c g     F .text	00000068 __hi0bits
811168c0 g     F .text	0000012c vPusType251run
81107560 g     F .text	00000050 uliRmapCh6WriteCmdAddress
8111f9fc g     F .text	0000003c vChangeRTValue
81154658 g     O .bss	00000004 is_sd_card_formated_as_FAT16
81117acc g     F .text	000001a4 vCheck
8111ec24 g     F .text	00000050 vNFeeNotInUse
81122348 g     F .text	00000080 .hidden __fixdfsi
81113990 g     F .text	000000c8 bSendCmdQToNFeeInst_Prio
81105e04 g     F .text	000000d4 bFeebCh8SetBufferSize
81106890 g     F .text	00000088 bFeebStopCh
8110d9ec g     F .text	00000084 uliPerCalcPeriodMs
8111320c g     F .text	00000450 vNFeeControlTask
8115dfe0 g     O .bss	00001000 vInitialTask_stk
81154550 g     O .bss	00000002 usiIdCMD
8115efe0 g     O .bss	00000020 SyncTBL3
8110d0dc g     F .text	00000054 bSyncCtrStart
8114580c g     F .text	00000254 find_first_empty_record_in_a_subdirectory
81130a54 g     F .text	00000018 strtod
81106918 g     F .text	00000088 bFeebClrCh
81154614 g     O .bss	00000004 OSTCBFreeList
811072c8 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
8113ffe0 g     F .text	00000174 OSSemPendAbort
8111caac g     F .text	00000064 vFailGetMacRTC
811074c0 g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8111d54c g     F .text	00000064 vFailCreateTimerRetransmisison
8111cf20 g     F .text	00000080 vFailGetCountSemaphorexBuffer32
81119334 g     F .text	00000320 bSendUART128v2
8111f830 g     F .text	000000ec vSimucamStructureInit
811543e4 g     O .rwdata	00000008 alt_dev_list
81122958 g     F .text	0000004c _fputc_r
81139148 g     F .text	0000010c write
81123cbc g     F .text	000000a8 _putc_r
8115467c g     O .bss	00000004 device_pointer
8115446c g     O .rwdata	00000002 OSVersionNbr
81136000 g     F .text	000000bc .hidden __gtsf2
8111eae4 g     F .text	00000064 vFailFlushMEBQueue
81114d40 g     F .text	00000118 getPreParsedPacket
81110ef8 g     F .text	00000060 bEnableSPWChannel
81137840 g     F .text	000000b8 fstat
8111f67c g     F .text	00000040 vChangeIdNFEEMaster
8112292c g     F .text	0000002c fprintf
8111f45c g     F .text	00000038 cFeeRMAPLogEnable
81102c74 g     F .text	00000114 DMA_SINGLE_TRANSFER
81105730 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
8111d6f8 g     F .text	00000080 vFailPostBlockingSemTimeoutTask
811202d0 g     F .text	00000058 _reg_write
8111f6bc g     F .text	00000034 vChangeDefaultIdNFEEMaster
811373b0 g     F .text	000000f4 .hidden __ledf2
81106e10 g     F .text	00000038 vRmapCh5HandleIrq
81110dec g     F .text	00000054 bDisableRmapIRQ
8115f000 g     O .bss	00001000 vStackMonitor_stk
8111daf8 g     F .text	00000080 vCouldNotSendLog
811425b4 g     F .text	000001b8 OSTmrRemainGet
81154414 g     O .rwdata	00000004 OSEndiannessTest
8110c51c g     F .text	00000058 v_spi_start
8112e1f8 g     F .text	00000148 __pow5mult
81107420 g     F .text	00000050 uliRmapCh2WriteCmdAddress
81132b74 g     F .text	00001464 ___vfiprintf_internal_r
811545a8 g     O .bss	00000004 __nlocale_changed
81135f30 g     F .text	00000058 .hidden __umodsi3
8110d22c g     F .text	00000074 bSyncCtrSyncOutEnable
8111fe64 g     F .text	000000f8 bInitializeSDCard
8111d420 g     F .text	00000064 vFailParserCommTaskCreate
8111da78 g     F .text	00000080 vCouldNotSendReset
811241a8 g     F .text	00000038 _scanf_r
8111d4e8 g     F .text	00000064 vFailOutAckHandlerTaskCreate
81154426 g     O .rwdata	00000002 OSFlagGrpSize
811163d8 g     F .text	000000ac vPusType250conf
81160000 g     O .bss	00000058 xInUseRetrans
8110cb94 g     F .text	00000050 bSyncIrqFlagSync
8114a5a4 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
8114276c g     F .text	000000ec OSTmrStateGet
8116e6f8 g       *ABS*	00000000 end
811052b0 g     F .text	00000038 vFeebCh6HandleIrq
8111d120 g     F .text	00000080 vNoContentInPreParsedBuffer
81122e74 g     F .text	0000001c fseeko
81114e58 g     F .text	00000168 bSendMessagePUStoMebTask
8111dd18 g     F .text	00000088 vFailCreateNFEEQueue
811227dc g     F .text	0000000c _atoi_r
81149084 g     F .text	00000240 altera_avalon_uart_write
81137ba4 g     F .text	00000054 alt_log_txchar
81122a0c g     F .text	0000001c fseek
811192a4 g     F .text	00000090 vCCDChangeValues
81147978 g     F .text	000001d0 altera_avalon_jtag_uart_init
8113b1ac g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
8111c61c g     F .text	00000064 vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
8114868c g     F .text	00000084 alt_avalon_timer_sc_init
811066d8 g     F .text	000000a8 bFeebSetWindowing
81148778 g     F .text	00000068 altera_avalon_uart_write_fd
8112276c g     F .text	00000064 .hidden __clzsi2
811487e0 g     F .text	00000058 altera_avalon_uart_close_fd
81160058 g     O .bss	00000020 xMebQTBL
8114833c g     F .text	000002cc altera_avalon_jtag_uart_write
81142ce0 g     F .text	00000174 OSTmr_Init
81160078 g     O .bss	00000348 xBuffer128
8112c738 g     F .text	00000004 __sfp_lock_acquire
8110335c g     F .text	00000048 sense_log_temp
8112d950 g     F .text	000000e4 memchr
8113ae50 g     F .text	0000005c OS_MemClr
8112696c g     F .text	00002200 ___vfprintf_internal_r
8114c02c g     F .text	00000164 OSTaskStkInit
811241e0 g     F .text	00000060 _sprintf_r
81108094 g     F .text	000002d4 bRmapGetMemConfigArea
81154552 g     O .bss	00000001 SemCount32
8112cbc0 g     F .text	00000318 _free_r
8114bca8 g     F .text	00000234 alt_printf
8111a304 g     F .text	00000050 vTimeoutCheck
81120380 g     F .text	00000214 _print_codec_status
8112d650 g     F .text	00000010 __locale_mb_cur_max
8113a460 g     F .text	000001a0 OS_EventTaskRdy
811078fc g     F .text	00000088 bRmapGetIrqFlags
81102bcc g     F .text	000000a8 DMA_DISPATCHER_RESET
8114c580 g     F .text	00000188 __call_exitprocs
81113760 g     F .text	00000168 vPerformActionNFCRunning
81154618 g     O .bss	00000001 OSCPUUsage
8111e028 g     F .text	00000080 vCoudlNotCreateNFee4Task
811545a4 g     O .bss	00000004 __mlocale_changed
8111365c g     F .text	00000104 vPerformActionNFCConfig
8110d184 g     F .text	00000054 bSyncCtrOneShot
811543c8 g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110d8fc g     F .text	0000003c uliSyncReadStatus
811545d0 g     O .bss	00000004 _alt_tick_rate
8113eed4 g     F .text	00000294 OSQPend
81130b74 g     F .text	000002e8 _strtoll_r
811603c0 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
81167f88 g     O .bss	0000003c xDefaults
81141c58 g     F .text	0000010c OSTimeDly
81116750 g     F .text	000000c4 vPusMebInTaskRunningMode
8110cb58 g     F .text	0000003c vSyncIrqFlagClrSync
8112e340 g     F .text	00000150 __lshift
81113a58 g     F .text	00000328 vOutAckHandlerTask
81149ffc g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
811545d4 g     O .bss	00000004 _alt_nticks
81138ba8 g     F .text	00000104 read
81143334 g     F .text	000000f0 alt_sys_init
81121024 g     F .text	0000012c .hidden __floatsisf
81106f34 g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
811313ac g     F .text	000001d8 __ssprint_r
81123c54 g     F .text	00000068 _open_r
81120270 g     F .text	00000060 bTestSimucamCriticalHW
8110625c g     F .text	0000010c bFeebGetBuffersStatus
8111c28c g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
81154619 g     O .bss	00000001 OSTaskCtr
81137b70 g       .text	00000000 tx_log_str
811161b8 g     F .text	0000015c vPusMebTask
8111a2b4 g     F .text	00000050 siPosStr
81116e94 g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
81135044 g     F .text	000000d0 strncmp
8110d938 g     F .text	0000005c bSyncWriteReg
81107270 g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
81141d64 g     F .text	00000164 OSTimeDlyHMSM
8112dff8 g     F .text	00000200 __multiply
81147f10 g     F .text	00000070 altera_avalon_jtag_uart_close
8110c6ec g     F .text	00000058 v_spi_end
8111ffd8 g     F .text	00000040 cGetNextChar
8114c494 g     F .text	000000ec strncpy
811547d0 g     O .bss	00000028 __malloc_current_mallinfo
8115441a g     O .rwdata	00000002 OSEventMax
81135f88 g     F .text	00000078 .hidden __eqsf2
8112e86c g     F .text	00000154 __d2b
81140154 g     F .text	00000118 OSSemPost
81105424 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
8111fa38 g     F .text	00000030 vChangeDefaultRTValue
81105320 g     F .text	00000038 vFeebCh8HandleIrq
81154654 g     O .bss	00000004 initialized
8111a164 g     F .text	00000100 vSendLog
81139fd4 g     F .text	000000e4 OSSchedUnlock
8110c744 g     F .text	0000017c RTCC_SPI_R_MAC
811543f8 g     O .rwdata	00000004 alt_log_boot_on_flag
811477f4 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
81130e5c g     F .text	00000254 _strtoul_r
81160400 g     O .bss	00000020 xFeeQueueTBL5
8114b7ac g     F .text	000000e4 alt_get_fd
8115461c g     O .bss	00000004 OSMemFreeList
8113a130 g     F .text	000000b8 OSStatInit
8112023c g     F .text	00000034 bClearCounterSync
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
8116e090 g     O .bss	00000014 search_data
8110a0c4 g     F .text	00000134 bSpwcSetLink
81137554 g     F .text	00000130 alt_busy_sleep
8113caf0 g     F .text	000000cc OSFlagQuery
8110d2a0 g     F .text	00000074 bSyncCtrCh1OutEnable
81154450 g     O .rwdata	00000002 OSTaskCreateExtEn
81120594 g     F .text	00000074 _split_codec_status
8112a814 g     F .text	0000005c _close_r
8111d1a0 g     F .text	00000080 vCouldNotSendEthConfUART
81112b80 g     F .text	0000068c vInitialTask
81138318 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
8114a4e4 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
8114c418 g     F .text	0000007c memcmp
8113a438 g     F .text	00000028 OS_Dummy
811478c4 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
8116e6f8 g       *ABS*	00000000 __alt_stack_base
81105d30 g     F .text	000000d4 bFeebCh7SetBufferSize
8114791c g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
81105468 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
81122ef4 g     F .text	000000d4 _fwrite_r
811171c8 g     F .text	000000a4 vReleaseSyncMessages
8114a604 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
81105578 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
8112a6b8 g     F .text	0000015c __swsetup_r
8116a62c g     O .bss	00000300 OSQTbl
8111e568 g     F .text	00000080 vCouldNotGetQueueMaskNfeeCtrl
81167fc4 g     O .bss	0000001c xConfEth
81136a38 g     F .text	000008f0 .hidden __divdf3
8111fa9c g     F .text	0000003c vChangeSyncSource
8112c5f0 g     F .text	00000120 __sfp
8116e0a4 g     O .bss	00000054 boot_sector_data
8111e4e8 g     F .text	00000080 vCouldNotCreateQueueMaskDataCtrl
8110a530 g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
8112eae8 g     F .text	00000078 __copybits
81152abc g     O .rwdata	00000408 __malloc_av_
8112c744 g     F .text	00000004 __sinit_lock_release
8115448c g     O .bss	00000004 uliInitialState
8110ae70 g     F .text	00000080 i2c_stop
811206ac g     F .text	0000007c Verif_Error
81120728 g     F .text	00000034 toInt
8111c7c8 g     F .text	00000064 vFailSendPreAckSenderSemaphore
81154620 g     O .bss	00000004 OSTCBHighRdy
81121324 g     F .text	00000720 .hidden __muldf3
811242b4 g     F .text	0000005c __sread
8112ca58 g     F .text	0000003c fread
81154624 g     O .bss	00000004 OSQFreeList
8114b69c g     F .text	00000110 alt_find_file
8114b558 g     F .text	000000ac alt_dev_llist_insert
81139388 g     F .text	00000128 __malloc_lock
811228fc g     F .text	00000030 _fprintf_r
81138d18 g     F .text	000000fc sbrk
8111f2e8 g     F .text	0000002c vFeeSpwRMAPLoadDefault
8111cea0 g     F .text	00000080 vFailGetCountSemaphorexBuffer64
8112478c g     F .text	000021e0 ___svfprintf_internal_r
8111a6a4 g     F .text	00000088 vTMPusTestConnection
81154554 g     O .bss	00000004 xMebQ
811396ac g     F .text	00000148 OSEventNameSet
8112c32c g     F .text	00000064 _fflush_r
811340b8 g     F .text	000000cc _calloc_r
81154628 g     O .bss	00000001 OSRdyGrp
8111e954 g     F .text	00000064 vFailSendMsgFeeCTRL
8110ccd0 g     F .text	00000044 ucSyncStatusCycleNumber
81107a5c g     F .text	0000008c bRmapGetCodecConfig
81142858 g     F .text	00000148 OSTmrStart
81105278 g     F .text	00000038 vFeebCh5HandleIrq
811228e4 g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
8115448c g       *ABS*	00000000 __bss_start
81105ab4 g     F .text	000000d4 bFeebCh4SetBufferSize
81123b2c g     F .text	00000128 memset
81115244 g     F .text	0000013c setPreParsedFreePos
8110f71c g     F .text	0000025c vQCmdFEEinStandBy
8114b060 g     F .text	00000060 alt_msgdma_open
8111fbf4 g     F .text	00000210 pattern_createPattern
81118bcc g     F .text	00000220 main
8111c9ac g     F .text	00000080 vFailGetMutexReceiverTask
81160420 g     O .bss	00001000 vNFeeControlTask_stk
811070cc g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
8111f954 g     F .text	0000003c vChangeEPValue
81107218 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
811545cc g     O .bss	00000004 alt_envp
8111ea1c g     F .text	00000064 vFailFlushQueue
81154594 g     O .bss	00000004 __malloc_max_total_mem
8114a904 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8111c330 g     F .text	0000005c ucCrc8wInit
8111d5b0 g     F .text	00000064 vCouldNotCheckBufferTimeOutFunction
8114785c g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f9c g     F .text	000002c8 POWER_Read
8110b028 g     F .text	00000160 i2c_read
81161420 g     O .bss	00000020 SyncTBL5
8112a638 g     F .text	00000018 __swbuf
811521f0 g     O .rodata	00000100 OSUnMapTbl
811360bc g     F .text	000000c8 .hidden __ltsf2
81146bf8 g     F .text	00000090 alt_up_sd_card_get_attributes
8112c824 g     F .text	00000234 _fread_r
8111c82c g     F .text	00000080 vFailGetCountSemaphoreSenderTask
8110a81c g     F .text	0000003c bDisableIsoDrivers
8115444a g     O .rwdata	00000002 OSSemEn
81143424 g     F .text	000000bc Write_Sector_Data
81147008 g     F .text	00000628 alt_up_sd_card_write
81154558 g     O .bss	00000004 xFeeQ
811064c0 g     F .text	00000068 bFeebGetCh1RightBufferEmpty
8113c754 g     F .text	0000039c OSFlagPost
81124400 g     F .text	00000008 __sclose
8111d978 g     F .text	00000080 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
8113427c g     F .text	00000014 fclose
8113a600 g     F .text	00000118 OS_EventTaskWait
8111d7f8 g     F .text	00000080 vCouldNotRetransmitB32TimeoutTask
81124530 g     F .text	00000240 _strtol_r
811225c4 g     F .text	000001a8 .hidden __truncdfsf2
81161440 g     O .bss	00000020 xFeeQueueTBL2
8113b290 g     F .text	000000d4 OS_TaskStatStkChk
81141070 g     F .text	00000158 OSTaskDelReq
81104b98 g     F .text	000000c4 bDpktGetPacketHeader
81106bc8 g     F .text	000000ec vRmapCh1HandleIrq
8112aa78 g     F .text	00001690 _dtoa_r
8114ac20 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
811231c8 g     F .text	00000814 _malloc_r
81161460 g     O .bss	00000020 SyncTBL0
81135280 g     F .text	00000030 __ascii_wctomb
8113d8ec g     F .text	000001d0 OSMutexCreate
8111d778 g     F .text	00000080 vFailCouldNotRetransmitTimeoutTask
81112a34 g     F .text	0000014c bCheckInAck32
811543f0 g     O .rwdata	00000004 alt_errno
8114a74c g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
8113a0b8 g     F .text	00000078 OSStart
8110a1f8 g     F .text	000000e4 bSpwcGetLink
8110be40 g     F .text	000004e8 POWER_SPI_RW
811327c8 g     F .text	000000dc __submore
81138278 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
81139320 g     F .text	00000068 __env_unlock
8111dea8 g     F .text	00000080 vCoudlNotCreateNFee1Task
8112d39c g     F .text	000000cc _fwalk
81141524 g     F .text	000001dc OSTaskResume
8113d57c g     F .text	000000f0 OSMemQuery
8115445c g     O .rwdata	00000002 OSTaskStatEn
8116e6f8 g       *ABS*	00000000 __alt_stack_limit
8115449c g     O .bss	00000004 ECommSpwCh
8111fb40 g     F .text	0000003c vChangeAutoResetSync
8112d8ec g     F .text	00000064 _mbtowc_r
81112420 g     F .text	00000380 vInAckHandlerTaskV2
81154436 g     O .rwdata	00000002 OSMemMax
8113f44c g     F .text	00000178 OSQPostFront
81123d64 g     F .text	000000d0 putc
81135dd4 g     F .text	00000084 .hidden __divsi3
81154629 g     O .bss	00000006 OSRdyTbl
81154410 g     O .rwdata	00000002 OSDebugEn
81153154 g     O .rwdata	0000002a alt_log_msg_cache
8112ca94 g     F .text	0000012c _malloc_trim_r
81109c14 g     F .text	000001a4 bRmapInitCh
81154588 g     O .bss	00000008 xSdHandle
81120c20 g     F .text	00000404 .hidden __mulsf3
81154428 g     O .rwdata	00000002 OSFlagNodeSize
81154490 g     O .bss	00000004 pnt_memory
8111fbac g     F .text	00000048 vSyncReset
81111ef8 g     F .text	00000528 vLoadCtemp
8110cd94 g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
81154660 g     O .bss	00000004 status_register
81154470 g     O .rwdata	00000002 OSTmrCfgMax
8110d728 g     F .text	00000074 bSyncIrqFlagClrError
8111d2a0 g     F .text	00000080 vFailSetPreAckSenderBuffer
8112f30c g     F .text	000000dc strcmp
81154668 g     O .bss	00000004 command_register
8113e9d8 g     F .text	000001b4 OSQCreate
811411c8 g     F .text	000001a0 OSTaskNameGet
81161480 g     O .bss	00001000 vFeeTask4_stk
81162480 g     O .bss	00000018 xReceivedACK
8113f5c4 g     F .text	00000214 OSQPostOpt
8113a1e8 g     F .text	00000228 OSTimeTick
81154458 g     O .rwdata	00000002 OSTaskMax
8113faa4 g     F .text	000000e0 OSSemCreate
8115447c g     O .rwdata	00000002 OSTmrWheelSize
8111dc98 g     F .text	00000080 vFailCreateScheduleQueue
81120328 g     F .text	00000058 _reg_read
8113e584 g     F .text	00000174 OSMutexQuery
81111100 g     F .text	000000a4 bSendGiveBackNFeeCtrl
81137328 g     F .text	00000088 .hidden __nedf2
81154452 g     O .rwdata	00000002 OSTaskDelEn
8111f91c g     F .text	00000038 vLoadDefaultEPValue
81162498 g     O .bss	00001000 vFeeTask1_stk
8110d558 g     F .text	00000074 bSyncCtrCh7OutEnable
8114026c g     F .text	00000118 OSSemQuery
8113eb8c g     F .text	00000288 OSQDel
8113f168 g     F .text	00000174 OSQPendAbort
8115455c g     O .bss	00000004 xMutexPreParsed
811432f4 g     F .text	00000040 alt_irq_init
81138cac g     F .text	0000006c alt_release_fd
81143614 g     F .text	000000bc get_cluster_flag
8110d79c g     F .text	00000074 bSyncIrqFlagClrBlank
8114b358 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110cae0 g     F .text	0000002c vSyncClearCounter
81111b0c g     F .text	000003ec bPrepareDoubleBuffer
81153120 g     O .rwdata	00000031 alt_log_msg_stackpointer
81124240 g     F .text	00000074 sprintf
811518d8 g     O .rodata	00000100 .hidden __clz_tab
81143be8 g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
8111ca2c g     F .text	00000080 vFailGetMutexTxUARTSenderTask
811545a0 g     O .bss	00000004 _PathLocale
8110d868 g     F .text	00000058 bSyncIrqFlagBlank
8110bcf8 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
811429a0 g     F .text	000001e8 OSTmrStop
81109e0c g     F .text	00000050 uliRmapReadReg
8111a264 g     F .text	00000050 usiGetIdCMD
8110d994 g     F .text	00000058 uliSyncReadReg
81130a6c g     F .text	00000108 strtof
81105208 g     F .text	00000038 vFeebCh3HandleIrq
81136000 g     F .text	000000bc .hidden __gesf2
81124408 g     F .text	0000004c strcspn
8112a650 g     F .text	00000068 _write_r
8110c394 g     F .text	00000074 vRstcReleaseDeviceReset
8111d484 g     F .text	00000064 vFailInAckHandlerTaskCreate
81139f40 g     F .text	00000094 OSSchedLock
8111dfa8 g     F .text	00000080 vCoudlNotCreateNFee3Task
8112d680 g     F .text	00000018 setlocale
8114a6ac g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
8116a92c g     O .bss	00000800 OSTmrTaskStk
81124164 g     F .text	00000044 scanf
8111e2a8 g     F .text	00000078 vFailCreateMutexSPUSQueueMeb
8113bb48 g     F .text	00000110 OSFlagCreate
81143e7c g     F .text	00000688 Check_for_DOS_FAT
811170c0 g     F .text	00000064 vMebInit
81145d28 g     F .text	000002d0 create_file
8112f304 g     F .text	00000008 nanf
811543c4 g     O .rwdata	00000004 _impure_ptr
81154664 g     O .bss	00000004 CSD_register_w0
811545c4 g     O .bss	00000004 alt_argc
8111ce20 g     F .text	00000080 vFailGetCountSemaphorexBuffer128
8112c108 g     F .text	00000224 __sflush_r
8112d70c g     F .text	000000b4 _mbrtowc_r
8110a4a0 g     F .text	00000090 bSpwcGetTimecode
8112d66c g     F .text	00000008 __locale_cjk_lang
811033a4 g     F .text	0000078c sense_log
811544a0 g     O .bss	00000004 ESdmaBufferSide
81154422 g     O .rwdata	00000002 OSEventMultiEn
81122a08 g     F .text	00000004 _fseek_r
81163498 g     O .bss	00001800 vParserCommTask_stk
8111c46c g     F .text	00000070 printErrorTask
8111f990 g     F .text	00000030 vChangeDefaultEPValue
81118180 g     F .text	000002c8 vCheckRetransmission32
81142170 g     F .text	000001c4 OSTmrCreate
8111726c g     F .text	000007dc vStackMonitor
81123f2c g     F .text	000001dc __srefill_r
8110a858 g     F .text	0000003c bEnableLvdsBoard
81154560 g     O .bss	00000004 xMutexBuffer32
81154508 g     O .bss	00000001 ucIterationSide
81106cb4 g     F .text	000000ec vRmapCh2HandleIrq
8113bc58 g     F .text	00000250 OSFlagDel
81154630 g     O .bss	00000004 OSEventFreeList
8110a8d0 g     F .text	000000c0 bSetPreEmphasys
8110f4d8 g     F .text	00000244 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
8112d8a0 g     F .text	0000004c __ascii_mbtowc
8110d064 g     F .text	00000078 bSyncCtrExtnIrq
81106528 g     F .text	00000068 bFeebGetCh2LeftBufferEmpty
8112e6f4 g     F .text	00000064 __ulp
8111f4c8 g     F .text	0000010c vNFeeControlInit
81117124 g     F .text	000000a4 vSwapMemmory
8113c12c g     F .text	000005c0 OSFlagPend
8115446e g     O .rwdata	00000002 OSTmrEn
8112c760 g     F .text	00000018 __fp_unlock_all
81164c98 g     O .bss	00000010 xDma
811229a4 g     F .text	00000064 fputc
81110e40 g     F .text	00000058 bEnableRmapIRQ
8111997c g     F .text	00000328 bSendUART32v2
811154fc g     F .text	000001b4 setPreAckReceiverFreePos
8110d024 g     F .text	00000040 bSyncErrInj
811543dc g     O .rwdata	00000008 alt_fs_list
81164ca8 g     O .bss	00001000 vSimMebTask_stk
8111e228 g     F .text	00000080 vCoudlNotCreateMebTask
811446c4 g     F .text	00000274 check_file_name_for_FAT16_compliance
81165ca8 g     O .bss	00001000 vFeeTask3_stk
81142474 g     F .text	00000140 OSTmrNameGet
811548f8 g     O .bss	00000400 xSZData
8110f978 g     F .text	00000288 vQCmdFEEinFullPattern
8113b070 g     F .text	0000007c OS_StrCopy
81154670 g     O .bss	00000004 buffer_memory
8111d0a0 g     F .text	00000080 vFailGetxMutexPreParsedParserRxTask
8111f798 g     F .text	00000098 vLogWriteNUC
81154438 g     O .rwdata	00000002 OSMemNameSize
81103b30 g     F .text	000000bc bSdmaInitM1Dma
8110d6b4 g     F .text	00000074 bSyncIrqEnableBlank
8114c2b8 g     F .text	00000028 OSInitHookEnd
8111eef8 g     F .text	00000340 vUpdateMemMapFEE
8111d3a0 g     F .text	00000080 vFailSetPreAckReceiverBuffer
811057e0 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
81154464 g     O .rwdata	00000002 OSTCBPrioTblMax
8112d698 g     F .text	0000000c localeconv
8111e1a8 g     F .text	00000080 vCoudlNotCreateDataControllerTask
81154564 g     O .bss	00000004 xTimerRetransmission
81114fc0 g     F .text	00000284 vReceiverUartTask
811545c0 g     O .bss	00000004 alt_log_sys_clk_count
81154460 g     O .rwdata	00000002 OSTaskStatStkChkEn
811384c8 g     F .text	00000140 alt_log_write
81166ca8 g     O .bss	00001000 vFeeTask2_stk
81154568 g     O .bss	00000004 xMutexBuffer128
81105198 g     F .text	00000038 vFeebCh1HandleIrq
811201d0 g     F .text	0000003c bStartSync
811052e8 g     F .text	00000038 vFeebCh7HandleIrq
8112020c g     F .text	00000030 bStopSync
811544a4 g     O .bss	00000004 ECommBufferSide
8114b890 g     F .text	00000058 alt_ic_isr_register
81154434 g     O .rwdata	00000002 OSMemEn
81106da0 g     F .text	00000038 vRmapCh3HandleIrq
811543b0 g     O .rwdata	00000004 alt_stack_limit_value
811169ec g     F .text	00000420 vPusType252run
8111e8f0 g     F .text	00000064 vFailSendMsgMasterSyncMeb
81122fc8 g     F .text	0000003c fwrite
81154674 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
8115443e g     O .rwdata	00000002 OSMutexEn
8111e5e8 g     F .text	00000080 vCouldNotGetQueueMaskDataCtrl
8115448c g       *ABS*	00000000 _edata
81148710 g     F .text	00000068 altera_avalon_uart_read_fd
8111f648 g     F .text	00000034 vLoadDefaultIdNFEEMaster
81105080 g     F .text	0000008c usiAdcPxDelayCalcPeriodNs
8116e6f8 g       *ABS*	00000000 _end
8116e0f8 g     O .bss	00000500 active_files
81154634 g     O .bss	00000001 OSIntNesting
8111cb10 g     F .text	00000064 vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
8111f3c4 g     F .text	0000002c cFeeRMAPDump
811059e0 g     F .text	000000d4 bFeebCh3SetBufferSize
8115456c g     O .bss	00000004 xSemCountBuffer32
81134290 g     F .text	0000016c __fputwc
81154570 g     O .bss	00000004 xQMaskFeeCtrl
8111f314 g     F .text	0000002c vFeeSpwRMAPChangeConfig
8112a410 g     F .text	00000070 vfscanf
81145ff8 g     F .text	00000150 copy_file_record_name_to_string
81147f80 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
81141ec8 g     F .text	000001dc OSTimeDlyResume
81144504 g     F .text	000000f4 Look_for_FAT16
81110e98 g     F .text	00000060 bDisableSPWChannel
8113bfd8 g     F .text	00000154 OSFlagNameSet
81110ff0 g     F .text	0000006c bDisAndClrDbBuffer
81154574 g     O .bss	00000004 xMutexBuffer64
81107c48 g     F .text	00000160 bRmapGetCodecError
81141700 g     F .text	000001c8 OSTaskStkChk
8114b978 g     F .text	00000094 alt_ic_irq_disable
81103cb0 g     F .text	00000454 bSdmaDmaM1Transfer
8115443a g     O .rwdata	00000002 OSMemSize
811164f0 g     F .text	00000260 vPusType252conf
8111cca0 g     F .text	00000080 vFailSetCountSemaphorexBuffer32
81124318 g     F .text	00000084 __swrite
811543cc g     O .rwdata	00000004 __malloc_trim_threshold
8112d660 g     F .text	0000000c __locale_msgcharset
81167ca8 g     O .bss	00000020 xFeeQueueTBL1
81154638 g     O .bss	00000004 OSTCBCur
8111d878 g     F .text	00000080 vCouldNotRetransmitB64TimeoutTask
8110bdfc g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
8114c3d8 g     F .text	00000040 exit
8113e364 g     F .text	00000220 OSMutexPost
8110d810 g     F .text	00000058 bSyncIrqFlagError
81146424 g     F .text	000003c0 alt_up_sd_card_find_next
8115443c g     O .rwdata	00000002 OSMemTblSize
8112d468 g     F .text	000000cc _fwalk_reent
8114aaa4 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
81121150 g     F .text	000000f8 .hidden __floatunsisf
8112e4f0 g     F .text	00000204 __mdiff
8111de28 g     F .text	00000080 vCoudlNotCreateNFee0Task
81105ed8 g     F .text	0000017c vFeebInitIrq
81104840 g     F .text	0000022c bDpktSetPacketConfig
8111cbd8 g     F .text	00000064 vFailSenderCreate
81135e58 g     F .text	00000074 .hidden __modsi3
8111e0a8 g     F .text	00000080 vCoudlNotCreateNFee5Task
8110cf70 g     F .text	0000003c uliSyncGetPer
81106e48 g     F .text	00000038 vRmapCh6HandleIrq
81154578 g     O .bss	00000004 xMutexSenderACK
8111d678 g     F .text	00000080 vFailGetBlockingSemTimeoutTask
811543bc g     O .rwdata	00000004 __ctype_ptr__
8111d320 g     F .text	00000080 vFailSetPreParsedBuffer
81143534 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
8112c73c g     F .text	00000004 __sfp_lock_release
81106128 g     F .text	000000ac bFeebGetIrqControl
8111d9f8 g     F .text	00000080 vCouldNotSendTurnOff
81139d88 g     F .text	00000064 OSInit
8110b208 g     F .text	00000078 bSetPainelLeds
8114a1ec g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
8115463c g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
81107da8 g     F .text	000002ec bRmapSetMemConfigArea
81141ab4 g     F .text	0000012c OSTaskQuery
8110d640 g     F .text	00000074 bSyncIrqEnableError
8115457c g     O .bss	00000004 xMutexPus
8113f93c g     F .text	000000b0 OS_QInit
8112f234 g     F .text	000000d0 __sccl
811227d0 g     F .text	0000000c atoi
8110db28 g     F .text	00001798 vFeeTask
8113b0ec g     F .text	0000005c OS_StrLen
8111eb48 g     F .text	00000064 vFailFlushNFEEQueue
811055d0 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
8111c38c g     F .text	000000e0 vDataControllerInit
8113d380 g     F .text	0000011c OSMemNameSet
811519d8 g     O .rodata	00000101 _ctype_
8110cf34 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
8111cda0 g     F .text	00000080 vFailSetCountSemaphorexBuffer128
81154456 g     O .rwdata	00000002 OSTaskProfileEn
8111ebac g     F .text	00000028 vEvtChangeMebMode
8114a0bc g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
81154580 g     O .bss	00000004 xTxUARTMutex
81154640 g     O .bss	00000004 OSTime
811543d4 g     O .rwdata	00000004 __mbtowc
81148d30 g     F .text	0000005c altera_avalon_uart_close
8110f2c0 g     F .text	00000218 vQCmdFEEinWaitingSync
81154644 g     O .bss	00000004 OSTmrSem
81116484 g     F .text	0000006c vPusType251conf
8116b12c g     O .bss	00001000 OSTaskIdleStk
811227e8 g     F .text	000000fc _fopen_r
8115451c g     O .bss	00000004 pdata
8114c708 g     F .text	000000bc _exit
81106368 g     F .text	00000078 bFeebGetLeftBufferEmpty
8114b3e0 g     F .text	00000134 alt_alarm_start
8113bea8 g     F .text	00000130 OSFlagNameGet
811420a4 g     F .text	00000064 OSTimeGet
811544a8 g     O .bss	00000004 ESdmaChBufferId
81146c88 g     F .text	00000380 alt_up_sd_card_read
81107000 g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
81123004 g     F .text	000001c4 __smakebuf_r
81154584 g     O .bss	00000001 SemCount64
81119654 g     F .text	00000328 bSendUART64v2
8111ea80 g     F .text	00000064 vFailFlushQueueData
81105680 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
81154484 g     O .rwdata	00000008 alt_msgdma_list
81124454 g     F .text	00000098 strlen
8110c638 g     F .text	000000b4 uc_spi_get_byte
81107044 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
8111e668 g     F .text	0000006c vFailSendMsgAccessDMA
8114c1e8 g     F .text	00000028 OSTaskSwHook
81138a08 g     F .text	0000015c open
81109448 g     F .text	000007cc bRmapGetRmapMemHKArea
8116c12c g     O .bss	00000d00 OSEventTbl
8111f340 g     F .text	0000002c vFeeSpwRMAPChangeDefault
81121248 g     F .text	000000dc .hidden __gedf2
8111e884 g     F .text	0000006c vFailSendMsgSyncRMAPTRIGGER
81167cc8 g     O .bss	00000020 xSenderACK
8114bedc g     F .text	00000044 alt_putchar
8116ce2c g     O .bss	000011b8 OSTCBTbl
811345a8 g     F .text	00000838 __gethex
81140384 g     F .text	00000108 OSSemSet
81117a48 g     F .text	00000084 vTimeoutCheckerTaskv2
8111f3f0 g     F .text	00000038 cFeeRMAPEchoingEnable
811543d8 g     O .rwdata	00000004 __wctomb
811188b8 g     F .text	00000314 vVariablesInitialization
81132b5c g     F .text	00000018 __sprint_r
81110284 g     F .text	000005e4 vQCmdFeeRMAPinFullPattern
811061d4 g     F .text	00000088 bFeebGetIrqFlags
81154498 g     O .bss	00000004 pxDmaM2Dev
8111c5b8 g     F .text	00000064 vFailCreateSemaphoreResources
811543f4 g     O .rwdata	00000004 alt_priority_mask
8110a894 g     F .text	0000003c bDisableLvdsBoard
8113fb84 g     F .text	00000248 OSSemDel
8110590c g     F .text	000000d4 bFeebCh2SetBufferSize
81154648 g     O .bss	00000004 OSFlagFreeList
8110c574 g     F .text	000000c4 v_spi_send_byte
8110c8c0 g     F .text	000000d0 bSSDisplayConfig
8114b8e8 g     F .text	00000090 alt_ic_irq_enable
8115441c g     O .rwdata	00000002 OSEventNameSize
81128b6c g     F .text	0000001c __vfprintf_internal
8115464c g     O .bss	00000001 OSStatRdy
8110d314 g     F .text	00000074 bSyncCtrCh2OutEnable
8116dfe4 g     O .bss	000000ac OSTCBPrioTbl
81148dd0 g     F .text	00000270 altera_avalon_uart_read
811352b0 g     F .text	00000064 _wctomb_r
81139254 g     F .text	000000cc __env_lock
81154462 g     O .rwdata	00000002 OSTaskSwHookEn
81154e10 g     O .bss	00000100 cTemp
811053e0 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
81121a44 g     F .text	00000904 .hidden __subdf3
81167ce8 g     O .bss	00000260 xPreParsed
8110cfac g     F .text	0000003c uliSyncGetOst
81154585 g     O .bss	00000001 SemCount128
81106eb8 g     F .text	00000038 vRmapCh8HandleIrq
811054ac g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
81119ca4 g     F .text	00000290 vSendEthConf
811046cc g     F .text	000000d0 bCommInitCh
8112df04 g     F .text	000000b0 __lo0bits
81128c4c g     F .text	000017c4 __svfscanf_r
81154400 g     O .rwdata	00000008 alt_alarm_list
811328a4 g     F .text	0000019c _ungetc_r
8115442a g     O .rwdata	00000002 OSFlagWidth
81106ef0 g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
811351b8 g     F .text	000000c8 wcrtomb
81104c5c g     F .text	00000148 bDpktSetPixelDelay
81119140 g     F .text	00000164 vCCDLoadDefaultValues
811376c8 g     F .text	000000d8 close
8110cfe8 g     F .text	0000003c uliSyncGetGeneral
8111ebfc g     F .text	00000028 vEvtChangeDataControllerMode
811545dc g     O .bss	00000004 alt_envsem
81137bf8 g     F .text	00000068 alt_log_repchar
81154650 g     O .bss	00000004 OSIdleCtrRun
8113a410 g     F .text	00000028 OSVersion
81154474 g     O .rwdata	00000002 OSTmrCfgWheelSize
81141be0 g     F .text	00000078 OS_TaskStkClr
8111ff5c g     F .text	0000003c siOpenFile
8110da70 g     F .text	000000b8 vDataControlTask
8115444e g     O .rwdata	00000002 OSTaskCreateEn
81107168 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
811075b0 g     F .text	00000050 uliRmapCh7WriteCmdAddress
81106808 g     F .text	00000088 bFeebStartCh
81119f34 g     F .text	00000118 vSendTurnOff
8111c700 g     F .text	00000064 vFailSendPreParsedSemaphore
811449f8 g     F .text	000002a4 match_file_record_to_name_ext
8113aa38 g     F .text	00000070 OS_EventWaitListInit
81134420 g     F .text	00000088 fputwc
81167f48 g     O .bss	00000020 xFeeQueueTBL0
8111c680 g     F .text	00000080 vFailSendxSemCommInit
8114c2e0 g     F .text	00000028 OSTaskIdleHook
8111a04c g     F .text	00000118 vSendReset
8112c740 g     F .text	00000004 __sinit_lock_acquire
8112dc68 g     F .text	00000128 __multadd
81167f68 g     O .bss	00000020 SyncTBL1
811054f0 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110cc38 g     F .text	0000004c ucSyncStatusState
811418c8 g     F .text	000001ec OSTaskSuspend
8112dc40 g     F .text	00000028 _Bfree
8110cef8 g     F .text	0000003c uliSyncGetMbt
8113b148 g     F .text	00000064 OS_TaskIdle
8115447a g     O .rwdata	00000002 OSTmrTblSize
8113f7d8 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	1139dec0 	call	81139dec <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045f4 	movhi	r2,33047
81100150:	10b97e04 	addi	r2,r2,-6664
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045f4 	movhi	r2,33047
81100168:	10b97e04 	addi	r2,r2,-6664
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	1139e400 	call	81139e40 <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b717 	ldw	r2,-32036(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b717 	ldw	r2,-32036(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	2110fe04 	addi	r4,r4,17400
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	210c5504 	addi	r4,r4,12628
81100274:	1137b700 	call	81137b70 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	2110fe04 	addi	r4,r4,17400
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	210c4804 	addi	r4,r4,12576
81100290:	1137b700 	call	81137b70 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d6b0ec14 	ori	gp,gp,50096
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	2110fe04 	addi	r4,r4,17400
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	210c3904 	addi	r4,r4,12516
811002bc:	1137b700 	call	81137b70 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04574 	movhi	r2,33045
    ori r2, r2, %lo(__bss_start)
811002c4:	10912314 	ori	r2,r2,17548

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18f9be14 	ori	r3,r3,59128

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	2110fe04 	addi	r4,r4,17400
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	210c4004 	addi	r4,r4,12544
811002fc:	1137b700 	call	81137b70 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	113879c0 	call	8113879c <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18d1fe04 	addi	r3,r3,18424
81100330:	00a04574 	movhi	r2,33045
81100334:	10b1f104 	addi	r2,r2,-14396
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	11239dc0 	call	811239dc <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a06217 	ldw	r2,-32376(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	2951fe04 	addi	r5,r5,18424
8110035c:	1009883a 	mov	r4,r2
81100360:	112292c0 	call	8112292c <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18d1fe04 	addi	r3,r3,18424
811003cc:	00a04574 	movhi	r2,33045
811003d0:	10b1fa04 	addi	r2,r2,-14360
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	11239dc0 	call	811239dc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a06217 	ldw	r2,-32376(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	2951fe04 	addi	r5,r5,18424
811003f8:	1009883a 	mov	r4,r2
811003fc:	112292c0 	call	8112292c <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18d1fe04 	addi	r3,r3,18424
81100410:	00a04574 	movhi	r2,33045
81100414:	10b20604 	addi	r2,r2,-14312
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	11239dc0 	call	811239dc <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a06217 	ldw	r2,-32376(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	2951fe04 	addi	r5,r5,18424
8110043c:	1009883a 	mov	r4,r2
81100440:	112292c0 	call	8112292c <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	1138fc80 	call	81138fc8 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	110ab740 	call	8110ab74 <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#if DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604574 	movhi	r5,33045
811004b0:	29720c04 	addi	r5,r5,-14288
811004b4:	01204574 	movhi	r4,33045
811004b8:	2111fe04 	addi	r4,r4,18424
811004bc:	11242400 	call	81124240 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a06217 	ldw	r2,-32376(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	2951fe04 	addi	r5,r5,18424
811004cc:	1009883a 	mov	r4,r2
811004d0:	112292c0 	call	8112292c <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#if DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18d1fe04 	addi	r3,r3,18424
811004e0:	00a04574 	movhi	r2,33045
811004e4:	10b21104 	addi	r2,r2,-14268
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	11239dc0 	call	811239dc <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a06217 	ldw	r2,-32376(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	2951fe04 	addi	r5,r5,18424
8110050c:	1009883a 	mov	r4,r2
81100510:	112292c0 	call	8112292c <fprintf>
#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18d1fe04 	addi	r3,r3,18424
81100544:	00a04574 	movhi	r2,33045
81100548:	10b21704 	addi	r2,r2,-14244
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	11239dc0 	call	811239dc <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a06217 	ldw	r2,-32376(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	2951fe04 	addi	r5,r5,18424
81100570:	1009883a 	mov	r4,r2
81100574:	112292c0 	call	8112292c <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18d1fe04 	addi	r3,r3,18424
81100584:	00a04574 	movhi	r2,33045
81100588:	10b22004 	addi	r2,r2,-14208
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	11239dc0 	call	811239dc <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a06217 	ldw	r2,-32376(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	2951fe04 	addi	r5,r5,18424
811005b0:	1009883a 	mov	r4,r2
811005b4:	112292c0 	call	8112292c <fprintf>
#endif
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18d1fe04 	addi	r3,r3,18424
811005c0:	00a04574 	movhi	r2,33045
811005c4:	10b22804 	addi	r2,r2,-14176
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	11239dc0 	call	811239dc <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a06217 	ldw	r2,-32376(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	2951fe04 	addi	r5,r5,18424
811005ec:	1009883a 	mov	r4,r2
811005f0:	112292c0 	call	8112292c <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	1138fc80 	call	81138fc8 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	110aa940 	call	8110aa94 <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#if DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18d1fe04 	addi	r3,r3,18424
81100650:	00a04574 	movhi	r2,33045
81100654:	10b22e04 	addi	r2,r2,-14152
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	11239dc0 	call	811239dc <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a06217 	ldw	r2,-32376(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	2951fe04 	addi	r5,r5,18424
8110067c:	1009883a 	mov	r4,r2
81100680:	112292c0 	call	8112292c <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	110ab740 	call	8110ab74 <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#if DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18d1fe04 	addi	r3,r3,18424
811006cc:	00a04574 	movhi	r2,33045
811006d0:	10b23404 	addi	r2,r2,-14128
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	11239dc0 	call	811239dc <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a06217 	ldw	r2,-32376(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	2951fe04 	addi	r5,r5,18424
811006f8:	1009883a 	mov	r4,r2
811006fc:	112292c0 	call	8112292c <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604574 	movhi	r5,33045
81100730:	29723d04 	addi	r5,r5,-14092
81100734:	01204574 	movhi	r4,33045
81100738:	2111fe04 	addi	r4,r4,18424
8110073c:	11242400 	call	81124240 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a06217 	ldw	r2,-32376(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	2951fe04 	addi	r5,r5,18424
8110074c:	1009883a 	mov	r4,r2
81100750:	112292c0 	call	8112292c <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18d1fe04 	addi	r3,r3,18424
81100764:	00a04574 	movhi	r2,33045
81100768:	10b24c04 	addi	r2,r2,-14032
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	11239dc0 	call	811239dc <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a06217 	ldw	r2,-32376(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	2951fe04 	addi	r5,r5,18424
81100790:	1009883a 	mov	r4,r2
81100794:	112292c0 	call	8112292c <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18d1fe04 	addi	r3,r3,18424
811007a4:	00a04574 	movhi	r2,33045
811007a8:	10b25504 	addi	r2,r2,-13996
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	11239dc0 	call	811239dc <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a06217 	ldw	r2,-32376(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	2951fe04 	addi	r5,r5,18424
811007d0:	1009883a 	mov	r4,r2
811007d4:	112292c0 	call	8112292c <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	1091fe04 	addi	r2,r2,18424
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a06217 	ldw	r2,-32376(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	2951fe04 	addi	r5,r5,18424
811007f8:	1009883a 	mov	r4,r2
811007fc:	112292c0 	call	8112292c <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18d1fe04 	addi	r3,r3,18424
81100840:	00a04574 	movhi	r2,33045
81100844:	10b25d04 	addi	r2,r2,-13964
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	11239dc0 	call	811239dc <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a06217 	ldw	r2,-32376(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	2951fe04 	addi	r5,r5,18424
8110086c:	1009883a 	mov	r4,r2
81100870:	112292c0 	call	8112292c <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18d1fe04 	addi	r3,r3,18424
811008dc:	00a04574 	movhi	r2,33045
811008e0:	10b26604 	addi	r2,r2,-13928
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	11239dc0 	call	811239dc <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a06217 	ldw	r2,-32376(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	2951fe04 	addi	r5,r5,18424
81100908:	1009883a 	mov	r4,r2
8110090c:	112292c0 	call	8112292c <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	110ac7c0 	call	8110ac7c <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604574 	movhi	r5,33045
81100984:	29727204 	addi	r5,r5,-13880
81100988:	01204574 	movhi	r4,33045
8110098c:	2111fe04 	addi	r4,r4,18424
81100990:	11242400 	call	81124240 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a06217 	ldw	r2,-32376(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	2951fe04 	addi	r5,r5,18424
811009a0:	1009883a 	mov	r4,r2
811009a4:	112292c0 	call	8112292c <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#if DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18d1fe04 	addi	r3,r3,18424
811009c0:	00a04574 	movhi	r2,33045
811009c4:	10b27e04 	addi	r2,r2,-13832
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	11239dc0 	call	811239dc <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a06217 	ldw	r2,-32376(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	2951fe04 	addi	r5,r5,18424
811009ec:	1009883a 	mov	r4,r2
811009f0:	112292c0 	call	8112292c <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18d1fe04 	addi	r3,r3,18424
81100a0c:	00a04574 	movhi	r2,33045
81100a10:	10b28a04 	addi	r2,r2,-13784
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a06217 	ldw	r2,-32376(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	2951fe04 	addi	r5,r5,18424
81100a38:	1009883a 	mov	r4,r2
81100a3c:	112292c0 	call	8112292c <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18d1fe04 	addi	r3,r3,18424
81100a58:	00a04574 	movhi	r2,33045
81100a5c:	10b29204 	addi	r2,r2,-13752
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	11239dc0 	call	811239dc <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a06217 	ldw	r2,-32376(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	2951fe04 	addi	r5,r5,18424
81100a84:	1009883a 	mov	r4,r2
81100a88:	112292c0 	call	8112292c <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18d1fe04 	addi	r3,r3,18424
81100aa4:	00a04574 	movhi	r2,33045
81100aa8:	10b29c04 	addi	r2,r2,-13712
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	11239dc0 	call	811239dc <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a06217 	ldw	r2,-32376(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	2951fe04 	addi	r5,r5,18424
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	112292c0 	call	8112292c <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18d1fe04 	addi	r3,r3,18424
81100af0:	00a04574 	movhi	r2,33045
81100af4:	10b2a704 	addi	r2,r2,-13668
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	11239dc0 	call	811239dc <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a06217 	ldw	r2,-32376(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	2951fe04 	addi	r5,r5,18424
81100b1c:	1009883a 	mov	r4,r2
81100b20:	112292c0 	call	8112292c <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18d1fe04 	addi	r3,r3,18424
81100b3c:	00a04574 	movhi	r2,33045
81100b40:	10b2b304 	addi	r2,r2,-13620
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a06217 	ldw	r2,-32376(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	2951fe04 	addi	r5,r5,18424
81100b68:	1009883a 	mov	r4,r2
81100b6c:	112292c0 	call	8112292c <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18d1fe04 	addi	r3,r3,18424
81100b88:	00a04574 	movhi	r2,33045
81100b8c:	10b2b904 	addi	r2,r2,-13596
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a06217 	ldw	r2,-32376(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	2951fe04 	addi	r5,r5,18424
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	112292c0 	call	8112292c <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18d1fe04 	addi	r3,r3,18424
81100bd4:	00a04574 	movhi	r2,33045
81100bd8:	10b2c104 	addi	r2,r2,-13564
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	11239dc0 	call	811239dc <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a06217 	ldw	r2,-32376(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	2951fe04 	addi	r5,r5,18424
81100c00:	1009883a 	mov	r4,r2
81100c04:	112292c0 	call	8112292c <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18d1fe04 	addi	r3,r3,18424
81100c20:	00a04574 	movhi	r2,33045
81100c24:	10b2ce04 	addi	r2,r2,-13512
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a06217 	ldw	r2,-32376(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	2951fe04 	addi	r5,r5,18424
81100c4c:	1009883a 	mov	r4,r2
81100c50:	112292c0 	call	8112292c <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18d1fe04 	addi	r3,r3,18424
81100c6c:	00a04574 	movhi	r2,33045
81100c70:	10b2d404 	addi	r2,r2,-13488
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a06217 	ldw	r2,-32376(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	2951fe04 	addi	r5,r5,18424
81100c98:	1009883a 	mov	r4,r2
81100c9c:	112292c0 	call	8112292c <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18d1fe04 	addi	r3,r3,18424
81100cb8:	00a04574 	movhi	r2,33045
81100cbc:	10b2d904 	addi	r2,r2,-13468
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a06217 	ldw	r2,-32376(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	2951fe04 	addi	r5,r5,18424
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	112292c0 	call	8112292c <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18d1fe04 	addi	r3,r3,18424
81100d04:	00a04574 	movhi	r2,33045
81100d08:	10b2e004 	addi	r2,r2,-13440
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	11239dc0 	call	811239dc <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a06217 	ldw	r2,-32376(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	2951fe04 	addi	r5,r5,18424
81100d30:	1009883a 	mov	r4,r2
81100d34:	112292c0 	call	8112292c <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18d1fe04 	addi	r3,r3,18424
81100d50:	00a04574 	movhi	r2,33045
81100d54:	10b2ee04 	addi	r2,r2,-13384
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	11239dc0 	call	811239dc <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a06217 	ldw	r2,-32376(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	2951fe04 	addi	r5,r5,18424
81100d7c:	1009883a 	mov	r4,r2
81100d80:	112292c0 	call	8112292c <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18d1fe04 	addi	r3,r3,18424
81100d9c:	00a04574 	movhi	r2,33045
81100da0:	10b30004 	addi	r2,r2,-13312
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a06217 	ldw	r2,-32376(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	2951fe04 	addi	r5,r5,18424
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	112292c0 	call	8112292c <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18d1fe04 	addi	r3,r3,18424
81100de8:	00a04574 	movhi	r2,33045
81100dec:	10b30804 	addi	r2,r2,-13280
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	11239dc0 	call	811239dc <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a06217 	ldw	r2,-32376(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	2951fe04 	addi	r5,r5,18424
81100e14:	1009883a 	mov	r4,r2
81100e18:	112292c0 	call	8112292c <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18d1fe04 	addi	r3,r3,18424
81100e34:	00a04574 	movhi	r2,33045
81100e38:	10b31204 	addi	r2,r2,-13240
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	11239dc0 	call	811239dc <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a06217 	ldw	r2,-32376(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	2951fe04 	addi	r5,r5,18424
81100e60:	1009883a 	mov	r4,r2
81100e64:	112292c0 	call	8112292c <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18d1fe04 	addi	r3,r3,18424
81100e80:	00a04574 	movhi	r2,33045
81100e84:	10b31f04 	addi	r2,r2,-13188
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	11239dc0 	call	811239dc <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a06217 	ldw	r2,-32376(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	2951fe04 	addi	r5,r5,18424
81100eac:	1009883a 	mov	r4,r2
81100eb0:	112292c0 	call	8112292c <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18d1fe04 	addi	r3,r3,18424
81100ecc:	00a04574 	movhi	r2,33045
81100ed0:	10b32904 	addi	r2,r2,-13148
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	11239dc0 	call	811239dc <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a06217 	ldw	r2,-32376(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	2951fe04 	addi	r5,r5,18424
81100ef8:	1009883a 	mov	r4,r2
81100efc:	112292c0 	call	8112292c <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18d1fe04 	addi	r3,r3,18424
81100f18:	00a04574 	movhi	r2,33045
81100f1c:	10b33404 	addi	r2,r2,-13104
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	11239dc0 	call	811239dc <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a06217 	ldw	r2,-32376(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	2951fe04 	addi	r5,r5,18424
81100f44:	1009883a 	mov	r4,r2
81100f48:	112292c0 	call	8112292c <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18d1fe04 	addi	r3,r3,18424
81100f64:	00a04574 	movhi	r2,33045
81100f68:	10b34504 	addi	r2,r2,-13036
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	11239dc0 	call	811239dc <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a06217 	ldw	r2,-32376(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	2951fe04 	addi	r5,r5,18424
81100f90:	1009883a 	mov	r4,r2
81100f94:	112292c0 	call	8112292c <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18d1fe04 	addi	r3,r3,18424
81100fb0:	00a04574 	movhi	r2,33045
81100fb4:	10b35004 	addi	r2,r2,-12992
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	11239dc0 	call	811239dc <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a06217 	ldw	r2,-32376(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	2951fe04 	addi	r5,r5,18424
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	112292c0 	call	8112292c <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18d1fe04 	addi	r3,r3,18424
81100ffc:	00a04574 	movhi	r2,33045
81101000:	10b35d04 	addi	r2,r2,-12940
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	11239dc0 	call	811239dc <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a06217 	ldw	r2,-32376(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	2951fe04 	addi	r5,r5,18424
81101028:	1009883a 	mov	r4,r2
8110102c:	112292c0 	call	8112292c <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18d1fe04 	addi	r3,r3,18424
81101048:	00a04574 	movhi	r2,33045
8110104c:	10b36b04 	addi	r2,r2,-12884
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	11239dc0 	call	811239dc <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a06217 	ldw	r2,-32376(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	2951fe04 	addi	r5,r5,18424
81101074:	1009883a 	mov	r4,r2
81101078:	112292c0 	call	8112292c <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#if DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18d1fe04 	addi	r3,r3,18424
81101094:	00a04574 	movhi	r2,33045
81101098:	10b37804 	addi	r2,r2,-12832
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	11239dc0 	call	811239dc <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a06217 	ldw	r2,-32376(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	2951fe04 	addi	r5,r5,18424
811010c0:	1009883a 	mov	r4,r2
811010c4:	112292c0 	call	8112292c <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18d1fe04 	addi	r3,r3,18424
811010e0:	00a04574 	movhi	r2,33045
811010e4:	10b38504 	addi	r2,r2,-12780
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a06217 	ldw	r2,-32376(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	2951fe04 	addi	r5,r5,18424
8110110c:	1009883a 	mov	r4,r2
81101110:	112292c0 	call	8112292c <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	1091fe04 	addi	r2,r2,18424
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a06217 	ldw	r2,-32376(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	2951fe04 	addi	r5,r5,18424
81101194:	1009883a 	mov	r4,r2
81101198:	112292c0 	call	8112292c <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18d1fe04 	addi	r3,r3,18424
811011b4:	00a04574 	movhi	r2,33045
811011b8:	10b38904 	addi	r2,r2,-12764
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a06217 	ldw	r2,-32376(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	2951fe04 	addi	r5,r5,18424
811011e0:	1009883a 	mov	r4,r2
811011e4:	112292c0 	call	8112292c <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#if DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18d1fe04 	addi	r3,r3,18424
81101200:	00a04574 	movhi	r2,33045
81101204:	10b39104 	addi	r2,r2,-12732
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	11239dc0 	call	811239dc <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a06217 	ldw	r2,-32376(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	2951fe04 	addi	r5,r5,18424
8110122c:	1009883a 	mov	r4,r2
81101230:	112292c0 	call	8112292c <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18d1fe04 	addi	r3,r3,18424
8110124c:	00a04574 	movhi	r2,33045
81101250:	10b39f04 	addi	r2,r2,-12676
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a06217 	ldw	r2,-32376(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	2951fe04 	addi	r5,r5,18424
81101278:	1009883a 	mov	r4,r2
8110127c:	112292c0 	call	8112292c <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18d1fe04 	addi	r3,r3,18424
81101298:	00a04574 	movhi	r2,33045
8110129c:	10b3a704 	addi	r2,r2,-12644
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a06217 	ldw	r2,-32376(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	2951fe04 	addi	r5,r5,18424
811012c4:	1009883a 	mov	r4,r2
811012c8:	112292c0 	call	8112292c <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#if DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18d1fe04 	addi	r3,r3,18424
811012e4:	00a04574 	movhi	r2,33045
811012e8:	10b3af04 	addi	r2,r2,-12612
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	11239dc0 	call	811239dc <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a06217 	ldw	r2,-32376(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	2951fe04 	addi	r5,r5,18424
81101310:	1009883a 	mov	r4,r2
81101314:	112292c0 	call	8112292c <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18d1fe04 	addi	r3,r3,18424
81101330:	00a04574 	movhi	r2,33045
81101334:	10b3b904 	addi	r2,r2,-12572
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a06217 	ldw	r2,-32376(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	2951fe04 	addi	r5,r5,18424
8110135c:	1009883a 	mov	r4,r2
81101360:	112292c0 	call	8112292c <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18d1fe04 	addi	r3,r3,18424
8110137c:	00a04574 	movhi	r2,33045
81101380:	10b3c004 	addi	r2,r2,-12544
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	11239dc0 	call	811239dc <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a06217 	ldw	r2,-32376(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	2951fe04 	addi	r5,r5,18424
811013a8:	1009883a 	mov	r4,r2
811013ac:	112292c0 	call	8112292c <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#if DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18d1fe04 	addi	r3,r3,18424
811013c8:	00a04574 	movhi	r2,33045
811013cc:	10b3ca04 	addi	r2,r2,-12504
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a06217 	ldw	r2,-32376(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	2951fe04 	addi	r5,r5,18424
811013f4:	1009883a 	mov	r4,r2
811013f8:	112292c0 	call	8112292c <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#if DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	1091fe04 	addi	r2,r2,18424
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a06217 	ldw	r2,-32376(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	2951fe04 	addi	r5,r5,18424
81101420:	1009883a 	mov	r4,r2
81101424:	112292c0 	call	8112292c <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18d1fe04 	addi	r3,r3,18424
81101454:	00a04574 	movhi	r2,33045
81101458:	10b3d404 	addi	r2,r2,-12464
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	11239dc0 	call	811239dc <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a06217 	ldw	r2,-32376(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	2951fe04 	addi	r5,r5,18424
81101480:	1009883a 	mov	r4,r2
81101484:	112292c0 	call	8112292c <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	1091fe04 	addi	r2,r2,18424
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a06217 	ldw	r2,-32376(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	2951fe04 	addi	r5,r5,18424
811014a8:	1009883a 	mov	r4,r2
811014ac:	112292c0 	call	8112292c <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18d1fe04 	addi	r3,r3,18424
81101538:	00a04574 	movhi	r2,33045
8110153c:	10b3da04 	addi	r2,r2,-12440
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	11239dc0 	call	811239dc <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a06217 	ldw	r2,-32376(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	2951fe04 	addi	r5,r5,18424
81101564:	1009883a 	mov	r4,r2
81101568:	112292c0 	call	8112292c <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18d1fe04 	addi	r3,r3,18424
811015b4:	00a04574 	movhi	r2,33045
811015b8:	10b3e904 	addi	r2,r2,-12380
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	11239dc0 	call	811239dc <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a06217 	ldw	r2,-32376(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	2951fe04 	addi	r5,r5,18424
811015e0:	1009883a 	mov	r4,r2
811015e4:	112292c0 	call	8112292c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18d1fe04 	addi	r3,r3,18424
81101648:	00a04574 	movhi	r2,33045
8110164c:	10b1fa04 	addi	r2,r2,-14360
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	11239dc0 	call	811239dc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a06217 	ldw	r2,-32376(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	2951fe04 	addi	r5,r5,18424
81101674:	1009883a 	mov	r4,r2
81101678:	112292c0 	call	8112292c <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604574 	movhi	r5,33045
81101694:	2973f304 	addi	r5,r5,-12340
81101698:	01204574 	movhi	r4,33045
8110169c:	2111fe04 	addi	r4,r4,18424
811016a0:	11242400 	call	81124240 <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a06217 	ldw	r2,-32376(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	2951fe04 	addi	r5,r5,18424
811016b0:	1009883a 	mov	r4,r2
811016b4:	112292c0 	call	8112292c <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08917 	ldw	r2,-32220(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	10923e04 	addi	r2,r2,18680
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	10923e04 	addi	r2,r2,18680
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	10923e04 	addi	r2,r2,18680
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	10923e04 	addi	r2,r2,18680
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	10923e04 	addi	r2,r2,18680
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	10923e04 	addi	r2,r2,18680
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	10923e04 	addi	r2,r2,18680
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#if DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18d1fe04 	addi	r3,r3,18424
81101868:	00a04574 	movhi	r2,33045
8110186c:	10b3f904 	addi	r2,r2,-12316
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	11239dc0 	call	811239dc <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a06217 	ldw	r2,-32376(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	2951fe04 	addi	r5,r5,18424
81101894:	1009883a 	mov	r4,r2
81101898:	112292c0 	call	8112292c <fprintf>
8110189c:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	29523e04 	addi	r5,r5,18680
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	11239dc0 	call	811239dc <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604574 	movhi	r5,33045
81101990:	2973fe04 	addi	r5,r5,-12296
81101994:	01204574 	movhi	r4,33045
81101998:	2111fe04 	addi	r4,r4,18424
8110199c:	11242400 	call	81124240 <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a06217 	ldw	r2,-32376(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	2951fe04 	addi	r5,r5,18424
811019ac:	1009883a 	mov	r4,r2
811019b0:	112292c0 	call	8112292c <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	11377a00 	call	811377a0 <alt_dcache_flush_all>
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	1091fe04 	addi	r2,r2,18424
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a06217 	ldw	r2,-32376(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	2951fe04 	addi	r5,r5,18424
811019e4:	1009883a 	mov	r4,r2
811019e8:	112292c0 	call	8112292c <fprintf>
811019ec:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#if DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	11210240 	call	81121024 <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08817 	ldw	r2,-32224(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	11211500 	call	81121150 <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	11207d80 	call	811207d8 <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	11224ac0 	call	811224ac <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604574 	movhi	r5,33045
81101a54:	29740004 	addi	r5,r5,-12288
81101a58:	01204574 	movhi	r4,33045
81101a5c:	2111fe04 	addi	r4,r4,18424
81101a60:	11242400 	call	81124240 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a06217 	ldw	r2,-32376(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	2951fe04 	addi	r5,r5,18424
81101a70:	1009883a 	mov	r4,r2
81101a74:	112292c0 	call	8112292c <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18d1fe04 	addi	r3,r3,18424
81101a84:	00a04574 	movhi	r2,33045
81101a88:	10b40c04 	addi	r2,r2,-12240
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	11239dc0 	call	811239dc <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a06217 	ldw	r2,-32376(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	2951fe04 	addi	r5,r5,18424
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	112292c0 	call	8112292c <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	1091fe04 	addi	r2,r2,18424
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a06217 	ldw	r2,-32376(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	2951fe04 	addi	r5,r5,18424
81101ad8:	1009883a 	mov	r4,r2
81101adc:	112292c0 	call	8112292c <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18d1fe04 	addi	r3,r3,18424
81101b30:	00a04574 	movhi	r2,33045
81101b34:	10b41204 	addi	r2,r2,-12216
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	11239dc0 	call	811239dc <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a06217 	ldw	r2,-32376(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	2951fe04 	addi	r5,r5,18424
81101b5c:	1009883a 	mov	r4,r2
81101b60:	112292c0 	call	8112292c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18d1fe04 	addi	r3,r3,18424
81101bc4:	00a04574 	movhi	r2,33045
81101bc8:	10b1fa04 	addi	r2,r2,-14360
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	11239dc0 	call	811239dc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a06217 	ldw	r2,-32376(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	2951fe04 	addi	r5,r5,18424
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	112292c0 	call	8112292c <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604574 	movhi	r5,33045
81101c10:	29741c04 	addi	r5,r5,-12176
81101c14:	01204574 	movhi	r4,33045
81101c18:	2111fe04 	addi	r4,r4,18424
81101c1c:	11242400 	call	81124240 <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a06217 	ldw	r2,-32376(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	2951fe04 	addi	r5,r5,18424
81101c2c:	1009883a 	mov	r4,r2
81101c30:	112292c0 	call	8112292c <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18d1fe04 	addi	r3,r3,18424
81101cd0:	00a04574 	movhi	r2,33045
81101cd4:	10b42204 	addi	r2,r2,-12152
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	11239dc0 	call	811239dc <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a06217 	ldw	r2,-32376(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	2951fe04 	addi	r5,r5,18424
81101cfc:	1009883a 	mov	r4,r2
81101d00:	112292c0 	call	8112292c <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	10923e04 	addi	r2,r2,18680
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	10923e04 	addi	r2,r2,18680
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#if DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604574 	movhi	r5,33045
81101df4:	29742904 	addi	r5,r5,-12124
81101df8:	01204574 	movhi	r4,33045
81101dfc:	2111fe04 	addi	r4,r4,18424
81101e00:	11242400 	call	81124240 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a06217 	ldw	r2,-32376(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	2951fe04 	addi	r5,r5,18424
81101e10:	1009883a 	mov	r4,r2
81101e14:	112292c0 	call	8112292c <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604574 	movhi	r5,33045
81101e98:	2973fe04 	addi	r5,r5,-12296
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	2111fe04 	addi	r4,r4,18424
81101ea4:	11242400 	call	81124240 <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a06217 	ldw	r2,-32376(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	2951fe04 	addi	r5,r5,18424
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	112292c0 	call	8112292c <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	1091fe04 	addi	r2,r2,18424
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a06217 	ldw	r2,-32376(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	2951fe04 	addi	r5,r5,18424
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	112292c0 	call	8112292c <fprintf>
81101ef8:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	11210240 	call	81121024 <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08817 	ldw	r2,-32224(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	11211500 	call	81121150 <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	11207d80 	call	811207d8 <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	11224ac0 	call	811224ac <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604574 	movhi	r5,33045
81101f60:	29743704 	addi	r5,r5,-12068
81101f64:	01204574 	movhi	r4,33045
81101f68:	2111fe04 	addi	r4,r4,18424
81101f6c:	11242400 	call	81124240 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a06217 	ldw	r2,-32376(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	2951fe04 	addi	r5,r5,18424
81101f7c:	1009883a 	mov	r4,r2
81101f80:	112292c0 	call	8112292c <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18d1fe04 	addi	r3,r3,18424
81101f90:	00a04574 	movhi	r2,33045
81101f94:	10b44304 	addi	r2,r2,-12020
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	11239dc0 	call	811239dc <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a06217 	ldw	r2,-32376(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	2951fe04 	addi	r5,r5,18424
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	112292c0 	call	8112292c <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	1091fe04 	addi	r2,r2,18424
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a06217 	ldw	r2,-32376(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	2951fe04 	addi	r5,r5,18424
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	112292c0 	call	8112292c <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18d1fe04 	addi	r3,r3,18424
8110204c:	00a04574 	movhi	r2,33045
81102050:	10b44904 	addi	r2,r2,-11996
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	11239dc0 	call	811239dc <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a06217 	ldw	r2,-32376(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	2951fe04 	addi	r5,r5,18424
81102078:	1009883a 	mov	r4,r2
8110207c:	112292c0 	call	8112292c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18d1fe04 	addi	r3,r3,18424
811020e0:	00a04574 	movhi	r2,33045
811020e4:	10b1fa04 	addi	r2,r2,-14360
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	11239dc0 	call	811239dc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a06217 	ldw	r2,-32376(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	2951fe04 	addi	r5,r5,18424
8110210c:	1009883a 	mov	r4,r2
81102110:	112292c0 	call	8112292c <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604574 	movhi	r5,33045
8110212c:	2973f304 	addi	r5,r5,-12340
81102130:	01204574 	movhi	r4,33045
81102134:	2111fe04 	addi	r4,r4,18424
81102138:	11242400 	call	81124240 <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a06217 	ldw	r2,-32376(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	2951fe04 	addi	r5,r5,18424
81102148:	1009883a 	mov	r4,r2
8110214c:	112292c0 	call	8112292c <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08917 	ldw	r2,-32220(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18d1fe04 	addi	r3,r3,18424
811021ac:	00a04574 	movhi	r2,33045
811021b0:	10b45504 	addi	r2,r2,-11948
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	11239dc0 	call	811239dc <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a06217 	ldw	r2,-32376(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	2951fe04 	addi	r5,r5,18424
811021d8:	1009883a 	mov	r4,r2
811021dc:	112292c0 	call	8112292c <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#if DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604574 	movhi	r5,33045
811021f0:	29745b04 	addi	r5,r5,-11924
811021f4:	01204574 	movhi	r4,33045
811021f8:	2111fe04 	addi	r4,r4,18424
811021fc:	11242400 	call	81124240 <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a06217 	ldw	r2,-32376(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	2951fe04 	addi	r5,r5,18424
8110220c:	1009883a 	mov	r4,r2
81102210:	112292c0 	call	8112292c <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#if DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604574 	movhi	r5,33045
81102274:	29745d04 	addi	r5,r5,-11916
81102278:	01204574 	movhi	r4,33045
8110227c:	2111fe04 	addi	r4,r4,18424
81102280:	11242400 	call	81124240 <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a06217 	ldw	r2,-32376(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	2951fe04 	addi	r5,r5,18424
81102290:	1009883a 	mov	r4,r2
81102294:	112292c0 	call	8112292c <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	11377a00 	call	811377a0 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#if DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604574 	movhi	r5,33045
811022fc:	29746004 	addi	r5,r5,-11904
81102300:	01204574 	movhi	r4,33045
81102304:	2111fe04 	addi	r4,r4,18424
81102308:	11242400 	call	81124240 <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a06217 	ldw	r2,-32376(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	2951fe04 	addi	r5,r5,18424
81102318:	1009883a 	mov	r4,r2
8110231c:	112292c0 	call	8112292c <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	11210240 	call	81121024 <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08817 	ldw	r2,-32224(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	11211500 	call	81121150 <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	11207d80 	call	811207d8 <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#if DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	11224ac0 	call	811224ac <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604574 	movhi	r5,33045
81102394:	29746304 	addi	r5,r5,-11892
81102398:	01204574 	movhi	r4,33045
8110239c:	2111fe04 	addi	r4,r4,18424
811023a0:	11242400 	call	81124240 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a06217 	ldw	r2,-32376(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	2951fe04 	addi	r5,r5,18424
811023b0:	1009883a 	mov	r4,r2
811023b4:	112292c0 	call	8112292c <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#if DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604574 	movhi	r5,33045
811023c4:	29746f04 	addi	r5,r5,-11844
811023c8:	01204574 	movhi	r4,33045
811023cc:	2111fe04 	addi	r4,r4,18424
811023d0:	11242400 	call	81124240 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a06217 	ldw	r2,-32376(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	2951fe04 	addi	r5,r5,18424
811023e0:	1009883a 	mov	r4,r2
811023e4:	112292c0 	call	8112292c <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18d1fe04 	addi	r3,r3,18424
811023f4:	00a04574 	movhi	r2,33045
811023f8:	10b40c04 	addi	r2,r2,-12240
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	11239dc0 	call	811239dc <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a06217 	ldw	r2,-32376(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	2951fe04 	addi	r5,r5,18424
81102420:	1009883a 	mov	r4,r2
81102424:	112292c0 	call	8112292c <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	1091fe04 	addi	r2,r2,18424
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a06217 	ldw	r2,-32376(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	2951fe04 	addi	r5,r5,18424
81102448:	1009883a 	mov	r4,r2
8110244c:	112292c0 	call	8112292c <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18d1fe04 	addi	r3,r3,18424
811024b8:	00a04574 	movhi	r2,33045
811024bc:	10b47904 	addi	r2,r2,-11804
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	11239dc0 	call	811239dc <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a06217 	ldw	r2,-32376(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	2951fe04 	addi	r5,r5,18424
811024e4:	1009883a 	mov	r4,r2
811024e8:	112292c0 	call	8112292c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18d1fe04 	addi	r3,r3,18424
8110254c:	00a04574 	movhi	r2,33045
81102550:	10b1fa04 	addi	r2,r2,-14360
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	11239dc0 	call	811239dc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a06217 	ldw	r2,-32376(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	2951fe04 	addi	r5,r5,18424
81102578:	1009883a 	mov	r4,r2
8110257c:	112292c0 	call	8112292c <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604574 	movhi	r5,33045
81102598:	2973f304 	addi	r5,r5,-12340
8110259c:	01204574 	movhi	r4,33045
811025a0:	2111fe04 	addi	r4,r4,18424
811025a4:	11242400 	call	81124240 <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a06217 	ldw	r2,-32376(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	2951fe04 	addi	r5,r5,18424
811025b4:	1009883a 	mov	r4,r2
811025b8:	112292c0 	call	8112292c <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18d1fe04 	addi	r3,r3,18424
81102610:	00a04574 	movhi	r2,33045
81102614:	10b48504 	addi	r2,r2,-11756
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	11239dc0 	call	811239dc <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a06217 	ldw	r2,-32376(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	2951fe04 	addi	r5,r5,18424
8110263c:	1009883a 	mov	r4,r2
81102640:	112292c0 	call	8112292c <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#if DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604574 	movhi	r5,33045
81102654:	29745b04 	addi	r5,r5,-11924
81102658:	01204574 	movhi	r4,33045
8110265c:	2111fe04 	addi	r4,r4,18424
81102660:	11242400 	call	81124240 <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a06217 	ldw	r2,-32376(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	2951fe04 	addi	r5,r5,18424
81102670:	1009883a 	mov	r4,r2
81102674:	112292c0 	call	8112292c <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#if DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604574 	movhi	r5,33045
811026c8:	29748b04 	addi	r5,r5,-11732
811026cc:	01204574 	movhi	r4,33045
811026d0:	2111fe04 	addi	r4,r4,18424
811026d4:	11242400 	call	81124240 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a06217 	ldw	r2,-32376(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	2951fe04 	addi	r5,r5,18424
811026e4:	1009883a 	mov	r4,r2
811026e8:	112292c0 	call	8112292c <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#if DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604574 	movhi	r5,33045
81102710:	29745d04 	addi	r5,r5,-11916
81102714:	01204574 	movhi	r4,33045
81102718:	2111fe04 	addi	r4,r4,18424
8110271c:	11242400 	call	81124240 <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a06217 	ldw	r2,-32376(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	2951fe04 	addi	r5,r5,18424
8110272c:	1009883a 	mov	r4,r2
81102730:	112292c0 	call	8112292c <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#if DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604574 	movhi	r5,33045
81102794:	29746004 	addi	r5,r5,-11904
81102798:	01204574 	movhi	r4,33045
8110279c:	2111fe04 	addi	r4,r4,18424
811027a0:	11242400 	call	81124240 <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a06217 	ldw	r2,-32376(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	2951fe04 	addi	r5,r5,18424
811027b0:	1009883a 	mov	r4,r2
811027b4:	112292c0 	call	8112292c <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#if DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	11210240 	call	81121024 <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08817 	ldw	r2,-32224(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	11211500 	call	81121150 <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	11207d80 	call	811207d8 <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#if DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	11224ac0 	call	811224ac <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604574 	movhi	r5,33045
8110282c:	29749304 	addi	r5,r5,-11700
81102830:	01204574 	movhi	r4,33045
81102834:	2111fe04 	addi	r4,r4,18424
81102838:	11242400 	call	81124240 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a06217 	ldw	r2,-32376(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	2951fe04 	addi	r5,r5,18424
81102848:	1009883a 	mov	r4,r2
8110284c:	112292c0 	call	8112292c <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#if DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604574 	movhi	r5,33045
8110285c:	29749f04 	addi	r5,r5,-11652
81102860:	01204574 	movhi	r4,33045
81102864:	2111fe04 	addi	r4,r4,18424
81102868:	11242400 	call	81124240 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a06217 	ldw	r2,-32376(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	2951fe04 	addi	r5,r5,18424
81102878:	1009883a 	mov	r4,r2
8110287c:	112292c0 	call	8112292c <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18d1fe04 	addi	r3,r3,18424
8110288c:	00a04574 	movhi	r2,33045
81102890:	10b44304 	addi	r2,r2,-12020
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	11239dc0 	call	811239dc <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a06217 	ldw	r2,-32376(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	2951fe04 	addi	r5,r5,18424
811028b8:	1009883a 	mov	r4,r2
811028bc:	112292c0 	call	8112292c <fprintf>
#endif
	}
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	1091fe04 	addi	r2,r2,18424
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a06217 	ldw	r2,-32376(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	2951fe04 	addi	r5,r5,18424
811028e0:	1009883a 	mov	r4,r2
811028e4:	112292c0 	call	8112292c <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	114b0600 	call	8114b060 <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000f1e 	bne	r2,zero,81102bac <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000806 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	1138fc80 	call	81138fc8 <usleep>
81102b84:	00000306 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e0bfff17 	ldw	r2,-4(fp)
81102b8c:	1009883a 	mov	r4,r2
81102b90:	1138fc80 	call	81138fc8 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b94:	e0bffd17 	ldw	r2,-12(fp)
81102b98:	10800317 	ldw	r2,12(r2)
81102b9c:	10800037 	ldwio	r2,0(r2)
81102ba0:	1080080c 	andi	r2,r2,32
81102ba4:	103ff31e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba8:	00000206 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bac:	e0bffc17 	ldw	r2,-16(fp)
81102bb0:	00000106 	br	81102bb8 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102bb4:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb8:	e037883a 	mov	sp,fp
81102bbc:	dfc00117 	ldw	ra,4(sp)
81102bc0:	df000017 	ldw	fp,0(sp)
81102bc4:	dec00204 	addi	sp,sp,8
81102bc8:	f800283a 	ret

81102bcc <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bcc:	defffa04 	addi	sp,sp,-24
81102bd0:	de00012e 	bgeu	sp,et,81102bd8 <DMA_DISPATCHER_RESET+0xc>
81102bd4:	003b68fa 	trap	3
81102bd8:	dfc00515 	stw	ra,20(sp)
81102bdc:	df000415 	stw	fp,16(sp)
81102be0:	df000404 	addi	fp,sp,16
81102be4:	e13ffd15 	stw	r4,-12(fp)
81102be8:	e17ffe15 	stw	r5,-8(fp)
81102bec:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bf0:	00800044 	movi	r2,1
81102bf4:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf8:	e0bffd17 	ldw	r2,-12(fp)
81102bfc:	10800317 	ldw	r2,12(r2)
81102c00:	10800104 	addi	r2,r2,4
81102c04:	00c00084 	movi	r3,2
81102c08:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c0c:	e0bffe17 	ldw	r2,-8(fp)
81102c10:	10800058 	cmpnei	r2,r2,1
81102c14:	10000f1e 	bne	r2,zero,81102c54 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c18:	00000806 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c1c:	e0bfff17 	ldw	r2,-4(fp)
81102c20:	1000031e 	bne	r2,zero,81102c30 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c24:	01000044 	movi	r4,1
81102c28:	1138fc80 	call	81138fc8 <usleep>
81102c2c:	00000306 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c30:	e0bfff17 	ldw	r2,-4(fp)
81102c34:	1009883a 	mov	r4,r2
81102c38:	1138fc80 	call	81138fc8 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c3c:	e0bffd17 	ldw	r2,-12(fp)
81102c40:	10800317 	ldw	r2,12(r2)
81102c44:	10800037 	ldwio	r2,0(r2)
81102c48:	1080100c 	andi	r2,r2,64
81102c4c:	103ff31e 	bne	r2,zero,81102c1c <__reset+0xfb0e2c1c>
81102c50:	00000206 	br	81102c5c <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
81102c58:	00000106 	br	81102c60 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102c5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102c60:	e037883a 	mov	sp,fp
81102c64:	dfc00117 	ldw	ra,4(sp)
81102c68:	df000017 	ldw	fp,0(sp)
81102c6c:	dec00204 	addi	sp,sp,8
81102c70:	f800283a 	ret

81102c74 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c74:	defff604 	addi	sp,sp,-40
81102c78:	de00012e 	bgeu	sp,et,81102c80 <DMA_SINGLE_TRANSFER+0xc>
81102c7c:	003b68fa 	trap	3
81102c80:	dfc00915 	stw	ra,36(sp)
81102c84:	df000815 	stw	fp,32(sp)
81102c88:	dc000715 	stw	r16,28(sp)
81102c8c:	df000804 	addi	fp,sp,32
81102c90:	e13ffb15 	stw	r4,-20(fp)
81102c94:	e17ffc15 	stw	r5,-16(fp)
81102c98:	e1bffd15 	stw	r6,-12(fp)
81102c9c:	e1fffe15 	stw	r7,-8(fp)
81102ca0:	defff804 	addi	sp,sp,-32
81102ca4:	d8800204 	addi	r2,sp,8
81102ca8:	108003c4 	addi	r2,r2,15
81102cac:	1004d13a 	srli	r2,r2,4
81102cb0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cb4:	00800044 	movi	r2,1
81102cb8:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cbc:	e0fffc17 	ldw	r3,-16(fp)
81102cc0:	e13ffd17 	ldw	r4,-12(fp)
81102cc4:	e0800217 	ldw	r2,8(fp)
81102cc8:	d8800115 	stw	r2,4(sp)
81102ccc:	e0bffe17 	ldw	r2,-8(fp)
81102cd0:	d8800015 	stw	r2,0(sp)
81102cd4:	200f883a 	mov	r7,r4
81102cd8:	180d883a 	mov	r6,r3
81102cdc:	800b883a 	mov	r5,r16
81102ce0:	e13ffb17 	ldw	r4,-20(fp)
81102ce4:	114a05c0 	call	8114a05c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce8:	10000326 	beq	r2,zero,81102cf8 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102cec:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102cf0:	e0bffa17 	ldw	r2,-24(fp)
81102cf4:	00001e06 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf8:	800b883a 	mov	r5,r16
81102cfc:	e13ffb17 	ldw	r4,-20(fp)
81102d00:	114b2d00 	call	8114b2d0 <alt_msgdma_standard_descriptor_async_transfer>
81102d04:	10000326 	beq	r2,zero,81102d14 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d08:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	00001706 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d14:	e0bffa17 	ldw	r2,-24(fp)
81102d18:	10800060 	cmpeqi	r2,r2,1
81102d1c:	1007883a 	mov	r3,r2
81102d20:	e0800317 	ldw	r2,12(fp)
81102d24:	10800060 	cmpeqi	r2,r2,1
81102d28:	1884703a 	and	r2,r3,r2
81102d2c:	10803fcc 	andi	r2,r2,255
81102d30:	10000e26 	beq	r2,zero,81102d6c <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d34:	00000806 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d38:	e0800417 	ldw	r2,16(fp)
81102d3c:	1000031e 	bne	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d40:	0100fa04 	movi	r4,1000
81102d44:	1138fc80 	call	81138fc8 <usleep>
81102d48:	00000306 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1009883a 	mov	r4,r2
81102d54:	1138fc80 	call	81138fc8 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d58:	e0bffb17 	ldw	r2,-20(fp)
81102d5c:	10800317 	ldw	r2,12(r2)
81102d60:	10800037 	ldwio	r2,0(r2)
81102d64:	1080004c 	andi	r2,r2,1
81102d68:	103ff31e 	bne	r2,zero,81102d38 <__reset+0xfb0e2d38>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d6c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d70:	e6ffff04 	addi	sp,fp,-4
81102d74:	dfc00217 	ldw	ra,8(sp)
81102d78:	df000117 	ldw	fp,4(sp)
81102d7c:	dc000017 	ldw	r16,0(sp)
81102d80:	dec00304 	addi	sp,sp,12
81102d84:	f800283a 	ret

81102d88 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d88:	defff504 	addi	sp,sp,-44
81102d8c:	de00012e 	bgeu	sp,et,81102d94 <DMA_MULTIPLE_TRANSFER+0xc>
81102d90:	003b68fa 	trap	3
81102d94:	dfc00a15 	stw	ra,40(sp)
81102d98:	df000915 	stw	fp,36(sp)
81102d9c:	dc000815 	stw	r16,32(sp)
81102da0:	df000904 	addi	fp,sp,36
81102da4:	e13ffb15 	stw	r4,-20(fp)
81102da8:	e17ffc15 	stw	r5,-16(fp)
81102dac:	e1bffd15 	stw	r6,-12(fp)
81102db0:	3805883a 	mov	r2,r7
81102db4:	e0bffe05 	stb	r2,-8(fp)
81102db8:	defff804 	addi	sp,sp,-32
81102dbc:	d8800204 	addi	r2,sp,8
81102dc0:	108003c4 	addi	r2,r2,15
81102dc4:	1004d13a 	srli	r2,r2,4
81102dc8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dcc:	00800044 	movi	r2,1
81102dd0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dd4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dd8:	00002506 	br	81102e70 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102ddc:	e0bffa03 	ldbu	r2,-24(fp)
81102de0:	1085883a 	add	r2,r2,r2
81102de4:	1085883a 	add	r2,r2,r2
81102de8:	1007883a 	mov	r3,r2
81102dec:	e0bffc17 	ldw	r2,-16(fp)
81102df0:	10c5883a 	add	r2,r2,r3
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	1009883a 	mov	r4,r2
81102dfc:	e0bffa03 	ldbu	r2,-24(fp)
81102e00:	1085883a 	add	r2,r2,r2
81102e04:	1085883a 	add	r2,r2,r2
81102e08:	1007883a 	mov	r3,r2
81102e0c:	e0bffd17 	ldw	r2,-12(fp)
81102e10:	10c5883a 	add	r2,r2,r3
81102e14:	10800017 	ldw	r2,0(r2)
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0800317 	ldw	r2,12(fp)
81102e20:	10804034 	orhi	r2,r2,256
81102e24:	d8800115 	stw	r2,4(sp)
81102e28:	e0800217 	ldw	r2,8(fp)
81102e2c:	d8800015 	stw	r2,0(sp)
81102e30:	180f883a 	mov	r7,r3
81102e34:	200d883a 	mov	r6,r4
81102e38:	800b883a 	mov	r5,r16
81102e3c:	e13ffb17 	ldw	r4,-20(fp)
81102e40:	114a05c0 	call	8114a05c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e44:	10000226 	beq	r2,zero,81102e50 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e48:	e03ff915 	stw	zero,-28(fp)
81102e4c:	00000506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e50:	800b883a 	mov	r5,r16
81102e54:	e13ffb17 	ldw	r4,-20(fp)
81102e58:	114b2d00 	call	8114b2d0 <alt_msgdma_standard_descriptor_async_transfer>
81102e5c:	10000126 	beq	r2,zero,81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e60:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	10800044 	addi	r2,r2,1
81102e6c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e70:	e0bff917 	ldw	r2,-28(fp)
81102e74:	10800060 	cmpeqi	r2,r2,1
81102e78:	1009883a 	mov	r4,r2
81102e7c:	e0fffa03 	ldbu	r3,-24(fp)
81102e80:	e0bffe03 	ldbu	r2,-8(fp)
81102e84:	10bfffc4 	addi	r2,r2,-1
81102e88:	1884803a 	cmplt	r2,r3,r2
81102e8c:	2084703a 	and	r2,r4,r2
81102e90:	10803fcc 	andi	r2,r2,255
81102e94:	103fd11e 	bne	r2,zero,81102ddc <__reset+0xfb0e2ddc>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e98:	e0bff917 	ldw	r2,-28(fp)
81102e9c:	10800058 	cmpnei	r2,r2,1
81102ea0:	1000211e 	bne	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ea4:	e0bffa03 	ldbu	r2,-24(fp)
81102ea8:	1085883a 	add	r2,r2,r2
81102eac:	1085883a 	add	r2,r2,r2
81102eb0:	1007883a 	mov	r3,r2
81102eb4:	e0bffc17 	ldw	r2,-16(fp)
81102eb8:	10c5883a 	add	r2,r2,r3
81102ebc:	10800017 	ldw	r2,0(r2)
81102ec0:	1009883a 	mov	r4,r2
81102ec4:	e0bffa03 	ldbu	r2,-24(fp)
81102ec8:	1085883a 	add	r2,r2,r2
81102ecc:	1085883a 	add	r2,r2,r2
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0bffd17 	ldw	r2,-12(fp)
81102ed8:	10c5883a 	add	r2,r2,r3
81102edc:	10800017 	ldw	r2,0(r2)
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0800317 	ldw	r2,12(fp)
81102ee8:	d8800115 	stw	r2,4(sp)
81102eec:	e0800217 	ldw	r2,8(fp)
81102ef0:	d8800015 	stw	r2,0(sp)
81102ef4:	180f883a 	mov	r7,r3
81102ef8:	200d883a 	mov	r6,r4
81102efc:	800b883a 	mov	r5,r16
81102f00:	e13ffb17 	ldw	r4,-20(fp)
81102f04:	114a05c0 	call	8114a05c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f08:	10000226 	beq	r2,zero,81102f14 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f0c:	e03ff915 	stw	zero,-28(fp)
81102f10:	00000506 	br	81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f14:	800b883a 	mov	r5,r16
81102f18:	e13ffb17 	ldw	r4,-20(fp)
81102f1c:	114b2d00 	call	8114b2d0 <alt_msgdma_standard_descriptor_async_transfer>
81102f20:	10000126 	beq	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f24:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f28:	e0bff917 	ldw	r2,-28(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1007883a 	mov	r3,r2
81102f34:	e0800417 	ldw	r2,16(fp)
81102f38:	10800060 	cmpeqi	r2,r2,1
81102f3c:	1884703a 	and	r2,r3,r2
81102f40:	10803fcc 	andi	r2,r2,255
81102f44:	10000e26 	beq	r2,zero,81102f80 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f48:	00000806 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f4c:	e0800517 	ldw	r2,20(fp)
81102f50:	1000031e 	bne	r2,zero,81102f60 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f54:	0100fa04 	movi	r4,1000
81102f58:	1138fc80 	call	81138fc8 <usleep>
81102f5c:	00000306 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102f60:	e0800517 	ldw	r2,20(fp)
81102f64:	1009883a 	mov	r4,r2
81102f68:	1138fc80 	call	81138fc8 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f6c:	e0bffb17 	ldw	r2,-20(fp)
81102f70:	10800317 	ldw	r2,12(r2)
81102f74:	10800037 	ldwio	r2,0(r2)
81102f78:	1080004c 	andi	r2,r2,1
81102f7c:	103ff31e 	bne	r2,zero,81102f4c <__reset+0xfb0e2f4c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f80:	e0bff917 	ldw	r2,-28(fp)
}
81102f84:	e6ffff04 	addi	sp,fp,-4
81102f88:	dfc00217 	ldw	ra,8(sp)
81102f8c:	df000117 	ldw	fp,4(sp)
81102f90:	dc000017 	ldw	r16,0(sp)
81102f94:	dec00304 	addi	sp,sp,12
81102f98:	f800283a 	ret

81102f9c <POWER_Read>:

#if DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f9c:	deffef04 	addi	sp,sp,-68
81102fa0:	de00012e 	bgeu	sp,et,81102fa8 <POWER_Read+0xc>
81102fa4:	003b68fa 	trap	3
81102fa8:	dfc01015 	stw	ra,64(sp)
81102fac:	df000f15 	stw	fp,60(sp)
81102fb0:	df000f04 	addi	fp,sp,60
81102fb4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fb8:	00800044 	movi	r2,1
81102fbc:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fc0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fc4:	00800204 	movi	r2,8
81102fc8:	e0bffc15 	stw	r2,-16(fp)
81102fcc:	00800104 	movi	r2,4
81102fd0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fd4:	00800044 	movi	r2,1
81102fd8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fdc:	00800044 	movi	r2,1
81102fe0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fe4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fe8:	e03ff515 	stw	zero,-44(fp)
81102fec:	00009206 	br	81103238 <POWER_Read+0x29c>
		NextChannel = 0;
81102ff0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102ff4:	e0bff517 	ldw	r2,-44(fp)
81102ff8:	10c03fcc 	andi	r3,r2,255
81102ffc:	e13ffa03 	ldbu	r4,-24(fp)
81103000:	e0bfff17 	ldw	r2,-4(fp)
81103004:	d8800115 	stw	r2,4(sp)
81103008:	e0bff917 	ldw	r2,-28(fp)
8110300c:	d8800015 	stw	r2,0(sp)
81103010:	e1fff817 	ldw	r7,-32(fp)
81103014:	e1bff717 	ldw	r6,-36(fp)
81103018:	200b883a 	mov	r5,r4
8110301c:	1809883a 	mov	r4,r3
81103020:	110be400 	call	8110be40 <POWER_SPI_RW>
81103024:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103028:	e03ff415 	stw	zero,-48(fp)
8110302c:	00007406 	br	81103200 <POWER_Read+0x264>
			NextChannel = i + 1;
81103030:	e0bff417 	ldw	r2,-48(fp)
81103034:	10800044 	addi	r2,r2,1
81103038:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110303c:	e0bff517 	ldw	r2,-44(fp)
81103040:	10c03fcc 	andi	r3,r2,255
81103044:	e13ffa03 	ldbu	r4,-24(fp)
81103048:	e0bffe04 	addi	r2,fp,-8
8110304c:	d8800115 	stw	r2,4(sp)
81103050:	e0bff917 	ldw	r2,-28(fp)
81103054:	d8800015 	stw	r2,0(sp)
81103058:	e1fff817 	ldw	r7,-32(fp)
8110305c:	e1bff717 	ldw	r6,-36(fp)
81103060:	200b883a 	mov	r5,r4
81103064:	1809883a 	mov	r4,r3
81103068:	110be400 	call	8110be40 <POWER_SPI_RW>
8110306c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103070:	e0bff317 	ldw	r2,-52(fp)
81103074:	10005026 	beq	r2,zero,811031b8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103078:	e0bffe17 	ldw	r2,-8(fp)
8110307c:	1004d7ba 	srli	r2,r2,30
81103080:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d07a 	srli	r2,r2,1
8110308c:	108001cc 	andi	r2,r2,7
81103090:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d13a 	srli	r2,r2,4
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1004d17a 	srli	r2,r2,5
811030ac:	1080004c 	andi	r2,r2,1
811030b0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030b4:	e0bffe17 	ldw	r2,-8(fp)
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030c0:	e0bffa43 	ldbu	r2,-23(fp)
811030c4:	10000d26 	beq	r2,zero,811030fc <POWER_Read+0x160>
#if DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030c8:	e1bff417 	ldw	r6,-48(fp)
811030cc:	01604574 	movhi	r5,33045
811030d0:	2974a904 	addi	r5,r5,-11612
811030d4:	01204574 	movhi	r4,33045
811030d8:	2111fe04 	addi	r4,r4,18424
811030dc:	11242400 	call	81124240 <sprintf>
					debug(fp, cDebugBuffer);
811030e0:	d0a06217 	ldw	r2,-32376(gp)
811030e4:	01604574 	movhi	r5,33045
811030e8:	2951fe04 	addi	r5,r5,18424
811030ec:	1009883a 	mov	r4,r2
811030f0:	112292c0 	call	8112292c <fprintf>
#endif
					bSuccess = FALSE;
811030f4:	e03ff315 	stw	zero,-52(fp)
811030f8:	00002206 	br	81103184 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030fc:	e0fffa83 	ldbu	r3,-22(fp)
81103100:	e0bff417 	ldw	r2,-48(fp)
81103104:	18801026 	beq	r3,r2,81103148 <POWER_Read+0x1ac>
#if DEBUG_ON
					sprintf(cDebugBuffer,
81103108:	e0bffa83 	ldbu	r2,-22(fp)
8110310c:	d8800015 	stw	r2,0(sp)
81103110:	e1fff417 	ldw	r7,-48(fp)
81103114:	e1bff417 	ldw	r6,-48(fp)
81103118:	01604574 	movhi	r5,33045
8110311c:	2974af04 	addi	r5,r5,-11588
81103120:	01204574 	movhi	r4,33045
81103124:	2111fe04 	addi	r4,r4,18424
81103128:	11242400 	call	81124240 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110312c:	d0a06217 	ldw	r2,-32376(gp)
81103130:	01604574 	movhi	r5,33045
81103134:	2951fe04 	addi	r5,r5,18424
81103138:	1009883a 	mov	r4,r2
8110313c:	112292c0 	call	8112292c <fprintf>
#endif
					bSuccess = FALSE;
81103140:	e03ff315 	stw	zero,-52(fp)
81103144:	00000f06 	br	81103184 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103148:	e0fffac3 	ldbu	r3,-21(fp)
8110314c:	e0bff817 	ldw	r2,-32(fp)
81103150:	18800c26 	beq	r3,r2,81103184 <POWER_Read+0x1e8>
#if DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103154:	e1bff417 	ldw	r6,-48(fp)
81103158:	01604574 	movhi	r5,33045
8110315c:	2974bb04 	addi	r5,r5,-11540
81103160:	01204574 	movhi	r4,33045
81103164:	2111fe04 	addi	r4,r4,18424
81103168:	11242400 	call	81124240 <sprintf>
					debug(fp, cDebugBuffer);
8110316c:	d0a06217 	ldw	r2,-32376(gp)
81103170:	01604574 	movhi	r5,33045
81103174:	2951fe04 	addi	r5,r5,18424
81103178:	1009883a 	mov	r4,r2
8110317c:	112292c0 	call	8112292c <fprintf>
#endif
					bSuccess = FALSE;
81103180:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103184:	e0bff317 	ldw	r2,-52(fp)
81103188:	10001a26 	beq	r2,zero,811031f4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110318c:	e0bff617 	ldw	r2,-40(fp)
81103190:	10c00044 	addi	r3,r2,1
81103194:	e0fff615 	stw	r3,-40(fp)
81103198:	1085883a 	add	r2,r2,r2
8110319c:	1085883a 	add	r2,r2,r2
811031a0:	1007883a 	mov	r3,r2
811031a4:	e0bfff17 	ldw	r2,-4(fp)
811031a8:	10c5883a 	add	r2,r2,r3
811031ac:	e0fffe17 	ldw	r3,-8(fp)
811031b0:	10c00015 	stw	r3,0(r2)
811031b4:	00000f06 	br	811031f4 <POWER_Read+0x258>
			} else {
#if DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031b8:	00e04574 	movhi	r3,33045
811031bc:	18d1fe04 	addi	r3,r3,18424
811031c0:	00a04574 	movhi	r2,33045
811031c4:	10b4c104 	addi	r2,r2,-11516
811031c8:	1009883a 	mov	r4,r2
811031cc:	00800444 	movi	r2,17
811031d0:	100d883a 	mov	r6,r2
811031d4:	200b883a 	mov	r5,r4
811031d8:	1809883a 	mov	r4,r3
811031dc:	11239dc0 	call	811239dc <memcpy>
				debug(fp, cDebugBuffer);
811031e0:	d0a06217 	ldw	r2,-32376(gp)
811031e4:	01604574 	movhi	r5,33045
811031e8:	2951fe04 	addi	r5,r5,18424
811031ec:	1009883a 	mov	r4,r2
811031f0:	112292c0 	call	8112292c <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031f4:	e0bff417 	ldw	r2,-48(fp)
811031f8:	10800044 	addi	r2,r2,1
811031fc:	e0bff415 	stw	r2,-48(fp)
81103200:	e0bff517 	ldw	r2,-44(fp)
81103204:	1085883a 	add	r2,r2,r2
81103208:	1085883a 	add	r2,r2,r2
8110320c:	e0fff304 	addi	r3,fp,-52
81103210:	1885883a 	add	r2,r3,r2
81103214:	10800904 	addi	r2,r2,36
81103218:	10800017 	ldw	r2,0(r2)
8110321c:	e0fff417 	ldw	r3,-48(fp)
81103220:	1880020e 	bge	r3,r2,8110322c <POWER_Read+0x290>
81103224:	e0bff317 	ldw	r2,-52(fp)
81103228:	103f811e 	bne	r2,zero,81103030 <__reset+0xfb0e3030>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110322c:	e0bff517 	ldw	r2,-44(fp)
81103230:	10800044 	addi	r2,r2,1
81103234:	e0bff515 	stw	r2,-44(fp)
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800088 	cmpgei	r2,r2,2
81103240:	1000021e 	bne	r2,zero,8110324c <POWER_Read+0x2b0>
81103244:	e0bff317 	ldw	r2,-52(fp)
81103248:	103f691e 	bne	r2,zero,81102ff0 <__reset+0xfb0e2ff0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110324c:	e0bff317 	ldw	r2,-52(fp)
}
81103250:	e037883a 	mov	sp,fp
81103254:	dfc00117 	ldw	ra,4(sp)
81103258:	df000017 	ldw	fp,0(sp)
8110325c:	dec00204 	addi	sp,sp,8
81103260:	f800283a 	ret

81103264 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103264:	defff904 	addi	sp,sp,-28
81103268:	de00012e 	bgeu	sp,et,81103270 <TEMP_Read+0xc>
8110326c:	003b68fa 	trap	3
81103270:	dfc00615 	stw	ra,24(sp)
81103274:	df000515 	stw	fp,20(sp)
81103278:	df000504 	addi	fp,sp,20
8110327c:	e13ffe15 	stw	r4,-8(fp)
81103280:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103284:	00800c04 	movi	r2,48
81103288:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110328c:	e0bffd83 	ldbu	r2,-10(fp)
81103290:	10c03fcc 	andi	r3,r2,255
81103294:	18c0201c 	xori	r3,r3,128
81103298:	18ffe004 	addi	r3,r3,-128
8110329c:	e0bffdc4 	addi	r2,fp,-9
811032a0:	d8800015 	stw	r2,0(sp)
811032a4:	000f883a 	mov	r7,zero
811032a8:	180d883a 	mov	r6,r3
811032ac:	01600034 	movhi	r5,32768
811032b0:	29426004 	addi	r5,r5,2432
811032b4:	01200034 	movhi	r4,32768
811032b8:	21026404 	addi	r4,r4,2448
811032bc:	110ab740 	call	8110ab74 <I2C_Read>
811032c0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10000226 	beq	r2,zero,811032d4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032cc:	e0bffdc3 	ldbu	r2,-9(fp)
811032d0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032d4:	e0bffc17 	ldw	r2,-16(fp)
811032d8:	10001226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032dc:	e0bffd83 	ldbu	r2,-10(fp)
811032e0:	10c03fcc 	andi	r3,r2,255
811032e4:	18c0201c 	xori	r3,r3,128
811032e8:	18ffe004 	addi	r3,r3,-128
811032ec:	e0bffdc4 	addi	r2,fp,-9
811032f0:	d8800015 	stw	r2,0(sp)
811032f4:	01c00044 	movi	r7,1
811032f8:	180d883a 	mov	r6,r3
811032fc:	01600034 	movhi	r5,32768
81103300:	29426004 	addi	r5,r5,2432
81103304:	01200034 	movhi	r4,32768
81103308:	21026404 	addi	r4,r4,2448
8110330c:	110ab740 	call	8110ab74 <I2C_Read>
81103310:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110331c:	e0bffdc3 	ldbu	r2,-9(fp)
81103320:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103324:	e0bffc17 	ldw	r2,-16(fp)
81103328:	10000626 	beq	r2,zero,81103344 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110332c:	e0bffe17 	ldw	r2,-8(fp)
81103330:	e0fffd03 	ldbu	r3,-12(fp)
81103334:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103338:	e0bfff17 	ldw	r2,-4(fp)
8110333c:	e0fffd43 	ldbu	r3,-11(fp)
81103340:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103344:	e0bffc17 	ldw	r2,-16(fp)
}
81103348:	e037883a 	mov	sp,fp
8110334c:	dfc00117 	ldw	ra,4(sp)
81103350:	df000017 	ldw	fp,0(sp)
81103354:	dec00204 	addi	sp,sp,8
81103358:	f800283a 	ret

8110335c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110335c:	defffb04 	addi	sp,sp,-20
81103360:	de00012e 	bgeu	sp,et,81103368 <sense_log_temp+0xc>
81103364:	003b68fa 	trap	3
81103368:	dfc00415 	stw	ra,16(sp)
8110336c:	df000315 	stw	fp,12(sp)
81103370:	df000304 	addi	fp,sp,12
81103374:	e13ffe15 	stw	r4,-8(fp)
81103378:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110337c:	e17fff17 	ldw	r5,-4(fp)
81103380:	e13ffe17 	ldw	r4,-8(fp)
81103384:	11032640 	call	81103264 <TEMP_Read>
81103388:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110338c:	e0bffd17 	ldw	r2,-12(fp)
}
81103390:	e037883a 	mov	sp,fp
81103394:	dfc00117 	ldw	ra,4(sp)
81103398:	df000017 	ldw	fp,0(sp)
8110339c:	dec00204 	addi	sp,sp,8
811033a0:	f800283a 	ret

811033a4 <sense_log>:

void sense_log(void) {
811033a4:	deff0404 	addi	sp,sp,-1008
811033a8:	de00012e 	bgeu	sp,et,811033b0 <sense_log+0xc>
811033ac:	003b68fa 	trap	3
811033b0:	dfc0fb15 	stw	ra,1004(sp)
811033b4:	df00fa15 	stw	fp,1000(sp)
811033b8:	dd40f915 	stw	r21,996(sp)
811033bc:	dd00f815 	stw	r20,992(sp)
811033c0:	dcc0f715 	stw	r19,988(sp)
811033c4:	dc80f615 	stw	r18,984(sp)
811033c8:	dc40f515 	stw	r17,980(sp)
811033cc:	dc00f415 	stw	r16,976(sp)
811033d0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033d4:	00902834 	movhi	r2,16544
811033d8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033dc:	008ed174 	movhi	r2,15173
811033e0:	10a6e984 	addi	r2,r2,-25690
811033e4:	e0bf2215 	stw	r2,-888(fp)
811033e8:	008ea0f4 	movhi	r2,14979
811033ec:	10849bc4 	addi	r2,r2,4719
811033f0:	e0bf2315 	stw	r2,-884(fp)
811033f4:	008ed174 	movhi	r2,15173
811033f8:	10a6e984 	addi	r2,r2,-25690
811033fc:	e0bf2415 	stw	r2,-880(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2515 	stw	r2,-876(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2615 	stw	r2,-872(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2715 	stw	r2,-868(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2815 	stw	r2,-864(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2915 	stw	r2,-860(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2a15 	stw	r2,-856(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2b15 	stw	r2,-852(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2c15 	stw	r2,-848(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110346c:	008fd9b4 	movhi	r2,16230
81103470:	10999984 	addi	r2,r2,26214
81103474:	e0bf2e15 	stw	r2,-840(fp)
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2f15 	stw	r2,-836(fp)
81103484:	00901034 	movhi	r2,16448
81103488:	e0bf3015 	stw	r2,-832(fp)
8110348c:	008fd9b4 	movhi	r2,16230
81103490:	10999984 	addi	r2,r2,26214
81103494:	e0bf3115 	stw	r2,-828(fp)
81103498:	008ff9b4 	movhi	r2,16358
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3215 	stw	r2,-824(fp)
811034a4:	00900834 	movhi	r2,16416
811034a8:	e0bf3315 	stw	r2,-820(fp)
811034ac:	008ff9b4 	movhi	r2,16358
811034b0:	10999984 	addi	r2,r2,26214
811034b4:	e0bf3415 	stw	r2,-816(fp)
811034b8:	00900834 	movhi	r2,16416
811034bc:	e0bf3515 	stw	r2,-812(fp)
811034c0:	008fe374 	movhi	r2,16269
811034c4:	10b33344 	addi	r2,r2,-13107
811034c8:	e0bf3615 	stw	r2,-808(fp)
811034cc:	008fecf4 	movhi	r2,16307
811034d0:	108cccc4 	addi	r2,r2,13107
811034d4:	e0bf3715 	stw	r2,-804(fp)
811034d8:	009014f4 	movhi	r2,16467
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3815 	stw	r2,-800(fp)
811034e4:	00900834 	movhi	r2,16416
811034e8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034ec:	00a04574 	movhi	r2,33045
811034f0:	10b4f804 	addi	r2,r2,-11296
811034f4:	e0ff3a04 	addi	r3,fp,-792
811034f8:	1009883a 	mov	r4,r2
811034fc:	0080c004 	movi	r2,768
81103500:	100d883a 	mov	r6,r2
81103504:	200b883a 	mov	r5,r4
81103508:	1809883a 	mov	r4,r3
8110350c:	11239dc0 	call	811239dc <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103510:	e0bf1604 	addi	r2,fp,-936
81103514:	1009883a 	mov	r4,r2
81103518:	1102f9c0 	call	81102f9c <POWER_Read>
8110351c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103520:	e0bf0f17 	ldw	r2,-964(fp)
81103524:	10016026 	beq	r2,zero,81103aa8 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103528:	e03f0c15 	stw	zero,-976(fp)
8110352c:	00014c06 	br	81103a60 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103530:	e0bf0c17 	ldw	r2,-976(fp)
81103534:	1085883a 	add	r2,r2,r2
81103538:	1085883a 	add	r2,r2,r2
8110353c:	e0ff0c04 	addi	r3,fp,-976
81103540:	1885883a 	add	r2,r3,r2
81103544:	10800a04 	addi	r2,r2,40
81103548:	10800017 	ldw	r2,0(r2)
8110354c:	1004d77a 	srli	r2,r2,29
81103550:	1080004c 	andi	r2,r2,1
81103554:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103558:	e0bf0c17 	ldw	r2,-976(fp)
8110355c:	1085883a 	add	r2,r2,r2
81103560:	1085883a 	add	r2,r2,r2
81103564:	e0ff0c04 	addi	r3,fp,-976
81103568:	1885883a 	add	r2,r3,r2
8110356c:	10800a04 	addi	r2,r2,40
81103570:	10800017 	ldw	r2,0(r2)
81103574:	1004d73a 	srli	r2,r2,28
81103578:	1080004c 	andi	r2,r2,1
8110357c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103580:	e0bf0c17 	ldw	r2,-976(fp)
81103584:	1085883a 	add	r2,r2,r2
81103588:	1085883a 	add	r2,r2,r2
8110358c:	e0ff0c04 	addi	r3,fp,-976
81103590:	1885883a 	add	r2,r3,r2
81103594:	10800a04 	addi	r2,r2,40
81103598:	10800017 	ldw	r2,0(r2)
8110359c:	1006d1ba 	srli	r3,r2,6
811035a0:	00801034 	movhi	r2,64
811035a4:	10bfffc4 	addi	r2,r2,-1
811035a8:	1884703a 	and	r2,r3,r2
811035ac:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035b0:	e0bf1117 	ldw	r2,-956(fp)
811035b4:	1000091e 	bne	r2,zero,811035dc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035b8:	e13f1217 	ldw	r4,-952(fp)
811035bc:	11211500 	call	81121150 <__floatunsisf>
811035c0:	1007883a 	mov	r3,r2
811035c4:	0152a034 	movhi	r5,19072
811035c8:	1809883a 	mov	r4,r3
811035cc:	11207d80 	call	811207d8 <__divsf3>
811035d0:	1007883a 	mov	r3,r2
811035d4:	e0ff0d15 	stw	r3,-972(fp)
811035d8:	00000106 	br	811035e0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035dc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035e0:	e0bf1017 	ldw	r2,-960(fp)
811035e4:	10002626 	beq	r2,zero,81103680 <sense_log+0x2dc>
811035e8:	e0bf1117 	ldw	r2,-956(fp)
811035ec:	10002426 	beq	r2,zero,81103680 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035f0:	014fc034 	movhi	r5,16128
811035f4:	e13f0e17 	ldw	r4,-968(fp)
811035f8:	1120c200 	call	81120c20 <__mulsf3>
811035fc:	1007883a 	mov	r3,r2
81103600:	e0ff1315 	stw	r3,-948(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103604:	e0ff3a04 	addi	r3,fp,-792
81103608:	e0bf0c17 	ldw	r2,-976(fp)
8110360c:	100491ba 	slli	r2,r2,6
81103610:	18a1883a 	add	r16,r3,r2
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	1085883a 	add	r2,r2,r2
8110361c:	1085883a 	add	r2,r2,r2
81103620:	e0ff0c04 	addi	r3,fp,-976
81103624:	1885883a 	add	r2,r3,r2
81103628:	10800a04 	addi	r2,r2,40
8110362c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103630:	1023883a 	mov	r17,r2
81103634:	e13f1317 	ldw	r4,-948(fp)
81103638:	11224ac0 	call	811224ac <__extendsfdf2>
8110363c:	1009883a 	mov	r4,r2
81103640:	180b883a 	mov	r5,r3
81103644:	d9000015 	stw	r4,0(sp)
81103648:	d9400115 	stw	r5,4(sp)
8110364c:	880f883a 	mov	r7,r17
81103650:	800d883a 	mov	r6,r16
81103654:	01604574 	movhi	r5,33045
81103658:	2974c604 	addi	r5,r5,-11496
8110365c:	01204574 	movhi	r4,33045
81103660:	2111fe04 	addi	r4,r4,18424
81103664:	11242400 	call	81124240 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103668:	d0a06217 	ldw	r2,-32376(gp)
8110366c:	01604574 	movhi	r5,33045
81103670:	2951fe04 	addi	r5,r5,18424
81103674:	1009883a 	mov	r4,r2
81103678:	112292c0 	call	8112292c <fprintf>
8110367c:	0000f506 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103680:	e0bf1017 	ldw	r2,-960(fp)
81103684:	10006426 	beq	r2,zero,81103818 <sense_log+0x474>
81103688:	e0bf1117 	ldw	r2,-956(fp)
8110368c:	1000621e 	bne	r2,zero,81103818 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103690:	e13f0e17 	ldw	r4,-968(fp)
81103694:	11224ac0 	call	811224ac <__extendsfdf2>
81103698:	1011883a 	mov	r8,r2
8110369c:	1813883a 	mov	r9,r3
811036a0:	000d883a 	mov	r6,zero
811036a4:	01cff834 	movhi	r7,16352
811036a8:	4009883a 	mov	r4,r8
811036ac:	480b883a 	mov	r5,r9
811036b0:	11213240 	call	81121324 <__muldf3>
811036b4:	1009883a 	mov	r4,r2
811036b8:	180b883a 	mov	r5,r3
811036bc:	2021883a 	mov	r16,r4
811036c0:	2823883a 	mov	r17,r5
811036c4:	e13f0d17 	ldw	r4,-972(fp)
811036c8:	11224ac0 	call	811224ac <__extendsfdf2>
811036cc:	1009883a 	mov	r4,r2
811036d0:	180b883a 	mov	r5,r3
811036d4:	200d883a 	mov	r6,r4
811036d8:	280f883a 	mov	r7,r5
811036dc:	8009883a 	mov	r4,r16
811036e0:	880b883a 	mov	r5,r17
811036e4:	11213240 	call	81121324 <__muldf3>
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	2005883a 	mov	r2,r4
811036f4:	2807883a 	mov	r3,r5
811036f8:	1009883a 	mov	r4,r2
811036fc:	180b883a 	mov	r5,r3
81103700:	11225c40 	call	811225c4 <__truncdfsf2>
81103704:	1007883a 	mov	r3,r2
81103708:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	1085883a 	add	r2,r2,r2
81103714:	1085883a 	add	r2,r2,r2
81103718:	e0ff0c04 	addi	r3,fp,-976
8110371c:	1885883a 	add	r2,r3,r2
81103720:	10801604 	addi	r2,r2,88
81103724:	10c00017 	ldw	r3,0(r2)
81103728:	180b883a 	mov	r5,r3
8110372c:	e13f0d17 	ldw	r4,-972(fp)
81103730:	11207d80 	call	811207d8 <__divsf3>
81103734:	1007883a 	mov	r3,r2
81103738:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110373c:	e0bf0c17 	ldw	r2,-976(fp)
81103740:	1085883a 	add	r2,r2,r2
81103744:	1085883a 	add	r2,r2,r2
81103748:	e0ff0c04 	addi	r3,fp,-976
8110374c:	1885883a 	add	r2,r3,r2
81103750:	10802204 	addi	r2,r2,136
81103754:	10c00017 	ldw	r3,0(r2)
81103758:	e17f1417 	ldw	r5,-944(fp)
8110375c:	1809883a 	mov	r4,r3
81103760:	1120c200 	call	81120c20 <__mulsf3>
81103764:	1007883a 	mov	r3,r2
81103768:	e0ff1515 	stw	r3,-940(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110376c:	e0ff3a04 	addi	r3,fp,-792
81103770:	e0bf0c17 	ldw	r2,-976(fp)
81103774:	100491ba 	slli	r2,r2,6
81103778:	18a9883a 	add	r20,r3,r2
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	1085883a 	add	r2,r2,r2
81103784:	1085883a 	add	r2,r2,r2
81103788:	e0ff0c04 	addi	r3,fp,-976
8110378c:	1885883a 	add	r2,r3,r2
81103790:	10800a04 	addi	r2,r2,40
81103794:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#if DEBUG_ON
				sprintf(cDebugBuffer,
81103798:	102b883a 	mov	r21,r2
8110379c:	e13f0d17 	ldw	r4,-972(fp)
811037a0:	11224ac0 	call	811224ac <__extendsfdf2>
811037a4:	1021883a 	mov	r16,r2
811037a8:	1823883a 	mov	r17,r3
811037ac:	e13f1417 	ldw	r4,-944(fp)
811037b0:	11224ac0 	call	811224ac <__extendsfdf2>
811037b4:	1025883a 	mov	r18,r2
811037b8:	1827883a 	mov	r19,r3
811037bc:	e13f1517 	ldw	r4,-940(fp)
811037c0:	11224ac0 	call	811224ac <__extendsfdf2>
811037c4:	1009883a 	mov	r4,r2
811037c8:	180b883a 	mov	r5,r3
811037cc:	d9000415 	stw	r4,16(sp)
811037d0:	d9400515 	stw	r5,20(sp)
811037d4:	dc800215 	stw	r18,8(sp)
811037d8:	dcc00315 	stw	r19,12(sp)
811037dc:	dc000015 	stw	r16,0(sp)
811037e0:	dc400115 	stw	r17,4(sp)
811037e4:	a80f883a 	mov	r7,r21
811037e8:	a00d883a 	mov	r6,r20
811037ec:	01604574 	movhi	r5,33045
811037f0:	2974cf04 	addi	r5,r5,-11460
811037f4:	01204574 	movhi	r4,33045
811037f8:	2111fe04 	addi	r4,r4,18424
811037fc:	11242400 	call	81124240 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103800:	d0a06217 	ldw	r2,-32376(gp)
81103804:	01604574 	movhi	r5,33045
81103808:	2951fe04 	addi	r5,r5,18424
8110380c:	1009883a 	mov	r4,r2
81103810:	112292c0 	call	8112292c <fprintf>
81103814:	00008f06 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103818:	e0bf1017 	ldw	r2,-960(fp)
8110381c:	1000641e 	bne	r2,zero,811039b0 <sense_log+0x60c>
81103820:	e0bf1117 	ldw	r2,-956(fp)
81103824:	10006226 	beq	r2,zero,811039b0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103828:	e13f0e17 	ldw	r4,-968(fp)
8110382c:	11224ac0 	call	811224ac <__extendsfdf2>
81103830:	1011883a 	mov	r8,r2
81103834:	1813883a 	mov	r9,r3
81103838:	000d883a 	mov	r6,zero
8110383c:	01cff834 	movhi	r7,16352
81103840:	4009883a 	mov	r4,r8
81103844:	480b883a 	mov	r5,r9
81103848:	11213240 	call	81121324 <__muldf3>
8110384c:	1009883a 	mov	r4,r2
81103850:	180b883a 	mov	r5,r3
81103854:	2021883a 	mov	r16,r4
81103858:	2823883a 	mov	r17,r5
8110385c:	e13f0d17 	ldw	r4,-972(fp)
81103860:	11224ac0 	call	811224ac <__extendsfdf2>
81103864:	1009883a 	mov	r4,r2
81103868:	180b883a 	mov	r5,r3
8110386c:	200d883a 	mov	r6,r4
81103870:	280f883a 	mov	r7,r5
81103874:	8009883a 	mov	r4,r16
81103878:	880b883a 	mov	r5,r17
8110387c:	11213240 	call	81121324 <__muldf3>
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	2005883a 	mov	r2,r4
8110388c:	2807883a 	mov	r3,r5
81103890:	1009883a 	mov	r4,r2
81103894:	180b883a 	mov	r5,r3
81103898:	11225c40 	call	811225c4 <__truncdfsf2>
8110389c:	1007883a 	mov	r3,r2
811038a0:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	1085883a 	add	r2,r2,r2
811038ac:	1085883a 	add	r2,r2,r2
811038b0:	e0ff0c04 	addi	r3,fp,-976
811038b4:	1885883a 	add	r2,r3,r2
811038b8:	10801604 	addi	r2,r2,88
811038bc:	10c00017 	ldw	r3,0(r2)
811038c0:	180b883a 	mov	r5,r3
811038c4:	e13f0d17 	ldw	r4,-972(fp)
811038c8:	11207d80 	call	811207d8 <__divsf3>
811038cc:	1007883a 	mov	r3,r2
811038d0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038d4:	e0bf0c17 	ldw	r2,-976(fp)
811038d8:	1085883a 	add	r2,r2,r2
811038dc:	1085883a 	add	r2,r2,r2
811038e0:	e0ff0c04 	addi	r3,fp,-976
811038e4:	1885883a 	add	r2,r3,r2
811038e8:	10802204 	addi	r2,r2,136
811038ec:	10c00017 	ldw	r3,0(r2)
811038f0:	e17f1417 	ldw	r5,-944(fp)
811038f4:	1809883a 	mov	r4,r3
811038f8:	1120c200 	call	81120c20 <__mulsf3>
811038fc:	1007883a 	mov	r3,r2
81103900:	e0ff1515 	stw	r3,-940(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103904:	e0ff3a04 	addi	r3,fp,-792
81103908:	e0bf0c17 	ldw	r2,-976(fp)
8110390c:	100491ba 	slli	r2,r2,6
81103910:	18a9883a 	add	r20,r3,r2
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	1085883a 	add	r2,r2,r2
8110391c:	1085883a 	add	r2,r2,r2
81103920:	e0ff0c04 	addi	r3,fp,-976
81103924:	1885883a 	add	r2,r3,r2
81103928:	10800a04 	addi	r2,r2,40
8110392c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#if DEBUG_ON
				sprintf(cDebugBuffer,
81103930:	102b883a 	mov	r21,r2
81103934:	e13f0d17 	ldw	r4,-972(fp)
81103938:	11224ac0 	call	811224ac <__extendsfdf2>
8110393c:	1021883a 	mov	r16,r2
81103940:	1823883a 	mov	r17,r3
81103944:	e13f1417 	ldw	r4,-944(fp)
81103948:	11224ac0 	call	811224ac <__extendsfdf2>
8110394c:	1025883a 	mov	r18,r2
81103950:	1827883a 	mov	r19,r3
81103954:	e13f1517 	ldw	r4,-940(fp)
81103958:	11224ac0 	call	811224ac <__extendsfdf2>
8110395c:	1009883a 	mov	r4,r2
81103960:	180b883a 	mov	r5,r3
81103964:	d9000415 	stw	r4,16(sp)
81103968:	d9400515 	stw	r5,20(sp)
8110396c:	dc800215 	stw	r18,8(sp)
81103970:	dcc00315 	stw	r19,12(sp)
81103974:	dc000015 	stw	r16,0(sp)
81103978:	dc400115 	stw	r17,4(sp)
8110397c:	a80f883a 	mov	r7,r21
81103980:	a00d883a 	mov	r6,r20
81103984:	01604574 	movhi	r5,33045
81103988:	2974df04 	addi	r5,r5,-11396
8110398c:	01204574 	movhi	r4,33045
81103990:	2111fe04 	addi	r4,r4,18424
81103994:	11242400 	call	81124240 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103998:	d0a06217 	ldw	r2,-32376(gp)
8110399c:	01604574 	movhi	r5,33045
811039a0:	2951fe04 	addi	r5,r5,18424
811039a4:	1009883a 	mov	r4,r2
811039a8:	112292c0 	call	8112292c <fprintf>
811039ac:	00002906 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039b0:	e0bf1017 	ldw	r2,-960(fp)
811039b4:	1000271e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
811039b8:	e0bf1117 	ldw	r2,-956(fp)
811039bc:	1000251e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039c0:	e0bf0e17 	ldw	r2,-968(fp)
811039c4:	10a0003c 	xorhi	r2,r2,32768
811039c8:	014fc034 	movhi	r5,16128
811039cc:	1009883a 	mov	r4,r2
811039d0:	1120c200 	call	81120c20 <__mulsf3>
811039d4:	1007883a 	mov	r3,r2
811039d8:	e0ff1315 	stw	r3,-948(fp)
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039dc:	e0ff3a04 	addi	r3,fp,-792
811039e0:	e0bf0c17 	ldw	r2,-976(fp)
811039e4:	100491ba 	slli	r2,r2,6
811039e8:	18a1883a 	add	r16,r3,r2
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	1085883a 	add	r2,r2,r2
811039f4:	1085883a 	add	r2,r2,r2
811039f8:	e0ff0c04 	addi	r3,fp,-976
811039fc:	1885883a 	add	r2,r3,r2
81103a00:	10800a04 	addi	r2,r2,40
81103a04:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a08:	1023883a 	mov	r17,r2
81103a0c:	e13f1317 	ldw	r4,-948(fp)
81103a10:	11224ac0 	call	811224ac <__extendsfdf2>
81103a14:	1009883a 	mov	r4,r2
81103a18:	180b883a 	mov	r5,r3
81103a1c:	d9000015 	stw	r4,0(sp)
81103a20:	d9400115 	stw	r5,4(sp)
81103a24:	880f883a 	mov	r7,r17
81103a28:	800d883a 	mov	r6,r16
81103a2c:	01604574 	movhi	r5,33045
81103a30:	2974ef04 	addi	r5,r5,-11332
81103a34:	01204574 	movhi	r4,33045
81103a38:	2111fe04 	addi	r4,r4,18424
81103a3c:	11242400 	call	81124240 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a40:	d0a06217 	ldw	r2,-32376(gp)
81103a44:	01604574 	movhi	r5,33045
81103a48:	2951fe04 	addi	r5,r5,18424
81103a4c:	1009883a 	mov	r4,r2
81103a50:	112292c0 	call	8112292c <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a54:	e0bf0c17 	ldw	r2,-976(fp)
81103a58:	10800044 	addi	r2,r2,1
81103a5c:	e0bf0c15 	stw	r2,-976(fp)
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800308 	cmpgei	r2,r2,12
81103a68:	1000021e 	bne	r2,zero,81103a74 <sense_log+0x6d0>
81103a6c:	e0bf0f17 	ldw	r2,-964(fp)
81103a70:	103eaf1e 	bne	r2,zero,81103530 <__reset+0xfb0e3530>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#if DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a74:	00a04574 	movhi	r2,33045
81103a78:	1091fe04 	addi	r2,r2,18424
81103a7c:	00c00344 	movi	r3,13
81103a80:	10c00005 	stb	r3,0(r2)
81103a84:	00c00284 	movi	r3,10
81103a88:	10c00045 	stb	r3,1(r2)
81103a8c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a90:	d0a06217 	ldw	r2,-32376(gp)
81103a94:	01604574 	movhi	r5,33045
81103a98:	2951fe04 	addi	r5,r5,18424
81103a9c:	1009883a 	mov	r4,r2
81103aa0:	112292c0 	call	8112292c <fprintf>
#if DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103aa4:	00001606 	br	81103b00 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#if DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103aa8:	00a04574 	movhi	r2,33045
81103aac:	1091fe04 	addi	r2,r2,18424
81103ab0:	00c01144 	movi	r3,69
81103ab4:	10c00005 	stb	r3,0(r2)
81103ab8:	00c01c84 	movi	r3,114
81103abc:	10c00045 	stb	r3,1(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00085 	stb	r3,2(r2)
81103ac8:	00c01bc4 	movi	r3,111
81103acc:	10c000c5 	stb	r3,3(r2)
81103ad0:	00c01c84 	movi	r3,114
81103ad4:	10c00105 	stb	r3,4(r2)
81103ad8:	00c00344 	movi	r3,13
81103adc:	10c00145 	stb	r3,5(r2)
81103ae0:	00c00284 	movi	r3,10
81103ae4:	10c00185 	stb	r3,6(r2)
81103ae8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103aec:	d0a06217 	ldw	r2,-32376(gp)
81103af0:	01604574 	movhi	r5,33045
81103af4:	2951fe04 	addi	r5,r5,18424
81103af8:	1009883a 	mov	r4,r2
81103afc:	112292c0 	call	8112292c <fprintf>
#endif
	}
}
81103b00:	0001883a 	nop
81103b04:	e6fffa04 	addi	sp,fp,-24
81103b08:	dfc00717 	ldw	ra,28(sp)
81103b0c:	df000617 	ldw	fp,24(sp)
81103b10:	dd400517 	ldw	r21,20(sp)
81103b14:	dd000417 	ldw	r20,16(sp)
81103b18:	dcc00317 	ldw	r19,12(sp)
81103b1c:	dc800217 	ldw	r18,8(sp)
81103b20:	dc400117 	ldw	r17,4(sp)
81103b24:	dc000017 	ldw	r16,0(sp)
81103b28:	dec00804 	addi	sp,sp,32
81103b2c:	f800283a 	ret

81103b30 <bSdmaInitM1Dma>:
alt_msgdma_dev *pxDmaM1Dev = NULL;
alt_msgdma_dev *pxDmaM2Dev = NULL;
//! [data memory public global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b30:	defffb04 	addi	sp,sp,-20
81103b34:	de00012e 	bgeu	sp,et,81103b3c <bSdmaInitM1Dma+0xc>
81103b38:	003b68fa 	trap	3
81103b3c:	dfc00415 	stw	ra,16(sp)
81103b40:	df000315 	stw	fp,12(sp)
81103b44:	df000304 	addi	fp,sp,12
	bool bStatus = FALSE;
81103b48:	e03ffd15 	stw	zero,-12(fp)
	bool bFailDispatcher = FALSE;
81103b4c:	e03ffe15 	stw	zero,-8(fp)
	alt_u16 usiCounter = 0;
81103b50:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b54:	01204574 	movhi	r4,33045
81103b58:	2135b804 	addi	r4,r4,-10528
81103b5c:	114b0600 	call	8114b060 <alt_msgdma_open>
81103b60:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev != NULL) {
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	10001a26 	beq	r2,zero,81103bd4 <bSdmaInitM1Dma+0xa4>
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81103b6c:	d0a03917 	ldw	r2,-32540(gp)
81103b70:	10800317 	ldw	r2,12(r2)
81103b74:	10800104 	addi	r2,r2,4
81103b78:	00c00084 	movi	r3,2
81103b7c:	10c00035 	stwio	r3,0(r2)
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103b80:	00000b06 	br	81103bb0 <bSdmaInitM1Dma+0x80>
			usleep(1);
81103b84:	01000044 	movi	r4,1
81103b88:	1138fc80 	call	81138fc8 <usleep>
			usiCounter++;
81103b8c:	e0bfff0b 	ldhu	r2,-4(fp)
81103b90:	10800044 	addi	r2,r2,1
81103b94:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103b98:	e0bfff0b 	ldhu	r2,-4(fp)
81103b9c:	1084e230 	cmpltui	r2,r2,5000
81103ba0:	1000031e 	bne	r2,zero,81103bb0 <bSdmaInitM1Dma+0x80>
				bFailDispatcher = TRUE;
81103ba4:	00800044 	movi	r2,1
81103ba8:	e0bffe15 	stw	r2,-8(fp)
				break;
81103bac:	00000506 	br	81103bc4 <bSdmaInitM1Dma+0x94>
	// check if the device was opened
	if (pxDmaM1Dev != NULL) {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bb0:	d0a03917 	ldw	r2,-32540(gp)
81103bb4:	10800317 	ldw	r2,12(r2)
81103bb8:	10800037 	ldwio	r2,0(r2)
81103bbc:	1080100c 	andi	r2,r2,64
81103bc0:	103ff01e 	bne	r2,zero,81103b84 <__reset+0xfb0e3b84>
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
				bFailDispatcher = TRUE;
				break;
			}
		}
		if (bFailDispatcher == FALSE)
81103bc4:	e0bffe17 	ldw	r2,-8(fp)
81103bc8:	1000021e 	bne	r2,zero,81103bd4 <bSdmaInitM1Dma+0xa4>
			bStatus = TRUE;
81103bcc:	00800044 	movi	r2,1
81103bd0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81103bd4:	e0bffd17 	ldw	r2,-12(fp)
}
81103bd8:	e037883a 	mov	sp,fp
81103bdc:	dfc00117 	ldw	ra,4(sp)
81103be0:	df000017 	ldw	fp,0(sp)
81103be4:	dec00204 	addi	sp,sp,8
81103be8:	f800283a 	ret

81103bec <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103bec:	defffb04 	addi	sp,sp,-20
81103bf0:	de00012e 	bgeu	sp,et,81103bf8 <bSdmaInitM2Dma+0xc>
81103bf4:	003b68fa 	trap	3
81103bf8:	dfc00415 	stw	ra,16(sp)
81103bfc:	df000315 	stw	fp,12(sp)
81103c00:	df000304 	addi	fp,sp,12
	bool bStatus = FALSE;
81103c04:	e03ffd15 	stw	zero,-12(fp)
	bool bFailDispatcher = FALSE;
81103c08:	e03ffe15 	stw	zero,-8(fp)
	alt_u16 usiCounter = 0;
81103c0c:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c10:	01204574 	movhi	r4,33045
81103c14:	2135bd04 	addi	r4,r4,-10508
81103c18:	114b0600 	call	8114b060 <alt_msgdma_open>
81103c1c:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c20:	d0a03a17 	ldw	r2,-32536(gp)
81103c24:	1000021e 	bne	r2,zero,81103c30 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c28:	e03ffd15 	stw	zero,-12(fp)
81103c2c:	00001a06 	br	81103c98 <bSdmaInitM2Dma+0xac>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81103c30:	d0a03a17 	ldw	r2,-32536(gp)
81103c34:	10800317 	ldw	r2,12(r2)
81103c38:	10800104 	addi	r2,r2,4
81103c3c:	00c00084 	movi	r3,2
81103c40:	10c00035 	stwio	r3,0(r2)
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c44:	00000b06 	br	81103c74 <bSdmaInitM2Dma+0x88>
			usleep(1);
81103c48:	01000044 	movi	r4,1
81103c4c:	1138fc80 	call	81138fc8 <usleep>
			usiCounter++;
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	10800044 	addi	r2,r2,1
81103c58:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c5c:	e0bfff0b 	ldhu	r2,-4(fp)
81103c60:	1084e230 	cmpltui	r2,r2,5000
81103c64:	1000031e 	bne	r2,zero,81103c74 <bSdmaInitM2Dma+0x88>
				bFailDispatcher = TRUE;
81103c68:	00800044 	movi	r2,1
81103c6c:	e0bffe15 	stw	r2,-8(fp)
				break;
81103c70:	00000506 	br	81103c88 <bSdmaInitM2Dma+0x9c>
		bStatus = FALSE;
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c74:	d0a03a17 	ldw	r2,-32536(gp)
81103c78:	10800317 	ldw	r2,12(r2)
81103c7c:	10800037 	ldwio	r2,0(r2)
81103c80:	1080100c 	andi	r2,r2,64
81103c84:	103ff01e 	bne	r2,zero,81103c48 <__reset+0xfb0e3c48>
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
				bFailDispatcher = TRUE;
				break;
			}
		}
		if (bFailDispatcher == FALSE)
81103c88:	e0bffe17 	ldw	r2,-8(fp)
81103c8c:	1000021e 	bne	r2,zero,81103c98 <bSdmaInitM2Dma+0xac>
			bStatus = TRUE;
81103c90:	00800044 	movi	r2,1
81103c94:	e0bffd15 	stw	r2,-12(fp)
	}
	return bStatus;
81103c98:	e0bffd17 	ldw	r2,-12(fp)
}
81103c9c:	e037883a 	mov	sp,fp
81103ca0:	dfc00117 	ldw	ra,4(sp)
81103ca4:	df000017 	ldw	fp,0(sp)
81103ca8:	dec00204 	addi	sp,sp,8
81103cac:	f800283a 	ret

81103cb0 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
81103cb0:	deffe804 	addi	sp,sp,-96
81103cb4:	de00012e 	bgeu	sp,et,81103cbc <bSdmaDmaM1Transfer+0xc>
81103cb8:	003b68fa 	trap	3
81103cbc:	dfc01715 	stw	ra,92(sp)
81103cc0:	df001615 	stw	fp,88(sp)
81103cc4:	dc001515 	stw	r16,84(sp)
81103cc8:	df001604 	addi	fp,sp,88
81103ccc:	e13ffb15 	stw	r4,-20(fp)
81103cd0:	2809883a 	mov	r4,r5
81103cd4:	3007883a 	mov	r3,r6
81103cd8:	3805883a 	mov	r2,r7
81103cdc:	e13ffc0d 	sth	r4,-16(fp)
81103ce0:	e0fffd05 	stb	r3,-12(fp)
81103ce4:	e0bffe05 	stb	r2,-8(fp)
81103ce8:	defff004 	addi	sp,sp,-64
81103cec:	d8800904 	addi	r2,sp,36
81103cf0:	108007c4 	addi	r2,r2,31
81103cf4:	1004d17a 	srli	r2,r2,5
81103cf8:	1020917a 	slli	r16,r2,5
	bool bStatus;

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103cfc:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
81103d00:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
81103d04:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103d08:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103d0c:	e03ffa15 	stw	zero,-24(fp)
	bool bBufferEmptyFlag;
	bool bChannelFlag;

	/* Assuming that the channel selected exist, change to FALSE if doesn't */
	bChannelFlag = TRUE;
81103d10:	00800044 	movi	r2,1
81103d14:	e0bff715 	stw	r2,-36(fp)
	bStatus = FALSE;
81103d18:	e03ff315 	stw	zero,-52(fp)
	bBufferEmptyFlag = FALSE;
81103d1c:	e03ff615 	stw	zero,-40(fp)
	switch (ucChBufferId) {
81103d20:	e0bffe03 	ldbu	r2,-8(fp)
81103d24:	10c00228 	cmpgeui	r3,r2,8
81103d28:	1800b81e 	bne	r3,zero,8110400c <bSdmaDmaM1Transfer+0x35c>
81103d2c:	100690ba 	slli	r3,r2,2
81103d30:	00a04434 	movhi	r2,33040
81103d34:	108f5104 	addi	r2,r2,15684
81103d38:	1885883a 	add	r2,r3,r2
81103d3c:	10800017 	ldw	r2,0(r2)
81103d40:	1000683a 	jmp	r2
81103d44:	81103d64 	muli	r4,r16,16629
81103d48:	81103db8 	rdprs	r4,r16,16630
81103d4c:	81103e14 	ori	r4,r16,16632
81103d50:	81103e68 	cmpgeui	r4,r16,16633
81103d54:	81103ebc 	xorhi	r4,r16,16634
81103d58:	81103f10 	cmplti	r4,r16,16636
81103d5c:	81103f64 	muli	r4,r16,16637
81103d60:	81103fb8 	rdprs	r4,r16,16638
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d64:	e0bffd03 	ldbu	r2,-12(fp)
81103d68:	10000826 	beq	r2,zero,81103d8c <bSdmaDmaM1Transfer+0xdc>
81103d6c:	10800060 	cmpeqi	r2,r2,1
81103d70:	10000d26 	beq	r2,zero,81103da8 <bSdmaDmaM1Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d74:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d78:	00800044 	movi	r2,1
81103d7c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
81103d80:	11064c00 	call	811064c0 <bFeebGetCh1RightBufferEmpty>
81103d84:	e0bff615 	stw	r2,-40(fp)
			break;
81103d88:	00000a06 	br	81103db4 <bSdmaDmaM1Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d8c:	00800074 	movhi	r2,1
81103d90:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d94:	00800044 	movi	r2,1
81103d98:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
81103d9c:	11064580 	call	81106458 <bFeebGetCh1LeftBufferEmpty>
81103da0:	e0bff615 	stw	r2,-40(fp)
			break;
81103da4:	00000306 	br	81103db4 <bSdmaDmaM1Transfer+0x104>
		default:
			bChannelFlag = FALSE;
81103da8:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103dac:	e03ff615 	stw	zero,-40(fp)
			break;
81103db0:	0001883a 	nop
		}
		break;
81103db4:	00009706 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103db8:	e0bffd03 	ldbu	r2,-12(fp)
81103dbc:	10000926 	beq	r2,zero,81103de4 <bSdmaDmaM1Transfer+0x134>
81103dc0:	10800060 	cmpeqi	r2,r2,1
81103dc4:	10000f26 	beq	r2,zero,81103e04 <bSdmaDmaM1Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103dc8:	00880004 	movi	r2,8192
81103dcc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103dd0:	00800044 	movi	r2,1
81103dd4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81103dd8:	11065900 	call	81106590 <bFeebGetCh2RightBufferEmpty>
81103ddc:	e0bff615 	stw	r2,-40(fp)
			break;
81103de0:	00000b06 	br	81103e10 <bSdmaDmaM1Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103de4:	00800074 	movhi	r2,1
81103de8:	10880004 	addi	r2,r2,8192
81103dec:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103df0:	00800044 	movi	r2,1
81103df4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
81103df8:	11065280 	call	81106528 <bFeebGetCh2LeftBufferEmpty>
81103dfc:	e0bff615 	stw	r2,-40(fp)
			break;
81103e00:	00000306 	br	81103e10 <bSdmaDmaM1Transfer+0x160>
		default:
			bChannelFlag = FALSE;
81103e04:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103e08:	e03ff615 	stw	zero,-40(fp)
			break;
81103e0c:	0001883a 	nop
		}
		break;
81103e10:	00008006 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103e14:	e0bffd03 	ldbu	r2,-12(fp)
81103e18:	10000826 	beq	r2,zero,81103e3c <bSdmaDmaM1Transfer+0x18c>
81103e1c:	10800060 	cmpeqi	r2,r2,1
81103e20:	10000d26 	beq	r2,zero,81103e58 <bSdmaDmaM1Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103e24:	00900004 	movi	r2,16384
81103e28:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103e2c:	00800044 	movi	r2,1
81103e30:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e34:	e03ff615 	stw	zero,-40(fp)
			break;
81103e38:	00000a06 	br	81103e64 <bSdmaDmaM1Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103e3c:	00800074 	movhi	r2,1
81103e40:	10900004 	addi	r2,r2,16384
81103e44:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103e48:	00800044 	movi	r2,1
81103e4c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e50:	e03ff615 	stw	zero,-40(fp)
			break;
81103e54:	00000306 	br	81103e64 <bSdmaDmaM1Transfer+0x1b4>
		default:
			bChannelFlag = FALSE;
81103e58:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103e5c:	e03ff615 	stw	zero,-40(fp)
			break;
81103e60:	0001883a 	nop
		}
		break;
81103e64:	00006b06 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e68:	e0bffd03 	ldbu	r2,-12(fp)
81103e6c:	10000826 	beq	r2,zero,81103e90 <bSdmaDmaM1Transfer+0x1e0>
81103e70:	10800060 	cmpeqi	r2,r2,1
81103e74:	10000d26 	beq	r2,zero,81103eac <bSdmaDmaM1Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e78:	00980004 	movi	r2,24576
81103e7c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e80:	00800044 	movi	r2,1
81103e84:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e88:	e03ff615 	stw	zero,-40(fp)
			break;
81103e8c:	00000a06 	br	81103eb8 <bSdmaDmaM1Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e90:	00800074 	movhi	r2,1
81103e94:	10980004 	addi	r2,r2,24576
81103e98:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e9c:	00800044 	movi	r2,1
81103ea0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ea4:	e03ff615 	stw	zero,-40(fp)
			break;
81103ea8:	00000306 	br	81103eb8 <bSdmaDmaM1Transfer+0x208>
		default:
			bChannelFlag = FALSE;
81103eac:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103eb0:	e03ff615 	stw	zero,-40(fp)
			break;
81103eb4:	0001883a 	nop
		}
		break;
81103eb8:	00005606 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103ebc:	e0bffd03 	ldbu	r2,-12(fp)
81103ec0:	10000826 	beq	r2,zero,81103ee4 <bSdmaDmaM1Transfer+0x234>
81103ec4:	10800060 	cmpeqi	r2,r2,1
81103ec8:	10000d26 	beq	r2,zero,81103f00 <bSdmaDmaM1Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103ecc:	00a00014 	movui	r2,32768
81103ed0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103ed4:	00800044 	movi	r2,1
81103ed8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103edc:	e03ff615 	stw	zero,-40(fp)
			break;
81103ee0:	00000a06 	br	81103f0c <bSdmaDmaM1Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103ee4:	008000b4 	movhi	r2,2
81103ee8:	10a00004 	addi	r2,r2,-32768
81103eec:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103ef0:	00800044 	movi	r2,1
81103ef4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ef8:	e03ff615 	stw	zero,-40(fp)
			break;
81103efc:	00000306 	br	81103f0c <bSdmaDmaM1Transfer+0x25c>
		default:
			bChannelFlag = FALSE;
81103f00:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103f04:	e03ff615 	stw	zero,-40(fp)
			break;
81103f08:	0001883a 	nop
		}
		break;
81103f0c:	00004106 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103f10:	e0bffd03 	ldbu	r2,-12(fp)
81103f14:	10000826 	beq	r2,zero,81103f38 <bSdmaDmaM1Transfer+0x288>
81103f18:	10800060 	cmpeqi	r2,r2,1
81103f1c:	10000d26 	beq	r2,zero,81103f54 <bSdmaDmaM1Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103f20:	00a80014 	movui	r2,40960
81103f24:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103f28:	00800044 	movi	r2,1
81103f2c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f30:	e03ff615 	stw	zero,-40(fp)
			break;
81103f34:	00000a06 	br	81103f60 <bSdmaDmaM1Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103f38:	008000b4 	movhi	r2,2
81103f3c:	10a80004 	addi	r2,r2,-24576
81103f40:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103f44:	00800044 	movi	r2,1
81103f48:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f4c:	e03ff615 	stw	zero,-40(fp)
			break;
81103f50:	00000306 	br	81103f60 <bSdmaDmaM1Transfer+0x2b0>
		default:
			bChannelFlag = FALSE;
81103f54:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103f58:	e03ff615 	stw	zero,-40(fp)
			break;
81103f5c:	0001883a 	nop
		}
		break;
81103f60:	00002c06 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103f64:	e0bffd03 	ldbu	r2,-12(fp)
81103f68:	10000826 	beq	r2,zero,81103f8c <bSdmaDmaM1Transfer+0x2dc>
81103f6c:	10800060 	cmpeqi	r2,r2,1
81103f70:	10000d26 	beq	r2,zero,81103fa8 <bSdmaDmaM1Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103f74:	00b00014 	movui	r2,49152
81103f78:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f7c:	00800044 	movi	r2,1
81103f80:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f84:	e03ff615 	stw	zero,-40(fp)
			break;
81103f88:	00000a06 	br	81103fb4 <bSdmaDmaM1Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f8c:	008000b4 	movhi	r2,2
81103f90:	10b00004 	addi	r2,r2,-16384
81103f94:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f98:	00800044 	movi	r2,1
81103f9c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fa0:	e03ff615 	stw	zero,-40(fp)
			break;
81103fa4:	00000306 	br	81103fb4 <bSdmaDmaM1Transfer+0x304>
		default:
			bChannelFlag = FALSE;
81103fa8:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81103fac:	e03ff615 	stw	zero,-40(fp)
			break;
81103fb0:	0001883a 	nop
		}
		break;
81103fb4:	00001706 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103fb8:	e0bffd03 	ldbu	r2,-12(fp)
81103fbc:	10000826 	beq	r2,zero,81103fe0 <bSdmaDmaM1Transfer+0x330>
81103fc0:	10800060 	cmpeqi	r2,r2,1
81103fc4:	10000d26 	beq	r2,zero,81103ffc <bSdmaDmaM1Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103fc8:	00b80014 	movui	r2,57344
81103fcc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103fd0:	00800044 	movi	r2,1
81103fd4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fd8:	e03ff615 	stw	zero,-40(fp)
			break;
81103fdc:	00000a06 	br	81104008 <bSdmaDmaM1Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103fe0:	008000b4 	movhi	r2,2
81103fe4:	10b80004 	addi	r2,r2,-8192
81103fe8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103fec:	00800044 	movi	r2,1
81103ff0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ff4:	e03ff615 	stw	zero,-40(fp)
			break;
81103ff8:	00000306 	br	81104008 <bSdmaDmaM1Transfer+0x358>
		default:
			bChannelFlag = FALSE;
81103ffc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104000:	e03ff615 	stw	zero,-40(fp)
			break;
81104004:	0001883a 	nop
		}
		break;
81104008:	00000206 	br	81104014 <bSdmaDmaM1Transfer+0x364>
	default:
		bChannelFlag = FALSE;
8110400c:	e03ff715 	stw	zero,-36(fp)
		break;
81104010:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW	+ (alt_u32) uliDdrInitialAddr;
81104014:	e0bffb17 	ldw	r2,-20(fp)
81104018:	e0bff815 	stw	r2,-32(fp)
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
8110401c:	e03ff915 	stw	zero,-28(fp)

	if ( (bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
81104020:	e0bff717 	ldw	r2,-36(fp)
81104024:	10003026 	beq	r2,zero,811040e8 <bSdmaDmaM1Transfer+0x438>
81104028:	e0bff617 	ldw	r2,-40(fp)
8110402c:	10002e26 	beq	r2,zero,811040e8 <bSdmaDmaM1Transfer+0x438>
81104030:	e0bffc0b 	ldhu	r2,-16(fp)
81104034:	10800468 	cmpgeui	r2,r2,17
81104038:	10002b1e 	bne	r2,zero,811040e8 <bSdmaDmaM1Transfer+0x438>

		if (pxDmaM1Dev != NULL) {
8110403c:	d0a03917 	ldw	r2,-32540(gp)
81104040:	10002926 	beq	r2,zero,811040e8 <bSdmaDmaM1Transfer+0x438>
			// hold transfers for descriptor fifo space
			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104044:	00000206 	br	81104050 <bSdmaDmaM1Transfer+0x3a0>
				alt_busy_sleep(1); /* delay 1us */
81104048:	01000044 	movi	r4,1
8110404c:	11375540 	call	81137554 <alt_busy_sleep>

	if ( (bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {

		if (pxDmaM1Dev != NULL) {
			// hold transfers for descriptor fifo space
			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104050:	d0a03917 	ldw	r2,-32540(gp)
81104054:	10800317 	ldw	r2,12(r2)
81104058:	10800037 	ldwio	r2,0(r2)
8110405c:	1080010c 	andi	r2,r2,4
81104060:	103ff91e 	bne	r2,zero,81104048 <__reset+0xfb0e4048>
				alt_busy_sleep(1); /* delay 1us */
			}
			/* Success = 0 */
			if (0 == iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81104064:	d2203917 	ldw	r8,-32540(gp)
81104068:	e1bff817 	ldw	r6,-32(fp)
8110406c:	e1fff417 	ldw	r7,-48(fp)
81104070:	e0bffc0b 	ldhu	r2,-16(fp)
81104074:	10802224 	muli	r2,r2,136
81104078:	e0fff917 	ldw	r3,-28(fp)
8110407c:	e13ff517 	ldw	r4,-44(fp)
81104080:	01400044 	movi	r5,1
81104084:	d9400815 	stw	r5,32(sp)
81104088:	01400044 	movi	r5,1
8110408c:	d9400715 	stw	r5,28(sp)
81104090:	01400044 	movi	r5,1
81104094:	d9400615 	stw	r5,24(sp)
81104098:	01400044 	movi	r5,1
8110409c:	d9400515 	stw	r5,20(sp)
811040a0:	01400044 	movi	r5,1
811040a4:	d9400415 	stw	r5,16(sp)
811040a8:	d9000315 	stw	r4,12(sp)
811040ac:	d8c00215 	stw	r3,8(sp)
811040b0:	e0fffa17 	ldw	r3,-24(fp)
811040b4:	d8c00115 	stw	r3,4(sp)
811040b8:	d8800015 	stw	r2,0(sp)
811040bc:	800b883a 	mov	r5,r16
811040c0:	4009883a 	mov	r4,r8
811040c4:	110bcf80 	call	8110bcf8 <iMsgdmaConstructExtendedMmToMmDescriptor>
811040c8:	1000071e 	bne	r2,zero,811040e8 <bSdmaDmaM1Transfer+0x438>
					(alt_u32 *) uliDestAddrLow,
					SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
					(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
					1, 1, 1, 1, 1)	) {
				/* Success = 0 */
				if (0 == iMsgdmaExtendedDescriptorAsyncTransfer(pxDmaM1Dev,	&xDmaExtendedDescriptor)) {
811040cc:	d0a03917 	ldw	r2,-32540(gp)
811040d0:	800b883a 	mov	r5,r16
811040d4:	1009883a 	mov	r4,r2
811040d8:	110bdb80 	call	8110bdb8 <iMsgdmaExtendedDescriptorAsyncTransfer>
811040dc:	1000021e 	bne	r2,zero,811040e8 <bSdmaDmaM1Transfer+0x438>
					bStatus = TRUE;
811040e0:	00800044 	movi	r2,1
811040e4:	e0bff315 	stw	r2,-52(fp)
				}
			}
		}
	}
	return bStatus;
811040e8:	e0bff317 	ldw	r2,-52(fp)
}
811040ec:	e6ffff04 	addi	sp,fp,-4
811040f0:	dfc00217 	ldw	ra,8(sp)
811040f4:	df000117 	ldw	fp,4(sp)
811040f8:	dc000017 	ldw	r16,0(sp)
811040fc:	dec00304 	addi	sp,sp,12
81104100:	f800283a 	ret

81104104 <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
81104104:	deffe804 	addi	sp,sp,-96
81104108:	de00012e 	bgeu	sp,et,81104110 <bSdmaDmaM2Transfer+0xc>
8110410c:	003b68fa 	trap	3
81104110:	dfc01715 	stw	ra,92(sp)
81104114:	df001615 	stw	fp,88(sp)
81104118:	dc001515 	stw	r16,84(sp)
8110411c:	df001604 	addi	fp,sp,88
81104120:	e13ffb15 	stw	r4,-20(fp)
81104124:	2809883a 	mov	r4,r5
81104128:	3007883a 	mov	r3,r6
8110412c:	3805883a 	mov	r2,r7
81104130:	e13ffc0d 	sth	r4,-16(fp)
81104134:	e0fffd05 	stb	r3,-12(fp)
81104138:	e0bffe05 	stb	r2,-8(fp)
8110413c:	defff004 	addi	sp,sp,-64
81104140:	d8800904 	addi	r2,sp,36
81104144:	108007c4 	addi	r2,r2,31
81104148:	1004d17a 	srli	r2,r2,5
8110414c:	1020917a 	slli	r16,r2,5
	bool bStatus;

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81104150:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
81104154:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
81104158:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
8110415c:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104160:	e03ffa15 	stw	zero,-24(fp)
	bool bBufferEmptyFlag;
	bool bChannelFlag;


	/* Assuming that the channel selected exist, change to FALSE if doesn't */
	bChannelFlag = TRUE;
81104164:	00800044 	movi	r2,1
81104168:	e0bff715 	stw	r2,-36(fp)
	bStatus = FALSE;
8110416c:	e03ff315 	stw	zero,-52(fp)
	bBufferEmptyFlag = FALSE;
81104170:	e03ff615 	stw	zero,-40(fp)
	switch (ucChBufferId) {
81104174:	e0bffe03 	ldbu	r2,-8(fp)
81104178:	10c00228 	cmpgeui	r3,r2,8
8110417c:	1800b81e 	bne	r3,zero,81104460 <bSdmaDmaM2Transfer+0x35c>
81104180:	100690ba 	slli	r3,r2,2
81104184:	00a04434 	movhi	r2,33040
81104188:	10906604 	addi	r2,r2,16792
8110418c:	1885883a 	add	r2,r3,r2
81104190:	10800017 	ldw	r2,0(r2)
81104194:	1000683a 	jmp	r2
81104198:	811041b8 	rdprs	r4,r16,16646
8110419c:	8110420c 	andi	r4,r16,16648
811041a0:	81104268 	cmpgeui	r4,r16,16649
811041a4:	811042bc 	xorhi	r4,r16,16650
811041a8:	81104310 	cmplti	r4,r16,16652
811041ac:	81104364 	muli	r4,r16,16653
811041b0:	811043b8 	rdprs	r4,r16,16654
811041b4:	8110440c 	andi	r4,r16,16656
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
811041b8:	e0bffd03 	ldbu	r2,-12(fp)
811041bc:	10000826 	beq	r2,zero,811041e0 <bSdmaDmaM2Transfer+0xdc>
811041c0:	10800060 	cmpeqi	r2,r2,1
811041c4:	10000d26 	beq	r2,zero,811041fc <bSdmaDmaM2Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
811041c8:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
811041cc:	00800044 	movi	r2,1
811041d0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
811041d4:	11064c00 	call	811064c0 <bFeebGetCh1RightBufferEmpty>
811041d8:	e0bff615 	stw	r2,-40(fp)
			break;
811041dc:	00000a06 	br	81104208 <bSdmaDmaM2Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
811041e0:	00800074 	movhi	r2,1
811041e4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
811041e8:	00800044 	movi	r2,1
811041ec:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
811041f0:	11064580 	call	81106458 <bFeebGetCh1LeftBufferEmpty>
811041f4:	e0bff615 	stw	r2,-40(fp)
			break;
811041f8:	00000306 	br	81104208 <bSdmaDmaM2Transfer+0x104>
		default:
			bChannelFlag = FALSE;
811041fc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104200:	e03ff615 	stw	zero,-40(fp)
			break;
81104204:	0001883a 	nop
		}
		break;
81104208:	00009706 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
8110420c:	e0bffd03 	ldbu	r2,-12(fp)
81104210:	10000926 	beq	r2,zero,81104238 <bSdmaDmaM2Transfer+0x134>
81104214:	10800060 	cmpeqi	r2,r2,1
81104218:	10000f26 	beq	r2,zero,81104258 <bSdmaDmaM2Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
8110421c:	00880004 	movi	r2,8192
81104220:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81104224:	00800044 	movi	r2,1
81104228:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
8110422c:	11065900 	call	81106590 <bFeebGetCh2RightBufferEmpty>
81104230:	e0bff615 	stw	r2,-40(fp)
			break;
81104234:	00000b06 	br	81104264 <bSdmaDmaM2Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81104238:	00800074 	movhi	r2,1
8110423c:	10880004 	addi	r2,r2,8192
81104240:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81104244:	00800044 	movi	r2,1
81104248:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
8110424c:	11065280 	call	81106528 <bFeebGetCh2LeftBufferEmpty>
81104250:	e0bff615 	stw	r2,-40(fp)
			break;
81104254:	00000306 	br	81104264 <bSdmaDmaM2Transfer+0x160>
		default:
			bChannelFlag = FALSE;
81104258:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
8110425c:	e03ff615 	stw	zero,-40(fp)
			break;
81104260:	0001883a 	nop
		}
		break;
81104264:	00008006 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81104268:	e0bffd03 	ldbu	r2,-12(fp)
8110426c:	10000826 	beq	r2,zero,81104290 <bSdmaDmaM2Transfer+0x18c>
81104270:	10800060 	cmpeqi	r2,r2,1
81104274:	10000d26 	beq	r2,zero,811042ac <bSdmaDmaM2Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81104278:	00900004 	movi	r2,16384
8110427c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81104280:	00800044 	movi	r2,1
81104284:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104288:	e03ff615 	stw	zero,-40(fp)
			break;
8110428c:	00000a06 	br	811042b8 <bSdmaDmaM2Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81104290:	00800074 	movhi	r2,1
81104294:	10900004 	addi	r2,r2,16384
81104298:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
8110429c:	00800044 	movi	r2,1
811042a0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042a4:	e03ff615 	stw	zero,-40(fp)
			break;
811042a8:	00000306 	br	811042b8 <bSdmaDmaM2Transfer+0x1b4>
		default:
			bChannelFlag = FALSE;
811042ac:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
811042b0:	e03ff615 	stw	zero,-40(fp)
			break;
811042b4:	0001883a 	nop
		}
		break;
811042b8:	00006b06 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
811042bc:	e0bffd03 	ldbu	r2,-12(fp)
811042c0:	10000826 	beq	r2,zero,811042e4 <bSdmaDmaM2Transfer+0x1e0>
811042c4:	10800060 	cmpeqi	r2,r2,1
811042c8:	10000d26 	beq	r2,zero,81104300 <bSdmaDmaM2Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
811042cc:	00980004 	movi	r2,24576
811042d0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
811042d4:	00800044 	movi	r2,1
811042d8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042dc:	e03ff615 	stw	zero,-40(fp)
			break;
811042e0:	00000a06 	br	8110430c <bSdmaDmaM2Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
811042e4:	00800074 	movhi	r2,1
811042e8:	10980004 	addi	r2,r2,24576
811042ec:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
811042f0:	00800044 	movi	r2,1
811042f4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042f8:	e03ff615 	stw	zero,-40(fp)
			break;
811042fc:	00000306 	br	8110430c <bSdmaDmaM2Transfer+0x208>
		default:
			bChannelFlag = FALSE;
81104300:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104304:	e03ff615 	stw	zero,-40(fp)
			break;
81104308:	0001883a 	nop
		}
		break;
8110430c:	00005606 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81104310:	e0bffd03 	ldbu	r2,-12(fp)
81104314:	10000826 	beq	r2,zero,81104338 <bSdmaDmaM2Transfer+0x234>
81104318:	10800060 	cmpeqi	r2,r2,1
8110431c:	10000d26 	beq	r2,zero,81104354 <bSdmaDmaM2Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81104320:	00a00014 	movui	r2,32768
81104324:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81104328:	00800044 	movi	r2,1
8110432c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104330:	e03ff615 	stw	zero,-40(fp)
			break;
81104334:	00000a06 	br	81104360 <bSdmaDmaM2Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81104338:	008000b4 	movhi	r2,2
8110433c:	10a00004 	addi	r2,r2,-32768
81104340:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81104344:	00800044 	movi	r2,1
81104348:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110434c:	e03ff615 	stw	zero,-40(fp)
			break;
81104350:	00000306 	br	81104360 <bSdmaDmaM2Transfer+0x25c>
		default:
			bChannelFlag = FALSE;
81104354:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104358:	e03ff615 	stw	zero,-40(fp)
			break;
8110435c:	0001883a 	nop
		}
		break;
81104360:	00004106 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81104364:	e0bffd03 	ldbu	r2,-12(fp)
81104368:	10000826 	beq	r2,zero,8110438c <bSdmaDmaM2Transfer+0x288>
8110436c:	10800060 	cmpeqi	r2,r2,1
81104370:	10000d26 	beq	r2,zero,811043a8 <bSdmaDmaM2Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81104374:	00a80014 	movui	r2,40960
81104378:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
8110437c:	00800044 	movi	r2,1
81104380:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104384:	e03ff615 	stw	zero,-40(fp)
			break;
81104388:	00000a06 	br	811043b4 <bSdmaDmaM2Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
8110438c:	008000b4 	movhi	r2,2
81104390:	10a80004 	addi	r2,r2,-24576
81104394:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81104398:	00800044 	movi	r2,1
8110439c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043a0:	e03ff615 	stw	zero,-40(fp)
			break;
811043a4:	00000306 	br	811043b4 <bSdmaDmaM2Transfer+0x2b0>
		default:
			bChannelFlag = FALSE;
811043a8:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
811043ac:	e03ff615 	stw	zero,-40(fp)
			break;
811043b0:	0001883a 	nop
		}
		break;
811043b4:	00002c06 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
811043b8:	e0bffd03 	ldbu	r2,-12(fp)
811043bc:	10000826 	beq	r2,zero,811043e0 <bSdmaDmaM2Transfer+0x2dc>
811043c0:	10800060 	cmpeqi	r2,r2,1
811043c4:	10000d26 	beq	r2,zero,811043fc <bSdmaDmaM2Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
811043c8:	00b00014 	movui	r2,49152
811043cc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
811043d0:	00800044 	movi	r2,1
811043d4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043d8:	e03ff615 	stw	zero,-40(fp)
			break;
811043dc:	00000a06 	br	81104408 <bSdmaDmaM2Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
811043e0:	008000b4 	movhi	r2,2
811043e4:	10b00004 	addi	r2,r2,-16384
811043e8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
811043ec:	00800044 	movi	r2,1
811043f0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043f4:	e03ff615 	stw	zero,-40(fp)
			break;
811043f8:	00000306 	br	81104408 <bSdmaDmaM2Transfer+0x304>
		default:
			bChannelFlag = FALSE;
811043fc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104400:	e03ff615 	stw	zero,-40(fp)
			break;
81104404:	0001883a 	nop
		}
		break;
81104408:	00001706 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
8110440c:	e0bffd03 	ldbu	r2,-12(fp)
81104410:	10000826 	beq	r2,zero,81104434 <bSdmaDmaM2Transfer+0x330>
81104414:	10800060 	cmpeqi	r2,r2,1
81104418:	10000d26 	beq	r2,zero,81104450 <bSdmaDmaM2Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
8110441c:	00b80014 	movui	r2,57344
81104420:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104424:	00800044 	movi	r2,1
81104428:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110442c:	e03ff615 	stw	zero,-40(fp)
			break;
81104430:	00000a06 	br	8110445c <bSdmaDmaM2Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104434:	008000b4 	movhi	r2,2
81104438:	10b80004 	addi	r2,r2,-8192
8110443c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81104440:	00800044 	movi	r2,1
81104444:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104448:	e03ff615 	stw	zero,-40(fp)
			break;
8110444c:	00000306 	br	8110445c <bSdmaDmaM2Transfer+0x358>
		default:
			bChannelFlag = FALSE;
81104450:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
81104454:	e03ff615 	stw	zero,-40(fp)
			break;
81104458:	0001883a 	nop
		}
		break;
8110445c:	00000206 	br	81104468 <bSdmaDmaM2Transfer+0x364>
	default:
		bChannelFlag = FALSE;
81104460:	e03ff715 	stw	zero,-36(fp)
		break;
81104464:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
81104468:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bChannelFlag = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
8110446c:	00a00034 	movhi	r2,32768
81104470:	1885883a 	add	r2,r3,r2
81104474:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81104478:	e03ff915 	stw	zero,-28(fp)

	if ((bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
8110447c:	e0bff717 	ldw	r2,-36(fp)
81104480:	10003026 	beq	r2,zero,81104544 <bSdmaDmaM2Transfer+0x440>
81104484:	e0bff617 	ldw	r2,-40(fp)
81104488:	10002e26 	beq	r2,zero,81104544 <bSdmaDmaM2Transfer+0x440>
8110448c:	e0bffc0b 	ldhu	r2,-16(fp)
81104490:	10800468 	cmpgeui	r2,r2,17
81104494:	10002b1e 	bne	r2,zero,81104544 <bSdmaDmaM2Transfer+0x440>
		if (pxDmaM2Dev != NULL) {
81104498:	d0a03a17 	ldw	r2,-32536(gp)
8110449c:	10002926 	beq	r2,zero,81104544 <bSdmaDmaM2Transfer+0x440>

			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811044a0:	00000206 	br	811044ac <bSdmaDmaM2Transfer+0x3a8>
				alt_busy_sleep(1); /* delay 1us */
811044a4:	01000044 	movi	r4,1
811044a8:	11375540 	call	81137554 <alt_busy_sleep>
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;

	if ((bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
		if (pxDmaM2Dev != NULL) {

			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811044ac:	d0a03a17 	ldw	r2,-32536(gp)
811044b0:	10800317 	ldw	r2,12(r2)
811044b4:	10800037 	ldwio	r2,0(r2)
811044b8:	1080010c 	andi	r2,r2,4
811044bc:	103ff91e 	bne	r2,zero,811044a4 <__reset+0xfb0e44a4>
				alt_busy_sleep(1); /* delay 1us */
			}
			/* Success = 0 */
			if ( 0 == iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
811044c0:	d2203a17 	ldw	r8,-32536(gp)
811044c4:	e1bff817 	ldw	r6,-32(fp)
811044c8:	e1fff417 	ldw	r7,-48(fp)
811044cc:	e0bffc0b 	ldhu	r2,-16(fp)
811044d0:	10802224 	muli	r2,r2,136
811044d4:	e0fff917 	ldw	r3,-28(fp)
811044d8:	e13ff517 	ldw	r4,-44(fp)
811044dc:	01400044 	movi	r5,1
811044e0:	d9400815 	stw	r5,32(sp)
811044e4:	01400044 	movi	r5,1
811044e8:	d9400715 	stw	r5,28(sp)
811044ec:	01400044 	movi	r5,1
811044f0:	d9400615 	stw	r5,24(sp)
811044f4:	01400044 	movi	r5,1
811044f8:	d9400515 	stw	r5,20(sp)
811044fc:	01400044 	movi	r5,1
81104500:	d9400415 	stw	r5,16(sp)
81104504:	d9000315 	stw	r4,12(sp)
81104508:	d8c00215 	stw	r3,8(sp)
8110450c:	e0fffa17 	ldw	r3,-24(fp)
81104510:	d8c00115 	stw	r3,4(sp)
81104514:	d8800015 	stw	r2,0(sp)
81104518:	800b883a 	mov	r5,r16
8110451c:	4009883a 	mov	r4,r8
81104520:	110bcf80 	call	8110bcf8 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104524:	1000071e 	bne	r2,zero,81104544 <bSdmaDmaM2Transfer+0x440>
					(alt_u32 *) uliDestAddrLow,
					SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
					(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
					1, 1, 1, 1, 1)) {
				/* Success = 0 */
				if ( 0 == iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
81104528:	d0a03a17 	ldw	r2,-32536(gp)
8110452c:	800b883a 	mov	r5,r16
81104530:	1009883a 	mov	r4,r2
81104534:	110bdfc0 	call	8110bdfc <iMsgdmaExtendedDescriptorSyncTransfer>
81104538:	1000021e 	bne	r2,zero,81104544 <bSdmaDmaM2Transfer+0x440>
						&xDmaExtendedDescriptor)) {
					bStatus = TRUE;
8110453c:	00800044 	movi	r2,1
81104540:	e0bff315 	stw	r2,-52(fp)
				}
			}
		}
	}
	return bStatus;
81104544:	e0bff317 	ldw	r2,-52(fp)
}
81104548:	e6ffff04 	addi	sp,fp,-4
8110454c:	dfc00217 	ldw	ra,8(sp)
81104550:	df000117 	ldw	fp,4(sp)
81104554:	dc000017 	ldw	r16,0(sp)
81104558:	dec00304 	addi	sp,sp,12
8110455c:	f800283a 	ret

81104560 <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
81104560:	defff904 	addi	sp,sp,-28
81104564:	de00012e 	bgeu	sp,et,8110456c <bCommSetGlobalIrqEn+0xc>
81104568:	003b68fa 	trap	3
8110456c:	dfc00615 	stw	ra,24(sp)
81104570:	df000515 	stw	fp,20(sp)
81104574:	df000504 	addi	fp,sp,20
81104578:	e13ffe15 	stw	r4,-8(fp)
8110457c:	2805883a 	mov	r2,r5
81104580:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104584:	00800044 	movi	r2,1
81104588:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
8110458c:	e03ffc15 	stw	zero,-16(fp)
	alt_u32 *puliCommAddr = 0;
81104590:	e03ffd15 	stw	zero,-12(fp)

	switch (ucCommCh) {
81104594:	e0bfff03 	ldbu	r2,-4(fp)
81104598:	10c00228 	cmpgeui	r3,r2,8
8110459c:	18002e1e 	bne	r3,zero,81104658 <bCommSetGlobalIrqEn+0xf8>
811045a0:	100690ba 	slli	r3,r2,2
811045a4:	00a04434 	movhi	r2,33040
811045a8:	10916e04 	addi	r2,r2,17848
811045ac:	1885883a 	add	r2,r3,r2
811045b0:	10800017 	ldw	r2,0(r2)
811045b4:	1000683a 	jmp	r2
811045b8:	811045d8 	cmpnei	r4,r16,16663
811045bc:	811045e8 	cmpgeui	r4,r16,16663
811045c0:	811045f8 	rdprs	r4,r16,16663
811045c4:	81104608 	cmpgei	r4,r16,16664
811045c8:	81104618 	cmpnei	r4,r16,16664
811045cc:	81104628 	cmpgeui	r4,r16,16664
811045d0:	81104638 	rdprs	r4,r16,16664
811045d4:	81104648 	cmpgei	r4,r16,16665
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
811045d8:	00a04834 	movhi	r2,33056
811045dc:	108b0004 	addi	r2,r2,11264
811045e0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045e4:	00001e06 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811045e8:	00a04834 	movhi	r2,33056
811045ec:	108a0004 	addi	r2,r2,10240
811045f0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045f4:	00001a06 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811045f8:	00a04834 	movhi	r2,33056
811045fc:	108b0004 	addi	r2,r2,11264
81104600:	e0bffd15 	stw	r2,-12(fp)
		break;
81104604:	00001606 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104608:	00a04834 	movhi	r2,33056
8110460c:	108a0004 	addi	r2,r2,10240
81104610:	e0bffd15 	stw	r2,-12(fp)
		break;
81104614:	00001206 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104618:	00a04834 	movhi	r2,33056
8110461c:	108b0004 	addi	r2,r2,11264
81104620:	e0bffd15 	stw	r2,-12(fp)
		break;
81104624:	00000e06 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104628:	00a04834 	movhi	r2,33056
8110462c:	108a0004 	addi	r2,r2,10240
81104630:	e0bffd15 	stw	r2,-12(fp)
		break;
81104634:	00000a06 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104638:	00a04834 	movhi	r2,33056
8110463c:	108b0004 	addi	r2,r2,11264
81104640:	e0bffd15 	stw	r2,-12(fp)
		break;
81104644:	00000606 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104648:	00a04834 	movhi	r2,33056
8110464c:	108a0004 	addi	r2,r2,10240
81104650:	e0bffd15 	stw	r2,-12(fp)
		break;
81104654:	00000206 	br	81104660 <bCommSetGlobalIrqEn+0x100>
	default:
		bStatus = FALSE;
81104658:	e03ffb15 	stw	zero,-20(fp)
		break;
8110465c:	0001883a 	nop
	}

	if (bStatus) {
81104660:	e0bffb17 	ldw	r2,-20(fp)
81104664:	10001326 	beq	r2,zero,811046b4 <bCommSetGlobalIrqEn+0x154>
		uliReg = uliCommReadReg(puliCommAddr,
81104668:	01400444 	movi	r5,17
8110466c:	e13ffd17 	ldw	r4,-12(fp)
81104670:	11047f00 	call	811047f0 <uliCommReadReg>
81104674:	e0bffc15 	stw	r2,-16(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
81104678:	e0bffe17 	ldw	r2,-8(fp)
8110467c:	10000426 	beq	r2,zero,81104690 <bCommSetGlobalIrqEn+0x130>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
81104680:	e0bffc17 	ldw	r2,-16(fp)
81104684:	10800074 	orhi	r2,r2,1
81104688:	e0bffc15 	stw	r2,-16(fp)
8110468c:	00000506 	br	811046a4 <bCommSetGlobalIrqEn+0x144>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
81104690:	e0fffc17 	ldw	r3,-16(fp)
81104694:	00bffff4 	movhi	r2,65535
81104698:	10bfffc4 	addi	r2,r2,-1
8110469c:	1884703a 	and	r2,r3,r2
811046a0:	e0bffc15 	stw	r2,-16(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
811046a4:	e1bffc17 	ldw	r6,-16(fp)
811046a8:	01400444 	movi	r5,17
811046ac:	e13ffd17 	ldw	r4,-12(fp)
811046b0:	110479c0 	call	8110479c <vCommWriteReg>
	}

	return bStatus;
811046b4:	e0bffb17 	ldw	r2,-20(fp)
}
811046b8:	e037883a 	mov	sp,fp
811046bc:	dfc00117 	ldw	ra,4(sp)
811046c0:	df000017 	ldw	fp,0(sp)
811046c4:	dec00204 	addi	sp,sp,8
811046c8:	f800283a 	ret

811046cc <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
811046cc:	defffb04 	addi	sp,sp,-20
811046d0:	de00012e 	bgeu	sp,et,811046d8 <bCommInitCh+0xc>
811046d4:	003b68fa 	trap	3
811046d8:	dfc00415 	stw	ra,16(sp)
811046dc:	df000315 	stw	fp,12(sp)
811046e0:	df000304 	addi	fp,sp,12
811046e4:	e13ffe15 	stw	r4,-8(fp)
811046e8:	2805883a 	mov	r2,r5
811046ec:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811046f0:	00800044 	movi	r2,1
811046f4:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
811046f8:	e0bffe17 	ldw	r2,-8(fp)
811046fc:	10805704 	addi	r2,r2,348
81104700:	e0ffff03 	ldbu	r3,-4(fp)
81104704:	180b883a 	mov	r5,r3
81104708:	1009883a 	mov	r4,r2
8110470c:	110a5b80 	call	8110a5b8 <bSpwcInitCh>
81104710:	1000011e 	bne	r2,zero,81104718 <bCommInitCh+0x4c>
		bStatus = FALSE;
81104714:	e03ffd15 	stw	zero,-12(fp)
	}
	//vFeebInitIrq(ucCommCh);

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
81104718:	e0bffe17 	ldw	r2,-8(fp)
8110471c:	10800904 	addi	r2,r2,36
81104720:	e0ffff03 	ldbu	r3,-4(fp)
81104724:	180b883a 	mov	r5,r3
81104728:	1009883a 	mov	r4,r2
8110472c:	11069a00 	call	811069a0 <bFeebInitCh>
81104730:	1000011e 	bne	r2,zero,81104738 <bCommInitCh+0x6c>
		bStatus = FALSE;
81104734:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81104738:	e0bffe17 	ldw	r2,-8(fp)
8110473c:	10801104 	addi	r2,r2,68
81104740:	e0ffff03 	ldbu	r3,-4(fp)
81104744:	180b883a 	mov	r5,r3
81104748:	1009883a 	mov	r4,r2
8110474c:	1109c140 	call	81109c14 <bRmapInitCh>
81104750:	1000011e 	bne	r2,zero,81104758 <bCommInitCh+0x8c>
		bStatus = FALSE;
81104754:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
81104758:	e0bfff03 	ldbu	r2,-4(fp)
8110475c:	1009883a 	mov	r4,r2
81104760:	11076500 	call	81107650 <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
81104764:	e0bffe17 	ldw	r2,-8(fp)
81104768:	10800104 	addi	r2,r2,4
8110476c:	e0ffff03 	ldbu	r3,-4(fp)
81104770:	180b883a 	mov	r5,r3
81104774:	1009883a 	mov	r4,r2
81104778:	1104e680 	call	81104e68 <bDpktInitCh>
8110477c:	1000011e 	bne	r2,zero,81104784 <bCommInitCh+0xb8>
		bStatus = FALSE;
81104780:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
81104784:	e0bffd17 	ldw	r2,-12(fp)
}
81104788:	e037883a 	mov	sp,fp
8110478c:	dfc00117 	ldw	ra,4(sp)
81104790:	df000017 	ldw	fp,0(sp)
81104794:	dec00204 	addi	sp,sp,8
81104798:	f800283a 	ret

8110479c <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110479c:	defffc04 	addi	sp,sp,-16
811047a0:	de00012e 	bgeu	sp,et,811047a8 <vCommWriteReg+0xc>
811047a4:	003b68fa 	trap	3
811047a8:	df000315 	stw	fp,12(sp)
811047ac:	df000304 	addi	fp,sp,12
811047b0:	e13ffd15 	stw	r4,-12(fp)
811047b4:	e17ffe15 	stw	r5,-8(fp)
811047b8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811047bc:	e0bffe17 	ldw	r2,-8(fp)
811047c0:	1085883a 	add	r2,r2,r2
811047c4:	1085883a 	add	r2,r2,r2
811047c8:	1007883a 	mov	r3,r2
811047cc:	e0bffd17 	ldw	r2,-12(fp)
811047d0:	10c5883a 	add	r2,r2,r3
811047d4:	e0ffff17 	ldw	r3,-4(fp)
811047d8:	10c00015 	stw	r3,0(r2)
}
811047dc:	0001883a 	nop
811047e0:	e037883a 	mov	sp,fp
811047e4:	df000017 	ldw	fp,0(sp)
811047e8:	dec00104 	addi	sp,sp,4
811047ec:	f800283a 	ret

811047f0 <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811047f0:	defffc04 	addi	sp,sp,-16
811047f4:	de00012e 	bgeu	sp,et,811047fc <uliCommReadReg+0xc>
811047f8:	003b68fa 	trap	3
811047fc:	df000315 	stw	fp,12(sp)
81104800:	df000304 	addi	fp,sp,12
81104804:	e13ffe15 	stw	r4,-8(fp)
81104808:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110480c:	e0bfff17 	ldw	r2,-4(fp)
81104810:	1085883a 	add	r2,r2,r2
81104814:	1085883a 	add	r2,r2,r2
81104818:	1007883a 	mov	r3,r2
8110481c:	e0bffe17 	ldw	r2,-8(fp)
81104820:	10c5883a 	add	r2,r2,r3
81104824:	10800017 	ldw	r2,0(r2)
81104828:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110482c:	e0bffd17 	ldw	r2,-12(fp)
}
81104830:	e037883a 	mov	sp,fp
81104834:	df000017 	ldw	fp,0(sp)
81104838:	dec00104 	addi	sp,sp,4
8110483c:	f800283a 	ret

81104840 <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
81104840:	defffb04 	addi	sp,sp,-20
81104844:	de00012e 	bgeu	sp,et,8110484c <bDpktSetPacketConfig+0xc>
81104848:	003b68fa 	trap	3
8110484c:	dfc00415 	stw	ra,16(sp)
81104850:	df000315 	stw	fp,12(sp)
81104854:	df000304 	addi	fp,sp,12
81104858:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110485c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104860:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104864:	e0bfff17 	ldw	r2,-4(fp)
81104868:	10007a26 	beq	r2,zero,81104a54 <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110486c:	e0bfff17 	ldw	r2,-4(fp)
81104870:	10800017 	ldw	r2,0(r2)
81104874:	01400204 	movi	r5,8
81104878:	1009883a 	mov	r4,r2
8110487c:	11050300 	call	81105030 <uliDpktReadReg>
81104880:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
81104884:	e0bffe17 	ldw	r2,-8(fp)
81104888:	10bfffec 	andhi	r2,r2,65535
8110488c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
81104890:	e0bfff17 	ldw	r2,-4(fp)
81104894:	1080010b 	ldhu	r2,4(r2)
81104898:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
8110489c:	e0fffe17 	ldw	r3,-8(fp)
811048a0:	1884b03a 	or	r2,r3,r2
811048a4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
811048a8:	e0bffe17 	ldw	r2,-8(fp)
811048ac:	10bfffcc 	andi	r2,r2,65535
811048b0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
811048b4:	e0bfff17 	ldw	r2,-4(fp)
811048b8:	1080018b 	ldhu	r2,6(r2)
811048bc:	10bfffcc 	andi	r2,r2,65535
811048c0:	1004943a 	slli	r2,r2,16
811048c4:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
811048c8:	e0bffe17 	ldw	r2,-8(fp)
811048cc:	10c4b03a 	or	r2,r2,r3
811048d0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
811048d4:	e0bfff17 	ldw	r2,-4(fp)
811048d8:	10800017 	ldw	r2,0(r2)
811048dc:	e1bffe17 	ldw	r6,-8(fp)
811048e0:	01400204 	movi	r5,8
811048e4:	1009883a 	mov	r4,r2
811048e8:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811048ec:	e0bfff17 	ldw	r2,-4(fp)
811048f0:	10800017 	ldw	r2,0(r2)
811048f4:	01400244 	movi	r5,9
811048f8:	1009883a 	mov	r4,r2
811048fc:	11050300 	call	81105030 <uliDpktReadReg>
81104900:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
81104904:	e0bffe17 	ldw	r2,-8(fp)
81104908:	10bfffec 	andhi	r2,r2,65535
8110490c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
81104910:	e0bfff17 	ldw	r2,-4(fp)
81104914:	1080020b 	ldhu	r2,8(r2)
81104918:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
8110491c:	e0fffe17 	ldw	r3,-8(fp)
81104920:	1884b03a 	or	r2,r3,r2
81104924:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104928:	e0bffe17 	ldw	r2,-8(fp)
8110492c:	10bfffcc 	andi	r2,r2,65535
81104930:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81104934:	e0bfff17 	ldw	r2,-4(fp)
81104938:	1080028b 	ldhu	r2,10(r2)
										<< 16));
8110493c:	10bfffcc 	andi	r2,r2,65535
81104940:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
81104944:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
81104948:	e0bffe17 	ldw	r2,-8(fp)
8110494c:	10c4b03a 	or	r2,r2,r3
81104950:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
81104954:	e0bfff17 	ldw	r2,-4(fp)
81104958:	10800017 	ldw	r2,0(r2)
8110495c:	e1bffe17 	ldw	r6,-8(fp)
81104960:	01400244 	movi	r5,9
81104964:	1009883a 	mov	r4,r2
81104968:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110496c:	e0bfff17 	ldw	r2,-4(fp)
81104970:	10800017 	ldw	r2,0(r2)
81104974:	01400284 	movi	r5,10
81104978:	1009883a 	mov	r4,r2
8110497c:	11050300 	call	81105030 <uliDpktReadReg>
81104980:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
81104984:	e0bffe17 	ldw	r2,-8(fp)
81104988:	10bfffec 	andhi	r2,r2,65535
8110498c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
81104990:	e0bfff17 	ldw	r2,-4(fp)
81104994:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
81104998:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
8110499c:	e0fffe17 	ldw	r3,-8(fp)
811049a0:	1884b03a 	or	r2,r3,r2
811049a4:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
811049a8:	e0bfff17 	ldw	r2,-4(fp)
811049ac:	10800017 	ldw	r2,0(r2)
811049b0:	e1bffe17 	ldw	r6,-8(fp)
811049b4:	01400284 	movi	r5,10
811049b8:	1009883a 	mov	r4,r2
811049bc:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811049c0:	e0bfff17 	ldw	r2,-4(fp)
811049c4:	10800017 	ldw	r2,0(r2)
811049c8:	014002c4 	movi	r5,11
811049cc:	1009883a 	mov	r4,r2
811049d0:	11050300 	call	81105030 <uliDpktReadReg>
811049d4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
811049d8:	e0fffe17 	ldw	r3,-8(fp)
811049dc:	00bfc004 	movi	r2,-256
811049e0:	1884703a 	and	r2,r3,r2
811049e4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
811049e8:	e0bfff17 	ldw	r2,-4(fp)
811049ec:	10800383 	ldbu	r2,14(r2)
811049f0:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
811049f4:	e0fffe17 	ldw	r3,-8(fp)
811049f8:	1884b03a 	or	r2,r3,r2
811049fc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
81104a00:	e0fffe17 	ldw	r3,-8(fp)
81104a04:	00bffff4 	movhi	r2,65535
81104a08:	10803fc4 	addi	r2,r2,255
81104a0c:	1884703a 	and	r2,r3,r2
81104a10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81104a14:	e0bfff17 	ldw	r2,-4(fp)
81104a18:	108003c3 	ldbu	r2,15(r2)
81104a1c:	10803fcc 	andi	r2,r2,255
81104a20:	1004923a 	slli	r2,r2,8
81104a24:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104a28:	e0fffe17 	ldw	r3,-8(fp)
81104a2c:	1884b03a 	or	r2,r3,r2
81104a30:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104a34:	e0bfff17 	ldw	r2,-4(fp)
81104a38:	10800017 	ldw	r2,0(r2)
81104a3c:	e1bffe17 	ldw	r6,-8(fp)
81104a40:	014002c4 	movi	r5,11
81104a44:	1009883a 	mov	r4,r2
81104a48:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104a4c:	00800044 	movi	r2,1
81104a50:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104a54:	e0bffd17 	ldw	r2,-12(fp)
}
81104a58:	e037883a 	mov	sp,fp
81104a5c:	dfc00117 	ldw	ra,4(sp)
81104a60:	df000017 	ldw	fp,0(sp)
81104a64:	dec00204 	addi	sp,sp,8
81104a68:	f800283a 	ret

81104a6c <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
81104a6c:	defffb04 	addi	sp,sp,-20
81104a70:	de00012e 	bgeu	sp,et,81104a78 <bDpktGetPacketConfig+0xc>
81104a74:	003b68fa 	trap	3
81104a78:	dfc00415 	stw	ra,16(sp)
81104a7c:	df000315 	stw	fp,12(sp)
81104a80:	df000304 	addi	fp,sp,12
81104a84:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104a88:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104a8c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104a90:	e0bfff17 	ldw	r2,-4(fp)
81104a94:	10003a26 	beq	r2,zero,81104b80 <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a98:	e0bfff17 	ldw	r2,-4(fp)
81104a9c:	10800017 	ldw	r2,0(r2)
81104aa0:	01400204 	movi	r5,8
81104aa4:	1009883a 	mov	r4,r2
81104aa8:	11050300 	call	81105030 <uliDpktReadReg>
81104aac:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104ab0:	e0bffe17 	ldw	r2,-8(fp)
81104ab4:	1007883a 	mov	r3,r2
81104ab8:	e0bfff17 	ldw	r2,-4(fp)
81104abc:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104ac0:	e0bffe17 	ldw	r2,-8(fp)
81104ac4:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104ac8:	1007883a 	mov	r3,r2
81104acc:	e0bfff17 	ldw	r2,-4(fp)
81104ad0:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104ad4:	e0bfff17 	ldw	r2,-4(fp)
81104ad8:	10800017 	ldw	r2,0(r2)
81104adc:	01400244 	movi	r5,9
81104ae0:	1009883a 	mov	r4,r2
81104ae4:	11050300 	call	81105030 <uliDpktReadReg>
81104ae8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104aec:	e0bffe17 	ldw	r2,-8(fp)
81104af0:	1007883a 	mov	r3,r2
81104af4:	e0bfff17 	ldw	r2,-4(fp)
81104af8:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104afc:	e0bffe17 	ldw	r2,-8(fp)
81104b00:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104b04:	1007883a 	mov	r3,r2
81104b08:	e0bfff17 	ldw	r2,-4(fp)
81104b0c:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b10:	e0bfff17 	ldw	r2,-4(fp)
81104b14:	10800017 	ldw	r2,0(r2)
81104b18:	01400284 	movi	r5,10
81104b1c:	1009883a 	mov	r4,r2
81104b20:	11050300 	call	81105030 <uliDpktReadReg>
81104b24:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104b28:	e0bffe17 	ldw	r2,-8(fp)
81104b2c:	1007883a 	mov	r3,r2
81104b30:	e0bfff17 	ldw	r2,-4(fp)
81104b34:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b38:	e0bfff17 	ldw	r2,-4(fp)
81104b3c:	10800017 	ldw	r2,0(r2)
81104b40:	014002c4 	movi	r5,11
81104b44:	1009883a 	mov	r4,r2
81104b48:	11050300 	call	81105030 <uliDpktReadReg>
81104b4c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81104b50:	e0bffe17 	ldw	r2,-8(fp)
81104b54:	1007883a 	mov	r3,r2
81104b58:	e0bfff17 	ldw	r2,-4(fp)
81104b5c:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81104b60:	e0bffe17 	ldw	r2,-8(fp)
81104b64:	10bfc00c 	andi	r2,r2,65280
81104b68:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81104b6c:	1007883a 	mov	r3,r2
81104b70:	e0bfff17 	ldw	r2,-4(fp)
81104b74:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
81104b78:	00800044 	movi	r2,1
81104b7c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104b80:	e0bffd17 	ldw	r2,-12(fp)
}
81104b84:	e037883a 	mov	sp,fp
81104b88:	dfc00117 	ldw	ra,4(sp)
81104b8c:	df000017 	ldw	fp,0(sp)
81104b90:	dec00204 	addi	sp,sp,8
81104b94:	f800283a 	ret

81104b98 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104b98:	defffb04 	addi	sp,sp,-20
81104b9c:	de00012e 	bgeu	sp,et,81104ba4 <bDpktGetPacketHeader+0xc>
81104ba0:	003b68fa 	trap	3
81104ba4:	dfc00415 	stw	ra,16(sp)
81104ba8:	df000315 	stw	fp,12(sp)
81104bac:	df000304 	addi	fp,sp,12
81104bb0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104bb4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104bb8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104bbc:	e0bfff17 	ldw	r2,-4(fp)
81104bc0:	10002026 	beq	r2,zero,81104c44 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104bc4:	e0bfff17 	ldw	r2,-4(fp)
81104bc8:	10800017 	ldw	r2,0(r2)
81104bcc:	01400304 	movi	r5,12
81104bd0:	1009883a 	mov	r4,r2
81104bd4:	11050300 	call	81105030 <uliDpktReadReg>
81104bd8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104bdc:	e0bffe17 	ldw	r2,-8(fp)
81104be0:	1007883a 	mov	r3,r2
81104be4:	e0bfff17 	ldw	r2,-4(fp)
81104be8:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104bec:	e0bffe17 	ldw	r2,-8(fp)
81104bf0:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104bf4:	1007883a 	mov	r3,r2
81104bf8:	e0bfff17 	ldw	r2,-4(fp)
81104bfc:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c00:	e0bfff17 	ldw	r2,-4(fp)
81104c04:	10800017 	ldw	r2,0(r2)
81104c08:	01400344 	movi	r5,13
81104c0c:	1009883a 	mov	r4,r2
81104c10:	11050300 	call	81105030 <uliDpktReadReg>
81104c14:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104c18:	e0bffe17 	ldw	r2,-8(fp)
81104c1c:	1007883a 	mov	r3,r2
81104c20:	e0bfff17 	ldw	r2,-4(fp)
81104c24:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104c28:	e0bffe17 	ldw	r2,-8(fp)
81104c2c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81104c30:	1007883a 	mov	r3,r2
81104c34:	e0bfff17 	ldw	r2,-4(fp)
81104c38:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104c3c:	00800044 	movi	r2,1
81104c40:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104c44:	e0bffd17 	ldw	r2,-12(fp)
}
81104c48:	e037883a 	mov	sp,fp
81104c4c:	dfc00117 	ldw	ra,4(sp)
81104c50:	df000017 	ldw	fp,0(sp)
81104c54:	dec00204 	addi	sp,sp,8
81104c58:	f800283a 	ret

81104c5c <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81104c5c:	defffb04 	addi	sp,sp,-20
81104c60:	de00012e 	bgeu	sp,et,81104c68 <bDpktSetPixelDelay+0xc>
81104c64:	003b68fa 	trap	3
81104c68:	dfc00415 	stw	ra,16(sp)
81104c6c:	df000315 	stw	fp,12(sp)
81104c70:	df000304 	addi	fp,sp,12
81104c74:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104c78:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104c7c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104c80:	e0bfff17 	ldw	r2,-4(fp)
81104c84:	10004126 	beq	r2,zero,81104d8c <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c88:	e0bfff17 	ldw	r2,-4(fp)
81104c8c:	10800017 	ldw	r2,0(r2)
81104c90:	01400384 	movi	r5,14
81104c94:	1009883a 	mov	r4,r2
81104c98:	11050300 	call	81105030 <uliDpktReadReg>
81104c9c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104ca0:	e0bffe17 	ldw	r2,-8(fp)
81104ca4:	10bfffec 	andhi	r2,r2,65535
81104ca8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104cac:	e0bfff17 	ldw	r2,-4(fp)
81104cb0:	1080060b 	ldhu	r2,24(r2)
81104cb4:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104cb8:	e0fffe17 	ldw	r3,-8(fp)
81104cbc:	1884b03a 	or	r2,r3,r2
81104cc0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104cc4:	e0bfff17 	ldw	r2,-4(fp)
81104cc8:	10800017 	ldw	r2,0(r2)
81104ccc:	e1bffe17 	ldw	r6,-8(fp)
81104cd0:	01400384 	movi	r5,14
81104cd4:	1009883a 	mov	r4,r2
81104cd8:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104cdc:	e0bfff17 	ldw	r2,-4(fp)
81104ce0:	10800017 	ldw	r2,0(r2)
81104ce4:	014003c4 	movi	r5,15
81104ce8:	1009883a 	mov	r4,r2
81104cec:	11050300 	call	81105030 <uliDpktReadReg>
81104cf0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104cf4:	e0bffe17 	ldw	r2,-8(fp)
81104cf8:	10bfffec 	andhi	r2,r2,65535
81104cfc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104d00:	e0bfff17 	ldw	r2,-4(fp)
81104d04:	1080068b 	ldhu	r2,26(r2)
81104d08:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104d0c:	e0fffe17 	ldw	r3,-8(fp)
81104d10:	1884b03a 	or	r2,r3,r2
81104d14:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104d18:	e0bfff17 	ldw	r2,-4(fp)
81104d1c:	10800017 	ldw	r2,0(r2)
81104d20:	e1bffe17 	ldw	r6,-8(fp)
81104d24:	014003c4 	movi	r5,15
81104d28:	1009883a 	mov	r4,r2
81104d2c:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d30:	e0bfff17 	ldw	r2,-4(fp)
81104d34:	10800017 	ldw	r2,0(r2)
81104d38:	01400404 	movi	r5,16
81104d3c:	1009883a 	mov	r4,r2
81104d40:	11050300 	call	81105030 <uliDpktReadReg>
81104d44:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104d48:	e0bffe17 	ldw	r2,-8(fp)
81104d4c:	10bfffec 	andhi	r2,r2,65535
81104d50:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104d54:	e0bfff17 	ldw	r2,-4(fp)
81104d58:	1080070b 	ldhu	r2,28(r2)
81104d5c:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104d60:	e0fffe17 	ldw	r3,-8(fp)
81104d64:	1884b03a 	or	r2,r3,r2
81104d68:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104d6c:	e0bfff17 	ldw	r2,-4(fp)
81104d70:	10800017 	ldw	r2,0(r2)
81104d74:	e1bffe17 	ldw	r6,-8(fp)
81104d78:	01400404 	movi	r5,16
81104d7c:	1009883a 	mov	r4,r2
81104d80:	1104fdc0 	call	81104fdc <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104d84:	00800044 	movi	r2,1
81104d88:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104d8c:	e0bffd17 	ldw	r2,-12(fp)
}
81104d90:	e037883a 	mov	sp,fp
81104d94:	dfc00117 	ldw	ra,4(sp)
81104d98:	df000017 	ldw	fp,0(sp)
81104d9c:	dec00204 	addi	sp,sp,8
81104da0:	f800283a 	ret

81104da4 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104da4:	defffb04 	addi	sp,sp,-20
81104da8:	de00012e 	bgeu	sp,et,81104db0 <bDpktGetPixelDelay+0xc>
81104dac:	003b68fa 	trap	3
81104db0:	dfc00415 	stw	ra,16(sp)
81104db4:	df000315 	stw	fp,12(sp)
81104db8:	df000304 	addi	fp,sp,12
81104dbc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104dc0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104dc4:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104dc8:	e0bfff17 	ldw	r2,-4(fp)
81104dcc:	10002026 	beq	r2,zero,81104e50 <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104dd0:	e0bfff17 	ldw	r2,-4(fp)
81104dd4:	10800017 	ldw	r2,0(r2)
81104dd8:	01400384 	movi	r5,14
81104ddc:	1009883a 	mov	r4,r2
81104de0:	11050300 	call	81105030 <uliDpktReadReg>
81104de4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104de8:	e0bffe17 	ldw	r2,-8(fp)
81104dec:	1007883a 	mov	r3,r2
81104df0:	e0bfff17 	ldw	r2,-4(fp)
81104df4:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104df8:	e0bfff17 	ldw	r2,-4(fp)
81104dfc:	10800017 	ldw	r2,0(r2)
81104e00:	014003c4 	movi	r5,15
81104e04:	1009883a 	mov	r4,r2
81104e08:	11050300 	call	81105030 <uliDpktReadReg>
81104e0c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104e10:	e0bffe17 	ldw	r2,-8(fp)
81104e14:	1007883a 	mov	r3,r2
81104e18:	e0bfff17 	ldw	r2,-4(fp)
81104e1c:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104e20:	e0bfff17 	ldw	r2,-4(fp)
81104e24:	10800017 	ldw	r2,0(r2)
81104e28:	01400404 	movi	r5,16
81104e2c:	1009883a 	mov	r4,r2
81104e30:	11050300 	call	81105030 <uliDpktReadReg>
81104e34:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104e38:	e0bffe17 	ldw	r2,-8(fp)
81104e3c:	1007883a 	mov	r3,r2
81104e40:	e0bfff17 	ldw	r2,-4(fp)
81104e44:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104e48:	00800044 	movi	r2,1
81104e4c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104e50:	e0bffd17 	ldw	r2,-12(fp)
}
81104e54:	e037883a 	mov	sp,fp
81104e58:	dfc00117 	ldw	ra,4(sp)
81104e5c:	df000017 	ldw	fp,0(sp)
81104e60:	dec00204 	addi	sp,sp,8
81104e64:	f800283a 	ret

81104e68 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104e68:	defffb04 	addi	sp,sp,-20
81104e6c:	de00012e 	bgeu	sp,et,81104e74 <bDpktInitCh+0xc>
81104e70:	003b68fa 	trap	3
81104e74:	dfc00415 	stw	ra,16(sp)
81104e78:	df000315 	stw	fp,12(sp)
81104e7c:	df000304 	addi	fp,sp,12
81104e80:	e13ffe15 	stw	r4,-8(fp)
81104e84:	2805883a 	mov	r2,r5
81104e88:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104e8c:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81104e90:	e0bffe17 	ldw	r2,-8(fp)
81104e94:	10004b26 	beq	r2,zero,81104fc4 <bDpktInitCh+0x15c>
		bStatus = TRUE;
81104e98:	00800044 	movi	r2,1
81104e9c:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104ea0:	e0bfff03 	ldbu	r2,-4(fp)
81104ea4:	10c00228 	cmpgeui	r3,r2,8
81104ea8:	1800361e 	bne	r3,zero,81104f84 <bDpktInitCh+0x11c>
81104eac:	100690ba 	slli	r3,r2,2
81104eb0:	00a04434 	movhi	r2,33040
81104eb4:	1093b104 	addi	r2,r2,20164
81104eb8:	1885883a 	add	r2,r3,r2
81104ebc:	10800017 	ldw	r2,0(r2)
81104ec0:	1000683a 	jmp	r2
81104ec4:	81104ee4 	muli	r4,r16,16699
81104ec8:	81104ef8 	rdprs	r4,r16,16699
81104ecc:	81104f0c 	andi	r4,r16,16700
81104ed0:	81104f20 	cmpeqi	r4,r16,16700
81104ed4:	81104f34 	orhi	r4,r16,16700
81104ed8:	81104f48 	cmpgei	r4,r16,16701
81104edc:	81104f5c 	xori	r4,r16,16701
81104ee0:	81104f70 	cmpltui	r4,r16,16701
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104ee4:	e0fffe17 	ldw	r3,-8(fp)
81104ee8:	00a04834 	movhi	r2,33056
81104eec:	108b0004 	addi	r2,r2,11264
81104ef0:	18800015 	stw	r2,0(r3)
			break;
81104ef4:	00002506 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104ef8:	e0fffe17 	ldw	r3,-8(fp)
81104efc:	00a04834 	movhi	r2,33056
81104f00:	108a0004 	addi	r2,r2,10240
81104f04:	18800015 	stw	r2,0(r3)
			break;
81104f08:	00002006 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104f0c:	e0fffe17 	ldw	r3,-8(fp)
81104f10:	00a04834 	movhi	r2,33056
81104f14:	108b0004 	addi	r2,r2,11264
81104f18:	18800015 	stw	r2,0(r3)
			break;
81104f1c:	00001b06 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104f20:	e0fffe17 	ldw	r3,-8(fp)
81104f24:	00a04834 	movhi	r2,33056
81104f28:	108a0004 	addi	r2,r2,10240
81104f2c:	18800015 	stw	r2,0(r3)
			break;
81104f30:	00001606 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104f34:	e0fffe17 	ldw	r3,-8(fp)
81104f38:	00a04834 	movhi	r2,33056
81104f3c:	108b0004 	addi	r2,r2,11264
81104f40:	18800015 	stw	r2,0(r3)
			break;
81104f44:	00001106 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104f48:	e0fffe17 	ldw	r3,-8(fp)
81104f4c:	00a04834 	movhi	r2,33056
81104f50:	108a0004 	addi	r2,r2,10240
81104f54:	18800015 	stw	r2,0(r3)
			break;
81104f58:	00000c06 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104f5c:	e0fffe17 	ldw	r3,-8(fp)
81104f60:	00a04834 	movhi	r2,33056
81104f64:	108b0004 	addi	r2,r2,11264
81104f68:	18800015 	stw	r2,0(r3)
			break;
81104f6c:	00000706 	br	81104f8c <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104f70:	e0fffe17 	ldw	r3,-8(fp)
81104f74:	00a04834 	movhi	r2,33056
81104f78:	108a0004 	addi	r2,r2,10240
81104f7c:	18800015 	stw	r2,0(r3)
			break;
81104f80:	00000206 	br	81104f8c <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81104f84:	e03ffd15 	stw	zero,-12(fp)
			break;
81104f88:	0001883a 	nop
		}

		if (bStatus) {
81104f8c:	e0bffd17 	ldw	r2,-12(fp)
81104f90:	10000c26 	beq	r2,zero,81104fc4 <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81104f94:	e13ffe17 	ldw	r4,-8(fp)
81104f98:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
81104f9c:	1000011e 	bne	r2,zero,81104fa4 <bDpktInitCh+0x13c>
				bStatus = FALSE;
81104fa0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81104fa4:	e13ffe17 	ldw	r4,-8(fp)
81104fa8:	1104b980 	call	81104b98 <bDpktGetPacketHeader>
81104fac:	1000011e 	bne	r2,zero,81104fb4 <bDpktInitCh+0x14c>
				bStatus = FALSE;
81104fb0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81104fb4:	e13ffe17 	ldw	r4,-8(fp)
81104fb8:	1104da40 	call	81104da4 <bDpktGetPixelDelay>
81104fbc:	1000011e 	bne	r2,zero,81104fc4 <bDpktInitCh+0x15c>
				bStatus = FALSE;
81104fc0:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104fc4:	e0bffd17 	ldw	r2,-12(fp)
}
81104fc8:	e037883a 	mov	sp,fp
81104fcc:	dfc00117 	ldw	ra,4(sp)
81104fd0:	df000017 	ldw	fp,0(sp)
81104fd4:	dec00204 	addi	sp,sp,8
81104fd8:	f800283a 	ret

81104fdc <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104fdc:	defffc04 	addi	sp,sp,-16
81104fe0:	de00012e 	bgeu	sp,et,81104fe8 <vDpktWriteReg+0xc>
81104fe4:	003b68fa 	trap	3
81104fe8:	df000315 	stw	fp,12(sp)
81104fec:	df000304 	addi	fp,sp,12
81104ff0:	e13ffd15 	stw	r4,-12(fp)
81104ff4:	e17ffe15 	stw	r5,-8(fp)
81104ff8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104ffc:	e0bffe17 	ldw	r2,-8(fp)
81105000:	1085883a 	add	r2,r2,r2
81105004:	1085883a 	add	r2,r2,r2
81105008:	1007883a 	mov	r3,r2
8110500c:	e0bffd17 	ldw	r2,-12(fp)
81105010:	10c5883a 	add	r2,r2,r3
81105014:	e0ffff17 	ldw	r3,-4(fp)
81105018:	10c00015 	stw	r3,0(r2)
}
8110501c:	0001883a 	nop
81105020:	e037883a 	mov	sp,fp
81105024:	df000017 	ldw	fp,0(sp)
81105028:	dec00104 	addi	sp,sp,4
8110502c:	f800283a 	ret

81105030 <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81105030:	defffc04 	addi	sp,sp,-16
81105034:	de00012e 	bgeu	sp,et,8110503c <uliDpktReadReg+0xc>
81105038:	003b68fa 	trap	3
8110503c:	df000315 	stw	fp,12(sp)
81105040:	df000304 	addi	fp,sp,12
81105044:	e13ffe15 	stw	r4,-8(fp)
81105048:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110504c:	e0bfff17 	ldw	r2,-4(fp)
81105050:	1085883a 	add	r2,r2,r2
81105054:	1085883a 	add	r2,r2,r2
81105058:	1007883a 	mov	r3,r2
8110505c:	e0bffe17 	ldw	r2,-8(fp)
81105060:	10c5883a 	add	r2,r2,r3
81105064:	10800017 	ldw	r2,0(r2)
81105068:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110506c:	e0bffd17 	ldw	r2,-12(fp)
}
81105070:	e037883a 	mov	sp,fp
81105074:	df000017 	ldw	fp,0(sp)
81105078:	dec00104 	addi	sp,sp,4
8110507c:	f800283a 	ret

81105080 <usiAdcPxDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * ADC Pixel Delay period in uliPeriodNs ns.
 */
alt_u16 usiAdcPxDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
81105080:	defffc04 	addi	sp,sp,-16
81105084:	de00012e 	bgeu	sp,et,8110508c <usiAdcPxDelayCalcPeriodNs+0xc>
81105088:	003b68fa 	trap	3
8110508c:	dfc00315 	stw	ra,12(sp)
81105090:	df000215 	stw	fp,8(sp)
81105094:	df000204 	addi	fp,sp,8
81105098:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 10 = Delay[ns] * 1e-1
	 * AdcPxDelay = Delay[ns] * 1e-1
	 */

	alt_u16 usiAdcPxDelay;
	usiAdcPxDelay = (alt_u16) ((float) uliPeriodNs * 1e-1);
8110509c:	e13fff17 	ldw	r4,-4(fp)
811050a0:	11211500 	call	81121150 <__floatunsisf>
811050a4:	1007883a 	mov	r3,r2
811050a8:	1809883a 	mov	r4,r3
811050ac:	11224ac0 	call	811224ac <__extendsfdf2>
811050b0:	1011883a 	mov	r8,r2
811050b4:	1813883a 	mov	r9,r3
811050b8:	01a666b4 	movhi	r6,39322
811050bc:	31a66684 	addi	r6,r6,-26214
811050c0:	01cfeeb4 	movhi	r7,16314
811050c4:	39e66644 	addi	r7,r7,-26215
811050c8:	4009883a 	mov	r4,r8
811050cc:	480b883a 	mov	r5,r9
811050d0:	11213240 	call	81121324 <__muldf3>
811050d4:	1009883a 	mov	r4,r2
811050d8:	180b883a 	mov	r5,r3
811050dc:	2005883a 	mov	r2,r4
811050e0:	2807883a 	mov	r3,r5
811050e4:	1009883a 	mov	r4,r2
811050e8:	180b883a 	mov	r5,r3
811050ec:	112075c0 	call	8112075c <__fixunsdfsi>
811050f0:	e0bffe0d 	sth	r2,-8(fp)

	return usiAdcPxDelay;
811050f4:	e0bffe0b 	ldhu	r2,-8(fp)
}
811050f8:	e037883a 	mov	sp,fp
811050fc:	dfc00117 	ldw	ra,4(sp)
81105100:	df000017 	ldw	fp,0(sp)
81105104:	dec00204 	addi	sp,sp,8
81105108:	f800283a 	ret

8110510c <usiLineTrDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * Line Transfer Delay period in uliPeriodNs ns.
 */
alt_u16 usiLineTrDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
8110510c:	defffc04 	addi	sp,sp,-16
81105110:	de00012e 	bgeu	sp,et,81105118 <usiLineTrDelayCalcPeriodNs+0xc>
81105114:	003b68fa 	trap	3
81105118:	dfc00315 	stw	ra,12(sp)
8110511c:	df000215 	stw	fp,8(sp)
81105120:	df000204 	addi	fp,sp,8
81105124:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 100 = Delay[ns] * 1e-2
	 * LineTrDelay = Delay[ns] * 1e-2
	 */

	alt_u16 LineTrDelay;
	LineTrDelay = (alt_u16) ((float) uliPeriodNs * 1e-2);
81105128:	e13fff17 	ldw	r4,-4(fp)
8110512c:	11211500 	call	81121150 <__floatunsisf>
81105130:	1007883a 	mov	r3,r2
81105134:	1809883a 	mov	r4,r3
81105138:	11224ac0 	call	811224ac <__extendsfdf2>
8110513c:	1011883a 	mov	r8,r2
81105140:	1813883a 	mov	r9,r3
81105144:	0191ebb4 	movhi	r6,18350
81105148:	31851ec4 	addi	r6,r6,5243
8110514c:	01cfe134 	movhi	r7,16260
81105150:	39deb844 	addi	r7,r7,31457
81105154:	4009883a 	mov	r4,r8
81105158:	480b883a 	mov	r5,r9
8110515c:	11213240 	call	81121324 <__muldf3>
81105160:	1009883a 	mov	r4,r2
81105164:	180b883a 	mov	r5,r3
81105168:	2005883a 	mov	r2,r4
8110516c:	2807883a 	mov	r3,r5
81105170:	1009883a 	mov	r4,r2
81105174:	180b883a 	mov	r5,r3
81105178:	112075c0 	call	8112075c <__fixunsdfsi>
8110517c:	e0bffe0d 	sth	r2,-8(fp)

	return LineTrDelay;
81105180:	e0bffe0b 	ldhu	r2,-8(fp)
}
81105184:	e037883a 	mov	sp,fp
81105188:	dfc00117 	ldw	ra,4(sp)
8110518c:	df000017 	ldw	fp,0(sp)
81105190:	dec00204 	addi	sp,sp,8
81105194:	f800283a 	ret

81105198 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81105198:	defffd04 	addi	sp,sp,-12
8110519c:	de00012e 	bgeu	sp,et,811051a4 <vFeebCh1HandleIrq+0xc>
811051a0:	003b68fa 	trap	3
811051a4:	dfc00215 	stw	ra,8(sp)
811051a8:	df000115 	stw	fp,4(sp)
811051ac:	df000104 	addi	fp,sp,4
811051b0:	e13fff15 	stw	r4,-4(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	//INT8U error_codel;
	//tQMask uiCmdtoSend;

	vFeebCh1IrqFlagClrBufferEmpty();
811051b4:	11053580 	call	81105358 <vFeebCh1IrqFlagClrBufferEmpty>
	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */



}
811051b8:	0001883a 	nop
811051bc:	e037883a 	mov	sp,fp
811051c0:	dfc00117 	ldw	ra,4(sp)
811051c4:	df000017 	ldw	fp,0(sp)
811051c8:	dec00204 	addi	sp,sp,8
811051cc:	f800283a 	ret

811051d0 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
811051d0:	defffd04 	addi	sp,sp,-12
811051d4:	de00012e 	bgeu	sp,et,811051dc <vFeebCh2HandleIrq+0xc>
811051d8:	003b68fa 	trap	3
811051dc:	dfc00215 	stw	ra,8(sp)
811051e0:	df000115 	stw	fp,4(sp)
811051e4:	df000104 	addi	fp,sp,4
811051e8:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;

	//INT8U error_codel;
	//tQMask uiCmdtoSend;

	vFeebCh2IrqFlagClrBufferEmpty();
811051ec:	110539c0 	call	8110539c <vFeebCh2IrqFlagClrBufferEmpty>
	if ( error_codel != OS_ERR_NONE ) {
		vFailRequestDMAFromIRQ( 1 );
	}
*/

}
811051f0:	0001883a 	nop
811051f4:	e037883a 	mov	sp,fp
811051f8:	dfc00117 	ldw	ra,4(sp)
811051fc:	df000017 	ldw	fp,0(sp)
81105200:	dec00204 	addi	sp,sp,8
81105204:	f800283a 	ret

81105208 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
81105208:	defffd04 	addi	sp,sp,-12
8110520c:	de00012e 	bgeu	sp,et,81105214 <vFeebCh3HandleIrq+0xc>
81105210:	003b68fa 	trap	3
81105214:	dfc00215 	stw	ra,8(sp)
81105218:	df000115 	stw	fp,4(sp)
8110521c:	df000104 	addi	fp,sp,4
81105220:	e13fff15 	stw	r4,-4(fp)
//	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 2 );
//	}

	vFeebCh3IrqFlagClrBufferEmpty();
81105224:	11053e00 	call	811053e0 <vFeebCh3IrqFlagClrBufferEmpty>
}
81105228:	0001883a 	nop
8110522c:	e037883a 	mov	sp,fp
81105230:	dfc00117 	ldw	ra,4(sp)
81105234:	df000017 	ldw	fp,0(sp)
81105238:	dec00204 	addi	sp,sp,8
8110523c:	f800283a 	ret

81105240 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
81105240:	defffd04 	addi	sp,sp,-12
81105244:	de00012e 	bgeu	sp,et,8110524c <vFeebCh4HandleIrq+0xc>
81105248:	003b68fa 	trap	3
8110524c:	dfc00215 	stw	ra,8(sp)
81105250:	df000115 	stw	fp,4(sp)
81105254:	df000104 	addi	fp,sp,4
81105258:	e13fff15 	stw	r4,-4(fp)
//	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 3 );
//	}

	vFeebCh4IrqFlagClrBufferEmpty();
8110525c:	11054240 	call	81105424 <vFeebCh4IrqFlagClrBufferEmpty>
}
81105260:	0001883a 	nop
81105264:	e037883a 	mov	sp,fp
81105268:	dfc00117 	ldw	ra,4(sp)
8110526c:	df000017 	ldw	fp,0(sp)
81105270:	dec00204 	addi	sp,sp,8
81105274:	f800283a 	ret

81105278 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81105278:	defffd04 	addi	sp,sp,-12
8110527c:	de00012e 	bgeu	sp,et,81105284 <vFeebCh5HandleIrq+0xc>
81105280:	003b68fa 	trap	3
81105284:	dfc00215 	stw	ra,8(sp)
81105288:	df000115 	stw	fp,4(sp)
8110528c:	df000104 	addi	fp,sp,4
81105290:	e13fff15 	stw	r4,-4(fp)
//	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 4 );
//	}

	vFeebCh5IrqFlagClrBufferEmpty();
81105294:	11054680 	call	81105468 <vFeebCh5IrqFlagClrBufferEmpty>
}
81105298:	0001883a 	nop
8110529c:	e037883a 	mov	sp,fp
811052a0:	dfc00117 	ldw	ra,4(sp)
811052a4:	df000017 	ldw	fp,0(sp)
811052a8:	dec00204 	addi	sp,sp,8
811052ac:	f800283a 	ret

811052b0 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
811052b0:	defffd04 	addi	sp,sp,-12
811052b4:	de00012e 	bgeu	sp,et,811052bc <vFeebCh6HandleIrq+0xc>
811052b8:	003b68fa 	trap	3
811052bc:	dfc00215 	stw	ra,8(sp)
811052c0:	df000115 	stw	fp,4(sp)
811052c4:	df000104 	addi	fp,sp,4
811052c8:	e13fff15 	stw	r4,-4(fp)
//	if ( error_codel != OS_ERR_NONE ) {
//		vFailRequestDMAFromIRQ( 5 );
//	}


	vFeebCh6IrqFlagClrBufferEmpty();
811052cc:	11054ac0 	call	811054ac <vFeebCh6IrqFlagClrBufferEmpty>
}
811052d0:	0001883a 	nop
811052d4:	e037883a 	mov	sp,fp
811052d8:	dfc00117 	ldw	ra,4(sp)
811052dc:	df000017 	ldw	fp,0(sp)
811052e0:	dec00204 	addi	sp,sp,8
811052e4:	f800283a 	ret

811052e8 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
811052e8:	defffd04 	addi	sp,sp,-12
811052ec:	de00012e 	bgeu	sp,et,811052f4 <vFeebCh7HandleIrq+0xc>
811052f0:	003b68fa 	trap	3
811052f4:	dfc00215 	stw	ra,8(sp)
811052f8:	df000115 	stw	fp,4(sp)
811052fc:	df000104 	addi	fp,sp,4
81105300:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;


	vFeebCh7IrqFlagClrBufferEmpty();
81105304:	11054f00 	call	811054f0 <vFeebCh7IrqFlagClrBufferEmpty>
}
81105308:	0001883a 	nop
8110530c:	e037883a 	mov	sp,fp
81105310:	dfc00117 	ldw	ra,4(sp)
81105314:	df000017 	ldw	fp,0(sp)
81105318:	dec00204 	addi	sp,sp,8
8110531c:	f800283a 	ret

81105320 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
81105320:	defffd04 	addi	sp,sp,-12
81105324:	de00012e 	bgeu	sp,et,8110532c <vFeebCh8HandleIrq+0xc>
81105328:	003b68fa 	trap	3
8110532c:	dfc00215 	stw	ra,8(sp)
81105330:	df000115 	stw	fp,4(sp)
81105334:	df000104 	addi	fp,sp,4
81105338:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;


	vFeebCh8IrqFlagClrBufferEmpty();
8110533c:	11055340 	call	81105534 <vFeebCh8IrqFlagClrBufferEmpty>
}
81105340:	0001883a 	nop
81105344:	e037883a 	mov	sp,fp
81105348:	dfc00117 	ldw	ra,4(sp)
8110534c:	df000017 	ldw	fp,0(sp)
81105350:	dec00204 	addi	sp,sp,8
81105354:	f800283a 	ret

81105358 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81105358:	defffe04 	addi	sp,sp,-8
8110535c:	de00012e 	bgeu	sp,et,81105364 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
81105360:	003b68fa 	trap	3
81105364:	dfc00115 	stw	ra,4(sp)
81105368:	df000015 	stw	fp,0(sp)
8110536c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105370:	01804004 	movi	r6,256
81105374:	014004c4 	movi	r5,19
81105378:	01204834 	movhi	r4,33056
8110537c:	210b0004 	addi	r4,r4,11264
81105380:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105384:	0001883a 	nop
81105388:	e037883a 	mov	sp,fp
8110538c:	dfc00117 	ldw	ra,4(sp)
81105390:	df000017 	ldw	fp,0(sp)
81105394:	dec00204 	addi	sp,sp,8
81105398:	f800283a 	ret

8110539c <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
8110539c:	defffe04 	addi	sp,sp,-8
811053a0:	de00012e 	bgeu	sp,et,811053a8 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
811053a4:	003b68fa 	trap	3
811053a8:	dfc00115 	stw	ra,4(sp)
811053ac:	df000015 	stw	fp,0(sp)
811053b0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811053b4:	01804004 	movi	r6,256
811053b8:	014004c4 	movi	r5,19
811053bc:	01204834 	movhi	r4,33056
811053c0:	210a0004 	addi	r4,r4,10240
811053c4:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811053c8:	0001883a 	nop
811053cc:	e037883a 	mov	sp,fp
811053d0:	dfc00117 	ldw	ra,4(sp)
811053d4:	df000017 	ldw	fp,0(sp)
811053d8:	dec00204 	addi	sp,sp,8
811053dc:	f800283a 	ret

811053e0 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
811053e0:	defffe04 	addi	sp,sp,-8
811053e4:	de00012e 	bgeu	sp,et,811053ec <vFeebCh3IrqFlagClrBufferEmpty+0xc>
811053e8:	003b68fa 	trap	3
811053ec:	dfc00115 	stw	ra,4(sp)
811053f0:	df000015 	stw	fp,0(sp)
811053f4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811053f8:	01804004 	movi	r6,256
811053fc:	014004c4 	movi	r5,19
81105400:	01204834 	movhi	r4,33056
81105404:	210b0004 	addi	r4,r4,11264
81105408:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110540c:	0001883a 	nop
81105410:	e037883a 	mov	sp,fp
81105414:	dfc00117 	ldw	ra,4(sp)
81105418:	df000017 	ldw	fp,0(sp)
8110541c:	dec00204 	addi	sp,sp,8
81105420:	f800283a 	ret

81105424 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
81105424:	defffe04 	addi	sp,sp,-8
81105428:	de00012e 	bgeu	sp,et,81105430 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
8110542c:	003b68fa 	trap	3
81105430:	dfc00115 	stw	ra,4(sp)
81105434:	df000015 	stw	fp,0(sp)
81105438:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110543c:	01804004 	movi	r6,256
81105440:	014004c4 	movi	r5,19
81105444:	01204834 	movhi	r4,33056
81105448:	210a0004 	addi	r4,r4,10240
8110544c:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105450:	0001883a 	nop
81105454:	e037883a 	mov	sp,fp
81105458:	dfc00117 	ldw	ra,4(sp)
8110545c:	df000017 	ldw	fp,0(sp)
81105460:	dec00204 	addi	sp,sp,8
81105464:	f800283a 	ret

81105468 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
81105468:	defffe04 	addi	sp,sp,-8
8110546c:	de00012e 	bgeu	sp,et,81105474 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
81105470:	003b68fa 	trap	3
81105474:	dfc00115 	stw	ra,4(sp)
81105478:	df000015 	stw	fp,0(sp)
8110547c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105480:	01804004 	movi	r6,256
81105484:	014004c4 	movi	r5,19
81105488:	01204834 	movhi	r4,33056
8110548c:	210b0004 	addi	r4,r4,11264
81105490:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105494:	0001883a 	nop
81105498:	e037883a 	mov	sp,fp
8110549c:	dfc00117 	ldw	ra,4(sp)
811054a0:	df000017 	ldw	fp,0(sp)
811054a4:	dec00204 	addi	sp,sp,8
811054a8:	f800283a 	ret

811054ac <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
811054ac:	defffe04 	addi	sp,sp,-8
811054b0:	de00012e 	bgeu	sp,et,811054b8 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
811054b4:	003b68fa 	trap	3
811054b8:	dfc00115 	stw	ra,4(sp)
811054bc:	df000015 	stw	fp,0(sp)
811054c0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811054c4:	01804004 	movi	r6,256
811054c8:	014004c4 	movi	r5,19
811054cc:	01204834 	movhi	r4,33056
811054d0:	210a0004 	addi	r4,r4,10240
811054d4:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811054d8:	0001883a 	nop
811054dc:	e037883a 	mov	sp,fp
811054e0:	dfc00117 	ldw	ra,4(sp)
811054e4:	df000017 	ldw	fp,0(sp)
811054e8:	dec00204 	addi	sp,sp,8
811054ec:	f800283a 	ret

811054f0 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
811054f0:	defffe04 	addi	sp,sp,-8
811054f4:	de00012e 	bgeu	sp,et,811054fc <vFeebCh7IrqFlagClrBufferEmpty+0xc>
811054f8:	003b68fa 	trap	3
811054fc:	dfc00115 	stw	ra,4(sp)
81105500:	df000015 	stw	fp,0(sp)
81105504:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105508:	01804004 	movi	r6,256
8110550c:	014004c4 	movi	r5,19
81105510:	01204834 	movhi	r4,33056
81105514:	210b0004 	addi	r4,r4,11264
81105518:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110551c:	0001883a 	nop
81105520:	e037883a 	mov	sp,fp
81105524:	dfc00117 	ldw	ra,4(sp)
81105528:	df000017 	ldw	fp,0(sp)
8110552c:	dec00204 	addi	sp,sp,8
81105530:	f800283a 	ret

81105534 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
81105534:	defffe04 	addi	sp,sp,-8
81105538:	de00012e 	bgeu	sp,et,81105540 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
8110553c:	003b68fa 	trap	3
81105540:	dfc00115 	stw	ra,4(sp)
81105544:	df000015 	stw	fp,0(sp)
81105548:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110554c:	01804004 	movi	r6,256
81105550:	014004c4 	movi	r5,19
81105554:	01204834 	movhi	r4,33056
81105558:	210a0004 	addi	r4,r4,10240
8110555c:	1106b240 	call	81106b24 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105560:	0001883a 	nop
81105564:	e037883a 	mov	sp,fp
81105568:	dfc00117 	ldw	ra,4(sp)
8110556c:	df000017 	ldw	fp,0(sp)
81105570:	dec00204 	addi	sp,sp,8
81105574:	f800283a 	ret

81105578 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
81105578:	defffd04 	addi	sp,sp,-12
8110557c:	de00012e 	bgeu	sp,et,81105584 <bFeebCh1IrqFlagBufferEmpty+0xc>
81105580:	003b68fa 	trap	3
81105584:	dfc00215 	stw	ra,8(sp)
81105588:	df000115 	stw	fp,4(sp)
8110558c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105590:	01400484 	movi	r5,18
81105594:	01204834 	movhi	r4,33056
81105598:	210b0004 	addi	r4,r4,11264
8110559c:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811055a0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811055a4:	10000326 	beq	r2,zero,811055b4 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811055a8:	00800044 	movi	r2,1
811055ac:	e0bfff15 	stw	r2,-4(fp)
811055b0:	00000106 	br	811055b8 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811055b4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811055b8:	e0bfff17 	ldw	r2,-4(fp)
}
811055bc:	e037883a 	mov	sp,fp
811055c0:	dfc00117 	ldw	ra,4(sp)
811055c4:	df000017 	ldw	fp,0(sp)
811055c8:	dec00204 	addi	sp,sp,8
811055cc:	f800283a 	ret

811055d0 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
811055d0:	defffd04 	addi	sp,sp,-12
811055d4:	de00012e 	bgeu	sp,et,811055dc <bFeebCh2IrqFlagBufferEmpty+0xc>
811055d8:	003b68fa 	trap	3
811055dc:	dfc00215 	stw	ra,8(sp)
811055e0:	df000115 	stw	fp,4(sp)
811055e4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811055e8:	01400484 	movi	r5,18
811055ec:	01204834 	movhi	r4,33056
811055f0:	210a0004 	addi	r4,r4,10240
811055f4:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811055f8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811055fc:	10000326 	beq	r2,zero,8110560c <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105600:	00800044 	movi	r2,1
81105604:	e0bfff15 	stw	r2,-4(fp)
81105608:	00000106 	br	81105610 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110560c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105610:	e0bfff17 	ldw	r2,-4(fp)
}
81105614:	e037883a 	mov	sp,fp
81105618:	dfc00117 	ldw	ra,4(sp)
8110561c:	df000017 	ldw	fp,0(sp)
81105620:	dec00204 	addi	sp,sp,8
81105624:	f800283a 	ret

81105628 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
81105628:	defffd04 	addi	sp,sp,-12
8110562c:	de00012e 	bgeu	sp,et,81105634 <bFeebCh3IrqFlagBufferEmpty+0xc>
81105630:	003b68fa 	trap	3
81105634:	dfc00215 	stw	ra,8(sp)
81105638:	df000115 	stw	fp,4(sp)
8110563c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105640:	01400484 	movi	r5,18
81105644:	01204834 	movhi	r4,33056
81105648:	210b0004 	addi	r4,r4,11264
8110564c:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105650:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105654:	10000326 	beq	r2,zero,81105664 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105658:	00800044 	movi	r2,1
8110565c:	e0bfff15 	stw	r2,-4(fp)
81105660:	00000106 	br	81105668 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105664:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105668:	e0bfff17 	ldw	r2,-4(fp)
}
8110566c:	e037883a 	mov	sp,fp
81105670:	dfc00117 	ldw	ra,4(sp)
81105674:	df000017 	ldw	fp,0(sp)
81105678:	dec00204 	addi	sp,sp,8
8110567c:	f800283a 	ret

81105680 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81105680:	defffd04 	addi	sp,sp,-12
81105684:	de00012e 	bgeu	sp,et,8110568c <bFeebCh4IrqFlagBufferEmpty+0xc>
81105688:	003b68fa 	trap	3
8110568c:	dfc00215 	stw	ra,8(sp)
81105690:	df000115 	stw	fp,4(sp)
81105694:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105698:	01400484 	movi	r5,18
8110569c:	01204834 	movhi	r4,33056
811056a0:	210a0004 	addi	r4,r4,10240
811056a4:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811056a8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811056ac:	10000326 	beq	r2,zero,811056bc <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811056b0:	00800044 	movi	r2,1
811056b4:	e0bfff15 	stw	r2,-4(fp)
811056b8:	00000106 	br	811056c0 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811056bc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811056c0:	e0bfff17 	ldw	r2,-4(fp)
}
811056c4:	e037883a 	mov	sp,fp
811056c8:	dfc00117 	ldw	ra,4(sp)
811056cc:	df000017 	ldw	fp,0(sp)
811056d0:	dec00204 	addi	sp,sp,8
811056d4:	f800283a 	ret

811056d8 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
811056d8:	defffd04 	addi	sp,sp,-12
811056dc:	de00012e 	bgeu	sp,et,811056e4 <bFeebCh5IrqFlagBufferEmpty+0xc>
811056e0:	003b68fa 	trap	3
811056e4:	dfc00215 	stw	ra,8(sp)
811056e8:	df000115 	stw	fp,4(sp)
811056ec:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811056f0:	01400484 	movi	r5,18
811056f4:	01204834 	movhi	r4,33056
811056f8:	210b0004 	addi	r4,r4,11264
811056fc:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105700:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105704:	10000326 	beq	r2,zero,81105714 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105708:	00800044 	movi	r2,1
8110570c:	e0bfff15 	stw	r2,-4(fp)
81105710:	00000106 	br	81105718 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105714:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105718:	e0bfff17 	ldw	r2,-4(fp)
}
8110571c:	e037883a 	mov	sp,fp
81105720:	dfc00117 	ldw	ra,4(sp)
81105724:	df000017 	ldw	fp,0(sp)
81105728:	dec00204 	addi	sp,sp,8
8110572c:	f800283a 	ret

81105730 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81105730:	defffd04 	addi	sp,sp,-12
81105734:	de00012e 	bgeu	sp,et,8110573c <bFeebCh6IrqFlagBufferEmpty+0xc>
81105738:	003b68fa 	trap	3
8110573c:	dfc00215 	stw	ra,8(sp)
81105740:	df000115 	stw	fp,4(sp)
81105744:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105748:	01400484 	movi	r5,18
8110574c:	01204834 	movhi	r4,33056
81105750:	210a0004 	addi	r4,r4,10240
81105754:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105758:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
8110575c:	10000326 	beq	r2,zero,8110576c <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105760:	00800044 	movi	r2,1
81105764:	e0bfff15 	stw	r2,-4(fp)
81105768:	00000106 	br	81105770 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110576c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105770:	e0bfff17 	ldw	r2,-4(fp)
}
81105774:	e037883a 	mov	sp,fp
81105778:	dfc00117 	ldw	ra,4(sp)
8110577c:	df000017 	ldw	fp,0(sp)
81105780:	dec00204 	addi	sp,sp,8
81105784:	f800283a 	ret

81105788 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81105788:	defffd04 	addi	sp,sp,-12
8110578c:	de00012e 	bgeu	sp,et,81105794 <bFeebCh7IrqFlagBufferEmpty+0xc>
81105790:	003b68fa 	trap	3
81105794:	dfc00215 	stw	ra,8(sp)
81105798:	df000115 	stw	fp,4(sp)
8110579c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811057a0:	01400484 	movi	r5,18
811057a4:	01204834 	movhi	r4,33056
811057a8:	210b0004 	addi	r4,r4,11264
811057ac:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811057b0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811057b4:	10000326 	beq	r2,zero,811057c4 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811057b8:	00800044 	movi	r2,1
811057bc:	e0bfff15 	stw	r2,-4(fp)
811057c0:	00000106 	br	811057c8 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811057c4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811057c8:	e0bfff17 	ldw	r2,-4(fp)
}
811057cc:	e037883a 	mov	sp,fp
811057d0:	dfc00117 	ldw	ra,4(sp)
811057d4:	df000017 	ldw	fp,0(sp)
811057d8:	dec00204 	addi	sp,sp,8
811057dc:	f800283a 	ret

811057e0 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
811057e0:	defffd04 	addi	sp,sp,-12
811057e4:	de00012e 	bgeu	sp,et,811057ec <bFeebCh8IrqFlagBufferEmpty+0xc>
811057e8:	003b68fa 	trap	3
811057ec:	dfc00215 	stw	ra,8(sp)
811057f0:	df000115 	stw	fp,4(sp)
811057f4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811057f8:	01400484 	movi	r5,18
811057fc:	01204834 	movhi	r4,33056
81105800:	210a0004 	addi	r4,r4,10240
81105804:	1106b780 	call	81106b78 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105808:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110580c:	10000326 	beq	r2,zero,8110581c <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105810:	00800044 	movi	r2,1
81105814:	e0bfff15 	stw	r2,-4(fp)
81105818:	00000106 	br	81105820 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110581c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105820:	e0bfff17 	ldw	r2,-4(fp)
}
81105824:	e037883a 	mov	sp,fp
81105828:	dfc00117 	ldw	ra,4(sp)
8110582c:	df000017 	ldw	fp,0(sp)
81105830:	dec00204 	addi	sp,sp,8
81105834:	f800283a 	ret

81105838 <bFeebCh1SetBufferSize>:

bool bFeebCh1SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105838:	defffa04 	addi	sp,sp,-24
8110583c:	de00012e 	bgeu	sp,et,81105844 <bFeebCh1SetBufferSize+0xc>
81105840:	003b68fa 	trap	3
81105844:	dfc00515 	stw	ra,20(sp)
81105848:	df000415 	stw	fp,16(sp)
8110584c:	df000404 	addi	fp,sp,16
81105850:	2007883a 	mov	r3,r4
81105854:	2805883a 	mov	r2,r5
81105858:	e0fffe05 	stb	r3,-8(fp)
8110585c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105860:	00800044 	movi	r2,1
81105864:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105868:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
8110586c:	e0bffe03 	ldbu	r2,-8(fp)
81105870:	10001f26 	beq	r2,zero,811058f0 <bFeebCh1SetBufferSize+0xb8>
81105874:	e0bffe03 	ldbu	r2,-8(fp)
81105878:	10800468 	cmpgeui	r2,r2,17
8110587c:	10001c1e 	bne	r2,zero,811058f0 <bFeebCh1SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105880:	e0bfff03 	ldbu	r2,-4(fp)
81105884:	10000326 	beq	r2,zero,81105894 <bFeebCh1SetBufferSize+0x5c>
81105888:	10800060 	cmpeqi	r2,r2,1
8110588c:	10000b1e 	bne	r2,zero,811058bc <bFeebCh1SetBufferSize+0x84>
81105890:	00001406 	br	811058e4 <bFeebCh1SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105894:	e0bffe03 	ldbu	r2,-8(fp)
81105898:	10bfffc4 	addi	r2,r2,-1
8110589c:	108003cc 	andi	r2,r2,15
811058a0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811058a4:	e1bffd17 	ldw	r6,-12(fp)
811058a8:	01400544 	movi	r5,21
811058ac:	01204834 	movhi	r4,33056
811058b0:	210b0004 	addi	r4,r4,11264
811058b4:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811058b8:	00000c06 	br	811058ec <bFeebCh1SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811058bc:	e0bffe03 	ldbu	r2,-8(fp)
811058c0:	10bfffc4 	addi	r2,r2,-1
811058c4:	108003cc 	andi	r2,r2,15
811058c8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811058cc:	e1bffd17 	ldw	r6,-12(fp)
811058d0:	01400504 	movi	r5,20
811058d4:	01204834 	movhi	r4,33056
811058d8:	210b0004 	addi	r4,r4,11264
811058dc:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811058e0:	00000206 	br	811058ec <bFeebCh1SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
811058e4:	e03ffc15 	stw	zero,-16(fp)
			break;
811058e8:	0001883a 	nop
		}
	} else {
811058ec:	00000106 	br	811058f4 <bFeebCh1SetBufferSize+0xbc>
		bStatus = FALSE;
811058f0:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
811058f4:	e0bffc17 	ldw	r2,-16(fp)
}
811058f8:	e037883a 	mov	sp,fp
811058fc:	dfc00117 	ldw	ra,4(sp)
81105900:	df000017 	ldw	fp,0(sp)
81105904:	dec00204 	addi	sp,sp,8
81105908:	f800283a 	ret

8110590c <bFeebCh2SetBufferSize>:

bool bFeebCh2SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
8110590c:	defffa04 	addi	sp,sp,-24
81105910:	de00012e 	bgeu	sp,et,81105918 <bFeebCh2SetBufferSize+0xc>
81105914:	003b68fa 	trap	3
81105918:	dfc00515 	stw	ra,20(sp)
8110591c:	df000415 	stw	fp,16(sp)
81105920:	df000404 	addi	fp,sp,16
81105924:	2007883a 	mov	r3,r4
81105928:	2805883a 	mov	r2,r5
8110592c:	e0fffe05 	stb	r3,-8(fp)
81105930:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105934:	00800044 	movi	r2,1
81105938:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
8110593c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105940:	e0bffe03 	ldbu	r2,-8(fp)
81105944:	10001f26 	beq	r2,zero,811059c4 <bFeebCh2SetBufferSize+0xb8>
81105948:	e0bffe03 	ldbu	r2,-8(fp)
8110594c:	10800468 	cmpgeui	r2,r2,17
81105950:	10001c1e 	bne	r2,zero,811059c4 <bFeebCh2SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105954:	e0bfff03 	ldbu	r2,-4(fp)
81105958:	10000326 	beq	r2,zero,81105968 <bFeebCh2SetBufferSize+0x5c>
8110595c:	10800060 	cmpeqi	r2,r2,1
81105960:	10000b1e 	bne	r2,zero,81105990 <bFeebCh2SetBufferSize+0x84>
81105964:	00001406 	br	811059b8 <bFeebCh2SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105968:	e0bffe03 	ldbu	r2,-8(fp)
8110596c:	10bfffc4 	addi	r2,r2,-1
81105970:	108003cc 	andi	r2,r2,15
81105974:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105978:	e1bffd17 	ldw	r6,-12(fp)
8110597c:	01400544 	movi	r5,21
81105980:	01204834 	movhi	r4,33056
81105984:	210a0004 	addi	r4,r4,10240
81105988:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
8110598c:	00000c06 	br	811059c0 <bFeebCh2SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105990:	e0bffe03 	ldbu	r2,-8(fp)
81105994:	10bfffc4 	addi	r2,r2,-1
81105998:	108003cc 	andi	r2,r2,15
8110599c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811059a0:	e1bffd17 	ldw	r6,-12(fp)
811059a4:	01400504 	movi	r5,20
811059a8:	01204834 	movhi	r4,33056
811059ac:	210a0004 	addi	r4,r4,10240
811059b0:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811059b4:	00000206 	br	811059c0 <bFeebCh2SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
811059b8:	e03ffc15 	stw	zero,-16(fp)
			break;
811059bc:	0001883a 	nop
		}
	} else {
811059c0:	00000106 	br	811059c8 <bFeebCh2SetBufferSize+0xbc>
		bStatus = FALSE;
811059c4:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
811059c8:	e0bffc17 	ldw	r2,-16(fp)
}
811059cc:	e037883a 	mov	sp,fp
811059d0:	dfc00117 	ldw	ra,4(sp)
811059d4:	df000017 	ldw	fp,0(sp)
811059d8:	dec00204 	addi	sp,sp,8
811059dc:	f800283a 	ret

811059e0 <bFeebCh3SetBufferSize>:

bool bFeebCh3SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
811059e0:	defffa04 	addi	sp,sp,-24
811059e4:	de00012e 	bgeu	sp,et,811059ec <bFeebCh3SetBufferSize+0xc>
811059e8:	003b68fa 	trap	3
811059ec:	dfc00515 	stw	ra,20(sp)
811059f0:	df000415 	stw	fp,16(sp)
811059f4:	df000404 	addi	fp,sp,16
811059f8:	2007883a 	mov	r3,r4
811059fc:	2805883a 	mov	r2,r5
81105a00:	e0fffe05 	stb	r3,-8(fp)
81105a04:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105a08:	00800044 	movi	r2,1
81105a0c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105a10:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105a14:	e0bffe03 	ldbu	r2,-8(fp)
81105a18:	10001f26 	beq	r2,zero,81105a98 <bFeebCh3SetBufferSize+0xb8>
81105a1c:	e0bffe03 	ldbu	r2,-8(fp)
81105a20:	10800468 	cmpgeui	r2,r2,17
81105a24:	10001c1e 	bne	r2,zero,81105a98 <bFeebCh3SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105a28:	e0bfff03 	ldbu	r2,-4(fp)
81105a2c:	10000326 	beq	r2,zero,81105a3c <bFeebCh3SetBufferSize+0x5c>
81105a30:	10800060 	cmpeqi	r2,r2,1
81105a34:	10000b1e 	bne	r2,zero,81105a64 <bFeebCh3SetBufferSize+0x84>
81105a38:	00001406 	br	81105a8c <bFeebCh3SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a3c:	e0bffe03 	ldbu	r2,-8(fp)
81105a40:	10bfffc4 	addi	r2,r2,-1
81105a44:	108003cc 	andi	r2,r2,15
81105a48:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105a4c:	e1bffd17 	ldw	r6,-12(fp)
81105a50:	01400544 	movi	r5,21
81105a54:	01204834 	movhi	r4,33056
81105a58:	210b0004 	addi	r4,r4,11264
81105a5c:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105a60:	00000c06 	br	81105a94 <bFeebCh3SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a64:	e0bffe03 	ldbu	r2,-8(fp)
81105a68:	10bfffc4 	addi	r2,r2,-1
81105a6c:	108003cc 	andi	r2,r2,15
81105a70:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105a74:	e1bffd17 	ldw	r6,-12(fp)
81105a78:	01400504 	movi	r5,20
81105a7c:	01204834 	movhi	r4,33056
81105a80:	210b0004 	addi	r4,r4,11264
81105a84:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105a88:	00000206 	br	81105a94 <bFeebCh3SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105a8c:	e03ffc15 	stw	zero,-16(fp)
			break;
81105a90:	0001883a 	nop
		}
	} else {
81105a94:	00000106 	br	81105a9c <bFeebCh3SetBufferSize+0xbc>
		bStatus = FALSE;
81105a98:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105a9c:	e0bffc17 	ldw	r2,-16(fp)
}
81105aa0:	e037883a 	mov	sp,fp
81105aa4:	dfc00117 	ldw	ra,4(sp)
81105aa8:	df000017 	ldw	fp,0(sp)
81105aac:	dec00204 	addi	sp,sp,8
81105ab0:	f800283a 	ret

81105ab4 <bFeebCh4SetBufferSize>:

bool bFeebCh4SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105ab4:	defffa04 	addi	sp,sp,-24
81105ab8:	de00012e 	bgeu	sp,et,81105ac0 <bFeebCh4SetBufferSize+0xc>
81105abc:	003b68fa 	trap	3
81105ac0:	dfc00515 	stw	ra,20(sp)
81105ac4:	df000415 	stw	fp,16(sp)
81105ac8:	df000404 	addi	fp,sp,16
81105acc:	2007883a 	mov	r3,r4
81105ad0:	2805883a 	mov	r2,r5
81105ad4:	e0fffe05 	stb	r3,-8(fp)
81105ad8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105adc:	00800044 	movi	r2,1
81105ae0:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105ae4:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105ae8:	e0bffe03 	ldbu	r2,-8(fp)
81105aec:	10001f26 	beq	r2,zero,81105b6c <bFeebCh4SetBufferSize+0xb8>
81105af0:	e0bffe03 	ldbu	r2,-8(fp)
81105af4:	10800468 	cmpgeui	r2,r2,17
81105af8:	10001c1e 	bne	r2,zero,81105b6c <bFeebCh4SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105afc:	e0bfff03 	ldbu	r2,-4(fp)
81105b00:	10000326 	beq	r2,zero,81105b10 <bFeebCh4SetBufferSize+0x5c>
81105b04:	10800060 	cmpeqi	r2,r2,1
81105b08:	10000b1e 	bne	r2,zero,81105b38 <bFeebCh4SetBufferSize+0x84>
81105b0c:	00001406 	br	81105b60 <bFeebCh4SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105b10:	e0bffe03 	ldbu	r2,-8(fp)
81105b14:	10bfffc4 	addi	r2,r2,-1
81105b18:	108003cc 	andi	r2,r2,15
81105b1c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105b20:	e1bffd17 	ldw	r6,-12(fp)
81105b24:	01400544 	movi	r5,21
81105b28:	01204834 	movhi	r4,33056
81105b2c:	210a0004 	addi	r4,r4,10240
81105b30:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105b34:	00000c06 	br	81105b68 <bFeebCh4SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105b38:	e0bffe03 	ldbu	r2,-8(fp)
81105b3c:	10bfffc4 	addi	r2,r2,-1
81105b40:	108003cc 	andi	r2,r2,15
81105b44:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105b48:	e1bffd17 	ldw	r6,-12(fp)
81105b4c:	01400504 	movi	r5,20
81105b50:	01204834 	movhi	r4,33056
81105b54:	210a0004 	addi	r4,r4,10240
81105b58:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105b5c:	00000206 	br	81105b68 <bFeebCh4SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105b60:	e03ffc15 	stw	zero,-16(fp)
			break;
81105b64:	0001883a 	nop
		}
	} else {
81105b68:	00000106 	br	81105b70 <bFeebCh4SetBufferSize+0xbc>
		bStatus = FALSE;
81105b6c:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105b70:	e0bffc17 	ldw	r2,-16(fp)
}
81105b74:	e037883a 	mov	sp,fp
81105b78:	dfc00117 	ldw	ra,4(sp)
81105b7c:	df000017 	ldw	fp,0(sp)
81105b80:	dec00204 	addi	sp,sp,8
81105b84:	f800283a 	ret

81105b88 <bFeebCh5SetBufferSize>:

bool bFeebCh5SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105b88:	defffa04 	addi	sp,sp,-24
81105b8c:	de00012e 	bgeu	sp,et,81105b94 <bFeebCh5SetBufferSize+0xc>
81105b90:	003b68fa 	trap	3
81105b94:	dfc00515 	stw	ra,20(sp)
81105b98:	df000415 	stw	fp,16(sp)
81105b9c:	df000404 	addi	fp,sp,16
81105ba0:	2007883a 	mov	r3,r4
81105ba4:	2805883a 	mov	r2,r5
81105ba8:	e0fffe05 	stb	r3,-8(fp)
81105bac:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105bb0:	00800044 	movi	r2,1
81105bb4:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105bb8:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105bbc:	e0bffe03 	ldbu	r2,-8(fp)
81105bc0:	10001f26 	beq	r2,zero,81105c40 <bFeebCh5SetBufferSize+0xb8>
81105bc4:	e0bffe03 	ldbu	r2,-8(fp)
81105bc8:	10800468 	cmpgeui	r2,r2,17
81105bcc:	10001c1e 	bne	r2,zero,81105c40 <bFeebCh5SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105bd0:	e0bfff03 	ldbu	r2,-4(fp)
81105bd4:	10000326 	beq	r2,zero,81105be4 <bFeebCh5SetBufferSize+0x5c>
81105bd8:	10800060 	cmpeqi	r2,r2,1
81105bdc:	10000b1e 	bne	r2,zero,81105c0c <bFeebCh5SetBufferSize+0x84>
81105be0:	00001406 	br	81105c34 <bFeebCh5SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105be4:	e0bffe03 	ldbu	r2,-8(fp)
81105be8:	10bfffc4 	addi	r2,r2,-1
81105bec:	108003cc 	andi	r2,r2,15
81105bf0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105bf4:	e1bffd17 	ldw	r6,-12(fp)
81105bf8:	01400544 	movi	r5,21
81105bfc:	01204834 	movhi	r4,33056
81105c00:	210b0004 	addi	r4,r4,11264
81105c04:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105c08:	00000c06 	br	81105c3c <bFeebCh5SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105c0c:	e0bffe03 	ldbu	r2,-8(fp)
81105c10:	10bfffc4 	addi	r2,r2,-1
81105c14:	108003cc 	andi	r2,r2,15
81105c18:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105c1c:	e1bffd17 	ldw	r6,-12(fp)
81105c20:	01400504 	movi	r5,20
81105c24:	01204834 	movhi	r4,33056
81105c28:	210b0004 	addi	r4,r4,11264
81105c2c:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105c30:	00000206 	br	81105c3c <bFeebCh5SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105c34:	e03ffc15 	stw	zero,-16(fp)
			break;
81105c38:	0001883a 	nop
		}
	} else {
81105c3c:	00000106 	br	81105c44 <bFeebCh5SetBufferSize+0xbc>
		bStatus = FALSE;
81105c40:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105c44:	e0bffc17 	ldw	r2,-16(fp)
}
81105c48:	e037883a 	mov	sp,fp
81105c4c:	dfc00117 	ldw	ra,4(sp)
81105c50:	df000017 	ldw	fp,0(sp)
81105c54:	dec00204 	addi	sp,sp,8
81105c58:	f800283a 	ret

81105c5c <bFeebCh6SetBufferSize>:

bool bFeebCh6SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105c5c:	defffa04 	addi	sp,sp,-24
81105c60:	de00012e 	bgeu	sp,et,81105c68 <bFeebCh6SetBufferSize+0xc>
81105c64:	003b68fa 	trap	3
81105c68:	dfc00515 	stw	ra,20(sp)
81105c6c:	df000415 	stw	fp,16(sp)
81105c70:	df000404 	addi	fp,sp,16
81105c74:	2007883a 	mov	r3,r4
81105c78:	2805883a 	mov	r2,r5
81105c7c:	e0fffe05 	stb	r3,-8(fp)
81105c80:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105c84:	00800044 	movi	r2,1
81105c88:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105c8c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105c90:	e0bffe03 	ldbu	r2,-8(fp)
81105c94:	10001f26 	beq	r2,zero,81105d14 <bFeebCh6SetBufferSize+0xb8>
81105c98:	e0bffe03 	ldbu	r2,-8(fp)
81105c9c:	10800468 	cmpgeui	r2,r2,17
81105ca0:	10001c1e 	bne	r2,zero,81105d14 <bFeebCh6SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105ca4:	e0bfff03 	ldbu	r2,-4(fp)
81105ca8:	10000326 	beq	r2,zero,81105cb8 <bFeebCh6SetBufferSize+0x5c>
81105cac:	10800060 	cmpeqi	r2,r2,1
81105cb0:	10000b1e 	bne	r2,zero,81105ce0 <bFeebCh6SetBufferSize+0x84>
81105cb4:	00001406 	br	81105d08 <bFeebCh6SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105cb8:	e0bffe03 	ldbu	r2,-8(fp)
81105cbc:	10bfffc4 	addi	r2,r2,-1
81105cc0:	108003cc 	andi	r2,r2,15
81105cc4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105cc8:	e1bffd17 	ldw	r6,-12(fp)
81105ccc:	01400544 	movi	r5,21
81105cd0:	01204834 	movhi	r4,33056
81105cd4:	210a0004 	addi	r4,r4,10240
81105cd8:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105cdc:	00000c06 	br	81105d10 <bFeebCh6SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ce0:	e0bffe03 	ldbu	r2,-8(fp)
81105ce4:	10bfffc4 	addi	r2,r2,-1
81105ce8:	108003cc 	andi	r2,r2,15
81105cec:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105cf0:	e1bffd17 	ldw	r6,-12(fp)
81105cf4:	01400504 	movi	r5,20
81105cf8:	01204834 	movhi	r4,33056
81105cfc:	210a0004 	addi	r4,r4,10240
81105d00:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105d04:	00000206 	br	81105d10 <bFeebCh6SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105d08:	e03ffc15 	stw	zero,-16(fp)
			break;
81105d0c:	0001883a 	nop
		}
	} else {
81105d10:	00000106 	br	81105d18 <bFeebCh6SetBufferSize+0xbc>
		bStatus = FALSE;
81105d14:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105d18:	e0bffc17 	ldw	r2,-16(fp)
}
81105d1c:	e037883a 	mov	sp,fp
81105d20:	dfc00117 	ldw	ra,4(sp)
81105d24:	df000017 	ldw	fp,0(sp)
81105d28:	dec00204 	addi	sp,sp,8
81105d2c:	f800283a 	ret

81105d30 <bFeebCh7SetBufferSize>:

bool bFeebCh7SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105d30:	defffa04 	addi	sp,sp,-24
81105d34:	de00012e 	bgeu	sp,et,81105d3c <bFeebCh7SetBufferSize+0xc>
81105d38:	003b68fa 	trap	3
81105d3c:	dfc00515 	stw	ra,20(sp)
81105d40:	df000415 	stw	fp,16(sp)
81105d44:	df000404 	addi	fp,sp,16
81105d48:	2007883a 	mov	r3,r4
81105d4c:	2805883a 	mov	r2,r5
81105d50:	e0fffe05 	stb	r3,-8(fp)
81105d54:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105d58:	00800044 	movi	r2,1
81105d5c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105d60:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105d64:	e0bffe03 	ldbu	r2,-8(fp)
81105d68:	10001f26 	beq	r2,zero,81105de8 <bFeebCh7SetBufferSize+0xb8>
81105d6c:	e0bffe03 	ldbu	r2,-8(fp)
81105d70:	10800468 	cmpgeui	r2,r2,17
81105d74:	10001c1e 	bne	r2,zero,81105de8 <bFeebCh7SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105d78:	e0bfff03 	ldbu	r2,-4(fp)
81105d7c:	10000326 	beq	r2,zero,81105d8c <bFeebCh7SetBufferSize+0x5c>
81105d80:	10800060 	cmpeqi	r2,r2,1
81105d84:	10000b1e 	bne	r2,zero,81105db4 <bFeebCh7SetBufferSize+0x84>
81105d88:	00001406 	br	81105ddc <bFeebCh7SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d8c:	e0bffe03 	ldbu	r2,-8(fp)
81105d90:	10bfffc4 	addi	r2,r2,-1
81105d94:	108003cc 	andi	r2,r2,15
81105d98:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105d9c:	e1bffd17 	ldw	r6,-12(fp)
81105da0:	01400544 	movi	r5,21
81105da4:	01204834 	movhi	r4,33056
81105da8:	210b0004 	addi	r4,r4,11264
81105dac:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105db0:	00000c06 	br	81105de4 <bFeebCh7SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105db4:	e0bffe03 	ldbu	r2,-8(fp)
81105db8:	10bfffc4 	addi	r2,r2,-1
81105dbc:	108003cc 	andi	r2,r2,15
81105dc0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105dc4:	e1bffd17 	ldw	r6,-12(fp)
81105dc8:	01400504 	movi	r5,20
81105dcc:	01204834 	movhi	r4,33056
81105dd0:	210b0004 	addi	r4,r4,11264
81105dd4:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105dd8:	00000206 	br	81105de4 <bFeebCh7SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105ddc:	e03ffc15 	stw	zero,-16(fp)
			break;
81105de0:	0001883a 	nop
		}
	} else {
81105de4:	00000106 	br	81105dec <bFeebCh7SetBufferSize+0xbc>
		bStatus = FALSE;
81105de8:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105dec:	e0bffc17 	ldw	r2,-16(fp)
}
81105df0:	e037883a 	mov	sp,fp
81105df4:	dfc00117 	ldw	ra,4(sp)
81105df8:	df000017 	ldw	fp,0(sp)
81105dfc:	dec00204 	addi	sp,sp,8
81105e00:	f800283a 	ret

81105e04 <bFeebCh8SetBufferSize>:

bool bFeebCh8SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105e04:	defffa04 	addi	sp,sp,-24
81105e08:	de00012e 	bgeu	sp,et,81105e10 <bFeebCh8SetBufferSize+0xc>
81105e0c:	003b68fa 	trap	3
81105e10:	dfc00515 	stw	ra,20(sp)
81105e14:	df000415 	stw	fp,16(sp)
81105e18:	df000404 	addi	fp,sp,16
81105e1c:	2007883a 	mov	r3,r4
81105e20:	2805883a 	mov	r2,r5
81105e24:	e0fffe05 	stb	r3,-8(fp)
81105e28:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105e2c:	00800044 	movi	r2,1
81105e30:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105e34:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105e38:	e0bffe03 	ldbu	r2,-8(fp)
81105e3c:	10001f26 	beq	r2,zero,81105ebc <bFeebCh8SetBufferSize+0xb8>
81105e40:	e0bffe03 	ldbu	r2,-8(fp)
81105e44:	10800468 	cmpgeui	r2,r2,17
81105e48:	10001c1e 	bne	r2,zero,81105ebc <bFeebCh8SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105e4c:	e0bfff03 	ldbu	r2,-4(fp)
81105e50:	10000326 	beq	r2,zero,81105e60 <bFeebCh8SetBufferSize+0x5c>
81105e54:	10800060 	cmpeqi	r2,r2,1
81105e58:	10000b1e 	bne	r2,zero,81105e88 <bFeebCh8SetBufferSize+0x84>
81105e5c:	00001406 	br	81105eb0 <bFeebCh8SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e60:	e0bffe03 	ldbu	r2,-8(fp)
81105e64:	10bfffc4 	addi	r2,r2,-1
81105e68:	108003cc 	andi	r2,r2,15
81105e6c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105e70:	e1bffd17 	ldw	r6,-12(fp)
81105e74:	01400544 	movi	r5,21
81105e78:	01204834 	movhi	r4,33056
81105e7c:	210a0004 	addi	r4,r4,10240
81105e80:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e84:	00000c06 	br	81105eb8 <bFeebCh8SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e88:	e0bffe03 	ldbu	r2,-8(fp)
81105e8c:	10bfffc4 	addi	r2,r2,-1
81105e90:	108003cc 	andi	r2,r2,15
81105e94:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105e98:	e1bffd17 	ldw	r6,-12(fp)
81105e9c:	01400504 	movi	r5,20
81105ea0:	01204834 	movhi	r4,33056
81105ea4:	210a0004 	addi	r4,r4,10240
81105ea8:	1106b240 	call	81106b24 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105eac:	00000206 	br	81105eb8 <bFeebCh8SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105eb0:	e03ffc15 	stw	zero,-16(fp)
			break;
81105eb4:	0001883a 	nop
		}
	} else {
81105eb8:	00000106 	br	81105ec0 <bFeebCh8SetBufferSize+0xbc>
		bStatus = FALSE;
81105ebc:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105ec0:	e0bffc17 	ldw	r2,-16(fp)
}
81105ec4:	e037883a 	mov	sp,fp
81105ec8:	dfc00117 	ldw	ra,4(sp)
81105ecc:	df000017 	ldw	fp,0(sp)
81105ed0:	dec00204 	addi	sp,sp,8
81105ed4:	f800283a 	ret

81105ed8 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81105ed8:	defffc04 	addi	sp,sp,-16
81105edc:	de00012e 	bgeu	sp,et,81105ee4 <vFeebInitIrq+0xc>
81105ee0:	003b68fa 	trap	3
81105ee4:	dfc00315 	stw	ra,12(sp)
81105ee8:	df000215 	stw	fp,8(sp)
81105eec:	df000204 	addi	fp,sp,8
81105ef0:	2005883a 	mov	r2,r4
81105ef4:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81105ef8:	e0bfff03 	ldbu	r2,-4(fp)
81105efc:	10c00228 	cmpgeui	r3,r2,8
81105f00:	18004e1e 	bne	r3,zero,8110603c <vFeebInitIrq+0x164>
81105f04:	100690ba 	slli	r3,r2,2
81105f08:	00a04434 	movhi	r2,33040
81105f0c:	1097c704 	addi	r2,r2,24348
81105f10:	1885883a 	add	r2,r3,r2
81105f14:	10800017 	ldw	r2,0(r2)
81105f18:	1000683a 	jmp	r2
81105f1c:	81105f3c 	xorhi	r4,r16,16764
81105f20:	81105f5c 	xori	r4,r16,16765
81105f24:	81105f7c 	xorhi	r4,r16,16765
81105f28:	81105f9c 	xori	r4,r16,16766
81105f2c:	81105fbc 	xorhi	r4,r16,16766
81105f30:	81105fdc 	xori	r4,r16,16767
81105f34:	81105ffc 	xorhi	r4,r16,16767
81105f38:	8110601c 	xori	r4,r16,16768
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81105f3c:	d0a04004 	addi	r2,gp,-32512
81105f40:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
81105f44:	01a04434 	movhi	r6,33040
81105f48:	31946604 	addi	r6,r6,20888
81105f4c:	e17ffe17 	ldw	r5,-8(fp)
81105f50:	01000584 	movi	r4,22
81105f54:	11378f80 	call	811378f8 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
81105f58:	00003806 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81105f5c:	d0a04104 	addi	r2,gp,-32508
81105f60:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
81105f64:	01a04434 	movhi	r6,33040
81105f68:	31947404 	addi	r6,r6,20944
81105f6c:	e17ffe17 	ldw	r5,-8(fp)
81105f70:	01000504 	movi	r4,20
81105f74:	11378f80 	call	811378f8 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
81105f78:	00003006 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81105f7c:	d0a04204 	addi	r2,gp,-32504
81105f80:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
81105f84:	01a04434 	movhi	r6,33040
81105f88:	31948204 	addi	r6,r6,21000
81105f8c:	e17ffe17 	ldw	r5,-8(fp)
81105f90:	01000484 	movi	r4,18
81105f94:	11378f80 	call	811378f8 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81105f98:	00002806 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81105f9c:	d0a04304 	addi	r2,gp,-32500
81105fa0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
81105fa4:	01a04434 	movhi	r6,33040
81105fa8:	31949004 	addi	r6,r6,21056
81105fac:	e17ffe17 	ldw	r5,-8(fp)
81105fb0:	01000404 	movi	r4,16
81105fb4:	11378f80 	call	811378f8 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
81105fb8:	00002006 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81105fbc:	d0a04404 	addi	r2,gp,-32496
81105fc0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
81105fc4:	01a04434 	movhi	r6,33040
81105fc8:	31949e04 	addi	r6,r6,21112
81105fcc:	e17ffe17 	ldw	r5,-8(fp)
81105fd0:	01000204 	movi	r4,8
81105fd4:	11378f80 	call	811378f8 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
81105fd8:	00001806 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81105fdc:	d0a04504 	addi	r2,gp,-32492
81105fe0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
81105fe4:	01a04434 	movhi	r6,33040
81105fe8:	3194ac04 	addi	r6,r6,21168
81105fec:	e17ffe17 	ldw	r5,-8(fp)
81105ff0:	01000184 	movi	r4,6
81105ff4:	11378f80 	call	811378f8 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
81105ff8:	00001006 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81105ffc:	d0a04604 	addi	r2,gp,-32488
81106000:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
81106004:	01a04434 	movhi	r6,33040
81106008:	3194ba04 	addi	r6,r6,21224
8110600c:	e17ffe17 	ldw	r5,-8(fp)
81106010:	01000144 	movi	r4,5
81106014:	11378f80 	call	811378f8 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81106018:	00000806 	br	8110603c <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
8110601c:	d0a04704 	addi	r2,gp,-32484
81106020:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
81106024:	01a04434 	movhi	r6,33040
81106028:	3194c804 	addi	r6,r6,21280
8110602c:	e17ffe17 	ldw	r5,-8(fp)
81106030:	01000084 	movi	r4,2
81106034:	11378f80 	call	811378f8 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
81106038:	0001883a 	nop
	}
}
8110603c:	0001883a 	nop
81106040:	e037883a 	mov	sp,fp
81106044:	dfc00117 	ldw	ra,4(sp)
81106048:	df000017 	ldw	fp,0(sp)
8110604c:	dec00204 	addi	sp,sp,8
81106050:	f800283a 	ret

81106054 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
81106054:	defffb04 	addi	sp,sp,-20
81106058:	de00012e 	bgeu	sp,et,81106060 <bFeebSetIrqControl+0xc>
8110605c:	003b68fa 	trap	3
81106060:	dfc00415 	stw	ra,16(sp)
81106064:	df000315 	stw	fp,12(sp)
81106068:	df000304 	addi	fp,sp,12
8110606c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106070:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106074:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106078:	e0bfff17 	ldw	r2,-4(fp)
8110607c:	10002426 	beq	r2,zero,81106110 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106080:	e0bfff17 	ldw	r2,-4(fp)
81106084:	10800017 	ldw	r2,0(r2)
81106088:	01400444 	movi	r5,17
8110608c:	1009883a 	mov	r4,r2
81106090:	1106b780 	call	81106b78 <uliFeebReadReg>
81106094:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
81106098:	e0bfff17 	ldw	r2,-4(fp)
8110609c:	10800217 	ldw	r2,8(r2)
811060a0:	10000426 	beq	r2,zero,811060b4 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
811060a4:	e0bffe17 	ldw	r2,-8(fp)
811060a8:	10808014 	ori	r2,r2,512
811060ac:	e0bffe15 	stw	r2,-8(fp)
811060b0:	00000406 	br	811060c4 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
811060b4:	e0fffe17 	ldw	r3,-8(fp)
811060b8:	00bf7fc4 	movi	r2,-513
811060bc:	1884703a 	and	r2,r3,r2
811060c0:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
811060c4:	e0bfff17 	ldw	r2,-4(fp)
811060c8:	10800317 	ldw	r2,12(r2)
811060cc:	10000426 	beq	r2,zero,811060e0 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
811060d0:	e0bffe17 	ldw	r2,-8(fp)
811060d4:	10804014 	ori	r2,r2,256
811060d8:	e0bffe15 	stw	r2,-8(fp)
811060dc:	00000406 	br	811060f0 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
811060e0:	e0fffe17 	ldw	r3,-8(fp)
811060e4:	00bfbfc4 	movi	r2,-257
811060e8:	1884703a 	and	r2,r3,r2
811060ec:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
811060f0:	e0bfff17 	ldw	r2,-4(fp)
811060f4:	10800017 	ldw	r2,0(r2)
811060f8:	e1bffe17 	ldw	r6,-8(fp)
811060fc:	01400444 	movi	r5,17
81106100:	1009883a 	mov	r4,r2
81106104:	1106b240 	call	81106b24 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81106108:	00800044 	movi	r2,1
8110610c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106110:	e0bffd17 	ldw	r2,-12(fp)
}
81106114:	e037883a 	mov	sp,fp
81106118:	dfc00117 	ldw	ra,4(sp)
8110611c:	df000017 	ldw	fp,0(sp)
81106120:	dec00204 	addi	sp,sp,8
81106124:	f800283a 	ret

81106128 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81106128:	defffb04 	addi	sp,sp,-20
8110612c:	de00012e 	bgeu	sp,et,81106134 <bFeebGetIrqControl+0xc>
81106130:	003b68fa 	trap	3
81106134:	dfc00415 	stw	ra,16(sp)
81106138:	df000315 	stw	fp,12(sp)
8110613c:	df000304 	addi	fp,sp,12
81106140:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106144:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106148:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110614c:	e0bfff17 	ldw	r2,-4(fp)
81106150:	10001a26 	beq	r2,zero,811061bc <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106154:	e0bfff17 	ldw	r2,-4(fp)
81106158:	10800017 	ldw	r2,0(r2)
8110615c:	01400444 	movi	r5,17
81106160:	1009883a 	mov	r4,r2
81106164:	1106b780 	call	81106b78 <uliFeebReadReg>
81106168:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
8110616c:	e0bffe17 	ldw	r2,-8(fp)
81106170:	1080800c 	andi	r2,r2,512
81106174:	10000426 	beq	r2,zero,81106188 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81106178:	e0bfff17 	ldw	r2,-4(fp)
8110617c:	00c00044 	movi	r3,1
81106180:	10c00215 	stw	r3,8(r2)
81106184:	00000206 	br	81106190 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81106188:	e0bfff17 	ldw	r2,-4(fp)
8110618c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
81106190:	e0bffe17 	ldw	r2,-8(fp)
81106194:	1080400c 	andi	r2,r2,256
81106198:	10000426 	beq	r2,zero,811061ac <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8110619c:	e0bfff17 	ldw	r2,-4(fp)
811061a0:	00c00044 	movi	r3,1
811061a4:	10c00315 	stw	r3,12(r2)
811061a8:	00000206 	br	811061b4 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
811061ac:	e0bfff17 	ldw	r2,-4(fp)
811061b0:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
811061b4:	00800044 	movi	r2,1
811061b8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811061bc:	e0bffd17 	ldw	r2,-12(fp)
}
811061c0:	e037883a 	mov	sp,fp
811061c4:	dfc00117 	ldw	ra,4(sp)
811061c8:	df000017 	ldw	fp,0(sp)
811061cc:	dec00204 	addi	sp,sp,8
811061d0:	f800283a 	ret

811061d4 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
811061d4:	defffb04 	addi	sp,sp,-20
811061d8:	de00012e 	bgeu	sp,et,811061e0 <bFeebGetIrqFlags+0xc>
811061dc:	003b68fa 	trap	3
811061e0:	dfc00415 	stw	ra,16(sp)
811061e4:	df000315 	stw	fp,12(sp)
811061e8:	df000304 	addi	fp,sp,12
811061ec:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811061f0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811061f4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811061f8:	e0bfff17 	ldw	r2,-4(fp)
811061fc:	10001126 	beq	r2,zero,81106244 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106200:	e0bfff17 	ldw	r2,-4(fp)
81106204:	10800017 	ldw	r2,0(r2)
81106208:	01400484 	movi	r5,18
8110620c:	1009883a 	mov	r4,r2
81106210:	1106b780 	call	81106b78 <uliFeebReadReg>
81106214:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81106218:	e0bffe17 	ldw	r2,-8(fp)
8110621c:	1080400c 	andi	r2,r2,256
81106220:	10000426 	beq	r2,zero,81106234 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81106224:	e0bfff17 	ldw	r2,-4(fp)
81106228:	00c00044 	movi	r3,1
8110622c:	10c00415 	stw	r3,16(r2)
81106230:	00000206 	br	8110623c <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81106234:	e0bfff17 	ldw	r2,-4(fp)
81106238:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
8110623c:	00800044 	movi	r2,1
81106240:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106244:	e0bffd17 	ldw	r2,-12(fp)
}
81106248:	e037883a 	mov	sp,fp
8110624c:	dfc00117 	ldw	ra,4(sp)
81106250:	df000017 	ldw	fp,0(sp)
81106254:	dec00204 	addi	sp,sp,8
81106258:	f800283a 	ret

8110625c <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
8110625c:	defffb04 	addi	sp,sp,-20
81106260:	de00012e 	bgeu	sp,et,81106268 <bFeebGetBuffersStatus+0xc>
81106264:	003b68fa 	trap	3
81106268:	dfc00415 	stw	ra,16(sp)
8110626c:	df000315 	stw	fp,12(sp)
81106270:	df000304 	addi	fp,sp,12
81106274:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106278:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110627c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106280:	e0bfff17 	ldw	r2,-4(fp)
81106284:	10003226 	beq	r2,zero,81106350 <bFeebGetBuffersStatus+0xf4>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106288:	e0bfff17 	ldw	r2,-4(fp)
8110628c:	10800017 	ldw	r2,0(r2)
81106290:	014000c4 	movi	r5,3
81106294:	1009883a 	mov	r4,r2
81106298:	1106b780 	call	81106b78 <uliFeebReadReg>
8110629c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811062a0:	e0bffe17 	ldw	r2,-8(fp)
811062a4:	1080008c 	andi	r2,r2,2
811062a8:	10000426 	beq	r2,zero,811062bc <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
811062ac:	e0bfff17 	ldw	r2,-4(fp)
811062b0:	00c00044 	movi	r3,1
811062b4:	10c00515 	stw	r3,20(r2)
811062b8:	00000206 	br	811062c4 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
811062bc:	e0bfff17 	ldw	r2,-4(fp)
811062c0:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811062c4:	e0bffe17 	ldw	r2,-8(fp)
811062c8:	1080004c 	andi	r2,r2,1
811062cc:	10000426 	beq	r2,zero,811062e0 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
811062d0:	e0bfff17 	ldw	r2,-4(fp)
811062d4:	00c00044 	movi	r3,1
811062d8:	10c00615 	stw	r3,24(r2)
811062dc:	00000206 	br	811062e8 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
811062e0:	e0bfff17 	ldw	r2,-4(fp)
811062e4:	10000615 	stw	zero,24(r2)
		}

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811062e8:	e0bfff17 	ldw	r2,-4(fp)
811062ec:	10800017 	ldw	r2,0(r2)
811062f0:	01400504 	movi	r5,20
811062f4:	1009883a 	mov	r4,r2
811062f8:	1106b780 	call	81106b78 <uliFeebReadReg>
811062fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RIGT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81106300:	e0bffe17 	ldw	r2,-8(fp)
81106304:	108003cc 	andi	r2,r2,15
81106308:	10800044 	addi	r2,r2,1
8110630c:	1007883a 	mov	r3,r2
81106310:	e0bfff17 	ldw	r2,-4(fp)
81106314:	10c00745 	stb	r3,29(r2)
				& COMM_RIGT_FEEBUFF_SIZE_MSK) + 1;

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106318:	e0bfff17 	ldw	r2,-4(fp)
8110631c:	10800017 	ldw	r2,0(r2)
81106320:	01400544 	movi	r5,21
81106324:	1009883a 	mov	r4,r2
81106328:	1106b780 	call	81106b78 <uliFeebReadReg>
8110632c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LEFT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81106330:	e0bffe17 	ldw	r2,-8(fp)
81106334:	108003cc 	andi	r2,r2,15
81106338:	10800044 	addi	r2,r2,1
8110633c:	1007883a 	mov	r3,r2
81106340:	e0bfff17 	ldw	r2,-4(fp)
81106344:	10c00745 	stb	r3,29(r2)
				& COMM_LEFT_FEEBUFF_SIZE_MSK) + 1;

		bStatus = TRUE;
81106348:	00800044 	movi	r2,1
8110634c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106350:	e0bffd17 	ldw	r2,-12(fp)
}
81106354:	e037883a 	mov	sp,fp
81106358:	dfc00117 	ldw	ra,4(sp)
8110635c:	df000017 	ldw	fp,0(sp)
81106360:	dec00204 	addi	sp,sp,8
81106364:	f800283a 	ret

81106368 <bFeebGetLeftBufferEmpty>:

bool bFeebGetLeftBufferEmpty(TFeebChannel *pxFeebCh){
81106368:	defffb04 	addi	sp,sp,-20
8110636c:	de00012e 	bgeu	sp,et,81106374 <bFeebGetLeftBufferEmpty+0xc>
81106370:	003b68fa 	trap	3
81106374:	dfc00415 	stw	ra,16(sp)
81106378:	df000315 	stw	fp,12(sp)
8110637c:	df000304 	addi	fp,sp,12
81106380:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
81106384:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106388:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110638c:	e0bfff17 	ldw	r2,-4(fp)
81106390:	10000d26 	beq	r2,zero,811063c8 <bFeebGetLeftBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106394:	e0bfff17 	ldw	r2,-4(fp)
81106398:	10800017 	ldw	r2,0(r2)
8110639c:	014000c4 	movi	r5,3
811063a0:	1009883a 	mov	r4,r2
811063a4:	1106b780 	call	81106b78 <uliFeebReadReg>
811063a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811063ac:	e0bffe17 	ldw	r2,-8(fp)
811063b0:	1080008c 	andi	r2,r2,2
811063b4:	10000326 	beq	r2,zero,811063c4 <bFeebGetLeftBufferEmpty+0x5c>
			bFlag = TRUE;
811063b8:	00800044 	movi	r2,1
811063bc:	e0bffd15 	stw	r2,-12(fp)
811063c0:	00000106 	br	811063c8 <bFeebGetLeftBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
811063c4:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
811063c8:	e0bffd17 	ldw	r2,-12(fp)
}
811063cc:	e037883a 	mov	sp,fp
811063d0:	dfc00117 	ldw	ra,4(sp)
811063d4:	df000017 	ldw	fp,0(sp)
811063d8:	dec00204 	addi	sp,sp,8
811063dc:	f800283a 	ret

811063e0 <bFeebGetRightBufferEmpty>:

bool bFeebGetRightBufferEmpty(TFeebChannel *pxFeebCh){
811063e0:	defffb04 	addi	sp,sp,-20
811063e4:	de00012e 	bgeu	sp,et,811063ec <bFeebGetRightBufferEmpty+0xc>
811063e8:	003b68fa 	trap	3
811063ec:	dfc00415 	stw	ra,16(sp)
811063f0:	df000315 	stw	fp,12(sp)
811063f4:	df000304 	addi	fp,sp,12
811063f8:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
811063fc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106400:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106404:	e0bfff17 	ldw	r2,-4(fp)
81106408:	10000d26 	beq	r2,zero,81106440 <bFeebGetRightBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110640c:	e0bfff17 	ldw	r2,-4(fp)
81106410:	10800017 	ldw	r2,0(r2)
81106414:	014000c4 	movi	r5,3
81106418:	1009883a 	mov	r4,r2
8110641c:	1106b780 	call	81106b78 <uliFeebReadReg>
81106420:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106424:	e0bffe17 	ldw	r2,-8(fp)
81106428:	1080004c 	andi	r2,r2,1
8110642c:	10000326 	beq	r2,zero,8110643c <bFeebGetRightBufferEmpty+0x5c>
			bFlag = TRUE;
81106430:	00800044 	movi	r2,1
81106434:	e0bffd15 	stw	r2,-12(fp)
81106438:	00000106 	br	81106440 <bFeebGetRightBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
8110643c:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81106440:	e0bffd17 	ldw	r2,-12(fp)
}
81106444:	e037883a 	mov	sp,fp
81106448:	dfc00117 	ldw	ra,4(sp)
8110644c:	df000017 	ldw	fp,0(sp)
81106450:	dec00204 	addi	sp,sp,8
81106454:	f800283a 	ret

81106458 <bFeebGetCh1LeftBufferEmpty>:

bool bFeebGetCh1LeftBufferEmpty(void){
81106458:	defffc04 	addi	sp,sp,-16
8110645c:	de00012e 	bgeu	sp,et,81106464 <bFeebGetCh1LeftBufferEmpty+0xc>
81106460:	003b68fa 	trap	3
81106464:	dfc00315 	stw	ra,12(sp)
81106468:	df000215 	stw	fp,8(sp)
8110646c:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106470:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106474:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106478:	014000c4 	movi	r5,3
8110647c:	01204834 	movhi	r4,33056
81106480:	210b0004 	addi	r4,r4,11264
81106484:	1106b780 	call	81106b78 <uliFeebReadReg>
81106488:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110648c:	e0bfff17 	ldw	r2,-4(fp)
81106490:	1080008c 	andi	r2,r2,2
81106494:	10000326 	beq	r2,zero,811064a4 <bFeebGetCh1LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81106498:	00800044 	movi	r2,1
8110649c:	e0bffe15 	stw	r2,-8(fp)
811064a0:	00000106 	br	811064a8 <bFeebGetCh1LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811064a4:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811064a8:	e0bffe17 	ldw	r2,-8(fp)
}
811064ac:	e037883a 	mov	sp,fp
811064b0:	dfc00117 	ldw	ra,4(sp)
811064b4:	df000017 	ldw	fp,0(sp)
811064b8:	dec00204 	addi	sp,sp,8
811064bc:	f800283a 	ret

811064c0 <bFeebGetCh1RightBufferEmpty>:

bool bFeebGetCh1RightBufferEmpty(void){
811064c0:	defffc04 	addi	sp,sp,-16
811064c4:	de00012e 	bgeu	sp,et,811064cc <bFeebGetCh1RightBufferEmpty+0xc>
811064c8:	003b68fa 	trap	3
811064cc:	dfc00315 	stw	ra,12(sp)
811064d0:	df000215 	stw	fp,8(sp)
811064d4:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811064d8:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811064dc:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
811064e0:	014000c4 	movi	r5,3
811064e4:	01204834 	movhi	r4,33056
811064e8:	210b0004 	addi	r4,r4,11264
811064ec:	1106b780 	call	81106b78 <uliFeebReadReg>
811064f0:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811064f4:	e0bfff17 	ldw	r2,-4(fp)
811064f8:	1080004c 	andi	r2,r2,1
811064fc:	10000326 	beq	r2,zero,8110650c <bFeebGetCh1RightBufferEmpty+0x4c>
			bFlag = TRUE;
81106500:	00800044 	movi	r2,1
81106504:	e0bffe15 	stw	r2,-8(fp)
81106508:	00000106 	br	81106510 <bFeebGetCh1RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
8110650c:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106510:	e0bffe17 	ldw	r2,-8(fp)
}
81106514:	e037883a 	mov	sp,fp
81106518:	dfc00117 	ldw	ra,4(sp)
8110651c:	df000017 	ldw	fp,0(sp)
81106520:	dec00204 	addi	sp,sp,8
81106524:	f800283a 	ret

81106528 <bFeebGetCh2LeftBufferEmpty>:

bool bFeebGetCh2LeftBufferEmpty(void){
81106528:	defffc04 	addi	sp,sp,-16
8110652c:	de00012e 	bgeu	sp,et,81106534 <bFeebGetCh2LeftBufferEmpty+0xc>
81106530:	003b68fa 	trap	3
81106534:	dfc00315 	stw	ra,12(sp)
81106538:	df000215 	stw	fp,8(sp)
8110653c:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106540:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106544:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106548:	014000c4 	movi	r5,3
8110654c:	01204834 	movhi	r4,33056
81106550:	210a0004 	addi	r4,r4,10240
81106554:	1106b780 	call	81106b78 <uliFeebReadReg>
81106558:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110655c:	e0bfff17 	ldw	r2,-4(fp)
81106560:	1080008c 	andi	r2,r2,2
81106564:	10000326 	beq	r2,zero,81106574 <bFeebGetCh2LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81106568:	00800044 	movi	r2,1
8110656c:	e0bffe15 	stw	r2,-8(fp)
81106570:	00000106 	br	81106578 <bFeebGetCh2LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106574:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106578:	e0bffe17 	ldw	r2,-8(fp)
}
8110657c:	e037883a 	mov	sp,fp
81106580:	dfc00117 	ldw	ra,4(sp)
81106584:	df000017 	ldw	fp,0(sp)
81106588:	dec00204 	addi	sp,sp,8
8110658c:	f800283a 	ret

81106590 <bFeebGetCh2RightBufferEmpty>:

bool bFeebGetCh2RightBufferEmpty(void){
81106590:	defffc04 	addi	sp,sp,-16
81106594:	de00012e 	bgeu	sp,et,8110659c <bFeebGetCh2RightBufferEmpty+0xc>
81106598:	003b68fa 	trap	3
8110659c:	dfc00315 	stw	ra,12(sp)
811065a0:	df000215 	stw	fp,8(sp)
811065a4:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811065a8:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811065ac:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
811065b0:	014000c4 	movi	r5,3
811065b4:	01204834 	movhi	r4,33056
811065b8:	210a0004 	addi	r4,r4,10240
811065bc:	1106b780 	call	81106b78 <uliFeebReadReg>
811065c0:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811065c4:	e0bfff17 	ldw	r2,-4(fp)
811065c8:	1080004c 	andi	r2,r2,1
811065cc:	10000326 	beq	r2,zero,811065dc <bFeebGetCh2RightBufferEmpty+0x4c>
			bFlag = TRUE;
811065d0:	00800044 	movi	r2,1
811065d4:	e0bffe15 	stw	r2,-8(fp)
811065d8:	00000106 	br	811065e0 <bFeebGetCh2RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811065dc:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811065e0:	e0bffe17 	ldw	r2,-8(fp)
}
811065e4:	e037883a 	mov	sp,fp
811065e8:	dfc00117 	ldw	ra,4(sp)
811065ec:	df000017 	ldw	fp,0(sp)
811065f0:	dec00204 	addi	sp,sp,8
811065f4:	f800283a 	ret

811065f8 <bFeebSetBufferSize>:

bool bFeebSetBufferSize(TFeebChannel *pxFeebCh, alt_u8 ucBufferSizeInBlocks,
		alt_u8 ucBufferSide) {
811065f8:	defff904 	addi	sp,sp,-28
811065fc:	de00012e 	bgeu	sp,et,81106604 <bFeebSetBufferSize+0xc>
81106600:	003b68fa 	trap	3
81106604:	dfc00615 	stw	ra,24(sp)
81106608:	df000515 	stw	fp,20(sp)
8110660c:	df000504 	addi	fp,sp,20
81106610:	e13ffd15 	stw	r4,-12(fp)
81106614:	2807883a 	mov	r3,r5
81106618:	3005883a 	mov	r2,r6
8110661c:	e0fffe05 	stb	r3,-8(fp)
81106620:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81106624:	00800044 	movi	r2,1
81106628:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
8110662c:	e03ffc15 	stw	zero,-16(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106630:	e0bffe03 	ldbu	r2,-8(fp)
81106634:	10002126 	beq	r2,zero,811066bc <bFeebSetBufferSize+0xc4>
81106638:	e0bffe03 	ldbu	r2,-8(fp)
8110663c:	10800468 	cmpgeui	r2,r2,17
81106640:	10001e1e 	bne	r2,zero,811066bc <bFeebSetBufferSize+0xc4>
		switch (ucBufferSide) {
81106644:	e0bfff03 	ldbu	r2,-4(fp)
81106648:	10000326 	beq	r2,zero,81106658 <bFeebSetBufferSize+0x60>
8110664c:	10800060 	cmpeqi	r2,r2,1
81106650:	10000c1e 	bne	r2,zero,81106684 <bFeebSetBufferSize+0x8c>
81106654:	00001606 	br	811066b0 <bFeebSetBufferSize+0xb8>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106658:	e0bffe03 	ldbu	r2,-8(fp)
8110665c:	10bfffc4 	addi	r2,r2,-1
81106660:	108003cc 	andi	r2,r2,15
81106664:	e0bffc15 	stw	r2,-16(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81106668:	e0bffd17 	ldw	r2,-12(fp)
8110666c:	10800017 	ldw	r2,0(r2)
81106670:	e1bffc17 	ldw	r6,-16(fp)
81106674:	01400544 	movi	r5,21
81106678:	1009883a 	mov	r4,r2
8110667c:	1106b240 	call	81106b24 <vFeebWriteReg>
					COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106680:	00000d06 	br	811066b8 <bFeebSetBufferSize+0xc0>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106684:	e0bffe03 	ldbu	r2,-8(fp)
81106688:	10bfffc4 	addi	r2,r2,-1
8110668c:	108003cc 	andi	r2,r2,15
81106690:	e0bffc15 	stw	r2,-16(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81106694:	e0bffd17 	ldw	r2,-12(fp)
81106698:	10800017 	ldw	r2,0(r2)
8110669c:	e1bffc17 	ldw	r6,-16(fp)
811066a0:	01400504 	movi	r5,20
811066a4:	1009883a 	mov	r4,r2
811066a8:	1106b240 	call	81106b24 <vFeebWriteReg>
					COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811066ac:	00000206 	br	811066b8 <bFeebSetBufferSize+0xc0>
		default:
			bStatus = FALSE;
811066b0:	e03ffb15 	stw	zero,-20(fp)
			break;
811066b4:	0001883a 	nop
		}
	} else {
811066b8:	00000106 	br	811066c0 <bFeebSetBufferSize+0xc8>
		bStatus = FALSE;
811066bc:	e03ffb15 	stw	zero,-20(fp)
	}

	return bStatus;
811066c0:	e0bffb17 	ldw	r2,-20(fp)
}
811066c4:	e037883a 	mov	sp,fp
811066c8:	dfc00117 	ldw	ra,4(sp)
811066cc:	df000017 	ldw	fp,0(sp)
811066d0:	dec00204 	addi	sp,sp,8
811066d4:	f800283a 	ret

811066d8 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
811066d8:	defffb04 	addi	sp,sp,-20
811066dc:	de00012e 	bgeu	sp,et,811066e4 <bFeebSetWindowing+0xc>
811066e0:	003b68fa 	trap	3
811066e4:	dfc00415 	stw	ra,16(sp)
811066e8:	df000315 	stw	fp,12(sp)
811066ec:	df000304 	addi	fp,sp,12
811066f0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811066f4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811066f8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811066fc:	e0bfff17 	ldw	r2,-4(fp)
81106700:	10001926 	beq	r2,zero,81106768 <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106704:	e0bfff17 	ldw	r2,-4(fp)
81106708:	10800017 	ldw	r2,0(r2)
8110670c:	01400084 	movi	r5,2
81106710:	1009883a 	mov	r4,r2
81106714:	1106b780 	call	81106b78 <uliFeebReadReg>
81106718:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
8110671c:	e0bfff17 	ldw	r2,-4(fp)
81106720:	10800117 	ldw	r2,4(r2)
81106724:	10000426 	beq	r2,zero,81106738 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81106728:	e0bffe17 	ldw	r2,-8(fp)
8110672c:	10800214 	ori	r2,r2,8
81106730:	e0bffe15 	stw	r2,-8(fp)
81106734:	00000406 	br	81106748 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
81106738:	e0fffe17 	ldw	r3,-8(fp)
8110673c:	00bffdc4 	movi	r2,-9
81106740:	1884703a 	and	r2,r3,r2
81106744:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106748:	e0bfff17 	ldw	r2,-4(fp)
8110674c:	10800017 	ldw	r2,0(r2)
81106750:	e1bffe17 	ldw	r6,-8(fp)
81106754:	01400084 	movi	r5,2
81106758:	1009883a 	mov	r4,r2
8110675c:	1106b240 	call	81106b24 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106760:	00800044 	movi	r2,1
81106764:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106768:	e0bffd17 	ldw	r2,-12(fp)
}
8110676c:	e037883a 	mov	sp,fp
81106770:	dfc00117 	ldw	ra,4(sp)
81106774:	df000017 	ldw	fp,0(sp)
81106778:	dec00204 	addi	sp,sp,8
8110677c:	f800283a 	ret

81106780 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81106780:	defffb04 	addi	sp,sp,-20
81106784:	de00012e 	bgeu	sp,et,8110678c <bFeebGetWindowing+0xc>
81106788:	003b68fa 	trap	3
8110678c:	dfc00415 	stw	ra,16(sp)
81106790:	df000315 	stw	fp,12(sp)
81106794:	df000304 	addi	fp,sp,12
81106798:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110679c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811067a0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811067a4:	e0bfff17 	ldw	r2,-4(fp)
811067a8:	10001126 	beq	r2,zero,811067f0 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811067ac:	e0bfff17 	ldw	r2,-4(fp)
811067b0:	10800017 	ldw	r2,0(r2)
811067b4:	01400084 	movi	r5,2
811067b8:	1009883a 	mov	r4,r2
811067bc:	1106b780 	call	81106b78 <uliFeebReadReg>
811067c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
811067c4:	e0bffe17 	ldw	r2,-8(fp)
811067c8:	1080020c 	andi	r2,r2,8
811067cc:	10000426 	beq	r2,zero,811067e0 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
811067d0:	e0bfff17 	ldw	r2,-4(fp)
811067d4:	00c00044 	movi	r3,1
811067d8:	10c00115 	stw	r3,4(r2)
811067dc:	00000206 	br	811067e8 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
811067e0:	e0bfff17 	ldw	r2,-4(fp)
811067e4:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
811067e8:	00800044 	movi	r2,1
811067ec:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811067f0:	e0bffd17 	ldw	r2,-12(fp)
}
811067f4:	e037883a 	mov	sp,fp
811067f8:	dfc00117 	ldw	ra,4(sp)
811067fc:	df000017 	ldw	fp,0(sp)
81106800:	dec00204 	addi	sp,sp,8
81106804:	f800283a 	ret

81106808 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81106808:	defffb04 	addi	sp,sp,-20
8110680c:	de00012e 	bgeu	sp,et,81106814 <bFeebStartCh+0xc>
81106810:	003b68fa 	trap	3
81106814:	dfc00415 	stw	ra,16(sp)
81106818:	df000315 	stw	fp,12(sp)
8110681c:	df000304 	addi	fp,sp,12
81106820:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106824:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106828:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110682c:	e0bfff17 	ldw	r2,-4(fp)
81106830:	10001126 	beq	r2,zero,81106878 <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106834:	e0bfff17 	ldw	r2,-4(fp)
81106838:	10800017 	ldw	r2,0(r2)
8110683c:	01400084 	movi	r5,2
81106840:	1009883a 	mov	r4,r2
81106844:	1106b780 	call	81106b78 <uliFeebReadReg>
81106848:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
8110684c:	e0bffe17 	ldw	r2,-8(fp)
81106850:	10800114 	ori	r2,r2,4
81106854:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106858:	e0bfff17 	ldw	r2,-4(fp)
8110685c:	10800017 	ldw	r2,0(r2)
81106860:	e1bffe17 	ldw	r6,-8(fp)
81106864:	01400084 	movi	r5,2
81106868:	1009883a 	mov	r4,r2
8110686c:	1106b240 	call	81106b24 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106870:	00800044 	movi	r2,1
81106874:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106878:	e0bffd17 	ldw	r2,-12(fp)
}
8110687c:	e037883a 	mov	sp,fp
81106880:	dfc00117 	ldw	ra,4(sp)
81106884:	df000017 	ldw	fp,0(sp)
81106888:	dec00204 	addi	sp,sp,8
8110688c:	f800283a 	ret

81106890 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
81106890:	defffb04 	addi	sp,sp,-20
81106894:	de00012e 	bgeu	sp,et,8110689c <bFeebStopCh+0xc>
81106898:	003b68fa 	trap	3
8110689c:	dfc00415 	stw	ra,16(sp)
811068a0:	df000315 	stw	fp,12(sp)
811068a4:	df000304 	addi	fp,sp,12
811068a8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811068ac:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811068b0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811068b4:	e0bfff17 	ldw	r2,-4(fp)
811068b8:	10001126 	beq	r2,zero,81106900 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811068bc:	e0bfff17 	ldw	r2,-4(fp)
811068c0:	10800017 	ldw	r2,0(r2)
811068c4:	01400084 	movi	r5,2
811068c8:	1009883a 	mov	r4,r2
811068cc:	1106b780 	call	81106b78 <uliFeebReadReg>
811068d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
811068d4:	e0bffe17 	ldw	r2,-8(fp)
811068d8:	10800094 	ori	r2,r2,2
811068dc:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811068e0:	e0bfff17 	ldw	r2,-4(fp)
811068e4:	10800017 	ldw	r2,0(r2)
811068e8:	e1bffe17 	ldw	r6,-8(fp)
811068ec:	01400084 	movi	r5,2
811068f0:	1009883a 	mov	r4,r2
811068f4:	1106b240 	call	81106b24 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811068f8:	00800044 	movi	r2,1
811068fc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106900:	e0bffd17 	ldw	r2,-12(fp)
}
81106904:	e037883a 	mov	sp,fp
81106908:	dfc00117 	ldw	ra,4(sp)
8110690c:	df000017 	ldw	fp,0(sp)
81106910:	dec00204 	addi	sp,sp,8
81106914:	f800283a 	ret

81106918 <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81106918:	defffb04 	addi	sp,sp,-20
8110691c:	de00012e 	bgeu	sp,et,81106924 <bFeebClrCh+0xc>
81106920:	003b68fa 	trap	3
81106924:	dfc00415 	stw	ra,16(sp)
81106928:	df000315 	stw	fp,12(sp)
8110692c:	df000304 	addi	fp,sp,12
81106930:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106934:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106938:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110693c:	e0bfff17 	ldw	r2,-4(fp)
81106940:	10001126 	beq	r2,zero,81106988 <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106944:	e0bfff17 	ldw	r2,-4(fp)
81106948:	10800017 	ldw	r2,0(r2)
8110694c:	01400084 	movi	r5,2
81106950:	1009883a 	mov	r4,r2
81106954:	1106b780 	call	81106b78 <uliFeebReadReg>
81106958:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
8110695c:	e0bffe17 	ldw	r2,-8(fp)
81106960:	10800054 	ori	r2,r2,1
81106964:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106968:	e0bfff17 	ldw	r2,-4(fp)
8110696c:	10800017 	ldw	r2,0(r2)
81106970:	e1bffe17 	ldw	r6,-8(fp)
81106974:	01400084 	movi	r5,2
81106978:	1009883a 	mov	r4,r2
8110697c:	1106b240 	call	81106b24 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106980:	00800044 	movi	r2,1
81106984:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106988:	e0bffd17 	ldw	r2,-12(fp)
}
8110698c:	e037883a 	mov	sp,fp
81106990:	dfc00117 	ldw	ra,4(sp)
81106994:	df000017 	ldw	fp,0(sp)
81106998:	dec00204 	addi	sp,sp,8
8110699c:	f800283a 	ret

811069a0 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
811069a0:	defffb04 	addi	sp,sp,-20
811069a4:	de00012e 	bgeu	sp,et,811069ac <bFeebInitCh+0xc>
811069a8:	003b68fa 	trap	3
811069ac:	dfc00415 	stw	ra,16(sp)
811069b0:	df000315 	stw	fp,12(sp)
811069b4:	df000304 	addi	fp,sp,12
811069b8:	e13ffe15 	stw	r4,-8(fp)
811069bc:	2805883a 	mov	r2,r5
811069c0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
811069c4:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
811069c8:	e0bffe17 	ldw	r2,-8(fp)
811069cc:	10004f26 	beq	r2,zero,81106b0c <bFeebInitCh+0x16c>
		bStatus = TRUE;
811069d0:	00800044 	movi	r2,1
811069d4:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
811069d8:	e0bfff03 	ldbu	r2,-4(fp)
811069dc:	10c00228 	cmpgeui	r3,r2,8
811069e0:	1800361e 	bne	r3,zero,81106abc <bFeebInitCh+0x11c>
811069e4:	100690ba 	slli	r3,r2,2
811069e8:	00a04434 	movhi	r2,33040
811069ec:	109a7f04 	addi	r2,r2,27132
811069f0:	1885883a 	add	r2,r3,r2
811069f4:	10800017 	ldw	r2,0(r2)
811069f8:	1000683a 	jmp	r2
811069fc:	81106a1c 	xori	r4,r16,16808
81106a00:	81106a30 	cmpltui	r4,r16,16808
81106a04:	81106a44 	addi	r4,r16,16809
81106a08:	81106a58 	cmpnei	r4,r16,16809
81106a0c:	81106a6c 	andhi	r4,r16,16809
81106a10:	81106a80 	call	881106a8 <__reset+0x20f06a8>
81106a14:	81106a94 	ori	r4,r16,16810
81106a18:	81106aa8 	cmpgeui	r4,r16,16810
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81106a1c:	e0fffe17 	ldw	r3,-8(fp)
81106a20:	00a04834 	movhi	r2,33056
81106a24:	108b0004 	addi	r2,r2,11264
81106a28:	18800015 	stw	r2,0(r3)
			break;
81106a2c:	00002506 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81106a30:	e0fffe17 	ldw	r3,-8(fp)
81106a34:	00a04834 	movhi	r2,33056
81106a38:	108a0004 	addi	r2,r2,10240
81106a3c:	18800015 	stw	r2,0(r3)
			break;
81106a40:	00002006 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81106a44:	e0fffe17 	ldw	r3,-8(fp)
81106a48:	00a04834 	movhi	r2,33056
81106a4c:	108b0004 	addi	r2,r2,11264
81106a50:	18800015 	stw	r2,0(r3)
			break;
81106a54:	00001b06 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81106a58:	e0fffe17 	ldw	r3,-8(fp)
81106a5c:	00a04834 	movhi	r2,33056
81106a60:	108a0004 	addi	r2,r2,10240
81106a64:	18800015 	stw	r2,0(r3)
			break;
81106a68:	00001606 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81106a6c:	e0fffe17 	ldw	r3,-8(fp)
81106a70:	00a04834 	movhi	r2,33056
81106a74:	108b0004 	addi	r2,r2,11264
81106a78:	18800015 	stw	r2,0(r3)
			break;
81106a7c:	00001106 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81106a80:	e0fffe17 	ldw	r3,-8(fp)
81106a84:	00a04834 	movhi	r2,33056
81106a88:	108a0004 	addi	r2,r2,10240
81106a8c:	18800015 	stw	r2,0(r3)
			break;
81106a90:	00000c06 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81106a94:	e0fffe17 	ldw	r3,-8(fp)
81106a98:	00a04834 	movhi	r2,33056
81106a9c:	108b0004 	addi	r2,r2,11264
81106aa0:	18800015 	stw	r2,0(r3)
			break;
81106aa4:	00000706 	br	81106ac4 <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81106aa8:	e0fffe17 	ldw	r3,-8(fp)
81106aac:	00a04834 	movhi	r2,33056
81106ab0:	108a0004 	addi	r2,r2,10240
81106ab4:	18800015 	stw	r2,0(r3)
			break;
81106ab8:	00000206 	br	81106ac4 <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81106abc:	e03ffd15 	stw	zero,-12(fp)
			break;
81106ac0:	0001883a 	nop
		}

		if (bStatus) {
81106ac4:	e0bffd17 	ldw	r2,-12(fp)
81106ac8:	10001026 	beq	r2,zero,81106b0c <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81106acc:	e13ffe17 	ldw	r4,-8(fp)
81106ad0:	11061280 	call	81106128 <bFeebGetIrqControl>
81106ad4:	1000011e 	bne	r2,zero,81106adc <bFeebInitCh+0x13c>
				bStatus = FALSE;
81106ad8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81106adc:	e13ffe17 	ldw	r4,-8(fp)
81106ae0:	11061d40 	call	811061d4 <bFeebGetIrqFlags>
81106ae4:	1000011e 	bne	r2,zero,81106aec <bFeebInitCh+0x14c>
				bStatus = FALSE;
81106ae8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81106aec:	e13ffe17 	ldw	r4,-8(fp)
81106af0:	110625c0 	call	8110625c <bFeebGetBuffersStatus>
81106af4:	1000011e 	bne	r2,zero,81106afc <bFeebInitCh+0x15c>
				bStatus = FALSE;
81106af8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81106afc:	e13ffe17 	ldw	r4,-8(fp)
81106b00:	11067800 	call	81106780 <bFeebGetWindowing>
81106b04:	1000011e 	bne	r2,zero,81106b0c <bFeebInitCh+0x16c>
				bStatus = FALSE;
81106b08:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81106b0c:	e0bffd17 	ldw	r2,-12(fp)
}
81106b10:	e037883a 	mov	sp,fp
81106b14:	dfc00117 	ldw	ra,4(sp)
81106b18:	df000017 	ldw	fp,0(sp)
81106b1c:	dec00204 	addi	sp,sp,8
81106b20:	f800283a 	ret

81106b24 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81106b24:	defffc04 	addi	sp,sp,-16
81106b28:	de00012e 	bgeu	sp,et,81106b30 <vFeebWriteReg+0xc>
81106b2c:	003b68fa 	trap	3
81106b30:	df000315 	stw	fp,12(sp)
81106b34:	df000304 	addi	fp,sp,12
81106b38:	e13ffd15 	stw	r4,-12(fp)
81106b3c:	e17ffe15 	stw	r5,-8(fp)
81106b40:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81106b44:	e0bffe17 	ldw	r2,-8(fp)
81106b48:	1085883a 	add	r2,r2,r2
81106b4c:	1085883a 	add	r2,r2,r2
81106b50:	1007883a 	mov	r3,r2
81106b54:	e0bffd17 	ldw	r2,-12(fp)
81106b58:	10c5883a 	add	r2,r2,r3
81106b5c:	e0ffff17 	ldw	r3,-4(fp)
81106b60:	10c00015 	stw	r3,0(r2)
}
81106b64:	0001883a 	nop
81106b68:	e037883a 	mov	sp,fp
81106b6c:	df000017 	ldw	fp,0(sp)
81106b70:	dec00104 	addi	sp,sp,4
81106b74:	f800283a 	ret

81106b78 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81106b78:	defffc04 	addi	sp,sp,-16
81106b7c:	de00012e 	bgeu	sp,et,81106b84 <uliFeebReadReg+0xc>
81106b80:	003b68fa 	trap	3
81106b84:	df000315 	stw	fp,12(sp)
81106b88:	df000304 	addi	fp,sp,12
81106b8c:	e13ffe15 	stw	r4,-8(fp)
81106b90:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81106b94:	e0bfff17 	ldw	r2,-4(fp)
81106b98:	1085883a 	add	r2,r2,r2
81106b9c:	1085883a 	add	r2,r2,r2
81106ba0:	1007883a 	mov	r3,r2
81106ba4:	e0bffe17 	ldw	r2,-8(fp)
81106ba8:	10c5883a 	add	r2,r2,r3
81106bac:	10800017 	ldw	r2,0(r2)
81106bb0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81106bb4:	e0bffd17 	ldw	r2,-12(fp)
}
81106bb8:	e037883a 	mov	sp,fp
81106bbc:	df000017 	ldw	fp,0(sp)
81106bc0:	dec00104 	addi	sp,sp,4
81106bc4:	f800283a 	ret

81106bc8 <vRmapCh1HandleIrq>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
/* todo:Trigger not working right */
void vRmapCh1HandleIrq(void* pvContext) {
81106bc8:	defffb04 	addi	sp,sp,-20
81106bcc:	de00012e 	bgeu	sp,et,81106bd4 <vRmapCh1HandleIrq+0xc>
81106bd0:	003b68fa 	trap	3
81106bd4:	dfc00415 	stw	ra,16(sp)
81106bd8:	df000315 	stw	fp,12(sp)
81106bdc:	df000304 	addi	fp,sp,12
81106be0:	e13fff15 	stw	r4,-4(fp)
	INT8U error_codel;

	/* Warnning simplification: For now all address is lower than 1 bytes  */

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81106be4:	00a045b4 	movhi	r2,33046
81106be8:	109fe204 	addi	r2,r2,32648
81106bec:	10800d8b 	ldhu	r2,54(r2)
81106bf0:	10bfffcc 	andi	r2,r2,65535
81106bf4:	108000e8 	cmpgeui	r2,r2,3
81106bf8:	1000071e 	bne	r2,zero,81106c18 <vRmapCh1HandleIrq+0x50>
		fprintf(fp,"IRQ RMAP.\n");
81106bfc:	d0a06217 	ldw	r2,-32376(gp)
81106c00:	100f883a 	mov	r7,r2
81106c04:	01800284 	movi	r6,10
81106c08:	01400044 	movi	r5,1
81106c0c:	01204574 	movhi	r4,33045
81106c10:	2135c204 	addi	r4,r4,-10488
81106c14:	1122fc80 	call	81122fc8 <fwrite>
	}
#endif

	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
81106c18:	11073d00 	call	811073d0 <uliRmapCh1WriteCmdAddress>
81106c1c:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81106c20:	00800444 	movi	r2,17
81106c24:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81106c28:	00bffc04 	movi	r2,-16
81106c2c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81106c30:	e0bffd03 	ldbu	r2,-12(fp)
81106c34:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
81106c38:	e03ffe05 	stb	zero,-8(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81106c3c:	00a045b4 	movhi	r2,33046
81106c40:	109fe204 	addi	r2,r2,32648
81106c44:	10800d8b 	ldhu	r2,54(r2)
81106c48:	10bfffcc 	andi	r2,r2,65535
81106c4c:	108000e8 	cmpgeui	r2,r2,3
81106c50:	1000071e 	bne	r2,zero,81106c70 <vRmapCh1HandleIrq+0xa8>
		fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81106c54:	d0a06217 	ldw	r2,-32376(gp)
81106c58:	e0fffd03 	ldbu	r3,-12(fp)
81106c5c:	180d883a 	mov	r6,r3
81106c60:	01604574 	movhi	r5,33045
81106c64:	2975c504 	addi	r5,r5,-10476
81106c68:	1009883a 	mov	r4,r2
81106c6c:	112292c0 	call	8112292c <fprintf>
	}
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
81106c70:	d0a06a17 	ldw	r2,-32344(gp)
81106c74:	e0fffe17 	ldw	r3,-8(fp)
81106c78:	180b883a 	mov	r5,r3
81106c7c:	1009883a 	mov	r4,r2
81106c80:	113f44c0 	call	8113f44c <OSQPostFront>
81106c84:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81106c88:	e0bffd43 	ldbu	r2,-11(fp)
81106c8c:	10000226 	beq	r2,zero,81106c98 <vRmapCh1HandleIrq+0xd0>
		vFailSendRMAPFromIRQ( 0 );
81106c90:	0009883a 	mov	r4,zero
81106c94:	111e7ac0 	call	8111e7ac <vFailSendRMAPFromIRQ>
	}

	vRmapCh1IrqFlagClrWriteCmd();
81106c98:	1106ef00 	call	81106ef0 <vRmapCh1IrqFlagClrWriteCmd>
}
81106c9c:	0001883a 	nop
81106ca0:	e037883a 	mov	sp,fp
81106ca4:	dfc00117 	ldw	ra,4(sp)
81106ca8:	df000017 	ldw	fp,0(sp)
81106cac:	dec00204 	addi	sp,sp,8
81106cb0:	f800283a 	ret

81106cb4 <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81106cb4:	defffb04 	addi	sp,sp,-20
81106cb8:	de00012e 	bgeu	sp,et,81106cc0 <vRmapCh2HandleIrq+0xc>
81106cbc:	003b68fa 	trap	3
81106cc0:	dfc00415 	stw	ra,16(sp)
81106cc4:	df000315 	stw	fp,12(sp)
81106cc8:	df000304 	addi	fp,sp,12
81106ccc:	e13fff15 	stw	r4,-4(fp)
	INT8U ucADDRReg;
	INT8U error_codel;


#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81106cd0:	00a045b4 	movhi	r2,33046
81106cd4:	109fe204 	addi	r2,r2,32648
81106cd8:	10800d8b 	ldhu	r2,54(r2)
81106cdc:	10bfffcc 	andi	r2,r2,65535
81106ce0:	108000e8 	cmpgeui	r2,r2,3
81106ce4:	1000071e 	bne	r2,zero,81106d04 <vRmapCh2HandleIrq+0x50>
		fprintf(fp,"IRQ RMAP.\n");
81106ce8:	d0a06217 	ldw	r2,-32376(gp)
81106cec:	100f883a 	mov	r7,r2
81106cf0:	01800284 	movi	r6,10
81106cf4:	01400044 	movi	r5,1
81106cf8:	01204574 	movhi	r4,33045
81106cfc:	2135c204 	addi	r4,r4,-10488
81106d00:	1122fc80 	call	81122fc8 <fwrite>
	}
#endif

	ucADDRReg = (unsigned char)uliRmapCh2WriteCmdAddress();
81106d04:	11074200 	call	81107420 <uliRmapCh2WriteCmdAddress>
81106d08:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81106d0c:	00800444 	movi	r2,17
81106d10:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81106d14:	00bffc04 	movi	r2,-16
81106d18:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81106d1c:	e0bffd03 	ldbu	r2,-12(fp)
81106d20:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
81106d24:	e03ffe05 	stb	zero,-8(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81106d28:	00a045b4 	movhi	r2,33046
81106d2c:	109fe204 	addi	r2,r2,32648
81106d30:	10800d8b 	ldhu	r2,54(r2)
81106d34:	10bfffcc 	andi	r2,r2,65535
81106d38:	108000e8 	cmpgeui	r2,r2,3
81106d3c:	1000071e 	bne	r2,zero,81106d5c <vRmapCh2HandleIrq+0xa8>
		fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81106d40:	d0a06217 	ldw	r2,-32376(gp)
81106d44:	e0fffd03 	ldbu	r3,-12(fp)
81106d48:	180d883a 	mov	r6,r3
81106d4c:	01604574 	movhi	r5,33045
81106d50:	2975c504 	addi	r5,r5,-10476
81106d54:	1009883a 	mov	r4,r2
81106d58:	112292c0 	call	8112292c <fprintf>
	}
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
81106d5c:	d0a06a17 	ldw	r2,-32344(gp)
81106d60:	e0fffe17 	ldw	r3,-8(fp)
81106d64:	180b883a 	mov	r5,r3
81106d68:	1009883a 	mov	r4,r2
81106d6c:	113f44c0 	call	8113f44c <OSQPostFront>
81106d70:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81106d74:	e0bffd43 	ldbu	r2,-11(fp)
81106d78:	10000226 	beq	r2,zero,81106d84 <vRmapCh2HandleIrq+0xd0>
		vFailSendRMAPFromIRQ( 0 );
81106d7c:	0009883a 	mov	r4,zero
81106d80:	111e7ac0 	call	8111e7ac <vFailSendRMAPFromIRQ>
	}


	vRmapCh2IrqFlagClrWriteCmd();
81106d84:	1106f340 	call	81106f34 <vRmapCh2IrqFlagClrWriteCmd>
}
81106d88:	0001883a 	nop
81106d8c:	e037883a 	mov	sp,fp
81106d90:	dfc00117 	ldw	ra,4(sp)
81106d94:	df000017 	ldw	fp,0(sp)
81106d98:	dec00204 	addi	sp,sp,8
81106d9c:	f800283a 	ret

81106da0 <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81106da0:	defffd04 	addi	sp,sp,-12
81106da4:	de00012e 	bgeu	sp,et,81106dac <vRmapCh3HandleIrq+0xc>
81106da8:	003b68fa 	trap	3
81106dac:	dfc00215 	stw	ra,8(sp)
81106db0:	df000115 	stw	fp,4(sp)
81106db4:	df000104 	addi	fp,sp,4
81106db8:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81106dbc:	1106f780 	call	81106f78 <vRmapCh3IrqFlagClrWriteCmd>
}
81106dc0:	0001883a 	nop
81106dc4:	e037883a 	mov	sp,fp
81106dc8:	dfc00117 	ldw	ra,4(sp)
81106dcc:	df000017 	ldw	fp,0(sp)
81106dd0:	dec00204 	addi	sp,sp,8
81106dd4:	f800283a 	ret

81106dd8 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
81106dd8:	defffd04 	addi	sp,sp,-12
81106ddc:	de00012e 	bgeu	sp,et,81106de4 <vRmapCh4HandleIrq+0xc>
81106de0:	003b68fa 	trap	3
81106de4:	dfc00215 	stw	ra,8(sp)
81106de8:	df000115 	stw	fp,4(sp)
81106dec:	df000104 	addi	fp,sp,4
81106df0:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
81106df4:	1106fbc0 	call	81106fbc <vRmapCh4IrqFlagClrWriteCmd>
}
81106df8:	0001883a 	nop
81106dfc:	e037883a 	mov	sp,fp
81106e00:	dfc00117 	ldw	ra,4(sp)
81106e04:	df000017 	ldw	fp,0(sp)
81106e08:	dec00204 	addi	sp,sp,8
81106e0c:	f800283a 	ret

81106e10 <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
81106e10:	defffd04 	addi	sp,sp,-12
81106e14:	de00012e 	bgeu	sp,et,81106e1c <vRmapCh5HandleIrq+0xc>
81106e18:	003b68fa 	trap	3
81106e1c:	dfc00215 	stw	ra,8(sp)
81106e20:	df000115 	stw	fp,4(sp)
81106e24:	df000104 	addi	fp,sp,4
81106e28:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
81106e2c:	11070000 	call	81107000 <vRmapCh5IrqFlagClrWriteCmd>
}
81106e30:	0001883a 	nop
81106e34:	e037883a 	mov	sp,fp
81106e38:	dfc00117 	ldw	ra,4(sp)
81106e3c:	df000017 	ldw	fp,0(sp)
81106e40:	dec00204 	addi	sp,sp,8
81106e44:	f800283a 	ret

81106e48 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
81106e48:	defffd04 	addi	sp,sp,-12
81106e4c:	de00012e 	bgeu	sp,et,81106e54 <vRmapCh6HandleIrq+0xc>
81106e50:	003b68fa 	trap	3
81106e54:	dfc00215 	stw	ra,8(sp)
81106e58:	df000115 	stw	fp,4(sp)
81106e5c:	df000104 	addi	fp,sp,4
81106e60:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
81106e64:	11070440 	call	81107044 <vRmapCh6IrqFlagClrWriteCmd>
}
81106e68:	0001883a 	nop
81106e6c:	e037883a 	mov	sp,fp
81106e70:	dfc00117 	ldw	ra,4(sp)
81106e74:	df000017 	ldw	fp,0(sp)
81106e78:	dec00204 	addi	sp,sp,8
81106e7c:	f800283a 	ret

81106e80 <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
81106e80:	defffd04 	addi	sp,sp,-12
81106e84:	de00012e 	bgeu	sp,et,81106e8c <vRmapCh7HandleIrq+0xc>
81106e88:	003b68fa 	trap	3
81106e8c:	dfc00215 	stw	ra,8(sp)
81106e90:	df000115 	stw	fp,4(sp)
81106e94:	df000104 	addi	fp,sp,4
81106e98:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81106e9c:	11070880 	call	81107088 <vRmapCh7IrqFlagClrWriteCmd>
}
81106ea0:	0001883a 	nop
81106ea4:	e037883a 	mov	sp,fp
81106ea8:	dfc00117 	ldw	ra,4(sp)
81106eac:	df000017 	ldw	fp,0(sp)
81106eb0:	dec00204 	addi	sp,sp,8
81106eb4:	f800283a 	ret

81106eb8 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81106eb8:	defffd04 	addi	sp,sp,-12
81106ebc:	de00012e 	bgeu	sp,et,81106ec4 <vRmapCh8HandleIrq+0xc>
81106ec0:	003b68fa 	trap	3
81106ec4:	dfc00215 	stw	ra,8(sp)
81106ec8:	df000115 	stw	fp,4(sp)
81106ecc:	df000104 	addi	fp,sp,4
81106ed0:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81106ed4:	11070cc0 	call	811070cc <vRmapCh8IrqFlagClrWriteCmd>
}
81106ed8:	0001883a 	nop
81106edc:	e037883a 	mov	sp,fp
81106ee0:	dfc00117 	ldw	ra,4(sp)
81106ee4:	df000017 	ldw	fp,0(sp)
81106ee8:	dec00204 	addi	sp,sp,8
81106eec:	f800283a 	ret

81106ef0 <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
81106ef0:	defffe04 	addi	sp,sp,-8
81106ef4:	de00012e 	bgeu	sp,et,81106efc <vRmapCh1IrqFlagClrWriteCmd+0xc>
81106ef8:	003b68fa 	trap	3
81106efc:	dfc00115 	stw	ra,4(sp)
81106f00:	df000015 	stw	fp,0(sp)
81106f04:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106f08:	01800044 	movi	r6,1
81106f0c:	014004c4 	movi	r5,19
81106f10:	01204834 	movhi	r4,33056
81106f14:	210b0004 	addi	r4,r4,11264
81106f18:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106f1c:	0001883a 	nop
81106f20:	e037883a 	mov	sp,fp
81106f24:	dfc00117 	ldw	ra,4(sp)
81106f28:	df000017 	ldw	fp,0(sp)
81106f2c:	dec00204 	addi	sp,sp,8
81106f30:	f800283a 	ret

81106f34 <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
81106f34:	defffe04 	addi	sp,sp,-8
81106f38:	de00012e 	bgeu	sp,et,81106f40 <vRmapCh2IrqFlagClrWriteCmd+0xc>
81106f3c:	003b68fa 	trap	3
81106f40:	dfc00115 	stw	ra,4(sp)
81106f44:	df000015 	stw	fp,0(sp)
81106f48:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106f4c:	01800044 	movi	r6,1
81106f50:	014004c4 	movi	r5,19
81106f54:	01204834 	movhi	r4,33056
81106f58:	210a0004 	addi	r4,r4,10240
81106f5c:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106f60:	0001883a 	nop
81106f64:	e037883a 	mov	sp,fp
81106f68:	dfc00117 	ldw	ra,4(sp)
81106f6c:	df000017 	ldw	fp,0(sp)
81106f70:	dec00204 	addi	sp,sp,8
81106f74:	f800283a 	ret

81106f78 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
81106f78:	defffe04 	addi	sp,sp,-8
81106f7c:	de00012e 	bgeu	sp,et,81106f84 <vRmapCh3IrqFlagClrWriteCmd+0xc>
81106f80:	003b68fa 	trap	3
81106f84:	dfc00115 	stw	ra,4(sp)
81106f88:	df000015 	stw	fp,0(sp)
81106f8c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81106f90:	01800044 	movi	r6,1
81106f94:	014004c4 	movi	r5,19
81106f98:	01204834 	movhi	r4,33056
81106f9c:	210b0004 	addi	r4,r4,11264
81106fa0:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106fa4:	0001883a 	nop
81106fa8:	e037883a 	mov	sp,fp
81106fac:	dfc00117 	ldw	ra,4(sp)
81106fb0:	df000017 	ldw	fp,0(sp)
81106fb4:	dec00204 	addi	sp,sp,8
81106fb8:	f800283a 	ret

81106fbc <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
81106fbc:	defffe04 	addi	sp,sp,-8
81106fc0:	de00012e 	bgeu	sp,et,81106fc8 <vRmapCh4IrqFlagClrWriteCmd+0xc>
81106fc4:	003b68fa 	trap	3
81106fc8:	dfc00115 	stw	ra,4(sp)
81106fcc:	df000015 	stw	fp,0(sp)
81106fd0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81106fd4:	01800044 	movi	r6,1
81106fd8:	014004c4 	movi	r5,19
81106fdc:	01204834 	movhi	r4,33056
81106fe0:	210a0004 	addi	r4,r4,10240
81106fe4:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106fe8:	0001883a 	nop
81106fec:	e037883a 	mov	sp,fp
81106ff0:	dfc00117 	ldw	ra,4(sp)
81106ff4:	df000017 	ldw	fp,0(sp)
81106ff8:	dec00204 	addi	sp,sp,8
81106ffc:	f800283a 	ret

81107000 <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
81107000:	defffe04 	addi	sp,sp,-8
81107004:	de00012e 	bgeu	sp,et,8110700c <vRmapCh5IrqFlagClrWriteCmd+0xc>
81107008:	003b68fa 	trap	3
8110700c:	dfc00115 	stw	ra,4(sp)
81107010:	df000015 	stw	fp,0(sp)
81107014:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107018:	01800044 	movi	r6,1
8110701c:	014004c4 	movi	r5,19
81107020:	01204834 	movhi	r4,33056
81107024:	210b0004 	addi	r4,r4,11264
81107028:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110702c:	0001883a 	nop
81107030:	e037883a 	mov	sp,fp
81107034:	dfc00117 	ldw	ra,4(sp)
81107038:	df000017 	ldw	fp,0(sp)
8110703c:	dec00204 	addi	sp,sp,8
81107040:	f800283a 	ret

81107044 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
81107044:	defffe04 	addi	sp,sp,-8
81107048:	de00012e 	bgeu	sp,et,81107050 <vRmapCh6IrqFlagClrWriteCmd+0xc>
8110704c:	003b68fa 	trap	3
81107050:	dfc00115 	stw	ra,4(sp)
81107054:	df000015 	stw	fp,0(sp)
81107058:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
8110705c:	01800044 	movi	r6,1
81107060:	014004c4 	movi	r5,19
81107064:	01204834 	movhi	r4,33056
81107068:	210a0004 	addi	r4,r4,10240
8110706c:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107070:	0001883a 	nop
81107074:	e037883a 	mov	sp,fp
81107078:	dfc00117 	ldw	ra,4(sp)
8110707c:	df000017 	ldw	fp,0(sp)
81107080:	dec00204 	addi	sp,sp,8
81107084:	f800283a 	ret

81107088 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
81107088:	defffe04 	addi	sp,sp,-8
8110708c:	de00012e 	bgeu	sp,et,81107094 <vRmapCh7IrqFlagClrWriteCmd+0xc>
81107090:	003b68fa 	trap	3
81107094:	dfc00115 	stw	ra,4(sp)
81107098:	df000015 	stw	fp,0(sp)
8110709c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811070a0:	01800044 	movi	r6,1
811070a4:	014004c4 	movi	r5,19
811070a8:	01204834 	movhi	r4,33056
811070ac:	210b0004 	addi	r4,r4,11264
811070b0:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811070b4:	0001883a 	nop
811070b8:	e037883a 	mov	sp,fp
811070bc:	dfc00117 	ldw	ra,4(sp)
811070c0:	df000017 	ldw	fp,0(sp)
811070c4:	dec00204 	addi	sp,sp,8
811070c8:	f800283a 	ret

811070cc <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
811070cc:	defffe04 	addi	sp,sp,-8
811070d0:	de00012e 	bgeu	sp,et,811070d8 <vRmapCh8IrqFlagClrWriteCmd+0xc>
811070d4:	003b68fa 	trap	3
811070d8:	dfc00115 	stw	ra,4(sp)
811070dc:	df000015 	stw	fp,0(sp)
811070e0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811070e4:	01800044 	movi	r6,1
811070e8:	014004c4 	movi	r5,19
811070ec:	01204834 	movhi	r4,33056
811070f0:	210a0004 	addi	r4,r4,10240
811070f4:	1109db80 	call	81109db8 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811070f8:	0001883a 	nop
811070fc:	e037883a 	mov	sp,fp
81107100:	dfc00117 	ldw	ra,4(sp)
81107104:	df000017 	ldw	fp,0(sp)
81107108:	dec00204 	addi	sp,sp,8
8110710c:	f800283a 	ret

81107110 <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
81107110:	defffd04 	addi	sp,sp,-12
81107114:	de00012e 	bgeu	sp,et,8110711c <bRmapCh1IrqFlagWriteCmd+0xc>
81107118:	003b68fa 	trap	3
8110711c:	dfc00215 	stw	ra,8(sp)
81107120:	df000115 	stw	fp,4(sp)
81107124:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81107128:	01400484 	movi	r5,18
8110712c:	01204834 	movhi	r4,33056
81107130:	210b0004 	addi	r4,r4,11264
81107134:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107138:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
8110713c:	10000326 	beq	r2,zero,8110714c <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107140:	00800044 	movi	r2,1
81107144:	e0bfff15 	stw	r2,-4(fp)
81107148:	00000106 	br	81107150 <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110714c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107150:	e0bfff17 	ldw	r2,-4(fp)
}
81107154:	e037883a 	mov	sp,fp
81107158:	dfc00117 	ldw	ra,4(sp)
8110715c:	df000017 	ldw	fp,0(sp)
81107160:	dec00204 	addi	sp,sp,8
81107164:	f800283a 	ret

81107168 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
81107168:	defffd04 	addi	sp,sp,-12
8110716c:	de00012e 	bgeu	sp,et,81107174 <bRmapCh2IrqFlagWriteCmd+0xc>
81107170:	003b68fa 	trap	3
81107174:	dfc00215 	stw	ra,8(sp)
81107178:	df000115 	stw	fp,4(sp)
8110717c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107180:	01400484 	movi	r5,18
81107184:	01204834 	movhi	r4,33056
81107188:	210a0004 	addi	r4,r4,10240
8110718c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107190:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107194:	10000326 	beq	r2,zero,811071a4 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107198:	00800044 	movi	r2,1
8110719c:	e0bfff15 	stw	r2,-4(fp)
811071a0:	00000106 	br	811071a8 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811071a4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811071a8:	e0bfff17 	ldw	r2,-4(fp)
}
811071ac:	e037883a 	mov	sp,fp
811071b0:	dfc00117 	ldw	ra,4(sp)
811071b4:	df000017 	ldw	fp,0(sp)
811071b8:	dec00204 	addi	sp,sp,8
811071bc:	f800283a 	ret

811071c0 <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
811071c0:	defffd04 	addi	sp,sp,-12
811071c4:	de00012e 	bgeu	sp,et,811071cc <bRmapCh3IrqFlagWriteCmd+0xc>
811071c8:	003b68fa 	trap	3
811071cc:	dfc00215 	stw	ra,8(sp)
811071d0:	df000115 	stw	fp,4(sp)
811071d4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811071d8:	01400484 	movi	r5,18
811071dc:	01204834 	movhi	r4,33056
811071e0:	210b0004 	addi	r4,r4,11264
811071e4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811071e8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811071ec:	10000326 	beq	r2,zero,811071fc <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811071f0:	00800044 	movi	r2,1
811071f4:	e0bfff15 	stw	r2,-4(fp)
811071f8:	00000106 	br	81107200 <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811071fc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107200:	e0bfff17 	ldw	r2,-4(fp)
}
81107204:	e037883a 	mov	sp,fp
81107208:	dfc00117 	ldw	ra,4(sp)
8110720c:	df000017 	ldw	fp,0(sp)
81107210:	dec00204 	addi	sp,sp,8
81107214:	f800283a 	ret

81107218 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
81107218:	defffd04 	addi	sp,sp,-12
8110721c:	de00012e 	bgeu	sp,et,81107224 <bRmapCh4IrqFlagWriteCmd+0xc>
81107220:	003b68fa 	trap	3
81107224:	dfc00215 	stw	ra,8(sp)
81107228:	df000115 	stw	fp,4(sp)
8110722c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81107230:	01400484 	movi	r5,18
81107234:	01204834 	movhi	r4,33056
81107238:	210a0004 	addi	r4,r4,10240
8110723c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107240:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81107244:	10000326 	beq	r2,zero,81107254 <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107248:	00800044 	movi	r2,1
8110724c:	e0bfff15 	stw	r2,-4(fp)
81107250:	00000106 	br	81107258 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107254:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107258:	e0bfff17 	ldw	r2,-4(fp)
}
8110725c:	e037883a 	mov	sp,fp
81107260:	dfc00117 	ldw	ra,4(sp)
81107264:	df000017 	ldw	fp,0(sp)
81107268:	dec00204 	addi	sp,sp,8
8110726c:	f800283a 	ret

81107270 <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
81107270:	defffd04 	addi	sp,sp,-12
81107274:	de00012e 	bgeu	sp,et,8110727c <bRmapCh5IrqFlagWriteCmd+0xc>
81107278:	003b68fa 	trap	3
8110727c:	dfc00215 	stw	ra,8(sp)
81107280:	df000115 	stw	fp,4(sp)
81107284:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107288:	01400484 	movi	r5,18
8110728c:	01204834 	movhi	r4,33056
81107290:	210b0004 	addi	r4,r4,11264
81107294:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107298:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110729c:	10000326 	beq	r2,zero,811072ac <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811072a0:	00800044 	movi	r2,1
811072a4:	e0bfff15 	stw	r2,-4(fp)
811072a8:	00000106 	br	811072b0 <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811072ac:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811072b0:	e0bfff17 	ldw	r2,-4(fp)
}
811072b4:	e037883a 	mov	sp,fp
811072b8:	dfc00117 	ldw	ra,4(sp)
811072bc:	df000017 	ldw	fp,0(sp)
811072c0:	dec00204 	addi	sp,sp,8
811072c4:	f800283a 	ret

811072c8 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
811072c8:	defffd04 	addi	sp,sp,-12
811072cc:	de00012e 	bgeu	sp,et,811072d4 <bRmapCh6IrqFlagWriteCmd+0xc>
811072d0:	003b68fa 	trap	3
811072d4:	dfc00215 	stw	ra,8(sp)
811072d8:	df000115 	stw	fp,4(sp)
811072dc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811072e0:	01400484 	movi	r5,18
811072e4:	01204834 	movhi	r4,33056
811072e8:	210a0004 	addi	r4,r4,10240
811072ec:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811072f0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811072f4:	10000326 	beq	r2,zero,81107304 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811072f8:	00800044 	movi	r2,1
811072fc:	e0bfff15 	stw	r2,-4(fp)
81107300:	00000106 	br	81107308 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107304:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107308:	e0bfff17 	ldw	r2,-4(fp)
}
8110730c:	e037883a 	mov	sp,fp
81107310:	dfc00117 	ldw	ra,4(sp)
81107314:	df000017 	ldw	fp,0(sp)
81107318:	dec00204 	addi	sp,sp,8
8110731c:	f800283a 	ret

81107320 <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
81107320:	defffd04 	addi	sp,sp,-12
81107324:	de00012e 	bgeu	sp,et,8110732c <bRmapCh7IrqFlagWriteCmd+0xc>
81107328:	003b68fa 	trap	3
8110732c:	dfc00215 	stw	ra,8(sp)
81107330:	df000115 	stw	fp,4(sp)
81107334:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107338:	01400484 	movi	r5,18
8110733c:	01204834 	movhi	r4,33056
81107340:	210b0004 	addi	r4,r4,11264
81107344:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107348:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110734c:	10000326 	beq	r2,zero,8110735c <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107350:	00800044 	movi	r2,1
81107354:	e0bfff15 	stw	r2,-4(fp)
81107358:	00000106 	br	81107360 <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110735c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107360:	e0bfff17 	ldw	r2,-4(fp)
}
81107364:	e037883a 	mov	sp,fp
81107368:	dfc00117 	ldw	ra,4(sp)
8110736c:	df000017 	ldw	fp,0(sp)
81107370:	dec00204 	addi	sp,sp,8
81107374:	f800283a 	ret

81107378 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
81107378:	defffd04 	addi	sp,sp,-12
8110737c:	de00012e 	bgeu	sp,et,81107384 <bRmapCh8IrqFlagWriteCmd+0xc>
81107380:	003b68fa 	trap	3
81107384:	dfc00215 	stw	ra,8(sp)
81107388:	df000115 	stw	fp,4(sp)
8110738c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107390:	01400484 	movi	r5,18
81107394:	01204834 	movhi	r4,33056
81107398:	210a0004 	addi	r4,r4,10240
8110739c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811073a0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811073a4:	10000326 	beq	r2,zero,811073b4 <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811073a8:	00800044 	movi	r2,1
811073ac:	e0bfff15 	stw	r2,-4(fp)
811073b0:	00000106 	br	811073b8 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811073b4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811073b8:	e0bfff17 	ldw	r2,-4(fp)
}
811073bc:	e037883a 	mov	sp,fp
811073c0:	dfc00117 	ldw	ra,4(sp)
811073c4:	df000017 	ldw	fp,0(sp)
811073c8:	dec00204 	addi	sp,sp,8
811073cc:	f800283a 	ret

811073d0 <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
811073d0:	defffd04 	addi	sp,sp,-12
811073d4:	de00012e 	bgeu	sp,et,811073dc <uliRmapCh1WriteCmdAddress+0xc>
811073d8:	003b68fa 	trap	3
811073dc:	dfc00215 	stw	ra,8(sp)
811073e0:	df000115 	stw	fp,4(sp)
811073e4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811073e8:	01400184 	movi	r5,6
811073ec:	01204834 	movhi	r4,33056
811073f0:	210b0004 	addi	r4,r4,11264
811073f4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811073f8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);


	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811073fc:	e13fff17 	ldw	r4,-4(fp)
81107400:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
81107404:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107408:	e0bfff17 	ldw	r2,-4(fp)
}
8110740c:	e037883a 	mov	sp,fp
81107410:	dfc00117 	ldw	ra,4(sp)
81107414:	df000017 	ldw	fp,0(sp)
81107418:	dec00204 	addi	sp,sp,8
8110741c:	f800283a 	ret

81107420 <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
81107420:	defffd04 	addi	sp,sp,-12
81107424:	de00012e 	bgeu	sp,et,8110742c <uliRmapCh2WriteCmdAddress+0xc>
81107428:	003b68fa 	trap	3
8110742c:	dfc00215 	stw	ra,8(sp)
81107430:	df000115 	stw	fp,4(sp)
81107434:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107438:	01400184 	movi	r5,6
8110743c:	01204834 	movhi	r4,33056
81107440:	210a0004 	addi	r4,r4,10240
81107444:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107448:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110744c:	e13fff17 	ldw	r4,-4(fp)
81107450:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
81107454:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107458:	e0bfff17 	ldw	r2,-4(fp)
}
8110745c:	e037883a 	mov	sp,fp
81107460:	dfc00117 	ldw	ra,4(sp)
81107464:	df000017 	ldw	fp,0(sp)
81107468:	dec00204 	addi	sp,sp,8
8110746c:	f800283a 	ret

81107470 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
81107470:	defffd04 	addi	sp,sp,-12
81107474:	de00012e 	bgeu	sp,et,8110747c <uliRmapCh3WriteCmdAddress+0xc>
81107478:	003b68fa 	trap	3
8110747c:	dfc00215 	stw	ra,8(sp)
81107480:	df000115 	stw	fp,4(sp)
81107484:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107488:	01400184 	movi	r5,6
8110748c:	01204834 	movhi	r4,33056
81107490:	210b0004 	addi	r4,r4,11264
81107494:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107498:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110749c:	e13fff17 	ldw	r4,-4(fp)
811074a0:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
811074a4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811074a8:	e0bfff17 	ldw	r2,-4(fp)
}
811074ac:	e037883a 	mov	sp,fp
811074b0:	dfc00117 	ldw	ra,4(sp)
811074b4:	df000017 	ldw	fp,0(sp)
811074b8:	dec00204 	addi	sp,sp,8
811074bc:	f800283a 	ret

811074c0 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
811074c0:	defffd04 	addi	sp,sp,-12
811074c4:	de00012e 	bgeu	sp,et,811074cc <uliRmapCh4WriteCmdAddress+0xc>
811074c8:	003b68fa 	trap	3
811074cc:	dfc00215 	stw	ra,8(sp)
811074d0:	df000115 	stw	fp,4(sp)
811074d4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811074d8:	01400184 	movi	r5,6
811074dc:	01204834 	movhi	r4,33056
811074e0:	210a0004 	addi	r4,r4,10240
811074e4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811074e8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811074ec:	e13fff17 	ldw	r4,-4(fp)
811074f0:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
811074f4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811074f8:	e0bfff17 	ldw	r2,-4(fp)
}
811074fc:	e037883a 	mov	sp,fp
81107500:	dfc00117 	ldw	ra,4(sp)
81107504:	df000017 	ldw	fp,0(sp)
81107508:	dec00204 	addi	sp,sp,8
8110750c:	f800283a 	ret

81107510 <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
81107510:	defffd04 	addi	sp,sp,-12
81107514:	de00012e 	bgeu	sp,et,8110751c <uliRmapCh5WriteCmdAddress+0xc>
81107518:	003b68fa 	trap	3
8110751c:	dfc00215 	stw	ra,8(sp)
81107520:	df000115 	stw	fp,4(sp)
81107524:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107528:	01400184 	movi	r5,6
8110752c:	01204834 	movhi	r4,33056
81107530:	210b0004 	addi	r4,r4,11264
81107534:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107538:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110753c:	e13fff17 	ldw	r4,-4(fp)
81107540:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
81107544:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107548:	e0bfff17 	ldw	r2,-4(fp)
}
8110754c:	e037883a 	mov	sp,fp
81107550:	dfc00117 	ldw	ra,4(sp)
81107554:	df000017 	ldw	fp,0(sp)
81107558:	dec00204 	addi	sp,sp,8
8110755c:	f800283a 	ret

81107560 <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
81107560:	defffd04 	addi	sp,sp,-12
81107564:	de00012e 	bgeu	sp,et,8110756c <uliRmapCh6WriteCmdAddress+0xc>
81107568:	003b68fa 	trap	3
8110756c:	dfc00215 	stw	ra,8(sp)
81107570:	df000115 	stw	fp,4(sp)
81107574:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107578:	01400184 	movi	r5,6
8110757c:	01204834 	movhi	r4,33056
81107580:	210a0004 	addi	r4,r4,10240
81107584:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107588:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110758c:	e13fff17 	ldw	r4,-4(fp)
81107590:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
81107594:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107598:	e0bfff17 	ldw	r2,-4(fp)
}
8110759c:	e037883a 	mov	sp,fp
811075a0:	dfc00117 	ldw	ra,4(sp)
811075a4:	df000017 	ldw	fp,0(sp)
811075a8:	dec00204 	addi	sp,sp,8
811075ac:	f800283a 	ret

811075b0 <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
811075b0:	defffd04 	addi	sp,sp,-12
811075b4:	de00012e 	bgeu	sp,et,811075bc <uliRmapCh7WriteCmdAddress+0xc>
811075b8:	003b68fa 	trap	3
811075bc:	dfc00215 	stw	ra,8(sp)
811075c0:	df000115 	stw	fp,4(sp)
811075c4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811075c8:	01400184 	movi	r5,6
811075cc:	01204834 	movhi	r4,33056
811075d0:	210b0004 	addi	r4,r4,11264
811075d4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811075d8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811075dc:	e13fff17 	ldw	r4,-4(fp)
811075e0:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
811075e4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811075e8:	e0bfff17 	ldw	r2,-4(fp)
}
811075ec:	e037883a 	mov	sp,fp
811075f0:	dfc00117 	ldw	ra,4(sp)
811075f4:	df000017 	ldw	fp,0(sp)
811075f8:	dec00204 	addi	sp,sp,8
811075fc:	f800283a 	ret

81107600 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
81107600:	defffd04 	addi	sp,sp,-12
81107604:	de00012e 	bgeu	sp,et,8110760c <uliRmapCh8WriteCmdAddress+0xc>
81107608:	003b68fa 	trap	3
8110760c:	dfc00215 	stw	ra,8(sp)
81107610:	df000115 	stw	fp,4(sp)
81107614:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107618:	01400184 	movi	r5,6
8110761c:	01204834 	movhi	r4,33056
81107620:	210a0004 	addi	r4,r4,10240
81107624:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107628:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110762c:	e13fff17 	ldw	r4,-4(fp)
81107630:	1109e5c0 	call	81109e5c <uliConvRmapCfgAddr>
81107634:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107638:	e0bfff17 	ldw	r2,-4(fp)
}
8110763c:	e037883a 	mov	sp,fp
81107640:	dfc00117 	ldw	ra,4(sp)
81107644:	df000017 	ldw	fp,0(sp)
81107648:	dec00204 	addi	sp,sp,8
8110764c:	f800283a 	ret

81107650 <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
81107650:	defffc04 	addi	sp,sp,-16
81107654:	de00012e 	bgeu	sp,et,8110765c <vRmapInitIrq+0xc>
81107658:	003b68fa 	trap	3
8110765c:	dfc00315 	stw	ra,12(sp)
81107660:	df000215 	stw	fp,8(sp)
81107664:	df000204 	addi	fp,sp,8
81107668:	2005883a 	mov	r2,r4
8110766c:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81107670:	e0bfff03 	ldbu	r2,-4(fp)
81107674:	10c00228 	cmpgeui	r3,r2,8
81107678:	18004e1e 	bne	r3,zero,811077b4 <vRmapInitIrq+0x164>
8110767c:	100690ba 	slli	r3,r2,2
81107680:	00a04434 	movhi	r2,33040
81107684:	109da504 	addi	r2,r2,30356
81107688:	1885883a 	add	r2,r3,r2
8110768c:	10800017 	ldw	r2,0(r2)
81107690:	1000683a 	jmp	r2
81107694:	811076b4 	orhi	r4,r16,16858
81107698:	811076d4 	ori	r4,r16,16859
8110769c:	811076f4 	orhi	r4,r16,16859
811076a0:	81107714 	ori	r4,r16,16860
811076a4:	81107734 	orhi	r4,r16,16860
811076a8:	81107754 	ori	r4,r16,16861
811076ac:	81107774 	orhi	r4,r16,16861
811076b0:	81107794 	ori	r4,r16,16862
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
811076b4:	d0a04804 	addi	r2,gp,-32480
811076b8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
811076bc:	01a04434 	movhi	r6,33040
811076c0:	319af204 	addi	r6,r6,27592
811076c4:	e17ffe17 	ldw	r5,-8(fp)
811076c8:	010005c4 	movi	r4,23
811076cc:	11378f80 	call	811378f8 <alt_irq_register>
		break;
811076d0:	00003806 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811076d4:	d0a04904 	addi	r2,gp,-32476
811076d8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
811076dc:	01a04434 	movhi	r6,33040
811076e0:	319b2d04 	addi	r6,r6,27828
811076e4:	e17ffe17 	ldw	r5,-8(fp)
811076e8:	01000544 	movi	r4,21
811076ec:	11378f80 	call	811378f8 <alt_irq_register>
		break;
811076f0:	00003006 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811076f4:	d0a04a04 	addi	r2,gp,-32472
811076f8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
811076fc:	01a04434 	movhi	r6,33040
81107700:	319b6804 	addi	r6,r6,28064
81107704:	e17ffe17 	ldw	r5,-8(fp)
81107708:	010004c4 	movi	r4,19
8110770c:	11378f80 	call	811378f8 <alt_irq_register>
		break;
81107710:	00002806 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81107714:	d0a04b04 	addi	r2,gp,-32468
81107718:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
8110771c:	01a04434 	movhi	r6,33040
81107720:	319b7604 	addi	r6,r6,28120
81107724:	e17ffe17 	ldw	r5,-8(fp)
81107728:	01000444 	movi	r4,17
8110772c:	11378f80 	call	811378f8 <alt_irq_register>
		break;
81107730:	00002006 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81107734:	d0a04c04 	addi	r2,gp,-32464
81107738:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
8110773c:	01a04434 	movhi	r6,33040
81107740:	319b8404 	addi	r6,r6,28176
81107744:	e17ffe17 	ldw	r5,-8(fp)
81107748:	01000244 	movi	r4,9
8110774c:	11378f80 	call	811378f8 <alt_irq_register>
		break;
81107750:	00001806 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81107754:	d0a04d04 	addi	r2,gp,-32460
81107758:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
8110775c:	01a04434 	movhi	r6,33040
81107760:	319b9204 	addi	r6,r6,28232
81107764:	e17ffe17 	ldw	r5,-8(fp)
81107768:	010001c4 	movi	r4,7
8110776c:	11378f80 	call	811378f8 <alt_irq_register>
		break;
81107770:	00001006 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81107774:	d0a04e04 	addi	r2,gp,-32456
81107778:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
8110777c:	01a04434 	movhi	r6,33040
81107780:	319ba004 	addi	r6,r6,28288
81107784:	e17ffe17 	ldw	r5,-8(fp)
81107788:	01000104 	movi	r4,4
8110778c:	11378f80 	call	811378f8 <alt_irq_register>
		break;
81107790:	00000806 	br	811077b4 <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81107794:	d0a04f04 	addi	r2,gp,-32452
81107798:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
8110779c:	01a04434 	movhi	r6,33040
811077a0:	319bae04 	addi	r6,r6,28344
811077a4:	e17ffe17 	ldw	r5,-8(fp)
811077a8:	010000c4 	movi	r4,3
811077ac:	11378f80 	call	811378f8 <alt_irq_register>
		break;
811077b0:	0001883a 	nop
	}
}
811077b4:	0001883a 	nop
811077b8:	e037883a 	mov	sp,fp
811077bc:	dfc00117 	ldw	ra,4(sp)
811077c0:	df000017 	ldw	fp,0(sp)
811077c4:	dec00204 	addi	sp,sp,8
811077c8:	f800283a 	ret

811077cc <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
811077cc:	defffb04 	addi	sp,sp,-20
811077d0:	de00012e 	bgeu	sp,et,811077d8 <bRmapSetIrqControl+0xc>
811077d4:	003b68fa 	trap	3
811077d8:	dfc00415 	stw	ra,16(sp)
811077dc:	df000315 	stw	fp,12(sp)
811077e0:	df000304 	addi	fp,sp,12
811077e4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811077e8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811077ec:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811077f0:	e0bfff17 	ldw	r2,-4(fp)
811077f4:	10001926 	beq	r2,zero,8110785c <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811077f8:	e0bfff17 	ldw	r2,-4(fp)
811077fc:	10800017 	ldw	r2,0(r2)
81107800:	01400444 	movi	r5,17
81107804:	1009883a 	mov	r4,r2
81107808:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110780c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
81107810:	e0bfff17 	ldw	r2,-4(fp)
81107814:	10801017 	ldw	r2,64(r2)
81107818:	10000426 	beq	r2,zero,8110782c <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
8110781c:	e0bffe17 	ldw	r2,-8(fp)
81107820:	10800054 	ori	r2,r2,1
81107824:	e0bffe15 	stw	r2,-8(fp)
81107828:	00000406 	br	8110783c <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
8110782c:	e0fffe17 	ldw	r3,-8(fp)
81107830:	00bfff84 	movi	r2,-2
81107834:	1884703a 	and	r2,r3,r2
81107838:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
8110783c:	e0bfff17 	ldw	r2,-4(fp)
81107840:	10800017 	ldw	r2,0(r2)
81107844:	e1bffe17 	ldw	r6,-8(fp)
81107848:	01400444 	movi	r5,17
8110784c:	1009883a 	mov	r4,r2
81107850:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81107854:	00800044 	movi	r2,1
81107858:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110785c:	e0bffd17 	ldw	r2,-12(fp)
}
81107860:	e037883a 	mov	sp,fp
81107864:	dfc00117 	ldw	ra,4(sp)
81107868:	df000017 	ldw	fp,0(sp)
8110786c:	dec00204 	addi	sp,sp,8
81107870:	f800283a 	ret

81107874 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
81107874:	defffb04 	addi	sp,sp,-20
81107878:	de00012e 	bgeu	sp,et,81107880 <bRmapGetIrqControl+0xc>
8110787c:	003b68fa 	trap	3
81107880:	dfc00415 	stw	ra,16(sp)
81107884:	df000315 	stw	fp,12(sp)
81107888:	df000304 	addi	fp,sp,12
8110788c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107890:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107894:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107898:	e0bfff17 	ldw	r2,-4(fp)
8110789c:	10001126 	beq	r2,zero,811078e4 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811078a0:	e0bfff17 	ldw	r2,-4(fp)
811078a4:	10800017 	ldw	r2,0(r2)
811078a8:	01400444 	movi	r5,17
811078ac:	1009883a 	mov	r4,r2
811078b0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811078b4:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
811078b8:	e0bffe17 	ldw	r2,-8(fp)
811078bc:	1080004c 	andi	r2,r2,1
811078c0:	10000426 	beq	r2,zero,811078d4 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
811078c4:	e0bfff17 	ldw	r2,-4(fp)
811078c8:	00c00044 	movi	r3,1
811078cc:	10c01015 	stw	r3,64(r2)
811078d0:	00000206 	br	811078dc <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
811078d4:	e0bfff17 	ldw	r2,-4(fp)
811078d8:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
811078dc:	00800044 	movi	r2,1
811078e0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811078e4:	e0bffd17 	ldw	r2,-12(fp)
}
811078e8:	e037883a 	mov	sp,fp
811078ec:	dfc00117 	ldw	ra,4(sp)
811078f0:	df000017 	ldw	fp,0(sp)
811078f4:	dec00204 	addi	sp,sp,8
811078f8:	f800283a 	ret

811078fc <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
811078fc:	defffb04 	addi	sp,sp,-20
81107900:	de00012e 	bgeu	sp,et,81107908 <bRmapGetIrqFlags+0xc>
81107904:	003b68fa 	trap	3
81107908:	dfc00415 	stw	ra,16(sp)
8110790c:	df000315 	stw	fp,12(sp)
81107910:	df000304 	addi	fp,sp,12
81107914:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107918:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110791c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107920:	e0bfff17 	ldw	r2,-4(fp)
81107924:	10001126 	beq	r2,zero,8110796c <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107928:	e0bfff17 	ldw	r2,-4(fp)
8110792c:	10800017 	ldw	r2,0(r2)
81107930:	01400484 	movi	r5,18
81107934:	1009883a 	mov	r4,r2
81107938:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110793c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107940:	e0bffe17 	ldw	r2,-8(fp)
81107944:	1080004c 	andi	r2,r2,1
81107948:	10000426 	beq	r2,zero,8110795c <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
8110794c:	e0bfff17 	ldw	r2,-4(fp)
81107950:	00c00044 	movi	r3,1
81107954:	10c01115 	stw	r3,68(r2)
81107958:	00000206 	br	81107964 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
8110795c:	e0bfff17 	ldw	r2,-4(fp)
81107960:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81107964:	00800044 	movi	r2,1
81107968:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110796c:	e0bffd17 	ldw	r2,-12(fp)
}
81107970:	e037883a 	mov	sp,fp
81107974:	dfc00117 	ldw	ra,4(sp)
81107978:	df000017 	ldw	fp,0(sp)
8110797c:	dec00204 	addi	sp,sp,8
81107980:	f800283a 	ret

81107984 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81107984:	defffb04 	addi	sp,sp,-20
81107988:	de00012e 	bgeu	sp,et,81107990 <bRmapSetCodecConfig+0xc>
8110798c:	003b68fa 	trap	3
81107990:	dfc00415 	stw	ra,16(sp)
81107994:	df000315 	stw	fp,12(sp)
81107998:	df000304 	addi	fp,sp,12
8110799c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811079a0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811079a4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811079a8:	e0bfff17 	ldw	r2,-4(fp)
811079ac:	10002526 	beq	r2,zero,81107a44 <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811079b0:	e0bfff17 	ldw	r2,-4(fp)
811079b4:	10800017 	ldw	r2,0(r2)
811079b8:	01400104 	movi	r5,4
811079bc:	1009883a 	mov	r4,r2
811079c0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811079c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
811079c8:	e0fffe17 	ldw	r3,-8(fp)
811079cc:	00bfc004 	movi	r2,-256
811079d0:	1884703a 	and	r2,r3,r2
811079d4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
811079d8:	e0bfff17 	ldw	r2,-4(fp)
811079dc:	10800143 	ldbu	r2,5(r2)
811079e0:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
811079e4:	e0fffe17 	ldw	r3,-8(fp)
811079e8:	1884b03a 	or	r2,r3,r2
811079ec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
811079f0:	e0fffe17 	ldw	r3,-8(fp)
811079f4:	00bffff4 	movhi	r2,65535
811079f8:	10803fc4 	addi	r2,r2,255
811079fc:	1884703a 	and	r2,r3,r2
81107a00:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81107a04:	e0bfff17 	ldw	r2,-4(fp)
81107a08:	10800103 	ldbu	r2,4(r2)
81107a0c:	10803fcc 	andi	r2,r2,255
81107a10:	1004923a 	slli	r2,r2,8
81107a14:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81107a18:	e0fffe17 	ldw	r3,-8(fp)
81107a1c:	1884b03a 	or	r2,r3,r2
81107a20:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81107a24:	e0bfff17 	ldw	r2,-4(fp)
81107a28:	10800017 	ldw	r2,0(r2)
81107a2c:	e1bffe17 	ldw	r6,-8(fp)
81107a30:	01400104 	movi	r5,4
81107a34:	1009883a 	mov	r4,r2
81107a38:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81107a3c:	00800044 	movi	r2,1
81107a40:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107a44:	e0bffd17 	ldw	r2,-12(fp)
}
81107a48:	e037883a 	mov	sp,fp
81107a4c:	dfc00117 	ldw	ra,4(sp)
81107a50:	df000017 	ldw	fp,0(sp)
81107a54:	dec00204 	addi	sp,sp,8
81107a58:	f800283a 	ret

81107a5c <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81107a5c:	defffb04 	addi	sp,sp,-20
81107a60:	de00012e 	bgeu	sp,et,81107a68 <bRmapGetCodecConfig+0xc>
81107a64:	003b68fa 	trap	3
81107a68:	dfc00415 	stw	ra,16(sp)
81107a6c:	df000315 	stw	fp,12(sp)
81107a70:	df000304 	addi	fp,sp,12
81107a74:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107a78:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107a7c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107a80:	e0bfff17 	ldw	r2,-4(fp)
81107a84:	10001226 	beq	r2,zero,81107ad0 <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a88:	e0bfff17 	ldw	r2,-4(fp)
81107a8c:	10800017 	ldw	r2,0(r2)
81107a90:	01400104 	movi	r5,4
81107a94:	1009883a 	mov	r4,r2
81107a98:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107a9c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81107aa0:	e0bffe17 	ldw	r2,-8(fp)
81107aa4:	1007883a 	mov	r3,r2
81107aa8:	e0bfff17 	ldw	r2,-4(fp)
81107aac:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81107ab0:	e0bffe17 	ldw	r2,-8(fp)
81107ab4:	10bfc00c 	andi	r2,r2,65280
81107ab8:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81107abc:	1007883a 	mov	r3,r2
81107ac0:	e0bfff17 	ldw	r2,-4(fp)
81107ac4:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81107ac8:	00800044 	movi	r2,1
81107acc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107ad0:	e0bffd17 	ldw	r2,-12(fp)
}
81107ad4:	e037883a 	mov	sp,fp
81107ad8:	dfc00117 	ldw	ra,4(sp)
81107adc:	df000017 	ldw	fp,0(sp)
81107ae0:	dec00204 	addi	sp,sp,8
81107ae4:	f800283a 	ret

81107ae8 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81107ae8:	defffb04 	addi	sp,sp,-20
81107aec:	de00012e 	bgeu	sp,et,81107af4 <bRmapGetCodecStatus+0xc>
81107af0:	003b68fa 	trap	3
81107af4:	dfc00415 	stw	ra,16(sp)
81107af8:	df000315 	stw	fp,12(sp)
81107afc:	df000304 	addi	fp,sp,12
81107b00:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107b04:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107b08:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107b0c:	e0bfff17 	ldw	r2,-4(fp)
81107b10:	10004726 	beq	r2,zero,81107c30 <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b14:	e0bfff17 	ldw	r2,-4(fp)
81107b18:	10800017 	ldw	r2,0(r2)
81107b1c:	01400144 	movi	r5,5
81107b20:	1009883a 	mov	r4,r2
81107b24:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107b28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81107b2c:	e0bffe17 	ldw	r2,-8(fp)
81107b30:	1080004c 	andi	r2,r2,1
81107b34:	10000426 	beq	r2,zero,81107b48 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81107b38:	e0bfff17 	ldw	r2,-4(fp)
81107b3c:	00c00044 	movi	r3,1
81107b40:	10c00215 	stw	r3,8(r2)
81107b44:	00000206 	br	81107b50 <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107b48:	e0bfff17 	ldw	r2,-4(fp)
81107b4c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81107b50:	e0bffe17 	ldw	r2,-8(fp)
81107b54:	1080008c 	andi	r2,r2,2
81107b58:	10000426 	beq	r2,zero,81107b6c <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81107b5c:	e0bfff17 	ldw	r2,-4(fp)
81107b60:	00c00044 	movi	r3,1
81107b64:	10c00315 	stw	r3,12(r2)
81107b68:	00000206 	br	81107b74 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81107b6c:	e0bfff17 	ldw	r2,-4(fp)
81107b70:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81107b74:	e0bffe17 	ldw	r2,-8(fp)
81107b78:	1080010c 	andi	r2,r2,4
81107b7c:	10000426 	beq	r2,zero,81107b90 <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
81107b80:	e0bfff17 	ldw	r2,-4(fp)
81107b84:	00c00044 	movi	r3,1
81107b88:	10c00415 	stw	r3,16(r2)
81107b8c:	00000206 	br	81107b98 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
81107b90:	e0bfff17 	ldw	r2,-4(fp)
81107b94:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81107b98:	e0bffe17 	ldw	r2,-8(fp)
81107b9c:	1080020c 	andi	r2,r2,8
81107ba0:	10000426 	beq	r2,zero,81107bb4 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81107ba4:	e0bfff17 	ldw	r2,-4(fp)
81107ba8:	00c00044 	movi	r3,1
81107bac:	10c00515 	stw	r3,20(r2)
81107bb0:	00000206 	br	81107bbc <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81107bb4:	e0bfff17 	ldw	r2,-4(fp)
81107bb8:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81107bbc:	e0bffe17 	ldw	r2,-8(fp)
81107bc0:	1080040c 	andi	r2,r2,16
81107bc4:	10000426 	beq	r2,zero,81107bd8 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81107bc8:	e0bfff17 	ldw	r2,-4(fp)
81107bcc:	00c00044 	movi	r3,1
81107bd0:	10c00615 	stw	r3,24(r2)
81107bd4:	00000206 	br	81107be0 <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81107bd8:	e0bfff17 	ldw	r2,-4(fp)
81107bdc:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81107be0:	e0bffe17 	ldw	r2,-8(fp)
81107be4:	1080080c 	andi	r2,r2,32
81107be8:	10000426 	beq	r2,zero,81107bfc <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81107bec:	e0bfff17 	ldw	r2,-4(fp)
81107bf0:	00c00044 	movi	r3,1
81107bf4:	10c00715 	stw	r3,28(r2)
81107bf8:	00000206 	br	81107c04 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81107bfc:	e0bfff17 	ldw	r2,-4(fp)
81107c00:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81107c04:	e0bffe17 	ldw	r2,-8(fp)
81107c08:	1080100c 	andi	r2,r2,64
81107c0c:	10000426 	beq	r2,zero,81107c20 <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81107c10:	e0bfff17 	ldw	r2,-4(fp)
81107c14:	00c00044 	movi	r3,1
81107c18:	10c00815 	stw	r3,32(r2)
81107c1c:	00000206 	br	81107c28 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107c20:	e0bfff17 	ldw	r2,-4(fp)
81107c24:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81107c28:	00800044 	movi	r2,1
81107c2c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107c30:	e0bffd17 	ldw	r2,-12(fp)
}
81107c34:	e037883a 	mov	sp,fp
81107c38:	dfc00117 	ldw	ra,4(sp)
81107c3c:	df000017 	ldw	fp,0(sp)
81107c40:	dec00204 	addi	sp,sp,8
81107c44:	f800283a 	ret

81107c48 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81107c48:	defffb04 	addi	sp,sp,-20
81107c4c:	de00012e 	bgeu	sp,et,81107c54 <bRmapGetCodecError+0xc>
81107c50:	003b68fa 	trap	3
81107c54:	dfc00415 	stw	ra,16(sp)
81107c58:	df000315 	stw	fp,12(sp)
81107c5c:	df000304 	addi	fp,sp,12
81107c60:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107c64:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107c68:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107c6c:	e0bfff17 	ldw	r2,-4(fp)
81107c70:	10004726 	beq	r2,zero,81107d90 <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c74:	e0bfff17 	ldw	r2,-4(fp)
81107c78:	10800017 	ldw	r2,0(r2)
81107c7c:	01400144 	movi	r5,5
81107c80:	1009883a 	mov	r4,r2
81107c84:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107c88:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
81107c8c:	e0bffe17 	ldw	r2,-8(fp)
81107c90:	1080006c 	andhi	r2,r2,1
81107c94:	10000426 	beq	r2,zero,81107ca8 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
81107c98:	e0bfff17 	ldw	r2,-4(fp)
81107c9c:	00c00044 	movi	r3,1
81107ca0:	10c00915 	stw	r3,36(r2)
81107ca4:	00000206 	br	81107cb0 <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81107ca8:	e0bfff17 	ldw	r2,-4(fp)
81107cac:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
81107cb0:	e0bffe17 	ldw	r2,-8(fp)
81107cb4:	108000ac 	andhi	r2,r2,2
81107cb8:	10000426 	beq	r2,zero,81107ccc <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81107cbc:	e0bfff17 	ldw	r2,-4(fp)
81107cc0:	00c00044 	movi	r3,1
81107cc4:	10c00a15 	stw	r3,40(r2)
81107cc8:	00000206 	br	81107cd4 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81107ccc:	e0bfff17 	ldw	r2,-4(fp)
81107cd0:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81107cd4:	e0bffe17 	ldw	r2,-8(fp)
81107cd8:	1080012c 	andhi	r2,r2,4
81107cdc:	10000426 	beq	r2,zero,81107cf0 <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81107ce0:	e0bfff17 	ldw	r2,-4(fp)
81107ce4:	00c00044 	movi	r3,1
81107ce8:	10c00b15 	stw	r3,44(r2)
81107cec:	00000206 	br	81107cf8 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81107cf0:	e0bfff17 	ldw	r2,-4(fp)
81107cf4:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81107cf8:	e0bffe17 	ldw	r2,-8(fp)
81107cfc:	1080022c 	andhi	r2,r2,8
81107d00:	10000426 	beq	r2,zero,81107d14 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81107d04:	e0bfff17 	ldw	r2,-4(fp)
81107d08:	00c00044 	movi	r3,1
81107d0c:	10c00c15 	stw	r3,48(r2)
81107d10:	00000206 	br	81107d1c <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81107d14:	e0bfff17 	ldw	r2,-4(fp)
81107d18:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81107d1c:	e0bffe17 	ldw	r2,-8(fp)
81107d20:	1080042c 	andhi	r2,r2,16
81107d24:	10000426 	beq	r2,zero,81107d38 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81107d28:	e0bfff17 	ldw	r2,-4(fp)
81107d2c:	00c00044 	movi	r3,1
81107d30:	10c00d15 	stw	r3,52(r2)
81107d34:	00000206 	br	81107d40 <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81107d38:	e0bfff17 	ldw	r2,-4(fp)
81107d3c:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
81107d40:	e0bffe17 	ldw	r2,-8(fp)
81107d44:	1080082c 	andhi	r2,r2,32
81107d48:	10000426 	beq	r2,zero,81107d5c <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
81107d4c:	e0bfff17 	ldw	r2,-4(fp)
81107d50:	00c00044 	movi	r3,1
81107d54:	10c00e15 	stw	r3,56(r2)
81107d58:	00000206 	br	81107d64 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
81107d5c:	e0bfff17 	ldw	r2,-4(fp)
81107d60:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81107d64:	e0bffe17 	ldw	r2,-8(fp)
81107d68:	1080102c 	andhi	r2,r2,64
81107d6c:	10000426 	beq	r2,zero,81107d80 <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
81107d70:	e0bfff17 	ldw	r2,-4(fp)
81107d74:	00c00044 	movi	r3,1
81107d78:	10c00f15 	stw	r3,60(r2)
81107d7c:	00000206 	br	81107d88 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
81107d80:	e0bfff17 	ldw	r2,-4(fp)
81107d84:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
81107d88:	00800044 	movi	r2,1
81107d8c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107d90:	e0bffd17 	ldw	r2,-12(fp)
}
81107d94:	e037883a 	mov	sp,fp
81107d98:	dfc00117 	ldw	ra,4(sp)
81107d9c:	df000017 	ldw	fp,0(sp)
81107da0:	dec00204 	addi	sp,sp,8
81107da4:	f800283a 	ret

81107da8 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81107da8:	defffb04 	addi	sp,sp,-20
81107dac:	de00012e 	bgeu	sp,et,81107db4 <bRmapSetMemConfigArea+0xc>
81107db0:	003b68fa 	trap	3
81107db4:	dfc00415 	stw	ra,16(sp)
81107db8:	df000315 	stw	fp,12(sp)
81107dbc:	df000304 	addi	fp,sp,12
81107dc0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107dc4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107dc8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107dcc:	e0bfff17 	ldw	r2,-4(fp)
81107dd0:	1000aa26 	beq	r2,zero,8110807c <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81107dd4:	e0bfff17 	ldw	r2,-4(fp)
81107dd8:	10801217 	ldw	r2,72(r2)
81107ddc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107de0:	e0bfff17 	ldw	r2,-4(fp)
81107de4:	10800017 	ldw	r2,0(r2)
81107de8:	e1bffe17 	ldw	r6,-8(fp)
81107dec:	01401004 	movi	r5,64
81107df0:	1009883a 	mov	r4,r2
81107df4:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81107df8:	e0bfff17 	ldw	r2,-4(fp)
81107dfc:	10801317 	ldw	r2,76(r2)
81107e00:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e04:	e0bfff17 	ldw	r2,-4(fp)
81107e08:	10800017 	ldw	r2,0(r2)
81107e0c:	e1bffe17 	ldw	r6,-8(fp)
81107e10:	01401044 	movi	r5,65
81107e14:	1009883a 	mov	r4,r2
81107e18:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
81107e1c:	e0bfff17 	ldw	r2,-4(fp)
81107e20:	10801417 	ldw	r2,80(r2)
81107e24:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e28:	e0bfff17 	ldw	r2,-4(fp)
81107e2c:	10800017 	ldw	r2,0(r2)
81107e30:	e1bffe17 	ldw	r6,-8(fp)
81107e34:	01401084 	movi	r5,66
81107e38:	1009883a 	mov	r4,r2
81107e3c:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
81107e40:	e0bfff17 	ldw	r2,-4(fp)
81107e44:	10801517 	ldw	r2,84(r2)
81107e48:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e4c:	e0bfff17 	ldw	r2,-4(fp)
81107e50:	10800017 	ldw	r2,0(r2)
81107e54:	e1bffe17 	ldw	r6,-8(fp)
81107e58:	014010c4 	movi	r5,67
81107e5c:	1009883a 	mov	r4,r2
81107e60:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107e64:	e0bfff17 	ldw	r2,-4(fp)
81107e68:	10802217 	ldw	r2,136(r2)
81107e6c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e70:	e0bfff17 	ldw	r2,-4(fp)
81107e74:	10800017 	ldw	r2,0(r2)
81107e78:	e1bffe17 	ldw	r6,-8(fp)
81107e7c:	01401104 	movi	r5,68
81107e80:	1009883a 	mov	r4,r2
81107e84:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
81107e88:	e0bfff17 	ldw	r2,-4(fp)
81107e8c:	10801717 	ldw	r2,92(r2)
81107e90:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e94:	e0bfff17 	ldw	r2,-4(fp)
81107e98:	10800017 	ldw	r2,0(r2)
81107e9c:	e1bffe17 	ldw	r6,-8(fp)
81107ea0:	01401144 	movi	r5,69
81107ea4:	1009883a 	mov	r4,r2
81107ea8:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81107eac:	e0bfff17 	ldw	r2,-4(fp)
81107eb0:	10801817 	ldw	r2,96(r2)
81107eb4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107eb8:	e0bfff17 	ldw	r2,-4(fp)
81107ebc:	10800017 	ldw	r2,0(r2)
81107ec0:	e1bffe17 	ldw	r6,-8(fp)
81107ec4:	01401184 	movi	r5,70
81107ec8:	1009883a 	mov	r4,r2
81107ecc:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81107ed0:	e0bfff17 	ldw	r2,-4(fp)
81107ed4:	10801917 	ldw	r2,100(r2)
81107ed8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107edc:	e0bfff17 	ldw	r2,-4(fp)
81107ee0:	10800017 	ldw	r2,0(r2)
81107ee4:	e1bffe17 	ldw	r6,-8(fp)
81107ee8:	014011c4 	movi	r5,71
81107eec:	1009883a 	mov	r4,r2
81107ef0:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81107ef4:	e0bfff17 	ldw	r2,-4(fp)
81107ef8:	10801a17 	ldw	r2,104(r2)
81107efc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f00:	e0bfff17 	ldw	r2,-4(fp)
81107f04:	10800017 	ldw	r2,0(r2)
81107f08:	e1bffe17 	ldw	r6,-8(fp)
81107f0c:	01401204 	movi	r5,72
81107f10:	1009883a 	mov	r4,r2
81107f14:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
81107f18:	e0bfff17 	ldw	r2,-4(fp)
81107f1c:	10801b17 	ldw	r2,108(r2)
81107f20:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f24:	e0bfff17 	ldw	r2,-4(fp)
81107f28:	10800017 	ldw	r2,0(r2)
81107f2c:	e1bffe17 	ldw	r6,-8(fp)
81107f30:	01401244 	movi	r5,73
81107f34:	1009883a 	mov	r4,r2
81107f38:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f3c:	e0bfff17 	ldw	r2,-4(fp)
81107f40:	10800017 	ldw	r2,0(r2)
81107f44:	01401284 	movi	r5,74
81107f48:	1009883a 	mov	r4,r2
81107f4c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81107f50:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
81107f54:	e0bfff17 	ldw	r2,-4(fp)
81107f58:	10801c17 	ldw	r2,112(r2)
81107f5c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f60:	e0bfff17 	ldw	r2,-4(fp)
81107f64:	10800017 	ldw	r2,0(r2)
81107f68:	e1bffe17 	ldw	r6,-8(fp)
81107f6c:	01401284 	movi	r5,74
81107f70:	1009883a 	mov	r4,r2
81107f74:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
81107f78:	e0bfff17 	ldw	r2,-4(fp)
81107f7c:	10801d17 	ldw	r2,116(r2)
81107f80:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f84:	e0bfff17 	ldw	r2,-4(fp)
81107f88:	10800017 	ldw	r2,0(r2)
81107f8c:	e1bffe17 	ldw	r6,-8(fp)
81107f90:	014012c4 	movi	r5,75
81107f94:	1009883a 	mov	r4,r2
81107f98:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
81107f9c:	e0bfff17 	ldw	r2,-4(fp)
81107fa0:	10801e17 	ldw	r2,120(r2)
81107fa4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81107fa8:	e0bfff17 	ldw	r2,-4(fp)
81107fac:	10800017 	ldw	r2,0(r2)
81107fb0:	e1bffe17 	ldw	r6,-8(fp)
81107fb4:	01401304 	movi	r5,76
81107fb8:	1009883a 	mov	r4,r2
81107fbc:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
81107fc0:	e0bfff17 	ldw	r2,-4(fp)
81107fc4:	10801f17 	ldw	r2,124(r2)
81107fc8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
81107fcc:	e0bfff17 	ldw	r2,-4(fp)
81107fd0:	10800017 	ldw	r2,0(r2)
81107fd4:	e1bffe17 	ldw	r6,-8(fp)
81107fd8:	01401344 	movi	r5,77
81107fdc:	1009883a 	mov	r4,r2
81107fe0:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
81107fe4:	e0bfff17 	ldw	r2,-4(fp)
81107fe8:	10802017 	ldw	r2,128(r2)
81107fec:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
81107ff0:	e0bfff17 	ldw	r2,-4(fp)
81107ff4:	10800017 	ldw	r2,0(r2)
81107ff8:	e1bffe17 	ldw	r6,-8(fp)
81107ffc:	01401384 	movi	r5,78
81108000:	1009883a 	mov	r4,r2
81108004:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81108008:	e0bfff17 	ldw	r2,-4(fp)
8110800c:	10802217 	ldw	r2,136(r2)
81108010:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108014:	e0bfff17 	ldw	r2,-4(fp)
81108018:	10800017 	ldw	r2,0(r2)
8110801c:	e1bffe17 	ldw	r6,-8(fp)
81108020:	014013c4 	movi	r5,79
81108024:	1009883a 	mov	r4,r2
81108028:	1109db80 	call	81109db8 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
8110802c:	e0bfff17 	ldw	r2,-4(fp)
81108030:	10802217 	ldw	r2,136(r2)
81108034:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
81108038:	e0bfff17 	ldw	r2,-4(fp)
8110803c:	10800017 	ldw	r2,0(r2)
81108040:	e1bffe17 	ldw	r6,-8(fp)
81108044:	01401404 	movi	r5,80
81108048:	1009883a 	mov	r4,r2
8110804c:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
81108050:	e0bfff17 	ldw	r2,-4(fp)
81108054:	10802317 	ldw	r2,140(r2)
81108058:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
8110805c:	e0bfff17 	ldw	r2,-4(fp)
81108060:	10800017 	ldw	r2,0(r2)
81108064:	e1bffe17 	ldw	r6,-8(fp)
81108068:	01401444 	movi	r5,81
8110806c:	1009883a 	mov	r4,r2
81108070:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108074:	00800044 	movi	r2,1
81108078:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110807c:	e0bffd17 	ldw	r2,-12(fp)
}
81108080:	e037883a 	mov	sp,fp
81108084:	dfc00117 	ldw	ra,4(sp)
81108088:	df000017 	ldw	fp,0(sp)
8110808c:	dec00204 	addi	sp,sp,8
81108090:	f800283a 	ret

81108094 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81108094:	defffb04 	addi	sp,sp,-20
81108098:	de00012e 	bgeu	sp,et,811080a0 <bRmapGetMemConfigArea+0xc>
8110809c:	003b68fa 	trap	3
811080a0:	dfc00415 	stw	ra,16(sp)
811080a4:	df000315 	stw	fp,12(sp)
811080a8:	df000304 	addi	fp,sp,12
811080ac:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811080b0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811080b4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811080b8:	e0bfff17 	ldw	r2,-4(fp)
811080bc:	1000a426 	beq	r2,zero,81108350 <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811080c0:	e0bfff17 	ldw	r2,-4(fp)
811080c4:	10800017 	ldw	r2,0(r2)
811080c8:	01401004 	movi	r5,64
811080cc:	1009883a 	mov	r4,r2
811080d0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811080d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
811080d8:	e0bfff17 	ldw	r2,-4(fp)
811080dc:	e0fffe17 	ldw	r3,-8(fp)
811080e0:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811080e4:	e0bfff17 	ldw	r2,-4(fp)
811080e8:	10800017 	ldw	r2,0(r2)
811080ec:	01401044 	movi	r5,65
811080f0:	1009883a 	mov	r4,r2
811080f4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811080f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
811080fc:	e0bfff17 	ldw	r2,-4(fp)
81108100:	e0fffe17 	ldw	r3,-8(fp)
81108104:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108108:	e0bfff17 	ldw	r2,-4(fp)
8110810c:	10800017 	ldw	r2,0(r2)
81108110:	01401084 	movi	r5,66
81108114:	1009883a 	mov	r4,r2
81108118:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110811c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
81108120:	e0bfff17 	ldw	r2,-4(fp)
81108124:	e0fffe17 	ldw	r3,-8(fp)
81108128:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110812c:	e0bfff17 	ldw	r2,-4(fp)
81108130:	10800017 	ldw	r2,0(r2)
81108134:	014010c4 	movi	r5,67
81108138:	1009883a 	mov	r4,r2
8110813c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108140:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
81108144:	e0bfff17 	ldw	r2,-4(fp)
81108148:	e0fffe17 	ldw	r3,-8(fp)
8110814c:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108150:	e0bfff17 	ldw	r2,-4(fp)
81108154:	10800017 	ldw	r2,0(r2)
81108158:	01401104 	movi	r5,68
8110815c:	1009883a 	mov	r4,r2
81108160:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108164:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81108168:	e0bfff17 	ldw	r2,-4(fp)
8110816c:	e0fffe17 	ldw	r3,-8(fp)
81108170:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108174:	e0bfff17 	ldw	r2,-4(fp)
81108178:	10800017 	ldw	r2,0(r2)
8110817c:	01401144 	movi	r5,69
81108180:	1009883a 	mov	r4,r2
81108184:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108188:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
8110818c:	e0bfff17 	ldw	r2,-4(fp)
81108190:	e0fffe17 	ldw	r3,-8(fp)
81108194:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108198:	e0bfff17 	ldw	r2,-4(fp)
8110819c:	10800017 	ldw	r2,0(r2)
811081a0:	01401184 	movi	r5,70
811081a4:	1009883a 	mov	r4,r2
811081a8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811081ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
811081b0:	e0bfff17 	ldw	r2,-4(fp)
811081b4:	e0fffe17 	ldw	r3,-8(fp)
811081b8:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081bc:	e0bfff17 	ldw	r2,-4(fp)
811081c0:	10800017 	ldw	r2,0(r2)
811081c4:	014011c4 	movi	r5,71
811081c8:	1009883a 	mov	r4,r2
811081cc:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811081d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
811081d4:	e0bfff17 	ldw	r2,-4(fp)
811081d8:	e0fffe17 	ldw	r3,-8(fp)
811081dc:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081e0:	e0bfff17 	ldw	r2,-4(fp)
811081e4:	10800017 	ldw	r2,0(r2)
811081e8:	01401204 	movi	r5,72
811081ec:	1009883a 	mov	r4,r2
811081f0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811081f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
811081f8:	e0bfff17 	ldw	r2,-4(fp)
811081fc:	e0fffe17 	ldw	r3,-8(fp)
81108200:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108204:	e0bfff17 	ldw	r2,-4(fp)
81108208:	10800017 	ldw	r2,0(r2)
8110820c:	01401244 	movi	r5,73
81108210:	1009883a 	mov	r4,r2
81108214:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108218:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
8110821c:	e0bfff17 	ldw	r2,-4(fp)
81108220:	e0fffe17 	ldw	r3,-8(fp)
81108224:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108228:	e0bfff17 	ldw	r2,-4(fp)
8110822c:	10800017 	ldw	r2,0(r2)
81108230:	01401284 	movi	r5,74
81108234:	1009883a 	mov	r4,r2
81108238:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110823c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
81108240:	e0bfff17 	ldw	r2,-4(fp)
81108244:	e0fffe17 	ldw	r3,-8(fp)
81108248:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110824c:	e0bfff17 	ldw	r2,-4(fp)
81108250:	10800017 	ldw	r2,0(r2)
81108254:	014012c4 	movi	r5,75
81108258:	1009883a 	mov	r4,r2
8110825c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108260:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
81108264:	e0bfff17 	ldw	r2,-4(fp)
81108268:	e0fffe17 	ldw	r3,-8(fp)
8110826c:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108270:	e0bfff17 	ldw	r2,-4(fp)
81108274:	10800017 	ldw	r2,0(r2)
81108278:	01401304 	movi	r5,76
8110827c:	1009883a 	mov	r4,r2
81108280:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108284:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
81108288:	e0bfff17 	ldw	r2,-4(fp)
8110828c:	e0fffe17 	ldw	r3,-8(fp)
81108290:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108294:	e0bfff17 	ldw	r2,-4(fp)
81108298:	10800017 	ldw	r2,0(r2)
8110829c:	01401344 	movi	r5,77
811082a0:	1009883a 	mov	r4,r2
811082a4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811082a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
811082ac:	e0bfff17 	ldw	r2,-4(fp)
811082b0:	e0fffe17 	ldw	r3,-8(fp)
811082b4:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082b8:	e0bfff17 	ldw	r2,-4(fp)
811082bc:	10800017 	ldw	r2,0(r2)
811082c0:	01401384 	movi	r5,78
811082c4:	1009883a 	mov	r4,r2
811082c8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811082cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
811082d0:	e0bfff17 	ldw	r2,-4(fp)
811082d4:	e0fffe17 	ldw	r3,-8(fp)
811082d8:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082dc:	e0bfff17 	ldw	r2,-4(fp)
811082e0:	10800017 	ldw	r2,0(r2)
811082e4:	014013c4 	movi	r5,79
811082e8:	1009883a 	mov	r4,r2
811082ec:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811082f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811082f4:	e0bfff17 	ldw	r2,-4(fp)
811082f8:	e0fffe17 	ldw	r3,-8(fp)
811082fc:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108300:	e0bfff17 	ldw	r2,-4(fp)
81108304:	10800017 	ldw	r2,0(r2)
81108308:	01401404 	movi	r5,80
8110830c:	1009883a 	mov	r4,r2
81108310:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108314:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81108318:	e0bfff17 	ldw	r2,-4(fp)
8110831c:	e0fffe17 	ldw	r3,-8(fp)
81108320:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108324:	e0bfff17 	ldw	r2,-4(fp)
81108328:	10800017 	ldw	r2,0(r2)
8110832c:	01401444 	movi	r5,81
81108330:	1009883a 	mov	r4,r2
81108334:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108338:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
8110833c:	e0bfff17 	ldw	r2,-4(fp)
81108340:	e0fffe17 	ldw	r3,-8(fp)
81108344:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
81108348:	00800044 	movi	r2,1
8110834c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108350:	e0bffd17 	ldw	r2,-12(fp)
}
81108354:	e037883a 	mov	sp,fp
81108358:	dfc00117 	ldw	ra,4(sp)
8110835c:	df000017 	ldw	fp,0(sp)
81108360:	dec00204 	addi	sp,sp,8
81108364:	f800283a 	ret

81108368 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
81108368:	defffb04 	addi	sp,sp,-20
8110836c:	de00012e 	bgeu	sp,et,81108374 <bRmapGetMemConfigStat+0xc>
81108370:	003b68fa 	trap	3
81108374:	dfc00415 	stw	ra,16(sp)
81108378:	df000315 	stw	fp,12(sp)
8110837c:	df000304 	addi	fp,sp,12
81108380:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108384:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108388:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110838c:	e0bfff17 	ldw	r2,-4(fp)
81108390:	10001426 	beq	r2,zero,811083e4 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108394:	e0bfff17 	ldw	r2,-4(fp)
81108398:	10800017 	ldw	r2,0(r2)
8110839c:	014001c4 	movi	r5,7
811083a0:	1009883a 	mov	r4,r2
811083a4:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811083a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
811083ac:	e0bfff17 	ldw	r2,-4(fp)
811083b0:	e0fffe17 	ldw	r3,-8(fp)
811083b4:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083b8:	e0bfff17 	ldw	r2,-4(fp)
811083bc:	10800017 	ldw	r2,0(r2)
811083c0:	01400184 	movi	r5,6
811083c4:	1009883a 	mov	r4,r2
811083c8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811083cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
811083d0:	e0bfff17 	ldw	r2,-4(fp)
811083d4:	e0fffe17 	ldw	r3,-8(fp)
811083d8:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
811083dc:	00800044 	movi	r2,1
811083e0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811083e4:	e0bffd17 	ldw	r2,-12(fp)
}
811083e8:	e037883a 	mov	sp,fp
811083ec:	dfc00117 	ldw	ra,4(sp)
811083f0:	df000017 	ldw	fp,0(sp)
811083f4:	dec00204 	addi	sp,sp,8
811083f8:	f800283a 	ret

811083fc <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811083fc:	defffb04 	addi	sp,sp,-20
81108400:	de00012e 	bgeu	sp,et,81108408 <bRmapSetRmapMemHKArea+0xc>
81108404:	003b68fa 	trap	3
81108408:	dfc00415 	stw	ra,16(sp)
8110840c:	df000315 	stw	fp,12(sp)
81108410:	df000304 	addi	fp,sp,12
81108414:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108418:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110841c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108420:	e0bfff17 	ldw	r2,-4(fp)
81108424:	10040226 	beq	r2,zero,81109430 <bRmapSetRmapMemHKArea+0x1034>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108428:	e0bfff17 	ldw	r2,-4(fp)
8110842c:	10800017 	ldw	r2,0(r2)
81108430:	01402804 	movi	r5,160
81108434:	1009883a 	mov	r4,r2
81108438:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110843c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
81108440:	e0bffe17 	ldw	r2,-8(fp)
81108444:	10bfffec 	andhi	r2,r2,65535
81108448:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
8110844c:	e0bfff17 	ldw	r2,-4(fp)
81108450:	1080260b 	ldhu	r2,152(r2)
81108454:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
81108458:	e0fffe17 	ldw	r3,-8(fp)
8110845c:	1884b03a 	or	r2,r3,r2
81108460:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
81108464:	e0bffe17 	ldw	r2,-8(fp)
81108468:	10bfffcc 	andi	r2,r2,65535
8110846c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
81108470:	e0bfff17 	ldw	r2,-4(fp)
81108474:	1080268b 	ldhu	r2,154(r2)
81108478:	10bfffcc 	andi	r2,r2,65535
8110847c:	1004943a 	slli	r2,r2,16
81108480:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
81108484:	e0bffe17 	ldw	r2,-8(fp)
81108488:	10c4b03a 	or	r2,r2,r3
8110848c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
81108490:	e0bfff17 	ldw	r2,-4(fp)
81108494:	10800017 	ldw	r2,0(r2)
81108498:	e1bffe17 	ldw	r6,-8(fp)
8110849c:	01402804 	movi	r5,160
811084a0:	1009883a 	mov	r4,r2
811084a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084a8:	e0bfff17 	ldw	r2,-4(fp)
811084ac:	10800017 	ldw	r2,0(r2)
811084b0:	01402844 	movi	r5,161
811084b4:	1009883a 	mov	r4,r2
811084b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811084bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
811084c0:	e0bffe17 	ldw	r2,-8(fp)
811084c4:	10bfffec 	andhi	r2,r2,65535
811084c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
811084cc:	e0bfff17 	ldw	r2,-4(fp)
811084d0:	1080270b 	ldhu	r2,156(r2)
811084d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
811084d8:	e0fffe17 	ldw	r3,-8(fp)
811084dc:	1884b03a 	or	r2,r3,r2
811084e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
811084e4:	e0bffe17 	ldw	r2,-8(fp)
811084e8:	10bfffcc 	andi	r2,r2,65535
811084ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
811084f0:	e0bfff17 	ldw	r2,-4(fp)
811084f4:	1080278b 	ldhu	r2,158(r2)
811084f8:	10bfffcc 	andi	r2,r2,65535
811084fc:	1004943a 	slli	r2,r2,16
81108500:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
81108504:	e0bffe17 	ldw	r2,-8(fp)
81108508:	10c4b03a 	or	r2,r2,r3
8110850c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
81108510:	e0bfff17 	ldw	r2,-4(fp)
81108514:	10800017 	ldw	r2,0(r2)
81108518:	e1bffe17 	ldw	r6,-8(fp)
8110851c:	01402844 	movi	r5,161
81108520:	1009883a 	mov	r4,r2
81108524:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108528:	e0bfff17 	ldw	r2,-4(fp)
8110852c:	10800017 	ldw	r2,0(r2)
81108530:	01402884 	movi	r5,162
81108534:	1009883a 	mov	r4,r2
81108538:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110853c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
81108540:	e0bffe17 	ldw	r2,-8(fp)
81108544:	10bfffec 	andhi	r2,r2,65535
81108548:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
8110854c:	e0bfff17 	ldw	r2,-4(fp)
81108550:	1080280b 	ldhu	r2,160(r2)
81108554:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
81108558:	e0fffe17 	ldw	r3,-8(fp)
8110855c:	1884b03a 	or	r2,r3,r2
81108560:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
81108564:	e0bffe17 	ldw	r2,-8(fp)
81108568:	10bfffcc 	andi	r2,r2,65535
8110856c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
81108570:	e0bfff17 	ldw	r2,-4(fp)
81108574:	1080288b 	ldhu	r2,162(r2)
81108578:	10bfffcc 	andi	r2,r2,65535
8110857c:	1004943a 	slli	r2,r2,16
81108580:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
81108584:	e0bffe17 	ldw	r2,-8(fp)
81108588:	10c4b03a 	or	r2,r2,r3
8110858c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
81108590:	e0bfff17 	ldw	r2,-4(fp)
81108594:	10800017 	ldw	r2,0(r2)
81108598:	e1bffe17 	ldw	r6,-8(fp)
8110859c:	01402884 	movi	r5,162
811085a0:	1009883a 	mov	r4,r2
811085a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085a8:	e0bfff17 	ldw	r2,-4(fp)
811085ac:	10800017 	ldw	r2,0(r2)
811085b0:	014028c4 	movi	r5,163
811085b4:	1009883a 	mov	r4,r2
811085b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811085bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
811085c0:	e0bffe17 	ldw	r2,-8(fp)
811085c4:	10bfffec 	andhi	r2,r2,65535
811085c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
811085cc:	e0bfff17 	ldw	r2,-4(fp)
811085d0:	1080290b 	ldhu	r2,164(r2)
811085d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
811085d8:	e0fffe17 	ldw	r3,-8(fp)
811085dc:	1884b03a 	or	r2,r3,r2
811085e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
811085e4:	e0bffe17 	ldw	r2,-8(fp)
811085e8:	10bfffcc 	andi	r2,r2,65535
811085ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
811085f0:	e0bfff17 	ldw	r2,-4(fp)
811085f4:	1080298b 	ldhu	r2,166(r2)
811085f8:	10bfffcc 	andi	r2,r2,65535
811085fc:	1004943a 	slli	r2,r2,16
81108600:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
81108604:	e0bffe17 	ldw	r2,-8(fp)
81108608:	10c4b03a 	or	r2,r2,r3
8110860c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
81108610:	e0bfff17 	ldw	r2,-4(fp)
81108614:	10800017 	ldw	r2,0(r2)
81108618:	e1bffe17 	ldw	r6,-8(fp)
8110861c:	014028c4 	movi	r5,163
81108620:	1009883a 	mov	r4,r2
81108624:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108628:	e0bfff17 	ldw	r2,-4(fp)
8110862c:	10800017 	ldw	r2,0(r2)
81108630:	01402904 	movi	r5,164
81108634:	1009883a 	mov	r4,r2
81108638:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110863c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
81108640:	e0bffe17 	ldw	r2,-8(fp)
81108644:	10bfffec 	andhi	r2,r2,65535
81108648:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
8110864c:	e0bfff17 	ldw	r2,-4(fp)
81108650:	10802a0b 	ldhu	r2,168(r2)
81108654:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
81108658:	e0fffe17 	ldw	r3,-8(fp)
8110865c:	1884b03a 	or	r2,r3,r2
81108660:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
81108664:	e0bffe17 	ldw	r2,-8(fp)
81108668:	10bfffcc 	andi	r2,r2,65535
8110866c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
81108670:	e0bfff17 	ldw	r2,-4(fp)
81108674:	10802a8b 	ldhu	r2,170(r2)
81108678:	10bfffcc 	andi	r2,r2,65535
8110867c:	1004943a 	slli	r2,r2,16
81108680:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
81108684:	e0bffe17 	ldw	r2,-8(fp)
81108688:	10c4b03a 	or	r2,r2,r3
8110868c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
81108690:	e0bfff17 	ldw	r2,-4(fp)
81108694:	10800017 	ldw	r2,0(r2)
81108698:	e1bffe17 	ldw	r6,-8(fp)
8110869c:	01402904 	movi	r5,164
811086a0:	1009883a 	mov	r4,r2
811086a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086a8:	e0bfff17 	ldw	r2,-4(fp)
811086ac:	10800017 	ldw	r2,0(r2)
811086b0:	01402944 	movi	r5,165
811086b4:	1009883a 	mov	r4,r2
811086b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811086bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
811086c0:	e0bffe17 	ldw	r2,-8(fp)
811086c4:	10bfffec 	andhi	r2,r2,65535
811086c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
811086cc:	e0bfff17 	ldw	r2,-4(fp)
811086d0:	10802b0b 	ldhu	r2,172(r2)
811086d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
811086d8:	e0fffe17 	ldw	r3,-8(fp)
811086dc:	1884b03a 	or	r2,r3,r2
811086e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
811086e4:	e0bffe17 	ldw	r2,-8(fp)
811086e8:	10bfffcc 	andi	r2,r2,65535
811086ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
811086f0:	e0bfff17 	ldw	r2,-4(fp)
811086f4:	10802b8b 	ldhu	r2,174(r2)
811086f8:	10bfffcc 	andi	r2,r2,65535
811086fc:	1004943a 	slli	r2,r2,16
81108700:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
81108704:	e0bffe17 	ldw	r2,-8(fp)
81108708:	10c4b03a 	or	r2,r2,r3
8110870c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
81108710:	e0bfff17 	ldw	r2,-4(fp)
81108714:	10800017 	ldw	r2,0(r2)
81108718:	e1bffe17 	ldw	r6,-8(fp)
8110871c:	01402944 	movi	r5,165
81108720:	1009883a 	mov	r4,r2
81108724:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108728:	e0bfff17 	ldw	r2,-4(fp)
8110872c:	10800017 	ldw	r2,0(r2)
81108730:	01402984 	movi	r5,166
81108734:	1009883a 	mov	r4,r2
81108738:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110873c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
81108740:	e0bffe17 	ldw	r2,-8(fp)
81108744:	10bfffec 	andhi	r2,r2,65535
81108748:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
8110874c:	e0bfff17 	ldw	r2,-4(fp)
81108750:	10802c0b 	ldhu	r2,176(r2)
81108754:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
81108758:	e0fffe17 	ldw	r3,-8(fp)
8110875c:	1884b03a 	or	r2,r3,r2
81108760:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
81108764:	e0bffe17 	ldw	r2,-8(fp)
81108768:	10bfffcc 	andi	r2,r2,65535
8110876c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
81108770:	e0bfff17 	ldw	r2,-4(fp)
81108774:	10802c8b 	ldhu	r2,178(r2)
81108778:	10bfffcc 	andi	r2,r2,65535
8110877c:	1004943a 	slli	r2,r2,16
81108780:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
81108784:	e0bffe17 	ldw	r2,-8(fp)
81108788:	10c4b03a 	or	r2,r2,r3
8110878c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
81108790:	e0bfff17 	ldw	r2,-4(fp)
81108794:	10800017 	ldw	r2,0(r2)
81108798:	e1bffe17 	ldw	r6,-8(fp)
8110879c:	01402984 	movi	r5,166
811087a0:	1009883a 	mov	r4,r2
811087a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087a8:	e0bfff17 	ldw	r2,-4(fp)
811087ac:	10800017 	ldw	r2,0(r2)
811087b0:	014029c4 	movi	r5,167
811087b4:	1009883a 	mov	r4,r2
811087b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811087bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
811087c0:	e0bffe17 	ldw	r2,-8(fp)
811087c4:	10bfffec 	andhi	r2,r2,65535
811087c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
811087cc:	e0bfff17 	ldw	r2,-4(fp)
811087d0:	10802d0b 	ldhu	r2,180(r2)
811087d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
811087d8:	e0fffe17 	ldw	r3,-8(fp)
811087dc:	1884b03a 	or	r2,r3,r2
811087e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
811087e4:	e0bffe17 	ldw	r2,-8(fp)
811087e8:	10bfffcc 	andi	r2,r2,65535
811087ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
811087f0:	e0bfff17 	ldw	r2,-4(fp)
811087f4:	10802d8b 	ldhu	r2,182(r2)
811087f8:	10bfffcc 	andi	r2,r2,65535
811087fc:	1004943a 	slli	r2,r2,16
81108800:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
81108804:	e0bffe17 	ldw	r2,-8(fp)
81108808:	10c4b03a 	or	r2,r2,r3
8110880c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
81108810:	e0bfff17 	ldw	r2,-4(fp)
81108814:	10800017 	ldw	r2,0(r2)
81108818:	e1bffe17 	ldw	r6,-8(fp)
8110881c:	014029c4 	movi	r5,167
81108820:	1009883a 	mov	r4,r2
81108824:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108828:	e0bfff17 	ldw	r2,-4(fp)
8110882c:	10800017 	ldw	r2,0(r2)
81108830:	01402a04 	movi	r5,168
81108834:	1009883a 	mov	r4,r2
81108838:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110883c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
81108840:	e0bffe17 	ldw	r2,-8(fp)
81108844:	10bfffec 	andhi	r2,r2,65535
81108848:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
8110884c:	e0bfff17 	ldw	r2,-4(fp)
81108850:	10802e0b 	ldhu	r2,184(r2)
81108854:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81108858:	e0fffe17 	ldw	r3,-8(fp)
8110885c:	1884b03a 	or	r2,r3,r2
81108860:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
81108864:	e0bffe17 	ldw	r2,-8(fp)
81108868:	10bfffcc 	andi	r2,r2,65535
8110886c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
81108870:	e0bfff17 	ldw	r2,-4(fp)
81108874:	10802e8b 	ldhu	r2,186(r2)
81108878:	10bfffcc 	andi	r2,r2,65535
8110887c:	1004943a 	slli	r2,r2,16
81108880:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
81108884:	e0bffe17 	ldw	r2,-8(fp)
81108888:	10c4b03a 	or	r2,r2,r3
8110888c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81108890:	e0bfff17 	ldw	r2,-4(fp)
81108894:	10800017 	ldw	r2,0(r2)
81108898:	e1bffe17 	ldw	r6,-8(fp)
8110889c:	01402a04 	movi	r5,168
811088a0:	1009883a 	mov	r4,r2
811088a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088a8:	e0bfff17 	ldw	r2,-4(fp)
811088ac:	10800017 	ldw	r2,0(r2)
811088b0:	01402a44 	movi	r5,169
811088b4:	1009883a 	mov	r4,r2
811088b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811088bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
811088c0:	e0bffe17 	ldw	r2,-8(fp)
811088c4:	10bfffec 	andhi	r2,r2,65535
811088c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
811088cc:	e0bfff17 	ldw	r2,-4(fp)
811088d0:	10802f0b 	ldhu	r2,188(r2)
811088d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
811088d8:	e0fffe17 	ldw	r3,-8(fp)
811088dc:	1884b03a 	or	r2,r3,r2
811088e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
811088e4:	e0bffe17 	ldw	r2,-8(fp)
811088e8:	10bfffcc 	andi	r2,r2,65535
811088ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
811088f0:	e0bfff17 	ldw	r2,-4(fp)
811088f4:	10802f8b 	ldhu	r2,190(r2)
811088f8:	10bfffcc 	andi	r2,r2,65535
811088fc:	1004943a 	slli	r2,r2,16
81108900:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
81108904:	e0bffe17 	ldw	r2,-8(fp)
81108908:	10c4b03a 	or	r2,r2,r3
8110890c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
81108910:	e0bfff17 	ldw	r2,-4(fp)
81108914:	10800017 	ldw	r2,0(r2)
81108918:	e1bffe17 	ldw	r6,-8(fp)
8110891c:	01402a44 	movi	r5,169
81108920:	1009883a 	mov	r4,r2
81108924:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108928:	e0bfff17 	ldw	r2,-4(fp)
8110892c:	10800017 	ldw	r2,0(r2)
81108930:	01402a84 	movi	r5,170
81108934:	1009883a 	mov	r4,r2
81108938:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110893c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81108940:	e0bffe17 	ldw	r2,-8(fp)
81108944:	10bfffec 	andhi	r2,r2,65535
81108948:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
8110894c:	e0bfff17 	ldw	r2,-4(fp)
81108950:	1080300b 	ldhu	r2,192(r2)
81108954:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81108958:	e0fffe17 	ldw	r3,-8(fp)
8110895c:	1884b03a 	or	r2,r3,r2
81108960:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81108964:	e0bffe17 	ldw	r2,-8(fp)
81108968:	10bfffcc 	andi	r2,r2,65535
8110896c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
81108970:	e0bfff17 	ldw	r2,-4(fp)
81108974:	1080308b 	ldhu	r2,194(r2)
81108978:	10bfffcc 	andi	r2,r2,65535
8110897c:	1004943a 	slli	r2,r2,16
81108980:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
81108984:	e0bffe17 	ldw	r2,-8(fp)
81108988:	10c4b03a 	or	r2,r2,r3
8110898c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81108990:	e0bfff17 	ldw	r2,-4(fp)
81108994:	10800017 	ldw	r2,0(r2)
81108998:	e1bffe17 	ldw	r6,-8(fp)
8110899c:	01402a84 	movi	r5,170
811089a0:	1009883a 	mov	r4,r2
811089a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089a8:	e0bfff17 	ldw	r2,-4(fp)
811089ac:	10800017 	ldw	r2,0(r2)
811089b0:	01402ac4 	movi	r5,171
811089b4:	1009883a 	mov	r4,r2
811089b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811089bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
811089c0:	e0bffe17 	ldw	r2,-8(fp)
811089c4:	10bfffec 	andhi	r2,r2,65535
811089c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
811089cc:	e0bfff17 	ldw	r2,-4(fp)
811089d0:	1080310b 	ldhu	r2,196(r2)
811089d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
811089d8:	e0fffe17 	ldw	r3,-8(fp)
811089dc:	1884b03a 	or	r2,r3,r2
811089e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
811089e4:	e0bffe17 	ldw	r2,-8(fp)
811089e8:	10bfffcc 	andi	r2,r2,65535
811089ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
811089f0:	e0bfff17 	ldw	r2,-4(fp)
811089f4:	1080318b 	ldhu	r2,198(r2)
811089f8:	10bfffcc 	andi	r2,r2,65535
811089fc:	1004943a 	slli	r2,r2,16
81108a00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
81108a04:	e0bffe17 	ldw	r2,-8(fp)
81108a08:	10c4b03a 	or	r2,r2,r3
81108a0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81108a10:	e0bfff17 	ldw	r2,-4(fp)
81108a14:	10800017 	ldw	r2,0(r2)
81108a18:	e1bffe17 	ldw	r6,-8(fp)
81108a1c:	01402ac4 	movi	r5,171
81108a20:	1009883a 	mov	r4,r2
81108a24:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a28:	e0bfff17 	ldw	r2,-4(fp)
81108a2c:	10800017 	ldw	r2,0(r2)
81108a30:	01402b04 	movi	r5,172
81108a34:	1009883a 	mov	r4,r2
81108a38:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108a3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
81108a40:	e0bffe17 	ldw	r2,-8(fp)
81108a44:	10bfffec 	andhi	r2,r2,65535
81108a48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
81108a4c:	e0bfff17 	ldw	r2,-4(fp)
81108a50:	1080320b 	ldhu	r2,200(r2)
81108a54:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81108a58:	e0fffe17 	ldw	r3,-8(fp)
81108a5c:	1884b03a 	or	r2,r3,r2
81108a60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
81108a64:	e0bffe17 	ldw	r2,-8(fp)
81108a68:	10bfffcc 	andi	r2,r2,65535
81108a6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
81108a70:	e0bfff17 	ldw	r2,-4(fp)
81108a74:	1080328b 	ldhu	r2,202(r2)
81108a78:	10bfffcc 	andi	r2,r2,65535
81108a7c:	1004943a 	slli	r2,r2,16
81108a80:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
81108a84:	e0bffe17 	ldw	r2,-8(fp)
81108a88:	10c4b03a 	or	r2,r2,r3
81108a8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81108a90:	e0bfff17 	ldw	r2,-4(fp)
81108a94:	10800017 	ldw	r2,0(r2)
81108a98:	e1bffe17 	ldw	r6,-8(fp)
81108a9c:	01402b04 	movi	r5,172
81108aa0:	1009883a 	mov	r4,r2
81108aa4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108aa8:	e0bfff17 	ldw	r2,-4(fp)
81108aac:	10800017 	ldw	r2,0(r2)
81108ab0:	01402b44 	movi	r5,173
81108ab4:	1009883a 	mov	r4,r2
81108ab8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108abc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81108ac0:	e0bffe17 	ldw	r2,-8(fp)
81108ac4:	10bfffec 	andhi	r2,r2,65535
81108ac8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81108acc:	e0bfff17 	ldw	r2,-4(fp)
81108ad0:	1080330b 	ldhu	r2,204(r2)
81108ad4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81108ad8:	e0fffe17 	ldw	r3,-8(fp)
81108adc:	1884b03a 	or	r2,r3,r2
81108ae0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81108ae4:	e0bffe17 	ldw	r2,-8(fp)
81108ae8:	10bfffcc 	andi	r2,r2,65535
81108aec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
81108af0:	e0bfff17 	ldw	r2,-4(fp)
81108af4:	1080338b 	ldhu	r2,206(r2)
81108af8:	10bfffcc 	andi	r2,r2,65535
81108afc:	1004943a 	slli	r2,r2,16
81108b00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
81108b04:	e0bffe17 	ldw	r2,-8(fp)
81108b08:	10c4b03a 	or	r2,r2,r3
81108b0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81108b10:	e0bfff17 	ldw	r2,-4(fp)
81108b14:	10800017 	ldw	r2,0(r2)
81108b18:	e1bffe17 	ldw	r6,-8(fp)
81108b1c:	01402b44 	movi	r5,173
81108b20:	1009883a 	mov	r4,r2
81108b24:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b28:	e0bfff17 	ldw	r2,-4(fp)
81108b2c:	10800017 	ldw	r2,0(r2)
81108b30:	01402b84 	movi	r5,174
81108b34:	1009883a 	mov	r4,r2
81108b38:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108b3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81108b40:	e0bffe17 	ldw	r2,-8(fp)
81108b44:	10bfffec 	andhi	r2,r2,65535
81108b48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81108b4c:	e0bfff17 	ldw	r2,-4(fp)
81108b50:	1080340b 	ldhu	r2,208(r2)
81108b54:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81108b58:	e0fffe17 	ldw	r3,-8(fp)
81108b5c:	1884b03a 	or	r2,r3,r2
81108b60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81108b64:	e0bffe17 	ldw	r2,-8(fp)
81108b68:	10bfffcc 	andi	r2,r2,65535
81108b6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
81108b70:	e0bfff17 	ldw	r2,-4(fp)
81108b74:	1080348b 	ldhu	r2,210(r2)
81108b78:	10bfffcc 	andi	r2,r2,65535
81108b7c:	1004943a 	slli	r2,r2,16
81108b80:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
81108b84:	e0bffe17 	ldw	r2,-8(fp)
81108b88:	10c4b03a 	or	r2,r2,r3
81108b8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81108b90:	e0bfff17 	ldw	r2,-4(fp)
81108b94:	10800017 	ldw	r2,0(r2)
81108b98:	e1bffe17 	ldw	r6,-8(fp)
81108b9c:	01402b84 	movi	r5,174
81108ba0:	1009883a 	mov	r4,r2
81108ba4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ba8:	e0bfff17 	ldw	r2,-4(fp)
81108bac:	10800017 	ldw	r2,0(r2)
81108bb0:	01402bc4 	movi	r5,175
81108bb4:	1009883a 	mov	r4,r2
81108bb8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108bbc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81108bc0:	e0bffe17 	ldw	r2,-8(fp)
81108bc4:	10bfffec 	andhi	r2,r2,65535
81108bc8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81108bcc:	e0bfff17 	ldw	r2,-4(fp)
81108bd0:	1080350b 	ldhu	r2,212(r2)
81108bd4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81108bd8:	e0fffe17 	ldw	r3,-8(fp)
81108bdc:	1884b03a 	or	r2,r3,r2
81108be0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81108be4:	e0bffe17 	ldw	r2,-8(fp)
81108be8:	10bfffcc 	andi	r2,r2,65535
81108bec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
81108bf0:	e0bfff17 	ldw	r2,-4(fp)
81108bf4:	1080358b 	ldhu	r2,214(r2)
81108bf8:	10bfffcc 	andi	r2,r2,65535
81108bfc:	1004943a 	slli	r2,r2,16
81108c00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
81108c04:	e0bffe17 	ldw	r2,-8(fp)
81108c08:	10c4b03a 	or	r2,r2,r3
81108c0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81108c10:	e0bfff17 	ldw	r2,-4(fp)
81108c14:	10800017 	ldw	r2,0(r2)
81108c18:	e1bffe17 	ldw	r6,-8(fp)
81108c1c:	01402bc4 	movi	r5,175
81108c20:	1009883a 	mov	r4,r2
81108c24:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c28:	e0bfff17 	ldw	r2,-4(fp)
81108c2c:	10800017 	ldw	r2,0(r2)
81108c30:	01402c04 	movi	r5,176
81108c34:	1009883a 	mov	r4,r2
81108c38:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108c3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81108c40:	e0bffe17 	ldw	r2,-8(fp)
81108c44:	10bfffec 	andhi	r2,r2,65535
81108c48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81108c4c:	e0bfff17 	ldw	r2,-4(fp)
81108c50:	1080360b 	ldhu	r2,216(r2)
81108c54:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81108c58:	e0fffe17 	ldw	r3,-8(fp)
81108c5c:	1884b03a 	or	r2,r3,r2
81108c60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81108c64:	e0bffe17 	ldw	r2,-8(fp)
81108c68:	10bfffcc 	andi	r2,r2,65535
81108c6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
81108c70:	e0bfff17 	ldw	r2,-4(fp)
81108c74:	1080368b 	ldhu	r2,218(r2)
81108c78:	10bfffcc 	andi	r2,r2,65535
81108c7c:	1004943a 	slli	r2,r2,16
81108c80:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
81108c84:	e0bffe17 	ldw	r2,-8(fp)
81108c88:	10c4b03a 	or	r2,r2,r3
81108c8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81108c90:	e0bfff17 	ldw	r2,-4(fp)
81108c94:	10800017 	ldw	r2,0(r2)
81108c98:	e1bffe17 	ldw	r6,-8(fp)
81108c9c:	01402c04 	movi	r5,176
81108ca0:	1009883a 	mov	r4,r2
81108ca4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ca8:	e0bfff17 	ldw	r2,-4(fp)
81108cac:	10800017 	ldw	r2,0(r2)
81108cb0:	01402c44 	movi	r5,177
81108cb4:	1009883a 	mov	r4,r2
81108cb8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108cbc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81108cc0:	e0bffe17 	ldw	r2,-8(fp)
81108cc4:	10bfffec 	andhi	r2,r2,65535
81108cc8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81108ccc:	e0bfff17 	ldw	r2,-4(fp)
81108cd0:	1080370b 	ldhu	r2,220(r2)
81108cd4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81108cd8:	e0fffe17 	ldw	r3,-8(fp)
81108cdc:	1884b03a 	or	r2,r3,r2
81108ce0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81108ce4:	e0bffe17 	ldw	r2,-8(fp)
81108ce8:	10bfffcc 	andi	r2,r2,65535
81108cec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
81108cf0:	e0bfff17 	ldw	r2,-4(fp)
81108cf4:	1080378b 	ldhu	r2,222(r2)
81108cf8:	10bfffcc 	andi	r2,r2,65535
81108cfc:	1004943a 	slli	r2,r2,16
81108d00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
81108d04:	e0bffe17 	ldw	r2,-8(fp)
81108d08:	10c4b03a 	or	r2,r2,r3
81108d0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
81108d10:	e0bfff17 	ldw	r2,-4(fp)
81108d14:	10800017 	ldw	r2,0(r2)
81108d18:	e1bffe17 	ldw	r6,-8(fp)
81108d1c:	01402c44 	movi	r5,177
81108d20:	1009883a 	mov	r4,r2
81108d24:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d28:	e0bfff17 	ldw	r2,-4(fp)
81108d2c:	10800017 	ldw	r2,0(r2)
81108d30:	01402c84 	movi	r5,178
81108d34:	1009883a 	mov	r4,r2
81108d38:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108d3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81108d40:	e0bffe17 	ldw	r2,-8(fp)
81108d44:	10bfffec 	andhi	r2,r2,65535
81108d48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81108d4c:	e0bfff17 	ldw	r2,-4(fp)
81108d50:	1080380b 	ldhu	r2,224(r2)
81108d54:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81108d58:	e0fffe17 	ldw	r3,-8(fp)
81108d5c:	1884b03a 	or	r2,r3,r2
81108d60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81108d64:	e0bffe17 	ldw	r2,-8(fp)
81108d68:	10bfffcc 	andi	r2,r2,65535
81108d6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
81108d70:	e0bfff17 	ldw	r2,-4(fp)
81108d74:	1080388b 	ldhu	r2,226(r2)
81108d78:	10bfffcc 	andi	r2,r2,65535
81108d7c:	1004943a 	slli	r2,r2,16
81108d80:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
81108d84:	e0bffe17 	ldw	r2,-8(fp)
81108d88:	10c4b03a 	or	r2,r2,r3
81108d8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81108d90:	e0bfff17 	ldw	r2,-4(fp)
81108d94:	10800017 	ldw	r2,0(r2)
81108d98:	e1bffe17 	ldw	r6,-8(fp)
81108d9c:	01402c84 	movi	r5,178
81108da0:	1009883a 	mov	r4,r2
81108da4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108da8:	e0bfff17 	ldw	r2,-4(fp)
81108dac:	10800017 	ldw	r2,0(r2)
81108db0:	01402cc4 	movi	r5,179
81108db4:	1009883a 	mov	r4,r2
81108db8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108dbc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81108dc0:	e0bffe17 	ldw	r2,-8(fp)
81108dc4:	10bfffec 	andhi	r2,r2,65535
81108dc8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81108dcc:	e0bfff17 	ldw	r2,-4(fp)
81108dd0:	1080390b 	ldhu	r2,228(r2)
81108dd4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
81108dd8:	e0fffe17 	ldw	r3,-8(fp)
81108ddc:	1884b03a 	or	r2,r3,r2
81108de0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81108de4:	e0bffe17 	ldw	r2,-8(fp)
81108de8:	10bfffcc 	andi	r2,r2,65535
81108dec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
81108df0:	e0bfff17 	ldw	r2,-4(fp)
81108df4:	1080398b 	ldhu	r2,230(r2)
81108df8:	10bfffcc 	andi	r2,r2,65535
81108dfc:	1004943a 	slli	r2,r2,16
81108e00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
81108e04:	e0bffe17 	ldw	r2,-8(fp)
81108e08:	10c4b03a 	or	r2,r2,r3
81108e0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
81108e10:	e0bfff17 	ldw	r2,-4(fp)
81108e14:	10800017 	ldw	r2,0(r2)
81108e18:	e1bffe17 	ldw	r6,-8(fp)
81108e1c:	01402cc4 	movi	r5,179
81108e20:	1009883a 	mov	r4,r2
81108e24:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e28:	e0bfff17 	ldw	r2,-4(fp)
81108e2c:	10800017 	ldw	r2,0(r2)
81108e30:	01402d04 	movi	r5,180
81108e34:	1009883a 	mov	r4,r2
81108e38:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108e3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
81108e40:	e0bffe17 	ldw	r2,-8(fp)
81108e44:	10bfffec 	andhi	r2,r2,65535
81108e48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81108e4c:	e0bfff17 	ldw	r2,-4(fp)
81108e50:	10803a0b 	ldhu	r2,232(r2)
81108e54:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
81108e58:	e0fffe17 	ldw	r3,-8(fp)
81108e5c:	1884b03a 	or	r2,r3,r2
81108e60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81108e64:	e0bffe17 	ldw	r2,-8(fp)
81108e68:	10bfffcc 	andi	r2,r2,65535
81108e6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
81108e70:	e0bfff17 	ldw	r2,-4(fp)
81108e74:	10803a8b 	ldhu	r2,234(r2)
81108e78:	10bfffcc 	andi	r2,r2,65535
81108e7c:	1004943a 	slli	r2,r2,16
81108e80:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
81108e84:	e0bffe17 	ldw	r2,-8(fp)
81108e88:	10c4b03a 	or	r2,r2,r3
81108e8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81108e90:	e0bfff17 	ldw	r2,-4(fp)
81108e94:	10800017 	ldw	r2,0(r2)
81108e98:	e1bffe17 	ldw	r6,-8(fp)
81108e9c:	01402d04 	movi	r5,180
81108ea0:	1009883a 	mov	r4,r2
81108ea4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ea8:	e0bfff17 	ldw	r2,-4(fp)
81108eac:	10800017 	ldw	r2,0(r2)
81108eb0:	01402d44 	movi	r5,181
81108eb4:	1009883a 	mov	r4,r2
81108eb8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108ebc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
81108ec0:	e0bffe17 	ldw	r2,-8(fp)
81108ec4:	10bfffec 	andhi	r2,r2,65535
81108ec8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81108ecc:	e0bfff17 	ldw	r2,-4(fp)
81108ed0:	10803b0b 	ldhu	r2,236(r2)
81108ed4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81108ed8:	e0fffe17 	ldw	r3,-8(fp)
81108edc:	1884b03a 	or	r2,r3,r2
81108ee0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
81108ee4:	e0bffe17 	ldw	r2,-8(fp)
81108ee8:	10bfffcc 	andi	r2,r2,65535
81108eec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
81108ef0:	e0bfff17 	ldw	r2,-4(fp)
81108ef4:	10803b8b 	ldhu	r2,238(r2)
81108ef8:	10bfffcc 	andi	r2,r2,65535
81108efc:	1004943a 	slli	r2,r2,16
81108f00:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
81108f04:	e0bffe17 	ldw	r2,-8(fp)
81108f08:	10c4b03a 	or	r2,r2,r3
81108f0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
81108f10:	e0bfff17 	ldw	r2,-4(fp)
81108f14:	10800017 	ldw	r2,0(r2)
81108f18:	e1bffe17 	ldw	r6,-8(fp)
81108f1c:	01402d44 	movi	r5,181
81108f20:	1009883a 	mov	r4,r2
81108f24:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f28:	e0bfff17 	ldw	r2,-4(fp)
81108f2c:	10800017 	ldw	r2,0(r2)
81108f30:	01402d84 	movi	r5,182
81108f34:	1009883a 	mov	r4,r2
81108f38:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108f3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
81108f40:	e0bffe17 	ldw	r2,-8(fp)
81108f44:	10bfffec 	andhi	r2,r2,65535
81108f48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
81108f4c:	e0bfff17 	ldw	r2,-4(fp)
81108f50:	10803c0b 	ldhu	r2,240(r2)
81108f54:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
81108f58:	e0fffe17 	ldw	r3,-8(fp)
81108f5c:	1884b03a 	or	r2,r3,r2
81108f60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81108f64:	e0bffe17 	ldw	r2,-8(fp)
81108f68:	10bfffcc 	andi	r2,r2,65535
81108f6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
81108f70:	e0bfff17 	ldw	r2,-4(fp)
81108f74:	10803c8b 	ldhu	r2,242(r2)
81108f78:	10bfffcc 	andi	r2,r2,65535
81108f7c:	1004943a 	slli	r2,r2,16
81108f80:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
81108f84:	e0bffe17 	ldw	r2,-8(fp)
81108f88:	10c4b03a 	or	r2,r2,r3
81108f8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
81108f90:	e0bfff17 	ldw	r2,-4(fp)
81108f94:	10800017 	ldw	r2,0(r2)
81108f98:	e1bffe17 	ldw	r6,-8(fp)
81108f9c:	01402d84 	movi	r5,182
81108fa0:	1009883a 	mov	r4,r2
81108fa4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108fa8:	e0bfff17 	ldw	r2,-4(fp)
81108fac:	10800017 	ldw	r2,0(r2)
81108fb0:	01402dc4 	movi	r5,183
81108fb4:	1009883a 	mov	r4,r2
81108fb8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81108fbc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
81108fc0:	e0bffe17 	ldw	r2,-8(fp)
81108fc4:	10bfffec 	andhi	r2,r2,65535
81108fc8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
81108fcc:	e0bfff17 	ldw	r2,-4(fp)
81108fd0:	10803d0b 	ldhu	r2,244(r2)
81108fd4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
81108fd8:	e0fffe17 	ldw	r3,-8(fp)
81108fdc:	1884b03a 	or	r2,r3,r2
81108fe0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
81108fe4:	e0bffe17 	ldw	r2,-8(fp)
81108fe8:	10bfffcc 	andi	r2,r2,65535
81108fec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
81108ff0:	e0bfff17 	ldw	r2,-4(fp)
81108ff4:	10803d8b 	ldhu	r2,246(r2)
81108ff8:	10bfffcc 	andi	r2,r2,65535
81108ffc:	1004943a 	slli	r2,r2,16
81109000:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
81109004:	e0bffe17 	ldw	r2,-8(fp)
81109008:	10c4b03a 	or	r2,r2,r3
8110900c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
81109010:	e0bfff17 	ldw	r2,-4(fp)
81109014:	10800017 	ldw	r2,0(r2)
81109018:	e1bffe17 	ldw	r6,-8(fp)
8110901c:	01402dc4 	movi	r5,183
81109020:	1009883a 	mov	r4,r2
81109024:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109028:	e0bfff17 	ldw	r2,-4(fp)
8110902c:	10800017 	ldw	r2,0(r2)
81109030:	01402e04 	movi	r5,184
81109034:	1009883a 	mov	r4,r2
81109038:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110903c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
81109040:	e0bffe17 	ldw	r2,-8(fp)
81109044:	10bfffec 	andhi	r2,r2,65535
81109048:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
8110904c:	e0bfff17 	ldw	r2,-4(fp)
81109050:	10803e0b 	ldhu	r2,248(r2)
81109054:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
81109058:	e0fffe17 	ldw	r3,-8(fp)
8110905c:	1884b03a 	or	r2,r3,r2
81109060:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81109064:	e0bffe17 	ldw	r2,-8(fp)
81109068:	10bfffcc 	andi	r2,r2,65535
8110906c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
81109070:	e0bfff17 	ldw	r2,-4(fp)
81109074:	10803e8b 	ldhu	r2,250(r2)
81109078:	10bfffcc 	andi	r2,r2,65535
8110907c:	1004943a 	slli	r2,r2,16
81109080:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
81109084:	e0bffe17 	ldw	r2,-8(fp)
81109088:	10c4b03a 	or	r2,r2,r3
8110908c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81109090:	e0bfff17 	ldw	r2,-4(fp)
81109094:	10800017 	ldw	r2,0(r2)
81109098:	e1bffe17 	ldw	r6,-8(fp)
8110909c:	01402e04 	movi	r5,184
811090a0:	1009883a 	mov	r4,r2
811090a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811090a8:	e0bfff17 	ldw	r2,-4(fp)
811090ac:	10800017 	ldw	r2,0(r2)
811090b0:	01402e44 	movi	r5,185
811090b4:	1009883a 	mov	r4,r2
811090b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811090bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
811090c0:	e0bffe17 	ldw	r2,-8(fp)
811090c4:	10bfffec 	andhi	r2,r2,65535
811090c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
811090cc:	e0bfff17 	ldw	r2,-4(fp)
811090d0:	10803f0b 	ldhu	r2,252(r2)
811090d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
811090d8:	e0fffe17 	ldw	r3,-8(fp)
811090dc:	1884b03a 	or	r2,r3,r2
811090e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
811090e4:	e0bffe17 	ldw	r2,-8(fp)
811090e8:	10bfffcc 	andi	r2,r2,65535
811090ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
811090f0:	e0bfff17 	ldw	r2,-4(fp)
811090f4:	10803f8b 	ldhu	r2,254(r2)
811090f8:	10bfffcc 	andi	r2,r2,65535
811090fc:	1004943a 	slli	r2,r2,16
81109100:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
81109104:	e0bffe17 	ldw	r2,-8(fp)
81109108:	10c4b03a 	or	r2,r2,r3
8110910c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
81109110:	e0bfff17 	ldw	r2,-4(fp)
81109114:	10800017 	ldw	r2,0(r2)
81109118:	e1bffe17 	ldw	r6,-8(fp)
8110911c:	01402e44 	movi	r5,185
81109120:	1009883a 	mov	r4,r2
81109124:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109128:	e0bfff17 	ldw	r2,-4(fp)
8110912c:	10800017 	ldw	r2,0(r2)
81109130:	01402e84 	movi	r5,186
81109134:	1009883a 	mov	r4,r2
81109138:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110913c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
81109140:	e0bffe17 	ldw	r2,-8(fp)
81109144:	10bfffec 	andhi	r2,r2,65535
81109148:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
8110914c:	e0bfff17 	ldw	r2,-4(fp)
81109150:	1080400b 	ldhu	r2,256(r2)
81109154:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
81109158:	e0fffe17 	ldw	r3,-8(fp)
8110915c:	1884b03a 	or	r2,r3,r2
81109160:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81109164:	e0bffe17 	ldw	r2,-8(fp)
81109168:	10bfffcc 	andi	r2,r2,65535
8110916c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
81109170:	e0bfff17 	ldw	r2,-4(fp)
81109174:	1080408b 	ldhu	r2,258(r2)
81109178:	10bfffcc 	andi	r2,r2,65535
8110917c:	1004943a 	slli	r2,r2,16
81109180:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
81109184:	e0bffe17 	ldw	r2,-8(fp)
81109188:	10c4b03a 	or	r2,r2,r3
8110918c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
81109190:	e0bfff17 	ldw	r2,-4(fp)
81109194:	10800017 	ldw	r2,0(r2)
81109198:	e1bffe17 	ldw	r6,-8(fp)
8110919c:	01402e84 	movi	r5,186
811091a0:	1009883a 	mov	r4,r2
811091a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811091a8:	e0bfff17 	ldw	r2,-4(fp)
811091ac:	10800017 	ldw	r2,0(r2)
811091b0:	01402ec4 	movi	r5,187
811091b4:	1009883a 	mov	r4,r2
811091b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811091bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
811091c0:	e0bffe17 	ldw	r2,-8(fp)
811091c4:	10bfffec 	andhi	r2,r2,65535
811091c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
811091cc:	e0bfff17 	ldw	r2,-4(fp)
811091d0:	1080410b 	ldhu	r2,260(r2)
811091d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
811091d8:	e0fffe17 	ldw	r3,-8(fp)
811091dc:	1884b03a 	or	r2,r3,r2
811091e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
811091e4:	e0bffe17 	ldw	r2,-8(fp)
811091e8:	10bfffcc 	andi	r2,r2,65535
811091ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
811091f0:	e0bfff17 	ldw	r2,-4(fp)
811091f4:	1080418b 	ldhu	r2,262(r2)
811091f8:	10bfffcc 	andi	r2,r2,65535
811091fc:	1004943a 	slli	r2,r2,16
81109200:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
81109204:	e0bffe17 	ldw	r2,-8(fp)
81109208:	10c4b03a 	or	r2,r2,r3
8110920c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
81109210:	e0bfff17 	ldw	r2,-4(fp)
81109214:	10800017 	ldw	r2,0(r2)
81109218:	e1bffe17 	ldw	r6,-8(fp)
8110921c:	01402ec4 	movi	r5,187
81109220:	1009883a 	mov	r4,r2
81109224:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109228:	e0bfff17 	ldw	r2,-4(fp)
8110922c:	10800017 	ldw	r2,0(r2)
81109230:	01402f04 	movi	r5,188
81109234:	1009883a 	mov	r4,r2
81109238:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110923c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
81109240:	e0bffe17 	ldw	r2,-8(fp)
81109244:	10bfffec 	andhi	r2,r2,65535
81109248:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
8110924c:	e0bfff17 	ldw	r2,-4(fp)
81109250:	1080420b 	ldhu	r2,264(r2)
81109254:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
81109258:	e0fffe17 	ldw	r3,-8(fp)
8110925c:	1884b03a 	or	r2,r3,r2
81109260:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81109264:	e0bffe17 	ldw	r2,-8(fp)
81109268:	10bfffcc 	andi	r2,r2,65535
8110926c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
81109270:	e0bfff17 	ldw	r2,-4(fp)
81109274:	1080428b 	ldhu	r2,266(r2)
81109278:	10bfffcc 	andi	r2,r2,65535
8110927c:	1004943a 	slli	r2,r2,16
81109280:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
81109284:	e0bffe17 	ldw	r2,-8(fp)
81109288:	10c4b03a 	or	r2,r2,r3
8110928c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
81109290:	e0bfff17 	ldw	r2,-4(fp)
81109294:	10800017 	ldw	r2,0(r2)
81109298:	e1bffe17 	ldw	r6,-8(fp)
8110929c:	01402f04 	movi	r5,188
811092a0:	1009883a 	mov	r4,r2
811092a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811092a8:	e0bfff17 	ldw	r2,-4(fp)
811092ac:	10800017 	ldw	r2,0(r2)
811092b0:	01402f44 	movi	r5,189
811092b4:	1009883a 	mov	r4,r2
811092b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811092bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
811092c0:	e0bffe17 	ldw	r2,-8(fp)
811092c4:	10bfffec 	andhi	r2,r2,65535
811092c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
811092cc:	e0bfff17 	ldw	r2,-4(fp)
811092d0:	1080430b 	ldhu	r2,268(r2)
811092d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
811092d8:	e0fffe17 	ldw	r3,-8(fp)
811092dc:	1884b03a 	or	r2,r3,r2
811092e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
811092e4:	e0bffe17 	ldw	r2,-8(fp)
811092e8:	10bfffcc 	andi	r2,r2,65535
811092ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
811092f0:	e0bfff17 	ldw	r2,-4(fp)
811092f4:	1080438b 	ldhu	r2,270(r2)
811092f8:	10bfffcc 	andi	r2,r2,65535
811092fc:	1004943a 	slli	r2,r2,16
81109300:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
81109304:	e0bffe17 	ldw	r2,-8(fp)
81109308:	10c4b03a 	or	r2,r2,r3
8110930c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
81109310:	e0bfff17 	ldw	r2,-4(fp)
81109314:	10800017 	ldw	r2,0(r2)
81109318:	e1bffe17 	ldw	r6,-8(fp)
8110931c:	01402f44 	movi	r5,189
81109320:	1009883a 	mov	r4,r2
81109324:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109328:	e0bfff17 	ldw	r2,-4(fp)
8110932c:	10800017 	ldw	r2,0(r2)
81109330:	01402f84 	movi	r5,190
81109334:	1009883a 	mov	r4,r2
81109338:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110933c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
81109340:	e0bffe17 	ldw	r2,-8(fp)
81109344:	10bfffec 	andhi	r2,r2,65535
81109348:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
8110934c:	e0bfff17 	ldw	r2,-4(fp)
81109350:	1080440b 	ldhu	r2,272(r2)
81109354:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
81109358:	e0fffe17 	ldw	r3,-8(fp)
8110935c:	1884b03a 	or	r2,r3,r2
81109360:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81109364:	e0bffe17 	ldw	r2,-8(fp)
81109368:	10bfffcc 	andi	r2,r2,65535
8110936c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
81109370:	e0bfff17 	ldw	r2,-4(fp)
81109374:	1080448b 	ldhu	r2,274(r2)
81109378:	10bfffcc 	andi	r2,r2,65535
8110937c:	1004943a 	slli	r2,r2,16
81109380:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
81109384:	e0bffe17 	ldw	r2,-8(fp)
81109388:	10c4b03a 	or	r2,r2,r3
8110938c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
81109390:	e0bfff17 	ldw	r2,-4(fp)
81109394:	10800017 	ldw	r2,0(r2)
81109398:	e1bffe17 	ldw	r6,-8(fp)
8110939c:	01402f84 	movi	r5,190
811093a0:	1009883a 	mov	r4,r2
811093a4:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811093a8:	e0bfff17 	ldw	r2,-4(fp)
811093ac:	10800017 	ldw	r2,0(r2)
811093b0:	01402fc4 	movi	r5,191
811093b4:	1009883a 	mov	r4,r2
811093b8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811093bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
811093c0:	e0bffe17 	ldw	r2,-8(fp)
811093c4:	10bfffec 	andhi	r2,r2,65535
811093c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
811093cc:	e0bfff17 	ldw	r2,-4(fp)
811093d0:	1080450b 	ldhu	r2,276(r2)
811093d4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
811093d8:	e0fffe17 	ldw	r3,-8(fp)
811093dc:	1884b03a 	or	r2,r3,r2
811093e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
811093e4:	e0bffe17 	ldw	r2,-8(fp)
811093e8:	10bfffcc 	andi	r2,r2,65535
811093ec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
811093f0:	e0bfff17 	ldw	r2,-4(fp)
811093f4:	1080458b 	ldhu	r2,278(r2)
811093f8:	10bfffcc 	andi	r2,r2,65535
811093fc:	1004943a 	slli	r2,r2,16
81109400:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
81109404:	e0bffe17 	ldw	r2,-8(fp)
81109408:	10c4b03a 	or	r2,r2,r3
8110940c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
81109410:	e0bfff17 	ldw	r2,-4(fp)
81109414:	10800017 	ldw	r2,0(r2)
81109418:	e1bffe17 	ldw	r6,-8(fp)
8110941c:	01402fc4 	movi	r5,191
81109420:	1009883a 	mov	r4,r2
81109424:	1109db80 	call	81109db8 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81109428:	00800044 	movi	r2,1
8110942c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109430:	e0bffd17 	ldw	r2,-12(fp)
}
81109434:	e037883a 	mov	sp,fp
81109438:	dfc00117 	ldw	ra,4(sp)
8110943c:	df000017 	ldw	fp,0(sp)
81109440:	dec00204 	addi	sp,sp,8
81109444:	f800283a 	ret

81109448 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81109448:	defffb04 	addi	sp,sp,-20
8110944c:	de00012e 	bgeu	sp,et,81109454 <bRmapGetRmapMemHKArea+0xc>
81109450:	003b68fa 	trap	3
81109454:	dfc00415 	stw	ra,16(sp)
81109458:	df000315 	stw	fp,12(sp)
8110945c:	df000304 	addi	fp,sp,12
81109460:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109464:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109468:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110946c:	e0bfff17 	ldw	r2,-4(fp)
81109470:	1001e226 	beq	r2,zero,81109bfc <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109474:	e0bfff17 	ldw	r2,-4(fp)
81109478:	10800017 	ldw	r2,0(r2)
8110947c:	01402804 	movi	r5,160
81109480:	1009883a 	mov	r4,r2
81109484:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109488:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
8110948c:	e0bffe17 	ldw	r2,-8(fp)
81109490:	1007883a 	mov	r3,r2
81109494:	e0bfff17 	ldw	r2,-4(fp)
81109498:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
8110949c:	e0bffe17 	ldw	r2,-8(fp)
811094a0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
811094a4:	1007883a 	mov	r3,r2
811094a8:	e0bfff17 	ldw	r2,-4(fp)
811094ac:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811094b0:	e0bfff17 	ldw	r2,-4(fp)
811094b4:	10800017 	ldw	r2,0(r2)
811094b8:	01402844 	movi	r5,161
811094bc:	1009883a 	mov	r4,r2
811094c0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811094c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
811094c8:	e0bffe17 	ldw	r2,-8(fp)
811094cc:	1007883a 	mov	r3,r2
811094d0:	e0bfff17 	ldw	r2,-4(fp)
811094d4:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
811094d8:	e0bffe17 	ldw	r2,-8(fp)
811094dc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
811094e0:	1007883a 	mov	r3,r2
811094e4:	e0bfff17 	ldw	r2,-4(fp)
811094e8:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811094ec:	e0bfff17 	ldw	r2,-4(fp)
811094f0:	10800017 	ldw	r2,0(r2)
811094f4:	01402884 	movi	r5,162
811094f8:	1009883a 	mov	r4,r2
811094fc:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109500:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
81109504:	e0bffe17 	ldw	r2,-8(fp)
81109508:	1007883a 	mov	r3,r2
8110950c:	e0bfff17 	ldw	r2,-4(fp)
81109510:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
81109514:	e0bffe17 	ldw	r2,-8(fp)
81109518:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
8110951c:	1007883a 	mov	r3,r2
81109520:	e0bfff17 	ldw	r2,-4(fp)
81109524:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109528:	e0bfff17 	ldw	r2,-4(fp)
8110952c:	10800017 	ldw	r2,0(r2)
81109530:	014028c4 	movi	r5,163
81109534:	1009883a 	mov	r4,r2
81109538:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110953c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
81109540:	e0bffe17 	ldw	r2,-8(fp)
81109544:	1007883a 	mov	r3,r2
81109548:	e0bfff17 	ldw	r2,-4(fp)
8110954c:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
81109550:	e0bffe17 	ldw	r2,-8(fp)
81109554:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
81109558:	1007883a 	mov	r3,r2
8110955c:	e0bfff17 	ldw	r2,-4(fp)
81109560:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109564:	e0bfff17 	ldw	r2,-4(fp)
81109568:	10800017 	ldw	r2,0(r2)
8110956c:	01402904 	movi	r5,164
81109570:	1009883a 	mov	r4,r2
81109574:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109578:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
8110957c:	e0bffe17 	ldw	r2,-8(fp)
81109580:	1007883a 	mov	r3,r2
81109584:	e0bfff17 	ldw	r2,-4(fp)
81109588:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
8110958c:	e0bffe17 	ldw	r2,-8(fp)
81109590:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81109594:	1007883a 	mov	r3,r2
81109598:	e0bfff17 	ldw	r2,-4(fp)
8110959c:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095a0:	e0bfff17 	ldw	r2,-4(fp)
811095a4:	10800017 	ldw	r2,0(r2)
811095a8:	01402944 	movi	r5,165
811095ac:	1009883a 	mov	r4,r2
811095b0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811095b4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
811095b8:	e0bffe17 	ldw	r2,-8(fp)
811095bc:	1007883a 	mov	r3,r2
811095c0:	e0bfff17 	ldw	r2,-4(fp)
811095c4:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
811095c8:	e0bffe17 	ldw	r2,-8(fp)
811095cc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
811095d0:	1007883a 	mov	r3,r2
811095d4:	e0bfff17 	ldw	r2,-4(fp)
811095d8:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095dc:	e0bfff17 	ldw	r2,-4(fp)
811095e0:	10800017 	ldw	r2,0(r2)
811095e4:	01402984 	movi	r5,166
811095e8:	1009883a 	mov	r4,r2
811095ec:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811095f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
811095f4:	e0bffe17 	ldw	r2,-8(fp)
811095f8:	1007883a 	mov	r3,r2
811095fc:	e0bfff17 	ldw	r2,-4(fp)
81109600:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
81109604:	e0bffe17 	ldw	r2,-8(fp)
81109608:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
8110960c:	1007883a 	mov	r3,r2
81109610:	e0bfff17 	ldw	r2,-4(fp)
81109614:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109618:	e0bfff17 	ldw	r2,-4(fp)
8110961c:	10800017 	ldw	r2,0(r2)
81109620:	014029c4 	movi	r5,167
81109624:	1009883a 	mov	r4,r2
81109628:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110962c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
81109630:	e0bffe17 	ldw	r2,-8(fp)
81109634:	1007883a 	mov	r3,r2
81109638:	e0bfff17 	ldw	r2,-4(fp)
8110963c:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
81109640:	e0bffe17 	ldw	r2,-8(fp)
81109644:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
81109648:	1007883a 	mov	r3,r2
8110964c:	e0bfff17 	ldw	r2,-4(fp)
81109650:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109654:	e0bfff17 	ldw	r2,-4(fp)
81109658:	10800017 	ldw	r2,0(r2)
8110965c:	01402a04 	movi	r5,168
81109660:	1009883a 	mov	r4,r2
81109664:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109668:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
8110966c:	e0bffe17 	ldw	r2,-8(fp)
81109670:	1007883a 	mov	r3,r2
81109674:	e0bfff17 	ldw	r2,-4(fp)
81109678:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
8110967c:	e0bffe17 	ldw	r2,-8(fp)
81109680:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
81109684:	1007883a 	mov	r3,r2
81109688:	e0bfff17 	ldw	r2,-4(fp)
8110968c:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109690:	e0bfff17 	ldw	r2,-4(fp)
81109694:	10800017 	ldw	r2,0(r2)
81109698:	01402a44 	movi	r5,169
8110969c:	1009883a 	mov	r4,r2
811096a0:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811096a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
811096a8:	e0bffe17 	ldw	r2,-8(fp)
811096ac:	1007883a 	mov	r3,r2
811096b0:	e0bfff17 	ldw	r2,-4(fp)
811096b4:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
811096b8:	e0bffe17 	ldw	r2,-8(fp)
811096bc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
811096c0:	1007883a 	mov	r3,r2
811096c4:	e0bfff17 	ldw	r2,-4(fp)
811096c8:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811096cc:	e0bfff17 	ldw	r2,-4(fp)
811096d0:	10800017 	ldw	r2,0(r2)
811096d4:	01402a84 	movi	r5,170
811096d8:	1009883a 	mov	r4,r2
811096dc:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811096e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
811096e4:	e0bffe17 	ldw	r2,-8(fp)
811096e8:	1007883a 	mov	r3,r2
811096ec:	e0bfff17 	ldw	r2,-4(fp)
811096f0:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
811096f4:	e0bffe17 	ldw	r2,-8(fp)
811096f8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
811096fc:	1007883a 	mov	r3,r2
81109700:	e0bfff17 	ldw	r2,-4(fp)
81109704:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109708:	e0bfff17 	ldw	r2,-4(fp)
8110970c:	10800017 	ldw	r2,0(r2)
81109710:	01402ac4 	movi	r5,171
81109714:	1009883a 	mov	r4,r2
81109718:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110971c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
81109720:	e0bffe17 	ldw	r2,-8(fp)
81109724:	1007883a 	mov	r3,r2
81109728:	e0bfff17 	ldw	r2,-4(fp)
8110972c:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
81109730:	e0bffe17 	ldw	r2,-8(fp)
81109734:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
81109738:	1007883a 	mov	r3,r2
8110973c:	e0bfff17 	ldw	r2,-4(fp)
81109740:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109744:	e0bfff17 	ldw	r2,-4(fp)
81109748:	10800017 	ldw	r2,0(r2)
8110974c:	01402b04 	movi	r5,172
81109750:	1009883a 	mov	r4,r2
81109754:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109758:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
8110975c:	e0bffe17 	ldw	r2,-8(fp)
81109760:	1007883a 	mov	r3,r2
81109764:	e0bfff17 	ldw	r2,-4(fp)
81109768:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
8110976c:	e0bffe17 	ldw	r2,-8(fp)
81109770:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
81109774:	1007883a 	mov	r3,r2
81109778:	e0bfff17 	ldw	r2,-4(fp)
8110977c:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109780:	e0bfff17 	ldw	r2,-4(fp)
81109784:	10800017 	ldw	r2,0(r2)
81109788:	01402b44 	movi	r5,173
8110978c:	1009883a 	mov	r4,r2
81109790:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109794:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
81109798:	e0bffe17 	ldw	r2,-8(fp)
8110979c:	1007883a 	mov	r3,r2
811097a0:	e0bfff17 	ldw	r2,-4(fp)
811097a4:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
811097a8:	e0bffe17 	ldw	r2,-8(fp)
811097ac:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
811097b0:	1007883a 	mov	r3,r2
811097b4:	e0bfff17 	ldw	r2,-4(fp)
811097b8:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811097bc:	e0bfff17 	ldw	r2,-4(fp)
811097c0:	10800017 	ldw	r2,0(r2)
811097c4:	01402b84 	movi	r5,174
811097c8:	1009883a 	mov	r4,r2
811097cc:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811097d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
811097d4:	e0bffe17 	ldw	r2,-8(fp)
811097d8:	1007883a 	mov	r3,r2
811097dc:	e0bfff17 	ldw	r2,-4(fp)
811097e0:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
811097e4:	e0bffe17 	ldw	r2,-8(fp)
811097e8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
811097ec:	1007883a 	mov	r3,r2
811097f0:	e0bfff17 	ldw	r2,-4(fp)
811097f4:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811097f8:	e0bfff17 	ldw	r2,-4(fp)
811097fc:	10800017 	ldw	r2,0(r2)
81109800:	01402bc4 	movi	r5,175
81109804:	1009883a 	mov	r4,r2
81109808:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110980c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
81109810:	e0bffe17 	ldw	r2,-8(fp)
81109814:	1007883a 	mov	r3,r2
81109818:	e0bfff17 	ldw	r2,-4(fp)
8110981c:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
81109820:	e0bffe17 	ldw	r2,-8(fp)
81109824:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
81109828:	1007883a 	mov	r3,r2
8110982c:	e0bfff17 	ldw	r2,-4(fp)
81109830:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109834:	e0bfff17 	ldw	r2,-4(fp)
81109838:	10800017 	ldw	r2,0(r2)
8110983c:	01402c04 	movi	r5,176
81109840:	1009883a 	mov	r4,r2
81109844:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109848:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
8110984c:	e0bffe17 	ldw	r2,-8(fp)
81109850:	1007883a 	mov	r3,r2
81109854:	e0bfff17 	ldw	r2,-4(fp)
81109858:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
8110985c:	e0bffe17 	ldw	r2,-8(fp)
81109860:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
81109864:	1007883a 	mov	r3,r2
81109868:	e0bfff17 	ldw	r2,-4(fp)
8110986c:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109870:	e0bfff17 	ldw	r2,-4(fp)
81109874:	10800017 	ldw	r2,0(r2)
81109878:	01402c44 	movi	r5,177
8110987c:	1009883a 	mov	r4,r2
81109880:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109884:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
81109888:	e0bffe17 	ldw	r2,-8(fp)
8110988c:	1007883a 	mov	r3,r2
81109890:	e0bfff17 	ldw	r2,-4(fp)
81109894:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
81109898:	e0bffe17 	ldw	r2,-8(fp)
8110989c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
811098a0:	1007883a 	mov	r3,r2
811098a4:	e0bfff17 	ldw	r2,-4(fp)
811098a8:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098ac:	e0bfff17 	ldw	r2,-4(fp)
811098b0:	10800017 	ldw	r2,0(r2)
811098b4:	01402c84 	movi	r5,178
811098b8:	1009883a 	mov	r4,r2
811098bc:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811098c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
811098c4:	e0bffe17 	ldw	r2,-8(fp)
811098c8:	1007883a 	mov	r3,r2
811098cc:	e0bfff17 	ldw	r2,-4(fp)
811098d0:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
811098d4:	e0bffe17 	ldw	r2,-8(fp)
811098d8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
811098dc:	1007883a 	mov	r3,r2
811098e0:	e0bfff17 	ldw	r2,-4(fp)
811098e4:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098e8:	e0bfff17 	ldw	r2,-4(fp)
811098ec:	10800017 	ldw	r2,0(r2)
811098f0:	01402cc4 	movi	r5,179
811098f4:	1009883a 	mov	r4,r2
811098f8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811098fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
81109900:	e0bffe17 	ldw	r2,-8(fp)
81109904:	1007883a 	mov	r3,r2
81109908:	e0bfff17 	ldw	r2,-4(fp)
8110990c:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
81109910:	e0bffe17 	ldw	r2,-8(fp)
81109914:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
81109918:	1007883a 	mov	r3,r2
8110991c:	e0bfff17 	ldw	r2,-4(fp)
81109920:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109924:	e0bfff17 	ldw	r2,-4(fp)
81109928:	10800017 	ldw	r2,0(r2)
8110992c:	01402d04 	movi	r5,180
81109930:	1009883a 	mov	r4,r2
81109934:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109938:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
8110993c:	e0bffe17 	ldw	r2,-8(fp)
81109940:	1007883a 	mov	r3,r2
81109944:	e0bfff17 	ldw	r2,-4(fp)
81109948:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
8110994c:	e0bffe17 	ldw	r2,-8(fp)
81109950:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
81109954:	1007883a 	mov	r3,r2
81109958:	e0bfff17 	ldw	r2,-4(fp)
8110995c:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109960:	e0bfff17 	ldw	r2,-4(fp)
81109964:	10800017 	ldw	r2,0(r2)
81109968:	01402d44 	movi	r5,181
8110996c:	1009883a 	mov	r4,r2
81109970:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109974:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
81109978:	e0bffe17 	ldw	r2,-8(fp)
8110997c:	1007883a 	mov	r3,r2
81109980:	e0bfff17 	ldw	r2,-4(fp)
81109984:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
81109988:	e0bffe17 	ldw	r2,-8(fp)
8110998c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
81109990:	1007883a 	mov	r3,r2
81109994:	e0bfff17 	ldw	r2,-4(fp)
81109998:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110999c:	e0bfff17 	ldw	r2,-4(fp)
811099a0:	10800017 	ldw	r2,0(r2)
811099a4:	01402d84 	movi	r5,182
811099a8:	1009883a 	mov	r4,r2
811099ac:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811099b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
811099b4:	e0bffe17 	ldw	r2,-8(fp)
811099b8:	1007883a 	mov	r3,r2
811099bc:	e0bfff17 	ldw	r2,-4(fp)
811099c0:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
811099c4:	e0bffe17 	ldw	r2,-8(fp)
811099c8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
811099cc:	1007883a 	mov	r3,r2
811099d0:	e0bfff17 	ldw	r2,-4(fp)
811099d4:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811099d8:	e0bfff17 	ldw	r2,-4(fp)
811099dc:	10800017 	ldw	r2,0(r2)
811099e0:	01402dc4 	movi	r5,183
811099e4:	1009883a 	mov	r4,r2
811099e8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811099ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
811099f0:	e0bffe17 	ldw	r2,-8(fp)
811099f4:	1007883a 	mov	r3,r2
811099f8:	e0bfff17 	ldw	r2,-4(fp)
811099fc:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
81109a00:	e0bffe17 	ldw	r2,-8(fp)
81109a04:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
81109a08:	1007883a 	mov	r3,r2
81109a0c:	e0bfff17 	ldw	r2,-4(fp)
81109a10:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a14:	e0bfff17 	ldw	r2,-4(fp)
81109a18:	10800017 	ldw	r2,0(r2)
81109a1c:	01402e04 	movi	r5,184
81109a20:	1009883a 	mov	r4,r2
81109a24:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109a28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
81109a2c:	e0bffe17 	ldw	r2,-8(fp)
81109a30:	1007883a 	mov	r3,r2
81109a34:	e0bfff17 	ldw	r2,-4(fp)
81109a38:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
81109a3c:	e0bffe17 	ldw	r2,-8(fp)
81109a40:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
81109a44:	1007883a 	mov	r3,r2
81109a48:	e0bfff17 	ldw	r2,-4(fp)
81109a4c:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a50:	e0bfff17 	ldw	r2,-4(fp)
81109a54:	10800017 	ldw	r2,0(r2)
81109a58:	01402e44 	movi	r5,185
81109a5c:	1009883a 	mov	r4,r2
81109a60:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109a64:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81109a68:	e0bffe17 	ldw	r2,-8(fp)
81109a6c:	1007883a 	mov	r3,r2
81109a70:	e0bfff17 	ldw	r2,-4(fp)
81109a74:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
81109a78:	e0bffe17 	ldw	r2,-8(fp)
81109a7c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
81109a80:	1007883a 	mov	r3,r2
81109a84:	e0bfff17 	ldw	r2,-4(fp)
81109a88:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a8c:	e0bfff17 	ldw	r2,-4(fp)
81109a90:	10800017 	ldw	r2,0(r2)
81109a94:	01402e84 	movi	r5,186
81109a98:	1009883a 	mov	r4,r2
81109a9c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109aa0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
81109aa4:	e0bffe17 	ldw	r2,-8(fp)
81109aa8:	1007883a 	mov	r3,r2
81109aac:	e0bfff17 	ldw	r2,-4(fp)
81109ab0:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
81109ab4:	e0bffe17 	ldw	r2,-8(fp)
81109ab8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
81109abc:	1007883a 	mov	r3,r2
81109ac0:	e0bfff17 	ldw	r2,-4(fp)
81109ac4:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109ac8:	e0bfff17 	ldw	r2,-4(fp)
81109acc:	10800017 	ldw	r2,0(r2)
81109ad0:	01402ec4 	movi	r5,187
81109ad4:	1009883a 	mov	r4,r2
81109ad8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109adc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
81109ae0:	e0bffe17 	ldw	r2,-8(fp)
81109ae4:	1007883a 	mov	r3,r2
81109ae8:	e0bfff17 	ldw	r2,-4(fp)
81109aec:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
81109af0:	e0bffe17 	ldw	r2,-8(fp)
81109af4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
81109af8:	1007883a 	mov	r3,r2
81109afc:	e0bfff17 	ldw	r2,-4(fp)
81109b00:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b04:	e0bfff17 	ldw	r2,-4(fp)
81109b08:	10800017 	ldw	r2,0(r2)
81109b0c:	01402f04 	movi	r5,188
81109b10:	1009883a 	mov	r4,r2
81109b14:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109b18:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
81109b1c:	e0bffe17 	ldw	r2,-8(fp)
81109b20:	1007883a 	mov	r3,r2
81109b24:	e0bfff17 	ldw	r2,-4(fp)
81109b28:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
81109b2c:	e0bffe17 	ldw	r2,-8(fp)
81109b30:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
81109b34:	1007883a 	mov	r3,r2
81109b38:	e0bfff17 	ldw	r2,-4(fp)
81109b3c:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b40:	e0bfff17 	ldw	r2,-4(fp)
81109b44:	10800017 	ldw	r2,0(r2)
81109b48:	01402f44 	movi	r5,189
81109b4c:	1009883a 	mov	r4,r2
81109b50:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109b54:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81109b58:	e0bffe17 	ldw	r2,-8(fp)
81109b5c:	1007883a 	mov	r3,r2
81109b60:	e0bfff17 	ldw	r2,-4(fp)
81109b64:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81109b68:	e0bffe17 	ldw	r2,-8(fp)
81109b6c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
81109b70:	1007883a 	mov	r3,r2
81109b74:	e0bfff17 	ldw	r2,-4(fp)
81109b78:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b7c:	e0bfff17 	ldw	r2,-4(fp)
81109b80:	10800017 	ldw	r2,0(r2)
81109b84:	01402f84 	movi	r5,190
81109b88:	1009883a 	mov	r4,r2
81109b8c:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109b90:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
81109b94:	e0bffe17 	ldw	r2,-8(fp)
81109b98:	1007883a 	mov	r3,r2
81109b9c:	e0bfff17 	ldw	r2,-4(fp)
81109ba0:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
81109ba4:	e0bffe17 	ldw	r2,-8(fp)
81109ba8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
81109bac:	1007883a 	mov	r3,r2
81109bb0:	e0bfff17 	ldw	r2,-4(fp)
81109bb4:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109bb8:	e0bfff17 	ldw	r2,-4(fp)
81109bbc:	10800017 	ldw	r2,0(r2)
81109bc0:	01402fc4 	movi	r5,191
81109bc4:	1009883a 	mov	r4,r2
81109bc8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81109bcc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
81109bd0:	e0bffe17 	ldw	r2,-8(fp)
81109bd4:	1007883a 	mov	r3,r2
81109bd8:	e0bfff17 	ldw	r2,-4(fp)
81109bdc:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
81109be0:	e0bffe17 	ldw	r2,-8(fp)
81109be4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
81109be8:	1007883a 	mov	r3,r2
81109bec:	e0bfff17 	ldw	r2,-4(fp)
81109bf0:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
81109bf4:	00800044 	movi	r2,1
81109bf8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109bfc:	e0bffd17 	ldw	r2,-12(fp)
}
81109c00:	e037883a 	mov	sp,fp
81109c04:	dfc00117 	ldw	ra,4(sp)
81109c08:	df000017 	ldw	fp,0(sp)
81109c0c:	dec00204 	addi	sp,sp,8
81109c10:	f800283a 	ret

81109c14 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
81109c14:	defffb04 	addi	sp,sp,-20
81109c18:	de00012e 	bgeu	sp,et,81109c20 <bRmapInitCh+0xc>
81109c1c:	003b68fa 	trap	3
81109c20:	dfc00415 	stw	ra,16(sp)
81109c24:	df000315 	stw	fp,12(sp)
81109c28:	df000304 	addi	fp,sp,12
81109c2c:	e13ffe15 	stw	r4,-8(fp)
81109c30:	2805883a 	mov	r2,r5
81109c34:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81109c38:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81109c3c:	e0bffe17 	ldw	r2,-8(fp)
81109c40:	10005726 	beq	r2,zero,81109da0 <bRmapInitCh+0x18c>
		bStatus = TRUE;
81109c44:	00800044 	movi	r2,1
81109c48:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81109c4c:	e0bfff03 	ldbu	r2,-4(fp)
81109c50:	10c00228 	cmpgeui	r3,r2,8
81109c54:	1800361e 	bne	r3,zero,81109d30 <bRmapInitCh+0x11c>
81109c58:	100690ba 	slli	r3,r2,2
81109c5c:	00a04474 	movhi	r2,33041
81109c60:	10a71c04 	addi	r2,r2,-25488
81109c64:	1885883a 	add	r2,r3,r2
81109c68:	10800017 	ldw	r2,0(r2)
81109c6c:	1000683a 	jmp	r2
81109c70:	81109c90 	cmplti	r4,r16,17010
81109c74:	81109ca4 	muli	r4,r16,17010
81109c78:	81109cb8 	rdprs	r4,r16,17010
81109c7c:	81109ccc 	andi	r4,r16,17011
81109c80:	81109ce0 	cmpeqi	r4,r16,17011
81109c84:	81109cf4 	orhi	r4,r16,17011
81109c88:	81109d08 	cmpgei	r4,r16,17012
81109c8c:	81109d1c 	xori	r4,r16,17012
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81109c90:	e0fffe17 	ldw	r3,-8(fp)
81109c94:	00a04834 	movhi	r2,33056
81109c98:	108b0004 	addi	r2,r2,11264
81109c9c:	18800015 	stw	r2,0(r3)
			break;
81109ca0:	00002506 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81109ca4:	e0fffe17 	ldw	r3,-8(fp)
81109ca8:	00a04834 	movhi	r2,33056
81109cac:	108a0004 	addi	r2,r2,10240
81109cb0:	18800015 	stw	r2,0(r3)
			break;
81109cb4:	00002006 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81109cb8:	e0fffe17 	ldw	r3,-8(fp)
81109cbc:	00a04834 	movhi	r2,33056
81109cc0:	108b0004 	addi	r2,r2,11264
81109cc4:	18800015 	stw	r2,0(r3)
			break;
81109cc8:	00001b06 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81109ccc:	e0fffe17 	ldw	r3,-8(fp)
81109cd0:	00a04834 	movhi	r2,33056
81109cd4:	108a0004 	addi	r2,r2,10240
81109cd8:	18800015 	stw	r2,0(r3)
			break;
81109cdc:	00001606 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81109ce0:	e0fffe17 	ldw	r3,-8(fp)
81109ce4:	00a04834 	movhi	r2,33056
81109ce8:	108b0004 	addi	r2,r2,11264
81109cec:	18800015 	stw	r2,0(r3)
			break;
81109cf0:	00001106 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81109cf4:	e0fffe17 	ldw	r3,-8(fp)
81109cf8:	00a04834 	movhi	r2,33056
81109cfc:	108a0004 	addi	r2,r2,10240
81109d00:	18800015 	stw	r2,0(r3)
			break;
81109d04:	00000c06 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81109d08:	e0fffe17 	ldw	r3,-8(fp)
81109d0c:	00a04834 	movhi	r2,33056
81109d10:	108b0004 	addi	r2,r2,11264
81109d14:	18800015 	stw	r2,0(r3)
			break;
81109d18:	00000706 	br	81109d38 <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81109d1c:	e0fffe17 	ldw	r3,-8(fp)
81109d20:	00a04834 	movhi	r2,33056
81109d24:	108a0004 	addi	r2,r2,10240
81109d28:	18800015 	stw	r2,0(r3)
			break;
81109d2c:	00000206 	br	81109d38 <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
81109d30:	e03ffd15 	stw	zero,-12(fp)
			break;
81109d34:	0001883a 	nop
		}

		if (bStatus) {
81109d38:	e0bffd17 	ldw	r2,-12(fp)
81109d3c:	10001826 	beq	r2,zero,81109da0 <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
81109d40:	e13ffe17 	ldw	r4,-8(fp)
81109d44:	11078740 	call	81107874 <bRmapGetIrqControl>
81109d48:	1000011e 	bne	r2,zero,81109d50 <bRmapInitCh+0x13c>
				bStatus = FALSE;
81109d4c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
81109d50:	e13ffe17 	ldw	r4,-8(fp)
81109d54:	1107a5c0 	call	81107a5c <bRmapGetCodecConfig>
81109d58:	1000011e 	bne	r2,zero,81109d60 <bRmapInitCh+0x14c>
				bStatus = FALSE;
81109d5c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81109d60:	e13ffe17 	ldw	r4,-8(fp)
81109d64:	1107ae80 	call	81107ae8 <bRmapGetCodecStatus>
81109d68:	1000011e 	bne	r2,zero,81109d70 <bRmapInitCh+0x15c>
				bStatus = FALSE;
81109d6c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81109d70:	e13ffe17 	ldw	r4,-8(fp)
81109d74:	11080940 	call	81108094 <bRmapGetMemConfigArea>
81109d78:	1000011e 	bne	r2,zero,81109d80 <bRmapInitCh+0x16c>
				bStatus = FALSE;
81109d7c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
81109d80:	e13ffe17 	ldw	r4,-8(fp)
81109d84:	11083680 	call	81108368 <bRmapGetMemConfigStat>
81109d88:	1000011e 	bne	r2,zero,81109d90 <bRmapInitCh+0x17c>
				bStatus = FALSE;
81109d8c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
81109d90:	e13ffe17 	ldw	r4,-8(fp)
81109d94:	11094480 	call	81109448 <bRmapGetRmapMemHKArea>
81109d98:	1000011e 	bne	r2,zero,81109da0 <bRmapInitCh+0x18c>
				bStatus = FALSE;
81109d9c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81109da0:	e0bffd17 	ldw	r2,-12(fp)
}
81109da4:	e037883a 	mov	sp,fp
81109da8:	dfc00117 	ldw	ra,4(sp)
81109dac:	df000017 	ldw	fp,0(sp)
81109db0:	dec00204 	addi	sp,sp,8
81109db4:	f800283a 	ret

81109db8 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81109db8:	defffc04 	addi	sp,sp,-16
81109dbc:	de00012e 	bgeu	sp,et,81109dc4 <vRmapWriteReg+0xc>
81109dc0:	003b68fa 	trap	3
81109dc4:	df000315 	stw	fp,12(sp)
81109dc8:	df000304 	addi	fp,sp,12
81109dcc:	e13ffd15 	stw	r4,-12(fp)
81109dd0:	e17ffe15 	stw	r5,-8(fp)
81109dd4:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81109dd8:	e0bffe17 	ldw	r2,-8(fp)
81109ddc:	1085883a 	add	r2,r2,r2
81109de0:	1085883a 	add	r2,r2,r2
81109de4:	1007883a 	mov	r3,r2
81109de8:	e0bffd17 	ldw	r2,-12(fp)
81109dec:	10c5883a 	add	r2,r2,r3
81109df0:	e0ffff17 	ldw	r3,-4(fp)
81109df4:	10c00015 	stw	r3,0(r2)
}
81109df8:	0001883a 	nop
81109dfc:	e037883a 	mov	sp,fp
81109e00:	df000017 	ldw	fp,0(sp)
81109e04:	dec00104 	addi	sp,sp,4
81109e08:	f800283a 	ret

81109e0c <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81109e0c:	defffc04 	addi	sp,sp,-16
81109e10:	de00012e 	bgeu	sp,et,81109e18 <uliRmapReadReg+0xc>
81109e14:	003b68fa 	trap	3
81109e18:	df000315 	stw	fp,12(sp)
81109e1c:	df000304 	addi	fp,sp,12
81109e20:	e13ffe15 	stw	r4,-8(fp)
81109e24:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81109e28:	e0bfff17 	ldw	r2,-4(fp)
81109e2c:	1085883a 	add	r2,r2,r2
81109e30:	1085883a 	add	r2,r2,r2
81109e34:	1007883a 	mov	r3,r2
81109e38:	e0bffe17 	ldw	r2,-8(fp)
81109e3c:	10c5883a 	add	r2,r2,r3
81109e40:	10800017 	ldw	r2,0(r2)
81109e44:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81109e48:	e0bffd17 	ldw	r2,-12(fp)
}
81109e4c:	e037883a 	mov	sp,fp
81109e50:	df000017 	ldw	fp,0(sp)
81109e54:	dec00104 	addi	sp,sp,4
81109e58:	f800283a 	ret

81109e5c <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
81109e5c:	defffd04 	addi	sp,sp,-12
81109e60:	de00012e 	bgeu	sp,et,81109e68 <uliConvRmapCfgAddr+0xc>
81109e64:	003b68fa 	trap	3
81109e68:	df000215 	stw	fp,8(sp)
81109e6c:	df000204 	addi	fp,sp,8
81109e70:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
81109e74:	e0bfff17 	ldw	r2,-4(fp)
81109e78:	10801368 	cmpgeui	r2,r2,77
81109e7c:	10008a1e 	bne	r2,zero,8110a0a8 <uliConvRmapCfgAddr+0x24c>
81109e80:	e0bfff17 	ldw	r2,-4(fp)
81109e84:	100690ba 	slli	r3,r2,2
81109e88:	00a04474 	movhi	r2,33041
81109e8c:	10a7a704 	addi	r2,r2,-24932
81109e90:	1885883a 	add	r2,r3,r2
81109e94:	10800017 	ldw	r2,0(r2)
81109e98:	1000683a 	jmp	r2
81109e9c:	81109fd0 	cmplti	r4,r16,17023
81109ea0:	8110a0a8 	cmpgeui	r4,r16,17026
81109ea4:	8110a0a8 	cmpgeui	r4,r16,17026
81109ea8:	8110a0a8 	cmpgeui	r4,r16,17026
81109eac:	81109fdc 	xori	r4,r16,17023
81109eb0:	8110a0a8 	cmpgeui	r4,r16,17026
81109eb4:	8110a0a8 	cmpgeui	r4,r16,17026
81109eb8:	8110a0a8 	cmpgeui	r4,r16,17026
81109ebc:	81109fe8 	cmpgeui	r4,r16,17023
81109ec0:	8110a0a8 	cmpgeui	r4,r16,17026
81109ec4:	8110a0a8 	cmpgeui	r4,r16,17026
81109ec8:	8110a0a8 	cmpgeui	r4,r16,17026
81109ecc:	81109ff4 	orhi	r4,r16,17023
81109ed0:	8110a0a8 	cmpgeui	r4,r16,17026
81109ed4:	8110a0a8 	cmpgeui	r4,r16,17026
81109ed8:	8110a0a8 	cmpgeui	r4,r16,17026
81109edc:	8110a000 	call	88110a00 <__reset+0x20f0a00>
81109ee0:	8110a0a8 	cmpgeui	r4,r16,17026
81109ee4:	8110a0a8 	cmpgeui	r4,r16,17026
81109ee8:	8110a0a8 	cmpgeui	r4,r16,17026
81109eec:	8110a00c 	andi	r4,r16,17024
81109ef0:	8110a0a8 	cmpgeui	r4,r16,17026
81109ef4:	8110a0a8 	cmpgeui	r4,r16,17026
81109ef8:	8110a0a8 	cmpgeui	r4,r16,17026
81109efc:	8110a018 	cmpnei	r4,r16,17024
81109f00:	8110a0a8 	cmpgeui	r4,r16,17026
81109f04:	8110a0a8 	cmpgeui	r4,r16,17026
81109f08:	8110a0a8 	cmpgeui	r4,r16,17026
81109f0c:	8110a024 	muli	r4,r16,17024
81109f10:	8110a0a8 	cmpgeui	r4,r16,17026
81109f14:	8110a0a8 	cmpgeui	r4,r16,17026
81109f18:	8110a0a8 	cmpgeui	r4,r16,17026
81109f1c:	8110a030 	cmpltui	r4,r16,17024
81109f20:	8110a0a8 	cmpgeui	r4,r16,17026
81109f24:	8110a0a8 	cmpgeui	r4,r16,17026
81109f28:	8110a0a8 	cmpgeui	r4,r16,17026
81109f2c:	8110a03c 	xorhi	r4,r16,17024
81109f30:	8110a0a8 	cmpgeui	r4,r16,17026
81109f34:	8110a0a8 	cmpgeui	r4,r16,17026
81109f38:	8110a0a8 	cmpgeui	r4,r16,17026
81109f3c:	8110a048 	cmpgei	r4,r16,17025
81109f40:	8110a0a8 	cmpgeui	r4,r16,17026
81109f44:	8110a0a8 	cmpgeui	r4,r16,17026
81109f48:	8110a0a8 	cmpgeui	r4,r16,17026
81109f4c:	8110a054 	ori	r4,r16,17025
81109f50:	8110a0a8 	cmpgeui	r4,r16,17026
81109f54:	8110a0a8 	cmpgeui	r4,r16,17026
81109f58:	8110a0a8 	cmpgeui	r4,r16,17026
81109f5c:	8110a0a8 	cmpgeui	r4,r16,17026
81109f60:	8110a0a8 	cmpgeui	r4,r16,17026
81109f64:	8110a0a8 	cmpgeui	r4,r16,17026
81109f68:	8110a0a8 	cmpgeui	r4,r16,17026
81109f6c:	8110a0a8 	cmpgeui	r4,r16,17026
81109f70:	8110a0a8 	cmpgeui	r4,r16,17026
81109f74:	8110a0a8 	cmpgeui	r4,r16,17026
81109f78:	8110a0a8 	cmpgeui	r4,r16,17026
81109f7c:	8110a060 	cmpeqi	r4,r16,17025
81109f80:	8110a0a8 	cmpgeui	r4,r16,17026
81109f84:	8110a0a8 	cmpgeui	r4,r16,17026
81109f88:	8110a0a8 	cmpgeui	r4,r16,17026
81109f8c:	8110a06c 	andhi	r4,r16,17025
81109f90:	8110a0a8 	cmpgeui	r4,r16,17026
81109f94:	8110a0a8 	cmpgeui	r4,r16,17026
81109f98:	8110a0a8 	cmpgeui	r4,r16,17026
81109f9c:	8110a078 	rdprs	r4,r16,17025
81109fa0:	8110a0a8 	cmpgeui	r4,r16,17026
81109fa4:	8110a0a8 	cmpgeui	r4,r16,17026
81109fa8:	8110a0a8 	cmpgeui	r4,r16,17026
81109fac:	8110a084 	addi	r4,r16,17026
81109fb0:	8110a0a8 	cmpgeui	r4,r16,17026
81109fb4:	8110a0a8 	cmpgeui	r4,r16,17026
81109fb8:	8110a0a8 	cmpgeui	r4,r16,17026
81109fbc:	8110a090 	cmplti	r4,r16,17026
81109fc0:	8110a0a8 	cmpgeui	r4,r16,17026
81109fc4:	8110a0a8 	cmpgeui	r4,r16,17026
81109fc8:	8110a0a8 	cmpgeui	r4,r16,17026
81109fcc:	8110a09c 	xori	r4,r16,17026
	case 0x00000000:
		uliValue = 0x00000040;
81109fd0:	00801004 	movi	r2,64
81109fd4:	e0bffe15 	stw	r2,-8(fp)
		break;
81109fd8:	00003506 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
81109fdc:	00801044 	movi	r2,65
81109fe0:	e0bffe15 	stw	r2,-8(fp)
		break;
81109fe4:	00003206 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
81109fe8:	00801084 	movi	r2,66
81109fec:	e0bffe15 	stw	r2,-8(fp)
		break;
81109ff0:	00002f06 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
81109ff4:	008010c4 	movi	r2,67
81109ff8:	e0bffe15 	stw	r2,-8(fp)
		break;
81109ffc:	00002c06 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
8110a000:	00801104 	movi	r2,68
8110a004:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a008:	00002906 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
8110a00c:	00801144 	movi	r2,69
8110a010:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a014:	00002606 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
8110a018:	00801184 	movi	r2,70
8110a01c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a020:	00002306 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
8110a024:	008011c4 	movi	r2,71
8110a028:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a02c:	00002006 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
8110a030:	00801204 	movi	r2,72
8110a034:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a038:	00001d06 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
8110a03c:	00801244 	movi	r2,73
8110a040:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a044:	00001a06 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
8110a048:	00801284 	movi	r2,74
8110a04c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a050:	00001706 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
8110a054:	008012c4 	movi	r2,75
8110a058:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a05c:	00001406 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
8110a060:	00801304 	movi	r2,76
8110a064:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a068:	00001106 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
8110a06c:	00801344 	movi	r2,77
8110a070:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a074:	00000e06 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
8110a078:	00801384 	movi	r2,78
8110a07c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a080:	00000b06 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
8110a084:	008013c4 	movi	r2,79
8110a088:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a08c:	00000806 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
8110a090:	00801404 	movi	r2,80
8110a094:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a098:	00000506 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
8110a09c:	00801444 	movi	r2,81
8110a0a0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0a4:	00000206 	br	8110a0b0 <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
8110a0a8:	e03ffe15 	stw	zero,-8(fp)
		break;
8110a0ac:	0001883a 	nop
	}

	return uliValue;
8110a0b0:	e0bffe17 	ldw	r2,-8(fp)
}
8110a0b4:	e037883a 	mov	sp,fp
8110a0b8:	df000017 	ldw	fp,0(sp)
8110a0bc:	dec00104 	addi	sp,sp,4
8110a0c0:	f800283a 	ret

8110a0c4 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
8110a0c4:	defffb04 	addi	sp,sp,-20
8110a0c8:	de00012e 	bgeu	sp,et,8110a0d0 <bSpwcSetLink+0xc>
8110a0cc:	003b68fa 	trap	3
8110a0d0:	dfc00415 	stw	ra,16(sp)
8110a0d4:	df000315 	stw	fp,12(sp)
8110a0d8:	df000304 	addi	fp,sp,12
8110a0dc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a0e0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a0e4:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a0e8:	e0bfff17 	ldw	r2,-4(fp)
8110a0ec:	10003c26 	beq	r2,zero,8110a1e0 <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a0f0:	e0bfff17 	ldw	r2,-4(fp)
8110a0f4:	10800017 	ldw	r2,0(r2)
8110a0f8:	000b883a 	mov	r5,zero
8110a0fc:	1009883a 	mov	r4,r2
8110a100:	110a7900 	call	8110a790 <uliSpwcReadReg>
8110a104:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
8110a108:	e0bfff17 	ldw	r2,-4(fp)
8110a10c:	10800117 	ldw	r2,4(r2)
8110a110:	10000426 	beq	r2,zero,8110a124 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
8110a114:	e0bffe17 	ldw	r2,-8(fp)
8110a118:	10800114 	ori	r2,r2,4
8110a11c:	e0bffe15 	stw	r2,-8(fp)
8110a120:	00000406 	br	8110a134 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
8110a124:	e0fffe17 	ldw	r3,-8(fp)
8110a128:	00bffec4 	movi	r2,-5
8110a12c:	1884703a 	and	r2,r3,r2
8110a130:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
8110a134:	e0bfff17 	ldw	r2,-4(fp)
8110a138:	10800217 	ldw	r2,8(r2)
8110a13c:	10000426 	beq	r2,zero,8110a150 <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
8110a140:	e0bffe17 	ldw	r2,-8(fp)
8110a144:	10800094 	ori	r2,r2,2
8110a148:	e0bffe15 	stw	r2,-8(fp)
8110a14c:	00000406 	br	8110a160 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
8110a150:	e0fffe17 	ldw	r3,-8(fp)
8110a154:	00bfff44 	movi	r2,-3
8110a158:	1884703a 	and	r2,r3,r2
8110a15c:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
8110a160:	e0bfff17 	ldw	r2,-4(fp)
8110a164:	10800317 	ldw	r2,12(r2)
8110a168:	10000426 	beq	r2,zero,8110a17c <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
8110a16c:	e0bffe17 	ldw	r2,-8(fp)
8110a170:	10800054 	ori	r2,r2,1
8110a174:	e0bffe15 	stw	r2,-8(fp)
8110a178:	00000406 	br	8110a18c <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
8110a17c:	e0fffe17 	ldw	r3,-8(fp)
8110a180:	00bfff84 	movi	r2,-2
8110a184:	1884703a 	and	r2,r3,r2
8110a188:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
8110a18c:	e0fffe17 	ldw	r3,-8(fp)
8110a190:	00804034 	movhi	r2,256
8110a194:	10bfffc4 	addi	r2,r2,-1
8110a198:	1884703a 	and	r2,r3,r2
8110a19c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
8110a1a0:	e0bfff17 	ldw	r2,-4(fp)
8110a1a4:	10800403 	ldbu	r2,16(r2)
8110a1a8:	10803fcc 	andi	r2,r2,255
8110a1ac:	1004963a 	slli	r2,r2,24
8110a1b0:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
8110a1b4:	e0bffe17 	ldw	r2,-8(fp)
8110a1b8:	10c4b03a 	or	r2,r2,r3
8110a1bc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
8110a1c0:	e0bfff17 	ldw	r2,-4(fp)
8110a1c4:	10800017 	ldw	r2,0(r2)
8110a1c8:	e1bffe17 	ldw	r6,-8(fp)
8110a1cc:	000b883a 	mov	r5,zero
8110a1d0:	1009883a 	mov	r4,r2
8110a1d4:	110a73c0 	call	8110a73c <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
8110a1d8:	00800044 	movi	r2,1
8110a1dc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a1e0:	e0bffd17 	ldw	r2,-12(fp)
}
8110a1e4:	e037883a 	mov	sp,fp
8110a1e8:	dfc00117 	ldw	ra,4(sp)
8110a1ec:	df000017 	ldw	fp,0(sp)
8110a1f0:	dec00204 	addi	sp,sp,8
8110a1f4:	f800283a 	ret

8110a1f8 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
8110a1f8:	defffb04 	addi	sp,sp,-20
8110a1fc:	de00012e 	bgeu	sp,et,8110a204 <bSpwcGetLink+0xc>
8110a200:	003b68fa 	trap	3
8110a204:	dfc00415 	stw	ra,16(sp)
8110a208:	df000315 	stw	fp,12(sp)
8110a20c:	df000304 	addi	fp,sp,12
8110a210:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a214:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a218:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a21c:	e0bfff17 	ldw	r2,-4(fp)
8110a220:	10002826 	beq	r2,zero,8110a2c4 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a224:	e0bfff17 	ldw	r2,-4(fp)
8110a228:	10800017 	ldw	r2,0(r2)
8110a22c:	000b883a 	mov	r5,zero
8110a230:	1009883a 	mov	r4,r2
8110a234:	110a7900 	call	8110a790 <uliSpwcReadReg>
8110a238:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
8110a23c:	e0bffe17 	ldw	r2,-8(fp)
8110a240:	1080010c 	andi	r2,r2,4
8110a244:	10000426 	beq	r2,zero,8110a258 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
8110a248:	e0bfff17 	ldw	r2,-4(fp)
8110a24c:	00c00044 	movi	r3,1
8110a250:	10c00115 	stw	r3,4(r2)
8110a254:	00000206 	br	8110a260 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
8110a258:	e0bfff17 	ldw	r2,-4(fp)
8110a25c:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
8110a260:	e0bffe17 	ldw	r2,-8(fp)
8110a264:	1080008c 	andi	r2,r2,2
8110a268:	10000426 	beq	r2,zero,8110a27c <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
8110a26c:	e0bfff17 	ldw	r2,-4(fp)
8110a270:	00c00044 	movi	r3,1
8110a274:	10c00215 	stw	r3,8(r2)
8110a278:	00000206 	br	8110a284 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
8110a27c:	e0bfff17 	ldw	r2,-4(fp)
8110a280:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
8110a284:	e0bffe17 	ldw	r2,-8(fp)
8110a288:	1080004c 	andi	r2,r2,1
8110a28c:	10000426 	beq	r2,zero,8110a2a0 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
8110a290:	e0bfff17 	ldw	r2,-4(fp)
8110a294:	00c00044 	movi	r3,1
8110a298:	10c00315 	stw	r3,12(r2)
8110a29c:	00000206 	br	8110a2a8 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
8110a2a0:	e0bfff17 	ldw	r2,-4(fp)
8110a2a4:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
8110a2a8:	e0bffe17 	ldw	r2,-8(fp)
8110a2ac:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
8110a2b0:	1007883a 	mov	r3,r2
8110a2b4:	e0bfff17 	ldw	r2,-4(fp)
8110a2b8:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
8110a2bc:	00800044 	movi	r2,1
8110a2c0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a2c4:	e0bffd17 	ldw	r2,-12(fp)
}
8110a2c8:	e037883a 	mov	sp,fp
8110a2cc:	dfc00117 	ldw	ra,4(sp)
8110a2d0:	df000017 	ldw	fp,0(sp)
8110a2d4:	dec00204 	addi	sp,sp,8
8110a2d8:	f800283a 	ret

8110a2dc <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8110a2dc:	defffb04 	addi	sp,sp,-20
8110a2e0:	de00012e 	bgeu	sp,et,8110a2e8 <bSpwcGetLinkError+0xc>
8110a2e4:	003b68fa 	trap	3
8110a2e8:	dfc00415 	stw	ra,16(sp)
8110a2ec:	df000315 	stw	fp,12(sp)
8110a2f0:	df000304 	addi	fp,sp,12
8110a2f4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a2f8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a2fc:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a300:	e0bfff17 	ldw	r2,-4(fp)
8110a304:	10002c26 	beq	r2,zero,8110a3b8 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a308:	e0bfff17 	ldw	r2,-4(fp)
8110a30c:	10800017 	ldw	r2,0(r2)
8110a310:	000b883a 	mov	r5,zero
8110a314:	1009883a 	mov	r4,r2
8110a318:	110a7900 	call	8110a790 <uliSpwcReadReg>
8110a31c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
8110a320:	e0bffe17 	ldw	r2,-8(fp)
8110a324:	1080006c 	andhi	r2,r2,1
8110a328:	10000426 	beq	r2,zero,8110a33c <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
8110a32c:	e0bfff17 	ldw	r2,-4(fp)
8110a330:	00c00044 	movi	r3,1
8110a334:	10c00515 	stw	r3,20(r2)
8110a338:	00000206 	br	8110a344 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
8110a33c:	e0bfff17 	ldw	r2,-4(fp)
8110a340:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
8110a344:	e0bffe17 	ldw	r2,-8(fp)
8110a348:	108000ac 	andhi	r2,r2,2
8110a34c:	10000426 	beq	r2,zero,8110a360 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
8110a350:	e0bfff17 	ldw	r2,-4(fp)
8110a354:	00c00044 	movi	r3,1
8110a358:	10c00615 	stw	r3,24(r2)
8110a35c:	00000206 	br	8110a368 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
8110a360:	e0bfff17 	ldw	r2,-4(fp)
8110a364:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
8110a368:	e0bffe17 	ldw	r2,-8(fp)
8110a36c:	1080012c 	andhi	r2,r2,4
8110a370:	10000426 	beq	r2,zero,8110a384 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
8110a374:	e0bfff17 	ldw	r2,-4(fp)
8110a378:	00c00044 	movi	r3,1
8110a37c:	10c00715 	stw	r3,28(r2)
8110a380:	00000206 	br	8110a38c <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
8110a384:	e0bfff17 	ldw	r2,-4(fp)
8110a388:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
8110a38c:	e0bffe17 	ldw	r2,-8(fp)
8110a390:	1080022c 	andhi	r2,r2,8
8110a394:	10000426 	beq	r2,zero,8110a3a8 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
8110a398:	e0bfff17 	ldw	r2,-4(fp)
8110a39c:	00c00044 	movi	r3,1
8110a3a0:	10c00815 	stw	r3,32(r2)
8110a3a4:	00000206 	br	8110a3b0 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
8110a3a8:	e0bfff17 	ldw	r2,-4(fp)
8110a3ac:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
8110a3b0:	00800044 	movi	r2,1
8110a3b4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a3b8:	e0bffd17 	ldw	r2,-12(fp)
}
8110a3bc:	e037883a 	mov	sp,fp
8110a3c0:	dfc00117 	ldw	ra,4(sp)
8110a3c4:	df000017 	ldw	fp,0(sp)
8110a3c8:	dec00204 	addi	sp,sp,8
8110a3cc:	f800283a 	ret

8110a3d0 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
8110a3d0:	defffb04 	addi	sp,sp,-20
8110a3d4:	de00012e 	bgeu	sp,et,8110a3dc <bSpwcGetLinkStatus+0xc>
8110a3d8:	003b68fa 	trap	3
8110a3dc:	dfc00415 	stw	ra,16(sp)
8110a3e0:	df000315 	stw	fp,12(sp)
8110a3e4:	df000304 	addi	fp,sp,12
8110a3e8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a3ec:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a3f0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a3f4:	e0bfff17 	ldw	r2,-4(fp)
8110a3f8:	10002326 	beq	r2,zero,8110a488 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a3fc:	e0bfff17 	ldw	r2,-4(fp)
8110a400:	10800017 	ldw	r2,0(r2)
8110a404:	000b883a 	mov	r5,zero
8110a408:	1009883a 	mov	r4,r2
8110a40c:	110a7900 	call	8110a790 <uliSpwcReadReg>
8110a410:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
8110a414:	e0bffe17 	ldw	r2,-8(fp)
8110a418:	1081000c 	andi	r2,r2,1024
8110a41c:	10000426 	beq	r2,zero,8110a430 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
8110a420:	e0bfff17 	ldw	r2,-4(fp)
8110a424:	00c00044 	movi	r3,1
8110a428:	10c00915 	stw	r3,36(r2)
8110a42c:	00000206 	br	8110a438 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
8110a430:	e0bfff17 	ldw	r2,-4(fp)
8110a434:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
8110a438:	e0bffe17 	ldw	r2,-8(fp)
8110a43c:	1080800c 	andi	r2,r2,512
8110a440:	10000426 	beq	r2,zero,8110a454 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
8110a444:	e0bfff17 	ldw	r2,-4(fp)
8110a448:	00c00044 	movi	r3,1
8110a44c:	10c00a15 	stw	r3,40(r2)
8110a450:	00000206 	br	8110a45c <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
8110a454:	e0bfff17 	ldw	r2,-4(fp)
8110a458:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
8110a45c:	e0bffe17 	ldw	r2,-8(fp)
8110a460:	1080400c 	andi	r2,r2,256
8110a464:	10000426 	beq	r2,zero,8110a478 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
8110a468:	e0bfff17 	ldw	r2,-4(fp)
8110a46c:	00c00044 	movi	r3,1
8110a470:	10c00b15 	stw	r3,44(r2)
8110a474:	00000206 	br	8110a480 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
8110a478:	e0bfff17 	ldw	r2,-4(fp)
8110a47c:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
8110a480:	00800044 	movi	r2,1
8110a484:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a488:	e0bffd17 	ldw	r2,-12(fp)
}
8110a48c:	e037883a 	mov	sp,fp
8110a490:	dfc00117 	ldw	ra,4(sp)
8110a494:	df000017 	ldw	fp,0(sp)
8110a498:	dec00204 	addi	sp,sp,8
8110a49c:	f800283a 	ret

8110a4a0 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
8110a4a0:	defffb04 	addi	sp,sp,-20
8110a4a4:	de00012e 	bgeu	sp,et,8110a4ac <bSpwcGetTimecode+0xc>
8110a4a8:	003b68fa 	trap	3
8110a4ac:	dfc00415 	stw	ra,16(sp)
8110a4b0:	df000315 	stw	fp,12(sp)
8110a4b4:	df000304 	addi	fp,sp,12
8110a4b8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a4bc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a4c0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a4c4:	e0bfff17 	ldw	r2,-4(fp)
8110a4c8:	10001326 	beq	r2,zero,8110a518 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a4cc:	e0bfff17 	ldw	r2,-4(fp)
8110a4d0:	10800017 	ldw	r2,0(r2)
8110a4d4:	01400044 	movi	r5,1
8110a4d8:	1009883a 	mov	r4,r2
8110a4dc:	110a7900 	call	8110a790 <uliSpwcReadReg>
8110a4e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
8110a4e4:	e0bffe17 	ldw	r2,-8(fp)
8110a4e8:	1080300c 	andi	r2,r2,192
8110a4ec:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
8110a4f0:	1007883a 	mov	r3,r2
8110a4f4:	e0bfff17 	ldw	r2,-4(fp)
8110a4f8:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
8110a4fc:	e0bffe17 	ldw	r2,-8(fp)
8110a500:	10800fcc 	andi	r2,r2,63
8110a504:	1007883a 	mov	r3,r2
8110a508:	e0bfff17 	ldw	r2,-4(fp)
8110a50c:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
8110a510:	00800044 	movi	r2,1
8110a514:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a518:	e0bffd17 	ldw	r2,-12(fp)
}
8110a51c:	e037883a 	mov	sp,fp
8110a520:	dfc00117 	ldw	ra,4(sp)
8110a524:	df000017 	ldw	fp,0(sp)
8110a528:	dec00204 	addi	sp,sp,8
8110a52c:	f800283a 	ret

8110a530 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
8110a530:	defffb04 	addi	sp,sp,-20
8110a534:	de00012e 	bgeu	sp,et,8110a53c <bSpwcClearTimecode+0xc>
8110a538:	003b68fa 	trap	3
8110a53c:	dfc00415 	stw	ra,16(sp)
8110a540:	df000315 	stw	fp,12(sp)
8110a544:	df000304 	addi	fp,sp,12
8110a548:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a54c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a550:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a554:	e0bfff17 	ldw	r2,-4(fp)
8110a558:	10001126 	beq	r2,zero,8110a5a0 <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a55c:	e0bfff17 	ldw	r2,-4(fp)
8110a560:	10800017 	ldw	r2,0(r2)
8110a564:	01400044 	movi	r5,1
8110a568:	1009883a 	mov	r4,r2
8110a56c:	110a7900 	call	8110a790 <uliSpwcReadReg>
8110a570:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
8110a574:	e0bffe17 	ldw	r2,-8(fp)
8110a578:	10804014 	ori	r2,r2,256
8110a57c:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
8110a580:	e0bfff17 	ldw	r2,-4(fp)
8110a584:	10800017 	ldw	r2,0(r2)
8110a588:	e1bffe17 	ldw	r6,-8(fp)
8110a58c:	01400044 	movi	r5,1
8110a590:	1009883a 	mov	r4,r2
8110a594:	110a73c0 	call	8110a73c <vSpwcWriteReg>
		bStatus = TRUE;
8110a598:	00800044 	movi	r2,1
8110a59c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a5a0:	e0bffd17 	ldw	r2,-12(fp)
}
8110a5a4:	e037883a 	mov	sp,fp
8110a5a8:	dfc00117 	ldw	ra,4(sp)
8110a5ac:	df000017 	ldw	fp,0(sp)
8110a5b0:	dec00204 	addi	sp,sp,8
8110a5b4:	f800283a 	ret

8110a5b8 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
8110a5b8:	defffb04 	addi	sp,sp,-20
8110a5bc:	de00012e 	bgeu	sp,et,8110a5c4 <bSpwcInitCh+0xc>
8110a5c0:	003b68fa 	trap	3
8110a5c4:	dfc00415 	stw	ra,16(sp)
8110a5c8:	df000315 	stw	fp,12(sp)
8110a5cc:	df000304 	addi	fp,sp,12
8110a5d0:	e13ffe15 	stw	r4,-8(fp)
8110a5d4:	2805883a 	mov	r2,r5
8110a5d8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110a5dc:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
8110a5e0:	e0bffe17 	ldw	r2,-8(fp)
8110a5e4:	10004f26 	beq	r2,zero,8110a724 <bSpwcInitCh+0x16c>
		bStatus = TRUE;
8110a5e8:	00800044 	movi	r2,1
8110a5ec:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
8110a5f0:	e0bfff03 	ldbu	r2,-4(fp)
8110a5f4:	10c00228 	cmpgeui	r3,r2,8
8110a5f8:	1800361e 	bne	r3,zero,8110a6d4 <bSpwcInitCh+0x11c>
8110a5fc:	100690ba 	slli	r3,r2,2
8110a600:	00a04474 	movhi	r2,33041
8110a604:	10a98504 	addi	r2,r2,-23020
8110a608:	1885883a 	add	r2,r3,r2
8110a60c:	10800017 	ldw	r2,0(r2)
8110a610:	1000683a 	jmp	r2
8110a614:	8110a634 	orhi	r4,r16,17048
8110a618:	8110a648 	cmpgei	r4,r16,17049
8110a61c:	8110a65c 	xori	r4,r16,17049
8110a620:	8110a670 	cmpltui	r4,r16,17049
8110a624:	8110a684 	addi	r4,r16,17050
8110a628:	8110a698 	cmpnei	r4,r16,17050
8110a62c:	8110a6ac 	andhi	r4,r16,17050
8110a630:	8110a6c0 	call	88110a6c <__reset+0x20f0a6c>
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110a634:	e0fffe17 	ldw	r3,-8(fp)
8110a638:	00a04834 	movhi	r2,33056
8110a63c:	108b0004 	addi	r2,r2,11264
8110a640:	18800015 	stw	r2,0(r3)
			break;
8110a644:	00002506 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8110a648:	e0fffe17 	ldw	r3,-8(fp)
8110a64c:	00a04834 	movhi	r2,33056
8110a650:	108a0004 	addi	r2,r2,10240
8110a654:	18800015 	stw	r2,0(r3)
			break;
8110a658:	00002006 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110a65c:	e0fffe17 	ldw	r3,-8(fp)
8110a660:	00a04834 	movhi	r2,33056
8110a664:	108b0004 	addi	r2,r2,11264
8110a668:	18800015 	stw	r2,0(r3)
			break;
8110a66c:	00001b06 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110a670:	e0fffe17 	ldw	r3,-8(fp)
8110a674:	00a04834 	movhi	r2,33056
8110a678:	108a0004 	addi	r2,r2,10240
8110a67c:	18800015 	stw	r2,0(r3)
			break;
8110a680:	00001606 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110a684:	e0fffe17 	ldw	r3,-8(fp)
8110a688:	00a04834 	movhi	r2,33056
8110a68c:	108b0004 	addi	r2,r2,11264
8110a690:	18800015 	stw	r2,0(r3)
			break;
8110a694:	00001106 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8110a698:	e0fffe17 	ldw	r3,-8(fp)
8110a69c:	00a04834 	movhi	r2,33056
8110a6a0:	108a0004 	addi	r2,r2,10240
8110a6a4:	18800015 	stw	r2,0(r3)
			break;
8110a6a8:	00000c06 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110a6ac:	e0fffe17 	ldw	r3,-8(fp)
8110a6b0:	00a04834 	movhi	r2,33056
8110a6b4:	108b0004 	addi	r2,r2,11264
8110a6b8:	18800015 	stw	r2,0(r3)
			break;
8110a6bc:	00000706 	br	8110a6dc <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110a6c0:	e0fffe17 	ldw	r3,-8(fp)
8110a6c4:	00a04834 	movhi	r2,33056
8110a6c8:	108a0004 	addi	r2,r2,10240
8110a6cc:	18800015 	stw	r2,0(r3)
			break;
8110a6d0:	00000206 	br	8110a6dc <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
8110a6d4:	e03ffd15 	stw	zero,-12(fp)
			break;
8110a6d8:	0001883a 	nop
		}

		if (bStatus) {
8110a6dc:	e0bffd17 	ldw	r2,-12(fp)
8110a6e0:	10001026 	beq	r2,zero,8110a724 <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
8110a6e4:	e13ffe17 	ldw	r4,-8(fp)
8110a6e8:	110a1f80 	call	8110a1f8 <bSpwcGetLink>
8110a6ec:	1000011e 	bne	r2,zero,8110a6f4 <bSpwcInitCh+0x13c>
				bStatus = FALSE;
8110a6f0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
8110a6f4:	e13ffe17 	ldw	r4,-8(fp)
8110a6f8:	110a2dc0 	call	8110a2dc <bSpwcGetLinkError>
8110a6fc:	1000011e 	bne	r2,zero,8110a704 <bSpwcInitCh+0x14c>
				bStatus = FALSE;
8110a700:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
8110a704:	e13ffe17 	ldw	r4,-8(fp)
8110a708:	110a3d00 	call	8110a3d0 <bSpwcGetLinkStatus>
8110a70c:	1000011e 	bne	r2,zero,8110a714 <bSpwcInitCh+0x15c>
				bStatus = FALSE;
8110a710:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
8110a714:	e13ffe17 	ldw	r4,-8(fp)
8110a718:	110a4a00 	call	8110a4a0 <bSpwcGetTimecode>
8110a71c:	1000011e 	bne	r2,zero,8110a724 <bSpwcInitCh+0x16c>
				bStatus = FALSE;
8110a720:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
8110a724:	e0bffd17 	ldw	r2,-12(fp)
}
8110a728:	e037883a 	mov	sp,fp
8110a72c:	dfc00117 	ldw	ra,4(sp)
8110a730:	df000017 	ldw	fp,0(sp)
8110a734:	dec00204 	addi	sp,sp,8
8110a738:	f800283a 	ret

8110a73c <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110a73c:	defffc04 	addi	sp,sp,-16
8110a740:	de00012e 	bgeu	sp,et,8110a748 <vSpwcWriteReg+0xc>
8110a744:	003b68fa 	trap	3
8110a748:	df000315 	stw	fp,12(sp)
8110a74c:	df000304 	addi	fp,sp,12
8110a750:	e13ffd15 	stw	r4,-12(fp)
8110a754:	e17ffe15 	stw	r5,-8(fp)
8110a758:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110a75c:	e0bffe17 	ldw	r2,-8(fp)
8110a760:	1085883a 	add	r2,r2,r2
8110a764:	1085883a 	add	r2,r2,r2
8110a768:	1007883a 	mov	r3,r2
8110a76c:	e0bffd17 	ldw	r2,-12(fp)
8110a770:	10c5883a 	add	r2,r2,r3
8110a774:	e0ffff17 	ldw	r3,-4(fp)
8110a778:	10c00015 	stw	r3,0(r2)
}
8110a77c:	0001883a 	nop
8110a780:	e037883a 	mov	sp,fp
8110a784:	df000017 	ldw	fp,0(sp)
8110a788:	dec00104 	addi	sp,sp,4
8110a78c:	f800283a 	ret

8110a790 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110a790:	defffc04 	addi	sp,sp,-16
8110a794:	de00012e 	bgeu	sp,et,8110a79c <uliSpwcReadReg+0xc>
8110a798:	003b68fa 	trap	3
8110a79c:	df000315 	stw	fp,12(sp)
8110a7a0:	df000304 	addi	fp,sp,12
8110a7a4:	e13ffe15 	stw	r4,-8(fp)
8110a7a8:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110a7ac:	e0bfff17 	ldw	r2,-4(fp)
8110a7b0:	1085883a 	add	r2,r2,r2
8110a7b4:	1085883a 	add	r2,r2,r2
8110a7b8:	1007883a 	mov	r3,r2
8110a7bc:	e0bffe17 	ldw	r2,-8(fp)
8110a7c0:	10c5883a 	add	r2,r2,r3
8110a7c4:	10800017 	ldw	r2,0(r2)
8110a7c8:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110a7cc:	e0bffd17 	ldw	r2,-12(fp)
}
8110a7d0:	e037883a 	mov	sp,fp
8110a7d4:	df000017 	ldw	fp,0(sp)
8110a7d8:	dec00104 	addi	sp,sp,4
8110a7dc:	f800283a 	ret

8110a7e0 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110a7e0:	defffe04 	addi	sp,sp,-8
8110a7e4:	de00012e 	bgeu	sp,et,8110a7ec <bEnableIsoDrivers+0xc>
8110a7e8:	003b68fa 	trap	3
8110a7ec:	dfc00115 	stw	ra,4(sp)
8110a7f0:	df000015 	stw	fp,0(sp)
8110a7f4:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
8110a7f8:	01400204 	movi	r5,8
8110a7fc:	01000044 	movi	r4,1
8110a800:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a804:	00800044 	movi	r2,1
}
8110a808:	e037883a 	mov	sp,fp
8110a80c:	dfc00117 	ldw	ra,4(sp)
8110a810:	df000017 	ldw	fp,0(sp)
8110a814:	dec00204 	addi	sp,sp,8
8110a818:	f800283a 	ret

8110a81c <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
8110a81c:	defffe04 	addi	sp,sp,-8
8110a820:	de00012e 	bgeu	sp,et,8110a828 <bDisableIsoDrivers+0xc>
8110a824:	003b68fa 	trap	3
8110a828:	dfc00115 	stw	ra,4(sp)
8110a82c:	df000015 	stw	fp,0(sp)
8110a830:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
8110a834:	01400204 	movi	r5,8
8110a838:	0009883a 	mov	r4,zero
8110a83c:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a840:	00800044 	movi	r2,1
}
8110a844:	e037883a 	mov	sp,fp
8110a848:	dfc00117 	ldw	ra,4(sp)
8110a84c:	df000017 	ldw	fp,0(sp)
8110a850:	dec00204 	addi	sp,sp,8
8110a854:	f800283a 	ret

8110a858 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
8110a858:	defffe04 	addi	sp,sp,-8
8110a85c:	de00012e 	bgeu	sp,et,8110a864 <bEnableLvdsBoard+0xc>
8110a860:	003b68fa 	trap	3
8110a864:	dfc00115 	stw	ra,4(sp)
8110a868:	df000015 	stw	fp,0(sp)
8110a86c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110a870:	01400104 	movi	r5,4
8110a874:	01000044 	movi	r4,1
8110a878:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a87c:	00800044 	movi	r2,1
}
8110a880:	e037883a 	mov	sp,fp
8110a884:	dfc00117 	ldw	ra,4(sp)
8110a888:	df000017 	ldw	fp,0(sp)
8110a88c:	dec00204 	addi	sp,sp,8
8110a890:	f800283a 	ret

8110a894 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8110a894:	defffe04 	addi	sp,sp,-8
8110a898:	de00012e 	bgeu	sp,et,8110a8a0 <bDisableLvdsBoard+0xc>
8110a89c:	003b68fa 	trap	3
8110a8a0:	dfc00115 	stw	ra,4(sp)
8110a8a4:	df000015 	stw	fp,0(sp)
8110a8a8:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
8110a8ac:	01400104 	movi	r5,4
8110a8b0:	0009883a 	mov	r4,zero
8110a8b4:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a8b8:	00800044 	movi	r2,1
}
8110a8bc:	e037883a 	mov	sp,fp
8110a8c0:	dfc00117 	ldw	ra,4(sp)
8110a8c4:	df000017 	ldw	fp,0(sp)
8110a8c8:	dec00204 	addi	sp,sp,8
8110a8cc:	f800283a 	ret

8110a8d0 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110a8d0:	defffd04 	addi	sp,sp,-12
8110a8d4:	de00012e 	bgeu	sp,et,8110a8dc <bSetPreEmphasys+0xc>
8110a8d8:	003b68fa 	trap	3
8110a8dc:	dfc00215 	stw	ra,8(sp)
8110a8e0:	df000115 	stw	fp,4(sp)
8110a8e4:	df000104 	addi	fp,sp,4
8110a8e8:	2005883a 	mov	r2,r4
8110a8ec:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8110a8f0:	e0bfff03 	ldbu	r2,-4(fp)
8110a8f4:	10c00060 	cmpeqi	r3,r2,1
8110a8f8:	18000d1e 	bne	r3,zero,8110a930 <bSetPreEmphasys+0x60>
8110a8fc:	10c00088 	cmpgei	r3,r2,2
8110a900:	1800021e 	bne	r3,zero,8110a90c <bSetPreEmphasys+0x3c>
8110a904:	10000626 	beq	r2,zero,8110a920 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110a908:	00001b06 	br	8110a978 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
8110a90c:	10c000a0 	cmpeqi	r3,r2,2
8110a910:	18000e1e 	bne	r3,zero,8110a94c <bSetPreEmphasys+0x7c>
8110a914:	108000e0 	cmpeqi	r2,r2,3
8110a918:	1000131e 	bne	r2,zero,8110a968 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110a91c:	00001606 	br	8110a978 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110a920:	014000c4 	movi	r5,3
8110a924:	0009883a 	mov	r4,zero
8110a928:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
      break;
8110a92c:	00001206 	br	8110a978 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110a930:	01400084 	movi	r5,2
8110a934:	0009883a 	mov	r4,zero
8110a938:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
8110a93c:	01400044 	movi	r5,1
8110a940:	01000044 	movi	r4,1
8110a944:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
      break;
8110a948:	00000b06 	br	8110a978 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
8110a94c:	01400044 	movi	r5,1
8110a950:	0009883a 	mov	r4,zero
8110a954:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
8110a958:	01400084 	movi	r5,2
8110a95c:	01000044 	movi	r4,1
8110a960:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
      break;
8110a964:	00000406 	br	8110a978 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110a968:	014000c4 	movi	r5,3
8110a96c:	01000044 	movi	r4,1
8110a970:	110a9900 	call	8110a990 <bCtrlIoLvdsDrive>
      break;
8110a974:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
8110a978:	00800044 	movi	r2,1
}
8110a97c:	e037883a 	mov	sp,fp
8110a980:	dfc00117 	ldw	ra,4(sp)
8110a984:	df000017 	ldw	fp,0(sp)
8110a988:	dec00204 	addi	sp,sp,8
8110a98c:	f800283a 	ret

8110a990 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8110a990:	defffd04 	addi	sp,sp,-12
8110a994:	de00012e 	bgeu	sp,et,8110a99c <bCtrlIoLvdsDrive+0xc>
8110a998:	003b68fa 	trap	3
8110a99c:	df000215 	stw	fp,8(sp)
8110a9a0:	df000204 	addi	fp,sp,8
8110a9a4:	e13ffe15 	stw	r4,-8(fp)
8110a9a8:	2805883a 	mov	r2,r5
8110a9ac:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8110a9b0:	e0bffe17 	ldw	r2,-8(fp)
8110a9b4:	1000071e 	bne	r2,zero,8110a9d4 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
8110a9b8:	e0bfff03 	ldbu	r2,-4(fp)
8110a9bc:	0084303a 	nor	r2,zero,r2
8110a9c0:	1007883a 	mov	r3,r2
8110a9c4:	d0a00103 	ldbu	r2,-32764(gp)
8110a9c8:	1884703a 	and	r2,r3,r2
8110a9cc:	d0a00105 	stb	r2,-32764(gp)
8110a9d0:	00000406 	br	8110a9e4 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
8110a9d4:	d0e00103 	ldbu	r3,-32764(gp)
8110a9d8:	e0bfff03 	ldbu	r2,-4(fp)
8110a9dc:	1884b03a 	or	r2,r3,r2
8110a9e0:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
8110a9e4:	d0a00103 	ldbu	r2,-32764(gp)
8110a9e8:	10c03fcc 	andi	r3,r2,255
8110a9ec:	00a00034 	movhi	r2,32768
8110a9f0:	10822804 	addi	r2,r2,2208
8110a9f4:	10c00035 	stwio	r3,0(r2)
  return TRUE;
8110a9f8:	00800044 	movi	r2,1
}
8110a9fc:	e037883a 	mov	sp,fp
8110aa00:	df000017 	ldw	fp,0(sp)
8110aa04:	dec00104 	addi	sp,sp,4
8110aa08:	f800283a 	ret

8110aa0c <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
8110aa0c:	defffa04 	addi	sp,sp,-24
8110aa10:	de00012e 	bgeu	sp,et,8110aa18 <I2C_TestAdress+0xc>
8110aa14:	003b68fa 	trap	3
8110aa18:	dfc00515 	stw	ra,20(sp)
8110aa1c:	df000415 	stw	fp,16(sp)
8110aa20:	df000404 	addi	fp,sp,16
8110aa24:	e13ffd15 	stw	r4,-12(fp)
8110aa28:	e17ffe15 	stw	r5,-8(fp)
8110aa2c:	3005883a 	mov	r2,r6
8110aa30:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110aa34:	00800044 	movi	r2,1
8110aa38:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110aa3c:	e17ffe17 	ldw	r5,-8(fp)
8110aa40:	e13ffd17 	ldw	r4,-12(fp)
8110aa44:	110addc0 	call	8110addc <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110aa48:	e0bfff03 	ldbu	r2,-4(fp)
8110aa4c:	10803fcc 	andi	r2,r2,255
8110aa50:	100d883a 	mov	r6,r2
8110aa54:	e17ffe17 	ldw	r5,-8(fp)
8110aa58:	e13ffd17 	ldw	r4,-12(fp)
8110aa5c:	110aef00 	call	8110aef0 <i2c_write>
8110aa60:	1000011e 	bne	r2,zero,8110aa68 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
8110aa64:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110aa68:	e17ffe17 	ldw	r5,-8(fp)
8110aa6c:	e13ffd17 	ldw	r4,-12(fp)
8110aa70:	110ae700 	call	8110ae70 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110aa74:	0106d604 	movi	r4,7000
8110aa78:	1138fc80 	call	81138fc8 <usleep>
    
    return bSuccess;
8110aa7c:	e0bffc17 	ldw	r2,-16(fp)

}
8110aa80:	e037883a 	mov	sp,fp
8110aa84:	dfc00117 	ldw	ra,4(sp)
8110aa88:	df000017 	ldw	fp,0(sp)
8110aa8c:	dec00204 	addi	sp,sp,8
8110aa90:	f800283a 	ret

8110aa94 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
8110aa94:	defff804 	addi	sp,sp,-32
8110aa98:	de00012e 	bgeu	sp,et,8110aaa0 <I2C_Write+0xc>
8110aa9c:	003b68fa 	trap	3
8110aaa0:	dfc00715 	stw	ra,28(sp)
8110aaa4:	df000615 	stw	fp,24(sp)
8110aaa8:	df000604 	addi	fp,sp,24
8110aaac:	e13ffb15 	stw	r4,-20(fp)
8110aab0:	e17ffc15 	stw	r5,-16(fp)
8110aab4:	3009883a 	mov	r4,r6
8110aab8:	3807883a 	mov	r3,r7
8110aabc:	e0800217 	ldw	r2,8(fp)
8110aac0:	e13ffd05 	stb	r4,-12(fp)
8110aac4:	e0fffe05 	stb	r3,-8(fp)
8110aac8:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110aacc:	00800044 	movi	r2,1
8110aad0:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110aad4:	e17ffc17 	ldw	r5,-16(fp)
8110aad8:	e13ffb17 	ldw	r4,-20(fp)
8110aadc:	110addc0 	call	8110addc <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110aae0:	e0bffd03 	ldbu	r2,-12(fp)
8110aae4:	10803fcc 	andi	r2,r2,255
8110aae8:	100d883a 	mov	r6,r2
8110aaec:	e17ffc17 	ldw	r5,-16(fp)
8110aaf0:	e13ffb17 	ldw	r4,-20(fp)
8110aaf4:	110aef00 	call	8110aef0 <i2c_write>
8110aaf8:	1000011e 	bne	r2,zero,8110ab00 <I2C_Write+0x6c>
        bSuccess = FALSE;
8110aafc:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110ab00:	e0bffa17 	ldw	r2,-24(fp)
8110ab04:	10000726 	beq	r2,zero,8110ab24 <I2C_Write+0x90>
8110ab08:	e0bffe03 	ldbu	r2,-8(fp)
8110ab0c:	100d883a 	mov	r6,r2
8110ab10:	e17ffc17 	ldw	r5,-16(fp)
8110ab14:	e13ffb17 	ldw	r4,-20(fp)
8110ab18:	110aef00 	call	8110aef0 <i2c_write>
8110ab1c:	1000011e 	bne	r2,zero,8110ab24 <I2C_Write+0x90>
        bSuccess = FALSE;
8110ab20:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
8110ab24:	e0bffa17 	ldw	r2,-24(fp)
8110ab28:	10000726 	beq	r2,zero,8110ab48 <I2C_Write+0xb4>
8110ab2c:	e0bfff03 	ldbu	r2,-4(fp)
8110ab30:	100d883a 	mov	r6,r2
8110ab34:	e17ffc17 	ldw	r5,-16(fp)
8110ab38:	e13ffb17 	ldw	r4,-20(fp)
8110ab3c:	110aef00 	call	8110aef0 <i2c_write>
8110ab40:	1000011e 	bne	r2,zero,8110ab48 <I2C_Write+0xb4>
        bSuccess = FALSE;
8110ab44:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110ab48:	e17ffc17 	ldw	r5,-16(fp)
8110ab4c:	e13ffb17 	ldw	r4,-20(fp)
8110ab50:	110ae700 	call	8110ae70 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110ab54:	0106d604 	movi	r4,7000
8110ab58:	1138fc80 	call	81138fc8 <usleep>
    
    return bSuccess;
8110ab5c:	e0bffa17 	ldw	r2,-24(fp)

}
8110ab60:	e037883a 	mov	sp,fp
8110ab64:	dfc00117 	ldw	ra,4(sp)
8110ab68:	df000017 	ldw	fp,0(sp)
8110ab6c:	dec00204 	addi	sp,sp,8
8110ab70:	f800283a 	ret

8110ab74 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
8110ab74:	defff904 	addi	sp,sp,-28
8110ab78:	de00012e 	bgeu	sp,et,8110ab80 <I2C_Read+0xc>
8110ab7c:	003b68fa 	trap	3
8110ab80:	dfc00615 	stw	ra,24(sp)
8110ab84:	df000515 	stw	fp,20(sp)
8110ab88:	df000504 	addi	fp,sp,20
8110ab8c:	e13ffc15 	stw	r4,-16(fp)
8110ab90:	e17ffd15 	stw	r5,-12(fp)
8110ab94:	3007883a 	mov	r3,r6
8110ab98:	3805883a 	mov	r2,r7
8110ab9c:	e0fffe05 	stb	r3,-8(fp)
8110aba0:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110aba4:	00800044 	movi	r2,1
8110aba8:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110abac:	e17ffd17 	ldw	r5,-12(fp)
8110abb0:	e13ffc17 	ldw	r4,-16(fp)
8110abb4:	110addc0 	call	8110addc <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110abb8:	e0bffe03 	ldbu	r2,-8(fp)
8110abbc:	10803fcc 	andi	r2,r2,255
8110abc0:	100d883a 	mov	r6,r2
8110abc4:	e17ffd17 	ldw	r5,-12(fp)
8110abc8:	e13ffc17 	ldw	r4,-16(fp)
8110abcc:	110aef00 	call	8110aef0 <i2c_write>
8110abd0:	1000011e 	bne	r2,zero,8110abd8 <I2C_Read+0x64>
        bSuccess = FALSE;
8110abd4:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110abd8:	e0bffb17 	ldw	r2,-20(fp)
8110abdc:	10000726 	beq	r2,zero,8110abfc <I2C_Read+0x88>
8110abe0:	e0bfff03 	ldbu	r2,-4(fp)
8110abe4:	100d883a 	mov	r6,r2
8110abe8:	e17ffd17 	ldw	r5,-12(fp)
8110abec:	e13ffc17 	ldw	r4,-16(fp)
8110abf0:	110aef00 	call	8110aef0 <i2c_write>
8110abf4:	1000011e 	bne	r2,zero,8110abfc <I2C_Read+0x88>
        bSuccess = FALSE;
8110abf8:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
8110abfc:	e17ffd17 	ldw	r5,-12(fp)
8110ac00:	e13ffc17 	ldw	r4,-16(fp)
8110ac04:	110addc0 	call	8110addc <i2c_start>
    DeviceAddr |= 1; // Read
8110ac08:	e0bffe03 	ldbu	r2,-8(fp)
8110ac0c:	10800054 	ori	r2,r2,1
8110ac10:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110ac14:	e0bffb17 	ldw	r2,-20(fp)
8110ac18:	10000826 	beq	r2,zero,8110ac3c <I2C_Read+0xc8>
8110ac1c:	e0bffe03 	ldbu	r2,-8(fp)
8110ac20:	10803fcc 	andi	r2,r2,255
8110ac24:	100d883a 	mov	r6,r2
8110ac28:	e17ffd17 	ldw	r5,-12(fp)
8110ac2c:	e13ffc17 	ldw	r4,-16(fp)
8110ac30:	110aef00 	call	8110aef0 <i2c_write>
8110ac34:	1000011e 	bne	r2,zero,8110ac3c <I2C_Read+0xc8>
        bSuccess = FALSE;
8110ac38:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110ac3c:	e0bffb17 	ldw	r2,-20(fp)
8110ac40:	10000526 	beq	r2,zero,8110ac58 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
8110ac44:	000f883a 	mov	r7,zero
8110ac48:	e1800217 	ldw	r6,8(fp)
8110ac4c:	e17ffd17 	ldw	r5,-12(fp)
8110ac50:	e13ffc17 	ldw	r4,-16(fp)
8110ac54:	110b0280 	call	8110b028 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
8110ac58:	e17ffd17 	ldw	r5,-12(fp)
8110ac5c:	e13ffc17 	ldw	r4,-16(fp)
8110ac60:	110ae700 	call	8110ae70 <i2c_stop>
    
    return bSuccess;
8110ac64:	e0bffb17 	ldw	r2,-20(fp)
}
8110ac68:	e037883a 	mov	sp,fp
8110ac6c:	dfc00117 	ldw	ra,4(sp)
8110ac70:	df000017 	ldw	fp,0(sp)
8110ac74:	dec00204 	addi	sp,sp,8
8110ac78:	f800283a 	ret

8110ac7c <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
8110ac7c:	defff604 	addi	sp,sp,-40
8110ac80:	de00012e 	bgeu	sp,et,8110ac88 <I2C_MultipleRead+0xc>
8110ac84:	003b68fa 	trap	3
8110ac88:	dfc00915 	stw	ra,36(sp)
8110ac8c:	df000815 	stw	fp,32(sp)
8110ac90:	df000804 	addi	fp,sp,32
8110ac94:	e13ffb15 	stw	r4,-20(fp)
8110ac98:	e17ffc15 	stw	r5,-16(fp)
8110ac9c:	3007883a 	mov	r3,r6
8110aca0:	e1fffe15 	stw	r7,-8(fp)
8110aca4:	e0800217 	ldw	r2,8(fp)
8110aca8:	e0fffd05 	stb	r3,-12(fp)
8110acac:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
8110acb0:	00800044 	movi	r2,1
8110acb4:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
8110acb8:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110acbc:	e17ffc17 	ldw	r5,-16(fp)
8110acc0:	e13ffb17 	ldw	r4,-20(fp)
8110acc4:	110addc0 	call	8110addc <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110acc8:	e0bffd03 	ldbu	r2,-12(fp)
8110accc:	10803fcc 	andi	r2,r2,255
8110acd0:	100d883a 	mov	r6,r2
8110acd4:	e17ffc17 	ldw	r5,-16(fp)
8110acd8:	e13ffb17 	ldw	r4,-20(fp)
8110acdc:	110aef00 	call	8110aef0 <i2c_write>
8110ace0:	1000011e 	bne	r2,zero,8110ace8 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
8110ace4:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110ace8:	e0bff917 	ldw	r2,-28(fp)
8110acec:	10000726 	beq	r2,zero,8110ad0c <I2C_MultipleRead+0x90>
8110acf0:	e0bffa03 	ldbu	r2,-24(fp)
8110acf4:	100d883a 	mov	r6,r2
8110acf8:	e17ffc17 	ldw	r5,-16(fp)
8110acfc:	e13ffb17 	ldw	r4,-20(fp)
8110ad00:	110aef00 	call	8110aef0 <i2c_write>
8110ad04:	1000011e 	bne	r2,zero,8110ad0c <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
8110ad08:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
8110ad0c:	e0bff917 	ldw	r2,-28(fp)
8110ad10:	10000326 	beq	r2,zero,8110ad20 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
8110ad14:	e17ffc17 	ldw	r5,-16(fp)
8110ad18:	e13ffb17 	ldw	r4,-20(fp)
8110ad1c:	110addc0 	call	8110addc <i2c_start>
    DeviceAddr |= 1; // Read
8110ad20:	e0bffd03 	ldbu	r2,-12(fp)
8110ad24:	10800054 	ori	r2,r2,1
8110ad28:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110ad2c:	e0bff917 	ldw	r2,-28(fp)
8110ad30:	10000826 	beq	r2,zero,8110ad54 <I2C_MultipleRead+0xd8>
8110ad34:	e0bffd03 	ldbu	r2,-12(fp)
8110ad38:	10803fcc 	andi	r2,r2,255
8110ad3c:	100d883a 	mov	r6,r2
8110ad40:	e17ffc17 	ldw	r5,-16(fp)
8110ad44:	e13ffb17 	ldw	r4,-20(fp)
8110ad48:	110aef00 	call	8110aef0 <i2c_write>
8110ad4c:	1000011e 	bne	r2,zero,8110ad54 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
8110ad50:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110ad54:	e0bff917 	ldw	r2,-28(fp)
8110ad58:	10001726 	beq	r2,zero,8110adb8 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
8110ad5c:	e03ff815 	stw	zero,-32(fp)
8110ad60:	00001006 	br	8110ada4 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
8110ad64:	e0bff817 	ldw	r2,-32(fp)
8110ad68:	e0fffe17 	ldw	r3,-8(fp)
8110ad6c:	1889883a 	add	r4,r3,r2
8110ad70:	e0bfff0b 	ldhu	r2,-4(fp)
8110ad74:	10ffffc4 	addi	r3,r2,-1
8110ad78:	e0bff817 	ldw	r2,-32(fp)
8110ad7c:	1884c03a 	cmpne	r2,r3,r2
8110ad80:	10803fcc 	andi	r2,r2,255
8110ad84:	100f883a 	mov	r7,r2
8110ad88:	200d883a 	mov	r6,r4
8110ad8c:	e17ffc17 	ldw	r5,-16(fp)
8110ad90:	e13ffb17 	ldw	r4,-20(fp)
8110ad94:	110b0280 	call	8110b028 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
8110ad98:	e0bff817 	ldw	r2,-32(fp)
8110ad9c:	10800044 	addi	r2,r2,1
8110ada0:	e0bff815 	stw	r2,-32(fp)
8110ada4:	e0bfff0b 	ldhu	r2,-4(fp)
8110ada8:	e0fff817 	ldw	r3,-32(fp)
8110adac:	1880020e 	bge	r3,r2,8110adb8 <I2C_MultipleRead+0x13c>
8110adb0:	e0bff917 	ldw	r2,-28(fp)
8110adb4:	103feb1e 	bne	r2,zero,8110ad64 <__reset+0xfb0ead64>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
8110adb8:	e17ffc17 	ldw	r5,-16(fp)
8110adbc:	e13ffb17 	ldw	r4,-20(fp)
8110adc0:	110ae700 	call	8110ae70 <i2c_stop>
    
    return bSuccess;    
8110adc4:	e0bff917 	ldw	r2,-28(fp)
    
}
8110adc8:	e037883a 	mov	sp,fp
8110adcc:	dfc00117 	ldw	ra,4(sp)
8110add0:	df000017 	ldw	fp,0(sp)
8110add4:	dec00204 	addi	sp,sp,8
8110add8:	f800283a 	ret

8110addc <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
8110addc:	defffc04 	addi	sp,sp,-16
8110ade0:	de00012e 	bgeu	sp,et,8110ade8 <i2c_start+0xc>
8110ade4:	003b68fa 	trap	3
8110ade8:	dfc00315 	stw	ra,12(sp)
8110adec:	df000215 	stw	fp,8(sp)
8110adf0:	df000204 	addi	fp,sp,8
8110adf4:	e13ffe15 	stw	r4,-8(fp)
8110adf8:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
8110adfc:	e0bfff17 	ldw	r2,-4(fp)
8110ae00:	10800104 	addi	r2,r2,4
8110ae04:	1007883a 	mov	r3,r2
8110ae08:	00800044 	movi	r2,1
8110ae0c:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
8110ae10:	e0bfff17 	ldw	r2,-4(fp)
8110ae14:	00c00044 	movi	r3,1
8110ae18:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
8110ae1c:	e0bffe17 	ldw	r2,-8(fp)
8110ae20:	00c00044 	movi	r3,1
8110ae24:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110ae28:	01000044 	movi	r4,1
8110ae2c:	1138fc80 	call	81138fc8 <usleep>
     
    SDA_LOW(data_base); // data low
8110ae30:	e0bfff17 	ldw	r2,-4(fp)
8110ae34:	0007883a 	mov	r3,zero
8110ae38:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
8110ae3c:	01000044 	movi	r4,1
8110ae40:	1138fc80 	call	81138fc8 <usleep>
    SCL_LOW(clk_base); // clock low
8110ae44:	e0bffe17 	ldw	r2,-8(fp)
8110ae48:	0007883a 	mov	r3,zero
8110ae4c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110ae50:	01000044 	movi	r4,1
8110ae54:	1138fc80 	call	81138fc8 <usleep>
}
8110ae58:	0001883a 	nop
8110ae5c:	e037883a 	mov	sp,fp
8110ae60:	dfc00117 	ldw	ra,4(sp)
8110ae64:	df000017 	ldw	fp,0(sp)
8110ae68:	dec00204 	addi	sp,sp,8
8110ae6c:	f800283a 	ret

8110ae70 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
8110ae70:	defffc04 	addi	sp,sp,-16
8110ae74:	de00012e 	bgeu	sp,et,8110ae7c <i2c_stop+0xc>
8110ae78:	003b68fa 	trap	3
8110ae7c:	dfc00315 	stw	ra,12(sp)
8110ae80:	df000215 	stw	fp,8(sp)
8110ae84:	df000204 	addi	fp,sp,8
8110ae88:	e13ffe15 	stw	r4,-8(fp)
8110ae8c:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
8110ae90:	e0bfff17 	ldw	r2,-4(fp)
8110ae94:	10800104 	addi	r2,r2,4
8110ae98:	1007883a 	mov	r3,r2
8110ae9c:	00800044 	movi	r2,1
8110aea0:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
8110aea4:	e0bfff17 	ldw	r2,-4(fp)
8110aea8:	0007883a 	mov	r3,zero
8110aeac:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
8110aeb0:	e0bffe17 	ldw	r2,-8(fp)
8110aeb4:	00c00044 	movi	r3,1
8110aeb8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
8110aebc:	01000044 	movi	r4,1
8110aec0:	1138fc80 	call	81138fc8 <usleep>
    SDA_HIGH(data_base); // data high
8110aec4:	e0bfff17 	ldw	r2,-4(fp)
8110aec8:	00c00044 	movi	r3,1
8110aecc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
8110aed0:	01000044 	movi	r4,1
8110aed4:	1138fc80 	call	81138fc8 <usleep>
    

    
}
8110aed8:	0001883a 	nop
8110aedc:	e037883a 	mov	sp,fp
8110aee0:	dfc00117 	ldw	ra,4(sp)
8110aee4:	df000017 	ldw	fp,0(sp)
8110aee8:	dec00204 	addi	sp,sp,8
8110aeec:	f800283a 	ret

8110aef0 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
8110aef0:	defff804 	addi	sp,sp,-32
8110aef4:	de00012e 	bgeu	sp,et,8110aefc <i2c_write+0xc>
8110aef8:	003b68fa 	trap	3
8110aefc:	dfc00715 	stw	ra,28(sp)
8110af00:	df000615 	stw	fp,24(sp)
8110af04:	df000604 	addi	fp,sp,24
8110af08:	e13ffd15 	stw	r4,-12(fp)
8110af0c:	e17ffe15 	stw	r5,-8(fp)
8110af10:	3005883a 	mov	r2,r6
8110af14:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
8110af18:	00bfe004 	movi	r2,-128
8110af1c:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
8110af20:	e0bffe17 	ldw	r2,-8(fp)
8110af24:	10800104 	addi	r2,r2,4
8110af28:	1007883a 	mov	r3,r2
8110af2c:	00800044 	movi	r2,1
8110af30:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
8110af34:	e03ffb15 	stw	zero,-20(fp)
8110af38:	00001f06 	br	8110afb8 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
8110af3c:	e0bffd17 	ldw	r2,-12(fp)
8110af40:	0007883a 	mov	r3,zero
8110af44:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
8110af48:	e0ffff03 	ldbu	r3,-4(fp)
8110af4c:	e0bffa03 	ldbu	r2,-24(fp)
8110af50:	1884703a 	and	r2,r3,r2
8110af54:	10803fcc 	andi	r2,r2,255
8110af58:	10000426 	beq	r2,zero,8110af6c <i2c_write+0x7c>
            SDA_HIGH(data_base);
8110af5c:	e0bffe17 	ldw	r2,-8(fp)
8110af60:	00c00044 	movi	r3,1
8110af64:	10c00035 	stwio	r3,0(r2)
8110af68:	00000306 	br	8110af78 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8110af6c:	e0bffe17 	ldw	r2,-8(fp)
8110af70:	0007883a 	mov	r3,zero
8110af74:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
8110af78:	e0bffa03 	ldbu	r2,-24(fp)
8110af7c:	1004d07a 	srli	r2,r2,1
8110af80:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
8110af84:	e0bffd17 	ldw	r2,-12(fp)
8110af88:	00c00044 	movi	r3,1
8110af8c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110af90:	01000044 	movi	r4,1
8110af94:	1138fc80 	call	81138fc8 <usleep>
        SCL_LOW(clk_base);
8110af98:	e0bffd17 	ldw	r2,-12(fp)
8110af9c:	0007883a 	mov	r3,zero
8110afa0:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110afa4:	01000044 	movi	r4,1
8110afa8:	1138fc80 	call	81138fc8 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110afac:	e0bffb17 	ldw	r2,-20(fp)
8110afb0:	10800044 	addi	r2,r2,1
8110afb4:	e0bffb15 	stw	r2,-20(fp)
8110afb8:	e0bffb17 	ldw	r2,-20(fp)
8110afbc:	10800210 	cmplti	r2,r2,8
8110afc0:	103fde1e 	bne	r2,zero,8110af3c <__reset+0xfb0eaf3c>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8110afc4:	e0bffe17 	ldw	r2,-8(fp)
8110afc8:	10800104 	addi	r2,r2,4
8110afcc:	0007883a 	mov	r3,zero
8110afd0:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8110afd4:	e0bffd17 	ldw	r2,-12(fp)
8110afd8:	00c00044 	movi	r3,1
8110afdc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8110afe0:	01000044 	movi	r4,1
8110afe4:	1138fc80 	call	81138fc8 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8110afe8:	e0bffe17 	ldw	r2,-8(fp)
8110afec:	10800037 	ldwio	r2,0(r2)
8110aff0:	1005003a 	cmpeq	r2,r2,zero
8110aff4:	10803fcc 	andi	r2,r2,255
8110aff8:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110affc:	e0bffd17 	ldw	r2,-12(fp)
8110b000:	0007883a 	mov	r3,zero
8110b004:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b008:	01000044 	movi	r4,1
8110b00c:	1138fc80 	call	81138fc8 <usleep>
    return bAck;
8110b010:	e0bffc17 	ldw	r2,-16(fp)
}    
8110b014:	e037883a 	mov	sp,fp
8110b018:	dfc00117 	ldw	ra,4(sp)
8110b01c:	df000017 	ldw	fp,0(sp)
8110b020:	dec00204 	addi	sp,sp,8
8110b024:	f800283a 	ret

8110b028 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8110b028:	defff804 	addi	sp,sp,-32
8110b02c:	de00012e 	bgeu	sp,et,8110b034 <i2c_read+0xc>
8110b030:	003b68fa 	trap	3
8110b034:	dfc00715 	stw	ra,28(sp)
8110b038:	df000615 	stw	fp,24(sp)
8110b03c:	df000604 	addi	fp,sp,24
8110b040:	e13ffc15 	stw	r4,-16(fp)
8110b044:	e17ffd15 	stw	r5,-12(fp)
8110b048:	e1bffe15 	stw	r6,-8(fp)
8110b04c:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110b050:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8110b054:	e0bffd17 	ldw	r2,-12(fp)
8110b058:	10800104 	addi	r2,r2,4
8110b05c:	0007883a 	mov	r3,zero
8110b060:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8110b064:	e0bffc17 	ldw	r2,-16(fp)
8110b068:	0007883a 	mov	r3,zero
8110b06c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b070:	01000044 	movi	r4,1
8110b074:	1138fc80 	call	81138fc8 <usleep>

    for(i=0;i<8;i++){
8110b078:	e03ffb15 	stw	zero,-20(fp)
8110b07c:	00001606 	br	8110b0d8 <i2c_read+0xb0>
        Data <<= 1;
8110b080:	e0bffa03 	ldbu	r2,-24(fp)
8110b084:	1085883a 	add	r2,r2,r2
8110b088:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110b08c:	e0bffc17 	ldw	r2,-16(fp)
8110b090:	00c00044 	movi	r3,1
8110b094:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b098:	01000044 	movi	r4,1
8110b09c:	1138fc80 	call	81138fc8 <usleep>
        if (SDA_READ(data_base))  // read data   
8110b0a0:	e0bffd17 	ldw	r2,-12(fp)
8110b0a4:	10800037 	ldwio	r2,0(r2)
8110b0a8:	10000326 	beq	r2,zero,8110b0b8 <i2c_read+0x90>
            Data |= 0x01;
8110b0ac:	e0bffa03 	ldbu	r2,-24(fp)
8110b0b0:	10800054 	ori	r2,r2,1
8110b0b4:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8110b0b8:	e0bffc17 	ldw	r2,-16(fp)
8110b0bc:	0007883a 	mov	r3,zero
8110b0c0:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b0c4:	01000044 	movi	r4,1
8110b0c8:	1138fc80 	call	81138fc8 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110b0cc:	e0bffb17 	ldw	r2,-20(fp)
8110b0d0:	10800044 	addi	r2,r2,1
8110b0d4:	e0bffb15 	stw	r2,-20(fp)
8110b0d8:	e0bffb17 	ldw	r2,-20(fp)
8110b0dc:	10800210 	cmplti	r2,r2,8
8110b0e0:	103fe71e 	bne	r2,zero,8110b080 <__reset+0xfb0eb080>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110b0e4:	e0bffc17 	ldw	r2,-16(fp)
8110b0e8:	0007883a 	mov	r3,zero
8110b0ec:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110b0f0:	e0bffd17 	ldw	r2,-12(fp)
8110b0f4:	10800104 	addi	r2,r2,4
8110b0f8:	1007883a 	mov	r3,r2
8110b0fc:	00800044 	movi	r2,1
8110b100:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110b104:	e0bfff17 	ldw	r2,-4(fp)
8110b108:	10000426 	beq	r2,zero,8110b11c <i2c_read+0xf4>
        SDA_LOW(data_base);
8110b10c:	e0bffd17 	ldw	r2,-12(fp)
8110b110:	0007883a 	mov	r3,zero
8110b114:	10c00035 	stwio	r3,0(r2)
8110b118:	00000306 	br	8110b128 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8110b11c:	e0bffd17 	ldw	r2,-12(fp)
8110b120:	00c00044 	movi	r3,1
8110b124:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8110b128:	e0bffc17 	ldw	r2,-16(fp)
8110b12c:	00c00044 	movi	r3,1
8110b130:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8110b134:	01000044 	movi	r4,1
8110b138:	1138fc80 	call	81138fc8 <usleep>
    SCL_LOW(clk_base); // clock low
8110b13c:	e0bffc17 	ldw	r2,-16(fp)
8110b140:	0007883a 	mov	r3,zero
8110b144:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b148:	01000044 	movi	r4,1
8110b14c:	1138fc80 	call	81138fc8 <usleep>
    SDA_LOW(data_base);  // data low
8110b150:	e0bffd17 	ldw	r2,-12(fp)
8110b154:	0007883a 	mov	r3,zero
8110b158:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8110b15c:	01000044 	movi	r4,1
8110b160:	1138fc80 	call	81138fc8 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8110b164:	e0bffe17 	ldw	r2,-8(fp)
8110b168:	e0fffa03 	ldbu	r3,-24(fp)
8110b16c:	10c00005 	stb	r3,0(r2)
}
8110b170:	0001883a 	nop
8110b174:	e037883a 	mov	sp,fp
8110b178:	dfc00117 	ldw	ra,4(sp)
8110b17c:	df000017 	ldw	fp,0(sp)
8110b180:	dec00204 	addi	sp,sp,8
8110b184:	f800283a 	ret

8110b188 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8110b188:	defffd04 	addi	sp,sp,-12
8110b18c:	de00012e 	bgeu	sp,et,8110b194 <bSetBoardLeds+0xc>
8110b190:	003b68fa 	trap	3
8110b194:	df000215 	stw	fp,8(sp)
8110b198:	df000204 	addi	fp,sp,8
8110b19c:	e13ffe15 	stw	r4,-8(fp)
8110b1a0:	2805883a 	mov	r2,r5
8110b1a4:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110b1a8:	e0bffe17 	ldw	r2,-8(fp)
8110b1ac:	10800058 	cmpnei	r2,r2,1
8110b1b0:	1000071e 	bne	r2,zero,8110b1d0 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110b1b4:	e0bfff03 	ldbu	r2,-4(fp)
8110b1b8:	0084303a 	nor	r2,zero,r2
8110b1bc:	1007883a 	mov	r3,r2
8110b1c0:	d0a05003 	ldbu	r2,-32448(gp)
8110b1c4:	1884703a 	and	r2,r3,r2
8110b1c8:	d0a05005 	stb	r2,-32448(gp)
8110b1cc:	00000406 	br	8110b1e0 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110b1d0:	d0e05003 	ldbu	r3,-32448(gp)
8110b1d4:	e0bfff03 	ldbu	r2,-4(fp)
8110b1d8:	1884b03a 	or	r2,r3,r2
8110b1dc:	d0a05005 	stb	r2,-32448(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110b1e0:	d0a05003 	ldbu	r2,-32448(gp)
8110b1e4:	10c03fcc 	andi	r3,r2,255
8110b1e8:	00a00034 	movhi	r2,32768
8110b1ec:	10827404 	addi	r2,r2,2512
8110b1f0:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b1f4:	00800044 	movi	r2,1
}
8110b1f8:	e037883a 	mov	sp,fp
8110b1fc:	df000017 	ldw	fp,0(sp)
8110b200:	dec00104 	addi	sp,sp,4
8110b204:	f800283a 	ret

8110b208 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110b208:	defffd04 	addi	sp,sp,-12
8110b20c:	de00012e 	bgeu	sp,et,8110b214 <bSetPainelLeds+0xc>
8110b210:	003b68fa 	trap	3
8110b214:	df000215 	stw	fp,8(sp)
8110b218:	df000204 	addi	fp,sp,8
8110b21c:	e13ffe15 	stw	r4,-8(fp)
8110b220:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110b224:	e0bffe17 	ldw	r2,-8(fp)
8110b228:	10800058 	cmpnei	r2,r2,1
8110b22c:	1000051e 	bne	r2,zero,8110b244 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110b230:	d0e00217 	ldw	r3,-32760(gp)
8110b234:	e0bfff17 	ldw	r2,-4(fp)
8110b238:	1884b03a 	or	r2,r3,r2
8110b23c:	d0a00215 	stw	r2,-32760(gp)
8110b240:	00000506 	br	8110b258 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110b244:	e0bfff17 	ldw	r2,-4(fp)
8110b248:	0086303a 	nor	r3,zero,r2
8110b24c:	d0a00217 	ldw	r2,-32760(gp)
8110b250:	1884703a 	and	r2,r3,r2
8110b254:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110b258:	d0a00217 	ldw	r2,-32760(gp)
8110b25c:	1007883a 	mov	r3,r2
8110b260:	00a00034 	movhi	r2,32768
8110b264:	10824004 	addi	r2,r2,2304
8110b268:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b26c:	00800044 	movi	r2,1
}
8110b270:	e037883a 	mov	sp,fp
8110b274:	df000017 	ldw	fp,0(sp)
8110b278:	dec00104 	addi	sp,sp,4
8110b27c:	f800283a 	ret

8110b280 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110b280:	defffc04 	addi	sp,sp,-16
8110b284:	de00012e 	bgeu	sp,et,8110b28c <msgdma_write_extended_descriptor+0xc>
8110b288:	003b68fa 	trap	3
8110b28c:	df000315 	stw	fp,12(sp)
8110b290:	df000304 	addi	fp,sp,12
8110b294:	e13ffd15 	stw	r4,-12(fp)
8110b298:	e17ffe15 	stw	r5,-8(fp)
8110b29c:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110b2a0:	e0bffd17 	ldw	r2,-12(fp)
8110b2a4:	10800037 	ldwio	r2,0(r2)
8110b2a8:	1080010c 	andi	r2,r2,4
8110b2ac:	10000226 	beq	r2,zero,8110b2b8 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110b2b0:	00bff904 	movi	r2,-28
8110b2b4:	00003d06 	br	8110b3ac <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110b2b8:	e0bfff17 	ldw	r2,-4(fp)
8110b2bc:	10800017 	ldw	r2,0(r2)
8110b2c0:	1007883a 	mov	r3,r2
8110b2c4:	e0bffe17 	ldw	r2,-8(fp)
8110b2c8:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110b2cc:	e0bffe17 	ldw	r2,-8(fp)
8110b2d0:	10800104 	addi	r2,r2,4
8110b2d4:	e0ffff17 	ldw	r3,-4(fp)
8110b2d8:	18c00117 	ldw	r3,4(r3)
8110b2dc:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110b2e0:	e0bffe17 	ldw	r2,-8(fp)
8110b2e4:	10800204 	addi	r2,r2,8
8110b2e8:	e0ffff17 	ldw	r3,-4(fp)
8110b2ec:	18c00217 	ldw	r3,8(r3)
8110b2f0:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110b2f4:	e0bffe17 	ldw	r2,-8(fp)
8110b2f8:	10800304 	addi	r2,r2,12
8110b2fc:	e0ffff17 	ldw	r3,-4(fp)
8110b300:	18c0030b 	ldhu	r3,12(r3)
8110b304:	18ffffcc 	andi	r3,r3,65535
8110b308:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110b30c:	e0bffe17 	ldw	r2,-8(fp)
8110b310:	10800384 	addi	r2,r2,14
8110b314:	e0ffff17 	ldw	r3,-4(fp)
8110b318:	18c00383 	ldbu	r3,14(r3)
8110b31c:	18c03fcc 	andi	r3,r3,255
8110b320:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110b324:	e0bffe17 	ldw	r2,-8(fp)
8110b328:	108003c4 	addi	r2,r2,15
8110b32c:	e0ffff17 	ldw	r3,-4(fp)
8110b330:	18c003c3 	ldbu	r3,15(r3)
8110b334:	18c03fcc 	andi	r3,r3,255
8110b338:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110b33c:	e0bffe17 	ldw	r2,-8(fp)
8110b340:	10800404 	addi	r2,r2,16
8110b344:	e0ffff17 	ldw	r3,-4(fp)
8110b348:	18c0040b 	ldhu	r3,16(r3)
8110b34c:	18ffffcc 	andi	r3,r3,65535
8110b350:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110b354:	e0bffe17 	ldw	r2,-8(fp)
8110b358:	10800484 	addi	r2,r2,18
8110b35c:	e0ffff17 	ldw	r3,-4(fp)
8110b360:	18c0048b 	ldhu	r3,18(r3)
8110b364:	18ffffcc 	andi	r3,r3,65535
8110b368:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110b36c:	e0bffe17 	ldw	r2,-8(fp)
8110b370:	10800504 	addi	r2,r2,20
8110b374:	e0ffff17 	ldw	r3,-4(fp)
8110b378:	18c00517 	ldw	r3,20(r3)
8110b37c:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110b380:	e0bffe17 	ldw	r2,-8(fp)
8110b384:	10800604 	addi	r2,r2,24
8110b388:	e0ffff17 	ldw	r3,-4(fp)
8110b38c:	18c00617 	ldw	r3,24(r3)
8110b390:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110b394:	e0bffe17 	ldw	r2,-8(fp)
8110b398:	10800704 	addi	r2,r2,28
8110b39c:	e0ffff17 	ldw	r3,-4(fp)
8110b3a0:	18c00717 	ldw	r3,28(r3)
8110b3a4:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110b3a8:	0005883a 	mov	r2,zero
}
8110b3ac:	e037883a 	mov	sp,fp
8110b3b0:	df000017 	ldw	fp,0(sp)
8110b3b4:	dec00104 	addi	sp,sp,4
8110b3b8:	f800283a 	ret

8110b3bc <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110b3bc:	defff604 	addi	sp,sp,-40
8110b3c0:	de00012e 	bgeu	sp,et,8110b3c8 <msgdma_construct_extended_descriptor+0xc>
8110b3c4:	003b68fa 	trap	3
8110b3c8:	df000915 	stw	fp,36(sp)
8110b3cc:	df000904 	addi	fp,sp,36
8110b3d0:	e13ff715 	stw	r4,-36(fp)
8110b3d4:	e17ff815 	stw	r5,-32(fp)
8110b3d8:	e1bff915 	stw	r6,-28(fp)
8110b3dc:	e1fffa15 	stw	r7,-24(fp)
8110b3e0:	e1800517 	ldw	r6,20(fp)
8110b3e4:	e1400617 	ldw	r5,24(fp)
8110b3e8:	e1000717 	ldw	r4,28(fp)
8110b3ec:	e0c00817 	ldw	r3,32(fp)
8110b3f0:	e0800917 	ldw	r2,36(fp)
8110b3f4:	e1bffb0d 	sth	r6,-20(fp)
8110b3f8:	e17ffc05 	stb	r5,-16(fp)
8110b3fc:	e13ffd05 	stb	r4,-12(fp)
8110b400:	e0fffe0d 	sth	r3,-8(fp)
8110b404:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110b408:	e0bff717 	ldw	r2,-36(fp)
8110b40c:	10c01217 	ldw	r3,72(r2)
8110b410:	e0800117 	ldw	r2,4(fp)
8110b414:	18801936 	bltu	r3,r2,8110b47c <msgdma_construct_extended_descriptor+0xc0>
8110b418:	e13ff717 	ldw	r4,-36(fp)
8110b41c:	20801317 	ldw	r2,76(r4)
8110b420:	20c01417 	ldw	r3,80(r4)
8110b424:	e13ffe0b 	ldhu	r4,-8(fp)
8110b428:	213fffcc 	andi	r4,r4,65535
8110b42c:	2015883a 	mov	r10,r4
8110b430:	0017883a 	mov	r11,zero
8110b434:	1ac01136 	bltu	r3,r11,8110b47c <msgdma_construct_extended_descriptor+0xc0>
8110b438:	58c0011e 	bne	r11,r3,8110b440 <msgdma_construct_extended_descriptor+0x84>
8110b43c:	12800f36 	bltu	r2,r10,8110b47c <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110b440:	e13ff717 	ldw	r4,-36(fp)
8110b444:	20801317 	ldw	r2,76(r4)
8110b448:	20c01417 	ldw	r3,80(r4)
8110b44c:	e13fff0b 	ldhu	r4,-4(fp)
8110b450:	213fffcc 	andi	r4,r4,65535
8110b454:	2011883a 	mov	r8,r4
8110b458:	0013883a 	mov	r9,zero
8110b45c:	1a400736 	bltu	r3,r9,8110b47c <msgdma_construct_extended_descriptor+0xc0>
8110b460:	48c0011e 	bne	r9,r3,8110b468 <msgdma_construct_extended_descriptor+0xac>
8110b464:	12000536 	bltu	r2,r8,8110b47c <msgdma_construct_extended_descriptor+0xc0>
8110b468:	e0bff717 	ldw	r2,-36(fp)
8110b46c:	10801703 	ldbu	r2,92(r2)
8110b470:	10803fcc 	andi	r2,r2,255
8110b474:	10800060 	cmpeqi	r2,r2,1
8110b478:	1000021e 	bne	r2,zero,8110b484 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110b47c:	00bffa84 	movi	r2,-22
8110b480:	00002306 	br	8110b510 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110b484:	e0bff817 	ldw	r2,-32(fp)
8110b488:	e0fff917 	ldw	r3,-28(fp)
8110b48c:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110b490:	e0bff817 	ldw	r2,-32(fp)
8110b494:	e0fffa17 	ldw	r3,-24(fp)
8110b498:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110b49c:	e0bff817 	ldw	r2,-32(fp)
8110b4a0:	e0c00117 	ldw	r3,4(fp)
8110b4a4:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110b4a8:	e0bff817 	ldw	r2,-32(fp)
8110b4ac:	e0fffb0b 	ldhu	r3,-20(fp)
8110b4b0:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110b4b4:	e0bff817 	ldw	r2,-32(fp)
8110b4b8:	e0fffc03 	ldbu	r3,-16(fp)
8110b4bc:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110b4c0:	e0bff817 	ldw	r2,-32(fp)
8110b4c4:	e0fffd03 	ldbu	r3,-12(fp)
8110b4c8:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110b4cc:	e0bff817 	ldw	r2,-32(fp)
8110b4d0:	e0fffe0b 	ldhu	r3,-8(fp)
8110b4d4:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110b4d8:	e0bff817 	ldw	r2,-32(fp)
8110b4dc:	e0ffff0b 	ldhu	r3,-4(fp)
8110b4e0:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110b4e4:	e0bff817 	ldw	r2,-32(fp)
8110b4e8:	e0c00317 	ldw	r3,12(fp)
8110b4ec:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110b4f0:	e0bff817 	ldw	r2,-32(fp)
8110b4f4:	e0c00417 	ldw	r3,16(fp)
8110b4f8:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110b4fc:	e0800217 	ldw	r2,8(fp)
8110b500:	10e00034 	orhi	r3,r2,32768
8110b504:	e0bff817 	ldw	r2,-32(fp)
8110b508:	10c00715 	stw	r3,28(r2)

	return 0;
8110b50c:	0005883a 	mov	r2,zero

}
8110b510:	e037883a 	mov	sp,fp
8110b514:	df000017 	ldw	fp,0(sp)
8110b518:	dec00104 	addi	sp,sp,4
8110b51c:	f800283a 	ret

8110b520 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b520:	deffee04 	addi	sp,sp,-72
8110b524:	de00012e 	bgeu	sp,et,8110b52c <msgdma_descriptor_async_transfer+0xc>
8110b528:	003b68fa 	trap	3
8110b52c:	dfc01115 	stw	ra,68(sp)
8110b530:	df001015 	stw	fp,64(sp)
8110b534:	df001004 	addi	fp,sp,64
8110b538:	e13ffd15 	stw	r4,-12(fp)
8110b53c:	e17ffe15 	stw	r5,-8(fp)
8110b540:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b544:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110b548:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110b54c:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b550:	e0bffd17 	ldw	r2,-12(fp)
8110b554:	10800317 	ldw	r2,12(r2)
8110b558:	10800204 	addi	r2,r2,8
8110b55c:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b560:	10bfffcc 	andi	r2,r2,65535
8110b564:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b568:	e0bffd17 	ldw	r2,-12(fp)
8110b56c:	10800317 	ldw	r2,12(r2)
8110b570:	10800204 	addi	r2,r2,8
8110b574:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b578:	1004d43a 	srli	r2,r2,16
8110b57c:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b580:	e0bffd17 	ldw	r2,-12(fp)
8110b584:	10800917 	ldw	r2,36(r2)
8110b588:	e0fff417 	ldw	r3,-48(fp)
8110b58c:	1880042e 	bgeu	r3,r2,8110b5a0 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b590:	e0bffd17 	ldw	r2,-12(fp)
8110b594:	10800917 	ldw	r2,36(r2)
8110b598:	e0fff317 	ldw	r3,-52(fp)
8110b59c:	18800236 	bltu	r3,r2,8110b5a8 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110b5a0:	00bff904 	movi	r2,-28
8110b5a4:	0000ab06 	br	8110b854 <msgdma_descriptor_async_transfer+0x334>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110b5a8:	e0bffd17 	ldw	r2,-12(fp)
8110b5ac:	10801817 	ldw	r2,96(r2)
8110b5b0:	e0bff615 	stw	r2,-40(fp)
8110b5b4:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110b5b8:	e0bffc0b 	ldhu	r2,-16(fp)
8110b5bc:	e0fffc84 	addi	r3,fp,-14
8110b5c0:	180d883a 	mov	r6,r3
8110b5c4:	100b883a 	mov	r5,r2
8110b5c8:	e13ff617 	ldw	r4,-40(fp)
8110b5cc:	113fdcc0 	call	8113fdcc <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110b5d0:	00800804 	movi	r2,32
8110b5d4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b5d8:	0005303a 	rdctl	r2,status
8110b5dc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b5e0:	e0fff717 	ldw	r3,-36(fp)
8110b5e4:	00bfff84 	movi	r2,-2
8110b5e8:	1884703a 	and	r2,r3,r2
8110b5ec:	1001703a 	wrctl	status,r2
  
  return context;
8110b5f0:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b5f4:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b5f8:	e0bffd17 	ldw	r2,-12(fp)
8110b5fc:	10800317 	ldw	r2,12(r2)
8110b600:	10800104 	addi	r2,r2,4
8110b604:	e0fff117 	ldw	r3,-60(fp)
8110b608:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110b60c:	e0bffd17 	ldw	r2,-12(fp)
8110b610:	10800317 	ldw	r2,12(r2)
8110b614:	e0fffd17 	ldw	r3,-12(fp)
8110b618:	18c00317 	ldw	r3,12(r3)
8110b61c:	18c00037 	ldwio	r3,0(r3)
8110b620:	10c00035 	stwio	r3,0(r2)
8110b624:	e0bff217 	ldw	r2,-56(fp)
8110b628:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b62c:	e0bffb17 	ldw	r2,-20(fp)
8110b630:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110b634:	e0bffe17 	ldw	r2,-8(fp)
8110b638:	10001626 	beq	r2,zero,8110b694 <msgdma_descriptor_async_transfer+0x174>
8110b63c:	e0bfff17 	ldw	r2,-4(fp)
8110b640:	1000141e 	bne	r2,zero,8110b694 <msgdma_descriptor_async_transfer+0x174>
		counter = 0; /* reset counter */
8110b644:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110b648:	00a045b4 	movhi	r2,33046
8110b64c:	109fe204 	addi	r2,r2,32648
8110b650:	10800d8b 	ldhu	r2,54(r2)
8110b654:	10bfffcc 	andi	r2,r2,65535
8110b658:	10800228 	cmpgeui	r2,r2,8
8110b65c:	1000071e 	bne	r2,zero,8110b67c <msgdma_descriptor_async_transfer+0x15c>
		debug(fp, "invalid dma descriptor option\n");
8110b660:	d0a06217 	ldw	r2,-32376(gp)
8110b664:	100f883a 	mov	r7,r2
8110b668:	01800784 	movi	r6,30
8110b66c:	01400044 	movi	r5,1
8110b670:	01204574 	movhi	r4,33045
8110b674:	2135c904 	addi	r4,r4,-10460
8110b678:	1122fc80 	call	81122fc8 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b67c:	e0bffd17 	ldw	r2,-12(fp)
8110b680:	10801817 	ldw	r2,96(r2)
8110b684:	1009883a 	mov	r4,r2
8110b688:	11401540 	call	81140154 <OSSemPost>

		return -ETIME;
8110b68c:	00bff084 	movi	r2,-62
8110b690:	00007006 	br	8110b854 <msgdma_descriptor_async_transfer+0x334>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b694:	e0bffe17 	ldw	r2,-8(fp)
8110b698:	1000291e 	bne	r2,zero,8110b740 <msgdma_descriptor_async_transfer+0x220>
8110b69c:	e0bfff17 	ldw	r2,-4(fp)
8110b6a0:	10002726 	beq	r2,zero,8110b740 <msgdma_descriptor_async_transfer+0x220>
		counter = 0; /* reset counter */
8110b6a4:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b6a8:	00001b06 	br	8110b718 <msgdma_descriptor_async_transfer+0x1f8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110b6ac:	01000044 	movi	r4,1
8110b6b0:	11375540 	call	81137554 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b6b4:	e0bff00b 	ldhu	r2,-64(fp)
8110b6b8:	1084e230 	cmpltui	r2,r2,5000
8110b6bc:	1000131e 	bne	r2,zero,8110b70c <msgdma_descriptor_async_transfer+0x1ec>
			{
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110b6c0:	00a045b4 	movhi	r2,33046
8110b6c4:	109fe204 	addi	r2,r2,32648
8110b6c8:	10800d8b 	ldhu	r2,54(r2)
8110b6cc:	10bfffcc 	andi	r2,r2,65535
8110b6d0:	10800228 	cmpgeui	r2,r2,8
8110b6d4:	1000071e 	bne	r2,zero,8110b6f4 <msgdma_descriptor_async_transfer+0x1d4>
					debug(fp, "time out after 5 msec while waiting free FIFO buffer for storing extended descriptor\n");
8110b6d8:	d0a06217 	ldw	r2,-32376(gp)
8110b6dc:	100f883a 	mov	r7,r2
8110b6e0:	01801544 	movi	r6,85
8110b6e4:	01400044 	movi	r5,1
8110b6e8:	01204574 	movhi	r4,33045
8110b6ec:	2135d104 	addi	r4,r4,-10428
8110b6f0:	1122fc80 	call	81122fc8 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110b6f4:	e0bffd17 	ldw	r2,-12(fp)
8110b6f8:	10801817 	ldw	r2,96(r2)
8110b6fc:	1009883a 	mov	r4,r2
8110b700:	11401540 	call	81140154 <OSSemPost>

				return -ETIME;
8110b704:	00bff084 	movi	r2,-62
8110b708:	00005206 	br	8110b854 <msgdma_descriptor_async_transfer+0x334>
			}
			counter++;
8110b70c:	e0bff00b 	ldhu	r2,-64(fp)
8110b710:	10800044 	addi	r2,r2,1
8110b714:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110b718:	e0bffd17 	ldw	r2,-12(fp)
8110b71c:	10c00317 	ldw	r3,12(r2)
8110b720:	e0bffd17 	ldw	r2,-12(fp)
8110b724:	10800417 	ldw	r2,16(r2)
8110b728:	e1bfff17 	ldw	r6,-4(fp)
8110b72c:	100b883a 	mov	r5,r2
8110b730:	1809883a 	mov	r4,r3
8110b734:	110b2800 	call	8110b280 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b738:	103fdc1e 	bne	r2,zero,8110b6ac <__reset+0xfb0eb6ac>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b73c:	00000606 	br	8110b758 <msgdma_descriptor_async_transfer+0x238>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b740:	e0bffd17 	ldw	r2,-12(fp)
8110b744:	10801817 	ldw	r2,96(r2)
8110b748:	1009883a 	mov	r4,r2
8110b74c:	11401540 	call	81140154 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110b750:	00bfffc4 	movi	r2,-1
8110b754:	00003f06 	br	8110b854 <msgdma_descriptor_async_transfer+0x334>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110b758:	e0bffd17 	ldw	r2,-12(fp)
8110b75c:	10800b17 	ldw	r2,44(r2)
8110b760:	10001c26 	beq	r2,zero,8110b7d4 <msgdma_descriptor_async_transfer+0x2b4>

		control |= (dev->control |
8110b764:	e0bffd17 	ldw	r2,-12(fp)
8110b768:	10c00d17 	ldw	r3,52(r2)
8110b76c:	e0bff117 	ldw	r2,-60(fp)
8110b770:	1884b03a 	or	r2,r3,r2
8110b774:	10800514 	ori	r2,r2,20
8110b778:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110b77c:	e0fff117 	ldw	r3,-60(fp)
8110b780:	00bff7c4 	movi	r2,-33
8110b784:	1884703a 	and	r2,r3,r2
8110b788:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b78c:	0005303a 	rdctl	r2,status
8110b790:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b794:	e0fff917 	ldw	r3,-28(fp)
8110b798:	00bfff84 	movi	r2,-2
8110b79c:	1884703a 	and	r2,r3,r2
8110b7a0:	1001703a 	wrctl	status,r2
  
  return context;
8110b7a4:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110b7a8:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b7ac:	e0bffd17 	ldw	r2,-12(fp)
8110b7b0:	10800317 	ldw	r2,12(r2)
8110b7b4:	10800104 	addi	r2,r2,4
8110b7b8:	e0fff117 	ldw	r3,-60(fp)
8110b7bc:	10c00035 	stwio	r3,0(r2)
8110b7c0:	e0bff217 	ldw	r2,-56(fp)
8110b7c4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b7c8:	e0bff517 	ldw	r2,-44(fp)
8110b7cc:	1001703a 	wrctl	status,r2
8110b7d0:	00001b06 	br	8110b840 <msgdma_descriptor_async_transfer+0x320>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110b7d4:	e0bffd17 	ldw	r2,-12(fp)
8110b7d8:	10c00d17 	ldw	r3,52(r2)
8110b7dc:	e0bff117 	ldw	r2,-60(fp)
8110b7e0:	1884b03a 	or	r2,r3,r2
8110b7e4:	10800114 	ori	r2,r2,4
8110b7e8:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110b7ec:	e0fff117 	ldw	r3,-60(fp)
8110b7f0:	00bff3c4 	movi	r2,-49
8110b7f4:	1884703a 	and	r2,r3,r2
8110b7f8:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b7fc:	0005303a 	rdctl	r2,status
8110b800:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b804:	e0fffa17 	ldw	r3,-24(fp)
8110b808:	00bfff84 	movi	r2,-2
8110b80c:	1884703a 	and	r2,r3,r2
8110b810:	1001703a 	wrctl	status,r2
  
  return context;
8110b814:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110b818:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b81c:	e0bffd17 	ldw	r2,-12(fp)
8110b820:	10800317 	ldw	r2,12(r2)
8110b824:	10800104 	addi	r2,r2,4
8110b828:	e0fff117 	ldw	r3,-60(fp)
8110b82c:	10c00035 	stwio	r3,0(r2)
8110b830:	e0bff217 	ldw	r2,-56(fp)
8110b834:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b838:	e0bff817 	ldw	r2,-32(fp)
8110b83c:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110b840:	e0bffd17 	ldw	r2,-12(fp)
8110b844:	10801817 	ldw	r2,96(r2)
8110b848:	1009883a 	mov	r4,r2
8110b84c:	11401540 	call	81140154 <OSSemPost>

	return 0;
8110b850:	0005883a 	mov	r2,zero
}
8110b854:	e037883a 	mov	sp,fp
8110b858:	dfc00117 	ldw	ra,4(sp)
8110b85c:	df000017 	ldw	fp,0(sp)
8110b860:	dec00204 	addi	sp,sp,8
8110b864:	f800283a 	ret

8110b868 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b868:	deffee04 	addi	sp,sp,-72
8110b86c:	de00012e 	bgeu	sp,et,8110b874 <msgdma_descriptor_sync_transfer+0xc>
8110b870:	003b68fa 	trap	3
8110b874:	dfc01115 	stw	ra,68(sp)
8110b878:	df001015 	stw	fp,64(sp)
8110b87c:	df001004 	addi	fp,sp,64
8110b880:	e13ffd15 	stw	r4,-12(fp)
8110b884:	e17ffe15 	stw	r5,-8(fp)
8110b888:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b88c:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110b890:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110b894:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110b898:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b89c:	e0bffd17 	ldw	r2,-12(fp)
8110b8a0:	10800317 	ldw	r2,12(r2)
8110b8a4:	10800204 	addi	r2,r2,8
8110b8a8:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b8ac:	10bfffcc 	andi	r2,r2,65535
8110b8b0:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b8b4:	e0bffd17 	ldw	r2,-12(fp)
8110b8b8:	10800317 	ldw	r2,12(r2)
8110b8bc:	10800204 	addi	r2,r2,8
8110b8c0:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b8c4:	1004d43a 	srli	r2,r2,16
8110b8c8:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110b8cc:	00807804 	movi	r2,480
8110b8d0:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b8d4:	00003006 	br	8110b998 <msgdma_descriptor_sync_transfer+0x130>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110b8d8:	01000044 	movi	r4,1
8110b8dc:	11375540 	call	81137554 <alt_busy_sleep>
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110b8e0:	00a045b4 	movhi	r2,33046
8110b8e4:	109fe204 	addi	r2,r2,32648
8110b8e8:	10800d8b 	ldhu	r2,54(r2)
8110b8ec:	10bfffcc 	andi	r2,r2,65535
8110b8f0:	10800228 	cmpgeui	r2,r2,8
8110b8f4:	1000071e 	bne	r2,zero,8110b914 <msgdma_descriptor_sync_transfer+0xac>
		fprintf(fp,"\n-- DMA can't write in the descriptor \n ");
8110b8f8:	d0a06217 	ldw	r2,-32376(gp)
8110b8fc:	100f883a 	mov	r7,r2
8110b900:	01800a04 	movi	r6,40
8110b904:	01400044 	movi	r5,1
8110b908:	01204574 	movhi	r4,33045
8110b90c:	2135e704 	addi	r4,r4,-10340
8110b910:	1122fc80 	call	81122fc8 <fwrite>
	}
#endif
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b914:	e0bff10b 	ldhu	r2,-60(fp)
8110b918:	1084e230 	cmpltui	r2,r2,5000
8110b91c:	10000f1e 	bne	r2,zero,8110b95c <msgdma_descriptor_sync_transfer+0xf4>
		{
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110b920:	00a045b4 	movhi	r2,33046
8110b924:	109fe204 	addi	r2,r2,32648
8110b928:	10800d8b 	ldhu	r2,54(r2)
8110b92c:	10bfffcc 	andi	r2,r2,65535
8110b930:	10800228 	cmpgeui	r2,r2,8
8110b934:	1000071e 	bne	r2,zero,8110b954 <msgdma_descriptor_sync_transfer+0xec>
		debug(fp, "time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
8110b938:	d0a06217 	ldw	r2,-32376(gp)
8110b93c:	100f883a 	mov	r7,r2
8110b940:	01801304 	movi	r6,76
8110b944:	01400044 	movi	r5,1
8110b948:	01204574 	movhi	r4,33045
8110b94c:	2135f204 	addi	r4,r4,-10296
8110b950:	1122fc80 	call	81122fc8 <fwrite>
	}
#endif
			return -ETIME;
8110b954:	00bff084 	movi	r2,-62
8110b958:	0000e206 	br	8110bce4 <msgdma_descriptor_sync_transfer+0x47c>
		}
		counter++;
8110b95c:	e0bff10b 	ldhu	r2,-60(fp)
8110b960:	10800044 	addi	r2,r2,1
8110b964:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b968:	e0bffd17 	ldw	r2,-12(fp)
8110b96c:	10800317 	ldw	r2,12(r2)
8110b970:	10800204 	addi	r2,r2,8
8110b974:	10800037 	ldwio	r2,0(r2)
	}
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110b978:	10bfffcc 	andi	r2,r2,65535
8110b97c:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b980:	e0bffd17 	ldw	r2,-12(fp)
8110b984:	10800317 	ldw	r2,12(r2)
8110b988:	10800204 	addi	r2,r2,8
8110b98c:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110b990:	1004d43a 	srli	r2,r2,16
8110b994:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b998:	e0bffd17 	ldw	r2,-12(fp)
8110b99c:	10800917 	ldw	r2,36(r2)
8110b9a0:	e0fff317 	ldw	r3,-52(fp)
8110b9a4:	18bfcc2e 	bgeu	r3,r2,8110b8d8 <__reset+0xfb0eb8d8>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b9a8:	e0bffd17 	ldw	r2,-12(fp)
8110b9ac:	10800917 	ldw	r2,36(r2)
8110b9b0:	e0fff217 	ldw	r3,-56(fp)
8110b9b4:	18bfc82e 	bgeu	r3,r2,8110b8d8 <__reset+0xfb0eb8d8>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110b9b8:	e0bffd17 	ldw	r2,-12(fp)
8110b9bc:	10801817 	ldw	r2,96(r2)
8110b9c0:	e0bff815 	stw	r2,-32(fp)
8110b9c4:	e03ffc0d 	sth	zero,-16(fp)
8110b9c8:	e0bffc0b 	ldhu	r2,-16(fp)
8110b9cc:	e0fffc84 	addi	r3,fp,-14
8110b9d0:	180d883a 	mov	r6,r3
8110b9d4:	100b883a 	mov	r5,r2
8110b9d8:	e13ff817 	ldw	r4,-32(fp)
8110b9dc:	113fdcc0 	call	8113fdcc <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b9e0:	0005303a 	rdctl	r2,status
8110b9e4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b9e8:	e0fffb17 	ldw	r3,-20(fp)
8110b9ec:	00bfff84 	movi	r2,-2
8110b9f0:	1884703a 	and	r2,r3,r2
8110b9f4:	1001703a 	wrctl	status,r2
  
  return context;
8110b9f8:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b9fc:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110ba00:	e0bffd17 	ldw	r2,-12(fp)
8110ba04:	10800317 	ldw	r2,12(r2)
8110ba08:	10800104 	addi	r2,r2,4
8110ba0c:	00c00804 	movi	r3,32
8110ba10:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110ba14:	e0bffd17 	ldw	r2,-12(fp)
8110ba18:	10800317 	ldw	r2,12(r2)
8110ba1c:	e0fffd17 	ldw	r3,-12(fp)
8110ba20:	18c00317 	ldw	r3,12(r3)
8110ba24:	18c00037 	ldwio	r3,0(r3)
8110ba28:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110ba2c:	e0bffe17 	ldw	r2,-8(fp)
8110ba30:	10001626 	beq	r2,zero,8110ba8c <msgdma_descriptor_sync_transfer+0x224>
8110ba34:	e0bfff17 	ldw	r2,-4(fp)
8110ba38:	1000141e 	bne	r2,zero,8110ba8c <msgdma_descriptor_sync_transfer+0x224>
		counter = 0; /* reset counter */
8110ba3c:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110ba40:	00a045b4 	movhi	r2,33046
8110ba44:	109fe204 	addi	r2,r2,32648
8110ba48:	10800d8b 	ldhu	r2,54(r2)
8110ba4c:	10bfffcc 	andi	r2,r2,65535
8110ba50:	10800228 	cmpgeui	r2,r2,8
8110ba54:	1000071e 	bne	r2,zero,8110ba74 <msgdma_descriptor_sync_transfer+0x20c>
			debug(fp, "invalid dma descriptor option\n");
8110ba58:	d0a06217 	ldw	r2,-32376(gp)
8110ba5c:	100f883a 	mov	r7,r2
8110ba60:	01800784 	movi	r6,30
8110ba64:	01400044 	movi	r5,1
8110ba68:	01204574 	movhi	r4,33045
8110ba6c:	2135c904 	addi	r4,r4,-10460
8110ba70:	1122fc80 	call	81122fc8 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110ba74:	e0bffd17 	ldw	r2,-12(fp)
8110ba78:	10801817 	ldw	r2,96(r2)
8110ba7c:	1009883a 	mov	r4,r2
8110ba80:	11401540 	call	81140154 <OSSemPost>

		return -ETIME;
8110ba84:	00bff084 	movi	r2,-62
8110ba88:	00009606 	br	8110bce4 <msgdma_descriptor_sync_transfer+0x47c>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110ba8c:	e0bffe17 	ldw	r2,-8(fp)
8110ba90:	1000291e 	bne	r2,zero,8110bb38 <msgdma_descriptor_sync_transfer+0x2d0>
8110ba94:	e0bfff17 	ldw	r2,-4(fp)
8110ba98:	10002726 	beq	r2,zero,8110bb38 <msgdma_descriptor_sync_transfer+0x2d0>
		counter = 0; /* reset counter */
8110ba9c:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110baa0:	00001b06 	br	8110bb10 <msgdma_descriptor_sync_transfer+0x2a8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110baa4:	01000044 	movi	r4,1
8110baa8:	11375540 	call	81137554 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110baac:	e0bff10b 	ldhu	r2,-60(fp)
8110bab0:	1084e230 	cmpltui	r2,r2,5000
8110bab4:	1000131e 	bne	r2,zero,8110bb04 <msgdma_descriptor_sync_transfer+0x29c>
			{
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110bab8:	00a045b4 	movhi	r2,33046
8110babc:	109fe204 	addi	r2,r2,32648
8110bac0:	10800d8b 	ldhu	r2,54(r2)
8110bac4:	10bfffcc 	andi	r2,r2,65535
8110bac8:	10800228 	cmpgeui	r2,r2,8
8110bacc:	1000071e 	bne	r2,zero,8110baec <msgdma_descriptor_sync_transfer+0x284>
					debug(fp, "time out after 5 msec while writing extended descriptor to FIFO\n");
8110bad0:	d0a06217 	ldw	r2,-32376(gp)
8110bad4:	100f883a 	mov	r7,r2
8110bad8:	01801004 	movi	r6,64
8110badc:	01400044 	movi	r5,1
8110bae0:	01204574 	movhi	r4,33045
8110bae4:	21360604 	addi	r4,r4,-10216
8110bae8:	1122fc80 	call	81122fc8 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110baec:	e0bffd17 	ldw	r2,-12(fp)
8110baf0:	10801817 	ldw	r2,96(r2)
8110baf4:	1009883a 	mov	r4,r2
8110baf8:	11401540 	call	81140154 <OSSemPost>

				return -ETIME;
8110bafc:	00bff084 	movi	r2,-62
8110bb00:	00007806 	br	8110bce4 <msgdma_descriptor_sync_transfer+0x47c>
			}
			counter++;
8110bb04:	e0bff10b 	ldhu	r2,-60(fp)
8110bb08:	10800044 	addi	r2,r2,1
8110bb0c:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110bb10:	e0bffd17 	ldw	r2,-12(fp)
8110bb14:	10c00317 	ldw	r3,12(r2)
8110bb18:	e0bffd17 	ldw	r2,-12(fp)
8110bb1c:	10800417 	ldw	r2,16(r2)
8110bb20:	e1bfff17 	ldw	r6,-4(fp)
8110bb24:	100b883a 	mov	r5,r2
8110bb28:	1809883a 	mov	r4,r3
8110bb2c:	110b2800 	call	8110b280 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110bb30:	103fdc1e 	bne	r2,zero,8110baa4 <__reset+0xfb0ebaa4>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110bb34:	00000606 	br	8110bb50 <msgdma_descriptor_sync_transfer+0x2e8>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110bb38:	e0bffd17 	ldw	r2,-12(fp)
8110bb3c:	10801817 	ldw	r2,96(r2)
8110bb40:	1009883a 	mov	r4,r2
8110bb44:	11401540 	call	81140154 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110bb48:	00bfffc4 	movi	r2,-1
8110bb4c:	00006506 	br	8110bce4 <msgdma_descriptor_sync_transfer+0x47c>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110bb50:	e0bffd17 	ldw	r2,-12(fp)
8110bb54:	10800317 	ldw	r2,12(r2)
8110bb58:	10800104 	addi	r2,r2,4
8110bb5c:	e0fffd17 	ldw	r3,-12(fp)
8110bb60:	19000d17 	ldw	r4,52(r3)
8110bb64:	00fff2c4 	movi	r3,-53
8110bb68:	20c6703a 	and	r3,r4,r3
8110bb6c:	18c00114 	ori	r3,r3,4
8110bb70:	10c00035 	stwio	r3,0(r2)
8110bb74:	e0bff517 	ldw	r2,-44(fp)
8110bb78:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bb7c:	e0bff717 	ldw	r2,-36(fp)
8110bb80:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110bb84:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110bb88:	e0bffd17 	ldw	r2,-12(fp)
8110bb8c:	10800317 	ldw	r2,12(r2)
8110bb90:	10800037 	ldwio	r2,0(r2)
8110bb94:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110bb98:	00001f06 	br	8110bc18 <msgdma_descriptor_sync_transfer+0x3b0>
		alt_busy_sleep(1); /* delay 1us */
8110bb9c:	01000044 	movi	r4,1
8110bba0:	11375540 	call	81137554 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110bba4:	e0bff10b 	ldhu	r2,-60(fp)
8110bba8:	1084e230 	cmpltui	r2,r2,5000
8110bbac:	1000131e 	bne	r2,zero,8110bbfc <msgdma_descriptor_sync_transfer+0x394>
		{
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110bbb0:	00a045b4 	movhi	r2,33046
8110bbb4:	109fe204 	addi	r2,r2,32648
8110bbb8:	10800d8b 	ldhu	r2,54(r2)
8110bbbc:	10bfffcc 	andi	r2,r2,65535
8110bbc0:	10800228 	cmpgeui	r2,r2,8
8110bbc4:	1000071e 	bne	r2,zero,8110bbe4 <msgdma_descriptor_sync_transfer+0x37c>
				debug(fp, "time out after 5 msec while waiting for any pending transfer complete\n");
8110bbc8:	d0a06217 	ldw	r2,-32376(gp)
8110bbcc:	100f883a 	mov	r7,r2
8110bbd0:	01801184 	movi	r6,70
8110bbd4:	01400044 	movi	r5,1
8110bbd8:	01204574 	movhi	r4,33045
8110bbdc:	21361704 	addi	r4,r4,-10148
8110bbe0:	1122fc80 	call	81122fc8 <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110bbe4:	e0bffd17 	ldw	r2,-12(fp)
8110bbe8:	10801817 	ldw	r2,96(r2)
8110bbec:	1009883a 	mov	r4,r2
8110bbf0:	11401540 	call	81140154 <OSSemPost>

			return -ETIME;
8110bbf4:	00bff084 	movi	r2,-62
8110bbf8:	00003a06 	br	8110bce4 <msgdma_descriptor_sync_transfer+0x47c>
		}
		counter++;
8110bbfc:	e0bff10b 	ldhu	r2,-60(fp)
8110bc00:	10800044 	addi	r2,r2,1
8110bc04:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110bc08:	e0bffd17 	ldw	r2,-12(fp)
8110bc0c:	10800317 	ldw	r2,12(r2)
8110bc10:	10800037 	ldwio	r2,0(r2)
8110bc14:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110bc18:	e0fff017 	ldw	r3,-64(fp)
8110bc1c:	e0bff617 	ldw	r2,-40(fp)
8110bc20:	1884703a 	and	r2,r3,r2
8110bc24:	1000031e 	bne	r2,zero,8110bc34 <msgdma_descriptor_sync_transfer+0x3cc>
8110bc28:	e0bff017 	ldw	r2,-64(fp)
8110bc2c:	1080004c 	andi	r2,r2,1
8110bc30:	103fda1e 	bne	r2,zero,8110bb9c <__reset+0xfb0ebb9c>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110bc34:	e0fff017 	ldw	r3,-64(fp)
8110bc38:	e0bff617 	ldw	r2,-40(fp)
8110bc3c:	1884703a 	and	r2,r3,r2
8110bc40:	10000626 	beq	r2,zero,8110bc5c <msgdma_descriptor_sync_transfer+0x3f4>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110bc44:	e0bffd17 	ldw	r2,-12(fp)
8110bc48:	10801817 	ldw	r2,96(r2)
8110bc4c:	1009883a 	mov	r4,r2
8110bc50:	11401540 	call	81140154 <OSSemPost>

		return error;
8110bc54:	e0bff617 	ldw	r2,-40(fp)
8110bc58:	00002206 	br	8110bce4 <msgdma_descriptor_sync_transfer+0x47c>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110bc5c:	e0bffd17 	ldw	r2,-12(fp)
8110bc60:	10800317 	ldw	r2,12(r2)
8110bc64:	10800104 	addi	r2,r2,4
8110bc68:	10800037 	ldwio	r2,0(r2)
8110bc6c:	10800814 	ori	r2,r2,32
8110bc70:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110bc74:	0005303a 	rdctl	r2,status
8110bc78:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110bc7c:	e0fffa17 	ldw	r3,-24(fp)
8110bc80:	00bfff84 	movi	r2,-2
8110bc84:	1884703a 	and	r2,r3,r2
8110bc88:	1001703a 	wrctl	status,r2
  
  return context;
8110bc8c:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110bc90:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110bc94:	e0bffd17 	ldw	r2,-12(fp)
8110bc98:	10800317 	ldw	r2,12(r2)
8110bc9c:	10800104 	addi	r2,r2,4
8110bca0:	e0fff417 	ldw	r3,-48(fp)
8110bca4:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110bca8:	e0bffd17 	ldw	r2,-12(fp)
8110bcac:	10800317 	ldw	r2,12(r2)
8110bcb0:	e0fffd17 	ldw	r3,-12(fp)
8110bcb4:	18c00317 	ldw	r3,12(r3)
8110bcb8:	18c00037 	ldwio	r3,0(r3)
8110bcbc:	10c00035 	stwio	r3,0(r2)
8110bcc0:	e0bff517 	ldw	r2,-44(fp)
8110bcc4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bcc8:	e0bff917 	ldw	r2,-28(fp)
8110bccc:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110bcd0:	e0bffd17 	ldw	r2,-12(fp)
8110bcd4:	10801817 	ldw	r2,96(r2)
8110bcd8:	1009883a 	mov	r4,r2
8110bcdc:	11401540 	call	81140154 <OSSemPost>

	return 0;
8110bce0:	0005883a 	mov	r2,zero

}
8110bce4:	e037883a 	mov	sp,fp
8110bce8:	dfc00117 	ldw	ra,4(sp)
8110bcec:	df000017 	ldw	fp,0(sp)
8110bcf0:	dec00204 	addi	sp,sp,8
8110bcf4:	f800283a 	ret

8110bcf8 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110bcf8:	deffec04 	addi	sp,sp,-80
8110bcfc:	de00012e 	bgeu	sp,et,8110bd04 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110bd00:	003b68fa 	trap	3
8110bd04:	dfc01315 	stw	ra,76(sp)
8110bd08:	df001215 	stw	fp,72(sp)
8110bd0c:	df001204 	addi	fp,sp,72
8110bd10:	e13ff715 	stw	r4,-36(fp)
8110bd14:	e17ff815 	stw	r5,-32(fp)
8110bd18:	e1bff915 	stw	r6,-28(fp)
8110bd1c:	e1fffa15 	stw	r7,-24(fp)
8110bd20:	e1800617 	ldw	r6,24(fp)
8110bd24:	e1400717 	ldw	r5,28(fp)
8110bd28:	e1000817 	ldw	r4,32(fp)
8110bd2c:	e0c00917 	ldw	r3,36(fp)
8110bd30:	e0800a17 	ldw	r2,40(fp)
8110bd34:	e1bffb0d 	sth	r6,-20(fp)
8110bd38:	e17ffc05 	stb	r5,-16(fp)
8110bd3c:	e13ffd05 	stb	r4,-12(fp)
8110bd40:	e0fffe0d 	sth	r3,-8(fp)
8110bd44:	e0bfff0d 	sth	r2,-4(fp)

	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110bd48:	e0bffb0b 	ldhu	r2,-20(fp)
8110bd4c:	e0fffc03 	ldbu	r3,-16(fp)
8110bd50:	e13ffd03 	ldbu	r4,-12(fp)
8110bd54:	e17ffe0b 	ldhu	r5,-8(fp)
8110bd58:	e1bfff0b 	ldhu	r6,-4(fp)
8110bd5c:	d9800815 	stw	r6,32(sp)
8110bd60:	d9400715 	stw	r5,28(sp)
8110bd64:	d9000615 	stw	r4,24(sp)
8110bd68:	d8c00515 	stw	r3,20(sp)
8110bd6c:	d8800415 	stw	r2,16(sp)
8110bd70:	e0800517 	ldw	r2,20(fp)
8110bd74:	d8800315 	stw	r2,12(sp)
8110bd78:	e0800417 	ldw	r2,16(fp)
8110bd7c:	d8800215 	stw	r2,8(sp)
8110bd80:	e0800317 	ldw	r2,12(fp)
8110bd84:	d8800115 	stw	r2,4(sp)
8110bd88:	e0800217 	ldw	r2,8(fp)
8110bd8c:	d8800015 	stw	r2,0(sp)
8110bd90:	e1fffa17 	ldw	r7,-24(fp)
8110bd94:	e1bff917 	ldw	r6,-28(fp)
8110bd98:	e17ff817 	ldw	r5,-32(fp)
8110bd9c:	e13ff717 	ldw	r4,-36(fp)
8110bda0:	110b3bc0 	call	8110b3bc <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110bda4:	e037883a 	mov	sp,fp
8110bda8:	dfc00117 	ldw	ra,4(sp)
8110bdac:	df000017 	ldw	fp,0(sp)
8110bdb0:	dec00204 	addi	sp,sp,8
8110bdb4:	f800283a 	ret

8110bdb8 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110bdb8:	defffc04 	addi	sp,sp,-16
8110bdbc:	de00012e 	bgeu	sp,et,8110bdc4 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110bdc0:	003b68fa 	trap	3
8110bdc4:	dfc00315 	stw	ra,12(sp)
8110bdc8:	df000215 	stw	fp,8(sp)
8110bdcc:	df000204 	addi	fp,sp,8
8110bdd0:	e13ffe15 	stw	r4,-8(fp)
8110bdd4:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110bdd8:	e1bfff17 	ldw	r6,-4(fp)
8110bddc:	000b883a 	mov	r5,zero
8110bde0:	e13ffe17 	ldw	r4,-8(fp)
8110bde4:	110b5200 	call	8110b520 <msgdma_descriptor_async_transfer>
}
8110bde8:	e037883a 	mov	sp,fp
8110bdec:	dfc00117 	ldw	ra,4(sp)
8110bdf0:	df000017 	ldw	fp,0(sp)
8110bdf4:	dec00204 	addi	sp,sp,8
8110bdf8:	f800283a 	ret

8110bdfc <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110bdfc:	defffc04 	addi	sp,sp,-16
8110be00:	de00012e 	bgeu	sp,et,8110be08 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110be04:	003b68fa 	trap	3
8110be08:	dfc00315 	stw	ra,12(sp)
8110be0c:	df000215 	stw	fp,8(sp)
8110be10:	df000204 	addi	fp,sp,8
8110be14:	e13ffe15 	stw	r4,-8(fp)
8110be18:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110be1c:	e1bfff17 	ldw	r6,-4(fp)
8110be20:	000b883a 	mov	r5,zero
8110be24:	e13ffe17 	ldw	r4,-8(fp)
8110be28:	110b8680 	call	8110b868 <msgdma_descriptor_sync_transfer>
}
8110be2c:	e037883a 	mov	sp,fp
8110be30:	dfc00117 	ldw	ra,4(sp)
8110be34:	df000017 	ldw	fp,0(sp)
8110be38:	dec00204 	addi	sp,sp,8
8110be3c:	f800283a 	ret

8110be40 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110be40:	defff204 	addi	sp,sp,-56
8110be44:	de00012e 	bgeu	sp,et,8110be4c <POWER_SPI_RW+0xc>
8110be48:	003b68fa 	trap	3
8110be4c:	dfc00d15 	stw	ra,52(sp)
8110be50:	df000c15 	stw	fp,48(sp)
8110be54:	df000c04 	addi	fp,sp,48
8110be58:	2007883a 	mov	r3,r4
8110be5c:	2805883a 	mov	r2,r5
8110be60:	e1bffe15 	stw	r6,-8(fp)
8110be64:	e1ffff15 	stw	r7,-4(fp)
8110be68:	e0fffc05 	stb	r3,-16(fp)
8110be6c:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110be70:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110be74:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110be78:	008003f4 	movhi	r2,15
8110be7c:	10909004 	addi	r2,r2,16960
8110be80:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110be84:	00bfe004 	movi	r2,-128
8110be88:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110be8c:	e0bffe17 	ldw	r2,-8(fp)
8110be90:	10000226 	beq	r2,zero,8110be9c <POWER_SPI_RW+0x5c>
8110be94:	00800804 	movi	r2,32
8110be98:	00000106 	br	8110bea0 <POWER_SPI_RW+0x60>
8110be9c:	0005883a 	mov	r2,zero
8110bea0:	e0fff403 	ldbu	r3,-48(fp)
8110bea4:	10c4b03a 	or	r2,r2,r3
8110bea8:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110beac:	e0800217 	ldw	r2,8(fp)
8110beb0:	10000226 	beq	r2,zero,8110bebc <POWER_SPI_RW+0x7c>
8110beb4:	00800404 	movi	r2,16
8110beb8:	00000106 	br	8110bec0 <POWER_SPI_RW+0x80>
8110bebc:	0005883a 	mov	r2,zero
8110bec0:	e0fff403 	ldbu	r3,-48(fp)
8110bec4:	10c4b03a 	or	r2,r2,r3
8110bec8:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110becc:	e0bfff17 	ldw	r2,-4(fp)
8110bed0:	10000226 	beq	r2,zero,8110bedc <POWER_SPI_RW+0x9c>
8110bed4:	00800204 	movi	r2,8
8110bed8:	00000106 	br	8110bee0 <POWER_SPI_RW+0xa0>
8110bedc:	0005883a 	mov	r2,zero
8110bee0:	e0fff403 	ldbu	r3,-48(fp)
8110bee4:	10c4b03a 	or	r2,r2,r3
8110bee8:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110beec:	e0bffd03 	ldbu	r2,-12(fp)
8110bef0:	108001cc 	andi	r2,r2,7
8110bef4:	1007883a 	mov	r3,r2
8110bef8:	e0bff403 	ldbu	r2,-48(fp)
8110befc:	1884b03a 	or	r2,r3,r2
8110bf00:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110bf04:	0007883a 	mov	r3,zero
8110bf08:	00a00034 	movhi	r2,32768
8110bf0c:	10824404 	addi	r2,r2,2320
8110bf10:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110bf14:	0007883a 	mov	r3,zero
8110bf18:	00a00034 	movhi	r2,32768
8110bf1c:	10824c04 	addi	r2,r2,2352
8110bf20:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110bf24:	e0bffc03 	ldbu	r2,-16(fp)
8110bf28:	1000021e 	bne	r2,zero,8110bf34 <POWER_SPI_RW+0xf4>
8110bf2c:	00c00084 	movi	r3,2
8110bf30:	00000106 	br	8110bf38 <POWER_SPI_RW+0xf8>
8110bf34:	00c00044 	movi	r3,1
8110bf38:	00a00034 	movhi	r2,32768
8110bf3c:	10824804 	addi	r2,r2,2336
8110bf40:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110bf44:	010003c4 	movi	r4,15
8110bf48:	1138fc80 	call	81138fc8 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110bf4c:	00000306 	br	8110bf5c <POWER_SPI_RW+0x11c>
		nWait++;
8110bf50:	e0bff817 	ldw	r2,-32(fp)
8110bf54:	10800044 	addi	r2,r2,1
8110bf58:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110bf5c:	00a00034 	movhi	r2,32768
8110bf60:	10825404 	addi	r2,r2,2384
8110bf64:	10800037 	ldwio	r2,0(r2)
8110bf68:	1080004c 	andi	r2,r2,1
8110bf6c:	10000326 	beq	r2,zero,8110bf7c <POWER_SPI_RW+0x13c>
8110bf70:	e0fff817 	ldw	r3,-32(fp)
8110bf74:	e0bffa17 	ldw	r2,-24(fp)
8110bf78:	18bff516 	blt	r3,r2,8110bf50 <__reset+0xfb0ebf50>
		nWait++;
	}

	if (SPI_SDO) {
8110bf7c:	00a00034 	movhi	r2,32768
8110bf80:	10825404 	addi	r2,r2,2384
8110bf84:	10800037 	ldwio	r2,0(r2)
8110bf88:	1080004c 	andi	r2,r2,1
8110bf8c:	10000626 	beq	r2,zero,8110bfa8 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110bf90:	00c000c4 	movi	r3,3
8110bf94:	00a00034 	movhi	r2,32768
8110bf98:	10824804 	addi	r2,r2,2336
8110bf9c:	10c00035 	stwio	r3,0(r2)
		return FALSE;
8110bfa0:	0005883a 	mov	r2,zero
8110bfa4:	0000db06 	br	8110c314 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110bfa8:	e03ff715 	stw	zero,-36(fp)
8110bfac:	00002406 	br	8110c040 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110bfb0:	e0bff403 	ldbu	r2,-48(fp)
8110bfb4:	10803fcc 	andi	r2,r2,255
8110bfb8:	1004d1fa 	srli	r2,r2,7
8110bfbc:	10c03fcc 	andi	r3,r2,255
8110bfc0:	00a00034 	movhi	r2,32768
8110bfc4:	10825004 	addi	r2,r2,2368
8110bfc8:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110bfcc:	e0bff403 	ldbu	r2,-48(fp)
8110bfd0:	1085883a 	add	r2,r2,r2
8110bfd4:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110bfd8:	e0bff517 	ldw	r2,-44(fp)
8110bfdc:	1085883a 	add	r2,r2,r2
8110bfe0:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110bfe4:	00a00034 	movhi	r2,32768
8110bfe8:	10825404 	addi	r2,r2,2384
8110bfec:	10800037 	ldwio	r2,0(r2)
8110bff0:	1080004c 	andi	r2,r2,1
8110bff4:	1007883a 	mov	r3,r2
8110bff8:	e0bff517 	ldw	r2,-44(fp)
8110bffc:	10c4b03a 	or	r2,r2,r3
8110c000:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c004:	00c00044 	movi	r3,1
8110c008:	00a00034 	movhi	r2,32768
8110c00c:	10824c04 	addi	r2,r2,2352
8110c010:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c014:	010003c4 	movi	r4,15
8110c018:	1138fc80 	call	81138fc8 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c01c:	0007883a 	mov	r3,zero
8110c020:	00a00034 	movhi	r2,32768
8110c024:	10824c04 	addi	r2,r2,2352
8110c028:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c02c:	010003c4 	movi	r4,15
8110c030:	1138fc80 	call	81138fc8 <usleep>
	if (SPI_SDO) {
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110c034:	e0bff717 	ldw	r2,-36(fp)
8110c038:	10800044 	addi	r2,r2,1
8110c03c:	e0bff715 	stw	r2,-36(fp)
8110c040:	e0bff717 	ldw	r2,-36(fp)
8110c044:	10800090 	cmplti	r2,r2,2
8110c048:	103fd91e 	bne	r2,zero,8110bfb0 <__reset+0xfb0ebfb0>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110c04c:	e03ff715 	stw	zero,-36(fp)
8110c050:	00002406 	br	8110c0e4 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110c054:	e0bff403 	ldbu	r2,-48(fp)
8110c058:	10803fcc 	andi	r2,r2,255
8110c05c:	1004d1fa 	srli	r2,r2,7
8110c060:	10c03fcc 	andi	r3,r2,255
8110c064:	00a00034 	movhi	r2,32768
8110c068:	10825004 	addi	r2,r2,2368
8110c06c:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110c070:	e0bff403 	ldbu	r2,-48(fp)
8110c074:	1085883a 	add	r2,r2,r2
8110c078:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110c07c:	e0bff517 	ldw	r2,-44(fp)
8110c080:	1085883a 	add	r2,r2,r2
8110c084:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110c088:	00a00034 	movhi	r2,32768
8110c08c:	10825404 	addi	r2,r2,2384
8110c090:	10800037 	ldwio	r2,0(r2)
8110c094:	1080004c 	andi	r2,r2,1
8110c098:	1007883a 	mov	r3,r2
8110c09c:	e0bff517 	ldw	r2,-44(fp)
8110c0a0:	10c4b03a 	or	r2,r2,r3
8110c0a4:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c0a8:	00c00044 	movi	r3,1
8110c0ac:	00a00034 	movhi	r2,32768
8110c0b0:	10824c04 	addi	r2,r2,2352
8110c0b4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c0b8:	010003c4 	movi	r4,15
8110c0bc:	1138fc80 	call	81138fc8 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c0c0:	0007883a 	mov	r3,zero
8110c0c4:	00a00034 	movhi	r2,32768
8110c0c8:	10824c04 	addi	r2,r2,2352
8110c0cc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c0d0:	010003c4 	movi	r4,15
8110c0d4:	1138fc80 	call	81138fc8 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110c0d8:	e0bff717 	ldw	r2,-36(fp)
8110c0dc:	10800044 	addi	r2,r2,1
8110c0e0:	e0bff715 	stw	r2,-36(fp)
8110c0e4:	e0bff717 	ldw	r2,-36(fp)
8110c0e8:	10800210 	cmplti	r2,r2,8
8110c0ec:	103fd91e 	bne	r2,zero,8110c054 <__reset+0xfb0ec054>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c0f0:	e03ff715 	stw	zero,-36(fp)
8110c0f4:	00001a06 	br	8110c160 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110c0f8:	e0bff517 	ldw	r2,-44(fp)
8110c0fc:	1085883a 	add	r2,r2,r2
8110c100:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110c104:	00a00034 	movhi	r2,32768
8110c108:	10825404 	addi	r2,r2,2384
8110c10c:	10800037 	ldwio	r2,0(r2)
8110c110:	1080004c 	andi	r2,r2,1
8110c114:	1007883a 	mov	r3,r2
8110c118:	e0bff517 	ldw	r2,-44(fp)
8110c11c:	10c4b03a 	or	r2,r2,r3
8110c120:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c124:	00c00044 	movi	r3,1
8110c128:	00a00034 	movhi	r2,32768
8110c12c:	10824c04 	addi	r2,r2,2352
8110c130:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c134:	010003c4 	movi	r4,15
8110c138:	1138fc80 	call	81138fc8 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c13c:	0007883a 	mov	r3,zero
8110c140:	00a00034 	movhi	r2,32768
8110c144:	10824c04 	addi	r2,r2,2352
8110c148:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c14c:	010003c4 	movi	r4,15
8110c150:	1138fc80 	call	81138fc8 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c154:	e0bff717 	ldw	r2,-36(fp)
8110c158:	10800044 	addi	r2,r2,1
8110c15c:	e0bff715 	stw	r2,-36(fp)
8110c160:	e0bff717 	ldw	r2,-36(fp)
8110c164:	10800210 	cmplti	r2,r2,8
8110c168:	103fe31e 	bne	r2,zero,8110c0f8 <__reset+0xfb0ec0f8>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c16c:	e03ff715 	stw	zero,-36(fp)
8110c170:	00001a06 	br	8110c1dc <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110c174:	e0bff517 	ldw	r2,-44(fp)
8110c178:	1085883a 	add	r2,r2,r2
8110c17c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110c180:	00a00034 	movhi	r2,32768
8110c184:	10825404 	addi	r2,r2,2384
8110c188:	10800037 	ldwio	r2,0(r2)
8110c18c:	1080004c 	andi	r2,r2,1
8110c190:	1007883a 	mov	r3,r2
8110c194:	e0bff517 	ldw	r2,-44(fp)
8110c198:	10c4b03a 	or	r2,r2,r3
8110c19c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c1a0:	00c00044 	movi	r3,1
8110c1a4:	00a00034 	movhi	r2,32768
8110c1a8:	10824c04 	addi	r2,r2,2352
8110c1ac:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c1b0:	010003c4 	movi	r4,15
8110c1b4:	1138fc80 	call	81138fc8 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c1b8:	0007883a 	mov	r3,zero
8110c1bc:	00a00034 	movhi	r2,32768
8110c1c0:	10824c04 	addi	r2,r2,2352
8110c1c4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c1c8:	010003c4 	movi	r4,15
8110c1cc:	1138fc80 	call	81138fc8 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c1d0:	e0bff717 	ldw	r2,-36(fp)
8110c1d4:	10800044 	addi	r2,r2,1
8110c1d8:	e0bff715 	stw	r2,-36(fp)
8110c1dc:	e0bff717 	ldw	r2,-36(fp)
8110c1e0:	10800210 	cmplti	r2,r2,8
8110c1e4:	103fe31e 	bne	r2,zero,8110c174 <__reset+0xfb0ec174>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c1e8:	e03ff715 	stw	zero,-36(fp)
8110c1ec:	00001a06 	br	8110c258 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110c1f0:	e0bff517 	ldw	r2,-44(fp)
8110c1f4:	1085883a 	add	r2,r2,r2
8110c1f8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110c1fc:	00a00034 	movhi	r2,32768
8110c200:	10825404 	addi	r2,r2,2384
8110c204:	10800037 	ldwio	r2,0(r2)
8110c208:	1080004c 	andi	r2,r2,1
8110c20c:	1007883a 	mov	r3,r2
8110c210:	e0bff517 	ldw	r2,-44(fp)
8110c214:	10c4b03a 	or	r2,r2,r3
8110c218:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c21c:	00c00044 	movi	r3,1
8110c220:	00a00034 	movhi	r2,32768
8110c224:	10824c04 	addi	r2,r2,2352
8110c228:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c22c:	010003c4 	movi	r4,15
8110c230:	1138fc80 	call	81138fc8 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c234:	0007883a 	mov	r3,zero
8110c238:	00a00034 	movhi	r2,32768
8110c23c:	10824c04 	addi	r2,r2,2352
8110c240:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c244:	010003c4 	movi	r4,15
8110c248:	1138fc80 	call	81138fc8 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c24c:	e0bff717 	ldw	r2,-36(fp)
8110c250:	10800044 	addi	r2,r2,1
8110c254:	e0bff715 	stw	r2,-36(fp)
8110c258:	e0bff717 	ldw	r2,-36(fp)
8110c25c:	10800190 	cmplti	r2,r2,6
8110c260:	103fe31e 	bne	r2,zero,8110c1f0 <__reset+0xfb0ec1f0>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110c264:	00c00044 	movi	r3,1
8110c268:	00a00034 	movhi	r2,32768
8110c26c:	10824c04 	addi	r2,r2,2352
8110c270:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110c274:	010003c4 	movi	r4,15
8110c278:	1138fc80 	call	81138fc8 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110c27c:	00c000c4 	movi	r3,3
8110c280:	00a00034 	movhi	r2,32768
8110c284:	10824804 	addi	r2,r2,2336
8110c288:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110c28c:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110c290:	00800044 	movi	r2,1
8110c294:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110c298:	e03ff715 	stw	zero,-36(fp)
8110c29c:	00000d06 	br	8110c2d4 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110c2a0:	e0fff517 	ldw	r3,-44(fp)
8110c2a4:	e0bff617 	ldw	r2,-40(fp)
8110c2a8:	1884703a 	and	r2,r3,r2
8110c2ac:	1000031e 	bne	r2,zero,8110c2bc <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110c2b0:	e0bff917 	ldw	r2,-28(fp)
8110c2b4:	10800044 	addi	r2,r2,1
8110c2b8:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110c2bc:	e0bff617 	ldw	r2,-40(fp)
8110c2c0:	1085883a 	add	r2,r2,r2
8110c2c4:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110c2c8:	e0bff717 	ldw	r2,-36(fp)
8110c2cc:	10800044 	addi	r2,r2,1
8110c2d0:	e0bff715 	stw	r2,-36(fp)
8110c2d4:	e0bff717 	ldw	r2,-36(fp)
8110c2d8:	10800810 	cmplti	r2,r2,32
8110c2dc:	103ff01e 	bne	r2,zero,8110c2a0 <__reset+0xfb0ec2a0>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110c2e0:	e0bff917 	ldw	r2,-28(fp)
8110c2e4:	1080004c 	andi	r2,r2,1
8110c2e8:	1005003a 	cmpeq	r2,r2,zero
8110c2ec:	10803fcc 	andi	r2,r2,255
8110c2f0:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110c2f4:	e0bffb17 	ldw	r2,-20(fp)
8110c2f8:	1000021e 	bne	r2,zero,8110c304 <POWER_SPI_RW+0x4c4>
		return FALSE;
8110c2fc:	0005883a 	mov	r2,zero
8110c300:	00000406 	br	8110c314 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110c304:	e0800317 	ldw	r2,12(fp)
8110c308:	e0fff517 	ldw	r3,-44(fp)
8110c30c:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110c310:	e0bffb17 	ldw	r2,-20(fp)
}
8110c314:	e037883a 	mov	sp,fp
8110c318:	dfc00117 	ldw	ra,4(sp)
8110c31c:	df000017 	ldw	fp,0(sp)
8110c320:	dec00204 	addi	sp,sp,8
8110c324:	f800283a 	ret

8110c328 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110c328:	defffc04 	addi	sp,sp,-16
8110c32c:	de00012e 	bgeu	sp,et,8110c334 <vRstcSimucamReset+0xc>
8110c330:	003b68fa 	trap	3
8110c334:	dfc00315 	stw	ra,12(sp)
8110c338:	df000215 	stw	fp,8(sp)
8110c33c:	df000204 	addi	fp,sp,8
8110c340:	2005883a 	mov	r2,r4
8110c344:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110c348:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110c34c:	e0bfff0b 	ldhu	r2,-4(fp)
8110c350:	e0fffe17 	ldw	r3,-8(fp)
8110c354:	1884b03a 	or	r2,r3,r2
8110c358:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110c35c:	e0bffe17 	ldw	r2,-8(fp)
8110c360:	10800074 	orhi	r2,r2,1
8110c364:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c368:	e1bffe17 	ldw	r6,-8(fp)
8110c36c:	000b883a 	mov	r5,zero
8110c370:	01200034 	movhi	r4,32768
8110c374:	21020004 	addi	r4,r4,2048
8110c378:	110c4780 	call	8110c478 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110c37c:	0001883a 	nop
8110c380:	e037883a 	mov	sp,fp
8110c384:	dfc00117 	ldw	ra,4(sp)
8110c388:	df000017 	ldw	fp,0(sp)
8110c38c:	dec00204 	addi	sp,sp,8
8110c390:	f800283a 	ret

8110c394 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110c394:	defffc04 	addi	sp,sp,-16
8110c398:	de00012e 	bgeu	sp,et,8110c3a0 <vRstcReleaseDeviceReset+0xc>
8110c39c:	003b68fa 	trap	3
8110c3a0:	dfc00315 	stw	ra,12(sp)
8110c3a4:	df000215 	stw	fp,8(sp)
8110c3a8:	df000204 	addi	fp,sp,8
8110c3ac:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110c3b0:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c3b4:	01400044 	movi	r5,1
8110c3b8:	01200034 	movhi	r4,32768
8110c3bc:	21020004 	addi	r4,r4,2048
8110c3c0:	110c4cc0 	call	8110c4cc <uliRstReadReg>
8110c3c4:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110c3c8:	e0bfff17 	ldw	r2,-4(fp)
8110c3cc:	0084303a 	nor	r2,zero,r2
8110c3d0:	e0fffe17 	ldw	r3,-8(fp)
8110c3d4:	1884703a 	and	r2,r3,r2
8110c3d8:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c3dc:	e1bffe17 	ldw	r6,-8(fp)
8110c3e0:	01400044 	movi	r5,1
8110c3e4:	01200034 	movhi	r4,32768
8110c3e8:	21020004 	addi	r4,r4,2048
8110c3ec:	110c4780 	call	8110c478 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110c3f0:	0001883a 	nop
8110c3f4:	e037883a 	mov	sp,fp
8110c3f8:	dfc00117 	ldw	ra,4(sp)
8110c3fc:	df000017 	ldw	fp,0(sp)
8110c400:	dec00204 	addi	sp,sp,8
8110c404:	f800283a 	ret

8110c408 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110c408:	defffc04 	addi	sp,sp,-16
8110c40c:	de00012e 	bgeu	sp,et,8110c414 <vRstcHoldDeviceReset+0xc>
8110c410:	003b68fa 	trap	3
8110c414:	dfc00315 	stw	ra,12(sp)
8110c418:	df000215 	stw	fp,8(sp)
8110c41c:	df000204 	addi	fp,sp,8
8110c420:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110c424:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c428:	01400044 	movi	r5,1
8110c42c:	01200034 	movhi	r4,32768
8110c430:	21020004 	addi	r4,r4,2048
8110c434:	110c4cc0 	call	8110c4cc <uliRstReadReg>
8110c438:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110c43c:	e0fffe17 	ldw	r3,-8(fp)
8110c440:	e0bfff17 	ldw	r2,-4(fp)
8110c444:	1884b03a 	or	r2,r3,r2
8110c448:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c44c:	e1bffe17 	ldw	r6,-8(fp)
8110c450:	01400044 	movi	r5,1
8110c454:	01200034 	movhi	r4,32768
8110c458:	21020004 	addi	r4,r4,2048
8110c45c:	110c4780 	call	8110c478 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110c460:	0001883a 	nop
8110c464:	e037883a 	mov	sp,fp
8110c468:	dfc00117 	ldw	ra,4(sp)
8110c46c:	df000017 	ldw	fp,0(sp)
8110c470:	dec00204 	addi	sp,sp,8
8110c474:	f800283a 	ret

8110c478 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110c478:	defffc04 	addi	sp,sp,-16
8110c47c:	de00012e 	bgeu	sp,et,8110c484 <vRstcWriteReg+0xc>
8110c480:	003b68fa 	trap	3
8110c484:	df000315 	stw	fp,12(sp)
8110c488:	df000304 	addi	fp,sp,12
8110c48c:	e13ffd15 	stw	r4,-12(fp)
8110c490:	e17ffe15 	stw	r5,-8(fp)
8110c494:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110c498:	e0bffe17 	ldw	r2,-8(fp)
8110c49c:	1085883a 	add	r2,r2,r2
8110c4a0:	1085883a 	add	r2,r2,r2
8110c4a4:	1007883a 	mov	r3,r2
8110c4a8:	e0bffd17 	ldw	r2,-12(fp)
8110c4ac:	10c5883a 	add	r2,r2,r3
8110c4b0:	e0ffff17 	ldw	r3,-4(fp)
8110c4b4:	10c00015 	stw	r3,0(r2)
}
8110c4b8:	0001883a 	nop
8110c4bc:	e037883a 	mov	sp,fp
8110c4c0:	df000017 	ldw	fp,0(sp)
8110c4c4:	dec00104 	addi	sp,sp,4
8110c4c8:	f800283a 	ret

8110c4cc <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110c4cc:	defffc04 	addi	sp,sp,-16
8110c4d0:	de00012e 	bgeu	sp,et,8110c4d8 <uliRstReadReg+0xc>
8110c4d4:	003b68fa 	trap	3
8110c4d8:	df000315 	stw	fp,12(sp)
8110c4dc:	df000304 	addi	fp,sp,12
8110c4e0:	e13ffe15 	stw	r4,-8(fp)
8110c4e4:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110c4e8:	e0bfff17 	ldw	r2,-4(fp)
8110c4ec:	1085883a 	add	r2,r2,r2
8110c4f0:	1085883a 	add	r2,r2,r2
8110c4f4:	1007883a 	mov	r3,r2
8110c4f8:	e0bffe17 	ldw	r2,-8(fp)
8110c4fc:	10c5883a 	add	r2,r2,r3
8110c500:	10800017 	ldw	r2,0(r2)
8110c504:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110c508:	e0bffd17 	ldw	r2,-12(fp)
}
8110c50c:	e037883a 	mov	sp,fp
8110c510:	df000017 	ldw	fp,0(sp)
8110c514:	dec00104 	addi	sp,sp,4
8110c518:	f800283a 	ret

8110c51c <v_spi_start>:

#if DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110c51c:	defffe04 	addi	sp,sp,-8
8110c520:	de00012e 	bgeu	sp,et,8110c528 <v_spi_start+0xc>
8110c524:	003b68fa 	trap	3
8110c528:	dfc00115 	stw	ra,4(sp)
8110c52c:	df000015 	stw	fp,0(sp)
8110c530:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110c534:	0007883a 	mov	r3,zero
8110c538:	00a00034 	movhi	r2,32768
8110c53c:	10823004 	addi	r2,r2,2240
8110c540:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110c544:	0007883a 	mov	r3,zero
8110c548:	00a00034 	movhi	r2,32768
8110c54c:	10822c04 	addi	r2,r2,2224
8110c550:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c554:	01002584 	movi	r4,150
8110c558:	1138fc80 	call	81138fc8 <usleep>
}
8110c55c:	0001883a 	nop
8110c560:	e037883a 	mov	sp,fp
8110c564:	dfc00117 	ldw	ra,4(sp)
8110c568:	df000017 	ldw	fp,0(sp)
8110c56c:	dec00204 	addi	sp,sp,8
8110c570:	f800283a 	ret

8110c574 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110c574:	defffc04 	addi	sp,sp,-16
8110c578:	de00012e 	bgeu	sp,et,8110c580 <v_spi_send_byte+0xc>
8110c57c:	003b68fa 	trap	3
8110c580:	dfc00315 	stw	ra,12(sp)
8110c584:	df000215 	stw	fp,8(sp)
8110c588:	df000204 	addi	fp,sp,8
8110c58c:	2005883a 	mov	r2,r4
8110c590:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110c594:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110c598:	00bfe004 	movi	r2,-128
8110c59c:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110c5a0:	e03ffe05 	stb	zero,-8(fp)
8110c5a4:	00001b06 	br	8110c614 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110c5a8:	e0ffff03 	ldbu	r3,-4(fp)
8110c5ac:	e0bffe43 	ldbu	r2,-7(fp)
8110c5b0:	1884703a 	and	r2,r3,r2
8110c5b4:	10803fcc 	andi	r2,r2,255
8110c5b8:	1004c03a 	cmpne	r2,r2,zero
8110c5bc:	10c03fcc 	andi	r3,r2,255
8110c5c0:	00a00034 	movhi	r2,32768
8110c5c4:	10823404 	addi	r2,r2,2256
8110c5c8:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110c5cc:	e0bffe43 	ldbu	r2,-7(fp)
8110c5d0:	1004d07a 	srli	r2,r2,1
8110c5d4:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c5d8:	00c00044 	movi	r3,1
8110c5dc:	00a00034 	movhi	r2,32768
8110c5e0:	10823004 	addi	r2,r2,2240
8110c5e4:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c5e8:	01002584 	movi	r4,150
8110c5ec:	1138fc80 	call	81138fc8 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c5f0:	0007883a 	mov	r3,zero
8110c5f4:	00a00034 	movhi	r2,32768
8110c5f8:	10823004 	addi	r2,r2,2240
8110c5fc:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c600:	01002584 	movi	r4,150
8110c604:	1138fc80 	call	81138fc8 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110c608:	e0bffe03 	ldbu	r2,-8(fp)
8110c60c:	10800044 	addi	r2,r2,1
8110c610:	e0bffe05 	stb	r2,-8(fp)
8110c614:	e0bffe03 	ldbu	r2,-8(fp)
8110c618:	10800230 	cmpltui	r2,r2,8
8110c61c:	103fe21e 	bne	r2,zero,8110c5a8 <__reset+0xfb0ec5a8>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110c620:	0001883a 	nop
8110c624:	e037883a 	mov	sp,fp
8110c628:	dfc00117 	ldw	ra,4(sp)
8110c62c:	df000017 	ldw	fp,0(sp)
8110c630:	dec00204 	addi	sp,sp,8
8110c634:	f800283a 	ret

8110c638 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110c638:	defffd04 	addi	sp,sp,-12
8110c63c:	de00012e 	bgeu	sp,et,8110c644 <uc_spi_get_byte+0xc>
8110c640:	003b68fa 	trap	3
8110c644:	dfc00215 	stw	ra,8(sp)
8110c648:	df000115 	stw	fp,4(sp)
8110c64c:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110c650:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110c654:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110c658:	e03fff05 	stb	zero,-4(fp)
8110c65c:	00001a06 	br	8110c6c8 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110c660:	e0bfff43 	ldbu	r2,-3(fp)
8110c664:	1085883a 	add	r2,r2,r2
8110c668:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110c66c:	00a00034 	movhi	r2,32768
8110c670:	10823804 	addi	r2,r2,2272
8110c674:	10800037 	ldwio	r2,0(r2)
8110c678:	1080004c 	andi	r2,r2,1
8110c67c:	1007883a 	mov	r3,r2
8110c680:	e0bfff43 	ldbu	r2,-3(fp)
8110c684:	1884b03a 	or	r2,r3,r2
8110c688:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c68c:	00c00044 	movi	r3,1
8110c690:	00a00034 	movhi	r2,32768
8110c694:	10823004 	addi	r2,r2,2240
8110c698:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c69c:	01002584 	movi	r4,150
8110c6a0:	1138fc80 	call	81138fc8 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c6a4:	0007883a 	mov	r3,zero
8110c6a8:	00a00034 	movhi	r2,32768
8110c6ac:	10823004 	addi	r2,r2,2240
8110c6b0:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c6b4:	01002584 	movi	r4,150
8110c6b8:	1138fc80 	call	81138fc8 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110c6bc:	e0bfff03 	ldbu	r2,-4(fp)
8110c6c0:	10800044 	addi	r2,r2,1
8110c6c4:	e0bfff05 	stb	r2,-4(fp)
8110c6c8:	e0bfff03 	ldbu	r2,-4(fp)
8110c6cc:	10800230 	cmpltui	r2,r2,8
8110c6d0:	103fe31e 	bne	r2,zero,8110c660 <__reset+0xfb0ec660>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110c6d4:	e0bfff43 	ldbu	r2,-3(fp)
}
8110c6d8:	e037883a 	mov	sp,fp
8110c6dc:	dfc00117 	ldw	ra,4(sp)
8110c6e0:	df000017 	ldw	fp,0(sp)
8110c6e4:	dec00204 	addi	sp,sp,8
8110c6e8:	f800283a 	ret

8110c6ec <v_spi_end>:

void v_spi_end(void){
8110c6ec:	defffe04 	addi	sp,sp,-8
8110c6f0:	de00012e 	bgeu	sp,et,8110c6f8 <v_spi_end+0xc>
8110c6f4:	003b68fa 	trap	3
8110c6f8:	dfc00115 	stw	ra,4(sp)
8110c6fc:	df000015 	stw	fp,0(sp)
8110c700:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110c704:	0007883a 	mov	r3,zero
8110c708:	00a00034 	movhi	r2,32768
8110c70c:	10823004 	addi	r2,r2,2240
8110c710:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c714:	01002584 	movi	r4,150
8110c718:	1138fc80 	call	81138fc8 <usleep>
    SPI_CS_N(1);
8110c71c:	00c00044 	movi	r3,1
8110c720:	00a00034 	movhi	r2,32768
8110c724:	10822c04 	addi	r2,r2,2224
8110c728:	10c00035 	stwio	r3,0(r2)
}
8110c72c:	0001883a 	nop
8110c730:	e037883a 	mov	sp,fp
8110c734:	dfc00117 	ldw	ra,4(sp)
8110c738:	df000017 	ldw	fp,0(sp)
8110c73c:	dec00204 	addi	sp,sp,8
8110c740:	f800283a 	ret

8110c744 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110c744:	defff604 	addi	sp,sp,-40
8110c748:	de00012e 	bgeu	sp,et,8110c750 <RTCC_SPI_R_MAC+0xc>
8110c74c:	003b68fa 	trap	3
8110c750:	dfc00915 	stw	ra,36(sp)
8110c754:	df000815 	stw	fp,32(sp)
8110c758:	df000804 	addi	fp,sp,32
8110c75c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c760:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110c764:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110c768:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110c76c:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110c770:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110c774:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110c778:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110c77c:	00800084 	movi	r2,2
8110c780:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110c784:	00800cc4 	movi	r2,51
8110c788:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110c78c:	110c51c0 	call	8110c51c <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110c790:	e0bffec3 	ldbu	r2,-5(fp)
8110c794:	1009883a 	mov	r4,r2
8110c798:	110c5740 	call	8110c574 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110c79c:	e0bffe83 	ldbu	r2,-6(fp)
8110c7a0:	1009883a 	mov	r4,r2
8110c7a4:	110c5740 	call	8110c574 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110c7a8:	110c6380 	call	8110c638 <uc_spi_get_byte>
8110c7ac:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110c7b0:	110c6380 	call	8110c638 <uc_spi_get_byte>
8110c7b4:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110c7b8:	110c6380 	call	8110c638 <uc_spi_get_byte>
8110c7bc:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110c7c0:	110c6380 	call	8110c638 <uc_spi_get_byte>
8110c7c4:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110c7c8:	110c6380 	call	8110c638 <uc_spi_get_byte>
8110c7cc:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110c7d0:	110c6380 	call	8110c638 <uc_spi_get_byte>
8110c7d4:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110c7d8:	110c6ec0 	call	8110c6ec <v_spi_end>

    bSuccess = TRUE;
8110c7dc:	00800044 	movi	r2,1
8110c7e0:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110c7e4:	e0bfff17 	ldw	r2,-4(fp)
8110c7e8:	e0fffd03 	ldbu	r3,-12(fp)
8110c7ec:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110c7f0:	e0bfff17 	ldw	r2,-4(fp)
8110c7f4:	10800044 	addi	r2,r2,1
8110c7f8:	e0fffd43 	ldbu	r3,-11(fp)
8110c7fc:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110c800:	e0bfff17 	ldw	r2,-4(fp)
8110c804:	10800084 	addi	r2,r2,2
8110c808:	e0fffd83 	ldbu	r3,-10(fp)
8110c80c:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110c810:	e0bfff17 	ldw	r2,-4(fp)
8110c814:	108000c4 	addi	r2,r2,3
8110c818:	e0fffdc3 	ldbu	r3,-9(fp)
8110c81c:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110c820:	e0bfff17 	ldw	r2,-4(fp)
8110c824:	10800104 	addi	r2,r2,4
8110c828:	e0fffe03 	ldbu	r3,-8(fp)
8110c82c:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110c830:	e0bfff17 	ldw	r2,-4(fp)
8110c834:	10800144 	addi	r2,r2,5
8110c838:	e0fffe43 	ldbu	r3,-7(fp)
8110c83c:	10c00005 	stb	r3,0(r2)

#if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110c840:	00a045b4 	movhi	r2,33046
8110c844:	109fe204 	addi	r2,r2,32648
8110c848:	10800d8b 	ldhu	r2,54(r2)
8110c84c:	10bfffcc 	andi	r2,r2,65535
8110c850:	108000e8 	cmpgeui	r2,r2,3
8110c854:	1000141e 	bne	r2,zero,8110c8a8 <RTCC_SPI_R_MAC+0x164>
		sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110c858:	e1bffd03 	ldbu	r6,-12(fp)
8110c85c:	e1fffd43 	ldbu	r7,-11(fp)
8110c860:	e0bffd83 	ldbu	r2,-10(fp)
8110c864:	e0fffdc3 	ldbu	r3,-9(fp)
8110c868:	e13ffe03 	ldbu	r4,-8(fp)
8110c86c:	e17ffe43 	ldbu	r5,-7(fp)
8110c870:	d9400315 	stw	r5,12(sp)
8110c874:	d9000215 	stw	r4,8(sp)
8110c878:	d8c00115 	stw	r3,4(sp)
8110c87c:	d8800015 	stw	r2,0(sp)
8110c880:	01604574 	movhi	r5,33045
8110c884:	29762904 	addi	r5,r5,-10076
8110c888:	01204574 	movhi	r4,33045
8110c88c:	2111fe04 	addi	r4,r4,18424
8110c890:	11242400 	call	81124240 <sprintf>
		debug(fp, cDebugBuffer);
8110c894:	d0a06217 	ldw	r2,-32376(gp)
8110c898:	01604574 	movhi	r5,33045
8110c89c:	2951fe04 	addi	r5,r5,18424
8110c8a0:	1009883a 	mov	r4,r2
8110c8a4:	112292c0 	call	8112292c <fprintf>
    }
#endif

    return bSuccess;
8110c8a8:	e0bffc17 	ldw	r2,-16(fp)
}
8110c8ac:	e037883a 	mov	sp,fp
8110c8b0:	dfc00117 	ldw	ra,4(sp)
8110c8b4:	df000017 	ldw	fp,0(sp)
8110c8b8:	dec00204 	addi	sp,sp,8
8110c8bc:	f800283a 	ret

8110c8c0 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110c8c0:	defffd04 	addi	sp,sp,-12
8110c8c4:	de00012e 	bgeu	sp,et,8110c8cc <bSSDisplayConfig+0xc>
8110c8c8:	003b68fa 	trap	3
8110c8cc:	df000215 	stw	fp,8(sp)
8110c8d0:	df000204 	addi	fp,sp,8
8110c8d4:	2005883a 	mov	r2,r4
8110c8d8:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110c8dc:	e0bfff03 	ldbu	r2,-4(fp)
8110c8e0:	10c00168 	cmpgeui	r3,r2,5
8110c8e4:	18001c1e 	bne	r3,zero,8110c958 <bSSDisplayConfig+0x98>
8110c8e8:	100690ba 	slli	r3,r2,2
8110c8ec:	00a04474 	movhi	r2,33041
8110c8f0:	10b24004 	addi	r2,r2,-14080
8110c8f4:	1885883a 	add	r2,r3,r2
8110c8f8:	10800017 	ldw	r2,0(r2)
8110c8fc:	1000683a 	jmp	r2
8110c900:	8110c914 	ori	r4,r16,17188
8110c904:	8110c920 	cmpeqi	r4,r16,17188
8110c908:	8110c92c 	andhi	r4,r16,17188
8110c90c:	8110c940 	call	88110c94 <__reset+0x20f0c94>
8110c910:	8110c950 	cmplti	r4,r16,17189
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110c914:	00800cc4 	movi	r2,51
8110c918:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c91c:	00001006 	br	8110c960 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110c920:	00801544 	movi	r2,85
8110c924:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c928:	00000d06 	br	8110c960 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110c92c:	d0e05043 	ldbu	r3,-32447(gp)
8110c930:	00bff744 	movi	r2,-35
8110c934:	1884703a 	and	r2,r3,r2
8110c938:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c93c:	00000806 	br	8110c960 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110c940:	d0a05043 	ldbu	r2,-32447(gp)
8110c944:	10800894 	ori	r2,r2,34
8110c948:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c94c:	00000406 	br	8110c960 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110c950:	d0205045 	stb	zero,-32447(gp)
	    break;
8110c954:	00000206 	br	8110c960 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110c958:	0005883a 	mov	r2,zero
8110c95c:	00000806 	br	8110c980 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c960:	00a00034 	movhi	r2,32768
8110c964:	10828404 	addi	r2,r2,2576
8110c968:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110c96c:	d0a05043 	ldbu	r2,-32447(gp)
8110c970:	10c03fcc 	andi	r3,r2,255
8110c974:	e0bffe17 	ldw	r2,-8(fp)
8110c978:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c97c:	00800044 	movi	r2,1
}
8110c980:	e037883a 	mov	sp,fp
8110c984:	df000017 	ldw	fp,0(sp)
8110c988:	dec00104 	addi	sp,sp,4
8110c98c:	f800283a 	ret

8110c990 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110c990:	defffd04 	addi	sp,sp,-12
8110c994:	de00012e 	bgeu	sp,et,8110c99c <bSSDisplayUpdate+0xc>
8110c998:	003b68fa 	trap	3
8110c99c:	df000215 	stw	fp,8(sp)
8110c9a0:	df000204 	addi	fp,sp,8
8110c9a4:	2005883a 	mov	r2,r4
8110c9a8:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c9ac:	00a00034 	movhi	r2,32768
8110c9b0:	10828404 	addi	r2,r2,2576
8110c9b4:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110c9b8:	e0bffe17 	ldw	r2,-8(fp)
8110c9bc:	10800104 	addi	r2,r2,4
8110c9c0:	e0ffff03 	ldbu	r3,-4(fp)
8110c9c4:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c9c8:	00800044 	movi	r2,1
}
8110c9cc:	e037883a 	mov	sp,fp
8110c9d0:	df000017 	ldw	fp,0(sp)
8110c9d4:	dec00104 	addi	sp,sp,4
8110c9d8:	f800283a 	ret

8110c9dc <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110c9dc:	defffb04 	addi	sp,sp,-20
8110c9e0:	de00012e 	bgeu	sp,et,8110c9e8 <vSyncHandleIrq+0xc>
8110c9e4:	003b68fa 	trap	3
8110c9e8:	dfc00415 	stw	ra,16(sp)
8110c9ec:	df000315 	stw	fp,12(sp)
8110c9f0:	df000304 	addi	fp,sp,12
8110c9f4:	e13fff15 	stw	r4,-4(fp)
	tQMask uiCmdtoSend;

	//volatile int* pviHoldContext = (volatile int*) pvContext;


	uiCmdtoSend.ulWord = 0;
8110c9f8:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110c9fc:	d0a05203 	ldbu	r2,-32440(gp)
8110ca00:	108000cc 	andi	r2,r2,3
8110ca04:	e0bffd45 	stb	r2,-11(fp)
	if ( ucSyncL == 0 )
8110ca08:	e0bffd43 	ldbu	r2,-11(fp)
8110ca0c:	1000031e 	bne	r2,zero,8110ca1c <vSyncHandleIrq+0x40>
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110ca10:	00bff804 	movi	r2,-32
8110ca14:	e0bffe85 	stb	r2,-6(fp)
8110ca18:	00000206 	br	8110ca24 <vSyncHandleIrq+0x48>
	else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110ca1c:	00bff844 	movi	r2,-31
8110ca20:	e0bffe85 	stb	r2,-6(fp)

	uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110ca24:	00800044 	movi	r2,1
8110ca28:	e0bffec5 	stb	r2,-5(fp)

	/* Send Priority message to the Meb Task to indicate the Master Sync */
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110ca2c:	d0a06917 	ldw	r2,-32348(gp)
8110ca30:	e0fffe17 	ldw	r3,-8(fp)
8110ca34:	180b883a 	mov	r5,r3
8110ca38:	1009883a 	mov	r4,r2
8110ca3c:	113f44c0 	call	8113f44c <OSQPostFront>
8110ca40:	e0bffd85 	stb	r2,-10(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110ca44:	e0bffd83 	ldbu	r2,-10(fp)
8110ca48:	10000126 	beq	r2,zero,8110ca50 <vSyncHandleIrq+0x74>
		vFailSendMsgMasterSyncMeb( );
8110ca4c:	111e8f00 	call	8111e8f0 <vFailSendMsgMasterSyncMeb>
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110ca50:	e03ffd05 	stb	zero,-12(fp)
8110ca54:	00001606 	br	8110cab0 <vSyncHandleIrq+0xd4>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110ca58:	e0bffd03 	ldbu	r2,-12(fp)
8110ca5c:	10800444 	addi	r2,r2,17
8110ca60:	e0bffec5 	stb	r2,-5(fp)
		error_codel = OSQPostFront(xFeeQ[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110ca64:	e0bffd03 	ldbu	r2,-12(fp)
8110ca68:	1085883a 	add	r2,r2,r2
8110ca6c:	1087883a 	add	r3,r2,r2
8110ca70:	d0a06a04 	addi	r2,gp,-32344
8110ca74:	1885883a 	add	r2,r3,r2
8110ca78:	10800017 	ldw	r2,0(r2)
8110ca7c:	e0fffe17 	ldw	r3,-8(fp)
8110ca80:	180b883a 	mov	r5,r3
8110ca84:	1009883a 	mov	r4,r2
8110ca88:	113f44c0 	call	8113f44c <OSQPostFront>
8110ca8c:	e0bffd85 	stb	r2,-10(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110ca90:	e0bffd83 	ldbu	r2,-10(fp)
8110ca94:	10000326 	beq	r2,zero,8110caa4 <vSyncHandleIrq+0xc8>
			vFailSendMsgSync( ucIL );
8110ca98:	e0bffd03 	ldbu	r2,-12(fp)
8110ca9c:	1009883a 	mov	r4,r2
8110caa0:	111e8180 	call	8111e818 <vFailSendMsgSync>
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
	if ( error_codel != OS_ERR_NONE ) {
		vFailSendMsgMasterSyncMeb( );
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110caa4:	e0bffd03 	ldbu	r2,-12(fp)
8110caa8:	10800044 	addi	r2,r2,1
8110caac:	e0bffd05 	stb	r2,-12(fp)
8110cab0:	e0bffd03 	ldbu	r2,-12(fp)
8110cab4:	103fe826 	beq	r2,zero,8110ca58 <__reset+0xfb0eca58>
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}

	vucN += 1;
8110cab8:	d0a05203 	ldbu	r2,-32440(gp)
8110cabc:	10800044 	addi	r2,r2,1
8110cac0:	d0a05205 	stb	r2,-32440(gp)

	vSyncIrqFlagClrSync();
8110cac4:	110cb580 	call	8110cb58 <vSyncIrqFlagClrSync>
}
8110cac8:	0001883a 	nop
8110cacc:	e037883a 	mov	sp,fp
8110cad0:	dfc00117 	ldw	ra,4(sp)
8110cad4:	df000017 	ldw	fp,0(sp)
8110cad8:	dec00204 	addi	sp,sp,8
8110cadc:	f800283a 	ret

8110cae0 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110cae0:	deffff04 	addi	sp,sp,-4
8110cae4:	de00012e 	bgeu	sp,et,8110caec <vSyncClearCounter+0xc>
8110cae8:	003b68fa 	trap	3
8110caec:	df000015 	stw	fp,0(sp)
8110caf0:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110caf4:	d0205205 	stb	zero,-32440(gp)
}
8110caf8:	0001883a 	nop
8110cafc:	e037883a 	mov	sp,fp
8110cb00:	df000017 	ldw	fp,0(sp)
8110cb04:	dec00104 	addi	sp,sp,4
8110cb08:	f800283a 	ret

8110cb0c <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110cb0c:	defffd04 	addi	sp,sp,-12
8110cb10:	de00012e 	bgeu	sp,et,8110cb18 <vSyncInitIrq+0xc>
8110cb14:	003b68fa 	trap	3
8110cb18:	dfc00215 	stw	ra,8(sp)
8110cb1c:	df000115 	stw	fp,4(sp)
8110cb20:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110cb24:	d0a05104 	addi	r2,gp,-32444
8110cb28:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110cb2c:	01a04474 	movhi	r6,33041
8110cb30:	31b27704 	addi	r6,r6,-13860
8110cb34:	e17fff17 	ldw	r5,-4(fp)
8110cb38:	01000284 	movi	r4,10
8110cb3c:	11378f80 	call	811378f8 <alt_irq_register>
}
8110cb40:	0001883a 	nop
8110cb44:	e037883a 	mov	sp,fp
8110cb48:	dfc00117 	ldw	ra,4(sp)
8110cb4c:	df000017 	ldw	fp,0(sp)
8110cb50:	dec00204 	addi	sp,sp,8
8110cb54:	f800283a 	ret

8110cb58 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110cb58:	defffe04 	addi	sp,sp,-8
8110cb5c:	de00012e 	bgeu	sp,et,8110cb64 <vSyncIrqFlagClrSync+0xc>
8110cb60:	003b68fa 	trap	3
8110cb64:	dfc00115 	stw	ra,4(sp)
8110cb68:	df000015 	stw	fp,0(sp)
8110cb6c:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110cb70:	01400044 	movi	r5,1
8110cb74:	010002c4 	movi	r4,11
8110cb78:	110d9380 	call	8110d938 <bSyncWriteReg>
}
8110cb7c:	0001883a 	nop
8110cb80:	e037883a 	mov	sp,fp
8110cb84:	dfc00117 	ldw	ra,4(sp)
8110cb88:	df000017 	ldw	fp,0(sp)
8110cb8c:	dec00204 	addi	sp,sp,8
8110cb90:	f800283a 	ret

8110cb94 <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110cb94:	defffd04 	addi	sp,sp,-12
8110cb98:	de00012e 	bgeu	sp,et,8110cba0 <bSyncIrqFlagSync+0xc>
8110cb9c:	003b68fa 	trap	3
8110cba0:	dfc00215 	stw	ra,8(sp)
8110cba4:	df000115 	stw	fp,4(sp)
8110cba8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110cbac:	01000304 	movi	r4,12
8110cbb0:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cbb4:	1080004c 	andi	r2,r2,1
8110cbb8:	10000326 	beq	r2,zero,8110cbc8 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110cbbc:	00800044 	movi	r2,1
8110cbc0:	e0bfff15 	stw	r2,-4(fp)
8110cbc4:	00000106 	br	8110cbcc <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110cbc8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110cbcc:	e0bfff17 	ldw	r2,-4(fp)
}
8110cbd0:	e037883a 	mov	sp,fp
8110cbd4:	dfc00117 	ldw	ra,4(sp)
8110cbd8:	df000017 	ldw	fp,0(sp)
8110cbdc:	dec00204 	addi	sp,sp,8
8110cbe0:	f800283a 	ret

8110cbe4 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110cbe4:	defffc04 	addi	sp,sp,-16
8110cbe8:	de00012e 	bgeu	sp,et,8110cbf0 <bSyncStatusExtnIrq+0xc>
8110cbec:	003b68fa 	trap	3
8110cbf0:	dfc00315 	stw	ra,12(sp)
8110cbf4:	df000215 	stw	fp,8(sp)
8110cbf8:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cbfc:	0009883a 	mov	r4,zero
8110cc00:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cc04:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110cc08:	e0bfff17 	ldw	r2,-4(fp)
8110cc0c:	1000030e 	bge	r2,zero,8110cc1c <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110cc10:	00800044 	movi	r2,1
8110cc14:	e0bffe15 	stw	r2,-8(fp)
8110cc18:	00000106 	br	8110cc20 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110cc1c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110cc20:	e0bffe17 	ldw	r2,-8(fp)
}
8110cc24:	e037883a 	mov	sp,fp
8110cc28:	dfc00117 	ldw	ra,4(sp)
8110cc2c:	df000017 	ldw	fp,0(sp)
8110cc30:	dec00204 	addi	sp,sp,8
8110cc34:	f800283a 	ret

8110cc38 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110cc38:	defffc04 	addi	sp,sp,-16
8110cc3c:	de00012e 	bgeu	sp,et,8110cc44 <ucSyncStatusState+0xc>
8110cc40:	003b68fa 	trap	3
8110cc44:	dfc00315 	stw	ra,12(sp)
8110cc48:	df000215 	stw	fp,8(sp)
8110cc4c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cc50:	0009883a 	mov	r4,zero
8110cc54:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cc58:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110cc5c:	e0bffe17 	ldw	r2,-8(fp)
8110cc60:	10803fec 	andhi	r2,r2,255
8110cc64:	1004d43a 	srli	r2,r2,16
8110cc68:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110cc6c:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cc70:	e037883a 	mov	sp,fp
8110cc74:	dfc00117 	ldw	ra,4(sp)
8110cc78:	df000017 	ldw	fp,0(sp)
8110cc7c:	dec00204 	addi	sp,sp,8
8110cc80:	f800283a 	ret

8110cc84 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110cc84:	defffc04 	addi	sp,sp,-16
8110cc88:	de00012e 	bgeu	sp,et,8110cc90 <ucSyncStatusErrorCode+0xc>
8110cc8c:	003b68fa 	trap	3
8110cc90:	dfc00315 	stw	ra,12(sp)
8110cc94:	df000215 	stw	fp,8(sp)
8110cc98:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cc9c:	0009883a 	mov	r4,zero
8110cca0:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cca4:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110cca8:	e0bffe17 	ldw	r2,-8(fp)
8110ccac:	10bfc00c 	andi	r2,r2,65280
8110ccb0:	1004d23a 	srli	r2,r2,8
8110ccb4:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110ccb8:	e0bfff03 	ldbu	r2,-4(fp)
}
8110ccbc:	e037883a 	mov	sp,fp
8110ccc0:	dfc00117 	ldw	ra,4(sp)
8110ccc4:	df000017 	ldw	fp,0(sp)
8110ccc8:	dec00204 	addi	sp,sp,8
8110cccc:	f800283a 	ret

8110ccd0 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110ccd0:	defffc04 	addi	sp,sp,-16
8110ccd4:	de00012e 	bgeu	sp,et,8110ccdc <ucSyncStatusCycleNumber+0xc>
8110ccd8:	003b68fa 	trap	3
8110ccdc:	dfc00315 	stw	ra,12(sp)
8110cce0:	df000215 	stw	fp,8(sp)
8110cce4:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cce8:	0009883a 	mov	r4,zero
8110ccec:	110d9940 	call	8110d994 <uliSyncReadReg>
8110ccf0:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110ccf4:	e0bffe17 	ldw	r2,-8(fp)
8110ccf8:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110ccfc:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cd00:	e037883a 	mov	sp,fp
8110cd04:	dfc00117 	ldw	ra,4(sp)
8110cd08:	df000017 	ldw	fp,0(sp)
8110cd0c:	dec00204 	addi	sp,sp,8
8110cd10:	f800283a 	ret

8110cd14 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110cd14:	defffd04 	addi	sp,sp,-12
8110cd18:	de00012e 	bgeu	sp,et,8110cd20 <bSyncSetMbt+0xc>
8110cd1c:	003b68fa 	trap	3
8110cd20:	dfc00215 	stw	ra,8(sp)
8110cd24:	df000115 	stw	fp,4(sp)
8110cd28:	df000104 	addi	fp,sp,4
8110cd2c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110cd30:	e17fff17 	ldw	r5,-4(fp)
8110cd34:	01000104 	movi	r4,4
8110cd38:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110cd3c:	00800044 	movi	r2,1
}
8110cd40:	e037883a 	mov	sp,fp
8110cd44:	dfc00117 	ldw	ra,4(sp)
8110cd48:	df000017 	ldw	fp,0(sp)
8110cd4c:	dec00204 	addi	sp,sp,8
8110cd50:	f800283a 	ret

8110cd54 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110cd54:	defffd04 	addi	sp,sp,-12
8110cd58:	de00012e 	bgeu	sp,et,8110cd60 <bSyncSetBt+0xc>
8110cd5c:	003b68fa 	trap	3
8110cd60:	dfc00215 	stw	ra,8(sp)
8110cd64:	df000115 	stw	fp,4(sp)
8110cd68:	df000104 	addi	fp,sp,4
8110cd6c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110cd70:	e17fff17 	ldw	r5,-4(fp)
8110cd74:	01000144 	movi	r4,5
8110cd78:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110cd7c:	00800044 	movi	r2,1
}
8110cd80:	e037883a 	mov	sp,fp
8110cd84:	dfc00117 	ldw	ra,4(sp)
8110cd88:	df000017 	ldw	fp,0(sp)
8110cd8c:	dec00204 	addi	sp,sp,8
8110cd90:	f800283a 	ret

8110cd94 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110cd94:	defffd04 	addi	sp,sp,-12
8110cd98:	de00012e 	bgeu	sp,et,8110cda0 <bSyncSetPer+0xc>
8110cd9c:	003b68fa 	trap	3
8110cda0:	dfc00215 	stw	ra,8(sp)
8110cda4:	df000115 	stw	fp,4(sp)
8110cda8:	df000104 	addi	fp,sp,4
8110cdac:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110cdb0:	e17fff17 	ldw	r5,-4(fp)
8110cdb4:	01000184 	movi	r4,6
8110cdb8:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110cdbc:	00800044 	movi	r2,1
}
8110cdc0:	e037883a 	mov	sp,fp
8110cdc4:	dfc00117 	ldw	ra,4(sp)
8110cdc8:	df000017 	ldw	fp,0(sp)
8110cdcc:	dec00204 	addi	sp,sp,8
8110cdd0:	f800283a 	ret

8110cdd4 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110cdd4:	defffd04 	addi	sp,sp,-12
8110cdd8:	de00012e 	bgeu	sp,et,8110cde0 <bSyncSetOst+0xc>
8110cddc:	003b68fa 	trap	3
8110cde0:	dfc00215 	stw	ra,8(sp)
8110cde4:	df000115 	stw	fp,4(sp)
8110cde8:	df000104 	addi	fp,sp,4
8110cdec:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110cdf0:	e17fff17 	ldw	r5,-4(fp)
8110cdf4:	010001c4 	movi	r4,7
8110cdf8:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110cdfc:	00800044 	movi	r2,1
}
8110ce00:	e037883a 	mov	sp,fp
8110ce04:	dfc00117 	ldw	ra,4(sp)
8110ce08:	df000017 	ldw	fp,0(sp)
8110ce0c:	dec00204 	addi	sp,sp,8
8110ce10:	f800283a 	ret

8110ce14 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110ce14:	defffc04 	addi	sp,sp,-16
8110ce18:	de00012e 	bgeu	sp,et,8110ce20 <bSyncSetPolarity+0xc>
8110ce1c:	003b68fa 	trap	3
8110ce20:	dfc00315 	stw	ra,12(sp)
8110ce24:	df000215 	stw	fp,8(sp)
8110ce28:	df000204 	addi	fp,sp,8
8110ce2c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110ce30:	01000204 	movi	r4,8
8110ce34:	110d9940 	call	8110d994 <uliSyncReadReg>
8110ce38:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ce3c:	e0bfff17 	ldw	r2,-4(fp)
8110ce40:	1000051e 	bne	r2,zero,8110ce58 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110ce44:	e0fffe17 	ldw	r3,-8(fp)
8110ce48:	00bfbfc4 	movi	r2,-257
8110ce4c:	1884703a 	and	r2,r3,r2
8110ce50:	e0bffe15 	stw	r2,-8(fp)
8110ce54:	00000306 	br	8110ce64 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110ce58:	e0bffe17 	ldw	r2,-8(fp)
8110ce5c:	10804014 	ori	r2,r2,256
8110ce60:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110ce64:	e17ffe17 	ldw	r5,-8(fp)
8110ce68:	01000204 	movi	r4,8
8110ce6c:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110ce70:	00800044 	movi	r2,1
}
8110ce74:	e037883a 	mov	sp,fp
8110ce78:	dfc00117 	ldw	ra,4(sp)
8110ce7c:	df000017 	ldw	fp,0(sp)
8110ce80:	dec00204 	addi	sp,sp,8
8110ce84:	f800283a 	ret

8110ce88 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110ce88:	defffc04 	addi	sp,sp,-16
8110ce8c:	de00012e 	bgeu	sp,et,8110ce94 <bSyncSetNCycles+0xc>
8110ce90:	003b68fa 	trap	3
8110ce94:	dfc00315 	stw	ra,12(sp)
8110ce98:	df000215 	stw	fp,8(sp)
8110ce9c:	df000204 	addi	fp,sp,8
8110cea0:	2005883a 	mov	r2,r4
8110cea4:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110cea8:	01000204 	movi	r4,8
8110ceac:	110d9940 	call	8110d994 <uliSyncReadReg>
8110ceb0:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110ceb4:	e0fffe17 	ldw	r3,-8(fp)
8110ceb8:	00bfc004 	movi	r2,-256
8110cebc:	1884703a 	and	r2,r3,r2
8110cec0:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110cec4:	e0bfff03 	ldbu	r2,-4(fp)
8110cec8:	e0fffe17 	ldw	r3,-8(fp)
8110cecc:	1884b03a 	or	r2,r3,r2
8110ced0:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110ced4:	e17ffe17 	ldw	r5,-8(fp)
8110ced8:	01000204 	movi	r4,8
8110cedc:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110cee0:	00800044 	movi	r2,1
}
8110cee4:	e037883a 	mov	sp,fp
8110cee8:	dfc00117 	ldw	ra,4(sp)
8110ceec:	df000017 	ldw	fp,0(sp)
8110cef0:	dec00204 	addi	sp,sp,8
8110cef4:	f800283a 	ret

8110cef8 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110cef8:	defffd04 	addi	sp,sp,-12
8110cefc:	de00012e 	bgeu	sp,et,8110cf04 <uliSyncGetMbt+0xc>
8110cf00:	003b68fa 	trap	3
8110cf04:	dfc00215 	stw	ra,8(sp)
8110cf08:	df000115 	stw	fp,4(sp)
8110cf0c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110cf10:	01000104 	movi	r4,4
8110cf14:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cf18:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cf1c:	e0bfff17 	ldw	r2,-4(fp)
}
8110cf20:	e037883a 	mov	sp,fp
8110cf24:	dfc00117 	ldw	ra,4(sp)
8110cf28:	df000017 	ldw	fp,0(sp)
8110cf2c:	dec00204 	addi	sp,sp,8
8110cf30:	f800283a 	ret

8110cf34 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110cf34:	defffd04 	addi	sp,sp,-12
8110cf38:	de00012e 	bgeu	sp,et,8110cf40 <uliSyncGetBt+0xc>
8110cf3c:	003b68fa 	trap	3
8110cf40:	dfc00215 	stw	ra,8(sp)
8110cf44:	df000115 	stw	fp,4(sp)
8110cf48:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110cf4c:	01000144 	movi	r4,5
8110cf50:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cf54:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cf58:	e0bfff17 	ldw	r2,-4(fp)
}
8110cf5c:	e037883a 	mov	sp,fp
8110cf60:	dfc00117 	ldw	ra,4(sp)
8110cf64:	df000017 	ldw	fp,0(sp)
8110cf68:	dec00204 	addi	sp,sp,8
8110cf6c:	f800283a 	ret

8110cf70 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110cf70:	defffd04 	addi	sp,sp,-12
8110cf74:	de00012e 	bgeu	sp,et,8110cf7c <uliSyncGetPer+0xc>
8110cf78:	003b68fa 	trap	3
8110cf7c:	dfc00215 	stw	ra,8(sp)
8110cf80:	df000115 	stw	fp,4(sp)
8110cf84:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110cf88:	01000184 	movi	r4,6
8110cf8c:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cf90:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cf94:	e0bfff17 	ldw	r2,-4(fp)
}
8110cf98:	e037883a 	mov	sp,fp
8110cf9c:	dfc00117 	ldw	ra,4(sp)
8110cfa0:	df000017 	ldw	fp,0(sp)
8110cfa4:	dec00204 	addi	sp,sp,8
8110cfa8:	f800283a 	ret

8110cfac <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110cfac:	defffd04 	addi	sp,sp,-12
8110cfb0:	de00012e 	bgeu	sp,et,8110cfb8 <uliSyncGetOst+0xc>
8110cfb4:	003b68fa 	trap	3
8110cfb8:	dfc00215 	stw	ra,8(sp)
8110cfbc:	df000115 	stw	fp,4(sp)
8110cfc0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110cfc4:	010001c4 	movi	r4,7
8110cfc8:	110d9940 	call	8110d994 <uliSyncReadReg>
8110cfcc:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cfd0:	e0bfff17 	ldw	r2,-4(fp)
}
8110cfd4:	e037883a 	mov	sp,fp
8110cfd8:	dfc00117 	ldw	ra,4(sp)
8110cfdc:	df000017 	ldw	fp,0(sp)
8110cfe0:	dec00204 	addi	sp,sp,8
8110cfe4:	f800283a 	ret

8110cfe8 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110cfe8:	defffd04 	addi	sp,sp,-12
8110cfec:	de00012e 	bgeu	sp,et,8110cff4 <uliSyncGetGeneral+0xc>
8110cff0:	003b68fa 	trap	3
8110cff4:	dfc00215 	stw	ra,8(sp)
8110cff8:	df000115 	stw	fp,4(sp)
8110cffc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110d000:	01000204 	movi	r4,8
8110d004:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d008:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d00c:	e0bfff17 	ldw	r2,-4(fp)
}
8110d010:	e037883a 	mov	sp,fp
8110d014:	dfc00117 	ldw	ra,4(sp)
8110d018:	df000017 	ldw	fp,0(sp)
8110d01c:	dec00204 	addi	sp,sp,8
8110d020:	f800283a 	ret

8110d024 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110d024:	defffd04 	addi	sp,sp,-12
8110d028:	de00012e 	bgeu	sp,et,8110d030 <bSyncErrInj+0xc>
8110d02c:	003b68fa 	trap	3
8110d030:	dfc00215 	stw	ra,8(sp)
8110d034:	df000115 	stw	fp,4(sp)
8110d038:	df000104 	addi	fp,sp,4
8110d03c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110d040:	e17fff17 	ldw	r5,-4(fp)
8110d044:	01000244 	movi	r4,9
8110d048:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d04c:	00800044 	movi	r2,1
}
8110d050:	e037883a 	mov	sp,fp
8110d054:	dfc00117 	ldw	ra,4(sp)
8110d058:	df000017 	ldw	fp,0(sp)
8110d05c:	dec00204 	addi	sp,sp,8
8110d060:	f800283a 	ret

8110d064 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110d064:	defffc04 	addi	sp,sp,-16
8110d068:	de00012e 	bgeu	sp,et,8110d070 <bSyncCtrExtnIrq+0xc>
8110d06c:	003b68fa 	trap	3
8110d070:	dfc00315 	stw	ra,12(sp)
8110d074:	df000215 	stw	fp,8(sp)
8110d078:	df000204 	addi	fp,sp,8
8110d07c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d080:	01000284 	movi	r4,10
8110d084:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d088:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d08c:	e0bfff17 	ldw	r2,-4(fp)
8110d090:	1000061e 	bne	r2,zero,8110d0ac <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110d094:	e0fffe17 	ldw	r3,-8(fp)
8110d098:	00a00034 	movhi	r2,32768
8110d09c:	10bfffc4 	addi	r2,r2,-1
8110d0a0:	1884703a 	and	r2,r3,r2
8110d0a4:	e0bffe15 	stw	r2,-8(fp)
8110d0a8:	00000306 	br	8110d0b8 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110d0ac:	e0bffe17 	ldw	r2,-8(fp)
8110d0b0:	10a00034 	orhi	r2,r2,32768
8110d0b4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d0b8:	e17ffe17 	ldw	r5,-8(fp)
8110d0bc:	01000284 	movi	r4,10
8110d0c0:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d0c4:	00800044 	movi	r2,1
}
8110d0c8:	e037883a 	mov	sp,fp
8110d0cc:	dfc00117 	ldw	ra,4(sp)
8110d0d0:	df000017 	ldw	fp,0(sp)
8110d0d4:	dec00204 	addi	sp,sp,8
8110d0d8:	f800283a 	ret

8110d0dc <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110d0dc:	defffd04 	addi	sp,sp,-12
8110d0e0:	de00012e 	bgeu	sp,et,8110d0e8 <bSyncCtrStart+0xc>
8110d0e4:	003b68fa 	trap	3
8110d0e8:	dfc00215 	stw	ra,8(sp)
8110d0ec:	df000115 	stw	fp,4(sp)
8110d0f0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d0f4:	01000284 	movi	r4,10
8110d0f8:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d0fc:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110d100:	e0bfff17 	ldw	r2,-4(fp)
8110d104:	10800234 	orhi	r2,r2,8
8110d108:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d10c:	e17fff17 	ldw	r5,-4(fp)
8110d110:	01000284 	movi	r4,10
8110d114:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d118:	00800044 	movi	r2,1
}
8110d11c:	e037883a 	mov	sp,fp
8110d120:	dfc00117 	ldw	ra,4(sp)
8110d124:	df000017 	ldw	fp,0(sp)
8110d128:	dec00204 	addi	sp,sp,8
8110d12c:	f800283a 	ret

8110d130 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110d130:	defffd04 	addi	sp,sp,-12
8110d134:	de00012e 	bgeu	sp,et,8110d13c <bSyncCtrReset+0xc>
8110d138:	003b68fa 	trap	3
8110d13c:	dfc00215 	stw	ra,8(sp)
8110d140:	df000115 	stw	fp,4(sp)
8110d144:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d148:	01000284 	movi	r4,10
8110d14c:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d150:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110d154:	e0bfff17 	ldw	r2,-4(fp)
8110d158:	10800134 	orhi	r2,r2,4
8110d15c:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d160:	e17fff17 	ldw	r5,-4(fp)
8110d164:	01000284 	movi	r4,10
8110d168:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d16c:	00800044 	movi	r2,1
}
8110d170:	e037883a 	mov	sp,fp
8110d174:	dfc00117 	ldw	ra,4(sp)
8110d178:	df000017 	ldw	fp,0(sp)
8110d17c:	dec00204 	addi	sp,sp,8
8110d180:	f800283a 	ret

8110d184 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110d184:	defffd04 	addi	sp,sp,-12
8110d188:	de00012e 	bgeu	sp,et,8110d190 <bSyncCtrOneShot+0xc>
8110d18c:	003b68fa 	trap	3
8110d190:	dfc00215 	stw	ra,8(sp)
8110d194:	df000115 	stw	fp,4(sp)
8110d198:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d19c:	01000284 	movi	r4,10
8110d1a0:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d1a4:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110d1a8:	e0bfff17 	ldw	r2,-4(fp)
8110d1ac:	108000b4 	orhi	r2,r2,2
8110d1b0:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d1b4:	e17fff17 	ldw	r5,-4(fp)
8110d1b8:	01000284 	movi	r4,10
8110d1bc:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d1c0:	00800044 	movi	r2,1
}
8110d1c4:	e037883a 	mov	sp,fp
8110d1c8:	dfc00117 	ldw	ra,4(sp)
8110d1cc:	df000017 	ldw	fp,0(sp)
8110d1d0:	dec00204 	addi	sp,sp,8
8110d1d4:	f800283a 	ret

8110d1d8 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110d1d8:	defffd04 	addi	sp,sp,-12
8110d1dc:	de00012e 	bgeu	sp,et,8110d1e4 <bSyncCtrErrInj+0xc>
8110d1e0:	003b68fa 	trap	3
8110d1e4:	dfc00215 	stw	ra,8(sp)
8110d1e8:	df000115 	stw	fp,4(sp)
8110d1ec:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d1f0:	01000284 	movi	r4,10
8110d1f4:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d1f8:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110d1fc:	e0bfff17 	ldw	r2,-4(fp)
8110d200:	10800074 	orhi	r2,r2,1
8110d204:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d208:	e17fff17 	ldw	r5,-4(fp)
8110d20c:	01000284 	movi	r4,10
8110d210:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d214:	00800044 	movi	r2,1
}
8110d218:	e037883a 	mov	sp,fp
8110d21c:	dfc00117 	ldw	ra,4(sp)
8110d220:	df000017 	ldw	fp,0(sp)
8110d224:	dec00204 	addi	sp,sp,8
8110d228:	f800283a 	ret

8110d22c <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110d22c:	defffc04 	addi	sp,sp,-16
8110d230:	de00012e 	bgeu	sp,et,8110d238 <bSyncCtrSyncOutEnable+0xc>
8110d234:	003b68fa 	trap	3
8110d238:	dfc00315 	stw	ra,12(sp)
8110d23c:	df000215 	stw	fp,8(sp)
8110d240:	df000204 	addi	fp,sp,8
8110d244:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d248:	01000284 	movi	r4,10
8110d24c:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d250:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d254:	e0bfff17 	ldw	r2,-4(fp)
8110d258:	1000051e 	bne	r2,zero,8110d270 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110d25c:	e0fffe17 	ldw	r3,-8(fp)
8110d260:	00bfbfc4 	movi	r2,-257
8110d264:	1884703a 	and	r2,r3,r2
8110d268:	e0bffe15 	stw	r2,-8(fp)
8110d26c:	00000306 	br	8110d27c <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110d270:	e0bffe17 	ldw	r2,-8(fp)
8110d274:	10804014 	ori	r2,r2,256
8110d278:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d27c:	e17ffe17 	ldw	r5,-8(fp)
8110d280:	01000284 	movi	r4,10
8110d284:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d288:	00800044 	movi	r2,1
}
8110d28c:	e037883a 	mov	sp,fp
8110d290:	dfc00117 	ldw	ra,4(sp)
8110d294:	df000017 	ldw	fp,0(sp)
8110d298:	dec00204 	addi	sp,sp,8
8110d29c:	f800283a 	ret

8110d2a0 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110d2a0:	defffc04 	addi	sp,sp,-16
8110d2a4:	de00012e 	bgeu	sp,et,8110d2ac <bSyncCtrCh1OutEnable+0xc>
8110d2a8:	003b68fa 	trap	3
8110d2ac:	dfc00315 	stw	ra,12(sp)
8110d2b0:	df000215 	stw	fp,8(sp)
8110d2b4:	df000204 	addi	fp,sp,8
8110d2b8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d2bc:	01000284 	movi	r4,10
8110d2c0:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d2c4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d2c8:	e0bfff17 	ldw	r2,-4(fp)
8110d2cc:	1000051e 	bne	r2,zero,8110d2e4 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110d2d0:	e0fffe17 	ldw	r3,-8(fp)
8110d2d4:	00bfff84 	movi	r2,-2
8110d2d8:	1884703a 	and	r2,r3,r2
8110d2dc:	e0bffe15 	stw	r2,-8(fp)
8110d2e0:	00000306 	br	8110d2f0 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110d2e4:	e0bffe17 	ldw	r2,-8(fp)
8110d2e8:	10800054 	ori	r2,r2,1
8110d2ec:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d2f0:	e17ffe17 	ldw	r5,-8(fp)
8110d2f4:	01000284 	movi	r4,10
8110d2f8:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d2fc:	00800044 	movi	r2,1
}
8110d300:	e037883a 	mov	sp,fp
8110d304:	dfc00117 	ldw	ra,4(sp)
8110d308:	df000017 	ldw	fp,0(sp)
8110d30c:	dec00204 	addi	sp,sp,8
8110d310:	f800283a 	ret

8110d314 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110d314:	defffc04 	addi	sp,sp,-16
8110d318:	de00012e 	bgeu	sp,et,8110d320 <bSyncCtrCh2OutEnable+0xc>
8110d31c:	003b68fa 	trap	3
8110d320:	dfc00315 	stw	ra,12(sp)
8110d324:	df000215 	stw	fp,8(sp)
8110d328:	df000204 	addi	fp,sp,8
8110d32c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d330:	01000284 	movi	r4,10
8110d334:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d338:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d33c:	e0bfff17 	ldw	r2,-4(fp)
8110d340:	1000051e 	bne	r2,zero,8110d358 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110d344:	e0fffe17 	ldw	r3,-8(fp)
8110d348:	00bfff44 	movi	r2,-3
8110d34c:	1884703a 	and	r2,r3,r2
8110d350:	e0bffe15 	stw	r2,-8(fp)
8110d354:	00000306 	br	8110d364 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110d358:	e0bffe17 	ldw	r2,-8(fp)
8110d35c:	10800094 	ori	r2,r2,2
8110d360:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d364:	e17ffe17 	ldw	r5,-8(fp)
8110d368:	01000284 	movi	r4,10
8110d36c:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d370:	00800044 	movi	r2,1
}
8110d374:	e037883a 	mov	sp,fp
8110d378:	dfc00117 	ldw	ra,4(sp)
8110d37c:	df000017 	ldw	fp,0(sp)
8110d380:	dec00204 	addi	sp,sp,8
8110d384:	f800283a 	ret

8110d388 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110d388:	defffc04 	addi	sp,sp,-16
8110d38c:	de00012e 	bgeu	sp,et,8110d394 <bSyncCtrCh3OutEnable+0xc>
8110d390:	003b68fa 	trap	3
8110d394:	dfc00315 	stw	ra,12(sp)
8110d398:	df000215 	stw	fp,8(sp)
8110d39c:	df000204 	addi	fp,sp,8
8110d3a0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d3a4:	01000284 	movi	r4,10
8110d3a8:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d3ac:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d3b0:	e0bfff17 	ldw	r2,-4(fp)
8110d3b4:	1000051e 	bne	r2,zero,8110d3cc <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110d3b8:	e0fffe17 	ldw	r3,-8(fp)
8110d3bc:	00bffec4 	movi	r2,-5
8110d3c0:	1884703a 	and	r2,r3,r2
8110d3c4:	e0bffe15 	stw	r2,-8(fp)
8110d3c8:	00000306 	br	8110d3d8 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110d3cc:	e0bffe17 	ldw	r2,-8(fp)
8110d3d0:	10800114 	ori	r2,r2,4
8110d3d4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d3d8:	e17ffe17 	ldw	r5,-8(fp)
8110d3dc:	01000284 	movi	r4,10
8110d3e0:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d3e4:	00800044 	movi	r2,1
}
8110d3e8:	e037883a 	mov	sp,fp
8110d3ec:	dfc00117 	ldw	ra,4(sp)
8110d3f0:	df000017 	ldw	fp,0(sp)
8110d3f4:	dec00204 	addi	sp,sp,8
8110d3f8:	f800283a 	ret

8110d3fc <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110d3fc:	defffc04 	addi	sp,sp,-16
8110d400:	de00012e 	bgeu	sp,et,8110d408 <bSyncCtrCh4OutEnable+0xc>
8110d404:	003b68fa 	trap	3
8110d408:	dfc00315 	stw	ra,12(sp)
8110d40c:	df000215 	stw	fp,8(sp)
8110d410:	df000204 	addi	fp,sp,8
8110d414:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d418:	01000284 	movi	r4,10
8110d41c:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d420:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d424:	e0bfff17 	ldw	r2,-4(fp)
8110d428:	1000051e 	bne	r2,zero,8110d440 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110d42c:	e0fffe17 	ldw	r3,-8(fp)
8110d430:	00bffdc4 	movi	r2,-9
8110d434:	1884703a 	and	r2,r3,r2
8110d438:	e0bffe15 	stw	r2,-8(fp)
8110d43c:	00000306 	br	8110d44c <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110d440:	e0bffe17 	ldw	r2,-8(fp)
8110d444:	10800214 	ori	r2,r2,8
8110d448:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d44c:	e17ffe17 	ldw	r5,-8(fp)
8110d450:	01000284 	movi	r4,10
8110d454:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d458:	00800044 	movi	r2,1
}
8110d45c:	e037883a 	mov	sp,fp
8110d460:	dfc00117 	ldw	ra,4(sp)
8110d464:	df000017 	ldw	fp,0(sp)
8110d468:	dec00204 	addi	sp,sp,8
8110d46c:	f800283a 	ret

8110d470 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110d470:	defffc04 	addi	sp,sp,-16
8110d474:	de00012e 	bgeu	sp,et,8110d47c <bSyncCtrCh5OutEnable+0xc>
8110d478:	003b68fa 	trap	3
8110d47c:	dfc00315 	stw	ra,12(sp)
8110d480:	df000215 	stw	fp,8(sp)
8110d484:	df000204 	addi	fp,sp,8
8110d488:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d48c:	01000284 	movi	r4,10
8110d490:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d494:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d498:	e0bfff17 	ldw	r2,-4(fp)
8110d49c:	1000051e 	bne	r2,zero,8110d4b4 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110d4a0:	e0fffe17 	ldw	r3,-8(fp)
8110d4a4:	00bffbc4 	movi	r2,-17
8110d4a8:	1884703a 	and	r2,r3,r2
8110d4ac:	e0bffe15 	stw	r2,-8(fp)
8110d4b0:	00000306 	br	8110d4c0 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110d4b4:	e0bffe17 	ldw	r2,-8(fp)
8110d4b8:	10800414 	ori	r2,r2,16
8110d4bc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d4c0:	e17ffe17 	ldw	r5,-8(fp)
8110d4c4:	01000284 	movi	r4,10
8110d4c8:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d4cc:	00800044 	movi	r2,1
}
8110d4d0:	e037883a 	mov	sp,fp
8110d4d4:	dfc00117 	ldw	ra,4(sp)
8110d4d8:	df000017 	ldw	fp,0(sp)
8110d4dc:	dec00204 	addi	sp,sp,8
8110d4e0:	f800283a 	ret

8110d4e4 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110d4e4:	defffc04 	addi	sp,sp,-16
8110d4e8:	de00012e 	bgeu	sp,et,8110d4f0 <bSyncCtrCh6OutEnable+0xc>
8110d4ec:	003b68fa 	trap	3
8110d4f0:	dfc00315 	stw	ra,12(sp)
8110d4f4:	df000215 	stw	fp,8(sp)
8110d4f8:	df000204 	addi	fp,sp,8
8110d4fc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d500:	01000284 	movi	r4,10
8110d504:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d508:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d50c:	e0bfff17 	ldw	r2,-4(fp)
8110d510:	1000051e 	bne	r2,zero,8110d528 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110d514:	e0fffe17 	ldw	r3,-8(fp)
8110d518:	00bff7c4 	movi	r2,-33
8110d51c:	1884703a 	and	r2,r3,r2
8110d520:	e0bffe15 	stw	r2,-8(fp)
8110d524:	00000306 	br	8110d534 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110d528:	e0bffe17 	ldw	r2,-8(fp)
8110d52c:	10800814 	ori	r2,r2,32
8110d530:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d534:	e17ffe17 	ldw	r5,-8(fp)
8110d538:	01000284 	movi	r4,10
8110d53c:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d540:	00800044 	movi	r2,1
}
8110d544:	e037883a 	mov	sp,fp
8110d548:	dfc00117 	ldw	ra,4(sp)
8110d54c:	df000017 	ldw	fp,0(sp)
8110d550:	dec00204 	addi	sp,sp,8
8110d554:	f800283a 	ret

8110d558 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110d558:	defffc04 	addi	sp,sp,-16
8110d55c:	de00012e 	bgeu	sp,et,8110d564 <bSyncCtrCh7OutEnable+0xc>
8110d560:	003b68fa 	trap	3
8110d564:	dfc00315 	stw	ra,12(sp)
8110d568:	df000215 	stw	fp,8(sp)
8110d56c:	df000204 	addi	fp,sp,8
8110d570:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d574:	01000284 	movi	r4,10
8110d578:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d57c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d580:	e0bfff17 	ldw	r2,-4(fp)
8110d584:	1000051e 	bne	r2,zero,8110d59c <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110d588:	e0fffe17 	ldw	r3,-8(fp)
8110d58c:	00bfefc4 	movi	r2,-65
8110d590:	1884703a 	and	r2,r3,r2
8110d594:	e0bffe15 	stw	r2,-8(fp)
8110d598:	00000306 	br	8110d5a8 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110d59c:	e0bffe17 	ldw	r2,-8(fp)
8110d5a0:	10801014 	ori	r2,r2,64
8110d5a4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d5a8:	e17ffe17 	ldw	r5,-8(fp)
8110d5ac:	01000284 	movi	r4,10
8110d5b0:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d5b4:	00800044 	movi	r2,1
}
8110d5b8:	e037883a 	mov	sp,fp
8110d5bc:	dfc00117 	ldw	ra,4(sp)
8110d5c0:	df000017 	ldw	fp,0(sp)
8110d5c4:	dec00204 	addi	sp,sp,8
8110d5c8:	f800283a 	ret

8110d5cc <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110d5cc:	defffc04 	addi	sp,sp,-16
8110d5d0:	de00012e 	bgeu	sp,et,8110d5d8 <bSyncCtrCh8OutEnable+0xc>
8110d5d4:	003b68fa 	trap	3
8110d5d8:	dfc00315 	stw	ra,12(sp)
8110d5dc:	df000215 	stw	fp,8(sp)
8110d5e0:	df000204 	addi	fp,sp,8
8110d5e4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d5e8:	01000284 	movi	r4,10
8110d5ec:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d5f0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d5f4:	e0bfff17 	ldw	r2,-4(fp)
8110d5f8:	1000051e 	bne	r2,zero,8110d610 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110d5fc:	e0fffe17 	ldw	r3,-8(fp)
8110d600:	00bfdfc4 	movi	r2,-129
8110d604:	1884703a 	and	r2,r3,r2
8110d608:	e0bffe15 	stw	r2,-8(fp)
8110d60c:	00000306 	br	8110d61c <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110d610:	e0bffe17 	ldw	r2,-8(fp)
8110d614:	10802014 	ori	r2,r2,128
8110d618:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d61c:	e17ffe17 	ldw	r5,-8(fp)
8110d620:	01000284 	movi	r4,10
8110d624:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d628:	00800044 	movi	r2,1
}
8110d62c:	e037883a 	mov	sp,fp
8110d630:	dfc00117 	ldw	ra,4(sp)
8110d634:	df000017 	ldw	fp,0(sp)
8110d638:	dec00204 	addi	sp,sp,8
8110d63c:	f800283a 	ret

8110d640 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110d640:	defffc04 	addi	sp,sp,-16
8110d644:	de00012e 	bgeu	sp,et,8110d64c <bSyncIrqEnableError+0xc>
8110d648:	003b68fa 	trap	3
8110d64c:	dfc00315 	stw	ra,12(sp)
8110d650:	df000215 	stw	fp,8(sp)
8110d654:	df000204 	addi	fp,sp,8
8110d658:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d65c:	01000044 	movi	r4,1
8110d660:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d664:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d668:	e0bfff17 	ldw	r2,-4(fp)
8110d66c:	1000051e 	bne	r2,zero,8110d684 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110d670:	e0fffe17 	ldw	r3,-8(fp)
8110d674:	00bfff44 	movi	r2,-3
8110d678:	1884703a 	and	r2,r3,r2
8110d67c:	e0bffe15 	stw	r2,-8(fp)
8110d680:	00000306 	br	8110d690 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110d684:	e0bffe17 	ldw	r2,-8(fp)
8110d688:	10800094 	ori	r2,r2,2
8110d68c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d690:	e17ffe17 	ldw	r5,-8(fp)
8110d694:	01000044 	movi	r4,1
8110d698:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d69c:	00800044 	movi	r2,1
}
8110d6a0:	e037883a 	mov	sp,fp
8110d6a4:	dfc00117 	ldw	ra,4(sp)
8110d6a8:	df000017 	ldw	fp,0(sp)
8110d6ac:	dec00204 	addi	sp,sp,8
8110d6b0:	f800283a 	ret

8110d6b4 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110d6b4:	defffc04 	addi	sp,sp,-16
8110d6b8:	de00012e 	bgeu	sp,et,8110d6c0 <bSyncIrqEnableBlank+0xc>
8110d6bc:	003b68fa 	trap	3
8110d6c0:	dfc00315 	stw	ra,12(sp)
8110d6c4:	df000215 	stw	fp,8(sp)
8110d6c8:	df000204 	addi	fp,sp,8
8110d6cc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d6d0:	01000044 	movi	r4,1
8110d6d4:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d6d8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d6dc:	e0bfff17 	ldw	r2,-4(fp)
8110d6e0:	1000051e 	bne	r2,zero,8110d6f8 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110d6e4:	e0fffe17 	ldw	r3,-8(fp)
8110d6e8:	00bfff84 	movi	r2,-2
8110d6ec:	1884703a 	and	r2,r3,r2
8110d6f0:	e0bffe15 	stw	r2,-8(fp)
8110d6f4:	00000306 	br	8110d704 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110d6f8:	e0bffe17 	ldw	r2,-8(fp)
8110d6fc:	10800054 	ori	r2,r2,1
8110d700:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d704:	e17ffe17 	ldw	r5,-8(fp)
8110d708:	01000044 	movi	r4,1
8110d70c:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d710:	00800044 	movi	r2,1
}
8110d714:	e037883a 	mov	sp,fp
8110d718:	dfc00117 	ldw	ra,4(sp)
8110d71c:	df000017 	ldw	fp,0(sp)
8110d720:	dec00204 	addi	sp,sp,8
8110d724:	f800283a 	ret

8110d728 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110d728:	defffc04 	addi	sp,sp,-16
8110d72c:	de00012e 	bgeu	sp,et,8110d734 <bSyncIrqFlagClrError+0xc>
8110d730:	003b68fa 	trap	3
8110d734:	dfc00315 	stw	ra,12(sp)
8110d738:	df000215 	stw	fp,8(sp)
8110d73c:	df000204 	addi	fp,sp,8
8110d740:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d744:	01000084 	movi	r4,2
8110d748:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d74c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d750:	e0bfff17 	ldw	r2,-4(fp)
8110d754:	1000051e 	bne	r2,zero,8110d76c <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d758:	e0fffe17 	ldw	r3,-8(fp)
8110d75c:	00bfff44 	movi	r2,-3
8110d760:	1884703a 	and	r2,r3,r2
8110d764:	e0bffe15 	stw	r2,-8(fp)
8110d768:	00000306 	br	8110d778 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d76c:	e0bffe17 	ldw	r2,-8(fp)
8110d770:	10800094 	ori	r2,r2,2
8110d774:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d778:	e17ffe17 	ldw	r5,-8(fp)
8110d77c:	01000084 	movi	r4,2
8110d780:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d784:	00800044 	movi	r2,1
}
8110d788:	e037883a 	mov	sp,fp
8110d78c:	dfc00117 	ldw	ra,4(sp)
8110d790:	df000017 	ldw	fp,0(sp)
8110d794:	dec00204 	addi	sp,sp,8
8110d798:	f800283a 	ret

8110d79c <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110d79c:	defffc04 	addi	sp,sp,-16
8110d7a0:	de00012e 	bgeu	sp,et,8110d7a8 <bSyncIrqFlagClrBlank+0xc>
8110d7a4:	003b68fa 	trap	3
8110d7a8:	dfc00315 	stw	ra,12(sp)
8110d7ac:	df000215 	stw	fp,8(sp)
8110d7b0:	df000204 	addi	fp,sp,8
8110d7b4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d7b8:	01000084 	movi	r4,2
8110d7bc:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d7c0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d7c4:	e0bfff17 	ldw	r2,-4(fp)
8110d7c8:	1000051e 	bne	r2,zero,8110d7e0 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d7cc:	e0fffe17 	ldw	r3,-8(fp)
8110d7d0:	00bfff84 	movi	r2,-2
8110d7d4:	1884703a 	and	r2,r3,r2
8110d7d8:	e0bffe15 	stw	r2,-8(fp)
8110d7dc:	00000306 	br	8110d7ec <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d7e0:	e0bffe17 	ldw	r2,-8(fp)
8110d7e4:	10800054 	ori	r2,r2,1
8110d7e8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d7ec:	e17ffe17 	ldw	r5,-8(fp)
8110d7f0:	01000084 	movi	r4,2
8110d7f4:	110d9380 	call	8110d938 <bSyncWriteReg>
	return TRUE;
8110d7f8:	00800044 	movi	r2,1
}
8110d7fc:	e037883a 	mov	sp,fp
8110d800:	dfc00117 	ldw	ra,4(sp)
8110d804:	df000017 	ldw	fp,0(sp)
8110d808:	dec00204 	addi	sp,sp,8
8110d80c:	f800283a 	ret

8110d810 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110d810:	defffc04 	addi	sp,sp,-16
8110d814:	de00012e 	bgeu	sp,et,8110d81c <bSyncIrqFlagError+0xc>
8110d818:	003b68fa 	trap	3
8110d81c:	dfc00315 	stw	ra,12(sp)
8110d820:	df000215 	stw	fp,8(sp)
8110d824:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d828:	010000c4 	movi	r4,3
8110d82c:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d830:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110d834:	e0bfff17 	ldw	r2,-4(fp)
8110d838:	1080008c 	andi	r2,r2,2
8110d83c:	10000326 	beq	r2,zero,8110d84c <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110d840:	00800044 	movi	r2,1
8110d844:	e0bffe15 	stw	r2,-8(fp)
8110d848:	00000106 	br	8110d850 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110d84c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d850:	e0bffe17 	ldw	r2,-8(fp)
}
8110d854:	e037883a 	mov	sp,fp
8110d858:	dfc00117 	ldw	ra,4(sp)
8110d85c:	df000017 	ldw	fp,0(sp)
8110d860:	dec00204 	addi	sp,sp,8
8110d864:	f800283a 	ret

8110d868 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110d868:	defffc04 	addi	sp,sp,-16
8110d86c:	de00012e 	bgeu	sp,et,8110d874 <bSyncIrqFlagBlank+0xc>
8110d870:	003b68fa 	trap	3
8110d874:	dfc00315 	stw	ra,12(sp)
8110d878:	df000215 	stw	fp,8(sp)
8110d87c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d880:	010000c4 	movi	r4,3
8110d884:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d888:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110d88c:	e0bfff17 	ldw	r2,-4(fp)
8110d890:	1080004c 	andi	r2,r2,1
8110d894:	10000326 	beq	r2,zero,8110d8a4 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110d898:	00800044 	movi	r2,1
8110d89c:	e0bffe15 	stw	r2,-8(fp)
8110d8a0:	00000106 	br	8110d8a8 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110d8a4:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d8a8:	e0bffe17 	ldw	r2,-8(fp)
}
8110d8ac:	e037883a 	mov	sp,fp
8110d8b0:	dfc00117 	ldw	ra,4(sp)
8110d8b4:	df000017 	ldw	fp,0(sp)
8110d8b8:	dec00204 	addi	sp,sp,8
8110d8bc:	f800283a 	ret

8110d8c0 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110d8c0:	defffd04 	addi	sp,sp,-12
8110d8c4:	de00012e 	bgeu	sp,et,8110d8cc <uliSyncGetCtr+0xc>
8110d8c8:	003b68fa 	trap	3
8110d8cc:	dfc00215 	stw	ra,8(sp)
8110d8d0:	df000115 	stw	fp,4(sp)
8110d8d4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d8d8:	01000284 	movi	r4,10
8110d8dc:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d8e0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d8e4:	e0bfff17 	ldw	r2,-4(fp)
}
8110d8e8:	e037883a 	mov	sp,fp
8110d8ec:	dfc00117 	ldw	ra,4(sp)
8110d8f0:	df000017 	ldw	fp,0(sp)
8110d8f4:	dec00204 	addi	sp,sp,8
8110d8f8:	f800283a 	ret

8110d8fc <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110d8fc:	defffd04 	addi	sp,sp,-12
8110d900:	de00012e 	bgeu	sp,et,8110d908 <uliSyncReadStatus+0xc>
8110d904:	003b68fa 	trap	3
8110d908:	dfc00215 	stw	ra,8(sp)
8110d90c:	df000115 	stw	fp,4(sp)
8110d910:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d914:	0009883a 	mov	r4,zero
8110d918:	110d9940 	call	8110d994 <uliSyncReadReg>
8110d91c:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110d920:	e0bfff17 	ldw	r2,-4(fp)
}
8110d924:	e037883a 	mov	sp,fp
8110d928:	dfc00117 	ldw	ra,4(sp)
8110d92c:	df000017 	ldw	fp,0(sp)
8110d930:	dec00204 	addi	sp,sp,8
8110d934:	f800283a 	ret

8110d938 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110d938:	defffc04 	addi	sp,sp,-16
8110d93c:	de00012e 	bgeu	sp,et,8110d944 <bSyncWriteReg+0xc>
8110d940:	003b68fa 	trap	3
8110d944:	df000315 	stw	fp,12(sp)
8110d948:	df000304 	addi	fp,sp,12
8110d94c:	e13ffe15 	stw	r4,-8(fp)
8110d950:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d954:	00a00034 	movhi	r2,32768
8110d958:	10810004 	addi	r2,r2,1024
8110d95c:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110d960:	e0bffe17 	ldw	r2,-8(fp)
8110d964:	1085883a 	add	r2,r2,r2
8110d968:	1085883a 	add	r2,r2,r2
8110d96c:	1007883a 	mov	r3,r2
8110d970:	e0bffd17 	ldw	r2,-12(fp)
8110d974:	10c5883a 	add	r2,r2,r3
8110d978:	e0ffff17 	ldw	r3,-4(fp)
8110d97c:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110d980:	00800044 	movi	r2,1
}
8110d984:	e037883a 	mov	sp,fp
8110d988:	df000017 	ldw	fp,0(sp)
8110d98c:	dec00104 	addi	sp,sp,4
8110d990:	f800283a 	ret

8110d994 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110d994:	defffc04 	addi	sp,sp,-16
8110d998:	de00012e 	bgeu	sp,et,8110d9a0 <uliSyncReadReg+0xc>
8110d99c:	003b68fa 	trap	3
8110d9a0:	df000315 	stw	fp,12(sp)
8110d9a4:	df000304 	addi	fp,sp,12
8110d9a8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d9ac:	00a00034 	movhi	r2,32768
8110d9b0:	10810004 	addi	r2,r2,1024
8110d9b4:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110d9b8:	e0bfff17 	ldw	r2,-4(fp)
8110d9bc:	1085883a 	add	r2,r2,r2
8110d9c0:	1085883a 	add	r2,r2,r2
8110d9c4:	1007883a 	mov	r3,r2
8110d9c8:	e0bffd17 	ldw	r2,-12(fp)
8110d9cc:	10c5883a 	add	r2,r2,r3
8110d9d0:	10800017 	ldw	r2,0(r2)
8110d9d4:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110d9d8:	e0bffe17 	ldw	r2,-8(fp)
}
8110d9dc:	e037883a 	mov	sp,fp
8110d9e0:	df000017 	ldw	fp,0(sp)
8110d9e4:	dec00104 	addi	sp,sp,4
8110d9e8:	f800283a 	ret

8110d9ec <uliPerCalcPeriodMs>:

/*
 * Return the necessary PER value for a
 * Sync Signal period in usiPeriodMs ms.
 */
alt_u32 uliPerCalcPeriodMs(alt_u16 usiPeriodMs) {
8110d9ec:	defffc04 	addi	sp,sp,-16
8110d9f0:	de00012e 	bgeu	sp,et,8110d9f8 <uliPerCalcPeriodMs+0xc>
8110d9f4:	003b68fa 	trap	3
8110d9f8:	dfc00315 	stw	ra,12(sp)
8110d9fc:	df000215 	stw	fp,8(sp)
8110da00:	df000204 	addi	fp,sp,8
8110da04:	2005883a 	mov	r2,r4
8110da08:	e0bfff0d 	sth	r2,-4(fp)
	 * Period[ms] / 20e-6 = Period[ms] * 5e+4
	 * PER = Period[ms] * 5e+4
	 */

	alt_u32 uliPer;
	uliPer = usiPeriodMs * 5e+4;
8110da0c:	e0bfff0b 	ldhu	r2,-4(fp)
8110da10:	1009883a 	mov	r4,r2
8110da14:	11223c80 	call	811223c8 <__floatsidf>
8110da18:	1011883a 	mov	r8,r2
8110da1c:	1813883a 	mov	r9,r3
8110da20:	000d883a 	mov	r6,zero
8110da24:	01d03a34 	movhi	r7,16616
8110da28:	39da8004 	addi	r7,r7,27136
8110da2c:	4009883a 	mov	r4,r8
8110da30:	480b883a 	mov	r5,r9
8110da34:	11213240 	call	81121324 <__muldf3>
8110da38:	1009883a 	mov	r4,r2
8110da3c:	180b883a 	mov	r5,r3
8110da40:	2005883a 	mov	r2,r4
8110da44:	2807883a 	mov	r3,r5
8110da48:	1009883a 	mov	r4,r2
8110da4c:	180b883a 	mov	r5,r3
8110da50:	112075c0 	call	8112075c <__fixunsdfsi>
8110da54:	e0bffe15 	stw	r2,-8(fp)

	return uliPer;
8110da58:	e0bffe17 	ldw	r2,-8(fp)
}
8110da5c:	e037883a 	mov	sp,fp
8110da60:	dfc00117 	ldw	ra,4(sp)
8110da64:	df000017 	ldw	fp,0(sp)
8110da68:	dec00204 	addi	sp,sp,8
8110da6c:	f800283a 	ret

8110da70 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110da70:	defff804 	addi	sp,sp,-32
8110da74:	de00012e 	bgeu	sp,et,8110da7c <vDataControlTask+0xc>
8110da78:	003b68fa 	trap	3
8110da7c:	dfc00715 	stw	ra,28(sp)
8110da80:	df000615 	stw	fp,24(sp)
8110da84:	df000604 	addi	fp,sp,24
8110da88:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110da8c:	e0bffd17 	ldw	r2,-12(fp)
8110da90:	e0bffa15 	stw	r2,-24(fp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110da94:	00a045b4 	movhi	r2,33046
8110da98:	109fe204 	addi	r2,r2,32648
8110da9c:	10800d8b 	ldhu	r2,54(r2)
8110daa0:	10bfffcc 	andi	r2,r2,65535
8110daa4:	10800168 	cmpgeui	r2,r2,5
8110daa8:	1000071e 	bne	r2,zero,8110dac8 <vDataControlTask+0x58>
        debug(fp,"Data Controller Task. (Task on)\n");
8110daac:	d0a06217 	ldw	r2,-32376(gp)
8110dab0:	100f883a 	mov	r7,r2
8110dab4:	01800804 	movi	r6,32
8110dab8:	01400044 	movi	r5,1
8110dabc:	01204574 	movhi	r4,33045
8110dac0:	21363804 	addi	r4,r4,-10016
8110dac4:	1122fc80 	call	81122fc8 <fwrite>
	}
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110dac8:	e0bffa17 	ldw	r2,-24(fp)
8110dacc:	00c00044 	movi	r3,1
8110dad0:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110dad4:	d0a05f17 	ldw	r2,-32388(gp)
8110dad8:	1009883a 	mov	r4,r2
8110dadc:	113ee140 	call	8113ee14 <OSQFlush>
8110dae0:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110dae4:	e0bffc03 	ldbu	r2,-16(fp)
8110dae8:	10803fcc 	andi	r2,r2,255
8110daec:	10000126 	beq	r2,zero,8110daf4 <vDataControlTask+0x84>
		vFailFlushQueueData();
8110daf0:	111ea800 	call	8111ea80 <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskDataCtrl, 0, &error_code); /* Blocking operation */
8110daf4:	d0a05f17 	ldw	r2,-32388(gp)
8110daf8:	e0fffc04 	addi	r3,fp,-16
8110dafc:	180d883a 	mov	r6,r3
8110db00:	000b883a 	mov	r5,zero
8110db04:	1009883a 	mov	r4,r2
8110db08:	113eed40 	call	8113eed4 <OSQPend>
8110db0c:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110db10:	000f883a 	mov	r7,zero
8110db14:	01800144 	movi	r6,5
8110db18:	000b883a 	mov	r5,zero
8110db1c:	0009883a 	mov	r4,zero
8110db20:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
	}
8110db24:	003ff306 	br	8110daf4 <__reset+0xfb0edaf4>

8110db28 <vFeeTask>:

const char *cTemp[64];
unsigned char ucIterationSide;


void vFeeTask(void *task_data) {
8110db28:	defff204 	addi	sp,sp,-56
8110db2c:	de00012e 	bgeu	sp,et,8110db34 <vFeeTask+0xc>
8110db30:	003b68fa 	trap	3
8110db34:	dfc00d15 	stw	ra,52(sp)
8110db38:	df000c15 	stw	fp,48(sp)
8110db3c:	df000c04 	addi	fp,sp,48
8110db40:	e13fff15 	stw	r4,-4(fp)
	bool bFinal;
	alt_u16 *pusiHK;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
8110db44:	e0bfff17 	ldw	r2,-4(fp)
8110db48:	d0a05315 	stw	r2,-32436(gp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110db4c:	00a045b4 	movhi	r2,33046
8110db50:	109fe204 	addi	r2,r2,32648
8110db54:	10800d8b 	ldhu	r2,54(r2)
8110db58:	10bfffcc 	andi	r2,r2,65535
8110db5c:	10800168 	cmpgeui	r2,r2,5
8110db60:	1000091e 	bne	r2,zero,8110db88 <vFeeTask+0x60>
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110db64:	d0e06217 	ldw	r3,-32376(gp)
8110db68:	d0a05317 	ldw	r2,-32436(gp)
8110db6c:	10800003 	ldbu	r2,0(r2)
8110db70:	10803fcc 	andi	r2,r2,255
8110db74:	100d883a 	mov	r6,r2
8110db78:	01604574 	movhi	r5,33045
8110db7c:	29764104 	addi	r5,r5,-9980
8110db80:	1809883a 	mov	r4,r3
8110db84:	112292c0 	call	8112292c <fprintf>
	}
	#endif

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110db88:	00a045b4 	movhi	r2,33046
8110db8c:	109fe204 	addi	r2,r2,32648
8110db90:	10800d8b 	ldhu	r2,54(r2)
8110db94:	10bfffcc 	andi	r2,r2,65535
8110db98:	108000e8 	cmpgeui	r2,r2,3
8110db9c:	1000031e 	bne	r2,zero,8110dbac <vFeeTask+0x84>
		vPrintConsoleNFee( pxNFee );
8110dba0:	d0a05317 	ldw	r2,-32436(gp)
8110dba4:	1009883a 	mov	r4,r2
8110dba8:	11111a40 	call	811111a4 <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110dbac:	d0a05317 	ldw	r2,-32436(gp)
8110dbb0:	10802c17 	ldw	r2,176(r2)
8110dbb4:	10c00368 	cmpgeui	r3,r2,13
8110dbb8:	1805a21e 	bne	r3,zero,8110f244 <vFeeTask+0x171c>
8110dbbc:	100690ba 	slli	r3,r2,2
8110dbc0:	00a04474 	movhi	r2,33041
8110dbc4:	10b6f504 	addi	r2,r2,-9260
8110dbc8:	1885883a 	add	r2,r3,r2
8110dbcc:	10800017 	ldw	r2,0(r2)
8110dbd0:	1000683a 	jmp	r2
8110dbd4:	8110dc08 	cmpgei	r4,r16,17264
8110dbd8:	8110e3f0 	cmpltui	r4,r16,17295
8110dbdc:	8110e48c 	andi	r4,r16,17298
8110dbe0:	8110e604 	addi	r4,r16,17304
8110dbe4:	8110ed3c 	xorhi	r4,r16,17332
8110dbe8:	8110e210 	cmplti	r4,r16,17288
8110dbec:	8110e49c 	xori	r4,r16,17298
8110dbf0:	8110ec14 	ori	r4,r16,17328
8110dbf4:	8110f244 	addi	r4,r16,17353
8110dbf8:	8110f244 	addi	r4,r16,17353
8110dbfc:	8110e6a0 	cmpeqi	r4,r16,17306
8110dc00:	8110f04c 	andi	r4,r16,17345
8110dc04:	8110f16c 	andhi	r4,r16,17349
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110dc08:	d0a05317 	ldw	r2,-32436(gp)
8110dc0c:	10800003 	ldbu	r2,0(r2)
8110dc10:	10803fcc 	andi	r2,r2,255
8110dc14:	1085883a 	add	r2,r2,r2
8110dc18:	1087883a 	add	r3,r2,r2
8110dc1c:	d0a06a04 	addi	r2,gp,-32344
8110dc20:	1885883a 	add	r2,r3,r2
8110dc24:	10800017 	ldw	r2,0(r2)
8110dc28:	1009883a 	mov	r4,r2
8110dc2c:	113ee140 	call	8113ee14 <OSQFlush>
8110dc30:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110dc34:	e0bffd03 	ldbu	r2,-12(fp)
8110dc38:	10803fcc 	andi	r2,r2,255
8110dc3c:	10000126 	beq	r2,zero,8110dc44 <vFeeTask+0x11c>
					vFailFlushNFEEQueue();
8110dc40:	111eb480 	call	8111eb48 <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110dc44:	d0a05317 	ldw	r2,-32436(gp)
8110dc48:	10800003 	ldbu	r2,0(r2)
8110dc4c:	10803fcc 	andi	r2,r2,255
8110dc50:	1085883a 	add	r2,r2,r2
8110dc54:	1087883a 	add	r3,r2,r2
8110dc58:	d0a05c04 	addi	r2,gp,-32400
8110dc5c:	1885883a 	add	r2,r3,r2
8110dc60:	10800017 	ldw	r2,0(r2)
8110dc64:	1009883a 	mov	r4,r2
8110dc68:	113ee140 	call	8113ee14 <OSQFlush>
8110dc6c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110dc70:	e0bffd03 	ldbu	r2,-12(fp)
8110dc74:	10803fcc 	andi	r2,r2,255
8110dc78:	10000126 	beq	r2,zero,8110dc80 <vFeeTask+0x158>
					vFailFlushNFEEQueue();
8110dc7c:	111eb480 	call	8111eb48 <vFailFlushNFEEQueue>
				}				

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110dc80:	d0a05317 	ldw	r2,-32436(gp)
8110dc84:	10803304 	addi	r2,r2,204
8110dc88:	1009883a 	mov	r4,r2
8110dc8c:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth + pxNFee->xCcdInfo.usiSPrescanN + pxNFee->xCcdInfo.usiSOverscanN;
8110dc90:	d0a05317 	ldw	r2,-32436(gp)
8110dc94:	d0e05317 	ldw	r3,-32436(gp)
8110dc98:	1900308b 	ldhu	r4,194(r3)
8110dc9c:	d0e05317 	ldw	r3,-32436(gp)
8110dca0:	18c02f0b 	ldhu	r3,188(r3)
8110dca4:	20c7883a 	add	r3,r4,r3
8110dca8:	1809883a 	mov	r4,r3
8110dcac:	d0e05317 	ldw	r3,-32436(gp)
8110dcb0:	18c02f8b 	ldhu	r3,190(r3)
8110dcb4:	20c7883a 	add	r3,r4,r3
8110dcb8:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight + pxNFee->xCcdInfo.usiOLN;
8110dcbc:	d0a05317 	ldw	r2,-32436(gp)
8110dcc0:	d0e05317 	ldw	r3,-32436(gp)
8110dcc4:	1900310b 	ldhu	r4,196(r3)
8110dcc8:	d0e05317 	ldw	r3,-32436(gp)
8110dccc:	18c0300b 	ldhu	r3,192(r3)
8110dcd0:	20c7883a 	add	r3,r4,r3
8110dcd4:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight;
8110dcd8:	d0a05317 	ldw	r2,-32436(gp)
8110dcdc:	d0e05317 	ldw	r3,-32436(gp)
8110dce0:	18c0310b 	ldhu	r3,196(r3)
8110dce4:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8110dce8:	d0a05317 	ldw	r2,-32436(gp)
8110dcec:	d0e05317 	ldw	r3,-32436(gp)
8110dcf0:	18c0300b 	ldhu	r3,192(r3)
8110dcf4:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8110dcf8:	d0a05317 	ldw	r2,-32436(gp)
8110dcfc:	00e00004 	movi	r3,-32768
8110dd00:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8110dd04:	d0a05317 	ldw	r2,-32436(gp)
8110dd08:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110dd0c:	d0a05317 	ldw	r2,-32436(gp)
8110dd10:	00c00044 	movi	r3,1
8110dd14:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110dd18:	d0a05317 	ldw	r2,-32436(gp)
8110dd1c:	10803304 	addi	r2,r2,204
8110dd20:	1009883a 	mov	r4,r2
8110dd24:	11048400 	call	81104840 <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110dd28:	d0a05317 	ldw	r2,-32436(gp)
8110dd2c:	10804304 	addi	r2,r2,268
8110dd30:	1009883a 	mov	r4,r2
8110dd34:	11094480 	call	81109448 <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
8110dd38:	d0a05317 	ldw	r2,-32436(gp)
8110dd3c:	00ffc004 	movi	r3,-256
8110dd40:	10c0690d 	sth	r3,420(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
8110dd44:	d0a05317 	ldw	r2,-32436(gp)
8110dd48:	00ffc044 	movi	r3,-255
8110dd4c:	10c0698d 	sth	r3,422(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
8110dd50:	d0a05317 	ldw	r2,-32436(gp)
8110dd54:	00ffc084 	movi	r3,-254
8110dd58:	10c06a0d 	sth	r3,424(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
8110dd5c:	d0a05317 	ldw	r2,-32436(gp)
8110dd60:	00ffc0c4 	movi	r3,-253
8110dd64:	10c06a8d 	sth	r3,426(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
8110dd68:	d0a05317 	ldw	r2,-32436(gp)
8110dd6c:	00ffc104 	movi	r3,-252
8110dd70:	10c06b0d 	sth	r3,428(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
8110dd74:	d0a05317 	ldw	r2,-32436(gp)
8110dd78:	00ffc144 	movi	r3,-251
8110dd7c:	10c06b8d 	sth	r3,430(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
8110dd80:	d0a05317 	ldw	r2,-32436(gp)
8110dd84:	00ffc184 	movi	r3,-250
8110dd88:	10c06c0d 	sth	r3,432(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
8110dd8c:	d0a05317 	ldw	r2,-32436(gp)
8110dd90:	00ffc1c4 	movi	r3,-249
8110dd94:	10c06c8d 	sth	r3,434(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
8110dd98:	d0a05317 	ldw	r2,-32436(gp)
8110dd9c:	00ffc204 	movi	r3,-248
8110dda0:	10c06d0d 	sth	r3,436(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
8110dda4:	d0a05317 	ldw	r2,-32436(gp)
8110dda8:	00ffc244 	movi	r3,-247
8110ddac:	10c06d8d 	sth	r3,438(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
8110ddb0:	d0a05317 	ldw	r2,-32436(gp)
8110ddb4:	00ffc284 	movi	r3,-246
8110ddb8:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
8110ddbc:	d0a05317 	ldw	r2,-32436(gp)
8110ddc0:	00ffc2c4 	movi	r3,-245
8110ddc4:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
8110ddc8:	d0a05317 	ldw	r2,-32436(gp)
8110ddcc:	00ffc304 	movi	r3,-244
8110ddd0:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
8110ddd4:	d0a05317 	ldw	r2,-32436(gp)
8110ddd8:	00ffc344 	movi	r3,-243
8110dddc:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
8110dde0:	d0a05317 	ldw	r2,-32436(gp)
8110dde4:	00ffc384 	movi	r3,-242
8110dde8:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
8110ddec:	d0a05317 	ldw	r2,-32436(gp)
8110ddf0:	00ffc3c4 	movi	r3,-241
8110ddf4:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
8110ddf8:	d0a05317 	ldw	r2,-32436(gp)
8110ddfc:	00ffc404 	movi	r3,-240
8110de00:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
8110de04:	d0a05317 	ldw	r2,-32436(gp)
8110de08:	00ffc444 	movi	r3,-239
8110de0c:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
8110de10:	d0a05317 	ldw	r2,-32436(gp)
8110de14:	00ffc484 	movi	r3,-238
8110de18:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
8110de1c:	d0a05317 	ldw	r2,-32436(gp)
8110de20:	00ffc4c4 	movi	r3,-237
8110de24:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
8110de28:	d0a05317 	ldw	r2,-32436(gp)
8110de2c:	00ffc504 	movi	r3,-236
8110de30:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
8110de34:	d0a05317 	ldw	r2,-32436(gp)
8110de38:	00ffc544 	movi	r3,-235
8110de3c:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
8110de40:	d0a05317 	ldw	r2,-32436(gp)
8110de44:	00ffc584 	movi	r3,-234
8110de48:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
8110de4c:	d0a05317 	ldw	r2,-32436(gp)
8110de50:	00ffc5c4 	movi	r3,-233
8110de54:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
8110de58:	d0a05317 	ldw	r2,-32436(gp)
8110de5c:	00ffc604 	movi	r3,-232
8110de60:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
8110de64:	d0a05317 	ldw	r2,-32436(gp)
8110de68:	00ffc644 	movi	r3,-231
8110de6c:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
8110de70:	d0a05317 	ldw	r2,-32436(gp)
8110de74:	00ffc684 	movi	r3,-230
8110de78:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
8110de7c:	d0a05317 	ldw	r2,-32436(gp)
8110de80:	00ffc6c4 	movi	r3,-229
8110de84:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
8110de88:	d0a05317 	ldw	r2,-32436(gp)
8110de8c:	00ffc704 	movi	r3,-228
8110de90:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
8110de94:	d0a05317 	ldw	r2,-32436(gp)
8110de98:	00ffc744 	movi	r3,-227
8110de9c:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
8110dea0:	d0a05317 	ldw	r2,-32436(gp)
8110dea4:	00ffc784 	movi	r3,-226
8110dea8:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
8110deac:	d0a05317 	ldw	r2,-32436(gp)
8110deb0:	00ffc7c4 	movi	r3,-225
8110deb4:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
8110deb8:	d0a05317 	ldw	r2,-32436(gp)
8110debc:	00ffc804 	movi	r3,-224
8110dec0:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
8110dec4:	d0a05317 	ldw	r2,-32436(gp)
8110dec8:	00ffc844 	movi	r3,-223
8110decc:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
8110ded0:	d0a05317 	ldw	r2,-32436(gp)
8110ded4:	00ffc884 	movi	r3,-222
8110ded8:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
8110dedc:	d0a05317 	ldw	r2,-32436(gp)
8110dee0:	00ffc8c4 	movi	r3,-221
8110dee4:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
8110dee8:	d0a05317 	ldw	r2,-32436(gp)
8110deec:	00ffc904 	movi	r3,-220
8110def0:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
8110def4:	d0a05317 	ldw	r2,-32436(gp)
8110def8:	00ffc944 	movi	r3,-219
8110defc:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
8110df00:	d0a05317 	ldw	r2,-32436(gp)
8110df04:	00ffc984 	movi	r3,-218
8110df08:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
8110df0c:	d0a05317 	ldw	r2,-32436(gp)
8110df10:	00ffc9c4 	movi	r3,-217
8110df14:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
8110df18:	d0a05317 	ldw	r2,-32436(gp)
8110df1c:	00ffca04 	movi	r3,-216
8110df20:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
8110df24:	d0a05317 	ldw	r2,-32436(gp)
8110df28:	00ffca44 	movi	r3,-215
8110df2c:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
8110df30:	d0a05317 	ldw	r2,-32436(gp)
8110df34:	00ffca84 	movi	r3,-214
8110df38:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
8110df3c:	d0a05317 	ldw	r2,-32436(gp)
8110df40:	00ffcac4 	movi	r3,-213
8110df44:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
8110df48:	d0a05317 	ldw	r2,-32436(gp)
8110df4c:	00ffcb04 	movi	r3,-212
8110df50:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
8110df54:	d0a05317 	ldw	r2,-32436(gp)
8110df58:	00ffcb44 	movi	r3,-211
8110df5c:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
8110df60:	d0a05317 	ldw	r2,-32436(gp)
8110df64:	00ffcb84 	movi	r3,-210
8110df68:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
8110df6c:	d0a05317 	ldw	r2,-32436(gp)
8110df70:	00ffcbc4 	movi	r3,-209
8110df74:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
8110df78:	d0a05317 	ldw	r2,-32436(gp)
8110df7c:	00ffcc04 	movi	r3,-208
8110df80:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
8110df84:	d0a05317 	ldw	r2,-32436(gp)
8110df88:	00ffcc44 	movi	r3,-207
8110df8c:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
8110df90:	d0a05317 	ldw	r2,-32436(gp)
8110df94:	00ffcc84 	movi	r3,-206
8110df98:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
8110df9c:	d0a05317 	ldw	r2,-32436(gp)
8110dfa0:	00ffccc4 	movi	r3,-205
8110dfa4:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
8110dfa8:	d0a05317 	ldw	r2,-32436(gp)
8110dfac:	00ffcd04 	movi	r3,-204
8110dfb0:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
8110dfb4:	d0a05317 	ldw	r2,-32436(gp)
8110dfb8:	00ffcd44 	movi	r3,-203
8110dfbc:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
8110dfc0:	d0a05317 	ldw	r2,-32436(gp)
8110dfc4:	00ffcd84 	movi	r3,-202
8110dfc8:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
8110dfcc:	d0a05317 	ldw	r2,-32436(gp)
8110dfd0:	00ffcdc4 	movi	r3,-201
8110dfd4:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
8110dfd8:	d0a05317 	ldw	r2,-32436(gp)
8110dfdc:	00ffce04 	movi	r3,-200
8110dfe0:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
8110dfe4:	d0a05317 	ldw	r2,-32436(gp)
8110dfe8:	00ffce44 	movi	r3,-199
8110dfec:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
8110dff0:	d0a05317 	ldw	r2,-32436(gp)
8110dff4:	00ffce84 	movi	r3,-198
8110dff8:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
8110dffc:	d0a05317 	ldw	r2,-32436(gp)
8110e000:	00ffcec4 	movi	r3,-197
8110e004:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
8110e008:	d0a05317 	ldw	r2,-32436(gp)
8110e00c:	00ffcf04 	movi	r3,-196
8110e010:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
8110e014:	d0a05317 	ldw	r2,-32436(gp)
8110e018:	00ffcf44 	movi	r3,-195
8110e01c:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
8110e020:	d0a05317 	ldw	r2,-32436(gp)
8110e024:	00ffcf84 	movi	r3,-194
8110e028:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
8110e02c:	d0a05317 	ldw	r2,-32436(gp)
8110e030:	00ffcfc4 	movi	r3,-193
8110e034:	10c0888d 	sth	r3,546(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110e038:	d0a05317 	ldw	r2,-32436(gp)
8110e03c:	10804304 	addi	r2,r2,268
8110e040:	1009883a 	mov	r4,r2
8110e044:	11083fc0 	call	811083fc <bRmapSetRmapMemHKArea>


				vLoadCtemp();
8110e048:	1111ef80 	call	81111ef8 <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110e04c:	d0a05317 	ldw	r2,-32436(gp)
8110e050:	10804304 	addi	r2,r2,268
8110e054:	1009883a 	mov	r4,r2
8110e058:	11094480 	call	81109448 <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
8110e05c:	d0a05317 	ldw	r2,-32436(gp)
8110e060:	10806904 	addi	r2,r2,420
8110e064:	e0bffa15 	stw	r2,-24(fp)

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110e068:	00a045b4 	movhi	r2,33046
8110e06c:	109fe204 	addi	r2,r2,32648
8110e070:	10800d8b 	ldhu	r2,54(r2)
8110e074:	10bfffcc 	andi	r2,r2,65535
8110e078:	108000e8 	cmpgeui	r2,r2,3
8110e07c:	1000291e 	bne	r2,zero,8110e124 <vFeeTask+0x5fc>
					fprintf(fp,"\n\n================= H  K ==================\n");
8110e080:	d0a06217 	ldw	r2,-32376(gp)
8110e084:	100f883a 	mov	r7,r2
8110e088:	01800b04 	movi	r6,44
8110e08c:	01400044 	movi	r5,1
8110e090:	01204574 	movhi	r4,33045
8110e094:	21364804 	addi	r4,r4,-9952
8110e098:	1122fc80 	call	81122fc8 <fwrite>
					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110e09c:	e03ffb05 	stb	zero,-20(fp)
8110e0a0:	00001606 	br	8110e0fc <vFeeTask+0x5d4>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
8110e0a4:	d1206217 	ldw	r4,-32376(gp)
8110e0a8:	e0fffb03 	ldbu	r3,-20(fp)
8110e0ac:	00a04574 	movhi	r2,33045
8110e0b0:	10938404 	addi	r2,r2,19984
8110e0b4:	18c7883a 	add	r3,r3,r3
8110e0b8:	18c7883a 	add	r3,r3,r3
8110e0bc:	10c5883a 	add	r2,r2,r3
8110e0c0:	10c00017 	ldw	r3,0(r2)
8110e0c4:	e0bffa17 	ldw	r2,-24(fp)
8110e0c8:	1080000b 	ldhu	r2,0(r2)
8110e0cc:	10bfffcc 	andi	r2,r2,65535
8110e0d0:	100f883a 	mov	r7,r2
8110e0d4:	180d883a 	mov	r6,r3
8110e0d8:	01604574 	movhi	r5,33045
8110e0dc:	29765404 	addi	r5,r5,-9904
8110e0e0:	112292c0 	call	8112292c <fprintf>
						pusiHK++;
8110e0e4:	e0bffa17 	ldw	r2,-24(fp)
8110e0e8:	10800084 	addi	r2,r2,2
8110e0ec:	e0bffa15 	stw	r2,-24(fp)
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
					fprintf(fp,"\n\n================= H  K ==================\n");
					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110e0f0:	e0bffb03 	ldbu	r2,-20(fp)
8110e0f4:	10800044 	addi	r2,r2,1
8110e0f8:	e0bffb05 	stb	r2,-20(fp)
8110e0fc:	e0bffb03 	ldbu	r2,-20(fp)
8110e100:	10801030 	cmpltui	r2,r2,64
8110e104:	103fe71e 	bne	r2,zero,8110e0a4 <__reset+0xfb0ee0a4>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
						pusiHK++;
					}
					fprintf(fp,"\n================= H  K ==================\n\n");
8110e108:	d0a06217 	ldw	r2,-32376(gp)
8110e10c:	100f883a 	mov	r7,r2
8110e110:	01800b04 	movi	r6,44
8110e114:	01400044 	movi	r5,1
8110e118:	01204574 	movhi	r4,33045
8110e11c:	21365904 	addi	r4,r4,-9884
8110e120:	1122fc80 	call	81122fc8 <fwrite>
				}
				#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
8110e124:	d0a05317 	ldw	r2,-32436(gp)
8110e128:	10804304 	addi	r2,r2,268
8110e12c:	1009883a 	mov	r4,r2
8110e130:	1107a5c0 	call	81107a5c <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
8110e134:	d0e05317 	ldw	r3,-32436(gp)
8110e138:	00a045b4 	movhi	r2,33046
8110e13c:	109fe204 	addi	r2,r2,32648
8110e140:	10800b0b 	ldhu	r2,44(r2)
8110e144:	18804405 	stb	r2,272(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
8110e148:	d0e05317 	ldw	r3,-32436(gp)
8110e14c:	00a045b4 	movhi	r2,33046
8110e150:	109fe204 	addi	r2,r2,32648
8110e154:	10800b8b 	ldhu	r2,46(r2)
8110e158:	18804445 	stb	r2,273(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
8110e15c:	d0a05317 	ldw	r2,-32436(gp)
8110e160:	10804304 	addi	r2,r2,268
8110e164:	1009883a 	mov	r4,r2
8110e168:	11079840 	call	81107984 <bRmapSetCodecConfig>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110e16c:	00a045b4 	movhi	r2,33046
8110e170:	109fe204 	addi	r2,r2,32648
8110e174:	10800d8b 	ldhu	r2,54(r2)
8110e178:	10bfffcc 	andi	r2,r2,65535
8110e17c:	108000e8 	cmpgeui	r2,r2,3
8110e180:	10001c1e 	bne	r2,zero,8110e1f4 <vFeeTask+0x6cc>
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", pxNFee->ucId ,xDefaults.ucRmapKey );
8110e184:	d0e06217 	ldw	r3,-32376(gp)
8110e188:	d0a05317 	ldw	r2,-32436(gp)
8110e18c:	10800003 	ldbu	r2,0(r2)
8110e190:	11003fcc 	andi	r4,r2,255
8110e194:	00a045b4 	movhi	r2,33046
8110e198:	109fe204 	addi	r2,r2,32648
8110e19c:	10800b0b 	ldhu	r2,44(r2)
8110e1a0:	10bfffcc 	andi	r2,r2,65535
8110e1a4:	100f883a 	mov	r7,r2
8110e1a8:	200d883a 	mov	r6,r4
8110e1ac:	01604574 	movhi	r5,33045
8110e1b0:	29766504 	addi	r5,r5,-9836
8110e1b4:	1809883a 	mov	r4,r3
8110e1b8:	112292c0 	call	8112292c <fprintf>
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", pxNFee->ucId, xDefaults.ucLogicalAddr);
8110e1bc:	d0e06217 	ldw	r3,-32376(gp)
8110e1c0:	d0a05317 	ldw	r2,-32436(gp)
8110e1c4:	10800003 	ldbu	r2,0(r2)
8110e1c8:	11003fcc 	andi	r4,r2,255
8110e1cc:	00a045b4 	movhi	r2,33046
8110e1d0:	109fe204 	addi	r2,r2,32648
8110e1d4:	10800b8b 	ldhu	r2,46(r2)
8110e1d8:	10bfffcc 	andi	r2,r2,65535
8110e1dc:	100f883a 	mov	r7,r2
8110e1e0:	200d883a 	mov	r6,r4
8110e1e4:	01604574 	movhi	r5,33045
8110e1e8:	29766d04 	addi	r5,r5,-9804
8110e1ec:	1809883a 	mov	r4,r3
8110e1f0:	112292c0 	call	8112292c <fprintf>
				}
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
8110e1f4:	d0a05317 	ldw	r2,-32436(gp)
8110e1f8:	00c00144 	movi	r3,5
8110e1fc:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e200:	d0a05317 	ldw	r2,-32436(gp)
8110e204:	10802e17 	ldw	r2,184(r2)
8110e208:	d0a05605 	stb	r2,-32424(gp)

				break;
8110e20c:	00042b06 	br	8110f2bc <vFeeTask+0x1794>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e210:	d0a05317 	ldw	r2,-32436(gp)
8110e214:	10804304 	addi	r2,r2,268
8110e218:	1009883a 	mov	r4,r2
8110e21c:	11080940 	call	81108094 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8110e220:	d0a05317 	ldw	r2,-32436(gp)
8110e224:	00c00184 	movi	r3,6
8110e228:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e22c:	d0a05317 	ldw	r2,-32436(gp)
8110e230:	10804304 	addi	r2,r2,268
8110e234:	1009883a 	mov	r4,r2
8110e238:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e23c:	d0a05317 	ldw	r2,-32436(gp)
8110e240:	10808904 	addi	r2,r2,548
8110e244:	1009883a 	mov	r4,r2
8110e248:	1110e980 	call	81110e98 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110e24c:	d0a05317 	ldw	r2,-32436(gp)
8110e250:	10002615 	stw	zero,152(r2)

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucSPWId);
8110e254:	d0a05317 	ldw	r2,-32436(gp)
8110e258:	10c04304 	addi	r3,r2,268
8110e25c:	d0a05317 	ldw	r2,-32436(gp)
8110e260:	10800043 	ldbu	r2,1(r2)
8110e264:	10803fcc 	andi	r2,r2,255
8110e268:	100b883a 	mov	r5,r2
8110e26c:	1809883a 	mov	r4,r3
8110e270:	1110dec0 	call	81110dec <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e274:	d0a05317 	ldw	r2,-32436(gp)
8110e278:	10803b04 	addi	r2,r2,236
8110e27c:	1009883a 	mov	r4,r2
8110e280:	1110ff00 	call	81110ff0 <bDisAndClrDbBuffer>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110e284:	00a045b4 	movhi	r2,33046
8110e288:	109fe204 	addi	r2,r2,32648
8110e28c:	10800d8b 	ldhu	r2,54(r2)
8110e290:	10bfffcc 	andi	r2,r2,65535
8110e294:	10800168 	cmpgeui	r2,r2,5
8110e298:	1000091e 	bne	r2,zero,8110e2c0 <vFeeTask+0x798>
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110e29c:	d0e06217 	ldw	r3,-32376(gp)
8110e2a0:	d0a05317 	ldw	r2,-32436(gp)
8110e2a4:	10800003 	ldbu	r2,0(r2)
8110e2a8:	10803fcc 	andi	r2,r2,255
8110e2ac:	100d883a 	mov	r6,r2
8110e2b0:	01604574 	movhi	r5,33045
8110e2b4:	29767604 	addi	r5,r5,-9768
8110e2b8:	1809883a 	mov	r4,r3
8110e2bc:	112292c0 	call	8112292c <fprintf>
				}
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110e2c0:	d0a05317 	ldw	r2,-32436(gp)
8110e2c4:	10802217 	ldw	r2,136(r2)
8110e2c8:	10800058 	cmpnei	r2,r2,1
8110e2cc:	10000a1e 	bne	r2,zero,8110e2f8 <vFeeTask+0x7d0>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e2d0:	e0fff403 	ldbu	r3,-48(fp)
8110e2d4:	00a045b4 	movhi	r2,33046
8110e2d8:	10932604 	addi	r2,r2,19608
8110e2dc:	180690fa 	slli	r3,r3,3
8110e2e0:	10c5883a 	add	r2,r2,r3
8110e2e4:	10800017 	ldw	r2,0(r2)
8110e2e8:	1009883a 	mov	r4,r2
8110e2ec:	113e3640 	call	8113e364 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110e2f0:	d0a05317 	ldw	r2,-32436(gp)
8110e2f4:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e2f8:	d0a05317 	ldw	r2,-32436(gp)
8110e2fc:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e300:	d0a05317 	ldw	r2,-32436(gp)
8110e304:	10800003 	ldbu	r2,0(r2)
8110e308:	10803fcc 	andi	r2,r2,255
8110e30c:	1085883a 	add	r2,r2,r2
8110e310:	1087883a 	add	r3,r2,r2
8110e314:	d0a05c04 	addi	r2,gp,-32400
8110e318:	1885883a 	add	r2,r3,r2
8110e31c:	10800017 	ldw	r2,0(r2)
8110e320:	1009883a 	mov	r4,r2
8110e324:	113ee140 	call	8113ee14 <OSQFlush>
8110e328:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e32c:	e0bffd03 	ldbu	r2,-12(fp)
8110e330:	10803fcc 	andi	r2,r2,255
8110e334:	10000126 	beq	r2,zero,8110e33c <vFeeTask+0x814>
					vFailFlushNFEEQueue();
8110e338:	111eb480 	call	8111eb48 <vFailFlushNFEEQueue>
				}

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e33c:	d0a05317 	ldw	r2,-32436(gp)
8110e340:	10800003 	ldbu	r2,0(r2)
8110e344:	10803fcc 	andi	r2,r2,255
8110e348:	100d883a 	mov	r6,r2
8110e34c:	000b883a 	mov	r5,zero
8110e350:	01002044 	movi	r4,129
8110e354:	11111000 	call	81111100 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110e358:	d0a05317 	ldw	r2,-32436(gp)
8110e35c:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110e360:	d0a05317 	ldw	r2,-32436(gp)
8110e364:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e368:	d0a05317 	ldw	r2,-32436(gp)
8110e36c:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e370:	d0a05317 	ldw	r2,-32436(gp)
8110e374:	00c00044 	movi	r3,1
8110e378:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
8110e37c:	d0a05317 	ldw	r2,-32436(gp)
8110e380:	1009883a 	mov	r4,r2
8110e384:	111f2380 	call	8111f238 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110e388:	d0a05317 	ldw	r2,-32436(gp)
8110e38c:	10800003 	ldbu	r2,0(r2)
8110e390:	10803fcc 	andi	r2,r2,255
8110e394:	1085883a 	add	r2,r2,r2
8110e398:	1087883a 	add	r3,r2,r2
8110e39c:	d0a06a04 	addi	r2,gp,-32344
8110e3a0:	1885883a 	add	r2,r3,r2
8110e3a4:	10800017 	ldw	r2,0(r2)
8110e3a8:	1009883a 	mov	r4,r2
8110e3ac:	113ee140 	call	8113ee14 <OSQFlush>
8110e3b0:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e3b4:	e0bffd03 	ldbu	r2,-12(fp)
8110e3b8:	10803fcc 	andi	r2,r2,255
8110e3bc:	10000126 	beq	r2,zero,8110e3c4 <vFeeTask+0x89c>
					vFailFlushNFEEQueue();
8110e3c0:	111eb480 	call	8111eb48 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
8110e3c4:	d0a05317 	ldw	r2,-32436(gp)
8110e3c8:	00c00044 	movi	r3,1
8110e3cc:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
8110e3d0:	d0a05317 	ldw	r2,-32436(gp)
8110e3d4:	00c00044 	movi	r3,1
8110e3d8:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e3dc:	d0a05317 	ldw	r2,-32436(gp)
8110e3e0:	10802e17 	ldw	r2,184(r2)
8110e3e4:	d0a05605 	stb	r2,-32424(gp)
				bFinal = FALSE;
8110e3e8:	e03ff915 	stw	zero,-28(fp)
				break;
8110e3ec:	0003b306 	br	8110f2bc <vFeeTask+0x1794>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e3f0:	d0a05317 	ldw	r2,-32436(gp)
8110e3f4:	10800003 	ldbu	r2,0(r2)
8110e3f8:	10803fcc 	andi	r2,r2,255
8110e3fc:	1085883a 	add	r2,r2,r2
8110e400:	1087883a 	add	r3,r2,r2
8110e404:	d0a06a04 	addi	r2,gp,-32344
8110e408:	1885883a 	add	r2,r3,r2
8110e40c:	10800017 	ldw	r2,0(r2)
8110e410:	e0fffd04 	addi	r3,fp,-12
8110e414:	180d883a 	mov	r6,r3
8110e418:	000b883a 	mov	r5,zero
8110e41c:	1009883a 	mov	r4,r2
8110e420:	113eed40 	call	8113eed4 <OSQPend>
8110e424:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e428:	e0bffd03 	ldbu	r2,-12(fp)
8110e42c:	10803fcc 	andi	r2,r2,255
8110e430:	1000061e 	bne	r2,zero,8110e44c <vFeeTask+0x924>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110e434:	d0a05317 	ldw	r2,-32436(gp)
8110e438:	e0fffe17 	ldw	r3,-8(fp)
8110e43c:	180b883a 	mov	r5,r3
8110e440:	1009883a 	mov	r4,r2
8110e444:	110f4d80 	call	8110f4d8 <vQCmdFEEinConfig>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110e448:	00039106 	br	8110f290 <vFeeTask+0x1768>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110e44c:	00a045b4 	movhi	r2,33046
8110e450:	109fe204 	addi	r2,r2,32648
8110e454:	10800d8b 	ldhu	r2,54(r2)
8110e458:	10bfffcc 	andi	r2,r2,65535
8110e45c:	10800228 	cmpgeui	r2,r2,8
8110e460:	10038b1e 	bne	r2,zero,8110f290 <vFeeTask+0x1768>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e464:	d0e06217 	ldw	r3,-32376(gp)
8110e468:	d0a05317 	ldw	r2,-32436(gp)
8110e46c:	10800003 	ldbu	r2,0(r2)
8110e470:	10803fcc 	andi	r2,r2,255
8110e474:	100d883a 	mov	r6,r2
8110e478:	01604574 	movhi	r5,33045
8110e47c:	29767d04 	addi	r5,r5,-9740
8110e480:	1809883a 	mov	r4,r3
8110e484:	112292c0 	call	8112292c <fprintf>
					}
					#endif
				}

				break;
8110e488:	00038106 	br	8110f290 <vFeeTask+0x1768>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110e48c:	d0a05317 	ldw	r2,-32436(gp)
8110e490:	00c00184 	movi	r3,6
8110e494:	10c02c15 	stw	r3,176(r2)
				break;
8110e498:	00038806 	br	8110f2bc <vFeeTask+0x1794>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e49c:	d0a05317 	ldw	r2,-32436(gp)
8110e4a0:	10804304 	addi	r2,r2,268
8110e4a4:	1009883a 	mov	r4,r2
8110e4a8:	11080940 	call	81108094 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8110e4ac:	d0a05317 	ldw	r2,-32436(gp)
8110e4b0:	10006615 	stw	zero,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e4b4:	d0a05317 	ldw	r2,-32436(gp)
8110e4b8:	10804304 	addi	r2,r2,268
8110e4bc:	1009883a 	mov	r4,r2
8110e4c0:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e4c4:	d0a05317 	ldw	r2,-32436(gp)
8110e4c8:	10803b04 	addi	r2,r2,236
8110e4cc:	1009883a 	mov	r4,r2
8110e4d0:	1110ff00 	call	81110ff0 <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110e4d4:	d0a05317 	ldw	r2,-32436(gp)
8110e4d8:	10c04304 	addi	r3,r2,268
8110e4dc:	d0a05317 	ldw	r2,-32436(gp)
8110e4e0:	10800003 	ldbu	r2,0(r2)
8110e4e4:	10803fcc 	andi	r2,r2,255
8110e4e8:	100b883a 	mov	r5,r2
8110e4ec:	1809883a 	mov	r4,r3
8110e4f0:	1110e400 	call	81110e40 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e4f4:	d0a05317 	ldw	r2,-32436(gp)
8110e4f8:	10808904 	addi	r2,r2,548
8110e4fc:	1009883a 	mov	r4,r2
8110e500:	1110ef80 	call	81110ef8 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110e504:	d0a05317 	ldw	r2,-32436(gp)
8110e508:	00c00044 	movi	r3,1
8110e50c:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.bSimulating = TRUE;
8110e510:	d0a05317 	ldw	r2,-32436(gp)
8110e514:	00c00044 	movi	r3,1
8110e518:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e51c:	d0a05317 	ldw	r2,-32436(gp)
8110e520:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e524:	d0a05317 	ldw	r2,-32436(gp)
8110e528:	00c00044 	movi	r3,1
8110e52c:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e530:	d0a05317 	ldw	r2,-32436(gp)
8110e534:	10800003 	ldbu	r2,0(r2)
8110e538:	10803fcc 	andi	r2,r2,255
8110e53c:	100d883a 	mov	r6,r2
8110e540:	000b883a 	mov	r5,zero
8110e544:	01002044 	movi	r4,129
8110e548:	11111000 	call	81111100 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e54c:	d0a05317 	ldw	r2,-32436(gp)
8110e550:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e554:	d0a05317 	ldw	r2,-32436(gp)
8110e558:	10800003 	ldbu	r2,0(r2)
8110e55c:	10803fcc 	andi	r2,r2,255
8110e560:	1085883a 	add	r2,r2,r2
8110e564:	1087883a 	add	r3,r2,r2
8110e568:	d0a05c04 	addi	r2,gp,-32400
8110e56c:	1885883a 	add	r2,r3,r2
8110e570:	10800017 	ldw	r2,0(r2)
8110e574:	1009883a 	mov	r4,r2
8110e578:	113ee140 	call	8113ee14 <OSQFlush>
8110e57c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e580:	e0bffd03 	ldbu	r2,-12(fp)
8110e584:	10803fcc 	andi	r2,r2,255
8110e588:	10000126 	beq	r2,zero,8110e590 <vFeeTask+0xa68>
					vFailFlushNFEEQueue();
8110e58c:	111eb480 	call	8111eb48 <vFailFlushNFEEQueue>
				}

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110e590:	00a045b4 	movhi	r2,33046
8110e594:	109fe204 	addi	r2,r2,32648
8110e598:	10800d8b 	ldhu	r2,54(r2)
8110e59c:	10bfffcc 	andi	r2,r2,65535
8110e5a0:	10800168 	cmpgeui	r2,r2,5
8110e5a4:	1000091e 	bne	r2,zero,8110e5cc <vFeeTask+0xaa4>
					fprintf(fp,"NFEE-%hu Task: Standby\n", pxNFee->ucId);
8110e5a8:	d0e06217 	ldw	r3,-32376(gp)
8110e5ac:	d0a05317 	ldw	r2,-32436(gp)
8110e5b0:	10800003 	ldbu	r2,0(r2)
8110e5b4:	10803fcc 	andi	r2,r2,255
8110e5b8:	100d883a 	mov	r6,r2
8110e5bc:	01604574 	movhi	r5,33045
8110e5c0:	29768904 	addi	r5,r5,-9692
8110e5c4:	1809883a 	mov	r4,r3
8110e5c8:	112292c0 	call	8112292c <fprintf>
				}
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
8110e5cc:	d0a05317 	ldw	r2,-32436(gp)
8110e5d0:	1009883a 	mov	r4,r2
8110e5d4:	111f2380 	call	8111f238 <vResetMemCCDFEE>

				incrementador = 0;
8110e5d8:	d0205415 	stw	zero,-32432(gp)

				pxNFee->xControl.bWatingSync = TRUE;
8110e5dc:	d0a05317 	ldw	r2,-32436(gp)
8110e5e0:	00c00044 	movi	r3,1
8110e5e4:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
8110e5e8:	d0a05317 	ldw	r2,-32436(gp)
8110e5ec:	00c000c4 	movi	r3,3
8110e5f0:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e5f4:	d0a05317 	ldw	r2,-32436(gp)
8110e5f8:	10802e17 	ldw	r2,184(r2)
8110e5fc:	d0a05605 	stb	r2,-32424(gp)
				break;
8110e600:	00032e06 	br	8110f2bc <vFeeTask+0x1794>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e604:	d0a05317 	ldw	r2,-32436(gp)
8110e608:	10800003 	ldbu	r2,0(r2)
8110e60c:	10803fcc 	andi	r2,r2,255
8110e610:	1085883a 	add	r2,r2,r2
8110e614:	1087883a 	add	r3,r2,r2
8110e618:	d0a06a04 	addi	r2,gp,-32344
8110e61c:	1885883a 	add	r2,r3,r2
8110e620:	10800017 	ldw	r2,0(r2)
8110e624:	e0fffd04 	addi	r3,fp,-12
8110e628:	180d883a 	mov	r6,r3
8110e62c:	000b883a 	mov	r5,zero
8110e630:	1009883a 	mov	r4,r2
8110e634:	113eed40 	call	8113eed4 <OSQPend>
8110e638:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e63c:	e0bffd03 	ldbu	r2,-12(fp)
8110e640:	10803fcc 	andi	r2,r2,255
8110e644:	1000061e 	bne	r2,zero,8110e660 <vFeeTask+0xb38>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110e648:	d0a05317 	ldw	r2,-32436(gp)
8110e64c:	e0fffe17 	ldw	r3,-8(fp)
8110e650:	180b883a 	mov	r5,r3
8110e654:	1009883a 	mov	r4,r2
8110e658:	110f71c0 	call	8110f71c <vQCmdFEEinStandBy>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110e65c:	00030e06 	br	8110f298 <vFeeTask+0x1770>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110e660:	00a045b4 	movhi	r2,33046
8110e664:	109fe204 	addi	r2,r2,32648
8110e668:	10800d8b 	ldhu	r2,54(r2)
8110e66c:	10bfffcc 	andi	r2,r2,65535
8110e670:	10800228 	cmpgeui	r2,r2,8
8110e674:	1003081e 	bne	r2,zero,8110f298 <vFeeTask+0x1770>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e678:	d0e06217 	ldw	r3,-32376(gp)
8110e67c:	d0a05317 	ldw	r2,-32436(gp)
8110e680:	10800003 	ldbu	r2,0(r2)
8110e684:	10803fcc 	andi	r2,r2,255
8110e688:	100d883a 	mov	r6,r2
8110e68c:	01604574 	movhi	r5,33045
8110e690:	29767d04 	addi	r5,r5,-9740
8110e694:	1809883a 	mov	r4,r3
8110e698:	112292c0 	call	8112292c <fprintf>
					}
					#endif
				}

				break;
8110e69c:	0002fe06 	br	8110f298 <vFeeTask+0x1770>


			case sNextPatternIteration:


				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e6a0:	d0a05317 	ldw	r2,-32436(gp)
8110e6a4:	10800003 	ldbu	r2,0(r2)
8110e6a8:	10803fcc 	andi	r2,r2,255
8110e6ac:	1085883a 	add	r2,r2,r2
8110e6b0:	1087883a 	add	r3,r2,r2
8110e6b4:	d0a05c04 	addi	r2,gp,-32400
8110e6b8:	1885883a 	add	r2,r3,r2
8110e6bc:	10800017 	ldw	r2,0(r2)
8110e6c0:	1009883a 	mov	r4,r2
8110e6c4:	113ee140 	call	8113ee14 <OSQFlush>
8110e6c8:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e6cc:	e0bffd03 	ldbu	r2,-12(fp)
8110e6d0:	10803fcc 	andi	r2,r2,255
8110e6d4:	10000126 	beq	r2,zero,8110e6dc <vFeeTask+0xbb4>
					vFailFlushNFEEQueue();
8110e6d8:	111eb480 	call	8111eb48 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bUsingDMA = TRUE;
8110e6dc:	d0a05317 	ldw	r2,-32436(gp)
8110e6e0:	00c00044 	movi	r3,1
8110e6e4:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110e6e8:	d0a05317 	ldw	r2,-32436(gp)
8110e6ec:	00c00044 	movi	r3,1
8110e6f0:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
8110e6f4:	d0a05317 	ldw	r2,-32436(gp)
8110e6f8:	1009883a 	mov	r4,r2
8110e6fc:	111f2380 	call	8111f238 <vResetMemCCDFEE>

				/* Wait until both buffers are empty  */
				while ( (bFeebGetCh1LeftBufferEmpty()== FALSE) || (bFeebGetCh1RightBufferEmpty()== FALSE)  ) {}
8110e700:	0001883a 	nop
8110e704:	11064580 	call	81106458 <bFeebGetCh1LeftBufferEmpty>
8110e708:	103ffe26 	beq	r2,zero,8110e704 <__reset+0xfb0ee704>
8110e70c:	11064c00 	call	811064c0 <bFeebGetCh1RightBufferEmpty>
8110e710:	103ffc26 	beq	r2,zero,8110e704 <__reset+0xfb0ee704>

				OSTimeDlyHMSM(0,0,0,xDefaults.usiGuardNFEEDelay);
8110e714:	00a045b4 	movhi	r2,33046
8110e718:	109fe204 	addi	r2,r2,32648
8110e71c:	10800e8b 	ldhu	r2,58(r2)
8110e720:	10bfffcc 	andi	r2,r2,65535
8110e724:	100f883a 	mov	r7,r2
8110e728:	000d883a 	mov	r6,zero
8110e72c:	000b883a 	mov	r5,zero
8110e730:	0009883a 	mov	r4,zero
8110e734:	1141d640 	call	81141d64 <OSTimeDlyHMSM>

				if (xDefaults.usiLinkNFEE0 == 0) {
8110e738:	00a045b4 	movhi	r2,33046
8110e73c:	109fe204 	addi	r2,r2,32648
8110e740:	10800d0b 	ldhu	r2,52(r2)
8110e744:	10bfffcc 	andi	r2,r2,65535
8110e748:	1000071e 	bne	r2,zero,8110e768 <vFeeTask+0xc40>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110e74c:	000b883a 	mov	r5,zero
8110e750:	01000404 	movi	r4,16
8110e754:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110e758:	01400044 	movi	r5,1
8110e75c:	01000404 	movi	r4,16
8110e760:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
8110e764:	00000606 	br	8110e780 <vFeeTask+0xc58>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110e768:	000b883a 	mov	r5,zero
8110e76c:	01000404 	movi	r4,16
8110e770:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110e774:	01400044 	movi	r5,1
8110e778:	01000404 	movi	r4,16
8110e77c:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
				}

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e780:	d0a05317 	ldw	r2,-32436(gp)
8110e784:	10803b04 	addi	r2,r2,236
8110e788:	1009883a 	mov	r4,r2
8110e78c:	1110f580 	call	81110f58 <bEnableDbBuffer>

				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110e790:	d0a05317 	ldw	r2,-32436(gp)
8110e794:	10808904 	addi	r2,r2,548
8110e798:	1009883a 	mov	r4,r2
8110e79c:	110a4a00 	call	8110a4a0 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
8110e7a0:	d0a05317 	ldw	r2,-32436(gp)
8110e7a4:	10809543 	ldbu	r2,597(r2)
8110e7a8:	10803fcc 	andi	r2,r2,255
8110e7ac:	d0a05515 	stw	r2,-32428(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
8110e7b0:	d0a05517 	ldw	r2,-32428(gp)
8110e7b4:	10800044 	addi	r2,r2,1
8110e7b8:	108000cc 	andi	r2,r2,3
8110e7bc:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8110e7c0:	e0bffc17 	ldw	r2,-16(fp)
8110e7c4:	10000e1e 	bne	r2,zero,8110e800 <vFeeTask+0xcd8>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110e7c8:	d0a05317 	ldw	r2,-32436(gp)
8110e7cc:	10802917 	ldw	r2,164(r2)
8110e7d0:	10800003 	ldbu	r2,0(r2)
8110e7d4:	10803fcc 	andi	r2,r2,255
8110e7d8:	10c00044 	addi	r3,r2,1
8110e7dc:	00a00034 	movhi	r2,32768
8110e7e0:	10800044 	addi	r2,r2,1
8110e7e4:	1884703a 	and	r2,r3,r2
8110e7e8:	1000040e 	bge	r2,zero,8110e7fc <vFeeTask+0xcd4>
8110e7ec:	10bfffc4 	addi	r2,r2,-1
8110e7f0:	00ffff84 	movi	r3,-2
8110e7f4:	10c4b03a 	or	r2,r2,r3
8110e7f8:	10800044 	addi	r2,r2,1
8110e7fc:	e0bff405 	stb	r2,-48(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110e800:	d0e05317 	ldw	r3,-32436(gp)
8110e804:	e0bffc17 	ldw	r2,-16(fp)
8110e808:	1885883a 	add	r2,r3,r2
8110e80c:	10802a44 	addi	r2,r2,169
8110e810:	10800003 	ldbu	r2,0(r2)
8110e814:	e0bff605 	stb	r2,-40(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110e818:	d0a05317 	ldw	r2,-32436(gp)
8110e81c:	10802e17 	ldw	r2,184(r2)
8110e820:	1000071e 	bne	r2,zero,8110e840 <vFeeTask+0xd18>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110e824:	d0e05317 	ldw	r3,-32436(gp)
8110e828:	e0bff603 	ldbu	r2,-40(fp)
8110e82c:	10800624 	muli	r2,r2,24
8110e830:	10800904 	addi	r2,r2,36
8110e834:	1885883a 	add	r2,r3,r2
8110e838:	e0bff515 	stw	r2,-44(fp)
8110e83c:	00000606 	br	8110e858 <vFeeTask+0xd30>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110e840:	d0e05317 	ldw	r3,-32436(gp)
8110e844:	e0bff603 	ldbu	r2,-40(fp)
8110e848:	10800624 	muli	r2,r2,24
8110e84c:	10800c04 	addi	r2,r2,48
8110e850:	1885883a 	add	r2,r3,r2
8110e854:	e0bff515 	stw	r2,-44(fp)

				ucIterationSide = pxNFee->xControl.eSide;
8110e858:	d0a05317 	ldw	r2,-32436(gp)
8110e85c:	10802e17 	ldw	r2,184(r2)
8110e860:	d0a05605 	stb	r2,-32424(gp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e864:	d0a05317 	ldw	r2,-32436(gp)
8110e868:	10803304 	addi	r2,r2,204
8110e86c:	1009883a 	mov	r4,r2
8110e870:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110e874:	d0a05317 	ldw	r2,-32436(gp)
8110e878:	e0fff603 	ldbu	r3,-40(fp)
8110e87c:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern;
8110e880:	d0a05317 	ldw	r2,-32436(gp)
8110e884:	00c00044 	movi	r3,1
8110e888:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e88c:	d0a05317 	ldw	r2,-32436(gp)
8110e890:	10803304 	addi	r2,r2,204
8110e894:	1009883a 	mov	r4,r2
8110e898:	11048400 	call	81104840 <bDpktSetPacketConfig>


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e89c:	d0a05317 	ldw	r2,-32436(gp)
8110e8a0:	10803304 	addi	r2,r2,204
8110e8a4:	1009883a 	mov	r4,r2
8110e8a8:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110e8ac:	00a045b4 	movhi	r2,33046
8110e8b0:	109fe204 	addi	r2,r2,32648
8110e8b4:	10800d8b 	ldhu	r2,54(r2)
8110e8b8:	10bfffcc 	andi	r2,r2,65535
8110e8bc:	108000e8 	cmpgeui	r2,r2,3
8110e8c0:	10004d1e 	bne	r2,zero,8110e9f8 <vFeeTask+0xed0>
					fprintf(fp,"\n\n=========DATA PACKET=============\n");
8110e8c4:	d0a06217 	ldw	r2,-32376(gp)
8110e8c8:	100f883a 	mov	r7,r2
8110e8cc:	01800904 	movi	r6,36
8110e8d0:	01400044 	movi	r5,1
8110e8d4:	01204574 	movhi	r4,33045
8110e8d8:	21368f04 	addi	r4,r4,-9668
8110e8dc:	1122fc80 	call	81122fc8 <fwrite>
					fprintf(fp,"usiCcdXSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize);
8110e8e0:	d0e06217 	ldw	r3,-32376(gp)
8110e8e4:	d0a05317 	ldw	r2,-32436(gp)
8110e8e8:	1080340b 	ldhu	r2,208(r2)
8110e8ec:	10bfffcc 	andi	r2,r2,65535
8110e8f0:	100d883a 	mov	r6,r2
8110e8f4:	01604574 	movhi	r5,33045
8110e8f8:	29769904 	addi	r5,r5,-9628
8110e8fc:	1809883a 	mov	r4,r3
8110e900:	112292c0 	call	8112292c <fprintf>
					fprintf(fp,"usiCcdYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize);
8110e904:	d0e06217 	ldw	r3,-32376(gp)
8110e908:	d0a05317 	ldw	r2,-32436(gp)
8110e90c:	1080348b 	ldhu	r2,210(r2)
8110e910:	10bfffcc 	andi	r2,r2,65535
8110e914:	100d883a 	mov	r6,r2
8110e918:	01604574 	movhi	r5,33045
8110e91c:	29769e04 	addi	r5,r5,-9608
8110e920:	1809883a 	mov	r4,r3
8110e924:	112292c0 	call	8112292c <fprintf>
					fprintf(fp,"usiDataYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize);
8110e928:	d0e06217 	ldw	r3,-32376(gp)
8110e92c:	d0a05317 	ldw	r2,-32436(gp)
8110e930:	1080350b 	ldhu	r2,212(r2)
8110e934:	10bfffcc 	andi	r2,r2,65535
8110e938:	100d883a 	mov	r6,r2
8110e93c:	01604574 	movhi	r5,33045
8110e940:	2976a304 	addi	r5,r5,-9588
8110e944:	1809883a 	mov	r4,r3
8110e948:	112292c0 	call	8112292c <fprintf>
					fprintf(fp,"usiOverscanYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize);
8110e94c:	d0e06217 	ldw	r3,-32376(gp)
8110e950:	d0a05317 	ldw	r2,-32436(gp)
8110e954:	1080358b 	ldhu	r2,214(r2)
8110e958:	10bfffcc 	andi	r2,r2,65535
8110e95c:	100d883a 	mov	r6,r2
8110e960:	01604574 	movhi	r5,33045
8110e964:	2976a804 	addi	r5,r5,-9568
8110e968:	1809883a 	mov	r4,r3
8110e96c:	112292c0 	call	8112292c <fprintf>
					fprintf(fp,"usiPacketLength %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength);
8110e970:	d0e06217 	ldw	r3,-32376(gp)
8110e974:	d0a05317 	ldw	r2,-32436(gp)
8110e978:	1080360b 	ldhu	r2,216(r2)
8110e97c:	10bfffcc 	andi	r2,r2,65535
8110e980:	100d883a 	mov	r6,r2
8110e984:	01604574 	movhi	r5,33045
8110e988:	2976ae04 	addi	r5,r5,-9544
8110e98c:	1809883a 	mov	r4,r3
8110e990:	112292c0 	call	8112292c <fprintf>
					fprintf(fp,"ucCcdNumber %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber);
8110e994:	d0e06217 	ldw	r3,-32376(gp)
8110e998:	d0a05317 	ldw	r2,-32436(gp)
8110e99c:	108036c3 	ldbu	r2,219(r2)
8110e9a0:	10803fcc 	andi	r2,r2,255
8110e9a4:	100d883a 	mov	r6,r2
8110e9a8:	01604574 	movhi	r5,33045
8110e9ac:	2976b404 	addi	r5,r5,-9520
8110e9b0:	1809883a 	mov	r4,r3
8110e9b4:	112292c0 	call	8112292c <fprintf>
					fprintf(fp,"ucFeeMode %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode);
8110e9b8:	d0e06217 	ldw	r3,-32376(gp)
8110e9bc:	d0a05317 	ldw	r2,-32436(gp)
8110e9c0:	10803683 	ldbu	r2,218(r2)
8110e9c4:	10803fcc 	andi	r2,r2,255
8110e9c8:	100d883a 	mov	r6,r2
8110e9cc:	01604574 	movhi	r5,33045
8110e9d0:	2976b904 	addi	r5,r5,-9500
8110e9d4:	1809883a 	mov	r4,r3
8110e9d8:	112292c0 	call	8112292c <fprintf>
					fprintf(fp,"=========DATA PACKET=============\n");
8110e9dc:	d0a06217 	ldw	r2,-32376(gp)
8110e9e0:	100f883a 	mov	r7,r2
8110e9e4:	01800884 	movi	r6,34
8110e9e8:	01400044 	movi	r5,1
8110e9ec:	01204574 	movhi	r4,33045
8110e9f0:	2136bd04 	addi	r4,r4,-9484
8110e9f4:	1122fc80 	call	81122fc8 <fwrite>
				}
				#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110e9f8:	d0a05317 	ldw	r2,-32436(gp)
8110e9fc:	10800003 	ldbu	r2,0(r2)
8110ea00:	10803fcc 	andi	r2,r2,255
8110ea04:	100d883a 	mov	r6,r2
8110ea08:	000b883a 	mov	r5,zero
8110ea0c:	01002004 	movi	r4,128
8110ea10:	111105c0 	call	8111105c <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8110ea14:	e03ff815 	stw	zero,-32(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ea18:	d0a05317 	ldw	r2,-32436(gp)
8110ea1c:	10800003 	ldbu	r2,0(r2)
8110ea20:	10803fcc 	andi	r2,r2,255
8110ea24:	1085883a 	add	r2,r2,r2
8110ea28:	1087883a 	add	r3,r2,r2
8110ea2c:	d0a06a04 	addi	r2,gp,-32344
8110ea30:	1885883a 	add	r2,r3,r2
8110ea34:	10800017 	ldw	r2,0(r2)
8110ea38:	e0fffd04 	addi	r3,fp,-12
8110ea3c:	180d883a 	mov	r6,r3
8110ea40:	000b883a 	mov	r5,zero
8110ea44:	1009883a 	mov	r4,r2
8110ea48:	113eed40 	call	8113eed4 <OSQPend>
8110ea4c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ea50:	e0bffd03 	ldbu	r2,-12(fp)
8110ea54:	10803fcc 	andi	r2,r2,255
8110ea58:	10005e1e 	bne	r2,zero,8110ebd4 <vFeeTask+0x10ac>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110ea5c:	e0bffe83 	ldbu	r2,-6(fp)
8110ea60:	10803fcc 	andi	r2,r2,255
8110ea64:	108023d8 	cmpnei	r2,r2,143
8110ea68:	1000541e 	bne	r2,zero,8110ebbc <vFeeTask+0x1094>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110ea6c:	e0fff403 	ldbu	r3,-48(fp)
8110ea70:	00a045b4 	movhi	r2,33046
8110ea74:	10932604 	addi	r2,r2,19608
8110ea78:	180690fa 	slli	r3,r3,3
8110ea7c:	10c5883a 	add	r2,r2,r3
8110ea80:	10800017 	ldw	r2,0(r2)
8110ea84:	e0fffd04 	addi	r3,fp,-12
8110ea88:	180d883a 	mov	r6,r3
8110ea8c:	000b883a 	mov	r5,zero
8110ea90:	1009883a 	mov	r4,r2
8110ea94:	113ddc00 	call	8113ddc0 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110ea98:	e0bffd03 	ldbu	r2,-12(fp)
8110ea9c:	10803fcc 	andi	r2,r2,255
8110eaa0:	1000181e 	bne	r2,zero,8110eb04 <vFeeTask+0xfdc>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110eaa4:	d0a05317 	ldw	r2,-32436(gp)
8110eaa8:	00c00044 	movi	r3,1
8110eaac:	10c02215 	stw	r3,136(r2)

							bDmaReturn = bPrepareDoubleBuffer( xCcdMapLocal, ucMemUsing, pxNFee->ucId, pxNFee );
8110eab0:	e0fff403 	ldbu	r3,-48(fp)
8110eab4:	d0a05317 	ldw	r2,-32436(gp)
8110eab8:	10800003 	ldbu	r2,0(r2)
8110eabc:	10803fcc 	andi	r2,r2,255
8110eac0:	d1205317 	ldw	r4,-32436(gp)
8110eac4:	200f883a 	mov	r7,r4
8110eac8:	100d883a 	mov	r6,r2
8110eacc:	180b883a 	mov	r5,r3
8110ead0:	e13ff517 	ldw	r4,-44(fp)
8110ead4:	1111b0c0 	call	81111b0c <bPrepareDoubleBuffer>
8110ead8:	e0bff815 	stw	r2,-32(fp)
							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110eadc:	e0fff403 	ldbu	r3,-48(fp)
8110eae0:	00a045b4 	movhi	r2,33046
8110eae4:	10932604 	addi	r2,r2,19608
8110eae8:	180690fa 	slli	r3,r3,3
8110eaec:	10c5883a 	add	r2,r2,r3
8110eaf0:	10800017 	ldw	r2,0(r2)
8110eaf4:	1009883a 	mov	r4,r2
8110eaf8:	113e3640 	call	8113e364 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8110eafc:	d0a05317 	ldw	r2,-32436(gp)
8110eb00:	10002215 	stw	zero,136(r2)
		
						}
						/* Send message telling to controller that is not using the DMA any more */
						bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);							
8110eb04:	d0a05317 	ldw	r2,-32436(gp)
8110eb08:	10800003 	ldbu	r2,0(r2)
8110eb0c:	10803fcc 	andi	r2,r2,255
8110eb10:	100d883a 	mov	r6,r2
8110eb14:	000b883a 	mov	r5,zero
8110eb18:	01002044 	movi	r4,129
8110eb1c:	11111000 	call	81111100 <bSendGiveBackNFeeCtrl>

						if ( bDmaReturn == TRUE ) {
8110eb20:	e0bff817 	ldw	r2,-32(fp)
8110eb24:	10800058 	cmpnei	r2,r2,1
8110eb28:	1000141e 	bne	r2,zero,8110eb7c <vFeeTask+0x1054>
							if (pxNFee->xControl.bWatingSync==TRUE) {
8110eb2c:	d0a05317 	ldw	r2,-32436(gp)
8110eb30:	10802817 	ldw	r2,160(r2)
8110eb34:	10800058 	cmpnei	r2,r2,1
8110eb38:	1000071e 	bne	r2,zero,8110eb58 <vFeeTask+0x1030>
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110eb3c:	d0a05317 	ldw	r2,-32436(gp)
8110eb40:	00c001c4 	movi	r3,7
8110eb44:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sFeeWaitingSync;
8110eb48:	d0a05317 	ldw	r2,-32436(gp)
8110eb4c:	00c00304 	movi	r3,12
8110eb50:	10c02c15 	stw	r3,176(r2)
8110eb54:	00000606 	br	8110eb70 <vFeeTask+0x1048>
							} else {
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110eb58:	d0a05317 	ldw	r2,-32436(gp)
8110eb5c:	00c001c4 	movi	r3,7
8110eb60:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sToTestFullPattern;
8110eb64:	d0a05317 	ldw	r2,-32436(gp)
8110eb68:	00c001c4 	movi	r3,7
8110eb6c:	10c02c15 	stw	r3,176(r2)
							}
							incrementador++;
8110eb70:	d0a05417 	ldw	r2,-32432(gp)
8110eb74:	10800044 	addi	r2,r2,1
8110eb78:	d0a05415 	stw	r2,-32432(gp)
						}

						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110eb7c:	00a045b4 	movhi	r2,33046
8110eb80:	109fe204 	addi	r2,r2,32648
8110eb84:	10800d8b 	ldhu	r2,54(r2)
8110eb88:	10bfffcc 	andi	r2,r2,65535
8110eb8c:	10800168 	cmpgeui	r2,r2,5
8110eb90:	1001c31e 	bne	r2,zero,8110f2a0 <vFeeTask+0x1778>
							fprintf(fp,"\nNFEE-%hu Task: Double buffer prepared\n", pxNFee->ucId);
8110eb94:	d0e06217 	ldw	r3,-32376(gp)
8110eb98:	d0a05317 	ldw	r2,-32436(gp)
8110eb9c:	10800003 	ldbu	r2,0(r2)
8110eba0:	10803fcc 	andi	r2,r2,255
8110eba4:	100d883a 	mov	r6,r2
8110eba8:	01604574 	movhi	r5,33045
8110ebac:	2976c604 	addi	r5,r5,-9448
8110ebb0:	1809883a 	mov	r4,r3
8110ebb4:	112292c0 	call	8112292c <fprintf>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8110ebb8:	0001b906 	br	8110f2a0 <vFeeTask+0x1778>
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
							fprintf(fp,"\nNFEE-%hu Task: Double buffer prepared\n", pxNFee->ucId);
						}
						#endif
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110ebbc:	d0a05317 	ldw	r2,-32436(gp)
8110ebc0:	e0fffe17 	ldw	r3,-8(fp)
8110ebc4:	180b883a 	mov	r5,r3
8110ebc8:	1009883a 	mov	r4,r2
8110ebcc:	110f9780 	call	8110f978 <vQCmdFEEinFullPattern>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8110ebd0:	0001b306 	br	8110f2a0 <vFeeTask+0x1778>
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
					}
				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110ebd4:	00a045b4 	movhi	r2,33046
8110ebd8:	109fe204 	addi	r2,r2,32648
8110ebdc:	10800d8b 	ldhu	r2,54(r2)
8110ebe0:	10bfffcc 	andi	r2,r2,65535
8110ebe4:	10800228 	cmpgeui	r2,r2,8
8110ebe8:	1001ad1e 	bne	r2,zero,8110f2a0 <vFeeTask+0x1778>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110ebec:	d0e06217 	ldw	r3,-32376(gp)
8110ebf0:	d0a05317 	ldw	r2,-32436(gp)
8110ebf4:	10800003 	ldbu	r2,0(r2)
8110ebf8:	10803fcc 	andi	r2,r2,255
8110ebfc:	100d883a 	mov	r6,r2
8110ec00:	01604574 	movhi	r5,33045
8110ec04:	29767d04 	addi	r5,r5,-9740
8110ec08:	1809883a 	mov	r4,r3
8110ec0c:	112292c0 	call	8112292c <fprintf>
					}
					#endif
				}	
				break;
8110ec10:	0001a306 	br	8110f2a0 <vFeeTask+0x1778>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
8110ec14:	e03ff915 	stw	zero,-28(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ec18:	d0a05317 	ldw	r2,-32436(gp)
8110ec1c:	10804304 	addi	r2,r2,268
8110ec20:	1009883a 	mov	r4,r2
8110ec24:	11080940 	call	81108094 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8110ec28:	d0a05317 	ldw	r2,-32436(gp)
8110ec2c:	00c00084 	movi	r3,2
8110ec30:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ec34:	d0a05317 	ldw	r2,-32436(gp)
8110ec38:	10804304 	addi	r2,r2,268
8110ec3c:	1009883a 	mov	r4,r2
8110ec40:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110ec44:	00a045b4 	movhi	r2,33046
8110ec48:	109fe204 	addi	r2,r2,32648
8110ec4c:	10800d8b 	ldhu	r2,54(r2)
8110ec50:	10bfffcc 	andi	r2,r2,65535
8110ec54:	108000e8 	cmpgeui	r2,r2,3
8110ec58:	1000091e 	bne	r2,zero,8110ec80 <vFeeTask+0x1158>
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110ec5c:	d0e06217 	ldw	r3,-32376(gp)
8110ec60:	d0a05317 	ldw	r2,-32436(gp)
8110ec64:	10800003 	ldbu	r2,0(r2)
8110ec68:	10803fcc 	andi	r2,r2,255
8110ec6c:	100d883a 	mov	r6,r2
8110ec70:	01604574 	movhi	r5,33045
8110ec74:	2976d004 	addi	r5,r5,-9408
8110ec78:	1809883a 	mov	r4,r3
8110ec7c:	112292c0 	call	8112292c <fprintf>
				}
				#endif

				ucIterationSide = pxNFee->xControl.eSide;
8110ec80:	d0a05317 	ldw	r2,-32436(gp)
8110ec84:	10802e17 	ldw	r2,184(r2)
8110ec88:	d0a05605 	stb	r2,-32424(gp)

				pxNFee->xControl.bUsingDMA = TRUE;
8110ec8c:	d0a05317 	ldw	r2,-32436(gp)
8110ec90:	00c00044 	movi	r3,1
8110ec94:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110ec98:	d0a05317 	ldw	r2,-32436(gp)
8110ec9c:	00c00104 	movi	r3,4
8110eca0:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
8110eca4:	d0a05317 	ldw	r2,-32436(gp)
8110eca8:	00c00104 	movi	r3,4
8110ecac:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8110ecb0:	d0a05317 	ldw	r2,-32436(gp)
8110ecb4:	00c00044 	movi	r3,1
8110ecb8:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110ecbc:	d0a05317 	ldw	r2,-32436(gp)
8110ecc0:	00c00044 	movi	r3,1
8110ecc4:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110ecc8:	d0a05317 	ldw	r2,-32436(gp)
8110eccc:	00c00044 	movi	r3,1
8110ecd0:	10c02115 	stw	r3,132(r2)
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110ecd4:	d0a05317 	ldw	r2,-32436(gp)
8110ecd8:	10800003 	ldbu	r2,0(r2)
8110ecdc:	10803fcc 	andi	r2,r2,255
8110ece0:	100d883a 	mov	r6,r2
8110ece4:	000b883a 	mov	r5,zero
8110ece8:	01002004 	movi	r4,128
8110ecec:	111105c0 	call	8111105c <bSendRequestNFeeCtrl>

				if (xDefaults.usiLinkNFEE0 == 0) {
8110ecf0:	00a045b4 	movhi	r2,33046
8110ecf4:	109fe204 	addi	r2,r2,32648
8110ecf8:	10800d0b 	ldhu	r2,52(r2)
8110ecfc:	10bfffcc 	andi	r2,r2,65535
8110ed00:	1000071e 	bne	r2,zero,8110ed20 <vFeeTask+0x11f8>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110ed04:	000b883a 	mov	r5,zero
8110ed08:	01000404 	movi	r4,16
8110ed0c:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110ed10:	01400044 	movi	r5,1
8110ed14:	01000404 	movi	r4,16
8110ed18:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				}

				break;
8110ed1c:	00016706 	br	8110f2bc <vFeeTask+0x1794>

				if (xDefaults.usiLinkNFEE0 == 0) {
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110ed20:	000b883a 	mov	r5,zero
8110ed24:	01000404 	movi	r4,16
8110ed28:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110ed2c:	01400044 	movi	r5,1
8110ed30:	01000404 	movi	r4,16
8110ed34:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
				}

				break;
8110ed38:	00016006 	br	8110f2bc <vFeeTask+0x1794>

			case sFeeTestFullPattern: /* Real mode */
				bFinal = FALSE;
8110ed3c:	e03ff915 	stw	zero,-28(fp)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ed40:	d0a05317 	ldw	r2,-32436(gp)
8110ed44:	10800003 	ldbu	r2,0(r2)
8110ed48:	10803fcc 	andi	r2,r2,255
8110ed4c:	1085883a 	add	r2,r2,r2
8110ed50:	1087883a 	add	r3,r2,r2
8110ed54:	d0a06a04 	addi	r2,gp,-32344
8110ed58:	1885883a 	add	r2,r3,r2
8110ed5c:	10800017 	ldw	r2,0(r2)
8110ed60:	e0fffd04 	addi	r3,fp,-12
8110ed64:	180d883a 	mov	r6,r3
8110ed68:	000b883a 	mov	r5,zero
8110ed6c:	1009883a 	mov	r4,r2
8110ed70:	113eed40 	call	8113eed4 <OSQPend>
8110ed74:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ed78:	e0bffd03 	ldbu	r2,-12(fp)
8110ed7c:	10803fcc 	andi	r2,r2,255
8110ed80:	1000a21e 	bne	r2,zero,8110f00c <vFeeTask+0x14e4>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110ed84:	e0bffe83 	ldbu	r2,-6(fp)
8110ed88:	10803fcc 	andi	r2,r2,255
8110ed8c:	108023d8 	cmpnei	r2,r2,143
8110ed90:	1000911e 	bne	r2,zero,8110efd8 <vFeeTask+0x14b0>

						/* Try to get the Mutex */
						OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110ed94:	e0fff403 	ldbu	r3,-48(fp)
8110ed98:	00a045b4 	movhi	r2,33046
8110ed9c:	10932604 	addi	r2,r2,19608
8110eda0:	180690fa 	slli	r3,r3,3
8110eda4:	10c5883a 	add	r2,r2,r3
8110eda8:	10800017 	ldw	r2,0(r2)
8110edac:	e0fffd04 	addi	r3,fp,-12
8110edb0:	180d883a 	mov	r6,r3
8110edb4:	000b883a 	mov	r5,zero
8110edb8:	1009883a 	mov	r4,r2
8110edbc:	113ddc00 	call	8113ddc0 <OSMutexPend>
						if ( error_code == OS_ERR_NONE ) {
8110edc0:	e0bffd03 	ldbu	r2,-12(fp)
8110edc4:	10803fcc 	andi	r2,r2,255
8110edc8:	1001371e 	bne	r2,zero,8110f2a8 <vFeeTask+0x1780>
							pxNFee->xControl.bDMALocked = TRUE;
8110edcc:	d0a05317 	ldw	r2,-32436(gp)
8110edd0:	00c00044 	movi	r3,1
8110edd4:	10c02215 	stw	r3,136(r2)

							/* Is this the last block? */
							if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110edd8:	e0bff517 	ldw	r2,-44(fp)
8110eddc:	10800117 	ldw	r2,4(r2)
8110ede0:	10c00404 	addi	r3,r2,16
8110ede4:	d0a05317 	ldw	r2,-32436(gp)
8110ede8:	10800417 	ldw	r2,16(r2)
8110edec:	18802336 	bltu	r3,r2,8110ee7c <vFeeTask+0x1354>

								/*Define the size of the data in the double buffer (need this to create the interrupt right)*/
								usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110edf0:	d0a05317 	ldw	r2,-32436(gp)
8110edf4:	10c00417 	ldw	r3,16(r2)
8110edf8:	e0bff517 	ldw	r2,-44(fp)
8110edfc:	10800117 	ldw	r2,4(r2)
8110ee00:	1885c83a 	sub	r2,r3,r2
8110ee04:	e0bff715 	stw	r2,-36(fp)

								if (xDefaults.usiLinkNFEE0 == 0) {
8110ee08:	00a045b4 	movhi	r2,33046
8110ee0c:	109fe204 	addi	r2,r2,32648
8110ee10:	10800d0b 	ldhu	r2,52(r2)
8110ee14:	10bfffcc 	andi	r2,r2,65535
8110ee18:	10000b1e 	bne	r2,zero,8110ee48 <vFeeTask+0x1320>
									bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,0);
8110ee1c:	e0bff717 	ldw	r2,-36(fp)
8110ee20:	10803fcc 	andi	r2,r2,255
8110ee24:	000b883a 	mov	r5,zero
8110ee28:	1009883a 	mov	r4,r2
8110ee2c:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
									bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,1);
8110ee30:	e0bff717 	ldw	r2,-36(fp)
8110ee34:	10803fcc 	andi	r2,r2,255
8110ee38:	01400044 	movi	r5,1
8110ee3c:	1009883a 	mov	r4,r2
8110ee40:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
8110ee44:	00000a06 	br	8110ee70 <vFeeTask+0x1348>
								} else {
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,0);
8110ee48:	e0bff717 	ldw	r2,-36(fp)
8110ee4c:	10803fcc 	andi	r2,r2,255
8110ee50:	000b883a 	mov	r5,zero
8110ee54:	1009883a 	mov	r4,r2
8110ee58:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
8110ee5c:	e0bff717 	ldw	r2,-36(fp)
8110ee60:	10803fcc 	andi	r2,r2,255
8110ee64:	01400044 	movi	r5,1
8110ee68:	1009883a 	mov	r4,r2
8110ee6c:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
								}

								bFinal = TRUE;
8110ee70:	00800044 	movi	r2,1
8110ee74:	e0bff915 	stw	r2,-28(fp)
8110ee78:	00000206 	br	8110ee84 <vFeeTask+0x135c>

							} else {
								usiLengthBlocks = SDMA_MAX_BLOCKS;
8110ee7c:	00800404 	movi	r2,16
8110ee80:	e0bff715 	stw	r2,-36(fp)
							}


							if ( ucMemUsing == 0  ) {
8110ee84:	e0bff403 	ldbu	r2,-48(fp)
8110ee88:	1000111e 	bne	r2,zero,8110eed0 <vFeeTask+0x13a8>
								bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110ee8c:	e0bff517 	ldw	r2,-44(fp)
8110ee90:	10800217 	ldw	r2,8(r2)
8110ee94:	1011883a 	mov	r8,r2
8110ee98:	e0bff717 	ldw	r2,-36(fp)
8110ee9c:	10ffffcc 	andi	r3,r2,65535
8110eea0:	d0a05603 	ldbu	r2,-32424(gp)
8110eea4:	11003fcc 	andi	r4,r2,255
8110eea8:	d0a05317 	ldw	r2,-32436(gp)
8110eeac:	10800043 	ldbu	r2,1(r2)
8110eeb0:	10803fcc 	andi	r2,r2,255
8110eeb4:	100f883a 	mov	r7,r2
8110eeb8:	200d883a 	mov	r6,r4
8110eebc:	180b883a 	mov	r5,r3
8110eec0:	4009883a 	mov	r4,r8
8110eec4:	1103cb00 	call	81103cb0 <bSdmaDmaM1Transfer>
8110eec8:	e0bff815 	stw	r2,-32(fp)
8110eecc:	00001006 	br	8110ef10 <vFeeTask+0x13e8>
							} else {
								bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110eed0:	e0bff517 	ldw	r2,-44(fp)
8110eed4:	10800217 	ldw	r2,8(r2)
8110eed8:	1011883a 	mov	r8,r2
8110eedc:	e0bff717 	ldw	r2,-36(fp)
8110eee0:	10ffffcc 	andi	r3,r2,65535
8110eee4:	d0a05603 	ldbu	r2,-32424(gp)
8110eee8:	11003fcc 	andi	r4,r2,255
8110eeec:	d0a05317 	ldw	r2,-32436(gp)
8110eef0:	10800043 	ldbu	r2,1(r2)
8110eef4:	10803fcc 	andi	r2,r2,255
8110eef8:	100f883a 	mov	r7,r2
8110eefc:	200d883a 	mov	r6,r4
8110ef00:	180b883a 	mov	r5,r3
8110ef04:	4009883a 	mov	r4,r8
8110ef08:	11041040 	call	81104104 <bSdmaDmaM2Transfer>
8110ef0c:	e0bff815 	stw	r2,-32(fp)
							}

							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110ef10:	e0fff403 	ldbu	r3,-48(fp)
8110ef14:	00a045b4 	movhi	r2,33046
8110ef18:	10932604 	addi	r2,r2,19608
8110ef1c:	180690fa 	slli	r3,r3,3
8110ef20:	10c5883a 	add	r2,r2,r3
8110ef24:	10800017 	ldw	r2,0(r2)
8110ef28:	1009883a 	mov	r4,r2
8110ef2c:	113e3640 	call	8113e364 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8110ef30:	d0a05317 	ldw	r2,-32436(gp)
8110ef34:	10002215 	stw	zero,136(r2)

							if ( bDmaReturn == TRUE ) {
8110ef38:	e0bff817 	ldw	r2,-32(fp)
8110ef3c:	10800058 	cmpnei	r2,r2,1
8110ef40:	10000e1e 	bne	r2,zero,8110ef7c <vFeeTask+0x1454>
								/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
								xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*usiLengthBlocks;
8110ef44:	e0bff517 	ldw	r2,-44(fp)
8110ef48:	10c00217 	ldw	r3,8(r2)
8110ef4c:	e0bff717 	ldw	r2,-36(fp)
8110ef50:	10802224 	muli	r2,r2,136
8110ef54:	1887883a 	add	r3,r3,r2
8110ef58:	e0bff517 	ldw	r2,-44(fp)
8110ef5c:	10c00215 	stw	r3,8(r2)
								xCcdMapLocal->ulBlockI += usiLengthBlocks;
8110ef60:	e0bff517 	ldw	r2,-44(fp)
8110ef64:	10c00117 	ldw	r3,4(r2)
8110ef68:	e0bff717 	ldw	r2,-36(fp)
8110ef6c:	1887883a 	add	r3,r3,r2
8110ef70:	e0bff517 	ldw	r2,-44(fp)
8110ef74:	10c00115 	stw	r3,4(r2)
8110ef78:	00000106 	br	8110ef80 <vFeeTask+0x1458>
							} else {
								bFinal = FALSE;
8110ef7c:	e03ff915 	stw	zero,-28(fp)
							}

							/* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110ef80:	d0a05317 	ldw	r2,-32436(gp)
8110ef84:	10800003 	ldbu	r2,0(r2)
8110ef88:	10803fcc 	andi	r2,r2,255
8110ef8c:	100d883a 	mov	r6,r2
8110ef90:	000b883a 	mov	r5,zero
8110ef94:	01002044 	movi	r4,129
8110ef98:	11111000 	call	81111100 <bSendGiveBackNFeeCtrl>

							if ( bFinal == TRUE ) {
8110ef9c:	e0bff917 	ldw	r2,-28(fp)
8110efa0:	10800058 	cmpnei	r2,r2,1
8110efa4:	1000041e 	bne	r2,zero,8110efb8 <vFeeTask+0x1490>
								pxNFee->xControl.eMode = sEndTransmission;
8110efa8:	d0a05317 	ldw	r2,-32436(gp)
8110efac:	00c002c4 	movi	r3,11
8110efb0:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110efb4:	0000bc06 	br	8110f2a8 <vFeeTask+0x1780>
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);

							if ( bFinal == TRUE ) {
								pxNFee->xControl.eMode = sEndTransmission;
							} else {
								bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110efb8:	d0a05317 	ldw	r2,-32436(gp)
8110efbc:	10800003 	ldbu	r2,0(r2)
8110efc0:	10803fcc 	andi	r2,r2,255
8110efc4:	100d883a 	mov	r6,r2
8110efc8:	000b883a 	mov	r5,zero
8110efcc:	01002004 	movi	r4,128
8110efd0:	111105c0 	call	8111105c <bSendRequestNFeeCtrl>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110efd4:	0000b406 	br	8110f2a8 <vFeeTask+0x1780>
								bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
							}

						}
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110efd8:	d0a05317 	ldw	r2,-32436(gp)
8110efdc:	e0fffe17 	ldw	r3,-8(fp)
8110efe0:	180b883a 	mov	r5,r3
8110efe4:	1009883a 	mov	r4,r2
8110efe8:	110f9780 	call	8110f978 <vQCmdFEEinFullPattern>

						if ( pxNFee->xControl.bWatingSync == FALSE ) {
8110efec:	d0a05317 	ldw	r2,-32436(gp)
8110eff0:	10802817 	ldw	r2,160(r2)
8110eff4:	1000ac1e 	bne	r2,zero,8110f2a8 <vFeeTask+0x1780>
							pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110eff8:	d0a05317 	ldw	r2,-32436(gp)
8110effc:	d0e05317 	ldw	r3,-32436(gp)
8110f000:	18c02d17 	ldw	r3,180(r3)
8110f004:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f008:	0000a706 	br	8110f2a8 <vFeeTask+0x1780>
						}
					}

				} else {
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f00c:	00a045b4 	movhi	r2,33046
8110f010:	109fe204 	addi	r2,r2,32648
8110f014:	10800d8b 	ldhu	r2,54(r2)
8110f018:	10bfffcc 	andi	r2,r2,65535
8110f01c:	10800228 	cmpgeui	r2,r2,8
8110f020:	1000a11e 	bne	r2,zero,8110f2a8 <vFeeTask+0x1780>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110f024:	d0e06217 	ldw	r3,-32376(gp)
8110f028:	d0a05317 	ldw	r2,-32436(gp)
8110f02c:	10800003 	ldbu	r2,0(r2)
8110f030:	10803fcc 	andi	r2,r2,255
8110f034:	100d883a 	mov	r6,r2
8110f038:	01604574 	movhi	r5,33045
8110f03c:	29767d04 	addi	r5,r5,-9740
8110f040:	1809883a 	mov	r4,r3
8110f044:	112292c0 	call	8112292c <fprintf>
					}
					#endif
				}

				break;
8110f048:	00009706 	br	8110f2a8 <vFeeTask+0x1780>

			case sEndTransmission:

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f04c:	00a045b4 	movhi	r2,33046
8110f050:	109fe204 	addi	r2,r2,32648
8110f054:	10800d8b 	ldhu	r2,54(r2)
8110f058:	10bfffcc 	andi	r2,r2,65535
8110f05c:	10800168 	cmpgeui	r2,r2,5
8110f060:	1000121e 	bne	r2,zero,8110f0ac <vFeeTask+0x1584>
					fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu\n", pxNFee->ucId, ucReadout);
8110f064:	d0e06217 	ldw	r3,-32376(gp)
8110f068:	d0a05317 	ldw	r2,-32436(gp)
8110f06c:	10800003 	ldbu	r2,0(r2)
8110f070:	10803fcc 	andi	r2,r2,255
8110f074:	e13ff603 	ldbu	r4,-40(fp)
8110f078:	200f883a 	mov	r7,r4
8110f07c:	100d883a 	mov	r6,r2
8110f080:	01604574 	movhi	r5,33045
8110f084:	2976da04 	addi	r5,r5,-9368
8110f088:	1809883a 	mov	r4,r3
8110f08c:	112292c0 	call	8112292c <fprintf>
					fprintf(fp,"Memory used: %u\n", ucMemUsing);
8110f090:	d0a06217 	ldw	r2,-32376(gp)
8110f094:	e0fff403 	ldbu	r3,-48(fp)
8110f098:	180d883a 	mov	r6,r3
8110f09c:	01604574 	movhi	r5,33045
8110f0a0:	2976e504 	addi	r5,r5,-9324
8110f0a4:	1009883a 	mov	r4,r2
8110f0a8:	112292c0 	call	8112292c <fprintf>
				}
				#endif

				pxNFee->xControl.bWatingSync = TRUE;
8110f0ac:	d0a05317 	ldw	r2,-32436(gp)
8110f0b0:	00c00044 	movi	r3,1
8110f0b4:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110f0b8:	d0a05317 	ldw	r2,-32436(gp)
8110f0bc:	10002315 	stw	zero,140(r2)

				if ( xDefaults.bOneShot == FALSE ) {
8110f0c0:	00a045b4 	movhi	r2,33046
8110f0c4:	109fe204 	addi	r2,r2,32648
8110f0c8:	10800c17 	ldw	r2,48(r2)
8110f0cc:	1000201e 	bne	r2,zero,8110f150 <vFeeTask+0x1628>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
8110f0d0:	d0a05317 	ldw	r2,-32436(gp)
8110f0d4:	10802d17 	ldw	r2,180(r2)
8110f0d8:	10800198 	cmpnei	r2,r2,6
8110f0dc:	1000151e 	bne	r2,zero,8110f134 <vFeeTask+0x160c>

						bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110f0e0:	d0a05317 	ldw	r2,-32436(gp)
8110f0e4:	10803304 	addi	r2,r2,204
8110f0e8:	1009883a 	mov	r4,r2
8110f0ec:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110f0f0:	d0a05317 	ldw	r2,-32436(gp)
8110f0f4:	e0fff603 	ldbu	r3,-40(fp)
8110f0f8:	10c036c5 	stb	r3,219(r2)
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
8110f0fc:	d0a05317 	ldw	r2,-32436(gp)
8110f100:	00c00144 	movi	r3,5
8110f104:	10c03685 	stb	r3,218(r2)
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110f108:	d0a05317 	ldw	r2,-32436(gp)
8110f10c:	10803304 	addi	r2,r2,204
8110f110:	1009883a 	mov	r4,r2
8110f114:	11048400 	call	81104840 <bDpktSetPacketConfig>

						pxNFee->xControl.eMode =  sFeeWaitingSync;
8110f118:	d0a05317 	ldw	r2,-32436(gp)
8110f11c:	00c00304 	movi	r3,12
8110f120:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110f124:	d0a05317 	ldw	r2,-32436(gp)
8110f128:	00c00184 	movi	r3,6
8110f12c:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
8110f130:	00006206 	br	8110f2bc <vFeeTask+0x1794>
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);

						pxNFee->xControl.eMode =  sFeeWaitingSync;
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
					} else {
						pxNFee->xControl.eMode =  sNextPatternIteration;
8110f134:	d0a05317 	ldw	r2,-32436(gp)
8110f138:	00c00284 	movi	r3,10
8110f13c:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
8110f140:	d0a05317 	ldw	r2,-32436(gp)
8110f144:	00c00304 	movi	r3,12
8110f148:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
8110f14c:	00005b06 	br	8110f2bc <vFeeTask+0x1794>
						pxNFee->xControl.eMode =  sNextPatternIteration;
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
					}

				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
8110f150:	d0a05317 	ldw	r2,-32436(gp)
8110f154:	00c00304 	movi	r3,12
8110f158:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110f15c:	d0a05317 	ldw	r2,-32436(gp)
8110f160:	00c00184 	movi	r3,6
8110f164:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110f168:	00005406 	br	8110f2bc <vFeeTask+0x1794>

			case sFeeWaitingSync:

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f16c:	00a045b4 	movhi	r2,33046
8110f170:	109fe204 	addi	r2,r2,32648
8110f174:	10800d8b 	ldhu	r2,54(r2)
8110f178:	10bfffcc 	andi	r2,r2,65535
8110f17c:	10800168 	cmpgeui	r2,r2,5
8110f180:	1000091e 	bne	r2,zero,8110f1a8 <vFeeTask+0x1680>
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
8110f184:	d0e06217 	ldw	r3,-32376(gp)
8110f188:	d0a05317 	ldw	r2,-32436(gp)
8110f18c:	10800003 	ldbu	r2,0(r2)
8110f190:	10803fcc 	andi	r2,r2,255
8110f194:	100d883a 	mov	r6,r2
8110f198:	01604574 	movhi	r5,33045
8110f19c:	2976ea04 	addi	r5,r5,-9304
8110f1a0:	1809883a 	mov	r4,r3
8110f1a4:	112292c0 	call	8112292c <fprintf>
				}
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110f1a8:	d0a05317 	ldw	r2,-32436(gp)
8110f1ac:	10800003 	ldbu	r2,0(r2)
8110f1b0:	10803fcc 	andi	r2,r2,255
8110f1b4:	1085883a 	add	r2,r2,r2
8110f1b8:	1087883a 	add	r3,r2,r2
8110f1bc:	d0a06a04 	addi	r2,gp,-32344
8110f1c0:	1885883a 	add	r2,r3,r2
8110f1c4:	10800017 	ldw	r2,0(r2)
8110f1c8:	e0fffd04 	addi	r3,fp,-12
8110f1cc:	180d883a 	mov	r6,r3
8110f1d0:	000b883a 	mov	r5,zero
8110f1d4:	1009883a 	mov	r4,r2
8110f1d8:	113eed40 	call	8113eed4 <OSQPend>
8110f1dc:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8110f1e0:	e0bffd03 	ldbu	r2,-12(fp)
8110f1e4:	10803fcc 	andi	r2,r2,255
8110f1e8:	10001026 	beq	r2,zero,8110f22c <vFeeTask+0x1704>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f1ec:	00a045b4 	movhi	r2,33046
8110f1f0:	109fe204 	addi	r2,r2,32648
8110f1f4:	10800d8b 	ldhu	r2,54(r2)
8110f1f8:	10bfffcc 	andi	r2,r2,65535
8110f1fc:	10800228 	cmpgeui	r2,r2,8
8110f200:	10002b1e 	bne	r2,zero,8110f2b0 <vFeeTask+0x1788>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
8110f204:	d0e06217 	ldw	r3,-32376(gp)
8110f208:	d0a05317 	ldw	r2,-32436(gp)
8110f20c:	10800003 	ldbu	r2,0(r2)
8110f210:	10803fcc 	andi	r2,r2,255
8110f214:	100d883a 	mov	r6,r2
8110f218:	01604574 	movhi	r5,33045
8110f21c:	2976f304 	addi	r5,r5,-9268
8110f220:	1809883a 	mov	r4,r3
8110f224:	112292c0 	call	8112292c <fprintf>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110f228:	00002106 	br	8110f2b0 <vFeeTask+0x1788>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					}
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
8110f22c:	d0a05317 	ldw	r2,-32436(gp)
8110f230:	e0fffe17 	ldw	r3,-8(fp)
8110f234:	180b883a 	mov	r5,r3
8110f238:	1009883a 	mov	r4,r2
8110f23c:	110f2c00 	call	8110f2c0 <vQCmdFEEinWaitingSync>
				}

				break;
8110f240:	00001b06 	br	8110f2b0 <vFeeTask+0x1788>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110f244:	d0a05317 	ldw	r2,-32436(gp)
8110f248:	00c00144 	movi	r3,5
8110f24c:	10c02c15 	stw	r3,176(r2)
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f250:	00a045b4 	movhi	r2,33046
8110f254:	109fe204 	addi	r2,r2,32648
8110f258:	10800d8b 	ldhu	r2,54(r2)
8110f25c:	10bfffcc 	andi	r2,r2,65535
8110f260:	10800228 	cmpgeui	r2,r2,8
8110f264:	1000141e 	bne	r2,zero,8110f2b8 <vFeeTask+0x1790>
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110f268:	d0e06217 	ldw	r3,-32376(gp)
8110f26c:	d0a05317 	ldw	r2,-32436(gp)
8110f270:	10800003 	ldbu	r2,0(r2)
8110f274:	10803fcc 	andi	r2,r2,255
8110f278:	100d883a 	mov	r6,r2
8110f27c:	01604574 	movhi	r5,33045
8110f280:	29770404 	addi	r5,r5,-9200
8110f284:	1809883a 	mov	r4,r3
8110f288:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				break;
8110f28c:	00000a06 	br	8110f2b8 <vFeeTask+0x1790>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f290:	0001883a 	nop
8110f294:	003a4506 	br	8110dbac <__reset+0xfb0edbac>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f298:	0001883a 	nop
8110f29c:	003a4306 	br	8110dbac <__reset+0xfb0edbac>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8110f2a0:	0001883a 	nop
8110f2a4:	003a4106 	br	8110dbac <__reset+0xfb0edbac>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8110f2a8:	0001883a 	nop
8110f2ac:	003a3f06 	br	8110dbac <__reset+0xfb0edbac>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110f2b0:	0001883a 	nop
8110f2b4:	003a3d06 	br	8110dbac <__reset+0xfb0edbac>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				}
				#endif
				break;
8110f2b8:	0001883a 	nop
		}

	}
8110f2bc:	003a3b06 	br	8110dbac <__reset+0xfb0edbac>

8110f2c0 <vQCmdFEEinWaitingSync>:

}

void vQCmdFEEinWaitingSync( TNFee *pxNFeeP, unsigned int cmd ) {
8110f2c0:	defffb04 	addi	sp,sp,-20
8110f2c4:	de00012e 	bgeu	sp,et,8110f2cc <vQCmdFEEinWaitingSync+0xc>
8110f2c8:	003b68fa 	trap	3
8110f2cc:	dfc00415 	stw	ra,16(sp)
8110f2d0:	df000315 	stw	fp,12(sp)
8110f2d4:	df000304 	addi	fp,sp,12
8110f2d8:	e13ffe15 	stw	r4,-8(fp)
8110f2dc:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f2e0:	e0bfff17 	ldw	r2,-4(fp)
8110f2e4:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f2e8:	e0bffdc3 	ldbu	r2,-9(fp)
8110f2ec:	10c03fcc 	andi	r3,r2,255
8110f2f0:	e0bffe17 	ldw	r2,-8(fp)
8110f2f4:	10800003 	ldbu	r2,0(r2)
8110f2f8:	10803fcc 	andi	r2,r2,255
8110f2fc:	10800444 	addi	r2,r2,17
8110f300:	18806f1e 	bne	r3,r2,8110f4c0 <vQCmdFEEinWaitingSync+0x200>

		switch (uiCmdFEEL.ucByte[2]) {
8110f304:	e0bffd83 	ldbu	r2,-10(fp)
8110f308:	10803fcc 	andi	r2,r2,255
8110f30c:	10c02860 	cmpeqi	r3,r2,161
8110f310:	18001a1e 	bne	r3,zero,8110f37c <vQCmdFEEinWaitingSync+0xbc>
8110f314:	10c02888 	cmpgei	r3,r2,162
8110f318:	18000c1e 	bne	r3,zero,8110f34c <vQCmdFEEinWaitingSync+0x8c>
8110f31c:	10c00120 	cmpeqi	r3,r2,4
8110f320:	18001f1e 	bne	r3,zero,8110f3a0 <vQCmdFEEinWaitingSync+0xe0>
8110f324:	10c00148 	cmpgei	r3,r2,5
8110f328:	1800031e 	bne	r3,zero,8110f338 <vQCmdFEEinWaitingSync+0x78>
8110f32c:	10800060 	cmpeqi	r2,r2,1
8110f330:	1000121e 	bne	r2,zero,8110f37c <vQCmdFEEinWaitingSync+0xbc>
8110f334:	00005206 	br	8110f480 <vQCmdFEEinWaitingSync+0x1c0>
8110f338:	10c00220 	cmpeqi	r3,r2,8
8110f33c:	1800221e 	bne	r3,zero,8110f3c8 <vQCmdFEEinWaitingSync+0x108>
8110f340:	108023e0 	cmpeqi	r2,r2,143
8110f344:	1000441e 	bne	r2,zero,8110f458 <vQCmdFEEinWaitingSync+0x198>
8110f348:	00004d06 	br	8110f480 <vQCmdFEEinWaitingSync+0x1c0>
8110f34c:	10c03888 	cmpgei	r3,r2,226
8110f350:	1800071e 	bne	r3,zero,8110f370 <vQCmdFEEinWaitingSync+0xb0>
8110f354:	10c03808 	cmpgei	r3,r2,224
8110f358:	1800381e 	bne	r3,zero,8110f43c <vQCmdFEEinWaitingSync+0x17c>
8110f35c:	10c02920 	cmpeqi	r3,r2,164
8110f360:	18000f1e 	bne	r3,zero,8110f3a0 <vQCmdFEEinWaitingSync+0xe0>
8110f364:	10802a20 	cmpeqi	r2,r2,168
8110f368:	1000171e 	bne	r2,zero,8110f3c8 <vQCmdFEEinWaitingSync+0x108>
8110f36c:	00004406 	br	8110f480 <vQCmdFEEinWaitingSync+0x1c0>
8110f370:	10803c20 	cmpeqi	r2,r2,240
8110f374:	10001e1e 	bne	r2,zero,8110f3f0 <vQCmdFEEinWaitingSync+0x130>
8110f378:	00004106 	br	8110f480 <vQCmdFEEinWaitingSync+0x1c0>
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f37c:	e0bffe17 	ldw	r2,-8(fp)
8110f380:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f384:	e0bffe17 	ldw	r2,-8(fp)
8110f388:	00c00144 	movi	r3,5
8110f38c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f390:	e0bffe17 	ldw	r2,-8(fp)
8110f394:	00c00144 	movi	r3,5
8110f398:	10c02d15 	stw	r3,180(r2)
				break;
8110f39c:	00004806 	br	8110f4c0 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f3a0:	e0bffe17 	ldw	r2,-8(fp)
8110f3a4:	00c00044 	movi	r3,1
8110f3a8:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8110f3ac:	e0bffe17 	ldw	r2,-8(fp)
8110f3b0:	00c00304 	movi	r3,12
8110f3b4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f3b8:	e0bffe17 	ldw	r2,-8(fp)
8110f3bc:	00c00184 	movi	r3,6
8110f3c0:	10c02d15 	stw	r3,180(r2)
				break;
8110f3c4:	00003e06 	br	8110f4c0 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f3c8:	e0bffe17 	ldw	r2,-8(fp)
8110f3cc:	00c00044 	movi	r3,1
8110f3d0:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f3d4:	e0bffe17 	ldw	r2,-8(fp)
8110f3d8:	00c00284 	movi	r3,10
8110f3dc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f3e0:	e0bffe17 	ldw	r2,-8(fp)
8110f3e4:	00c00304 	movi	r3,12
8110f3e8:	10c02d15 	stw	r3,180(r2)
				break;
8110f3ec:	00003406 	br	8110f4c0 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_RMAP:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110f3f0:	00a045b4 	movhi	r2,33046
8110f3f4:	109fe204 	addi	r2,r2,32648
8110f3f8:	10800d8b 	ldhu	r2,54(r2)
8110f3fc:	10bfffcc 	andi	r2,r2,65535
8110f400:	108000e8 	cmpgeui	r2,r2,3
8110f404:	1000091e 	bne	r2,zero,8110f42c <vQCmdFEEinWaitingSync+0x16c>
					fprintf(fp,"\nNFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
8110f408:	d0e06217 	ldw	r3,-32376(gp)
8110f40c:	e0bffe17 	ldw	r2,-8(fp)
8110f410:	10800003 	ldbu	r2,0(r2)
8110f414:	10803fcc 	andi	r2,r2,255
8110f418:	100d883a 	mov	r6,r2
8110f41c:	01604574 	movhi	r5,33045
8110f420:	29770f04 	addi	r5,r5,-9156
8110f424:	1809883a 	mov	r4,r3
8110f428:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPWaitingSync( pxNFeeP, cmd );
8110f42c:	e17fff17 	ldw	r5,-4(fp)
8110f430:	e13ffe17 	ldw	r4,-8(fp)
8110f434:	11108680 	call	81110868 <vQCmdFeeRMAPWaitingSync>
				break;
8110f438:	00002106 	br	8110f4c0 <vQCmdFEEinWaitingSync+0x200>
			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f43c:	e0bffe17 	ldw	r2,-8(fp)
8110f440:	10c02d17 	ldw	r3,180(r2)
8110f444:	e0bffe17 	ldw	r2,-8(fp)
8110f448:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f44c:	e0bffe17 	ldw	r2,-8(fp)
8110f450:	10002815 	stw	zero,160(r2)

				break;
8110f454:	00001a06 	br	8110f4c0 <vQCmdFEEinWaitingSync+0x200>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f458:	e0bffe17 	ldw	r2,-8(fp)
8110f45c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f460:	e0bffe17 	ldw	r2,-8(fp)
8110f464:	10800003 	ldbu	r2,0(r2)
8110f468:	10803fcc 	andi	r2,r2,255
8110f46c:	100d883a 	mov	r6,r2
8110f470:	000b883a 	mov	r5,zero
8110f474:	01002044 	movi	r4,129
8110f478:	11111000 	call	81111100 <bSendGiveBackNFeeCtrl>
				break;
8110f47c:	00001006 	br	8110f4c0 <vQCmdFEEinWaitingSync+0x200>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f480:	00a045b4 	movhi	r2,33046
8110f484:	109fe204 	addi	r2,r2,32648
8110f488:	10800d8b 	ldhu	r2,54(r2)
8110f48c:	10bfffcc 	andi	r2,r2,65535
8110f490:	10800228 	cmpgeui	r2,r2,8
8110f494:	1000091e 	bne	r2,zero,8110f4bc <vQCmdFEEinWaitingSync+0x1fc>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110f498:	d0e06217 	ldw	r3,-32376(gp)
8110f49c:	e0bffe17 	ldw	r2,-8(fp)
8110f4a0:	10800003 	ldbu	r2,0(r2)
8110f4a4:	10803fcc 	andi	r2,r2,255
8110f4a8:	100d883a 	mov	r6,r2
8110f4ac:	01604574 	movhi	r5,33045
8110f4b0:	29771704 	addi	r5,r5,-9124
8110f4b4:	1809883a 	mov	r4,r3
8110f4b8:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				break;
8110f4bc:	0001883a 	nop
		}
	}
}
8110f4c0:	0001883a 	nop
8110f4c4:	e037883a 	mov	sp,fp
8110f4c8:	dfc00117 	ldw	ra,4(sp)
8110f4cc:	df000017 	ldw	fp,0(sp)
8110f4d0:	dec00204 	addi	sp,sp,8
8110f4d4:	f800283a 	ret

8110f4d8 <vQCmdFEEinConfig>:


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110f4d8:	defffb04 	addi	sp,sp,-20
8110f4dc:	de00012e 	bgeu	sp,et,8110f4e4 <vQCmdFEEinConfig+0xc>
8110f4e0:	003b68fa 	trap	3
8110f4e4:	dfc00415 	stw	ra,16(sp)
8110f4e8:	df000315 	stw	fp,12(sp)
8110f4ec:	df000304 	addi	fp,sp,12
8110f4f0:	e13ffe15 	stw	r4,-8(fp)
8110f4f4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f4f8:	e0bfff17 	ldw	r2,-4(fp)
8110f4fc:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f500:	e0bffdc3 	ldbu	r2,-9(fp)
8110f504:	10c03fcc 	andi	r3,r2,255
8110f508:	e0bffe17 	ldw	r2,-8(fp)
8110f50c:	10800003 	ldbu	r2,0(r2)
8110f510:	10803fcc 	andi	r2,r2,255
8110f514:	10800444 	addi	r2,r2,17
8110f518:	18807a1e 	bne	r3,r2,8110f704 <vQCmdFEEinConfig+0x22c>

		switch (uiCmdFEEL.ucByte[2]) {
8110f51c:	e0bffd83 	ldbu	r2,-10(fp)
8110f520:	10803fcc 	andi	r2,r2,255
8110f524:	10c02860 	cmpeqi	r3,r2,161
8110f528:	18001a1e 	bne	r3,zero,8110f594 <vQCmdFEEinConfig+0xbc>
8110f52c:	10c02888 	cmpgei	r3,r2,162
8110f530:	18000c1e 	bne	r3,zero,8110f564 <vQCmdFEEinConfig+0x8c>
8110f534:	10c00120 	cmpeqi	r3,r2,4
8110f538:	1800261e 	bne	r3,zero,8110f5d4 <vQCmdFEEinConfig+0xfc>
8110f53c:	10c00148 	cmpgei	r3,r2,5
8110f540:	1800031e 	bne	r3,zero,8110f550 <vQCmdFEEinConfig+0x78>
8110f544:	10800060 	cmpeqi	r2,r2,1
8110f548:	1000121e 	bne	r2,zero,8110f594 <vQCmdFEEinConfig+0xbc>
8110f54c:	00005406 	br	8110f6a0 <vQCmdFEEinConfig+0x1c8>
8110f550:	10c00220 	cmpeqi	r3,r2,8
8110f554:	1800281e 	bne	r3,zero,8110f5f8 <vQCmdFEEinConfig+0x120>
8110f558:	108023e0 	cmpeqi	r2,r2,143
8110f55c:	1000461e 	bne	r2,zero,8110f678 <vQCmdFEEinConfig+0x1a0>
8110f560:	00004f06 	br	8110f6a0 <vQCmdFEEinConfig+0x1c8>
8110f564:	10c03888 	cmpgei	r3,r2,226
8110f568:	1800071e 	bne	r3,zero,8110f588 <vQCmdFEEinConfig+0xb0>
8110f56c:	10c03808 	cmpgei	r3,r2,224
8110f570:	18005b1e 	bne	r3,zero,8110f6e0 <vQCmdFEEinConfig+0x208>
8110f574:	10c02920 	cmpeqi	r3,r2,164
8110f578:	1800161e 	bne	r3,zero,8110f5d4 <vQCmdFEEinConfig+0xfc>
8110f57c:	10802a20 	cmpeqi	r2,r2,168
8110f580:	10001d1e 	bne	r2,zero,8110f5f8 <vQCmdFEEinConfig+0x120>
8110f584:	00004606 	br	8110f6a0 <vQCmdFEEinConfig+0x1c8>
8110f588:	10803c20 	cmpeqi	r2,r2,240
8110f58c:	10002a1e 	bne	r2,zero,8110f638 <vQCmdFEEinConfig+0x160>
8110f590:	00004306 	br	8110f6a0 <vQCmdFEEinConfig+0x1c8>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f594:	00a045b4 	movhi	r2,33046
8110f598:	109fe204 	addi	r2,r2,32648
8110f59c:	10800d8b 	ldhu	r2,54(r2)
8110f5a0:	10bfffcc 	andi	r2,r2,65535
8110f5a4:	10800168 	cmpgeui	r2,r2,5
8110f5a8:	10004f1e 	bne	r2,zero,8110f6e8 <vQCmdFEEinConfig+0x210>
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110f5ac:	d0e06217 	ldw	r3,-32376(gp)
8110f5b0:	e0bffe17 	ldw	r2,-8(fp)
8110f5b4:	10800003 	ldbu	r2,0(r2)
8110f5b8:	10803fcc 	andi	r2,r2,255
8110f5bc:	100d883a 	mov	r6,r2
8110f5c0:	01604574 	movhi	r5,33045
8110f5c4:	29772804 	addi	r5,r5,-9056
8110f5c8:	1809883a 	mov	r4,r3
8110f5cc:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				break;
8110f5d0:	00004506 	br	8110f6e8 <vQCmdFEEinConfig+0x210>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				break;*/
			case M_FEE_STANDBY: /* Config -> StandBy is always forced mode (don't need sync) */
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f5d4:	e0bffe17 	ldw	r2,-8(fp)
8110f5d8:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110f5dc:	e0bffe17 	ldw	r2,-8(fp)
8110f5e0:	00c00184 	movi	r3,6
8110f5e4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f5e8:	e0bffe17 	ldw	r2,-8(fp)
8110f5ec:	00c00184 	movi	r3,6
8110f5f0:	10c02d15 	stw	r3,180(r2)
				break;				
8110f5f4:	00004306 	br	8110f704 <vQCmdFEEinConfig+0x22c>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f5f8:	00a045b4 	movhi	r2,33046
8110f5fc:	109fe204 	addi	r2,r2,32648
8110f600:	10800d8b 	ldhu	r2,54(r2)
8110f604:	10bfffcc 	andi	r2,r2,65535
8110f608:	10800168 	cmpgeui	r2,r2,5
8110f60c:	1000381e 	bne	r2,zero,8110f6f0 <vQCmdFEEinConfig+0x218>
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110f610:	d0e06217 	ldw	r3,-32376(gp)
8110f614:	e0bffe17 	ldw	r2,-8(fp)
8110f618:	10800003 	ldbu	r2,0(r2)
8110f61c:	10803fcc 	andi	r2,r2,255
8110f620:	100d883a 	mov	r6,r2
8110f624:	01604574 	movhi	r5,33045
8110f628:	29773304 	addi	r5,r5,-9012
8110f62c:	1809883a 	mov	r4,r3
8110f630:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				break;
8110f634:	00002e06 	br	8110f6f0 <vQCmdFEEinConfig+0x218>
			case M_FEE_RMAP:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f638:	00a045b4 	movhi	r2,33046
8110f63c:	109fe204 	addi	r2,r2,32648
8110f640:	10800d8b 	ldhu	r2,54(r2)
8110f644:	10bfffcc 	andi	r2,r2,65535
8110f648:	10800168 	cmpgeui	r2,r2,5
8110f64c:	10002a1e 	bne	r2,zero,8110f6f8 <vQCmdFEEinConfig+0x220>
					fprintf(fp,"NFEE %hhu Task: Can't threat RMAP Messages in this mode (Config)\n", pxNFeeP->ucId);
8110f650:	d0e06217 	ldw	r3,-32376(gp)
8110f654:	e0bffe17 	ldw	r2,-8(fp)
8110f658:	10800003 	ldbu	r2,0(r2)
8110f65c:	10803fcc 	andi	r2,r2,255
8110f660:	100d883a 	mov	r6,r2
8110f664:	01604574 	movhi	r5,33045
8110f668:	29774404 	addi	r5,r5,-8944
8110f66c:	1809883a 	mov	r4,r3
8110f670:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				break;
8110f674:	00002006 	br	8110f6f8 <vQCmdFEEinConfig+0x220>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f678:	e0bffe17 	ldw	r2,-8(fp)
8110f67c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f680:	e0bffe17 	ldw	r2,-8(fp)
8110f684:	10800003 	ldbu	r2,0(r2)
8110f688:	10803fcc 	andi	r2,r2,255
8110f68c:	100d883a 	mov	r6,r2
8110f690:	000b883a 	mov	r5,zero
8110f694:	01002044 	movi	r4,129
8110f698:	11111000 	call	81111100 <bSendGiveBackNFeeCtrl>
				break;
8110f69c:	00001906 	br	8110f704 <vQCmdFEEinConfig+0x22c>
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f6a0:	00a045b4 	movhi	r2,33046
8110f6a4:	109fe204 	addi	r2,r2,32648
8110f6a8:	10800d8b 	ldhu	r2,54(r2)
8110f6ac:	10bfffcc 	andi	r2,r2,65535
8110f6b0:	10800228 	cmpgeui	r2,r2,8
8110f6b4:	1000121e 	bne	r2,zero,8110f700 <vQCmdFEEinConfig+0x228>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (Config)\n", pxNFeeP->ucId);
8110f6b8:	d0e06217 	ldw	r3,-32376(gp)
8110f6bc:	e0bffe17 	ldw	r2,-8(fp)
8110f6c0:	10800003 	ldbu	r2,0(r2)
8110f6c4:	10803fcc 	andi	r2,r2,255
8110f6c8:	100d883a 	mov	r6,r2
8110f6cc:	01604574 	movhi	r5,33045
8110f6d0:	29775504 	addi	r5,r5,-8876
8110f6d4:	1809883a 	mov	r4,r3
8110f6d8:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				break;
8110f6dc:	00000806 	br	8110f700 <vQCmdFEEinConfig+0x228>
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
				break;
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
8110f6e0:	0001883a 	nop
8110f6e4:	00000706 	br	8110f704 <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110f6e8:	0001883a 	nop
8110f6ec:	00000506 	br	8110f704 <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110f6f0:	0001883a 	nop
8110f6f4:	00000306 	br	8110f704 <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task: Can't threat RMAP Messages in this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110f6f8:	0001883a 	nop
8110f6fc:	00000106 	br	8110f704 <vQCmdFEEinConfig+0x22c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110f700:	0001883a 	nop
		}
	}
}
8110f704:	0001883a 	nop
8110f708:	e037883a 	mov	sp,fp
8110f70c:	dfc00117 	ldw	ra,4(sp)
8110f710:	df000017 	ldw	fp,0(sp)
8110f714:	dec00204 	addi	sp,sp,8
8110f718:	f800283a 	ret

8110f71c <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110f71c:	defffb04 	addi	sp,sp,-20
8110f720:	de00012e 	bgeu	sp,et,8110f728 <vQCmdFEEinStandBy+0xc>
8110f724:	003b68fa 	trap	3
8110f728:	dfc00415 	stw	ra,16(sp)
8110f72c:	df000315 	stw	fp,12(sp)
8110f730:	df000304 	addi	fp,sp,12
8110f734:	e13ffe15 	stw	r4,-8(fp)
8110f738:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f73c:	e0bfff17 	ldw	r2,-4(fp)
8110f740:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f744:	e0bffdc3 	ldbu	r2,-9(fp)
8110f748:	10c03fcc 	andi	r3,r2,255
8110f74c:	e0bffe17 	ldw	r2,-8(fp)
8110f750:	10800003 	ldbu	r2,0(r2)
8110f754:	10803fcc 	andi	r2,r2,255
8110f758:	10800444 	addi	r2,r2,17
8110f75c:	1880801e 	bne	r3,r2,8110f960 <vQCmdFEEinStandBy+0x244>

		switch (uiCmdFEEL.ucByte[2]) {
8110f760:	e0bffd83 	ldbu	r2,-10(fp)
8110f764:	10803fcc 	andi	r2,r2,255
8110f768:	10c02860 	cmpeqi	r3,r2,161
8110f76c:	18001a1e 	bne	r3,zero,8110f7d8 <vQCmdFEEinStandBy+0xbc>
8110f770:	10c02888 	cmpgei	r3,r2,162
8110f774:	18000c1e 	bne	r3,zero,8110f7a8 <vQCmdFEEinStandBy+0x8c>
8110f778:	10c00120 	cmpeqi	r3,r2,4
8110f77c:	18001f1e 	bne	r3,zero,8110f7fc <vQCmdFEEinStandBy+0xe0>
8110f780:	10c00148 	cmpgei	r3,r2,5
8110f784:	1800031e 	bne	r3,zero,8110f794 <vQCmdFEEinStandBy+0x78>
8110f788:	10800060 	cmpeqi	r2,r2,1
8110f78c:	1000121e 	bne	r2,zero,8110f7d8 <vQCmdFEEinStandBy+0xbc>
8110f790:	00005c06 	br	8110f904 <vQCmdFEEinStandBy+0x1e8>
8110f794:	10c00220 	cmpeqi	r3,r2,8
8110f798:	1800281e 	bne	r3,zero,8110f83c <vQCmdFEEinStandBy+0x120>
8110f79c:	108023e0 	cmpeqi	r2,r2,143
8110f7a0:	10004e1e 	bne	r2,zero,8110f8dc <vQCmdFEEinStandBy+0x1c0>
8110f7a4:	00005706 	br	8110f904 <vQCmdFEEinStandBy+0x1e8>
8110f7a8:	10c03888 	cmpgei	r3,r2,226
8110f7ac:	1800071e 	bne	r3,zero,8110f7cc <vQCmdFEEinStandBy+0xb0>
8110f7b0:	10c03808 	cmpgei	r3,r2,224
8110f7b4:	18003e1e 	bne	r3,zero,8110f8b0 <vQCmdFEEinStandBy+0x194>
8110f7b8:	10c02920 	cmpeqi	r3,r2,164
8110f7bc:	18000f1e 	bne	r3,zero,8110f7fc <vQCmdFEEinStandBy+0xe0>
8110f7c0:	10802a20 	cmpeqi	r2,r2,168
8110f7c4:	10001d1e 	bne	r2,zero,8110f83c <vQCmdFEEinStandBy+0x120>
8110f7c8:	00004e06 	br	8110f904 <vQCmdFEEinStandBy+0x1e8>
8110f7cc:	10803c20 	cmpeqi	r2,r2,240
8110f7d0:	1000241e 	bne	r2,zero,8110f864 <vQCmdFEEinStandBy+0x148>
8110f7d4:	00004b06 	br	8110f904 <vQCmdFEEinStandBy+0x1e8>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f7d8:	e0bffe17 	ldw	r2,-8(fp)
8110f7dc:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f7e0:	e0bffe17 	ldw	r2,-8(fp)
8110f7e4:	00c00144 	movi	r3,5
8110f7e8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f7ec:	e0bffe17 	ldw	r2,-8(fp)
8110f7f0:	00c00144 	movi	r3,5
8110f7f4:	10c02d15 	stw	r3,180(r2)
				break;				
8110f7f8:	00005906 	br	8110f960 <vQCmdFEEinStandBy+0x244>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f7fc:	00a045b4 	movhi	r2,33046
8110f800:	109fe204 	addi	r2,r2,32648
8110f804:	10800d8b 	ldhu	r2,54(r2)
8110f808:	10bfffcc 	andi	r2,r2,65535
8110f80c:	10800168 	cmpgeui	r2,r2,5
8110f810:	10004c1e 	bne	r2,zero,8110f944 <vQCmdFEEinStandBy+0x228>
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by\n", pxNFeeP->ucId);
8110f814:	d0e06217 	ldw	r3,-32376(gp)
8110f818:	e0bffe17 	ldw	r2,-8(fp)
8110f81c:	10800003 	ldbu	r2,0(r2)
8110f820:	10803fcc 	andi	r2,r2,255
8110f824:	100d883a 	mov	r6,r2
8110f828:	01604574 	movhi	r5,33045
8110f82c:	29776404 	addi	r5,r5,-8816
8110f830:	1809883a 	mov	r4,r3
8110f834:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				break;
8110f838:	00004206 	br	8110f944 <vQCmdFEEinStandBy+0x228>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f83c:	e0bffe17 	ldw	r2,-8(fp)
8110f840:	00c00044 	movi	r3,1
8110f844:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f848:	e0bffe17 	ldw	r2,-8(fp)
8110f84c:	00c00284 	movi	r3,10
8110f850:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f854:	e0bffe17 	ldw	r2,-8(fp)
8110f858:	00c00304 	movi	r3,12
8110f85c:	10c02d15 	stw	r3,180(r2)
				break;
8110f860:	00003f06 	br	8110f960 <vQCmdFEEinStandBy+0x244>

			case M_FEE_RMAP:
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
8110f864:	e17fff17 	ldw	r5,-4(fp)
8110f868:	e13ffe17 	ldw	r4,-8(fp)
8110f86c:	110fc000 	call	8110fc00 <vQCmdFeeRMAPinStandBy>

				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110f870:	00a045b4 	movhi	r2,33046
8110f874:	109fe204 	addi	r2,r2,32648
8110f878:	10800d8b 	ldhu	r2,54(r2)
8110f87c:	10bfffcc 	andi	r2,r2,65535
8110f880:	10800168 	cmpgeui	r2,r2,5
8110f884:	1000311e 	bne	r2,zero,8110f94c <vQCmdFEEinStandBy+0x230>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
8110f888:	d0e06217 	ldw	r3,-32376(gp)
8110f88c:	e0bffe17 	ldw	r2,-8(fp)
8110f890:	10800003 	ldbu	r2,0(r2)
8110f894:	10803fcc 	andi	r2,r2,255
8110f898:	100d883a 	mov	r6,r2
8110f89c:	01604574 	movhi	r5,33045
8110f8a0:	29776e04 	addi	r5,r5,-8776
8110f8a4:	1809883a 	mov	r4,r3
8110f8a8:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8110f8ac:	00002706 	br	8110f94c <vQCmdFEEinStandBy+0x230>


			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110f8b0:	e0bffe17 	ldw	r2,-8(fp)
8110f8b4:	10802c17 	ldw	r2,176(r2)
8110f8b8:	10800318 	cmpnei	r2,r2,12
8110f8bc:	1000251e 	bne	r2,zero,8110f954 <vQCmdFEEinStandBy+0x238>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f8c0:	e0bffe17 	ldw	r2,-8(fp)
8110f8c4:	10c02d17 	ldw	r3,180(r2)
8110f8c8:	e0bffe17 	ldw	r2,-8(fp)
8110f8cc:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f8d0:	e0bffe17 	ldw	r2,-8(fp)
8110f8d4:	10002815 	stw	zero,160(r2)
				}
				break;
8110f8d8:	00001e06 	br	8110f954 <vQCmdFEEinStandBy+0x238>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f8dc:	e0bffe17 	ldw	r2,-8(fp)
8110f8e0:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f8e4:	e0bffe17 	ldw	r2,-8(fp)
8110f8e8:	10800003 	ldbu	r2,0(r2)
8110f8ec:	10803fcc 	andi	r2,r2,255
8110f8f0:	100d883a 	mov	r6,r2
8110f8f4:	000b883a 	mov	r5,zero
8110f8f8:	01002044 	movi	r4,129
8110f8fc:	11111000 	call	81111100 <bSendGiveBackNFeeCtrl>
				break;
8110f900:	00001706 	br	8110f960 <vQCmdFEEinStandBy+0x244>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110f904:	00a045b4 	movhi	r2,33046
8110f908:	109fe204 	addi	r2,r2,32648
8110f90c:	10800d8b 	ldhu	r2,54(r2)
8110f910:	10bfffcc 	andi	r2,r2,65535
8110f914:	10800228 	cmpgeui	r2,r2,8
8110f918:	1000101e 	bne	r2,zero,8110f95c <vQCmdFEEinStandBy+0x240>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110f91c:	d0e06217 	ldw	r3,-32376(gp)
8110f920:	e0bffe17 	ldw	r2,-8(fp)
8110f924:	10800003 	ldbu	r2,0(r2)
8110f928:	10803fcc 	andi	r2,r2,255
8110f92c:	100d883a 	mov	r6,r2
8110f930:	01604574 	movhi	r5,33045
8110f934:	29771704 	addi	r5,r5,-9124
8110f938:	1809883a 	mov	r4,r3
8110f93c:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				break;
8110f940:	00000606 	br	8110f95c <vQCmdFEEinStandBy+0x240>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110f944:	0001883a 	nop
8110f948:	00000506 	br	8110f960 <vQCmdFEEinStandBy+0x244>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8110f94c:	0001883a 	nop
8110f950:	00000306 	br	8110f960 <vQCmdFEEinStandBy+0x244>
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}
				break;
8110f954:	0001883a 	nop
8110f958:	00000106 	br	8110f960 <vQCmdFEEinStandBy+0x244>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110f95c:	0001883a 	nop
		}
	}
}
8110f960:	0001883a 	nop
8110f964:	e037883a 	mov	sp,fp
8110f968:	dfc00117 	ldw	ra,4(sp)
8110f96c:	df000017 	ldw	fp,0(sp)
8110f970:	dec00204 	addi	sp,sp,8
8110f974:	f800283a 	ret

8110f978 <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110f978:	defffb04 	addi	sp,sp,-20
8110f97c:	de00012e 	bgeu	sp,et,8110f984 <vQCmdFEEinFullPattern+0xc>
8110f980:	003b68fa 	trap	3
8110f984:	dfc00415 	stw	ra,16(sp)
8110f988:	df000315 	stw	fp,12(sp)
8110f98c:	df000304 	addi	fp,sp,12
8110f990:	e13ffe15 	stw	r4,-8(fp)
8110f994:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f998:	e0bfff17 	ldw	r2,-4(fp)
8110f99c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f9a0:	e0bffdc3 	ldbu	r2,-9(fp)
8110f9a4:	10c03fcc 	andi	r3,r2,255
8110f9a8:	e0bffe17 	ldw	r2,-8(fp)
8110f9ac:	10800003 	ldbu	r2,0(r2)
8110f9b0:	10803fcc 	andi	r2,r2,255
8110f9b4:	10800444 	addi	r2,r2,17
8110f9b8:	18808b1e 	bne	r3,r2,8110fbe8 <vQCmdFEEinFullPattern+0x270>

		switch (uiCmdFEEL.ucByte[2]) {
8110f9bc:	e0bffd83 	ldbu	r2,-10(fp)
8110f9c0:	10803fcc 	andi	r2,r2,255
8110f9c4:	10c02860 	cmpeqi	r3,r2,161
8110f9c8:	1800181e 	bne	r3,zero,8110fa2c <vQCmdFEEinFullPattern+0xb4>
8110f9cc:	10c02888 	cmpgei	r3,r2,162
8110f9d0:	18000c1e 	bne	r3,zero,8110fa04 <vQCmdFEEinFullPattern+0x8c>
8110f9d4:	10c000a0 	cmpeqi	r3,r2,2
8110f9d8:	18007c1e 	bne	r3,zero,8110fbcc <vQCmdFEEinFullPattern+0x254>
8110f9dc:	10c000c8 	cmpgei	r3,r2,3
8110f9e0:	1800031e 	bne	r3,zero,8110f9f0 <vQCmdFEEinFullPattern+0x78>
8110f9e4:	10800060 	cmpeqi	r2,r2,1
8110f9e8:	1000101e 	bne	r2,zero,8110fa2c <vQCmdFEEinFullPattern+0xb4>
8110f9ec:	00006706 	br	8110fb8c <vQCmdFEEinFullPattern+0x214>
8110f9f0:	10c00120 	cmpeqi	r3,r2,4
8110f9f4:	1800161e 	bne	r3,zero,8110fa50 <vQCmdFEEinFullPattern+0xd8>
8110f9f8:	10800220 	cmpeqi	r2,r2,8
8110f9fc:	1000351e 	bne	r2,zero,8110fad4 <vQCmdFEEinFullPattern+0x15c>
8110fa00:	00006206 	br	8110fb8c <vQCmdFEEinFullPattern+0x214>
8110fa04:	10c03888 	cmpgei	r3,r2,226
8110fa08:	1800051e 	bne	r3,zero,8110fa20 <vQCmdFEEinFullPattern+0xa8>
8110fa0c:	10c03808 	cmpgei	r3,r2,224
8110fa10:	1800531e 	bne	r3,zero,8110fb60 <vQCmdFEEinFullPattern+0x1e8>
8110fa14:	10802920 	cmpeqi	r2,r2,164
8110fa18:	1000251e 	bne	r2,zero,8110fab0 <vQCmdFEEinFullPattern+0x138>
8110fa1c:	00005b06 	br	8110fb8c <vQCmdFEEinFullPattern+0x214>
8110fa20:	10803c20 	cmpeqi	r2,r2,240
8110fa24:	10003b1e 	bne	r2,zero,8110fb14 <vQCmdFEEinFullPattern+0x19c>
8110fa28:	00005806 	br	8110fb8c <vQCmdFEEinFullPattern+0x214>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110fa2c:	e0bffe17 	ldw	r2,-8(fp)
8110fa30:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110fa34:	e0bffe17 	ldw	r2,-8(fp)
8110fa38:	00c00144 	movi	r3,5
8110fa3c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110fa40:	e0bffe17 	ldw	r2,-8(fp)
8110fa44:	00c00144 	movi	r3,5
8110fa48:	10c02d15 	stw	r3,180(r2)
				break;				
8110fa4c:	00006606 	br	8110fbe8 <vQCmdFEEinFullPattern+0x270>
				break;
			case M_FEE_STANDBY:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;*/ /* To finish the actual transfer only when sync comes */
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8110fa50:	e0bffe17 	ldw	r2,-8(fp)
8110fa54:	10802c17 	ldw	r2,176(r2)
8110fa58:	10800298 	cmpnei	r2,r2,10
8110fa5c:	10000a1e 	bne	r2,zero,8110fa88 <vQCmdFEEinFullPattern+0x110>
					pxNFeeP->xControl.bWatingSync = TRUE;
8110fa60:	e0bffe17 	ldw	r2,-8(fp)
8110fa64:	00c00044 	movi	r3,1
8110fa68:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110fa6c:	e0bffe17 	ldw	r2,-8(fp)
8110fa70:	00c00304 	movi	r3,12
8110fa74:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110fa78:	e0bffe17 	ldw	r2,-8(fp)
8110fa7c:	00c00184 	movi	r3,6
8110fa80:	10c02d15 	stw	r3,180(r2)
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				}

				break;
8110fa84:	00005806 	br	8110fbe8 <vQCmdFEEinFullPattern+0x270>
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				} else {
					pxNFeeP->xControl.bWatingSync = TRUE;
8110fa88:	e0bffe17 	ldw	r2,-8(fp)
8110fa8c:	00c00044 	movi	r3,1
8110fa90:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8110fa94:	e0bffe17 	ldw	r2,-8(fp)
8110fa98:	00c00104 	movi	r3,4
8110fa9c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110faa0:	e0bffe17 	ldw	r2,-8(fp)
8110faa4:	00c00184 	movi	r3,6
8110faa8:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110faac:	00004e06 	br	8110fbe8 <vQCmdFEEinFullPattern+0x270>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110fab0:	e0bffe17 	ldw	r2,-8(fp)
8110fab4:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110fab8:	e0bffe17 	ldw	r2,-8(fp)
8110fabc:	00c00184 	movi	r3,6
8110fac0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110fac4:	e0bffe17 	ldw	r2,-8(fp)
8110fac8:	00c00184 	movi	r3,6
8110facc:	10c02d15 	stw	r3,180(r2)
				break;				
8110fad0:	00004506 	br	8110fbe8 <vQCmdFEEinFullPattern+0x270>
			case M_FEE_FULL_PATTERN:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110fad4:	00a045b4 	movhi	r2,33046
8110fad8:	109fe204 	addi	r2,r2,32648
8110fadc:	10800d8b 	ldhu	r2,54(r2)
8110fae0:	10bfffcc 	andi	r2,r2,65535
8110fae4:	10800168 	cmpgeui	r2,r2,5
8110fae8:	10003a1e 	bne	r2,zero,8110fbd4 <vQCmdFEEinFullPattern+0x25c>
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110faec:	d0e06217 	ldw	r3,-32376(gp)
8110faf0:	e0bffe17 	ldw	r2,-8(fp)
8110faf4:	10800003 	ldbu	r2,0(r2)
8110faf8:	10803fcc 	andi	r2,r2,255
8110fafc:	100d883a 	mov	r6,r2
8110fb00:	01604574 	movhi	r5,33045
8110fb04:	29777604 	addi	r5,r5,-8744
8110fb08:	1809883a 	mov	r4,r3
8110fb0c:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				break;
8110fb10:	00003006 	br	8110fbd4 <vQCmdFEEinFullPattern+0x25c>
			case M_FEE_RMAP:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110fb14:	00a045b4 	movhi	r2,33046
8110fb18:	109fe204 	addi	r2,r2,32648
8110fb1c:	10800d8b 	ldhu	r2,54(r2)
8110fb20:	10bfffcc 	andi	r2,r2,65535
8110fb24:	10800168 	cmpgeui	r2,r2,5
8110fb28:	1000091e 	bne	r2,zero,8110fb50 <vQCmdFEEinFullPattern+0x1d8>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
8110fb2c:	d0e06217 	ldw	r3,-32376(gp)
8110fb30:	e0bffe17 	ldw	r2,-8(fp)
8110fb34:	10800003 	ldbu	r2,0(r2)
8110fb38:	10803fcc 	andi	r2,r2,255
8110fb3c:	100d883a 	mov	r6,r2
8110fb40:	01604574 	movhi	r5,33045
8110fb44:	29776e04 	addi	r5,r5,-8776
8110fb48:	1809883a 	mov	r4,r3
8110fb4c:	112292c0 	call	8112292c <fprintf>
				}
				#endif

				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
8110fb50:	e17fff17 	ldw	r5,-4(fp)
8110fb54:	e13ffe17 	ldw	r4,-8(fp)
8110fb58:	11102840 	call	81110284 <vQCmdFeeRMAPinFullPattern>

				break;
8110fb5c:	00002206 	br	8110fbe8 <vQCmdFEEinFullPattern+0x270>

			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110fb60:	e0bffe17 	ldw	r2,-8(fp)
8110fb64:	10802c17 	ldw	r2,176(r2)
8110fb68:	10800318 	cmpnei	r2,r2,12
8110fb6c:	10001b1e 	bne	r2,zero,8110fbdc <vQCmdFEEinFullPattern+0x264>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110fb70:	e0bffe17 	ldw	r2,-8(fp)
8110fb74:	10c02d17 	ldw	r3,180(r2)
8110fb78:	e0bffe17 	ldw	r2,-8(fp)
8110fb7c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110fb80:	e0bffe17 	ldw	r2,-8(fp)
8110fb84:	10002815 	stw	zero,160(r2)
				}

				break;
8110fb88:	00001406 	br	8110fbdc <vQCmdFEEinFullPattern+0x264>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8110fb8c:	00a045b4 	movhi	r2,33046
8110fb90:	109fe204 	addi	r2,r2,32648
8110fb94:	10800d8b 	ldhu	r2,54(r2)
8110fb98:	10bfffcc 	andi	r2,r2,65535
8110fb9c:	10800228 	cmpgeui	r2,r2,8
8110fba0:	1000101e 	bne	r2,zero,8110fbe4 <vQCmdFEEinFullPattern+0x26c>
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110fba4:	d0e06217 	ldw	r3,-32376(gp)
8110fba8:	e0bffe17 	ldw	r2,-8(fp)
8110fbac:	10800003 	ldbu	r2,0(r2)
8110fbb0:	10803fcc 	andi	r2,r2,255
8110fbb4:	100d883a 	mov	r6,r2
8110fbb8:	01604574 	movhi	r5,33045
8110fbbc:	29778404 	addi	r5,r5,-8688
8110fbc0:	1809883a 	mov	r4,r3
8110fbc4:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				break;
8110fbc8:	00000606 	br	8110fbe4 <vQCmdFEEinFullPattern+0x26c>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110fbcc:	0001883a 	nop
8110fbd0:	00000506 	br	8110fbe8 <vQCmdFEEinFullPattern+0x270>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110fbd4:	0001883a 	nop
8110fbd8:	00000306 	br	8110fbe8 <vQCmdFEEinFullPattern+0x270>
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}

				break;
8110fbdc:	0001883a 	nop
8110fbe0:	00000106 	br	8110fbe8 <vQCmdFEEinFullPattern+0x270>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8110fbe4:	0001883a 	nop
		}
	}
}
8110fbe8:	0001883a 	nop
8110fbec:	e037883a 	mov	sp,fp
8110fbf0:	dfc00117 	ldw	ra,4(sp)
8110fbf4:	df000017 	ldw	fp,0(sp)
8110fbf8:	dec00204 	addi	sp,sp,8
8110fbfc:	f800283a 	ret

8110fc00 <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
8110fc00:	defff704 	addi	sp,sp,-36
8110fc04:	de00012e 	bgeu	sp,et,8110fc0c <vQCmdFeeRMAPinStandBy+0xc>
8110fc08:	003b68fa 	trap	3
8110fc0c:	dfc00815 	stw	ra,32(sp)
8110fc10:	df000715 	stw	fp,28(sp)
8110fc14:	df000704 	addi	fp,sp,28
8110fc18:	e13ffe15 	stw	r4,-8(fp)
8110fc1c:	e17fff15 	stw	r5,-4(fp)
	INT32U ucValueMasked;
	INT32U ucValueMasked2;


#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110fc20:	00a045b4 	movhi	r2,33046
8110fc24:	109fe204 	addi	r2,r2,32648
8110fc28:	10800d8b 	ldhu	r2,54(r2)
8110fc2c:	10bfffcc 	andi	r2,r2,65535
8110fc30:	108000e8 	cmpgeui	r2,r2,3
8110fc34:	1000091e 	bne	r2,zero,8110fc5c <vQCmdFeeRMAPinStandBy+0x5c>
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (StandBy)\n", pxNFeeP->ucId);
8110fc38:	d0e06217 	ldw	r3,-32376(gp)
8110fc3c:	e0bffe17 	ldw	r2,-8(fp)
8110fc40:	10800003 	ldbu	r2,0(r2)
8110fc44:	10803fcc 	andi	r2,r2,255
8110fc48:	100d883a 	mov	r6,r2
8110fc4c:	01604574 	movhi	r5,33045
8110fc50:	29779504 	addi	r5,r5,-8620
8110fc54:	1809883a 	mov	r4,r3
8110fc58:	112292c0 	call	8112292c <fprintf>
	}
#endif


	uiCmdFEEL.ulWord = cmd;
8110fc5c:	e0bfff17 	ldw	r2,-4(fp)
8110fc60:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110fc64:	e0bffd43 	ldbu	r2,-11(fp)
8110fc68:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110fc6c:	e0bffe17 	ldw	r2,-8(fp)
8110fc70:	10804317 	ldw	r2,268(r2)
8110fc74:	e0fff903 	ldbu	r3,-28(fp)
8110fc78:	180b883a 	mov	r5,r3
8110fc7c:	1009883a 	mov	r4,r2
8110fc80:	1109e0c0 	call	81109e0c <uliRmapReadReg>
8110fc84:	e0bffa15 	stw	r2,-24(fp)

	switch (ucADDRReg) {
8110fc88:	e0bff903 	ldbu	r2,-28(fp)
8110fc8c:	10bff004 	addi	r2,r2,-64
8110fc90:	10c003a8 	cmpgeui	r3,r2,14
8110fc94:	18015e1e 	bne	r3,zero,81110210 <vQCmdFeeRMAPinStandBy+0x610>
8110fc98:	100690ba 	slli	r3,r2,2
8110fc9c:	00a04474 	movhi	r2,33041
8110fca0:	10bf2c04 	addi	r2,r2,-848
8110fca4:	1885883a 	add	r2,r3,r2
8110fca8:	10800017 	ldw	r2,0(r2)
8110fcac:	1000683a 	jmp	r2
8110fcb0:	8110fce8 	cmpgeui	r4,r16,17395
8110fcb4:	81110248 	cmpgei	r4,r16,17417
8110fcb8:	8110fdd4 	ori	r4,r16,17399
8110fcbc:	81110010 	cmplti	r4,r16,17408
8110fcc0:	81110010 	cmplti	r4,r16,17408
8110fcc4:	81110010 	cmplti	r4,r16,17408
8110fcc8:	81110010 	cmplti	r4,r16,17408
8110fccc:	81110010 	cmplti	r4,r16,17408
8110fcd0:	81110010 	cmplti	r4,r16,17408
8110fcd4:	81110010 	cmplti	r4,r16,17408
8110fcd8:	81110010 	cmplti	r4,r16,17408
8110fcdc:	81110010 	cmplti	r4,r16,17408
8110fce0:	81110048 	cmpgei	r4,r16,17409
8110fce4:	81110188 	cmpgei	r4,r16,17414
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
8110fce8:	e0fffa17 	ldw	r3,-24(fp)
8110fcec:	00800434 	movhi	r2,16
8110fcf0:	10bffc04 	addi	r2,r2,-16
8110fcf4:	1884703a 	and	r2,r3,r2
8110fcf8:	1004d13a 	srli	r2,r2,4
8110fcfc:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
8110fd00:	e0bffa17 	ldw	r2,-24(fp)
8110fd04:	1004d53a 	srli	r2,r2,20
8110fd08:	e0bffc15 	stw	r2,-16(fp)


			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8110fd0c:	e0bffb17 	ldw	r2,-20(fp)
8110fd10:	1007883a 	mov	r3,r2
8110fd14:	e0bffe17 	ldw	r2,-8(fp)
8110fd18:	1080300b 	ldhu	r2,192(r2)
8110fd1c:	1885c83a 	sub	r2,r3,r2
8110fd20:	1007883a 	mov	r3,r2
8110fd24:	e0bffe17 	ldw	r2,-8(fp)
8110fd28:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2 - (pxNFeeP->xCcdInfo.usiSOverscanN + pxNFeeP->xCcdInfo.usiSPrescanN);
8110fd2c:	e0bffc17 	ldw	r2,-16(fp)
8110fd30:	1009883a 	mov	r4,r2
8110fd34:	e0bffe17 	ldw	r2,-8(fp)
8110fd38:	10c02f8b 	ldhu	r3,190(r2)
8110fd3c:	e0bffe17 	ldw	r2,-8(fp)
8110fd40:	10802f0b 	ldhu	r2,188(r2)
8110fd44:	1885883a 	add	r2,r3,r2
8110fd48:	2085c83a 	sub	r2,r4,r2
8110fd4c:	1007883a 	mov	r3,r2
8110fd50:	e0bffe17 	ldw	r2,-8(fp)
8110fd54:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
8110fd58:	e13ffe17 	ldw	r4,-8(fp)
8110fd5c:	111eef80 	call	8111eef8 <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fd60:	e0bffe17 	ldw	r2,-8(fp)
8110fd64:	10803304 	addi	r2,r2,204
8110fd68:	1009883a 	mov	r4,r2
8110fd6c:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFeeP->xCcdInfo.usiOLN;
8110fd70:	e0bffe17 	ldw	r2,-8(fp)
8110fd74:	10c0300b 	ldhu	r3,192(r2)
8110fd78:	e0bffe17 	ldw	r2,-8(fp)
8110fd7c:	10c0358d 	sth	r3,214(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = ucValueMasked2 ;
8110fd80:	e0bffc17 	ldw	r2,-16(fp)
8110fd84:	1007883a 	mov	r3,r2
8110fd88:	e0bffe17 	ldw	r2,-8(fp)
8110fd8c:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = ucValueMasked;
8110fd90:	e0bffb17 	ldw	r2,-20(fp)
8110fd94:	1007883a 	mov	r3,r2
8110fd98:	e0bffe17 	ldw	r2,-8(fp)
8110fd9c:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8110fda0:	e0bffb17 	ldw	r2,-20(fp)
8110fda4:	1007883a 	mov	r3,r2
8110fda8:	e0bffe17 	ldw	r2,-8(fp)
8110fdac:	1080300b 	ldhu	r2,192(r2)
8110fdb0:	1885c83a 	sub	r2,r3,r2
8110fdb4:	1007883a 	mov	r3,r2
8110fdb8:	e0bffe17 	ldw	r2,-8(fp)
8110fdbc:	10c0350d 	sth	r3,212(r2)
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fdc0:	e0bffe17 	ldw	r2,-8(fp)
8110fdc4:	10803304 	addi	r2,r2,204
8110fdc8:	1009883a 	mov	r4,r2
8110fdcc:	11048400 	call	81104840 <bDpktSetPacketConfig>

			break;
8110fdd0:	00012606 	br	8111026c <vQCmdFeeRMAPinStandBy+0x66c>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
8110fdd4:	e0fffa17 	ldw	r3,-24(fp)
8110fdd8:	00800434 	movhi	r2,16
8110fddc:	10bffc04 	addi	r2,r2,-16
8110fde0:	1884703a 	and	r2,r3,r2
8110fde4:	1004d13a 	srli	r2,r2,4
8110fde8:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fdec:	e0bffe17 	ldw	r2,-8(fp)
8110fdf0:	10803304 	addi	r2,r2,204
8110fdf4:	1009883a 	mov	r4,r2
8110fdf8:	1104a6c0 	call	81104a6c <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
8110fdfc:	e0bffb17 	ldw	r2,-20(fp)
8110fe00:	1007883a 	mov	r3,r2
8110fe04:	e0bffe17 	ldw	r2,-8(fp)
8110fe08:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fe0c:	e0bffe17 	ldw	r2,-8(fp)
8110fe10:	10803304 	addi	r2,r2,204
8110fe14:	1009883a 	mov	r4,r2
8110fe18:	11048400 	call	81104840 <bDpktSetPacketConfig>

			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110fe1c:	00a045b4 	movhi	r2,33046
8110fe20:	109fe204 	addi	r2,r2,32648
8110fe24:	10800d8b 	ldhu	r2,54(r2)
8110fe28:	10bfffcc 	andi	r2,r2,65535
8110fe2c:	108000e8 	cmpgeui	r2,r2,3
8110fe30:	1000061e 	bne	r2,zero,8110fe4c <vQCmdFeeRMAPinStandBy+0x24c>
				fprintf(fp,"- Pckt Length: %lu\n", ucValueMasked);
8110fe34:	d0a06217 	ldw	r2,-32376(gp)
8110fe38:	e1bffb17 	ldw	r6,-20(fp)
8110fe3c:	01604574 	movhi	r5,33045
8110fe40:	2977a104 	addi	r5,r5,-8572
8110fe44:	1009883a 	mov	r4,r2
8110fe48:	112292c0 	call	8112292c <fprintf>
			}
			#endif

			ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110fe4c:	e0bffa17 	ldw	r2,-24(fp)
8110fe50:	1080030c 	andi	r2,r2,12
8110fe54:	1004d0ba 	srli	r2,r2,2
8110fe58:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked2) {
8110fe5c:	e0bffc17 	ldw	r2,-16(fp)
8110fe60:	10c000a0 	cmpeqi	r3,r2,2
8110fe64:	1800141e 	bne	r3,zero,8110feb8 <vQCmdFeeRMAPinStandBy+0x2b8>
8110fe68:	10c000e0 	cmpeqi	r3,r2,3
8110fe6c:	1800231e 	bne	r3,zero,8110fefc <vQCmdFeeRMAPinStandBy+0x2fc>
8110fe70:	10800060 	cmpeqi	r2,r2,1
8110fe74:	10003026 	beq	r2,zero,8110ff38 <vQCmdFeeRMAPinStandBy+0x338>
				case 0b01:
					pxNFeeP->xControl.eSide = sLeft;
8110fe78:	e0bffe17 	ldw	r2,-8(fp)
8110fe7c:	10002e15 	stw	zero,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110fe80:	00a045b4 	movhi	r2,33046
8110fe84:	109fe204 	addi	r2,r2,32648
8110fe88:	10800d8b 	ldhu	r2,54(r2)
8110fe8c:	10bfffcc 	andi	r2,r2,65535
8110fe90:	108000e8 	cmpgeui	r2,r2,3
8110fe94:	1000461e 	bne	r2,zero,8110ffb0 <vQCmdFeeRMAPinStandBy+0x3b0>
						fprintf(fp," - Left side\n");
8110fe98:	d0a06217 	ldw	r2,-32376(gp)
8110fe9c:	100f883a 	mov	r7,r2
8110fea0:	01800344 	movi	r6,13
8110fea4:	01400044 	movi	r5,1
8110fea8:	01204574 	movhi	r4,33045
8110feac:	2137a604 	addi	r4,r4,-8552
8110feb0:	1122fc80 	call	81122fc8 <fwrite>
					}
					#endif
					break;
8110feb4:	00003e06 	br	8110ffb0 <vQCmdFeeRMAPinStandBy+0x3b0>
				case 0b10:
					pxNFeeP->xControl.eSide = sRight;
8110feb8:	e0bffe17 	ldw	r2,-8(fp)
8110febc:	00c00044 	movi	r3,1
8110fec0:	10c02e15 	stw	r3,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110fec4:	00a045b4 	movhi	r2,33046
8110fec8:	109fe204 	addi	r2,r2,32648
8110fecc:	10800d8b 	ldhu	r2,54(r2)
8110fed0:	10bfffcc 	andi	r2,r2,65535
8110fed4:	108000e8 	cmpgeui	r2,r2,3
8110fed8:	1000371e 	bne	r2,zero,8110ffb8 <vQCmdFeeRMAPinStandBy+0x3b8>
						fprintf(fp," - Right side\n");
8110fedc:	d0a06217 	ldw	r2,-32376(gp)
8110fee0:	100f883a 	mov	r7,r2
8110fee4:	01800384 	movi	r6,14
8110fee8:	01400044 	movi	r5,1
8110feec:	01204574 	movhi	r4,33045
8110fef0:	2137aa04 	addi	r4,r4,-8536
8110fef4:	1122fc80 	call	81122fc8 <fwrite>
					}
					#endif
					break;
8110fef8:	00002f06 	br	8110ffb8 <vQCmdFeeRMAPinStandBy+0x3b8>
				case 0b11:
					pxNFeeP->xControl.eSide = sLeft;
8110fefc:	e0bffe17 	ldw	r2,-8(fp)
8110ff00:	10002e15 	stw	zero,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110ff04:	00a045b4 	movhi	r2,33046
8110ff08:	109fe204 	addi	r2,r2,32648
8110ff0c:	10800d8b 	ldhu	r2,54(r2)
8110ff10:	10bfffcc 	andi	r2,r2,65535
8110ff14:	108000e8 	cmpgeui	r2,r2,3
8110ff18:	1000071e 	bne	r2,zero,8110ff38 <vQCmdFeeRMAPinStandBy+0x338>
						fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8110ff1c:	d0a06217 	ldw	r2,-32376(gp)
8110ff20:	100f883a 	mov	r7,r2
8110ff24:	01800f44 	movi	r6,61
8110ff28:	01400044 	movi	r5,1
8110ff2c:	01204574 	movhi	r4,33045
8110ff30:	2137ae04 	addi	r4,r4,-8520
8110ff34:	1122fc80 	call	81122fc8 <fwrite>
					}
					#endif
				default:
					pxNFeeP->xControl.eSide = sLeft;
8110ff38:	e0bffe17 	ldw	r2,-8(fp)
8110ff3c:	10002e15 	stw	zero,184(r2)

					bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110ff40:	e0bffe17 	ldw	r2,-8(fp)
8110ff44:	10804304 	addi	r2,r2,268
8110ff48:	1009883a 	mov	r4,r2
8110ff4c:	11080940 	call	81108094 <bRmapGetMemConfigArea>
					pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8110ff50:	e0bffe17 	ldw	r2,-8(fp)
8110ff54:	10c05717 	ldw	r3,348(r2)
8110ff58:	00bffdc4 	movi	r2,-9
8110ff5c:	1886703a 	and	r3,r3,r2
8110ff60:	e0bffe17 	ldw	r2,-8(fp)
8110ff64:	10c05715 	stw	r3,348(r2)
					bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110ff68:	e0bffe17 	ldw	r2,-8(fp)
8110ff6c:	10804304 	addi	r2,r2,268
8110ff70:	1009883a 	mov	r4,r2
8110ff74:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8110ff78:	00a045b4 	movhi	r2,33046
8110ff7c:	109fe204 	addi	r2,r2,32648
8110ff80:	10800d8b 	ldhu	r2,54(r2)
8110ff84:	10bfffcc 	andi	r2,r2,65535
8110ff88:	108000e8 	cmpgeui	r2,r2,3
8110ff8c:	10000c1e 	bne	r2,zero,8110ffc0 <vQCmdFeeRMAPinStandBy+0x3c0>
						fprintf(fp," - Switching to Left side\n");
8110ff90:	d0a06217 	ldw	r2,-32376(gp)
8110ff94:	100f883a 	mov	r7,r2
8110ff98:	01800684 	movi	r6,26
8110ff9c:	01400044 	movi	r5,1
8110ffa0:	01204574 	movhi	r4,33045
8110ffa4:	2137be04 	addi	r4,r4,-8456
8110ffa8:	1122fc80 	call	81122fc8 <fwrite>
					}
					#endif
					break;
8110ffac:	00000406 	br	8110ffc0 <vQCmdFeeRMAPinStandBy+0x3c0>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Left side\n");
					}
					#endif
					break;
8110ffb0:	0001883a 	nop
8110ffb4:	00000306 	br	8110ffc4 <vQCmdFeeRMAPinStandBy+0x3c4>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Right side\n");
					}
					#endif
					break;
8110ffb8:	0001883a 	nop
8110ffbc:	00000106 	br	8110ffc4 <vQCmdFeeRMAPinStandBy+0x3c4>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Switching to Left side\n");
					}
					#endif
					break;
8110ffc0:	0001883a 	nop
				}
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
8110ffc4:	00a045b4 	movhi	r2,33046
8110ffc8:	109fe204 	addi	r2,r2,32648
8110ffcc:	10800d8b 	ldhu	r2,54(r2)
8110ffd0:	10bfffcc 	andi	r2,r2,65535
8110ffd4:	10800168 	cmpgeui	r2,r2,5
8110ffd8:	10009d1e 	bne	r2,zero,81110250 <vQCmdFeeRMAPinStandBy+0x650>
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
8110ffdc:	d0e06217 	ldw	r3,-32376(gp)
8110ffe0:	e0bffe17 	ldw	r2,-8(fp)
8110ffe4:	10800003 	ldbu	r2,0(r2)
8110ffe8:	11003fcc 	andi	r4,r2,255
8110ffec:	e0bffe17 	ldw	r2,-8(fp)
8110fff0:	10802e17 	ldw	r2,184(r2)
8110fff4:	100f883a 	mov	r7,r2
8110fff8:	200d883a 	mov	r6,r4
8110fffc:	01604574 	movhi	r5,33045
81110000:	2977c504 	addi	r5,r5,-8428
81110004:	1809883a 	mov	r4,r3
81110008:	112292c0 	call	8112292c <fprintf>
			}
			#endif
			break;
8111000c:	00009006 	br	81110250 <vQCmdFeeRMAPinStandBy+0x650>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110010:	00a045b4 	movhi	r2,33046
81110014:	109fe204 	addi	r2,r2,32648
81110018:	10800d8b 	ldhu	r2,54(r2)
8111001c:	10bfffcc 	andi	r2,r2,65535
81110020:	10800168 	cmpgeui	r2,r2,5
81110024:	10008c1e 	bne	r2,zero,81110258 <vQCmdFeeRMAPinStandBy+0x658>
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
81110028:	d0a06217 	ldw	r2,-32376(gp)
8111002c:	e0fff903 	ldbu	r3,-28(fp)
81110030:	180d883a 	mov	r6,r3
81110034:	01604574 	movhi	r5,33045
81110038:	2977d304 	addi	r5,r5,-8372
8111003c:	1009883a 	mov	r4,r2
81110040:	112292c0 	call	8112292c <fprintf>
			}
			#endif
				break;
81110044:	00008406 	br	81110258 <vQCmdFeeRMAPinStandBy+0x658>
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
81110048:	e0bffa17 	ldw	r2,-24(fp)
8111004c:	10803c0c 	andi	r2,r2,240
81110050:	1004d13a 	srli	r2,r2,4
81110054:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
81110058:	e0bffb17 	ldw	r2,-20(fp)
8111005c:	10c000a0 	cmpeqi	r3,r2,2
81110060:	1800111e 	bne	r3,zero,811100a8 <vQCmdFeeRMAPinStandBy+0x4a8>
81110064:	10c001a0 	cmpeqi	r3,r2,6
81110068:	1800261e 	bne	r3,zero,81110104 <vQCmdFeeRMAPinStandBy+0x504>
8111006c:	1000331e 	bne	r2,zero,8111013c <vQCmdFeeRMAPinStandBy+0x53c>
				case 0: /* Standby */

				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110070:	00a045b4 	movhi	r2,33046
81110074:	109fe204 	addi	r2,r2,32648
81110078:	10800d8b 	ldhu	r2,54(r2)
8111007c:	10bfffcc 	andi	r2,r2,65535
81110080:	10800168 	cmpgeui	r2,r2,5
81110084:	10003a1e 	bne	r2,zero,81110170 <vQCmdFeeRMAPinStandBy+0x570>
						fprintf(fp,"- already in Stand by mode\n");
81110088:	d0a06217 	ldw	r2,-32376(gp)
8111008c:	100f883a 	mov	r7,r2
81110090:	018006c4 	movi	r6,27
81110094:	01400044 	movi	r5,1
81110098:	01204574 	movhi	r4,33045
8111009c:	2137dc04 	addi	r4,r4,-8336
811100a0:	1122fc80 	call	81122fc8 <fwrite>
					}
				#endif

					break;
811100a4:	00003206 	br	81110170 <vQCmdFeeRMAPinStandBy+0x570>
				case 2: /* PAttern Full image */
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811100a8:	00a045b4 	movhi	r2,33046
811100ac:	109fe204 	addi	r2,r2,32648
811100b0:	10800d8b 	ldhu	r2,54(r2)
811100b4:	10bfffcc 	andi	r2,r2,65535
811100b8:	10800168 	cmpgeui	r2,r2,5
811100bc:	1000071e 	bne	r2,zero,811100dc <vQCmdFeeRMAPinStandBy+0x4dc>
						fprintf(fp,"- to Full-Image-Pattern\n");
811100c0:	d0a06217 	ldw	r2,-32376(gp)
811100c4:	100f883a 	mov	r7,r2
811100c8:	01800604 	movi	r6,24
811100cc:	01400044 	movi	r5,1
811100d0:	01204574 	movhi	r4,33045
811100d4:	2137e304 	addi	r4,r4,-8308
811100d8:	1122fc80 	call	81122fc8 <fwrite>
					}
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
811100dc:	e0bffe17 	ldw	r2,-8(fp)
811100e0:	00c00044 	movi	r3,1
811100e4:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
811100e8:	e0bffe17 	ldw	r2,-8(fp)
811100ec:	00c00284 	movi	r3,10
811100f0:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
811100f4:	e0bffe17 	ldw	r2,-8(fp)
811100f8:	00c00304 	movi	r3,12
811100fc:	10c02d15 	stw	r3,180(r2)

					break;
81110100:	00002006 	br	81110184 <vQCmdFeeRMAPinStandBy+0x584>
				case 6:
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110104:	00a045b4 	movhi	r2,33046
81110108:	109fe204 	addi	r2,r2,32648
8111010c:	10800d8b 	ldhu	r2,54(r2)
81110110:	10bfffcc 	andi	r2,r2,65535
81110114:	10800168 	cmpgeui	r2,r2,5
81110118:	1000171e 	bne	r2,zero,81110178 <vQCmdFeeRMAPinStandBy+0x578>
						fprintf(fp,"- Off-Mode not allowed.\n");
8111011c:	d0a06217 	ldw	r2,-32376(gp)
81110120:	100f883a 	mov	r7,r2
81110124:	01800604 	movi	r6,24
81110128:	01400044 	movi	r5,1
8111012c:	01204574 	movhi	r4,33045
81110130:	2137ea04 	addi	r4,r4,-8280
81110134:	1122fc80 	call	81122fc8 <fwrite>
					}
				#endif
					break;
81110138:	00000f06 	br	81110178 <vQCmdFeeRMAPinStandBy+0x578>
				case 3:
				case 4:
				case 5:
				default:
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111013c:	00a045b4 	movhi	r2,33046
81110140:	109fe204 	addi	r2,r2,32648
81110144:	10800d8b 	ldhu	r2,54(r2)
81110148:	10bfffcc 	andi	r2,r2,65535
8111014c:	10800228 	cmpgeui	r2,r2,8
81110150:	10000b1e 	bne	r2,zero,81110180 <vQCmdFeeRMAPinStandBy+0x580>
						fprintf(fp,"- mode not allowed yet ( %lu )\n", ucValueMasked);
81110154:	d0a06217 	ldw	r2,-32376(gp)
81110158:	e1bffb17 	ldw	r6,-20(fp)
8111015c:	01604574 	movhi	r5,33045
81110160:	2977f104 	addi	r5,r5,-8252
81110164:	1009883a 	mov	r4,r2
81110168:	112292c0 	call	8112292c <fprintf>
					}
					#endif
					break;
8111016c:	00000406 	br	81110180 <vQCmdFeeRMAPinStandBy+0x580>
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"- already in Stand by mode\n");
					}
				#endif

					break;
81110170:	0001883a 	nop
81110174:	00003d06 	br	8111026c <vQCmdFeeRMAPinStandBy+0x66c>
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"- Off-Mode not allowed.\n");
					}
				#endif
					break;
81110178:	0001883a 	nop
8111017c:	00003b06 	br	8111026c <vQCmdFeeRMAPinStandBy+0x66c>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"- mode not allowed yet ( %lu )\n", ucValueMasked);
					}
					#endif
					break;
81110180:	0001883a 	nop
			}

			break;
81110184:	00003906 	br	8111026c <vQCmdFeeRMAPinStandBy+0x66c>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
81110188:	e0bffa17 	ldw	r2,-24(fp)
8111018c:	1080010c 	andi	r2,r2,4
81110190:	1004d0ba 	srli	r2,r2,2
81110194:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
81110198:	e0bffb17 	ldw	r2,-20(fp)
8111019c:	10003026 	beq	r2,zero,81110260 <vQCmdFeeRMAPinStandBy+0x660>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811101a0:	00a045b4 	movhi	r2,33046
811101a4:	109fe204 	addi	r2,r2,32648
811101a8:	10800d8b 	ldhu	r2,54(r2)
811101ac:	10bfffcc 	andi	r2,r2,65535
811101b0:	10800168 	cmpgeui	r2,r2,5
811101b4:	1000071e 	bne	r2,zero,811101d4 <vQCmdFeeRMAPinStandBy+0x5d4>
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
811101b8:	d0a06217 	ldw	r2,-32376(gp)
811101bc:	100f883a 	mov	r7,r2
811101c0:	01800a04 	movi	r6,40
811101c4:	01400044 	movi	r5,1
811101c8:	01204574 	movhi	r4,33045
811101cc:	2137f904 	addi	r4,r4,-8220
811101d0:	1122fc80 	call	81122fc8 <fwrite>
				}
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
811101d4:	e0bffe17 	ldw	r2,-8(fp)
811101d8:	10804304 	addi	r2,r2,268
811101dc:	1009883a 	mov	r4,r2
811101e0:	11080940 	call	81108094 <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
811101e4:	e0bffe17 	ldw	r2,-8(fp)
811101e8:	10c06217 	ldw	r3,392(r2)
811101ec:	00bffec4 	movi	r2,-5
811101f0:	1886703a 	and	r3,r3,r2
811101f4:	e0bffe17 	ldw	r2,-8(fp)
811101f8:	10c06215 	stw	r3,392(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
811101fc:	e0bffe17 	ldw	r2,-8(fp)
81110200:	10804304 	addi	r2,r2,268
81110204:	1009883a 	mov	r4,r2
81110208:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>
			}

			break;
8111020c:	00001406 	br	81110260 <vQCmdFeeRMAPinStandBy+0x660>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81110210:	00a045b4 	movhi	r2,33046
81110214:	109fe204 	addi	r2,r2,32648
81110218:	10800d8b 	ldhu	r2,54(r2)
8111021c:	10bfffcc 	andi	r2,r2,65535
81110220:	10800228 	cmpgeui	r2,r2,8
81110224:	1000101e 	bne	r2,zero,81110268 <vQCmdFeeRMAPinStandBy+0x668>
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
81110228:	d0a06217 	ldw	r2,-32376(gp)
8111022c:	e0fff903 	ldbu	r3,-28(fp)
81110230:	180d883a 	mov	r6,r3
81110234:	01604574 	movhi	r5,33045
81110238:	29780404 	addi	r5,r5,-8176
8111023c:	1009883a 	mov	r4,r2
81110240:	112292c0 	call	8112292c <fprintf>
			}
			#endif
			break;
81110244:	00000806 	br	81110268 <vQCmdFeeRMAPinStandBy+0x668>
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
81110248:	0001883a 	nop
8111024c:	00000706 	br	8111026c <vQCmdFeeRMAPinStandBy+0x66c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
			}
			#endif
			break;
81110250:	0001883a 	nop
81110254:	00000506 	br	8111026c <vQCmdFeeRMAPinStandBy+0x66c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
				break;
81110258:	0001883a 	nop
8111025c:	00000306 	br	8111026c <vQCmdFeeRMAPinStandBy+0x66c>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110260:	0001883a 	nop
81110264:	00000106 	br	8111026c <vQCmdFeeRMAPinStandBy+0x66c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
81110268:	0001883a 	nop
		}
}
8111026c:	0001883a 	nop
81110270:	e037883a 	mov	sp,fp
81110274:	dfc00117 	ldw	ra,4(sp)
81110278:	df000017 	ldw	fp,0(sp)
8111027c:	dec00204 	addi	sp,sp,8
81110280:	f800283a 	ret

81110284 <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ) {
81110284:	defff804 	addi	sp,sp,-32
81110288:	de00012e 	bgeu	sp,et,81110290 <vQCmdFeeRMAPinFullPattern+0xc>
8111028c:	003b68fa 	trap	3
81110290:	dfc00715 	stw	ra,28(sp)
81110294:	df000615 	stw	fp,24(sp)
81110298:	df000604 	addi	fp,sp,24
8111029c:	e13ffe15 	stw	r4,-8(fp)
811102a0:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811102a4:	00a045b4 	movhi	r2,33046
811102a8:	109fe204 	addi	r2,r2,32648
811102ac:	10800d8b 	ldhu	r2,54(r2)
811102b0:	10bfffcc 	andi	r2,r2,65535
811102b4:	108000e8 	cmpgeui	r2,r2,3
811102b8:	1000091e 	bne	r2,zero,811102e0 <vQCmdFeeRMAPinFullPattern+0x5c>
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (FullPattern)\n", pxNFeeP->ucId);
811102bc:	d0e06217 	ldw	r3,-32376(gp)
811102c0:	e0bffe17 	ldw	r2,-8(fp)
811102c4:	10800003 	ldbu	r2,0(r2)
811102c8:	10803fcc 	andi	r2,r2,255
811102cc:	100d883a 	mov	r6,r2
811102d0:	01604574 	movhi	r5,33045
811102d4:	29780d04 	addi	r5,r5,-8140
811102d8:	1809883a 	mov	r4,r3
811102dc:	112292c0 	call	8112292c <fprintf>
	}
	#endif

	uiCmdFEEL.ulWord = cmd;
811102e0:	e0bfff17 	ldw	r2,-4(fp)
811102e4:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
811102e8:	e0bffd43 	ldbu	r2,-11(fp)
811102ec:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
811102f0:	e0bffe17 	ldw	r2,-8(fp)
811102f4:	10804317 	ldw	r2,268(r2)
811102f8:	e0fffa03 	ldbu	r3,-24(fp)
811102fc:	180b883a 	mov	r5,r3
81110300:	1009883a 	mov	r4,r2
81110304:	1109e0c0 	call	81109e0c <uliRmapReadReg>
81110308:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
8111030c:	e0bffa03 	ldbu	r2,-24(fp)
81110310:	10bff004 	addi	r2,r2,-64
81110314:	10c003a8 	cmpgeui	r3,r2,14
81110318:	1801381e 	bne	r3,zero,811107fc <vQCmdFeeRMAPinFullPattern+0x578>
8111031c:	100690ba 	slli	r3,r2,2
81110320:	00a04474 	movhi	r2,33041
81110324:	1080cd04 	addi	r2,r2,820
81110328:	1885883a 	add	r2,r3,r2
8111032c:	10800017 	ldw	r2,0(r2)
81110330:	1000683a 	jmp	r2
81110334:	8111036c 	andhi	r4,r16,17421
81110338:	8111036c 	andhi	r4,r16,17421
8111033c:	8111036c 	andhi	r4,r16,17421
81110340:	811105c4 	addi	r4,r16,17431
81110344:	811105c4 	addi	r4,r16,17431
81110348:	811105c4 	addi	r4,r16,17431
8111034c:	811105c4 	addi	r4,r16,17431
81110350:	811105c4 	addi	r4,r16,17431
81110354:	811105c4 	addi	r4,r16,17431
81110358:	811105c4 	addi	r4,r16,17431
8111035c:	811105c4 	addi	r4,r16,17431
81110360:	811105c4 	addi	r4,r16,17431
81110364:	811105fc 	xorhi	r4,r16,17431
81110368:	8111077c 	xorhi	r4,r16,17437
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config
			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
8111036c:	e0bffe17 	ldw	r2,-8(fp)
81110370:	10802d17 	ldw	r2,180(r2)
81110374:	108001e0 	cmpeqi	r2,r2,7
81110378:	1000041e 	bne	r2,zero,8111038c <vQCmdFeeRMAPinFullPattern+0x108>
8111037c:	e0bffe17 	ldw	r2,-8(fp)
81110380:	10802d17 	ldw	r2,180(r2)
81110384:	10800318 	cmpnei	r2,r2,12
81110388:	1000771e 	bne	r2,zero,81110568 <vQCmdFeeRMAPinFullPattern+0x2e4>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8111038c:	e0bffa43 	ldbu	r2,-23(fp)
81110390:	1080030c 	andi	r2,r2,12
81110394:	1005d0ba 	srai	r2,r2,2
81110398:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
8111039c:	e0bffb17 	ldw	r2,-20(fp)
811103a0:	10c000a0 	cmpeqi	r3,r2,2
811103a4:	1800141e 	bne	r3,zero,811103f8 <vQCmdFeeRMAPinFullPattern+0x174>
811103a8:	10c000e0 	cmpeqi	r3,r2,3
811103ac:	1800231e 	bne	r3,zero,8111043c <vQCmdFeeRMAPinFullPattern+0x1b8>
811103b0:	10800060 	cmpeqi	r2,r2,1
811103b4:	10003026 	beq	r2,zero,81110478 <vQCmdFeeRMAPinFullPattern+0x1f4>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
811103b8:	e0bffe17 	ldw	r2,-8(fp)
811103bc:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811103c0:	00a045b4 	movhi	r2,33046
811103c4:	109fe204 	addi	r2,r2,32648
811103c8:	10800d8b 	ldhu	r2,54(r2)
811103cc:	10bfffcc 	andi	r2,r2,65535
811103d0:	108000e8 	cmpgeui	r2,r2,3
811103d4:	1000461e 	bne	r2,zero,811104f0 <vQCmdFeeRMAPinFullPattern+0x26c>
							fprintf(fp," - Left side\n");
811103d8:	d0a06217 	ldw	r2,-32376(gp)
811103dc:	100f883a 	mov	r7,r2
811103e0:	01800344 	movi	r6,13
811103e4:	01400044 	movi	r5,1
811103e8:	01204574 	movhi	r4,33045
811103ec:	2137a604 	addi	r4,r4,-8552
811103f0:	1122fc80 	call	81122fc8 <fwrite>
						}
						#endif
						break;
811103f4:	00003e06 	br	811104f0 <vQCmdFeeRMAPinFullPattern+0x26c>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
811103f8:	e0bffe17 	ldw	r2,-8(fp)
811103fc:	00c00044 	movi	r3,1
81110400:	10c02e15 	stw	r3,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110404:	00a045b4 	movhi	r2,33046
81110408:	109fe204 	addi	r2,r2,32648
8111040c:	10800d8b 	ldhu	r2,54(r2)
81110410:	10bfffcc 	andi	r2,r2,65535
81110414:	108000e8 	cmpgeui	r2,r2,3
81110418:	1000371e 	bne	r2,zero,811104f8 <vQCmdFeeRMAPinFullPattern+0x274>
							fprintf(fp," - Right side\n");
8111041c:	d0a06217 	ldw	r2,-32376(gp)
81110420:	100f883a 	mov	r7,r2
81110424:	01800384 	movi	r6,14
81110428:	01400044 	movi	r5,1
8111042c:	01204574 	movhi	r4,33045
81110430:	2137aa04 	addi	r4,r4,-8536
81110434:	1122fc80 	call	81122fc8 <fwrite>
						}
						#endif
						break;
81110438:	00002f06 	br	811104f8 <vQCmdFeeRMAPinFullPattern+0x274>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
8111043c:	e0bffe17 	ldw	r2,-8(fp)
81110440:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110444:	00a045b4 	movhi	r2,33046
81110448:	109fe204 	addi	r2,r2,32648
8111044c:	10800d8b 	ldhu	r2,54(r2)
81110450:	10bfffcc 	andi	r2,r2,65535
81110454:	108000e8 	cmpgeui	r2,r2,3
81110458:	1000071e 	bne	r2,zero,81110478 <vQCmdFeeRMAPinFullPattern+0x1f4>
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8111045c:	d0a06217 	ldw	r2,-32376(gp)
81110460:	100f883a 	mov	r7,r2
81110464:	01800f44 	movi	r6,61
81110468:	01400044 	movi	r5,1
8111046c:	01204574 	movhi	r4,33045
81110470:	2137ae04 	addi	r4,r4,-8520
81110474:	1122fc80 	call	81122fc8 <fwrite>
						}
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
81110478:	e0bffe17 	ldw	r2,-8(fp)
8111047c:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110480:	e0bffe17 	ldw	r2,-8(fp)
81110484:	10804304 	addi	r2,r2,268
81110488:	1009883a 	mov	r4,r2
8111048c:	11080940 	call	81108094 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
81110490:	e0bffe17 	ldw	r2,-8(fp)
81110494:	10c05717 	ldw	r3,348(r2)
81110498:	00bffdc4 	movi	r2,-9
8111049c:	1886703a 	and	r3,r3,r2
811104a0:	e0bffe17 	ldw	r2,-8(fp)
811104a4:	10c05715 	stw	r3,348(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
811104a8:	e0bffe17 	ldw	r2,-8(fp)
811104ac:	10804304 	addi	r2,r2,268
811104b0:	1009883a 	mov	r4,r2
811104b4:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811104b8:	00a045b4 	movhi	r2,33046
811104bc:	109fe204 	addi	r2,r2,32648
811104c0:	10800d8b 	ldhu	r2,54(r2)
811104c4:	10bfffcc 	andi	r2,r2,65535
811104c8:	108000e8 	cmpgeui	r2,r2,3
811104cc:	10000c1e 	bne	r2,zero,81110500 <vQCmdFeeRMAPinFullPattern+0x27c>
							fprintf(fp," - Switching to Left side\n");
811104d0:	d0a06217 	ldw	r2,-32376(gp)
811104d4:	100f883a 	mov	r7,r2
811104d8:	01800684 	movi	r6,26
811104dc:	01400044 	movi	r5,1
811104e0:	01204574 	movhi	r4,33045
811104e4:	2137be04 	addi	r4,r4,-8456
811104e8:	1122fc80 	call	81122fc8 <fwrite>
						}
						#endif
					break;
811104ec:	00000406 	br	81110500 <vQCmdFeeRMAPinFullPattern+0x27c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Left side\n");
						}
						#endif
						break;
811104f0:	0001883a 	nop
811104f4:	00000306 	br	81110504 <vQCmdFeeRMAPinFullPattern+0x280>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Right side\n");
						}
						#endif
						break;
811104f8:	0001883a 	nop
811104fc:	00000106 	br	81110504 <vQCmdFeeRMAPinFullPattern+0x280>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Switching to Left side\n");
						}
						#endif
					break;
81110500:	0001883a 	nop
				}
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110504:	00a045b4 	movhi	r2,33046
81110508:	109fe204 	addi	r2,r2,32648
8111050c:	10800d8b 	ldhu	r2,54(r2)
81110510:	10bfffcc 	andi	r2,r2,65535
81110514:	10800168 	cmpgeui	r2,r2,5
81110518:	10000c1e 	bne	r2,zero,8111054c <vQCmdFeeRMAPinFullPattern+0x2c8>
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
8111051c:	d0e06217 	ldw	r3,-32376(gp)
81110520:	e0bffe17 	ldw	r2,-8(fp)
81110524:	10800003 	ldbu	r2,0(r2)
81110528:	11003fcc 	andi	r4,r2,255
8111052c:	e0bffe17 	ldw	r2,-8(fp)
81110530:	10802e17 	ldw	r2,184(r2)
81110534:	100f883a 	mov	r7,r2
81110538:	200d883a 	mov	r6,r4
8111053c:	01604574 	movhi	r5,33045
81110540:	2977c504 	addi	r5,r5,-8428
81110544:	1809883a 	mov	r4,r3
81110548:	112292c0 	call	8112292c <fprintf>
				}
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
8111054c:	e0bffe17 	ldw	r2,-8(fp)
81110550:	00c00284 	movi	r3,10
81110554:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
81110558:	e0bffe17 	ldw	r2,-8(fp)
8111055c:	00c00304 	movi	r3,12
81110560:	10c02d15 	stw	r3,180(r2)
				}
			}



			break;
81110564:	0000b306 	br	81110834 <vQCmdFeeRMAPinFullPattern+0x5b0>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
81110568:	e0bffe17 	ldw	r2,-8(fp)
8111056c:	10802d17 	ldw	r2,180(r2)
81110570:	10800118 	cmpnei	r2,r2,4
81110574:	1000af1e 	bne	r2,zero,81110834 <vQCmdFeeRMAPinFullPattern+0x5b0>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110578:	00a045b4 	movhi	r2,33046
8111057c:	109fe204 	addi	r2,r2,32648
81110580:	10800d8b 	ldhu	r2,54(r2)
81110584:	10bfffcc 	andi	r2,r2,65535
81110588:	10800168 	cmpgeui	r2,r2,5
8111058c:	1000a91e 	bne	r2,zero,81110834 <vQCmdFeeRMAPinFullPattern+0x5b0>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110590:	d0e06217 	ldw	r3,-32376(gp)
81110594:	e0bffe17 	ldw	r2,-8(fp)
81110598:	10800003 	ldbu	r2,0(r2)
8111059c:	11003fcc 	andi	r4,r2,255
811105a0:	e0bffe17 	ldw	r2,-8(fp)
811105a4:	10802e17 	ldw	r2,184(r2)
811105a8:	100f883a 	mov	r7,r2
811105ac:	200d883a 	mov	r6,r4
811105b0:	01604574 	movhi	r5,33045
811105b4:	29781a04 	addi	r5,r5,-8088
811105b8:	1809883a 	mov	r4,r3
811105bc:	112292c0 	call	8112292c <fprintf>
				}
			}



			break;
811105c0:	00009c06 	br	81110834 <vQCmdFeeRMAPinFullPattern+0x5b0>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811105c4:	00a045b4 	movhi	r2,33046
811105c8:	109fe204 	addi	r2,r2,32648
811105cc:	10800d8b 	ldhu	r2,54(r2)
811105d0:	10bfffcc 	andi	r2,r2,65535
811105d4:	10800168 	cmpgeui	r2,r2,5
811105d8:	1000981e 	bne	r2,zero,8111083c <vQCmdFeeRMAPinFullPattern+0x5b8>
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
811105dc:	d0a06217 	ldw	r2,-32376(gp)
811105e0:	e0fffa03 	ldbu	r3,-24(fp)
811105e4:	180d883a 	mov	r6,r3
811105e8:	01604574 	movhi	r5,33045
811105ec:	29780404 	addi	r5,r5,-8176
811105f0:	1009883a 	mov	r4,r2
811105f4:	112292c0 	call	8112292c <fprintf>
			}
			#endif
				break;
811105f8:	00009006 	br	8111083c <vQCmdFeeRMAPinFullPattern+0x5b8>

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
811105fc:	e0bffa43 	ldbu	r2,-23(fp)
81110600:	1004d13a 	srli	r2,r2,4
81110604:	10803fcc 	andi	r2,r2,255
81110608:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked) {
8111060c:	e0bffc17 	ldw	r2,-16(fp)
81110610:	10c000a0 	cmpeqi	r3,r2,2
81110614:	1800281e 	bne	r3,zero,811106b8 <vQCmdFeeRMAPinFullPattern+0x434>
81110618:	10c001a0 	cmpeqi	r3,r2,6
8111061c:	1800361e 	bne	r3,zero,811106f8 <vQCmdFeeRMAPinFullPattern+0x474>
81110620:	1000431e 	bne	r2,zero,81110730 <vQCmdFeeRMAPinFullPattern+0x4ac>
				case 0: /* Standby */
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110624:	00a045b4 	movhi	r2,33046
81110628:	109fe204 	addi	r2,r2,32648
8111062c:	10800d8b 	ldhu	r2,54(r2)
81110630:	10bfffcc 	andi	r2,r2,65535
81110634:	108000e8 	cmpgeui	r2,r2,3
81110638:	1000071e 	bne	r2,zero,81110658 <vQCmdFeeRMAPinFullPattern+0x3d4>
						fprintf(fp,"- to Stand-By\n");
8111063c:	d0a06217 	ldw	r2,-32376(gp)
81110640:	100f883a 	mov	r7,r2
81110644:	01800384 	movi	r6,14
81110648:	01400044 	movi	r5,1
8111064c:	01204574 	movhi	r4,33045
81110650:	21383104 	addi	r4,r4,-7996
81110654:	1122fc80 	call	81122fc8 <fwrite>
					}
				#endif

					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
81110658:	e0bffe17 	ldw	r2,-8(fp)
8111065c:	10802c17 	ldw	r2,176(r2)
81110660:	10800298 	cmpnei	r2,r2,10
81110664:	10000a1e 	bne	r2,zero,81110690 <vQCmdFeeRMAPinFullPattern+0x40c>
						pxNFeeP->xControl.bWatingSync = TRUE;
81110668:	e0bffe17 	ldw	r2,-8(fp)
8111066c:	00c00044 	movi	r3,1
81110670:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
81110674:	e0bffe17 	ldw	r2,-8(fp)
81110678:	00c00304 	movi	r3,12
8111067c:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110680:	e0bffe17 	ldw	r2,-8(fp)
81110684:	00c00184 	movi	r3,6
81110688:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
8111068c:	00003a06 	br	81110778 <vQCmdFeeRMAPinFullPattern+0x4f4>
					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
						pxNFeeP->xControl.bWatingSync = TRUE;
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
					} else {
						pxNFeeP->xControl.bWatingSync = TRUE;
81110690:	e0bffe17 	ldw	r2,-8(fp)
81110694:	00c00044 	movi	r3,1
81110698:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8111069c:	e0bffe17 	ldw	r2,-8(fp)
811106a0:	00c00104 	movi	r3,4
811106a4:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
811106a8:	e0bffe17 	ldw	r2,-8(fp)
811106ac:	00c00184 	movi	r3,6
811106b0:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
811106b4:	00003006 	br	81110778 <vQCmdFeeRMAPinFullPattern+0x4f4>
				case 2: /* PAttern Full image */
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811106b8:	00a045b4 	movhi	r2,33046
811106bc:	109fe204 	addi	r2,r2,32648
811106c0:	10800d8b 	ldhu	r2,54(r2)
811106c4:	10bfffcc 	andi	r2,r2,65535
811106c8:	10800168 	cmpgeui	r2,r2,5
811106cc:	1000251e 	bne	r2,zero,81110764 <vQCmdFeeRMAPinFullPattern+0x4e0>
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
811106d0:	d0e06217 	ldw	r3,-32376(gp)
811106d4:	e0bffe17 	ldw	r2,-8(fp)
811106d8:	10800003 	ldbu	r2,0(r2)
811106dc:	10803fcc 	andi	r2,r2,255
811106e0:	100d883a 	mov	r6,r2
811106e4:	01604574 	movhi	r5,33045
811106e8:	29777604 	addi	r5,r5,-8744
811106ec:	1809883a 	mov	r4,r3
811106f0:	112292c0 	call	8112292c <fprintf>
					}
					#endif

					break;
811106f4:	00001b06 	br	81110764 <vQCmdFeeRMAPinFullPattern+0x4e0>
				case 6:
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811106f8:	00a045b4 	movhi	r2,33046
811106fc:	109fe204 	addi	r2,r2,32648
81110700:	10800d8b 	ldhu	r2,54(r2)
81110704:	10bfffcc 	andi	r2,r2,65535
81110708:	10800168 	cmpgeui	r2,r2,5
8111070c:	1000171e 	bne	r2,zero,8111076c <vQCmdFeeRMAPinFullPattern+0x4e8>
						fprintf(fp," Off-Mode not allowed.\n");
81110710:	d0a06217 	ldw	r2,-32376(gp)
81110714:	100f883a 	mov	r7,r2
81110718:	018005c4 	movi	r6,23
8111071c:	01400044 	movi	r5,1
81110720:	01204574 	movhi	r4,33045
81110724:	21383504 	addi	r4,r4,-7980
81110728:	1122fc80 	call	81122fc8 <fwrite>
					}
				#endif
					break;
8111072c:	00000f06 	br	8111076c <vQCmdFeeRMAPinFullPattern+0x4e8>
				case 3:
				case 4:
				case 5:
				default:
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110730:	00a045b4 	movhi	r2,33046
81110734:	109fe204 	addi	r2,r2,32648
81110738:	10800d8b 	ldhu	r2,54(r2)
8111073c:	10bfffcc 	andi	r2,r2,65535
81110740:	10800168 	cmpgeui	r2,r2,5
81110744:	10000b1e 	bne	r2,zero,81110774 <vQCmdFeeRMAPinFullPattern+0x4f0>
						fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
81110748:	d0a06217 	ldw	r2,-32376(gp)
8111074c:	e1bffc17 	ldw	r6,-16(fp)
81110750:	01604574 	movhi	r5,33045
81110754:	29783b04 	addi	r5,r5,-7956
81110758:	1009883a 	mov	r4,r2
8111075c:	112292c0 	call	8112292c <fprintf>
					}
					#endif
					break;
81110760:	00000406 	br	81110774 <vQCmdFeeRMAPinFullPattern+0x4f0>
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
					}
					#endif

					break;
81110764:	0001883a 	nop
81110768:	00003906 	br	81110850 <vQCmdFeeRMAPinFullPattern+0x5cc>
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp," Off-Mode not allowed.\n");
					}
				#endif
					break;
8111076c:	0001883a 	nop
81110770:	00003706 	br	81110850 <vQCmdFeeRMAPinFullPattern+0x5cc>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
					}
					#endif
					break;
81110774:	0001883a 	nop
			}

			break;
81110778:	00003506 	br	81110850 <vQCmdFeeRMAPinFullPattern+0x5cc>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8111077c:	e0bffa43 	ldbu	r2,-23(fp)
81110780:	1080010c 	andi	r2,r2,4
81110784:	10803fcc 	andi	r2,r2,255
81110788:	1004d0ba 	srli	r2,r2,2
8111078c:	10803fcc 	andi	r2,r2,255
81110790:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
81110794:	e0bffc17 	ldw	r2,-16(fp)
81110798:	10002a26 	beq	r2,zero,81110844 <vQCmdFeeRMAPinFullPattern+0x5c0>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
8111079c:	e0bffe17 	ldw	r2,-8(fp)
811107a0:	10802d17 	ldw	r2,180(r2)
811107a4:	10800198 	cmpnei	r2,r2,6
811107a8:	1000261e 	bne	r2,zero,81110844 <vQCmdFeeRMAPinFullPattern+0x5c0>
					pxNFeeP->xControl.bWatingSync = FALSE;
811107ac:	e0bffe17 	ldw	r2,-8(fp)
811107b0:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
811107b4:	e0bffe17 	ldw	r2,-8(fp)
811107b8:	10c02d17 	ldw	r3,180(r2)
811107bc:	e0bffe17 	ldw	r2,-8(fp)
811107c0:	10c02c15 	stw	r3,176(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811107c4:	00a045b4 	movhi	r2,33046
811107c8:	109fe204 	addi	r2,r2,32648
811107cc:	10800d8b 	ldhu	r2,54(r2)
811107d0:	10bfffcc 	andi	r2,r2,65535
811107d4:	10800168 	cmpgeui	r2,r2,5
811107d8:	10001a1e 	bne	r2,zero,81110844 <vQCmdFeeRMAPinFullPattern+0x5c0>
						fprintf(fp," - Mode Forced.\n");
811107dc:	d0a06217 	ldw	r2,-32376(gp)
811107e0:	100f883a 	mov	r7,r2
811107e4:	01800404 	movi	r6,16
811107e8:	01400044 	movi	r5,1
811107ec:	01204574 	movhi	r4,33045
811107f0:	21384304 	addi	r4,r4,-7924
811107f4:	1122fc80 	call	81122fc8 <fwrite>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
811107f8:	00001206 	br	81110844 <vQCmdFeeRMAPinFullPattern+0x5c0>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811107fc:	00a045b4 	movhi	r2,33046
81110800:	109fe204 	addi	r2,r2,32648
81110804:	10800d8b 	ldhu	r2,54(r2)
81110808:	10bfffcc 	andi	r2,r2,65535
8111080c:	10800228 	cmpgeui	r2,r2,8
81110810:	10000e1e 	bne	r2,zero,8111084c <vQCmdFeeRMAPinFullPattern+0x5c8>
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
81110814:	d0a06217 	ldw	r2,-32376(gp)
81110818:	e0fffa03 	ldbu	r3,-24(fp)
8111081c:	180d883a 	mov	r6,r3
81110820:	01604574 	movhi	r5,33045
81110824:	2977d304 	addi	r5,r5,-8372
81110828:	1009883a 	mov	r4,r2
8111082c:	112292c0 	call	8112292c <fprintf>
			}
			#endif
			break;
81110830:	00000606 	br	8111084c <vQCmdFeeRMAPinFullPattern+0x5c8>
				}
			}



			break;
81110834:	0001883a 	nop
81110838:	00000506 	br	81110850 <vQCmdFeeRMAPinFullPattern+0x5cc>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
				break;
8111083c:	0001883a 	nop
81110840:	00000306 	br	81110850 <vQCmdFeeRMAPinFullPattern+0x5cc>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
81110844:	0001883a 	nop
81110848:	00000106 	br	81110850 <vQCmdFeeRMAPinFullPattern+0x5cc>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
8111084c:	0001883a 	nop
		}
}
81110850:	0001883a 	nop
81110854:	e037883a 	mov	sp,fp
81110858:	dfc00117 	ldw	ra,4(sp)
8111085c:	df000017 	ldw	fp,0(sp)
81110860:	dec00204 	addi	sp,sp,8
81110864:	f800283a 	ret

81110868 <vQCmdFeeRMAPWaitingSync>:


void vQCmdFeeRMAPWaitingSync( TNFee *pxNFeeP, unsigned int cmd ){
81110868:	defff804 	addi	sp,sp,-32
8111086c:	de00012e 	bgeu	sp,et,81110874 <vQCmdFeeRMAPWaitingSync+0xc>
81110870:	003b68fa 	trap	3
81110874:	dfc00715 	stw	ra,28(sp)
81110878:	df000615 	stw	fp,24(sp)
8111087c:	df000604 	addi	fp,sp,24
81110880:	e13ffe15 	stw	r4,-8(fp)
81110884:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110888:	00a045b4 	movhi	r2,33046
8111088c:	109fe204 	addi	r2,r2,32648
81110890:	10800d8b 	ldhu	r2,54(r2)
81110894:	10bfffcc 	andi	r2,r2,65535
81110898:	108000e8 	cmpgeui	r2,r2,3
8111089c:	1000091e 	bne	r2,zero,811108c4 <vQCmdFeeRMAPWaitingSync+0x5c>
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (WaitingSync)\n", pxNFeeP->ucId);
811108a0:	d0e06217 	ldw	r3,-32376(gp)
811108a4:	e0bffe17 	ldw	r2,-8(fp)
811108a8:	10800003 	ldbu	r2,0(r2)
811108ac:	10803fcc 	andi	r2,r2,255
811108b0:	100d883a 	mov	r6,r2
811108b4:	01604574 	movhi	r5,33045
811108b8:	29784804 	addi	r5,r5,-7904
811108bc:	1809883a 	mov	r4,r3
811108c0:	112292c0 	call	8112292c <fprintf>
	}
	#endif

	uiCmdFEEL.ulWord = cmd;
811108c4:	e0bfff17 	ldw	r2,-4(fp)
811108c8:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
811108cc:	e0bffd43 	ldbu	r2,-11(fp)
811108d0:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
811108d4:	e0bffe17 	ldw	r2,-8(fp)
811108d8:	10804317 	ldw	r2,268(r2)
811108dc:	e0fffa03 	ldbu	r3,-24(fp)
811108e0:	180b883a 	mov	r5,r3
811108e4:	1009883a 	mov	r4,r2
811108e8:	1109e0c0 	call	81109e0c <uliRmapReadReg>
811108ec:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
811108f0:	e0bffa03 	ldbu	r2,-24(fp)
811108f4:	10c010c8 	cmpgei	r3,r2,67
811108f8:	1800051e 	bne	r3,zero,81110910 <vQCmdFeeRMAPWaitingSync+0xa8>
811108fc:	10c01008 	cmpgei	r3,r2,64
81110900:	1800081e 	bne	r3,zero,81110924 <vQCmdFeeRMAPWaitingSync+0xbc>
81110904:	108000a0 	cmpeqi	r2,r2,2
81110908:	1000e61e 	bne	r2,zero,81110ca4 <vQCmdFeeRMAPWaitingSync+0x43c>
8111090c:	00011e06 	br	81110d88 <vQCmdFeeRMAPWaitingSync+0x520>
81110910:	10c01350 	cmplti	r3,r2,77
81110914:	1800991e 	bne	r3,zero,81110b7c <vQCmdFeeRMAPWaitingSync+0x314>
81110918:	10801360 	cmpeqi	r2,r2,77
8111091c:	1000fa1e 	bne	r2,zero,81110d08 <vQCmdFeeRMAPWaitingSync+0x4a0>
81110920:	00011906 	br	81110d88 <vQCmdFeeRMAPWaitingSync+0x520>
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config

			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
81110924:	e0bffe17 	ldw	r2,-8(fp)
81110928:	10802d17 	ldw	r2,180(r2)
8111092c:	108001e0 	cmpeqi	r2,r2,7
81110930:	1000041e 	bne	r2,zero,81110944 <vQCmdFeeRMAPWaitingSync+0xdc>
81110934:	e0bffe17 	ldw	r2,-8(fp)
81110938:	10802d17 	ldw	r2,180(r2)
8111093c:	10800318 	cmpnei	r2,r2,12
81110940:	1000771e 	bne	r2,zero,81110b20 <vQCmdFeeRMAPWaitingSync+0x2b8>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
81110944:	e0bffa43 	ldbu	r2,-23(fp)
81110948:	1080030c 	andi	r2,r2,12
8111094c:	1005d0ba 	srai	r2,r2,2
81110950:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
81110954:	e0bffb17 	ldw	r2,-20(fp)
81110958:	10c000a0 	cmpeqi	r3,r2,2
8111095c:	1800141e 	bne	r3,zero,811109b0 <vQCmdFeeRMAPWaitingSync+0x148>
81110960:	10c000e0 	cmpeqi	r3,r2,3
81110964:	1800231e 	bne	r3,zero,811109f4 <vQCmdFeeRMAPWaitingSync+0x18c>
81110968:	10800060 	cmpeqi	r2,r2,1
8111096c:	10003026 	beq	r2,zero,81110a30 <vQCmdFeeRMAPWaitingSync+0x1c8>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
81110970:	e0bffe17 	ldw	r2,-8(fp)
81110974:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110978:	00a045b4 	movhi	r2,33046
8111097c:	109fe204 	addi	r2,r2,32648
81110980:	10800d8b 	ldhu	r2,54(r2)
81110984:	10bfffcc 	andi	r2,r2,65535
81110988:	108000e8 	cmpgeui	r2,r2,3
8111098c:	1000461e 	bne	r2,zero,81110aa8 <vQCmdFeeRMAPWaitingSync+0x240>
							fprintf(fp," - Left side\n");
81110990:	d0a06217 	ldw	r2,-32376(gp)
81110994:	100f883a 	mov	r7,r2
81110998:	01800344 	movi	r6,13
8111099c:	01400044 	movi	r5,1
811109a0:	01204574 	movhi	r4,33045
811109a4:	2137a604 	addi	r4,r4,-8552
811109a8:	1122fc80 	call	81122fc8 <fwrite>
						}
						#endif
						break;
811109ac:	00003e06 	br	81110aa8 <vQCmdFeeRMAPWaitingSync+0x240>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
811109b0:	e0bffe17 	ldw	r2,-8(fp)
811109b4:	00c00044 	movi	r3,1
811109b8:	10c02e15 	stw	r3,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811109bc:	00a045b4 	movhi	r2,33046
811109c0:	109fe204 	addi	r2,r2,32648
811109c4:	10800d8b 	ldhu	r2,54(r2)
811109c8:	10bfffcc 	andi	r2,r2,65535
811109cc:	108000e8 	cmpgeui	r2,r2,3
811109d0:	1000371e 	bne	r2,zero,81110ab0 <vQCmdFeeRMAPWaitingSync+0x248>
							fprintf(fp," - Right side\n");
811109d4:	d0a06217 	ldw	r2,-32376(gp)
811109d8:	100f883a 	mov	r7,r2
811109dc:	01800384 	movi	r6,14
811109e0:	01400044 	movi	r5,1
811109e4:	01204574 	movhi	r4,33045
811109e8:	2137aa04 	addi	r4,r4,-8536
811109ec:	1122fc80 	call	81122fc8 <fwrite>
						}
						#endif
						break;
811109f0:	00002f06 	br	81110ab0 <vQCmdFeeRMAPWaitingSync+0x248>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
811109f4:	e0bffe17 	ldw	r2,-8(fp)
811109f8:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811109fc:	00a045b4 	movhi	r2,33046
81110a00:	109fe204 	addi	r2,r2,32648
81110a04:	10800d8b 	ldhu	r2,54(r2)
81110a08:	10bfffcc 	andi	r2,r2,65535
81110a0c:	10800168 	cmpgeui	r2,r2,5
81110a10:	1000071e 	bne	r2,zero,81110a30 <vQCmdFeeRMAPWaitingSync+0x1c8>
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
81110a14:	d0a06217 	ldw	r2,-32376(gp)
81110a18:	100f883a 	mov	r7,r2
81110a1c:	01800f44 	movi	r6,61
81110a20:	01400044 	movi	r5,1
81110a24:	01204574 	movhi	r4,33045
81110a28:	2137ae04 	addi	r4,r4,-8520
81110a2c:	1122fc80 	call	81122fc8 <fwrite>
						}
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
81110a30:	e0bffe17 	ldw	r2,-8(fp)
81110a34:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110a38:	e0bffe17 	ldw	r2,-8(fp)
81110a3c:	10804304 	addi	r2,r2,268
81110a40:	1009883a 	mov	r4,r2
81110a44:	11080940 	call	81108094 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
81110a48:	e0bffe17 	ldw	r2,-8(fp)
81110a4c:	10c05717 	ldw	r3,348(r2)
81110a50:	00bffdc4 	movi	r2,-9
81110a54:	1886703a 	and	r3,r3,r2
81110a58:	e0bffe17 	ldw	r2,-8(fp)
81110a5c:	10c05715 	stw	r3,348(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110a60:	e0bffe17 	ldw	r2,-8(fp)
81110a64:	10804304 	addi	r2,r2,268
81110a68:	1009883a 	mov	r4,r2
81110a6c:	1107da80 	call	81107da8 <bRmapSetMemConfigArea>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110a70:	00a045b4 	movhi	r2,33046
81110a74:	109fe204 	addi	r2,r2,32648
81110a78:	10800d8b 	ldhu	r2,54(r2)
81110a7c:	10bfffcc 	andi	r2,r2,65535
81110a80:	108000e8 	cmpgeui	r2,r2,3
81110a84:	10000c1e 	bne	r2,zero,81110ab8 <vQCmdFeeRMAPWaitingSync+0x250>
							fprintf(fp," - Switching to Left side\n");
81110a88:	d0a06217 	ldw	r2,-32376(gp)
81110a8c:	100f883a 	mov	r7,r2
81110a90:	01800684 	movi	r6,26
81110a94:	01400044 	movi	r5,1
81110a98:	01204574 	movhi	r4,33045
81110a9c:	2137be04 	addi	r4,r4,-8456
81110aa0:	1122fc80 	call	81122fc8 <fwrite>
						}
						#endif
					break;
81110aa4:	00000406 	br	81110ab8 <vQCmdFeeRMAPWaitingSync+0x250>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Left side\n");
						}
						#endif
						break;
81110aa8:	0001883a 	nop
81110aac:	00000306 	br	81110abc <vQCmdFeeRMAPWaitingSync+0x254>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Right side\n");
						}
						#endif
						break;
81110ab0:	0001883a 	nop
81110ab4:	00000106 	br	81110abc <vQCmdFeeRMAPWaitingSync+0x254>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Switching to Left side\n");
						}
						#endif
					break;
81110ab8:	0001883a 	nop
				}
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110abc:	00a045b4 	movhi	r2,33046
81110ac0:	109fe204 	addi	r2,r2,32648
81110ac4:	10800d8b 	ldhu	r2,54(r2)
81110ac8:	10bfffcc 	andi	r2,r2,65535
81110acc:	10800168 	cmpgeui	r2,r2,5
81110ad0:	10000c1e 	bne	r2,zero,81110b04 <vQCmdFeeRMAPWaitingSync+0x29c>
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110ad4:	d0e06217 	ldw	r3,-32376(gp)
81110ad8:	e0bffe17 	ldw	r2,-8(fp)
81110adc:	10800003 	ldbu	r2,0(r2)
81110ae0:	11003fcc 	andi	r4,r2,255
81110ae4:	e0bffe17 	ldw	r2,-8(fp)
81110ae8:	10802e17 	ldw	r2,184(r2)
81110aec:	100f883a 	mov	r7,r2
81110af0:	200d883a 	mov	r6,r4
81110af4:	01604574 	movhi	r5,33045
81110af8:	2977c504 	addi	r5,r5,-8428
81110afc:	1809883a 	mov	r4,r3
81110b00:	112292c0 	call	8112292c <fprintf>
				}
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
81110b04:	e0bffe17 	ldw	r2,-8(fp)
81110b08:	00c00284 	movi	r3,10
81110b0c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
81110b10:	e0bffe17 	ldw	r2,-8(fp)
81110b14:	00c00304 	movi	r3,12
81110b18:	10c02d15 	stw	r3,180(r2)
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					}
					#endif
				}
			}
			break;
81110b1c:	0000a806 	br	81110dc0 <vQCmdFeeRMAPWaitingSync+0x558>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
81110b20:	e0bffe17 	ldw	r2,-8(fp)
81110b24:	10802d17 	ldw	r2,180(r2)
81110b28:	10800118 	cmpnei	r2,r2,4
81110b2c:	1000a41e 	bne	r2,zero,81110dc0 <vQCmdFeeRMAPWaitingSync+0x558>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81110b30:	00a045b4 	movhi	r2,33046
81110b34:	109fe204 	addi	r2,r2,32648
81110b38:	10800d8b 	ldhu	r2,54(r2)
81110b3c:	10bfffcc 	andi	r2,r2,65535
81110b40:	10800228 	cmpgeui	r2,r2,8
81110b44:	10009e1e 	bne	r2,zero,81110dc0 <vQCmdFeeRMAPWaitingSync+0x558>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110b48:	d0e06217 	ldw	r3,-32376(gp)
81110b4c:	e0bffe17 	ldw	r2,-8(fp)
81110b50:	10800003 	ldbu	r2,0(r2)
81110b54:	11003fcc 	andi	r4,r2,255
81110b58:	e0bffe17 	ldw	r2,-8(fp)
81110b5c:	10802e17 	ldw	r2,184(r2)
81110b60:	100f883a 	mov	r7,r2
81110b64:	200d883a 	mov	r6,r4
81110b68:	01604574 	movhi	r5,33045
81110b6c:	29781a04 	addi	r5,r5,-8088
81110b70:	1809883a 	mov	r4,r3
81110b74:	112292c0 	call	8112292c <fprintf>
					}
					#endif
				}
			}
			break;
81110b78:	00009106 	br	81110dc0 <vQCmdFeeRMAPWaitingSync+0x558>
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
		case 0x0000004C://0x00000038:operation_mode_config

		ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
81110b7c:	e0bffa43 	ldbu	r2,-23(fp)
81110b80:	1004d13a 	srli	r2,r2,4
81110b84:	10803fcc 	andi	r2,r2,255
81110b88:	e0bffc15 	stw	r2,-16(fp)

		switch (ucValueMasked) {
81110b8c:	e0bffc17 	ldw	r2,-16(fp)
81110b90:	10c000a0 	cmpeqi	r3,r2,2
81110b94:	18001a1e 	bne	r3,zero,81110c00 <vQCmdFeeRMAPWaitingSync+0x398>
81110b98:	10c001a0 	cmpeqi	r3,r2,6
81110b9c:	1800221e 	bne	r3,zero,81110c28 <vQCmdFeeRMAPWaitingSync+0x3c0>
81110ba0:	10002f1e 	bne	r2,zero,81110c60 <vQCmdFeeRMAPWaitingSync+0x3f8>
			case 0: /* Standby */
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81110ba4:	00a045b4 	movhi	r2,33046
81110ba8:	109fe204 	addi	r2,r2,32648
81110bac:	10800d8b 	ldhu	r2,54(r2)
81110bb0:	10bfffcc 	andi	r2,r2,65535
81110bb4:	108000e8 	cmpgeui	r2,r2,3
81110bb8:	1000071e 	bne	r2,zero,81110bd8 <vQCmdFeeRMAPWaitingSync+0x370>
					fprintf(fp,"- to Stand-By\n");
81110bbc:	d0a06217 	ldw	r2,-32376(gp)
81110bc0:	100f883a 	mov	r7,r2
81110bc4:	01800384 	movi	r6,14
81110bc8:	01400044 	movi	r5,1
81110bcc:	01204574 	movhi	r4,33045
81110bd0:	21383104 	addi	r4,r4,-7996
81110bd4:	1122fc80 	call	81122fc8 <fwrite>
				}
			#endif

				pxNFeeP->xControl.bWatingSync = TRUE;
81110bd8:	e0bffe17 	ldw	r2,-8(fp)
81110bdc:	00c00044 	movi	r3,1
81110be0:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
81110be4:	e0bffe17 	ldw	r2,-8(fp)
81110be8:	00c00304 	movi	r3,12
81110bec:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110bf0:	e0bffe17 	ldw	r2,-8(fp)
81110bf4:	00c00184 	movi	r3,6
81110bf8:	10c02d15 	stw	r3,180(r2)


				break;
81110bfc:	00002806 	br	81110ca0 <vQCmdFeeRMAPWaitingSync+0x438>
			case 2: /* PAttern Full image */

				pxNFeeP->xControl.bWatingSync = TRUE;
81110c00:	e0bffe17 	ldw	r2,-8(fp)
81110c04:	00c00044 	movi	r3,1
81110c08:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
81110c0c:	e0bffe17 	ldw	r2,-8(fp)
81110c10:	00c00304 	movi	r3,12
81110c14:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sNextPatternIteration;
81110c18:	e0bffe17 	ldw	r2,-8(fp)
81110c1c:	00c00284 	movi	r3,10
81110c20:	10c02d15 	stw	r3,180(r2)

				break;
81110c24:	00001e06 	br	81110ca0 <vQCmdFeeRMAPWaitingSync+0x438>
			case 6:
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110c28:	00a045b4 	movhi	r2,33046
81110c2c:	109fe204 	addi	r2,r2,32648
81110c30:	10800d8b 	ldhu	r2,54(r2)
81110c34:	10bfffcc 	andi	r2,r2,65535
81110c38:	10800168 	cmpgeui	r2,r2,5
81110c3c:	1000151e 	bne	r2,zero,81110c94 <vQCmdFeeRMAPWaitingSync+0x42c>
					fprintf(fp," Off-Mode not allowed.\n");
81110c40:	d0a06217 	ldw	r2,-32376(gp)
81110c44:	100f883a 	mov	r7,r2
81110c48:	018005c4 	movi	r6,23
81110c4c:	01400044 	movi	r5,1
81110c50:	01204574 	movhi	r4,33045
81110c54:	21383504 	addi	r4,r4,-7980
81110c58:	1122fc80 	call	81122fc8 <fwrite>
				}
			#endif
				break;
81110c5c:	00000d06 	br	81110c94 <vQCmdFeeRMAPWaitingSync+0x42c>
			case 3:
			case 4:
			case 5:
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110c60:	00a045b4 	movhi	r2,33046
81110c64:	109fe204 	addi	r2,r2,32648
81110c68:	10800d8b 	ldhu	r2,54(r2)
81110c6c:	10bfffcc 	andi	r2,r2,65535
81110c70:	10800168 	cmpgeui	r2,r2,5
81110c74:	1000091e 	bne	r2,zero,81110c9c <vQCmdFeeRMAPWaitingSync+0x434>
					fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
81110c78:	d0a06217 	ldw	r2,-32376(gp)
81110c7c:	e1bffc17 	ldw	r6,-16(fp)
81110c80:	01604574 	movhi	r5,33045
81110c84:	29783b04 	addi	r5,r5,-7956
81110c88:	1009883a 	mov	r4,r2
81110c8c:	112292c0 	call	8112292c <fprintf>
				}
				#endif
				break;
81110c90:	00000206 	br	81110c9c <vQCmdFeeRMAPWaitingSync+0x434>
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp," Off-Mode not allowed.\n");
				}
			#endif
				break;
81110c94:	0001883a 	nop
81110c98:	00004e06 	br	81110dd4 <vQCmdFeeRMAPWaitingSync+0x56c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
				}
				#endif
				break;
81110c9c:	0001883a 	nop
		}

			break;
81110ca0:	00004c06 	br	81110dd4 <vQCmdFeeRMAPWaitingSync+0x56c>
		case 2: /* PAttern Full image */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110ca4:	00a045b4 	movhi	r2,33046
81110ca8:	109fe204 	addi	r2,r2,32648
81110cac:	10800d8b 	ldhu	r2,54(r2)
81110cb0:	10bfffcc 	andi	r2,r2,65535
81110cb4:	10800168 	cmpgeui	r2,r2,5
81110cb8:	1000091e 	bne	r2,zero,81110ce0 <vQCmdFeeRMAPWaitingSync+0x478>
				fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
81110cbc:	d0e06217 	ldw	r3,-32376(gp)
81110cc0:	e0bffe17 	ldw	r2,-8(fp)
81110cc4:	10800003 	ldbu	r2,0(r2)
81110cc8:	10803fcc 	andi	r2,r2,255
81110ccc:	100d883a 	mov	r6,r2
81110cd0:	01604574 	movhi	r5,33045
81110cd4:	29777604 	addi	r5,r5,-8744
81110cd8:	1809883a 	mov	r4,r3
81110cdc:	112292c0 	call	8112292c <fprintf>
			}
			#endif

			pxNFeeP->xControl.bWatingSync = TRUE;
81110ce0:	e0bffe17 	ldw	r2,-8(fp)
81110ce4:	00c00044 	movi	r3,1
81110ce8:	10c02815 	stw	r3,160(r2)
			pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
81110cec:	e0bffe17 	ldw	r2,-8(fp)
81110cf0:	00c00284 	movi	r3,10
81110cf4:	10c02c15 	stw	r3,176(r2)
			pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
81110cf8:	e0bffe17 	ldw	r2,-8(fp)
81110cfc:	00c00304 	movi	r3,12
81110d00:	10c02d15 	stw	r3,180(r2)

			break;
81110d04:	00003306 	br	81110dd4 <vQCmdFeeRMAPWaitingSync+0x56c>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
81110d08:	e0bffa43 	ldbu	r2,-23(fp)
81110d0c:	1080010c 	andi	r2,r2,4
81110d10:	10803fcc 	andi	r2,r2,255
81110d14:	1004d0ba 	srli	r2,r2,2
81110d18:	10803fcc 	andi	r2,r2,255
81110d1c:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
81110d20:	e0bffc17 	ldw	r2,-16(fp)
81110d24:	10002826 	beq	r2,zero,81110dc8 <vQCmdFeeRMAPWaitingSync+0x560>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
81110d28:	e0bffe17 	ldw	r2,-8(fp)
81110d2c:	10802d17 	ldw	r2,180(r2)
81110d30:	10800198 	cmpnei	r2,r2,6
81110d34:	1000241e 	bne	r2,zero,81110dc8 <vQCmdFeeRMAPWaitingSync+0x560>
					pxNFeeP->xControl.bWatingSync = FALSE;
81110d38:	e0bffe17 	ldw	r2,-8(fp)
81110d3c:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
81110d40:	e0bffe17 	ldw	r2,-8(fp)
81110d44:	10c02d17 	ldw	r3,180(r2)
81110d48:	e0bffe17 	ldw	r2,-8(fp)
81110d4c:	10c02c15 	stw	r3,176(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81110d50:	00a045b4 	movhi	r2,33046
81110d54:	109fe204 	addi	r2,r2,32648
81110d58:	10800d8b 	ldhu	r2,54(r2)
81110d5c:	10bfffcc 	andi	r2,r2,65535
81110d60:	10800168 	cmpgeui	r2,r2,5
81110d64:	1000181e 	bne	r2,zero,81110dc8 <vQCmdFeeRMAPWaitingSync+0x560>
						fprintf(fp," - Mode Forced.\n");
81110d68:	d0a06217 	ldw	r2,-32376(gp)
81110d6c:	100f883a 	mov	r7,r2
81110d70:	01800404 	movi	r6,16
81110d74:	01400044 	movi	r5,1
81110d78:	01204574 	movhi	r4,33045
81110d7c:	21384304 	addi	r4,r4,-7924
81110d80:	1122fc80 	call	81122fc8 <fwrite>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110d84:	00001006 	br	81110dc8 <vQCmdFeeRMAPWaitingSync+0x560>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81110d88:	00a045b4 	movhi	r2,33046
81110d8c:	109fe204 	addi	r2,r2,32648
81110d90:	10800d8b 	ldhu	r2,54(r2)
81110d94:	10bfffcc 	andi	r2,r2,65535
81110d98:	10800228 	cmpgeui	r2,r2,8
81110d9c:	10000c1e 	bne	r2,zero,81110dd0 <vQCmdFeeRMAPWaitingSync+0x568>
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
81110da0:	d0a06217 	ldw	r2,-32376(gp)
81110da4:	e0fffa03 	ldbu	r3,-24(fp)
81110da8:	180d883a 	mov	r6,r3
81110dac:	01604574 	movhi	r5,33045
81110db0:	29780404 	addi	r5,r5,-8176
81110db4:	1009883a 	mov	r4,r2
81110db8:	112292c0 	call	8112292c <fprintf>
			}
			#endif
			break;
81110dbc:	00000406 	br	81110dd0 <vQCmdFeeRMAPWaitingSync+0x568>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					}
					#endif
				}
			}
			break;
81110dc0:	0001883a 	nop
81110dc4:	00000306 	br	81110dd4 <vQCmdFeeRMAPWaitingSync+0x56c>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110dc8:	0001883a 	nop
81110dcc:	00000106 	br	81110dd4 <vQCmdFeeRMAPWaitingSync+0x56c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
81110dd0:	0001883a 	nop
		}
}
81110dd4:	0001883a 	nop
81110dd8:	e037883a 	mov	sp,fp
81110ddc:	dfc00117 	ldw	ra,4(sp)
81110de0:	df000017 	ldw	fp,0(sp)
81110de4:	dec00204 	addi	sp,sp,8
81110de8:	f800283a 	ret

81110dec <bDisableRmapIRQ>:


bool bDisableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
81110dec:	defffc04 	addi	sp,sp,-16
81110df0:	de00012e 	bgeu	sp,et,81110df8 <bDisableRmapIRQ+0xc>
81110df4:	003b68fa 	trap	3
81110df8:	dfc00315 	stw	ra,12(sp)
81110dfc:	df000215 	stw	fp,8(sp)
81110e00:	df000204 	addi	fp,sp,8
81110e04:	e13ffe15 	stw	r4,-8(fp)
81110e08:	2805883a 	mov	r2,r5
81110e0c:	e0bfff05 	stb	r2,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
81110e10:	e13ffe17 	ldw	r4,-8(fp)
81110e14:	11078740 	call	81107874 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
81110e18:	e0bffe17 	ldw	r2,-8(fp)
81110e1c:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
81110e20:	e13ffe17 	ldw	r4,-8(fp)
81110e24:	11077cc0 	call	811077cc <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81110e28:	00800044 	movi	r2,1
}
81110e2c:	e037883a 	mov	sp,fp
81110e30:	dfc00117 	ldw	ra,4(sp)
81110e34:	df000017 	ldw	fp,0(sp)
81110e38:	dec00204 	addi	sp,sp,8
81110e3c:	f800283a 	ret

81110e40 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
81110e40:	defffc04 	addi	sp,sp,-16
81110e44:	de00012e 	bgeu	sp,et,81110e4c <bEnableRmapIRQ+0xc>
81110e48:	003b68fa 	trap	3
81110e4c:	dfc00315 	stw	ra,12(sp)
81110e50:	df000215 	stw	fp,8(sp)
81110e54:	df000204 	addi	fp,sp,8
81110e58:	e13ffe15 	stw	r4,-8(fp)
81110e5c:	2805883a 	mov	r2,r5
81110e60:	e0bfff05 	stb	r2,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	//bRmapGetMemConfigArea(&xRmap[ucId]);

	bRmapGetIrqControl(pxRmapCh);
81110e64:	e13ffe17 	ldw	r4,-8(fp)
81110e68:	11078740 	call	81107874 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
81110e6c:	e0bffe17 	ldw	r2,-8(fp)
81110e70:	00c00044 	movi	r3,1
81110e74:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
81110e78:	e13ffe17 	ldw	r4,-8(fp)
81110e7c:	11077cc0 	call	811077cc <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81110e80:	00800044 	movi	r2,1
}
81110e84:	e037883a 	mov	sp,fp
81110e88:	dfc00117 	ldw	ra,4(sp)
81110e8c:	df000017 	ldw	fp,0(sp)
81110e90:	dec00204 	addi	sp,sp,8
81110e94:	f800283a 	ret

81110e98 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
81110e98:	defffd04 	addi	sp,sp,-12
81110e9c:	de00012e 	bgeu	sp,et,81110ea4 <bDisableSPWChannel+0xc>
81110ea0:	003b68fa 	trap	3
81110ea4:	dfc00215 	stw	ra,8(sp)
81110ea8:	df000115 	stw	fp,4(sp)
81110eac:	df000104 	addi	fp,sp,4
81110eb0:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
81110eb4:	e13fff17 	ldw	r4,-4(fp)
81110eb8:	110a1f80 	call	8110a1f8 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
81110ebc:	e0bfff17 	ldw	r2,-4(fp)
81110ec0:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
81110ec4:	e0bfff17 	ldw	r2,-4(fp)
81110ec8:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
81110ecc:	e0bfff17 	ldw	r2,-4(fp)
81110ed0:	00c00044 	movi	r3,1
81110ed4:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
81110ed8:	e13fff17 	ldw	r4,-4(fp)
81110edc:	110a0c40 	call	8110a0c4 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
81110ee0:	00800044 	movi	r2,1
}
81110ee4:	e037883a 	mov	sp,fp
81110ee8:	dfc00117 	ldw	ra,4(sp)
81110eec:	df000017 	ldw	fp,0(sp)
81110ef0:	dec00204 	addi	sp,sp,8
81110ef4:	f800283a 	ret

81110ef8 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
81110ef8:	defffd04 	addi	sp,sp,-12
81110efc:	de00012e 	bgeu	sp,et,81110f04 <bEnableSPWChannel+0xc>
81110f00:	003b68fa 	trap	3
81110f04:	dfc00215 	stw	ra,8(sp)
81110f08:	df000115 	stw	fp,4(sp)
81110f0c:	df000104 	addi	fp,sp,4
81110f10:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
81110f14:	e13fff17 	ldw	r4,-4(fp)
81110f18:	110a1f80 	call	8110a1f8 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
81110f1c:	e0bfff17 	ldw	r2,-4(fp)
81110f20:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
81110f24:	e0bfff17 	ldw	r2,-4(fp)
81110f28:	00c00044 	movi	r3,1
81110f2c:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
81110f30:	e0bfff17 	ldw	r2,-4(fp)
81110f34:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
81110f38:	e13fff17 	ldw	r4,-4(fp)
81110f3c:	110a0c40 	call	8110a0c4 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
81110f40:	00800044 	movi	r2,1
}
81110f44:	e037883a 	mov	sp,fp
81110f48:	dfc00117 	ldw	ra,4(sp)
81110f4c:	df000017 	ldw	fp,0(sp)
81110f50:	dec00204 	addi	sp,sp,8
81110f54:	f800283a 	ret

81110f58 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
81110f58:	defffd04 	addi	sp,sp,-12
81110f5c:	de00012e 	bgeu	sp,et,81110f64 <bEnableDbBuffer+0xc>
81110f60:	003b68fa 	trap	3
81110f64:	dfc00215 	stw	ra,8(sp)
81110f68:	df000115 	stw	fp,4(sp)
81110f6c:	df000104 	addi	fp,sp,4
81110f70:	e13fff15 	stw	r4,-4(fp)
	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
81110f74:	e13fff17 	ldw	r4,-4(fp)
81110f78:	11068900 	call	81106890 <bFeebStopCh>
	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
81110f7c:	e13fff17 	ldw	r4,-4(fp)
81110f80:	11069180 	call	81106918 <bFeebClrCh>
	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
81110f84:	e13fff17 	ldw	r4,-4(fp)
81110f88:	11068080 	call	81106808 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
81110f8c:	e13fff17 	ldw	r4,-4(fp)
81110f90:	11067800 	call	81106780 <bFeebGetWindowing>
	//pxFeebCh->xWindowingConfig.bMasking = DATA_PACKET;/* True= data packet;    FALSE= Transparent mode */
	pxFeebCh->xWindowingConfig.bMasking = xDefaults.bDataPacket;
81110f94:	00a045b4 	movhi	r2,33046
81110f98:	109fe204 	addi	r2,r2,32648
81110f9c:	10c00717 	ldw	r3,28(r2)
81110fa0:	e0bfff17 	ldw	r2,-4(fp)
81110fa4:	10c00115 	stw	r3,4(r2)
	bFeebSetWindowing(pxFeebCh);
81110fa8:	e13fff17 	ldw	r4,-4(fp)
81110fac:	11066d80 	call	811066d8 <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
81110fb0:	e13fff17 	ldw	r4,-4(fp)
81110fb4:	11061280 	call	81106128 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81110fb8:	e0bfff17 	ldw	r2,-4(fp)
81110fbc:	00c00044 	movi	r3,1
81110fc0:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81110fc4:	e0bfff17 	ldw	r2,-4(fp)
81110fc8:	00c00044 	movi	r3,1
81110fcc:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
81110fd0:	e13fff17 	ldw	r4,-4(fp)
81110fd4:	11060540 	call	81106054 <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81110fd8:	00800044 	movi	r2,1
}
81110fdc:	e037883a 	mov	sp,fp
81110fe0:	dfc00117 	ldw	ra,4(sp)
81110fe4:	df000017 	ldw	fp,0(sp)
81110fe8:	dec00204 	addi	sp,sp,8
81110fec:	f800283a 	ret

81110ff0 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
81110ff0:	defffd04 	addi	sp,sp,-12
81110ff4:	de00012e 	bgeu	sp,et,81110ffc <bDisAndClrDbBuffer+0xc>
81110ff8:	003b68fa 	trap	3
81110ffc:	dfc00215 	stw	ra,8(sp)
81111000:	df000115 	stw	fp,4(sp)
81111004:	df000104 	addi	fp,sp,4
81111008:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8111100c:	e13fff17 	ldw	r4,-4(fp)
81111010:	11061280 	call	81106128 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81111014:	e0bfff17 	ldw	r2,-4(fp)
81111018:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
8111101c:	e0bfff17 	ldw	r2,-4(fp)
81111020:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
81111024:	e13fff17 	ldw	r4,-4(fp)
81111028:	11060540 	call	81106054 <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
8111102c:	e13fff17 	ldw	r4,-4(fp)
81111030:	11068900 	call	81106890 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
81111034:	e13fff17 	ldw	r4,-4(fp)
81111038:	11069180 	call	81106918 <bFeebClrCh>
	bFeebStartCh(pxFeebCh);
8111103c:	e13fff17 	ldw	r4,-4(fp)
81111040:	11068080 	call	81106808 <bFeebStartCh>

	/*todo: No treatment for now  */
	return TRUE;
81111044:	00800044 	movi	r2,1
}
81111048:	e037883a 	mov	sp,fp
8111104c:	dfc00117 	ldw	ra,4(sp)
81111050:	df000017 	ldw	fp,0(sp)
81111054:	dec00204 	addi	sp,sp,8
81111058:	f800283a 	ret

8111105c <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8111105c:	defff804 	addi	sp,sp,-32
81111060:	de00012e 	bgeu	sp,et,81111068 <bSendRequestNFeeCtrl+0xc>
81111064:	003b68fa 	trap	3
81111068:	dfc00715 	stw	ra,28(sp)
8111106c:	df000615 	stw	fp,24(sp)
81111070:	df000604 	addi	fp,sp,24
81111074:	2807883a 	mov	r3,r5
81111078:	3005883a 	mov	r2,r6
8111107c:	e13ffd05 	stb	r4,-12(fp)
81111080:	e0fffe05 	stb	r3,-8(fp)
81111084:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81111088:	00800404 	movi	r2,16
8111108c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111090:	e0bffd03 	ldbu	r2,-12(fp)
81111094:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111098:	e0bffe03 	ldbu	r2,-8(fp)
8111109c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811110a0:	e0bfff03 	ldbu	r2,-4(fp)
811110a4:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
811110a8:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811110ac:	d0a05d17 	ldw	r2,-32396(gp)
811110b0:	e0fffc17 	ldw	r3,-16(fp)
811110b4:	180b883a 	mov	r5,r3
811110b8:	1009883a 	mov	r4,r2
811110bc:	113f2dc0 	call	8113f2dc <OSQPost>
811110c0:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811110c4:	e0bffb03 	ldbu	r2,-20(fp)
811110c8:	10000526 	beq	r2,zero,811110e0 <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
811110cc:	e0bfff03 	ldbu	r2,-4(fp)
811110d0:	1009883a 	mov	r4,r2
811110d4:	111e6d40 	call	8111e6d4 <vFailRequestDMA>
		bSuccesL = FALSE;
811110d8:	e03ffa15 	stw	zero,-24(fp)
811110dc:	00000206 	br	811110e8 <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
811110e0:	00800044 	movi	r2,1
811110e4:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
811110e8:	e0bffa17 	ldw	r2,-24(fp)
}
811110ec:	e037883a 	mov	sp,fp
811110f0:	dfc00117 	ldw	ra,4(sp)
811110f4:	df000017 	ldw	fp,0(sp)
811110f8:	dec00204 	addi	sp,sp,8
811110fc:	f800283a 	ret

81111100 <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111100:	defff804 	addi	sp,sp,-32
81111104:	de00012e 	bgeu	sp,et,8111110c <bSendGiveBackNFeeCtrl+0xc>
81111108:	003b68fa 	trap	3
8111110c:	dfc00715 	stw	ra,28(sp)
81111110:	df000615 	stw	fp,24(sp)
81111114:	df000604 	addi	fp,sp,24
81111118:	2807883a 	mov	r3,r5
8111111c:	3005883a 	mov	r2,r6
81111120:	e13ffd05 	stb	r4,-12(fp)
81111124:	e0fffe05 	stb	r3,-8(fp)
81111128:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8111112c:	00800404 	movi	r2,16
81111130:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111134:	e0bffd03 	ldbu	r2,-12(fp)
81111138:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8111113c:	e0bffe03 	ldbu	r2,-8(fp)
81111140:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111144:	e0bfff03 	ldbu	r2,-4(fp)
81111148:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8111114c:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81111150:	d0a07017 	ldw	r2,-32320(gp)
81111154:	e0fffc17 	ldw	r3,-16(fp)
81111158:	180b883a 	mov	r5,r3
8111115c:	1009883a 	mov	r4,r2
81111160:	113f2dc0 	call	8113f2dc <OSQPost>
81111164:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111168:	e0bffb03 	ldbu	r2,-20(fp)
8111116c:	10000526 	beq	r2,zero,81111184 <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
81111170:	e0bfff03 	ldbu	r2,-4(fp)
81111174:	1009883a 	mov	r4,r2
81111178:	111e6d40 	call	8111e6d4 <vFailRequestDMA>
		bSuccesL = FALSE;
8111117c:	e03ffa15 	stw	zero,-24(fp)
81111180:	00000206 	br	8111118c <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81111184:	00800044 	movi	r2,1
81111188:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8111118c:	e0bffa17 	ldw	r2,-24(fp)
}
81111190:	e037883a 	mov	sp,fp
81111194:	dfc00117 	ldw	ra,4(sp)
81111198:	df000017 	ldw	fp,0(sp)
8111119c:	dec00204 	addi	sp,sp,8
811111a0:	f800283a 	ret

811111a4 <vPrintConsoleNFee>:




#if DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
811111a4:	defffa04 	addi	sp,sp,-24
811111a8:	de00012e 	bgeu	sp,et,811111b0 <vPrintConsoleNFee+0xc>
811111ac:	003b68fa 	trap	3
811111b0:	dfc00515 	stw	ra,20(sp)
811111b4:	df000415 	stw	fp,16(sp)
811111b8:	df000404 	addi	fp,sp,16
811111bc:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
811111c0:	e0bfff17 	ldw	r2,-4(fp)
811111c4:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
811111c8:	d0e06217 	ldw	r3,-32376(gp)
811111cc:	e0bffe17 	ldw	r2,-8(fp)
811111d0:	10800003 	ldbu	r2,0(r2)
811111d4:	10803fcc 	andi	r2,r2,255
811111d8:	100d883a 	mov	r6,r2
811111dc:	01604574 	movhi	r5,33045
811111e0:	29785504 	addi	r5,r5,-7852
811111e4:	1809883a 	mov	r4,r3
811111e8:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"\n");
811111ec:	d0a06217 	ldw	r2,-32376(gp)
811111f0:	100b883a 	mov	r5,r2
811111f4:	01000284 	movi	r4,10
811111f8:	11229a40 	call	811229a4 <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
811111fc:	d0e06217 	ldw	r3,-32376(gp)
81111200:	e0bffe17 	ldw	r2,-8(fp)
81111204:	10800003 	ldbu	r2,0(r2)
81111208:	10803fcc 	andi	r2,r2,255
8111120c:	100d883a 	mov	r6,r2
81111210:	01604574 	movhi	r5,33045
81111214:	29786a04 	addi	r5,r5,-7768
81111218:	1809883a 	mov	r4,r3
8111121c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
81111220:	d0e06217 	ldw	r3,-32376(gp)
81111224:	e0bffe17 	ldw	r2,-8(fp)
81111228:	10802f0b 	ldhu	r2,188(r2)
8111122c:	10bfffcc 	andi	r2,r2,65535
81111230:	100d883a 	mov	r6,r2
81111234:	01604574 	movhi	r5,33045
81111238:	29787004 	addi	r5,r5,-7744
8111123c:	1809883a 	mov	r4,r3
81111240:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
81111244:	d0e06217 	ldw	r3,-32376(gp)
81111248:	e0bffe17 	ldw	r2,-8(fp)
8111124c:	10802f8b 	ldhu	r2,190(r2)
81111250:	10bfffcc 	andi	r2,r2,65535
81111254:	100d883a 	mov	r6,r2
81111258:	01604574 	movhi	r5,33045
8111125c:	29787504 	addi	r5,r5,-7724
81111260:	1809883a 	mov	r4,r3
81111264:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
81111268:	d0e06217 	ldw	r3,-32376(gp)
8111126c:	e0bffe17 	ldw	r2,-8(fp)
81111270:	1080300b 	ldhu	r2,192(r2)
81111274:	10bfffcc 	andi	r2,r2,65535
81111278:	100d883a 	mov	r6,r2
8111127c:	01604574 	movhi	r5,33045
81111280:	29787b04 	addi	r5,r5,-7700
81111284:	1809883a 	mov	r4,r3
81111288:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
8111128c:	d0e06217 	ldw	r3,-32376(gp)
81111290:	e0bffe17 	ldw	r2,-8(fp)
81111294:	1080308b 	ldhu	r2,194(r2)
81111298:	10bfffcc 	andi	r2,r2,65535
8111129c:	100d883a 	mov	r6,r2
811112a0:	01604574 	movhi	r5,33045
811112a4:	29787f04 	addi	r5,r5,-7684
811112a8:	1809883a 	mov	r4,r3
811112ac:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
811112b0:	d0e06217 	ldw	r3,-32376(gp)
811112b4:	e0bffe17 	ldw	r2,-8(fp)
811112b8:	1080310b 	ldhu	r2,196(r2)
811112bc:	10bfffcc 	andi	r2,r2,65535
811112c0:	100d883a 	mov	r6,r2
811112c4:	01604574 	movhi	r5,33045
811112c8:	29788504 	addi	r5,r5,-7660
811112cc:	1809883a 	mov	r4,r3
811112d0:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"\n");
811112d4:	d0a06217 	ldw	r2,-32376(gp)
811112d8:	100b883a 	mov	r5,r2
811112dc:	01000284 	movi	r4,10
811112e0:	11229a40 	call	811229a4 <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
811112e4:	d0e06217 	ldw	r3,-32376(gp)
811112e8:	e0bffe17 	ldw	r2,-8(fp)
811112ec:	10800003 	ldbu	r2,0(r2)
811112f0:	10803fcc 	andi	r2,r2,255
811112f4:	100d883a 	mov	r6,r2
811112f8:	01604574 	movhi	r5,33045
811112fc:	29788a04 	addi	r5,r5,-7640
81111300:	1809883a 	mov	r4,r3
81111304:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
81111308:	d0e06217 	ldw	r3,-32376(gp)
8111130c:	e0bffe17 	ldw	r2,-8(fp)
81111310:	10802c17 	ldw	r2,176(r2)
81111314:	100d883a 	mov	r6,r2
81111318:	01604574 	movhi	r5,33045
8111131c:	29789004 	addi	r5,r5,-7616
81111320:	1809883a 	mov	r4,r3
81111324:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
81111328:	d0e06217 	ldw	r3,-32376(gp)
8111132c:	e0bffe17 	ldw	r2,-8(fp)
81111330:	10802117 	ldw	r2,132(r2)
81111334:	100d883a 	mov	r6,r2
81111338:	01604574 	movhi	r5,33045
8111133c:	29789604 	addi	r5,r5,-7592
81111340:	1809883a 	mov	r4,r3
81111344:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
81111348:	d0e06217 	ldw	r3,-32376(gp)
8111134c:	e0bffe17 	ldw	r2,-8(fp)
81111350:	10802317 	ldw	r2,140(r2)
81111354:	100d883a 	mov	r6,r2
81111358:	01604574 	movhi	r5,33045
8111135c:	29789d04 	addi	r5,r5,-7564
81111360:	1809883a 	mov	r4,r3
81111364:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
81111368:	d0e06217 	ldw	r3,-32376(gp)
8111136c:	e0bffe17 	ldw	r2,-8(fp)
81111370:	10802417 	ldw	r2,144(r2)
81111374:	100d883a 	mov	r6,r2
81111378:	01604574 	movhi	r5,33045
8111137c:	2978a404 	addi	r5,r5,-7536
81111380:	1809883a 	mov	r4,r3
81111384:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
81111388:	d0e06217 	ldw	r3,-32376(gp)
8111138c:	e0bffe17 	ldw	r2,-8(fp)
81111390:	10802517 	ldw	r2,148(r2)
81111394:	100d883a 	mov	r6,r2
81111398:	01604574 	movhi	r5,33045
8111139c:	2978ab04 	addi	r5,r5,-7508
811113a0:	1809883a 	mov	r4,r3
811113a4:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
811113a8:	d0e06217 	ldw	r3,-32376(gp)
811113ac:	e0bffe17 	ldw	r2,-8(fp)
811113b0:	10802617 	ldw	r2,152(r2)
811113b4:	100d883a 	mov	r6,r2
811113b8:	01604574 	movhi	r5,33045
811113bc:	2978b204 	addi	r5,r5,-7480
811113c0:	1809883a 	mov	r4,r3
811113c4:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
811113c8:	d1206217 	ldw	r4,-32376(gp)
811113cc:	e0bffe17 	ldw	r2,-8(fp)
811113d0:	10802a43 	ldbu	r2,169(r2)
811113d4:	11403fcc 	andi	r5,r2,255
811113d8:	e0bffe17 	ldw	r2,-8(fp)
811113dc:	10802a83 	ldbu	r2,170(r2)
811113e0:	11803fcc 	andi	r6,r2,255
811113e4:	e0bffe17 	ldw	r2,-8(fp)
811113e8:	10802ac3 	ldbu	r2,171(r2)
811113ec:	10803fcc 	andi	r2,r2,255
811113f0:	e0fffe17 	ldw	r3,-8(fp)
811113f4:	18c02b03 	ldbu	r3,172(r3)
811113f8:	18c03fcc 	andi	r3,r3,255
811113fc:	d8c00115 	stw	r3,4(sp)
81111400:	d8800015 	stw	r2,0(sp)
81111404:	300f883a 	mov	r7,r6
81111408:	280d883a 	mov	r6,r5
8111140c:	01604574 	movhi	r5,33045
81111410:	2978b904 	addi	r5,r5,-7452
81111414:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
81111418:	d0e06217 	ldw	r3,-32376(gp)
8111141c:	e0bffe17 	ldw	r2,-8(fp)
81111420:	10802e17 	ldw	r2,184(r2)
81111424:	100d883a 	mov	r6,r2
81111428:	01604574 	movhi	r5,33045
8111142c:	2978c604 	addi	r5,r5,-7400
81111430:	1809883a 	mov	r4,r3
81111434:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"\n\n");
81111438:	d0a06217 	ldw	r2,-32376(gp)
8111143c:	100f883a 	mov	r7,r2
81111440:	01800084 	movi	r6,2
81111444:	01400044 	movi	r5,1
81111448:	01204574 	movhi	r4,33045
8111144c:	2138cc04 	addi	r4,r4,-7376
81111450:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
81111454:	d0e06217 	ldw	r3,-32376(gp)
81111458:	e0bffe17 	ldw	r2,-8(fp)
8111145c:	10800003 	ldbu	r2,0(r2)
81111460:	10803fcc 	andi	r2,r2,255
81111464:	100d883a 	mov	r6,r2
81111468:	01604574 	movhi	r5,33045
8111146c:	2978cd04 	addi	r5,r5,-7372
81111470:	1809883a 	mov	r4,r3
81111474:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    General Info: \n");
81111478:	d0a06217 	ldw	r2,-32376(gp)
8111147c:	100f883a 	mov	r7,r2
81111480:	018004c4 	movi	r6,19
81111484:	01400044 	movi	r5,1
81111488:	01204574 	movhi	r4,33045
8111148c:	2138d304 	addi	r4,r4,-7348
81111490:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
81111494:	d0e06217 	ldw	r3,-32376(gp)
81111498:	e0bffe17 	ldw	r2,-8(fp)
8111149c:	10800117 	ldw	r2,4(r2)
811114a0:	100d883a 	mov	r6,r2
811114a4:	01604574 	movhi	r5,33045
811114a8:	2978d804 	addi	r5,r5,-7328
811114ac:	1809883a 	mov	r4,r3
811114b0:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
811114b4:	d0e06217 	ldw	r3,-32376(gp)
811114b8:	e0bffe17 	ldw	r2,-8(fp)
811114bc:	10800217 	ldw	r2,8(r2)
811114c0:	100d883a 	mov	r6,r2
811114c4:	01604574 	movhi	r5,33045
811114c8:	2978e004 	addi	r5,r5,-7296
811114cc:	1809883a 	mov	r4,r3
811114d0:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
811114d4:	d0e06217 	ldw	r3,-32376(gp)
811114d8:	e0bffe17 	ldw	r2,-8(fp)
811114dc:	10800317 	ldw	r2,12(r2)
811114e0:	100d883a 	mov	r6,r2
811114e4:	01604574 	movhi	r5,33045
811114e8:	2978e804 	addi	r5,r5,-7264
811114ec:	1809883a 	mov	r4,r3
811114f0:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
811114f4:	d0a06217 	ldw	r2,-32376(gp)
811114f8:	100f883a 	mov	r7,r2
811114fc:	01800644 	movi	r6,25
81111500:	01400044 	movi	r5,1
81111504:	01204574 	movhi	r4,33045
81111508:	2138ef04 	addi	r4,r4,-7236
8111150c:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
81111510:	d0e06217 	ldw	r3,-32376(gp)
81111514:	e0bffe17 	ldw	r2,-8(fp)
81111518:	10800517 	ldw	r2,20(r2)
8111151c:	100d883a 	mov	r6,r2
81111520:	01604574 	movhi	r5,33045
81111524:	2978e004 	addi	r5,r5,-7296
81111528:	1809883a 	mov	r4,r3
8111152c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        Total of Blocks = %lu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
81111530:	d0e06217 	ldw	r3,-32376(gp)
81111534:	e0bffe17 	ldw	r2,-8(fp)
81111538:	10800417 	ldw	r2,16(r2)
8111153c:	100d883a 	mov	r6,r2
81111540:	01604574 	movhi	r5,33045
81111544:	2978f604 	addi	r5,r5,-7208
81111548:	1809883a 	mov	r4,r3
8111154c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
81111550:	d0e06217 	ldw	r3,-32376(gp)
81111554:	e0bffe17 	ldw	r2,-8(fp)
81111558:	10800603 	ldbu	r2,24(r2)
8111155c:	10803fcc 	andi	r2,r2,255
81111560:	100d883a 	mov	r6,r2
81111564:	01604574 	movhi	r5,33045
81111568:	2978fe04 	addi	r5,r5,-7176
8111156c:	1809883a 	mov	r4,r3
81111570:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
81111574:	d2206217 	ldw	r8,-32376(gp)
81111578:	e13ffe17 	ldw	r4,-8(fp)
8111157c:	20800717 	ldw	r2,28(r4)
81111580:	20c00817 	ldw	r3,32(r4)
81111584:	100d883a 	mov	r6,r2
81111588:	180f883a 	mov	r7,r3
8111158c:	01604574 	movhi	r5,33045
81111590:	29790604 	addi	r5,r5,-7144
81111594:	4009883a 	mov	r4,r8
81111598:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"\n");
8111159c:	d0a06217 	ldw	r2,-32376(gp)
811115a0:	100b883a 	mov	r5,r2
811115a4:	01000284 	movi	r4,10
811115a8:	11229a40 	call	811229a4 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
811115ac:	d0e06217 	ldw	r3,-32376(gp)
811115b0:	e0bffe17 	ldw	r2,-8(fp)
811115b4:	10800003 	ldbu	r2,0(r2)
811115b8:	10803fcc 	andi	r2,r2,255
811115bc:	100f883a 	mov	r7,r2
811115c0:	000d883a 	mov	r6,zero
811115c4:	01604574 	movhi	r5,33045
811115c8:	29790e04 	addi	r5,r5,-7112
811115cc:	1809883a 	mov	r4,r3
811115d0:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        Left side \n");
811115d4:	d0a06217 	ldw	r2,-32376(gp)
811115d8:	100f883a 	mov	r7,r2
811115dc:	018004c4 	movi	r6,19
811115e0:	01400044 	movi	r5,1
811115e4:	01204574 	movhi	r4,33045
811115e8:	21391804 	addi	r4,r4,-7072
811115ec:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
811115f0:	d0e06217 	ldw	r3,-32376(gp)
811115f4:	e0bffe17 	ldw	r2,-8(fp)
811115f8:	10800917 	ldw	r2,36(r2)
811115fc:	100d883a 	mov	r6,r2
81111600:	01604574 	movhi	r5,33045
81111604:	29791d04 	addi	r5,r5,-7052
81111608:	1809883a 	mov	r4,r3
8111160c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
81111610:	d0e06217 	ldw	r3,-32376(gp)
81111614:	e0bffe17 	ldw	r2,-8(fp)
81111618:	10800a17 	ldw	r2,40(r2)
8111161c:	100d883a 	mov	r6,r2
81111620:	01604574 	movhi	r5,33045
81111624:	29792604 	addi	r5,r5,-7016
81111628:	1809883a 	mov	r4,r3
8111162c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
81111630:	d0e06217 	ldw	r3,-32376(gp)
81111634:	e0bffe17 	ldw	r2,-8(fp)
81111638:	10800b17 	ldw	r2,44(r2)
8111163c:	100d883a 	mov	r6,r2
81111640:	01604574 	movhi	r5,33045
81111644:	29793104 	addi	r5,r5,-6972
81111648:	1809883a 	mov	r4,r3
8111164c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        Right side \n");
81111650:	d0a06217 	ldw	r2,-32376(gp)
81111654:	100f883a 	mov	r7,r2
81111658:	01800504 	movi	r6,20
8111165c:	01400044 	movi	r5,1
81111660:	01204574 	movhi	r4,33045
81111664:	21393d04 	addi	r4,r4,-6924
81111668:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
8111166c:	d0e06217 	ldw	r3,-32376(gp)
81111670:	e0bffe17 	ldw	r2,-8(fp)
81111674:	10800c17 	ldw	r2,48(r2)
81111678:	100d883a 	mov	r6,r2
8111167c:	01604574 	movhi	r5,33045
81111680:	29791d04 	addi	r5,r5,-7052
81111684:	1809883a 	mov	r4,r3
81111688:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
8111168c:	d0e06217 	ldw	r3,-32376(gp)
81111690:	e0bffe17 	ldw	r2,-8(fp)
81111694:	10800d17 	ldw	r2,52(r2)
81111698:	100d883a 	mov	r6,r2
8111169c:	01604574 	movhi	r5,33045
811116a0:	29792604 	addi	r5,r5,-7016
811116a4:	1809883a 	mov	r4,r3
811116a8:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
811116ac:	d0e06217 	ldw	r3,-32376(gp)
811116b0:	e0bffe17 	ldw	r2,-8(fp)
811116b4:	10800e17 	ldw	r2,56(r2)
811116b8:	100d883a 	mov	r6,r2
811116bc:	01604574 	movhi	r5,33045
811116c0:	29793104 	addi	r5,r5,-6972
811116c4:	1809883a 	mov	r4,r3
811116c8:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"\n");
811116cc:	d0a06217 	ldw	r2,-32376(gp)
811116d0:	100b883a 	mov	r5,r2
811116d4:	01000284 	movi	r4,10
811116d8:	11229a40 	call	811229a4 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
811116dc:	d0e06217 	ldw	r3,-32376(gp)
811116e0:	e0bffe17 	ldw	r2,-8(fp)
811116e4:	10800003 	ldbu	r2,0(r2)
811116e8:	10803fcc 	andi	r2,r2,255
811116ec:	100f883a 	mov	r7,r2
811116f0:	01800044 	movi	r6,1
811116f4:	01604574 	movhi	r5,33045
811116f8:	29790e04 	addi	r5,r5,-7112
811116fc:	1809883a 	mov	r4,r3
81111700:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        Left side \n");
81111704:	d0a06217 	ldw	r2,-32376(gp)
81111708:	100f883a 	mov	r7,r2
8111170c:	018004c4 	movi	r6,19
81111710:	01400044 	movi	r5,1
81111714:	01204574 	movhi	r4,33045
81111718:	21391804 	addi	r4,r4,-7072
8111171c:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
81111720:	d0e06217 	ldw	r3,-32376(gp)
81111724:	e0bffe17 	ldw	r2,-8(fp)
81111728:	10800f17 	ldw	r2,60(r2)
8111172c:	100d883a 	mov	r6,r2
81111730:	01604574 	movhi	r5,33045
81111734:	29791d04 	addi	r5,r5,-7052
81111738:	1809883a 	mov	r4,r3
8111173c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
81111740:	d0e06217 	ldw	r3,-32376(gp)
81111744:	e0bffe17 	ldw	r2,-8(fp)
81111748:	10801017 	ldw	r2,64(r2)
8111174c:	100d883a 	mov	r6,r2
81111750:	01604574 	movhi	r5,33045
81111754:	29792604 	addi	r5,r5,-7016
81111758:	1809883a 	mov	r4,r3
8111175c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
81111760:	d0e06217 	ldw	r3,-32376(gp)
81111764:	e0bffe17 	ldw	r2,-8(fp)
81111768:	10801117 	ldw	r2,68(r2)
8111176c:	100d883a 	mov	r6,r2
81111770:	01604574 	movhi	r5,33045
81111774:	29793104 	addi	r5,r5,-6972
81111778:	1809883a 	mov	r4,r3
8111177c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        Right side \n");
81111780:	d0a06217 	ldw	r2,-32376(gp)
81111784:	100f883a 	mov	r7,r2
81111788:	01800504 	movi	r6,20
8111178c:	01400044 	movi	r5,1
81111790:	01204574 	movhi	r4,33045
81111794:	21393d04 	addi	r4,r4,-6924
81111798:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
8111179c:	d0e06217 	ldw	r3,-32376(gp)
811117a0:	e0bffe17 	ldw	r2,-8(fp)
811117a4:	10801217 	ldw	r2,72(r2)
811117a8:	100d883a 	mov	r6,r2
811117ac:	01604574 	movhi	r5,33045
811117b0:	29791d04 	addi	r5,r5,-7052
811117b4:	1809883a 	mov	r4,r3
811117b8:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
811117bc:	d0e06217 	ldw	r3,-32376(gp)
811117c0:	e0bffe17 	ldw	r2,-8(fp)
811117c4:	10801317 	ldw	r2,76(r2)
811117c8:	100d883a 	mov	r6,r2
811117cc:	01604574 	movhi	r5,33045
811117d0:	29792604 	addi	r5,r5,-7016
811117d4:	1809883a 	mov	r4,r3
811117d8:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
811117dc:	d0e06217 	ldw	r3,-32376(gp)
811117e0:	e0bffe17 	ldw	r2,-8(fp)
811117e4:	10801417 	ldw	r2,80(r2)
811117e8:	100d883a 	mov	r6,r2
811117ec:	01604574 	movhi	r5,33045
811117f0:	29793104 	addi	r5,r5,-6972
811117f4:	1809883a 	mov	r4,r3
811117f8:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"\n");
811117fc:	d0a06217 	ldw	r2,-32376(gp)
81111800:	100b883a 	mov	r5,r2
81111804:	01000284 	movi	r4,10
81111808:	11229a40 	call	811229a4 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
8111180c:	d0e06217 	ldw	r3,-32376(gp)
81111810:	e0bffe17 	ldw	r2,-8(fp)
81111814:	10800003 	ldbu	r2,0(r2)
81111818:	10803fcc 	andi	r2,r2,255
8111181c:	100f883a 	mov	r7,r2
81111820:	01800084 	movi	r6,2
81111824:	01604574 	movhi	r5,33045
81111828:	29790e04 	addi	r5,r5,-7112
8111182c:	1809883a 	mov	r4,r3
81111830:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        Left side \n");
81111834:	d0a06217 	ldw	r2,-32376(gp)
81111838:	100f883a 	mov	r7,r2
8111183c:	018004c4 	movi	r6,19
81111840:	01400044 	movi	r5,1
81111844:	01204574 	movhi	r4,33045
81111848:	21391804 	addi	r4,r4,-7072
8111184c:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
81111850:	d0e06217 	ldw	r3,-32376(gp)
81111854:	e0bffe17 	ldw	r2,-8(fp)
81111858:	10801517 	ldw	r2,84(r2)
8111185c:	100d883a 	mov	r6,r2
81111860:	01604574 	movhi	r5,33045
81111864:	29791d04 	addi	r5,r5,-7052
81111868:	1809883a 	mov	r4,r3
8111186c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
81111870:	d0e06217 	ldw	r3,-32376(gp)
81111874:	e0bffe17 	ldw	r2,-8(fp)
81111878:	10801617 	ldw	r2,88(r2)
8111187c:	100d883a 	mov	r6,r2
81111880:	01604574 	movhi	r5,33045
81111884:	29792604 	addi	r5,r5,-7016
81111888:	1809883a 	mov	r4,r3
8111188c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
81111890:	d0e06217 	ldw	r3,-32376(gp)
81111894:	e0bffe17 	ldw	r2,-8(fp)
81111898:	10801717 	ldw	r2,92(r2)
8111189c:	100d883a 	mov	r6,r2
811118a0:	01604574 	movhi	r5,33045
811118a4:	29793104 	addi	r5,r5,-6972
811118a8:	1809883a 	mov	r4,r3
811118ac:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        Right side \n");
811118b0:	d0a06217 	ldw	r2,-32376(gp)
811118b4:	100f883a 	mov	r7,r2
811118b8:	01800504 	movi	r6,20
811118bc:	01400044 	movi	r5,1
811118c0:	01204574 	movhi	r4,33045
811118c4:	21393d04 	addi	r4,r4,-6924
811118c8:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
811118cc:	d0e06217 	ldw	r3,-32376(gp)
811118d0:	e0bffe17 	ldw	r2,-8(fp)
811118d4:	10801817 	ldw	r2,96(r2)
811118d8:	100d883a 	mov	r6,r2
811118dc:	01604574 	movhi	r5,33045
811118e0:	29791d04 	addi	r5,r5,-7052
811118e4:	1809883a 	mov	r4,r3
811118e8:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
811118ec:	d0e06217 	ldw	r3,-32376(gp)
811118f0:	e0bffe17 	ldw	r2,-8(fp)
811118f4:	10801917 	ldw	r2,100(r2)
811118f8:	100d883a 	mov	r6,r2
811118fc:	01604574 	movhi	r5,33045
81111900:	29792604 	addi	r5,r5,-7016
81111904:	1809883a 	mov	r4,r3
81111908:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
8111190c:	d0e06217 	ldw	r3,-32376(gp)
81111910:	e0bffe17 	ldw	r2,-8(fp)
81111914:	10801a17 	ldw	r2,104(r2)
81111918:	100d883a 	mov	r6,r2
8111191c:	01604574 	movhi	r5,33045
81111920:	29793104 	addi	r5,r5,-6972
81111924:	1809883a 	mov	r4,r3
81111928:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"\n");
8111192c:	d0a06217 	ldw	r2,-32376(gp)
81111930:	100b883a 	mov	r5,r2
81111934:	01000284 	movi	r4,10
81111938:	11229a40 	call	811229a4 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
8111193c:	d0e06217 	ldw	r3,-32376(gp)
81111940:	e0bffe17 	ldw	r2,-8(fp)
81111944:	10800003 	ldbu	r2,0(r2)
81111948:	10803fcc 	andi	r2,r2,255
8111194c:	100f883a 	mov	r7,r2
81111950:	018000c4 	movi	r6,3
81111954:	01604574 	movhi	r5,33045
81111958:	29790e04 	addi	r5,r5,-7112
8111195c:	1809883a 	mov	r4,r3
81111960:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        Left side \n");
81111964:	d0a06217 	ldw	r2,-32376(gp)
81111968:	100f883a 	mov	r7,r2
8111196c:	018004c4 	movi	r6,19
81111970:	01400044 	movi	r5,1
81111974:	01204574 	movhi	r4,33045
81111978:	21391804 	addi	r4,r4,-7072
8111197c:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
81111980:	d0e06217 	ldw	r3,-32376(gp)
81111984:	e0bffe17 	ldw	r2,-8(fp)
81111988:	10801b17 	ldw	r2,108(r2)
8111198c:	100d883a 	mov	r6,r2
81111990:	01604574 	movhi	r5,33045
81111994:	29791d04 	addi	r5,r5,-7052
81111998:	1809883a 	mov	r4,r3
8111199c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
811119a0:	d0e06217 	ldw	r3,-32376(gp)
811119a4:	e0bffe17 	ldw	r2,-8(fp)
811119a8:	10801c17 	ldw	r2,112(r2)
811119ac:	100d883a 	mov	r6,r2
811119b0:	01604574 	movhi	r5,33045
811119b4:	29792604 	addi	r5,r5,-7016
811119b8:	1809883a 	mov	r4,r3
811119bc:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
811119c0:	d0e06217 	ldw	r3,-32376(gp)
811119c4:	e0bffe17 	ldw	r2,-8(fp)
811119c8:	10801d17 	ldw	r2,116(r2)
811119cc:	100d883a 	mov	r6,r2
811119d0:	01604574 	movhi	r5,33045
811119d4:	29793104 	addi	r5,r5,-6972
811119d8:	1809883a 	mov	r4,r3
811119dc:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"        Right side \n");
811119e0:	d0a06217 	ldw	r2,-32376(gp)
811119e4:	100f883a 	mov	r7,r2
811119e8:	01800504 	movi	r6,20
811119ec:	01400044 	movi	r5,1
811119f0:	01204574 	movhi	r4,33045
811119f4:	21393d04 	addi	r4,r4,-6924
811119f8:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
811119fc:	d0e06217 	ldw	r3,-32376(gp)
81111a00:	e0bffe17 	ldw	r2,-8(fp)
81111a04:	10801e17 	ldw	r2,120(r2)
81111a08:	100d883a 	mov	r6,r2
81111a0c:	01604574 	movhi	r5,33045
81111a10:	29791d04 	addi	r5,r5,-7052
81111a14:	1809883a 	mov	r4,r3
81111a18:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
81111a1c:	d0e06217 	ldw	r3,-32376(gp)
81111a20:	e0bffe17 	ldw	r2,-8(fp)
81111a24:	10801f17 	ldw	r2,124(r2)
81111a28:	100d883a 	mov	r6,r2
81111a2c:	01604574 	movhi	r5,33045
81111a30:	29792604 	addi	r5,r5,-7016
81111a34:	1809883a 	mov	r4,r3
81111a38:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
81111a3c:	d0e06217 	ldw	r3,-32376(gp)
81111a40:	e0bffe17 	ldw	r2,-8(fp)
81111a44:	10802017 	ldw	r2,128(r2)
81111a48:	100d883a 	mov	r6,r2
81111a4c:	01604574 	movhi	r5,33045
81111a50:	29793104 	addi	r5,r5,-6972
81111a54:	1809883a 	mov	r4,r3
81111a58:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"\n");
81111a5c:	d0a06217 	ldw	r2,-32376(gp)
81111a60:	100b883a 	mov	r5,r2
81111a64:	01000284 	movi	r4,10
81111a68:	11229a40 	call	811229a4 <fputc>
		fprintf(fp,"==============================================================================\n");
81111a6c:	d0a06217 	ldw	r2,-32376(gp)
81111a70:	100f883a 	mov	r7,r2
81111a74:	018013c4 	movi	r6,79
81111a78:	01400044 	movi	r5,1
81111a7c:	01204574 	movhi	r4,33045
81111a80:	21394304 	addi	r4,r4,-6900
81111a84:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"==============================================================================\n");
81111a88:	d0a06217 	ldw	r2,-32376(gp)
81111a8c:	100f883a 	mov	r7,r2
81111a90:	018013c4 	movi	r6,79
81111a94:	01400044 	movi	r5,1
81111a98:	01204574 	movhi	r4,33045
81111a9c:	21394304 	addi	r4,r4,-6900
81111aa0:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"\n");
81111aa4:	d0a06217 	ldw	r2,-32376(gp)
81111aa8:	100b883a 	mov	r5,r2
81111aac:	01000284 	movi	r4,10
81111ab0:	11229a40 	call	811229a4 <fputc>
		fprintf(fp,"\n");
81111ab4:	d0a06217 	ldw	r2,-32376(gp)
81111ab8:	100b883a 	mov	r5,r2
81111abc:	01000284 	movi	r4,10
81111ac0:	11229a40 	call	811229a4 <fputc>
		fprintf(fp,"\n");
81111ac4:	d0a06217 	ldw	r2,-32376(gp)
81111ac8:	100b883a 	mov	r5,r2
81111acc:	01000284 	movi	r4,10
81111ad0:	11229a40 	call	811229a4 <fputc>
		fprintf(fp,"\n");
81111ad4:	d0a06217 	ldw	r2,-32376(gp)
81111ad8:	100b883a 	mov	r5,r2
81111adc:	01000284 	movi	r4,10
81111ae0:	11229a40 	call	811229a4 <fputc>
		fprintf(fp,"\n");
81111ae4:	d0a06217 	ldw	r2,-32376(gp)
81111ae8:	100b883a 	mov	r5,r2
81111aec:	01000284 	movi	r4,10
81111af0:	11229a40 	call	811229a4 <fputc>
	}
81111af4:	0001883a 	nop
81111af8:	e037883a 	mov	sp,fp
81111afc:	dfc00117 	ldw	ra,4(sp)
81111b00:	df000017 	ldw	fp,0(sp)
81111b04:	dec00204 	addi	sp,sp,8
81111b08:	f800283a 	ret

81111b0c <bPrepareDoubleBuffer>:
#endif


bool bPrepareDoubleBuffer( TCcdMemMap *xCcdMapLocal, unsigned char ucMem, unsigned char ucID, TNFee *pxNFee ) {
81111b0c:	defff804 	addi	sp,sp,-32
81111b10:	de00012e 	bgeu	sp,et,81111b18 <bPrepareDoubleBuffer+0xc>
81111b14:	003b68fa 	trap	3
81111b18:	dfc00715 	stw	ra,28(sp)
81111b1c:	df000615 	stw	fp,24(sp)
81111b20:	df000604 	addi	fp,sp,24
81111b24:	e13ffc15 	stw	r4,-16(fp)
81111b28:	2807883a 	mov	r3,r5
81111b2c:	3005883a 	mov	r2,r6
81111b30:	e1ffff15 	stw	r7,-4(fp)
81111b34:	e0fffd05 	stb	r3,-12(fp)
81111b38:	e0bffe05 	stb	r2,-8(fp)
	bool  bDmaReturn;
	unsigned long ulLengthBlocks;

	bDmaReturn = FALSE;
81111b3c:	e03ffa15 	stw	zero,-24(fp)
	xCcdMapLocal->ulBlockI = 0;
81111b40:	e0bffc17 	ldw	r2,-16(fp)
81111b44:	10000115 	stw	zero,4(r2)
	xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
81111b48:	e0bffc17 	ldw	r2,-16(fp)
81111b4c:	10c00017 	ldw	r3,0(r2)
81111b50:	e0bffc17 	ldw	r2,-16(fp)
81111b54:	10c00215 	stw	r3,8(r2)


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
81111b58:	e0bffc17 	ldw	r2,-16(fp)
81111b5c:	10800117 	ldw	r2,4(r2)
81111b60:	10c00404 	addi	r3,r2,16
81111b64:	e0bfff17 	ldw	r2,-4(fp)
81111b68:	10800417 	ldw	r2,16(r2)
81111b6c:	18800736 	bltu	r3,r2,81111b8c <bPrepareDoubleBuffer+0x80>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
81111b70:	e0bfff17 	ldw	r2,-4(fp)
81111b74:	10c00417 	ldw	r3,16(r2)
81111b78:	e0bffc17 	ldw	r2,-16(fp)
81111b7c:	10800117 	ldw	r2,4(r2)
81111b80:	1885c83a 	sub	r2,r3,r2
81111b84:	e0bffb15 	stw	r2,-20(fp)
81111b88:	00000206 	br	81111b94 <bPrepareDoubleBuffer+0x88>

	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
81111b8c:	00800404 	movi	r2,16
81111b90:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
81111b94:	00a045b4 	movhi	r2,33046
81111b98:	109fe204 	addi	r2,r2,32648
81111b9c:	10800d0b 	ldhu	r2,52(r2)
81111ba0:	10bfffcc 	andi	r2,r2,65535
81111ba4:	10000b1e 	bne	r2,zero,81111bd4 <bPrepareDoubleBuffer+0xc8>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
81111ba8:	e0bffb17 	ldw	r2,-20(fp)
81111bac:	10803fcc 	andi	r2,r2,255
81111bb0:	000b883a 	mov	r5,zero
81111bb4:	1009883a 	mov	r4,r2
81111bb8:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
81111bbc:	e0bffb17 	ldw	r2,-20(fp)
81111bc0:	10803fcc 	andi	r2,r2,255
81111bc4:	01400044 	movi	r5,1
81111bc8:	1009883a 	mov	r4,r2
81111bcc:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
81111bd0:	00000a06 	br	81111bfc <bPrepareDoubleBuffer+0xf0>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
81111bd4:	e0bffb17 	ldw	r2,-20(fp)
81111bd8:	10803fcc 	andi	r2,r2,255
81111bdc:	000b883a 	mov	r5,zero
81111be0:	1009883a 	mov	r4,r2
81111be4:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
81111be8:	e0bffb17 	ldw	r2,-20(fp)
81111bec:	10803fcc 	andi	r2,r2,255
81111bf0:	01400044 	movi	r5,1
81111bf4:	1009883a 	mov	r4,r2
81111bf8:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
	}

	if (  ucMem == 0  ) {
81111bfc:	e0bffd03 	ldbu	r2,-12(fp)
81111c00:	1000231e 	bne	r2,zero,81111c90 <bPrepareDoubleBuffer+0x184>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81111c04:	e0bffc17 	ldw	r2,-16(fp)
81111c08:	10800217 	ldw	r2,8(r2)
81111c0c:	1011883a 	mov	r8,r2
81111c10:	e0bffb17 	ldw	r2,-20(fp)
81111c14:	10ffffcc 	andi	r3,r2,65535
81111c18:	d0a05603 	ldbu	r2,-32424(gp)
81111c1c:	11003fcc 	andi	r4,r2,255
81111c20:	e0bfff17 	ldw	r2,-4(fp)
81111c24:	10800043 	ldbu	r2,1(r2)
81111c28:	10803fcc 	andi	r2,r2,255
81111c2c:	100f883a 	mov	r7,r2
81111c30:	200d883a 	mov	r6,r4
81111c34:	180b883a 	mov	r5,r3
81111c38:	4009883a 	mov	r4,r8
81111c3c:	1103cb00 	call	81103cb0 <bSdmaDmaM1Transfer>
81111c40:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111c44:	e0bffa17 	ldw	r2,-24(fp)
81111c48:	10800058 	cmpnei	r2,r2,1
81111c4c:	10000e1e 	bne	r2,zero,81111c88 <bPrepareDoubleBuffer+0x17c>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81111c50:	e0bffc17 	ldw	r2,-16(fp)
81111c54:	10c00217 	ldw	r3,8(r2)
81111c58:	e0bffb17 	ldw	r2,-20(fp)
81111c5c:	10802224 	muli	r2,r2,136
81111c60:	1887883a 	add	r3,r3,r2
81111c64:	e0bffc17 	ldw	r2,-16(fp)
81111c68:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81111c6c:	e0bffc17 	ldw	r2,-16(fp)
81111c70:	10c00117 	ldw	r3,4(r2)
81111c74:	e0bffb17 	ldw	r2,-20(fp)
81111c78:	1887883a 	add	r3,r3,r2
81111c7c:	e0bffc17 	ldw	r2,-16(fp)
81111c80:	10c00115 	stw	r3,4(r2)
81111c84:	00002506 	br	81111d1c <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
81111c88:	e0bffa17 	ldw	r2,-24(fp)
81111c8c:	00009506 	br	81111ee4 <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81111c90:	e0bffc17 	ldw	r2,-16(fp)
81111c94:	10800217 	ldw	r2,8(r2)
81111c98:	1011883a 	mov	r8,r2
81111c9c:	e0bffb17 	ldw	r2,-20(fp)
81111ca0:	10ffffcc 	andi	r3,r2,65535
81111ca4:	d0a05603 	ldbu	r2,-32424(gp)
81111ca8:	11003fcc 	andi	r4,r2,255
81111cac:	e0bfff17 	ldw	r2,-4(fp)
81111cb0:	10800043 	ldbu	r2,1(r2)
81111cb4:	10803fcc 	andi	r2,r2,255
81111cb8:	100f883a 	mov	r7,r2
81111cbc:	200d883a 	mov	r6,r4
81111cc0:	180b883a 	mov	r5,r3
81111cc4:	4009883a 	mov	r4,r8
81111cc8:	11041040 	call	81104104 <bSdmaDmaM2Transfer>
81111ccc:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111cd0:	e0bffa17 	ldw	r2,-24(fp)
81111cd4:	10800058 	cmpnei	r2,r2,1
81111cd8:	10000e1e 	bne	r2,zero,81111d14 <bPrepareDoubleBuffer+0x208>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81111cdc:	e0bffc17 	ldw	r2,-16(fp)
81111ce0:	10c00217 	ldw	r3,8(r2)
81111ce4:	e0bffb17 	ldw	r2,-20(fp)
81111ce8:	10802224 	muli	r2,r2,136
81111cec:	1887883a 	add	r3,r3,r2
81111cf0:	e0bffc17 	ldw	r2,-16(fp)
81111cf4:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81111cf8:	e0bffc17 	ldw	r2,-16(fp)
81111cfc:	10c00117 	ldw	r3,4(r2)
81111d00:	e0bffb17 	ldw	r2,-20(fp)
81111d04:	1887883a 	add	r3,r3,r2
81111d08:	e0bffc17 	ldw	r2,-16(fp)
81111d0c:	10c00115 	stw	r3,4(r2)
81111d10:	00000206 	br	81111d1c <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
81111d14:	e0bffa17 	ldw	r2,-24(fp)
81111d18:	00007206 	br	81111ee4 <bPrepareDoubleBuffer+0x3d8>
	}


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
81111d1c:	e0bffc17 	ldw	r2,-16(fp)
81111d20:	10800117 	ldw	r2,4(r2)
81111d24:	10c00404 	addi	r3,r2,16
81111d28:	e0bfff17 	ldw	r2,-4(fp)
81111d2c:	10800417 	ldw	r2,16(r2)
81111d30:	18800736 	bltu	r3,r2,81111d50 <bPrepareDoubleBuffer+0x244>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
81111d34:	e0bfff17 	ldw	r2,-4(fp)
81111d38:	10c00417 	ldw	r3,16(r2)
81111d3c:	e0bffc17 	ldw	r2,-16(fp)
81111d40:	10800117 	ldw	r2,4(r2)
81111d44:	1885c83a 	sub	r2,r3,r2
81111d48:	e0bffb15 	stw	r2,-20(fp)
81111d4c:	00000206 	br	81111d58 <bPrepareDoubleBuffer+0x24c>
	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
81111d50:	00800404 	movi	r2,16
81111d54:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
81111d58:	00a045b4 	movhi	r2,33046
81111d5c:	109fe204 	addi	r2,r2,32648
81111d60:	10800d0b 	ldhu	r2,52(r2)
81111d64:	10bfffcc 	andi	r2,r2,65535
81111d68:	10000b1e 	bne	r2,zero,81111d98 <bPrepareDoubleBuffer+0x28c>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
81111d6c:	e0bffb17 	ldw	r2,-20(fp)
81111d70:	10803fcc 	andi	r2,r2,255
81111d74:	000b883a 	mov	r5,zero
81111d78:	1009883a 	mov	r4,r2
81111d7c:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
81111d80:	e0bffb17 	ldw	r2,-20(fp)
81111d84:	10803fcc 	andi	r2,r2,255
81111d88:	01400044 	movi	r5,1
81111d8c:	1009883a 	mov	r4,r2
81111d90:	11058380 	call	81105838 <bFeebCh1SetBufferSize>
81111d94:	00000a06 	br	81111dc0 <bPrepareDoubleBuffer+0x2b4>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
81111d98:	e0bffb17 	ldw	r2,-20(fp)
81111d9c:	10803fcc 	andi	r2,r2,255
81111da0:	000b883a 	mov	r5,zero
81111da4:	1009883a 	mov	r4,r2
81111da8:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
81111dac:	e0bffb17 	ldw	r2,-20(fp)
81111db0:	10803fcc 	andi	r2,r2,255
81111db4:	01400044 	movi	r5,1
81111db8:	1009883a 	mov	r4,r2
81111dbc:	110590c0 	call	8110590c <bFeebCh2SetBufferSize>
	}

	if (  ucMem == 0  ) {
81111dc0:	e0bffd03 	ldbu	r2,-12(fp)
81111dc4:	1000231e 	bne	r2,zero,81111e54 <bPrepareDoubleBuffer+0x348>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81111dc8:	e0bffc17 	ldw	r2,-16(fp)
81111dcc:	10800217 	ldw	r2,8(r2)
81111dd0:	1011883a 	mov	r8,r2
81111dd4:	e0bffb17 	ldw	r2,-20(fp)
81111dd8:	10ffffcc 	andi	r3,r2,65535
81111ddc:	d0a05603 	ldbu	r2,-32424(gp)
81111de0:	11003fcc 	andi	r4,r2,255
81111de4:	e0bfff17 	ldw	r2,-4(fp)
81111de8:	10800043 	ldbu	r2,1(r2)
81111dec:	10803fcc 	andi	r2,r2,255
81111df0:	100f883a 	mov	r7,r2
81111df4:	200d883a 	mov	r6,r4
81111df8:	180b883a 	mov	r5,r3
81111dfc:	4009883a 	mov	r4,r8
81111e00:	1103cb00 	call	81103cb0 <bSdmaDmaM1Transfer>
81111e04:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111e08:	e0bffa17 	ldw	r2,-24(fp)
81111e0c:	10800058 	cmpnei	r2,r2,1
81111e10:	10000e1e 	bne	r2,zero,81111e4c <bPrepareDoubleBuffer+0x340>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81111e14:	e0bffc17 	ldw	r2,-16(fp)
81111e18:	10c00217 	ldw	r3,8(r2)
81111e1c:	e0bffb17 	ldw	r2,-20(fp)
81111e20:	10802224 	muli	r2,r2,136
81111e24:	1887883a 	add	r3,r3,r2
81111e28:	e0bffc17 	ldw	r2,-16(fp)
81111e2c:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81111e30:	e0bffc17 	ldw	r2,-16(fp)
81111e34:	10c00117 	ldw	r3,4(r2)
81111e38:	e0bffb17 	ldw	r2,-20(fp)
81111e3c:	1887883a 	add	r3,r3,r2
81111e40:	e0bffc17 	ldw	r2,-16(fp)
81111e44:	10c00115 	stw	r3,4(r2)
81111e48:	00002506 	br	81111ee0 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
81111e4c:	e0bffa17 	ldw	r2,-24(fp)
81111e50:	00002406 	br	81111ee4 <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81111e54:	e0bffc17 	ldw	r2,-16(fp)
81111e58:	10800217 	ldw	r2,8(r2)
81111e5c:	1011883a 	mov	r8,r2
81111e60:	e0bffb17 	ldw	r2,-20(fp)
81111e64:	10ffffcc 	andi	r3,r2,65535
81111e68:	d0a05603 	ldbu	r2,-32424(gp)
81111e6c:	11003fcc 	andi	r4,r2,255
81111e70:	e0bfff17 	ldw	r2,-4(fp)
81111e74:	10800043 	ldbu	r2,1(r2)
81111e78:	10803fcc 	andi	r2,r2,255
81111e7c:	100f883a 	mov	r7,r2
81111e80:	200d883a 	mov	r6,r4
81111e84:	180b883a 	mov	r5,r3
81111e88:	4009883a 	mov	r4,r8
81111e8c:	11041040 	call	81104104 <bSdmaDmaM2Transfer>
81111e90:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111e94:	e0bffa17 	ldw	r2,-24(fp)
81111e98:	10800058 	cmpnei	r2,r2,1
81111e9c:	10000e1e 	bne	r2,zero,81111ed8 <bPrepareDoubleBuffer+0x3cc>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81111ea0:	e0bffc17 	ldw	r2,-16(fp)
81111ea4:	10c00217 	ldw	r3,8(r2)
81111ea8:	e0bffb17 	ldw	r2,-20(fp)
81111eac:	10802224 	muli	r2,r2,136
81111eb0:	1887883a 	add	r3,r3,r2
81111eb4:	e0bffc17 	ldw	r2,-16(fp)
81111eb8:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81111ebc:	e0bffc17 	ldw	r2,-16(fp)
81111ec0:	10c00117 	ldw	r3,4(r2)
81111ec4:	e0bffb17 	ldw	r2,-20(fp)
81111ec8:	1887883a 	add	r3,r3,r2
81111ecc:	e0bffc17 	ldw	r2,-16(fp)
81111ed0:	10c00115 	stw	r3,4(r2)
81111ed4:	00000206 	br	81111ee0 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
81111ed8:	e0bffa17 	ldw	r2,-24(fp)
81111edc:	00000106 	br	81111ee4 <bPrepareDoubleBuffer+0x3d8>
	}

	return bDmaReturn;
81111ee0:	e0bffa17 	ldw	r2,-24(fp)

}
81111ee4:	e037883a 	mov	sp,fp
81111ee8:	dfc00117 	ldw	ra,4(sp)
81111eec:	df000017 	ldw	fp,0(sp)
81111ef0:	dec00204 	addi	sp,sp,8
81111ef4:	f800283a 	ret

81111ef8 <vLoadCtemp>:


void vLoadCtemp(void) {
81111ef8:	deffff04 	addi	sp,sp,-4
81111efc:	de00012e 	bgeu	sp,et,81111f04 <vLoadCtemp+0xc>
81111f00:	003b68fa 	trap	3
81111f04:	df000015 	stw	fp,0(sp)
81111f08:	d839883a 	mov	fp,sp
	cTemp[0]="usiHkCcd1VodE";
81111f0c:	00a04574 	movhi	r2,33045
81111f10:	10938404 	addi	r2,r2,19984
81111f14:	00e04574 	movhi	r3,33045
81111f18:	18f95704 	addi	r3,r3,-6820
81111f1c:	10c00015 	stw	r3,0(r2)
	cTemp[1]="usiHkCcd1VodF";
81111f20:	00a04574 	movhi	r2,33045
81111f24:	10938404 	addi	r2,r2,19984
81111f28:	00e04574 	movhi	r3,33045
81111f2c:	18f95b04 	addi	r3,r3,-6804
81111f30:	10c00115 	stw	r3,4(r2)
	cTemp[2]="usiHkCcd1VrdMon";
81111f34:	00a04574 	movhi	r2,33045
81111f38:	10938404 	addi	r2,r2,19984
81111f3c:	00e04574 	movhi	r3,33045
81111f40:	18f95f04 	addi	r3,r3,-6788
81111f44:	10c00215 	stw	r3,8(r2)
	cTemp[3]="usiHkCcd2VodE";
81111f48:	00a04574 	movhi	r2,33045
81111f4c:	10938404 	addi	r2,r2,19984
81111f50:	00e04574 	movhi	r3,33045
81111f54:	18f96304 	addi	r3,r3,-6772
81111f58:	10c00315 	stw	r3,12(r2)
	cTemp[4]="usiHkCcd2VodF";
81111f5c:	00a04574 	movhi	r2,33045
81111f60:	10938404 	addi	r2,r2,19984
81111f64:	00e04574 	movhi	r3,33045
81111f68:	18f96704 	addi	r3,r3,-6756
81111f6c:	10c00415 	stw	r3,16(r2)
	cTemp[5]="usiHkCcd2VrdMon";
81111f70:	00a04574 	movhi	r2,33045
81111f74:	10938404 	addi	r2,r2,19984
81111f78:	00e04574 	movhi	r3,33045
81111f7c:	18f96b04 	addi	r3,r3,-6740
81111f80:	10c00515 	stw	r3,20(r2)
	cTemp[6]="usiHkCcd3VodE";
81111f84:	00a04574 	movhi	r2,33045
81111f88:	10938404 	addi	r2,r2,19984
81111f8c:	00e04574 	movhi	r3,33045
81111f90:	18f96f04 	addi	r3,r3,-6724
81111f94:	10c00615 	stw	r3,24(r2)
	cTemp[7]="usiHkCcd3VodF";
81111f98:	00a04574 	movhi	r2,33045
81111f9c:	10938404 	addi	r2,r2,19984
81111fa0:	00e04574 	movhi	r3,33045
81111fa4:	18f97304 	addi	r3,r3,-6708
81111fa8:	10c00715 	stw	r3,28(r2)
	cTemp[8]="usiHkCcd3VrdMon";
81111fac:	00a04574 	movhi	r2,33045
81111fb0:	10938404 	addi	r2,r2,19984
81111fb4:	00e04574 	movhi	r3,33045
81111fb8:	18f97704 	addi	r3,r3,-6692
81111fbc:	10c00815 	stw	r3,32(r2)
	cTemp[9]="usiHkCcd4VodE";
81111fc0:	00a04574 	movhi	r2,33045
81111fc4:	10938404 	addi	r2,r2,19984
81111fc8:	00e04574 	movhi	r3,33045
81111fcc:	18f97b04 	addi	r3,r3,-6676
81111fd0:	10c00915 	stw	r3,36(r2)
	cTemp[10]="usiHkCcd4VodF";
81111fd4:	00a04574 	movhi	r2,33045
81111fd8:	10938404 	addi	r2,r2,19984
81111fdc:	00e04574 	movhi	r3,33045
81111fe0:	18f97f04 	addi	r3,r3,-6660
81111fe4:	10c00a15 	stw	r3,40(r2)
	cTemp[11]="usiHkCcd4VrdMon";
81111fe8:	00a04574 	movhi	r2,33045
81111fec:	10938404 	addi	r2,r2,19984
81111ff0:	00e04574 	movhi	r3,33045
81111ff4:	18f98304 	addi	r3,r3,-6644
81111ff8:	10c00b15 	stw	r3,44(r2)
	cTemp[12]="usiHkVccd";
81111ffc:	00a04574 	movhi	r2,33045
81112000:	10938404 	addi	r2,r2,19984
81112004:	00e04574 	movhi	r3,33045
81112008:	18f98704 	addi	r3,r3,-6628
8111200c:	10c00c15 	stw	r3,48(r2)
	cTemp[13]="usiHkVrclk";
81112010:	00a04574 	movhi	r2,33045
81112014:	10938404 	addi	r2,r2,19984
81112018:	00e04574 	movhi	r3,33045
8111201c:	18f98a04 	addi	r3,r3,-6616
81112020:	10c00d15 	stw	r3,52(r2)
	cTemp[14]="usiHkViclk";
81112024:	00a04574 	movhi	r2,33045
81112028:	10938404 	addi	r2,r2,19984
8111202c:	00e04574 	movhi	r3,33045
81112030:	18f98d04 	addi	r3,r3,-6604
81112034:	10c00e15 	stw	r3,56(r2)
	cTemp[15]="usiHkVrclkLow";
81112038:	00a04574 	movhi	r2,33045
8111203c:	10938404 	addi	r2,r2,19984
81112040:	00e04574 	movhi	r3,33045
81112044:	18f99004 	addi	r3,r3,-6592
81112048:	10c00f15 	stw	r3,60(r2)
	cTemp[16]="usiHk5vbPos";
8111204c:	00a04574 	movhi	r2,33045
81112050:	10938404 	addi	r2,r2,19984
81112054:	00e04574 	movhi	r3,33045
81112058:	18f99404 	addi	r3,r3,-6576
8111205c:	10c01015 	stw	r3,64(r2)
	cTemp[17]="usiHk5vbNeg";
81112060:	00a04574 	movhi	r2,33045
81112064:	10938404 	addi	r2,r2,19984
81112068:	00e04574 	movhi	r3,33045
8111206c:	18f99704 	addi	r3,r3,-6564
81112070:	10c01115 	stw	r3,68(r2)
	cTemp[18]="usiHk33vbPos";
81112074:	00a04574 	movhi	r2,33045
81112078:	10938404 	addi	r2,r2,19984
8111207c:	00e04574 	movhi	r3,33045
81112080:	18f99a04 	addi	r3,r3,-6552
81112084:	10c01215 	stw	r3,72(r2)
	cTemp[19]="usiHk25vaPos";
81112088:	00a04574 	movhi	r2,33045
8111208c:	10938404 	addi	r2,r2,19984
81112090:	00e04574 	movhi	r3,33045
81112094:	18f99e04 	addi	r3,r3,-6536
81112098:	10c01315 	stw	r3,76(r2)
	cTemp[20]="usiHk33vdPos";
8111209c:	00a04574 	movhi	r2,33045
811120a0:	10938404 	addi	r2,r2,19984
811120a4:	00e04574 	movhi	r3,33045
811120a8:	18f9a204 	addi	r3,r3,-6520
811120ac:	10c01415 	stw	r3,80(r2)
	cTemp[21]="usiHk25vdPos";
811120b0:	00a04574 	movhi	r2,33045
811120b4:	10938404 	addi	r2,r2,19984
811120b8:	00e04574 	movhi	r3,33045
811120bc:	18f9a604 	addi	r3,r3,-6504
811120c0:	10c01515 	stw	r3,84(r2)
	cTemp[22]="usiHk15vdPos";
811120c4:	00a04574 	movhi	r2,33045
811120c8:	10938404 	addi	r2,r2,19984
811120cc:	00e04574 	movhi	r3,33045
811120d0:	18f9aa04 	addi	r3,r3,-6488
811120d4:	10c01615 	stw	r3,88(r2)
	cTemp[23]="usiHk5vref";
811120d8:	00a04574 	movhi	r2,33045
811120dc:	10938404 	addi	r2,r2,19984
811120e0:	00e04574 	movhi	r3,33045
811120e4:	18f9ae04 	addi	r3,r3,-6472
811120e8:	10c01715 	stw	r3,92(r2)
	cTemp[24]="usiHkVccdPosRaw";
811120ec:	00a04574 	movhi	r2,33045
811120f0:	10938404 	addi	r2,r2,19984
811120f4:	00e04574 	movhi	r3,33045
811120f8:	18f9b104 	addi	r3,r3,-6460
811120fc:	10c01815 	stw	r3,96(r2)
	cTemp[25]="usiHkVclkPosRaw";
81112100:	00a04574 	movhi	r2,33045
81112104:	10938404 	addi	r2,r2,19984
81112108:	00e04574 	movhi	r3,33045
8111210c:	18f9b504 	addi	r3,r3,-6444
81112110:	10c01915 	stw	r3,100(r2)
	cTemp[26]="usiHkVan1PosRaw";
81112114:	00a04574 	movhi	r2,33045
81112118:	10938404 	addi	r2,r2,19984
8111211c:	00e04574 	movhi	r3,33045
81112120:	18f9b904 	addi	r3,r3,-6428
81112124:	10c01a15 	stw	r3,104(r2)
	cTemp[27]="usiHkVan3NegRaw";
81112128:	00a04574 	movhi	r2,33045
8111212c:	10938404 	addi	r2,r2,19984
81112130:	00e04574 	movhi	r3,33045
81112134:	18f9bd04 	addi	r3,r3,-6412
81112138:	10c01b15 	stw	r3,108(r2)
	cTemp[28]="usiHkVan2PosRaw";
8111213c:	00a04574 	movhi	r2,33045
81112140:	10938404 	addi	r2,r2,19984
81112144:	00e04574 	movhi	r3,33045
81112148:	18f9c104 	addi	r3,r3,-6396
8111214c:	10c01c15 	stw	r3,112(r2)
	cTemp[29]="usiHkVdigFpgaRaw";
81112150:	00a04574 	movhi	r2,33045
81112154:	10938404 	addi	r2,r2,19984
81112158:	00e04574 	movhi	r3,33045
8111215c:	18f9c504 	addi	r3,r3,-6380
81112160:	10c01d15 	stw	r3,116(r2)
	cTemp[30]="usiHkVdigSpwRaw";
81112164:	00a04574 	movhi	r2,33045
81112168:	10938404 	addi	r2,r2,19984
8111216c:	00e04574 	movhi	r3,33045
81112170:	18f9ca04 	addi	r3,r3,-6360
81112174:	10c01e15 	stw	r3,120(r2)
	cTemp[31]="usiHkViclkLow";
81112178:	00a04574 	movhi	r2,33045
8111217c:	10938404 	addi	r2,r2,19984
81112180:	00e04574 	movhi	r3,33045
81112184:	18f9ce04 	addi	r3,r3,-6344
81112188:	10c01f15 	stw	r3,124(r2)
	cTemp[32]="usiHkAdcTempAE";
8111218c:	00a04574 	movhi	r2,33045
81112190:	10938404 	addi	r2,r2,19984
81112194:	00e04574 	movhi	r3,33045
81112198:	18f9d204 	addi	r3,r3,-6328
8111219c:	10c02015 	stw	r3,128(r2)
	cTemp[33]="usiHkAdcTempAF";
811121a0:	00a04574 	movhi	r2,33045
811121a4:	10938404 	addi	r2,r2,19984
811121a8:	00e04574 	movhi	r3,33045
811121ac:	18f9d604 	addi	r3,r3,-6312
811121b0:	10c02115 	stw	r3,132(r2)
	cTemp[34]="usiHkCcd1Temp";
811121b4:	00a04574 	movhi	r2,33045
811121b8:	10938404 	addi	r2,r2,19984
811121bc:	00e04574 	movhi	r3,33045
811121c0:	18f9da04 	addi	r3,r3,-6296
811121c4:	10c02215 	stw	r3,136(r2)
	cTemp[35]="usiHkCcd2Temp";
811121c8:	00a04574 	movhi	r2,33045
811121cc:	10938404 	addi	r2,r2,19984
811121d0:	00e04574 	movhi	r3,33045
811121d4:	18f9de04 	addi	r3,r3,-6280
811121d8:	10c02315 	stw	r3,140(r2)
	cTemp[36]="usiHkCcd3Temp";
811121dc:	00a04574 	movhi	r2,33045
811121e0:	10938404 	addi	r2,r2,19984
811121e4:	00e04574 	movhi	r3,33045
811121e8:	18f9e204 	addi	r3,r3,-6264
811121ec:	10c02415 	stw	r3,144(r2)
	cTemp[37]="usiHkCcd4Temp";
811121f0:	00a04574 	movhi	r2,33045
811121f4:	10938404 	addi	r2,r2,19984
811121f8:	00e04574 	movhi	r3,33045
811121fc:	18f9e604 	addi	r3,r3,-6248
81112200:	10c02515 	stw	r3,148(r2)
	cTemp[38]="usiHkWp605Spare";
81112204:	00a04574 	movhi	r2,33045
81112208:	10938404 	addi	r2,r2,19984
8111220c:	00e04574 	movhi	r3,33045
81112210:	18f9ea04 	addi	r3,r3,-6232
81112214:	10c02615 	stw	r3,152(r2)
	cTemp[39]="usiLowresPrtA0";
81112218:	00a04574 	movhi	r2,33045
8111221c:	10938404 	addi	r2,r2,19984
81112220:	00e04574 	movhi	r3,33045
81112224:	18f9ee04 	addi	r3,r3,-6216
81112228:	10c02715 	stw	r3,156(r2)
	cTemp[40]="usiLowresPrtA1";
8111222c:	00a04574 	movhi	r2,33045
81112230:	10938404 	addi	r2,r2,19984
81112234:	00e04574 	movhi	r3,33045
81112238:	18f9f204 	addi	r3,r3,-6200
8111223c:	10c02815 	stw	r3,160(r2)
	cTemp[41]="usiLowresPrtA2";
81112240:	00a04574 	movhi	r2,33045
81112244:	10938404 	addi	r2,r2,19984
81112248:	00e04574 	movhi	r3,33045
8111224c:	18f9f604 	addi	r3,r3,-6184
81112250:	10c02915 	stw	r3,164(r2)
	cTemp[42]="usiLowresPrtA3";
81112254:	00a04574 	movhi	r2,33045
81112258:	10938404 	addi	r2,r2,19984
8111225c:	00e04574 	movhi	r3,33045
81112260:	18f9fa04 	addi	r3,r3,-6168
81112264:	10c02a15 	stw	r3,168(r2)
	cTemp[43]="usiLowresPrtA4";
81112268:	00a04574 	movhi	r2,33045
8111226c:	10938404 	addi	r2,r2,19984
81112270:	00e04574 	movhi	r3,33045
81112274:	18f9fe04 	addi	r3,r3,-6152
81112278:	10c02b15 	stw	r3,172(r2)
	cTemp[44]="usiLowresPrtA5";
8111227c:	00a04574 	movhi	r2,33045
81112280:	10938404 	addi	r2,r2,19984
81112284:	00e04574 	movhi	r3,33045
81112288:	18fa0204 	addi	r3,r3,-6136
8111228c:	10c02c15 	stw	r3,176(r2)
	cTemp[45]="usiLowresPrtA6";
81112290:	00a04574 	movhi	r2,33045
81112294:	10938404 	addi	r2,r2,19984
81112298:	00e04574 	movhi	r3,33045
8111229c:	18fa0604 	addi	r3,r3,-6120
811122a0:	10c02d15 	stw	r3,180(r2)
	cTemp[46]="usiLowresPrtA7";
811122a4:	00a04574 	movhi	r2,33045
811122a8:	10938404 	addi	r2,r2,19984
811122ac:	00e04574 	movhi	r3,33045
811122b0:	18fa0a04 	addi	r3,r3,-6104
811122b4:	10c02e15 	stw	r3,184(r2)
	cTemp[47]="usiLowresPrtA8";
811122b8:	00a04574 	movhi	r2,33045
811122bc:	10938404 	addi	r2,r2,19984
811122c0:	00e04574 	movhi	r3,33045
811122c4:	18fa0e04 	addi	r3,r3,-6088
811122c8:	10c02f15 	stw	r3,188(r2)
	cTemp[48]="usiLowresPrtA9";
811122cc:	00a04574 	movhi	r2,33045
811122d0:	10938404 	addi	r2,r2,19984
811122d4:	00e04574 	movhi	r3,33045
811122d8:	18fa1204 	addi	r3,r3,-6072
811122dc:	10c03015 	stw	r3,192(r2)
	cTemp[49]="usiLowresPrtA10";
811122e0:	00a04574 	movhi	r2,33045
811122e4:	10938404 	addi	r2,r2,19984
811122e8:	00e04574 	movhi	r3,33045
811122ec:	18fa1604 	addi	r3,r3,-6056
811122f0:	10c03115 	stw	r3,196(r2)
	cTemp[50]="usiLowresPrtA11";
811122f4:	00a04574 	movhi	r2,33045
811122f8:	10938404 	addi	r2,r2,19984
811122fc:	00e04574 	movhi	r3,33045
81112300:	18fa1a04 	addi	r3,r3,-6040
81112304:	10c03215 	stw	r3,200(r2)
	cTemp[51]="usiLowresPrtA12";
81112308:	00a04574 	movhi	r2,33045
8111230c:	10938404 	addi	r2,r2,19984
81112310:	00e04574 	movhi	r3,33045
81112314:	18fa1e04 	addi	r3,r3,-6024
81112318:	10c03315 	stw	r3,204(r2)
	cTemp[52]="usiLowresPrtA13";
8111231c:	00a04574 	movhi	r2,33045
81112320:	10938404 	addi	r2,r2,19984
81112324:	00e04574 	movhi	r3,33045
81112328:	18fa2204 	addi	r3,r3,-6008
8111232c:	10c03415 	stw	r3,208(r2)
	cTemp[53]="usiLowresPrtA14";
81112330:	00a04574 	movhi	r2,33045
81112334:	10938404 	addi	r2,r2,19984
81112338:	00e04574 	movhi	r3,33045
8111233c:	18fa2604 	addi	r3,r3,-5992
81112340:	10c03515 	stw	r3,212(r2)
	cTemp[54]="usiLowresPrtA15";
81112344:	00a04574 	movhi	r2,33045
81112348:	10938404 	addi	r2,r2,19984
8111234c:	00e04574 	movhi	r3,33045
81112350:	18fa2a04 	addi	r3,r3,-5976
81112354:	10c03615 	stw	r3,216(r2)
	cTemp[55]="usiSelHiresPrt0";
81112358:	00a04574 	movhi	r2,33045
8111235c:	10938404 	addi	r2,r2,19984
81112360:	00e04574 	movhi	r3,33045
81112364:	18fa2e04 	addi	r3,r3,-5960
81112368:	10c03715 	stw	r3,220(r2)
	cTemp[56]="usiSelHiresPrt1";
8111236c:	00a04574 	movhi	r2,33045
81112370:	10938404 	addi	r2,r2,19984
81112374:	00e04574 	movhi	r3,33045
81112378:	18fa3204 	addi	r3,r3,-5944
8111237c:	10c03815 	stw	r3,224(r2)
	cTemp[57]="usiSelHiresPrt2";
81112380:	00a04574 	movhi	r2,33045
81112384:	10938404 	addi	r2,r2,19984
81112388:	00e04574 	movhi	r3,33045
8111238c:	18fa3604 	addi	r3,r3,-5928
81112390:	10c03915 	stw	r3,228(r2)
	cTemp[58]="usiSelHiresPrt3";
81112394:	00a04574 	movhi	r2,33045
81112398:	10938404 	addi	r2,r2,19984
8111239c:	00e04574 	movhi	r3,33045
811123a0:	18fa3a04 	addi	r3,r3,-5912
811123a4:	10c03a15 	stw	r3,232(r2)
	cTemp[59]="usiSelHiresPrt4";
811123a8:	00a04574 	movhi	r2,33045
811123ac:	10938404 	addi	r2,r2,19984
811123b0:	00e04574 	movhi	r3,33045
811123b4:	18fa3e04 	addi	r3,r3,-5896
811123b8:	10c03b15 	stw	r3,236(r2)
	cTemp[60]="usiSelHiresPrt5";
811123bc:	00a04574 	movhi	r2,33045
811123c0:	10938404 	addi	r2,r2,19984
811123c4:	00e04574 	movhi	r3,33045
811123c8:	18fa4204 	addi	r3,r3,-5880
811123cc:	10c03c15 	stw	r3,240(r2)
	cTemp[61]="usiSelHiresPrt6";
811123d0:	00a04574 	movhi	r2,33045
811123d4:	10938404 	addi	r2,r2,19984
811123d8:	00e04574 	movhi	r3,33045
811123dc:	18fa4604 	addi	r3,r3,-5864
811123e0:	10c03d15 	stw	r3,244(r2)
	cTemp[62]="usiSelHiresPrt7";
811123e4:	00a04574 	movhi	r2,33045
811123e8:	10938404 	addi	r2,r2,19984
811123ec:	00e04574 	movhi	r3,33045
811123f0:	18fa4a04 	addi	r3,r3,-5848
811123f4:	10c03e15 	stw	r3,248(r2)
	cTemp[63]="usiZeroHiresAmp";
811123f8:	00a04574 	movhi	r2,33045
811123fc:	10938404 	addi	r2,r2,19984
81112400:	00e04574 	movhi	r3,33045
81112404:	18fa4e04 	addi	r3,r3,-5832
81112408:	10c03f15 	stw	r3,252(r2)
}
8111240c:	0001883a 	nop
81112410:	e037883a 	mov	sp,fp
81112414:	df000017 	ldw	fp,0(sp)
81112418:	dec00104 	addi	sp,sp,4
8111241c:	f800283a 	ret

81112420 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
81112420:	defff604 	addi	sp,sp,-40
81112424:	de00012e 	bgeu	sp,et,8111242c <vInAckHandlerTaskV2+0xc>
81112428:	003b68fa 	trap	3
8111242c:	dfc00915 	stw	ra,36(sp)
81112430:	df000815 	stw	fp,32(sp)
81112434:	df000804 	addi	fp,sp,32
81112438:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
8111243c:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
81112440:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
81112444:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
81112448:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
8111244c:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
81112450:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
81112454:	e03ffa45 	stb	zero,-23(fp)

    #if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81112458:	00a045b4 	movhi	r2,33046
8111245c:	109fe204 	addi	r2,r2,32648
81112460:	10800d8b 	ldhu	r2,54(r2)
81112464:	10bfffcc 	andi	r2,r2,65535
81112468:	10800168 	cmpgeui	r2,r2,5
8111246c:	1000071e 	bne	r2,zero,8111248c <vInAckHandlerTaskV2+0x6c>
        debug(fp,"In Ack Handler Task. (Task on)\n");
81112470:	d0a06217 	ldw	r2,-32376(gp)
81112474:	100f883a 	mov	r7,r2
81112478:	018007c4 	movi	r6,31
8111247c:	01400044 	movi	r5,1
81112480:	01204574 	movhi	r4,33045
81112484:	213a5204 	addi	r4,r4,-5816
81112488:	1122fc80 	call	81122fc8 <fwrite>
    }
    #endif

	eReceiverAckState = sRAConfiguring;
8111248c:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
81112490:	e0bff917 	ldw	r2,-28(fp)
81112494:	10c00060 	cmpeqi	r3,r2,1
81112498:	1800071e 	bne	r3,zero,811124b8 <vInAckHandlerTaskV2+0x98>
8111249c:	0080032e 	bgeu	zero,r2,811124ac <vInAckHandlerTaskV2+0x8c>
811124a0:	108000a0 	cmpeqi	r2,r2,2
811124a4:	10004a1e 	bne	r2,zero,811125d0 <vInAckHandlerTaskV2+0x1b0>
811124a8:	0000ac06 	br	8111275c <vInAckHandlerTaskV2+0x33c>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
811124ac:	00800044 	movi	r2,1
811124b0:	e0bff915 	stw	r2,-28(fp)
				break;
811124b4:	0000b906 	br	8111279c <vInAckHandlerTaskV2+0x37c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
811124b8:	00800044 	movi	r2,1
811124bc:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
811124c0:	d0a06617 	ldw	r2,-32360(gp)
811124c4:	e0fffe04 	addi	r3,fp,-8
811124c8:	180d883a 	mov	r6,r3
811124cc:	000b883a 	mov	r5,zero
811124d0:	1009883a 	mov	r4,r2
811124d4:	113fdcc0 	call	8113fdcc <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
811124d8:	e0bffe03 	ldbu	r2,-8(fp)
811124dc:	10803fcc 	andi	r2,r2,255
811124e0:	1000391e 	bne	r2,zero,811125c8 <vInAckHandlerTaskV2+0x1a8>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
811124e4:	d0a06517 	ldw	r2,-32364(gp)
811124e8:	e0fffe04 	addi	r3,fp,-8
811124ec:	180d883a 	mov	r6,r3
811124f0:	000b883a 	mov	r5,zero
811124f4:	1009883a 	mov	r4,r2
811124f8:	113ddc00 	call	8113ddc0 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
811124fc:	e0bffe03 	ldbu	r2,-8(fp)
81112500:	10803fcc 	andi	r2,r2,255
81112504:	10002b1e 	bne	r2,zero,811125b4 <vInAckHandlerTaskV2+0x194>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81112508:	e03ffa45 	stb	zero,-23(fp)
8111250c:	00002206 	br	81112598 <vInAckHandlerTaskV2+0x178>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
81112510:	e0fffa43 	ldbu	r3,-23(fp)
81112514:	00a045b4 	movhi	r2,33046
81112518:	10892004 	addi	r2,r2,9344
8111251c:	18c7883a 	add	r3,r3,r3
81112520:	18c7883a 	add	r3,r3,r3
81112524:	10c5883a 	add	r2,r2,r3
81112528:	10800003 	ldbu	r2,0(r2)
8111252c:	10803fcc 	andi	r2,r2,255
81112530:	1080201c 	xori	r2,r2,128
81112534:	10bfe004 	addi	r2,r2,-128
81112538:	10001426 	beq	r2,zero,8111258c <vInAckHandlerTaskV2+0x16c>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
8111253c:	e0fffa43 	ldbu	r3,-23(fp)
81112540:	00a045b4 	movhi	r2,33046
81112544:	10892004 	addi	r2,r2,9344
81112548:	18c7883a 	add	r3,r3,r3
8111254c:	18c7883a 	add	r3,r3,r3
81112550:	10c5883a 	add	r2,r2,r3
81112554:	10c0000b 	ldhu	r3,0(r2)
81112558:	d0e0568d 	sth	r3,-32422(gp)
8111255c:	1080008b 	ldhu	r2,2(r2)
81112560:	d0a0570d 	sth	r2,-32420(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81112564:	e0fffa43 	ldbu	r3,-23(fp)
81112568:	00a045b4 	movhi	r2,33046
8111256c:	10892004 	addi	r2,r2,9344
81112570:	18c7883a 	add	r3,r3,r3
81112574:	18c7883a 	add	r3,r3,r3
81112578:	10c5883a 	add	r2,r2,r3
8111257c:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
81112580:	00800084 	movi	r2,2
81112584:	e0bff915 	stw	r2,-28(fp)
                                break;                                
81112588:	00000606 	br	811125a4 <vInAckHandlerTaskV2+0x184>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8111258c:	e0bffa43 	ldbu	r2,-23(fp)
81112590:	10800044 	addi	r2,r2,1
81112594:	e0bffa45 	stb	r2,-23(fp)
81112598:	e0bffa43 	ldbu	r2,-23(fp)
8111259c:	108001b0 	cmpltui	r2,r2,6
811125a0:	103fdb1e 	bne	r2,zero,81112510 <__reset+0xfb0f2510>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
811125a4:	d0a06517 	ldw	r2,-32364(gp)
811125a8:	1009883a 	mov	r4,r2
811125ac:	113e3640 	call	8113e364 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
811125b0:	00007a06 	br	8111279c <vInAckHandlerTaskV2+0x37c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
811125b4:	d0a06617 	ldw	r2,-32360(gp)
811125b8:	1009883a 	mov	r4,r2
811125bc:	11401540 	call	81140154 <OSSemPost>
                    	vFailGetMutexReceiverTask();
811125c0:	111c9ac0 	call	8111c9ac <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
811125c4:	00007506 	br	8111279c <vInAckHandlerTaskV2+0x37c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
811125c8:	111c92c0 	call	8111c92c <vFailGetCountSemaphoreReceiverTask>
                }
                break;
811125cc:	00007306 	br	8111279c <vInAckHandlerTaskV2+0x37c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
811125d0:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
811125d4:	d0a06883 	ldbu	r2,-32350(gp)
811125d8:	10803fcc 	andi	r2,r2,255
811125dc:	10800218 	cmpnei	r2,r2,8
811125e0:	1000021e 	bne	r2,zero,811125ec <vInAckHandlerTaskV2+0x1cc>
811125e4:	00c00104 	movi	r3,4
811125e8:	00000106 	br	811125f0 <vInAckHandlerTaskV2+0x1d0>
811125ec:	0007883a 	mov	r3,zero
811125f0:	d0a07503 	ldbu	r2,-32300(gp)
811125f4:	10803fcc 	andi	r2,r2,255
811125f8:	10800218 	cmpnei	r2,r2,8
811125fc:	1000021e 	bne	r2,zero,81112608 <vInAckHandlerTaskV2+0x1e8>
81112600:	00800084 	movi	r2,2
81112604:	00000106 	br	8111260c <vInAckHandlerTaskV2+0x1ec>
81112608:	0005883a 	mov	r2,zero
8111260c:	1884b03a 	or	r2,r3,r2
81112610:	1007883a 	mov	r3,r2
81112614:	d0a07543 	ldbu	r2,-32299(gp)
81112618:	10803fcc 	andi	r2,r2,255
8111261c:	108001a0 	cmpeqi	r2,r2,6
81112620:	1884b03a 	or	r2,r3,r2
81112624:	1007883a 	mov	r3,r2
81112628:	e0bffa83 	ldbu	r2,-22(fp)
8111262c:	1884b03a 	or	r2,r3,r2
81112630:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
81112634:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
81112638:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
8111263c:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
81112640:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
81112644:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
81112648:	e0bffa03 	ldbu	r2,-24(fp)
8111264c:	10800044 	addi	r2,r2,1
81112650:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81112654:	e0bffa83 	ldbu	r2,-22(fp)
81112658:	1080004c 	andi	r2,r2,1
8111265c:	10803fcc 	andi	r2,r2,255
81112660:	1000061e 	bne	r2,zero,8111267c <vInAckHandlerTaskV2+0x25c>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
81112664:	e0bffd04 	addi	r2,fp,-12
81112668:	100b883a 	mov	r5,r2
8111266c:	d1205684 	addi	r4,gp,-32422
81112670:	11127a00 	call	811127a0 <bCheckInAck128>
81112674:	e0bff815 	stw	r2,-32(fp)
81112678:	00000206 	br	81112684 <vInAckHandlerTaskV2+0x264>
                    else
                        bFinished128 = TRUE;
8111267c:	00800044 	movi	r2,1
81112680:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
81112684:	e0bffa83 	ldbu	r2,-22(fp)
81112688:	1080008c 	andi	r2,r2,2
8111268c:	10803fcc 	andi	r2,r2,255
81112690:	1000081e 	bne	r2,zero,811126b4 <vInAckHandlerTaskV2+0x294>
81112694:	e0bff817 	ldw	r2,-32(fp)
81112698:	1000061e 	bne	r2,zero,811126b4 <vInAckHandlerTaskV2+0x294>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
8111269c:	e0bffc04 	addi	r2,fp,-16
811126a0:	100b883a 	mov	r5,r2
811126a4:	d1205684 	addi	r4,gp,-32422
811126a8:	11128e80 	call	811128e8 <bCheckInAck64>
811126ac:	e0bff815 	stw	r2,-32(fp)
811126b0:	00000206 	br	811126bc <vInAckHandlerTaskV2+0x29c>
                    else
                        bFinished64 = TRUE;
811126b4:	00800044 	movi	r2,1
811126b8:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
811126bc:	e0bffa83 	ldbu	r2,-22(fp)
811126c0:	1080010c 	andi	r2,r2,4
811126c4:	10803fcc 	andi	r2,r2,255
811126c8:	1000081e 	bne	r2,zero,811126ec <vInAckHandlerTaskV2+0x2cc>
811126cc:	e0bff817 	ldw	r2,-32(fp)
811126d0:	1000061e 	bne	r2,zero,811126ec <vInAckHandlerTaskV2+0x2cc>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
811126d4:	e0bffb04 	addi	r2,fp,-20
811126d8:	100b883a 	mov	r5,r2
811126dc:	d1205684 	addi	r4,gp,-32422
811126e0:	1112a340 	call	81112a34 <bCheckInAck32>
811126e4:	e0bff815 	stw	r2,-32(fp)
811126e8:	00000206 	br	811126f4 <vInAckHandlerTaskV2+0x2d4>
                    else
                        bFinished32 = TRUE;
811126ec:	00800044 	movi	r2,1
811126f0:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
811126f4:	e0bffa03 	ldbu	r2,-24(fp)
811126f8:	10c00044 	addi	r3,r2,1
811126fc:	e0fffa05 	stb	r3,-24(fp)
81112700:	10803fcc 	andi	r2,r2,255
81112704:	10800ca8 	cmpgeui	r2,r2,50
81112708:	10000e1e 	bne	r2,zero,81112744 <vInAckHandlerTaskV2+0x324>
8111270c:	e0bff817 	ldw	r2,-32(fp)
81112710:	10000c1e 	bne	r2,zero,81112744 <vInAckHandlerTaskV2+0x324>
81112714:	e0bffb17 	ldw	r2,-20(fp)
81112718:	1005003a 	cmpeq	r2,r2,zero
8111271c:	1007883a 	mov	r3,r2
81112720:	e0bffc17 	ldw	r2,-16(fp)
81112724:	1005003a 	cmpeq	r2,r2,zero
81112728:	1884b03a 	or	r2,r3,r2
8111272c:	10c03fcc 	andi	r3,r2,255
81112730:	e0bffd17 	ldw	r2,-12(fp)
81112734:	1005003a 	cmpeq	r2,r2,zero
81112738:	10803fcc 	andi	r2,r2,255
8111273c:	1884b03a 	or	r2,r3,r2
81112740:	103fc11e 	bne	r2,zero,81112648 <__reset+0xfb0f2648>
                
                if (bFound == FALSE) {
81112744:	e0bff817 	ldw	r2,-32(fp)
81112748:	1000011e 	bne	r2,zero,81112750 <vInAckHandlerTaskV2+0x330>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
8111274c:	111cfa00 	call	8111cfa0 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
81112750:	00800044 	movi	r2,1
81112754:	e0bff915 	stw	r2,-28(fp)
				break;
81112758:	00001006 	br	8111279c <vInAckHandlerTaskV2+0x37c>
			default:
                #if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly) {
8111275c:	00a045b4 	movhi	r2,33046
81112760:	109fe204 	addi	r2,r2,32648
81112764:	10800d8b 	ldhu	r2,54(r2)
81112768:	10bfffcc 	andi	r2,r2,65535
8111276c:	10800228 	cmpgeui	r2,r2,8
81112770:	1000071e 	bne	r2,zero,81112790 <vInAckHandlerTaskV2+0x370>
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
81112774:	d0a06217 	ldw	r2,-32376(gp)
81112778:	100f883a 	mov	r7,r2
8111277c:	01801144 	movi	r6,69
81112780:	01400044 	movi	r5,1
81112784:	01204574 	movhi	r4,33045
81112788:	213a5a04 	addi	r4,r4,-5784
8111278c:	1122fc80 	call	81122fc8 <fwrite>
				}
	            #endif
                eReceiverAckState = sRAGettingACK;
81112790:	00800044 	movi	r2,1
81112794:	e0bff915 	stw	r2,-28(fp)
				break;
81112798:	0001883a 	nop
		}
	}
8111279c:	003f3c06 	br	81112490 <__reset+0xfb0f2490>

811127a0 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
811127a0:	defffa04 	addi	sp,sp,-24
811127a4:	de00012e 	bgeu	sp,et,811127ac <bCheckInAck128+0xc>
811127a8:	003b68fa 	trap	3
811127ac:	dfc00515 	stw	ra,20(sp)
811127b0:	df000415 	stw	fp,16(sp)
811127b4:	df000404 	addi	fp,sp,16
811127b8:	e13ffe15 	stw	r4,-8(fp)
811127bc:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
811127c0:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811127c4:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811127c8:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
811127cc:	e0bfff17 	ldw	r2,-4(fp)
811127d0:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
811127d4:	d0a06e17 	ldw	r2,-32328(gp)
811127d8:	e0fffd44 	addi	r3,fp,-11
811127dc:	180d883a 	mov	r6,r3
811127e0:	01400144 	movi	r5,5
811127e4:	1009883a 	mov	r4,r2
811127e8:	113ddc00 	call	8113ddc0 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
811127ec:	e0bffd43 	ldbu	r2,-11(fp)
811127f0:	10803fcc 	andi	r2,r2,255
811127f4:	10000226 	beq	r2,zero,81112800 <bCheckInAck128+0x60>
        return bFound;
811127f8:	e0bffc17 	ldw	r2,-16(fp)
811127fc:	00003506 	br	811128d4 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81112800:	e03ffd05 	stb	zero,-12(fp)
81112804:	00002706 	br	811128a4 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
81112808:	e0fffd03 	ldbu	r3,-12(fp)
8111280c:	00a045b4 	movhi	r2,33046
81112810:	10801e04 	addi	r2,r2,120
81112814:	18c02324 	muli	r3,r3,140
81112818:	10c5883a 	add	r2,r2,r3
8111281c:	10802104 	addi	r2,r2,132
81112820:	10c0000b 	ldhu	r3,0(r2)
81112824:	e0bffe17 	ldw	r2,-8(fp)
81112828:	1080008b 	ldhu	r2,2(r2)
8111282c:	18ffffcc 	andi	r3,r3,65535
81112830:	10bfffcc 	andi	r2,r2,65535
81112834:	1880181e 	bne	r3,r2,81112898 <bCheckInAck128+0xf8>
            bFound = TRUE;
81112838:	00800044 	movi	r2,1
8111283c:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
81112840:	e0fffd03 	ldbu	r3,-12(fp)
81112844:	00a045b4 	movhi	r2,33046
81112848:	10800004 	addi	r2,r2,0
8111284c:	18c7883a 	add	r3,r3,r3
81112850:	18c7883a 	add	r3,r3,r3
81112854:	10c5883a 	add	r2,r2,r3
81112858:	10000015 	stw	zero,0(r2)
            SemCount128++;
8111285c:	d0a07543 	ldbu	r2,-32299(gp)
81112860:	10800044 	addi	r2,r2,1
81112864:	d0a07545 	stb	r2,-32299(gp)
            error_code = OSSemPost(xSemCountBuffer128);
81112868:	d0a06317 	ldw	r2,-32372(gp)
8111286c:	1009883a 	mov	r4,r2
81112870:	11401540 	call	81140154 <OSSemPost>
81112874:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81112878:	e0bffd43 	ldbu	r2,-11(fp)
8111287c:	10803fcc 	andi	r2,r2,255
81112880:	10000c26 	beq	r2,zero,811128b4 <bCheckInAck128+0x114>
                SemCount128--;
81112884:	d0a07543 	ldbu	r2,-32299(gp)
81112888:	10bfffc4 	addi	r2,r2,-1
8111288c:	d0a07545 	stb	r2,-32299(gp)
                vFailSetCountSemaphorexBuffer128();
81112890:	111cda00 	call	8111cda0 <vFailSetCountSemaphorexBuffer128>
            }
            break;
81112894:	00000706 	br	811128b4 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81112898:	e0bffd03 	ldbu	r2,-12(fp)
8111289c:	10800044 	addi	r2,r2,1
811128a0:	e0bffd05 	stb	r2,-12(fp)
811128a4:	e0bffd03 	ldbu	r2,-12(fp)
811128a8:	108001b0 	cmpltui	r2,r2,6
811128ac:	103fd61e 	bne	r2,zero,81112808 <__reset+0xfb0f2808>
811128b0:	00000106 	br	811128b8 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
811128b4:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
811128b8:	d0a06e17 	ldw	r2,-32328(gp)
811128bc:	1009883a 	mov	r4,r2
811128c0:	113e3640 	call	8113e364 <OSMutexPost>
    (*bFinished) = TRUE;
811128c4:	e0bfff17 	ldw	r2,-4(fp)
811128c8:	00c00044 	movi	r3,1
811128cc:	10c00015 	stw	r3,0(r2)

    return bFound;
811128d0:	e0bffc17 	ldw	r2,-16(fp)
}
811128d4:	e037883a 	mov	sp,fp
811128d8:	dfc00117 	ldw	ra,4(sp)
811128dc:	df000017 	ldw	fp,0(sp)
811128e0:	dec00204 	addi	sp,sp,8
811128e4:	f800283a 	ret

811128e8 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
811128e8:	defffa04 	addi	sp,sp,-24
811128ec:	de00012e 	bgeu	sp,et,811128f4 <bCheckInAck64+0xc>
811128f0:	003b68fa 	trap	3
811128f4:	dfc00515 	stw	ra,20(sp)
811128f8:	df000415 	stw	fp,16(sp)
811128fc:	df000404 	addi	fp,sp,16
81112900:	e13ffe15 	stw	r4,-8(fp)
81112904:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81112908:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8111290c:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81112910:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81112914:	e0bfff17 	ldw	r2,-4(fp)
81112918:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8111291c:	d0a07117 	ldw	r2,-32316(gp)
81112920:	e0fffd44 	addi	r3,fp,-11
81112924:	180d883a 	mov	r6,r3
81112928:	01400044 	movi	r5,1
8111292c:	1009883a 	mov	r4,r2
81112930:	113ddc00 	call	8113ddc0 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81112934:	e0bffd43 	ldbu	r2,-11(fp)
81112938:	10803fcc 	andi	r2,r2,255
8111293c:	10000226 	beq	r2,zero,81112948 <bCheckInAck64+0x60>
        return bFound;
81112940:	e0bffc17 	ldw	r2,-16(fp)
81112944:	00003606 	br	81112a20 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81112948:	e03ffd05 	stb	zero,-12(fp)
8111294c:	00002806 	br	811129f0 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
81112950:	e0fffd03 	ldbu	r3,-12(fp)
81112954:	00a04574 	movhi	r2,33045
81112958:	109bc404 	addi	r2,r2,28432
8111295c:	18c01324 	muli	r3,r3,76
81112960:	10c5883a 	add	r2,r2,r3
81112964:	10801104 	addi	r2,r2,68
81112968:	10c0000b 	ldhu	r3,0(r2)
8111296c:	e0bffe17 	ldw	r2,-8(fp)
81112970:	1080008b 	ldhu	r2,2(r2)
81112974:	18ffffcc 	andi	r3,r3,65535
81112978:	10bfffcc 	andi	r2,r2,65535
8111297c:	1880191e 	bne	r3,r2,811129e4 <bCheckInAck64+0xfc>
            bFound = TRUE;
81112980:	00800044 	movi	r2,1
81112984:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
81112988:	e0fffd03 	ldbu	r3,-12(fp)
8111298c:	00a045b4 	movhi	r2,33046
81112990:	10800004 	addi	r2,r2,0
81112994:	18c00184 	addi	r3,r3,6
81112998:	18c7883a 	add	r3,r3,r3
8111299c:	18c7883a 	add	r3,r3,r3
811129a0:	10c5883a 	add	r2,r2,r3
811129a4:	10000015 	stw	zero,0(r2)
            SemCount64++;
811129a8:	d0a07503 	ldbu	r2,-32300(gp)
811129ac:	10800044 	addi	r2,r2,1
811129b0:	d0a07505 	stb	r2,-32300(gp)
            error_code = OSSemPost(xSemCountBuffer64);
811129b4:	d0a05e17 	ldw	r2,-32392(gp)
811129b8:	1009883a 	mov	r4,r2
811129bc:	11401540 	call	81140154 <OSSemPost>
811129c0:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
811129c4:	e0bffd43 	ldbu	r2,-11(fp)
811129c8:	10803fcc 	andi	r2,r2,255
811129cc:	10000c26 	beq	r2,zero,81112a00 <bCheckInAck64+0x118>
                SemCount64--;
811129d0:	d0a07503 	ldbu	r2,-32300(gp)
811129d4:	10bfffc4 	addi	r2,r2,-1
811129d8:	d0a07505 	stb	r2,-32300(gp)
                vFailSetCountSemaphorexBuffer64();
811129dc:	111cd200 	call	8111cd20 <vFailSetCountSemaphorexBuffer64>
            }
            break;
811129e0:	00000706 	br	81112a00 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
811129e4:	e0bffd03 	ldbu	r2,-12(fp)
811129e8:	10800044 	addi	r2,r2,1
811129ec:	e0bffd05 	stb	r2,-12(fp)
811129f0:	e0bffd03 	ldbu	r2,-12(fp)
811129f4:	10800230 	cmpltui	r2,r2,8
811129f8:	103fd51e 	bne	r2,zero,81112950 <__reset+0xfb0f2950>
811129fc:	00000106 	br	81112a04 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
81112a00:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
81112a04:	d0a07117 	ldw	r2,-32316(gp)
81112a08:	1009883a 	mov	r4,r2
81112a0c:	113e3640 	call	8113e364 <OSMutexPost>
    (*bFinished) = TRUE;
81112a10:	e0bfff17 	ldw	r2,-4(fp)
81112a14:	00c00044 	movi	r3,1
81112a18:	10c00015 	stw	r3,0(r2)

    return bFound;
81112a1c:	e0bffc17 	ldw	r2,-16(fp)
}
81112a20:	e037883a 	mov	sp,fp
81112a24:	dfc00117 	ldw	ra,4(sp)
81112a28:	df000017 	ldw	fp,0(sp)
81112a2c:	dec00204 	addi	sp,sp,8
81112a30:	f800283a 	ret

81112a34 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
81112a34:	defffa04 	addi	sp,sp,-24
81112a38:	de00012e 	bgeu	sp,et,81112a40 <bCheckInAck32+0xc>
81112a3c:	003b68fa 	trap	3
81112a40:	dfc00515 	stw	ra,20(sp)
81112a44:	df000415 	stw	fp,16(sp)
81112a48:	df000404 	addi	fp,sp,16
81112a4c:	e13ffe15 	stw	r4,-8(fp)
81112a50:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81112a54:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81112a58:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81112a5c:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81112a60:	e0bfff17 	ldw	r2,-4(fp)
81112a64:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
81112a68:	d0a06c17 	ldw	r2,-32336(gp)
81112a6c:	e0fffd44 	addi	r3,fp,-11
81112a70:	180d883a 	mov	r6,r3
81112a74:	01400044 	movi	r5,1
81112a78:	1009883a 	mov	r4,r2
81112a7c:	113ddc00 	call	8113ddc0 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81112a80:	e0bffd43 	ldbu	r2,-11(fp)
81112a84:	10803fcc 	andi	r2,r2,255
81112a88:	10000226 	beq	r2,zero,81112a94 <bCheckInAck32+0x60>
        return bFound;
81112a8c:	e0bffc17 	ldw	r2,-16(fp)
81112a90:	00003606 	br	81112b6c <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81112a94:	e03ffd05 	stb	zero,-12(fp)
81112a98:	00002806 	br	81112b3c <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
81112a9c:	e0fffd03 	ldbu	r3,-12(fp)
81112aa0:	00a045b4 	movhi	r2,33046
81112aa4:	10ad8004 	addi	r2,r2,-18944
81112aa8:	18c00b24 	muli	r3,r3,44
81112aac:	10c5883a 	add	r2,r2,r3
81112ab0:	10800904 	addi	r2,r2,36
81112ab4:	10c0000b 	ldhu	r3,0(r2)
81112ab8:	e0bffe17 	ldw	r2,-8(fp)
81112abc:	1080008b 	ldhu	r2,2(r2)
81112ac0:	18ffffcc 	andi	r3,r3,65535
81112ac4:	10bfffcc 	andi	r2,r2,65535
81112ac8:	1880191e 	bne	r3,r2,81112b30 <bCheckInAck32+0xfc>
            bFound = TRUE;
81112acc:	00800044 	movi	r2,1
81112ad0:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
81112ad4:	e0fffd03 	ldbu	r3,-12(fp)
81112ad8:	00a045b4 	movhi	r2,33046
81112adc:	10800004 	addi	r2,r2,0
81112ae0:	18c00384 	addi	r3,r3,14
81112ae4:	18c7883a 	add	r3,r3,r3
81112ae8:	18c7883a 	add	r3,r3,r3
81112aec:	10c5883a 	add	r2,r2,r3
81112af0:	10000015 	stw	zero,0(r2)
            SemCount32++;
81112af4:	d0a06883 	ldbu	r2,-32350(gp)
81112af8:	10800044 	addi	r2,r2,1
81112afc:	d0a06885 	stb	r2,-32350(gp)
            error_code = OSSemPost(xSemCountBuffer32);
81112b00:	d0a06f17 	ldw	r2,-32324(gp)
81112b04:	1009883a 	mov	r4,r2
81112b08:	11401540 	call	81140154 <OSSemPost>
81112b0c:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81112b10:	e0bffd43 	ldbu	r2,-11(fp)
81112b14:	10803fcc 	andi	r2,r2,255
81112b18:	10000c26 	beq	r2,zero,81112b4c <bCheckInAck32+0x118>
                SemCount32--;
81112b1c:	d0a06883 	ldbu	r2,-32350(gp)
81112b20:	10bfffc4 	addi	r2,r2,-1
81112b24:	d0a06885 	stb	r2,-32350(gp)
                vFailSetCountSemaphorexBuffer32();
81112b28:	111cca00 	call	8111cca0 <vFailSetCountSemaphorexBuffer32>
            }
            break;
81112b2c:	00000706 	br	81112b4c <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81112b30:	e0bffd03 	ldbu	r2,-12(fp)
81112b34:	10800044 	addi	r2,r2,1
81112b38:	e0bffd05 	stb	r2,-12(fp)
81112b3c:	e0bffd03 	ldbu	r2,-12(fp)
81112b40:	10800230 	cmpltui	r2,r2,8
81112b44:	103fd51e 	bne	r2,zero,81112a9c <__reset+0xfb0f2a9c>
81112b48:	00000106 	br	81112b50 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
81112b4c:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
81112b50:	d0a06c17 	ldw	r2,-32336(gp)
81112b54:	1009883a 	mov	r4,r2
81112b58:	113e3640 	call	8113e364 <OSMutexPost>
    (*bFinished) = TRUE;
81112b5c:	e0bfff17 	ldw	r2,-4(fp)
81112b60:	00c00044 	movi	r3,1
81112b64:	10c00015 	stw	r3,0(r2)

    return bFound;
81112b68:	e0bffc17 	ldw	r2,-16(fp)
}
81112b6c:	e037883a 	mov	sp,fp
81112b70:	dfc00117 	ldw	ra,4(sp)
81112b74:	df000017 	ldw	fp,0(sp)
81112b78:	dec00204 	addi	sp,sp,8
81112b7c:	f800283a 	ret

81112b80 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
81112b80:	defff704 	addi	sp,sp,-36
81112b84:	de00012e 	bgeu	sp,et,81112b8c <vInitialTask+0xc>
81112b88:	003b68fa 	trap	3
81112b8c:	dfc00815 	stw	ra,32(sp)
81112b90:	df000715 	stw	fp,28(sp)
81112b94:	df000704 	addi	fp,sp,28
81112b98:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
81112b9c:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
81112ba0:	d8000415 	stw	zero,16(sp)
81112ba4:	d8000315 	stw	zero,12(sp)
81112ba8:	00810004 	movi	r2,1024
81112bac:	d8800215 	stw	r2,8(sp)
81112bb0:	00a04574 	movhi	r2,33045
81112bb4:	1093c404 	addi	r2,r2,20240
81112bb8:	d8800115 	stw	r2,4(sp)
81112bbc:	008002c4 	movi	r2,11
81112bc0:	d8800015 	stw	r2,0(sp)
81112bc4:	01c002c4 	movi	r7,11
81112bc8:	01a04574 	movhi	r6,33045
81112bcc:	3197c304 	addi	r6,r6,24332
81112bd0:	016045b4 	movhi	r5,33046
81112bd4:	2968e404 	addi	r5,r5,-23664
81112bd8:	01204474 	movhi	r4,33041
81112bdc:	2136ca04 	addi	r4,r4,-9432
81112be0:	1140b380 	call	81140b38 <OSTaskCreateExt>
81112be4:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112be8:	e0bffe03 	ldbu	r2,-8(fp)
81112bec:	10803fcc 	andi	r2,r2,255
81112bf0:	10000b26 	beq	r2,zero,81112c20 <vInitialTask+0xa0>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112bf4:	00a045b4 	movhi	r2,33046
81112bf8:	109fe204 	addi	r2,r2,32648
81112bfc:	10800d8b 	ldhu	r2,54(r2)
81112c00:	10bfffcc 	andi	r2,r2,65535
81112c04:	10800228 	cmpgeui	r2,r2,8
81112c08:	1000041e 	bne	r2,zero,81112c1c <vInitialTask+0x9c>
			printErrorTask( error_code );
81112c0c:	e0bffe03 	ldbu	r2,-8(fp)
81112c10:	10803fcc 	andi	r2,r2,255
81112c14:	1009883a 	mov	r4,r2
81112c18:	111c46c0 	call	8111c46c <printErrorTask>
		}
		#endif
			vCoudlNotCreateNFee0Task();
81112c1c:	111de280 	call	8111de28 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112c20:	01c17704 	movi	r7,1500
81112c24:	000d883a 	mov	r6,zero
81112c28:	000b883a 	mov	r5,zero
81112c2c:	0009883a 	mov	r4,zero
81112c30:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
81112c34:	d8000415 	stw	zero,16(sp)
81112c38:	d8000315 	stw	zero,12(sp)
81112c3c:	00810004 	movi	r2,1024
81112c40:	d8800215 	stw	r2,8(sp)
81112c44:	00a045b4 	movhi	r2,33046
81112c48:	10a4d204 	addi	r2,r2,-27832
81112c4c:	d8800115 	stw	r2,4(sp)
81112c50:	00800284 	movi	r2,10
81112c54:	d8800015 	stw	r2,0(sp)
81112c58:	01c00284 	movi	r7,10
81112c5c:	01a045b4 	movhi	r6,33046
81112c60:	31a8d104 	addi	r6,r6,-23740
81112c64:	016045b4 	movhi	r5,33046
81112c68:	2968dc04 	addi	r5,r5,-23696
81112c6c:	01204474 	movhi	r4,33041
81112c70:	21369c04 	addi	r4,r4,-9616
81112c74:	1140b380 	call	81140b38 <OSTaskCreateExt>
81112c78:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112c7c:	e0bffe03 	ldbu	r2,-8(fp)
81112c80:	10803fcc 	andi	r2,r2,255
81112c84:	10000b26 	beq	r2,zero,81112cb4 <vInitialTask+0x134>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112c88:	00a045b4 	movhi	r2,33046
81112c8c:	109fe204 	addi	r2,r2,32648
81112c90:	10800d8b 	ldhu	r2,54(r2)
81112c94:	10bfffcc 	andi	r2,r2,65535
81112c98:	10800228 	cmpgeui	r2,r2,8
81112c9c:	1000041e 	bne	r2,zero,81112cb0 <vInitialTask+0x130>
			printErrorTask( error_code );
81112ca0:	e0bffe03 	ldbu	r2,-8(fp)
81112ca4:	10803fcc 	andi	r2,r2,255
81112ca8:	1009883a 	mov	r4,r2
81112cac:	111c46c0 	call	8111c46c <printErrorTask>
		}
		#endif
			vCoudlNotCreateDataControllerTask();
81112cb0:	111e1a80 	call	8111e1a8 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112cb4:	01c17704 	movi	r7,1500
81112cb8:	000d883a 	mov	r6,zero
81112cbc:	000b883a 	mov	r5,zero
81112cc0:	0009883a 	mov	r4,zero
81112cc4:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
81112cc8:	d8000415 	stw	zero,16(sp)
81112ccc:	d8000315 	stw	zero,12(sp)
81112cd0:	00810004 	movi	r2,1024
81112cd4:	d8800215 	stw	r2,8(sp)
81112cd8:	00a045b4 	movhi	r2,33046
81112cdc:	10810804 	addi	r2,r2,1056
81112ce0:	d8800115 	stw	r2,4(sp)
81112ce4:	00800244 	movi	r2,9
81112ce8:	d8800015 	stw	r2,0(sp)
81112cec:	01c00244 	movi	r7,9
81112cf0:	01a045b4 	movhi	r6,33046
81112cf4:	31850704 	addi	r6,r6,5148
81112cf8:	016045b4 	movhi	r5,33046
81112cfc:	2968e404 	addi	r5,r5,-23664
81112d00:	01204474 	movhi	r4,33041
81112d04:	210c8304 	addi	r4,r4,12812
81112d08:	1140b380 	call	81140b38 <OSTaskCreateExt>
81112d0c:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112d10:	e0bffe03 	ldbu	r2,-8(fp)
81112d14:	10803fcc 	andi	r2,r2,255
81112d18:	10000b26 	beq	r2,zero,81112d48 <vInitialTask+0x1c8>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112d1c:	00a045b4 	movhi	r2,33046
81112d20:	109fe204 	addi	r2,r2,32648
81112d24:	10800d8b 	ldhu	r2,54(r2)
81112d28:	10bfffcc 	andi	r2,r2,65535
81112d2c:	10800228 	cmpgeui	r2,r2,8
81112d30:	1000041e 	bne	r2,zero,81112d44 <vInitialTask+0x1c4>
			printErrorTask( error_code );
81112d34:	e0bffe03 	ldbu	r2,-8(fp)
81112d38:	10803fcc 	andi	r2,r2,255
81112d3c:	1009883a 	mov	r4,r2
81112d40:	111c46c0 	call	8111c46c <printErrorTask>
		}
		#endif
			vCoudlNotCreateNFeeControllerTask();
81112d44:	111e1280 	call	8111e128 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112d48:	01c17704 	movi	r7,1500
81112d4c:	000d883a 	mov	r6,zero
81112d50:	000b883a 	mov	r5,zero
81112d54:	0009883a 	mov	r4,zero
81112d58:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
81112d5c:	d8000415 	stw	zero,16(sp)
81112d60:	d8000315 	stw	zero,12(sp)
81112d64:	00810004 	movi	r2,1024
81112d68:	d8800215 	stw	r2,8(sp)
81112d6c:	00a045b4 	movhi	r2,33046
81112d70:	10932a04 	addi	r2,r2,19624
81112d74:	d8800115 	stw	r2,4(sp)
81112d78:	00800204 	movi	r2,8
81112d7c:	d8800015 	stw	r2,0(sp)
81112d80:	01c00204 	movi	r7,8
81112d84:	01a045b4 	movhi	r6,33046
81112d88:	31972904 	addi	r6,r6,23716
81112d8c:	016045b4 	movhi	r5,33046
81112d90:	2968d204 	addi	r5,r5,-23736
81112d94:	01204474 	movhi	r4,33041
81112d98:	21170f04 	addi	r4,r4,23612
81112d9c:	1140b380 	call	81140b38 <OSTaskCreateExt>
81112da0:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112da4:	e0bffe03 	ldbu	r2,-8(fp)
81112da8:	10803fcc 	andi	r2,r2,255
81112dac:	10000b26 	beq	r2,zero,81112ddc <vInitialTask+0x25c>
		/* Can't create Task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112db0:	00a045b4 	movhi	r2,33046
81112db4:	109fe204 	addi	r2,r2,32648
81112db8:	10800d8b 	ldhu	r2,54(r2)
81112dbc:	10bfffcc 	andi	r2,r2,65535
81112dc0:	10800228 	cmpgeui	r2,r2,8
81112dc4:	1000041e 	bne	r2,zero,81112dd8 <vInitialTask+0x258>
			printErrorTask( error_code );
81112dc8:	e0bffe03 	ldbu	r2,-8(fp)
81112dcc:	10803fcc 	andi	r2,r2,255
81112dd0:	1009883a 	mov	r4,r2
81112dd4:	111c46c0 	call	8111c46c <printErrorTask>
		}
		#endif
			vCoudlNotCreateMebTask();
81112dd8:	111e2280 	call	8111e228 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112ddc:	01c17704 	movi	r7,1500
81112de0:	000d883a 	mov	r6,zero
81112de4:	000b883a 	mov	r5,zero
81112de8:	0009883a 	mov	r4,zero
81112dec:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
81112df0:	d8000415 	stw	zero,16(sp)
81112df4:	d8000315 	stw	zero,12(sp)
81112df8:	00810004 	movi	r2,1024
81112dfc:	d8800215 	stw	r2,8(sp)
81112e00:	00a045b4 	movhi	r2,33046
81112e04:	10a0d204 	addi	r2,r2,-31928
81112e08:	d8800115 	stw	r2,4(sp)
81112e0c:	00800784 	movi	r2,30
81112e10:	d8800015 	stw	r2,0(sp)
81112e14:	01c00784 	movi	r7,30
81112e18:	01a045b4 	movhi	r6,33046
81112e1c:	31a4d104 	addi	r6,r6,-27836
81112e20:	000b883a 	mov	r5,zero
81112e24:	01204474 	movhi	r4,33041
81112e28:	211e9204 	addi	r4,r4,31304
81112e2c:	1140b380 	call	81140b38 <OSTaskCreateExt>
81112e30:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112e34:	e0bffe03 	ldbu	r2,-8(fp)
81112e38:	10803fcc 	andi	r2,r2,255
81112e3c:	10000b26 	beq	r2,zero,81112e6c <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112e40:	00a045b4 	movhi	r2,33046
81112e44:	109fe204 	addi	r2,r2,32648
81112e48:	10800d8b 	ldhu	r2,54(r2)
81112e4c:	10bfffcc 	andi	r2,r2,65535
81112e50:	10800228 	cmpgeui	r2,r2,8
81112e54:	1000041e 	bne	r2,zero,81112e68 <vInitialTask+0x2e8>
			printErrorTask( error_code );
81112e58:	e0bffe03 	ldbu	r2,-8(fp)
81112e5c:	10803fcc 	andi	r2,r2,255
81112e60:	1009883a 	mov	r4,r2
81112e64:	111c46c0 	call	8111c46c <printErrorTask>
		}
		#endif
		vFailTimeoutCheckerTaskCreate();
81112e68:	111d6140 	call	8111d614 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112e6c:	01c03204 	movi	r7,200
81112e70:	000d883a 	mov	r6,zero
81112e74:	000b883a 	mov	r5,zero
81112e78:	0009883a 	mov	r4,zero
81112e7c:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
81112e80:	d8000415 	stw	zero,16(sp)
81112e84:	d8000315 	stw	zero,12(sp)
81112e88:	00810004 	movi	r2,1024
81112e8c:	d8800215 	stw	r2,8(sp)
81112e90:	00a045b4 	movhi	r2,33046
81112e94:	10b3e804 	addi	r2,r2,-12384
81112e98:	d8800115 	stw	r2,4(sp)
81112e9c:	008006c4 	movi	r2,27
81112ea0:	d8800015 	stw	r2,0(sp)
81112ea4:	01c006c4 	movi	r7,27
81112ea8:	01a045b4 	movhi	r6,33046
81112eac:	31b7e704 	addi	r6,r6,-8292
81112eb0:	000b883a 	mov	r5,zero
81112eb4:	01204474 	movhi	r4,33041
81112eb8:	210e9604 	addi	r4,r4,14936
81112ebc:	1140b380 	call	81140b38 <OSTaskCreateExt>
81112ec0:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112ec4:	e0bffe03 	ldbu	r2,-8(fp)
81112ec8:	10803fcc 	andi	r2,r2,255
81112ecc:	10000b26 	beq	r2,zero,81112efc <vInitialTask+0x37c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112ed0:	00a045b4 	movhi	r2,33046
81112ed4:	109fe204 	addi	r2,r2,32648
81112ed8:	10800d8b 	ldhu	r2,54(r2)
81112edc:	10bfffcc 	andi	r2,r2,65535
81112ee0:	10800228 	cmpgeui	r2,r2,8
81112ee4:	1000041e 	bne	r2,zero,81112ef8 <vInitialTask+0x378>
			printErrorTask( error_code );
81112ee8:	e0bffe03 	ldbu	r2,-8(fp)
81112eec:	10803fcc 	andi	r2,r2,255
81112ef0:	1009883a 	mov	r4,r2
81112ef4:	111c46c0 	call	8111c46c <printErrorTask>
		}
		#endif
		vFailOutAckHandlerTaskCreate();
81112ef8:	111d4e80 	call	8111d4e8 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112efc:	01c03204 	movi	r7,200
81112f00:	000d883a 	mov	r6,zero
81112f04:	000b883a 	mov	r5,zero
81112f08:	0009883a 	mov	r4,zero
81112f0c:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
81112f10:	d8000415 	stw	zero,16(sp)
81112f14:	d8000315 	stw	zero,12(sp)
81112f18:	00810004 	movi	r2,1024
81112f1c:	d8800215 	stw	r2,8(sp)
81112f20:	00a04574 	movhi	r2,33045
81112f24:	1097c404 	addi	r2,r2,24336
81112f28:	d8800115 	stw	r2,4(sp)
81112f2c:	00800644 	movi	r2,25
81112f30:	d8800015 	stw	r2,0(sp)
81112f34:	01c00644 	movi	r7,25
81112f38:	01a04574 	movhi	r6,33045
81112f3c:	319bc304 	addi	r6,r6,28428
81112f40:	000b883a 	mov	r5,zero
81112f44:	01204474 	movhi	r4,33041
81112f48:	21090804 	addi	r4,r4,9248
81112f4c:	1140b380 	call	81140b38 <OSTaskCreateExt>
81112f50:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112f54:	e0bffe03 	ldbu	r2,-8(fp)
81112f58:	10803fcc 	andi	r2,r2,255
81112f5c:	10000b26 	beq	r2,zero,81112f8c <vInitialTask+0x40c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112f60:	00a045b4 	movhi	r2,33046
81112f64:	109fe204 	addi	r2,r2,32648
81112f68:	10800d8b 	ldhu	r2,54(r2)
81112f6c:	10bfffcc 	andi	r2,r2,65535
81112f70:	10800228 	cmpgeui	r2,r2,8
81112f74:	1000041e 	bne	r2,zero,81112f88 <vInitialTask+0x408>
			printErrorTask( error_code );
81112f78:	e0bffe03 	ldbu	r2,-8(fp)
81112f7c:	10803fcc 	andi	r2,r2,255
81112f80:	1009883a 	mov	r4,r2
81112f84:	111c46c0 	call	8111c46c <printErrorTask>
		}
		#endif
		vFailInAckHandlerTaskCreate();
81112f88:	111d4840 	call	8111d484 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112f8c:	01c03204 	movi	r7,200
81112f90:	000d883a 	mov	r6,zero
81112f94:	000b883a 	mov	r5,zero
81112f98:	0009883a 	mov	r4,zero
81112f9c:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
81112fa0:	d8000415 	stw	zero,16(sp)
81112fa4:	d8000315 	stw	zero,12(sp)
81112fa8:	00818004 	movi	r2,1536
81112fac:	d8800215 	stw	r2,8(sp)
81112fb0:	00a045b4 	movhi	r2,33046
81112fb4:	108d2604 	addi	r2,r2,13464
81112fb8:	d8800115 	stw	r2,4(sp)
81112fbc:	00800704 	movi	r2,28
81112fc0:	d8800015 	stw	r2,0(sp)
81112fc4:	01c00704 	movi	r7,28
81112fc8:	01a045b4 	movhi	r6,33046
81112fcc:	31932504 	addi	r6,r6,19604
81112fd0:	000b883a 	mov	r5,zero
81112fd4:	01204474 	movhi	r4,33041
81112fd8:	210f6004 	addi	r4,r4,15744
81112fdc:	1140b380 	call	81140b38 <OSTaskCreateExt>
81112fe0:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112fe4:	e0bffe03 	ldbu	r2,-8(fp)
81112fe8:	10803fcc 	andi	r2,r2,255
81112fec:	10000b26 	beq	r2,zero,8111301c <vInitialTask+0x49c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81112ff0:	00a045b4 	movhi	r2,33046
81112ff4:	109fe204 	addi	r2,r2,32648
81112ff8:	10800d8b 	ldhu	r2,54(r2)
81112ffc:	10bfffcc 	andi	r2,r2,65535
81113000:	10800228 	cmpgeui	r2,r2,8
81113004:	1000041e 	bne	r2,zero,81113018 <vInitialTask+0x498>
			printErrorTask( error_code );
81113008:	e0bffe03 	ldbu	r2,-8(fp)
8111300c:	10803fcc 	andi	r2,r2,255
81113010:	1009883a 	mov	r4,r2
81113014:	111c46c0 	call	8111c46c <printErrorTask>
		}
		#endif
		vFailParserCommTaskCreate();
81113018:	111d4200 	call	8111d420 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8111301c:	01c03204 	movi	r7,200
81113020:	000d883a 	mov	r6,zero
81113024:	000b883a 	mov	r5,zero
81113028:	0009883a 	mov	r4,zero
8111302c:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
81113030:	d8000415 	stw	zero,16(sp)
81113034:	d8000315 	stw	zero,12(sp)
81113038:	00818004 	movi	r2,1536
8111303c:	d8800215 	stw	r2,8(sp)
81113040:	00a045b4 	movhi	r2,33046
81113044:	10add804 	addi	r2,r2,-18592
81113048:	d8800115 	stw	r2,4(sp)
8111304c:	00800804 	movi	r2,32
81113050:	d8800015 	stw	r2,0(sp)
81113054:	01c00804 	movi	r7,32
81113058:	01a045b4 	movhi	r6,33046
8111305c:	31b3d704 	addi	r6,r6,-12452
81113060:	000b883a 	mov	r5,zero
81113064:	01204474 	movhi	r4,33041
81113068:	2113f004 	addi	r4,r4,20416
8111306c:	1140b380 	call	81140b38 <OSTaskCreateExt>
81113070:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81113074:	e0bffe03 	ldbu	r2,-8(fp)
81113078:	10803fcc 	andi	r2,r2,255
8111307c:	10000b26 	beq	r2,zero,811130ac <vInitialTask+0x52c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113080:	00a045b4 	movhi	r2,33046
81113084:	109fe204 	addi	r2,r2,32648
81113088:	10800d8b 	ldhu	r2,54(r2)
8111308c:	10bfffcc 	andi	r2,r2,65535
81113090:	10800228 	cmpgeui	r2,r2,8
81113094:	1000041e 	bne	r2,zero,811130a8 <vInitialTask+0x528>
			printErrorTask( error_code );
81113098:	e0bffe03 	ldbu	r2,-8(fp)
8111309c:	10803fcc 	andi	r2,r2,255
811130a0:	1009883a 	mov	r4,r2
811130a4:	111c46c0 	call	8111c46c <printErrorTask>
		}
		#endif
		vFailReceiverCreate();
811130a8:	111cb740 	call	8111cb74 <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
811130ac:	01c03204 	movi	r7,200
811130b0:	000d883a 	mov	r6,zero
811130b4:	000b883a 	mov	r5,zero
811130b8:	0009883a 	mov	r4,zero
811130bc:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
811130c0:	d8000415 	stw	zero,16(sp)
811130c4:	d8000315 	stw	zero,12(sp)
811130c8:	00810004 	movi	r2,1024
811130cc:	d8800215 	stw	r2,8(sp)
811130d0:	00a04574 	movhi	r2,33045
811130d4:	109cc004 	addi	r2,r2,29440
811130d8:	d8800115 	stw	r2,4(sp)
811130dc:	00800684 	movi	r2,26
811130e0:	d8800015 	stw	r2,0(sp)
811130e4:	01c00684 	movi	r7,26
811130e8:	01a045b4 	movhi	r6,33046
811130ec:	31a0bf04 	addi	r6,r6,-32004
811130f0:	000b883a 	mov	r5,zero
811130f4:	01204474 	movhi	r4,33041
811130f8:	21168b04 	addi	r4,r4,23084
811130fc:	1140b380 	call	81140b38 <OSTaskCreateExt>
81113100:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
81113104:	01c03204 	movi	r7,200
81113108:	000d883a 	mov	r6,zero
8111310c:	000b883a 	mov	r5,zero
81113110:	0009883a 	mov	r4,zero
81113114:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
81113118:	e0bffe03 	ldbu	r2,-8(fp)
8111311c:	10803fcc 	andi	r2,r2,255
81113120:	10000b26 	beq	r2,zero,81113150 <vInitialTask+0x5d0>
		/* Can't create Task for sender comm packets */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113124:	00a045b4 	movhi	r2,33046
81113128:	109fe204 	addi	r2,r2,32648
8111312c:	10800d8b 	ldhu	r2,54(r2)
81113130:	10bfffcc 	andi	r2,r2,65535
81113134:	10800228 	cmpgeui	r2,r2,8
81113138:	1000041e 	bne	r2,zero,8111314c <vInitialTask+0x5cc>
			printErrorTask( error_code );
8111313c:	e0bffe03 	ldbu	r2,-8(fp)
81113140:	10803fcc 	andi	r2,r2,255
81113144:	1009883a 	mov	r4,r2
81113148:	111c46c0 	call	8111c46c <printErrorTask>
		}
		#endif
		vFailSenderCreate();
8111314c:	111cbd80 	call	8111cbd8 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
81113150:	d0a06d17 	ldw	r2,-32332(gp)
81113154:	e17ffe04 	addi	r5,fp,-8
81113158:	1009883a 	mov	r4,r2
8111315c:	11428580 	call	81142858 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
81113160:	e0bffe03 	ldbu	r2,-8(fp)
81113164:	10803fcc 	andi	r2,r2,255
81113168:	10000126 	beq	r2,zero,81113170 <vInitialTask+0x5f0>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
8111316c:	111d9780 	call	8111d978 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
81113170:	01c00084 	movi	r7,2
81113174:	01800784 	movi	r6,30
81113178:	000b883a 	mov	r5,zero
8111317c:	0009883a 	mov	r4,zero
81113180:	1141d640 	call	81141d64 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
81113184:	01003fc4 	movi	r4,255
81113188:	1140d240 	call	81140d24 <OSTaskDel>
8111318c:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
81113190:	e0bffe03 	ldbu	r2,-8(fp)
81113194:	10803fcc 	andi	r2,r2,255
81113198:	10001626 	beq	r2,zero,811131f4 <vInitialTask+0x674>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111319c:	00a045b4 	movhi	r2,33046
811131a0:	109fe204 	addi	r2,r2,32648
811131a4:	10800d8b 	ldhu	r2,54(r2)
811131a8:	10bfffcc 	andi	r2,r2,65535
811131ac:	10800228 	cmpgeui	r2,r2,8
811131b0:	1000041e 	bne	r2,zero,811131c4 <vInitialTask+0x644>
			printErrorTask( error_code );		
811131b4:	e0bffe03 	ldbu	r2,-8(fp)
811131b8:	10803fcc 	andi	r2,r2,255
811131bc:	1009883a 	mov	r4,r2
811131c0:	111c46c0 	call	8111c46c <printErrorTask>
		}
		#endif
		vFailDeleteInitialization();
811131c4:	111cc3c0 	call	8111cc3c <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
811131c8:	014009c4 	movi	r5,39
811131cc:	01000044 	movi	r4,1
811131d0:	114048c0 	call	8114048c <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
811131d4:	01003fc4 	movi	r4,255
811131d8:	1140d240 	call	81140d24 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
811131dc:	000f883a 	mov	r7,zero
811131e0:	01800284 	movi	r6,10
811131e4:	000b883a 	mov	r5,zero
811131e8:	0009883a 	mov	r4,zero
811131ec:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
		}
811131f0:	003ff806 	br	811131d4 <__reset+0xfb0f31d4>
	}

}
811131f4:	0001883a 	nop
811131f8:	e037883a 	mov	sp,fp
811131fc:	dfc00117 	ldw	ra,4(sp)
81113200:	df000017 	ldw	fp,0(sp)
81113204:	dec00204 	addi	sp,sp,8
81113208:	f800283a 	ret

8111320c <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
8111320c:	defff704 	addi	sp,sp,-36
81113210:	de00012e 	bgeu	sp,et,81113218 <vNFeeControlTask+0xc>
81113214:	003b68fa 	trap	3
81113218:	dfc00815 	stw	ra,32(sp)
8111321c:	df000715 	stw	fp,28(sp)
81113220:	df000704 	addi	fp,sp,28
81113224:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	static unsigned char ucWhoGetDMA;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
81113228:	e0bfff17 	ldw	r2,-4(fp)
8111322c:	e0bffa15 	stw	r2,-24(fp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81113230:	00a045b4 	movhi	r2,33046
81113234:	109fe204 	addi	r2,r2,32648
81113238:	10800d8b 	ldhu	r2,54(r2)
8111323c:	10bfffcc 	andi	r2,r2,65535
81113240:	10800168 	cmpgeui	r2,r2,5
81113244:	1000071e 	bne	r2,zero,81113264 <vNFeeControlTask+0x58>
        debug(fp,"NFee Controller Task. (Task on)\n");
81113248:	d0a06217 	ldw	r2,-32376(gp)
8111324c:	100f883a 	mov	r7,r2
81113250:	01800804 	movi	r6,32
81113254:	01400044 	movi	r5,1
81113258:	01204574 	movhi	r4,33045
8111325c:	213a6c04 	addi	r4,r4,-5712
81113260:	1122fc80 	call	81122fc8 <fwrite>
	}
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
81113264:	e0bffa17 	ldw	r2,-24(fp)
81113268:	10809a17 	ldw	r2,616(r2)
8111326c:	10c00168 	cmpgeui	r3,r2,5
81113270:	1800e71e 	bne	r3,zero,81113610 <vNFeeControlTask+0x404>
81113274:	100690ba 	slli	r3,r2,2
81113278:	00a04474 	movhi	r2,33041
8111327c:	108ca304 	addi	r2,r2,12940
81113280:	1885883a 	add	r2,r3,r2
81113284:	10800017 	ldw	r2,0(r2)
81113288:	1000683a 	jmp	r2
8111328c:	811132a0 	cmpeqi	r4,r16,17610
81113290:	811132d0 	cmplti	r4,r16,17611
81113294:	81113348 	cmpgei	r4,r16,17613
81113298:	81113414 	ori	r4,r16,17616
8111329c:	81113474 	orhi	r4,r16,17617
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
811132a0:	d0a07017 	ldw	r2,-32320(gp)
811132a4:	1009883a 	mov	r4,r2
811132a8:	113ee140 	call	8113ee14 <OSQFlush>
811132ac:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
811132b0:	e0bffe03 	ldbu	r2,-8(fp)
811132b4:	10803fcc 	andi	r2,r2,255
811132b8:	10000126 	beq	r2,zero,811132c0 <vNFeeControlTask+0xb4>
					vFailFlushQueue();
811132bc:	111ea1c0 	call	8111ea1c <vFailFlushQueue>
				}

				pxFeeC->sMode = sMebToConfig;
811132c0:	e0bffa17 	ldw	r2,-24(fp)
811132c4:	00c00044 	movi	r3,1
811132c8:	10c09a15 	stw	r3,616(r2)
				break;
811132cc:	0000e206 	br	81113658 <vNFeeControlTask+0x44c>


			case sMebToConfig:
				/* Transition state */
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811132d0:	00a045b4 	movhi	r2,33046
811132d4:	109fe204 	addi	r2,r2,32648
811132d8:	10800d8b 	ldhu	r2,54(r2)
811132dc:	10bfffcc 	andi	r2,r2,65535
811132e0:	108000e8 	cmpgeui	r2,r2,3
811132e4:	1000071e 	bne	r2,zero,81113304 <vNFeeControlTask+0xf8>
					debug(fp,"NFEE Controller Task: Config Mode\n");
811132e8:	d0a06217 	ldw	r2,-32376(gp)
811132ec:	100f883a 	mov	r7,r2
811132f0:	01800884 	movi	r6,34
811132f4:	01400044 	movi	r5,1
811132f8:	01204574 	movhi	r4,33045
811132fc:	213a7504 	addi	r4,r4,-5676
81113300:	1122fc80 	call	81122fc8 <fwrite>
				}
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81113304:	d0a05d17 	ldw	r2,-32396(gp)
81113308:	1009883a 	mov	r4,r2
8111330c:	113ee140 	call	8113ee14 <OSQFlush>
81113310:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81113314:	e0bffe03 	ldbu	r2,-8(fp)
81113318:	10803fcc 	andi	r2,r2,255
8111331c:	10000126 	beq	r2,zero,81113324 <vNFeeControlTask+0x118>
					vFailFlushQueue();
81113320:	111ea1c0 	call	8111ea1c <vFailFlushQueue>
				}

				bCmdSent = FALSE;
81113324:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
81113328:	00800044 	movi	r2,1
8111332c:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
81113330:	00bfffc4 	movi	r2,-1
81113334:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebConfig;
81113338:	e0bffa17 	ldw	r2,-24(fp)
8111333c:	00c000c4 	movi	r3,3
81113340:	10c09a15 	stw	r3,616(r2)
				break;
81113344:	0000c406 	br	81113658 <vNFeeControlTask+0x44c>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
81113348:	111ebd40 	call	8111ebd4 <vEvtChangeFeeControllerMode>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111334c:	00a045b4 	movhi	r2,33046
81113350:	109fe204 	addi	r2,r2,32648
81113354:	10800d8b 	ldhu	r2,54(r2)
81113358:	10bfffcc 	andi	r2,r2,65535
8111335c:	108000e8 	cmpgeui	r2,r2,3
81113360:	1000071e 	bne	r2,zero,81113380 <vNFeeControlTask+0x174>
					debug(fp,"NFEE Controller Task: RUN Mode\n");
81113364:	d0a06217 	ldw	r2,-32376(gp)
81113368:	100f883a 	mov	r7,r2
8111336c:	018007c4 	movi	r6,31
81113370:	01400044 	movi	r5,1
81113374:	01204574 	movhi	r4,33045
81113378:	213a7e04 	addi	r4,r4,-5640
8111337c:	1122fc80 	call	81122fc8 <fwrite>
				}
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81113380:	d0a05d17 	ldw	r2,-32396(gp)
81113384:	1009883a 	mov	r4,r2
81113388:	113ee140 	call	8113ee14 <OSQFlush>
8111338c:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81113390:	e0bffe03 	ldbu	r2,-8(fp)
81113394:	10803fcc 	andi	r2,r2,255
81113398:	10000126 	beq	r2,zero,811133a0 <vNFeeControlTask+0x194>
					vFailFlushQueue();
8111339c:	111ea1c0 	call	8111ea1c <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
811133a0:	e03ff905 	stb	zero,-28(fp)
811133a4:	00001006 	br	811133e8 <vNFeeControlTask+0x1dc>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
811133a8:	e0bff903 	ldbu	r2,-28(fp)
811133ac:	1085883a 	add	r2,r2,r2
811133b0:	1087883a 	add	r3,r2,r2
811133b4:	d0a06a04 	addi	r2,gp,-32344
811133b8:	1885883a 	add	r2,r3,r2
811133bc:	10800017 	ldw	r2,0(r2)
811133c0:	1009883a 	mov	r4,r2
811133c4:	113ee140 	call	8113ee14 <OSQFlush>
811133c8:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
811133cc:	e0bffe03 	ldbu	r2,-8(fp)
811133d0:	10803fcc 	andi	r2,r2,255
811133d4:	10000126 	beq	r2,zero,811133dc <vNFeeControlTask+0x1d0>
						vFailFlushQueue();
811133d8:	111ea1c0 	call	8111ea1c <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
811133dc:	e0bff903 	ldbu	r2,-28(fp)
811133e0:	10800044 	addi	r2,r2,1
811133e4:	e0bff905 	stb	r2,-28(fp)
811133e8:	e0bff903 	ldbu	r2,-28(fp)
811133ec:	103fee26 	beq	r2,zero,811133a8 <__reset+0xfb0f33a8>
					if ( error_codeCtrl != OS_NO_ERR ) {
						vFailFlushQueue();
					}
				}

				bCmdSent = FALSE;
811133f0:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
811133f4:	00800044 	movi	r2,1
811133f8:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
811133fc:	00bfffc4 	movi	r2,-1
81113400:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebRun;
81113404:	e0bffa17 	ldw	r2,-24(fp)
81113408:	00c00104 	movi	r3,4
8111340c:	10c09a15 	stw	r3,616(r2)
				break;
81113410:	00009106 	br	81113658 <vNFeeControlTask+0x44c>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
81113414:	d0a07017 	ldw	r2,-32320(gp)
81113418:	e0fffe04 	addi	r3,fp,-8
8111341c:	180d883a 	mov	r6,r3
81113420:	000b883a 	mov	r5,zero
81113424:	1009883a 	mov	r4,r2
81113428:	113eed40 	call	8113eed4 <OSQPend>
8111342c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
81113430:	e0bffe03 	ldbu	r2,-8(fp)
81113434:	10803fcc 	andi	r2,r2,255
81113438:	10000c1e 	bne	r2,zero,8111346c <vNFeeControlTask+0x260>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8111343c:	e0bffdc3 	ldbu	r2,-9(fp)
81113440:	10803fcc 	andi	r2,r2,255
81113444:	10800418 	cmpnei	r2,r2,16
81113448:	1000041e 	bne	r2,zero,8111345c <vNFeeControlTask+0x250>
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
8111344c:	e0bffd17 	ldw	r2,-12(fp)
81113450:	e17ffa17 	ldw	r5,-24(fp)
81113454:	1009883a 	mov	r4,r2
81113458:	111365c0 	call	8111365c <vPerformActionNFCConfig>
					}
					bCmdSent = FALSE;
8111345c:	e03ffb15 	stw	zero,-20(fp)
					bDmaBack = TRUE;
81113460:	00800044 	movi	r2,1
81113464:	d0a05815 	stw	r2,-32416(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
81113468:	00007b06 	br	81113658 <vNFeeControlTask+0x44c>
					}
					bCmdSent = FALSE;
					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
8111346c:	111e5680 	call	8111e568 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
81113470:	00007906 	br	81113658 <vNFeeControlTask+0x44c>
				/* 	We have 2 importantes Queues here.  
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fast way and
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				
				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
81113474:	d0a05817 	ldw	r2,-32416(gp)
81113478:	10800058 	cmpnei	r2,r2,1
8111347c:	1000221e 	bne	r2,zero,81113508 <vNFeeControlTask+0x2fc>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
81113480:	d0a05d17 	ldw	r2,-32396(gp)
81113484:	e0fffe04 	addi	r3,fp,-8
81113488:	180d883a 	mov	r6,r3
8111348c:	01400104 	movi	r5,4
81113490:	1009883a 	mov	r4,r2
81113494:	113eed40 	call	8113eed4 <OSQPend>
81113498:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
8111349c:	e0bffe03 	ldbu	r2,-8(fp)
811134a0:	10803fcc 	andi	r2,r2,255
811134a4:	1000181e 	bne	r2,zero,81113508 <vNFeeControlTask+0x2fc>
						ucFeeInstL = uiCmdNFC.ucByte[0];
811134a8:	e0bffd03 	ldbu	r2,-12(fp)
811134ac:	e0bffc05 	stb	r2,-16(fp)

						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
811134b0:	e0bffc03 	ldbu	r2,-16(fp)
811134b4:	e0fffa17 	ldw	r3,-24(fp)
811134b8:	10809624 	muli	r2,r2,600
811134bc:	1885883a 	add	r2,r3,r2
811134c0:	10802304 	addi	r2,r2,140
811134c4:	10800017 	ldw	r2,0(r2)
811134c8:	10800058 	cmpnei	r2,r2,1
811134cc:	10000e1e 	bne	r2,zero,81113508 <vNFeeControlTask+0x2fc>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
811134d0:	e0bffc03 	ldbu	r2,-16(fp)
811134d4:	e0fffc03 	ldbu	r3,-16(fp)
811134d8:	180f883a 	mov	r7,r3
811134dc:	000d883a 	mov	r6,zero
811134e0:	014023c4 	movi	r5,143
811134e4:	1009883a 	mov	r4,r2
811134e8:	11138c80 	call	811138c8 <bSendCmdQToNFeeInst>
811134ec:	e0bffb15 	stw	r2,-20(fp)
							if ( bCmdSent == TRUE ) {
811134f0:	e0bffb17 	ldw	r2,-20(fp)
811134f4:	10800058 	cmpnei	r2,r2,1
811134f8:	1000031e 	bne	r2,zero,81113508 <vNFeeControlTask+0x2fc>
								bDmaBack = FALSE;
811134fc:	d0205815 	stw	zero,-32416(gp)
								ucWhoGetDMA = ucFeeInstL;
81113500:	e0bffc03 	ldbu	r2,-16(fp)
81113504:	d0a05905 	stb	r2,-32412(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
81113508:	d0a05817 	ldw	r2,-32416(gp)
8111350c:	1000081e 	bne	r2,zero,81113530 <vNFeeControlTask+0x324>
					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
81113510:	d0a07017 	ldw	r2,-32320(gp)
81113514:	e0fffe04 	addi	r3,fp,-8
81113518:	180d883a 	mov	r6,r3
8111351c:	000b883a 	mov	r5,zero
81113520:	1009883a 	mov	r4,r2
81113524:	113eed40 	call	8113eed4 <OSQPend>
81113528:	e0bffd15 	stw	r2,-12(fp)
8111352c:	00000706 	br	8111354c <vNFeeControlTask+0x340>
				} else {
					/* If No FEE has the DMA */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
81113530:	d0a07017 	ldw	r2,-32320(gp)
81113534:	e0fffe04 	addi	r3,fp,-8
81113538:	180d883a 	mov	r6,r3
8111353c:	01400104 	movi	r5,4
81113540:	1009883a 	mov	r4,r2
81113544:	113eed40 	call	8113eed4 <OSQPend>
81113548:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
8111354c:	e0bffe03 	ldbu	r2,-8(fp)
81113550:	10803fcc 	andi	r2,r2,255
81113554:	10003f1e 	bne	r2,zero,81113654 <vNFeeControlTask+0x448>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
81113558:	e0bffd83 	ldbu	r2,-10(fp)
8111355c:	10803fcc 	andi	r2,r2,255
81113560:	10802058 	cmpnei	r2,r2,129
81113564:	10000a1e 	bne	r2,zero,81113590 <vNFeeControlTask+0x384>
						if ( uiCmdNFC.ucByte[0] == ucWhoGetDMA ){
81113568:	e0fffd03 	ldbu	r3,-12(fp)
8111356c:	d0a05903 	ldbu	r2,-32412(gp)
81113570:	18c03fcc 	andi	r3,r3,255
81113574:	10803fcc 	andi	r2,r2,255
81113578:	1880361e 	bne	r3,r2,81113654 <vNFeeControlTask+0x448>
							bDmaBack = TRUE;
8111357c:	00800044 	movi	r2,1
81113580:	d0a05815 	stw	r2,-32416(gp)
							ucFeeInstL = 255;
81113584:	00bfffc4 	movi	r2,-1
81113588:	e0bffc05 	stb	r2,-16(fp)
							}
						}
					}
				}
				
				break;		
8111358c:	00003106 	br	81113654 <vNFeeControlTask+0x448>
						}

					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81113590:	e0bffdc3 	ldbu	r2,-9(fp)
81113594:	10803fcc 	andi	r2,r2,255
81113598:	10800418 	cmpnei	r2,r2,16
8111359c:	1000051e 	bne	r2,zero,811135b4 <vNFeeControlTask+0x3a8>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
811135a0:	e0bffd17 	ldw	r2,-12(fp)
811135a4:	e17ffa17 	ldw	r5,-24(fp)
811135a8:	1009883a 	mov	r4,r2
811135ac:	11137600 	call	81113760 <vPerformActionNFCRunning>
							}
						}
					}
				}
				
				break;		
811135b0:	00002806 	br	81113654 <vNFeeControlTask+0x448>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
811135b4:	e0bffdc3 	ldbu	r2,-9(fp)
811135b8:	10803fcc 	andi	r2,r2,255
811135bc:	10800470 	cmpltui	r2,r2,17
811135c0:	1000241e 	bne	r2,zero,81113654 <vNFeeControlTask+0x448>
811135c4:	e0bffdc3 	ldbu	r2,-9(fp)
811135c8:	10803fcc 	andi	r2,r2,255
811135cc:	108004e8 	cmpgeui	r2,r2,19
811135d0:	1000201e 	bne	r2,zero,81113654 <vNFeeControlTask+0x448>
								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
811135d4:	e0bffdc3 	ldbu	r2,-9(fp)
811135d8:	10bffbc4 	addi	r2,r2,-17
811135dc:	10803fcc 	andi	r2,r2,255
811135e0:	e0fffd83 	ldbu	r3,-10(fp)
811135e4:	18c03fcc 	andi	r3,r3,255
811135e8:	e13ffd43 	ldbu	r4,-11(fp)
811135ec:	21003fcc 	andi	r4,r4,255
811135f0:	e17ffd03 	ldbu	r5,-12(fp)
811135f4:	29403fcc 	andi	r5,r5,255
811135f8:	280f883a 	mov	r7,r5
811135fc:	200d883a 	mov	r6,r4
81113600:	180b883a 	mov	r5,r3
81113604:	1009883a 	mov	r4,r2
81113608:	11138c80 	call	811138c8 <bSendCmdQToNFeeInst>
							}
						}
					}
				}
				
				break;		
8111360c:	00001106 	br	81113654 <vNFeeControlTask+0x448>
			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113610:	00a045b4 	movhi	r2,33046
81113614:	109fe204 	addi	r2,r2,32648
81113618:	10800d8b 	ldhu	r2,54(r2)
8111361c:	10bfffcc 	andi	r2,r2,65535
81113620:	10800228 	cmpgeui	r2,r2,8
81113624:	1000071e 	bne	r2,zero,81113644 <vNFeeControlTask+0x438>
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
81113628:	d0a06217 	ldw	r2,-32376(gp)
8111362c:	100f883a 	mov	r7,r2
81113630:	01800f44 	movi	r6,61
81113634:	01400044 	movi	r5,1
81113638:	01204574 	movhi	r4,33045
8111363c:	213a8604 	addi	r4,r4,-5608
81113640:	1122fc80 	call	81122fc8 <fwrite>
				}
				#endif
				
				pxFeeC->sMode = sMebConfig;
81113644:	e0bffa17 	ldw	r2,-24(fp)
81113648:	00c000c4 	movi	r3,3
8111364c:	10c09a15 	stw	r3,616(r2)
				break;
81113650:	00000106 	br	81113658 <vNFeeControlTask+0x44c>
							}
						}
					}
				}
				
				break;		
81113654:	0001883a 	nop
				#endif
				
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
81113658:	003f0206 	br	81113264 <__reset+0xfb0f3264>

8111365c <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8111365c:	defffb04 	addi	sp,sp,-20
81113660:	de00012e 	bgeu	sp,et,81113668 <vPerformActionNFCConfig+0xc>
81113664:	003b68fa 	trap	3
81113668:	dfc00415 	stw	ra,16(sp)
8111366c:	df000315 	stw	fp,12(sp)
81113670:	df000304 	addi	fp,sp,12
81113674:	e13ffe15 	stw	r4,-8(fp)
81113678:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;

	uiCmdLocal.ulWord = uiCmdParam;
8111367c:	e0bffe17 	ldw	r2,-8(fp)
81113680:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81113684:	e0bffd83 	ldbu	r2,-10(fp)
81113688:	10803fcc 	andi	r2,r2,255
8111368c:	10c000a0 	cmpeqi	r3,r2,2
81113690:	1800181e 	bne	r3,zero,811136f4 <vPerformActionNFCConfig+0x98>
81113694:	10c000c8 	cmpgei	r3,r2,3
81113698:	1800031e 	bne	r3,zero,811136a8 <vPerformActionNFCConfig+0x4c>
8111369c:	10800060 	cmpeqi	r2,r2,1
811136a0:	1000061e 	bne	r2,zero,811136bc <vPerformActionNFCConfig+0x60>
811136a4:	00001706 	br	81113704 <vPerformActionNFCConfig+0xa8>
811136a8:	10c02860 	cmpeqi	r3,r2,161
811136ac:	1800031e 	bne	r3,zero,811136bc <vPerformActionNFCConfig+0x60>
811136b0:	108028a0 	cmpeqi	r2,r2,162
811136b4:	10000f1e 	bne	r2,zero,811136f4 <vPerformActionNFCConfig+0x98>
811136b8:	00001206 	br	81113704 <vPerformActionNFCConfig+0xa8>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811136bc:	00a045b4 	movhi	r2,33046
811136c0:	109fe204 	addi	r2,r2,32648
811136c4:	10800d8b 	ldhu	r2,54(r2)
811136c8:	10bfffcc 	andi	r2,r2,65535
811136cc:	108000e8 	cmpgeui	r2,r2,3
811136d0:	10001a1e 	bne	r2,zero,8111373c <vPerformActionNFCConfig+0xe0>
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
811136d4:	d0a06217 	ldw	r2,-32376(gp)
811136d8:	100f883a 	mov	r7,r2
811136dc:	01800d44 	movi	r6,53
811136e0:	01400044 	movi	r5,1
811136e4:	01204574 	movhi	r4,33045
811136e8:	213a9604 	addi	r4,r4,-5544
811136ec:	1122fc80 	call	81122fc8 <fwrite>
			}
			#endif
			/* Do nothing for now */
			break;
811136f0:	00001206 	br	8111373c <vPerformActionNFCConfig+0xe0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
811136f4:	e0bfff17 	ldw	r2,-4(fp)
811136f8:	00c00084 	movi	r3,2
811136fc:	10c09a15 	stw	r3,616(r2)
			break;
81113700:	00001106 	br	81113748 <vPerformActionNFCConfig+0xec>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:

		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113704:	00a045b4 	movhi	r2,33046
81113708:	109fe204 	addi	r2,r2,32648
8111370c:	10800d8b 	ldhu	r2,54(r2)
81113710:	10bfffcc 	andi	r2,r2,65535
81113714:	10800228 	cmpgeui	r2,r2,8
81113718:	10000a1e 	bne	r2,zero,81113744 <vPerformActionNFCConfig+0xe8>
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
8111371c:	d0a06217 	ldw	r2,-32376(gp)
81113720:	100f883a 	mov	r7,r2
81113724:	018009c4 	movi	r6,39
81113728:	01400044 	movi	r5,1
8111372c:	01204574 	movhi	r4,33045
81113730:	213aa404 	addi	r4,r4,-5488
81113734:	1122fc80 	call	81122fc8 <fwrite>
			}
			#endif	
			break;
81113738:	00000206 	br	81113744 <vPerformActionNFCConfig+0xe8>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
			}
			#endif
			/* Do nothing for now */
			break;
8111373c:	0001883a 	nop
81113740:	00000106 	br	81113748 <vPerformActionNFCConfig+0xec>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
81113744:	0001883a 	nop
	}

}
81113748:	0001883a 	nop
8111374c:	e037883a 	mov	sp,fp
81113750:	dfc00117 	ldw	ra,4(sp)
81113754:	df000017 	ldw	fp,0(sp)
81113758:	dec00204 	addi	sp,sp,8
8111375c:	f800283a 	ret

81113760 <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81113760:	defffa04 	addi	sp,sp,-24
81113764:	de00012e 	bgeu	sp,et,8111376c <vPerformActionNFCRunning+0xc>
81113768:	003b68fa 	trap	3
8111376c:	dfc00515 	stw	ra,20(sp)
81113770:	df000415 	stw	fp,16(sp)
81113774:	df000404 	addi	fp,sp,16
81113778:	e13ffe15 	stw	r4,-8(fp)
8111377c:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
81113780:	e0bffe17 	ldw	r2,-8(fp)
81113784:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81113788:	e0bffd83 	ldbu	r2,-10(fp)
8111378c:	10803fcc 	andi	r2,r2,255
81113790:	10c02088 	cmpgei	r3,r2,130
81113794:	1800071e 	bne	r3,zero,811137b4 <vPerformActionNFCRunning+0x54>
81113798:	10c02008 	cmpgei	r3,r2,128
8111379c:	18003f1e 	bne	r3,zero,8111389c <vPerformActionNFCRunning+0x13c>
811137a0:	10c00060 	cmpeqi	r3,r2,1
811137a4:	1800051e 	bne	r3,zero,811137bc <vPerformActionNFCRunning+0x5c>
811137a8:	108000a0 	cmpeqi	r2,r2,2
811137ac:	10001f1e 	bne	r2,zero,8111382c <vPerformActionNFCRunning+0xcc>
811137b0:	00002c06 	br	81113864 <vPerformActionNFCRunning+0x104>
811137b4:	10802860 	cmpeqi	r2,r2,161
811137b8:	10002a26 	beq	r2,zero,81113864 <vPerformActionNFCRunning+0x104>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;
811137bc:	e0bfff17 	ldw	r2,-4(fp)
811137c0:	00c00044 	movi	r3,1
811137c4:	10c09a15 	stw	r3,616(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
811137c8:	e03ffc05 	stb	zero,-16(fp)
811137cc:	00001406 	br	81113820 <vPerformActionNFCRunning+0xc0>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
811137d0:	e0bffc03 	ldbu	r2,-16(fp)
811137d4:	e0ffff17 	ldw	r3,-4(fp)
811137d8:	108025c4 	addi	r2,r2,151
811137dc:	1085883a 	add	r2,r2,r2
811137e0:	1085883a 	add	r2,r2,r2
811137e4:	1885883a 	add	r2,r3,r2
811137e8:	10800017 	ldw	r2,0(r2)
811137ec:	10800017 	ldw	r2,0(r2)
811137f0:	10800058 	cmpnei	r2,r2,1
811137f4:	1000071e 	bne	r2,zero,81113814 <vPerformActionNFCRunning+0xb4>
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
811137f8:	e0bffc03 	ldbu	r2,-16(fp)
811137fc:	e0fffc03 	ldbu	r3,-16(fp)
81113800:	180f883a 	mov	r7,r3
81113804:	000d883a 	mov	r6,zero
81113808:	01402844 	movi	r5,161
8111380c:	1009883a 	mov	r4,r2
81113810:	11139900 	call	81113990 <bSendCmdQToNFeeInst_Prio>
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81113814:	e0bffc03 	ldbu	r2,-16(fp)
81113818:	10800044 	addi	r2,r2,1
8111381c:	e0bffc05 	stb	r2,-16(fp)
81113820:	e0bffc03 	ldbu	r2,-16(fp)
81113824:	103fea26 	beq	r2,zero,811137d0 <__reset+0xfb0f37d0>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
81113828:	00002106 	br	811138b0 <vPerformActionNFCRunning+0x150>
		case M_NFC_RUN:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111382c:	00a045b4 	movhi	r2,33046
81113830:	109fe204 	addi	r2,r2,32648
81113834:	10800d8b 	ldhu	r2,54(r2)
81113838:	10bfffcc 	andi	r2,r2,65535
8111383c:	108000e8 	cmpgeui	r2,r2,3
81113840:	1000181e 	bne	r2,zero,811138a4 <vPerformActionNFCRunning+0x144>
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
81113844:	d0a06217 	ldw	r2,-32376(gp)
81113848:	100f883a 	mov	r7,r2
8111384c:	01800d84 	movi	r6,54
81113850:	01400044 	movi	r5,1
81113854:	01204574 	movhi	r4,33045
81113858:	213aae04 	addi	r4,r4,-5448
8111385c:	1122fc80 	call	81122fc8 <fwrite>
			}
			#endif		
			/* Do nothing for now */

			break;
81113860:	00001006 	br	811138a4 <vPerformActionNFCRunning+0x144>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113864:	00a045b4 	movhi	r2,33046
81113868:	109fe204 	addi	r2,r2,32648
8111386c:	10800d8b 	ldhu	r2,54(r2)
81113870:	10bfffcc 	andi	r2,r2,65535
81113874:	10800228 	cmpgeui	r2,r2,8
81113878:	10000c1e 	bne	r2,zero,811138ac <vPerformActionNFCRunning+0x14c>
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
8111387c:	d0a06217 	ldw	r2,-32376(gp)
81113880:	100f883a 	mov	r7,r2
81113884:	018009c4 	movi	r6,39
81113888:	01400044 	movi	r5,1
8111388c:	01204574 	movhi	r4,33045
81113890:	213aa404 	addi	r4,r4,-5488
81113894:	1122fc80 	call	81122fc8 <fwrite>
			}
			#endif	
			break;
81113898:	00000406 	br	811138ac <vPerformActionNFCRunning+0x14c>
			/* Do nothing for now */

			break;
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
8111389c:	0001883a 	nop
811138a0:	00000306 	br	811138b0 <vPerformActionNFCRunning+0x150>
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
			}
			#endif		
			/* Do nothing for now */

			break;
811138a4:	0001883a 	nop
811138a8:	00000106 	br	811138b0 <vPerformActionNFCRunning+0x150>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
811138ac:	0001883a 	nop
	}
}
811138b0:	0001883a 	nop
811138b4:	e037883a 	mov	sp,fp
811138b8:	dfc00117 	ldw	ra,4(sp)
811138bc:	df000017 	ldw	fp,0(sp)
811138c0:	dec00204 	addi	sp,sp,8
811138c4:	f800283a 	ret

811138c8 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811138c8:	defff704 	addi	sp,sp,-36
811138cc:	de00012e 	bgeu	sp,et,811138d4 <bSendCmdQToNFeeInst+0xc>
811138d0:	003b68fa 	trap	3
811138d4:	dfc00815 	stw	ra,32(sp)
811138d8:	df000715 	stw	fp,28(sp)
811138dc:	df000704 	addi	fp,sp,28
811138e0:	2011883a 	mov	r8,r4
811138e4:	2809883a 	mov	r4,r5
811138e8:	3007883a 	mov	r3,r6
811138ec:	3805883a 	mov	r2,r7
811138f0:	e23ffc05 	stb	r8,-16(fp)
811138f4:	e13ffd05 	stb	r4,-12(fp)
811138f8:	e0fffe05 	stb	r3,-8(fp)
811138fc:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
81113900:	e0bffc03 	ldbu	r2,-16(fp)
81113904:	10800444 	addi	r2,r2,17
81113908:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111390c:	e0bffd03 	ldbu	r2,-12(fp)
81113910:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81113914:	e0bffe03 	ldbu	r2,-8(fp)
81113918:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111391c:	e0bfff03 	ldbu	r2,-4(fp)
81113920:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81113924:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81113928:	e0bffc03 	ldbu	r2,-16(fp)
8111392c:	1085883a 	add	r2,r2,r2
81113930:	1087883a 	add	r3,r2,r2
81113934:	d0a06a04 	addi	r2,gp,-32344
81113938:	1885883a 	add	r2,r3,r2
8111393c:	10800017 	ldw	r2,0(r2)
81113940:	e0fffb17 	ldw	r3,-20(fp)
81113944:	180b883a 	mov	r5,r3
81113948:	1009883a 	mov	r4,r2
8111394c:	113f2dc0 	call	8113f2dc <OSQPost>
81113950:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81113954:	e0bffa03 	ldbu	r2,-24(fp)
81113958:	10000526 	beq	r2,zero,81113970 <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
8111395c:	e0bffc03 	ldbu	r2,-16(fp)
81113960:	1009883a 	mov	r4,r2
81113964:	111e6680 	call	8111e668 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81113968:	e03ff915 	stw	zero,-28(fp)
8111396c:	00000206 	br	81113978 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
81113970:	00800044 	movi	r2,1
81113974:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81113978:	e0bff917 	ldw	r2,-28(fp)
}
8111397c:	e037883a 	mov	sp,fp
81113980:	dfc00117 	ldw	ra,4(sp)
81113984:	df000017 	ldw	fp,0(sp)
81113988:	dec00204 	addi	sp,sp,8
8111398c:	f800283a 	ret

81113990 <bSendCmdQToNFeeInst_Prio>:


bool bSendCmdQToNFeeInst_Prio( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81113990:	defff704 	addi	sp,sp,-36
81113994:	de00012e 	bgeu	sp,et,8111399c <bSendCmdQToNFeeInst_Prio+0xc>
81113998:	003b68fa 	trap	3
8111399c:	dfc00815 	stw	ra,32(sp)
811139a0:	df000715 	stw	fp,28(sp)
811139a4:	df000704 	addi	fp,sp,28
811139a8:	2011883a 	mov	r8,r4
811139ac:	2809883a 	mov	r4,r5
811139b0:	3007883a 	mov	r3,r6
811139b4:	3805883a 	mov	r2,r7
811139b8:	e23ffc05 	stb	r8,-16(fp)
811139bc:	e13ffd05 	stb	r4,-12(fp)
811139c0:	e0fffe05 	stb	r3,-8(fp)
811139c4:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
811139c8:	e0bffc03 	ldbu	r2,-16(fp)
811139cc:	10800444 	addi	r2,r2,17
811139d0:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811139d4:	e0bffd03 	ldbu	r2,-12(fp)
811139d8:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811139dc:	e0bffe03 	ldbu	r2,-8(fp)
811139e0:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811139e4:	e0bfff03 	ldbu	r2,-4(fp)
811139e8:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
811139ec:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPostFront(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
811139f0:	e0bffc03 	ldbu	r2,-16(fp)
811139f4:	1085883a 	add	r2,r2,r2
811139f8:	1087883a 	add	r3,r2,r2
811139fc:	d0a06a04 	addi	r2,gp,-32344
81113a00:	1885883a 	add	r2,r3,r2
81113a04:	10800017 	ldw	r2,0(r2)
81113a08:	e0fffb17 	ldw	r3,-20(fp)
81113a0c:	180b883a 	mov	r5,r3
81113a10:	1009883a 	mov	r4,r2
81113a14:	113f44c0 	call	8113f44c <OSQPostFront>
81113a18:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81113a1c:	e0bffa03 	ldbu	r2,-24(fp)
81113a20:	10000526 	beq	r2,zero,81113a38 <bSendCmdQToNFeeInst_Prio+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
81113a24:	e0bffc03 	ldbu	r2,-16(fp)
81113a28:	1009883a 	mov	r4,r2
81113a2c:	111e6680 	call	8111e668 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81113a30:	e03ff915 	stw	zero,-28(fp)
81113a34:	00000206 	br	81113a40 <bSendCmdQToNFeeInst_Prio+0xb0>
	} else {
		bSuccesL =  TRUE;
81113a38:	00800044 	movi	r2,1
81113a3c:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81113a40:	e0bff917 	ldw	r2,-28(fp)
}
81113a44:	e037883a 	mov	sp,fp
81113a48:	dfc00117 	ldw	ra,4(sp)
81113a4c:	df000017 	ldw	fp,0(sp)
81113a50:	dec00204 	addi	sp,sp,8
81113a54:	f800283a 	ret

81113a58 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
81113a58:	defff704 	addi	sp,sp,-36
81113a5c:	de00012e 	bgeu	sp,et,81113a64 <vOutAckHandlerTask+0xc>
81113a60:	003b68fa 	trap	3
81113a64:	dfc00815 	stw	ra,32(sp)
81113a68:	df000715 	stw	fp,28(sp)
81113a6c:	df000704 	addi	fp,sp,28
81113a70:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
81113a74:	e03ffac5 	stb	zero,-21(fp)
81113a78:	e03ffb05 	stb	zero,-20(fp)
81113a7c:	e03ffb45 	stb	zero,-19(fp)
81113a80:	e03ffb85 	stb	zero,-18(fp)
81113a84:	e03ffbc5 	stb	zero,-17(fp)
81113a88:	e03ffc05 	stb	zero,-16(fp)
81113a8c:	e03ffc45 	stb	zero,-15(fp)
81113a90:	e03ffc85 	stb	zero,-14(fp)
81113a94:	e03ffcc5 	stb	zero,-13(fp)
81113a98:	e03ffd05 	stb	zero,-12(fp)
81113a9c:	e03ffd45 	stb	zero,-11(fp)
81113aa0:	e03ffd85 	stb	zero,-10(fp)
81113aa4:	e03ffdc5 	stb	zero,-9(fp)
81113aa8:	e03ffe05 	stb	zero,-8(fp)
81113aac:	e03ffe45 	stb	zero,-7(fp)
81113ab0:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
81113ab4:	e03ffa45 	stb	zero,-23(fp)

	#if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81113ab8:	00a045b4 	movhi	r2,33046
81113abc:	109fe204 	addi	r2,r2,32648
81113ac0:	10800d8b 	ldhu	r2,54(r2)
81113ac4:	10bfffcc 	andi	r2,r2,65535
81113ac8:	10800168 	cmpgeui	r2,r2,5
81113acc:	1000071e 	bne	r2,zero,81113aec <vOutAckHandlerTask+0x94>
		debug(fp,"Out Ack Handler Task. (Task on)\n");
81113ad0:	d0a06217 	ldw	r2,-32376(gp)
81113ad4:	100f883a 	mov	r7,r2
81113ad8:	01800804 	movi	r6,32
81113adc:	01400044 	movi	r5,1
81113ae0:	01204574 	movhi	r4,33045
81113ae4:	213abc04 	addi	r4,r4,-5392
81113ae8:	1122fc80 	call	81122fc8 <fwrite>
    }
	#endif

	eSenderAckState = sSAConfiguring;
81113aec:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
81113af0:	e0bff917 	ldw	r2,-28(fp)
81113af4:	10c00060 	cmpeqi	r3,r2,1
81113af8:	1800071e 	bne	r3,zero,81113b18 <vOutAckHandlerTask+0xc0>
81113afc:	0080032e 	bgeu	zero,r2,81113b0c <vOutAckHandlerTask+0xb4>
81113b00:	108000a0 	cmpeqi	r2,r2,2
81113b04:	1000471e 	bne	r2,zero,81113c24 <vOutAckHandlerTask+0x1cc>
81113b08:	00008c06 	br	81113d3c <vOutAckHandlerTask+0x2e4>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
81113b0c:	00800044 	movi	r2,1
81113b10:	e0bff915 	stw	r2,-28(fp)
				break;
81113b14:	00009906 	br	81113d7c <vOutAckHandlerTask+0x324>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
81113b18:	00800044 	movi	r2,1
81113b1c:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
81113b20:	d0a06117 	ldw	r2,-32380(gp)
81113b24:	e0fffa84 	addi	r3,fp,-22
81113b28:	180d883a 	mov	r6,r3
81113b2c:	000b883a 	mov	r5,zero
81113b30:	1009883a 	mov	r4,r2
81113b34:	113fdcc0 	call	8113fdcc <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81113b38:	e0bffa83 	ldbu	r2,-22(fp)
81113b3c:	10803fcc 	andi	r2,r2,255
81113b40:	1000361e 	bne	r2,zero,81113c1c <vOutAckHandlerTask+0x1c4>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
81113b44:	d0a07217 	ldw	r2,-32312(gp)
81113b48:	e0fffa84 	addi	r3,fp,-22
81113b4c:	180d883a 	mov	r6,r3
81113b50:	000b883a 	mov	r5,zero
81113b54:	1009883a 	mov	r4,r2
81113b58:	113ddc00 	call	8113ddc0 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81113b5c:	e0bffa83 	ldbu	r2,-22(fp)
81113b60:	10803fcc 	andi	r2,r2,255
81113b64:	10002b1e 	bne	r2,zero,81113c14 <vOutAckHandlerTask+0x1bc>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81113b68:	e03ffa05 	stb	zero,-24(fp)
81113b6c:	00002206 	br	81113bf8 <vOutAckHandlerTask+0x1a0>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
81113b70:	e0fffa03 	ldbu	r3,-24(fp)
81113b74:	00a045b4 	movhi	r2,33046
81113b78:	109f3204 	addi	r2,r2,31944
81113b7c:	18c7883a 	add	r3,r3,r3
81113b80:	18c7883a 	add	r3,r3,r3
81113b84:	10c5883a 	add	r2,r2,r3
81113b88:	10800003 	ldbu	r2,0(r2)
81113b8c:	10803fcc 	andi	r2,r2,255
81113b90:	1080201c 	xori	r2,r2,128
81113b94:	10bfe004 	addi	r2,r2,-128
81113b98:	10001426 	beq	r2,zero,81113bec <vOutAckHandlerTask+0x194>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
81113b9c:	e0fffa03 	ldbu	r3,-24(fp)
81113ba0:	00a045b4 	movhi	r2,33046
81113ba4:	109f3204 	addi	r2,r2,31944
81113ba8:	18c7883a 	add	r3,r3,r3
81113bac:	18c7883a 	add	r3,r3,r3
81113bb0:	10c5883a 	add	r2,r2,r3
81113bb4:	10c0000b 	ldhu	r3,0(r2)
81113bb8:	d0e0598d 	sth	r3,-32410(gp)
81113bbc:	1080008b 	ldhu	r2,2(r2)
81113bc0:	d0a05a0d 	sth	r2,-32408(gp)
                                eSenderAckState = sSASending;
81113bc4:	00800084 	movi	r2,2
81113bc8:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81113bcc:	e0fffa03 	ldbu	r3,-24(fp)
81113bd0:	00a045b4 	movhi	r2,33046
81113bd4:	109f3204 	addi	r2,r2,31944
81113bd8:	18c7883a 	add	r3,r3,r3
81113bdc:	18c7883a 	add	r3,r3,r3
81113be0:	10c5883a 	add	r2,r2,r3
81113be4:	10000005 	stb	zero,0(r2)
                                break;
81113be8:	00000606 	br	81113c04 <vOutAckHandlerTask+0x1ac>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81113bec:	e0bffa03 	ldbu	r2,-24(fp)
81113bf0:	10800044 	addi	r2,r2,1
81113bf4:	e0bffa05 	stb	r2,-24(fp)
81113bf8:	e0bffa03 	ldbu	r2,-24(fp)
81113bfc:	10800230 	cmpltui	r2,r2,8
81113c00:	103fdb1e 	bne	r2,zero,81113b70 <__reset+0xfb0f3b70>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
81113c04:	d0a07217 	ldw	r2,-32312(gp)
81113c08:	1009883a 	mov	r4,r2
81113c0c:	113e3640 	call	8113e364 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81113c10:	00005a06 	br	81113d7c <vOutAckHandlerTask+0x324>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
81113c14:	111c8ac0 	call	8111c8ac <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81113c18:	00005806 	br	81113d7c <vOutAckHandlerTask+0x324>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
81113c1c:	111c82c0 	call	8111c82c <vFailGetCountSemaphoreSenderTask>
                }

                break;
81113c20:	00005606 	br	81113d7c <vOutAckHandlerTask+0x324>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
81113c24:	d0a05983 	ldbu	r2,-32410(gp)
81113c28:	10803fcc 	andi	r2,r2,255
81113c2c:	1080201c 	xori	r2,r2,128
81113c30:	10bfe004 	addi	r2,r2,-128
81113c34:	108008e0 	cmpeqi	r2,r2,35
81113c38:	1000201e 	bne	r2,zero,81113cbc <vOutAckHandlerTask+0x264>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
81113c3c:	d0a059c3 	ldbu	r2,-32409(gp)
81113c40:	10c03fcc 	andi	r3,r2,255
81113c44:	18c0201c 	xori	r3,r3,128
81113c48:	18ffe004 	addi	r3,r3,-128
81113c4c:	d0a05a0b 	ldhu	r2,-32408(gp)
81113c50:	113fffcc 	andi	r4,r2,65535
81113c54:	e0bffac4 	addi	r2,fp,-21
81113c58:	200f883a 	mov	r7,r4
81113c5c:	180d883a 	mov	r6,r3
81113c60:	01604574 	movhi	r5,33045
81113c64:	297ac504 	addi	r5,r5,-5356
81113c68:	1009883a 	mov	r4,r2
81113c6c:	11242400 	call	81124240 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
81113c70:	e0bffac4 	addi	r2,fp,-21
81113c74:	1009883a 	mov	r4,r2
81113c78:	11244540 	call	81124454 <strlen>
81113c7c:	1007883a 	mov	r3,r2
81113c80:	e0bffac4 	addi	r2,fp,-21
81113c84:	180b883a 	mov	r5,r3
81113c88:	1009883a 	mov	r4,r2
81113c8c:	111c3300 	call	8111c330 <ucCrc8wInit>
81113c90:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
81113c94:	e13ffa43 	ldbu	r4,-23(fp)
81113c98:	e0fffac4 	addi	r3,fp,-21
81113c9c:	e0bffac4 	addi	r2,fp,-21
81113ca0:	200f883a 	mov	r7,r4
81113ca4:	180d883a 	mov	r6,r3
81113ca8:	01604574 	movhi	r5,33045
81113cac:	297ac704 	addi	r5,r5,-5348
81113cb0:	1009883a 	mov	r4,r2
81113cb4:	11242400 	call	81124240 <sprintf>
81113cb8:	00000c06 	br	81113cec <vOutAckHandlerTask+0x294>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
81113cbc:	e0bffac4 	addi	r2,fp,-21
81113cc0:	00c008c4 	movi	r3,35
81113cc4:	10c00005 	stb	r3,0(r2)
81113cc8:	00c01f04 	movi	r3,124
81113ccc:	10c00045 	stb	r3,1(r2)
81113cd0:	00c00d44 	movi	r3,53
81113cd4:	10c00085 	stb	r3,2(r2)
81113cd8:	00c00d04 	movi	r3,52
81113cdc:	10c000c5 	stb	r3,3(r2)
81113ce0:	00c00ec4 	movi	r3,59
81113ce4:	10c00105 	stb	r3,4(r2)
81113ce8:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
81113cec:	d0a07417 	ldw	r2,-32304(gp)
81113cf0:	e0fffa84 	addi	r3,fp,-22
81113cf4:	180d883a 	mov	r6,r3
81113cf8:	01401904 	movi	r5,100
81113cfc:	1009883a 	mov	r4,r2
81113d00:	113ddc00 	call	8113ddc0 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
81113d04:	e0bffa83 	ldbu	r2,-22(fp)
81113d08:	10803fcc 	andi	r2,r2,255
81113d0c:	1000071e 	bne	r2,zero,81113d2c <vOutAckHandlerTask+0x2d4>
                    puts(cBufferAck);
81113d10:	e0bffac4 	addi	r2,fp,-21
81113d14:	1009883a 	mov	r4,r2
81113d18:	1123efc0 	call	81123efc <puts>
                    OSMutexPost(xTxUARTMutex);
81113d1c:	d0a07417 	ldw	r2,-32304(gp)
81113d20:	1009883a 	mov	r4,r2
81113d24:	113e3640 	call	8113e364 <OSMutexPost>
81113d28:	00000106 	br	81113d30 <vOutAckHandlerTask+0x2d8>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
81113d2c:	111ca2c0 	call	8111ca2c <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
81113d30:	00800044 	movi	r2,1
81113d34:	e0bff915 	stw	r2,-28(fp)
                
				break;
81113d38:	00001006 	br	81113d7c <vOutAckHandlerTask+0x324>
			default:
            	#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81113d3c:	00a045b4 	movhi	r2,33046
81113d40:	109fe204 	addi	r2,r2,32648
81113d44:	10800d8b 	ldhu	r2,54(r2)
81113d48:	10bfffcc 	andi	r2,r2,65535
81113d4c:	10800228 	cmpgeui	r2,r2,8
81113d50:	1000071e 	bne	r2,zero,81113d70 <vOutAckHandlerTask+0x318>
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
81113d54:	d0a06217 	ldw	r2,-32376(gp)
81113d58:	100f883a 	mov	r7,r2
81113d5c:	01801104 	movi	r6,68
81113d60:	01400044 	movi	r5,1
81113d64:	01204574 	movhi	r4,33045
81113d68:	213aca04 	addi	r4,r4,-5336
81113d6c:	1122fc80 	call	81122fc8 <fwrite>
				}
	            #endif
                eSenderAckState = sSAGettingACK;
81113d70:	00800044 	movi	r2,1
81113d74:	e0bff915 	stw	r2,-28(fp)
				break;
81113d78:	0001883a 	nop
		}
	}
81113d7c:	003f5c06 	br	81113af0 <__reset+0xfb0f3af0>

81113d80 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
81113d80:	deffd704 	addi	sp,sp,-164
81113d84:	de00012e 	bgeu	sp,et,81113d8c <vParserCommTask+0xc>
81113d88:	003b68fa 	trap	3
81113d8c:	dfc02815 	stw	ra,160(sp)
81113d90:	df002715 	stw	fp,156(sp)
81113d94:	df002704 	addi	fp,sp,156
81113d98:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
81113d9c:	e03fdd15 	stw	zero,-140(fp)
	#if DEBUG_ON
		char cPUSDebug[128];
	#endif

    #if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81113da0:	00a045b4 	movhi	r2,33046
81113da4:	109fe204 	addi	r2,r2,32648
81113da8:	10800d8b 	ldhu	r2,54(r2)
81113dac:	10bfffcc 	andi	r2,r2,65535
81113db0:	10800168 	cmpgeui	r2,r2,5
81113db4:	1000071e 	bne	r2,zero,81113dd4 <vParserCommTask+0x54>
			debug(fp,"Parser Comm Task. (Task on)\n");
81113db8:	d0a06217 	ldw	r2,-32376(gp)
81113dbc:	100f883a 	mov	r7,r2
81113dc0:	01800704 	movi	r6,28
81113dc4:	01400044 	movi	r5,1
81113dc8:	01204574 	movhi	r4,33045
81113dcc:	213adc04 	addi	r4,r4,-5264
81113dd0:	1122fc80 	call	81122fc8 <fwrite>
		}
    #endif

	eParserMode = sConfiguring;
81113dd4:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
81113dd8:	e0bfdc17 	ldw	r2,-144(fp)
81113ddc:	10800168 	cmpgeui	r2,r2,5
81113de0:	1003d31e 	bne	r2,zero,81114d30 <vParserCommTask+0xfb0>
81113de4:	e0bfdc17 	ldw	r2,-144(fp)
81113de8:	100690ba 	slli	r3,r2,2
81113dec:	00a04474 	movhi	r2,33041
81113df0:	108f8004 	addi	r2,r2,15872
81113df4:	1885883a 	add	r2,r3,r2
81113df8:	10800017 	ldw	r2,0(r2)
81113dfc:	1000683a 	jmp	r2
81113e00:	81113e14 	ori	r4,r16,17656
81113e04:	81113e20 	cmpeqi	r4,r16,17656
81113e08:	81113eb4 	orhi	r4,r16,17658
81113e0c:	81114030 	cmpltui	r4,r16,17664
81113e10:	81114074 	orhi	r4,r16,17665
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
81113e14:	00800044 	movi	r2,1
81113e18:	e0bfdc15 	stw	r2,-144(fp)
				break;
81113e1c:	0003c706 	br	81114d3c <vParserCommTask+0xfbc>
			case sWaitingMessage:

				bSuccess = FALSE;
81113e20:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
81113e24:	00800044 	movi	r2,1
81113e28:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
81113e2c:	d0a06417 	ldw	r2,-32368(gp)
81113e30:	e0ffde84 	addi	r3,fp,-134
81113e34:	180d883a 	mov	r6,r3
81113e38:	000b883a 	mov	r5,zero
81113e3c:	1009883a 	mov	r4,r2
81113e40:	113fdcc0 	call	8113fdcc <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
81113e44:	e0bfde83 	ldbu	r2,-134(fp)
81113e48:	10803fcc 	andi	r2,r2,255
81113e4c:	1000171e 	bne	r2,zero,81113eac <vParserCommTask+0x12c>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
81113e50:	01204574 	movhi	r4,33045
81113e54:	2111a404 	addi	r4,r4,18064
81113e58:	1114d400 	call	81114d40 <getPreParsedPacket>
81113e5c:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
81113e60:	e0bfdd17 	ldw	r2,-140(fp)
81113e64:	10800058 	cmpnei	r2,r2,1
81113e68:	10000e1e 	bne	r2,zero,81113ea4 <vParserCommTask+0x124>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
81113e6c:	00a04574 	movhi	r2,33045
81113e70:	1091a404 	addi	r2,r2,18064
81113e74:	10800103 	ldbu	r2,4(r2)
81113e78:	10803fcc 	andi	r2,r2,255
81113e7c:	1080201c 	xori	r2,r2,128
81113e80:	10bfe004 	addi	r2,r2,-128
81113e84:	10800858 	cmpnei	r2,r2,33
81113e88:	1000031e 	bne	r2,zero,81113e98 <vParserCommTask+0x118>
							eParserMode = sReplyParsing;
81113e8c:	008000c4 	movi	r2,3
81113e90:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81113e94:	0003a906 	br	81114d3c <vParserCommTask+0xfbc>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
81113e98:	00800084 	movi	r2,2
81113e9c:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81113ea0:	0003a606 	br	81114d3c <vParserCommTask+0xfbc>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
81113ea4:	111d1200 	call	8111d120 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81113ea8:	0003a406 	br	81114d3c <vParserCommTask+0xfbc>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
81113eac:	111d0200 	call	8111d020 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
81113eb0:	0003a206 	br	81114d3c <vParserCommTask+0xfbc>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
81113eb4:	00a04574 	movhi	r2,33045
81113eb8:	1091a404 	addi	r2,r2,18064
81113ebc:	10800143 	ldbu	r2,5(r2)
81113ec0:	10803fcc 	andi	r2,r2,255
81113ec4:	1080201c 	xori	r2,r2,128
81113ec8:	10bfe004 	addi	r2,r2,-128
81113ecc:	10c010e0 	cmpeqi	r3,r2,67
81113ed0:	1800031e 	bne	r3,zero,81113ee0 <vParserCommTask+0x160>
81113ed4:	10801420 	cmpeqi	r2,r2,80
81113ed8:	1000051e 	bne	r2,zero,81113ef0 <vParserCommTask+0x170>
81113edc:	00005006 	br	81114020 <vParserCommTask+0x2a0>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
81113ee0:	1119ca40 	call	81119ca4 <vSendEthConf>
						eParserMode = sWaitingMessage;
81113ee4:	00800044 	movi	r2,1
81113ee8:	e0bfdc15 	stw	r2,-144(fp)
						break;
81113eec:	00004f06 	br	8111402c <vParserCommTask+0x2ac>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#if DEBUG_ON
                    	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81113ef0:	00a045b4 	movhi	r2,33046
81113ef4:	109fe204 	addi	r2,r2,32648
81113ef8:	10800d8b 	ldhu	r2,54(r2)
81113efc:	10bfffcc 	andi	r2,r2,65535
81113f00:	108000e8 	cmpgeui	r2,r2,3
81113f04:	1000281e 	bne	r2,zero,81113fa8 <vParserCommTask+0x228>
							memset(cPUSDebug,0,128);
81113f08:	e0bfdec4 	addi	r2,fp,-133
81113f0c:	01802004 	movi	r6,128
81113f10:	000b883a 	mov	r5,zero
81113f14:	1009883a 	mov	r4,r2
81113f18:	1123b2c0 	call	81123b2c <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
81113f1c:	00a04574 	movhi	r2,33045
81113f20:	1091a404 	addi	r2,r2,18064
81113f24:	1080028b 	ldhu	r2,10(r2)
81113f28:	117fffcc 	andi	r5,r2,65535
81113f2c:	00a04574 	movhi	r2,33045
81113f30:	1091a404 	addi	r2,r2,18064
81113f34:	1080030b 	ldhu	r2,12(r2)
81113f38:	11bfffcc 	andi	r6,r2,65535
81113f3c:	00a04574 	movhi	r2,33045
81113f40:	1091a404 	addi	r2,r2,18064
81113f44:	1080038b 	ldhu	r2,14(r2)
81113f48:	10ffffcc 	andi	r3,r2,65535
81113f4c:	00a04574 	movhi	r2,33045
81113f50:	1091a404 	addi	r2,r2,18064
81113f54:	1080040b 	ldhu	r2,16(r2)
81113f58:	113fffcc 	andi	r4,r2,65535
81113f5c:	00a04574 	movhi	r2,33045
81113f60:	1091a404 	addi	r2,r2,18064
81113f64:	1080048b 	ldhu	r2,18(r2)
81113f68:	10bfffcc 	andi	r2,r2,65535
81113f6c:	e23fdec4 	addi	r8,fp,-133
81113f70:	d8800215 	stw	r2,8(sp)
81113f74:	d9000115 	stw	r4,4(sp)
81113f78:	d8c00015 	stw	r3,0(sp)
81113f7c:	300f883a 	mov	r7,r6
81113f80:	280d883a 	mov	r6,r5
81113f84:	01604574 	movhi	r5,33045
81113f88:	297ae404 	addi	r5,r5,-5232
81113f8c:	4009883a 	mov	r4,r8
81113f90:	11242400 	call	81124240 <sprintf>
							debug(fp, cPUSDebug );
81113f94:	d0a06217 	ldw	r2,-32376(gp)
81113f98:	e0ffdec4 	addi	r3,fp,-133
81113f9c:	180b883a 	mov	r5,r3
81113fa0:	1009883a 	mov	r4,r2
81113fa4:	112292c0 	call	8112292c <fprintf>
                    	}
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
81113fa8:	00a04574 	movhi	r2,33045
81113fac:	1091a404 	addi	r2,r2,18064
81113fb0:	10c0030b 	ldhu	r3,12(r2)
81113fb4:	00a04574 	movhi	r2,33045
81113fb8:	1091b704 	addi	r2,r2,18140
81113fbc:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
81113fc0:	00a04574 	movhi	r2,33045
81113fc4:	1091a404 	addi	r2,r2,18064
81113fc8:	10c0038b 	ldhu	r3,14(r2)
81113fcc:	00a04574 	movhi	r2,33045
81113fd0:	1091b704 	addi	r2,r2,18140
81113fd4:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
81113fd8:	00a04574 	movhi	r2,33045
81113fdc:	1091a404 	addi	r2,r2,18064
81113fe0:	10c0040b 	ldhu	r3,16(r2)
81113fe4:	00a04574 	movhi	r2,33045
81113fe8:	1091b704 	addi	r2,r2,18140
81113fec:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
81113ff0:	00a04574 	movhi	r2,33045
81113ff4:	1091a404 	addi	r2,r2,18064
81113ff8:	10c0048b 	ldhu	r3,18(r2)
81113ffc:	00a04574 	movhi	r2,33045
81114000:	1091b704 	addi	r2,r2,18140
81114004:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
81114008:	00a04574 	movhi	r2,33045
8111400c:	1091b704 	addi	r2,r2,18140
81114010:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
81114014:	00800104 	movi	r2,4
81114018:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
8111401c:	00000306 	br	8111402c <vParserCommTask+0x2ac>
					default:
						eParserMode = sWaitingMessage;
81114020:	00800044 	movi	r2,1
81114024:	e0bfdc15 	stw	r2,-144(fp)
						break;
81114028:	0001883a 	nop
				}
				break;
8111402c:	00034306 	br	81114d3c <vParserCommTask+0xfbc>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
81114030:	00800044 	movi	r2,1
81114034:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
81114038:	00a04574 	movhi	r2,33045
8111403c:	1091b704 	addi	r2,r2,18140
81114040:	1080030b 	ldhu	r2,12(r2)
81114044:	10bfffcc 	andi	r2,r2,65535
81114048:	10c01220 	cmpeqi	r3,r2,72
8111404c:	1800051e 	bne	r3,zero,81114064 <vParserCommTask+0x2e4>
81114050:	108014e0 	cmpeqi	r2,r2,83
81114054:	1000051e 	bne	r2,zero,8111406c <vParserCommTask+0x2ec>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
81114058:	00800044 	movi	r2,1
8111405c:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81114060:	00000306 	br	81114070 <vParserCommTask+0x2f0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
81114064:	0001883a 	nop
81114068:	00033406 	br	81114d3c <vParserCommTask+0xfbc>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
8111406c:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
81114070:	00033206 	br	81114d3c <vParserCommTask+0xfbc>
			case sPusHandling:
				eParserMode = sWaitingMessage;
81114074:	00800044 	movi	r2,1
81114078:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
8111407c:	00a04574 	movhi	r2,33045
81114080:	1091b704 	addi	r2,r2,18140
81114084:	1080030b 	ldhu	r2,12(r2)
81114088:	10bfffcc 	andi	r2,r2,65535
8111408c:	10c03ea0 	cmpeqi	r3,r2,250
81114090:	18004c1e 	bne	r3,zero,811141c4 <vParserCommTask+0x444>
81114094:	10c03ec8 	cmpgei	r3,r2,251
81114098:	1800031e 	bne	r3,zero,811140a8 <vParserCommTask+0x328>
8111409c:	10800460 	cmpeqi	r2,r2,17
811140a0:	1000061e 	bne	r2,zero,811140bc <vParserCommTask+0x33c>
811140a4:	00031d06 	br	81114d1c <vParserCommTask+0xf9c>
811140a8:	10c03ee0 	cmpeqi	r3,r2,251
811140ac:	1800c71e 	bne	r3,zero,811143cc <vParserCommTask+0x64c>
811140b0:	10803f20 	cmpeqi	r2,r2,252
811140b4:	10017a1e 	bne	r2,zero,811146a0 <vParserCommTask+0x920>
811140b8:	00031806 	br	81114d1c <vParserCommTask+0xf9c>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
811140bc:	00a04574 	movhi	r2,33045
811140c0:	1091b704 	addi	r2,r2,18140
811140c4:	1080038b 	ldhu	r2,14(r2)
811140c8:	10bfffcc 	andi	r2,r2,65535
811140cc:	10800060 	cmpeqi	r2,r2,1
811140d0:	10001426 	beq	r2,zero,81114124 <vParserCommTask+0x3a4>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811140d4:	00a045b4 	movhi	r2,33046
811140d8:	109fe204 	addi	r2,r2,32648
811140dc:	10800d8b 	ldhu	r2,54(r2)
811140e0:	10bfffcc 	andi	r2,r2,65535
811140e4:	10800168 	cmpgeui	r2,r2,5
811140e8:	1000071e 	bne	r2,zero,81114108 <vParserCommTask+0x388>
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
811140ec:	d0a06217 	ldw	r2,-32376(gp)
811140f0:	100f883a 	mov	r7,r2
811140f4:	01800944 	movi	r6,37
811140f8:	01400044 	movi	r5,1
811140fc:	01204574 	movhi	r4,33045
81114100:	213afa04 	addi	r4,r4,-5144
81114104:	1122fc80 	call	81122fc8 <fwrite>
								}
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
81114108:	00a04574 	movhi	r2,33045
8111410c:	1091b704 	addi	r2,r2,18140
81114110:	1080040b 	ldhu	r2,16(r2)
81114114:	10bfffcc 	andi	r2,r2,65535
81114118:	1009883a 	mov	r4,r2
8111411c:	111a6a40 	call	8111a6a4 <vTMPusTestConnection>

								break;
81114120:	00002706 	br	811141c0 <vParserCommTask+0x440>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114124:	00a045b4 	movhi	r2,33046
81114128:	109fe204 	addi	r2,r2,32648
8111412c:	10800d8b 	ldhu	r2,54(r2)
81114130:	10bfffcc 	andi	r2,r2,65535
81114134:	108000e8 	cmpgeui	r2,r2,3
81114138:	10001e1e 	bne	r2,zero,811141b4 <vParserCommTask+0x434>
									memset(cPUSDebug,0,128);
8111413c:	e0bfdec4 	addi	r2,fp,-133
81114140:	01802004 	movi	r6,128
81114144:	000b883a 	mov	r5,zero
81114148:	1009883a 	mov	r4,r2
8111414c:	1123b2c0 	call	81123b2c <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81114150:	00a04574 	movhi	r2,33045
81114154:	1091b704 	addi	r2,r2,18140
81114158:	1080030b 	ldhu	r2,12(r2)
8111415c:	113fffcc 	andi	r4,r2,65535
81114160:	00a04574 	movhi	r2,33045
81114164:	1091b704 	addi	r2,r2,18140
81114168:	1080038b 	ldhu	r2,14(r2)
8111416c:	117fffcc 	andi	r5,r2,65535
81114170:	00a04574 	movhi	r2,33045
81114174:	1091b704 	addi	r2,r2,18140
81114178:	1080040b 	ldhu	r2,16(r2)
8111417c:	10bfffcc 	andi	r2,r2,65535
81114180:	e0ffdec4 	addi	r3,fp,-133
81114184:	d8800015 	stw	r2,0(sp)
81114188:	280f883a 	mov	r7,r5
8111418c:	200d883a 	mov	r6,r4
81114190:	01604574 	movhi	r5,33045
81114194:	297b0404 	addi	r5,r5,-5104
81114198:	1809883a 	mov	r4,r3
8111419c:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
811141a0:	d0a06217 	ldw	r2,-32376(gp)
811141a4:	e0ffdec4 	addi	r3,fp,-133
811141a8:	180b883a 	mov	r5,r3
811141ac:	1009883a 	mov	r4,r2
811141b0:	112292c0 	call	8112292c <fprintf>
								}
								#endif
								eParserMode = sWaitingMessage;
811141b4:	00800044 	movi	r2,1
811141b8:	e0bfdc15 	stw	r2,-144(fp)
								break;
811141bc:	0001883a 	nop
						}
                        break;
811141c0:	0002da06 	br	81114d2c <vParserCommTask+0xfac>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
811141c4:	00a04574 	movhi	r2,33045
811141c8:	1091b704 	addi	r2,r2,18140
811141cc:	1080038b 	ldhu	r2,14(r2)
811141d0:	10bfffcc 	andi	r2,r2,65535
811141d4:	10c00f20 	cmpeqi	r3,r2,60
811141d8:	1800201e 	bne	r3,zero,8111425c <vParserCommTask+0x4dc>
811141dc:	10c00f48 	cmpgei	r3,r2,61
811141e0:	1800031e 	bne	r3,zero,811141f0 <vParserCommTask+0x470>
811141e4:	10800ee0 	cmpeqi	r2,r2,59
811141e8:	1000061e 	bne	r2,zero,81114204 <vParserCommTask+0x484>
811141ec:	00004f06 	br	8111432c <vParserCommTask+0x5ac>
811141f0:	10c00f60 	cmpeqi	r3,r2,61
811141f4:	18002a1e 	bne	r3,zero,811142a0 <vParserCommTask+0x520>
811141f8:	10800fa0 	cmpeqi	r2,r2,62
811141fc:	1000391e 	bne	r2,zero,811142e4 <vParserCommTask+0x564>
81114200:	00004a06 	br	8111432c <vParserCommTask+0x5ac>
						{
							case 59: /* TC_SCAM_RESET */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114204:	00a045b4 	movhi	r2,33046
81114208:	109fe204 	addi	r2,r2,32648
8111420c:	10800d8b 	ldhu	r2,54(r2)
81114210:	10bfffcc 	andi	r2,r2,65535
81114214:	108000e8 	cmpgeui	r2,r2,3
81114218:	1000071e 	bne	r2,zero,81114238 <vParserCommTask+0x4b8>
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
8111421c:	d0a06217 	ldw	r2,-32376(gp)
81114220:	100f883a 	mov	r7,r2
81114224:	018006c4 	movi	r6,27
81114228:	01400044 	movi	r5,1
8111422c:	01204574 	movhi	r4,33045
81114230:	213b1704 	addi	r4,r4,-5028
81114234:	1122fc80 	call	81122fc8 <fwrite>
								}
								#endif
								vSendReset();
81114238:	111a04c0 	call	8111a04c <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
8111423c:	000f883a 	mov	r7,zero
81114240:	018000c4 	movi	r6,3
81114244:	000b883a 	mov	r5,zero
81114248:	0009883a 	mov	r4,zero
8111424c:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
81114250:	0104e204 	movi	r4,5000
81114254:	110c3280 	call	8110c328 <vRstcSimucamReset>

								break;
81114258:	00005b06 	br	811143c8 <vParserCommTask+0x648>
							case 60: /* TC_SCAM_CONFIG */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111425c:	00a045b4 	movhi	r2,33046
81114260:	109fe204 	addi	r2,r2,32648
81114264:	10800d8b 	ldhu	r2,54(r2)
81114268:	10bfffcc 	andi	r2,r2,65535
8111426c:	108000e8 	cmpgeui	r2,r2,3
81114270:	1000071e 	bne	r2,zero,81114290 <vParserCommTask+0x510>
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
81114274:	d0a06217 	ldw	r2,-32376(gp)
81114278:	100f883a 	mov	r7,r2
8111427c:	01800704 	movi	r6,28
81114280:	01400044 	movi	r5,1
81114284:	01204574 	movhi	r4,33045
81114288:	213b1e04 	addi	r4,r4,-5000
8111428c:	1122fc80 	call	81122fc8 <fwrite>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114290:	01204574 	movhi	r4,33045
81114294:	2111b704 	addi	r4,r4,18140
81114298:	1114e580 	call	81114e58 <bSendMessagePUStoMebTask>

								break;
8111429c:	00004a06 	br	811143c8 <vParserCommTask+0x648>
							case 61: /* TC_SCAM_RUN */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811142a0:	00a045b4 	movhi	r2,33046
811142a4:	109fe204 	addi	r2,r2,32648
811142a8:	10800d8b 	ldhu	r2,54(r2)
811142ac:	10bfffcc 	andi	r2,r2,65535
811142b0:	108000e8 	cmpgeui	r2,r2,3
811142b4:	1000071e 	bne	r2,zero,811142d4 <vParserCommTask+0x554>
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
811142b8:	d0a06217 	ldw	r2,-32376(gp)
811142bc:	100f883a 	mov	r7,r2
811142c0:	01800644 	movi	r6,25
811142c4:	01400044 	movi	r5,1
811142c8:	01204574 	movhi	r4,33045
811142cc:	213b2604 	addi	r4,r4,-4968
811142d0:	1122fc80 	call	81122fc8 <fwrite>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811142d4:	01204574 	movhi	r4,33045
811142d8:	2111b704 	addi	r4,r4,18140
811142dc:	1114e580 	call	81114e58 <bSendMessagePUStoMebTask>

								break;
811142e0:	00003906 	br	811143c8 <vParserCommTask+0x648>
							case 62: /* TC_SCAM_TURNOFF */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811142e4:	00a045b4 	movhi	r2,33046
811142e8:	109fe204 	addi	r2,r2,32648
811142ec:	10800d8b 	ldhu	r2,54(r2)
811142f0:	10bfffcc 	andi	r2,r2,65535
811142f4:	108000e8 	cmpgeui	r2,r2,3
811142f8:	1000071e 	bne	r2,zero,81114318 <vParserCommTask+0x598>
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
811142fc:	d0a06217 	ldw	r2,-32376(gp)
81114300:	100f883a 	mov	r7,r2
81114304:	01800744 	movi	r6,29
81114308:	01400044 	movi	r5,1
8111430c:	01204574 	movhi	r4,33045
81114310:	213b2d04 	addi	r4,r4,-4940
81114314:	1122fc80 	call	81122fc8 <fwrite>
								}
								#endif
								vSendTurnOff();
81114318:	1119f340 	call	81119f34 <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
8111431c:	01204574 	movhi	r4,33045
81114320:	2111b704 	addi	r4,r4,18140
81114324:	1114e580 	call	81114e58 <bSendMessagePUStoMebTask>

								break;
81114328:	00002706 	br	811143c8 <vParserCommTask+0x648>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111432c:	00a045b4 	movhi	r2,33046
81114330:	109fe204 	addi	r2,r2,32648
81114334:	10800d8b 	ldhu	r2,54(r2)
81114338:	10bfffcc 	andi	r2,r2,65535
8111433c:	108000e8 	cmpgeui	r2,r2,3
81114340:	10001e1e 	bne	r2,zero,811143bc <vParserCommTask+0x63c>
									memset(cPUSDebug,0,128);
81114344:	e0bfdec4 	addi	r2,fp,-133
81114348:	01802004 	movi	r6,128
8111434c:	000b883a 	mov	r5,zero
81114350:	1009883a 	mov	r4,r2
81114354:	1123b2c0 	call	81123b2c <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81114358:	00a04574 	movhi	r2,33045
8111435c:	1091b704 	addi	r2,r2,18140
81114360:	1080030b 	ldhu	r2,12(r2)
81114364:	113fffcc 	andi	r4,r2,65535
81114368:	00a04574 	movhi	r2,33045
8111436c:	1091b704 	addi	r2,r2,18140
81114370:	1080038b 	ldhu	r2,14(r2)
81114374:	117fffcc 	andi	r5,r2,65535
81114378:	00a04574 	movhi	r2,33045
8111437c:	1091b704 	addi	r2,r2,18140
81114380:	1080040b 	ldhu	r2,16(r2)
81114384:	10bfffcc 	andi	r2,r2,65535
81114388:	e0ffdec4 	addi	r3,fp,-133
8111438c:	d8800015 	stw	r2,0(sp)
81114390:	280f883a 	mov	r7,r5
81114394:	200d883a 	mov	r6,r4
81114398:	01604574 	movhi	r5,33045
8111439c:	297b0404 	addi	r5,r5,-5104
811143a0:	1809883a 	mov	r4,r3
811143a4:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
811143a8:	d0a06217 	ldw	r2,-32376(gp)
811143ac:	e0ffdec4 	addi	r3,fp,-133
811143b0:	180b883a 	mov	r5,r3
811143b4:	1009883a 	mov	r4,r2
811143b8:	112292c0 	call	8112292c <fprintf>
								}
								#endif							
								eParserMode = sWaitingMessage;
811143bc:	00800044 	movi	r2,1
811143c0:	e0bfdc15 	stw	r2,-144(fp)
								break;
811143c4:	0001883a 	nop
						}
                        break;
811143c8:	00025806 	br	81114d2c <vParserCommTask+0xfac>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
811143cc:	00a04574 	movhi	r2,33045
811143d0:	1091a404 	addi	r2,r2,18064
811143d4:	1080050b 	ldhu	r2,20(r2)
811143d8:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
811143dc:	e0bfde0b 	ldhu	r2,-136(fp)
811143e0:	108000b0 	cmpltui	r2,r2,2
811143e4:	1000181e 	bne	r2,zero,81114448 <vParserCommTask+0x6c8>
							#if DEBUG_ON
							if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811143e8:	00a045b4 	movhi	r2,33046
811143ec:	109fe204 	addi	r2,r2,32648
811143f0:	10800d8b 	ldhu	r2,54(r2)
811143f4:	10bfffcc 	andi	r2,r2,65535
811143f8:	108000e8 	cmpgeui	r2,r2,3
811143fc:	10024a1e 	bne	r2,zero,81114d28 <vParserCommTask+0xfa8>
								memset(cPUSDebug,0,128);
81114400:	e0bfdec4 	addi	r2,fp,-133
81114404:	01802004 	movi	r6,128
81114408:	000b883a 	mov	r5,zero
8111440c:	1009883a 	mov	r4,r2
81114410:	1123b2c0 	call	81123b2c <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
81114414:	e0ffde0b 	ldhu	r3,-136(fp)
81114418:	e0bfdec4 	addi	r2,fp,-133
8111441c:	180d883a 	mov	r6,r3
81114420:	01604574 	movhi	r5,33045
81114424:	297b3504 	addi	r5,r5,-4908
81114428:	1009883a 	mov	r4,r2
8111442c:	11242400 	call	81124240 <sprintf>
								debug(fp, cPUSDebug );
81114430:	d0a06217 	ldw	r2,-32376(gp)
81114434:	e0ffdec4 	addi	r3,fp,-133
81114438:	180b883a 	mov	r5,r3
8111443c:	1009883a 	mov	r4,r2
81114440:	112292c0 	call	8112292c <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
81114444:	00023806 	br	81114d28 <vParserCommTask+0xfa8>
								debug(fp, cPUSDebug );
							}
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81114448:	00a04574 	movhi	r2,33045
8111444c:	1091b704 	addi	r2,r2,18140
81114450:	10800483 	ldbu	r2,18(r2)
81114454:	10c03fcc 	andi	r3,r2,255
81114458:	00a04574 	movhi	r2,33045
8111445c:	1091b704 	addi	r2,r2,18140
81114460:	18c00284 	addi	r3,r3,10
81114464:	18c7883a 	add	r3,r3,r3
81114468:	10c5883a 	add	r2,r2,r3
8111446c:	e0ffde0b 	ldhu	r3,-136(fp)
81114470:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
81114474:	00a04574 	movhi	r2,33045
81114478:	1091b704 	addi	r2,r2,18140
8111447c:	10800483 	ldbu	r2,18(r2)
81114480:	10800044 	addi	r2,r2,1
81114484:	1007883a 	mov	r3,r2
81114488:	00a04574 	movhi	r2,33045
8111448c:	1091b704 	addi	r2,r2,18140
81114490:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
81114494:	00a04574 	movhi	r2,33045
81114498:	1091b704 	addi	r2,r2,18140
8111449c:	1080038b 	ldhu	r2,14(r2)
811144a0:	10bfffcc 	andi	r2,r2,65535
811144a4:	10c000a0 	cmpeqi	r3,r2,2
811144a8:	18001f1e 	bne	r3,zero,81114528 <vParserCommTask+0x7a8>
811144ac:	10c00160 	cmpeqi	r3,r2,5
811144b0:	1800381e 	bne	r3,zero,81114594 <vParserCommTask+0x814>
811144b4:	10800060 	cmpeqi	r2,r2,1
811144b8:	10005126 	beq	r2,zero,81114600 <vParserCommTask+0x880>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811144bc:	00a045b4 	movhi	r2,33046
811144c0:	109fe204 	addi	r2,r2,32648
811144c4:	10800d8b 	ldhu	r2,54(r2)
811144c8:	10bfffcc 	andi	r2,r2,65535
811144cc:	108000e8 	cmpgeui	r2,r2,3
811144d0:	1000111e 	bne	r2,zero,81114518 <vParserCommTask+0x798>
										memset(cPUSDebug,0,128);
811144d4:	e0bfdec4 	addi	r2,fp,-133
811144d8:	01802004 	movi	r6,128
811144dc:	000b883a 	mov	r5,zero
811144e0:	1009883a 	mov	r4,r2
811144e4:	1123b2c0 	call	81123b2c <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811144e8:	e0ffde0b 	ldhu	r3,-136(fp)
811144ec:	e0bfdec4 	addi	r2,fp,-133
811144f0:	180d883a 	mov	r6,r3
811144f4:	01604574 	movhi	r5,33045
811144f8:	297b4404 	addi	r5,r5,-4848
811144fc:	1009883a 	mov	r4,r2
81114500:	11242400 	call	81124240 <sprintf>
										debug(fp, cPUSDebug );
81114504:	d0a06217 	ldw	r2,-32376(gp)
81114508:	e0ffdec4 	addi	r3,fp,-133
8111450c:	180b883a 	mov	r5,r3
81114510:	1009883a 	mov	r4,r2
81114514:	112292c0 	call	8112292c <fprintf>
									}
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
81114518:	01204574 	movhi	r4,33045
8111451c:	2111b704 	addi	r4,r4,18140
81114520:	1114e580 	call	81114e58 <bSendMessagePUStoMebTask>

									break;
81114524:	00005d06 	br	8111469c <vParserCommTask+0x91c>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114528:	00a045b4 	movhi	r2,33046
8111452c:	109fe204 	addi	r2,r2,32648
81114530:	10800d8b 	ldhu	r2,54(r2)
81114534:	10bfffcc 	andi	r2,r2,65535
81114538:	108000e8 	cmpgeui	r2,r2,3
8111453c:	1000111e 	bne	r2,zero,81114584 <vParserCommTask+0x804>
										memset(cPUSDebug,0,128);
81114540:	e0bfdec4 	addi	r2,fp,-133
81114544:	01802004 	movi	r6,128
81114548:	000b883a 	mov	r5,zero
8111454c:	1009883a 	mov	r4,r2
81114550:	1123b2c0 	call	81123b2c <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114554:	e0ffde0b 	ldhu	r3,-136(fp)
81114558:	e0bfdec4 	addi	r2,fp,-133
8111455c:	180d883a 	mov	r6,r3
81114560:	01604574 	movhi	r5,33045
81114564:	297b5404 	addi	r5,r5,-4784
81114568:	1009883a 	mov	r4,r2
8111456c:	11242400 	call	81124240 <sprintf>
										debug(fp, cPUSDebug );
81114570:	d0a06217 	ldw	r2,-32376(gp)
81114574:	e0ffdec4 	addi	r3,fp,-133
81114578:	180b883a 	mov	r5,r3
8111457c:	1009883a 	mov	r4,r2
81114580:	112292c0 	call	8112292c <fprintf>
									}
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81114584:	01204574 	movhi	r4,33045
81114588:	2111b704 	addi	r4,r4,18140
8111458c:	1114e580 	call	81114e58 <bSendMessagePUStoMebTask>

									break;
81114590:	00004206 	br	8111469c <vParserCommTask+0x91c>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114594:	00a045b4 	movhi	r2,33046
81114598:	109fe204 	addi	r2,r2,32648
8111459c:	10800d8b 	ldhu	r2,54(r2)
811145a0:	10bfffcc 	andi	r2,r2,65535
811145a4:	108000e8 	cmpgeui	r2,r2,3
811145a8:	1000111e 	bne	r2,zero,811145f0 <vParserCommTask+0x870>
										memset(cPUSDebug,0,128);
811145ac:	e0bfdec4 	addi	r2,fp,-133
811145b0:	01802004 	movi	r6,128
811145b4:	000b883a 	mov	r5,zero
811145b8:	1009883a 	mov	r4,r2
811145bc:	1123b2c0 	call	81123b2c <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811145c0:	e0ffde0b 	ldhu	r3,-136(fp)
811145c4:	e0bfdec4 	addi	r2,fp,-133
811145c8:	180d883a 	mov	r6,r3
811145cc:	01604574 	movhi	r5,33045
811145d0:	297b6404 	addi	r5,r5,-4720
811145d4:	1009883a 	mov	r4,r2
811145d8:	11242400 	call	81124240 <sprintf>
										debug(fp, cPUSDebug );
811145dc:	d0a06217 	ldw	r2,-32376(gp)
811145e0:	e0ffdec4 	addi	r3,fp,-133
811145e4:	180b883a 	mov	r5,r3
811145e8:	1009883a 	mov	r4,r2
811145ec:	112292c0 	call	8112292c <fprintf>
									}
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
811145f0:	01204574 	movhi	r4,33045
811145f4:	2111b704 	addi	r4,r4,18140
811145f8:	1114e580 	call	81114e58 <bSendMessagePUStoMebTask>

									break;
811145fc:	00002706 	br	8111469c <vParserCommTask+0x91c>
								default:
									#if DEBUG_ON
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114600:	00a045b4 	movhi	r2,33046
81114604:	109fe204 	addi	r2,r2,32648
81114608:	10800d8b 	ldhu	r2,54(r2)
8111460c:	10bfffcc 	andi	r2,r2,65535
81114610:	108000e8 	cmpgeui	r2,r2,3
81114614:	10001e1e 	bne	r2,zero,81114690 <vParserCommTask+0x910>
										memset(cPUSDebug,0,128);
81114618:	e0bfdec4 	addi	r2,fp,-133
8111461c:	01802004 	movi	r6,128
81114620:	000b883a 	mov	r5,zero
81114624:	1009883a 	mov	r4,r2
81114628:	1123b2c0 	call	81123b2c <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8111462c:	00a04574 	movhi	r2,33045
81114630:	1091b704 	addi	r2,r2,18140
81114634:	1080030b 	ldhu	r2,12(r2)
81114638:	113fffcc 	andi	r4,r2,65535
8111463c:	00a04574 	movhi	r2,33045
81114640:	1091b704 	addi	r2,r2,18140
81114644:	1080038b 	ldhu	r2,14(r2)
81114648:	117fffcc 	andi	r5,r2,65535
8111464c:	00a04574 	movhi	r2,33045
81114650:	1091b704 	addi	r2,r2,18140
81114654:	1080040b 	ldhu	r2,16(r2)
81114658:	10bfffcc 	andi	r2,r2,65535
8111465c:	e0ffdec4 	addi	r3,fp,-133
81114660:	d8800015 	stw	r2,0(sp)
81114664:	280f883a 	mov	r7,r5
81114668:	200d883a 	mov	r6,r4
8111466c:	01604574 	movhi	r5,33045
81114670:	297b0404 	addi	r5,r5,-5104
81114674:	1809883a 	mov	r4,r3
81114678:	11242400 	call	81124240 <sprintf>
										debug(fp, cPUSDebug );
8111467c:	d0a06217 	ldw	r2,-32376(gp)
81114680:	e0ffdec4 	addi	r3,fp,-133
81114684:	180b883a 	mov	r5,r3
81114688:	1009883a 	mov	r4,r2
8111468c:	112292c0 	call	8112292c <fprintf>
									}
									#endif							
									eParserMode = sWaitingMessage;
81114690:	00800044 	movi	r2,1
81114694:	e0bfdc15 	stw	r2,-144(fp)
									break;
81114698:	0001883a 	nop
							}
						}
                        break;
8111469c:	0001a206 	br	81114d28 <vParserCommTask+0xfa8>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
811146a0:	00a04574 	movhi	r2,33045
811146a4:	1091a404 	addi	r2,r2,18064
811146a8:	1080050b 	ldhu	r2,20(r2)
811146ac:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
811146b0:	00a04574 	movhi	r2,33045
811146b4:	1091b704 	addi	r2,r2,18140
811146b8:	10800483 	ldbu	r2,18(r2)
811146bc:	10c03fcc 	andi	r3,r2,255
811146c0:	00a04574 	movhi	r2,33045
811146c4:	1091b704 	addi	r2,r2,18140
811146c8:	18c00284 	addi	r3,r3,10
811146cc:	18c7883a 	add	r3,r3,r3
811146d0:	10c5883a 	add	r2,r2,r3
811146d4:	e0ffde0b 	ldhu	r3,-136(fp)
811146d8:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
811146dc:	00a04574 	movhi	r2,33045
811146e0:	1091b704 	addi	r2,r2,18140
811146e4:	10800483 	ldbu	r2,18(r2)
811146e8:	10800044 	addi	r2,r2,1
811146ec:	1007883a 	mov	r3,r2
811146f0:	00a04574 	movhi	r2,33045
811146f4:	1091b704 	addi	r2,r2,18140
811146f8:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
811146fc:	00a04574 	movhi	r2,33045
81114700:	1091b704 	addi	r2,r2,18140
81114704:	1080038b 	ldhu	r2,14(r2)
81114708:	10bfffcc 	andi	r2,r2,65535
8111470c:	10c000e0 	cmpeqi	r3,r2,3
81114710:	18000a1e 	bne	r3,zero,8111473c <vParserCommTask+0x9bc>
81114714:	10c00108 	cmpgei	r3,r2,4
81114718:	1800031e 	bne	r3,zero,81114728 <vParserCommTask+0x9a8>
8111471c:	108000a0 	cmpeqi	r2,r2,2
81114720:	1000571e 	bne	r2,zero,81114880 <vParserCommTask+0xb00>
81114724:	00015406 	br	81114c78 <vParserCommTask+0xef8>
81114728:	10c00120 	cmpeqi	r3,r2,4
8111472c:	18001e1e 	bne	r3,zero,811147a8 <vParserCommTask+0xa28>
81114730:	10800160 	cmpeqi	r2,r2,5
81114734:	1000371e 	bne	r2,zero,81114814 <vParserCommTask+0xa94>
81114738:	00014f06 	br	81114c78 <vParserCommTask+0xef8>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111473c:	00a045b4 	movhi	r2,33046
81114740:	109fe204 	addi	r2,r2,32648
81114744:	10800d8b 	ldhu	r2,54(r2)
81114748:	10bfffcc 	andi	r2,r2,65535
8111474c:	108000e8 	cmpgeui	r2,r2,3
81114750:	1000111e 	bne	r2,zero,81114798 <vParserCommTask+0xa18>
									memset(cPUSDebug,0,128);
81114754:	e0bfdec4 	addi	r2,fp,-133
81114758:	01802004 	movi	r6,128
8111475c:	000b883a 	mov	r5,zero
81114760:	1009883a 	mov	r4,r2
81114764:	1123b2c0 	call	81123b2c <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114768:	e0ffde0b 	ldhu	r3,-136(fp)
8111476c:	e0bfdec4 	addi	r2,fp,-133
81114770:	180d883a 	mov	r6,r3
81114774:	01604574 	movhi	r5,33045
81114778:	297b7604 	addi	r5,r5,-4648
8111477c:	1009883a 	mov	r4,r2
81114780:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
81114784:	d0a06217 	ldw	r2,-32376(gp)
81114788:	e0ffdec4 	addi	r3,fp,-133
8111478c:	180b883a 	mov	r5,r3
81114790:	1009883a 	mov	r4,r2
81114794:	112292c0 	call	8112292c <fprintf>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114798:	01204574 	movhi	r4,33045
8111479c:	2111b704 	addi	r4,r4,18140
811147a0:	1114e580 	call	81114e58 <bSendMessagePUStoMebTask>

								break;
811147a4:	00015c06 	br	81114d18 <vParserCommTask+0xf98>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811147a8:	00a045b4 	movhi	r2,33046
811147ac:	109fe204 	addi	r2,r2,32648
811147b0:	10800d8b 	ldhu	r2,54(r2)
811147b4:	10bfffcc 	andi	r2,r2,65535
811147b8:	108000e8 	cmpgeui	r2,r2,3
811147bc:	1000111e 	bne	r2,zero,81114804 <vParserCommTask+0xa84>
									memset(cPUSDebug,0,128);
811147c0:	e0bfdec4 	addi	r2,fp,-133
811147c4:	01802004 	movi	r6,128
811147c8:	000b883a 	mov	r5,zero
811147cc:	1009883a 	mov	r4,r2
811147d0:	1123b2c0 	call	81123b2c <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811147d4:	e0ffde0b 	ldhu	r3,-136(fp)
811147d8:	e0bfdec4 	addi	r2,fp,-133
811147dc:	180d883a 	mov	r6,r3
811147e0:	01604574 	movhi	r5,33045
811147e4:	297b8604 	addi	r5,r5,-4584
811147e8:	1009883a 	mov	r4,r2
811147ec:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
811147f0:	d0a06217 	ldw	r2,-32376(gp)
811147f4:	e0ffdec4 	addi	r3,fp,-133
811147f8:	180b883a 	mov	r5,r3
811147fc:	1009883a 	mov	r4,r2
81114800:	112292c0 	call	8112292c <fprintf>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114804:	01204574 	movhi	r4,33045
81114808:	2111b704 	addi	r4,r4,18140
8111480c:	1114e580 	call	81114e58 <bSendMessagePUStoMebTask>

								break;
81114810:	00014106 	br	81114d18 <vParserCommTask+0xf98>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114814:	00a045b4 	movhi	r2,33046
81114818:	109fe204 	addi	r2,r2,32648
8111481c:	10800d8b 	ldhu	r2,54(r2)
81114820:	10bfffcc 	andi	r2,r2,65535
81114824:	108000e8 	cmpgeui	r2,r2,3
81114828:	1000111e 	bne	r2,zero,81114870 <vParserCommTask+0xaf0>
									memset(cPUSDebug,0,128);
8111482c:	e0bfdec4 	addi	r2,fp,-133
81114830:	01802004 	movi	r6,128
81114834:	000b883a 	mov	r5,zero
81114838:	1009883a 	mov	r4,r2
8111483c:	1123b2c0 	call	81123b2c <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81114840:	e0ffde0b 	ldhu	r3,-136(fp)
81114844:	e0bfdec4 	addi	r2,fp,-133
81114848:	180d883a 	mov	r6,r3
8111484c:	01604574 	movhi	r5,33045
81114850:	297b9604 	addi	r5,r5,-4520
81114854:	1009883a 	mov	r4,r2
81114858:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
8111485c:	d0a06217 	ldw	r2,-32376(gp)
81114860:	e0ffdec4 	addi	r3,fp,-133
81114864:	180b883a 	mov	r5,r3
81114868:	1009883a 	mov	r4,r2
8111486c:	112292c0 	call	8112292c <fprintf>
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81114870:	01204574 	movhi	r4,33045
81114874:	2111b704 	addi	r4,r4,18140
81114878:	1114e580 	call	81114e58 <bSendMessagePUStoMebTask>

								break;
8111487c:	00012606 	br	81114d18 <vParserCommTask+0xf98>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
81114880:	00a04574 	movhi	r2,33045
81114884:	1091b704 	addi	r2,r2,18140
81114888:	10800483 	ldbu	r2,18(r2)
8111488c:	10c03fcc 	andi	r3,r2,255
81114890:	00a04574 	movhi	r2,33045
81114894:	1091a404 	addi	r2,r2,18064
81114898:	1100058b 	ldhu	r4,22(r2)
8111489c:	00a04574 	movhi	r2,33045
811148a0:	1091b704 	addi	r2,r2,18140
811148a4:	18c00284 	addi	r3,r3,10
811148a8:	18c7883a 	add	r3,r3,r3
811148ac:	10c5883a 	add	r2,r2,r3
811148b0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811148b4:	00a04574 	movhi	r2,33045
811148b8:	1091b704 	addi	r2,r2,18140
811148bc:	10800483 	ldbu	r2,18(r2)
811148c0:	10800044 	addi	r2,r2,1
811148c4:	1007883a 	mov	r3,r2
811148c8:	00a04574 	movhi	r2,33045
811148cc:	1091b704 	addi	r2,r2,18140
811148d0:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
811148d4:	00a04574 	movhi	r2,33045
811148d8:	1091b704 	addi	r2,r2,18140
811148dc:	10800483 	ldbu	r2,18(r2)
811148e0:	10c03fcc 	andi	r3,r2,255
811148e4:	00a04574 	movhi	r2,33045
811148e8:	1091a404 	addi	r2,r2,18064
811148ec:	1100060b 	ldhu	r4,24(r2)
811148f0:	00a04574 	movhi	r2,33045
811148f4:	1091b704 	addi	r2,r2,18140
811148f8:	18c00284 	addi	r3,r3,10
811148fc:	18c7883a 	add	r3,r3,r3
81114900:	10c5883a 	add	r2,r2,r3
81114904:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81114908:	00a04574 	movhi	r2,33045
8111490c:	1091b704 	addi	r2,r2,18140
81114910:	10800483 	ldbu	r2,18(r2)
81114914:	10800044 	addi	r2,r2,1
81114918:	1007883a 	mov	r3,r2
8111491c:	00a04574 	movhi	r2,33045
81114920:	1091b704 	addi	r2,r2,18140
81114924:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
81114928:	00a04574 	movhi	r2,33045
8111492c:	1091b704 	addi	r2,r2,18140
81114930:	10800483 	ldbu	r2,18(r2)
81114934:	10c03fcc 	andi	r3,r2,255
81114938:	00a04574 	movhi	r2,33045
8111493c:	1091a404 	addi	r2,r2,18064
81114940:	1100068b 	ldhu	r4,26(r2)
81114944:	00a04574 	movhi	r2,33045
81114948:	1091b704 	addi	r2,r2,18140
8111494c:	18c00284 	addi	r3,r3,10
81114950:	18c7883a 	add	r3,r3,r3
81114954:	10c5883a 	add	r2,r2,r3
81114958:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8111495c:	00a04574 	movhi	r2,33045
81114960:	1091b704 	addi	r2,r2,18140
81114964:	10800483 	ldbu	r2,18(r2)
81114968:	10800044 	addi	r2,r2,1
8111496c:	1007883a 	mov	r3,r2
81114970:	00a04574 	movhi	r2,33045
81114974:	1091b704 	addi	r2,r2,18140
81114978:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
8111497c:	00a04574 	movhi	r2,33045
81114980:	1091b704 	addi	r2,r2,18140
81114984:	10800483 	ldbu	r2,18(r2)
81114988:	10c03fcc 	andi	r3,r2,255
8111498c:	00a04574 	movhi	r2,33045
81114990:	1091a404 	addi	r2,r2,18064
81114994:	1100070b 	ldhu	r4,28(r2)
81114998:	00a04574 	movhi	r2,33045
8111499c:	1091b704 	addi	r2,r2,18140
811149a0:	18c00284 	addi	r3,r3,10
811149a4:	18c7883a 	add	r3,r3,r3
811149a8:	10c5883a 	add	r2,r2,r3
811149ac:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811149b0:	00a04574 	movhi	r2,33045
811149b4:	1091b704 	addi	r2,r2,18140
811149b8:	10800483 	ldbu	r2,18(r2)
811149bc:	10800044 	addi	r2,r2,1
811149c0:	1007883a 	mov	r3,r2
811149c4:	00a04574 	movhi	r2,33045
811149c8:	1091b704 	addi	r2,r2,18140
811149cc:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
811149d0:	00a04574 	movhi	r2,33045
811149d4:	1091b704 	addi	r2,r2,18140
811149d8:	10800483 	ldbu	r2,18(r2)
811149dc:	10c03fcc 	andi	r3,r2,255
811149e0:	00a04574 	movhi	r2,33045
811149e4:	1091a404 	addi	r2,r2,18064
811149e8:	1100078b 	ldhu	r4,30(r2)
811149ec:	00a04574 	movhi	r2,33045
811149f0:	1091b704 	addi	r2,r2,18140
811149f4:	18c00284 	addi	r3,r3,10
811149f8:	18c7883a 	add	r3,r3,r3
811149fc:	10c5883a 	add	r2,r2,r3
81114a00:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81114a04:	00a04574 	movhi	r2,33045
81114a08:	1091b704 	addi	r2,r2,18140
81114a0c:	10800483 	ldbu	r2,18(r2)
81114a10:	10800044 	addi	r2,r2,1
81114a14:	1007883a 	mov	r3,r2
81114a18:	00a04574 	movhi	r2,33045
81114a1c:	1091b704 	addi	r2,r2,18140
81114a20:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
81114a24:	00a04574 	movhi	r2,33045
81114a28:	1091b704 	addi	r2,r2,18140
81114a2c:	10800483 	ldbu	r2,18(r2)
81114a30:	10c03fcc 	andi	r3,r2,255
81114a34:	00a04574 	movhi	r2,33045
81114a38:	1091a404 	addi	r2,r2,18064
81114a3c:	1100080b 	ldhu	r4,32(r2)
81114a40:	00a04574 	movhi	r2,33045
81114a44:	1091b704 	addi	r2,r2,18140
81114a48:	18c00284 	addi	r3,r3,10
81114a4c:	18c7883a 	add	r3,r3,r3
81114a50:	10c5883a 	add	r2,r2,r3
81114a54:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81114a58:	00a04574 	movhi	r2,33045
81114a5c:	1091b704 	addi	r2,r2,18140
81114a60:	10800483 	ldbu	r2,18(r2)
81114a64:	10800044 	addi	r2,r2,1
81114a68:	1007883a 	mov	r3,r2
81114a6c:	00a04574 	movhi	r2,33045
81114a70:	1091b704 	addi	r2,r2,18140
81114a74:	10c00485 	stb	r3,18(r2)


								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114a78:	00a045b4 	movhi	r2,33046
81114a7c:	109fe204 	addi	r2,r2,32648
81114a80:	10800d8b 	ldhu	r2,54(r2)
81114a84:	10bfffcc 	andi	r2,r2,65535
81114a88:	108000e8 	cmpgeui	r2,r2,3
81114a8c:	1000a11e 	bne	r2,zero,81114d14 <vParserCommTask+0xf94>
									memset(cPUSDebug,0,128);
81114a90:	e0bfdec4 	addi	r2,fp,-133
81114a94:	01802004 	movi	r6,128
81114a98:	000b883a 	mov	r5,zero
81114a9c:	1009883a 	mov	r4,r2
81114aa0:	1123b2c0 	call	81123b2c <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
81114aa4:	e0ffdec4 	addi	r3,fp,-133
81114aa8:	00a04574 	movhi	r2,33045
81114aac:	10bba504 	addi	r2,r2,-4460
81114ab0:	1009883a 	mov	r4,r2
81114ab4:	00800b84 	movi	r2,46
81114ab8:	100d883a 	mov	r6,r2
81114abc:	200b883a 	mov	r5,r4
81114ac0:	1809883a 	mov	r4,r3
81114ac4:	11239dc0 	call	811239dc <memcpy>
									debug(fp, cPUSDebug );
81114ac8:	d0a06217 	ldw	r2,-32376(gp)
81114acc:	e0ffdec4 	addi	r3,fp,-133
81114ad0:	180b883a 	mov	r5,r3
81114ad4:	1009883a 	mov	r4,r2
81114ad8:	112292c0 	call	8112292c <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81114adc:	e0ffde0b 	ldhu	r3,-136(fp)
81114ae0:	e0bfdec4 	addi	r2,fp,-133
81114ae4:	180d883a 	mov	r6,r3
81114ae8:	01604574 	movhi	r5,33045
81114aec:	297bb104 	addi	r5,r5,-4412
81114af0:	1009883a 	mov	r4,r2
81114af4:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
81114af8:	d0a06217 	ldw	r2,-32376(gp)
81114afc:	e0ffdec4 	addi	r3,fp,-133
81114b00:	180b883a 	mov	r5,r3
81114b04:	1009883a 	mov	r4,r2
81114b08:	112292c0 	call	8112292c <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
81114b0c:	00a04574 	movhi	r2,33045
81114b10:	1091a404 	addi	r2,r2,18064
81114b14:	1080058b 	ldhu	r2,22(r2)
81114b18:	10ffffcc 	andi	r3,r2,65535
81114b1c:	e0bfdec4 	addi	r2,fp,-133
81114b20:	180d883a 	mov	r6,r3
81114b24:	01604574 	movhi	r5,33045
81114b28:	297bb804 	addi	r5,r5,-4384
81114b2c:	1009883a 	mov	r4,r2
81114b30:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
81114b34:	d0a06217 	ldw	r2,-32376(gp)
81114b38:	e0ffdec4 	addi	r3,fp,-133
81114b3c:	180b883a 	mov	r5,r3
81114b40:	1009883a 	mov	r4,r2
81114b44:	112292c0 	call	8112292c <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
81114b48:	00a04574 	movhi	r2,33045
81114b4c:	1091a404 	addi	r2,r2,18064
81114b50:	1080060b 	ldhu	r2,24(r2)
81114b54:	10ffffcc 	andi	r3,r2,65535
81114b58:	e0bfdec4 	addi	r2,fp,-133
81114b5c:	180d883a 	mov	r6,r3
81114b60:	01604574 	movhi	r5,33045
81114b64:	297bbc04 	addi	r5,r5,-4368
81114b68:	1009883a 	mov	r4,r2
81114b6c:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
81114b70:	d0a06217 	ldw	r2,-32376(gp)
81114b74:	e0ffdec4 	addi	r3,fp,-133
81114b78:	180b883a 	mov	r5,r3
81114b7c:	1009883a 	mov	r4,r2
81114b80:	112292c0 	call	8112292c <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
81114b84:	00a04574 	movhi	r2,33045
81114b88:	1091a404 	addi	r2,r2,18064
81114b8c:	1080068b 	ldhu	r2,26(r2)
81114b90:	10ffffcc 	andi	r3,r2,65535
81114b94:	e0bfdec4 	addi	r2,fp,-133
81114b98:	180d883a 	mov	r6,r3
81114b9c:	01604574 	movhi	r5,33045
81114ba0:	297bc104 	addi	r5,r5,-4348
81114ba4:	1009883a 	mov	r4,r2
81114ba8:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
81114bac:	d0a06217 	ldw	r2,-32376(gp)
81114bb0:	e0ffdec4 	addi	r3,fp,-133
81114bb4:	180b883a 	mov	r5,r3
81114bb8:	1009883a 	mov	r4,r2
81114bbc:	112292c0 	call	8112292c <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
81114bc0:	00a04574 	movhi	r2,33045
81114bc4:	1091a404 	addi	r2,r2,18064
81114bc8:	1080070b 	ldhu	r2,28(r2)
81114bcc:	10ffffcc 	andi	r3,r2,65535
81114bd0:	e0bfdec4 	addi	r2,fp,-133
81114bd4:	180d883a 	mov	r6,r3
81114bd8:	01604574 	movhi	r5,33045
81114bdc:	297bc804 	addi	r5,r5,-4320
81114be0:	1009883a 	mov	r4,r2
81114be4:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
81114be8:	d0a06217 	ldw	r2,-32376(gp)
81114bec:	e0ffdec4 	addi	r3,fp,-133
81114bf0:	180b883a 	mov	r5,r3
81114bf4:	1009883a 	mov	r4,r2
81114bf8:	112292c0 	call	8112292c <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
81114bfc:	00a04574 	movhi	r2,33045
81114c00:	1091a404 	addi	r2,r2,18064
81114c04:	1080078b 	ldhu	r2,30(r2)
81114c08:	10ffffcc 	andi	r3,r2,65535
81114c0c:	e0bfdec4 	addi	r2,fp,-133
81114c10:	180d883a 	mov	r6,r3
81114c14:	01604574 	movhi	r5,33045
81114c18:	297bcf04 	addi	r5,r5,-4292
81114c1c:	1009883a 	mov	r4,r2
81114c20:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
81114c24:	d0a06217 	ldw	r2,-32376(gp)
81114c28:	e0ffdec4 	addi	r3,fp,-133
81114c2c:	180b883a 	mov	r5,r3
81114c30:	1009883a 	mov	r4,r2
81114c34:	112292c0 	call	8112292c <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
81114c38:	00a04574 	movhi	r2,33045
81114c3c:	1091a404 	addi	r2,r2,18064
81114c40:	1080080b 	ldhu	r2,32(r2)
81114c44:	10ffffcc 	andi	r3,r2,65535
81114c48:	e0bfdec4 	addi	r2,fp,-133
81114c4c:	180d883a 	mov	r6,r3
81114c50:	01604574 	movhi	r5,33045
81114c54:	297bd504 	addi	r5,r5,-4268
81114c58:	1009883a 	mov	r4,r2
81114c5c:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
81114c60:	d0a06217 	ldw	r2,-32376(gp)
81114c64:	e0ffdec4 	addi	r3,fp,-133
81114c68:	180b883a 	mov	r5,r3
81114c6c:	1009883a 	mov	r4,r2
81114c70:	112292c0 	call	8112292c <fprintf>
								}
								#endif

								break;
81114c74:	00002706 	br	81114d14 <vParserCommTask+0xf94>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81114c78:	00a045b4 	movhi	r2,33046
81114c7c:	109fe204 	addi	r2,r2,32648
81114c80:	10800d8b 	ldhu	r2,54(r2)
81114c84:	10bfffcc 	andi	r2,r2,65535
81114c88:	108000e8 	cmpgeui	r2,r2,3
81114c8c:	10001e1e 	bne	r2,zero,81114d08 <vParserCommTask+0xf88>
									memset(cPUSDebug,0,128);
81114c90:	e0bfdec4 	addi	r2,fp,-133
81114c94:	01802004 	movi	r6,128
81114c98:	000b883a 	mov	r5,zero
81114c9c:	1009883a 	mov	r4,r2
81114ca0:	1123b2c0 	call	81123b2c <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81114ca4:	00a04574 	movhi	r2,33045
81114ca8:	1091b704 	addi	r2,r2,18140
81114cac:	1080030b 	ldhu	r2,12(r2)
81114cb0:	113fffcc 	andi	r4,r2,65535
81114cb4:	00a04574 	movhi	r2,33045
81114cb8:	1091b704 	addi	r2,r2,18140
81114cbc:	1080038b 	ldhu	r2,14(r2)
81114cc0:	117fffcc 	andi	r5,r2,65535
81114cc4:	00a04574 	movhi	r2,33045
81114cc8:	1091b704 	addi	r2,r2,18140
81114ccc:	1080040b 	ldhu	r2,16(r2)
81114cd0:	10bfffcc 	andi	r2,r2,65535
81114cd4:	e0ffdec4 	addi	r3,fp,-133
81114cd8:	d8800015 	stw	r2,0(sp)
81114cdc:	280f883a 	mov	r7,r5
81114ce0:	200d883a 	mov	r6,r4
81114ce4:	01604574 	movhi	r5,33045
81114ce8:	297b0404 	addi	r5,r5,-5104
81114cec:	1809883a 	mov	r4,r3
81114cf0:	11242400 	call	81124240 <sprintf>
									debug(fp, cPUSDebug );
81114cf4:	d0a06217 	ldw	r2,-32376(gp)
81114cf8:	e0ffdec4 	addi	r3,fp,-133
81114cfc:	180b883a 	mov	r5,r3
81114d00:	1009883a 	mov	r4,r2
81114d04:	112292c0 	call	8112292c <fprintf>
								}
								#endif							
								eParserMode = sWaitingMessage;
81114d08:	00800044 	movi	r2,1
81114d0c:	e0bfdc15 	stw	r2,-144(fp)
								break;
81114d10:	00000106 	br	81114d18 <vParserCommTask+0xf98>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
									debug(fp, cPUSDebug );
								}
								#endif

								break;
81114d14:	0001883a 	nop
								}
								#endif							
								eParserMode = sWaitingMessage;
								break;
						}
                        break;
81114d18:	00000406 	br	81114d2c <vParserCommTask+0xfac>
                    default:
						eParserMode = sWaitingMessage;
81114d1c:	00800044 	movi	r2,1
81114d20:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81114d24:	00000106 	br	81114d2c <vParserCommTask+0xfac>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
81114d28:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;				
81114d2c:	00000306 	br	81114d3c <vParserCommTask+0xfbc>
			default:
				eParserMode = sWaitingMessage;
81114d30:	00800044 	movi	r2,1
81114d34:	e0bfdc15 	stw	r2,-144(fp)
				break;
81114d38:	0001883a 	nop
		}
	}
81114d3c:	003c2606 	br	81113dd8 <__reset+0xfb0f3dd8>

81114d40 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
81114d40:	defffb04 	addi	sp,sp,-20
81114d44:	de00012e 	bgeu	sp,et,81114d4c <getPreParsedPacket+0xc>
81114d48:	003b68fa 	trap	3
81114d4c:	dfc00415 	stw	ra,16(sp)
81114d50:	df000315 	stw	fp,12(sp)
81114d54:	df000304 	addi	fp,sp,12
81114d58:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114d5c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
81114d60:	d0a06b17 	ldw	r2,-32340(gp)
81114d64:	e0fffe44 	addi	r3,fp,-7
81114d68:	180d883a 	mov	r6,r3
81114d6c:	000b883a 	mov	r5,zero
81114d70:	1009883a 	mov	r4,r2
81114d74:	113ddc00 	call	8113ddc0 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
81114d78:	e0bffe43 	ldbu	r2,-7(fp)
81114d7c:	10803fcc 	andi	r2,r2,255
81114d80:	10002e1e 	bne	r2,zero,81114e3c <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81114d84:	e03ffe05 	stb	zero,-8(fp)
81114d88:	00002506 	br	81114e20 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
81114d8c:	e0fffe03 	ldbu	r3,-8(fp)
81114d90:	00a045b4 	movhi	r2,33046
81114d94:	109f3a04 	addi	r2,r2,31976
81114d98:	18c01324 	muli	r3,r3,76
81114d9c:	10c5883a 	add	r2,r2,r3
81114da0:	10800104 	addi	r2,r2,4
81114da4:	10800003 	ldbu	r2,0(r2)
81114da8:	10803fcc 	andi	r2,r2,255
81114dac:	1080201c 	xori	r2,r2,128
81114db0:	10bfe004 	addi	r2,r2,-128
81114db4:	10001726 	beq	r2,zero,81114e14 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
81114db8:	e0fffe03 	ldbu	r3,-8(fp)
81114dbc:	e13fff17 	ldw	r4,-4(fp)
81114dc0:	00a045b4 	movhi	r2,33046
81114dc4:	109f3a04 	addi	r2,r2,31976
81114dc8:	18c01324 	muli	r3,r3,76
81114dcc:	10c5883a 	add	r2,r2,r3
81114dd0:	2007883a 	mov	r3,r4
81114dd4:	1009883a 	mov	r4,r2
81114dd8:	00801304 	movi	r2,76
81114ddc:	100d883a 	mov	r6,r2
81114de0:	200b883a 	mov	r5,r4
81114de4:	1809883a 	mov	r4,r3
81114de8:	11239dc0 	call	811239dc <memcpy>
                bSuccess = TRUE;
81114dec:	00800044 	movi	r2,1
81114df0:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
81114df4:	e0fffe03 	ldbu	r3,-8(fp)
81114df8:	00a045b4 	movhi	r2,33046
81114dfc:	109f3a04 	addi	r2,r2,31976
81114e00:	18c01324 	muli	r3,r3,76
81114e04:	10c5883a 	add	r2,r2,r3
81114e08:	10800104 	addi	r2,r2,4
81114e0c:	10000005 	stb	zero,0(r2)
                break;
81114e10:	00000606 	br	81114e2c <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81114e14:	e0bffe03 	ldbu	r2,-8(fp)
81114e18:	10800044 	addi	r2,r2,1
81114e1c:	e0bffe05 	stb	r2,-8(fp)
81114e20:	e0bffe03 	ldbu	r2,-8(fp)
81114e24:	10800230 	cmpltui	r2,r2,8
81114e28:	103fd81e 	bne	r2,zero,81114d8c <__reset+0xfb0f4d8c>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
81114e2c:	d0a06b17 	ldw	r2,-32340(gp)
81114e30:	1009883a 	mov	r4,r2
81114e34:	113e3640 	call	8113e364 <OSMutexPost>
81114e38:	00000106 	br	81114e40 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
81114e3c:	111d0a00 	call	8111d0a0 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
81114e40:	e0bffd17 	ldw	r2,-12(fp)
}
81114e44:	e037883a 	mov	sp,fp
81114e48:	dfc00117 	ldw	ra,4(sp)
81114e4c:	df000017 	ldw	fp,0(sp)
81114e50:	dec00204 	addi	sp,sp,8
81114e54:	f800283a 	ret

81114e58 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
81114e58:	defffa04 	addi	sp,sp,-24
81114e5c:	de00012e 	bgeu	sp,et,81114e64 <bSendMessagePUStoMebTask+0xc>
81114e60:	003b68fa 	trap	3
81114e64:	dfc00515 	stw	ra,20(sp)
81114e68:	df000415 	stw	fp,16(sp)
81114e6c:	df000404 	addi	fp,sp,16
81114e70:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114e74:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
81114e78:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
81114e7c:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
81114e80:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
81114e84:	d0a07317 	ldw	r2,-32308(gp)
81114e88:	e0fffd44 	addi	r3,fp,-11
81114e8c:	180d883a 	mov	r6,r3
81114e90:	01400284 	movi	r5,10
81114e94:	1009883a 	mov	r4,r2
81114e98:	113ddc00 	call	8113ddc0 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81114e9c:	e0bffd43 	ldbu	r2,-11(fp)
81114ea0:	10803fcc 	andi	r2,r2,255
81114ea4:	1000401e 	bne	r2,zero,81114fa8 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
81114ea8:	e03ffd05 	stb	zero,-12(fp)
81114eac:	00003806 	br	81114f90 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
81114eb0:	e0fffd03 	ldbu	r3,-12(fp)
81114eb4:	00a04574 	movhi	r2,33045
81114eb8:	109c5c04 	addi	r2,r2,29040
81114ebc:	18c01524 	muli	r3,r3,84
81114ec0:	10c5883a 	add	r2,r2,r3
81114ec4:	10800104 	addi	r2,r2,4
81114ec8:	10800017 	ldw	r2,0(r2)
81114ecc:	10002d1e 	bne	r2,zero,81114f84 <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
81114ed0:	e0fffd03 	ldbu	r3,-12(fp)
81114ed4:	00a04574 	movhi	r2,33045
81114ed8:	109c5c04 	addi	r2,r2,29040
81114edc:	18c01524 	muli	r3,r3,84
81114ee0:	10c7883a 	add	r3,r2,r3
81114ee4:	e0bfff17 	ldw	r2,-4(fp)
81114ee8:	1009883a 	mov	r4,r2
81114eec:	00801504 	movi	r2,84
81114ef0:	100d883a 	mov	r6,r2
81114ef4:	200b883a 	mov	r5,r4
81114ef8:	1809883a 	mov	r4,r3
81114efc:	11239dc0 	call	811239dc <memcpy>
            	xPus[i].bInUse = TRUE;
81114f00:	e0fffd03 	ldbu	r3,-12(fp)
81114f04:	00a04574 	movhi	r2,33045
81114f08:	109c5c04 	addi	r2,r2,29040
81114f0c:	18c01524 	muli	r3,r3,84
81114f10:	10c5883a 	add	r2,r2,r3
81114f14:	10800104 	addi	r2,r2,4
81114f18:	00c00044 	movi	r3,1
81114f1c:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
81114f20:	00800044 	movi	r2,1
81114f24:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
81114f28:	00800044 	movi	r2,1
81114f2c:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
81114f30:	d0a06917 	ldw	r2,-32348(gp)
81114f34:	e0fffe17 	ldw	r3,-8(fp)
81114f38:	180b883a 	mov	r5,r3
81114f3c:	1009883a 	mov	r4,r2
81114f40:	113f2dc0 	call	8113f2dc <OSQPost>
81114f44:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
81114f48:	e0bffd43 	ldbu	r2,-11(fp)
81114f4c:	10803fcc 	andi	r2,r2,255
81114f50:	10000926 	beq	r2,zero,81114f78 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
81114f54:	111e3200 	call	8111e320 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
81114f58:	e0fffd03 	ldbu	r3,-12(fp)
81114f5c:	00a04574 	movhi	r2,33045
81114f60:	109c5c04 	addi	r2,r2,29040
81114f64:	18c01524 	muli	r3,r3,84
81114f68:	10c5883a 	add	r2,r2,r3
81114f6c:	10800104 	addi	r2,r2,4
81114f70:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81114f74:	00000906 	br	81114f9c <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
81114f78:	00800044 	movi	r2,1
81114f7c:	e0bffc15 	stw	r2,-16(fp)
                break;
81114f80:	00000606 	br	81114f9c <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
81114f84:	e0bffd03 	ldbu	r2,-12(fp)
81114f88:	10800044 	addi	r2,r2,1
81114f8c:	e0bffd05 	stb	r2,-12(fp)
81114f90:	e0bffd03 	ldbu	r2,-12(fp)
81114f94:	10800130 	cmpltui	r2,r2,4
81114f98:	103fc51e 	bne	r2,zero,81114eb0 <__reset+0xfb0f4eb0>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
81114f9c:	d0a07317 	ldw	r2,-32308(gp)
81114fa0:	1009883a 	mov	r4,r2
81114fa4:	113e3640 	call	8113e364 <OSMutexPost>
    }

    return bSuccess;
81114fa8:	e0bffc17 	ldw	r2,-16(fp)
}
81114fac:	e037883a 	mov	sp,fp
81114fb0:	dfc00117 	ldw	ra,4(sp)
81114fb4:	df000017 	ldw	fp,0(sp)
81114fb8:	dec00204 	addi	sp,sp,8
81114fbc:	f800283a 	ret

81114fc0 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
81114fc0:	deffab04 	addi	sp,sp,-340
81114fc4:	de00012e 	bgeu	sp,et,81114fcc <vReceiverUartTask+0xc>
81114fc8:	003b68fa 	trap	3
81114fcc:	dfc05415 	stw	ra,336(sp)
81114fd0:	df005315 	stw	fp,332(sp)
81114fd4:	df005304 	addi	fp,sp,332
81114fd8:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114fdc:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81114fe0:	00a045b4 	movhi	r2,33046
81114fe4:	109fe204 	addi	r2,r2,32648
81114fe8:	10800d8b 	ldhu	r2,54(r2)
81114fec:	10bfffcc 	andi	r2,r2,65535
81114ff0:	10800168 	cmpgeui	r2,r2,5
81114ff4:	1000071e 	bne	r2,zero,81115014 <vReceiverUartTask+0x54>
        debug(fp,"Receiver UART Task. (Task on)\n");
81114ff8:	d0a06217 	ldw	r2,-32376(gp)
81114ffc:	100f883a 	mov	r7,r2
81115000:	01800784 	movi	r6,30
81115004:	01400044 	movi	r5,1
81115008:	01204574 	movhi	r4,33045
8111500c:	213bdb04 	addi	r4,r4,-4244
81115010:	1122fc80 	call	81122fc8 <fwrite>
    }
    #endif

    eReaderRXMode = sRConfiguring;
81115014:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
81115018:	e0bfad17 	ldw	r2,-332(fp)
8111501c:	10c00060 	cmpeqi	r3,r2,1
81115020:	1800091e 	bne	r3,zero,81115048 <vReceiverUartTask+0x88>
81115024:	0080052e 	bgeu	zero,r2,8111503c <vReceiverUartTask+0x7c>
81115028:	10c000a0 	cmpeqi	r3,r2,2
8111502c:	1800631e 	bne	r3,zero,811151bc <vReceiverUartTask+0x1fc>
81115030:	108000e0 	cmpeqi	r2,r2,3
81115034:	1000741e 	bne	r2,zero,81115208 <vReceiverUartTask+0x248>
81115038:	00007d06 	br	81115230 <vReceiverUartTask+0x270>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
8111503c:	00800044 	movi	r2,1
81115040:	e0bfad15 	stw	r2,-332(fp)
                break;
81115044:	00007e06 	br	81115240 <vReceiverUartTask+0x280>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
81115048:	e0bfaf04 	addi	r2,fp,-324
8111504c:	01802004 	movi	r6,128
81115050:	000b883a 	mov	r5,zero
81115054:	1009883a 	mov	r4,r2
81115058:	1123b2c0 	call	81123b2c <memset>
                scanf("%s", cReceive);
8111505c:	e0bfcf04 	addi	r2,fp,-196
81115060:	100b883a 	mov	r5,r2
81115064:	01204574 	movhi	r4,33045
81115068:	213be304 	addi	r4,r4,-4212
8111506c:	11241640 	call	81124164 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
81115070:	e0ffcf04 	addi	r3,fp,-196
81115074:	e0bfaf04 	addi	r2,fp,-324
81115078:	01801fc4 	movi	r6,127
8111507c:	180b883a 	mov	r5,r3
81115080:	1009883a 	mov	r4,r2
81115084:	11239dc0 	call	811239dc <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
81115088:	e0bfaf04 	addi	r2,fp,-324
8111508c:	01604574 	movhi	r5,33045
81115090:	2951cc04 	addi	r5,r5,18224
81115094:	1009883a 	mov	r4,r2
81115098:	11156b00 	call	811156b0 <bPreParserV2>
8111509c:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
811150a0:	e0bfae17 	ldw	r2,-328(fp)
811150a4:	10800058 	cmpnei	r2,r2,1
811150a8:	10002e1e 	bne	r2,zero,81115164 <vReceiverUartTask+0x1a4>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
811150ac:	00a04574 	movhi	r2,33045
811150b0:	1091cc04 	addi	r2,r2,18224
811150b4:	10800103 	ldbu	r2,4(r2)
811150b8:	10803fcc 	andi	r2,r2,255
811150bc:	1080201c 	xori	r2,r2,128
811150c0:	10bfe004 	addi	r2,r2,-128
811150c4:	10800fe0 	cmpeqi	r2,r2,63
811150c8:	1000081e 	bne	r2,zero,811150ec <vReceiverUartTask+0x12c>
811150cc:	00a04574 	movhi	r2,33045
811150d0:	1091cc04 	addi	r2,r2,18224
811150d4:	10800103 	ldbu	r2,4(r2)
811150d8:	10803fcc 	andi	r2,r2,255
811150dc:	1080201c 	xori	r2,r2,128
811150e0:	10bfe004 	addi	r2,r2,-128
811150e4:	10800858 	cmpnei	r2,r2,33
811150e8:	1000031e 	bne	r2,zero,811150f8 <vReceiverUartTask+0x138>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
811150ec:	00800084 	movi	r2,2
811150f0:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
811150f4:	00005106 	br	8111523c <vReceiverUartTask+0x27c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
811150f8:	00a04574 	movhi	r2,33045
811150fc:	1091cc04 	addi	r2,r2,18224
81115100:	10800103 	ldbu	r2,4(r2)
81115104:	10803fcc 	andi	r2,r2,255
81115108:	1080201c 	xori	r2,r2,128
8111510c:	10bfe004 	addi	r2,r2,-128
81115110:	108008d8 	cmpnei	r2,r2,35
81115114:	1000101e 	bne	r2,zero,81115158 <vReceiverUartTask+0x198>
                            eReaderRXMode = sGetRxUart;
81115118:	00800044 	movi	r2,1
8111511c:	e0bfad15 	stw	r2,-332(fp)
                            #if DEBUG_ON
                            if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115120:	00a045b4 	movhi	r2,33046
81115124:	109fe204 	addi	r2,r2,32648
81115128:	10800d8b 	ldhu	r2,54(r2)
8111512c:	10bfffcc 	andi	r2,r2,65535
81115130:	108000e8 	cmpgeui	r2,r2,3
81115134:	1000411e 	bne	r2,zero,8111523c <vReceiverUartTask+0x27c>
                                debug(fp,"Nack Received. Do nothing!\n");
81115138:	d0a06217 	ldw	r2,-32376(gp)
8111513c:	100f883a 	mov	r7,r2
81115140:	018006c4 	movi	r6,27
81115144:	01400044 	movi	r5,1
81115148:	01204574 	movhi	r4,33045
8111514c:	213be404 	addi	r4,r4,-4208
81115150:	1122fc80 	call	81122fc8 <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81115154:	00003906 	br	8111523c <vReceiverUartTask+0x27c>
                            if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
                                debug(fp,"Nack Received. Do nothing!\n");
                            }
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
81115158:	008000c4 	movi	r2,3
8111515c:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81115160:	00003606 	br	8111523c <vReceiverUartTask+0x27c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
81115164:	00a04574 	movhi	r2,33045
81115168:	1091cc04 	addi	r2,r2,18224
8111516c:	00c008c4 	movi	r3,35
81115170:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
81115174:	00a04574 	movhi	r2,33045
81115178:	1091cc04 	addi	r2,r2,18224
8111517c:	00c00b84 	movi	r3,46
81115180:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
81115184:	00a04574 	movhi	r2,33045
81115188:	1091cc04 	addi	r2,r2,18224
8111518c:	00c00044 	movi	r3,1
81115190:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81115194:	01204574 	movhi	r4,33045
81115198:	2111cc04 	addi	r4,r4,18224
8111519c:	11153800 	call	81115380 <setPreAckSenderFreePos>
811151a0:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
811151a4:	e0bfae17 	ldw	r2,-328(fp)
811151a8:	1000011e 	bne	r2,zero,811151b0 <vReceiverUartTask+0x1f0>
                        vFailSendNack();
811151ac:	111d2200 	call	8111d220 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
811151b0:	00800044 	movi	r2,1
811151b4:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
811151b8:	00002006 	br	8111523c <vReceiverUartTask+0x27c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
811151bc:	01204574 	movhi	r4,33045
811151c0:	2111cc04 	addi	r4,r4,18224
811151c4:	11153800 	call	81115380 <setPreAckSenderFreePos>
811151c8:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
811151cc:	e0bfae17 	ldw	r2,-328(fp)
811151d0:	10800058 	cmpnei	r2,r2,1
811151d4:	1000081e 	bne	r2,zero,811151f8 <vReceiverUartTask+0x238>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
811151d8:	01204574 	movhi	r4,33045
811151dc:	2111cc04 	addi	r4,r4,18224
811151e0:	11152440 	call	81115244 <setPreParsedFreePos>
811151e4:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
811151e8:	e0bfae17 	ldw	r2,-328(fp)
811151ec:	1000031e 	bne	r2,zero,811151fc <vReceiverUartTask+0x23c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
811151f0:	111d3200 	call	8111d320 <vFailSetPreParsedBuffer>
811151f4:	00000106 	br	811151fc <vReceiverUartTask+0x23c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
811151f8:	111d2a00 	call	8111d2a0 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
811151fc:	00800044 	movi	r2,1
81115200:	e0bfad15 	stw	r2,-332(fp)
                break;
81115204:	00000e06 	br	81115240 <vReceiverUartTask+0x280>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
81115208:	01204574 	movhi	r4,33045
8111520c:	2111cc04 	addi	r4,r4,18224
81115210:	11154fc0 	call	811154fc <setPreAckReceiverFreePos>
81115214:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
81115218:	e0bfae17 	ldw	r2,-328(fp)
8111521c:	1000011e 	bne	r2,zero,81115224 <vReceiverUartTask+0x264>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81115220:	111d3a00 	call	8111d3a0 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
81115224:	00800044 	movi	r2,1
81115228:	e0bfad15 	stw	r2,-332(fp)
                break;
8111522c:	00000406 	br	81115240 <vReceiverUartTask+0x280>
            default:
                eReaderRXMode = sGetRxUart;
81115230:	00800044 	movi	r2,1
81115234:	e0bfad15 	stw	r2,-332(fp)
                break;
81115238:	00000106 	br	81115240 <vReceiverUartTask+0x280>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8111523c:	0001883a 	nop
            default:
                eReaderRXMode = sGetRxUart;
                break;
        }

    }
81115240:	003f7506 	br	81115018 <__reset+0xfb0f5018>

81115244 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81115244:	defffb04 	addi	sp,sp,-20
81115248:	de00012e 	bgeu	sp,et,81115250 <setPreParsedFreePos+0xc>
8111524c:	003b68fa 	trap	3
81115250:	dfc00415 	stw	ra,16(sp)
81115254:	df000315 	stw	fp,12(sp)
81115258:	df000304 	addi	fp,sp,12
8111525c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81115260:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81115264:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81115268:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
8111526c:	d0a06b17 	ldw	r2,-32340(gp)
81115270:	e0fffe44 	addi	r3,fp,-7
81115274:	180d883a 	mov	r6,r3
81115278:	01400284 	movi	r5,10
8111527c:	1009883a 	mov	r4,r2
81115280:	113ddc00 	call	8113ddc0 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81115284:	e0bffe43 	ldbu	r2,-7(fp)
81115288:	10803fcc 	andi	r2,r2,255
8111528c:	1000361e 	bne	r2,zero,81115368 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81115290:	e03ffe05 	stb	zero,-8(fp)
81115294:	00002e06 	br	81115350 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
81115298:	e0fffe03 	ldbu	r3,-8(fp)
8111529c:	00a045b4 	movhi	r2,33046
811152a0:	109f3a04 	addi	r2,r2,31976
811152a4:	18c01324 	muli	r3,r3,76
811152a8:	10c5883a 	add	r2,r2,r3
811152ac:	10800104 	addi	r2,r2,4
811152b0:	10800003 	ldbu	r2,0(r2)
811152b4:	10803fcc 	andi	r2,r2,255
811152b8:	1080201c 	xori	r2,r2,128
811152bc:	10bfe004 	addi	r2,r2,-128
811152c0:	1000201e 	bne	r2,zero,81115344 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
811152c4:	e0fffe03 	ldbu	r3,-8(fp)
811152c8:	00a045b4 	movhi	r2,33046
811152cc:	109f3a04 	addi	r2,r2,31976
811152d0:	18c01324 	muli	r3,r3,76
811152d4:	10c7883a 	add	r3,r2,r3
811152d8:	e0bfff17 	ldw	r2,-4(fp)
811152dc:	1009883a 	mov	r4,r2
811152e0:	00801304 	movi	r2,76
811152e4:	100d883a 	mov	r6,r2
811152e8:	200b883a 	mov	r5,r4
811152ec:	1809883a 	mov	r4,r3
811152f0:	11239dc0 	call	811239dc <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
811152f4:	d0a06417 	ldw	r2,-32368(gp)
811152f8:	1009883a 	mov	r4,r2
811152fc:	11401540 	call	81140154 <OSSemPost>
81115300:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81115304:	e0bffe43 	ldbu	r2,-7(fp)
81115308:	10803fcc 	andi	r2,r2,255
8111530c:	1000031e 	bne	r2,zero,8111531c <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
81115310:	00800044 	movi	r2,1
81115314:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
81115318:	00001006 	br	8111535c <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
8111531c:	111c7000 	call	8111c700 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81115320:	e0fffe03 	ldbu	r3,-8(fp)
81115324:	00a045b4 	movhi	r2,33046
81115328:	109f3a04 	addi	r2,r2,31976
8111532c:	18c01324 	muli	r3,r3,76
81115330:	10c5883a 	add	r2,r2,r3
81115334:	10800104 	addi	r2,r2,4
81115338:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
8111533c:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81115340:	00000606 	br	8111535c <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81115344:	e0bffe03 	ldbu	r2,-8(fp)
81115348:	10800044 	addi	r2,r2,1
8111534c:	e0bffe05 	stb	r2,-8(fp)
81115350:	e0bffe03 	ldbu	r2,-8(fp)
81115354:	10800230 	cmpltui	r2,r2,8
81115358:	103fcf1e 	bne	r2,zero,81115298 <__reset+0xfb0f5298>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
8111535c:	d0a06b17 	ldw	r2,-32340(gp)
81115360:	1009883a 	mov	r4,r2
81115364:	113e3640 	call	8113e364 <OSMutexPost>
    }
    return bSuccess;
81115368:	e0bffd17 	ldw	r2,-12(fp)
}
8111536c:	e037883a 	mov	sp,fp
81115370:	dfc00117 	ldw	ra,4(sp)
81115374:	df000017 	ldw	fp,0(sp)
81115378:	dec00204 	addi	sp,sp,8
8111537c:	f800283a 	ret

81115380 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
81115380:	defffb04 	addi	sp,sp,-20
81115384:	de00012e 	bgeu	sp,et,8111538c <setPreAckSenderFreePos+0xc>
81115388:	003b68fa 	trap	3
8111538c:	dfc00415 	stw	ra,16(sp)
81115390:	df000315 	stw	fp,12(sp)
81115394:	df000304 	addi	fp,sp,12
81115398:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8111539c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
811153a0:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
811153a4:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
811153a8:	d0a07217 	ldw	r2,-32312(gp)
811153ac:	e0fffe44 	addi	r3,fp,-7
811153b0:	180d883a 	mov	r6,r3
811153b4:	01400284 	movi	r5,10
811153b8:	1009883a 	mov	r4,r2
811153bc:	113ddc00 	call	8113ddc0 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811153c0:	e0bffe43 	ldbu	r2,-7(fp)
811153c4:	10803fcc 	andi	r2,r2,255
811153c8:	1000461e 	bne	r2,zero,811154e4 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
811153cc:	e03ffe05 	stb	zero,-8(fp)
811153d0:	00003e06 	br	811154cc <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
811153d4:	e0fffe03 	ldbu	r3,-8(fp)
811153d8:	00a045b4 	movhi	r2,33046
811153dc:	109f3204 	addi	r2,r2,31944
811153e0:	18c7883a 	add	r3,r3,r3
811153e4:	18c7883a 	add	r3,r3,r3
811153e8:	10c5883a 	add	r2,r2,r3
811153ec:	10800003 	ldbu	r2,0(r2)
811153f0:	10803fcc 	andi	r2,r2,255
811153f4:	1080201c 	xori	r2,r2,128
811153f8:	10bfe004 	addi	r2,r2,-128
811153fc:	1000301e 	bne	r2,zero,811154c0 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
81115400:	e0fffe03 	ldbu	r3,-8(fp)
81115404:	e0bfff17 	ldw	r2,-4(fp)
81115408:	11000103 	ldbu	r4,4(r2)
8111540c:	00a045b4 	movhi	r2,33046
81115410:	109f3204 	addi	r2,r2,31944
81115414:	18c7883a 	add	r3,r3,r3
81115418:	18c7883a 	add	r3,r3,r3
8111541c:	10c5883a 	add	r2,r2,r3
81115420:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81115424:	e0fffe03 	ldbu	r3,-8(fp)
81115428:	e0bfff17 	ldw	r2,-4(fp)
8111542c:	11000143 	ldbu	r4,5(r2)
81115430:	00a045b4 	movhi	r2,33046
81115434:	109f3204 	addi	r2,r2,31944
81115438:	18c7883a 	add	r3,r3,r3
8111543c:	18c7883a 	add	r3,r3,r3
81115440:	10c5883a 	add	r2,r2,r3
81115444:	10800044 	addi	r2,r2,1
81115448:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
8111544c:	e0fffe03 	ldbu	r3,-8(fp)
81115450:	e0bfff17 	ldw	r2,-4(fp)
81115454:	1100020b 	ldhu	r4,8(r2)
81115458:	00a045b4 	movhi	r2,33046
8111545c:	109f3204 	addi	r2,r2,31944
81115460:	18c7883a 	add	r3,r3,r3
81115464:	18c7883a 	add	r3,r3,r3
81115468:	10c5883a 	add	r2,r2,r3
8111546c:	10800084 	addi	r2,r2,2
81115470:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
81115474:	d0a06117 	ldw	r2,-32380(gp)
81115478:	1009883a 	mov	r4,r2
8111547c:	11401540 	call	81140154 <OSSemPost>
81115480:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
81115484:	e0bffe43 	ldbu	r2,-7(fp)
81115488:	10803fcc 	andi	r2,r2,255
8111548c:	10000926 	beq	r2,zero,811154b4 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
81115490:	111c7c80 	call	8111c7c8 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
81115494:	e0fffe03 	ldbu	r3,-8(fp)
81115498:	00a045b4 	movhi	r2,33046
8111549c:	109f3204 	addi	r2,r2,31944
811154a0:	18c7883a 	add	r3,r3,r3
811154a4:	18c7883a 	add	r3,r3,r3
811154a8:	10c5883a 	add	r2,r2,r3
811154ac:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
811154b0:	00000906 	br	811154d8 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
811154b4:	00800044 	movi	r2,1
811154b8:	e0bffd15 	stw	r2,-12(fp)
                break;
811154bc:	00000606 	br	811154d8 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
811154c0:	e0bffe03 	ldbu	r2,-8(fp)
811154c4:	10800044 	addi	r2,r2,1
811154c8:	e0bffe05 	stb	r2,-8(fp)
811154cc:	e0bffe03 	ldbu	r2,-8(fp)
811154d0:	10800230 	cmpltui	r2,r2,8
811154d4:	103fbf1e 	bne	r2,zero,811153d4 <__reset+0xfb0f53d4>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
811154d8:	d0a07217 	ldw	r2,-32312(gp)
811154dc:	1009883a 	mov	r4,r2
811154e0:	113e3640 	call	8113e364 <OSMutexPost>
    }

    return bSuccess;
811154e4:	e0bffd17 	ldw	r2,-12(fp)
}
811154e8:	e037883a 	mov	sp,fp
811154ec:	dfc00117 	ldw	ra,4(sp)
811154f0:	df000017 	ldw	fp,0(sp)
811154f4:	dec00204 	addi	sp,sp,8
811154f8:	f800283a 	ret

811154fc <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
811154fc:	defffb04 	addi	sp,sp,-20
81115500:	de00012e 	bgeu	sp,et,81115508 <setPreAckReceiverFreePos+0xc>
81115504:	003b68fa 	trap	3
81115508:	dfc00415 	stw	ra,16(sp)
8111550c:	df000315 	stw	fp,12(sp)
81115510:	df000304 	addi	fp,sp,12
81115514:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81115518:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
8111551c:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81115520:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
81115524:	d0a06517 	ldw	r2,-32364(gp)
81115528:	e0fffe44 	addi	r3,fp,-7
8111552c:	180d883a 	mov	r6,r3
81115530:	01400504 	movi	r5,20
81115534:	1009883a 	mov	r4,r2
81115538:	113ddc00 	call	8113ddc0 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8111553c:	e0bffe43 	ldbu	r2,-7(fp)
81115540:	10803fcc 	andi	r2,r2,255
81115544:	1000471e 	bne	r2,zero,81115664 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81115548:	e03ffe05 	stb	zero,-8(fp)
8111554c:	00003e06 	br	81115648 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
81115550:	e0fffe03 	ldbu	r3,-8(fp)
81115554:	00a045b4 	movhi	r2,33046
81115558:	10892004 	addi	r2,r2,9344
8111555c:	18c7883a 	add	r3,r3,r3
81115560:	18c7883a 	add	r3,r3,r3
81115564:	10c5883a 	add	r2,r2,r3
81115568:	10800003 	ldbu	r2,0(r2)
8111556c:	10803fcc 	andi	r2,r2,255
81115570:	1080201c 	xori	r2,r2,128
81115574:	10bfe004 	addi	r2,r2,-128
81115578:	1000301e 	bne	r2,zero,8111563c <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
8111557c:	e0fffe03 	ldbu	r3,-8(fp)
81115580:	e0bfff17 	ldw	r2,-4(fp)
81115584:	11000103 	ldbu	r4,4(r2)
81115588:	00a045b4 	movhi	r2,33046
8111558c:	10892004 	addi	r2,r2,9344
81115590:	18c7883a 	add	r3,r3,r3
81115594:	18c7883a 	add	r3,r3,r3
81115598:	10c5883a 	add	r2,r2,r3
8111559c:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
811155a0:	e0fffe03 	ldbu	r3,-8(fp)
811155a4:	e0bfff17 	ldw	r2,-4(fp)
811155a8:	11000143 	ldbu	r4,5(r2)
811155ac:	00a045b4 	movhi	r2,33046
811155b0:	10892004 	addi	r2,r2,9344
811155b4:	18c7883a 	add	r3,r3,r3
811155b8:	18c7883a 	add	r3,r3,r3
811155bc:	10c5883a 	add	r2,r2,r3
811155c0:	10800044 	addi	r2,r2,1
811155c4:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
811155c8:	e0fffe03 	ldbu	r3,-8(fp)
811155cc:	e0bfff17 	ldw	r2,-4(fp)
811155d0:	1100020b 	ldhu	r4,8(r2)
811155d4:	00a045b4 	movhi	r2,33046
811155d8:	10892004 	addi	r2,r2,9344
811155dc:	18c7883a 	add	r3,r3,r3
811155e0:	18c7883a 	add	r3,r3,r3
811155e4:	10c5883a 	add	r2,r2,r3
811155e8:	10800084 	addi	r2,r2,2
811155ec:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
811155f0:	d0a06617 	ldw	r2,-32360(gp)
811155f4:	1009883a 	mov	r4,r2
811155f8:	11401540 	call	81140154 <OSSemPost>
811155fc:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81115600:	e0bffe43 	ldbu	r2,-7(fp)
81115604:	10803fcc 	andi	r2,r2,255
81115608:	1000031e 	bne	r2,zero,81115618 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
8111560c:	00800044 	movi	r2,1
81115610:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
81115614:	00000f06 	br	81115654 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
81115618:	111c7640 	call	8111c764 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
8111561c:	e0fffe03 	ldbu	r3,-8(fp)
81115620:	00a045b4 	movhi	r2,33046
81115624:	10892004 	addi	r2,r2,9344
81115628:	18c7883a 	add	r3,r3,r3
8111562c:	18c7883a 	add	r3,r3,r3
81115630:	10c5883a 	add	r2,r2,r3
81115634:	10000005 	stb	zero,0(r2)
                }
                break;
81115638:	00000606 	br	81115654 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8111563c:	e0bffe03 	ldbu	r2,-8(fp)
81115640:	10800044 	addi	r2,r2,1
81115644:	e0bffe05 	stb	r2,-8(fp)
81115648:	e0bffe03 	ldbu	r2,-8(fp)
8111564c:	108001b0 	cmpltui	r2,r2,6
81115650:	103fbf1e 	bne	r2,zero,81115550 <__reset+0xfb0f5550>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
81115654:	d0a06517 	ldw	r2,-32364(gp)
81115658:	1009883a 	mov	r4,r2
8111565c:	113e3640 	call	8113e364 <OSMutexPost>
81115660:	00000d06 	br	81115698 <setPreAckReceiverFreePos+0x19c>
    } else {
        /* Could not  */
        #if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81115664:	00a045b4 	movhi	r2,33046
81115668:	109fe204 	addi	r2,r2,32648
8111566c:	10800d8b 	ldhu	r2,54(r2)
81115670:	10bfffcc 	andi	r2,r2,65535
81115674:	10800228 	cmpgeui	r2,r2,8
81115678:	1000071e 	bne	r2,zero,81115698 <setPreAckReceiverFreePos+0x19c>
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
8111567c:	d0a06217 	ldw	r2,-32376(gp)
81115680:	100f883a 	mov	r7,r2
81115684:	01801404 	movi	r6,80
81115688:	01400044 	movi	r5,1
8111568c:	01204574 	movhi	r4,33045
81115690:	213beb04 	addi	r4,r4,-4180
81115694:	1122fc80 	call	81122fc8 <fwrite>
    	}
        #endif
    }

    return bSuccess;
81115698:	e0bffd17 	ldw	r2,-12(fp)
}
8111569c:	e037883a 	mov	sp,fp
811156a0:	dfc00117 	ldw	ra,4(sp)
811156a4:	df000017 	ldw	fp,0(sp)
811156a8:	dec00204 	addi	sp,sp,8
811156ac:	f800283a 	ret

811156b0 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
811156b0:	defff404 	addi	sp,sp,-48
811156b4:	de00012e 	bgeu	sp,et,811156bc <bPreParserV2+0xc>
811156b8:	003b68fa 	trap	3
811156bc:	dfc00b15 	stw	ra,44(sp)
811156c0:	df000a15 	stw	fp,40(sp)
811156c4:	dc000915 	stw	r16,36(sp)
811156c8:	df000a04 	addi	fp,sp,40
811156cc:	e13ffd15 	stw	r4,-12(fp)
811156d0:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
811156d4:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
811156d8:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
811156dc:	01402004 	movi	r5,128
811156e0:	e13ffd17 	ldw	r4,-12(fp)
811156e4:	11244ec0 	call	811244ec <strnlen>
811156e8:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
811156ec:	01400ec4 	movi	r5,59
811156f0:	e13ffd17 	ldw	r4,-12(fp)
811156f4:	111a2b40 	call	8111a2b4 <siPosStr>
811156f8:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
811156fc:	e0fff98f 	ldh	r3,-26(fp)
81115700:	e0bff90f 	ldh	r2,-28(fp)
81115704:	10bfffc4 	addi	r2,r2,-1
81115708:	18800226 	beq	r3,r2,81115714 <bPreParserV2+0x64>
        return bSuccess;
8111570c:	e0bff617 	ldw	r2,-40(fp)
81115710:	0000c006 	br	81115a14 <bPreParserV2+0x364>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81115714:	01401f04 	movi	r5,124
81115718:	e13ffd17 	ldw	r4,-12(fp)
8111571c:	111a2b40 	call	8111a2b4 <siPosStr>
81115720:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81115724:	e0bffa0f 	ldh	r2,-24(fp)
81115728:	e0fff98f 	ldh	r3,-26(fp)
8111572c:	1880020e 	bge	r3,r2,81115738 <bPreParserV2+0x88>
        return bSuccess;
81115730:	e0bff617 	ldw	r2,-40(fp)
81115734:	0000b706 	br	81115a14 <bPreParserV2+0x364>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81115738:	01604574 	movhi	r5,33045
8111573c:	297c0004 	addi	r5,r5,-4096
81115740:	e13ffd17 	ldw	r4,-12(fp)
81115744:	11244080 	call	81124408 <strcspn>
81115748:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
8111574c:	e0bffa8f 	ldh	r2,-22(fp)
81115750:	e0fffa0f 	ldh	r3,-24(fp)
81115754:	1880020e 	bge	r3,r2,81115760 <bPreParserV2+0xb0>
        return bSuccess;
81115758:	e0bff617 	ldw	r2,-40(fp)
8111575c:	0000ad06 	br	81115a14 <bPreParserV2+0x364>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
81115760:	e0bffa8f 	ldh	r2,-22(fp)
81115764:	e0fffd17 	ldw	r3,-12(fp)
81115768:	1885883a 	add	r2,r3,r2
8111576c:	10c00003 	ldbu	r3,0(r2)
81115770:	e0bffe17 	ldw	r2,-8(fp)
81115774:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81115778:	e0bffe17 	ldw	r2,-8(fp)
8111577c:	10800103 	ldbu	r2,4(r2)
81115780:	10803fcc 	andi	r2,r2,255
81115784:	1080201c 	xori	r2,r2,128
81115788:	10bfe004 	addi	r2,r2,-128
8111578c:	108008d8 	cmpnei	r2,r2,35
81115790:	1000041e 	bne	r2,zero,811157a4 <bPreParserV2+0xf4>
        bSuccess = TRUE;
81115794:	00800044 	movi	r2,1
81115798:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
8111579c:	e0bff617 	ldw	r2,-40(fp)
811157a0:	00009c06 	br	81115a14 <bPreParserV2+0x364>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
811157a4:	e0bffa8f 	ldh	r2,-22(fp)
811157a8:	e0fffd17 	ldw	r3,-12(fp)
811157ac:	1889883a 	add	r4,r3,r2
811157b0:	e0fffa0f 	ldh	r3,-24(fp)
811157b4:	e0bffa8f 	ldh	r2,-22(fp)
811157b8:	1885c83a 	sub	r2,r3,r2
811157bc:	100b883a 	mov	r5,r2
811157c0:	111c3300 	call	8111c330 <ucCrc8wInit>
811157c4:	1007883a 	mov	r3,r2
811157c8:	e0bffe17 	ldw	r2,-8(fp)
811157cc:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
811157d0:	e0bffa8f 	ldh	r2,-22(fp)
811157d4:	10800044 	addi	r2,r2,1
811157d8:	e0fffd17 	ldw	r3,-12(fp)
811157dc:	1885883a 	add	r2,r3,r2
811157e0:	10c00003 	ldbu	r3,0(r2)
811157e4:	e0bffe17 	ldw	r2,-8(fp)
811157e8:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
811157ec:	e0bffe17 	ldw	r2,-8(fp)
811157f0:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
811157f4:	e0bffe17 	ldw	r2,-8(fp)
811157f8:	10800204 	addi	r2,r2,8
811157fc:	01801004 	movi	r6,64
81115800:	000b883a 	mov	r5,zero
81115804:	1009883a 	mov	r4,r2
81115808:	1123b2c0 	call	81123b2c <memset>

    i = siIni + 3; /* "?C:i..." */
8111580c:	e0bffa8b 	ldhu	r2,-22(fp)
81115810:	108000c4 	addi	r2,r2,3
81115814:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81115818:	e0bffb44 	addi	r2,fp,-19
8111581c:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
81115820:	e0bffb44 	addi	r2,fp,-19
81115824:	01800184 	movi	r6,6
81115828:	000b883a 	mov	r5,zero
8111582c:	1009883a 	mov	r4,r2
81115830:	1123b2c0 	call	81123b2c <memset>
        do {
            c = buffer[i];
81115834:	e0bff703 	ldbu	r2,-36(fp)
81115838:	e0fffd17 	ldw	r3,-12(fp)
8111583c:	1885883a 	add	r2,r3,r2
81115840:	10800003 	ldbu	r2,0(r2)
81115844:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81115848:	d0e00317 	ldw	r3,-32756(gp)
8111584c:	e0bffb07 	ldb	r2,-20(fp)
81115850:	10800044 	addi	r2,r2,1
81115854:	1885883a 	add	r2,r3,r2
81115858:	10800003 	ldbu	r2,0(r2)
8111585c:	10803fcc 	andi	r2,r2,255
81115860:	1080010c 	andi	r2,r2,4
81115864:	10000626 	beq	r2,zero,81115880 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81115868:	e0bff817 	ldw	r2,-32(fp)
8111586c:	e0fffb03 	ldbu	r3,-20(fp)
81115870:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81115874:	e0bff817 	ldw	r2,-32(fp)
81115878:	10800044 	addi	r2,r2,1
8111587c:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
81115880:	e0bff703 	ldbu	r2,-36(fp)
81115884:	10800044 	addi	r2,r2,1
81115888:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
8111588c:	e0bff90f 	ldh	r2,-28(fp)
81115890:	e0fff703 	ldbu	r3,-36(fp)
81115894:	1880090e 	bge	r3,r2,811158bc <bPreParserV2+0x20c>
81115898:	e0bffb07 	ldb	r2,-20(fp)
8111589c:	10800ea0 	cmpeqi	r2,r2,58
811158a0:	1000061e 	bne	r2,zero,811158bc <bPreParserV2+0x20c>
811158a4:	e0bffb07 	ldb	r2,-20(fp)
811158a8:	10800ee0 	cmpeqi	r2,r2,59
811158ac:	1000031e 	bne	r2,zero,811158bc <bPreParserV2+0x20c>
811158b0:	e0bffb07 	ldb	r2,-20(fp)
811158b4:	10801f18 	cmpnei	r2,r2,124
811158b8:	103fde1e 	bne	r2,zero,81115834 <__reset+0xfb0f5834>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811158bc:	e0bff817 	ldw	r2,-32(fp)
811158c0:	00c00284 	movi	r3,10
811158c4:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
811158c8:	e0bffb07 	ldb	r2,-20(fp)
811158cc:	10800ea0 	cmpeqi	r2,r2,58
811158d0:	1000031e 	bne	r2,zero,811158e0 <bPreParserV2+0x230>
811158d4:	e0bffb07 	ldb	r2,-20(fp)
811158d8:	10801f18 	cmpnei	r2,r2,124
811158dc:	10001a1e 	bne	r2,zero,81115948 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
811158e0:	e0bffe17 	ldw	r2,-8(fp)
811158e4:	10800183 	ldbu	r2,6(r2)
811158e8:	10803fcc 	andi	r2,r2,255
811158ec:	10800828 	cmpgeui	r2,r2,32
811158f0:	1000041e 	bne	r2,zero,81115904 <bPreParserV2+0x254>
811158f4:	e0bffe17 	ldw	r2,-8(fp)
811158f8:	10800183 	ldbu	r2,6(r2)
811158fc:	14003fcc 	andi	r16,r2,255
81115900:	00000106 	br	81115908 <bPreParserV2+0x258>
81115904:	04000804 	movi	r16,32
81115908:	e0bffb44 	addi	r2,fp,-19
8111590c:	1009883a 	mov	r4,r2
81115910:	11227d00 	call	811227d0 <atoi>
81115914:	1009883a 	mov	r4,r2
81115918:	e0fffe17 	ldw	r3,-8(fp)
8111591c:	80800104 	addi	r2,r16,4
81115920:	1085883a 	add	r2,r2,r2
81115924:	1885883a 	add	r2,r3,r2
81115928:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
8111592c:	e0bffe17 	ldw	r2,-8(fp)
81115930:	10800183 	ldbu	r2,6(r2)
81115934:	10800044 	addi	r2,r2,1
81115938:	1007883a 	mov	r3,r2
8111593c:	e0bffe17 	ldw	r2,-8(fp)
81115940:	10c00185 	stb	r3,6(r2)
81115944:	00000906 	br	8111596c <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
81115948:	e0bffb07 	ldb	r2,-20(fp)
8111594c:	10800ed8 	cmpnei	r2,r2,59
81115950:	1000061e 	bne	r2,zero,8111596c <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
81115954:	e0bffb44 	addi	r2,fp,-19
81115958:	1009883a 	mov	r4,r2
8111595c:	11227d00 	call	811227d0 <atoi>
81115960:	1007883a 	mov	r3,r2
81115964:	e0bffe17 	ldw	r2,-8(fp)
81115968:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
8111596c:	e0bffb07 	ldb	r2,-20(fp)
81115970:	10800ee0 	cmpeqi	r2,r2,59
81115974:	1000031e 	bne	r2,zero,81115984 <bPreParserV2+0x2d4>
81115978:	e0bff90f 	ldh	r2,-28(fp)
8111597c:	e0fff703 	ldbu	r3,-36(fp)
81115980:	18bfa516 	blt	r3,r2,81115818 <__reset+0xfb0f5818>


    if ( c == FINAL_CHAR )
81115984:	e0bffb07 	ldb	r2,-20(fp)
81115988:	10800ed8 	cmpnei	r2,r2,59
8111598c:	10001f1e 	bne	r2,zero,81115a0c <bPreParserV2+0x35c>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
81115990:	e0bffe17 	ldw	r2,-8(fp)
81115994:	10c01243 	ldbu	r3,73(r2)
81115998:	e0bffe17 	ldw	r2,-8(fp)
8111599c:	10801203 	ldbu	r2,72(r2)
811159a0:	18c03fcc 	andi	r3,r3,255
811159a4:	10803fcc 	andi	r2,r2,255
811159a8:	1880031e 	bne	r3,r2,811159b8 <bPreParserV2+0x308>
            bSuccess = TRUE;
811159ac:	00800044 	movi	r2,1
811159b0:	e0bff615 	stw	r2,-40(fp)
811159b4:	00001606 	br	81115a10 <bPreParserV2+0x360>
        } else {
            /* Wrong CRC */
            #if DEBUG_ON
        	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811159b8:	00a045b4 	movhi	r2,33046
811159bc:	109fe204 	addi	r2,r2,32648
811159c0:	10800d8b 	ldhu	r2,54(r2)
811159c4:	10bfffcc 	andi	r2,r2,65535
811159c8:	10800228 	cmpgeui	r2,r2,8
811159cc:	10000d1e 	bne	r2,zero,81115a04 <bPreParserV2+0x354>
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
811159d0:	d0e06217 	ldw	r3,-32376(gp)
811159d4:	e0bffe17 	ldw	r2,-8(fp)
811159d8:	10801203 	ldbu	r2,72(r2)
811159dc:	11003fcc 	andi	r4,r2,255
811159e0:	e0bffe17 	ldw	r2,-8(fp)
811159e4:	10801243 	ldbu	r2,73(r2)
811159e8:	10803fcc 	andi	r2,r2,255
811159ec:	100f883a 	mov	r7,r2
811159f0:	200d883a 	mov	r6,r4
811159f4:	01604574 	movhi	r5,33045
811159f8:	297c0204 	addi	r5,r5,-4088
811159fc:	1809883a 	mov	r4,r3
81115a00:	112292c0 	call	8112292c <fprintf>
        	}
            #endif
            bSuccess = FALSE;
81115a04:	e03ff615 	stw	zero,-40(fp)
81115a08:	00000106 	br	81115a10 <bPreParserV2+0x360>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
81115a0c:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
81115a10:	e0bff617 	ldw	r2,-40(fp)
}
81115a14:	e6ffff04 	addi	sp,fp,-4
81115a18:	dfc00217 	ldw	ra,8(sp)
81115a1c:	df000117 	ldw	fp,4(sp)
81115a20:	dc000017 	ldw	r16,0(sp)
81115a24:	dec00304 	addi	sp,sp,12
81115a28:	f800283a 	ret

81115a2c <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81115a2c:	defffb04 	addi	sp,sp,-20
81115a30:	de00012e 	bgeu	sp,et,81115a38 <vSenderComTask+0xc>
81115a34:	003b68fa 	trap	3
81115a38:	dfc00415 	stw	ra,16(sp)
81115a3c:	df000315 	stw	fp,12(sp)
81115a40:	df000304 	addi	fp,sp,12
81115a44:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
81115a48:	e03ffd15 	stw	zero,-12(fp)

    #if DEBUG_ON
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81115a4c:	00a045b4 	movhi	r2,33046
81115a50:	109fe204 	addi	r2,r2,32648
81115a54:	10800d8b 	ldhu	r2,54(r2)
81115a58:	10bfffcc 	andi	r2,r2,65535
81115a5c:	10800168 	cmpgeui	r2,r2,5
81115a60:	1000071e 	bne	r2,zero,81115a80 <vSenderComTask+0x54>
        debug(fp,"Sender Comm Task. (Task on)\n");
81115a64:	d0a06217 	ldw	r2,-32376(gp)
81115a68:	100f883a 	mov	r7,r2
81115a6c:	01800704 	movi	r6,28
81115a70:	01400044 	movi	r5,1
81115a74:	01204574 	movhi	r4,33045
81115a78:	213c0e04 	addi	r4,r4,-4040
81115a7c:	1122fc80 	call	81122fc8 <fwrite>
    }
    #endif

    for (;;){
        
        switch (eSenderMode)
81115a80:	e0bffd17 	ldw	r2,-12(fp)
81115a84:	10c00060 	cmpeqi	r3,r2,1
81115a88:	1800091e 	bne	r3,zero,81115ab0 <vSenderComTask+0x84>
81115a8c:	0080052e 	bgeu	zero,r2,81115aa4 <vSenderComTask+0x78>
81115a90:	10c000a0 	cmpeqi	r3,r2,2
81115a94:	1800651e 	bne	r3,zero,81115c2c <vSenderComTask+0x200>
81115a98:	10800160 	cmpeqi	r2,r2,5
81115a9c:	10003e1e 	bne	r2,zero,81115b98 <vSenderComTask+0x16c>
81115aa0:	00005206 	br	81115bec <vSenderComTask+0x1c0>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
81115aa4:	00800044 	movi	r2,1
81115aa8:	e0bffd15 	stw	r2,-12(fp)
                break;
81115aac:	00006206 	br	81115c38 <vSenderComTask+0x20c>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #if DEBUG_ON
            	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115ab0:	00a045b4 	movhi	r2,33046
81115ab4:	109fe204 	addi	r2,r2,32648
81115ab8:	10800d8b 	ldhu	r2,54(r2)
81115abc:	10bfffcc 	andi	r2,r2,65535
81115ac0:	108000e8 	cmpgeui	r2,r2,3
81115ac4:	1000071e 	bne	r2,zero,81115ae4 <vSenderComTask+0xb8>
                    debug(fp,"Preparing the Start Sequence.\n");
81115ac8:	d0a06217 	ldw	r2,-32376(gp)
81115acc:	100f883a 	mov	r7,r2
81115ad0:	01800784 	movi	r6,30
81115ad4:	01400044 	movi	r5,1
81115ad8:	01204574 	movhi	r4,33045
81115adc:	213c1604 	addi	r4,r4,-4008
81115ae0:	1122fc80 	call	81122fc8 <fwrite>
            	}
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
81115ae4:	01400044 	movi	r5,1
81115ae8:	01204574 	movhi	r4,33045
81115aec:	213c1e04 	addi	r4,r4,-3976
81115af0:	111997c0 	call	8111997c <bSendUART32v2>
81115af4:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
81115af8:	e0bffe17 	ldw	r2,-8(fp)
81115afc:	10800058 	cmpnei	r2,r2,1
81115b00:	1000101e 	bne	r2,zero,81115b44 <vSenderComTask+0x118>
                    eSenderMode = sDummySender;
81115b04:	00800144 	movi	r2,5
81115b08:	e0bffd15 	stw	r2,-12(fp)
                    #if DEBUG_ON
                    if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115b0c:	00a045b4 	movhi	r2,33046
81115b10:	109fe204 	addi	r2,r2,32648
81115b14:	10800d8b 	ldhu	r2,54(r2)
81115b18:	10bfffcc 	andi	r2,r2,65535
81115b1c:	108000e8 	cmpgeui	r2,r2,3
81115b20:	1000441e 	bne	r2,zero,81115c34 <vSenderComTask+0x208>
                        debug(fp,"Success, start message in the retransmission buffer.\n");
81115b24:	d0a06217 	ldw	r2,-32376(gp)
81115b28:	100f883a 	mov	r7,r2
81115b2c:	01800d44 	movi	r6,53
81115b30:	01400044 	movi	r5,1
81115b34:	01204574 	movhi	r4,33045
81115b38:	213c2104 	addi	r4,r4,-3964
81115b3c:	1122fc80 	call	81122fc8 <fwrite>
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81115b40:	00003c06 	br	81115c34 <vSenderComTask+0x208>
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    }
                    #endif                    
                } else {
                    #if DEBUG_ON
                	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115b44:	00a045b4 	movhi	r2,33046
81115b48:	109fe204 	addi	r2,r2,32648
81115b4c:	10800d8b 	ldhu	r2,54(r2)
81115b50:	10bfffcc 	andi	r2,r2,65535
81115b54:	108000e8 	cmpgeui	r2,r2,3
81115b58:	1000071e 	bne	r2,zero,81115b78 <vSenderComTask+0x14c>
                        debug(fp,"Fail, try again in 5 seconds.\n");
81115b5c:	d0a06217 	ldw	r2,-32376(gp)
81115b60:	100f883a 	mov	r7,r2
81115b64:	01800784 	movi	r6,30
81115b68:	01400044 	movi	r5,1
81115b6c:	01204574 	movhi	r4,33045
81115b70:	213c2f04 	addi	r4,r4,-3908
81115b74:	1122fc80 	call	81122fc8 <fwrite>
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
81115b78:	00800044 	movi	r2,1
81115b7c:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
81115b80:	000f883a 	mov	r7,zero
81115b84:	01800144 	movi	r6,5
81115b88:	000b883a 	mov	r5,zero
81115b8c:	0009883a 	mov	r4,zero
81115b90:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
                }
                break;
81115b94:	00002706 	br	81115c34 <vSenderComTask+0x208>
            case sReadingQueue:

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
81115b98:	00800144 	movi	r2,5
81115b9c:	e0bffd15 	stw	r2,-12(fp)

                #if DEBUG_ON
                if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81115ba0:	00a045b4 	movhi	r2,33046
81115ba4:	109fe204 	addi	r2,r2,32648
81115ba8:	10800d8b 	ldhu	r2,54(r2)
81115bac:	10bfffcc 	andi	r2,r2,65535
81115bb0:	108000e8 	cmpgeui	r2,r2,3
81115bb4:	1000071e 	bne	r2,zero,81115bd4 <vSenderComTask+0x1a8>
                    debug(fp,"Working...\n");
81115bb8:	d0a06217 	ldw	r2,-32376(gp)
81115bbc:	100f883a 	mov	r7,r2
81115bc0:	018002c4 	movi	r6,11
81115bc4:	01400044 	movi	r5,1
81115bc8:	01204574 	movhi	r4,33045
81115bcc:	213c3704 	addi	r4,r4,-3876
81115bd0:	1122fc80 	call	81122fc8 <fwrite>
                }
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
81115bd4:	000f883a 	mov	r7,zero
81115bd8:	01800644 	movi	r6,25
81115bdc:	000b883a 	mov	r5,zero
81115be0:	0009883a 	mov	r4,zero
81115be4:	1141d640 	call	81141d64 <OSTimeDlyHMSM>

                break;
81115be8:	00001306 	br	81115c38 <vSenderComTask+0x20c>
            default:
                #if DEBUG_ON
            	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81115bec:	00a045b4 	movhi	r2,33046
81115bf0:	109fe204 	addi	r2,r2,32648
81115bf4:	10800d8b 	ldhu	r2,54(r2)
81115bf8:	10bfffcc 	andi	r2,r2,65535
81115bfc:	10800228 	cmpgeui	r2,r2,8
81115c00:	1000071e 	bne	r2,zero,81115c20 <vSenderComTask+0x1f4>
                    debug(fp,"Sender default\n");
81115c04:	d0a06217 	ldw	r2,-32376(gp)
81115c08:	100f883a 	mov	r7,r2
81115c0c:	018003c4 	movi	r6,15
81115c10:	01400044 	movi	r5,1
81115c14:	01204574 	movhi	r4,33045
81115c18:	213c3a04 	addi	r4,r4,-3864
81115c1c:	1122fc80 	call	81122fc8 <fwrite>
            	}
                #endif
                eSenderMode = sDummySender;
81115c20:	00800144 	movi	r2,5
81115c24:	e0bffd15 	stw	r2,-12(fp)
                break;
81115c28:	00000306 	br	81115c38 <vSenderComTask+0x20c>
                break;


            case sReadingQueue:

                break;
81115c2c:	0001883a 	nop
81115c30:	003f9306 	br	81115a80 <__reset+0xfb0f5a80>
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81115c34:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81115c38:	003f9106 	br	81115a80 <__reset+0xfb0f5a80>

81115c3c <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
81115c3c:	defff804 	addi	sp,sp,-32
81115c40:	de00012e 	bgeu	sp,et,81115c48 <vSimMebTask+0xc>
81115c44:	003b68fa 	trap	3
81115c48:	dfc00715 	stw	ra,28(sp)
81115c4c:	df000615 	stw	fp,24(sp)
81115c50:	df000604 	addi	fp,sp,24
81115c54:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	tQMask uiCmdMeb;
	INT8U error_code;
	INT8U ucFrameNumber;

	pxMebC = (TSimucam_MEB *) task_data;
81115c58:	e0bfff17 	ldw	r2,-4(fp)
81115c5c:	e0bffb15 	stw	r2,-20(fp)

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81115c60:	00a045b4 	movhi	r2,33046
81115c64:	109fe204 	addi	r2,r2,32648
81115c68:	10800d8b 	ldhu	r2,54(r2)
81115c6c:	10bfffcc 	andi	r2,r2,65535
81115c70:	10800168 	cmpgeui	r2,r2,5
81115c74:	1000071e 	bne	r2,zero,81115c94 <vSimMebTask+0x58>
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
81115c78:	d0a06217 	ldw	r2,-32376(gp)
81115c7c:	100f883a 	mov	r7,r2
81115c80:	018008c4 	movi	r6,35
81115c84:	01400044 	movi	r5,1
81115c88:	01204574 	movhi	r4,33045
81115c8c:	213c3e04 	addi	r4,r4,-3848
81115c90:	1122fc80 	call	81122fc8 <fwrite>
	}
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
81115c94:	e0bffb17 	ldw	r2,-20(fp)
81115c98:	10800117 	ldw	r2,4(r2)
81115c9c:	10c00168 	cmpgeui	r3,r2,5
81115ca0:	1801301e 	bne	r3,zero,81116164 <vSimMebTask+0x528>
81115ca4:	100690ba 	slli	r3,r2,2
81115ca8:	00a04474 	movhi	r2,33041
81115cac:	10972f04 	addi	r2,r2,23740
81115cb0:	1885883a 	add	r2,r3,r2
81115cb4:	10800017 	ldw	r2,0(r2)
81115cb8:	1000683a 	jmp	r2
81115cbc:	81115cd0 	cmplti	r4,r16,17779
81115cc0:	81115ce8 	cmpgeui	r4,r16,17779
81115cc4:	81115d80 	call	881115d8 <__reset+0x20f15d8>
81115cc8:	81115e64 	muli	r4,r16,17785
81115ccc:	81115f90 	cmplti	r4,r16,17790
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
81115cd0:	e13ffb17 	ldw	r4,-20(fp)
81115cd4:	11170c00 	call	811170c0 <vMebInit>
				pxMebC->eMode = sMebToConfig;
81115cd8:	e0bffb17 	ldw	r2,-20(fp)
81115cdc:	00c00044 	movi	r3,1
81115ce0:	10c00115 	stw	r3,4(r2)
				break;
81115ce4:	00013306 	br	811161b4 <vSimMebTask+0x578>


			case sMebToConfig:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81115ce8:	00a045b4 	movhi	r2,33046
81115cec:	109fe204 	addi	r2,r2,32648
81115cf0:	10800d8b 	ldhu	r2,54(r2)
81115cf4:	10bfffcc 	andi	r2,r2,65535
81115cf8:	10800168 	cmpgeui	r2,r2,5
81115cfc:	1000071e 	bne	r2,zero,81115d1c <vSimMebTask+0xe0>
					debug(fp,"MEB Task: Config Mode\n");
81115d00:	d0a06217 	ldw	r2,-32376(gp)
81115d04:	100f883a 	mov	r7,r2
81115d08:	01800584 	movi	r6,22
81115d0c:	01400044 	movi	r5,1
81115d10:	01204574 	movhi	r4,33045
81115d14:	213c4704 	addi	r4,r4,-3812
81115d18:	1122fc80 	call	81122fc8 <fwrite>
				}
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
81115d1c:	112020c0 	call	8112020c <bStopSync>
				vSyncClearCounter();
81115d20:	110cae00 	call	8110cae0 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
81115d24:	11171c80 	call	811171c8 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
81115d28:	01c00284 	movi	r7,10
81115d2c:	000d883a 	mov	r6,zero
81115d30:	000b883a 	mov	r5,zero
81115d34:	0009883a 	mov	r4,zero
81115d38:	1141d640 	call	81141d64 <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
81115d3c:	000d883a 	mov	r6,zero
81115d40:	000b883a 	mov	r5,zero
81115d44:	01002844 	movi	r4,161
81115d48:	1116e940 	call	81116e94 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
81115d4c:	000d883a 	mov	r6,zero
81115d50:	000b883a 	mov	r5,zero
81115d54:	01002844 	movi	r4,161
81115d58:	11170380 	call	81117038 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
81115d5c:	01c03e84 	movi	r7,250
81115d60:	000d883a 	mov	r6,zero
81115d64:	000b883a 	mov	r5,zero
81115d68:	0009883a 	mov	r4,zero
81115d6c:	1141d640 	call	81141d64 <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
81115d70:	e0bffb17 	ldw	r2,-20(fp)
81115d74:	00c000c4 	movi	r3,3
81115d78:	10c00115 	stw	r3,4(r2)
				break;
81115d7c:	00010d06 	br	811161b4 <vSimMebTask+0x578>


			case sMebToRun:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81115d80:	00a045b4 	movhi	r2,33046
81115d84:	109fe204 	addi	r2,r2,32648
81115d88:	10800d8b 	ldhu	r2,54(r2)
81115d8c:	10bfffcc 	andi	r2,r2,65535
81115d90:	10800168 	cmpgeui	r2,r2,5
81115d94:	1000071e 	bne	r2,zero,81115db4 <vSimMebTask+0x178>
					debug(fp,"MEB Task: Run Mode\n");
81115d98:	d0a06217 	ldw	r2,-32376(gp)
81115d9c:	100f883a 	mov	r7,r2
81115da0:	018004c4 	movi	r6,19
81115da4:	01400044 	movi	r5,1
81115da8:	01204574 	movhi	r4,33045
81115dac:	213c4d04 	addi	r4,r4,-3788
81115db0:	1122fc80 	call	81122fc8 <fwrite>
				}
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
81115db4:	000d883a 	mov	r6,zero
81115db8:	000b883a 	mov	r5,zero
81115dbc:	01002884 	movi	r4,162
81115dc0:	1116e940 	call	81116e94 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
81115dc4:	000d883a 	mov	r6,zero
81115dc8:	000b883a 	mov	r5,zero
81115dcc:	01002884 	movi	r4,162
81115dd0:	11170380 	call	81117038 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
81115dd4:	e0bffb17 	ldw	r2,-20(fp)
81115dd8:	1080050b 	ldhu	r2,20(r2)
81115ddc:	10bfffcc 	andi	r2,r2,65535
81115de0:	100f883a 	mov	r7,r2
81115de4:	000d883a 	mov	r6,zero
81115de8:	000b883a 	mov	r5,zero
81115dec:	0009883a 	mov	r4,zero
81115df0:	1141d640 	call	81141d64 <OSTimeDlyHMSM>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81115df4:	e03ffa05 	stb	zero,-24(fp)
81115df8:	00001006 	br	81115e3c <vSimMebTask+0x200>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
81115dfc:	e0bffa03 	ldbu	r2,-24(fp)
81115e00:	10809624 	muli	r2,r2,600
81115e04:	10809b04 	addi	r2,r2,620
81115e08:	e0fffb17 	ldw	r3,-20(fp)
81115e0c:	1885883a 	add	r2,r3,r2
81115e10:	1009883a 	mov	r4,r2
81115e14:	110a5300 	call	8110a530 <bSpwcClearTimecode>
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
81115e18:	e0bffa03 	ldbu	r2,-24(fp)
81115e1c:	e0fffb17 	ldw	r3,-20(fp)
81115e20:	10809624 	muli	r2,r2,600
81115e24:	1885883a 	add	r2,r3,r2
81115e28:	10803c04 	addi	r2,r2,240
81115e2c:	10000005 	stb	zero,0(r2)
				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81115e30:	e0bffa03 	ldbu	r2,-24(fp)
81115e34:	10800044 	addi	r2,r2,1
81115e38:	e0bffa05 	stb	r2,-24(fp)
81115e3c:	e0bffa03 	ldbu	r2,-24(fp)
81115e40:	103fee26 	beq	r2,zero,81115dfc <__reset+0xfb0f5dfc>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
				}

				bSyncCtrReset();
81115e44:	110d1300 	call	8110d130 <bSyncCtrReset>
				vSyncClearCounter();
81115e48:	110cae00 	call	8110cae0 <vSyncClearCounter>
				bStartSync();
81115e4c:	11201d00 	call	811201d0 <bStartSync>

				vEvtChangeMebMode();
81115e50:	111ebac0 	call	8111ebac <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
81115e54:	e0bffb17 	ldw	r2,-20(fp)
81115e58:	00c00104 	movi	r3,4
81115e5c:	10c00115 	stw	r3,4(r2)
				break;
81115e60:	0000d406 	br	811161b4 <vSimMebTask+0x578>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81115e64:	d0a06917 	ldw	r2,-32348(gp)
81115e68:	e0fffe04 	addi	r3,fp,-8
81115e6c:	180d883a 	mov	r6,r3
81115e70:	000b883a 	mov	r5,zero
81115e74:	1009883a 	mov	r4,r2
81115e78:	113eed40 	call	8113eed4 <OSQPend>
81115e7c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81115e80:	e0bffe03 	ldbu	r2,-8(fp)
81115e84:	10803fcc 	andi	r2,r2,255
81115e88:	10003b1e 	bne	r2,zero,81115f78 <vSimMebTask+0x33c>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81115e8c:	e0bffdc3 	ldbu	r2,-9(fp)
81115e90:	10803fcc 	andi	r2,r2,255
81115e94:	10800058 	cmpnei	r2,r2,1
81115e98:	1000281e 	bne	r2,zero,81115f3c <vSimMebTask+0x300>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
81115e9c:	e0bffd83 	ldbu	r2,-10(fp)
81115ea0:	10803fcc 	andi	r2,r2,255
81115ea4:	10c00060 	cmpeqi	r3,r2,1
81115ea8:	1800031e 	bne	r3,zero,81115eb8 <vSimMebTask+0x27c>
81115eac:	10803820 	cmpeqi	r2,r2,224
81115eb0:	1000041e 	bne	r2,zero,81115ec4 <vSimMebTask+0x288>
81115eb4:	00001106 	br	81115efc <vSimMebTask+0x2c0>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81115eb8:	e13ffb17 	ldw	r4,-20(fp)
81115ebc:	11161b80 	call	811161b8 <vPusMebTask>
								break;
81115ec0:	00003206 	br	81115f8c <vSimMebTask+0x350>
							case M_MASTER_SYNC:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81115ec4:	00a045b4 	movhi	r2,33046
81115ec8:	109fe204 	addi	r2,r2,32648
81115ecc:	10800d8b 	ldhu	r2,54(r2)
81115ed0:	10bfffcc 	andi	r2,r2,65535
81115ed4:	10800228 	cmpgeui	r2,r2,8
81115ed8:	1000291e 	bne	r2,zero,81115f80 <vSimMebTask+0x344>
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
81115edc:	d0a06217 	ldw	r2,-32376(gp)
81115ee0:	100f883a 	mov	r7,r2
81115ee4:	018012c4 	movi	r6,75
81115ee8:	01400044 	movi	r5,1
81115eec:	01204574 	movhi	r4,33045
81115ef0:	213c5204 	addi	r4,r4,-3768
81115ef4:	1122fc80 	call	81122fc8 <fwrite>
								}
								#endif
								break;
81115ef8:	00002106 	br	81115f80 <vSimMebTask+0x344>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81115efc:	00a045b4 	movhi	r2,33046
81115f00:	109fe204 	addi	r2,r2,32648
81115f04:	10800d8b 	ldhu	r2,54(r2)
81115f08:	10bfffcc 	andi	r2,r2,65535
81115f0c:	10800228 	cmpgeui	r2,r2,8
81115f10:	10001d1e 	bne	r2,zero,81115f88 <vSimMebTask+0x34c>
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
81115f14:	d0a06217 	ldw	r2,-32376(gp)
81115f18:	e0fffd83 	ldbu	r3,-10(fp)
81115f1c:	18c03fcc 	andi	r3,r3,255
81115f20:	180d883a 	mov	r6,r3
81115f24:	01604574 	movhi	r5,33045
81115f28:	297c6504 	addi	r5,r5,-3692
81115f2c:	1009883a 	mov	r4,r2
81115f30:	112292c0 	call	8112292c <fprintf>
								}
								#endif
								break;
81115f34:	0001883a 	nop
81115f38:	00001306 	br	81115f88 <vSimMebTask+0x34c>
						}
					} else {
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81115f3c:	00a045b4 	movhi	r2,33046
81115f40:	109fe204 	addi	r2,r2,32648
81115f44:	10800d8b 	ldhu	r2,54(r2)
81115f48:	10bfffcc 	andi	r2,r2,65535
81115f4c:	10800228 	cmpgeui	r2,r2,8
81115f50:	1000951e 	bne	r2,zero,811161a8 <vSimMebTask+0x56c>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81115f54:	d0a06217 	ldw	r2,-32376(gp)
81115f58:	e0fffdc3 	ldbu	r3,-9(fp)
81115f5c:	18c03fcc 	andi	r3,r3,255
81115f60:	180d883a 	mov	r6,r3
81115f64:	01604574 	movhi	r5,33045
81115f68:	297c7704 	addi	r5,r5,-3620
81115f6c:	1009883a 	mov	r4,r2
81115f70:	112292c0 	call	8112292c <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81115f74:	00008c06 	br	811161a8 <vSimMebTask+0x56c>
						}
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81115f78:	111e3840 	call	8111e384 <vCouldNotGetCmdQueueMeb>
				}

				break;
81115f7c:	00008a06 	br	811161a8 <vSimMebTask+0x56c>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
								}
								#endif
								break;
81115f80:	0001883a 	nop
81115f84:	00008806 	br	811161a8 <vSimMebTask+0x56c>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
								}
								#endif
								break;
81115f88:	0001883a 	nop
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81115f8c:	00008606 	br	811161a8 <vSimMebTask+0x56c>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81115f90:	d0a06917 	ldw	r2,-32348(gp)
81115f94:	e0fffe04 	addi	r3,fp,-8
81115f98:	180d883a 	mov	r6,r3
81115f9c:	000b883a 	mov	r5,zero
81115fa0:	1009883a 	mov	r4,r2
81115fa4:	113eed40 	call	8113eed4 <OSQPend>
81115fa8:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81115fac:	e0bffe03 	ldbu	r2,-8(fp)
81115fb0:	10803fcc 	andi	r2,r2,255
81115fb4:	1000651e 	bne	r2,zero,8111614c <vSimMebTask+0x510>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81115fb8:	e0bffdc3 	ldbu	r2,-9(fp)
81115fbc:	10803fcc 	andi	r2,r2,255
81115fc0:	10800058 	cmpnei	r2,r2,1
81115fc4:	1000521e 	bne	r2,zero,81116110 <vSimMebTask+0x4d4>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81115fc8:	e0bffd83 	ldbu	r2,-10(fp)
81115fcc:	10803fcc 	andi	r2,r2,255
81115fd0:	10c03820 	cmpeqi	r3,r2,224
81115fd4:	1800071e 	bne	r3,zero,81115ff4 <vSimMebTask+0x3b8>
81115fd8:	10c03860 	cmpeqi	r3,r2,225
81115fdc:	1800071e 	bne	r3,zero,81115ffc <vSimMebTask+0x3c0>
81115fe0:	10800060 	cmpeqi	r2,r2,1
81115fe4:	10003a26 	beq	r2,zero,811160d0 <vSimMebTask+0x494>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81115fe8:	e13ffb17 	ldw	r4,-20(fp)
81115fec:	11161b80 	call	811161b8 <vPusMebTask>
								break;
81115ff0:	00005b06 	br	81116160 <vSimMebTask+0x524>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
81115ff4:	e13ffb17 	ldw	r4,-20(fp)
81115ff8:	11171240 	call	81117124 <vSwapMemmory>
							case M_SYNC:
								#if DEBUG_ON

								if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81115ffc:	00a045b4 	movhi	r2,33046
81116000:	109fe204 	addi	r2,r2,32648
81116004:	10800d8b 	ldhu	r2,54(r2)
81116008:	10bfffcc 	andi	r2,r2,65535
8111600c:	10800168 	cmpgeui	r2,r2,5
81116010:	1000501e 	bne	r2,zero,81116154 <vSimMebTask+0x518>
									fprintf(fp,"\n\nSync\n");
81116014:	d0a06217 	ldw	r2,-32376(gp)
81116018:	100f883a 	mov	r7,r2
8111601c:	018001c4 	movi	r6,7
81116020:	01400044 	movi	r5,1
81116024:	01204574 	movhi	r4,33045
81116028:	213c8504 	addi	r4,r4,-3564
8111602c:	1122fc80 	call	81122fc8 <fwrite>
									if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116030:	00a045b4 	movhi	r2,33046
81116034:	109fe204 	addi	r2,r2,32648
81116038:	10800d8b 	ldhu	r2,54(r2)
8111603c:	10bfffcc 	andi	r2,r2,65535
81116040:	108000e8 	cmpgeui	r2,r2,3
81116044:	1000431e 	bne	r2,zero,81116154 <vSimMebTask+0x518>
										bSpwcGetTimecode(&pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire);
81116048:	e0bffb17 	ldw	r2,-20(fp)
8111604c:	10809b04 	addi	r2,r2,620
81116050:	1009883a 	mov	r4,r2
81116054:	110a4a00 	call	8110a4a0 <bSpwcGetTimecode>
										tCode = ( pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire.xTimecode.ucCounter);
81116058:	e0bffb17 	ldw	r2,-20(fp)
8111605c:	1080a743 	ldbu	r2,669(r2)
81116060:	e0bffc05 	stb	r2,-16(fp)
										tCodeNext = ( tCode ) % 4;
81116064:	e0bffc03 	ldbu	r2,-16(fp)
81116068:	108000cc 	andi	r2,r2,3
8111606c:	e0bffc45 	stb	r2,-15(fp)
										fprintf(fp,"TC: %hhu ( %hhu )\n ", tCode, tCodeNext);
81116070:	d0a06217 	ldw	r2,-32376(gp)
81116074:	e0fffc03 	ldbu	r3,-16(fp)
81116078:	e13ffc43 	ldbu	r4,-15(fp)
8111607c:	200f883a 	mov	r7,r4
81116080:	180d883a 	mov	r6,r3
81116084:	01604574 	movhi	r5,33045
81116088:	297c8704 	addi	r5,r5,-3556
8111608c:	1009883a 	mov	r4,r2
81116090:	112292c0 	call	8112292c <fprintf>
										bRmapGetMemConfigArea(&pxMebC->xFeeControl.xNfee[0].xChannel.xRmap);
81116094:	e0bffb17 	ldw	r2,-20(fp)
81116098:	10805504 	addi	r2,r2,340
8111609c:	1009883a 	mov	r4,r2
811160a0:	11080940 	call	81108094 <bRmapGetMemConfigArea>
										ucFrameNumber = pxMebC->xFeeControl.xNfee[0].xChannel.xRmap.xRmapMemConfigArea.uliFrameNumber;
811160a4:	e0bffb17 	ldw	r2,-20(fp)
811160a8:	10807717 	ldw	r2,476(r2)
811160ac:	e0bffc85 	stb	r2,-14(fp)
										fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
811160b0:	d0a06217 	ldw	r2,-32376(gp)
811160b4:	e0fffc83 	ldbu	r3,-14(fp)
811160b8:	180d883a 	mov	r6,r3
811160bc:	01604574 	movhi	r5,33045
811160c0:	297c8c04 	addi	r5,r5,-3536
811160c4:	1009883a 	mov	r4,r2
811160c8:	112292c0 	call	8112292c <fprintf>
									}
								}
								#endif

								break;
811160cc:	00002106 	br	81116154 <vSimMebTask+0x518>
							default:
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811160d0:	00a045b4 	movhi	r2,33046
811160d4:	109fe204 	addi	r2,r2,32648
811160d8:	10800d8b 	ldhu	r2,54(r2)
811160dc:	10bfffcc 	andi	r2,r2,65535
811160e0:	10800228 	cmpgeui	r2,r2,8
811160e4:	10001d1e 	bne	r2,zero,8111615c <vSimMebTask+0x520>
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
811160e8:	d0a06217 	ldw	r2,-32376(gp)
811160ec:	e0fffd83 	ldbu	r3,-10(fp)
811160f0:	18c03fcc 	andi	r3,r3,255
811160f4:	180d883a 	mov	r6,r3
811160f8:	01604574 	movhi	r5,33045
811160fc:	297c9504 	addi	r5,r5,-3500
81116100:	1009883a 	mov	r4,r2
81116104:	112292c0 	call	8112292c <fprintf>
								}
								#endif
								break;
81116108:	0001883a 	nop
8111610c:	00001306 	br	8111615c <vSimMebTask+0x520>
						}
					} else {
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116110:	00a045b4 	movhi	r2,33046
81116114:	109fe204 	addi	r2,r2,32648
81116118:	10800d8b 	ldhu	r2,54(r2)
8111611c:	10bfffcc 	andi	r2,r2,65535
81116120:	10800228 	cmpgeui	r2,r2,8
81116124:	1000221e 	bne	r2,zero,811161b0 <vSimMebTask+0x574>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81116128:	d0a06217 	ldw	r2,-32376(gp)
8111612c:	e0fffdc3 	ldbu	r3,-9(fp)
81116130:	18c03fcc 	andi	r3,r3,255
81116134:	180d883a 	mov	r6,r3
81116138:	01604574 	movhi	r5,33045
8111613c:	297c7704 	addi	r5,r5,-3620
81116140:	1009883a 	mov	r4,r2
81116144:	112292c0 	call	8112292c <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81116148:	00001906 	br	811161b0 <vSimMebTask+0x574>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
8111614c:	111e3840 	call	8111e384 <vCouldNotGetCmdQueueMeb>
				}			
				break;
81116150:	00001706 	br	811161b0 <vSimMebTask+0x574>
										fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
									}
								}
								#endif

								break;
81116154:	0001883a 	nop
81116158:	00001506 	br	811161b0 <vSimMebTask+0x574>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
								}
								#endif
								break;
8111615c:	0001883a 	nop

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81116160:	00001306 	br	811161b0 <vSimMebTask+0x574>

			default:
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116164:	00a045b4 	movhi	r2,33046
81116168:	109fe204 	addi	r2,r2,32648
8111616c:	10800d8b 	ldhu	r2,54(r2)
81116170:	10bfffcc 	andi	r2,r2,65535
81116174:	10800228 	cmpgeui	r2,r2,8
81116178:	1000071e 	bne	r2,zero,81116198 <vSimMebTask+0x55c>
					debug(fp,"MEB Task: Unknown state, backing to Config Mode\n");
8111617c:	d0a06217 	ldw	r2,-32376(gp)
81116180:	100f883a 	mov	r7,r2
81116184:	01800c04 	movi	r6,48
81116188:	01400044 	movi	r5,1
8111618c:	01204574 	movhi	r4,33045
81116190:	213c9e04 	addi	r4,r4,-3464
81116194:	1122fc80 	call	81122fc8 <fwrite>
				}
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
81116198:	e0bffb17 	ldw	r2,-20(fp)
8111619c:	00c00044 	movi	r3,1
811161a0:	10c00115 	stw	r3,4(r2)
				break;
811161a4:	00000306 	br	811161b4 <vSimMebTask+0x578>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
811161a8:	0001883a 	nop
811161ac:	003eb906 	br	81115c94 <__reset+0xfb0f5c94>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
811161b0:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
				break;
		}
	}
811161b4:	003eb706 	br	81115c94 <__reset+0xfb0f5c94>

811161b8 <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
811161b8:	defffb04 	addi	sp,sp,-20
811161bc:	de00012e 	bgeu	sp,et,811161c4 <vPusMebTask+0xc>
811161c0:	003b68fa 	trap	3
811161c4:	dfc00415 	stw	ra,16(sp)
811161c8:	df000315 	stw	fp,12(sp)
811161cc:	df000304 	addi	fp,sp,12
811161d0:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
811161d4:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
811161d8:	d0a07317 	ldw	r2,-32308(gp)
811161dc:	e0fffe44 	addi	r3,fp,-7
811161e0:	180d883a 	mov	r6,r3
811161e4:	01400084 	movi	r5,2
811161e8:	1009883a 	mov	r4,r2
811161ec:	113ddc00 	call	8113ddc0 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
811161f0:	e0bffe43 	ldbu	r2,-7(fp)
811161f4:	10803fcc 	andi	r2,r2,255
811161f8:	10002c1e 	bne	r2,zero,811162ac <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811161fc:	e03ffe05 	stb	zero,-8(fp)
81116200:	00002306 	br	81116290 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
81116204:	e0fffe03 	ldbu	r3,-8(fp)
81116208:	00a04574 	movhi	r2,33045
8111620c:	109c5c04 	addi	r2,r2,29040
81116210:	18c01524 	muli	r3,r3,84
81116214:	10c5883a 	add	r2,r2,r3
81116218:	10800104 	addi	r2,r2,4
8111621c:	10800017 	ldw	r2,0(r2)
81116220:	10800058 	cmpnei	r2,r2,1
81116224:	1000171e 	bne	r2,zero,81116284 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81116228:	e13ffe03 	ldbu	r4,-8(fp)
8111622c:	00e04574 	movhi	r3,33045
81116230:	18d1df04 	addi	r3,r3,18300
81116234:	00a04574 	movhi	r2,33045
81116238:	109c5c04 	addi	r2,r2,29040
8111623c:	21001524 	muli	r4,r4,84
81116240:	1105883a 	add	r2,r2,r4
81116244:	1009883a 	mov	r4,r2
81116248:	00801504 	movi	r2,84
8111624c:	100d883a 	mov	r6,r2
81116250:	200b883a 	mov	r5,r4
81116254:	1809883a 	mov	r4,r3
81116258:	11239dc0 	call	811239dc <memcpy>
            	xPus[ucIL].bInUse = FALSE;
8111625c:	e0fffe03 	ldbu	r3,-8(fp)
81116260:	00a04574 	movhi	r2,33045
81116264:	109c5c04 	addi	r2,r2,29040
81116268:	18c01524 	muli	r3,r3,84
8111626c:	10c5883a 	add	r2,r2,r3
81116270:	10800104 	addi	r2,r2,4
81116274:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
81116278:	00800044 	movi	r2,1
8111627c:	e0bffd15 	stw	r2,-12(fp)
                break;
81116280:	00000606 	br	8111629c <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81116284:	e0bffe03 	ldbu	r2,-8(fp)
81116288:	10800044 	addi	r2,r2,1
8111628c:	e0bffe05 	stb	r2,-8(fp)
81116290:	e0bffe03 	ldbu	r2,-8(fp)
81116294:	10800130 	cmpltui	r2,r2,4
81116298:	103fda1e 	bne	r2,zero,81116204 <__reset+0xfb0f6204>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
8111629c:	d0a07317 	ldw	r2,-32308(gp)
811162a0:	1009883a 	mov	r4,r2
811162a4:	113e3640 	call	8113e364 <OSMutexPost>
811162a8:	00000106 	br	811162b0 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
811162ac:	111e4040 	call	8111e404 <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
811162b0:	e0bffd17 	ldw	r2,-12(fp)
811162b4:	10001126 	beq	r2,zero,811162fc <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
811162b8:	e0bfff17 	ldw	r2,-4(fp)
811162bc:	10800117 	ldw	r2,4(r2)
811162c0:	10c000e0 	cmpeqi	r3,r2,3
811162c4:	1800031e 	bne	r3,zero,811162d4 <vPusMebTask+0x11c>
811162c8:	10800120 	cmpeqi	r2,r2,4
811162cc:	1000061e 	bne	r2,zero,811162e8 <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
811162d0:	00000a06 	br	811162fc <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
811162d4:	01604574 	movhi	r5,33045
811162d8:	2951df04 	addi	r5,r5,18300
811162dc:	e13fff17 	ldw	r4,-4(fp)
811162e0:	11163140 	call	81116314 <vPusMebInTaskConfigMode>
				break;
811162e4:	00000506 	br	811162fc <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
811162e8:	01604574 	movhi	r5,33045
811162ec:	2951df04 	addi	r5,r5,18300
811162f0:	e13fff17 	ldw	r4,-4(fp)
811162f4:	11167500 	call	81116750 <vPusMebInTaskRunningMode>
				break;
811162f8:	0001883a 	nop
			default:
				break;
		}
	}
}
811162fc:	0001883a 	nop
81116300:	e037883a 	mov	sp,fp
81116304:	dfc00117 	ldw	ra,4(sp)
81116308:	df000017 	ldw	fp,0(sp)
8111630c:	dec00204 	addi	sp,sp,8
81116310:	f800283a 	ret

81116314 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116314:	defffc04 	addi	sp,sp,-16
81116318:	de00012e 	bgeu	sp,et,81116320 <vPusMebInTaskConfigMode+0xc>
8111631c:	003b68fa 	trap	3
81116320:	dfc00315 	stw	ra,12(sp)
81116324:	df000215 	stw	fp,8(sp)
81116328:	df000204 	addi	fp,sp,8
8111632c:	e13ffe15 	stw	r4,-8(fp)
81116330:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81116334:	e0bfff17 	ldw	r2,-4(fp)
81116338:	1080030b 	ldhu	r2,12(r2)
8111633c:	10bfffcc 	andi	r2,r2,65535
81116340:	10c03ee0 	cmpeqi	r3,r2,251
81116344:	1800081e 	bne	r3,zero,81116368 <vPusMebInTaskConfigMode+0x54>
81116348:	10c03f20 	cmpeqi	r3,r2,252
8111634c:	18000a1e 	bne	r3,zero,81116378 <vPusMebInTaskConfigMode+0x64>
81116350:	10803ea0 	cmpeqi	r2,r2,250
81116354:	10000c26 	beq	r2,zero,81116388 <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
81116358:	e17fff17 	ldw	r5,-4(fp)
8111635c:	e13ffe17 	ldw	r4,-8(fp)
81116360:	11163d80 	call	811163d8 <vPusType250conf>
			break;
81116364:	00001606 	br	811163c0 <vPusMebInTaskConfigMode+0xac>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
81116368:	e17fff17 	ldw	r5,-4(fp)
8111636c:	e13ffe17 	ldw	r4,-8(fp)
81116370:	11164840 	call	81116484 <vPusType251conf>
			break;
81116374:	00001206 	br	811163c0 <vPusMebInTaskConfigMode+0xac>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
81116378:	e17fff17 	ldw	r5,-4(fp)
8111637c:	e13ffe17 	ldw	r4,-8(fp)
81116380:	11164f00 	call	811164f0 <vPusType252conf>
			break;
81116384:	00000e06 	br	811163c0 <vPusMebInTaskConfigMode+0xac>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116388:	00a045b4 	movhi	r2,33046
8111638c:	109fe204 	addi	r2,r2,32648
81116390:	10800d8b 	ldhu	r2,54(r2)
81116394:	10bfffcc 	andi	r2,r2,65535
81116398:	10800228 	cmpgeui	r2,r2,8
8111639c:	1000071e 	bne	r2,zero,811163bc <vPusMebInTaskConfigMode+0xa8>
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
811163a0:	d0a06217 	ldw	r2,-32376(gp)
811163a4:	100f883a 	mov	r7,r2
811163a8:	01800d84 	movi	r6,54
811163ac:	01400044 	movi	r5,1
811163b0:	01204574 	movhi	r4,33045
811163b4:	213cab04 	addi	r4,r4,-3412
811163b8:	1122fc80 	call	81122fc8 <fwrite>
			}
			#endif
			break;
811163bc:	0001883a 	nop
	}
}
811163c0:	0001883a 	nop
811163c4:	e037883a 	mov	sp,fp
811163c8:	dfc00117 	ldw	ra,4(sp)
811163cc:	df000017 	ldw	fp,0(sp)
811163d0:	dec00204 	addi	sp,sp,8
811163d4:	f800283a 	ret

811163d8 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811163d8:	defffc04 	addi	sp,sp,-16
811163dc:	de00012e 	bgeu	sp,et,811163e4 <vPusType250conf+0xc>
811163e0:	003b68fa 	trap	3
811163e4:	dfc00315 	stw	ra,12(sp)
811163e8:	df000215 	stw	fp,8(sp)
811163ec:	df000204 	addi	fp,sp,8
811163f0:	e13ffe15 	stw	r4,-8(fp)
811163f4:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
811163f8:	e0bfff17 	ldw	r2,-4(fp)
811163fc:	1080038b 	ldhu	r2,14(r2)
81116400:	10bfffcc 	andi	r2,r2,65535
81116404:	10c00f60 	cmpeqi	r3,r2,61
81116408:	1800031e 	bne	r3,zero,81116418 <vPusType250conf+0x40>
8111640c:	10800fa0 	cmpeqi	r2,r2,62
81116410:	1000131e 	bne	r2,zero,81116460 <vPusType250conf+0x88>
81116414:	00000406 	br	81116428 <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
81116418:	e0bffe17 	ldw	r2,-8(fp)
8111641c:	00c00084 	movi	r3,2
81116420:	10c00115 	stw	r3,4(r2)
			break;
81116424:	00001106 	br	8111646c <vPusType250conf+0x94>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116428:	00a045b4 	movhi	r2,33046
8111642c:	109fe204 	addi	r2,r2,32648
81116430:	10800d8b 	ldhu	r2,54(r2)
81116434:	10bfffcc 	andi	r2,r2,65535
81116438:	10800228 	cmpgeui	r2,r2,8
8111643c:	10000a1e 	bne	r2,zero,81116468 <vPusType250conf+0x90>
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81116440:	d0a06217 	ldw	r2,-32376(gp)
81116444:	100f883a 	mov	r7,r2
81116448:	01800b04 	movi	r6,44
8111644c:	01400044 	movi	r5,1
81116450:	01204574 	movhi	r4,33045
81116454:	213cb904 	addi	r4,r4,-3356
81116458:	1122fc80 	call	81122fc8 <fwrite>
			}
			#endif
			break;
8111645c:	00000206 	br	81116468 <vPusType250conf+0x90>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81116460:	0001883a 	nop
81116464:	00000106 	br	8111646c <vPusType250conf+0x94>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			}
			#endif
			break;
81116468:	0001883a 	nop
	}
}
8111646c:	0001883a 	nop
81116470:	e037883a 	mov	sp,fp
81116474:	dfc00117 	ldw	ra,4(sp)
81116478:	df000017 	ldw	fp,0(sp)
8111647c:	dec00204 	addi	sp,sp,8
81116480:	f800283a 	ret

81116484 <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116484:	defffc04 	addi	sp,sp,-16
81116488:	de00012e 	bgeu	sp,et,81116490 <vPusType251conf+0xc>
8111648c:	003b68fa 	trap	3
81116490:	dfc00315 	stw	ra,12(sp)
81116494:	df000215 	stw	fp,8(sp)
81116498:	df000204 	addi	fp,sp,8
8111649c:	e13ffe15 	stw	r4,-8(fp)
811164a0:	e17fff15 	stw	r5,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811164a4:	00a045b4 	movhi	r2,33046
811164a8:	109fe204 	addi	r2,r2,32648
811164ac:	10800d8b 	ldhu	r2,54(r2)
811164b0:	10bfffcc 	andi	r2,r2,65535
811164b4:	10800168 	cmpgeui	r2,r2,5
811164b8:	1000071e 	bne	r2,zero,811164d8 <vPusType251conf+0x54>
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
811164bc:	d0a06217 	ldw	r2,-32376(gp)
811164c0:	100f883a 	mov	r7,r2
811164c4:	01801184 	movi	r6,70
811164c8:	01400044 	movi	r5,1
811164cc:	01204574 	movhi	r4,33045
811164d0:	213cc504 	addi	r4,r4,-3308
811164d4:	1122fc80 	call	81122fc8 <fwrite>
	}
	#endif
}
811164d8:	0001883a 	nop
811164dc:	e037883a 	mov	sp,fp
811164e0:	dfc00117 	ldw	ra,4(sp)
811164e4:	df000017 	ldw	fp,0(sp)
811164e8:	dec00204 	addi	sp,sp,8
811164ec:	f800283a 	ret

811164f0 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811164f0:	defffb04 	addi	sp,sp,-20
811164f4:	de00012e 	bgeu	sp,et,811164fc <vPusType252conf+0xc>
811164f8:	003b68fa 	trap	3
811164fc:	dfc00415 	stw	ra,16(sp)
81116500:	df000315 	stw	fp,12(sp)
81116504:	df000304 	addi	fp,sp,12
81116508:	e13ffe15 	stw	r4,-8(fp)
8111650c:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81116510:	e0bfff17 	ldw	r2,-4(fp)
81116514:	1080050b 	ldhu	r2,20(r2)
81116518:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
8111651c:	e0bfff17 	ldw	r2,-4(fp)
81116520:	1080038b 	ldhu	r2,14(r2)
81116524:	10bfffcc 	andi	r2,r2,65535
81116528:	10c000a0 	cmpeqi	r3,r2,2
8111652c:	1800121e 	bne	r3,zero,81116578 <vPusType252conf+0x88>
81116530:	10c00090 	cmplti	r3,r2,2
81116534:	18006d1e 	bne	r3,zero,811166ec <vPusType252conf+0x1fc>
81116538:	10800188 	cmpgei	r2,r2,6
8111653c:	10006b1e 	bne	r2,zero,811166ec <vPusType252conf+0x1fc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116540:	00a045b4 	movhi	r2,33046
81116544:	109fe204 	addi	r2,r2,32648
81116548:	10800d8b 	ldhu	r2,54(r2)
8111654c:	10bfffcc 	andi	r2,r2,65535
81116550:	10800168 	cmpgeui	r2,r2,5
81116554:	1000731e 	bne	r2,zero,81116724 <vPusType252conf+0x234>
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
81116558:	d0a06217 	ldw	r2,-32376(gp)
8111655c:	100f883a 	mov	r7,r2
81116560:	01801384 	movi	r6,78
81116564:	01400044 	movi	r5,1
81116568:	01204574 	movhi	r4,33045
8111656c:	213cd704 	addi	r4,r4,-3236
81116570:	1122fc80 	call	81122fc8 <fwrite>
			}
			#endif
			break;
81116574:	00006b06 	br	81116724 <vPusType252conf+0x234>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116578:	e0bffd0b 	ldhu	r2,-12(fp)
8111657c:	10809624 	muli	r2,r2,600
81116580:	10805504 	addi	r2,r2,340
81116584:	e0fffe17 	ldw	r3,-8(fp)
81116588:	1885883a 	add	r2,r3,r2
8111658c:	1009883a 	mov	r4,r2
81116590:	11078740 	call	81107874 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81116594:	e0bffd0b 	ldhu	r2,-12(fp)
81116598:	e0fffe17 	ldw	r3,-8(fp)
8111659c:	10809624 	muli	r2,r2,600
811165a0:	1885883a 	add	r2,r3,r2
811165a4:	10806504 	addi	r2,r2,404
811165a8:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811165ac:	e0bffd0b 	ldhu	r2,-12(fp)
811165b0:	10809624 	muli	r2,r2,600
811165b4:	10805504 	addi	r2,r2,340
811165b8:	e0fffe17 	ldw	r3,-8(fp)
811165bc:	1885883a 	add	r2,r3,r2
811165c0:	1009883a 	mov	r4,r2
811165c4:	11077cc0 	call	811077cc <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811165c8:	e0bffd0b 	ldhu	r2,-12(fp)
811165cc:	10809624 	muli	r2,r2,600
811165d0:	10805504 	addi	r2,r2,340
811165d4:	e0fffe17 	ldw	r3,-8(fp)
811165d8:	1885883a 	add	r2,r3,r2
811165dc:	1009883a 	mov	r4,r2
811165e0:	1107a5c0 	call	81107a5c <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
811165e4:	e0bffd0b 	ldhu	r2,-12(fp)
811165e8:	e0ffff17 	ldw	r3,-4(fp)
811165ec:	18c00b0b 	ldhu	r3,44(r3)
811165f0:	1809883a 	mov	r4,r3
811165f4:	e0fffe17 	ldw	r3,-8(fp)
811165f8:	10809624 	muli	r2,r2,600
811165fc:	1885883a 	add	r2,r3,r2
81116600:	10805604 	addi	r2,r2,344
81116604:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81116608:	e0bffd0b 	ldhu	r2,-12(fp)
8111660c:	e0ffff17 	ldw	r3,-4(fp)
81116610:	18c0098b 	ldhu	r3,38(r3)
81116614:	1809883a 	mov	r4,r3
81116618:	e0fffe17 	ldw	r3,-8(fp)
8111661c:	10809624 	muli	r2,r2,600
81116620:	1885883a 	add	r2,r3,r2
81116624:	10805644 	addi	r2,r2,345
81116628:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
8111662c:	e0bffd0b 	ldhu	r2,-12(fp)
81116630:	10809624 	muli	r2,r2,600
81116634:	10805504 	addi	r2,r2,340
81116638:	e0fffe17 	ldw	r3,-8(fp)
8111663c:	1885883a 	add	r2,r3,r2
81116640:	1009883a 	mov	r4,r2
81116644:	11079840 	call	81107984 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116648:	e0bffd0b 	ldhu	r2,-12(fp)
8111664c:	10809624 	muli	r2,r2,600
81116650:	10805504 	addi	r2,r2,340
81116654:	e0fffe17 	ldw	r3,-8(fp)
81116658:	1885883a 	add	r2,r3,r2
8111665c:	1009883a 	mov	r4,r2
81116660:	11078740 	call	81107874 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81116664:	e0bffd0b 	ldhu	r2,-12(fp)
81116668:	e0fffe17 	ldw	r3,-8(fp)
8111666c:	10809624 	muli	r2,r2,600
81116670:	1885883a 	add	r2,r3,r2
81116674:	10806504 	addi	r2,r2,404
81116678:	00c00044 	movi	r3,1
8111667c:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116680:	e0bffd0b 	ldhu	r2,-12(fp)
81116684:	10809624 	muli	r2,r2,600
81116688:	10805504 	addi	r2,r2,340
8111668c:	e0fffe17 	ldw	r3,-8(fp)
81116690:	1885883a 	add	r2,r3,r2
81116694:	1009883a 	mov	r4,r2
81116698:	11077cc0 	call	811077cc <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
8111669c:	00a045b4 	movhi	r2,33046
811166a0:	109fe204 	addi	r2,r2,32648
811166a4:	10800d8b 	ldhu	r2,54(r2)
811166a8:	10bfffcc 	andi	r2,r2,65535
811166ac:	108000e8 	cmpgeui	r2,r2,3
811166b0:	10001e1e 	bne	r2,zero,8111672c <vPusType252conf+0x23c>
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
811166b4:	d0e06217 	ldw	r3,-32376(gp)
811166b8:	e0bfff17 	ldw	r2,-4(fp)
811166bc:	10800b0b 	ldhu	r2,44(r2)
811166c0:	113fffcc 	andi	r4,r2,65535
811166c4:	e0bfff17 	ldw	r2,-4(fp)
811166c8:	1080098b 	ldhu	r2,38(r2)
811166cc:	10bfffcc 	andi	r2,r2,65535
811166d0:	100f883a 	mov	r7,r2
811166d4:	200d883a 	mov	r6,r4
811166d8:	01604574 	movhi	r5,33045
811166dc:	297ceb04 	addi	r5,r5,-3156
811166e0:	1809883a 	mov	r4,r3
811166e4:	112292c0 	call	8112292c <fprintf>
			}
			#endif

			break;
811166e8:	00001006 	br	8111672c <vPusType252conf+0x23c>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811166ec:	00a045b4 	movhi	r2,33046
811166f0:	109fe204 	addi	r2,r2,32648
811166f4:	10800d8b 	ldhu	r2,54(r2)
811166f8:	10bfffcc 	andi	r2,r2,65535
811166fc:	10800228 	cmpgeui	r2,r2,8
81116700:	10000c1e 	bne	r2,zero,81116734 <vPusType252conf+0x244>
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81116704:	d0a06217 	ldw	r2,-32376(gp)
81116708:	100f883a 	mov	r7,r2
8111670c:	01800b04 	movi	r6,44
81116710:	01400044 	movi	r5,1
81116714:	01204574 	movhi	r4,33045
81116718:	213cb904 	addi	r4,r4,-3356
8111671c:	1122fc80 	call	81122fc8 <fwrite>
			}
			#endif
			break;
81116720:	00000406 	br	81116734 <vPusType252conf+0x244>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
			}
			#endif
			break;
81116724:	0001883a 	nop
81116728:	00000306 	br	81116738 <vPusType252conf+0x248>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			}
			#endif

			break;
8111672c:	0001883a 	nop
81116730:	00000106 	br	81116738 <vPusType252conf+0x248>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			}
			#endif
			break;
81116734:	0001883a 	nop
	}
}
81116738:	0001883a 	nop
8111673c:	e037883a 	mov	sp,fp
81116740:	dfc00117 	ldw	ra,4(sp)
81116744:	df000017 	ldw	fp,0(sp)
81116748:	dec00204 	addi	sp,sp,8
8111674c:	f800283a 	ret

81116750 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116750:	defffc04 	addi	sp,sp,-16
81116754:	de00012e 	bgeu	sp,et,8111675c <vPusMebInTaskRunningMode+0xc>
81116758:	003b68fa 	trap	3
8111675c:	dfc00315 	stw	ra,12(sp)
81116760:	df000215 	stw	fp,8(sp)
81116764:	df000204 	addi	fp,sp,8
81116768:	e13ffe15 	stw	r4,-8(fp)
8111676c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81116770:	e0bfff17 	ldw	r2,-4(fp)
81116774:	1080030b 	ldhu	r2,12(r2)
81116778:	10bfffcc 	andi	r2,r2,65535
8111677c:	10c03ee0 	cmpeqi	r3,r2,251
81116780:	1800081e 	bne	r3,zero,811167a4 <vPusMebInTaskRunningMode+0x54>
81116784:	10c03f20 	cmpeqi	r3,r2,252
81116788:	18000a1e 	bne	r3,zero,811167b4 <vPusMebInTaskRunningMode+0x64>
8111678c:	10803ea0 	cmpeqi	r2,r2,250
81116790:	10000c26 	beq	r2,zero,811167c4 <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
81116794:	e17fff17 	ldw	r5,-4(fp)
81116798:	e13ffe17 	ldw	r4,-8(fp)
8111679c:	11168140 	call	81116814 <vPusType250run>
			break;
811167a0:	00001606 	br	811167fc <vPusMebInTaskRunningMode+0xac>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
811167a4:	e17fff17 	ldw	r5,-4(fp)
811167a8:	e13ffe17 	ldw	r4,-8(fp)
811167ac:	11168c00 	call	811168c0 <vPusType251run>
			break;
811167b0:	00001206 	br	811167fc <vPusMebInTaskRunningMode+0xac>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
811167b4:	e17fff17 	ldw	r5,-4(fp)
811167b8:	e13ffe17 	ldw	r4,-8(fp)
811167bc:	11169ec0 	call	811169ec <vPusType252run>
			break;
811167c0:	00000e06 	br	811167fc <vPusMebInTaskRunningMode+0xac>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811167c4:	00a045b4 	movhi	r2,33046
811167c8:	109fe204 	addi	r2,r2,32648
811167cc:	10800d8b 	ldhu	r2,54(r2)
811167d0:	10bfffcc 	andi	r2,r2,65535
811167d4:	10800228 	cmpgeui	r2,r2,8
811167d8:	1000071e 	bne	r2,zero,811167f8 <vPusMebInTaskRunningMode+0xa8>
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
811167dc:	d0a06217 	ldw	r2,-32376(gp)
811167e0:	100f883a 	mov	r7,r2
811167e4:	01800cc4 	movi	r6,51
811167e8:	01400044 	movi	r5,1
811167ec:	01204574 	movhi	r4,33045
811167f0:	213cfb04 	addi	r4,r4,-3092
811167f4:	1122fc80 	call	81122fc8 <fwrite>
			}
			#endif
			break;
811167f8:	0001883a 	nop
	}
}
811167fc:	0001883a 	nop
81116800:	e037883a 	mov	sp,fp
81116804:	dfc00117 	ldw	ra,4(sp)
81116808:	df000017 	ldw	fp,0(sp)
8111680c:	dec00204 	addi	sp,sp,8
81116810:	f800283a 	ret

81116814 <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81116814:	defffc04 	addi	sp,sp,-16
81116818:	de00012e 	bgeu	sp,et,81116820 <vPusType250run+0xc>
8111681c:	003b68fa 	trap	3
81116820:	dfc00315 	stw	ra,12(sp)
81116824:	df000215 	stw	fp,8(sp)
81116828:	df000204 	addi	fp,sp,8
8111682c:	e13ffe15 	stw	r4,-8(fp)
81116830:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81116834:	e0bfff17 	ldw	r2,-4(fp)
81116838:	1080038b 	ldhu	r2,14(r2)
8111683c:	10bfffcc 	andi	r2,r2,65535
81116840:	10c00f20 	cmpeqi	r3,r2,60
81116844:	1800031e 	bne	r3,zero,81116854 <vPusType250run+0x40>
81116848:	10800fa0 	cmpeqi	r2,r2,62
8111684c:	1000131e 	bne	r2,zero,8111689c <vPusType250run+0x88>
81116850:	00000406 	br	81116864 <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
81116854:	e0bffe17 	ldw	r2,-8(fp)
81116858:	00c00044 	movi	r3,1
8111685c:	10c00115 	stw	r3,4(r2)
			break;
81116860:	00001106 	br	811168a8 <vPusType250run+0x94>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116864:	00a045b4 	movhi	r2,33046
81116868:	109fe204 	addi	r2,r2,32648
8111686c:	10800d8b 	ldhu	r2,54(r2)
81116870:	10bfffcc 	andi	r2,r2,65535
81116874:	10800228 	cmpgeui	r2,r2,8
81116878:	10000a1e 	bne	r2,zero,811168a4 <vPusType250run+0x90>
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
8111687c:	d0a06217 	ldw	r2,-32376(gp)
81116880:	100f883a 	mov	r7,r2
81116884:	01800c84 	movi	r6,50
81116888:	01400044 	movi	r5,1
8111688c:	01204574 	movhi	r4,33045
81116890:	213d0804 	addi	r4,r4,-3040
81116894:	1122fc80 	call	81122fc8 <fwrite>
			}
			#endif
			break;
81116898:	00000206 	br	811168a4 <vPusType250run+0x90>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
8111689c:	0001883a 	nop
811168a0:	00000106 	br	811168a8 <vPusType250run+0x94>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
811168a4:	0001883a 	nop
	}
}
811168a8:	0001883a 	nop
811168ac:	e037883a 	mov	sp,fp
811168b0:	dfc00117 	ldw	ra,4(sp)
811168b4:	df000017 	ldw	fp,0(sp)
811168b8:	dec00204 	addi	sp,sp,8
811168bc:	f800283a 	ret

811168c0 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811168c0:	defffb04 	addi	sp,sp,-20
811168c4:	de00012e 	bgeu	sp,et,811168cc <vPusType251run+0xc>
811168c8:	003b68fa 	trap	3
811168cc:	dfc00415 	stw	ra,16(sp)
811168d0:	df000315 	stw	fp,12(sp)
811168d4:	df000304 	addi	fp,sp,12
811168d8:	e13ffe15 	stw	r4,-8(fp)
811168dc:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
811168e0:	e0bfff17 	ldw	r2,-4(fp)
811168e4:	1080050b 	ldhu	r2,20(r2)
811168e8:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811168ec:	e0bfff17 	ldw	r2,-4(fp)
811168f0:	1080038b 	ldhu	r2,14(r2)
811168f4:	10bfffcc 	andi	r2,r2,65535
811168f8:	10c000a0 	cmpeqi	r3,r2,2
811168fc:	18000f1e 	bne	r3,zero,8111693c <vPusType251run+0x7c>
81116900:	10c00160 	cmpeqi	r3,r2,5
81116904:	1800181e 	bne	r3,zero,81116968 <vPusType251run+0xa8>
81116908:	10800060 	cmpeqi	r2,r2,1
8111690c:	10002126 	beq	r2,zero,81116994 <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
81116910:	e0bffd0b 	ldhu	r2,-12(fp)
81116914:	10800444 	addi	r2,r2,17
81116918:	10803fcc 	andi	r2,r2,255
8111691c:	e0fffd0b 	ldhu	r3,-12(fp)
81116920:	18c03fcc 	andi	r3,r3,255
81116924:	180f883a 	mov	r7,r3
81116928:	000d883a 	mov	r6,zero
8111692c:	01400044 	movi	r5,1
81116930:	1009883a 	mov	r4,r2
81116934:	1116f1c0 	call	81116f1c <vSendCmdQToNFeeCTRL_GEN>
			break;
81116938:	00002606 	br	811169d4 <vPusType251run+0x114>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
8111693c:	e0bffd0b 	ldhu	r2,-12(fp)
81116940:	10800444 	addi	r2,r2,17
81116944:	10803fcc 	andi	r2,r2,255
81116948:	e0fffd0b 	ldhu	r3,-12(fp)
8111694c:	18c03fcc 	andi	r3,r3,255
81116950:	180f883a 	mov	r7,r3
81116954:	000d883a 	mov	r6,zero
81116958:	01400104 	movi	r5,4
8111695c:	1009883a 	mov	r4,r2
81116960:	1116f1c0 	call	81116f1c <vSendCmdQToNFeeCTRL_GEN>
			break;
81116964:	00001b06 	br	811169d4 <vPusType251run+0x114>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
81116968:	e0bffd0b 	ldhu	r2,-12(fp)
8111696c:	10800444 	addi	r2,r2,17
81116970:	10803fcc 	andi	r2,r2,255
81116974:	e0fffd0b 	ldhu	r3,-12(fp)
81116978:	18c03fcc 	andi	r3,r3,255
8111697c:	180f883a 	mov	r7,r3
81116980:	000d883a 	mov	r6,zero
81116984:	01400204 	movi	r5,8
81116988:	1009883a 	mov	r4,r2
8111698c:	1116f1c0 	call	81116f1c <vSendCmdQToNFeeCTRL_GEN>
			break;
81116990:	00001006 	br	811169d4 <vPusType251run+0x114>
		case 3:
		case 4:
		case 6:
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81116994:	00a045b4 	movhi	r2,33046
81116998:	109fe204 	addi	r2,r2,32648
8111699c:	10800d8b 	ldhu	r2,54(r2)
811169a0:	10bfffcc 	andi	r2,r2,65535
811169a4:	10800228 	cmpgeui	r2,r2,8
811169a8:	1000091e 	bne	r2,zero,811169d0 <vPusType251run+0x110>
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
811169ac:	d0e06217 	ldw	r3,-32376(gp)
811169b0:	e0bfff17 	ldw	r2,-4(fp)
811169b4:	1080038b 	ldhu	r2,14(r2)
811169b8:	10bfffcc 	andi	r2,r2,65535
811169bc:	100d883a 	mov	r6,r2
811169c0:	01604574 	movhi	r5,33045
811169c4:	297d1504 	addi	r5,r5,-2988
811169c8:	1809883a 	mov	r4,r3
811169cc:	112292c0 	call	8112292c <fprintf>
			}
			#endif
			break;
811169d0:	0001883a 	nop
	}
}
811169d4:	0001883a 	nop
811169d8:	e037883a 	mov	sp,fp
811169dc:	dfc00117 	ldw	ra,4(sp)
811169e0:	df000017 	ldw	fp,0(sp)
811169e4:	dec00204 	addi	sp,sp,8
811169e8:	f800283a 	ret

811169ec <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811169ec:	defffb04 	addi	sp,sp,-20
811169f0:	de00012e 	bgeu	sp,et,811169f8 <vPusType252run+0xc>
811169f4:	003b68fa 	trap	3
811169f8:	dfc00415 	stw	ra,16(sp)
811169fc:	df000315 	stw	fp,12(sp)
81116a00:	df000304 	addi	fp,sp,12
81116a04:	e13ffe15 	stw	r4,-8(fp)
81116a08:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81116a0c:	e0bfff17 	ldw	r2,-4(fp)
81116a10:	1080050b 	ldhu	r2,20(r2)
81116a14:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81116a18:	e0bfff17 	ldw	r2,-4(fp)
81116a1c:	1080038b 	ldhu	r2,14(r2)
81116a20:	10bfffcc 	andi	r2,r2,65535
81116a24:	10c000e0 	cmpeqi	r3,r2,3
81116a28:	18000a1e 	bne	r3,zero,81116a54 <vPusType252run+0x68>
81116a2c:	10c00108 	cmpgei	r3,r2,4
81116a30:	1800031e 	bne	r3,zero,81116a40 <vPusType252run+0x54>
81116a34:	108000a0 	cmpeqi	r2,r2,2
81116a38:	1000641e 	bne	r2,zero,81116bcc <vPusType252run+0x1e0>
81116a3c:	0000d606 	br	81116d98 <vPusType252run+0x3ac>
81116a40:	10c00120 	cmpeqi	r3,r2,4
81116a44:	1800321e 	bne	r3,zero,81116b10 <vPusType252run+0x124>
81116a48:	10800160 	cmpeqi	r2,r2,5
81116a4c:	1000e01e 	bne	r2,zero,81116dd0 <vPusType252run+0x3e4>
81116a50:	0000d106 	br	81116d98 <vPusType252run+0x3ac>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81116a54:	e0bffd0b 	ldhu	r2,-12(fp)
81116a58:	10809624 	muli	r2,r2,600
81116a5c:	10809b04 	addi	r2,r2,620
81116a60:	e0fffe17 	ldw	r3,-8(fp)
81116a64:	1885883a 	add	r2,r3,r2
81116a68:	1009883a 	mov	r4,r2
81116a6c:	110a1f80 	call	8110a1f8 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81116a70:	e0bffd0b 	ldhu	r2,-12(fp)
81116a74:	e0fffe17 	ldw	r3,-8(fp)
81116a78:	10809624 	muli	r2,r2,600
81116a7c:	1885883a 	add	r2,r3,r2
81116a80:	10809d04 	addi	r2,r2,628
81116a84:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
81116a88:	e0bffd0b 	ldhu	r2,-12(fp)
81116a8c:	e0fffe17 	ldw	r3,-8(fp)
81116a90:	10809624 	muli	r2,r2,600
81116a94:	1885883a 	add	r2,r3,r2
81116a98:	10809c04 	addi	r2,r2,624
81116a9c:	00c00044 	movi	r3,1
81116aa0:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81116aa4:	e0bffd0b 	ldhu	r2,-12(fp)
81116aa8:	e0fffe17 	ldw	r3,-8(fp)
81116aac:	10809624 	muli	r2,r2,600
81116ab0:	1885883a 	add	r2,r3,r2
81116ab4:	10809e04 	addi	r2,r2,632
81116ab8:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81116abc:	e0bffd0b 	ldhu	r2,-12(fp)
81116ac0:	10809624 	muli	r2,r2,600
81116ac4:	10809b04 	addi	r2,r2,620
81116ac8:	e0fffe17 	ldw	r3,-8(fp)
81116acc:	1885883a 	add	r2,r3,r2
81116ad0:	1009883a 	mov	r4,r2
81116ad4:	110a0c40 	call	8110a0c4 <bSpwcSetLink>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116ad8:	00a045b4 	movhi	r2,33046
81116adc:	109fe204 	addi	r2,r2,32648
81116ae0:	10800d8b 	ldhu	r2,54(r2)
81116ae4:	10bfffcc 	andi	r2,r2,65535
81116ae8:	108000e8 	cmpgeui	r2,r2,3
81116aec:	1000ba1e 	bne	r2,zero,81116dd8 <vPusType252run+0x3ec>
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
81116af0:	d0a06217 	ldw	r2,-32376(gp)
81116af4:	e0fffd0b 	ldhu	r3,-12(fp)
81116af8:	180d883a 	mov	r6,r3
81116afc:	01604574 	movhi	r5,33045
81116b00:	297d2304 	addi	r5,r5,-2932
81116b04:	1009883a 	mov	r4,r2
81116b08:	112292c0 	call	8112292c <fprintf>
			}
			#endif

			break;
81116b0c:	0000b206 	br	81116dd8 <vPusType252run+0x3ec>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81116b10:	e0bffd0b 	ldhu	r2,-12(fp)
81116b14:	10809624 	muli	r2,r2,600
81116b18:	10809b04 	addi	r2,r2,620
81116b1c:	e0fffe17 	ldw	r3,-8(fp)
81116b20:	1885883a 	add	r2,r3,r2
81116b24:	1009883a 	mov	r4,r2
81116b28:	110a1f80 	call	8110a1f8 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81116b2c:	e0bffd0b 	ldhu	r2,-12(fp)
81116b30:	e0fffe17 	ldw	r3,-8(fp)
81116b34:	10809624 	muli	r2,r2,600
81116b38:	1885883a 	add	r2,r3,r2
81116b3c:	10809d04 	addi	r2,r2,628
81116b40:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81116b44:	e0bffd0b 	ldhu	r2,-12(fp)
81116b48:	e0fffe17 	ldw	r3,-8(fp)
81116b4c:	10809624 	muli	r2,r2,600
81116b50:	1885883a 	add	r2,r3,r2
81116b54:	10809c04 	addi	r2,r2,624
81116b58:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
81116b5c:	e0bffd0b 	ldhu	r2,-12(fp)
81116b60:	e0fffe17 	ldw	r3,-8(fp)
81116b64:	10809624 	muli	r2,r2,600
81116b68:	1885883a 	add	r2,r3,r2
81116b6c:	10809e04 	addi	r2,r2,632
81116b70:	00c00044 	movi	r3,1
81116b74:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81116b78:	e0bffd0b 	ldhu	r2,-12(fp)
81116b7c:	10809624 	muli	r2,r2,600
81116b80:	10809b04 	addi	r2,r2,620
81116b84:	e0fffe17 	ldw	r3,-8(fp)
81116b88:	1885883a 	add	r2,r3,r2
81116b8c:	1009883a 	mov	r4,r2
81116b90:	110a0c40 	call	8110a0c4 <bSpwcSetLink>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116b94:	00a045b4 	movhi	r2,33046
81116b98:	109fe204 	addi	r2,r2,32648
81116b9c:	10800d8b 	ldhu	r2,54(r2)
81116ba0:	10bfffcc 	andi	r2,r2,65535
81116ba4:	108000e8 	cmpgeui	r2,r2,3
81116ba8:	10008d1e 	bne	r2,zero,81116de0 <vPusType252run+0x3f4>
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81116bac:	d0a06217 	ldw	r2,-32376(gp)
81116bb0:	e0fffd0b 	ldhu	r3,-12(fp)
81116bb4:	180d883a 	mov	r6,r3
81116bb8:	01604574 	movhi	r5,33045
81116bbc:	297d2c04 	addi	r5,r5,-2896
81116bc0:	1009883a 	mov	r4,r2
81116bc4:	112292c0 	call	8112292c <fprintf>
			}
			#endif

			break;
81116bc8:	00008506 	br	81116de0 <vPusType252run+0x3f4>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81116bcc:	e0bffd0b 	ldhu	r2,-12(fp)
81116bd0:	e0fffe17 	ldw	r3,-8(fp)
81116bd4:	10809624 	muli	r2,r2,600
81116bd8:	1885883a 	add	r2,r3,r2
81116bdc:	10803e04 	addi	r2,r2,248
81116be0:	10800017 	ldw	r2,0(r2)
81116be4:	10800058 	cmpnei	r2,r2,1
81116be8:	10004a1e 	bne	r2,zero,81116d14 <vPusType252run+0x328>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116bec:	e0bffd0b 	ldhu	r2,-12(fp)
81116bf0:	10809624 	muli	r2,r2,600
81116bf4:	10805504 	addi	r2,r2,340
81116bf8:	e0fffe17 	ldw	r3,-8(fp)
81116bfc:	1885883a 	add	r2,r3,r2
81116c00:	1009883a 	mov	r4,r2
81116c04:	11078740 	call	81107874 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81116c08:	e0bffd0b 	ldhu	r2,-12(fp)
81116c0c:	e0fffe17 	ldw	r3,-8(fp)
81116c10:	10809624 	muli	r2,r2,600
81116c14:	1885883a 	add	r2,r3,r2
81116c18:	10806504 	addi	r2,r2,404
81116c1c:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116c20:	e0bffd0b 	ldhu	r2,-12(fp)
81116c24:	10809624 	muli	r2,r2,600
81116c28:	10805504 	addi	r2,r2,340
81116c2c:	e0fffe17 	ldw	r3,-8(fp)
81116c30:	1885883a 	add	r2,r3,r2
81116c34:	1009883a 	mov	r4,r2
81116c38:	11077cc0 	call	811077cc <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81116c3c:	e0bffd0b 	ldhu	r2,-12(fp)
81116c40:	10809624 	muli	r2,r2,600
81116c44:	10805504 	addi	r2,r2,340
81116c48:	e0fffe17 	ldw	r3,-8(fp)
81116c4c:	1885883a 	add	r2,r3,r2
81116c50:	1009883a 	mov	r4,r2
81116c54:	1107a5c0 	call	81107a5c <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81116c58:	e0bffd0b 	ldhu	r2,-12(fp)
81116c5c:	e0ffff17 	ldw	r3,-4(fp)
81116c60:	18c00b0b 	ldhu	r3,44(r3)
81116c64:	1809883a 	mov	r4,r3
81116c68:	e0fffe17 	ldw	r3,-8(fp)
81116c6c:	10809624 	muli	r2,r2,600
81116c70:	1885883a 	add	r2,r3,r2
81116c74:	10805604 	addi	r2,r2,344
81116c78:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81116c7c:	e0bffd0b 	ldhu	r2,-12(fp)
81116c80:	e0ffff17 	ldw	r3,-4(fp)
81116c84:	18c0098b 	ldhu	r3,38(r3)
81116c88:	1809883a 	mov	r4,r3
81116c8c:	e0fffe17 	ldw	r3,-8(fp)
81116c90:	10809624 	muli	r2,r2,600
81116c94:	1885883a 	add	r2,r3,r2
81116c98:	10805644 	addi	r2,r2,345
81116c9c:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81116ca0:	e0bffd0b 	ldhu	r2,-12(fp)
81116ca4:	10809624 	muli	r2,r2,600
81116ca8:	10805504 	addi	r2,r2,340
81116cac:	e0fffe17 	ldw	r3,-8(fp)
81116cb0:	1885883a 	add	r2,r3,r2
81116cb4:	1009883a 	mov	r4,r2
81116cb8:	11079840 	call	81107984 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116cbc:	e0bffd0b 	ldhu	r2,-12(fp)
81116cc0:	10809624 	muli	r2,r2,600
81116cc4:	10805504 	addi	r2,r2,340
81116cc8:	e0fffe17 	ldw	r3,-8(fp)
81116ccc:	1885883a 	add	r2,r3,r2
81116cd0:	1009883a 	mov	r4,r2
81116cd4:	11078740 	call	81107874 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81116cd8:	e0bffd0b 	ldhu	r2,-12(fp)
81116cdc:	e0fffe17 	ldw	r3,-8(fp)
81116ce0:	10809624 	muli	r2,r2,600
81116ce4:	1885883a 	add	r2,r3,r2
81116ce8:	10806504 	addi	r2,r2,404
81116cec:	00c00044 	movi	r3,1
81116cf0:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81116cf4:	e0bffd0b 	ldhu	r2,-12(fp)
81116cf8:	10809624 	muli	r2,r2,600
81116cfc:	10805504 	addi	r2,r2,340
81116d00:	e0fffe17 	ldw	r3,-8(fp)
81116d04:	1885883a 	add	r2,r3,r2
81116d08:	1009883a 	mov	r4,r2
81116d0c:	11077cc0 	call	811077cc <bRmapSetIrqControl>
81116d10:	00000d06 	br	81116d48 <vPusType252run+0x35c>
			} else {
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116d14:	00a045b4 	movhi	r2,33046
81116d18:	109fe204 	addi	r2,r2,32648
81116d1c:	10800d8b 	ldhu	r2,54(r2)
81116d20:	10bfffcc 	andi	r2,r2,65535
81116d24:	10800168 	cmpgeui	r2,r2,5
81116d28:	1000071e 	bne	r2,zero,81116d48 <vPusType252run+0x35c>
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
81116d2c:	d0a06217 	ldw	r2,-32376(gp)
81116d30:	e0fffd0b 	ldhu	r3,-12(fp)
81116d34:	180d883a 	mov	r6,r3
81116d38:	01604574 	movhi	r5,33045
81116d3c:	297d3504 	addi	r5,r5,-2860
81116d40:	1009883a 	mov	r4,r2
81116d44:	112292c0 	call	8112292c <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81116d48:	00a045b4 	movhi	r2,33046
81116d4c:	109fe204 	addi	r2,r2,32648
81116d50:	10800d8b 	ldhu	r2,54(r2)
81116d54:	10bfffcc 	andi	r2,r2,65535
81116d58:	108000e8 	cmpgeui	r2,r2,3
81116d5c:	1000221e 	bne	r2,zero,81116de8 <vPusType252run+0x3fc>
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81116d60:	d0e06217 	ldw	r3,-32376(gp)
81116d64:	e0bfff17 	ldw	r2,-4(fp)
81116d68:	10800b0b 	ldhu	r2,44(r2)
81116d6c:	113fffcc 	andi	r4,r2,65535
81116d70:	e0bfff17 	ldw	r2,-4(fp)
81116d74:	1080098b 	ldhu	r2,38(r2)
81116d78:	10bfffcc 	andi	r2,r2,65535
81116d7c:	100f883a 	mov	r7,r2
81116d80:	200d883a 	mov	r6,r4
81116d84:	01604574 	movhi	r5,33045
81116d88:	297ceb04 	addi	r5,r5,-3156
81116d8c:	1809883a 	mov	r4,r3
81116d90:	112292c0 	call	8112292c <fprintf>
			}
			#endif
			break;
81116d94:	00001406 	br	81116de8 <vPusType252run+0x3fc>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81116d98:	00a045b4 	movhi	r2,33046
81116d9c:	109fe204 	addi	r2,r2,32648
81116da0:	10800d8b 	ldhu	r2,54(r2)
81116da4:	10bfffcc 	andi	r2,r2,65535
81116da8:	10800168 	cmpgeui	r2,r2,5
81116dac:	1000101e 	bne	r2,zero,81116df0 <vPusType252run+0x404>
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81116db0:	d0a06217 	ldw	r2,-32376(gp)
81116db4:	100f883a 	mov	r7,r2
81116db8:	01800c84 	movi	r6,50
81116dbc:	01400044 	movi	r5,1
81116dc0:	01204574 	movhi	r4,33045
81116dc4:	213d0804 	addi	r4,r4,-3040
81116dc8:	1122fc80 	call	81122fc8 <fwrite>
			}
			#endif
			break;
81116dcc:	00000806 	br	81116df0 <vPusType252run+0x404>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
81116dd0:	0001883a 	nop
81116dd4:	00000706 	br	81116df4 <vPusType252run+0x408>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
			}
			#endif

			break;
81116dd8:	0001883a 	nop
81116ddc:	00000506 	br	81116df4 <vPusType252run+0x408>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
			}
			#endif

			break;
81116de0:	0001883a 	nop
81116de4:	00000306 	br	81116df4 <vPusType252run+0x408>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			}
			#endif
			break;
81116de8:	0001883a 	nop
81116dec:	00000106 	br	81116df4 <vPusType252run+0x408>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
81116df0:	0001883a 	nop
	}
}
81116df4:	0001883a 	nop
81116df8:	e037883a 	mov	sp,fp
81116dfc:	dfc00117 	ldw	ra,4(sp)
81116e00:	df000017 	ldw	fp,0(sp)
81116e04:	dec00204 	addi	sp,sp,8
81116e08:	f800283a 	ret

81116e0c <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81116e0c:	defff904 	addi	sp,sp,-28
81116e10:	de00012e 	bgeu	sp,et,81116e18 <vSendCmdQToNFeeCTRL+0xc>
81116e14:	003b68fa 	trap	3
81116e18:	dfc00615 	stw	ra,24(sp)
81116e1c:	df000515 	stw	fp,20(sp)
81116e20:	df000504 	addi	fp,sp,20
81116e24:	2807883a 	mov	r3,r5
81116e28:	3005883a 	mov	r2,r6
81116e2c:	e13ffd05 	stb	r4,-12(fp)
81116e30:	e0fffe05 	stb	r3,-8(fp)
81116e34:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81116e38:	00800404 	movi	r2,16
81116e3c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81116e40:	e0bffd03 	ldbu	r2,-12(fp)
81116e44:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116e48:	e0bffe03 	ldbu	r2,-8(fp)
81116e4c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81116e50:	e0bfff03 	ldbu	r2,-4(fp)
81116e54:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81116e58:	d0a07017 	ldw	r2,-32320(gp)
81116e5c:	e0fffc17 	ldw	r3,-16(fp)
81116e60:	180b883a 	mov	r5,r3
81116e64:	1009883a 	mov	r4,r2
81116e68:	113f2dc0 	call	8113f2dc <OSQPost>
81116e6c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81116e70:	e0bffb03 	ldbu	r2,-20(fp)
81116e74:	10000126 	beq	r2,zero,81116e7c <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
81116e78:	111e9540 	call	8111e954 <vFailSendMsgFeeCTRL>
	}
}
81116e7c:	0001883a 	nop
81116e80:	e037883a 	mov	sp,fp
81116e84:	dfc00117 	ldw	ra,4(sp)
81116e88:	df000017 	ldw	fp,0(sp)
81116e8c:	dec00204 	addi	sp,sp,8
81116e90:	f800283a 	ret

81116e94 <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81116e94:	defff904 	addi	sp,sp,-28
81116e98:	de00012e 	bgeu	sp,et,81116ea0 <vSendCmdQToNFeeCTRL_PRIO+0xc>
81116e9c:	003b68fa 	trap	3
81116ea0:	dfc00615 	stw	ra,24(sp)
81116ea4:	df000515 	stw	fp,20(sp)
81116ea8:	df000504 	addi	fp,sp,20
81116eac:	2807883a 	mov	r3,r5
81116eb0:	3005883a 	mov	r2,r6
81116eb4:	e13ffd05 	stb	r4,-12(fp)
81116eb8:	e0fffe05 	stb	r3,-8(fp)
81116ebc:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81116ec0:	00800404 	movi	r2,16
81116ec4:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81116ec8:	e0bffd03 	ldbu	r2,-12(fp)
81116ecc:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116ed0:	e0bffe03 	ldbu	r2,-8(fp)
81116ed4:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81116ed8:	e0bfff03 	ldbu	r2,-4(fp)
81116edc:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81116ee0:	d0a07017 	ldw	r2,-32320(gp)
81116ee4:	e0fffc17 	ldw	r3,-16(fp)
81116ee8:	180b883a 	mov	r5,r3
81116eec:	1009883a 	mov	r4,r2
81116ef0:	113f44c0 	call	8113f44c <OSQPostFront>
81116ef4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81116ef8:	e0bffb03 	ldbu	r2,-20(fp)
81116efc:	10000126 	beq	r2,zero,81116f04 <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81116f00:	111e9540 	call	8111e954 <vFailSendMsgFeeCTRL>
	}
}
81116f04:	0001883a 	nop
81116f08:	e037883a 	mov	sp,fp
81116f0c:	dfc00117 	ldw	ra,4(sp)
81116f10:	df000017 	ldw	fp,0(sp)
81116f14:	dec00204 	addi	sp,sp,8
81116f18:	f800283a 	ret

81116f1c <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81116f1c:	defff804 	addi	sp,sp,-32
81116f20:	de00012e 	bgeu	sp,et,81116f28 <vSendCmdQToNFeeCTRL_GEN+0xc>
81116f24:	003b68fa 	trap	3
81116f28:	dfc00715 	stw	ra,28(sp)
81116f2c:	df000615 	stw	fp,24(sp)
81116f30:	df000604 	addi	fp,sp,24
81116f34:	2011883a 	mov	r8,r4
81116f38:	2809883a 	mov	r4,r5
81116f3c:	3007883a 	mov	r3,r6
81116f40:	3805883a 	mov	r2,r7
81116f44:	e23ffc05 	stb	r8,-16(fp)
81116f48:	e13ffd05 	stb	r4,-12(fp)
81116f4c:	e0fffe05 	stb	r3,-8(fp)
81116f50:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
81116f54:	e0bffc03 	ldbu	r2,-16(fp)
81116f58:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81116f5c:	e0bffd03 	ldbu	r2,-12(fp)
81116f60:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116f64:	e0bffe03 	ldbu	r2,-8(fp)
81116f68:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81116f6c:	e0bfff03 	ldbu	r2,-4(fp)
81116f70:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81116f74:	d0a07017 	ldw	r2,-32320(gp)
81116f78:	e0fffb17 	ldw	r3,-20(fp)
81116f7c:	180b883a 	mov	r5,r3
81116f80:	1009883a 	mov	r4,r2
81116f84:	113f2dc0 	call	8113f2dc <OSQPost>
81116f88:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81116f8c:	e0bffa03 	ldbu	r2,-24(fp)
81116f90:	10000126 	beq	r2,zero,81116f98 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
81116f94:	111e9540 	call	8111e954 <vFailSendMsgFeeCTRL>
	}
}
81116f98:	0001883a 	nop
81116f9c:	e037883a 	mov	sp,fp
81116fa0:	dfc00117 	ldw	ra,4(sp)
81116fa4:	df000017 	ldw	fp,0(sp)
81116fa8:	dec00204 	addi	sp,sp,8
81116fac:	f800283a 	ret

81116fb0 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81116fb0:	defff904 	addi	sp,sp,-28
81116fb4:	de00012e 	bgeu	sp,et,81116fbc <vSendCmdQToDataCTRL+0xc>
81116fb8:	003b68fa 	trap	3
81116fbc:	dfc00615 	stw	ra,24(sp)
81116fc0:	df000515 	stw	fp,20(sp)
81116fc4:	df000504 	addi	fp,sp,20
81116fc8:	2807883a 	mov	r3,r5
81116fcc:	3005883a 	mov	r2,r6
81116fd0:	e13ffd05 	stb	r4,-12(fp)
81116fd4:	e0fffe05 	stb	r3,-8(fp)
81116fd8:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81116fdc:	00800804 	movi	r2,32
81116fe0:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81116fe4:	e0bffd03 	ldbu	r2,-12(fp)
81116fe8:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116fec:	e0bffe03 	ldbu	r2,-8(fp)
81116ff0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81116ff4:	e0bfff03 	ldbu	r2,-4(fp)
81116ff8:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81116ffc:	d0a05f17 	ldw	r2,-32388(gp)
81117000:	e0fffc17 	ldw	r3,-16(fp)
81117004:	180b883a 	mov	r5,r3
81117008:	1009883a 	mov	r4,r2
8111700c:	113f2dc0 	call	8113f2dc <OSQPost>
81117010:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81117014:	e0bffb03 	ldbu	r2,-20(fp)
81117018:	10000126 	beq	r2,zero,81117020 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
8111701c:	111e9b80 	call	8111e9b8 <vFailSendMsgDataCTRL>
	}
}
81117020:	0001883a 	nop
81117024:	e037883a 	mov	sp,fp
81117028:	dfc00117 	ldw	ra,4(sp)
8111702c:	df000017 	ldw	fp,0(sp)
81117030:	dec00204 	addi	sp,sp,8
81117034:	f800283a 	ret

81117038 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81117038:	defff904 	addi	sp,sp,-28
8111703c:	de00012e 	bgeu	sp,et,81117044 <vSendCmdQToDataCTRL_PRIO+0xc>
81117040:	003b68fa 	trap	3
81117044:	dfc00615 	stw	ra,24(sp)
81117048:	df000515 	stw	fp,20(sp)
8111704c:	df000504 	addi	fp,sp,20
81117050:	2807883a 	mov	r3,r5
81117054:	3005883a 	mov	r2,r6
81117058:	e13ffd05 	stb	r4,-12(fp)
8111705c:	e0fffe05 	stb	r3,-8(fp)
81117060:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81117064:	00800404 	movi	r2,16
81117068:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111706c:	e0bffd03 	ldbu	r2,-12(fp)
81117070:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81117074:	e0bffe03 	ldbu	r2,-8(fp)
81117078:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111707c:	e0bfff03 	ldbu	r2,-4(fp)
81117080:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81117084:	d0a05f17 	ldw	r2,-32388(gp)
81117088:	e0fffc17 	ldw	r3,-16(fp)
8111708c:	180b883a 	mov	r5,r3
81117090:	1009883a 	mov	r4,r2
81117094:	113f44c0 	call	8113f44c <OSQPostFront>
81117098:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111709c:	e0bffb03 	ldbu	r2,-20(fp)
811170a0:	10000126 	beq	r2,zero,811170a8 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
811170a4:	111e9540 	call	8111e954 <vFailSendMsgFeeCTRL>
	}
}
811170a8:	0001883a 	nop
811170ac:	e037883a 	mov	sp,fp
811170b0:	dfc00117 	ldw	ra,4(sp)
811170b4:	df000017 	ldw	fp,0(sp)
811170b8:	dec00204 	addi	sp,sp,8
811170bc:	f800283a 	ret

811170c0 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
811170c0:	defffc04 	addi	sp,sp,-16
811170c4:	de00012e 	bgeu	sp,et,811170cc <vMebInit+0xc>
811170c8:	003b68fa 	trap	3
811170cc:	dfc00315 	stw	ra,12(sp)
811170d0:	df000215 	stw	fp,8(sp)
811170d4:	df000204 	addi	fp,sp,8
811170d8:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
811170dc:	e0bfff17 	ldw	r2,-4(fp)
811170e0:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
811170e4:	e0bfff17 	ldw	r2,-4(fp)
811170e8:	00c00044 	movi	r3,1
811170ec:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
811170f0:	d0a06917 	ldw	r2,-32348(gp)
811170f4:	1009883a 	mov	r4,r2
811170f8:	113ee140 	call	8113ee14 <OSQFlush>
811170fc:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
81117100:	e0bffe03 	ldbu	r2,-8(fp)
81117104:	10000126 	beq	r2,zero,8111710c <vMebInit+0x4c>
		vFailFlushMEBQueue();
81117108:	111eae40 	call	8111eae4 <vFailFlushMEBQueue>
	}
}
8111710c:	0001883a 	nop
81117110:	e037883a 	mov	sp,fp
81117114:	dfc00117 	ldw	ra,4(sp)
81117118:	df000017 	ldw	fp,0(sp)
8111711c:	dec00204 	addi	sp,sp,8
81117120:	f800283a 	ret

81117124 <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
81117124:	defffe04 	addi	sp,sp,-8
81117128:	de00012e 	bgeu	sp,et,81117130 <vSwapMemmory+0xc>
8111712c:	003b68fa 	trap	3
81117130:	df000115 	stw	fp,4(sp)
81117134:	df000104 	addi	fp,sp,4
81117138:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
8111713c:	e0bfff17 	ldw	r2,-4(fp)
81117140:	10800203 	ldbu	r2,8(r2)
81117144:	10803fcc 	andi	r2,r2,255
81117148:	10c00044 	addi	r3,r2,1
8111714c:	00a00034 	movhi	r2,32768
81117150:	10800044 	addi	r2,r2,1
81117154:	1884703a 	and	r2,r3,r2
81117158:	1000040e 	bge	r2,zero,8111716c <vSwapMemmory+0x48>
8111715c:	10bfffc4 	addi	r2,r2,-1
81117160:	00ffff84 	movi	r3,-2
81117164:	10c4b03a 	or	r2,r2,r3
81117168:	10800044 	addi	r2,r2,1
8111716c:	1007883a 	mov	r3,r2
81117170:	e0bfff17 	ldw	r2,-4(fp)
81117174:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
81117178:	e0bfff17 	ldw	r2,-4(fp)
8111717c:	10800243 	ldbu	r2,9(r2)
81117180:	10803fcc 	andi	r2,r2,255
81117184:	10c00044 	addi	r3,r2,1
81117188:	00a00034 	movhi	r2,32768
8111718c:	10800044 	addi	r2,r2,1
81117190:	1884703a 	and	r2,r3,r2
81117194:	1000040e 	bge	r2,zero,811171a8 <vSwapMemmory+0x84>
81117198:	10bfffc4 	addi	r2,r2,-1
8111719c:	00ffff84 	movi	r3,-2
811171a0:	10c4b03a 	or	r2,r2,r3
811171a4:	10800044 	addi	r2,r2,1
811171a8:	1007883a 	mov	r3,r2
811171ac:	e0bfff17 	ldw	r2,-4(fp)
811171b0:	10c00245 	stb	r3,9(r2)

}
811171b4:	0001883a 	nop
811171b8:	e037883a 	mov	sp,fp
811171bc:	df000017 	ldw	fp,0(sp)
811171c0:	dec00104 	addi	sp,sp,4
811171c4:	f800283a 	ret

811171c8 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
811171c8:	defffc04 	addi	sp,sp,-16
811171cc:	de00012e 	bgeu	sp,et,811171d4 <vReleaseSyncMessages+0xc>
811171d0:	003b68fa 	trap	3
811171d4:	dfc00315 	stw	ra,12(sp)
811171d8:	df000215 	stw	fp,8(sp)
811171dc:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
811171e0:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
811171e4:	00bff844 	movi	r2,-31
811171e8:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
811171ec:	e03ffe05 	stb	zero,-8(fp)
811171f0:	00001606 	br	8111724c <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
811171f4:	e0bffe03 	ldbu	r2,-8(fp)
811171f8:	10800444 	addi	r2,r2,17
811171fc:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
81117200:	e0bffe03 	ldbu	r2,-8(fp)
81117204:	1085883a 	add	r2,r2,r2
81117208:	1087883a 	add	r3,r2,r2
8111720c:	d0a05c04 	addi	r2,gp,-32400
81117210:	1885883a 	add	r2,r3,r2
81117214:	10800017 	ldw	r2,0(r2)
81117218:	e0ffff17 	ldw	r3,-4(fp)
8111721c:	180b883a 	mov	r5,r3
81117220:	1009883a 	mov	r4,r2
81117224:	113f2dc0 	call	8113f2dc <OSQPost>
81117228:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
8111722c:	e0bffe43 	ldbu	r2,-7(fp)
81117230:	10000326 	beq	r2,zero,81117240 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
81117234:	e0bffe03 	ldbu	r2,-8(fp)
81117238:	1009883a 	mov	r4,r2
8111723c:	111e8180 	call	8111e818 <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81117240:	e0bffe03 	ldbu	r2,-8(fp)
81117244:	10800044 	addi	r2,r2,1
81117248:	e0bffe05 	stb	r2,-8(fp)
8111724c:	e0bffe03 	ldbu	r2,-8(fp)
81117250:	103fe826 	beq	r2,zero,811171f4 <__reset+0xfb0f71f4>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
81117254:	0001883a 	nop
81117258:	e037883a 	mov	sp,fp
8111725c:	dfc00117 	ldw	ra,4(sp)
81117260:	df000017 	ldw	fp,0(sp)
81117264:	dec00204 	addi	sp,sp,8
81117268:	f800283a 	ret

8111726c <vStackMonitor>:
    }
}

#else
#if DEBUG_ON
void vStackMonitor(void *task_data) {
8111726c:	defff804 	addi	sp,sp,-32
81117270:	de00012e 	bgeu	sp,et,81117278 <vStackMonitor+0xc>
81117274:	003b68fa 	trap	3
81117278:	dfc00715 	stw	ra,28(sp)
8111727c:	df000615 	stw	fp,24(sp)
81117280:	df000604 	addi	fp,sp,24
81117284:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81117288:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
8111728c:	d0a06217 	ldw	r2,-32376(gp)
81117290:	100f883a 	mov	r7,r2
81117294:	018006c4 	movi	r6,27
81117298:	01400044 	movi	r5,1
8111729c:	01204574 	movhi	r4,33045
811172a0:	213d4804 	addi	r4,r4,-2784
811172a4:	1122fc80 	call	81122fc8 <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
811172a8:	d0a06217 	ldw	r2,-32376(gp)
811172ac:	100f883a 	mov	r7,r2
811172b0:	01800b04 	movi	r6,44
811172b4:	01400044 	movi	r5,1
811172b8:	01204574 	movhi	r4,33045
811172bc:	213d4f04 	addi	r4,r4,-2756
811172c0:	1122fc80 	call	81122fc8 <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
811172c4:	d0a06217 	ldw	r2,-32376(gp)
811172c8:	100f883a 	mov	r7,r2
811172cc:	01800f84 	movi	r6,62
811172d0:	01400044 	movi	r5,1
811172d4:	01204574 	movhi	r4,33045
811172d8:	213d5b04 	addi	r4,r4,-2708
811172dc:	1122fc80 	call	81122fc8 <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
811172e0:	e0bffd04 	addi	r2,fp,-12
811172e4:	100b883a 	mov	r5,r2
811172e8:	01000804 	movi	r4,32
811172ec:	11417000 	call	81141700 <OSTaskStkChk>
811172f0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
811172f4:	e0bffc03 	ldbu	r2,-16(fp)
811172f8:	10000f1e 	bne	r2,zero,81117338 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811172fc:	d1206217 	ldw	r4,-32376(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
81117300:	e0fffd17 	ldw	r3,-12(fp)
81117304:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117308:	188b883a 	add	r5,r3,r2
8111730c:	e0bffd17 	ldw	r2,-12(fp)
81117310:	e0fffe17 	ldw	r3,-8(fp)
81117314:	d8c00115 	stw	r3,4(sp)
81117318:	d8800015 	stw	r2,0(sp)
8111731c:	280f883a 	mov	r7,r5
81117320:	01a04574 	movhi	r6,33045
81117324:	31bd6b04 	addi	r6,r6,-2644
81117328:	01604574 	movhi	r5,33045
8111732c:	297d6f04 	addi	r5,r5,-2628
81117330:	112292c0 	call	8112292c <fprintf>
81117334:	00000706 	br	81117354 <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81117338:	d0a06217 	ldw	r2,-32376(gp)
8111733c:	100f883a 	mov	r7,r2
81117340:	01800904 	movi	r6,36
81117344:	01400044 	movi	r5,1
81117348:	01204574 	movhi	r4,33045
8111734c:	213d7e04 	addi	r4,r4,-2568
81117350:	1122fc80 	call	81122fc8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
81117354:	e0bffd04 	addi	r2,fp,-12
81117358:	100b883a 	mov	r5,r2
8111735c:	01000784 	movi	r4,30
81117360:	11417000 	call	81141700 <OSTaskStkChk>
81117364:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117368:	e0bffc03 	ldbu	r2,-16(fp)
8111736c:	10000f1e 	bne	r2,zero,811173ac <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117370:	d1206217 	ldw	r4,-32376(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
81117374:	e0fffd17 	ldw	r3,-12(fp)
81117378:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111737c:	188b883a 	add	r5,r3,r2
81117380:	e0bffd17 	ldw	r2,-12(fp)
81117384:	e0fffe17 	ldw	r3,-8(fp)
81117388:	d8c00115 	stw	r3,4(sp)
8111738c:	d8800015 	stw	r2,0(sp)
81117390:	280f883a 	mov	r7,r5
81117394:	01a04574 	movhi	r6,33045
81117398:	31bd8804 	addi	r6,r6,-2528
8111739c:	01604574 	movhi	r5,33045
811173a0:	297d6f04 	addi	r5,r5,-2628
811173a4:	112292c0 	call	8112292c <fprintf>
811173a8:	00000706 	br	811173c8 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
811173ac:	d0a06217 	ldw	r2,-32376(gp)
811173b0:	100f883a 	mov	r7,r2
811173b4:	01800984 	movi	r6,38
811173b8:	01400044 	movi	r5,1
811173bc:	01204574 	movhi	r4,33045
811173c0:	213d8c04 	addi	r4,r4,-2512
811173c4:	1122fc80 	call	81122fc8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
811173c8:	e0bffd04 	addi	r2,fp,-12
811173cc:	100b883a 	mov	r5,r2
811173d0:	01000704 	movi	r4,28
811173d4:	11417000 	call	81141700 <OSTaskStkChk>
811173d8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811173dc:	e0bffc03 	ldbu	r2,-16(fp)
811173e0:	10000f1e 	bne	r2,zero,81117420 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811173e4:	d1206217 	ldw	r4,-32376(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
811173e8:	e0fffd17 	ldw	r3,-12(fp)
811173ec:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811173f0:	188b883a 	add	r5,r3,r2
811173f4:	e0bffd17 	ldw	r2,-12(fp)
811173f8:	e0fffe17 	ldw	r3,-8(fp)
811173fc:	d8c00115 	stw	r3,4(sp)
81117400:	d8800015 	stw	r2,0(sp)
81117404:	280f883a 	mov	r7,r5
81117408:	01a04574 	movhi	r6,33045
8111740c:	31bd9604 	addi	r6,r6,-2472
81117410:	01604574 	movhi	r5,33045
81117414:	297d6f04 	addi	r5,r5,-2628
81117418:	112292c0 	call	8112292c <fprintf>
8111741c:	00000706 	br	8111743c <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
81117420:	d0a06217 	ldw	r2,-32376(gp)
81117424:	100f883a 	mov	r7,r2
81117428:	01800884 	movi	r6,34
8111742c:	01400044 	movi	r5,1
81117430:	01204574 	movhi	r4,33045
81117434:	213d9904 	addi	r4,r4,-2460
81117438:	1122fc80 	call	81122fc8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
8111743c:	e0bffd04 	addi	r2,fp,-12
81117440:	100b883a 	mov	r5,r2
81117444:	010006c4 	movi	r4,27
81117448:	11417000 	call	81141700 <OSTaskStkChk>
8111744c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117450:	e0bffc03 	ldbu	r2,-16(fp)
81117454:	10000f1e 	bne	r2,zero,81117494 <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117458:	d1206217 	ldw	r4,-32376(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
8111745c:	e0fffd17 	ldw	r3,-12(fp)
81117460:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117464:	188b883a 	add	r5,r3,r2
81117468:	e0bffd17 	ldw	r2,-12(fp)
8111746c:	e0fffe17 	ldw	r3,-8(fp)
81117470:	d8c00115 	stw	r3,4(sp)
81117474:	d8800015 	stw	r2,0(sp)
81117478:	280f883a 	mov	r7,r5
8111747c:	01a04574 	movhi	r6,33045
81117480:	31bda204 	addi	r6,r6,-2424
81117484:	01604574 	movhi	r5,33045
81117488:	297d6f04 	addi	r5,r5,-2628
8111748c:	112292c0 	call	8112292c <fprintf>
81117490:	00000706 	br	811174b0 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
81117494:	d0a06217 	ldw	r2,-32376(gp)
81117498:	100f883a 	mov	r7,r2
8111749c:	018008c4 	movi	r6,35
811174a0:	01400044 	movi	r5,1
811174a4:	01204574 	movhi	r4,33045
811174a8:	213da604 	addi	r4,r4,-2408
811174ac:	1122fc80 	call	81122fc8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
811174b0:	e0bffd04 	addi	r2,fp,-12
811174b4:	100b883a 	mov	r5,r2
811174b8:	01000684 	movi	r4,26
811174bc:	11417000 	call	81141700 <OSTaskStkChk>
811174c0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811174c4:	e0bffc03 	ldbu	r2,-16(fp)
811174c8:	10000f1e 	bne	r2,zero,81117508 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811174cc:	d1206217 	ldw	r4,-32376(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
811174d0:	e0fffd17 	ldw	r3,-12(fp)
811174d4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811174d8:	188b883a 	add	r5,r3,r2
811174dc:	e0bffd17 	ldw	r2,-12(fp)
811174e0:	e0fffe17 	ldw	r3,-8(fp)
811174e4:	d8c00115 	stw	r3,4(sp)
811174e8:	d8800015 	stw	r2,0(sp)
811174ec:	280f883a 	mov	r7,r5
811174f0:	01a04574 	movhi	r6,33045
811174f4:	31bdaf04 	addi	r6,r6,-2372
811174f8:	01604574 	movhi	r5,33045
811174fc:	297d6f04 	addi	r5,r5,-2628
81117500:	112292c0 	call	8112292c <fprintf>
81117504:	00000706 	br	81117524 <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
81117508:	d0a06217 	ldw	r2,-32376(gp)
8111750c:	100f883a 	mov	r7,r2
81117510:	01800884 	movi	r6,34
81117514:	01400044 	movi	r5,1
81117518:	01204574 	movhi	r4,33045
8111751c:	213db204 	addi	r4,r4,-2360
81117520:	1122fc80 	call	81122fc8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
81117524:	e0bffd04 	addi	r2,fp,-12
81117528:	100b883a 	mov	r5,r2
8111752c:	01000644 	movi	r4,25
81117530:	11417000 	call	81141700 <OSTaskStkChk>
81117534:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117538:	e0bffc03 	ldbu	r2,-16(fp)
8111753c:	10000f1e 	bne	r2,zero,8111757c <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117540:	d1206217 	ldw	r4,-32376(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
81117544:	e0fffd17 	ldw	r3,-12(fp)
81117548:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111754c:	188b883a 	add	r5,r3,r2
81117550:	e0bffd17 	ldw	r2,-12(fp)
81117554:	e0fffe17 	ldw	r3,-8(fp)
81117558:	d8c00115 	stw	r3,4(sp)
8111755c:	d8800015 	stw	r2,0(sp)
81117560:	280f883a 	mov	r7,r5
81117564:	01a04574 	movhi	r6,33045
81117568:	31bdbb04 	addi	r6,r6,-2324
8111756c:	01604574 	movhi	r5,33045
81117570:	297d6f04 	addi	r5,r5,-2628
81117574:	112292c0 	call	8112292c <fprintf>
81117578:	00000706 	br	81117598 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
8111757c:	d0a06217 	ldw	r2,-32376(gp)
81117580:	100f883a 	mov	r7,r2
81117584:	01800884 	movi	r6,34
81117588:	01400044 	movi	r5,1
8111758c:	01204574 	movhi	r4,33045
81117590:	213dbe04 	addi	r4,r4,-2312
81117594:	1122fc80 	call	81122fc8 <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
81117598:	e0bffd04 	addi	r2,fp,-12
8111759c:	100b883a 	mov	r5,r2
811175a0:	01000044 	movi	r4,1
811175a4:	11417000 	call	81141700 <OSTaskStkChk>
811175a8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811175ac:	e0bffc03 	ldbu	r2,-16(fp)
811175b0:	10000f1e 	bne	r2,zero,811175f0 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811175b4:	d1206217 	ldw	r4,-32376(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
811175b8:	e0fffd17 	ldw	r3,-12(fp)
811175bc:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811175c0:	188b883a 	add	r5,r3,r2
811175c4:	e0bffd17 	ldw	r2,-12(fp)
811175c8:	e0fffe17 	ldw	r3,-8(fp)
811175cc:	d8c00115 	stw	r3,4(sp)
811175d0:	d8800015 	stw	r2,0(sp)
811175d4:	280f883a 	mov	r7,r5
811175d8:	01a04574 	movhi	r6,33045
811175dc:	31bdc704 	addi	r6,r6,-2276
811175e0:	01604574 	movhi	r5,33045
811175e4:	297d6f04 	addi	r5,r5,-2628
811175e8:	112292c0 	call	8112292c <fprintf>
811175ec:	00000706 	br	8111760c <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
811175f0:	d0a06217 	ldw	r2,-32376(gp)
811175f4:	100f883a 	mov	r7,r2
811175f8:	01800804 	movi	r6,32
811175fc:	01400044 	movi	r5,1
81117600:	01204574 	movhi	r4,33045
81117604:	213dca04 	addi	r4,r4,-2264
81117608:	1122fc80 	call	81122fc8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
8111760c:	e0bffd04 	addi	r2,fp,-12
81117610:	100b883a 	mov	r5,r2
81117614:	010002c4 	movi	r4,11
81117618:	11417000 	call	81141700 <OSTaskStkChk>
8111761c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117620:	e0bffc03 	ldbu	r2,-16(fp)
81117624:	10000f1e 	bne	r2,zero,81117664 <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117628:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
8111762c:	e0fffd17 	ldw	r3,-12(fp)
81117630:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117634:	188b883a 	add	r5,r3,r2
81117638:	e0bffd17 	ldw	r2,-12(fp)
8111763c:	e0fffe17 	ldw	r3,-8(fp)
81117640:	d8c00115 	stw	r3,4(sp)
81117644:	d8800015 	stw	r2,0(sp)
81117648:	280f883a 	mov	r7,r5
8111764c:	01a04574 	movhi	r6,33045
81117650:	31bdd304 	addi	r6,r6,-2228
81117654:	01604574 	movhi	r5,33045
81117658:	297d6f04 	addi	r5,r5,-2628
8111765c:	112292c0 	call	8112292c <fprintf>
81117660:	00000706 	br	81117680 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
81117664:	d0a06217 	ldw	r2,-32376(gp)
81117668:	100f883a 	mov	r7,r2
8111766c:	018008c4 	movi	r6,35
81117670:	01400044 	movi	r5,1
81117674:	01204574 	movhi	r4,33045
81117678:	213dd604 	addi	r4,r4,-2216
8111767c:	1122fc80 	call	81122fc8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
81117680:	e0bffd04 	addi	r2,fp,-12
81117684:	100b883a 	mov	r5,r2
81117688:	01000304 	movi	r4,12
8111768c:	11417000 	call	81141700 <OSTaskStkChk>
81117690:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117694:	e0bffc03 	ldbu	r2,-16(fp)
81117698:	10000f1e 	bne	r2,zero,811176d8 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111769c:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
811176a0:	e0fffd17 	ldw	r3,-12(fp)
811176a4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811176a8:	188b883a 	add	r5,r3,r2
811176ac:	e0bffd17 	ldw	r2,-12(fp)
811176b0:	e0fffe17 	ldw	r3,-8(fp)
811176b4:	d8c00115 	stw	r3,4(sp)
811176b8:	d8800015 	stw	r2,0(sp)
811176bc:	280f883a 	mov	r7,r5
811176c0:	01a04574 	movhi	r6,33045
811176c4:	31bddf04 	addi	r6,r6,-2180
811176c8:	01604574 	movhi	r5,33045
811176cc:	297d6f04 	addi	r5,r5,-2628
811176d0:	112292c0 	call	8112292c <fprintf>
811176d4:	00000706 	br	811176f4 <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
811176d8:	d0a06217 	ldw	r2,-32376(gp)
811176dc:	100f883a 	mov	r7,r2
811176e0:	018008c4 	movi	r6,35
811176e4:	01400044 	movi	r5,1
811176e8:	01204574 	movhi	r4,33045
811176ec:	213de204 	addi	r4,r4,-2168
811176f0:	1122fc80 	call	81122fc8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
811176f4:	e0bffd04 	addi	r2,fp,-12
811176f8:	100b883a 	mov	r5,r2
811176fc:	01000344 	movi	r4,13
81117700:	11417000 	call	81141700 <OSTaskStkChk>
81117704:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117708:	e0bffc03 	ldbu	r2,-16(fp)
8111770c:	10000f1e 	bne	r2,zero,8111774c <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117710:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
81117714:	e0fffd17 	ldw	r3,-12(fp)
81117718:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111771c:	188b883a 	add	r5,r3,r2
81117720:	e0bffd17 	ldw	r2,-12(fp)
81117724:	e0fffe17 	ldw	r3,-8(fp)
81117728:	d8c00115 	stw	r3,4(sp)
8111772c:	d8800015 	stw	r2,0(sp)
81117730:	280f883a 	mov	r7,r5
81117734:	01a04574 	movhi	r6,33045
81117738:	31bdeb04 	addi	r6,r6,-2132
8111773c:	01604574 	movhi	r5,33045
81117740:	297d6f04 	addi	r5,r5,-2628
81117744:	112292c0 	call	8112292c <fprintf>
81117748:	00000706 	br	81117768 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
8111774c:	d0a06217 	ldw	r2,-32376(gp)
81117750:	100f883a 	mov	r7,r2
81117754:	018008c4 	movi	r6,35
81117758:	01400044 	movi	r5,1
8111775c:	01204574 	movhi	r4,33045
81117760:	213dee04 	addi	r4,r4,-2120
81117764:	1122fc80 	call	81122fc8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
81117768:	e0bffd04 	addi	r2,fp,-12
8111776c:	100b883a 	mov	r5,r2
81117770:	01000384 	movi	r4,14
81117774:	11417000 	call	81141700 <OSTaskStkChk>
81117778:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111777c:	e0bffc03 	ldbu	r2,-16(fp)
81117780:	10000f1e 	bne	r2,zero,811177c0 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117784:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
81117788:	e0fffd17 	ldw	r3,-12(fp)
8111778c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117790:	188b883a 	add	r5,r3,r2
81117794:	e0bffd17 	ldw	r2,-12(fp)
81117798:	e0fffe17 	ldw	r3,-8(fp)
8111779c:	d8c00115 	stw	r3,4(sp)
811177a0:	d8800015 	stw	r2,0(sp)
811177a4:	280f883a 	mov	r7,r5
811177a8:	01a04574 	movhi	r6,33045
811177ac:	31bdf704 	addi	r6,r6,-2084
811177b0:	01604574 	movhi	r5,33045
811177b4:	297d6f04 	addi	r5,r5,-2628
811177b8:	112292c0 	call	8112292c <fprintf>
811177bc:	00000706 	br	811177dc <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
811177c0:	d0a06217 	ldw	r2,-32376(gp)
811177c4:	100f883a 	mov	r7,r2
811177c8:	018008c4 	movi	r6,35
811177cc:	01400044 	movi	r5,1
811177d0:	01204574 	movhi	r4,33045
811177d4:	213dfa04 	addi	r4,r4,-2072
811177d8:	1122fc80 	call	81122fc8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
811177dc:	e0bffd04 	addi	r2,fp,-12
811177e0:	100b883a 	mov	r5,r2
811177e4:	010003c4 	movi	r4,15
811177e8:	11417000 	call	81141700 <OSTaskStkChk>
811177ec:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811177f0:	e0bffc03 	ldbu	r2,-16(fp)
811177f4:	10000f1e 	bne	r2,zero,81117834 <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811177f8:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
811177fc:	e0fffd17 	ldw	r3,-12(fp)
81117800:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117804:	188b883a 	add	r5,r3,r2
81117808:	e0bffd17 	ldw	r2,-12(fp)
8111780c:	e0fffe17 	ldw	r3,-8(fp)
81117810:	d8c00115 	stw	r3,4(sp)
81117814:	d8800015 	stw	r2,0(sp)
81117818:	280f883a 	mov	r7,r5
8111781c:	01a04574 	movhi	r6,33045
81117820:	31be0304 	addi	r6,r6,-2036
81117824:	01604574 	movhi	r5,33045
81117828:	297d6f04 	addi	r5,r5,-2628
8111782c:	112292c0 	call	8112292c <fprintf>
81117830:	00000706 	br	81117850 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
81117834:	d0a06217 	ldw	r2,-32376(gp)
81117838:	100f883a 	mov	r7,r2
8111783c:	018008c4 	movi	r6,35
81117840:	01400044 	movi	r5,1
81117844:	01204574 	movhi	r4,33045
81117848:	213e0604 	addi	r4,r4,-2024
8111784c:	1122fc80 	call	81122fc8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81117850:	e0bffd04 	addi	r2,fp,-12
81117854:	100b883a 	mov	r5,r2
81117858:	01000404 	movi	r4,16
8111785c:	11417000 	call	81141700 <OSTaskStkChk>
81117860:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81117864:	e0bffc03 	ldbu	r2,-16(fp)
81117868:	10000f1e 	bne	r2,zero,811178a8 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111786c:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
81117870:	e0fffd17 	ldw	r3,-12(fp)
81117874:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117878:	188b883a 	add	r5,r3,r2
8111787c:	e0bffd17 	ldw	r2,-12(fp)
81117880:	e0fffe17 	ldw	r3,-8(fp)
81117884:	d8c00115 	stw	r3,4(sp)
81117888:	d8800015 	stw	r2,0(sp)
8111788c:	280f883a 	mov	r7,r5
81117890:	01a04574 	movhi	r6,33045
81117894:	31be0f04 	addi	r6,r6,-1988
81117898:	01604574 	movhi	r5,33045
8111789c:	297d6f04 	addi	r5,r5,-2628
811178a0:	112292c0 	call	8112292c <fprintf>
811178a4:	00000706 	br	811178c4 <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
811178a8:	d0a06217 	ldw	r2,-32376(gp)
811178ac:	100f883a 	mov	r7,r2
811178b0:	018008c4 	movi	r6,35
811178b4:	01400044 	movi	r5,1
811178b8:	01204574 	movhi	r4,33045
811178bc:	213e1204 	addi	r4,r4,-1976
811178c0:	1122fc80 	call	81122fc8 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
811178c4:	e0bffd04 	addi	r2,fp,-12
811178c8:	100b883a 	mov	r5,r2
811178cc:	01000284 	movi	r4,10
811178d0:	11417000 	call	81141700 <OSTaskStkChk>
811178d4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811178d8:	e0bffc03 	ldbu	r2,-16(fp)
811178dc:	10000f1e 	bne	r2,zero,8111791c <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811178e0:	d1206217 	ldw	r4,-32376(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
811178e4:	e0fffd17 	ldw	r3,-12(fp)
811178e8:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811178ec:	188b883a 	add	r5,r3,r2
811178f0:	e0bffd17 	ldw	r2,-12(fp)
811178f4:	e0fffe17 	ldw	r3,-8(fp)
811178f8:	d8c00115 	stw	r3,4(sp)
811178fc:	d8800015 	stw	r2,0(sp)
81117900:	280f883a 	mov	r7,r5
81117904:	01a04574 	movhi	r6,33045
81117908:	31be1b04 	addi	r6,r6,-1940
8111790c:	01604574 	movhi	r5,33045
81117910:	297d6f04 	addi	r5,r5,-2628
81117914:	112292c0 	call	8112292c <fprintf>
81117918:	00000706 	br	81117938 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
8111791c:	d0a06217 	ldw	r2,-32376(gp)
81117920:	100f883a 	mov	r7,r2
81117924:	01800884 	movi	r6,34
81117928:	01400044 	movi	r5,1
8111792c:	01204574 	movhi	r4,33045
81117930:	213e1e04 	addi	r4,r4,-1928
81117934:	1122fc80 	call	81122fc8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
81117938:	e0bffd04 	addi	r2,fp,-12
8111793c:	100b883a 	mov	r5,r2
81117940:	01000244 	movi	r4,9
81117944:	11417000 	call	81141700 <OSTaskStkChk>
81117948:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111794c:	e0bffc03 	ldbu	r2,-16(fp)
81117950:	10000f1e 	bne	r2,zero,81117990 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117954:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
81117958:	e0fffd17 	ldw	r3,-12(fp)
8111795c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81117960:	188b883a 	add	r5,r3,r2
81117964:	e0bffd17 	ldw	r2,-12(fp)
81117968:	e0fffe17 	ldw	r3,-8(fp)
8111796c:	d8c00115 	stw	r3,4(sp)
81117970:	d8800015 	stw	r2,0(sp)
81117974:	280f883a 	mov	r7,r5
81117978:	01a04574 	movhi	r6,33045
8111797c:	31be2704 	addi	r6,r6,-1892
81117980:	01604574 	movhi	r5,33045
81117984:	297d6f04 	addi	r5,r5,-2628
81117988:	112292c0 	call	8112292c <fprintf>
8111798c:	00000706 	br	811179ac <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
81117990:	d0a06217 	ldw	r2,-32376(gp)
81117994:	100f883a 	mov	r7,r2
81117998:	01800844 	movi	r6,33
8111799c:	01400044 	movi	r5,1
811179a0:	01204574 	movhi	r4,33045
811179a4:	213e2a04 	addi	r4,r4,-1880
811179a8:	1122fc80 	call	81122fc8 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
811179ac:	e0bffd04 	addi	r2,fp,-12
811179b0:	100b883a 	mov	r5,r2
811179b4:	01000204 	movi	r4,8
811179b8:	11417000 	call	81141700 <OSTaskStkChk>
811179bc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811179c0:	e0bffc03 	ldbu	r2,-16(fp)
811179c4:	10000f1e 	bne	r2,zero,81117a04 <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811179c8:	d1206217 	ldw	r4,-32376(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
811179cc:	e0fffd17 	ldw	r3,-12(fp)
811179d0:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811179d4:	188b883a 	add	r5,r3,r2
811179d8:	e0bffd17 	ldw	r2,-12(fp)
811179dc:	e0fffe17 	ldw	r3,-8(fp)
811179e0:	d8c00115 	stw	r3,4(sp)
811179e4:	d8800015 	stw	r2,0(sp)
811179e8:	280f883a 	mov	r7,r5
811179ec:	01a04574 	movhi	r6,33045
811179f0:	31be3304 	addi	r6,r6,-1844
811179f4:	01604574 	movhi	r5,33045
811179f8:	297d6f04 	addi	r5,r5,-2628
811179fc:	112292c0 	call	8112292c <fprintf>
81117a00:	00000706 	br	81117a20 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
81117a04:	d0a06217 	ldw	r2,-32376(gp)
81117a08:	100f883a 	mov	r7,r2
81117a0c:	018007c4 	movi	r6,31
81117a10:	01400044 	movi	r5,1
81117a14:	01204574 	movhi	r4,33045
81117a18:	213e3604 	addi	r4,r4,-1832
81117a1c:	1122fc80 	call	81122fc8 <fwrite>
    	}		


    	fprintf(fp, "\n" );
81117a20:	d0a06217 	ldw	r2,-32376(gp)
81117a24:	100b883a 	mov	r5,r2
81117a28:	01000284 	movi	r4,10
81117a2c:	11229a40 	call	811229a4 <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
81117a30:	000f883a 	mov	r7,zero
81117a34:	01800284 	movi	r6,10
81117a38:	000b883a 	mov	r5,zero
81117a3c:	0009883a 	mov	r4,zero
81117a40:	1141d640 	call	81141d64 <OSTimeDlyHMSM>
    }
81117a44:	003e1806 	br	811172a8 <__reset+0xfb0f72a8>

81117a48 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
81117a48:	defffc04 	addi	sp,sp,-16
81117a4c:	de00012e 	bgeu	sp,et,81117a54 <vTimeoutCheckerTaskv2+0xc>
81117a50:	003b68fa 	trap	3
81117a54:	dfc00315 	stw	ra,12(sp)
81117a58:	df000215 	stw	fp,8(sp)
81117a5c:	df000204 	addi	fp,sp,8
81117a60:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81117a64:	e03ffe05 	stb	zero,-8(fp)

    #if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81117a68:	00a045b4 	movhi	r2,33046
81117a6c:	109fe204 	addi	r2,r2,32648
81117a70:	10800d8b 	ldhu	r2,54(r2)
81117a74:	10bfffcc 	andi	r2,r2,65535
81117a78:	10800168 	cmpgeui	r2,r2,5
81117a7c:	1000071e 	bne	r2,zero,81117a9c <vTimeoutCheckerTaskv2+0x54>
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
81117a80:	d0a06217 	ldw	r2,-32376(gp)
81117a84:	100f883a 	mov	r7,r2
81117a88:	01800844 	movi	r6,33
81117a8c:	01400044 	movi	r5,1
81117a90:	01204574 	movhi	r4,33045
81117a94:	213e3e04 	addi	r4,r4,-1800
81117a98:	1122fc80 	call	81122fc8 <fwrite>
	}
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
81117a9c:	d0a06717 	ldw	r2,-32356(gp)
81117aa0:	e1bffe04 	addi	r6,fp,-8
81117aa4:	000b883a 	mov	r5,zero
81117aa8:	1009883a 	mov	r4,r2
81117aac:	113fdcc0 	call	8113fdcc <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
81117ab0:	e0bffe03 	ldbu	r2,-8(fp)
81117ab4:	10803fcc 	andi	r2,r2,255
81117ab8:	1000021e 	bne	r2,zero,81117ac4 <vTimeoutCheckerTaskv2+0x7c>
            /* Just check the restransmission buffer */
            vCheck();
81117abc:	1117acc0 	call	81117acc <vCheck>
81117ac0:	003ff606 	br	81117a9c <__reset+0xfb0f7a9c>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
81117ac4:	111d6780 	call	8111d678 <vFailGetBlockingSemTimeoutTask>
        }
    }
81117ac8:	003ff406 	br	81117a9c <__reset+0xfb0f7a9c>

81117acc <vCheck>:
}


void vCheck( void ) {
81117acc:	defffd04 	addi	sp,sp,-12
81117ad0:	de00012e 	bgeu	sp,et,81117ad8 <vCheck+0xc>
81117ad4:	003b68fa 	trap	3
81117ad8:	dfc00215 	stw	ra,8(sp)
81117adc:	df000115 	stw	fp,4(sp)
81117ae0:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
81117ae4:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
81117ae8:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81117aec:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81117af0:	d0a06883 	ldbu	r2,-32350(gp)
81117af4:	10803fcc 	andi	r2,r2,255
81117af8:	10800218 	cmpnei	r2,r2,8
81117afc:	1000021e 	bne	r2,zero,81117b08 <vCheck+0x3c>
81117b00:	00c00104 	movi	r3,4
81117b04:	00000106 	br	81117b0c <vCheck+0x40>
81117b08:	0007883a 	mov	r3,zero
81117b0c:	d0a07503 	ldbu	r2,-32300(gp)
81117b10:	10803fcc 	andi	r2,r2,255
81117b14:	10800218 	cmpnei	r2,r2,8
81117b18:	1000021e 	bne	r2,zero,81117b24 <vCheck+0x58>
81117b1c:	00800084 	movi	r2,2
81117b20:	00000106 	br	81117b28 <vCheck+0x5c>
81117b24:	0005883a 	mov	r2,zero
81117b28:	1884b03a 	or	r2,r3,r2
81117b2c:	1007883a 	mov	r3,r2
81117b30:	d0a07543 	ldbu	r2,-32299(gp)
81117b34:	10803fcc 	andi	r2,r2,255
81117b38:	108001a0 	cmpeqi	r2,r2,6
81117b3c:	1884b03a 	or	r2,r3,r2
81117b40:	1007883a 	mov	r3,r2
81117b44:	e0bfff03 	ldbu	r2,-4(fp)
81117b48:	1884b03a 	or	r2,r3,r2
81117b4c:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81117b50:	e0bfff03 	ldbu	r2,-4(fp)
81117b54:	108001d8 	cmpnei	r2,r2,7
81117b58:	10003d26 	beq	r2,zero,81117c50 <vCheck+0x184>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
81117b5c:	d0a07417 	ldw	r2,-32304(gp)
81117b60:	e0ffff44 	addi	r3,fp,-3
81117b64:	180d883a 	mov	r6,r3
81117b68:	000b883a 	mov	r5,zero
81117b6c:	1009883a 	mov	r4,r2
81117b70:	113ddc00 	call	8113ddc0 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
81117b74:	e0bfff43 	ldbu	r2,-3(fp)
81117b78:	10803fcc 	andi	r2,r2,255
81117b7c:	10000e26 	beq	r2,zero,81117bb8 <vCheck+0xec>
        /* Should never get here, is a blocking operation */
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81117b80:	00a045b4 	movhi	r2,33046
81117b84:	109fe204 	addi	r2,r2,32648
81117b88:	10800d8b 	ldhu	r2,54(r2)
81117b8c:	10bfffcc 	andi	r2,r2,65535
81117b90:	10800228 	cmpgeui	r2,r2,8
81117b94:	1000301e 	bne	r2,zero,81117c58 <vCheck+0x18c>
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
81117b98:	d0a06217 	ldw	r2,-32376(gp)
81117b9c:	100f883a 	mov	r7,r2
81117ba0:	01800f04 	movi	r6,60
81117ba4:	01400044 	movi	r5,1
81117ba8:	01204574 	movhi	r4,33045
81117bac:	213e4704 	addi	r4,r4,-1764
81117bb0:	1122fc80 	call	81122fc8 <fwrite>
    	}
		#endif
        return;
81117bb4:	00002806 	br	81117c58 <vCheck+0x18c>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81117bb8:	e0bfff03 	ldbu	r2,-4(fp)
81117bbc:	1080004c 	andi	r2,r2,1
81117bc0:	10803fcc 	andi	r2,r2,255
81117bc4:	1000021e 	bne	r2,zero,81117bd0 <vCheck+0x104>
        vCheckRetransmission128();
81117bc8:	1117c700 	call	81117c70 <vCheckRetransmission128>
81117bcc:	00000506 	br	81117be4 <vCheck+0x118>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
81117bd0:	01800604 	movi	r6,24
81117bd4:	000b883a 	mov	r5,zero
81117bd8:	012045b4 	movhi	r4,33046
81117bdc:	21000004 	addi	r4,r4,0
81117be0:	1123b2c0 	call	81123b2c <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
81117be4:	e0bfff03 	ldbu	r2,-4(fp)
81117be8:	1080008c 	andi	r2,r2,2
81117bec:	10803fcc 	andi	r2,r2,255
81117bf0:	1000021e 	bne	r2,zero,81117bfc <vCheck+0x130>
        vCheckRetransmission64();
81117bf4:	1117ef40 	call	81117ef4 <vCheckRetransmission64>
81117bf8:	00000506 	br	81117c10 <vCheck+0x144>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
81117bfc:	01800804 	movi	r6,32
81117c00:	000b883a 	mov	r5,zero
81117c04:	012045b4 	movhi	r4,33046
81117c08:	21000604 	addi	r4,r4,24
81117c0c:	1123b2c0 	call	81123b2c <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
81117c10:	e0bfff03 	ldbu	r2,-4(fp)
81117c14:	1080010c 	andi	r2,r2,4
81117c18:	10803fcc 	andi	r2,r2,255
81117c1c:	1000021e 	bne	r2,zero,81117c28 <vCheck+0x15c>
        vCheckRetransmission32();
81117c20:	11181800 	call	81118180 <vCheckRetransmission32>
81117c24:	00000506 	br	81117c3c <vCheck+0x170>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81117c28:	01800804 	movi	r6,32
81117c2c:	000b883a 	mov	r5,zero
81117c30:	012045b4 	movhi	r4,33046
81117c34:	21000e04 	addi	r4,r4,56
81117c38:	1123b2c0 	call	81123b2c <memset>


    OSMutexPost(xTxUARTMutex);
81117c3c:	d0a07417 	ldw	r2,-32304(gp)
81117c40:	1009883a 	mov	r4,r2
81117c44:	113e3640 	call	8113e364 <OSMutexPost>

    return;
81117c48:	0001883a 	nop
81117c4c:	00000306 	br	81117c5c <vCheck+0x190>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
81117c50:	0001883a 	nop
81117c54:	00000106 	br	81117c5c <vCheck+0x190>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
    	}
		#endif
        return;
81117c58:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
81117c5c:	e037883a 	mov	sp,fp
81117c60:	dfc00117 	ldw	ra,4(sp)
81117c64:	df000017 	ldw	fp,0(sp)
81117c68:	dec00204 	addi	sp,sp,8
81117c6c:	f800283a 	ret

81117c70 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81117c70:	defffd04 	addi	sp,sp,-12
81117c74:	de00012e 	bgeu	sp,et,81117c7c <vCheckRetransmission128+0xc>
81117c78:	003b68fa 	trap	3
81117c7c:	dfc00215 	stw	ra,8(sp)
81117c80:	df000115 	stw	fp,4(sp)
81117c84:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81117c88:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81117c8c:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81117c90:	d0a06e17 	ldw	r2,-32328(gp)
81117c94:	e0ffff44 	addi	r3,fp,-3
81117c98:	180b883a 	mov	r5,r3
81117c9c:	1009883a 	mov	r4,r2
81117ca0:	113d7400 	call	8113d740 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81117ca4:	e0bfff43 	ldbu	r2,-3(fp)
81117ca8:	10803fcc 	andi	r2,r2,255
81117cac:	10008b1e 	bne	r2,zero,81117edc <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81117cb0:	e03fff05 	stb	zero,-4(fp)
81117cb4:	00008106 	br	81117ebc <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
81117cb8:	e0ffff03 	ldbu	r3,-4(fp)
81117cbc:	00a045b4 	movhi	r2,33046
81117cc0:	10800004 	addi	r2,r2,0
81117cc4:	18c7883a 	add	r3,r3,r3
81117cc8:	18c7883a 	add	r3,r3,r3
81117ccc:	10c5883a 	add	r2,r2,r3
81117cd0:	10800017 	ldw	r2,0(r2)
81117cd4:	10800058 	cmpnei	r2,r2,1
81117cd8:	1000751e 	bne	r2,zero,81117eb0 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
81117cdc:	e0ffff03 	ldbu	r3,-4(fp)
81117ce0:	00a045b4 	movhi	r2,33046
81117ce4:	10801e04 	addi	r2,r2,120
81117ce8:	18c02324 	muli	r3,r3,140
81117cec:	10c5883a 	add	r2,r2,r3
81117cf0:	10802004 	addi	r2,r2,128
81117cf4:	10800017 	ldw	r2,0(r2)
81117cf8:	10800058 	cmpnei	r2,r2,1
81117cfc:	1000211e 	bne	r2,zero,81117d84 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
81117d00:	e0ffff03 	ldbu	r3,-4(fp)
81117d04:	00a045b4 	movhi	r2,33046
81117d08:	10801e04 	addi	r2,r2,120
81117d0c:	19002324 	muli	r4,r3,140
81117d10:	1105883a 	add	r2,r2,r4
81117d14:	10802184 	addi	r2,r2,134
81117d18:	1080000b 	ldhu	r2,0(r2)
81117d1c:	10800044 	addi	r2,r2,1
81117d20:	100b883a 	mov	r5,r2
81117d24:	00a045b4 	movhi	r2,33046
81117d28:	10801e04 	addi	r2,r2,120
81117d2c:	19002324 	muli	r4,r3,140
81117d30:	1105883a 	add	r2,r2,r4
81117d34:	10802184 	addi	r2,r2,134
81117d38:	1140000d 	sth	r5,0(r2)
81117d3c:	00a045b4 	movhi	r2,33046
81117d40:	10801e04 	addi	r2,r2,120
81117d44:	18c02324 	muli	r3,r3,140
81117d48:	10c5883a 	add	r2,r2,r3
81117d4c:	10802184 	addi	r2,r2,134
81117d50:	1080000b 	ldhu	r2,0(r2)
81117d54:	10bfffcc 	andi	r2,r2,65535
81117d58:	10a0001c 	xori	r2,r2,32768
81117d5c:	10a00004 	addi	r2,r2,-32768
81117d60:	10800090 	cmplti	r2,r2,2
81117d64:	1000071e 	bne	r2,zero,81117d84 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
81117d68:	e0ffff03 	ldbu	r3,-4(fp)
81117d6c:	00a045b4 	movhi	r2,33046
81117d70:	10801e04 	addi	r2,r2,120
81117d74:	18c02324 	muli	r3,r3,140
81117d78:	10c5883a 	add	r2,r2,r3
81117d7c:	10802004 	addi	r2,r2,128
81117d80:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
81117d84:	e0ffff03 	ldbu	r3,-4(fp)
81117d88:	00a045b4 	movhi	r2,33046
81117d8c:	10801e04 	addi	r2,r2,120
81117d90:	18c02324 	muli	r3,r3,140
81117d94:	10c5883a 	add	r2,r2,r3
81117d98:	10802004 	addi	r2,r2,128
81117d9c:	10800017 	ldw	r2,0(r2)
81117da0:	1000431e 	bne	r2,zero,81117eb0 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
81117da4:	e0bfff03 	ldbu	r2,-4(fp)
81117da8:	10c02324 	muli	r3,r2,140
81117dac:	00a045b4 	movhi	r2,33046
81117db0:	10801e04 	addi	r2,r2,120
81117db4:	1885883a 	add	r2,r3,r2
81117db8:	1009883a 	mov	r4,r2
81117dbc:	1123efc0 	call	81123efc <puts>
                xBuffer128[ucIL].bSent = TRUE;
81117dc0:	e0ffff03 	ldbu	r3,-4(fp)
81117dc4:	00a045b4 	movhi	r2,33046
81117dc8:	10801e04 	addi	r2,r2,120
81117dcc:	18c02324 	muli	r3,r3,140
81117dd0:	10c5883a 	add	r2,r2,r3
81117dd4:	10802004 	addi	r2,r2,128
81117dd8:	00c00044 	movi	r3,1
81117ddc:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81117de0:	e0ffff03 	ldbu	r3,-4(fp)
81117de4:	00a045b4 	movhi	r2,33046
81117de8:	10801e04 	addi	r2,r2,120
81117dec:	18c02324 	muli	r3,r3,140
81117df0:	10c5883a 	add	r2,r2,r3
81117df4:	10802184 	addi	r2,r2,134
81117df8:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81117dfc:	e0ffff03 	ldbu	r3,-4(fp)
81117e00:	00a045b4 	movhi	r2,33046
81117e04:	10801e04 	addi	r2,r2,120
81117e08:	19002324 	muli	r4,r3,140
81117e0c:	1105883a 	add	r2,r2,r4
81117e10:	10802204 	addi	r2,r2,136
81117e14:	10800003 	ldbu	r2,0(r2)
81117e18:	10800044 	addi	r2,r2,1
81117e1c:	100b883a 	mov	r5,r2
81117e20:	00a045b4 	movhi	r2,33046
81117e24:	10801e04 	addi	r2,r2,120
81117e28:	19002324 	muli	r4,r3,140
81117e2c:	1105883a 	add	r2,r2,r4
81117e30:	10802204 	addi	r2,r2,136
81117e34:	11400005 	stb	r5,0(r2)
81117e38:	00a045b4 	movhi	r2,33046
81117e3c:	10801e04 	addi	r2,r2,120
81117e40:	18c02324 	muli	r3,r3,140
81117e44:	10c5883a 	add	r2,r2,r3
81117e48:	10802204 	addi	r2,r2,136
81117e4c:	10800003 	ldbu	r2,0(r2)
81117e50:	10803fcc 	andi	r2,r2,255
81117e54:	108000b0 	cmpltui	r2,r2,2
81117e58:	1000151e 	bne	r2,zero,81117eb0 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
81117e5c:	e0ffff03 	ldbu	r3,-4(fp)
81117e60:	00a045b4 	movhi	r2,33046
81117e64:	10800004 	addi	r2,r2,0
81117e68:	18c7883a 	add	r3,r3,r3
81117e6c:	18c7883a 	add	r3,r3,r3
81117e70:	10c5883a 	add	r2,r2,r3
81117e74:	10000015 	stw	zero,0(r2)
                    SemCount128++;
81117e78:	d0a07543 	ldbu	r2,-32299(gp)
81117e7c:	10800044 	addi	r2,r2,1
81117e80:	d0a07545 	stb	r2,-32299(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
81117e84:	d0a06317 	ldw	r2,-32372(gp)
81117e88:	1009883a 	mov	r4,r2
81117e8c:	11401540 	call	81140154 <OSSemPost>
81117e90:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81117e94:	e0bfff43 	ldbu	r2,-3(fp)
81117e98:	10803fcc 	andi	r2,r2,255
81117e9c:	10000426 	beq	r2,zero,81117eb0 <vCheckRetransmission128+0x240>
                        SemCount128--;
81117ea0:	d0a07543 	ldbu	r2,-32299(gp)
81117ea4:	10bfffc4 	addi	r2,r2,-1
81117ea8:	d0a07545 	stb	r2,-32299(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81117eac:	111cda00 	call	8111cda0 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81117eb0:	e0bfff03 	ldbu	r2,-4(fp)
81117eb4:	10800044 	addi	r2,r2,1
81117eb8:	e0bfff05 	stb	r2,-4(fp)
81117ebc:	e0bfff03 	ldbu	r2,-4(fp)
81117ec0:	108001b0 	cmpltui	r2,r2,6
81117ec4:	103f7c1e 	bne	r2,zero,81117cb8 <__reset+0xfb0f7cb8>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
81117ec8:	d0a06e17 	ldw	r2,-32328(gp)
81117ecc:	1009883a 	mov	r4,r2
81117ed0:	113e3640 	call	8113e364 <OSMutexPost>

    return;
81117ed4:	0001883a 	nop
81117ed8:	00000106 	br	81117ee0 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81117edc:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
81117ee0:	e037883a 	mov	sp,fp
81117ee4:	dfc00117 	ldw	ra,4(sp)
81117ee8:	df000017 	ldw	fp,0(sp)
81117eec:	dec00204 	addi	sp,sp,8
81117ef0:	f800283a 	ret

81117ef4 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
81117ef4:	defffd04 	addi	sp,sp,-12
81117ef8:	de00012e 	bgeu	sp,et,81117f00 <vCheckRetransmission64+0xc>
81117efc:	003b68fa 	trap	3
81117f00:	dfc00215 	stw	ra,8(sp)
81117f04:	df000115 	stw	fp,4(sp)
81117f08:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81117f0c:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81117f10:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81117f14:	d0a07117 	ldw	r2,-32316(gp)
81117f18:	e0ffff44 	addi	r3,fp,-3
81117f1c:	180b883a 	mov	r5,r3
81117f20:	1009883a 	mov	r4,r2
81117f24:	113d7400 	call	8113d740 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81117f28:	e0bfff43 	ldbu	r2,-3(fp)
81117f2c:	10803fcc 	andi	r2,r2,255
81117f30:	10008d1e 	bne	r2,zero,81118168 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81117f34:	e03fff05 	stb	zero,-4(fp)
81117f38:	00008306 	br	81118148 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
81117f3c:	e0ffff03 	ldbu	r3,-4(fp)
81117f40:	00a045b4 	movhi	r2,33046
81117f44:	10800004 	addi	r2,r2,0
81117f48:	18c00184 	addi	r3,r3,6
81117f4c:	18c7883a 	add	r3,r3,r3
81117f50:	18c7883a 	add	r3,r3,r3
81117f54:	10c5883a 	add	r2,r2,r3
81117f58:	10800017 	ldw	r2,0(r2)
81117f5c:	10800058 	cmpnei	r2,r2,1
81117f60:	1000761e 	bne	r2,zero,8111813c <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81117f64:	e0ffff03 	ldbu	r3,-4(fp)
81117f68:	00a04574 	movhi	r2,33045
81117f6c:	109bc404 	addi	r2,r2,28432
81117f70:	18c01324 	muli	r3,r3,76
81117f74:	10c5883a 	add	r2,r2,r3
81117f78:	10801004 	addi	r2,r2,64
81117f7c:	10800017 	ldw	r2,0(r2)
81117f80:	10800058 	cmpnei	r2,r2,1
81117f84:	1000211e 	bne	r2,zero,8111800c <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
81117f88:	e0ffff03 	ldbu	r3,-4(fp)
81117f8c:	00a04574 	movhi	r2,33045
81117f90:	109bc404 	addi	r2,r2,28432
81117f94:	19001324 	muli	r4,r3,76
81117f98:	1105883a 	add	r2,r2,r4
81117f9c:	10801184 	addi	r2,r2,70
81117fa0:	1080000b 	ldhu	r2,0(r2)
81117fa4:	10800044 	addi	r2,r2,1
81117fa8:	100b883a 	mov	r5,r2
81117fac:	00a04574 	movhi	r2,33045
81117fb0:	109bc404 	addi	r2,r2,28432
81117fb4:	19001324 	muli	r4,r3,76
81117fb8:	1105883a 	add	r2,r2,r4
81117fbc:	10801184 	addi	r2,r2,70
81117fc0:	1140000d 	sth	r5,0(r2)
81117fc4:	00a04574 	movhi	r2,33045
81117fc8:	109bc404 	addi	r2,r2,28432
81117fcc:	18c01324 	muli	r3,r3,76
81117fd0:	10c5883a 	add	r2,r2,r3
81117fd4:	10801184 	addi	r2,r2,70
81117fd8:	1080000b 	ldhu	r2,0(r2)
81117fdc:	10bfffcc 	andi	r2,r2,65535
81117fe0:	10a0001c 	xori	r2,r2,32768
81117fe4:	10a00004 	addi	r2,r2,-32768
81117fe8:	10800090 	cmplti	r2,r2,2
81117fec:	1000071e 	bne	r2,zero,8111800c <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81117ff0:	e0ffff03 	ldbu	r3,-4(fp)
81117ff4:	00a04574 	movhi	r2,33045
81117ff8:	109bc404 	addi	r2,r2,28432
81117ffc:	18c01324 	muli	r3,r3,76
81118000:	10c5883a 	add	r2,r2,r3
81118004:	10801004 	addi	r2,r2,64
81118008:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
8111800c:	e0ffff03 	ldbu	r3,-4(fp)
81118010:	00a04574 	movhi	r2,33045
81118014:	109bc404 	addi	r2,r2,28432
81118018:	18c01324 	muli	r3,r3,76
8111801c:	10c5883a 	add	r2,r2,r3
81118020:	10801004 	addi	r2,r2,64
81118024:	10800017 	ldw	r2,0(r2)
81118028:	1000441e 	bne	r2,zero,8111813c <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
8111802c:	e0bfff03 	ldbu	r2,-4(fp)
81118030:	10c01324 	muli	r3,r2,76
81118034:	00a04574 	movhi	r2,33045
81118038:	109bc404 	addi	r2,r2,28432
8111803c:	1885883a 	add	r2,r3,r2
81118040:	1009883a 	mov	r4,r2
81118044:	1123efc0 	call	81123efc <puts>
                xBuffer64[ucIL].bSent = TRUE;
81118048:	e0ffff03 	ldbu	r3,-4(fp)
8111804c:	00a04574 	movhi	r2,33045
81118050:	109bc404 	addi	r2,r2,28432
81118054:	18c01324 	muli	r3,r3,76
81118058:	10c5883a 	add	r2,r2,r3
8111805c:	10801004 	addi	r2,r2,64
81118060:	00c00044 	movi	r3,1
81118064:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
81118068:	e0ffff03 	ldbu	r3,-4(fp)
8111806c:	00a04574 	movhi	r2,33045
81118070:	109bc404 	addi	r2,r2,28432
81118074:	18c01324 	muli	r3,r3,76
81118078:	10c5883a 	add	r2,r2,r3
8111807c:	10801184 	addi	r2,r2,70
81118080:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81118084:	e0ffff03 	ldbu	r3,-4(fp)
81118088:	00a04574 	movhi	r2,33045
8111808c:	109bc404 	addi	r2,r2,28432
81118090:	19001324 	muli	r4,r3,76
81118094:	1105883a 	add	r2,r2,r4
81118098:	10801204 	addi	r2,r2,72
8111809c:	10800003 	ldbu	r2,0(r2)
811180a0:	10800044 	addi	r2,r2,1
811180a4:	100b883a 	mov	r5,r2
811180a8:	00a04574 	movhi	r2,33045
811180ac:	109bc404 	addi	r2,r2,28432
811180b0:	19001324 	muli	r4,r3,76
811180b4:	1105883a 	add	r2,r2,r4
811180b8:	10801204 	addi	r2,r2,72
811180bc:	11400005 	stb	r5,0(r2)
811180c0:	00a04574 	movhi	r2,33045
811180c4:	109bc404 	addi	r2,r2,28432
811180c8:	18c01324 	muli	r3,r3,76
811180cc:	10c5883a 	add	r2,r2,r3
811180d0:	10801204 	addi	r2,r2,72
811180d4:	10800003 	ldbu	r2,0(r2)
811180d8:	10803fcc 	andi	r2,r2,255
811180dc:	108000b0 	cmpltui	r2,r2,2
811180e0:	1000161e 	bne	r2,zero,8111813c <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
811180e4:	e0ffff03 	ldbu	r3,-4(fp)
811180e8:	00a045b4 	movhi	r2,33046
811180ec:	10800004 	addi	r2,r2,0
811180f0:	18c00184 	addi	r3,r3,6
811180f4:	18c7883a 	add	r3,r3,r3
811180f8:	18c7883a 	add	r3,r3,r3
811180fc:	10c5883a 	add	r2,r2,r3
81118100:	10000015 	stw	zero,0(r2)
                    SemCount64++;
81118104:	d0a07503 	ldbu	r2,-32300(gp)
81118108:	10800044 	addi	r2,r2,1
8111810c:	d0a07505 	stb	r2,-32300(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
81118110:	d0a05e17 	ldw	r2,-32392(gp)
81118114:	1009883a 	mov	r4,r2
81118118:	11401540 	call	81140154 <OSSemPost>
8111811c:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81118120:	e0bfff43 	ldbu	r2,-3(fp)
81118124:	10803fcc 	andi	r2,r2,255
81118128:	10000426 	beq	r2,zero,8111813c <vCheckRetransmission64+0x248>
                        SemCount64--;
8111812c:	d0a07503 	ldbu	r2,-32300(gp)
81118130:	10bfffc4 	addi	r2,r2,-1
81118134:	d0a07505 	stb	r2,-32300(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81118138:	111cd200 	call	8111cd20 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
8111813c:	e0bfff03 	ldbu	r2,-4(fp)
81118140:	10800044 	addi	r2,r2,1
81118144:	e0bfff05 	stb	r2,-4(fp)
81118148:	e0bfff03 	ldbu	r2,-4(fp)
8111814c:	10800230 	cmpltui	r2,r2,8
81118150:	103f7a1e 	bne	r2,zero,81117f3c <__reset+0xfb0f7f3c>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
81118154:	d0a07117 	ldw	r2,-32316(gp)
81118158:	1009883a 	mov	r4,r2
8111815c:	113e3640 	call	8113e364 <OSMutexPost>

    return;
81118160:	0001883a 	nop
81118164:	00000106 	br	8111816c <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81118168:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
8111816c:	e037883a 	mov	sp,fp
81118170:	dfc00117 	ldw	ra,4(sp)
81118174:	df000017 	ldw	fp,0(sp)
81118178:	dec00204 	addi	sp,sp,8
8111817c:	f800283a 	ret

81118180 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
81118180:	defffd04 	addi	sp,sp,-12
81118184:	de00012e 	bgeu	sp,et,8111818c <vCheckRetransmission32+0xc>
81118188:	003b68fa 	trap	3
8111818c:	dfc00215 	stw	ra,8(sp)
81118190:	df000115 	stw	fp,4(sp)
81118194:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81118198:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
8111819c:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
811181a0:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
811181a4:	d0a06c17 	ldw	r2,-32336(gp)
811181a8:	e0ffff84 	addi	r3,fp,-2
811181ac:	180b883a 	mov	r5,r3
811181b0:	1009883a 	mov	r4,r2
811181b4:	113d7400 	call	8113d740 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811181b8:	e0bfff83 	ldbu	r2,-2(fp)
811181bc:	10803fcc 	andi	r2,r2,255
811181c0:	10009b1e 	bne	r2,zero,81118430 <vCheckRetransmission32+0x2b0>
    }
    
    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
811181c4:	e03fff05 	stb	zero,-4(fp)
811181c8:	00009106 	br	81118410 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
811181cc:	e0ffff03 	ldbu	r3,-4(fp)
811181d0:	00a045b4 	movhi	r2,33046
811181d4:	10800004 	addi	r2,r2,0
811181d8:	18c00384 	addi	r3,r3,14
811181dc:	18c7883a 	add	r3,r3,r3
811181e0:	18c7883a 	add	r3,r3,r3
811181e4:	10c5883a 	add	r2,r2,r3
811181e8:	10800017 	ldw	r2,0(r2)
811181ec:	10800058 	cmpnei	r2,r2,1
811181f0:	1000841e 	bne	r2,zero,81118404 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
811181f4:	e0ffff03 	ldbu	r3,-4(fp)
811181f8:	00a045b4 	movhi	r2,33046
811181fc:	10ad8004 	addi	r2,r2,-18944
81118200:	18c00b24 	muli	r3,r3,44
81118204:	10c5883a 	add	r2,r2,r3
81118208:	10800804 	addi	r2,r2,32
8111820c:	10800017 	ldw	r2,0(r2)
81118210:	10800058 	cmpnei	r2,r2,1
81118214:	1000211e 	bne	r2,zero,8111829c <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
81118218:	e0ffff03 	ldbu	r3,-4(fp)
8111821c:	00a045b4 	movhi	r2,33046
81118220:	10ad8004 	addi	r2,r2,-18944
81118224:	19000b24 	muli	r4,r3,44
81118228:	1105883a 	add	r2,r2,r4
8111822c:	10800984 	addi	r2,r2,38
81118230:	1080000b 	ldhu	r2,0(r2)
81118234:	10800044 	addi	r2,r2,1
81118238:	100b883a 	mov	r5,r2
8111823c:	00a045b4 	movhi	r2,33046
81118240:	10ad8004 	addi	r2,r2,-18944
81118244:	19000b24 	muli	r4,r3,44
81118248:	1105883a 	add	r2,r2,r4
8111824c:	10800984 	addi	r2,r2,38
81118250:	1140000d 	sth	r5,0(r2)
81118254:	00a045b4 	movhi	r2,33046
81118258:	10ad8004 	addi	r2,r2,-18944
8111825c:	18c00b24 	muli	r3,r3,44
81118260:	10c5883a 	add	r2,r2,r3
81118264:	10800984 	addi	r2,r2,38
81118268:	1080000b 	ldhu	r2,0(r2)
8111826c:	10bfffcc 	andi	r2,r2,65535
81118270:	10a0001c 	xori	r2,r2,32768
81118274:	10a00004 	addi	r2,r2,-32768
81118278:	10800090 	cmplti	r2,r2,2
8111827c:	1000071e 	bne	r2,zero,8111829c <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
81118280:	e0ffff03 	ldbu	r3,-4(fp)
81118284:	00a045b4 	movhi	r2,33046
81118288:	10ad8004 	addi	r2,r2,-18944
8111828c:	18c00b24 	muli	r3,r3,44
81118290:	10c5883a 	add	r2,r2,r3
81118294:	10800804 	addi	r2,r2,32
81118298:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
8111829c:	e0ffff03 	ldbu	r3,-4(fp)
811182a0:	00a045b4 	movhi	r2,33046
811182a4:	10ad8004 	addi	r2,r2,-18944
811182a8:	18c00b24 	muli	r3,r3,44
811182ac:	10c5883a 	add	r2,r2,r3
811182b0:	10800804 	addi	r2,r2,32
811182b4:	10800017 	ldw	r2,0(r2)
811182b8:	1000521e 	bne	r2,zero,81118404 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
811182bc:	e0bfff03 	ldbu	r2,-4(fp)
811182c0:	10c00b24 	muli	r3,r2,44
811182c4:	00a045b4 	movhi	r2,33046
811182c8:	10ad8004 	addi	r2,r2,-18944
811182cc:	1885883a 	add	r2,r3,r2
811182d0:	1009883a 	mov	r4,r2
811182d4:	1123efc0 	call	81123efc <puts>
                xBuffer32[ucIL].bSent = TRUE;
811182d8:	e0ffff03 	ldbu	r3,-4(fp)
811182dc:	00a045b4 	movhi	r2,33046
811182e0:	10ad8004 	addi	r2,r2,-18944
811182e4:	18c00b24 	muli	r3,r3,44
811182e8:	10c5883a 	add	r2,r2,r3
811182ec:	10800804 	addi	r2,r2,32
811182f0:	00c00044 	movi	r3,1
811182f4:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
811182f8:	e0ffff03 	ldbu	r3,-4(fp)
811182fc:	00a045b4 	movhi	r2,33046
81118300:	10ad8004 	addi	r2,r2,-18944
81118304:	18c00b24 	muli	r3,r3,44
81118308:	10c5883a 	add	r2,r2,r3
8111830c:	10800984 	addi	r2,r2,38
81118310:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
81118314:	e0ffff03 	ldbu	r3,-4(fp)
81118318:	00a045b4 	movhi	r2,33046
8111831c:	10ad8004 	addi	r2,r2,-18944
81118320:	18c00b24 	muli	r3,r3,44
81118324:	10c5883a 	add	r2,r2,r3
81118328:	10800904 	addi	r2,r2,36
8111832c:	1080000b 	ldhu	r2,0(r2)
81118330:	10bfffcc 	andi	r2,r2,65535
81118334:	10800058 	cmpnei	r2,r2,1
81118338:	1000021e 	bne	r2,zero,81118344 <vCheckRetransmission32+0x1c4>
8111833c:	00bffe84 	movi	r2,-6
81118340:	00000106 	br	81118348 <vCheckRetransmission32+0x1c8>
81118344:	00800044 	movi	r2,1
81118348:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
8111834c:	e0ffff03 	ldbu	r3,-4(fp)
81118350:	00a045b4 	movhi	r2,33046
81118354:	10ad8004 	addi	r2,r2,-18944
81118358:	19000b24 	muli	r4,r3,44
8111835c:	1105883a 	add	r2,r2,r4
81118360:	10800a04 	addi	r2,r2,40
81118364:	10800003 	ldbu	r2,0(r2)
81118368:	10800044 	addi	r2,r2,1
8111836c:	100b883a 	mov	r5,r2
81118370:	00a045b4 	movhi	r2,33046
81118374:	10ad8004 	addi	r2,r2,-18944
81118378:	19000b24 	muli	r4,r3,44
8111837c:	1105883a 	add	r2,r2,r4
81118380:	10800a04 	addi	r2,r2,40
81118384:	11400005 	stb	r5,0(r2)
81118388:	00a045b4 	movhi	r2,33046
8111838c:	10ad8004 	addi	r2,r2,-18944
81118390:	18c00b24 	muli	r3,r3,44
81118394:	10c5883a 	add	r2,r2,r3
81118398:	10800a04 	addi	r2,r2,40
8111839c:	10800003 	ldbu	r2,0(r2)
811183a0:	10803fcc 	andi	r2,r2,255
811183a4:	e0ffff43 	ldbu	r3,-3(fp)
811183a8:	1880162e 	bgeu	r3,r2,81118404 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
811183ac:	e0ffff03 	ldbu	r3,-4(fp)
811183b0:	00a045b4 	movhi	r2,33046
811183b4:	10800004 	addi	r2,r2,0
811183b8:	18c00384 	addi	r3,r3,14
811183bc:	18c7883a 	add	r3,r3,r3
811183c0:	18c7883a 	add	r3,r3,r3
811183c4:	10c5883a 	add	r2,r2,r3
811183c8:	10000015 	stw	zero,0(r2)
                    SemCount32++;
811183cc:	d0a06883 	ldbu	r2,-32350(gp)
811183d0:	10800044 	addi	r2,r2,1
811183d4:	d0a06885 	stb	r2,-32350(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
811183d8:	d0a06f17 	ldw	r2,-32324(gp)
811183dc:	1009883a 	mov	r4,r2
811183e0:	11401540 	call	81140154 <OSSemPost>
811183e4:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
811183e8:	e0bfff83 	ldbu	r2,-2(fp)
811183ec:	10803fcc 	andi	r2,r2,255
811183f0:	10000426 	beq	r2,zero,81118404 <vCheckRetransmission32+0x284>
                        SemCount32--;
811183f4:	d0a06883 	ldbu	r2,-32350(gp)
811183f8:	10bfffc4 	addi	r2,r2,-1
811183fc:	d0a06885 	stb	r2,-32350(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81118400:	111cca00 	call	8111cca0 <vFailSetCountSemaphorexBuffer32>
    }
    
    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81118404:	e0bfff03 	ldbu	r2,-4(fp)
81118408:	10800044 	addi	r2,r2,1
8111840c:	e0bfff05 	stb	r2,-4(fp)
81118410:	e0bfff03 	ldbu	r2,-4(fp)
81118414:	10800230 	cmpltui	r2,r2,8
81118418:	103f6c1e 	bne	r2,zero,811181cc <__reset+0xfb0f81cc>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
8111841c:	d0a06c17 	ldw	r2,-32336(gp)
81118420:	1009883a 	mov	r4,r2
81118424:	113e3640 	call	8113e364 <OSMutexPost>

    return;
81118428:	0001883a 	nop
8111842c:	00000106 	br	81118434 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81118430:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
81118434:	e037883a 	mov	sp,fp
81118438:	dfc00117 	ldw	ra,4(sp)
8111843c:	df000017 	ldw	fp,0(sp)
81118440:	dec00204 	addi	sp,sp,8
81118444:	f800283a 	ret

81118448 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81118448:	defff904 	addi	sp,sp,-28
8111844c:	de00012e 	bgeu	sp,et,81118454 <bResourcesInitRTOS+0xc>
81118450:	003b68fa 	trap	3
81118454:	dfc00615 	stw	ra,24(sp)
81118458:	df000515 	stw	fp,20(sp)
8111845c:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81118460:	00800044 	movi	r2,1
81118464:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81118468:	0009883a 	mov	r4,zero
8111846c:	113faa40 	call	8113faa4 <OSSemCreate>
81118470:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCommInit) {
81118474:	d0a06017 	ldw	r2,-32384(gp)
81118478:	1000021e 	bne	r2,zero,81118484 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
8111847c:	111c5b80 	call	8111c5b8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118480:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81118484:	e0bfff04 	addi	r2,fp,-4
81118488:	100b883a 	mov	r5,r2
8111848c:	01000444 	movi	r4,17
81118490:	113d8ec0 	call	8113d8ec <OSMutexCreate>
81118494:	d0a07415 	stw	r2,-32304(gp)
	if ( err != OS_ERR_NONE ) {
81118498:	e0bfff03 	ldbu	r2,-4(fp)
8111849c:	10803fcc 	andi	r2,r2,255
811184a0:	10000526 	beq	r2,zero,811184b8 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
811184a4:	e0bfff03 	ldbu	r2,-4(fp)
811184a8:	10803fcc 	andi	r2,r2,255
811184ac:	1009883a 	mov	r4,r2
811184b0:	111c4dc0 	call	8111c4dc <vFailCreateMutexSResources>
		bSuccess = FALSE;
811184b4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
811184b8:	e0bfff04 	addi	r2,fp,-4
811184bc:	100b883a 	mov	r5,r2
811184c0:	01000504 	movi	r4,20
811184c4:	113d8ec0 	call	8113d8ec <OSMutexCreate>
811184c8:	d0a06e15 	stw	r2,-32328(gp)
	if ( err != OS_ERR_NONE ) {
811184cc:	e0bfff03 	ldbu	r2,-4(fp)
811184d0:	10803fcc 	andi	r2,r2,255
811184d4:	10000526 	beq	r2,zero,811184ec <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
811184d8:	e0bfff03 	ldbu	r2,-4(fp)
811184dc:	10803fcc 	andi	r2,r2,255
811184e0:	1009883a 	mov	r4,r2
811184e4:	111c4dc0 	call	8111c4dc <vFailCreateMutexSResources>
		bSuccess = FALSE;
811184e8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
811184ec:	e0bfff04 	addi	r2,fp,-4
811184f0:	100b883a 	mov	r5,r2
811184f4:	01000544 	movi	r4,21
811184f8:	113d8ec0 	call	8113d8ec <OSMutexCreate>
811184fc:	d0a07115 	stw	r2,-32316(gp)
	if ( err != OS_ERR_NONE ) {
81118500:	e0bfff03 	ldbu	r2,-4(fp)
81118504:	10803fcc 	andi	r2,r2,255
81118508:	10000526 	beq	r2,zero,81118520 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
8111850c:	e0bfff03 	ldbu	r2,-4(fp)
81118510:	10803fcc 	andi	r2,r2,255
81118514:	1009883a 	mov	r4,r2
81118518:	111c4dc0 	call	8111c4dc <vFailCreateMutexSResources>
		bSuccess = FALSE;
8111851c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81118520:	e0bfff04 	addi	r2,fp,-4
81118524:	100b883a 	mov	r5,r2
81118528:	01000584 	movi	r4,22
8111852c:	113d8ec0 	call	8113d8ec <OSMutexCreate>
81118530:	d0a06c15 	stw	r2,-32336(gp)
	if ( err != OS_ERR_NONE ) {
81118534:	e0bfff03 	ldbu	r2,-4(fp)
81118538:	10803fcc 	andi	r2,r2,255
8111853c:	10000526 	beq	r2,zero,81118554 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
81118540:	e0bfff03 	ldbu	r2,-4(fp)
81118544:	10803fcc 	andi	r2,r2,255
81118548:	1009883a 	mov	r4,r2
8111854c:	111c4dc0 	call	8111c4dc <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118550:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
81118554:	00800184 	movi	r2,6
81118558:	d0a07545 	stb	r2,-32299(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
8111855c:	01000184 	movi	r4,6
81118560:	113faa40 	call	8113faa4 <OSSemCreate>
81118564:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemCountBuffer128) {
81118568:	d0a06317 	ldw	r2,-32372(gp)
8111856c:	1000031e 	bne	r2,zero,8111857c <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81118570:	d0207545 	stb	zero,-32299(gp)
		vFailCreateSemaphoreResources();
81118574:	111c5b80 	call	8111c5b8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118578:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
8111857c:	00800204 	movi	r2,8
81118580:	d0a07505 	stb	r2,-32300(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81118584:	01000204 	movi	r4,8
81118588:	113faa40 	call	8113faa4 <OSSemCreate>
8111858c:	d0a05e15 	stw	r2,-32392(gp)
	if (!xSemCountBuffer64) {
81118590:	d0a05e17 	ldw	r2,-32392(gp)
81118594:	1000031e 	bne	r2,zero,811185a4 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81118598:	d0207505 	stb	zero,-32300(gp)
		vFailCreateSemaphoreResources();
8111859c:	111c5b80 	call	8111c5b8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811185a0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
811185a4:	00800204 	movi	r2,8
811185a8:	d0a06885 	stb	r2,-32350(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
811185ac:	01000204 	movi	r4,8
811185b0:	113faa40 	call	8113faa4 <OSSemCreate>
811185b4:	d0a06f15 	stw	r2,-32324(gp)
	if (!xSemCountBuffer32) {
811185b8:	d0a06f17 	ldw	r2,-32324(gp)
811185bc:	1000031e 	bne	r2,zero,811185cc <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
811185c0:	d0206885 	stb	zero,-32350(gp)
		vFailCreateSemaphoreResources();
811185c4:	111c5b80 	call	8111c5b8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811185c8:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
811185cc:	e0bfff04 	addi	r2,fp,-4
811185d0:	100b883a 	mov	r5,r2
811185d4:	010004c4 	movi	r4,19
811185d8:	113d8ec0 	call	8113d8ec <OSMutexCreate>
811185dc:	d0a06515 	stw	r2,-32364(gp)
	if ( err != OS_ERR_NONE ) {
811185e0:	e0bfff03 	ldbu	r2,-4(fp)
811185e4:	10803fcc 	andi	r2,r2,255
811185e8:	10000526 	beq	r2,zero,81118600 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
811185ec:	e0bfff03 	ldbu	r2,-4(fp)
811185f0:	10803fcc 	andi	r2,r2,255
811185f4:	1009883a 	mov	r4,r2
811185f8:	111c4dc0 	call	8111c4dc <vFailCreateMutexSResources>
		bSuccess = FALSE;
811185fc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
81118600:	e0bfff04 	addi	r2,fp,-4
81118604:	100b883a 	mov	r5,r2
81118608:	010005c4 	movi	r4,23
8111860c:	113d8ec0 	call	8113d8ec <OSMutexCreate>
81118610:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
81118614:	e0bfff03 	ldbu	r2,-4(fp)
81118618:	10803fcc 	andi	r2,r2,255
8111861c:	10000526 	beq	r2,zero,81118634 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81118620:	e0bfff03 	ldbu	r2,-4(fp)
81118624:	10803fcc 	andi	r2,r2,255
81118628:	1009883a 	mov	r4,r2
8111862c:	111c4dc0 	call	8111c4dc <vFailCreateMutexSResources>
		bSuccess = FALSE;
81118630:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81118634:	0009883a 	mov	r4,zero
81118638:	113faa40 	call	8113faa4 <OSSemCreate>
8111863c:	d0a06615 	stw	r2,-32360(gp)
	if (!xSemCountReceivedACK) {
81118640:	d0a06617 	ldw	r2,-32360(gp)
81118644:	1000021e 	bne	r2,zero,81118650 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81118648:	111c5b80 	call	8111c5b8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8111864c:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81118650:	0009883a 	mov	r4,zero
81118654:	113faa40 	call	8113faa4 <OSSemCreate>
81118658:	d0a06415 	stw	r2,-32368(gp)
	if (!xSemCountPreParsed) {
8111865c:	d0a06417 	ldw	r2,-32368(gp)
81118660:	1000021e 	bne	r2,zero,8111866c <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
81118664:	111c5b80 	call	8111c5b8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118668:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
8111866c:	0009883a 	mov	r4,zero
81118670:	113faa40 	call	8113faa4 <OSSemCreate>
81118674:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemCountSenderACK) {
81118678:	d0a06117 	ldw	r2,-32380(gp)
8111867c:	1000021e 	bne	r2,zero,81118688 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81118680:	111c5b80 	call	8111c5b8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81118684:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81118688:	e0bfff04 	addi	r2,fp,-4
8111868c:	100b883a 	mov	r5,r2
81118690:	01000484 	movi	r4,18
81118694:	113d8ec0 	call	8113d8ec <OSMutexCreate>
81118698:	d0a07215 	stw	r2,-32312(gp)
	if ( err != OS_ERR_NONE ) {
8111869c:	e0bfff03 	ldbu	r2,-4(fp)
811186a0:	10803fcc 	andi	r2,r2,255
811186a4:	10000526 	beq	r2,zero,811186bc <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
811186a8:	e0bfff03 	ldbu	r2,-4(fp)
811186ac:	10803fcc 	andi	r2,r2,255
811186b0:	1009883a 	mov	r4,r2
811186b4:	111c4dc0 	call	8111c4dc <vFailCreateMutexSResources>
		bSuccess = FALSE;
811186b8:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
811186bc:	0009883a 	mov	r4,zero
811186c0:	113faa40 	call	8113faa4 <OSSemCreate>
811186c4:	d0a06715 	stw	r2,-32356(gp)
	if (!xSemTimeoutChecker) {
811186c8:	d0a06717 	ldw	r2,-32356(gp)
811186cc:	1000021e 	bne	r2,zero,811186d8 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
811186d0:	111c5b80 	call	8111c5b8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811186d4:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
811186d8:	e0bfff04 	addi	r2,fp,-4
811186dc:	d8800215 	stw	r2,8(sp)
811186e0:	00a04574 	movhi	r2,33045
811186e4:	10be5704 	addi	r2,r2,-1700
811186e8:	d8800115 	stw	r2,4(sp)
811186ec:	d8000015 	stw	zero,0(sp)
811186f0:	01e044b4 	movhi	r7,33042
811186f4:	39e8c104 	addi	r7,r7,-23804
811186f8:	01800084 	movi	r6,2
811186fc:	01400104 	movi	r5,4
81118700:	01000284 	movi	r4,10
81118704:	11421700 	call	81142170 <OSTmrCreate>
81118708:	d0a06d15 	stw	r2,-32332(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
8111870c:	e0bfff03 	ldbu	r2,-4(fp)
81118710:	10803fcc 	andi	r2,r2,255
81118714:	10000226 	beq	r2,zero,81118720 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81118718:	111d54c0 	call	8111d54c <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
8111871c:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81118720:	01400484 	movi	r5,18
81118724:	012045b4 	movhi	r4,33046
81118728:	2120c004 	addi	r4,r4,-32000
8111872c:	113e9d80 	call	8113e9d8 <OSQCreate>
81118730:	d0a05d15 	stw	r2,-32396(gp)
	if ( xNfeeSchedule == NULL ) {
81118734:	d0a05d17 	ldw	r2,-32396(gp)
81118738:	1000021e 	bne	r2,zero,81118744 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
8111873c:	111dc980 	call	8111dc98 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81118740:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81118744:	01400204 	movi	r5,8
81118748:	012045b4 	movhi	r4,33046
8111874c:	211fd204 	addi	r4,r4,32584
81118750:	113e9d80 	call	8113e9d8 <OSQCreate>
81118754:	d0a06a15 	stw	r2,-32344(gp)
	if ( xFeeQ[0] == NULL ) {
81118758:	d0a06a17 	ldw	r2,-32344(gp)
8111875c:	1000031e 	bne	r2,zero,8111876c <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81118760:	0009883a 	mov	r4,zero
81118764:	111dd180 	call	8111dd18 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81118768:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
8111876c:	01400204 	movi	r5,8
81118770:	012045b4 	movhi	r4,33046
81118774:	21051804 	addi	r4,r4,5216
81118778:	113e9d80 	call	8113e9d8 <OSQCreate>
8111877c:	d0a05c15 	stw	r2,-32400(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
81118780:	d0a05c17 	ldw	r2,-32400(gp)
81118784:	1000031e 	bne	r2,zero,81118794 <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81118788:	0009883a 	mov	r4,zero
8111878c:	111dda00 	call	8111dda0 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
81118790:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
81118794:	01400204 	movi	r5,8
81118798:	012045b4 	movhi	r4,33046
8111879c:	21001604 	addi	r4,r4,88
811187a0:	113e9d80 	call	8113e9d8 <OSQCreate>
811187a4:	d0a06915 	stw	r2,-32348(gp)
	if ( xMebQ == NULL ) {
811187a8:	d0a06917 	ldw	r2,-32348(gp)
811187ac:	1000031e 	bne	r2,zero,811187bc <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
811187b0:	01000144 	movi	r4,5
811187b4:	111dd180 	call	8111dd18 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
811187b8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
811187bc:	e0bfff04 	addi	r2,fp,-4
811187c0:	100b883a 	mov	r5,r2
811187c4:	010001c4 	movi	r4,7
811187c8:	113d8ec0 	call	8113d8ec <OSMutexCreate>
811187cc:	d0a07315 	stw	r2,-32308(gp)
	if ( err != OS_ERR_NONE ) {
811187d0:	e0bfff03 	ldbu	r2,-4(fp)
811187d4:	10803fcc 	andi	r2,r2,255
811187d8:	10000526 	beq	r2,zero,811187f0 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
811187dc:	e0bfff03 	ldbu	r2,-4(fp)
811187e0:	10803fcc 	andi	r2,r2,255
811187e4:	1009883a 	mov	r4,r2
811187e8:	111e2a80 	call	8111e2a8 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
811187ec:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
811187f0:	01400404 	movi	r5,16
811187f4:	012045b4 	movhi	r4,33046
811187f8:	2100f004 	addi	r4,r4,960
811187fc:	113e9d80 	call	8113e9d8 <OSQCreate>
81118800:	d0a07015 	stw	r2,-32320(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81118804:	d0a07017 	ldw	r2,-32320(gp)
81118808:	1000021e 	bne	r2,zero,81118814 <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
8111880c:	111e4680 	call	8111e468 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
81118810:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81118814:	01400404 	movi	r5,16
81118818:	012045b4 	movhi	r4,33046
8111881c:	2133d804 	addi	r4,r4,-12448
81118820:	113e9d80 	call	8113e9d8 <OSQCreate>
81118824:	d0a05f15 	stw	r2,-32388(gp)
	if ( xQMaskDataCtrl == NULL ) {
81118828:	d0a05f17 	ldw	r2,-32388(gp)
8111882c:	1000021e 	bne	r2,zero,81118838 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
81118830:	111e4e80 	call	8111e4e8 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81118834:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
81118838:	e0bfff04 	addi	r2,fp,-4
8111883c:	100b883a 	mov	r5,r2
81118840:	01000104 	movi	r4,4
81118844:	113d8ec0 	call	8113d8ec <OSMutexCreate>
81118848:	1007883a 	mov	r3,r2
8111884c:	00a045b4 	movhi	r2,33046
81118850:	10932604 	addi	r2,r2,19608
81118854:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
81118858:	e0bfff03 	ldbu	r2,-4(fp)
8111885c:	10803fcc 	andi	r2,r2,255
81118860:	10000226 	beq	r2,zero,8111886c <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
81118864:	111c5540 	call	8111c554 <vFailCreateMutexDMA>
		bSuccess = FALSE;
81118868:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
8111886c:	e0bfff04 	addi	r2,fp,-4
81118870:	100b883a 	mov	r5,r2
81118874:	01000184 	movi	r4,6
81118878:	113d8ec0 	call	8113d8ec <OSMutexCreate>
8111887c:	1007883a 	mov	r3,r2
81118880:	00a045b4 	movhi	r2,33046
81118884:	10932604 	addi	r2,r2,19608
81118888:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
8111888c:	e0bfff03 	ldbu	r2,-4(fp)
81118890:	10803fcc 	andi	r2,r2,255
81118894:	10000226 	beq	r2,zero,811188a0 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
81118898:	111c5540 	call	8111c554 <vFailCreateMutexDMA>
		bSuccess = FALSE;
8111889c:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
811188a0:	e0bffe17 	ldw	r2,-8(fp)
}
811188a4:	e037883a 	mov	sp,fp
811188a8:	dfc00117 	ldw	ra,4(sp)
811188ac:	df000017 	ldw	fp,0(sp)
811188b0:	dec00204 	addi	sp,sp,8
811188b4:	f800283a 	ret

811188b8 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
811188b8:	defffd04 	addi	sp,sp,-12
811188bc:	de00012e 	bgeu	sp,et,811188c4 <vVariablesInitialization+0xc>
811188c0:	003b68fa 	trap	3
811188c4:	dfc00215 	stw	ra,8(sp)
811188c8:	df000115 	stw	fp,4(sp)
811188cc:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
811188d0:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
811188d4:	00800084 	movi	r2,2
811188d8:	d0a0680d 	sth	r2,-32352(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
811188dc:	01800604 	movi	r6,24
811188e0:	000b883a 	mov	r5,zero
811188e4:	012045b4 	movhi	r4,33046
811188e8:	21000004 	addi	r4,r4,0
811188ec:	1123b2c0 	call	81123b2c <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
811188f0:	01800804 	movi	r6,32
811188f4:	000b883a 	mov	r5,zero
811188f8:	012045b4 	movhi	r4,33046
811188fc:	21000604 	addi	r4,r4,24
81118900:	1123b2c0 	call	81123b2c <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
81118904:	01800804 	movi	r6,32
81118908:	000b883a 	mov	r5,zero
8111890c:	012045b4 	movhi	r4,33046
81118910:	21000e04 	addi	r4,r4,56
81118914:	1123b2c0 	call	81123b2c <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81118918:	e03fff05 	stb	zero,-4(fp)
8111891c:	00002806 	br	811189c0 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
81118920:	e0bfff03 	ldbu	r2,-4(fp)
81118924:	10c02324 	muli	r3,r2,140
81118928:	00a045b4 	movhi	r2,33046
8111892c:	10801e04 	addi	r2,r2,120
81118930:	1885883a 	add	r2,r3,r2
81118934:	01802004 	movi	r6,128
81118938:	000b883a 	mov	r5,zero
8111893c:	1009883a 	mov	r4,r2
81118940:	1123b2c0 	call	81123b2c <memset>
		xBuffer128[ucIL].bSent = FALSE;
81118944:	e0ffff03 	ldbu	r3,-4(fp)
81118948:	00a045b4 	movhi	r2,33046
8111894c:	10801e04 	addi	r2,r2,120
81118950:	18c02324 	muli	r3,r3,140
81118954:	10c5883a 	add	r2,r2,r3
81118958:	10802004 	addi	r2,r2,128
8111895c:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
81118960:	e0ffff03 	ldbu	r3,-4(fp)
81118964:	00a045b4 	movhi	r2,33046
81118968:	10801e04 	addi	r2,r2,120
8111896c:	18c02324 	muli	r3,r3,140
81118970:	10c5883a 	add	r2,r2,r3
81118974:	10802104 	addi	r2,r2,132
81118978:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
8111897c:	e0ffff03 	ldbu	r3,-4(fp)
81118980:	00a045b4 	movhi	r2,33046
81118984:	10801e04 	addi	r2,r2,120
81118988:	18c02324 	muli	r3,r3,140
8111898c:	10c5883a 	add	r2,r2,r3
81118990:	10802184 	addi	r2,r2,134
81118994:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
81118998:	e0ffff03 	ldbu	r3,-4(fp)
8111899c:	00a045b4 	movhi	r2,33046
811189a0:	10801e04 	addi	r2,r2,120
811189a4:	18c02324 	muli	r3,r3,140
811189a8:	10c5883a 	add	r2,r2,r3
811189ac:	10802204 	addi	r2,r2,136
811189b0:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
811189b4:	e0bfff03 	ldbu	r2,-4(fp)
811189b8:	10800044 	addi	r2,r2,1
811189bc:	e0bfff05 	stb	r2,-4(fp)
811189c0:	e0bfff03 	ldbu	r2,-4(fp)
811189c4:	108001b0 	cmpltui	r2,r2,6
811189c8:	103fd51e 	bne	r2,zero,81118920 <__reset+0xfb0f8920>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
811189cc:	e03fff05 	stb	zero,-4(fp)
811189d0:	00002806 	br	81118a74 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
811189d4:	e0bfff03 	ldbu	r2,-4(fp)
811189d8:	10c01324 	muli	r3,r2,76
811189dc:	00a04574 	movhi	r2,33045
811189e0:	109bc404 	addi	r2,r2,28432
811189e4:	1885883a 	add	r2,r3,r2
811189e8:	01801004 	movi	r6,64
811189ec:	000b883a 	mov	r5,zero
811189f0:	1009883a 	mov	r4,r2
811189f4:	1123b2c0 	call	81123b2c <memset>
		xBuffer64[ucIL].bSent = FALSE;
811189f8:	e0ffff03 	ldbu	r3,-4(fp)
811189fc:	00a04574 	movhi	r2,33045
81118a00:	109bc404 	addi	r2,r2,28432
81118a04:	18c01324 	muli	r3,r3,76
81118a08:	10c5883a 	add	r2,r2,r3
81118a0c:	10801004 	addi	r2,r2,64
81118a10:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
81118a14:	e0ffff03 	ldbu	r3,-4(fp)
81118a18:	00a04574 	movhi	r2,33045
81118a1c:	109bc404 	addi	r2,r2,28432
81118a20:	18c01324 	muli	r3,r3,76
81118a24:	10c5883a 	add	r2,r2,r3
81118a28:	10801104 	addi	r2,r2,68
81118a2c:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
81118a30:	e0ffff03 	ldbu	r3,-4(fp)
81118a34:	00a04574 	movhi	r2,33045
81118a38:	109bc404 	addi	r2,r2,28432
81118a3c:	18c01324 	muli	r3,r3,76
81118a40:	10c5883a 	add	r2,r2,r3
81118a44:	10801184 	addi	r2,r2,70
81118a48:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
81118a4c:	e0ffff03 	ldbu	r3,-4(fp)
81118a50:	00a04574 	movhi	r2,33045
81118a54:	109bc404 	addi	r2,r2,28432
81118a58:	18c01324 	muli	r3,r3,76
81118a5c:	10c5883a 	add	r2,r2,r3
81118a60:	10801204 	addi	r2,r2,72
81118a64:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81118a68:	e0bfff03 	ldbu	r2,-4(fp)
81118a6c:	10800044 	addi	r2,r2,1
81118a70:	e0bfff05 	stb	r2,-4(fp)
81118a74:	e0bfff03 	ldbu	r2,-4(fp)
81118a78:	10800230 	cmpltui	r2,r2,8
81118a7c:	103fd51e 	bne	r2,zero,811189d4 <__reset+0xfb0f89d4>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81118a80:	e03fff05 	stb	zero,-4(fp)
81118a84:	00002806 	br	81118b28 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
81118a88:	e0bfff03 	ldbu	r2,-4(fp)
81118a8c:	10c00b24 	muli	r3,r2,44
81118a90:	00a045b4 	movhi	r2,33046
81118a94:	10ad8004 	addi	r2,r2,-18944
81118a98:	1885883a 	add	r2,r3,r2
81118a9c:	01800804 	movi	r6,32
81118aa0:	000b883a 	mov	r5,zero
81118aa4:	1009883a 	mov	r4,r2
81118aa8:	1123b2c0 	call	81123b2c <memset>
		xBuffer32[ucIL].bSent = FALSE;
81118aac:	e0ffff03 	ldbu	r3,-4(fp)
81118ab0:	00a045b4 	movhi	r2,33046
81118ab4:	10ad8004 	addi	r2,r2,-18944
81118ab8:	18c00b24 	muli	r3,r3,44
81118abc:	10c5883a 	add	r2,r2,r3
81118ac0:	10800804 	addi	r2,r2,32
81118ac4:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81118ac8:	e0ffff03 	ldbu	r3,-4(fp)
81118acc:	00a045b4 	movhi	r2,33046
81118ad0:	10ad8004 	addi	r2,r2,-18944
81118ad4:	18c00b24 	muli	r3,r3,44
81118ad8:	10c5883a 	add	r2,r2,r3
81118adc:	10800904 	addi	r2,r2,36
81118ae0:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
81118ae4:	e0ffff03 	ldbu	r3,-4(fp)
81118ae8:	00a045b4 	movhi	r2,33046
81118aec:	10ad8004 	addi	r2,r2,-18944
81118af0:	18c00b24 	muli	r3,r3,44
81118af4:	10c5883a 	add	r2,r2,r3
81118af8:	10800984 	addi	r2,r2,38
81118afc:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81118b00:	e0ffff03 	ldbu	r3,-4(fp)
81118b04:	00a045b4 	movhi	r2,33046
81118b08:	10ad8004 	addi	r2,r2,-18944
81118b0c:	18c00b24 	muli	r3,r3,44
81118b10:	10c5883a 	add	r2,r2,r3
81118b14:	10800a04 	addi	r2,r2,40
81118b18:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81118b1c:	e0bfff03 	ldbu	r2,-4(fp)
81118b20:	10800044 	addi	r2,r2,1
81118b24:	e0bfff05 	stb	r2,-4(fp)
81118b28:	e0bfff03 	ldbu	r2,-4(fp)
81118b2c:	10800230 	cmpltui	r2,r2,8
81118b30:	103fd51e 	bne	r2,zero,81118a88 <__reset+0xfb0f8a88>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81118b34:	e03fff05 	stb	zero,-4(fp)
81118b38:	00001b06 	br	81118ba8 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
81118b3c:	e0ffff03 	ldbu	r3,-4(fp)
81118b40:	00a04574 	movhi	r2,33045
81118b44:	109c5c04 	addi	r2,r2,29040
81118b48:	18c01524 	muli	r3,r3,84
81118b4c:	10c5883a 	add	r2,r2,r3
81118b50:	10800104 	addi	r2,r2,4
81118b54:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
81118b58:	e0ffff03 	ldbu	r3,-4(fp)
81118b5c:	00a04574 	movhi	r2,33045
81118b60:	109c5c04 	addi	r2,r2,29040
81118b64:	18c01524 	muli	r3,r3,84
81118b68:	10c5883a 	add	r2,r2,r3
81118b6c:	10800484 	addi	r2,r2,18
81118b70:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
81118b74:	e0bfff03 	ldbu	r2,-4(fp)
81118b78:	10801524 	muli	r2,r2,84
81118b7c:	10c00504 	addi	r3,r2,20
81118b80:	00a04574 	movhi	r2,33045
81118b84:	109c5c04 	addi	r2,r2,29040
81118b88:	1885883a 	add	r2,r3,r2
81118b8c:	01801004 	movi	r6,64
81118b90:	000b883a 	mov	r5,zero
81118b94:	1009883a 	mov	r4,r2
81118b98:	1123b2c0 	call	81123b2c <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81118b9c:	e0bfff03 	ldbu	r2,-4(fp)
81118ba0:	10800044 	addi	r2,r2,1
81118ba4:	e0bfff05 	stb	r2,-4(fp)
81118ba8:	e0bfff03 	ldbu	r2,-4(fp)
81118bac:	10800130 	cmpltui	r2,r2,4
81118bb0:	103fe21e 	bne	r2,zero,81118b3c <__reset+0xfb0f8b3c>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
81118bb4:	0001883a 	nop
81118bb8:	e037883a 	mov	sp,fp
81118bbc:	dfc00117 	ldw	ra,4(sp)
81118bc0:	df000017 	ldw	fp,0(sp)
81118bc4:	dec00204 	addi	sp,sp,8
81118bc8:	f800283a 	ret

81118bcc <main>:
void vFillMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
81118bcc:	defff704 	addi	sp,sp,-36
81118bd0:	de00012e 	bgeu	sp,et,81118bd8 <main+0xc>
81118bd4:	003b68fa 	trap	3
81118bd8:	dfc00815 	stw	ra,32(sp)
81118bdc:	df000715 	stw	fp,28(sp)
81118be0:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
81118be4:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
81118be8:	1139d880 	call	81139d88 <OSInit>

	/* Debug device initialization - JTAG USB */
	#if DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
81118bec:	01604574 	movhi	r5,33045
81118bf0:	297e5b04 	addi	r5,r5,-1684
81118bf4:	01204574 	movhi	r4,33045
81118bf8:	213e5c04 	addi	r4,r4,-1680
81118bfc:	11228e40 	call	811228e4 <fopen>
81118c00:	d0a06215 	stw	r2,-32376(gp)
	#endif	

	#if DEBUG_ON
		debug(fp, "Main entry point.\n");
81118c04:	d0a06217 	ldw	r2,-32376(gp)
81118c08:	100f883a 	mov	r7,r2
81118c0c:	01800484 	movi	r6,18
81118c10:	01400044 	movi	r5,1
81118c14:	01204574 	movhi	r4,33045
81118c18:	213e6104 	addi	r4,r4,-1660
81118c1c:	1122fc80 	call	81122fc8 <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
81118c20:	111f6f00 	call	8111f6f0 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
81118c24:	11202700 	call	81120270 <bTestSimucamCriticalHW>
81118c28:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81118c2c:	e0bffe17 	ldw	r2,-8(fp)
81118c30:	1000031e 	bne	r2,zero,81118c40 <main+0x74>
		vFailTestCriticasParts();
81118c34:	111c61c0 	call	8111c61c <vFailTestCriticasParts>
		return -1;
81118c38:	00bfffc4 	movi	r2,-1
81118c3c:	00006606 	br	81118dd8 <main+0x20c>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
81118c40:	111fe640 	call	8111fe64 <bInitializeSDCard>
81118c44:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81118c48:	e0bffe17 	ldw	r2,-8(fp)
81118c4c:	1000031e 	bne	r2,zero,81118c5c <main+0x90>
		vFailTestCriticasParts();
81118c50:	111c61c0 	call	8111c61c <vFailTestCriticasParts>
		return -1;
81118c54:	00bfffc4 	movi	r2,-1
81118c58:	00005f06 	br	81118dd8 <main+0x20c>
	}

	bIniSimucamStatus = vLoadDebugConfs();
81118c5c:	111b49c0 	call	8111b49c <vLoadDebugConfs>
81118c60:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81118c64:	e0bffe17 	ldw	r2,-8(fp)
81118c68:	10000f1e 	bne	r2,zero,81118ca8 <main+0xdc>
		/* Default configuration for eth connection loaded */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81118c6c:	00a045b4 	movhi	r2,33046
81118c70:	109fe204 	addi	r2,r2,32648
81118c74:	10800d8b 	ldhu	r2,54(r2)
81118c78:	10bfffcc 	andi	r2,r2,65535
81118c7c:	10800228 	cmpgeui	r2,r2,8
81118c80:	1000071e 	bne	r2,zero,81118ca0 <main+0xd4>
			debug(fp, "Didn't load DEBUG configuration from SDCard. Default configuration will be loaded. \n");
81118c84:	d0a06217 	ldw	r2,-32376(gp)
81118c88:	100f883a 	mov	r7,r2
81118c8c:	01801504 	movi	r6,84
81118c90:	01400044 	movi	r5,1
81118c94:	01204574 	movhi	r4,33045
81118c98:	213e6604 	addi	r4,r4,-1640
81118c9c:	1122fc80 	call	81122fc8 <fwrite>
		}
		#endif
		return -1;
81118ca0:	00bfffc4 	movi	r2,-1
81118ca4:	00004c06 	br	81118dd8 <main+0x20c>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
81118ca8:	111a72c0 	call	8111a72c <vLoadDefaultETHConf>
81118cac:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81118cb0:	e0bffe17 	ldw	r2,-8(fp)
81118cb4:	10000f1e 	bne	r2,zero,81118cf4 <main+0x128>
		/* Default configuration for eth connection loaded */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81118cb8:	00a045b4 	movhi	r2,33046
81118cbc:	109fe204 	addi	r2,r2,32648
81118cc0:	10800d8b 	ldhu	r2,54(r2)
81118cc4:	10bfffcc 	andi	r2,r2,65535
81118cc8:	10800228 	cmpgeui	r2,r2,8
81118ccc:	1000071e 	bne	r2,zero,81118cec <main+0x120>
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. \n");
81118cd0:	d0a06217 	ldw	r2,-32376(gp)
81118cd4:	100f883a 	mov	r7,r2
81118cd8:	01801484 	movi	r6,82
81118cdc:	01400044 	movi	r5,1
81118ce0:	01204574 	movhi	r4,33045
81118ce4:	213e7c04 	addi	r4,r4,-1552
81118ce8:	1122fc80 	call	81122fc8 <fwrite>
		}
		#endif
		return -1;
81118cec:	00bfffc4 	movi	r2,-1
81118cf0:	00003906 	br	81118dd8 <main+0x20c>
	}


	/* If debug is enable, will print the eth configuration in the*/
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81118cf4:	00a045b4 	movhi	r2,33046
81118cf8:	109fe204 	addi	r2,r2,32648
81118cfc:	10800d8b 	ldhu	r2,54(r2)
81118d00:	10bfffcc 	andi	r2,r2,65535
81118d04:	108000e8 	cmpgeui	r2,r2,3
81118d08:	1000011e 	bne	r2,zero,81118d10 <main+0x144>
		vShowEthConfig();
81118d0c:	111b16c0 	call	8111b16c <vShowEthConfig>
	}
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
81118d10:	11184480 	call	81118448 <bResourcesInitRTOS>
81118d14:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81118d18:	e0bffe17 	ldw	r2,-8(fp)
81118d1c:	10000f1e 	bne	r2,zero,81118d5c <main+0x190>
		/* Default configuration for eth connection loaded */
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81118d20:	00a045b4 	movhi	r2,33046
81118d24:	109fe204 	addi	r2,r2,32648
81118d28:	10800d8b 	ldhu	r2,54(r2)
81118d2c:	10bfffcc 	andi	r2,r2,65535
81118d30:	10800228 	cmpgeui	r2,r2,8
81118d34:	1000071e 	bne	r2,zero,81118d54 <main+0x188>
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
81118d38:	d0a06217 	ldw	r2,-32376(gp)
81118d3c:	100f883a 	mov	r7,r2
81118d40:	01800ac4 	movi	r6,43
81118d44:	01400044 	movi	r5,1
81118d48:	01204574 	movhi	r4,33045
81118d4c:	213e9104 	addi	r4,r4,-1468
81118d50:	1122fc80 	call	81122fc8 <fwrite>
	}
	#endif
		return -1;
81118d54:	00bfffc4 	movi	r2,-1
81118d58:	00001f06 	br	81118dd8 <main+0x20c>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
81118d5c:	012045b4 	movhi	r4,33046
81118d60:	2128d204 	addi	r4,r4,-23736
81118d64:	111f8300 	call	8111f830 <vSimucamStructureInit>

	vVariablesInitialization();
81118d68:	11188b80 	call	811188b8 <vVariablesInitialization>

	bInitSync();
81118d6c:	11200180 	call	81120018 <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
81118d70:	012045b4 	movhi	r4,33046
81118d74:	2128d204 	addi	r4,r4,-23736
81118d78:	1118dec0 	call	81118dec <vFillMemmoryPattern>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
81118d7c:	d8000415 	stw	zero,16(sp)
81118d80:	d8000315 	stw	zero,12(sp)
81118d84:	00810004 	movi	r2,1024
81118d88:	d8800215 	stw	r2,8(sp)
81118d8c:	00a045b4 	movhi	r2,33046
81118d90:	10b7f804 	addi	r2,r2,-8224
81118d94:	d8800115 	stw	r2,4(sp)
81118d98:	00800044 	movi	r2,1
81118d9c:	d8800015 	stw	r2,0(sp)
81118da0:	01c00044 	movi	r7,1
81118da4:	01a045b4 	movhi	r6,33046
81118da8:	31bbf704 	addi	r6,r6,-4132
81118dac:	000b883a 	mov	r5,zero
81118db0:	01204474 	movhi	r4,33041
81118db4:	210ae004 	addi	r4,r4,11136
81118db8:	1140b380 	call	81140b38 <OSTaskCreateExt>
81118dbc:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
81118dc0:	e0bfff03 	ldbu	r2,-4(fp)
81118dc4:	1000021e 	bne	r2,zero,81118dd0 <main+0x204>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
81118dc8:	113a0b80 	call	8113a0b8 <OSStart>
81118dcc:	00000106 	br	81118dd4 <main+0x208>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
81118dd0:	111cb100 	call	8111cb10 <vFailInitialization>
	}
  
	return 0;
81118dd4:	0005883a 	mov	r2,zero
}
81118dd8:	e037883a 	mov	sp,fp
81118ddc:	dfc00117 	ldw	ra,4(sp)
81118de0:	df000017 	ldw	fp,0(sp)
81118de4:	dec00204 	addi	sp,sp,8
81118de8:	f800283a 	ret

81118dec <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81118dec:	defff604 	addi	sp,sp,-40
81118df0:	de00012e 	bgeu	sp,et,81118df8 <vFillMemmoryPattern+0xc>
81118df4:	003b68fa 	trap	3
81118df8:	dfc00915 	stw	ra,36(sp)
81118dfc:	df000815 	stw	fp,32(sp)
81118e00:	df000804 	addi	fp,sp,32
81118e04:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81118e08:	00800044 	movi	r2,1
81118e0c:	e0bffcc5 	stb	r2,-13(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81118e10:	00a045b4 	movhi	r2,33046
81118e14:	109fe204 	addi	r2,r2,32648
81118e18:	10800d8b 	ldhu	r2,54(r2)
81118e1c:	10bfffcc 	andi	r2,r2,65535
81118e20:	10800168 	cmpgeui	r2,r2,5
81118e24:	1000071e 	bne	r2,zero,81118e44 <vFillMemmoryPattern+0x58>
		debug(fp, "\nStart to fill the memory with Pattern.\n");
81118e28:	d0a06217 	ldw	r2,-32376(gp)
81118e2c:	100f883a 	mov	r7,r2
81118e30:	01800a04 	movi	r6,40
81118e34:	01400044 	movi	r5,1
81118e38:	01204574 	movhi	r4,33045
81118e3c:	213e9c04 	addi	r4,r4,-1424
81118e40:	1122fc80 	call	81122fc8 <fwrite>
	}
#endif

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81118e44:	e03ffa05 	stb	zero,-24(fp)
81118e48:	0000a706 	br	811190e8 <vFillMemmoryPattern+0x2fc>
		/* n NFEE */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81118e4c:	00a045b4 	movhi	r2,33046
81118e50:	109fe204 	addi	r2,r2,32648
81118e54:	10800d8b 	ldhu	r2,54(r2)
81118e58:	10bfffcc 	andi	r2,r2,65535
81118e5c:	10800168 	cmpgeui	r2,r2,5
81118e60:	1000071e 	bne	r2,zero,81118e80 <vFillMemmoryPattern+0x94>
			fprintf(fp, "Memory %i\n",mem_number);
81118e64:	d0a06217 	ldw	r2,-32376(gp)
81118e68:	e0fffa03 	ldbu	r3,-24(fp)
81118e6c:	180d883a 	mov	r6,r3
81118e70:	01604574 	movhi	r5,33045
81118e74:	297ea704 	addi	r5,r5,-1380
81118e78:	1009883a 	mov	r4,r2
81118e7c:	112292c0 	call	8112292c <fprintf>
		}
		#endif
		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81118e80:	e03ffc85 	stb	zero,-14(fp)
81118e84:	00009206 	br	811190d0 <vFillMemmoryPattern+0x2e4>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81118e88:	00a045b4 	movhi	r2,33046
81118e8c:	109fe204 	addi	r2,r2,32648
81118e90:	10800d8b 	ldhu	r2,54(r2)
81118e94:	10bfffcc 	andi	r2,r2,65535
81118e98:	10800168 	cmpgeui	r2,r2,5
81118e9c:	1000071e 	bne	r2,zero,81118ebc <vFillMemmoryPattern+0xd0>
				fprintf(fp, "--NFEE %i\n", NFee_i);
81118ea0:	d0a06217 	ldw	r2,-32376(gp)
81118ea4:	e0fffc83 	ldbu	r3,-14(fp)
81118ea8:	180d883a 	mov	r6,r3
81118eac:	01604574 	movhi	r5,33045
81118eb0:	297eaa04 	addi	r5,r5,-1368
81118eb4:	1009883a 	mov	r4,r2
81118eb8:	112292c0 	call	8112292c <fprintf>
			}
			#endif
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81118ebc:	e0bffc83 	ldbu	r2,-14(fp)
81118ec0:	e0ffff17 	ldw	r3,-4(fp)
81118ec4:	10809624 	muli	r2,r2,600
81118ec8:	1885883a 	add	r2,r3,r2
81118ecc:	10804304 	addi	r2,r2,268
81118ed0:	1080000b 	ldhu	r2,0(r2)
81118ed4:	10ffffcc 	andi	r3,r2,65535
81118ed8:	e0bffc83 	ldbu	r2,-14(fp)
81118edc:	e13fff17 	ldw	r4,-4(fp)
81118ee0:	10809624 	muli	r2,r2,600
81118ee4:	2085883a 	add	r2,r4,r2
81118ee8:	10804204 	addi	r2,r2,264
81118eec:	1080000b 	ldhu	r2,0(r2)
81118ef0:	10bfffcc 	andi	r2,r2,65535
81118ef4:	1885883a 	add	r2,r3,r2
81118ef8:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81118efc:	e0bffc83 	ldbu	r2,-14(fp)
81118f00:	e0ffff17 	ldw	r3,-4(fp)
81118f04:	10809624 	muli	r2,r2,600
81118f08:	1885883a 	add	r2,r3,r2
81118f0c:	10804284 	addi	r2,r2,266
81118f10:	1080000b 	ldhu	r2,0(r2)
81118f14:	10ffffcc 	andi	r3,r2,65535
81118f18:	e0bffc83 	ldbu	r2,-14(fp)
81118f1c:	e13fff17 	ldw	r4,-4(fp)
81118f20:	10809624 	muli	r2,r2,600
81118f24:	2085883a 	add	r2,r4,r2
81118f28:	10804184 	addi	r2,r2,262
81118f2c:	1080000b 	ldhu	r2,0(r2)
81118f30:	10bfffcc 	andi	r2,r2,65535
81118f34:	1887883a 	add	r3,r3,r2
81118f38:	e0bffc83 	ldbu	r2,-14(fp)
81118f3c:	e13fff17 	ldw	r4,-4(fp)
81118f40:	10809624 	muli	r2,r2,600
81118f44:	2085883a 	add	r2,r4,r2
81118f48:	10804104 	addi	r2,r2,260
81118f4c:	1080000b 	ldhu	r2,0(r2)
81118f50:	10bfffcc 	andi	r2,r2,65535
81118f54:	1885883a 	add	r2,r3,r2
81118f58:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81118f5c:	e03ffc05 	stb	zero,-16(fp)
81118f60:	00005506 	br	811190b8 <vFillMemmoryPattern+0x2cc>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81118f64:	00a045b4 	movhi	r2,33046
81118f68:	109fe204 	addi	r2,r2,32648
81118f6c:	10800d8b 	ldhu	r2,54(r2)
81118f70:	10bfffcc 	andi	r2,r2,65535
81118f74:	10800168 	cmpgeui	r2,r2,5
81118f78:	1000071e 	bne	r2,zero,81118f98 <vFillMemmoryPattern+0x1ac>
					fprintf(fp, "-----CCD %i\n", ccd_number);
81118f7c:	d0a06217 	ldw	r2,-32376(gp)
81118f80:	e0fffc03 	ldbu	r3,-16(fp)
81118f84:	180d883a 	mov	r6,r3
81118f88:	01604574 	movhi	r5,33045
81118f8c:	297ead04 	addi	r5,r5,-1356
81118f90:	1009883a 	mov	r4,r2
81118f94:	112292c0 	call	8112292c <fprintf>
				}
				#endif

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81118f98:	e03ffc45 	stb	zero,-15(fp)
81118f9c:	00004006 	br	811190a0 <vFillMemmoryPattern+0x2b4>
					if (ccd_side == 0){
81118fa0:	e0bffc43 	ldbu	r2,-15(fp)
81118fa4:	1000181e 	bne	r2,zero,81119008 <vFillMemmoryPattern+0x21c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81118fa8:	00a045b4 	movhi	r2,33046
81118fac:	109fe204 	addi	r2,r2,32648
81118fb0:	10800d8b 	ldhu	r2,54(r2)
81118fb4:	10bfffcc 	andi	r2,r2,65535
81118fb8:	10800168 	cmpgeui	r2,r2,5
81118fbc:	1000071e 	bne	r2,zero,81118fdc <vFillMemmoryPattern+0x1f0>
							fprintf(fp, "------Left side\n");
81118fc0:	d0a06217 	ldw	r2,-32376(gp)
81118fc4:	100f883a 	mov	r7,r2
81118fc8:	01800404 	movi	r6,16
81118fcc:	01400044 	movi	r5,1
81118fd0:	01204574 	movhi	r4,33045
81118fd4:	213eb104 	addi	r4,r4,-1340
81118fd8:	1122fc80 	call	81122fc8 <fwrite>
						}
						#endif
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81118fdc:	e0bffc83 	ldbu	r2,-14(fp)
81118fe0:	e13ffc03 	ldbu	r4,-16(fp)
81118fe4:	e0ffff17 	ldw	r3,-4(fp)
81118fe8:	21000624 	muli	r4,r4,24
81118fec:	10809624 	muli	r2,r2,600
81118ff0:	2085883a 	add	r2,r4,r2
81118ff4:	1885883a 	add	r2,r3,r2
81118ff8:	10801b04 	addi	r2,r2,108
81118ffc:	10800017 	ldw	r2,0(r2)
81119000:	e0bffb15 	stw	r2,-20(fp)
81119004:	00001706 	br	81119064 <vFillMemmoryPattern+0x278>
					} else {
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
81119008:	00a045b4 	movhi	r2,33046
8111900c:	109fe204 	addi	r2,r2,32648
81119010:	10800d8b 	ldhu	r2,54(r2)
81119014:	10bfffcc 	andi	r2,r2,65535
81119018:	10800168 	cmpgeui	r2,r2,5
8111901c:	1000071e 	bne	r2,zero,8111903c <vFillMemmoryPattern+0x250>
							fprintf(fp, "------Right side\n");
81119020:	d0a06217 	ldw	r2,-32376(gp)
81119024:	100f883a 	mov	r7,r2
81119028:	01800444 	movi	r6,17
8111902c:	01400044 	movi	r5,1
81119030:	01204574 	movhi	r4,33045
81119034:	213eb604 	addi	r4,r4,-1320
81119038:	1122fc80 	call	81122fc8 <fwrite>
						}
						#endif
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
8111903c:	e0bffc83 	ldbu	r2,-14(fp)
81119040:	e13ffc03 	ldbu	r4,-16(fp)
81119044:	e0ffff17 	ldw	r3,-4(fp)
81119048:	21000624 	muli	r4,r4,24
8111904c:	10809624 	muli	r2,r2,600
81119050:	2085883a 	add	r2,r4,r2
81119054:	1885883a 	add	r2,r3,r2
81119058:	10801e04 	addi	r2,r2,120
8111905c:	10800017 	ldw	r2,0(r2)
81119060:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81119064:	e0fffa03 	ldbu	r3,-24(fp)
81119068:	e13ffc03 	ldbu	r4,-16(fp)
8111906c:	e17ffc43 	ldbu	r5,-15(fp)
81119070:	e0bffd17 	ldw	r2,-12(fp)
81119074:	d8800115 	stw	r2,4(sp)
81119078:	e0bffe17 	ldw	r2,-8(fp)
8111907c:	d8800015 	stw	r2,0(sp)
81119080:	280f883a 	mov	r7,r5
81119084:	200d883a 	mov	r6,r4
81119088:	e17ffb17 	ldw	r5,-20(fp)
8111908c:	1809883a 	mov	r4,r3
81119090:	111fbf40 	call	8111fbf4 <pattern_createPattern>
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp, "-----CCD %i\n", ccd_number);
				}
				#endif

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81119094:	e0bffc43 	ldbu	r2,-15(fp)
81119098:	10800044 	addi	r2,r2,1
8111909c:	e0bffc45 	stb	r2,-15(fp)
811190a0:	e0bffc43 	ldbu	r2,-15(fp)
811190a4:	108000b0 	cmpltui	r2,r2,2
811190a8:	103fbd1e 	bne	r2,zero,81118fa0 <__reset+0xfb0f8fa0>
			}
			#endif
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811190ac:	e0bffc03 	ldbu	r2,-16(fp)
811190b0:	10800044 	addi	r2,r2,1
811190b4:	e0bffc05 	stb	r2,-16(fp)
811190b8:	e0bffc03 	ldbu	r2,-16(fp)
811190bc:	10800130 	cmpltui	r2,r2,4
811190c0:	103fa81e 	bne	r2,zero,81118f64 <__reset+0xfb0f8f64>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
			fprintf(fp, "Memory %i\n",mem_number);
		}
		#endif
		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811190c4:	e0bffc83 	ldbu	r2,-14(fp)
811190c8:	10800044 	addi	r2,r2,1
811190cc:	e0bffc85 	stb	r2,-14(fp)
811190d0:	e0fffc83 	ldbu	r3,-14(fp)
811190d4:	e0bffcc3 	ldbu	r2,-13(fp)
811190d8:	18bf6b36 	bltu	r3,r2,81118e88 <__reset+0xfb0f8e88>
		debug(fp, "\nStart to fill the memory with Pattern.\n");
	}
#endif

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
811190dc:	e0bffa03 	ldbu	r2,-24(fp)
811190e0:	10800044 	addi	r2,r2,1
811190e4:	e0bffa05 	stb	r2,-24(fp)
811190e8:	e0bffa03 	ldbu	r2,-24(fp)
811190ec:	108000b0 	cmpltui	r2,r2,2
811190f0:	103f561e 	bne	r2,zero,81118e4c <__reset+0xfb0f8e4c>
			}
		}
	}

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
811190f4:	00a045b4 	movhi	r2,33046
811190f8:	109fe204 	addi	r2,r2,32648
811190fc:	10800d8b 	ldhu	r2,54(r2)
81119100:	10bfffcc 	andi	r2,r2,65535
81119104:	10800168 	cmpgeui	r2,r2,5
81119108:	1000071e 	bne	r2,zero,81119128 <vFillMemmoryPattern+0x33c>
	debug(fp, "\nMemory Filled\n");
8111910c:	d0a06217 	ldw	r2,-32376(gp)
81119110:	100f883a 	mov	r7,r2
81119114:	018003c4 	movi	r6,15
81119118:	01400044 	movi	r5,1
8111911c:	01204574 	movhi	r4,33045
81119120:	213ebb04 	addi	r4,r4,-1300
81119124:	1122fc80 	call	81122fc8 <fwrite>
	}
#endif

}
81119128:	0001883a 	nop
8111912c:	e037883a 	mov	sp,fp
81119130:	dfc00117 	ldw	ra,4(sp)
81119134:	df000017 	ldw	fp,0(sp)
81119138:	dec00204 	addi	sp,sp,8
8111913c:	f800283a 	ret

81119140 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
81119140:	defffd04 	addi	sp,sp,-12
81119144:	de00012e 	bgeu	sp,et,8111914c <vCCDLoadDefaultValues+0xc>
81119148:	003b68fa 	trap	3
8111914c:	dfc00215 	stw	ra,8(sp)
81119150:	df000115 	stw	fp,4(sp)
81119154:	df000104 	addi	fp,sp,4
81119158:	e13fff15 	stw	r4,-4(fp)
	ccdDef->usiOLN = 30;
	ccdDef->usiHalfWidth = 2255;
	ccdDef->usiSOverscanN = 15;
	ccdDef->usiSPrescanN = 25;
*/
	ccdDef->usiHeight = xDefaults.usiRows;
8111915c:	00a045b4 	movhi	r2,33046
81119160:	109fe204 	addi	r2,r2,32648
81119164:	10c0060b 	ldhu	r3,24(r2)
81119168:	e0bfff17 	ldw	r2,-4(fp)
8111916c:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = xDefaults.usiOLN;
81119170:	00a045b4 	movhi	r2,33046
81119174:	109fe204 	addi	r2,r2,32648
81119178:	10c0050b 	ldhu	r3,20(r2)
8111917c:	e0bfff17 	ldw	r2,-4(fp)
81119180:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = xDefaults.usiCols;
81119184:	00a045b4 	movhi	r2,33046
81119188:	109fe204 	addi	r2,r2,32648
8111918c:	10c0058b 	ldhu	r3,22(r2)
81119190:	e0bfff17 	ldw	r2,-4(fp)
81119194:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = xDefaults.usiOverScanSerial;
81119198:	00a045b4 	movhi	r2,33046
8111919c:	109fe204 	addi	r2,r2,32648
811191a0:	10c0040b 	ldhu	r3,16(r2)
811191a4:	e0bfff17 	ldw	r2,-4(fp)
811191a8:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = xDefaults.usiPreScanSerial;
811191ac:	00a045b4 	movhi	r2,33046
811191b0:	109fe204 	addi	r2,r2,32648
811191b4:	10c0048b 	ldhu	r3,18(r2)
811191b8:	e0bfff17 	ldw	r2,-4(fp)
811191bc:	10c0000d 	sth	r3,0(r2)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811191c0:	00a045b4 	movhi	r2,33046
811191c4:	109fe204 	addi	r2,r2,32648
811191c8:	10800d8b 	ldhu	r2,54(r2)
811191cc:	10bfffcc 	andi	r2,r2,65535
811191d0:	108000e8 	cmpgeui	r2,r2,3
811191d4:	10002d1e 	bne	r2,zero,8111928c <vCCDLoadDefaultValues+0x14c>
		fprintf(fp,"\nusiHeight %hu\n", ccdDef->usiHeight);
811191d8:	d0e06217 	ldw	r3,-32376(gp)
811191dc:	e0bfff17 	ldw	r2,-4(fp)
811191e0:	1080020b 	ldhu	r2,8(r2)
811191e4:	10bfffcc 	andi	r2,r2,65535
811191e8:	100d883a 	mov	r6,r2
811191ec:	01604574 	movhi	r5,33045
811191f0:	297ebf04 	addi	r5,r5,-1284
811191f4:	1809883a 	mov	r4,r3
811191f8:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"usiOLN %hu\n", ccdDef->usiOLN);
811191fc:	d0e06217 	ldw	r3,-32376(gp)
81119200:	e0bfff17 	ldw	r2,-4(fp)
81119204:	1080010b 	ldhu	r2,4(r2)
81119208:	10bfffcc 	andi	r2,r2,65535
8111920c:	100d883a 	mov	r6,r2
81119210:	01604574 	movhi	r5,33045
81119214:	297ec304 	addi	r5,r5,-1268
81119218:	1809883a 	mov	r4,r3
8111921c:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"usiHalfWidth %hu\n", ccdDef->usiHalfWidth);
81119220:	d0e06217 	ldw	r3,-32376(gp)
81119224:	e0bfff17 	ldw	r2,-4(fp)
81119228:	1080018b 	ldhu	r2,6(r2)
8111922c:	10bfffcc 	andi	r2,r2,65535
81119230:	100d883a 	mov	r6,r2
81119234:	01604574 	movhi	r5,33045
81119238:	297ec604 	addi	r5,r5,-1256
8111923c:	1809883a 	mov	r4,r3
81119240:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"usiSOverscanN %hu\n", ccdDef->usiSOverscanN);
81119244:	d0e06217 	ldw	r3,-32376(gp)
81119248:	e0bfff17 	ldw	r2,-4(fp)
8111924c:	1080008b 	ldhu	r2,2(r2)
81119250:	10bfffcc 	andi	r2,r2,65535
81119254:	100d883a 	mov	r6,r2
81119258:	01604574 	movhi	r5,33045
8111925c:	297ecb04 	addi	r5,r5,-1236
81119260:	1809883a 	mov	r4,r3
81119264:	112292c0 	call	8112292c <fprintf>
		fprintf(fp,"usiSPrescanN %hu\n",  ccdDef->usiSPrescanN);
81119268:	d0e06217 	ldw	r3,-32376(gp)
8111926c:	e0bfff17 	ldw	r2,-4(fp)
81119270:	1080000b 	ldhu	r2,0(r2)
81119274:	10bfffcc 	andi	r2,r2,65535
81119278:	100d883a 	mov	r6,r2
8111927c:	01604574 	movhi	r5,33045
81119280:	297ed004 	addi	r5,r5,-1216
81119284:	1809883a 	mov	r4,r3
81119288:	112292c0 	call	8112292c <fprintf>
	}
#endif

}
8111928c:	0001883a 	nop
81119290:	e037883a 	mov	sp,fp
81119294:	dfc00117 	ldw	ra,4(sp)
81119298:	df000017 	ldw	fp,0(sp)
8111929c:	dec00204 	addi	sp,sp,8
811192a0:	f800283a 	ret

811192a4 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
811192a4:	defff904 	addi	sp,sp,-28
811192a8:	de00012e 	bgeu	sp,et,811192b0 <vCCDChangeValues+0xc>
811192ac:	003b68fa 	trap	3
811192b0:	df000615 	stw	fp,24(sp)
811192b4:	df000604 	addi	fp,sp,24
811192b8:	e13ffa15 	stw	r4,-24(fp)
811192bc:	2811883a 	mov	r8,r5
811192c0:	300b883a 	mov	r5,r6
811192c4:	3809883a 	mov	r4,r7
811192c8:	e0c00117 	ldw	r3,4(fp)
811192cc:	e0800217 	ldw	r2,8(fp)
811192d0:	e23ffb0d 	sth	r8,-20(fp)
811192d4:	e17ffc0d 	sth	r5,-16(fp)
811192d8:	e13ffd0d 	sth	r4,-12(fp)
811192dc:	e0fffe0d 	sth	r3,-8(fp)
811192e0:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
811192e4:	e0bffa17 	ldw	r2,-24(fp)
811192e8:	e0fffb0b 	ldhu	r3,-20(fp)
811192ec:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
811192f0:	e0bffa17 	ldw	r2,-24(fp)
811192f4:	e0fffc0b 	ldhu	r3,-16(fp)
811192f8:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
811192fc:	e0bffa17 	ldw	r2,-24(fp)
81119300:	e0fffd0b 	ldhu	r3,-12(fp)
81119304:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81119308:	e0bffa17 	ldw	r2,-24(fp)
8111930c:	e0fffe0b 	ldhu	r3,-8(fp)
81119310:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
81119314:	e0bffa17 	ldw	r2,-24(fp)
81119318:	e0ffff0b 	ldhu	r3,-4(fp)
8111931c:	10c0000d 	sth	r3,0(r2)
}
81119320:	0001883a 	nop
81119324:	e037883a 	mov	sp,fp
81119328:	df000017 	ldw	fp,0(sp)
8111932c:	dec00104 	addi	sp,sp,4
81119330:	f800283a 	ret

81119334 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
81119334:	defff904 	addi	sp,sp,-28
81119338:	de00012e 	bgeu	sp,et,81119340 <bSendUART128v2+0xc>
8111933c:	003b68fa 	trap	3
81119340:	dfc00615 	stw	ra,24(sp)
81119344:	df000515 	stw	fp,20(sp)
81119348:	df000504 	addi	fp,sp,20
8111934c:	e13ffe15 	stw	r4,-8(fp)
81119350:	2805883a 	mov	r2,r5
81119354:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
81119358:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8111935c:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81119360:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81119364:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81119368:	d0a06317 	ldw	r2,-32372(gp)
8111936c:	e0fffd04 	addi	r3,fp,-12
81119370:	180d883a 	mov	r6,r3
81119374:	01400504 	movi	r5,20
81119378:	1009883a 	mov	r4,r2
8111937c:	113fdcc0 	call	8113fdcc <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81119380:	e0bffd03 	ldbu	r2,-12(fp)
81119384:	10803fcc 	andi	r2,r2,255
81119388:	10000326 	beq	r2,zero,81119398 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8111938c:	111ce200 	call	8111ce20 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
81119390:	e0bffc17 	ldw	r2,-16(fp)
81119394:	0000aa06 	br	81119640 <bSendUART128v2+0x30c>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81119398:	d0a06e17 	ldw	r2,-32328(gp)
8111939c:	e0fffd04 	addi	r3,fp,-12
811193a0:	180d883a 	mov	r6,r3
811193a4:	01400104 	movi	r5,4
811193a8:	1009883a 	mov	r4,r2
811193ac:	113ddc00 	call	8113ddc0 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811193b0:	e0bffd03 	ldbu	r2,-12(fp)
811193b4:	10803fcc 	andi	r2,r2,255
811193b8:	10001726 	beq	r2,zero,81119418 <bSendUART128v2+0xe4>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811193bc:	00a045b4 	movhi	r2,33046
811193c0:	109fe204 	addi	r2,r2,32648
811193c4:	10800d8b 	ldhu	r2,54(r2)
811193c8:	10bfffcc 	andi	r2,r2,65535
811193cc:	10800228 	cmpgeui	r2,r2,8
811193d0:	1000071e 	bne	r2,zero,811193f0 <bSendUART128v2+0xbc>
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
811193d4:	d0a06217 	ldw	r2,-32376(gp)
811193d8:	100f883a 	mov	r7,r2
811193dc:	01801484 	movi	r6,82
811193e0:	01400044 	movi	r5,1
811193e4:	01204574 	movhi	r4,33045
811193e8:	213ed504 	addi	r4,r4,-1196
811193ec:	1122fc80 	call	81122fc8 <fwrite>
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
811193f0:	d0a06317 	ldw	r2,-32372(gp)
811193f4:	1009883a 	mov	r4,r2
811193f8:	11401540 	call	81140154 <OSSemPost>
811193fc:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81119400:	e0bffd03 	ldbu	r2,-12(fp)
81119404:	10803fcc 	andi	r2,r2,255
81119408:	10000126 	beq	r2,zero,81119410 <bSendUART128v2+0xdc>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8111940c:	111cda00 	call	8111cda0 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81119410:	e0bffc17 	ldw	r2,-16(fp)
81119414:	00008a06 	br	81119640 <bSendUART128v2+0x30c>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81119418:	e03ffb05 	stb	zero,-20(fp)
8111941c:	00004306 	br	8111952c <bSendUART128v2+0x1f8>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81119420:	e0fffb03 	ldbu	r3,-20(fp)
81119424:	00a045b4 	movhi	r2,33046
81119428:	10800004 	addi	r2,r2,0
8111942c:	18c7883a 	add	r3,r3,r3
81119430:	18c7883a 	add	r3,r3,r3
81119434:	10c5883a 	add	r2,r2,r3
81119438:	10800017 	ldw	r2,0(r2)
8111943c:	1000381e 	bne	r2,zero,81119520 <bSendUART128v2+0x1ec>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81119440:	e0bffb03 	ldbu	r2,-20(fp)
81119444:	10c02324 	muli	r3,r2,140
81119448:	00a045b4 	movhi	r2,33046
8111944c:	10801e04 	addi	r2,r2,120
81119450:	1885883a 	add	r2,r3,r2
81119454:	01802004 	movi	r6,128
81119458:	000b883a 	mov	r5,zero
8111945c:	1009883a 	mov	r4,r2
81119460:	1123b2c0 	call	81123b2c <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81119464:	e0bffb03 	ldbu	r2,-20(fp)
81119468:	10c02324 	muli	r3,r2,140
8111946c:	00a045b4 	movhi	r2,33046
81119470:	10801e04 	addi	r2,r2,120
81119474:	1885883a 	add	r2,r3,r2
81119478:	01801fc4 	movi	r6,127
8111947c:	e17ffe17 	ldw	r5,-8(fp)
81119480:	1009883a 	mov	r4,r2
81119484:	11239dc0 	call	811239dc <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81119488:	e13ffb03 	ldbu	r4,-20(fp)
8111948c:	e0ffff0b 	ldhu	r3,-4(fp)
81119490:	00a045b4 	movhi	r2,33046
81119494:	10801e04 	addi	r2,r2,120
81119498:	21002324 	muli	r4,r4,140
8111949c:	1105883a 	add	r2,r2,r4
811194a0:	10802104 	addi	r2,r2,132
811194a4:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
811194a8:	e0fffb03 	ldbu	r3,-20(fp)
811194ac:	00a045b4 	movhi	r2,33046
811194b0:	10801e04 	addi	r2,r2,120
811194b4:	18c02324 	muli	r3,r3,140
811194b8:	10c5883a 	add	r2,r2,r3
811194bc:	10802204 	addi	r2,r2,136
811194c0:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
811194c4:	e0fffb03 	ldbu	r3,-20(fp)
811194c8:	00a045b4 	movhi	r2,33046
811194cc:	10801e04 	addi	r2,r2,120
811194d0:	18c02324 	muli	r3,r3,140
811194d4:	10c5883a 	add	r2,r2,r3
811194d8:	10802184 	addi	r2,r2,134
811194dc:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
811194e0:	e0fffb03 	ldbu	r3,-20(fp)
811194e4:	00a045b4 	movhi	r2,33046
811194e8:	10801e04 	addi	r2,r2,120
811194ec:	18c02324 	muli	r3,r3,140
811194f0:	10c5883a 	add	r2,r2,r3
811194f4:	10802004 	addi	r2,r2,128
811194f8:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
811194fc:	e0fffb03 	ldbu	r3,-20(fp)
81119500:	00a045b4 	movhi	r2,33046
81119504:	10800004 	addi	r2,r2,0
81119508:	18c7883a 	add	r3,r3,r3
8111950c:	18c7883a 	add	r3,r3,r3
81119510:	10c5883a 	add	r2,r2,r3
81119514:	00c00044 	movi	r3,1
81119518:	10c00015 	stw	r3,0(r2)
			break;
8111951c:	00000606 	br	81119538 <bSendUART128v2+0x204>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81119520:	e0bffb03 	ldbu	r2,-20(fp)
81119524:	10800044 	addi	r2,r2,1
81119528:	e0bffb05 	stb	r2,-20(fp)
8111952c:	e0bffb03 	ldbu	r2,-20(fp)
81119530:	108001b0 	cmpltui	r2,r2,6
81119534:	103fba1e 	bne	r2,zero,81119420 <__reset+0xfb0f9420>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
81119538:	e0bffb03 	ldbu	r2,-20(fp)
8111953c:	108001b0 	cmpltui	r2,r2,6
81119540:	1000091e 	bne	r2,zero,81119568 <bSendUART128v2+0x234>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81119544:	d0a06317 	ldw	r2,-32372(gp)
81119548:	1009883a 	mov	r4,r2
8111954c:	11401540 	call	81140154 <OSSemPost>
81119550:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
81119554:	d0a06e17 	ldw	r2,-32328(gp)
81119558:	1009883a 	mov	r4,r2
8111955c:	113e3640 	call	8113e364 <OSMutexPost>
		return bSuccessL;
81119560:	e0bffc17 	ldw	r2,-16(fp)
81119564:	00003606 	br	81119640 <bSendUART128v2+0x30c>
	}

	bSuccessL = TRUE;
81119568:	00800044 	movi	r2,1
8111956c:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
81119570:	d0a07543 	ldbu	r2,-32299(gp)
81119574:	10bfffc4 	addi	r2,r2,-1
81119578:	d0a07545 	stb	r2,-32299(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8111957c:	d0a07417 	ldw	r2,-32304(gp)
81119580:	e0fffd04 	addi	r3,fp,-12
81119584:	180d883a 	mov	r6,r3
81119588:	01400084 	movi	r5,2
8111958c:	1009883a 	mov	r4,r2
81119590:	113ddc00 	call	8113ddc0 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81119594:	e0bffd03 	ldbu	r2,-12(fp)
81119598:	10803fcc 	andi	r2,r2,255
8111959c:	10001226 	beq	r2,zero,811195e8 <bSendUART128v2+0x2b4>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811195a0:	00a045b4 	movhi	r2,33046
811195a4:	109fe204 	addi	r2,r2,32648
811195a8:	10800d8b 	ldhu	r2,54(r2)
811195ac:	10bfffcc 	andi	r2,r2,65535
811195b0:	10800228 	cmpgeui	r2,r2,8
811195b4:	1000071e 	bne	r2,zero,811195d4 <bSendUART128v2+0x2a0>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
811195b8:	d0a06217 	ldw	r2,-32376(gp)
811195bc:	100f883a 	mov	r7,r2
811195c0:	01801c04 	movi	r6,112
811195c4:	01400044 	movi	r5,1
811195c8:	01204574 	movhi	r4,33045
811195cc:	213eea04 	addi	r4,r4,-1112
811195d0:	1122fc80 	call	81122fc8 <fwrite>
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
811195d4:	d0a06e17 	ldw	r2,-32328(gp)
811195d8:	1009883a 	mov	r4,r2
811195dc:	113e3640 	call	8113e364 <OSMutexPost>
		return bSuccessL;
811195e0:	e0bffc17 	ldw	r2,-16(fp)
811195e4:	00001606 	br	81119640 <bSendUART128v2+0x30c>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
811195e8:	e0bffb03 	ldbu	r2,-20(fp)
811195ec:	10c02324 	muli	r3,r2,140
811195f0:	00a045b4 	movhi	r2,33046
811195f4:	10801e04 	addi	r2,r2,120
811195f8:	1885883a 	add	r2,r3,r2
811195fc:	1009883a 	mov	r4,r2
81119600:	1123efc0 	call	81123efc <puts>
	xBuffer128[ucIL].bSent = TRUE;
81119604:	e0fffb03 	ldbu	r3,-20(fp)
81119608:	00a045b4 	movhi	r2,33046
8111960c:	10801e04 	addi	r2,r2,120
81119610:	18c02324 	muli	r3,r3,140
81119614:	10c5883a 	add	r2,r2,r3
81119618:	10802004 	addi	r2,r2,128
8111961c:	00c00044 	movi	r3,1
81119620:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81119624:	d0a07417 	ldw	r2,-32304(gp)
81119628:	1009883a 	mov	r4,r2
8111962c:	113e3640 	call	8113e364 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81119630:	d0a06e17 	ldw	r2,-32328(gp)
81119634:	1009883a 	mov	r4,r2
81119638:	113e3640 	call	8113e364 <OSMutexPost>

	return bSuccessL;
8111963c:	e0bffc17 	ldw	r2,-16(fp)
}
81119640:	e037883a 	mov	sp,fp
81119644:	dfc00117 	ldw	ra,4(sp)
81119648:	df000017 	ldw	fp,0(sp)
8111964c:	dec00204 	addi	sp,sp,8
81119650:	f800283a 	ret

81119654 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
81119654:	defff904 	addi	sp,sp,-28
81119658:	de00012e 	bgeu	sp,et,81119660 <bSendUART64v2+0xc>
8111965c:	003b68fa 	trap	3
81119660:	dfc00615 	stw	ra,24(sp)
81119664:	df000515 	stw	fp,20(sp)
81119668:	df000504 	addi	fp,sp,20
8111966c:	e13ffe15 	stw	r4,-8(fp)
81119670:	2805883a 	mov	r2,r5
81119674:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81119678:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
8111967c:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81119680:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81119684:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81119688:	d0a05e17 	ldw	r2,-32392(gp)
8111968c:	e0fffd04 	addi	r3,fp,-12
81119690:	180d883a 	mov	r6,r3
81119694:	01400504 	movi	r5,20
81119698:	1009883a 	mov	r4,r2
8111969c:	113fdcc0 	call	8113fdcc <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811196a0:	e0bffd03 	ldbu	r2,-12(fp)
811196a4:	10803fcc 	andi	r2,r2,255
811196a8:	10000326 	beq	r2,zero,811196b8 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
811196ac:	111cea00 	call	8111cea0 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
811196b0:	e0bffc17 	ldw	r2,-16(fp)
811196b4:	0000ac06 	br	81119968 <bSendUART64v2+0x314>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811196b8:	d0a07117 	ldw	r2,-32316(gp)
811196bc:	e0fffd04 	addi	r3,fp,-12
811196c0:	180d883a 	mov	r6,r3
811196c4:	01400104 	movi	r5,4
811196c8:	1009883a 	mov	r4,r2
811196cc:	113ddc00 	call	8113ddc0 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811196d0:	e0bffd03 	ldbu	r2,-12(fp)
811196d4:	10803fcc 	andi	r2,r2,255
811196d8:	10001726 	beq	r2,zero,81119738 <bSendUART64v2+0xe4>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811196dc:	00a045b4 	movhi	r2,33046
811196e0:	109fe204 	addi	r2,r2,32648
811196e4:	10800d8b 	ldhu	r2,54(r2)
811196e8:	10bfffcc 	andi	r2,r2,65535
811196ec:	10800228 	cmpgeui	r2,r2,8
811196f0:	1000071e 	bne	r2,zero,81119710 <bSendUART64v2+0xbc>
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
811196f4:	d0a06217 	ldw	r2,-32376(gp)
811196f8:	100f883a 	mov	r7,r2
811196fc:	018013c4 	movi	r6,79
81119700:	01400044 	movi	r5,1
81119704:	01204574 	movhi	r4,33045
81119708:	213f0704 	addi	r4,r4,-996
8111970c:	1122fc80 	call	81122fc8 <fwrite>
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81119710:	d0a05e17 	ldw	r2,-32392(gp)
81119714:	1009883a 	mov	r4,r2
81119718:	11401540 	call	81140154 <OSSemPost>
8111971c:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81119720:	e0bffd03 	ldbu	r2,-12(fp)
81119724:	10803fcc 	andi	r2,r2,255
81119728:	10000126 	beq	r2,zero,81119730 <bSendUART64v2+0xdc>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8111972c:	111cd200 	call	8111cd20 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81119730:	e0bffc17 	ldw	r2,-16(fp)
81119734:	00008c06 	br	81119968 <bSendUART64v2+0x314>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81119738:	e03ffb05 	stb	zero,-20(fp)
8111973c:	00004506 	br	81119854 <bSendUART64v2+0x200>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81119740:	e0fffb03 	ldbu	r3,-20(fp)
81119744:	00a045b4 	movhi	r2,33046
81119748:	10800004 	addi	r2,r2,0
8111974c:	18c00184 	addi	r3,r3,6
81119750:	18c7883a 	add	r3,r3,r3
81119754:	18c7883a 	add	r3,r3,r3
81119758:	10c5883a 	add	r2,r2,r3
8111975c:	10800017 	ldw	r2,0(r2)
81119760:	1000391e 	bne	r2,zero,81119848 <bSendUART64v2+0x1f4>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81119764:	e0bffb03 	ldbu	r2,-20(fp)
81119768:	10c01324 	muli	r3,r2,76
8111976c:	00a04574 	movhi	r2,33045
81119770:	109bc404 	addi	r2,r2,28432
81119774:	1885883a 	add	r2,r3,r2
81119778:	01801004 	movi	r6,64
8111977c:	000b883a 	mov	r5,zero
81119780:	1009883a 	mov	r4,r2
81119784:	1123b2c0 	call	81123b2c <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
81119788:	e0bffb03 	ldbu	r2,-20(fp)
8111978c:	10c01324 	muli	r3,r2,76
81119790:	00a04574 	movhi	r2,33045
81119794:	109bc404 	addi	r2,r2,28432
81119798:	1885883a 	add	r2,r3,r2
8111979c:	01800fc4 	movi	r6,63
811197a0:	e17ffe17 	ldw	r5,-8(fp)
811197a4:	1009883a 	mov	r4,r2
811197a8:	11239dc0 	call	811239dc <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
811197ac:	e13ffb03 	ldbu	r4,-20(fp)
811197b0:	e0ffff0b 	ldhu	r3,-4(fp)
811197b4:	00a04574 	movhi	r2,33045
811197b8:	109bc404 	addi	r2,r2,28432
811197bc:	21001324 	muli	r4,r4,76
811197c0:	1105883a 	add	r2,r2,r4
811197c4:	10801104 	addi	r2,r2,68
811197c8:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
811197cc:	e0fffb03 	ldbu	r3,-20(fp)
811197d0:	00a04574 	movhi	r2,33045
811197d4:	109bc404 	addi	r2,r2,28432
811197d8:	18c01324 	muli	r3,r3,76
811197dc:	10c5883a 	add	r2,r2,r3
811197e0:	10801204 	addi	r2,r2,72
811197e4:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
811197e8:	e0fffb03 	ldbu	r3,-20(fp)
811197ec:	00a04574 	movhi	r2,33045
811197f0:	109bc404 	addi	r2,r2,28432
811197f4:	18c01324 	muli	r3,r3,76
811197f8:	10c5883a 	add	r2,r2,r3
811197fc:	10801184 	addi	r2,r2,70
81119800:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
81119804:	e0fffb03 	ldbu	r3,-20(fp)
81119808:	00a04574 	movhi	r2,33045
8111980c:	109bc404 	addi	r2,r2,28432
81119810:	18c01324 	muli	r3,r3,76
81119814:	10c5883a 	add	r2,r2,r3
81119818:	10801004 	addi	r2,r2,64
8111981c:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81119820:	e0fffb03 	ldbu	r3,-20(fp)
81119824:	00a045b4 	movhi	r2,33046
81119828:	10800004 	addi	r2,r2,0
8111982c:	18c00184 	addi	r3,r3,6
81119830:	18c7883a 	add	r3,r3,r3
81119834:	18c7883a 	add	r3,r3,r3
81119838:	10c5883a 	add	r2,r2,r3
8111983c:	00c00044 	movi	r3,1
81119840:	10c00015 	stw	r3,0(r2)
			break;
81119844:	00000606 	br	81119860 <bSendUART64v2+0x20c>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81119848:	e0bffb03 	ldbu	r2,-20(fp)
8111984c:	10800044 	addi	r2,r2,1
81119850:	e0bffb05 	stb	r2,-20(fp)
81119854:	e0bffb03 	ldbu	r2,-20(fp)
81119858:	10800230 	cmpltui	r2,r2,8
8111985c:	103fb81e 	bne	r2,zero,81119740 <__reset+0xfb0f9740>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81119860:	e0bffb03 	ldbu	r2,-20(fp)
81119864:	10800230 	cmpltui	r2,r2,8
81119868:	1000091e 	bne	r2,zero,81119890 <bSendUART64v2+0x23c>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
8111986c:	d0a05e17 	ldw	r2,-32392(gp)
81119870:	1009883a 	mov	r4,r2
81119874:	11401540 	call	81140154 <OSSemPost>
81119878:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
8111987c:	d0a07117 	ldw	r2,-32316(gp)
81119880:	1009883a 	mov	r4,r2
81119884:	113e3640 	call	8113e364 <OSMutexPost>
		return bSuccessL;
81119888:	e0bffc17 	ldw	r2,-16(fp)
8111988c:	00003606 	br	81119968 <bSendUART64v2+0x314>
	}

	bSuccessL = TRUE;
81119890:	00800044 	movi	r2,1
81119894:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
81119898:	d0a07503 	ldbu	r2,-32300(gp)
8111989c:	10bfffc4 	addi	r2,r2,-1
811198a0:	d0a07505 	stb	r2,-32300(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811198a4:	d0a07417 	ldw	r2,-32304(gp)
811198a8:	e0fffd04 	addi	r3,fp,-12
811198ac:	180d883a 	mov	r6,r3
811198b0:	01400084 	movi	r5,2
811198b4:	1009883a 	mov	r4,r2
811198b8:	113ddc00 	call	8113ddc0 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811198bc:	e0bffd03 	ldbu	r2,-12(fp)
811198c0:	10803fcc 	andi	r2,r2,255
811198c4:	10001226 	beq	r2,zero,81119910 <bSendUART64v2+0x2bc>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811198c8:	00a045b4 	movhi	r2,33046
811198cc:	109fe204 	addi	r2,r2,32648
811198d0:	10800d8b 	ldhu	r2,54(r2)
811198d4:	10bfffcc 	andi	r2,r2,65535
811198d8:	10800228 	cmpgeui	r2,r2,8
811198dc:	1000071e 	bne	r2,zero,811198fc <bSendUART64v2+0x2a8>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
811198e0:	d0a06217 	ldw	r2,-32376(gp)
811198e4:	100f883a 	mov	r7,r2
811198e8:	01801bc4 	movi	r6,111
811198ec:	01400044 	movi	r5,1
811198f0:	01204574 	movhi	r4,33045
811198f4:	213f1b04 	addi	r4,r4,-916
811198f8:	1122fc80 	call	81122fc8 <fwrite>
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
811198fc:	d0a07117 	ldw	r2,-32316(gp)
81119900:	1009883a 	mov	r4,r2
81119904:	113e3640 	call	8113e364 <OSMutexPost>
		return bSuccessL;
81119908:	e0bffc17 	ldw	r2,-16(fp)
8111990c:	00001606 	br	81119968 <bSendUART64v2+0x314>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
81119910:	e0bffb03 	ldbu	r2,-20(fp)
81119914:	10c01324 	muli	r3,r2,76
81119918:	00a04574 	movhi	r2,33045
8111991c:	109bc404 	addi	r2,r2,28432
81119920:	1885883a 	add	r2,r3,r2
81119924:	1009883a 	mov	r4,r2
81119928:	1123efc0 	call	81123efc <puts>
	xBuffer64[ucIL].bSent = TRUE;
8111992c:	e0fffb03 	ldbu	r3,-20(fp)
81119930:	00a04574 	movhi	r2,33045
81119934:	109bc404 	addi	r2,r2,28432
81119938:	18c01324 	muli	r3,r3,76
8111993c:	10c5883a 	add	r2,r2,r3
81119940:	10801004 	addi	r2,r2,64
81119944:	00c00044 	movi	r3,1
81119948:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
8111994c:	d0a07417 	ldw	r2,-32304(gp)
81119950:	1009883a 	mov	r4,r2
81119954:	113e3640 	call	8113e364 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
81119958:	d0a07117 	ldw	r2,-32316(gp)
8111995c:	1009883a 	mov	r4,r2
81119960:	113e3640 	call	8113e364 <OSMutexPost>

	return bSuccessL;
81119964:	e0bffc17 	ldw	r2,-16(fp)
}
81119968:	e037883a 	mov	sp,fp
8111996c:	dfc00117 	ldw	ra,4(sp)
81119970:	df000017 	ldw	fp,0(sp)
81119974:	dec00204 	addi	sp,sp,8
81119978:	f800283a 	ret

8111997c <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
8111997c:	defff904 	addi	sp,sp,-28
81119980:	de00012e 	bgeu	sp,et,81119988 <bSendUART32v2+0xc>
81119984:	003b68fa 	trap	3
81119988:	dfc00615 	stw	ra,24(sp)
8111998c:	df000515 	stw	fp,20(sp)
81119990:	df000504 	addi	fp,sp,20
81119994:	e13ffe15 	stw	r4,-8(fp)
81119998:	2805883a 	mov	r2,r5
8111999c:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
811199a0:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811199a4:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811199a8:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811199ac:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811199b0:	d0a06f17 	ldw	r2,-32324(gp)
811199b4:	e0fffd04 	addi	r3,fp,-12
811199b8:	180d883a 	mov	r6,r3
811199bc:	01400504 	movi	r5,20
811199c0:	1009883a 	mov	r4,r2
811199c4:	113fdcc0 	call	8113fdcc <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811199c8:	e0bffd03 	ldbu	r2,-12(fp)
811199cc:	10803fcc 	andi	r2,r2,255
811199d0:	10000326 	beq	r2,zero,811199e0 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
811199d4:	111cf200 	call	8111cf20 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
811199d8:	e0bffc17 	ldw	r2,-16(fp)
811199dc:	0000ac06 	br	81119c90 <bSendUART32v2+0x314>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811199e0:	d0a06c17 	ldw	r2,-32336(gp)
811199e4:	e0fffd04 	addi	r3,fp,-12
811199e8:	180d883a 	mov	r6,r3
811199ec:	01400104 	movi	r5,4
811199f0:	1009883a 	mov	r4,r2
811199f4:	113ddc00 	call	8113ddc0 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811199f8:	e0bffd03 	ldbu	r2,-12(fp)
811199fc:	10803fcc 	andi	r2,r2,255
81119a00:	10001726 	beq	r2,zero,81119a60 <bSendUART32v2+0xe4>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81119a04:	00a045b4 	movhi	r2,33046
81119a08:	109fe204 	addi	r2,r2,32648
81119a0c:	10800d8b 	ldhu	r2,54(r2)
81119a10:	10bfffcc 	andi	r2,r2,65535
81119a14:	10800228 	cmpgeui	r2,r2,8
81119a18:	1000071e 	bne	r2,zero,81119a38 <bSendUART32v2+0xbc>
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
81119a1c:	d0a06217 	ldw	r2,-32376(gp)
81119a20:	100f883a 	mov	r7,r2
81119a24:	018013c4 	movi	r6,79
81119a28:	01400044 	movi	r5,1
81119a2c:	01204574 	movhi	r4,33045
81119a30:	213f3704 	addi	r4,r4,-804
81119a34:	1122fc80 	call	81122fc8 <fwrite>
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81119a38:	d0a06f17 	ldw	r2,-32324(gp)
81119a3c:	1009883a 	mov	r4,r2
81119a40:	11401540 	call	81140154 <OSSemPost>
81119a44:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81119a48:	e0bffd03 	ldbu	r2,-12(fp)
81119a4c:	10803fcc 	andi	r2,r2,255
81119a50:	10000126 	beq	r2,zero,81119a58 <bSendUART32v2+0xdc>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81119a54:	111cca00 	call	8111cca0 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
81119a58:	e0bffc17 	ldw	r2,-16(fp)
81119a5c:	00008c06 	br	81119c90 <bSendUART32v2+0x314>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81119a60:	e03ffb05 	stb	zero,-20(fp)
81119a64:	00004506 	br	81119b7c <bSendUART32v2+0x200>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
81119a68:	e0fffb03 	ldbu	r3,-20(fp)
81119a6c:	00a045b4 	movhi	r2,33046
81119a70:	10800004 	addi	r2,r2,0
81119a74:	18c00384 	addi	r3,r3,14
81119a78:	18c7883a 	add	r3,r3,r3
81119a7c:	18c7883a 	add	r3,r3,r3
81119a80:	10c5883a 	add	r2,r2,r3
81119a84:	10800017 	ldw	r2,0(r2)
81119a88:	1000391e 	bne	r2,zero,81119b70 <bSendUART32v2+0x1f4>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
81119a8c:	e0bffb03 	ldbu	r2,-20(fp)
81119a90:	10c00b24 	muli	r3,r2,44
81119a94:	00a045b4 	movhi	r2,33046
81119a98:	10ad8004 	addi	r2,r2,-18944
81119a9c:	1885883a 	add	r2,r3,r2
81119aa0:	01800804 	movi	r6,32
81119aa4:	000b883a 	mov	r5,zero
81119aa8:	1009883a 	mov	r4,r2
81119aac:	1123b2c0 	call	81123b2c <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
81119ab0:	e0bffb03 	ldbu	r2,-20(fp)
81119ab4:	10c00b24 	muli	r3,r2,44
81119ab8:	00a045b4 	movhi	r2,33046
81119abc:	10ad8004 	addi	r2,r2,-18944
81119ac0:	1885883a 	add	r2,r3,r2
81119ac4:	018007c4 	movi	r6,31
81119ac8:	e17ffe17 	ldw	r5,-8(fp)
81119acc:	1009883a 	mov	r4,r2
81119ad0:	11239dc0 	call	811239dc <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
81119ad4:	e13ffb03 	ldbu	r4,-20(fp)
81119ad8:	e0ffff0b 	ldhu	r3,-4(fp)
81119adc:	00a045b4 	movhi	r2,33046
81119ae0:	10ad8004 	addi	r2,r2,-18944
81119ae4:	21000b24 	muli	r4,r4,44
81119ae8:	1105883a 	add	r2,r2,r4
81119aec:	10800904 	addi	r2,r2,36
81119af0:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
81119af4:	e0fffb03 	ldbu	r3,-20(fp)
81119af8:	00a045b4 	movhi	r2,33046
81119afc:	10ad8004 	addi	r2,r2,-18944
81119b00:	18c00b24 	muli	r3,r3,44
81119b04:	10c5883a 	add	r2,r2,r3
81119b08:	10800a04 	addi	r2,r2,40
81119b0c:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
81119b10:	e0fffb03 	ldbu	r3,-20(fp)
81119b14:	00a045b4 	movhi	r2,33046
81119b18:	10ad8004 	addi	r2,r2,-18944
81119b1c:	18c00b24 	muli	r3,r3,44
81119b20:	10c5883a 	add	r2,r2,r3
81119b24:	10800984 	addi	r2,r2,38
81119b28:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81119b2c:	e0fffb03 	ldbu	r3,-20(fp)
81119b30:	00a045b4 	movhi	r2,33046
81119b34:	10ad8004 	addi	r2,r2,-18944
81119b38:	18c00b24 	muli	r3,r3,44
81119b3c:	10c5883a 	add	r2,r2,r3
81119b40:	10800804 	addi	r2,r2,32
81119b44:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
81119b48:	e0fffb03 	ldbu	r3,-20(fp)
81119b4c:	00a045b4 	movhi	r2,33046
81119b50:	10800004 	addi	r2,r2,0
81119b54:	18c00384 	addi	r3,r3,14
81119b58:	18c7883a 	add	r3,r3,r3
81119b5c:	18c7883a 	add	r3,r3,r3
81119b60:	10c5883a 	add	r2,r2,r3
81119b64:	00c00044 	movi	r3,1
81119b68:	10c00015 	stw	r3,0(r2)
			break;
81119b6c:	00000606 	br	81119b88 <bSendUART32v2+0x20c>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81119b70:	e0bffb03 	ldbu	r2,-20(fp)
81119b74:	10800044 	addi	r2,r2,1
81119b78:	e0bffb05 	stb	r2,-20(fp)
81119b7c:	e0bffb03 	ldbu	r2,-20(fp)
81119b80:	10800230 	cmpltui	r2,r2,8
81119b84:	103fb81e 	bne	r2,zero,81119a68 <__reset+0xfb0f9a68>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
81119b88:	e0bffb03 	ldbu	r2,-20(fp)
81119b8c:	10800230 	cmpltui	r2,r2,8
81119b90:	1000091e 	bne	r2,zero,81119bb8 <bSendUART32v2+0x23c>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81119b94:	d0a06f17 	ldw	r2,-32324(gp)
81119b98:	1009883a 	mov	r4,r2
81119b9c:	11401540 	call	81140154 <OSSemPost>
81119ba0:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81119ba4:	d0a06c17 	ldw	r2,-32336(gp)
81119ba8:	1009883a 	mov	r4,r2
81119bac:	113e3640 	call	8113e364 <OSMutexPost>
		return bSuccessL;
81119bb0:	e0bffc17 	ldw	r2,-16(fp)
81119bb4:	00003606 	br	81119c90 <bSendUART32v2+0x314>
	}
	
	bSuccessL = TRUE;
81119bb8:	00800044 	movi	r2,1
81119bbc:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
81119bc0:	d0a06883 	ldbu	r2,-32350(gp)
81119bc4:	10bfffc4 	addi	r2,r2,-1
81119bc8:	d0a06885 	stb	r2,-32350(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81119bcc:	d0a07417 	ldw	r2,-32304(gp)
81119bd0:	e0fffd04 	addi	r3,fp,-12
81119bd4:	180d883a 	mov	r6,r3
81119bd8:	01400084 	movi	r5,2
81119bdc:	1009883a 	mov	r4,r2
81119be0:	113ddc00 	call	8113ddc0 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81119be4:	e0bffd03 	ldbu	r2,-12(fp)
81119be8:	10803fcc 	andi	r2,r2,255
81119bec:	10001226 	beq	r2,zero,81119c38 <bSendUART32v2+0x2bc>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
81119bf0:	00a045b4 	movhi	r2,33046
81119bf4:	109fe204 	addi	r2,r2,32648
81119bf8:	10800d8b 	ldhu	r2,54(r2)
81119bfc:	10bfffcc 	andi	r2,r2,65535
81119c00:	10800228 	cmpgeui	r2,r2,8
81119c04:	1000071e 	bne	r2,zero,81119c24 <bSendUART32v2+0x2a8>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
81119c08:	d0a06217 	ldw	r2,-32376(gp)
81119c0c:	100f883a 	mov	r7,r2
81119c10:	01801bc4 	movi	r6,111
81119c14:	01400044 	movi	r5,1
81119c18:	01204574 	movhi	r4,33045
81119c1c:	213f4b04 	addi	r4,r4,-724
81119c20:	1122fc80 	call	81122fc8 <fwrite>
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
81119c24:	d0a06c17 	ldw	r2,-32336(gp)
81119c28:	1009883a 	mov	r4,r2
81119c2c:	113e3640 	call	8113e364 <OSMutexPost>
		return bSuccessL;
81119c30:	e0bffc17 	ldw	r2,-16(fp)
81119c34:	00001606 	br	81119c90 <bSendUART32v2+0x314>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
81119c38:	e0bffb03 	ldbu	r2,-20(fp)
81119c3c:	10c00b24 	muli	r3,r2,44
81119c40:	00a045b4 	movhi	r2,33046
81119c44:	10ad8004 	addi	r2,r2,-18944
81119c48:	1885883a 	add	r2,r3,r2
81119c4c:	1009883a 	mov	r4,r2
81119c50:	1123efc0 	call	81123efc <puts>
	xBuffer32[ucIL].bSent = TRUE;
81119c54:	e0fffb03 	ldbu	r3,-20(fp)
81119c58:	00a045b4 	movhi	r2,33046
81119c5c:	10ad8004 	addi	r2,r2,-18944
81119c60:	18c00b24 	muli	r3,r3,44
81119c64:	10c5883a 	add	r2,r2,r3
81119c68:	10800804 	addi	r2,r2,32
81119c6c:	00c00044 	movi	r3,1
81119c70:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
81119c74:	d0a07417 	ldw	r2,-32304(gp)
81119c78:	1009883a 	mov	r4,r2
81119c7c:	113e3640 	call	8113e364 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
81119c80:	d0a06c17 	ldw	r2,-32336(gp)
81119c84:	1009883a 	mov	r4,r2
81119c88:	113e3640 	call	8113e364 <OSMutexPost>

	return bSuccessL;
81119c8c:	e0bffc17 	ldw	r2,-16(fp)
}
81119c90:	e037883a 	mov	sp,fp
81119c94:	dfc00117 	ldw	ra,4(sp)
81119c98:	df000017 	ldw	fp,0(sp)
81119c9c:	dec00204 	addi	sp,sp,8
81119ca0:	f800283a 	ret

81119ca4 <vSendEthConf>:


void vSendEthConf ( void ) {
81119ca4:	deffc304 	addi	sp,sp,-244
81119ca8:	de00012e 	bgeu	sp,et,81119cb0 <vSendEthConf+0xc>
81119cac:	003b68fa 	trap	3
81119cb0:	dfc03c15 	stw	ra,240(sp)
81119cb4:	df003b15 	stw	fp,236(sp)
81119cb8:	dd403a15 	stw	r21,232(sp)
81119cbc:	dd003915 	stw	r20,228(sp)
81119cc0:	dcc03815 	stw	r19,224(sp)
81119cc4:	dc803715 	stw	r18,220(sp)
81119cc8:	dc403615 	stw	r17,216(sp)
81119ccc:	dc003515 	stw	r16,212(sp)
81119cd0:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
81119cd4:	e03fd98d 	sth	zero,-154(fp)
81119cd8:	e03fda0d 	sth	zero,-152(fp)
81119cdc:	e0bfda84 	addi	r2,fp,-150
81119ce0:	00c01f04 	movi	r3,124
81119ce4:	180d883a 	mov	r6,r3
81119ce8:	000b883a 	mov	r5,zero
81119cec:	1009883a 	mov	r4,r2
81119cf0:	1123b2c0 	call	81123b2c <memset>
    unsigned char crc = 0;
81119cf4:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81119cf8:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119cfc:	111a2640 	call	8111a264 <usiGetIdCMD>
81119d00:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d04:	e57fd90b 	ldhu	r21,-156(fp)
81119d08:	00a045b4 	movhi	r2,33046
81119d0c:	109ff104 	addi	r2,r2,32708
81119d10:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81119d14:	00a045b4 	movhi	r2,33046
81119d18:	109ff104 	addi	r2,r2,32708
81119d1c:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d20:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81119d24:	00a045b4 	movhi	r2,33046
81119d28:	109ff104 	addi	r2,r2,32708
81119d2c:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d30:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81119d34:	00a045b4 	movhi	r2,33046
81119d38:	109ff104 	addi	r2,r2,32708
81119d3c:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d40:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81119d44:	00a045b4 	movhi	r2,33046
81119d48:	109ff104 	addi	r2,r2,32708
81119d4c:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d50:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81119d54:	00a045b4 	movhi	r2,33046
81119d58:	109ff104 	addi	r2,r2,32708
81119d5c:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d60:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81119d64:	00a045b4 	movhi	r2,33046
81119d68:	109ff104 	addi	r2,r2,32708
81119d6c:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d70:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81119d74:	00a045b4 	movhi	r2,33046
81119d78:	109ff104 	addi	r2,r2,32708
81119d7c:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d80:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81119d84:	00a045b4 	movhi	r2,33046
81119d88:	109ff104 	addi	r2,r2,32708
81119d8c:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119d90:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81119d94:	00a045b4 	movhi	r2,33046
81119d98:	109ff104 	addi	r2,r2,32708
81119d9c:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119da0:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81119da4:	00a045b4 	movhi	r2,33046
81119da8:	109ff104 	addi	r2,r2,32708
81119dac:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119db0:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81119db4:	00a045b4 	movhi	r2,33046
81119db8:	109ff104 	addi	r2,r2,32708
81119dbc:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119dc0:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81119dc4:	00a045b4 	movhi	r2,33046
81119dc8:	109ff104 	addi	r2,r2,32708
81119dcc:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119dd0:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81119dd4:	00a045b4 	movhi	r2,33046
81119dd8:	109ff104 	addi	r2,r2,32708
81119ddc:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119de0:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81119de4:	00a045b4 	movhi	r2,33046
81119de8:	109ff104 	addi	r2,r2,32708
81119dec:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119df0:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81119df4:	00a045b4 	movhi	r2,33046
81119df8:	109ff104 	addi	r2,r2,32708
81119dfc:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119e00:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81119e04:	00a045b4 	movhi	r2,33046
81119e08:	109ff104 	addi	r2,r2,32708
81119e0c:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119e10:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
81119e14:	00a045b4 	movhi	r2,33046
81119e18:	109ff104 	addi	r2,r2,32708
81119e1c:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81119e20:	10bfffcc 	andi	r2,r2,65535
81119e24:	e53fd984 	addi	r20,fp,-154
81119e28:	d8801115 	stw	r2,68(sp)
81119e2c:	dcc01015 	stw	r19,64(sp)
81119e30:	dc800f15 	stw	r18,60(sp)
81119e34:	dc400e15 	stw	r17,56(sp)
81119e38:	dc000d15 	stw	r16,52(sp)
81119e3c:	dbc00c15 	stw	r15,48(sp)
81119e40:	db800b15 	stw	r14,44(sp)
81119e44:	db400a15 	stw	r13,40(sp)
81119e48:	db000915 	stw	r12,36(sp)
81119e4c:	dac00815 	stw	r11,32(sp)
81119e50:	da800715 	stw	r10,28(sp)
81119e54:	da400615 	stw	r9,24(sp)
81119e58:	da000515 	stw	r8,20(sp)
81119e5c:	d9c00415 	stw	r7,16(sp)
81119e60:	d9800315 	stw	r6,12(sp)
81119e64:	d9400215 	stw	r5,8(sp)
81119e68:	d9000115 	stw	r4,4(sp)
81119e6c:	d8c00015 	stw	r3,0(sp)
81119e70:	a80f883a 	mov	r7,r21
81119e74:	018010c4 	movi	r6,67
81119e78:	01604574 	movhi	r5,33045
81119e7c:	297f6704 	addi	r5,r5,-612
81119e80:	a009883a 	mov	r4,r20
81119e84:	11242400 	call	81124240 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
81119e88:	e0bfd984 	addi	r2,fp,-154
81119e8c:	1009883a 	mov	r4,r2
81119e90:	11244540 	call	81124454 <strlen>
81119e94:	1007883a 	mov	r3,r2
81119e98:	e0bfd984 	addi	r2,fp,-154
81119e9c:	180b883a 	mov	r5,r3
81119ea0:	1009883a 	mov	r4,r2
81119ea4:	111c3300 	call	8111c330 <ucCrc8wInit>
81119ea8:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81119eac:	e13fd703 	ldbu	r4,-164(fp)
81119eb0:	e0ffd984 	addi	r3,fp,-154
81119eb4:	e0bfd984 	addi	r2,fp,-154
81119eb8:	200f883a 	mov	r7,r4
81119ebc:	180d883a 	mov	r6,r3
81119ec0:	01604574 	movhi	r5,33045
81119ec4:	297f7f04 	addi	r5,r5,-516
81119ec8:	1009883a 	mov	r4,r2
81119ecc:	11242400 	call	81124240 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
81119ed0:	e0bfd90b 	ldhu	r2,-156(fp)
81119ed4:	10ffffcc 	andi	r3,r2,65535
81119ed8:	18e0001c 	xori	r3,r3,32768
81119edc:	18e00004 	addi	r3,r3,-32768
81119ee0:	e0bfd984 	addi	r2,fp,-154
81119ee4:	180b883a 	mov	r5,r3
81119ee8:	1009883a 	mov	r4,r2
81119eec:	11193340 	call	81119334 <bSendUART128v2>
81119ef0:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
81119ef4:	e0bfd817 	ldw	r2,-160(fp)
81119ef8:	10800060 	cmpeqi	r2,r2,1
81119efc:	1000011e 	bne	r2,zero,81119f04 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
81119f00:	111d1a00 	call	8111d1a0 <vCouldNotSendEthConfUART>
	}
}
81119f04:	0001883a 	nop
81119f08:	e6fffa04 	addi	sp,fp,-24
81119f0c:	dfc00717 	ldw	ra,28(sp)
81119f10:	df000617 	ldw	fp,24(sp)
81119f14:	dd400517 	ldw	r21,20(sp)
81119f18:	dd000417 	ldw	r20,16(sp)
81119f1c:	dcc00317 	ldw	r19,12(sp)
81119f20:	dc800217 	ldw	r18,8(sp)
81119f24:	dc400117 	ldw	r17,4(sp)
81119f28:	dc000017 	ldw	r16,0(sp)
81119f2c:	dec00804 	addi	sp,sp,32
81119f30:	f800283a 	ret

81119f34 <vSendTurnOff>:


void vSendTurnOff ( void ) {
81119f34:	defff304 	addi	sp,sp,-52
81119f38:	de00012e 	bgeu	sp,et,81119f40 <vSendTurnOff+0xc>
81119f3c:	003b68fa 	trap	3
81119f40:	dfc00c15 	stw	ra,48(sp)
81119f44:	df000b15 	stw	fp,44(sp)
81119f48:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81119f4c:	e03ff78d 	sth	zero,-34(fp)
81119f50:	e03ff80d 	sth	zero,-32(fp)
81119f54:	e03ff88d 	sth	zero,-30(fp)
81119f58:	e03ff90d 	sth	zero,-28(fp)
81119f5c:	e03ff98d 	sth	zero,-26(fp)
81119f60:	e03ffa0d 	sth	zero,-24(fp)
81119f64:	e03ffa8d 	sth	zero,-22(fp)
81119f68:	e03ffb0d 	sth	zero,-20(fp)
81119f6c:	e03ffb8d 	sth	zero,-18(fp)
81119f70:	e03ffc0d 	sth	zero,-16(fp)
81119f74:	e03ffc8d 	sth	zero,-14(fp)
81119f78:	e03ffd0d 	sth	zero,-12(fp)
81119f7c:	e03ffd8d 	sth	zero,-10(fp)
81119f80:	e03ffe0d 	sth	zero,-8(fp)
81119f84:	e03ffe8d 	sth	zero,-6(fp)
81119f88:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81119f8c:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81119f90:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119f94:	111a2640 	call	8111a264 <usiGetIdCMD>
81119f98:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81119f9c:	e0fff70b 	ldhu	r3,-36(fp)
81119fa0:	e0bff784 	addi	r2,fp,-34
81119fa4:	180d883a 	mov	r6,r3
81119fa8:	01604574 	movhi	r5,33045
81119fac:	297f8204 	addi	r5,r5,-504
81119fb0:	1009883a 	mov	r4,r2
81119fb4:	11242400 	call	81124240 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81119fb8:	e0bff784 	addi	r2,fp,-34
81119fbc:	1009883a 	mov	r4,r2
81119fc0:	11244540 	call	81124454 <strlen>
81119fc4:	1007883a 	mov	r3,r2
81119fc8:	e0bff784 	addi	r2,fp,-34
81119fcc:	180b883a 	mov	r5,r3
81119fd0:	1009883a 	mov	r4,r2
81119fd4:	111c3300 	call	8111c330 <ucCrc8wInit>
81119fd8:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81119fdc:	e13ff503 	ldbu	r4,-44(fp)
81119fe0:	e0fff784 	addi	r3,fp,-34
81119fe4:	e0bff784 	addi	r2,fp,-34
81119fe8:	200f883a 	mov	r7,r4
81119fec:	180d883a 	mov	r6,r3
81119ff0:	01604574 	movhi	r5,33045
81119ff4:	297f7f04 	addi	r5,r5,-516
81119ff8:	1009883a 	mov	r4,r2
81119ffc:	11242400 	call	81124240 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8111a000:	e0bff70b 	ldhu	r2,-36(fp)
8111a004:	10ffffcc 	andi	r3,r2,65535
8111a008:	18e0001c 	xori	r3,r3,32768
8111a00c:	18e00004 	addi	r3,r3,-32768
8111a010:	e0bff784 	addi	r2,fp,-34
8111a014:	180b883a 	mov	r5,r3
8111a018:	1009883a 	mov	r4,r2
8111a01c:	111997c0 	call	8111997c <bSendUART32v2>
8111a020:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8111a024:	e0bff617 	ldw	r2,-40(fp)
8111a028:	10800060 	cmpeqi	r2,r2,1
8111a02c:	1000011e 	bne	r2,zero,8111a034 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111a030:	111d9f80 	call	8111d9f8 <vCouldNotSendTurnOff>
	}
}
8111a034:	0001883a 	nop
8111a038:	e037883a 	mov	sp,fp
8111a03c:	dfc00117 	ldw	ra,4(sp)
8111a040:	df000017 	ldw	fp,0(sp)
8111a044:	dec00204 	addi	sp,sp,8
8111a048:	f800283a 	ret

8111a04c <vSendReset>:

void vSendReset ( void ) {
8111a04c:	defff304 	addi	sp,sp,-52
8111a050:	de00012e 	bgeu	sp,et,8111a058 <vSendReset+0xc>
8111a054:	003b68fa 	trap	3
8111a058:	dfc00c15 	stw	ra,48(sp)
8111a05c:	df000b15 	stw	fp,44(sp)
8111a060:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
8111a064:	e03ff78d 	sth	zero,-34(fp)
8111a068:	e03ff80d 	sth	zero,-32(fp)
8111a06c:	e03ff88d 	sth	zero,-30(fp)
8111a070:	e03ff90d 	sth	zero,-28(fp)
8111a074:	e03ff98d 	sth	zero,-26(fp)
8111a078:	e03ffa0d 	sth	zero,-24(fp)
8111a07c:	e03ffa8d 	sth	zero,-22(fp)
8111a080:	e03ffb0d 	sth	zero,-20(fp)
8111a084:	e03ffb8d 	sth	zero,-18(fp)
8111a088:	e03ffc0d 	sth	zero,-16(fp)
8111a08c:	e03ffc8d 	sth	zero,-14(fp)
8111a090:	e03ffd0d 	sth	zero,-12(fp)
8111a094:	e03ffd8d 	sth	zero,-10(fp)
8111a098:	e03ffe0d 	sth	zero,-8(fp)
8111a09c:	e03ffe8d 	sth	zero,-6(fp)
8111a0a0:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8111a0a4:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a0a8:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a0ac:	111a2640 	call	8111a264 <usiGetIdCMD>
8111a0b0:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
8111a0b4:	e0fff70b 	ldhu	r3,-36(fp)
8111a0b8:	e0bff784 	addi	r2,fp,-34
8111a0bc:	180d883a 	mov	r6,r3
8111a0c0:	01604574 	movhi	r5,33045
8111a0c4:	297f8404 	addi	r5,r5,-496
8111a0c8:	1009883a 	mov	r4,r2
8111a0cc:	11242400 	call	81124240 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8111a0d0:	e0bff784 	addi	r2,fp,-34
8111a0d4:	1009883a 	mov	r4,r2
8111a0d8:	11244540 	call	81124454 <strlen>
8111a0dc:	1007883a 	mov	r3,r2
8111a0e0:	e0bff784 	addi	r2,fp,-34
8111a0e4:	180b883a 	mov	r5,r3
8111a0e8:	1009883a 	mov	r4,r2
8111a0ec:	111c3300 	call	8111c330 <ucCrc8wInit>
8111a0f0:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8111a0f4:	e13ff503 	ldbu	r4,-44(fp)
8111a0f8:	e0fff784 	addi	r3,fp,-34
8111a0fc:	e0bff784 	addi	r2,fp,-34
8111a100:	200f883a 	mov	r7,r4
8111a104:	180d883a 	mov	r6,r3
8111a108:	01604574 	movhi	r5,33045
8111a10c:	297f7f04 	addi	r5,r5,-516
8111a110:	1009883a 	mov	r4,r2
8111a114:	11242400 	call	81124240 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8111a118:	e0bff70b 	ldhu	r2,-36(fp)
8111a11c:	10ffffcc 	andi	r3,r2,65535
8111a120:	18e0001c 	xori	r3,r3,32768
8111a124:	18e00004 	addi	r3,r3,-32768
8111a128:	e0bff784 	addi	r2,fp,-34
8111a12c:	180b883a 	mov	r5,r3
8111a130:	1009883a 	mov	r4,r2
8111a134:	111997c0 	call	8111997c <bSendUART32v2>
8111a138:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8111a13c:	e0bff617 	ldw	r2,-40(fp)
8111a140:	10800060 	cmpeqi	r2,r2,1
8111a144:	1000011e 	bne	r2,zero,8111a14c <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111a148:	111d9f80 	call	8111d9f8 <vCouldNotSendTurnOff>
	}
}
8111a14c:	0001883a 	nop
8111a150:	e037883a 	mov	sp,fp
8111a154:	dfc00117 	ldw	ra,4(sp)
8111a158:	df000017 	ldw	fp,0(sp)
8111a15c:	dec00204 	addi	sp,sp,8
8111a160:	f800283a 	ret

8111a164 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
8111a164:	deffda04 	addi	sp,sp,-152
8111a168:	de00012e 	bgeu	sp,et,8111a170 <vSendLog+0xc>
8111a16c:	003b68fa 	trap	3
8111a170:	dfc02515 	stw	ra,148(sp)
8111a174:	df002415 	stw	fp,144(sp)
8111a178:	df002404 	addi	fp,sp,144
8111a17c:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
8111a180:	e03fde8d 	sth	zero,-134(fp)
8111a184:	e03fdf0d 	sth	zero,-132(fp)
8111a188:	e0bfdf84 	addi	r2,fp,-130
8111a18c:	00c01f04 	movi	r3,124
8111a190:	180d883a 	mov	r6,r3
8111a194:	000b883a 	mov	r5,zero
8111a198:	1009883a 	mov	r4,r2
8111a19c:	1123b2c0 	call	81123b2c <memset>
    unsigned char crc = 0;
8111a1a0:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a1a4:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a1a8:	111a2640 	call	8111a264 <usiGetIdCMD>
8111a1ac:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
8111a1b0:	e0ffde0b 	ldhu	r3,-136(fp)
8111a1b4:	e0bfde84 	addi	r2,fp,-134
8111a1b8:	e1ffff17 	ldw	r7,-4(fp)
8111a1bc:	180d883a 	mov	r6,r3
8111a1c0:	01604574 	movhi	r5,33045
8111a1c4:	297f8604 	addi	r5,r5,-488
8111a1c8:	1009883a 	mov	r4,r2
8111a1cc:	11242400 	call	81124240 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
8111a1d0:	e0bfde84 	addi	r2,fp,-134
8111a1d4:	1009883a 	mov	r4,r2
8111a1d8:	11244540 	call	81124454 <strlen>
8111a1dc:	1007883a 	mov	r3,r2
8111a1e0:	e0bfde84 	addi	r2,fp,-134
8111a1e4:	180b883a 	mov	r5,r3
8111a1e8:	1009883a 	mov	r4,r2
8111a1ec:	111c3300 	call	8111c330 <ucCrc8wInit>
8111a1f0:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
8111a1f4:	e13fdc03 	ldbu	r4,-144(fp)
8111a1f8:	e0ffde84 	addi	r3,fp,-134
8111a1fc:	e0bfde84 	addi	r2,fp,-134
8111a200:	200f883a 	mov	r7,r4
8111a204:	180d883a 	mov	r6,r3
8111a208:	01604574 	movhi	r5,33045
8111a20c:	297f7f04 	addi	r5,r5,-516
8111a210:	1009883a 	mov	r4,r2
8111a214:	11242400 	call	81124240 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
8111a218:	e0bfde0b 	ldhu	r2,-136(fp)
8111a21c:	10ffffcc 	andi	r3,r2,65535
8111a220:	18e0001c 	xori	r3,r3,32768
8111a224:	18e00004 	addi	r3,r3,-32768
8111a228:	e0bfde84 	addi	r2,fp,-134
8111a22c:	180b883a 	mov	r5,r3
8111a230:	1009883a 	mov	r4,r2
8111a234:	11193340 	call	81119334 <bSendUART128v2>
8111a238:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
8111a23c:	e0bfdd17 	ldw	r2,-140(fp)
8111a240:	10800060 	cmpeqi	r2,r2,1
8111a244:	1000011e 	bne	r2,zero,8111a24c <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
8111a248:	111daf80 	call	8111daf8 <vCouldNotSendLog>
	}
}
8111a24c:	0001883a 	nop
8111a250:	e037883a 	mov	sp,fp
8111a254:	dfc00117 	ldw	ra,4(sp)
8111a258:	df000017 	ldw	fp,0(sp)
8111a25c:	dec00204 	addi	sp,sp,8
8111a260:	f800283a 	ret

8111a264 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
8111a264:	deffff04 	addi	sp,sp,-4
8111a268:	de00012e 	bgeu	sp,et,8111a270 <usiGetIdCMD+0xc>
8111a26c:	003b68fa 	trap	3
8111a270:	df000015 	stw	fp,0(sp)
8111a274:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
8111a278:	d0a0680b 	ldhu	r2,-32352(gp)
8111a27c:	10ffffcc 	andi	r3,r2,65535
8111a280:	00bfffd4 	movui	r2,65535
8111a284:	1880031e 	bne	r3,r2,8111a294 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
8111a288:	00800084 	movi	r2,2
8111a28c:	d0a0680d 	sth	r2,-32352(gp)
8111a290:	00000306 	br	8111a2a0 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
8111a294:	d0a0680b 	ldhu	r2,-32352(gp)
8111a298:	10800044 	addi	r2,r2,1
8111a29c:	d0a0680d 	sth	r2,-32352(gp)

    return usiIdCMD;
8111a2a0:	d0a0680b 	ldhu	r2,-32352(gp)
}
8111a2a4:	e037883a 	mov	sp,fp
8111a2a8:	df000017 	ldw	fp,0(sp)
8111a2ac:	dec00104 	addi	sp,sp,4
8111a2b0:	f800283a 	ret

8111a2b4 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
8111a2b4:	defffb04 	addi	sp,sp,-20
8111a2b8:	de00012e 	bgeu	sp,et,8111a2c0 <siPosStr+0xc>
8111a2bc:	003b68fa 	trap	3
8111a2c0:	dfc00415 	stw	ra,16(sp)
8111a2c4:	df000315 	stw	fp,12(sp)
8111a2c8:	df000304 	addi	fp,sp,12
8111a2cc:	e13ffe15 	stw	r4,-8(fp)
8111a2d0:	2805883a 	mov	r2,r5
8111a2d4:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
8111a2d8:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
8111a2dc:	e0bfff03 	ldbu	r2,-4(fp)
8111a2e0:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
8111a2e4:	e17ffd04 	addi	r5,fp,-12
8111a2e8:	e13ffe17 	ldw	r4,-8(fp)
8111a2ec:	11244080 	call	81124408 <strcspn>
}
8111a2f0:	e037883a 	mov	sp,fp
8111a2f4:	dfc00117 	ldw	ra,4(sp)
8111a2f8:	df000017 	ldw	fp,0(sp)
8111a2fc:	dec00204 	addi	sp,sp,8
8111a300:	f800283a 	ret

8111a304 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
8111a304:	defffc04 	addi	sp,sp,-16
8111a308:	de00012e 	bgeu	sp,et,8111a310 <vTimeoutCheck+0xc>
8111a30c:	003b68fa 	trap	3
8111a310:	dfc00315 	stw	ra,12(sp)
8111a314:	df000215 	stw	fp,8(sp)
8111a318:	df000204 	addi	fp,sp,8
8111a31c:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
8111a320:	d0a06717 	ldw	r2,-32356(gp)
8111a324:	1009883a 	mov	r4,r2
8111a328:	11401540 	call	81140154 <OSSemPost>
8111a32c:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
8111a330:	e0bffe03 	ldbu	r2,-8(fp)
8111a334:	10000126 	beq	r2,zero,8111a33c <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
8111a338:	111d6f80 	call	8111d6f8 <vFailPostBlockingSemTimeoutTask>
	}
}
8111a33c:	0001883a 	nop
8111a340:	e037883a 	mov	sp,fp
8111a344:	dfc00117 	ldw	ra,4(sp)
8111a348:	df000017 	ldw	fp,0(sp)
8111a34c:	dec00204 	addi	sp,sp,8
8111a350:	f800283a 	ret

8111a354 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
8111a354:	deffe304 	addi	sp,sp,-116
8111a358:	de00012e 	bgeu	sp,et,8111a360 <vSendPusTM64+0xc>
8111a35c:	003b68fa 	trap	3
8111a360:	dfc01815 	stw	ra,96(sp)
8111a364:	df001715 	stw	fp,92(sp)
8111a368:	df001704 	addi	fp,sp,92
8111a36c:	e1000215 	stw	r4,8(fp)
8111a370:	e1400315 	stw	r5,12(fp)
8111a374:	e1800415 	stw	r6,16(fp)
8111a378:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
8111a37c:	e03fef8d 	sth	zero,-66(fp)
8111a380:	e03ff00d 	sth	zero,-64(fp)
8111a384:	e0bff084 	addi	r2,fp,-62
8111a388:	00c00f04 	movi	r3,60
8111a38c:	180d883a 	mov	r6,r3
8111a390:	000b883a 	mov	r5,zero
8111a394:	1009883a 	mov	r4,r2
8111a398:	1123b2c0 	call	81123b2c <memset>
    unsigned char crc = 0;
8111a39c:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
8111a3a0:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a3a4:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a3a8:	111a2640 	call	8111a264 <usiGetIdCMD>
8111a3ac:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8111a3b0:	e1bfef0b 	ldhu	r6,-68(fp)
8111a3b4:	e080040b 	ldhu	r2,16(fp)
8111a3b8:	11ffffcc 	andi	r7,r2,65535
8111a3bc:	e080048b 	ldhu	r2,18(fp)
8111a3c0:	10bfffcc 	andi	r2,r2,65535
8111a3c4:	e0c0050b 	ldhu	r3,20(fp)
8111a3c8:	18ffffcc 	andi	r3,r3,65535
8111a3cc:	e100058b 	ldhu	r4,22(fp)
8111a3d0:	213fffcc 	andi	r4,r4,65535
8111a3d4:	e140060b 	ldhu	r5,24(fp)
8111a3d8:	297fffcc 	andi	r5,r5,65535
8111a3dc:	e23fef84 	addi	r8,fp,-66
8111a3e0:	d9400315 	stw	r5,12(sp)
8111a3e4:	d9000215 	stw	r4,8(sp)
8111a3e8:	d8c00115 	stw	r3,4(sp)
8111a3ec:	d8800015 	stw	r2,0(sp)
8111a3f0:	01604574 	movhi	r5,33045
8111a3f4:	297f8904 	addi	r5,r5,-476
8111a3f8:	4009883a 	mov	r4,r8
8111a3fc:	11242400 	call	81124240 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111a400:	e03fed05 	stb	zero,-76(fp)
8111a404:	00001206 	br	8111a450 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8111a408:	e0bfed03 	ldbu	r2,-76(fp)
8111a40c:	10800284 	addi	r2,r2,10
8111a410:	1085883a 	add	r2,r2,r2
8111a414:	e0c00204 	addi	r3,fp,8
8111a418:	1885883a 	add	r2,r3,r2
8111a41c:	1080000b 	ldhu	r2,0(r2)
8111a420:	113fffcc 	andi	r4,r2,65535
8111a424:	e0ffef84 	addi	r3,fp,-66
8111a428:	e0bfef84 	addi	r2,fp,-66
8111a42c:	200f883a 	mov	r7,r4
8111a430:	180d883a 	mov	r6,r3
8111a434:	01604574 	movhi	r5,33045
8111a438:	297f9004 	addi	r5,r5,-448
8111a43c:	1009883a 	mov	r4,r2
8111a440:	11242400 	call	81124240 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111a444:	e0bfed03 	ldbu	r2,-76(fp)
8111a448:	10800044 	addi	r2,r2,1
8111a44c:	e0bfed05 	stb	r2,-76(fp)
8111a450:	e0800683 	ldbu	r2,26(fp)
8111a454:	10803fcc 	andi	r2,r2,255
8111a458:	e0ffed03 	ldbu	r3,-76(fp)
8111a45c:	18bfea36 	bltu	r3,r2,8111a408 <__reset+0xfb0fa408>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111a460:	e0bfef84 	addi	r2,fp,-66
8111a464:	1009883a 	mov	r4,r2
8111a468:	11244540 	call	81124454 <strlen>
8111a46c:	1007883a 	mov	r3,r2
8111a470:	e0bfef84 	addi	r2,fp,-66
8111a474:	180b883a 	mov	r5,r3
8111a478:	1009883a 	mov	r4,r2
8111a47c:	111c3300 	call	8111c330 <ucCrc8wInit>
8111a480:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8111a484:	e13fed43 	ldbu	r4,-75(fp)
8111a488:	e0ffef84 	addi	r3,fp,-66
8111a48c:	e0bfef84 	addi	r2,fp,-66
8111a490:	200f883a 	mov	r7,r4
8111a494:	180d883a 	mov	r6,r3
8111a498:	01604574 	movhi	r5,33045
8111a49c:	297f7f04 	addi	r5,r5,-516
8111a4a0:	1009883a 	mov	r4,r2
8111a4a4:	11242400 	call	81124240 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
8111a4a8:	e0bfef0b 	ldhu	r2,-68(fp)
8111a4ac:	10ffffcc 	andi	r3,r2,65535
8111a4b0:	18e0001c 	xori	r3,r3,32768
8111a4b4:	18e00004 	addi	r3,r3,-32768
8111a4b8:	e0bfef84 	addi	r2,fp,-66
8111a4bc:	180b883a 	mov	r5,r3
8111a4c0:	1009883a 	mov	r4,r2
8111a4c4:	11196540 	call	81119654 <bSendUART64v2>
8111a4c8:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
8111a4cc:	e0bfee17 	ldw	r2,-72(fp)
8111a4d0:	10800060 	cmpeqi	r2,r2,1
8111a4d4:	1000031e 	bne	r2,zero,8111a4e4 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111a4d8:	e0bfef84 	addi	r2,fp,-66
8111a4dc:	1009883a 	mov	r4,r2
8111a4e0:	111db780 	call	8111db78 <vCouldNotSendTMPusCommand>
	}
}
8111a4e4:	0001883a 	nop
8111a4e8:	e037883a 	mov	sp,fp
8111a4ec:	dfc00117 	ldw	ra,4(sp)
8111a4f0:	df000017 	ldw	fp,0(sp)
8111a4f4:	dec00604 	addi	sp,sp,24
8111a4f8:	f800283a 	ret

8111a4fc <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
8111a4fc:	deffd304 	addi	sp,sp,-180
8111a500:	de00012e 	bgeu	sp,et,8111a508 <vSendPusTM128+0xc>
8111a504:	003b68fa 	trap	3
8111a508:	dfc02815 	stw	ra,160(sp)
8111a50c:	df002715 	stw	fp,156(sp)
8111a510:	df002704 	addi	fp,sp,156
8111a514:	e1000215 	stw	r4,8(fp)
8111a518:	e1400315 	stw	r5,12(fp)
8111a51c:	e1800415 	stw	r6,16(fp)
8111a520:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
8111a524:	e03fdf8d 	sth	zero,-130(fp)
8111a528:	e03fe00d 	sth	zero,-128(fp)
8111a52c:	e0bfe084 	addi	r2,fp,-126
8111a530:	00c01f04 	movi	r3,124
8111a534:	180d883a 	mov	r6,r3
8111a538:	000b883a 	mov	r5,zero
8111a53c:	1009883a 	mov	r4,r2
8111a540:	1123b2c0 	call	81123b2c <memset>
    unsigned char crc = 0;
8111a544:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
8111a548:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
8111a54c:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111a550:	111a2640 	call	8111a264 <usiGetIdCMD>
8111a554:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8111a558:	e1bfdf0b 	ldhu	r6,-132(fp)
8111a55c:	e080040b 	ldhu	r2,16(fp)
8111a560:	11ffffcc 	andi	r7,r2,65535
8111a564:	e080048b 	ldhu	r2,18(fp)
8111a568:	10bfffcc 	andi	r2,r2,65535
8111a56c:	e0c0050b 	ldhu	r3,20(fp)
8111a570:	18ffffcc 	andi	r3,r3,65535
8111a574:	e100058b 	ldhu	r4,22(fp)
8111a578:	213fffcc 	andi	r4,r4,65535
8111a57c:	e140060b 	ldhu	r5,24(fp)
8111a580:	297fffcc 	andi	r5,r5,65535
8111a584:	e23fdf84 	addi	r8,fp,-130
8111a588:	d9400315 	stw	r5,12(sp)
8111a58c:	d9000215 	stw	r4,8(sp)
8111a590:	d8c00115 	stw	r3,4(sp)
8111a594:	d8800015 	stw	r2,0(sp)
8111a598:	01604574 	movhi	r5,33045
8111a59c:	297f8904 	addi	r5,r5,-476
8111a5a0:	4009883a 	mov	r4,r8
8111a5a4:	11242400 	call	81124240 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111a5a8:	e03fdd05 	stb	zero,-140(fp)
8111a5ac:	00001206 	br	8111a5f8 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8111a5b0:	e0bfdd03 	ldbu	r2,-140(fp)
8111a5b4:	10800284 	addi	r2,r2,10
8111a5b8:	1085883a 	add	r2,r2,r2
8111a5bc:	e0c00204 	addi	r3,fp,8
8111a5c0:	1885883a 	add	r2,r3,r2
8111a5c4:	1080000b 	ldhu	r2,0(r2)
8111a5c8:	113fffcc 	andi	r4,r2,65535
8111a5cc:	e0ffdf84 	addi	r3,fp,-130
8111a5d0:	e0bfdf84 	addi	r2,fp,-130
8111a5d4:	200f883a 	mov	r7,r4
8111a5d8:	180d883a 	mov	r6,r3
8111a5dc:	01604574 	movhi	r5,33045
8111a5e0:	297f9004 	addi	r5,r5,-448
8111a5e4:	1009883a 	mov	r4,r2
8111a5e8:	11242400 	call	81124240 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111a5ec:	e0bfdd03 	ldbu	r2,-140(fp)
8111a5f0:	10800044 	addi	r2,r2,1
8111a5f4:	e0bfdd05 	stb	r2,-140(fp)
8111a5f8:	e0800683 	ldbu	r2,26(fp)
8111a5fc:	10803fcc 	andi	r2,r2,255
8111a600:	e0ffdd03 	ldbu	r3,-140(fp)
8111a604:	18bfea36 	bltu	r3,r2,8111a5b0 <__reset+0xfb0fa5b0>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111a608:	e0bfdf84 	addi	r2,fp,-130
8111a60c:	1009883a 	mov	r4,r2
8111a610:	11244540 	call	81124454 <strlen>
8111a614:	1007883a 	mov	r3,r2
8111a618:	e0bfdf84 	addi	r2,fp,-130
8111a61c:	180b883a 	mov	r5,r3
8111a620:	1009883a 	mov	r4,r2
8111a624:	111c3300 	call	8111c330 <ucCrc8wInit>
8111a628:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8111a62c:	e13fdd43 	ldbu	r4,-139(fp)
8111a630:	e0ffdf84 	addi	r3,fp,-130
8111a634:	e0bfdf84 	addi	r2,fp,-130
8111a638:	200f883a 	mov	r7,r4
8111a63c:	180d883a 	mov	r6,r3
8111a640:	01604574 	movhi	r5,33045
8111a644:	297f7f04 	addi	r5,r5,-516
8111a648:	1009883a 	mov	r4,r2
8111a64c:	11242400 	call	81124240 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
8111a650:	e0bfdf0b 	ldhu	r2,-132(fp)
8111a654:	10ffffcc 	andi	r3,r2,65535
8111a658:	18e0001c 	xori	r3,r3,32768
8111a65c:	18e00004 	addi	r3,r3,-32768
8111a660:	e0bfdf84 	addi	r2,fp,-130
8111a664:	180b883a 	mov	r5,r3
8111a668:	1009883a 	mov	r4,r2
8111a66c:	11193340 	call	81119334 <bSendUART128v2>
8111a670:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
8111a674:	e0bfde17 	ldw	r2,-136(fp)
8111a678:	10800060 	cmpeqi	r2,r2,1
8111a67c:	1000031e 	bne	r2,zero,8111a68c <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111a680:	e0bfdf84 	addi	r2,fp,-130
8111a684:	1009883a 	mov	r4,r2
8111a688:	111db780 	call	8111db78 <vCouldNotSendTMPusCommand>
	}
}
8111a68c:	0001883a 	nop
8111a690:	e037883a 	mov	sp,fp
8111a694:	dfc00117 	ldw	ra,4(sp)
8111a698:	df000017 	ldw	fp,0(sp)
8111a69c:	dec00604 	addi	sp,sp,24
8111a6a0:	f800283a 	ret

8111a6a4 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
8111a6a4:	deffd704 	addi	sp,sp,-164
8111a6a8:	de00012e 	bgeu	sp,et,8111a6b0 <vTMPusTestConnection+0xc>
8111a6ac:	003b68fa 	trap	3
8111a6b0:	dfc02815 	stw	ra,160(sp)
8111a6b4:	df002715 	stw	fp,156(sp)
8111a6b8:	df002704 	addi	fp,sp,156
8111a6bc:	2005883a 	mov	r2,r4
8111a6c0:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
8111a6c4:	e0bfff0b 	ldhu	r2,-4(fp)
8111a6c8:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
8111a6cc:	00801c04 	movi	r2,112
8111a6d0:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
8111a6d4:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
8111a6d8:	00800444 	movi	r2,17
8111a6dc:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
8111a6e0:	00800084 	movi	r2,2
8111a6e4:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
8111a6e8:	d809883a 	mov	r4,sp
8111a6ec:	e0bfee04 	addi	r2,fp,-72
8111a6f0:	00c01104 	movi	r3,68
8111a6f4:	180d883a 	mov	r6,r3
8111a6f8:	100b883a 	mov	r5,r2
8111a6fc:	11239dc0 	call	811239dc <memcpy>
8111a700:	e13fea17 	ldw	r4,-88(fp)
8111a704:	e17feb17 	ldw	r5,-84(fp)
8111a708:	e1bfec17 	ldw	r6,-80(fp)
8111a70c:	e1ffed17 	ldw	r7,-76(fp)
8111a710:	111a3540 	call	8111a354 <vSendPusTM64>
}
8111a714:	0001883a 	nop
8111a718:	e037883a 	mov	sp,fp
8111a71c:	dfc00117 	ldw	ra,4(sp)
8111a720:	df000017 	ldw	fp,0(sp)
8111a724:	dec00204 	addi	sp,sp,8
8111a728:	f800283a 	ret

8111a72c <vLoadDefaultETHConf>:
/*Configuration related to the eth connection*/
TConfEth xConfEth;
TDefaults xDefaults;


bool vLoadDefaultETHConf( void ){
8111a72c:	defff504 	addi	sp,sp,-44
8111a730:	de00012e 	bgeu	sp,et,8111a738 <vLoadDefaultETHConf+0xc>
8111a734:	003b68fa 	trap	3
8111a738:	dfc00a15 	stw	ra,40(sp)
8111a73c:	df000915 	stw	fp,36(sp)
8111a740:	dc000815 	stw	r16,32(sp)
8111a744:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8111a748:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
8111a74c:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
8111a750:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8111a754:	d0a07617 	ldw	r2,-32296(gp)
8111a758:	10800058 	cmpnei	r2,r2,1
8111a75c:	10021f1e 	bne	r2,zero,8111afdc <vLoadDefaultETHConf+0x8b0>
8111a760:	111fe040 	call	8111fe04 <bSDcardIsPresent>
8111a764:	10021d26 	beq	r2,zero,8111afdc <vLoadDefaultETHConf+0x8b0>
8111a768:	111fe340 	call	8111fe34 <bSDcardFAT16Check>
8111a76c:	10021b26 	beq	r2,zero,8111afdc <vLoadDefaultETHConf+0x8b0>

		siFile = siOpenFile( ETH_FILE_NAME );
8111a770:	01204574 	movhi	r4,33045
8111a774:	213f9204 	addi	r4,r4,-440
8111a778:	111ff5c0 	call	8111ff5c <siOpenFile>
8111a77c:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
8111a780:	e0bffc0f 	ldh	r2,-16(fp)
8111a784:	10020716 	blt	r2,zero,8111afa4 <vLoadDefaultETHConf+0x878>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8111a788:	e0bffd04 	addi	r2,fp,-12
8111a78c:	01800204 	movi	r6,8
8111a790:	01400284 	movi	r5,10
8111a794:	1009883a 	mov	r4,r2
8111a798:	1123b2c0 	call	81123b2c <memset>
			p_inteiro = inteiro;
8111a79c:	e0bffd04 	addi	r2,fp,-12
8111a7a0:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
8111a7a4:	e0bffc0f 	ldh	r2,-16(fp)
8111a7a8:	1009883a 	mov	r4,r2
8111a7ac:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111a7b0:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
8111a7b4:	e0bff947 	ldb	r2,-27(fp)
8111a7b8:	10800084 	addi	r2,r2,2
8111a7bc:	10c015a8 	cmpgeui	r3,r2,86
8111a7c0:	1801e41e 	bne	r3,zero,8111af54 <vLoadDefaultETHConf+0x828>
8111a7c4:	100690ba 	slli	r3,r2,2
8111a7c8:	00a044b4 	movhi	r2,33042
8111a7cc:	10a9f704 	addi	r2,r2,-22564
8111a7d0:	1885883a 	add	r2,r3,r2
8111a7d4:	10800017 	ldw	r2,0(r2)
8111a7d8:	1000683a 	jmp	r2
8111a7dc:	8111a974 	orhi	r4,r16,18085
8111a7e0:	8111a968 	cmpgeui	r4,r16,18085
8111a7e4:	8111af54 	ori	r4,r16,18109
8111a7e8:	8111af54 	ori	r4,r16,18109
8111a7ec:	8111af54 	ori	r4,r16,18109
8111a7f0:	8111af54 	ori	r4,r16,18109
8111a7f4:	8111af54 	ori	r4,r16,18109
8111a7f8:	8111af54 	ori	r4,r16,18109
8111a7fc:	8111af54 	ori	r4,r16,18109
8111a800:	8111af54 	ori	r4,r16,18109
8111a804:	8111af54 	ori	r4,r16,18109
8111a808:	8111af54 	ori	r4,r16,18109
8111a80c:	8111af8c 	andi	r4,r16,18110
8111a810:	8111af54 	ori	r4,r16,18109
8111a814:	8111af54 	ori	r4,r16,18109
8111a818:	8111af8c 	andi	r4,r16,18110
8111a81c:	8111af54 	ori	r4,r16,18109
8111a820:	8111af54 	ori	r4,r16,18109
8111a824:	8111af54 	ori	r4,r16,18109
8111a828:	8111af54 	ori	r4,r16,18109
8111a82c:	8111af54 	ori	r4,r16,18109
8111a830:	8111af54 	ori	r4,r16,18109
8111a834:	8111af54 	ori	r4,r16,18109
8111a838:	8111af54 	ori	r4,r16,18109
8111a83c:	8111af54 	ori	r4,r16,18109
8111a840:	8111af54 	ori	r4,r16,18109
8111a844:	8111af54 	ori	r4,r16,18109
8111a848:	8111af54 	ori	r4,r16,18109
8111a84c:	8111af54 	ori	r4,r16,18109
8111a850:	8111af54 	ori	r4,r16,18109
8111a854:	8111af54 	ori	r4,r16,18109
8111a858:	8111af54 	ori	r4,r16,18109
8111a85c:	8111af54 	ori	r4,r16,18109
8111a860:	8111af54 	ori	r4,r16,18109
8111a864:	8111af8c 	andi	r4,r16,18110
8111a868:	8111af54 	ori	r4,r16,18109
8111a86c:	8111af54 	ori	r4,r16,18109
8111a870:	8111af54 	ori	r4,r16,18109
8111a874:	8111af54 	ori	r4,r16,18109
8111a878:	8111af54 	ori	r4,r16,18109
8111a87c:	8111af54 	ori	r4,r16,18109
8111a880:	8111a934 	orhi	r4,r16,18084
8111a884:	8111af54 	ori	r4,r16,18109
8111a888:	8111af54 	ori	r4,r16,18109
8111a88c:	8111af54 	ori	r4,r16,18109
8111a890:	8111af54 	ori	r4,r16,18109
8111a894:	8111af54 	ori	r4,r16,18109
8111a898:	8111af54 	ori	r4,r16,18109
8111a89c:	8111af54 	ori	r4,r16,18109
8111a8a0:	8111af54 	ori	r4,r16,18109
8111a8a4:	8111af54 	ori	r4,r16,18109
8111a8a8:	8111af54 	ori	r4,r16,18109
8111a8ac:	8111af54 	ori	r4,r16,18109
8111a8b0:	8111af54 	ori	r4,r16,18109
8111a8b4:	8111af54 	ori	r4,r16,18109
8111a8b8:	8111af54 	ori	r4,r16,18109
8111a8bc:	8111af54 	ori	r4,r16,18109
8111a8c0:	8111af54 	ori	r4,r16,18109
8111a8c4:	8111af54 	ori	r4,r16,18109
8111a8c8:	8111af54 	ori	r4,r16,18109
8111a8cc:	8111af54 	ori	r4,r16,18109
8111a8d0:	8111af54 	ori	r4,r16,18109
8111a8d4:	8111aef4 	orhi	r4,r16,18107
8111a8d8:	8111af54 	ori	r4,r16,18109
8111a8dc:	8111af54 	ori	r4,r16,18109
8111a8e0:	8111af54 	ori	r4,r16,18109
8111a8e4:	8111af54 	ori	r4,r16,18109
8111a8e8:	8111af54 	ori	r4,r16,18109
8111a8ec:	8111af54 	ori	r4,r16,18109
8111a8f0:	8111af54 	ori	r4,r16,18109
8111a8f4:	8111ae24 	muli	r4,r16,18104
8111a8f8:	8111af54 	ori	r4,r16,18109
8111a8fc:	8111af54 	ori	r4,r16,18109
8111a900:	8111ab50 	cmplti	r4,r16,18093
8111a904:	8111acac 	andhi	r4,r16,18098
8111a908:	8111aa84 	addi	r4,r16,18090
8111a90c:	8111af54 	ori	r4,r16,18109
8111a910:	8111af54 	ori	r4,r16,18109
8111a914:	8111af54 	ori	r4,r16,18109
8111a918:	8111a9b4 	orhi	r4,r16,18086
8111a91c:	8111af54 	ori	r4,r16,18109
8111a920:	8111af54 	ori	r4,r16,18109
8111a924:	8111ac20 	cmpeqi	r4,r16,18096
8111a928:	8111af54 	ori	r4,r16,18109
8111a92c:	8111af54 	ori	r4,r16,18109
8111a930:	8111ad54 	ori	r4,r16,18101
					case 39:// single quote '
						c = cGetNextChar(siFile);
8111a934:	e0bffc0f 	ldh	r2,-16(fp)
8111a938:	1009883a 	mov	r4,r2
8111a93c:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111a940:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
8111a944:	00000406 	br	8111a958 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
8111a948:	e0bffc0f 	ldh	r2,-16(fp)
8111a94c:	1009883a 	mov	r4,r2
8111a950:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111a954:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111a958:	e0bff947 	ldb	r2,-27(fp)
8111a95c:	108009d8 	cmpnei	r2,r2,39
8111a960:	103ff91e 	bne	r2,zero,8111a948 <__reset+0xfb0fa948>
							c = cGetNextChar(siFile);
						}
						break;
8111a964:	00018c06 	br	8111af98 <vLoadDefaultETHConf+0x86c>
					case -1: 	//EOF
						bEOF = TRUE;
8111a968:	00800044 	movi	r2,1
8111a96c:	e0bff815 	stw	r2,-32(fp)
						break;
8111a970:	00018906 	br	8111af98 <vLoadDefaultETHConf+0x86c>
					case -2: 	//EOF
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111a974:	00a045b4 	movhi	r2,33046
8111a978:	109fe204 	addi	r2,r2,32648
8111a97c:	10800d8b 	ldhu	r2,54(r2)
8111a980:	10bfffcc 	andi	r2,r2,65535
8111a984:	10800228 	cmpgeui	r2,r2,8
8111a988:	1000071e 	bne	r2,zero,8111a9a8 <vLoadDefaultETHConf+0x27c>
							debug(fp,"SDCard: Problem with SDCard");
8111a98c:	d0a06217 	ldw	r2,-32376(gp)
8111a990:	100f883a 	mov	r7,r2
8111a994:	018006c4 	movi	r6,27
8111a998:	01400044 	movi	r5,1
8111a99c:	01204574 	movhi	r4,33045
8111a9a0:	213f9404 	addi	r4,r4,-432
8111a9a4:	1122fc80 	call	81122fc8 <fwrite>
						}
						#endif
						bEOF = TRUE;
8111a9a8:	00800044 	movi	r2,1
8111a9ac:	e0bff815 	stw	r2,-32(fp)
						break;
8111a9b0:	00017906 	br	8111af98 <vLoadDefaultETHConf+0x86c>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
8111a9b4:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a9b8:	e0bffc0f 	ldh	r2,-16(fp)
8111a9bc:	1009883a 	mov	r4,r2
8111a9c0:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111a9c4:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a9c8:	d0e00317 	ldw	r3,-32756(gp)
8111a9cc:	e0bff947 	ldb	r2,-27(fp)
8111a9d0:	10800044 	addi	r2,r2,1
8111a9d4:	1885883a 	add	r2,r3,r2
8111a9d8:	10800003 	ldbu	r2,0(r2)
8111a9dc:	10803fcc 	andi	r2,r2,255
8111a9e0:	1080010c 	andi	r2,r2,4
8111a9e4:	10000626 	beq	r2,zero,8111aa00 <vLoadDefaultETHConf+0x2d4>
									(*p_inteiro) = c;
8111a9e8:	e0bffa17 	ldw	r2,-24(fp)
8111a9ec:	e0fff943 	ldbu	r3,-27(fp)
8111a9f0:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a9f4:	e0bffa17 	ldw	r2,-24(fp)
8111a9f8:	10800044 	addi	r2,r2,1
8111a9fc:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
8111aa00:	e0bff947 	ldb	r2,-27(fp)
8111aa04:	10800ea0 	cmpeqi	r2,r2,58
8111aa08:	1000031e 	bne	r2,zero,8111aa18 <vLoadDefaultETHConf+0x2ec>
8111aa0c:	e0bff947 	ldb	r2,-27(fp)
8111aa10:	10800ed8 	cmpnei	r2,r2,59
8111aa14:	103fe81e 	bne	r2,zero,8111a9b8 <__reset+0xfb0fa9b8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111aa18:	e0bffa17 	ldw	r2,-24(fp)
8111aa1c:	00c00284 	movi	r3,10
8111aa20:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
8111aa24:	e0bff903 	ldbu	r2,-28(fp)
8111aa28:	10800168 	cmpgeui	r2,r2,5
8111aa2c:	1000021e 	bne	r2,zero,8111aa38 <vLoadDefaultETHConf+0x30c>
8111aa30:	e43ff903 	ldbu	r16,-28(fp)
8111aa34:	00000106 	br	8111aa3c <vLoadDefaultETHConf+0x310>
8111aa38:	04000144 	movi	r16,5
8111aa3c:	e0bffd04 	addi	r2,fp,-12
8111aa40:	1009883a 	mov	r4,r2
8111aa44:	11227d00 	call	811227d0 <atoi>
8111aa48:	1007883a 	mov	r3,r2
8111aa4c:	00a045b4 	movhi	r2,33046
8111aa50:	109ff104 	addi	r2,r2,32708
8111aa54:	1405883a 	add	r2,r2,r16
8111aa58:	10800404 	addi	r2,r2,16
8111aa5c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111aa60:	e0bffd04 	addi	r2,fp,-12
8111aa64:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111aa68:	e0bff903 	ldbu	r2,-28(fp)
8111aa6c:	10800044 	addi	r2,r2,1
8111aa70:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111aa74:	e0bff947 	ldb	r2,-27(fp)
8111aa78:	10800ed8 	cmpnei	r2,r2,59
8111aa7c:	103fce1e 	bne	r2,zero,8111a9b8 <__reset+0xfb0fa9b8>

						break;
8111aa80:	00014506 	br	8111af98 <vLoadDefaultETHConf+0x86c>
					case 'I':

						ucParser = 0;
8111aa84:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111aa88:	e0bffc0f 	ldh	r2,-16(fp)
8111aa8c:	1009883a 	mov	r4,r2
8111aa90:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111aa94:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111aa98:	d0e00317 	ldw	r3,-32756(gp)
8111aa9c:	e0bff947 	ldb	r2,-27(fp)
8111aaa0:	10800044 	addi	r2,r2,1
8111aaa4:	1885883a 	add	r2,r3,r2
8111aaa8:	10800003 	ldbu	r2,0(r2)
8111aaac:	10803fcc 	andi	r2,r2,255
8111aab0:	1080010c 	andi	r2,r2,4
8111aab4:	10000626 	beq	r2,zero,8111aad0 <vLoadDefaultETHConf+0x3a4>
									(*p_inteiro) = c;
8111aab8:	e0bffa17 	ldw	r2,-24(fp)
8111aabc:	e0fff943 	ldbu	r3,-27(fp)
8111aac0:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111aac4:	e0bffa17 	ldw	r2,-24(fp)
8111aac8:	10800044 	addi	r2,r2,1
8111aacc:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111aad0:	e0bff947 	ldb	r2,-27(fp)
8111aad4:	10800ba0 	cmpeqi	r2,r2,46
8111aad8:	1000031e 	bne	r2,zero,8111aae8 <vLoadDefaultETHConf+0x3bc>
8111aadc:	e0bff947 	ldb	r2,-27(fp)
8111aae0:	10800ed8 	cmpnei	r2,r2,59
8111aae4:	103fe81e 	bne	r2,zero,8111aa88 <__reset+0xfb0faa88>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111aae8:	e0bffa17 	ldw	r2,-24(fp)
8111aaec:	00c00284 	movi	r3,10
8111aaf0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
8111aaf4:	e0bff903 	ldbu	r2,-28(fp)
8111aaf8:	108000e8 	cmpgeui	r2,r2,3
8111aafc:	1000021e 	bne	r2,zero,8111ab08 <vLoadDefaultETHConf+0x3dc>
8111ab00:	e43ff903 	ldbu	r16,-28(fp)
8111ab04:	00000106 	br	8111ab0c <vLoadDefaultETHConf+0x3e0>
8111ab08:	040000c4 	movi	r16,3
8111ab0c:	e0bffd04 	addi	r2,fp,-12
8111ab10:	1009883a 	mov	r4,r2
8111ab14:	11227d00 	call	811227d0 <atoi>
8111ab18:	1007883a 	mov	r3,r2
8111ab1c:	00a045b4 	movhi	r2,33046
8111ab20:	109ff104 	addi	r2,r2,32708
8111ab24:	1405883a 	add	r2,r2,r16
8111ab28:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111ab2c:	e0bffd04 	addi	r2,fp,-12
8111ab30:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111ab34:	e0bff903 	ldbu	r2,-28(fp)
8111ab38:	10800044 	addi	r2,r2,1
8111ab3c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111ab40:	e0bff947 	ldb	r2,-27(fp)
8111ab44:	10800ed8 	cmpnei	r2,r2,59
8111ab48:	103fcf1e 	bne	r2,zero,8111aa88 <__reset+0xfb0faa88>

						break;
8111ab4c:	00011206 	br	8111af98 <vLoadDefaultETHConf+0x86c>
					case 'G':

						ucParser = 0;
8111ab50:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ab54:	e0bffc0f 	ldh	r2,-16(fp)
8111ab58:	1009883a 	mov	r4,r2
8111ab5c:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111ab60:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111ab64:	d0e00317 	ldw	r3,-32756(gp)
8111ab68:	e0bff947 	ldb	r2,-27(fp)
8111ab6c:	10800044 	addi	r2,r2,1
8111ab70:	1885883a 	add	r2,r3,r2
8111ab74:	10800003 	ldbu	r2,0(r2)
8111ab78:	10803fcc 	andi	r2,r2,255
8111ab7c:	1080010c 	andi	r2,r2,4
8111ab80:	10000626 	beq	r2,zero,8111ab9c <vLoadDefaultETHConf+0x470>
									(*p_inteiro) = c;
8111ab84:	e0bffa17 	ldw	r2,-24(fp)
8111ab88:	e0fff943 	ldbu	r3,-27(fp)
8111ab8c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ab90:	e0bffa17 	ldw	r2,-24(fp)
8111ab94:	10800044 	addi	r2,r2,1
8111ab98:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ab9c:	e0bff947 	ldb	r2,-27(fp)
8111aba0:	10800ba0 	cmpeqi	r2,r2,46
8111aba4:	1000031e 	bne	r2,zero,8111abb4 <vLoadDefaultETHConf+0x488>
8111aba8:	e0bff947 	ldb	r2,-27(fp)
8111abac:	10800ed8 	cmpnei	r2,r2,59
8111abb0:	103fe81e 	bne	r2,zero,8111ab54 <__reset+0xfb0fab54>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111abb4:	e0bffa17 	ldw	r2,-24(fp)
8111abb8:	00c00284 	movi	r3,10
8111abbc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
8111abc0:	e0bff903 	ldbu	r2,-28(fp)
8111abc4:	108000e8 	cmpgeui	r2,r2,3
8111abc8:	1000021e 	bne	r2,zero,8111abd4 <vLoadDefaultETHConf+0x4a8>
8111abcc:	e43ff903 	ldbu	r16,-28(fp)
8111abd0:	00000106 	br	8111abd8 <vLoadDefaultETHConf+0x4ac>
8111abd4:	040000c4 	movi	r16,3
8111abd8:	e0bffd04 	addi	r2,fp,-12
8111abdc:	1009883a 	mov	r4,r2
8111abe0:	11227d00 	call	811227d0 <atoi>
8111abe4:	1007883a 	mov	r3,r2
8111abe8:	00a045b4 	movhi	r2,33046
8111abec:	109ff104 	addi	r2,r2,32708
8111abf0:	1405883a 	add	r2,r2,r16
8111abf4:	10800104 	addi	r2,r2,4
8111abf8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111abfc:	e0bffd04 	addi	r2,fp,-12
8111ac00:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111ac04:	e0bff903 	ldbu	r2,-28(fp)
8111ac08:	10800044 	addi	r2,r2,1
8111ac0c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111ac10:	e0bff947 	ldb	r2,-27(fp)
8111ac14:	10800ed8 	cmpnei	r2,r2,59
8111ac18:	103fce1e 	bne	r2,zero,8111ab54 <__reset+0xfb0fab54>

						break;
8111ac1c:	0000de06 	br	8111af98 <vLoadDefaultETHConf+0x86c>
					case 'P':
						ucParser = 0;
8111ac20:	e03ff905 	stb	zero,-28(fp)
						do {
							c = cGetNextChar(siFile);
8111ac24:	e0bffc0f 	ldh	r2,-16(fp)
8111ac28:	1009883a 	mov	r4,r2
8111ac2c:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111ac30:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111ac34:	d0e00317 	ldw	r3,-32756(gp)
8111ac38:	e0bff947 	ldb	r2,-27(fp)
8111ac3c:	10800044 	addi	r2,r2,1
8111ac40:	1885883a 	add	r2,r3,r2
8111ac44:	10800003 	ldbu	r2,0(r2)
8111ac48:	10803fcc 	andi	r2,r2,255
8111ac4c:	1080010c 	andi	r2,r2,4
8111ac50:	10000626 	beq	r2,zero,8111ac6c <vLoadDefaultETHConf+0x540>
								(*p_inteiro) = c;
8111ac54:	e0bffa17 	ldw	r2,-24(fp)
8111ac58:	e0fff943 	ldbu	r3,-27(fp)
8111ac5c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111ac60:	e0bffa17 	ldw	r2,-24(fp)
8111ac64:	10800044 	addi	r2,r2,1
8111ac68:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111ac6c:	e0bff947 	ldb	r2,-27(fp)
8111ac70:	10800ed8 	cmpnei	r2,r2,59
8111ac74:	103feb1e 	bne	r2,zero,8111ac24 <__reset+0xfb0fac24>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ac78:	e0bffa17 	ldw	r2,-24(fp)
8111ac7c:	00c00284 	movi	r3,10
8111ac80:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
8111ac84:	e0bffd04 	addi	r2,fp,-12
8111ac88:	1009883a 	mov	r4,r2
8111ac8c:	11227d00 	call	811227d0 <atoi>
8111ac90:	1007883a 	mov	r3,r2
8111ac94:	00a045b4 	movhi	r2,33046
8111ac98:	109ff104 	addi	r2,r2,32708
8111ac9c:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111aca0:	e0bffd04 	addi	r2,fp,-12
8111aca4:	e0bffa15 	stw	r2,-24(fp)

						break;
8111aca8:	0000bb06 	br	8111af98 <vLoadDefaultETHConf+0x86c>
					case 'H':

						do {
							c = cGetNextChar(siFile);
8111acac:	e0bffc0f 	ldh	r2,-16(fp)
8111acb0:	1009883a 	mov	r4,r2
8111acb4:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111acb8:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111acbc:	d0e00317 	ldw	r3,-32756(gp)
8111acc0:	e0bff947 	ldb	r2,-27(fp)
8111acc4:	10800044 	addi	r2,r2,1
8111acc8:	1885883a 	add	r2,r3,r2
8111accc:	10800003 	ldbu	r2,0(r2)
8111acd0:	10803fcc 	andi	r2,r2,255
8111acd4:	1080010c 	andi	r2,r2,4
8111acd8:	10000626 	beq	r2,zero,8111acf4 <vLoadDefaultETHConf+0x5c8>
								(*p_inteiro) = c;
8111acdc:	e0bffa17 	ldw	r2,-24(fp)
8111ace0:	e0fff943 	ldbu	r3,-27(fp)
8111ace4:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111ace8:	e0bffa17 	ldw	r2,-24(fp)
8111acec:	10800044 	addi	r2,r2,1
8111acf0:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111acf4:	e0bff947 	ldb	r2,-27(fp)
8111acf8:	10800ed8 	cmpnei	r2,r2,59
8111acfc:	103feb1e 	bne	r2,zero,8111acac <__reset+0xfb0facac>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ad00:	e0bffa17 	ldw	r2,-24(fp)
8111ad04:	00c00284 	movi	r3,10
8111ad08:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111ad0c:	e0bffd04 	addi	r2,fp,-12
8111ad10:	1009883a 	mov	r4,r2
8111ad14:	11227d00 	call	811227d0 <atoi>
8111ad18:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
8111ad1c:	e0bffc8f 	ldh	r2,-14(fp)
8111ad20:	10800058 	cmpnei	r2,r2,1
8111ad24:	1000051e 	bne	r2,zero,8111ad3c <vLoadDefaultETHConf+0x610>
							xConfEth.bDHCP = TRUE;
8111ad28:	00a045b4 	movhi	r2,33046
8111ad2c:	109ff104 	addi	r2,r2,32708
8111ad30:	00c00044 	movi	r3,1
8111ad34:	10c00615 	stw	r3,24(r2)
8111ad38:	00000306 	br	8111ad48 <vLoadDefaultETHConf+0x61c>
						else
							xConfEth.bDHCP = FALSE;
8111ad3c:	00a045b4 	movhi	r2,33046
8111ad40:	109ff104 	addi	r2,r2,32708
8111ad44:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111ad48:	e0bffd04 	addi	r2,fp,-12
8111ad4c:	e0bffa15 	stw	r2,-24(fp)

						break;
8111ad50:	00009106 	br	8111af98 <vLoadDefaultETHConf+0x86c>

					case 'S':

						ucParser = 0;
8111ad54:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ad58:	e0bffc0f 	ldh	r2,-16(fp)
8111ad5c:	1009883a 	mov	r4,r2
8111ad60:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111ad64:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111ad68:	d0e00317 	ldw	r3,-32756(gp)
8111ad6c:	e0bff947 	ldb	r2,-27(fp)
8111ad70:	10800044 	addi	r2,r2,1
8111ad74:	1885883a 	add	r2,r3,r2
8111ad78:	10800003 	ldbu	r2,0(r2)
8111ad7c:	10803fcc 	andi	r2,r2,255
8111ad80:	1080010c 	andi	r2,r2,4
8111ad84:	10000626 	beq	r2,zero,8111ada0 <vLoadDefaultETHConf+0x674>
									(*p_inteiro) = c;
8111ad88:	e0bffa17 	ldw	r2,-24(fp)
8111ad8c:	e0fff943 	ldbu	r3,-27(fp)
8111ad90:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ad94:	e0bffa17 	ldw	r2,-24(fp)
8111ad98:	10800044 	addi	r2,r2,1
8111ad9c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ada0:	e0bff947 	ldb	r2,-27(fp)
8111ada4:	10800ba0 	cmpeqi	r2,r2,46
8111ada8:	1000031e 	bne	r2,zero,8111adb8 <vLoadDefaultETHConf+0x68c>
8111adac:	e0bff947 	ldb	r2,-27(fp)
8111adb0:	10800ed8 	cmpnei	r2,r2,59
8111adb4:	103fe81e 	bne	r2,zero,8111ad58 <__reset+0xfb0fad58>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111adb8:	e0bffa17 	ldw	r2,-24(fp)
8111adbc:	00c00284 	movi	r3,10
8111adc0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
8111adc4:	e0bff903 	ldbu	r2,-28(fp)
8111adc8:	108000e8 	cmpgeui	r2,r2,3
8111adcc:	1000021e 	bne	r2,zero,8111add8 <vLoadDefaultETHConf+0x6ac>
8111add0:	e43ff903 	ldbu	r16,-28(fp)
8111add4:	00000106 	br	8111addc <vLoadDefaultETHConf+0x6b0>
8111add8:	040000c4 	movi	r16,3
8111addc:	e0bffd04 	addi	r2,fp,-12
8111ade0:	1009883a 	mov	r4,r2
8111ade4:	11227d00 	call	811227d0 <atoi>
8111ade8:	1007883a 	mov	r3,r2
8111adec:	00a045b4 	movhi	r2,33046
8111adf0:	109ff104 	addi	r2,r2,32708
8111adf4:	1405883a 	add	r2,r2,r16
8111adf8:	10800204 	addi	r2,r2,8
8111adfc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111ae00:	e0bffd04 	addi	r2,fp,-12
8111ae04:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111ae08:	e0bff903 	ldbu	r2,-28(fp)
8111ae0c:	10800044 	addi	r2,r2,1
8111ae10:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111ae14:	e0bff947 	ldb	r2,-27(fp)
8111ae18:	10800ed8 	cmpnei	r2,r2,59
8111ae1c:	103fce1e 	bne	r2,zero,8111ad58 <__reset+0xfb0fad58>

						break;
8111ae20:	00005d06 	br	8111af98 <vLoadDefaultETHConf+0x86c>
					case 'D':

						ucParser = 0;
8111ae24:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ae28:	e0bffc0f 	ldh	r2,-16(fp)
8111ae2c:	1009883a 	mov	r4,r2
8111ae30:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111ae34:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111ae38:	d0e00317 	ldw	r3,-32756(gp)
8111ae3c:	e0bff947 	ldb	r2,-27(fp)
8111ae40:	10800044 	addi	r2,r2,1
8111ae44:	1885883a 	add	r2,r3,r2
8111ae48:	10800003 	ldbu	r2,0(r2)
8111ae4c:	10803fcc 	andi	r2,r2,255
8111ae50:	1080010c 	andi	r2,r2,4
8111ae54:	10000626 	beq	r2,zero,8111ae70 <vLoadDefaultETHConf+0x744>
									(*p_inteiro) = c;
8111ae58:	e0bffa17 	ldw	r2,-24(fp)
8111ae5c:	e0fff943 	ldbu	r3,-27(fp)
8111ae60:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ae64:	e0bffa17 	ldw	r2,-24(fp)
8111ae68:	10800044 	addi	r2,r2,1
8111ae6c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ae70:	e0bff947 	ldb	r2,-27(fp)
8111ae74:	10800ba0 	cmpeqi	r2,r2,46
8111ae78:	1000031e 	bne	r2,zero,8111ae88 <vLoadDefaultETHConf+0x75c>
8111ae7c:	e0bff947 	ldb	r2,-27(fp)
8111ae80:	10800ed8 	cmpnei	r2,r2,59
8111ae84:	103fe81e 	bne	r2,zero,8111ae28 <__reset+0xfb0fae28>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ae88:	e0bffa17 	ldw	r2,-24(fp)
8111ae8c:	00c00284 	movi	r3,10
8111ae90:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
8111ae94:	e0bff903 	ldbu	r2,-28(fp)
8111ae98:	108000e8 	cmpgeui	r2,r2,3
8111ae9c:	1000021e 	bne	r2,zero,8111aea8 <vLoadDefaultETHConf+0x77c>
8111aea0:	e43ff903 	ldbu	r16,-28(fp)
8111aea4:	00000106 	br	8111aeac <vLoadDefaultETHConf+0x780>
8111aea8:	040000c4 	movi	r16,3
8111aeac:	e0bffd04 	addi	r2,fp,-12
8111aeb0:	1009883a 	mov	r4,r2
8111aeb4:	11227d00 	call	811227d0 <atoi>
8111aeb8:	1007883a 	mov	r3,r2
8111aebc:	00a045b4 	movhi	r2,33046
8111aec0:	109ff104 	addi	r2,r2,32708
8111aec4:	1405883a 	add	r2,r2,r16
8111aec8:	10800304 	addi	r2,r2,12
8111aecc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111aed0:	e0bffd04 	addi	r2,fp,-12
8111aed4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111aed8:	e0bff903 	ldbu	r2,-28(fp)
8111aedc:	10800044 	addi	r2,r2,1
8111aee0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111aee4:	e0bff947 	ldb	r2,-27(fp)
8111aee8:	10800ed8 	cmpnei	r2,r2,59
8111aeec:	103fce1e 	bne	r2,zero,8111ae28 <__reset+0xfb0fae28>

						break;						
8111aef0:	00002906 	br	8111af98 <vLoadDefaultETHConf+0x86c>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111aef4:	e0bffc0f 	ldh	r2,-16(fp)
8111aef8:	1009883a 	mov	r4,r2
8111aefc:	111ff980 	call	8111ff98 <siCloseFile>
8111af00:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
8111af04:	e0bffb17 	ldw	r2,-20(fp)
8111af08:	10000d1e 	bne	r2,zero,8111af40 <vLoadDefaultETHConf+0x814>
							#if DEBUG_ON
							if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111af0c:	00a045b4 	movhi	r2,33046
8111af10:	109fe204 	addi	r2,r2,32648
8111af14:	10800d8b 	ldhu	r2,54(r2)
8111af18:	10bfffcc 	andi	r2,r2,65535
8111af1c:	10800228 	cmpgeui	r2,r2,8
8111af20:	1000071e 	bne	r2,zero,8111af40 <vLoadDefaultETHConf+0x814>
								debug(fp,"SDCard: Can't close the file.\n");
8111af24:	d0a06217 	ldw	r2,-32376(gp)
8111af28:	100f883a 	mov	r7,r2
8111af2c:	01800784 	movi	r6,30
8111af30:	01400044 	movi	r5,1
8111af34:	01204574 	movhi	r4,33045
8111af38:	213f9b04 	addi	r4,r4,-404
8111af3c:	1122fc80 	call	81122fc8 <fwrite>
							}
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111af40:	00800044 	movi	r2,1
8111af44:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
8111af48:	00800044 	movi	r2,1
8111af4c:	e0bff715 	stw	r2,-36(fp)
						break;
8111af50:	00001106 	br	8111af98 <vLoadDefaultETHConf+0x86c>
					default:
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111af54:	00a045b4 	movhi	r2,33046
8111af58:	109fe204 	addi	r2,r2,32648
8111af5c:	10800d8b 	ldhu	r2,54(r2)
8111af60:	10bfffcc 	andi	r2,r2,65535
8111af64:	10800228 	cmpgeui	r2,r2,8
8111af68:	10000a1e 	bne	r2,zero,8111af94 <vLoadDefaultETHConf+0x868>
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111af6c:	d0a06217 	ldw	r2,-32376(gp)
8111af70:	100f883a 	mov	r7,r2
8111af74:	01800844 	movi	r6,33
8111af78:	01400044 	movi	r5,1
8111af7c:	01204574 	movhi	r4,33045
8111af80:	213fa304 	addi	r4,r4,-372
8111af84:	1122fc80 	call	81122fc8 <fwrite>
						}
						#endif
						break;
8111af88:	00000206 	br	8111af94 <vLoadDefaultETHConf+0x868>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111af8c:	0001883a 	nop
8111af90:	00000106 	br	8111af98 <vLoadDefaultETHConf+0x86c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
							fprintf(fp,"SDCard: Problem with the parser.\n");
						}
						#endif
						break;
8111af94:	0001883a 	nop
				}
			} while ( bEOF == FALSE );
8111af98:	e0bff817 	ldw	r2,-32(fp)
8111af9c:	103e0126 	beq	r2,zero,8111a7a4 <__reset+0xfb0fa7a4>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111afa0:	00001c06 	br	8111b014 <vLoadDefaultETHConf+0x8e8>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111afa4:	00a045b4 	movhi	r2,33046
8111afa8:	109fe204 	addi	r2,r2,32648
8111afac:	10800d8b 	ldhu	r2,54(r2)
8111afb0:	10bfffcc 	andi	r2,r2,65535
8111afb4:	10800228 	cmpgeui	r2,r2,8
8111afb8:	1000161e 	bne	r2,zero,8111b014 <vLoadDefaultETHConf+0x8e8>
				fprintf(fp,"SDCard: File not found.\n");
8111afbc:	d0a06217 	ldw	r2,-32376(gp)
8111afc0:	100f883a 	mov	r7,r2
8111afc4:	01800604 	movi	r6,24
8111afc8:	01400044 	movi	r5,1
8111afcc:	01204574 	movhi	r4,33045
8111afd0:	213fac04 	addi	r4,r4,-336
8111afd4:	1122fc80 	call	81122fc8 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111afd8:	00000e06 	br	8111b014 <vLoadDefaultETHConf+0x8e8>
			}
			#endif
		}
	} else {
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111afdc:	00a045b4 	movhi	r2,33046
8111afe0:	109fe204 	addi	r2,r2,32648
8111afe4:	10800d8b 	ldhu	r2,54(r2)
8111afe8:	10bfffcc 	andi	r2,r2,65535
8111afec:	10800228 	cmpgeui	r2,r2,8
8111aff0:	1000091e 	bne	r2,zero,8111b018 <vLoadDefaultETHConf+0x8ec>
			fprintf(fp,"SDCard: No SDCard.\n");
8111aff4:	d0a06217 	ldw	r2,-32376(gp)
8111aff8:	100f883a 	mov	r7,r2
8111affc:	018004c4 	movi	r6,19
8111b000:	01400044 	movi	r5,1
8111b004:	01204574 	movhi	r4,33045
8111b008:	213fb304 	addi	r4,r4,-308
8111b00c:	1122fc80 	call	81122fc8 <fwrite>
8111b010:	00000106 	br	8111b018 <vLoadDefaultETHConf+0x8ec>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
8111b014:	0001883a 	nop
			fprintf(fp,"SDCard: No SDCard.\n");
		}
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
8111b018:	e0bff717 	ldw	r2,-36(fp)
8111b01c:	10004c1e 	bne	r2,zero,8111b150 <vLoadDefaultETHConf+0xa24>
		xConfEth.siPortPUS = 17000;
8111b020:	00a045b4 	movhi	r2,33046
8111b024:	109ff104 	addi	r2,r2,32708
8111b028:	00d09a04 	movi	r3,17000
8111b02c:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
8111b030:	00a045b4 	movhi	r2,33046
8111b034:	109ff104 	addi	r2,r2,32708
8111b038:	00fff004 	movi	r3,-64
8111b03c:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
8111b040:	00a045b4 	movhi	r2,33046
8111b044:	109ff104 	addi	r2,r2,32708
8111b048:	00ffea04 	movi	r3,-88
8111b04c:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
8111b050:	00a045b4 	movhi	r2,33046
8111b054:	109ff104 	addi	r2,r2,32708
8111b058:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
8111b05c:	00a045b4 	movhi	r2,33046
8111b060:	109ff104 	addi	r2,r2,32708
8111b064:	00c00144 	movi	r3,5
8111b068:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
8111b06c:	00a045b4 	movhi	r2,33046
8111b070:	109ff104 	addi	r2,r2,32708
8111b074:	00fff004 	movi	r3,-64
8111b078:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
8111b07c:	00a045b4 	movhi	r2,33046
8111b080:	109ff104 	addi	r2,r2,32708
8111b084:	00ffea04 	movi	r3,-88
8111b088:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
8111b08c:	00a045b4 	movhi	r2,33046
8111b090:	109ff104 	addi	r2,r2,32708
8111b094:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
8111b098:	00a045b4 	movhi	r2,33046
8111b09c:	109ff104 	addi	r2,r2,32708
8111b0a0:	00c00044 	movi	r3,1
8111b0a4:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
8111b0a8:	00a045b4 	movhi	r2,33046
8111b0ac:	109ff104 	addi	r2,r2,32708
8111b0b0:	00ffffc4 	movi	r3,-1
8111b0b4:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
8111b0b8:	00a045b4 	movhi	r2,33046
8111b0bc:	109ff104 	addi	r2,r2,32708
8111b0c0:	00ffffc4 	movi	r3,-1
8111b0c4:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
8111b0c8:	00a045b4 	movhi	r2,33046
8111b0cc:	109ff104 	addi	r2,r2,32708
8111b0d0:	00ffffc4 	movi	r3,-1
8111b0d4:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
8111b0d8:	00a045b4 	movhi	r2,33046
8111b0dc:	109ff104 	addi	r2,r2,32708
8111b0e0:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
8111b0e4:	00a045b4 	movhi	r2,33046
8111b0e8:	109ff104 	addi	r2,r2,32708
8111b0ec:	00ffff04 	movi	r3,-4
8111b0f0:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
8111b0f4:	00a045b4 	movhi	r2,33046
8111b0f8:	109ff104 	addi	r2,r2,32708
8111b0fc:	00fffdc4 	movi	r3,-9
8111b100:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
8111b104:	00a045b4 	movhi	r2,33046
8111b108:	109ff104 	addi	r2,r2,32708
8111b10c:	00c018c4 	movi	r3,99
8111b110:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
8111b114:	00a045b4 	movhi	r2,33046
8111b118:	109ff104 	addi	r2,r2,32708
8111b11c:	00c01344 	movi	r3,77
8111b120:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
8111b124:	00a045b4 	movhi	r2,33046
8111b128:	109ff104 	addi	r2,r2,32708
8111b12c:	00c007c4 	movi	r3,31
8111b130:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
8111b134:	00a045b4 	movhi	r2,33046
8111b138:	109ff104 	addi	r2,r2,32708
8111b13c:	00c01084 	movi	r3,66
8111b140:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
8111b144:	00a045b4 	movhi	r2,33046
8111b148:	109ff104 	addi	r2,r2,32708
8111b14c:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
8111b150:	e0bff717 	ldw	r2,-36(fp)
}
8111b154:	e6ffff04 	addi	sp,fp,-4
8111b158:	dfc00217 	ldw	ra,8(sp)
8111b15c:	df000117 	ldw	fp,4(sp)
8111b160:	dc000017 	ldw	r16,0(sp)
8111b164:	dec00304 	addi	sp,sp,12
8111b168:	f800283a 	ret

8111b16c <vShowEthConfig>:

#if DEBUG_ON
	void vShowEthConfig( void ) {
8111b16c:	defff004 	addi	sp,sp,-64
8111b170:	de00012e 	bgeu	sp,et,8111b178 <vShowEthConfig+0xc>
8111b174:	003b68fa 	trap	3
8111b178:	dfc00f15 	stw	ra,60(sp)
8111b17c:	df000e15 	stw	fp,56(sp)
8111b180:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
8111b184:	d0a06217 	ldw	r2,-32376(gp)
8111b188:	100f883a 	mov	r7,r2
8111b18c:	018007c4 	movi	r6,31
8111b190:	01400044 	movi	r5,1
8111b194:	01204574 	movhi	r4,33045
8111b198:	213fb804 	addi	r4,r4,-288
8111b19c:	1122fc80 	call	81122fc8 <fwrite>

		memset(buffer,0,40);
8111b1a0:	01800a04 	movi	r6,40
8111b1a4:	000b883a 	mov	r5,zero
8111b1a8:	e13ff604 	addi	r4,fp,-40
8111b1ac:	1123b2c0 	call	81123b2c <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
8111b1b0:	00a045b4 	movhi	r2,33046
8111b1b4:	109ff104 	addi	r2,r2,32708
8111b1b8:	10800403 	ldbu	r2,16(r2)
8111b1bc:	11803fcc 	andi	r6,r2,255
8111b1c0:	00a045b4 	movhi	r2,33046
8111b1c4:	109ff104 	addi	r2,r2,32708
8111b1c8:	10800443 	ldbu	r2,17(r2)
8111b1cc:	11c03fcc 	andi	r7,r2,255
8111b1d0:	00a045b4 	movhi	r2,33046
8111b1d4:	109ff104 	addi	r2,r2,32708
8111b1d8:	10800483 	ldbu	r2,18(r2)
8111b1dc:	10c03fcc 	andi	r3,r2,255
8111b1e0:	00a045b4 	movhi	r2,33046
8111b1e4:	109ff104 	addi	r2,r2,32708
8111b1e8:	108004c3 	ldbu	r2,19(r2)
8111b1ec:	11003fcc 	andi	r4,r2,255
8111b1f0:	00a045b4 	movhi	r2,33046
8111b1f4:	109ff104 	addi	r2,r2,32708
8111b1f8:	10800503 	ldbu	r2,20(r2)
8111b1fc:	11403fcc 	andi	r5,r2,255
8111b200:	00a045b4 	movhi	r2,33046
8111b204:	109ff104 	addi	r2,r2,32708
8111b208:	10800543 	ldbu	r2,21(r2)
8111b20c:	10803fcc 	andi	r2,r2,255
8111b210:	d8800315 	stw	r2,12(sp)
8111b214:	d9400215 	stw	r5,8(sp)
8111b218:	d9000115 	stw	r4,4(sp)
8111b21c:	d8c00015 	stw	r3,0(sp)
8111b220:	01604574 	movhi	r5,33045
8111b224:	297fc004 	addi	r5,r5,-256
8111b228:	e13ff604 	addi	r4,fp,-40
8111b22c:	11242400 	call	81124240 <sprintf>
		debug(fp, buffer );
8111b230:	d0a06217 	ldw	r2,-32376(gp)
8111b234:	e17ff604 	addi	r5,fp,-40
8111b238:	1009883a 	mov	r4,r2
8111b23c:	112292c0 	call	8112292c <fprintf>

		memset(buffer,0,40);
8111b240:	01800a04 	movi	r6,40
8111b244:	000b883a 	mov	r5,zero
8111b248:	e13ff604 	addi	r4,fp,-40
8111b24c:	1123b2c0 	call	81123b2c <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
8111b250:	00a045b4 	movhi	r2,33046
8111b254:	109ff104 	addi	r2,r2,32708
8111b258:	10800003 	ldbu	r2,0(r2)
8111b25c:	11003fcc 	andi	r4,r2,255
8111b260:	00a045b4 	movhi	r2,33046
8111b264:	109ff104 	addi	r2,r2,32708
8111b268:	10800043 	ldbu	r2,1(r2)
8111b26c:	11403fcc 	andi	r5,r2,255
8111b270:	00a045b4 	movhi	r2,33046
8111b274:	109ff104 	addi	r2,r2,32708
8111b278:	10800083 	ldbu	r2,2(r2)
8111b27c:	10c03fcc 	andi	r3,r2,255
8111b280:	00a045b4 	movhi	r2,33046
8111b284:	109ff104 	addi	r2,r2,32708
8111b288:	108000c3 	ldbu	r2,3(r2)
8111b28c:	10803fcc 	andi	r2,r2,255
8111b290:	d8800115 	stw	r2,4(sp)
8111b294:	d8c00015 	stw	r3,0(sp)
8111b298:	280f883a 	mov	r7,r5
8111b29c:	200d883a 	mov	r6,r4
8111b2a0:	01604574 	movhi	r5,33045
8111b2a4:	297fc904 	addi	r5,r5,-220
8111b2a8:	e13ff604 	addi	r4,fp,-40
8111b2ac:	11242400 	call	81124240 <sprintf>
		debug(fp, buffer );
8111b2b0:	d0a06217 	ldw	r2,-32376(gp)
8111b2b4:	e17ff604 	addi	r5,fp,-40
8111b2b8:	1009883a 	mov	r4,r2
8111b2bc:	112292c0 	call	8112292c <fprintf>

		memset(buffer,0,40);
8111b2c0:	01800a04 	movi	r6,40
8111b2c4:	000b883a 	mov	r5,zero
8111b2c8:	e13ff604 	addi	r4,fp,-40
8111b2cc:	1123b2c0 	call	81123b2c <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
8111b2d0:	00a045b4 	movhi	r2,33046
8111b2d4:	109ff104 	addi	r2,r2,32708
8111b2d8:	10800103 	ldbu	r2,4(r2)
8111b2dc:	11003fcc 	andi	r4,r2,255
8111b2e0:	00a045b4 	movhi	r2,33046
8111b2e4:	109ff104 	addi	r2,r2,32708
8111b2e8:	10800143 	ldbu	r2,5(r2)
8111b2ec:	11403fcc 	andi	r5,r2,255
8111b2f0:	00a045b4 	movhi	r2,33046
8111b2f4:	109ff104 	addi	r2,r2,32708
8111b2f8:	10800183 	ldbu	r2,6(r2)
8111b2fc:	10c03fcc 	andi	r3,r2,255
8111b300:	00a045b4 	movhi	r2,33046
8111b304:	109ff104 	addi	r2,r2,32708
8111b308:	108001c3 	ldbu	r2,7(r2)
8111b30c:	10803fcc 	andi	r2,r2,255
8111b310:	d8800115 	stw	r2,4(sp)
8111b314:	d8c00015 	stw	r3,0(sp)
8111b318:	280f883a 	mov	r7,r5
8111b31c:	200d883a 	mov	r6,r4
8111b320:	01604574 	movhi	r5,33045
8111b324:	297fcf04 	addi	r5,r5,-196
8111b328:	e13ff604 	addi	r4,fp,-40
8111b32c:	11242400 	call	81124240 <sprintf>
		debug(fp, buffer );
8111b330:	d0a06217 	ldw	r2,-32376(gp)
8111b334:	e17ff604 	addi	r5,fp,-40
8111b338:	1009883a 	mov	r4,r2
8111b33c:	112292c0 	call	8112292c <fprintf>

		memset(buffer,0,40);
8111b340:	01800a04 	movi	r6,40
8111b344:	000b883a 	mov	r5,zero
8111b348:	e13ff604 	addi	r4,fp,-40
8111b34c:	1123b2c0 	call	81123b2c <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
8111b350:	00a045b4 	movhi	r2,33046
8111b354:	109ff104 	addi	r2,r2,32708
8111b358:	10800203 	ldbu	r2,8(r2)
8111b35c:	11003fcc 	andi	r4,r2,255
8111b360:	00a045b4 	movhi	r2,33046
8111b364:	109ff104 	addi	r2,r2,32708
8111b368:	10800243 	ldbu	r2,9(r2)
8111b36c:	11403fcc 	andi	r5,r2,255
8111b370:	00a045b4 	movhi	r2,33046
8111b374:	109ff104 	addi	r2,r2,32708
8111b378:	10800283 	ldbu	r2,10(r2)
8111b37c:	10c03fcc 	andi	r3,r2,255
8111b380:	00a045b4 	movhi	r2,33046
8111b384:	109ff104 	addi	r2,r2,32708
8111b388:	108002c3 	ldbu	r2,11(r2)
8111b38c:	10803fcc 	andi	r2,r2,255
8111b390:	d8800115 	stw	r2,4(sp)
8111b394:	d8c00015 	stw	r3,0(sp)
8111b398:	280f883a 	mov	r7,r5
8111b39c:	200d883a 	mov	r6,r4
8111b3a0:	01604574 	movhi	r5,33045
8111b3a4:	297fd604 	addi	r5,r5,-168
8111b3a8:	e13ff604 	addi	r4,fp,-40
8111b3ac:	11242400 	call	81124240 <sprintf>
		debug(fp, buffer );
8111b3b0:	d0a06217 	ldw	r2,-32376(gp)
8111b3b4:	e17ff604 	addi	r5,fp,-40
8111b3b8:	1009883a 	mov	r4,r2
8111b3bc:	112292c0 	call	8112292c <fprintf>

		memset(buffer,0,40);
8111b3c0:	01800a04 	movi	r6,40
8111b3c4:	000b883a 	mov	r5,zero
8111b3c8:	e13ff604 	addi	r4,fp,-40
8111b3cc:	1123b2c0 	call	81123b2c <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
8111b3d0:	00a045b4 	movhi	r2,33046
8111b3d4:	109ff104 	addi	r2,r2,32708
8111b3d8:	10800303 	ldbu	r2,12(r2)
8111b3dc:	11003fcc 	andi	r4,r2,255
8111b3e0:	00a045b4 	movhi	r2,33046
8111b3e4:	109ff104 	addi	r2,r2,32708
8111b3e8:	10800343 	ldbu	r2,13(r2)
8111b3ec:	11403fcc 	andi	r5,r2,255
8111b3f0:	00a045b4 	movhi	r2,33046
8111b3f4:	109ff104 	addi	r2,r2,32708
8111b3f8:	10800383 	ldbu	r2,14(r2)
8111b3fc:	10c03fcc 	andi	r3,r2,255
8111b400:	00a045b4 	movhi	r2,33046
8111b404:	109ff104 	addi	r2,r2,32708
8111b408:	108003c3 	ldbu	r2,15(r2)
8111b40c:	10803fcc 	andi	r2,r2,255
8111b410:	d8800115 	stw	r2,4(sp)
8111b414:	d8c00015 	stw	r3,0(sp)
8111b418:	280f883a 	mov	r7,r5
8111b41c:	200d883a 	mov	r6,r4
8111b420:	01604574 	movhi	r5,33045
8111b424:	297fdd04 	addi	r5,r5,-140
8111b428:	e13ff604 	addi	r4,fp,-40
8111b42c:	11242400 	call	81124240 <sprintf>
		debug(fp, buffer );
8111b430:	d0a06217 	ldw	r2,-32376(gp)
8111b434:	e17ff604 	addi	r5,fp,-40
8111b438:	1009883a 	mov	r4,r2
8111b43c:	112292c0 	call	8112292c <fprintf>

		memset(buffer,0,40);
8111b440:	01800a04 	movi	r6,40
8111b444:	000b883a 	mov	r5,zero
8111b448:	e13ff604 	addi	r4,fp,-40
8111b44c:	1123b2c0 	call	81123b2c <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
8111b450:	00a045b4 	movhi	r2,33046
8111b454:	109ff104 	addi	r2,r2,32708
8111b458:	1080058b 	ldhu	r2,22(r2)
8111b45c:	10bfffcc 	andi	r2,r2,65535
8111b460:	100d883a 	mov	r6,r2
8111b464:	01604574 	movhi	r5,33045
8111b468:	297fe404 	addi	r5,r5,-112
8111b46c:	e13ff604 	addi	r4,fp,-40
8111b470:	11242400 	call	81124240 <sprintf>
		debug(fp, buffer );
8111b474:	d0a06217 	ldw	r2,-32376(gp)
8111b478:	e17ff604 	addi	r5,fp,-40
8111b47c:	1009883a 	mov	r4,r2
8111b480:	112292c0 	call	8112292c <fprintf>

	}
8111b484:	0001883a 	nop
8111b488:	e037883a 	mov	sp,fp
8111b48c:	dfc00117 	ldw	ra,4(sp)
8111b490:	df000017 	ldw	fp,0(sp)
8111b494:	dec00204 	addi	sp,sp,8
8111b498:	f800283a 	ret

8111b49c <vLoadDebugConfs>:
#endif




bool vLoadDebugConfs( void ){
8111b49c:	defff004 	addi	sp,sp,-64
8111b4a0:	de00012e 	bgeu	sp,et,8111b4a8 <vLoadDebugConfs+0xc>
8111b4a4:	003b68fa 	trap	3
8111b4a8:	dfc00f15 	stw	ra,60(sp)
8111b4ac:	df000e15 	stw	fp,56(sp)
8111b4b0:	df000e04 	addi	fp,sp,56
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8111b4b4:	e03ff215 	stw	zero,-56(fp)
	bool bEOF = FALSE;
8111b4b8:	e03ff315 	stw	zero,-52(fp)
	bool close = FALSE;
8111b4bc:	e03ff615 	stw	zero,-40(fp)
	char c, *p_inteiro;
	char inteiro[8];
	char inteiroll[24];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8111b4c0:	d0a07617 	ldw	r2,-32296(gp)
8111b4c4:	10800058 	cmpnei	r2,r2,1
8111b4c8:	1003631e 	bne	r2,zero,8111c258 <vLoadDebugConfs+0xdbc>
8111b4cc:	111fe040 	call	8111fe04 <bSDcardIsPresent>
8111b4d0:	10036126 	beq	r2,zero,8111c258 <vLoadDebugConfs+0xdbc>
8111b4d4:	111fe340 	call	8111fe34 <bSDcardFAT16Check>
8111b4d8:	10035f26 	beq	r2,zero,8111c258 <vLoadDebugConfs+0xdbc>

		siFile = siOpenFile( DEBUG_FILE_NAME );
8111b4dc:	01204574 	movhi	r4,33045
8111b4e0:	213fe804 	addi	r4,r4,-96
8111b4e4:	111ff5c0 	call	8111ff5c <siOpenFile>
8111b4e8:	e0bff70d 	sth	r2,-36(fp)

		if ( siFile >= 0 ){
8111b4ec:	e0bff70f 	ldh	r2,-36(fp)
8111b4f0:	10035116 	blt	r2,zero,8111c238 <vLoadDebugConfs+0xd9c>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8111b4f4:	e0bff804 	addi	r2,fp,-32
8111b4f8:	01800204 	movi	r6,8
8111b4fc:	01400284 	movi	r5,10
8111b500:	1009883a 	mov	r4,r2
8111b504:	1123b2c0 	call	81123b2c <memset>
			memset( &(inteiroll) , 10 , sizeof( inteiroll ) );
8111b508:	e0bffa04 	addi	r2,fp,-24
8111b50c:	01800604 	movi	r6,24
8111b510:	01400284 	movi	r5,10
8111b514:	1009883a 	mov	r4,r2
8111b518:	1123b2c0 	call	81123b2c <memset>
			p_inteiro = inteiro;
8111b51c:	e0bff804 	addi	r2,fp,-32
8111b520:	e0bff515 	stw	r2,-44(fp)

			do {
				c = cGetNextChar(siFile);
8111b524:	e0bff70f 	ldh	r2,-36(fp)
8111b528:	1009883a 	mov	r4,r2
8111b52c:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111b530:	e0bff445 	stb	r2,-47(fp)
				//printf("%c \n", c);
				switch (c) {
8111b534:	e0bff447 	ldb	r2,-47(fp)
8111b538:	10800084 	addi	r2,r2,2
8111b53c:	10c01768 	cmpgeui	r3,r2,93
8111b540:	1803311e 	bne	r3,zero,8111c208 <vLoadDebugConfs+0xd6c>
8111b544:	100690ba 	slli	r3,r2,2
8111b548:	00a044b4 	movhi	r2,33042
8111b54c:	10ad5704 	addi	r2,r2,-19108
8111b550:	1885883a 	add	r2,r3,r2
8111b554:	10800017 	ldw	r2,0(r2)
8111b558:	1000683a 	jmp	r2
8111b55c:	8111b710 	cmplti	r4,r16,18140
8111b560:	8111b704 	addi	r4,r16,18140
8111b564:	8111c208 	cmpgei	r4,r16,18184
8111b568:	8111c208 	cmpgei	r4,r16,18184
8111b56c:	8111c208 	cmpgei	r4,r16,18184
8111b570:	8111c208 	cmpgei	r4,r16,18184
8111b574:	8111c208 	cmpgei	r4,r16,18184
8111b578:	8111c208 	cmpgei	r4,r16,18184
8111b57c:	8111c208 	cmpgei	r4,r16,18184
8111b580:	8111c208 	cmpgei	r4,r16,18184
8111b584:	8111c208 	cmpgei	r4,r16,18184
8111b588:	8111c208 	cmpgei	r4,r16,18184
8111b58c:	8111c228 	cmpgeui	r4,r16,18184
8111b590:	8111c208 	cmpgei	r4,r16,18184
8111b594:	8111c208 	cmpgei	r4,r16,18184
8111b598:	8111c228 	cmpgeui	r4,r16,18184
8111b59c:	8111c208 	cmpgei	r4,r16,18184
8111b5a0:	8111c208 	cmpgei	r4,r16,18184
8111b5a4:	8111c208 	cmpgei	r4,r16,18184
8111b5a8:	8111c208 	cmpgei	r4,r16,18184
8111b5ac:	8111c208 	cmpgei	r4,r16,18184
8111b5b0:	8111c208 	cmpgei	r4,r16,18184
8111b5b4:	8111c208 	cmpgei	r4,r16,18184
8111b5b8:	8111c208 	cmpgei	r4,r16,18184
8111b5bc:	8111c208 	cmpgei	r4,r16,18184
8111b5c0:	8111c208 	cmpgei	r4,r16,18184
8111b5c4:	8111c208 	cmpgei	r4,r16,18184
8111b5c8:	8111c208 	cmpgei	r4,r16,18184
8111b5cc:	8111c208 	cmpgei	r4,r16,18184
8111b5d0:	8111c208 	cmpgei	r4,r16,18184
8111b5d4:	8111c208 	cmpgei	r4,r16,18184
8111b5d8:	8111c208 	cmpgei	r4,r16,18184
8111b5dc:	8111c208 	cmpgei	r4,r16,18184
8111b5e0:	8111c208 	cmpgei	r4,r16,18184
8111b5e4:	8111c228 	cmpgeui	r4,r16,18184
8111b5e8:	8111c208 	cmpgei	r4,r16,18184
8111b5ec:	8111c208 	cmpgei	r4,r16,18184
8111b5f0:	8111c208 	cmpgei	r4,r16,18184
8111b5f4:	8111c208 	cmpgei	r4,r16,18184
8111b5f8:	8111c208 	cmpgei	r4,r16,18184
8111b5fc:	8111c208 	cmpgei	r4,r16,18184
8111b600:	8111b6d0 	cmplti	r4,r16,18139
8111b604:	8111c208 	cmpgei	r4,r16,18184
8111b608:	8111c208 	cmpgei	r4,r16,18184
8111b60c:	8111c208 	cmpgei	r4,r16,18184
8111b610:	8111c208 	cmpgei	r4,r16,18184
8111b614:	8111c208 	cmpgei	r4,r16,18184
8111b618:	8111c208 	cmpgei	r4,r16,18184
8111b61c:	8111c208 	cmpgei	r4,r16,18184
8111b620:	8111c208 	cmpgei	r4,r16,18184
8111b624:	8111c208 	cmpgei	r4,r16,18184
8111b628:	8111c208 	cmpgei	r4,r16,18184
8111b62c:	8111c208 	cmpgei	r4,r16,18184
8111b630:	8111c208 	cmpgei	r4,r16,18184
8111b634:	8111c208 	cmpgei	r4,r16,18184
8111b638:	8111c208 	cmpgei	r4,r16,18184
8111b63c:	8111c208 	cmpgei	r4,r16,18184
8111b640:	8111c208 	cmpgei	r4,r16,18184
8111b644:	8111c208 	cmpgei	r4,r16,18184
8111b648:	8111c208 	cmpgei	r4,r16,18184
8111b64c:	8111c208 	cmpgei	r4,r16,18184
8111b650:	8111c208 	cmpgei	r4,r16,18184
8111b654:	8111c1c0 	call	88111c1c <__reset+0x20f1c1c>
8111b658:	8111c208 	cmpgei	r4,r16,18184
8111b65c:	8111c208 	cmpgei	r4,r16,18184
8111b660:	8111c208 	cmpgei	r4,r16,18184
8111b664:	8111c208 	cmpgei	r4,r16,18184
8111b668:	8111b9f8 	rdprs	r4,r16,18151
8111b66c:	8111be50 	cmplti	r4,r16,18169
8111b670:	8111bc08 	cmpgei	r4,r16,18160
8111b674:	8111c208 	cmpgei	r4,r16,18184
8111b678:	8111c208 	cmpgei	r4,r16,18184
8111b67c:	8111bed8 	cmpnei	r4,r16,18171
8111b680:	8111c208 	cmpgei	r4,r16,18184
8111b684:	8111c208 	cmpgei	r4,r16,18184
8111b688:	8111c208 	cmpgei	r4,r16,18184
8111b68c:	8111bdc8 	cmpgei	r4,r16,18167
8111b690:	8111bcb8 	rdprs	r4,r16,18162
8111b694:	8111baa8 	cmpgeui	r4,r16,18154
8111b698:	8111bd40 	call	88111bd4 <__reset+0x20f1bd4>
8111b69c:	8111b898 	cmpnei	r4,r16,18146
8111b6a0:	8111bb58 	cmpnei	r4,r16,18157
8111b6a4:	8111b7e8 	cmpgeui	r4,r16,18143
8111b6a8:	8111bf60 	cmpeqi	r4,r16,18173
8111b6ac:	8111b948 	cmpgei	r4,r16,18149
8111b6b0:	8111b738 	rdprs	r4,r16,18140
8111b6b4:	8111c070 	cmpltui	r4,r16,18177
8111b6b8:	8111c208 	cmpgei	r4,r16,18184
8111b6bc:	8111c208 	cmpgei	r4,r16,18184
8111b6c0:	8111c208 	cmpgei	r4,r16,18184
8111b6c4:	8111c208 	cmpgei	r4,r16,18184
8111b6c8:	8111bfe8 	cmpgeui	r4,r16,18175
8111b6cc:	8111c118 	cmpnei	r4,r16,18180
					case 39:// single quote '
						c = cGetNextChar(siFile);
8111b6d0:	e0bff70f 	ldh	r2,-36(fp)
8111b6d4:	1009883a 	mov	r4,r2
8111b6d8:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111b6dc:	e0bff445 	stb	r2,-47(fp)
						while ( c != 39 ){
8111b6e0:	00000406 	br	8111b6f4 <vLoadDebugConfs+0x258>
							c = cGetNextChar(siFile);
8111b6e4:	e0bff70f 	ldh	r2,-36(fp)
8111b6e8:	1009883a 	mov	r4,r2
8111b6ec:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111b6f0:	e0bff445 	stb	r2,-47(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111b6f4:	e0bff447 	ldb	r2,-47(fp)
8111b6f8:	108009d8 	cmpnei	r2,r2,39
8111b6fc:	103ff91e 	bne	r2,zero,8111b6e4 <__reset+0xfb0fb6e4>
							c = cGetNextChar(siFile);
						}
						break;
8111b700:	0002ca06 	br	8111c22c <vLoadDebugConfs+0xd90>
					case -1: 	//EOF
						bEOF = TRUE;
8111b704:	00800044 	movi	r2,1
8111b708:	e0bff315 	stw	r2,-52(fp)
						break;
8111b70c:	0002c706 	br	8111c22c <vLoadDebugConfs+0xd90>
					case -2: 	//EOF
						#if DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
8111b710:	d0a06217 	ldw	r2,-32376(gp)
8111b714:	100f883a 	mov	r7,r2
8111b718:	018006c4 	movi	r6,27
8111b71c:	01400044 	movi	r5,1
8111b720:	01204574 	movhi	r4,33045
8111b724:	213f9404 	addi	r4,r4,-432
8111b728:	1122fc80 	call	81122fc8 <fwrite>
						#endif
						bEOF = TRUE;
8111b72c:	00800044 	movi	r2,1
8111b730:	e0bff315 	stw	r2,-52(fp)
						break;
8111b734:	0002bd06 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;

					case 'S':
						ucParser = 0;
8111b738:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b73c:	e0bff70f 	ldh	r2,-36(fp)
8111b740:	1009883a 	mov	r4,r2
8111b744:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111b748:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111b74c:	d0e00317 	ldw	r3,-32756(gp)
8111b750:	e0bff447 	ldb	r2,-47(fp)
8111b754:	10800044 	addi	r2,r2,1
8111b758:	1885883a 	add	r2,r3,r2
8111b75c:	10800003 	ldbu	r2,0(r2)
8111b760:	10803fcc 	andi	r2,r2,255
8111b764:	1080010c 	andi	r2,r2,4
8111b768:	10000626 	beq	r2,zero,8111b784 <vLoadDebugConfs+0x2e8>
									(*p_inteiro) = c;
8111b76c:	e0bff517 	ldw	r2,-44(fp)
8111b770:	e0fff443 	ldbu	r3,-47(fp)
8111b774:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b778:	e0bff517 	ldw	r2,-44(fp)
8111b77c:	10800044 	addi	r2,r2,1
8111b780:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b784:	e0bff447 	ldb	r2,-47(fp)
8111b788:	10800ba0 	cmpeqi	r2,r2,46
8111b78c:	1000031e 	bne	r2,zero,8111b79c <vLoadDebugConfs+0x300>
8111b790:	e0bff447 	ldb	r2,-47(fp)
8111b794:	10800ed8 	cmpnei	r2,r2,59
8111b798:	103fe81e 	bne	r2,zero,8111b73c <__reset+0xfb0fb73c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b79c:	e0bff517 	ldw	r2,-44(fp)
8111b7a0:	00c00284 	movi	r3,10
8111b7a4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiSyncPeriod = atoi( inteiro );
8111b7a8:	e0bff804 	addi	r2,fp,-32
8111b7ac:	1009883a 	mov	r4,r2
8111b7b0:	11227d00 	call	811227d0 <atoi>
8111b7b4:	1007883a 	mov	r3,r2
8111b7b8:	00a045b4 	movhi	r2,33046
8111b7bc:	109fe204 	addi	r2,r2,32648
8111b7c0:	10c0068d 	sth	r3,26(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b7c4:	e0bff804 	addi	r2,fp,-32
8111b7c8:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111b7cc:	e0bff403 	ldbu	r2,-48(fp)
8111b7d0:	10800044 	addi	r2,r2,1
8111b7d4:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111b7d8:	e0bff447 	ldb	r2,-47(fp)
8111b7dc:	10800ed8 	cmpnei	r2,r2,59
8111b7e0:	103fd61e 	bne	r2,zero,8111b73c <__reset+0xfb0fb73c>

						break;
8111b7e4:	00029106 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'P':
						ucParser = 0;
8111b7e8:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b7ec:	e0bff70f 	ldh	r2,-36(fp)
8111b7f0:	1009883a 	mov	r4,r2
8111b7f4:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111b7f8:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111b7fc:	d0e00317 	ldw	r3,-32756(gp)
8111b800:	e0bff447 	ldb	r2,-47(fp)
8111b804:	10800044 	addi	r2,r2,1
8111b808:	1885883a 	add	r2,r3,r2
8111b80c:	10800003 	ldbu	r2,0(r2)
8111b810:	10803fcc 	andi	r2,r2,255
8111b814:	1080010c 	andi	r2,r2,4
8111b818:	10000626 	beq	r2,zero,8111b834 <vLoadDebugConfs+0x398>
									(*p_inteiro) = c;
8111b81c:	e0bff517 	ldw	r2,-44(fp)
8111b820:	e0fff443 	ldbu	r3,-47(fp)
8111b824:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b828:	e0bff517 	ldw	r2,-44(fp)
8111b82c:	10800044 	addi	r2,r2,1
8111b830:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b834:	e0bff447 	ldb	r2,-47(fp)
8111b838:	10800ba0 	cmpeqi	r2,r2,46
8111b83c:	1000031e 	bne	r2,zero,8111b84c <vLoadDebugConfs+0x3b0>
8111b840:	e0bff447 	ldb	r2,-47(fp)
8111b844:	10800ed8 	cmpnei	r2,r2,59
8111b848:	103fe81e 	bne	r2,zero,8111b7ec <__reset+0xfb0fb7ec>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b84c:	e0bff517 	ldw	r2,-44(fp)
8111b850:	00c00284 	movi	r3,10
8111b854:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiPreScanSerial = atoi( inteiro );
8111b858:	e0bff804 	addi	r2,fp,-32
8111b85c:	1009883a 	mov	r4,r2
8111b860:	11227d00 	call	811227d0 <atoi>
8111b864:	1007883a 	mov	r3,r2
8111b868:	00a045b4 	movhi	r2,33046
8111b86c:	109fe204 	addi	r2,r2,32648
8111b870:	10c0048d 	sth	r3,18(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b874:	e0bff804 	addi	r2,fp,-32
8111b878:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111b87c:	e0bff403 	ldbu	r2,-48(fp)
8111b880:	10800044 	addi	r2,r2,1
8111b884:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111b888:	e0bff447 	ldb	r2,-47(fp)
8111b88c:	10800ed8 	cmpnei	r2,r2,59
8111b890:	103fd61e 	bne	r2,zero,8111b7ec <__reset+0xfb0fb7ec>

						break;
8111b894:	00026506 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'N':
						ucParser = 0;
8111b898:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b89c:	e0bff70f 	ldh	r2,-36(fp)
8111b8a0:	1009883a 	mov	r4,r2
8111b8a4:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111b8a8:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111b8ac:	d0e00317 	ldw	r3,-32756(gp)
8111b8b0:	e0bff447 	ldb	r2,-47(fp)
8111b8b4:	10800044 	addi	r2,r2,1
8111b8b8:	1885883a 	add	r2,r3,r2
8111b8bc:	10800003 	ldbu	r2,0(r2)
8111b8c0:	10803fcc 	andi	r2,r2,255
8111b8c4:	1080010c 	andi	r2,r2,4
8111b8c8:	10000626 	beq	r2,zero,8111b8e4 <vLoadDebugConfs+0x448>
									(*p_inteiro) = c;
8111b8cc:	e0bff517 	ldw	r2,-44(fp)
8111b8d0:	e0fff443 	ldbu	r3,-47(fp)
8111b8d4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b8d8:	e0bff517 	ldw	r2,-44(fp)
8111b8dc:	10800044 	addi	r2,r2,1
8111b8e0:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b8e4:	e0bff447 	ldb	r2,-47(fp)
8111b8e8:	10800ba0 	cmpeqi	r2,r2,46
8111b8ec:	1000031e 	bne	r2,zero,8111b8fc <vLoadDebugConfs+0x460>
8111b8f0:	e0bff447 	ldb	r2,-47(fp)
8111b8f4:	10800ed8 	cmpnei	r2,r2,59
8111b8f8:	103fe81e 	bne	r2,zero,8111b89c <__reset+0xfb0fb89c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b8fc:	e0bff517 	ldw	r2,-44(fp)
8111b900:	00c00284 	movi	r3,10
8111b904:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOverScanSerial = atoi( inteiro );
8111b908:	e0bff804 	addi	r2,fp,-32
8111b90c:	1009883a 	mov	r4,r2
8111b910:	11227d00 	call	811227d0 <atoi>
8111b914:	1007883a 	mov	r3,r2
8111b918:	00a045b4 	movhi	r2,33046
8111b91c:	109fe204 	addi	r2,r2,32648
8111b920:	10c0040d 	sth	r3,16(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b924:	e0bff804 	addi	r2,fp,-32
8111b928:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111b92c:	e0bff403 	ldbu	r2,-48(fp)
8111b930:	10800044 	addi	r2,r2,1
8111b934:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111b938:	e0bff447 	ldb	r2,-47(fp)
8111b93c:	10800ed8 	cmpnei	r2,r2,59
8111b940:	103fd61e 	bne	r2,zero,8111b89c <__reset+0xfb0fb89c>

						break;
8111b944:	00023906 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'R':
						ucParser = 0;
8111b948:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b94c:	e0bff70f 	ldh	r2,-36(fp)
8111b950:	1009883a 	mov	r4,r2
8111b954:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111b958:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111b95c:	d0e00317 	ldw	r3,-32756(gp)
8111b960:	e0bff447 	ldb	r2,-47(fp)
8111b964:	10800044 	addi	r2,r2,1
8111b968:	1885883a 	add	r2,r3,r2
8111b96c:	10800003 	ldbu	r2,0(r2)
8111b970:	10803fcc 	andi	r2,r2,255
8111b974:	1080010c 	andi	r2,r2,4
8111b978:	10000626 	beq	r2,zero,8111b994 <vLoadDebugConfs+0x4f8>
									(*p_inteiro) = c;
8111b97c:	e0bff517 	ldw	r2,-44(fp)
8111b980:	e0fff443 	ldbu	r3,-47(fp)
8111b984:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111b988:	e0bff517 	ldw	r2,-44(fp)
8111b98c:	10800044 	addi	r2,r2,1
8111b990:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111b994:	e0bff447 	ldb	r2,-47(fp)
8111b998:	10800ba0 	cmpeqi	r2,r2,46
8111b99c:	1000031e 	bne	r2,zero,8111b9ac <vLoadDebugConfs+0x510>
8111b9a0:	e0bff447 	ldb	r2,-47(fp)
8111b9a4:	10800ed8 	cmpnei	r2,r2,59
8111b9a8:	103fe81e 	bne	r2,zero,8111b94c <__reset+0xfb0fb94c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b9ac:	e0bff517 	ldw	r2,-44(fp)
8111b9b0:	00c00284 	movi	r3,10
8111b9b4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucRmapKey = atoi( inteiro );
8111b9b8:	e0bff804 	addi	r2,fp,-32
8111b9bc:	1009883a 	mov	r4,r2
8111b9c0:	11227d00 	call	811227d0 <atoi>
8111b9c4:	1007883a 	mov	r3,r2
8111b9c8:	00a045b4 	movhi	r2,33046
8111b9cc:	109fe204 	addi	r2,r2,32648
8111b9d0:	10c00b0d 	sth	r3,44(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111b9d4:	e0bff804 	addi	r2,fp,-32
8111b9d8:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111b9dc:	e0bff403 	ldbu	r2,-48(fp)
8111b9e0:	10800044 	addi	r2,r2,1
8111b9e4:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111b9e8:	e0bff447 	ldb	r2,-47(fp)
8111b9ec:	10800ed8 	cmpnei	r2,r2,59
8111b9f0:	103fd61e 	bne	r2,zero,8111b94c <__reset+0xfb0fb94c>

						break;
8111b9f4:	00020d06 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'A':
						ucParser = 0;
8111b9f8:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111b9fc:	e0bff70f 	ldh	r2,-36(fp)
8111ba00:	1009883a 	mov	r4,r2
8111ba04:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111ba08:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111ba0c:	d0e00317 	ldw	r3,-32756(gp)
8111ba10:	e0bff447 	ldb	r2,-47(fp)
8111ba14:	10800044 	addi	r2,r2,1
8111ba18:	1885883a 	add	r2,r3,r2
8111ba1c:	10800003 	ldbu	r2,0(r2)
8111ba20:	10803fcc 	andi	r2,r2,255
8111ba24:	1080010c 	andi	r2,r2,4
8111ba28:	10000626 	beq	r2,zero,8111ba44 <vLoadDebugConfs+0x5a8>
									(*p_inteiro) = c;
8111ba2c:	e0bff517 	ldw	r2,-44(fp)
8111ba30:	e0fff443 	ldbu	r3,-47(fp)
8111ba34:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ba38:	e0bff517 	ldw	r2,-44(fp)
8111ba3c:	10800044 	addi	r2,r2,1
8111ba40:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ba44:	e0bff447 	ldb	r2,-47(fp)
8111ba48:	10800ba0 	cmpeqi	r2,r2,46
8111ba4c:	1000031e 	bne	r2,zero,8111ba5c <vLoadDebugConfs+0x5c0>
8111ba50:	e0bff447 	ldb	r2,-47(fp)
8111ba54:	10800ed8 	cmpnei	r2,r2,59
8111ba58:	103fe81e 	bne	r2,zero,8111b9fc <__reset+0xfb0fb9fc>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ba5c:	e0bff517 	ldw	r2,-44(fp)
8111ba60:	00c00284 	movi	r3,10
8111ba64:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucLogicalAddr = atoi( inteiro );
8111ba68:	e0bff804 	addi	r2,fp,-32
8111ba6c:	1009883a 	mov	r4,r2
8111ba70:	11227d00 	call	811227d0 <atoi>
8111ba74:	1007883a 	mov	r3,r2
8111ba78:	00a045b4 	movhi	r2,33046
8111ba7c:	109fe204 	addi	r2,r2,32648
8111ba80:	10c00b8d 	sth	r3,46(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111ba84:	e0bff804 	addi	r2,fp,-32
8111ba88:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111ba8c:	e0bff403 	ldbu	r2,-48(fp)
8111ba90:	10800044 	addi	r2,r2,1
8111ba94:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111ba98:	e0bff447 	ldb	r2,-47(fp)
8111ba9c:	10800ed8 	cmpnei	r2,r2,59
8111baa0:	103fd61e 	bne	r2,zero,8111b9fc <__reset+0xfb0fb9fc>

						break;
8111baa4:	0001e106 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'L':
						ucParser = 0;
8111baa8:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111baac:	e0bff70f 	ldh	r2,-36(fp)
8111bab0:	1009883a 	mov	r4,r2
8111bab4:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111bab8:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111babc:	d0e00317 	ldw	r3,-32756(gp)
8111bac0:	e0bff447 	ldb	r2,-47(fp)
8111bac4:	10800044 	addi	r2,r2,1
8111bac8:	1885883a 	add	r2,r3,r2
8111bacc:	10800003 	ldbu	r2,0(r2)
8111bad0:	10803fcc 	andi	r2,r2,255
8111bad4:	1080010c 	andi	r2,r2,4
8111bad8:	10000626 	beq	r2,zero,8111baf4 <vLoadDebugConfs+0x658>
									(*p_inteiro) = c;
8111badc:	e0bff517 	ldw	r2,-44(fp)
8111bae0:	e0fff443 	ldbu	r3,-47(fp)
8111bae4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111bae8:	e0bff517 	ldw	r2,-44(fp)
8111baec:	10800044 	addi	r2,r2,1
8111baf0:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111baf4:	e0bff447 	ldb	r2,-47(fp)
8111baf8:	10800ba0 	cmpeqi	r2,r2,46
8111bafc:	1000031e 	bne	r2,zero,8111bb0c <vLoadDebugConfs+0x670>
8111bb00:	e0bff447 	ldb	r2,-47(fp)
8111bb04:	10800ed8 	cmpnei	r2,r2,59
8111bb08:	103fe81e 	bne	r2,zero,8111baac <__reset+0xfb0fbaac>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bb0c:	e0bff517 	ldw	r2,-44(fp)
8111bb10:	00c00284 	movi	r3,10
8111bb14:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiRows = atoi( inteiro );
8111bb18:	e0bff804 	addi	r2,fp,-32
8111bb1c:	1009883a 	mov	r4,r2
8111bb20:	11227d00 	call	811227d0 <atoi>
8111bb24:	1007883a 	mov	r3,r2
8111bb28:	00a045b4 	movhi	r2,33046
8111bb2c:	109fe204 	addi	r2,r2,32648
8111bb30:	10c0060d 	sth	r3,24(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111bb34:	e0bff804 	addi	r2,fp,-32
8111bb38:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111bb3c:	e0bff403 	ldbu	r2,-48(fp)
8111bb40:	10800044 	addi	r2,r2,1
8111bb44:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111bb48:	e0bff447 	ldb	r2,-47(fp)
8111bb4c:	10800ed8 	cmpnei	r2,r2,59
8111bb50:	103fd61e 	bne	r2,zero,8111baac <__reset+0xfb0fbaac>

						break;
8111bb54:	0001b506 	br	8111c22c <vLoadDebugConfs+0xd90>

					case 'O':
						ucParser = 0;
8111bb58:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111bb5c:	e0bff70f 	ldh	r2,-36(fp)
8111bb60:	1009883a 	mov	r4,r2
8111bb64:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111bb68:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111bb6c:	d0e00317 	ldw	r3,-32756(gp)
8111bb70:	e0bff447 	ldb	r2,-47(fp)
8111bb74:	10800044 	addi	r2,r2,1
8111bb78:	1885883a 	add	r2,r3,r2
8111bb7c:	10800003 	ldbu	r2,0(r2)
8111bb80:	10803fcc 	andi	r2,r2,255
8111bb84:	1080010c 	andi	r2,r2,4
8111bb88:	10000626 	beq	r2,zero,8111bba4 <vLoadDebugConfs+0x708>
									(*p_inteiro) = c;
8111bb8c:	e0bff517 	ldw	r2,-44(fp)
8111bb90:	e0fff443 	ldbu	r3,-47(fp)
8111bb94:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111bb98:	e0bff517 	ldw	r2,-44(fp)
8111bb9c:	10800044 	addi	r2,r2,1
8111bba0:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111bba4:	e0bff447 	ldb	r2,-47(fp)
8111bba8:	10800ba0 	cmpeqi	r2,r2,46
8111bbac:	1000031e 	bne	r2,zero,8111bbbc <vLoadDebugConfs+0x720>
8111bbb0:	e0bff447 	ldb	r2,-47(fp)
8111bbb4:	10800ed8 	cmpnei	r2,r2,59
8111bbb8:	103fe81e 	bne	r2,zero,8111bb5c <__reset+0xfb0fbb5c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bbbc:	e0bff517 	ldw	r2,-44(fp)
8111bbc0:	00c00284 	movi	r3,10
8111bbc4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOLN = atoi( inteiro );
8111bbc8:	e0bff804 	addi	r2,fp,-32
8111bbcc:	1009883a 	mov	r4,r2
8111bbd0:	11227d00 	call	811227d0 <atoi>
8111bbd4:	1007883a 	mov	r3,r2
8111bbd8:	00a045b4 	movhi	r2,33046
8111bbdc:	109fe204 	addi	r2,r2,32648
8111bbe0:	10c0050d 	sth	r3,20(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111bbe4:	e0bff804 	addi	r2,fp,-32
8111bbe8:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111bbec:	e0bff403 	ldbu	r2,-48(fp)
8111bbf0:	10800044 	addi	r2,r2,1
8111bbf4:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111bbf8:	e0bff447 	ldb	r2,-47(fp)
8111bbfc:	10800ed8 	cmpnei	r2,r2,59
8111bc00:	103fd61e 	bne	r2,zero,8111bb5c <__reset+0xfb0fbb5c>

						break;
8111bc04:	00018906 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'C':
						ucParser = 0;
8111bc08:	e03ff405 	stb	zero,-48(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111bc0c:	e0bff70f 	ldh	r2,-36(fp)
8111bc10:	1009883a 	mov	r4,r2
8111bc14:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111bc18:	e0bff445 	stb	r2,-47(fp)
								if ( isdigit( c ) ) {
8111bc1c:	d0e00317 	ldw	r3,-32756(gp)
8111bc20:	e0bff447 	ldb	r2,-47(fp)
8111bc24:	10800044 	addi	r2,r2,1
8111bc28:	1885883a 	add	r2,r3,r2
8111bc2c:	10800003 	ldbu	r2,0(r2)
8111bc30:	10803fcc 	andi	r2,r2,255
8111bc34:	1080010c 	andi	r2,r2,4
8111bc38:	10000626 	beq	r2,zero,8111bc54 <vLoadDebugConfs+0x7b8>
									(*p_inteiro) = c;
8111bc3c:	e0bff517 	ldw	r2,-44(fp)
8111bc40:	e0fff443 	ldbu	r3,-47(fp)
8111bc44:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111bc48:	e0bff517 	ldw	r2,-44(fp)
8111bc4c:	10800044 	addi	r2,r2,1
8111bc50:	e0bff515 	stw	r2,-44(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111bc54:	e0bff447 	ldb	r2,-47(fp)
8111bc58:	10800ba0 	cmpeqi	r2,r2,46
8111bc5c:	1000031e 	bne	r2,zero,8111bc6c <vLoadDebugConfs+0x7d0>
8111bc60:	e0bff447 	ldb	r2,-47(fp)
8111bc64:	10800ed8 	cmpnei	r2,r2,59
8111bc68:	103fe81e 	bne	r2,zero,8111bc0c <__reset+0xfb0fbc0c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bc6c:	e0bff517 	ldw	r2,-44(fp)
8111bc70:	00c00284 	movi	r3,10
8111bc74:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiCols = atoi( inteiro );
8111bc78:	e0bff804 	addi	r2,fp,-32
8111bc7c:	1009883a 	mov	r4,r2
8111bc80:	11227d00 	call	811227d0 <atoi>
8111bc84:	1007883a 	mov	r3,r2
8111bc88:	00a045b4 	movhi	r2,33046
8111bc8c:	109fe204 	addi	r2,r2,32648
8111bc90:	10c0058d 	sth	r3,22(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111bc94:	e0bff804 	addi	r2,fp,-32
8111bc98:	e0bff515 	stw	r2,-44(fp)
							ucParser++;
8111bc9c:	e0bff403 	ldbu	r2,-48(fp)
8111bca0:	10800044 	addi	r2,r2,1
8111bca4:	e0bff405 	stb	r2,-48(fp)
						} while ( (c !=59) );
8111bca8:	e0bff447 	ldb	r2,-47(fp)
8111bcac:	10800ed8 	cmpnei	r2,r2,59
8111bcb0:	103fd61e 	bne	r2,zero,8111bc0c <__reset+0xfb0fbc0c>

						break;
8111bcb4:	00015d06 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'K':

						do {
							c = cGetNextChar(siFile);
8111bcb8:	e0bff70f 	ldh	r2,-36(fp)
8111bcbc:	1009883a 	mov	r4,r2
8111bcc0:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111bcc4:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111bcc8:	d0e00317 	ldw	r3,-32756(gp)
8111bccc:	e0bff447 	ldb	r2,-47(fp)
8111bcd0:	10800044 	addi	r2,r2,1
8111bcd4:	1885883a 	add	r2,r3,r2
8111bcd8:	10800003 	ldbu	r2,0(r2)
8111bcdc:	10803fcc 	andi	r2,r2,255
8111bce0:	1080010c 	andi	r2,r2,4
8111bce4:	10000626 	beq	r2,zero,8111bd00 <vLoadDebugConfs+0x864>
								(*p_inteiro) = c;
8111bce8:	e0bff517 	ldw	r2,-44(fp)
8111bcec:	e0fff443 	ldbu	r3,-47(fp)
8111bcf0:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111bcf4:	e0bff517 	ldw	r2,-44(fp)
8111bcf8:	10800044 	addi	r2,r2,1
8111bcfc:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111bd00:	e0bff447 	ldb	r2,-47(fp)
8111bd04:	10800ed8 	cmpnei	r2,r2,59
8111bd08:	103feb1e 	bne	r2,zero,8111bcb8 <__reset+0xfb0fbcb8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bd0c:	e0bff517 	ldw	r2,-44(fp)
8111bd10:	00c00284 	movi	r3,10
8111bd14:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulColDelay = atoi( inteiro );
8111bd18:	e0bff804 	addi	r2,fp,-32
8111bd1c:	1009883a 	mov	r4,r2
8111bd20:	11227d00 	call	811227d0 <atoi>
8111bd24:	1007883a 	mov	r3,r2
8111bd28:	00a045b4 	movhi	r2,33046
8111bd2c:	109fe204 	addi	r2,r2,32648
8111bd30:	10c00915 	stw	r3,36(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111bd34:	e0bff804 	addi	r2,fp,-32
8111bd38:	e0bff515 	stw	r2,-44(fp)

						break;
8111bd3c:	00013b06 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'M':

						do {
							c = cGetNextChar(siFile);
8111bd40:	e0bff70f 	ldh	r2,-36(fp)
8111bd44:	1009883a 	mov	r4,r2
8111bd48:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111bd4c:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111bd50:	d0e00317 	ldw	r3,-32756(gp)
8111bd54:	e0bff447 	ldb	r2,-47(fp)
8111bd58:	10800044 	addi	r2,r2,1
8111bd5c:	1885883a 	add	r2,r3,r2
8111bd60:	10800003 	ldbu	r2,0(r2)
8111bd64:	10803fcc 	andi	r2,r2,255
8111bd68:	1080010c 	andi	r2,r2,4
8111bd6c:	10000626 	beq	r2,zero,8111bd88 <vLoadDebugConfs+0x8ec>
								(*p_inteiro) = c;
8111bd70:	e0bff517 	ldw	r2,-44(fp)
8111bd74:	e0fff443 	ldbu	r3,-47(fp)
8111bd78:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111bd7c:	e0bff517 	ldw	r2,-44(fp)
8111bd80:	10800044 	addi	r2,r2,1
8111bd84:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111bd88:	e0bff447 	ldb	r2,-47(fp)
8111bd8c:	10800ed8 	cmpnei	r2,r2,59
8111bd90:	103feb1e 	bne	r2,zero,8111bd40 <__reset+0xfb0fbd40>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bd94:	e0bff517 	ldw	r2,-44(fp)
8111bd98:	00c00284 	movi	r3,10
8111bd9c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulADCPixelDelay = atoi( inteiro );
8111bda0:	e0bff804 	addi	r2,fp,-32
8111bda4:	1009883a 	mov	r4,r2
8111bda8:	11227d00 	call	811227d0 <atoi>
8111bdac:	1007883a 	mov	r3,r2
8111bdb0:	00a045b4 	movhi	r2,33046
8111bdb4:	109fe204 	addi	r2,r2,32648
8111bdb8:	10c00a15 	stw	r3,40(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111bdbc:	e0bff804 	addi	r2,fp,-32
8111bdc0:	e0bff515 	stw	r2,-44(fp)

						break;
8111bdc4:	00011906 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'J':

						do {
							c = cGetNextChar(siFile);
8111bdc8:	e0bff70f 	ldh	r2,-36(fp)
8111bdcc:	1009883a 	mov	r4,r2
8111bdd0:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111bdd4:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111bdd8:	d0e00317 	ldw	r3,-32756(gp)
8111bddc:	e0bff447 	ldb	r2,-47(fp)
8111bde0:	10800044 	addi	r2,r2,1
8111bde4:	1885883a 	add	r2,r3,r2
8111bde8:	10800003 	ldbu	r2,0(r2)
8111bdec:	10803fcc 	andi	r2,r2,255
8111bdf0:	1080010c 	andi	r2,r2,4
8111bdf4:	10000626 	beq	r2,zero,8111be10 <vLoadDebugConfs+0x974>
								(*p_inteiro) = c;
8111bdf8:	e0bff517 	ldw	r2,-44(fp)
8111bdfc:	e0fff443 	ldbu	r3,-47(fp)
8111be00:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111be04:	e0bff517 	ldw	r2,-44(fp)
8111be08:	10800044 	addi	r2,r2,1
8111be0c:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111be10:	e0bff447 	ldb	r2,-47(fp)
8111be14:	10800ed8 	cmpnei	r2,r2,59
8111be18:	103feb1e 	bne	r2,zero,8111bdc8 <__reset+0xfb0fbdc8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111be1c:	e0bff517 	ldw	r2,-44(fp)
8111be20:	00c00284 	movi	r3,10
8111be24:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulLineDelay = atoi( inteiro );
8111be28:	e0bff804 	addi	r2,fp,-32
8111be2c:	1009883a 	mov	r4,r2
8111be30:	11227d00 	call	811227d0 <atoi>
8111be34:	1007883a 	mov	r3,r2
8111be38:	00a045b4 	movhi	r2,33046
8111be3c:	109fe204 	addi	r2,r2,32648
8111be40:	10c00815 	stw	r3,32(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111be44:	e0bff804 	addi	r2,fp,-32
8111be48:	e0bff515 	stw	r2,-44(fp)

						break;
8111be4c:	0000f706 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'B':

						do {
							c = cGetNextChar(siFile);
8111be50:	e0bff70f 	ldh	r2,-36(fp)
8111be54:	1009883a 	mov	r4,r2
8111be58:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111be5c:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111be60:	d0e00317 	ldw	r3,-32756(gp)
8111be64:	e0bff447 	ldb	r2,-47(fp)
8111be68:	10800044 	addi	r2,r2,1
8111be6c:	1885883a 	add	r2,r3,r2
8111be70:	10800003 	ldbu	r2,0(r2)
8111be74:	10803fcc 	andi	r2,r2,255
8111be78:	1080010c 	andi	r2,r2,4
8111be7c:	10000626 	beq	r2,zero,8111be98 <vLoadDebugConfs+0x9fc>
								(*p_inteiro) = c;
8111be80:	e0bff517 	ldw	r2,-44(fp)
8111be84:	e0fff443 	ldbu	r3,-47(fp)
8111be88:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111be8c:	e0bff517 	ldw	r2,-44(fp)
8111be90:	10800044 	addi	r2,r2,1
8111be94:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111be98:	e0bff447 	ldb	r2,-47(fp)
8111be9c:	10800ed8 	cmpnei	r2,r2,59
8111bea0:	103feb1e 	bne	r2,zero,8111be50 <__reset+0xfb0fbe50>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bea4:	e0bff517 	ldw	r2,-44(fp)
8111bea8:	00c00284 	movi	r3,10
8111beac:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiLinkNFEE0 = atoi( inteiro );
8111beb0:	e0bff804 	addi	r2,fp,-32
8111beb4:	1009883a 	mov	r4,r2
8111beb8:	11227d00 	call	811227d0 <atoi>
8111bebc:	1007883a 	mov	r3,r2
8111bec0:	00a045b4 	movhi	r2,33046
8111bec4:	109fe204 	addi	r2,r2,32648
8111bec8:	10c00d0d 	sth	r3,52(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111becc:	e0bff804 	addi	r2,fp,-32
8111bed0:	e0bff515 	stw	r2,-44(fp)

						break;
8111bed4:	0000d506 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'F':

						do {
							c = cGetNextChar(siFile);
8111bed8:	e0bff70f 	ldh	r2,-36(fp)
8111bedc:	1009883a 	mov	r4,r2
8111bee0:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111bee4:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111bee8:	d0e00317 	ldw	r3,-32756(gp)
8111beec:	e0bff447 	ldb	r2,-47(fp)
8111bef0:	10800044 	addi	r2,r2,1
8111bef4:	1885883a 	add	r2,r3,r2
8111bef8:	10800003 	ldbu	r2,0(r2)
8111befc:	10803fcc 	andi	r2,r2,255
8111bf00:	1080010c 	andi	r2,r2,4
8111bf04:	10000626 	beq	r2,zero,8111bf20 <vLoadDebugConfs+0xa84>
								(*p_inteiro) = c;
8111bf08:	e0bff517 	ldw	r2,-44(fp)
8111bf0c:	e0fff443 	ldbu	r3,-47(fp)
8111bf10:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111bf14:	e0bff517 	ldw	r2,-44(fp)
8111bf18:	10800044 	addi	r2,r2,1
8111bf1c:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111bf20:	e0bff447 	ldb	r2,-47(fp)
8111bf24:	10800ed8 	cmpnei	r2,r2,59
8111bf28:	103feb1e 	bne	r2,zero,8111bed8 <__reset+0xfb0fbed8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bf2c:	e0bff517 	ldw	r2,-44(fp)
8111bf30:	00c00284 	movi	r3,10
8111bf34:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDebugLevel = atoi( inteiro );
8111bf38:	e0bff804 	addi	r2,fp,-32
8111bf3c:	1009883a 	mov	r4,r2
8111bf40:	11227d00 	call	811227d0 <atoi>
8111bf44:	1007883a 	mov	r3,r2
8111bf48:	00a045b4 	movhi	r2,33046
8111bf4c:	109fe204 	addi	r2,r2,32648
8111bf50:	10c00d8d 	sth	r3,54(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111bf54:	e0bff804 	addi	r2,fp,-32
8111bf58:	e0bff515 	stw	r2,-44(fp)

						break;
8111bf5c:	0000b306 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'Q':

						do {
							c = cGetNextChar(siFile);
8111bf60:	e0bff70f 	ldh	r2,-36(fp)
8111bf64:	1009883a 	mov	r4,r2
8111bf68:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111bf6c:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111bf70:	d0e00317 	ldw	r3,-32756(gp)
8111bf74:	e0bff447 	ldb	r2,-47(fp)
8111bf78:	10800044 	addi	r2,r2,1
8111bf7c:	1885883a 	add	r2,r3,r2
8111bf80:	10800003 	ldbu	r2,0(r2)
8111bf84:	10803fcc 	andi	r2,r2,255
8111bf88:	1080010c 	andi	r2,r2,4
8111bf8c:	10000626 	beq	r2,zero,8111bfa8 <vLoadDebugConfs+0xb0c>
								(*p_inteiro) = c;
8111bf90:	e0bff517 	ldw	r2,-44(fp)
8111bf94:	e0fff443 	ldbu	r3,-47(fp)
8111bf98:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111bf9c:	e0bff517 	ldw	r2,-44(fp)
8111bfa0:	10800044 	addi	r2,r2,1
8111bfa4:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111bfa8:	e0bff447 	ldb	r2,-47(fp)
8111bfac:	10800ed8 	cmpnei	r2,r2,59
8111bfb0:	103feb1e 	bne	r2,zero,8111bf60 <__reset+0xfb0fbf60>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111bfb4:	e0bff517 	ldw	r2,-44(fp)
8111bfb8:	00c00284 	movi	r3,10
8111bfbc:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiPatternType = atoi( inteiro );
8111bfc0:	e0bff804 	addi	r2,fp,-32
8111bfc4:	1009883a 	mov	r4,r2
8111bfc8:	11227d00 	call	811227d0 <atoi>
8111bfcc:	1007883a 	mov	r3,r2
8111bfd0:	00a045b4 	movhi	r2,33046
8111bfd4:	109fe204 	addi	r2,r2,32648
8111bfd8:	10c00e0d 	sth	r3,56(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111bfdc:	e0bff804 	addi	r2,fp,-32
8111bfe0:	e0bff515 	stw	r2,-44(fp)

						break;
8111bfe4:	00009106 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'Y':

						do {
							c = cGetNextChar(siFile);
8111bfe8:	e0bff70f 	ldh	r2,-36(fp)
8111bfec:	1009883a 	mov	r4,r2
8111bff0:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111bff4:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111bff8:	d0e00317 	ldw	r3,-32756(gp)
8111bffc:	e0bff447 	ldb	r2,-47(fp)
8111c000:	10800044 	addi	r2,r2,1
8111c004:	1885883a 	add	r2,r3,r2
8111c008:	10800003 	ldbu	r2,0(r2)
8111c00c:	10803fcc 	andi	r2,r2,255
8111c010:	1080010c 	andi	r2,r2,4
8111c014:	10000626 	beq	r2,zero,8111c030 <vLoadDebugConfs+0xb94>
								(*p_inteiro) = c;
8111c018:	e0bff517 	ldw	r2,-44(fp)
8111c01c:	e0fff443 	ldbu	r3,-47(fp)
8111c020:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c024:	e0bff517 	ldw	r2,-44(fp)
8111c028:	10800044 	addi	r2,r2,1
8111c02c:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c030:	e0bff447 	ldb	r2,-47(fp)
8111c034:	10800ed8 	cmpnei	r2,r2,59
8111c038:	103feb1e 	bne	r2,zero,8111bfe8 <__reset+0xfb0fbfe8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c03c:	e0bff517 	ldw	r2,-44(fp)
8111c040:	00c00284 	movi	r3,10
8111c044:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiGuardNFEEDelay = atoi( inteiro );
8111c048:	e0bff804 	addi	r2,fp,-32
8111c04c:	1009883a 	mov	r4,r2
8111c050:	11227d00 	call	811227d0 <atoi>
8111c054:	1007883a 	mov	r3,r2
8111c058:	00a045b4 	movhi	r2,33046
8111c05c:	109fe204 	addi	r2,r2,32648
8111c060:	10c00e8d 	sth	r3,58(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c064:	e0bff804 	addi	r2,fp,-32
8111c068:	e0bff515 	stw	r2,-44(fp)

						break;
8111c06c:	00006f06 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'T':

						do {
							c = cGetNextChar(siFile);
8111c070:	e0bff70f 	ldh	r2,-36(fp)
8111c074:	1009883a 	mov	r4,r2
8111c078:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111c07c:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111c080:	d0e00317 	ldw	r3,-32756(gp)
8111c084:	e0bff447 	ldb	r2,-47(fp)
8111c088:	10800044 	addi	r2,r2,1
8111c08c:	1885883a 	add	r2,r3,r2
8111c090:	10800003 	ldbu	r2,0(r2)
8111c094:	10803fcc 	andi	r2,r2,255
8111c098:	1080010c 	andi	r2,r2,4
8111c09c:	10000626 	beq	r2,zero,8111c0b8 <vLoadDebugConfs+0xc1c>
								(*p_inteiro) = c;
8111c0a0:	e0bff517 	ldw	r2,-44(fp)
8111c0a4:	e0fff443 	ldbu	r3,-47(fp)
8111c0a8:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c0ac:	e0bff517 	ldw	r2,-44(fp)
8111c0b0:	10800044 	addi	r2,r2,1
8111c0b4:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c0b8:	e0bff447 	ldb	r2,-47(fp)
8111c0bc:	10800ed8 	cmpnei	r2,r2,59
8111c0c0:	103feb1e 	bne	r2,zero,8111c070 <__reset+0xfb0fc070>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c0c4:	e0bff517 	ldw	r2,-44(fp)
8111c0c8:	00c00284 	movi	r3,10
8111c0cc:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111c0d0:	e0bff804 	addi	r2,fp,-32
8111c0d4:	1009883a 	mov	r4,r2
8111c0d8:	11227d00 	call	811227d0 <atoi>
8111c0dc:	e0bff78d 	sth	r2,-34(fp)
						if (sidhcpTemp == 1)
8111c0e0:	e0bff78f 	ldh	r2,-34(fp)
8111c0e4:	10800058 	cmpnei	r2,r2,1
8111c0e8:	1000051e 	bne	r2,zero,8111c100 <vLoadDebugConfs+0xc64>
							xDefaults.bDataPacket = TRUE;
8111c0ec:	00a045b4 	movhi	r2,33046
8111c0f0:	109fe204 	addi	r2,r2,32648
8111c0f4:	00c00044 	movi	r3,1
8111c0f8:	10c00715 	stw	r3,28(r2)
8111c0fc:	00000306 	br	8111c10c <vLoadDebugConfs+0xc70>
						else
							xDefaults.bDataPacket = FALSE;
8111c100:	00a045b4 	movhi	r2,33046
8111c104:	109fe204 	addi	r2,r2,32648
8111c108:	10000715 	stw	zero,28(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c10c:	e0bff804 	addi	r2,fp,-32
8111c110:	e0bff515 	stw	r2,-44(fp)

						break;
8111c114:	00004506 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 'Z':

						do {
							c = cGetNextChar(siFile);
8111c118:	e0bff70f 	ldh	r2,-36(fp)
8111c11c:	1009883a 	mov	r4,r2
8111c120:	111ffd80 	call	8111ffd8 <cGetNextChar>
8111c124:	e0bff445 	stb	r2,-47(fp)
							if ( isdigit( c ) ) {
8111c128:	d0e00317 	ldw	r3,-32756(gp)
8111c12c:	e0bff447 	ldb	r2,-47(fp)
8111c130:	10800044 	addi	r2,r2,1
8111c134:	1885883a 	add	r2,r3,r2
8111c138:	10800003 	ldbu	r2,0(r2)
8111c13c:	10803fcc 	andi	r2,r2,255
8111c140:	1080010c 	andi	r2,r2,4
8111c144:	10000626 	beq	r2,zero,8111c160 <vLoadDebugConfs+0xcc4>
								(*p_inteiro) = c;
8111c148:	e0bff517 	ldw	r2,-44(fp)
8111c14c:	e0fff443 	ldbu	r3,-47(fp)
8111c150:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111c154:	e0bff517 	ldw	r2,-44(fp)
8111c158:	10800044 	addi	r2,r2,1
8111c15c:	e0bff515 	stw	r2,-44(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111c160:	e0bff447 	ldb	r2,-47(fp)
8111c164:	10800ed8 	cmpnei	r2,r2,59
8111c168:	103feb1e 	bne	r2,zero,8111c118 <__reset+0xfb0fc118>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111c16c:	e0bff517 	ldw	r2,-44(fp)
8111c170:	00c00284 	movi	r3,10
8111c174:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111c178:	e0bff804 	addi	r2,fp,-32
8111c17c:	1009883a 	mov	r4,r2
8111c180:	11227d00 	call	811227d0 <atoi>
8111c184:	e0bff78d 	sth	r2,-34(fp)
						if (sidhcpTemp == 1)
8111c188:	e0bff78f 	ldh	r2,-34(fp)
8111c18c:	10800058 	cmpnei	r2,r2,1
8111c190:	1000051e 	bne	r2,zero,8111c1a8 <vLoadDebugConfs+0xd0c>
							xDefaults.bOneShot = TRUE;
8111c194:	00a045b4 	movhi	r2,33046
8111c198:	109fe204 	addi	r2,r2,32648
8111c19c:	00c00044 	movi	r3,1
8111c1a0:	10c00c15 	stw	r3,48(r2)
8111c1a4:	00000306 	br	8111c1b4 <vLoadDebugConfs+0xd18>
						else
							xDefaults.bOneShot = FALSE;
8111c1a8:	00a045b4 	movhi	r2,33046
8111c1ac:	109fe204 	addi	r2,r2,32648
8111c1b0:	10000c15 	stw	zero,48(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111c1b4:	e0bff804 	addi	r2,fp,-32
8111c1b8:	e0bff515 	stw	r2,-44(fp)

						break;
8111c1bc:	00001b06 	br	8111c22c <vLoadDebugConfs+0xd90>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111c1c0:	e0bff70f 	ldh	r2,-36(fp)
8111c1c4:	1009883a 	mov	r4,r2
8111c1c8:	111ff980 	call	8111ff98 <siCloseFile>
8111c1cc:	e0bff615 	stw	r2,-40(fp)
						if (close == FALSE){
8111c1d0:	e0bff617 	ldw	r2,-40(fp)
8111c1d4:	1000071e 	bne	r2,zero,8111c1f4 <vLoadDebugConfs+0xd58>
							#if DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
8111c1d8:	d0a06217 	ldw	r2,-32376(gp)
8111c1dc:	100f883a 	mov	r7,r2
8111c1e0:	01800784 	movi	r6,30
8111c1e4:	01400044 	movi	r5,1
8111c1e8:	01204574 	movhi	r4,33045
8111c1ec:	213f9b04 	addi	r4,r4,-404
8111c1f0:	1122fc80 	call	81122fc8 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111c1f4:	00800044 	movi	r2,1
8111c1f8:	e0bff315 	stw	r2,-52(fp)
						bSuccess = TRUE; //pensar melhor
8111c1fc:	00800044 	movi	r2,1
8111c200:	e0bff215 	stw	r2,-56(fp)
						break;
8111c204:	00000906 	br	8111c22c <vLoadDebugConfs+0xd90>
					default:
						#if DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111c208:	d0a06217 	ldw	r2,-32376(gp)
8111c20c:	100f883a 	mov	r7,r2
8111c210:	01800844 	movi	r6,33
8111c214:	01400044 	movi	r5,1
8111c218:	01204574 	movhi	r4,33045
8111c21c:	213fa304 	addi	r4,r4,-372
8111c220:	1122fc80 	call	81122fc8 <fwrite>
						#endif
						break;
8111c224:	00000106 	br	8111c22c <vLoadDebugConfs+0xd90>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111c228:	0001883a 	nop
						#if DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
8111c22c:	e0bff317 	ldw	r2,-52(fp)
8111c230:	103cbc26 	beq	r2,zero,8111b524 <__reset+0xfb0fb524>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111c234:	00000f06 	br	8111c274 <vLoadDebugConfs+0xdd8>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#if DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
8111c238:	d0a06217 	ldw	r2,-32376(gp)
8111c23c:	100f883a 	mov	r7,r2
8111c240:	01800604 	movi	r6,24
8111c244:	01400044 	movi	r5,1
8111c248:	01204574 	movhi	r4,33045
8111c24c:	213fac04 	addi	r4,r4,-336
8111c250:	1122fc80 	call	81122fc8 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111c254:	00000706 	br	8111c274 <vLoadDebugConfs+0xdd8>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#if DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
8111c258:	d0a06217 	ldw	r2,-32376(gp)
8111c25c:	100f883a 	mov	r7,r2
8111c260:	018004c4 	movi	r6,19
8111c264:	01400044 	movi	r5,1
8111c268:	01204574 	movhi	r4,33045
8111c26c:	213fb304 	addi	r4,r4,-308
8111c270:	1122fc80 	call	81122fc8 <fwrite>
	if ( bSuccess == FALSE ) {
		/* Load default? */

	}

	return bSuccess;
8111c274:	e0bff217 	ldw	r2,-56(fp)
}
8111c278:	e037883a 	mov	sp,fp
8111c27c:	dfc00117 	ldw	ra,4(sp)
8111c280:	df000017 	ldw	fp,0(sp)
8111c284:	dec00204 	addi	sp,sp,8
8111c288:	f800283a 	ret

8111c28c <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
8111c28c:	defffb04 	addi	sp,sp,-20
8111c290:	de00012e 	bgeu	sp,et,8111c298 <ucCrc8+0xc>
8111c294:	003b68fa 	trap	3
8111c298:	df000415 	stw	fp,16(sp)
8111c29c:	df000404 	addi	fp,sp,16
8111c2a0:	e13ffd15 	stw	r4,-12(fp)
8111c2a4:	e17ffe15 	stw	r5,-8(fp)
8111c2a8:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
8111c2ac:	e0bffe17 	ldw	r2,-8(fp)
8111c2b0:	1000021e 	bne	r2,zero,8111c2bc <ucCrc8+0x30>
        return 0;
8111c2b4:	0005883a 	mov	r2,zero
8111c2b8:	00001906 	br	8111c320 <ucCrc8+0x94>
    crc &= 0xff;
8111c2bc:	e0bffd17 	ldw	r2,-12(fp)
8111c2c0:	10803fcc 	andi	r2,r2,255
8111c2c4:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
8111c2c8:	e0fffe17 	ldw	r3,-8(fp)
8111c2cc:	e0bfff17 	ldw	r2,-4(fp)
8111c2d0:	1885883a 	add	r2,r3,r2
8111c2d4:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
8111c2d8:	00000d06 	br	8111c310 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
8111c2dc:	e0bffe17 	ldw	r2,-8(fp)
8111c2e0:	10c00044 	addi	r3,r2,1
8111c2e4:	e0fffe15 	stw	r3,-8(fp)
8111c2e8:	10800003 	ldbu	r2,0(r2)
8111c2ec:	10c03fcc 	andi	r3,r2,255
8111c2f0:	e0bffd17 	ldw	r2,-12(fp)
8111c2f4:	1886f03a 	xor	r3,r3,r2
8111c2f8:	00a04574 	movhi	r2,33045
8111c2fc:	10bfea84 	addi	r2,r2,-86
8111c300:	10c5883a 	add	r2,r2,r3
8111c304:	10800003 	ldbu	r2,0(r2)
8111c308:	10803fcc 	andi	r2,r2,255
8111c30c:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
8111c310:	e0fffe17 	ldw	r3,-8(fp)
8111c314:	e0bffc17 	ldw	r2,-16(fp)
8111c318:	18bff036 	bltu	r3,r2,8111c2dc <__reset+0xfb0fc2dc>
        crc = crc8_table[crc ^ *data++];
    return crc;
8111c31c:	e0bffd17 	ldw	r2,-12(fp)
}
8111c320:	e037883a 	mov	sp,fp
8111c324:	df000017 	ldw	fp,0(sp)
8111c328:	dec00104 	addi	sp,sp,4
8111c32c:	f800283a 	ret

8111c330 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8111c330:	defffb04 	addi	sp,sp,-20
8111c334:	de00012e 	bgeu	sp,et,8111c33c <ucCrc8wInit+0xc>
8111c338:	003b68fa 	trap	3
8111c33c:	dfc00415 	stw	ra,16(sp)
8111c340:	df000315 	stw	fp,12(sp)
8111c344:	df000304 	addi	fp,sp,12
8111c348:	e13ffe15 	stw	r4,-8(fp)
8111c34c:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
8111c350:	000d883a 	mov	r6,zero
8111c354:	000b883a 	mov	r5,zero
8111c358:	0009883a 	mov	r4,zero
8111c35c:	111c28c0 	call	8111c28c <ucCrc8>
8111c360:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
8111c364:	e0bffd03 	ldbu	r2,-12(fp)
8111c368:	e1bfff17 	ldw	r6,-4(fp)
8111c36c:	e17ffe17 	ldw	r5,-8(fp)
8111c370:	1009883a 	mov	r4,r2
8111c374:	111c28c0 	call	8111c28c <ucCrc8>
}
8111c378:	e037883a 	mov	sp,fp
8111c37c:	dfc00117 	ldw	ra,4(sp)
8111c380:	df000017 	ldw	fp,0(sp)
8111c384:	dec00204 	addi	sp,sp,8
8111c388:	f800283a 	ret

8111c38c <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
8111c38c:	defffc04 	addi	sp,sp,-16
8111c390:	de00012e 	bgeu	sp,et,8111c398 <vDataControllerInit+0xc>
8111c394:	003b68fa 	trap	3
8111c398:	df000315 	stw	fp,12(sp)
8111c39c:	df000304 	addi	fp,sp,12
8111c3a0:	e13ffe15 	stw	r4,-8(fp)
8111c3a4:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
8111c3a8:	e0bffe17 	ldw	r2,-8(fp)
8111c3ac:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111c3b0:	e03ffd05 	stb	zero,-12(fp)
8111c3b4:	00001c06 	br	8111c428 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
8111c3b8:	e0bffd03 	ldbu	r2,-12(fp)
8111c3bc:	e0fffd03 	ldbu	r3,-12(fp)
8111c3c0:	18c09624 	muli	r3,r3,600
8111c3c4:	e13fff17 	ldw	r4,-4(fp)
8111c3c8:	20c7883a 	add	r3,r4,r3
8111c3cc:	e13ffe17 	ldw	r4,-8(fp)
8111c3d0:	10800084 	addi	r2,r2,2
8111c3d4:	1085883a 	add	r2,r2,r2
8111c3d8:	1085883a 	add	r2,r2,r2
8111c3dc:	2085883a 	add	r2,r4,r2
8111c3e0:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
8111c3e4:	e17ffd03 	ldbu	r5,-12(fp)
8111c3e8:	e0bffd03 	ldbu	r2,-12(fp)
8111c3ec:	e0ffff17 	ldw	r3,-4(fp)
8111c3f0:	108025c4 	addi	r2,r2,151
8111c3f4:	1085883a 	add	r2,r2,r2
8111c3f8:	1085883a 	add	r2,r2,r2
8111c3fc:	1885883a 	add	r2,r3,r2
8111c400:	10c00017 	ldw	r3,0(r2)
8111c404:	e13ffe17 	ldw	r4,-8(fp)
8111c408:	288000c4 	addi	r2,r5,3
8111c40c:	1085883a 	add	r2,r2,r2
8111c410:	1085883a 	add	r2,r2,r2
8111c414:	2085883a 	add	r2,r4,r2
8111c418:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111c41c:	e0bffd03 	ldbu	r2,-12(fp)
8111c420:	10800044 	addi	r2,r2,1
8111c424:	e0bffd05 	stb	r2,-12(fp)
8111c428:	e0bffd03 	ldbu	r2,-12(fp)
8111c42c:	103fe226 	beq	r2,zero,8111c3b8 <__reset+0xfb0fc3b8>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
8111c430:	e0bfff17 	ldw	r2,-4(fp)
8111c434:	10c09904 	addi	r3,r2,612
8111c438:	e0bffe17 	ldw	r2,-8(fp)
8111c43c:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
8111c440:	e0bffe17 	ldw	r2,-8(fp)
8111c444:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
8111c448:	e0bffe17 	ldw	r2,-8(fp)
8111c44c:	10c00504 	addi	r3,r2,20
8111c450:	e0bfff17 	ldw	r2,-4(fp)
8111c454:	10c09b15 	stw	r3,620(r2)
}
8111c458:	0001883a 	nop
8111c45c:	e037883a 	mov	sp,fp
8111c460:	df000017 	ldw	fp,0(sp)
8111c464:	dec00104 	addi	sp,sp,4
8111c468:	f800283a 	ret

8111c46c <printErrorTask>:

#include "error_handler_simucam.h"


#if DEBUG_ON
    void printErrorTask( INT8U error_code ) {
8111c46c:	defff904 	addi	sp,sp,-28
8111c470:	de00012e 	bgeu	sp,et,8111c478 <printErrorTask+0xc>
8111c474:	003b68fa 	trap	3
8111c478:	dfc00615 	stw	ra,24(sp)
8111c47c:	df000515 	stw	fp,20(sp)
8111c480:	df000504 	addi	fp,sp,20
8111c484:	2005883a 	mov	r2,r4
8111c488:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
8111c48c:	e03ffb15 	stw	zero,-20(fp)
8111c490:	e03ffc15 	stw	zero,-16(fp)
8111c494:	e03ffd15 	stw	zero,-12(fp)
8111c498:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
8111c49c:	e0bfff03 	ldbu	r2,-4(fp)
8111c4a0:	100d883a 	mov	r6,r2
8111c4a4:	01604574 	movhi	r5,33045
8111c4a8:	29402b04 	addi	r5,r5,172
8111c4ac:	e13ffb04 	addi	r4,fp,-20
8111c4b0:	11242400 	call	81124240 <sprintf>
		debug(fp, buffer);
8111c4b4:	d0a06217 	ldw	r2,-32376(gp)
8111c4b8:	e17ffb04 	addi	r5,fp,-20
8111c4bc:	1009883a 	mov	r4,r2
8111c4c0:	112292c0 	call	8112292c <fprintf>
	}
8111c4c4:	0001883a 	nop
8111c4c8:	e037883a 	mov	sp,fp
8111c4cc:	dfc00117 	ldw	ra,4(sp)
8111c4d0:	df000017 	ldw	fp,0(sp)
8111c4d4:	dec00204 	addi	sp,sp,8
8111c4d8:	f800283a 	ret

8111c4dc <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
8111c4dc:	defffd04 	addi	sp,sp,-12
8111c4e0:	de00012e 	bgeu	sp,et,8111c4e8 <vFailCreateMutexSResources+0xc>
8111c4e4:	003b68fa 	trap	3
8111c4e8:	dfc00215 	stw	ra,8(sp)
8111c4ec:	df000115 	stw	fp,4(sp)
8111c4f0:	df000104 	addi	fp,sp,4
8111c4f4:	2005883a 	mov	r2,r4
8111c4f8:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c4fc:	00a045b4 	movhi	r2,33046
8111c500:	109fe204 	addi	r2,r2,32648
8111c504:	10800d8b 	ldhu	r2,54(r2)
8111c508:	10bfffcc 	andi	r2,r2,65535
8111c50c:	10800228 	cmpgeui	r2,r2,8
8111c510:	10000a1e 	bne	r2,zero,8111c53c <vFailCreateMutexSResources+0x60>
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
8111c514:	d0a06217 	ldw	r2,-32376(gp)
8111c518:	100f883a 	mov	r7,r2
8111c51c:	018008c4 	movi	r6,35
8111c520:	01400044 	movi	r5,1
8111c524:	01204574 	movhi	r4,33045
8111c528:	21002e04 	addi	r4,r4,184
8111c52c:	1122fc80 	call	81122fc8 <fwrite>
		printErrorTask(error_code);
8111c530:	e0bfff03 	ldbu	r2,-4(fp)
8111c534:	1009883a 	mov	r4,r2
8111c538:	111c46c0 	call	8111c46c <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c53c:	0001883a 	nop
8111c540:	e037883a 	mov	sp,fp
8111c544:	dfc00117 	ldw	ra,4(sp)
8111c548:	df000017 	ldw	fp,0(sp)
8111c54c:	dec00204 	addi	sp,sp,8
8111c550:	f800283a 	ret

8111c554 <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
8111c554:	defffe04 	addi	sp,sp,-8
8111c558:	de00012e 	bgeu	sp,et,8111c560 <vFailCreateMutexDMA+0xc>
8111c55c:	003b68fa 	trap	3
8111c560:	dfc00115 	stw	ra,4(sp)
8111c564:	df000015 	stw	fp,0(sp)
8111c568:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c56c:	00a045b4 	movhi	r2,33046
8111c570:	109fe204 	addi	r2,r2,32648
8111c574:	10800d8b 	ldhu	r2,54(r2)
8111c578:	10bfffcc 	andi	r2,r2,65535
8111c57c:	10800228 	cmpgeui	r2,r2,8
8111c580:	1000071e 	bne	r2,zero,8111c5a0 <vFailCreateMutexDMA+0x4c>
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
8111c584:	d0a06217 	ldw	r2,-32376(gp)
8111c588:	100f883a 	mov	r7,r2
8111c58c:	018009c4 	movi	r6,39
8111c590:	01400044 	movi	r5,1
8111c594:	01204574 	movhi	r4,33045
8111c598:	21003704 	addi	r4,r4,220
8111c59c:	1122fc80 	call	81122fc8 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c5a0:	0001883a 	nop
8111c5a4:	e037883a 	mov	sp,fp
8111c5a8:	dfc00117 	ldw	ra,4(sp)
8111c5ac:	df000017 	ldw	fp,0(sp)
8111c5b0:	dec00204 	addi	sp,sp,8
8111c5b4:	f800283a 	ret

8111c5b8 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
8111c5b8:	defffe04 	addi	sp,sp,-8
8111c5bc:	de00012e 	bgeu	sp,et,8111c5c4 <vFailCreateSemaphoreResources+0xc>
8111c5c0:	003b68fa 	trap	3
8111c5c4:	dfc00115 	stw	ra,4(sp)
8111c5c8:	df000015 	stw	fp,0(sp)
8111c5cc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c5d0:	00a045b4 	movhi	r2,33046
8111c5d4:	109fe204 	addi	r2,r2,32648
8111c5d8:	10800d8b 	ldhu	r2,54(r2)
8111c5dc:	10bfffcc 	andi	r2,r2,65535
8111c5e0:	10800228 	cmpgeui	r2,r2,8
8111c5e4:	1000071e 	bne	r2,zero,8111c604 <vFailCreateSemaphoreResources+0x4c>
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
8111c5e8:	d0a06217 	ldw	r2,-32376(gp)
8111c5ec:	100f883a 	mov	r7,r2
8111c5f0:	01800984 	movi	r6,38
8111c5f4:	01400044 	movi	r5,1
8111c5f8:	01204574 	movhi	r4,33045
8111c5fc:	21004104 	addi	r4,r4,260
8111c600:	1122fc80 	call	81122fc8 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c604:	0001883a 	nop
8111c608:	e037883a 	mov	sp,fp
8111c60c:	dfc00117 	ldw	ra,4(sp)
8111c610:	df000017 	ldw	fp,0(sp)
8111c614:	dec00204 	addi	sp,sp,8
8111c618:	f800283a 	ret

8111c61c <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
8111c61c:	defffe04 	addi	sp,sp,-8
8111c620:	de00012e 	bgeu	sp,et,8111c628 <vFailTestCriticasParts+0xc>
8111c624:	003b68fa 	trap	3
8111c628:	dfc00115 	stw	ra,4(sp)
8111c62c:	df000015 	stw	fp,0(sp)
8111c630:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c634:	00a045b4 	movhi	r2,33046
8111c638:	109fe204 	addi	r2,r2,32648
8111c63c:	10800d8b 	ldhu	r2,54(r2)
8111c640:	10bfffcc 	andi	r2,r2,65535
8111c644:	10800228 	cmpgeui	r2,r2,8
8111c648:	1000071e 	bne	r2,zero,8111c668 <vFailTestCriticasParts+0x4c>
		debug(fp,"vFailTestCriticasParts. (exit)\n");
8111c64c:	d0a06217 	ldw	r2,-32376(gp)
8111c650:	100f883a 	mov	r7,r2
8111c654:	018007c4 	movi	r6,31
8111c658:	01400044 	movi	r5,1
8111c65c:	01204574 	movhi	r4,33045
8111c660:	21004b04 	addi	r4,r4,300
8111c664:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c668:	0001883a 	nop
8111c66c:	e037883a 	mov	sp,fp
8111c670:	dfc00117 	ldw	ra,4(sp)
8111c674:	df000017 	ldw	fp,0(sp)
8111c678:	dec00204 	addi	sp,sp,8
8111c67c:	f800283a 	ret

8111c680 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
8111c680:	defffe04 	addi	sp,sp,-8
8111c684:	de00012e 	bgeu	sp,et,8111c68c <vFailSendxSemCommInit+0xc>
8111c688:	003b68fa 	trap	3
8111c68c:	dfc00115 	stw	ra,4(sp)
8111c690:	df000015 	stw	fp,0(sp)
8111c694:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c698:	00a045b4 	movhi	r2,33046
8111c69c:	109fe204 	addi	r2,r2,32648
8111c6a0:	10800d8b 	ldhu	r2,54(r2)
8111c6a4:	10bfffcc 	andi	r2,r2,65535
8111c6a8:	10800228 	cmpgeui	r2,r2,8
8111c6ac:	10000e1e 	bne	r2,zero,8111c6e8 <vFailSendxSemCommInit+0x68>
		debug(fp,"vFailSendxSemCommInit. (exit)");
8111c6b0:	d0a06217 	ldw	r2,-32376(gp)
8111c6b4:	100f883a 	mov	r7,r2
8111c6b8:	01800744 	movi	r6,29
8111c6bc:	01400044 	movi	r5,1
8111c6c0:	01204574 	movhi	r4,33045
8111c6c4:	21005304 	addi	r4,r4,332
8111c6c8:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
8111c6cc:	d0a06217 	ldw	r2,-32376(gp)
8111c6d0:	100f883a 	mov	r7,r2
8111c6d4:	01800a44 	movi	r6,41
8111c6d8:	01400044 	movi	r5,1
8111c6dc:	01204574 	movhi	r4,33045
8111c6e0:	21005b04 	addi	r4,r4,364
8111c6e4:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c6e8:	0001883a 	nop
8111c6ec:	e037883a 	mov	sp,fp
8111c6f0:	dfc00117 	ldw	ra,4(sp)
8111c6f4:	df000017 	ldw	fp,0(sp)
8111c6f8:	dec00204 	addi	sp,sp,8
8111c6fc:	f800283a 	ret

8111c700 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
8111c700:	defffe04 	addi	sp,sp,-8
8111c704:	de00012e 	bgeu	sp,et,8111c70c <vFailSendPreParsedSemaphore+0xc>
8111c708:	003b68fa 	trap	3
8111c70c:	dfc00115 	stw	ra,4(sp)
8111c710:	df000015 	stw	fp,0(sp)
8111c714:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c718:	00a045b4 	movhi	r2,33046
8111c71c:	109fe204 	addi	r2,r2,32648
8111c720:	10800d8b 	ldhu	r2,54(r2)
8111c724:	10bfffcc 	andi	r2,r2,65535
8111c728:	10800228 	cmpgeui	r2,r2,8
8111c72c:	1000071e 	bne	r2,zero,8111c74c <vFailSendPreParsedSemaphore+0x4c>
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
8111c730:	d0a06217 	ldw	r2,-32376(gp)
8111c734:	100f883a 	mov	r7,r2
8111c738:	01800904 	movi	r6,36
8111c73c:	01400044 	movi	r5,1
8111c740:	01204574 	movhi	r4,33045
8111c744:	21006604 	addi	r4,r4,408
8111c748:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c74c:	0001883a 	nop
8111c750:	e037883a 	mov	sp,fp
8111c754:	dfc00117 	ldw	ra,4(sp)
8111c758:	df000017 	ldw	fp,0(sp)
8111c75c:	dec00204 	addi	sp,sp,8
8111c760:	f800283a 	ret

8111c764 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
8111c764:	defffe04 	addi	sp,sp,-8
8111c768:	de00012e 	bgeu	sp,et,8111c770 <vFailSendPreAckReceiverSemaphore+0xc>
8111c76c:	003b68fa 	trap	3
8111c770:	dfc00115 	stw	ra,4(sp)
8111c774:	df000015 	stw	fp,0(sp)
8111c778:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c77c:	00a045b4 	movhi	r2,33046
8111c780:	109fe204 	addi	r2,r2,32648
8111c784:	10800d8b 	ldhu	r2,54(r2)
8111c788:	10bfffcc 	andi	r2,r2,65535
8111c78c:	10800228 	cmpgeui	r2,r2,8
8111c790:	1000071e 	bne	r2,zero,8111c7b0 <vFailSendPreAckReceiverSemaphore+0x4c>
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
8111c794:	d0a06217 	ldw	r2,-32376(gp)
8111c798:	100f883a 	mov	r7,r2
8111c79c:	01800a44 	movi	r6,41
8111c7a0:	01400044 	movi	r5,1
8111c7a4:	01204574 	movhi	r4,33045
8111c7a8:	21007004 	addi	r4,r4,448
8111c7ac:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c7b0:	0001883a 	nop
8111c7b4:	e037883a 	mov	sp,fp
8111c7b8:	dfc00117 	ldw	ra,4(sp)
8111c7bc:	df000017 	ldw	fp,0(sp)
8111c7c0:	dec00204 	addi	sp,sp,8
8111c7c4:	f800283a 	ret

8111c7c8 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
8111c7c8:	defffe04 	addi	sp,sp,-8
8111c7cc:	de00012e 	bgeu	sp,et,8111c7d4 <vFailSendPreAckSenderSemaphore+0xc>
8111c7d0:	003b68fa 	trap	3
8111c7d4:	dfc00115 	stw	ra,4(sp)
8111c7d8:	df000015 	stw	fp,0(sp)
8111c7dc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c7e0:	00a045b4 	movhi	r2,33046
8111c7e4:	109fe204 	addi	r2,r2,32648
8111c7e8:	10800d8b 	ldhu	r2,54(r2)
8111c7ec:	10bfffcc 	andi	r2,r2,65535
8111c7f0:	10800228 	cmpgeui	r2,r2,8
8111c7f4:	1000071e 	bne	r2,zero,8111c814 <vFailSendPreAckSenderSemaphore+0x4c>
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
8111c7f8:	d0a06217 	ldw	r2,-32376(gp)
8111c7fc:	100f883a 	mov	r7,r2
8111c800:	018009c4 	movi	r6,39
8111c804:	01400044 	movi	r5,1
8111c808:	01204574 	movhi	r4,33045
8111c80c:	21007b04 	addi	r4,r4,492
8111c810:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c814:	0001883a 	nop
8111c818:	e037883a 	mov	sp,fp
8111c81c:	dfc00117 	ldw	ra,4(sp)
8111c820:	df000017 	ldw	fp,0(sp)
8111c824:	dec00204 	addi	sp,sp,8
8111c828:	f800283a 	ret

8111c82c <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
8111c82c:	defffe04 	addi	sp,sp,-8
8111c830:	de00012e 	bgeu	sp,et,8111c838 <vFailGetCountSemaphoreSenderTask+0xc>
8111c834:	003b68fa 	trap	3
8111c838:	dfc00115 	stw	ra,4(sp)
8111c83c:	df000015 	stw	fp,0(sp)
8111c840:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c844:	00a045b4 	movhi	r2,33046
8111c848:	109fe204 	addi	r2,r2,32648
8111c84c:	10800d8b 	ldhu	r2,54(r2)
8111c850:	10bfffcc 	andi	r2,r2,65535
8111c854:	10800228 	cmpgeui	r2,r2,8
8111c858:	10000e1e 	bne	r2,zero,8111c894 <vFailGetCountSemaphoreSenderTask+0x68>
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
8111c85c:	d0a06217 	ldw	r2,-32376(gp)
8111c860:	100f883a 	mov	r7,r2
8111c864:	01800a44 	movi	r6,41
8111c868:	01400044 	movi	r5,1
8111c86c:	01204574 	movhi	r4,33045
8111c870:	21008504 	addi	r4,r4,532
8111c874:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
8111c878:	d0a06217 	ldw	r2,-32376(gp)
8111c87c:	100f883a 	mov	r7,r2
8111c880:	01801104 	movi	r6,68
8111c884:	01400044 	movi	r5,1
8111c888:	01204574 	movhi	r4,33045
8111c88c:	21009004 	addi	r4,r4,576
8111c890:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c894:	0001883a 	nop
8111c898:	e037883a 	mov	sp,fp
8111c89c:	dfc00117 	ldw	ra,4(sp)
8111c8a0:	df000017 	ldw	fp,0(sp)
8111c8a4:	dec00204 	addi	sp,sp,8
8111c8a8:	f800283a 	ret

8111c8ac <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
8111c8ac:	defffe04 	addi	sp,sp,-8
8111c8b0:	de00012e 	bgeu	sp,et,8111c8b8 <vFailGetMutexSenderTask+0xc>
8111c8b4:	003b68fa 	trap	3
8111c8b8:	dfc00115 	stw	ra,4(sp)
8111c8bc:	df000015 	stw	fp,0(sp)
8111c8c0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c8c4:	00a045b4 	movhi	r2,33046
8111c8c8:	109fe204 	addi	r2,r2,32648
8111c8cc:	10800d8b 	ldhu	r2,54(r2)
8111c8d0:	10bfffcc 	andi	r2,r2,65535
8111c8d4:	10800228 	cmpgeui	r2,r2,8
8111c8d8:	10000e1e 	bne	r2,zero,8111c914 <vFailGetMutexSenderTask+0x68>
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
8111c8dc:	d0a06217 	ldw	r2,-32376(gp)
8111c8e0:	100f883a 	mov	r7,r2
8111c8e4:	01800804 	movi	r6,32
8111c8e8:	01400044 	movi	r5,1
8111c8ec:	01204574 	movhi	r4,33045
8111c8f0:	2100a204 	addi	r4,r4,648
8111c8f4:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
8111c8f8:	d0a06217 	ldw	r2,-32376(gp)
8111c8fc:	100f883a 	mov	r7,r2
8111c900:	01801084 	movi	r6,66
8111c904:	01400044 	movi	r5,1
8111c908:	01204574 	movhi	r4,33045
8111c90c:	2100ab04 	addi	r4,r4,684
8111c910:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c914:	0001883a 	nop
8111c918:	e037883a 	mov	sp,fp
8111c91c:	dfc00117 	ldw	ra,4(sp)
8111c920:	df000017 	ldw	fp,0(sp)
8111c924:	dec00204 	addi	sp,sp,8
8111c928:	f800283a 	ret

8111c92c <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
8111c92c:	defffe04 	addi	sp,sp,-8
8111c930:	de00012e 	bgeu	sp,et,8111c938 <vFailGetCountSemaphoreReceiverTask+0xc>
8111c934:	003b68fa 	trap	3
8111c938:	dfc00115 	stw	ra,4(sp)
8111c93c:	df000015 	stw	fp,0(sp)
8111c940:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c944:	00a045b4 	movhi	r2,33046
8111c948:	109fe204 	addi	r2,r2,32648
8111c94c:	10800d8b 	ldhu	r2,54(r2)
8111c950:	10bfffcc 	andi	r2,r2,65535
8111c954:	10800228 	cmpgeui	r2,r2,8
8111c958:	10000e1e 	bne	r2,zero,8111c994 <vFailGetCountSemaphoreReceiverTask+0x68>
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
8111c95c:	d0a06217 	ldw	r2,-32376(gp)
8111c960:	100f883a 	mov	r7,r2
8111c964:	01800ac4 	movi	r6,43
8111c968:	01400044 	movi	r5,1
8111c96c:	01204574 	movhi	r4,33045
8111c970:	2100bc04 	addi	r4,r4,752
8111c974:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
8111c978:	d0a06217 	ldw	r2,-32376(gp)
8111c97c:	100f883a 	mov	r7,r2
8111c980:	01801184 	movi	r6,70
8111c984:	01400044 	movi	r5,1
8111c988:	01204574 	movhi	r4,33045
8111c98c:	2100c704 	addi	r4,r4,796
8111c990:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c994:	0001883a 	nop
8111c998:	e037883a 	mov	sp,fp
8111c99c:	dfc00117 	ldw	ra,4(sp)
8111c9a0:	df000017 	ldw	fp,0(sp)
8111c9a4:	dec00204 	addi	sp,sp,8
8111c9a8:	f800283a 	ret

8111c9ac <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
8111c9ac:	defffe04 	addi	sp,sp,-8
8111c9b0:	de00012e 	bgeu	sp,et,8111c9b8 <vFailGetMutexReceiverTask+0xc>
8111c9b4:	003b68fa 	trap	3
8111c9b8:	dfc00115 	stw	ra,4(sp)
8111c9bc:	df000015 	stw	fp,0(sp)
8111c9c0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111c9c4:	00a045b4 	movhi	r2,33046
8111c9c8:	109fe204 	addi	r2,r2,32648
8111c9cc:	10800d8b 	ldhu	r2,54(r2)
8111c9d0:	10bfffcc 	andi	r2,r2,65535
8111c9d4:	10800228 	cmpgeui	r2,r2,8
8111c9d8:	10000e1e 	bne	r2,zero,8111ca14 <vFailGetMutexReceiverTask+0x68>
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
8111c9dc:	d0a06217 	ldw	r2,-32376(gp)
8111c9e0:	100f883a 	mov	r7,r2
8111c9e4:	01800884 	movi	r6,34
8111c9e8:	01400044 	movi	r5,1
8111c9ec:	01204574 	movhi	r4,33045
8111c9f0:	2100d904 	addi	r4,r4,868
8111c9f4:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
8111c9f8:	d0a06217 	ldw	r2,-32376(gp)
8111c9fc:	100f883a 	mov	r7,r2
8111ca00:	01801104 	movi	r6,68
8111ca04:	01400044 	movi	r5,1
8111ca08:	01204574 	movhi	r4,33045
8111ca0c:	2100e204 	addi	r4,r4,904
8111ca10:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ca14:	0001883a 	nop
8111ca18:	e037883a 	mov	sp,fp
8111ca1c:	dfc00117 	ldw	ra,4(sp)
8111ca20:	df000017 	ldw	fp,0(sp)
8111ca24:	dec00204 	addi	sp,sp,8
8111ca28:	f800283a 	ret

8111ca2c <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
8111ca2c:	defffe04 	addi	sp,sp,-8
8111ca30:	de00012e 	bgeu	sp,et,8111ca38 <vFailGetMutexTxUARTSenderTask+0xc>
8111ca34:	003b68fa 	trap	3
8111ca38:	dfc00115 	stw	ra,4(sp)
8111ca3c:	df000015 	stw	fp,0(sp)
8111ca40:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ca44:	00a045b4 	movhi	r2,33046
8111ca48:	109fe204 	addi	r2,r2,32648
8111ca4c:	10800d8b 	ldhu	r2,54(r2)
8111ca50:	10bfffcc 	andi	r2,r2,65535
8111ca54:	10800228 	cmpgeui	r2,r2,8
8111ca58:	10000e1e 	bne	r2,zero,8111ca94 <vFailGetMutexTxUARTSenderTask+0x68>
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
8111ca5c:	d0a06217 	ldw	r2,-32376(gp)
8111ca60:	100f883a 	mov	r7,r2
8111ca64:	01800984 	movi	r6,38
8111ca68:	01400044 	movi	r5,1
8111ca6c:	01204574 	movhi	r4,33045
8111ca70:	2100f404 	addi	r4,r4,976
8111ca74:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
8111ca78:	d0a06217 	ldw	r2,-32376(gp)
8111ca7c:	100f883a 	mov	r7,r2
8111ca80:	01801044 	movi	r6,65
8111ca84:	01400044 	movi	r5,1
8111ca88:	01204574 	movhi	r4,33045
8111ca8c:	2100fe04 	addi	r4,r4,1016
8111ca90:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ca94:	0001883a 	nop
8111ca98:	e037883a 	mov	sp,fp
8111ca9c:	dfc00117 	ldw	ra,4(sp)
8111caa0:	df000017 	ldw	fp,0(sp)
8111caa4:	dec00204 	addi	sp,sp,8
8111caa8:	f800283a 	ret

8111caac <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
8111caac:	defffe04 	addi	sp,sp,-8
8111cab0:	de00012e 	bgeu	sp,et,8111cab8 <vFailGetMacRTC+0xc>
8111cab4:	003b68fa 	trap	3
8111cab8:	dfc00115 	stw	ra,4(sp)
8111cabc:	df000015 	stw	fp,0(sp)
8111cac0:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cac4:	00a045b4 	movhi	r2,33046
8111cac8:	109fe204 	addi	r2,r2,32648
8111cacc:	10800d8b 	ldhu	r2,54(r2)
8111cad0:	10bfffcc 	andi	r2,r2,65535
8111cad4:	10800228 	cmpgeui	r2,r2,8
8111cad8:	1000071e 	bne	r2,zero,8111caf8 <vFailGetMacRTC+0x4c>
		debug(fp,"vFailGetMacRTC\n");
8111cadc:	d0a06217 	ldw	r2,-32376(gp)
8111cae0:	100f883a 	mov	r7,r2
8111cae4:	018003c4 	movi	r6,15
8111cae8:	01400044 	movi	r5,1
8111caec:	01204574 	movhi	r4,33045
8111caf0:	21010f04 	addi	r4,r4,1084
8111caf4:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111caf8:	0001883a 	nop
8111cafc:	e037883a 	mov	sp,fp
8111cb00:	dfc00117 	ldw	ra,4(sp)
8111cb04:	df000017 	ldw	fp,0(sp)
8111cb08:	dec00204 	addi	sp,sp,8
8111cb0c:	f800283a 	ret

8111cb10 <vFailInitialization>:


void vFailInitialization( void )
{
8111cb10:	defffe04 	addi	sp,sp,-8
8111cb14:	de00012e 	bgeu	sp,et,8111cb1c <vFailInitialization+0xc>
8111cb18:	003b68fa 	trap	3
8111cb1c:	dfc00115 	stw	ra,4(sp)
8111cb20:	df000015 	stw	fp,0(sp)
8111cb24:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cb28:	00a045b4 	movhi	r2,33046
8111cb2c:	109fe204 	addi	r2,r2,32648
8111cb30:	10800d8b 	ldhu	r2,54(r2)
8111cb34:	10bfffcc 	andi	r2,r2,65535
8111cb38:	10800228 	cmpgeui	r2,r2,8
8111cb3c:	1000071e 	bne	r2,zero,8111cb5c <vFailInitialization+0x4c>
		debug(fp,"vFailInitialization\n");
8111cb40:	d0a06217 	ldw	r2,-32376(gp)
8111cb44:	100f883a 	mov	r7,r2
8111cb48:	01800504 	movi	r6,20
8111cb4c:	01400044 	movi	r5,1
8111cb50:	01204574 	movhi	r4,33045
8111cb54:	21011304 	addi	r4,r4,1100
8111cb58:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cb5c:	0001883a 	nop
8111cb60:	e037883a 	mov	sp,fp
8111cb64:	dfc00117 	ldw	ra,4(sp)
8111cb68:	df000017 	ldw	fp,0(sp)
8111cb6c:	dec00204 	addi	sp,sp,8
8111cb70:	f800283a 	ret

8111cb74 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
8111cb74:	defffe04 	addi	sp,sp,-8
8111cb78:	de00012e 	bgeu	sp,et,8111cb80 <vFailReceiverCreate+0xc>
8111cb7c:	003b68fa 	trap	3
8111cb80:	dfc00115 	stw	ra,4(sp)
8111cb84:	df000015 	stw	fp,0(sp)
8111cb88:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cb8c:	00a045b4 	movhi	r2,33046
8111cb90:	109fe204 	addi	r2,r2,32648
8111cb94:	10800d8b 	ldhu	r2,54(r2)
8111cb98:	10bfffcc 	andi	r2,r2,65535
8111cb9c:	10800228 	cmpgeui	r2,r2,8
8111cba0:	1000071e 	bne	r2,zero,8111cbc0 <vFailReceiverCreate+0x4c>
		debug(fp,"vReceiverUartTask\n");
8111cba4:	d0a06217 	ldw	r2,-32376(gp)
8111cba8:	100f883a 	mov	r7,r2
8111cbac:	01800484 	movi	r6,18
8111cbb0:	01400044 	movi	r5,1
8111cbb4:	01204574 	movhi	r4,33045
8111cbb8:	21011904 	addi	r4,r4,1124
8111cbbc:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cbc0:	0001883a 	nop
8111cbc4:	e037883a 	mov	sp,fp
8111cbc8:	dfc00117 	ldw	ra,4(sp)
8111cbcc:	df000017 	ldw	fp,0(sp)
8111cbd0:	dec00204 	addi	sp,sp,8
8111cbd4:	f800283a 	ret

8111cbd8 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
8111cbd8:	defffe04 	addi	sp,sp,-8
8111cbdc:	de00012e 	bgeu	sp,et,8111cbe4 <vFailSenderCreate+0xc>
8111cbe0:	003b68fa 	trap	3
8111cbe4:	dfc00115 	stw	ra,4(sp)
8111cbe8:	df000015 	stw	fp,0(sp)
8111cbec:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cbf0:	00a045b4 	movhi	r2,33046
8111cbf4:	109fe204 	addi	r2,r2,32648
8111cbf8:	10800d8b 	ldhu	r2,54(r2)
8111cbfc:	10bfffcc 	andi	r2,r2,65535
8111cc00:	10800228 	cmpgeui	r2,r2,8
8111cc04:	1000071e 	bne	r2,zero,8111cc24 <vFailSenderCreate+0x4c>
		debug(fp,"vFailSenderCreate\n");
8111cc08:	d0a06217 	ldw	r2,-32376(gp)
8111cc0c:	100f883a 	mov	r7,r2
8111cc10:	01800484 	movi	r6,18
8111cc14:	01400044 	movi	r5,1
8111cc18:	01204574 	movhi	r4,33045
8111cc1c:	21011e04 	addi	r4,r4,1144
8111cc20:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cc24:	0001883a 	nop
8111cc28:	e037883a 	mov	sp,fp
8111cc2c:	dfc00117 	ldw	ra,4(sp)
8111cc30:	df000017 	ldw	fp,0(sp)
8111cc34:	dec00204 	addi	sp,sp,8
8111cc38:	f800283a 	ret

8111cc3c <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
8111cc3c:	defffe04 	addi	sp,sp,-8
8111cc40:	de00012e 	bgeu	sp,et,8111cc48 <vFailDeleteInitialization+0xc>
8111cc44:	003b68fa 	trap	3
8111cc48:	dfc00115 	stw	ra,4(sp)
8111cc4c:	df000015 	stw	fp,0(sp)
8111cc50:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cc54:	00a045b4 	movhi	r2,33046
8111cc58:	109fe204 	addi	r2,r2,32648
8111cc5c:	10800d8b 	ldhu	r2,54(r2)
8111cc60:	10bfffcc 	andi	r2,r2,65535
8111cc64:	10800228 	cmpgeui	r2,r2,8
8111cc68:	1000071e 	bne	r2,zero,8111cc88 <vFailDeleteInitialization+0x4c>
		debug(fp,"vFailDeleteInitialization\n");
8111cc6c:	d0a06217 	ldw	r2,-32376(gp)
8111cc70:	100f883a 	mov	r7,r2
8111cc74:	01800684 	movi	r6,26
8111cc78:	01400044 	movi	r5,1
8111cc7c:	01204574 	movhi	r4,33045
8111cc80:	21012304 	addi	r4,r4,1164
8111cc84:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cc88:	0001883a 	nop
8111cc8c:	e037883a 	mov	sp,fp
8111cc90:	dfc00117 	ldw	ra,4(sp)
8111cc94:	df000017 	ldw	fp,0(sp)
8111cc98:	dec00204 	addi	sp,sp,8
8111cc9c:	f800283a 	ret

8111cca0 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
8111cca0:	defffe04 	addi	sp,sp,-8
8111cca4:	de00012e 	bgeu	sp,et,8111ccac <vFailSetCountSemaphorexBuffer32+0xc>
8111cca8:	003b68fa 	trap	3
8111ccac:	dfc00115 	stw	ra,4(sp)
8111ccb0:	df000015 	stw	fp,0(sp)
8111ccb4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ccb8:	00a045b4 	movhi	r2,33046
8111ccbc:	109fe204 	addi	r2,r2,32648
8111ccc0:	10800d8b 	ldhu	r2,54(r2)
8111ccc4:	10bfffcc 	andi	r2,r2,65535
8111ccc8:	10800228 	cmpgeui	r2,r2,8
8111cccc:	10000e1e 	bne	r2,zero,8111cd08 <vFailSetCountSemaphorexBuffer32+0x68>
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
8111ccd0:	d0a06217 	ldw	r2,-32376(gp)
8111ccd4:	100f883a 	mov	r7,r2
8111ccd8:	01800a04 	movi	r6,40
8111ccdc:	01400044 	movi	r5,1
8111cce0:	01204574 	movhi	r4,33045
8111cce4:	21012a04 	addi	r4,r4,1192
8111cce8:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not post to the semaphore.()\n");
8111ccec:	d0a06217 	ldw	r2,-32376(gp)
8111ccf0:	100f883a 	mov	r7,r2
8111ccf4:	018008c4 	movi	r6,35
8111ccf8:	01400044 	movi	r5,1
8111ccfc:	01204574 	movhi	r4,33045
8111cd00:	21013504 	addi	r4,r4,1236
8111cd04:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cd08:	0001883a 	nop
8111cd0c:	e037883a 	mov	sp,fp
8111cd10:	dfc00117 	ldw	ra,4(sp)
8111cd14:	df000017 	ldw	fp,0(sp)
8111cd18:	dec00204 	addi	sp,sp,8
8111cd1c:	f800283a 	ret

8111cd20 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
8111cd20:	defffe04 	addi	sp,sp,-8
8111cd24:	de00012e 	bgeu	sp,et,8111cd2c <vFailSetCountSemaphorexBuffer64+0xc>
8111cd28:	003b68fa 	trap	3
8111cd2c:	dfc00115 	stw	ra,4(sp)
8111cd30:	df000015 	stw	fp,0(sp)
8111cd34:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cd38:	00a045b4 	movhi	r2,33046
8111cd3c:	109fe204 	addi	r2,r2,32648
8111cd40:	10800d8b 	ldhu	r2,54(r2)
8111cd44:	10bfffcc 	andi	r2,r2,65535
8111cd48:	10800228 	cmpgeui	r2,r2,8
8111cd4c:	10000e1e 	bne	r2,zero,8111cd88 <vFailSetCountSemaphorexBuffer64+0x68>
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
8111cd50:	d0a06217 	ldw	r2,-32376(gp)
8111cd54:	100f883a 	mov	r7,r2
8111cd58:	01800a04 	movi	r6,40
8111cd5c:	01400044 	movi	r5,1
8111cd60:	01204574 	movhi	r4,33045
8111cd64:	21013e04 	addi	r4,r4,1272
8111cd68:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not post to the semaphore.()\n");
8111cd6c:	d0a06217 	ldw	r2,-32376(gp)
8111cd70:	100f883a 	mov	r7,r2
8111cd74:	018008c4 	movi	r6,35
8111cd78:	01400044 	movi	r5,1
8111cd7c:	01204574 	movhi	r4,33045
8111cd80:	21013504 	addi	r4,r4,1236
8111cd84:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cd88:	0001883a 	nop
8111cd8c:	e037883a 	mov	sp,fp
8111cd90:	dfc00117 	ldw	ra,4(sp)
8111cd94:	df000017 	ldw	fp,0(sp)
8111cd98:	dec00204 	addi	sp,sp,8
8111cd9c:	f800283a 	ret

8111cda0 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
8111cda0:	defffe04 	addi	sp,sp,-8
8111cda4:	de00012e 	bgeu	sp,et,8111cdac <vFailSetCountSemaphorexBuffer128+0xc>
8111cda8:	003b68fa 	trap	3
8111cdac:	dfc00115 	stw	ra,4(sp)
8111cdb0:	df000015 	stw	fp,0(sp)
8111cdb4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cdb8:	00a045b4 	movhi	r2,33046
8111cdbc:	109fe204 	addi	r2,r2,32648
8111cdc0:	10800d8b 	ldhu	r2,54(r2)
8111cdc4:	10bfffcc 	andi	r2,r2,65535
8111cdc8:	10800228 	cmpgeui	r2,r2,8
8111cdcc:	10000e1e 	bne	r2,zero,8111ce08 <vFailSetCountSemaphorexBuffer128+0x68>
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
8111cdd0:	d0a06217 	ldw	r2,-32376(gp)
8111cdd4:	100f883a 	mov	r7,r2
8111cdd8:	01800a44 	movi	r6,41
8111cddc:	01400044 	movi	r5,1
8111cde0:	01204574 	movhi	r4,33045
8111cde4:	21014904 	addi	r4,r4,1316
8111cde8:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not post to the semaphore.()\n");
8111cdec:	d0a06217 	ldw	r2,-32376(gp)
8111cdf0:	100f883a 	mov	r7,r2
8111cdf4:	018008c4 	movi	r6,35
8111cdf8:	01400044 	movi	r5,1
8111cdfc:	01204574 	movhi	r4,33045
8111ce00:	21013504 	addi	r4,r4,1236
8111ce04:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ce08:	0001883a 	nop
8111ce0c:	e037883a 	mov	sp,fp
8111ce10:	dfc00117 	ldw	ra,4(sp)
8111ce14:	df000017 	ldw	fp,0(sp)
8111ce18:	dec00204 	addi	sp,sp,8
8111ce1c:	f800283a 	ret

8111ce20 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
8111ce20:	defffe04 	addi	sp,sp,-8
8111ce24:	de00012e 	bgeu	sp,et,8111ce2c <vFailGetCountSemaphorexBuffer128+0xc>
8111ce28:	003b68fa 	trap	3
8111ce2c:	dfc00115 	stw	ra,4(sp)
8111ce30:	df000015 	stw	fp,0(sp)
8111ce34:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ce38:	00a045b4 	movhi	r2,33046
8111ce3c:	109fe204 	addi	r2,r2,32648
8111ce40:	10800d8b 	ldhu	r2,54(r2)
8111ce44:	10bfffcc 	andi	r2,r2,65535
8111ce48:	10800228 	cmpgeui	r2,r2,8
8111ce4c:	10000e1e 	bne	r2,zero,8111ce88 <vFailGetCountSemaphorexBuffer128+0x68>
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
8111ce50:	d0a06217 	ldw	r2,-32376(gp)
8111ce54:	100f883a 	mov	r7,r2
8111ce58:	01800a44 	movi	r6,41
8111ce5c:	01400044 	movi	r5,1
8111ce60:	01204574 	movhi	r4,33045
8111ce64:	21015404 	addi	r4,r4,1360
8111ce68:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get to the semaphore.()\n");
8111ce6c:	d0a06217 	ldw	r2,-32376(gp)
8111ce70:	100f883a 	mov	r7,r2
8111ce74:	01800884 	movi	r6,34
8111ce78:	01400044 	movi	r5,1
8111ce7c:	01204574 	movhi	r4,33045
8111ce80:	21015f04 	addi	r4,r4,1404
8111ce84:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ce88:	0001883a 	nop
8111ce8c:	e037883a 	mov	sp,fp
8111ce90:	dfc00117 	ldw	ra,4(sp)
8111ce94:	df000017 	ldw	fp,0(sp)
8111ce98:	dec00204 	addi	sp,sp,8
8111ce9c:	f800283a 	ret

8111cea0 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
8111cea0:	defffe04 	addi	sp,sp,-8
8111cea4:	de00012e 	bgeu	sp,et,8111ceac <vFailGetCountSemaphorexBuffer64+0xc>
8111cea8:	003b68fa 	trap	3
8111ceac:	dfc00115 	stw	ra,4(sp)
8111ceb0:	df000015 	stw	fp,0(sp)
8111ceb4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ceb8:	00a045b4 	movhi	r2,33046
8111cebc:	109fe204 	addi	r2,r2,32648
8111cec0:	10800d8b 	ldhu	r2,54(r2)
8111cec4:	10bfffcc 	andi	r2,r2,65535
8111cec8:	10800228 	cmpgeui	r2,r2,8
8111cecc:	10000e1e 	bne	r2,zero,8111cf08 <vFailGetCountSemaphorexBuffer64+0x68>
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
8111ced0:	d0a06217 	ldw	r2,-32376(gp)
8111ced4:	100f883a 	mov	r7,r2
8111ced8:	01800a04 	movi	r6,40
8111cedc:	01400044 	movi	r5,1
8111cee0:	01204574 	movhi	r4,33045
8111cee4:	21016804 	addi	r4,r4,1440
8111cee8:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get to the semaphore.()\n");
8111ceec:	d0a06217 	ldw	r2,-32376(gp)
8111cef0:	100f883a 	mov	r7,r2
8111cef4:	01800884 	movi	r6,34
8111cef8:	01400044 	movi	r5,1
8111cefc:	01204574 	movhi	r4,33045
8111cf00:	21015f04 	addi	r4,r4,1404
8111cf04:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cf08:	0001883a 	nop
8111cf0c:	e037883a 	mov	sp,fp
8111cf10:	dfc00117 	ldw	ra,4(sp)
8111cf14:	df000017 	ldw	fp,0(sp)
8111cf18:	dec00204 	addi	sp,sp,8
8111cf1c:	f800283a 	ret

8111cf20 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
8111cf20:	defffe04 	addi	sp,sp,-8
8111cf24:	de00012e 	bgeu	sp,et,8111cf2c <vFailGetCountSemaphorexBuffer32+0xc>
8111cf28:	003b68fa 	trap	3
8111cf2c:	dfc00115 	stw	ra,4(sp)
8111cf30:	df000015 	stw	fp,0(sp)
8111cf34:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cf38:	00a045b4 	movhi	r2,33046
8111cf3c:	109fe204 	addi	r2,r2,32648
8111cf40:	10800d8b 	ldhu	r2,54(r2)
8111cf44:	10bfffcc 	andi	r2,r2,65535
8111cf48:	10800228 	cmpgeui	r2,r2,8
8111cf4c:	10000e1e 	bne	r2,zero,8111cf88 <vFailGetCountSemaphorexBuffer32+0x68>
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
8111cf50:	d0a06217 	ldw	r2,-32376(gp)
8111cf54:	100f883a 	mov	r7,r2
8111cf58:	01800a04 	movi	r6,40
8111cf5c:	01400044 	movi	r5,1
8111cf60:	01204574 	movhi	r4,33045
8111cf64:	21017304 	addi	r4,r4,1484
8111cf68:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get to the semaphore.()\n");
8111cf6c:	d0a06217 	ldw	r2,-32376(gp)
8111cf70:	100f883a 	mov	r7,r2
8111cf74:	01800884 	movi	r6,34
8111cf78:	01400044 	movi	r5,1
8111cf7c:	01204574 	movhi	r4,33045
8111cf80:	21015f04 	addi	r4,r4,1404
8111cf84:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cf88:	0001883a 	nop
8111cf8c:	e037883a 	mov	sp,fp
8111cf90:	dfc00117 	ldw	ra,4(sp)
8111cf94:	df000017 	ldw	fp,0(sp)
8111cf98:	dec00204 	addi	sp,sp,8
8111cf9c:	f800283a 	ret

8111cfa0 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
8111cfa0:	defffe04 	addi	sp,sp,-8
8111cfa4:	de00012e 	bgeu	sp,et,8111cfac <vFailFoundBufferRetransmission+0xc>
8111cfa8:	003b68fa 	trap	3
8111cfac:	dfc00115 	stw	ra,4(sp)
8111cfb0:	df000015 	stw	fp,0(sp)
8111cfb4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111cfb8:	00a045b4 	movhi	r2,33046
8111cfbc:	109fe204 	addi	r2,r2,32648
8111cfc0:	10800d8b 	ldhu	r2,54(r2)
8111cfc4:	10bfffcc 	andi	r2,r2,65535
8111cfc8:	10800228 	cmpgeui	r2,r2,8
8111cfcc:	10000e1e 	bne	r2,zero,8111d008 <vFailFoundBufferRetransmission+0x68>
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
8111cfd0:	d0a06217 	ldw	r2,-32376(gp)
8111cfd4:	100f883a 	mov	r7,r2
8111cfd8:	01800a84 	movi	r6,42
8111cfdc:	01400044 	movi	r5,1
8111cfe0:	01204574 	movhi	r4,33045
8111cfe4:	21017e04 	addi	r4,r4,1528
8111cfe8:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
8111cfec:	d0a06217 	ldw	r2,-32376(gp)
8111cff0:	100f883a 	mov	r7,r2
8111cff4:	01801204 	movi	r6,72
8111cff8:	01400044 	movi	r5,1
8111cffc:	01204574 	movhi	r4,33045
8111d000:	21018904 	addi	r4,r4,1572
8111d004:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d008:	0001883a 	nop
8111d00c:	e037883a 	mov	sp,fp
8111d010:	dfc00117 	ldw	ra,4(sp)
8111d014:	df000017 	ldw	fp,0(sp)
8111d018:	dec00204 	addi	sp,sp,8
8111d01c:	f800283a 	ret

8111d020 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
8111d020:	defffe04 	addi	sp,sp,-8
8111d024:	de00012e 	bgeu	sp,et,8111d02c <vFailGetCountSemaphorePreParsedBuffer+0xc>
8111d028:	003b68fa 	trap	3
8111d02c:	dfc00115 	stw	ra,4(sp)
8111d030:	df000015 	stw	fp,0(sp)
8111d034:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d038:	00a045b4 	movhi	r2,33046
8111d03c:	109fe204 	addi	r2,r2,32648
8111d040:	10800d8b 	ldhu	r2,54(r2)
8111d044:	10bfffcc 	andi	r2,r2,65535
8111d048:	10800228 	cmpgeui	r2,r2,8
8111d04c:	10000e1e 	bne	r2,zero,8111d088 <vFailGetCountSemaphorePreParsedBuffer+0x68>
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
8111d050:	d0a06217 	ldw	r2,-32376(gp)
8111d054:	100f883a 	mov	r7,r2
8111d058:	01800b84 	movi	r6,46
8111d05c:	01400044 	movi	r5,1
8111d060:	01204574 	movhi	r4,33045
8111d064:	21019c04 	addi	r4,r4,1648
8111d068:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
8111d06c:	d0a06217 	ldw	r2,-32376(gp)
8111d070:	100f883a 	mov	r7,r2
8111d074:	018010c4 	movi	r6,67
8111d078:	01400044 	movi	r5,1
8111d07c:	01204574 	movhi	r4,33045
8111d080:	2101a804 	addi	r4,r4,1696
8111d084:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d088:	0001883a 	nop
8111d08c:	e037883a 	mov	sp,fp
8111d090:	dfc00117 	ldw	ra,4(sp)
8111d094:	df000017 	ldw	fp,0(sp)
8111d098:	dec00204 	addi	sp,sp,8
8111d09c:	f800283a 	ret

8111d0a0 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
8111d0a0:	defffe04 	addi	sp,sp,-8
8111d0a4:	de00012e 	bgeu	sp,et,8111d0ac <vFailGetxMutexPreParsedParserRxTask+0xc>
8111d0a8:	003b68fa 	trap	3
8111d0ac:	dfc00115 	stw	ra,4(sp)
8111d0b0:	df000015 	stw	fp,0(sp)
8111d0b4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d0b8:	00a045b4 	movhi	r2,33046
8111d0bc:	109fe204 	addi	r2,r2,32648
8111d0c0:	10800d8b 	ldhu	r2,54(r2)
8111d0c4:	10bfffcc 	andi	r2,r2,65535
8111d0c8:	10800228 	cmpgeui	r2,r2,8
8111d0cc:	10000e1e 	bne	r2,zero,8111d108 <vFailGetxMutexPreParsedParserRxTask+0x68>
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
8111d0d0:	d0a06217 	ldw	r2,-32376(gp)
8111d0d4:	100f883a 	mov	r7,r2
8111d0d8:	01800b04 	movi	r6,44
8111d0dc:	01400044 	movi	r5,1
8111d0e0:	01204574 	movhi	r4,33045
8111d0e4:	2101b904 	addi	r4,r4,1764
8111d0e8:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
8111d0ec:	d0a06217 	ldw	r2,-32376(gp)
8111d0f0:	100f883a 	mov	r7,r2
8111d0f4:	01800fc4 	movi	r6,63
8111d0f8:	01400044 	movi	r5,1
8111d0fc:	01204574 	movhi	r4,33045
8111d100:	2101c504 	addi	r4,r4,1812
8111d104:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d108:	0001883a 	nop
8111d10c:	e037883a 	mov	sp,fp
8111d110:	dfc00117 	ldw	ra,4(sp)
8111d114:	df000017 	ldw	fp,0(sp)
8111d118:	dec00204 	addi	sp,sp,8
8111d11c:	f800283a 	ret

8111d120 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
8111d120:	defffe04 	addi	sp,sp,-8
8111d124:	de00012e 	bgeu	sp,et,8111d12c <vNoContentInPreParsedBuffer+0xc>
8111d128:	003b68fa 	trap	3
8111d12c:	dfc00115 	stw	ra,4(sp)
8111d130:	df000015 	stw	fp,0(sp)
8111d134:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d138:	00a045b4 	movhi	r2,33046
8111d13c:	109fe204 	addi	r2,r2,32648
8111d140:	10800d8b 	ldhu	r2,54(r2)
8111d144:	10bfffcc 	andi	r2,r2,65535
8111d148:	10800228 	cmpgeui	r2,r2,8
8111d14c:	10000e1e 	bne	r2,zero,8111d188 <vNoContentInPreParsedBuffer+0x68>
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
8111d150:	d0a06217 	ldw	r2,-32376(gp)
8111d154:	100f883a 	mov	r7,r2
8111d158:	01800904 	movi	r6,36
8111d15c:	01400044 	movi	r5,1
8111d160:	01204574 	movhi	r4,33045
8111d164:	2101d504 	addi	r4,r4,1876
8111d168:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
8111d16c:	d0a06217 	ldw	r2,-32376(gp)
8111d170:	100f883a 	mov	r7,r2
8111d174:	01801684 	movi	r6,90
8111d178:	01400044 	movi	r5,1
8111d17c:	01204574 	movhi	r4,33045
8111d180:	2101df04 	addi	r4,r4,1916
8111d184:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d188:	0001883a 	nop
8111d18c:	e037883a 	mov	sp,fp
8111d190:	dfc00117 	ldw	ra,4(sp)
8111d194:	df000017 	ldw	fp,0(sp)
8111d198:	dec00204 	addi	sp,sp,8
8111d19c:	f800283a 	ret

8111d1a0 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
8111d1a0:	defffe04 	addi	sp,sp,-8
8111d1a4:	de00012e 	bgeu	sp,et,8111d1ac <vCouldNotSendEthConfUART+0xc>
8111d1a8:	003b68fa 	trap	3
8111d1ac:	dfc00115 	stw	ra,4(sp)
8111d1b0:	df000015 	stw	fp,0(sp)
8111d1b4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d1b8:	00a045b4 	movhi	r2,33046
8111d1bc:	109fe204 	addi	r2,r2,32648
8111d1c0:	10800d8b 	ldhu	r2,54(r2)
8111d1c4:	10bfffcc 	andi	r2,r2,65535
8111d1c8:	10800228 	cmpgeui	r2,r2,8
8111d1cc:	10000e1e 	bne	r2,zero,8111d208 <vCouldNotSendEthConfUART+0x68>
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
8111d1d0:	d0a06217 	ldw	r2,-32376(gp)
8111d1d4:	100f883a 	mov	r7,r2
8111d1d8:	01800844 	movi	r6,33
8111d1dc:	01400044 	movi	r5,1
8111d1e0:	01204574 	movhi	r4,33045
8111d1e4:	2101f604 	addi	r4,r4,2008
8111d1e8:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
8111d1ec:	d0a06217 	ldw	r2,-32376(gp)
8111d1f0:	100f883a 	mov	r7,r2
8111d1f4:	01801784 	movi	r6,94
8111d1f8:	01400044 	movi	r5,1
8111d1fc:	01204574 	movhi	r4,33045
8111d200:	2101ff04 	addi	r4,r4,2044
8111d204:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d208:	0001883a 	nop
8111d20c:	e037883a 	mov	sp,fp
8111d210:	dfc00117 	ldw	ra,4(sp)
8111d214:	df000017 	ldw	fp,0(sp)
8111d218:	dec00204 	addi	sp,sp,8
8111d21c:	f800283a 	ret

8111d220 <vFailSendNack>:

void vFailSendNack( void )
{
8111d220:	defffe04 	addi	sp,sp,-8
8111d224:	de00012e 	bgeu	sp,et,8111d22c <vFailSendNack+0xc>
8111d228:	003b68fa 	trap	3
8111d22c:	dfc00115 	stw	ra,4(sp)
8111d230:	df000015 	stw	fp,0(sp)
8111d234:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d238:	00a045b4 	movhi	r2,33046
8111d23c:	109fe204 	addi	r2,r2,32648
8111d240:	10800d8b 	ldhu	r2,54(r2)
8111d244:	10bfffcc 	andi	r2,r2,65535
8111d248:	10800228 	cmpgeui	r2,r2,8
8111d24c:	10000e1e 	bne	r2,zero,8111d288 <vFailSendNack+0x68>
		debug(fp,"vFailSendNack. (exit)\n");
8111d250:	d0a06217 	ldw	r2,-32376(gp)
8111d254:	100f883a 	mov	r7,r2
8111d258:	01800584 	movi	r6,22
8111d25c:	01400044 	movi	r5,1
8111d260:	01204574 	movhi	r4,33045
8111d264:	21021704 	addi	r4,r4,2140
8111d268:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
8111d26c:	d0a06217 	ldw	r2,-32376(gp)
8111d270:	100f883a 	mov	r7,r2
8111d274:	01800a84 	movi	r6,42
8111d278:	01400044 	movi	r5,1
8111d27c:	01204574 	movhi	r4,33045
8111d280:	21021d04 	addi	r4,r4,2164
8111d284:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d288:	0001883a 	nop
8111d28c:	e037883a 	mov	sp,fp
8111d290:	dfc00117 	ldw	ra,4(sp)
8111d294:	df000017 	ldw	fp,0(sp)
8111d298:	dec00204 	addi	sp,sp,8
8111d29c:	f800283a 	ret

8111d2a0 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
8111d2a0:	defffe04 	addi	sp,sp,-8
8111d2a4:	de00012e 	bgeu	sp,et,8111d2ac <vFailSetPreAckSenderBuffer+0xc>
8111d2a8:	003b68fa 	trap	3
8111d2ac:	dfc00115 	stw	ra,4(sp)
8111d2b0:	df000015 	stw	fp,0(sp)
8111d2b4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d2b8:	00a045b4 	movhi	r2,33046
8111d2bc:	109fe204 	addi	r2,r2,32648
8111d2c0:	10800d8b 	ldhu	r2,54(r2)
8111d2c4:	10bfffcc 	andi	r2,r2,65535
8111d2c8:	10800228 	cmpgeui	r2,r2,8
8111d2cc:	10000e1e 	bne	r2,zero,8111d308 <vFailSetPreAckSenderBuffer+0x68>
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
8111d2d0:	d0a06217 	ldw	r2,-32376(gp)
8111d2d4:	100f883a 	mov	r7,r2
8111d2d8:	018008c4 	movi	r6,35
8111d2dc:	01400044 	movi	r5,1
8111d2e0:	01204574 	movhi	r4,33045
8111d2e4:	21022804 	addi	r4,r4,2208
8111d2e8:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
8111d2ec:	d0a06217 	ldw	r2,-32376(gp)
8111d2f0:	100f883a 	mov	r7,r2
8111d2f4:	01801584 	movi	r6,86
8111d2f8:	01400044 	movi	r5,1
8111d2fc:	01204574 	movhi	r4,33045
8111d300:	21023104 	addi	r4,r4,2244
8111d304:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d308:	0001883a 	nop
8111d30c:	e037883a 	mov	sp,fp
8111d310:	dfc00117 	ldw	ra,4(sp)
8111d314:	df000017 	ldw	fp,0(sp)
8111d318:	dec00204 	addi	sp,sp,8
8111d31c:	f800283a 	ret

8111d320 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
8111d320:	defffe04 	addi	sp,sp,-8
8111d324:	de00012e 	bgeu	sp,et,8111d32c <vFailSetPreParsedBuffer+0xc>
8111d328:	003b68fa 	trap	3
8111d32c:	dfc00115 	stw	ra,4(sp)
8111d330:	df000015 	stw	fp,0(sp)
8111d334:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d338:	00a045b4 	movhi	r2,33046
8111d33c:	109fe204 	addi	r2,r2,32648
8111d340:	10800d8b 	ldhu	r2,54(r2)
8111d344:	10bfffcc 	andi	r2,r2,65535
8111d348:	10800228 	cmpgeui	r2,r2,8
8111d34c:	10000e1e 	bne	r2,zero,8111d388 <vFailSetPreParsedBuffer+0x68>
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
8111d350:	d0a06217 	ldw	r2,-32376(gp)
8111d354:	100f883a 	mov	r7,r2
8111d358:	01800804 	movi	r6,32
8111d35c:	01400044 	movi	r5,1
8111d360:	01204574 	movhi	r4,33045
8111d364:	21024704 	addi	r4,r4,2332
8111d368:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
8111d36c:	d0a06217 	ldw	r2,-32376(gp)
8111d370:	100f883a 	mov	r7,r2
8111d374:	018013c4 	movi	r6,79
8111d378:	01400044 	movi	r5,1
8111d37c:	01204574 	movhi	r4,33045
8111d380:	21025004 	addi	r4,r4,2368
8111d384:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d388:	0001883a 	nop
8111d38c:	e037883a 	mov	sp,fp
8111d390:	dfc00117 	ldw	ra,4(sp)
8111d394:	df000017 	ldw	fp,0(sp)
8111d398:	dec00204 	addi	sp,sp,8
8111d39c:	f800283a 	ret

8111d3a0 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
8111d3a0:	defffe04 	addi	sp,sp,-8
8111d3a4:	de00012e 	bgeu	sp,et,8111d3ac <vFailSetPreAckReceiverBuffer+0xc>
8111d3a8:	003b68fa 	trap	3
8111d3ac:	dfc00115 	stw	ra,4(sp)
8111d3b0:	df000015 	stw	fp,0(sp)
8111d3b4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d3b8:	00a045b4 	movhi	r2,33046
8111d3bc:	109fe204 	addi	r2,r2,32648
8111d3c0:	10800d8b 	ldhu	r2,54(r2)
8111d3c4:	10bfffcc 	andi	r2,r2,65535
8111d3c8:	10800228 	cmpgeui	r2,r2,8
8111d3cc:	10000e1e 	bne	r2,zero,8111d408 <vFailSetPreAckReceiverBuffer+0x68>
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
8111d3d0:	d0a06217 	ldw	r2,-32376(gp)
8111d3d4:	100f883a 	mov	r7,r2
8111d3d8:	01800944 	movi	r6,37
8111d3dc:	01400044 	movi	r5,1
8111d3e0:	01204574 	movhi	r4,33045
8111d3e4:	21026404 	addi	r4,r4,2448
8111d3e8:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
8111d3ec:	d0a06217 	ldw	r2,-32376(gp)
8111d3f0:	100f883a 	mov	r7,r2
8111d3f4:	018015c4 	movi	r6,87
8111d3f8:	01400044 	movi	r5,1
8111d3fc:	01204574 	movhi	r4,33045
8111d400:	21026e04 	addi	r4,r4,2488
8111d404:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d408:	0001883a 	nop
8111d40c:	e037883a 	mov	sp,fp
8111d410:	dfc00117 	ldw	ra,4(sp)
8111d414:	df000017 	ldw	fp,0(sp)
8111d418:	dec00204 	addi	sp,sp,8
8111d41c:	f800283a 	ret

8111d420 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
8111d420:	defffe04 	addi	sp,sp,-8
8111d424:	de00012e 	bgeu	sp,et,8111d42c <vFailParserCommTaskCreate+0xc>
8111d428:	003b68fa 	trap	3
8111d42c:	dfc00115 	stw	ra,4(sp)
8111d430:	df000015 	stw	fp,0(sp)
8111d434:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d438:	00a045b4 	movhi	r2,33046
8111d43c:	109fe204 	addi	r2,r2,32648
8111d440:	10800d8b 	ldhu	r2,54(r2)
8111d444:	10bfffcc 	andi	r2,r2,65535
8111d448:	10800228 	cmpgeui	r2,r2,8
8111d44c:	1000071e 	bne	r2,zero,8111d46c <vFailParserCommTaskCreate+0x4c>
		debug(fp,"vFailParserCommTaskCreate\n");
8111d450:	d0a06217 	ldw	r2,-32376(gp)
8111d454:	100f883a 	mov	r7,r2
8111d458:	01800684 	movi	r6,26
8111d45c:	01400044 	movi	r5,1
8111d460:	01204574 	movhi	r4,33045
8111d464:	21028404 	addi	r4,r4,2576
8111d468:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d46c:	0001883a 	nop
8111d470:	e037883a 	mov	sp,fp
8111d474:	dfc00117 	ldw	ra,4(sp)
8111d478:	df000017 	ldw	fp,0(sp)
8111d47c:	dec00204 	addi	sp,sp,8
8111d480:	f800283a 	ret

8111d484 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8111d484:	defffe04 	addi	sp,sp,-8
8111d488:	de00012e 	bgeu	sp,et,8111d490 <vFailInAckHandlerTaskCreate+0xc>
8111d48c:	003b68fa 	trap	3
8111d490:	dfc00115 	stw	ra,4(sp)
8111d494:	df000015 	stw	fp,0(sp)
8111d498:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d49c:	00a045b4 	movhi	r2,33046
8111d4a0:	109fe204 	addi	r2,r2,32648
8111d4a4:	10800d8b 	ldhu	r2,54(r2)
8111d4a8:	10bfffcc 	andi	r2,r2,65535
8111d4ac:	10800228 	cmpgeui	r2,r2,8
8111d4b0:	1000071e 	bne	r2,zero,8111d4d0 <vFailInAckHandlerTaskCreate+0x4c>
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111d4b4:	d0a06217 	ldw	r2,-32376(gp)
8111d4b8:	100f883a 	mov	r7,r2
8111d4bc:	01800704 	movi	r6,28
8111d4c0:	01400044 	movi	r5,1
8111d4c4:	01204574 	movhi	r4,33045
8111d4c8:	21028b04 	addi	r4,r4,2604
8111d4cc:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d4d0:	0001883a 	nop
8111d4d4:	e037883a 	mov	sp,fp
8111d4d8:	dfc00117 	ldw	ra,4(sp)
8111d4dc:	df000017 	ldw	fp,0(sp)
8111d4e0:	dec00204 	addi	sp,sp,8
8111d4e4:	f800283a 	ret

8111d4e8 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
8111d4e8:	defffe04 	addi	sp,sp,-8
8111d4ec:	de00012e 	bgeu	sp,et,8111d4f4 <vFailOutAckHandlerTaskCreate+0xc>
8111d4f0:	003b68fa 	trap	3
8111d4f4:	dfc00115 	stw	ra,4(sp)
8111d4f8:	df000015 	stw	fp,0(sp)
8111d4fc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d500:	00a045b4 	movhi	r2,33046
8111d504:	109fe204 	addi	r2,r2,32648
8111d508:	10800d8b 	ldhu	r2,54(r2)
8111d50c:	10bfffcc 	andi	r2,r2,65535
8111d510:	10800228 	cmpgeui	r2,r2,8
8111d514:	1000071e 	bne	r2,zero,8111d534 <vFailOutAckHandlerTaskCreate+0x4c>
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111d518:	d0a06217 	ldw	r2,-32376(gp)
8111d51c:	100f883a 	mov	r7,r2
8111d520:	01800704 	movi	r6,28
8111d524:	01400044 	movi	r5,1
8111d528:	01204574 	movhi	r4,33045
8111d52c:	21028b04 	addi	r4,r4,2604
8111d530:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d534:	0001883a 	nop
8111d538:	e037883a 	mov	sp,fp
8111d53c:	dfc00117 	ldw	ra,4(sp)
8111d540:	df000017 	ldw	fp,0(sp)
8111d544:	dec00204 	addi	sp,sp,8
8111d548:	f800283a 	ret

8111d54c <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8111d54c:	defffe04 	addi	sp,sp,-8
8111d550:	de00012e 	bgeu	sp,et,8111d558 <vFailCreateTimerRetransmisison+0xc>
8111d554:	003b68fa 	trap	3
8111d558:	dfc00115 	stw	ra,4(sp)
8111d55c:	df000015 	stw	fp,0(sp)
8111d560:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d564:	00a045b4 	movhi	r2,33046
8111d568:	109fe204 	addi	r2,r2,32648
8111d56c:	10800d8b 	ldhu	r2,54(r2)
8111d570:	10bfffcc 	andi	r2,r2,65535
8111d574:	10800228 	cmpgeui	r2,r2,8
8111d578:	1000071e 	bne	r2,zero,8111d598 <vFailCreateTimerRetransmisison+0x4c>
		debug(fp,"vFailCreateTimerRetransmisison\n");
8111d57c:	d0a06217 	ldw	r2,-32376(gp)
8111d580:	100f883a 	mov	r7,r2
8111d584:	018007c4 	movi	r6,31
8111d588:	01400044 	movi	r5,1
8111d58c:	01204574 	movhi	r4,33045
8111d590:	21029304 	addi	r4,r4,2636
8111d594:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d598:	0001883a 	nop
8111d59c:	e037883a 	mov	sp,fp
8111d5a0:	dfc00117 	ldw	ra,4(sp)
8111d5a4:	df000017 	ldw	fp,0(sp)
8111d5a8:	dec00204 	addi	sp,sp,8
8111d5ac:	f800283a 	ret

8111d5b0 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
8111d5b0:	defffe04 	addi	sp,sp,-8
8111d5b4:	de00012e 	bgeu	sp,et,8111d5bc <vCouldNotCheckBufferTimeOutFunction+0xc>
8111d5b8:	003b68fa 	trap	3
8111d5bc:	dfc00115 	stw	ra,4(sp)
8111d5c0:	df000015 	stw	fp,0(sp)
8111d5c4:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d5c8:	00a045b4 	movhi	r2,33046
8111d5cc:	109fe204 	addi	r2,r2,32648
8111d5d0:	10800d8b 	ldhu	r2,54(r2)
8111d5d4:	10bfffcc 	andi	r2,r2,65535
8111d5d8:	10800228 	cmpgeui	r2,r2,8
8111d5dc:	1000071e 	bne	r2,zero,8111d5fc <vCouldNotCheckBufferTimeOutFunction+0x4c>
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
8111d5e0:	d0a06217 	ldw	r2,-32376(gp)
8111d5e4:	100f883a 	mov	r7,r2
8111d5e8:	01800904 	movi	r6,36
8111d5ec:	01400044 	movi	r5,1
8111d5f0:	01204574 	movhi	r4,33045
8111d5f4:	21029b04 	addi	r4,r4,2668
8111d5f8:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d5fc:	0001883a 	nop
8111d600:	e037883a 	mov	sp,fp
8111d604:	dfc00117 	ldw	ra,4(sp)
8111d608:	df000017 	ldw	fp,0(sp)
8111d60c:	dec00204 	addi	sp,sp,8
8111d610:	f800283a 	ret

8111d614 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
8111d614:	defffe04 	addi	sp,sp,-8
8111d618:	de00012e 	bgeu	sp,et,8111d620 <vFailTimeoutCheckerTaskCreate+0xc>
8111d61c:	003b68fa 	trap	3
8111d620:	dfc00115 	stw	ra,4(sp)
8111d624:	df000015 	stw	fp,0(sp)
8111d628:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d62c:	00a045b4 	movhi	r2,33046
8111d630:	109fe204 	addi	r2,r2,32648
8111d634:	10800d8b 	ldhu	r2,54(r2)
8111d638:	10bfffcc 	andi	r2,r2,65535
8111d63c:	10800228 	cmpgeui	r2,r2,8
8111d640:	1000071e 	bne	r2,zero,8111d660 <vFailTimeoutCheckerTaskCreate+0x4c>
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
8111d644:	d0a06217 	ldw	r2,-32376(gp)
8111d648:	100f883a 	mov	r7,r2
8111d64c:	01800a04 	movi	r6,40
8111d650:	01400044 	movi	r5,1
8111d654:	01204574 	movhi	r4,33045
8111d658:	2102a504 	addi	r4,r4,2708
8111d65c:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d660:	0001883a 	nop
8111d664:	e037883a 	mov	sp,fp
8111d668:	dfc00117 	ldw	ra,4(sp)
8111d66c:	df000017 	ldw	fp,0(sp)
8111d670:	dec00204 	addi	sp,sp,8
8111d674:	f800283a 	ret

8111d678 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
8111d678:	defffe04 	addi	sp,sp,-8
8111d67c:	de00012e 	bgeu	sp,et,8111d684 <vFailGetBlockingSemTimeoutTask+0xc>
8111d680:	003b68fa 	trap	3
8111d684:	dfc00115 	stw	ra,4(sp)
8111d688:	df000015 	stw	fp,0(sp)
8111d68c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d690:	00a045b4 	movhi	r2,33046
8111d694:	109fe204 	addi	r2,r2,32648
8111d698:	10800d8b 	ldhu	r2,54(r2)
8111d69c:	10bfffcc 	andi	r2,r2,65535
8111d6a0:	10800228 	cmpgeui	r2,r2,8
8111d6a4:	10000e1e 	bne	r2,zero,8111d6e0 <vFailGetBlockingSemTimeoutTask+0x68>
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
8111d6a8:	d0a06217 	ldw	r2,-32376(gp)
8111d6ac:	100f883a 	mov	r7,r2
8111d6b0:	018009c4 	movi	r6,39
8111d6b4:	01400044 	movi	r5,1
8111d6b8:	01204574 	movhi	r4,33045
8111d6bc:	2102b004 	addi	r4,r4,2752
8111d6c0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
8111d6c4:	d0a06217 	ldw	r2,-32376(gp)
8111d6c8:	100f883a 	mov	r7,r2
8111d6cc:	01800cc4 	movi	r6,51
8111d6d0:	01400044 	movi	r5,1
8111d6d4:	01204574 	movhi	r4,33045
8111d6d8:	2102ba04 	addi	r4,r4,2792
8111d6dc:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d6e0:	0001883a 	nop
8111d6e4:	e037883a 	mov	sp,fp
8111d6e8:	dfc00117 	ldw	ra,4(sp)
8111d6ec:	df000017 	ldw	fp,0(sp)
8111d6f0:	dec00204 	addi	sp,sp,8
8111d6f4:	f800283a 	ret

8111d6f8 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
8111d6f8:	defffe04 	addi	sp,sp,-8
8111d6fc:	de00012e 	bgeu	sp,et,8111d704 <vFailPostBlockingSemTimeoutTask+0xc>
8111d700:	003b68fa 	trap	3
8111d704:	dfc00115 	stw	ra,4(sp)
8111d708:	df000015 	stw	fp,0(sp)
8111d70c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d710:	00a045b4 	movhi	r2,33046
8111d714:	109fe204 	addi	r2,r2,32648
8111d718:	10800d8b 	ldhu	r2,54(r2)
8111d71c:	10bfffcc 	andi	r2,r2,65535
8111d720:	10800228 	cmpgeui	r2,r2,8
8111d724:	10000e1e 	bne	r2,zero,8111d760 <vFailPostBlockingSemTimeoutTask+0x68>
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
8111d728:	d0a06217 	ldw	r2,-32376(gp)
8111d72c:	100f883a 	mov	r7,r2
8111d730:	01800a04 	movi	r6,40
8111d734:	01400044 	movi	r5,1
8111d738:	01204574 	movhi	r4,33045
8111d73c:	2102c704 	addi	r4,r4,2844
8111d740:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
8111d744:	d0a06217 	ldw	r2,-32376(gp)
8111d748:	100f883a 	mov	r7,r2
8111d74c:	01800c84 	movi	r6,50
8111d750:	01400044 	movi	r5,1
8111d754:	01204574 	movhi	r4,33045
8111d758:	2102d204 	addi	r4,r4,2888
8111d75c:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d760:	0001883a 	nop
8111d764:	e037883a 	mov	sp,fp
8111d768:	dfc00117 	ldw	ra,4(sp)
8111d76c:	df000017 	ldw	fp,0(sp)
8111d770:	dec00204 	addi	sp,sp,8
8111d774:	f800283a 	ret

8111d778 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
8111d778:	defffe04 	addi	sp,sp,-8
8111d77c:	de00012e 	bgeu	sp,et,8111d784 <vFailCouldNotRetransmitTimeoutTask+0xc>
8111d780:	003b68fa 	trap	3
8111d784:	dfc00115 	stw	ra,4(sp)
8111d788:	df000015 	stw	fp,0(sp)
8111d78c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d790:	00a045b4 	movhi	r2,33046
8111d794:	109fe204 	addi	r2,r2,32648
8111d798:	10800d8b 	ldhu	r2,54(r2)
8111d79c:	10bfffcc 	andi	r2,r2,65535
8111d7a0:	10800228 	cmpgeui	r2,r2,8
8111d7a4:	10000e1e 	bne	r2,zero,8111d7e0 <vFailCouldNotRetransmitTimeoutTask+0x68>
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
8111d7a8:	d0a06217 	ldw	r2,-32376(gp)
8111d7ac:	100f883a 	mov	r7,r2
8111d7b0:	01800ac4 	movi	r6,43
8111d7b4:	01400044 	movi	r5,1
8111d7b8:	01204574 	movhi	r4,33045
8111d7bc:	2102df04 	addi	r4,r4,2940
8111d7c0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
8111d7c4:	d0a06217 	ldw	r2,-32376(gp)
8111d7c8:	100f883a 	mov	r7,r2
8111d7cc:	01801644 	movi	r6,89
8111d7d0:	01400044 	movi	r5,1
8111d7d4:	01204574 	movhi	r4,33045
8111d7d8:	2102ea04 	addi	r4,r4,2984
8111d7dc:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d7e0:	0001883a 	nop
8111d7e4:	e037883a 	mov	sp,fp
8111d7e8:	dfc00117 	ldw	ra,4(sp)
8111d7ec:	df000017 	ldw	fp,0(sp)
8111d7f0:	dec00204 	addi	sp,sp,8
8111d7f4:	f800283a 	ret

8111d7f8 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
8111d7f8:	defffe04 	addi	sp,sp,-8
8111d7fc:	de00012e 	bgeu	sp,et,8111d804 <vCouldNotRetransmitB32TimeoutTask+0xc>
8111d800:	003b68fa 	trap	3
8111d804:	dfc00115 	stw	ra,4(sp)
8111d808:	df000015 	stw	fp,0(sp)
8111d80c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d810:	00a045b4 	movhi	r2,33046
8111d814:	109fe204 	addi	r2,r2,32648
8111d818:	10800d8b 	ldhu	r2,54(r2)
8111d81c:	10bfffcc 	andi	r2,r2,65535
8111d820:	10800228 	cmpgeui	r2,r2,8
8111d824:	10000e1e 	bne	r2,zero,8111d860 <vCouldNotRetransmitB32TimeoutTask+0x68>
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
8111d828:	d0a06217 	ldw	r2,-32376(gp)
8111d82c:	100f883a 	mov	r7,r2
8111d830:	01800a84 	movi	r6,42
8111d834:	01400044 	movi	r5,1
8111d838:	01204574 	movhi	r4,33045
8111d83c:	21030104 	addi	r4,r4,3076
8111d840:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
8111d844:	d0a06217 	ldw	r2,-32376(gp)
8111d848:	100f883a 	mov	r7,r2
8111d84c:	01801444 	movi	r6,81
8111d850:	01400044 	movi	r5,1
8111d854:	01204574 	movhi	r4,33045
8111d858:	21030c04 	addi	r4,r4,3120
8111d85c:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d860:	0001883a 	nop
8111d864:	e037883a 	mov	sp,fp
8111d868:	dfc00117 	ldw	ra,4(sp)
8111d86c:	df000017 	ldw	fp,0(sp)
8111d870:	dec00204 	addi	sp,sp,8
8111d874:	f800283a 	ret

8111d878 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
8111d878:	defffe04 	addi	sp,sp,-8
8111d87c:	de00012e 	bgeu	sp,et,8111d884 <vCouldNotRetransmitB64TimeoutTask+0xc>
8111d880:	003b68fa 	trap	3
8111d884:	dfc00115 	stw	ra,4(sp)
8111d888:	df000015 	stw	fp,0(sp)
8111d88c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d890:	00a045b4 	movhi	r2,33046
8111d894:	109fe204 	addi	r2,r2,32648
8111d898:	10800d8b 	ldhu	r2,54(r2)
8111d89c:	10bfffcc 	andi	r2,r2,65535
8111d8a0:	10800228 	cmpgeui	r2,r2,8
8111d8a4:	10000e1e 	bne	r2,zero,8111d8e0 <vCouldNotRetransmitB64TimeoutTask+0x68>
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
8111d8a8:	d0a06217 	ldw	r2,-32376(gp)
8111d8ac:	100f883a 	mov	r7,r2
8111d8b0:	01800a84 	movi	r6,42
8111d8b4:	01400044 	movi	r5,1
8111d8b8:	01204574 	movhi	r4,33045
8111d8bc:	21032104 	addi	r4,r4,3204
8111d8c0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
8111d8c4:	d0a06217 	ldw	r2,-32376(gp)
8111d8c8:	100f883a 	mov	r7,r2
8111d8cc:	01801444 	movi	r6,81
8111d8d0:	01400044 	movi	r5,1
8111d8d4:	01204574 	movhi	r4,33045
8111d8d8:	21032c04 	addi	r4,r4,3248
8111d8dc:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d8e0:	0001883a 	nop
8111d8e4:	e037883a 	mov	sp,fp
8111d8e8:	dfc00117 	ldw	ra,4(sp)
8111d8ec:	df000017 	ldw	fp,0(sp)
8111d8f0:	dec00204 	addi	sp,sp,8
8111d8f4:	f800283a 	ret

8111d8f8 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
8111d8f8:	defffe04 	addi	sp,sp,-8
8111d8fc:	de00012e 	bgeu	sp,et,8111d904 <vCouldNotRetransmitB128TimeoutTask+0xc>
8111d900:	003b68fa 	trap	3
8111d904:	dfc00115 	stw	ra,4(sp)
8111d908:	df000015 	stw	fp,0(sp)
8111d90c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d910:	00a045b4 	movhi	r2,33046
8111d914:	109fe204 	addi	r2,r2,32648
8111d918:	10800d8b 	ldhu	r2,54(r2)
8111d91c:	10bfffcc 	andi	r2,r2,65535
8111d920:	10800228 	cmpgeui	r2,r2,8
8111d924:	10000e1e 	bne	r2,zero,8111d960 <vCouldNotRetransmitB128TimeoutTask+0x68>
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
8111d928:	d0a06217 	ldw	r2,-32376(gp)
8111d92c:	100f883a 	mov	r7,r2
8111d930:	01800ac4 	movi	r6,43
8111d934:	01400044 	movi	r5,1
8111d938:	01204574 	movhi	r4,33045
8111d93c:	21034104 	addi	r4,r4,3332
8111d940:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
8111d944:	d0a06217 	ldw	r2,-32376(gp)
8111d948:	100f883a 	mov	r7,r2
8111d94c:	01801484 	movi	r6,82
8111d950:	01400044 	movi	r5,1
8111d954:	01204574 	movhi	r4,33045
8111d958:	21034c04 	addi	r4,r4,3376
8111d95c:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d960:	0001883a 	nop
8111d964:	e037883a 	mov	sp,fp
8111d968:	dfc00117 	ldw	ra,4(sp)
8111d96c:	df000017 	ldw	fp,0(sp)
8111d970:	dec00204 	addi	sp,sp,8
8111d974:	f800283a 	ret

8111d978 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
8111d978:	defffe04 	addi	sp,sp,-8
8111d97c:	de00012e 	bgeu	sp,et,8111d984 <vFailStartTimerRetransmission+0xc>
8111d980:	003b68fa 	trap	3
8111d984:	dfc00115 	stw	ra,4(sp)
8111d988:	df000015 	stw	fp,0(sp)
8111d98c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111d990:	00a045b4 	movhi	r2,33046
8111d994:	109fe204 	addi	r2,r2,32648
8111d998:	10800d8b 	ldhu	r2,54(r2)
8111d99c:	10bfffcc 	andi	r2,r2,65535
8111d9a0:	10800228 	cmpgeui	r2,r2,8
8111d9a4:	10000e1e 	bne	r2,zero,8111d9e0 <vFailStartTimerRetransmission+0x68>
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
8111d9a8:	d0a06217 	ldw	r2,-32376(gp)
8111d9ac:	100f883a 	mov	r7,r2
8111d9b0:	01800984 	movi	r6,38
8111d9b4:	01400044 	movi	r5,1
8111d9b8:	01204574 	movhi	r4,33045
8111d9bc:	21036104 	addi	r4,r4,3460
8111d9c0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
8111d9c4:	d0a06217 	ldw	r2,-32376(gp)
8111d9c8:	100f883a 	mov	r7,r2
8111d9cc:	01800d44 	movi	r6,53
8111d9d0:	01400044 	movi	r5,1
8111d9d4:	01204574 	movhi	r4,33045
8111d9d8:	21036b04 	addi	r4,r4,3500
8111d9dc:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d9e0:	0001883a 	nop
8111d9e4:	e037883a 	mov	sp,fp
8111d9e8:	dfc00117 	ldw	ra,4(sp)
8111d9ec:	df000017 	ldw	fp,0(sp)
8111d9f0:	dec00204 	addi	sp,sp,8
8111d9f4:	f800283a 	ret

8111d9f8 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
8111d9f8:	defffe04 	addi	sp,sp,-8
8111d9fc:	de00012e 	bgeu	sp,et,8111da04 <vCouldNotSendTurnOff+0xc>
8111da00:	003b68fa 	trap	3
8111da04:	dfc00115 	stw	ra,4(sp)
8111da08:	df000015 	stw	fp,0(sp)
8111da0c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111da10:	00a045b4 	movhi	r2,33046
8111da14:	109fe204 	addi	r2,r2,32648
8111da18:	10800d8b 	ldhu	r2,54(r2)
8111da1c:	10bfffcc 	andi	r2,r2,65535
8111da20:	10800228 	cmpgeui	r2,r2,8
8111da24:	10000e1e 	bne	r2,zero,8111da60 <vCouldNotSendTurnOff+0x68>
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
8111da28:	d0a06217 	ldw	r2,-32376(gp)
8111da2c:	100f883a 	mov	r7,r2
8111da30:	01800744 	movi	r6,29
8111da34:	01400044 	movi	r5,1
8111da38:	01204574 	movhi	r4,33045
8111da3c:	21037904 	addi	r4,r4,3556
8111da40:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not send the turn off command. \n");
8111da44:	d0a06217 	ldw	r2,-32376(gp)
8111da48:	100f883a 	mov	r7,r2
8111da4c:	01800984 	movi	r6,38
8111da50:	01400044 	movi	r5,1
8111da54:	01204574 	movhi	r4,33045
8111da58:	21038104 	addi	r4,r4,3588
8111da5c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111da60:	0001883a 	nop
8111da64:	e037883a 	mov	sp,fp
8111da68:	dfc00117 	ldw	ra,4(sp)
8111da6c:	df000017 	ldw	fp,0(sp)
8111da70:	dec00204 	addi	sp,sp,8
8111da74:	f800283a 	ret

8111da78 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
8111da78:	defffe04 	addi	sp,sp,-8
8111da7c:	de00012e 	bgeu	sp,et,8111da84 <vCouldNotSendReset+0xc>
8111da80:	003b68fa 	trap	3
8111da84:	dfc00115 	stw	ra,4(sp)
8111da88:	df000015 	stw	fp,0(sp)
8111da8c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111da90:	00a045b4 	movhi	r2,33046
8111da94:	109fe204 	addi	r2,r2,32648
8111da98:	10800d8b 	ldhu	r2,54(r2)
8111da9c:	10bfffcc 	andi	r2,r2,65535
8111daa0:	10800228 	cmpgeui	r2,r2,8
8111daa4:	10000e1e 	bne	r2,zero,8111dae0 <vCouldNotSendReset+0x68>
		debug(fp,"vCouldNotSendReset. (exit)\n");
8111daa8:	d0a06217 	ldw	r2,-32376(gp)
8111daac:	100f883a 	mov	r7,r2
8111dab0:	018006c4 	movi	r6,27
8111dab4:	01400044 	movi	r5,1
8111dab8:	01204574 	movhi	r4,33045
8111dabc:	21038b04 	addi	r4,r4,3628
8111dac0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not send the reset command. \n");
8111dac4:	d0a06217 	ldw	r2,-32376(gp)
8111dac8:	100f883a 	mov	r7,r2
8111dacc:	018008c4 	movi	r6,35
8111dad0:	01400044 	movi	r5,1
8111dad4:	01204574 	movhi	r4,33045
8111dad8:	21039204 	addi	r4,r4,3656
8111dadc:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dae0:	0001883a 	nop
8111dae4:	e037883a 	mov	sp,fp
8111dae8:	dfc00117 	ldw	ra,4(sp)
8111daec:	df000017 	ldw	fp,0(sp)
8111daf0:	dec00204 	addi	sp,sp,8
8111daf4:	f800283a 	ret

8111daf8 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
8111daf8:	defffe04 	addi	sp,sp,-8
8111dafc:	de00012e 	bgeu	sp,et,8111db04 <vCouldNotSendLog+0xc>
8111db00:	003b68fa 	trap	3
8111db04:	dfc00115 	stw	ra,4(sp)
8111db08:	df000015 	stw	fp,0(sp)
8111db0c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111db10:	00a045b4 	movhi	r2,33046
8111db14:	109fe204 	addi	r2,r2,32648
8111db18:	10800d8b 	ldhu	r2,54(r2)
8111db1c:	10bfffcc 	andi	r2,r2,65535
8111db20:	10800228 	cmpgeui	r2,r2,8
8111db24:	10000e1e 	bne	r2,zero,8111db60 <vCouldNotSendLog+0x68>
		debug(fp,"vCouldNotSendLog. (exit)\n");
8111db28:	d0a06217 	ldw	r2,-32376(gp)
8111db2c:	100f883a 	mov	r7,r2
8111db30:	01800644 	movi	r6,25
8111db34:	01400044 	movi	r5,1
8111db38:	01204574 	movhi	r4,33045
8111db3c:	21039b04 	addi	r4,r4,3692
8111db40:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not send log packet to NUC. \n");
8111db44:	d0a06217 	ldw	r2,-32376(gp)
8111db48:	100f883a 	mov	r7,r2
8111db4c:	018008c4 	movi	r6,35
8111db50:	01400044 	movi	r5,1
8111db54:	01204574 	movhi	r4,33045
8111db58:	2103a204 	addi	r4,r4,3720
8111db5c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111db60:	0001883a 	nop
8111db64:	e037883a 	mov	sp,fp
8111db68:	dfc00117 	ldw	ra,4(sp)
8111db6c:	df000017 	ldw	fp,0(sp)
8111db70:	dec00204 	addi	sp,sp,8
8111db74:	f800283a 	ret

8111db78 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
8111db78:	defffd04 	addi	sp,sp,-12
8111db7c:	de00012e 	bgeu	sp,et,8111db84 <vCouldNotSendTMPusCommand+0xc>
8111db80:	003b68fa 	trap	3
8111db84:	dfc00215 	stw	ra,8(sp)
8111db88:	df000115 	stw	fp,4(sp)
8111db8c:	df000104 	addi	fp,sp,4
8111db90:	e13fff15 	stw	r4,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111db94:	00a045b4 	movhi	r2,33046
8111db98:	109fe204 	addi	r2,r2,32648
8111db9c:	10800d8b 	ldhu	r2,54(r2)
8111dba0:	10bfffcc 	andi	r2,r2,65535
8111dba4:	10800228 	cmpgeui	r2,r2,8
8111dba8:	1000151e 	bne	r2,zero,8111dc00 <vCouldNotSendTMPusCommand+0x88>
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
8111dbac:	d0a06217 	ldw	r2,-32376(gp)
8111dbb0:	100f883a 	mov	r7,r2
8111dbb4:	01800884 	movi	r6,34
8111dbb8:	01400044 	movi	r5,1
8111dbbc:	01204574 	movhi	r4,33045
8111dbc0:	2103ab04 	addi	r4,r4,3756
8111dbc4:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not send the TM PUS command to NUC. \n");
8111dbc8:	d0a06217 	ldw	r2,-32376(gp)
8111dbcc:	100f883a 	mov	r7,r2
8111dbd0:	01800ac4 	movi	r6,43
8111dbd4:	01400044 	movi	r5,1
8111dbd8:	01204574 	movhi	r4,33045
8111dbdc:	2103b404 	addi	r4,r4,3792
8111dbe0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"cData");
8111dbe4:	d0a06217 	ldw	r2,-32376(gp)
8111dbe8:	100f883a 	mov	r7,r2
8111dbec:	01800144 	movi	r6,5
8111dbf0:	01400044 	movi	r5,1
8111dbf4:	01204574 	movhi	r4,33045
8111dbf8:	2103bf04 	addi	r4,r4,3836
8111dbfc:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dc00:	0001883a 	nop
8111dc04:	e037883a 	mov	sp,fp
8111dc08:	dfc00117 	ldw	ra,4(sp)
8111dc0c:	df000017 	ldw	fp,0(sp)
8111dc10:	dec00204 	addi	sp,sp,8
8111dc14:	f800283a 	ret

8111dc18 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
8111dc18:	defffe04 	addi	sp,sp,-8
8111dc1c:	de00012e 	bgeu	sp,et,8111dc24 <vWarnCouldNotgetMutexRetrans128+0xc>
8111dc20:	003b68fa 	trap	3
8111dc24:	dfc00115 	stw	ra,4(sp)
8111dc28:	df000015 	stw	fp,0(sp)
8111dc2c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dc30:	00a045b4 	movhi	r2,33046
8111dc34:	109fe204 	addi	r2,r2,32648
8111dc38:	10800d8b 	ldhu	r2,54(r2)
8111dc3c:	10bfffcc 	andi	r2,r2,65535
8111dc40:	10800228 	cmpgeui	r2,r2,8
8111dc44:	10000e1e 	bne	r2,zero,8111dc80 <vWarnCouldNotgetMutexRetrans128+0x68>
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
8111dc48:	d0a06217 	ldw	r2,-32376(gp)
8111dc4c:	100f883a 	mov	r7,r2
8111dc50:	01800a04 	movi	r6,40
8111dc54:	01400044 	movi	r5,1
8111dc58:	01204574 	movhi	r4,33045
8111dc5c:	2103c104 	addi	r4,r4,3844
8111dc60:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
8111dc64:	d0a06217 	ldw	r2,-32376(gp)
8111dc68:	100f883a 	mov	r7,r2
8111dc6c:	018014c4 	movi	r6,83
8111dc70:	01400044 	movi	r5,1
8111dc74:	01204574 	movhi	r4,33045
8111dc78:	2103cc04 	addi	r4,r4,3888
8111dc7c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dc80:	0001883a 	nop
8111dc84:	e037883a 	mov	sp,fp
8111dc88:	dfc00117 	ldw	ra,4(sp)
8111dc8c:	df000017 	ldw	fp,0(sp)
8111dc90:	dec00204 	addi	sp,sp,8
8111dc94:	f800283a 	ret

8111dc98 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
8111dc98:	defffe04 	addi	sp,sp,-8
8111dc9c:	de00012e 	bgeu	sp,et,8111dca4 <vFailCreateScheduleQueue+0xc>
8111dca0:	003b68fa 	trap	3
8111dca4:	dfc00115 	stw	ra,4(sp)
8111dca8:	df000015 	stw	fp,0(sp)
8111dcac:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dcb0:	00a045b4 	movhi	r2,33046
8111dcb4:	109fe204 	addi	r2,r2,32648
8111dcb8:	10800d8b 	ldhu	r2,54(r2)
8111dcbc:	10bfffcc 	andi	r2,r2,65535
8111dcc0:	10800228 	cmpgeui	r2,r2,8
8111dcc4:	10000e1e 	bne	r2,zero,8111dd00 <vFailCreateScheduleQueue+0x68>
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
8111dcc8:	d0a06217 	ldw	r2,-32376(gp)
8111dccc:	100f883a 	mov	r7,r2
8111dcd0:	01800844 	movi	r6,33
8111dcd4:	01400044 	movi	r5,1
8111dcd8:	01204574 	movhi	r4,33045
8111dcdc:	2103e104 	addi	r4,r4,3972
8111dce0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
8111dce4:	d0a06217 	ldw	r2,-32376(gp)
8111dce8:	100f883a 	mov	r7,r2
8111dcec:	01801204 	movi	r6,72
8111dcf0:	01400044 	movi	r5,1
8111dcf4:	01204574 	movhi	r4,33045
8111dcf8:	2103ea04 	addi	r4,r4,4008
8111dcfc:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dd00:	0001883a 	nop
8111dd04:	e037883a 	mov	sp,fp
8111dd08:	dfc00117 	ldw	ra,4(sp)
8111dd0c:	df000017 	ldw	fp,0(sp)
8111dd10:	dec00204 	addi	sp,sp,8
8111dd14:	f800283a 	ret

8111dd18 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
8111dd18:	defffd04 	addi	sp,sp,-12
8111dd1c:	de00012e 	bgeu	sp,et,8111dd24 <vFailCreateNFEEQueue+0xc>
8111dd20:	003b68fa 	trap	3
8111dd24:	dfc00215 	stw	ra,8(sp)
8111dd28:	df000115 	stw	fp,4(sp)
8111dd2c:	df000104 	addi	fp,sp,4
8111dd30:	2005883a 	mov	r2,r4
8111dd34:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dd38:	00a045b4 	movhi	r2,33046
8111dd3c:	109fe204 	addi	r2,r2,32648
8111dd40:	10800d8b 	ldhu	r2,54(r2)
8111dd44:	10bfffcc 	andi	r2,r2,65535
8111dd48:	10800228 	cmpgeui	r2,r2,8
8111dd4c:	10000e1e 	bne	r2,zero,8111dd88 <vFailCreateNFEEQueue+0x70>
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
8111dd50:	d0a06217 	ldw	r2,-32376(gp)
8111dd54:	100f883a 	mov	r7,r2
8111dd58:	01800744 	movi	r6,29
8111dd5c:	01400044 	movi	r5,1
8111dd60:	01204574 	movhi	r4,33045
8111dd64:	2103fd04 	addi	r4,r4,4084
8111dd68:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
8111dd6c:	d0a06217 	ldw	r2,-32376(gp)
8111dd70:	e0ffff03 	ldbu	r3,-4(fp)
8111dd74:	180d883a 	mov	r6,r3
8111dd78:	01604574 	movhi	r5,33045
8111dd7c:	29440504 	addi	r5,r5,4116
8111dd80:	1009883a 	mov	r4,r2
8111dd84:	112292c0 	call	8112292c <fprintf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111dd88:	0001883a 	nop
8111dd8c:	e037883a 	mov	sp,fp
8111dd90:	dfc00117 	ldw	ra,4(sp)
8111dd94:	df000017 	ldw	fp,0(sp)
8111dd98:	dec00204 	addi	sp,sp,8
8111dd9c:	f800283a 	ret

8111dda0 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
8111dda0:	defffd04 	addi	sp,sp,-12
8111dda4:	de00012e 	bgeu	sp,et,8111ddac <vFailCreateNFEESyncQueue+0xc>
8111dda8:	003b68fa 	trap	3
8111ddac:	dfc00215 	stw	ra,8(sp)
8111ddb0:	df000115 	stw	fp,4(sp)
8111ddb4:	df000104 	addi	fp,sp,4
8111ddb8:	2005883a 	mov	r2,r4
8111ddbc:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ddc0:	00a045b4 	movhi	r2,33046
8111ddc4:	109fe204 	addi	r2,r2,32648
8111ddc8:	10800d8b 	ldhu	r2,54(r2)
8111ddcc:	10bfffcc 	andi	r2,r2,65535
8111ddd0:	10800228 	cmpgeui	r2,r2,8
8111ddd4:	10000e1e 	bne	r2,zero,8111de10 <vFailCreateNFEESyncQueue+0x70>
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
8111ddd8:	d0a06217 	ldw	r2,-32376(gp)
8111dddc:	100f883a 	mov	r7,r2
8111dde0:	01800844 	movi	r6,33
8111dde4:	01400044 	movi	r5,1
8111dde8:	01204574 	movhi	r4,33045
8111ddec:	21041304 	addi	r4,r4,4172
8111ddf0:	1122fc80 	call	81122fc8 <fwrite>
		fprintf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
8111ddf4:	d0a06217 	ldw	r2,-32376(gp)
8111ddf8:	e0ffff03 	ldbu	r3,-4(fp)
8111ddfc:	180d883a 	mov	r6,r3
8111de00:	01604574 	movhi	r5,33045
8111de04:	29441c04 	addi	r5,r5,4208
8111de08:	1009883a 	mov	r4,r2
8111de0c:	112292c0 	call	8112292c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111de10:	0001883a 	nop
8111de14:	e037883a 	mov	sp,fp
8111de18:	dfc00117 	ldw	ra,4(sp)
8111de1c:	df000017 	ldw	fp,0(sp)
8111de20:	dec00204 	addi	sp,sp,8
8111de24:	f800283a 	ret

8111de28 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
8111de28:	defffe04 	addi	sp,sp,-8
8111de2c:	de00012e 	bgeu	sp,et,8111de34 <vCoudlNotCreateNFee0Task+0xc>
8111de30:	003b68fa 	trap	3
8111de34:	dfc00115 	stw	ra,4(sp)
8111de38:	df000015 	stw	fp,0(sp)
8111de3c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111de40:	00a045b4 	movhi	r2,33046
8111de44:	109fe204 	addi	r2,r2,32648
8111de48:	10800d8b 	ldhu	r2,54(r2)
8111de4c:	10bfffcc 	andi	r2,r2,65535
8111de50:	10800228 	cmpgeui	r2,r2,8
8111de54:	10000e1e 	bne	r2,zero,8111de90 <vCoudlNotCreateNFee0Task+0x68>
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
8111de58:	d0a06217 	ldw	r2,-32376(gp)
8111de5c:	100f883a 	mov	r7,r2
8111de60:	01800844 	movi	r6,33
8111de64:	01400044 	movi	r5,1
8111de68:	01204574 	movhi	r4,33045
8111de6c:	21042a04 	addi	r4,r4,4264
8111de70:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not create NFEE 0 Task.\n");
8111de74:	d0a06217 	ldw	r2,-32376(gp)
8111de78:	100f883a 	mov	r7,r2
8111de7c:	01800784 	movi	r6,30
8111de80:	01400044 	movi	r5,1
8111de84:	01204574 	movhi	r4,33045
8111de88:	21043304 	addi	r4,r4,4300
8111de8c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111de90:	0001883a 	nop
8111de94:	e037883a 	mov	sp,fp
8111de98:	dfc00117 	ldw	ra,4(sp)
8111de9c:	df000017 	ldw	fp,0(sp)
8111dea0:	dec00204 	addi	sp,sp,8
8111dea4:	f800283a 	ret

8111dea8 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
8111dea8:	defffe04 	addi	sp,sp,-8
8111deac:	de00012e 	bgeu	sp,et,8111deb4 <vCoudlNotCreateNFee1Task+0xc>
8111deb0:	003b68fa 	trap	3
8111deb4:	dfc00115 	stw	ra,4(sp)
8111deb8:	df000015 	stw	fp,0(sp)
8111debc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dec0:	00a045b4 	movhi	r2,33046
8111dec4:	109fe204 	addi	r2,r2,32648
8111dec8:	10800d8b 	ldhu	r2,54(r2)
8111decc:	10bfffcc 	andi	r2,r2,65535
8111ded0:	10800228 	cmpgeui	r2,r2,8
8111ded4:	10000e1e 	bne	r2,zero,8111df10 <vCoudlNotCreateNFee1Task+0x68>
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
8111ded8:	d0a06217 	ldw	r2,-32376(gp)
8111dedc:	100f883a 	mov	r7,r2
8111dee0:	01800844 	movi	r6,33
8111dee4:	01400044 	movi	r5,1
8111dee8:	01204574 	movhi	r4,33045
8111deec:	21043b04 	addi	r4,r4,4332
8111def0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not create NFEE 1 Task.\n");
8111def4:	d0a06217 	ldw	r2,-32376(gp)
8111def8:	100f883a 	mov	r7,r2
8111defc:	01800784 	movi	r6,30
8111df00:	01400044 	movi	r5,1
8111df04:	01204574 	movhi	r4,33045
8111df08:	21044404 	addi	r4,r4,4368
8111df0c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111df10:	0001883a 	nop
8111df14:	e037883a 	mov	sp,fp
8111df18:	dfc00117 	ldw	ra,4(sp)
8111df1c:	df000017 	ldw	fp,0(sp)
8111df20:	dec00204 	addi	sp,sp,8
8111df24:	f800283a 	ret

8111df28 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
8111df28:	defffe04 	addi	sp,sp,-8
8111df2c:	de00012e 	bgeu	sp,et,8111df34 <vCoudlNotCreateNFee2Task+0xc>
8111df30:	003b68fa 	trap	3
8111df34:	dfc00115 	stw	ra,4(sp)
8111df38:	df000015 	stw	fp,0(sp)
8111df3c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111df40:	00a045b4 	movhi	r2,33046
8111df44:	109fe204 	addi	r2,r2,32648
8111df48:	10800d8b 	ldhu	r2,54(r2)
8111df4c:	10bfffcc 	andi	r2,r2,65535
8111df50:	10800228 	cmpgeui	r2,r2,8
8111df54:	10000e1e 	bne	r2,zero,8111df90 <vCoudlNotCreateNFee2Task+0x68>
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
8111df58:	d0a06217 	ldw	r2,-32376(gp)
8111df5c:	100f883a 	mov	r7,r2
8111df60:	01800844 	movi	r6,33
8111df64:	01400044 	movi	r5,1
8111df68:	01204574 	movhi	r4,33045
8111df6c:	21044c04 	addi	r4,r4,4400
8111df70:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not create NFEE 2 Task.\n");
8111df74:	d0a06217 	ldw	r2,-32376(gp)
8111df78:	100f883a 	mov	r7,r2
8111df7c:	01800784 	movi	r6,30
8111df80:	01400044 	movi	r5,1
8111df84:	01204574 	movhi	r4,33045
8111df88:	21045504 	addi	r4,r4,4436
8111df8c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111df90:	0001883a 	nop
8111df94:	e037883a 	mov	sp,fp
8111df98:	dfc00117 	ldw	ra,4(sp)
8111df9c:	df000017 	ldw	fp,0(sp)
8111dfa0:	dec00204 	addi	sp,sp,8
8111dfa4:	f800283a 	ret

8111dfa8 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
8111dfa8:	defffe04 	addi	sp,sp,-8
8111dfac:	de00012e 	bgeu	sp,et,8111dfb4 <vCoudlNotCreateNFee3Task+0xc>
8111dfb0:	003b68fa 	trap	3
8111dfb4:	dfc00115 	stw	ra,4(sp)
8111dfb8:	df000015 	stw	fp,0(sp)
8111dfbc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111dfc0:	00a045b4 	movhi	r2,33046
8111dfc4:	109fe204 	addi	r2,r2,32648
8111dfc8:	10800d8b 	ldhu	r2,54(r2)
8111dfcc:	10bfffcc 	andi	r2,r2,65535
8111dfd0:	10800228 	cmpgeui	r2,r2,8
8111dfd4:	10000e1e 	bne	r2,zero,8111e010 <vCoudlNotCreateNFee3Task+0x68>
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
8111dfd8:	d0a06217 	ldw	r2,-32376(gp)
8111dfdc:	100f883a 	mov	r7,r2
8111dfe0:	01800844 	movi	r6,33
8111dfe4:	01400044 	movi	r5,1
8111dfe8:	01204574 	movhi	r4,33045
8111dfec:	21045d04 	addi	r4,r4,4468
8111dff0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not create NFEE 3 Task.\n");
8111dff4:	d0a06217 	ldw	r2,-32376(gp)
8111dff8:	100f883a 	mov	r7,r2
8111dffc:	01800784 	movi	r6,30
8111e000:	01400044 	movi	r5,1
8111e004:	01204574 	movhi	r4,33045
8111e008:	21046604 	addi	r4,r4,4504
8111e00c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e010:	0001883a 	nop
8111e014:	e037883a 	mov	sp,fp
8111e018:	dfc00117 	ldw	ra,4(sp)
8111e01c:	df000017 	ldw	fp,0(sp)
8111e020:	dec00204 	addi	sp,sp,8
8111e024:	f800283a 	ret

8111e028 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
8111e028:	defffe04 	addi	sp,sp,-8
8111e02c:	de00012e 	bgeu	sp,et,8111e034 <vCoudlNotCreateNFee4Task+0xc>
8111e030:	003b68fa 	trap	3
8111e034:	dfc00115 	stw	ra,4(sp)
8111e038:	df000015 	stw	fp,0(sp)
8111e03c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e040:	00a045b4 	movhi	r2,33046
8111e044:	109fe204 	addi	r2,r2,32648
8111e048:	10800d8b 	ldhu	r2,54(r2)
8111e04c:	10bfffcc 	andi	r2,r2,65535
8111e050:	10800228 	cmpgeui	r2,r2,8
8111e054:	10000e1e 	bne	r2,zero,8111e090 <vCoudlNotCreateNFee4Task+0x68>
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
8111e058:	d0a06217 	ldw	r2,-32376(gp)
8111e05c:	100f883a 	mov	r7,r2
8111e060:	01800844 	movi	r6,33
8111e064:	01400044 	movi	r5,1
8111e068:	01204574 	movhi	r4,33045
8111e06c:	21046e04 	addi	r4,r4,4536
8111e070:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not create NFEE 4 Task.\n");
8111e074:	d0a06217 	ldw	r2,-32376(gp)
8111e078:	100f883a 	mov	r7,r2
8111e07c:	01800784 	movi	r6,30
8111e080:	01400044 	movi	r5,1
8111e084:	01204574 	movhi	r4,33045
8111e088:	21047704 	addi	r4,r4,4572
8111e08c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e090:	0001883a 	nop
8111e094:	e037883a 	mov	sp,fp
8111e098:	dfc00117 	ldw	ra,4(sp)
8111e09c:	df000017 	ldw	fp,0(sp)
8111e0a0:	dec00204 	addi	sp,sp,8
8111e0a4:	f800283a 	ret

8111e0a8 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
8111e0a8:	defffe04 	addi	sp,sp,-8
8111e0ac:	de00012e 	bgeu	sp,et,8111e0b4 <vCoudlNotCreateNFee5Task+0xc>
8111e0b0:	003b68fa 	trap	3
8111e0b4:	dfc00115 	stw	ra,4(sp)
8111e0b8:	df000015 	stw	fp,0(sp)
8111e0bc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e0c0:	00a045b4 	movhi	r2,33046
8111e0c4:	109fe204 	addi	r2,r2,32648
8111e0c8:	10800d8b 	ldhu	r2,54(r2)
8111e0cc:	10bfffcc 	andi	r2,r2,65535
8111e0d0:	10800228 	cmpgeui	r2,r2,8
8111e0d4:	10000e1e 	bne	r2,zero,8111e110 <vCoudlNotCreateNFee5Task+0x68>
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
8111e0d8:	d0a06217 	ldw	r2,-32376(gp)
8111e0dc:	100f883a 	mov	r7,r2
8111e0e0:	01800844 	movi	r6,33
8111e0e4:	01400044 	movi	r5,1
8111e0e8:	01204574 	movhi	r4,33045
8111e0ec:	21047f04 	addi	r4,r4,4604
8111e0f0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not create NFEE 5 Task.\n");
8111e0f4:	d0a06217 	ldw	r2,-32376(gp)
8111e0f8:	100f883a 	mov	r7,r2
8111e0fc:	01800784 	movi	r6,30
8111e100:	01400044 	movi	r5,1
8111e104:	01204574 	movhi	r4,33045
8111e108:	21048804 	addi	r4,r4,4640
8111e10c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e110:	0001883a 	nop
8111e114:	e037883a 	mov	sp,fp
8111e118:	dfc00117 	ldw	ra,4(sp)
8111e11c:	df000017 	ldw	fp,0(sp)
8111e120:	dec00204 	addi	sp,sp,8
8111e124:	f800283a 	ret

8111e128 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
8111e128:	defffe04 	addi	sp,sp,-8
8111e12c:	de00012e 	bgeu	sp,et,8111e134 <vCoudlNotCreateNFeeControllerTask+0xc>
8111e130:	003b68fa 	trap	3
8111e134:	dfc00115 	stw	ra,4(sp)
8111e138:	df000015 	stw	fp,0(sp)
8111e13c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e140:	00a045b4 	movhi	r2,33046
8111e144:	109fe204 	addi	r2,r2,32648
8111e148:	10800d8b 	ldhu	r2,54(r2)
8111e14c:	10bfffcc 	andi	r2,r2,65535
8111e150:	10800228 	cmpgeui	r2,r2,8
8111e154:	10000e1e 	bne	r2,zero,8111e190 <vCoudlNotCreateNFeeControllerTask+0x68>
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
8111e158:	d0a06217 	ldw	r2,-32376(gp)
8111e15c:	100f883a 	mov	r7,r2
8111e160:	01800a84 	movi	r6,42
8111e164:	01400044 	movi	r5,1
8111e168:	01204574 	movhi	r4,33045
8111e16c:	21049004 	addi	r4,r4,4672
8111e170:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not create NFEE Controller Task.\n");
8111e174:	d0a06217 	ldw	r2,-32376(gp)
8111e178:	100f883a 	mov	r7,r2
8111e17c:	018009c4 	movi	r6,39
8111e180:	01400044 	movi	r5,1
8111e184:	01204574 	movhi	r4,33045
8111e188:	21049b04 	addi	r4,r4,4716
8111e18c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e190:	0001883a 	nop
8111e194:	e037883a 	mov	sp,fp
8111e198:	dfc00117 	ldw	ra,4(sp)
8111e19c:	df000017 	ldw	fp,0(sp)
8111e1a0:	dec00204 	addi	sp,sp,8
8111e1a4:	f800283a 	ret

8111e1a8 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8111e1a8:	defffe04 	addi	sp,sp,-8
8111e1ac:	de00012e 	bgeu	sp,et,8111e1b4 <vCoudlNotCreateDataControllerTask+0xc>
8111e1b0:	003b68fa 	trap	3
8111e1b4:	dfc00115 	stw	ra,4(sp)
8111e1b8:	df000015 	stw	fp,0(sp)
8111e1bc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e1c0:	00a045b4 	movhi	r2,33046
8111e1c4:	109fe204 	addi	r2,r2,32648
8111e1c8:	10800d8b 	ldhu	r2,54(r2)
8111e1cc:	10bfffcc 	andi	r2,r2,65535
8111e1d0:	10800228 	cmpgeui	r2,r2,8
8111e1d4:	10000e1e 	bne	r2,zero,8111e210 <vCoudlNotCreateDataControllerTask+0x68>
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
8111e1d8:	d0a06217 	ldw	r2,-32376(gp)
8111e1dc:	100f883a 	mov	r7,r2
8111e1e0:	01800a84 	movi	r6,42
8111e1e4:	01400044 	movi	r5,1
8111e1e8:	01204574 	movhi	r4,33045
8111e1ec:	2104a504 	addi	r4,r4,4756
8111e1f0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not create Data Controller Task.\n");
8111e1f4:	d0a06217 	ldw	r2,-32376(gp)
8111e1f8:	100f883a 	mov	r7,r2
8111e1fc:	018009c4 	movi	r6,39
8111e200:	01400044 	movi	r5,1
8111e204:	01204574 	movhi	r4,33045
8111e208:	2104b004 	addi	r4,r4,4800
8111e20c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e210:	0001883a 	nop
8111e214:	e037883a 	mov	sp,fp
8111e218:	dfc00117 	ldw	ra,4(sp)
8111e21c:	df000017 	ldw	fp,0(sp)
8111e220:	dec00204 	addi	sp,sp,8
8111e224:	f800283a 	ret

8111e228 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
8111e228:	defffe04 	addi	sp,sp,-8
8111e22c:	de00012e 	bgeu	sp,et,8111e234 <vCoudlNotCreateMebTask+0xc>
8111e230:	003b68fa 	trap	3
8111e234:	dfc00115 	stw	ra,4(sp)
8111e238:	df000015 	stw	fp,0(sp)
8111e23c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e240:	00a045b4 	movhi	r2,33046
8111e244:	109fe204 	addi	r2,r2,32648
8111e248:	10800d8b 	ldhu	r2,54(r2)
8111e24c:	10bfffcc 	andi	r2,r2,65535
8111e250:	10800228 	cmpgeui	r2,r2,8
8111e254:	10000e1e 	bne	r2,zero,8111e290 <vCoudlNotCreateMebTask+0x68>
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
8111e258:	d0a06217 	ldw	r2,-32376(gp)
8111e25c:	100f883a 	mov	r7,r2
8111e260:	018007c4 	movi	r6,31
8111e264:	01400044 	movi	r5,1
8111e268:	01204574 	movhi	r4,33045
8111e26c:	2104ba04 	addi	r4,r4,4840
8111e270:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not create Meb Task.\n");
8111e274:	d0a06217 	ldw	r2,-32376(gp)
8111e278:	100f883a 	mov	r7,r2
8111e27c:	018006c4 	movi	r6,27
8111e280:	01400044 	movi	r5,1
8111e284:	01204574 	movhi	r4,33045
8111e288:	2104c204 	addi	r4,r4,4872
8111e28c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e290:	0001883a 	nop
8111e294:	e037883a 	mov	sp,fp
8111e298:	dfc00117 	ldw	ra,4(sp)
8111e29c:	df000017 	ldw	fp,0(sp)
8111e2a0:	dec00204 	addi	sp,sp,8
8111e2a4:	f800283a 	ret

8111e2a8 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
8111e2a8:	defffd04 	addi	sp,sp,-12
8111e2ac:	de00012e 	bgeu	sp,et,8111e2b4 <vFailCreateMutexSPUSQueueMeb+0xc>
8111e2b0:	003b68fa 	trap	3
8111e2b4:	dfc00215 	stw	ra,8(sp)
8111e2b8:	df000115 	stw	fp,4(sp)
8111e2bc:	df000104 	addi	fp,sp,4
8111e2c0:	2005883a 	mov	r2,r4
8111e2c4:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e2c8:	00a045b4 	movhi	r2,33046
8111e2cc:	109fe204 	addi	r2,r2,32648
8111e2d0:	10800d8b 	ldhu	r2,54(r2)
8111e2d4:	10bfffcc 	andi	r2,r2,65535
8111e2d8:	10800228 	cmpgeui	r2,r2,8
8111e2dc:	10000a1e 	bne	r2,zero,8111e308 <vFailCreateMutexSPUSQueueMeb+0x60>
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
8111e2e0:	d0a06217 	ldw	r2,-32376(gp)
8111e2e4:	100f883a 	mov	r7,r2
8111e2e8:	01800944 	movi	r6,37
8111e2ec:	01400044 	movi	r5,1
8111e2f0:	01204574 	movhi	r4,33045
8111e2f4:	2104c904 	addi	r4,r4,4900
8111e2f8:	1122fc80 	call	81122fc8 <fwrite>
		printErrorTask(error_code);
8111e2fc:	e0bfff03 	ldbu	r2,-4(fp)
8111e300:	1009883a 	mov	r4,r2
8111e304:	111c46c0 	call	8111c46c <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e308:	0001883a 	nop
8111e30c:	e037883a 	mov	sp,fp
8111e310:	dfc00117 	ldw	ra,4(sp)
8111e314:	df000017 	ldw	fp,0(sp)
8111e318:	dec00204 	addi	sp,sp,8
8111e31c:	f800283a 	ret

8111e320 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
8111e320:	defffe04 	addi	sp,sp,-8
8111e324:	de00012e 	bgeu	sp,et,8111e32c <vFailSendPUStoMebTask+0xc>
8111e328:	003b68fa 	trap	3
8111e32c:	dfc00115 	stw	ra,4(sp)
8111e330:	df000015 	stw	fp,0(sp)
8111e334:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e338:	00a045b4 	movhi	r2,33046
8111e33c:	109fe204 	addi	r2,r2,32648
8111e340:	10800d8b 	ldhu	r2,54(r2)
8111e344:	10bfffcc 	andi	r2,r2,65535
8111e348:	10800228 	cmpgeui	r2,r2,8
8111e34c:	1000071e 	bne	r2,zero,8111e36c <vFailSendPUStoMebTask+0x4c>
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
8111e350:	d0a06217 	ldw	r2,-32376(gp)
8111e354:	100f883a 	mov	r7,r2
8111e358:	01800784 	movi	r6,30
8111e35c:	01400044 	movi	r5,1
8111e360:	01204574 	movhi	r4,33045
8111e364:	2104d304 	addi	r4,r4,4940
8111e368:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e36c:	0001883a 	nop
8111e370:	e037883a 	mov	sp,fp
8111e374:	dfc00117 	ldw	ra,4(sp)
8111e378:	df000017 	ldw	fp,0(sp)
8111e37c:	dec00204 	addi	sp,sp,8
8111e380:	f800283a 	ret

8111e384 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
8111e384:	defffe04 	addi	sp,sp,-8
8111e388:	de00012e 	bgeu	sp,et,8111e390 <vCouldNotGetCmdQueueMeb+0xc>
8111e38c:	003b68fa 	trap	3
8111e390:	dfc00115 	stw	ra,4(sp)
8111e394:	df000015 	stw	fp,0(sp)
8111e398:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e39c:	00a045b4 	movhi	r2,33046
8111e3a0:	109fe204 	addi	r2,r2,32648
8111e3a4:	10800d8b 	ldhu	r2,54(r2)
8111e3a8:	10bfffcc 	andi	r2,r2,65535
8111e3ac:	10800228 	cmpgeui	r2,r2,8
8111e3b0:	10000e1e 	bne	r2,zero,8111e3ec <vCouldNotGetCmdQueueMeb+0x68>
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
8111e3b4:	d0a06217 	ldw	r2,-32376(gp)
8111e3b8:	100f883a 	mov	r7,r2
8111e3bc:	01800a84 	movi	r6,42
8111e3c0:	01400044 	movi	r5,1
8111e3c4:	01204574 	movhi	r4,33045
8111e3c8:	2104db04 	addi	r4,r4,4972
8111e3cc:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
8111e3d0:	d0a06217 	ldw	r2,-32376(gp)
8111e3d4:	100f883a 	mov	r7,r2
8111e3d8:	01800cc4 	movi	r6,51
8111e3dc:	01400044 	movi	r5,1
8111e3e0:	01204574 	movhi	r4,33045
8111e3e4:	2104e604 	addi	r4,r4,5016
8111e3e8:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e3ec:	0001883a 	nop
8111e3f0:	e037883a 	mov	sp,fp
8111e3f4:	dfc00117 	ldw	ra,4(sp)
8111e3f8:	df000017 	ldw	fp,0(sp)
8111e3fc:	dec00204 	addi	sp,sp,8
8111e400:	f800283a 	ret

8111e404 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
8111e404:	defffe04 	addi	sp,sp,-8
8111e408:	de00012e 	bgeu	sp,et,8111e410 <vCouldNotGetMutexMebPus+0xc>
8111e40c:	003b68fa 	trap	3
8111e410:	dfc00115 	stw	ra,4(sp)
8111e414:	df000015 	stw	fp,0(sp)
8111e418:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e41c:	00a045b4 	movhi	r2,33046
8111e420:	109fe204 	addi	r2,r2,32648
8111e424:	10800d8b 	ldhu	r2,54(r2)
8111e428:	10bfffcc 	andi	r2,r2,65535
8111e42c:	10800228 	cmpgeui	r2,r2,8
8111e430:	1000071e 	bne	r2,zero,8111e450 <vCouldNotGetMutexMebPus+0x4c>
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
8111e434:	d0a06217 	ldw	r2,-32376(gp)
8111e438:	100f883a 	mov	r7,r2
8111e43c:	01800804 	movi	r6,32
8111e440:	01400044 	movi	r5,1
8111e444:	01204574 	movhi	r4,33045
8111e448:	2104f304 	addi	r4,r4,5068
8111e44c:	1122fc80 	call	81122fc8 <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e450:	0001883a 	nop
8111e454:	e037883a 	mov	sp,fp
8111e458:	dfc00117 	ldw	ra,4(sp)
8111e45c:	df000017 	ldw	fp,0(sp)
8111e460:	dec00204 	addi	sp,sp,8
8111e464:	f800283a 	ret

8111e468 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
8111e468:	defffe04 	addi	sp,sp,-8
8111e46c:	de00012e 	bgeu	sp,et,8111e474 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
8111e470:	003b68fa 	trap	3
8111e474:	dfc00115 	stw	ra,4(sp)
8111e478:	df000015 	stw	fp,0(sp)
8111e47c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e480:	00a045b4 	movhi	r2,33046
8111e484:	109fe204 	addi	r2,r2,32648
8111e488:	10800d8b 	ldhu	r2,54(r2)
8111e48c:	10bfffcc 	andi	r2,r2,65535
8111e490:	10800228 	cmpgeui	r2,r2,8
8111e494:	10000e1e 	bne	r2,zero,8111e4d0 <vCouldNotCreateQueueMaskNfeeCtrl+0x68>
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
8111e498:	d0a06217 	ldw	r2,-32376(gp)
8111e49c:	100f883a 	mov	r7,r2
8111e4a0:	01800a44 	movi	r6,41
8111e4a4:	01400044 	movi	r5,1
8111e4a8:	01204574 	movhi	r4,33045
8111e4ac:	2104fc04 	addi	r4,r4,5104
8111e4b0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
8111e4b4:	d0a06217 	ldw	r2,-32376(gp)
8111e4b8:	100f883a 	mov	r7,r2
8111e4bc:	01800c84 	movi	r6,50
8111e4c0:	01400044 	movi	r5,1
8111e4c4:	01204574 	movhi	r4,33045
8111e4c8:	21050704 	addi	r4,r4,5148
8111e4cc:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e4d0:	0001883a 	nop
8111e4d4:	e037883a 	mov	sp,fp
8111e4d8:	dfc00117 	ldw	ra,4(sp)
8111e4dc:	df000017 	ldw	fp,0(sp)
8111e4e0:	dec00204 	addi	sp,sp,8
8111e4e4:	f800283a 	ret

8111e4e8 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
8111e4e8:	defffe04 	addi	sp,sp,-8
8111e4ec:	de00012e 	bgeu	sp,et,8111e4f4 <vCouldNotCreateQueueMaskDataCtrl+0xc>
8111e4f0:	003b68fa 	trap	3
8111e4f4:	dfc00115 	stw	ra,4(sp)
8111e4f8:	df000015 	stw	fp,0(sp)
8111e4fc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e500:	00a045b4 	movhi	r2,33046
8111e504:	109fe204 	addi	r2,r2,32648
8111e508:	10800d8b 	ldhu	r2,54(r2)
8111e50c:	10bfffcc 	andi	r2,r2,65535
8111e510:	10800228 	cmpgeui	r2,r2,8
8111e514:	10000e1e 	bne	r2,zero,8111e550 <vCouldNotCreateQueueMaskDataCtrl+0x68>
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
8111e518:	d0a06217 	ldw	r2,-32376(gp)
8111e51c:	100f883a 	mov	r7,r2
8111e520:	01800a44 	movi	r6,41
8111e524:	01400044 	movi	r5,1
8111e528:	01204574 	movhi	r4,33045
8111e52c:	21051404 	addi	r4,r4,5200
8111e530:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
8111e534:	d0a06217 	ldw	r2,-32376(gp)
8111e538:	100f883a 	mov	r7,r2
8111e53c:	01800c84 	movi	r6,50
8111e540:	01400044 	movi	r5,1
8111e544:	01204574 	movhi	r4,33045
8111e548:	21051f04 	addi	r4,r4,5244
8111e54c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e550:	0001883a 	nop
8111e554:	e037883a 	mov	sp,fp
8111e558:	dfc00117 	ldw	ra,4(sp)
8111e55c:	df000017 	ldw	fp,0(sp)
8111e560:	dec00204 	addi	sp,sp,8
8111e564:	f800283a 	ret

8111e568 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
8111e568:	defffe04 	addi	sp,sp,-8
8111e56c:	de00012e 	bgeu	sp,et,8111e574 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
8111e570:	003b68fa 	trap	3
8111e574:	dfc00115 	stw	ra,4(sp)
8111e578:	df000015 	stw	fp,0(sp)
8111e57c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e580:	00a045b4 	movhi	r2,33046
8111e584:	109fe204 	addi	r2,r2,32648
8111e588:	10800d8b 	ldhu	r2,54(r2)
8111e58c:	10bfffcc 	andi	r2,r2,65535
8111e590:	10800228 	cmpgeui	r2,r2,8
8111e594:	10000e1e 	bne	r2,zero,8111e5d0 <vCouldNotGetQueueMaskNfeeCtrl+0x68>
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
8111e598:	d0a06217 	ldw	r2,-32376(gp)
8111e59c:	100f883a 	mov	r7,r2
8111e5a0:	01800984 	movi	r6,38
8111e5a4:	01400044 	movi	r5,1
8111e5a8:	01204574 	movhi	r4,33045
8111e5ac:	21052c04 	addi	r4,r4,5296
8111e5b0:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
8111e5b4:	d0a06217 	ldw	r2,-32376(gp)
8111e5b8:	100f883a 	mov	r7,r2
8111e5bc:	01800bc4 	movi	r6,47
8111e5c0:	01400044 	movi	r5,1
8111e5c4:	01204574 	movhi	r4,33045
8111e5c8:	21053604 	addi	r4,r4,5336
8111e5cc:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e5d0:	0001883a 	nop
8111e5d4:	e037883a 	mov	sp,fp
8111e5d8:	dfc00117 	ldw	ra,4(sp)
8111e5dc:	df000017 	ldw	fp,0(sp)
8111e5e0:	dec00204 	addi	sp,sp,8
8111e5e4:	f800283a 	ret

8111e5e8 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8111e5e8:	defffe04 	addi	sp,sp,-8
8111e5ec:	de00012e 	bgeu	sp,et,8111e5f4 <vCouldNotGetQueueMaskDataCtrl+0xc>
8111e5f0:	003b68fa 	trap	3
8111e5f4:	dfc00115 	stw	ra,4(sp)
8111e5f8:	df000015 	stw	fp,0(sp)
8111e5fc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e600:	00a045b4 	movhi	r2,33046
8111e604:	109fe204 	addi	r2,r2,32648
8111e608:	10800d8b 	ldhu	r2,54(r2)
8111e60c:	10bfffcc 	andi	r2,r2,65535
8111e610:	10800228 	cmpgeui	r2,r2,8
8111e614:	10000e1e 	bne	r2,zero,8111e650 <vCouldNotGetQueueMaskDataCtrl+0x68>
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
8111e618:	d0a06217 	ldw	r2,-32376(gp)
8111e61c:	100f883a 	mov	r7,r2
8111e620:	01800984 	movi	r6,38
8111e624:	01400044 	movi	r5,1
8111e628:	01204574 	movhi	r4,33045
8111e62c:	21054204 	addi	r4,r4,5384
8111e630:	1122fc80 	call	81122fc8 <fwrite>
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
8111e634:	d0a06217 	ldw	r2,-32376(gp)
8111e638:	100f883a 	mov	r7,r2
8111e63c:	01800bc4 	movi	r6,47
8111e640:	01400044 	movi	r5,1
8111e644:	01204574 	movhi	r4,33045
8111e648:	21054c04 	addi	r4,r4,5424
8111e64c:	1122fc80 	call	81122fc8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e650:	0001883a 	nop
8111e654:	e037883a 	mov	sp,fp
8111e658:	dfc00117 	ldw	ra,4(sp)
8111e65c:	df000017 	ldw	fp,0(sp)
8111e660:	dec00204 	addi	sp,sp,8
8111e664:	f800283a 	ret

8111e668 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
8111e668:	defffd04 	addi	sp,sp,-12
8111e66c:	de00012e 	bgeu	sp,et,8111e674 <vFailSendMsgAccessDMA+0xc>
8111e670:	003b68fa 	trap	3
8111e674:	dfc00215 	stw	ra,8(sp)
8111e678:	df000115 	stw	fp,4(sp)
8111e67c:	df000104 	addi	fp,sp,4
8111e680:	2005883a 	mov	r2,r4
8111e684:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e688:	00a045b4 	movhi	r2,33046
8111e68c:	109fe204 	addi	r2,r2,32648
8111e690:	10800d8b 	ldhu	r2,54(r2)
8111e694:	10bfffcc 	andi	r2,r2,65535
8111e698:	10800228 	cmpgeui	r2,r2,8
8111e69c:	1000071e 	bne	r2,zero,8111e6bc <vFailSendMsgAccessDMA+0x54>
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n:%hhu \n", ucTemp);
8111e6a0:	d0a06217 	ldw	r2,-32376(gp)
8111e6a4:	e0ffff03 	ldbu	r3,-4(fp)
8111e6a8:	180d883a 	mov	r6,r3
8111e6ac:	01604574 	movhi	r5,33045
8111e6b0:	29455804 	addi	r5,r5,5472
8111e6b4:	1009883a 	mov	r4,r2
8111e6b8:	112292c0 	call	8112292c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e6bc:	0001883a 	nop
8111e6c0:	e037883a 	mov	sp,fp
8111e6c4:	dfc00117 	ldw	ra,4(sp)
8111e6c8:	df000017 	ldw	fp,0(sp)
8111e6cc:	dec00204 	addi	sp,sp,8
8111e6d0:	f800283a 	ret

8111e6d4 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
8111e6d4:	defffd04 	addi	sp,sp,-12
8111e6d8:	de00012e 	bgeu	sp,et,8111e6e0 <vFailRequestDMA+0xc>
8111e6dc:	003b68fa 	trap	3
8111e6e0:	dfc00215 	stw	ra,8(sp)
8111e6e4:	df000115 	stw	fp,4(sp)
8111e6e8:	df000104 	addi	fp,sp,4
8111e6ec:	2005883a 	mov	r2,r4
8111e6f0:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e6f4:	00a045b4 	movhi	r2,33046
8111e6f8:	109fe204 	addi	r2,r2,32648
8111e6fc:	10800d8b 	ldhu	r2,54(r2)
8111e700:	10bfffcc 	andi	r2,r2,65535
8111e704:	10800228 	cmpgeui	r2,r2,8
8111e708:	1000071e 	bne	r2,zero,8111e728 <vFailRequestDMA+0x54>
		fprintf(fp,"vFailRequestDMA. FEE n:%hhu \n", ucTemp);
8111e70c:	d0a06217 	ldw	r2,-32376(gp)
8111e710:	e0ffff03 	ldbu	r3,-4(fp)
8111e714:	180d883a 	mov	r6,r3
8111e718:	01604574 	movhi	r5,33045
8111e71c:	29456104 	addi	r5,r5,5508
8111e720:	1009883a 	mov	r4,r2
8111e724:	112292c0 	call	8112292c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e728:	0001883a 	nop
8111e72c:	e037883a 	mov	sp,fp
8111e730:	dfc00117 	ldw	ra,4(sp)
8111e734:	df000017 	ldw	fp,0(sp)
8111e738:	dec00204 	addi	sp,sp,8
8111e73c:	f800283a 	ret

8111e740 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
8111e740:	defffd04 	addi	sp,sp,-12
8111e744:	de00012e 	bgeu	sp,et,8111e74c <vFailRequestDMAFromIRQ+0xc>
8111e748:	003b68fa 	trap	3
8111e74c:	dfc00215 	stw	ra,8(sp)
8111e750:	df000115 	stw	fp,4(sp)
8111e754:	df000104 	addi	fp,sp,4
8111e758:	2005883a 	mov	r2,r4
8111e75c:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e760:	00a045b4 	movhi	r2,33046
8111e764:	109fe204 	addi	r2,r2,32648
8111e768:	10800d8b 	ldhu	r2,54(r2)
8111e76c:	10bfffcc 	andi	r2,r2,65535
8111e770:	10800228 	cmpgeui	r2,r2,8
8111e774:	1000071e 	bne	r2,zero,8111e794 <vFailRequestDMAFromIRQ+0x54>
		fprintf(fp,"vFailRequestDMA. FEE n:%hhu \n", ucTemp);
8111e778:	d0a06217 	ldw	r2,-32376(gp)
8111e77c:	e0ffff03 	ldbu	r3,-4(fp)
8111e780:	180d883a 	mov	r6,r3
8111e784:	01604574 	movhi	r5,33045
8111e788:	29456104 	addi	r5,r5,5508
8111e78c:	1009883a 	mov	r4,r2
8111e790:	112292c0 	call	8112292c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e794:	0001883a 	nop
8111e798:	e037883a 	mov	sp,fp
8111e79c:	dfc00117 	ldw	ra,4(sp)
8111e7a0:	df000017 	ldw	fp,0(sp)
8111e7a4:	dec00204 	addi	sp,sp,8
8111e7a8:	f800283a 	ret

8111e7ac <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
8111e7ac:	defffd04 	addi	sp,sp,-12
8111e7b0:	de00012e 	bgeu	sp,et,8111e7b8 <vFailSendRMAPFromIRQ+0xc>
8111e7b4:	003b68fa 	trap	3
8111e7b8:	dfc00215 	stw	ra,8(sp)
8111e7bc:	df000115 	stw	fp,4(sp)
8111e7c0:	df000104 	addi	fp,sp,4
8111e7c4:	2005883a 	mov	r2,r4
8111e7c8:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e7cc:	00a045b4 	movhi	r2,33046
8111e7d0:	109fe204 	addi	r2,r2,32648
8111e7d4:	10800d8b 	ldhu	r2,54(r2)
8111e7d8:	10bfffcc 	andi	r2,r2,65535
8111e7dc:	10800228 	cmpgeui	r2,r2,8
8111e7e0:	1000071e 	bne	r2,zero,8111e800 <vFailSendRMAPFromIRQ+0x54>
		fprintf(fp,"vFailSendRMAPFromIRQ. FEE n:%hhu \n", ucTemp);
8111e7e4:	d0a06217 	ldw	r2,-32376(gp)
8111e7e8:	e0ffff03 	ldbu	r3,-4(fp)
8111e7ec:	180d883a 	mov	r6,r3
8111e7f0:	01604574 	movhi	r5,33045
8111e7f4:	29456904 	addi	r5,r5,5540
8111e7f8:	1009883a 	mov	r4,r2
8111e7fc:	112292c0 	call	8112292c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e800:	0001883a 	nop
8111e804:	e037883a 	mov	sp,fp
8111e808:	dfc00117 	ldw	ra,4(sp)
8111e80c:	df000017 	ldw	fp,0(sp)
8111e810:	dec00204 	addi	sp,sp,8
8111e814:	f800283a 	ret

8111e818 <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
8111e818:	defffd04 	addi	sp,sp,-12
8111e81c:	de00012e 	bgeu	sp,et,8111e824 <vFailSendMsgSync+0xc>
8111e820:	003b68fa 	trap	3
8111e824:	dfc00215 	stw	ra,8(sp)
8111e828:	df000115 	stw	fp,4(sp)
8111e82c:	df000104 	addi	fp,sp,4
8111e830:	2005883a 	mov	r2,r4
8111e834:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e838:	00a045b4 	movhi	r2,33046
8111e83c:	109fe204 	addi	r2,r2,32648
8111e840:	10800d8b 	ldhu	r2,54(r2)
8111e844:	10bfffcc 	andi	r2,r2,65535
8111e848:	10800228 	cmpgeui	r2,r2,8
8111e84c:	1000071e 	bne	r2,zero,8111e86c <vFailSendMsgSync+0x54>
		fprintf(fp,"vFailSendMsgSync. FEE n:%hhu \n", ucTemp);
8111e850:	d0a06217 	ldw	r2,-32376(gp)
8111e854:	e0ffff03 	ldbu	r3,-4(fp)
8111e858:	180d883a 	mov	r6,r3
8111e85c:	01604574 	movhi	r5,33045
8111e860:	29457204 	addi	r5,r5,5576
8111e864:	1009883a 	mov	r4,r2
8111e868:	112292c0 	call	8112292c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e86c:	0001883a 	nop
8111e870:	e037883a 	mov	sp,fp
8111e874:	dfc00117 	ldw	ra,4(sp)
8111e878:	df000017 	ldw	fp,0(sp)
8111e87c:	dec00204 	addi	sp,sp,8
8111e880:	f800283a 	ret

8111e884 <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
8111e884:	defffd04 	addi	sp,sp,-12
8111e888:	de00012e 	bgeu	sp,et,8111e890 <vFailSendMsgSyncRMAPTRIGGER+0xc>
8111e88c:	003b68fa 	trap	3
8111e890:	dfc00215 	stw	ra,8(sp)
8111e894:	df000115 	stw	fp,4(sp)
8111e898:	df000104 	addi	fp,sp,4
8111e89c:	2005883a 	mov	r2,r4
8111e8a0:	e0bfff05 	stb	r2,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e8a4:	00a045b4 	movhi	r2,33046
8111e8a8:	109fe204 	addi	r2,r2,32648
8111e8ac:	10800d8b 	ldhu	r2,54(r2)
8111e8b0:	10bfffcc 	andi	r2,r2,65535
8111e8b4:	10800228 	cmpgeui	r2,r2,8
8111e8b8:	1000071e 	bne	r2,zero,8111e8d8 <vFailSendMsgSyncRMAPTRIGGER+0x54>
		fprintf(fp,"vFailSendMsgSyncRMAPTRIGGER (FORCED MODE). FEE n:%hhu \n", ucTemp);
8111e8bc:	d0a06217 	ldw	r2,-32376(gp)
8111e8c0:	e0ffff03 	ldbu	r3,-4(fp)
8111e8c4:	180d883a 	mov	r6,r3
8111e8c8:	01604574 	movhi	r5,33045
8111e8cc:	29457a04 	addi	r5,r5,5608
8111e8d0:	1009883a 	mov	r4,r2
8111e8d4:	112292c0 	call	8112292c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e8d8:	0001883a 	nop
8111e8dc:	e037883a 	mov	sp,fp
8111e8e0:	dfc00117 	ldw	ra,4(sp)
8111e8e4:	df000017 	ldw	fp,0(sp)
8111e8e8:	dec00204 	addi	sp,sp,8
8111e8ec:	f800283a 	ret

8111e8f0 <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
8111e8f0:	defffe04 	addi	sp,sp,-8
8111e8f4:	de00012e 	bgeu	sp,et,8111e8fc <vFailSendMsgMasterSyncMeb+0xc>
8111e8f8:	003b68fa 	trap	3
8111e8fc:	dfc00115 	stw	ra,4(sp)
8111e900:	df000015 	stw	fp,0(sp)
8111e904:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e908:	00a045b4 	movhi	r2,33046
8111e90c:	109fe204 	addi	r2,r2,32648
8111e910:	10800d8b 	ldhu	r2,54(r2)
8111e914:	10bfffcc 	andi	r2,r2,65535
8111e918:	10800228 	cmpgeui	r2,r2,8
8111e91c:	1000071e 	bne	r2,zero,8111e93c <vFailSendMsgMasterSyncMeb+0x4c>
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
8111e920:	d0a06217 	ldw	r2,-32376(gp)
8111e924:	100f883a 	mov	r7,r2
8111e928:	018006c4 	movi	r6,27
8111e92c:	01400044 	movi	r5,1
8111e930:	01204574 	movhi	r4,33045
8111e934:	21058804 	addi	r4,r4,5664
8111e938:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e93c:	0001883a 	nop
8111e940:	e037883a 	mov	sp,fp
8111e944:	dfc00117 	ldw	ra,4(sp)
8111e948:	df000017 	ldw	fp,0(sp)
8111e94c:	dec00204 	addi	sp,sp,8
8111e950:	f800283a 	ret

8111e954 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
8111e954:	defffe04 	addi	sp,sp,-8
8111e958:	de00012e 	bgeu	sp,et,8111e960 <vFailSendMsgFeeCTRL+0xc>
8111e95c:	003b68fa 	trap	3
8111e960:	dfc00115 	stw	ra,4(sp)
8111e964:	df000015 	stw	fp,0(sp)
8111e968:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e96c:	00a045b4 	movhi	r2,33046
8111e970:	109fe204 	addi	r2,r2,32648
8111e974:	10800d8b 	ldhu	r2,54(r2)
8111e978:	10bfffcc 	andi	r2,r2,65535
8111e97c:	10800228 	cmpgeui	r2,r2,8
8111e980:	1000071e 	bne	r2,zero,8111e9a0 <vFailSendMsgFeeCTRL+0x4c>
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
8111e984:	d0a06217 	ldw	r2,-32376(gp)
8111e988:	100f883a 	mov	r7,r2
8111e98c:	018005c4 	movi	r6,23
8111e990:	01400044 	movi	r5,1
8111e994:	01204574 	movhi	r4,33045
8111e998:	21058f04 	addi	r4,r4,5692
8111e99c:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111e9a0:	0001883a 	nop
8111e9a4:	e037883a 	mov	sp,fp
8111e9a8:	dfc00117 	ldw	ra,4(sp)
8111e9ac:	df000017 	ldw	fp,0(sp)
8111e9b0:	dec00204 	addi	sp,sp,8
8111e9b4:	f800283a 	ret

8111e9b8 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
8111e9b8:	defffe04 	addi	sp,sp,-8
8111e9bc:	de00012e 	bgeu	sp,et,8111e9c4 <vFailSendMsgDataCTRL+0xc>
8111e9c0:	003b68fa 	trap	3
8111e9c4:	dfc00115 	stw	ra,4(sp)
8111e9c8:	df000015 	stw	fp,0(sp)
8111e9cc:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111e9d0:	00a045b4 	movhi	r2,33046
8111e9d4:	109fe204 	addi	r2,r2,32648
8111e9d8:	10800d8b 	ldhu	r2,54(r2)
8111e9dc:	10bfffcc 	andi	r2,r2,65535
8111e9e0:	10800228 	cmpgeui	r2,r2,8
8111e9e4:	1000071e 	bne	r2,zero,8111ea04 <vFailSendMsgDataCTRL+0x4c>
		debug(fp,"vFailSendMsgDataCTRL.  \n");
8111e9e8:	d0a06217 	ldw	r2,-32376(gp)
8111e9ec:	100f883a 	mov	r7,r2
8111e9f0:	01800604 	movi	r6,24
8111e9f4:	01400044 	movi	r5,1
8111e9f8:	01204574 	movhi	r4,33045
8111e9fc:	21059504 	addi	r4,r4,5716
8111ea00:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ea04:	0001883a 	nop
8111ea08:	e037883a 	mov	sp,fp
8111ea0c:	dfc00117 	ldw	ra,4(sp)
8111ea10:	df000017 	ldw	fp,0(sp)
8111ea14:	dec00204 	addi	sp,sp,8
8111ea18:	f800283a 	ret

8111ea1c <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8111ea1c:	defffe04 	addi	sp,sp,-8
8111ea20:	de00012e 	bgeu	sp,et,8111ea28 <vFailFlushQueue+0xc>
8111ea24:	003b68fa 	trap	3
8111ea28:	dfc00115 	stw	ra,4(sp)
8111ea2c:	df000015 	stw	fp,0(sp)
8111ea30:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ea34:	00a045b4 	movhi	r2,33046
8111ea38:	109fe204 	addi	r2,r2,32648
8111ea3c:	10800d8b 	ldhu	r2,54(r2)
8111ea40:	10bfffcc 	andi	r2,r2,65535
8111ea44:	10800228 	cmpgeui	r2,r2,8
8111ea48:	1000071e 	bne	r2,zero,8111ea68 <vFailFlushQueue+0x4c>
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
8111ea4c:	d0a06217 	ldw	r2,-32376(gp)
8111ea50:	100f883a 	mov	r7,r2
8111ea54:	01800744 	movi	r6,29
8111ea58:	01400044 	movi	r5,1
8111ea5c:	01204574 	movhi	r4,33045
8111ea60:	21059c04 	addi	r4,r4,5744
8111ea64:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ea68:	0001883a 	nop
8111ea6c:	e037883a 	mov	sp,fp
8111ea70:	dfc00117 	ldw	ra,4(sp)
8111ea74:	df000017 	ldw	fp,0(sp)
8111ea78:	dec00204 	addi	sp,sp,8
8111ea7c:	f800283a 	ret

8111ea80 <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
8111ea80:	defffe04 	addi	sp,sp,-8
8111ea84:	de00012e 	bgeu	sp,et,8111ea8c <vFailFlushQueueData+0xc>
8111ea88:	003b68fa 	trap	3
8111ea8c:	dfc00115 	stw	ra,4(sp)
8111ea90:	df000015 	stw	fp,0(sp)
8111ea94:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ea98:	00a045b4 	movhi	r2,33046
8111ea9c:	109fe204 	addi	r2,r2,32648
8111eaa0:	10800d8b 	ldhu	r2,54(r2)
8111eaa4:	10bfffcc 	andi	r2,r2,65535
8111eaa8:	10800228 	cmpgeui	r2,r2,8
8111eaac:	1000071e 	bne	r2,zero,8111eacc <vFailFlushQueueData+0x4c>
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
8111eab0:	d0a06217 	ldw	r2,-32376(gp)
8111eab4:	100f883a 	mov	r7,r2
8111eab8:	01800844 	movi	r6,33
8111eabc:	01400044 	movi	r5,1
8111eac0:	01204574 	movhi	r4,33045
8111eac4:	2105a404 	addi	r4,r4,5776
8111eac8:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111eacc:	0001883a 	nop
8111ead0:	e037883a 	mov	sp,fp
8111ead4:	dfc00117 	ldw	ra,4(sp)
8111ead8:	df000017 	ldw	fp,0(sp)
8111eadc:	dec00204 	addi	sp,sp,8
8111eae0:	f800283a 	ret

8111eae4 <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8111eae4:	defffe04 	addi	sp,sp,-8
8111eae8:	de00012e 	bgeu	sp,et,8111eaf0 <vFailFlushMEBQueue+0xc>
8111eaec:	003b68fa 	trap	3
8111eaf0:	dfc00115 	stw	ra,4(sp)
8111eaf4:	df000015 	stw	fp,0(sp)
8111eaf8:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111eafc:	00a045b4 	movhi	r2,33046
8111eb00:	109fe204 	addi	r2,r2,32648
8111eb04:	10800d8b 	ldhu	r2,54(r2)
8111eb08:	10bfffcc 	andi	r2,r2,65535
8111eb0c:	10800228 	cmpgeui	r2,r2,8
8111eb10:	1000071e 	bne	r2,zero,8111eb30 <vFailFlushMEBQueue+0x4c>
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
8111eb14:	d0a06217 	ldw	r2,-32376(gp)
8111eb18:	100f883a 	mov	r7,r2
8111eb1c:	01800804 	movi	r6,32
8111eb20:	01400044 	movi	r5,1
8111eb24:	01204574 	movhi	r4,33045
8111eb28:	2105ad04 	addi	r4,r4,5812
8111eb2c:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111eb30:	0001883a 	nop
8111eb34:	e037883a 	mov	sp,fp
8111eb38:	dfc00117 	ldw	ra,4(sp)
8111eb3c:	df000017 	ldw	fp,0(sp)
8111eb40:	dec00204 	addi	sp,sp,8
8111eb44:	f800283a 	ret

8111eb48 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
8111eb48:	defffe04 	addi	sp,sp,-8
8111eb4c:	de00012e 	bgeu	sp,et,8111eb54 <vFailFlushNFEEQueue+0xc>
8111eb50:	003b68fa 	trap	3
8111eb54:	dfc00115 	stw	ra,4(sp)
8111eb58:	df000015 	stw	fp,0(sp)
8111eb5c:	d839883a 	mov	fp,sp
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111eb60:	00a045b4 	movhi	r2,33046
8111eb64:	109fe204 	addi	r2,r2,32648
8111eb68:	10800d8b 	ldhu	r2,54(r2)
8111eb6c:	10bfffcc 	andi	r2,r2,65535
8111eb70:	10800228 	cmpgeui	r2,r2,8
8111eb74:	1000071e 	bne	r2,zero,8111eb94 <vFailFlushNFEEQueue+0x4c>
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
8111eb78:	d0a06217 	ldw	r2,-32376(gp)
8111eb7c:	100f883a 	mov	r7,r2
8111eb80:	01800844 	movi	r6,33
8111eb84:	01400044 	movi	r5,1
8111eb88:	01204574 	movhi	r4,33045
8111eb8c:	2105b604 	addi	r4,r4,5848
8111eb90:	1122fc80 	call	81122fc8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111eb94:	0001883a 	nop
8111eb98:	e037883a 	mov	sp,fp
8111eb9c:	dfc00117 	ldw	ra,4(sp)
8111eba0:	df000017 	ldw	fp,0(sp)
8111eba4:	dec00204 	addi	sp,sp,8
8111eba8:	f800283a 	ret

8111ebac <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
8111ebac:	deffff04 	addi	sp,sp,-4
8111ebb0:	de00012e 	bgeu	sp,et,8111ebb8 <vEvtChangeMebMode+0xc>
8111ebb4:	003b68fa 	trap	3
8111ebb8:	df000015 	stw	fp,0(sp)
8111ebbc:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111ebc0:	0001883a 	nop
8111ebc4:	e037883a 	mov	sp,fp
8111ebc8:	df000017 	ldw	fp,0(sp)
8111ebcc:	dec00104 	addi	sp,sp,4
8111ebd0:	f800283a 	ret

8111ebd4 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
8111ebd4:	deffff04 	addi	sp,sp,-4
8111ebd8:	de00012e 	bgeu	sp,et,8111ebe0 <vEvtChangeFeeControllerMode+0xc>
8111ebdc:	003b68fa 	trap	3
8111ebe0:	df000015 	stw	fp,0(sp)
8111ebe4:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111ebe8:	0001883a 	nop
8111ebec:	e037883a 	mov	sp,fp
8111ebf0:	df000017 	ldw	fp,0(sp)
8111ebf4:	dec00104 	addi	sp,sp,4
8111ebf8:	f800283a 	ret

8111ebfc <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
8111ebfc:	deffff04 	addi	sp,sp,-4
8111ec00:	de00012e 	bgeu	sp,et,8111ec08 <vEvtChangeDataControllerMode+0xc>
8111ec04:	003b68fa 	trap	3
8111ec08:	df000015 	stw	fp,0(sp)
8111ec0c:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111ec10:	0001883a 	nop
8111ec14:	e037883a 	mov	sp,fp
8111ec18:	df000017 	ldw	fp,0(sp)
8111ec1c:	dec00104 	addi	sp,sp,4
8111ec20:	f800283a 	ret

8111ec24 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111ec24:	defffd04 	addi	sp,sp,-12
8111ec28:	de00012e 	bgeu	sp,et,8111ec30 <vNFeeNotInUse+0xc>
8111ec2c:	003b68fa 	trap	3
8111ec30:	df000215 	stw	fp,8(sp)
8111ec34:	df000204 	addi	fp,sp,8
8111ec38:	e13ffe15 	stw	r4,-8(fp)
8111ec3c:	2805883a 	mov	r2,r5
8111ec40:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8111ec44:	e0bffe17 	ldw	r2,-8(fp)
8111ec48:	e0ffff03 	ldbu	r3,-4(fp)
8111ec4c:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
8111ec50:	e0bffe17 	ldw	r2,-8(fp)
8111ec54:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111ec58:	e0bffe17 	ldw	r2,-8(fp)
8111ec5c:	10002315 	stw	zero,140(r2)
}
8111ec60:	0001883a 	nop
8111ec64:	e037883a 	mov	sp,fp
8111ec68:	df000017 	ldw	fp,0(sp)
8111ec6c:	dec00104 	addi	sp,sp,4
8111ec70:	f800283a 	ret

8111ec74 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111ec74:	defffb04 	addi	sp,sp,-20
8111ec78:	de00012e 	bgeu	sp,et,8111ec80 <vNFeeStructureInit+0xc>
8111ec7c:	003b68fa 	trap	3
8111ec80:	dfc00415 	stw	ra,16(sp)
8111ec84:	df000315 	stw	fp,12(sp)
8111ec88:	df000304 	addi	fp,sp,12
8111ec8c:	e13ffe15 	stw	r4,-8(fp)
8111ec90:	2805883a 	mov	r2,r5
8111ec94:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8111ec98:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
8111ec9c:	e0bffe17 	ldw	r2,-8(fp)
8111eca0:	e0ffff03 	ldbu	r3,-4(fp)
8111eca4:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8111eca8:	e0bffe17 	ldw	r2,-8(fp)
8111ecac:	10802f04 	addi	r2,r2,188
8111ecb0:	1009883a 	mov	r4,r2
8111ecb4:	11191400 	call	81119140 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8111ecb8:	e13ffe17 	ldw	r4,-8(fp)
8111ecbc:	111eef80 	call	8111eef8 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
8111ecc0:	e0bffe17 	ldw	r2,-8(fp)
8111ecc4:	00c00044 	movi	r3,1
8111ecc8:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111eccc:	e0bffe17 	ldw	r2,-8(fp)
8111ecd0:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
8111ecd4:	e0bffe17 	ldw	r2,-8(fp)
8111ecd8:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
8111ecdc:	e0bffe17 	ldw	r2,-8(fp)
8111ece0:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
8111ece4:	e0bffe17 	ldw	r2,-8(fp)
8111ece8:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8111ecec:	e0bffe17 	ldw	r2,-8(fp)
8111ecf0:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
8111ecf4:	e0bffe17 	ldw	r2,-8(fp)
8111ecf8:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
8111ecfc:	e0bffe17 	ldw	r2,-8(fp)
8111ed00:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
8111ed04:	e0bffe17 	ldw	r2,-8(fp)
8111ed08:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
8111ed0c:	e0bffe17 	ldw	r2,-8(fp)
8111ed10:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
8111ed14:	e0bffe17 	ldw	r2,-8(fp)
8111ed18:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
8111ed1c:	e0bffe17 	ldw	r2,-8(fp)
8111ed20:	10002d15 	stw	zero,180(r2)

    switch (ucIdNFEE) {
8111ed24:	e0bfff03 	ldbu	r2,-4(fp)
8111ed28:	1000071e 	bne	r2,zero,8111ed48 <vNFeeStructureInit+0xd4>
		case 0:
			pxNfeeL->ucSPWId = (unsigned char)xDefaults.usiLinkNFEE0;
8111ed2c:	00a045b4 	movhi	r2,33046
8111ed30:	109fe204 	addi	r2,r2,32648
8111ed34:	10800d0b 	ldhu	r2,52(r2)
8111ed38:	1007883a 	mov	r3,r2
8111ed3c:	e0bffe17 	ldw	r2,-8(fp)
8111ed40:	10c00045 	stb	r3,1(r2)
			break;
8111ed44:	00001006 	br	8111ed88 <vNFeeStructureInit+0x114>
		default:
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ed48:	00a045b4 	movhi	r2,33046
8111ed4c:	109fe204 	addi	r2,r2,32648
8111ed50:	10800d8b 	ldhu	r2,54(r2)
8111ed54:	10bfffcc 	andi	r2,r2,65535
8111ed58:	10800228 	cmpgeui	r2,r2,8
8111ed5c:	1000091e 	bne	r2,zero,8111ed84 <vNFeeStructureInit+0x110>
				fprintf(fp, "\n CRITICAL! Can't bind the SPW channel with the NFEE %i \n", pxNfeeL->ucId);
8111ed60:	d0e06217 	ldw	r3,-32376(gp)
8111ed64:	e0bffe17 	ldw	r2,-8(fp)
8111ed68:	10800003 	ldbu	r2,0(r2)
8111ed6c:	10803fcc 	andi	r2,r2,255
8111ed70:	100d883a 	mov	r6,r2
8111ed74:	01604574 	movhi	r5,33045
8111ed78:	2945bf04 	addi	r5,r5,5884
8111ed7c:	1809883a 	mov	r4,r3
8111ed80:	112292c0 	call	8112292c <fprintf>
			}
			#endif
			break;
8111ed84:	0001883a 	nop

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111ed88:	e03ffd05 	stb	zero,-12(fp)
8111ed8c:	00000906 	br	8111edb4 <vNFeeStructureInit+0x140>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
8111ed90:	e0bffd03 	ldbu	r2,-12(fp)
8111ed94:	e0fffe17 	ldw	r3,-8(fp)
8111ed98:	1885883a 	add	r2,r3,r2
8111ed9c:	10802a44 	addi	r2,r2,169
8111eda0:	e0fffd03 	ldbu	r3,-12(fp)
8111eda4:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111eda8:	e0bffd03 	ldbu	r2,-12(fp)
8111edac:	10800044 	addi	r2,r2,1
8111edb0:	e0bffd05 	stb	r2,-12(fp)
8111edb4:	e0bffd03 	ldbu	r2,-12(fp)
8111edb8:	10800130 	cmpltui	r2,r2,4
8111edbc:	103ff41e 	bne	r2,zero,8111ed90 <__reset+0xfb0fed90>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, pxNfeeL->ucSPWId ) == FALSE ) {
8111edc0:	e0bffe17 	ldw	r2,-8(fp)
8111edc4:	10c03204 	addi	r3,r2,200
8111edc8:	e0bffe17 	ldw	r2,-8(fp)
8111edcc:	10800043 	ldbu	r2,1(r2)
8111edd0:	10803fcc 	andi	r2,r2,255
8111edd4:	100b883a 	mov	r5,r2
8111edd8:	1809883a 	mov	r4,r3
8111eddc:	11046cc0 	call	811046cc <bCommInitCh>
8111ede0:	10000f1e 	bne	r2,zero,8111ee20 <vNFeeStructureInit+0x1ac>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ede4:	00a045b4 	movhi	r2,33046
8111ede8:	109fe204 	addi	r2,r2,32648
8111edec:	10800d8b 	ldhu	r2,54(r2)
8111edf0:	10bfffcc 	andi	r2,r2,65535
8111edf4:	10800228 	cmpgeui	r2,r2,8
8111edf8:	1000091e 	bne	r2,zero,8111ee20 <vNFeeStructureInit+0x1ac>
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
8111edfc:	d0e06217 	ldw	r3,-32376(gp)
8111ee00:	e0bffe17 	ldw	r2,-8(fp)
8111ee04:	10800003 	ldbu	r2,0(r2)
8111ee08:	10803fcc 	andi	r2,r2,255
8111ee0c:	100d883a 	mov	r6,r2
8111ee10:	01604574 	movhi	r5,33045
8111ee14:	2945ce04 	addi	r5,r5,5944
8111ee18:	1809883a 	mov	r4,r3
8111ee1c:	112292c0 	call	8112292c <fprintf>
    	}
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, pxNfeeL->ucSPWId ) == FALSE ) {
8111ee20:	e0bffe17 	ldw	r2,-8(fp)
8111ee24:	10800043 	ldbu	r2,1(r2)
8111ee28:	10803fcc 	andi	r2,r2,255
8111ee2c:	100b883a 	mov	r5,r2
8111ee30:	01000044 	movi	r4,1
8111ee34:	11045600 	call	81104560 <bCommSetGlobalIrqEn>
8111ee38:	10000f1e 	bne	r2,zero,8111ee78 <vNFeeStructureInit+0x204>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
8111ee3c:	00a045b4 	movhi	r2,33046
8111ee40:	109fe204 	addi	r2,r2,32648
8111ee44:	10800d8b 	ldhu	r2,54(r2)
8111ee48:	10bfffcc 	andi	r2,r2,65535
8111ee4c:	10800228 	cmpgeui	r2,r2,8
8111ee50:	1000091e 	bne	r2,zero,8111ee78 <vNFeeStructureInit+0x204>
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
8111ee54:	d0e06217 	ldw	r3,-32376(gp)
8111ee58:	e0bffe17 	ldw	r2,-8(fp)
8111ee5c:	10800003 	ldbu	r2,0(r2)
8111ee60:	10803fcc 	andi	r2,r2,255
8111ee64:	100d883a 	mov	r6,r2
8111ee68:	01604574 	movhi	r5,33045
8111ee6c:	2945da04 	addi	r5,r5,5992
8111ee70:	1809883a 	mov	r4,r3
8111ee74:	112292c0 	call	8112292c <fprintf>
    	}
		#endif
    }

    bDpktGetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111ee78:	e0bffe17 	ldw	r2,-8(fp)
8111ee7c:	10803304 	addi	r2,r2,204
8111ee80:	1009883a 	mov	r4,r2
8111ee84:	1104da40 	call	81104da4 <bDpktGetPixelDelay>
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiAdcDelay = usiAdcPxDelayCalcPeriodNs(xDefaults.ulADCPixelDelay);
8111ee88:	00a045b4 	movhi	r2,33046
8111ee8c:	109fe204 	addi	r2,r2,32648
8111ee90:	10800a17 	ldw	r2,40(r2)
8111ee94:	1009883a 	mov	r4,r2
8111ee98:	11050800 	call	81105080 <usiAdcPxDelayCalcPeriodNs>
8111ee9c:	1007883a 	mov	r3,r2
8111eea0:	e0bffe17 	ldw	r2,-8(fp)
8111eea4:	10c03a0d 	sth	r3,232(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiColumnDelay = 0 ;
8111eea8:	e0bffe17 	ldw	r2,-8(fp)
8111eeac:	1000398d 	sth	zero,230(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiLineDelay = usiLineTrDelayCalcPeriodNs(xDefaults.ulLineDelay);
8111eeb0:	00a045b4 	movhi	r2,33046
8111eeb4:	109fe204 	addi	r2,r2,32648
8111eeb8:	10800817 	ldw	r2,32(r2)
8111eebc:	1009883a 	mov	r4,r2
8111eec0:	110510c0 	call	8110510c <usiLineTrDelayCalcPeriodNs>
8111eec4:	1007883a 	mov	r3,r2
8111eec8:	e0bffe17 	ldw	r2,-8(fp)
8111eecc:	10c0390d 	sth	r3,228(r2)
    bDpktSetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111eed0:	e0bffe17 	ldw	r2,-8(fp)
8111eed4:	10803304 	addi	r2,r2,204
8111eed8:	1009883a 	mov	r4,r2
8111eedc:	1104c5c0 	call	81104c5c <bDpktSetPixelDelay>

}
8111eee0:	0001883a 	nop
8111eee4:	e037883a 	mov	sp,fp
8111eee8:	dfc00117 	ldw	ra,4(sp)
8111eeec:	df000017 	ldw	fp,0(sp)
8111eef0:	dec00204 	addi	sp,sp,8
8111eef4:	f800283a 	ret

8111eef8 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8111eef8:	defff404 	addi	sp,sp,-48
8111eefc:	de00012e 	bgeu	sp,et,8111ef04 <vUpdateMemMapFEE+0xc>
8111ef00:	003b68fa 	trap	3
8111ef04:	df000b15 	stw	fp,44(sp)
8111ef08:	df000b04 	addi	fp,sp,44
8111ef0c:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
8111ef10:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8111ef14:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8111ef18:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
8111ef1c:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
8111ef20:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8111ef24:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8111ef28:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
8111ef2c:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
8111ef30:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
8111ef34:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
8111ef38:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
8111ef3c:	e17fff17 	ldw	r5,-4(fp)
8111ef40:	01035a34 	movhi	r4,3432
8111ef44:	21348c04 	addi	r4,r4,-11728
8111ef48:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
8111ef4c:	e13fff17 	ldw	r4,-4(fp)
8111ef50:	21000003 	ldbu	r4,0(r4)
8111ef54:	21403fcc 	andi	r5,r4,255
8111ef58:	01035a34 	movhi	r4,3432
8111ef5c:	21348c04 	addi	r4,r4,-11728
8111ef60:	2909383a 	mul	r4,r5,r4
8111ef64:	200b883a 	mov	r5,r4
8111ef68:	e13fff17 	ldw	r4,-4(fp)
8111ef6c:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
8111ef70:	e13fff17 	ldw	r4,-4(fp)
8111ef74:	21400117 	ldw	r5,4(r4)
8111ef78:	01033234 	movhi	r4,3272
8111ef7c:	21348c04 	addi	r4,r4,-11728
8111ef80:	290b883a 	add	r5,r5,r4
8111ef84:	e13fff17 	ldw	r4,-4(fp)
8111ef88:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111ef8c:	e13fff17 	ldw	r4,-4(fp)
8111ef90:	2100310b 	ldhu	r4,196(r4)
8111ef94:	217fffcc 	andi	r5,r4,65535
8111ef98:	e13fff17 	ldw	r4,-4(fp)
8111ef9c:	2100300b 	ldhu	r4,192(r4)
8111efa0:	213fffcc 	andi	r4,r4,65535
8111efa4:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8111efa8:	e13fff17 	ldw	r4,-4(fp)
8111efac:	2100308b 	ldhu	r4,194(r4)
8111efb0:	21bfffcc 	andi	r6,r4,65535
8111efb4:	e13fff17 	ldw	r4,-4(fp)
8111efb8:	21002f8b 	ldhu	r4,190(r4)
8111efbc:	213fffcc 	andi	r4,r4,65535
8111efc0:	310d883a 	add	r6,r6,r4
8111efc4:	e13fff17 	ldw	r4,-4(fp)
8111efc8:	21002f0b 	ldhu	r4,188(r4)
8111efcc:	213fffcc 	andi	r4,r4,65535
8111efd0:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111efd4:	2909383a 	mul	r4,r5,r4
8111efd8:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
8111efdc:	e13ffa17 	ldw	r4,-24(fp)
8111efe0:	2109883a 	add	r4,r4,r4
8111efe4:	200b883a 	mov	r5,r4
8111efe8:	e13fff17 	ldw	r4,-4(fp)
8111efec:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
8111eff0:	e13fff17 	ldw	r4,-4(fp)
8111eff4:	21000517 	ldw	r4,20(r4)
8111eff8:	2008d0fa 	srli	r4,r4,3
8111effc:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
8111f000:	e13fff17 	ldw	r4,-4(fp)
8111f004:	21000517 	ldw	r4,20(r4)
8111f008:	210001cc 	andi	r4,r4,7
8111f00c:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
8111f010:	e13ffb17 	ldw	r4,-20(fp)
8111f014:	20001226 	beq	r4,zero,8111f060 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
8111f018:	e13ff517 	ldw	r4,-44(fp)
8111f01c:	21000044 	addi	r4,r4,1
8111f020:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8111f024:	e13fff17 	ldw	r4,-4(fp)
8111f028:	21400517 	ldw	r5,20(r4)
8111f02c:	e13ffb17 	ldw	r4,-20(fp)
8111f030:	2909c83a 	sub	r4,r5,r4
8111f034:	21400204 	addi	r5,r4,8
8111f038:	e13fff17 	ldw	r4,-4(fp)
8111f03c:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
8111f040:	e13ffb17 	ldw	r4,-20(fp)
8111f044:	200b883a 	mov	r5,r4
8111f048:	01000204 	movi	r4,8
8111f04c:	2149c83a 	sub	r4,r4,r5
8111f050:	200b883a 	mov	r5,r4
8111f054:	e13fff17 	ldw	r4,-4(fp)
8111f058:	21400605 	stb	r5,24(r4)
8111f05c:	00000206 	br	8111f068 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
8111f060:	e13fff17 	ldw	r4,-4(fp)
8111f064:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8111f068:	e13ff517 	ldw	r4,-44(fp)
8111f06c:	2008d13a 	srli	r4,r4,4
8111f070:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8111f074:	e13ff517 	ldw	r4,-44(fp)
8111f078:	210003cc 	andi	r4,r4,15
8111f07c:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
8111f080:	e13ffc17 	ldw	r4,-16(fp)
8111f084:	20000b26 	beq	r4,zero,8111f0b4 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8111f088:	e13ff717 	ldw	r4,-36(fp)
8111f08c:	21000044 	addi	r4,r4,1
8111f090:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
8111f094:	e17ff517 	ldw	r5,-44(fp)
8111f098:	e13ffc17 	ldw	r4,-16(fp)
8111f09c:	290bc83a 	sub	r5,r5,r4
8111f0a0:	e13ff717 	ldw	r4,-36(fp)
8111f0a4:	2909883a 	add	r4,r5,r4
8111f0a8:	21000404 	addi	r4,r4,16
8111f0ac:	e13ff615 	stw	r4,-40(fp)
8111f0b0:	00000406 	br	8111f0c4 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8111f0b4:	e17ff517 	ldw	r5,-44(fp)
8111f0b8:	e13ff717 	ldw	r4,-36(fp)
8111f0bc:	2909883a 	add	r4,r5,r4
8111f0c0:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8111f0c4:	e13ff617 	ldw	r4,-40(fp)
8111f0c8:	200a90fa 	slli	r5,r4,3
8111f0cc:	e13fff17 	ldw	r4,-4(fp)
8111f0d0:	21400515 	stw	r5,20(r4)


    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8111f0d4:	e13ffb17 	ldw	r4,-20(fp)
8111f0d8:	20000926 	beq	r4,zero,8111f100 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
8111f0dc:	e13ffc17 	ldw	r4,-16(fp)
8111f0e0:	2109883a 	add	r4,r4,r4
8111f0e4:	2109883a 	add	r4,r4,r4
8111f0e8:	200b883a 	mov	r5,r4
8111f0ec:	e13ffb17 	ldw	r4,-20(fp)
8111f0f0:	2008d07a 	srli	r4,r4,1
8111f0f4:	2909883a 	add	r4,r5,r4
8111f0f8:	e13ff805 	stb	r4,-32(fp)
8111f0fc:	00000406 	br	8111f110 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
8111f100:	e13ffc17 	ldw	r4,-16(fp)
8111f104:	2109883a 	add	r4,r4,r4
8111f108:	2109883a 	add	r4,r4,r4
8111f10c:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
8111f110:	e13ff803 	ldbu	r4,-32(fp)
8111f114:	01401004 	movi	r5,64
8111f118:	2909c83a 	sub	r4,r5,r4
8111f11c:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF << ucShiftsL);
8111f120:	e13ffd03 	ldbu	r4,-12(fp)
8111f124:	217ff804 	addi	r5,r4,-32
8111f128:	28000416 	blt	r5,zero,8111f13c <vUpdateMemMapFEE+0x244>
8111f12c:	013fffc4 	movi	r4,-1
8111f130:	2146983a 	sll	r3,r4,r5
8111f134:	0005883a 	mov	r2,zero
8111f138:	00000a06 	br	8111f164 <vUpdateMemMapFEE+0x26c>
8111f13c:	017fffc4 	movi	r5,-1
8111f140:	280cd07a 	srli	r6,r5,1
8111f144:	014007c4 	movi	r5,31
8111f148:	290bc83a 	sub	r5,r5,r4
8111f14c:	314ad83a 	srl	r5,r6,r5
8111f150:	01bfffc4 	movi	r6,-1
8111f154:	3106983a 	sll	r3,r6,r4
8111f158:	28c6b03a 	or	r3,r5,r3
8111f15c:	017fffc4 	movi	r5,-1
8111f160:	2904983a 	sll	r2,r5,r4
8111f164:	e13fff17 	ldw	r4,-4(fp)
8111f168:	20800715 	stw	r2,28(r4)
8111f16c:	20c00815 	stw	r3,32(r4)
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF);


    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
8111f170:	e0bfff17 	ldw	r2,-4(fp)
8111f174:	e0fff717 	ldw	r3,-36(fp)
8111f178:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
8111f17c:	e0bfff17 	ldw	r2,-4(fp)
8111f180:	10c00117 	ldw	r3,4(r2)
8111f184:	008004b4 	movhi	r2,18
8111f188:	10a40004 	addi	r2,r2,-28672
8111f18c:	1885883a 	add	r2,r3,r2
8111f190:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
8111f194:	e0bfff17 	ldw	r2,-4(fp)
8111f198:	10c00517 	ldw	r3,20(r2)
8111f19c:	008000b4 	movhi	r2,2
8111f1a0:	10a40004 	addi	r2,r2,-28672
8111f1a4:	1885883a 	add	r2,r3,r2
8111f1a8:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111f1ac:	e03ff845 	stb	zero,-31(fp)
8111f1b0:	00001906 	br	8111f218 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111f1b4:	e0bff843 	ldbu	r2,-31(fp)
8111f1b8:	e0ffff17 	ldw	r3,-4(fp)
8111f1bc:	10800624 	muli	r2,r2,24
8111f1c0:	1885883a 	add	r2,r3,r2
8111f1c4:	10800904 	addi	r2,r2,36
8111f1c8:	e0fff917 	ldw	r3,-28(fp)
8111f1cc:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111f1d0:	e0fff917 	ldw	r3,-28(fp)
8111f1d4:	e0bffe17 	ldw	r2,-8(fp)
8111f1d8:	1885883a 	add	r2,r3,r2
8111f1dc:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
8111f1e0:	e0bff843 	ldbu	r2,-31(fp)
8111f1e4:	e0ffff17 	ldw	r3,-4(fp)
8111f1e8:	10800624 	muli	r2,r2,24
8111f1ec:	1885883a 	add	r2,r3,r2
8111f1f0:	10800c04 	addi	r2,r2,48
8111f1f4:	e0fff917 	ldw	r3,-28(fp)
8111f1f8:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111f1fc:	e0fff917 	ldw	r3,-28(fp)
8111f200:	e0bffe17 	ldw	r2,-8(fp)
8111f204:	1885883a 	add	r2,r3,r2
8111f208:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111f20c:	e0bff843 	ldbu	r2,-31(fp)
8111f210:	10800044 	addi	r2,r2,1
8111f214:	e0bff845 	stb	r2,-31(fp)
8111f218:	e0bff843 	ldbu	r2,-31(fp)
8111f21c:	10800130 	cmpltui	r2,r2,4
8111f220:	103fe41e 	bne	r2,zero,8111f1b4 <__reset+0xfb0ff1b4>
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }

}
8111f224:	0001883a 	nop
8111f228:	e037883a 	mov	sp,fp
8111f22c:	df000017 	ldw	fp,0(sp)
8111f230:	dec00104 	addi	sp,sp,4
8111f234:	f800283a 	ret

8111f238 <vResetMemCCDFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
8111f238:	defffd04 	addi	sp,sp,-12
8111f23c:	de00012e 	bgeu	sp,et,8111f244 <vResetMemCCDFEE+0xc>
8111f240:	003b68fa 	trap	3
8111f244:	df000215 	stw	fp,8(sp)
8111f248:	df000204 	addi	fp,sp,8
8111f24c:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL = 0;
8111f250:	e03ffe05 	stb	zero,-8(fp)

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111f254:	e03ffe05 	stb	zero,-8(fp)
8111f258:	00001b06 	br	8111f2c8 <vResetMemCCDFEE+0x90>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
8111f25c:	e0bffe03 	ldbu	r2,-8(fp)
8111f260:	e0ffff17 	ldw	r3,-4(fp)
8111f264:	10800624 	muli	r2,r2,24
8111f268:	1885883a 	add	r2,r3,r2
8111f26c:	10800b04 	addi	r2,r2,44
8111f270:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
8111f274:	e0bffe03 	ldbu	r2,-8(fp)
8111f278:	e0ffff17 	ldw	r3,-4(fp)
8111f27c:	10800624 	muli	r2,r2,24
8111f280:	1885883a 	add	r2,r3,r2
8111f284:	10800a04 	addi	r2,r2,40
8111f288:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
8111f28c:	e0bffe03 	ldbu	r2,-8(fp)
8111f290:	e0ffff17 	ldw	r3,-4(fp)
8111f294:	10800624 	muli	r2,r2,24
8111f298:	1885883a 	add	r2,r3,r2
8111f29c:	10800e04 	addi	r2,r2,56
8111f2a0:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
8111f2a4:	e0bffe03 	ldbu	r2,-8(fp)
8111f2a8:	e0ffff17 	ldw	r3,-4(fp)
8111f2ac:	10800624 	muli	r2,r2,24
8111f2b0:	1885883a 	add	r2,r3,r2
8111f2b4:	10800d04 	addi	r2,r2,52
8111f2b8:	10000015 	stw	zero,0(r2)

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
	unsigned char ucIL = 0;

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111f2bc:	e0bffe03 	ldbu	r2,-8(fp)
8111f2c0:	10800044 	addi	r2,r2,1
8111f2c4:	e0bffe05 	stb	r2,-8(fp)
8111f2c8:	e0bffe03 	ldbu	r2,-8(fp)
8111f2cc:	10800130 	cmpltui	r2,r2,4
8111f2d0:	103fe21e 	bne	r2,zero,8111f25c <__reset+0xfb0ff25c>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
    }
}
8111f2d4:	0001883a 	nop
8111f2d8:	e037883a 	mov	sp,fp
8111f2dc:	df000017 	ldw	fp,0(sp)
8111f2e0:	dec00104 	addi	sp,sp,4
8111f2e4:	f800283a 	ret

8111f2e8 <vFeeSpwRMAPLoadDefault>:



/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
8111f2e8:	defffe04 	addi	sp,sp,-8
8111f2ec:	de00012e 	bgeu	sp,et,8111f2f4 <vFeeSpwRMAPLoadDefault+0xc>
8111f2f0:	003b68fa 	trap	3
8111f2f4:	df000115 	stw	fp,4(sp)
8111f2f8:	df000104 	addi	fp,sp,4
8111f2fc:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111f300:	0001883a 	nop
8111f304:	e037883a 	mov	sp,fp
8111f308:	df000017 	ldw	fp,0(sp)
8111f30c:	dec00104 	addi	sp,sp,4
8111f310:	f800283a 	ret

8111f314 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
8111f314:	defffe04 	addi	sp,sp,-8
8111f318:	de00012e 	bgeu	sp,et,8111f320 <vFeeSpwRMAPChangeConfig+0xc>
8111f31c:	003b68fa 	trap	3
8111f320:	df000115 	stw	fp,4(sp)
8111f324:	df000104 	addi	fp,sp,4
8111f328:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111f32c:	0001883a 	nop
8111f330:	e037883a 	mov	sp,fp
8111f334:	df000017 	ldw	fp,0(sp)
8111f338:	dec00104 	addi	sp,sp,4
8111f33c:	f800283a 	ret

8111f340 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
8111f340:	defffe04 	addi	sp,sp,-8
8111f344:	de00012e 	bgeu	sp,et,8111f34c <vFeeSpwRMAPChangeDefault+0xc>
8111f348:	003b68fa 	trap	3
8111f34c:	df000115 	stw	fp,4(sp)
8111f350:	df000104 	addi	fp,sp,4
8111f354:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
8111f358:	0001883a 	nop
8111f35c:	e037883a 	mov	sp,fp
8111f360:	df000017 	ldw	fp,0(sp)
8111f364:	dec00104 	addi	sp,sp,4
8111f368:	f800283a 	ret

8111f36c <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
8111f36c:	defffe04 	addi	sp,sp,-8
8111f370:	de00012e 	bgeu	sp,et,8111f378 <cFeeSpwChannelEnable+0xc>
8111f374:	003b68fa 	trap	3
8111f378:	df000115 	stw	fp,4(sp)
8111f37c:	df000104 	addi	fp,sp,4
8111f380:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111f384:	0001883a 	nop
8111f388:	e037883a 	mov	sp,fp
8111f38c:	df000017 	ldw	fp,0(sp)
8111f390:	dec00104 	addi	sp,sp,4
8111f394:	f800283a 	ret

8111f398 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
8111f398:	defffe04 	addi	sp,sp,-8
8111f39c:	de00012e 	bgeu	sp,et,8111f3a4 <cFeeSpwChannelDisable+0xc>
8111f3a0:	003b68fa 	trap	3
8111f3a4:	df000115 	stw	fp,4(sp)
8111f3a8:	df000104 	addi	fp,sp,4
8111f3ac:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111f3b0:	0001883a 	nop
8111f3b4:	e037883a 	mov	sp,fp
8111f3b8:	df000017 	ldw	fp,0(sp)
8111f3bc:	dec00104 	addi	sp,sp,4
8111f3c0:	f800283a 	ret

8111f3c4 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
8111f3c4:	defffe04 	addi	sp,sp,-8
8111f3c8:	de00012e 	bgeu	sp,et,8111f3d0 <cFeeRMAPDump+0xc>
8111f3cc:	003b68fa 	trap	3
8111f3d0:	df000115 	stw	fp,4(sp)
8111f3d4:	df000104 	addi	fp,sp,4
8111f3d8:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
8111f3dc:	0001883a 	nop
8111f3e0:	e037883a 	mov	sp,fp
8111f3e4:	df000017 	ldw	fp,0(sp)
8111f3e8:	dec00104 	addi	sp,sp,4
8111f3ec:	f800283a 	ret

8111f3f0 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
8111f3f0:	defffe04 	addi	sp,sp,-8
8111f3f4:	de00012e 	bgeu	sp,et,8111f3fc <cFeeRMAPEchoingEnable+0xc>
8111f3f8:	003b68fa 	trap	3
8111f3fc:	df000115 	stw	fp,4(sp)
8111f400:	df000104 	addi	fp,sp,4
8111f404:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
8111f408:	e0bfff17 	ldw	r2,-4(fp)
8111f40c:	00c00044 	movi	r3,1
8111f410:	10c02515 	stw	r3,148(r2)
}
8111f414:	0001883a 	nop
8111f418:	e037883a 	mov	sp,fp
8111f41c:	df000017 	ldw	fp,0(sp)
8111f420:	dec00104 	addi	sp,sp,4
8111f424:	f800283a 	ret

8111f428 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
8111f428:	defffe04 	addi	sp,sp,-8
8111f42c:	de00012e 	bgeu	sp,et,8111f434 <cFeeRMAPEchoingDisable+0xc>
8111f430:	003b68fa 	trap	3
8111f434:	df000115 	stw	fp,4(sp)
8111f438:	df000104 	addi	fp,sp,4
8111f43c:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
8111f440:	e0bfff17 	ldw	r2,-4(fp)
8111f444:	10002515 	stw	zero,148(r2)
}
8111f448:	0001883a 	nop
8111f44c:	e037883a 	mov	sp,fp
8111f450:	df000017 	ldw	fp,0(sp)
8111f454:	dec00104 	addi	sp,sp,4
8111f458:	f800283a 	ret

8111f45c <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
8111f45c:	defffe04 	addi	sp,sp,-8
8111f460:	de00012e 	bgeu	sp,et,8111f468 <cFeeRMAPLogEnable+0xc>
8111f464:	003b68fa 	trap	3
8111f468:	df000115 	stw	fp,4(sp)
8111f46c:	df000104 	addi	fp,sp,4
8111f470:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111f474:	e0bfff17 	ldw	r2,-4(fp)
8111f478:	00c00044 	movi	r3,1
8111f47c:	10c02415 	stw	r3,144(r2)
}
8111f480:	0001883a 	nop
8111f484:	e037883a 	mov	sp,fp
8111f488:	df000017 	ldw	fp,0(sp)
8111f48c:	dec00104 	addi	sp,sp,4
8111f490:	f800283a 	ret

8111f494 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111f494:	defffe04 	addi	sp,sp,-8
8111f498:	de00012e 	bgeu	sp,et,8111f4a0 <cFeeRMAPLogDisable+0xc>
8111f49c:	003b68fa 	trap	3
8111f4a0:	df000115 	stw	fp,4(sp)
8111f4a4:	df000104 	addi	fp,sp,4
8111f4a8:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8111f4ac:	e0bfff17 	ldw	r2,-4(fp)
8111f4b0:	10002415 	stw	zero,144(r2)
}
8111f4b4:	0001883a 	nop
8111f4b8:	e037883a 	mov	sp,fp
8111f4bc:	df000017 	ldw	fp,0(sp)
8111f4c0:	dec00104 	addi	sp,sp,4
8111f4c4:	f800283a 	ret

8111f4c8 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
8111f4c8:	defffc04 	addi	sp,sp,-16
8111f4cc:	de00012e 	bgeu	sp,et,8111f4d4 <vNFeeControlInit+0xc>
8111f4d0:	003b68fa 	trap	3
8111f4d4:	dfc00315 	stw	ra,12(sp)
8111f4d8:	df000215 	stw	fp,8(sp)
8111f4dc:	df000204 	addi	fp,sp,8
8111f4e0:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
8111f4e4:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
8111f4e8:	e13fff17 	ldw	r4,-4(fp)
8111f4ec:	111f6140 	call	8111f614 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
8111f4f0:	e13fff17 	ldw	r4,-4(fp)
8111f4f4:	111f6480 	call	8111f648 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
8111f4f8:	e0bfff17 	ldw	r2,-4(fp)
8111f4fc:	10009a15 	stw	zero,616(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111f500:	e03ffe05 	stb	zero,-8(fp)
8111f504:	00002b06 	br	8111f5b4 <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
8111f508:	e0bffe03 	ldbu	r2,-8(fp)
8111f50c:	10809624 	muli	r2,r2,600
8111f510:	e0ffff17 	ldw	r3,-4(fp)
8111f514:	1885883a 	add	r2,r3,r2
8111f518:	e0fffe03 	ldbu	r3,-8(fp)
8111f51c:	180b883a 	mov	r5,r3
8111f520:	1009883a 	mov	r4,r2
8111f524:	111ec740 	call	8111ec74 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
8111f528:	e0bffe03 	ldbu	r2,-8(fp)
8111f52c:	e0fffe03 	ldbu	r3,-8(fp)
8111f530:	18c09624 	muli	r3,r3,600
8111f534:	18c02104 	addi	r3,r3,132
8111f538:	e13fff17 	ldw	r4,-4(fp)
8111f53c:	20c7883a 	add	r3,r4,r3
8111f540:	e13fff17 	ldw	r4,-4(fp)
8111f544:	108025c4 	addi	r2,r2,151
8111f548:	1085883a 	add	r2,r2,r2
8111f54c:	1085883a 	add	r2,r2,r2
8111f550:	2085883a 	add	r2,r4,r2
8111f554:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
8111f558:	e0bffe03 	ldbu	r2,-8(fp)
8111f55c:	e0fffe03 	ldbu	r3,-8(fp)
8111f560:	18c09624 	muli	r3,r3,600
8111f564:	18c02704 	addi	r3,r3,156
8111f568:	e13fff17 	ldw	r4,-4(fp)
8111f56c:	20c7883a 	add	r3,r4,r3
8111f570:	e13fff17 	ldw	r4,-4(fp)
8111f574:	10802604 	addi	r2,r2,152
8111f578:	1085883a 	add	r2,r2,r2
8111f57c:	1085883a 	add	r2,r2,r2
8111f580:	2085883a 	add	r2,r4,r2
8111f584:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
8111f588:	e0bffe03 	ldbu	r2,-8(fp)
8111f58c:	e0ffff17 	ldw	r3,-4(fp)
8111f590:	18c09617 	ldw	r3,600(r3)
8111f594:	e13fff17 	ldw	r4,-4(fp)
8111f598:	10809624 	muli	r2,r2,600
8111f59c:	2085883a 	add	r2,r4,r2
8111f5a0:	10802904 	addi	r2,r2,164
8111f5a4:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111f5a8:	e0bffe03 	ldbu	r2,-8(fp)
8111f5ac:	10800044 	addi	r2,r2,1
8111f5b0:	e0bffe05 	stb	r2,-8(fp)
8111f5b4:	e0bffe03 	ldbu	r2,-8(fp)
8111f5b8:	103fd326 	beq	r2,zero,8111f508 <__reset+0xfb0ff508>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
8111f5bc:	0001883a 	nop
8111f5c0:	e037883a 	mov	sp,fp
8111f5c4:	dfc00117 	ldw	ra,4(sp)
8111f5c8:	df000017 	ldw	fp,0(sp)
8111f5cc:	dec00204 	addi	sp,sp,8
8111f5d0:	f800283a 	ret

8111f5d4 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
8111f5d4:	defffd04 	addi	sp,sp,-12
8111f5d8:	de00012e 	bgeu	sp,et,8111f5e0 <vSetTimeCode+0xc>
8111f5dc:	003b68fa 	trap	3
8111f5e0:	df000215 	stw	fp,8(sp)
8111f5e4:	df000204 	addi	fp,sp,8
8111f5e8:	e13ffe15 	stw	r4,-8(fp)
8111f5ec:	2805883a 	mov	r2,r5
8111f5f0:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
8111f5f4:	e0bffe17 	ldw	r2,-8(fp)
8111f5f8:	e0ffff03 	ldbu	r3,-4(fp)
8111f5fc:	10c09905 	stb	r3,612(r2)
}
8111f600:	0001883a 	nop
8111f604:	e037883a 	mov	sp,fp
8111f608:	df000017 	ldw	fp,0(sp)
8111f60c:	dec00104 	addi	sp,sp,4
8111f610:	f800283a 	ret

8111f614 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
8111f614:	defffe04 	addi	sp,sp,-8
8111f618:	de00012e 	bgeu	sp,et,8111f620 <vResetTimeCode+0xc>
8111f61c:	003b68fa 	trap	3
8111f620:	df000115 	stw	fp,4(sp)
8111f624:	df000104 	addi	fp,sp,4
8111f628:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8111f62c:	e0bfff17 	ldw	r2,-4(fp)
8111f630:	10009905 	stb	zero,612(r2)
}
8111f634:	0001883a 	nop
8111f638:	e037883a 	mov	sp,fp
8111f63c:	df000017 	ldw	fp,0(sp)
8111f640:	dec00104 	addi	sp,sp,4
8111f644:	f800283a 	ret

8111f648 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
8111f648:	defffe04 	addi	sp,sp,-8
8111f64c:	de00012e 	bgeu	sp,et,8111f654 <vLoadDefaultIdNFEEMaster+0xc>
8111f650:	003b68fa 	trap	3
8111f654:	df000115 	stw	fp,4(sp)
8111f658:	df000104 	addi	fp,sp,4
8111f65c:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
8111f660:	e0bfff17 	ldw	r2,-4(fp)
8111f664:	10009945 	stb	zero,613(r2)
}
8111f668:	0001883a 	nop
8111f66c:	e037883a 	mov	sp,fp
8111f670:	df000017 	ldw	fp,0(sp)
8111f674:	dec00104 	addi	sp,sp,4
8111f678:	f800283a 	ret

8111f67c <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111f67c:	defffd04 	addi	sp,sp,-12
8111f680:	de00012e 	bgeu	sp,et,8111f688 <vChangeIdNFEEMaster+0xc>
8111f684:	003b68fa 	trap	3
8111f688:	df000215 	stw	fp,8(sp)
8111f68c:	df000204 	addi	fp,sp,8
8111f690:	e13ffe15 	stw	r4,-8(fp)
8111f694:	2805883a 	mov	r2,r5
8111f698:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
8111f69c:	e0bffe17 	ldw	r2,-8(fp)
8111f6a0:	e0ffff03 	ldbu	r3,-4(fp)
8111f6a4:	10c09945 	stb	r3,613(r2)
}
8111f6a8:	0001883a 	nop
8111f6ac:	e037883a 	mov	sp,fp
8111f6b0:	df000017 	ldw	fp,0(sp)
8111f6b4:	dec00104 	addi	sp,sp,4
8111f6b8:	f800283a 	ret

8111f6bc <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111f6bc:	defffd04 	addi	sp,sp,-12
8111f6c0:	de00012e 	bgeu	sp,et,8111f6c8 <vChangeDefaultIdNFEEMaster+0xc>
8111f6c4:	003b68fa 	trap	3
8111f6c8:	df000215 	stw	fp,8(sp)
8111f6cc:	df000204 	addi	fp,sp,8
8111f6d0:	e13ffe15 	stw	r4,-8(fp)
8111f6d4:	2805883a 	mov	r2,r5
8111f6d8:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8111f6dc:	0001883a 	nop
8111f6e0:	e037883a 	mov	sp,fp
8111f6e4:	df000017 	ldw	fp,0(sp)
8111f6e8:	dec00104 	addi	sp,sp,4
8111f6ec:	f800283a 	ret

8111f6f0 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
8111f6f0:	defffe04 	addi	sp,sp,-8
8111f6f4:	de00012e 	bgeu	sp,et,8111f6fc <vInitSimucamBasicHW+0xc>
8111f6f8:	003b68fa 	trap	3
8111f6fc:	dfc00115 	stw	ra,4(sp)
8111f700:	df000015 	stw	fp,0(sp)
8111f704:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
8111f708:	01403fc4 	movi	r5,255
8111f70c:	0009883a 	mov	r4,zero
8111f710:	110b1880 	call	8110b188 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
8111f714:	01400834 	movhi	r5,32
8111f718:	297fffc4 	addi	r5,r5,-1
8111f71c:	0009883a 	mov	r4,zero
8111f720:	110b2080 	call	8110b208 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
8111f724:	01400074 	movhi	r5,1
8111f728:	01000044 	movi	r4,1
8111f72c:	110b2080 	call	8110b208 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
8111f730:	0009883a 	mov	r4,zero
8111f734:	110c8c00 	call	8110c8c0 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
8111f738:	0009883a 	mov	r4,zero
8111f73c:	110c9900 	call	8110c990 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111f740:	01008004 	movi	r4,512
8111f744:	110c4080 	call	8110c408 <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111f748:	01008004 	movi	r4,512
8111f74c:	110c3940 	call	8110c394 <vRstcReleaseDeviceReset>

}
8111f750:	0001883a 	nop
8111f754:	e037883a 	mov	sp,fp
8111f758:	dfc00117 	ldw	ra,4(sp)
8111f75c:	df000017 	ldw	fp,0(sp)
8111f760:	dec00204 	addi	sp,sp,8
8111f764:	f800283a 	ret

8111f768 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
8111f768:	defffd04 	addi	sp,sp,-12
8111f76c:	de00012e 	bgeu	sp,et,8111f774 <bLogWriteSDCard+0xc>
8111f770:	003b68fa 	trap	3
8111f774:	df000215 	stw	fp,8(sp)
8111f778:	df000204 	addi	fp,sp,8
8111f77c:	e13ffe15 	stw	r4,-8(fp)
8111f780:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
8111f784:	00800044 	movi	r2,1
}
8111f788:	e037883a 	mov	sp,fp
8111f78c:	df000017 	ldw	fp,0(sp)
8111f790:	dec00104 	addi	sp,sp,4
8111f794:	f800283a 	ret

8111f798 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
8111f798:	deffe004 	addi	sp,sp,-128
8111f79c:	de00012e 	bgeu	sp,et,8111f7a4 <vLogWriteNUC+0xc>
8111f7a0:	003b68fa 	trap	3
8111f7a4:	dfc01f15 	stw	ra,124(sp)
8111f7a8:	df001e15 	stw	fp,120(sp)
8111f7ac:	df001e04 	addi	fp,sp,120
8111f7b0:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
8111f7b4:	e03fe215 	stw	zero,-120(fp)
8111f7b8:	e0bfe304 	addi	r2,fp,-116
8111f7bc:	00c01b84 	movi	r3,110
8111f7c0:	180d883a 	mov	r6,r3
8111f7c4:	000b883a 	mov	r5,zero
8111f7c8:	1009883a 	mov	r4,r2
8111f7cc:	1123b2c0 	call	81123b2c <memset>
	memset(cTemp,0,114);
8111f7d0:	01801c84 	movi	r6,114
8111f7d4:	000b883a 	mov	r5,zero
8111f7d8:	e13fe204 	addi	r4,fp,-120
8111f7dc:	1123b2c0 	call	81123b2c <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
8111f7e0:	e13fff17 	ldw	r4,-4(fp)
8111f7e4:	11244540 	call	81124454 <strlen>
8111f7e8:	10801c68 	cmpgeui	r2,r2,113
8111f7ec:	1000031e 	bne	r2,zero,8111f7fc <vLogWriteNUC+0x64>
8111f7f0:	e13fff17 	ldw	r4,-4(fp)
8111f7f4:	11244540 	call	81124454 <strlen>
8111f7f8:	00000106 	br	8111f800 <vLogWriteNUC+0x68>
8111f7fc:	00801c44 	movi	r2,113
8111f800:	100d883a 	mov	r6,r2
8111f804:	e17fff17 	ldw	r5,-4(fp)
8111f808:	e13fe204 	addi	r4,fp,-120
8111f80c:	11239dc0 	call	811239dc <memcpy>
	vSendLog ( cDataIn );
8111f810:	e13fff17 	ldw	r4,-4(fp)
8111f814:	111a1640 	call	8111a164 <vSendLog>
}
8111f818:	0001883a 	nop
8111f81c:	e037883a 	mov	sp,fp
8111f820:	dfc00117 	ldw	ra,4(sp)
8111f824:	df000017 	ldw	fp,0(sp)
8111f828:	dec00204 	addi	sp,sp,8
8111f82c:	f800283a 	ret

8111f830 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
8111f830:	defffd04 	addi	sp,sp,-12
8111f834:	de00012e 	bgeu	sp,et,8111f83c <vSimucamStructureInit+0xc>
8111f838:	003b68fa 	trap	3
8111f83c:	dfc00215 	stw	ra,8(sp)
8111f840:	df000115 	stw	fp,4(sp)
8111f844:	df000104 	addi	fp,sp,4
8111f848:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
8111f84c:	e0bfff17 	ldw	r2,-4(fp)
8111f850:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
8111f854:	e0bfff17 	ldw	r2,-4(fp)
8111f858:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8111f85c:	e13fff17 	ldw	r4,-4(fp)
8111f860:	111f91c0 	call	8111f91c <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
8111f864:	e13fff17 	ldw	r4,-4(fp)
8111f868:	111f9c00 	call	8111f9c0 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
8111f86c:	e13fff17 	ldw	r4,-4(fp)
8111f870:	111fa680 	call	8111fa68 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
8111f874:	e13fff17 	ldw	r4,-4(fp)
8111f878:	111fb080 	call	8111fb08 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
8111f87c:	e0bfff17 	ldw	r2,-4(fp)
8111f880:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
8111f884:	e0bfff17 	ldw	r2,-4(fp)
8111f888:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
8111f88c:	e0bfff17 	ldw	r2,-4(fp)
8111f890:	00c07d04 	movi	r3,500
8111f894:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
8111f898:	e0bfff17 	ldw	r2,-4(fp)
8111f89c:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
8111f8a0:	e0bfff17 	ldw	r2,-4(fp)
8111f8a4:	00c00044 	movi	r3,1
8111f8a8:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
8111f8ac:	e0bfff17 	ldw	r2,-4(fp)
8111f8b0:	10c00204 	addi	r3,r2,8
8111f8b4:	e0bfff17 	ldw	r2,-4(fp)
8111f8b8:	10c0a815 	stw	r3,672(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
8111f8bc:	e0bfff17 	ldw	r2,-4(fp)
8111f8c0:	10c00244 	addi	r3,r2,9
8111f8c4:	e0bfff17 	ldw	r2,-4(fp)
8111f8c8:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
8111f8cc:	e0bfff17 	ldw	r2,-4(fp)
8111f8d0:	10800017 	ldw	r2,0(r2)
8111f8d4:	10000b1e 	bne	r2,zero,8111f904 <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
8111f8d8:	e0bfff17 	ldw	r2,-4(fp)
8111f8dc:	10801204 	addi	r2,r2,72
8111f8e0:	1009883a 	mov	r4,r2
8111f8e4:	111f4c80 	call	8111f4c8 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
8111f8e8:	e0bfff17 	ldw	r2,-4(fp)
8111f8ec:	10c00a04 	addi	r3,r2,40
8111f8f0:	e0bfff17 	ldw	r2,-4(fp)
8111f8f4:	10801204 	addi	r2,r2,72
8111f8f8:	100b883a 	mov	r5,r2
8111f8fc:	1809883a 	mov	r4,r3
8111f900:	111c38c0 	call	8111c38c <vDataControllerInit>
        /* Are Fast Fee instances */
        /* todo: Not in use yet */
    }

    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */
}
8111f904:	0001883a 	nop
8111f908:	e037883a 	mov	sp,fp
8111f90c:	dfc00117 	ldw	ra,4(sp)
8111f910:	df000017 	ldw	fp,0(sp)
8111f914:	dec00204 	addi	sp,sp,8
8111f918:	f800283a 	ret

8111f91c <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
8111f91c:	defffe04 	addi	sp,sp,-8
8111f920:	de00012e 	bgeu	sp,et,8111f928 <vLoadDefaultEPValue+0xc>
8111f924:	003b68fa 	trap	3
8111f928:	df000115 	stw	fp,4(sp)
8111f92c:	df000104 	addi	fp,sp,4
8111f930:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
8111f934:	e0bfff17 	ldw	r2,-4(fp)
8111f938:	00d07234 	movhi	r3,16840
8111f93c:	10c00315 	stw	r3,12(r2)
}
8111f940:	0001883a 	nop
8111f944:	e037883a 	mov	sp,fp
8111f948:	df000017 	ldw	fp,0(sp)
8111f94c:	dec00104 	addi	sp,sp,4
8111f950:	f800283a 	ret

8111f954 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111f954:	defffd04 	addi	sp,sp,-12
8111f958:	de00012e 	bgeu	sp,et,8111f960 <vChangeEPValue+0xc>
8111f95c:	003b68fa 	trap	3
8111f960:	df000215 	stw	fp,8(sp)
8111f964:	df000204 	addi	fp,sp,8
8111f968:	e13ffe15 	stw	r4,-8(fp)
8111f96c:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
8111f970:	e0bffe17 	ldw	r2,-8(fp)
8111f974:	e0ffff17 	ldw	r3,-4(fp)
8111f978:	10c00315 	stw	r3,12(r2)
}
8111f97c:	0001883a 	nop
8111f980:	e037883a 	mov	sp,fp
8111f984:	df000017 	ldw	fp,0(sp)
8111f988:	dec00104 	addi	sp,sp,4
8111f98c:	f800283a 	ret

8111f990 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111f990:	defffd04 	addi	sp,sp,-12
8111f994:	de00012e 	bgeu	sp,et,8111f99c <vChangeDefaultEPValue+0xc>
8111f998:	003b68fa 	trap	3
8111f99c:	df000215 	stw	fp,8(sp)
8111f9a0:	df000204 	addi	fp,sp,8
8111f9a4:	e13ffe15 	stw	r4,-8(fp)
8111f9a8:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
8111f9ac:	0001883a 	nop
8111f9b0:	e037883a 	mov	sp,fp
8111f9b4:	df000017 	ldw	fp,0(sp)
8111f9b8:	dec00104 	addi	sp,sp,4
8111f9bc:	f800283a 	ret

8111f9c0 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
8111f9c0:	defffe04 	addi	sp,sp,-8
8111f9c4:	de00012e 	bgeu	sp,et,8111f9cc <vLoadDefaultRTValue+0xc>
8111f9c8:	003b68fa 	trap	3
8111f9cc:	df000115 	stw	fp,4(sp)
8111f9d0:	df000104 	addi	fp,sp,4
8111f9d4:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
8111f9d8:	e0ffff17 	ldw	r3,-4(fp)
8111f9dc:	00901eb4 	movhi	r2,16506
8111f9e0:	10a66684 	addi	r2,r2,-26214
8111f9e4:	18800415 	stw	r2,16(r3)
}
8111f9e8:	0001883a 	nop
8111f9ec:	e037883a 	mov	sp,fp
8111f9f0:	df000017 	ldw	fp,0(sp)
8111f9f4:	dec00104 	addi	sp,sp,4
8111f9f8:	f800283a 	ret

8111f9fc <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111f9fc:	defffd04 	addi	sp,sp,-12
8111fa00:	de00012e 	bgeu	sp,et,8111fa08 <vChangeRTValue+0xc>
8111fa04:	003b68fa 	trap	3
8111fa08:	df000215 	stw	fp,8(sp)
8111fa0c:	df000204 	addi	fp,sp,8
8111fa10:	e13ffe15 	stw	r4,-8(fp)
8111fa14:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
8111fa18:	e0bffe17 	ldw	r2,-8(fp)
8111fa1c:	e0ffff17 	ldw	r3,-4(fp)
8111fa20:	10c00415 	stw	r3,16(r2)
}
8111fa24:	0001883a 	nop
8111fa28:	e037883a 	mov	sp,fp
8111fa2c:	df000017 	ldw	fp,0(sp)
8111fa30:	dec00104 	addi	sp,sp,4
8111fa34:	f800283a 	ret

8111fa38 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111fa38:	defffd04 	addi	sp,sp,-12
8111fa3c:	de00012e 	bgeu	sp,et,8111fa44 <vChangeDefaultRTValue+0xc>
8111fa40:	003b68fa 	trap	3
8111fa44:	df000215 	stw	fp,8(sp)
8111fa48:	df000204 	addi	fp,sp,8
8111fa4c:	e13ffe15 	stw	r4,-8(fp)
8111fa50:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
8111fa54:	0001883a 	nop
8111fa58:	e037883a 	mov	sp,fp
8111fa5c:	df000017 	ldw	fp,0(sp)
8111fa60:	dec00104 	addi	sp,sp,4
8111fa64:	f800283a 	ret

8111fa68 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
8111fa68:	defffe04 	addi	sp,sp,-8
8111fa6c:	de00012e 	bgeu	sp,et,8111fa74 <vLoadDefaultSyncSource+0xc>
8111fa70:	003b68fa 	trap	3
8111fa74:	df000115 	stw	fp,4(sp)
8111fa78:	df000104 	addi	fp,sp,4
8111fa7c:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
8111fa80:	e0bfff17 	ldw	r2,-4(fp)
8111fa84:	10000815 	stw	zero,32(r2)
}
8111fa88:	0001883a 	nop
8111fa8c:	e037883a 	mov	sp,fp
8111fa90:	df000017 	ldw	fp,0(sp)
8111fa94:	dec00104 	addi	sp,sp,4
8111fa98:	f800283a 	ret

8111fa9c <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111fa9c:	defffd04 	addi	sp,sp,-12
8111faa0:	de00012e 	bgeu	sp,et,8111faa8 <vChangeSyncSource+0xc>
8111faa4:	003b68fa 	trap	3
8111faa8:	df000215 	stw	fp,8(sp)
8111faac:	df000204 	addi	fp,sp,8
8111fab0:	e13ffe15 	stw	r4,-8(fp)
8111fab4:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
8111fab8:	e0bffe17 	ldw	r2,-8(fp)
8111fabc:	e0ffff17 	ldw	r3,-4(fp)
8111fac0:	10c00815 	stw	r3,32(r2)
}
8111fac4:	0001883a 	nop
8111fac8:	e037883a 	mov	sp,fp
8111facc:	df000017 	ldw	fp,0(sp)
8111fad0:	dec00104 	addi	sp,sp,4
8111fad4:	f800283a 	ret

8111fad8 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111fad8:	defffd04 	addi	sp,sp,-12
8111fadc:	de00012e 	bgeu	sp,et,8111fae4 <vChangeDefaultSyncSource+0xc>
8111fae0:	003b68fa 	trap	3
8111fae4:	df000215 	stw	fp,8(sp)
8111fae8:	df000204 	addi	fp,sp,8
8111faec:	e13ffe15 	stw	r4,-8(fp)
8111faf0:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
8111faf4:	0001883a 	nop
8111faf8:	e037883a 	mov	sp,fp
8111fafc:	df000017 	ldw	fp,0(sp)
8111fb00:	dec00104 	addi	sp,sp,4
8111fb04:	f800283a 	ret

8111fb08 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
8111fb08:	defffe04 	addi	sp,sp,-8
8111fb0c:	de00012e 	bgeu	sp,et,8111fb14 <vLoadDefaultAutoResetSync+0xc>
8111fb10:	003b68fa 	trap	3
8111fb14:	df000115 	stw	fp,4(sp)
8111fb18:	df000104 	addi	fp,sp,4
8111fb1c:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
8111fb20:	e0bfff17 	ldw	r2,-4(fp)
8111fb24:	00c00044 	movi	r3,1
8111fb28:	10c00915 	stw	r3,36(r2)
}
8111fb2c:	0001883a 	nop
8111fb30:	e037883a 	mov	sp,fp
8111fb34:	df000017 	ldw	fp,0(sp)
8111fb38:	dec00104 	addi	sp,sp,4
8111fb3c:	f800283a 	ret

8111fb40 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111fb40:	defffd04 	addi	sp,sp,-12
8111fb44:	de00012e 	bgeu	sp,et,8111fb4c <vChangeAutoResetSync+0xc>
8111fb48:	003b68fa 	trap	3
8111fb4c:	df000215 	stw	fp,8(sp)
8111fb50:	df000204 	addi	fp,sp,8
8111fb54:	e13ffe15 	stw	r4,-8(fp)
8111fb58:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
8111fb5c:	e0bffe17 	ldw	r2,-8(fp)
8111fb60:	e0ffff17 	ldw	r3,-4(fp)
8111fb64:	10c00915 	stw	r3,36(r2)
}
8111fb68:	0001883a 	nop
8111fb6c:	e037883a 	mov	sp,fp
8111fb70:	df000017 	ldw	fp,0(sp)
8111fb74:	dec00104 	addi	sp,sp,4
8111fb78:	f800283a 	ret

8111fb7c <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111fb7c:	defffd04 	addi	sp,sp,-12
8111fb80:	de00012e 	bgeu	sp,et,8111fb88 <vChangeDefaultAutoResetSync+0xc>
8111fb84:	003b68fa 	trap	3
8111fb88:	df000215 	stw	fp,8(sp)
8111fb8c:	df000204 	addi	fp,sp,8
8111fb90:	e13ffe15 	stw	r4,-8(fp)
8111fb94:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8111fb98:	0001883a 	nop
8111fb9c:	e037883a 	mov	sp,fp
8111fba0:	df000017 	ldw	fp,0(sp)
8111fba4:	dec00104 	addi	sp,sp,4
8111fba8:	f800283a 	ret

8111fbac <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
8111fbac:	defffc04 	addi	sp,sp,-16
8111fbb0:	de00012e 	bgeu	sp,et,8111fbb8 <vSyncReset+0xc>
8111fbb4:	003b68fa 	trap	3
8111fbb8:	dfc00315 	stw	ra,12(sp)
8111fbbc:	df000215 	stw	fp,8(sp)
8111fbc0:	df000204 	addi	fp,sp,8
8111fbc4:	e13ffe15 	stw	r4,-8(fp)
8111fbc8:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
8111fbcc:	e0bffe17 	ldw	r2,-8(fp)
8111fbd0:	10801204 	addi	r2,r2,72
8111fbd4:	1009883a 	mov	r4,r2
8111fbd8:	111f6140 	call	8111f614 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
8111fbdc:	0001883a 	nop
8111fbe0:	e037883a 	mov	sp,fp
8111fbe4:	dfc00117 	ldw	ra,4(sp)
8111fbe8:	df000017 	ldw	fp,0(sp)
8111fbec:	dec00204 	addi	sp,sp,8
8111fbf0:	f800283a 	ret

8111fbf4 <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
8111fbf4:	defff004 	addi	sp,sp,-64
8111fbf8:	de00012e 	bgeu	sp,et,8111fc00 <pattern_createPattern+0xc>
8111fbfc:	003b68fa 	trap	3
8111fc00:	dfc00f15 	stw	ra,60(sp)
8111fc04:	df000e15 	stw	fp,56(sp)
8111fc08:	dcc00d15 	stw	r19,52(sp)
8111fc0c:	dc800c15 	stw	r18,48(sp)
8111fc10:	dc400b15 	stw	r17,44(sp)
8111fc14:	dc000a15 	stw	r16,40(sp)
8111fc18:	df000e04 	addi	fp,sp,56
8111fc1c:	e17ff915 	stw	r5,-28(fp)
8111fc20:	3007883a 	mov	r3,r6
8111fc24:	3805883a 	mov	r2,r7
8111fc28:	e13ff805 	stb	r4,-32(fp)
8111fc2c:	e0fffa05 	stb	r3,-24(fp)
8111fc30:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
8111fc34:	e0bff803 	ldbu	r2,-32(fp)
8111fc38:	1009883a 	mov	r4,r2
8111fc3c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
8111fc40:	e0bff917 	ldw	r2,-28(fp)
8111fc44:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
8111fc48:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
8111fc4c:	e0bff217 	ldw	r2,-56(fp)
8111fc50:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111fc54:	e03ff515 	stw	zero,-44(fp)
8111fc58:	00003606 	br	8111fd34 <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111fc5c:	e03ff615 	stw	zero,-40(fp)
8111fc60:	00002e06 	br	8111fd1c <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
8111fc64:	e0bff303 	ldbu	r2,-52(fp)
8111fc68:	10801018 	cmpnei	r2,r2,64
8111fc6c:	10000b1e 	bne	r2,zero,8111fc9c <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
8111fc70:	e0bff417 	ldw	r2,-48(fp)
8111fc74:	00ffffc4 	movi	r3,-1
8111fc78:	10c02015 	stw	r3,128(r2)
8111fc7c:	00ffffc4 	movi	r3,-1
8111fc80:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
8111fc84:	e0bff217 	ldw	r2,-56(fp)
8111fc88:	10802204 	addi	r2,r2,136
8111fc8c:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
8111fc90:	e0bff217 	ldw	r2,-56(fp)
8111fc94:	e0bff415 	stw	r2,-48(fp)
				i = 0;
8111fc98:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
8111fc9c:	e0bff303 	ldbu	r2,-52(fp)
8111fca0:	10c00044 	addi	r3,r2,1
8111fca4:	e0fff305 	stb	r3,-52(fp)
8111fca8:	10803fcc 	andi	r2,r2,255
8111fcac:	e0fffa03 	ldbu	r3,-24(fp)
8111fcb0:	18c000cc 	andi	r3,r3,3
8111fcb4:	180692fa 	slli	r3,r3,11
8111fcb8:	1809883a 	mov	r4,r3
8111fcbc:	00f80004 	movi	r3,-8192
8111fcc0:	20c6b03a 	or	r3,r4,r3
8111fcc4:	1809883a 	mov	r4,r3
8111fcc8:	e0fffb03 	ldbu	r3,-20(fp)
8111fccc:	18c0004c 	andi	r3,r3,1
8111fcd0:	180692ba 	slli	r3,r3,10
8111fcd4:	20c6b03a 	or	r3,r4,r3
8111fcd8:	1809883a 	mov	r4,r3
8111fcdc:	e0fff517 	ldw	r3,-44(fp)
8111fce0:	18c007cc 	andi	r3,r3,31
8111fce4:	1806917a 	slli	r3,r3,5
8111fce8:	20c6b03a 	or	r3,r4,r3
8111fcec:	1809883a 	mov	r4,r3
8111fcf0:	e0fff617 	ldw	r3,-40(fp)
8111fcf4:	18c007cc 	andi	r3,r3,31
8111fcf8:	20c6b03a 	or	r3,r4,r3
8111fcfc:	1809883a 	mov	r4,r3
8111fd00:	e0fff417 	ldw	r3,-48(fp)
8111fd04:	1085883a 	add	r2,r2,r2
8111fd08:	1885883a 	add	r2,r3,r2
8111fd0c:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111fd10:	e0bff617 	ldw	r2,-40(fp)
8111fd14:	10800044 	addi	r2,r2,1
8111fd18:	e0bff615 	stw	r2,-40(fp)
8111fd1c:	e0fff617 	ldw	r3,-40(fp)
8111fd20:	e0800217 	ldw	r2,8(fp)
8111fd24:	18bfcf36 	bltu	r3,r2,8111fc64 <__reset+0xfb0ffc64>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111fd28:	e0bff517 	ldw	r2,-44(fp)
8111fd2c:	10800044 	addi	r2,r2,1
8111fd30:	e0bff515 	stw	r2,-44(fp)
8111fd34:	e0fff517 	ldw	r3,-44(fp)
8111fd38:	e0800317 	ldw	r2,12(fp)
8111fd3c:	18bfc736 	bltu	r3,r2,8111fc5c <__reset+0xfb0ffc5c>
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
8111fd40:	e0bff417 	ldw	r2,-48(fp)
8111fd44:	10002015 	stw	zero,128(r2)
8111fd48:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111fd4c:	e03ff705 	stb	zero,-36(fp)
8111fd50:	00001c06 	br	8111fdc4 <pattern_createPattern+0x1d0>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
8111fd54:	e13ff417 	ldw	r4,-48(fp)
8111fd58:	20802017 	ldw	r2,128(r4)
8111fd5c:	20c02117 	ldw	r3,132(r4)
8111fd60:	e13ff703 	ldbu	r4,-36(fp)
8111fd64:	217ff804 	addi	r5,r4,-32
8111fd68:	28000416 	blt	r5,zero,8111fd7c <pattern_createPattern+0x188>
8111fd6c:	01200034 	movhi	r4,32768
8111fd70:	2160d83a 	srl	r16,r4,r5
8111fd74:	0023883a 	mov	r17,zero
8111fd78:	00000a06 	br	8111fda4 <pattern_createPattern+0x1b0>
8111fd7c:	01600034 	movhi	r5,32768
8111fd80:	280c907a 	slli	r6,r5,1
8111fd84:	014007c4 	movi	r5,31
8111fd88:	290bc83a 	sub	r5,r5,r4
8111fd8c:	314a983a 	sll	r5,r6,r5
8111fd90:	000d883a 	mov	r6,zero
8111fd94:	3120d83a 	srl	r16,r6,r4
8111fd98:	2c20b03a 	or	r16,r5,r16
8111fd9c:	01600034 	movhi	r5,32768
8111fda0:	2922d83a 	srl	r17,r5,r4
8111fda4:	1424b03a 	or	r18,r2,r16
8111fda8:	1c66b03a 	or	r19,r3,r17
8111fdac:	e0bff417 	ldw	r2,-48(fp)
8111fdb0:	14802015 	stw	r18,128(r2)
8111fdb4:	14c02115 	stw	r19,132(r2)
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111fdb8:	e0bff703 	ldbu	r2,-36(fp)
8111fdbc:	10800044 	addi	r2,r2,1
8111fdc0:	e0bff705 	stb	r2,-36(fp)
8111fdc4:	e0fff703 	ldbu	r3,-36(fp)
8111fdc8:	e0bff303 	ldbu	r2,-52(fp)
8111fdcc:	18bfe136 	bltu	r3,r2,8111fd54 <__reset+0xfb0ffd54>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
	}

	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
8111fdd0:	e0bff217 	ldw	r2,-56(fp)
8111fdd4:	10802204 	addi	r2,r2,136
8111fdd8:	e0bff215 	stw	r2,-56(fp)
	return offset;
8111fddc:	e0bff217 	ldw	r2,-56(fp)
}
8111fde0:	e6fffc04 	addi	sp,fp,-16
8111fde4:	dfc00517 	ldw	ra,20(sp)
8111fde8:	df000417 	ldw	fp,16(sp)
8111fdec:	dcc00317 	ldw	r19,12(sp)
8111fdf0:	dc800217 	ldw	r18,8(sp)
8111fdf4:	dc400117 	ldw	r17,4(sp)
8111fdf8:	dc000017 	ldw	r16,0(sp)
8111fdfc:	dec00604 	addi	sp,sp,24
8111fe00:	f800283a 	ret

8111fe04 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
8111fe04:	defffe04 	addi	sp,sp,-8
8111fe08:	de00012e 	bgeu	sp,et,8111fe10 <bSDcardIsPresent+0xc>
8111fe0c:	003b68fa 	trap	3
8111fe10:	dfc00115 	stw	ra,4(sp)
8111fe14:	df000015 	stw	fp,0(sp)
8111fe18:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
8111fe1c:	114620c0 	call	8114620c <alt_up_sd_card_is_Present>
}
8111fe20:	e037883a 	mov	sp,fp
8111fe24:	dfc00117 	ldw	ra,4(sp)
8111fe28:	df000017 	ldw	fp,0(sp)
8111fe2c:	dec00204 	addi	sp,sp,8
8111fe30:	f800283a 	ret

8111fe34 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
8111fe34:	defffe04 	addi	sp,sp,-8
8111fe38:	de00012e 	bgeu	sp,et,8111fe40 <bSDcardFAT16Check+0xc>
8111fe3c:	003b68fa 	trap	3
8111fe40:	dfc00115 	stw	ra,4(sp)
8111fe44:	df000015 	stw	fp,0(sp)
8111fe48:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
8111fe4c:	11462d80 	call	811462d8 <alt_up_sd_card_is_FAT16>
}
8111fe50:	e037883a 	mov	sp,fp
8111fe54:	dfc00117 	ldw	ra,4(sp)
8111fe58:	df000017 	ldw	fp,0(sp)
8111fe5c:	dec00204 	addi	sp,sp,8
8111fe60:	f800283a 	ret

8111fe64 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
8111fe64:	defffd04 	addi	sp,sp,-12
8111fe68:	de00012e 	bgeu	sp,et,8111fe70 <bInitializeSDCard+0xc>
8111fe6c:	003b68fa 	trap	3
8111fe70:	dfc00215 	stw	ra,8(sp)
8111fe74:	df000115 	stw	fp,4(sp)
8111fe78:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
8111fe7c:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
8111fe80:	d0207715 	stw	zero,-32292(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
8111fe84:	01204574 	movhi	r4,33045
8111fe88:	2105ea04 	addi	r4,r4,6056
8111fe8c:	11461480 	call	81146148 <alt_up_sd_card_open_dev>
8111fe90:	d0a07715 	stw	r2,-32292(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
8111fe94:	d0a07717 	ldw	r2,-32292(gp)
8111fe98:	10002226 	beq	r2,zero,8111ff24 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
8111fe9c:	111fe040 	call	8111fe04 <bSDcardIsPresent>
8111fea0:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
8111fea4:	e0bfff17 	ldw	r2,-4(fp)
8111fea8:	10001626 	beq	r2,zero,8111ff04 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
8111feac:	111fe340 	call	8111fe34 <bSDcardFAT16Check>
8111feb0:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
8111feb4:	e0bfff17 	ldw	r2,-4(fp)
8111feb8:	10000a26 	beq	r2,zero,8111fee4 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
8111febc:	00800044 	movi	r2,1
8111fec0:	d0a07615 	stw	r2,-32296(gp)
				#if DEBUG_ON
					debug(fp, "SD is up.\r\n");
8111fec4:	d0a06217 	ldw	r2,-32376(gp)
8111fec8:	100f883a 	mov	r7,r2
8111fecc:	018002c4 	movi	r6,11
8111fed0:	01400044 	movi	r5,1
8111fed4:	01204574 	movhi	r4,33045
8111fed8:	2105f504 	addi	r4,r4,6100
8111fedc:	1122fc80 	call	81122fc8 <fwrite>
8111fee0:	00001806 	br	8111ff44 <bInitializeSDCard+0xe0>
				#endif

			} else {
				/* SD isn't in FAT16 format*/
				#if DEBUG_ON
					debug(fp, "SD Card should be formated in FAT16.\r\n");
8111fee4:	d0a06217 	ldw	r2,-32376(gp)
8111fee8:	100f883a 	mov	r7,r2
8111feec:	01800984 	movi	r6,38
8111fef0:	01400044 	movi	r5,1
8111fef4:	01204574 	movhi	r4,33045
8111fef8:	2105f804 	addi	r4,r4,6112
8111fefc:	1122fc80 	call	81122fc8 <fwrite>
8111ff00:	00001006 	br	8111ff44 <bInitializeSDCard+0xe0>
				#endif
			}
		} else {
			/* There's no SDCard in the slot */
			#if DEBUG_ON
				debug(fp, "There is no SD in the slot.\r\n");
8111ff04:	d0a06217 	ldw	r2,-32376(gp)
8111ff08:	100f883a 	mov	r7,r2
8111ff0c:	01800744 	movi	r6,29
8111ff10:	01400044 	movi	r5,1
8111ff14:	01204574 	movhi	r4,33045
8111ff18:	21060204 	addi	r4,r4,6152
8111ff1c:	1122fc80 	call	81122fc8 <fwrite>
8111ff20:	00000806 	br	8111ff44 <bInitializeSDCard+0xe0>
			#endif
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
8111ff24:	e03fff15 	stw	zero,-4(fp)
		#if DEBUG_ON
			debug(fp, "Unable to open the SDCard device.\r\n");
8111ff28:	d0a06217 	ldw	r2,-32376(gp)
8111ff2c:	100f883a 	mov	r7,r2
8111ff30:	018008c4 	movi	r6,35
8111ff34:	01400044 	movi	r5,1
8111ff38:	01204574 	movhi	r4,33045
8111ff3c:	21060a04 	addi	r4,r4,6184
8111ff40:	1122fc80 	call	81122fc8 <fwrite>
		#endif
	}

	return bSucess;
8111ff44:	e0bfff17 	ldw	r2,-4(fp)
}
8111ff48:	e037883a 	mov	sp,fp
8111ff4c:	dfc00117 	ldw	ra,4(sp)
8111ff50:	df000017 	ldw	fp,0(sp)
8111ff54:	dec00204 	addi	sp,sp,8
8111ff58:	f800283a 	ret

8111ff5c <siOpenFile>:

short int siOpenFile( char *filename ) {
8111ff5c:	defffd04 	addi	sp,sp,-12
8111ff60:	de00012e 	bgeu	sp,et,8111ff68 <siOpenFile+0xc>
8111ff64:	003b68fa 	trap	3
8111ff68:	dfc00215 	stw	ra,8(sp)
8111ff6c:	df000115 	stw	fp,4(sp)
8111ff70:	df000104 	addi	fp,sp,4
8111ff74:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
8111ff78:	000b883a 	mov	r5,zero
8111ff7c:	e13fff17 	ldw	r4,-4(fp)
8111ff80:	11467e40 	call	811467e4 <alt_up_sd_card_fopen>
}
8111ff84:	e037883a 	mov	sp,fp
8111ff88:	dfc00117 	ldw	ra,4(sp)
8111ff8c:	df000017 	ldw	fp,0(sp)
8111ff90:	dec00204 	addi	sp,sp,8
8111ff94:	f800283a 	ret

8111ff98 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
8111ff98:	defffd04 	addi	sp,sp,-12
8111ff9c:	de00012e 	bgeu	sp,et,8111ffa4 <siCloseFile+0xc>
8111ffa0:	003b68fa 	trap	3
8111ffa4:	dfc00215 	stw	ra,8(sp)
8111ffa8:	df000115 	stw	fp,4(sp)
8111ffac:	df000104 	addi	fp,sp,4
8111ffb0:	2005883a 	mov	r2,r4
8111ffb4:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
8111ffb8:	e0bfff0f 	ldh	r2,-4(fp)
8111ffbc:	1009883a 	mov	r4,r2
8111ffc0:	11476300 	call	81147630 <alt_up_sd_card_fclose>
}
8111ffc4:	e037883a 	mov	sp,fp
8111ffc8:	dfc00117 	ldw	ra,4(sp)
8111ffcc:	df000017 	ldw	fp,0(sp)
8111ffd0:	dec00204 	addi	sp,sp,8
8111ffd4:	f800283a 	ret

8111ffd8 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
8111ffd8:	defffd04 	addi	sp,sp,-12
8111ffdc:	de00012e 	bgeu	sp,et,8111ffe4 <cGetNextChar+0xc>
8111ffe0:	003b68fa 	trap	3
8111ffe4:	dfc00215 	stw	ra,8(sp)
8111ffe8:	df000115 	stw	fp,4(sp)
8111ffec:	df000104 	addi	fp,sp,4
8111fff0:	2005883a 	mov	r2,r4
8111fff4:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
8111fff8:	e0bfff0f 	ldh	r2,-4(fp)
8111fffc:	1009883a 	mov	r4,r2
81120000:	1146c880 	call	81146c88 <alt_up_sd_card_read>
}
81120004:	e037883a 	mov	sp,fp
81120008:	dfc00117 	ldw	ra,4(sp)
8112000c:	df000017 	ldw	fp,0(sp)
81120010:	dec00204 	addi	sp,sp,8
81120014:	f800283a 	ret

81120018 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
81120018:	defffd04 	addi	sp,sp,-12
8112001c:	de00012e 	bgeu	sp,et,81120024 <bInitSync+0xc>
81120020:	003b68fa 	trap	3
81120024:	dfc00215 	stw	ra,8(sp)
81120028:	df000115 	stw	fp,4(sp)
8112002c:	df000104 	addi	fp,sp,4
	bool	bSuccess;

	vSyncInitIrq();
81120030:	110cb0c0 	call	8110cb0c <vSyncInitIrq>

	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
81120034:	00a045b4 	movhi	r2,33046
81120038:	109fe204 	addi	r2,r2,32648
8112003c:	10800d8b 	ldhu	r2,54(r2)
81120040:	10bfffcc 	andi	r2,r2,65535
81120044:	108000e8 	cmpgeui	r2,r2,3
81120048:	1000071e 	bne	r2,zero,81120068 <bInitSync+0x50>
		debug(fp, "Initializing Sync Module.\n");
8112004c:	d0a06217 	ldw	r2,-32376(gp)
81120050:	100f883a 	mov	r7,r2
81120054:	01800684 	movi	r6,26
81120058:	01400044 	movi	r5,1
8112005c:	01204574 	movhi	r4,33045
81120060:	21061304 	addi	r4,r4,6220
81120064:	1122fc80 	call	81122fc8 <fwrite>
	}
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
81120068:	01004c74 	movhi	r4,305
8112006c:	210b4004 	addi	r4,r4,11520
81120070:	110cd140 	call	8110cd14 <bSyncSetMbt>
81120074:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120078:	e0bfff17 	ldw	r2,-4(fp)
8112007c:	1000021e 	bne	r2,zero,81120088 <bInitSync+0x70>
		return bSuccess;
81120080:	e0bfff17 	ldw	r2,-4(fp)
81120084:	00004d06 	br	811201bc <bInitSync+0x1a4>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
81120088:	01002674 	movhi	r4,153
8112008c:	2125a004 	addi	r4,r4,-27008
81120090:	110cd540 	call	8110cd54 <bSyncSetBt>
81120094:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120098:	e0bfff17 	ldw	r2,-4(fp)
8112009c:	1000021e 	bne	r2,zero,811200a8 <bInitSync+0x90>
		return bSuccess;
811200a0:	e0bfff17 	ldw	r2,-4(fp)
811200a4:	00004506 	br	811201bc <bInitSync+0x1a4>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer(  uliPerCalcPeriodMs( xDefaults.usiSyncPeriod ) );
811200a8:	00a045b4 	movhi	r2,33046
811200ac:	109fe204 	addi	r2,r2,32648
811200b0:	1080068b 	ldhu	r2,26(r2)
811200b4:	10bfffcc 	andi	r2,r2,65535
811200b8:	1009883a 	mov	r4,r2
811200bc:	110d9ec0 	call	8110d9ec <uliPerCalcPeriodMs>
811200c0:	1009883a 	mov	r4,r2
811200c4:	110cd940 	call	8110cd94 <bSyncSetPer>
811200c8:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
811200cc:	e0bfff17 	ldw	r2,-4(fp)
811200d0:	1000021e 	bne	r2,zero,811200dc <bInitSync+0xc4>
		return bSuccess;
811200d4:	e0bfff17 	ldw	r2,-4(fp)
811200d8:	00003806 	br	811201bc <bInitSync+0x1a4>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
811200dc:	01005f74 	movhi	r4,381
811200e0:	211e1004 	addi	r4,r4,30784
811200e4:	110cdd40 	call	8110cdd4 <bSyncSetOst>
811200e8:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
811200ec:	e0bfff17 	ldw	r2,-4(fp)
811200f0:	1000021e 	bne	r2,zero,811200fc <bInitSync+0xe4>
		return bSuccess;
811200f4:	e0bfff17 	ldw	r2,-4(fp)
811200f8:	00003006 	br	811201bc <bInitSync+0x1a4>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
811200fc:	0009883a 	mov	r4,zero
81120100:	110ce140 	call	8110ce14 <bSyncSetPolarity>
81120104:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120108:	e0bfff17 	ldw	r2,-4(fp)
8112010c:	1000021e 	bne	r2,zero,81120118 <bInitSync+0x100>
		return bSuccess;
81120110:	e0bfff17 	ldw	r2,-4(fp)
81120114:	00002906 	br	811201bc <bInitSync+0x1a4>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
81120118:	01000104 	movi	r4,4
8112011c:	110ce880 	call	8110ce88 <bSyncSetNCycles>
81120120:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120124:	e0bfff17 	ldw	r2,-4(fp)
81120128:	1000021e 	bne	r2,zero,81120134 <bInitSync+0x11c>
		return bSuccess;
8112012c:	e0bfff17 	ldw	r2,-4(fp)
81120130:	00002206 	br	811201bc <bInitSync+0x1a4>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
81120134:	01000044 	movi	r4,1
81120138:	110d0640 	call	8110d064 <bSyncCtrExtnIrq>
8112013c:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120140:	e0bfff17 	ldw	r2,-4(fp)
81120144:	1000021e 	bne	r2,zero,81120150 <bInitSync+0x138>
		return bSuccess;
81120148:	e0bfff17 	ldw	r2,-4(fp)
8112014c:	00001b06 	br	811201bc <bInitSync+0x1a4>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
81120150:	01000044 	movi	r4,1
81120154:	110d22c0 	call	8110d22c <bSyncCtrSyncOutEnable>
81120158:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8112015c:	e0bfff17 	ldw	r2,-4(fp)
81120160:	1000021e 	bne	r2,zero,8112016c <bInitSync+0x154>
		return bSuccess;
81120164:	e0bfff17 	ldw	r2,-4(fp)
81120168:	00001406 	br	811201bc <bInitSync+0x1a4>
	}


	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
8112016c:	01000044 	movi	r4,1
81120170:	110d2a00 	call	8110d2a0 <bSyncCtrCh1OutEnable>
81120174:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120178:	e0bfff17 	ldw	r2,-4(fp)
8112017c:	1000021e 	bne	r2,zero,81120188 <bInitSync+0x170>
		return bSuccess;
81120180:	e0bfff17 	ldw	r2,-4(fp)
81120184:	00000d06 	br	811201bc <bInitSync+0x1a4>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh2OutEnable(TRUE);
81120188:	01000044 	movi	r4,1
8112018c:	110d3140 	call	8110d314 <bSyncCtrCh2OutEnable>
81120190:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
81120194:	e0bfff17 	ldw	r2,-4(fp)
81120198:	1000021e 	bne	r2,zero,811201a4 <bInitSync+0x18c>
		return bSuccess;
8112019c:	e0bfff17 	ldw	r2,-4(fp)
811201a0:	00000606 	br	811201bc <bInitSync+0x1a4>
	}

	bSuccess = bSyncCtrStart();
811201a4:	110d0dc0 	call	8110d0dc <bSyncCtrStart>
811201a8:	e0bfff15 	stw	r2,-4(fp)
	bSyncCtrReset();
811201ac:	110d1300 	call	8110d130 <bSyncCtrReset>
	bSyncIrqEnableBlank(TRUE);
811201b0:	01000044 	movi	r4,1
811201b4:	110d6b40 	call	8110d6b4 <bSyncIrqEnableBlank>


	return bSuccess;
811201b8:	e0bfff17 	ldw	r2,-4(fp)
}
811201bc:	e037883a 	mov	sp,fp
811201c0:	dfc00117 	ldw	ra,4(sp)
811201c4:	df000017 	ldw	fp,0(sp)
811201c8:	dec00204 	addi	sp,sp,8
811201cc:	f800283a 	ret

811201d0 <bStartSync>:


bool bStartSync(void) {
811201d0:	defffd04 	addi	sp,sp,-12
811201d4:	de00012e 	bgeu	sp,et,811201dc <bStartSync+0xc>
811201d8:	003b68fa 	trap	3
811201dc:	dfc00215 	stw	ra,8(sp)
811201e0:	df000115 	stw	fp,4(sp)
811201e4:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSyncCtrReset();
811201e8:	110d1300 	call	8110d130 <bSyncCtrReset>
	bSuccess = bSyncCtrStart();
811201ec:	110d0dc0 	call	8110d0dc <bSyncCtrStart>
811201f0:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
811201f4:	e0bfff17 	ldw	r2,-4(fp)
}
811201f8:	e037883a 	mov	sp,fp
811201fc:	dfc00117 	ldw	ra,4(sp)
81120200:	df000017 	ldw	fp,0(sp)
81120204:	dec00204 	addi	sp,sp,8
81120208:	f800283a 	ret

8112020c <bStopSync>:

bool bStopSync(void) {
8112020c:	defffe04 	addi	sp,sp,-8
81120210:	de00012e 	bgeu	sp,et,81120218 <bStopSync+0xc>
81120214:	003b68fa 	trap	3
81120218:	dfc00115 	stw	ra,4(sp)
8112021c:	df000015 	stw	fp,0(sp)
81120220:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
81120224:	110d1300 	call	8110d130 <bSyncCtrReset>
}
81120228:	e037883a 	mov	sp,fp
8112022c:	dfc00117 	ldw	ra,4(sp)
81120230:	df000017 	ldw	fp,0(sp)
81120234:	dec00204 	addi	sp,sp,8
81120238:	f800283a 	ret

8112023c <bClearCounterSync>:

void bClearCounterSync(void) {
8112023c:	defffe04 	addi	sp,sp,-8
81120240:	de00012e 	bgeu	sp,et,81120248 <bClearCounterSync+0xc>
81120244:	003b68fa 	trap	3
81120248:	dfc00115 	stw	ra,4(sp)
8112024c:	df000015 	stw	fp,0(sp)
81120250:	d839883a 	mov	fp,sp
	vSyncClearCounter();
81120254:	110cae00 	call	8110cae0 <vSyncClearCounter>
}
81120258:	0001883a 	nop
8112025c:	e037883a 	mov	sp,fp
81120260:	dfc00117 	ldw	ra,4(sp)
81120264:	df000017 	ldw	fp,0(sp)
81120268:	dec00204 	addi	sp,sp,8
8112026c:	f800283a 	ret

81120270 <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
81120270:	defffd04 	addi	sp,sp,-12
81120274:	de00012e 	bgeu	sp,et,8112027c <bTestSimucamCriticalHW+0xc>
81120278:	003b68fa 	trap	3
8112027c:	dfc00215 	stw	ra,8(sp)
81120280:	df000115 	stw	fp,4(sp)
81120284:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
81120288:	1103b300 	call	81103b30 <bSdmaInitM1Dma>
8112028c:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
81120290:	e0bfff17 	ldw	r2,-4(fp)
81120294:	1000021e 	bne	r2,zero,811202a0 <bTestSimucamCriticalHW+0x30>
		return bSuccess;
81120298:	e0bfff17 	ldw	r2,-4(fp)
8112029c:	00000706 	br	811202bc <bTestSimucamCriticalHW+0x4c>
	}

	bSuccess = bSdmaInitM2Dma();
811202a0:	1103bec0 	call	81103bec <bSdmaInitM2Dma>
811202a4:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
811202a8:	e0bfff17 	ldw	r2,-4(fp)
811202ac:	1000021e 	bne	r2,zero,811202b8 <bTestSimucamCriticalHW+0x48>
		return bSuccess;
811202b0:	e0bfff17 	ldw	r2,-4(fp)
811202b4:	00000106 	br	811202bc <bTestSimucamCriticalHW+0x4c>

	//xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
	//xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;


	return TRUE;
811202b8:	00800044 	movi	r2,1
}
811202bc:	e037883a 	mov	sp,fp
811202c0:	dfc00117 	ldw	ra,4(sp)
811202c4:	df000017 	ldw	fp,0(sp)
811202c8:	dec00204 	addi	sp,sp,8
811202cc:	f800283a 	ret

811202d0 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
811202d0:	defffc04 	addi	sp,sp,-16
811202d4:	de00012e 	bgeu	sp,et,811202dc <_reg_write+0xc>
811202d8:	003b68fa 	trap	3
811202dc:	df000315 	stw	fp,12(sp)
811202e0:	df000304 	addi	fp,sp,12
811202e4:	e13ffd15 	stw	r4,-12(fp)
811202e8:	e17ffe15 	stw	r5,-8(fp)
811202ec:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
811202f0:	e0bffe17 	ldw	r2,-8(fp)
811202f4:	1085883a 	add	r2,r2,r2
811202f8:	1085883a 	add	r2,r2,r2
811202fc:	1007883a 	mov	r3,r2
81120300:	e0bffd17 	ldw	r2,-12(fp)
81120304:	1885883a 	add	r2,r3,r2
81120308:	1007883a 	mov	r3,r2
8112030c:	e0bfff17 	ldw	r2,-4(fp)
81120310:	18800035 	stwio	r2,0(r3)
	return 1;
81120314:	00800044 	movi	r2,1

}
81120318:	e037883a 	mov	sp,fp
8112031c:	df000017 	ldw	fp,0(sp)
81120320:	dec00104 	addi	sp,sp,4
81120324:	f800283a 	ret

81120328 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
81120328:	defffc04 	addi	sp,sp,-16
8112032c:	de00012e 	bgeu	sp,et,81120334 <_reg_read+0xc>
81120330:	003b68fa 	trap	3
81120334:	df000315 	stw	fp,12(sp)
81120338:	df000304 	addi	fp,sp,12
8112033c:	e13ffd15 	stw	r4,-12(fp)
81120340:	e17ffe15 	stw	r5,-8(fp)
81120344:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
81120348:	e0bffe17 	ldw	r2,-8(fp)
8112034c:	1085883a 	add	r2,r2,r2
81120350:	1085883a 	add	r2,r2,r2
81120354:	1007883a 	mov	r3,r2
81120358:	e0bffd17 	ldw	r2,-12(fp)
8112035c:	1885883a 	add	r2,r3,r2
81120360:	10c00037 	ldwio	r3,0(r2)
81120364:	e0bfff17 	ldw	r2,-4(fp)
81120368:	10c00015 	stw	r3,0(r2)
	return 1;
8112036c:	00800044 	movi	r2,1

}
81120370:	e037883a 	mov	sp,fp
81120374:	df000017 	ldw	fp,0(sp)
81120378:	dec00104 	addi	sp,sp,4
8112037c:	f800283a 	ret

81120380 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
81120380:	defffa04 	addi	sp,sp,-24
81120384:	de00012e 	bgeu	sp,et,8112038c <_print_codec_status+0xc>
81120388:	003b68fa 	trap	3
8112038c:	dfc00515 	stw	ra,20(sp)
81120390:	df000415 	stw	fp,16(sp)
81120394:	df000404 	addi	fp,sp,16
81120398:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
8112039c:	e0bfff17 	ldw	r2,-4(fp)
811203a0:	1005d1ba 	srai	r2,r2,6
811203a4:	1080004c 	andi	r2,r2,1
811203a8:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
811203ac:	e0bfff17 	ldw	r2,-4(fp)
811203b0:	1005d17a 	srai	r2,r2,5
811203b4:	1080004c 	andi	r2,r2,1
811203b8:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
811203bc:	e0bfff17 	ldw	r2,-4(fp)
811203c0:	1005d13a 	srai	r2,r2,4
811203c4:	1080004c 	andi	r2,r2,1
811203c8:	e0bffe15 	stw	r2,-8(fp)

#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
811203cc:	00a045b4 	movhi	r2,33046
811203d0:	109fe204 	addi	r2,r2,32648
811203d4:	10800d8b 	ldhu	r2,54(r2)
811203d8:	10bfffcc 	andi	r2,r2,65535
811203dc:	108000e8 	cmpgeui	r2,r2,3
811203e0:	1000661e 	bne	r2,zero,8112057c <_print_codec_status+0x1fc>
		sprintf(cDebugBuffer, "-------- link status \n");
811203e4:	00e04574 	movhi	r3,33045
811203e8:	18d1fe04 	addi	r3,r3,18424
811203ec:	00a04574 	movhi	r2,33045
811203f0:	10861a04 	addi	r2,r2,6248
811203f4:	1009883a 	mov	r4,r2
811203f8:	008005c4 	movi	r2,23
811203fc:	100d883a 	mov	r6,r2
81120400:	200b883a 	mov	r5,r4
81120404:	1809883a 	mov	r4,r3
81120408:	11239dc0 	call	811239dc <memcpy>
		debug(fp, cDebugBuffer);
8112040c:	d0a06217 	ldw	r2,-32376(gp)
81120410:	01604574 	movhi	r5,33045
81120414:	2951fe04 	addi	r5,r5,18424
81120418:	1009883a 	mov	r4,r2
8112041c:	112292c0 	call	8112292c <fprintf>
		sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
81120420:	e0bffc17 	ldw	r2,-16(fp)
81120424:	10800058 	cmpnei	r2,r2,1
81120428:	1000031e 	bne	r2,zero,81120438 <_print_codec_status+0xb8>
8112042c:	00a04574 	movhi	r2,33045
81120430:	10862004 	addi	r2,r2,6272
81120434:	00000206 	br	81120440 <_print_codec_status+0xc0>
81120438:	00a04574 	movhi	r2,33045
8112043c:	10862104 	addi	r2,r2,6276
81120440:	100d883a 	mov	r6,r2
81120444:	01604574 	movhi	r5,33045
81120448:	29462204 	addi	r5,r5,6280
8112044c:	01204574 	movhi	r4,33045
81120450:	2111fe04 	addi	r4,r4,18424
81120454:	11242400 	call	81124240 <sprintf>
		debug(fp, cDebugBuffer);
81120458:	d0a06217 	ldw	r2,-32376(gp)
8112045c:	01604574 	movhi	r5,33045
81120460:	2951fe04 	addi	r5,r5,18424
81120464:	1009883a 	mov	r4,r2
81120468:	112292c0 	call	8112292c <fprintf>
		sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
8112046c:	e0bffd17 	ldw	r2,-12(fp)
81120470:	10800058 	cmpnei	r2,r2,1
81120474:	1000031e 	bne	r2,zero,81120484 <_print_codec_status+0x104>
81120478:	00a04574 	movhi	r2,33045
8112047c:	10862004 	addi	r2,r2,6272
81120480:	00000206 	br	8112048c <_print_codec_status+0x10c>
81120484:	00a04574 	movhi	r2,33045
81120488:	10862104 	addi	r2,r2,6276
8112048c:	100d883a 	mov	r6,r2
81120490:	01604574 	movhi	r5,33045
81120494:	29462804 	addi	r5,r5,6304
81120498:	01204574 	movhi	r4,33045
8112049c:	2111fe04 	addi	r4,r4,18424
811204a0:	11242400 	call	81124240 <sprintf>
		debug(fp, cDebugBuffer);
811204a4:	d0a06217 	ldw	r2,-32376(gp)
811204a8:	01604574 	movhi	r5,33045
811204ac:	2951fe04 	addi	r5,r5,18424
811204b0:	1009883a 	mov	r4,r2
811204b4:	112292c0 	call	8112292c <fprintf>
		sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
811204b8:	e0bffe17 	ldw	r2,-8(fp)
811204bc:	10800058 	cmpnei	r2,r2,1
811204c0:	1000031e 	bne	r2,zero,811204d0 <_print_codec_status+0x150>
811204c4:	00a04574 	movhi	r2,33045
811204c8:	10862004 	addi	r2,r2,6272
811204cc:	00000206 	br	811204d8 <_print_codec_status+0x158>
811204d0:	00a04574 	movhi	r2,33045
811204d4:	10862104 	addi	r2,r2,6276
811204d8:	100d883a 	mov	r6,r2
811204dc:	01604574 	movhi	r5,33045
811204e0:	29462e04 	addi	r5,r5,6328
811204e4:	01204574 	movhi	r4,33045
811204e8:	2111fe04 	addi	r4,r4,18424
811204ec:	11242400 	call	81124240 <sprintf>
		debug(fp, cDebugBuffer);
811204f0:	d0a06217 	ldw	r2,-32376(gp)
811204f4:	01604574 	movhi	r5,33045
811204f8:	2951fe04 	addi	r5,r5,18424
811204fc:	1009883a 	mov	r4,r2
81120500:	112292c0 	call	8112292c <fprintf>
		sprintf(cDebugBuffer, "--------  \n");
81120504:	00a04574 	movhi	r2,33045
81120508:	1091fe04 	addi	r2,r2,18424
8112050c:	00c00b44 	movi	r3,45
81120510:	10c00005 	stb	r3,0(r2)
81120514:	00c00b44 	movi	r3,45
81120518:	10c00045 	stb	r3,1(r2)
8112051c:	00c00b44 	movi	r3,45
81120520:	10c00085 	stb	r3,2(r2)
81120524:	00c00b44 	movi	r3,45
81120528:	10c000c5 	stb	r3,3(r2)
8112052c:	00c00b44 	movi	r3,45
81120530:	10c00105 	stb	r3,4(r2)
81120534:	00c00b44 	movi	r3,45
81120538:	10c00145 	stb	r3,5(r2)
8112053c:	00c00b44 	movi	r3,45
81120540:	10c00185 	stb	r3,6(r2)
81120544:	00c00b44 	movi	r3,45
81120548:	10c001c5 	stb	r3,7(r2)
8112054c:	00c00804 	movi	r3,32
81120550:	10c00205 	stb	r3,8(r2)
81120554:	00c00804 	movi	r3,32
81120558:	10c00245 	stb	r3,9(r2)
8112055c:	00c00284 	movi	r3,10
81120560:	10c00285 	stb	r3,10(r2)
81120564:	100002c5 	stb	zero,11(r2)
		debug(fp, cDebugBuffer);
81120568:	d0a06217 	ldw	r2,-32376(gp)
8112056c:	01604574 	movhi	r5,33045
81120570:	2951fe04 	addi	r5,r5,18424
81120574:	1009883a 	mov	r4,r2
81120578:	112292c0 	call	8112292c <fprintf>
	}
#endif
}
8112057c:	0001883a 	nop
81120580:	e037883a 	mov	sp,fp
81120584:	dfc00117 	ldw	ra,4(sp)
81120588:	df000017 	ldw	fp,0(sp)
8112058c:	dec00204 	addi	sp,sp,8
81120590:	f800283a 	ret

81120594 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
81120594:	defffb04 	addi	sp,sp,-20
81120598:	de00012e 	bgeu	sp,et,811205a0 <_split_codec_status+0xc>
8112059c:	003b68fa 	trap	3
811205a0:	df000415 	stw	fp,16(sp)
811205a4:	df000404 	addi	fp,sp,16
811205a8:	e13ffc15 	stw	r4,-16(fp)
811205ac:	e17ffd15 	stw	r5,-12(fp)
811205b0:	e1bffe15 	stw	r6,-8(fp)
811205b4:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
811205b8:	e0bffc17 	ldw	r2,-16(fp)
811205bc:	1005d1ba 	srai	r2,r2,6
811205c0:	10c0004c 	andi	r3,r2,1
811205c4:	e0bffd17 	ldw	r2,-12(fp)
811205c8:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
811205cc:	e0bffc17 	ldw	r2,-16(fp)
811205d0:	1005d17a 	srai	r2,r2,5
811205d4:	10c0004c 	andi	r3,r2,1
811205d8:	e0bffe17 	ldw	r2,-8(fp)
811205dc:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
811205e0:	e0bffc17 	ldw	r2,-16(fp)
811205e4:	1005d13a 	srai	r2,r2,4
811205e8:	10c0004c 	andi	r3,r2,1
811205ec:	e0bfff17 	ldw	r2,-4(fp)
811205f0:	10c00015 	stw	r3,0(r2)
}
811205f4:	0001883a 	nop
811205f8:	e037883a 	mov	sp,fp
811205fc:	df000017 	ldw	fp,0(sp)
81120600:	dec00104 	addi	sp,sp,4
81120604:	f800283a 	ret

81120608 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
81120608:	defffc04 	addi	sp,sp,-16
8112060c:	de00012e 	bgeu	sp,et,81120614 <aatoh+0xc>
81120610:	003b68fa 	trap	3
81120614:	df000315 	stw	fp,12(sp)
81120618:	df000304 	addi	fp,sp,12
8112061c:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
81120620:	e0bfff17 	ldw	r2,-4(fp)
81120624:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81120628:	e0bffd17 	ldw	r2,-12(fp)
8112062c:	10c00003 	ldbu	r3,0(r2)
81120630:	e0bffd17 	ldw	r2,-12(fp)
81120634:	10800003 	ldbu	r2,0(r2)
81120638:	10803fcc 	andi	r2,r2,255
8112063c:	10800eb0 	cmpltui	r2,r2,58
81120640:	1000021e 	bne	r2,zero,8112064c <aatoh+0x44>
81120644:	00800dc4 	movi	r2,55
81120648:	00000106 	br	81120650 <aatoh+0x48>
8112064c:	00800c04 	movi	r2,48
81120650:	1885c83a 	sub	r2,r3,r2
81120654:	1004913a 	slli	r2,r2,4
81120658:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
8112065c:	e0bffd17 	ldw	r2,-12(fp)
81120660:	10800044 	addi	r2,r2,1
81120664:	10c00003 	ldbu	r3,0(r2)
81120668:	e0bffd17 	ldw	r2,-12(fp)
8112066c:	10800044 	addi	r2,r2,1
81120670:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81120674:	10803fcc 	andi	r2,r2,255
81120678:	10800eb0 	cmpltui	r2,r2,58
8112067c:	1000021e 	bne	r2,zero,81120688 <aatoh+0x80>
81120680:	00800dc4 	movi	r2,55
81120684:	00000106 	br	8112068c <aatoh+0x84>
81120688:	00800c04 	movi	r2,48
8112068c:	1885c83a 	sub	r2,r3,r2
81120690:	2085883a 	add	r2,r4,r2
81120694:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
81120698:	e0bffe03 	ldbu	r2,-8(fp)
}
8112069c:	e037883a 	mov	sp,fp
811206a0:	df000017 	ldw	fp,0(sp)
811206a4:	dec00104 	addi	sp,sp,4
811206a8:	f800283a 	ret

811206ac <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
811206ac:	defffd04 	addi	sp,sp,-12
811206b0:	de00012e 	bgeu	sp,et,811206b8 <Verif_Error+0xc>
811206b4:	003b68fa 	trap	3
811206b8:	dfc00215 	stw	ra,8(sp)
811206bc:	df000115 	stw	fp,4(sp)
811206c0:	df000104 	addi	fp,sp,4
811206c4:	2005883a 	mov	r2,r4
811206c8:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
811206cc:	e0bfff03 	ldbu	r2,-4(fp)
811206d0:	10000f1e 	bne	r2,zero,81120710 <Verif_Error+0x64>
#if DEBUG_ON
if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
811206d4:	00a045b4 	movhi	r2,33046
811206d8:	109fe204 	addi	r2,r2,32648
811206dc:	10800d8b 	ldhu	r2,54(r2)
811206e0:	10bfffcc 	andi	r2,r2,65535
811206e4:	10800228 	cmpgeui	r2,r2,8
811206e8:	1000071e 	bne	r2,zero,81120708 <Verif_Error+0x5c>
	debug(fp, "ERROR\n\r");
811206ec:	d0a06217 	ldw	r2,-32376(gp)
811206f0:	100f883a 	mov	r7,r2
811206f4:	018001c4 	movi	r6,7
811206f8:	01400044 	movi	r5,1
811206fc:	01204574 	movhi	r4,33045
81120700:	21063404 	addi	r4,r4,6352
81120704:	1122fc80 	call	81122fc8 <fwrite>
}
#endif
		return 0;
81120708:	0005883a 	mov	r2,zero
8112070c:	00000106 	br	81120714 <Verif_Error+0x68>
	} else
		return 1;
81120710:	00800044 	movi	r2,1
}
81120714:	e037883a 	mov	sp,fp
81120718:	dfc00117 	ldw	ra,4(sp)
8112071c:	df000017 	ldw	fp,0(sp)
81120720:	dec00204 	addi	sp,sp,8
81120724:	f800283a 	ret

81120728 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
81120728:	defffe04 	addi	sp,sp,-8
8112072c:	de00012e 	bgeu	sp,et,81120734 <toInt+0xc>
81120730:	003b68fa 	trap	3
81120734:	df000115 	stw	fp,4(sp)
81120738:	df000104 	addi	fp,sp,4
8112073c:	2005883a 	mov	r2,r4
81120740:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
81120744:	e0bfff03 	ldbu	r2,-4(fp)
81120748:	10bff404 	addi	r2,r2,-48
}
8112074c:	e037883a 	mov	sp,fp
81120750:	df000017 	ldw	fp,0(sp)
81120754:	dec00104 	addi	sp,sp,4
81120758:	f800283a 	ret

8112075c <__fixunsdfsi>:
8112075c:	defffd04 	addi	sp,sp,-12
81120760:	000d883a 	mov	r6,zero
81120764:	01d07834 	movhi	r7,16864
81120768:	de00012e 	bgeu	sp,et,81120770 <__fixunsdfsi+0x14>
8112076c:	003b68fa 	trap	3
81120770:	dc400115 	stw	r17,4(sp)
81120774:	dc000015 	stw	r16,0(sp)
81120778:	dfc00215 	stw	ra,8(sp)
8112077c:	2023883a 	mov	r17,r4
81120780:	2821883a 	mov	r16,r5
81120784:	11212480 	call	81121248 <__gedf2>
81120788:	1000080e 	bge	r2,zero,811207ac <__fixunsdfsi+0x50>
8112078c:	8809883a 	mov	r4,r17
81120790:	800b883a 	mov	r5,r16
81120794:	11223480 	call	81122348 <__fixdfsi>
81120798:	dfc00217 	ldw	ra,8(sp)
8112079c:	dc400117 	ldw	r17,4(sp)
811207a0:	dc000017 	ldw	r16,0(sp)
811207a4:	dec00304 	addi	sp,sp,12
811207a8:	f800283a 	ret
811207ac:	000d883a 	mov	r6,zero
811207b0:	01d07834 	movhi	r7,16864
811207b4:	8809883a 	mov	r4,r17
811207b8:	800b883a 	mov	r5,r16
811207bc:	1121a440 	call	81121a44 <__subdf3>
811207c0:	180b883a 	mov	r5,r3
811207c4:	1009883a 	mov	r4,r2
811207c8:	11223480 	call	81122348 <__fixdfsi>
811207cc:	00e00034 	movhi	r3,32768
811207d0:	10c5883a 	add	r2,r2,r3
811207d4:	003ff006 	br	81120798 <__reset+0xfb100798>

811207d8 <__divsf3>:
811207d8:	defff504 	addi	sp,sp,-44
811207dc:	200cd5fa 	srli	r6,r4,23
811207e0:	de00012e 	bgeu	sp,et,811207e8 <__divsf3+0x10>
811207e4:	003b68fa 	trap	3
811207e8:	dcc00415 	stw	r19,16(sp)
811207ec:	2026d7fa 	srli	r19,r4,31
811207f0:	00c02034 	movhi	r3,128
811207f4:	dd800715 	stw	r22,28(sp)
811207f8:	dd000515 	stw	r20,20(sp)
811207fc:	dc800315 	stw	r18,12(sp)
81120800:	18ffffc4 	addi	r3,r3,-1
81120804:	dfc00a15 	stw	ra,40(sp)
81120808:	df000915 	stw	fp,36(sp)
8112080c:	ddc00815 	stw	r23,32(sp)
81120810:	dd400615 	stw	r21,24(sp)
81120814:	dc400215 	stw	r17,8(sp)
81120818:	dc000115 	stw	r16,4(sp)
8112081c:	35003fcc 	andi	r20,r6,255
81120820:	1924703a 	and	r18,r3,r4
81120824:	9d803fcc 	andi	r22,r19,255
81120828:	a0005226 	beq	r20,zero,81120974 <__divsf3+0x19c>
8112082c:	00803fc4 	movi	r2,255
81120830:	a0802e26 	beq	r20,r2,811208ec <__divsf3+0x114>
81120834:	91002034 	orhi	r4,r18,128
81120838:	202490fa 	slli	r18,r4,3
8112083c:	a53fe044 	addi	r20,r20,-127
81120840:	0021883a 	mov	r16,zero
81120844:	002f883a 	mov	r23,zero
81120848:	280cd5fa 	srli	r6,r5,23
8112084c:	282ad7fa 	srli	r21,r5,31
81120850:	00c02034 	movhi	r3,128
81120854:	18ffffc4 	addi	r3,r3,-1
81120858:	31803fcc 	andi	r6,r6,255
8112085c:	1962703a 	and	r17,r3,r5
81120860:	af003fcc 	andi	fp,r21,255
81120864:	30004a26 	beq	r6,zero,81120990 <__divsf3+0x1b8>
81120868:	00803fc4 	movi	r2,255
8112086c:	30804526 	beq	r6,r2,81120984 <__divsf3+0x1ac>
81120870:	89402034 	orhi	r5,r17,128
81120874:	282290fa 	slli	r17,r5,3
81120878:	31bfe044 	addi	r6,r6,-127
8112087c:	000b883a 	mov	r5,zero
81120880:	2c20b03a 	or	r16,r5,r16
81120884:	802090ba 	slli	r16,r16,2
81120888:	00a044b4 	movhi	r2,33042
8112088c:	10822b04 	addi	r2,r2,2220
81120890:	80a1883a 	add	r16,r16,r2
81120894:	81000017 	ldw	r4,0(r16)
81120898:	9d46f03a 	xor	r3,r19,r21
8112089c:	180f883a 	mov	r7,r3
811208a0:	18803fcc 	andi	r2,r3,255
811208a4:	a18dc83a 	sub	r6,r20,r6
811208a8:	2000683a 	jmp	r4
811208ac:	81120a90 	cmplti	r4,r16,18474
811208b0:	81120914 	ori	r4,r16,18468
811208b4:	81120a84 	addi	r4,r16,18474
811208b8:	81120900 	call	88112090 <__reset+0x20f2090>
811208bc:	81120a84 	addi	r4,r16,18474
811208c0:	81120a5c 	xori	r4,r16,18473
811208c4:	81120a84 	addi	r4,r16,18474
811208c8:	81120900 	call	88112090 <__reset+0x20f2090>
811208cc:	81120914 	ori	r4,r16,18468
811208d0:	81120914 	ori	r4,r16,18468
811208d4:	81120a5c 	xori	r4,r16,18473
811208d8:	81120900 	call	88112090 <__reset+0x20f2090>
811208dc:	81120b70 	cmpltui	r4,r16,18477
811208e0:	81120b70 	cmpltui	r4,r16,18477
811208e4:	81120b70 	cmpltui	r4,r16,18477
811208e8:	81120b24 	muli	r4,r16,18476
811208ec:	9000581e 	bne	r18,zero,81120a50 <__divsf3+0x278>
811208f0:	04000204 	movi	r16,8
811208f4:	05c00084 	movi	r23,2
811208f8:	003fd306 	br	81120848 <__reset+0xfb100848>
811208fc:	0023883a 	mov	r17,zero
81120900:	e02d883a 	mov	r22,fp
81120904:	282f883a 	mov	r23,r5
81120908:	00800084 	movi	r2,2
8112090c:	b8808f1e 	bne	r23,r2,81120b4c <__divsf3+0x374>
81120910:	b005883a 	mov	r2,r22
81120914:	11c0004c 	andi	r7,r2,1
81120918:	013fffc4 	movi	r4,-1
8112091c:	000d883a 	mov	r6,zero
81120920:	21003fcc 	andi	r4,r4,255
81120924:	200895fa 	slli	r4,r4,23
81120928:	38803fcc 	andi	r2,r7,255
8112092c:	00c02034 	movhi	r3,128
81120930:	100497fa 	slli	r2,r2,31
81120934:	18ffffc4 	addi	r3,r3,-1
81120938:	30c6703a 	and	r3,r6,r3
8112093c:	1906b03a 	or	r3,r3,r4
81120940:	1884b03a 	or	r2,r3,r2
81120944:	dfc00a17 	ldw	ra,40(sp)
81120948:	df000917 	ldw	fp,36(sp)
8112094c:	ddc00817 	ldw	r23,32(sp)
81120950:	dd800717 	ldw	r22,28(sp)
81120954:	dd400617 	ldw	r21,24(sp)
81120958:	dd000517 	ldw	r20,20(sp)
8112095c:	dcc00417 	ldw	r19,16(sp)
81120960:	dc800317 	ldw	r18,12(sp)
81120964:	dc400217 	ldw	r17,8(sp)
81120968:	dc000117 	ldw	r16,4(sp)
8112096c:	dec00b04 	addi	sp,sp,44
81120970:	f800283a 	ret
81120974:	90002b1e 	bne	r18,zero,81120a24 <__divsf3+0x24c>
81120978:	04000104 	movi	r16,4
8112097c:	05c00044 	movi	r23,1
81120980:	003fb106 	br	81120848 <__reset+0xfb100848>
81120984:	8800251e 	bne	r17,zero,81120a1c <__divsf3+0x244>
81120988:	01400084 	movi	r5,2
8112098c:	00000206 	br	81120998 <__divsf3+0x1c0>
81120990:	88001a1e 	bne	r17,zero,811209fc <__divsf3+0x224>
81120994:	01400044 	movi	r5,1
81120998:	8160b03a 	or	r16,r16,r5
8112099c:	802090ba 	slli	r16,r16,2
811209a0:	00e044b4 	movhi	r3,33042
811209a4:	18c26f04 	addi	r3,r3,2492
811209a8:	80e1883a 	add	r16,r16,r3
811209ac:	80c00017 	ldw	r3,0(r16)
811209b0:	9d44f03a 	xor	r2,r19,r21
811209b4:	a18dc83a 	sub	r6,r20,r6
811209b8:	1800683a 	jmp	r3
811209bc:	81120914 	ori	r4,r16,18468
811209c0:	81120914 	ori	r4,r16,18468
811209c4:	81120b60 	cmpeqi	r4,r16,18477
811209c8:	811208fc 	xorhi	r4,r16,18467
811209cc:	81120b60 	cmpeqi	r4,r16,18477
811209d0:	81120a5c 	xori	r4,r16,18473
811209d4:	81120b60 	cmpeqi	r4,r16,18477
811209d8:	811208fc 	xorhi	r4,r16,18467
811209dc:	81120914 	ori	r4,r16,18468
811209e0:	81120914 	ori	r4,r16,18468
811209e4:	81120a5c 	xori	r4,r16,18473
811209e8:	811208fc 	xorhi	r4,r16,18467
811209ec:	81120b70 	cmpltui	r4,r16,18477
811209f0:	81120b70 	cmpltui	r4,r16,18477
811209f4:	81120b70 	cmpltui	r4,r16,18477
811209f8:	81120b88 	cmpgei	r4,r16,18478
811209fc:	8809883a 	mov	r4,r17
81120a00:	112276c0 	call	8112276c <__clzsi2>
81120a04:	10fffec4 	addi	r3,r2,-5
81120a08:	10801d84 	addi	r2,r2,118
81120a0c:	88e2983a 	sll	r17,r17,r3
81120a10:	008dc83a 	sub	r6,zero,r2
81120a14:	000b883a 	mov	r5,zero
81120a18:	003f9906 	br	81120880 <__reset+0xfb100880>
81120a1c:	014000c4 	movi	r5,3
81120a20:	003f9706 	br	81120880 <__reset+0xfb100880>
81120a24:	9009883a 	mov	r4,r18
81120a28:	d9400015 	stw	r5,0(sp)
81120a2c:	112276c0 	call	8112276c <__clzsi2>
81120a30:	10fffec4 	addi	r3,r2,-5
81120a34:	11801d84 	addi	r6,r2,118
81120a38:	90e4983a 	sll	r18,r18,r3
81120a3c:	01a9c83a 	sub	r20,zero,r6
81120a40:	0021883a 	mov	r16,zero
81120a44:	002f883a 	mov	r23,zero
81120a48:	d9400017 	ldw	r5,0(sp)
81120a4c:	003f7e06 	br	81120848 <__reset+0xfb100848>
81120a50:	04000304 	movi	r16,12
81120a54:	05c000c4 	movi	r23,3
81120a58:	003f7b06 	br	81120848 <__reset+0xfb100848>
81120a5c:	01802034 	movhi	r6,128
81120a60:	000f883a 	mov	r7,zero
81120a64:	31bfffc4 	addi	r6,r6,-1
81120a68:	013fffc4 	movi	r4,-1
81120a6c:	003fac06 	br	81120920 <__reset+0xfb100920>
81120a70:	01400044 	movi	r5,1
81120a74:	2909c83a 	sub	r4,r5,r4
81120a78:	00c006c4 	movi	r3,27
81120a7c:	19004b0e 	bge	r3,r4,81120bac <__divsf3+0x3d4>
81120a80:	114e703a 	and	r7,r2,r5
81120a84:	0009883a 	mov	r4,zero
81120a88:	000d883a 	mov	r6,zero
81120a8c:	003fa406 	br	81120920 <__reset+0xfb100920>
81120a90:	9006917a 	slli	r3,r18,5
81120a94:	8822917a 	slli	r17,r17,5
81120a98:	1c40372e 	bgeu	r3,r17,81120b78 <__divsf3+0x3a0>
81120a9c:	31bfffc4 	addi	r6,r6,-1
81120aa0:	010006c4 	movi	r4,27
81120aa4:	000b883a 	mov	r5,zero
81120aa8:	180f883a 	mov	r7,r3
81120aac:	294b883a 	add	r5,r5,r5
81120ab0:	18c7883a 	add	r3,r3,r3
81120ab4:	38000116 	blt	r7,zero,81120abc <__divsf3+0x2e4>
81120ab8:	1c400236 	bltu	r3,r17,81120ac4 <__divsf3+0x2ec>
81120abc:	1c47c83a 	sub	r3,r3,r17
81120ac0:	29400054 	ori	r5,r5,1
81120ac4:	213fffc4 	addi	r4,r4,-1
81120ac8:	203ff71e 	bne	r4,zero,81120aa8 <__reset+0xfb100aa8>
81120acc:	1806c03a 	cmpne	r3,r3,zero
81120ad0:	1962b03a 	or	r17,r3,r5
81120ad4:	31001fc4 	addi	r4,r6,127
81120ad8:	013fe50e 	bge	zero,r4,81120a70 <__reset+0xfb100a70>
81120adc:	88c001cc 	andi	r3,r17,7
81120ae0:	18000426 	beq	r3,zero,81120af4 <__divsf3+0x31c>
81120ae4:	88c003cc 	andi	r3,r17,15
81120ae8:	01400104 	movi	r5,4
81120aec:	19400126 	beq	r3,r5,81120af4 <__divsf3+0x31c>
81120af0:	8963883a 	add	r17,r17,r5
81120af4:	88c2002c 	andhi	r3,r17,2048
81120af8:	18000426 	beq	r3,zero,81120b0c <__divsf3+0x334>
81120afc:	00fe0034 	movhi	r3,63488
81120b00:	18ffffc4 	addi	r3,r3,-1
81120b04:	31002004 	addi	r4,r6,128
81120b08:	88e2703a 	and	r17,r17,r3
81120b0c:	00c03f84 	movi	r3,254
81120b10:	193f8016 	blt	r3,r4,81120914 <__reset+0xfb100914>
81120b14:	880c91ba 	slli	r6,r17,6
81120b18:	11c0004c 	andi	r7,r2,1
81120b1c:	300cd27a 	srli	r6,r6,9
81120b20:	003f7f06 	br	81120920 <__reset+0xfb100920>
81120b24:	9080102c 	andhi	r2,r18,64
81120b28:	10000226 	beq	r2,zero,81120b34 <__divsf3+0x35c>
81120b2c:	8880102c 	andhi	r2,r17,64
81120b30:	10001826 	beq	r2,zero,81120b94 <__divsf3+0x3bc>
81120b34:	00802034 	movhi	r2,128
81120b38:	91801034 	orhi	r6,r18,64
81120b3c:	10bfffc4 	addi	r2,r2,-1
81120b40:	980f883a 	mov	r7,r19
81120b44:	308c703a 	and	r6,r6,r2
81120b48:	003fc706 	br	81120a68 <__reset+0xfb100a68>
81120b4c:	008000c4 	movi	r2,3
81120b50:	b8802d26 	beq	r23,r2,81120c08 <__divsf3+0x430>
81120b54:	00c00044 	movi	r3,1
81120b58:	b005883a 	mov	r2,r22
81120b5c:	b8ffdd1e 	bne	r23,r3,81120ad4 <__reset+0xfb100ad4>
81120b60:	11c0004c 	andi	r7,r2,1
81120b64:	0009883a 	mov	r4,zero
81120b68:	000d883a 	mov	r6,zero
81120b6c:	003f6c06 	br	81120920 <__reset+0xfb100920>
81120b70:	9023883a 	mov	r17,r18
81120b74:	003f6406 	br	81120908 <__reset+0xfb100908>
81120b78:	1c47c83a 	sub	r3,r3,r17
81120b7c:	01000684 	movi	r4,26
81120b80:	01400044 	movi	r5,1
81120b84:	003fc806 	br	81120aa8 <__reset+0xfb100aa8>
81120b88:	9080102c 	andhi	r2,r18,64
81120b8c:	103fe926 	beq	r2,zero,81120b34 <__reset+0xfb100b34>
81120b90:	0023883a 	mov	r17,zero
81120b94:	00802034 	movhi	r2,128
81120b98:	89801034 	orhi	r6,r17,64
81120b9c:	10bfffc4 	addi	r2,r2,-1
81120ba0:	a80f883a 	mov	r7,r21
81120ba4:	308c703a 	and	r6,r6,r2
81120ba8:	003faf06 	br	81120a68 <__reset+0xfb100a68>
81120bac:	01c00804 	movi	r7,32
81120bb0:	390fc83a 	sub	r7,r7,r4
81120bb4:	89ce983a 	sll	r7,r17,r7
81120bb8:	890ad83a 	srl	r5,r17,r4
81120bbc:	380ec03a 	cmpne	r7,r7,zero
81120bc0:	29cab03a 	or	r5,r5,r7
81120bc4:	28c001cc 	andi	r3,r5,7
81120bc8:	18000426 	beq	r3,zero,81120bdc <__divsf3+0x404>
81120bcc:	28c003cc 	andi	r3,r5,15
81120bd0:	01000104 	movi	r4,4
81120bd4:	19000126 	beq	r3,r4,81120bdc <__divsf3+0x404>
81120bd8:	290b883a 	add	r5,r5,r4
81120bdc:	28c1002c 	andhi	r3,r5,1024
81120be0:	18000426 	beq	r3,zero,81120bf4 <__divsf3+0x41c>
81120be4:	11c0004c 	andi	r7,r2,1
81120be8:	01000044 	movi	r4,1
81120bec:	000d883a 	mov	r6,zero
81120bf0:	003f4b06 	br	81120920 <__reset+0xfb100920>
81120bf4:	280a91ba 	slli	r5,r5,6
81120bf8:	11c0004c 	andi	r7,r2,1
81120bfc:	0009883a 	mov	r4,zero
81120c00:	280cd27a 	srli	r6,r5,9
81120c04:	003f4606 	br	81120920 <__reset+0xfb100920>
81120c08:	00802034 	movhi	r2,128
81120c0c:	89801034 	orhi	r6,r17,64
81120c10:	10bfffc4 	addi	r2,r2,-1
81120c14:	b00f883a 	mov	r7,r22
81120c18:	308c703a 	and	r6,r6,r2
81120c1c:	003f9206 	br	81120a68 <__reset+0xfb100a68>

81120c20 <__mulsf3>:
81120c20:	defff504 	addi	sp,sp,-44
81120c24:	de00012e 	bgeu	sp,et,81120c2c <__mulsf3+0xc>
81120c28:	003b68fa 	trap	3
81120c2c:	dc000115 	stw	r16,4(sp)
81120c30:	2020d5fa 	srli	r16,r4,23
81120c34:	dd400615 	stw	r21,24(sp)
81120c38:	202ad7fa 	srli	r21,r4,31
81120c3c:	dc800315 	stw	r18,12(sp)
81120c40:	04802034 	movhi	r18,128
81120c44:	df000915 	stw	fp,36(sp)
81120c48:	dd000515 	stw	r20,20(sp)
81120c4c:	94bfffc4 	addi	r18,r18,-1
81120c50:	dfc00a15 	stw	ra,40(sp)
81120c54:	ddc00815 	stw	r23,32(sp)
81120c58:	dd800715 	stw	r22,28(sp)
81120c5c:	dcc00415 	stw	r19,16(sp)
81120c60:	dc400215 	stw	r17,8(sp)
81120c64:	84003fcc 	andi	r16,r16,255
81120c68:	9124703a 	and	r18,r18,r4
81120c6c:	a829883a 	mov	r20,r21
81120c70:	af003fcc 	andi	fp,r21,255
81120c74:	80005426 	beq	r16,zero,81120dc8 <__mulsf3+0x1a8>
81120c78:	00803fc4 	movi	r2,255
81120c7c:	80802f26 	beq	r16,r2,81120d3c <__mulsf3+0x11c>
81120c80:	91002034 	orhi	r4,r18,128
81120c84:	202490fa 	slli	r18,r4,3
81120c88:	843fe044 	addi	r16,r16,-127
81120c8c:	0023883a 	mov	r17,zero
81120c90:	002f883a 	mov	r23,zero
81120c94:	2804d5fa 	srli	r2,r5,23
81120c98:	282cd7fa 	srli	r22,r5,31
81120c9c:	01002034 	movhi	r4,128
81120ca0:	213fffc4 	addi	r4,r4,-1
81120ca4:	10803fcc 	andi	r2,r2,255
81120ca8:	2166703a 	and	r19,r4,r5
81120cac:	b1803fcc 	andi	r6,r22,255
81120cb0:	10004c26 	beq	r2,zero,81120de4 <__mulsf3+0x1c4>
81120cb4:	00c03fc4 	movi	r3,255
81120cb8:	10c04726 	beq	r2,r3,81120dd8 <__mulsf3+0x1b8>
81120cbc:	99002034 	orhi	r4,r19,128
81120cc0:	202690fa 	slli	r19,r4,3
81120cc4:	10bfe044 	addi	r2,r2,-127
81120cc8:	0007883a 	mov	r3,zero
81120ccc:	80a1883a 	add	r16,r16,r2
81120cd0:	010003c4 	movi	r4,15
81120cd4:	1c44b03a 	or	r2,r3,r17
81120cd8:	b56af03a 	xor	r21,r22,r21
81120cdc:	81c00044 	addi	r7,r16,1
81120ce0:	20806b36 	bltu	r4,r2,81120e90 <__mulsf3+0x270>
81120ce4:	100490ba 	slli	r2,r2,2
81120ce8:	012044b4 	movhi	r4,33042
81120cec:	21033f04 	addi	r4,r4,3324
81120cf0:	1105883a 	add	r2,r2,r4
81120cf4:	10800017 	ldw	r2,0(r2)
81120cf8:	1000683a 	jmp	r2
81120cfc:	81120e90 	cmplti	r4,r16,18490
81120d00:	81120d50 	cmplti	r4,r16,18485
81120d04:	81120d50 	cmplti	r4,r16,18485
81120d08:	81120d4c 	andi	r4,r16,18485
81120d0c:	81120e74 	orhi	r4,r16,18489
81120d10:	81120e74 	orhi	r4,r16,18489
81120d14:	81120e60 	cmpeqi	r4,r16,18489
81120d18:	81120d4c 	andi	r4,r16,18485
81120d1c:	81120e74 	orhi	r4,r16,18489
81120d20:	81120e60 	cmpeqi	r4,r16,18489
81120d24:	81120e74 	orhi	r4,r16,18489
81120d28:	81120d4c 	andi	r4,r16,18485
81120d2c:	81120e80 	call	881120e8 <__reset+0x20f20e8>
81120d30:	81120e80 	call	881120e8 <__reset+0x20f20e8>
81120d34:	81120e80 	call	881120e8 <__reset+0x20f20e8>
81120d38:	81120f5c 	xori	r4,r16,18493
81120d3c:	90003b1e 	bne	r18,zero,81120e2c <__mulsf3+0x20c>
81120d40:	04400204 	movi	r17,8
81120d44:	05c00084 	movi	r23,2
81120d48:	003fd206 	br	81120c94 <__reset+0xfb100c94>
81120d4c:	302b883a 	mov	r21,r6
81120d50:	00800084 	movi	r2,2
81120d54:	18802626 	beq	r3,r2,81120df0 <__mulsf3+0x1d0>
81120d58:	008000c4 	movi	r2,3
81120d5c:	1880ab26 	beq	r3,r2,8112100c <__mulsf3+0x3ec>
81120d60:	00800044 	movi	r2,1
81120d64:	1880a21e 	bne	r3,r2,81120ff0 <__mulsf3+0x3d0>
81120d68:	a829883a 	mov	r20,r21
81120d6c:	0007883a 	mov	r3,zero
81120d70:	0009883a 	mov	r4,zero
81120d74:	18803fcc 	andi	r2,r3,255
81120d78:	100695fa 	slli	r3,r2,23
81120d7c:	a0803fcc 	andi	r2,r20,255
81120d80:	100a97fa 	slli	r5,r2,31
81120d84:	00802034 	movhi	r2,128
81120d88:	10bfffc4 	addi	r2,r2,-1
81120d8c:	2084703a 	and	r2,r4,r2
81120d90:	10c4b03a 	or	r2,r2,r3
81120d94:	1144b03a 	or	r2,r2,r5
81120d98:	dfc00a17 	ldw	ra,40(sp)
81120d9c:	df000917 	ldw	fp,36(sp)
81120da0:	ddc00817 	ldw	r23,32(sp)
81120da4:	dd800717 	ldw	r22,28(sp)
81120da8:	dd400617 	ldw	r21,24(sp)
81120dac:	dd000517 	ldw	r20,20(sp)
81120db0:	dcc00417 	ldw	r19,16(sp)
81120db4:	dc800317 	ldw	r18,12(sp)
81120db8:	dc400217 	ldw	r17,8(sp)
81120dbc:	dc000117 	ldw	r16,4(sp)
81120dc0:	dec00b04 	addi	sp,sp,44
81120dc4:	f800283a 	ret
81120dc8:	90000d1e 	bne	r18,zero,81120e00 <__mulsf3+0x1e0>
81120dcc:	04400104 	movi	r17,4
81120dd0:	05c00044 	movi	r23,1
81120dd4:	003faf06 	br	81120c94 <__reset+0xfb100c94>
81120dd8:	9806c03a 	cmpne	r3,r19,zero
81120ddc:	18c00084 	addi	r3,r3,2
81120de0:	003fba06 	br	81120ccc <__reset+0xfb100ccc>
81120de4:	9800141e 	bne	r19,zero,81120e38 <__mulsf3+0x218>
81120de8:	00c00044 	movi	r3,1
81120dec:	003fb706 	br	81120ccc <__reset+0xfb100ccc>
81120df0:	a829883a 	mov	r20,r21
81120df4:	00ffffc4 	movi	r3,-1
81120df8:	0009883a 	mov	r4,zero
81120dfc:	003fdd06 	br	81120d74 <__reset+0xfb100d74>
81120e00:	9009883a 	mov	r4,r18
81120e04:	d9400015 	stw	r5,0(sp)
81120e08:	112276c0 	call	8112276c <__clzsi2>
81120e0c:	10fffec4 	addi	r3,r2,-5
81120e10:	10801d84 	addi	r2,r2,118
81120e14:	90e4983a 	sll	r18,r18,r3
81120e18:	00a1c83a 	sub	r16,zero,r2
81120e1c:	0023883a 	mov	r17,zero
81120e20:	002f883a 	mov	r23,zero
81120e24:	d9400017 	ldw	r5,0(sp)
81120e28:	003f9a06 	br	81120c94 <__reset+0xfb100c94>
81120e2c:	04400304 	movi	r17,12
81120e30:	05c000c4 	movi	r23,3
81120e34:	003f9706 	br	81120c94 <__reset+0xfb100c94>
81120e38:	9809883a 	mov	r4,r19
81120e3c:	d9800015 	stw	r6,0(sp)
81120e40:	112276c0 	call	8112276c <__clzsi2>
81120e44:	10fffec4 	addi	r3,r2,-5
81120e48:	10801d84 	addi	r2,r2,118
81120e4c:	98e6983a 	sll	r19,r19,r3
81120e50:	0085c83a 	sub	r2,zero,r2
81120e54:	0007883a 	mov	r3,zero
81120e58:	d9800017 	ldw	r6,0(sp)
81120e5c:	003f9b06 	br	81120ccc <__reset+0xfb100ccc>
81120e60:	01002034 	movhi	r4,128
81120e64:	0029883a 	mov	r20,zero
81120e68:	213fffc4 	addi	r4,r4,-1
81120e6c:	00ffffc4 	movi	r3,-1
81120e70:	003fc006 	br	81120d74 <__reset+0xfb100d74>
81120e74:	9027883a 	mov	r19,r18
81120e78:	b807883a 	mov	r3,r23
81120e7c:	003fb406 	br	81120d50 <__reset+0xfb100d50>
81120e80:	9027883a 	mov	r19,r18
81120e84:	e02b883a 	mov	r21,fp
81120e88:	b807883a 	mov	r3,r23
81120e8c:	003fb006 	br	81120d50 <__reset+0xfb100d50>
81120e90:	9004d43a 	srli	r2,r18,16
81120e94:	9810d43a 	srli	r8,r19,16
81120e98:	94bfffcc 	andi	r18,r18,65535
81120e9c:	993fffcc 	andi	r4,r19,65535
81120ea0:	910d383a 	mul	r6,r18,r4
81120ea4:	20a7383a 	mul	r19,r4,r2
81120ea8:	9225383a 	mul	r18,r18,r8
81120eac:	3006d43a 	srli	r3,r6,16
81120eb0:	1211383a 	mul	r8,r2,r8
81120eb4:	94e5883a 	add	r18,r18,r19
81120eb8:	1c87883a 	add	r3,r3,r18
81120ebc:	1cc0022e 	bgeu	r3,r19,81120ec8 <__mulsf3+0x2a8>
81120ec0:	00800074 	movhi	r2,1
81120ec4:	4091883a 	add	r8,r8,r2
81120ec8:	1804943a 	slli	r2,r3,16
81120ecc:	31bfffcc 	andi	r6,r6,65535
81120ed0:	1806d43a 	srli	r3,r3,16
81120ed4:	1185883a 	add	r2,r2,r6
81120ed8:	102691ba 	slli	r19,r2,6
81120edc:	1a07883a 	add	r3,r3,r8
81120ee0:	1004d6ba 	srli	r2,r2,26
81120ee4:	180891ba 	slli	r4,r3,6
81120ee8:	9826c03a 	cmpne	r19,r19,zero
81120eec:	9884b03a 	or	r2,r19,r2
81120ef0:	1126b03a 	or	r19,r2,r4
81120ef4:	9882002c 	andhi	r2,r19,2048
81120ef8:	10000426 	beq	r2,zero,81120f0c <__mulsf3+0x2ec>
81120efc:	9804d07a 	srli	r2,r19,1
81120f00:	9900004c 	andi	r4,r19,1
81120f04:	3821883a 	mov	r16,r7
81120f08:	1126b03a 	or	r19,r2,r4
81120f0c:	80c01fc4 	addi	r3,r16,127
81120f10:	00c0210e 	bge	zero,r3,81120f98 <__mulsf3+0x378>
81120f14:	988001cc 	andi	r2,r19,7
81120f18:	10000426 	beq	r2,zero,81120f2c <__mulsf3+0x30c>
81120f1c:	988003cc 	andi	r2,r19,15
81120f20:	01000104 	movi	r4,4
81120f24:	11000126 	beq	r2,r4,81120f2c <__mulsf3+0x30c>
81120f28:	9927883a 	add	r19,r19,r4
81120f2c:	9882002c 	andhi	r2,r19,2048
81120f30:	10000426 	beq	r2,zero,81120f44 <__mulsf3+0x324>
81120f34:	00be0034 	movhi	r2,63488
81120f38:	10bfffc4 	addi	r2,r2,-1
81120f3c:	80c02004 	addi	r3,r16,128
81120f40:	98a6703a 	and	r19,r19,r2
81120f44:	00803f84 	movi	r2,254
81120f48:	10ffa916 	blt	r2,r3,81120df0 <__reset+0xfb100df0>
81120f4c:	980891ba 	slli	r4,r19,6
81120f50:	a829883a 	mov	r20,r21
81120f54:	2008d27a 	srli	r4,r4,9
81120f58:	003f8606 	br	81120d74 <__reset+0xfb100d74>
81120f5c:	9080102c 	andhi	r2,r18,64
81120f60:	10000826 	beq	r2,zero,81120f84 <__mulsf3+0x364>
81120f64:	9880102c 	andhi	r2,r19,64
81120f68:	1000061e 	bne	r2,zero,81120f84 <__mulsf3+0x364>
81120f6c:	00802034 	movhi	r2,128
81120f70:	99001034 	orhi	r4,r19,64
81120f74:	10bfffc4 	addi	r2,r2,-1
81120f78:	b029883a 	mov	r20,r22
81120f7c:	2088703a 	and	r4,r4,r2
81120f80:	003fba06 	br	81120e6c <__reset+0xfb100e6c>
81120f84:	00802034 	movhi	r2,128
81120f88:	91001034 	orhi	r4,r18,64
81120f8c:	10bfffc4 	addi	r2,r2,-1
81120f90:	2088703a 	and	r4,r4,r2
81120f94:	003fb506 	br	81120e6c <__reset+0xfb100e6c>
81120f98:	00800044 	movi	r2,1
81120f9c:	10c7c83a 	sub	r3,r2,r3
81120fa0:	008006c4 	movi	r2,27
81120fa4:	10ff7016 	blt	r2,r3,81120d68 <__reset+0xfb100d68>
81120fa8:	00800804 	movi	r2,32
81120fac:	10c5c83a 	sub	r2,r2,r3
81120fb0:	9884983a 	sll	r2,r19,r2
81120fb4:	98c6d83a 	srl	r3,r19,r3
81120fb8:	1004c03a 	cmpne	r2,r2,zero
81120fbc:	1884b03a 	or	r2,r3,r2
81120fc0:	10c001cc 	andi	r3,r2,7
81120fc4:	18000426 	beq	r3,zero,81120fd8 <__mulsf3+0x3b8>
81120fc8:	10c003cc 	andi	r3,r2,15
81120fcc:	01000104 	movi	r4,4
81120fd0:	19000126 	beq	r3,r4,81120fd8 <__mulsf3+0x3b8>
81120fd4:	1105883a 	add	r2,r2,r4
81120fd8:	10c1002c 	andhi	r3,r2,1024
81120fdc:	18000626 	beq	r3,zero,81120ff8 <__mulsf3+0x3d8>
81120fe0:	a829883a 	mov	r20,r21
81120fe4:	00c00044 	movi	r3,1
81120fe8:	0009883a 	mov	r4,zero
81120fec:	003f6106 	br	81120d74 <__reset+0xfb100d74>
81120ff0:	3821883a 	mov	r16,r7
81120ff4:	003fc506 	br	81120f0c <__reset+0xfb100f0c>
81120ff8:	100491ba 	slli	r2,r2,6
81120ffc:	a829883a 	mov	r20,r21
81121000:	0007883a 	mov	r3,zero
81121004:	1008d27a 	srli	r4,r2,9
81121008:	003f5a06 	br	81120d74 <__reset+0xfb100d74>
8112100c:	00802034 	movhi	r2,128
81121010:	99001034 	orhi	r4,r19,64
81121014:	10bfffc4 	addi	r2,r2,-1
81121018:	a829883a 	mov	r20,r21
8112101c:	2088703a 	and	r4,r4,r2
81121020:	003f9206 	br	81120e6c <__reset+0xfb100e6c>

81121024 <__floatsisf>:
81121024:	defffd04 	addi	sp,sp,-12
81121028:	de00012e 	bgeu	sp,et,81121030 <__floatsisf+0xc>
8112102c:	003b68fa 	trap	3
81121030:	dfc00215 	stw	ra,8(sp)
81121034:	dc400115 	stw	r17,4(sp)
81121038:	dc000015 	stw	r16,0(sp)
8112103c:	20003526 	beq	r4,zero,81121114 <__floatsisf+0xf0>
81121040:	2021883a 	mov	r16,r4
81121044:	2022d7fa 	srli	r17,r4,31
81121048:	20003616 	blt	r4,zero,81121124 <__floatsisf+0x100>
8112104c:	8009883a 	mov	r4,r16
81121050:	112276c0 	call	8112276c <__clzsi2>
81121054:	00c02784 	movi	r3,158
81121058:	1887c83a 	sub	r3,r3,r2
8112105c:	01002584 	movi	r4,150
81121060:	20c01416 	blt	r4,r3,811210b4 <__floatsisf+0x90>
81121064:	20c9c83a 	sub	r4,r4,r3
81121068:	8120983a 	sll	r16,r16,r4
8112106c:	00802034 	movhi	r2,128
81121070:	10bfffc4 	addi	r2,r2,-1
81121074:	8809883a 	mov	r4,r17
81121078:	80a0703a 	and	r16,r16,r2
8112107c:	18803fcc 	andi	r2,r3,255
81121080:	100695fa 	slli	r3,r2,23
81121084:	20803fcc 	andi	r2,r4,255
81121088:	100897fa 	slli	r4,r2,31
8112108c:	00802034 	movhi	r2,128
81121090:	10bfffc4 	addi	r2,r2,-1
81121094:	8084703a 	and	r2,r16,r2
81121098:	10c4b03a 	or	r2,r2,r3
8112109c:	1104b03a 	or	r2,r2,r4
811210a0:	dfc00217 	ldw	ra,8(sp)
811210a4:	dc400117 	ldw	r17,4(sp)
811210a8:	dc000017 	ldw	r16,0(sp)
811210ac:	dec00304 	addi	sp,sp,12
811210b0:	f800283a 	ret
811210b4:	01002644 	movi	r4,153
811210b8:	20c01c16 	blt	r4,r3,8112112c <__floatsisf+0x108>
811210bc:	20c9c83a 	sub	r4,r4,r3
811210c0:	8120983a 	sll	r16,r16,r4
811210c4:	013f0034 	movhi	r4,64512
811210c8:	213fffc4 	addi	r4,r4,-1
811210cc:	814001cc 	andi	r5,r16,7
811210d0:	8108703a 	and	r4,r16,r4
811210d4:	28000426 	beq	r5,zero,811210e8 <__floatsisf+0xc4>
811210d8:	840003cc 	andi	r16,r16,15
811210dc:	01400104 	movi	r5,4
811210e0:	81400126 	beq	r16,r5,811210e8 <__floatsisf+0xc4>
811210e4:	2149883a 	add	r4,r4,r5
811210e8:	2141002c 	andhi	r5,r4,1024
811210ec:	28000526 	beq	r5,zero,81121104 <__floatsisf+0xe0>
811210f0:	00c027c4 	movi	r3,159
811210f4:	1887c83a 	sub	r3,r3,r2
811210f8:	00bf0034 	movhi	r2,64512
811210fc:	10bfffc4 	addi	r2,r2,-1
81121100:	2088703a 	and	r4,r4,r2
81121104:	202091ba 	slli	r16,r4,6
81121108:	8809883a 	mov	r4,r17
8112110c:	8020d27a 	srli	r16,r16,9
81121110:	003fda06 	br	8112107c <__reset+0xfb10107c>
81121114:	0009883a 	mov	r4,zero
81121118:	0007883a 	mov	r3,zero
8112111c:	0021883a 	mov	r16,zero
81121120:	003fd606 	br	8112107c <__reset+0xfb10107c>
81121124:	0121c83a 	sub	r16,zero,r4
81121128:	003fc806 	br	8112104c <__reset+0xfb10104c>
8112112c:	01002e44 	movi	r4,185
81121130:	20c9c83a 	sub	r4,r4,r3
81121134:	01400144 	movi	r5,5
81121138:	8108983a 	sll	r4,r16,r4
8112113c:	288bc83a 	sub	r5,r5,r2
81121140:	8160d83a 	srl	r16,r16,r5
81121144:	2008c03a 	cmpne	r4,r4,zero
81121148:	8120b03a 	or	r16,r16,r4
8112114c:	003fdd06 	br	811210c4 <__reset+0xfb1010c4>

81121150 <__floatunsisf>:
81121150:	defffe04 	addi	sp,sp,-8
81121154:	de00012e 	bgeu	sp,et,8112115c <__floatunsisf+0xc>
81121158:	003b68fa 	trap	3
8112115c:	dfc00115 	stw	ra,4(sp)
81121160:	dc000015 	stw	r16,0(sp)
81121164:	20002c26 	beq	r4,zero,81121218 <__floatunsisf+0xc8>
81121168:	2021883a 	mov	r16,r4
8112116c:	112276c0 	call	8112276c <__clzsi2>
81121170:	00c02784 	movi	r3,158
81121174:	1887c83a 	sub	r3,r3,r2
81121178:	01002584 	movi	r4,150
8112117c:	20c00f16 	blt	r4,r3,811211bc <__floatunsisf+0x6c>
81121180:	20c9c83a 	sub	r4,r4,r3
81121184:	8108983a 	sll	r4,r16,r4
81121188:	00802034 	movhi	r2,128
8112118c:	10bfffc4 	addi	r2,r2,-1
81121190:	2088703a 	and	r4,r4,r2
81121194:	18803fcc 	andi	r2,r3,255
81121198:	100695fa 	slli	r3,r2,23
8112119c:	00802034 	movhi	r2,128
811211a0:	10bfffc4 	addi	r2,r2,-1
811211a4:	2084703a 	and	r2,r4,r2
811211a8:	10c4b03a 	or	r2,r2,r3
811211ac:	dfc00117 	ldw	ra,4(sp)
811211b0:	dc000017 	ldw	r16,0(sp)
811211b4:	dec00204 	addi	sp,sp,8
811211b8:	f800283a 	ret
811211bc:	01002644 	movi	r4,153
811211c0:	20c01816 	blt	r4,r3,81121224 <__floatunsisf+0xd4>
811211c4:	20c9c83a 	sub	r4,r4,r3
811211c8:	8108983a 	sll	r4,r16,r4
811211cc:	017f0034 	movhi	r5,64512
811211d0:	297fffc4 	addi	r5,r5,-1
811211d4:	218001cc 	andi	r6,r4,7
811211d8:	214a703a 	and	r5,r4,r5
811211dc:	30000426 	beq	r6,zero,811211f0 <__floatunsisf+0xa0>
811211e0:	210003cc 	andi	r4,r4,15
811211e4:	01800104 	movi	r6,4
811211e8:	21800126 	beq	r4,r6,811211f0 <__floatunsisf+0xa0>
811211ec:	298b883a 	add	r5,r5,r6
811211f0:	2901002c 	andhi	r4,r5,1024
811211f4:	20000526 	beq	r4,zero,8112120c <__floatunsisf+0xbc>
811211f8:	00c027c4 	movi	r3,159
811211fc:	1887c83a 	sub	r3,r3,r2
81121200:	00bf0034 	movhi	r2,64512
81121204:	10bfffc4 	addi	r2,r2,-1
81121208:	288a703a 	and	r5,r5,r2
8112120c:	280891ba 	slli	r4,r5,6
81121210:	2008d27a 	srli	r4,r4,9
81121214:	003fdf06 	br	81121194 <__reset+0xfb101194>
81121218:	0007883a 	mov	r3,zero
8112121c:	0009883a 	mov	r4,zero
81121220:	003fdc06 	br	81121194 <__reset+0xfb101194>
81121224:	01402e44 	movi	r5,185
81121228:	28cbc83a 	sub	r5,r5,r3
8112122c:	01000144 	movi	r4,5
81121230:	2089c83a 	sub	r4,r4,r2
81121234:	814a983a 	sll	r5,r16,r5
81121238:	8108d83a 	srl	r4,r16,r4
8112123c:	2820c03a 	cmpne	r16,r5,zero
81121240:	2408b03a 	or	r4,r4,r16
81121244:	003fe106 	br	811211cc <__reset+0xfb1011cc>

81121248 <__gedf2>:
81121248:	2804d53a 	srli	r2,r5,20
8112124c:	3806d53a 	srli	r3,r7,20
81121250:	02000434 	movhi	r8,16
81121254:	423fffc4 	addi	r8,r8,-1
81121258:	1081ffcc 	andi	r2,r2,2047
8112125c:	0241ffc4 	movi	r9,2047
81121260:	2a14703a 	and	r10,r5,r8
81121264:	18c1ffcc 	andi	r3,r3,2047
81121268:	3a10703a 	and	r8,r7,r8
8112126c:	280ad7fa 	srli	r5,r5,31
81121270:	380ed7fa 	srli	r7,r7,31
81121274:	12401d26 	beq	r2,r9,811212ec <__gedf2+0xa4>
81121278:	0241ffc4 	movi	r9,2047
8112127c:	1a401226 	beq	r3,r9,811212c8 <__gedf2+0x80>
81121280:	1000081e 	bne	r2,zero,811212a4 <__gedf2+0x5c>
81121284:	2296b03a 	or	r11,r4,r10
81121288:	5813003a 	cmpeq	r9,r11,zero
8112128c:	1800091e 	bne	r3,zero,811212b4 <__gedf2+0x6c>
81121290:	3218b03a 	or	r12,r6,r8
81121294:	6000071e 	bne	r12,zero,811212b4 <__gedf2+0x6c>
81121298:	0005883a 	mov	r2,zero
8112129c:	5800101e 	bne	r11,zero,811212e0 <__gedf2+0x98>
811212a0:	f800283a 	ret
811212a4:	18000c1e 	bne	r3,zero,811212d8 <__gedf2+0x90>
811212a8:	3212b03a 	or	r9,r6,r8
811212ac:	48000c26 	beq	r9,zero,811212e0 <__gedf2+0x98>
811212b0:	0013883a 	mov	r9,zero
811212b4:	39c03fcc 	andi	r7,r7,255
811212b8:	48000826 	beq	r9,zero,811212dc <__gedf2+0x94>
811212bc:	38000926 	beq	r7,zero,811212e4 <__gedf2+0x9c>
811212c0:	00800044 	movi	r2,1
811212c4:	f800283a 	ret
811212c8:	3212b03a 	or	r9,r6,r8
811212cc:	483fec26 	beq	r9,zero,81121280 <__reset+0xfb101280>
811212d0:	00bfff84 	movi	r2,-2
811212d4:	f800283a 	ret
811212d8:	39c03fcc 	andi	r7,r7,255
811212dc:	29c00626 	beq	r5,r7,811212f8 <__gedf2+0xb0>
811212e0:	283ff726 	beq	r5,zero,811212c0 <__reset+0xfb1012c0>
811212e4:	00bfffc4 	movi	r2,-1
811212e8:	f800283a 	ret
811212ec:	2292b03a 	or	r9,r4,r10
811212f0:	483fe126 	beq	r9,zero,81121278 <__reset+0xfb101278>
811212f4:	003ff606 	br	811212d0 <__reset+0xfb1012d0>
811212f8:	18bff916 	blt	r3,r2,811212e0 <__reset+0xfb1012e0>
811212fc:	10c00316 	blt	r2,r3,8112130c <__gedf2+0xc4>
81121300:	42bff736 	bltu	r8,r10,811212e0 <__reset+0xfb1012e0>
81121304:	52000326 	beq	r10,r8,81121314 <__gedf2+0xcc>
81121308:	5200042e 	bgeu	r10,r8,8112131c <__gedf2+0xd4>
8112130c:	283fec1e 	bne	r5,zero,811212c0 <__reset+0xfb1012c0>
81121310:	003ff406 	br	811212e4 <__reset+0xfb1012e4>
81121314:	313ff236 	bltu	r6,r4,811212e0 <__reset+0xfb1012e0>
81121318:	21bffc36 	bltu	r4,r6,8112130c <__reset+0xfb10130c>
8112131c:	0005883a 	mov	r2,zero
81121320:	f800283a 	ret

81121324 <__muldf3>:
81121324:	defff304 	addi	sp,sp,-52
81121328:	2804d53a 	srli	r2,r5,20
8112132c:	de00012e 	bgeu	sp,et,81121334 <__muldf3+0x10>
81121330:	003b68fa 	trap	3
81121334:	dd800915 	stw	r22,36(sp)
81121338:	282cd7fa 	srli	r22,r5,31
8112133c:	dc000315 	stw	r16,12(sp)
81121340:	04000434 	movhi	r16,16
81121344:	dd400815 	stw	r21,32(sp)
81121348:	dc800515 	stw	r18,20(sp)
8112134c:	843fffc4 	addi	r16,r16,-1
81121350:	dfc00c15 	stw	ra,48(sp)
81121354:	df000b15 	stw	fp,44(sp)
81121358:	ddc00a15 	stw	r23,40(sp)
8112135c:	dd000715 	stw	r20,28(sp)
81121360:	dcc00615 	stw	r19,24(sp)
81121364:	dc400415 	stw	r17,16(sp)
81121368:	1481ffcc 	andi	r18,r2,2047
8112136c:	2c20703a 	and	r16,r5,r16
81121370:	b02b883a 	mov	r21,r22
81121374:	b2403fcc 	andi	r9,r22,255
81121378:	90006026 	beq	r18,zero,811214fc <__muldf3+0x1d8>
8112137c:	0081ffc4 	movi	r2,2047
81121380:	2029883a 	mov	r20,r4
81121384:	90803626 	beq	r18,r2,81121460 <__muldf3+0x13c>
81121388:	80800434 	orhi	r2,r16,16
8112138c:	100490fa 	slli	r2,r2,3
81121390:	2020d77a 	srli	r16,r4,29
81121394:	202890fa 	slli	r20,r4,3
81121398:	94bf0044 	addi	r18,r18,-1023
8112139c:	80a0b03a 	or	r16,r16,r2
811213a0:	0027883a 	mov	r19,zero
811213a4:	0039883a 	mov	fp,zero
811213a8:	3804d53a 	srli	r2,r7,20
811213ac:	382ed7fa 	srli	r23,r7,31
811213b0:	04400434 	movhi	r17,16
811213b4:	8c7fffc4 	addi	r17,r17,-1
811213b8:	1081ffcc 	andi	r2,r2,2047
811213bc:	3011883a 	mov	r8,r6
811213c0:	3c62703a 	and	r17,r7,r17
811213c4:	ba803fcc 	andi	r10,r23,255
811213c8:	10006d26 	beq	r2,zero,81121580 <__muldf3+0x25c>
811213cc:	00c1ffc4 	movi	r3,2047
811213d0:	10c06526 	beq	r2,r3,81121568 <__muldf3+0x244>
811213d4:	88c00434 	orhi	r3,r17,16
811213d8:	180690fa 	slli	r3,r3,3
811213dc:	3022d77a 	srli	r17,r6,29
811213e0:	301090fa 	slli	r8,r6,3
811213e4:	10bf0044 	addi	r2,r2,-1023
811213e8:	88e2b03a 	or	r17,r17,r3
811213ec:	000b883a 	mov	r5,zero
811213f0:	9085883a 	add	r2,r18,r2
811213f4:	2cc8b03a 	or	r4,r5,r19
811213f8:	00c003c4 	movi	r3,15
811213fc:	bdacf03a 	xor	r22,r23,r22
81121400:	12c00044 	addi	r11,r2,1
81121404:	19009936 	bltu	r3,r4,8112166c <__muldf3+0x348>
81121408:	200890ba 	slli	r4,r4,2
8112140c:	00e044b4 	movhi	r3,33042
81121410:	18c50804 	addi	r3,r3,5152
81121414:	20c9883a 	add	r4,r4,r3
81121418:	20c00017 	ldw	r3,0(r4)
8112141c:	1800683a 	jmp	r3
81121420:	8112166c 	andhi	r4,r16,18521
81121424:	81121480 	call	88112148 <__reset+0x20f2148>
81121428:	81121480 	call	88112148 <__reset+0x20f2148>
8112142c:	8112147c 	xorhi	r4,r16,18513
81121430:	81121648 	cmpgei	r4,r16,18521
81121434:	81121648 	cmpgei	r4,r16,18521
81121438:	81121630 	cmpltui	r4,r16,18520
8112143c:	8112147c 	xorhi	r4,r16,18513
81121440:	81121648 	cmpgei	r4,r16,18521
81121444:	81121630 	cmpltui	r4,r16,18520
81121448:	81121648 	cmpgei	r4,r16,18521
8112144c:	8112147c 	xorhi	r4,r16,18513
81121450:	81121658 	cmpnei	r4,r16,18521
81121454:	81121658 	cmpnei	r4,r16,18521
81121458:	81121658 	cmpnei	r4,r16,18521
8112145c:	81121874 	orhi	r4,r16,18529
81121460:	2404b03a 	or	r2,r4,r16
81121464:	10006f1e 	bne	r2,zero,81121624 <__muldf3+0x300>
81121468:	04c00204 	movi	r19,8
8112146c:	0021883a 	mov	r16,zero
81121470:	0029883a 	mov	r20,zero
81121474:	07000084 	movi	fp,2
81121478:	003fcb06 	br	811213a8 <__reset+0xfb1013a8>
8112147c:	502d883a 	mov	r22,r10
81121480:	00800084 	movi	r2,2
81121484:	28805726 	beq	r5,r2,811215e4 <__muldf3+0x2c0>
81121488:	008000c4 	movi	r2,3
8112148c:	28816626 	beq	r5,r2,81121a28 <__muldf3+0x704>
81121490:	00800044 	movi	r2,1
81121494:	2881411e 	bne	r5,r2,8112199c <__muldf3+0x678>
81121498:	b02b883a 	mov	r21,r22
8112149c:	0005883a 	mov	r2,zero
811214a0:	000b883a 	mov	r5,zero
811214a4:	0029883a 	mov	r20,zero
811214a8:	1004953a 	slli	r2,r2,20
811214ac:	a8c03fcc 	andi	r3,r21,255
811214b0:	04400434 	movhi	r17,16
811214b4:	8c7fffc4 	addi	r17,r17,-1
811214b8:	180697fa 	slli	r3,r3,31
811214bc:	2c4a703a 	and	r5,r5,r17
811214c0:	288ab03a 	or	r5,r5,r2
811214c4:	28c6b03a 	or	r3,r5,r3
811214c8:	a005883a 	mov	r2,r20
811214cc:	dfc00c17 	ldw	ra,48(sp)
811214d0:	df000b17 	ldw	fp,44(sp)
811214d4:	ddc00a17 	ldw	r23,40(sp)
811214d8:	dd800917 	ldw	r22,36(sp)
811214dc:	dd400817 	ldw	r21,32(sp)
811214e0:	dd000717 	ldw	r20,28(sp)
811214e4:	dcc00617 	ldw	r19,24(sp)
811214e8:	dc800517 	ldw	r18,20(sp)
811214ec:	dc400417 	ldw	r17,16(sp)
811214f0:	dc000317 	ldw	r16,12(sp)
811214f4:	dec00d04 	addi	sp,sp,52
811214f8:	f800283a 	ret
811214fc:	2404b03a 	or	r2,r4,r16
81121500:	2027883a 	mov	r19,r4
81121504:	10004226 	beq	r2,zero,81121610 <__muldf3+0x2ec>
81121508:	8000fc26 	beq	r16,zero,811218fc <__muldf3+0x5d8>
8112150c:	8009883a 	mov	r4,r16
81121510:	d9800215 	stw	r6,8(sp)
81121514:	d9c00015 	stw	r7,0(sp)
81121518:	da400115 	stw	r9,4(sp)
8112151c:	112276c0 	call	8112276c <__clzsi2>
81121520:	d9800217 	ldw	r6,8(sp)
81121524:	d9c00017 	ldw	r7,0(sp)
81121528:	da400117 	ldw	r9,4(sp)
8112152c:	113ffd44 	addi	r4,r2,-11
81121530:	00c00704 	movi	r3,28
81121534:	1900ed16 	blt	r3,r4,811218ec <__muldf3+0x5c8>
81121538:	00c00744 	movi	r3,29
8112153c:	147ffe04 	addi	r17,r2,-8
81121540:	1907c83a 	sub	r3,r3,r4
81121544:	8460983a 	sll	r16,r16,r17
81121548:	98c6d83a 	srl	r3,r19,r3
8112154c:	9c68983a 	sll	r20,r19,r17
81121550:	1c20b03a 	or	r16,r3,r16
81121554:	1080fcc4 	addi	r2,r2,1011
81121558:	00a5c83a 	sub	r18,zero,r2
8112155c:	0027883a 	mov	r19,zero
81121560:	0039883a 	mov	fp,zero
81121564:	003f9006 	br	811213a8 <__reset+0xfb1013a8>
81121568:	3446b03a 	or	r3,r6,r17
8112156c:	1800261e 	bne	r3,zero,81121608 <__muldf3+0x2e4>
81121570:	0023883a 	mov	r17,zero
81121574:	0011883a 	mov	r8,zero
81121578:	01400084 	movi	r5,2
8112157c:	003f9c06 	br	811213f0 <__reset+0xfb1013f0>
81121580:	3446b03a 	or	r3,r6,r17
81121584:	18001c26 	beq	r3,zero,811215f8 <__muldf3+0x2d4>
81121588:	8800ce26 	beq	r17,zero,811218c4 <__muldf3+0x5a0>
8112158c:	8809883a 	mov	r4,r17
81121590:	d9800215 	stw	r6,8(sp)
81121594:	da400115 	stw	r9,4(sp)
81121598:	da800015 	stw	r10,0(sp)
8112159c:	112276c0 	call	8112276c <__clzsi2>
811215a0:	d9800217 	ldw	r6,8(sp)
811215a4:	da400117 	ldw	r9,4(sp)
811215a8:	da800017 	ldw	r10,0(sp)
811215ac:	113ffd44 	addi	r4,r2,-11
811215b0:	00c00704 	movi	r3,28
811215b4:	1900bf16 	blt	r3,r4,811218b4 <__muldf3+0x590>
811215b8:	00c00744 	movi	r3,29
811215bc:	123ffe04 	addi	r8,r2,-8
811215c0:	1907c83a 	sub	r3,r3,r4
811215c4:	8a22983a 	sll	r17,r17,r8
811215c8:	30c6d83a 	srl	r3,r6,r3
811215cc:	3210983a 	sll	r8,r6,r8
811215d0:	1c62b03a 	or	r17,r3,r17
811215d4:	1080fcc4 	addi	r2,r2,1011
811215d8:	0085c83a 	sub	r2,zero,r2
811215dc:	000b883a 	mov	r5,zero
811215e0:	003f8306 	br	811213f0 <__reset+0xfb1013f0>
811215e4:	b02b883a 	mov	r21,r22
811215e8:	0081ffc4 	movi	r2,2047
811215ec:	000b883a 	mov	r5,zero
811215f0:	0029883a 	mov	r20,zero
811215f4:	003fac06 	br	811214a8 <__reset+0xfb1014a8>
811215f8:	0023883a 	mov	r17,zero
811215fc:	0011883a 	mov	r8,zero
81121600:	01400044 	movi	r5,1
81121604:	003f7a06 	br	811213f0 <__reset+0xfb1013f0>
81121608:	014000c4 	movi	r5,3
8112160c:	003f7806 	br	811213f0 <__reset+0xfb1013f0>
81121610:	04c00104 	movi	r19,4
81121614:	0021883a 	mov	r16,zero
81121618:	0029883a 	mov	r20,zero
8112161c:	07000044 	movi	fp,1
81121620:	003f6106 	br	811213a8 <__reset+0xfb1013a8>
81121624:	04c00304 	movi	r19,12
81121628:	070000c4 	movi	fp,3
8112162c:	003f5e06 	br	811213a8 <__reset+0xfb1013a8>
81121630:	01400434 	movhi	r5,16
81121634:	002b883a 	mov	r21,zero
81121638:	297fffc4 	addi	r5,r5,-1
8112163c:	053fffc4 	movi	r20,-1
81121640:	0081ffc4 	movi	r2,2047
81121644:	003f9806 	br	811214a8 <__reset+0xfb1014a8>
81121648:	8023883a 	mov	r17,r16
8112164c:	a011883a 	mov	r8,r20
81121650:	e00b883a 	mov	r5,fp
81121654:	003f8a06 	br	81121480 <__reset+0xfb101480>
81121658:	8023883a 	mov	r17,r16
8112165c:	a011883a 	mov	r8,r20
81121660:	482d883a 	mov	r22,r9
81121664:	e00b883a 	mov	r5,fp
81121668:	003f8506 	br	81121480 <__reset+0xfb101480>
8112166c:	a00ad43a 	srli	r5,r20,16
81121670:	401ad43a 	srli	r13,r8,16
81121674:	a53fffcc 	andi	r20,r20,65535
81121678:	423fffcc 	andi	r8,r8,65535
8112167c:	4519383a 	mul	r12,r8,r20
81121680:	4147383a 	mul	r3,r8,r5
81121684:	6d09383a 	mul	r4,r13,r20
81121688:	600cd43a 	srli	r6,r12,16
8112168c:	2b5d383a 	mul	r14,r5,r13
81121690:	20c9883a 	add	r4,r4,r3
81121694:	310d883a 	add	r6,r6,r4
81121698:	30c0022e 	bgeu	r6,r3,811216a4 <__muldf3+0x380>
8112169c:	00c00074 	movhi	r3,1
811216a0:	70dd883a 	add	r14,r14,r3
811216a4:	8826d43a 	srli	r19,r17,16
811216a8:	8bffffcc 	andi	r15,r17,65535
811216ac:	7d23383a 	mul	r17,r15,r20
811216b0:	7949383a 	mul	r4,r15,r5
811216b4:	9d29383a 	mul	r20,r19,r20
811216b8:	8814d43a 	srli	r10,r17,16
811216bc:	3012943a 	slli	r9,r6,16
811216c0:	a129883a 	add	r20,r20,r4
811216c4:	633fffcc 	andi	r12,r12,65535
811216c8:	5515883a 	add	r10,r10,r20
811216cc:	3006d43a 	srli	r3,r6,16
811216d0:	4b13883a 	add	r9,r9,r12
811216d4:	2ccb383a 	mul	r5,r5,r19
811216d8:	5100022e 	bgeu	r10,r4,811216e4 <__muldf3+0x3c0>
811216dc:	01000074 	movhi	r4,1
811216e0:	290b883a 	add	r5,r5,r4
811216e4:	802ad43a 	srli	r21,r16,16
811216e8:	843fffcc 	andi	r16,r16,65535
811216ec:	440d383a 	mul	r6,r8,r16
811216f0:	4565383a 	mul	r18,r8,r21
811216f4:	8349383a 	mul	r4,r16,r13
811216f8:	500e943a 	slli	r7,r10,16
811216fc:	3010d43a 	srli	r8,r6,16
81121700:	5028d43a 	srli	r20,r10,16
81121704:	2489883a 	add	r4,r4,r18
81121708:	8abfffcc 	andi	r10,r17,65535
8112170c:	3a95883a 	add	r10,r7,r10
81121710:	4119883a 	add	r12,r8,r4
81121714:	a169883a 	add	r20,r20,r5
81121718:	1a87883a 	add	r3,r3,r10
8112171c:	6d5b383a 	mul	r13,r13,r21
81121720:	6480022e 	bgeu	r12,r18,8112172c <__muldf3+0x408>
81121724:	01000074 	movhi	r4,1
81121728:	691b883a 	add	r13,r13,r4
8112172c:	7c25383a 	mul	r18,r15,r16
81121730:	7d4b383a 	mul	r5,r15,r21
81121734:	84cf383a 	mul	r7,r16,r19
81121738:	901ed43a 	srli	r15,r18,16
8112173c:	6008d43a 	srli	r4,r12,16
81121740:	6010943a 	slli	r8,r12,16
81121744:	394f883a 	add	r7,r7,r5
81121748:	333fffcc 	andi	r12,r6,65535
8112174c:	79df883a 	add	r15,r15,r7
81121750:	235b883a 	add	r13,r4,r13
81121754:	9d63383a 	mul	r17,r19,r21
81121758:	4309883a 	add	r4,r8,r12
8112175c:	7940022e 	bgeu	r15,r5,81121768 <__muldf3+0x444>
81121760:	01400074 	movhi	r5,1
81121764:	8963883a 	add	r17,r17,r5
81121768:	780a943a 	slli	r5,r15,16
8112176c:	91bfffcc 	andi	r6,r18,65535
81121770:	70c7883a 	add	r3,r14,r3
81121774:	298d883a 	add	r6,r5,r6
81121778:	1a8f803a 	cmpltu	r7,r3,r10
8112177c:	350b883a 	add	r5,r6,r20
81121780:	20c7883a 	add	r3,r4,r3
81121784:	3955883a 	add	r10,r7,r5
81121788:	1909803a 	cmpltu	r4,r3,r4
8112178c:	6a91883a 	add	r8,r13,r10
81121790:	780cd43a 	srli	r6,r15,16
81121794:	2219883a 	add	r12,r4,r8
81121798:	2d0b803a 	cmpltu	r5,r5,r20
8112179c:	51cf803a 	cmpltu	r7,r10,r7
811217a0:	29ceb03a 	or	r7,r5,r7
811217a4:	4351803a 	cmpltu	r8,r8,r13
811217a8:	610b803a 	cmpltu	r5,r12,r4
811217ac:	4148b03a 	or	r4,r8,r5
811217b0:	398f883a 	add	r7,r7,r6
811217b4:	3909883a 	add	r4,r7,r4
811217b8:	1810927a 	slli	r8,r3,9
811217bc:	2449883a 	add	r4,r4,r17
811217c0:	2008927a 	slli	r4,r4,9
811217c4:	6022d5fa 	srli	r17,r12,23
811217c8:	1806d5fa 	srli	r3,r3,23
811217cc:	4252b03a 	or	r9,r8,r9
811217d0:	600a927a 	slli	r5,r12,9
811217d4:	4810c03a 	cmpne	r8,r9,zero
811217d8:	2462b03a 	or	r17,r4,r17
811217dc:	40c6b03a 	or	r3,r8,r3
811217e0:	8900402c 	andhi	r4,r17,256
811217e4:	1950b03a 	or	r8,r3,r5
811217e8:	20000726 	beq	r4,zero,81121808 <__muldf3+0x4e4>
811217ec:	4006d07a 	srli	r3,r8,1
811217f0:	880497fa 	slli	r2,r17,31
811217f4:	4200004c 	andi	r8,r8,1
811217f8:	8822d07a 	srli	r17,r17,1
811217fc:	1a10b03a 	or	r8,r3,r8
81121800:	1210b03a 	or	r8,r2,r8
81121804:	5805883a 	mov	r2,r11
81121808:	1140ffc4 	addi	r5,r2,1023
8112180c:	0140440e 	bge	zero,r5,81121920 <__muldf3+0x5fc>
81121810:	40c001cc 	andi	r3,r8,7
81121814:	18000726 	beq	r3,zero,81121834 <__muldf3+0x510>
81121818:	40c003cc 	andi	r3,r8,15
8112181c:	01000104 	movi	r4,4
81121820:	19000426 	beq	r3,r4,81121834 <__muldf3+0x510>
81121824:	4107883a 	add	r3,r8,r4
81121828:	1a11803a 	cmpltu	r8,r3,r8
8112182c:	8a23883a 	add	r17,r17,r8
81121830:	1811883a 	mov	r8,r3
81121834:	88c0402c 	andhi	r3,r17,256
81121838:	18000426 	beq	r3,zero,8112184c <__muldf3+0x528>
8112183c:	11410004 	addi	r5,r2,1024
81121840:	00bfc034 	movhi	r2,65280
81121844:	10bfffc4 	addi	r2,r2,-1
81121848:	88a2703a 	and	r17,r17,r2
8112184c:	0081ff84 	movi	r2,2046
81121850:	117f6416 	blt	r2,r5,811215e4 <__reset+0xfb1015e4>
81121854:	8828977a 	slli	r20,r17,29
81121858:	4010d0fa 	srli	r8,r8,3
8112185c:	8822927a 	slli	r17,r17,9
81121860:	2881ffcc 	andi	r2,r5,2047
81121864:	a228b03a 	or	r20,r20,r8
81121868:	880ad33a 	srli	r5,r17,12
8112186c:	b02b883a 	mov	r21,r22
81121870:	003f0d06 	br	811214a8 <__reset+0xfb1014a8>
81121874:	8080022c 	andhi	r2,r16,8
81121878:	10000926 	beq	r2,zero,811218a0 <__muldf3+0x57c>
8112187c:	8880022c 	andhi	r2,r17,8
81121880:	1000071e 	bne	r2,zero,811218a0 <__muldf3+0x57c>
81121884:	00800434 	movhi	r2,16
81121888:	89400234 	orhi	r5,r17,8
8112188c:	10bfffc4 	addi	r2,r2,-1
81121890:	b82b883a 	mov	r21,r23
81121894:	288a703a 	and	r5,r5,r2
81121898:	4029883a 	mov	r20,r8
8112189c:	003f6806 	br	81121640 <__reset+0xfb101640>
811218a0:	00800434 	movhi	r2,16
811218a4:	81400234 	orhi	r5,r16,8
811218a8:	10bfffc4 	addi	r2,r2,-1
811218ac:	288a703a 	and	r5,r5,r2
811218b0:	003f6306 	br	81121640 <__reset+0xfb101640>
811218b4:	147ff604 	addi	r17,r2,-40
811218b8:	3462983a 	sll	r17,r6,r17
811218bc:	0011883a 	mov	r8,zero
811218c0:	003f4406 	br	811215d4 <__reset+0xfb1015d4>
811218c4:	3009883a 	mov	r4,r6
811218c8:	d9800215 	stw	r6,8(sp)
811218cc:	da400115 	stw	r9,4(sp)
811218d0:	da800015 	stw	r10,0(sp)
811218d4:	112276c0 	call	8112276c <__clzsi2>
811218d8:	10800804 	addi	r2,r2,32
811218dc:	da800017 	ldw	r10,0(sp)
811218e0:	da400117 	ldw	r9,4(sp)
811218e4:	d9800217 	ldw	r6,8(sp)
811218e8:	003f3006 	br	811215ac <__reset+0xfb1015ac>
811218ec:	143ff604 	addi	r16,r2,-40
811218f0:	9c20983a 	sll	r16,r19,r16
811218f4:	0029883a 	mov	r20,zero
811218f8:	003f1606 	br	81121554 <__reset+0xfb101554>
811218fc:	d9800215 	stw	r6,8(sp)
81121900:	d9c00015 	stw	r7,0(sp)
81121904:	da400115 	stw	r9,4(sp)
81121908:	112276c0 	call	8112276c <__clzsi2>
8112190c:	10800804 	addi	r2,r2,32
81121910:	da400117 	ldw	r9,4(sp)
81121914:	d9c00017 	ldw	r7,0(sp)
81121918:	d9800217 	ldw	r6,8(sp)
8112191c:	003f0306 	br	8112152c <__reset+0xfb10152c>
81121920:	00c00044 	movi	r3,1
81121924:	1947c83a 	sub	r3,r3,r5
81121928:	00800e04 	movi	r2,56
8112192c:	10feda16 	blt	r2,r3,81121498 <__reset+0xfb101498>
81121930:	008007c4 	movi	r2,31
81121934:	10c01b16 	blt	r2,r3,811219a4 <__muldf3+0x680>
81121938:	00800804 	movi	r2,32
8112193c:	10c5c83a 	sub	r2,r2,r3
81121940:	888a983a 	sll	r5,r17,r2
81121944:	40c8d83a 	srl	r4,r8,r3
81121948:	4084983a 	sll	r2,r8,r2
8112194c:	88e2d83a 	srl	r17,r17,r3
81121950:	2906b03a 	or	r3,r5,r4
81121954:	1004c03a 	cmpne	r2,r2,zero
81121958:	1886b03a 	or	r3,r3,r2
8112195c:	188001cc 	andi	r2,r3,7
81121960:	10000726 	beq	r2,zero,81121980 <__muldf3+0x65c>
81121964:	188003cc 	andi	r2,r3,15
81121968:	01000104 	movi	r4,4
8112196c:	11000426 	beq	r2,r4,81121980 <__muldf3+0x65c>
81121970:	1805883a 	mov	r2,r3
81121974:	10c00104 	addi	r3,r2,4
81121978:	1885803a 	cmpltu	r2,r3,r2
8112197c:	88a3883a 	add	r17,r17,r2
81121980:	8880202c 	andhi	r2,r17,128
81121984:	10001c26 	beq	r2,zero,811219f8 <__muldf3+0x6d4>
81121988:	b02b883a 	mov	r21,r22
8112198c:	00800044 	movi	r2,1
81121990:	000b883a 	mov	r5,zero
81121994:	0029883a 	mov	r20,zero
81121998:	003ec306 	br	811214a8 <__reset+0xfb1014a8>
8112199c:	5805883a 	mov	r2,r11
811219a0:	003f9906 	br	81121808 <__reset+0xfb101808>
811219a4:	00bff844 	movi	r2,-31
811219a8:	1145c83a 	sub	r2,r2,r5
811219ac:	8888d83a 	srl	r4,r17,r2
811219b0:	00800804 	movi	r2,32
811219b4:	18801a26 	beq	r3,r2,81121a20 <__muldf3+0x6fc>
811219b8:	00801004 	movi	r2,64
811219bc:	10c5c83a 	sub	r2,r2,r3
811219c0:	8884983a 	sll	r2,r17,r2
811219c4:	1204b03a 	or	r2,r2,r8
811219c8:	1004c03a 	cmpne	r2,r2,zero
811219cc:	2084b03a 	or	r2,r4,r2
811219d0:	144001cc 	andi	r17,r2,7
811219d4:	88000d1e 	bne	r17,zero,81121a0c <__muldf3+0x6e8>
811219d8:	000b883a 	mov	r5,zero
811219dc:	1028d0fa 	srli	r20,r2,3
811219e0:	b02b883a 	mov	r21,r22
811219e4:	0005883a 	mov	r2,zero
811219e8:	a468b03a 	or	r20,r20,r17
811219ec:	003eae06 	br	811214a8 <__reset+0xfb1014a8>
811219f0:	1007883a 	mov	r3,r2
811219f4:	0023883a 	mov	r17,zero
811219f8:	880a927a 	slli	r5,r17,9
811219fc:	1805883a 	mov	r2,r3
81121a00:	8822977a 	slli	r17,r17,29
81121a04:	280ad33a 	srli	r5,r5,12
81121a08:	003ff406 	br	811219dc <__reset+0xfb1019dc>
81121a0c:	10c003cc 	andi	r3,r2,15
81121a10:	01000104 	movi	r4,4
81121a14:	193ff626 	beq	r3,r4,811219f0 <__reset+0xfb1019f0>
81121a18:	0023883a 	mov	r17,zero
81121a1c:	003fd506 	br	81121974 <__reset+0xfb101974>
81121a20:	0005883a 	mov	r2,zero
81121a24:	003fe706 	br	811219c4 <__reset+0xfb1019c4>
81121a28:	00800434 	movhi	r2,16
81121a2c:	89400234 	orhi	r5,r17,8
81121a30:	10bfffc4 	addi	r2,r2,-1
81121a34:	b02b883a 	mov	r21,r22
81121a38:	288a703a 	and	r5,r5,r2
81121a3c:	4029883a 	mov	r20,r8
81121a40:	003eff06 	br	81121640 <__reset+0xfb101640>

81121a44 <__subdf3>:
81121a44:	02000434 	movhi	r8,16
81121a48:	423fffc4 	addi	r8,r8,-1
81121a4c:	defffb04 	addi	sp,sp,-20
81121a50:	2a14703a 	and	r10,r5,r8
81121a54:	3812d53a 	srli	r9,r7,20
81121a58:	3a10703a 	and	r8,r7,r8
81121a5c:	de00012e 	bgeu	sp,et,81121a64 <__subdf3+0x20>
81121a60:	003b68fa 	trap	3
81121a64:	2006d77a 	srli	r3,r4,29
81121a68:	3004d77a 	srli	r2,r6,29
81121a6c:	dc000015 	stw	r16,0(sp)
81121a70:	501490fa 	slli	r10,r10,3
81121a74:	2820d53a 	srli	r16,r5,20
81121a78:	401090fa 	slli	r8,r8,3
81121a7c:	dc800215 	stw	r18,8(sp)
81121a80:	dc400115 	stw	r17,4(sp)
81121a84:	dfc00415 	stw	ra,16(sp)
81121a88:	202290fa 	slli	r17,r4,3
81121a8c:	dcc00315 	stw	r19,12(sp)
81121a90:	4a41ffcc 	andi	r9,r9,2047
81121a94:	0101ffc4 	movi	r4,2047
81121a98:	2824d7fa 	srli	r18,r5,31
81121a9c:	8401ffcc 	andi	r16,r16,2047
81121aa0:	50c6b03a 	or	r3,r10,r3
81121aa4:	380ed7fa 	srli	r7,r7,31
81121aa8:	408ab03a 	or	r5,r8,r2
81121aac:	300c90fa 	slli	r6,r6,3
81121ab0:	49009626 	beq	r9,r4,81121d0c <__subdf3+0x2c8>
81121ab4:	39c0005c 	xori	r7,r7,1
81121ab8:	8245c83a 	sub	r2,r16,r9
81121abc:	3c807426 	beq	r7,r18,81121c90 <__subdf3+0x24c>
81121ac0:	0080af0e 	bge	zero,r2,81121d80 <__subdf3+0x33c>
81121ac4:	48002a1e 	bne	r9,zero,81121b70 <__subdf3+0x12c>
81121ac8:	2988b03a 	or	r4,r5,r6
81121acc:	20009a1e 	bne	r4,zero,81121d38 <__subdf3+0x2f4>
81121ad0:	888001cc 	andi	r2,r17,7
81121ad4:	10000726 	beq	r2,zero,81121af4 <__subdf3+0xb0>
81121ad8:	888003cc 	andi	r2,r17,15
81121adc:	01000104 	movi	r4,4
81121ae0:	11000426 	beq	r2,r4,81121af4 <__subdf3+0xb0>
81121ae4:	890b883a 	add	r5,r17,r4
81121ae8:	2c63803a 	cmpltu	r17,r5,r17
81121aec:	1c47883a 	add	r3,r3,r17
81121af0:	2823883a 	mov	r17,r5
81121af4:	1880202c 	andhi	r2,r3,128
81121af8:	10005926 	beq	r2,zero,81121c60 <__subdf3+0x21c>
81121afc:	84000044 	addi	r16,r16,1
81121b00:	0081ffc4 	movi	r2,2047
81121b04:	8080be26 	beq	r16,r2,81121e00 <__subdf3+0x3bc>
81121b08:	017fe034 	movhi	r5,65408
81121b0c:	297fffc4 	addi	r5,r5,-1
81121b10:	1946703a 	and	r3,r3,r5
81121b14:	1804977a 	slli	r2,r3,29
81121b18:	1806927a 	slli	r3,r3,9
81121b1c:	8822d0fa 	srli	r17,r17,3
81121b20:	8401ffcc 	andi	r16,r16,2047
81121b24:	180ad33a 	srli	r5,r3,12
81121b28:	9100004c 	andi	r4,r18,1
81121b2c:	1444b03a 	or	r2,r2,r17
81121b30:	80c1ffcc 	andi	r3,r16,2047
81121b34:	1820953a 	slli	r16,r3,20
81121b38:	20c03fcc 	andi	r3,r4,255
81121b3c:	180897fa 	slli	r4,r3,31
81121b40:	00c00434 	movhi	r3,16
81121b44:	18ffffc4 	addi	r3,r3,-1
81121b48:	28c6703a 	and	r3,r5,r3
81121b4c:	1c06b03a 	or	r3,r3,r16
81121b50:	1906b03a 	or	r3,r3,r4
81121b54:	dfc00417 	ldw	ra,16(sp)
81121b58:	dcc00317 	ldw	r19,12(sp)
81121b5c:	dc800217 	ldw	r18,8(sp)
81121b60:	dc400117 	ldw	r17,4(sp)
81121b64:	dc000017 	ldw	r16,0(sp)
81121b68:	dec00504 	addi	sp,sp,20
81121b6c:	f800283a 	ret
81121b70:	0101ffc4 	movi	r4,2047
81121b74:	813fd626 	beq	r16,r4,81121ad0 <__reset+0xfb101ad0>
81121b78:	29402034 	orhi	r5,r5,128
81121b7c:	01000e04 	movi	r4,56
81121b80:	2080a316 	blt	r4,r2,81121e10 <__subdf3+0x3cc>
81121b84:	010007c4 	movi	r4,31
81121b88:	2080c616 	blt	r4,r2,81121ea4 <__subdf3+0x460>
81121b8c:	01000804 	movi	r4,32
81121b90:	2089c83a 	sub	r4,r4,r2
81121b94:	2910983a 	sll	r8,r5,r4
81121b98:	308ed83a 	srl	r7,r6,r2
81121b9c:	3108983a 	sll	r4,r6,r4
81121ba0:	2884d83a 	srl	r2,r5,r2
81121ba4:	41ccb03a 	or	r6,r8,r7
81121ba8:	2008c03a 	cmpne	r4,r4,zero
81121bac:	310cb03a 	or	r6,r6,r4
81121bb0:	898dc83a 	sub	r6,r17,r6
81121bb4:	89a3803a 	cmpltu	r17,r17,r6
81121bb8:	1887c83a 	sub	r3,r3,r2
81121bbc:	1c47c83a 	sub	r3,r3,r17
81121bc0:	3023883a 	mov	r17,r6
81121bc4:	1880202c 	andhi	r2,r3,128
81121bc8:	10002326 	beq	r2,zero,81121c58 <__subdf3+0x214>
81121bcc:	04c02034 	movhi	r19,128
81121bd0:	9cffffc4 	addi	r19,r19,-1
81121bd4:	1ce6703a 	and	r19,r3,r19
81121bd8:	98007a26 	beq	r19,zero,81121dc4 <__subdf3+0x380>
81121bdc:	9809883a 	mov	r4,r19
81121be0:	112276c0 	call	8112276c <__clzsi2>
81121be4:	113ffe04 	addi	r4,r2,-8
81121be8:	00c007c4 	movi	r3,31
81121bec:	19007b16 	blt	r3,r4,81121ddc <__subdf3+0x398>
81121bf0:	00800804 	movi	r2,32
81121bf4:	1105c83a 	sub	r2,r2,r4
81121bf8:	8884d83a 	srl	r2,r17,r2
81121bfc:	9906983a 	sll	r3,r19,r4
81121c00:	8922983a 	sll	r17,r17,r4
81121c04:	10c4b03a 	or	r2,r2,r3
81121c08:	24007816 	blt	r4,r16,81121dec <__subdf3+0x3a8>
81121c0c:	2421c83a 	sub	r16,r4,r16
81121c10:	80c00044 	addi	r3,r16,1
81121c14:	010007c4 	movi	r4,31
81121c18:	20c09516 	blt	r4,r3,81121e70 <__subdf3+0x42c>
81121c1c:	01400804 	movi	r5,32
81121c20:	28cbc83a 	sub	r5,r5,r3
81121c24:	88c8d83a 	srl	r4,r17,r3
81121c28:	8962983a 	sll	r17,r17,r5
81121c2c:	114a983a 	sll	r5,r2,r5
81121c30:	10c6d83a 	srl	r3,r2,r3
81121c34:	8804c03a 	cmpne	r2,r17,zero
81121c38:	290ab03a 	or	r5,r5,r4
81121c3c:	28a2b03a 	or	r17,r5,r2
81121c40:	0021883a 	mov	r16,zero
81121c44:	003fa206 	br	81121ad0 <__reset+0xfb101ad0>
81121c48:	2090b03a 	or	r8,r4,r2
81121c4c:	40018e26 	beq	r8,zero,81122288 <__subdf3+0x844>
81121c50:	1007883a 	mov	r3,r2
81121c54:	2023883a 	mov	r17,r4
81121c58:	888001cc 	andi	r2,r17,7
81121c5c:	103f9e1e 	bne	r2,zero,81121ad8 <__reset+0xfb101ad8>
81121c60:	1804977a 	slli	r2,r3,29
81121c64:	8822d0fa 	srli	r17,r17,3
81121c68:	1810d0fa 	srli	r8,r3,3
81121c6c:	9100004c 	andi	r4,r18,1
81121c70:	1444b03a 	or	r2,r2,r17
81121c74:	00c1ffc4 	movi	r3,2047
81121c78:	80c02826 	beq	r16,r3,81121d1c <__subdf3+0x2d8>
81121c7c:	01400434 	movhi	r5,16
81121c80:	297fffc4 	addi	r5,r5,-1
81121c84:	80e0703a 	and	r16,r16,r3
81121c88:	414a703a 	and	r5,r8,r5
81121c8c:	003fa806 	br	81121b30 <__reset+0xfb101b30>
81121c90:	0080630e 	bge	zero,r2,81121e20 <__subdf3+0x3dc>
81121c94:	48003026 	beq	r9,zero,81121d58 <__subdf3+0x314>
81121c98:	0101ffc4 	movi	r4,2047
81121c9c:	813f8c26 	beq	r16,r4,81121ad0 <__reset+0xfb101ad0>
81121ca0:	29402034 	orhi	r5,r5,128
81121ca4:	01000e04 	movi	r4,56
81121ca8:	2080a90e 	bge	r4,r2,81121f50 <__subdf3+0x50c>
81121cac:	298cb03a 	or	r6,r5,r6
81121cb0:	3012c03a 	cmpne	r9,r6,zero
81121cb4:	0005883a 	mov	r2,zero
81121cb8:	4c53883a 	add	r9,r9,r17
81121cbc:	4c63803a 	cmpltu	r17,r9,r17
81121cc0:	10c7883a 	add	r3,r2,r3
81121cc4:	88c7883a 	add	r3,r17,r3
81121cc8:	4823883a 	mov	r17,r9
81121ccc:	1880202c 	andhi	r2,r3,128
81121cd0:	1000d026 	beq	r2,zero,81122014 <__subdf3+0x5d0>
81121cd4:	84000044 	addi	r16,r16,1
81121cd8:	0081ffc4 	movi	r2,2047
81121cdc:	8080fe26 	beq	r16,r2,811220d8 <__subdf3+0x694>
81121ce0:	00bfe034 	movhi	r2,65408
81121ce4:	10bfffc4 	addi	r2,r2,-1
81121ce8:	1886703a 	and	r3,r3,r2
81121cec:	880ad07a 	srli	r5,r17,1
81121cf0:	180497fa 	slli	r2,r3,31
81121cf4:	8900004c 	andi	r4,r17,1
81121cf8:	2922b03a 	or	r17,r5,r4
81121cfc:	1806d07a 	srli	r3,r3,1
81121d00:	1462b03a 	or	r17,r2,r17
81121d04:	3825883a 	mov	r18,r7
81121d08:	003f7106 	br	81121ad0 <__reset+0xfb101ad0>
81121d0c:	2984b03a 	or	r2,r5,r6
81121d10:	103f6826 	beq	r2,zero,81121ab4 <__reset+0xfb101ab4>
81121d14:	39c03fcc 	andi	r7,r7,255
81121d18:	003f6706 	br	81121ab8 <__reset+0xfb101ab8>
81121d1c:	4086b03a 	or	r3,r8,r2
81121d20:	18015226 	beq	r3,zero,8112226c <__subdf3+0x828>
81121d24:	00c00434 	movhi	r3,16
81121d28:	41400234 	orhi	r5,r8,8
81121d2c:	18ffffc4 	addi	r3,r3,-1
81121d30:	28ca703a 	and	r5,r5,r3
81121d34:	003f7e06 	br	81121b30 <__reset+0xfb101b30>
81121d38:	10bfffc4 	addi	r2,r2,-1
81121d3c:	1000491e 	bne	r2,zero,81121e64 <__subdf3+0x420>
81121d40:	898fc83a 	sub	r7,r17,r6
81121d44:	89e3803a 	cmpltu	r17,r17,r7
81121d48:	1947c83a 	sub	r3,r3,r5
81121d4c:	1c47c83a 	sub	r3,r3,r17
81121d50:	3823883a 	mov	r17,r7
81121d54:	003f9b06 	br	81121bc4 <__reset+0xfb101bc4>
81121d58:	2988b03a 	or	r4,r5,r6
81121d5c:	203f5c26 	beq	r4,zero,81121ad0 <__reset+0xfb101ad0>
81121d60:	10bfffc4 	addi	r2,r2,-1
81121d64:	1000931e 	bne	r2,zero,81121fb4 <__subdf3+0x570>
81121d68:	898d883a 	add	r6,r17,r6
81121d6c:	3463803a 	cmpltu	r17,r6,r17
81121d70:	1947883a 	add	r3,r3,r5
81121d74:	88c7883a 	add	r3,r17,r3
81121d78:	3023883a 	mov	r17,r6
81121d7c:	003fd306 	br	81121ccc <__reset+0xfb101ccc>
81121d80:	1000541e 	bne	r2,zero,81121ed4 <__subdf3+0x490>
81121d84:	80800044 	addi	r2,r16,1
81121d88:	1081ffcc 	andi	r2,r2,2047
81121d8c:	01000044 	movi	r4,1
81121d90:	2080a20e 	bge	r4,r2,8112201c <__subdf3+0x5d8>
81121d94:	8989c83a 	sub	r4,r17,r6
81121d98:	8905803a 	cmpltu	r2,r17,r4
81121d9c:	1967c83a 	sub	r19,r3,r5
81121da0:	98a7c83a 	sub	r19,r19,r2
81121da4:	9880202c 	andhi	r2,r19,128
81121da8:	10006326 	beq	r2,zero,81121f38 <__subdf3+0x4f4>
81121dac:	3463c83a 	sub	r17,r6,r17
81121db0:	28c7c83a 	sub	r3,r5,r3
81121db4:	344d803a 	cmpltu	r6,r6,r17
81121db8:	19a7c83a 	sub	r19,r3,r6
81121dbc:	3825883a 	mov	r18,r7
81121dc0:	983f861e 	bne	r19,zero,81121bdc <__reset+0xfb101bdc>
81121dc4:	8809883a 	mov	r4,r17
81121dc8:	112276c0 	call	8112276c <__clzsi2>
81121dcc:	10800804 	addi	r2,r2,32
81121dd0:	113ffe04 	addi	r4,r2,-8
81121dd4:	00c007c4 	movi	r3,31
81121dd8:	193f850e 	bge	r3,r4,81121bf0 <__reset+0xfb101bf0>
81121ddc:	10bff604 	addi	r2,r2,-40
81121de0:	8884983a 	sll	r2,r17,r2
81121de4:	0023883a 	mov	r17,zero
81121de8:	243f880e 	bge	r4,r16,81121c0c <__reset+0xfb101c0c>
81121dec:	00ffe034 	movhi	r3,65408
81121df0:	18ffffc4 	addi	r3,r3,-1
81121df4:	8121c83a 	sub	r16,r16,r4
81121df8:	10c6703a 	and	r3,r2,r3
81121dfc:	003f3406 	br	81121ad0 <__reset+0xfb101ad0>
81121e00:	9100004c 	andi	r4,r18,1
81121e04:	000b883a 	mov	r5,zero
81121e08:	0005883a 	mov	r2,zero
81121e0c:	003f4806 	br	81121b30 <__reset+0xfb101b30>
81121e10:	298cb03a 	or	r6,r5,r6
81121e14:	300cc03a 	cmpne	r6,r6,zero
81121e18:	0005883a 	mov	r2,zero
81121e1c:	003f6406 	br	81121bb0 <__reset+0xfb101bb0>
81121e20:	10009a1e 	bne	r2,zero,8112208c <__subdf3+0x648>
81121e24:	82400044 	addi	r9,r16,1
81121e28:	4881ffcc 	andi	r2,r9,2047
81121e2c:	02800044 	movi	r10,1
81121e30:	5080670e 	bge	r10,r2,81121fd0 <__subdf3+0x58c>
81121e34:	0081ffc4 	movi	r2,2047
81121e38:	4880af26 	beq	r9,r2,811220f8 <__subdf3+0x6b4>
81121e3c:	898d883a 	add	r6,r17,r6
81121e40:	1945883a 	add	r2,r3,r5
81121e44:	3447803a 	cmpltu	r3,r6,r17
81121e48:	1887883a 	add	r3,r3,r2
81121e4c:	182297fa 	slli	r17,r3,31
81121e50:	300cd07a 	srli	r6,r6,1
81121e54:	1806d07a 	srli	r3,r3,1
81121e58:	4821883a 	mov	r16,r9
81121e5c:	89a2b03a 	or	r17,r17,r6
81121e60:	003f1b06 	br	81121ad0 <__reset+0xfb101ad0>
81121e64:	0101ffc4 	movi	r4,2047
81121e68:	813f441e 	bne	r16,r4,81121b7c <__reset+0xfb101b7c>
81121e6c:	003f1806 	br	81121ad0 <__reset+0xfb101ad0>
81121e70:	843ff844 	addi	r16,r16,-31
81121e74:	01400804 	movi	r5,32
81121e78:	1408d83a 	srl	r4,r2,r16
81121e7c:	19405026 	beq	r3,r5,81121fc0 <__subdf3+0x57c>
81121e80:	01401004 	movi	r5,64
81121e84:	28c7c83a 	sub	r3,r5,r3
81121e88:	10c4983a 	sll	r2,r2,r3
81121e8c:	88a2b03a 	or	r17,r17,r2
81121e90:	8822c03a 	cmpne	r17,r17,zero
81121e94:	2462b03a 	or	r17,r4,r17
81121e98:	0007883a 	mov	r3,zero
81121e9c:	0021883a 	mov	r16,zero
81121ea0:	003f6d06 	br	81121c58 <__reset+0xfb101c58>
81121ea4:	11fff804 	addi	r7,r2,-32
81121ea8:	01000804 	movi	r4,32
81121eac:	29ced83a 	srl	r7,r5,r7
81121eb0:	11004526 	beq	r2,r4,81121fc8 <__subdf3+0x584>
81121eb4:	01001004 	movi	r4,64
81121eb8:	2089c83a 	sub	r4,r4,r2
81121ebc:	2904983a 	sll	r2,r5,r4
81121ec0:	118cb03a 	or	r6,r2,r6
81121ec4:	300cc03a 	cmpne	r6,r6,zero
81121ec8:	398cb03a 	or	r6,r7,r6
81121ecc:	0005883a 	mov	r2,zero
81121ed0:	003f3706 	br	81121bb0 <__reset+0xfb101bb0>
81121ed4:	80002a26 	beq	r16,zero,81121f80 <__subdf3+0x53c>
81121ed8:	0101ffc4 	movi	r4,2047
81121edc:	49006626 	beq	r9,r4,81122078 <__subdf3+0x634>
81121ee0:	0085c83a 	sub	r2,zero,r2
81121ee4:	18c02034 	orhi	r3,r3,128
81121ee8:	01000e04 	movi	r4,56
81121eec:	20807e16 	blt	r4,r2,811220e8 <__subdf3+0x6a4>
81121ef0:	010007c4 	movi	r4,31
81121ef4:	2080e716 	blt	r4,r2,81122294 <__subdf3+0x850>
81121ef8:	01000804 	movi	r4,32
81121efc:	2089c83a 	sub	r4,r4,r2
81121f00:	1914983a 	sll	r10,r3,r4
81121f04:	8890d83a 	srl	r8,r17,r2
81121f08:	8908983a 	sll	r4,r17,r4
81121f0c:	1884d83a 	srl	r2,r3,r2
81121f10:	5222b03a 	or	r17,r10,r8
81121f14:	2006c03a 	cmpne	r3,r4,zero
81121f18:	88e2b03a 	or	r17,r17,r3
81121f1c:	3463c83a 	sub	r17,r6,r17
81121f20:	2885c83a 	sub	r2,r5,r2
81121f24:	344d803a 	cmpltu	r6,r6,r17
81121f28:	1187c83a 	sub	r3,r2,r6
81121f2c:	4821883a 	mov	r16,r9
81121f30:	3825883a 	mov	r18,r7
81121f34:	003f2306 	br	81121bc4 <__reset+0xfb101bc4>
81121f38:	24d0b03a 	or	r8,r4,r19
81121f3c:	40001b1e 	bne	r8,zero,81121fac <__subdf3+0x568>
81121f40:	0005883a 	mov	r2,zero
81121f44:	0009883a 	mov	r4,zero
81121f48:	0021883a 	mov	r16,zero
81121f4c:	003f4906 	br	81121c74 <__reset+0xfb101c74>
81121f50:	010007c4 	movi	r4,31
81121f54:	20803a16 	blt	r4,r2,81122040 <__subdf3+0x5fc>
81121f58:	01000804 	movi	r4,32
81121f5c:	2089c83a 	sub	r4,r4,r2
81121f60:	2912983a 	sll	r9,r5,r4
81121f64:	3090d83a 	srl	r8,r6,r2
81121f68:	3108983a 	sll	r4,r6,r4
81121f6c:	2884d83a 	srl	r2,r5,r2
81121f70:	4a12b03a 	or	r9,r9,r8
81121f74:	2008c03a 	cmpne	r4,r4,zero
81121f78:	4912b03a 	or	r9,r9,r4
81121f7c:	003f4e06 	br	81121cb8 <__reset+0xfb101cb8>
81121f80:	1c48b03a 	or	r4,r3,r17
81121f84:	20003c26 	beq	r4,zero,81122078 <__subdf3+0x634>
81121f88:	0084303a 	nor	r2,zero,r2
81121f8c:	1000381e 	bne	r2,zero,81122070 <__subdf3+0x62c>
81121f90:	3463c83a 	sub	r17,r6,r17
81121f94:	28c5c83a 	sub	r2,r5,r3
81121f98:	344d803a 	cmpltu	r6,r6,r17
81121f9c:	1187c83a 	sub	r3,r2,r6
81121fa0:	4821883a 	mov	r16,r9
81121fa4:	3825883a 	mov	r18,r7
81121fa8:	003f0606 	br	81121bc4 <__reset+0xfb101bc4>
81121fac:	2023883a 	mov	r17,r4
81121fb0:	003f0906 	br	81121bd8 <__reset+0xfb101bd8>
81121fb4:	0101ffc4 	movi	r4,2047
81121fb8:	813f3a1e 	bne	r16,r4,81121ca4 <__reset+0xfb101ca4>
81121fbc:	003ec406 	br	81121ad0 <__reset+0xfb101ad0>
81121fc0:	0005883a 	mov	r2,zero
81121fc4:	003fb106 	br	81121e8c <__reset+0xfb101e8c>
81121fc8:	0005883a 	mov	r2,zero
81121fcc:	003fbc06 	br	81121ec0 <__reset+0xfb101ec0>
81121fd0:	1c44b03a 	or	r2,r3,r17
81121fd4:	80008e1e 	bne	r16,zero,81122210 <__subdf3+0x7cc>
81121fd8:	1000c826 	beq	r2,zero,811222fc <__subdf3+0x8b8>
81121fdc:	2984b03a 	or	r2,r5,r6
81121fe0:	103ebb26 	beq	r2,zero,81121ad0 <__reset+0xfb101ad0>
81121fe4:	8989883a 	add	r4,r17,r6
81121fe8:	1945883a 	add	r2,r3,r5
81121fec:	2447803a 	cmpltu	r3,r4,r17
81121ff0:	1887883a 	add	r3,r3,r2
81121ff4:	1880202c 	andhi	r2,r3,128
81121ff8:	2023883a 	mov	r17,r4
81121ffc:	103f1626 	beq	r2,zero,81121c58 <__reset+0xfb101c58>
81122000:	00bfe034 	movhi	r2,65408
81122004:	10bfffc4 	addi	r2,r2,-1
81122008:	5021883a 	mov	r16,r10
8112200c:	1886703a 	and	r3,r3,r2
81122010:	003eaf06 	br	81121ad0 <__reset+0xfb101ad0>
81122014:	3825883a 	mov	r18,r7
81122018:	003f0f06 	br	81121c58 <__reset+0xfb101c58>
8112201c:	1c44b03a 	or	r2,r3,r17
81122020:	8000251e 	bne	r16,zero,811220b8 <__subdf3+0x674>
81122024:	1000661e 	bne	r2,zero,811221c0 <__subdf3+0x77c>
81122028:	2990b03a 	or	r8,r5,r6
8112202c:	40009626 	beq	r8,zero,81122288 <__subdf3+0x844>
81122030:	2807883a 	mov	r3,r5
81122034:	3023883a 	mov	r17,r6
81122038:	3825883a 	mov	r18,r7
8112203c:	003ea406 	br	81121ad0 <__reset+0xfb101ad0>
81122040:	127ff804 	addi	r9,r2,-32
81122044:	01000804 	movi	r4,32
81122048:	2a52d83a 	srl	r9,r5,r9
8112204c:	11008c26 	beq	r2,r4,81122280 <__subdf3+0x83c>
81122050:	01001004 	movi	r4,64
81122054:	2085c83a 	sub	r2,r4,r2
81122058:	2884983a 	sll	r2,r5,r2
8112205c:	118cb03a 	or	r6,r2,r6
81122060:	300cc03a 	cmpne	r6,r6,zero
81122064:	4992b03a 	or	r9,r9,r6
81122068:	0005883a 	mov	r2,zero
8112206c:	003f1206 	br	81121cb8 <__reset+0xfb101cb8>
81122070:	0101ffc4 	movi	r4,2047
81122074:	493f9c1e 	bne	r9,r4,81121ee8 <__reset+0xfb101ee8>
81122078:	2807883a 	mov	r3,r5
8112207c:	3023883a 	mov	r17,r6
81122080:	4821883a 	mov	r16,r9
81122084:	3825883a 	mov	r18,r7
81122088:	003e9106 	br	81121ad0 <__reset+0xfb101ad0>
8112208c:	80001f1e 	bne	r16,zero,8112210c <__subdf3+0x6c8>
81122090:	1c48b03a 	or	r4,r3,r17
81122094:	20005a26 	beq	r4,zero,81122200 <__subdf3+0x7bc>
81122098:	0084303a 	nor	r2,zero,r2
8112209c:	1000561e 	bne	r2,zero,811221f8 <__subdf3+0x7b4>
811220a0:	89a3883a 	add	r17,r17,r6
811220a4:	1945883a 	add	r2,r3,r5
811220a8:	898d803a 	cmpltu	r6,r17,r6
811220ac:	3087883a 	add	r3,r6,r2
811220b0:	4821883a 	mov	r16,r9
811220b4:	003f0506 	br	81121ccc <__reset+0xfb101ccc>
811220b8:	10002b1e 	bne	r2,zero,81122168 <__subdf3+0x724>
811220bc:	2984b03a 	or	r2,r5,r6
811220c0:	10008026 	beq	r2,zero,811222c4 <__subdf3+0x880>
811220c4:	2807883a 	mov	r3,r5
811220c8:	3023883a 	mov	r17,r6
811220cc:	3825883a 	mov	r18,r7
811220d0:	0401ffc4 	movi	r16,2047
811220d4:	003e7e06 	br	81121ad0 <__reset+0xfb101ad0>
811220d8:	3809883a 	mov	r4,r7
811220dc:	0011883a 	mov	r8,zero
811220e0:	0005883a 	mov	r2,zero
811220e4:	003ee306 	br	81121c74 <__reset+0xfb101c74>
811220e8:	1c62b03a 	or	r17,r3,r17
811220ec:	8822c03a 	cmpne	r17,r17,zero
811220f0:	0005883a 	mov	r2,zero
811220f4:	003f8906 	br	81121f1c <__reset+0xfb101f1c>
811220f8:	3809883a 	mov	r4,r7
811220fc:	4821883a 	mov	r16,r9
81122100:	0011883a 	mov	r8,zero
81122104:	0005883a 	mov	r2,zero
81122108:	003eda06 	br	81121c74 <__reset+0xfb101c74>
8112210c:	0101ffc4 	movi	r4,2047
81122110:	49003b26 	beq	r9,r4,81122200 <__subdf3+0x7bc>
81122114:	0085c83a 	sub	r2,zero,r2
81122118:	18c02034 	orhi	r3,r3,128
8112211c:	01000e04 	movi	r4,56
81122120:	20806e16 	blt	r4,r2,811222dc <__subdf3+0x898>
81122124:	010007c4 	movi	r4,31
81122128:	20807716 	blt	r4,r2,81122308 <__subdf3+0x8c4>
8112212c:	01000804 	movi	r4,32
81122130:	2089c83a 	sub	r4,r4,r2
81122134:	1914983a 	sll	r10,r3,r4
81122138:	8890d83a 	srl	r8,r17,r2
8112213c:	8908983a 	sll	r4,r17,r4
81122140:	1884d83a 	srl	r2,r3,r2
81122144:	5222b03a 	or	r17,r10,r8
81122148:	2006c03a 	cmpne	r3,r4,zero
8112214c:	88e2b03a 	or	r17,r17,r3
81122150:	89a3883a 	add	r17,r17,r6
81122154:	1145883a 	add	r2,r2,r5
81122158:	898d803a 	cmpltu	r6,r17,r6
8112215c:	3087883a 	add	r3,r6,r2
81122160:	4821883a 	mov	r16,r9
81122164:	003ed906 	br	81121ccc <__reset+0xfb101ccc>
81122168:	2984b03a 	or	r2,r5,r6
8112216c:	10004226 	beq	r2,zero,81122278 <__subdf3+0x834>
81122170:	1808d0fa 	srli	r4,r3,3
81122174:	8822d0fa 	srli	r17,r17,3
81122178:	1806977a 	slli	r3,r3,29
8112217c:	2080022c 	andhi	r2,r4,8
81122180:	1c62b03a 	or	r17,r3,r17
81122184:	10000826 	beq	r2,zero,811221a8 <__subdf3+0x764>
81122188:	2812d0fa 	srli	r9,r5,3
8112218c:	4880022c 	andhi	r2,r9,8
81122190:	1000051e 	bne	r2,zero,811221a8 <__subdf3+0x764>
81122194:	300cd0fa 	srli	r6,r6,3
81122198:	2804977a 	slli	r2,r5,29
8112219c:	4809883a 	mov	r4,r9
811221a0:	3825883a 	mov	r18,r7
811221a4:	11a2b03a 	or	r17,r2,r6
811221a8:	8806d77a 	srli	r3,r17,29
811221ac:	200890fa 	slli	r4,r4,3
811221b0:	882290fa 	slli	r17,r17,3
811221b4:	0401ffc4 	movi	r16,2047
811221b8:	1906b03a 	or	r3,r3,r4
811221bc:	003e4406 	br	81121ad0 <__reset+0xfb101ad0>
811221c0:	2984b03a 	or	r2,r5,r6
811221c4:	103e4226 	beq	r2,zero,81121ad0 <__reset+0xfb101ad0>
811221c8:	8989c83a 	sub	r4,r17,r6
811221cc:	8911803a 	cmpltu	r8,r17,r4
811221d0:	1945c83a 	sub	r2,r3,r5
811221d4:	1205c83a 	sub	r2,r2,r8
811221d8:	1200202c 	andhi	r8,r2,128
811221dc:	403e9a26 	beq	r8,zero,81121c48 <__reset+0xfb101c48>
811221e0:	3463c83a 	sub	r17,r6,r17
811221e4:	28c5c83a 	sub	r2,r5,r3
811221e8:	344d803a 	cmpltu	r6,r6,r17
811221ec:	1187c83a 	sub	r3,r2,r6
811221f0:	3825883a 	mov	r18,r7
811221f4:	003e3606 	br	81121ad0 <__reset+0xfb101ad0>
811221f8:	0101ffc4 	movi	r4,2047
811221fc:	493fc71e 	bne	r9,r4,8112211c <__reset+0xfb10211c>
81122200:	2807883a 	mov	r3,r5
81122204:	3023883a 	mov	r17,r6
81122208:	4821883a 	mov	r16,r9
8112220c:	003e3006 	br	81121ad0 <__reset+0xfb101ad0>
81122210:	10003626 	beq	r2,zero,811222ec <__subdf3+0x8a8>
81122214:	2984b03a 	or	r2,r5,r6
81122218:	10001726 	beq	r2,zero,81122278 <__subdf3+0x834>
8112221c:	1808d0fa 	srli	r4,r3,3
81122220:	8822d0fa 	srli	r17,r17,3
81122224:	1806977a 	slli	r3,r3,29
81122228:	2080022c 	andhi	r2,r4,8
8112222c:	1c62b03a 	or	r17,r3,r17
81122230:	10000726 	beq	r2,zero,81122250 <__subdf3+0x80c>
81122234:	2812d0fa 	srli	r9,r5,3
81122238:	4880022c 	andhi	r2,r9,8
8112223c:	1000041e 	bne	r2,zero,81122250 <__subdf3+0x80c>
81122240:	300cd0fa 	srli	r6,r6,3
81122244:	2804977a 	slli	r2,r5,29
81122248:	4809883a 	mov	r4,r9
8112224c:	11a2b03a 	or	r17,r2,r6
81122250:	8806d77a 	srli	r3,r17,29
81122254:	200890fa 	slli	r4,r4,3
81122258:	882290fa 	slli	r17,r17,3
8112225c:	3825883a 	mov	r18,r7
81122260:	1906b03a 	or	r3,r3,r4
81122264:	0401ffc4 	movi	r16,2047
81122268:	003e1906 	br	81121ad0 <__reset+0xfb101ad0>
8112226c:	000b883a 	mov	r5,zero
81122270:	0005883a 	mov	r2,zero
81122274:	003e2e06 	br	81121b30 <__reset+0xfb101b30>
81122278:	0401ffc4 	movi	r16,2047
8112227c:	003e1406 	br	81121ad0 <__reset+0xfb101ad0>
81122280:	0005883a 	mov	r2,zero
81122284:	003f7506 	br	8112205c <__reset+0xfb10205c>
81122288:	0005883a 	mov	r2,zero
8112228c:	0009883a 	mov	r4,zero
81122290:	003e7806 	br	81121c74 <__reset+0xfb101c74>
81122294:	123ff804 	addi	r8,r2,-32
81122298:	01000804 	movi	r4,32
8112229c:	1a10d83a 	srl	r8,r3,r8
811222a0:	11002526 	beq	r2,r4,81122338 <__subdf3+0x8f4>
811222a4:	01001004 	movi	r4,64
811222a8:	2085c83a 	sub	r2,r4,r2
811222ac:	1884983a 	sll	r2,r3,r2
811222b0:	1444b03a 	or	r2,r2,r17
811222b4:	1004c03a 	cmpne	r2,r2,zero
811222b8:	40a2b03a 	or	r17,r8,r2
811222bc:	0005883a 	mov	r2,zero
811222c0:	003f1606 	br	81121f1c <__reset+0xfb101f1c>
811222c4:	02000434 	movhi	r8,16
811222c8:	0009883a 	mov	r4,zero
811222cc:	423fffc4 	addi	r8,r8,-1
811222d0:	00bfffc4 	movi	r2,-1
811222d4:	0401ffc4 	movi	r16,2047
811222d8:	003e6606 	br	81121c74 <__reset+0xfb101c74>
811222dc:	1c62b03a 	or	r17,r3,r17
811222e0:	8822c03a 	cmpne	r17,r17,zero
811222e4:	0005883a 	mov	r2,zero
811222e8:	003f9906 	br	81122150 <__reset+0xfb102150>
811222ec:	2807883a 	mov	r3,r5
811222f0:	3023883a 	mov	r17,r6
811222f4:	0401ffc4 	movi	r16,2047
811222f8:	003df506 	br	81121ad0 <__reset+0xfb101ad0>
811222fc:	2807883a 	mov	r3,r5
81122300:	3023883a 	mov	r17,r6
81122304:	003df206 	br	81121ad0 <__reset+0xfb101ad0>
81122308:	123ff804 	addi	r8,r2,-32
8112230c:	01000804 	movi	r4,32
81122310:	1a10d83a 	srl	r8,r3,r8
81122314:	11000a26 	beq	r2,r4,81122340 <__subdf3+0x8fc>
81122318:	01001004 	movi	r4,64
8112231c:	2085c83a 	sub	r2,r4,r2
81122320:	1884983a 	sll	r2,r3,r2
81122324:	1444b03a 	or	r2,r2,r17
81122328:	1004c03a 	cmpne	r2,r2,zero
8112232c:	40a2b03a 	or	r17,r8,r2
81122330:	0005883a 	mov	r2,zero
81122334:	003f8606 	br	81122150 <__reset+0xfb102150>
81122338:	0005883a 	mov	r2,zero
8112233c:	003fdc06 	br	811222b0 <__reset+0xfb1022b0>
81122340:	0005883a 	mov	r2,zero
81122344:	003ff706 	br	81122324 <__reset+0xfb102324>

81122348 <__fixdfsi>:
81122348:	280cd53a 	srli	r6,r5,20
8112234c:	00c00434 	movhi	r3,16
81122350:	18ffffc4 	addi	r3,r3,-1
81122354:	3181ffcc 	andi	r6,r6,2047
81122358:	01c0ff84 	movi	r7,1022
8112235c:	28c6703a 	and	r3,r5,r3
81122360:	280ad7fa 	srli	r5,r5,31
81122364:	3980120e 	bge	r7,r6,811223b0 <__fixdfsi+0x68>
81122368:	00810744 	movi	r2,1053
8112236c:	11800c16 	blt	r2,r6,811223a0 <__fixdfsi+0x58>
81122370:	00810cc4 	movi	r2,1075
81122374:	1185c83a 	sub	r2,r2,r6
81122378:	01c007c4 	movi	r7,31
8112237c:	18c00434 	orhi	r3,r3,16
81122380:	38800d16 	blt	r7,r2,811223b8 <__fixdfsi+0x70>
81122384:	31befb44 	addi	r6,r6,-1043
81122388:	2084d83a 	srl	r2,r4,r2
8112238c:	1986983a 	sll	r3,r3,r6
81122390:	1884b03a 	or	r2,r3,r2
81122394:	28000726 	beq	r5,zero,811223b4 <__fixdfsi+0x6c>
81122398:	0085c83a 	sub	r2,zero,r2
8112239c:	f800283a 	ret
811223a0:	00a00034 	movhi	r2,32768
811223a4:	10bfffc4 	addi	r2,r2,-1
811223a8:	2885883a 	add	r2,r5,r2
811223ac:	f800283a 	ret
811223b0:	0005883a 	mov	r2,zero
811223b4:	f800283a 	ret
811223b8:	008104c4 	movi	r2,1043
811223bc:	1185c83a 	sub	r2,r2,r6
811223c0:	1884d83a 	srl	r2,r3,r2
811223c4:	003ff306 	br	81122394 <__reset+0xfb102394>

811223c8 <__floatsidf>:
811223c8:	defffd04 	addi	sp,sp,-12
811223cc:	de00012e 	bgeu	sp,et,811223d4 <__floatsidf+0xc>
811223d0:	003b68fa 	trap	3
811223d4:	dfc00215 	stw	ra,8(sp)
811223d8:	dc400115 	stw	r17,4(sp)
811223dc:	dc000015 	stw	r16,0(sp)
811223e0:	20002b26 	beq	r4,zero,81122490 <__floatsidf+0xc8>
811223e4:	2023883a 	mov	r17,r4
811223e8:	2020d7fa 	srli	r16,r4,31
811223ec:	20002d16 	blt	r4,zero,811224a4 <__floatsidf+0xdc>
811223f0:	8809883a 	mov	r4,r17
811223f4:	112276c0 	call	8112276c <__clzsi2>
811223f8:	01410784 	movi	r5,1054
811223fc:	288bc83a 	sub	r5,r5,r2
81122400:	01010cc4 	movi	r4,1075
81122404:	2149c83a 	sub	r4,r4,r5
81122408:	00c007c4 	movi	r3,31
8112240c:	1900160e 	bge	r3,r4,81122468 <__floatsidf+0xa0>
81122410:	00c104c4 	movi	r3,1043
81122414:	1947c83a 	sub	r3,r3,r5
81122418:	88c6983a 	sll	r3,r17,r3
8112241c:	00800434 	movhi	r2,16
81122420:	10bfffc4 	addi	r2,r2,-1
81122424:	1886703a 	and	r3,r3,r2
81122428:	2941ffcc 	andi	r5,r5,2047
8112242c:	800d883a 	mov	r6,r16
81122430:	0005883a 	mov	r2,zero
81122434:	280a953a 	slli	r5,r5,20
81122438:	31803fcc 	andi	r6,r6,255
8112243c:	01000434 	movhi	r4,16
81122440:	300c97fa 	slli	r6,r6,31
81122444:	213fffc4 	addi	r4,r4,-1
81122448:	1906703a 	and	r3,r3,r4
8112244c:	1946b03a 	or	r3,r3,r5
81122450:	1986b03a 	or	r3,r3,r6
81122454:	dfc00217 	ldw	ra,8(sp)
81122458:	dc400117 	ldw	r17,4(sp)
8112245c:	dc000017 	ldw	r16,0(sp)
81122460:	dec00304 	addi	sp,sp,12
81122464:	f800283a 	ret
81122468:	00c002c4 	movi	r3,11
8112246c:	1887c83a 	sub	r3,r3,r2
81122470:	88c6d83a 	srl	r3,r17,r3
81122474:	8904983a 	sll	r2,r17,r4
81122478:	01000434 	movhi	r4,16
8112247c:	213fffc4 	addi	r4,r4,-1
81122480:	2941ffcc 	andi	r5,r5,2047
81122484:	1906703a 	and	r3,r3,r4
81122488:	800d883a 	mov	r6,r16
8112248c:	003fe906 	br	81122434 <__reset+0xfb102434>
81122490:	000d883a 	mov	r6,zero
81122494:	000b883a 	mov	r5,zero
81122498:	0007883a 	mov	r3,zero
8112249c:	0005883a 	mov	r2,zero
811224a0:	003fe406 	br	81122434 <__reset+0xfb102434>
811224a4:	0123c83a 	sub	r17,zero,r4
811224a8:	003fd106 	br	811223f0 <__reset+0xfb1023f0>

811224ac <__extendsfdf2>:
811224ac:	200ad5fa 	srli	r5,r4,23
811224b0:	defffd04 	addi	sp,sp,-12
811224b4:	de00012e 	bgeu	sp,et,811224bc <__extendsfdf2+0x10>
811224b8:	003b68fa 	trap	3
811224bc:	29403fcc 	andi	r5,r5,255
811224c0:	dc400115 	stw	r17,4(sp)
811224c4:	29800044 	addi	r6,r5,1
811224c8:	04402034 	movhi	r17,128
811224cc:	dc000015 	stw	r16,0(sp)
811224d0:	8c7fffc4 	addi	r17,r17,-1
811224d4:	dfc00215 	stw	ra,8(sp)
811224d8:	31803fcc 	andi	r6,r6,255
811224dc:	00800044 	movi	r2,1
811224e0:	8922703a 	and	r17,r17,r4
811224e4:	2020d7fa 	srli	r16,r4,31
811224e8:	1180110e 	bge	r2,r6,81122530 <__extendsfdf2+0x84>
811224ec:	880cd0fa 	srli	r6,r17,3
811224f0:	8822977a 	slli	r17,r17,29
811224f4:	2940e004 	addi	r5,r5,896
811224f8:	2941ffcc 	andi	r5,r5,2047
811224fc:	2804953a 	slli	r2,r5,20
81122500:	01400434 	movhi	r5,16
81122504:	800697fa 	slli	r3,r16,31
81122508:	297fffc4 	addi	r5,r5,-1
8112250c:	314a703a 	and	r5,r6,r5
81122510:	288ab03a 	or	r5,r5,r2
81122514:	28c6b03a 	or	r3,r5,r3
81122518:	8805883a 	mov	r2,r17
8112251c:	dfc00217 	ldw	ra,8(sp)
81122520:	dc400117 	ldw	r17,4(sp)
81122524:	dc000017 	ldw	r16,0(sp)
81122528:	dec00304 	addi	sp,sp,12
8112252c:	f800283a 	ret
81122530:	2800111e 	bne	r5,zero,81122578 <__extendsfdf2+0xcc>
81122534:	88001c26 	beq	r17,zero,811225a8 <__extendsfdf2+0xfc>
81122538:	8809883a 	mov	r4,r17
8112253c:	112276c0 	call	8112276c <__clzsi2>
81122540:	00c00284 	movi	r3,10
81122544:	18801b16 	blt	r3,r2,811225b4 <__extendsfdf2+0x108>
81122548:	018002c4 	movi	r6,11
8112254c:	308dc83a 	sub	r6,r6,r2
81122550:	11000544 	addi	r4,r2,21
81122554:	8986d83a 	srl	r3,r17,r6
81122558:	8922983a 	sll	r17,r17,r4
8112255c:	0180e244 	movi	r6,905
81122560:	01400434 	movhi	r5,16
81122564:	3085c83a 	sub	r2,r6,r2
81122568:	297fffc4 	addi	r5,r5,-1
8112256c:	194c703a 	and	r6,r3,r5
81122570:	1141ffcc 	andi	r5,r2,2047
81122574:	003fe006 	br	811224f8 <__reset+0xfb1024f8>
81122578:	88000826 	beq	r17,zero,8112259c <__extendsfdf2+0xf0>
8112257c:	880cd0fa 	srli	r6,r17,3
81122580:	00800434 	movhi	r2,16
81122584:	10bfffc4 	addi	r2,r2,-1
81122588:	31800234 	orhi	r6,r6,8
8112258c:	8822977a 	slli	r17,r17,29
81122590:	308c703a 	and	r6,r6,r2
81122594:	0141ffc4 	movi	r5,2047
81122598:	003fd706 	br	811224f8 <__reset+0xfb1024f8>
8112259c:	0141ffc4 	movi	r5,2047
811225a0:	000d883a 	mov	r6,zero
811225a4:	003fd406 	br	811224f8 <__reset+0xfb1024f8>
811225a8:	000b883a 	mov	r5,zero
811225ac:	000d883a 	mov	r6,zero
811225b0:	003fd106 	br	811224f8 <__reset+0xfb1024f8>
811225b4:	11bffd44 	addi	r6,r2,-11
811225b8:	8986983a 	sll	r3,r17,r6
811225bc:	0023883a 	mov	r17,zero
811225c0:	003fe606 	br	8112255c <__reset+0xfb10255c>

811225c4 <__truncdfsf2>:
811225c4:	2810d53a 	srli	r8,r5,20
811225c8:	01c00434 	movhi	r7,16
811225cc:	39ffffc4 	addi	r7,r7,-1
811225d0:	29ce703a 	and	r7,r5,r7
811225d4:	4201ffcc 	andi	r8,r8,2047
811225d8:	380e90fa 	slli	r7,r7,3
811225dc:	200cd77a 	srli	r6,r4,29
811225e0:	42400044 	addi	r9,r8,1
811225e4:	4a41ffcc 	andi	r9,r9,2047
811225e8:	00c00044 	movi	r3,1
811225ec:	280ad7fa 	srli	r5,r5,31
811225f0:	31ceb03a 	or	r7,r6,r7
811225f4:	200490fa 	slli	r2,r4,3
811225f8:	1a40230e 	bge	r3,r9,81122688 <__truncdfsf2+0xc4>
811225fc:	40ff2004 	addi	r3,r8,-896
81122600:	01803f84 	movi	r6,254
81122604:	30c01516 	blt	r6,r3,8112265c <__truncdfsf2+0x98>
81122608:	00c0380e 	bge	zero,r3,811226ec <__truncdfsf2+0x128>
8112260c:	200c91ba 	slli	r6,r4,6
81122610:	380e90fa 	slli	r7,r7,3
81122614:	1004d77a 	srli	r2,r2,29
81122618:	300cc03a 	cmpne	r6,r6,zero
8112261c:	31ccb03a 	or	r6,r6,r7
81122620:	308cb03a 	or	r6,r6,r2
81122624:	308001cc 	andi	r2,r6,7
81122628:	10000426 	beq	r2,zero,8112263c <__truncdfsf2+0x78>
8112262c:	308003cc 	andi	r2,r6,15
81122630:	01000104 	movi	r4,4
81122634:	11000126 	beq	r2,r4,8112263c <__truncdfsf2+0x78>
81122638:	31800104 	addi	r6,r6,4
8112263c:	3081002c 	andhi	r2,r6,1024
81122640:	10001626 	beq	r2,zero,8112269c <__truncdfsf2+0xd8>
81122644:	18c00044 	addi	r3,r3,1
81122648:	00803fc4 	movi	r2,255
8112264c:	18800326 	beq	r3,r2,8112265c <__truncdfsf2+0x98>
81122650:	300c91ba 	slli	r6,r6,6
81122654:	300cd27a 	srli	r6,r6,9
81122658:	00000206 	br	81122664 <__truncdfsf2+0xa0>
8112265c:	00ffffc4 	movi	r3,-1
81122660:	000d883a 	mov	r6,zero
81122664:	18c03fcc 	andi	r3,r3,255
81122668:	180895fa 	slli	r4,r3,23
8112266c:	00c02034 	movhi	r3,128
81122670:	280a97fa 	slli	r5,r5,31
81122674:	18ffffc4 	addi	r3,r3,-1
81122678:	30c6703a 	and	r3,r6,r3
8112267c:	1906b03a 	or	r3,r3,r4
81122680:	1944b03a 	or	r2,r3,r5
81122684:	f800283a 	ret
81122688:	40000b1e 	bne	r8,zero,811226b8 <__truncdfsf2+0xf4>
8112268c:	388cb03a 	or	r6,r7,r2
81122690:	0007883a 	mov	r3,zero
81122694:	30000426 	beq	r6,zero,811226a8 <__truncdfsf2+0xe4>
81122698:	01800144 	movi	r6,5
8112269c:	00803fc4 	movi	r2,255
811226a0:	300cd0fa 	srli	r6,r6,3
811226a4:	18800a26 	beq	r3,r2,811226d0 <__truncdfsf2+0x10c>
811226a8:	00802034 	movhi	r2,128
811226ac:	10bfffc4 	addi	r2,r2,-1
811226b0:	308c703a 	and	r6,r6,r2
811226b4:	003feb06 	br	81122664 <__reset+0xfb102664>
811226b8:	3888b03a 	or	r4,r7,r2
811226bc:	203fe726 	beq	r4,zero,8112265c <__reset+0xfb10265c>
811226c0:	380c90fa 	slli	r6,r7,3
811226c4:	00c03fc4 	movi	r3,255
811226c8:	31808034 	orhi	r6,r6,512
811226cc:	003fd506 	br	81122624 <__reset+0xfb102624>
811226d0:	303fe226 	beq	r6,zero,8112265c <__reset+0xfb10265c>
811226d4:	00802034 	movhi	r2,128
811226d8:	31801034 	orhi	r6,r6,64
811226dc:	10bfffc4 	addi	r2,r2,-1
811226e0:	00ffffc4 	movi	r3,-1
811226e4:	308c703a 	and	r6,r6,r2
811226e8:	003fde06 	br	81122664 <__reset+0xfb102664>
811226ec:	013ffa44 	movi	r4,-23
811226f0:	19000e16 	blt	r3,r4,8112272c <__truncdfsf2+0x168>
811226f4:	01000784 	movi	r4,30
811226f8:	20c9c83a 	sub	r4,r4,r3
811226fc:	018007c4 	movi	r6,31
81122700:	39c02034 	orhi	r7,r7,128
81122704:	31000b16 	blt	r6,r4,81122734 <__truncdfsf2+0x170>
81122708:	423f2084 	addi	r8,r8,-894
8112270c:	120c983a 	sll	r6,r2,r8
81122710:	3a0e983a 	sll	r7,r7,r8
81122714:	1104d83a 	srl	r2,r2,r4
81122718:	300cc03a 	cmpne	r6,r6,zero
8112271c:	31ceb03a 	or	r7,r6,r7
81122720:	388cb03a 	or	r6,r7,r2
81122724:	0007883a 	mov	r3,zero
81122728:	003fbe06 	br	81122624 <__reset+0xfb102624>
8112272c:	0007883a 	mov	r3,zero
81122730:	003fd906 	br	81122698 <__reset+0xfb102698>
81122734:	01bfff84 	movi	r6,-2
81122738:	30cdc83a 	sub	r6,r6,r3
8112273c:	00c00804 	movi	r3,32
81122740:	398cd83a 	srl	r6,r7,r6
81122744:	20c00726 	beq	r4,r3,81122764 <__truncdfsf2+0x1a0>
81122748:	423f2884 	addi	r8,r8,-862
8112274c:	3a0e983a 	sll	r7,r7,r8
81122750:	3884b03a 	or	r2,r7,r2
81122754:	1004c03a 	cmpne	r2,r2,zero
81122758:	118cb03a 	or	r6,r2,r6
8112275c:	0007883a 	mov	r3,zero
81122760:	003fb006 	br	81122624 <__reset+0xfb102624>
81122764:	000f883a 	mov	r7,zero
81122768:	003ff906 	br	81122750 <__reset+0xfb102750>

8112276c <__clzsi2>:
8112276c:	00bfffd4 	movui	r2,65535
81122770:	11000536 	bltu	r2,r4,81122788 <__clzsi2+0x1c>
81122774:	00803fc4 	movi	r2,255
81122778:	11000f36 	bltu	r2,r4,811227b8 <__clzsi2+0x4c>
8112277c:	00800804 	movi	r2,32
81122780:	0007883a 	mov	r3,zero
81122784:	00000506 	br	8112279c <__clzsi2+0x30>
81122788:	00804034 	movhi	r2,256
8112278c:	10bfffc4 	addi	r2,r2,-1
81122790:	11000c2e 	bgeu	r2,r4,811227c4 <__clzsi2+0x58>
81122794:	00800204 	movi	r2,8
81122798:	00c00604 	movi	r3,24
8112279c:	20c8d83a 	srl	r4,r4,r3
811227a0:	00e04574 	movhi	r3,33045
811227a4:	18c63604 	addi	r3,r3,6360
811227a8:	1909883a 	add	r4,r3,r4
811227ac:	20c00003 	ldbu	r3,0(r4)
811227b0:	10c5c83a 	sub	r2,r2,r3
811227b4:	f800283a 	ret
811227b8:	00800604 	movi	r2,24
811227bc:	00c00204 	movi	r3,8
811227c0:	003ff606 	br	8112279c <__reset+0xfb10279c>
811227c4:	00800404 	movi	r2,16
811227c8:	1007883a 	mov	r3,r2
811227cc:	003ff306 	br	8112279c <__reset+0xfb10279c>

811227d0 <atoi>:
811227d0:	01800284 	movi	r6,10
811227d4:	000b883a 	mov	r5,zero
811227d8:	11247701 	jmpi	81124770 <strtol>

811227dc <_atoi_r>:
811227dc:	01c00284 	movi	r7,10
811227e0:	000d883a 	mov	r6,zero
811227e4:	11245301 	jmpi	81124530 <_strtol_r>

811227e8 <_fopen_r>:
811227e8:	defffa04 	addi	sp,sp,-24
811227ec:	3005883a 	mov	r2,r6
811227f0:	de00012e 	bgeu	sp,et,811227f8 <_fopen_r+0x10>
811227f4:	003b68fa 	trap	3
811227f8:	d80d883a 	mov	r6,sp
811227fc:	dcc00415 	stw	r19,16(sp)
81122800:	2827883a 	mov	r19,r5
81122804:	100b883a 	mov	r5,r2
81122808:	dc800315 	stw	r18,12(sp)
8112280c:	dfc00515 	stw	ra,20(sp)
81122810:	dc400215 	stw	r17,8(sp)
81122814:	dc000115 	stw	r16,4(sp)
81122818:	2025883a 	mov	r18,r4
8112281c:	112c7780 	call	8112c778 <__sflags>
81122820:	10002726 	beq	r2,zero,811228c0 <_fopen_r+0xd8>
81122824:	9009883a 	mov	r4,r18
81122828:	1023883a 	mov	r17,r2
8112282c:	112c5f00 	call	8112c5f0 <__sfp>
81122830:	1021883a 	mov	r16,r2
81122834:	10002226 	beq	r2,zero,811228c0 <_fopen_r+0xd8>
81122838:	d9800017 	ldw	r6,0(sp)
8112283c:	01c06d84 	movi	r7,438
81122840:	980b883a 	mov	r5,r19
81122844:	9009883a 	mov	r4,r18
81122848:	1123c540 	call	81123c54 <_open_r>
8112284c:	10001916 	blt	r2,zero,811228b4 <_fopen_r+0xcc>
81122850:	8080038d 	sth	r2,14(r16)
81122854:	00a044b4 	movhi	r2,33042
81122858:	1090ad04 	addi	r2,r2,17076
8112285c:	80800815 	stw	r2,32(r16)
81122860:	00a044b4 	movhi	r2,33042
81122864:	1090c604 	addi	r2,r2,17176
81122868:	80800915 	stw	r2,36(r16)
8112286c:	00a044b4 	movhi	r2,33042
81122870:	1090e704 	addi	r2,r2,17308
81122874:	80800a15 	stw	r2,40(r16)
81122878:	00a044b4 	movhi	r2,33042
8112287c:	10910004 	addi	r2,r2,17408
81122880:	8440030d 	sth	r17,12(r16)
81122884:	84000715 	stw	r16,28(r16)
81122888:	80800b15 	stw	r2,44(r16)
8112288c:	8c40400c 	andi	r17,r17,256
81122890:	88000d1e 	bne	r17,zero,811228c8 <_fopen_r+0xe0>
81122894:	8005883a 	mov	r2,r16
81122898:	dfc00517 	ldw	ra,20(sp)
8112289c:	dcc00417 	ldw	r19,16(sp)
811228a0:	dc800317 	ldw	r18,12(sp)
811228a4:	dc400217 	ldw	r17,8(sp)
811228a8:	dc000117 	ldw	r16,4(sp)
811228ac:	dec00604 	addi	sp,sp,24
811228b0:	f800283a 	ret
811228b4:	112c7380 	call	8112c738 <__sfp_lock_acquire>
811228b8:	8000030d 	sth	zero,12(r16)
811228bc:	112c73c0 	call	8112c73c <__sfp_lock_release>
811228c0:	0005883a 	mov	r2,zero
811228c4:	003ff406 	br	81122898 <__reset+0xfb102898>
811228c8:	01c00084 	movi	r7,2
811228cc:	000d883a 	mov	r6,zero
811228d0:	800b883a 	mov	r5,r16
811228d4:	9009883a 	mov	r4,r18
811228d8:	1122a080 	call	81122a08 <_fseek_r>
811228dc:	8005883a 	mov	r2,r16
811228e0:	003fed06 	br	81122898 <__reset+0xfb102898>

811228e4 <fopen>:
811228e4:	00a04574 	movhi	r2,33045
811228e8:	1090f104 	addi	r2,r2,17348
811228ec:	280d883a 	mov	r6,r5
811228f0:	200b883a 	mov	r5,r4
811228f4:	11000017 	ldw	r4,0(r2)
811228f8:	11227e81 	jmpi	811227e8 <_fopen_r>

811228fc <_fprintf_r>:
811228fc:	defffe04 	addi	sp,sp,-8
81122900:	2809883a 	mov	r4,r5
81122904:	300b883a 	mov	r5,r6
81122908:	de00012e 	bgeu	sp,et,81122910 <_fprintf_r+0x14>
8112290c:	003b68fa 	trap	3
81122910:	dfc00015 	stw	ra,0(sp)
81122914:	d9c00115 	stw	r7,4(sp)
81122918:	d9800104 	addi	r6,sp,4
8112291c:	1128b6c0 	call	81128b6c <__vfprintf_internal>
81122920:	dfc00017 	ldw	ra,0(sp)
81122924:	dec00204 	addi	sp,sp,8
81122928:	f800283a 	ret

8112292c <fprintf>:
8112292c:	defffd04 	addi	sp,sp,-12
81122930:	de00012e 	bgeu	sp,et,81122938 <fprintf+0xc>
81122934:	003b68fa 	trap	3
81122938:	dfc00015 	stw	ra,0(sp)
8112293c:	d9800115 	stw	r6,4(sp)
81122940:	d9c00215 	stw	r7,8(sp)
81122944:	d9800104 	addi	r6,sp,4
81122948:	1128b6c0 	call	81128b6c <__vfprintf_internal>
8112294c:	dfc00017 	ldw	ra,0(sp)
81122950:	dec00304 	addi	sp,sp,12
81122954:	f800283a 	ret

81122958 <_fputc_r>:
81122958:	defffc04 	addi	sp,sp,-16
8112295c:	de00012e 	bgeu	sp,et,81122964 <_fputc_r+0xc>
81122960:	003b68fa 	trap	3
81122964:	dc000215 	stw	r16,8(sp)
81122968:	dfc00315 	stw	ra,12(sp)
8112296c:	2021883a 	mov	r16,r4
81122970:	20000726 	beq	r4,zero,81122990 <_fputc_r+0x38>
81122974:	20800e17 	ldw	r2,56(r4)
81122978:	1000051e 	bne	r2,zero,81122990 <_fputc_r+0x38>
8112297c:	d9400015 	stw	r5,0(sp)
81122980:	d9800115 	stw	r6,4(sp)
81122984:	112c7280 	call	8112c728 <__sinit>
81122988:	d9800117 	ldw	r6,4(sp)
8112298c:	d9400017 	ldw	r5,0(sp)
81122990:	8009883a 	mov	r4,r16
81122994:	dfc00317 	ldw	ra,12(sp)
81122998:	dc000217 	ldw	r16,8(sp)
8112299c:	dec00404 	addi	sp,sp,16
811229a0:	1123cbc1 	jmpi	81123cbc <_putc_r>

811229a4 <fputc>:
811229a4:	00a04574 	movhi	r2,33045
811229a8:	defffc04 	addi	sp,sp,-16
811229ac:	1090f104 	addi	r2,r2,17348
811229b0:	de00012e 	bgeu	sp,et,811229b8 <fputc+0x14>
811229b4:	003b68fa 	trap	3
811229b8:	dc000115 	stw	r16,4(sp)
811229bc:	14000017 	ldw	r16,0(r2)
811229c0:	dc400215 	stw	r17,8(sp)
811229c4:	dfc00315 	stw	ra,12(sp)
811229c8:	2023883a 	mov	r17,r4
811229cc:	80000626 	beq	r16,zero,811229e8 <fputc+0x44>
811229d0:	80800e17 	ldw	r2,56(r16)
811229d4:	1000041e 	bne	r2,zero,811229e8 <fputc+0x44>
811229d8:	8009883a 	mov	r4,r16
811229dc:	d9400015 	stw	r5,0(sp)
811229e0:	112c7280 	call	8112c728 <__sinit>
811229e4:	d9400017 	ldw	r5,0(sp)
811229e8:	280d883a 	mov	r6,r5
811229ec:	8009883a 	mov	r4,r16
811229f0:	880b883a 	mov	r5,r17
811229f4:	dfc00317 	ldw	ra,12(sp)
811229f8:	dc400217 	ldw	r17,8(sp)
811229fc:	dc000117 	ldw	r16,4(sp)
81122a00:	dec00404 	addi	sp,sp,16
81122a04:	1123cbc1 	jmpi	81123cbc <_putc_r>

81122a08 <_fseek_r>:
81122a08:	1122a281 	jmpi	81122a28 <_fseeko_r>

81122a0c <fseek>:
81122a0c:	00a04574 	movhi	r2,33045
81122a10:	1090f104 	addi	r2,r2,17348
81122a14:	300f883a 	mov	r7,r6
81122a18:	280d883a 	mov	r6,r5
81122a1c:	200b883a 	mov	r5,r4
81122a20:	11000017 	ldw	r4,0(r2)
81122a24:	1122a281 	jmpi	81122a28 <_fseeko_r>

81122a28 <_fseeko_r>:
81122a28:	deffe804 	addi	sp,sp,-96
81122a2c:	de00012e 	bgeu	sp,et,81122a34 <_fseeko_r+0xc>
81122a30:	003b68fa 	trap	3
81122a34:	dd401415 	stw	r21,80(sp)
81122a38:	dc801115 	stw	r18,68(sp)
81122a3c:	dc401015 	stw	r17,64(sp)
81122a40:	dc000f15 	stw	r16,60(sp)
81122a44:	dfc01715 	stw	ra,92(sp)
81122a48:	ddc01615 	stw	r23,88(sp)
81122a4c:	dd801515 	stw	r22,84(sp)
81122a50:	dd001315 	stw	r20,76(sp)
81122a54:	dcc01215 	stw	r19,72(sp)
81122a58:	2023883a 	mov	r17,r4
81122a5c:	2821883a 	mov	r16,r5
81122a60:	302b883a 	mov	r21,r6
81122a64:	3825883a 	mov	r18,r7
81122a68:	20000226 	beq	r4,zero,81122a74 <_fseeko_r+0x4c>
81122a6c:	20800e17 	ldw	r2,56(r4)
81122a70:	10005a26 	beq	r2,zero,81122bdc <_fseeko_r+0x1b4>
81122a74:	8080030b 	ldhu	r2,12(r16)
81122a78:	00c04204 	movi	r3,264
81122a7c:	1080420c 	andi	r2,r2,264
81122a80:	10c05b26 	beq	r2,r3,81122bf0 <_fseeko_r+0x1c8>
81122a84:	85000a17 	ldw	r20,40(r16)
81122a88:	a000f626 	beq	r20,zero,81122e64 <_fseeko_r+0x43c>
81122a8c:	00800044 	movi	r2,1
81122a90:	90803e26 	beq	r18,r2,81122b8c <_fseeko_r+0x164>
81122a94:	00800084 	movi	r2,2
81122a98:	90801026 	beq	r18,r2,81122adc <_fseeko_r+0xb4>
81122a9c:	90000f26 	beq	r18,zero,81122adc <_fseeko_r+0xb4>
81122aa0:	00800584 	movi	r2,22
81122aa4:	88800015 	stw	r2,0(r17)
81122aa8:	04ffffc4 	movi	r19,-1
81122aac:	9805883a 	mov	r2,r19
81122ab0:	dfc01717 	ldw	ra,92(sp)
81122ab4:	ddc01617 	ldw	r23,88(sp)
81122ab8:	dd801517 	ldw	r22,84(sp)
81122abc:	dd401417 	ldw	r21,80(sp)
81122ac0:	dd001317 	ldw	r20,76(sp)
81122ac4:	dcc01217 	ldw	r19,72(sp)
81122ac8:	dc801117 	ldw	r18,68(sp)
81122acc:	dc401017 	ldw	r17,64(sp)
81122ad0:	dc000f17 	ldw	r16,60(sp)
81122ad4:	dec01804 	addi	sp,sp,96
81122ad8:	f800283a 	ret
81122adc:	80800417 	ldw	r2,16(r16)
81122ae0:	002f883a 	mov	r23,zero
81122ae4:	0027883a 	mov	r19,zero
81122ae8:	1000cb26 	beq	r2,zero,81122e18 <_fseeko_r+0x3f0>
81122aec:	8080030b 	ldhu	r2,12(r16)
81122af0:	10c2068c 	andi	r3,r2,2074
81122af4:	1800071e 	bne	r3,zero,81122b14 <_fseeko_r+0xec>
81122af8:	10c1000c 	andi	r3,r2,1024
81122afc:	1800451e 	bne	r3,zero,81122c14 <_fseeko_r+0x1ec>
81122b00:	00e044b4 	movhi	r3,33042
81122b04:	18d0e704 	addi	r3,r3,17308
81122b08:	a0c0b726 	beq	r20,r3,81122de8 <_fseeko_r+0x3c0>
81122b0c:	10820014 	ori	r2,r2,2048
81122b10:	8080030d 	sth	r2,12(r16)
81122b14:	800b883a 	mov	r5,r16
81122b18:	8809883a 	mov	r4,r17
81122b1c:	112c32c0 	call	8112c32c <_fflush_r>
81122b20:	1027883a 	mov	r19,r2
81122b24:	103fe01e 	bne	r2,zero,81122aa8 <__reset+0xfb102aa8>
81122b28:	81400717 	ldw	r5,28(r16)
81122b2c:	900f883a 	mov	r7,r18
81122b30:	a80d883a 	mov	r6,r21
81122b34:	8809883a 	mov	r4,r17
81122b38:	a03ee83a 	callr	r20
81122b3c:	00ffffc4 	movi	r3,-1
81122b40:	10ffd926 	beq	r2,r3,81122aa8 <__reset+0xfb102aa8>
81122b44:	81400c17 	ldw	r5,48(r16)
81122b48:	28000526 	beq	r5,zero,81122b60 <_fseeko_r+0x138>
81122b4c:	80801004 	addi	r2,r16,64
81122b50:	28800226 	beq	r5,r2,81122b5c <_fseeko_r+0x134>
81122b54:	8809883a 	mov	r4,r17
81122b58:	112cbc00 	call	8112cbc0 <_free_r>
81122b5c:	80000c15 	stw	zero,48(r16)
81122b60:	8080030b 	ldhu	r2,12(r16)
81122b64:	80c00417 	ldw	r3,16(r16)
81122b68:	80000115 	stw	zero,4(r16)
81122b6c:	10bdf7cc 	andi	r2,r2,63455
81122b70:	80c00015 	stw	r3,0(r16)
81122b74:	8080030d 	sth	r2,12(r16)
81122b78:	01800204 	movi	r6,8
81122b7c:	000b883a 	mov	r5,zero
81122b80:	81001704 	addi	r4,r16,92
81122b84:	1123b2c0 	call	81123b2c <memset>
81122b88:	003fc806 	br	81122aac <__reset+0xfb102aac>
81122b8c:	800b883a 	mov	r5,r16
81122b90:	8809883a 	mov	r4,r17
81122b94:	112c32c0 	call	8112c32c <_fflush_r>
81122b98:	8080030b 	ldhu	r2,12(r16)
81122b9c:	10c4000c 	andi	r3,r2,4096
81122ba0:	18008726 	beq	r3,zero,81122dc0 <_fseeko_r+0x398>
81122ba4:	84c01417 	ldw	r19,80(r16)
81122ba8:	10c0010c 	andi	r3,r2,4
81122bac:	1800431e 	bne	r3,zero,81122cbc <_fseeko_r+0x294>
81122bb0:	1080020c 	andi	r2,r2,8
81122bb4:	10008026 	beq	r2,zero,81122db8 <_fseeko_r+0x390>
81122bb8:	80c00017 	ldw	r3,0(r16)
81122bbc:	80800417 	ldw	r2,16(r16)
81122bc0:	18000226 	beq	r3,zero,81122bcc <_fseeko_r+0x1a4>
81122bc4:	1887c83a 	sub	r3,r3,r2
81122bc8:	98e7883a 	add	r19,r19,r3
81122bcc:	aceb883a 	add	r21,r21,r19
81122bd0:	05c00044 	movi	r23,1
81122bd4:	0025883a 	mov	r18,zero
81122bd8:	003fc306 	br	81122ae8 <__reset+0xfb102ae8>
81122bdc:	112c7280 	call	8112c728 <__sinit>
81122be0:	8080030b 	ldhu	r2,12(r16)
81122be4:	00c04204 	movi	r3,264
81122be8:	1080420c 	andi	r2,r2,264
81122bec:	10ffa51e 	bne	r2,r3,81122a84 <__reset+0xfb102a84>
81122bf0:	800b883a 	mov	r5,r16
81122bf4:	8809883a 	mov	r4,r17
81122bf8:	112c32c0 	call	8112c32c <_fflush_r>
81122bfc:	003fa106 	br	81122a84 <__reset+0xfb102a84>
81122c00:	8080030b 	ldhu	r2,12(r16)
81122c04:	00c10004 	movi	r3,1024
81122c08:	80c01315 	stw	r3,76(r16)
81122c0c:	10c4b03a 	or	r2,r2,r3
81122c10:	8080030d 	sth	r2,12(r16)
81122c14:	9000311e 	bne	r18,zero,81122cdc <_fseeko_r+0x2b4>
81122c18:	a82d883a 	mov	r22,r21
81122c1c:	b800371e 	bne	r23,zero,81122cfc <_fseeko_r+0x2d4>
81122c20:	8080030b 	ldhu	r2,12(r16)
81122c24:	1084000c 	andi	r2,r2,4096
81122c28:	10007f26 	beq	r2,zero,81122e28 <_fseeko_r+0x400>
81122c2c:	80801417 	ldw	r2,80(r16)
81122c30:	81800117 	ldw	r6,4(r16)
81122c34:	81400c17 	ldw	r5,48(r16)
81122c38:	11a7c83a 	sub	r19,r2,r6
81122c3c:	28008226 	beq	r5,zero,81122e48 <_fseeko_r+0x420>
81122c40:	81c00f17 	ldw	r7,60(r16)
81122c44:	99e7c83a 	sub	r19,r19,r7
81122c48:	81000e17 	ldw	r4,56(r16)
81122c4c:	80800417 	ldw	r2,16(r16)
81122c50:	99a7883a 	add	r19,r19,r6
81122c54:	2087c83a 	sub	r3,r4,r2
81122c58:	98e7c83a 	sub	r19,r19,r3
81122c5c:	38c7883a 	add	r3,r7,r3
81122c60:	b4c02b16 	blt	r22,r19,81122d10 <_fseeko_r+0x2e8>
81122c64:	98c9883a 	add	r4,r19,r3
81122c68:	b100292e 	bgeu	r22,r4,81122d10 <_fseeko_r+0x2e8>
81122c6c:	b4e7c83a 	sub	r19,r22,r19
81122c70:	14c5883a 	add	r2,r2,r19
81122c74:	1ce7c83a 	sub	r19,r3,r19
81122c78:	80800015 	stw	r2,0(r16)
81122c7c:	84c00115 	stw	r19,4(r16)
81122c80:	28000526 	beq	r5,zero,81122c98 <_fseeko_r+0x270>
81122c84:	80801004 	addi	r2,r16,64
81122c88:	28800226 	beq	r5,r2,81122c94 <_fseeko_r+0x26c>
81122c8c:	8809883a 	mov	r4,r17
81122c90:	112cbc00 	call	8112cbc0 <_free_r>
81122c94:	80000c15 	stw	zero,48(r16)
81122c98:	8080030b 	ldhu	r2,12(r16)
81122c9c:	01800204 	movi	r6,8
81122ca0:	000b883a 	mov	r5,zero
81122ca4:	10bff7cc 	andi	r2,r2,65503
81122ca8:	8080030d 	sth	r2,12(r16)
81122cac:	81001704 	addi	r4,r16,92
81122cb0:	1123b2c0 	call	81123b2c <memset>
81122cb4:	0027883a 	mov	r19,zero
81122cb8:	003f7c06 	br	81122aac <__reset+0xfb102aac>
81122cbc:	80c00117 	ldw	r3,4(r16)
81122cc0:	80800c17 	ldw	r2,48(r16)
81122cc4:	98e7c83a 	sub	r19,r19,r3
81122cc8:	10003b26 	beq	r2,zero,81122db8 <_fseeko_r+0x390>
81122ccc:	80c00f17 	ldw	r3,60(r16)
81122cd0:	80800417 	ldw	r2,16(r16)
81122cd4:	98e7c83a 	sub	r19,r19,r3
81122cd8:	003fbc06 	br	81122bcc <__reset+0xfb102bcc>
81122cdc:	8140038f 	ldh	r5,14(r16)
81122ce0:	d80d883a 	mov	r6,sp
81122ce4:	8809883a 	mov	r4,r17
81122ce8:	1122e900 	call	81122e90 <_fstat_r>
81122cec:	103f891e 	bne	r2,zero,81122b14 <__reset+0xfb102b14>
81122cf0:	dd800417 	ldw	r22,16(sp)
81122cf4:	adad883a 	add	r22,r21,r22
81122cf8:	b83fc926 	beq	r23,zero,81122c20 <__reset+0xfb102c20>
81122cfc:	81400c17 	ldw	r5,48(r16)
81122d00:	81800117 	ldw	r6,4(r16)
81122d04:	28005026 	beq	r5,zero,81122e48 <_fseeko_r+0x420>
81122d08:	81c00f17 	ldw	r7,60(r16)
81122d0c:	003fce06 	br	81122c48 <__reset+0xfb102c48>
81122d10:	84c01317 	ldw	r19,76(r16)
81122d14:	81400717 	ldw	r5,28(r16)
81122d18:	000f883a 	mov	r7,zero
81122d1c:	04e7c83a 	sub	r19,zero,r19
81122d20:	9da6703a 	and	r19,r19,r22
81122d24:	980d883a 	mov	r6,r19
81122d28:	8809883a 	mov	r4,r17
81122d2c:	a03ee83a 	callr	r20
81122d30:	00ffffc4 	movi	r3,-1
81122d34:	10ff7726 	beq	r2,r3,81122b14 <__reset+0xfb102b14>
81122d38:	80800417 	ldw	r2,16(r16)
81122d3c:	81400c17 	ldw	r5,48(r16)
81122d40:	80000115 	stw	zero,4(r16)
81122d44:	80800015 	stw	r2,0(r16)
81122d48:	28000526 	beq	r5,zero,81122d60 <_fseeko_r+0x338>
81122d4c:	80801004 	addi	r2,r16,64
81122d50:	28800226 	beq	r5,r2,81122d5c <_fseeko_r+0x334>
81122d54:	8809883a 	mov	r4,r17
81122d58:	112cbc00 	call	8112cbc0 <_free_r>
81122d5c:	80000c15 	stw	zero,48(r16)
81122d60:	8080030b 	ldhu	r2,12(r16)
81122d64:	b4e7c83a 	sub	r19,r22,r19
81122d68:	10bff7cc 	andi	r2,r2,65503
81122d6c:	8080030d 	sth	r2,12(r16)
81122d70:	98000b26 	beq	r19,zero,81122da0 <_fseeko_r+0x378>
81122d74:	800b883a 	mov	r5,r16
81122d78:	8809883a 	mov	r4,r17
81122d7c:	1123f2c0 	call	81123f2c <__srefill_r>
81122d80:	103f641e 	bne	r2,zero,81122b14 <__reset+0xfb102b14>
81122d84:	80800117 	ldw	r2,4(r16)
81122d88:	14ff6236 	bltu	r2,r19,81122b14 <__reset+0xfb102b14>
81122d8c:	80c00017 	ldw	r3,0(r16)
81122d90:	14c5c83a 	sub	r2,r2,r19
81122d94:	80800115 	stw	r2,4(r16)
81122d98:	1ce7883a 	add	r19,r3,r19
81122d9c:	84c00015 	stw	r19,0(r16)
81122da0:	01800204 	movi	r6,8
81122da4:	000b883a 	mov	r5,zero
81122da8:	81001704 	addi	r4,r16,92
81122dac:	1123b2c0 	call	81123b2c <memset>
81122db0:	0027883a 	mov	r19,zero
81122db4:	003f3d06 	br	81122aac <__reset+0xfb102aac>
81122db8:	80800417 	ldw	r2,16(r16)
81122dbc:	003f8306 	br	81122bcc <__reset+0xfb102bcc>
81122dc0:	81400717 	ldw	r5,28(r16)
81122dc4:	900f883a 	mov	r7,r18
81122dc8:	000d883a 	mov	r6,zero
81122dcc:	8809883a 	mov	r4,r17
81122dd0:	a03ee83a 	callr	r20
81122dd4:	1027883a 	mov	r19,r2
81122dd8:	00bfffc4 	movi	r2,-1
81122ddc:	98bf3226 	beq	r19,r2,81122aa8 <__reset+0xfb102aa8>
81122de0:	8080030b 	ldhu	r2,12(r16)
81122de4:	003f7006 	br	81122ba8 <__reset+0xfb102ba8>
81122de8:	8140038f 	ldh	r5,14(r16)
81122dec:	283f4716 	blt	r5,zero,81122b0c <__reset+0xfb102b0c>
81122df0:	d80d883a 	mov	r6,sp
81122df4:	8809883a 	mov	r4,r17
81122df8:	1122e900 	call	81122e90 <_fstat_r>
81122dfc:	1000041e 	bne	r2,zero,81122e10 <_fseeko_r+0x3e8>
81122e00:	d8800117 	ldw	r2,4(sp)
81122e04:	00e00014 	movui	r3,32768
81122e08:	10bc000c 	andi	r2,r2,61440
81122e0c:	10ff7c26 	beq	r2,r3,81122c00 <__reset+0xfb102c00>
81122e10:	8080030b 	ldhu	r2,12(r16)
81122e14:	003f3d06 	br	81122b0c <__reset+0xfb102b0c>
81122e18:	800b883a 	mov	r5,r16
81122e1c:	8809883a 	mov	r4,r17
81122e20:	11230040 	call	81123004 <__smakebuf_r>
81122e24:	003f3106 	br	81122aec <__reset+0xfb102aec>
81122e28:	81400717 	ldw	r5,28(r16)
81122e2c:	01c00044 	movi	r7,1
81122e30:	000d883a 	mov	r6,zero
81122e34:	8809883a 	mov	r4,r17
81122e38:	a03ee83a 	callr	r20
81122e3c:	00ffffc4 	movi	r3,-1
81122e40:	10ff7b1e 	bne	r2,r3,81122c30 <__reset+0xfb102c30>
81122e44:	003f3306 	br	81122b14 <__reset+0xfb102b14>
81122e48:	80c00017 	ldw	r3,0(r16)
81122e4c:	80800417 	ldw	r2,16(r16)
81122e50:	000b883a 	mov	r5,zero
81122e54:	1887c83a 	sub	r3,r3,r2
81122e58:	98e7c83a 	sub	r19,r19,r3
81122e5c:	30c7883a 	add	r3,r6,r3
81122e60:	003f7f06 	br	81122c60 <__reset+0xfb102c60>
81122e64:	00800744 	movi	r2,29
81122e68:	88800015 	stw	r2,0(r17)
81122e6c:	04ffffc4 	movi	r19,-1
81122e70:	003f0e06 	br	81122aac <__reset+0xfb102aac>

81122e74 <fseeko>:
81122e74:	00a04574 	movhi	r2,33045
81122e78:	1090f104 	addi	r2,r2,17348
81122e7c:	300f883a 	mov	r7,r6
81122e80:	280d883a 	mov	r6,r5
81122e84:	200b883a 	mov	r5,r4
81122e88:	11000017 	ldw	r4,0(r2)
81122e8c:	1122a281 	jmpi	81122a28 <_fseeko_r>

81122e90 <_fstat_r>:
81122e90:	defffd04 	addi	sp,sp,-12
81122e94:	de00012e 	bgeu	sp,et,81122e9c <_fstat_r+0xc>
81122e98:	003b68fa 	trap	3
81122e9c:	2805883a 	mov	r2,r5
81122ea0:	dc000015 	stw	r16,0(sp)
81122ea4:	04204574 	movhi	r16,33045
81122ea8:	dc400115 	stw	r17,4(sp)
81122eac:	84116404 	addi	r16,r16,17808
81122eb0:	2023883a 	mov	r17,r4
81122eb4:	300b883a 	mov	r5,r6
81122eb8:	1009883a 	mov	r4,r2
81122ebc:	dfc00215 	stw	ra,8(sp)
81122ec0:	80000015 	stw	zero,0(r16)
81122ec4:	11378400 	call	81137840 <fstat>
81122ec8:	00ffffc4 	movi	r3,-1
81122ecc:	10c00526 	beq	r2,r3,81122ee4 <_fstat_r+0x54>
81122ed0:	dfc00217 	ldw	ra,8(sp)
81122ed4:	dc400117 	ldw	r17,4(sp)
81122ed8:	dc000017 	ldw	r16,0(sp)
81122edc:	dec00304 	addi	sp,sp,12
81122ee0:	f800283a 	ret
81122ee4:	80c00017 	ldw	r3,0(r16)
81122ee8:	183ff926 	beq	r3,zero,81122ed0 <__reset+0xfb102ed0>
81122eec:	88c00015 	stw	r3,0(r17)
81122ef0:	003ff706 	br	81122ed0 <__reset+0xfb102ed0>

81122ef4 <_fwrite_r>:
81122ef4:	defff504 	addi	sp,sp,-44
81122ef8:	de00012e 	bgeu	sp,et,81122f00 <_fwrite_r+0xc>
81122efc:	003b68fa 	trap	3
81122f00:	dc800815 	stw	r18,32(sp)
81122f04:	39a5383a 	mul	r18,r7,r6
81122f08:	d8800304 	addi	r2,sp,12
81122f0c:	d8800015 	stw	r2,0(sp)
81122f10:	00800044 	movi	r2,1
81122f14:	dcc00915 	stw	r19,36(sp)
81122f18:	dc400715 	stw	r17,28(sp)
81122f1c:	dc000615 	stw	r16,24(sp)
81122f20:	d9400315 	stw	r5,12(sp)
81122f24:	dfc00a15 	stw	ra,40(sp)
81122f28:	dc800415 	stw	r18,16(sp)
81122f2c:	dc800215 	stw	r18,8(sp)
81122f30:	d8800115 	stw	r2,4(sp)
81122f34:	3027883a 	mov	r19,r6
81122f38:	3821883a 	mov	r16,r7
81122f3c:	2023883a 	mov	r17,r4
81122f40:	d9400b17 	ldw	r5,44(sp)
81122f44:	20000226 	beq	r4,zero,81122f50 <_fwrite_r+0x5c>
81122f48:	20800e17 	ldw	r2,56(r4)
81122f4c:	10001a26 	beq	r2,zero,81122fb8 <_fwrite_r+0xc4>
81122f50:	2880030b 	ldhu	r2,12(r5)
81122f54:	10c8000c 	andi	r3,r2,8192
81122f58:	1800061e 	bne	r3,zero,81122f74 <_fwrite_r+0x80>
81122f5c:	29001917 	ldw	r4,100(r5)
81122f60:	00f7ffc4 	movi	r3,-8193
81122f64:	10880014 	ori	r2,r2,8192
81122f68:	20c6703a 	and	r3,r4,r3
81122f6c:	2880030d 	sth	r2,12(r5)
81122f70:	28c01915 	stw	r3,100(r5)
81122f74:	d80d883a 	mov	r6,sp
81122f78:	8809883a 	mov	r4,r17
81122f7c:	112ced80 	call	8112ced8 <__sfvwrite_r>
81122f80:	10000b26 	beq	r2,zero,81122fb0 <_fwrite_r+0xbc>
81122f84:	d9000217 	ldw	r4,8(sp)
81122f88:	980b883a 	mov	r5,r19
81122f8c:	9109c83a 	sub	r4,r18,r4
81122f90:	1135ecc0 	call	81135ecc <__udivsi3>
81122f94:	dfc00a17 	ldw	ra,40(sp)
81122f98:	dcc00917 	ldw	r19,36(sp)
81122f9c:	dc800817 	ldw	r18,32(sp)
81122fa0:	dc400717 	ldw	r17,28(sp)
81122fa4:	dc000617 	ldw	r16,24(sp)
81122fa8:	dec00b04 	addi	sp,sp,44
81122fac:	f800283a 	ret
81122fb0:	8005883a 	mov	r2,r16
81122fb4:	003ff706 	br	81122f94 <__reset+0xfb102f94>
81122fb8:	d9400515 	stw	r5,20(sp)
81122fbc:	112c7280 	call	8112c728 <__sinit>
81122fc0:	d9400517 	ldw	r5,20(sp)
81122fc4:	003fe206 	br	81122f50 <__reset+0xfb102f50>

81122fc8 <fwrite>:
81122fc8:	defffe04 	addi	sp,sp,-8
81122fcc:	00a04574 	movhi	r2,33045
81122fd0:	de00012e 	bgeu	sp,et,81122fd8 <fwrite+0x10>
81122fd4:	003b68fa 	trap	3
81122fd8:	1090f104 	addi	r2,r2,17348
81122fdc:	d9c00015 	stw	r7,0(sp)
81122fe0:	300f883a 	mov	r7,r6
81122fe4:	280d883a 	mov	r6,r5
81122fe8:	200b883a 	mov	r5,r4
81122fec:	11000017 	ldw	r4,0(r2)
81122ff0:	dfc00115 	stw	ra,4(sp)
81122ff4:	1122ef40 	call	81122ef4 <_fwrite_r>
81122ff8:	dfc00117 	ldw	ra,4(sp)
81122ffc:	dec00204 	addi	sp,sp,8
81123000:	f800283a 	ret

81123004 <__smakebuf_r>:
81123004:	2880030b 	ldhu	r2,12(r5)
81123008:	10c0008c 	andi	r3,r2,2
8112300c:	1800431e 	bne	r3,zero,8112311c <__smakebuf_r+0x118>
81123010:	deffec04 	addi	sp,sp,-80
81123014:	de00012e 	bgeu	sp,et,8112301c <__smakebuf_r+0x18>
81123018:	003b68fa 	trap	3
8112301c:	dc000f15 	stw	r16,60(sp)
81123020:	2821883a 	mov	r16,r5
81123024:	2940038f 	ldh	r5,14(r5)
81123028:	dc401015 	stw	r17,64(sp)
8112302c:	dfc01315 	stw	ra,76(sp)
81123030:	dcc01215 	stw	r19,72(sp)
81123034:	dc801115 	stw	r18,68(sp)
81123038:	2023883a 	mov	r17,r4
8112303c:	28001c16 	blt	r5,zero,811230b0 <__smakebuf_r+0xac>
81123040:	d80d883a 	mov	r6,sp
81123044:	1122e900 	call	81122e90 <_fstat_r>
81123048:	10001816 	blt	r2,zero,811230ac <__smakebuf_r+0xa8>
8112304c:	d8800117 	ldw	r2,4(sp)
81123050:	00e00014 	movui	r3,32768
81123054:	10bc000c 	andi	r2,r2,61440
81123058:	14c80020 	cmpeqi	r19,r2,8192
8112305c:	10c03726 	beq	r2,r3,8112313c <__smakebuf_r+0x138>
81123060:	80c0030b 	ldhu	r3,12(r16)
81123064:	18c20014 	ori	r3,r3,2048
81123068:	80c0030d 	sth	r3,12(r16)
8112306c:	00c80004 	movi	r3,8192
81123070:	10c0521e 	bne	r2,r3,811231bc <__smakebuf_r+0x1b8>
81123074:	8140038f 	ldh	r5,14(r16)
81123078:	8809883a 	mov	r4,r17
8112307c:	112d5340 	call	8112d534 <_isatty_r>
81123080:	10004c26 	beq	r2,zero,811231b4 <__smakebuf_r+0x1b0>
81123084:	8080030b 	ldhu	r2,12(r16)
81123088:	80c010c4 	addi	r3,r16,67
8112308c:	80c00015 	stw	r3,0(r16)
81123090:	10800054 	ori	r2,r2,1
81123094:	8080030d 	sth	r2,12(r16)
81123098:	00800044 	movi	r2,1
8112309c:	80c00415 	stw	r3,16(r16)
811230a0:	80800515 	stw	r2,20(r16)
811230a4:	04810004 	movi	r18,1024
811230a8:	00000706 	br	811230c8 <__smakebuf_r+0xc4>
811230ac:	8080030b 	ldhu	r2,12(r16)
811230b0:	10c0200c 	andi	r3,r2,128
811230b4:	18001f1e 	bne	r3,zero,81123134 <__smakebuf_r+0x130>
811230b8:	04810004 	movi	r18,1024
811230bc:	10820014 	ori	r2,r2,2048
811230c0:	8080030d 	sth	r2,12(r16)
811230c4:	0027883a 	mov	r19,zero
811230c8:	900b883a 	mov	r5,r18
811230cc:	8809883a 	mov	r4,r17
811230d0:	11231c80 	call	811231c8 <_malloc_r>
811230d4:	10002c26 	beq	r2,zero,81123188 <__smakebuf_r+0x184>
811230d8:	80c0030b 	ldhu	r3,12(r16)
811230dc:	012044f4 	movhi	r4,33043
811230e0:	2130f204 	addi	r4,r4,-15416
811230e4:	89000f15 	stw	r4,60(r17)
811230e8:	18c02014 	ori	r3,r3,128
811230ec:	80c0030d 	sth	r3,12(r16)
811230f0:	80800015 	stw	r2,0(r16)
811230f4:	80800415 	stw	r2,16(r16)
811230f8:	84800515 	stw	r18,20(r16)
811230fc:	98001a1e 	bne	r19,zero,81123168 <__smakebuf_r+0x164>
81123100:	dfc01317 	ldw	ra,76(sp)
81123104:	dcc01217 	ldw	r19,72(sp)
81123108:	dc801117 	ldw	r18,68(sp)
8112310c:	dc401017 	ldw	r17,64(sp)
81123110:	dc000f17 	ldw	r16,60(sp)
81123114:	dec01404 	addi	sp,sp,80
81123118:	f800283a 	ret
8112311c:	288010c4 	addi	r2,r5,67
81123120:	28800015 	stw	r2,0(r5)
81123124:	28800415 	stw	r2,16(r5)
81123128:	00800044 	movi	r2,1
8112312c:	28800515 	stw	r2,20(r5)
81123130:	f800283a 	ret
81123134:	04801004 	movi	r18,64
81123138:	003fe006 	br	811230bc <__reset+0xfb1030bc>
8112313c:	81000a17 	ldw	r4,40(r16)
81123140:	00e044b4 	movhi	r3,33042
81123144:	18d0e704 	addi	r3,r3,17308
81123148:	20ffc51e 	bne	r4,r3,81123060 <__reset+0xfb103060>
8112314c:	8080030b 	ldhu	r2,12(r16)
81123150:	04810004 	movi	r18,1024
81123154:	84801315 	stw	r18,76(r16)
81123158:	1484b03a 	or	r2,r2,r18
8112315c:	8080030d 	sth	r2,12(r16)
81123160:	0027883a 	mov	r19,zero
81123164:	003fd806 	br	811230c8 <__reset+0xfb1030c8>
81123168:	8140038f 	ldh	r5,14(r16)
8112316c:	8809883a 	mov	r4,r17
81123170:	112d5340 	call	8112d534 <_isatty_r>
81123174:	103fe226 	beq	r2,zero,81123100 <__reset+0xfb103100>
81123178:	8080030b 	ldhu	r2,12(r16)
8112317c:	10800054 	ori	r2,r2,1
81123180:	8080030d 	sth	r2,12(r16)
81123184:	003fde06 	br	81123100 <__reset+0xfb103100>
81123188:	8080030b 	ldhu	r2,12(r16)
8112318c:	10c0800c 	andi	r3,r2,512
81123190:	183fdb1e 	bne	r3,zero,81123100 <__reset+0xfb103100>
81123194:	10800094 	ori	r2,r2,2
81123198:	80c010c4 	addi	r3,r16,67
8112319c:	8080030d 	sth	r2,12(r16)
811231a0:	00800044 	movi	r2,1
811231a4:	80c00015 	stw	r3,0(r16)
811231a8:	80c00415 	stw	r3,16(r16)
811231ac:	80800515 	stw	r2,20(r16)
811231b0:	003fd306 	br	81123100 <__reset+0xfb103100>
811231b4:	04810004 	movi	r18,1024
811231b8:	003fc306 	br	811230c8 <__reset+0xfb1030c8>
811231bc:	0027883a 	mov	r19,zero
811231c0:	04810004 	movi	r18,1024
811231c4:	003fc006 	br	811230c8 <__reset+0xfb1030c8>

811231c8 <_malloc_r>:
811231c8:	defff504 	addi	sp,sp,-44
811231cc:	de00012e 	bgeu	sp,et,811231d4 <_malloc_r+0xc>
811231d0:	003b68fa 	trap	3
811231d4:	288002c4 	addi	r2,r5,11
811231d8:	dc800315 	stw	r18,12(sp)
811231dc:	dfc00a15 	stw	ra,40(sp)
811231e0:	df000915 	stw	fp,36(sp)
811231e4:	ddc00815 	stw	r23,32(sp)
811231e8:	dd800715 	stw	r22,28(sp)
811231ec:	dd400615 	stw	r21,24(sp)
811231f0:	dd000515 	stw	r20,20(sp)
811231f4:	dcc00415 	stw	r19,16(sp)
811231f8:	dc400215 	stw	r17,8(sp)
811231fc:	dc000115 	stw	r16,4(sp)
81123200:	00c00584 	movi	r3,22
81123204:	2025883a 	mov	r18,r4
81123208:	18807f2e 	bgeu	r3,r2,81123408 <_malloc_r+0x240>
8112320c:	047ffe04 	movi	r17,-8
81123210:	1462703a 	and	r17,r2,r17
81123214:	8800a316 	blt	r17,zero,811234a4 <_malloc_r+0x2dc>
81123218:	8940a236 	bltu	r17,r5,811234a4 <_malloc_r+0x2dc>
8112321c:	11393880 	call	81139388 <__malloc_lock>
81123220:	00807dc4 	movi	r2,503
81123224:	1441e92e 	bgeu	r2,r17,811239cc <_malloc_r+0x804>
81123228:	8804d27a 	srli	r2,r17,9
8112322c:	1000a126 	beq	r2,zero,811234b4 <_malloc_r+0x2ec>
81123230:	00c00104 	movi	r3,4
81123234:	18811e36 	bltu	r3,r2,811236b0 <_malloc_r+0x4e8>
81123238:	8804d1ba 	srli	r2,r17,6
8112323c:	12000e44 	addi	r8,r2,57
81123240:	11c00e04 	addi	r7,r2,56
81123244:	4209883a 	add	r4,r8,r8
81123248:	04e04574 	movhi	r19,33045
8112324c:	2109883a 	add	r4,r4,r4
81123250:	9ccaaf04 	addi	r19,r19,10940
81123254:	2109883a 	add	r4,r4,r4
81123258:	9909883a 	add	r4,r19,r4
8112325c:	24000117 	ldw	r16,4(r4)
81123260:	213ffe04 	addi	r4,r4,-8
81123264:	24009726 	beq	r4,r16,811234c4 <_malloc_r+0x2fc>
81123268:	80800117 	ldw	r2,4(r16)
8112326c:	01bfff04 	movi	r6,-4
81123270:	014003c4 	movi	r5,15
81123274:	1184703a 	and	r2,r2,r6
81123278:	1447c83a 	sub	r3,r2,r17
8112327c:	28c00716 	blt	r5,r3,8112329c <_malloc_r+0xd4>
81123280:	1800920e 	bge	r3,zero,811234cc <_malloc_r+0x304>
81123284:	84000317 	ldw	r16,12(r16)
81123288:	24008e26 	beq	r4,r16,811234c4 <_malloc_r+0x2fc>
8112328c:	80800117 	ldw	r2,4(r16)
81123290:	1184703a 	and	r2,r2,r6
81123294:	1447c83a 	sub	r3,r2,r17
81123298:	28fff90e 	bge	r5,r3,81123280 <__reset+0xfb103280>
8112329c:	3809883a 	mov	r4,r7
811232a0:	01a04574 	movhi	r6,33045
811232a4:	9c000417 	ldw	r16,16(r19)
811232a8:	318aaf04 	addi	r6,r6,10940
811232ac:	32000204 	addi	r8,r6,8
811232b0:	82013426 	beq	r16,r8,81123784 <_malloc_r+0x5bc>
811232b4:	80c00117 	ldw	r3,4(r16)
811232b8:	00bfff04 	movi	r2,-4
811232bc:	188e703a 	and	r7,r3,r2
811232c0:	3c45c83a 	sub	r2,r7,r17
811232c4:	00c003c4 	movi	r3,15
811232c8:	18811f16 	blt	r3,r2,81123748 <_malloc_r+0x580>
811232cc:	32000515 	stw	r8,20(r6)
811232d0:	32000415 	stw	r8,16(r6)
811232d4:	10007f0e 	bge	r2,zero,811234d4 <_malloc_r+0x30c>
811232d8:	00807fc4 	movi	r2,511
811232dc:	11c0fd36 	bltu	r2,r7,811236d4 <_malloc_r+0x50c>
811232e0:	3806d0fa 	srli	r3,r7,3
811232e4:	01c00044 	movi	r7,1
811232e8:	30800117 	ldw	r2,4(r6)
811232ec:	19400044 	addi	r5,r3,1
811232f0:	294b883a 	add	r5,r5,r5
811232f4:	1807d0ba 	srai	r3,r3,2
811232f8:	294b883a 	add	r5,r5,r5
811232fc:	294b883a 	add	r5,r5,r5
81123300:	298b883a 	add	r5,r5,r6
81123304:	38c6983a 	sll	r3,r7,r3
81123308:	29c00017 	ldw	r7,0(r5)
8112330c:	2a7ffe04 	addi	r9,r5,-8
81123310:	1886b03a 	or	r3,r3,r2
81123314:	82400315 	stw	r9,12(r16)
81123318:	81c00215 	stw	r7,8(r16)
8112331c:	30c00115 	stw	r3,4(r6)
81123320:	2c000015 	stw	r16,0(r5)
81123324:	3c000315 	stw	r16,12(r7)
81123328:	2005d0ba 	srai	r2,r4,2
8112332c:	01400044 	movi	r5,1
81123330:	288a983a 	sll	r5,r5,r2
81123334:	19406f36 	bltu	r3,r5,811234f4 <_malloc_r+0x32c>
81123338:	28c4703a 	and	r2,r5,r3
8112333c:	10000a1e 	bne	r2,zero,81123368 <_malloc_r+0x1a0>
81123340:	00bfff04 	movi	r2,-4
81123344:	294b883a 	add	r5,r5,r5
81123348:	2088703a 	and	r4,r4,r2
8112334c:	28c4703a 	and	r2,r5,r3
81123350:	21000104 	addi	r4,r4,4
81123354:	1000041e 	bne	r2,zero,81123368 <_malloc_r+0x1a0>
81123358:	294b883a 	add	r5,r5,r5
8112335c:	28c4703a 	and	r2,r5,r3
81123360:	21000104 	addi	r4,r4,4
81123364:	103ffc26 	beq	r2,zero,81123358 <__reset+0xfb103358>
81123368:	02bfff04 	movi	r10,-4
8112336c:	024003c4 	movi	r9,15
81123370:	21800044 	addi	r6,r4,1
81123374:	318d883a 	add	r6,r6,r6
81123378:	318d883a 	add	r6,r6,r6
8112337c:	318d883a 	add	r6,r6,r6
81123380:	998d883a 	add	r6,r19,r6
81123384:	333ffe04 	addi	r12,r6,-8
81123388:	2017883a 	mov	r11,r4
8112338c:	31800104 	addi	r6,r6,4
81123390:	34000017 	ldw	r16,0(r6)
81123394:	31fffd04 	addi	r7,r6,-12
81123398:	81c0041e 	bne	r16,r7,811233ac <_malloc_r+0x1e4>
8112339c:	0000fb06 	br	8112378c <_malloc_r+0x5c4>
811233a0:	1801030e 	bge	r3,zero,811237b0 <_malloc_r+0x5e8>
811233a4:	84000317 	ldw	r16,12(r16)
811233a8:	81c0f826 	beq	r16,r7,8112378c <_malloc_r+0x5c4>
811233ac:	80800117 	ldw	r2,4(r16)
811233b0:	1284703a 	and	r2,r2,r10
811233b4:	1447c83a 	sub	r3,r2,r17
811233b8:	48fff90e 	bge	r9,r3,811233a0 <__reset+0xfb1033a0>
811233bc:	80800317 	ldw	r2,12(r16)
811233c0:	81000217 	ldw	r4,8(r16)
811233c4:	89400054 	ori	r5,r17,1
811233c8:	81400115 	stw	r5,4(r16)
811233cc:	20800315 	stw	r2,12(r4)
811233d0:	11000215 	stw	r4,8(r2)
811233d4:	8463883a 	add	r17,r16,r17
811233d8:	9c400515 	stw	r17,20(r19)
811233dc:	9c400415 	stw	r17,16(r19)
811233e0:	18800054 	ori	r2,r3,1
811233e4:	88800115 	stw	r2,4(r17)
811233e8:	8a000315 	stw	r8,12(r17)
811233ec:	8a000215 	stw	r8,8(r17)
811233f0:	88e3883a 	add	r17,r17,r3
811233f4:	88c00015 	stw	r3,0(r17)
811233f8:	9009883a 	mov	r4,r18
811233fc:	11394b00 	call	811394b0 <__malloc_unlock>
81123400:	80800204 	addi	r2,r16,8
81123404:	00001b06 	br	81123474 <_malloc_r+0x2ac>
81123408:	04400404 	movi	r17,16
8112340c:	89402536 	bltu	r17,r5,811234a4 <_malloc_r+0x2dc>
81123410:	11393880 	call	81139388 <__malloc_lock>
81123414:	00800184 	movi	r2,6
81123418:	01000084 	movi	r4,2
8112341c:	04e04574 	movhi	r19,33045
81123420:	1085883a 	add	r2,r2,r2
81123424:	9ccaaf04 	addi	r19,r19,10940
81123428:	1085883a 	add	r2,r2,r2
8112342c:	9885883a 	add	r2,r19,r2
81123430:	14000117 	ldw	r16,4(r2)
81123434:	10fffe04 	addi	r3,r2,-8
81123438:	80c0d926 	beq	r16,r3,811237a0 <_malloc_r+0x5d8>
8112343c:	80c00117 	ldw	r3,4(r16)
81123440:	81000317 	ldw	r4,12(r16)
81123444:	00bfff04 	movi	r2,-4
81123448:	1884703a 	and	r2,r3,r2
8112344c:	81400217 	ldw	r5,8(r16)
81123450:	8085883a 	add	r2,r16,r2
81123454:	10c00117 	ldw	r3,4(r2)
81123458:	29000315 	stw	r4,12(r5)
8112345c:	21400215 	stw	r5,8(r4)
81123460:	18c00054 	ori	r3,r3,1
81123464:	10c00115 	stw	r3,4(r2)
81123468:	9009883a 	mov	r4,r18
8112346c:	11394b00 	call	811394b0 <__malloc_unlock>
81123470:	80800204 	addi	r2,r16,8
81123474:	dfc00a17 	ldw	ra,40(sp)
81123478:	df000917 	ldw	fp,36(sp)
8112347c:	ddc00817 	ldw	r23,32(sp)
81123480:	dd800717 	ldw	r22,28(sp)
81123484:	dd400617 	ldw	r21,24(sp)
81123488:	dd000517 	ldw	r20,20(sp)
8112348c:	dcc00417 	ldw	r19,16(sp)
81123490:	dc800317 	ldw	r18,12(sp)
81123494:	dc400217 	ldw	r17,8(sp)
81123498:	dc000117 	ldw	r16,4(sp)
8112349c:	dec00b04 	addi	sp,sp,44
811234a0:	f800283a 	ret
811234a4:	00800304 	movi	r2,12
811234a8:	90800015 	stw	r2,0(r18)
811234ac:	0005883a 	mov	r2,zero
811234b0:	003ff006 	br	81123474 <__reset+0xfb103474>
811234b4:	01002004 	movi	r4,128
811234b8:	02001004 	movi	r8,64
811234bc:	01c00fc4 	movi	r7,63
811234c0:	003f6106 	br	81123248 <__reset+0xfb103248>
811234c4:	4009883a 	mov	r4,r8
811234c8:	003f7506 	br	811232a0 <__reset+0xfb1032a0>
811234cc:	81000317 	ldw	r4,12(r16)
811234d0:	003fde06 	br	8112344c <__reset+0xfb10344c>
811234d4:	81c5883a 	add	r2,r16,r7
811234d8:	11400117 	ldw	r5,4(r2)
811234dc:	9009883a 	mov	r4,r18
811234e0:	29400054 	ori	r5,r5,1
811234e4:	11400115 	stw	r5,4(r2)
811234e8:	11394b00 	call	811394b0 <__malloc_unlock>
811234ec:	80800204 	addi	r2,r16,8
811234f0:	003fe006 	br	81123474 <__reset+0xfb103474>
811234f4:	9c000217 	ldw	r16,8(r19)
811234f8:	00bfff04 	movi	r2,-4
811234fc:	85800117 	ldw	r22,4(r16)
81123500:	b0ac703a 	and	r22,r22,r2
81123504:	b4400336 	bltu	r22,r17,81123514 <_malloc_r+0x34c>
81123508:	b445c83a 	sub	r2,r22,r17
8112350c:	00c003c4 	movi	r3,15
81123510:	18805d16 	blt	r3,r2,81123688 <_malloc_r+0x4c0>
81123514:	05e04574 	movhi	r23,33045
81123518:	00a04574 	movhi	r2,33045
8112351c:	10916704 	addi	r2,r2,17820
81123520:	bdd0f204 	addi	r23,r23,17352
81123524:	15400017 	ldw	r21,0(r2)
81123528:	b8c00017 	ldw	r3,0(r23)
8112352c:	00bfffc4 	movi	r2,-1
81123530:	858d883a 	add	r6,r16,r22
81123534:	8d6b883a 	add	r21,r17,r21
81123538:	1880ea26 	beq	r3,r2,811238e4 <_malloc_r+0x71c>
8112353c:	ad4403c4 	addi	r21,r21,4111
81123540:	00bc0004 	movi	r2,-4096
81123544:	a8aa703a 	and	r21,r21,r2
81123548:	a80b883a 	mov	r5,r21
8112354c:	9009883a 	mov	r4,r18
81123550:	d9800015 	stw	r6,0(sp)
81123554:	11241080 	call	81124108 <_sbrk_r>
81123558:	1029883a 	mov	r20,r2
8112355c:	00bfffc4 	movi	r2,-1
81123560:	d9800017 	ldw	r6,0(sp)
81123564:	a080e826 	beq	r20,r2,81123908 <_malloc_r+0x740>
81123568:	a180a636 	bltu	r20,r6,81123804 <_malloc_r+0x63c>
8112356c:	07204574 	movhi	fp,33045
81123570:	e711f404 	addi	fp,fp,18384
81123574:	e0800017 	ldw	r2,0(fp)
81123578:	a887883a 	add	r3,r21,r2
8112357c:	e0c00015 	stw	r3,0(fp)
81123580:	3500e626 	beq	r6,r20,8112391c <_malloc_r+0x754>
81123584:	b9000017 	ldw	r4,0(r23)
81123588:	00bfffc4 	movi	r2,-1
8112358c:	2080ee26 	beq	r4,r2,81123948 <_malloc_r+0x780>
81123590:	a185c83a 	sub	r2,r20,r6
81123594:	10c5883a 	add	r2,r2,r3
81123598:	e0800015 	stw	r2,0(fp)
8112359c:	a0c001cc 	andi	r3,r20,7
811235a0:	1800bc26 	beq	r3,zero,81123894 <_malloc_r+0x6cc>
811235a4:	a0e9c83a 	sub	r20,r20,r3
811235a8:	00840204 	movi	r2,4104
811235ac:	a5000204 	addi	r20,r20,8
811235b0:	10c7c83a 	sub	r3,r2,r3
811235b4:	a545883a 	add	r2,r20,r21
811235b8:	1083ffcc 	andi	r2,r2,4095
811235bc:	18abc83a 	sub	r21,r3,r2
811235c0:	a80b883a 	mov	r5,r21
811235c4:	9009883a 	mov	r4,r18
811235c8:	11241080 	call	81124108 <_sbrk_r>
811235cc:	00ffffc4 	movi	r3,-1
811235d0:	10c0e126 	beq	r2,r3,81123958 <_malloc_r+0x790>
811235d4:	1505c83a 	sub	r2,r2,r20
811235d8:	1545883a 	add	r2,r2,r21
811235dc:	10800054 	ori	r2,r2,1
811235e0:	e0c00017 	ldw	r3,0(fp)
811235e4:	9d000215 	stw	r20,8(r19)
811235e8:	a0800115 	stw	r2,4(r20)
811235ec:	a8c7883a 	add	r3,r21,r3
811235f0:	e0c00015 	stw	r3,0(fp)
811235f4:	84c00e26 	beq	r16,r19,81123630 <_malloc_r+0x468>
811235f8:	018003c4 	movi	r6,15
811235fc:	3580a72e 	bgeu	r6,r22,8112389c <_malloc_r+0x6d4>
81123600:	81400117 	ldw	r5,4(r16)
81123604:	013ffe04 	movi	r4,-8
81123608:	b0bffd04 	addi	r2,r22,-12
8112360c:	1104703a 	and	r2,r2,r4
81123610:	2900004c 	andi	r4,r5,1
81123614:	2088b03a 	or	r4,r4,r2
81123618:	81000115 	stw	r4,4(r16)
8112361c:	01400144 	movi	r5,5
81123620:	8089883a 	add	r4,r16,r2
81123624:	21400115 	stw	r5,4(r4)
81123628:	21400215 	stw	r5,8(r4)
8112362c:	3080cd36 	bltu	r6,r2,81123964 <_malloc_r+0x79c>
81123630:	00a04574 	movhi	r2,33045
81123634:	10916604 	addi	r2,r2,17816
81123638:	11000017 	ldw	r4,0(r2)
8112363c:	20c0012e 	bgeu	r4,r3,81123644 <_malloc_r+0x47c>
81123640:	10c00015 	stw	r3,0(r2)
81123644:	00a04574 	movhi	r2,33045
81123648:	10916504 	addi	r2,r2,17812
8112364c:	11000017 	ldw	r4,0(r2)
81123650:	9c000217 	ldw	r16,8(r19)
81123654:	20c0012e 	bgeu	r4,r3,8112365c <_malloc_r+0x494>
81123658:	10c00015 	stw	r3,0(r2)
8112365c:	80c00117 	ldw	r3,4(r16)
81123660:	00bfff04 	movi	r2,-4
81123664:	1886703a 	and	r3,r3,r2
81123668:	1c45c83a 	sub	r2,r3,r17
8112366c:	1c400236 	bltu	r3,r17,81123678 <_malloc_r+0x4b0>
81123670:	00c003c4 	movi	r3,15
81123674:	18800416 	blt	r3,r2,81123688 <_malloc_r+0x4c0>
81123678:	9009883a 	mov	r4,r18
8112367c:	11394b00 	call	811394b0 <__malloc_unlock>
81123680:	0005883a 	mov	r2,zero
81123684:	003f7b06 	br	81123474 <__reset+0xfb103474>
81123688:	88c00054 	ori	r3,r17,1
8112368c:	80c00115 	stw	r3,4(r16)
81123690:	8463883a 	add	r17,r16,r17
81123694:	10800054 	ori	r2,r2,1
81123698:	9c400215 	stw	r17,8(r19)
8112369c:	88800115 	stw	r2,4(r17)
811236a0:	9009883a 	mov	r4,r18
811236a4:	11394b00 	call	811394b0 <__malloc_unlock>
811236a8:	80800204 	addi	r2,r16,8
811236ac:	003f7106 	br	81123474 <__reset+0xfb103474>
811236b0:	00c00504 	movi	r3,20
811236b4:	18804a2e 	bgeu	r3,r2,811237e0 <_malloc_r+0x618>
811236b8:	00c01504 	movi	r3,84
811236bc:	18806e36 	bltu	r3,r2,81123878 <_malloc_r+0x6b0>
811236c0:	8804d33a 	srli	r2,r17,12
811236c4:	12001bc4 	addi	r8,r2,111
811236c8:	11c01b84 	addi	r7,r2,110
811236cc:	4209883a 	add	r4,r8,r8
811236d0:	003edd06 	br	81123248 <__reset+0xfb103248>
811236d4:	3804d27a 	srli	r2,r7,9
811236d8:	00c00104 	movi	r3,4
811236dc:	1880442e 	bgeu	r3,r2,811237f0 <_malloc_r+0x628>
811236e0:	00c00504 	movi	r3,20
811236e4:	18808136 	bltu	r3,r2,811238ec <_malloc_r+0x724>
811236e8:	11401704 	addi	r5,r2,92
811236ec:	10c016c4 	addi	r3,r2,91
811236f0:	294b883a 	add	r5,r5,r5
811236f4:	294b883a 	add	r5,r5,r5
811236f8:	294b883a 	add	r5,r5,r5
811236fc:	994b883a 	add	r5,r19,r5
81123700:	28800017 	ldw	r2,0(r5)
81123704:	01a04574 	movhi	r6,33045
81123708:	297ffe04 	addi	r5,r5,-8
8112370c:	318aaf04 	addi	r6,r6,10940
81123710:	28806526 	beq	r5,r2,811238a8 <_malloc_r+0x6e0>
81123714:	01bfff04 	movi	r6,-4
81123718:	10c00117 	ldw	r3,4(r2)
8112371c:	1986703a 	and	r3,r3,r6
81123720:	38c0022e 	bgeu	r7,r3,8112372c <_malloc_r+0x564>
81123724:	10800217 	ldw	r2,8(r2)
81123728:	28bffb1e 	bne	r5,r2,81123718 <__reset+0xfb103718>
8112372c:	11400317 	ldw	r5,12(r2)
81123730:	98c00117 	ldw	r3,4(r19)
81123734:	81400315 	stw	r5,12(r16)
81123738:	80800215 	stw	r2,8(r16)
8112373c:	2c000215 	stw	r16,8(r5)
81123740:	14000315 	stw	r16,12(r2)
81123744:	003ef806 	br	81123328 <__reset+0xfb103328>
81123748:	88c00054 	ori	r3,r17,1
8112374c:	80c00115 	stw	r3,4(r16)
81123750:	8463883a 	add	r17,r16,r17
81123754:	34400515 	stw	r17,20(r6)
81123758:	34400415 	stw	r17,16(r6)
8112375c:	10c00054 	ori	r3,r2,1
81123760:	8a000315 	stw	r8,12(r17)
81123764:	8a000215 	stw	r8,8(r17)
81123768:	88c00115 	stw	r3,4(r17)
8112376c:	88a3883a 	add	r17,r17,r2
81123770:	88800015 	stw	r2,0(r17)
81123774:	9009883a 	mov	r4,r18
81123778:	11394b00 	call	811394b0 <__malloc_unlock>
8112377c:	80800204 	addi	r2,r16,8
81123780:	003f3c06 	br	81123474 <__reset+0xfb103474>
81123784:	30c00117 	ldw	r3,4(r6)
81123788:	003ee706 	br	81123328 <__reset+0xfb103328>
8112378c:	5ac00044 	addi	r11,r11,1
81123790:	588000cc 	andi	r2,r11,3
81123794:	31800204 	addi	r6,r6,8
81123798:	103efd1e 	bne	r2,zero,81123390 <__reset+0xfb103390>
8112379c:	00002406 	br	81123830 <_malloc_r+0x668>
811237a0:	14000317 	ldw	r16,12(r2)
811237a4:	143f251e 	bne	r2,r16,8112343c <__reset+0xfb10343c>
811237a8:	21000084 	addi	r4,r4,2
811237ac:	003ebc06 	br	811232a0 <__reset+0xfb1032a0>
811237b0:	8085883a 	add	r2,r16,r2
811237b4:	10c00117 	ldw	r3,4(r2)
811237b8:	81000317 	ldw	r4,12(r16)
811237bc:	81400217 	ldw	r5,8(r16)
811237c0:	18c00054 	ori	r3,r3,1
811237c4:	10c00115 	stw	r3,4(r2)
811237c8:	29000315 	stw	r4,12(r5)
811237cc:	21400215 	stw	r5,8(r4)
811237d0:	9009883a 	mov	r4,r18
811237d4:	11394b00 	call	811394b0 <__malloc_unlock>
811237d8:	80800204 	addi	r2,r16,8
811237dc:	003f2506 	br	81123474 <__reset+0xfb103474>
811237e0:	12001704 	addi	r8,r2,92
811237e4:	11c016c4 	addi	r7,r2,91
811237e8:	4209883a 	add	r4,r8,r8
811237ec:	003e9606 	br	81123248 <__reset+0xfb103248>
811237f0:	3804d1ba 	srli	r2,r7,6
811237f4:	11400e44 	addi	r5,r2,57
811237f8:	10c00e04 	addi	r3,r2,56
811237fc:	294b883a 	add	r5,r5,r5
81123800:	003fbc06 	br	811236f4 <__reset+0xfb1036f4>
81123804:	84ff5926 	beq	r16,r19,8112356c <__reset+0xfb10356c>
81123808:	00a04574 	movhi	r2,33045
8112380c:	108aaf04 	addi	r2,r2,10940
81123810:	14000217 	ldw	r16,8(r2)
81123814:	00bfff04 	movi	r2,-4
81123818:	80c00117 	ldw	r3,4(r16)
8112381c:	1886703a 	and	r3,r3,r2
81123820:	003f9106 	br	81123668 <__reset+0xfb103668>
81123824:	60800217 	ldw	r2,8(r12)
81123828:	213fffc4 	addi	r4,r4,-1
8112382c:	1300651e 	bne	r2,r12,811239c4 <_malloc_r+0x7fc>
81123830:	208000cc 	andi	r2,r4,3
81123834:	633ffe04 	addi	r12,r12,-8
81123838:	103ffa1e 	bne	r2,zero,81123824 <__reset+0xfb103824>
8112383c:	98800117 	ldw	r2,4(r19)
81123840:	0146303a 	nor	r3,zero,r5
81123844:	1884703a 	and	r2,r3,r2
81123848:	98800115 	stw	r2,4(r19)
8112384c:	294b883a 	add	r5,r5,r5
81123850:	117f2836 	bltu	r2,r5,811234f4 <__reset+0xfb1034f4>
81123854:	283f2726 	beq	r5,zero,811234f4 <__reset+0xfb1034f4>
81123858:	2886703a 	and	r3,r5,r2
8112385c:	5809883a 	mov	r4,r11
81123860:	183ec31e 	bne	r3,zero,81123370 <__reset+0xfb103370>
81123864:	294b883a 	add	r5,r5,r5
81123868:	2886703a 	and	r3,r5,r2
8112386c:	21000104 	addi	r4,r4,4
81123870:	183ffc26 	beq	r3,zero,81123864 <__reset+0xfb103864>
81123874:	003ebe06 	br	81123370 <__reset+0xfb103370>
81123878:	00c05504 	movi	r3,340
8112387c:	18801236 	bltu	r3,r2,811238c8 <_malloc_r+0x700>
81123880:	8804d3fa 	srli	r2,r17,15
81123884:	12001e04 	addi	r8,r2,120
81123888:	11c01dc4 	addi	r7,r2,119
8112388c:	4209883a 	add	r4,r8,r8
81123890:	003e6d06 	br	81123248 <__reset+0xfb103248>
81123894:	00c40004 	movi	r3,4096
81123898:	003f4606 	br	811235b4 <__reset+0xfb1035b4>
8112389c:	00800044 	movi	r2,1
811238a0:	a0800115 	stw	r2,4(r20)
811238a4:	003f7406 	br	81123678 <__reset+0xfb103678>
811238a8:	1805d0ba 	srai	r2,r3,2
811238ac:	01c00044 	movi	r7,1
811238b0:	30c00117 	ldw	r3,4(r6)
811238b4:	388e983a 	sll	r7,r7,r2
811238b8:	2805883a 	mov	r2,r5
811238bc:	38c6b03a 	or	r3,r7,r3
811238c0:	30c00115 	stw	r3,4(r6)
811238c4:	003f9b06 	br	81123734 <__reset+0xfb103734>
811238c8:	00c15504 	movi	r3,1364
811238cc:	18801a36 	bltu	r3,r2,81123938 <_malloc_r+0x770>
811238d0:	8804d4ba 	srli	r2,r17,18
811238d4:	12001f44 	addi	r8,r2,125
811238d8:	11c01f04 	addi	r7,r2,124
811238dc:	4209883a 	add	r4,r8,r8
811238e0:	003e5906 	br	81123248 <__reset+0xfb103248>
811238e4:	ad400404 	addi	r21,r21,16
811238e8:	003f1706 	br	81123548 <__reset+0xfb103548>
811238ec:	00c01504 	movi	r3,84
811238f0:	18802336 	bltu	r3,r2,81123980 <_malloc_r+0x7b8>
811238f4:	3804d33a 	srli	r2,r7,12
811238f8:	11401bc4 	addi	r5,r2,111
811238fc:	10c01b84 	addi	r3,r2,110
81123900:	294b883a 	add	r5,r5,r5
81123904:	003f7b06 	br	811236f4 <__reset+0xfb1036f4>
81123908:	9c000217 	ldw	r16,8(r19)
8112390c:	00bfff04 	movi	r2,-4
81123910:	80c00117 	ldw	r3,4(r16)
81123914:	1886703a 	and	r3,r3,r2
81123918:	003f5306 	br	81123668 <__reset+0xfb103668>
8112391c:	3083ffcc 	andi	r2,r6,4095
81123920:	103f181e 	bne	r2,zero,81123584 <__reset+0xfb103584>
81123924:	99000217 	ldw	r4,8(r19)
81123928:	b545883a 	add	r2,r22,r21
8112392c:	10800054 	ori	r2,r2,1
81123930:	20800115 	stw	r2,4(r4)
81123934:	003f3e06 	br	81123630 <__reset+0xfb103630>
81123938:	01003f84 	movi	r4,254
8112393c:	02001fc4 	movi	r8,127
81123940:	01c01f84 	movi	r7,126
81123944:	003e4006 	br	81123248 <__reset+0xfb103248>
81123948:	00a04574 	movhi	r2,33045
8112394c:	1090f204 	addi	r2,r2,17352
81123950:	15000015 	stw	r20,0(r2)
81123954:	003f1106 	br	8112359c <__reset+0xfb10359c>
81123958:	00800044 	movi	r2,1
8112395c:	002b883a 	mov	r21,zero
81123960:	003f1f06 	br	811235e0 <__reset+0xfb1035e0>
81123964:	81400204 	addi	r5,r16,8
81123968:	9009883a 	mov	r4,r18
8112396c:	112cbc00 	call	8112cbc0 <_free_r>
81123970:	00a04574 	movhi	r2,33045
81123974:	1091f404 	addi	r2,r2,18384
81123978:	10c00017 	ldw	r3,0(r2)
8112397c:	003f2c06 	br	81123630 <__reset+0xfb103630>
81123980:	00c05504 	movi	r3,340
81123984:	18800536 	bltu	r3,r2,8112399c <_malloc_r+0x7d4>
81123988:	3804d3fa 	srli	r2,r7,15
8112398c:	11401e04 	addi	r5,r2,120
81123990:	10c01dc4 	addi	r3,r2,119
81123994:	294b883a 	add	r5,r5,r5
81123998:	003f5606 	br	811236f4 <__reset+0xfb1036f4>
8112399c:	00c15504 	movi	r3,1364
811239a0:	18800536 	bltu	r3,r2,811239b8 <_malloc_r+0x7f0>
811239a4:	3804d4ba 	srli	r2,r7,18
811239a8:	11401f44 	addi	r5,r2,125
811239ac:	10c01f04 	addi	r3,r2,124
811239b0:	294b883a 	add	r5,r5,r5
811239b4:	003f4f06 	br	811236f4 <__reset+0xfb1036f4>
811239b8:	01403f84 	movi	r5,254
811239bc:	00c01f84 	movi	r3,126
811239c0:	003f4c06 	br	811236f4 <__reset+0xfb1036f4>
811239c4:	98800117 	ldw	r2,4(r19)
811239c8:	003fa006 	br	8112384c <__reset+0xfb10384c>
811239cc:	8808d0fa 	srli	r4,r17,3
811239d0:	20800044 	addi	r2,r4,1
811239d4:	1085883a 	add	r2,r2,r2
811239d8:	003e9006 	br	8112341c <__reset+0xfb10341c>

811239dc <memcpy>:
811239dc:	defffd04 	addi	sp,sp,-12
811239e0:	de00012e 	bgeu	sp,et,811239e8 <memcpy+0xc>
811239e4:	003b68fa 	trap	3
811239e8:	00c003c4 	movi	r3,15
811239ec:	dfc00215 	stw	ra,8(sp)
811239f0:	dc400115 	stw	r17,4(sp)
811239f4:	dc000015 	stw	r16,0(sp)
811239f8:	2005883a 	mov	r2,r4
811239fc:	1980452e 	bgeu	r3,r6,81123b14 <memcpy+0x138>
81123a00:	2906b03a 	or	r3,r5,r4
81123a04:	18c000cc 	andi	r3,r3,3
81123a08:	1800441e 	bne	r3,zero,81123b1c <memcpy+0x140>
81123a0c:	347ffc04 	addi	r17,r6,-16
81123a10:	8822d13a 	srli	r17,r17,4
81123a14:	28c00104 	addi	r3,r5,4
81123a18:	23400104 	addi	r13,r4,4
81123a1c:	8820913a 	slli	r16,r17,4
81123a20:	2b000204 	addi	r12,r5,8
81123a24:	22c00204 	addi	r11,r4,8
81123a28:	84000504 	addi	r16,r16,20
81123a2c:	2a800304 	addi	r10,r5,12
81123a30:	22400304 	addi	r9,r4,12
81123a34:	2c21883a 	add	r16,r5,r16
81123a38:	2811883a 	mov	r8,r5
81123a3c:	200f883a 	mov	r7,r4
81123a40:	41000017 	ldw	r4,0(r8)
81123a44:	1fc00017 	ldw	ra,0(r3)
81123a48:	63c00017 	ldw	r15,0(r12)
81123a4c:	39000015 	stw	r4,0(r7)
81123a50:	53800017 	ldw	r14,0(r10)
81123a54:	6fc00015 	stw	ra,0(r13)
81123a58:	5bc00015 	stw	r15,0(r11)
81123a5c:	4b800015 	stw	r14,0(r9)
81123a60:	18c00404 	addi	r3,r3,16
81123a64:	39c00404 	addi	r7,r7,16
81123a68:	42000404 	addi	r8,r8,16
81123a6c:	6b400404 	addi	r13,r13,16
81123a70:	63000404 	addi	r12,r12,16
81123a74:	5ac00404 	addi	r11,r11,16
81123a78:	52800404 	addi	r10,r10,16
81123a7c:	4a400404 	addi	r9,r9,16
81123a80:	1c3fef1e 	bne	r3,r16,81123a40 <__reset+0xfb103a40>
81123a84:	89c00044 	addi	r7,r17,1
81123a88:	380e913a 	slli	r7,r7,4
81123a8c:	310003cc 	andi	r4,r6,15
81123a90:	02c000c4 	movi	r11,3
81123a94:	11c7883a 	add	r3,r2,r7
81123a98:	29cb883a 	add	r5,r5,r7
81123a9c:	5900212e 	bgeu	r11,r4,81123b24 <memcpy+0x148>
81123aa0:	1813883a 	mov	r9,r3
81123aa4:	2811883a 	mov	r8,r5
81123aa8:	200f883a 	mov	r7,r4
81123aac:	42800017 	ldw	r10,0(r8)
81123ab0:	4a400104 	addi	r9,r9,4
81123ab4:	39ffff04 	addi	r7,r7,-4
81123ab8:	4abfff15 	stw	r10,-4(r9)
81123abc:	42000104 	addi	r8,r8,4
81123ac0:	59fffa36 	bltu	r11,r7,81123aac <__reset+0xfb103aac>
81123ac4:	213fff04 	addi	r4,r4,-4
81123ac8:	2008d0ba 	srli	r4,r4,2
81123acc:	318000cc 	andi	r6,r6,3
81123ad0:	21000044 	addi	r4,r4,1
81123ad4:	2109883a 	add	r4,r4,r4
81123ad8:	2109883a 	add	r4,r4,r4
81123adc:	1907883a 	add	r3,r3,r4
81123ae0:	290b883a 	add	r5,r5,r4
81123ae4:	30000626 	beq	r6,zero,81123b00 <memcpy+0x124>
81123ae8:	198d883a 	add	r6,r3,r6
81123aec:	29c00003 	ldbu	r7,0(r5)
81123af0:	18c00044 	addi	r3,r3,1
81123af4:	29400044 	addi	r5,r5,1
81123af8:	19ffffc5 	stb	r7,-1(r3)
81123afc:	19bffb1e 	bne	r3,r6,81123aec <__reset+0xfb103aec>
81123b00:	dfc00217 	ldw	ra,8(sp)
81123b04:	dc400117 	ldw	r17,4(sp)
81123b08:	dc000017 	ldw	r16,0(sp)
81123b0c:	dec00304 	addi	sp,sp,12
81123b10:	f800283a 	ret
81123b14:	2007883a 	mov	r3,r4
81123b18:	003ff206 	br	81123ae4 <__reset+0xfb103ae4>
81123b1c:	2007883a 	mov	r3,r4
81123b20:	003ff106 	br	81123ae8 <__reset+0xfb103ae8>
81123b24:	200d883a 	mov	r6,r4
81123b28:	003fee06 	br	81123ae4 <__reset+0xfb103ae4>

81123b2c <memset>:
81123b2c:	20c000cc 	andi	r3,r4,3
81123b30:	2005883a 	mov	r2,r4
81123b34:	18004426 	beq	r3,zero,81123c48 <memset+0x11c>
81123b38:	31ffffc4 	addi	r7,r6,-1
81123b3c:	30004026 	beq	r6,zero,81123c40 <memset+0x114>
81123b40:	2813883a 	mov	r9,r5
81123b44:	200d883a 	mov	r6,r4
81123b48:	2007883a 	mov	r3,r4
81123b4c:	00000406 	br	81123b60 <memset+0x34>
81123b50:	3a3fffc4 	addi	r8,r7,-1
81123b54:	31800044 	addi	r6,r6,1
81123b58:	38003926 	beq	r7,zero,81123c40 <memset+0x114>
81123b5c:	400f883a 	mov	r7,r8
81123b60:	18c00044 	addi	r3,r3,1
81123b64:	32400005 	stb	r9,0(r6)
81123b68:	1a0000cc 	andi	r8,r3,3
81123b6c:	403ff81e 	bne	r8,zero,81123b50 <__reset+0xfb103b50>
81123b70:	010000c4 	movi	r4,3
81123b74:	21c02d2e 	bgeu	r4,r7,81123c2c <memset+0x100>
81123b78:	29003fcc 	andi	r4,r5,255
81123b7c:	200c923a 	slli	r6,r4,8
81123b80:	3108b03a 	or	r4,r6,r4
81123b84:	200c943a 	slli	r6,r4,16
81123b88:	218cb03a 	or	r6,r4,r6
81123b8c:	010003c4 	movi	r4,15
81123b90:	21c0182e 	bgeu	r4,r7,81123bf4 <memset+0xc8>
81123b94:	3b3ffc04 	addi	r12,r7,-16
81123b98:	6018d13a 	srli	r12,r12,4
81123b9c:	1a000104 	addi	r8,r3,4
81123ba0:	1ac00204 	addi	r11,r3,8
81123ba4:	6008913a 	slli	r4,r12,4
81123ba8:	1a800304 	addi	r10,r3,12
81123bac:	1813883a 	mov	r9,r3
81123bb0:	21000504 	addi	r4,r4,20
81123bb4:	1909883a 	add	r4,r3,r4
81123bb8:	49800015 	stw	r6,0(r9)
81123bbc:	41800015 	stw	r6,0(r8)
81123bc0:	59800015 	stw	r6,0(r11)
81123bc4:	51800015 	stw	r6,0(r10)
81123bc8:	42000404 	addi	r8,r8,16
81123bcc:	4a400404 	addi	r9,r9,16
81123bd0:	5ac00404 	addi	r11,r11,16
81123bd4:	52800404 	addi	r10,r10,16
81123bd8:	413ff71e 	bne	r8,r4,81123bb8 <__reset+0xfb103bb8>
81123bdc:	63000044 	addi	r12,r12,1
81123be0:	6018913a 	slli	r12,r12,4
81123be4:	39c003cc 	andi	r7,r7,15
81123be8:	010000c4 	movi	r4,3
81123bec:	1b07883a 	add	r3,r3,r12
81123bf0:	21c00e2e 	bgeu	r4,r7,81123c2c <memset+0x100>
81123bf4:	1813883a 	mov	r9,r3
81123bf8:	3811883a 	mov	r8,r7
81123bfc:	010000c4 	movi	r4,3
81123c00:	49800015 	stw	r6,0(r9)
81123c04:	423fff04 	addi	r8,r8,-4
81123c08:	4a400104 	addi	r9,r9,4
81123c0c:	223ffc36 	bltu	r4,r8,81123c00 <__reset+0xfb103c00>
81123c10:	393fff04 	addi	r4,r7,-4
81123c14:	2008d0ba 	srli	r4,r4,2
81123c18:	39c000cc 	andi	r7,r7,3
81123c1c:	21000044 	addi	r4,r4,1
81123c20:	2109883a 	add	r4,r4,r4
81123c24:	2109883a 	add	r4,r4,r4
81123c28:	1907883a 	add	r3,r3,r4
81123c2c:	38000526 	beq	r7,zero,81123c44 <memset+0x118>
81123c30:	19cf883a 	add	r7,r3,r7
81123c34:	19400005 	stb	r5,0(r3)
81123c38:	18c00044 	addi	r3,r3,1
81123c3c:	38fffd1e 	bne	r7,r3,81123c34 <__reset+0xfb103c34>
81123c40:	f800283a 	ret
81123c44:	f800283a 	ret
81123c48:	2007883a 	mov	r3,r4
81123c4c:	300f883a 	mov	r7,r6
81123c50:	003fc706 	br	81123b70 <__reset+0xfb103b70>

81123c54 <_open_r>:
81123c54:	defffd04 	addi	sp,sp,-12
81123c58:	de00012e 	bgeu	sp,et,81123c60 <_open_r+0xc>
81123c5c:	003b68fa 	trap	3
81123c60:	2805883a 	mov	r2,r5
81123c64:	dc000015 	stw	r16,0(sp)
81123c68:	04204574 	movhi	r16,33045
81123c6c:	dc400115 	stw	r17,4(sp)
81123c70:	300b883a 	mov	r5,r6
81123c74:	84116404 	addi	r16,r16,17808
81123c78:	2023883a 	mov	r17,r4
81123c7c:	380d883a 	mov	r6,r7
81123c80:	1009883a 	mov	r4,r2
81123c84:	dfc00215 	stw	ra,8(sp)
81123c88:	80000015 	stw	zero,0(r16)
81123c8c:	1138a080 	call	81138a08 <open>
81123c90:	00ffffc4 	movi	r3,-1
81123c94:	10c00526 	beq	r2,r3,81123cac <_open_r+0x58>
81123c98:	dfc00217 	ldw	ra,8(sp)
81123c9c:	dc400117 	ldw	r17,4(sp)
81123ca0:	dc000017 	ldw	r16,0(sp)
81123ca4:	dec00304 	addi	sp,sp,12
81123ca8:	f800283a 	ret
81123cac:	80c00017 	ldw	r3,0(r16)
81123cb0:	183ff926 	beq	r3,zero,81123c98 <__reset+0xfb103c98>
81123cb4:	88c00015 	stw	r3,0(r17)
81123cb8:	003ff706 	br	81123c98 <__reset+0xfb103c98>

81123cbc <_putc_r>:
81123cbc:	defffc04 	addi	sp,sp,-16
81123cc0:	de00012e 	bgeu	sp,et,81123cc8 <_putc_r+0xc>
81123cc4:	003b68fa 	trap	3
81123cc8:	dc000215 	stw	r16,8(sp)
81123ccc:	dfc00315 	stw	ra,12(sp)
81123cd0:	2021883a 	mov	r16,r4
81123cd4:	20000226 	beq	r4,zero,81123ce0 <_putc_r+0x24>
81123cd8:	20800e17 	ldw	r2,56(r4)
81123cdc:	10001b26 	beq	r2,zero,81123d4c <_putc_r+0x90>
81123ce0:	30800217 	ldw	r2,8(r6)
81123ce4:	10bfffc4 	addi	r2,r2,-1
81123ce8:	30800215 	stw	r2,8(r6)
81123cec:	10000a16 	blt	r2,zero,81123d18 <_putc_r+0x5c>
81123cf0:	30800017 	ldw	r2,0(r6)
81123cf4:	11400005 	stb	r5,0(r2)
81123cf8:	30800017 	ldw	r2,0(r6)
81123cfc:	10c00044 	addi	r3,r2,1
81123d00:	30c00015 	stw	r3,0(r6)
81123d04:	10800003 	ldbu	r2,0(r2)
81123d08:	dfc00317 	ldw	ra,12(sp)
81123d0c:	dc000217 	ldw	r16,8(sp)
81123d10:	dec00404 	addi	sp,sp,16
81123d14:	f800283a 	ret
81123d18:	30c00617 	ldw	r3,24(r6)
81123d1c:	10c00616 	blt	r2,r3,81123d38 <_putc_r+0x7c>
81123d20:	30800017 	ldw	r2,0(r6)
81123d24:	00c00284 	movi	r3,10
81123d28:	11400005 	stb	r5,0(r2)
81123d2c:	30800017 	ldw	r2,0(r6)
81123d30:	11400003 	ldbu	r5,0(r2)
81123d34:	28fff11e 	bne	r5,r3,81123cfc <__reset+0xfb103cfc>
81123d38:	8009883a 	mov	r4,r16
81123d3c:	dfc00317 	ldw	ra,12(sp)
81123d40:	dc000217 	ldw	r16,8(sp)
81123d44:	dec00404 	addi	sp,sp,16
81123d48:	112a4f01 	jmpi	8112a4f0 <__swbuf_r>
81123d4c:	d9400015 	stw	r5,0(sp)
81123d50:	d9800115 	stw	r6,4(sp)
81123d54:	112c7280 	call	8112c728 <__sinit>
81123d58:	d9800117 	ldw	r6,4(sp)
81123d5c:	d9400017 	ldw	r5,0(sp)
81123d60:	003fdf06 	br	81123ce0 <__reset+0xfb103ce0>

81123d64 <putc>:
81123d64:	00a04574 	movhi	r2,33045
81123d68:	defffc04 	addi	sp,sp,-16
81123d6c:	1090f104 	addi	r2,r2,17348
81123d70:	de00012e 	bgeu	sp,et,81123d78 <putc+0x14>
81123d74:	003b68fa 	trap	3
81123d78:	dc000115 	stw	r16,4(sp)
81123d7c:	14000017 	ldw	r16,0(r2)
81123d80:	dc400215 	stw	r17,8(sp)
81123d84:	dfc00315 	stw	ra,12(sp)
81123d88:	2023883a 	mov	r17,r4
81123d8c:	80000226 	beq	r16,zero,81123d98 <putc+0x34>
81123d90:	80800e17 	ldw	r2,56(r16)
81123d94:	10001a26 	beq	r2,zero,81123e00 <putc+0x9c>
81123d98:	28800217 	ldw	r2,8(r5)
81123d9c:	10bfffc4 	addi	r2,r2,-1
81123da0:	28800215 	stw	r2,8(r5)
81123da4:	10000b16 	blt	r2,zero,81123dd4 <putc+0x70>
81123da8:	28800017 	ldw	r2,0(r5)
81123dac:	14400005 	stb	r17,0(r2)
81123db0:	28800017 	ldw	r2,0(r5)
81123db4:	10c00044 	addi	r3,r2,1
81123db8:	28c00015 	stw	r3,0(r5)
81123dbc:	10800003 	ldbu	r2,0(r2)
81123dc0:	dfc00317 	ldw	ra,12(sp)
81123dc4:	dc400217 	ldw	r17,8(sp)
81123dc8:	dc000117 	ldw	r16,4(sp)
81123dcc:	dec00404 	addi	sp,sp,16
81123dd0:	f800283a 	ret
81123dd4:	28c00617 	ldw	r3,24(r5)
81123dd8:	10c00e16 	blt	r2,r3,81123e14 <putc+0xb0>
81123ddc:	28800017 	ldw	r2,0(r5)
81123de0:	01000284 	movi	r4,10
81123de4:	14400005 	stb	r17,0(r2)
81123de8:	28800017 	ldw	r2,0(r5)
81123dec:	10c00003 	ldbu	r3,0(r2)
81123df0:	193ff01e 	bne	r3,r4,81123db4 <__reset+0xfb103db4>
81123df4:	280d883a 	mov	r6,r5
81123df8:	180b883a 	mov	r5,r3
81123dfc:	00000706 	br	81123e1c <putc+0xb8>
81123e00:	8009883a 	mov	r4,r16
81123e04:	d9400015 	stw	r5,0(sp)
81123e08:	112c7280 	call	8112c728 <__sinit>
81123e0c:	d9400017 	ldw	r5,0(sp)
81123e10:	003fe106 	br	81123d98 <__reset+0xfb103d98>
81123e14:	280d883a 	mov	r6,r5
81123e18:	880b883a 	mov	r5,r17
81123e1c:	8009883a 	mov	r4,r16
81123e20:	dfc00317 	ldw	ra,12(sp)
81123e24:	dc400217 	ldw	r17,8(sp)
81123e28:	dc000117 	ldw	r16,4(sp)
81123e2c:	dec00404 	addi	sp,sp,16
81123e30:	112a4f01 	jmpi	8112a4f0 <__swbuf_r>

81123e34 <_puts_r>:
81123e34:	defff604 	addi	sp,sp,-40
81123e38:	de00012e 	bgeu	sp,et,81123e40 <_puts_r+0xc>
81123e3c:	003b68fa 	trap	3
81123e40:	dc000715 	stw	r16,28(sp)
81123e44:	2021883a 	mov	r16,r4
81123e48:	2809883a 	mov	r4,r5
81123e4c:	dc400815 	stw	r17,32(sp)
81123e50:	dfc00915 	stw	ra,36(sp)
81123e54:	2823883a 	mov	r17,r5
81123e58:	11244540 	call	81124454 <strlen>
81123e5c:	10c00044 	addi	r3,r2,1
81123e60:	d8800115 	stw	r2,4(sp)
81123e64:	00a04574 	movhi	r2,33045
81123e68:	10871804 	addi	r2,r2,7264
81123e6c:	d8800215 	stw	r2,8(sp)
81123e70:	00800044 	movi	r2,1
81123e74:	d8800315 	stw	r2,12(sp)
81123e78:	00800084 	movi	r2,2
81123e7c:	dc400015 	stw	r17,0(sp)
81123e80:	d8c00615 	stw	r3,24(sp)
81123e84:	dec00415 	stw	sp,16(sp)
81123e88:	d8800515 	stw	r2,20(sp)
81123e8c:	80000226 	beq	r16,zero,81123e98 <_puts_r+0x64>
81123e90:	80800e17 	ldw	r2,56(r16)
81123e94:	10001426 	beq	r2,zero,81123ee8 <_puts_r+0xb4>
81123e98:	81400217 	ldw	r5,8(r16)
81123e9c:	2880030b 	ldhu	r2,12(r5)
81123ea0:	10c8000c 	andi	r3,r2,8192
81123ea4:	1800061e 	bne	r3,zero,81123ec0 <_puts_r+0x8c>
81123ea8:	29001917 	ldw	r4,100(r5)
81123eac:	00f7ffc4 	movi	r3,-8193
81123eb0:	10880014 	ori	r2,r2,8192
81123eb4:	20c6703a 	and	r3,r4,r3
81123eb8:	2880030d 	sth	r2,12(r5)
81123ebc:	28c01915 	stw	r3,100(r5)
81123ec0:	d9800404 	addi	r6,sp,16
81123ec4:	8009883a 	mov	r4,r16
81123ec8:	112ced80 	call	8112ced8 <__sfvwrite_r>
81123ecc:	1000091e 	bne	r2,zero,81123ef4 <_puts_r+0xc0>
81123ed0:	00800284 	movi	r2,10
81123ed4:	dfc00917 	ldw	ra,36(sp)
81123ed8:	dc400817 	ldw	r17,32(sp)
81123edc:	dc000717 	ldw	r16,28(sp)
81123ee0:	dec00a04 	addi	sp,sp,40
81123ee4:	f800283a 	ret
81123ee8:	8009883a 	mov	r4,r16
81123eec:	112c7280 	call	8112c728 <__sinit>
81123ef0:	003fe906 	br	81123e98 <__reset+0xfb103e98>
81123ef4:	00bfffc4 	movi	r2,-1
81123ef8:	003ff606 	br	81123ed4 <__reset+0xfb103ed4>

81123efc <puts>:
81123efc:	00a04574 	movhi	r2,33045
81123f00:	1090f104 	addi	r2,r2,17348
81123f04:	200b883a 	mov	r5,r4
81123f08:	11000017 	ldw	r4,0(r2)
81123f0c:	1123e341 	jmpi	81123e34 <_puts_r>

81123f10 <lflush>:
81123f10:	2080030b 	ldhu	r2,12(r4)
81123f14:	00c00244 	movi	r3,9
81123f18:	1080024c 	andi	r2,r2,9
81123f1c:	10c00226 	beq	r2,r3,81123f28 <lflush+0x18>
81123f20:	0005883a 	mov	r2,zero
81123f24:	f800283a 	ret
81123f28:	112c3901 	jmpi	8112c390 <fflush>

81123f2c <__srefill_r>:
81123f2c:	defffc04 	addi	sp,sp,-16
81123f30:	de00012e 	bgeu	sp,et,81123f38 <__srefill_r+0xc>
81123f34:	003b68fa 	trap	3
81123f38:	dc400115 	stw	r17,4(sp)
81123f3c:	dc000015 	stw	r16,0(sp)
81123f40:	dfc00315 	stw	ra,12(sp)
81123f44:	dc800215 	stw	r18,8(sp)
81123f48:	2023883a 	mov	r17,r4
81123f4c:	2821883a 	mov	r16,r5
81123f50:	20000226 	beq	r4,zero,81123f5c <__srefill_r+0x30>
81123f54:	20800e17 	ldw	r2,56(r4)
81123f58:	10003c26 	beq	r2,zero,8112404c <__srefill_r+0x120>
81123f5c:	80c0030b 	ldhu	r3,12(r16)
81123f60:	1908000c 	andi	r4,r3,8192
81123f64:	1805883a 	mov	r2,r3
81123f68:	2000071e 	bne	r4,zero,81123f88 <__srefill_r+0x5c>
81123f6c:	81001917 	ldw	r4,100(r16)
81123f70:	18880014 	ori	r2,r3,8192
81123f74:	00f7ffc4 	movi	r3,-8193
81123f78:	20c8703a 	and	r4,r4,r3
81123f7c:	8080030d 	sth	r2,12(r16)
81123f80:	1007883a 	mov	r3,r2
81123f84:	81001915 	stw	r4,100(r16)
81123f88:	80000115 	stw	zero,4(r16)
81123f8c:	1100080c 	andi	r4,r2,32
81123f90:	2000571e 	bne	r4,zero,811240f0 <__srefill_r+0x1c4>
81123f94:	1100010c 	andi	r4,r2,4
81123f98:	20001f26 	beq	r4,zero,81124018 <__srefill_r+0xec>
81123f9c:	81400c17 	ldw	r5,48(r16)
81123fa0:	28000826 	beq	r5,zero,81123fc4 <__srefill_r+0x98>
81123fa4:	80801004 	addi	r2,r16,64
81123fa8:	28800226 	beq	r5,r2,81123fb4 <__srefill_r+0x88>
81123fac:	8809883a 	mov	r4,r17
81123fb0:	112cbc00 	call	8112cbc0 <_free_r>
81123fb4:	80800f17 	ldw	r2,60(r16)
81123fb8:	80000c15 	stw	zero,48(r16)
81123fbc:	80800115 	stw	r2,4(r16)
81123fc0:	1000391e 	bne	r2,zero,811240a8 <__srefill_r+0x17c>
81123fc4:	80800417 	ldw	r2,16(r16)
81123fc8:	10004b26 	beq	r2,zero,811240f8 <__srefill_r+0x1cc>
81123fcc:	8480030b 	ldhu	r18,12(r16)
81123fd0:	908000cc 	andi	r2,r18,3
81123fd4:	10001f1e 	bne	r2,zero,81124054 <__srefill_r+0x128>
81123fd8:	81800417 	ldw	r6,16(r16)
81123fdc:	80800817 	ldw	r2,32(r16)
81123fe0:	81c00517 	ldw	r7,20(r16)
81123fe4:	81400717 	ldw	r5,28(r16)
81123fe8:	81800015 	stw	r6,0(r16)
81123fec:	8809883a 	mov	r4,r17
81123ff0:	103ee83a 	callr	r2
81123ff4:	80800115 	stw	r2,4(r16)
81123ff8:	00800e0e 	bge	zero,r2,81124034 <__srefill_r+0x108>
81123ffc:	0005883a 	mov	r2,zero
81124000:	dfc00317 	ldw	ra,12(sp)
81124004:	dc800217 	ldw	r18,8(sp)
81124008:	dc400117 	ldw	r17,4(sp)
8112400c:	dc000017 	ldw	r16,0(sp)
81124010:	dec00404 	addi	sp,sp,16
81124014:	f800283a 	ret
81124018:	1100040c 	andi	r4,r2,16
8112401c:	20003026 	beq	r4,zero,811240e0 <__srefill_r+0x1b4>
81124020:	1080020c 	andi	r2,r2,8
81124024:	1000241e 	bne	r2,zero,811240b8 <__srefill_r+0x18c>
81124028:	18c00114 	ori	r3,r3,4
8112402c:	80c0030d 	sth	r3,12(r16)
81124030:	003fe406 	br	81123fc4 <__reset+0xfb103fc4>
81124034:	80c0030b 	ldhu	r3,12(r16)
81124038:	1000161e 	bne	r2,zero,81124094 <__srefill_r+0x168>
8112403c:	18c00814 	ori	r3,r3,32
81124040:	00bfffc4 	movi	r2,-1
81124044:	80c0030d 	sth	r3,12(r16)
81124048:	003fed06 	br	81124000 <__reset+0xfb104000>
8112404c:	112c7280 	call	8112c728 <__sinit>
81124050:	003fc206 	br	81123f5c <__reset+0xfb103f5c>
81124054:	00a04574 	movhi	r2,33045
81124058:	1090f004 	addi	r2,r2,17344
8112405c:	11000017 	ldw	r4,0(r2)
81124060:	016044b4 	movhi	r5,33042
81124064:	00800044 	movi	r2,1
81124068:	294fc404 	addi	r5,r5,16144
8112406c:	8080030d 	sth	r2,12(r16)
81124070:	112d39c0 	call	8112d39c <_fwalk>
81124074:	00800244 	movi	r2,9
81124078:	8480030d 	sth	r18,12(r16)
8112407c:	9480024c 	andi	r18,r18,9
81124080:	90bfd51e 	bne	r18,r2,81123fd8 <__reset+0xfb103fd8>
81124084:	800b883a 	mov	r5,r16
81124088:	8809883a 	mov	r4,r17
8112408c:	112c1080 	call	8112c108 <__sflush_r>
81124090:	003fd106 	br	81123fd8 <__reset+0xfb103fd8>
81124094:	18c01014 	ori	r3,r3,64
81124098:	80000115 	stw	zero,4(r16)
8112409c:	00bfffc4 	movi	r2,-1
811240a0:	80c0030d 	sth	r3,12(r16)
811240a4:	003fd606 	br	81124000 <__reset+0xfb104000>
811240a8:	80c00e17 	ldw	r3,56(r16)
811240ac:	0005883a 	mov	r2,zero
811240b0:	80c00015 	stw	r3,0(r16)
811240b4:	003fd206 	br	81124000 <__reset+0xfb104000>
811240b8:	800b883a 	mov	r5,r16
811240bc:	8809883a 	mov	r4,r17
811240c0:	112c32c0 	call	8112c32c <_fflush_r>
811240c4:	10000a1e 	bne	r2,zero,811240f0 <__srefill_r+0x1c4>
811240c8:	8080030b 	ldhu	r2,12(r16)
811240cc:	00fffdc4 	movi	r3,-9
811240d0:	80000215 	stw	zero,8(r16)
811240d4:	1886703a 	and	r3,r3,r2
811240d8:	80000615 	stw	zero,24(r16)
811240dc:	003fd206 	br	81124028 <__reset+0xfb104028>
811240e0:	00800244 	movi	r2,9
811240e4:	88800015 	stw	r2,0(r17)
811240e8:	18c01014 	ori	r3,r3,64
811240ec:	80c0030d 	sth	r3,12(r16)
811240f0:	00bfffc4 	movi	r2,-1
811240f4:	003fc206 	br	81124000 <__reset+0xfb104000>
811240f8:	800b883a 	mov	r5,r16
811240fc:	8809883a 	mov	r4,r17
81124100:	11230040 	call	81123004 <__smakebuf_r>
81124104:	003fb106 	br	81123fcc <__reset+0xfb103fcc>

81124108 <_sbrk_r>:
81124108:	defffd04 	addi	sp,sp,-12
8112410c:	de00012e 	bgeu	sp,et,81124114 <_sbrk_r+0xc>
81124110:	003b68fa 	trap	3
81124114:	dc000015 	stw	r16,0(sp)
81124118:	04204574 	movhi	r16,33045
8112411c:	dc400115 	stw	r17,4(sp)
81124120:	84116404 	addi	r16,r16,17808
81124124:	2023883a 	mov	r17,r4
81124128:	2809883a 	mov	r4,r5
8112412c:	dfc00215 	stw	ra,8(sp)
81124130:	80000015 	stw	zero,0(r16)
81124134:	1138d180 	call	81138d18 <sbrk>
81124138:	00ffffc4 	movi	r3,-1
8112413c:	10c00526 	beq	r2,r3,81124154 <_sbrk_r+0x4c>
81124140:	dfc00217 	ldw	ra,8(sp)
81124144:	dc400117 	ldw	r17,4(sp)
81124148:	dc000017 	ldw	r16,0(sp)
8112414c:	dec00304 	addi	sp,sp,12
81124150:	f800283a 	ret
81124154:	80c00017 	ldw	r3,0(r16)
81124158:	183ff926 	beq	r3,zero,81124140 <__reset+0xfb104140>
8112415c:	88c00015 	stw	r3,0(r17)
81124160:	003ff706 	br	81124140 <__reset+0xfb104140>

81124164 <scanf>:
81124164:	defffc04 	addi	sp,sp,-16
81124168:	de00012e 	bgeu	sp,et,81124170 <scanf+0xc>
8112416c:	003b68fa 	trap	3
81124170:	dfc00015 	stw	ra,0(sp)
81124174:	d9400115 	stw	r5,4(sp)
81124178:	d9800215 	stw	r6,8(sp)
8112417c:	d9c00315 	stw	r7,12(sp)
81124180:	00a04574 	movhi	r2,33045
81124184:	1090f104 	addi	r2,r2,17348
81124188:	200d883a 	mov	r6,r4
8112418c:	11000017 	ldw	r4,0(r2)
81124190:	d9c00104 	addi	r7,sp,4
81124194:	21400117 	ldw	r5,4(r4)
81124198:	112a49c0 	call	8112a49c <_vfscanf_r>
8112419c:	dfc00017 	ldw	ra,0(sp)
811241a0:	dec00404 	addi	sp,sp,16
811241a4:	f800283a 	ret

811241a8 <_scanf_r>:
811241a8:	defffd04 	addi	sp,sp,-12
811241ac:	2805883a 	mov	r2,r5
811241b0:	de00012e 	bgeu	sp,et,811241b8 <_scanf_r+0x10>
811241b4:	003b68fa 	trap	3
811241b8:	dfc00015 	stw	ra,0(sp)
811241bc:	d9800115 	stw	r6,4(sp)
811241c0:	d9c00215 	stw	r7,8(sp)
811241c4:	21400117 	ldw	r5,4(r4)
811241c8:	d9c00104 	addi	r7,sp,4
811241cc:	100d883a 	mov	r6,r2
811241d0:	112a49c0 	call	8112a49c <_vfscanf_r>
811241d4:	dfc00017 	ldw	ra,0(sp)
811241d8:	dec00304 	addi	sp,sp,12
811241dc:	f800283a 	ret

811241e0 <_sprintf_r>:
811241e0:	deffe404 	addi	sp,sp,-112
811241e4:	2807883a 	mov	r3,r5
811241e8:	de00012e 	bgeu	sp,et,811241f0 <_sprintf_r+0x10>
811241ec:	003b68fa 	trap	3
811241f0:	dfc01a15 	stw	ra,104(sp)
811241f4:	d9c01b15 	stw	r7,108(sp)
811241f8:	00a00034 	movhi	r2,32768
811241fc:	10bfffc4 	addi	r2,r2,-1
81124200:	02008204 	movi	r8,520
81124204:	d8800215 	stw	r2,8(sp)
81124208:	d8800515 	stw	r2,20(sp)
8112420c:	d9c01b04 	addi	r7,sp,108
81124210:	d80b883a 	mov	r5,sp
81124214:	00bfffc4 	movi	r2,-1
81124218:	d8c00015 	stw	r3,0(sp)
8112421c:	d8c00415 	stw	r3,16(sp)
81124220:	da00030d 	sth	r8,12(sp)
81124224:	d880038d 	sth	r2,14(sp)
81124228:	112478c0 	call	8112478c <___svfprintf_internal_r>
8112422c:	d8c00017 	ldw	r3,0(sp)
81124230:	18000005 	stb	zero,0(r3)
81124234:	dfc01a17 	ldw	ra,104(sp)
81124238:	dec01c04 	addi	sp,sp,112
8112423c:	f800283a 	ret

81124240 <sprintf>:
81124240:	deffe304 	addi	sp,sp,-116
81124244:	2007883a 	mov	r3,r4
81124248:	de00012e 	bgeu	sp,et,81124250 <sprintf+0x10>
8112424c:	003b68fa 	trap	3
81124250:	dfc01a15 	stw	ra,104(sp)
81124254:	d9801b15 	stw	r6,108(sp)
81124258:	d9c01c15 	stw	r7,112(sp)
8112425c:	01204574 	movhi	r4,33045
81124260:	2110f104 	addi	r4,r4,17348
81124264:	21000017 	ldw	r4,0(r4)
81124268:	00a00034 	movhi	r2,32768
8112426c:	10bfffc4 	addi	r2,r2,-1
81124270:	280d883a 	mov	r6,r5
81124274:	02008204 	movi	r8,520
81124278:	d8800215 	stw	r2,8(sp)
8112427c:	d8800515 	stw	r2,20(sp)
81124280:	d9c01b04 	addi	r7,sp,108
81124284:	d80b883a 	mov	r5,sp
81124288:	00bfffc4 	movi	r2,-1
8112428c:	d8c00015 	stw	r3,0(sp)
81124290:	d8c00415 	stw	r3,16(sp)
81124294:	da00030d 	sth	r8,12(sp)
81124298:	d880038d 	sth	r2,14(sp)
8112429c:	112478c0 	call	8112478c <___svfprintf_internal_r>
811242a0:	d8c00017 	ldw	r3,0(sp)
811242a4:	18000005 	stb	zero,0(r3)
811242a8:	dfc01a17 	ldw	ra,104(sp)
811242ac:	dec01d04 	addi	sp,sp,116
811242b0:	f800283a 	ret

811242b4 <__sread>:
811242b4:	defffe04 	addi	sp,sp,-8
811242b8:	de00012e 	bgeu	sp,et,811242c0 <__sread+0xc>
811242bc:	003b68fa 	trap	3
811242c0:	dc000015 	stw	r16,0(sp)
811242c4:	2821883a 	mov	r16,r5
811242c8:	2940038f 	ldh	r5,14(r5)
811242cc:	dfc00115 	stw	ra,4(sp)
811242d0:	112ebec0 	call	8112ebec <_read_r>
811242d4:	10000716 	blt	r2,zero,811242f4 <__sread+0x40>
811242d8:	80c01417 	ldw	r3,80(r16)
811242dc:	1887883a 	add	r3,r3,r2
811242e0:	80c01415 	stw	r3,80(r16)
811242e4:	dfc00117 	ldw	ra,4(sp)
811242e8:	dc000017 	ldw	r16,0(sp)
811242ec:	dec00204 	addi	sp,sp,8
811242f0:	f800283a 	ret
811242f4:	80c0030b 	ldhu	r3,12(r16)
811242f8:	18fbffcc 	andi	r3,r3,61439
811242fc:	80c0030d 	sth	r3,12(r16)
81124300:	dfc00117 	ldw	ra,4(sp)
81124304:	dc000017 	ldw	r16,0(sp)
81124308:	dec00204 	addi	sp,sp,8
8112430c:	f800283a 	ret

81124310 <__seofread>:
81124310:	0005883a 	mov	r2,zero
81124314:	f800283a 	ret

81124318 <__swrite>:
81124318:	defffb04 	addi	sp,sp,-20
8112431c:	de00012e 	bgeu	sp,et,81124324 <__swrite+0xc>
81124320:	003b68fa 	trap	3
81124324:	2880030b 	ldhu	r2,12(r5)
81124328:	dcc00315 	stw	r19,12(sp)
8112432c:	dc800215 	stw	r18,8(sp)
81124330:	dc400115 	stw	r17,4(sp)
81124334:	dc000015 	stw	r16,0(sp)
81124338:	dfc00415 	stw	ra,16(sp)
8112433c:	10c0400c 	andi	r3,r2,256
81124340:	2821883a 	mov	r16,r5
81124344:	2023883a 	mov	r17,r4
81124348:	3025883a 	mov	r18,r6
8112434c:	3827883a 	mov	r19,r7
81124350:	18000526 	beq	r3,zero,81124368 <__swrite+0x50>
81124354:	2940038f 	ldh	r5,14(r5)
81124358:	01c00084 	movi	r7,2
8112435c:	000d883a 	mov	r6,zero
81124360:	112d6a40 	call	8112d6a4 <_lseek_r>
81124364:	8080030b 	ldhu	r2,12(r16)
81124368:	8140038f 	ldh	r5,14(r16)
8112436c:	10bbffcc 	andi	r2,r2,61439
81124370:	980f883a 	mov	r7,r19
81124374:	900d883a 	mov	r6,r18
81124378:	8809883a 	mov	r4,r17
8112437c:	8080030d 	sth	r2,12(r16)
81124380:	dfc00417 	ldw	ra,16(sp)
81124384:	dcc00317 	ldw	r19,12(sp)
81124388:	dc800217 	ldw	r18,8(sp)
8112438c:	dc400117 	ldw	r17,4(sp)
81124390:	dc000017 	ldw	r16,0(sp)
81124394:	dec00504 	addi	sp,sp,20
81124398:	112a6501 	jmpi	8112a650 <_write_r>

8112439c <__sseek>:
8112439c:	defffe04 	addi	sp,sp,-8
811243a0:	de00012e 	bgeu	sp,et,811243a8 <__sseek+0xc>
811243a4:	003b68fa 	trap	3
811243a8:	dc000015 	stw	r16,0(sp)
811243ac:	2821883a 	mov	r16,r5
811243b0:	2940038f 	ldh	r5,14(r5)
811243b4:	dfc00115 	stw	ra,4(sp)
811243b8:	112d6a40 	call	8112d6a4 <_lseek_r>
811243bc:	00ffffc4 	movi	r3,-1
811243c0:	10c00826 	beq	r2,r3,811243e4 <__sseek+0x48>
811243c4:	80c0030b 	ldhu	r3,12(r16)
811243c8:	80801415 	stw	r2,80(r16)
811243cc:	18c40014 	ori	r3,r3,4096
811243d0:	80c0030d 	sth	r3,12(r16)
811243d4:	dfc00117 	ldw	ra,4(sp)
811243d8:	dc000017 	ldw	r16,0(sp)
811243dc:	dec00204 	addi	sp,sp,8
811243e0:	f800283a 	ret
811243e4:	80c0030b 	ldhu	r3,12(r16)
811243e8:	18fbffcc 	andi	r3,r3,61439
811243ec:	80c0030d 	sth	r3,12(r16)
811243f0:	dfc00117 	ldw	ra,4(sp)
811243f4:	dc000017 	ldw	r16,0(sp)
811243f8:	dec00204 	addi	sp,sp,8
811243fc:	f800283a 	ret

81124400 <__sclose>:
81124400:	2940038f 	ldh	r5,14(r5)
81124404:	112a8141 	jmpi	8112a814 <_close_r>

81124408 <strcspn>:
81124408:	21c00007 	ldb	r7,0(r4)
8112440c:	38000f26 	beq	r7,zero,8112444c <strcspn+0x44>
81124410:	2a000007 	ldb	r8,0(r5)
81124414:	2005883a 	mov	r2,r4
81124418:	40000726 	beq	r8,zero,81124438 <strcspn+0x30>
8112441c:	3a000926 	beq	r7,r8,81124444 <strcspn+0x3c>
81124420:	2807883a 	mov	r3,r5
81124424:	00000106 	br	8112442c <strcspn+0x24>
81124428:	31c00626 	beq	r6,r7,81124444 <strcspn+0x3c>
8112442c:	18c00044 	addi	r3,r3,1
81124430:	19800007 	ldb	r6,0(r3)
81124434:	303ffc1e 	bne	r6,zero,81124428 <__reset+0xfb104428>
81124438:	10800044 	addi	r2,r2,1
8112443c:	11c00007 	ldb	r7,0(r2)
81124440:	383ff51e 	bne	r7,zero,81124418 <__reset+0xfb104418>
81124444:	1105c83a 	sub	r2,r2,r4
81124448:	f800283a 	ret
8112444c:	0005883a 	mov	r2,zero
81124450:	f800283a 	ret

81124454 <strlen>:
81124454:	208000cc 	andi	r2,r4,3
81124458:	10002026 	beq	r2,zero,811244dc <strlen+0x88>
8112445c:	20800007 	ldb	r2,0(r4)
81124460:	10002026 	beq	r2,zero,811244e4 <strlen+0x90>
81124464:	2005883a 	mov	r2,r4
81124468:	00000206 	br	81124474 <strlen+0x20>
8112446c:	10c00007 	ldb	r3,0(r2)
81124470:	18001826 	beq	r3,zero,811244d4 <strlen+0x80>
81124474:	10800044 	addi	r2,r2,1
81124478:	10c000cc 	andi	r3,r2,3
8112447c:	183ffb1e 	bne	r3,zero,8112446c <__reset+0xfb10446c>
81124480:	10c00017 	ldw	r3,0(r2)
81124484:	01ffbff4 	movhi	r7,65279
81124488:	39ffbfc4 	addi	r7,r7,-257
8112448c:	00ca303a 	nor	r5,zero,r3
81124490:	01a02074 	movhi	r6,32897
81124494:	19c7883a 	add	r3,r3,r7
81124498:	31a02004 	addi	r6,r6,-32640
8112449c:	1946703a 	and	r3,r3,r5
811244a0:	1986703a 	and	r3,r3,r6
811244a4:	1800091e 	bne	r3,zero,811244cc <strlen+0x78>
811244a8:	10800104 	addi	r2,r2,4
811244ac:	10c00017 	ldw	r3,0(r2)
811244b0:	19cb883a 	add	r5,r3,r7
811244b4:	00c6303a 	nor	r3,zero,r3
811244b8:	28c6703a 	and	r3,r5,r3
811244bc:	1986703a 	and	r3,r3,r6
811244c0:	183ff926 	beq	r3,zero,811244a8 <__reset+0xfb1044a8>
811244c4:	00000106 	br	811244cc <strlen+0x78>
811244c8:	10800044 	addi	r2,r2,1
811244cc:	10c00007 	ldb	r3,0(r2)
811244d0:	183ffd1e 	bne	r3,zero,811244c8 <__reset+0xfb1044c8>
811244d4:	1105c83a 	sub	r2,r2,r4
811244d8:	f800283a 	ret
811244dc:	2005883a 	mov	r2,r4
811244e0:	003fe706 	br	81124480 <__reset+0xfb104480>
811244e4:	0005883a 	mov	r2,zero
811244e8:	f800283a 	ret

811244ec <strnlen>:
811244ec:	28000e26 	beq	r5,zero,81124528 <strnlen+0x3c>
811244f0:	20800007 	ldb	r2,0(r4)
811244f4:	10000c26 	beq	r2,zero,81124528 <strnlen+0x3c>
811244f8:	20c00044 	addi	r3,r4,1
811244fc:	214b883a 	add	r5,r4,r5
81124500:	28c00526 	beq	r5,r3,81124518 <strnlen+0x2c>
81124504:	19800007 	ldb	r6,0(r3)
81124508:	19c00044 	addi	r7,r3,1
8112450c:	30000426 	beq	r6,zero,81124520 <strnlen+0x34>
81124510:	3807883a 	mov	r3,r7
81124514:	28fffb1e 	bne	r5,r3,81124504 <__reset+0xfb104504>
81124518:	2905c83a 	sub	r2,r5,r4
8112451c:	f800283a 	ret
81124520:	1905c83a 	sub	r2,r3,r4
81124524:	f800283a 	ret
81124528:	0005883a 	mov	r2,zero
8112452c:	f800283a 	ret

81124530 <_strtol_r>:
81124530:	00a04574 	movhi	r2,33045
81124534:	defff404 	addi	sp,sp,-48
81124538:	1090ef04 	addi	r2,r2,17340
8112453c:	de00012e 	bgeu	sp,et,81124544 <_strtol_r+0x14>
81124540:	003b68fa 	trap	3
81124544:	dd400715 	stw	r21,28(sp)
81124548:	15400017 	ldw	r21,0(r2)
8112454c:	dd800815 	stw	r22,32(sp)
81124550:	dd000615 	stw	r20,24(sp)
81124554:	dcc00515 	stw	r19,20(sp)
81124558:	d9000015 	stw	r4,0(sp)
8112455c:	dfc00b15 	stw	ra,44(sp)
81124560:	df000a15 	stw	fp,40(sp)
81124564:	ddc00915 	stw	r23,36(sp)
81124568:	dc800415 	stw	r18,16(sp)
8112456c:	dc400315 	stw	r17,12(sp)
81124570:	dc000215 	stw	r16,8(sp)
81124574:	2829883a 	mov	r20,r5
81124578:	3027883a 	mov	r19,r6
8112457c:	382d883a 	mov	r22,r7
81124580:	2809883a 	mov	r4,r5
81124584:	24000003 	ldbu	r16,0(r4)
81124588:	24400044 	addi	r17,r4,1
8112458c:	2007883a 	mov	r3,r4
81124590:	ac05883a 	add	r2,r21,r16
81124594:	10800043 	ldbu	r2,1(r2)
81124598:	8809883a 	mov	r4,r17
8112459c:	1080020c 	andi	r2,r2,8
811245a0:	103ff81e 	bne	r2,zero,81124584 <__reset+0xfb104584>
811245a4:	00800b44 	movi	r2,45
811245a8:	80805826 	beq	r16,r2,8112470c <_strtol_r+0x1dc>
811245ac:	00800ac4 	movi	r2,43
811245b0:	80805a26 	beq	r16,r2,8112471c <_strtol_r+0x1ec>
811245b4:	0039883a 	mov	fp,zero
811245b8:	b0004426 	beq	r22,zero,811246cc <_strtol_r+0x19c>
811245bc:	00800404 	movi	r2,16
811245c0:	b0806026 	beq	r22,r2,81124744 <_strtol_r+0x214>
811245c4:	b02f883a 	mov	r23,r22
811245c8:	00a00034 	movhi	r2,32768
811245cc:	e025003a 	cmpeq	r18,fp,zero
811245d0:	14a5c83a 	sub	r18,r2,r18
811245d4:	b80b883a 	mov	r5,r23
811245d8:	9009883a 	mov	r4,r18
811245dc:	1135f300 	call	81135f30 <__umodsi3>
811245e0:	b80b883a 	mov	r5,r23
811245e4:	9009883a 	mov	r4,r18
811245e8:	d8800115 	stw	r2,4(sp)
811245ec:	1135ecc0 	call	81135ecc <__udivsi3>
811245f0:	ac07883a 	add	r3,r21,r16
811245f4:	18c00043 	ldbu	r3,1(r3)
811245f8:	880b883a 	mov	r5,r17
811245fc:	000d883a 	mov	r6,zero
81124600:	1a00010c 	andi	r8,r3,4
81124604:	0009883a 	mov	r4,zero
81124608:	02800044 	movi	r10,1
8112460c:	027fffc4 	movi	r9,-1
81124610:	d9c00117 	ldw	r7,4(sp)
81124614:	40000e26 	beq	r8,zero,81124650 <_strtol_r+0x120>
81124618:	843ff404 	addi	r16,r16,-48
8112461c:	8580120e 	bge	r16,r22,81124668 <_strtol_r+0x138>
81124620:	32400526 	beq	r6,r9,81124638 <_strtol_r+0x108>
81124624:	11002536 	bltu	r2,r4,811246bc <_strtol_r+0x18c>
81124628:	20802326 	beq	r4,r2,811246b8 <_strtol_r+0x188>
8112462c:	25c9383a 	mul	r4,r4,r23
81124630:	01800044 	movi	r6,1
81124634:	8109883a 	add	r4,r16,r4
81124638:	2c000003 	ldbu	r16,0(r5)
8112463c:	29400044 	addi	r5,r5,1
81124640:	ac07883a 	add	r3,r21,r16
81124644:	18c00043 	ldbu	r3,1(r3)
81124648:	1a00010c 	andi	r8,r3,4
8112464c:	403ff21e 	bne	r8,zero,81124618 <__reset+0xfb104618>
81124650:	18c000cc 	andi	r3,r3,3
81124654:	18000426 	beq	r3,zero,81124668 <_strtol_r+0x138>
81124658:	1a801a26 	beq	r3,r10,811246c4 <_strtol_r+0x194>
8112465c:	00c015c4 	movi	r3,87
81124660:	80e1c83a 	sub	r16,r16,r3
81124664:	85bfee16 	blt	r16,r22,81124620 <__reset+0xfb104620>
81124668:	00bfffc4 	movi	r2,-1
8112466c:	30801e26 	beq	r6,r2,811246e8 <_strtol_r+0x1b8>
81124670:	e0001b1e 	bne	fp,zero,811246e0 <_strtol_r+0x1b0>
81124674:	2005883a 	mov	r2,r4
81124678:	98000326 	beq	r19,zero,81124688 <_strtol_r+0x158>
8112467c:	3000211e 	bne	r6,zero,81124704 <_strtol_r+0x1d4>
81124680:	a00b883a 	mov	r5,r20
81124684:	99400015 	stw	r5,0(r19)
81124688:	dfc00b17 	ldw	ra,44(sp)
8112468c:	df000a17 	ldw	fp,40(sp)
81124690:	ddc00917 	ldw	r23,36(sp)
81124694:	dd800817 	ldw	r22,32(sp)
81124698:	dd400717 	ldw	r21,28(sp)
8112469c:	dd000617 	ldw	r20,24(sp)
811246a0:	dcc00517 	ldw	r19,20(sp)
811246a4:	dc800417 	ldw	r18,16(sp)
811246a8:	dc400317 	ldw	r17,12(sp)
811246ac:	dc000217 	ldw	r16,8(sp)
811246b0:	dec00c04 	addi	sp,sp,48
811246b4:	f800283a 	ret
811246b8:	3c3fdc0e 	bge	r7,r16,8112462c <__reset+0xfb10462c>
811246bc:	01bfffc4 	movi	r6,-1
811246c0:	003fdd06 	br	81124638 <__reset+0xfb104638>
811246c4:	00c00dc4 	movi	r3,55
811246c8:	003fe506 	br	81124660 <__reset+0xfb104660>
811246cc:	00800c04 	movi	r2,48
811246d0:	80801626 	beq	r16,r2,8112472c <_strtol_r+0x1fc>
811246d4:	05800284 	movi	r22,10
811246d8:	b02f883a 	mov	r23,r22
811246dc:	003fba06 	br	811245c8 <__reset+0xfb1045c8>
811246e0:	0109c83a 	sub	r4,zero,r4
811246e4:	003fe306 	br	81124674 <__reset+0xfb104674>
811246e8:	d9000017 	ldw	r4,0(sp)
811246ec:	00c00884 	movi	r3,34
811246f0:	e005003a 	cmpeq	r2,fp,zero
811246f4:	20c00015 	stw	r3,0(r4)
811246f8:	00e00034 	movhi	r3,32768
811246fc:	1885c83a 	sub	r2,r3,r2
81124700:	983fe126 	beq	r19,zero,81124688 <__reset+0xfb104688>
81124704:	297fffc4 	addi	r5,r5,-1
81124708:	003fde06 	br	81124684 <__reset+0xfb104684>
8112470c:	1c400084 	addi	r17,r3,2
81124710:	1c000043 	ldbu	r16,1(r3)
81124714:	07000044 	movi	fp,1
81124718:	003fa706 	br	811245b8 <__reset+0xfb1045b8>
8112471c:	1c400084 	addi	r17,r3,2
81124720:	1c000043 	ldbu	r16,1(r3)
81124724:	0039883a 	mov	fp,zero
81124728:	003fa306 	br	811245b8 <__reset+0xfb1045b8>
8112472c:	88800003 	ldbu	r2,0(r17)
81124730:	00c01604 	movi	r3,88
81124734:	108037cc 	andi	r2,r2,223
81124738:	10c00826 	beq	r2,r3,8112475c <_strtol_r+0x22c>
8112473c:	05800204 	movi	r22,8
81124740:	003fa006 	br	811245c4 <__reset+0xfb1045c4>
81124744:	00800c04 	movi	r2,48
81124748:	80bf9e1e 	bne	r16,r2,811245c4 <__reset+0xfb1045c4>
8112474c:	88800003 	ldbu	r2,0(r17)
81124750:	00c01604 	movi	r3,88
81124754:	108037cc 	andi	r2,r2,223
81124758:	10ff9a1e 	bne	r2,r3,811245c4 <__reset+0xfb1045c4>
8112475c:	05c00404 	movi	r23,16
81124760:	8c000043 	ldbu	r16,1(r17)
81124764:	b82d883a 	mov	r22,r23
81124768:	8c400084 	addi	r17,r17,2
8112476c:	003f9606 	br	811245c8 <__reset+0xfb1045c8>

81124770 <strtol>:
81124770:	00a04574 	movhi	r2,33045
81124774:	1090f104 	addi	r2,r2,17348
81124778:	300f883a 	mov	r7,r6
8112477c:	280d883a 	mov	r6,r5
81124780:	200b883a 	mov	r5,r4
81124784:	11000017 	ldw	r4,0(r2)
81124788:	11245301 	jmpi	81124530 <_strtol_r>

8112478c <___svfprintf_internal_r>:
8112478c:	deffb704 	addi	sp,sp,-292
81124790:	de00012e 	bgeu	sp,et,81124798 <___svfprintf_internal_r+0xc>
81124794:	003b68fa 	trap	3
81124798:	dfc04815 	stw	ra,288(sp)
8112479c:	ddc04615 	stw	r23,280(sp)
811247a0:	d9402c15 	stw	r5,176(sp)
811247a4:	d9003915 	stw	r4,228(sp)
811247a8:	302f883a 	mov	r23,r6
811247ac:	d9c02d15 	stw	r7,180(sp)
811247b0:	df004715 	stw	fp,284(sp)
811247b4:	dd804515 	stw	r22,276(sp)
811247b8:	dd404415 	stw	r21,272(sp)
811247bc:	dd004315 	stw	r20,268(sp)
811247c0:	dcc04215 	stw	r19,264(sp)
811247c4:	dc804115 	stw	r18,260(sp)
811247c8:	dc404015 	stw	r17,256(sp)
811247cc:	dc003f15 	stw	r16,252(sp)
811247d0:	112d6740 	call	8112d674 <_localeconv_r>
811247d4:	10800017 	ldw	r2,0(r2)
811247d8:	1009883a 	mov	r4,r2
811247dc:	d8803415 	stw	r2,208(sp)
811247e0:	11244540 	call	81124454 <strlen>
811247e4:	d8c02c17 	ldw	r3,176(sp)
811247e8:	d8803815 	stw	r2,224(sp)
811247ec:	1880030b 	ldhu	r2,12(r3)
811247f0:	1080200c 	andi	r2,r2,128
811247f4:	10000226 	beq	r2,zero,81124800 <___svfprintf_internal_r+0x74>
811247f8:	18800417 	ldw	r2,16(r3)
811247fc:	10067f26 	beq	r2,zero,811261fc <___svfprintf_internal_r+0x1a70>
81124800:	dcc03917 	ldw	r19,228(sp)
81124804:	d8c00404 	addi	r3,sp,16
81124808:	05604574 	movhi	r21,33045
8112480c:	d9001e04 	addi	r4,sp,120
81124810:	ad472984 	addi	r21,r21,7334
81124814:	d8c01e15 	stw	r3,120(sp)
81124818:	d8002015 	stw	zero,128(sp)
8112481c:	d8001f15 	stw	zero,124(sp)
81124820:	d8003315 	stw	zero,204(sp)
81124824:	d8003615 	stw	zero,216(sp)
81124828:	d8003715 	stw	zero,220(sp)
8112482c:	1811883a 	mov	r8,r3
81124830:	d8003a15 	stw	zero,232(sp)
81124834:	d8003b15 	stw	zero,236(sp)
81124838:	d8002f15 	stw	zero,188(sp)
8112483c:	d9002815 	stw	r4,160(sp)
81124840:	b8800007 	ldb	r2,0(r23)
81124844:	10026726 	beq	r2,zero,811251e4 <___svfprintf_internal_r+0xa58>
81124848:	00c00944 	movi	r3,37
8112484c:	b821883a 	mov	r16,r23
81124850:	10c0021e 	bne	r2,r3,8112485c <___svfprintf_internal_r+0xd0>
81124854:	00001406 	br	811248a8 <___svfprintf_internal_r+0x11c>
81124858:	10c00326 	beq	r2,r3,81124868 <___svfprintf_internal_r+0xdc>
8112485c:	84000044 	addi	r16,r16,1
81124860:	80800007 	ldb	r2,0(r16)
81124864:	103ffc1e 	bne	r2,zero,81124858 <__reset+0xfb104858>
81124868:	85e3c83a 	sub	r17,r16,r23
8112486c:	88000e26 	beq	r17,zero,811248a8 <___svfprintf_internal_r+0x11c>
81124870:	d8c02017 	ldw	r3,128(sp)
81124874:	d8801f17 	ldw	r2,124(sp)
81124878:	45c00015 	stw	r23,0(r8)
8112487c:	1c47883a 	add	r3,r3,r17
81124880:	10800044 	addi	r2,r2,1
81124884:	d8c02015 	stw	r3,128(sp)
81124888:	44400115 	stw	r17,4(r8)
8112488c:	d8801f15 	stw	r2,124(sp)
81124890:	00c001c4 	movi	r3,7
81124894:	18809716 	blt	r3,r2,81124af4 <___svfprintf_internal_r+0x368>
81124898:	42000204 	addi	r8,r8,8
8112489c:	d9402f17 	ldw	r5,188(sp)
811248a0:	2c4b883a 	add	r5,r5,r17
811248a4:	d9402f15 	stw	r5,188(sp)
811248a8:	80800007 	ldb	r2,0(r16)
811248ac:	10009826 	beq	r2,zero,81124b10 <___svfprintf_internal_r+0x384>
811248b0:	84400047 	ldb	r17,1(r16)
811248b4:	00bfffc4 	movi	r2,-1
811248b8:	85c00044 	addi	r23,r16,1
811248bc:	d8002785 	stb	zero,158(sp)
811248c0:	0007883a 	mov	r3,zero
811248c4:	000f883a 	mov	r7,zero
811248c8:	d8802915 	stw	r2,164(sp)
811248cc:	d8003115 	stw	zero,196(sp)
811248d0:	0025883a 	mov	r18,zero
811248d4:	01401604 	movi	r5,88
811248d8:	01800244 	movi	r6,9
811248dc:	02800a84 	movi	r10,42
811248e0:	02401b04 	movi	r9,108
811248e4:	bdc00044 	addi	r23,r23,1
811248e8:	88bff804 	addi	r2,r17,-32
811248ec:	2882f036 	bltu	r5,r2,811254b0 <___svfprintf_internal_r+0xd24>
811248f0:	100490ba 	slli	r2,r2,2
811248f4:	012044b4 	movhi	r4,33042
811248f8:	21124204 	addi	r4,r4,18696
811248fc:	1105883a 	add	r2,r2,r4
81124900:	10800017 	ldw	r2,0(r2)
81124904:	1000683a 	jmp	r2
81124908:	81125418 	cmpnei	r4,r16,18768
8112490c:	811254b0 	cmpltui	r4,r16,18770
81124910:	811254b0 	cmpltui	r4,r16,18770
81124914:	8112540c 	andi	r4,r16,18768
81124918:	811254b0 	cmpltui	r4,r16,18770
8112491c:	811254b0 	cmpltui	r4,r16,18770
81124920:	811254b0 	cmpltui	r4,r16,18770
81124924:	811254b0 	cmpltui	r4,r16,18770
81124928:	811254b0 	cmpltui	r4,r16,18770
8112492c:	811254b0 	cmpltui	r4,r16,18770
81124930:	81124b6c 	andhi	r4,r16,18733
81124934:	81125348 	cmpgei	r4,r16,18765
81124938:	811254b0 	cmpltui	r4,r16,18770
8112493c:	81124a7c 	xorhi	r4,r16,18729
81124940:	81124b94 	ori	r4,r16,18734
81124944:	811254b0 	cmpltui	r4,r16,18770
81124948:	81124c08 	cmpgei	r4,r16,18736
8112494c:	81124bd4 	ori	r4,r16,18735
81124950:	81124bd4 	ori	r4,r16,18735
81124954:	81124bd4 	ori	r4,r16,18735
81124958:	81124bd4 	ori	r4,r16,18735
8112495c:	81124bd4 	ori	r4,r16,18735
81124960:	81124bd4 	ori	r4,r16,18735
81124964:	81124bd4 	ori	r4,r16,18735
81124968:	81124bd4 	ori	r4,r16,18735
8112496c:	81124bd4 	ori	r4,r16,18735
81124970:	811254b0 	cmpltui	r4,r16,18770
81124974:	811254b0 	cmpltui	r4,r16,18770
81124978:	811254b0 	cmpltui	r4,r16,18770
8112497c:	811254b0 	cmpltui	r4,r16,18770
81124980:	811254b0 	cmpltui	r4,r16,18770
81124984:	811254b0 	cmpltui	r4,r16,18770
81124988:	811254b0 	cmpltui	r4,r16,18770
8112498c:	811254b0 	cmpltui	r4,r16,18770
81124990:	811254b0 	cmpltui	r4,r16,18770
81124994:	811254b0 	cmpltui	r4,r16,18770
81124998:	81124cc0 	call	881124cc <__reset+0x20f24cc>
8112499c:	81124c14 	ori	r4,r16,18736
811249a0:	811254b0 	cmpltui	r4,r16,18770
811249a4:	81124c14 	ori	r4,r16,18736
811249a8:	811254b0 	cmpltui	r4,r16,18770
811249ac:	811254b0 	cmpltui	r4,r16,18770
811249b0:	811254b0 	cmpltui	r4,r16,18770
811249b4:	811254b0 	cmpltui	r4,r16,18770
811249b8:	81124cb4 	orhi	r4,r16,18738
811249bc:	811254b0 	cmpltui	r4,r16,18770
811249c0:	811254b0 	cmpltui	r4,r16,18770
811249c4:	81124d7c 	xorhi	r4,r16,18741
811249c8:	811254b0 	cmpltui	r4,r16,18770
811249cc:	811254b0 	cmpltui	r4,r16,18770
811249d0:	811254b0 	cmpltui	r4,r16,18770
811249d4:	811254b0 	cmpltui	r4,r16,18770
811249d8:	811254b0 	cmpltui	r4,r16,18770
811249dc:	811251ec 	andhi	r4,r16,18759
811249e0:	811254b0 	cmpltui	r4,r16,18770
811249e4:	811254b0 	cmpltui	r4,r16,18770
811249e8:	8112524c 	andi	r4,r16,18761
811249ec:	811254b0 	cmpltui	r4,r16,18770
811249f0:	811254b0 	cmpltui	r4,r16,18770
811249f4:	811254b0 	cmpltui	r4,r16,18770
811249f8:	811254b0 	cmpltui	r4,r16,18770
811249fc:	811254b0 	cmpltui	r4,r16,18770
81124a00:	811254b0 	cmpltui	r4,r16,18770
81124a04:	811254b0 	cmpltui	r4,r16,18770
81124a08:	811254b0 	cmpltui	r4,r16,18770
81124a0c:	811254b0 	cmpltui	r4,r16,18770
81124a10:	811254b0 	cmpltui	r4,r16,18770
81124a14:	811252fc 	xorhi	r4,r16,18763
81124a18:	81125438 	rdprs	r4,r16,18768
81124a1c:	81124c14 	ori	r4,r16,18736
81124a20:	81124c14 	ori	r4,r16,18736
81124a24:	81124c14 	ori	r4,r16,18736
81124a28:	8112548c 	andi	r4,r16,18770
81124a2c:	81125438 	rdprs	r4,r16,18768
81124a30:	811254b0 	cmpltui	r4,r16,18770
81124a34:	811254b0 	cmpltui	r4,r16,18770
81124a38:	81125448 	cmpgei	r4,r16,18769
81124a3c:	811254b0 	cmpltui	r4,r16,18770
81124a40:	81125458 	cmpnei	r4,r16,18769
81124a44:	81125338 	rdprs	r4,r16,18764
81124a48:	81124a88 	cmpgei	r4,r16,18730
81124a4c:	81125358 	cmpnei	r4,r16,18765
81124a50:	811254b0 	cmpltui	r4,r16,18770
81124a54:	81125364 	muli	r4,r16,18765
81124a58:	811254b0 	cmpltui	r4,r16,18770
81124a5c:	811253c0 	call	8811253c <__reset+0x20f253c>
81124a60:	811254b0 	cmpltui	r4,r16,18770
81124a64:	811254b0 	cmpltui	r4,r16,18770
81124a68:	811253d0 	cmplti	r4,r16,18767
81124a6c:	d9003117 	ldw	r4,196(sp)
81124a70:	d8802d15 	stw	r2,180(sp)
81124a74:	0109c83a 	sub	r4,zero,r4
81124a78:	d9003115 	stw	r4,196(sp)
81124a7c:	94800114 	ori	r18,r18,4
81124a80:	bc400007 	ldb	r17,0(r23)
81124a84:	003f9706 	br	811248e4 <__reset+0xfb1048e4>
81124a88:	00800c04 	movi	r2,48
81124a8c:	d9002d17 	ldw	r4,180(sp)
81124a90:	d9402917 	ldw	r5,164(sp)
81124a94:	d8802705 	stb	r2,156(sp)
81124a98:	00801e04 	movi	r2,120
81124a9c:	d8802745 	stb	r2,157(sp)
81124aa0:	d8002785 	stb	zero,158(sp)
81124aa4:	20c00104 	addi	r3,r4,4
81124aa8:	25000017 	ldw	r20,0(r4)
81124aac:	002d883a 	mov	r22,zero
81124ab0:	90800094 	ori	r2,r18,2
81124ab4:	28028616 	blt	r5,zero,811254d0 <___svfprintf_internal_r+0xd44>
81124ab8:	00bfdfc4 	movi	r2,-129
81124abc:	90a4703a 	and	r18,r18,r2
81124ac0:	d8c02d15 	stw	r3,180(sp)
81124ac4:	94800094 	ori	r18,r18,2
81124ac8:	a002731e 	bne	r20,zero,81125498 <___svfprintf_internal_r+0xd0c>
81124acc:	00a04574 	movhi	r2,33045
81124ad0:	10872204 	addi	r2,r2,7304
81124ad4:	d8803a15 	stw	r2,232(sp)
81124ad8:	04401e04 	movi	r17,120
81124adc:	d8c02917 	ldw	r3,164(sp)
81124ae0:	0039883a 	mov	fp,zero
81124ae4:	1801d526 	beq	r3,zero,8112523c <___svfprintf_internal_r+0xab0>
81124ae8:	0029883a 	mov	r20,zero
81124aec:	002d883a 	mov	r22,zero
81124af0:	0001f106 	br	811252b8 <___svfprintf_internal_r+0xb2c>
81124af4:	d9402c17 	ldw	r5,176(sp)
81124af8:	d9801e04 	addi	r6,sp,120
81124afc:	9809883a 	mov	r4,r19
81124b00:	11313ac0 	call	811313ac <__ssprint_r>
81124b04:	1000081e 	bne	r2,zero,81124b28 <___svfprintf_internal_r+0x39c>
81124b08:	da000404 	addi	r8,sp,16
81124b0c:	003f6306 	br	8112489c <__reset+0xfb10489c>
81124b10:	d8802017 	ldw	r2,128(sp)
81124b14:	10000426 	beq	r2,zero,81124b28 <___svfprintf_internal_r+0x39c>
81124b18:	d9402c17 	ldw	r5,176(sp)
81124b1c:	d9003917 	ldw	r4,228(sp)
81124b20:	d9801e04 	addi	r6,sp,120
81124b24:	11313ac0 	call	811313ac <__ssprint_r>
81124b28:	d8802c17 	ldw	r2,176(sp)
81124b2c:	10c0030b 	ldhu	r3,12(r2)
81124b30:	d8802f17 	ldw	r2,188(sp)
81124b34:	18c0100c 	andi	r3,r3,64
81124b38:	1805f51e 	bne	r3,zero,81126310 <___svfprintf_internal_r+0x1b84>
81124b3c:	dfc04817 	ldw	ra,288(sp)
81124b40:	df004717 	ldw	fp,284(sp)
81124b44:	ddc04617 	ldw	r23,280(sp)
81124b48:	dd804517 	ldw	r22,276(sp)
81124b4c:	dd404417 	ldw	r21,272(sp)
81124b50:	dd004317 	ldw	r20,268(sp)
81124b54:	dcc04217 	ldw	r19,264(sp)
81124b58:	dc804117 	ldw	r18,260(sp)
81124b5c:	dc404017 	ldw	r17,256(sp)
81124b60:	dc003f17 	ldw	r16,252(sp)
81124b64:	dec04904 	addi	sp,sp,292
81124b68:	f800283a 	ret
81124b6c:	d8802d17 	ldw	r2,180(sp)
81124b70:	d9002d17 	ldw	r4,180(sp)
81124b74:	10800017 	ldw	r2,0(r2)
81124b78:	d8803115 	stw	r2,196(sp)
81124b7c:	20800104 	addi	r2,r4,4
81124b80:	d9003117 	ldw	r4,196(sp)
81124b84:	203fb916 	blt	r4,zero,81124a6c <__reset+0xfb104a6c>
81124b88:	d8802d15 	stw	r2,180(sp)
81124b8c:	bc400007 	ldb	r17,0(r23)
81124b90:	003f5406 	br	811248e4 <__reset+0xfb1048e4>
81124b94:	bc400007 	ldb	r17,0(r23)
81124b98:	bac00044 	addi	r11,r23,1
81124b9c:	8a873926 	beq	r17,r10,81126884 <___svfprintf_internal_r+0x20f8>
81124ba0:	88bff404 	addi	r2,r17,-48
81124ba4:	0009883a 	mov	r4,zero
81124ba8:	30868836 	bltu	r6,r2,811265cc <___svfprintf_internal_r+0x1e40>
81124bac:	5c400007 	ldb	r17,0(r11)
81124bb0:	210002a4 	muli	r4,r4,10
81124bb4:	5dc00044 	addi	r23,r11,1
81124bb8:	b817883a 	mov	r11,r23
81124bbc:	2089883a 	add	r4,r4,r2
81124bc0:	88bff404 	addi	r2,r17,-48
81124bc4:	30bff92e 	bgeu	r6,r2,81124bac <__reset+0xfb104bac>
81124bc8:	2005d716 	blt	r4,zero,81126328 <___svfprintf_internal_r+0x1b9c>
81124bcc:	d9002915 	stw	r4,164(sp)
81124bd0:	003f4506 	br	811248e8 <__reset+0xfb1048e8>
81124bd4:	b809883a 	mov	r4,r23
81124bd8:	d8003115 	stw	zero,196(sp)
81124bdc:	88bff404 	addi	r2,r17,-48
81124be0:	0017883a 	mov	r11,zero
81124be4:	24400007 	ldb	r17,0(r4)
81124be8:	5ac002a4 	muli	r11,r11,10
81124bec:	bdc00044 	addi	r23,r23,1
81124bf0:	b809883a 	mov	r4,r23
81124bf4:	12d7883a 	add	r11,r2,r11
81124bf8:	88bff404 	addi	r2,r17,-48
81124bfc:	30bff92e 	bgeu	r6,r2,81124be4 <__reset+0xfb104be4>
81124c00:	dac03115 	stw	r11,196(sp)
81124c04:	003f3806 	br	811248e8 <__reset+0xfb1048e8>
81124c08:	94802014 	ori	r18,r18,128
81124c0c:	bc400007 	ldb	r17,0(r23)
81124c10:	003f3406 	br	811248e4 <__reset+0xfb1048e4>
81124c14:	18c03fcc 	andi	r3,r3,255
81124c18:	1807471e 	bne	r3,zero,81126938 <___svfprintf_internal_r+0x21ac>
81124c1c:	9080020c 	andi	r2,r18,8
81124c20:	10047d26 	beq	r2,zero,81125e18 <___svfprintf_internal_r+0x168c>
81124c24:	d8c02d17 	ldw	r3,180(sp)
81124c28:	d9002d17 	ldw	r4,180(sp)
81124c2c:	d9402d17 	ldw	r5,180(sp)
81124c30:	18c00017 	ldw	r3,0(r3)
81124c34:	21000117 	ldw	r4,4(r4)
81124c38:	29400204 	addi	r5,r5,8
81124c3c:	d8c03615 	stw	r3,216(sp)
81124c40:	d9003715 	stw	r4,220(sp)
81124c44:	d9402d15 	stw	r5,180(sp)
81124c48:	d9003617 	ldw	r4,216(sp)
81124c4c:	d9403717 	ldw	r5,220(sp)
81124c50:	da003e15 	stw	r8,248(sp)
81124c54:	04000044 	movi	r16,1
81124c58:	112f1c00 	call	8112f1c0 <__fpclassifyd>
81124c5c:	da003e17 	ldw	r8,248(sp)
81124c60:	14044b1e 	bne	r2,r16,81125d90 <___svfprintf_internal_r+0x1604>
81124c64:	d9003617 	ldw	r4,216(sp)
81124c68:	d9403717 	ldw	r5,220(sp)
81124c6c:	000d883a 	mov	r6,zero
81124c70:	000f883a 	mov	r7,zero
81124c74:	11373b00 	call	811373b0 <__ledf2>
81124c78:	da003e17 	ldw	r8,248(sp)
81124c7c:	1005f316 	blt	r2,zero,8112644c <___svfprintf_internal_r+0x1cc0>
81124c80:	df002783 	ldbu	fp,158(sp)
81124c84:	008011c4 	movi	r2,71
81124c88:	1445590e 	bge	r2,r17,811261f0 <___svfprintf_internal_r+0x1a64>
81124c8c:	04204574 	movhi	r16,33045
81124c90:	84071a04 	addi	r16,r16,7272
81124c94:	00c000c4 	movi	r3,3
81124c98:	00bfdfc4 	movi	r2,-129
81124c9c:	d8c02a15 	stw	r3,168(sp)
81124ca0:	90a4703a 	and	r18,r18,r2
81124ca4:	d8c02e15 	stw	r3,184(sp)
81124ca8:	d8002915 	stw	zero,164(sp)
81124cac:	d8003215 	stw	zero,200(sp)
81124cb0:	00006606 	br	81124e4c <___svfprintf_internal_r+0x6c0>
81124cb4:	94800214 	ori	r18,r18,8
81124cb8:	bc400007 	ldb	r17,0(r23)
81124cbc:	003f0906 	br	811248e4 <__reset+0xfb1048e4>
81124cc0:	18c03fcc 	andi	r3,r3,255
81124cc4:	1807181e 	bne	r3,zero,81126928 <___svfprintf_internal_r+0x219c>
81124cc8:	94800414 	ori	r18,r18,16
81124ccc:	9080080c 	andi	r2,r18,32
81124cd0:	10039626 	beq	r2,zero,81125b2c <___svfprintf_internal_r+0x13a0>
81124cd4:	d9402d17 	ldw	r5,180(sp)
81124cd8:	28800117 	ldw	r2,4(r5)
81124cdc:	2d000017 	ldw	r20,0(r5)
81124ce0:	29400204 	addi	r5,r5,8
81124ce4:	d9402d15 	stw	r5,180(sp)
81124ce8:	102d883a 	mov	r22,r2
81124cec:	10039816 	blt	r2,zero,81125b50 <___svfprintf_internal_r+0x13c4>
81124cf0:	d9402917 	ldw	r5,164(sp)
81124cf4:	df002783 	ldbu	fp,158(sp)
81124cf8:	2803ab16 	blt	r5,zero,81125ba8 <___svfprintf_internal_r+0x141c>
81124cfc:	00ffdfc4 	movi	r3,-129
81124d00:	a584b03a 	or	r2,r20,r22
81124d04:	90e4703a 	and	r18,r18,r3
81124d08:	10014a26 	beq	r2,zero,81125234 <___svfprintf_internal_r+0xaa8>
81124d0c:	b0034b26 	beq	r22,zero,81125a3c <___svfprintf_internal_r+0x12b0>
81124d10:	dc402a15 	stw	r17,168(sp)
81124d14:	dc001e04 	addi	r16,sp,120
81124d18:	b023883a 	mov	r17,r22
81124d1c:	402d883a 	mov	r22,r8
81124d20:	a009883a 	mov	r4,r20
81124d24:	880b883a 	mov	r5,r17
81124d28:	01800284 	movi	r6,10
81124d2c:	000f883a 	mov	r7,zero
81124d30:	11358940 	call	81135894 <__umoddi3>
81124d34:	10800c04 	addi	r2,r2,48
81124d38:	843fffc4 	addi	r16,r16,-1
81124d3c:	a009883a 	mov	r4,r20
81124d40:	880b883a 	mov	r5,r17
81124d44:	80800005 	stb	r2,0(r16)
81124d48:	01800284 	movi	r6,10
81124d4c:	000f883a 	mov	r7,zero
81124d50:	11353140 	call	81135314 <__udivdi3>
81124d54:	1029883a 	mov	r20,r2
81124d58:	10c4b03a 	or	r2,r2,r3
81124d5c:	1823883a 	mov	r17,r3
81124d60:	103fef1e 	bne	r2,zero,81124d20 <__reset+0xfb104d20>
81124d64:	d8c02817 	ldw	r3,160(sp)
81124d68:	dc402a17 	ldw	r17,168(sp)
81124d6c:	b011883a 	mov	r8,r22
81124d70:	1c07c83a 	sub	r3,r3,r16
81124d74:	d8c02e15 	stw	r3,184(sp)
81124d78:	00002e06 	br	81124e34 <___svfprintf_internal_r+0x6a8>
81124d7c:	18c03fcc 	andi	r3,r3,255
81124d80:	1806e71e 	bne	r3,zero,81126920 <___svfprintf_internal_r+0x2194>
81124d84:	94800414 	ori	r18,r18,16
81124d88:	9080080c 	andi	r2,r18,32
81124d8c:	1002d426 	beq	r2,zero,811258e0 <___svfprintf_internal_r+0x1154>
81124d90:	d9402d17 	ldw	r5,180(sp)
81124d94:	d8c02917 	ldw	r3,164(sp)
81124d98:	d8002785 	stb	zero,158(sp)
81124d9c:	28800204 	addi	r2,r5,8
81124da0:	2d000017 	ldw	r20,0(r5)
81124da4:	2d800117 	ldw	r22,4(r5)
81124da8:	18041516 	blt	r3,zero,81125e00 <___svfprintf_internal_r+0x1674>
81124dac:	013fdfc4 	movi	r4,-129
81124db0:	a586b03a 	or	r3,r20,r22
81124db4:	d8802d15 	stw	r2,180(sp)
81124db8:	9124703a 	and	r18,r18,r4
81124dbc:	1802d51e 	bne	r3,zero,81125914 <___svfprintf_internal_r+0x1188>
81124dc0:	d9402917 	ldw	r5,164(sp)
81124dc4:	0039883a 	mov	fp,zero
81124dc8:	2806be26 	beq	r5,zero,811268c4 <___svfprintf_internal_r+0x2138>
81124dcc:	0029883a 	mov	r20,zero
81124dd0:	002d883a 	mov	r22,zero
81124dd4:	dc001e04 	addi	r16,sp,120
81124dd8:	a006d0fa 	srli	r3,r20,3
81124ddc:	b008977a 	slli	r4,r22,29
81124de0:	b02cd0fa 	srli	r22,r22,3
81124de4:	a50001cc 	andi	r20,r20,7
81124de8:	a0800c04 	addi	r2,r20,48
81124dec:	843fffc4 	addi	r16,r16,-1
81124df0:	20e8b03a 	or	r20,r4,r3
81124df4:	80800005 	stb	r2,0(r16)
81124df8:	a586b03a 	or	r3,r20,r22
81124dfc:	183ff61e 	bne	r3,zero,81124dd8 <__reset+0xfb104dd8>
81124e00:	90c0004c 	andi	r3,r18,1
81124e04:	18013926 	beq	r3,zero,811252ec <___svfprintf_internal_r+0xb60>
81124e08:	10803fcc 	andi	r2,r2,255
81124e0c:	1080201c 	xori	r2,r2,128
81124e10:	10bfe004 	addi	r2,r2,-128
81124e14:	00c00c04 	movi	r3,48
81124e18:	10c13426 	beq	r2,r3,811252ec <___svfprintf_internal_r+0xb60>
81124e1c:	80ffffc5 	stb	r3,-1(r16)
81124e20:	d8c02817 	ldw	r3,160(sp)
81124e24:	80bfffc4 	addi	r2,r16,-1
81124e28:	1021883a 	mov	r16,r2
81124e2c:	1887c83a 	sub	r3,r3,r2
81124e30:	d8c02e15 	stw	r3,184(sp)
81124e34:	d8802e17 	ldw	r2,184(sp)
81124e38:	d9002917 	ldw	r4,164(sp)
81124e3c:	1100010e 	bge	r2,r4,81124e44 <___svfprintf_internal_r+0x6b8>
81124e40:	2005883a 	mov	r2,r4
81124e44:	d8802a15 	stw	r2,168(sp)
81124e48:	d8003215 	stw	zero,200(sp)
81124e4c:	e7003fcc 	andi	fp,fp,255
81124e50:	e700201c 	xori	fp,fp,128
81124e54:	e73fe004 	addi	fp,fp,-128
81124e58:	e0000326 	beq	fp,zero,81124e68 <___svfprintf_internal_r+0x6dc>
81124e5c:	d8c02a17 	ldw	r3,168(sp)
81124e60:	18c00044 	addi	r3,r3,1
81124e64:	d8c02a15 	stw	r3,168(sp)
81124e68:	90c0008c 	andi	r3,r18,2
81124e6c:	d8c02b15 	stw	r3,172(sp)
81124e70:	18000326 	beq	r3,zero,81124e80 <___svfprintf_internal_r+0x6f4>
81124e74:	d8c02a17 	ldw	r3,168(sp)
81124e78:	18c00084 	addi	r3,r3,2
81124e7c:	d8c02a15 	stw	r3,168(sp)
81124e80:	90c0210c 	andi	r3,r18,132
81124e84:	d8c03015 	stw	r3,192(sp)
81124e88:	1801a11e 	bne	r3,zero,81125510 <___svfprintf_internal_r+0xd84>
81124e8c:	d9003117 	ldw	r4,196(sp)
81124e90:	d8c02a17 	ldw	r3,168(sp)
81124e94:	20e9c83a 	sub	r20,r4,r3
81124e98:	05019d0e 	bge	zero,r20,81125510 <___svfprintf_internal_r+0xd84>
81124e9c:	02400404 	movi	r9,16
81124ea0:	d8c02017 	ldw	r3,128(sp)
81124ea4:	d8801f17 	ldw	r2,124(sp)
81124ea8:	4d051b0e 	bge	r9,r20,81126318 <___svfprintf_internal_r+0x1b8c>
81124eac:	01604574 	movhi	r5,33045
81124eb0:	29472d84 	addi	r5,r5,7350
81124eb4:	dc403c15 	stw	r17,240(sp)
81124eb8:	d9403515 	stw	r5,212(sp)
81124ebc:	a023883a 	mov	r17,r20
81124ec0:	482d883a 	mov	r22,r9
81124ec4:	9029883a 	mov	r20,r18
81124ec8:	070001c4 	movi	fp,7
81124ecc:	8025883a 	mov	r18,r16
81124ed0:	dc002c17 	ldw	r16,176(sp)
81124ed4:	00000306 	br	81124ee4 <___svfprintf_internal_r+0x758>
81124ed8:	8c7ffc04 	addi	r17,r17,-16
81124edc:	42000204 	addi	r8,r8,8
81124ee0:	b440130e 	bge	r22,r17,81124f30 <___svfprintf_internal_r+0x7a4>
81124ee4:	01204574 	movhi	r4,33045
81124ee8:	18c00404 	addi	r3,r3,16
81124eec:	10800044 	addi	r2,r2,1
81124ef0:	21072d84 	addi	r4,r4,7350
81124ef4:	41000015 	stw	r4,0(r8)
81124ef8:	45800115 	stw	r22,4(r8)
81124efc:	d8c02015 	stw	r3,128(sp)
81124f00:	d8801f15 	stw	r2,124(sp)
81124f04:	e0bff40e 	bge	fp,r2,81124ed8 <__reset+0xfb104ed8>
81124f08:	d9801e04 	addi	r6,sp,120
81124f0c:	800b883a 	mov	r5,r16
81124f10:	9809883a 	mov	r4,r19
81124f14:	11313ac0 	call	811313ac <__ssprint_r>
81124f18:	103f031e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81124f1c:	8c7ffc04 	addi	r17,r17,-16
81124f20:	d8c02017 	ldw	r3,128(sp)
81124f24:	d8801f17 	ldw	r2,124(sp)
81124f28:	da000404 	addi	r8,sp,16
81124f2c:	b47fed16 	blt	r22,r17,81124ee4 <__reset+0xfb104ee4>
81124f30:	9021883a 	mov	r16,r18
81124f34:	a025883a 	mov	r18,r20
81124f38:	8829883a 	mov	r20,r17
81124f3c:	dc403c17 	ldw	r17,240(sp)
81124f40:	d9403517 	ldw	r5,212(sp)
81124f44:	a0c7883a 	add	r3,r20,r3
81124f48:	10800044 	addi	r2,r2,1
81124f4c:	41400015 	stw	r5,0(r8)
81124f50:	45000115 	stw	r20,4(r8)
81124f54:	d8c02015 	stw	r3,128(sp)
81124f58:	d8801f15 	stw	r2,124(sp)
81124f5c:	010001c4 	movi	r4,7
81124f60:	20829f16 	blt	r4,r2,811259e0 <___svfprintf_internal_r+0x1254>
81124f64:	df002787 	ldb	fp,158(sp)
81124f68:	42000204 	addi	r8,r8,8
81124f6c:	e0000c26 	beq	fp,zero,81124fa0 <___svfprintf_internal_r+0x814>
81124f70:	d8801f17 	ldw	r2,124(sp)
81124f74:	d9002784 	addi	r4,sp,158
81124f78:	18c00044 	addi	r3,r3,1
81124f7c:	10800044 	addi	r2,r2,1
81124f80:	41000015 	stw	r4,0(r8)
81124f84:	01000044 	movi	r4,1
81124f88:	41000115 	stw	r4,4(r8)
81124f8c:	d8c02015 	stw	r3,128(sp)
81124f90:	d8801f15 	stw	r2,124(sp)
81124f94:	010001c4 	movi	r4,7
81124f98:	20823816 	blt	r4,r2,8112587c <___svfprintf_internal_r+0x10f0>
81124f9c:	42000204 	addi	r8,r8,8
81124fa0:	d8802b17 	ldw	r2,172(sp)
81124fa4:	10000c26 	beq	r2,zero,81124fd8 <___svfprintf_internal_r+0x84c>
81124fa8:	d8801f17 	ldw	r2,124(sp)
81124fac:	d9002704 	addi	r4,sp,156
81124fb0:	18c00084 	addi	r3,r3,2
81124fb4:	10800044 	addi	r2,r2,1
81124fb8:	41000015 	stw	r4,0(r8)
81124fbc:	01000084 	movi	r4,2
81124fc0:	41000115 	stw	r4,4(r8)
81124fc4:	d8c02015 	stw	r3,128(sp)
81124fc8:	d8801f15 	stw	r2,124(sp)
81124fcc:	010001c4 	movi	r4,7
81124fd0:	20823216 	blt	r4,r2,8112589c <___svfprintf_internal_r+0x1110>
81124fd4:	42000204 	addi	r8,r8,8
81124fd8:	d9003017 	ldw	r4,192(sp)
81124fdc:	00802004 	movi	r2,128
81124fe0:	20819726 	beq	r4,r2,81125640 <___svfprintf_internal_r+0xeb4>
81124fe4:	d9402917 	ldw	r5,164(sp)
81124fe8:	d8802e17 	ldw	r2,184(sp)
81124fec:	28adc83a 	sub	r22,r5,r2
81124ff0:	05802f0e 	bge	zero,r22,811250b0 <___svfprintf_internal_r+0x924>
81124ff4:	07000404 	movi	fp,16
81124ff8:	d8801f17 	ldw	r2,124(sp)
81124ffc:	e583c00e 	bge	fp,r22,81125f00 <___svfprintf_internal_r+0x1774>
81125000:	01604574 	movhi	r5,33045
81125004:	29472984 	addi	r5,r5,7334
81125008:	dc402915 	stw	r17,164(sp)
8112500c:	d9402b15 	stw	r5,172(sp)
81125010:	b023883a 	mov	r17,r22
81125014:	050001c4 	movi	r20,7
81125018:	902d883a 	mov	r22,r18
8112501c:	8025883a 	mov	r18,r16
81125020:	dc002c17 	ldw	r16,176(sp)
81125024:	00000306 	br	81125034 <___svfprintf_internal_r+0x8a8>
81125028:	8c7ffc04 	addi	r17,r17,-16
8112502c:	42000204 	addi	r8,r8,8
81125030:	e440110e 	bge	fp,r17,81125078 <___svfprintf_internal_r+0x8ec>
81125034:	18c00404 	addi	r3,r3,16
81125038:	10800044 	addi	r2,r2,1
8112503c:	45400015 	stw	r21,0(r8)
81125040:	47000115 	stw	fp,4(r8)
81125044:	d8c02015 	stw	r3,128(sp)
81125048:	d8801f15 	stw	r2,124(sp)
8112504c:	a0bff60e 	bge	r20,r2,81125028 <__reset+0xfb105028>
81125050:	d9801e04 	addi	r6,sp,120
81125054:	800b883a 	mov	r5,r16
81125058:	9809883a 	mov	r4,r19
8112505c:	11313ac0 	call	811313ac <__ssprint_r>
81125060:	103eb11e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125064:	8c7ffc04 	addi	r17,r17,-16
81125068:	d8c02017 	ldw	r3,128(sp)
8112506c:	d8801f17 	ldw	r2,124(sp)
81125070:	da000404 	addi	r8,sp,16
81125074:	e47fef16 	blt	fp,r17,81125034 <__reset+0xfb105034>
81125078:	9021883a 	mov	r16,r18
8112507c:	b025883a 	mov	r18,r22
81125080:	882d883a 	mov	r22,r17
81125084:	dc402917 	ldw	r17,164(sp)
81125088:	d9002b17 	ldw	r4,172(sp)
8112508c:	1d87883a 	add	r3,r3,r22
81125090:	10800044 	addi	r2,r2,1
81125094:	41000015 	stw	r4,0(r8)
81125098:	45800115 	stw	r22,4(r8)
8112509c:	d8c02015 	stw	r3,128(sp)
811250a0:	d8801f15 	stw	r2,124(sp)
811250a4:	010001c4 	movi	r4,7
811250a8:	2081ec16 	blt	r4,r2,8112585c <___svfprintf_internal_r+0x10d0>
811250ac:	42000204 	addi	r8,r8,8
811250b0:	9080400c 	andi	r2,r18,256
811250b4:	1001181e 	bne	r2,zero,81125518 <___svfprintf_internal_r+0xd8c>
811250b8:	d9402e17 	ldw	r5,184(sp)
811250bc:	d8801f17 	ldw	r2,124(sp)
811250c0:	44000015 	stw	r16,0(r8)
811250c4:	1947883a 	add	r3,r3,r5
811250c8:	10800044 	addi	r2,r2,1
811250cc:	41400115 	stw	r5,4(r8)
811250d0:	d8c02015 	stw	r3,128(sp)
811250d4:	d8801f15 	stw	r2,124(sp)
811250d8:	010001c4 	movi	r4,7
811250dc:	2081d116 	blt	r4,r2,81125824 <___svfprintf_internal_r+0x1098>
811250e0:	42000204 	addi	r8,r8,8
811250e4:	9480010c 	andi	r18,r18,4
811250e8:	90003226 	beq	r18,zero,811251b4 <___svfprintf_internal_r+0xa28>
811250ec:	d9403117 	ldw	r5,196(sp)
811250f0:	d8802a17 	ldw	r2,168(sp)
811250f4:	28a1c83a 	sub	r16,r5,r2
811250f8:	04002e0e 	bge	zero,r16,811251b4 <___svfprintf_internal_r+0xa28>
811250fc:	04400404 	movi	r17,16
81125100:	d8801f17 	ldw	r2,124(sp)
81125104:	8c04b90e 	bge	r17,r16,811263ec <___svfprintf_internal_r+0x1c60>
81125108:	01604574 	movhi	r5,33045
8112510c:	29472d84 	addi	r5,r5,7350
81125110:	d9403515 	stw	r5,212(sp)
81125114:	048001c4 	movi	r18,7
81125118:	dd002c17 	ldw	r20,176(sp)
8112511c:	00000306 	br	8112512c <___svfprintf_internal_r+0x9a0>
81125120:	843ffc04 	addi	r16,r16,-16
81125124:	42000204 	addi	r8,r8,8
81125128:	8c00130e 	bge	r17,r16,81125178 <___svfprintf_internal_r+0x9ec>
8112512c:	01204574 	movhi	r4,33045
81125130:	18c00404 	addi	r3,r3,16
81125134:	10800044 	addi	r2,r2,1
81125138:	21072d84 	addi	r4,r4,7350
8112513c:	41000015 	stw	r4,0(r8)
81125140:	44400115 	stw	r17,4(r8)
81125144:	d8c02015 	stw	r3,128(sp)
81125148:	d8801f15 	stw	r2,124(sp)
8112514c:	90bff40e 	bge	r18,r2,81125120 <__reset+0xfb105120>
81125150:	d9801e04 	addi	r6,sp,120
81125154:	a00b883a 	mov	r5,r20
81125158:	9809883a 	mov	r4,r19
8112515c:	11313ac0 	call	811313ac <__ssprint_r>
81125160:	103e711e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125164:	843ffc04 	addi	r16,r16,-16
81125168:	d8c02017 	ldw	r3,128(sp)
8112516c:	d8801f17 	ldw	r2,124(sp)
81125170:	da000404 	addi	r8,sp,16
81125174:	8c3fed16 	blt	r17,r16,8112512c <__reset+0xfb10512c>
81125178:	d9403517 	ldw	r5,212(sp)
8112517c:	1c07883a 	add	r3,r3,r16
81125180:	10800044 	addi	r2,r2,1
81125184:	41400015 	stw	r5,0(r8)
81125188:	44000115 	stw	r16,4(r8)
8112518c:	d8c02015 	stw	r3,128(sp)
81125190:	d8801f15 	stw	r2,124(sp)
81125194:	010001c4 	movi	r4,7
81125198:	2080060e 	bge	r4,r2,811251b4 <___svfprintf_internal_r+0xa28>
8112519c:	d9402c17 	ldw	r5,176(sp)
811251a0:	d9801e04 	addi	r6,sp,120
811251a4:	9809883a 	mov	r4,r19
811251a8:	11313ac0 	call	811313ac <__ssprint_r>
811251ac:	103e5e1e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
811251b0:	d8c02017 	ldw	r3,128(sp)
811251b4:	d8803117 	ldw	r2,196(sp)
811251b8:	d9002a17 	ldw	r4,168(sp)
811251bc:	1100010e 	bge	r2,r4,811251c4 <___svfprintf_internal_r+0xa38>
811251c0:	2005883a 	mov	r2,r4
811251c4:	d9402f17 	ldw	r5,188(sp)
811251c8:	288b883a 	add	r5,r5,r2
811251cc:	d9402f15 	stw	r5,188(sp)
811251d0:	18019c1e 	bne	r3,zero,81125844 <___svfprintf_internal_r+0x10b8>
811251d4:	b8800007 	ldb	r2,0(r23)
811251d8:	d8001f15 	stw	zero,124(sp)
811251dc:	da000404 	addi	r8,sp,16
811251e0:	103d991e 	bne	r2,zero,81124848 <__reset+0xfb104848>
811251e4:	b821883a 	mov	r16,r23
811251e8:	003daf06 	br	811248a8 <__reset+0xfb1048a8>
811251ec:	18c03fcc 	andi	r3,r3,255
811251f0:	1805c71e 	bne	r3,zero,81126910 <___svfprintf_internal_r+0x2184>
811251f4:	94800414 	ori	r18,r18,16
811251f8:	9080080c 	andi	r2,r18,32
811251fc:	10020126 	beq	r2,zero,81125a04 <___svfprintf_internal_r+0x1278>
81125200:	d8802d17 	ldw	r2,180(sp)
81125204:	d9002917 	ldw	r4,164(sp)
81125208:	d8002785 	stb	zero,158(sp)
8112520c:	10c00204 	addi	r3,r2,8
81125210:	15000017 	ldw	r20,0(r2)
81125214:	15800117 	ldw	r22,4(r2)
81125218:	20038e16 	blt	r4,zero,81126054 <___svfprintf_internal_r+0x18c8>
8112521c:	013fdfc4 	movi	r4,-129
81125220:	a584b03a 	or	r2,r20,r22
81125224:	d8c02d15 	stw	r3,180(sp)
81125228:	9124703a 	and	r18,r18,r4
8112522c:	0039883a 	mov	fp,zero
81125230:	103eb61e 	bne	r2,zero,81124d0c <__reset+0xfb104d0c>
81125234:	d8802917 	ldw	r2,164(sp)
81125238:	1002c81e 	bne	r2,zero,81125d5c <___svfprintf_internal_r+0x15d0>
8112523c:	d8002915 	stw	zero,164(sp)
81125240:	d8002e15 	stw	zero,184(sp)
81125244:	dc001e04 	addi	r16,sp,120
81125248:	003efa06 	br	81124e34 <__reset+0xfb104e34>
8112524c:	18c03fcc 	andi	r3,r3,255
81125250:	1805ad1e 	bne	r3,zero,81126908 <___svfprintf_internal_r+0x217c>
81125254:	01604574 	movhi	r5,33045
81125258:	29471d04 	addi	r5,r5,7284
8112525c:	d9403a15 	stw	r5,232(sp)
81125260:	9080080c 	andi	r2,r18,32
81125264:	10006126 	beq	r2,zero,811253ec <___svfprintf_internal_r+0xc60>
81125268:	d8802d17 	ldw	r2,180(sp)
8112526c:	15000017 	ldw	r20,0(r2)
81125270:	15800117 	ldw	r22,4(r2)
81125274:	10800204 	addi	r2,r2,8
81125278:	d8802d15 	stw	r2,180(sp)
8112527c:	9080004c 	andi	r2,r18,1
81125280:	10018e26 	beq	r2,zero,811258bc <___svfprintf_internal_r+0x1130>
81125284:	a584b03a 	or	r2,r20,r22
81125288:	10030926 	beq	r2,zero,81125eb0 <___svfprintf_internal_r+0x1724>
8112528c:	d8c02917 	ldw	r3,164(sp)
81125290:	00800c04 	movi	r2,48
81125294:	d8802705 	stb	r2,156(sp)
81125298:	dc402745 	stb	r17,157(sp)
8112529c:	d8002785 	stb	zero,158(sp)
811252a0:	90800094 	ori	r2,r18,2
811252a4:	18048716 	blt	r3,zero,811264c4 <___svfprintf_internal_r+0x1d38>
811252a8:	00bfdfc4 	movi	r2,-129
811252ac:	90a4703a 	and	r18,r18,r2
811252b0:	94800094 	ori	r18,r18,2
811252b4:	0039883a 	mov	fp,zero
811252b8:	d9003a17 	ldw	r4,232(sp)
811252bc:	dc001e04 	addi	r16,sp,120
811252c0:	a08003cc 	andi	r2,r20,15
811252c4:	b006973a 	slli	r3,r22,28
811252c8:	2085883a 	add	r2,r4,r2
811252cc:	a028d13a 	srli	r20,r20,4
811252d0:	10800003 	ldbu	r2,0(r2)
811252d4:	b02cd13a 	srli	r22,r22,4
811252d8:	843fffc4 	addi	r16,r16,-1
811252dc:	1d28b03a 	or	r20,r3,r20
811252e0:	80800005 	stb	r2,0(r16)
811252e4:	a584b03a 	or	r2,r20,r22
811252e8:	103ff51e 	bne	r2,zero,811252c0 <__reset+0xfb1052c0>
811252ec:	d8c02817 	ldw	r3,160(sp)
811252f0:	1c07c83a 	sub	r3,r3,r16
811252f4:	d8c02e15 	stw	r3,184(sp)
811252f8:	003ece06 	br	81124e34 <__reset+0xfb104e34>
811252fc:	d8c02d17 	ldw	r3,180(sp)
81125300:	d9002d17 	ldw	r4,180(sp)
81125304:	d8002785 	stb	zero,158(sp)
81125308:	18800017 	ldw	r2,0(r3)
8112530c:	21000104 	addi	r4,r4,4
81125310:	00c00044 	movi	r3,1
81125314:	d8c02a15 	stw	r3,168(sp)
81125318:	d8801405 	stb	r2,80(sp)
8112531c:	d9002d15 	stw	r4,180(sp)
81125320:	d8c02e15 	stw	r3,184(sp)
81125324:	d8002915 	stw	zero,164(sp)
81125328:	d8003215 	stw	zero,200(sp)
8112532c:	dc001404 	addi	r16,sp,80
81125330:	0039883a 	mov	fp,zero
81125334:	003ecc06 	br	81124e68 <__reset+0xfb104e68>
81125338:	18c03fcc 	andi	r3,r3,255
8112533c:	183e9226 	beq	r3,zero,81124d88 <__reset+0xfb104d88>
81125340:	d9c02785 	stb	r7,158(sp)
81125344:	003e9006 	br	81124d88 <__reset+0xfb104d88>
81125348:	00c00044 	movi	r3,1
8112534c:	01c00ac4 	movi	r7,43
81125350:	bc400007 	ldb	r17,0(r23)
81125354:	003d6306 	br	811248e4 <__reset+0xfb1048e4>
81125358:	94800814 	ori	r18,r18,32
8112535c:	bc400007 	ldb	r17,0(r23)
81125360:	003d6006 	br	811248e4 <__reset+0xfb1048e4>
81125364:	d8c02d17 	ldw	r3,180(sp)
81125368:	d8002785 	stb	zero,158(sp)
8112536c:	1c000017 	ldw	r16,0(r3)
81125370:	1d000104 	addi	r20,r3,4
81125374:	80040f26 	beq	r16,zero,811263b4 <___svfprintf_internal_r+0x1c28>
81125378:	d9002917 	ldw	r4,164(sp)
8112537c:	2003dc16 	blt	r4,zero,811262f0 <___svfprintf_internal_r+0x1b64>
81125380:	200d883a 	mov	r6,r4
81125384:	000b883a 	mov	r5,zero
81125388:	8009883a 	mov	r4,r16
8112538c:	da003e15 	stw	r8,248(sp)
81125390:	112d9500 	call	8112d950 <memchr>
81125394:	da003e17 	ldw	r8,248(sp)
81125398:	10045826 	beq	r2,zero,811264fc <___svfprintf_internal_r+0x1d70>
8112539c:	1405c83a 	sub	r2,r2,r16
811253a0:	d8802e15 	stw	r2,184(sp)
811253a4:	1003d816 	blt	r2,zero,81126308 <___svfprintf_internal_r+0x1b7c>
811253a8:	df002783 	ldbu	fp,158(sp)
811253ac:	d8802a15 	stw	r2,168(sp)
811253b0:	dd002d15 	stw	r20,180(sp)
811253b4:	d8002915 	stw	zero,164(sp)
811253b8:	d8003215 	stw	zero,200(sp)
811253bc:	003ea306 	br	81124e4c <__reset+0xfb104e4c>
811253c0:	18c03fcc 	andi	r3,r3,255
811253c4:	183f8c26 	beq	r3,zero,811251f8 <__reset+0xfb1051f8>
811253c8:	d9c02785 	stb	r7,158(sp)
811253cc:	003f8a06 	br	811251f8 <__reset+0xfb1051f8>
811253d0:	18c03fcc 	andi	r3,r3,255
811253d4:	1805631e 	bne	r3,zero,81126964 <___svfprintf_internal_r+0x21d8>
811253d8:	01604574 	movhi	r5,33045
811253dc:	29472204 	addi	r5,r5,7304
811253e0:	d9403a15 	stw	r5,232(sp)
811253e4:	9080080c 	andi	r2,r18,32
811253e8:	103f9f1e 	bne	r2,zero,81125268 <__reset+0xfb105268>
811253ec:	9080040c 	andi	r2,r18,16
811253f0:	10029c26 	beq	r2,zero,81125e64 <___svfprintf_internal_r+0x16d8>
811253f4:	d8c02d17 	ldw	r3,180(sp)
811253f8:	002d883a 	mov	r22,zero
811253fc:	1d000017 	ldw	r20,0(r3)
81125400:	18c00104 	addi	r3,r3,4
81125404:	d8c02d15 	stw	r3,180(sp)
81125408:	003f9c06 	br	8112527c <__reset+0xfb10527c>
8112540c:	94800054 	ori	r18,r18,1
81125410:	bc400007 	ldb	r17,0(r23)
81125414:	003d3306 	br	811248e4 <__reset+0xfb1048e4>
81125418:	38803fcc 	andi	r2,r7,255
8112541c:	1080201c 	xori	r2,r2,128
81125420:	10bfe004 	addi	r2,r2,-128
81125424:	1002971e 	bne	r2,zero,81125e84 <___svfprintf_internal_r+0x16f8>
81125428:	00c00044 	movi	r3,1
8112542c:	01c00804 	movi	r7,32
81125430:	bc400007 	ldb	r17,0(r23)
81125434:	003d2b06 	br	811248e4 <__reset+0xfb1048e4>
81125438:	18c03fcc 	andi	r3,r3,255
8112543c:	183e2326 	beq	r3,zero,81124ccc <__reset+0xfb104ccc>
81125440:	d9c02785 	stb	r7,158(sp)
81125444:	003e2106 	br	81124ccc <__reset+0xfb104ccc>
81125448:	bc400007 	ldb	r17,0(r23)
8112544c:	8a430426 	beq	r17,r9,81126060 <___svfprintf_internal_r+0x18d4>
81125450:	94800414 	ori	r18,r18,16
81125454:	003d2306 	br	811248e4 <__reset+0xfb1048e4>
81125458:	18c03fcc 	andi	r3,r3,255
8112545c:	18053f1e 	bne	r3,zero,8112695c <___svfprintf_internal_r+0x21d0>
81125460:	9080080c 	andi	r2,r18,32
81125464:	10028926 	beq	r2,zero,81125e8c <___svfprintf_internal_r+0x1700>
81125468:	d9402d17 	ldw	r5,180(sp)
8112546c:	d9002f17 	ldw	r4,188(sp)
81125470:	28800017 	ldw	r2,0(r5)
81125474:	2007d7fa 	srai	r3,r4,31
81125478:	29400104 	addi	r5,r5,4
8112547c:	d9402d15 	stw	r5,180(sp)
81125480:	11000015 	stw	r4,0(r2)
81125484:	10c00115 	stw	r3,4(r2)
81125488:	003ced06 	br	81124840 <__reset+0xfb104840>
8112548c:	94801014 	ori	r18,r18,64
81125490:	bc400007 	ldb	r17,0(r23)
81125494:	003d1306 	br	811248e4 <__reset+0xfb1048e4>
81125498:	01204574 	movhi	r4,33045
8112549c:	21072204 	addi	r4,r4,7304
811254a0:	0039883a 	mov	fp,zero
811254a4:	d9003a15 	stw	r4,232(sp)
811254a8:	04401e04 	movi	r17,120
811254ac:	003f8206 	br	811252b8 <__reset+0xfb1052b8>
811254b0:	18c03fcc 	andi	r3,r3,255
811254b4:	1805221e 	bne	r3,zero,81126940 <___svfprintf_internal_r+0x21b4>
811254b8:	883d9526 	beq	r17,zero,81124b10 <__reset+0xfb104b10>
811254bc:	00c00044 	movi	r3,1
811254c0:	d8c02a15 	stw	r3,168(sp)
811254c4:	dc401405 	stb	r17,80(sp)
811254c8:	d8002785 	stb	zero,158(sp)
811254cc:	003f9406 	br	81125320 <__reset+0xfb105320>
811254d0:	01204574 	movhi	r4,33045
811254d4:	21072204 	addi	r4,r4,7304
811254d8:	d9003a15 	stw	r4,232(sp)
811254dc:	d8c02d15 	stw	r3,180(sp)
811254e0:	1025883a 	mov	r18,r2
811254e4:	04401e04 	movi	r17,120
811254e8:	a584b03a 	or	r2,r20,r22
811254ec:	1000fa1e 	bne	r2,zero,811258d8 <___svfprintf_internal_r+0x114c>
811254f0:	0039883a 	mov	fp,zero
811254f4:	00800084 	movi	r2,2
811254f8:	10803fcc 	andi	r2,r2,255
811254fc:	00c00044 	movi	r3,1
81125500:	10c21626 	beq	r2,r3,81125d5c <___svfprintf_internal_r+0x15d0>
81125504:	00c00084 	movi	r3,2
81125508:	10fe301e 	bne	r2,r3,81124dcc <__reset+0xfb104dcc>
8112550c:	003d7606 	br	81124ae8 <__reset+0xfb104ae8>
81125510:	d8c02017 	ldw	r3,128(sp)
81125514:	003e9506 	br	81124f6c <__reset+0xfb104f6c>
81125518:	00801944 	movi	r2,101
8112551c:	14407c0e 	bge	r2,r17,81125710 <___svfprintf_internal_r+0xf84>
81125520:	d9003617 	ldw	r4,216(sp)
81125524:	d9403717 	ldw	r5,220(sp)
81125528:	000d883a 	mov	r6,zero
8112552c:	000f883a 	mov	r7,zero
81125530:	d8c03d15 	stw	r3,244(sp)
81125534:	da003e15 	stw	r8,248(sp)
81125538:	11373280 	call	81137328 <__eqdf2>
8112553c:	d8c03d17 	ldw	r3,244(sp)
81125540:	da003e17 	ldw	r8,248(sp)
81125544:	1000f51e 	bne	r2,zero,8112591c <___svfprintf_internal_r+0x1190>
81125548:	d8801f17 	ldw	r2,124(sp)
8112554c:	01204574 	movhi	r4,33045
81125550:	21072904 	addi	r4,r4,7332
81125554:	18c00044 	addi	r3,r3,1
81125558:	10800044 	addi	r2,r2,1
8112555c:	41000015 	stw	r4,0(r8)
81125560:	01000044 	movi	r4,1
81125564:	41000115 	stw	r4,4(r8)
81125568:	d8c02015 	stw	r3,128(sp)
8112556c:	d8801f15 	stw	r2,124(sp)
81125570:	010001c4 	movi	r4,7
81125574:	20826616 	blt	r4,r2,81125f10 <___svfprintf_internal_r+0x1784>
81125578:	42000204 	addi	r8,r8,8
8112557c:	d8802617 	ldw	r2,152(sp)
81125580:	d9403317 	ldw	r5,204(sp)
81125584:	11400216 	blt	r2,r5,81125590 <___svfprintf_internal_r+0xe04>
81125588:	9080004c 	andi	r2,r18,1
8112558c:	103ed526 	beq	r2,zero,811250e4 <__reset+0xfb1050e4>
81125590:	d8803817 	ldw	r2,224(sp)
81125594:	d9003417 	ldw	r4,208(sp)
81125598:	d9403817 	ldw	r5,224(sp)
8112559c:	1887883a 	add	r3,r3,r2
811255a0:	d8801f17 	ldw	r2,124(sp)
811255a4:	41000015 	stw	r4,0(r8)
811255a8:	41400115 	stw	r5,4(r8)
811255ac:	10800044 	addi	r2,r2,1
811255b0:	d8c02015 	stw	r3,128(sp)
811255b4:	d8801f15 	stw	r2,124(sp)
811255b8:	010001c4 	movi	r4,7
811255bc:	2082af16 	blt	r4,r2,8112607c <___svfprintf_internal_r+0x18f0>
811255c0:	42000204 	addi	r8,r8,8
811255c4:	d8803317 	ldw	r2,204(sp)
811255c8:	143fffc4 	addi	r16,r2,-1
811255cc:	043ec50e 	bge	zero,r16,811250e4 <__reset+0xfb1050e4>
811255d0:	04400404 	movi	r17,16
811255d4:	d8801f17 	ldw	r2,124(sp)
811255d8:	8c00860e 	bge	r17,r16,811257f4 <___svfprintf_internal_r+0x1068>
811255dc:	01604574 	movhi	r5,33045
811255e0:	29472984 	addi	r5,r5,7334
811255e4:	d9402b15 	stw	r5,172(sp)
811255e8:	058001c4 	movi	r22,7
811255ec:	dd002c17 	ldw	r20,176(sp)
811255f0:	00000306 	br	81125600 <___svfprintf_internal_r+0xe74>
811255f4:	42000204 	addi	r8,r8,8
811255f8:	843ffc04 	addi	r16,r16,-16
811255fc:	8c00800e 	bge	r17,r16,81125800 <___svfprintf_internal_r+0x1074>
81125600:	18c00404 	addi	r3,r3,16
81125604:	10800044 	addi	r2,r2,1
81125608:	45400015 	stw	r21,0(r8)
8112560c:	44400115 	stw	r17,4(r8)
81125610:	d8c02015 	stw	r3,128(sp)
81125614:	d8801f15 	stw	r2,124(sp)
81125618:	b0bff60e 	bge	r22,r2,811255f4 <__reset+0xfb1055f4>
8112561c:	d9801e04 	addi	r6,sp,120
81125620:	a00b883a 	mov	r5,r20
81125624:	9809883a 	mov	r4,r19
81125628:	11313ac0 	call	811313ac <__ssprint_r>
8112562c:	103d3e1e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125630:	d8c02017 	ldw	r3,128(sp)
81125634:	d8801f17 	ldw	r2,124(sp)
81125638:	da000404 	addi	r8,sp,16
8112563c:	003fee06 	br	811255f8 <__reset+0xfb1055f8>
81125640:	d9403117 	ldw	r5,196(sp)
81125644:	d8802a17 	ldw	r2,168(sp)
81125648:	28adc83a 	sub	r22,r5,r2
8112564c:	05be650e 	bge	zero,r22,81124fe4 <__reset+0xfb104fe4>
81125650:	07000404 	movi	fp,16
81125654:	d8801f17 	ldw	r2,124(sp)
81125658:	e583a20e 	bge	fp,r22,811264e4 <___svfprintf_internal_r+0x1d58>
8112565c:	01604574 	movhi	r5,33045
81125660:	29472984 	addi	r5,r5,7334
81125664:	dc403015 	stw	r17,192(sp)
81125668:	d9402b15 	stw	r5,172(sp)
8112566c:	b023883a 	mov	r17,r22
81125670:	050001c4 	movi	r20,7
81125674:	902d883a 	mov	r22,r18
81125678:	8025883a 	mov	r18,r16
8112567c:	dc002c17 	ldw	r16,176(sp)
81125680:	00000306 	br	81125690 <___svfprintf_internal_r+0xf04>
81125684:	8c7ffc04 	addi	r17,r17,-16
81125688:	42000204 	addi	r8,r8,8
8112568c:	e440110e 	bge	fp,r17,811256d4 <___svfprintf_internal_r+0xf48>
81125690:	18c00404 	addi	r3,r3,16
81125694:	10800044 	addi	r2,r2,1
81125698:	45400015 	stw	r21,0(r8)
8112569c:	47000115 	stw	fp,4(r8)
811256a0:	d8c02015 	stw	r3,128(sp)
811256a4:	d8801f15 	stw	r2,124(sp)
811256a8:	a0bff60e 	bge	r20,r2,81125684 <__reset+0xfb105684>
811256ac:	d9801e04 	addi	r6,sp,120
811256b0:	800b883a 	mov	r5,r16
811256b4:	9809883a 	mov	r4,r19
811256b8:	11313ac0 	call	811313ac <__ssprint_r>
811256bc:	103d1a1e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
811256c0:	8c7ffc04 	addi	r17,r17,-16
811256c4:	d8c02017 	ldw	r3,128(sp)
811256c8:	d8801f17 	ldw	r2,124(sp)
811256cc:	da000404 	addi	r8,sp,16
811256d0:	e47fef16 	blt	fp,r17,81125690 <__reset+0xfb105690>
811256d4:	9021883a 	mov	r16,r18
811256d8:	b025883a 	mov	r18,r22
811256dc:	882d883a 	mov	r22,r17
811256e0:	dc403017 	ldw	r17,192(sp)
811256e4:	d9002b17 	ldw	r4,172(sp)
811256e8:	1d87883a 	add	r3,r3,r22
811256ec:	10800044 	addi	r2,r2,1
811256f0:	41000015 	stw	r4,0(r8)
811256f4:	45800115 	stw	r22,4(r8)
811256f8:	d8c02015 	stw	r3,128(sp)
811256fc:	d8801f15 	stw	r2,124(sp)
81125700:	010001c4 	movi	r4,7
81125704:	20819a16 	blt	r4,r2,81125d70 <___svfprintf_internal_r+0x15e4>
81125708:	42000204 	addi	r8,r8,8
8112570c:	003e3506 	br	81124fe4 <__reset+0xfb104fe4>
81125710:	d9403317 	ldw	r5,204(sp)
81125714:	00800044 	movi	r2,1
81125718:	18c00044 	addi	r3,r3,1
8112571c:	1141710e 	bge	r2,r5,81125ce4 <___svfprintf_internal_r+0x1558>
81125720:	dc401f17 	ldw	r17,124(sp)
81125724:	00800044 	movi	r2,1
81125728:	40800115 	stw	r2,4(r8)
8112572c:	8c400044 	addi	r17,r17,1
81125730:	44000015 	stw	r16,0(r8)
81125734:	d8c02015 	stw	r3,128(sp)
81125738:	dc401f15 	stw	r17,124(sp)
8112573c:	008001c4 	movi	r2,7
81125740:	14417416 	blt	r2,r17,81125d14 <___svfprintf_internal_r+0x1588>
81125744:	42000204 	addi	r8,r8,8
81125748:	d8803817 	ldw	r2,224(sp)
8112574c:	d9003417 	ldw	r4,208(sp)
81125750:	8c400044 	addi	r17,r17,1
81125754:	10c7883a 	add	r3,r2,r3
81125758:	40800115 	stw	r2,4(r8)
8112575c:	41000015 	stw	r4,0(r8)
81125760:	d8c02015 	stw	r3,128(sp)
81125764:	dc401f15 	stw	r17,124(sp)
81125768:	008001c4 	movi	r2,7
8112576c:	14417216 	blt	r2,r17,81125d38 <___svfprintf_internal_r+0x15ac>
81125770:	45800204 	addi	r22,r8,8
81125774:	d9003617 	ldw	r4,216(sp)
81125778:	d9403717 	ldw	r5,220(sp)
8112577c:	000d883a 	mov	r6,zero
81125780:	000f883a 	mov	r7,zero
81125784:	d8c03d15 	stw	r3,244(sp)
81125788:	11373280 	call	81137328 <__eqdf2>
8112578c:	d8c03d17 	ldw	r3,244(sp)
81125790:	1000b326 	beq	r2,zero,81125a60 <___svfprintf_internal_r+0x12d4>
81125794:	d9403317 	ldw	r5,204(sp)
81125798:	84000044 	addi	r16,r16,1
8112579c:	8c400044 	addi	r17,r17,1
811257a0:	28bfffc4 	addi	r2,r5,-1
811257a4:	1887883a 	add	r3,r3,r2
811257a8:	b0800115 	stw	r2,4(r22)
811257ac:	b4000015 	stw	r16,0(r22)
811257b0:	d8c02015 	stw	r3,128(sp)
811257b4:	dc401f15 	stw	r17,124(sp)
811257b8:	008001c4 	movi	r2,7
811257bc:	1440d216 	blt	r2,r17,81125b08 <___svfprintf_internal_r+0x137c>
811257c0:	b5800204 	addi	r22,r22,8
811257c4:	d9003b17 	ldw	r4,236(sp)
811257c8:	df0022c4 	addi	fp,sp,139
811257cc:	8c400044 	addi	r17,r17,1
811257d0:	20c7883a 	add	r3,r4,r3
811257d4:	b7000015 	stw	fp,0(r22)
811257d8:	b1000115 	stw	r4,4(r22)
811257dc:	d8c02015 	stw	r3,128(sp)
811257e0:	dc401f15 	stw	r17,124(sp)
811257e4:	008001c4 	movi	r2,7
811257e8:	14400e16 	blt	r2,r17,81125824 <___svfprintf_internal_r+0x1098>
811257ec:	b2000204 	addi	r8,r22,8
811257f0:	003e3c06 	br	811250e4 <__reset+0xfb1050e4>
811257f4:	01204574 	movhi	r4,33045
811257f8:	21072984 	addi	r4,r4,7334
811257fc:	d9002b15 	stw	r4,172(sp)
81125800:	d9002b17 	ldw	r4,172(sp)
81125804:	1c07883a 	add	r3,r3,r16
81125808:	44000115 	stw	r16,4(r8)
8112580c:	41000015 	stw	r4,0(r8)
81125810:	10800044 	addi	r2,r2,1
81125814:	d8c02015 	stw	r3,128(sp)
81125818:	d8801f15 	stw	r2,124(sp)
8112581c:	010001c4 	movi	r4,7
81125820:	20be2f0e 	bge	r4,r2,811250e0 <__reset+0xfb1050e0>
81125824:	d9402c17 	ldw	r5,176(sp)
81125828:	d9801e04 	addi	r6,sp,120
8112582c:	9809883a 	mov	r4,r19
81125830:	11313ac0 	call	811313ac <__ssprint_r>
81125834:	103cbc1e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125838:	d8c02017 	ldw	r3,128(sp)
8112583c:	da000404 	addi	r8,sp,16
81125840:	003e2806 	br	811250e4 <__reset+0xfb1050e4>
81125844:	d9402c17 	ldw	r5,176(sp)
81125848:	d9801e04 	addi	r6,sp,120
8112584c:	9809883a 	mov	r4,r19
81125850:	11313ac0 	call	811313ac <__ssprint_r>
81125854:	103e5f26 	beq	r2,zero,811251d4 <__reset+0xfb1051d4>
81125858:	003cb306 	br	81124b28 <__reset+0xfb104b28>
8112585c:	d9402c17 	ldw	r5,176(sp)
81125860:	d9801e04 	addi	r6,sp,120
81125864:	9809883a 	mov	r4,r19
81125868:	11313ac0 	call	811313ac <__ssprint_r>
8112586c:	103cae1e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125870:	d8c02017 	ldw	r3,128(sp)
81125874:	da000404 	addi	r8,sp,16
81125878:	003e0d06 	br	811250b0 <__reset+0xfb1050b0>
8112587c:	d9402c17 	ldw	r5,176(sp)
81125880:	d9801e04 	addi	r6,sp,120
81125884:	9809883a 	mov	r4,r19
81125888:	11313ac0 	call	811313ac <__ssprint_r>
8112588c:	103ca61e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125890:	d8c02017 	ldw	r3,128(sp)
81125894:	da000404 	addi	r8,sp,16
81125898:	003dc106 	br	81124fa0 <__reset+0xfb104fa0>
8112589c:	d9402c17 	ldw	r5,176(sp)
811258a0:	d9801e04 	addi	r6,sp,120
811258a4:	9809883a 	mov	r4,r19
811258a8:	11313ac0 	call	811313ac <__ssprint_r>
811258ac:	103c9e1e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
811258b0:	d8c02017 	ldw	r3,128(sp)
811258b4:	da000404 	addi	r8,sp,16
811258b8:	003dc706 	br	81124fd8 <__reset+0xfb104fd8>
811258bc:	d8802917 	ldw	r2,164(sp)
811258c0:	d8002785 	stb	zero,158(sp)
811258c4:	103f0816 	blt	r2,zero,811254e8 <__reset+0xfb1054e8>
811258c8:	00ffdfc4 	movi	r3,-129
811258cc:	a584b03a 	or	r2,r20,r22
811258d0:	90e4703a 	and	r18,r18,r3
811258d4:	103c8126 	beq	r2,zero,81124adc <__reset+0xfb104adc>
811258d8:	0039883a 	mov	fp,zero
811258dc:	003e7606 	br	811252b8 <__reset+0xfb1052b8>
811258e0:	9080040c 	andi	r2,r18,16
811258e4:	10013d26 	beq	r2,zero,81125ddc <___svfprintf_internal_r+0x1650>
811258e8:	d9002d17 	ldw	r4,180(sp)
811258ec:	d9402917 	ldw	r5,164(sp)
811258f0:	d8002785 	stb	zero,158(sp)
811258f4:	20800104 	addi	r2,r4,4
811258f8:	25000017 	ldw	r20,0(r4)
811258fc:	002d883a 	mov	r22,zero
81125900:	28013f16 	blt	r5,zero,81125e00 <___svfprintf_internal_r+0x1674>
81125904:	00ffdfc4 	movi	r3,-129
81125908:	d8802d15 	stw	r2,180(sp)
8112590c:	90e4703a 	and	r18,r18,r3
81125910:	a03d2b26 	beq	r20,zero,81124dc0 <__reset+0xfb104dc0>
81125914:	0039883a 	mov	fp,zero
81125918:	003d2e06 	br	81124dd4 <__reset+0xfb104dd4>
8112591c:	dc402617 	ldw	r17,152(sp)
81125920:	0441830e 	bge	zero,r17,81125f30 <___svfprintf_internal_r+0x17a4>
81125924:	dc403217 	ldw	r17,200(sp)
81125928:	d8803317 	ldw	r2,204(sp)
8112592c:	1440010e 	bge	r2,r17,81125934 <___svfprintf_internal_r+0x11a8>
81125930:	1023883a 	mov	r17,r2
81125934:	04400a0e 	bge	zero,r17,81125960 <___svfprintf_internal_r+0x11d4>
81125938:	d8801f17 	ldw	r2,124(sp)
8112593c:	1c47883a 	add	r3,r3,r17
81125940:	44000015 	stw	r16,0(r8)
81125944:	10800044 	addi	r2,r2,1
81125948:	44400115 	stw	r17,4(r8)
8112594c:	d8c02015 	stw	r3,128(sp)
81125950:	d8801f15 	stw	r2,124(sp)
81125954:	010001c4 	movi	r4,7
81125958:	20827516 	blt	r4,r2,81126330 <___svfprintf_internal_r+0x1ba4>
8112595c:	42000204 	addi	r8,r8,8
81125960:	88027b16 	blt	r17,zero,81126350 <___svfprintf_internal_r+0x1bc4>
81125964:	d9003217 	ldw	r4,200(sp)
81125968:	2463c83a 	sub	r17,r4,r17
8112596c:	0440990e 	bge	zero,r17,81125bd4 <___svfprintf_internal_r+0x1448>
81125970:	05800404 	movi	r22,16
81125974:	d8801f17 	ldw	r2,124(sp)
81125978:	b441530e 	bge	r22,r17,81125ec8 <___svfprintf_internal_r+0x173c>
8112597c:	01204574 	movhi	r4,33045
81125980:	21072984 	addi	r4,r4,7334
81125984:	d9002b15 	stw	r4,172(sp)
81125988:	070001c4 	movi	fp,7
8112598c:	dd002c17 	ldw	r20,176(sp)
81125990:	00000306 	br	811259a0 <___svfprintf_internal_r+0x1214>
81125994:	42000204 	addi	r8,r8,8
81125998:	8c7ffc04 	addi	r17,r17,-16
8112599c:	b4414d0e 	bge	r22,r17,81125ed4 <___svfprintf_internal_r+0x1748>
811259a0:	18c00404 	addi	r3,r3,16
811259a4:	10800044 	addi	r2,r2,1
811259a8:	45400015 	stw	r21,0(r8)
811259ac:	45800115 	stw	r22,4(r8)
811259b0:	d8c02015 	stw	r3,128(sp)
811259b4:	d8801f15 	stw	r2,124(sp)
811259b8:	e0bff60e 	bge	fp,r2,81125994 <__reset+0xfb105994>
811259bc:	d9801e04 	addi	r6,sp,120
811259c0:	a00b883a 	mov	r5,r20
811259c4:	9809883a 	mov	r4,r19
811259c8:	11313ac0 	call	811313ac <__ssprint_r>
811259cc:	103c561e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
811259d0:	d8c02017 	ldw	r3,128(sp)
811259d4:	d8801f17 	ldw	r2,124(sp)
811259d8:	da000404 	addi	r8,sp,16
811259dc:	003fee06 	br	81125998 <__reset+0xfb105998>
811259e0:	d9402c17 	ldw	r5,176(sp)
811259e4:	d9801e04 	addi	r6,sp,120
811259e8:	9809883a 	mov	r4,r19
811259ec:	11313ac0 	call	811313ac <__ssprint_r>
811259f0:	103c4d1e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
811259f4:	d8c02017 	ldw	r3,128(sp)
811259f8:	df002787 	ldb	fp,158(sp)
811259fc:	da000404 	addi	r8,sp,16
81125a00:	003d5a06 	br	81124f6c <__reset+0xfb104f6c>
81125a04:	9080040c 	andi	r2,r18,16
81125a08:	10005c26 	beq	r2,zero,81125b7c <___svfprintf_internal_r+0x13f0>
81125a0c:	d9402d17 	ldw	r5,180(sp)
81125a10:	d8c02917 	ldw	r3,164(sp)
81125a14:	d8002785 	stb	zero,158(sp)
81125a18:	28800104 	addi	r2,r5,4
81125a1c:	2d000017 	ldw	r20,0(r5)
81125a20:	002d883a 	mov	r22,zero
81125a24:	18005e16 	blt	r3,zero,81125ba0 <___svfprintf_internal_r+0x1414>
81125a28:	00ffdfc4 	movi	r3,-129
81125a2c:	d8802d15 	stw	r2,180(sp)
81125a30:	90e4703a 	and	r18,r18,r3
81125a34:	0039883a 	mov	fp,zero
81125a38:	a03dfe26 	beq	r20,zero,81125234 <__reset+0xfb105234>
81125a3c:	00800244 	movi	r2,9
81125a40:	153cb336 	bltu	r2,r20,81124d10 <__reset+0xfb104d10>
81125a44:	a5000c04 	addi	r20,r20,48
81125a48:	dc001dc4 	addi	r16,sp,119
81125a4c:	dd001dc5 	stb	r20,119(sp)
81125a50:	d8c02817 	ldw	r3,160(sp)
81125a54:	1c07c83a 	sub	r3,r3,r16
81125a58:	d8c02e15 	stw	r3,184(sp)
81125a5c:	003cf506 	br	81124e34 <__reset+0xfb104e34>
81125a60:	d8803317 	ldw	r2,204(sp)
81125a64:	143fffc4 	addi	r16,r2,-1
81125a68:	043f560e 	bge	zero,r16,811257c4 <__reset+0xfb1057c4>
81125a6c:	07000404 	movi	fp,16
81125a70:	e403530e 	bge	fp,r16,811267c0 <___svfprintf_internal_r+0x2034>
81125a74:	01604574 	movhi	r5,33045
81125a78:	29472984 	addi	r5,r5,7334
81125a7c:	d9402b15 	stw	r5,172(sp)
81125a80:	01c001c4 	movi	r7,7
81125a84:	dd002c17 	ldw	r20,176(sp)
81125a88:	00000306 	br	81125a98 <___svfprintf_internal_r+0x130c>
81125a8c:	843ffc04 	addi	r16,r16,-16
81125a90:	b5800204 	addi	r22,r22,8
81125a94:	e400130e 	bge	fp,r16,81125ae4 <___svfprintf_internal_r+0x1358>
81125a98:	18c00404 	addi	r3,r3,16
81125a9c:	8c400044 	addi	r17,r17,1
81125aa0:	b5400015 	stw	r21,0(r22)
81125aa4:	b7000115 	stw	fp,4(r22)
81125aa8:	d8c02015 	stw	r3,128(sp)
81125aac:	dc401f15 	stw	r17,124(sp)
81125ab0:	3c7ff60e 	bge	r7,r17,81125a8c <__reset+0xfb105a8c>
81125ab4:	d9801e04 	addi	r6,sp,120
81125ab8:	a00b883a 	mov	r5,r20
81125abc:	9809883a 	mov	r4,r19
81125ac0:	d9c03d15 	stw	r7,244(sp)
81125ac4:	11313ac0 	call	811313ac <__ssprint_r>
81125ac8:	d9c03d17 	ldw	r7,244(sp)
81125acc:	103c161e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125ad0:	843ffc04 	addi	r16,r16,-16
81125ad4:	d8c02017 	ldw	r3,128(sp)
81125ad8:	dc401f17 	ldw	r17,124(sp)
81125adc:	dd800404 	addi	r22,sp,16
81125ae0:	e43fed16 	blt	fp,r16,81125a98 <__reset+0xfb105a98>
81125ae4:	d8802b17 	ldw	r2,172(sp)
81125ae8:	1c07883a 	add	r3,r3,r16
81125aec:	8c400044 	addi	r17,r17,1
81125af0:	b0800015 	stw	r2,0(r22)
81125af4:	b4000115 	stw	r16,4(r22)
81125af8:	d8c02015 	stw	r3,128(sp)
81125afc:	dc401f15 	stw	r17,124(sp)
81125b00:	008001c4 	movi	r2,7
81125b04:	147f2e0e 	bge	r2,r17,811257c0 <__reset+0xfb1057c0>
81125b08:	d9402c17 	ldw	r5,176(sp)
81125b0c:	d9801e04 	addi	r6,sp,120
81125b10:	9809883a 	mov	r4,r19
81125b14:	11313ac0 	call	811313ac <__ssprint_r>
81125b18:	103c031e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125b1c:	d8c02017 	ldw	r3,128(sp)
81125b20:	dc401f17 	ldw	r17,124(sp)
81125b24:	dd800404 	addi	r22,sp,16
81125b28:	003f2606 	br	811257c4 <__reset+0xfb1057c4>
81125b2c:	9080040c 	andi	r2,r18,16
81125b30:	1000c326 	beq	r2,zero,81125e40 <___svfprintf_internal_r+0x16b4>
81125b34:	d8802d17 	ldw	r2,180(sp)
81125b38:	15000017 	ldw	r20,0(r2)
81125b3c:	10800104 	addi	r2,r2,4
81125b40:	d8802d15 	stw	r2,180(sp)
81125b44:	a02dd7fa 	srai	r22,r20,31
81125b48:	b005883a 	mov	r2,r22
81125b4c:	103c680e 	bge	r2,zero,81124cf0 <__reset+0xfb104cf0>
81125b50:	0529c83a 	sub	r20,zero,r20
81125b54:	a004c03a 	cmpne	r2,r20,zero
81125b58:	05adc83a 	sub	r22,zero,r22
81125b5c:	b0adc83a 	sub	r22,r22,r2
81125b60:	d8802917 	ldw	r2,164(sp)
81125b64:	07000b44 	movi	fp,45
81125b68:	df002785 	stb	fp,158(sp)
81125b6c:	10022e16 	blt	r2,zero,81126428 <___svfprintf_internal_r+0x1c9c>
81125b70:	00bfdfc4 	movi	r2,-129
81125b74:	90a4703a 	and	r18,r18,r2
81125b78:	003c6406 	br	81124d0c <__reset+0xfb104d0c>
81125b7c:	9080100c 	andi	r2,r18,64
81125b80:	d8002785 	stb	zero,158(sp)
81125b84:	10012526 	beq	r2,zero,8112601c <___svfprintf_internal_r+0x1890>
81125b88:	d9002d17 	ldw	r4,180(sp)
81125b8c:	d9402917 	ldw	r5,164(sp)
81125b90:	002d883a 	mov	r22,zero
81125b94:	20800104 	addi	r2,r4,4
81125b98:	2500000b 	ldhu	r20,0(r4)
81125b9c:	283fa20e 	bge	r5,zero,81125a28 <__reset+0xfb105a28>
81125ba0:	d8802d15 	stw	r2,180(sp)
81125ba4:	0039883a 	mov	fp,zero
81125ba8:	a584b03a 	or	r2,r20,r22
81125bac:	103c571e 	bne	r2,zero,81124d0c <__reset+0xfb104d0c>
81125bb0:	00800044 	movi	r2,1
81125bb4:	003e5006 	br	811254f8 <__reset+0xfb1054f8>
81125bb8:	d9402c17 	ldw	r5,176(sp)
81125bbc:	d9801e04 	addi	r6,sp,120
81125bc0:	9809883a 	mov	r4,r19
81125bc4:	11313ac0 	call	811313ac <__ssprint_r>
81125bc8:	103bd71e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125bcc:	d8c02017 	ldw	r3,128(sp)
81125bd0:	da000404 	addi	r8,sp,16
81125bd4:	d9003217 	ldw	r4,200(sp)
81125bd8:	d8802617 	ldw	r2,152(sp)
81125bdc:	d9403317 	ldw	r5,204(sp)
81125be0:	8123883a 	add	r17,r16,r4
81125be4:	11400216 	blt	r2,r5,81125bf0 <___svfprintf_internal_r+0x1464>
81125be8:	9100004c 	andi	r4,r18,1
81125bec:	20000d26 	beq	r4,zero,81125c24 <___svfprintf_internal_r+0x1498>
81125bf0:	d9003817 	ldw	r4,224(sp)
81125bf4:	d9403417 	ldw	r5,208(sp)
81125bf8:	1907883a 	add	r3,r3,r4
81125bfc:	d9001f17 	ldw	r4,124(sp)
81125c00:	41400015 	stw	r5,0(r8)
81125c04:	d9403817 	ldw	r5,224(sp)
81125c08:	21000044 	addi	r4,r4,1
81125c0c:	d8c02015 	stw	r3,128(sp)
81125c10:	41400115 	stw	r5,4(r8)
81125c14:	d9001f15 	stw	r4,124(sp)
81125c18:	014001c4 	movi	r5,7
81125c1c:	2901dc16 	blt	r5,r4,81126390 <___svfprintf_internal_r+0x1c04>
81125c20:	42000204 	addi	r8,r8,8
81125c24:	d9003317 	ldw	r4,204(sp)
81125c28:	8121883a 	add	r16,r16,r4
81125c2c:	2085c83a 	sub	r2,r4,r2
81125c30:	8461c83a 	sub	r16,r16,r17
81125c34:	1400010e 	bge	r2,r16,81125c3c <___svfprintf_internal_r+0x14b0>
81125c38:	1021883a 	mov	r16,r2
81125c3c:	04000a0e 	bge	zero,r16,81125c68 <___svfprintf_internal_r+0x14dc>
81125c40:	d9001f17 	ldw	r4,124(sp)
81125c44:	1c07883a 	add	r3,r3,r16
81125c48:	44400015 	stw	r17,0(r8)
81125c4c:	21000044 	addi	r4,r4,1
81125c50:	44000115 	stw	r16,4(r8)
81125c54:	d8c02015 	stw	r3,128(sp)
81125c58:	d9001f15 	stw	r4,124(sp)
81125c5c:	014001c4 	movi	r5,7
81125c60:	2901e616 	blt	r5,r4,811263fc <___svfprintf_internal_r+0x1c70>
81125c64:	42000204 	addi	r8,r8,8
81125c68:	8001f616 	blt	r16,zero,81126444 <___svfprintf_internal_r+0x1cb8>
81125c6c:	1421c83a 	sub	r16,r2,r16
81125c70:	043d1c0e 	bge	zero,r16,811250e4 <__reset+0xfb1050e4>
81125c74:	04400404 	movi	r17,16
81125c78:	d8801f17 	ldw	r2,124(sp)
81125c7c:	8c3edd0e 	bge	r17,r16,811257f4 <__reset+0xfb1057f4>
81125c80:	01604574 	movhi	r5,33045
81125c84:	29472984 	addi	r5,r5,7334
81125c88:	d9402b15 	stw	r5,172(sp)
81125c8c:	058001c4 	movi	r22,7
81125c90:	dd002c17 	ldw	r20,176(sp)
81125c94:	00000306 	br	81125ca4 <___svfprintf_internal_r+0x1518>
81125c98:	42000204 	addi	r8,r8,8
81125c9c:	843ffc04 	addi	r16,r16,-16
81125ca0:	8c3ed70e 	bge	r17,r16,81125800 <__reset+0xfb105800>
81125ca4:	18c00404 	addi	r3,r3,16
81125ca8:	10800044 	addi	r2,r2,1
81125cac:	45400015 	stw	r21,0(r8)
81125cb0:	44400115 	stw	r17,4(r8)
81125cb4:	d8c02015 	stw	r3,128(sp)
81125cb8:	d8801f15 	stw	r2,124(sp)
81125cbc:	b0bff60e 	bge	r22,r2,81125c98 <__reset+0xfb105c98>
81125cc0:	d9801e04 	addi	r6,sp,120
81125cc4:	a00b883a 	mov	r5,r20
81125cc8:	9809883a 	mov	r4,r19
81125ccc:	11313ac0 	call	811313ac <__ssprint_r>
81125cd0:	103b951e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125cd4:	d8c02017 	ldw	r3,128(sp)
81125cd8:	d8801f17 	ldw	r2,124(sp)
81125cdc:	da000404 	addi	r8,sp,16
81125ce0:	003fee06 	br	81125c9c <__reset+0xfb105c9c>
81125ce4:	9088703a 	and	r4,r18,r2
81125ce8:	203e8d1e 	bne	r4,zero,81125720 <__reset+0xfb105720>
81125cec:	dc401f17 	ldw	r17,124(sp)
81125cf0:	40800115 	stw	r2,4(r8)
81125cf4:	44000015 	stw	r16,0(r8)
81125cf8:	8c400044 	addi	r17,r17,1
81125cfc:	d8c02015 	stw	r3,128(sp)
81125d00:	dc401f15 	stw	r17,124(sp)
81125d04:	008001c4 	movi	r2,7
81125d08:	147f7f16 	blt	r2,r17,81125b08 <__reset+0xfb105b08>
81125d0c:	45800204 	addi	r22,r8,8
81125d10:	003eac06 	br	811257c4 <__reset+0xfb1057c4>
81125d14:	d9402c17 	ldw	r5,176(sp)
81125d18:	d9801e04 	addi	r6,sp,120
81125d1c:	9809883a 	mov	r4,r19
81125d20:	11313ac0 	call	811313ac <__ssprint_r>
81125d24:	103b801e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125d28:	d8c02017 	ldw	r3,128(sp)
81125d2c:	dc401f17 	ldw	r17,124(sp)
81125d30:	da000404 	addi	r8,sp,16
81125d34:	003e8406 	br	81125748 <__reset+0xfb105748>
81125d38:	d9402c17 	ldw	r5,176(sp)
81125d3c:	d9801e04 	addi	r6,sp,120
81125d40:	9809883a 	mov	r4,r19
81125d44:	11313ac0 	call	811313ac <__ssprint_r>
81125d48:	103b771e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125d4c:	d8c02017 	ldw	r3,128(sp)
81125d50:	dc401f17 	ldw	r17,124(sp)
81125d54:	dd800404 	addi	r22,sp,16
81125d58:	003e8606 	br	81125774 <__reset+0xfb105774>
81125d5c:	0029883a 	mov	r20,zero
81125d60:	a5000c04 	addi	r20,r20,48
81125d64:	dc001dc4 	addi	r16,sp,119
81125d68:	dd001dc5 	stb	r20,119(sp)
81125d6c:	003f3806 	br	81125a50 <__reset+0xfb105a50>
81125d70:	d9402c17 	ldw	r5,176(sp)
81125d74:	d9801e04 	addi	r6,sp,120
81125d78:	9809883a 	mov	r4,r19
81125d7c:	11313ac0 	call	811313ac <__ssprint_r>
81125d80:	103b691e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125d84:	d8c02017 	ldw	r3,128(sp)
81125d88:	da000404 	addi	r8,sp,16
81125d8c:	003c9506 	br	81124fe4 <__reset+0xfb104fe4>
81125d90:	d9003617 	ldw	r4,216(sp)
81125d94:	d9403717 	ldw	r5,220(sp)
81125d98:	da003e15 	stw	r8,248(sp)
81125d9c:	112f1c00 	call	8112f1c0 <__fpclassifyd>
81125da0:	da003e17 	ldw	r8,248(sp)
81125da4:	1000bd1e 	bne	r2,zero,8112609c <___svfprintf_internal_r+0x1910>
81125da8:	008011c4 	movi	r2,71
81125dac:	14411e0e 	bge	r2,r17,81126228 <___svfprintf_internal_r+0x1a9c>
81125db0:	04204574 	movhi	r16,33045
81125db4:	84071c04 	addi	r16,r16,7280
81125db8:	00c000c4 	movi	r3,3
81125dbc:	00bfdfc4 	movi	r2,-129
81125dc0:	d8c02a15 	stw	r3,168(sp)
81125dc4:	90a4703a 	and	r18,r18,r2
81125dc8:	df002783 	ldbu	fp,158(sp)
81125dcc:	d8c02e15 	stw	r3,184(sp)
81125dd0:	d8002915 	stw	zero,164(sp)
81125dd4:	d8003215 	stw	zero,200(sp)
81125dd8:	003c1c06 	br	81124e4c <__reset+0xfb104e4c>
81125ddc:	9080100c 	andi	r2,r18,64
81125de0:	d8002785 	stb	zero,158(sp)
81125de4:	10009426 	beq	r2,zero,81126038 <___svfprintf_internal_r+0x18ac>
81125de8:	d8c02d17 	ldw	r3,180(sp)
81125dec:	d9002917 	ldw	r4,164(sp)
81125df0:	002d883a 	mov	r22,zero
81125df4:	18800104 	addi	r2,r3,4
81125df8:	1d00000b 	ldhu	r20,0(r3)
81125dfc:	203ec10e 	bge	r4,zero,81125904 <__reset+0xfb105904>
81125e00:	a586b03a 	or	r3,r20,r22
81125e04:	d8802d15 	stw	r2,180(sp)
81125e08:	183ec21e 	bne	r3,zero,81125914 <__reset+0xfb105914>
81125e0c:	0039883a 	mov	fp,zero
81125e10:	0005883a 	mov	r2,zero
81125e14:	003db806 	br	811254f8 <__reset+0xfb1054f8>
81125e18:	d8802d17 	ldw	r2,180(sp)
81125e1c:	d8c02d17 	ldw	r3,180(sp)
81125e20:	d9002d17 	ldw	r4,180(sp)
81125e24:	10800017 	ldw	r2,0(r2)
81125e28:	18c00117 	ldw	r3,4(r3)
81125e2c:	21000204 	addi	r4,r4,8
81125e30:	d8803615 	stw	r2,216(sp)
81125e34:	d8c03715 	stw	r3,220(sp)
81125e38:	d9002d15 	stw	r4,180(sp)
81125e3c:	003b8206 	br	81124c48 <__reset+0xfb104c48>
81125e40:	9080100c 	andi	r2,r18,64
81125e44:	10010726 	beq	r2,zero,81126264 <___svfprintf_internal_r+0x1ad8>
81125e48:	d8c02d17 	ldw	r3,180(sp)
81125e4c:	1d00000f 	ldh	r20,0(r3)
81125e50:	18c00104 	addi	r3,r3,4
81125e54:	d8c02d15 	stw	r3,180(sp)
81125e58:	a02dd7fa 	srai	r22,r20,31
81125e5c:	b005883a 	mov	r2,r22
81125e60:	003ba206 	br	81124cec <__reset+0xfb104cec>
81125e64:	9080100c 	andi	r2,r18,64
81125e68:	10010526 	beq	r2,zero,81126280 <___svfprintf_internal_r+0x1af4>
81125e6c:	d9002d17 	ldw	r4,180(sp)
81125e70:	002d883a 	mov	r22,zero
81125e74:	2500000b 	ldhu	r20,0(r4)
81125e78:	21000104 	addi	r4,r4,4
81125e7c:	d9002d15 	stw	r4,180(sp)
81125e80:	003cfe06 	br	8112527c <__reset+0xfb10527c>
81125e84:	bc400007 	ldb	r17,0(r23)
81125e88:	003a9606 	br	811248e4 <__reset+0xfb1048e4>
81125e8c:	9080040c 	andi	r2,r18,16
81125e90:	10010126 	beq	r2,zero,81126298 <___svfprintf_internal_r+0x1b0c>
81125e94:	d9402d17 	ldw	r5,180(sp)
81125e98:	d8c02f17 	ldw	r3,188(sp)
81125e9c:	28800017 	ldw	r2,0(r5)
81125ea0:	29400104 	addi	r5,r5,4
81125ea4:	d9402d15 	stw	r5,180(sp)
81125ea8:	10c00015 	stw	r3,0(r2)
81125eac:	003a6406 	br	81124840 <__reset+0xfb104840>
81125eb0:	d9002917 	ldw	r4,164(sp)
81125eb4:	d8002785 	stb	zero,158(sp)
81125eb8:	203d8d16 	blt	r4,zero,811254f0 <__reset+0xfb1054f0>
81125ebc:	00bfdfc4 	movi	r2,-129
81125ec0:	90a4703a 	and	r18,r18,r2
81125ec4:	003b0506 	br	81124adc <__reset+0xfb104adc>
81125ec8:	01604574 	movhi	r5,33045
81125ecc:	29472984 	addi	r5,r5,7334
81125ed0:	d9402b15 	stw	r5,172(sp)
81125ed4:	d9402b17 	ldw	r5,172(sp)
81125ed8:	1c47883a 	add	r3,r3,r17
81125edc:	10800044 	addi	r2,r2,1
81125ee0:	41400015 	stw	r5,0(r8)
81125ee4:	44400115 	stw	r17,4(r8)
81125ee8:	d8c02015 	stw	r3,128(sp)
81125eec:	d8801f15 	stw	r2,124(sp)
81125ef0:	010001c4 	movi	r4,7
81125ef4:	20bf3016 	blt	r4,r2,81125bb8 <__reset+0xfb105bb8>
81125ef8:	42000204 	addi	r8,r8,8
81125efc:	003f3506 	br	81125bd4 <__reset+0xfb105bd4>
81125f00:	01204574 	movhi	r4,33045
81125f04:	21072984 	addi	r4,r4,7334
81125f08:	d9002b15 	stw	r4,172(sp)
81125f0c:	003c5e06 	br	81125088 <__reset+0xfb105088>
81125f10:	d9402c17 	ldw	r5,176(sp)
81125f14:	d9801e04 	addi	r6,sp,120
81125f18:	9809883a 	mov	r4,r19
81125f1c:	11313ac0 	call	811313ac <__ssprint_r>
81125f20:	103b011e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81125f24:	d8c02017 	ldw	r3,128(sp)
81125f28:	da000404 	addi	r8,sp,16
81125f2c:	003d9306 	br	8112557c <__reset+0xfb10557c>
81125f30:	d8801f17 	ldw	r2,124(sp)
81125f34:	01604574 	movhi	r5,33045
81125f38:	01000044 	movi	r4,1
81125f3c:	18c00044 	addi	r3,r3,1
81125f40:	10800044 	addi	r2,r2,1
81125f44:	29472904 	addi	r5,r5,7332
81125f48:	41000115 	stw	r4,4(r8)
81125f4c:	41400015 	stw	r5,0(r8)
81125f50:	d8c02015 	stw	r3,128(sp)
81125f54:	d8801f15 	stw	r2,124(sp)
81125f58:	010001c4 	movi	r4,7
81125f5c:	2080b516 	blt	r4,r2,81126234 <___svfprintf_internal_r+0x1aa8>
81125f60:	42000204 	addi	r8,r8,8
81125f64:	8800041e 	bne	r17,zero,81125f78 <___svfprintf_internal_r+0x17ec>
81125f68:	d8803317 	ldw	r2,204(sp)
81125f6c:	1000021e 	bne	r2,zero,81125f78 <___svfprintf_internal_r+0x17ec>
81125f70:	9080004c 	andi	r2,r18,1
81125f74:	103c5b26 	beq	r2,zero,811250e4 <__reset+0xfb1050e4>
81125f78:	d9003817 	ldw	r4,224(sp)
81125f7c:	d8801f17 	ldw	r2,124(sp)
81125f80:	d9403417 	ldw	r5,208(sp)
81125f84:	20c7883a 	add	r3,r4,r3
81125f88:	10800044 	addi	r2,r2,1
81125f8c:	41000115 	stw	r4,4(r8)
81125f90:	41400015 	stw	r5,0(r8)
81125f94:	d8c02015 	stw	r3,128(sp)
81125f98:	d8801f15 	stw	r2,124(sp)
81125f9c:	010001c4 	movi	r4,7
81125fa0:	20818016 	blt	r4,r2,811265a4 <___svfprintf_internal_r+0x1e18>
81125fa4:	42000204 	addi	r8,r8,8
81125fa8:	0463c83a 	sub	r17,zero,r17
81125fac:	0440cb0e 	bge	zero,r17,811262dc <___svfprintf_internal_r+0x1b50>
81125fb0:	05800404 	movi	r22,16
81125fb4:	b440e80e 	bge	r22,r17,81126358 <___svfprintf_internal_r+0x1bcc>
81125fb8:	01604574 	movhi	r5,33045
81125fbc:	29472984 	addi	r5,r5,7334
81125fc0:	d9402b15 	stw	r5,172(sp)
81125fc4:	070001c4 	movi	fp,7
81125fc8:	dd002c17 	ldw	r20,176(sp)
81125fcc:	00000306 	br	81125fdc <___svfprintf_internal_r+0x1850>
81125fd0:	42000204 	addi	r8,r8,8
81125fd4:	8c7ffc04 	addi	r17,r17,-16
81125fd8:	b440e20e 	bge	r22,r17,81126364 <___svfprintf_internal_r+0x1bd8>
81125fdc:	18c00404 	addi	r3,r3,16
81125fe0:	10800044 	addi	r2,r2,1
81125fe4:	45400015 	stw	r21,0(r8)
81125fe8:	45800115 	stw	r22,4(r8)
81125fec:	d8c02015 	stw	r3,128(sp)
81125ff0:	d8801f15 	stw	r2,124(sp)
81125ff4:	e0bff60e 	bge	fp,r2,81125fd0 <__reset+0xfb105fd0>
81125ff8:	d9801e04 	addi	r6,sp,120
81125ffc:	a00b883a 	mov	r5,r20
81126000:	9809883a 	mov	r4,r19
81126004:	11313ac0 	call	811313ac <__ssprint_r>
81126008:	103ac71e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
8112600c:	d8c02017 	ldw	r3,128(sp)
81126010:	d8801f17 	ldw	r2,124(sp)
81126014:	da000404 	addi	r8,sp,16
81126018:	003fee06 	br	81125fd4 <__reset+0xfb105fd4>
8112601c:	d8c02d17 	ldw	r3,180(sp)
81126020:	d9002917 	ldw	r4,164(sp)
81126024:	002d883a 	mov	r22,zero
81126028:	18800104 	addi	r2,r3,4
8112602c:	1d000017 	ldw	r20,0(r3)
81126030:	203e7d0e 	bge	r4,zero,81125a28 <__reset+0xfb105a28>
81126034:	003eda06 	br	81125ba0 <__reset+0xfb105ba0>
81126038:	d9402d17 	ldw	r5,180(sp)
8112603c:	d8c02917 	ldw	r3,164(sp)
81126040:	002d883a 	mov	r22,zero
81126044:	28800104 	addi	r2,r5,4
81126048:	2d000017 	ldw	r20,0(r5)
8112604c:	183e2d0e 	bge	r3,zero,81125904 <__reset+0xfb105904>
81126050:	003f6b06 	br	81125e00 <__reset+0xfb105e00>
81126054:	d8c02d15 	stw	r3,180(sp)
81126058:	0039883a 	mov	fp,zero
8112605c:	003ed206 	br	81125ba8 <__reset+0xfb105ba8>
81126060:	bc400043 	ldbu	r17,1(r23)
81126064:	94800814 	ori	r18,r18,32
81126068:	bdc00044 	addi	r23,r23,1
8112606c:	8c403fcc 	andi	r17,r17,255
81126070:	8c40201c 	xori	r17,r17,128
81126074:	8c7fe004 	addi	r17,r17,-128
81126078:	003a1a06 	br	811248e4 <__reset+0xfb1048e4>
8112607c:	d9402c17 	ldw	r5,176(sp)
81126080:	d9801e04 	addi	r6,sp,120
81126084:	9809883a 	mov	r4,r19
81126088:	11313ac0 	call	811313ac <__ssprint_r>
8112608c:	103aa61e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81126090:	d8c02017 	ldw	r3,128(sp)
81126094:	da000404 	addi	r8,sp,16
81126098:	003d4a06 	br	811255c4 <__reset+0xfb1055c4>
8112609c:	d9002917 	ldw	r4,164(sp)
811260a0:	05bff7c4 	movi	r22,-33
811260a4:	00bfffc4 	movi	r2,-1
811260a8:	8dac703a 	and	r22,r17,r22
811260ac:	20806a26 	beq	r4,r2,81126258 <___svfprintf_internal_r+0x1acc>
811260b0:	008011c4 	movi	r2,71
811260b4:	b0813726 	beq	r22,r2,81126594 <___svfprintf_internal_r+0x1e08>
811260b8:	d9003717 	ldw	r4,220(sp)
811260bc:	90c04014 	ori	r3,r18,256
811260c0:	d8c02b15 	stw	r3,172(sp)
811260c4:	20015d16 	blt	r4,zero,8112663c <___svfprintf_internal_r+0x1eb0>
811260c8:	dd003717 	ldw	r20,220(sp)
811260cc:	d8002a05 	stb	zero,168(sp)
811260d0:	00801984 	movi	r2,102
811260d4:	88814026 	beq	r17,r2,811265d8 <___svfprintf_internal_r+0x1e4c>
811260d8:	00801184 	movi	r2,70
811260dc:	88817126 	beq	r17,r2,811266a4 <___svfprintf_internal_r+0x1f18>
811260e0:	00801144 	movi	r2,69
811260e4:	b0816226 	beq	r22,r2,81126670 <___svfprintf_internal_r+0x1ee4>
811260e8:	d8c02917 	ldw	r3,164(sp)
811260ec:	d8802104 	addi	r2,sp,132
811260f0:	d8800315 	stw	r2,12(sp)
811260f4:	d9403617 	ldw	r5,216(sp)
811260f8:	d8802504 	addi	r2,sp,148
811260fc:	d8800215 	stw	r2,8(sp)
81126100:	d8802604 	addi	r2,sp,152
81126104:	d8c00015 	stw	r3,0(sp)
81126108:	d8800115 	stw	r2,4(sp)
8112610c:	01c00084 	movi	r7,2
81126110:	a00d883a 	mov	r6,r20
81126114:	9809883a 	mov	r4,r19
81126118:	d8c03d15 	stw	r3,244(sp)
8112611c:	da003e15 	stw	r8,248(sp)
81126120:	112aa780 	call	8112aa78 <_dtoa_r>
81126124:	1021883a 	mov	r16,r2
81126128:	008019c4 	movi	r2,103
8112612c:	d8c03d17 	ldw	r3,244(sp)
81126130:	da003e17 	ldw	r8,248(sp)
81126134:	8880e726 	beq	r17,r2,811264d4 <___svfprintf_internal_r+0x1d48>
81126138:	008011c4 	movi	r2,71
8112613c:	8880d426 	beq	r17,r2,81126490 <___svfprintf_internal_r+0x1d04>
81126140:	80f9883a 	add	fp,r16,r3
81126144:	d9003617 	ldw	r4,216(sp)
81126148:	000d883a 	mov	r6,zero
8112614c:	000f883a 	mov	r7,zero
81126150:	a00b883a 	mov	r5,r20
81126154:	da003e15 	stw	r8,248(sp)
81126158:	11373280 	call	81137328 <__eqdf2>
8112615c:	da003e17 	ldw	r8,248(sp)
81126160:	1000e426 	beq	r2,zero,811264f4 <___svfprintf_internal_r+0x1d68>
81126164:	d8802117 	ldw	r2,132(sp)
81126168:	1700062e 	bgeu	r2,fp,81126184 <___svfprintf_internal_r+0x19f8>
8112616c:	01000c04 	movi	r4,48
81126170:	10c00044 	addi	r3,r2,1
81126174:	d8c02115 	stw	r3,132(sp)
81126178:	11000005 	stb	r4,0(r2)
8112617c:	d8802117 	ldw	r2,132(sp)
81126180:	173ffb36 	bltu	r2,fp,81126170 <__reset+0xfb106170>
81126184:	1405c83a 	sub	r2,r2,r16
81126188:	d8803315 	stw	r2,204(sp)
8112618c:	008011c4 	movi	r2,71
81126190:	b080c526 	beq	r22,r2,811264a8 <___svfprintf_internal_r+0x1d1c>
81126194:	00801944 	movi	r2,101
81126198:	1441d90e 	bge	r2,r17,81126900 <___svfprintf_internal_r+0x2174>
8112619c:	d8c02617 	ldw	r3,152(sp)
811261a0:	00801984 	movi	r2,102
811261a4:	d8c03215 	stw	r3,200(sp)
811261a8:	88813426 	beq	r17,r2,8112667c <___svfprintf_internal_r+0x1ef0>
811261ac:	d8c03217 	ldw	r3,200(sp)
811261b0:	d9003317 	ldw	r4,204(sp)
811261b4:	19012516 	blt	r3,r4,8112664c <___svfprintf_internal_r+0x1ec0>
811261b8:	9480004c 	andi	r18,r18,1
811261bc:	9001841e 	bne	r18,zero,811267d0 <___svfprintf_internal_r+0x2044>
811261c0:	1805883a 	mov	r2,r3
811261c4:	1801cc16 	blt	r3,zero,811268f8 <___svfprintf_internal_r+0x216c>
811261c8:	d8c03217 	ldw	r3,200(sp)
811261cc:	044019c4 	movi	r17,103
811261d0:	d8c02e15 	stw	r3,184(sp)
811261d4:	df002a07 	ldb	fp,168(sp)
811261d8:	e000a61e 	bne	fp,zero,81126474 <___svfprintf_internal_r+0x1ce8>
811261dc:	df002783 	ldbu	fp,158(sp)
811261e0:	d8802a15 	stw	r2,168(sp)
811261e4:	dc802b17 	ldw	r18,172(sp)
811261e8:	d8002915 	stw	zero,164(sp)
811261ec:	003b1706 	br	81124e4c <__reset+0xfb104e4c>
811261f0:	04204574 	movhi	r16,33045
811261f4:	84071904 	addi	r16,r16,7268
811261f8:	003aa606 	br	81124c94 <__reset+0xfb104c94>
811261fc:	d9003917 	ldw	r4,228(sp)
81126200:	04001004 	movi	r16,64
81126204:	800b883a 	mov	r5,r16
81126208:	11231c80 	call	811231c8 <_malloc_r>
8112620c:	d9002c17 	ldw	r4,176(sp)
81126210:	20800015 	stw	r2,0(r4)
81126214:	20800415 	stw	r2,16(r4)
81126218:	1001cb26 	beq	r2,zero,81126948 <___svfprintf_internal_r+0x21bc>
8112621c:	d8802c17 	ldw	r2,176(sp)
81126220:	14000515 	stw	r16,20(r2)
81126224:	00397606 	br	81124800 <__reset+0xfb104800>
81126228:	04204574 	movhi	r16,33045
8112622c:	84071b04 	addi	r16,r16,7276
81126230:	003ee106 	br	81125db8 <__reset+0xfb105db8>
81126234:	d9402c17 	ldw	r5,176(sp)
81126238:	d9801e04 	addi	r6,sp,120
8112623c:	9809883a 	mov	r4,r19
81126240:	11313ac0 	call	811313ac <__ssprint_r>
81126244:	103a381e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81126248:	dc402617 	ldw	r17,152(sp)
8112624c:	d8c02017 	ldw	r3,128(sp)
81126250:	da000404 	addi	r8,sp,16
81126254:	003f4306 	br	81125f64 <__reset+0xfb105f64>
81126258:	01400184 	movi	r5,6
8112625c:	d9402915 	stw	r5,164(sp)
81126260:	003f9506 	br	811260b8 <__reset+0xfb1060b8>
81126264:	d9002d17 	ldw	r4,180(sp)
81126268:	25000017 	ldw	r20,0(r4)
8112626c:	21000104 	addi	r4,r4,4
81126270:	d9002d15 	stw	r4,180(sp)
81126274:	a02dd7fa 	srai	r22,r20,31
81126278:	b005883a 	mov	r2,r22
8112627c:	003a9b06 	br	81124cec <__reset+0xfb104cec>
81126280:	d9402d17 	ldw	r5,180(sp)
81126284:	002d883a 	mov	r22,zero
81126288:	2d000017 	ldw	r20,0(r5)
8112628c:	29400104 	addi	r5,r5,4
81126290:	d9402d15 	stw	r5,180(sp)
81126294:	003bf906 	br	8112527c <__reset+0xfb10527c>
81126298:	9480100c 	andi	r18,r18,64
8112629c:	90006e26 	beq	r18,zero,81126458 <___svfprintf_internal_r+0x1ccc>
811262a0:	d9002d17 	ldw	r4,180(sp)
811262a4:	d9402f17 	ldw	r5,188(sp)
811262a8:	20800017 	ldw	r2,0(r4)
811262ac:	21000104 	addi	r4,r4,4
811262b0:	d9002d15 	stw	r4,180(sp)
811262b4:	1140000d 	sth	r5,0(r2)
811262b8:	00396106 	br	81124840 <__reset+0xfb104840>
811262bc:	d9402c17 	ldw	r5,176(sp)
811262c0:	d9801e04 	addi	r6,sp,120
811262c4:	9809883a 	mov	r4,r19
811262c8:	11313ac0 	call	811313ac <__ssprint_r>
811262cc:	103a161e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
811262d0:	d8c02017 	ldw	r3,128(sp)
811262d4:	d8801f17 	ldw	r2,124(sp)
811262d8:	da000404 	addi	r8,sp,16
811262dc:	d9403317 	ldw	r5,204(sp)
811262e0:	10800044 	addi	r2,r2,1
811262e4:	44000015 	stw	r16,0(r8)
811262e8:	28c7883a 	add	r3,r5,r3
811262ec:	003b7706 	br	811250cc <__reset+0xfb1050cc>
811262f0:	8009883a 	mov	r4,r16
811262f4:	da003e15 	stw	r8,248(sp)
811262f8:	11244540 	call	81124454 <strlen>
811262fc:	d8802e15 	stw	r2,184(sp)
81126300:	da003e17 	ldw	r8,248(sp)
81126304:	103c280e 	bge	r2,zero,811253a8 <__reset+0xfb1053a8>
81126308:	0005883a 	mov	r2,zero
8112630c:	003c2606 	br	811253a8 <__reset+0xfb1053a8>
81126310:	00bfffc4 	movi	r2,-1
81126314:	003a0906 	br	81124b3c <__reset+0xfb104b3c>
81126318:	01204574 	movhi	r4,33045
8112631c:	21072d84 	addi	r4,r4,7350
81126320:	d9003515 	stw	r4,212(sp)
81126324:	003b0606 	br	81124f40 <__reset+0xfb104f40>
81126328:	013fffc4 	movi	r4,-1
8112632c:	003a2706 	br	81124bcc <__reset+0xfb104bcc>
81126330:	d9402c17 	ldw	r5,176(sp)
81126334:	d9801e04 	addi	r6,sp,120
81126338:	9809883a 	mov	r4,r19
8112633c:	11313ac0 	call	811313ac <__ssprint_r>
81126340:	1039f91e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81126344:	d8c02017 	ldw	r3,128(sp)
81126348:	da000404 	addi	r8,sp,16
8112634c:	003d8406 	br	81125960 <__reset+0xfb105960>
81126350:	0023883a 	mov	r17,zero
81126354:	003d8306 	br	81125964 <__reset+0xfb105964>
81126358:	01204574 	movhi	r4,33045
8112635c:	21072984 	addi	r4,r4,7334
81126360:	d9002b15 	stw	r4,172(sp)
81126364:	d9002b17 	ldw	r4,172(sp)
81126368:	1c47883a 	add	r3,r3,r17
8112636c:	10800044 	addi	r2,r2,1
81126370:	41000015 	stw	r4,0(r8)
81126374:	44400115 	stw	r17,4(r8)
81126378:	d8c02015 	stw	r3,128(sp)
8112637c:	d8801f15 	stw	r2,124(sp)
81126380:	010001c4 	movi	r4,7
81126384:	20bfcd16 	blt	r4,r2,811262bc <__reset+0xfb1062bc>
81126388:	42000204 	addi	r8,r8,8
8112638c:	003fd306 	br	811262dc <__reset+0xfb1062dc>
81126390:	d9402c17 	ldw	r5,176(sp)
81126394:	d9801e04 	addi	r6,sp,120
81126398:	9809883a 	mov	r4,r19
8112639c:	11313ac0 	call	811313ac <__ssprint_r>
811263a0:	1039e11e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
811263a4:	d8802617 	ldw	r2,152(sp)
811263a8:	d8c02017 	ldw	r3,128(sp)
811263ac:	da000404 	addi	r8,sp,16
811263b0:	003e1c06 	br	81125c24 <__reset+0xfb105c24>
811263b4:	d8802917 	ldw	r2,164(sp)
811263b8:	00c00184 	movi	r3,6
811263bc:	1880012e 	bgeu	r3,r2,811263c4 <___svfprintf_internal_r+0x1c38>
811263c0:	1805883a 	mov	r2,r3
811263c4:	d8802e15 	stw	r2,184(sp)
811263c8:	1000f316 	blt	r2,zero,81126798 <___svfprintf_internal_r+0x200c>
811263cc:	04204574 	movhi	r16,33045
811263d0:	d8802a15 	stw	r2,168(sp)
811263d4:	dd002d15 	stw	r20,180(sp)
811263d8:	d8002915 	stw	zero,164(sp)
811263dc:	d8003215 	stw	zero,200(sp)
811263e0:	84072704 	addi	r16,r16,7324
811263e4:	0039883a 	mov	fp,zero
811263e8:	003a9f06 	br	81124e68 <__reset+0xfb104e68>
811263ec:	01204574 	movhi	r4,33045
811263f0:	21072d84 	addi	r4,r4,7350
811263f4:	d9003515 	stw	r4,212(sp)
811263f8:	003b5f06 	br	81125178 <__reset+0xfb105178>
811263fc:	d9402c17 	ldw	r5,176(sp)
81126400:	d9801e04 	addi	r6,sp,120
81126404:	9809883a 	mov	r4,r19
81126408:	11313ac0 	call	811313ac <__ssprint_r>
8112640c:	1039c61e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
81126410:	d8802617 	ldw	r2,152(sp)
81126414:	d9403317 	ldw	r5,204(sp)
81126418:	d8c02017 	ldw	r3,128(sp)
8112641c:	da000404 	addi	r8,sp,16
81126420:	2885c83a 	sub	r2,r5,r2
81126424:	003e1006 	br	81125c68 <__reset+0xfb105c68>
81126428:	00800044 	movi	r2,1
8112642c:	10803fcc 	andi	r2,r2,255
81126430:	00c00044 	movi	r3,1
81126434:	10fa3526 	beq	r2,r3,81124d0c <__reset+0xfb104d0c>
81126438:	00c00084 	movi	r3,2
8112643c:	10fb9e26 	beq	r2,r3,811252b8 <__reset+0xfb1052b8>
81126440:	003a6406 	br	81124dd4 <__reset+0xfb104dd4>
81126444:	0021883a 	mov	r16,zero
81126448:	003e0806 	br	81125c6c <__reset+0xfb105c6c>
8112644c:	07000b44 	movi	fp,45
81126450:	df002785 	stb	fp,158(sp)
81126454:	003a0b06 	br	81124c84 <__reset+0xfb104c84>
81126458:	d8c02d17 	ldw	r3,180(sp)
8112645c:	d9002f17 	ldw	r4,188(sp)
81126460:	18800017 	ldw	r2,0(r3)
81126464:	18c00104 	addi	r3,r3,4
81126468:	d8c02d15 	stw	r3,180(sp)
8112646c:	11000015 	stw	r4,0(r2)
81126470:	0038f306 	br	81124840 <__reset+0xfb104840>
81126474:	00c00b44 	movi	r3,45
81126478:	d8c02785 	stb	r3,158(sp)
8112647c:	d8802a15 	stw	r2,168(sp)
81126480:	dc802b17 	ldw	r18,172(sp)
81126484:	d8002915 	stw	zero,164(sp)
81126488:	07000b44 	movi	fp,45
8112648c:	003a7306 	br	81124e5c <__reset+0xfb104e5c>
81126490:	9080004c 	andi	r2,r18,1
81126494:	1000941e 	bne	r2,zero,811266e8 <___svfprintf_internal_r+0x1f5c>
81126498:	d8802117 	ldw	r2,132(sp)
8112649c:	1405c83a 	sub	r2,r2,r16
811264a0:	d8803315 	stw	r2,204(sp)
811264a4:	b441161e 	bne	r22,r17,81126900 <___svfprintf_internal_r+0x2174>
811264a8:	dd802617 	ldw	r22,152(sp)
811264ac:	00bfff44 	movi	r2,-3
811264b0:	b0801a16 	blt	r22,r2,8112651c <___svfprintf_internal_r+0x1d90>
811264b4:	d9402917 	ldw	r5,164(sp)
811264b8:	2d801816 	blt	r5,r22,8112651c <___svfprintf_internal_r+0x1d90>
811264bc:	dd803215 	stw	r22,200(sp)
811264c0:	003f3a06 	br	811261ac <__reset+0xfb1061ac>
811264c4:	1025883a 	mov	r18,r2
811264c8:	0039883a 	mov	fp,zero
811264cc:	00800084 	movi	r2,2
811264d0:	003fd606 	br	8112642c <__reset+0xfb10642c>
811264d4:	9080004c 	andi	r2,r18,1
811264d8:	103f191e 	bne	r2,zero,81126140 <__reset+0xfb106140>
811264dc:	d8802117 	ldw	r2,132(sp)
811264e0:	003f2806 	br	81126184 <__reset+0xfb106184>
811264e4:	01204574 	movhi	r4,33045
811264e8:	21072984 	addi	r4,r4,7334
811264ec:	d9002b15 	stw	r4,172(sp)
811264f0:	003c7c06 	br	811256e4 <__reset+0xfb1056e4>
811264f4:	e005883a 	mov	r2,fp
811264f8:	003f2206 	br	81126184 <__reset+0xfb106184>
811264fc:	d9402917 	ldw	r5,164(sp)
81126500:	df002783 	ldbu	fp,158(sp)
81126504:	dd002d15 	stw	r20,180(sp)
81126508:	d9402a15 	stw	r5,168(sp)
8112650c:	d9402e15 	stw	r5,184(sp)
81126510:	d8002915 	stw	zero,164(sp)
81126514:	d8003215 	stw	zero,200(sp)
81126518:	003a4c06 	br	81124e4c <__reset+0xfb104e4c>
8112651c:	8c7fff84 	addi	r17,r17,-2
81126520:	b5bfffc4 	addi	r22,r22,-1
81126524:	dd802615 	stw	r22,152(sp)
81126528:	dc4022c5 	stb	r17,139(sp)
8112652c:	b000c316 	blt	r22,zero,8112683c <___svfprintf_internal_r+0x20b0>
81126530:	00800ac4 	movi	r2,43
81126534:	d8802305 	stb	r2,140(sp)
81126538:	00800244 	movi	r2,9
8112653c:	15806e16 	blt	r2,r22,811266f8 <___svfprintf_internal_r+0x1f6c>
81126540:	00800c04 	movi	r2,48
81126544:	b5800c04 	addi	r22,r22,48
81126548:	d8802345 	stb	r2,141(sp)
8112654c:	dd802385 	stb	r22,142(sp)
81126550:	d88023c4 	addi	r2,sp,143
81126554:	df0022c4 	addi	fp,sp,139
81126558:	d8c03317 	ldw	r3,204(sp)
8112655c:	1739c83a 	sub	fp,r2,fp
81126560:	d9003317 	ldw	r4,204(sp)
81126564:	e0c7883a 	add	r3,fp,r3
81126568:	df003b15 	stw	fp,236(sp)
8112656c:	d8c02e15 	stw	r3,184(sp)
81126570:	00800044 	movi	r2,1
81126574:	1100b70e 	bge	r2,r4,81126854 <___svfprintf_internal_r+0x20c8>
81126578:	d8c02e17 	ldw	r3,184(sp)
8112657c:	18c00044 	addi	r3,r3,1
81126580:	d8c02e15 	stw	r3,184(sp)
81126584:	1805883a 	mov	r2,r3
81126588:	1800b016 	blt	r3,zero,8112684c <___svfprintf_internal_r+0x20c0>
8112658c:	d8003215 	stw	zero,200(sp)
81126590:	003f1006 	br	811261d4 <__reset+0xfb1061d4>
81126594:	d8802917 	ldw	r2,164(sp)
81126598:	103ec71e 	bne	r2,zero,811260b8 <__reset+0xfb1060b8>
8112659c:	dc002915 	stw	r16,164(sp)
811265a0:	003ec506 	br	811260b8 <__reset+0xfb1060b8>
811265a4:	d9402c17 	ldw	r5,176(sp)
811265a8:	d9801e04 	addi	r6,sp,120
811265ac:	9809883a 	mov	r4,r19
811265b0:	11313ac0 	call	811313ac <__ssprint_r>
811265b4:	10395c1e 	bne	r2,zero,81124b28 <__reset+0xfb104b28>
811265b8:	dc402617 	ldw	r17,152(sp)
811265bc:	d8c02017 	ldw	r3,128(sp)
811265c0:	d8801f17 	ldw	r2,124(sp)
811265c4:	da000404 	addi	r8,sp,16
811265c8:	003e7706 	br	81125fa8 <__reset+0xfb105fa8>
811265cc:	582f883a 	mov	r23,r11
811265d0:	d8002915 	stw	zero,164(sp)
811265d4:	0038c406 	br	811248e8 <__reset+0xfb1048e8>
811265d8:	d8c02917 	ldw	r3,164(sp)
811265dc:	d8802104 	addi	r2,sp,132
811265e0:	d8800315 	stw	r2,12(sp)
811265e4:	d9403617 	ldw	r5,216(sp)
811265e8:	d8802504 	addi	r2,sp,148
811265ec:	d8800215 	stw	r2,8(sp)
811265f0:	d8802604 	addi	r2,sp,152
811265f4:	d8c00015 	stw	r3,0(sp)
811265f8:	9809883a 	mov	r4,r19
811265fc:	d8800115 	stw	r2,4(sp)
81126600:	01c000c4 	movi	r7,3
81126604:	a00d883a 	mov	r6,r20
81126608:	da003e15 	stw	r8,248(sp)
8112660c:	112aa780 	call	8112aa78 <_dtoa_r>
81126610:	d9002917 	ldw	r4,164(sp)
81126614:	da003e17 	ldw	r8,248(sp)
81126618:	1021883a 	mov	r16,r2
8112661c:	1139883a 	add	fp,r2,r4
81126620:	2007883a 	mov	r3,r4
81126624:	81000007 	ldb	r4,0(r16)
81126628:	00800c04 	movi	r2,48
8112662c:	20806f26 	beq	r4,r2,811267ec <___svfprintf_internal_r+0x2060>
81126630:	d8c02617 	ldw	r3,152(sp)
81126634:	e0f9883a 	add	fp,fp,r3
81126638:	003ec206 	br	81126144 <__reset+0xfb106144>
8112663c:	00c00b44 	movi	r3,45
81126640:	2520003c 	xorhi	r20,r4,32768
81126644:	d8c02a05 	stb	r3,168(sp)
81126648:	003ea106 	br	811260d0 <__reset+0xfb1060d0>
8112664c:	d8c03217 	ldw	r3,200(sp)
81126650:	00c0890e 	bge	zero,r3,81126878 <___svfprintf_internal_r+0x20ec>
81126654:	00800044 	movi	r2,1
81126658:	d9003317 	ldw	r4,204(sp)
8112665c:	1105883a 	add	r2,r2,r4
81126660:	d8802e15 	stw	r2,184(sp)
81126664:	10005f16 	blt	r2,zero,811267e4 <___svfprintf_internal_r+0x2058>
81126668:	044019c4 	movi	r17,103
8112666c:	003ed906 	br	811261d4 <__reset+0xfb1061d4>
81126670:	d9002917 	ldw	r4,164(sp)
81126674:	20c00044 	addi	r3,r4,1
81126678:	003e9c06 	br	811260ec <__reset+0xfb1060ec>
8112667c:	d9002917 	ldw	r4,164(sp)
81126680:	00c0680e 	bge	zero,r3,81126824 <___svfprintf_internal_r+0x2098>
81126684:	2000461e 	bne	r4,zero,811267a0 <___svfprintf_internal_r+0x2014>
81126688:	9480004c 	andi	r18,r18,1
8112668c:	9000441e 	bne	r18,zero,811267a0 <___svfprintf_internal_r+0x2014>
81126690:	1805883a 	mov	r2,r3
81126694:	1800a016 	blt	r3,zero,81126918 <___svfprintf_internal_r+0x218c>
81126698:	d8c03217 	ldw	r3,200(sp)
8112669c:	d8c02e15 	stw	r3,184(sp)
811266a0:	003ecc06 	br	811261d4 <__reset+0xfb1061d4>
811266a4:	d9402917 	ldw	r5,164(sp)
811266a8:	d8802104 	addi	r2,sp,132
811266ac:	d8800315 	stw	r2,12(sp)
811266b0:	d9400015 	stw	r5,0(sp)
811266b4:	d8802504 	addi	r2,sp,148
811266b8:	d9403617 	ldw	r5,216(sp)
811266bc:	d8800215 	stw	r2,8(sp)
811266c0:	d8802604 	addi	r2,sp,152
811266c4:	d8800115 	stw	r2,4(sp)
811266c8:	01c000c4 	movi	r7,3
811266cc:	a00d883a 	mov	r6,r20
811266d0:	9809883a 	mov	r4,r19
811266d4:	da003e15 	stw	r8,248(sp)
811266d8:	112aa780 	call	8112aa78 <_dtoa_r>
811266dc:	d8c02917 	ldw	r3,164(sp)
811266e0:	da003e17 	ldw	r8,248(sp)
811266e4:	1021883a 	mov	r16,r2
811266e8:	00801184 	movi	r2,70
811266ec:	80f9883a 	add	fp,r16,r3
811266f0:	88bfcc26 	beq	r17,r2,81126624 <__reset+0xfb106624>
811266f4:	003e9306 	br	81126144 <__reset+0xfb106144>
811266f8:	df0022c4 	addi	fp,sp,139
811266fc:	dc002915 	stw	r16,164(sp)
81126700:	9829883a 	mov	r20,r19
81126704:	e021883a 	mov	r16,fp
81126708:	4027883a 	mov	r19,r8
8112670c:	b009883a 	mov	r4,r22
81126710:	01400284 	movi	r5,10
81126714:	1135e580 	call	81135e58 <__modsi3>
81126718:	10800c04 	addi	r2,r2,48
8112671c:	843fffc4 	addi	r16,r16,-1
81126720:	b009883a 	mov	r4,r22
81126724:	01400284 	movi	r5,10
81126728:	80800005 	stb	r2,0(r16)
8112672c:	1135dd40 	call	81135dd4 <__divsi3>
81126730:	102d883a 	mov	r22,r2
81126734:	00800244 	movi	r2,9
81126738:	15bff416 	blt	r2,r22,8112670c <__reset+0xfb10670c>
8112673c:	9811883a 	mov	r8,r19
81126740:	b0800c04 	addi	r2,r22,48
81126744:	a027883a 	mov	r19,r20
81126748:	8029883a 	mov	r20,r16
8112674c:	a17fffc4 	addi	r5,r20,-1
81126750:	a0bfffc5 	stb	r2,-1(r20)
81126754:	dc002917 	ldw	r16,164(sp)
81126758:	2f00752e 	bgeu	r5,fp,81126930 <___svfprintf_internal_r+0x21a4>
8112675c:	d9c02384 	addi	r7,sp,142
81126760:	3d0fc83a 	sub	r7,r7,r20
81126764:	d9002344 	addi	r4,sp,141
81126768:	e1cf883a 	add	r7,fp,r7
8112676c:	00000106 	br	81126774 <___svfprintf_internal_r+0x1fe8>
81126770:	28800003 	ldbu	r2,0(r5)
81126774:	20800005 	stb	r2,0(r4)
81126778:	21000044 	addi	r4,r4,1
8112677c:	29400044 	addi	r5,r5,1
81126780:	21fffb1e 	bne	r4,r7,81126770 <__reset+0xfb106770>
81126784:	d8802304 	addi	r2,sp,140
81126788:	1505c83a 	sub	r2,r2,r20
8112678c:	d8c02344 	addi	r3,sp,141
81126790:	1885883a 	add	r2,r3,r2
81126794:	003f7006 	br	81126558 <__reset+0xfb106558>
81126798:	0005883a 	mov	r2,zero
8112679c:	003f0b06 	br	811263cc <__reset+0xfb1063cc>
811267a0:	d9002917 	ldw	r4,164(sp)
811267a4:	d8c03217 	ldw	r3,200(sp)
811267a8:	20800044 	addi	r2,r4,1
811267ac:	1885883a 	add	r2,r3,r2
811267b0:	d8802e15 	stw	r2,184(sp)
811267b4:	103e870e 	bge	r2,zero,811261d4 <__reset+0xfb1061d4>
811267b8:	0005883a 	mov	r2,zero
811267bc:	003e8506 	br	811261d4 <__reset+0xfb1061d4>
811267c0:	01204574 	movhi	r4,33045
811267c4:	21072984 	addi	r4,r4,7334
811267c8:	d9002b15 	stw	r4,172(sp)
811267cc:	003cc506 	br	81125ae4 <__reset+0xfb105ae4>
811267d0:	d8c03217 	ldw	r3,200(sp)
811267d4:	18c00044 	addi	r3,r3,1
811267d8:	d8c02e15 	stw	r3,184(sp)
811267dc:	1805883a 	mov	r2,r3
811267e0:	183fa10e 	bge	r3,zero,81126668 <__reset+0xfb106668>
811267e4:	0005883a 	mov	r2,zero
811267e8:	003f9f06 	br	81126668 <__reset+0xfb106668>
811267ec:	d9003617 	ldw	r4,216(sp)
811267f0:	000d883a 	mov	r6,zero
811267f4:	000f883a 	mov	r7,zero
811267f8:	a00b883a 	mov	r5,r20
811267fc:	d8c03d15 	stw	r3,244(sp)
81126800:	da003e15 	stw	r8,248(sp)
81126804:	11373280 	call	81137328 <__eqdf2>
81126808:	d8c03d17 	ldw	r3,244(sp)
8112680c:	da003e17 	ldw	r8,248(sp)
81126810:	103f8726 	beq	r2,zero,81126630 <__reset+0xfb106630>
81126814:	00800044 	movi	r2,1
81126818:	10c7c83a 	sub	r3,r2,r3
8112681c:	d8c02615 	stw	r3,152(sp)
81126820:	003f8406 	br	81126634 <__reset+0xfb106634>
81126824:	20000e1e 	bne	r4,zero,81126860 <___svfprintf_internal_r+0x20d4>
81126828:	9480004c 	andi	r18,r18,1
8112682c:	90000c1e 	bne	r18,zero,81126860 <___svfprintf_internal_r+0x20d4>
81126830:	00800044 	movi	r2,1
81126834:	d8802e15 	stw	r2,184(sp)
81126838:	003e6606 	br	811261d4 <__reset+0xfb1061d4>
8112683c:	00800b44 	movi	r2,45
81126840:	05adc83a 	sub	r22,zero,r22
81126844:	d8802305 	stb	r2,140(sp)
81126848:	003f3b06 	br	81126538 <__reset+0xfb106538>
8112684c:	0005883a 	mov	r2,zero
81126850:	003f4e06 	br	8112658c <__reset+0xfb10658c>
81126854:	90a4703a 	and	r18,r18,r2
81126858:	903f4a26 	beq	r18,zero,81126584 <__reset+0xfb106584>
8112685c:	003f4606 	br	81126578 <__reset+0xfb106578>
81126860:	d8c02917 	ldw	r3,164(sp)
81126864:	18c00084 	addi	r3,r3,2
81126868:	d8c02e15 	stw	r3,184(sp)
8112686c:	1805883a 	mov	r2,r3
81126870:	183e580e 	bge	r3,zero,811261d4 <__reset+0xfb1061d4>
81126874:	003fd006 	br	811267b8 <__reset+0xfb1067b8>
81126878:	00800084 	movi	r2,2
8112687c:	10c5c83a 	sub	r2,r2,r3
81126880:	003f7506 	br	81126658 <__reset+0xfb106658>
81126884:	d8802d17 	ldw	r2,180(sp)
81126888:	d9002d17 	ldw	r4,180(sp)
8112688c:	bc400043 	ldbu	r17,1(r23)
81126890:	10800017 	ldw	r2,0(r2)
81126894:	582f883a 	mov	r23,r11
81126898:	d8802915 	stw	r2,164(sp)
8112689c:	20800104 	addi	r2,r4,4
811268a0:	d9002917 	ldw	r4,164(sp)
811268a4:	d8802d15 	stw	r2,180(sp)
811268a8:	203df00e 	bge	r4,zero,8112606c <__reset+0xfb10606c>
811268ac:	8c403fcc 	andi	r17,r17,255
811268b0:	00bfffc4 	movi	r2,-1
811268b4:	8c40201c 	xori	r17,r17,128
811268b8:	d8802915 	stw	r2,164(sp)
811268bc:	8c7fe004 	addi	r17,r17,-128
811268c0:	00380806 	br	811248e4 <__reset+0xfb1048e4>
811268c4:	9080004c 	andi	r2,r18,1
811268c8:	0039883a 	mov	fp,zero
811268cc:	10000726 	beq	r2,zero,811268ec <___svfprintf_internal_r+0x2160>
811268d0:	d8c02817 	ldw	r3,160(sp)
811268d4:	dc001dc4 	addi	r16,sp,119
811268d8:	00800c04 	movi	r2,48
811268dc:	1c07c83a 	sub	r3,r3,r16
811268e0:	d8801dc5 	stb	r2,119(sp)
811268e4:	d8c02e15 	stw	r3,184(sp)
811268e8:	00395206 	br	81124e34 <__reset+0xfb104e34>
811268ec:	d8002e15 	stw	zero,184(sp)
811268f0:	dc001e04 	addi	r16,sp,120
811268f4:	00394f06 	br	81124e34 <__reset+0xfb104e34>
811268f8:	0005883a 	mov	r2,zero
811268fc:	003e3206 	br	811261c8 <__reset+0xfb1061c8>
81126900:	dd802617 	ldw	r22,152(sp)
81126904:	003f0606 	br	81126520 <__reset+0xfb106520>
81126908:	d9c02785 	stb	r7,158(sp)
8112690c:	003a5106 	br	81125254 <__reset+0xfb105254>
81126910:	d9c02785 	stb	r7,158(sp)
81126914:	003a3706 	br	811251f4 <__reset+0xfb1051f4>
81126918:	0005883a 	mov	r2,zero
8112691c:	003f5e06 	br	81126698 <__reset+0xfb106698>
81126920:	d9c02785 	stb	r7,158(sp)
81126924:	00391706 	br	81124d84 <__reset+0xfb104d84>
81126928:	d9c02785 	stb	r7,158(sp)
8112692c:	0038e606 	br	81124cc8 <__reset+0xfb104cc8>
81126930:	d8802344 	addi	r2,sp,141
81126934:	003f0806 	br	81126558 <__reset+0xfb106558>
81126938:	d9c02785 	stb	r7,158(sp)
8112693c:	0038b706 	br	81124c1c <__reset+0xfb104c1c>
81126940:	d9c02785 	stb	r7,158(sp)
81126944:	003adc06 	br	811254b8 <__reset+0xfb1054b8>
81126948:	d9403917 	ldw	r5,228(sp)
8112694c:	00800304 	movi	r2,12
81126950:	28800015 	stw	r2,0(r5)
81126954:	00bfffc4 	movi	r2,-1
81126958:	00387806 	br	81124b3c <__reset+0xfb104b3c>
8112695c:	d9c02785 	stb	r7,158(sp)
81126960:	003abf06 	br	81125460 <__reset+0xfb105460>
81126964:	d9c02785 	stb	r7,158(sp)
81126968:	003a9b06 	br	811253d8 <__reset+0xfb1053d8>

8112696c <___vfprintf_internal_r>:
8112696c:	deffb804 	addi	sp,sp,-288
81126970:	de00012e 	bgeu	sp,et,81126978 <___vfprintf_internal_r+0xc>
81126974:	003b68fa 	trap	3
81126978:	dfc04715 	stw	ra,284(sp)
8112697c:	ddc04515 	stw	r23,276(sp)
81126980:	dd404315 	stw	r21,268(sp)
81126984:	d9002c15 	stw	r4,176(sp)
81126988:	282f883a 	mov	r23,r5
8112698c:	302b883a 	mov	r21,r6
81126990:	d9c02d15 	stw	r7,180(sp)
81126994:	df004615 	stw	fp,280(sp)
81126998:	dd804415 	stw	r22,272(sp)
8112699c:	dd004215 	stw	r20,264(sp)
811269a0:	dcc04115 	stw	r19,260(sp)
811269a4:	dc804015 	stw	r18,256(sp)
811269a8:	dc403f15 	stw	r17,252(sp)
811269ac:	dc003e15 	stw	r16,248(sp)
811269b0:	112d6740 	call	8112d674 <_localeconv_r>
811269b4:	10800017 	ldw	r2,0(r2)
811269b8:	1009883a 	mov	r4,r2
811269bc:	d8803415 	stw	r2,208(sp)
811269c0:	11244540 	call	81124454 <strlen>
811269c4:	d8803715 	stw	r2,220(sp)
811269c8:	d8802c17 	ldw	r2,176(sp)
811269cc:	10000226 	beq	r2,zero,811269d8 <___vfprintf_internal_r+0x6c>
811269d0:	10800e17 	ldw	r2,56(r2)
811269d4:	1000f926 	beq	r2,zero,81126dbc <___vfprintf_internal_r+0x450>
811269d8:	b880030b 	ldhu	r2,12(r23)
811269dc:	10c8000c 	andi	r3,r2,8192
811269e0:	1800061e 	bne	r3,zero,811269fc <___vfprintf_internal_r+0x90>
811269e4:	b9001917 	ldw	r4,100(r23)
811269e8:	00f7ffc4 	movi	r3,-8193
811269ec:	10880014 	ori	r2,r2,8192
811269f0:	20c6703a 	and	r3,r4,r3
811269f4:	b880030d 	sth	r2,12(r23)
811269f8:	b8c01915 	stw	r3,100(r23)
811269fc:	10c0020c 	andi	r3,r2,8
81126a00:	1800c126 	beq	r3,zero,81126d08 <___vfprintf_internal_r+0x39c>
81126a04:	b8c00417 	ldw	r3,16(r23)
81126a08:	1800bf26 	beq	r3,zero,81126d08 <___vfprintf_internal_r+0x39c>
81126a0c:	1080068c 	andi	r2,r2,26
81126a10:	00c00284 	movi	r3,10
81126a14:	10c0c426 	beq	r2,r3,81126d28 <___vfprintf_internal_r+0x3bc>
81126a18:	d8c00404 	addi	r3,sp,16
81126a1c:	05204574 	movhi	r20,33045
81126a20:	d9001e04 	addi	r4,sp,120
81126a24:	a5073184 	addi	r20,r20,7366
81126a28:	d8c01e15 	stw	r3,120(sp)
81126a2c:	d8002015 	stw	zero,128(sp)
81126a30:	d8001f15 	stw	zero,124(sp)
81126a34:	d8003315 	stw	zero,204(sp)
81126a38:	d8003615 	stw	zero,216(sp)
81126a3c:	d8003815 	stw	zero,224(sp)
81126a40:	1811883a 	mov	r8,r3
81126a44:	d8003915 	stw	zero,228(sp)
81126a48:	d8003a15 	stw	zero,232(sp)
81126a4c:	d8002f15 	stw	zero,188(sp)
81126a50:	d9002815 	stw	r4,160(sp)
81126a54:	a8800007 	ldb	r2,0(r21)
81126a58:	10027b26 	beq	r2,zero,81127448 <___vfprintf_internal_r+0xadc>
81126a5c:	00c00944 	movi	r3,37
81126a60:	a821883a 	mov	r16,r21
81126a64:	10c0021e 	bne	r2,r3,81126a70 <___vfprintf_internal_r+0x104>
81126a68:	00001406 	br	81126abc <___vfprintf_internal_r+0x150>
81126a6c:	10c00326 	beq	r2,r3,81126a7c <___vfprintf_internal_r+0x110>
81126a70:	84000044 	addi	r16,r16,1
81126a74:	80800007 	ldb	r2,0(r16)
81126a78:	103ffc1e 	bne	r2,zero,81126a6c <__reset+0xfb106a6c>
81126a7c:	8563c83a 	sub	r17,r16,r21
81126a80:	88000e26 	beq	r17,zero,81126abc <___vfprintf_internal_r+0x150>
81126a84:	d8c02017 	ldw	r3,128(sp)
81126a88:	d8801f17 	ldw	r2,124(sp)
81126a8c:	45400015 	stw	r21,0(r8)
81126a90:	1c47883a 	add	r3,r3,r17
81126a94:	10800044 	addi	r2,r2,1
81126a98:	d8c02015 	stw	r3,128(sp)
81126a9c:	44400115 	stw	r17,4(r8)
81126aa0:	d8801f15 	stw	r2,124(sp)
81126aa4:	00c001c4 	movi	r3,7
81126aa8:	1880a716 	blt	r3,r2,81126d48 <___vfprintf_internal_r+0x3dc>
81126aac:	42000204 	addi	r8,r8,8
81126ab0:	d9402f17 	ldw	r5,188(sp)
81126ab4:	2c4b883a 	add	r5,r5,r17
81126ab8:	d9402f15 	stw	r5,188(sp)
81126abc:	80800007 	ldb	r2,0(r16)
81126ac0:	1000a826 	beq	r2,zero,81126d64 <___vfprintf_internal_r+0x3f8>
81126ac4:	84400047 	ldb	r17,1(r16)
81126ac8:	00bfffc4 	movi	r2,-1
81126acc:	85400044 	addi	r21,r16,1
81126ad0:	d8002785 	stb	zero,158(sp)
81126ad4:	0007883a 	mov	r3,zero
81126ad8:	000f883a 	mov	r7,zero
81126adc:	d8802915 	stw	r2,164(sp)
81126ae0:	d8003115 	stw	zero,196(sp)
81126ae4:	0025883a 	mov	r18,zero
81126ae8:	01401604 	movi	r5,88
81126aec:	01800244 	movi	r6,9
81126af0:	02800a84 	movi	r10,42
81126af4:	02401b04 	movi	r9,108
81126af8:	ad400044 	addi	r21,r21,1
81126afc:	88bff804 	addi	r2,r17,-32
81126b00:	28830436 	bltu	r5,r2,81127714 <___vfprintf_internal_r+0xda8>
81126b04:	100490ba 	slli	r2,r2,2
81126b08:	012044b4 	movhi	r4,33042
81126b0c:	211ac704 	addi	r4,r4,27420
81126b10:	1105883a 	add	r2,r2,r4
81126b14:	10800017 	ldw	r2,0(r2)
81126b18:	1000683a 	jmp	r2
81126b1c:	81127634 	orhi	r4,r16,18904
81126b20:	81127714 	ori	r4,r16,18908
81126b24:	81127714 	ori	r4,r16,18908
81126b28:	81127654 	ori	r4,r16,18905
81126b2c:	81127714 	ori	r4,r16,18908
81126b30:	81127714 	ori	r4,r16,18908
81126b34:	81127714 	ori	r4,r16,18908
81126b38:	81127714 	ori	r4,r16,18908
81126b3c:	81127714 	ori	r4,r16,18908
81126b40:	81127714 	ori	r4,r16,18908
81126b44:	81126dc8 	cmpgei	r4,r16,18871
81126b48:	81127570 	cmpltui	r4,r16,18901
81126b4c:	81127714 	ori	r4,r16,18908
81126b50:	81126c90 	cmplti	r4,r16,18866
81126b54:	81126df0 	cmpltui	r4,r16,18871
81126b58:	81127714 	ori	r4,r16,18908
81126b5c:	81126e30 	cmpltui	r4,r16,18872
81126b60:	81126e3c 	xorhi	r4,r16,18872
81126b64:	81126e3c 	xorhi	r4,r16,18872
81126b68:	81126e3c 	xorhi	r4,r16,18872
81126b6c:	81126e3c 	xorhi	r4,r16,18872
81126b70:	81126e3c 	xorhi	r4,r16,18872
81126b74:	81126e3c 	xorhi	r4,r16,18872
81126b78:	81126e3c 	xorhi	r4,r16,18872
81126b7c:	81126e3c 	xorhi	r4,r16,18872
81126b80:	81126e3c 	xorhi	r4,r16,18872
81126b84:	81127714 	ori	r4,r16,18908
81126b88:	81127714 	ori	r4,r16,18908
81126b8c:	81127714 	ori	r4,r16,18908
81126b90:	81127714 	ori	r4,r16,18908
81126b94:	81127714 	ori	r4,r16,18908
81126b98:	81127714 	ori	r4,r16,18908
81126b9c:	81127714 	ori	r4,r16,18908
81126ba0:	81127714 	ori	r4,r16,18908
81126ba4:	81127714 	ori	r4,r16,18908
81126ba8:	81127714 	ori	r4,r16,18908
81126bac:	81126e70 	cmpltui	r4,r16,18873
81126bb0:	81126f2c 	andhi	r4,r16,18876
81126bb4:	81127714 	ori	r4,r16,18908
81126bb8:	81126f2c 	andhi	r4,r16,18876
81126bbc:	81127714 	ori	r4,r16,18908
81126bc0:	81127714 	ori	r4,r16,18908
81126bc4:	81127714 	ori	r4,r16,18908
81126bc8:	81127714 	ori	r4,r16,18908
81126bcc:	81126fcc 	andi	r4,r16,18879
81126bd0:	81127714 	ori	r4,r16,18908
81126bd4:	81127714 	ori	r4,r16,18908
81126bd8:	81126fd8 	cmpnei	r4,r16,18879
81126bdc:	81127714 	ori	r4,r16,18908
81126be0:	81127714 	ori	r4,r16,18908
81126be4:	81127714 	ori	r4,r16,18908
81126be8:	81127714 	ori	r4,r16,18908
81126bec:	81127714 	ori	r4,r16,18908
81126bf0:	81127450 	cmplti	r4,r16,18897
81126bf4:	81127714 	ori	r4,r16,18908
81126bf8:	81127714 	ori	r4,r16,18908
81126bfc:	811274b0 	cmpltui	r4,r16,18898
81126c00:	81127714 	ori	r4,r16,18908
81126c04:	81127714 	ori	r4,r16,18908
81126c08:	81127714 	ori	r4,r16,18908
81126c0c:	81127714 	ori	r4,r16,18908
81126c10:	81127714 	ori	r4,r16,18908
81126c14:	81127714 	ori	r4,r16,18908
81126c18:	81127714 	ori	r4,r16,18908
81126c1c:	81127714 	ori	r4,r16,18908
81126c20:	81127714 	ori	r4,r16,18908
81126c24:	81127714 	ori	r4,r16,18908
81126c28:	811276c0 	call	8811276c <__reset+0x20f276c>
81126c2c:	81127660 	cmpeqi	r4,r16,18905
81126c30:	81126f2c 	andhi	r4,r16,18876
81126c34:	81126f2c 	andhi	r4,r16,18876
81126c38:	81126f2c 	andhi	r4,r16,18876
81126c3c:	81127670 	cmpltui	r4,r16,18905
81126c40:	81127660 	cmpeqi	r4,r16,18905
81126c44:	81127714 	ori	r4,r16,18908
81126c48:	81127714 	ori	r4,r16,18908
81126c4c:	8112767c 	xorhi	r4,r16,18905
81126c50:	81127714 	ori	r4,r16,18908
81126c54:	8112768c 	andi	r4,r16,18906
81126c58:	81127560 	cmpeqi	r4,r16,18901
81126c5c:	81126c9c 	xori	r4,r16,18866
81126c60:	81127580 	call	88112758 <__reset+0x20f2758>
81126c64:	81127714 	ori	r4,r16,18908
81126c68:	8112758c 	andi	r4,r16,18902
81126c6c:	81127714 	ori	r4,r16,18908
81126c70:	811275e8 	cmpgeui	r4,r16,18903
81126c74:	81127714 	ori	r4,r16,18908
81126c78:	81127714 	ori	r4,r16,18908
81126c7c:	811275f8 	rdprs	r4,r16,18903
81126c80:	d9003117 	ldw	r4,196(sp)
81126c84:	d8802d15 	stw	r2,180(sp)
81126c88:	0109c83a 	sub	r4,zero,r4
81126c8c:	d9003115 	stw	r4,196(sp)
81126c90:	94800114 	ori	r18,r18,4
81126c94:	ac400007 	ldb	r17,0(r21)
81126c98:	003f9706 	br	81126af8 <__reset+0xfb106af8>
81126c9c:	00800c04 	movi	r2,48
81126ca0:	d9002d17 	ldw	r4,180(sp)
81126ca4:	d9402917 	ldw	r5,164(sp)
81126ca8:	d8802705 	stb	r2,156(sp)
81126cac:	00801e04 	movi	r2,120
81126cb0:	d8802745 	stb	r2,157(sp)
81126cb4:	d8002785 	stb	zero,158(sp)
81126cb8:	20c00104 	addi	r3,r4,4
81126cbc:	24c00017 	ldw	r19,0(r4)
81126cc0:	002d883a 	mov	r22,zero
81126cc4:	90800094 	ori	r2,r18,2
81126cc8:	28029a16 	blt	r5,zero,81127734 <___vfprintf_internal_r+0xdc8>
81126ccc:	00bfdfc4 	movi	r2,-129
81126cd0:	90a4703a 	and	r18,r18,r2
81126cd4:	d8c02d15 	stw	r3,180(sp)
81126cd8:	94800094 	ori	r18,r18,2
81126cdc:	9802871e 	bne	r19,zero,811276fc <___vfprintf_internal_r+0xd90>
81126ce0:	00a04574 	movhi	r2,33045
81126ce4:	10872204 	addi	r2,r2,7304
81126ce8:	d8803915 	stw	r2,228(sp)
81126cec:	04401e04 	movi	r17,120
81126cf0:	d8802917 	ldw	r2,164(sp)
81126cf4:	0039883a 	mov	fp,zero
81126cf8:	1001e926 	beq	r2,zero,811274a0 <___vfprintf_internal_r+0xb34>
81126cfc:	0027883a 	mov	r19,zero
81126d00:	002d883a 	mov	r22,zero
81126d04:	00020506 	br	8112751c <___vfprintf_internal_r+0xbb0>
81126d08:	d9002c17 	ldw	r4,176(sp)
81126d0c:	b80b883a 	mov	r5,r23
81126d10:	112a6b80 	call	8112a6b8 <__swsetup_r>
81126d14:	1005ac1e 	bne	r2,zero,811283c8 <___vfprintf_internal_r+0x1a5c>
81126d18:	b880030b 	ldhu	r2,12(r23)
81126d1c:	00c00284 	movi	r3,10
81126d20:	1080068c 	andi	r2,r2,26
81126d24:	10ff3c1e 	bne	r2,r3,81126a18 <__reset+0xfb106a18>
81126d28:	b880038f 	ldh	r2,14(r23)
81126d2c:	103f3a16 	blt	r2,zero,81126a18 <__reset+0xfb106a18>
81126d30:	d9c02d17 	ldw	r7,180(sp)
81126d34:	d9002c17 	ldw	r4,176(sp)
81126d38:	a80d883a 	mov	r6,r21
81126d3c:	b80b883a 	mov	r5,r23
81126d40:	1128b880 	call	81128b88 <__sbprintf>
81126d44:	00001106 	br	81126d8c <___vfprintf_internal_r+0x420>
81126d48:	d9002c17 	ldw	r4,176(sp)
81126d4c:	d9801e04 	addi	r6,sp,120
81126d50:	b80b883a 	mov	r5,r23
81126d54:	1132b5c0 	call	81132b5c <__sprint_r>
81126d58:	1000081e 	bne	r2,zero,81126d7c <___vfprintf_internal_r+0x410>
81126d5c:	da000404 	addi	r8,sp,16
81126d60:	003f5306 	br	81126ab0 <__reset+0xfb106ab0>
81126d64:	d8802017 	ldw	r2,128(sp)
81126d68:	10000426 	beq	r2,zero,81126d7c <___vfprintf_internal_r+0x410>
81126d6c:	d9002c17 	ldw	r4,176(sp)
81126d70:	d9801e04 	addi	r6,sp,120
81126d74:	b80b883a 	mov	r5,r23
81126d78:	1132b5c0 	call	81132b5c <__sprint_r>
81126d7c:	b880030b 	ldhu	r2,12(r23)
81126d80:	1080100c 	andi	r2,r2,64
81126d84:	1005901e 	bne	r2,zero,811283c8 <___vfprintf_internal_r+0x1a5c>
81126d88:	d8802f17 	ldw	r2,188(sp)
81126d8c:	dfc04717 	ldw	ra,284(sp)
81126d90:	df004617 	ldw	fp,280(sp)
81126d94:	ddc04517 	ldw	r23,276(sp)
81126d98:	dd804417 	ldw	r22,272(sp)
81126d9c:	dd404317 	ldw	r21,268(sp)
81126da0:	dd004217 	ldw	r20,264(sp)
81126da4:	dcc04117 	ldw	r19,260(sp)
81126da8:	dc804017 	ldw	r18,256(sp)
81126dac:	dc403f17 	ldw	r17,252(sp)
81126db0:	dc003e17 	ldw	r16,248(sp)
81126db4:	dec04804 	addi	sp,sp,288
81126db8:	f800283a 	ret
81126dbc:	d9002c17 	ldw	r4,176(sp)
81126dc0:	112c7280 	call	8112c728 <__sinit>
81126dc4:	003f0406 	br	811269d8 <__reset+0xfb1069d8>
81126dc8:	d8802d17 	ldw	r2,180(sp)
81126dcc:	d9002d17 	ldw	r4,180(sp)
81126dd0:	10800017 	ldw	r2,0(r2)
81126dd4:	d8803115 	stw	r2,196(sp)
81126dd8:	20800104 	addi	r2,r4,4
81126ddc:	d9003117 	ldw	r4,196(sp)
81126de0:	203fa716 	blt	r4,zero,81126c80 <__reset+0xfb106c80>
81126de4:	d8802d15 	stw	r2,180(sp)
81126de8:	ac400007 	ldb	r17,0(r21)
81126dec:	003f4206 	br	81126af8 <__reset+0xfb106af8>
81126df0:	ac400007 	ldb	r17,0(r21)
81126df4:	aac00044 	addi	r11,r21,1
81126df8:	8a872826 	beq	r17,r10,81128a9c <___vfprintf_internal_r+0x2130>
81126dfc:	88bff404 	addi	r2,r17,-48
81126e00:	0009883a 	mov	r4,zero
81126e04:	30867d36 	bltu	r6,r2,811287fc <___vfprintf_internal_r+0x1e90>
81126e08:	5c400007 	ldb	r17,0(r11)
81126e0c:	210002a4 	muli	r4,r4,10
81126e10:	5d400044 	addi	r21,r11,1
81126e14:	a817883a 	mov	r11,r21
81126e18:	2089883a 	add	r4,r4,r2
81126e1c:	88bff404 	addi	r2,r17,-48
81126e20:	30bff92e 	bgeu	r6,r2,81126e08 <__reset+0xfb106e08>
81126e24:	2005c916 	blt	r4,zero,8112854c <___vfprintf_internal_r+0x1be0>
81126e28:	d9002915 	stw	r4,164(sp)
81126e2c:	003f3306 	br	81126afc <__reset+0xfb106afc>
81126e30:	94802014 	ori	r18,r18,128
81126e34:	ac400007 	ldb	r17,0(r21)
81126e38:	003f2f06 	br	81126af8 <__reset+0xfb106af8>
81126e3c:	a809883a 	mov	r4,r21
81126e40:	d8003115 	stw	zero,196(sp)
81126e44:	88bff404 	addi	r2,r17,-48
81126e48:	0017883a 	mov	r11,zero
81126e4c:	24400007 	ldb	r17,0(r4)
81126e50:	5ac002a4 	muli	r11,r11,10
81126e54:	ad400044 	addi	r21,r21,1
81126e58:	a809883a 	mov	r4,r21
81126e5c:	12d7883a 	add	r11,r2,r11
81126e60:	88bff404 	addi	r2,r17,-48
81126e64:	30bff92e 	bgeu	r6,r2,81126e4c <__reset+0xfb106e4c>
81126e68:	dac03115 	stw	r11,196(sp)
81126e6c:	003f2306 	br	81126afc <__reset+0xfb106afc>
81126e70:	18c03fcc 	andi	r3,r3,255
81126e74:	18072b1e 	bne	r3,zero,81128b24 <___vfprintf_internal_r+0x21b8>
81126e78:	94800414 	ori	r18,r18,16
81126e7c:	9080080c 	andi	r2,r18,32
81126e80:	10037b26 	beq	r2,zero,81127c70 <___vfprintf_internal_r+0x1304>
81126e84:	d9402d17 	ldw	r5,180(sp)
81126e88:	28800117 	ldw	r2,4(r5)
81126e8c:	2cc00017 	ldw	r19,0(r5)
81126e90:	29400204 	addi	r5,r5,8
81126e94:	d9402d15 	stw	r5,180(sp)
81126e98:	102d883a 	mov	r22,r2
81126e9c:	10044b16 	blt	r2,zero,81127fcc <___vfprintf_internal_r+0x1660>
81126ea0:	d9402917 	ldw	r5,164(sp)
81126ea4:	df002783 	ldbu	fp,158(sp)
81126ea8:	2803bc16 	blt	r5,zero,81127d9c <___vfprintf_internal_r+0x1430>
81126eac:	00ffdfc4 	movi	r3,-129
81126eb0:	9d84b03a 	or	r2,r19,r22
81126eb4:	90e4703a 	and	r18,r18,r3
81126eb8:	10017726 	beq	r2,zero,81127498 <___vfprintf_internal_r+0xb2c>
81126ebc:	b0038326 	beq	r22,zero,81127ccc <___vfprintf_internal_r+0x1360>
81126ec0:	dc402a15 	stw	r17,168(sp)
81126ec4:	dc001e04 	addi	r16,sp,120
81126ec8:	b023883a 	mov	r17,r22
81126ecc:	402d883a 	mov	r22,r8
81126ed0:	9809883a 	mov	r4,r19
81126ed4:	880b883a 	mov	r5,r17
81126ed8:	01800284 	movi	r6,10
81126edc:	000f883a 	mov	r7,zero
81126ee0:	11358940 	call	81135894 <__umoddi3>
81126ee4:	10800c04 	addi	r2,r2,48
81126ee8:	843fffc4 	addi	r16,r16,-1
81126eec:	9809883a 	mov	r4,r19
81126ef0:	880b883a 	mov	r5,r17
81126ef4:	80800005 	stb	r2,0(r16)
81126ef8:	01800284 	movi	r6,10
81126efc:	000f883a 	mov	r7,zero
81126f00:	11353140 	call	81135314 <__udivdi3>
81126f04:	1027883a 	mov	r19,r2
81126f08:	10c4b03a 	or	r2,r2,r3
81126f0c:	1823883a 	mov	r17,r3
81126f10:	103fef1e 	bne	r2,zero,81126ed0 <__reset+0xfb106ed0>
81126f14:	d8c02817 	ldw	r3,160(sp)
81126f18:	dc402a17 	ldw	r17,168(sp)
81126f1c:	b011883a 	mov	r8,r22
81126f20:	1c07c83a 	sub	r3,r3,r16
81126f24:	d8c02e15 	stw	r3,184(sp)
81126f28:	00005906 	br	81127090 <___vfprintf_internal_r+0x724>
81126f2c:	18c03fcc 	andi	r3,r3,255
81126f30:	1806fa1e 	bne	r3,zero,81128b1c <___vfprintf_internal_r+0x21b0>
81126f34:	9080020c 	andi	r2,r18,8
81126f38:	10048a26 	beq	r2,zero,81128164 <___vfprintf_internal_r+0x17f8>
81126f3c:	d8c02d17 	ldw	r3,180(sp)
81126f40:	d9002d17 	ldw	r4,180(sp)
81126f44:	d9402d17 	ldw	r5,180(sp)
81126f48:	18c00017 	ldw	r3,0(r3)
81126f4c:	21000117 	ldw	r4,4(r4)
81126f50:	29400204 	addi	r5,r5,8
81126f54:	d8c03615 	stw	r3,216(sp)
81126f58:	d9003815 	stw	r4,224(sp)
81126f5c:	d9402d15 	stw	r5,180(sp)
81126f60:	d9003617 	ldw	r4,216(sp)
81126f64:	d9403817 	ldw	r5,224(sp)
81126f68:	da003d15 	stw	r8,244(sp)
81126f6c:	04000044 	movi	r16,1
81126f70:	112f1c00 	call	8112f1c0 <__fpclassifyd>
81126f74:	da003d17 	ldw	r8,244(sp)
81126f78:	14041f1e 	bne	r2,r16,81127ff8 <___vfprintf_internal_r+0x168c>
81126f7c:	d9003617 	ldw	r4,216(sp)
81126f80:	d9403817 	ldw	r5,224(sp)
81126f84:	000d883a 	mov	r6,zero
81126f88:	000f883a 	mov	r7,zero
81126f8c:	11373b00 	call	811373b0 <__ledf2>
81126f90:	da003d17 	ldw	r8,244(sp)
81126f94:	1005be16 	blt	r2,zero,81128690 <___vfprintf_internal_r+0x1d24>
81126f98:	df002783 	ldbu	fp,158(sp)
81126f9c:	008011c4 	movi	r2,71
81126fa0:	1445330e 	bge	r2,r17,81128470 <___vfprintf_internal_r+0x1b04>
81126fa4:	04204574 	movhi	r16,33045
81126fa8:	84071a04 	addi	r16,r16,7272
81126fac:	00c000c4 	movi	r3,3
81126fb0:	00bfdfc4 	movi	r2,-129
81126fb4:	d8c02a15 	stw	r3,168(sp)
81126fb8:	90a4703a 	and	r18,r18,r2
81126fbc:	d8c02e15 	stw	r3,184(sp)
81126fc0:	d8002915 	stw	zero,164(sp)
81126fc4:	d8003215 	stw	zero,200(sp)
81126fc8:	00003706 	br	811270a8 <___vfprintf_internal_r+0x73c>
81126fcc:	94800214 	ori	r18,r18,8
81126fd0:	ac400007 	ldb	r17,0(r21)
81126fd4:	003ec806 	br	81126af8 <__reset+0xfb106af8>
81126fd8:	18c03fcc 	andi	r3,r3,255
81126fdc:	1806db1e 	bne	r3,zero,81128b4c <___vfprintf_internal_r+0x21e0>
81126fe0:	94800414 	ori	r18,r18,16
81126fe4:	9080080c 	andi	r2,r18,32
81126fe8:	1002d826 	beq	r2,zero,81127b4c <___vfprintf_internal_r+0x11e0>
81126fec:	d9402d17 	ldw	r5,180(sp)
81126ff0:	d8c02917 	ldw	r3,164(sp)
81126ff4:	d8002785 	stb	zero,158(sp)
81126ff8:	28800204 	addi	r2,r5,8
81126ffc:	2cc00017 	ldw	r19,0(r5)
81127000:	2d800117 	ldw	r22,4(r5)
81127004:	18048f16 	blt	r3,zero,81128244 <___vfprintf_internal_r+0x18d8>
81127008:	013fdfc4 	movi	r4,-129
8112700c:	9d86b03a 	or	r3,r19,r22
81127010:	d8802d15 	stw	r2,180(sp)
81127014:	9124703a 	and	r18,r18,r4
81127018:	1802d91e 	bne	r3,zero,81127b80 <___vfprintf_internal_r+0x1214>
8112701c:	d8c02917 	ldw	r3,164(sp)
81127020:	0039883a 	mov	fp,zero
81127024:	1805c326 	beq	r3,zero,81128734 <___vfprintf_internal_r+0x1dc8>
81127028:	0027883a 	mov	r19,zero
8112702c:	002d883a 	mov	r22,zero
81127030:	dc001e04 	addi	r16,sp,120
81127034:	9806d0fa 	srli	r3,r19,3
81127038:	b008977a 	slli	r4,r22,29
8112703c:	b02cd0fa 	srli	r22,r22,3
81127040:	9cc001cc 	andi	r19,r19,7
81127044:	98800c04 	addi	r2,r19,48
81127048:	843fffc4 	addi	r16,r16,-1
8112704c:	20e6b03a 	or	r19,r4,r3
81127050:	80800005 	stb	r2,0(r16)
81127054:	9d86b03a 	or	r3,r19,r22
81127058:	183ff61e 	bne	r3,zero,81127034 <__reset+0xfb107034>
8112705c:	90c0004c 	andi	r3,r18,1
81127060:	18013b26 	beq	r3,zero,81127550 <___vfprintf_internal_r+0xbe4>
81127064:	10803fcc 	andi	r2,r2,255
81127068:	1080201c 	xori	r2,r2,128
8112706c:	10bfe004 	addi	r2,r2,-128
81127070:	00c00c04 	movi	r3,48
81127074:	10c13626 	beq	r2,r3,81127550 <___vfprintf_internal_r+0xbe4>
81127078:	80ffffc5 	stb	r3,-1(r16)
8112707c:	d8c02817 	ldw	r3,160(sp)
81127080:	80bfffc4 	addi	r2,r16,-1
81127084:	1021883a 	mov	r16,r2
81127088:	1887c83a 	sub	r3,r3,r2
8112708c:	d8c02e15 	stw	r3,184(sp)
81127090:	d8802e17 	ldw	r2,184(sp)
81127094:	d9002917 	ldw	r4,164(sp)
81127098:	1100010e 	bge	r2,r4,811270a0 <___vfprintf_internal_r+0x734>
8112709c:	2005883a 	mov	r2,r4
811270a0:	d8802a15 	stw	r2,168(sp)
811270a4:	d8003215 	stw	zero,200(sp)
811270a8:	e7003fcc 	andi	fp,fp,255
811270ac:	e700201c 	xori	fp,fp,128
811270b0:	e73fe004 	addi	fp,fp,-128
811270b4:	e0000326 	beq	fp,zero,811270c4 <___vfprintf_internal_r+0x758>
811270b8:	d8c02a17 	ldw	r3,168(sp)
811270bc:	18c00044 	addi	r3,r3,1
811270c0:	d8c02a15 	stw	r3,168(sp)
811270c4:	90c0008c 	andi	r3,r18,2
811270c8:	d8c02b15 	stw	r3,172(sp)
811270cc:	18000326 	beq	r3,zero,811270dc <___vfprintf_internal_r+0x770>
811270d0:	d8c02a17 	ldw	r3,168(sp)
811270d4:	18c00084 	addi	r3,r3,2
811270d8:	d8c02a15 	stw	r3,168(sp)
811270dc:	90c0210c 	andi	r3,r18,132
811270e0:	d8c03015 	stw	r3,192(sp)
811270e4:	1801a31e 	bne	r3,zero,81127774 <___vfprintf_internal_r+0xe08>
811270e8:	d9003117 	ldw	r4,196(sp)
811270ec:	d8c02a17 	ldw	r3,168(sp)
811270f0:	20e7c83a 	sub	r19,r4,r3
811270f4:	04c19f0e 	bge	zero,r19,81127774 <___vfprintf_internal_r+0xe08>
811270f8:	02400404 	movi	r9,16
811270fc:	d8c02017 	ldw	r3,128(sp)
81127100:	d8801f17 	ldw	r2,124(sp)
81127104:	4cc50d0e 	bge	r9,r19,8112853c <___vfprintf_internal_r+0x1bd0>
81127108:	01604574 	movhi	r5,33045
8112710c:	29473584 	addi	r5,r5,7382
81127110:	dc403b15 	stw	r17,236(sp)
81127114:	d9403515 	stw	r5,212(sp)
81127118:	9823883a 	mov	r17,r19
8112711c:	482d883a 	mov	r22,r9
81127120:	9027883a 	mov	r19,r18
81127124:	070001c4 	movi	fp,7
81127128:	8025883a 	mov	r18,r16
8112712c:	dc002c17 	ldw	r16,176(sp)
81127130:	00000306 	br	81127140 <___vfprintf_internal_r+0x7d4>
81127134:	8c7ffc04 	addi	r17,r17,-16
81127138:	42000204 	addi	r8,r8,8
8112713c:	b440130e 	bge	r22,r17,8112718c <___vfprintf_internal_r+0x820>
81127140:	01204574 	movhi	r4,33045
81127144:	18c00404 	addi	r3,r3,16
81127148:	10800044 	addi	r2,r2,1
8112714c:	21073584 	addi	r4,r4,7382
81127150:	41000015 	stw	r4,0(r8)
81127154:	45800115 	stw	r22,4(r8)
81127158:	d8c02015 	stw	r3,128(sp)
8112715c:	d8801f15 	stw	r2,124(sp)
81127160:	e0bff40e 	bge	fp,r2,81127134 <__reset+0xfb107134>
81127164:	d9801e04 	addi	r6,sp,120
81127168:	b80b883a 	mov	r5,r23
8112716c:	8009883a 	mov	r4,r16
81127170:	1132b5c0 	call	81132b5c <__sprint_r>
81127174:	103f011e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127178:	8c7ffc04 	addi	r17,r17,-16
8112717c:	d8c02017 	ldw	r3,128(sp)
81127180:	d8801f17 	ldw	r2,124(sp)
81127184:	da000404 	addi	r8,sp,16
81127188:	b47fed16 	blt	r22,r17,81127140 <__reset+0xfb107140>
8112718c:	9021883a 	mov	r16,r18
81127190:	9825883a 	mov	r18,r19
81127194:	8827883a 	mov	r19,r17
81127198:	dc403b17 	ldw	r17,236(sp)
8112719c:	d9403517 	ldw	r5,212(sp)
811271a0:	98c7883a 	add	r3,r19,r3
811271a4:	10800044 	addi	r2,r2,1
811271a8:	41400015 	stw	r5,0(r8)
811271ac:	44c00115 	stw	r19,4(r8)
811271b0:	d8c02015 	stw	r3,128(sp)
811271b4:	d8801f15 	stw	r2,124(sp)
811271b8:	010001c4 	movi	r4,7
811271bc:	2082a316 	blt	r4,r2,81127c4c <___vfprintf_internal_r+0x12e0>
811271c0:	df002787 	ldb	fp,158(sp)
811271c4:	42000204 	addi	r8,r8,8
811271c8:	e0000c26 	beq	fp,zero,811271fc <___vfprintf_internal_r+0x890>
811271cc:	d8801f17 	ldw	r2,124(sp)
811271d0:	d9002784 	addi	r4,sp,158
811271d4:	18c00044 	addi	r3,r3,1
811271d8:	10800044 	addi	r2,r2,1
811271dc:	41000015 	stw	r4,0(r8)
811271e0:	01000044 	movi	r4,1
811271e4:	41000115 	stw	r4,4(r8)
811271e8:	d8c02015 	stw	r3,128(sp)
811271ec:	d8801f15 	stw	r2,124(sp)
811271f0:	010001c4 	movi	r4,7
811271f4:	20823c16 	blt	r4,r2,81127ae8 <___vfprintf_internal_r+0x117c>
811271f8:	42000204 	addi	r8,r8,8
811271fc:	d8802b17 	ldw	r2,172(sp)
81127200:	10000c26 	beq	r2,zero,81127234 <___vfprintf_internal_r+0x8c8>
81127204:	d8801f17 	ldw	r2,124(sp)
81127208:	d9002704 	addi	r4,sp,156
8112720c:	18c00084 	addi	r3,r3,2
81127210:	10800044 	addi	r2,r2,1
81127214:	41000015 	stw	r4,0(r8)
81127218:	01000084 	movi	r4,2
8112721c:	41000115 	stw	r4,4(r8)
81127220:	d8c02015 	stw	r3,128(sp)
81127224:	d8801f15 	stw	r2,124(sp)
81127228:	010001c4 	movi	r4,7
8112722c:	20823616 	blt	r4,r2,81127b08 <___vfprintf_internal_r+0x119c>
81127230:	42000204 	addi	r8,r8,8
81127234:	d9003017 	ldw	r4,192(sp)
81127238:	00802004 	movi	r2,128
8112723c:	20819926 	beq	r4,r2,811278a4 <___vfprintf_internal_r+0xf38>
81127240:	d9402917 	ldw	r5,164(sp)
81127244:	d8802e17 	ldw	r2,184(sp)
81127248:	28adc83a 	sub	r22,r5,r2
8112724c:	0580310e 	bge	zero,r22,81127314 <___vfprintf_internal_r+0x9a8>
81127250:	07000404 	movi	fp,16
81127254:	d8801f17 	ldw	r2,124(sp)
81127258:	e584140e 	bge	fp,r22,811282ac <___vfprintf_internal_r+0x1940>
8112725c:	01604574 	movhi	r5,33045
81127260:	29473184 	addi	r5,r5,7366
81127264:	dc402915 	stw	r17,164(sp)
81127268:	d9402b15 	stw	r5,172(sp)
8112726c:	b023883a 	mov	r17,r22
81127270:	04c001c4 	movi	r19,7
81127274:	a82d883a 	mov	r22,r21
81127278:	902b883a 	mov	r21,r18
8112727c:	8025883a 	mov	r18,r16
81127280:	dc002c17 	ldw	r16,176(sp)
81127284:	00000306 	br	81127294 <___vfprintf_internal_r+0x928>
81127288:	8c7ffc04 	addi	r17,r17,-16
8112728c:	42000204 	addi	r8,r8,8
81127290:	e440110e 	bge	fp,r17,811272d8 <___vfprintf_internal_r+0x96c>
81127294:	18c00404 	addi	r3,r3,16
81127298:	10800044 	addi	r2,r2,1
8112729c:	45000015 	stw	r20,0(r8)
811272a0:	47000115 	stw	fp,4(r8)
811272a4:	d8c02015 	stw	r3,128(sp)
811272a8:	d8801f15 	stw	r2,124(sp)
811272ac:	98bff60e 	bge	r19,r2,81127288 <__reset+0xfb107288>
811272b0:	d9801e04 	addi	r6,sp,120
811272b4:	b80b883a 	mov	r5,r23
811272b8:	8009883a 	mov	r4,r16
811272bc:	1132b5c0 	call	81132b5c <__sprint_r>
811272c0:	103eae1e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
811272c4:	8c7ffc04 	addi	r17,r17,-16
811272c8:	d8c02017 	ldw	r3,128(sp)
811272cc:	d8801f17 	ldw	r2,124(sp)
811272d0:	da000404 	addi	r8,sp,16
811272d4:	e47fef16 	blt	fp,r17,81127294 <__reset+0xfb107294>
811272d8:	9021883a 	mov	r16,r18
811272dc:	a825883a 	mov	r18,r21
811272e0:	b02b883a 	mov	r21,r22
811272e4:	882d883a 	mov	r22,r17
811272e8:	dc402917 	ldw	r17,164(sp)
811272ec:	d9002b17 	ldw	r4,172(sp)
811272f0:	1d87883a 	add	r3,r3,r22
811272f4:	10800044 	addi	r2,r2,1
811272f8:	41000015 	stw	r4,0(r8)
811272fc:	45800115 	stw	r22,4(r8)
81127300:	d8c02015 	stw	r3,128(sp)
81127304:	d8801f15 	stw	r2,124(sp)
81127308:	010001c4 	movi	r4,7
8112730c:	2081ee16 	blt	r4,r2,81127ac8 <___vfprintf_internal_r+0x115c>
81127310:	42000204 	addi	r8,r8,8
81127314:	9080400c 	andi	r2,r18,256
81127318:	1001181e 	bne	r2,zero,8112777c <___vfprintf_internal_r+0xe10>
8112731c:	d9402e17 	ldw	r5,184(sp)
81127320:	d8801f17 	ldw	r2,124(sp)
81127324:	44000015 	stw	r16,0(r8)
81127328:	1947883a 	add	r3,r3,r5
8112732c:	10800044 	addi	r2,r2,1
81127330:	41400115 	stw	r5,4(r8)
81127334:	d8c02015 	stw	r3,128(sp)
81127338:	d8801f15 	stw	r2,124(sp)
8112733c:	010001c4 	movi	r4,7
81127340:	2081d316 	blt	r4,r2,81127a90 <___vfprintf_internal_r+0x1124>
81127344:	42000204 	addi	r8,r8,8
81127348:	9480010c 	andi	r18,r18,4
8112734c:	90003226 	beq	r18,zero,81127418 <___vfprintf_internal_r+0xaac>
81127350:	d9403117 	ldw	r5,196(sp)
81127354:	d8802a17 	ldw	r2,168(sp)
81127358:	28a1c83a 	sub	r16,r5,r2
8112735c:	04002e0e 	bge	zero,r16,81127418 <___vfprintf_internal_r+0xaac>
81127360:	04400404 	movi	r17,16
81127364:	d8801f17 	ldw	r2,124(sp)
81127368:	8c04a20e 	bge	r17,r16,811285f4 <___vfprintf_internal_r+0x1c88>
8112736c:	01604574 	movhi	r5,33045
81127370:	29473584 	addi	r5,r5,7382
81127374:	d9403515 	stw	r5,212(sp)
81127378:	048001c4 	movi	r18,7
8112737c:	dcc02c17 	ldw	r19,176(sp)
81127380:	00000306 	br	81127390 <___vfprintf_internal_r+0xa24>
81127384:	843ffc04 	addi	r16,r16,-16
81127388:	42000204 	addi	r8,r8,8
8112738c:	8c00130e 	bge	r17,r16,811273dc <___vfprintf_internal_r+0xa70>
81127390:	01204574 	movhi	r4,33045
81127394:	18c00404 	addi	r3,r3,16
81127398:	10800044 	addi	r2,r2,1
8112739c:	21073584 	addi	r4,r4,7382
811273a0:	41000015 	stw	r4,0(r8)
811273a4:	44400115 	stw	r17,4(r8)
811273a8:	d8c02015 	stw	r3,128(sp)
811273ac:	d8801f15 	stw	r2,124(sp)
811273b0:	90bff40e 	bge	r18,r2,81127384 <__reset+0xfb107384>
811273b4:	d9801e04 	addi	r6,sp,120
811273b8:	b80b883a 	mov	r5,r23
811273bc:	9809883a 	mov	r4,r19
811273c0:	1132b5c0 	call	81132b5c <__sprint_r>
811273c4:	103e6d1e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
811273c8:	843ffc04 	addi	r16,r16,-16
811273cc:	d8c02017 	ldw	r3,128(sp)
811273d0:	d8801f17 	ldw	r2,124(sp)
811273d4:	da000404 	addi	r8,sp,16
811273d8:	8c3fed16 	blt	r17,r16,81127390 <__reset+0xfb107390>
811273dc:	d9403517 	ldw	r5,212(sp)
811273e0:	1c07883a 	add	r3,r3,r16
811273e4:	10800044 	addi	r2,r2,1
811273e8:	41400015 	stw	r5,0(r8)
811273ec:	44000115 	stw	r16,4(r8)
811273f0:	d8c02015 	stw	r3,128(sp)
811273f4:	d8801f15 	stw	r2,124(sp)
811273f8:	010001c4 	movi	r4,7
811273fc:	2080060e 	bge	r4,r2,81127418 <___vfprintf_internal_r+0xaac>
81127400:	d9002c17 	ldw	r4,176(sp)
81127404:	d9801e04 	addi	r6,sp,120
81127408:	b80b883a 	mov	r5,r23
8112740c:	1132b5c0 	call	81132b5c <__sprint_r>
81127410:	103e5a1e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127414:	d8c02017 	ldw	r3,128(sp)
81127418:	d8803117 	ldw	r2,196(sp)
8112741c:	d9002a17 	ldw	r4,168(sp)
81127420:	1100010e 	bge	r2,r4,81127428 <___vfprintf_internal_r+0xabc>
81127424:	2005883a 	mov	r2,r4
81127428:	d9402f17 	ldw	r5,188(sp)
8112742c:	288b883a 	add	r5,r5,r2
81127430:	d9402f15 	stw	r5,188(sp)
81127434:	18019e1e 	bne	r3,zero,81127ab0 <___vfprintf_internal_r+0x1144>
81127438:	a8800007 	ldb	r2,0(r21)
8112743c:	d8001f15 	stw	zero,124(sp)
81127440:	da000404 	addi	r8,sp,16
81127444:	103d851e 	bne	r2,zero,81126a5c <__reset+0xfb106a5c>
81127448:	a821883a 	mov	r16,r21
8112744c:	003d9b06 	br	81126abc <__reset+0xfb106abc>
81127450:	18c03fcc 	andi	r3,r3,255
81127454:	1805c11e 	bne	r3,zero,81128b5c <___vfprintf_internal_r+0x21f0>
81127458:	94800414 	ori	r18,r18,16
8112745c:	9080080c 	andi	r2,r18,32
81127460:	10020c26 	beq	r2,zero,81127c94 <___vfprintf_internal_r+0x1328>
81127464:	d8802d17 	ldw	r2,180(sp)
81127468:	d9002917 	ldw	r4,164(sp)
8112746c:	d8002785 	stb	zero,158(sp)
81127470:	10c00204 	addi	r3,r2,8
81127474:	14c00017 	ldw	r19,0(r2)
81127478:	15800117 	ldw	r22,4(r2)
8112747c:	20040f16 	blt	r4,zero,811284bc <___vfprintf_internal_r+0x1b50>
81127480:	013fdfc4 	movi	r4,-129
81127484:	9d84b03a 	or	r2,r19,r22
81127488:	d8c02d15 	stw	r3,180(sp)
8112748c:	9124703a 	and	r18,r18,r4
81127490:	0039883a 	mov	fp,zero
81127494:	103e891e 	bne	r2,zero,81126ebc <__reset+0xfb106ebc>
81127498:	d9002917 	ldw	r4,164(sp)
8112749c:	2002c11e 	bne	r4,zero,81127fa4 <___vfprintf_internal_r+0x1638>
811274a0:	d8002915 	stw	zero,164(sp)
811274a4:	d8002e15 	stw	zero,184(sp)
811274a8:	dc001e04 	addi	r16,sp,120
811274ac:	003ef806 	br	81127090 <__reset+0xfb107090>
811274b0:	18c03fcc 	andi	r3,r3,255
811274b4:	18059d1e 	bne	r3,zero,81128b2c <___vfprintf_internal_r+0x21c0>
811274b8:	01604574 	movhi	r5,33045
811274bc:	29471d04 	addi	r5,r5,7284
811274c0:	d9403915 	stw	r5,228(sp)
811274c4:	9080080c 	andi	r2,r18,32
811274c8:	10005226 	beq	r2,zero,81127614 <___vfprintf_internal_r+0xca8>
811274cc:	d8802d17 	ldw	r2,180(sp)
811274d0:	14c00017 	ldw	r19,0(r2)
811274d4:	15800117 	ldw	r22,4(r2)
811274d8:	10800204 	addi	r2,r2,8
811274dc:	d8802d15 	stw	r2,180(sp)
811274e0:	9080004c 	andi	r2,r18,1
811274e4:	10019026 	beq	r2,zero,81127b28 <___vfprintf_internal_r+0x11bc>
811274e8:	9d84b03a 	or	r2,r19,r22
811274ec:	10036926 	beq	r2,zero,81128294 <___vfprintf_internal_r+0x1928>
811274f0:	d8c02917 	ldw	r3,164(sp)
811274f4:	00800c04 	movi	r2,48
811274f8:	d8802705 	stb	r2,156(sp)
811274fc:	dc402745 	stb	r17,157(sp)
81127500:	d8002785 	stb	zero,158(sp)
81127504:	90800094 	ori	r2,r18,2
81127508:	18045d16 	blt	r3,zero,81128680 <___vfprintf_internal_r+0x1d14>
8112750c:	00bfdfc4 	movi	r2,-129
81127510:	90a4703a 	and	r18,r18,r2
81127514:	94800094 	ori	r18,r18,2
81127518:	0039883a 	mov	fp,zero
8112751c:	d9003917 	ldw	r4,228(sp)
81127520:	dc001e04 	addi	r16,sp,120
81127524:	988003cc 	andi	r2,r19,15
81127528:	b006973a 	slli	r3,r22,28
8112752c:	2085883a 	add	r2,r4,r2
81127530:	9826d13a 	srli	r19,r19,4
81127534:	10800003 	ldbu	r2,0(r2)
81127538:	b02cd13a 	srli	r22,r22,4
8112753c:	843fffc4 	addi	r16,r16,-1
81127540:	1ce6b03a 	or	r19,r3,r19
81127544:	80800005 	stb	r2,0(r16)
81127548:	9d84b03a 	or	r2,r19,r22
8112754c:	103ff51e 	bne	r2,zero,81127524 <__reset+0xfb107524>
81127550:	d8c02817 	ldw	r3,160(sp)
81127554:	1c07c83a 	sub	r3,r3,r16
81127558:	d8c02e15 	stw	r3,184(sp)
8112755c:	003ecc06 	br	81127090 <__reset+0xfb107090>
81127560:	18c03fcc 	andi	r3,r3,255
81127564:	183e9f26 	beq	r3,zero,81126fe4 <__reset+0xfb106fe4>
81127568:	d9c02785 	stb	r7,158(sp)
8112756c:	003e9d06 	br	81126fe4 <__reset+0xfb106fe4>
81127570:	00c00044 	movi	r3,1
81127574:	01c00ac4 	movi	r7,43
81127578:	ac400007 	ldb	r17,0(r21)
8112757c:	003d5e06 	br	81126af8 <__reset+0xfb106af8>
81127580:	94800814 	ori	r18,r18,32
81127584:	ac400007 	ldb	r17,0(r21)
81127588:	003d5b06 	br	81126af8 <__reset+0xfb106af8>
8112758c:	d8c02d17 	ldw	r3,180(sp)
81127590:	d8002785 	stb	zero,158(sp)
81127594:	1c000017 	ldw	r16,0(r3)
81127598:	1cc00104 	addi	r19,r3,4
8112759c:	80041926 	beq	r16,zero,81128604 <___vfprintf_internal_r+0x1c98>
811275a0:	d9002917 	ldw	r4,164(sp)
811275a4:	2003d016 	blt	r4,zero,811284e8 <___vfprintf_internal_r+0x1b7c>
811275a8:	200d883a 	mov	r6,r4
811275ac:	000b883a 	mov	r5,zero
811275b0:	8009883a 	mov	r4,r16
811275b4:	da003d15 	stw	r8,244(sp)
811275b8:	112d9500 	call	8112d950 <memchr>
811275bc:	da003d17 	ldw	r8,244(sp)
811275c0:	10045426 	beq	r2,zero,81128714 <___vfprintf_internal_r+0x1da8>
811275c4:	1405c83a 	sub	r2,r2,r16
811275c8:	d8802e15 	stw	r2,184(sp)
811275cc:	1003cc16 	blt	r2,zero,81128500 <___vfprintf_internal_r+0x1b94>
811275d0:	df002783 	ldbu	fp,158(sp)
811275d4:	d8802a15 	stw	r2,168(sp)
811275d8:	dcc02d15 	stw	r19,180(sp)
811275dc:	d8002915 	stw	zero,164(sp)
811275e0:	d8003215 	stw	zero,200(sp)
811275e4:	003eb006 	br	811270a8 <__reset+0xfb1070a8>
811275e8:	18c03fcc 	andi	r3,r3,255
811275ec:	183f9b26 	beq	r3,zero,8112745c <__reset+0xfb10745c>
811275f0:	d9c02785 	stb	r7,158(sp)
811275f4:	003f9906 	br	8112745c <__reset+0xfb10745c>
811275f8:	18c03fcc 	andi	r3,r3,255
811275fc:	1805551e 	bne	r3,zero,81128b54 <___vfprintf_internal_r+0x21e8>
81127600:	01604574 	movhi	r5,33045
81127604:	29472204 	addi	r5,r5,7304
81127608:	d9403915 	stw	r5,228(sp)
8112760c:	9080080c 	andi	r2,r18,32
81127610:	103fae1e 	bne	r2,zero,811274cc <__reset+0xfb1074cc>
81127614:	9080040c 	andi	r2,r18,16
81127618:	1002de26 	beq	r2,zero,81128194 <___vfprintf_internal_r+0x1828>
8112761c:	d8c02d17 	ldw	r3,180(sp)
81127620:	002d883a 	mov	r22,zero
81127624:	1cc00017 	ldw	r19,0(r3)
81127628:	18c00104 	addi	r3,r3,4
8112762c:	d8c02d15 	stw	r3,180(sp)
81127630:	003fab06 	br	811274e0 <__reset+0xfb1074e0>
81127634:	38803fcc 	andi	r2,r7,255
81127638:	1080201c 	xori	r2,r2,128
8112763c:	10bfe004 	addi	r2,r2,-128
81127640:	1002d21e 	bne	r2,zero,8112818c <___vfprintf_internal_r+0x1820>
81127644:	00c00044 	movi	r3,1
81127648:	01c00804 	movi	r7,32
8112764c:	ac400007 	ldb	r17,0(r21)
81127650:	003d2906 	br	81126af8 <__reset+0xfb106af8>
81127654:	94800054 	ori	r18,r18,1
81127658:	ac400007 	ldb	r17,0(r21)
8112765c:	003d2606 	br	81126af8 <__reset+0xfb106af8>
81127660:	18c03fcc 	andi	r3,r3,255
81127664:	183e0526 	beq	r3,zero,81126e7c <__reset+0xfb106e7c>
81127668:	d9c02785 	stb	r7,158(sp)
8112766c:	003e0306 	br	81126e7c <__reset+0xfb106e7c>
81127670:	94801014 	ori	r18,r18,64
81127674:	ac400007 	ldb	r17,0(r21)
81127678:	003d1f06 	br	81126af8 <__reset+0xfb106af8>
8112767c:	ac400007 	ldb	r17,0(r21)
81127680:	8a438726 	beq	r17,r9,811284a0 <___vfprintf_internal_r+0x1b34>
81127684:	94800414 	ori	r18,r18,16
81127688:	003d1b06 	br	81126af8 <__reset+0xfb106af8>
8112768c:	18c03fcc 	andi	r3,r3,255
81127690:	1805341e 	bne	r3,zero,81128b64 <___vfprintf_internal_r+0x21f8>
81127694:	9080080c 	andi	r2,r18,32
81127698:	1002cd26 	beq	r2,zero,811281d0 <___vfprintf_internal_r+0x1864>
8112769c:	d9402d17 	ldw	r5,180(sp)
811276a0:	d9002f17 	ldw	r4,188(sp)
811276a4:	28800017 	ldw	r2,0(r5)
811276a8:	2007d7fa 	srai	r3,r4,31
811276ac:	29400104 	addi	r5,r5,4
811276b0:	d9402d15 	stw	r5,180(sp)
811276b4:	11000015 	stw	r4,0(r2)
811276b8:	10c00115 	stw	r3,4(r2)
811276bc:	003ce506 	br	81126a54 <__reset+0xfb106a54>
811276c0:	d8c02d17 	ldw	r3,180(sp)
811276c4:	d9002d17 	ldw	r4,180(sp)
811276c8:	d8002785 	stb	zero,158(sp)
811276cc:	18800017 	ldw	r2,0(r3)
811276d0:	21000104 	addi	r4,r4,4
811276d4:	00c00044 	movi	r3,1
811276d8:	d8c02a15 	stw	r3,168(sp)
811276dc:	d8801405 	stb	r2,80(sp)
811276e0:	d9002d15 	stw	r4,180(sp)
811276e4:	d8c02e15 	stw	r3,184(sp)
811276e8:	d8002915 	stw	zero,164(sp)
811276ec:	d8003215 	stw	zero,200(sp)
811276f0:	dc001404 	addi	r16,sp,80
811276f4:	0039883a 	mov	fp,zero
811276f8:	003e7206 	br	811270c4 <__reset+0xfb1070c4>
811276fc:	01204574 	movhi	r4,33045
81127700:	21072204 	addi	r4,r4,7304
81127704:	0039883a 	mov	fp,zero
81127708:	d9003915 	stw	r4,228(sp)
8112770c:	04401e04 	movi	r17,120
81127710:	003f8206 	br	8112751c <__reset+0xfb10751c>
81127714:	18c03fcc 	andi	r3,r3,255
81127718:	1805061e 	bne	r3,zero,81128b34 <___vfprintf_internal_r+0x21c8>
8112771c:	883d9126 	beq	r17,zero,81126d64 <__reset+0xfb106d64>
81127720:	00c00044 	movi	r3,1
81127724:	d8c02a15 	stw	r3,168(sp)
81127728:	dc401405 	stb	r17,80(sp)
8112772c:	d8002785 	stb	zero,158(sp)
81127730:	003fec06 	br	811276e4 <__reset+0xfb1076e4>
81127734:	01604574 	movhi	r5,33045
81127738:	29472204 	addi	r5,r5,7304
8112773c:	d9403915 	stw	r5,228(sp)
81127740:	d8c02d15 	stw	r3,180(sp)
81127744:	1025883a 	mov	r18,r2
81127748:	04401e04 	movi	r17,120
8112774c:	9d84b03a 	or	r2,r19,r22
81127750:	1000fc1e 	bne	r2,zero,81127b44 <___vfprintf_internal_r+0x11d8>
81127754:	0039883a 	mov	fp,zero
81127758:	00800084 	movi	r2,2
8112775c:	10803fcc 	andi	r2,r2,255
81127760:	00c00044 	movi	r3,1
81127764:	10c20f26 	beq	r2,r3,81127fa4 <___vfprintf_internal_r+0x1638>
81127768:	00c00084 	movi	r3,2
8112776c:	10fd6326 	beq	r2,r3,81126cfc <__reset+0xfb106cfc>
81127770:	003e2d06 	br	81127028 <__reset+0xfb107028>
81127774:	d8c02017 	ldw	r3,128(sp)
81127778:	003e9306 	br	811271c8 <__reset+0xfb1071c8>
8112777c:	00801944 	movi	r2,101
81127780:	14407e0e 	bge	r2,r17,8112797c <___vfprintf_internal_r+0x1010>
81127784:	d9003617 	ldw	r4,216(sp)
81127788:	d9403817 	ldw	r5,224(sp)
8112778c:	000d883a 	mov	r6,zero
81127790:	000f883a 	mov	r7,zero
81127794:	d8c03c15 	stw	r3,240(sp)
81127798:	da003d15 	stw	r8,244(sp)
8112779c:	11373280 	call	81137328 <__eqdf2>
811277a0:	d8c03c17 	ldw	r3,240(sp)
811277a4:	da003d17 	ldw	r8,244(sp)
811277a8:	1000f71e 	bne	r2,zero,81127b88 <___vfprintf_internal_r+0x121c>
811277ac:	d8801f17 	ldw	r2,124(sp)
811277b0:	01204574 	movhi	r4,33045
811277b4:	21072904 	addi	r4,r4,7332
811277b8:	18c00044 	addi	r3,r3,1
811277bc:	10800044 	addi	r2,r2,1
811277c0:	41000015 	stw	r4,0(r8)
811277c4:	01000044 	movi	r4,1
811277c8:	41000115 	stw	r4,4(r8)
811277cc:	d8c02015 	stw	r3,128(sp)
811277d0:	d8801f15 	stw	r2,124(sp)
811277d4:	010001c4 	movi	r4,7
811277d8:	2082b816 	blt	r4,r2,811282bc <___vfprintf_internal_r+0x1950>
811277dc:	42000204 	addi	r8,r8,8
811277e0:	d8802617 	ldw	r2,152(sp)
811277e4:	d9403317 	ldw	r5,204(sp)
811277e8:	11400216 	blt	r2,r5,811277f4 <___vfprintf_internal_r+0xe88>
811277ec:	9080004c 	andi	r2,r18,1
811277f0:	103ed526 	beq	r2,zero,81127348 <__reset+0xfb107348>
811277f4:	d8803717 	ldw	r2,220(sp)
811277f8:	d9003417 	ldw	r4,208(sp)
811277fc:	d9403717 	ldw	r5,220(sp)
81127800:	1887883a 	add	r3,r3,r2
81127804:	d8801f17 	ldw	r2,124(sp)
81127808:	41000015 	stw	r4,0(r8)
8112780c:	41400115 	stw	r5,4(r8)
81127810:	10800044 	addi	r2,r2,1
81127814:	d8c02015 	stw	r3,128(sp)
81127818:	d8801f15 	stw	r2,124(sp)
8112781c:	010001c4 	movi	r4,7
81127820:	20832916 	blt	r4,r2,811284c8 <___vfprintf_internal_r+0x1b5c>
81127824:	42000204 	addi	r8,r8,8
81127828:	d8803317 	ldw	r2,204(sp)
8112782c:	143fffc4 	addi	r16,r2,-1
81127830:	043ec50e 	bge	zero,r16,81127348 <__reset+0xfb107348>
81127834:	04400404 	movi	r17,16
81127838:	d8801f17 	ldw	r2,124(sp)
8112783c:	8c00880e 	bge	r17,r16,81127a60 <___vfprintf_internal_r+0x10f4>
81127840:	01604574 	movhi	r5,33045
81127844:	29473184 	addi	r5,r5,7366
81127848:	d9402b15 	stw	r5,172(sp)
8112784c:	058001c4 	movi	r22,7
81127850:	dcc02c17 	ldw	r19,176(sp)
81127854:	00000306 	br	81127864 <___vfprintf_internal_r+0xef8>
81127858:	42000204 	addi	r8,r8,8
8112785c:	843ffc04 	addi	r16,r16,-16
81127860:	8c00820e 	bge	r17,r16,81127a6c <___vfprintf_internal_r+0x1100>
81127864:	18c00404 	addi	r3,r3,16
81127868:	10800044 	addi	r2,r2,1
8112786c:	45000015 	stw	r20,0(r8)
81127870:	44400115 	stw	r17,4(r8)
81127874:	d8c02015 	stw	r3,128(sp)
81127878:	d8801f15 	stw	r2,124(sp)
8112787c:	b0bff60e 	bge	r22,r2,81127858 <__reset+0xfb107858>
81127880:	d9801e04 	addi	r6,sp,120
81127884:	b80b883a 	mov	r5,r23
81127888:	9809883a 	mov	r4,r19
8112788c:	1132b5c0 	call	81132b5c <__sprint_r>
81127890:	103d3a1e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127894:	d8c02017 	ldw	r3,128(sp)
81127898:	d8801f17 	ldw	r2,124(sp)
8112789c:	da000404 	addi	r8,sp,16
811278a0:	003fee06 	br	8112785c <__reset+0xfb10785c>
811278a4:	d9403117 	ldw	r5,196(sp)
811278a8:	d8802a17 	ldw	r2,168(sp)
811278ac:	28adc83a 	sub	r22,r5,r2
811278b0:	05be630e 	bge	zero,r22,81127240 <__reset+0xfb107240>
811278b4:	07000404 	movi	fp,16
811278b8:	d8801f17 	ldw	r2,124(sp)
811278bc:	e5838f0e 	bge	fp,r22,811286fc <___vfprintf_internal_r+0x1d90>
811278c0:	01604574 	movhi	r5,33045
811278c4:	29473184 	addi	r5,r5,7366
811278c8:	dc403015 	stw	r17,192(sp)
811278cc:	d9402b15 	stw	r5,172(sp)
811278d0:	b023883a 	mov	r17,r22
811278d4:	04c001c4 	movi	r19,7
811278d8:	a82d883a 	mov	r22,r21
811278dc:	902b883a 	mov	r21,r18
811278e0:	8025883a 	mov	r18,r16
811278e4:	dc002c17 	ldw	r16,176(sp)
811278e8:	00000306 	br	811278f8 <___vfprintf_internal_r+0xf8c>
811278ec:	8c7ffc04 	addi	r17,r17,-16
811278f0:	42000204 	addi	r8,r8,8
811278f4:	e440110e 	bge	fp,r17,8112793c <___vfprintf_internal_r+0xfd0>
811278f8:	18c00404 	addi	r3,r3,16
811278fc:	10800044 	addi	r2,r2,1
81127900:	45000015 	stw	r20,0(r8)
81127904:	47000115 	stw	fp,4(r8)
81127908:	d8c02015 	stw	r3,128(sp)
8112790c:	d8801f15 	stw	r2,124(sp)
81127910:	98bff60e 	bge	r19,r2,811278ec <__reset+0xfb1078ec>
81127914:	d9801e04 	addi	r6,sp,120
81127918:	b80b883a 	mov	r5,r23
8112791c:	8009883a 	mov	r4,r16
81127920:	1132b5c0 	call	81132b5c <__sprint_r>
81127924:	103d151e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127928:	8c7ffc04 	addi	r17,r17,-16
8112792c:	d8c02017 	ldw	r3,128(sp)
81127930:	d8801f17 	ldw	r2,124(sp)
81127934:	da000404 	addi	r8,sp,16
81127938:	e47fef16 	blt	fp,r17,811278f8 <__reset+0xfb1078f8>
8112793c:	9021883a 	mov	r16,r18
81127940:	a825883a 	mov	r18,r21
81127944:	b02b883a 	mov	r21,r22
81127948:	882d883a 	mov	r22,r17
8112794c:	dc403017 	ldw	r17,192(sp)
81127950:	d9002b17 	ldw	r4,172(sp)
81127954:	1d87883a 	add	r3,r3,r22
81127958:	10800044 	addi	r2,r2,1
8112795c:	41000015 	stw	r4,0(r8)
81127960:	45800115 	stw	r22,4(r8)
81127964:	d8c02015 	stw	r3,128(sp)
81127968:	d8801f15 	stw	r2,124(sp)
8112796c:	010001c4 	movi	r4,7
81127970:	20818e16 	blt	r4,r2,81127fac <___vfprintf_internal_r+0x1640>
81127974:	42000204 	addi	r8,r8,8
81127978:	003e3106 	br	81127240 <__reset+0xfb107240>
8112797c:	d9403317 	ldw	r5,204(sp)
81127980:	00800044 	movi	r2,1
81127984:	18c00044 	addi	r3,r3,1
81127988:	1141530e 	bge	r2,r5,81127ed8 <___vfprintf_internal_r+0x156c>
8112798c:	dc401f17 	ldw	r17,124(sp)
81127990:	00800044 	movi	r2,1
81127994:	40800115 	stw	r2,4(r8)
81127998:	8c400044 	addi	r17,r17,1
8112799c:	44000015 	stw	r16,0(r8)
811279a0:	d8c02015 	stw	r3,128(sp)
811279a4:	dc401f15 	stw	r17,124(sp)
811279a8:	008001c4 	movi	r2,7
811279ac:	14416b16 	blt	r2,r17,81127f5c <___vfprintf_internal_r+0x15f0>
811279b0:	42000204 	addi	r8,r8,8
811279b4:	d8803717 	ldw	r2,220(sp)
811279b8:	d9003417 	ldw	r4,208(sp)
811279bc:	8c400044 	addi	r17,r17,1
811279c0:	10c7883a 	add	r3,r2,r3
811279c4:	40800115 	stw	r2,4(r8)
811279c8:	41000015 	stw	r4,0(r8)
811279cc:	d8c02015 	stw	r3,128(sp)
811279d0:	dc401f15 	stw	r17,124(sp)
811279d4:	008001c4 	movi	r2,7
811279d8:	14416916 	blt	r2,r17,81127f80 <___vfprintf_internal_r+0x1614>
811279dc:	45800204 	addi	r22,r8,8
811279e0:	d9003617 	ldw	r4,216(sp)
811279e4:	d9403817 	ldw	r5,224(sp)
811279e8:	000d883a 	mov	r6,zero
811279ec:	000f883a 	mov	r7,zero
811279f0:	d8c03c15 	stw	r3,240(sp)
811279f4:	11373280 	call	81137328 <__eqdf2>
811279f8:	d8c03c17 	ldw	r3,240(sp)
811279fc:	1000bc26 	beq	r2,zero,81127cf0 <___vfprintf_internal_r+0x1384>
81127a00:	d9403317 	ldw	r5,204(sp)
81127a04:	84000044 	addi	r16,r16,1
81127a08:	8c400044 	addi	r17,r17,1
81127a0c:	28bfffc4 	addi	r2,r5,-1
81127a10:	1887883a 	add	r3,r3,r2
81127a14:	b0800115 	stw	r2,4(r22)
81127a18:	b4000015 	stw	r16,0(r22)
81127a1c:	d8c02015 	stw	r3,128(sp)
81127a20:	dc401f15 	stw	r17,124(sp)
81127a24:	008001c4 	movi	r2,7
81127a28:	14414316 	blt	r2,r17,81127f38 <___vfprintf_internal_r+0x15cc>
81127a2c:	b5800204 	addi	r22,r22,8
81127a30:	d9003a17 	ldw	r4,232(sp)
81127a34:	df0022c4 	addi	fp,sp,139
81127a38:	8c400044 	addi	r17,r17,1
81127a3c:	20c7883a 	add	r3,r4,r3
81127a40:	b7000015 	stw	fp,0(r22)
81127a44:	b1000115 	stw	r4,4(r22)
81127a48:	d8c02015 	stw	r3,128(sp)
81127a4c:	dc401f15 	stw	r17,124(sp)
81127a50:	008001c4 	movi	r2,7
81127a54:	14400e16 	blt	r2,r17,81127a90 <___vfprintf_internal_r+0x1124>
81127a58:	b2000204 	addi	r8,r22,8
81127a5c:	003e3a06 	br	81127348 <__reset+0xfb107348>
81127a60:	01204574 	movhi	r4,33045
81127a64:	21073184 	addi	r4,r4,7366
81127a68:	d9002b15 	stw	r4,172(sp)
81127a6c:	d9002b17 	ldw	r4,172(sp)
81127a70:	1c07883a 	add	r3,r3,r16
81127a74:	44000115 	stw	r16,4(r8)
81127a78:	41000015 	stw	r4,0(r8)
81127a7c:	10800044 	addi	r2,r2,1
81127a80:	d8c02015 	stw	r3,128(sp)
81127a84:	d8801f15 	stw	r2,124(sp)
81127a88:	010001c4 	movi	r4,7
81127a8c:	20be2d0e 	bge	r4,r2,81127344 <__reset+0xfb107344>
81127a90:	d9002c17 	ldw	r4,176(sp)
81127a94:	d9801e04 	addi	r6,sp,120
81127a98:	b80b883a 	mov	r5,r23
81127a9c:	1132b5c0 	call	81132b5c <__sprint_r>
81127aa0:	103cb61e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127aa4:	d8c02017 	ldw	r3,128(sp)
81127aa8:	da000404 	addi	r8,sp,16
81127aac:	003e2606 	br	81127348 <__reset+0xfb107348>
81127ab0:	d9002c17 	ldw	r4,176(sp)
81127ab4:	d9801e04 	addi	r6,sp,120
81127ab8:	b80b883a 	mov	r5,r23
81127abc:	1132b5c0 	call	81132b5c <__sprint_r>
81127ac0:	103e5d26 	beq	r2,zero,81127438 <__reset+0xfb107438>
81127ac4:	003cad06 	br	81126d7c <__reset+0xfb106d7c>
81127ac8:	d9002c17 	ldw	r4,176(sp)
81127acc:	d9801e04 	addi	r6,sp,120
81127ad0:	b80b883a 	mov	r5,r23
81127ad4:	1132b5c0 	call	81132b5c <__sprint_r>
81127ad8:	103ca81e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127adc:	d8c02017 	ldw	r3,128(sp)
81127ae0:	da000404 	addi	r8,sp,16
81127ae4:	003e0b06 	br	81127314 <__reset+0xfb107314>
81127ae8:	d9002c17 	ldw	r4,176(sp)
81127aec:	d9801e04 	addi	r6,sp,120
81127af0:	b80b883a 	mov	r5,r23
81127af4:	1132b5c0 	call	81132b5c <__sprint_r>
81127af8:	103ca01e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127afc:	d8c02017 	ldw	r3,128(sp)
81127b00:	da000404 	addi	r8,sp,16
81127b04:	003dbd06 	br	811271fc <__reset+0xfb1071fc>
81127b08:	d9002c17 	ldw	r4,176(sp)
81127b0c:	d9801e04 	addi	r6,sp,120
81127b10:	b80b883a 	mov	r5,r23
81127b14:	1132b5c0 	call	81132b5c <__sprint_r>
81127b18:	103c981e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127b1c:	d8c02017 	ldw	r3,128(sp)
81127b20:	da000404 	addi	r8,sp,16
81127b24:	003dc306 	br	81127234 <__reset+0xfb107234>
81127b28:	d8802917 	ldw	r2,164(sp)
81127b2c:	d8002785 	stb	zero,158(sp)
81127b30:	103f0616 	blt	r2,zero,8112774c <__reset+0xfb10774c>
81127b34:	00ffdfc4 	movi	r3,-129
81127b38:	9d84b03a 	or	r2,r19,r22
81127b3c:	90e4703a 	and	r18,r18,r3
81127b40:	103c6b26 	beq	r2,zero,81126cf0 <__reset+0xfb106cf0>
81127b44:	0039883a 	mov	fp,zero
81127b48:	003e7406 	br	8112751c <__reset+0xfb10751c>
81127b4c:	9080040c 	andi	r2,r18,16
81127b50:	1001b326 	beq	r2,zero,81128220 <___vfprintf_internal_r+0x18b4>
81127b54:	d9002d17 	ldw	r4,180(sp)
81127b58:	d9402917 	ldw	r5,164(sp)
81127b5c:	d8002785 	stb	zero,158(sp)
81127b60:	20800104 	addi	r2,r4,4
81127b64:	24c00017 	ldw	r19,0(r4)
81127b68:	002d883a 	mov	r22,zero
81127b6c:	2801b516 	blt	r5,zero,81128244 <___vfprintf_internal_r+0x18d8>
81127b70:	00ffdfc4 	movi	r3,-129
81127b74:	d8802d15 	stw	r2,180(sp)
81127b78:	90e4703a 	and	r18,r18,r3
81127b7c:	983d2726 	beq	r19,zero,8112701c <__reset+0xfb10701c>
81127b80:	0039883a 	mov	fp,zero
81127b84:	003d2a06 	br	81127030 <__reset+0xfb107030>
81127b88:	dc402617 	ldw	r17,152(sp)
81127b8c:	0441d30e 	bge	zero,r17,811282dc <___vfprintf_internal_r+0x1970>
81127b90:	dc403217 	ldw	r17,200(sp)
81127b94:	d8803317 	ldw	r2,204(sp)
81127b98:	1440010e 	bge	r2,r17,81127ba0 <___vfprintf_internal_r+0x1234>
81127b9c:	1023883a 	mov	r17,r2
81127ba0:	04400a0e 	bge	zero,r17,81127bcc <___vfprintf_internal_r+0x1260>
81127ba4:	d8801f17 	ldw	r2,124(sp)
81127ba8:	1c47883a 	add	r3,r3,r17
81127bac:	44000015 	stw	r16,0(r8)
81127bb0:	10800044 	addi	r2,r2,1
81127bb4:	44400115 	stw	r17,4(r8)
81127bb8:	d8c02015 	stw	r3,128(sp)
81127bbc:	d8801f15 	stw	r2,124(sp)
81127bc0:	010001c4 	movi	r4,7
81127bc4:	20826516 	blt	r4,r2,8112855c <___vfprintf_internal_r+0x1bf0>
81127bc8:	42000204 	addi	r8,r8,8
81127bcc:	88026116 	blt	r17,zero,81128554 <___vfprintf_internal_r+0x1be8>
81127bd0:	d9003217 	ldw	r4,200(sp)
81127bd4:	2463c83a 	sub	r17,r4,r17
81127bd8:	04407b0e 	bge	zero,r17,81127dc8 <___vfprintf_internal_r+0x145c>
81127bdc:	05800404 	movi	r22,16
81127be0:	d8801f17 	ldw	r2,124(sp)
81127be4:	b4419d0e 	bge	r22,r17,8112825c <___vfprintf_internal_r+0x18f0>
81127be8:	01204574 	movhi	r4,33045
81127bec:	21073184 	addi	r4,r4,7366
81127bf0:	d9002b15 	stw	r4,172(sp)
81127bf4:	070001c4 	movi	fp,7
81127bf8:	dcc02c17 	ldw	r19,176(sp)
81127bfc:	00000306 	br	81127c0c <___vfprintf_internal_r+0x12a0>
81127c00:	42000204 	addi	r8,r8,8
81127c04:	8c7ffc04 	addi	r17,r17,-16
81127c08:	b441970e 	bge	r22,r17,81128268 <___vfprintf_internal_r+0x18fc>
81127c0c:	18c00404 	addi	r3,r3,16
81127c10:	10800044 	addi	r2,r2,1
81127c14:	45000015 	stw	r20,0(r8)
81127c18:	45800115 	stw	r22,4(r8)
81127c1c:	d8c02015 	stw	r3,128(sp)
81127c20:	d8801f15 	stw	r2,124(sp)
81127c24:	e0bff60e 	bge	fp,r2,81127c00 <__reset+0xfb107c00>
81127c28:	d9801e04 	addi	r6,sp,120
81127c2c:	b80b883a 	mov	r5,r23
81127c30:	9809883a 	mov	r4,r19
81127c34:	1132b5c0 	call	81132b5c <__sprint_r>
81127c38:	103c501e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127c3c:	d8c02017 	ldw	r3,128(sp)
81127c40:	d8801f17 	ldw	r2,124(sp)
81127c44:	da000404 	addi	r8,sp,16
81127c48:	003fee06 	br	81127c04 <__reset+0xfb107c04>
81127c4c:	d9002c17 	ldw	r4,176(sp)
81127c50:	d9801e04 	addi	r6,sp,120
81127c54:	b80b883a 	mov	r5,r23
81127c58:	1132b5c0 	call	81132b5c <__sprint_r>
81127c5c:	103c471e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127c60:	d8c02017 	ldw	r3,128(sp)
81127c64:	df002787 	ldb	fp,158(sp)
81127c68:	da000404 	addi	r8,sp,16
81127c6c:	003d5606 	br	811271c8 <__reset+0xfb1071c8>
81127c70:	9080040c 	andi	r2,r18,16
81127c74:	10016126 	beq	r2,zero,811281fc <___vfprintf_internal_r+0x1890>
81127c78:	d8802d17 	ldw	r2,180(sp)
81127c7c:	14c00017 	ldw	r19,0(r2)
81127c80:	10800104 	addi	r2,r2,4
81127c84:	d8802d15 	stw	r2,180(sp)
81127c88:	982dd7fa 	srai	r22,r19,31
81127c8c:	b005883a 	mov	r2,r22
81127c90:	003c8206 	br	81126e9c <__reset+0xfb106e9c>
81127c94:	9080040c 	andi	r2,r18,16
81127c98:	10003526 	beq	r2,zero,81127d70 <___vfprintf_internal_r+0x1404>
81127c9c:	d9402d17 	ldw	r5,180(sp)
81127ca0:	d8c02917 	ldw	r3,164(sp)
81127ca4:	d8002785 	stb	zero,158(sp)
81127ca8:	28800104 	addi	r2,r5,4
81127cac:	2cc00017 	ldw	r19,0(r5)
81127cb0:	002d883a 	mov	r22,zero
81127cb4:	18003716 	blt	r3,zero,81127d94 <___vfprintf_internal_r+0x1428>
81127cb8:	00ffdfc4 	movi	r3,-129
81127cbc:	d8802d15 	stw	r2,180(sp)
81127cc0:	90e4703a 	and	r18,r18,r3
81127cc4:	0039883a 	mov	fp,zero
81127cc8:	983df326 	beq	r19,zero,81127498 <__reset+0xfb107498>
81127ccc:	00800244 	movi	r2,9
81127cd0:	14fc7b36 	bltu	r2,r19,81126ec0 <__reset+0xfb106ec0>
81127cd4:	d8c02817 	ldw	r3,160(sp)
81127cd8:	dc001dc4 	addi	r16,sp,119
81127cdc:	9cc00c04 	addi	r19,r19,48
81127ce0:	1c07c83a 	sub	r3,r3,r16
81127ce4:	dcc01dc5 	stb	r19,119(sp)
81127ce8:	d8c02e15 	stw	r3,184(sp)
81127cec:	003ce806 	br	81127090 <__reset+0xfb107090>
81127cf0:	d8803317 	ldw	r2,204(sp)
81127cf4:	143fffc4 	addi	r16,r2,-1
81127cf8:	043f4d0e 	bge	zero,r16,81127a30 <__reset+0xfb107a30>
81127cfc:	07000404 	movi	fp,16
81127d00:	e400810e 	bge	fp,r16,81127f08 <___vfprintf_internal_r+0x159c>
81127d04:	01604574 	movhi	r5,33045
81127d08:	29473184 	addi	r5,r5,7366
81127d0c:	d9402b15 	stw	r5,172(sp)
81127d10:	01c001c4 	movi	r7,7
81127d14:	dcc02c17 	ldw	r19,176(sp)
81127d18:	00000306 	br	81127d28 <___vfprintf_internal_r+0x13bc>
81127d1c:	b5800204 	addi	r22,r22,8
81127d20:	843ffc04 	addi	r16,r16,-16
81127d24:	e4007b0e 	bge	fp,r16,81127f14 <___vfprintf_internal_r+0x15a8>
81127d28:	18c00404 	addi	r3,r3,16
81127d2c:	8c400044 	addi	r17,r17,1
81127d30:	b5000015 	stw	r20,0(r22)
81127d34:	b7000115 	stw	fp,4(r22)
81127d38:	d8c02015 	stw	r3,128(sp)
81127d3c:	dc401f15 	stw	r17,124(sp)
81127d40:	3c7ff60e 	bge	r7,r17,81127d1c <__reset+0xfb107d1c>
81127d44:	d9801e04 	addi	r6,sp,120
81127d48:	b80b883a 	mov	r5,r23
81127d4c:	9809883a 	mov	r4,r19
81127d50:	d9c03c15 	stw	r7,240(sp)
81127d54:	1132b5c0 	call	81132b5c <__sprint_r>
81127d58:	d9c03c17 	ldw	r7,240(sp)
81127d5c:	103c071e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127d60:	d8c02017 	ldw	r3,128(sp)
81127d64:	dc401f17 	ldw	r17,124(sp)
81127d68:	dd800404 	addi	r22,sp,16
81127d6c:	003fec06 	br	81127d20 <__reset+0xfb107d20>
81127d70:	9080100c 	andi	r2,r18,64
81127d74:	d8002785 	stb	zero,158(sp)
81127d78:	10010e26 	beq	r2,zero,811281b4 <___vfprintf_internal_r+0x1848>
81127d7c:	d9002d17 	ldw	r4,180(sp)
81127d80:	d9402917 	ldw	r5,164(sp)
81127d84:	002d883a 	mov	r22,zero
81127d88:	20800104 	addi	r2,r4,4
81127d8c:	24c0000b 	ldhu	r19,0(r4)
81127d90:	283fc90e 	bge	r5,zero,81127cb8 <__reset+0xfb107cb8>
81127d94:	d8802d15 	stw	r2,180(sp)
81127d98:	0039883a 	mov	fp,zero
81127d9c:	9d84b03a 	or	r2,r19,r22
81127da0:	103c461e 	bne	r2,zero,81126ebc <__reset+0xfb106ebc>
81127da4:	00800044 	movi	r2,1
81127da8:	003e6c06 	br	8112775c <__reset+0xfb10775c>
81127dac:	d9002c17 	ldw	r4,176(sp)
81127db0:	d9801e04 	addi	r6,sp,120
81127db4:	b80b883a 	mov	r5,r23
81127db8:	1132b5c0 	call	81132b5c <__sprint_r>
81127dbc:	103bef1e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127dc0:	d8c02017 	ldw	r3,128(sp)
81127dc4:	da000404 	addi	r8,sp,16
81127dc8:	d9003217 	ldw	r4,200(sp)
81127dcc:	d8802617 	ldw	r2,152(sp)
81127dd0:	d9403317 	ldw	r5,204(sp)
81127dd4:	8123883a 	add	r17,r16,r4
81127dd8:	11400216 	blt	r2,r5,81127de4 <___vfprintf_internal_r+0x1478>
81127ddc:	9100004c 	andi	r4,r18,1
81127de0:	20000d26 	beq	r4,zero,81127e18 <___vfprintf_internal_r+0x14ac>
81127de4:	d9003717 	ldw	r4,220(sp)
81127de8:	d9403417 	ldw	r5,208(sp)
81127dec:	1907883a 	add	r3,r3,r4
81127df0:	d9001f17 	ldw	r4,124(sp)
81127df4:	41400015 	stw	r5,0(r8)
81127df8:	d9403717 	ldw	r5,220(sp)
81127dfc:	21000044 	addi	r4,r4,1
81127e00:	d8c02015 	stw	r3,128(sp)
81127e04:	41400115 	stw	r5,4(r8)
81127e08:	d9001f15 	stw	r4,124(sp)
81127e0c:	014001c4 	movi	r5,7
81127e10:	2901e816 	blt	r5,r4,811285b4 <___vfprintf_internal_r+0x1c48>
81127e14:	42000204 	addi	r8,r8,8
81127e18:	d9003317 	ldw	r4,204(sp)
81127e1c:	8121883a 	add	r16,r16,r4
81127e20:	2085c83a 	sub	r2,r4,r2
81127e24:	8461c83a 	sub	r16,r16,r17
81127e28:	1400010e 	bge	r2,r16,81127e30 <___vfprintf_internal_r+0x14c4>
81127e2c:	1021883a 	mov	r16,r2
81127e30:	04000a0e 	bge	zero,r16,81127e5c <___vfprintf_internal_r+0x14f0>
81127e34:	d9001f17 	ldw	r4,124(sp)
81127e38:	1c07883a 	add	r3,r3,r16
81127e3c:	44400015 	stw	r17,0(r8)
81127e40:	21000044 	addi	r4,r4,1
81127e44:	44000115 	stw	r16,4(r8)
81127e48:	d8c02015 	stw	r3,128(sp)
81127e4c:	d9001f15 	stw	r4,124(sp)
81127e50:	014001c4 	movi	r5,7
81127e54:	2901fb16 	blt	r5,r4,81128644 <___vfprintf_internal_r+0x1cd8>
81127e58:	42000204 	addi	r8,r8,8
81127e5c:	8001f716 	blt	r16,zero,8112863c <___vfprintf_internal_r+0x1cd0>
81127e60:	1421c83a 	sub	r16,r2,r16
81127e64:	043d380e 	bge	zero,r16,81127348 <__reset+0xfb107348>
81127e68:	04400404 	movi	r17,16
81127e6c:	d8801f17 	ldw	r2,124(sp)
81127e70:	8c3efb0e 	bge	r17,r16,81127a60 <__reset+0xfb107a60>
81127e74:	01604574 	movhi	r5,33045
81127e78:	29473184 	addi	r5,r5,7366
81127e7c:	d9402b15 	stw	r5,172(sp)
81127e80:	058001c4 	movi	r22,7
81127e84:	dcc02c17 	ldw	r19,176(sp)
81127e88:	00000306 	br	81127e98 <___vfprintf_internal_r+0x152c>
81127e8c:	42000204 	addi	r8,r8,8
81127e90:	843ffc04 	addi	r16,r16,-16
81127e94:	8c3ef50e 	bge	r17,r16,81127a6c <__reset+0xfb107a6c>
81127e98:	18c00404 	addi	r3,r3,16
81127e9c:	10800044 	addi	r2,r2,1
81127ea0:	45000015 	stw	r20,0(r8)
81127ea4:	44400115 	stw	r17,4(r8)
81127ea8:	d8c02015 	stw	r3,128(sp)
81127eac:	d8801f15 	stw	r2,124(sp)
81127eb0:	b0bff60e 	bge	r22,r2,81127e8c <__reset+0xfb107e8c>
81127eb4:	d9801e04 	addi	r6,sp,120
81127eb8:	b80b883a 	mov	r5,r23
81127ebc:	9809883a 	mov	r4,r19
81127ec0:	1132b5c0 	call	81132b5c <__sprint_r>
81127ec4:	103bad1e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127ec8:	d8c02017 	ldw	r3,128(sp)
81127ecc:	d8801f17 	ldw	r2,124(sp)
81127ed0:	da000404 	addi	r8,sp,16
81127ed4:	003fee06 	br	81127e90 <__reset+0xfb107e90>
81127ed8:	9088703a 	and	r4,r18,r2
81127edc:	203eab1e 	bne	r4,zero,8112798c <__reset+0xfb10798c>
81127ee0:	dc401f17 	ldw	r17,124(sp)
81127ee4:	40800115 	stw	r2,4(r8)
81127ee8:	44000015 	stw	r16,0(r8)
81127eec:	8c400044 	addi	r17,r17,1
81127ef0:	d8c02015 	stw	r3,128(sp)
81127ef4:	dc401f15 	stw	r17,124(sp)
81127ef8:	008001c4 	movi	r2,7
81127efc:	14400e16 	blt	r2,r17,81127f38 <___vfprintf_internal_r+0x15cc>
81127f00:	45800204 	addi	r22,r8,8
81127f04:	003eca06 	br	81127a30 <__reset+0xfb107a30>
81127f08:	01204574 	movhi	r4,33045
81127f0c:	21073184 	addi	r4,r4,7366
81127f10:	d9002b15 	stw	r4,172(sp)
81127f14:	d8802b17 	ldw	r2,172(sp)
81127f18:	1c07883a 	add	r3,r3,r16
81127f1c:	8c400044 	addi	r17,r17,1
81127f20:	b0800015 	stw	r2,0(r22)
81127f24:	b4000115 	stw	r16,4(r22)
81127f28:	d8c02015 	stw	r3,128(sp)
81127f2c:	dc401f15 	stw	r17,124(sp)
81127f30:	008001c4 	movi	r2,7
81127f34:	147ebd0e 	bge	r2,r17,81127a2c <__reset+0xfb107a2c>
81127f38:	d9002c17 	ldw	r4,176(sp)
81127f3c:	d9801e04 	addi	r6,sp,120
81127f40:	b80b883a 	mov	r5,r23
81127f44:	1132b5c0 	call	81132b5c <__sprint_r>
81127f48:	103b8c1e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127f4c:	d8c02017 	ldw	r3,128(sp)
81127f50:	dc401f17 	ldw	r17,124(sp)
81127f54:	dd800404 	addi	r22,sp,16
81127f58:	003eb506 	br	81127a30 <__reset+0xfb107a30>
81127f5c:	d9002c17 	ldw	r4,176(sp)
81127f60:	d9801e04 	addi	r6,sp,120
81127f64:	b80b883a 	mov	r5,r23
81127f68:	1132b5c0 	call	81132b5c <__sprint_r>
81127f6c:	103b831e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127f70:	d8c02017 	ldw	r3,128(sp)
81127f74:	dc401f17 	ldw	r17,124(sp)
81127f78:	da000404 	addi	r8,sp,16
81127f7c:	003e8d06 	br	811279b4 <__reset+0xfb1079b4>
81127f80:	d9002c17 	ldw	r4,176(sp)
81127f84:	d9801e04 	addi	r6,sp,120
81127f88:	b80b883a 	mov	r5,r23
81127f8c:	1132b5c0 	call	81132b5c <__sprint_r>
81127f90:	103b7a1e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127f94:	d8c02017 	ldw	r3,128(sp)
81127f98:	dc401f17 	ldw	r17,124(sp)
81127f9c:	dd800404 	addi	r22,sp,16
81127fa0:	003e8f06 	br	811279e0 <__reset+0xfb1079e0>
81127fa4:	0027883a 	mov	r19,zero
81127fa8:	003f4a06 	br	81127cd4 <__reset+0xfb107cd4>
81127fac:	d9002c17 	ldw	r4,176(sp)
81127fb0:	d9801e04 	addi	r6,sp,120
81127fb4:	b80b883a 	mov	r5,r23
81127fb8:	1132b5c0 	call	81132b5c <__sprint_r>
81127fbc:	103b6f1e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81127fc0:	d8c02017 	ldw	r3,128(sp)
81127fc4:	da000404 	addi	r8,sp,16
81127fc8:	003c9d06 	br	81127240 <__reset+0xfb107240>
81127fcc:	04e7c83a 	sub	r19,zero,r19
81127fd0:	9804c03a 	cmpne	r2,r19,zero
81127fd4:	05adc83a 	sub	r22,zero,r22
81127fd8:	b0adc83a 	sub	r22,r22,r2
81127fdc:	d8802917 	ldw	r2,164(sp)
81127fe0:	07000b44 	movi	fp,45
81127fe4:	df002785 	stb	fp,158(sp)
81127fe8:	10017b16 	blt	r2,zero,811285d8 <___vfprintf_internal_r+0x1c6c>
81127fec:	00bfdfc4 	movi	r2,-129
81127ff0:	90a4703a 	and	r18,r18,r2
81127ff4:	003bb106 	br	81126ebc <__reset+0xfb106ebc>
81127ff8:	d9003617 	ldw	r4,216(sp)
81127ffc:	d9403817 	ldw	r5,224(sp)
81128000:	da003d15 	stw	r8,244(sp)
81128004:	112f1c00 	call	8112f1c0 <__fpclassifyd>
81128008:	da003d17 	ldw	r8,244(sp)
8112800c:	1000f026 	beq	r2,zero,811283d0 <___vfprintf_internal_r+0x1a64>
81128010:	d9002917 	ldw	r4,164(sp)
81128014:	05bff7c4 	movi	r22,-33
81128018:	00bfffc4 	movi	r2,-1
8112801c:	8dac703a 	and	r22,r17,r22
81128020:	20820026 	beq	r4,r2,81128824 <___vfprintf_internal_r+0x1eb8>
81128024:	008011c4 	movi	r2,71
81128028:	b081f726 	beq	r22,r2,81128808 <___vfprintf_internal_r+0x1e9c>
8112802c:	d9003817 	ldw	r4,224(sp)
81128030:	90c04014 	ori	r3,r18,256
81128034:	d8c02b15 	stw	r3,172(sp)
81128038:	20021516 	blt	r4,zero,81128890 <___vfprintf_internal_r+0x1f24>
8112803c:	dcc03817 	ldw	r19,224(sp)
81128040:	d8002a05 	stb	zero,168(sp)
81128044:	00801984 	movi	r2,102
81128048:	8881f926 	beq	r17,r2,81128830 <___vfprintf_internal_r+0x1ec4>
8112804c:	00801184 	movi	r2,70
81128050:	88821c26 	beq	r17,r2,811288c4 <___vfprintf_internal_r+0x1f58>
81128054:	00801144 	movi	r2,69
81128058:	b081ef26 	beq	r22,r2,81128818 <___vfprintf_internal_r+0x1eac>
8112805c:	d8c02917 	ldw	r3,164(sp)
81128060:	d8802104 	addi	r2,sp,132
81128064:	d8800315 	stw	r2,12(sp)
81128068:	d9403617 	ldw	r5,216(sp)
8112806c:	d8802504 	addi	r2,sp,148
81128070:	d9002c17 	ldw	r4,176(sp)
81128074:	d8800215 	stw	r2,8(sp)
81128078:	d8802604 	addi	r2,sp,152
8112807c:	d8c00015 	stw	r3,0(sp)
81128080:	d8800115 	stw	r2,4(sp)
81128084:	01c00084 	movi	r7,2
81128088:	980d883a 	mov	r6,r19
8112808c:	d8c03c15 	stw	r3,240(sp)
81128090:	da003d15 	stw	r8,244(sp)
81128094:	112aa780 	call	8112aa78 <_dtoa_r>
81128098:	1021883a 	mov	r16,r2
8112809c:	008019c4 	movi	r2,103
811280a0:	d8c03c17 	ldw	r3,240(sp)
811280a4:	da003d17 	ldw	r8,244(sp)
811280a8:	88817126 	beq	r17,r2,81128670 <___vfprintf_internal_r+0x1d04>
811280ac:	008011c4 	movi	r2,71
811280b0:	88829226 	beq	r17,r2,81128afc <___vfprintf_internal_r+0x2190>
811280b4:	80f9883a 	add	fp,r16,r3
811280b8:	d9003617 	ldw	r4,216(sp)
811280bc:	000d883a 	mov	r6,zero
811280c0:	000f883a 	mov	r7,zero
811280c4:	980b883a 	mov	r5,r19
811280c8:	da003d15 	stw	r8,244(sp)
811280cc:	11373280 	call	81137328 <__eqdf2>
811280d0:	da003d17 	ldw	r8,244(sp)
811280d4:	10018d26 	beq	r2,zero,8112870c <___vfprintf_internal_r+0x1da0>
811280d8:	d8802117 	ldw	r2,132(sp)
811280dc:	1700062e 	bgeu	r2,fp,811280f8 <___vfprintf_internal_r+0x178c>
811280e0:	01000c04 	movi	r4,48
811280e4:	10c00044 	addi	r3,r2,1
811280e8:	d8c02115 	stw	r3,132(sp)
811280ec:	11000005 	stb	r4,0(r2)
811280f0:	d8802117 	ldw	r2,132(sp)
811280f4:	173ffb36 	bltu	r2,fp,811280e4 <__reset+0xfb1080e4>
811280f8:	1405c83a 	sub	r2,r2,r16
811280fc:	d8803315 	stw	r2,204(sp)
81128100:	008011c4 	movi	r2,71
81128104:	b0817626 	beq	r22,r2,811286e0 <___vfprintf_internal_r+0x1d74>
81128108:	00801944 	movi	r2,101
8112810c:	1442810e 	bge	r2,r17,81128b14 <___vfprintf_internal_r+0x21a8>
81128110:	d8c02617 	ldw	r3,152(sp)
81128114:	00801984 	movi	r2,102
81128118:	d8c03215 	stw	r3,200(sp)
8112811c:	8881fe26 	beq	r17,r2,81128918 <___vfprintf_internal_r+0x1fac>
81128120:	d8c03217 	ldw	r3,200(sp)
81128124:	d9003317 	ldw	r4,204(sp)
81128128:	1901dd16 	blt	r3,r4,811288a0 <___vfprintf_internal_r+0x1f34>
8112812c:	9480004c 	andi	r18,r18,1
81128130:	90022b1e 	bne	r18,zero,811289e0 <___vfprintf_internal_r+0x2074>
81128134:	1805883a 	mov	r2,r3
81128138:	18028016 	blt	r3,zero,81128b3c <___vfprintf_internal_r+0x21d0>
8112813c:	d8c03217 	ldw	r3,200(sp)
81128140:	044019c4 	movi	r17,103
81128144:	d8c02e15 	stw	r3,184(sp)
81128148:	df002a07 	ldb	fp,168(sp)
8112814c:	e001531e 	bne	fp,zero,8112869c <___vfprintf_internal_r+0x1d30>
81128150:	df002783 	ldbu	fp,158(sp)
81128154:	d8802a15 	stw	r2,168(sp)
81128158:	dc802b17 	ldw	r18,172(sp)
8112815c:	d8002915 	stw	zero,164(sp)
81128160:	003bd106 	br	811270a8 <__reset+0xfb1070a8>
81128164:	d8802d17 	ldw	r2,180(sp)
81128168:	d8c02d17 	ldw	r3,180(sp)
8112816c:	d9002d17 	ldw	r4,180(sp)
81128170:	10800017 	ldw	r2,0(r2)
81128174:	18c00117 	ldw	r3,4(r3)
81128178:	21000204 	addi	r4,r4,8
8112817c:	d8803615 	stw	r2,216(sp)
81128180:	d8c03815 	stw	r3,224(sp)
81128184:	d9002d15 	stw	r4,180(sp)
81128188:	003b7506 	br	81126f60 <__reset+0xfb106f60>
8112818c:	ac400007 	ldb	r17,0(r21)
81128190:	003a5906 	br	81126af8 <__reset+0xfb106af8>
81128194:	9080100c 	andi	r2,r18,64
81128198:	1000a826 	beq	r2,zero,8112843c <___vfprintf_internal_r+0x1ad0>
8112819c:	d9002d17 	ldw	r4,180(sp)
811281a0:	002d883a 	mov	r22,zero
811281a4:	24c0000b 	ldhu	r19,0(r4)
811281a8:	21000104 	addi	r4,r4,4
811281ac:	d9002d15 	stw	r4,180(sp)
811281b0:	003ccb06 	br	811274e0 <__reset+0xfb1074e0>
811281b4:	d8c02d17 	ldw	r3,180(sp)
811281b8:	d9002917 	ldw	r4,164(sp)
811281bc:	002d883a 	mov	r22,zero
811281c0:	18800104 	addi	r2,r3,4
811281c4:	1cc00017 	ldw	r19,0(r3)
811281c8:	203ebb0e 	bge	r4,zero,81127cb8 <__reset+0xfb107cb8>
811281cc:	003ef106 	br	81127d94 <__reset+0xfb107d94>
811281d0:	9080040c 	andi	r2,r18,16
811281d4:	1000921e 	bne	r2,zero,81128420 <___vfprintf_internal_r+0x1ab4>
811281d8:	9480100c 	andi	r18,r18,64
811281dc:	90013926 	beq	r18,zero,811286c4 <___vfprintf_internal_r+0x1d58>
811281e0:	d9002d17 	ldw	r4,180(sp)
811281e4:	d9402f17 	ldw	r5,188(sp)
811281e8:	20800017 	ldw	r2,0(r4)
811281ec:	21000104 	addi	r4,r4,4
811281f0:	d9002d15 	stw	r4,180(sp)
811281f4:	1140000d 	sth	r5,0(r2)
811281f8:	003a1606 	br	81126a54 <__reset+0xfb106a54>
811281fc:	9080100c 	andi	r2,r18,64
81128200:	10008026 	beq	r2,zero,81128404 <___vfprintf_internal_r+0x1a98>
81128204:	d8c02d17 	ldw	r3,180(sp)
81128208:	1cc0000f 	ldh	r19,0(r3)
8112820c:	18c00104 	addi	r3,r3,4
81128210:	d8c02d15 	stw	r3,180(sp)
81128214:	982dd7fa 	srai	r22,r19,31
81128218:	b005883a 	mov	r2,r22
8112821c:	003b1f06 	br	81126e9c <__reset+0xfb106e9c>
81128220:	9080100c 	andi	r2,r18,64
81128224:	d8002785 	stb	zero,158(sp)
81128228:	10008a1e 	bne	r2,zero,81128454 <___vfprintf_internal_r+0x1ae8>
8112822c:	d9402d17 	ldw	r5,180(sp)
81128230:	d8c02917 	ldw	r3,164(sp)
81128234:	002d883a 	mov	r22,zero
81128238:	28800104 	addi	r2,r5,4
8112823c:	2cc00017 	ldw	r19,0(r5)
81128240:	183e4b0e 	bge	r3,zero,81127b70 <__reset+0xfb107b70>
81128244:	9d86b03a 	or	r3,r19,r22
81128248:	d8802d15 	stw	r2,180(sp)
8112824c:	183e4c1e 	bne	r3,zero,81127b80 <__reset+0xfb107b80>
81128250:	0039883a 	mov	fp,zero
81128254:	0005883a 	mov	r2,zero
81128258:	003d4006 	br	8112775c <__reset+0xfb10775c>
8112825c:	01604574 	movhi	r5,33045
81128260:	29473184 	addi	r5,r5,7366
81128264:	d9402b15 	stw	r5,172(sp)
81128268:	d9402b17 	ldw	r5,172(sp)
8112826c:	1c47883a 	add	r3,r3,r17
81128270:	10800044 	addi	r2,r2,1
81128274:	41400015 	stw	r5,0(r8)
81128278:	44400115 	stw	r17,4(r8)
8112827c:	d8c02015 	stw	r3,128(sp)
81128280:	d8801f15 	stw	r2,124(sp)
81128284:	010001c4 	movi	r4,7
81128288:	20bec816 	blt	r4,r2,81127dac <__reset+0xfb107dac>
8112828c:	42000204 	addi	r8,r8,8
81128290:	003ecd06 	br	81127dc8 <__reset+0xfb107dc8>
81128294:	d9002917 	ldw	r4,164(sp)
81128298:	d8002785 	stb	zero,158(sp)
8112829c:	203d2d16 	blt	r4,zero,81127754 <__reset+0xfb107754>
811282a0:	00bfdfc4 	movi	r2,-129
811282a4:	90a4703a 	and	r18,r18,r2
811282a8:	003a9106 	br	81126cf0 <__reset+0xfb106cf0>
811282ac:	01204574 	movhi	r4,33045
811282b0:	21073184 	addi	r4,r4,7366
811282b4:	d9002b15 	stw	r4,172(sp)
811282b8:	003c0c06 	br	811272ec <__reset+0xfb1072ec>
811282bc:	d9002c17 	ldw	r4,176(sp)
811282c0:	d9801e04 	addi	r6,sp,120
811282c4:	b80b883a 	mov	r5,r23
811282c8:	1132b5c0 	call	81132b5c <__sprint_r>
811282cc:	103aab1e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
811282d0:	d8c02017 	ldw	r3,128(sp)
811282d4:	da000404 	addi	r8,sp,16
811282d8:	003d4106 	br	811277e0 <__reset+0xfb1077e0>
811282dc:	d8801f17 	ldw	r2,124(sp)
811282e0:	01604574 	movhi	r5,33045
811282e4:	01000044 	movi	r4,1
811282e8:	18c00044 	addi	r3,r3,1
811282ec:	10800044 	addi	r2,r2,1
811282f0:	29472904 	addi	r5,r5,7332
811282f4:	41000115 	stw	r4,4(r8)
811282f8:	41400015 	stw	r5,0(r8)
811282fc:	d8c02015 	stw	r3,128(sp)
81128300:	d8801f15 	stw	r2,124(sp)
81128304:	010001c4 	movi	r4,7
81128308:	20805c16 	blt	r4,r2,8112847c <___vfprintf_internal_r+0x1b10>
8112830c:	42000204 	addi	r8,r8,8
81128310:	8800041e 	bne	r17,zero,81128324 <___vfprintf_internal_r+0x19b8>
81128314:	d8803317 	ldw	r2,204(sp)
81128318:	1000021e 	bne	r2,zero,81128324 <___vfprintf_internal_r+0x19b8>
8112831c:	9080004c 	andi	r2,r18,1
81128320:	103c0926 	beq	r2,zero,81127348 <__reset+0xfb107348>
81128324:	d9003717 	ldw	r4,220(sp)
81128328:	d8801f17 	ldw	r2,124(sp)
8112832c:	d9403417 	ldw	r5,208(sp)
81128330:	20c7883a 	add	r3,r4,r3
81128334:	10800044 	addi	r2,r2,1
81128338:	41000115 	stw	r4,4(r8)
8112833c:	41400015 	stw	r5,0(r8)
81128340:	d8c02015 	stw	r3,128(sp)
81128344:	d8801f15 	stw	r2,124(sp)
81128348:	010001c4 	movi	r4,7
8112834c:	20812116 	blt	r4,r2,811287d4 <___vfprintf_internal_r+0x1e68>
81128350:	42000204 	addi	r8,r8,8
81128354:	0463c83a 	sub	r17,zero,r17
81128358:	0440730e 	bge	zero,r17,81128528 <___vfprintf_internal_r+0x1bbc>
8112835c:	05800404 	movi	r22,16
81128360:	b440860e 	bge	r22,r17,8112857c <___vfprintf_internal_r+0x1c10>
81128364:	01604574 	movhi	r5,33045
81128368:	29473184 	addi	r5,r5,7366
8112836c:	d9402b15 	stw	r5,172(sp)
81128370:	070001c4 	movi	fp,7
81128374:	dcc02c17 	ldw	r19,176(sp)
81128378:	00000306 	br	81128388 <___vfprintf_internal_r+0x1a1c>
8112837c:	42000204 	addi	r8,r8,8
81128380:	8c7ffc04 	addi	r17,r17,-16
81128384:	b440800e 	bge	r22,r17,81128588 <___vfprintf_internal_r+0x1c1c>
81128388:	18c00404 	addi	r3,r3,16
8112838c:	10800044 	addi	r2,r2,1
81128390:	45000015 	stw	r20,0(r8)
81128394:	45800115 	stw	r22,4(r8)
81128398:	d8c02015 	stw	r3,128(sp)
8112839c:	d8801f15 	stw	r2,124(sp)
811283a0:	e0bff60e 	bge	fp,r2,8112837c <__reset+0xfb10837c>
811283a4:	d9801e04 	addi	r6,sp,120
811283a8:	b80b883a 	mov	r5,r23
811283ac:	9809883a 	mov	r4,r19
811283b0:	1132b5c0 	call	81132b5c <__sprint_r>
811283b4:	103a711e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
811283b8:	d8c02017 	ldw	r3,128(sp)
811283bc:	d8801f17 	ldw	r2,124(sp)
811283c0:	da000404 	addi	r8,sp,16
811283c4:	003fee06 	br	81128380 <__reset+0xfb108380>
811283c8:	00bfffc4 	movi	r2,-1
811283cc:	003a6f06 	br	81126d8c <__reset+0xfb106d8c>
811283d0:	008011c4 	movi	r2,71
811283d4:	1440b816 	blt	r2,r17,811286b8 <___vfprintf_internal_r+0x1d4c>
811283d8:	04204574 	movhi	r16,33045
811283dc:	84071b04 	addi	r16,r16,7276
811283e0:	00c000c4 	movi	r3,3
811283e4:	00bfdfc4 	movi	r2,-129
811283e8:	d8c02a15 	stw	r3,168(sp)
811283ec:	90a4703a 	and	r18,r18,r2
811283f0:	df002783 	ldbu	fp,158(sp)
811283f4:	d8c02e15 	stw	r3,184(sp)
811283f8:	d8002915 	stw	zero,164(sp)
811283fc:	d8003215 	stw	zero,200(sp)
81128400:	003b2906 	br	811270a8 <__reset+0xfb1070a8>
81128404:	d9002d17 	ldw	r4,180(sp)
81128408:	24c00017 	ldw	r19,0(r4)
8112840c:	21000104 	addi	r4,r4,4
81128410:	d9002d15 	stw	r4,180(sp)
81128414:	982dd7fa 	srai	r22,r19,31
81128418:	b005883a 	mov	r2,r22
8112841c:	003a9f06 	br	81126e9c <__reset+0xfb106e9c>
81128420:	d9402d17 	ldw	r5,180(sp)
81128424:	d8c02f17 	ldw	r3,188(sp)
81128428:	28800017 	ldw	r2,0(r5)
8112842c:	29400104 	addi	r5,r5,4
81128430:	d9402d15 	stw	r5,180(sp)
81128434:	10c00015 	stw	r3,0(r2)
81128438:	00398606 	br	81126a54 <__reset+0xfb106a54>
8112843c:	d9402d17 	ldw	r5,180(sp)
81128440:	002d883a 	mov	r22,zero
81128444:	2cc00017 	ldw	r19,0(r5)
81128448:	29400104 	addi	r5,r5,4
8112844c:	d9402d15 	stw	r5,180(sp)
81128450:	003c2306 	br	811274e0 <__reset+0xfb1074e0>
81128454:	d8c02d17 	ldw	r3,180(sp)
81128458:	d9002917 	ldw	r4,164(sp)
8112845c:	002d883a 	mov	r22,zero
81128460:	18800104 	addi	r2,r3,4
81128464:	1cc0000b 	ldhu	r19,0(r3)
81128468:	203dc10e 	bge	r4,zero,81127b70 <__reset+0xfb107b70>
8112846c:	003f7506 	br	81128244 <__reset+0xfb108244>
81128470:	04204574 	movhi	r16,33045
81128474:	84071904 	addi	r16,r16,7268
81128478:	003acc06 	br	81126fac <__reset+0xfb106fac>
8112847c:	d9002c17 	ldw	r4,176(sp)
81128480:	d9801e04 	addi	r6,sp,120
81128484:	b80b883a 	mov	r5,r23
81128488:	1132b5c0 	call	81132b5c <__sprint_r>
8112848c:	103a3b1e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81128490:	dc402617 	ldw	r17,152(sp)
81128494:	d8c02017 	ldw	r3,128(sp)
81128498:	da000404 	addi	r8,sp,16
8112849c:	003f9c06 	br	81128310 <__reset+0xfb108310>
811284a0:	ac400043 	ldbu	r17,1(r21)
811284a4:	94800814 	ori	r18,r18,32
811284a8:	ad400044 	addi	r21,r21,1
811284ac:	8c403fcc 	andi	r17,r17,255
811284b0:	8c40201c 	xori	r17,r17,128
811284b4:	8c7fe004 	addi	r17,r17,-128
811284b8:	00398f06 	br	81126af8 <__reset+0xfb106af8>
811284bc:	d8c02d15 	stw	r3,180(sp)
811284c0:	0039883a 	mov	fp,zero
811284c4:	003e3506 	br	81127d9c <__reset+0xfb107d9c>
811284c8:	d9002c17 	ldw	r4,176(sp)
811284cc:	d9801e04 	addi	r6,sp,120
811284d0:	b80b883a 	mov	r5,r23
811284d4:	1132b5c0 	call	81132b5c <__sprint_r>
811284d8:	103a281e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
811284dc:	d8c02017 	ldw	r3,128(sp)
811284e0:	da000404 	addi	r8,sp,16
811284e4:	003cd006 	br	81127828 <__reset+0xfb107828>
811284e8:	8009883a 	mov	r4,r16
811284ec:	da003d15 	stw	r8,244(sp)
811284f0:	11244540 	call	81124454 <strlen>
811284f4:	d8802e15 	stw	r2,184(sp)
811284f8:	da003d17 	ldw	r8,244(sp)
811284fc:	103c340e 	bge	r2,zero,811275d0 <__reset+0xfb1075d0>
81128500:	0005883a 	mov	r2,zero
81128504:	003c3206 	br	811275d0 <__reset+0xfb1075d0>
81128508:	d9002c17 	ldw	r4,176(sp)
8112850c:	d9801e04 	addi	r6,sp,120
81128510:	b80b883a 	mov	r5,r23
81128514:	1132b5c0 	call	81132b5c <__sprint_r>
81128518:	103a181e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
8112851c:	d8c02017 	ldw	r3,128(sp)
81128520:	d8801f17 	ldw	r2,124(sp)
81128524:	da000404 	addi	r8,sp,16
81128528:	d9403317 	ldw	r5,204(sp)
8112852c:	10800044 	addi	r2,r2,1
81128530:	44000015 	stw	r16,0(r8)
81128534:	28c7883a 	add	r3,r5,r3
81128538:	003b7d06 	br	81127330 <__reset+0xfb107330>
8112853c:	01204574 	movhi	r4,33045
81128540:	21073584 	addi	r4,r4,7382
81128544:	d9003515 	stw	r4,212(sp)
81128548:	003b1406 	br	8112719c <__reset+0xfb10719c>
8112854c:	013fffc4 	movi	r4,-1
81128550:	003a3506 	br	81126e28 <__reset+0xfb106e28>
81128554:	0023883a 	mov	r17,zero
81128558:	003d9d06 	br	81127bd0 <__reset+0xfb107bd0>
8112855c:	d9002c17 	ldw	r4,176(sp)
81128560:	d9801e04 	addi	r6,sp,120
81128564:	b80b883a 	mov	r5,r23
81128568:	1132b5c0 	call	81132b5c <__sprint_r>
8112856c:	103a031e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81128570:	d8c02017 	ldw	r3,128(sp)
81128574:	da000404 	addi	r8,sp,16
81128578:	003d9406 	br	81127bcc <__reset+0xfb107bcc>
8112857c:	01204574 	movhi	r4,33045
81128580:	21073184 	addi	r4,r4,7366
81128584:	d9002b15 	stw	r4,172(sp)
81128588:	d9002b17 	ldw	r4,172(sp)
8112858c:	1c47883a 	add	r3,r3,r17
81128590:	10800044 	addi	r2,r2,1
81128594:	41000015 	stw	r4,0(r8)
81128598:	44400115 	stw	r17,4(r8)
8112859c:	d8c02015 	stw	r3,128(sp)
811285a0:	d8801f15 	stw	r2,124(sp)
811285a4:	010001c4 	movi	r4,7
811285a8:	20bfd716 	blt	r4,r2,81128508 <__reset+0xfb108508>
811285ac:	42000204 	addi	r8,r8,8
811285b0:	003fdd06 	br	81128528 <__reset+0xfb108528>
811285b4:	d9002c17 	ldw	r4,176(sp)
811285b8:	d9801e04 	addi	r6,sp,120
811285bc:	b80b883a 	mov	r5,r23
811285c0:	1132b5c0 	call	81132b5c <__sprint_r>
811285c4:	1039ed1e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
811285c8:	d8802617 	ldw	r2,152(sp)
811285cc:	d8c02017 	ldw	r3,128(sp)
811285d0:	da000404 	addi	r8,sp,16
811285d4:	003e1006 	br	81127e18 <__reset+0xfb107e18>
811285d8:	00800044 	movi	r2,1
811285dc:	10803fcc 	andi	r2,r2,255
811285e0:	00c00044 	movi	r3,1
811285e4:	10fa3526 	beq	r2,r3,81126ebc <__reset+0xfb106ebc>
811285e8:	00c00084 	movi	r3,2
811285ec:	10fbcb26 	beq	r2,r3,8112751c <__reset+0xfb10751c>
811285f0:	003a8f06 	br	81127030 <__reset+0xfb107030>
811285f4:	01204574 	movhi	r4,33045
811285f8:	21073584 	addi	r4,r4,7382
811285fc:	d9003515 	stw	r4,212(sp)
81128600:	003b7606 	br	811273dc <__reset+0xfb1073dc>
81128604:	d8802917 	ldw	r2,164(sp)
81128608:	00c00184 	movi	r3,6
8112860c:	1880012e 	bgeu	r3,r2,81128614 <___vfprintf_internal_r+0x1ca8>
81128610:	1805883a 	mov	r2,r3
81128614:	d8802e15 	stw	r2,184(sp)
81128618:	1000ef16 	blt	r2,zero,811289d8 <___vfprintf_internal_r+0x206c>
8112861c:	04204574 	movhi	r16,33045
81128620:	d8802a15 	stw	r2,168(sp)
81128624:	dcc02d15 	stw	r19,180(sp)
81128628:	d8002915 	stw	zero,164(sp)
8112862c:	d8003215 	stw	zero,200(sp)
81128630:	84072704 	addi	r16,r16,7324
81128634:	0039883a 	mov	fp,zero
81128638:	003aa206 	br	811270c4 <__reset+0xfb1070c4>
8112863c:	0021883a 	mov	r16,zero
81128640:	003e0706 	br	81127e60 <__reset+0xfb107e60>
81128644:	d9002c17 	ldw	r4,176(sp)
81128648:	d9801e04 	addi	r6,sp,120
8112864c:	b80b883a 	mov	r5,r23
81128650:	1132b5c0 	call	81132b5c <__sprint_r>
81128654:	1039c91e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
81128658:	d8802617 	ldw	r2,152(sp)
8112865c:	d9403317 	ldw	r5,204(sp)
81128660:	d8c02017 	ldw	r3,128(sp)
81128664:	da000404 	addi	r8,sp,16
81128668:	2885c83a 	sub	r2,r5,r2
8112866c:	003dfb06 	br	81127e5c <__reset+0xfb107e5c>
81128670:	9080004c 	andi	r2,r18,1
81128674:	103e8f1e 	bne	r2,zero,811280b4 <__reset+0xfb1080b4>
81128678:	d8802117 	ldw	r2,132(sp)
8112867c:	003e9e06 	br	811280f8 <__reset+0xfb1080f8>
81128680:	1025883a 	mov	r18,r2
81128684:	0039883a 	mov	fp,zero
81128688:	00800084 	movi	r2,2
8112868c:	003fd306 	br	811285dc <__reset+0xfb1085dc>
81128690:	07000b44 	movi	fp,45
81128694:	df002785 	stb	fp,158(sp)
81128698:	003a4006 	br	81126f9c <__reset+0xfb106f9c>
8112869c:	00c00b44 	movi	r3,45
811286a0:	d8c02785 	stb	r3,158(sp)
811286a4:	d8802a15 	stw	r2,168(sp)
811286a8:	dc802b17 	ldw	r18,172(sp)
811286ac:	d8002915 	stw	zero,164(sp)
811286b0:	07000b44 	movi	fp,45
811286b4:	003a8006 	br	811270b8 <__reset+0xfb1070b8>
811286b8:	04204574 	movhi	r16,33045
811286bc:	84071c04 	addi	r16,r16,7280
811286c0:	003f4706 	br	811283e0 <__reset+0xfb1083e0>
811286c4:	d8c02d17 	ldw	r3,180(sp)
811286c8:	d9002f17 	ldw	r4,188(sp)
811286cc:	18800017 	ldw	r2,0(r3)
811286d0:	18c00104 	addi	r3,r3,4
811286d4:	d8c02d15 	stw	r3,180(sp)
811286d8:	11000015 	stw	r4,0(r2)
811286dc:	0038dd06 	br	81126a54 <__reset+0xfb106a54>
811286e0:	dd802617 	ldw	r22,152(sp)
811286e4:	00bfff44 	movi	r2,-3
811286e8:	b0801c16 	blt	r22,r2,8112875c <___vfprintf_internal_r+0x1df0>
811286ec:	d9402917 	ldw	r5,164(sp)
811286f0:	2d801a16 	blt	r5,r22,8112875c <___vfprintf_internal_r+0x1df0>
811286f4:	dd803215 	stw	r22,200(sp)
811286f8:	003e8906 	br	81128120 <__reset+0xfb108120>
811286fc:	01204574 	movhi	r4,33045
81128700:	21073184 	addi	r4,r4,7366
81128704:	d9002b15 	stw	r4,172(sp)
81128708:	003c9106 	br	81127950 <__reset+0xfb107950>
8112870c:	e005883a 	mov	r2,fp
81128710:	003e7906 	br	811280f8 <__reset+0xfb1080f8>
81128714:	d9402917 	ldw	r5,164(sp)
81128718:	df002783 	ldbu	fp,158(sp)
8112871c:	dcc02d15 	stw	r19,180(sp)
81128720:	d9402a15 	stw	r5,168(sp)
81128724:	d9402e15 	stw	r5,184(sp)
81128728:	d8002915 	stw	zero,164(sp)
8112872c:	d8003215 	stw	zero,200(sp)
81128730:	003a5d06 	br	811270a8 <__reset+0xfb1070a8>
81128734:	9080004c 	andi	r2,r18,1
81128738:	0039883a 	mov	fp,zero
8112873c:	10000426 	beq	r2,zero,81128750 <___vfprintf_internal_r+0x1de4>
81128740:	00800c04 	movi	r2,48
81128744:	dc001dc4 	addi	r16,sp,119
81128748:	d8801dc5 	stb	r2,119(sp)
8112874c:	003b8006 	br	81127550 <__reset+0xfb107550>
81128750:	d8002e15 	stw	zero,184(sp)
81128754:	dc001e04 	addi	r16,sp,120
81128758:	003a4d06 	br	81127090 <__reset+0xfb107090>
8112875c:	8c7fff84 	addi	r17,r17,-2
81128760:	b5bfffc4 	addi	r22,r22,-1
81128764:	dd802615 	stw	r22,152(sp)
81128768:	dc4022c5 	stb	r17,139(sp)
8112876c:	b000bf16 	blt	r22,zero,81128a6c <___vfprintf_internal_r+0x2100>
81128770:	00800ac4 	movi	r2,43
81128774:	d8802305 	stb	r2,140(sp)
81128778:	00800244 	movi	r2,9
8112877c:	15807016 	blt	r2,r22,81128940 <___vfprintf_internal_r+0x1fd4>
81128780:	00800c04 	movi	r2,48
81128784:	b5800c04 	addi	r22,r22,48
81128788:	d8802345 	stb	r2,141(sp)
8112878c:	dd802385 	stb	r22,142(sp)
81128790:	d88023c4 	addi	r2,sp,143
81128794:	df0022c4 	addi	fp,sp,139
81128798:	d8c03317 	ldw	r3,204(sp)
8112879c:	1739c83a 	sub	fp,r2,fp
811287a0:	d9003317 	ldw	r4,204(sp)
811287a4:	e0c7883a 	add	r3,fp,r3
811287a8:	df003a15 	stw	fp,232(sp)
811287ac:	d8c02e15 	stw	r3,184(sp)
811287b0:	00800044 	movi	r2,1
811287b4:	1100b30e 	bge	r2,r4,81128a84 <___vfprintf_internal_r+0x2118>
811287b8:	d8c02e17 	ldw	r3,184(sp)
811287bc:	18c00044 	addi	r3,r3,1
811287c0:	d8c02e15 	stw	r3,184(sp)
811287c4:	1805883a 	mov	r2,r3
811287c8:	1800ac16 	blt	r3,zero,81128a7c <___vfprintf_internal_r+0x2110>
811287cc:	d8003215 	stw	zero,200(sp)
811287d0:	003e5d06 	br	81128148 <__reset+0xfb108148>
811287d4:	d9002c17 	ldw	r4,176(sp)
811287d8:	d9801e04 	addi	r6,sp,120
811287dc:	b80b883a 	mov	r5,r23
811287e0:	1132b5c0 	call	81132b5c <__sprint_r>
811287e4:	1039651e 	bne	r2,zero,81126d7c <__reset+0xfb106d7c>
811287e8:	dc402617 	ldw	r17,152(sp)
811287ec:	d8c02017 	ldw	r3,128(sp)
811287f0:	d8801f17 	ldw	r2,124(sp)
811287f4:	da000404 	addi	r8,sp,16
811287f8:	003ed606 	br	81128354 <__reset+0xfb108354>
811287fc:	582b883a 	mov	r21,r11
81128800:	d8002915 	stw	zero,164(sp)
81128804:	0038bd06 	br	81126afc <__reset+0xfb106afc>
81128808:	d8802917 	ldw	r2,164(sp)
8112880c:	103e071e 	bne	r2,zero,8112802c <__reset+0xfb10802c>
81128810:	dc002915 	stw	r16,164(sp)
81128814:	003e0506 	br	8112802c <__reset+0xfb10802c>
81128818:	d9002917 	ldw	r4,164(sp)
8112881c:	20c00044 	addi	r3,r4,1
81128820:	003e0f06 	br	81128060 <__reset+0xfb108060>
81128824:	01400184 	movi	r5,6
81128828:	d9402915 	stw	r5,164(sp)
8112882c:	003dff06 	br	8112802c <__reset+0xfb10802c>
81128830:	d8802104 	addi	r2,sp,132
81128834:	d8800315 	stw	r2,12(sp)
81128838:	d8802504 	addi	r2,sp,148
8112883c:	d8800215 	stw	r2,8(sp)
81128840:	d8802604 	addi	r2,sp,152
81128844:	d8800115 	stw	r2,4(sp)
81128848:	d8802917 	ldw	r2,164(sp)
8112884c:	d9403617 	ldw	r5,216(sp)
81128850:	d9002c17 	ldw	r4,176(sp)
81128854:	d8800015 	stw	r2,0(sp)
81128858:	01c000c4 	movi	r7,3
8112885c:	980d883a 	mov	r6,r19
81128860:	da003d15 	stw	r8,244(sp)
81128864:	112aa780 	call	8112aa78 <_dtoa_r>
81128868:	d8c02917 	ldw	r3,164(sp)
8112886c:	da003d17 	ldw	r8,244(sp)
81128870:	1021883a 	mov	r16,r2
81128874:	10f9883a 	add	fp,r2,r3
81128878:	81000007 	ldb	r4,0(r16)
8112887c:	00800c04 	movi	r2,48
81128880:	20805e26 	beq	r4,r2,811289fc <___vfprintf_internal_r+0x2090>
81128884:	d8c02617 	ldw	r3,152(sp)
81128888:	e0f9883a 	add	fp,fp,r3
8112888c:	003e0a06 	br	811280b8 <__reset+0xfb1080b8>
81128890:	00c00b44 	movi	r3,45
81128894:	24e0003c 	xorhi	r19,r4,32768
81128898:	d8c02a05 	stb	r3,168(sp)
8112889c:	003de906 	br	81128044 <__reset+0xfb108044>
811288a0:	d8c03217 	ldw	r3,200(sp)
811288a4:	00c07a0e 	bge	zero,r3,81128a90 <___vfprintf_internal_r+0x2124>
811288a8:	00800044 	movi	r2,1
811288ac:	d9003317 	ldw	r4,204(sp)
811288b0:	1105883a 	add	r2,r2,r4
811288b4:	d8802e15 	stw	r2,184(sp)
811288b8:	10004e16 	blt	r2,zero,811289f4 <___vfprintf_internal_r+0x2088>
811288bc:	044019c4 	movi	r17,103
811288c0:	003e2106 	br	81128148 <__reset+0xfb108148>
811288c4:	d9002917 	ldw	r4,164(sp)
811288c8:	d8802104 	addi	r2,sp,132
811288cc:	d8800315 	stw	r2,12(sp)
811288d0:	d9000015 	stw	r4,0(sp)
811288d4:	d8802504 	addi	r2,sp,148
811288d8:	d9403617 	ldw	r5,216(sp)
811288dc:	d9002c17 	ldw	r4,176(sp)
811288e0:	d8800215 	stw	r2,8(sp)
811288e4:	d8802604 	addi	r2,sp,152
811288e8:	d8800115 	stw	r2,4(sp)
811288ec:	01c000c4 	movi	r7,3
811288f0:	980d883a 	mov	r6,r19
811288f4:	da003d15 	stw	r8,244(sp)
811288f8:	112aa780 	call	8112aa78 <_dtoa_r>
811288fc:	d8c02917 	ldw	r3,164(sp)
81128900:	da003d17 	ldw	r8,244(sp)
81128904:	1021883a 	mov	r16,r2
81128908:	00801184 	movi	r2,70
8112890c:	80f9883a 	add	fp,r16,r3
81128910:	88bfd926 	beq	r17,r2,81128878 <__reset+0xfb108878>
81128914:	003de806 	br	811280b8 <__reset+0xfb1080b8>
81128918:	d9002917 	ldw	r4,164(sp)
8112891c:	00c04d0e 	bge	zero,r3,81128a54 <___vfprintf_internal_r+0x20e8>
81128920:	2000441e 	bne	r4,zero,81128a34 <___vfprintf_internal_r+0x20c8>
81128924:	9480004c 	andi	r18,r18,1
81128928:	9000421e 	bne	r18,zero,81128a34 <___vfprintf_internal_r+0x20c8>
8112892c:	1805883a 	mov	r2,r3
81128930:	18007016 	blt	r3,zero,81128af4 <___vfprintf_internal_r+0x2188>
81128934:	d8c03217 	ldw	r3,200(sp)
81128938:	d8c02e15 	stw	r3,184(sp)
8112893c:	003e0206 	br	81128148 <__reset+0xfb108148>
81128940:	df0022c4 	addi	fp,sp,139
81128944:	dc002915 	stw	r16,164(sp)
81128948:	4027883a 	mov	r19,r8
8112894c:	e021883a 	mov	r16,fp
81128950:	b009883a 	mov	r4,r22
81128954:	01400284 	movi	r5,10
81128958:	1135e580 	call	81135e58 <__modsi3>
8112895c:	10800c04 	addi	r2,r2,48
81128960:	843fffc4 	addi	r16,r16,-1
81128964:	b009883a 	mov	r4,r22
81128968:	01400284 	movi	r5,10
8112896c:	80800005 	stb	r2,0(r16)
81128970:	1135dd40 	call	81135dd4 <__divsi3>
81128974:	102d883a 	mov	r22,r2
81128978:	00800244 	movi	r2,9
8112897c:	15bff416 	blt	r2,r22,81128950 <__reset+0xfb108950>
81128980:	9811883a 	mov	r8,r19
81128984:	b0800c04 	addi	r2,r22,48
81128988:	8027883a 	mov	r19,r16
8112898c:	997fffc4 	addi	r5,r19,-1
81128990:	98bfffc5 	stb	r2,-1(r19)
81128994:	dc002917 	ldw	r16,164(sp)
81128998:	2f006a2e 	bgeu	r5,fp,81128b44 <___vfprintf_internal_r+0x21d8>
8112899c:	d9c02384 	addi	r7,sp,142
811289a0:	3ccfc83a 	sub	r7,r7,r19
811289a4:	d9002344 	addi	r4,sp,141
811289a8:	e1cf883a 	add	r7,fp,r7
811289ac:	00000106 	br	811289b4 <___vfprintf_internal_r+0x2048>
811289b0:	28800003 	ldbu	r2,0(r5)
811289b4:	20800005 	stb	r2,0(r4)
811289b8:	21000044 	addi	r4,r4,1
811289bc:	29400044 	addi	r5,r5,1
811289c0:	393ffb1e 	bne	r7,r4,811289b0 <__reset+0xfb1089b0>
811289c4:	d8802304 	addi	r2,sp,140
811289c8:	14c5c83a 	sub	r2,r2,r19
811289cc:	d8c02344 	addi	r3,sp,141
811289d0:	1885883a 	add	r2,r3,r2
811289d4:	003f7006 	br	81128798 <__reset+0xfb108798>
811289d8:	0005883a 	mov	r2,zero
811289dc:	003f0f06 	br	8112861c <__reset+0xfb10861c>
811289e0:	d8c03217 	ldw	r3,200(sp)
811289e4:	18c00044 	addi	r3,r3,1
811289e8:	d8c02e15 	stw	r3,184(sp)
811289ec:	1805883a 	mov	r2,r3
811289f0:	183fb20e 	bge	r3,zero,811288bc <__reset+0xfb1088bc>
811289f4:	0005883a 	mov	r2,zero
811289f8:	003fb006 	br	811288bc <__reset+0xfb1088bc>
811289fc:	d9003617 	ldw	r4,216(sp)
81128a00:	000d883a 	mov	r6,zero
81128a04:	000f883a 	mov	r7,zero
81128a08:	980b883a 	mov	r5,r19
81128a0c:	d8c03c15 	stw	r3,240(sp)
81128a10:	da003d15 	stw	r8,244(sp)
81128a14:	11373280 	call	81137328 <__eqdf2>
81128a18:	d8c03c17 	ldw	r3,240(sp)
81128a1c:	da003d17 	ldw	r8,244(sp)
81128a20:	103f9826 	beq	r2,zero,81128884 <__reset+0xfb108884>
81128a24:	00800044 	movi	r2,1
81128a28:	10c7c83a 	sub	r3,r2,r3
81128a2c:	d8c02615 	stw	r3,152(sp)
81128a30:	003f9506 	br	81128888 <__reset+0xfb108888>
81128a34:	d9002917 	ldw	r4,164(sp)
81128a38:	d8c03217 	ldw	r3,200(sp)
81128a3c:	20800044 	addi	r2,r4,1
81128a40:	1885883a 	add	r2,r3,r2
81128a44:	d8802e15 	stw	r2,184(sp)
81128a48:	103dbf0e 	bge	r2,zero,81128148 <__reset+0xfb108148>
81128a4c:	0005883a 	mov	r2,zero
81128a50:	003dbd06 	br	81128148 <__reset+0xfb108148>
81128a54:	2000211e 	bne	r4,zero,81128adc <___vfprintf_internal_r+0x2170>
81128a58:	9480004c 	andi	r18,r18,1
81128a5c:	90001f1e 	bne	r18,zero,81128adc <___vfprintf_internal_r+0x2170>
81128a60:	00800044 	movi	r2,1
81128a64:	d8802e15 	stw	r2,184(sp)
81128a68:	003db706 	br	81128148 <__reset+0xfb108148>
81128a6c:	00800b44 	movi	r2,45
81128a70:	05adc83a 	sub	r22,zero,r22
81128a74:	d8802305 	stb	r2,140(sp)
81128a78:	003f3f06 	br	81128778 <__reset+0xfb108778>
81128a7c:	0005883a 	mov	r2,zero
81128a80:	003f5206 	br	811287cc <__reset+0xfb1087cc>
81128a84:	90a4703a 	and	r18,r18,r2
81128a88:	903f4e26 	beq	r18,zero,811287c4 <__reset+0xfb1087c4>
81128a8c:	003f4a06 	br	811287b8 <__reset+0xfb1087b8>
81128a90:	00800084 	movi	r2,2
81128a94:	10c5c83a 	sub	r2,r2,r3
81128a98:	003f8406 	br	811288ac <__reset+0xfb1088ac>
81128a9c:	d8802d17 	ldw	r2,180(sp)
81128aa0:	d9002d17 	ldw	r4,180(sp)
81128aa4:	ac400043 	ldbu	r17,1(r21)
81128aa8:	10800017 	ldw	r2,0(r2)
81128aac:	582b883a 	mov	r21,r11
81128ab0:	d8802915 	stw	r2,164(sp)
81128ab4:	20800104 	addi	r2,r4,4
81128ab8:	d9002917 	ldw	r4,164(sp)
81128abc:	d8802d15 	stw	r2,180(sp)
81128ac0:	203e7a0e 	bge	r4,zero,811284ac <__reset+0xfb1084ac>
81128ac4:	8c403fcc 	andi	r17,r17,255
81128ac8:	00bfffc4 	movi	r2,-1
81128acc:	8c40201c 	xori	r17,r17,128
81128ad0:	d8802915 	stw	r2,164(sp)
81128ad4:	8c7fe004 	addi	r17,r17,-128
81128ad8:	00380706 	br	81126af8 <__reset+0xfb106af8>
81128adc:	d8c02917 	ldw	r3,164(sp)
81128ae0:	18c00084 	addi	r3,r3,2
81128ae4:	d8c02e15 	stw	r3,184(sp)
81128ae8:	1805883a 	mov	r2,r3
81128aec:	183d960e 	bge	r3,zero,81128148 <__reset+0xfb108148>
81128af0:	003fd606 	br	81128a4c <__reset+0xfb108a4c>
81128af4:	0005883a 	mov	r2,zero
81128af8:	003f8e06 	br	81128934 <__reset+0xfb108934>
81128afc:	9080004c 	andi	r2,r18,1
81128b00:	103f811e 	bne	r2,zero,81128908 <__reset+0xfb108908>
81128b04:	d8802117 	ldw	r2,132(sp)
81128b08:	1405c83a 	sub	r2,r2,r16
81128b0c:	d8803315 	stw	r2,204(sp)
81128b10:	b47ef326 	beq	r22,r17,811286e0 <__reset+0xfb1086e0>
81128b14:	dd802617 	ldw	r22,152(sp)
81128b18:	003f1106 	br	81128760 <__reset+0xfb108760>
81128b1c:	d9c02785 	stb	r7,158(sp)
81128b20:	00390406 	br	81126f34 <__reset+0xfb106f34>
81128b24:	d9c02785 	stb	r7,158(sp)
81128b28:	0038d306 	br	81126e78 <__reset+0xfb106e78>
81128b2c:	d9c02785 	stb	r7,158(sp)
81128b30:	003a6106 	br	811274b8 <__reset+0xfb1074b8>
81128b34:	d9c02785 	stb	r7,158(sp)
81128b38:	003af806 	br	8112771c <__reset+0xfb10771c>
81128b3c:	0005883a 	mov	r2,zero
81128b40:	003d7e06 	br	8112813c <__reset+0xfb10813c>
81128b44:	d8802344 	addi	r2,sp,141
81128b48:	003f1306 	br	81128798 <__reset+0xfb108798>
81128b4c:	d9c02785 	stb	r7,158(sp)
81128b50:	00392306 	br	81126fe0 <__reset+0xfb106fe0>
81128b54:	d9c02785 	stb	r7,158(sp)
81128b58:	003aa906 	br	81127600 <__reset+0xfb107600>
81128b5c:	d9c02785 	stb	r7,158(sp)
81128b60:	003a3d06 	br	81127458 <__reset+0xfb107458>
81128b64:	d9c02785 	stb	r7,158(sp)
81128b68:	003aca06 	br	81127694 <__reset+0xfb107694>

81128b6c <__vfprintf_internal>:
81128b6c:	00a04574 	movhi	r2,33045
81128b70:	1090f104 	addi	r2,r2,17348
81128b74:	300f883a 	mov	r7,r6
81128b78:	280d883a 	mov	r6,r5
81128b7c:	200b883a 	mov	r5,r4
81128b80:	11000017 	ldw	r4,0(r2)
81128b84:	112696c1 	jmpi	8112696c <___vfprintf_internal_r>

81128b88 <__sbprintf>:
81128b88:	defee204 	addi	sp,sp,-1144
81128b8c:	de00012e 	bgeu	sp,et,81128b94 <__sbprintf+0xc>
81128b90:	003b68fa 	trap	3
81128b94:	2880030b 	ldhu	r2,12(r5)
81128b98:	2ac01917 	ldw	r11,100(r5)
81128b9c:	2a80038b 	ldhu	r10,14(r5)
81128ba0:	2a400717 	ldw	r9,28(r5)
81128ba4:	2a000917 	ldw	r8,36(r5)
81128ba8:	00c10004 	movi	r3,1024
81128bac:	dc011a15 	stw	r16,1128(sp)
81128bb0:	10bfff4c 	andi	r2,r2,65533
81128bb4:	2821883a 	mov	r16,r5
81128bb8:	d8cb883a 	add	r5,sp,r3
81128bbc:	dc811c15 	stw	r18,1136(sp)
81128bc0:	dc411b15 	stw	r17,1132(sp)
81128bc4:	dfc11d15 	stw	ra,1140(sp)
81128bc8:	2025883a 	mov	r18,r4
81128bcc:	d881030d 	sth	r2,1036(sp)
81128bd0:	dac11915 	stw	r11,1124(sp)
81128bd4:	da81038d 	sth	r10,1038(sp)
81128bd8:	da410715 	stw	r9,1052(sp)
81128bdc:	da010915 	stw	r8,1060(sp)
81128be0:	dec10015 	stw	sp,1024(sp)
81128be4:	dec10415 	stw	sp,1040(sp)
81128be8:	d8c10215 	stw	r3,1032(sp)
81128bec:	d8c10515 	stw	r3,1044(sp)
81128bf0:	d8010615 	stw	zero,1048(sp)
81128bf4:	112696c0 	call	8112696c <___vfprintf_internal_r>
81128bf8:	1023883a 	mov	r17,r2
81128bfc:	10000416 	blt	r2,zero,81128c10 <__sbprintf+0x88>
81128c00:	d9410004 	addi	r5,sp,1024
81128c04:	9009883a 	mov	r4,r18
81128c08:	112c32c0 	call	8112c32c <_fflush_r>
81128c0c:	10000d1e 	bne	r2,zero,81128c44 <__sbprintf+0xbc>
81128c10:	d881030b 	ldhu	r2,1036(sp)
81128c14:	1080100c 	andi	r2,r2,64
81128c18:	10000326 	beq	r2,zero,81128c28 <__sbprintf+0xa0>
81128c1c:	8080030b 	ldhu	r2,12(r16)
81128c20:	10801014 	ori	r2,r2,64
81128c24:	8080030d 	sth	r2,12(r16)
81128c28:	8805883a 	mov	r2,r17
81128c2c:	dfc11d17 	ldw	ra,1140(sp)
81128c30:	dc811c17 	ldw	r18,1136(sp)
81128c34:	dc411b17 	ldw	r17,1132(sp)
81128c38:	dc011a17 	ldw	r16,1128(sp)
81128c3c:	dec11e04 	addi	sp,sp,1144
81128c40:	f800283a 	ret
81128c44:	047fffc4 	movi	r17,-1
81128c48:	003ff106 	br	81128c10 <__reset+0xfb108c10>

81128c4c <__svfscanf_r>:
81128c4c:	deff4b04 	addi	sp,sp,-724
81128c50:	de00012e 	bgeu	sp,et,81128c58 <__svfscanf_r+0xc>
81128c54:	003b68fa 	trap	3
81128c58:	2880030b 	ldhu	r2,12(r5)
81128c5c:	df00b315 	stw	fp,716(sp)
81128c60:	dd80b115 	stw	r22,708(sp)
81128c64:	dfc0b415 	stw	ra,720(sp)
81128c68:	ddc0b215 	stw	r23,712(sp)
81128c6c:	dd40b015 	stw	r21,704(sp)
81128c70:	dd00af15 	stw	r20,700(sp)
81128c74:	dcc0ae15 	stw	r19,696(sp)
81128c78:	dc80ad15 	stw	r18,692(sp)
81128c7c:	dc40ac15 	stw	r17,688(sp)
81128c80:	dc00ab15 	stw	r16,684(sp)
81128c84:	10c8000c 	andi	r3,r2,8192
81128c88:	d9c09c15 	stw	r7,624(sp)
81128c8c:	2839883a 	mov	fp,r5
81128c90:	202d883a 	mov	r22,r4
81128c94:	1800061e 	bne	r3,zero,81128cb0 <__svfscanf_r+0x64>
81128c98:	29001917 	ldw	r4,100(r5)
81128c9c:	00f7ffc4 	movi	r3,-8193
81128ca0:	10880014 	ori	r2,r2,8192
81128ca4:	20c6703a 	and	r3,r4,r3
81128ca8:	2880030d 	sth	r2,12(r5)
81128cac:	28c01915 	stw	r3,100(r5)
81128cb0:	30800003 	ldbu	r2,0(r6)
81128cb4:	0021883a 	mov	r16,zero
81128cb8:	05e04574 	movhi	r23,33045
81128cbc:	d800a115 	stw	zero,644(sp)
81128cc0:	d8009e15 	stw	zero,632(sp)
81128cc4:	d800a015 	stw	zero,640(sp)
81128cc8:	d8809b15 	stw	r2,620(sp)
81128ccc:	bdd0ef04 	addi	r23,r23,17340
81128cd0:	8025883a 	mov	r18,r16
81128cd4:	35000044 	addi	r20,r6,1
81128cd8:	10001e26 	beq	r2,zero,81128d54 <__svfscanf_r+0x108>
81128cdc:	b9c00017 	ldw	r7,0(r23)
81128ce0:	3887883a 	add	r3,r7,r2
81128ce4:	18c00043 	ldbu	r3,1(r3)
81128ce8:	18c0020c 	andi	r3,r3,8
81128cec:	18001b26 	beq	r3,zero,81128d5c <__svfscanf_r+0x110>
81128cf0:	e0800117 	ldw	r2,4(fp)
81128cf4:	00800e0e 	bge	zero,r2,81128d30 <__svfscanf_r+0xe4>
81128cf8:	e0c00017 	ldw	r3,0(fp)
81128cfc:	b9000017 	ldw	r4,0(r23)
81128d00:	18800003 	ldbu	r2,0(r3)
81128d04:	2085883a 	add	r2,r4,r2
81128d08:	10800043 	ldbu	r2,1(r2)
81128d0c:	1080020c 	andi	r2,r2,8
81128d10:	10000b26 	beq	r2,zero,81128d40 <__svfscanf_r+0xf4>
81128d14:	e0800117 	ldw	r2,4(fp)
81128d18:	18c00044 	addi	r3,r3,1
81128d1c:	e0c00015 	stw	r3,0(fp)
81128d20:	10bfffc4 	addi	r2,r2,-1
81128d24:	e0800115 	stw	r2,4(fp)
81128d28:	94800044 	addi	r18,r18,1
81128d2c:	00bff216 	blt	zero,r2,81128cf8 <__reset+0xfb108cf8>
81128d30:	e00b883a 	mov	r5,fp
81128d34:	b009883a 	mov	r4,r22
81128d38:	1123f2c0 	call	81123f2c <__srefill_r>
81128d3c:	103fee26 	beq	r2,zero,81128cf8 <__reset+0xfb108cf8>
81128d40:	a00d883a 	mov	r6,r20
81128d44:	30800003 	ldbu	r2,0(r6)
81128d48:	35000044 	addi	r20,r6,1
81128d4c:	d8809b15 	stw	r2,620(sp)
81128d50:	103fe21e 	bne	r2,zero,81128cdc <__reset+0xfb108cdc>
81128d54:	d880a017 	ldw	r2,640(sp)
81128d58:	00009906 	br	81128fc0 <__svfscanf_r+0x374>
81128d5c:	00c00944 	movi	r3,37
81128d60:	10c0881e 	bne	r2,r3,81128f84 <__svfscanf_r+0x338>
81128d64:	30c00043 	ldbu	r3,1(r6)
81128d68:	0023883a 	mov	r17,zero
81128d6c:	0027883a 	mov	r19,zero
81128d70:	01001e04 	movi	r4,120
81128d74:	01401b04 	movi	r5,108
81128d78:	a1800044 	addi	r6,r20,1
81128d7c:	20c0a236 	bltu	r4,r3,81129008 <__svfscanf_r+0x3bc>
81128d80:	180490ba 	slli	r2,r3,2
81128d84:	022044f4 	movhi	r8,33043
81128d88:	42236604 	addi	r8,r8,-29288
81128d8c:	1205883a 	add	r2,r2,r8
81128d90:	10800017 	ldw	r2,0(r2)
81128d94:	1000683a 	jmp	r2
81128d98:	81128fbc 	xorhi	r4,r16,19006
81128d9c:	81129008 	cmpgei	r4,r16,19008
81128da0:	81129008 	cmpgei	r4,r16,19008
81128da4:	81129008 	cmpgei	r4,r16,19008
81128da8:	81129008 	cmpgei	r4,r16,19008
81128dac:	81129008 	cmpgei	r4,r16,19008
81128db0:	81129008 	cmpgei	r4,r16,19008
81128db4:	81129008 	cmpgei	r4,r16,19008
81128db8:	81129008 	cmpgei	r4,r16,19008
81128dbc:	81129008 	cmpgei	r4,r16,19008
81128dc0:	81129008 	cmpgei	r4,r16,19008
81128dc4:	81129008 	cmpgei	r4,r16,19008
81128dc8:	81129008 	cmpgei	r4,r16,19008
81128dcc:	81129008 	cmpgei	r4,r16,19008
81128dd0:	81129008 	cmpgei	r4,r16,19008
81128dd4:	81129008 	cmpgei	r4,r16,19008
81128dd8:	81129008 	cmpgei	r4,r16,19008
81128ddc:	81129008 	cmpgei	r4,r16,19008
81128de0:	81129008 	cmpgei	r4,r16,19008
81128de4:	81129008 	cmpgei	r4,r16,19008
81128de8:	81129008 	cmpgei	r4,r16,19008
81128dec:	81129008 	cmpgei	r4,r16,19008
81128df0:	81129008 	cmpgei	r4,r16,19008
81128df4:	81129008 	cmpgei	r4,r16,19008
81128df8:	81129008 	cmpgei	r4,r16,19008
81128dfc:	81129008 	cmpgei	r4,r16,19008
81128e00:	81129008 	cmpgei	r4,r16,19008
81128e04:	81129008 	cmpgei	r4,r16,19008
81128e08:	81129008 	cmpgei	r4,r16,19008
81128e0c:	81129008 	cmpgei	r4,r16,19008
81128e10:	81129008 	cmpgei	r4,r16,19008
81128e14:	81129008 	cmpgei	r4,r16,19008
81128e18:	81129008 	cmpgei	r4,r16,19008
81128e1c:	81129008 	cmpgei	r4,r16,19008
81128e20:	81129008 	cmpgei	r4,r16,19008
81128e24:	81129008 	cmpgei	r4,r16,19008
81128e28:	81129008 	cmpgei	r4,r16,19008
81128e2c:	81128f7c 	xorhi	r4,r16,19005
81128e30:	81129008 	cmpgei	r4,r16,19008
81128e34:	81129008 	cmpgei	r4,r16,19008
81128e38:	81129008 	cmpgei	r4,r16,19008
81128e3c:	81129008 	cmpgei	r4,r16,19008
81128e40:	81128ff0 	cmpltui	r4,r16,19007
81128e44:	81129008 	cmpgei	r4,r16,19008
81128e48:	81129008 	cmpgei	r4,r16,19008
81128e4c:	81129008 	cmpgei	r4,r16,19008
81128e50:	81129008 	cmpgei	r4,r16,19008
81128e54:	81129008 	cmpgei	r4,r16,19008
81128e58:	81129124 	muli	r4,r16,19012
81128e5c:	81129124 	muli	r4,r16,19012
81128e60:	81129124 	muli	r4,r16,19012
81128e64:	81129124 	muli	r4,r16,19012
81128e68:	81129124 	muli	r4,r16,19012
81128e6c:	81129124 	muli	r4,r16,19012
81128e70:	81129124 	muli	r4,r16,19012
81128e74:	81129124 	muli	r4,r16,19012
81128e78:	81129124 	muli	r4,r16,19012
81128e7c:	81129124 	muli	r4,r16,19012
81128e80:	81129008 	cmpgei	r4,r16,19008
81128e84:	81129008 	cmpgei	r4,r16,19008
81128e88:	81129008 	cmpgei	r4,r16,19008
81128e8c:	81129008 	cmpgei	r4,r16,19008
81128e90:	81129008 	cmpgei	r4,r16,19008
81128e94:	81129008 	cmpgei	r4,r16,19008
81128e98:	81129008 	cmpgei	r4,r16,19008
81128e9c:	81129008 	cmpgei	r4,r16,19008
81128ea0:	81129008 	cmpgei	r4,r16,19008
81128ea4:	81129008 	cmpgei	r4,r16,19008
81128ea8:	811290f8 	rdprs	r4,r16,19011
81128eac:	811291a8 	cmpgeui	r4,r16,19014
81128eb0:	81129008 	cmpgei	r4,r16,19008
81128eb4:	811291a8 	cmpgeui	r4,r16,19014
81128eb8:	81129008 	cmpgei	r4,r16,19008
81128ebc:	81129008 	cmpgei	r4,r16,19008
81128ec0:	81129008 	cmpgei	r4,r16,19008
81128ec4:	81129008 	cmpgei	r4,r16,19008
81128ec8:	81129194 	ori	r4,r16,19014
81128ecc:	81129008 	cmpgei	r4,r16,19008
81128ed0:	81129008 	cmpgei	r4,r16,19008
81128ed4:	81129168 	cmpgeui	r4,r16,19013
81128ed8:	81129008 	cmpgei	r4,r16,19008
81128edc:	81129008 	cmpgei	r4,r16,19008
81128ee0:	81129008 	cmpgei	r4,r16,19008
81128ee4:	81129008 	cmpgei	r4,r16,19008
81128ee8:	81129008 	cmpgei	r4,r16,19008
81128eec:	81129008 	cmpgei	r4,r16,19008
81128ef0:	81129008 	cmpgei	r4,r16,19008
81128ef4:	81129008 	cmpgei	r4,r16,19008
81128ef8:	81129140 	call	88112914 <__reset+0x20f2914>
81128efc:	81129008 	cmpgei	r4,r16,19008
81128f00:	81129008 	cmpgei	r4,r16,19008
81128f04:	811292dc 	xori	r4,r16,19019
81128f08:	81129008 	cmpgei	r4,r16,19008
81128f0c:	81129008 	cmpgei	r4,r16,19008
81128f10:	81129008 	cmpgei	r4,r16,19008
81128f14:	81129008 	cmpgei	r4,r16,19008
81128f18:	81129008 	cmpgei	r4,r16,19008
81128f1c:	81129008 	cmpgei	r4,r16,19008
81128f20:	81129008 	cmpgei	r4,r16,19008
81128f24:	81129260 	cmpeqi	r4,r16,19017
81128f28:	81129238 	rdprs	r4,r16,19016
81128f2c:	811291a8 	cmpgeui	r4,r16,19014
81128f30:	811291a8 	cmpgeui	r4,r16,19014
81128f34:	811291a8 	cmpgeui	r4,r16,19014
81128f38:	81129224 	muli	r4,r16,19016
81128f3c:	81129368 	cmpgeui	r4,r16,19021
81128f40:	81129008 	cmpgei	r4,r16,19008
81128f44:	81129008 	cmpgei	r4,r16,19008
81128f48:	81129210 	cmplti	r4,r16,19016
81128f4c:	81129008 	cmpgei	r4,r16,19008
81128f50:	811291e0 	cmpeqi	r4,r16,19015
81128f54:	811291bc 	xorhi	r4,r16,19014
81128f58:	811290cc 	andi	r4,r16,19011
81128f5c:	81129008 	cmpgei	r4,r16,19008
81128f60:	81129008 	cmpgei	r4,r16,19008
81128f64:	811290b8 	rdprs	r4,r16,19010
81128f68:	81129008 	cmpgei	r4,r16,19008
81128f6c:	81129040 	call	88112904 <__reset+0x20f2904>
81128f70:	81129008 	cmpgei	r4,r16,19008
81128f74:	81129008 	cmpgei	r4,r16,19008
81128f78:	81129140 	call	88112914 <__reset+0x20f2914>
81128f7c:	d9809d15 	stw	r6,628(sp)
81128f80:	3029883a 	mov	r20,r6
81128f84:	e0800117 	ldw	r2,4(fp)
81128f88:	0081aa0e 	bge	zero,r2,81129634 <__svfscanf_r+0x9e8>
81128f8c:	e0800017 	ldw	r2,0(fp)
81128f90:	a0ffffc3 	ldbu	r3,-1(r20)
81128f94:	11000003 	ldbu	r4,0(r2)
81128f98:	20ff6e1e 	bne	r4,r3,81128d54 <__reset+0xfb108d54>
81128f9c:	e0c00117 	ldw	r3,4(fp)
81128fa0:	10800044 	addi	r2,r2,1
81128fa4:	e0800015 	stw	r2,0(fp)
81128fa8:	18bfffc4 	addi	r2,r3,-1
81128fac:	e0800115 	stw	r2,4(fp)
81128fb0:	94800044 	addi	r18,r18,1
81128fb4:	a00d883a 	mov	r6,r20
81128fb8:	003f6206 	br	81128d44 <__reset+0xfb108d44>
81128fbc:	00bfffc4 	movi	r2,-1
81128fc0:	dfc0b417 	ldw	ra,720(sp)
81128fc4:	df00b317 	ldw	fp,716(sp)
81128fc8:	ddc0b217 	ldw	r23,712(sp)
81128fcc:	dd80b117 	ldw	r22,708(sp)
81128fd0:	dd40b017 	ldw	r21,704(sp)
81128fd4:	dd00af17 	ldw	r20,700(sp)
81128fd8:	dcc0ae17 	ldw	r19,696(sp)
81128fdc:	dc80ad17 	ldw	r18,692(sp)
81128fe0:	dc40ac17 	ldw	r17,688(sp)
81128fe4:	dc00ab17 	ldw	r16,684(sp)
81128fe8:	dec0b504 	addi	sp,sp,724
81128fec:	f800283a 	ret
81128ff0:	a0800043 	ldbu	r2,1(r20)
81128ff4:	3029883a 	mov	r20,r6
81128ff8:	8c400414 	ori	r17,r17,16
81128ffc:	10c03fcc 	andi	r3,r2,255
81129000:	a1800044 	addi	r6,r20,1
81129004:	20ff5e2e 	bgeu	r4,r3,81128d80 <__reset+0xfb108d80>
81129008:	38c7883a 	add	r3,r7,r3
8112900c:	18800043 	ldbu	r2,1(r3)
81129010:	d9809d15 	stw	r6,628(sp)
81129014:	00c00044 	movi	r3,1
81129018:	108000cc 	andi	r2,r2,3
8112901c:	10c18f26 	beq	r2,r3,8112965c <__svfscanf_r+0xa10>
81129020:	e0800117 	ldw	r2,4(fp)
81129024:	00808716 	blt	zero,r2,81129244 <__svfscanf_r+0x5f8>
81129028:	e00b883a 	mov	r5,fp
8112902c:	b009883a 	mov	r4,r22
81129030:	1123f2c0 	call	81123f2c <__srefill_r>
81129034:	1001431e 	bne	r2,zero,81129544 <__svfscanf_r+0x8f8>
81129038:	b9c00017 	ldw	r7,0(r23)
8112903c:	00008106 	br	81129244 <__svfscanf_r+0x5f8>
81129040:	e0800117 	ldw	r2,4(fp)
81129044:	d9809d15 	stw	r6,628(sp)
81129048:	0081a30e 	bge	zero,r2,811296d8 <__svfscanf_r+0xa8c>
8112904c:	00a044f4 	movhi	r2,33043
81129050:	10839704 	addi	r2,r2,3676
81129054:	02000284 	movi	r8,10
81129058:	d880a115 	stw	r2,644(sp)
8112905c:	da009e15 	stw	r8,632(sp)
81129060:	050000c4 	movi	r20,3
81129064:	e0c00017 	ldw	r3,0(fp)
81129068:	00000206 	br	81129074 <__svfscanf_r+0x428>
8112906c:	18c00044 	addi	r3,r3,1
81129070:	e0c00015 	stw	r3,0(fp)
81129074:	19000003 	ldbu	r4,0(r3)
81129078:	20803fcc 	andi	r2,r4,255
8112907c:	3885883a 	add	r2,r7,r2
81129080:	10800043 	ldbu	r2,1(r2)
81129084:	1140020c 	andi	r5,r2,8
81129088:	2801ab26 	beq	r5,zero,81129738 <__svfscanf_r+0xaec>
8112908c:	e0800117 	ldw	r2,4(fp)
81129090:	94800044 	addi	r18,r18,1
81129094:	10bfffc4 	addi	r2,r2,-1
81129098:	e0800115 	stw	r2,4(fp)
8112909c:	00bff316 	blt	zero,r2,8112906c <__reset+0xfb10906c>
811290a0:	e00b883a 	mov	r5,fp
811290a4:	b009883a 	mov	r4,r22
811290a8:	1123f2c0 	call	81123f2c <__srefill_r>
811290ac:	1001251e 	bne	r2,zero,81129544 <__svfscanf_r+0x8f8>
811290b0:	b9c00017 	ldw	r7,0(r23)
811290b4:	003feb06 	br	81129064 <__reset+0xfb109064>
811290b8:	e0800117 	ldw	r2,4(fp)
811290bc:	d9809d15 	stw	r6,628(sp)
811290c0:	00818b0e 	bge	zero,r2,811296f0 <__svfscanf_r+0xaa4>
811290c4:	05000084 	movi	r20,2
811290c8:	003fe606 	br	81129064 <__reset+0xfb109064>
811290cc:	e0800117 	ldw	r2,4(fp)
811290d0:	d9809d15 	stw	r6,628(sp)
811290d4:	8c408814 	ori	r17,r17,544
811290d8:	00801d0e 	bge	zero,r2,81129150 <__svfscanf_r+0x504>
811290dc:	00a044f4 	movhi	r2,33043
811290e0:	10839704 	addi	r2,r2,3676
811290e4:	02000404 	movi	r8,16
811290e8:	d880a115 	stw	r2,644(sp)
811290ec:	da009e15 	stw	r8,632(sp)
811290f0:	050000c4 	movi	r20,3
811290f4:	003fdb06 	br	81129064 <__reset+0xfb109064>
811290f8:	e0800117 	ldw	r2,4(fp)
811290fc:	d9809d15 	stw	r6,628(sp)
81129100:	8c400054 	ori	r17,r17,1
81129104:	00bfc80e 	bge	zero,r2,81129028 <__reset+0xfb109028>
81129108:	00e044b4 	movhi	r3,33042
8112910c:	18d14c04 	addi	r3,r3,17712
81129110:	02000284 	movi	r8,10
81129114:	d8c0a115 	stw	r3,644(sp)
81129118:	da009e15 	stw	r8,632(sp)
8112911c:	050000c4 	movi	r20,3
81129120:	003fd006 	br	81129064 <__reset+0xfb109064>
81129124:	9cc002a4 	muli	r19,r19,10
81129128:	a0800043 	ldbu	r2,1(r20)
8112912c:	3029883a 	mov	r20,r6
81129130:	98e7883a 	add	r19,r19,r3
81129134:	9cfff404 	addi	r19,r19,-48
81129138:	10c03fcc 	andi	r3,r2,255
8112913c:	003f0e06 	br	81128d78 <__reset+0xfb108d78>
81129140:	e0800117 	ldw	r2,4(fp)
81129144:	d9809d15 	stw	r6,628(sp)
81129148:	8c408014 	ori	r17,r17,512
8112914c:	00bfe316 	blt	zero,r2,811290dc <__reset+0xfb1090dc>
81129150:	e00b883a 	mov	r5,fp
81129154:	b009883a 	mov	r4,r22
81129158:	1123f2c0 	call	81123f2c <__srefill_r>
8112915c:	1000f91e 	bne	r2,zero,81129544 <__svfscanf_r+0x8f8>
81129160:	b9c00017 	ldw	r7,0(r23)
81129164:	003fdd06 	br	811290dc <__reset+0xfb1090dc>
81129168:	e0800117 	ldw	r2,4(fp)
8112916c:	d9809d15 	stw	r6,628(sp)
81129170:	8c400054 	ori	r17,r17,1
81129174:	0080140e 	bge	zero,r2,811291c8 <__svfscanf_r+0x57c>
81129178:	00a044f4 	movhi	r2,33043
8112917c:	10839704 	addi	r2,r2,3676
81129180:	02000204 	movi	r8,8
81129184:	d880a115 	stw	r2,644(sp)
81129188:	da009e15 	stw	r8,632(sp)
8112918c:	050000c4 	movi	r20,3
81129190:	003fb406 	br	81129064 <__reset+0xfb109064>
81129194:	a0800043 	ldbu	r2,1(r20)
81129198:	8c400094 	ori	r17,r17,2
8112919c:	3029883a 	mov	r20,r6
811291a0:	10c03fcc 	andi	r3,r2,255
811291a4:	003ef406 	br	81128d78 <__reset+0xfb108d78>
811291a8:	e0800117 	ldw	r2,4(fp)
811291ac:	d9809d15 	stw	r6,628(sp)
811291b0:	0081420e 	bge	zero,r2,811296bc <__svfscanf_r+0xa70>
811291b4:	05000104 	movi	r20,4
811291b8:	003faa06 	br	81129064 <__reset+0xfb109064>
811291bc:	e0800117 	ldw	r2,4(fp)
811291c0:	d9809d15 	stw	r6,628(sp)
811291c4:	00bfec16 	blt	zero,r2,81129178 <__reset+0xfb109178>
811291c8:	e00b883a 	mov	r5,fp
811291cc:	b009883a 	mov	r4,r22
811291d0:	1123f2c0 	call	81123f2c <__srefill_r>
811291d4:	1000db1e 	bne	r2,zero,81129544 <__svfscanf_r+0x8f8>
811291d8:	b9c00017 	ldw	r7,0(r23)
811291dc:	003fe606 	br	81129178 <__reset+0xfb109178>
811291e0:	d9809d15 	stw	r6,628(sp)
811291e4:	8880040c 	andi	r2,r17,16
811291e8:	10009c1e 	bne	r2,zero,8112945c <__svfscanf_r+0x810>
811291ec:	8880010c 	andi	r2,r17,4
811291f0:	10011e26 	beq	r2,zero,8112966c <__svfscanf_r+0xa20>
811291f4:	da009c17 	ldw	r8,624(sp)
811291f8:	3029883a 	mov	r20,r6
811291fc:	40800017 	ldw	r2,0(r8)
81129200:	42000104 	addi	r8,r8,4
81129204:	da009c15 	stw	r8,624(sp)
81129208:	1480000d 	sth	r18,0(r2)
8112920c:	003ecc06 	br	81128d40 <__reset+0xfb108d40>
81129210:	a0c00043 	ldbu	r3,1(r20)
81129214:	19410c26 	beq	r3,r5,81129648 <__svfscanf_r+0x9fc>
81129218:	8c400054 	ori	r17,r17,1
8112921c:	3029883a 	mov	r20,r6
81129220:	003ed506 	br	81128d78 <__reset+0xfb108d78>
81129224:	a0800043 	ldbu	r2,1(r20)
81129228:	8c400114 	ori	r17,r17,4
8112922c:	3029883a 	mov	r20,r6
81129230:	10c03fcc 	andi	r3,r2,255
81129234:	003ed006 	br	81128d78 <__reset+0xfb108d78>
81129238:	e0800117 	ldw	r2,4(fp)
8112923c:	d9809d15 	stw	r6,628(sp)
81129240:	00bf790e 	bge	zero,r2,81129028 <__reset+0xfb109028>
81129244:	00a044b4 	movhi	r2,33042
81129248:	10914c04 	addi	r2,r2,17712
8112924c:	02000284 	movi	r8,10
81129250:	d880a115 	stw	r2,644(sp)
81129254:	da009e15 	stw	r8,632(sp)
81129258:	050000c4 	movi	r20,3
8112925c:	003f8106 	br	81129064 <__reset+0xfb109064>
81129260:	e0800117 	ldw	r2,4(fp)
81129264:	d9809d15 	stw	r6,628(sp)
81129268:	0080c40e 	bge	zero,r2,8112957c <__svfscanf_r+0x930>
8112926c:	9800011e 	bne	r19,zero,81129274 <__svfscanf_r+0x628>
81129270:	04c00044 	movi	r19,1
81129274:	8880004c 	andi	r2,r17,1
81129278:	1000441e 	bne	r2,zero,8112938c <__svfscanf_r+0x740>
8112927c:	8c40040c 	andi	r17,r17,16
81129280:	8800da26 	beq	r17,zero,811295ec <__svfscanf_r+0x9a0>
81129284:	0021883a 	mov	r16,zero
81129288:	00000806 	br	811292ac <__svfscanf_r+0x660>
8112928c:	1887883a 	add	r3,r3,r2
81129290:	e00b883a 	mov	r5,fp
81129294:	b009883a 	mov	r4,r22
81129298:	e0c00015 	stw	r3,0(fp)
8112929c:	80a1883a 	add	r16,r16,r2
811292a0:	98a7c83a 	sub	r19,r19,r2
811292a4:	1123f2c0 	call	81123f2c <__srefill_r>
811292a8:	1000ca1e 	bne	r2,zero,811295d4 <__svfscanf_r+0x988>
811292ac:	e0800117 	ldw	r2,4(fp)
811292b0:	e0c00017 	ldw	r3,0(fp)
811292b4:	14fff516 	blt	r2,r19,8112928c <__reset+0xfb10928c>
811292b8:	14c5c83a 	sub	r2,r2,r19
811292bc:	1cd5883a 	add	r10,r3,r19
811292c0:	84e1883a 	add	r16,r16,r19
811292c4:	e0800115 	stw	r2,4(fp)
811292c8:	e2800015 	stw	r10,0(fp)
811292cc:	dd009d17 	ldw	r20,628(sp)
811292d0:	9425883a 	add	r18,r18,r16
811292d4:	a00d883a 	mov	r6,r20
811292d8:	003e9a06 	br	81128d44 <__reset+0xfb108d44>
811292dc:	300b883a 	mov	r5,r6
811292e0:	d9005884 	addi	r4,sp,354
811292e4:	d9809d15 	stw	r6,628(sp)
811292e8:	112f2340 	call	8112f234 <__sccl>
811292ec:	1029883a 	mov	r20,r2
811292f0:	e0800117 	ldw	r2,4(fp)
811292f4:	0081050e 	bge	zero,r2,8112970c <__svfscanf_r+0xac0>
811292f8:	e1000017 	ldw	r4,0(fp)
811292fc:	20800003 	ldbu	r2,0(r4)
81129300:	98005926 	beq	r19,zero,81129468 <__svfscanf_r+0x81c>
81129304:	8c40040c 	andi	r17,r17,16
81129308:	88005a26 	beq	r17,zero,81129474 <__svfscanf_r+0x828>
8112930c:	9823883a 	mov	r17,r19
81129310:	0021883a 	mov	r16,zero
81129314:	00000106 	br	8112931c <__svfscanf_r+0x6d0>
81129318:	20800003 	ldbu	r2,0(r4)
8112931c:	10803fcc 	andi	r2,r2,255
81129320:	d8c05884 	addi	r3,sp,354
81129324:	1885883a 	add	r2,r3,r2
81129328:	10800007 	ldb	r2,0(r2)
8112932c:	1000ad26 	beq	r2,zero,811295e4 <__svfscanf_r+0x998>
81129330:	e0800117 	ldw	r2,4(fp)
81129334:	21000044 	addi	r4,r4,1
81129338:	84000044 	addi	r16,r16,1
8112933c:	10bfffc4 	addi	r2,r2,-1
81129340:	e0800115 	stw	r2,4(fp)
81129344:	e1000015 	stw	r4,0(fp)
81129348:	84c0a026 	beq	r16,r19,811295cc <__svfscanf_r+0x980>
8112934c:	00bff216 	blt	zero,r2,81129318 <__reset+0xfb109318>
81129350:	e00b883a 	mov	r5,fp
81129354:	b009883a 	mov	r4,r22
81129358:	1123f2c0 	call	81123f2c <__srefill_r>
8112935c:	10009a1e 	bne	r2,zero,811295c8 <__svfscanf_r+0x97c>
81129360:	e1000017 	ldw	r4,0(fp)
81129364:	003fec06 	br	81129318 <__reset+0xfb109318>
81129368:	e0800117 	ldw	r2,4(fp)
8112936c:	d9809d15 	stw	r6,628(sp)
81129370:	0080eb0e 	bge	zero,r2,81129720 <__svfscanf_r+0xad4>
81129374:	00a044b4 	movhi	r2,33042
81129378:	10914c04 	addi	r2,r2,17712
8112937c:	d880a115 	stw	r2,644(sp)
81129380:	d8009e15 	stw	zero,632(sp)
81129384:	050000c4 	movi	r20,3
81129388:	003f3606 	br	81129064 <__reset+0xfb109064>
8112938c:	dd409904 	addi	r21,sp,612
81129390:	8c40040c 	andi	r17,r17,16
81129394:	01800204 	movi	r6,8
81129398:	000b883a 	mov	r5,zero
8112939c:	a809883a 	mov	r4,r21
811293a0:	dc409f15 	stw	r17,636(sp)
811293a4:	1123b2c0 	call	81123b2c <memset>
811293a8:	dc409f17 	ldw	r17,636(sp)
811293ac:	88006e26 	beq	r17,zero,81129568 <__svfscanf_r+0x91c>
811293b0:	0029883a 	mov	r20,zero
811293b4:	0023883a 	mov	r17,zero
811293b8:	112d6500 	call	8112d650 <__locale_mb_cur_max>
811293bc:	14406126 	beq	r2,r17,81129544 <__svfscanf_r+0x8f8>
811293c0:	e0800017 	ldw	r2,0(fp)
811293c4:	e0c00117 	ldw	r3,4(fp)
811293c8:	d9000104 	addi	r4,sp,4
811293cc:	12000003 	ldbu	r8,0(r2)
811293d0:	18ffffc4 	addi	r3,r3,-1
811293d4:	10800044 	addi	r2,r2,1
811293d8:	e0c00115 	stw	r3,4(fp)
811293dc:	e0800015 	stw	r2,0(fp)
811293e0:	8c000044 	addi	r16,r17,1
811293e4:	dd400015 	stw	r21,0(sp)
811293e8:	2463883a 	add	r17,r4,r17
811293ec:	200d883a 	mov	r6,r4
811293f0:	a00b883a 	mov	r5,r20
811293f4:	800f883a 	mov	r7,r16
811293f8:	b009883a 	mov	r4,r22
811293fc:	8a000005 	stb	r8,0(r17)
81129400:	112d70c0 	call	8112d70c <_mbrtowc_r>
81129404:	017fffc4 	movi	r5,-1
81129408:	11404e26 	beq	r2,r5,81129544 <__svfscanf_r+0x8f8>
8112940c:	1000601e 	bne	r2,zero,81129590 <__svfscanf_r+0x944>
81129410:	da009f17 	ldw	r8,636(sp)
81129414:	4000641e 	bne	r8,zero,811295a8 <__svfscanf_r+0x95c>
81129418:	a0000015 	stw	zero,0(r20)
8112941c:	9425883a 	add	r18,r18,r16
81129420:	9967883a 	add	r19,r19,r5
81129424:	a5000104 	addi	r20,r20,4
81129428:	e0800117 	ldw	r2,4(fp)
8112942c:	0023883a 	mov	r17,zero
81129430:	00804b16 	blt	zero,r2,81129560 <__svfscanf_r+0x914>
81129434:	e00b883a 	mov	r5,fp
81129438:	b009883a 	mov	r4,r22
8112943c:	1123f2c0 	call	81123f2c <__srefill_r>
81129440:	10004726 	beq	r2,zero,81129560 <__svfscanf_r+0x914>
81129444:	88003f1e 	bne	r17,zero,81129544 <__svfscanf_r+0x8f8>
81129448:	d8c09f17 	ldw	r3,636(sp)
8112944c:	1800031e 	bne	r3,zero,8112945c <__svfscanf_r+0x810>
81129450:	da00a017 	ldw	r8,640(sp)
81129454:	42000044 	addi	r8,r8,1
81129458:	da00a015 	stw	r8,640(sp)
8112945c:	dd009d17 	ldw	r20,628(sp)
81129460:	a00d883a 	mov	r6,r20
81129464:	003e3706 	br	81128d44 <__reset+0xfb108d44>
81129468:	8c40040c 	andi	r17,r17,16
8112946c:	04ffffc4 	movi	r19,-1
81129470:	883fa61e 	bne	r17,zero,8112930c <__reset+0xfb10930c>
81129474:	da009c17 	ldw	r8,624(sp)
81129478:	9abfffc4 	addi	r10,r19,-1
8112947c:	44000017 	ldw	r16,0(r8)
81129480:	44400104 	addi	r17,r8,4
81129484:	8007883a 	mov	r3,r16
81129488:	82ab883a 	add	r21,r16,r10
8112948c:	00000306 	br	8112949c <__svfscanf_r+0x850>
81129490:	e1000017 	ldw	r4,0(fp)
81129494:	9807883a 	mov	r3,r19
81129498:	20800003 	ldbu	r2,0(r4)
8112949c:	10803fcc 	andi	r2,r2,255
811294a0:	d9405884 	addi	r5,sp,354
811294a4:	2885883a 	add	r2,r5,r2
811294a8:	10800007 	ldb	r2,0(r2)
811294ac:	10004b26 	beq	r2,zero,811295dc <__svfscanf_r+0x990>
811294b0:	e0800117 	ldw	r2,4(fp)
811294b4:	21400044 	addi	r5,r4,1
811294b8:	e1400015 	stw	r5,0(fp)
811294bc:	10bfffc4 	addi	r2,r2,-1
811294c0:	e0800115 	stw	r2,4(fp)
811294c4:	20800003 	ldbu	r2,0(r4)
811294c8:	1cc00044 	addi	r19,r3,1
811294cc:	18800005 	stb	r2,0(r3)
811294d0:	1d400726 	beq	r3,r21,811294f0 <__svfscanf_r+0x8a4>
811294d4:	e0800117 	ldw	r2,4(fp)
811294d8:	00bfed16 	blt	zero,r2,81129490 <__reset+0xfb109490>
811294dc:	e00b883a 	mov	r5,fp
811294e0:	b009883a 	mov	r4,r22
811294e4:	1123f2c0 	call	81123f2c <__srefill_r>
811294e8:	103fe926 	beq	r2,zero,81129490 <__reset+0xfb109490>
811294ec:	84c01526 	beq	r16,r19,81129544 <__svfscanf_r+0x8f8>
811294f0:	9c21c83a 	sub	r16,r19,r16
811294f4:	803e1726 	beq	r16,zero,81128d54 <__reset+0xfb108d54>
811294f8:	da00a017 	ldw	r8,640(sp)
811294fc:	98000005 	stb	zero,0(r19)
81129500:	dc409c15 	stw	r17,624(sp)
81129504:	42000044 	addi	r8,r8,1
81129508:	da00a015 	stw	r8,640(sp)
8112950c:	9425883a 	add	r18,r18,r16
81129510:	a00d883a 	mov	r6,r20
81129514:	003e0b06 	br	81128d44 <__reset+0xfb108d44>
81129518:	017fff84 	movi	r5,-2
8112951c:	11439b1e 	bne	r2,r5,8112a38c <__svfscanf_r+0x1740>
81129520:	8821883a 	mov	r16,r17
81129524:	e0800117 	ldw	r2,4(fp)
81129528:	0082e516 	blt	zero,r2,8112a0c0 <__svfscanf_r+0x1474>
8112952c:	e00b883a 	mov	r5,fp
81129530:	b009883a 	mov	r4,r22
81129534:	1123f2c0 	call	81123f2c <__srefill_r>
81129538:	1002e126 	beq	r2,zero,8112a0c0 <__svfscanf_r+0x1474>
8112953c:	dc409f17 	ldw	r17,636(sp)
81129540:	8002e826 	beq	r16,zero,8112a0e4 <__svfscanf_r+0x1498>
81129544:	da00a017 	ldw	r8,640(sp)
81129548:	403e9c26 	beq	r8,zero,81128fbc <__reset+0xfb108fbc>
8112954c:	e080030b 	ldhu	r2,12(fp)
81129550:	1080100c 	andi	r2,r2,64
81129554:	103e991e 	bne	r2,zero,81128fbc <__reset+0xfb108fbc>
81129558:	4005883a 	mov	r2,r8
8112955c:	003e9806 	br	81128fc0 <__reset+0xfb108fc0>
81129560:	983f951e 	bne	r19,zero,811293b8 <__reset+0xfb1093b8>
81129564:	003fb806 	br	81129448 <__reset+0xfb109448>
81129568:	da009c17 	ldw	r8,624(sp)
8112956c:	45000017 	ldw	r20,0(r8)
81129570:	42000104 	addi	r8,r8,4
81129574:	da009c15 	stw	r8,624(sp)
81129578:	003f8e06 	br	811293b4 <__reset+0xfb1093b4>
8112957c:	e00b883a 	mov	r5,fp
81129580:	b009883a 	mov	r4,r22
81129584:	1123f2c0 	call	81123f2c <__srefill_r>
81129588:	103f3826 	beq	r2,zero,8112926c <__reset+0xfb10926c>
8112958c:	003fed06 	br	81129544 <__reset+0xfb109544>
81129590:	00ffff84 	movi	r3,-2
81129594:	10c0071e 	bne	r2,r3,811295b4 <__svfscanf_r+0x968>
81129598:	e0800117 	ldw	r2,4(fp)
8112959c:	8023883a 	mov	r17,r16
811295a0:	00bf8516 	blt	zero,r2,811293b8 <__reset+0xfb1093b8>
811295a4:	003fa306 	br	81129434 <__reset+0xfb109434>
811295a8:	9425883a 	add	r18,r18,r16
811295ac:	9cffffc4 	addi	r19,r19,-1
811295b0:	003f9d06 	br	81129428 <__reset+0xfb109428>
811295b4:	da009f17 	ldw	r8,636(sp)
811295b8:	9425883a 	add	r18,r18,r16
811295bc:	9cffffc4 	addi	r19,r19,-1
811295c0:	403f9826 	beq	r8,zero,81129424 <__reset+0xfb109424>
811295c4:	003f9806 	br	81129428 <__reset+0xfb109428>
811295c8:	8023883a 	mov	r17,r16
811295cc:	8821883a 	mov	r16,r17
811295d0:	003fce06 	br	8112950c <__reset+0xfb10950c>
811295d4:	803f3d1e 	bne	r16,zero,811292cc <__reset+0xfb1092cc>
811295d8:	003fda06 	br	81129544 <__reset+0xfb109544>
811295dc:	1827883a 	mov	r19,r3
811295e0:	003fc306 	br	811294f0 <__reset+0xfb1094f0>
811295e4:	803fc91e 	bne	r16,zero,8112950c <__reset+0xfb10950c>
811295e8:	003dda06 	br	81128d54 <__reset+0xfb108d54>
811295ec:	da009c17 	ldw	r8,624(sp)
811295f0:	df000015 	stw	fp,0(sp)
811295f4:	980f883a 	mov	r7,r19
811295f8:	41400017 	ldw	r5,0(r8)
811295fc:	01800044 	movi	r6,1
81129600:	b009883a 	mov	r4,r22
81129604:	112c8240 	call	8112c824 <_fread_r>
81129608:	da009c17 	ldw	r8,624(sp)
8112960c:	40c00104 	addi	r3,r8,4
81129610:	103fcc26 	beq	r2,zero,81129544 <__reset+0xfb109544>
81129614:	da00a017 	ldw	r8,640(sp)
81129618:	dd009d17 	ldw	r20,628(sp)
8112961c:	90a5883a 	add	r18,r18,r2
81129620:	42000044 	addi	r8,r8,1
81129624:	da00a015 	stw	r8,640(sp)
81129628:	d8c09c15 	stw	r3,624(sp)
8112962c:	a00d883a 	mov	r6,r20
81129630:	003dc406 	br	81128d44 <__reset+0xfb108d44>
81129634:	e00b883a 	mov	r5,fp
81129638:	b009883a 	mov	r4,r22
8112963c:	1123f2c0 	call	81123f2c <__srefill_r>
81129640:	103e5226 	beq	r2,zero,81128f8c <__reset+0xfb108f8c>
81129644:	003fbf06 	br	81129544 <__reset+0xfb109544>
81129648:	a0800083 	ldbu	r2,2(r20)
8112964c:	8c400094 	ori	r17,r17,2
81129650:	a5000084 	addi	r20,r20,2
81129654:	10c03fcc 	andi	r3,r2,255
81129658:	003dc706 	br	81128d78 <__reset+0xfb108d78>
8112965c:	e0800117 	ldw	r2,4(fp)
81129660:	88e2b03a 	or	r17,r17,r3
81129664:	00bef716 	blt	zero,r2,81129244 <__reset+0xfb109244>
81129668:	003e6f06 	br	81129028 <__reset+0xfb109028>
8112966c:	8880004c 	andi	r2,r17,1
81129670:	10000b1e 	bne	r2,zero,811296a0 <__svfscanf_r+0xa54>
81129674:	8c40008c 	andi	r17,r17,2
81129678:	88000926 	beq	r17,zero,811296a0 <__svfscanf_r+0xa54>
8112967c:	da009c17 	ldw	r8,624(sp)
81129680:	9007d7fa 	srai	r3,r18,31
81129684:	dd009d17 	ldw	r20,628(sp)
81129688:	40800017 	ldw	r2,0(r8)
8112968c:	42000104 	addi	r8,r8,4
81129690:	da009c15 	stw	r8,624(sp)
81129694:	14800015 	stw	r18,0(r2)
81129698:	10c00115 	stw	r3,4(r2)
8112969c:	003da806 	br	81128d40 <__reset+0xfb108d40>
811296a0:	da009c17 	ldw	r8,624(sp)
811296a4:	dd009d17 	ldw	r20,628(sp)
811296a8:	40800017 	ldw	r2,0(r8)
811296ac:	42000104 	addi	r8,r8,4
811296b0:	da009c15 	stw	r8,624(sp)
811296b4:	14800015 	stw	r18,0(r2)
811296b8:	003da106 	br	81128d40 <__reset+0xfb108d40>
811296bc:	e00b883a 	mov	r5,fp
811296c0:	b009883a 	mov	r4,r22
811296c4:	1123f2c0 	call	81123f2c <__srefill_r>
811296c8:	103f9e1e 	bne	r2,zero,81129544 <__reset+0xfb109544>
811296cc:	b9c00017 	ldw	r7,0(r23)
811296d0:	05000104 	movi	r20,4
811296d4:	003e6306 	br	81129064 <__reset+0xfb109064>
811296d8:	e00b883a 	mov	r5,fp
811296dc:	b009883a 	mov	r4,r22
811296e0:	1123f2c0 	call	81123f2c <__srefill_r>
811296e4:	103f971e 	bne	r2,zero,81129544 <__reset+0xfb109544>
811296e8:	b9c00017 	ldw	r7,0(r23)
811296ec:	003e5706 	br	8112904c <__reset+0xfb10904c>
811296f0:	e00b883a 	mov	r5,fp
811296f4:	b009883a 	mov	r4,r22
811296f8:	1123f2c0 	call	81123f2c <__srefill_r>
811296fc:	103f911e 	bne	r2,zero,81129544 <__reset+0xfb109544>
81129700:	b9c00017 	ldw	r7,0(r23)
81129704:	05000084 	movi	r20,2
81129708:	003e5606 	br	81129064 <__reset+0xfb109064>
8112970c:	e00b883a 	mov	r5,fp
81129710:	b009883a 	mov	r4,r22
81129714:	1123f2c0 	call	81123f2c <__srefill_r>
81129718:	103ef726 	beq	r2,zero,811292f8 <__reset+0xfb1092f8>
8112971c:	003f8906 	br	81129544 <__reset+0xfb109544>
81129720:	e00b883a 	mov	r5,fp
81129724:	b009883a 	mov	r4,r22
81129728:	1123f2c0 	call	81123f2c <__srefill_r>
8112972c:	103f851e 	bne	r2,zero,81129544 <__reset+0xfb109544>
81129730:	b9c00017 	ldw	r7,0(r23)
81129734:	003f0f06 	br	81129374 <__reset+0xfb109374>
81129738:	014000c4 	movi	r5,3
8112973c:	a1414a26 	beq	r20,r5,81129c68 <__svfscanf_r+0x101c>
81129740:	01000104 	movi	r4,4
81129744:	a101f11e 	bne	r20,r4,81129f0c <__svfscanf_r+0x12c0>
81129748:	b009883a 	mov	r4,r22
8112974c:	112d6740 	call	8112d674 <_localeconv_r>
81129750:	10800017 	ldw	r2,0(r2)
81129754:	98ffffc4 	addi	r3,r19,-1
81129758:	d880a315 	stw	r2,652(sp)
8112975c:	00805704 	movi	r2,348
81129760:	10c21e2e 	bgeu	r2,r3,81129fdc <__svfscanf_r+0x1390>
81129764:	9cffa8c4 	addi	r19,r19,-349
81129768:	dcc0a215 	stw	r19,648(sp)
8112976c:	04c05744 	movi	r19,349
81129770:	8d01e014 	ori	r20,r17,1920
81129774:	0023883a 	mov	r17,zero
81129778:	dc000104 	addi	r16,sp,4
8112977c:	8805883a 	mov	r2,r17
81129780:	0019883a 	mov	r12,zero
81129784:	8023883a 	mov	r17,r16
81129788:	b007883a 	mov	r3,r22
8112978c:	9821883a 	mov	r16,r19
81129790:	002b883a 	mov	r21,zero
81129794:	d800a515 	stw	zero,660(sp)
81129798:	d800a415 	stw	zero,656(sp)
8112979c:	d8009f15 	stw	zero,636(sp)
811297a0:	01c01384 	movi	r7,78
811297a4:	602d883a 	mov	r22,r12
811297a8:	1027883a 	mov	r19,r2
811297ac:	e1000017 	ldw	r4,0(fp)
811297b0:	21400003 	ldbu	r5,0(r4)
811297b4:	28bff544 	addi	r2,r5,-43
811297b8:	10803fcc 	andi	r2,r2,255
811297bc:	38810e36 	bltu	r7,r2,81129bf8 <__svfscanf_r+0xfac>
811297c0:	100490ba 	slli	r2,r2,2
811297c4:	01a044f4 	movhi	r6,33043
811297c8:	31a5f604 	addi	r6,r6,-26664
811297cc:	1185883a 	add	r2,r2,r6
811297d0:	10800017 	ldw	r2,0(r2)
811297d4:	1000683a 	jmp	r2
811297d8:	81129ad0 	cmplti	r4,r16,19051
811297dc:	81129bf8 	rdprs	r4,r16,19055
811297e0:	81129ad0 	cmplti	r4,r16,19051
811297e4:	81129bf8 	rdprs	r4,r16,19055
811297e8:	81129bf8 	rdprs	r4,r16,19055
811297ec:	81129aa4 	muli	r4,r16,19050
811297f0:	81129914 	ori	r4,r16,19044
811297f4:	81129914 	ori	r4,r16,19044
811297f8:	81129914 	ori	r4,r16,19044
811297fc:	81129914 	ori	r4,r16,19044
81129800:	81129914 	ori	r4,r16,19044
81129804:	81129914 	ori	r4,r16,19044
81129808:	81129914 	ori	r4,r16,19044
8112980c:	81129914 	ori	r4,r16,19044
81129810:	81129914 	ori	r4,r16,19044
81129814:	81129bf8 	rdprs	r4,r16,19055
81129818:	81129bf8 	rdprs	r4,r16,19055
8112981c:	81129bf8 	rdprs	r4,r16,19055
81129820:	81129bf8 	rdprs	r4,r16,19055
81129824:	81129bf8 	rdprs	r4,r16,19055
81129828:	81129bf8 	rdprs	r4,r16,19055
8112982c:	81129bf8 	rdprs	r4,r16,19055
81129830:	81129be8 	cmpgeui	r4,r16,19055
81129834:	81129bf8 	rdprs	r4,r16,19055
81129838:	81129bf8 	rdprs	r4,r16,19055
8112983c:	81129bf8 	rdprs	r4,r16,19055
81129840:	81129ba4 	muli	r4,r16,19054
81129844:	81129b88 	cmpgei	r4,r16,19054
81129848:	81129bf8 	rdprs	r4,r16,19055
8112984c:	81129bf8 	rdprs	r4,r16,19055
81129850:	81129b54 	ori	r4,r16,19053
81129854:	81129bf8 	rdprs	r4,r16,19055
81129858:	81129bf8 	rdprs	r4,r16,19055
8112985c:	81129bf8 	rdprs	r4,r16,19055
81129860:	81129bf8 	rdprs	r4,r16,19055
81129864:	81129b1c 	xori	r4,r16,19052
81129868:	81129bf8 	rdprs	r4,r16,19055
8112986c:	81129bf8 	rdprs	r4,r16,19055
81129870:	81129bf8 	rdprs	r4,r16,19055
81129874:	81129bf8 	rdprs	r4,r16,19055
81129878:	81129bf8 	rdprs	r4,r16,19055
8112987c:	81129b00 	call	881129b0 <__reset+0x20f29b0>
81129880:	81129bf8 	rdprs	r4,r16,19055
81129884:	81129bf8 	rdprs	r4,r16,19055
81129888:	81129bf8 	rdprs	r4,r16,19055
8112988c:	81129bf8 	rdprs	r4,r16,19055
81129890:	81129ae4 	muli	r4,r16,19051
81129894:	81129bf8 	rdprs	r4,r16,19055
81129898:	81129bf8 	rdprs	r4,r16,19055
8112989c:	81129bf8 	rdprs	r4,r16,19055
811298a0:	81129bf8 	rdprs	r4,r16,19055
811298a4:	81129bf8 	rdprs	r4,r16,19055
811298a8:	81129bf8 	rdprs	r4,r16,19055
811298ac:	81129bf8 	rdprs	r4,r16,19055
811298b0:	81129be8 	cmpgeui	r4,r16,19055
811298b4:	81129bf8 	rdprs	r4,r16,19055
811298b8:	81129bf8 	rdprs	r4,r16,19055
811298bc:	81129bf8 	rdprs	r4,r16,19055
811298c0:	81129ba4 	muli	r4,r16,19054
811298c4:	81129b88 	cmpgei	r4,r16,19054
811298c8:	81129bf8 	rdprs	r4,r16,19055
811298cc:	81129bf8 	rdprs	r4,r16,19055
811298d0:	81129b54 	ori	r4,r16,19053
811298d4:	81129bf8 	rdprs	r4,r16,19055
811298d8:	81129bf8 	rdprs	r4,r16,19055
811298dc:	81129bf8 	rdprs	r4,r16,19055
811298e0:	81129bf8 	rdprs	r4,r16,19055
811298e4:	81129b1c 	xori	r4,r16,19052
811298e8:	81129bf8 	rdprs	r4,r16,19055
811298ec:	81129bf8 	rdprs	r4,r16,19055
811298f0:	81129bf8 	rdprs	r4,r16,19055
811298f4:	81129bf8 	rdprs	r4,r16,19055
811298f8:	81129bf8 	rdprs	r4,r16,19055
811298fc:	81129b00 	call	881129b0 <__reset+0x20f29b0>
81129900:	81129bf8 	rdprs	r4,r16,19055
81129904:	81129bf8 	rdprs	r4,r16,19055
81129908:	81129bf8 	rdprs	r4,r16,19055
8112990c:	81129bf8 	rdprs	r4,r16,19055
81129910:	81129ae4 	muli	r4,r16,19051
81129914:	a8803fcc 	andi	r2,r21,255
81129918:	1080201c 	xori	r2,r2,128
8112991c:	10bfe004 	addi	r2,r2,-128
81129920:	b085883a 	add	r2,r22,r2
81129924:	10000d1e 	bne	r2,zero,8112995c <__svfscanf_r+0xd10>
81129928:	00bf9fc4 	movi	r2,-385
8112992c:	a0a8703a 	and	r20,r20,r2
81129930:	89400005 	stb	r5,0(r17)
81129934:	8c400044 	addi	r17,r17,1
81129938:	e0800117 	ldw	r2,4(fp)
8112993c:	843fffc4 	addi	r16,r16,-1
81129940:	94800044 	addi	r18,r18,1
81129944:	10bfffc4 	addi	r2,r2,-1
81129948:	e0800115 	stw	r2,4(fp)
8112994c:	0080b40e 	bge	zero,r2,81129c20 <__svfscanf_r+0xfd4>
81129950:	21000044 	addi	r4,r4,1
81129954:	e1000015 	stw	r4,0(fp)
81129958:	803f941e 	bne	r16,zero,811297ac <__reset+0xfb1097ac>
8112995c:	8821883a 	mov	r16,r17
81129960:	b019883a 	mov	r12,r22
81129964:	9823883a 	mov	r17,r19
81129968:	182d883a 	mov	r22,r3
8112996c:	9801961e 	bne	r19,zero,81129fc8 <__svfscanf_r+0x137c>
81129970:	633fffc4 	addi	r12,r12,-1
81129974:	00800044 	movi	r2,1
81129978:	1302882e 	bgeu	r2,r12,8112a39c <__svfscanf_r+0x1750>
8112997c:	a8803fcc 	andi	r2,r21,255
81129980:	1080201c 	xori	r2,r2,128
81129984:	10bfe004 	addi	r2,r2,-128
81129988:	113fffc4 	addi	r4,r2,-1
8112998c:	01400184 	movi	r5,6
81129990:	29001136 	bltu	r5,r4,811299d8 <__svfscanf_r+0xd8c>
81129994:	01000084 	movi	r4,2
81129998:	2082900e 	bge	r4,r2,8112a3dc <__svfscanf_r+0x1790>
8112999c:	00c000c4 	movi	r3,3
811299a0:	10c00d26 	beq	r2,r3,811299d8 <__svfscanf_r+0xd8c>
811299a4:	9425c83a 	sub	r18,r18,r16
811299a8:	1827883a 	mov	r19,r3
811299ac:	843fffc4 	addi	r16,r16,-1
811299b0:	81400007 	ldb	r5,0(r16)
811299b4:	e00d883a 	mov	r6,fp
811299b8:	b009883a 	mov	r4,r22
811299bc:	11328a40 	call	811328a4 <_ungetc_r>
811299c0:	a8bfffc4 	addi	r2,r21,-1
811299c4:	10c03fcc 	andi	r3,r2,255
811299c8:	8493883a 	add	r9,r16,r18
811299cc:	102b883a 	mov	r21,r2
811299d0:	98fff636 	bltu	r19,r3,811299ac <__reset+0xfb1099ac>
811299d4:	4825883a 	mov	r18,r9
811299d8:	a080400c 	andi	r2,r20,256
811299dc:	10001426 	beq	r2,zero,81129a30 <__svfscanf_r+0xde4>
811299e0:	a081000c 	andi	r2,r20,1024
811299e4:	1002571e 	bne	r2,zero,8112a344 <__svfscanf_r+0x16f8>
811299e8:	817fffc7 	ldb	r5,-1(r16)
811299ec:	00801944 	movi	r2,101
811299f0:	84ffffc4 	addi	r19,r16,-1
811299f4:	957fffc4 	addi	r21,r18,-1
811299f8:	28800826 	beq	r5,r2,81129a1c <__svfscanf_r+0xdd0>
811299fc:	00801144 	movi	r2,69
81129a00:	28800626 	beq	r5,r2,81129a1c <__svfscanf_r+0xdd0>
81129a04:	e00d883a 	mov	r6,fp
81129a08:	b009883a 	mov	r4,r22
81129a0c:	11328a40 	call	811328a4 <_ungetc_r>
81129a10:	817fff87 	ldb	r5,-2(r16)
81129a14:	84ffff84 	addi	r19,r16,-2
81129a18:	957fff84 	addi	r21,r18,-2
81129a1c:	e00d883a 	mov	r6,fp
81129a20:	b009883a 	mov	r4,r22
81129a24:	11328a40 	call	811328a4 <_ungetc_r>
81129a28:	a825883a 	mov	r18,r21
81129a2c:	9821883a 	mov	r16,r19
81129a30:	a080040c 	andi	r2,r20,16
81129a34:	103e891e 	bne	r2,zero,8112945c <__reset+0xfb10945c>
81129a38:	80000005 	stb	zero,0(r16)
81129a3c:	a081800c 	andi	r2,r20,1536
81129a40:	01010004 	movi	r4,1024
81129a44:	1101dd26 	beq	r2,r4,8112a1bc <__svfscanf_r+0x1570>
81129a48:	da00a417 	ldw	r8,656(sp)
81129a4c:	4001e71e 	bne	r8,zero,8112a1ec <__svfscanf_r+0x15a0>
81129a50:	000d883a 	mov	r6,zero
81129a54:	d9400104 	addi	r5,sp,4
81129a58:	b009883a 	mov	r4,r22
81129a5c:	112f4540 	call	8112f454 <_strtod_r>
81129a60:	1021883a 	mov	r16,r2
81129a64:	a080004c 	andi	r2,r20,1
81129a68:	1000021e 	bne	r2,zero,81129a74 <__svfscanf_r+0xe28>
81129a6c:	a2c0008c 	andi	r11,r20,2
81129a70:	5801e826 	beq	r11,zero,8112a214 <__svfscanf_r+0x15c8>
81129a74:	da009c17 	ldw	r8,624(sp)
81129a78:	40800017 	ldw	r2,0(r8)
81129a7c:	42000104 	addi	r8,r8,4
81129a80:	da009c15 	stw	r8,624(sp)
81129a84:	14000015 	stw	r16,0(r2)
81129a88:	10c00115 	stw	r3,4(r2)
81129a8c:	da00a017 	ldw	r8,640(sp)
81129a90:	dd009d17 	ldw	r20,628(sp)
81129a94:	42000044 	addi	r8,r8,1
81129a98:	da00a015 	stw	r8,640(sp)
81129a9c:	a00d883a 	mov	r6,r20
81129aa0:	003ca806 	br	81128d44 <__reset+0xfb108d44>
81129aa4:	a080400c 	andi	r2,r20,256
81129aa8:	103f9a26 	beq	r2,zero,81129914 <__reset+0xfb109914>
81129aac:	da00a217 	ldw	r8,648(sp)
81129ab0:	00bfdfc4 	movi	r2,-129
81129ab4:	a0a8703a 	and	r20,r20,r2
81129ab8:	9cc00044 	addi	r19,r19,1
81129abc:	403f9e26 	beq	r8,zero,81129938 <__reset+0xfb109938>
81129ac0:	423fffc4 	addi	r8,r8,-1
81129ac4:	da00a215 	stw	r8,648(sp)
81129ac8:	84000044 	addi	r16,r16,1
81129acc:	003f9a06 	br	81129938 <__reset+0xfb109938>
81129ad0:	a080200c 	andi	r2,r20,128
81129ad4:	103fa126 	beq	r2,zero,8112995c <__reset+0xfb10995c>
81129ad8:	00bfdfc4 	movi	r2,-129
81129adc:	a0a8703a 	and	r20,r20,r2
81129ae0:	003f9306 	br	81129930 <__reset+0xfb109930>
81129ae4:	a8803fcc 	andi	r2,r21,255
81129ae8:	1080201c 	xori	r2,r2,128
81129aec:	10bfe004 	addi	r2,r2,-128
81129af0:	020001c4 	movi	r8,7
81129af4:	123f991e 	bne	r2,r8,8112995c <__reset+0xfb10995c>
81129af8:	05400204 	movi	r21,8
81129afc:	003f8c06 	br	81129930 <__reset+0xfb109930>
81129b00:	a8803fcc 	andi	r2,r21,255
81129b04:	1080201c 	xori	r2,r2,128
81129b08:	10bfe004 	addi	r2,r2,-128
81129b0c:	01800184 	movi	r6,6
81129b10:	11bf921e 	bne	r2,r6,8112995c <__reset+0xfb10995c>
81129b14:	054001c4 	movi	r21,7
81129b18:	003f8506 	br	81129930 <__reset+0xfb109930>
81129b1c:	b000491e 	bne	r22,zero,81129c44 <__svfscanf_r+0xff8>
81129b20:	9800031e 	bne	r19,zero,81129b30 <__svfscanf_r+0xee4>
81129b24:	a081c00c 	andi	r2,r20,1792
81129b28:	0181c004 	movi	r6,1792
81129b2c:	11819f26 	beq	r2,r6,8112a1ac <__svfscanf_r+0x1560>
81129b30:	a8803fcc 	andi	r2,r21,255
81129b34:	1080201c 	xori	r2,r2,128
81129b38:	10bfe004 	addi	r2,r2,-128
81129b3c:	01800044 	movi	r6,1
81129b40:	11800226 	beq	r2,r6,81129b4c <__svfscanf_r+0xf00>
81129b44:	01800104 	movi	r6,4
81129b48:	11bf841e 	bne	r2,r6,8112995c <__reset+0xfb10995c>
81129b4c:	ad400044 	addi	r21,r21,1
81129b50:	003f7706 	br	81129930 <__reset+0xfb109930>
81129b54:	a8803fcc 	andi	r2,r21,255
81129b58:	1080201c 	xori	r2,r2,128
81129b5c:	10bfe004 	addi	r2,r2,-128
81129b60:	10003c1e 	bne	r2,zero,81129c54 <__svfscanf_r+0x1008>
81129b64:	9801141e 	bne	r19,zero,81129fb8 <__svfscanf_r+0x136c>
81129b68:	a081c00c 	andi	r2,r20,1792
81129b6c:	0181c004 	movi	r6,1792
81129b70:	11818226 	beq	r2,r6,8112a17c <__svfscanf_r+0x1530>
81129b74:	8821883a 	mov	r16,r17
81129b78:	b019883a 	mov	r12,r22
81129b7c:	9823883a 	mov	r17,r19
81129b80:	182d883a 	mov	r22,r3
81129b84:	003f7a06 	br	81129970 <__reset+0xfb109970>
81129b88:	a8803fcc 	andi	r2,r21,255
81129b8c:	1080201c 	xori	r2,r2,128
81129b90:	10bfe004 	addi	r2,r2,-128
81129b94:	01800084 	movi	r6,2
81129b98:	11bf701e 	bne	r2,r6,8112995c <__reset+0xfb10995c>
81129b9c:	054000c4 	movi	r21,3
81129ba0:	003f6306 	br	81129930 <__reset+0xfb109930>
81129ba4:	a081400c 	andi	r2,r20,1280
81129ba8:	01810004 	movi	r6,1024
81129bac:	11800326 	beq	r2,r6,81129bbc <__svfscanf_r+0xf70>
81129bb0:	a184703a 	and	r2,r20,r6
81129bb4:	103f6926 	beq	r2,zero,8112995c <__reset+0xfb10995c>
81129bb8:	983fee26 	beq	r19,zero,81129b74 <__reset+0xfb109b74>
81129bbc:	a080800c 	andi	r2,r20,512
81129bc0:	1000041e 	bne	r2,zero,81129bd4 <__svfscanf_r+0xf88>
81129bc4:	da009f17 	ldw	r8,636(sp)
81129bc8:	dc40a515 	stw	r17,660(sp)
81129bcc:	9a27c83a 	sub	r19,r19,r8
81129bd0:	dcc0a415 	stw	r19,656(sp)
81129bd4:	00be1fc4 	movi	r2,-1921
81129bd8:	a0a8703a 	and	r20,r20,r2
81129bdc:	a5006014 	ori	r20,r20,384
81129be0:	0027883a 	mov	r19,zero
81129be4:	003f5206 	br	81129930 <__reset+0xfb109930>
81129be8:	00800044 	movi	r2,1
81129bec:	b0bf5b1e 	bne	r22,r2,8112995c <__reset+0xfb10995c>
81129bf0:	05800084 	movi	r22,2
81129bf4:	003f4e06 	br	81129930 <__reset+0xfb109930>
81129bf8:	d980a317 	ldw	r6,652(sp)
81129bfc:	30800003 	ldbu	r2,0(r6)
81129c00:	29803fcc 	andi	r6,r5,255
81129c04:	30bf551e 	bne	r6,r2,8112995c <__reset+0xfb10995c>
81129c08:	a080800c 	andi	r2,r20,512
81129c0c:	103f5326 	beq	r2,zero,8112995c <__reset+0xfb10995c>
81129c10:	023f5fc4 	movi	r8,-641
81129c14:	a228703a 	and	r20,r20,r8
81129c18:	dcc09f15 	stw	r19,636(sp)
81129c1c:	003f4406 	br	81129930 <__reset+0xfb109930>
81129c20:	1809883a 	mov	r4,r3
81129c24:	e00b883a 	mov	r5,fp
81129c28:	d8c0a615 	stw	r3,664(sp)
81129c2c:	d9c0aa15 	stw	r7,680(sp)
81129c30:	1123f2c0 	call	81123f2c <__srefill_r>
81129c34:	d8c0a617 	ldw	r3,664(sp)
81129c38:	d9c0aa17 	ldw	r7,680(sp)
81129c3c:	103f4626 	beq	r2,zero,81129958 <__reset+0xfb109958>
81129c40:	003f4606 	br	8112995c <__reset+0xfb10995c>
81129c44:	00800084 	movi	r2,2
81129c48:	b0bfb91e 	bne	r22,r2,81129b30 <__reset+0xfb109b30>
81129c4c:	058000c4 	movi	r22,3
81129c50:	003f3706 	br	81129930 <__reset+0xfb109930>
81129c54:	018000c4 	movi	r6,3
81129c58:	11bfbc26 	beq	r2,r6,81129b4c <__reset+0xfb109b4c>
81129c5c:	01800144 	movi	r6,5
81129c60:	11bfba26 	beq	r2,r6,81129b4c <__reset+0xfb109b4c>
81129c64:	003f3d06 	br	8112995c <__reset+0xfb10995c>
81129c68:	98bfffc4 	addi	r2,r19,-1
81129c6c:	01405704 	movi	r5,348
81129c70:	2880d82e 	bgeu	r5,r2,81129fd4 <__svfscanf_r+0x1388>
81129c74:	99ffa8c4 	addi	r7,r19,-349
81129c78:	04c05744 	movi	r19,349
81129c7c:	8c436014 	ori	r17,r17,3456
81129c80:	9013883a 	mov	r9,r18
81129c84:	8825883a 	mov	r18,r17
81129c88:	dc409e17 	ldw	r17,632(sp)
81129c8c:	0029883a 	mov	r20,zero
81129c90:	dc000104 	addi	r16,sp,4
81129c94:	05401344 	movi	r21,77
81129c98:	02c08004 	movi	r11,512
81129c9c:	01bf7fc4 	movi	r6,-513
81129ca0:	023fdfc4 	movi	r8,-129
81129ca4:	20bff544 	addi	r2,r4,-43
81129ca8:	10803fcc 	andi	r2,r2,255
81129cac:	a8807236 	bltu	r21,r2,81129e78 <__svfscanf_r+0x122c>
81129cb0:	100490ba 	slli	r2,r2,2
81129cb4:	016044f4 	movhi	r5,33043
81129cb8:	29673204 	addi	r5,r5,-25400
81129cbc:	1145883a 	add	r2,r2,r5
81129cc0:	10800017 	ldw	r2,0(r2)
81129cc4:	1000683a 	jmp	r2
81129cc8:	81129efc 	xorhi	r4,r16,19067
81129ccc:	81129e78 	rdprs	r4,r16,19065
81129cd0:	81129efc 	xorhi	r4,r16,19067
81129cd4:	81129e78 	rdprs	r4,r16,19065
81129cd8:	81129e78 	rdprs	r4,r16,19065
81129cdc:	81129ed4 	ori	r4,r16,19067
81129ce0:	81129eb4 	orhi	r4,r16,19066
81129ce4:	81129eb4 	orhi	r4,r16,19066
81129ce8:	81129eb4 	orhi	r4,r16,19066
81129cec:	81129eb4 	orhi	r4,r16,19066
81129cf0:	81129eb4 	orhi	r4,r16,19066
81129cf4:	81129eb4 	orhi	r4,r16,19066
81129cf8:	81129eb4 	orhi	r4,r16,19066
81129cfc:	81129e5c 	xori	r4,r16,19065
81129d00:	81129e5c 	xori	r4,r16,19065
81129d04:	81129e78 	rdprs	r4,r16,19065
81129d08:	81129e78 	rdprs	r4,r16,19065
81129d0c:	81129e78 	rdprs	r4,r16,19065
81129d10:	81129e78 	rdprs	r4,r16,19065
81129d14:	81129e78 	rdprs	r4,r16,19065
81129d18:	81129e78 	rdprs	r4,r16,19065
81129d1c:	81129e78 	rdprs	r4,r16,19065
81129d20:	81129e48 	cmpgei	r4,r16,19065
81129d24:	81129e48 	cmpgei	r4,r16,19065
81129d28:	81129e48 	cmpgei	r4,r16,19065
81129d2c:	81129e48 	cmpgei	r4,r16,19065
81129d30:	81129e48 	cmpgei	r4,r16,19065
81129d34:	81129e48 	cmpgei	r4,r16,19065
81129d38:	81129e78 	rdprs	r4,r16,19065
81129d3c:	81129e78 	rdprs	r4,r16,19065
81129d40:	81129e78 	rdprs	r4,r16,19065
81129d44:	81129e78 	rdprs	r4,r16,19065
81129d48:	81129e78 	rdprs	r4,r16,19065
81129d4c:	81129e78 	rdprs	r4,r16,19065
81129d50:	81129e78 	rdprs	r4,r16,19065
81129d54:	81129e78 	rdprs	r4,r16,19065
81129d58:	81129e78 	rdprs	r4,r16,19065
81129d5c:	81129e78 	rdprs	r4,r16,19065
81129d60:	81129e78 	rdprs	r4,r16,19065
81129d64:	81129e78 	rdprs	r4,r16,19065
81129d68:	81129e78 	rdprs	r4,r16,19065
81129d6c:	81129e78 	rdprs	r4,r16,19065
81129d70:	81129e78 	rdprs	r4,r16,19065
81129d74:	81129e78 	rdprs	r4,r16,19065
81129d78:	81129e78 	rdprs	r4,r16,19065
81129d7c:	81129e00 	call	881129e0 <__reset+0x20f29e0>
81129d80:	81129e78 	rdprs	r4,r16,19065
81129d84:	81129e78 	rdprs	r4,r16,19065
81129d88:	81129e78 	rdprs	r4,r16,19065
81129d8c:	81129e78 	rdprs	r4,r16,19065
81129d90:	81129e78 	rdprs	r4,r16,19065
81129d94:	81129e78 	rdprs	r4,r16,19065
81129d98:	81129e78 	rdprs	r4,r16,19065
81129d9c:	81129e78 	rdprs	r4,r16,19065
81129da0:	81129e48 	cmpgei	r4,r16,19065
81129da4:	81129e48 	cmpgei	r4,r16,19065
81129da8:	81129e48 	cmpgei	r4,r16,19065
81129dac:	81129e48 	cmpgei	r4,r16,19065
81129db0:	81129e48 	cmpgei	r4,r16,19065
81129db4:	81129e48 	cmpgei	r4,r16,19065
81129db8:	81129e78 	rdprs	r4,r16,19065
81129dbc:	81129e78 	rdprs	r4,r16,19065
81129dc0:	81129e78 	rdprs	r4,r16,19065
81129dc4:	81129e78 	rdprs	r4,r16,19065
81129dc8:	81129e78 	rdprs	r4,r16,19065
81129dcc:	81129e78 	rdprs	r4,r16,19065
81129dd0:	81129e78 	rdprs	r4,r16,19065
81129dd4:	81129e78 	rdprs	r4,r16,19065
81129dd8:	81129e78 	rdprs	r4,r16,19065
81129ddc:	81129e78 	rdprs	r4,r16,19065
81129de0:	81129e78 	rdprs	r4,r16,19065
81129de4:	81129e78 	rdprs	r4,r16,19065
81129de8:	81129e78 	rdprs	r4,r16,19065
81129dec:	81129e78 	rdprs	r4,r16,19065
81129df0:	81129e78 	rdprs	r4,r16,19065
81129df4:	81129e78 	rdprs	r4,r16,19065
81129df8:	81129e78 	rdprs	r4,r16,19065
81129dfc:	81129e00 	call	881129e0 <__reset+0x20f29e0>
81129e00:	9081800c 	andi	r2,r18,1536
81129e04:	12c01c1e 	bne	r2,r11,81129e78 <__svfscanf_r+0x122c>
81129e08:	91a4703a 	and	r18,r18,r6
81129e0c:	94814014 	ori	r18,r18,1280
81129e10:	04400404 	movi	r17,16
81129e14:	81000005 	stb	r4,0(r16)
81129e18:	84000044 	addi	r16,r16,1
81129e1c:	e0800117 	ldw	r2,4(fp)
81129e20:	10bfffc4 	addi	r2,r2,-1
81129e24:	e0800115 	stw	r2,4(fp)
81129e28:	0080540e 	bge	zero,r2,81129f7c <__svfscanf_r+0x1330>
81129e2c:	18c00044 	addi	r3,r3,1
81129e30:	e0c00015 	stw	r3,0(fp)
81129e34:	9cffffc4 	addi	r19,r19,-1
81129e38:	98000f26 	beq	r19,zero,81129e78 <__svfscanf_r+0x122c>
81129e3c:	e0c00017 	ldw	r3,0(fp)
81129e40:	19000003 	ldbu	r4,0(r3)
81129e44:	003f9706 	br	81129ca4 <__reset+0xfb109ca4>
81129e48:	00800284 	movi	r2,10
81129e4c:	14400a0e 	bge	r2,r17,81129e78 <__svfscanf_r+0x122c>
81129e50:	00bd1fc4 	movi	r2,-2945
81129e54:	90a4703a 	and	r18,r18,r2
81129e58:	003fee06 	br	81129e14 <__reset+0xfb109e14>
81129e5c:	01604574 	movhi	r5,33045
81129e60:	8c63883a 	add	r17,r17,r17
81129e64:	29473b84 	addi	r5,r5,7406
81129e68:	2c45883a 	add	r2,r5,r17
81129e6c:	1440000f 	ldh	r17,0(r2)
81129e70:	00800204 	movi	r2,8
81129e74:	147ff616 	blt	r2,r17,81129e50 <__reset+0xfb109e50>
81129e78:	dc409e15 	stw	r17,632(sp)
81129e7c:	9023883a 	mov	r17,r18
81129e80:	8880400c 	andi	r2,r17,256
81129e84:	4825883a 	mov	r18,r9
81129e88:	10000426 	beq	r2,zero,81129e9c <__svfscanf_r+0x1250>
81129e8c:	d9800104 	addi	r6,sp,4
81129e90:	3400be36 	bltu	r6,r16,8112a18c <__svfscanf_r+0x1540>
81129e94:	da000104 	addi	r8,sp,4
81129e98:	443bae26 	beq	r8,r16,81128d54 <__reset+0xfb108d54>
81129e9c:	8880040c 	andi	r2,r17,16
81129ea0:	10009326 	beq	r2,zero,8112a0f0 <__svfscanf_r+0x14a4>
81129ea4:	d8800104 	addi	r2,sp,4
81129ea8:	80a1c83a 	sub	r16,r16,r2
81129eac:	8521883a 	add	r16,r16,r20
81129eb0:	003d0606 	br	811292cc <__reset+0xfb1092cc>
81129eb4:	01604574 	movhi	r5,33045
81129eb8:	8c63883a 	add	r17,r17,r17
81129ebc:	29473b84 	addi	r5,r5,7406
81129ec0:	2c45883a 	add	r2,r5,r17
81129ec4:	1440000f 	ldh	r17,0(r2)
81129ec8:	00bd1fc4 	movi	r2,-2945
81129ecc:	90a4703a 	and	r18,r18,r2
81129ed0:	003fd006 	br	81129e14 <__reset+0xfb109e14>
81129ed4:	9082000c 	andi	r2,r18,2048
81129ed8:	103fce26 	beq	r2,zero,81129e14 <__reset+0xfb109e14>
81129edc:	8800021e 	bne	r17,zero,81129ee8 <__svfscanf_r+0x129c>
81129ee0:	94808014 	ori	r18,r18,512
81129ee4:	04400204 	movi	r17,8
81129ee8:	9081000c 	andi	r2,r18,1024
81129eec:	10009426 	beq	r2,zero,8112a140 <__svfscanf_r+0x14f4>
81129ef0:	00be9fc4 	movi	r2,-1409
81129ef4:	90a4703a 	and	r18,r18,r2
81129ef8:	003fc606 	br	81129e14 <__reset+0xfb109e14>
81129efc:	9080200c 	andi	r2,r18,128
81129f00:	103fdd26 	beq	r2,zero,81129e78 <__reset+0xfb109e78>
81129f04:	9224703a 	and	r18,r18,r8
81129f08:	003fc206 	br	81129e14 <__reset+0xfb109e14>
81129f0c:	9800011e 	bne	r19,zero,81129f14 <__svfscanf_r+0x12c8>
81129f10:	04ffffc4 	movi	r19,-1
81129f14:	8900004c 	andi	r4,r17,1
81129f18:	20005b1e 	bne	r4,zero,8112a088 <__svfscanf_r+0x143c>
81129f1c:	8c40040c 	andi	r17,r17,16
81129f20:	88003026 	beq	r17,zero,81129fe4 <__svfscanf_r+0x1398>
81129f24:	0021883a 	mov	r16,zero
81129f28:	00000306 	br	81129f38 <__svfscanf_r+0x12ec>
81129f2c:	18800003 	ldbu	r2,0(r3)
81129f30:	3885883a 	add	r2,r7,r2
81129f34:	10800043 	ldbu	r2,1(r2)
81129f38:	1080020c 	andi	r2,r2,8
81129f3c:	103ce31e 	bne	r2,zero,811292cc <__reset+0xfb1092cc>
81129f40:	e0800117 	ldw	r2,4(fp)
81129f44:	18c00044 	addi	r3,r3,1
81129f48:	84000044 	addi	r16,r16,1
81129f4c:	10bfffc4 	addi	r2,r2,-1
81129f50:	e0800115 	stw	r2,4(fp)
81129f54:	e0c00015 	stw	r3,0(fp)
81129f58:	84fcdc26 	beq	r16,r19,811292cc <__reset+0xfb1092cc>
81129f5c:	00bff316 	blt	zero,r2,81129f2c <__reset+0xfb109f2c>
81129f60:	e00b883a 	mov	r5,fp
81129f64:	b009883a 	mov	r4,r22
81129f68:	1123f2c0 	call	81123f2c <__srefill_r>
81129f6c:	103cd71e 	bne	r2,zero,811292cc <__reset+0xfb1092cc>
81129f70:	b9c00017 	ldw	r7,0(r23)
81129f74:	e0c00017 	ldw	r3,0(fp)
81129f78:	003fec06 	br	81129f2c <__reset+0xfb109f2c>
81129f7c:	e00b883a 	mov	r5,fp
81129f80:	b009883a 	mov	r4,r22
81129f84:	d980a715 	stw	r6,668(sp)
81129f88:	d9c0aa15 	stw	r7,680(sp)
81129f8c:	da00a815 	stw	r8,672(sp)
81129f90:	da40a915 	stw	r9,676(sp)
81129f94:	dac0a615 	stw	r11,664(sp)
81129f98:	1123f2c0 	call	81123f2c <__srefill_r>
81129f9c:	d980a717 	ldw	r6,668(sp)
81129fa0:	d9c0aa17 	ldw	r7,680(sp)
81129fa4:	da00a817 	ldw	r8,672(sp)
81129fa8:	da40a917 	ldw	r9,676(sp)
81129fac:	dac0a617 	ldw	r11,664(sp)
81129fb0:	103fa026 	beq	r2,zero,81129e34 <__reset+0xfb109e34>
81129fb4:	003fb006 	br	81129e78 <__reset+0xfb109e78>
81129fb8:	8821883a 	mov	r16,r17
81129fbc:	b019883a 	mov	r12,r22
81129fc0:	9823883a 	mov	r17,r19
81129fc4:	182d883a 	mov	r22,r3
81129fc8:	00bfbfc4 	movi	r2,-257
81129fcc:	a0a8703a 	and	r20,r20,r2
81129fd0:	003e6706 	br	81129970 <__reset+0xfb109970>
81129fd4:	000f883a 	mov	r7,zero
81129fd8:	003f2806 	br	81129c7c <__reset+0xfb109c7c>
81129fdc:	d800a215 	stw	zero,648(sp)
81129fe0:	003de306 	br	81129770 <__reset+0xfb109770>
81129fe4:	da009c17 	ldw	r8,624(sp)
81129fe8:	9abfffc4 	addi	r10,r19,-1
81129fec:	44400017 	ldw	r17,0(r8)
81129ff0:	44000104 	addi	r16,r8,4
81129ff4:	880b883a 	mov	r5,r17
81129ff8:	8aa9883a 	add	r20,r17,r10
81129ffc:	00000606 	br	8112a018 <__svfscanf_r+0x13cc>
8112a000:	e0c00017 	ldw	r3,0(fp)
8112a004:	b9000017 	ldw	r4,0(r23)
8112a008:	a80b883a 	mov	r5,r21
8112a00c:	18800003 	ldbu	r2,0(r3)
8112a010:	2085883a 	add	r2,r4,r2
8112a014:	10800043 	ldbu	r2,1(r2)
8112a018:	1080020c 	andi	r2,r2,8
8112a01c:	1000551e 	bne	r2,zero,8112a174 <__svfscanf_r+0x1528>
8112a020:	e0800117 	ldw	r2,4(fp)
8112a024:	19000044 	addi	r4,r3,1
8112a028:	e1000015 	stw	r4,0(fp)
8112a02c:	10bfffc4 	addi	r2,r2,-1
8112a030:	e0800115 	stw	r2,4(fp)
8112a034:	18800003 	ldbu	r2,0(r3)
8112a038:	2d400044 	addi	r21,r5,1
8112a03c:	a827883a 	mov	r19,r21
8112a040:	28800005 	stb	r2,0(r5)
8112a044:	2d000626 	beq	r5,r20,8112a060 <__svfscanf_r+0x1414>
8112a048:	e0800117 	ldw	r2,4(fp)
8112a04c:	00bfec16 	blt	zero,r2,8112a000 <__reset+0xfb10a000>
8112a050:	e00b883a 	mov	r5,fp
8112a054:	b009883a 	mov	r4,r22
8112a058:	1123f2c0 	call	81123f2c <__srefill_r>
8112a05c:	103fe826 	beq	r2,zero,8112a000 <__reset+0xfb10a000>
8112a060:	da00a017 	ldw	r8,640(sp)
8112a064:	dd009d17 	ldw	r20,628(sp)
8112a068:	9c63c83a 	sub	r17,r19,r17
8112a06c:	42000044 	addi	r8,r8,1
8112a070:	98000005 	stb	zero,0(r19)
8112a074:	9465883a 	add	r18,r18,r17
8112a078:	da00a015 	stw	r8,640(sp)
8112a07c:	dc009c15 	stw	r16,624(sp)
8112a080:	a00d883a 	mov	r6,r20
8112a084:	003b2f06 	br	81128d44 <__reset+0xfb108d44>
8112a088:	dd409904 	addi	r21,sp,612
8112a08c:	8c40040c 	andi	r17,r17,16
8112a090:	01800204 	movi	r6,8
8112a094:	000b883a 	mov	r5,zero
8112a098:	a809883a 	mov	r4,r21
8112a09c:	1123b2c0 	call	81123b2c <memset>
8112a0a0:	8800401e 	bne	r17,zero,8112a1a4 <__svfscanf_r+0x1558>
8112a0a4:	da009c17 	ldw	r8,624(sp)
8112a0a8:	45000017 	ldw	r20,0(r8)
8112a0ac:	42000104 	addi	r8,r8,4
8112a0b0:	da009c15 	stw	r8,624(sp)
8112a0b4:	000d883a 	mov	r6,zero
8112a0b8:	3021883a 	mov	r16,r6
8112a0bc:	dc409f15 	stw	r17,636(sp)
8112a0c0:	e0800017 	ldw	r2,0(fp)
8112a0c4:	b8c00017 	ldw	r3,0(r23)
8112a0c8:	10800003 	ldbu	r2,0(r2)
8112a0cc:	1885883a 	add	r2,r3,r2
8112a0d0:	10800043 	ldbu	r2,1(r2)
8112a0d4:	1080020c 	andi	r2,r2,8
8112a0d8:	1000011e 	bne	r2,zero,8112a0e0 <__svfscanf_r+0x1494>
8112a0dc:	9800701e 	bne	r19,zero,8112a2a0 <__svfscanf_r+0x1654>
8112a0e0:	dc409f17 	ldw	r17,636(sp)
8112a0e4:	883cdd1e 	bne	r17,zero,8112945c <__reset+0xfb10945c>
8112a0e8:	a0000015 	stw	zero,0(r20)
8112a0ec:	003cd806 	br	81129450 <__reset+0xfb109450>
8112a0f0:	d9c09e17 	ldw	r7,632(sp)
8112a0f4:	da00a117 	ldw	r8,644(sp)
8112a0f8:	000d883a 	mov	r6,zero
8112a0fc:	d9400104 	addi	r5,sp,4
8112a100:	b009883a 	mov	r4,r22
8112a104:	80000005 	stb	zero,0(r16)
8112a108:	403ee83a 	callr	r8
8112a10c:	88c0080c 	andi	r3,r17,32
8112a110:	1800121e 	bne	r3,zero,8112a15c <__svfscanf_r+0x1510>
8112a114:	88c0010c 	andi	r3,r17,4
8112a118:	18004d26 	beq	r3,zero,8112a250 <__svfscanf_r+0x1604>
8112a11c:	da009c17 	ldw	r8,624(sp)
8112a120:	40c00017 	ldw	r3,0(r8)
8112a124:	42000104 	addi	r8,r8,4
8112a128:	da009c15 	stw	r8,624(sp)
8112a12c:	1880000d 	sth	r2,0(r3)
8112a130:	da00a017 	ldw	r8,640(sp)
8112a134:	42000044 	addi	r8,r8,1
8112a138:	da00a015 	stw	r8,640(sp)
8112a13c:	003f5906 	br	81129ea4 <__reset+0xfb109ea4>
8112a140:	00bf1fc4 	movi	r2,-897
8112a144:	90a4703a 	and	r18,r18,r2
8112a148:	38000226 	beq	r7,zero,8112a154 <__svfscanf_r+0x1508>
8112a14c:	39ffffc4 	addi	r7,r7,-1
8112a150:	9cc00044 	addi	r19,r19,1
8112a154:	a5000044 	addi	r20,r20,1
8112a158:	003f3006 	br	81129e1c <__reset+0xfb109e1c>
8112a15c:	da009c17 	ldw	r8,624(sp)
8112a160:	40c00017 	ldw	r3,0(r8)
8112a164:	42000104 	addi	r8,r8,4
8112a168:	da009c15 	stw	r8,624(sp)
8112a16c:	18800015 	stw	r2,0(r3)
8112a170:	003fef06 	br	8112a130 <__reset+0xfb10a130>
8112a174:	2827883a 	mov	r19,r5
8112a178:	003fb906 	br	8112a060 <__reset+0xfb10a060>
8112a17c:	01be1fc4 	movi	r6,-1921
8112a180:	a1a8703a 	and	r20,r20,r6
8112a184:	05400044 	movi	r21,1
8112a188:	003de906 	br	81129930 <__reset+0xfb109930>
8112a18c:	817fffc7 	ldb	r5,-1(r16)
8112a190:	e00d883a 	mov	r6,fp
8112a194:	b009883a 	mov	r4,r22
8112a198:	843fffc4 	addi	r16,r16,-1
8112a19c:	11328a40 	call	811328a4 <_ungetc_r>
8112a1a0:	003f3c06 	br	81129e94 <__reset+0xfb109e94>
8112a1a4:	dd009b04 	addi	r20,sp,620
8112a1a8:	003fc206 	br	8112a0b4 <__reset+0xfb10a0b4>
8112a1ac:	00be1fc4 	movi	r2,-1921
8112a1b0:	a0a8703a 	and	r20,r20,r2
8112a1b4:	05800044 	movi	r22,1
8112a1b8:	003ddd06 	br	81129930 <__reset+0xfb109930>
8112a1bc:	d8c09f17 	ldw	r3,636(sp)
8112a1c0:	88e3c83a 	sub	r17,r17,r3
8112a1c4:	044dc83a 	sub	r6,zero,r17
8112a1c8:	883e2126 	beq	r17,zero,81129a50 <__reset+0xfb109a50>
8112a1cc:	d88055c4 	addi	r2,sp,343
8112a1d0:	80800136 	bltu	r16,r2,8112a1d8 <__svfscanf_r+0x158c>
8112a1d4:	dc005584 	addi	r16,sp,342
8112a1d8:	01604574 	movhi	r5,33045
8112a1dc:	29473a04 	addi	r5,r5,7400
8112a1e0:	8009883a 	mov	r4,r16
8112a1e4:	11242400 	call	81124240 <sprintf>
8112a1e8:	003e1906 	br	81129a50 <__reset+0xfb109a50>
8112a1ec:	d8c0a517 	ldw	r3,660(sp)
8112a1f0:	000d883a 	mov	r6,zero
8112a1f4:	01c00284 	movi	r7,10
8112a1f8:	19400044 	addi	r5,r3,1
8112a1fc:	b009883a 	mov	r4,r22
8112a200:	11245300 	call	81124530 <_strtol_r>
8112a204:	da00a417 	ldw	r8,656(sp)
8112a208:	dc00a517 	ldw	r16,660(sp)
8112a20c:	120dc83a 	sub	r6,r2,r8
8112a210:	003fee06 	br	8112a1cc <__reset+0xfb10a1cc>
8112a214:	da009c17 	ldw	r8,624(sp)
8112a218:	180b883a 	mov	r5,r3
8112a21c:	8009883a 	mov	r4,r16
8112a220:	45000017 	ldw	r20,0(r8)
8112a224:	44400104 	addi	r17,r8,4
8112a228:	d8c0a615 	stw	r3,664(sp)
8112a22c:	112f1c00 	call	8112f1c0 <__fpclassifyd>
8112a230:	d8c0a617 	ldw	r3,664(sp)
8112a234:	10006426 	beq	r2,zero,8112a3c8 <__svfscanf_r+0x177c>
8112a238:	8009883a 	mov	r4,r16
8112a23c:	180b883a 	mov	r5,r3
8112a240:	11225c40 	call	811225c4 <__truncdfsf2>
8112a244:	a0800015 	stw	r2,0(r20)
8112a248:	dc409c15 	stw	r17,624(sp)
8112a24c:	003e0f06 	br	81129a8c <__reset+0xfb109a8c>
8112a250:	88c0004c 	andi	r3,r17,1
8112a254:	183fc11e 	bne	r3,zero,8112a15c <__reset+0xfb10a15c>
8112a258:	8c40008c 	andi	r17,r17,2
8112a25c:	883fbf26 	beq	r17,zero,8112a15c <__reset+0xfb10a15c>
8112a260:	da00a117 	ldw	r8,644(sp)
8112a264:	00a044f4 	movhi	r2,33043
8112a268:	10839704 	addi	r2,r2,3676
8112a26c:	d9c09e17 	ldw	r7,632(sp)
8112a270:	000d883a 	mov	r6,zero
8112a274:	d9400104 	addi	r5,sp,4
8112a278:	b009883a 	mov	r4,r22
8112a27c:	40806226 	beq	r8,r2,8112a408 <__svfscanf_r+0x17bc>
8112a280:	1130b740 	call	81130b74 <_strtoll_r>
8112a284:	da009c17 	ldw	r8,624(sp)
8112a288:	41000017 	ldw	r4,0(r8)
8112a28c:	42000104 	addi	r8,r8,4
8112a290:	da009c15 	stw	r8,624(sp)
8112a294:	20800015 	stw	r2,0(r4)
8112a298:	20c00115 	stw	r3,4(r4)
8112a29c:	003fa406 	br	8112a130 <__reset+0xfb10a130>
8112a2a0:	112d6500 	call	8112d650 <__locale_mb_cur_max>
8112a2a4:	80bca726 	beq	r16,r2,81129544 <__reset+0xfb109544>
8112a2a8:	e0800017 	ldw	r2,0(fp)
8112a2ac:	e1000117 	ldw	r4,4(fp)
8112a2b0:	d8c00104 	addi	r3,sp,4
8112a2b4:	12000003 	ldbu	r8,0(r2)
8112a2b8:	213fffc4 	addi	r4,r4,-1
8112a2bc:	10800044 	addi	r2,r2,1
8112a2c0:	e1000115 	stw	r4,4(fp)
8112a2c4:	e0800015 	stw	r2,0(fp)
8112a2c8:	84400044 	addi	r17,r16,1
8112a2cc:	dd400015 	stw	r21,0(sp)
8112a2d0:	1c21883a 	add	r16,r3,r16
8112a2d4:	b009883a 	mov	r4,r22
8112a2d8:	880f883a 	mov	r7,r17
8112a2dc:	180d883a 	mov	r6,r3
8112a2e0:	a00b883a 	mov	r5,r20
8112a2e4:	82000005 	stb	r8,0(r16)
8112a2e8:	112d70c0 	call	8112d70c <_mbrtowc_r>
8112a2ec:	013fffc4 	movi	r4,-1
8112a2f0:	113c9426 	beq	r2,r4,81129544 <__reset+0xfb109544>
8112a2f4:	103c881e 	bne	r2,zero,81129518 <__reset+0xfb109518>
8112a2f8:	a0000015 	stw	zero,0(r20)
8112a2fc:	0009883a 	mov	r4,zero
8112a300:	112d5900 	call	8112d590 <iswspace>
8112a304:	10001a26 	beq	r2,zero,8112a370 <__svfscanf_r+0x1724>
8112a308:	8821883a 	mov	r16,r17
8112a30c:	dc409f17 	ldw	r17,636(sp)
8112a310:	803f7426 	beq	r16,zero,8112a0e4 <__reset+0xfb10a0e4>
8112a314:	843fffc4 	addi	r16,r16,-1
8112a318:	d9800104 	addi	r6,sp,4
8112a31c:	342b883a 	add	r21,r6,r16
8112a320:	00000106 	br	8112a328 <__svfscanf_r+0x16dc>
8112a324:	843fffc4 	addi	r16,r16,-1
8112a328:	a9400003 	ldbu	r5,0(r21)
8112a32c:	e00d883a 	mov	r6,fp
8112a330:	b009883a 	mov	r4,r22
8112a334:	11328a40 	call	811328a4 <_ungetc_r>
8112a338:	ad7fffc4 	addi	r21,r21,-1
8112a33c:	803ff91e 	bne	r16,zero,8112a324 <__reset+0xfb10a324>
8112a340:	003f6806 	br	8112a0e4 <__reset+0xfb10a0e4>
8112a344:	d9800104 	addi	r6,sp,4
8112a348:	802b883a 	mov	r21,r16
8112a34c:	343a812e 	bgeu	r6,r16,81128d54 <__reset+0xfb108d54>
8112a350:	ad7fffc4 	addi	r21,r21,-1
8112a354:	a9400007 	ldb	r5,0(r21)
8112a358:	e00d883a 	mov	r6,fp
8112a35c:	b009883a 	mov	r4,r22
8112a360:	11328a40 	call	811328a4 <_ungetc_r>
8112a364:	da000104 	addi	r8,sp,4
8112a368:	457ff91e 	bne	r8,r21,8112a350 <__reset+0xfb10a350>
8112a36c:	003a7906 	br	81128d54 <__reset+0xfb108d54>
8112a370:	da009f17 	ldw	r8,636(sp)
8112a374:	9465883a 	add	r18,r18,r17
8112a378:	9cffffc4 	addi	r19,r19,-1
8112a37c:	4000051e 	bne	r8,zero,8112a394 <__svfscanf_r+0x1748>
8112a380:	a5000104 	addi	r20,r20,4
8112a384:	0021883a 	mov	r16,zero
8112a388:	003c6606 	br	81129524 <__reset+0xfb109524>
8112a38c:	a1000017 	ldw	r4,0(r20)
8112a390:	003fdb06 	br	8112a300 <__reset+0xfb10a300>
8112a394:	0021883a 	mov	r16,zero
8112a398:	003c6206 	br	81129524 <__reset+0xfb109524>
8112a39c:	d8800104 	addi	r2,sp,4
8112a3a0:	802b883a 	mov	r21,r16
8112a3a4:	143a6b2e 	bgeu	r2,r16,81128d54 <__reset+0xfb108d54>
8112a3a8:	ad7fffc4 	addi	r21,r21,-1
8112a3ac:	a9400007 	ldb	r5,0(r21)
8112a3b0:	e00d883a 	mov	r6,fp
8112a3b4:	b009883a 	mov	r4,r22
8112a3b8:	11328a40 	call	811328a4 <_ungetc_r>
8112a3bc:	d8c00104 	addi	r3,sp,4
8112a3c0:	1d7ff91e 	bne	r3,r21,8112a3a8 <__reset+0xfb10a3a8>
8112a3c4:	003a6306 	br	81128d54 <__reset+0xfb108d54>
8112a3c8:	0009883a 	mov	r4,zero
8112a3cc:	112f3040 	call	8112f304 <nanf>
8112a3d0:	a0800015 	stw	r2,0(r20)
8112a3d4:	dc409c15 	stw	r17,624(sp)
8112a3d8:	003dac06 	br	81129a8c <__reset+0xfb109a8c>
8112a3dc:	d9000104 	addi	r4,sp,4
8112a3e0:	802b883a 	mov	r21,r16
8112a3e4:	243a5b2e 	bgeu	r4,r16,81128d54 <__reset+0xfb108d54>
8112a3e8:	ad7fffc4 	addi	r21,r21,-1
8112a3ec:	a9400007 	ldb	r5,0(r21)
8112a3f0:	e00d883a 	mov	r6,fp
8112a3f4:	b009883a 	mov	r4,r22
8112a3f8:	11328a40 	call	811328a4 <_ungetc_r>
8112a3fc:	d9400104 	addi	r5,sp,4
8112a400:	2d7ff91e 	bne	r5,r21,8112a3e8 <__reset+0xfb10a3e8>
8112a404:	003a5306 	br	81128d54 <__reset+0xfb108d54>
8112a408:	11310cc0 	call	811310cc <_strtoull_r>
8112a40c:	003f9d06 	br	8112a284 <__reset+0xfb10a284>

8112a410 <vfscanf>:
8112a410:	00a04574 	movhi	r2,33045
8112a414:	defffb04 	addi	sp,sp,-20
8112a418:	1090f104 	addi	r2,r2,17348
8112a41c:	de00012e 	bgeu	sp,et,8112a424 <vfscanf+0x14>
8112a420:	003b68fa 	trap	3
8112a424:	dc000215 	stw	r16,8(sp)
8112a428:	14000017 	ldw	r16,0(r2)
8112a42c:	dc400315 	stw	r17,12(sp)
8112a430:	dfc00415 	stw	ra,16(sp)
8112a434:	2023883a 	mov	r17,r4
8112a438:	80000826 	beq	r16,zero,8112a45c <vfscanf+0x4c>
8112a43c:	80800e17 	ldw	r2,56(r16)
8112a440:	1000061e 	bne	r2,zero,8112a45c <vfscanf+0x4c>
8112a444:	8009883a 	mov	r4,r16
8112a448:	d9400015 	stw	r5,0(sp)
8112a44c:	d9800115 	stw	r6,4(sp)
8112a450:	112c7280 	call	8112c728 <__sinit>
8112a454:	d9800117 	ldw	r6,4(sp)
8112a458:	d9400017 	ldw	r5,0(sp)
8112a45c:	300f883a 	mov	r7,r6
8112a460:	8009883a 	mov	r4,r16
8112a464:	280d883a 	mov	r6,r5
8112a468:	880b883a 	mov	r5,r17
8112a46c:	dfc00417 	ldw	ra,16(sp)
8112a470:	dc400317 	ldw	r17,12(sp)
8112a474:	dc000217 	ldw	r16,8(sp)
8112a478:	dec00504 	addi	sp,sp,20
8112a47c:	1128c4c1 	jmpi	81128c4c <__svfscanf_r>

8112a480 <__svfscanf>:
8112a480:	00a04574 	movhi	r2,33045
8112a484:	1090f104 	addi	r2,r2,17348
8112a488:	300f883a 	mov	r7,r6
8112a48c:	280d883a 	mov	r6,r5
8112a490:	200b883a 	mov	r5,r4
8112a494:	11000017 	ldw	r4,0(r2)
8112a498:	1128c4c1 	jmpi	81128c4c <__svfscanf_r>

8112a49c <_vfscanf_r>:
8112a49c:	defffb04 	addi	sp,sp,-20
8112a4a0:	de00012e 	bgeu	sp,et,8112a4a8 <_vfscanf_r+0xc>
8112a4a4:	003b68fa 	trap	3
8112a4a8:	dc000315 	stw	r16,12(sp)
8112a4ac:	dfc00415 	stw	ra,16(sp)
8112a4b0:	2021883a 	mov	r16,r4
8112a4b4:	20000926 	beq	r4,zero,8112a4dc <_vfscanf_r+0x40>
8112a4b8:	20800e17 	ldw	r2,56(r4)
8112a4bc:	1000071e 	bne	r2,zero,8112a4dc <_vfscanf_r+0x40>
8112a4c0:	d9400015 	stw	r5,0(sp)
8112a4c4:	d9800115 	stw	r6,4(sp)
8112a4c8:	d9c00215 	stw	r7,8(sp)
8112a4cc:	112c7280 	call	8112c728 <__sinit>
8112a4d0:	d9c00217 	ldw	r7,8(sp)
8112a4d4:	d9800117 	ldw	r6,4(sp)
8112a4d8:	d9400017 	ldw	r5,0(sp)
8112a4dc:	8009883a 	mov	r4,r16
8112a4e0:	dfc00417 	ldw	ra,16(sp)
8112a4e4:	dc000317 	ldw	r16,12(sp)
8112a4e8:	dec00504 	addi	sp,sp,20
8112a4ec:	1128c4c1 	jmpi	81128c4c <__svfscanf_r>

8112a4f0 <__swbuf_r>:
8112a4f0:	defffb04 	addi	sp,sp,-20
8112a4f4:	de00012e 	bgeu	sp,et,8112a4fc <__swbuf_r+0xc>
8112a4f8:	003b68fa 	trap	3
8112a4fc:	dcc00315 	stw	r19,12(sp)
8112a500:	dc800215 	stw	r18,8(sp)
8112a504:	dc000015 	stw	r16,0(sp)
8112a508:	dfc00415 	stw	ra,16(sp)
8112a50c:	dc400115 	stw	r17,4(sp)
8112a510:	2025883a 	mov	r18,r4
8112a514:	2827883a 	mov	r19,r5
8112a518:	3021883a 	mov	r16,r6
8112a51c:	20000226 	beq	r4,zero,8112a528 <__swbuf_r+0x38>
8112a520:	20800e17 	ldw	r2,56(r4)
8112a524:	10004226 	beq	r2,zero,8112a630 <__swbuf_r+0x140>
8112a528:	80800617 	ldw	r2,24(r16)
8112a52c:	8100030b 	ldhu	r4,12(r16)
8112a530:	80800215 	stw	r2,8(r16)
8112a534:	2080020c 	andi	r2,r4,8
8112a538:	10003626 	beq	r2,zero,8112a614 <__swbuf_r+0x124>
8112a53c:	80c00417 	ldw	r3,16(r16)
8112a540:	18003426 	beq	r3,zero,8112a614 <__swbuf_r+0x124>
8112a544:	2088000c 	andi	r2,r4,8192
8112a548:	9c403fcc 	andi	r17,r19,255
8112a54c:	10001a26 	beq	r2,zero,8112a5b8 <__swbuf_r+0xc8>
8112a550:	80800017 	ldw	r2,0(r16)
8112a554:	81000517 	ldw	r4,20(r16)
8112a558:	10c7c83a 	sub	r3,r2,r3
8112a55c:	1900200e 	bge	r3,r4,8112a5e0 <__swbuf_r+0xf0>
8112a560:	18c00044 	addi	r3,r3,1
8112a564:	81000217 	ldw	r4,8(r16)
8112a568:	11400044 	addi	r5,r2,1
8112a56c:	81400015 	stw	r5,0(r16)
8112a570:	213fffc4 	addi	r4,r4,-1
8112a574:	81000215 	stw	r4,8(r16)
8112a578:	14c00005 	stb	r19,0(r2)
8112a57c:	80800517 	ldw	r2,20(r16)
8112a580:	10c01e26 	beq	r2,r3,8112a5fc <__swbuf_r+0x10c>
8112a584:	8080030b 	ldhu	r2,12(r16)
8112a588:	1080004c 	andi	r2,r2,1
8112a58c:	10000226 	beq	r2,zero,8112a598 <__swbuf_r+0xa8>
8112a590:	00800284 	movi	r2,10
8112a594:	88801926 	beq	r17,r2,8112a5fc <__swbuf_r+0x10c>
8112a598:	8805883a 	mov	r2,r17
8112a59c:	dfc00417 	ldw	ra,16(sp)
8112a5a0:	dcc00317 	ldw	r19,12(sp)
8112a5a4:	dc800217 	ldw	r18,8(sp)
8112a5a8:	dc400117 	ldw	r17,4(sp)
8112a5ac:	dc000017 	ldw	r16,0(sp)
8112a5b0:	dec00504 	addi	sp,sp,20
8112a5b4:	f800283a 	ret
8112a5b8:	81401917 	ldw	r5,100(r16)
8112a5bc:	00b7ffc4 	movi	r2,-8193
8112a5c0:	21080014 	ori	r4,r4,8192
8112a5c4:	2884703a 	and	r2,r5,r2
8112a5c8:	80801915 	stw	r2,100(r16)
8112a5cc:	80800017 	ldw	r2,0(r16)
8112a5d0:	8100030d 	sth	r4,12(r16)
8112a5d4:	81000517 	ldw	r4,20(r16)
8112a5d8:	10c7c83a 	sub	r3,r2,r3
8112a5dc:	193fe016 	blt	r3,r4,8112a560 <__reset+0xfb10a560>
8112a5e0:	800b883a 	mov	r5,r16
8112a5e4:	9009883a 	mov	r4,r18
8112a5e8:	112c32c0 	call	8112c32c <_fflush_r>
8112a5ec:	1000071e 	bne	r2,zero,8112a60c <__swbuf_r+0x11c>
8112a5f0:	80800017 	ldw	r2,0(r16)
8112a5f4:	00c00044 	movi	r3,1
8112a5f8:	003fda06 	br	8112a564 <__reset+0xfb10a564>
8112a5fc:	800b883a 	mov	r5,r16
8112a600:	9009883a 	mov	r4,r18
8112a604:	112c32c0 	call	8112c32c <_fflush_r>
8112a608:	103fe326 	beq	r2,zero,8112a598 <__reset+0xfb10a598>
8112a60c:	00bfffc4 	movi	r2,-1
8112a610:	003fe206 	br	8112a59c <__reset+0xfb10a59c>
8112a614:	800b883a 	mov	r5,r16
8112a618:	9009883a 	mov	r4,r18
8112a61c:	112a6b80 	call	8112a6b8 <__swsetup_r>
8112a620:	103ffa1e 	bne	r2,zero,8112a60c <__reset+0xfb10a60c>
8112a624:	8100030b 	ldhu	r4,12(r16)
8112a628:	80c00417 	ldw	r3,16(r16)
8112a62c:	003fc506 	br	8112a544 <__reset+0xfb10a544>
8112a630:	112c7280 	call	8112c728 <__sinit>
8112a634:	003fbc06 	br	8112a528 <__reset+0xfb10a528>

8112a638 <__swbuf>:
8112a638:	00a04574 	movhi	r2,33045
8112a63c:	1090f104 	addi	r2,r2,17348
8112a640:	280d883a 	mov	r6,r5
8112a644:	200b883a 	mov	r5,r4
8112a648:	11000017 	ldw	r4,0(r2)
8112a64c:	112a4f01 	jmpi	8112a4f0 <__swbuf_r>

8112a650 <_write_r>:
8112a650:	defffd04 	addi	sp,sp,-12
8112a654:	de00012e 	bgeu	sp,et,8112a65c <_write_r+0xc>
8112a658:	003b68fa 	trap	3
8112a65c:	2805883a 	mov	r2,r5
8112a660:	dc000015 	stw	r16,0(sp)
8112a664:	04204574 	movhi	r16,33045
8112a668:	dc400115 	stw	r17,4(sp)
8112a66c:	300b883a 	mov	r5,r6
8112a670:	84116404 	addi	r16,r16,17808
8112a674:	2023883a 	mov	r17,r4
8112a678:	380d883a 	mov	r6,r7
8112a67c:	1009883a 	mov	r4,r2
8112a680:	dfc00215 	stw	ra,8(sp)
8112a684:	80000015 	stw	zero,0(r16)
8112a688:	11391480 	call	81139148 <write>
8112a68c:	00ffffc4 	movi	r3,-1
8112a690:	10c00526 	beq	r2,r3,8112a6a8 <_write_r+0x58>
8112a694:	dfc00217 	ldw	ra,8(sp)
8112a698:	dc400117 	ldw	r17,4(sp)
8112a69c:	dc000017 	ldw	r16,0(sp)
8112a6a0:	dec00304 	addi	sp,sp,12
8112a6a4:	f800283a 	ret
8112a6a8:	80c00017 	ldw	r3,0(r16)
8112a6ac:	183ff926 	beq	r3,zero,8112a694 <__reset+0xfb10a694>
8112a6b0:	88c00015 	stw	r3,0(r17)
8112a6b4:	003ff706 	br	8112a694 <__reset+0xfb10a694>

8112a6b8 <__swsetup_r>:
8112a6b8:	00a04574 	movhi	r2,33045
8112a6bc:	defffd04 	addi	sp,sp,-12
8112a6c0:	1090f104 	addi	r2,r2,17348
8112a6c4:	de00012e 	bgeu	sp,et,8112a6cc <__swsetup_r+0x14>
8112a6c8:	003b68fa 	trap	3
8112a6cc:	dc400115 	stw	r17,4(sp)
8112a6d0:	2023883a 	mov	r17,r4
8112a6d4:	11000017 	ldw	r4,0(r2)
8112a6d8:	dc000015 	stw	r16,0(sp)
8112a6dc:	dfc00215 	stw	ra,8(sp)
8112a6e0:	2821883a 	mov	r16,r5
8112a6e4:	20000226 	beq	r4,zero,8112a6f0 <__swsetup_r+0x38>
8112a6e8:	20800e17 	ldw	r2,56(r4)
8112a6ec:	10003126 	beq	r2,zero,8112a7b4 <__swsetup_r+0xfc>
8112a6f0:	8080030b 	ldhu	r2,12(r16)
8112a6f4:	10c0020c 	andi	r3,r2,8
8112a6f8:	1009883a 	mov	r4,r2
8112a6fc:	18000f26 	beq	r3,zero,8112a73c <__swsetup_r+0x84>
8112a700:	80c00417 	ldw	r3,16(r16)
8112a704:	18001526 	beq	r3,zero,8112a75c <__swsetup_r+0xa4>
8112a708:	1100004c 	andi	r4,r2,1
8112a70c:	20001c1e 	bne	r4,zero,8112a780 <__swsetup_r+0xc8>
8112a710:	1080008c 	andi	r2,r2,2
8112a714:	1000291e 	bne	r2,zero,8112a7bc <__swsetup_r+0x104>
8112a718:	80800517 	ldw	r2,20(r16)
8112a71c:	80800215 	stw	r2,8(r16)
8112a720:	18001c26 	beq	r3,zero,8112a794 <__swsetup_r+0xdc>
8112a724:	0005883a 	mov	r2,zero
8112a728:	dfc00217 	ldw	ra,8(sp)
8112a72c:	dc400117 	ldw	r17,4(sp)
8112a730:	dc000017 	ldw	r16,0(sp)
8112a734:	dec00304 	addi	sp,sp,12
8112a738:	f800283a 	ret
8112a73c:	2080040c 	andi	r2,r4,16
8112a740:	10002e26 	beq	r2,zero,8112a7fc <__swsetup_r+0x144>
8112a744:	2080010c 	andi	r2,r4,4
8112a748:	10001e1e 	bne	r2,zero,8112a7c4 <__swsetup_r+0x10c>
8112a74c:	80c00417 	ldw	r3,16(r16)
8112a750:	20800214 	ori	r2,r4,8
8112a754:	8080030d 	sth	r2,12(r16)
8112a758:	183feb1e 	bne	r3,zero,8112a708 <__reset+0xfb10a708>
8112a75c:	1100a00c 	andi	r4,r2,640
8112a760:	01408004 	movi	r5,512
8112a764:	217fe826 	beq	r4,r5,8112a708 <__reset+0xfb10a708>
8112a768:	800b883a 	mov	r5,r16
8112a76c:	8809883a 	mov	r4,r17
8112a770:	11230040 	call	81123004 <__smakebuf_r>
8112a774:	8080030b 	ldhu	r2,12(r16)
8112a778:	80c00417 	ldw	r3,16(r16)
8112a77c:	003fe206 	br	8112a708 <__reset+0xfb10a708>
8112a780:	80800517 	ldw	r2,20(r16)
8112a784:	80000215 	stw	zero,8(r16)
8112a788:	0085c83a 	sub	r2,zero,r2
8112a78c:	80800615 	stw	r2,24(r16)
8112a790:	183fe41e 	bne	r3,zero,8112a724 <__reset+0xfb10a724>
8112a794:	80c0030b 	ldhu	r3,12(r16)
8112a798:	0005883a 	mov	r2,zero
8112a79c:	1900200c 	andi	r4,r3,128
8112a7a0:	203fe126 	beq	r4,zero,8112a728 <__reset+0xfb10a728>
8112a7a4:	18c01014 	ori	r3,r3,64
8112a7a8:	80c0030d 	sth	r3,12(r16)
8112a7ac:	00bfffc4 	movi	r2,-1
8112a7b0:	003fdd06 	br	8112a728 <__reset+0xfb10a728>
8112a7b4:	112c7280 	call	8112c728 <__sinit>
8112a7b8:	003fcd06 	br	8112a6f0 <__reset+0xfb10a6f0>
8112a7bc:	0005883a 	mov	r2,zero
8112a7c0:	003fd606 	br	8112a71c <__reset+0xfb10a71c>
8112a7c4:	81400c17 	ldw	r5,48(r16)
8112a7c8:	28000626 	beq	r5,zero,8112a7e4 <__swsetup_r+0x12c>
8112a7cc:	80801004 	addi	r2,r16,64
8112a7d0:	28800326 	beq	r5,r2,8112a7e0 <__swsetup_r+0x128>
8112a7d4:	8809883a 	mov	r4,r17
8112a7d8:	112cbc00 	call	8112cbc0 <_free_r>
8112a7dc:	8100030b 	ldhu	r4,12(r16)
8112a7e0:	80000c15 	stw	zero,48(r16)
8112a7e4:	80c00417 	ldw	r3,16(r16)
8112a7e8:	00bff6c4 	movi	r2,-37
8112a7ec:	1108703a 	and	r4,r2,r4
8112a7f0:	80000115 	stw	zero,4(r16)
8112a7f4:	80c00015 	stw	r3,0(r16)
8112a7f8:	003fd506 	br	8112a750 <__reset+0xfb10a750>
8112a7fc:	00800244 	movi	r2,9
8112a800:	88800015 	stw	r2,0(r17)
8112a804:	20801014 	ori	r2,r4,64
8112a808:	8080030d 	sth	r2,12(r16)
8112a80c:	00bfffc4 	movi	r2,-1
8112a810:	003fc506 	br	8112a728 <__reset+0xfb10a728>

8112a814 <_close_r>:
8112a814:	defffd04 	addi	sp,sp,-12
8112a818:	de00012e 	bgeu	sp,et,8112a820 <_close_r+0xc>
8112a81c:	003b68fa 	trap	3
8112a820:	dc000015 	stw	r16,0(sp)
8112a824:	04204574 	movhi	r16,33045
8112a828:	dc400115 	stw	r17,4(sp)
8112a82c:	84116404 	addi	r16,r16,17808
8112a830:	2023883a 	mov	r17,r4
8112a834:	2809883a 	mov	r4,r5
8112a838:	dfc00215 	stw	ra,8(sp)
8112a83c:	80000015 	stw	zero,0(r16)
8112a840:	11376c80 	call	811376c8 <close>
8112a844:	00ffffc4 	movi	r3,-1
8112a848:	10c00526 	beq	r2,r3,8112a860 <_close_r+0x4c>
8112a84c:	dfc00217 	ldw	ra,8(sp)
8112a850:	dc400117 	ldw	r17,4(sp)
8112a854:	dc000017 	ldw	r16,0(sp)
8112a858:	dec00304 	addi	sp,sp,12
8112a85c:	f800283a 	ret
8112a860:	80c00017 	ldw	r3,0(r16)
8112a864:	183ff926 	beq	r3,zero,8112a84c <__reset+0xfb10a84c>
8112a868:	88c00015 	stw	r3,0(r17)
8112a86c:	003ff706 	br	8112a84c <__reset+0xfb10a84c>

8112a870 <quorem>:
8112a870:	defff704 	addi	sp,sp,-36
8112a874:	de00012e 	bgeu	sp,et,8112a87c <quorem+0xc>
8112a878:	003b68fa 	trap	3
8112a87c:	dc800215 	stw	r18,8(sp)
8112a880:	20800417 	ldw	r2,16(r4)
8112a884:	2c800417 	ldw	r18,16(r5)
8112a888:	dfc00815 	stw	ra,32(sp)
8112a88c:	ddc00715 	stw	r23,28(sp)
8112a890:	dd800615 	stw	r22,24(sp)
8112a894:	dd400515 	stw	r21,20(sp)
8112a898:	dd000415 	stw	r20,16(sp)
8112a89c:	dcc00315 	stw	r19,12(sp)
8112a8a0:	dc400115 	stw	r17,4(sp)
8112a8a4:	dc000015 	stw	r16,0(sp)
8112a8a8:	14807116 	blt	r2,r18,8112aa70 <quorem+0x200>
8112a8ac:	94bfffc4 	addi	r18,r18,-1
8112a8b0:	94ad883a 	add	r22,r18,r18
8112a8b4:	b5ad883a 	add	r22,r22,r22
8112a8b8:	2c400504 	addi	r17,r5,20
8112a8bc:	8da9883a 	add	r20,r17,r22
8112a8c0:	25400504 	addi	r21,r4,20
8112a8c4:	282f883a 	mov	r23,r5
8112a8c8:	adad883a 	add	r22,r21,r22
8112a8cc:	a1400017 	ldw	r5,0(r20)
8112a8d0:	2021883a 	mov	r16,r4
8112a8d4:	b1000017 	ldw	r4,0(r22)
8112a8d8:	29400044 	addi	r5,r5,1
8112a8dc:	1135ecc0 	call	81135ecc <__udivsi3>
8112a8e0:	1027883a 	mov	r19,r2
8112a8e4:	10002c26 	beq	r2,zero,8112a998 <quorem+0x128>
8112a8e8:	a813883a 	mov	r9,r21
8112a8ec:	880b883a 	mov	r5,r17
8112a8f0:	0009883a 	mov	r4,zero
8112a8f4:	000d883a 	mov	r6,zero
8112a8f8:	2a000017 	ldw	r8,0(r5)
8112a8fc:	49c00017 	ldw	r7,0(r9)
8112a900:	29400104 	addi	r5,r5,4
8112a904:	40bfffcc 	andi	r2,r8,65535
8112a908:	14c5383a 	mul	r2,r2,r19
8112a90c:	4010d43a 	srli	r8,r8,16
8112a910:	38ffffcc 	andi	r3,r7,65535
8112a914:	1105883a 	add	r2,r2,r4
8112a918:	1008d43a 	srli	r4,r2,16
8112a91c:	44d1383a 	mul	r8,r8,r19
8112a920:	198d883a 	add	r6,r3,r6
8112a924:	10ffffcc 	andi	r3,r2,65535
8112a928:	30c7c83a 	sub	r3,r6,r3
8112a92c:	380ed43a 	srli	r7,r7,16
8112a930:	4105883a 	add	r2,r8,r4
8112a934:	180dd43a 	srai	r6,r3,16
8112a938:	113fffcc 	andi	r4,r2,65535
8112a93c:	390fc83a 	sub	r7,r7,r4
8112a940:	398d883a 	add	r6,r7,r6
8112a944:	300e943a 	slli	r7,r6,16
8112a948:	18ffffcc 	andi	r3,r3,65535
8112a94c:	1008d43a 	srli	r4,r2,16
8112a950:	38ceb03a 	or	r7,r7,r3
8112a954:	49c00015 	stw	r7,0(r9)
8112a958:	300dd43a 	srai	r6,r6,16
8112a95c:	4a400104 	addi	r9,r9,4
8112a960:	a17fe52e 	bgeu	r20,r5,8112a8f8 <__reset+0xfb10a8f8>
8112a964:	b0800017 	ldw	r2,0(r22)
8112a968:	10000b1e 	bne	r2,zero,8112a998 <quorem+0x128>
8112a96c:	b0bfff04 	addi	r2,r22,-4
8112a970:	a880082e 	bgeu	r21,r2,8112a994 <quorem+0x124>
8112a974:	b0ffff17 	ldw	r3,-4(r22)
8112a978:	18000326 	beq	r3,zero,8112a988 <quorem+0x118>
8112a97c:	00000506 	br	8112a994 <quorem+0x124>
8112a980:	10c00017 	ldw	r3,0(r2)
8112a984:	1800031e 	bne	r3,zero,8112a994 <quorem+0x124>
8112a988:	10bfff04 	addi	r2,r2,-4
8112a98c:	94bfffc4 	addi	r18,r18,-1
8112a990:	a8bffb36 	bltu	r21,r2,8112a980 <__reset+0xfb10a980>
8112a994:	84800415 	stw	r18,16(r16)
8112a998:	b80b883a 	mov	r5,r23
8112a99c:	8009883a 	mov	r4,r16
8112a9a0:	112e4900 	call	8112e490 <__mcmp>
8112a9a4:	10002616 	blt	r2,zero,8112aa40 <quorem+0x1d0>
8112a9a8:	9cc00044 	addi	r19,r19,1
8112a9ac:	a805883a 	mov	r2,r21
8112a9b0:	000b883a 	mov	r5,zero
8112a9b4:	11000017 	ldw	r4,0(r2)
8112a9b8:	89800017 	ldw	r6,0(r17)
8112a9bc:	10800104 	addi	r2,r2,4
8112a9c0:	20ffffcc 	andi	r3,r4,65535
8112a9c4:	194b883a 	add	r5,r3,r5
8112a9c8:	30ffffcc 	andi	r3,r6,65535
8112a9cc:	28c7c83a 	sub	r3,r5,r3
8112a9d0:	300cd43a 	srli	r6,r6,16
8112a9d4:	2008d43a 	srli	r4,r4,16
8112a9d8:	180bd43a 	srai	r5,r3,16
8112a9dc:	18ffffcc 	andi	r3,r3,65535
8112a9e0:	2189c83a 	sub	r4,r4,r6
8112a9e4:	2149883a 	add	r4,r4,r5
8112a9e8:	200c943a 	slli	r6,r4,16
8112a9ec:	8c400104 	addi	r17,r17,4
8112a9f0:	200bd43a 	srai	r5,r4,16
8112a9f4:	30c6b03a 	or	r3,r6,r3
8112a9f8:	10ffff15 	stw	r3,-4(r2)
8112a9fc:	a47fed2e 	bgeu	r20,r17,8112a9b4 <__reset+0xfb10a9b4>
8112aa00:	9485883a 	add	r2,r18,r18
8112aa04:	1085883a 	add	r2,r2,r2
8112aa08:	a887883a 	add	r3,r21,r2
8112aa0c:	18800017 	ldw	r2,0(r3)
8112aa10:	10000b1e 	bne	r2,zero,8112aa40 <quorem+0x1d0>
8112aa14:	18bfff04 	addi	r2,r3,-4
8112aa18:	a880082e 	bgeu	r21,r2,8112aa3c <quorem+0x1cc>
8112aa1c:	18ffff17 	ldw	r3,-4(r3)
8112aa20:	18000326 	beq	r3,zero,8112aa30 <quorem+0x1c0>
8112aa24:	00000506 	br	8112aa3c <quorem+0x1cc>
8112aa28:	10c00017 	ldw	r3,0(r2)
8112aa2c:	1800031e 	bne	r3,zero,8112aa3c <quorem+0x1cc>
8112aa30:	10bfff04 	addi	r2,r2,-4
8112aa34:	94bfffc4 	addi	r18,r18,-1
8112aa38:	a8bffb36 	bltu	r21,r2,8112aa28 <__reset+0xfb10aa28>
8112aa3c:	84800415 	stw	r18,16(r16)
8112aa40:	9805883a 	mov	r2,r19
8112aa44:	dfc00817 	ldw	ra,32(sp)
8112aa48:	ddc00717 	ldw	r23,28(sp)
8112aa4c:	dd800617 	ldw	r22,24(sp)
8112aa50:	dd400517 	ldw	r21,20(sp)
8112aa54:	dd000417 	ldw	r20,16(sp)
8112aa58:	dcc00317 	ldw	r19,12(sp)
8112aa5c:	dc800217 	ldw	r18,8(sp)
8112aa60:	dc400117 	ldw	r17,4(sp)
8112aa64:	dc000017 	ldw	r16,0(sp)
8112aa68:	dec00904 	addi	sp,sp,36
8112aa6c:	f800283a 	ret
8112aa70:	0005883a 	mov	r2,zero
8112aa74:	003ff306 	br	8112aa44 <__reset+0xfb10aa44>

8112aa78 <_dtoa_r>:
8112aa78:	deffde04 	addi	sp,sp,-136
8112aa7c:	de00012e 	bgeu	sp,et,8112aa84 <_dtoa_r+0xc>
8112aa80:	003b68fa 	trap	3
8112aa84:	20801017 	ldw	r2,64(r4)
8112aa88:	df002015 	stw	fp,128(sp)
8112aa8c:	dcc01b15 	stw	r19,108(sp)
8112aa90:	dc801a15 	stw	r18,104(sp)
8112aa94:	dc401915 	stw	r17,100(sp)
8112aa98:	dc001815 	stw	r16,96(sp)
8112aa9c:	dfc02115 	stw	ra,132(sp)
8112aaa0:	ddc01f15 	stw	r23,124(sp)
8112aaa4:	dd801e15 	stw	r22,120(sp)
8112aaa8:	dd401d15 	stw	r21,116(sp)
8112aaac:	dd001c15 	stw	r20,112(sp)
8112aab0:	d9c00315 	stw	r7,12(sp)
8112aab4:	2039883a 	mov	fp,r4
8112aab8:	3023883a 	mov	r17,r6
8112aabc:	2825883a 	mov	r18,r5
8112aac0:	dc002417 	ldw	r16,144(sp)
8112aac4:	3027883a 	mov	r19,r6
8112aac8:	10000826 	beq	r2,zero,8112aaec <_dtoa_r+0x74>
8112aacc:	21801117 	ldw	r6,68(r4)
8112aad0:	00c00044 	movi	r3,1
8112aad4:	100b883a 	mov	r5,r2
8112aad8:	1986983a 	sll	r3,r3,r6
8112aadc:	11800115 	stw	r6,4(r2)
8112aae0:	10c00215 	stw	r3,8(r2)
8112aae4:	112dc400 	call	8112dc40 <_Bfree>
8112aae8:	e0001015 	stw	zero,64(fp)
8112aaec:	88002e16 	blt	r17,zero,8112aba8 <_dtoa_r+0x130>
8112aaf0:	80000015 	stw	zero,0(r16)
8112aaf4:	889ffc2c 	andhi	r2,r17,32752
8112aaf8:	00dffc34 	movhi	r3,32752
8112aafc:	10c01c26 	beq	r2,r3,8112ab70 <_dtoa_r+0xf8>
8112ab00:	000d883a 	mov	r6,zero
8112ab04:	000f883a 	mov	r7,zero
8112ab08:	9009883a 	mov	r4,r18
8112ab0c:	980b883a 	mov	r5,r19
8112ab10:	11373280 	call	81137328 <__eqdf2>
8112ab14:	10002b1e 	bne	r2,zero,8112abc4 <_dtoa_r+0x14c>
8112ab18:	d9c02317 	ldw	r7,140(sp)
8112ab1c:	00800044 	movi	r2,1
8112ab20:	38800015 	stw	r2,0(r7)
8112ab24:	d8802517 	ldw	r2,148(sp)
8112ab28:	10019e26 	beq	r2,zero,8112b1a4 <_dtoa_r+0x72c>
8112ab2c:	d8c02517 	ldw	r3,148(sp)
8112ab30:	00a04574 	movhi	r2,33045
8112ab34:	10872944 	addi	r2,r2,7333
8112ab38:	18800015 	stw	r2,0(r3)
8112ab3c:	10bfffc4 	addi	r2,r2,-1
8112ab40:	dfc02117 	ldw	ra,132(sp)
8112ab44:	df002017 	ldw	fp,128(sp)
8112ab48:	ddc01f17 	ldw	r23,124(sp)
8112ab4c:	dd801e17 	ldw	r22,120(sp)
8112ab50:	dd401d17 	ldw	r21,116(sp)
8112ab54:	dd001c17 	ldw	r20,112(sp)
8112ab58:	dcc01b17 	ldw	r19,108(sp)
8112ab5c:	dc801a17 	ldw	r18,104(sp)
8112ab60:	dc401917 	ldw	r17,100(sp)
8112ab64:	dc001817 	ldw	r16,96(sp)
8112ab68:	dec02204 	addi	sp,sp,136
8112ab6c:	f800283a 	ret
8112ab70:	d8c02317 	ldw	r3,140(sp)
8112ab74:	0089c3c4 	movi	r2,9999
8112ab78:	18800015 	stw	r2,0(r3)
8112ab7c:	90017726 	beq	r18,zero,8112b15c <_dtoa_r+0x6e4>
8112ab80:	00a04574 	movhi	r2,33045
8112ab84:	10874704 	addi	r2,r2,7452
8112ab88:	d9002517 	ldw	r4,148(sp)
8112ab8c:	203fec26 	beq	r4,zero,8112ab40 <__reset+0xfb10ab40>
8112ab90:	10c000c7 	ldb	r3,3(r2)
8112ab94:	1801781e 	bne	r3,zero,8112b178 <_dtoa_r+0x700>
8112ab98:	10c000c4 	addi	r3,r2,3
8112ab9c:	d9802517 	ldw	r6,148(sp)
8112aba0:	30c00015 	stw	r3,0(r6)
8112aba4:	003fe606 	br	8112ab40 <__reset+0xfb10ab40>
8112aba8:	04e00034 	movhi	r19,32768
8112abac:	9cffffc4 	addi	r19,r19,-1
8112abb0:	00800044 	movi	r2,1
8112abb4:	8ce6703a 	and	r19,r17,r19
8112abb8:	80800015 	stw	r2,0(r16)
8112abbc:	9823883a 	mov	r17,r19
8112abc0:	003fcc06 	br	8112aaf4 <__reset+0xfb10aaf4>
8112abc4:	d8800204 	addi	r2,sp,8
8112abc8:	d8800015 	stw	r2,0(sp)
8112abcc:	d9c00104 	addi	r7,sp,4
8112abd0:	900b883a 	mov	r5,r18
8112abd4:	980d883a 	mov	r6,r19
8112abd8:	e009883a 	mov	r4,fp
8112abdc:	8820d53a 	srli	r16,r17,20
8112abe0:	112e86c0 	call	8112e86c <__d2b>
8112abe4:	d8800915 	stw	r2,36(sp)
8112abe8:	8001651e 	bne	r16,zero,8112b180 <_dtoa_r+0x708>
8112abec:	dd800217 	ldw	r22,8(sp)
8112abf0:	dc000117 	ldw	r16,4(sp)
8112abf4:	00800804 	movi	r2,32
8112abf8:	b421883a 	add	r16,r22,r16
8112abfc:	80c10c84 	addi	r3,r16,1074
8112ac00:	10c2d10e 	bge	r2,r3,8112b748 <_dtoa_r+0xcd0>
8112ac04:	00801004 	movi	r2,64
8112ac08:	81010484 	addi	r4,r16,1042
8112ac0c:	10c7c83a 	sub	r3,r2,r3
8112ac10:	9108d83a 	srl	r4,r18,r4
8112ac14:	88e2983a 	sll	r17,r17,r3
8112ac18:	2448b03a 	or	r4,r4,r17
8112ac1c:	11374a40 	call	811374a4 <__floatunsidf>
8112ac20:	017f8434 	movhi	r5,65040
8112ac24:	01800044 	movi	r6,1
8112ac28:	1009883a 	mov	r4,r2
8112ac2c:	194b883a 	add	r5,r3,r5
8112ac30:	843fffc4 	addi	r16,r16,-1
8112ac34:	d9801115 	stw	r6,68(sp)
8112ac38:	000d883a 	mov	r6,zero
8112ac3c:	01cffe34 	movhi	r7,16376
8112ac40:	1121a440 	call	81121a44 <__subdf3>
8112ac44:	0198dbf4 	movhi	r6,25455
8112ac48:	01cff4f4 	movhi	r7,16339
8112ac4c:	3190d844 	addi	r6,r6,17249
8112ac50:	39e1e9c4 	addi	r7,r7,-30809
8112ac54:	1009883a 	mov	r4,r2
8112ac58:	180b883a 	mov	r5,r3
8112ac5c:	11213240 	call	81121324 <__muldf3>
8112ac60:	01a2d874 	movhi	r6,35681
8112ac64:	01cff1f4 	movhi	r7,16327
8112ac68:	31b22cc4 	addi	r6,r6,-14157
8112ac6c:	39e28a04 	addi	r7,r7,-30168
8112ac70:	180b883a 	mov	r5,r3
8112ac74:	1009883a 	mov	r4,r2
8112ac78:	11361840 	call	81136184 <__adddf3>
8112ac7c:	8009883a 	mov	r4,r16
8112ac80:	1029883a 	mov	r20,r2
8112ac84:	1823883a 	mov	r17,r3
8112ac88:	11223c80 	call	811223c8 <__floatsidf>
8112ac8c:	019427f4 	movhi	r6,20639
8112ac90:	01cff4f4 	movhi	r7,16339
8112ac94:	319e7ec4 	addi	r6,r6,31227
8112ac98:	39d104c4 	addi	r7,r7,17427
8112ac9c:	1009883a 	mov	r4,r2
8112aca0:	180b883a 	mov	r5,r3
8112aca4:	11213240 	call	81121324 <__muldf3>
8112aca8:	100d883a 	mov	r6,r2
8112acac:	180f883a 	mov	r7,r3
8112acb0:	a009883a 	mov	r4,r20
8112acb4:	880b883a 	mov	r5,r17
8112acb8:	11361840 	call	81136184 <__adddf3>
8112acbc:	1009883a 	mov	r4,r2
8112acc0:	180b883a 	mov	r5,r3
8112acc4:	1029883a 	mov	r20,r2
8112acc8:	1823883a 	mov	r17,r3
8112accc:	11223480 	call	81122348 <__fixdfsi>
8112acd0:	000d883a 	mov	r6,zero
8112acd4:	000f883a 	mov	r7,zero
8112acd8:	a009883a 	mov	r4,r20
8112acdc:	880b883a 	mov	r5,r17
8112ace0:	d8800515 	stw	r2,20(sp)
8112ace4:	11373b00 	call	811373b0 <__ledf2>
8112ace8:	10028716 	blt	r2,zero,8112b708 <_dtoa_r+0xc90>
8112acec:	d8c00517 	ldw	r3,20(sp)
8112acf0:	00800584 	movi	r2,22
8112acf4:	10c27536 	bltu	r2,r3,8112b6cc <_dtoa_r+0xc54>
8112acf8:	180490fa 	slli	r2,r3,3
8112acfc:	00e04574 	movhi	r3,33045
8112ad00:	18c76204 	addi	r3,r3,7560
8112ad04:	1885883a 	add	r2,r3,r2
8112ad08:	11000017 	ldw	r4,0(r2)
8112ad0c:	11400117 	ldw	r5,4(r2)
8112ad10:	900d883a 	mov	r6,r18
8112ad14:	980f883a 	mov	r7,r19
8112ad18:	11212480 	call	81121248 <__gedf2>
8112ad1c:	00828d0e 	bge	zero,r2,8112b754 <_dtoa_r+0xcdc>
8112ad20:	d9000517 	ldw	r4,20(sp)
8112ad24:	d8000e15 	stw	zero,56(sp)
8112ad28:	213fffc4 	addi	r4,r4,-1
8112ad2c:	d9000515 	stw	r4,20(sp)
8112ad30:	b42dc83a 	sub	r22,r22,r16
8112ad34:	b5bfffc4 	addi	r22,r22,-1
8112ad38:	b0026f16 	blt	r22,zero,8112b6f8 <_dtoa_r+0xc80>
8112ad3c:	d8000815 	stw	zero,32(sp)
8112ad40:	d9c00517 	ldw	r7,20(sp)
8112ad44:	38026416 	blt	r7,zero,8112b6d8 <_dtoa_r+0xc60>
8112ad48:	b1ed883a 	add	r22,r22,r7
8112ad4c:	d9c00d15 	stw	r7,52(sp)
8112ad50:	d8000a15 	stw	zero,40(sp)
8112ad54:	d9800317 	ldw	r6,12(sp)
8112ad58:	00800244 	movi	r2,9
8112ad5c:	11811436 	bltu	r2,r6,8112b1b0 <_dtoa_r+0x738>
8112ad60:	00800144 	movi	r2,5
8112ad64:	1184e10e 	bge	r2,r6,8112c0ec <_dtoa_r+0x1674>
8112ad68:	31bfff04 	addi	r6,r6,-4
8112ad6c:	d9800315 	stw	r6,12(sp)
8112ad70:	0023883a 	mov	r17,zero
8112ad74:	d9800317 	ldw	r6,12(sp)
8112ad78:	008000c4 	movi	r2,3
8112ad7c:	30836726 	beq	r6,r2,8112bb1c <_dtoa_r+0x10a4>
8112ad80:	1183410e 	bge	r2,r6,8112ba88 <_dtoa_r+0x1010>
8112ad84:	d9c00317 	ldw	r7,12(sp)
8112ad88:	00800104 	movi	r2,4
8112ad8c:	38827c26 	beq	r7,r2,8112b780 <_dtoa_r+0xd08>
8112ad90:	00800144 	movi	r2,5
8112ad94:	3884c41e 	bne	r7,r2,8112c0a8 <_dtoa_r+0x1630>
8112ad98:	00800044 	movi	r2,1
8112ad9c:	d8800b15 	stw	r2,44(sp)
8112ada0:	d8c00517 	ldw	r3,20(sp)
8112ada4:	d9002217 	ldw	r4,136(sp)
8112ada8:	1907883a 	add	r3,r3,r4
8112adac:	19800044 	addi	r6,r3,1
8112adb0:	d8c00c15 	stw	r3,48(sp)
8112adb4:	d9800615 	stw	r6,24(sp)
8112adb8:	0183a40e 	bge	zero,r6,8112bc4c <_dtoa_r+0x11d4>
8112adbc:	d9800617 	ldw	r6,24(sp)
8112adc0:	3021883a 	mov	r16,r6
8112adc4:	e0001115 	stw	zero,68(fp)
8112adc8:	008005c4 	movi	r2,23
8112adcc:	1184c92e 	bgeu	r2,r6,8112c0f4 <_dtoa_r+0x167c>
8112add0:	00c00044 	movi	r3,1
8112add4:	00800104 	movi	r2,4
8112add8:	1085883a 	add	r2,r2,r2
8112addc:	11000504 	addi	r4,r2,20
8112ade0:	180b883a 	mov	r5,r3
8112ade4:	18c00044 	addi	r3,r3,1
8112ade8:	313ffb2e 	bgeu	r6,r4,8112add8 <__reset+0xfb10add8>
8112adec:	e1401115 	stw	r5,68(fp)
8112adf0:	e009883a 	mov	r4,fp
8112adf4:	112db900 	call	8112db90 <_Balloc>
8112adf8:	d8800715 	stw	r2,28(sp)
8112adfc:	e0801015 	stw	r2,64(fp)
8112ae00:	00800384 	movi	r2,14
8112ae04:	1400f736 	bltu	r2,r16,8112b1e4 <_dtoa_r+0x76c>
8112ae08:	8800f626 	beq	r17,zero,8112b1e4 <_dtoa_r+0x76c>
8112ae0c:	d9c00517 	ldw	r7,20(sp)
8112ae10:	01c39a0e 	bge	zero,r7,8112bc7c <_dtoa_r+0x1204>
8112ae14:	388003cc 	andi	r2,r7,15
8112ae18:	100490fa 	slli	r2,r2,3
8112ae1c:	382bd13a 	srai	r21,r7,4
8112ae20:	00e04574 	movhi	r3,33045
8112ae24:	18c76204 	addi	r3,r3,7560
8112ae28:	1885883a 	add	r2,r3,r2
8112ae2c:	a8c0040c 	andi	r3,r21,16
8112ae30:	12400017 	ldw	r9,0(r2)
8112ae34:	12000117 	ldw	r8,4(r2)
8112ae38:	18037926 	beq	r3,zero,8112bc20 <_dtoa_r+0x11a8>
8112ae3c:	00a04574 	movhi	r2,33045
8112ae40:	10875804 	addi	r2,r2,7520
8112ae44:	11800817 	ldw	r6,32(r2)
8112ae48:	11c00917 	ldw	r7,36(r2)
8112ae4c:	9009883a 	mov	r4,r18
8112ae50:	980b883a 	mov	r5,r19
8112ae54:	da001715 	stw	r8,92(sp)
8112ae58:	da401615 	stw	r9,88(sp)
8112ae5c:	1136a380 	call	81136a38 <__divdf3>
8112ae60:	da001717 	ldw	r8,92(sp)
8112ae64:	da401617 	ldw	r9,88(sp)
8112ae68:	ad4003cc 	andi	r21,r21,15
8112ae6c:	040000c4 	movi	r16,3
8112ae70:	1023883a 	mov	r17,r2
8112ae74:	1829883a 	mov	r20,r3
8112ae78:	a8001126 	beq	r21,zero,8112aec0 <_dtoa_r+0x448>
8112ae7c:	05e04574 	movhi	r23,33045
8112ae80:	bdc75804 	addi	r23,r23,7520
8112ae84:	4805883a 	mov	r2,r9
8112ae88:	4007883a 	mov	r3,r8
8112ae8c:	a980004c 	andi	r6,r21,1
8112ae90:	1009883a 	mov	r4,r2
8112ae94:	a82bd07a 	srai	r21,r21,1
8112ae98:	180b883a 	mov	r5,r3
8112ae9c:	30000426 	beq	r6,zero,8112aeb0 <_dtoa_r+0x438>
8112aea0:	b9800017 	ldw	r6,0(r23)
8112aea4:	b9c00117 	ldw	r7,4(r23)
8112aea8:	84000044 	addi	r16,r16,1
8112aeac:	11213240 	call	81121324 <__muldf3>
8112aeb0:	bdc00204 	addi	r23,r23,8
8112aeb4:	a83ff51e 	bne	r21,zero,8112ae8c <__reset+0xfb10ae8c>
8112aeb8:	1013883a 	mov	r9,r2
8112aebc:	1811883a 	mov	r8,r3
8112aec0:	480d883a 	mov	r6,r9
8112aec4:	400f883a 	mov	r7,r8
8112aec8:	8809883a 	mov	r4,r17
8112aecc:	a00b883a 	mov	r5,r20
8112aed0:	1136a380 	call	81136a38 <__divdf3>
8112aed4:	d8800f15 	stw	r2,60(sp)
8112aed8:	d8c01015 	stw	r3,64(sp)
8112aedc:	d8c00e17 	ldw	r3,56(sp)
8112aee0:	18000626 	beq	r3,zero,8112aefc <_dtoa_r+0x484>
8112aee4:	d9000f17 	ldw	r4,60(sp)
8112aee8:	d9401017 	ldw	r5,64(sp)
8112aeec:	000d883a 	mov	r6,zero
8112aef0:	01cffc34 	movhi	r7,16368
8112aef4:	11373b00 	call	811373b0 <__ledf2>
8112aef8:	10040b16 	blt	r2,zero,8112bf28 <_dtoa_r+0x14b0>
8112aefc:	8009883a 	mov	r4,r16
8112af00:	11223c80 	call	811223c8 <__floatsidf>
8112af04:	d9800f17 	ldw	r6,60(sp)
8112af08:	d9c01017 	ldw	r7,64(sp)
8112af0c:	1009883a 	mov	r4,r2
8112af10:	180b883a 	mov	r5,r3
8112af14:	11213240 	call	81121324 <__muldf3>
8112af18:	000d883a 	mov	r6,zero
8112af1c:	01d00734 	movhi	r7,16412
8112af20:	1009883a 	mov	r4,r2
8112af24:	180b883a 	mov	r5,r3
8112af28:	11361840 	call	81136184 <__adddf3>
8112af2c:	1021883a 	mov	r16,r2
8112af30:	d8800617 	ldw	r2,24(sp)
8112af34:	047f3034 	movhi	r17,64704
8112af38:	1c63883a 	add	r17,r3,r17
8112af3c:	10031826 	beq	r2,zero,8112bba0 <_dtoa_r+0x1128>
8112af40:	d8c00517 	ldw	r3,20(sp)
8112af44:	db000617 	ldw	r12,24(sp)
8112af48:	d8c01315 	stw	r3,76(sp)
8112af4c:	d9000b17 	ldw	r4,44(sp)
8112af50:	20038f26 	beq	r4,zero,8112bd90 <_dtoa_r+0x1318>
8112af54:	60bfffc4 	addi	r2,r12,-1
8112af58:	100490fa 	slli	r2,r2,3
8112af5c:	00e04574 	movhi	r3,33045
8112af60:	18c76204 	addi	r3,r3,7560
8112af64:	1885883a 	add	r2,r3,r2
8112af68:	11800017 	ldw	r6,0(r2)
8112af6c:	11c00117 	ldw	r7,4(r2)
8112af70:	d8800717 	ldw	r2,28(sp)
8112af74:	0009883a 	mov	r4,zero
8112af78:	014ff834 	movhi	r5,16352
8112af7c:	db001615 	stw	r12,88(sp)
8112af80:	15c00044 	addi	r23,r2,1
8112af84:	1136a380 	call	81136a38 <__divdf3>
8112af88:	800d883a 	mov	r6,r16
8112af8c:	880f883a 	mov	r7,r17
8112af90:	1009883a 	mov	r4,r2
8112af94:	180b883a 	mov	r5,r3
8112af98:	1121a440 	call	81121a44 <__subdf3>
8112af9c:	d9401017 	ldw	r5,64(sp)
8112afa0:	d9000f17 	ldw	r4,60(sp)
8112afa4:	102b883a 	mov	r21,r2
8112afa8:	d8c01215 	stw	r3,72(sp)
8112afac:	11223480 	call	81122348 <__fixdfsi>
8112afb0:	1009883a 	mov	r4,r2
8112afb4:	1029883a 	mov	r20,r2
8112afb8:	11223c80 	call	811223c8 <__floatsidf>
8112afbc:	d9000f17 	ldw	r4,60(sp)
8112afc0:	d9401017 	ldw	r5,64(sp)
8112afc4:	100d883a 	mov	r6,r2
8112afc8:	180f883a 	mov	r7,r3
8112afcc:	1121a440 	call	81121a44 <__subdf3>
8112afd0:	1823883a 	mov	r17,r3
8112afd4:	d8c00717 	ldw	r3,28(sp)
8112afd8:	d9401217 	ldw	r5,72(sp)
8112afdc:	a2000c04 	addi	r8,r20,48
8112afe0:	1021883a 	mov	r16,r2
8112afe4:	1a000005 	stb	r8,0(r3)
8112afe8:	800d883a 	mov	r6,r16
8112afec:	880f883a 	mov	r7,r17
8112aff0:	a809883a 	mov	r4,r21
8112aff4:	4029883a 	mov	r20,r8
8112aff8:	11212480 	call	81121248 <__gedf2>
8112affc:	00841d16 	blt	zero,r2,8112c074 <_dtoa_r+0x15fc>
8112b000:	800d883a 	mov	r6,r16
8112b004:	880f883a 	mov	r7,r17
8112b008:	0009883a 	mov	r4,zero
8112b00c:	014ffc34 	movhi	r5,16368
8112b010:	1121a440 	call	81121a44 <__subdf3>
8112b014:	d9401217 	ldw	r5,72(sp)
8112b018:	100d883a 	mov	r6,r2
8112b01c:	180f883a 	mov	r7,r3
8112b020:	a809883a 	mov	r4,r21
8112b024:	11212480 	call	81121248 <__gedf2>
8112b028:	db001617 	ldw	r12,88(sp)
8112b02c:	00840e16 	blt	zero,r2,8112c068 <_dtoa_r+0x15f0>
8112b030:	00800044 	movi	r2,1
8112b034:	13006b0e 	bge	r2,r12,8112b1e4 <_dtoa_r+0x76c>
8112b038:	d9000717 	ldw	r4,28(sp)
8112b03c:	dd800f15 	stw	r22,60(sp)
8112b040:	dcc01015 	stw	r19,64(sp)
8112b044:	2319883a 	add	r12,r4,r12
8112b048:	dcc01217 	ldw	r19,72(sp)
8112b04c:	602d883a 	mov	r22,r12
8112b050:	dc801215 	stw	r18,72(sp)
8112b054:	b825883a 	mov	r18,r23
8112b058:	00000906 	br	8112b080 <_dtoa_r+0x608>
8112b05c:	1121a440 	call	81121a44 <__subdf3>
8112b060:	a80d883a 	mov	r6,r21
8112b064:	980f883a 	mov	r7,r19
8112b068:	1009883a 	mov	r4,r2
8112b06c:	180b883a 	mov	r5,r3
8112b070:	11373b00 	call	811373b0 <__ledf2>
8112b074:	1003e816 	blt	r2,zero,8112c018 <_dtoa_r+0x15a0>
8112b078:	b825883a 	mov	r18,r23
8112b07c:	bd83e926 	beq	r23,r22,8112c024 <_dtoa_r+0x15ac>
8112b080:	a809883a 	mov	r4,r21
8112b084:	980b883a 	mov	r5,r19
8112b088:	000d883a 	mov	r6,zero
8112b08c:	01d00934 	movhi	r7,16420
8112b090:	11213240 	call	81121324 <__muldf3>
8112b094:	000d883a 	mov	r6,zero
8112b098:	01d00934 	movhi	r7,16420
8112b09c:	8009883a 	mov	r4,r16
8112b0a0:	880b883a 	mov	r5,r17
8112b0a4:	102b883a 	mov	r21,r2
8112b0a8:	1827883a 	mov	r19,r3
8112b0ac:	11213240 	call	81121324 <__muldf3>
8112b0b0:	180b883a 	mov	r5,r3
8112b0b4:	1009883a 	mov	r4,r2
8112b0b8:	1821883a 	mov	r16,r3
8112b0bc:	1023883a 	mov	r17,r2
8112b0c0:	11223480 	call	81122348 <__fixdfsi>
8112b0c4:	1009883a 	mov	r4,r2
8112b0c8:	1029883a 	mov	r20,r2
8112b0cc:	11223c80 	call	811223c8 <__floatsidf>
8112b0d0:	8809883a 	mov	r4,r17
8112b0d4:	800b883a 	mov	r5,r16
8112b0d8:	100d883a 	mov	r6,r2
8112b0dc:	180f883a 	mov	r7,r3
8112b0e0:	1121a440 	call	81121a44 <__subdf3>
8112b0e4:	a5000c04 	addi	r20,r20,48
8112b0e8:	a80d883a 	mov	r6,r21
8112b0ec:	980f883a 	mov	r7,r19
8112b0f0:	1009883a 	mov	r4,r2
8112b0f4:	180b883a 	mov	r5,r3
8112b0f8:	95000005 	stb	r20,0(r18)
8112b0fc:	1021883a 	mov	r16,r2
8112b100:	1823883a 	mov	r17,r3
8112b104:	11373b00 	call	811373b0 <__ledf2>
8112b108:	bdc00044 	addi	r23,r23,1
8112b10c:	800d883a 	mov	r6,r16
8112b110:	880f883a 	mov	r7,r17
8112b114:	0009883a 	mov	r4,zero
8112b118:	014ffc34 	movhi	r5,16368
8112b11c:	103fcf0e 	bge	r2,zero,8112b05c <__reset+0xfb10b05c>
8112b120:	d8c01317 	ldw	r3,76(sp)
8112b124:	d8c00515 	stw	r3,20(sp)
8112b128:	d9400917 	ldw	r5,36(sp)
8112b12c:	e009883a 	mov	r4,fp
8112b130:	112dc400 	call	8112dc40 <_Bfree>
8112b134:	d9000517 	ldw	r4,20(sp)
8112b138:	d9802317 	ldw	r6,140(sp)
8112b13c:	d9c02517 	ldw	r7,148(sp)
8112b140:	b8000005 	stb	zero,0(r23)
8112b144:	20800044 	addi	r2,r4,1
8112b148:	30800015 	stw	r2,0(r6)
8112b14c:	3802aa26 	beq	r7,zero,8112bbf8 <_dtoa_r+0x1180>
8112b150:	3dc00015 	stw	r23,0(r7)
8112b154:	d8800717 	ldw	r2,28(sp)
8112b158:	003e7906 	br	8112ab40 <__reset+0xfb10ab40>
8112b15c:	00800434 	movhi	r2,16
8112b160:	10bfffc4 	addi	r2,r2,-1
8112b164:	88a2703a 	and	r17,r17,r2
8112b168:	883e851e 	bne	r17,zero,8112ab80 <__reset+0xfb10ab80>
8112b16c:	00a04574 	movhi	r2,33045
8112b170:	10874404 	addi	r2,r2,7440
8112b174:	003e8406 	br	8112ab88 <__reset+0xfb10ab88>
8112b178:	10c00204 	addi	r3,r2,8
8112b17c:	003e8706 	br	8112ab9c <__reset+0xfb10ab9c>
8112b180:	01400434 	movhi	r5,16
8112b184:	297fffc4 	addi	r5,r5,-1
8112b188:	994a703a 	and	r5,r19,r5
8112b18c:	9009883a 	mov	r4,r18
8112b190:	843f0044 	addi	r16,r16,-1023
8112b194:	294ffc34 	orhi	r5,r5,16368
8112b198:	dd800217 	ldw	r22,8(sp)
8112b19c:	d8001115 	stw	zero,68(sp)
8112b1a0:	003ea506 	br	8112ac38 <__reset+0xfb10ac38>
8112b1a4:	00a04574 	movhi	r2,33045
8112b1a8:	10872904 	addi	r2,r2,7332
8112b1ac:	003e6406 	br	8112ab40 <__reset+0xfb10ab40>
8112b1b0:	e0001115 	stw	zero,68(fp)
8112b1b4:	000b883a 	mov	r5,zero
8112b1b8:	e009883a 	mov	r4,fp
8112b1bc:	112db900 	call	8112db90 <_Balloc>
8112b1c0:	01bfffc4 	movi	r6,-1
8112b1c4:	01c00044 	movi	r7,1
8112b1c8:	d8800715 	stw	r2,28(sp)
8112b1cc:	d9800c15 	stw	r6,48(sp)
8112b1d0:	e0801015 	stw	r2,64(fp)
8112b1d4:	d8000315 	stw	zero,12(sp)
8112b1d8:	d9c00b15 	stw	r7,44(sp)
8112b1dc:	d9800615 	stw	r6,24(sp)
8112b1e0:	d8002215 	stw	zero,136(sp)
8112b1e4:	d8800117 	ldw	r2,4(sp)
8112b1e8:	10008916 	blt	r2,zero,8112b410 <_dtoa_r+0x998>
8112b1ec:	d9000517 	ldw	r4,20(sp)
8112b1f0:	00c00384 	movi	r3,14
8112b1f4:	19008616 	blt	r3,r4,8112b410 <_dtoa_r+0x998>
8112b1f8:	200490fa 	slli	r2,r4,3
8112b1fc:	00e04574 	movhi	r3,33045
8112b200:	d9802217 	ldw	r6,136(sp)
8112b204:	18c76204 	addi	r3,r3,7560
8112b208:	1885883a 	add	r2,r3,r2
8112b20c:	14000017 	ldw	r16,0(r2)
8112b210:	14400117 	ldw	r17,4(r2)
8112b214:	30016316 	blt	r6,zero,8112b7a4 <_dtoa_r+0xd2c>
8112b218:	800d883a 	mov	r6,r16
8112b21c:	880f883a 	mov	r7,r17
8112b220:	9009883a 	mov	r4,r18
8112b224:	980b883a 	mov	r5,r19
8112b228:	1136a380 	call	81136a38 <__divdf3>
8112b22c:	180b883a 	mov	r5,r3
8112b230:	1009883a 	mov	r4,r2
8112b234:	11223480 	call	81122348 <__fixdfsi>
8112b238:	1009883a 	mov	r4,r2
8112b23c:	102b883a 	mov	r21,r2
8112b240:	11223c80 	call	811223c8 <__floatsidf>
8112b244:	800d883a 	mov	r6,r16
8112b248:	880f883a 	mov	r7,r17
8112b24c:	1009883a 	mov	r4,r2
8112b250:	180b883a 	mov	r5,r3
8112b254:	11213240 	call	81121324 <__muldf3>
8112b258:	100d883a 	mov	r6,r2
8112b25c:	180f883a 	mov	r7,r3
8112b260:	9009883a 	mov	r4,r18
8112b264:	980b883a 	mov	r5,r19
8112b268:	1121a440 	call	81121a44 <__subdf3>
8112b26c:	d9c00717 	ldw	r7,28(sp)
8112b270:	1009883a 	mov	r4,r2
8112b274:	a8800c04 	addi	r2,r21,48
8112b278:	38800005 	stb	r2,0(r7)
8112b27c:	3dc00044 	addi	r23,r7,1
8112b280:	d9c00617 	ldw	r7,24(sp)
8112b284:	01800044 	movi	r6,1
8112b288:	180b883a 	mov	r5,r3
8112b28c:	2005883a 	mov	r2,r4
8112b290:	39803826 	beq	r7,r6,8112b374 <_dtoa_r+0x8fc>
8112b294:	000d883a 	mov	r6,zero
8112b298:	01d00934 	movhi	r7,16420
8112b29c:	11213240 	call	81121324 <__muldf3>
8112b2a0:	000d883a 	mov	r6,zero
8112b2a4:	000f883a 	mov	r7,zero
8112b2a8:	1009883a 	mov	r4,r2
8112b2ac:	180b883a 	mov	r5,r3
8112b2b0:	1025883a 	mov	r18,r2
8112b2b4:	1827883a 	mov	r19,r3
8112b2b8:	11373280 	call	81137328 <__eqdf2>
8112b2bc:	103f9a26 	beq	r2,zero,8112b128 <__reset+0xfb10b128>
8112b2c0:	d9c00617 	ldw	r7,24(sp)
8112b2c4:	d8c00717 	ldw	r3,28(sp)
8112b2c8:	b829883a 	mov	r20,r23
8112b2cc:	38bfffc4 	addi	r2,r7,-1
8112b2d0:	18ad883a 	add	r22,r3,r2
8112b2d4:	00000a06 	br	8112b300 <_dtoa_r+0x888>
8112b2d8:	11213240 	call	81121324 <__muldf3>
8112b2dc:	000d883a 	mov	r6,zero
8112b2e0:	000f883a 	mov	r7,zero
8112b2e4:	1009883a 	mov	r4,r2
8112b2e8:	180b883a 	mov	r5,r3
8112b2ec:	1025883a 	mov	r18,r2
8112b2f0:	1827883a 	mov	r19,r3
8112b2f4:	b829883a 	mov	r20,r23
8112b2f8:	11373280 	call	81137328 <__eqdf2>
8112b2fc:	103f8a26 	beq	r2,zero,8112b128 <__reset+0xfb10b128>
8112b300:	800d883a 	mov	r6,r16
8112b304:	880f883a 	mov	r7,r17
8112b308:	9009883a 	mov	r4,r18
8112b30c:	980b883a 	mov	r5,r19
8112b310:	1136a380 	call	81136a38 <__divdf3>
8112b314:	180b883a 	mov	r5,r3
8112b318:	1009883a 	mov	r4,r2
8112b31c:	11223480 	call	81122348 <__fixdfsi>
8112b320:	1009883a 	mov	r4,r2
8112b324:	102b883a 	mov	r21,r2
8112b328:	11223c80 	call	811223c8 <__floatsidf>
8112b32c:	800d883a 	mov	r6,r16
8112b330:	880f883a 	mov	r7,r17
8112b334:	1009883a 	mov	r4,r2
8112b338:	180b883a 	mov	r5,r3
8112b33c:	11213240 	call	81121324 <__muldf3>
8112b340:	100d883a 	mov	r6,r2
8112b344:	180f883a 	mov	r7,r3
8112b348:	9009883a 	mov	r4,r18
8112b34c:	980b883a 	mov	r5,r19
8112b350:	1121a440 	call	81121a44 <__subdf3>
8112b354:	aa000c04 	addi	r8,r21,48
8112b358:	a2000005 	stb	r8,0(r20)
8112b35c:	000d883a 	mov	r6,zero
8112b360:	01d00934 	movhi	r7,16420
8112b364:	1009883a 	mov	r4,r2
8112b368:	180b883a 	mov	r5,r3
8112b36c:	a5c00044 	addi	r23,r20,1
8112b370:	b53fd91e 	bne	r22,r20,8112b2d8 <__reset+0xfb10b2d8>
8112b374:	100d883a 	mov	r6,r2
8112b378:	180f883a 	mov	r7,r3
8112b37c:	1009883a 	mov	r4,r2
8112b380:	180b883a 	mov	r5,r3
8112b384:	11361840 	call	81136184 <__adddf3>
8112b388:	100d883a 	mov	r6,r2
8112b38c:	180f883a 	mov	r7,r3
8112b390:	8009883a 	mov	r4,r16
8112b394:	880b883a 	mov	r5,r17
8112b398:	1027883a 	mov	r19,r2
8112b39c:	1825883a 	mov	r18,r3
8112b3a0:	11373b00 	call	811373b0 <__ledf2>
8112b3a4:	10000816 	blt	r2,zero,8112b3c8 <_dtoa_r+0x950>
8112b3a8:	980d883a 	mov	r6,r19
8112b3ac:	900f883a 	mov	r7,r18
8112b3b0:	8009883a 	mov	r4,r16
8112b3b4:	880b883a 	mov	r5,r17
8112b3b8:	11373280 	call	81137328 <__eqdf2>
8112b3bc:	103f5a1e 	bne	r2,zero,8112b128 <__reset+0xfb10b128>
8112b3c0:	ad40004c 	andi	r21,r21,1
8112b3c4:	a83f5826 	beq	r21,zero,8112b128 <__reset+0xfb10b128>
8112b3c8:	bd3fffc3 	ldbu	r20,-1(r23)
8112b3cc:	b8bfffc4 	addi	r2,r23,-1
8112b3d0:	1007883a 	mov	r3,r2
8112b3d4:	01400e44 	movi	r5,57
8112b3d8:	d9800717 	ldw	r6,28(sp)
8112b3dc:	00000506 	br	8112b3f4 <_dtoa_r+0x97c>
8112b3e0:	18ffffc4 	addi	r3,r3,-1
8112b3e4:	11824726 	beq	r2,r6,8112bd04 <_dtoa_r+0x128c>
8112b3e8:	1d000003 	ldbu	r20,0(r3)
8112b3ec:	102f883a 	mov	r23,r2
8112b3f0:	10bfffc4 	addi	r2,r2,-1
8112b3f4:	a1003fcc 	andi	r4,r20,255
8112b3f8:	2100201c 	xori	r4,r4,128
8112b3fc:	213fe004 	addi	r4,r4,-128
8112b400:	217ff726 	beq	r4,r5,8112b3e0 <__reset+0xfb10b3e0>
8112b404:	a2000044 	addi	r8,r20,1
8112b408:	12000005 	stb	r8,0(r2)
8112b40c:	003f4606 	br	8112b128 <__reset+0xfb10b128>
8112b410:	d9000b17 	ldw	r4,44(sp)
8112b414:	2000c826 	beq	r4,zero,8112b738 <_dtoa_r+0xcc0>
8112b418:	d9800317 	ldw	r6,12(sp)
8112b41c:	00c00044 	movi	r3,1
8112b420:	1980f90e 	bge	r3,r6,8112b808 <_dtoa_r+0xd90>
8112b424:	d8800617 	ldw	r2,24(sp)
8112b428:	d8c00a17 	ldw	r3,40(sp)
8112b42c:	157fffc4 	addi	r21,r2,-1
8112b430:	1d41f316 	blt	r3,r21,8112bc00 <_dtoa_r+0x1188>
8112b434:	1d6bc83a 	sub	r21,r3,r21
8112b438:	d9c00617 	ldw	r7,24(sp)
8112b43c:	3802aa16 	blt	r7,zero,8112bee8 <_dtoa_r+0x1470>
8112b440:	dd000817 	ldw	r20,32(sp)
8112b444:	d8800617 	ldw	r2,24(sp)
8112b448:	d8c00817 	ldw	r3,32(sp)
8112b44c:	01400044 	movi	r5,1
8112b450:	e009883a 	mov	r4,fp
8112b454:	1887883a 	add	r3,r3,r2
8112b458:	d8c00815 	stw	r3,32(sp)
8112b45c:	b0ad883a 	add	r22,r22,r2
8112b460:	112dfb40 	call	8112dfb4 <__i2b>
8112b464:	1023883a 	mov	r17,r2
8112b468:	a0000826 	beq	r20,zero,8112b48c <_dtoa_r+0xa14>
8112b46c:	0580070e 	bge	zero,r22,8112b48c <_dtoa_r+0xa14>
8112b470:	a005883a 	mov	r2,r20
8112b474:	b500b916 	blt	r22,r20,8112b75c <_dtoa_r+0xce4>
8112b478:	d9000817 	ldw	r4,32(sp)
8112b47c:	a0a9c83a 	sub	r20,r20,r2
8112b480:	b0adc83a 	sub	r22,r22,r2
8112b484:	2089c83a 	sub	r4,r4,r2
8112b488:	d9000815 	stw	r4,32(sp)
8112b48c:	d9800a17 	ldw	r6,40(sp)
8112b490:	0181810e 	bge	zero,r6,8112ba98 <_dtoa_r+0x1020>
8112b494:	d9c00b17 	ldw	r7,44(sp)
8112b498:	3800b326 	beq	r7,zero,8112b768 <_dtoa_r+0xcf0>
8112b49c:	a800b226 	beq	r21,zero,8112b768 <_dtoa_r+0xcf0>
8112b4a0:	880b883a 	mov	r5,r17
8112b4a4:	a80d883a 	mov	r6,r21
8112b4a8:	e009883a 	mov	r4,fp
8112b4ac:	112e1f80 	call	8112e1f8 <__pow5mult>
8112b4b0:	d9800917 	ldw	r6,36(sp)
8112b4b4:	100b883a 	mov	r5,r2
8112b4b8:	e009883a 	mov	r4,fp
8112b4bc:	1023883a 	mov	r17,r2
8112b4c0:	112dff80 	call	8112dff8 <__multiply>
8112b4c4:	1021883a 	mov	r16,r2
8112b4c8:	d8800a17 	ldw	r2,40(sp)
8112b4cc:	d9400917 	ldw	r5,36(sp)
8112b4d0:	e009883a 	mov	r4,fp
8112b4d4:	1545c83a 	sub	r2,r2,r21
8112b4d8:	d8800a15 	stw	r2,40(sp)
8112b4dc:	112dc400 	call	8112dc40 <_Bfree>
8112b4e0:	d8c00a17 	ldw	r3,40(sp)
8112b4e4:	18009f1e 	bne	r3,zero,8112b764 <_dtoa_r+0xcec>
8112b4e8:	05c00044 	movi	r23,1
8112b4ec:	e009883a 	mov	r4,fp
8112b4f0:	b80b883a 	mov	r5,r23
8112b4f4:	112dfb40 	call	8112dfb4 <__i2b>
8112b4f8:	d9000d17 	ldw	r4,52(sp)
8112b4fc:	102b883a 	mov	r21,r2
8112b500:	2000ce26 	beq	r4,zero,8112b83c <_dtoa_r+0xdc4>
8112b504:	200d883a 	mov	r6,r4
8112b508:	100b883a 	mov	r5,r2
8112b50c:	e009883a 	mov	r4,fp
8112b510:	112e1f80 	call	8112e1f8 <__pow5mult>
8112b514:	d9800317 	ldw	r6,12(sp)
8112b518:	102b883a 	mov	r21,r2
8112b51c:	b981810e 	bge	r23,r6,8112bb24 <_dtoa_r+0x10ac>
8112b520:	0027883a 	mov	r19,zero
8112b524:	a8800417 	ldw	r2,16(r21)
8112b528:	05c00804 	movi	r23,32
8112b52c:	10800104 	addi	r2,r2,4
8112b530:	1085883a 	add	r2,r2,r2
8112b534:	1085883a 	add	r2,r2,r2
8112b538:	a885883a 	add	r2,r21,r2
8112b53c:	11000017 	ldw	r4,0(r2)
8112b540:	112de9c0 	call	8112de9c <__hi0bits>
8112b544:	b885c83a 	sub	r2,r23,r2
8112b548:	1585883a 	add	r2,r2,r22
8112b54c:	108007cc 	andi	r2,r2,31
8112b550:	1000b326 	beq	r2,zero,8112b820 <_dtoa_r+0xda8>
8112b554:	00c00804 	movi	r3,32
8112b558:	1887c83a 	sub	r3,r3,r2
8112b55c:	01000104 	movi	r4,4
8112b560:	20c2cd0e 	bge	r4,r3,8112c098 <_dtoa_r+0x1620>
8112b564:	00c00704 	movi	r3,28
8112b568:	1885c83a 	sub	r2,r3,r2
8112b56c:	d8c00817 	ldw	r3,32(sp)
8112b570:	a0a9883a 	add	r20,r20,r2
8112b574:	b0ad883a 	add	r22,r22,r2
8112b578:	1887883a 	add	r3,r3,r2
8112b57c:	d8c00815 	stw	r3,32(sp)
8112b580:	d9800817 	ldw	r6,32(sp)
8112b584:	0180040e 	bge	zero,r6,8112b598 <_dtoa_r+0xb20>
8112b588:	800b883a 	mov	r5,r16
8112b58c:	e009883a 	mov	r4,fp
8112b590:	112e3400 	call	8112e340 <__lshift>
8112b594:	1021883a 	mov	r16,r2
8112b598:	0580050e 	bge	zero,r22,8112b5b0 <_dtoa_r+0xb38>
8112b59c:	a80b883a 	mov	r5,r21
8112b5a0:	b00d883a 	mov	r6,r22
8112b5a4:	e009883a 	mov	r4,fp
8112b5a8:	112e3400 	call	8112e340 <__lshift>
8112b5ac:	102b883a 	mov	r21,r2
8112b5b0:	d9c00e17 	ldw	r7,56(sp)
8112b5b4:	3801211e 	bne	r7,zero,8112ba3c <_dtoa_r+0xfc4>
8112b5b8:	d9800617 	ldw	r6,24(sp)
8112b5bc:	0181380e 	bge	zero,r6,8112baa0 <_dtoa_r+0x1028>
8112b5c0:	d8c00b17 	ldw	r3,44(sp)
8112b5c4:	1800ab1e 	bne	r3,zero,8112b874 <_dtoa_r+0xdfc>
8112b5c8:	dc800717 	ldw	r18,28(sp)
8112b5cc:	dcc00617 	ldw	r19,24(sp)
8112b5d0:	9029883a 	mov	r20,r18
8112b5d4:	00000206 	br	8112b5e0 <_dtoa_r+0xb68>
8112b5d8:	112dc680 	call	8112dc68 <__multadd>
8112b5dc:	1021883a 	mov	r16,r2
8112b5e0:	a80b883a 	mov	r5,r21
8112b5e4:	8009883a 	mov	r4,r16
8112b5e8:	112a8700 	call	8112a870 <quorem>
8112b5ec:	10800c04 	addi	r2,r2,48
8112b5f0:	90800005 	stb	r2,0(r18)
8112b5f4:	94800044 	addi	r18,r18,1
8112b5f8:	9507c83a 	sub	r3,r18,r20
8112b5fc:	000f883a 	mov	r7,zero
8112b600:	01800284 	movi	r6,10
8112b604:	800b883a 	mov	r5,r16
8112b608:	e009883a 	mov	r4,fp
8112b60c:	1cfff216 	blt	r3,r19,8112b5d8 <__reset+0xfb10b5d8>
8112b610:	1011883a 	mov	r8,r2
8112b614:	d8800617 	ldw	r2,24(sp)
8112b618:	0082370e 	bge	zero,r2,8112bef8 <_dtoa_r+0x1480>
8112b61c:	d9000717 	ldw	r4,28(sp)
8112b620:	0025883a 	mov	r18,zero
8112b624:	20af883a 	add	r23,r4,r2
8112b628:	01800044 	movi	r6,1
8112b62c:	800b883a 	mov	r5,r16
8112b630:	e009883a 	mov	r4,fp
8112b634:	da001715 	stw	r8,92(sp)
8112b638:	112e3400 	call	8112e340 <__lshift>
8112b63c:	a80b883a 	mov	r5,r21
8112b640:	1009883a 	mov	r4,r2
8112b644:	d8800915 	stw	r2,36(sp)
8112b648:	112e4900 	call	8112e490 <__mcmp>
8112b64c:	da001717 	ldw	r8,92(sp)
8112b650:	0081800e 	bge	zero,r2,8112bc54 <_dtoa_r+0x11dc>
8112b654:	b93fffc3 	ldbu	r4,-1(r23)
8112b658:	b8bfffc4 	addi	r2,r23,-1
8112b65c:	1007883a 	mov	r3,r2
8112b660:	01800e44 	movi	r6,57
8112b664:	d9c00717 	ldw	r7,28(sp)
8112b668:	00000506 	br	8112b680 <_dtoa_r+0xc08>
8112b66c:	18ffffc4 	addi	r3,r3,-1
8112b670:	11c12326 	beq	r2,r7,8112bb00 <_dtoa_r+0x1088>
8112b674:	19000003 	ldbu	r4,0(r3)
8112b678:	102f883a 	mov	r23,r2
8112b67c:	10bfffc4 	addi	r2,r2,-1
8112b680:	21403fcc 	andi	r5,r4,255
8112b684:	2940201c 	xori	r5,r5,128
8112b688:	297fe004 	addi	r5,r5,-128
8112b68c:	29bff726 	beq	r5,r6,8112b66c <__reset+0xfb10b66c>
8112b690:	21000044 	addi	r4,r4,1
8112b694:	11000005 	stb	r4,0(r2)
8112b698:	a80b883a 	mov	r5,r21
8112b69c:	e009883a 	mov	r4,fp
8112b6a0:	112dc400 	call	8112dc40 <_Bfree>
8112b6a4:	883ea026 	beq	r17,zero,8112b128 <__reset+0xfb10b128>
8112b6a8:	90000426 	beq	r18,zero,8112b6bc <_dtoa_r+0xc44>
8112b6ac:	94400326 	beq	r18,r17,8112b6bc <_dtoa_r+0xc44>
8112b6b0:	900b883a 	mov	r5,r18
8112b6b4:	e009883a 	mov	r4,fp
8112b6b8:	112dc400 	call	8112dc40 <_Bfree>
8112b6bc:	880b883a 	mov	r5,r17
8112b6c0:	e009883a 	mov	r4,fp
8112b6c4:	112dc400 	call	8112dc40 <_Bfree>
8112b6c8:	003e9706 	br	8112b128 <__reset+0xfb10b128>
8112b6cc:	01800044 	movi	r6,1
8112b6d0:	d9800e15 	stw	r6,56(sp)
8112b6d4:	003d9606 	br	8112ad30 <__reset+0xfb10ad30>
8112b6d8:	d8800817 	ldw	r2,32(sp)
8112b6dc:	d8c00517 	ldw	r3,20(sp)
8112b6e0:	d8000d15 	stw	zero,52(sp)
8112b6e4:	10c5c83a 	sub	r2,r2,r3
8112b6e8:	00c9c83a 	sub	r4,zero,r3
8112b6ec:	d8800815 	stw	r2,32(sp)
8112b6f0:	d9000a15 	stw	r4,40(sp)
8112b6f4:	003d9706 	br	8112ad54 <__reset+0xfb10ad54>
8112b6f8:	05adc83a 	sub	r22,zero,r22
8112b6fc:	dd800815 	stw	r22,32(sp)
8112b700:	002d883a 	mov	r22,zero
8112b704:	003d8e06 	br	8112ad40 <__reset+0xfb10ad40>
8112b708:	d9000517 	ldw	r4,20(sp)
8112b70c:	11223c80 	call	811223c8 <__floatsidf>
8112b710:	100d883a 	mov	r6,r2
8112b714:	180f883a 	mov	r7,r3
8112b718:	a009883a 	mov	r4,r20
8112b71c:	880b883a 	mov	r5,r17
8112b720:	11373280 	call	81137328 <__eqdf2>
8112b724:	103d7126 	beq	r2,zero,8112acec <__reset+0xfb10acec>
8112b728:	d9c00517 	ldw	r7,20(sp)
8112b72c:	39ffffc4 	addi	r7,r7,-1
8112b730:	d9c00515 	stw	r7,20(sp)
8112b734:	003d6d06 	br	8112acec <__reset+0xfb10acec>
8112b738:	dd400a17 	ldw	r21,40(sp)
8112b73c:	dd000817 	ldw	r20,32(sp)
8112b740:	0023883a 	mov	r17,zero
8112b744:	003f4806 	br	8112b468 <__reset+0xfb10b468>
8112b748:	10e3c83a 	sub	r17,r2,r3
8112b74c:	9448983a 	sll	r4,r18,r17
8112b750:	003d3206 	br	8112ac1c <__reset+0xfb10ac1c>
8112b754:	d8000e15 	stw	zero,56(sp)
8112b758:	003d7506 	br	8112ad30 <__reset+0xfb10ad30>
8112b75c:	b005883a 	mov	r2,r22
8112b760:	003f4506 	br	8112b478 <__reset+0xfb10b478>
8112b764:	dc000915 	stw	r16,36(sp)
8112b768:	d9800a17 	ldw	r6,40(sp)
8112b76c:	d9400917 	ldw	r5,36(sp)
8112b770:	e009883a 	mov	r4,fp
8112b774:	112e1f80 	call	8112e1f8 <__pow5mult>
8112b778:	1021883a 	mov	r16,r2
8112b77c:	003f5a06 	br	8112b4e8 <__reset+0xfb10b4e8>
8112b780:	01c00044 	movi	r7,1
8112b784:	d9c00b15 	stw	r7,44(sp)
8112b788:	d8802217 	ldw	r2,136(sp)
8112b78c:	0081280e 	bge	zero,r2,8112bc30 <_dtoa_r+0x11b8>
8112b790:	100d883a 	mov	r6,r2
8112b794:	1021883a 	mov	r16,r2
8112b798:	d8800c15 	stw	r2,48(sp)
8112b79c:	d8800615 	stw	r2,24(sp)
8112b7a0:	003d8806 	br	8112adc4 <__reset+0xfb10adc4>
8112b7a4:	d8800617 	ldw	r2,24(sp)
8112b7a8:	00be9b16 	blt	zero,r2,8112b218 <__reset+0xfb10b218>
8112b7ac:	10010f1e 	bne	r2,zero,8112bbec <_dtoa_r+0x1174>
8112b7b0:	880b883a 	mov	r5,r17
8112b7b4:	000d883a 	mov	r6,zero
8112b7b8:	01d00534 	movhi	r7,16404
8112b7bc:	8009883a 	mov	r4,r16
8112b7c0:	11213240 	call	81121324 <__muldf3>
8112b7c4:	900d883a 	mov	r6,r18
8112b7c8:	980f883a 	mov	r7,r19
8112b7cc:	1009883a 	mov	r4,r2
8112b7d0:	180b883a 	mov	r5,r3
8112b7d4:	11212480 	call	81121248 <__gedf2>
8112b7d8:	002b883a 	mov	r21,zero
8112b7dc:	0023883a 	mov	r17,zero
8112b7e0:	1000bf16 	blt	r2,zero,8112bae0 <_dtoa_r+0x1068>
8112b7e4:	d9802217 	ldw	r6,136(sp)
8112b7e8:	ddc00717 	ldw	r23,28(sp)
8112b7ec:	018c303a 	nor	r6,zero,r6
8112b7f0:	d9800515 	stw	r6,20(sp)
8112b7f4:	a80b883a 	mov	r5,r21
8112b7f8:	e009883a 	mov	r4,fp
8112b7fc:	112dc400 	call	8112dc40 <_Bfree>
8112b800:	883e4926 	beq	r17,zero,8112b128 <__reset+0xfb10b128>
8112b804:	003fad06 	br	8112b6bc <__reset+0xfb10b6bc>
8112b808:	d9c01117 	ldw	r7,68(sp)
8112b80c:	3801bc26 	beq	r7,zero,8112bf00 <_dtoa_r+0x1488>
8112b810:	10810cc4 	addi	r2,r2,1075
8112b814:	dd400a17 	ldw	r21,40(sp)
8112b818:	dd000817 	ldw	r20,32(sp)
8112b81c:	003f0a06 	br	8112b448 <__reset+0xfb10b448>
8112b820:	00800704 	movi	r2,28
8112b824:	d9000817 	ldw	r4,32(sp)
8112b828:	a0a9883a 	add	r20,r20,r2
8112b82c:	b0ad883a 	add	r22,r22,r2
8112b830:	2089883a 	add	r4,r4,r2
8112b834:	d9000815 	stw	r4,32(sp)
8112b838:	003f5106 	br	8112b580 <__reset+0xfb10b580>
8112b83c:	d8c00317 	ldw	r3,12(sp)
8112b840:	b8c1fc0e 	bge	r23,r3,8112c034 <_dtoa_r+0x15bc>
8112b844:	0027883a 	mov	r19,zero
8112b848:	b805883a 	mov	r2,r23
8112b84c:	003f3e06 	br	8112b548 <__reset+0xfb10b548>
8112b850:	880b883a 	mov	r5,r17
8112b854:	e009883a 	mov	r4,fp
8112b858:	000f883a 	mov	r7,zero
8112b85c:	01800284 	movi	r6,10
8112b860:	112dc680 	call	8112dc68 <__multadd>
8112b864:	d9000c17 	ldw	r4,48(sp)
8112b868:	1023883a 	mov	r17,r2
8112b86c:	0102040e 	bge	zero,r4,8112c080 <_dtoa_r+0x1608>
8112b870:	d9000615 	stw	r4,24(sp)
8112b874:	0500050e 	bge	zero,r20,8112b88c <_dtoa_r+0xe14>
8112b878:	880b883a 	mov	r5,r17
8112b87c:	a00d883a 	mov	r6,r20
8112b880:	e009883a 	mov	r4,fp
8112b884:	112e3400 	call	8112e340 <__lshift>
8112b888:	1023883a 	mov	r17,r2
8112b88c:	9801241e 	bne	r19,zero,8112bd20 <_dtoa_r+0x12a8>
8112b890:	8829883a 	mov	r20,r17
8112b894:	d9000617 	ldw	r4,24(sp)
8112b898:	dcc00717 	ldw	r19,28(sp)
8112b89c:	9480004c 	andi	r18,r18,1
8112b8a0:	20bfffc4 	addi	r2,r4,-1
8112b8a4:	9885883a 	add	r2,r19,r2
8112b8a8:	d8800415 	stw	r2,16(sp)
8112b8ac:	dc800615 	stw	r18,24(sp)
8112b8b0:	a80b883a 	mov	r5,r21
8112b8b4:	8009883a 	mov	r4,r16
8112b8b8:	112a8700 	call	8112a870 <quorem>
8112b8bc:	880b883a 	mov	r5,r17
8112b8c0:	8009883a 	mov	r4,r16
8112b8c4:	102f883a 	mov	r23,r2
8112b8c8:	112e4900 	call	8112e490 <__mcmp>
8112b8cc:	a80b883a 	mov	r5,r21
8112b8d0:	a00d883a 	mov	r6,r20
8112b8d4:	e009883a 	mov	r4,fp
8112b8d8:	102d883a 	mov	r22,r2
8112b8dc:	112e4f00 	call	8112e4f0 <__mdiff>
8112b8e0:	1007883a 	mov	r3,r2
8112b8e4:	10800317 	ldw	r2,12(r2)
8112b8e8:	bc800c04 	addi	r18,r23,48
8112b8ec:	180b883a 	mov	r5,r3
8112b8f0:	10004e1e 	bne	r2,zero,8112ba2c <_dtoa_r+0xfb4>
8112b8f4:	8009883a 	mov	r4,r16
8112b8f8:	d8c01615 	stw	r3,88(sp)
8112b8fc:	112e4900 	call	8112e490 <__mcmp>
8112b900:	d8c01617 	ldw	r3,88(sp)
8112b904:	e009883a 	mov	r4,fp
8112b908:	d8801615 	stw	r2,88(sp)
8112b90c:	180b883a 	mov	r5,r3
8112b910:	112dc400 	call	8112dc40 <_Bfree>
8112b914:	d8801617 	ldw	r2,88(sp)
8112b918:	1000041e 	bne	r2,zero,8112b92c <_dtoa_r+0xeb4>
8112b91c:	d9800317 	ldw	r6,12(sp)
8112b920:	3000021e 	bne	r6,zero,8112b92c <_dtoa_r+0xeb4>
8112b924:	d8c00617 	ldw	r3,24(sp)
8112b928:	18003726 	beq	r3,zero,8112ba08 <_dtoa_r+0xf90>
8112b92c:	b0002016 	blt	r22,zero,8112b9b0 <_dtoa_r+0xf38>
8112b930:	b000041e 	bne	r22,zero,8112b944 <_dtoa_r+0xecc>
8112b934:	d9000317 	ldw	r4,12(sp)
8112b938:	2000021e 	bne	r4,zero,8112b944 <_dtoa_r+0xecc>
8112b93c:	d8c00617 	ldw	r3,24(sp)
8112b940:	18001b26 	beq	r3,zero,8112b9b0 <_dtoa_r+0xf38>
8112b944:	00810716 	blt	zero,r2,8112bd64 <_dtoa_r+0x12ec>
8112b948:	d8c00417 	ldw	r3,16(sp)
8112b94c:	9d800044 	addi	r22,r19,1
8112b950:	9c800005 	stb	r18,0(r19)
8112b954:	b02f883a 	mov	r23,r22
8112b958:	98c10626 	beq	r19,r3,8112bd74 <_dtoa_r+0x12fc>
8112b95c:	800b883a 	mov	r5,r16
8112b960:	000f883a 	mov	r7,zero
8112b964:	01800284 	movi	r6,10
8112b968:	e009883a 	mov	r4,fp
8112b96c:	112dc680 	call	8112dc68 <__multadd>
8112b970:	1021883a 	mov	r16,r2
8112b974:	000f883a 	mov	r7,zero
8112b978:	01800284 	movi	r6,10
8112b97c:	880b883a 	mov	r5,r17
8112b980:	e009883a 	mov	r4,fp
8112b984:	8d002526 	beq	r17,r20,8112ba1c <_dtoa_r+0xfa4>
8112b988:	112dc680 	call	8112dc68 <__multadd>
8112b98c:	a00b883a 	mov	r5,r20
8112b990:	000f883a 	mov	r7,zero
8112b994:	01800284 	movi	r6,10
8112b998:	e009883a 	mov	r4,fp
8112b99c:	1023883a 	mov	r17,r2
8112b9a0:	112dc680 	call	8112dc68 <__multadd>
8112b9a4:	1029883a 	mov	r20,r2
8112b9a8:	b027883a 	mov	r19,r22
8112b9ac:	003fc006 	br	8112b8b0 <__reset+0xfb10b8b0>
8112b9b0:	9011883a 	mov	r8,r18
8112b9b4:	00800e0e 	bge	zero,r2,8112b9f0 <_dtoa_r+0xf78>
8112b9b8:	800b883a 	mov	r5,r16
8112b9bc:	01800044 	movi	r6,1
8112b9c0:	e009883a 	mov	r4,fp
8112b9c4:	da001715 	stw	r8,92(sp)
8112b9c8:	112e3400 	call	8112e340 <__lshift>
8112b9cc:	a80b883a 	mov	r5,r21
8112b9d0:	1009883a 	mov	r4,r2
8112b9d4:	1021883a 	mov	r16,r2
8112b9d8:	112e4900 	call	8112e490 <__mcmp>
8112b9dc:	da001717 	ldw	r8,92(sp)
8112b9e0:	0081960e 	bge	zero,r2,8112c03c <_dtoa_r+0x15c4>
8112b9e4:	00800e44 	movi	r2,57
8112b9e8:	40817026 	beq	r8,r2,8112bfac <_dtoa_r+0x1534>
8112b9ec:	ba000c44 	addi	r8,r23,49
8112b9f0:	8825883a 	mov	r18,r17
8112b9f4:	9dc00044 	addi	r23,r19,1
8112b9f8:	9a000005 	stb	r8,0(r19)
8112b9fc:	a023883a 	mov	r17,r20
8112ba00:	dc000915 	stw	r16,36(sp)
8112ba04:	003f2406 	br	8112b698 <__reset+0xfb10b698>
8112ba08:	00800e44 	movi	r2,57
8112ba0c:	9011883a 	mov	r8,r18
8112ba10:	90816626 	beq	r18,r2,8112bfac <_dtoa_r+0x1534>
8112ba14:	05bff516 	blt	zero,r22,8112b9ec <__reset+0xfb10b9ec>
8112ba18:	003ff506 	br	8112b9f0 <__reset+0xfb10b9f0>
8112ba1c:	112dc680 	call	8112dc68 <__multadd>
8112ba20:	1023883a 	mov	r17,r2
8112ba24:	1029883a 	mov	r20,r2
8112ba28:	003fdf06 	br	8112b9a8 <__reset+0xfb10b9a8>
8112ba2c:	e009883a 	mov	r4,fp
8112ba30:	112dc400 	call	8112dc40 <_Bfree>
8112ba34:	00800044 	movi	r2,1
8112ba38:	003fbc06 	br	8112b92c <__reset+0xfb10b92c>
8112ba3c:	a80b883a 	mov	r5,r21
8112ba40:	8009883a 	mov	r4,r16
8112ba44:	112e4900 	call	8112e490 <__mcmp>
8112ba48:	103edb0e 	bge	r2,zero,8112b5b8 <__reset+0xfb10b5b8>
8112ba4c:	800b883a 	mov	r5,r16
8112ba50:	000f883a 	mov	r7,zero
8112ba54:	01800284 	movi	r6,10
8112ba58:	e009883a 	mov	r4,fp
8112ba5c:	112dc680 	call	8112dc68 <__multadd>
8112ba60:	1021883a 	mov	r16,r2
8112ba64:	d8800517 	ldw	r2,20(sp)
8112ba68:	d8c00b17 	ldw	r3,44(sp)
8112ba6c:	10bfffc4 	addi	r2,r2,-1
8112ba70:	d8800515 	stw	r2,20(sp)
8112ba74:	183f761e 	bne	r3,zero,8112b850 <__reset+0xfb10b850>
8112ba78:	d9000c17 	ldw	r4,48(sp)
8112ba7c:	0101730e 	bge	zero,r4,8112c04c <_dtoa_r+0x15d4>
8112ba80:	d9000615 	stw	r4,24(sp)
8112ba84:	003ed006 	br	8112b5c8 <__reset+0xfb10b5c8>
8112ba88:	00800084 	movi	r2,2
8112ba8c:	3081861e 	bne	r6,r2,8112c0a8 <_dtoa_r+0x1630>
8112ba90:	d8000b15 	stw	zero,44(sp)
8112ba94:	003f3c06 	br	8112b788 <__reset+0xfb10b788>
8112ba98:	dc000917 	ldw	r16,36(sp)
8112ba9c:	003e9206 	br	8112b4e8 <__reset+0xfb10b4e8>
8112baa0:	d9c00317 	ldw	r7,12(sp)
8112baa4:	00800084 	movi	r2,2
8112baa8:	11fec50e 	bge	r2,r7,8112b5c0 <__reset+0xfb10b5c0>
8112baac:	d9000617 	ldw	r4,24(sp)
8112bab0:	20013c1e 	bne	r4,zero,8112bfa4 <_dtoa_r+0x152c>
8112bab4:	a80b883a 	mov	r5,r21
8112bab8:	000f883a 	mov	r7,zero
8112babc:	01800144 	movi	r6,5
8112bac0:	e009883a 	mov	r4,fp
8112bac4:	112dc680 	call	8112dc68 <__multadd>
8112bac8:	100b883a 	mov	r5,r2
8112bacc:	8009883a 	mov	r4,r16
8112bad0:	102b883a 	mov	r21,r2
8112bad4:	112e4900 	call	8112e490 <__mcmp>
8112bad8:	dc000915 	stw	r16,36(sp)
8112badc:	00bf410e 	bge	zero,r2,8112b7e4 <__reset+0xfb10b7e4>
8112bae0:	d9c00717 	ldw	r7,28(sp)
8112bae4:	00800c44 	movi	r2,49
8112bae8:	38800005 	stb	r2,0(r7)
8112baec:	d8800517 	ldw	r2,20(sp)
8112baf0:	3dc00044 	addi	r23,r7,1
8112baf4:	10800044 	addi	r2,r2,1
8112baf8:	d8800515 	stw	r2,20(sp)
8112bafc:	003f3d06 	br	8112b7f4 <__reset+0xfb10b7f4>
8112bb00:	d9800517 	ldw	r6,20(sp)
8112bb04:	d9c00717 	ldw	r7,28(sp)
8112bb08:	00800c44 	movi	r2,49
8112bb0c:	31800044 	addi	r6,r6,1
8112bb10:	d9800515 	stw	r6,20(sp)
8112bb14:	38800005 	stb	r2,0(r7)
8112bb18:	003edf06 	br	8112b698 <__reset+0xfb10b698>
8112bb1c:	d8000b15 	stw	zero,44(sp)
8112bb20:	003c9f06 	br	8112ada0 <__reset+0xfb10ada0>
8112bb24:	903e7e1e 	bne	r18,zero,8112b520 <__reset+0xfb10b520>
8112bb28:	00800434 	movhi	r2,16
8112bb2c:	10bfffc4 	addi	r2,r2,-1
8112bb30:	9884703a 	and	r2,r19,r2
8112bb34:	1000ea1e 	bne	r2,zero,8112bee0 <_dtoa_r+0x1468>
8112bb38:	9cdffc2c 	andhi	r19,r19,32752
8112bb3c:	9800e826 	beq	r19,zero,8112bee0 <_dtoa_r+0x1468>
8112bb40:	d9c00817 	ldw	r7,32(sp)
8112bb44:	b5800044 	addi	r22,r22,1
8112bb48:	04c00044 	movi	r19,1
8112bb4c:	39c00044 	addi	r7,r7,1
8112bb50:	d9c00815 	stw	r7,32(sp)
8112bb54:	d8800d17 	ldw	r2,52(sp)
8112bb58:	103e721e 	bne	r2,zero,8112b524 <__reset+0xfb10b524>
8112bb5c:	00800044 	movi	r2,1
8112bb60:	003e7906 	br	8112b548 <__reset+0xfb10b548>
8112bb64:	8009883a 	mov	r4,r16
8112bb68:	11223c80 	call	811223c8 <__floatsidf>
8112bb6c:	d9800f17 	ldw	r6,60(sp)
8112bb70:	d9c01017 	ldw	r7,64(sp)
8112bb74:	1009883a 	mov	r4,r2
8112bb78:	180b883a 	mov	r5,r3
8112bb7c:	11213240 	call	81121324 <__muldf3>
8112bb80:	000d883a 	mov	r6,zero
8112bb84:	01d00734 	movhi	r7,16412
8112bb88:	1009883a 	mov	r4,r2
8112bb8c:	180b883a 	mov	r5,r3
8112bb90:	11361840 	call	81136184 <__adddf3>
8112bb94:	047f3034 	movhi	r17,64704
8112bb98:	1021883a 	mov	r16,r2
8112bb9c:	1c63883a 	add	r17,r3,r17
8112bba0:	d9000f17 	ldw	r4,60(sp)
8112bba4:	d9401017 	ldw	r5,64(sp)
8112bba8:	000d883a 	mov	r6,zero
8112bbac:	01d00534 	movhi	r7,16404
8112bbb0:	1121a440 	call	81121a44 <__subdf3>
8112bbb4:	800d883a 	mov	r6,r16
8112bbb8:	880f883a 	mov	r7,r17
8112bbbc:	1009883a 	mov	r4,r2
8112bbc0:	180b883a 	mov	r5,r3
8112bbc4:	102b883a 	mov	r21,r2
8112bbc8:	1829883a 	mov	r20,r3
8112bbcc:	11212480 	call	81121248 <__gedf2>
8112bbd0:	00806c16 	blt	zero,r2,8112bd84 <_dtoa_r+0x130c>
8112bbd4:	89e0003c 	xorhi	r7,r17,32768
8112bbd8:	800d883a 	mov	r6,r16
8112bbdc:	a809883a 	mov	r4,r21
8112bbe0:	a00b883a 	mov	r5,r20
8112bbe4:	11373b00 	call	811373b0 <__ledf2>
8112bbe8:	103d7e0e 	bge	r2,zero,8112b1e4 <__reset+0xfb10b1e4>
8112bbec:	002b883a 	mov	r21,zero
8112bbf0:	0023883a 	mov	r17,zero
8112bbf4:	003efb06 	br	8112b7e4 <__reset+0xfb10b7e4>
8112bbf8:	d8800717 	ldw	r2,28(sp)
8112bbfc:	003bd006 	br	8112ab40 <__reset+0xfb10ab40>
8112bc00:	d9000a17 	ldw	r4,40(sp)
8112bc04:	d9800d17 	ldw	r6,52(sp)
8112bc08:	dd400a15 	stw	r21,40(sp)
8112bc0c:	a905c83a 	sub	r2,r21,r4
8112bc10:	308d883a 	add	r6,r6,r2
8112bc14:	d9800d15 	stw	r6,52(sp)
8112bc18:	002b883a 	mov	r21,zero
8112bc1c:	003e0606 	br	8112b438 <__reset+0xfb10b438>
8112bc20:	9023883a 	mov	r17,r18
8112bc24:	9829883a 	mov	r20,r19
8112bc28:	04000084 	movi	r16,2
8112bc2c:	003c9206 	br	8112ae78 <__reset+0xfb10ae78>
8112bc30:	04000044 	movi	r16,1
8112bc34:	dc000c15 	stw	r16,48(sp)
8112bc38:	dc000615 	stw	r16,24(sp)
8112bc3c:	dc002215 	stw	r16,136(sp)
8112bc40:	e0001115 	stw	zero,68(fp)
8112bc44:	000b883a 	mov	r5,zero
8112bc48:	003c6906 	br	8112adf0 <__reset+0xfb10adf0>
8112bc4c:	3021883a 	mov	r16,r6
8112bc50:	003ffb06 	br	8112bc40 <__reset+0xfb10bc40>
8112bc54:	1000021e 	bne	r2,zero,8112bc60 <_dtoa_r+0x11e8>
8112bc58:	4200004c 	andi	r8,r8,1
8112bc5c:	403e7d1e 	bne	r8,zero,8112b654 <__reset+0xfb10b654>
8112bc60:	01000c04 	movi	r4,48
8112bc64:	00000106 	br	8112bc6c <_dtoa_r+0x11f4>
8112bc68:	102f883a 	mov	r23,r2
8112bc6c:	b8bfffc4 	addi	r2,r23,-1
8112bc70:	10c00007 	ldb	r3,0(r2)
8112bc74:	193ffc26 	beq	r3,r4,8112bc68 <__reset+0xfb10bc68>
8112bc78:	003e8706 	br	8112b698 <__reset+0xfb10b698>
8112bc7c:	d8800517 	ldw	r2,20(sp)
8112bc80:	00a3c83a 	sub	r17,zero,r2
8112bc84:	8800a426 	beq	r17,zero,8112bf18 <_dtoa_r+0x14a0>
8112bc88:	888003cc 	andi	r2,r17,15
8112bc8c:	100490fa 	slli	r2,r2,3
8112bc90:	00e04574 	movhi	r3,33045
8112bc94:	18c76204 	addi	r3,r3,7560
8112bc98:	1885883a 	add	r2,r3,r2
8112bc9c:	11800017 	ldw	r6,0(r2)
8112bca0:	11c00117 	ldw	r7,4(r2)
8112bca4:	9009883a 	mov	r4,r18
8112bca8:	980b883a 	mov	r5,r19
8112bcac:	8823d13a 	srai	r17,r17,4
8112bcb0:	11213240 	call	81121324 <__muldf3>
8112bcb4:	d8800f15 	stw	r2,60(sp)
8112bcb8:	d8c01015 	stw	r3,64(sp)
8112bcbc:	8800e826 	beq	r17,zero,8112c060 <_dtoa_r+0x15e8>
8112bcc0:	05204574 	movhi	r20,33045
8112bcc4:	a5075804 	addi	r20,r20,7520
8112bcc8:	04000084 	movi	r16,2
8112bccc:	8980004c 	andi	r6,r17,1
8112bcd0:	1009883a 	mov	r4,r2
8112bcd4:	8823d07a 	srai	r17,r17,1
8112bcd8:	180b883a 	mov	r5,r3
8112bcdc:	30000426 	beq	r6,zero,8112bcf0 <_dtoa_r+0x1278>
8112bce0:	a1800017 	ldw	r6,0(r20)
8112bce4:	a1c00117 	ldw	r7,4(r20)
8112bce8:	84000044 	addi	r16,r16,1
8112bcec:	11213240 	call	81121324 <__muldf3>
8112bcf0:	a5000204 	addi	r20,r20,8
8112bcf4:	883ff51e 	bne	r17,zero,8112bccc <__reset+0xfb10bccc>
8112bcf8:	d8800f15 	stw	r2,60(sp)
8112bcfc:	d8c01015 	stw	r3,64(sp)
8112bd00:	003c7606 	br	8112aedc <__reset+0xfb10aedc>
8112bd04:	00c00c04 	movi	r3,48
8112bd08:	10c00005 	stb	r3,0(r2)
8112bd0c:	d8c00517 	ldw	r3,20(sp)
8112bd10:	bd3fffc3 	ldbu	r20,-1(r23)
8112bd14:	18c00044 	addi	r3,r3,1
8112bd18:	d8c00515 	stw	r3,20(sp)
8112bd1c:	003db906 	br	8112b404 <__reset+0xfb10b404>
8112bd20:	89400117 	ldw	r5,4(r17)
8112bd24:	e009883a 	mov	r4,fp
8112bd28:	112db900 	call	8112db90 <_Balloc>
8112bd2c:	89800417 	ldw	r6,16(r17)
8112bd30:	89400304 	addi	r5,r17,12
8112bd34:	11000304 	addi	r4,r2,12
8112bd38:	31800084 	addi	r6,r6,2
8112bd3c:	318d883a 	add	r6,r6,r6
8112bd40:	318d883a 	add	r6,r6,r6
8112bd44:	1027883a 	mov	r19,r2
8112bd48:	11239dc0 	call	811239dc <memcpy>
8112bd4c:	01800044 	movi	r6,1
8112bd50:	980b883a 	mov	r5,r19
8112bd54:	e009883a 	mov	r4,fp
8112bd58:	112e3400 	call	8112e340 <__lshift>
8112bd5c:	1029883a 	mov	r20,r2
8112bd60:	003ecc06 	br	8112b894 <__reset+0xfb10b894>
8112bd64:	00800e44 	movi	r2,57
8112bd68:	90809026 	beq	r18,r2,8112bfac <_dtoa_r+0x1534>
8112bd6c:	92000044 	addi	r8,r18,1
8112bd70:	003f1f06 	br	8112b9f0 <__reset+0xfb10b9f0>
8112bd74:	9011883a 	mov	r8,r18
8112bd78:	8825883a 	mov	r18,r17
8112bd7c:	a023883a 	mov	r17,r20
8112bd80:	003e2906 	br	8112b628 <__reset+0xfb10b628>
8112bd84:	002b883a 	mov	r21,zero
8112bd88:	0023883a 	mov	r17,zero
8112bd8c:	003f5406 	br	8112bae0 <__reset+0xfb10bae0>
8112bd90:	61bfffc4 	addi	r6,r12,-1
8112bd94:	300490fa 	slli	r2,r6,3
8112bd98:	00e04574 	movhi	r3,33045
8112bd9c:	18c76204 	addi	r3,r3,7560
8112bda0:	1885883a 	add	r2,r3,r2
8112bda4:	11000017 	ldw	r4,0(r2)
8112bda8:	11400117 	ldw	r5,4(r2)
8112bdac:	d8800717 	ldw	r2,28(sp)
8112bdb0:	880f883a 	mov	r7,r17
8112bdb4:	d9801215 	stw	r6,72(sp)
8112bdb8:	800d883a 	mov	r6,r16
8112bdbc:	db001615 	stw	r12,88(sp)
8112bdc0:	15c00044 	addi	r23,r2,1
8112bdc4:	11213240 	call	81121324 <__muldf3>
8112bdc8:	d9401017 	ldw	r5,64(sp)
8112bdcc:	d9000f17 	ldw	r4,60(sp)
8112bdd0:	d8c01515 	stw	r3,84(sp)
8112bdd4:	d8801415 	stw	r2,80(sp)
8112bdd8:	11223480 	call	81122348 <__fixdfsi>
8112bddc:	1009883a 	mov	r4,r2
8112bde0:	1021883a 	mov	r16,r2
8112bde4:	11223c80 	call	811223c8 <__floatsidf>
8112bde8:	d9000f17 	ldw	r4,60(sp)
8112bdec:	d9401017 	ldw	r5,64(sp)
8112bdf0:	100d883a 	mov	r6,r2
8112bdf4:	180f883a 	mov	r7,r3
8112bdf8:	1121a440 	call	81121a44 <__subdf3>
8112bdfc:	1829883a 	mov	r20,r3
8112be00:	d8c00717 	ldw	r3,28(sp)
8112be04:	84000c04 	addi	r16,r16,48
8112be08:	1023883a 	mov	r17,r2
8112be0c:	1c000005 	stb	r16,0(r3)
8112be10:	db001617 	ldw	r12,88(sp)
8112be14:	00800044 	movi	r2,1
8112be18:	60802226 	beq	r12,r2,8112bea4 <_dtoa_r+0x142c>
8112be1c:	d9c00717 	ldw	r7,28(sp)
8112be20:	8805883a 	mov	r2,r17
8112be24:	b82b883a 	mov	r21,r23
8112be28:	3b19883a 	add	r12,r7,r12
8112be2c:	6023883a 	mov	r17,r12
8112be30:	a007883a 	mov	r3,r20
8112be34:	dc800f15 	stw	r18,60(sp)
8112be38:	000d883a 	mov	r6,zero
8112be3c:	01d00934 	movhi	r7,16420
8112be40:	1009883a 	mov	r4,r2
8112be44:	180b883a 	mov	r5,r3
8112be48:	11213240 	call	81121324 <__muldf3>
8112be4c:	180b883a 	mov	r5,r3
8112be50:	1009883a 	mov	r4,r2
8112be54:	1829883a 	mov	r20,r3
8112be58:	1025883a 	mov	r18,r2
8112be5c:	11223480 	call	81122348 <__fixdfsi>
8112be60:	1009883a 	mov	r4,r2
8112be64:	1021883a 	mov	r16,r2
8112be68:	11223c80 	call	811223c8 <__floatsidf>
8112be6c:	100d883a 	mov	r6,r2
8112be70:	180f883a 	mov	r7,r3
8112be74:	9009883a 	mov	r4,r18
8112be78:	a00b883a 	mov	r5,r20
8112be7c:	84000c04 	addi	r16,r16,48
8112be80:	1121a440 	call	81121a44 <__subdf3>
8112be84:	ad400044 	addi	r21,r21,1
8112be88:	ac3fffc5 	stb	r16,-1(r21)
8112be8c:	ac7fea1e 	bne	r21,r17,8112be38 <__reset+0xfb10be38>
8112be90:	1023883a 	mov	r17,r2
8112be94:	d8801217 	ldw	r2,72(sp)
8112be98:	dc800f17 	ldw	r18,60(sp)
8112be9c:	1829883a 	mov	r20,r3
8112bea0:	b8af883a 	add	r23,r23,r2
8112bea4:	d9001417 	ldw	r4,80(sp)
8112bea8:	d9401517 	ldw	r5,84(sp)
8112beac:	000d883a 	mov	r6,zero
8112beb0:	01cff834 	movhi	r7,16352
8112beb4:	11361840 	call	81136184 <__adddf3>
8112beb8:	880d883a 	mov	r6,r17
8112bebc:	a00f883a 	mov	r7,r20
8112bec0:	1009883a 	mov	r4,r2
8112bec4:	180b883a 	mov	r5,r3
8112bec8:	11373b00 	call	811373b0 <__ledf2>
8112becc:	10003e0e 	bge	r2,zero,8112bfc8 <_dtoa_r+0x1550>
8112bed0:	d9001317 	ldw	r4,76(sp)
8112bed4:	bd3fffc3 	ldbu	r20,-1(r23)
8112bed8:	d9000515 	stw	r4,20(sp)
8112bedc:	003d3b06 	br	8112b3cc <__reset+0xfb10b3cc>
8112bee0:	0027883a 	mov	r19,zero
8112bee4:	003f1b06 	br	8112bb54 <__reset+0xfb10bb54>
8112bee8:	d8800817 	ldw	r2,32(sp)
8112beec:	11e9c83a 	sub	r20,r2,r7
8112bef0:	0005883a 	mov	r2,zero
8112bef4:	003d5406 	br	8112b448 <__reset+0xfb10b448>
8112bef8:	00800044 	movi	r2,1
8112befc:	003dc706 	br	8112b61c <__reset+0xfb10b61c>
8112bf00:	d8c00217 	ldw	r3,8(sp)
8112bf04:	00800d84 	movi	r2,54
8112bf08:	dd400a17 	ldw	r21,40(sp)
8112bf0c:	10c5c83a 	sub	r2,r2,r3
8112bf10:	dd000817 	ldw	r20,32(sp)
8112bf14:	003d4c06 	br	8112b448 <__reset+0xfb10b448>
8112bf18:	dc800f15 	stw	r18,60(sp)
8112bf1c:	dcc01015 	stw	r19,64(sp)
8112bf20:	04000084 	movi	r16,2
8112bf24:	003bed06 	br	8112aedc <__reset+0xfb10aedc>
8112bf28:	d9000617 	ldw	r4,24(sp)
8112bf2c:	203f0d26 	beq	r4,zero,8112bb64 <__reset+0xfb10bb64>
8112bf30:	d9800c17 	ldw	r6,48(sp)
8112bf34:	01bcab0e 	bge	zero,r6,8112b1e4 <__reset+0xfb10b1e4>
8112bf38:	d9401017 	ldw	r5,64(sp)
8112bf3c:	d9000f17 	ldw	r4,60(sp)
8112bf40:	000d883a 	mov	r6,zero
8112bf44:	01d00934 	movhi	r7,16420
8112bf48:	11213240 	call	81121324 <__muldf3>
8112bf4c:	81000044 	addi	r4,r16,1
8112bf50:	d8800f15 	stw	r2,60(sp)
8112bf54:	d8c01015 	stw	r3,64(sp)
8112bf58:	11223c80 	call	811223c8 <__floatsidf>
8112bf5c:	d9800f17 	ldw	r6,60(sp)
8112bf60:	d9c01017 	ldw	r7,64(sp)
8112bf64:	1009883a 	mov	r4,r2
8112bf68:	180b883a 	mov	r5,r3
8112bf6c:	11213240 	call	81121324 <__muldf3>
8112bf70:	01d00734 	movhi	r7,16412
8112bf74:	000d883a 	mov	r6,zero
8112bf78:	1009883a 	mov	r4,r2
8112bf7c:	180b883a 	mov	r5,r3
8112bf80:	11361840 	call	81136184 <__adddf3>
8112bf84:	d9c00517 	ldw	r7,20(sp)
8112bf88:	047f3034 	movhi	r17,64704
8112bf8c:	1021883a 	mov	r16,r2
8112bf90:	39ffffc4 	addi	r7,r7,-1
8112bf94:	d9c01315 	stw	r7,76(sp)
8112bf98:	1c63883a 	add	r17,r3,r17
8112bf9c:	db000c17 	ldw	r12,48(sp)
8112bfa0:	003bea06 	br	8112af4c <__reset+0xfb10af4c>
8112bfa4:	dc000915 	stw	r16,36(sp)
8112bfa8:	003e0e06 	br	8112b7e4 <__reset+0xfb10b7e4>
8112bfac:	01000e44 	movi	r4,57
8112bfb0:	8825883a 	mov	r18,r17
8112bfb4:	9dc00044 	addi	r23,r19,1
8112bfb8:	99000005 	stb	r4,0(r19)
8112bfbc:	a023883a 	mov	r17,r20
8112bfc0:	dc000915 	stw	r16,36(sp)
8112bfc4:	003da406 	br	8112b658 <__reset+0xfb10b658>
8112bfc8:	d9801417 	ldw	r6,80(sp)
8112bfcc:	d9c01517 	ldw	r7,84(sp)
8112bfd0:	0009883a 	mov	r4,zero
8112bfd4:	014ff834 	movhi	r5,16352
8112bfd8:	1121a440 	call	81121a44 <__subdf3>
8112bfdc:	880d883a 	mov	r6,r17
8112bfe0:	a00f883a 	mov	r7,r20
8112bfe4:	1009883a 	mov	r4,r2
8112bfe8:	180b883a 	mov	r5,r3
8112bfec:	11212480 	call	81121248 <__gedf2>
8112bff0:	00bc7c0e 	bge	zero,r2,8112b1e4 <__reset+0xfb10b1e4>
8112bff4:	01000c04 	movi	r4,48
8112bff8:	00000106 	br	8112c000 <_dtoa_r+0x1588>
8112bffc:	102f883a 	mov	r23,r2
8112c000:	b8bfffc4 	addi	r2,r23,-1
8112c004:	10c00007 	ldb	r3,0(r2)
8112c008:	193ffc26 	beq	r3,r4,8112bffc <__reset+0xfb10bffc>
8112c00c:	d9801317 	ldw	r6,76(sp)
8112c010:	d9800515 	stw	r6,20(sp)
8112c014:	003c4406 	br	8112b128 <__reset+0xfb10b128>
8112c018:	d9801317 	ldw	r6,76(sp)
8112c01c:	d9800515 	stw	r6,20(sp)
8112c020:	003cea06 	br	8112b3cc <__reset+0xfb10b3cc>
8112c024:	dd800f17 	ldw	r22,60(sp)
8112c028:	dcc01017 	ldw	r19,64(sp)
8112c02c:	dc801217 	ldw	r18,72(sp)
8112c030:	003c6c06 	br	8112b1e4 <__reset+0xfb10b1e4>
8112c034:	903e031e 	bne	r18,zero,8112b844 <__reset+0xfb10b844>
8112c038:	003ebb06 	br	8112bb28 <__reset+0xfb10bb28>
8112c03c:	103e6c1e 	bne	r2,zero,8112b9f0 <__reset+0xfb10b9f0>
8112c040:	4080004c 	andi	r2,r8,1
8112c044:	103e6a26 	beq	r2,zero,8112b9f0 <__reset+0xfb10b9f0>
8112c048:	003e6606 	br	8112b9e4 <__reset+0xfb10b9e4>
8112c04c:	d8c00317 	ldw	r3,12(sp)
8112c050:	00800084 	movi	r2,2
8112c054:	10c02916 	blt	r2,r3,8112c0fc <_dtoa_r+0x1684>
8112c058:	d9000c17 	ldw	r4,48(sp)
8112c05c:	003e8806 	br	8112ba80 <__reset+0xfb10ba80>
8112c060:	04000084 	movi	r16,2
8112c064:	003b9d06 	br	8112aedc <__reset+0xfb10aedc>
8112c068:	d9001317 	ldw	r4,76(sp)
8112c06c:	d9000515 	stw	r4,20(sp)
8112c070:	003cd606 	br	8112b3cc <__reset+0xfb10b3cc>
8112c074:	d8801317 	ldw	r2,76(sp)
8112c078:	d8800515 	stw	r2,20(sp)
8112c07c:	003c2a06 	br	8112b128 <__reset+0xfb10b128>
8112c080:	d9800317 	ldw	r6,12(sp)
8112c084:	00800084 	movi	r2,2
8112c088:	11801516 	blt	r2,r6,8112c0e0 <_dtoa_r+0x1668>
8112c08c:	d9c00c17 	ldw	r7,48(sp)
8112c090:	d9c00615 	stw	r7,24(sp)
8112c094:	003df706 	br	8112b874 <__reset+0xfb10b874>
8112c098:	193d3926 	beq	r3,r4,8112b580 <__reset+0xfb10b580>
8112c09c:	00c00f04 	movi	r3,60
8112c0a0:	1885c83a 	sub	r2,r3,r2
8112c0a4:	003ddf06 	br	8112b824 <__reset+0xfb10b824>
8112c0a8:	e009883a 	mov	r4,fp
8112c0ac:	e0001115 	stw	zero,68(fp)
8112c0b0:	000b883a 	mov	r5,zero
8112c0b4:	112db900 	call	8112db90 <_Balloc>
8112c0b8:	d8800715 	stw	r2,28(sp)
8112c0bc:	d8c00717 	ldw	r3,28(sp)
8112c0c0:	00bfffc4 	movi	r2,-1
8112c0c4:	01000044 	movi	r4,1
8112c0c8:	d8800c15 	stw	r2,48(sp)
8112c0cc:	e0c01015 	stw	r3,64(fp)
8112c0d0:	d9000b15 	stw	r4,44(sp)
8112c0d4:	d8800615 	stw	r2,24(sp)
8112c0d8:	d8002215 	stw	zero,136(sp)
8112c0dc:	003c4106 	br	8112b1e4 <__reset+0xfb10b1e4>
8112c0e0:	d8c00c17 	ldw	r3,48(sp)
8112c0e4:	d8c00615 	stw	r3,24(sp)
8112c0e8:	003e7006 	br	8112baac <__reset+0xfb10baac>
8112c0ec:	04400044 	movi	r17,1
8112c0f0:	003b2006 	br	8112ad74 <__reset+0xfb10ad74>
8112c0f4:	000b883a 	mov	r5,zero
8112c0f8:	003b3d06 	br	8112adf0 <__reset+0xfb10adf0>
8112c0fc:	d8800c17 	ldw	r2,48(sp)
8112c100:	d8800615 	stw	r2,24(sp)
8112c104:	003e6906 	br	8112baac <__reset+0xfb10baac>

8112c108 <__sflush_r>:
8112c108:	defffb04 	addi	sp,sp,-20
8112c10c:	de00012e 	bgeu	sp,et,8112c114 <__sflush_r+0xc>
8112c110:	003b68fa 	trap	3
8112c114:	2880030b 	ldhu	r2,12(r5)
8112c118:	dcc00315 	stw	r19,12(sp)
8112c11c:	dc400115 	stw	r17,4(sp)
8112c120:	dfc00415 	stw	ra,16(sp)
8112c124:	dc800215 	stw	r18,8(sp)
8112c128:	dc000015 	stw	r16,0(sp)
8112c12c:	10c0020c 	andi	r3,r2,8
8112c130:	2823883a 	mov	r17,r5
8112c134:	2027883a 	mov	r19,r4
8112c138:	1800311e 	bne	r3,zero,8112c200 <__sflush_r+0xf8>
8112c13c:	28c00117 	ldw	r3,4(r5)
8112c140:	10820014 	ori	r2,r2,2048
8112c144:	2880030d 	sth	r2,12(r5)
8112c148:	00c04b0e 	bge	zero,r3,8112c278 <__sflush_r+0x170>
8112c14c:	8a000a17 	ldw	r8,40(r17)
8112c150:	40002326 	beq	r8,zero,8112c1e0 <__sflush_r+0xd8>
8112c154:	9c000017 	ldw	r16,0(r19)
8112c158:	10c4000c 	andi	r3,r2,4096
8112c15c:	98000015 	stw	zero,0(r19)
8112c160:	18004826 	beq	r3,zero,8112c284 <__sflush_r+0x17c>
8112c164:	89801417 	ldw	r6,80(r17)
8112c168:	10c0010c 	andi	r3,r2,4
8112c16c:	18000626 	beq	r3,zero,8112c188 <__sflush_r+0x80>
8112c170:	88c00117 	ldw	r3,4(r17)
8112c174:	88800c17 	ldw	r2,48(r17)
8112c178:	30cdc83a 	sub	r6,r6,r3
8112c17c:	10000226 	beq	r2,zero,8112c188 <__sflush_r+0x80>
8112c180:	88800f17 	ldw	r2,60(r17)
8112c184:	308dc83a 	sub	r6,r6,r2
8112c188:	89400717 	ldw	r5,28(r17)
8112c18c:	000f883a 	mov	r7,zero
8112c190:	9809883a 	mov	r4,r19
8112c194:	403ee83a 	callr	r8
8112c198:	00ffffc4 	movi	r3,-1
8112c19c:	10c04426 	beq	r2,r3,8112c2b0 <__sflush_r+0x1a8>
8112c1a0:	88c0030b 	ldhu	r3,12(r17)
8112c1a4:	89000417 	ldw	r4,16(r17)
8112c1a8:	88000115 	stw	zero,4(r17)
8112c1ac:	197dffcc 	andi	r5,r3,63487
8112c1b0:	8940030d 	sth	r5,12(r17)
8112c1b4:	89000015 	stw	r4,0(r17)
8112c1b8:	18c4000c 	andi	r3,r3,4096
8112c1bc:	18002c1e 	bne	r3,zero,8112c270 <__sflush_r+0x168>
8112c1c0:	89400c17 	ldw	r5,48(r17)
8112c1c4:	9c000015 	stw	r16,0(r19)
8112c1c8:	28000526 	beq	r5,zero,8112c1e0 <__sflush_r+0xd8>
8112c1cc:	88801004 	addi	r2,r17,64
8112c1d0:	28800226 	beq	r5,r2,8112c1dc <__sflush_r+0xd4>
8112c1d4:	9809883a 	mov	r4,r19
8112c1d8:	112cbc00 	call	8112cbc0 <_free_r>
8112c1dc:	88000c15 	stw	zero,48(r17)
8112c1e0:	0005883a 	mov	r2,zero
8112c1e4:	dfc00417 	ldw	ra,16(sp)
8112c1e8:	dcc00317 	ldw	r19,12(sp)
8112c1ec:	dc800217 	ldw	r18,8(sp)
8112c1f0:	dc400117 	ldw	r17,4(sp)
8112c1f4:	dc000017 	ldw	r16,0(sp)
8112c1f8:	dec00504 	addi	sp,sp,20
8112c1fc:	f800283a 	ret
8112c200:	2c800417 	ldw	r18,16(r5)
8112c204:	903ff626 	beq	r18,zero,8112c1e0 <__reset+0xfb10c1e0>
8112c208:	2c000017 	ldw	r16,0(r5)
8112c20c:	108000cc 	andi	r2,r2,3
8112c210:	2c800015 	stw	r18,0(r5)
8112c214:	84a1c83a 	sub	r16,r16,r18
8112c218:	1000131e 	bne	r2,zero,8112c268 <__sflush_r+0x160>
8112c21c:	28800517 	ldw	r2,20(r5)
8112c220:	88800215 	stw	r2,8(r17)
8112c224:	04000316 	blt	zero,r16,8112c234 <__sflush_r+0x12c>
8112c228:	003fed06 	br	8112c1e0 <__reset+0xfb10c1e0>
8112c22c:	90a5883a 	add	r18,r18,r2
8112c230:	043feb0e 	bge	zero,r16,8112c1e0 <__reset+0xfb10c1e0>
8112c234:	88800917 	ldw	r2,36(r17)
8112c238:	89400717 	ldw	r5,28(r17)
8112c23c:	800f883a 	mov	r7,r16
8112c240:	900d883a 	mov	r6,r18
8112c244:	9809883a 	mov	r4,r19
8112c248:	103ee83a 	callr	r2
8112c24c:	80a1c83a 	sub	r16,r16,r2
8112c250:	00bff616 	blt	zero,r2,8112c22c <__reset+0xfb10c22c>
8112c254:	88c0030b 	ldhu	r3,12(r17)
8112c258:	00bfffc4 	movi	r2,-1
8112c25c:	18c01014 	ori	r3,r3,64
8112c260:	88c0030d 	sth	r3,12(r17)
8112c264:	003fdf06 	br	8112c1e4 <__reset+0xfb10c1e4>
8112c268:	0005883a 	mov	r2,zero
8112c26c:	003fec06 	br	8112c220 <__reset+0xfb10c220>
8112c270:	88801415 	stw	r2,80(r17)
8112c274:	003fd206 	br	8112c1c0 <__reset+0xfb10c1c0>
8112c278:	28c00f17 	ldw	r3,60(r5)
8112c27c:	00ffb316 	blt	zero,r3,8112c14c <__reset+0xfb10c14c>
8112c280:	003fd706 	br	8112c1e0 <__reset+0xfb10c1e0>
8112c284:	89400717 	ldw	r5,28(r17)
8112c288:	000d883a 	mov	r6,zero
8112c28c:	01c00044 	movi	r7,1
8112c290:	9809883a 	mov	r4,r19
8112c294:	403ee83a 	callr	r8
8112c298:	100d883a 	mov	r6,r2
8112c29c:	00bfffc4 	movi	r2,-1
8112c2a0:	30801426 	beq	r6,r2,8112c2f4 <__sflush_r+0x1ec>
8112c2a4:	8880030b 	ldhu	r2,12(r17)
8112c2a8:	8a000a17 	ldw	r8,40(r17)
8112c2ac:	003fae06 	br	8112c168 <__reset+0xfb10c168>
8112c2b0:	98c00017 	ldw	r3,0(r19)
8112c2b4:	183fba26 	beq	r3,zero,8112c1a0 <__reset+0xfb10c1a0>
8112c2b8:	01000744 	movi	r4,29
8112c2bc:	19000626 	beq	r3,r4,8112c2d8 <__sflush_r+0x1d0>
8112c2c0:	01000584 	movi	r4,22
8112c2c4:	19000426 	beq	r3,r4,8112c2d8 <__sflush_r+0x1d0>
8112c2c8:	88c0030b 	ldhu	r3,12(r17)
8112c2cc:	18c01014 	ori	r3,r3,64
8112c2d0:	88c0030d 	sth	r3,12(r17)
8112c2d4:	003fc306 	br	8112c1e4 <__reset+0xfb10c1e4>
8112c2d8:	8880030b 	ldhu	r2,12(r17)
8112c2dc:	88c00417 	ldw	r3,16(r17)
8112c2e0:	88000115 	stw	zero,4(r17)
8112c2e4:	10bdffcc 	andi	r2,r2,63487
8112c2e8:	8880030d 	sth	r2,12(r17)
8112c2ec:	88c00015 	stw	r3,0(r17)
8112c2f0:	003fb306 	br	8112c1c0 <__reset+0xfb10c1c0>
8112c2f4:	98800017 	ldw	r2,0(r19)
8112c2f8:	103fea26 	beq	r2,zero,8112c2a4 <__reset+0xfb10c2a4>
8112c2fc:	00c00744 	movi	r3,29
8112c300:	10c00226 	beq	r2,r3,8112c30c <__sflush_r+0x204>
8112c304:	00c00584 	movi	r3,22
8112c308:	10c0031e 	bne	r2,r3,8112c318 <__sflush_r+0x210>
8112c30c:	9c000015 	stw	r16,0(r19)
8112c310:	0005883a 	mov	r2,zero
8112c314:	003fb306 	br	8112c1e4 <__reset+0xfb10c1e4>
8112c318:	88c0030b 	ldhu	r3,12(r17)
8112c31c:	3005883a 	mov	r2,r6
8112c320:	18c01014 	ori	r3,r3,64
8112c324:	88c0030d 	sth	r3,12(r17)
8112c328:	003fae06 	br	8112c1e4 <__reset+0xfb10c1e4>

8112c32c <_fflush_r>:
8112c32c:	defffd04 	addi	sp,sp,-12
8112c330:	de00012e 	bgeu	sp,et,8112c338 <_fflush_r+0xc>
8112c334:	003b68fa 	trap	3
8112c338:	dc000115 	stw	r16,4(sp)
8112c33c:	dfc00215 	stw	ra,8(sp)
8112c340:	2021883a 	mov	r16,r4
8112c344:	20000226 	beq	r4,zero,8112c350 <_fflush_r+0x24>
8112c348:	20800e17 	ldw	r2,56(r4)
8112c34c:	10000c26 	beq	r2,zero,8112c380 <_fflush_r+0x54>
8112c350:	2880030f 	ldh	r2,12(r5)
8112c354:	1000051e 	bne	r2,zero,8112c36c <_fflush_r+0x40>
8112c358:	0005883a 	mov	r2,zero
8112c35c:	dfc00217 	ldw	ra,8(sp)
8112c360:	dc000117 	ldw	r16,4(sp)
8112c364:	dec00304 	addi	sp,sp,12
8112c368:	f800283a 	ret
8112c36c:	8009883a 	mov	r4,r16
8112c370:	dfc00217 	ldw	ra,8(sp)
8112c374:	dc000117 	ldw	r16,4(sp)
8112c378:	dec00304 	addi	sp,sp,12
8112c37c:	112c1081 	jmpi	8112c108 <__sflush_r>
8112c380:	d9400015 	stw	r5,0(sp)
8112c384:	112c7280 	call	8112c728 <__sinit>
8112c388:	d9400017 	ldw	r5,0(sp)
8112c38c:	003ff006 	br	8112c350 <__reset+0xfb10c350>

8112c390 <fflush>:
8112c390:	20000526 	beq	r4,zero,8112c3a8 <fflush+0x18>
8112c394:	00a04574 	movhi	r2,33045
8112c398:	1090f104 	addi	r2,r2,17348
8112c39c:	200b883a 	mov	r5,r4
8112c3a0:	11000017 	ldw	r4,0(r2)
8112c3a4:	112c32c1 	jmpi	8112c32c <_fflush_r>
8112c3a8:	00a04574 	movhi	r2,33045
8112c3ac:	1090f004 	addi	r2,r2,17344
8112c3b0:	11000017 	ldw	r4,0(r2)
8112c3b4:	016044f4 	movhi	r5,33043
8112c3b8:	2970cb04 	addi	r5,r5,-15572
8112c3bc:	112d4681 	jmpi	8112d468 <_fwalk_reent>

8112c3c0 <__fp_unlock>:
8112c3c0:	0005883a 	mov	r2,zero
8112c3c4:	f800283a 	ret

8112c3c8 <_cleanup_r>:
8112c3c8:	016044f4 	movhi	r5,33043
8112c3cc:	29506104 	addi	r5,r5,16772
8112c3d0:	112d4681 	jmpi	8112d468 <_fwalk_reent>

8112c3d4 <__sinit.part.1>:
8112c3d4:	defff704 	addi	sp,sp,-36
8112c3d8:	00e044f4 	movhi	r3,33043
8112c3dc:	de00012e 	bgeu	sp,et,8112c3e4 <__sinit.part.1+0x10>
8112c3e0:	003b68fa 	trap	3
8112c3e4:	18f0f204 	addi	r3,r3,-15416
8112c3e8:	dfc00815 	stw	ra,32(sp)
8112c3ec:	ddc00715 	stw	r23,28(sp)
8112c3f0:	dd800615 	stw	r22,24(sp)
8112c3f4:	dd400515 	stw	r21,20(sp)
8112c3f8:	dd000415 	stw	r20,16(sp)
8112c3fc:	dcc00315 	stw	r19,12(sp)
8112c400:	dc800215 	stw	r18,8(sp)
8112c404:	dc400115 	stw	r17,4(sp)
8112c408:	dc000015 	stw	r16,0(sp)
8112c40c:	24000117 	ldw	r16,4(r4)
8112c410:	20c00f15 	stw	r3,60(r4)
8112c414:	2080bb04 	addi	r2,r4,748
8112c418:	00c000c4 	movi	r3,3
8112c41c:	20c0b915 	stw	r3,740(r4)
8112c420:	2080ba15 	stw	r2,744(r4)
8112c424:	2000b815 	stw	zero,736(r4)
8112c428:	05c00204 	movi	r23,8
8112c42c:	00800104 	movi	r2,4
8112c430:	2025883a 	mov	r18,r4
8112c434:	b80d883a 	mov	r6,r23
8112c438:	81001704 	addi	r4,r16,92
8112c43c:	000b883a 	mov	r5,zero
8112c440:	80000015 	stw	zero,0(r16)
8112c444:	80000115 	stw	zero,4(r16)
8112c448:	80000215 	stw	zero,8(r16)
8112c44c:	8080030d 	sth	r2,12(r16)
8112c450:	80001915 	stw	zero,100(r16)
8112c454:	8000038d 	sth	zero,14(r16)
8112c458:	80000415 	stw	zero,16(r16)
8112c45c:	80000515 	stw	zero,20(r16)
8112c460:	80000615 	stw	zero,24(r16)
8112c464:	1123b2c0 	call	81123b2c <memset>
8112c468:	05a044b4 	movhi	r22,33042
8112c46c:	94400217 	ldw	r17,8(r18)
8112c470:	056044b4 	movhi	r21,33042
8112c474:	052044b4 	movhi	r20,33042
8112c478:	04e044b4 	movhi	r19,33042
8112c47c:	b590ad04 	addi	r22,r22,17076
8112c480:	ad50c604 	addi	r21,r21,17176
8112c484:	a510e704 	addi	r20,r20,17308
8112c488:	9cd10004 	addi	r19,r19,17408
8112c48c:	85800815 	stw	r22,32(r16)
8112c490:	85400915 	stw	r21,36(r16)
8112c494:	85000a15 	stw	r20,40(r16)
8112c498:	84c00b15 	stw	r19,44(r16)
8112c49c:	84000715 	stw	r16,28(r16)
8112c4a0:	00800284 	movi	r2,10
8112c4a4:	8880030d 	sth	r2,12(r17)
8112c4a8:	00800044 	movi	r2,1
8112c4ac:	b80d883a 	mov	r6,r23
8112c4b0:	89001704 	addi	r4,r17,92
8112c4b4:	000b883a 	mov	r5,zero
8112c4b8:	88000015 	stw	zero,0(r17)
8112c4bc:	88000115 	stw	zero,4(r17)
8112c4c0:	88000215 	stw	zero,8(r17)
8112c4c4:	88001915 	stw	zero,100(r17)
8112c4c8:	8880038d 	sth	r2,14(r17)
8112c4cc:	88000415 	stw	zero,16(r17)
8112c4d0:	88000515 	stw	zero,20(r17)
8112c4d4:	88000615 	stw	zero,24(r17)
8112c4d8:	1123b2c0 	call	81123b2c <memset>
8112c4dc:	94000317 	ldw	r16,12(r18)
8112c4e0:	00800484 	movi	r2,18
8112c4e4:	8c400715 	stw	r17,28(r17)
8112c4e8:	8d800815 	stw	r22,32(r17)
8112c4ec:	8d400915 	stw	r21,36(r17)
8112c4f0:	8d000a15 	stw	r20,40(r17)
8112c4f4:	8cc00b15 	stw	r19,44(r17)
8112c4f8:	8080030d 	sth	r2,12(r16)
8112c4fc:	00800084 	movi	r2,2
8112c500:	80000015 	stw	zero,0(r16)
8112c504:	80000115 	stw	zero,4(r16)
8112c508:	80000215 	stw	zero,8(r16)
8112c50c:	80001915 	stw	zero,100(r16)
8112c510:	8080038d 	sth	r2,14(r16)
8112c514:	80000415 	stw	zero,16(r16)
8112c518:	80000515 	stw	zero,20(r16)
8112c51c:	80000615 	stw	zero,24(r16)
8112c520:	b80d883a 	mov	r6,r23
8112c524:	000b883a 	mov	r5,zero
8112c528:	81001704 	addi	r4,r16,92
8112c52c:	1123b2c0 	call	81123b2c <memset>
8112c530:	00800044 	movi	r2,1
8112c534:	84000715 	stw	r16,28(r16)
8112c538:	85800815 	stw	r22,32(r16)
8112c53c:	85400915 	stw	r21,36(r16)
8112c540:	85000a15 	stw	r20,40(r16)
8112c544:	84c00b15 	stw	r19,44(r16)
8112c548:	90800e15 	stw	r2,56(r18)
8112c54c:	dfc00817 	ldw	ra,32(sp)
8112c550:	ddc00717 	ldw	r23,28(sp)
8112c554:	dd800617 	ldw	r22,24(sp)
8112c558:	dd400517 	ldw	r21,20(sp)
8112c55c:	dd000417 	ldw	r20,16(sp)
8112c560:	dcc00317 	ldw	r19,12(sp)
8112c564:	dc800217 	ldw	r18,8(sp)
8112c568:	dc400117 	ldw	r17,4(sp)
8112c56c:	dc000017 	ldw	r16,0(sp)
8112c570:	dec00904 	addi	sp,sp,36
8112c574:	f800283a 	ret

8112c578 <__fp_lock>:
8112c578:	0005883a 	mov	r2,zero
8112c57c:	f800283a 	ret

8112c580 <__sfmoreglue>:
8112c580:	defffc04 	addi	sp,sp,-16
8112c584:	de00012e 	bgeu	sp,et,8112c58c <__sfmoreglue+0xc>
8112c588:	003b68fa 	trap	3
8112c58c:	dc400115 	stw	r17,4(sp)
8112c590:	2c7fffc4 	addi	r17,r5,-1
8112c594:	8c401a24 	muli	r17,r17,104
8112c598:	dc800215 	stw	r18,8(sp)
8112c59c:	2825883a 	mov	r18,r5
8112c5a0:	89401d04 	addi	r5,r17,116
8112c5a4:	dc000015 	stw	r16,0(sp)
8112c5a8:	dfc00315 	stw	ra,12(sp)
8112c5ac:	11231c80 	call	811231c8 <_malloc_r>
8112c5b0:	1021883a 	mov	r16,r2
8112c5b4:	10000726 	beq	r2,zero,8112c5d4 <__sfmoreglue+0x54>
8112c5b8:	11000304 	addi	r4,r2,12
8112c5bc:	10000015 	stw	zero,0(r2)
8112c5c0:	14800115 	stw	r18,4(r2)
8112c5c4:	11000215 	stw	r4,8(r2)
8112c5c8:	89801a04 	addi	r6,r17,104
8112c5cc:	000b883a 	mov	r5,zero
8112c5d0:	1123b2c0 	call	81123b2c <memset>
8112c5d4:	8005883a 	mov	r2,r16
8112c5d8:	dfc00317 	ldw	ra,12(sp)
8112c5dc:	dc800217 	ldw	r18,8(sp)
8112c5e0:	dc400117 	ldw	r17,4(sp)
8112c5e4:	dc000017 	ldw	r16,0(sp)
8112c5e8:	dec00404 	addi	sp,sp,16
8112c5ec:	f800283a 	ret

8112c5f0 <__sfp>:
8112c5f0:	defffb04 	addi	sp,sp,-20
8112c5f4:	de00012e 	bgeu	sp,et,8112c5fc <__sfp+0xc>
8112c5f8:	003b68fa 	trap	3
8112c5fc:	dc000015 	stw	r16,0(sp)
8112c600:	04204574 	movhi	r16,33045
8112c604:	8410f004 	addi	r16,r16,17344
8112c608:	dcc00315 	stw	r19,12(sp)
8112c60c:	2027883a 	mov	r19,r4
8112c610:	81000017 	ldw	r4,0(r16)
8112c614:	dfc00415 	stw	ra,16(sp)
8112c618:	dc800215 	stw	r18,8(sp)
8112c61c:	20800e17 	ldw	r2,56(r4)
8112c620:	dc400115 	stw	r17,4(sp)
8112c624:	1000021e 	bne	r2,zero,8112c630 <__sfp+0x40>
8112c628:	112c3d40 	call	8112c3d4 <__sinit.part.1>
8112c62c:	81000017 	ldw	r4,0(r16)
8112c630:	2480b804 	addi	r18,r4,736
8112c634:	047fffc4 	movi	r17,-1
8112c638:	91000117 	ldw	r4,4(r18)
8112c63c:	94000217 	ldw	r16,8(r18)
8112c640:	213fffc4 	addi	r4,r4,-1
8112c644:	20000a16 	blt	r4,zero,8112c670 <__sfp+0x80>
8112c648:	8080030f 	ldh	r2,12(r16)
8112c64c:	10000c26 	beq	r2,zero,8112c680 <__sfp+0x90>
8112c650:	80c01d04 	addi	r3,r16,116
8112c654:	00000206 	br	8112c660 <__sfp+0x70>
8112c658:	18bfe60f 	ldh	r2,-104(r3)
8112c65c:	10000826 	beq	r2,zero,8112c680 <__sfp+0x90>
8112c660:	213fffc4 	addi	r4,r4,-1
8112c664:	1c3ffd04 	addi	r16,r3,-12
8112c668:	18c01a04 	addi	r3,r3,104
8112c66c:	247ffa1e 	bne	r4,r17,8112c658 <__reset+0xfb10c658>
8112c670:	90800017 	ldw	r2,0(r18)
8112c674:	10001d26 	beq	r2,zero,8112c6ec <__sfp+0xfc>
8112c678:	1025883a 	mov	r18,r2
8112c67c:	003fee06 	br	8112c638 <__reset+0xfb10c638>
8112c680:	00bfffc4 	movi	r2,-1
8112c684:	8080038d 	sth	r2,14(r16)
8112c688:	00800044 	movi	r2,1
8112c68c:	8080030d 	sth	r2,12(r16)
8112c690:	80001915 	stw	zero,100(r16)
8112c694:	80000015 	stw	zero,0(r16)
8112c698:	80000215 	stw	zero,8(r16)
8112c69c:	80000115 	stw	zero,4(r16)
8112c6a0:	80000415 	stw	zero,16(r16)
8112c6a4:	80000515 	stw	zero,20(r16)
8112c6a8:	80000615 	stw	zero,24(r16)
8112c6ac:	01800204 	movi	r6,8
8112c6b0:	000b883a 	mov	r5,zero
8112c6b4:	81001704 	addi	r4,r16,92
8112c6b8:	1123b2c0 	call	81123b2c <memset>
8112c6bc:	8005883a 	mov	r2,r16
8112c6c0:	80000c15 	stw	zero,48(r16)
8112c6c4:	80000d15 	stw	zero,52(r16)
8112c6c8:	80001115 	stw	zero,68(r16)
8112c6cc:	80001215 	stw	zero,72(r16)
8112c6d0:	dfc00417 	ldw	ra,16(sp)
8112c6d4:	dcc00317 	ldw	r19,12(sp)
8112c6d8:	dc800217 	ldw	r18,8(sp)
8112c6dc:	dc400117 	ldw	r17,4(sp)
8112c6e0:	dc000017 	ldw	r16,0(sp)
8112c6e4:	dec00504 	addi	sp,sp,20
8112c6e8:	f800283a 	ret
8112c6ec:	01400104 	movi	r5,4
8112c6f0:	9809883a 	mov	r4,r19
8112c6f4:	112c5800 	call	8112c580 <__sfmoreglue>
8112c6f8:	90800015 	stw	r2,0(r18)
8112c6fc:	103fde1e 	bne	r2,zero,8112c678 <__reset+0xfb10c678>
8112c700:	00800304 	movi	r2,12
8112c704:	98800015 	stw	r2,0(r19)
8112c708:	0005883a 	mov	r2,zero
8112c70c:	003ff006 	br	8112c6d0 <__reset+0xfb10c6d0>

8112c710 <_cleanup>:
8112c710:	00a04574 	movhi	r2,33045
8112c714:	1090f004 	addi	r2,r2,17344
8112c718:	11000017 	ldw	r4,0(r2)
8112c71c:	016044f4 	movhi	r5,33043
8112c720:	29506104 	addi	r5,r5,16772
8112c724:	112d4681 	jmpi	8112d468 <_fwalk_reent>

8112c728 <__sinit>:
8112c728:	20800e17 	ldw	r2,56(r4)
8112c72c:	10000126 	beq	r2,zero,8112c734 <__sinit+0xc>
8112c730:	f800283a 	ret
8112c734:	112c3d41 	jmpi	8112c3d4 <__sinit.part.1>

8112c738 <__sfp_lock_acquire>:
8112c738:	f800283a 	ret

8112c73c <__sfp_lock_release>:
8112c73c:	f800283a 	ret

8112c740 <__sinit_lock_acquire>:
8112c740:	f800283a 	ret

8112c744 <__sinit_lock_release>:
8112c744:	f800283a 	ret

8112c748 <__fp_lock_all>:
8112c748:	00a04574 	movhi	r2,33045
8112c74c:	1090f104 	addi	r2,r2,17348
8112c750:	11000017 	ldw	r4,0(r2)
8112c754:	016044f4 	movhi	r5,33043
8112c758:	29715e04 	addi	r5,r5,-14984
8112c75c:	112d39c1 	jmpi	8112d39c <_fwalk>

8112c760 <__fp_unlock_all>:
8112c760:	00a04574 	movhi	r2,33045
8112c764:	1090f104 	addi	r2,r2,17348
8112c768:	11000017 	ldw	r4,0(r2)
8112c76c:	016044f4 	movhi	r5,33043
8112c770:	2970f004 	addi	r5,r5,-15424
8112c774:	112d39c1 	jmpi	8112d39c <_fwalk>

8112c778 <__sflags>:
8112c778:	28800007 	ldb	r2,0(r5)
8112c77c:	00c01c84 	movi	r3,114
8112c780:	10c02426 	beq	r2,r3,8112c814 <__sflags+0x9c>
8112c784:	00c01dc4 	movi	r3,119
8112c788:	10c01e26 	beq	r2,r3,8112c804 <__sflags+0x8c>
8112c78c:	00c01844 	movi	r3,97
8112c790:	10c00426 	beq	r2,r3,8112c7a4 <__sflags+0x2c>
8112c794:	00800584 	movi	r2,22
8112c798:	20800015 	stw	r2,0(r4)
8112c79c:	0005883a 	mov	r2,zero
8112c7a0:	f800283a 	ret
8112c7a4:	02c08204 	movi	r11,520
8112c7a8:	01000044 	movi	r4,1
8112c7ac:	00804204 	movi	r2,264
8112c7b0:	01c00ac4 	movi	r7,43
8112c7b4:	02bff8c4 	movi	r10,-29
8112c7b8:	027fff04 	movi	r9,-4
8112c7bc:	02001e04 	movi	r8,120
8112c7c0:	29400044 	addi	r5,r5,1
8112c7c4:	28c00007 	ldb	r3,0(r5)
8112c7c8:	18000626 	beq	r3,zero,8112c7e4 <__sflags+0x6c>
8112c7cc:	19c00826 	beq	r3,r7,8112c7f0 <__sflags+0x78>
8112c7d0:	1a3ffb1e 	bne	r3,r8,8112c7c0 <__reset+0xfb10c7c0>
8112c7d4:	29400044 	addi	r5,r5,1
8112c7d8:	28c00007 	ldb	r3,0(r5)
8112c7dc:	21020014 	ori	r4,r4,2048
8112c7e0:	183ffa1e 	bne	r3,zero,8112c7cc <__reset+0xfb10c7cc>
8112c7e4:	22c8b03a 	or	r4,r4,r11
8112c7e8:	31000015 	stw	r4,0(r6)
8112c7ec:	f800283a 	ret
8112c7f0:	1284703a 	and	r2,r2,r10
8112c7f4:	2248703a 	and	r4,r4,r9
8112c7f8:	10800414 	ori	r2,r2,16
8112c7fc:	21000094 	ori	r4,r4,2
8112c800:	003fef06 	br	8112c7c0 <__reset+0xfb10c7c0>
8112c804:	02c18004 	movi	r11,1536
8112c808:	01000044 	movi	r4,1
8112c80c:	00800204 	movi	r2,8
8112c810:	003fe706 	br	8112c7b0 <__reset+0xfb10c7b0>
8112c814:	0017883a 	mov	r11,zero
8112c818:	0009883a 	mov	r4,zero
8112c81c:	00800104 	movi	r2,4
8112c820:	003fe306 	br	8112c7b0 <__reset+0xfb10c7b0>

8112c824 <_fread_r>:
8112c824:	defff404 	addi	sp,sp,-48
8112c828:	de00012e 	bgeu	sp,et,8112c830 <_fread_r+0xc>
8112c82c:	003b68fa 	trap	3
8112c830:	dd800815 	stw	r22,32(sp)
8112c834:	39ad383a 	mul	r22,r7,r6
8112c838:	dc000215 	stw	r16,8(sp)
8112c83c:	dfc00b15 	stw	ra,44(sp)
8112c840:	df000a15 	stw	fp,40(sp)
8112c844:	ddc00915 	stw	r23,36(sp)
8112c848:	dd400715 	stw	r21,28(sp)
8112c84c:	dd000615 	stw	r20,24(sp)
8112c850:	dcc00515 	stw	r19,20(sp)
8112c854:	dc800415 	stw	r18,16(sp)
8112c858:	dc400315 	stw	r17,12(sp)
8112c85c:	dc000c17 	ldw	r16,48(sp)
8112c860:	b0003b26 	beq	r22,zero,8112c950 <_fread_r+0x12c>
8112c864:	302f883a 	mov	r23,r6
8112c868:	382b883a 	mov	r21,r7
8112c86c:	2029883a 	mov	r20,r4
8112c870:	2827883a 	mov	r19,r5
8112c874:	20000226 	beq	r4,zero,8112c880 <_fread_r+0x5c>
8112c878:	20800e17 	ldw	r2,56(r4)
8112c87c:	10006e26 	beq	r2,zero,8112ca38 <_fread_r+0x214>
8112c880:	8080030b 	ldhu	r2,12(r16)
8112c884:	10c8000c 	andi	r3,r2,8192
8112c888:	1800061e 	bne	r3,zero,8112c8a4 <_fread_r+0x80>
8112c88c:	81001917 	ldw	r4,100(r16)
8112c890:	00f7ffc4 	movi	r3,-8193
8112c894:	10880014 	ori	r2,r2,8192
8112c898:	20c6703a 	and	r3,r4,r3
8112c89c:	8080030d 	sth	r2,12(r16)
8112c8a0:	80c01915 	stw	r3,100(r16)
8112c8a4:	84400117 	ldw	r17,4(r16)
8112c8a8:	88005f16 	blt	r17,zero,8112ca28 <_fread_r+0x204>
8112c8ac:	8809883a 	mov	r4,r17
8112c8b0:	1080008c 	andi	r2,r2,2
8112c8b4:	1000281e 	bne	r2,zero,8112c958 <_fread_r+0x134>
8112c8b8:	b025883a 	mov	r18,r22
8112c8bc:	00000b06 	br	8112c8ec <_fread_r+0xc8>
8112c8c0:	11239dc0 	call	811239dc <memcpy>
8112c8c4:	80800017 	ldw	r2,0(r16)
8112c8c8:	9c67883a 	add	r19,r19,r17
8112c8cc:	9465c83a 	sub	r18,r18,r17
8112c8d0:	1463883a 	add	r17,r2,r17
8112c8d4:	800b883a 	mov	r5,r16
8112c8d8:	a009883a 	mov	r4,r20
8112c8dc:	84400015 	stw	r17,0(r16)
8112c8e0:	1123f2c0 	call	81123f2c <__srefill_r>
8112c8e4:	10004c1e 	bne	r2,zero,8112ca18 <_fread_r+0x1f4>
8112c8e8:	84400117 	ldw	r17,4(r16)
8112c8ec:	880d883a 	mov	r6,r17
8112c8f0:	9809883a 	mov	r4,r19
8112c8f4:	81400017 	ldw	r5,0(r16)
8112c8f8:	8cbff136 	bltu	r17,r18,8112c8c0 <__reset+0xfb10c8c0>
8112c8fc:	900d883a 	mov	r6,r18
8112c900:	11239dc0 	call	811239dc <memcpy>
8112c904:	80c00117 	ldw	r3,4(r16)
8112c908:	81000017 	ldw	r4,0(r16)
8112c90c:	a805883a 	mov	r2,r21
8112c910:	1c87c83a 	sub	r3,r3,r18
8112c914:	24a5883a 	add	r18,r4,r18
8112c918:	80c00115 	stw	r3,4(r16)
8112c91c:	84800015 	stw	r18,0(r16)
8112c920:	dfc00b17 	ldw	ra,44(sp)
8112c924:	df000a17 	ldw	fp,40(sp)
8112c928:	ddc00917 	ldw	r23,36(sp)
8112c92c:	dd800817 	ldw	r22,32(sp)
8112c930:	dd400717 	ldw	r21,28(sp)
8112c934:	dd000617 	ldw	r20,24(sp)
8112c938:	dcc00517 	ldw	r19,20(sp)
8112c93c:	dc800417 	ldw	r18,16(sp)
8112c940:	dc400317 	ldw	r17,12(sp)
8112c944:	dc000217 	ldw	r16,8(sp)
8112c948:	dec00c04 	addi	sp,sp,48
8112c94c:	f800283a 	ret
8112c950:	0005883a 	mov	r2,zero
8112c954:	003ff206 	br	8112c920 <__reset+0xfb10c920>
8112c958:	b007883a 	mov	r3,r22
8112c95c:	2580012e 	bgeu	r4,r22,8112c964 <_fread_r+0x140>
8112c960:	2007883a 	mov	r3,r4
8112c964:	81400017 	ldw	r5,0(r16)
8112c968:	180d883a 	mov	r6,r3
8112c96c:	9809883a 	mov	r4,r19
8112c970:	d8c00115 	stw	r3,4(sp)
8112c974:	11239dc0 	call	811239dc <memcpy>
8112c978:	d8c00117 	ldw	r3,4(sp)
8112c97c:	84400017 	ldw	r17,0(r16)
8112c980:	80800117 	ldw	r2,4(r16)
8112c984:	81400c17 	ldw	r5,48(r16)
8112c988:	88e3883a 	add	r17,r17,r3
8112c98c:	10c5c83a 	sub	r2,r2,r3
8112c990:	84400015 	stw	r17,0(r16)
8112c994:	80800115 	stw	r2,4(r16)
8112c998:	b0e5c83a 	sub	r18,r22,r3
8112c99c:	28002b26 	beq	r5,zero,8112ca4c <_fread_r+0x228>
8112c9a0:	90002b26 	beq	r18,zero,8112ca50 <_fread_r+0x22c>
8112c9a4:	80801004 	addi	r2,r16,64
8112c9a8:	28800526 	beq	r5,r2,8112c9c0 <_fread_r+0x19c>
8112c9ac:	a009883a 	mov	r4,r20
8112c9b0:	d8c00115 	stw	r3,4(sp)
8112c9b4:	112cbc00 	call	8112cbc0 <_free_r>
8112c9b8:	d8c00117 	ldw	r3,4(sp)
8112c9bc:	84400017 	ldw	r17,0(r16)
8112c9c0:	80000c15 	stw	zero,48(r16)
8112c9c4:	80800517 	ldw	r2,20(r16)
8112c9c8:	87000417 	ldw	fp,16(r16)
8112c9cc:	98e7883a 	add	r19,r19,r3
8112c9d0:	d8800015 	stw	r2,0(sp)
8112c9d4:	00000106 	br	8112c9dc <_fread_r+0x1b8>
8112c9d8:	90001d26 	beq	r18,zero,8112ca50 <_fread_r+0x22c>
8112c9dc:	84c00415 	stw	r19,16(r16)
8112c9e0:	84800515 	stw	r18,20(r16)
8112c9e4:	84c00015 	stw	r19,0(r16)
8112c9e8:	a009883a 	mov	r4,r20
8112c9ec:	800b883a 	mov	r5,r16
8112c9f0:	1123f2c0 	call	81123f2c <__srefill_r>
8112c9f4:	d9000017 	ldw	r4,0(sp)
8112c9f8:	80c00117 	ldw	r3,4(r16)
8112c9fc:	87000415 	stw	fp,16(r16)
8112ca00:	81000515 	stw	r4,20(r16)
8112ca04:	84400015 	stw	r17,0(r16)
8112ca08:	80000115 	stw	zero,4(r16)
8112ca0c:	90e5c83a 	sub	r18,r18,r3
8112ca10:	98e7883a 	add	r19,r19,r3
8112ca14:	103ff026 	beq	r2,zero,8112c9d8 <__reset+0xfb10c9d8>
8112ca18:	b80b883a 	mov	r5,r23
8112ca1c:	b489c83a 	sub	r4,r22,r18
8112ca20:	1135ecc0 	call	81135ecc <__udivsi3>
8112ca24:	003fbe06 	br	8112c920 <__reset+0xfb10c920>
8112ca28:	80000115 	stw	zero,4(r16)
8112ca2c:	0009883a 	mov	r4,zero
8112ca30:	0023883a 	mov	r17,zero
8112ca34:	003f9e06 	br	8112c8b0 <__reset+0xfb10c8b0>
8112ca38:	112c7280 	call	8112c728 <__sinit>
8112ca3c:	8080030b 	ldhu	r2,12(r16)
8112ca40:	10c8000c 	andi	r3,r2,8192
8112ca44:	183f971e 	bne	r3,zero,8112c8a4 <__reset+0xfb10c8a4>
8112ca48:	003f9006 	br	8112c88c <__reset+0xfb10c88c>
8112ca4c:	903fdd1e 	bne	r18,zero,8112c9c4 <__reset+0xfb10c9c4>
8112ca50:	a805883a 	mov	r2,r21
8112ca54:	003fb206 	br	8112c920 <__reset+0xfb10c920>

8112ca58 <fread>:
8112ca58:	defffe04 	addi	sp,sp,-8
8112ca5c:	00a04574 	movhi	r2,33045
8112ca60:	de00012e 	bgeu	sp,et,8112ca68 <fread+0x10>
8112ca64:	003b68fa 	trap	3
8112ca68:	1090f104 	addi	r2,r2,17348
8112ca6c:	d9c00015 	stw	r7,0(sp)
8112ca70:	300f883a 	mov	r7,r6
8112ca74:	280d883a 	mov	r6,r5
8112ca78:	200b883a 	mov	r5,r4
8112ca7c:	11000017 	ldw	r4,0(r2)
8112ca80:	dfc00115 	stw	ra,4(sp)
8112ca84:	112c8240 	call	8112c824 <_fread_r>
8112ca88:	dfc00117 	ldw	ra,4(sp)
8112ca8c:	dec00204 	addi	sp,sp,8
8112ca90:	f800283a 	ret

8112ca94 <_malloc_trim_r>:
8112ca94:	defffb04 	addi	sp,sp,-20
8112ca98:	de00012e 	bgeu	sp,et,8112caa0 <_malloc_trim_r+0xc>
8112ca9c:	003b68fa 	trap	3
8112caa0:	dcc00315 	stw	r19,12(sp)
8112caa4:	04e04574 	movhi	r19,33045
8112caa8:	dc800215 	stw	r18,8(sp)
8112caac:	dc400115 	stw	r17,4(sp)
8112cab0:	dc000015 	stw	r16,0(sp)
8112cab4:	dfc00415 	stw	ra,16(sp)
8112cab8:	2821883a 	mov	r16,r5
8112cabc:	9ccaaf04 	addi	r19,r19,10940
8112cac0:	2025883a 	mov	r18,r4
8112cac4:	11393880 	call	81139388 <__malloc_lock>
8112cac8:	98800217 	ldw	r2,8(r19)
8112cacc:	14400117 	ldw	r17,4(r2)
8112cad0:	00bfff04 	movi	r2,-4
8112cad4:	88a2703a 	and	r17,r17,r2
8112cad8:	8c21c83a 	sub	r16,r17,r16
8112cadc:	8403fbc4 	addi	r16,r16,4079
8112cae0:	8020d33a 	srli	r16,r16,12
8112cae4:	0083ffc4 	movi	r2,4095
8112cae8:	843fffc4 	addi	r16,r16,-1
8112caec:	8020933a 	slli	r16,r16,12
8112caf0:	1400060e 	bge	r2,r16,8112cb0c <_malloc_trim_r+0x78>
8112caf4:	000b883a 	mov	r5,zero
8112caf8:	9009883a 	mov	r4,r18
8112cafc:	11241080 	call	81124108 <_sbrk_r>
8112cb00:	98c00217 	ldw	r3,8(r19)
8112cb04:	1c47883a 	add	r3,r3,r17
8112cb08:	10c00a26 	beq	r2,r3,8112cb34 <_malloc_trim_r+0xa0>
8112cb0c:	9009883a 	mov	r4,r18
8112cb10:	11394b00 	call	811394b0 <__malloc_unlock>
8112cb14:	0005883a 	mov	r2,zero
8112cb18:	dfc00417 	ldw	ra,16(sp)
8112cb1c:	dcc00317 	ldw	r19,12(sp)
8112cb20:	dc800217 	ldw	r18,8(sp)
8112cb24:	dc400117 	ldw	r17,4(sp)
8112cb28:	dc000017 	ldw	r16,0(sp)
8112cb2c:	dec00504 	addi	sp,sp,20
8112cb30:	f800283a 	ret
8112cb34:	040bc83a 	sub	r5,zero,r16
8112cb38:	9009883a 	mov	r4,r18
8112cb3c:	11241080 	call	81124108 <_sbrk_r>
8112cb40:	00ffffc4 	movi	r3,-1
8112cb44:	10c00d26 	beq	r2,r3,8112cb7c <_malloc_trim_r+0xe8>
8112cb48:	00e04574 	movhi	r3,33045
8112cb4c:	18d1f404 	addi	r3,r3,18384
8112cb50:	18800017 	ldw	r2,0(r3)
8112cb54:	99000217 	ldw	r4,8(r19)
8112cb58:	8c23c83a 	sub	r17,r17,r16
8112cb5c:	8c400054 	ori	r17,r17,1
8112cb60:	1421c83a 	sub	r16,r2,r16
8112cb64:	24400115 	stw	r17,4(r4)
8112cb68:	9009883a 	mov	r4,r18
8112cb6c:	1c000015 	stw	r16,0(r3)
8112cb70:	11394b00 	call	811394b0 <__malloc_unlock>
8112cb74:	00800044 	movi	r2,1
8112cb78:	003fe706 	br	8112cb18 <__reset+0xfb10cb18>
8112cb7c:	000b883a 	mov	r5,zero
8112cb80:	9009883a 	mov	r4,r18
8112cb84:	11241080 	call	81124108 <_sbrk_r>
8112cb88:	99000217 	ldw	r4,8(r19)
8112cb8c:	014003c4 	movi	r5,15
8112cb90:	1107c83a 	sub	r3,r2,r4
8112cb94:	28ffdd0e 	bge	r5,r3,8112cb0c <__reset+0xfb10cb0c>
8112cb98:	01604574 	movhi	r5,33045
8112cb9c:	2950f204 	addi	r5,r5,17352
8112cba0:	29400017 	ldw	r5,0(r5)
8112cba4:	18c00054 	ori	r3,r3,1
8112cba8:	20c00115 	stw	r3,4(r4)
8112cbac:	00e04574 	movhi	r3,33045
8112cbb0:	1145c83a 	sub	r2,r2,r5
8112cbb4:	18d1f404 	addi	r3,r3,18384
8112cbb8:	18800015 	stw	r2,0(r3)
8112cbbc:	003fd306 	br	8112cb0c <__reset+0xfb10cb0c>

8112cbc0 <_free_r>:
8112cbc0:	28004326 	beq	r5,zero,8112ccd0 <_free_r+0x110>
8112cbc4:	defffd04 	addi	sp,sp,-12
8112cbc8:	de00012e 	bgeu	sp,et,8112cbd0 <_free_r+0x10>
8112cbcc:	003b68fa 	trap	3
8112cbd0:	dc400115 	stw	r17,4(sp)
8112cbd4:	dc000015 	stw	r16,0(sp)
8112cbd8:	2023883a 	mov	r17,r4
8112cbdc:	2821883a 	mov	r16,r5
8112cbe0:	dfc00215 	stw	ra,8(sp)
8112cbe4:	11393880 	call	81139388 <__malloc_lock>
8112cbe8:	81ffff17 	ldw	r7,-4(r16)
8112cbec:	00bfff84 	movi	r2,-2
8112cbf0:	01204574 	movhi	r4,33045
8112cbf4:	81bffe04 	addi	r6,r16,-8
8112cbf8:	3884703a 	and	r2,r7,r2
8112cbfc:	210aaf04 	addi	r4,r4,10940
8112cc00:	308b883a 	add	r5,r6,r2
8112cc04:	2a400117 	ldw	r9,4(r5)
8112cc08:	22000217 	ldw	r8,8(r4)
8112cc0c:	00ffff04 	movi	r3,-4
8112cc10:	48c6703a 	and	r3,r9,r3
8112cc14:	2a005726 	beq	r5,r8,8112cd74 <_free_r+0x1b4>
8112cc18:	28c00115 	stw	r3,4(r5)
8112cc1c:	39c0004c 	andi	r7,r7,1
8112cc20:	3800091e 	bne	r7,zero,8112cc48 <_free_r+0x88>
8112cc24:	823ffe17 	ldw	r8,-8(r16)
8112cc28:	22400204 	addi	r9,r4,8
8112cc2c:	320dc83a 	sub	r6,r6,r8
8112cc30:	31c00217 	ldw	r7,8(r6)
8112cc34:	1205883a 	add	r2,r2,r8
8112cc38:	3a406526 	beq	r7,r9,8112cdd0 <_free_r+0x210>
8112cc3c:	32000317 	ldw	r8,12(r6)
8112cc40:	3a000315 	stw	r8,12(r7)
8112cc44:	41c00215 	stw	r7,8(r8)
8112cc48:	28cf883a 	add	r7,r5,r3
8112cc4c:	39c00117 	ldw	r7,4(r7)
8112cc50:	39c0004c 	andi	r7,r7,1
8112cc54:	38003a26 	beq	r7,zero,8112cd40 <_free_r+0x180>
8112cc58:	10c00054 	ori	r3,r2,1
8112cc5c:	30c00115 	stw	r3,4(r6)
8112cc60:	3087883a 	add	r3,r6,r2
8112cc64:	18800015 	stw	r2,0(r3)
8112cc68:	00c07fc4 	movi	r3,511
8112cc6c:	18801936 	bltu	r3,r2,8112ccd4 <_free_r+0x114>
8112cc70:	1004d0fa 	srli	r2,r2,3
8112cc74:	01c00044 	movi	r7,1
8112cc78:	21400117 	ldw	r5,4(r4)
8112cc7c:	10c00044 	addi	r3,r2,1
8112cc80:	18c7883a 	add	r3,r3,r3
8112cc84:	1005d0ba 	srai	r2,r2,2
8112cc88:	18c7883a 	add	r3,r3,r3
8112cc8c:	18c7883a 	add	r3,r3,r3
8112cc90:	1907883a 	add	r3,r3,r4
8112cc94:	3884983a 	sll	r2,r7,r2
8112cc98:	19c00017 	ldw	r7,0(r3)
8112cc9c:	1a3ffe04 	addi	r8,r3,-8
8112cca0:	1144b03a 	or	r2,r2,r5
8112cca4:	32000315 	stw	r8,12(r6)
8112cca8:	31c00215 	stw	r7,8(r6)
8112ccac:	20800115 	stw	r2,4(r4)
8112ccb0:	19800015 	stw	r6,0(r3)
8112ccb4:	39800315 	stw	r6,12(r7)
8112ccb8:	8809883a 	mov	r4,r17
8112ccbc:	dfc00217 	ldw	ra,8(sp)
8112ccc0:	dc400117 	ldw	r17,4(sp)
8112ccc4:	dc000017 	ldw	r16,0(sp)
8112ccc8:	dec00304 	addi	sp,sp,12
8112cccc:	11394b01 	jmpi	811394b0 <__malloc_unlock>
8112ccd0:	f800283a 	ret
8112ccd4:	100ad27a 	srli	r5,r2,9
8112ccd8:	00c00104 	movi	r3,4
8112ccdc:	19404a36 	bltu	r3,r5,8112ce08 <_free_r+0x248>
8112cce0:	100ad1ba 	srli	r5,r2,6
8112cce4:	28c00e44 	addi	r3,r5,57
8112cce8:	18c7883a 	add	r3,r3,r3
8112ccec:	29400e04 	addi	r5,r5,56
8112ccf0:	18c7883a 	add	r3,r3,r3
8112ccf4:	18c7883a 	add	r3,r3,r3
8112ccf8:	1909883a 	add	r4,r3,r4
8112ccfc:	20c00017 	ldw	r3,0(r4)
8112cd00:	01e04574 	movhi	r7,33045
8112cd04:	213ffe04 	addi	r4,r4,-8
8112cd08:	39caaf04 	addi	r7,r7,10940
8112cd0c:	20c04426 	beq	r4,r3,8112ce20 <_free_r+0x260>
8112cd10:	01ffff04 	movi	r7,-4
8112cd14:	19400117 	ldw	r5,4(r3)
8112cd18:	29ca703a 	and	r5,r5,r7
8112cd1c:	1140022e 	bgeu	r2,r5,8112cd28 <_free_r+0x168>
8112cd20:	18c00217 	ldw	r3,8(r3)
8112cd24:	20fffb1e 	bne	r4,r3,8112cd14 <__reset+0xfb10cd14>
8112cd28:	19000317 	ldw	r4,12(r3)
8112cd2c:	31000315 	stw	r4,12(r6)
8112cd30:	30c00215 	stw	r3,8(r6)
8112cd34:	21800215 	stw	r6,8(r4)
8112cd38:	19800315 	stw	r6,12(r3)
8112cd3c:	003fde06 	br	8112ccb8 <__reset+0xfb10ccb8>
8112cd40:	29c00217 	ldw	r7,8(r5)
8112cd44:	10c5883a 	add	r2,r2,r3
8112cd48:	00e04574 	movhi	r3,33045
8112cd4c:	18cab104 	addi	r3,r3,10948
8112cd50:	38c03b26 	beq	r7,r3,8112ce40 <_free_r+0x280>
8112cd54:	2a000317 	ldw	r8,12(r5)
8112cd58:	11400054 	ori	r5,r2,1
8112cd5c:	3087883a 	add	r3,r6,r2
8112cd60:	3a000315 	stw	r8,12(r7)
8112cd64:	41c00215 	stw	r7,8(r8)
8112cd68:	31400115 	stw	r5,4(r6)
8112cd6c:	18800015 	stw	r2,0(r3)
8112cd70:	003fbd06 	br	8112cc68 <__reset+0xfb10cc68>
8112cd74:	39c0004c 	andi	r7,r7,1
8112cd78:	10c5883a 	add	r2,r2,r3
8112cd7c:	3800071e 	bne	r7,zero,8112cd9c <_free_r+0x1dc>
8112cd80:	81fffe17 	ldw	r7,-8(r16)
8112cd84:	31cdc83a 	sub	r6,r6,r7
8112cd88:	30c00317 	ldw	r3,12(r6)
8112cd8c:	31400217 	ldw	r5,8(r6)
8112cd90:	11c5883a 	add	r2,r2,r7
8112cd94:	28c00315 	stw	r3,12(r5)
8112cd98:	19400215 	stw	r5,8(r3)
8112cd9c:	10c00054 	ori	r3,r2,1
8112cda0:	30c00115 	stw	r3,4(r6)
8112cda4:	00e04574 	movhi	r3,33045
8112cda8:	18d0f304 	addi	r3,r3,17356
8112cdac:	18c00017 	ldw	r3,0(r3)
8112cdb0:	21800215 	stw	r6,8(r4)
8112cdb4:	10ffc036 	bltu	r2,r3,8112ccb8 <__reset+0xfb10ccb8>
8112cdb8:	00a04574 	movhi	r2,33045
8112cdbc:	10916704 	addi	r2,r2,17820
8112cdc0:	11400017 	ldw	r5,0(r2)
8112cdc4:	8809883a 	mov	r4,r17
8112cdc8:	112ca940 	call	8112ca94 <_malloc_trim_r>
8112cdcc:	003fba06 	br	8112ccb8 <__reset+0xfb10ccb8>
8112cdd0:	28c9883a 	add	r4,r5,r3
8112cdd4:	21000117 	ldw	r4,4(r4)
8112cdd8:	2100004c 	andi	r4,r4,1
8112cddc:	2000391e 	bne	r4,zero,8112cec4 <_free_r+0x304>
8112cde0:	29c00217 	ldw	r7,8(r5)
8112cde4:	29000317 	ldw	r4,12(r5)
8112cde8:	1885883a 	add	r2,r3,r2
8112cdec:	10c00054 	ori	r3,r2,1
8112cdf0:	39000315 	stw	r4,12(r7)
8112cdf4:	21c00215 	stw	r7,8(r4)
8112cdf8:	30c00115 	stw	r3,4(r6)
8112cdfc:	308d883a 	add	r6,r6,r2
8112ce00:	30800015 	stw	r2,0(r6)
8112ce04:	003fac06 	br	8112ccb8 <__reset+0xfb10ccb8>
8112ce08:	00c00504 	movi	r3,20
8112ce0c:	19401536 	bltu	r3,r5,8112ce64 <_free_r+0x2a4>
8112ce10:	28c01704 	addi	r3,r5,92
8112ce14:	18c7883a 	add	r3,r3,r3
8112ce18:	294016c4 	addi	r5,r5,91
8112ce1c:	003fb406 	br	8112ccf0 <__reset+0xfb10ccf0>
8112ce20:	280bd0ba 	srai	r5,r5,2
8112ce24:	00c00044 	movi	r3,1
8112ce28:	38800117 	ldw	r2,4(r7)
8112ce2c:	194a983a 	sll	r5,r3,r5
8112ce30:	2007883a 	mov	r3,r4
8112ce34:	2884b03a 	or	r2,r5,r2
8112ce38:	38800115 	stw	r2,4(r7)
8112ce3c:	003fbb06 	br	8112cd2c <__reset+0xfb10cd2c>
8112ce40:	21800515 	stw	r6,20(r4)
8112ce44:	21800415 	stw	r6,16(r4)
8112ce48:	10c00054 	ori	r3,r2,1
8112ce4c:	31c00315 	stw	r7,12(r6)
8112ce50:	31c00215 	stw	r7,8(r6)
8112ce54:	30c00115 	stw	r3,4(r6)
8112ce58:	308d883a 	add	r6,r6,r2
8112ce5c:	30800015 	stw	r2,0(r6)
8112ce60:	003f9506 	br	8112ccb8 <__reset+0xfb10ccb8>
8112ce64:	00c01504 	movi	r3,84
8112ce68:	19400536 	bltu	r3,r5,8112ce80 <_free_r+0x2c0>
8112ce6c:	100ad33a 	srli	r5,r2,12
8112ce70:	28c01bc4 	addi	r3,r5,111
8112ce74:	18c7883a 	add	r3,r3,r3
8112ce78:	29401b84 	addi	r5,r5,110
8112ce7c:	003f9c06 	br	8112ccf0 <__reset+0xfb10ccf0>
8112ce80:	00c05504 	movi	r3,340
8112ce84:	19400536 	bltu	r3,r5,8112ce9c <_free_r+0x2dc>
8112ce88:	100ad3fa 	srli	r5,r2,15
8112ce8c:	28c01e04 	addi	r3,r5,120
8112ce90:	18c7883a 	add	r3,r3,r3
8112ce94:	29401dc4 	addi	r5,r5,119
8112ce98:	003f9506 	br	8112ccf0 <__reset+0xfb10ccf0>
8112ce9c:	00c15504 	movi	r3,1364
8112cea0:	19400536 	bltu	r3,r5,8112ceb8 <_free_r+0x2f8>
8112cea4:	100ad4ba 	srli	r5,r2,18
8112cea8:	28c01f44 	addi	r3,r5,125
8112ceac:	18c7883a 	add	r3,r3,r3
8112ceb0:	29401f04 	addi	r5,r5,124
8112ceb4:	003f8e06 	br	8112ccf0 <__reset+0xfb10ccf0>
8112ceb8:	00c03f84 	movi	r3,254
8112cebc:	01401f84 	movi	r5,126
8112cec0:	003f8b06 	br	8112ccf0 <__reset+0xfb10ccf0>
8112cec4:	10c00054 	ori	r3,r2,1
8112cec8:	30c00115 	stw	r3,4(r6)
8112cecc:	308d883a 	add	r6,r6,r2
8112ced0:	30800015 	stw	r2,0(r6)
8112ced4:	003f7806 	br	8112ccb8 <__reset+0xfb10ccb8>

8112ced8 <__sfvwrite_r>:
8112ced8:	30800217 	ldw	r2,8(r6)
8112cedc:	10006926 	beq	r2,zero,8112d084 <__sfvwrite_r+0x1ac>
8112cee0:	defff404 	addi	sp,sp,-48
8112cee4:	de00012e 	bgeu	sp,et,8112ceec <__sfvwrite_r+0x14>
8112cee8:	003b68fa 	trap	3
8112ceec:	28c0030b 	ldhu	r3,12(r5)
8112cef0:	dd400715 	stw	r21,28(sp)
8112cef4:	dd000615 	stw	r20,24(sp)
8112cef8:	dc000215 	stw	r16,8(sp)
8112cefc:	dfc00b15 	stw	ra,44(sp)
8112cf00:	df000a15 	stw	fp,40(sp)
8112cf04:	ddc00915 	stw	r23,36(sp)
8112cf08:	dd800815 	stw	r22,32(sp)
8112cf0c:	dcc00515 	stw	r19,20(sp)
8112cf10:	dc800415 	stw	r18,16(sp)
8112cf14:	dc400315 	stw	r17,12(sp)
8112cf18:	1880020c 	andi	r2,r3,8
8112cf1c:	2821883a 	mov	r16,r5
8112cf20:	202b883a 	mov	r21,r4
8112cf24:	3029883a 	mov	r20,r6
8112cf28:	10002726 	beq	r2,zero,8112cfc8 <__sfvwrite_r+0xf0>
8112cf2c:	28800417 	ldw	r2,16(r5)
8112cf30:	10002526 	beq	r2,zero,8112cfc8 <__sfvwrite_r+0xf0>
8112cf34:	1880008c 	andi	r2,r3,2
8112cf38:	a4400017 	ldw	r17,0(r20)
8112cf3c:	10002a26 	beq	r2,zero,8112cfe8 <__sfvwrite_r+0x110>
8112cf40:	05a00034 	movhi	r22,32768
8112cf44:	0027883a 	mov	r19,zero
8112cf48:	0025883a 	mov	r18,zero
8112cf4c:	b5bf0004 	addi	r22,r22,-1024
8112cf50:	980d883a 	mov	r6,r19
8112cf54:	a809883a 	mov	r4,r21
8112cf58:	90004626 	beq	r18,zero,8112d074 <__sfvwrite_r+0x19c>
8112cf5c:	900f883a 	mov	r7,r18
8112cf60:	b480022e 	bgeu	r22,r18,8112cf6c <__sfvwrite_r+0x94>
8112cf64:	01e00034 	movhi	r7,32768
8112cf68:	39ff0004 	addi	r7,r7,-1024
8112cf6c:	80800917 	ldw	r2,36(r16)
8112cf70:	81400717 	ldw	r5,28(r16)
8112cf74:	103ee83a 	callr	r2
8112cf78:	0080570e 	bge	zero,r2,8112d0d8 <__sfvwrite_r+0x200>
8112cf7c:	a0c00217 	ldw	r3,8(r20)
8112cf80:	98a7883a 	add	r19,r19,r2
8112cf84:	90a5c83a 	sub	r18,r18,r2
8112cf88:	1885c83a 	sub	r2,r3,r2
8112cf8c:	a0800215 	stw	r2,8(r20)
8112cf90:	103fef1e 	bne	r2,zero,8112cf50 <__reset+0xfb10cf50>
8112cf94:	0005883a 	mov	r2,zero
8112cf98:	dfc00b17 	ldw	ra,44(sp)
8112cf9c:	df000a17 	ldw	fp,40(sp)
8112cfa0:	ddc00917 	ldw	r23,36(sp)
8112cfa4:	dd800817 	ldw	r22,32(sp)
8112cfa8:	dd400717 	ldw	r21,28(sp)
8112cfac:	dd000617 	ldw	r20,24(sp)
8112cfb0:	dcc00517 	ldw	r19,20(sp)
8112cfb4:	dc800417 	ldw	r18,16(sp)
8112cfb8:	dc400317 	ldw	r17,12(sp)
8112cfbc:	dc000217 	ldw	r16,8(sp)
8112cfc0:	dec00c04 	addi	sp,sp,48
8112cfc4:	f800283a 	ret
8112cfc8:	800b883a 	mov	r5,r16
8112cfcc:	a809883a 	mov	r4,r21
8112cfd0:	112a6b80 	call	8112a6b8 <__swsetup_r>
8112cfd4:	1000eb1e 	bne	r2,zero,8112d384 <__sfvwrite_r+0x4ac>
8112cfd8:	80c0030b 	ldhu	r3,12(r16)
8112cfdc:	a4400017 	ldw	r17,0(r20)
8112cfe0:	1880008c 	andi	r2,r3,2
8112cfe4:	103fd61e 	bne	r2,zero,8112cf40 <__reset+0xfb10cf40>
8112cfe8:	1880004c 	andi	r2,r3,1
8112cfec:	10003f1e 	bne	r2,zero,8112d0ec <__sfvwrite_r+0x214>
8112cff0:	0039883a 	mov	fp,zero
8112cff4:	0025883a 	mov	r18,zero
8112cff8:	90001a26 	beq	r18,zero,8112d064 <__sfvwrite_r+0x18c>
8112cffc:	1880800c 	andi	r2,r3,512
8112d000:	84c00217 	ldw	r19,8(r16)
8112d004:	10002126 	beq	r2,zero,8112d08c <__sfvwrite_r+0x1b4>
8112d008:	982f883a 	mov	r23,r19
8112d00c:	94c09336 	bltu	r18,r19,8112d25c <__sfvwrite_r+0x384>
8112d010:	1881200c 	andi	r2,r3,1152
8112d014:	10009e1e 	bne	r2,zero,8112d290 <__sfvwrite_r+0x3b8>
8112d018:	81000017 	ldw	r4,0(r16)
8112d01c:	b80d883a 	mov	r6,r23
8112d020:	e00b883a 	mov	r5,fp
8112d024:	112da340 	call	8112da34 <memmove>
8112d028:	80c00217 	ldw	r3,8(r16)
8112d02c:	81000017 	ldw	r4,0(r16)
8112d030:	9005883a 	mov	r2,r18
8112d034:	1ce7c83a 	sub	r19,r3,r19
8112d038:	25cf883a 	add	r7,r4,r23
8112d03c:	84c00215 	stw	r19,8(r16)
8112d040:	81c00015 	stw	r7,0(r16)
8112d044:	a0c00217 	ldw	r3,8(r20)
8112d048:	e0b9883a 	add	fp,fp,r2
8112d04c:	90a5c83a 	sub	r18,r18,r2
8112d050:	18a7c83a 	sub	r19,r3,r2
8112d054:	a4c00215 	stw	r19,8(r20)
8112d058:	983fce26 	beq	r19,zero,8112cf94 <__reset+0xfb10cf94>
8112d05c:	80c0030b 	ldhu	r3,12(r16)
8112d060:	903fe61e 	bne	r18,zero,8112cffc <__reset+0xfb10cffc>
8112d064:	8f000017 	ldw	fp,0(r17)
8112d068:	8c800117 	ldw	r18,4(r17)
8112d06c:	8c400204 	addi	r17,r17,8
8112d070:	003fe106 	br	8112cff8 <__reset+0xfb10cff8>
8112d074:	8cc00017 	ldw	r19,0(r17)
8112d078:	8c800117 	ldw	r18,4(r17)
8112d07c:	8c400204 	addi	r17,r17,8
8112d080:	003fb306 	br	8112cf50 <__reset+0xfb10cf50>
8112d084:	0005883a 	mov	r2,zero
8112d088:	f800283a 	ret
8112d08c:	81000017 	ldw	r4,0(r16)
8112d090:	80800417 	ldw	r2,16(r16)
8112d094:	11005736 	bltu	r2,r4,8112d1f4 <__sfvwrite_r+0x31c>
8112d098:	85c00517 	ldw	r23,20(r16)
8112d09c:	95c05536 	bltu	r18,r23,8112d1f4 <__sfvwrite_r+0x31c>
8112d0a0:	00a00034 	movhi	r2,32768
8112d0a4:	10bfffc4 	addi	r2,r2,-1
8112d0a8:	9009883a 	mov	r4,r18
8112d0ac:	1480012e 	bgeu	r2,r18,8112d0b4 <__sfvwrite_r+0x1dc>
8112d0b0:	1009883a 	mov	r4,r2
8112d0b4:	b80b883a 	mov	r5,r23
8112d0b8:	1135dd40 	call	81135dd4 <__divsi3>
8112d0bc:	15cf383a 	mul	r7,r2,r23
8112d0c0:	81400717 	ldw	r5,28(r16)
8112d0c4:	80800917 	ldw	r2,36(r16)
8112d0c8:	e00d883a 	mov	r6,fp
8112d0cc:	a809883a 	mov	r4,r21
8112d0d0:	103ee83a 	callr	r2
8112d0d4:	00bfdb16 	blt	zero,r2,8112d044 <__reset+0xfb10d044>
8112d0d8:	8080030b 	ldhu	r2,12(r16)
8112d0dc:	10801014 	ori	r2,r2,64
8112d0e0:	8080030d 	sth	r2,12(r16)
8112d0e4:	00bfffc4 	movi	r2,-1
8112d0e8:	003fab06 	br	8112cf98 <__reset+0xfb10cf98>
8112d0ec:	0027883a 	mov	r19,zero
8112d0f0:	0011883a 	mov	r8,zero
8112d0f4:	0039883a 	mov	fp,zero
8112d0f8:	0025883a 	mov	r18,zero
8112d0fc:	90001f26 	beq	r18,zero,8112d17c <__sfvwrite_r+0x2a4>
8112d100:	40005a26 	beq	r8,zero,8112d26c <__sfvwrite_r+0x394>
8112d104:	982d883a 	mov	r22,r19
8112d108:	94c0012e 	bgeu	r18,r19,8112d110 <__sfvwrite_r+0x238>
8112d10c:	902d883a 	mov	r22,r18
8112d110:	81000017 	ldw	r4,0(r16)
8112d114:	80800417 	ldw	r2,16(r16)
8112d118:	b02f883a 	mov	r23,r22
8112d11c:	81c00517 	ldw	r7,20(r16)
8112d120:	1100032e 	bgeu	r2,r4,8112d130 <__sfvwrite_r+0x258>
8112d124:	80c00217 	ldw	r3,8(r16)
8112d128:	38c7883a 	add	r3,r7,r3
8112d12c:	1d801816 	blt	r3,r22,8112d190 <__sfvwrite_r+0x2b8>
8112d130:	b1c03e16 	blt	r22,r7,8112d22c <__sfvwrite_r+0x354>
8112d134:	80800917 	ldw	r2,36(r16)
8112d138:	81400717 	ldw	r5,28(r16)
8112d13c:	e00d883a 	mov	r6,fp
8112d140:	da000115 	stw	r8,4(sp)
8112d144:	a809883a 	mov	r4,r21
8112d148:	103ee83a 	callr	r2
8112d14c:	102f883a 	mov	r23,r2
8112d150:	da000117 	ldw	r8,4(sp)
8112d154:	00bfe00e 	bge	zero,r2,8112d0d8 <__reset+0xfb10d0d8>
8112d158:	9de7c83a 	sub	r19,r19,r23
8112d15c:	98001f26 	beq	r19,zero,8112d1dc <__sfvwrite_r+0x304>
8112d160:	a0800217 	ldw	r2,8(r20)
8112d164:	e5f9883a 	add	fp,fp,r23
8112d168:	95e5c83a 	sub	r18,r18,r23
8112d16c:	15efc83a 	sub	r23,r2,r23
8112d170:	a5c00215 	stw	r23,8(r20)
8112d174:	b83f8726 	beq	r23,zero,8112cf94 <__reset+0xfb10cf94>
8112d178:	903fe11e 	bne	r18,zero,8112d100 <__reset+0xfb10d100>
8112d17c:	8f000017 	ldw	fp,0(r17)
8112d180:	8c800117 	ldw	r18,4(r17)
8112d184:	0011883a 	mov	r8,zero
8112d188:	8c400204 	addi	r17,r17,8
8112d18c:	003fdb06 	br	8112d0fc <__reset+0xfb10d0fc>
8112d190:	180d883a 	mov	r6,r3
8112d194:	e00b883a 	mov	r5,fp
8112d198:	da000115 	stw	r8,4(sp)
8112d19c:	d8c00015 	stw	r3,0(sp)
8112d1a0:	112da340 	call	8112da34 <memmove>
8112d1a4:	d8c00017 	ldw	r3,0(sp)
8112d1a8:	80800017 	ldw	r2,0(r16)
8112d1ac:	800b883a 	mov	r5,r16
8112d1b0:	a809883a 	mov	r4,r21
8112d1b4:	10c5883a 	add	r2,r2,r3
8112d1b8:	80800015 	stw	r2,0(r16)
8112d1bc:	d8c00015 	stw	r3,0(sp)
8112d1c0:	112c32c0 	call	8112c32c <_fflush_r>
8112d1c4:	d8c00017 	ldw	r3,0(sp)
8112d1c8:	da000117 	ldw	r8,4(sp)
8112d1cc:	103fc21e 	bne	r2,zero,8112d0d8 <__reset+0xfb10d0d8>
8112d1d0:	182f883a 	mov	r23,r3
8112d1d4:	9de7c83a 	sub	r19,r19,r23
8112d1d8:	983fe11e 	bne	r19,zero,8112d160 <__reset+0xfb10d160>
8112d1dc:	800b883a 	mov	r5,r16
8112d1e0:	a809883a 	mov	r4,r21
8112d1e4:	112c32c0 	call	8112c32c <_fflush_r>
8112d1e8:	103fbb1e 	bne	r2,zero,8112d0d8 <__reset+0xfb10d0d8>
8112d1ec:	0011883a 	mov	r8,zero
8112d1f0:	003fdb06 	br	8112d160 <__reset+0xfb10d160>
8112d1f4:	94c0012e 	bgeu	r18,r19,8112d1fc <__sfvwrite_r+0x324>
8112d1f8:	9027883a 	mov	r19,r18
8112d1fc:	980d883a 	mov	r6,r19
8112d200:	e00b883a 	mov	r5,fp
8112d204:	112da340 	call	8112da34 <memmove>
8112d208:	80800217 	ldw	r2,8(r16)
8112d20c:	80c00017 	ldw	r3,0(r16)
8112d210:	14c5c83a 	sub	r2,r2,r19
8112d214:	1cc7883a 	add	r3,r3,r19
8112d218:	80800215 	stw	r2,8(r16)
8112d21c:	80c00015 	stw	r3,0(r16)
8112d220:	10004326 	beq	r2,zero,8112d330 <__sfvwrite_r+0x458>
8112d224:	9805883a 	mov	r2,r19
8112d228:	003f8606 	br	8112d044 <__reset+0xfb10d044>
8112d22c:	b00d883a 	mov	r6,r22
8112d230:	e00b883a 	mov	r5,fp
8112d234:	da000115 	stw	r8,4(sp)
8112d238:	112da340 	call	8112da34 <memmove>
8112d23c:	80800217 	ldw	r2,8(r16)
8112d240:	80c00017 	ldw	r3,0(r16)
8112d244:	da000117 	ldw	r8,4(sp)
8112d248:	1585c83a 	sub	r2,r2,r22
8112d24c:	1dad883a 	add	r22,r3,r22
8112d250:	80800215 	stw	r2,8(r16)
8112d254:	85800015 	stw	r22,0(r16)
8112d258:	003fbf06 	br	8112d158 <__reset+0xfb10d158>
8112d25c:	81000017 	ldw	r4,0(r16)
8112d260:	9027883a 	mov	r19,r18
8112d264:	902f883a 	mov	r23,r18
8112d268:	003f6c06 	br	8112d01c <__reset+0xfb10d01c>
8112d26c:	900d883a 	mov	r6,r18
8112d270:	01400284 	movi	r5,10
8112d274:	e009883a 	mov	r4,fp
8112d278:	112d9500 	call	8112d950 <memchr>
8112d27c:	10003e26 	beq	r2,zero,8112d378 <__sfvwrite_r+0x4a0>
8112d280:	10800044 	addi	r2,r2,1
8112d284:	1727c83a 	sub	r19,r2,fp
8112d288:	02000044 	movi	r8,1
8112d28c:	003f9d06 	br	8112d104 <__reset+0xfb10d104>
8112d290:	80800517 	ldw	r2,20(r16)
8112d294:	81400417 	ldw	r5,16(r16)
8112d298:	81c00017 	ldw	r7,0(r16)
8112d29c:	10a7883a 	add	r19,r2,r2
8112d2a0:	9885883a 	add	r2,r19,r2
8112d2a4:	1026d7fa 	srli	r19,r2,31
8112d2a8:	396dc83a 	sub	r22,r7,r5
8112d2ac:	b1000044 	addi	r4,r22,1
8112d2b0:	9885883a 	add	r2,r19,r2
8112d2b4:	1027d07a 	srai	r19,r2,1
8112d2b8:	2485883a 	add	r2,r4,r18
8112d2bc:	980d883a 	mov	r6,r19
8112d2c0:	9880022e 	bgeu	r19,r2,8112d2cc <__sfvwrite_r+0x3f4>
8112d2c4:	1027883a 	mov	r19,r2
8112d2c8:	100d883a 	mov	r6,r2
8112d2cc:	18c1000c 	andi	r3,r3,1024
8112d2d0:	18001c26 	beq	r3,zero,8112d344 <__sfvwrite_r+0x46c>
8112d2d4:	300b883a 	mov	r5,r6
8112d2d8:	a809883a 	mov	r4,r21
8112d2dc:	11231c80 	call	811231c8 <_malloc_r>
8112d2e0:	102f883a 	mov	r23,r2
8112d2e4:	10002926 	beq	r2,zero,8112d38c <__sfvwrite_r+0x4b4>
8112d2e8:	81400417 	ldw	r5,16(r16)
8112d2ec:	b00d883a 	mov	r6,r22
8112d2f0:	1009883a 	mov	r4,r2
8112d2f4:	11239dc0 	call	811239dc <memcpy>
8112d2f8:	8080030b 	ldhu	r2,12(r16)
8112d2fc:	00fedfc4 	movi	r3,-1153
8112d300:	10c4703a 	and	r2,r2,r3
8112d304:	10802014 	ori	r2,r2,128
8112d308:	8080030d 	sth	r2,12(r16)
8112d30c:	bd89883a 	add	r4,r23,r22
8112d310:	9d8fc83a 	sub	r7,r19,r22
8112d314:	85c00415 	stw	r23,16(r16)
8112d318:	84c00515 	stw	r19,20(r16)
8112d31c:	81000015 	stw	r4,0(r16)
8112d320:	9027883a 	mov	r19,r18
8112d324:	81c00215 	stw	r7,8(r16)
8112d328:	902f883a 	mov	r23,r18
8112d32c:	003f3b06 	br	8112d01c <__reset+0xfb10d01c>
8112d330:	800b883a 	mov	r5,r16
8112d334:	a809883a 	mov	r4,r21
8112d338:	112c32c0 	call	8112c32c <_fflush_r>
8112d33c:	103fb926 	beq	r2,zero,8112d224 <__reset+0xfb10d224>
8112d340:	003f6506 	br	8112d0d8 <__reset+0xfb10d0d8>
8112d344:	a809883a 	mov	r4,r21
8112d348:	112ec540 	call	8112ec54 <_realloc_r>
8112d34c:	102f883a 	mov	r23,r2
8112d350:	103fee1e 	bne	r2,zero,8112d30c <__reset+0xfb10d30c>
8112d354:	81400417 	ldw	r5,16(r16)
8112d358:	a809883a 	mov	r4,r21
8112d35c:	112cbc00 	call	8112cbc0 <_free_r>
8112d360:	8080030b 	ldhu	r2,12(r16)
8112d364:	00ffdfc4 	movi	r3,-129
8112d368:	1884703a 	and	r2,r3,r2
8112d36c:	00c00304 	movi	r3,12
8112d370:	a8c00015 	stw	r3,0(r21)
8112d374:	003f5906 	br	8112d0dc <__reset+0xfb10d0dc>
8112d378:	94c00044 	addi	r19,r18,1
8112d37c:	02000044 	movi	r8,1
8112d380:	003f6006 	br	8112d104 <__reset+0xfb10d104>
8112d384:	00bfffc4 	movi	r2,-1
8112d388:	003f0306 	br	8112cf98 <__reset+0xfb10cf98>
8112d38c:	00800304 	movi	r2,12
8112d390:	a8800015 	stw	r2,0(r21)
8112d394:	8080030b 	ldhu	r2,12(r16)
8112d398:	003f5006 	br	8112d0dc <__reset+0xfb10d0dc>

8112d39c <_fwalk>:
8112d39c:	defff704 	addi	sp,sp,-36
8112d3a0:	de00012e 	bgeu	sp,et,8112d3a8 <_fwalk+0xc>
8112d3a4:	003b68fa 	trap	3
8112d3a8:	dd000415 	stw	r20,16(sp)
8112d3ac:	dfc00815 	stw	ra,32(sp)
8112d3b0:	ddc00715 	stw	r23,28(sp)
8112d3b4:	dd800615 	stw	r22,24(sp)
8112d3b8:	dd400515 	stw	r21,20(sp)
8112d3bc:	dcc00315 	stw	r19,12(sp)
8112d3c0:	dc800215 	stw	r18,8(sp)
8112d3c4:	dc400115 	stw	r17,4(sp)
8112d3c8:	dc000015 	stw	r16,0(sp)
8112d3cc:	2500b804 	addi	r20,r4,736
8112d3d0:	a0002326 	beq	r20,zero,8112d460 <_fwalk+0xc4>
8112d3d4:	282b883a 	mov	r21,r5
8112d3d8:	002f883a 	mov	r23,zero
8112d3dc:	05800044 	movi	r22,1
8112d3e0:	04ffffc4 	movi	r19,-1
8112d3e4:	a4400117 	ldw	r17,4(r20)
8112d3e8:	a4800217 	ldw	r18,8(r20)
8112d3ec:	8c7fffc4 	addi	r17,r17,-1
8112d3f0:	88000d16 	blt	r17,zero,8112d428 <_fwalk+0x8c>
8112d3f4:	94000304 	addi	r16,r18,12
8112d3f8:	94800384 	addi	r18,r18,14
8112d3fc:	8080000b 	ldhu	r2,0(r16)
8112d400:	8c7fffc4 	addi	r17,r17,-1
8112d404:	813ffd04 	addi	r4,r16,-12
8112d408:	b080042e 	bgeu	r22,r2,8112d41c <_fwalk+0x80>
8112d40c:	9080000f 	ldh	r2,0(r18)
8112d410:	14c00226 	beq	r2,r19,8112d41c <_fwalk+0x80>
8112d414:	a83ee83a 	callr	r21
8112d418:	b8aeb03a 	or	r23,r23,r2
8112d41c:	84001a04 	addi	r16,r16,104
8112d420:	94801a04 	addi	r18,r18,104
8112d424:	8cfff51e 	bne	r17,r19,8112d3fc <__reset+0xfb10d3fc>
8112d428:	a5000017 	ldw	r20,0(r20)
8112d42c:	a03fed1e 	bne	r20,zero,8112d3e4 <__reset+0xfb10d3e4>
8112d430:	b805883a 	mov	r2,r23
8112d434:	dfc00817 	ldw	ra,32(sp)
8112d438:	ddc00717 	ldw	r23,28(sp)
8112d43c:	dd800617 	ldw	r22,24(sp)
8112d440:	dd400517 	ldw	r21,20(sp)
8112d444:	dd000417 	ldw	r20,16(sp)
8112d448:	dcc00317 	ldw	r19,12(sp)
8112d44c:	dc800217 	ldw	r18,8(sp)
8112d450:	dc400117 	ldw	r17,4(sp)
8112d454:	dc000017 	ldw	r16,0(sp)
8112d458:	dec00904 	addi	sp,sp,36
8112d45c:	f800283a 	ret
8112d460:	002f883a 	mov	r23,zero
8112d464:	003ff206 	br	8112d430 <__reset+0xfb10d430>

8112d468 <_fwalk_reent>:
8112d468:	defff704 	addi	sp,sp,-36
8112d46c:	de00012e 	bgeu	sp,et,8112d474 <_fwalk_reent+0xc>
8112d470:	003b68fa 	trap	3
8112d474:	dd000415 	stw	r20,16(sp)
8112d478:	dfc00815 	stw	ra,32(sp)
8112d47c:	ddc00715 	stw	r23,28(sp)
8112d480:	dd800615 	stw	r22,24(sp)
8112d484:	dd400515 	stw	r21,20(sp)
8112d488:	dcc00315 	stw	r19,12(sp)
8112d48c:	dc800215 	stw	r18,8(sp)
8112d490:	dc400115 	stw	r17,4(sp)
8112d494:	dc000015 	stw	r16,0(sp)
8112d498:	2500b804 	addi	r20,r4,736
8112d49c:	a0002326 	beq	r20,zero,8112d52c <_fwalk_reent+0xc4>
8112d4a0:	282b883a 	mov	r21,r5
8112d4a4:	2027883a 	mov	r19,r4
8112d4a8:	002f883a 	mov	r23,zero
8112d4ac:	05800044 	movi	r22,1
8112d4b0:	04bfffc4 	movi	r18,-1
8112d4b4:	a4400117 	ldw	r17,4(r20)
8112d4b8:	a4000217 	ldw	r16,8(r20)
8112d4bc:	8c7fffc4 	addi	r17,r17,-1
8112d4c0:	88000c16 	blt	r17,zero,8112d4f4 <_fwalk_reent+0x8c>
8112d4c4:	84000304 	addi	r16,r16,12
8112d4c8:	8080000b 	ldhu	r2,0(r16)
8112d4cc:	8c7fffc4 	addi	r17,r17,-1
8112d4d0:	817ffd04 	addi	r5,r16,-12
8112d4d4:	b080052e 	bgeu	r22,r2,8112d4ec <_fwalk_reent+0x84>
8112d4d8:	8080008f 	ldh	r2,2(r16)
8112d4dc:	9809883a 	mov	r4,r19
8112d4e0:	14800226 	beq	r2,r18,8112d4ec <_fwalk_reent+0x84>
8112d4e4:	a83ee83a 	callr	r21
8112d4e8:	b8aeb03a 	or	r23,r23,r2
8112d4ec:	84001a04 	addi	r16,r16,104
8112d4f0:	8cbff51e 	bne	r17,r18,8112d4c8 <__reset+0xfb10d4c8>
8112d4f4:	a5000017 	ldw	r20,0(r20)
8112d4f8:	a03fee1e 	bne	r20,zero,8112d4b4 <__reset+0xfb10d4b4>
8112d4fc:	b805883a 	mov	r2,r23
8112d500:	dfc00817 	ldw	ra,32(sp)
8112d504:	ddc00717 	ldw	r23,28(sp)
8112d508:	dd800617 	ldw	r22,24(sp)
8112d50c:	dd400517 	ldw	r21,20(sp)
8112d510:	dd000417 	ldw	r20,16(sp)
8112d514:	dcc00317 	ldw	r19,12(sp)
8112d518:	dc800217 	ldw	r18,8(sp)
8112d51c:	dc400117 	ldw	r17,4(sp)
8112d520:	dc000017 	ldw	r16,0(sp)
8112d524:	dec00904 	addi	sp,sp,36
8112d528:	f800283a 	ret
8112d52c:	002f883a 	mov	r23,zero
8112d530:	003ff206 	br	8112d4fc <__reset+0xfb10d4fc>

8112d534 <_isatty_r>:
8112d534:	defffd04 	addi	sp,sp,-12
8112d538:	de00012e 	bgeu	sp,et,8112d540 <_isatty_r+0xc>
8112d53c:	003b68fa 	trap	3
8112d540:	dc000015 	stw	r16,0(sp)
8112d544:	04204574 	movhi	r16,33045
8112d548:	dc400115 	stw	r17,4(sp)
8112d54c:	84116404 	addi	r16,r16,17808
8112d550:	2023883a 	mov	r17,r4
8112d554:	2809883a 	mov	r4,r5
8112d558:	dfc00215 	stw	ra,8(sp)
8112d55c:	80000015 	stw	zero,0(r16)
8112d560:	1137ac40 	call	81137ac4 <isatty>
8112d564:	00ffffc4 	movi	r3,-1
8112d568:	10c00526 	beq	r2,r3,8112d580 <_isatty_r+0x4c>
8112d56c:	dfc00217 	ldw	ra,8(sp)
8112d570:	dc400117 	ldw	r17,4(sp)
8112d574:	dc000017 	ldw	r16,0(sp)
8112d578:	dec00304 	addi	sp,sp,12
8112d57c:	f800283a 	ret
8112d580:	80c00017 	ldw	r3,0(r16)
8112d584:	183ff926 	beq	r3,zero,8112d56c <__reset+0xfb10d56c>
8112d588:	88c00015 	stw	r3,0(r17)
8112d58c:	003ff706 	br	8112d56c <__reset+0xfb10d56c>

8112d590 <iswspace>:
8112d590:	00803fc4 	movi	r2,255
8112d594:	11000836 	bltu	r2,r4,8112d5b8 <iswspace+0x28>
8112d598:	00a04574 	movhi	r2,33045
8112d59c:	1090ef04 	addi	r2,r2,17340
8112d5a0:	10800017 	ldw	r2,0(r2)
8112d5a4:	1109883a 	add	r4,r2,r4
8112d5a8:	20800043 	ldbu	r2,1(r4)
8112d5ac:	1080020c 	andi	r2,r2,8
8112d5b0:	10803fcc 	andi	r2,r2,255
8112d5b4:	f800283a 	ret
8112d5b8:	0005883a 	mov	r2,zero
8112d5bc:	f800283a 	ret

8112d5c0 <_setlocale_r>:
8112d5c0:	30001d26 	beq	r6,zero,8112d638 <_setlocale_r+0x78>
8112d5c4:	01604574 	movhi	r5,33045
8112d5c8:	defffe04 	addi	sp,sp,-8
8112d5cc:	29474804 	addi	r5,r5,7456
8112d5d0:	3009883a 	mov	r4,r6
8112d5d4:	de00012e 	bgeu	sp,et,8112d5dc <_setlocale_r+0x1c>
8112d5d8:	003b68fa 	trap	3
8112d5dc:	dc000015 	stw	r16,0(sp)
8112d5e0:	dfc00115 	stw	ra,4(sp)
8112d5e4:	3021883a 	mov	r16,r6
8112d5e8:	112f30c0 	call	8112f30c <strcmp>
8112d5ec:	1000061e 	bne	r2,zero,8112d608 <_setlocale_r+0x48>
8112d5f0:	00a04574 	movhi	r2,33045
8112d5f4:	10871704 	addi	r2,r2,7260
8112d5f8:	dfc00117 	ldw	ra,4(sp)
8112d5fc:	dc000017 	ldw	r16,0(sp)
8112d600:	dec00204 	addi	sp,sp,8
8112d604:	f800283a 	ret
8112d608:	01604574 	movhi	r5,33045
8112d60c:	29471704 	addi	r5,r5,7260
8112d610:	8009883a 	mov	r4,r16
8112d614:	112f30c0 	call	8112f30c <strcmp>
8112d618:	103ff526 	beq	r2,zero,8112d5f0 <__reset+0xfb10d5f0>
8112d61c:	01604574 	movhi	r5,33045
8112d620:	29472104 	addi	r5,r5,7300
8112d624:	8009883a 	mov	r4,r16
8112d628:	112f30c0 	call	8112f30c <strcmp>
8112d62c:	103ff026 	beq	r2,zero,8112d5f0 <__reset+0xfb10d5f0>
8112d630:	0005883a 	mov	r2,zero
8112d634:	003ff006 	br	8112d5f8 <__reset+0xfb10d5f8>
8112d638:	00a04574 	movhi	r2,33045
8112d63c:	10871704 	addi	r2,r2,7260
8112d640:	f800283a 	ret

8112d644 <__locale_charset>:
8112d644:	00a04574 	movhi	r2,33045
8112d648:	108bb904 	addi	r2,r2,12004
8112d64c:	f800283a 	ret

8112d650 <__locale_mb_cur_max>:
8112d650:	00a04574 	movhi	r2,33045
8112d654:	1090f404 	addi	r2,r2,17360
8112d658:	10800017 	ldw	r2,0(r2)
8112d65c:	f800283a 	ret

8112d660 <__locale_msgcharset>:
8112d660:	00a04574 	movhi	r2,33045
8112d664:	108bb104 	addi	r2,r2,11972
8112d668:	f800283a 	ret

8112d66c <__locale_cjk_lang>:
8112d66c:	0005883a 	mov	r2,zero
8112d670:	f800283a 	ret

8112d674 <_localeconv_r>:
8112d674:	00a04574 	movhi	r2,33045
8112d678:	108bc104 	addi	r2,r2,12036
8112d67c:	f800283a 	ret

8112d680 <setlocale>:
8112d680:	00a04574 	movhi	r2,33045
8112d684:	1090f104 	addi	r2,r2,17348
8112d688:	280d883a 	mov	r6,r5
8112d68c:	200b883a 	mov	r5,r4
8112d690:	11000017 	ldw	r4,0(r2)
8112d694:	112d5c01 	jmpi	8112d5c0 <_setlocale_r>

8112d698 <localeconv>:
8112d698:	00a04574 	movhi	r2,33045
8112d69c:	108bc104 	addi	r2,r2,12036
8112d6a0:	f800283a 	ret

8112d6a4 <_lseek_r>:
8112d6a4:	defffd04 	addi	sp,sp,-12
8112d6a8:	de00012e 	bgeu	sp,et,8112d6b0 <_lseek_r+0xc>
8112d6ac:	003b68fa 	trap	3
8112d6b0:	2805883a 	mov	r2,r5
8112d6b4:	dc000015 	stw	r16,0(sp)
8112d6b8:	04204574 	movhi	r16,33045
8112d6bc:	dc400115 	stw	r17,4(sp)
8112d6c0:	300b883a 	mov	r5,r6
8112d6c4:	84116404 	addi	r16,r16,17808
8112d6c8:	2023883a 	mov	r17,r4
8112d6cc:	380d883a 	mov	r6,r7
8112d6d0:	1009883a 	mov	r4,r2
8112d6d4:	dfc00215 	stw	ra,8(sp)
8112d6d8:	80000015 	stw	zero,0(r16)
8112d6dc:	11386c00 	call	811386c0 <lseek>
8112d6e0:	00ffffc4 	movi	r3,-1
8112d6e4:	10c00526 	beq	r2,r3,8112d6fc <_lseek_r+0x58>
8112d6e8:	dfc00217 	ldw	ra,8(sp)
8112d6ec:	dc400117 	ldw	r17,4(sp)
8112d6f0:	dc000017 	ldw	r16,0(sp)
8112d6f4:	dec00304 	addi	sp,sp,12
8112d6f8:	f800283a 	ret
8112d6fc:	80c00017 	ldw	r3,0(r16)
8112d700:	183ff926 	beq	r3,zero,8112d6e8 <__reset+0xfb10d6e8>
8112d704:	88c00015 	stw	r3,0(r17)
8112d708:	003ff706 	br	8112d6e8 <__reset+0xfb10d6e8>

8112d70c <_mbrtowc_r>:
8112d70c:	defff704 	addi	sp,sp,-36
8112d710:	00a04574 	movhi	r2,33045
8112d714:	de00012e 	bgeu	sp,et,8112d71c <_mbrtowc_r+0x10>
8112d718:	003b68fa 	trap	3
8112d71c:	1090f504 	addi	r2,r2,17364
8112d720:	dc800715 	stw	r18,28(sp)
8112d724:	dc400615 	stw	r17,24(sp)
8112d728:	dc000515 	stw	r16,20(sp)
8112d72c:	dfc00815 	stw	ra,32(sp)
8112d730:	2021883a 	mov	r16,r4
8112d734:	dc400917 	ldw	r17,36(sp)
8112d738:	14800017 	ldw	r18,0(r2)
8112d73c:	30001626 	beq	r6,zero,8112d798 <_mbrtowc_r+0x8c>
8112d740:	d9400215 	stw	r5,8(sp)
8112d744:	d9800315 	stw	r6,12(sp)
8112d748:	d9c00415 	stw	r7,16(sp)
8112d74c:	112d6440 	call	8112d644 <__locale_charset>
8112d750:	d9c00417 	ldw	r7,16(sp)
8112d754:	d9800317 	ldw	r6,12(sp)
8112d758:	d9400217 	ldw	r5,8(sp)
8112d75c:	d8800015 	stw	r2,0(sp)
8112d760:	dc400115 	stw	r17,4(sp)
8112d764:	8009883a 	mov	r4,r16
8112d768:	903ee83a 	callr	r18
8112d76c:	00ffffc4 	movi	r3,-1
8112d770:	10c0031e 	bne	r2,r3,8112d780 <_mbrtowc_r+0x74>
8112d774:	88000015 	stw	zero,0(r17)
8112d778:	00c02284 	movi	r3,138
8112d77c:	80c00015 	stw	r3,0(r16)
8112d780:	dfc00817 	ldw	ra,32(sp)
8112d784:	dc800717 	ldw	r18,28(sp)
8112d788:	dc400617 	ldw	r17,24(sp)
8112d78c:	dc000517 	ldw	r16,20(sp)
8112d790:	dec00904 	addi	sp,sp,36
8112d794:	f800283a 	ret
8112d798:	112d6440 	call	8112d644 <__locale_charset>
8112d79c:	01a04574 	movhi	r6,33045
8112d7a0:	31872104 	addi	r6,r6,7300
8112d7a4:	dc400115 	stw	r17,4(sp)
8112d7a8:	d8800015 	stw	r2,0(sp)
8112d7ac:	01c00044 	movi	r7,1
8112d7b0:	000b883a 	mov	r5,zero
8112d7b4:	8009883a 	mov	r4,r16
8112d7b8:	903ee83a 	callr	r18
8112d7bc:	003feb06 	br	8112d76c <__reset+0xfb10d76c>

8112d7c0 <mbrtowc>:
8112d7c0:	defff704 	addi	sp,sp,-36
8112d7c4:	00a04574 	movhi	r2,33045
8112d7c8:	de00012e 	bgeu	sp,et,8112d7d0 <mbrtowc+0x10>
8112d7cc:	003b68fa 	trap	3
8112d7d0:	1090f104 	addi	r2,r2,17348
8112d7d4:	dc800415 	stw	r18,16(sp)
8112d7d8:	dc400315 	stw	r17,12(sp)
8112d7dc:	dfc00815 	stw	ra,32(sp)
8112d7e0:	dd400715 	stw	r21,28(sp)
8112d7e4:	dd000615 	stw	r20,24(sp)
8112d7e8:	dcc00515 	stw	r19,20(sp)
8112d7ec:	dc000215 	stw	r16,8(sp)
8112d7f0:	3825883a 	mov	r18,r7
8112d7f4:	14400017 	ldw	r17,0(r2)
8112d7f8:	28001c26 	beq	r5,zero,8112d86c <mbrtowc+0xac>
8112d7fc:	00a04574 	movhi	r2,33045
8112d800:	1090f504 	addi	r2,r2,17364
8112d804:	15400017 	ldw	r21,0(r2)
8112d808:	2821883a 	mov	r16,r5
8112d80c:	2027883a 	mov	r19,r4
8112d810:	3029883a 	mov	r20,r6
8112d814:	112d6440 	call	8112d644 <__locale_charset>
8112d818:	d8800015 	stw	r2,0(sp)
8112d81c:	dc800115 	stw	r18,4(sp)
8112d820:	a00f883a 	mov	r7,r20
8112d824:	800d883a 	mov	r6,r16
8112d828:	980b883a 	mov	r5,r19
8112d82c:	8809883a 	mov	r4,r17
8112d830:	a83ee83a 	callr	r21
8112d834:	00ffffc4 	movi	r3,-1
8112d838:	10c0031e 	bne	r2,r3,8112d848 <mbrtowc+0x88>
8112d83c:	90000015 	stw	zero,0(r18)
8112d840:	00c02284 	movi	r3,138
8112d844:	88c00015 	stw	r3,0(r17)
8112d848:	dfc00817 	ldw	ra,32(sp)
8112d84c:	dd400717 	ldw	r21,28(sp)
8112d850:	dd000617 	ldw	r20,24(sp)
8112d854:	dcc00517 	ldw	r19,20(sp)
8112d858:	dc800417 	ldw	r18,16(sp)
8112d85c:	dc400317 	ldw	r17,12(sp)
8112d860:	dc000217 	ldw	r16,8(sp)
8112d864:	dec00904 	addi	sp,sp,36
8112d868:	f800283a 	ret
8112d86c:	00a04574 	movhi	r2,33045
8112d870:	1090f504 	addi	r2,r2,17364
8112d874:	14000017 	ldw	r16,0(r2)
8112d878:	112d6440 	call	8112d644 <__locale_charset>
8112d87c:	01a04574 	movhi	r6,33045
8112d880:	31872104 	addi	r6,r6,7300
8112d884:	dc800115 	stw	r18,4(sp)
8112d888:	d8800015 	stw	r2,0(sp)
8112d88c:	01c00044 	movi	r7,1
8112d890:	000b883a 	mov	r5,zero
8112d894:	8809883a 	mov	r4,r17
8112d898:	803ee83a 	callr	r16
8112d89c:	003fe506 	br	8112d834 <__reset+0xfb10d834>

8112d8a0 <__ascii_mbtowc>:
8112d8a0:	deffff04 	addi	sp,sp,-4
8112d8a4:	de00012e 	bgeu	sp,et,8112d8ac <__ascii_mbtowc+0xc>
8112d8a8:	003b68fa 	trap	3
8112d8ac:	28000826 	beq	r5,zero,8112d8d0 <__ascii_mbtowc+0x30>
8112d8b0:	30000926 	beq	r6,zero,8112d8d8 <__ascii_mbtowc+0x38>
8112d8b4:	38000b26 	beq	r7,zero,8112d8e4 <__ascii_mbtowc+0x44>
8112d8b8:	30800003 	ldbu	r2,0(r6)
8112d8bc:	28800015 	stw	r2,0(r5)
8112d8c0:	30800003 	ldbu	r2,0(r6)
8112d8c4:	1004c03a 	cmpne	r2,r2,zero
8112d8c8:	dec00104 	addi	sp,sp,4
8112d8cc:	f800283a 	ret
8112d8d0:	d80b883a 	mov	r5,sp
8112d8d4:	303ff71e 	bne	r6,zero,8112d8b4 <__reset+0xfb10d8b4>
8112d8d8:	0005883a 	mov	r2,zero
8112d8dc:	dec00104 	addi	sp,sp,4
8112d8e0:	f800283a 	ret
8112d8e4:	00bfff84 	movi	r2,-2
8112d8e8:	003ff706 	br	8112d8c8 <__reset+0xfb10d8c8>

8112d8ec <_mbtowc_r>:
8112d8ec:	00a04574 	movhi	r2,33045
8112d8f0:	defff804 	addi	sp,sp,-32
8112d8f4:	1090f504 	addi	r2,r2,17364
8112d8f8:	de00012e 	bgeu	sp,et,8112d900 <_mbtowc_r+0x14>
8112d8fc:	003b68fa 	trap	3
8112d900:	dfc00715 	stw	ra,28(sp)
8112d904:	dc000615 	stw	r16,24(sp)
8112d908:	14000017 	ldw	r16,0(r2)
8112d90c:	d9000215 	stw	r4,8(sp)
8112d910:	d9400315 	stw	r5,12(sp)
8112d914:	d9800415 	stw	r6,16(sp)
8112d918:	d9c00515 	stw	r7,20(sp)
8112d91c:	112d6440 	call	8112d644 <__locale_charset>
8112d920:	d8800015 	stw	r2,0(sp)
8112d924:	d8800817 	ldw	r2,32(sp)
8112d928:	d9c00517 	ldw	r7,20(sp)
8112d92c:	d9800417 	ldw	r6,16(sp)
8112d930:	d9400317 	ldw	r5,12(sp)
8112d934:	d9000217 	ldw	r4,8(sp)
8112d938:	d8800115 	stw	r2,4(sp)
8112d93c:	803ee83a 	callr	r16
8112d940:	dfc00717 	ldw	ra,28(sp)
8112d944:	dc000617 	ldw	r16,24(sp)
8112d948:	dec00804 	addi	sp,sp,32
8112d94c:	f800283a 	ret

8112d950 <memchr>:
8112d950:	208000cc 	andi	r2,r4,3
8112d954:	280f883a 	mov	r7,r5
8112d958:	10003426 	beq	r2,zero,8112da2c <memchr+0xdc>
8112d95c:	30bfffc4 	addi	r2,r6,-1
8112d960:	30001a26 	beq	r6,zero,8112d9cc <memchr+0x7c>
8112d964:	20c00003 	ldbu	r3,0(r4)
8112d968:	29803fcc 	andi	r6,r5,255
8112d96c:	30c0051e 	bne	r6,r3,8112d984 <memchr+0x34>
8112d970:	00001806 	br	8112d9d4 <memchr+0x84>
8112d974:	10001526 	beq	r2,zero,8112d9cc <memchr+0x7c>
8112d978:	20c00003 	ldbu	r3,0(r4)
8112d97c:	10bfffc4 	addi	r2,r2,-1
8112d980:	30c01426 	beq	r6,r3,8112d9d4 <memchr+0x84>
8112d984:	21000044 	addi	r4,r4,1
8112d988:	20c000cc 	andi	r3,r4,3
8112d98c:	183ff91e 	bne	r3,zero,8112d974 <__reset+0xfb10d974>
8112d990:	020000c4 	movi	r8,3
8112d994:	40801136 	bltu	r8,r2,8112d9dc <memchr+0x8c>
8112d998:	10000c26 	beq	r2,zero,8112d9cc <memchr+0x7c>
8112d99c:	20c00003 	ldbu	r3,0(r4)
8112d9a0:	29403fcc 	andi	r5,r5,255
8112d9a4:	28c00b26 	beq	r5,r3,8112d9d4 <memchr+0x84>
8112d9a8:	20c00044 	addi	r3,r4,1
8112d9ac:	39803fcc 	andi	r6,r7,255
8112d9b0:	2089883a 	add	r4,r4,r2
8112d9b4:	00000306 	br	8112d9c4 <memchr+0x74>
8112d9b8:	18c00044 	addi	r3,r3,1
8112d9bc:	197fffc3 	ldbu	r5,-1(r3)
8112d9c0:	31400526 	beq	r6,r5,8112d9d8 <memchr+0x88>
8112d9c4:	1805883a 	mov	r2,r3
8112d9c8:	20fffb1e 	bne	r4,r3,8112d9b8 <__reset+0xfb10d9b8>
8112d9cc:	0005883a 	mov	r2,zero
8112d9d0:	f800283a 	ret
8112d9d4:	2005883a 	mov	r2,r4
8112d9d8:	f800283a 	ret
8112d9dc:	28c03fcc 	andi	r3,r5,255
8112d9e0:	1812923a 	slli	r9,r3,8
8112d9e4:	02ffbff4 	movhi	r11,65279
8112d9e8:	02a02074 	movhi	r10,32897
8112d9ec:	48d2b03a 	or	r9,r9,r3
8112d9f0:	4806943a 	slli	r3,r9,16
8112d9f4:	5affbfc4 	addi	r11,r11,-257
8112d9f8:	52a02004 	addi	r10,r10,-32640
8112d9fc:	48d2b03a 	or	r9,r9,r3
8112da00:	20c00017 	ldw	r3,0(r4)
8112da04:	48c6f03a 	xor	r3,r9,r3
8112da08:	1acd883a 	add	r6,r3,r11
8112da0c:	00c6303a 	nor	r3,zero,r3
8112da10:	30c6703a 	and	r3,r6,r3
8112da14:	1a86703a 	and	r3,r3,r10
8112da18:	183fe01e 	bne	r3,zero,8112d99c <__reset+0xfb10d99c>
8112da1c:	10bfff04 	addi	r2,r2,-4
8112da20:	21000104 	addi	r4,r4,4
8112da24:	40bff636 	bltu	r8,r2,8112da00 <__reset+0xfb10da00>
8112da28:	003fdb06 	br	8112d998 <__reset+0xfb10d998>
8112da2c:	3005883a 	mov	r2,r6
8112da30:	003fd706 	br	8112d990 <__reset+0xfb10d990>

8112da34 <memmove>:
8112da34:	2005883a 	mov	r2,r4
8112da38:	29000b2e 	bgeu	r5,r4,8112da68 <memmove+0x34>
8112da3c:	298f883a 	add	r7,r5,r6
8112da40:	21c0092e 	bgeu	r4,r7,8112da68 <memmove+0x34>
8112da44:	2187883a 	add	r3,r4,r6
8112da48:	198bc83a 	sub	r5,r3,r6
8112da4c:	30004826 	beq	r6,zero,8112db70 <memmove+0x13c>
8112da50:	39ffffc4 	addi	r7,r7,-1
8112da54:	39000003 	ldbu	r4,0(r7)
8112da58:	18ffffc4 	addi	r3,r3,-1
8112da5c:	19000005 	stb	r4,0(r3)
8112da60:	28fffb1e 	bne	r5,r3,8112da50 <__reset+0xfb10da50>
8112da64:	f800283a 	ret
8112da68:	00c003c4 	movi	r3,15
8112da6c:	1980412e 	bgeu	r3,r6,8112db74 <memmove+0x140>
8112da70:	2886b03a 	or	r3,r5,r2
8112da74:	18c000cc 	andi	r3,r3,3
8112da78:	1800401e 	bne	r3,zero,8112db7c <memmove+0x148>
8112da7c:	33fffc04 	addi	r15,r6,-16
8112da80:	781ed13a 	srli	r15,r15,4
8112da84:	28c00104 	addi	r3,r5,4
8112da88:	13400104 	addi	r13,r2,4
8112da8c:	781c913a 	slli	r14,r15,4
8112da90:	2b000204 	addi	r12,r5,8
8112da94:	12c00204 	addi	r11,r2,8
8112da98:	73800504 	addi	r14,r14,20
8112da9c:	2a800304 	addi	r10,r5,12
8112daa0:	12400304 	addi	r9,r2,12
8112daa4:	2b9d883a 	add	r14,r5,r14
8112daa8:	2811883a 	mov	r8,r5
8112daac:	100f883a 	mov	r7,r2
8112dab0:	41000017 	ldw	r4,0(r8)
8112dab4:	39c00404 	addi	r7,r7,16
8112dab8:	18c00404 	addi	r3,r3,16
8112dabc:	393ffc15 	stw	r4,-16(r7)
8112dac0:	193ffc17 	ldw	r4,-16(r3)
8112dac4:	6b400404 	addi	r13,r13,16
8112dac8:	5ac00404 	addi	r11,r11,16
8112dacc:	693ffc15 	stw	r4,-16(r13)
8112dad0:	61000017 	ldw	r4,0(r12)
8112dad4:	4a400404 	addi	r9,r9,16
8112dad8:	42000404 	addi	r8,r8,16
8112dadc:	593ffc15 	stw	r4,-16(r11)
8112dae0:	51000017 	ldw	r4,0(r10)
8112dae4:	63000404 	addi	r12,r12,16
8112dae8:	52800404 	addi	r10,r10,16
8112daec:	493ffc15 	stw	r4,-16(r9)
8112daf0:	1bbfef1e 	bne	r3,r14,8112dab0 <__reset+0xfb10dab0>
8112daf4:	79000044 	addi	r4,r15,1
8112daf8:	2008913a 	slli	r4,r4,4
8112dafc:	328003cc 	andi	r10,r6,15
8112db00:	02c000c4 	movi	r11,3
8112db04:	1107883a 	add	r3,r2,r4
8112db08:	290b883a 	add	r5,r5,r4
8112db0c:	5a801e2e 	bgeu	r11,r10,8112db88 <memmove+0x154>
8112db10:	1813883a 	mov	r9,r3
8112db14:	2811883a 	mov	r8,r5
8112db18:	500f883a 	mov	r7,r10
8112db1c:	41000017 	ldw	r4,0(r8)
8112db20:	4a400104 	addi	r9,r9,4
8112db24:	39ffff04 	addi	r7,r7,-4
8112db28:	493fff15 	stw	r4,-4(r9)
8112db2c:	42000104 	addi	r8,r8,4
8112db30:	59fffa36 	bltu	r11,r7,8112db1c <__reset+0xfb10db1c>
8112db34:	513fff04 	addi	r4,r10,-4
8112db38:	2008d0ba 	srli	r4,r4,2
8112db3c:	318000cc 	andi	r6,r6,3
8112db40:	21000044 	addi	r4,r4,1
8112db44:	2109883a 	add	r4,r4,r4
8112db48:	2109883a 	add	r4,r4,r4
8112db4c:	1907883a 	add	r3,r3,r4
8112db50:	290b883a 	add	r5,r5,r4
8112db54:	30000b26 	beq	r6,zero,8112db84 <memmove+0x150>
8112db58:	198d883a 	add	r6,r3,r6
8112db5c:	29c00003 	ldbu	r7,0(r5)
8112db60:	18c00044 	addi	r3,r3,1
8112db64:	29400044 	addi	r5,r5,1
8112db68:	19ffffc5 	stb	r7,-1(r3)
8112db6c:	19bffb1e 	bne	r3,r6,8112db5c <__reset+0xfb10db5c>
8112db70:	f800283a 	ret
8112db74:	1007883a 	mov	r3,r2
8112db78:	003ff606 	br	8112db54 <__reset+0xfb10db54>
8112db7c:	1007883a 	mov	r3,r2
8112db80:	003ff506 	br	8112db58 <__reset+0xfb10db58>
8112db84:	f800283a 	ret
8112db88:	500d883a 	mov	r6,r10
8112db8c:	003ff106 	br	8112db54 <__reset+0xfb10db54>

8112db90 <_Balloc>:
8112db90:	defffc04 	addi	sp,sp,-16
8112db94:	de00012e 	bgeu	sp,et,8112db9c <_Balloc+0xc>
8112db98:	003b68fa 	trap	3
8112db9c:	20801317 	ldw	r2,76(r4)
8112dba0:	dc400115 	stw	r17,4(sp)
8112dba4:	dc000015 	stw	r16,0(sp)
8112dba8:	dfc00315 	stw	ra,12(sp)
8112dbac:	dc800215 	stw	r18,8(sp)
8112dbb0:	2023883a 	mov	r17,r4
8112dbb4:	2821883a 	mov	r16,r5
8112dbb8:	10000f26 	beq	r2,zero,8112dbf8 <_Balloc+0x68>
8112dbbc:	8407883a 	add	r3,r16,r16
8112dbc0:	18c7883a 	add	r3,r3,r3
8112dbc4:	10c7883a 	add	r3,r2,r3
8112dbc8:	18800017 	ldw	r2,0(r3)
8112dbcc:	10001126 	beq	r2,zero,8112dc14 <_Balloc+0x84>
8112dbd0:	11000017 	ldw	r4,0(r2)
8112dbd4:	19000015 	stw	r4,0(r3)
8112dbd8:	10000415 	stw	zero,16(r2)
8112dbdc:	10000315 	stw	zero,12(r2)
8112dbe0:	dfc00317 	ldw	ra,12(sp)
8112dbe4:	dc800217 	ldw	r18,8(sp)
8112dbe8:	dc400117 	ldw	r17,4(sp)
8112dbec:	dc000017 	ldw	r16,0(sp)
8112dbf0:	dec00404 	addi	sp,sp,16
8112dbf4:	f800283a 	ret
8112dbf8:	01800844 	movi	r6,33
8112dbfc:	01400104 	movi	r5,4
8112dc00:	11340b80 	call	811340b8 <_calloc_r>
8112dc04:	88801315 	stw	r2,76(r17)
8112dc08:	103fec1e 	bne	r2,zero,8112dbbc <__reset+0xfb10dbbc>
8112dc0c:	0005883a 	mov	r2,zero
8112dc10:	003ff306 	br	8112dbe0 <__reset+0xfb10dbe0>
8112dc14:	01400044 	movi	r5,1
8112dc18:	2c24983a 	sll	r18,r5,r16
8112dc1c:	8809883a 	mov	r4,r17
8112dc20:	91800144 	addi	r6,r18,5
8112dc24:	318d883a 	add	r6,r6,r6
8112dc28:	318d883a 	add	r6,r6,r6
8112dc2c:	11340b80 	call	811340b8 <_calloc_r>
8112dc30:	103ff626 	beq	r2,zero,8112dc0c <__reset+0xfb10dc0c>
8112dc34:	14000115 	stw	r16,4(r2)
8112dc38:	14800215 	stw	r18,8(r2)
8112dc3c:	003fe606 	br	8112dbd8 <__reset+0xfb10dbd8>

8112dc40 <_Bfree>:
8112dc40:	28000826 	beq	r5,zero,8112dc64 <_Bfree+0x24>
8112dc44:	28c00117 	ldw	r3,4(r5)
8112dc48:	20801317 	ldw	r2,76(r4)
8112dc4c:	18c7883a 	add	r3,r3,r3
8112dc50:	18c7883a 	add	r3,r3,r3
8112dc54:	10c5883a 	add	r2,r2,r3
8112dc58:	10c00017 	ldw	r3,0(r2)
8112dc5c:	28c00015 	stw	r3,0(r5)
8112dc60:	11400015 	stw	r5,0(r2)
8112dc64:	f800283a 	ret

8112dc68 <__multadd>:
8112dc68:	defffa04 	addi	sp,sp,-24
8112dc6c:	de00012e 	bgeu	sp,et,8112dc74 <__multadd+0xc>
8112dc70:	003b68fa 	trap	3
8112dc74:	0011883a 	mov	r8,zero
8112dc78:	dc800315 	stw	r18,12(sp)
8112dc7c:	dc400215 	stw	r17,8(sp)
8112dc80:	dc000115 	stw	r16,4(sp)
8112dc84:	2823883a 	mov	r17,r5
8112dc88:	2c000417 	ldw	r16,16(r5)
8112dc8c:	dfc00515 	stw	ra,20(sp)
8112dc90:	dcc00415 	stw	r19,16(sp)
8112dc94:	2025883a 	mov	r18,r4
8112dc98:	29400504 	addi	r5,r5,20
8112dc9c:	28c00017 	ldw	r3,0(r5)
8112dca0:	29400104 	addi	r5,r5,4
8112dca4:	42000044 	addi	r8,r8,1
8112dca8:	18bfffcc 	andi	r2,r3,65535
8112dcac:	1185383a 	mul	r2,r2,r6
8112dcb0:	1806d43a 	srli	r3,r3,16
8112dcb4:	11cf883a 	add	r7,r2,r7
8112dcb8:	3808d43a 	srli	r4,r7,16
8112dcbc:	1987383a 	mul	r3,r3,r6
8112dcc0:	38bfffcc 	andi	r2,r7,65535
8112dcc4:	1907883a 	add	r3,r3,r4
8112dcc8:	1808943a 	slli	r4,r3,16
8112dccc:	180ed43a 	srli	r7,r3,16
8112dcd0:	2085883a 	add	r2,r4,r2
8112dcd4:	28bfff15 	stw	r2,-4(r5)
8112dcd8:	443ff016 	blt	r8,r16,8112dc9c <__reset+0xfb10dc9c>
8112dcdc:	38000926 	beq	r7,zero,8112dd04 <__multadd+0x9c>
8112dce0:	88800217 	ldw	r2,8(r17)
8112dce4:	80800f0e 	bge	r16,r2,8112dd24 <__multadd+0xbc>
8112dce8:	80800144 	addi	r2,r16,5
8112dcec:	1085883a 	add	r2,r2,r2
8112dcf0:	1085883a 	add	r2,r2,r2
8112dcf4:	8885883a 	add	r2,r17,r2
8112dcf8:	11c00015 	stw	r7,0(r2)
8112dcfc:	84000044 	addi	r16,r16,1
8112dd00:	8c000415 	stw	r16,16(r17)
8112dd04:	8805883a 	mov	r2,r17
8112dd08:	dfc00517 	ldw	ra,20(sp)
8112dd0c:	dcc00417 	ldw	r19,16(sp)
8112dd10:	dc800317 	ldw	r18,12(sp)
8112dd14:	dc400217 	ldw	r17,8(sp)
8112dd18:	dc000117 	ldw	r16,4(sp)
8112dd1c:	dec00604 	addi	sp,sp,24
8112dd20:	f800283a 	ret
8112dd24:	89400117 	ldw	r5,4(r17)
8112dd28:	9009883a 	mov	r4,r18
8112dd2c:	d9c00015 	stw	r7,0(sp)
8112dd30:	29400044 	addi	r5,r5,1
8112dd34:	112db900 	call	8112db90 <_Balloc>
8112dd38:	89800417 	ldw	r6,16(r17)
8112dd3c:	89400304 	addi	r5,r17,12
8112dd40:	11000304 	addi	r4,r2,12
8112dd44:	31800084 	addi	r6,r6,2
8112dd48:	318d883a 	add	r6,r6,r6
8112dd4c:	318d883a 	add	r6,r6,r6
8112dd50:	1027883a 	mov	r19,r2
8112dd54:	11239dc0 	call	811239dc <memcpy>
8112dd58:	d9c00017 	ldw	r7,0(sp)
8112dd5c:	88000a26 	beq	r17,zero,8112dd88 <__multadd+0x120>
8112dd60:	88c00117 	ldw	r3,4(r17)
8112dd64:	90801317 	ldw	r2,76(r18)
8112dd68:	18c7883a 	add	r3,r3,r3
8112dd6c:	18c7883a 	add	r3,r3,r3
8112dd70:	10c5883a 	add	r2,r2,r3
8112dd74:	10c00017 	ldw	r3,0(r2)
8112dd78:	88c00015 	stw	r3,0(r17)
8112dd7c:	14400015 	stw	r17,0(r2)
8112dd80:	9823883a 	mov	r17,r19
8112dd84:	003fd806 	br	8112dce8 <__reset+0xfb10dce8>
8112dd88:	9823883a 	mov	r17,r19
8112dd8c:	003fd606 	br	8112dce8 <__reset+0xfb10dce8>

8112dd90 <__s2b>:
8112dd90:	defff904 	addi	sp,sp,-28
8112dd94:	de00012e 	bgeu	sp,et,8112dd9c <__s2b+0xc>
8112dd98:	003b68fa 	trap	3
8112dd9c:	dc400115 	stw	r17,4(sp)
8112dda0:	dc000015 	stw	r16,0(sp)
8112dda4:	2023883a 	mov	r17,r4
8112dda8:	2821883a 	mov	r16,r5
8112ddac:	39000204 	addi	r4,r7,8
8112ddb0:	01400244 	movi	r5,9
8112ddb4:	dcc00315 	stw	r19,12(sp)
8112ddb8:	dc800215 	stw	r18,8(sp)
8112ddbc:	dfc00615 	stw	ra,24(sp)
8112ddc0:	dd400515 	stw	r21,20(sp)
8112ddc4:	dd000415 	stw	r20,16(sp)
8112ddc8:	3825883a 	mov	r18,r7
8112ddcc:	3027883a 	mov	r19,r6
8112ddd0:	1135dd40 	call	81135dd4 <__divsi3>
8112ddd4:	00c00044 	movi	r3,1
8112ddd8:	000b883a 	mov	r5,zero
8112dddc:	1880030e 	bge	r3,r2,8112ddec <__s2b+0x5c>
8112dde0:	18c7883a 	add	r3,r3,r3
8112dde4:	29400044 	addi	r5,r5,1
8112dde8:	18bffd16 	blt	r3,r2,8112dde0 <__reset+0xfb10dde0>
8112ddec:	8809883a 	mov	r4,r17
8112ddf0:	112db900 	call	8112db90 <_Balloc>
8112ddf4:	d8c00717 	ldw	r3,28(sp)
8112ddf8:	10c00515 	stw	r3,20(r2)
8112ddfc:	00c00044 	movi	r3,1
8112de00:	10c00415 	stw	r3,16(r2)
8112de04:	00c00244 	movi	r3,9
8112de08:	1cc0210e 	bge	r3,r19,8112de90 <__s2b+0x100>
8112de0c:	80eb883a 	add	r21,r16,r3
8112de10:	a829883a 	mov	r20,r21
8112de14:	84e1883a 	add	r16,r16,r19
8112de18:	a1c00007 	ldb	r7,0(r20)
8112de1c:	01800284 	movi	r6,10
8112de20:	a5000044 	addi	r20,r20,1
8112de24:	100b883a 	mov	r5,r2
8112de28:	39fff404 	addi	r7,r7,-48
8112de2c:	8809883a 	mov	r4,r17
8112de30:	112dc680 	call	8112dc68 <__multadd>
8112de34:	a43ff81e 	bne	r20,r16,8112de18 <__reset+0xfb10de18>
8112de38:	ace1883a 	add	r16,r21,r19
8112de3c:	843ffe04 	addi	r16,r16,-8
8112de40:	9c800a0e 	bge	r19,r18,8112de6c <__s2b+0xdc>
8112de44:	94e5c83a 	sub	r18,r18,r19
8112de48:	84a5883a 	add	r18,r16,r18
8112de4c:	81c00007 	ldb	r7,0(r16)
8112de50:	01800284 	movi	r6,10
8112de54:	84000044 	addi	r16,r16,1
8112de58:	100b883a 	mov	r5,r2
8112de5c:	39fff404 	addi	r7,r7,-48
8112de60:	8809883a 	mov	r4,r17
8112de64:	112dc680 	call	8112dc68 <__multadd>
8112de68:	84bff81e 	bne	r16,r18,8112de4c <__reset+0xfb10de4c>
8112de6c:	dfc00617 	ldw	ra,24(sp)
8112de70:	dd400517 	ldw	r21,20(sp)
8112de74:	dd000417 	ldw	r20,16(sp)
8112de78:	dcc00317 	ldw	r19,12(sp)
8112de7c:	dc800217 	ldw	r18,8(sp)
8112de80:	dc400117 	ldw	r17,4(sp)
8112de84:	dc000017 	ldw	r16,0(sp)
8112de88:	dec00704 	addi	sp,sp,28
8112de8c:	f800283a 	ret
8112de90:	84000284 	addi	r16,r16,10
8112de94:	1827883a 	mov	r19,r3
8112de98:	003fe906 	br	8112de40 <__reset+0xfb10de40>

8112de9c <__hi0bits>:
8112de9c:	20bfffec 	andhi	r2,r4,65535
8112dea0:	1000141e 	bne	r2,zero,8112def4 <__hi0bits+0x58>
8112dea4:	2008943a 	slli	r4,r4,16
8112dea8:	00800404 	movi	r2,16
8112deac:	20ffc02c 	andhi	r3,r4,65280
8112deb0:	1800021e 	bne	r3,zero,8112debc <__hi0bits+0x20>
8112deb4:	2008923a 	slli	r4,r4,8
8112deb8:	10800204 	addi	r2,r2,8
8112debc:	20fc002c 	andhi	r3,r4,61440
8112dec0:	1800021e 	bne	r3,zero,8112decc <__hi0bits+0x30>
8112dec4:	2008913a 	slli	r4,r4,4
8112dec8:	10800104 	addi	r2,r2,4
8112decc:	20f0002c 	andhi	r3,r4,49152
8112ded0:	1800031e 	bne	r3,zero,8112dee0 <__hi0bits+0x44>
8112ded4:	2109883a 	add	r4,r4,r4
8112ded8:	10800084 	addi	r2,r2,2
8112dedc:	2109883a 	add	r4,r4,r4
8112dee0:	20000316 	blt	r4,zero,8112def0 <__hi0bits+0x54>
8112dee4:	2110002c 	andhi	r4,r4,16384
8112dee8:	2000041e 	bne	r4,zero,8112defc <__hi0bits+0x60>
8112deec:	00800804 	movi	r2,32
8112def0:	f800283a 	ret
8112def4:	0005883a 	mov	r2,zero
8112def8:	003fec06 	br	8112deac <__reset+0xfb10deac>
8112defc:	10800044 	addi	r2,r2,1
8112df00:	f800283a 	ret

8112df04 <__lo0bits>:
8112df04:	20c00017 	ldw	r3,0(r4)
8112df08:	188001cc 	andi	r2,r3,7
8112df0c:	10000826 	beq	r2,zero,8112df30 <__lo0bits+0x2c>
8112df10:	1880004c 	andi	r2,r3,1
8112df14:	1000211e 	bne	r2,zero,8112df9c <__lo0bits+0x98>
8112df18:	1880008c 	andi	r2,r3,2
8112df1c:	1000211e 	bne	r2,zero,8112dfa4 <__lo0bits+0xa0>
8112df20:	1806d0ba 	srli	r3,r3,2
8112df24:	00800084 	movi	r2,2
8112df28:	20c00015 	stw	r3,0(r4)
8112df2c:	f800283a 	ret
8112df30:	18bfffcc 	andi	r2,r3,65535
8112df34:	10001326 	beq	r2,zero,8112df84 <__lo0bits+0x80>
8112df38:	0005883a 	mov	r2,zero
8112df3c:	19403fcc 	andi	r5,r3,255
8112df40:	2800021e 	bne	r5,zero,8112df4c <__lo0bits+0x48>
8112df44:	1806d23a 	srli	r3,r3,8
8112df48:	10800204 	addi	r2,r2,8
8112df4c:	194003cc 	andi	r5,r3,15
8112df50:	2800021e 	bne	r5,zero,8112df5c <__lo0bits+0x58>
8112df54:	1806d13a 	srli	r3,r3,4
8112df58:	10800104 	addi	r2,r2,4
8112df5c:	194000cc 	andi	r5,r3,3
8112df60:	2800021e 	bne	r5,zero,8112df6c <__lo0bits+0x68>
8112df64:	1806d0ba 	srli	r3,r3,2
8112df68:	10800084 	addi	r2,r2,2
8112df6c:	1940004c 	andi	r5,r3,1
8112df70:	2800081e 	bne	r5,zero,8112df94 <__lo0bits+0x90>
8112df74:	1806d07a 	srli	r3,r3,1
8112df78:	1800051e 	bne	r3,zero,8112df90 <__lo0bits+0x8c>
8112df7c:	00800804 	movi	r2,32
8112df80:	f800283a 	ret
8112df84:	1806d43a 	srli	r3,r3,16
8112df88:	00800404 	movi	r2,16
8112df8c:	003feb06 	br	8112df3c <__reset+0xfb10df3c>
8112df90:	10800044 	addi	r2,r2,1
8112df94:	20c00015 	stw	r3,0(r4)
8112df98:	f800283a 	ret
8112df9c:	0005883a 	mov	r2,zero
8112dfa0:	f800283a 	ret
8112dfa4:	1806d07a 	srli	r3,r3,1
8112dfa8:	00800044 	movi	r2,1
8112dfac:	20c00015 	stw	r3,0(r4)
8112dfb0:	f800283a 	ret

8112dfb4 <__i2b>:
8112dfb4:	defffd04 	addi	sp,sp,-12
8112dfb8:	de00012e 	bgeu	sp,et,8112dfc0 <__i2b+0xc>
8112dfbc:	003b68fa 	trap	3
8112dfc0:	dc000015 	stw	r16,0(sp)
8112dfc4:	04000044 	movi	r16,1
8112dfc8:	dc400115 	stw	r17,4(sp)
8112dfcc:	2823883a 	mov	r17,r5
8112dfd0:	800b883a 	mov	r5,r16
8112dfd4:	dfc00215 	stw	ra,8(sp)
8112dfd8:	112db900 	call	8112db90 <_Balloc>
8112dfdc:	14400515 	stw	r17,20(r2)
8112dfe0:	14000415 	stw	r16,16(r2)
8112dfe4:	dfc00217 	ldw	ra,8(sp)
8112dfe8:	dc400117 	ldw	r17,4(sp)
8112dfec:	dc000017 	ldw	r16,0(sp)
8112dff0:	dec00304 	addi	sp,sp,12
8112dff4:	f800283a 	ret

8112dff8 <__multiply>:
8112dff8:	defffa04 	addi	sp,sp,-24
8112dffc:	de00012e 	bgeu	sp,et,8112e004 <__multiply+0xc>
8112e000:	003b68fa 	trap	3
8112e004:	dcc00315 	stw	r19,12(sp)
8112e008:	dc800215 	stw	r18,8(sp)
8112e00c:	34c00417 	ldw	r19,16(r6)
8112e010:	2c800417 	ldw	r18,16(r5)
8112e014:	dd000415 	stw	r20,16(sp)
8112e018:	dc400115 	stw	r17,4(sp)
8112e01c:	dfc00515 	stw	ra,20(sp)
8112e020:	dc000015 	stw	r16,0(sp)
8112e024:	2829883a 	mov	r20,r5
8112e028:	3023883a 	mov	r17,r6
8112e02c:	94c0050e 	bge	r18,r19,8112e044 <__multiply+0x4c>
8112e030:	9007883a 	mov	r3,r18
8112e034:	3029883a 	mov	r20,r6
8112e038:	9825883a 	mov	r18,r19
8112e03c:	2823883a 	mov	r17,r5
8112e040:	1827883a 	mov	r19,r3
8112e044:	a0800217 	ldw	r2,8(r20)
8112e048:	94e1883a 	add	r16,r18,r19
8112e04c:	a1400117 	ldw	r5,4(r20)
8112e050:	1400010e 	bge	r2,r16,8112e058 <__multiply+0x60>
8112e054:	29400044 	addi	r5,r5,1
8112e058:	112db900 	call	8112db90 <_Balloc>
8112e05c:	8415883a 	add	r10,r16,r16
8112e060:	12c00504 	addi	r11,r2,20
8112e064:	5295883a 	add	r10,r10,r10
8112e068:	5a95883a 	add	r10,r11,r10
8112e06c:	5807883a 	mov	r3,r11
8112e070:	5a80032e 	bgeu	r11,r10,8112e080 <__multiply+0x88>
8112e074:	18000015 	stw	zero,0(r3)
8112e078:	18c00104 	addi	r3,r3,4
8112e07c:	1abffd36 	bltu	r3,r10,8112e074 <__reset+0xfb10e074>
8112e080:	9ce7883a 	add	r19,r19,r19
8112e084:	94a5883a 	add	r18,r18,r18
8112e088:	89800504 	addi	r6,r17,20
8112e08c:	9ce7883a 	add	r19,r19,r19
8112e090:	a3400504 	addi	r13,r20,20
8112e094:	94a5883a 	add	r18,r18,r18
8112e098:	34d9883a 	add	r12,r6,r19
8112e09c:	6c93883a 	add	r9,r13,r18
8112e0a0:	3300422e 	bgeu	r6,r12,8112e1ac <__multiply+0x1b4>
8112e0a4:	37c00017 	ldw	ra,0(r6)
8112e0a8:	fbffffcc 	andi	r15,ra,65535
8112e0ac:	78001b26 	beq	r15,zero,8112e11c <__multiply+0x124>
8112e0b0:	5811883a 	mov	r8,r11
8112e0b4:	681d883a 	mov	r14,r13
8112e0b8:	000f883a 	mov	r7,zero
8112e0bc:	71000017 	ldw	r4,0(r14)
8112e0c0:	40c00017 	ldw	r3,0(r8)
8112e0c4:	73800104 	addi	r14,r14,4
8112e0c8:	217fffcc 	andi	r5,r4,65535
8112e0cc:	2bcb383a 	mul	r5,r5,r15
8112e0d0:	2008d43a 	srli	r4,r4,16
8112e0d4:	1c7fffcc 	andi	r17,r3,65535
8112e0d8:	2c4b883a 	add	r5,r5,r17
8112e0dc:	29cb883a 	add	r5,r5,r7
8112e0e0:	23c9383a 	mul	r4,r4,r15
8112e0e4:	1806d43a 	srli	r3,r3,16
8112e0e8:	280ed43a 	srli	r7,r5,16
8112e0ec:	297fffcc 	andi	r5,r5,65535
8112e0f0:	20c7883a 	add	r3,r4,r3
8112e0f4:	19c7883a 	add	r3,r3,r7
8112e0f8:	1808943a 	slli	r4,r3,16
8112e0fc:	4023883a 	mov	r17,r8
8112e100:	180ed43a 	srli	r7,r3,16
8112e104:	214ab03a 	or	r5,r4,r5
8112e108:	41400015 	stw	r5,0(r8)
8112e10c:	42000104 	addi	r8,r8,4
8112e110:	727fea36 	bltu	r14,r9,8112e0bc <__reset+0xfb10e0bc>
8112e114:	89c00115 	stw	r7,4(r17)
8112e118:	37c00017 	ldw	ra,0(r6)
8112e11c:	f83ed43a 	srli	ra,ra,16
8112e120:	f8001f26 	beq	ra,zero,8112e1a0 <__multiply+0x1a8>
8112e124:	58c00017 	ldw	r3,0(r11)
8112e128:	681d883a 	mov	r14,r13
8112e12c:	581f883a 	mov	r15,r11
8112e130:	1811883a 	mov	r8,r3
8112e134:	5825883a 	mov	r18,r11
8112e138:	000f883a 	mov	r7,zero
8112e13c:	00000106 	br	8112e144 <__multiply+0x14c>
8112e140:	8825883a 	mov	r18,r17
8112e144:	7140000b 	ldhu	r5,0(r14)
8112e148:	4010d43a 	srli	r8,r8,16
8112e14c:	193fffcc 	andi	r4,r3,65535
8112e150:	2fcb383a 	mul	r5,r5,ra
8112e154:	7bc00104 	addi	r15,r15,4
8112e158:	73800104 	addi	r14,r14,4
8112e15c:	2a0b883a 	add	r5,r5,r8
8112e160:	29cb883a 	add	r5,r5,r7
8112e164:	2806943a 	slli	r3,r5,16
8112e168:	94400104 	addi	r17,r18,4
8112e16c:	280ad43a 	srli	r5,r5,16
8112e170:	1908b03a 	or	r4,r3,r4
8112e174:	793fff15 	stw	r4,-4(r15)
8112e178:	70ffff17 	ldw	r3,-4(r14)
8112e17c:	8a000017 	ldw	r8,0(r17)
8112e180:	1806d43a 	srli	r3,r3,16
8112e184:	413fffcc 	andi	r4,r8,65535
8112e188:	1fc7383a 	mul	r3,r3,ra
8112e18c:	1907883a 	add	r3,r3,r4
8112e190:	1947883a 	add	r3,r3,r5
8112e194:	180ed43a 	srli	r7,r3,16
8112e198:	727fe936 	bltu	r14,r9,8112e140 <__reset+0xfb10e140>
8112e19c:	90c00115 	stw	r3,4(r18)
8112e1a0:	31800104 	addi	r6,r6,4
8112e1a4:	5ac00104 	addi	r11,r11,4
8112e1a8:	333fbe36 	bltu	r6,r12,8112e0a4 <__reset+0xfb10e0a4>
8112e1ac:	0400090e 	bge	zero,r16,8112e1d4 <__multiply+0x1dc>
8112e1b0:	50ffff17 	ldw	r3,-4(r10)
8112e1b4:	52bfff04 	addi	r10,r10,-4
8112e1b8:	18000326 	beq	r3,zero,8112e1c8 <__multiply+0x1d0>
8112e1bc:	00000506 	br	8112e1d4 <__multiply+0x1dc>
8112e1c0:	50c00017 	ldw	r3,0(r10)
8112e1c4:	1800031e 	bne	r3,zero,8112e1d4 <__multiply+0x1dc>
8112e1c8:	843fffc4 	addi	r16,r16,-1
8112e1cc:	52bfff04 	addi	r10,r10,-4
8112e1d0:	803ffb1e 	bne	r16,zero,8112e1c0 <__reset+0xfb10e1c0>
8112e1d4:	14000415 	stw	r16,16(r2)
8112e1d8:	dfc00517 	ldw	ra,20(sp)
8112e1dc:	dd000417 	ldw	r20,16(sp)
8112e1e0:	dcc00317 	ldw	r19,12(sp)
8112e1e4:	dc800217 	ldw	r18,8(sp)
8112e1e8:	dc400117 	ldw	r17,4(sp)
8112e1ec:	dc000017 	ldw	r16,0(sp)
8112e1f0:	dec00604 	addi	sp,sp,24
8112e1f4:	f800283a 	ret

8112e1f8 <__pow5mult>:
8112e1f8:	defffa04 	addi	sp,sp,-24
8112e1fc:	de00012e 	bgeu	sp,et,8112e204 <__pow5mult+0xc>
8112e200:	003b68fa 	trap	3
8112e204:	308000cc 	andi	r2,r6,3
8112e208:	dcc00315 	stw	r19,12(sp)
8112e20c:	dc000015 	stw	r16,0(sp)
8112e210:	dfc00515 	stw	ra,20(sp)
8112e214:	dd000415 	stw	r20,16(sp)
8112e218:	dc800215 	stw	r18,8(sp)
8112e21c:	dc400115 	stw	r17,4(sp)
8112e220:	3021883a 	mov	r16,r6
8112e224:	2027883a 	mov	r19,r4
8112e228:	10002f1e 	bne	r2,zero,8112e2e8 <__pow5mult+0xf0>
8112e22c:	2825883a 	mov	r18,r5
8112e230:	8021d0ba 	srai	r16,r16,2
8112e234:	80001a26 	beq	r16,zero,8112e2a0 <__pow5mult+0xa8>
8112e238:	9c401217 	ldw	r17,72(r19)
8112e23c:	8800061e 	bne	r17,zero,8112e258 <__pow5mult+0x60>
8112e240:	00003406 	br	8112e314 <__pow5mult+0x11c>
8112e244:	8021d07a 	srai	r16,r16,1
8112e248:	80001526 	beq	r16,zero,8112e2a0 <__pow5mult+0xa8>
8112e24c:	88800017 	ldw	r2,0(r17)
8112e250:	10001c26 	beq	r2,zero,8112e2c4 <__pow5mult+0xcc>
8112e254:	1023883a 	mov	r17,r2
8112e258:	8080004c 	andi	r2,r16,1
8112e25c:	103ff926 	beq	r2,zero,8112e244 <__reset+0xfb10e244>
8112e260:	880d883a 	mov	r6,r17
8112e264:	900b883a 	mov	r5,r18
8112e268:	9809883a 	mov	r4,r19
8112e26c:	112dff80 	call	8112dff8 <__multiply>
8112e270:	90001b26 	beq	r18,zero,8112e2e0 <__pow5mult+0xe8>
8112e274:	91000117 	ldw	r4,4(r18)
8112e278:	98c01317 	ldw	r3,76(r19)
8112e27c:	8021d07a 	srai	r16,r16,1
8112e280:	2109883a 	add	r4,r4,r4
8112e284:	2109883a 	add	r4,r4,r4
8112e288:	1907883a 	add	r3,r3,r4
8112e28c:	19000017 	ldw	r4,0(r3)
8112e290:	91000015 	stw	r4,0(r18)
8112e294:	1c800015 	stw	r18,0(r3)
8112e298:	1025883a 	mov	r18,r2
8112e29c:	803feb1e 	bne	r16,zero,8112e24c <__reset+0xfb10e24c>
8112e2a0:	9005883a 	mov	r2,r18
8112e2a4:	dfc00517 	ldw	ra,20(sp)
8112e2a8:	dd000417 	ldw	r20,16(sp)
8112e2ac:	dcc00317 	ldw	r19,12(sp)
8112e2b0:	dc800217 	ldw	r18,8(sp)
8112e2b4:	dc400117 	ldw	r17,4(sp)
8112e2b8:	dc000017 	ldw	r16,0(sp)
8112e2bc:	dec00604 	addi	sp,sp,24
8112e2c0:	f800283a 	ret
8112e2c4:	880d883a 	mov	r6,r17
8112e2c8:	880b883a 	mov	r5,r17
8112e2cc:	9809883a 	mov	r4,r19
8112e2d0:	112dff80 	call	8112dff8 <__multiply>
8112e2d4:	88800015 	stw	r2,0(r17)
8112e2d8:	10000015 	stw	zero,0(r2)
8112e2dc:	003fdd06 	br	8112e254 <__reset+0xfb10e254>
8112e2e0:	1025883a 	mov	r18,r2
8112e2e4:	003fd706 	br	8112e244 <__reset+0xfb10e244>
8112e2e8:	10bfffc4 	addi	r2,r2,-1
8112e2ec:	1085883a 	add	r2,r2,r2
8112e2f0:	00e04574 	movhi	r3,33045
8112e2f4:	18c74b04 	addi	r3,r3,7468
8112e2f8:	1085883a 	add	r2,r2,r2
8112e2fc:	1885883a 	add	r2,r3,r2
8112e300:	11800017 	ldw	r6,0(r2)
8112e304:	000f883a 	mov	r7,zero
8112e308:	112dc680 	call	8112dc68 <__multadd>
8112e30c:	1025883a 	mov	r18,r2
8112e310:	003fc706 	br	8112e230 <__reset+0xfb10e230>
8112e314:	05000044 	movi	r20,1
8112e318:	a00b883a 	mov	r5,r20
8112e31c:	9809883a 	mov	r4,r19
8112e320:	112db900 	call	8112db90 <_Balloc>
8112e324:	1023883a 	mov	r17,r2
8112e328:	00809c44 	movi	r2,625
8112e32c:	88800515 	stw	r2,20(r17)
8112e330:	8d000415 	stw	r20,16(r17)
8112e334:	9c401215 	stw	r17,72(r19)
8112e338:	88000015 	stw	zero,0(r17)
8112e33c:	003fc606 	br	8112e258 <__reset+0xfb10e258>

8112e340 <__lshift>:
8112e340:	defff904 	addi	sp,sp,-28
8112e344:	de00012e 	bgeu	sp,et,8112e34c <__lshift+0xc>
8112e348:	003b68fa 	trap	3
8112e34c:	dd400515 	stw	r21,20(sp)
8112e350:	dcc00315 	stw	r19,12(sp)
8112e354:	302bd17a 	srai	r21,r6,5
8112e358:	2cc00417 	ldw	r19,16(r5)
8112e35c:	28800217 	ldw	r2,8(r5)
8112e360:	dd000415 	stw	r20,16(sp)
8112e364:	ace7883a 	add	r19,r21,r19
8112e368:	dc800215 	stw	r18,8(sp)
8112e36c:	dc400115 	stw	r17,4(sp)
8112e370:	dc000015 	stw	r16,0(sp)
8112e374:	dfc00615 	stw	ra,24(sp)
8112e378:	9c000044 	addi	r16,r19,1
8112e37c:	2823883a 	mov	r17,r5
8112e380:	3029883a 	mov	r20,r6
8112e384:	2025883a 	mov	r18,r4
8112e388:	29400117 	ldw	r5,4(r5)
8112e38c:	1400030e 	bge	r2,r16,8112e39c <__lshift+0x5c>
8112e390:	1085883a 	add	r2,r2,r2
8112e394:	29400044 	addi	r5,r5,1
8112e398:	143ffd16 	blt	r2,r16,8112e390 <__reset+0xfb10e390>
8112e39c:	9009883a 	mov	r4,r18
8112e3a0:	112db900 	call	8112db90 <_Balloc>
8112e3a4:	10c00504 	addi	r3,r2,20
8112e3a8:	0540070e 	bge	zero,r21,8112e3c8 <__lshift+0x88>
8112e3ac:	ad6b883a 	add	r21,r21,r21
8112e3b0:	ad6b883a 	add	r21,r21,r21
8112e3b4:	1809883a 	mov	r4,r3
8112e3b8:	1d47883a 	add	r3,r3,r21
8112e3bc:	20000015 	stw	zero,0(r4)
8112e3c0:	21000104 	addi	r4,r4,4
8112e3c4:	193ffd1e 	bne	r3,r4,8112e3bc <__reset+0xfb10e3bc>
8112e3c8:	8a000417 	ldw	r8,16(r17)
8112e3cc:	89000504 	addi	r4,r17,20
8112e3d0:	a18007cc 	andi	r6,r20,31
8112e3d4:	4211883a 	add	r8,r8,r8
8112e3d8:	4211883a 	add	r8,r8,r8
8112e3dc:	2211883a 	add	r8,r4,r8
8112e3e0:	30002326 	beq	r6,zero,8112e470 <__lshift+0x130>
8112e3e4:	02400804 	movi	r9,32
8112e3e8:	4993c83a 	sub	r9,r9,r6
8112e3ec:	000b883a 	mov	r5,zero
8112e3f0:	21c00017 	ldw	r7,0(r4)
8112e3f4:	1815883a 	mov	r10,r3
8112e3f8:	18c00104 	addi	r3,r3,4
8112e3fc:	398e983a 	sll	r7,r7,r6
8112e400:	21000104 	addi	r4,r4,4
8112e404:	394ab03a 	or	r5,r7,r5
8112e408:	197fff15 	stw	r5,-4(r3)
8112e40c:	217fff17 	ldw	r5,-4(r4)
8112e410:	2a4ad83a 	srl	r5,r5,r9
8112e414:	223ff636 	bltu	r4,r8,8112e3f0 <__reset+0xfb10e3f0>
8112e418:	51400115 	stw	r5,4(r10)
8112e41c:	28001a1e 	bne	r5,zero,8112e488 <__lshift+0x148>
8112e420:	843fffc4 	addi	r16,r16,-1
8112e424:	14000415 	stw	r16,16(r2)
8112e428:	88000826 	beq	r17,zero,8112e44c <__lshift+0x10c>
8112e42c:	89000117 	ldw	r4,4(r17)
8112e430:	90c01317 	ldw	r3,76(r18)
8112e434:	2109883a 	add	r4,r4,r4
8112e438:	2109883a 	add	r4,r4,r4
8112e43c:	1907883a 	add	r3,r3,r4
8112e440:	19000017 	ldw	r4,0(r3)
8112e444:	89000015 	stw	r4,0(r17)
8112e448:	1c400015 	stw	r17,0(r3)
8112e44c:	dfc00617 	ldw	ra,24(sp)
8112e450:	dd400517 	ldw	r21,20(sp)
8112e454:	dd000417 	ldw	r20,16(sp)
8112e458:	dcc00317 	ldw	r19,12(sp)
8112e45c:	dc800217 	ldw	r18,8(sp)
8112e460:	dc400117 	ldw	r17,4(sp)
8112e464:	dc000017 	ldw	r16,0(sp)
8112e468:	dec00704 	addi	sp,sp,28
8112e46c:	f800283a 	ret
8112e470:	21400017 	ldw	r5,0(r4)
8112e474:	18c00104 	addi	r3,r3,4
8112e478:	21000104 	addi	r4,r4,4
8112e47c:	197fff15 	stw	r5,-4(r3)
8112e480:	223ffb36 	bltu	r4,r8,8112e470 <__reset+0xfb10e470>
8112e484:	003fe606 	br	8112e420 <__reset+0xfb10e420>
8112e488:	9c000084 	addi	r16,r19,2
8112e48c:	003fe406 	br	8112e420 <__reset+0xfb10e420>

8112e490 <__mcmp>:
8112e490:	20800417 	ldw	r2,16(r4)
8112e494:	28c00417 	ldw	r3,16(r5)
8112e498:	10c5c83a 	sub	r2,r2,r3
8112e49c:	1000111e 	bne	r2,zero,8112e4e4 <__mcmp+0x54>
8112e4a0:	18c7883a 	add	r3,r3,r3
8112e4a4:	18c7883a 	add	r3,r3,r3
8112e4a8:	21000504 	addi	r4,r4,20
8112e4ac:	29400504 	addi	r5,r5,20
8112e4b0:	20c5883a 	add	r2,r4,r3
8112e4b4:	28cb883a 	add	r5,r5,r3
8112e4b8:	00000106 	br	8112e4c0 <__mcmp+0x30>
8112e4bc:	20800a2e 	bgeu	r4,r2,8112e4e8 <__mcmp+0x58>
8112e4c0:	10bfff04 	addi	r2,r2,-4
8112e4c4:	297fff04 	addi	r5,r5,-4
8112e4c8:	11800017 	ldw	r6,0(r2)
8112e4cc:	28c00017 	ldw	r3,0(r5)
8112e4d0:	30fffa26 	beq	r6,r3,8112e4bc <__reset+0xfb10e4bc>
8112e4d4:	30c00236 	bltu	r6,r3,8112e4e0 <__mcmp+0x50>
8112e4d8:	00800044 	movi	r2,1
8112e4dc:	f800283a 	ret
8112e4e0:	00bfffc4 	movi	r2,-1
8112e4e4:	f800283a 	ret
8112e4e8:	0005883a 	mov	r2,zero
8112e4ec:	f800283a 	ret

8112e4f0 <__mdiff>:
8112e4f0:	defffa04 	addi	sp,sp,-24
8112e4f4:	de00012e 	bgeu	sp,et,8112e4fc <__mdiff+0xc>
8112e4f8:	003b68fa 	trap	3
8112e4fc:	28c00417 	ldw	r3,16(r5)
8112e500:	30800417 	ldw	r2,16(r6)
8112e504:	dcc00315 	stw	r19,12(sp)
8112e508:	dc800215 	stw	r18,8(sp)
8112e50c:	dfc00515 	stw	ra,20(sp)
8112e510:	dd000415 	stw	r20,16(sp)
8112e514:	dc400115 	stw	r17,4(sp)
8112e518:	dc000015 	stw	r16,0(sp)
8112e51c:	1887c83a 	sub	r3,r3,r2
8112e520:	2825883a 	mov	r18,r5
8112e524:	3027883a 	mov	r19,r6
8112e528:	1800141e 	bne	r3,zero,8112e57c <__mdiff+0x8c>
8112e52c:	1085883a 	add	r2,r2,r2
8112e530:	1085883a 	add	r2,r2,r2
8112e534:	2a000504 	addi	r8,r5,20
8112e538:	34000504 	addi	r16,r6,20
8112e53c:	4087883a 	add	r3,r8,r2
8112e540:	8085883a 	add	r2,r16,r2
8112e544:	00000106 	br	8112e54c <__mdiff+0x5c>
8112e548:	40c0592e 	bgeu	r8,r3,8112e6b0 <__mdiff+0x1c0>
8112e54c:	18ffff04 	addi	r3,r3,-4
8112e550:	10bfff04 	addi	r2,r2,-4
8112e554:	19c00017 	ldw	r7,0(r3)
8112e558:	11400017 	ldw	r5,0(r2)
8112e55c:	397ffa26 	beq	r7,r5,8112e548 <__reset+0xfb10e548>
8112e560:	3940592e 	bgeu	r7,r5,8112e6c8 <__mdiff+0x1d8>
8112e564:	9005883a 	mov	r2,r18
8112e568:	4023883a 	mov	r17,r8
8112e56c:	9825883a 	mov	r18,r19
8112e570:	05000044 	movi	r20,1
8112e574:	1027883a 	mov	r19,r2
8112e578:	00000406 	br	8112e58c <__mdiff+0x9c>
8112e57c:	18005616 	blt	r3,zero,8112e6d8 <__mdiff+0x1e8>
8112e580:	34400504 	addi	r17,r6,20
8112e584:	2c000504 	addi	r16,r5,20
8112e588:	0029883a 	mov	r20,zero
8112e58c:	91400117 	ldw	r5,4(r18)
8112e590:	112db900 	call	8112db90 <_Balloc>
8112e594:	92400417 	ldw	r9,16(r18)
8112e598:	9b000417 	ldw	r12,16(r19)
8112e59c:	12c00504 	addi	r11,r2,20
8112e5a0:	4a51883a 	add	r8,r9,r9
8112e5a4:	6319883a 	add	r12,r12,r12
8112e5a8:	4211883a 	add	r8,r8,r8
8112e5ac:	6319883a 	add	r12,r12,r12
8112e5b0:	15000315 	stw	r20,12(r2)
8112e5b4:	8211883a 	add	r8,r16,r8
8112e5b8:	8b19883a 	add	r12,r17,r12
8112e5bc:	0007883a 	mov	r3,zero
8112e5c0:	81400017 	ldw	r5,0(r16)
8112e5c4:	89c00017 	ldw	r7,0(r17)
8112e5c8:	59800104 	addi	r6,r11,4
8112e5cc:	293fffcc 	andi	r4,r5,65535
8112e5d0:	20c7883a 	add	r3,r4,r3
8112e5d4:	393fffcc 	andi	r4,r7,65535
8112e5d8:	1909c83a 	sub	r4,r3,r4
8112e5dc:	280ad43a 	srli	r5,r5,16
8112e5e0:	380ed43a 	srli	r7,r7,16
8112e5e4:	2007d43a 	srai	r3,r4,16
8112e5e8:	213fffcc 	andi	r4,r4,65535
8112e5ec:	29cbc83a 	sub	r5,r5,r7
8112e5f0:	28c7883a 	add	r3,r5,r3
8112e5f4:	180a943a 	slli	r5,r3,16
8112e5f8:	8c400104 	addi	r17,r17,4
8112e5fc:	84000104 	addi	r16,r16,4
8112e600:	2908b03a 	or	r4,r5,r4
8112e604:	59000015 	stw	r4,0(r11)
8112e608:	1807d43a 	srai	r3,r3,16
8112e60c:	3015883a 	mov	r10,r6
8112e610:	3017883a 	mov	r11,r6
8112e614:	8b3fea36 	bltu	r17,r12,8112e5c0 <__reset+0xfb10e5c0>
8112e618:	8200162e 	bgeu	r16,r8,8112e674 <__mdiff+0x184>
8112e61c:	8017883a 	mov	r11,r16
8112e620:	59400017 	ldw	r5,0(r11)
8112e624:	31800104 	addi	r6,r6,4
8112e628:	5ac00104 	addi	r11,r11,4
8112e62c:	293fffcc 	andi	r4,r5,65535
8112e630:	20c7883a 	add	r3,r4,r3
8112e634:	280ed43a 	srli	r7,r5,16
8112e638:	180bd43a 	srai	r5,r3,16
8112e63c:	193fffcc 	andi	r4,r3,65535
8112e640:	3947883a 	add	r3,r7,r5
8112e644:	180a943a 	slli	r5,r3,16
8112e648:	1807d43a 	srai	r3,r3,16
8112e64c:	2908b03a 	or	r4,r5,r4
8112e650:	313fff15 	stw	r4,-4(r6)
8112e654:	5a3ff236 	bltu	r11,r8,8112e620 <__reset+0xfb10e620>
8112e658:	0406303a 	nor	r3,zero,r16
8112e65c:	1a07883a 	add	r3,r3,r8
8112e660:	1806d0ba 	srli	r3,r3,2
8112e664:	18c00044 	addi	r3,r3,1
8112e668:	18c7883a 	add	r3,r3,r3
8112e66c:	18c7883a 	add	r3,r3,r3
8112e670:	50d5883a 	add	r10,r10,r3
8112e674:	50ffff04 	addi	r3,r10,-4
8112e678:	2000041e 	bne	r4,zero,8112e68c <__mdiff+0x19c>
8112e67c:	18ffff04 	addi	r3,r3,-4
8112e680:	19000017 	ldw	r4,0(r3)
8112e684:	4a7fffc4 	addi	r9,r9,-1
8112e688:	203ffc26 	beq	r4,zero,8112e67c <__reset+0xfb10e67c>
8112e68c:	12400415 	stw	r9,16(r2)
8112e690:	dfc00517 	ldw	ra,20(sp)
8112e694:	dd000417 	ldw	r20,16(sp)
8112e698:	dcc00317 	ldw	r19,12(sp)
8112e69c:	dc800217 	ldw	r18,8(sp)
8112e6a0:	dc400117 	ldw	r17,4(sp)
8112e6a4:	dc000017 	ldw	r16,0(sp)
8112e6a8:	dec00604 	addi	sp,sp,24
8112e6ac:	f800283a 	ret
8112e6b0:	000b883a 	mov	r5,zero
8112e6b4:	112db900 	call	8112db90 <_Balloc>
8112e6b8:	00c00044 	movi	r3,1
8112e6bc:	10c00415 	stw	r3,16(r2)
8112e6c0:	10000515 	stw	zero,20(r2)
8112e6c4:	003ff206 	br	8112e690 <__reset+0xfb10e690>
8112e6c8:	8023883a 	mov	r17,r16
8112e6cc:	0029883a 	mov	r20,zero
8112e6d0:	4021883a 	mov	r16,r8
8112e6d4:	003fad06 	br	8112e58c <__reset+0xfb10e58c>
8112e6d8:	9005883a 	mov	r2,r18
8112e6dc:	94400504 	addi	r17,r18,20
8112e6e0:	9c000504 	addi	r16,r19,20
8112e6e4:	9825883a 	mov	r18,r19
8112e6e8:	05000044 	movi	r20,1
8112e6ec:	1027883a 	mov	r19,r2
8112e6f0:	003fa606 	br	8112e58c <__reset+0xfb10e58c>

8112e6f4 <__ulp>:
8112e6f4:	295ffc2c 	andhi	r5,r5,32752
8112e6f8:	00bf3034 	movhi	r2,64704
8112e6fc:	2887883a 	add	r3,r5,r2
8112e700:	00c0020e 	bge	zero,r3,8112e70c <__ulp+0x18>
8112e704:	0005883a 	mov	r2,zero
8112e708:	f800283a 	ret
8112e70c:	00c7c83a 	sub	r3,zero,r3
8112e710:	1807d53a 	srai	r3,r3,20
8112e714:	008004c4 	movi	r2,19
8112e718:	10c00b0e 	bge	r2,r3,8112e748 <__ulp+0x54>
8112e71c:	18bffb04 	addi	r2,r3,-20
8112e720:	01000784 	movi	r4,30
8112e724:	0007883a 	mov	r3,zero
8112e728:	20800516 	blt	r4,r2,8112e740 <__ulp+0x4c>
8112e72c:	010007c4 	movi	r4,31
8112e730:	2089c83a 	sub	r4,r4,r2
8112e734:	00800044 	movi	r2,1
8112e738:	1104983a 	sll	r2,r2,r4
8112e73c:	f800283a 	ret
8112e740:	00800044 	movi	r2,1
8112e744:	f800283a 	ret
8112e748:	01400234 	movhi	r5,8
8112e74c:	28c7d83a 	sra	r3,r5,r3
8112e750:	0005883a 	mov	r2,zero
8112e754:	f800283a 	ret

8112e758 <__b2d>:
8112e758:	defffa04 	addi	sp,sp,-24
8112e75c:	de00012e 	bgeu	sp,et,8112e764 <__b2d+0xc>
8112e760:	003b68fa 	trap	3
8112e764:	dc000015 	stw	r16,0(sp)
8112e768:	24000417 	ldw	r16,16(r4)
8112e76c:	dc400115 	stw	r17,4(sp)
8112e770:	24400504 	addi	r17,r4,20
8112e774:	8421883a 	add	r16,r16,r16
8112e778:	8421883a 	add	r16,r16,r16
8112e77c:	8c21883a 	add	r16,r17,r16
8112e780:	dc800215 	stw	r18,8(sp)
8112e784:	84bfff17 	ldw	r18,-4(r16)
8112e788:	dd000415 	stw	r20,16(sp)
8112e78c:	dcc00315 	stw	r19,12(sp)
8112e790:	9009883a 	mov	r4,r18
8112e794:	2829883a 	mov	r20,r5
8112e798:	dfc00515 	stw	ra,20(sp)
8112e79c:	112de9c0 	call	8112de9c <__hi0bits>
8112e7a0:	00c00804 	movi	r3,32
8112e7a4:	1889c83a 	sub	r4,r3,r2
8112e7a8:	a1000015 	stw	r4,0(r20)
8112e7ac:	01000284 	movi	r4,10
8112e7b0:	84ffff04 	addi	r19,r16,-4
8112e7b4:	20801216 	blt	r4,r2,8112e800 <__b2d+0xa8>
8112e7b8:	018002c4 	movi	r6,11
8112e7bc:	308dc83a 	sub	r6,r6,r2
8112e7c0:	9186d83a 	srl	r3,r18,r6
8112e7c4:	18cffc34 	orhi	r3,r3,16368
8112e7c8:	8cc0212e 	bgeu	r17,r19,8112e850 <__b2d+0xf8>
8112e7cc:	813ffe17 	ldw	r4,-8(r16)
8112e7d0:	218cd83a 	srl	r6,r4,r6
8112e7d4:	10800544 	addi	r2,r2,21
8112e7d8:	9084983a 	sll	r2,r18,r2
8112e7dc:	1184b03a 	or	r2,r2,r6
8112e7e0:	dfc00517 	ldw	ra,20(sp)
8112e7e4:	dd000417 	ldw	r20,16(sp)
8112e7e8:	dcc00317 	ldw	r19,12(sp)
8112e7ec:	dc800217 	ldw	r18,8(sp)
8112e7f0:	dc400117 	ldw	r17,4(sp)
8112e7f4:	dc000017 	ldw	r16,0(sp)
8112e7f8:	dec00604 	addi	sp,sp,24
8112e7fc:	f800283a 	ret
8112e800:	8cc00f2e 	bgeu	r17,r19,8112e840 <__b2d+0xe8>
8112e804:	117ffd44 	addi	r5,r2,-11
8112e808:	80bffe17 	ldw	r2,-8(r16)
8112e80c:	28000e26 	beq	r5,zero,8112e848 <__b2d+0xf0>
8112e810:	1949c83a 	sub	r4,r3,r5
8112e814:	9164983a 	sll	r18,r18,r5
8112e818:	1106d83a 	srl	r3,r2,r4
8112e81c:	81bffe04 	addi	r6,r16,-8
8112e820:	948ffc34 	orhi	r18,r18,16368
8112e824:	90c6b03a 	or	r3,r18,r3
8112e828:	89800e2e 	bgeu	r17,r6,8112e864 <__b2d+0x10c>
8112e82c:	81bffd17 	ldw	r6,-12(r16)
8112e830:	1144983a 	sll	r2,r2,r5
8112e834:	310ad83a 	srl	r5,r6,r4
8112e838:	2884b03a 	or	r2,r5,r2
8112e83c:	003fe806 	br	8112e7e0 <__reset+0xfb10e7e0>
8112e840:	10bffd44 	addi	r2,r2,-11
8112e844:	1000041e 	bne	r2,zero,8112e858 <__b2d+0x100>
8112e848:	90cffc34 	orhi	r3,r18,16368
8112e84c:	003fe406 	br	8112e7e0 <__reset+0xfb10e7e0>
8112e850:	000d883a 	mov	r6,zero
8112e854:	003fdf06 	br	8112e7d4 <__reset+0xfb10e7d4>
8112e858:	90a4983a 	sll	r18,r18,r2
8112e85c:	0005883a 	mov	r2,zero
8112e860:	003ff906 	br	8112e848 <__reset+0xfb10e848>
8112e864:	1144983a 	sll	r2,r2,r5
8112e868:	003fdd06 	br	8112e7e0 <__reset+0xfb10e7e0>

8112e86c <__d2b>:
8112e86c:	defff804 	addi	sp,sp,-32
8112e870:	de00012e 	bgeu	sp,et,8112e878 <__d2b+0xc>
8112e874:	003b68fa 	trap	3
8112e878:	dc000215 	stw	r16,8(sp)
8112e87c:	3021883a 	mov	r16,r6
8112e880:	dc400315 	stw	r17,12(sp)
8112e884:	8022907a 	slli	r17,r16,1
8112e888:	dd000615 	stw	r20,24(sp)
8112e88c:	2829883a 	mov	r20,r5
8112e890:	01400044 	movi	r5,1
8112e894:	dcc00515 	stw	r19,20(sp)
8112e898:	dc800415 	stw	r18,16(sp)
8112e89c:	dfc00715 	stw	ra,28(sp)
8112e8a0:	3825883a 	mov	r18,r7
8112e8a4:	8822d57a 	srli	r17,r17,21
8112e8a8:	112db900 	call	8112db90 <_Balloc>
8112e8ac:	1027883a 	mov	r19,r2
8112e8b0:	00800434 	movhi	r2,16
8112e8b4:	10bfffc4 	addi	r2,r2,-1
8112e8b8:	808c703a 	and	r6,r16,r2
8112e8bc:	88000126 	beq	r17,zero,8112e8c4 <__d2b+0x58>
8112e8c0:	31800434 	orhi	r6,r6,16
8112e8c4:	d9800015 	stw	r6,0(sp)
8112e8c8:	a0002426 	beq	r20,zero,8112e95c <__d2b+0xf0>
8112e8cc:	d9000104 	addi	r4,sp,4
8112e8d0:	dd000115 	stw	r20,4(sp)
8112e8d4:	112df040 	call	8112df04 <__lo0bits>
8112e8d8:	d8c00017 	ldw	r3,0(sp)
8112e8dc:	10002f1e 	bne	r2,zero,8112e99c <__d2b+0x130>
8112e8e0:	d9000117 	ldw	r4,4(sp)
8112e8e4:	99000515 	stw	r4,20(r19)
8112e8e8:	1821003a 	cmpeq	r16,r3,zero
8112e8ec:	01000084 	movi	r4,2
8112e8f0:	2421c83a 	sub	r16,r4,r16
8112e8f4:	98c00615 	stw	r3,24(r19)
8112e8f8:	9c000415 	stw	r16,16(r19)
8112e8fc:	88001f1e 	bne	r17,zero,8112e97c <__d2b+0x110>
8112e900:	10bef384 	addi	r2,r2,-1074
8112e904:	90800015 	stw	r2,0(r18)
8112e908:	00900034 	movhi	r2,16384
8112e90c:	10bfffc4 	addi	r2,r2,-1
8112e910:	8085883a 	add	r2,r16,r2
8112e914:	1085883a 	add	r2,r2,r2
8112e918:	1085883a 	add	r2,r2,r2
8112e91c:	9885883a 	add	r2,r19,r2
8112e920:	11000517 	ldw	r4,20(r2)
8112e924:	8020917a 	slli	r16,r16,5
8112e928:	112de9c0 	call	8112de9c <__hi0bits>
8112e92c:	d8c00817 	ldw	r3,32(sp)
8112e930:	8085c83a 	sub	r2,r16,r2
8112e934:	18800015 	stw	r2,0(r3)
8112e938:	9805883a 	mov	r2,r19
8112e93c:	dfc00717 	ldw	ra,28(sp)
8112e940:	dd000617 	ldw	r20,24(sp)
8112e944:	dcc00517 	ldw	r19,20(sp)
8112e948:	dc800417 	ldw	r18,16(sp)
8112e94c:	dc400317 	ldw	r17,12(sp)
8112e950:	dc000217 	ldw	r16,8(sp)
8112e954:	dec00804 	addi	sp,sp,32
8112e958:	f800283a 	ret
8112e95c:	d809883a 	mov	r4,sp
8112e960:	112df040 	call	8112df04 <__lo0bits>
8112e964:	d8c00017 	ldw	r3,0(sp)
8112e968:	04000044 	movi	r16,1
8112e96c:	9c000415 	stw	r16,16(r19)
8112e970:	98c00515 	stw	r3,20(r19)
8112e974:	10800804 	addi	r2,r2,32
8112e978:	883fe126 	beq	r17,zero,8112e900 <__reset+0xfb10e900>
8112e97c:	00c00d44 	movi	r3,53
8112e980:	8c7ef344 	addi	r17,r17,-1075
8112e984:	88a3883a 	add	r17,r17,r2
8112e988:	1885c83a 	sub	r2,r3,r2
8112e98c:	d8c00817 	ldw	r3,32(sp)
8112e990:	94400015 	stw	r17,0(r18)
8112e994:	18800015 	stw	r2,0(r3)
8112e998:	003fe706 	br	8112e938 <__reset+0xfb10e938>
8112e99c:	01000804 	movi	r4,32
8112e9a0:	2089c83a 	sub	r4,r4,r2
8112e9a4:	1908983a 	sll	r4,r3,r4
8112e9a8:	d9400117 	ldw	r5,4(sp)
8112e9ac:	1886d83a 	srl	r3,r3,r2
8112e9b0:	2148b03a 	or	r4,r4,r5
8112e9b4:	99000515 	stw	r4,20(r19)
8112e9b8:	d8c00015 	stw	r3,0(sp)
8112e9bc:	003fca06 	br	8112e8e8 <__reset+0xfb10e8e8>

8112e9c0 <__ratio>:
8112e9c0:	defff904 	addi	sp,sp,-28
8112e9c4:	de00012e 	bgeu	sp,et,8112e9cc <__ratio+0xc>
8112e9c8:	003b68fa 	trap	3
8112e9cc:	dc400315 	stw	r17,12(sp)
8112e9d0:	2823883a 	mov	r17,r5
8112e9d4:	d9400104 	addi	r5,sp,4
8112e9d8:	dfc00615 	stw	ra,24(sp)
8112e9dc:	dcc00515 	stw	r19,20(sp)
8112e9e0:	dc800415 	stw	r18,16(sp)
8112e9e4:	2027883a 	mov	r19,r4
8112e9e8:	dc000215 	stw	r16,8(sp)
8112e9ec:	112e7580 	call	8112e758 <__b2d>
8112e9f0:	d80b883a 	mov	r5,sp
8112e9f4:	8809883a 	mov	r4,r17
8112e9f8:	1025883a 	mov	r18,r2
8112e9fc:	1821883a 	mov	r16,r3
8112ea00:	112e7580 	call	8112e758 <__b2d>
8112ea04:	8a000417 	ldw	r8,16(r17)
8112ea08:	99000417 	ldw	r4,16(r19)
8112ea0c:	d9400117 	ldw	r5,4(sp)
8112ea10:	2209c83a 	sub	r4,r4,r8
8112ea14:	2010917a 	slli	r8,r4,5
8112ea18:	d9000017 	ldw	r4,0(sp)
8112ea1c:	2909c83a 	sub	r4,r5,r4
8112ea20:	4109883a 	add	r4,r8,r4
8112ea24:	01000e0e 	bge	zero,r4,8112ea60 <__ratio+0xa0>
8112ea28:	2008953a 	slli	r4,r4,20
8112ea2c:	2421883a 	add	r16,r4,r16
8112ea30:	100d883a 	mov	r6,r2
8112ea34:	180f883a 	mov	r7,r3
8112ea38:	9009883a 	mov	r4,r18
8112ea3c:	800b883a 	mov	r5,r16
8112ea40:	1136a380 	call	81136a38 <__divdf3>
8112ea44:	dfc00617 	ldw	ra,24(sp)
8112ea48:	dcc00517 	ldw	r19,20(sp)
8112ea4c:	dc800417 	ldw	r18,16(sp)
8112ea50:	dc400317 	ldw	r17,12(sp)
8112ea54:	dc000217 	ldw	r16,8(sp)
8112ea58:	dec00704 	addi	sp,sp,28
8112ea5c:	f800283a 	ret
8112ea60:	2008953a 	slli	r4,r4,20
8112ea64:	1907c83a 	sub	r3,r3,r4
8112ea68:	003ff106 	br	8112ea30 <__reset+0xfb10ea30>

8112ea6c <_mprec_log10>:
8112ea6c:	defffe04 	addi	sp,sp,-8
8112ea70:	de00012e 	bgeu	sp,et,8112ea78 <_mprec_log10+0xc>
8112ea74:	003b68fa 	trap	3
8112ea78:	008005c4 	movi	r2,23
8112ea7c:	dc000015 	stw	r16,0(sp)
8112ea80:	dfc00115 	stw	ra,4(sp)
8112ea84:	2021883a 	mov	r16,r4
8112ea88:	11000d0e 	bge	r2,r4,8112eac0 <_mprec_log10+0x54>
8112ea8c:	0005883a 	mov	r2,zero
8112ea90:	00cffc34 	movhi	r3,16368
8112ea94:	843fffc4 	addi	r16,r16,-1
8112ea98:	000d883a 	mov	r6,zero
8112ea9c:	01d00934 	movhi	r7,16420
8112eaa0:	1009883a 	mov	r4,r2
8112eaa4:	180b883a 	mov	r5,r3
8112eaa8:	11213240 	call	81121324 <__muldf3>
8112eaac:	803ff91e 	bne	r16,zero,8112ea94 <__reset+0xfb10ea94>
8112eab0:	dfc00117 	ldw	ra,4(sp)
8112eab4:	dc000017 	ldw	r16,0(sp)
8112eab8:	dec00204 	addi	sp,sp,8
8112eabc:	f800283a 	ret
8112eac0:	202090fa 	slli	r16,r4,3
8112eac4:	00a04574 	movhi	r2,33045
8112eac8:	10876204 	addi	r2,r2,7560
8112eacc:	1421883a 	add	r16,r2,r16
8112ead0:	80800017 	ldw	r2,0(r16)
8112ead4:	80c00117 	ldw	r3,4(r16)
8112ead8:	dfc00117 	ldw	ra,4(sp)
8112eadc:	dc000017 	ldw	r16,0(sp)
8112eae0:	dec00204 	addi	sp,sp,8
8112eae4:	f800283a 	ret

8112eae8 <__copybits>:
8112eae8:	297fffc4 	addi	r5,r5,-1
8112eaec:	280fd17a 	srai	r7,r5,5
8112eaf0:	30c00417 	ldw	r3,16(r6)
8112eaf4:	30800504 	addi	r2,r6,20
8112eaf8:	39c00044 	addi	r7,r7,1
8112eafc:	18c7883a 	add	r3,r3,r3
8112eb00:	39cf883a 	add	r7,r7,r7
8112eb04:	18c7883a 	add	r3,r3,r3
8112eb08:	39cf883a 	add	r7,r7,r7
8112eb0c:	10c7883a 	add	r3,r2,r3
8112eb10:	21cf883a 	add	r7,r4,r7
8112eb14:	10c00d2e 	bgeu	r2,r3,8112eb4c <__copybits+0x64>
8112eb18:	200b883a 	mov	r5,r4
8112eb1c:	12000017 	ldw	r8,0(r2)
8112eb20:	29400104 	addi	r5,r5,4
8112eb24:	10800104 	addi	r2,r2,4
8112eb28:	2a3fff15 	stw	r8,-4(r5)
8112eb2c:	10fffb36 	bltu	r2,r3,8112eb1c <__reset+0xfb10eb1c>
8112eb30:	1985c83a 	sub	r2,r3,r6
8112eb34:	10bffac4 	addi	r2,r2,-21
8112eb38:	1004d0ba 	srli	r2,r2,2
8112eb3c:	10800044 	addi	r2,r2,1
8112eb40:	1085883a 	add	r2,r2,r2
8112eb44:	1085883a 	add	r2,r2,r2
8112eb48:	2089883a 	add	r4,r4,r2
8112eb4c:	21c0032e 	bgeu	r4,r7,8112eb5c <__copybits+0x74>
8112eb50:	20000015 	stw	zero,0(r4)
8112eb54:	21000104 	addi	r4,r4,4
8112eb58:	21fffd36 	bltu	r4,r7,8112eb50 <__reset+0xfb10eb50>
8112eb5c:	f800283a 	ret

8112eb60 <__any_on>:
8112eb60:	20c00417 	ldw	r3,16(r4)
8112eb64:	2805d17a 	srai	r2,r5,5
8112eb68:	21000504 	addi	r4,r4,20
8112eb6c:	18800d0e 	bge	r3,r2,8112eba4 <__any_on+0x44>
8112eb70:	18c7883a 	add	r3,r3,r3
8112eb74:	18c7883a 	add	r3,r3,r3
8112eb78:	20c7883a 	add	r3,r4,r3
8112eb7c:	20c0192e 	bgeu	r4,r3,8112ebe4 <__any_on+0x84>
8112eb80:	18bfff17 	ldw	r2,-4(r3)
8112eb84:	18ffff04 	addi	r3,r3,-4
8112eb88:	1000041e 	bne	r2,zero,8112eb9c <__any_on+0x3c>
8112eb8c:	20c0142e 	bgeu	r4,r3,8112ebe0 <__any_on+0x80>
8112eb90:	18ffff04 	addi	r3,r3,-4
8112eb94:	19400017 	ldw	r5,0(r3)
8112eb98:	283ffc26 	beq	r5,zero,8112eb8c <__reset+0xfb10eb8c>
8112eb9c:	00800044 	movi	r2,1
8112eba0:	f800283a 	ret
8112eba4:	10c00a0e 	bge	r2,r3,8112ebd0 <__any_on+0x70>
8112eba8:	1085883a 	add	r2,r2,r2
8112ebac:	1085883a 	add	r2,r2,r2
8112ebb0:	294007cc 	andi	r5,r5,31
8112ebb4:	2087883a 	add	r3,r4,r2
8112ebb8:	283ff026 	beq	r5,zero,8112eb7c <__reset+0xfb10eb7c>
8112ebbc:	19800017 	ldw	r6,0(r3)
8112ebc0:	3144d83a 	srl	r2,r6,r5
8112ebc4:	114a983a 	sll	r5,r2,r5
8112ebc8:	317ff41e 	bne	r6,r5,8112eb9c <__reset+0xfb10eb9c>
8112ebcc:	003feb06 	br	8112eb7c <__reset+0xfb10eb7c>
8112ebd0:	1085883a 	add	r2,r2,r2
8112ebd4:	1085883a 	add	r2,r2,r2
8112ebd8:	2087883a 	add	r3,r4,r2
8112ebdc:	003fe706 	br	8112eb7c <__reset+0xfb10eb7c>
8112ebe0:	f800283a 	ret
8112ebe4:	0005883a 	mov	r2,zero
8112ebe8:	f800283a 	ret

8112ebec <_read_r>:
8112ebec:	defffd04 	addi	sp,sp,-12
8112ebf0:	de00012e 	bgeu	sp,et,8112ebf8 <_read_r+0xc>
8112ebf4:	003b68fa 	trap	3
8112ebf8:	2805883a 	mov	r2,r5
8112ebfc:	dc000015 	stw	r16,0(sp)
8112ec00:	04204574 	movhi	r16,33045
8112ec04:	dc400115 	stw	r17,4(sp)
8112ec08:	300b883a 	mov	r5,r6
8112ec0c:	84116404 	addi	r16,r16,17808
8112ec10:	2023883a 	mov	r17,r4
8112ec14:	380d883a 	mov	r6,r7
8112ec18:	1009883a 	mov	r4,r2
8112ec1c:	dfc00215 	stw	ra,8(sp)
8112ec20:	80000015 	stw	zero,0(r16)
8112ec24:	1138ba80 	call	81138ba8 <read>
8112ec28:	00ffffc4 	movi	r3,-1
8112ec2c:	10c00526 	beq	r2,r3,8112ec44 <_read_r+0x58>
8112ec30:	dfc00217 	ldw	ra,8(sp)
8112ec34:	dc400117 	ldw	r17,4(sp)
8112ec38:	dc000017 	ldw	r16,0(sp)
8112ec3c:	dec00304 	addi	sp,sp,12
8112ec40:	f800283a 	ret
8112ec44:	80c00017 	ldw	r3,0(r16)
8112ec48:	183ff926 	beq	r3,zero,8112ec30 <__reset+0xfb10ec30>
8112ec4c:	88c00015 	stw	r3,0(r17)
8112ec50:	003ff706 	br	8112ec30 <__reset+0xfb10ec30>

8112ec54 <_realloc_r>:
8112ec54:	defff604 	addi	sp,sp,-40
8112ec58:	de00012e 	bgeu	sp,et,8112ec60 <_realloc_r+0xc>
8112ec5c:	003b68fa 	trap	3
8112ec60:	dc800215 	stw	r18,8(sp)
8112ec64:	dfc00915 	stw	ra,36(sp)
8112ec68:	df000815 	stw	fp,32(sp)
8112ec6c:	ddc00715 	stw	r23,28(sp)
8112ec70:	dd800615 	stw	r22,24(sp)
8112ec74:	dd400515 	stw	r21,20(sp)
8112ec78:	dd000415 	stw	r20,16(sp)
8112ec7c:	dcc00315 	stw	r19,12(sp)
8112ec80:	dc400115 	stw	r17,4(sp)
8112ec84:	dc000015 	stw	r16,0(sp)
8112ec88:	3025883a 	mov	r18,r6
8112ec8c:	2800b726 	beq	r5,zero,8112ef6c <_realloc_r+0x318>
8112ec90:	282b883a 	mov	r21,r5
8112ec94:	2029883a 	mov	r20,r4
8112ec98:	11393880 	call	81139388 <__malloc_lock>
8112ec9c:	a8bfff17 	ldw	r2,-4(r21)
8112eca0:	043fff04 	movi	r16,-4
8112eca4:	90c002c4 	addi	r3,r18,11
8112eca8:	01000584 	movi	r4,22
8112ecac:	acfffe04 	addi	r19,r21,-8
8112ecb0:	1420703a 	and	r16,r2,r16
8112ecb4:	20c0332e 	bgeu	r4,r3,8112ed84 <_realloc_r+0x130>
8112ecb8:	047ffe04 	movi	r17,-8
8112ecbc:	1c62703a 	and	r17,r3,r17
8112ecc0:	8807883a 	mov	r3,r17
8112ecc4:	88005816 	blt	r17,zero,8112ee28 <_realloc_r+0x1d4>
8112ecc8:	8c805736 	bltu	r17,r18,8112ee28 <_realloc_r+0x1d4>
8112eccc:	80c0300e 	bge	r16,r3,8112ed90 <_realloc_r+0x13c>
8112ecd0:	07204574 	movhi	fp,33045
8112ecd4:	e70aaf04 	addi	fp,fp,10940
8112ecd8:	e1c00217 	ldw	r7,8(fp)
8112ecdc:	9c09883a 	add	r4,r19,r16
8112ece0:	22000117 	ldw	r8,4(r4)
8112ece4:	21c06326 	beq	r4,r7,8112ee74 <_realloc_r+0x220>
8112ece8:	017fff84 	movi	r5,-2
8112ecec:	414a703a 	and	r5,r8,r5
8112ecf0:	214b883a 	add	r5,r4,r5
8112ecf4:	29800117 	ldw	r6,4(r5)
8112ecf8:	3180004c 	andi	r6,r6,1
8112ecfc:	30003f26 	beq	r6,zero,8112edfc <_realloc_r+0x1a8>
8112ed00:	1080004c 	andi	r2,r2,1
8112ed04:	10008326 	beq	r2,zero,8112ef14 <_realloc_r+0x2c0>
8112ed08:	900b883a 	mov	r5,r18
8112ed0c:	a009883a 	mov	r4,r20
8112ed10:	11231c80 	call	811231c8 <_malloc_r>
8112ed14:	1025883a 	mov	r18,r2
8112ed18:	10011e26 	beq	r2,zero,8112f194 <_realloc_r+0x540>
8112ed1c:	a93fff17 	ldw	r4,-4(r21)
8112ed20:	10fffe04 	addi	r3,r2,-8
8112ed24:	00bfff84 	movi	r2,-2
8112ed28:	2084703a 	and	r2,r4,r2
8112ed2c:	9885883a 	add	r2,r19,r2
8112ed30:	1880ee26 	beq	r3,r2,8112f0ec <_realloc_r+0x498>
8112ed34:	81bfff04 	addi	r6,r16,-4
8112ed38:	00800904 	movi	r2,36
8112ed3c:	1180b836 	bltu	r2,r6,8112f020 <_realloc_r+0x3cc>
8112ed40:	00c004c4 	movi	r3,19
8112ed44:	19809636 	bltu	r3,r6,8112efa0 <_realloc_r+0x34c>
8112ed48:	9005883a 	mov	r2,r18
8112ed4c:	a807883a 	mov	r3,r21
8112ed50:	19000017 	ldw	r4,0(r3)
8112ed54:	11000015 	stw	r4,0(r2)
8112ed58:	19000117 	ldw	r4,4(r3)
8112ed5c:	11000115 	stw	r4,4(r2)
8112ed60:	18c00217 	ldw	r3,8(r3)
8112ed64:	10c00215 	stw	r3,8(r2)
8112ed68:	a80b883a 	mov	r5,r21
8112ed6c:	a009883a 	mov	r4,r20
8112ed70:	112cbc00 	call	8112cbc0 <_free_r>
8112ed74:	a009883a 	mov	r4,r20
8112ed78:	11394b00 	call	811394b0 <__malloc_unlock>
8112ed7c:	9005883a 	mov	r2,r18
8112ed80:	00001206 	br	8112edcc <_realloc_r+0x178>
8112ed84:	00c00404 	movi	r3,16
8112ed88:	1823883a 	mov	r17,r3
8112ed8c:	003fce06 	br	8112ecc8 <__reset+0xfb10ecc8>
8112ed90:	a825883a 	mov	r18,r21
8112ed94:	8445c83a 	sub	r2,r16,r17
8112ed98:	00c003c4 	movi	r3,15
8112ed9c:	18802636 	bltu	r3,r2,8112ee38 <_realloc_r+0x1e4>
8112eda0:	99800117 	ldw	r6,4(r19)
8112eda4:	9c07883a 	add	r3,r19,r16
8112eda8:	3180004c 	andi	r6,r6,1
8112edac:	3420b03a 	or	r16,r6,r16
8112edb0:	9c000115 	stw	r16,4(r19)
8112edb4:	18800117 	ldw	r2,4(r3)
8112edb8:	10800054 	ori	r2,r2,1
8112edbc:	18800115 	stw	r2,4(r3)
8112edc0:	a009883a 	mov	r4,r20
8112edc4:	11394b00 	call	811394b0 <__malloc_unlock>
8112edc8:	9005883a 	mov	r2,r18
8112edcc:	dfc00917 	ldw	ra,36(sp)
8112edd0:	df000817 	ldw	fp,32(sp)
8112edd4:	ddc00717 	ldw	r23,28(sp)
8112edd8:	dd800617 	ldw	r22,24(sp)
8112eddc:	dd400517 	ldw	r21,20(sp)
8112ede0:	dd000417 	ldw	r20,16(sp)
8112ede4:	dcc00317 	ldw	r19,12(sp)
8112ede8:	dc800217 	ldw	r18,8(sp)
8112edec:	dc400117 	ldw	r17,4(sp)
8112edf0:	dc000017 	ldw	r16,0(sp)
8112edf4:	dec00a04 	addi	sp,sp,40
8112edf8:	f800283a 	ret
8112edfc:	017fff04 	movi	r5,-4
8112ee00:	414a703a 	and	r5,r8,r5
8112ee04:	814d883a 	add	r6,r16,r5
8112ee08:	30c01f16 	blt	r6,r3,8112ee88 <_realloc_r+0x234>
8112ee0c:	20800317 	ldw	r2,12(r4)
8112ee10:	20c00217 	ldw	r3,8(r4)
8112ee14:	a825883a 	mov	r18,r21
8112ee18:	3021883a 	mov	r16,r6
8112ee1c:	18800315 	stw	r2,12(r3)
8112ee20:	10c00215 	stw	r3,8(r2)
8112ee24:	003fdb06 	br	8112ed94 <__reset+0xfb10ed94>
8112ee28:	00800304 	movi	r2,12
8112ee2c:	a0800015 	stw	r2,0(r20)
8112ee30:	0005883a 	mov	r2,zero
8112ee34:	003fe506 	br	8112edcc <__reset+0xfb10edcc>
8112ee38:	98c00117 	ldw	r3,4(r19)
8112ee3c:	9c4b883a 	add	r5,r19,r17
8112ee40:	11000054 	ori	r4,r2,1
8112ee44:	18c0004c 	andi	r3,r3,1
8112ee48:	1c62b03a 	or	r17,r3,r17
8112ee4c:	9c400115 	stw	r17,4(r19)
8112ee50:	29000115 	stw	r4,4(r5)
8112ee54:	2885883a 	add	r2,r5,r2
8112ee58:	10c00117 	ldw	r3,4(r2)
8112ee5c:	29400204 	addi	r5,r5,8
8112ee60:	a009883a 	mov	r4,r20
8112ee64:	18c00054 	ori	r3,r3,1
8112ee68:	10c00115 	stw	r3,4(r2)
8112ee6c:	112cbc00 	call	8112cbc0 <_free_r>
8112ee70:	003fd306 	br	8112edc0 <__reset+0xfb10edc0>
8112ee74:	017fff04 	movi	r5,-4
8112ee78:	414a703a 	and	r5,r8,r5
8112ee7c:	89800404 	addi	r6,r17,16
8112ee80:	8151883a 	add	r8,r16,r5
8112ee84:	4180590e 	bge	r8,r6,8112efec <_realloc_r+0x398>
8112ee88:	1080004c 	andi	r2,r2,1
8112ee8c:	103f9e1e 	bne	r2,zero,8112ed08 <__reset+0xfb10ed08>
8112ee90:	adbffe17 	ldw	r22,-8(r21)
8112ee94:	00bfff04 	movi	r2,-4
8112ee98:	9dadc83a 	sub	r22,r19,r22
8112ee9c:	b1800117 	ldw	r6,4(r22)
8112eea0:	3084703a 	and	r2,r6,r2
8112eea4:	20002026 	beq	r4,zero,8112ef28 <_realloc_r+0x2d4>
8112eea8:	80af883a 	add	r23,r16,r2
8112eeac:	b96f883a 	add	r23,r23,r5
8112eeb0:	21c05f26 	beq	r4,r7,8112f030 <_realloc_r+0x3dc>
8112eeb4:	b8c01c16 	blt	r23,r3,8112ef28 <_realloc_r+0x2d4>
8112eeb8:	20800317 	ldw	r2,12(r4)
8112eebc:	20c00217 	ldw	r3,8(r4)
8112eec0:	81bfff04 	addi	r6,r16,-4
8112eec4:	01000904 	movi	r4,36
8112eec8:	18800315 	stw	r2,12(r3)
8112eecc:	10c00215 	stw	r3,8(r2)
8112eed0:	b0c00217 	ldw	r3,8(r22)
8112eed4:	b0800317 	ldw	r2,12(r22)
8112eed8:	b4800204 	addi	r18,r22,8
8112eedc:	18800315 	stw	r2,12(r3)
8112eee0:	10c00215 	stw	r3,8(r2)
8112eee4:	21801b36 	bltu	r4,r6,8112ef54 <_realloc_r+0x300>
8112eee8:	008004c4 	movi	r2,19
8112eeec:	1180352e 	bgeu	r2,r6,8112efc4 <_realloc_r+0x370>
8112eef0:	a8800017 	ldw	r2,0(r21)
8112eef4:	b0800215 	stw	r2,8(r22)
8112eef8:	a8800117 	ldw	r2,4(r21)
8112eefc:	b0800315 	stw	r2,12(r22)
8112ef00:	008006c4 	movi	r2,27
8112ef04:	11807f36 	bltu	r2,r6,8112f104 <_realloc_r+0x4b0>
8112ef08:	b0800404 	addi	r2,r22,16
8112ef0c:	ad400204 	addi	r21,r21,8
8112ef10:	00002d06 	br	8112efc8 <_realloc_r+0x374>
8112ef14:	adbffe17 	ldw	r22,-8(r21)
8112ef18:	00bfff04 	movi	r2,-4
8112ef1c:	9dadc83a 	sub	r22,r19,r22
8112ef20:	b1000117 	ldw	r4,4(r22)
8112ef24:	2084703a 	and	r2,r4,r2
8112ef28:	b03f7726 	beq	r22,zero,8112ed08 <__reset+0xfb10ed08>
8112ef2c:	80af883a 	add	r23,r16,r2
8112ef30:	b8ff7516 	blt	r23,r3,8112ed08 <__reset+0xfb10ed08>
8112ef34:	b0800317 	ldw	r2,12(r22)
8112ef38:	b0c00217 	ldw	r3,8(r22)
8112ef3c:	81bfff04 	addi	r6,r16,-4
8112ef40:	01000904 	movi	r4,36
8112ef44:	18800315 	stw	r2,12(r3)
8112ef48:	10c00215 	stw	r3,8(r2)
8112ef4c:	b4800204 	addi	r18,r22,8
8112ef50:	21bfe52e 	bgeu	r4,r6,8112eee8 <__reset+0xfb10eee8>
8112ef54:	a80b883a 	mov	r5,r21
8112ef58:	9009883a 	mov	r4,r18
8112ef5c:	112da340 	call	8112da34 <memmove>
8112ef60:	b821883a 	mov	r16,r23
8112ef64:	b027883a 	mov	r19,r22
8112ef68:	003f8a06 	br	8112ed94 <__reset+0xfb10ed94>
8112ef6c:	300b883a 	mov	r5,r6
8112ef70:	dfc00917 	ldw	ra,36(sp)
8112ef74:	df000817 	ldw	fp,32(sp)
8112ef78:	ddc00717 	ldw	r23,28(sp)
8112ef7c:	dd800617 	ldw	r22,24(sp)
8112ef80:	dd400517 	ldw	r21,20(sp)
8112ef84:	dd000417 	ldw	r20,16(sp)
8112ef88:	dcc00317 	ldw	r19,12(sp)
8112ef8c:	dc800217 	ldw	r18,8(sp)
8112ef90:	dc400117 	ldw	r17,4(sp)
8112ef94:	dc000017 	ldw	r16,0(sp)
8112ef98:	dec00a04 	addi	sp,sp,40
8112ef9c:	11231c81 	jmpi	811231c8 <_malloc_r>
8112efa0:	a8c00017 	ldw	r3,0(r21)
8112efa4:	90c00015 	stw	r3,0(r18)
8112efa8:	a8c00117 	ldw	r3,4(r21)
8112efac:	90c00115 	stw	r3,4(r18)
8112efb0:	00c006c4 	movi	r3,27
8112efb4:	19804536 	bltu	r3,r6,8112f0cc <_realloc_r+0x478>
8112efb8:	90800204 	addi	r2,r18,8
8112efbc:	a8c00204 	addi	r3,r21,8
8112efc0:	003f6306 	br	8112ed50 <__reset+0xfb10ed50>
8112efc4:	9005883a 	mov	r2,r18
8112efc8:	a8c00017 	ldw	r3,0(r21)
8112efcc:	b821883a 	mov	r16,r23
8112efd0:	b027883a 	mov	r19,r22
8112efd4:	10c00015 	stw	r3,0(r2)
8112efd8:	a8c00117 	ldw	r3,4(r21)
8112efdc:	10c00115 	stw	r3,4(r2)
8112efe0:	a8c00217 	ldw	r3,8(r21)
8112efe4:	10c00215 	stw	r3,8(r2)
8112efe8:	003f6a06 	br	8112ed94 <__reset+0xfb10ed94>
8112efec:	9c67883a 	add	r19,r19,r17
8112eff0:	4445c83a 	sub	r2,r8,r17
8112eff4:	e4c00215 	stw	r19,8(fp)
8112eff8:	10800054 	ori	r2,r2,1
8112effc:	98800115 	stw	r2,4(r19)
8112f000:	a8bfff17 	ldw	r2,-4(r21)
8112f004:	a009883a 	mov	r4,r20
8112f008:	1080004c 	andi	r2,r2,1
8112f00c:	1462b03a 	or	r17,r2,r17
8112f010:	ac7fff15 	stw	r17,-4(r21)
8112f014:	11394b00 	call	811394b0 <__malloc_unlock>
8112f018:	a805883a 	mov	r2,r21
8112f01c:	003f6b06 	br	8112edcc <__reset+0xfb10edcc>
8112f020:	a80b883a 	mov	r5,r21
8112f024:	9009883a 	mov	r4,r18
8112f028:	112da340 	call	8112da34 <memmove>
8112f02c:	003f4e06 	br	8112ed68 <__reset+0xfb10ed68>
8112f030:	89000404 	addi	r4,r17,16
8112f034:	b93fbc16 	blt	r23,r4,8112ef28 <__reset+0xfb10ef28>
8112f038:	b0800317 	ldw	r2,12(r22)
8112f03c:	b0c00217 	ldw	r3,8(r22)
8112f040:	81bfff04 	addi	r6,r16,-4
8112f044:	01000904 	movi	r4,36
8112f048:	18800315 	stw	r2,12(r3)
8112f04c:	10c00215 	stw	r3,8(r2)
8112f050:	b4800204 	addi	r18,r22,8
8112f054:	21804336 	bltu	r4,r6,8112f164 <_realloc_r+0x510>
8112f058:	008004c4 	movi	r2,19
8112f05c:	11803f2e 	bgeu	r2,r6,8112f15c <_realloc_r+0x508>
8112f060:	a8800017 	ldw	r2,0(r21)
8112f064:	b0800215 	stw	r2,8(r22)
8112f068:	a8800117 	ldw	r2,4(r21)
8112f06c:	b0800315 	stw	r2,12(r22)
8112f070:	008006c4 	movi	r2,27
8112f074:	11803f36 	bltu	r2,r6,8112f174 <_realloc_r+0x520>
8112f078:	b0800404 	addi	r2,r22,16
8112f07c:	ad400204 	addi	r21,r21,8
8112f080:	a8c00017 	ldw	r3,0(r21)
8112f084:	10c00015 	stw	r3,0(r2)
8112f088:	a8c00117 	ldw	r3,4(r21)
8112f08c:	10c00115 	stw	r3,4(r2)
8112f090:	a8c00217 	ldw	r3,8(r21)
8112f094:	10c00215 	stw	r3,8(r2)
8112f098:	b447883a 	add	r3,r22,r17
8112f09c:	bc45c83a 	sub	r2,r23,r17
8112f0a0:	e0c00215 	stw	r3,8(fp)
8112f0a4:	10800054 	ori	r2,r2,1
8112f0a8:	18800115 	stw	r2,4(r3)
8112f0ac:	b0800117 	ldw	r2,4(r22)
8112f0b0:	a009883a 	mov	r4,r20
8112f0b4:	1080004c 	andi	r2,r2,1
8112f0b8:	1462b03a 	or	r17,r2,r17
8112f0bc:	b4400115 	stw	r17,4(r22)
8112f0c0:	11394b00 	call	811394b0 <__malloc_unlock>
8112f0c4:	9005883a 	mov	r2,r18
8112f0c8:	003f4006 	br	8112edcc <__reset+0xfb10edcc>
8112f0cc:	a8c00217 	ldw	r3,8(r21)
8112f0d0:	90c00215 	stw	r3,8(r18)
8112f0d4:	a8c00317 	ldw	r3,12(r21)
8112f0d8:	90c00315 	stw	r3,12(r18)
8112f0dc:	30801126 	beq	r6,r2,8112f124 <_realloc_r+0x4d0>
8112f0e0:	90800404 	addi	r2,r18,16
8112f0e4:	a8c00404 	addi	r3,r21,16
8112f0e8:	003f1906 	br	8112ed50 <__reset+0xfb10ed50>
8112f0ec:	90ffff17 	ldw	r3,-4(r18)
8112f0f0:	00bfff04 	movi	r2,-4
8112f0f4:	a825883a 	mov	r18,r21
8112f0f8:	1884703a 	and	r2,r3,r2
8112f0fc:	80a1883a 	add	r16,r16,r2
8112f100:	003f2406 	br	8112ed94 <__reset+0xfb10ed94>
8112f104:	a8800217 	ldw	r2,8(r21)
8112f108:	b0800415 	stw	r2,16(r22)
8112f10c:	a8800317 	ldw	r2,12(r21)
8112f110:	b0800515 	stw	r2,20(r22)
8112f114:	31000a26 	beq	r6,r4,8112f140 <_realloc_r+0x4ec>
8112f118:	b0800604 	addi	r2,r22,24
8112f11c:	ad400404 	addi	r21,r21,16
8112f120:	003fa906 	br	8112efc8 <__reset+0xfb10efc8>
8112f124:	a9000417 	ldw	r4,16(r21)
8112f128:	90800604 	addi	r2,r18,24
8112f12c:	a8c00604 	addi	r3,r21,24
8112f130:	91000415 	stw	r4,16(r18)
8112f134:	a9000517 	ldw	r4,20(r21)
8112f138:	91000515 	stw	r4,20(r18)
8112f13c:	003f0406 	br	8112ed50 <__reset+0xfb10ed50>
8112f140:	a8c00417 	ldw	r3,16(r21)
8112f144:	ad400604 	addi	r21,r21,24
8112f148:	b0800804 	addi	r2,r22,32
8112f14c:	b0c00615 	stw	r3,24(r22)
8112f150:	a8ffff17 	ldw	r3,-4(r21)
8112f154:	b0c00715 	stw	r3,28(r22)
8112f158:	003f9b06 	br	8112efc8 <__reset+0xfb10efc8>
8112f15c:	9005883a 	mov	r2,r18
8112f160:	003fc706 	br	8112f080 <__reset+0xfb10f080>
8112f164:	a80b883a 	mov	r5,r21
8112f168:	9009883a 	mov	r4,r18
8112f16c:	112da340 	call	8112da34 <memmove>
8112f170:	003fc906 	br	8112f098 <__reset+0xfb10f098>
8112f174:	a8800217 	ldw	r2,8(r21)
8112f178:	b0800415 	stw	r2,16(r22)
8112f17c:	a8800317 	ldw	r2,12(r21)
8112f180:	b0800515 	stw	r2,20(r22)
8112f184:	31000726 	beq	r6,r4,8112f1a4 <_realloc_r+0x550>
8112f188:	b0800604 	addi	r2,r22,24
8112f18c:	ad400404 	addi	r21,r21,16
8112f190:	003fbb06 	br	8112f080 <__reset+0xfb10f080>
8112f194:	a009883a 	mov	r4,r20
8112f198:	11394b00 	call	811394b0 <__malloc_unlock>
8112f19c:	0005883a 	mov	r2,zero
8112f1a0:	003f0a06 	br	8112edcc <__reset+0xfb10edcc>
8112f1a4:	a8c00417 	ldw	r3,16(r21)
8112f1a8:	ad400604 	addi	r21,r21,24
8112f1ac:	b0800804 	addi	r2,r22,32
8112f1b0:	b0c00615 	stw	r3,24(r22)
8112f1b4:	a8ffff17 	ldw	r3,-4(r21)
8112f1b8:	b0c00715 	stw	r3,28(r22)
8112f1bc:	003fb006 	br	8112f080 <__reset+0xfb10f080>

8112f1c0 <__fpclassifyd>:
8112f1c0:	00a00034 	movhi	r2,32768
8112f1c4:	10bfffc4 	addi	r2,r2,-1
8112f1c8:	2884703a 	and	r2,r5,r2
8112f1cc:	10000726 	beq	r2,zero,8112f1ec <__fpclassifyd+0x2c>
8112f1d0:	00fffc34 	movhi	r3,65520
8112f1d4:	019ff834 	movhi	r6,32736
8112f1d8:	28c7883a 	add	r3,r5,r3
8112f1dc:	31bfffc4 	addi	r6,r6,-1
8112f1e0:	30c00536 	bltu	r6,r3,8112f1f8 <__fpclassifyd+0x38>
8112f1e4:	00800104 	movi	r2,4
8112f1e8:	f800283a 	ret
8112f1ec:	2000021e 	bne	r4,zero,8112f1f8 <__fpclassifyd+0x38>
8112f1f0:	00800084 	movi	r2,2
8112f1f4:	f800283a 	ret
8112f1f8:	00dffc34 	movhi	r3,32752
8112f1fc:	019ff834 	movhi	r6,32736
8112f200:	28cb883a 	add	r5,r5,r3
8112f204:	31bfffc4 	addi	r6,r6,-1
8112f208:	317ff62e 	bgeu	r6,r5,8112f1e4 <__reset+0xfb10f1e4>
8112f20c:	01400434 	movhi	r5,16
8112f210:	297fffc4 	addi	r5,r5,-1
8112f214:	28800236 	bltu	r5,r2,8112f220 <__fpclassifyd+0x60>
8112f218:	008000c4 	movi	r2,3
8112f21c:	f800283a 	ret
8112f220:	10c00226 	beq	r2,r3,8112f22c <__fpclassifyd+0x6c>
8112f224:	0005883a 	mov	r2,zero
8112f228:	f800283a 	ret
8112f22c:	2005003a 	cmpeq	r2,r4,zero
8112f230:	f800283a 	ret

8112f234 <__sccl>:
8112f234:	2a000003 	ldbu	r8,0(r5)
8112f238:	00801784 	movi	r2,94
8112f23c:	40802a26 	beq	r8,r2,8112f2e8 <__sccl+0xb4>
8112f240:	29400044 	addi	r5,r5,1
8112f244:	000f883a 	mov	r7,zero
8112f248:	0013883a 	mov	r9,zero
8112f24c:	2007883a 	mov	r3,r4
8112f250:	21804004 	addi	r6,r4,256
8112f254:	19c00005 	stb	r7,0(r3)
8112f258:	18c00044 	addi	r3,r3,1
8112f25c:	19bffd1e 	bne	r3,r6,8112f254 <__reset+0xfb10f254>
8112f260:	40001126 	beq	r8,zero,8112f2a8 <__sccl+0x74>
8112f264:	00800044 	movi	r2,1
8112f268:	124fc83a 	sub	r7,r2,r9
8112f26c:	02800b44 	movi	r10,45
8112f270:	02c01744 	movi	r11,93
8112f274:	2205883a 	add	r2,r4,r8
8112f278:	11c00005 	stb	r7,0(r2)
8112f27c:	28800044 	addi	r2,r5,1
8112f280:	28c00003 	ldbu	r3,0(r5)
8112f284:	1a800a26 	beq	r3,r10,8112f2b0 <__sccl+0x7c>
8112f288:	1ac00426 	beq	r3,r11,8112f29c <__sccl+0x68>
8112f28c:	18000426 	beq	r3,zero,8112f2a0 <__sccl+0x6c>
8112f290:	1811883a 	mov	r8,r3
8112f294:	100b883a 	mov	r5,r2
8112f298:	003ff606 	br	8112f274 <__reset+0xfb10f274>
8112f29c:	f800283a 	ret
8112f2a0:	2805883a 	mov	r2,r5
8112f2a4:	f800283a 	ret
8112f2a8:	28bfffc4 	addi	r2,r5,-1
8112f2ac:	f800283a 	ret
8112f2b0:	12400003 	ldbu	r9,0(r2)
8112f2b4:	4ac01126 	beq	r9,r11,8112f2fc <__sccl+0xc8>
8112f2b8:	4a001016 	blt	r9,r8,8112f2fc <__sccl+0xc8>
8112f2bc:	41800044 	addi	r6,r8,1
8112f2c0:	29400084 	addi	r5,r5,2
8112f2c4:	2187883a 	add	r3,r4,r6
8112f2c8:	00000106 	br	8112f2d0 <__sccl+0x9c>
8112f2cc:	31800044 	addi	r6,r6,1
8112f2d0:	19c00005 	stb	r7,0(r3)
8112f2d4:	3011883a 	mov	r8,r6
8112f2d8:	18c00044 	addi	r3,r3,1
8112f2dc:	327ffb16 	blt	r6,r9,8112f2cc <__reset+0xfb10f2cc>
8112f2e0:	10800084 	addi	r2,r2,2
8112f2e4:	003fe606 	br	8112f280 <__reset+0xfb10f280>
8112f2e8:	2a000043 	ldbu	r8,1(r5)
8112f2ec:	01c00044 	movi	r7,1
8112f2f0:	29400084 	addi	r5,r5,2
8112f2f4:	02400044 	movi	r9,1
8112f2f8:	003fd406 	br	8112f24c <__reset+0xfb10f24c>
8112f2fc:	5011883a 	mov	r8,r10
8112f300:	003fe406 	br	8112f294 <__reset+0xfb10f294>

8112f304 <nanf>:
8112f304:	009ff034 	movhi	r2,32704
8112f308:	f800283a 	ret

8112f30c <strcmp>:
8112f30c:	2144b03a 	or	r2,r4,r5
8112f310:	108000cc 	andi	r2,r2,3
8112f314:	1000171e 	bne	r2,zero,8112f374 <strcmp+0x68>
8112f318:	20800017 	ldw	r2,0(r4)
8112f31c:	28c00017 	ldw	r3,0(r5)
8112f320:	10c0141e 	bne	r2,r3,8112f374 <strcmp+0x68>
8112f324:	027fbff4 	movhi	r9,65279
8112f328:	4a7fbfc4 	addi	r9,r9,-257
8112f32c:	0086303a 	nor	r3,zero,r2
8112f330:	02202074 	movhi	r8,32897
8112f334:	1245883a 	add	r2,r2,r9
8112f338:	42202004 	addi	r8,r8,-32640
8112f33c:	10c4703a 	and	r2,r2,r3
8112f340:	1204703a 	and	r2,r2,r8
8112f344:	10000226 	beq	r2,zero,8112f350 <strcmp+0x44>
8112f348:	00002306 	br	8112f3d8 <strcmp+0xcc>
8112f34c:	1000221e 	bne	r2,zero,8112f3d8 <strcmp+0xcc>
8112f350:	21000104 	addi	r4,r4,4
8112f354:	20c00017 	ldw	r3,0(r4)
8112f358:	29400104 	addi	r5,r5,4
8112f35c:	29800017 	ldw	r6,0(r5)
8112f360:	1a4f883a 	add	r7,r3,r9
8112f364:	00c4303a 	nor	r2,zero,r3
8112f368:	3884703a 	and	r2,r7,r2
8112f36c:	1204703a 	and	r2,r2,r8
8112f370:	19bff626 	beq	r3,r6,8112f34c <__reset+0xfb10f34c>
8112f374:	20800003 	ldbu	r2,0(r4)
8112f378:	10c03fcc 	andi	r3,r2,255
8112f37c:	18c0201c 	xori	r3,r3,128
8112f380:	18ffe004 	addi	r3,r3,-128
8112f384:	18000c26 	beq	r3,zero,8112f3b8 <strcmp+0xac>
8112f388:	29800007 	ldb	r6,0(r5)
8112f38c:	19800326 	beq	r3,r6,8112f39c <strcmp+0x90>
8112f390:	00001306 	br	8112f3e0 <strcmp+0xd4>
8112f394:	29800007 	ldb	r6,0(r5)
8112f398:	11800b1e 	bne	r2,r6,8112f3c8 <strcmp+0xbc>
8112f39c:	21000044 	addi	r4,r4,1
8112f3a0:	20c00003 	ldbu	r3,0(r4)
8112f3a4:	29400044 	addi	r5,r5,1
8112f3a8:	18803fcc 	andi	r2,r3,255
8112f3ac:	1080201c 	xori	r2,r2,128
8112f3b0:	10bfe004 	addi	r2,r2,-128
8112f3b4:	103ff71e 	bne	r2,zero,8112f394 <__reset+0xfb10f394>
8112f3b8:	0007883a 	mov	r3,zero
8112f3bc:	28800003 	ldbu	r2,0(r5)
8112f3c0:	1885c83a 	sub	r2,r3,r2
8112f3c4:	f800283a 	ret
8112f3c8:	28800003 	ldbu	r2,0(r5)
8112f3cc:	18c03fcc 	andi	r3,r3,255
8112f3d0:	1885c83a 	sub	r2,r3,r2
8112f3d4:	f800283a 	ret
8112f3d8:	0005883a 	mov	r2,zero
8112f3dc:	f800283a 	ret
8112f3e0:	10c03fcc 	andi	r3,r2,255
8112f3e4:	003ff506 	br	8112f3bc <__reset+0xfb10f3bc>

8112f3e8 <sulp>:
8112f3e8:	defffd04 	addi	sp,sp,-12
8112f3ec:	de00012e 	bgeu	sp,et,8112f3f4 <sulp+0xc>
8112f3f0:	003b68fa 	trap	3
8112f3f4:	dc400115 	stw	r17,4(sp)
8112f3f8:	3023883a 	mov	r17,r6
8112f3fc:	dc000015 	stw	r16,0(sp)
8112f400:	dfc00215 	stw	ra,8(sp)
8112f404:	2821883a 	mov	r16,r5
8112f408:	112e6f40 	call	8112e6f4 <__ulp>
8112f40c:	88000c26 	beq	r17,zero,8112f440 <sulp+0x58>
8112f410:	841ffc2c 	andhi	r16,r16,32752
8112f414:	8020d53a 	srli	r16,r16,20
8112f418:	01c01ac4 	movi	r7,107
8112f41c:	3c21c83a 	sub	r16,r7,r16
8112f420:	0400070e 	bge	zero,r16,8112f440 <sulp+0x58>
8112f424:	8020953a 	slli	r16,r16,20
8112f428:	01cffc34 	movhi	r7,16368
8112f42c:	000d883a 	mov	r6,zero
8112f430:	81cf883a 	add	r7,r16,r7
8112f434:	1009883a 	mov	r4,r2
8112f438:	180b883a 	mov	r5,r3
8112f43c:	11213240 	call	81121324 <__muldf3>
8112f440:	dfc00217 	ldw	ra,8(sp)
8112f444:	dc400117 	ldw	r17,4(sp)
8112f448:	dc000017 	ldw	r16,0(sp)
8112f44c:	dec00304 	addi	sp,sp,12
8112f450:	f800283a 	ret

8112f454 <_strtod_r>:
8112f454:	deffe204 	addi	sp,sp,-120
8112f458:	de00012e 	bgeu	sp,et,8112f460 <_strtod_r+0xc>
8112f45c:	003b68fa 	trap	3
8112f460:	ddc01b15 	stw	r23,108(sp)
8112f464:	dd001815 	stw	r20,96(sp)
8112f468:	dc801615 	stw	r18,88(sp)
8112f46c:	dc401515 	stw	r17,84(sp)
8112f470:	dc001415 	stw	r16,80(sp)
8112f474:	d9400615 	stw	r5,24(sp)
8112f478:	dfc01d15 	stw	ra,116(sp)
8112f47c:	df001c15 	stw	fp,112(sp)
8112f480:	dd801a15 	stw	r22,104(sp)
8112f484:	dd401915 	stw	r21,100(sp)
8112f488:	dcc01715 	stw	r19,92(sp)
8112f48c:	2021883a 	mov	r16,r4
8112f490:	d8000515 	stw	zero,20(sp)
8112f494:	2809883a 	mov	r4,r5
8112f498:	20800003 	ldbu	r2,0(r4)
8112f49c:	01e044f4 	movhi	r7,33043
8112f4a0:	282f883a 	mov	r23,r5
8112f4a4:	10c03fcc 	andi	r3,r2,255
8112f4a8:	01400b44 	movi	r5,45
8112f4ac:	39fd3404 	addi	r7,r7,-2864
8112f4b0:	3029883a 	mov	r20,r6
8112f4b4:	0025883a 	mov	r18,zero
8112f4b8:	0023883a 	mov	r17,zero
8112f4bc:	28c0ba36 	bltu	r5,r3,8112f7a8 <_strtod_r+0x354>
8112f4c0:	180690ba 	slli	r3,r3,2
8112f4c4:	19c7883a 	add	r3,r3,r7
8112f4c8:	18c00017 	ldw	r3,0(r3)
8112f4cc:	1800683a 	jmp	r3
8112f4d0:	8112f590 	cmplti	r4,r16,19414
8112f4d4:	8112f7a8 	cmpgeui	r4,r16,19422
8112f4d8:	8112f7a8 	cmpgeui	r4,r16,19422
8112f4dc:	8112f7a8 	cmpgeui	r4,r16,19422
8112f4e0:	8112f7a8 	cmpgeui	r4,r16,19422
8112f4e4:	8112f7a8 	cmpgeui	r4,r16,19422
8112f4e8:	8112f7a8 	cmpgeui	r4,r16,19422
8112f4ec:	8112f7a8 	cmpgeui	r4,r16,19422
8112f4f0:	8112f7a8 	cmpgeui	r4,r16,19422
8112f4f4:	8112f794 	ori	r4,r16,19422
8112f4f8:	8112f794 	ori	r4,r16,19422
8112f4fc:	8112f794 	ori	r4,r16,19422
8112f500:	8112f794 	ori	r4,r16,19422
8112f504:	8112f794 	ori	r4,r16,19422
8112f508:	8112f7a8 	cmpgeui	r4,r16,19422
8112f50c:	8112f7a8 	cmpgeui	r4,r16,19422
8112f510:	8112f7a8 	cmpgeui	r4,r16,19422
8112f514:	8112f7a8 	cmpgeui	r4,r16,19422
8112f518:	8112f7a8 	cmpgeui	r4,r16,19422
8112f51c:	8112f7a8 	cmpgeui	r4,r16,19422
8112f520:	8112f7a8 	cmpgeui	r4,r16,19422
8112f524:	8112f7a8 	cmpgeui	r4,r16,19422
8112f528:	8112f7a8 	cmpgeui	r4,r16,19422
8112f52c:	8112f7a8 	cmpgeui	r4,r16,19422
8112f530:	8112f7a8 	cmpgeui	r4,r16,19422
8112f534:	8112f7a8 	cmpgeui	r4,r16,19422
8112f538:	8112f7a8 	cmpgeui	r4,r16,19422
8112f53c:	8112f7a8 	cmpgeui	r4,r16,19422
8112f540:	8112f7a8 	cmpgeui	r4,r16,19422
8112f544:	8112f7a8 	cmpgeui	r4,r16,19422
8112f548:	8112f7a8 	cmpgeui	r4,r16,19422
8112f54c:	8112f7a8 	cmpgeui	r4,r16,19422
8112f550:	8112f794 	ori	r4,r16,19422
8112f554:	8112f7a8 	cmpgeui	r4,r16,19422
8112f558:	8112f7a8 	cmpgeui	r4,r16,19422
8112f55c:	8112f7a8 	cmpgeui	r4,r16,19422
8112f560:	8112f7a8 	cmpgeui	r4,r16,19422
8112f564:	8112f7a8 	cmpgeui	r4,r16,19422
8112f568:	8112f7a8 	cmpgeui	r4,r16,19422
8112f56c:	8112f7a8 	cmpgeui	r4,r16,19422
8112f570:	8112f7a8 	cmpgeui	r4,r16,19422
8112f574:	8112f7a8 	cmpgeui	r4,r16,19422
8112f578:	8112f7a8 	cmpgeui	r4,r16,19422
8112f57c:	8112f5e8 	cmpgeui	r4,r16,19415
8112f580:	8112f7a8 	cmpgeui	r4,r16,19422
8112f584:	8112f788 	cmpgei	r4,r16,19422
8112f588:	00801244 	movi	r2,73
8112f58c:	88843526 	beq	r17,r2,81130664 <_strtod_r+0x1210>
8112f590:	002b883a 	mov	r21,zero
8112f594:	002d883a 	mov	r22,zero
8112f598:	a0000526 	beq	r20,zero,8112f5b0 <_strtod_r+0x15c>
8112f59c:	d8000715 	stw	zero,28(sp)
8112f5a0:	a5c00015 	stw	r23,0(r20)
8112f5a4:	d9000717 	ldw	r4,28(sp)
8112f5a8:	20000126 	beq	r4,zero,8112f5b0 <_strtod_r+0x15c>
8112f5ac:	b5a0003c 	xorhi	r22,r22,32768
8112f5b0:	a805883a 	mov	r2,r21
8112f5b4:	b007883a 	mov	r3,r22
8112f5b8:	dfc01d17 	ldw	ra,116(sp)
8112f5bc:	df001c17 	ldw	fp,112(sp)
8112f5c0:	ddc01b17 	ldw	r23,108(sp)
8112f5c4:	dd801a17 	ldw	r22,104(sp)
8112f5c8:	dd401917 	ldw	r21,100(sp)
8112f5cc:	dd001817 	ldw	r20,96(sp)
8112f5d0:	dcc01717 	ldw	r19,92(sp)
8112f5d4:	dc801617 	ldw	r18,88(sp)
8112f5d8:	dc401517 	ldw	r17,84(sp)
8112f5dc:	dc001417 	ldw	r16,80(sp)
8112f5e0:	dec01e04 	addi	sp,sp,120
8112f5e4:	f800283a 	ret
8112f5e8:	d8000715 	stw	zero,28(sp)
8112f5ec:	24c00044 	addi	r19,r4,1
8112f5f0:	dcc00615 	stw	r19,24(sp)
8112f5f4:	20800043 	ldbu	r2,1(r4)
8112f5f8:	10c03fcc 	andi	r3,r2,255
8112f5fc:	18c0201c 	xori	r3,r3,128
8112f600:	18ffe004 	addi	r3,r3,-128
8112f604:	183fe226 	beq	r3,zero,8112f590 <__reset+0xfb10f590>
8112f608:	11403fcc 	andi	r5,r2,255
8112f60c:	2940201c 	xori	r5,r5,128
8112f610:	297fe004 	addi	r5,r5,-128
8112f614:	00c00c04 	movi	r3,48
8112f618:	28c0e526 	beq	r5,r3,8112f9b0 <_strtod_r+0x55c>
8112f61c:	dcc00815 	stw	r19,32(sp)
8112f620:	0025883a 	mov	r18,zero
8112f624:	10fff404 	addi	r3,r2,-48
8112f628:	18c03fcc 	andi	r3,r3,255
8112f62c:	01000244 	movi	r4,9
8112f630:	20c37536 	bltu	r4,r3,81130408 <_strtod_r+0xfb4>
8112f634:	dd400817 	ldw	r21,32(sp)
8112f638:	0027883a 	mov	r19,zero
8112f63c:	0039883a 	mov	fp,zero
8112f640:	002d883a 	mov	r22,zero
8112f644:	01400204 	movi	r5,8
8112f648:	2d805a16 	blt	r5,r22,8112f7b4 <_strtod_r+0x360>
8112f64c:	e70002a4 	muli	fp,fp,10
8112f650:	10c03fcc 	andi	r3,r2,255
8112f654:	18c0201c 	xori	r3,r3,128
8112f658:	18ffe004 	addi	r3,r3,-128
8112f65c:	e0f9883a 	add	fp,fp,r3
8112f660:	e73ff404 	addi	fp,fp,-48
8112f664:	ad400044 	addi	r21,r21,1
8112f668:	dd400615 	stw	r21,24(sp)
8112f66c:	a8800003 	ldbu	r2,0(r21)
8112f670:	b5800044 	addi	r22,r22,1
8112f674:	10fff404 	addi	r3,r2,-48
8112f678:	18c03fcc 	andi	r3,r3,255
8112f67c:	20fff22e 	bgeu	r4,r3,8112f648 <__reset+0xfb10f648>
8112f680:	14403fcc 	andi	r17,r2,255
8112f684:	8c40201c 	xori	r17,r17,128
8112f688:	8c7fe004 	addi	r17,r17,-128
8112f68c:	8009883a 	mov	r4,r16
8112f690:	112d6740 	call	8112d674 <_localeconv_r>
8112f694:	11400017 	ldw	r5,0(r2)
8112f698:	8009883a 	mov	r4,r16
8112f69c:	d9401315 	stw	r5,76(sp)
8112f6a0:	112d6740 	call	8112d674 <_localeconv_r>
8112f6a4:	11000017 	ldw	r4,0(r2)
8112f6a8:	11244540 	call	81124454 <strlen>
8112f6ac:	d9401317 	ldw	r5,76(sp)
8112f6b0:	100d883a 	mov	r6,r2
8112f6b4:	a809883a 	mov	r4,r21
8112f6b8:	11350440 	call	81135044 <strncmp>
8112f6bc:	1000ce26 	beq	r2,zero,8112f9f8 <_strtod_r+0x5a4>
8112f6c0:	b013883a 	mov	r9,r22
8112f6c4:	000b883a 	mov	r5,zero
8112f6c8:	0015883a 	mov	r10,zero
8112f6cc:	0017883a 	mov	r11,zero
8112f6d0:	00801944 	movi	r2,101
8112f6d4:	88807826 	beq	r17,r2,8112f8b8 <_strtod_r+0x464>
8112f6d8:	00801144 	movi	r2,69
8112f6dc:	88807626 	beq	r17,r2,8112f8b8 <_strtod_r+0x464>
8112f6e0:	002b883a 	mov	r21,zero
8112f6e4:	48003d1e 	bne	r9,zero,8112f7dc <_strtod_r+0x388>
8112f6e8:	2800391e 	bne	r5,zero,8112f7d0 <_strtod_r+0x37c>
8112f6ec:	9000381e 	bne	r18,zero,8112f7d0 <_strtod_r+0x37c>
8112f6f0:	583fa71e 	bne	r11,zero,8112f590 <__reset+0xfb10f590>
8112f6f4:	00801384 	movi	r2,78
8112f6f8:	88800526 	beq	r17,r2,8112f710 <_strtod_r+0x2bc>
8112f6fc:	147fa20e 	bge	r2,r17,8112f588 <__reset+0xfb10f588>
8112f700:	00801a44 	movi	r2,105
8112f704:	8883d726 	beq	r17,r2,81130664 <_strtod_r+0x1210>
8112f708:	00801b84 	movi	r2,110
8112f70c:	88bfa01e 	bne	r17,r2,8112f590 <__reset+0xfb10f590>
8112f710:	01604574 	movhi	r5,33045
8112f714:	d9000617 	ldw	r4,24(sp)
8112f718:	29479704 	addi	r5,r5,7772
8112f71c:	01c00644 	movi	r7,25
8112f720:	00000b06 	br	8112f750 <_strtod_r+0x2fc>
8112f724:	21000044 	addi	r4,r4,1
8112f728:	20800003 	ldbu	r2,0(r4)
8112f72c:	10ffefc4 	addi	r3,r2,-65
8112f730:	10803fcc 	andi	r2,r2,255
8112f734:	1080201c 	xori	r2,r2,128
8112f738:	18c03fcc 	andi	r3,r3,255
8112f73c:	10bfe004 	addi	r2,r2,-128
8112f740:	38c00136 	bltu	r7,r3,8112f748 <_strtod_r+0x2f4>
8112f744:	10800804 	addi	r2,r2,32
8112f748:	29400044 	addi	r5,r5,1
8112f74c:	11bf901e 	bne	r2,r6,8112f590 <__reset+0xfb10f590>
8112f750:	29800007 	ldb	r6,0(r5)
8112f754:	303ff31e 	bne	r6,zero,8112f724 <__reset+0xfb10f724>
8112f758:	20800044 	addi	r2,r4,1
8112f75c:	d8800615 	stw	r2,24(sp)
8112f760:	20c00047 	ldb	r3,1(r4)
8112f764:	00800a04 	movi	r2,40
8112f768:	18849d26 	beq	r3,r2,811309e0 <_strtod_r+0x158c>
8112f76c:	047ffe34 	movhi	r17,65528
8112f770:	0025883a 	mov	r18,zero
8112f774:	902b883a 	mov	r21,r18
8112f778:	882d883a 	mov	r22,r17
8112f77c:	a03f8926 	beq	r20,zero,8112f5a4 <__reset+0xfb10f5a4>
8112f780:	ddc00617 	ldw	r23,24(sp)
8112f784:	003f8606 	br	8112f5a0 <__reset+0xfb10f5a0>
8112f788:	00800044 	movi	r2,1
8112f78c:	d8800715 	stw	r2,28(sp)
8112f790:	003f9606 	br	8112f5ec <__reset+0xfb10f5ec>
8112f794:	21000044 	addi	r4,r4,1
8112f798:	d9000615 	stw	r4,24(sp)
8112f79c:	20800003 	ldbu	r2,0(r4)
8112f7a0:	10c03fcc 	andi	r3,r2,255
8112f7a4:	28ff462e 	bgeu	r5,r3,8112f4c0 <__reset+0xfb10f4c0>
8112f7a8:	2027883a 	mov	r19,r4
8112f7ac:	d8000715 	stw	zero,28(sp)
8112f7b0:	003f9506 	br	8112f608 <__reset+0xfb10f608>
8112f7b4:	9cc002a4 	muli	r19,r19,10
8112f7b8:	10803fcc 	andi	r2,r2,255
8112f7bc:	1080201c 	xori	r2,r2,128
8112f7c0:	10bfe004 	addi	r2,r2,-128
8112f7c4:	9885883a 	add	r2,r19,r2
8112f7c8:	14fff404 	addi	r19,r2,-48
8112f7cc:	003fa506 	br	8112f664 <__reset+0xfb10f664>
8112f7d0:	002b883a 	mov	r21,zero
8112f7d4:	002d883a 	mov	r22,zero
8112f7d8:	003fe806 	br	8112f77c <__reset+0xfb10f77c>
8112f7dc:	aaabc83a 	sub	r21,r21,r10
8112f7e0:	b000011e 	bne	r22,zero,8112f7e8 <_strtod_r+0x394>
8112f7e4:	482d883a 	mov	r22,r9
8112f7e8:	00800404 	movi	r2,16
8112f7ec:	482f883a 	mov	r23,r9
8112f7f0:	1240010e 	bge	r2,r9,8112f7f8 <_strtod_r+0x3a4>
8112f7f4:	102f883a 	mov	r23,r2
8112f7f8:	e009883a 	mov	r4,fp
8112f7fc:	da401315 	stw	r9,76(sp)
8112f800:	11374a40 	call	811374a4 <__floatunsidf>
8112f804:	1025883a 	mov	r18,r2
8112f808:	00800244 	movi	r2,9
8112f80c:	1823883a 	mov	r17,r3
8112f810:	da401317 	ldw	r9,76(sp)
8112f814:	15c0160e 	bge	r2,r23,8112f870 <_strtod_r+0x41c>
8112f818:	b8bffdc4 	addi	r2,r23,-9
8112f81c:	100490fa 	slli	r2,r2,3
8112f820:	180b883a 	mov	r5,r3
8112f824:	00e04574 	movhi	r3,33045
8112f828:	18c76204 	addi	r3,r3,7560
8112f82c:	1885883a 	add	r2,r3,r2
8112f830:	11800017 	ldw	r6,0(r2)
8112f834:	11c00117 	ldw	r7,4(r2)
8112f838:	9009883a 	mov	r4,r18
8112f83c:	11213240 	call	81121324 <__muldf3>
8112f840:	9809883a 	mov	r4,r19
8112f844:	1025883a 	mov	r18,r2
8112f848:	1823883a 	mov	r17,r3
8112f84c:	11374a40 	call	811374a4 <__floatunsidf>
8112f850:	9009883a 	mov	r4,r18
8112f854:	880b883a 	mov	r5,r17
8112f858:	100d883a 	mov	r6,r2
8112f85c:	180f883a 	mov	r7,r3
8112f860:	11361840 	call	81136184 <__adddf3>
8112f864:	da401317 	ldw	r9,76(sp)
8112f868:	1025883a 	mov	r18,r2
8112f86c:	1823883a 	mov	r17,r3
8112f870:	008003c4 	movi	r2,15
8112f874:	12407b16 	blt	r2,r9,8112fa64 <_strtod_r+0x610>
8112f878:	a83fbe26 	beq	r21,zero,8112f774 <__reset+0xfb10f774>
8112f87c:	0543670e 	bge	zero,r21,8113061c <_strtod_r+0x11c8>
8112f880:	00c00584 	movi	r3,22
8112f884:	1d42e816 	blt	r3,r21,81130428 <_strtod_r+0xfd4>
8112f888:	a82a90fa 	slli	r21,r21,3
8112f88c:	00a04574 	movhi	r2,33045
8112f890:	10876204 	addi	r2,r2,7560
8112f894:	1545883a 	add	r2,r2,r21
8112f898:	11000017 	ldw	r4,0(r2)
8112f89c:	11400117 	ldw	r5,4(r2)
8112f8a0:	900d883a 	mov	r6,r18
8112f8a4:	880f883a 	mov	r7,r17
8112f8a8:	11213240 	call	81121324 <__muldf3>
8112f8ac:	102b883a 	mov	r21,r2
8112f8b0:	182d883a 	mov	r22,r3
8112f8b4:	003fb106 	br	8112f77c <__reset+0xfb10f77c>
8112f8b8:	4801b526 	beq	r9,zero,8112ff90 <_strtod_r+0xb3c>
8112f8bc:	ddc00617 	ldw	r23,24(sp)
8112f8c0:	00c00ac4 	movi	r3,43
8112f8c4:	b8800044 	addi	r2,r23,1
8112f8c8:	d8800615 	stw	r2,24(sp)
8112f8cc:	b8800047 	ldb	r2,1(r23)
8112f8d0:	10c1e926 	beq	r2,r3,81130078 <_strtod_r+0xc24>
8112f8d4:	00c00b44 	movi	r3,45
8112f8d8:	10c1ec26 	beq	r2,r3,8113008c <_strtod_r+0xc38>
8112f8dc:	1023883a 	mov	r17,r2
8112f8e0:	0019883a 	mov	r12,zero
8112f8e4:	88bff404 	addi	r2,r17,-48
8112f8e8:	00c00244 	movi	r3,9
8112f8ec:	1881b736 	bltu	r3,r2,8112ffcc <_strtod_r+0xb78>
8112f8f0:	00800c04 	movi	r2,48
8112f8f4:	8880071e 	bne	r17,r2,8112f914 <_strtod_r+0x4c0>
8112f8f8:	d8800617 	ldw	r2,24(sp)
8112f8fc:	8807883a 	mov	r3,r17
8112f900:	10800044 	addi	r2,r2,1
8112f904:	d8800615 	stw	r2,24(sp)
8112f908:	14400007 	ldb	r17,0(r2)
8112f90c:	10800044 	addi	r2,r2,1
8112f910:	88fffc26 	beq	r17,r3,8112f904 <__reset+0xfb10f904>
8112f914:	88bff3c4 	addi	r2,r17,-49
8112f918:	00c00204 	movi	r3,8
8112f91c:	18bf7036 	bltu	r3,r2,8112f6e0 <__reset+0xfb10f6e0>
8112f920:	db800617 	ldw	r14,24(sp)
8112f924:	88bff404 	addi	r2,r17,-48
8112f928:	03400244 	movi	r13,9
8112f92c:	71c00044 	addi	r7,r14,1
8112f930:	d9c00615 	stw	r7,24(sp)
8112f934:	74400043 	ldbu	r17,1(r14)
8112f938:	88fff404 	addi	r3,r17,-48
8112f93c:	8c403fcc 	andi	r17,r17,255
8112f940:	8c40201c 	xori	r17,r17,128
8112f944:	18c03fcc 	andi	r3,r3,255
8112f948:	8c7fe004 	addi	r17,r17,-128
8112f94c:	68c00e36 	bltu	r13,r3,8112f988 <_strtod_r+0x534>
8112f950:	71000084 	addi	r4,r14,2
8112f954:	d9000615 	stw	r4,24(sp)
8112f958:	108002a4 	muli	r2,r2,10
8112f95c:	21800003 	ldbu	r6,0(r4)
8112f960:	200f883a 	mov	r7,r4
8112f964:	1463883a 	add	r17,r2,r17
8112f968:	30fff404 	addi	r3,r6,-48
8112f96c:	88bff404 	addi	r2,r17,-48
8112f970:	34403fcc 	andi	r17,r6,255
8112f974:	8c40201c 	xori	r17,r17,128
8112f978:	18c03fcc 	andi	r3,r3,255
8112f97c:	8c7fe004 	addi	r17,r17,-128
8112f980:	21000044 	addi	r4,r4,1
8112f984:	68fff32e 	bgeu	r13,r3,8112f954 <__reset+0xfb10f954>
8112f988:	3b8fc83a 	sub	r7,r7,r14
8112f98c:	00c00204 	movi	r3,8
8112f990:	19c29716 	blt	r3,r7,811303f0 <_strtod_r+0xf9c>
8112f994:	102b883a 	mov	r21,r2
8112f998:	009387c4 	movi	r2,19999
8112f99c:	1540010e 	bge	r2,r21,8112f9a4 <_strtod_r+0x550>
8112f9a0:	102b883a 	mov	r21,r2
8112f9a4:	603f4f26 	beq	r12,zero,8112f6e4 <__reset+0xfb10f6e4>
8112f9a8:	056bc83a 	sub	r21,zero,r21
8112f9ac:	003f4d06 	br	8112f6e4 <__reset+0xfb10f6e4>
8112f9b0:	98800047 	ldb	r2,1(r19)
8112f9b4:	00c01604 	movi	r3,88
8112f9b8:	10c1de26 	beq	r2,r3,81130134 <_strtod_r+0xce0>
8112f9bc:	00c01e04 	movi	r3,120
8112f9c0:	10c1dc26 	beq	r2,r3,81130134 <_strtod_r+0xce0>
8112f9c4:	98c00044 	addi	r3,r19,1
8112f9c8:	1827883a 	mov	r19,r3
8112f9cc:	d8c00615 	stw	r3,24(sp)
8112f9d0:	18c00044 	addi	r3,r3,1
8112f9d4:	18bfffc3 	ldbu	r2,-1(r3)
8112f9d8:	11003fcc 	andi	r4,r2,255
8112f9dc:	2100201c 	xori	r4,r4,128
8112f9e0:	213fe004 	addi	r4,r4,-128
8112f9e4:	217ff826 	beq	r4,r5,8112f9c8 <__reset+0xfb10f9c8>
8112f9e8:	203f7926 	beq	r4,zero,8112f7d0 <__reset+0xfb10f7d0>
8112f9ec:	dcc00815 	stw	r19,32(sp)
8112f9f0:	04800044 	movi	r18,1
8112f9f4:	003f0b06 	br	8112f624 <__reset+0xfb10f624>
8112f9f8:	8009883a 	mov	r4,r16
8112f9fc:	112d6740 	call	8112d674 <_localeconv_r>
8112fa00:	11000017 	ldw	r4,0(r2)
8112fa04:	11244540 	call	81124454 <strlen>
8112fa08:	d8c00617 	ldw	r3,24(sp)
8112fa0c:	1885883a 	add	r2,r3,r2
8112fa10:	d8800615 	stw	r2,24(sp)
8112fa14:	14400007 	ldb	r17,0(r2)
8112fa18:	b001881e 	bne	r22,zero,8113003c <_strtod_r+0xbe8>
8112fa1c:	00c00c04 	movi	r3,48
8112fa20:	88c3391e 	bne	r17,r3,81130708 <_strtod_r+0x12b4>
8112fa24:	10c00044 	addi	r3,r2,1
8112fa28:	8809883a 	mov	r4,r17
8112fa2c:	d8c00615 	stw	r3,24(sp)
8112fa30:	1c400007 	ldb	r17,0(r3)
8112fa34:	188bc83a 	sub	r5,r3,r2
8112fa38:	18c00044 	addi	r3,r3,1
8112fa3c:	893ffb26 	beq	r17,r4,8112fa2c <__reset+0xfb10fa2c>
8112fa40:	88bff3c4 	addi	r2,r17,-49
8112fa44:	00c00204 	movi	r3,8
8112fa48:	1882e72e 	bgeu	r3,r2,811305e8 <_strtod_r+0x1194>
8112fa4c:	00801944 	movi	r2,101
8112fa50:	88814d26 	beq	r17,r2,8112ff88 <_strtod_r+0xb34>
8112fa54:	0013883a 	mov	r9,zero
8112fa58:	0015883a 	mov	r10,zero
8112fa5c:	02c00044 	movi	r11,1
8112fa60:	003f1d06 	br	8112f6d8 <__reset+0xfb10f6d8>
8112fa64:	4defc83a 	sub	r23,r9,r23
8112fa68:	bd6f883a 	add	r23,r23,r21
8112fa6c:	05c21e0e 	bge	zero,r23,811302e8 <_strtod_r+0xe94>
8112fa70:	b88003cc 	andi	r2,r23,15
8112fa74:	10000d26 	beq	r2,zero,8112faac <_strtod_r+0x658>
8112fa78:	100490fa 	slli	r2,r2,3
8112fa7c:	00e04574 	movhi	r3,33045
8112fa80:	18c76204 	addi	r3,r3,7560
8112fa84:	1885883a 	add	r2,r3,r2
8112fa88:	11000017 	ldw	r4,0(r2)
8112fa8c:	11400117 	ldw	r5,4(r2)
8112fa90:	900d883a 	mov	r6,r18
8112fa94:	880f883a 	mov	r7,r17
8112fa98:	da401315 	stw	r9,76(sp)
8112fa9c:	11213240 	call	81121324 <__muldf3>
8112faa0:	da401317 	ldw	r9,76(sp)
8112faa4:	1025883a 	mov	r18,r2
8112faa8:	1823883a 	mov	r17,r3
8112faac:	023ffc04 	movi	r8,-16
8112fab0:	ba10703a 	and	r8,r23,r8
8112fab4:	40003c26 	beq	r8,zero,8112fba8 <_strtod_r+0x754>
8112fab8:	00804d04 	movi	r2,308
8112fabc:	1201cd16 	blt	r2,r8,811301f4 <_strtod_r+0xda0>
8112fac0:	4011d13a 	srai	r8,r8,4
8112fac4:	03000044 	movi	r12,1
8112fac8:	62037c0e 	bge	r12,r8,811308bc <_strtod_r+0x1468>
8112facc:	01204574 	movhi	r4,33045
8112fad0:	21075804 	addi	r4,r4,7520
8112fad4:	2015883a 	mov	r10,r4
8112fad8:	0027883a 	mov	r19,zero
8112fadc:	d9000915 	stw	r4,36(sp)
8112fae0:	9005883a 	mov	r2,r18
8112fae4:	8807883a 	mov	r3,r17
8112fae8:	dc000c15 	stw	r16,48(sp)
8112faec:	dc800e15 	stw	r18,56(sp)
8112faf0:	9821883a 	mov	r16,r19
8112faf4:	0009883a 	mov	r4,zero
8112faf8:	8827883a 	mov	r19,r17
8112fafc:	602f883a 	mov	r23,r12
8112fb00:	da400a15 	stw	r9,40(sp)
8112fb04:	5025883a 	mov	r18,r10
8112fb08:	4023883a 	mov	r17,r8
8112fb0c:	8980004c 	andi	r6,r17,1
8112fb10:	30000626 	beq	r6,zero,8112fb2c <_strtod_r+0x6d8>
8112fb14:	91800017 	ldw	r6,0(r18)
8112fb18:	91c00117 	ldw	r7,4(r18)
8112fb1c:	1009883a 	mov	r4,r2
8112fb20:	180b883a 	mov	r5,r3
8112fb24:	11213240 	call	81121324 <__muldf3>
8112fb28:	01000044 	movi	r4,1
8112fb2c:	8823d07a 	srai	r17,r17,1
8112fb30:	84000044 	addi	r16,r16,1
8112fb34:	94800204 	addi	r18,r18,8
8112fb38:	8dfff41e 	bne	r17,r23,8112fb0c <__reset+0xfb10fb0c>
8112fb3c:	21003fcc 	andi	r4,r4,255
8112fb40:	9823883a 	mov	r17,r19
8112fb44:	da400a17 	ldw	r9,40(sp)
8112fb48:	8027883a 	mov	r19,r16
8112fb4c:	dc800e17 	ldw	r18,56(sp)
8112fb50:	dc000c17 	ldw	r16,48(sp)
8112fb54:	2003b11e 	bne	r4,zero,81130a1c <_strtod_r+0x15c8>
8112fb58:	981690fa 	slli	r11,r19,3
8112fb5c:	d8800917 	ldw	r2,36(sp)
8112fb60:	01ff2c34 	movhi	r7,64688
8112fb64:	900d883a 	mov	r6,r18
8112fb68:	12ef883a 	add	r23,r2,r11
8112fb6c:	b9000017 	ldw	r4,0(r23)
8112fb70:	b9400117 	ldw	r5,4(r23)
8112fb74:	89cf883a 	add	r7,r17,r7
8112fb78:	da401315 	stw	r9,76(sp)
8112fb7c:	11213240 	call	81121324 <__muldf3>
8112fb80:	1025883a 	mov	r18,r2
8112fb84:	011f2834 	movhi	r4,31904
8112fb88:	189ffc2c 	andhi	r2,r3,32752
8112fb8c:	da401317 	ldw	r9,76(sp)
8112fb90:	20819836 	bltu	r4,r2,811301f4 <_strtod_r+0xda0>
8112fb94:	011f2434 	movhi	r4,31888
8112fb98:	2083382e 	bgeu	r4,r2,8113087c <_strtod_r+0x1428>
8112fb9c:	045ffc34 	movhi	r17,32752
8112fba0:	8c7fffc4 	addi	r17,r17,-1
8112fba4:	04bfffc4 	movi	r18,-1
8112fba8:	d8000915 	stw	zero,36(sp)
8112fbac:	d9400817 	ldw	r5,32(sp)
8112fbb0:	df000015 	stw	fp,0(sp)
8112fbb4:	480f883a 	mov	r7,r9
8112fbb8:	b00d883a 	mov	r6,r22
8112fbbc:	8009883a 	mov	r4,r16
8112fbc0:	112dd900 	call	8112dd90 <__s2b>
8112fbc4:	d8800815 	stw	r2,32(sp)
8112fbc8:	10018a26 	beq	r2,zero,811301f4 <_strtod_r+0xda0>
8112fbcc:	a807d7fa 	srai	r3,r21,31
8112fbd0:	0545c83a 	sub	r2,zero,r21
8112fbd4:	dd400a15 	stw	r21,40(sp)
8112fbd8:	1886703a 	and	r3,r3,r2
8112fbdc:	d8c00c15 	stw	r3,48(sp)
8112fbe0:	a8013516 	blt	r21,zero,811300b8 <_strtod_r+0xc64>
8112fbe4:	d9400817 	ldw	r5,32(sp)
8112fbe8:	0011883a 	mov	r8,zero
8112fbec:	0027883a 	mov	r19,zero
8112fbf0:	29400304 	addi	r5,r5,12
8112fbf4:	d9400f15 	stw	r5,60(sp)
8112fbf8:	402b883a 	mov	r21,r8
8112fbfc:	dd001215 	stw	r20,72(sp)
8112fc00:	d8800817 	ldw	r2,32(sp)
8112fc04:	8009883a 	mov	r4,r16
8112fc08:	11400117 	ldw	r5,4(r2)
8112fc0c:	112db900 	call	8112db90 <_Balloc>
8112fc10:	1029883a 	mov	r20,r2
8112fc14:	10012d26 	beq	r2,zero,811300cc <_strtod_r+0xc78>
8112fc18:	d8c00817 	ldw	r3,32(sp)
8112fc1c:	d9400f17 	ldw	r5,60(sp)
8112fc20:	11000304 	addi	r4,r2,12
8112fc24:	19800417 	ldw	r6,16(r3)
8112fc28:	31800084 	addi	r6,r6,2
8112fc2c:	318d883a 	add	r6,r6,r6
8112fc30:	318d883a 	add	r6,r6,r6
8112fc34:	11239dc0 	call	811239dc <memcpy>
8112fc38:	d9000204 	addi	r4,sp,8
8112fc3c:	d9000015 	stw	r4,0(sp)
8112fc40:	d9c00404 	addi	r7,sp,16
8112fc44:	900b883a 	mov	r5,r18
8112fc48:	880d883a 	mov	r6,r17
8112fc4c:	8009883a 	mov	r4,r16
8112fc50:	112e86c0 	call	8112e86c <__d2b>
8112fc54:	d8800515 	stw	r2,20(sp)
8112fc58:	dc801115 	stw	r18,68(sp)
8112fc5c:	dc401015 	stw	r17,64(sp)
8112fc60:	10027c26 	beq	r2,zero,81130654 <_strtod_r+0x1200>
8112fc64:	01400044 	movi	r5,1
8112fc68:	8009883a 	mov	r4,r16
8112fc6c:	112dfb40 	call	8112dfb4 <__i2b>
8112fc70:	1027883a 	mov	r19,r2
8112fc74:	10011526 	beq	r2,zero,811300cc <_strtod_r+0xc78>
8112fc78:	d8800417 	ldw	r2,16(sp)
8112fc7c:	1000c816 	blt	r2,zero,8112ffa0 <_strtod_r+0xb4c>
8112fc80:	d9400c17 	ldw	r5,48(sp)
8112fc84:	d9000a17 	ldw	r4,40(sp)
8112fc88:	28ad883a 	add	r22,r5,r2
8112fc8c:	d9400917 	ldw	r5,36(sp)
8112fc90:	df000217 	ldw	fp,8(sp)
8112fc94:	05ff0084 	movi	r23,-1022
8112fc98:	1147c83a 	sub	r3,r2,r5
8112fc9c:	1f07883a 	add	r3,r3,fp
8112fca0:	00800d84 	movi	r2,54
8112fca4:	18ffffc4 	addi	r3,r3,-1
8112fca8:	1739c83a 	sub	fp,r2,fp
8112fcac:	1dc0a50e 	bge	r3,r23,8112ff44 <_strtod_r+0xaf0>
8112fcb0:	b8efc83a 	sub	r23,r23,r3
8112fcb4:	008007c4 	movi	r2,31
8112fcb8:	e5f9c83a 	sub	fp,fp,r23
8112fcbc:	15c0bc16 	blt	r2,r23,8112ffb0 <_strtod_r+0xb5c>
8112fcc0:	00800044 	movi	r2,1
8112fcc4:	15c4983a 	sll	r2,r2,r23
8112fcc8:	d8000b15 	stw	zero,44(sp)
8112fccc:	d8800d15 	stw	r2,52(sp)
8112fcd0:	2707883a 	add	r3,r4,fp
8112fcd4:	d9000917 	ldw	r4,36(sp)
8112fcd8:	b739883a 	add	fp,r22,fp
8112fcdc:	20ef883a 	add	r23,r4,r3
8112fce0:	b009883a 	mov	r4,r22
8112fce4:	e580010e 	bge	fp,r22,8112fcec <_strtod_r+0x898>
8112fce8:	e009883a 	mov	r4,fp
8112fcec:	b805883a 	mov	r2,r23
8112fcf0:	25c0010e 	bge	r4,r23,8112fcf8 <_strtod_r+0x8a4>
8112fcf4:	2005883a 	mov	r2,r4
8112fcf8:	0080030e 	bge	zero,r2,8112fd08 <_strtod_r+0x8b4>
8112fcfc:	e0b9c83a 	sub	fp,fp,r2
8112fd00:	b8afc83a 	sub	r23,r23,r2
8112fd04:	b0adc83a 	sub	r22,r22,r2
8112fd08:	d9400c17 	ldw	r5,48(sp)
8112fd0c:	28001126 	beq	r5,zero,8112fd54 <_strtod_r+0x900>
8112fd10:	280d883a 	mov	r6,r5
8112fd14:	8009883a 	mov	r4,r16
8112fd18:	980b883a 	mov	r5,r19
8112fd1c:	112e1f80 	call	8112e1f8 <__pow5mult>
8112fd20:	1027883a 	mov	r19,r2
8112fd24:	1000e926 	beq	r2,zero,811300cc <_strtod_r+0xc78>
8112fd28:	d9800517 	ldw	r6,20(sp)
8112fd2c:	100b883a 	mov	r5,r2
8112fd30:	8009883a 	mov	r4,r16
8112fd34:	112dff80 	call	8112dff8 <__multiply>
8112fd38:	1000e426 	beq	r2,zero,811300cc <_strtod_r+0xc78>
8112fd3c:	d9400517 	ldw	r5,20(sp)
8112fd40:	8009883a 	mov	r4,r16
8112fd44:	d8801315 	stw	r2,76(sp)
8112fd48:	112dc400 	call	8112dc40 <_Bfree>
8112fd4c:	d8801317 	ldw	r2,76(sp)
8112fd50:	d8800515 	stw	r2,20(sp)
8112fd54:	0700060e 	bge	zero,fp,8112fd70 <_strtod_r+0x91c>
8112fd58:	d9400517 	ldw	r5,20(sp)
8112fd5c:	e00d883a 	mov	r6,fp
8112fd60:	8009883a 	mov	r4,r16
8112fd64:	112e3400 	call	8112e340 <__lshift>
8112fd68:	d8800515 	stw	r2,20(sp)
8112fd6c:	10023926 	beq	r2,zero,81130654 <_strtod_r+0x1200>
8112fd70:	d8800a17 	ldw	r2,40(sp)
8112fd74:	10000626 	beq	r2,zero,8112fd90 <_strtod_r+0x93c>
8112fd78:	d9800a17 	ldw	r6,40(sp)
8112fd7c:	a00b883a 	mov	r5,r20
8112fd80:	8009883a 	mov	r4,r16
8112fd84:	112e1f80 	call	8112e1f8 <__pow5mult>
8112fd88:	1029883a 	mov	r20,r2
8112fd8c:	1000cf26 	beq	r2,zero,811300cc <_strtod_r+0xc78>
8112fd90:	05c0060e 	bge	zero,r23,8112fdac <_strtod_r+0x958>
8112fd94:	a00b883a 	mov	r5,r20
8112fd98:	b80d883a 	mov	r6,r23
8112fd9c:	8009883a 	mov	r4,r16
8112fda0:	112e3400 	call	8112e340 <__lshift>
8112fda4:	1029883a 	mov	r20,r2
8112fda8:	1000c826 	beq	r2,zero,811300cc <_strtod_r+0xc78>
8112fdac:	0580060e 	bge	zero,r22,8112fdc8 <_strtod_r+0x974>
8112fdb0:	980b883a 	mov	r5,r19
8112fdb4:	b00d883a 	mov	r6,r22
8112fdb8:	8009883a 	mov	r4,r16
8112fdbc:	112e3400 	call	8112e340 <__lshift>
8112fdc0:	1027883a 	mov	r19,r2
8112fdc4:	1000c126 	beq	r2,zero,811300cc <_strtod_r+0xc78>
8112fdc8:	d9400517 	ldw	r5,20(sp)
8112fdcc:	a00d883a 	mov	r6,r20
8112fdd0:	8009883a 	mov	r4,r16
8112fdd4:	112e4f00 	call	8112e4f0 <__mdiff>
8112fdd8:	102b883a 	mov	r21,r2
8112fddc:	1000bb26 	beq	r2,zero,811300cc <_strtod_r+0xc78>
8112fde0:	10c00317 	ldw	r3,12(r2)
8112fde4:	980b883a 	mov	r5,r19
8112fde8:	10000315 	stw	zero,12(r2)
8112fdec:	1009883a 	mov	r4,r2
8112fdf0:	d8c00e15 	stw	r3,56(sp)
8112fdf4:	112e4900 	call	8112e490 <__mcmp>
8112fdf8:	10027616 	blt	r2,zero,811307d4 <_strtod_r+0x1380>
8112fdfc:	10024426 	beq	r2,zero,81130710 <_strtod_r+0x12bc>
8112fe00:	980b883a 	mov	r5,r19
8112fe04:	a809883a 	mov	r4,r21
8112fe08:	112e9c00 	call	8112e9c0 <__ratio>
8112fe0c:	000d883a 	mov	r6,zero
8112fe10:	01d00034 	movhi	r7,16384
8112fe14:	1009883a 	mov	r4,r2
8112fe18:	180b883a 	mov	r5,r3
8112fe1c:	102f883a 	mov	r23,r2
8112fe20:	182d883a 	mov	r22,r3
8112fe24:	11373b00 	call	811373b0 <__ledf2>
8112fe28:	00804a16 	blt	zero,r2,8112ff54 <_strtod_r+0xb00>
8112fe2c:	d9400e17 	ldw	r5,56(sp)
8112fe30:	28006b26 	beq	r5,zero,8112ffe0 <_strtod_r+0xb8c>
8112fe34:	058ffc34 	movhi	r22,16368
8112fe38:	d8000b15 	stw	zero,44(sp)
8112fe3c:	d8000d15 	stw	zero,52(sp)
8112fe40:	b02f883a 	mov	r23,r22
8112fe44:	8f1ffc2c 	andhi	fp,r17,32752
8112fe48:	009ff834 	movhi	r2,32736
8112fe4c:	e080cd26 	beq	fp,r2,81130184 <_strtod_r+0xd30>
8112fe50:	d9400917 	ldw	r5,36(sp)
8112fe54:	28001a26 	beq	r5,zero,8112fec0 <_strtod_r+0xa6c>
8112fe58:	0081a834 	movhi	r2,1696
8112fe5c:	17001836 	bltu	r2,fp,8112fec0 <_strtod_r+0xa6c>
8112fe60:	d9000d17 	ldw	r4,52(sp)
8112fe64:	01d07834 	movhi	r7,16864
8112fe68:	39ffffc4 	addi	r7,r7,-1
8112fe6c:	01bff034 	movhi	r6,65472
8112fe70:	b80b883a 	mov	r5,r23
8112fe74:	11373b00 	call	811373b0 <__ledf2>
8112fe78:	00800e16 	blt	zero,r2,8112feb4 <_strtod_r+0xa60>
8112fe7c:	d9000d17 	ldw	r4,52(sp)
8112fe80:	b80b883a 	mov	r5,r23
8112fe84:	112075c0 	call	8112075c <__fixunsdfsi>
8112fe88:	10018126 	beq	r2,zero,81130490 <_strtod_r+0x103c>
8112fe8c:	1009883a 	mov	r4,r2
8112fe90:	11374a40 	call	811374a4 <__floatunsidf>
8112fe94:	d8800d15 	stw	r2,52(sp)
8112fe98:	182f883a 	mov	r23,r3
8112fe9c:	d8800e17 	ldw	r2,56(sp)
8112fea0:	1001791e 	bne	r2,zero,81130488 <_strtod_r+0x1034>
8112fea4:	ba20003c 	xorhi	r8,r23,32768
8112fea8:	d8c00d17 	ldw	r3,52(sp)
8112feac:	402d883a 	mov	r22,r8
8112feb0:	d8c00b15 	stw	r3,44(sp)
8112feb4:	0081ac34 	movhi	r2,1712
8112feb8:	b091883a 	add	r8,r22,r2
8112febc:	472dc83a 	sub	r22,r8,fp
8112fec0:	9009883a 	mov	r4,r18
8112fec4:	880b883a 	mov	r5,r17
8112fec8:	112e6f40 	call	8112e6f4 <__ulp>
8112fecc:	d9000b17 	ldw	r4,44(sp)
8112fed0:	b00b883a 	mov	r5,r22
8112fed4:	100d883a 	mov	r6,r2
8112fed8:	180f883a 	mov	r7,r3
8112fedc:	11213240 	call	81121324 <__muldf3>
8112fee0:	900d883a 	mov	r6,r18
8112fee4:	880f883a 	mov	r7,r17
8112fee8:	1009883a 	mov	r4,r2
8112feec:	180b883a 	mov	r5,r3
8112fef0:	11361840 	call	81136184 <__adddf3>
8112fef4:	1025883a 	mov	r18,r2
8112fef8:	1823883a 	mov	r17,r3
8112fefc:	182d883a 	mov	r22,r3
8112ff00:	d9000917 	ldw	r4,36(sp)
8112ff04:	2000021e 	bne	r4,zero,8112ff10 <_strtod_r+0xabc>
8112ff08:	b09ffc2c 	andhi	r2,r22,32752
8112ff0c:	e080be26 	beq	fp,r2,81130208 <_strtod_r+0xdb4>
8112ff10:	d9400517 	ldw	r5,20(sp)
8112ff14:	8009883a 	mov	r4,r16
8112ff18:	112dc400 	call	8112dc40 <_Bfree>
8112ff1c:	a00b883a 	mov	r5,r20
8112ff20:	8009883a 	mov	r4,r16
8112ff24:	112dc400 	call	8112dc40 <_Bfree>
8112ff28:	980b883a 	mov	r5,r19
8112ff2c:	8009883a 	mov	r4,r16
8112ff30:	112dc400 	call	8112dc40 <_Bfree>
8112ff34:	a80b883a 	mov	r5,r21
8112ff38:	8009883a 	mov	r4,r16
8112ff3c:	112dc400 	call	8112dc40 <_Bfree>
8112ff40:	003f2f06 	br	8112fc00 <__reset+0xfb10fc00>
8112ff44:	00c00044 	movi	r3,1
8112ff48:	d8000b15 	stw	zero,44(sp)
8112ff4c:	d8c00d15 	stw	r3,52(sp)
8112ff50:	003f5f06 	br	8112fcd0 <__reset+0xfb10fcd0>
8112ff54:	b809883a 	mov	r4,r23
8112ff58:	000d883a 	mov	r6,zero
8112ff5c:	01cff834 	movhi	r7,16352
8112ff60:	b00b883a 	mov	r5,r22
8112ff64:	11213240 	call	81121324 <__muldf3>
8112ff68:	d9000e17 	ldw	r4,56(sp)
8112ff6c:	d8800d15 	stw	r2,52(sp)
8112ff70:	182f883a 	mov	r23,r3
8112ff74:	2000181e 	bne	r4,zero,8112ffd8 <_strtod_r+0xb84>
8112ff78:	1a20003c 	xorhi	r8,r3,32768
8112ff7c:	d8800b15 	stw	r2,44(sp)
8112ff80:	402d883a 	mov	r22,r8
8112ff84:	003faf06 	br	8112fe44 <__reset+0xfb10fe44>
8112ff88:	0015883a 	mov	r10,zero
8112ff8c:	02c00044 	movi	r11,1
8112ff90:	2800011e 	bne	r5,zero,8112ff98 <_strtod_r+0xb44>
8112ff94:	903d7e26 	beq	r18,zero,8112f590 <__reset+0xfb10f590>
8112ff98:	0013883a 	mov	r9,zero
8112ff9c:	003e4706 	br	8112f8bc <__reset+0xfb10f8bc>
8112ffa0:	d8c00a17 	ldw	r3,40(sp)
8112ffa4:	dd800c17 	ldw	r22,48(sp)
8112ffa8:	1889c83a 	sub	r4,r3,r2
8112ffac:	003f3706 	br	8112fc8c <__reset+0xfb10fc8c>
8112ffb0:	00bef884 	movi	r2,-1054
8112ffb4:	05c00044 	movi	r23,1
8112ffb8:	10c5c83a 	sub	r2,r2,r3
8112ffbc:	b884983a 	sll	r2,r23,r2
8112ffc0:	ddc00d15 	stw	r23,52(sp)
8112ffc4:	d8800b15 	stw	r2,44(sp)
8112ffc8:	003f4106 	br	8112fcd0 <__reset+0xfb10fcd0>
8112ffcc:	ddc00615 	stw	r23,24(sp)
8112ffd0:	002b883a 	mov	r21,zero
8112ffd4:	003dc306 	br	8112f6e4 <__reset+0xfb10f6e4>
8112ffd8:	1811883a 	mov	r8,r3
8112ffdc:	003fe706 	br	8112ff7c <__reset+0xfb10ff7c>
8112ffe0:	90002e1e 	bne	r18,zero,8113009c <_strtod_r+0xc48>
8112ffe4:	00c00434 	movhi	r3,16
8112ffe8:	18ffffc4 	addi	r3,r3,-1
8112ffec:	88c4703a 	and	r2,r17,r3
8112fff0:	10002c1e 	bne	r2,zero,811300a4 <_strtod_r+0xc50>
8112fff4:	000d883a 	mov	r6,zero
8112fff8:	01cffc34 	movhi	r7,16368
8112fffc:	b809883a 	mov	r4,r23
81130000:	b00b883a 	mov	r5,r22
81130004:	11373b00 	call	811373b0 <__ledf2>
81130008:	10021716 	blt	r2,zero,81130868 <_strtod_r+0x1414>
8113000c:	b809883a 	mov	r4,r23
81130010:	b00b883a 	mov	r5,r22
81130014:	000d883a 	mov	r6,zero
81130018:	01cff834 	movhi	r7,16352
8113001c:	11213240 	call	81121324 <__muldf3>
81130020:	d8800d15 	stw	r2,52(sp)
81130024:	182f883a 	mov	r23,r3
81130028:	102d883a 	mov	r22,r2
8113002c:	1a20003c 	xorhi	r8,r3,32768
81130030:	dd800b15 	stw	r22,44(sp)
81130034:	402d883a 	mov	r22,r8
81130038:	003f8206 	br	8112fe44 <__reset+0xfb10fe44>
8113003c:	b013883a 	mov	r9,r22
81130040:	000b883a 	mov	r5,zero
81130044:	0015883a 	mov	r10,zero
81130048:	893ff404 	addi	r4,r17,-48
8113004c:	00800244 	movi	r2,9
81130050:	11001036 	bltu	r2,r4,81130094 <_strtod_r+0xc40>
81130054:	28c00044 	addi	r3,r5,1
81130058:	2023883a 	mov	r17,r4
8113005c:	20014d1e 	bne	r4,zero,81130594 <_strtod_r+0x1140>
81130060:	d9800617 	ldw	r6,24(sp)
81130064:	180b883a 	mov	r5,r3
81130068:	30800044 	addi	r2,r6,1
8113006c:	d8800615 	stw	r2,24(sp)
81130070:	34400047 	ldb	r17,1(r6)
81130074:	003ff406 	br	81130048 <__reset+0xfb110048>
81130078:	0019883a 	mov	r12,zero
8113007c:	b8800084 	addi	r2,r23,2
81130080:	d8800615 	stw	r2,24(sp)
81130084:	bc400087 	ldb	r17,2(r23)
81130088:	003e1606 	br	8112f8e4 <__reset+0xfb10f8e4>
8113008c:	03000044 	movi	r12,1
81130090:	003ffa06 	br	8113007c <__reset+0xfb11007c>
81130094:	02c00044 	movi	r11,1
81130098:	003d8d06 	br	8112f6d0 <__reset+0xfb10f6d0>
8113009c:	00800044 	movi	r2,1
811300a0:	9080fe26 	beq	r18,r2,8113049c <_strtod_r+0x1048>
811300a4:	d8000b15 	stw	zero,44(sp)
811300a8:	05affc34 	movhi	r22,49136
811300ac:	d8000d15 	stw	zero,52(sp)
811300b0:	05cffc34 	movhi	r23,16368
811300b4:	003f6306 	br	8112fe44 <__reset+0xfb10fe44>
811300b8:	d8000a15 	stw	zero,40(sp)
811300bc:	003ec906 	br	8112fbe4 <__reset+0xfb10fbe4>
811300c0:	d9001117 	ldw	r4,68(sp)
811300c4:	00bfffc4 	movi	r2,-1
811300c8:	2080461e 	bne	r4,r2,811301e4 <_strtod_r+0xd90>
811300cc:	dd000a15 	stw	r20,40(sp)
811300d0:	dd001217 	ldw	r20,72(sp)
811300d4:	a811883a 	mov	r8,r21
811300d8:	d8800517 	ldw	r2,20(sp)
811300dc:	00c00884 	movi	r3,34
811300e0:	80c00015 	stw	r3,0(r16)
811300e4:	002b883a 	mov	r21,zero
811300e8:	059ffc34 	movhi	r22,32752
811300ec:	100b883a 	mov	r5,r2
811300f0:	8009883a 	mov	r4,r16
811300f4:	da001315 	stw	r8,76(sp)
811300f8:	112dc400 	call	8112dc40 <_Bfree>
811300fc:	d9400a17 	ldw	r5,40(sp)
81130100:	8009883a 	mov	r4,r16
81130104:	112dc400 	call	8112dc40 <_Bfree>
81130108:	980b883a 	mov	r5,r19
8113010c:	8009883a 	mov	r4,r16
81130110:	112dc400 	call	8112dc40 <_Bfree>
81130114:	d9400817 	ldw	r5,32(sp)
81130118:	8009883a 	mov	r4,r16
8113011c:	112dc400 	call	8112dc40 <_Bfree>
81130120:	da001317 	ldw	r8,76(sp)
81130124:	8009883a 	mov	r4,r16
81130128:	400b883a 	mov	r5,r8
8113012c:	112dc400 	call	8112dc40 <_Bfree>
81130130:	003d9206 	br	8112f77c <__reset+0xfb10f77c>
81130134:	d8c00717 	ldw	r3,28(sp)
81130138:	d8800504 	addi	r2,sp,20
8113013c:	01a04574 	movhi	r6,33045
81130140:	31879d04 	addi	r6,r6,7796
81130144:	d8c00115 	stw	r3,4(sp)
81130148:	d8800015 	stw	r2,0(sp)
8113014c:	d9c00404 	addi	r7,sp,16
81130150:	d9400604 	addi	r5,sp,24
81130154:	8009883a 	mov	r4,r16
81130158:	11345a80 	call	811345a8 <__gethex>
8113015c:	154001cc 	andi	r21,r2,7
81130160:	a83d9b26 	beq	r21,zero,8112f7d0 <__reset+0xfb10f7d0>
81130164:	00c00184 	movi	r3,6
81130168:	a8c0d61e 	bne	r21,r3,811304c4 <_strtod_r+0x1070>
8113016c:	9cc00044 	addi	r19,r19,1
81130170:	dcc00615 	stw	r19,24(sp)
81130174:	002b883a 	mov	r21,zero
81130178:	002d883a 	mov	r22,zero
8113017c:	d8000715 	stw	zero,28(sp)
81130180:	003d7e06 	br	8112f77c <__reset+0xfb10f77c>
81130184:	00bf2c34 	movhi	r2,64688
81130188:	88a3883a 	add	r17,r17,r2
8113018c:	9009883a 	mov	r4,r18
81130190:	880b883a 	mov	r5,r17
81130194:	112e6f40 	call	8112e6f4 <__ulp>
81130198:	d9000b17 	ldw	r4,44(sp)
8113019c:	100d883a 	mov	r6,r2
811301a0:	180f883a 	mov	r7,r3
811301a4:	b00b883a 	mov	r5,r22
811301a8:	11213240 	call	81121324 <__muldf3>
811301ac:	900d883a 	mov	r6,r18
811301b0:	180b883a 	mov	r5,r3
811301b4:	880f883a 	mov	r7,r17
811301b8:	1009883a 	mov	r4,r2
811301bc:	11361840 	call	81136184 <__adddf3>
811301c0:	015f2834 	movhi	r5,31904
811301c4:	1025883a 	mov	r18,r2
811301c8:	297fffc4 	addi	r5,r5,-1
811301cc:	189ffc2c 	andhi	r2,r3,32752
811301d0:	2880892e 	bgeu	r5,r2,811303f8 <_strtod_r+0xfa4>
811301d4:	d8801017 	ldw	r2,64(sp)
811301d8:	00dffc34 	movhi	r3,32752
811301dc:	18ffffc4 	addi	r3,r3,-1
811301e0:	10ffb726 	beq	r2,r3,811300c0 <__reset+0xfb1100c0>
811301e4:	045ffc34 	movhi	r17,32752
811301e8:	8c7fffc4 	addi	r17,r17,-1
811301ec:	04bfffc4 	movi	r18,-1
811301f0:	003f4706 	br	8112ff10 <__reset+0xfb10ff10>
811301f4:	00800884 	movi	r2,34
811301f8:	80800015 	stw	r2,0(r16)
811301fc:	002b883a 	mov	r21,zero
81130200:	059ffc34 	movhi	r22,32752
81130204:	003d5d06 	br	8112f77c <__reset+0xfb10f77c>
81130208:	d9000d17 	ldw	r4,52(sp)
8113020c:	b80b883a 	mov	r5,r23
81130210:	11223480 	call	81122348 <__fixdfsi>
81130214:	1009883a 	mov	r4,r2
81130218:	11223c80 	call	811223c8 <__floatsidf>
8113021c:	d9000d17 	ldw	r4,52(sp)
81130220:	b80b883a 	mov	r5,r23
81130224:	100d883a 	mov	r6,r2
81130228:	180f883a 	mov	r7,r3
8113022c:	1121a440 	call	81121a44 <__subdf3>
81130230:	d9400e17 	ldw	r5,56(sp)
81130234:	1039883a 	mov	fp,r2
81130238:	182f883a 	mov	r23,r3
8113023c:	2800141e 	bne	r5,zero,81130290 <_strtod_r+0xe3c>
81130240:	9000131e 	bne	r18,zero,81130290 <_strtod_r+0xe3c>
81130244:	00800434 	movhi	r2,16
81130248:	10bfffc4 	addi	r2,r2,-1
8113024c:	b0ac703a 	and	r22,r22,r2
81130250:	b0000f1e 	bne	r22,zero,81130290 <_strtod_r+0xe3c>
81130254:	01a52834 	movhi	r6,38048
81130258:	01cff434 	movhi	r7,16336
8113025c:	318d6544 	addi	r6,r6,13717
81130260:	39ffffc4 	addi	r7,r7,-1
81130264:	e009883a 	mov	r4,fp
81130268:	180b883a 	mov	r5,r3
8113026c:	11373b00 	call	811373b0 <__ledf2>
81130270:	103f270e 	bge	r2,zero,8112ff10 <__reset+0xfb10ff10>
81130274:	dd000a15 	stw	r20,40(sp)
81130278:	a811883a 	mov	r8,r21
8113027c:	dd001217 	ldw	r20,72(sp)
81130280:	d8800517 	ldw	r2,20(sp)
81130284:	002b883a 	mov	r21,zero
81130288:	882d883a 	mov	r22,r17
8113028c:	003f9706 	br	811300ec <__reset+0xfb1100ec>
81130290:	01a52834 	movhi	r6,38048
81130294:	01cff834 	movhi	r7,16352
81130298:	318d6544 	addi	r6,r6,13717
8113029c:	39ffffc4 	addi	r7,r7,-1
811302a0:	e009883a 	mov	r4,fp
811302a4:	b80b883a 	mov	r5,r23
811302a8:	11373b00 	call	811373b0 <__ledf2>
811302ac:	10000716 	blt	r2,zero,811302cc <_strtod_r+0xe78>
811302b0:	018d6c34 	movhi	r6,13744
811302b4:	31b94d44 	addi	r6,r6,-6859
811302b8:	01cff834 	movhi	r7,16352
811302bc:	e009883a 	mov	r4,fp
811302c0:	b80b883a 	mov	r5,r23
811302c4:	11212480 	call	81121248 <__gedf2>
811302c8:	00bf110e 	bge	zero,r2,8112ff10 <__reset+0xfb10ff10>
811302cc:	dd000a15 	stw	r20,40(sp)
811302d0:	a811883a 	mov	r8,r21
811302d4:	dd001217 	ldw	r20,72(sp)
811302d8:	d8800517 	ldw	r2,20(sp)
811302dc:	902b883a 	mov	r21,r18
811302e0:	882d883a 	mov	r22,r17
811302e4:	003f8106 	br	811300ec <__reset+0xfb1100ec>
811302e8:	b83e2f26 	beq	r23,zero,8112fba8 <__reset+0xfb10fba8>
811302ec:	05efc83a 	sub	r23,zero,r23
811302f0:	b88003cc 	andi	r2,r23,15
811302f4:	10000d26 	beq	r2,zero,8113032c <_strtod_r+0xed8>
811302f8:	100490fa 	slli	r2,r2,3
811302fc:	00e04574 	movhi	r3,33045
81130300:	18c76204 	addi	r3,r3,7560
81130304:	1885883a 	add	r2,r3,r2
81130308:	11800017 	ldw	r6,0(r2)
8113030c:	11c00117 	ldw	r7,4(r2)
81130310:	9009883a 	mov	r4,r18
81130314:	880b883a 	mov	r5,r17
81130318:	da401315 	stw	r9,76(sp)
8113031c:	1136a380 	call	81136a38 <__divdf3>
81130320:	da401317 	ldw	r9,76(sp)
81130324:	1025883a 	mov	r18,r2
81130328:	1823883a 	mov	r17,r3
8113032c:	b82fd13a 	srai	r23,r23,4
81130330:	b83e1d26 	beq	r23,zero,8112fba8 <__reset+0xfb10fba8>
81130334:	008007c4 	movi	r2,31
81130338:	15c02816 	blt	r2,r23,811303dc <_strtod_r+0xf88>
8113033c:	b880040c 	andi	r2,r23,16
81130340:	10019726 	beq	r2,zero,811309a0 <_strtod_r+0x154c>
81130344:	05c1880e 	bge	zero,r23,81130968 <_strtod_r+0x1514>
81130348:	00c01a84 	movi	r3,106
8113034c:	d8c00915 	stw	r3,36(sp)
81130350:	04e04574 	movhi	r19,33045
81130354:	9cc7a204 	addi	r19,r19,7816
81130358:	8807883a 	mov	r3,r17
8113035c:	9005883a 	mov	r2,r18
81130360:	8023883a 	mov	r17,r16
81130364:	0009883a 	mov	r4,zero
81130368:	9821883a 	mov	r16,r19
8113036c:	da400a15 	stw	r9,40(sp)
81130370:	1827883a 	mov	r19,r3
81130374:	b980004c 	andi	r6,r23,1
81130378:	30000626 	beq	r6,zero,81130394 <_strtod_r+0xf40>
8113037c:	81800017 	ldw	r6,0(r16)
81130380:	81c00117 	ldw	r7,4(r16)
81130384:	1009883a 	mov	r4,r2
81130388:	180b883a 	mov	r5,r3
8113038c:	11213240 	call	81121324 <__muldf3>
81130390:	01000044 	movi	r4,1
81130394:	b82fd07a 	srai	r23,r23,1
81130398:	84000204 	addi	r16,r16,8
8113039c:	b83ff51e 	bne	r23,zero,81130374 <__reset+0xfb110374>
811303a0:	21003fcc 	andi	r4,r4,255
811303a4:	8821883a 	mov	r16,r17
811303a8:	da400a17 	ldw	r9,40(sp)
811303ac:	9823883a 	mov	r17,r19
811303b0:	2001a51e 	bne	r4,zero,81130a48 <_strtod_r+0x15f4>
811303b4:	d9000917 	ldw	r4,36(sp)
811303b8:	20016d1e 	bne	r4,zero,81130970 <_strtod_r+0x151c>
811303bc:	000d883a 	mov	r6,zero
811303c0:	000f883a 	mov	r7,zero
811303c4:	9009883a 	mov	r4,r18
811303c8:	880b883a 	mov	r5,r17
811303cc:	da401315 	stw	r9,76(sp)
811303d0:	11373280 	call	81137328 <__eqdf2>
811303d4:	da401317 	ldw	r9,76(sp)
811303d8:	103df41e 	bne	r2,zero,8112fbac <__reset+0xfb10fbac>
811303dc:	00800884 	movi	r2,34
811303e0:	80800015 	stw	r2,0(r16)
811303e4:	002b883a 	mov	r21,zero
811303e8:	002d883a 	mov	r22,zero
811303ec:	003ce306 	br	8112f77c <__reset+0xfb10f77c>
811303f0:	055387c4 	movi	r21,19999
811303f4:	003d6b06 	br	8112f9a4 <__reset+0xfb10f9a4>
811303f8:	0440d434 	movhi	r17,848
811303fc:	1c63883a 	add	r17,r3,r17
81130400:	882d883a 	mov	r22,r17
81130404:	003ebe06 	br	8112ff00 <__reset+0xfb10ff00>
81130408:	14403fcc 	andi	r17,r2,255
8113040c:	8c40201c 	xori	r17,r17,128
81130410:	8c7fe004 	addi	r17,r17,-128
81130414:	dd400817 	ldw	r21,32(sp)
81130418:	0027883a 	mov	r19,zero
8113041c:	0039883a 	mov	fp,zero
81130420:	002d883a 	mov	r22,zero
81130424:	003c9906 	br	8112f68c <__reset+0xfb10f68c>
81130428:	00c00944 	movi	r3,37
8113042c:	1a47c83a 	sub	r3,r3,r9
81130430:	1d7d8c16 	blt	r3,r21,8112fa64 <__reset+0xfb10fa64>
81130434:	1261c83a 	sub	r16,r2,r9
81130438:	800490fa 	slli	r2,r16,3
8113043c:	04e04574 	movhi	r19,33045
81130440:	9cc76204 	addi	r19,r19,7560
81130444:	9885883a 	add	r2,r19,r2
81130448:	11000017 	ldw	r4,0(r2)
8113044c:	11400117 	ldw	r5,4(r2)
81130450:	900d883a 	mov	r6,r18
81130454:	880f883a 	mov	r7,r17
81130458:	11213240 	call	81121324 <__muldf3>
8113045c:	ac0dc83a 	sub	r6,r21,r16
81130460:	300c90fa 	slli	r6,r6,3
81130464:	1009883a 	mov	r4,r2
81130468:	180b883a 	mov	r5,r3
8113046c:	9985883a 	add	r2,r19,r6
81130470:	11800017 	ldw	r6,0(r2)
81130474:	11c00117 	ldw	r7,4(r2)
81130478:	11213240 	call	81121324 <__muldf3>
8113047c:	102b883a 	mov	r21,r2
81130480:	182d883a 	mov	r22,r3
81130484:	003cbd06 	br	8112f77c <__reset+0xfb10f77c>
81130488:	b811883a 	mov	r8,r23
8113048c:	003e8606 	br	8112fea8 <__reset+0xfb10fea8>
81130490:	d8000d15 	stw	zero,52(sp)
81130494:	05cffc34 	movhi	r23,16368
81130498:	003e8006 	br	8112fe9c <__reset+0xfb10fe9c>
8113049c:	883f011e 	bne	r17,zero,811300a4 <__reset+0xfb1100a4>
811304a0:	dd000a15 	stw	r20,40(sp)
811304a4:	dd001217 	ldw	r20,72(sp)
811304a8:	a811883a 	mov	r8,r21
811304ac:	00800884 	movi	r2,34
811304b0:	80800015 	stw	r2,0(r16)
811304b4:	002b883a 	mov	r21,zero
811304b8:	d8800517 	ldw	r2,20(sp)
811304bc:	002d883a 	mov	r22,zero
811304c0:	003f0a06 	br	811300ec <__reset+0xfb1100ec>
811304c4:	d9800517 	ldw	r6,20(sp)
811304c8:	30000826 	beq	r6,zero,811304ec <_strtod_r+0x1098>
811304cc:	01400d44 	movi	r5,53
811304d0:	d9000204 	addi	r4,sp,8
811304d4:	d8801315 	stw	r2,76(sp)
811304d8:	112eae80 	call	8112eae8 <__copybits>
811304dc:	d9400517 	ldw	r5,20(sp)
811304e0:	8009883a 	mov	r4,r16
811304e4:	112dc400 	call	8112dc40 <_Bfree>
811304e8:	d8801317 	ldw	r2,76(sp)
811304ec:	00c00184 	movi	r3,6
811304f0:	1d400f36 	bltu	r3,r21,81130530 <_strtod_r+0x10dc>
811304f4:	a82a90ba 	slli	r21,r21,2
811304f8:	00e044f4 	movhi	r3,33043
811304fc:	18c14304 	addi	r3,r3,1292
81130500:	a8eb883a 	add	r21,r21,r3
81130504:	a8c00017 	ldw	r3,0(r21)
81130508:	1800683a 	jmp	r3
8113050c:	81130588 	cmpgei	r4,r16,19478
81130510:	81130560 	cmpeqi	r4,r16,19477
81130514:	81130544 	addi	r4,r16,19477
81130518:	81130528 	cmpgeui	r4,r16,19476
8113051c:	81130550 	cmplti	r4,r16,19477
81130520:	81130560 	cmpeqi	r4,r16,19477
81130524:	81130588 	cmpgei	r4,r16,19478
81130528:	045ffc34 	movhi	r17,32752
8113052c:	0025883a 	mov	r18,zero
81130530:	1080020c 	andi	r2,r2,8
81130534:	902b883a 	mov	r21,r18
81130538:	103c8f26 	beq	r2,zero,8112f778 <__reset+0xfb10f778>
8113053c:	8da00034 	orhi	r22,r17,32768
81130540:	003c8e06 	br	8112f77c <__reset+0xfb10f77c>
81130544:	dc800217 	ldw	r18,8(sp)
81130548:	dc400317 	ldw	r17,12(sp)
8113054c:	003ff806 	br	81130530 <__reset+0xfb110530>
81130550:	04600034 	movhi	r17,32768
81130554:	8c7fffc4 	addi	r17,r17,-1
81130558:	04bfffc4 	movi	r18,-1
8113055c:	003ff406 	br	81130530 <__reset+0xfb110530>
81130560:	d8c00417 	ldw	r3,16(sp)
81130564:	dc400317 	ldw	r17,12(sp)
81130568:	013ffc34 	movhi	r4,65520
8113056c:	18c10cc4 	addi	r3,r3,1075
81130570:	1806953a 	slli	r3,r3,20
81130574:	213fffc4 	addi	r4,r4,-1
81130578:	8922703a 	and	r17,r17,r4
8113057c:	dc800217 	ldw	r18,8(sp)
81130580:	88e2b03a 	or	r17,r17,r3
81130584:	003fea06 	br	81130530 <__reset+0xfb110530>
81130588:	0023883a 	mov	r17,zero
8113058c:	0025883a 	mov	r18,zero
81130590:	003fe706 	br	81130530 <__reset+0xfb110530>
81130594:	01800044 	movi	r6,1
81130598:	50d5883a 	add	r10,r10,r3
8113059c:	2a4b883a 	add	r5,r5,r9
811305a0:	19811a26 	beq	r3,r6,81130a0c <_strtod_r+0x15b8>
811305a4:	01800204 	movi	r6,8
811305a8:	01c00404 	movi	r7,16
811305ac:	4a400044 	addi	r9,r9,1
811305b0:	48bfffc4 	addi	r2,r9,-1
811305b4:	30801616 	blt	r6,r2,81130610 <_strtod_r+0x11bc>
811305b8:	e70002a4 	muli	fp,fp,10
811305bc:	497ffb1e 	bne	r9,r5,811305ac <__reset+0xfb1105ac>
811305c0:	d9800617 	ldw	r6,24(sp)
811305c4:	4a400044 	addi	r9,r9,1
811305c8:	00c00204 	movi	r3,8
811305cc:	19400c0e 	bge	r3,r5,81130600 <_strtod_r+0x11ac>
811305d0:	00800404 	movi	r2,16
811305d4:	000b883a 	mov	r5,zero
811305d8:	127ea316 	blt	r2,r9,81130068 <__reset+0xfb110068>
811305dc:	988002a4 	muli	r2,r19,10
811305e0:	20a7883a 	add	r19,r4,r2
811305e4:	003ea006 	br	81130068 <__reset+0xfb110068>
811305e8:	d8800617 	ldw	r2,24(sp)
811305ec:	8c7ff404 	addi	r17,r17,-48
811305f0:	2a800044 	addi	r10,r5,1
811305f4:	d8800815 	stw	r2,32(sp)
811305f8:	100d883a 	mov	r6,r2
811305fc:	02400044 	movi	r9,1
81130600:	e08002a4 	muli	r2,fp,10
81130604:	000b883a 	mov	r5,zero
81130608:	88b9883a 	add	fp,r17,r2
8113060c:	003e9606 	br	81130068 <__reset+0xfb110068>
81130610:	3a7fea16 	blt	r7,r9,811305bc <__reset+0xfb1105bc>
81130614:	9cc002a4 	muli	r19,r19,10
81130618:	003fe806 	br	811305bc <__reset+0xfb1105bc>
8113061c:	00bffa84 	movi	r2,-22
81130620:	a8bd1016 	blt	r21,r2,8112fa64 <__reset+0xfb10fa64>
81130624:	a82a90fa 	slli	r21,r21,3
81130628:	00a04574 	movhi	r2,33045
8113062c:	10876204 	addi	r2,r2,7560
81130630:	1545c83a 	sub	r2,r2,r21
81130634:	11800017 	ldw	r6,0(r2)
81130638:	11c00117 	ldw	r7,4(r2)
8113063c:	9009883a 	mov	r4,r18
81130640:	880b883a 	mov	r5,r17
81130644:	1136a380 	call	81136a38 <__divdf3>
81130648:	102b883a 	mov	r21,r2
8113064c:	182d883a 	mov	r22,r3
81130650:	003c4a06 	br	8112f77c <__reset+0xfb10f77c>
81130654:	dd000a15 	stw	r20,40(sp)
81130658:	a811883a 	mov	r8,r21
8113065c:	dd001217 	ldw	r20,72(sp)
81130660:	003e9e06 	br	811300dc <__reset+0xfb1100dc>
81130664:	01604574 	movhi	r5,33045
81130668:	d9000617 	ldw	r4,24(sp)
8113066c:	29479404 	addi	r5,r5,7760
81130670:	01c00644 	movi	r7,25
81130674:	00000b06 	br	811306a4 <_strtod_r+0x1250>
81130678:	21000044 	addi	r4,r4,1
8113067c:	20800003 	ldbu	r2,0(r4)
81130680:	10ffefc4 	addi	r3,r2,-65
81130684:	10803fcc 	andi	r2,r2,255
81130688:	1080201c 	xori	r2,r2,128
8113068c:	18c03fcc 	andi	r3,r3,255
81130690:	10bfe004 	addi	r2,r2,-128
81130694:	38c00136 	bltu	r7,r3,8113069c <_strtod_r+0x1248>
81130698:	10800804 	addi	r2,r2,32
8113069c:	29400044 	addi	r5,r5,1
811306a0:	11bbbb1e 	bne	r2,r6,8112f590 <__reset+0xfb10f590>
811306a4:	29800007 	ldb	r6,0(r5)
811306a8:	303ff31e 	bne	r6,zero,81130678 <__reset+0xfb110678>
811306ac:	01a04574 	movhi	r6,33045
811306b0:	d9000615 	stw	r4,24(sp)
811306b4:	31879504 	addi	r6,r6,7764
811306b8:	200b883a 	mov	r5,r4
811306bc:	02000644 	movi	r8,25
811306c0:	00000a06 	br	811306ec <_strtod_r+0x1298>
811306c4:	28800003 	ldbu	r2,0(r5)
811306c8:	10ffefc4 	addi	r3,r2,-65
811306cc:	10803fcc 	andi	r2,r2,255
811306d0:	1080201c 	xori	r2,r2,128
811306d4:	18c03fcc 	andi	r3,r3,255
811306d8:	10bfe004 	addi	r2,r2,-128
811306dc:	40c00136 	bltu	r8,r3,811306e4 <_strtod_r+0x1290>
811306e0:	10800804 	addi	r2,r2,32
811306e4:	31800044 	addi	r6,r6,1
811306e8:	11c0711e 	bne	r2,r7,811308b0 <_strtod_r+0x145c>
811306ec:	31c00007 	ldb	r7,0(r6)
811306f0:	29400044 	addi	r5,r5,1
811306f4:	383ff31e 	bne	r7,zero,811306c4 <__reset+0xfb1106c4>
811306f8:	d9400615 	stw	r5,24(sp)
811306fc:	045ffc34 	movhi	r17,32752
81130700:	0025883a 	mov	r18,zero
81130704:	003c1b06 	br	8112f774 <__reset+0xfb10f774>
81130708:	000b883a 	mov	r5,zero
8113070c:	003ccc06 	br	8112fa40 <__reset+0xfb10fa40>
81130710:	d9400e17 	ldw	r5,56(sp)
81130714:	dd000a15 	stw	r20,40(sp)
81130718:	00800434 	movhi	r2,16
8113071c:	a811883a 	mov	r8,r21
81130720:	dd001217 	ldw	r20,72(sp)
81130724:	dd401117 	ldw	r21,68(sp)
81130728:	dd801017 	ldw	r22,64(sp)
8113072c:	10bfffc4 	addi	r2,r2,-1
81130730:	28005626 	beq	r5,zero,8113088c <_strtod_r+0x1438>
81130734:	8886703a 	and	r3,r17,r2
81130738:	18807826 	beq	r3,r2,8113091c <_strtod_r+0x14c8>
8113073c:	d8c00b17 	ldw	r3,44(sp)
81130740:	18005726 	beq	r3,zero,811308a0 <_strtod_r+0x144c>
81130744:	1c44703a 	and	r2,r3,r17
81130748:	10000f26 	beq	r2,zero,81130788 <_strtod_r+0x1334>
8113074c:	d9000e17 	ldw	r4,56(sp)
81130750:	d9800917 	ldw	r6,36(sp)
81130754:	20005e26 	beq	r4,zero,811308d0 <_strtod_r+0x147c>
81130758:	9009883a 	mov	r4,r18
8113075c:	880b883a 	mov	r5,r17
81130760:	da001315 	stw	r8,76(sp)
81130764:	112f3e80 	call	8112f3e8 <sulp>
81130768:	100d883a 	mov	r6,r2
8113076c:	180f883a 	mov	r7,r3
81130770:	9009883a 	mov	r4,r18
81130774:	880b883a 	mov	r5,r17
81130778:	11361840 	call	81136184 <__adddf3>
8113077c:	da001317 	ldw	r8,76(sp)
81130780:	102b883a 	mov	r21,r2
81130784:	182d883a 	mov	r22,r3
81130788:	d8c00917 	ldw	r3,36(sp)
8113078c:	18000f26 	beq	r3,zero,811307cc <_strtod_r+0x1378>
81130790:	a809883a 	mov	r4,r21
81130794:	b00b883a 	mov	r5,r22
81130798:	000d883a 	mov	r6,zero
8113079c:	01ce5434 	movhi	r7,14672
811307a0:	da001315 	stw	r8,76(sp)
811307a4:	11213240 	call	81121324 <__muldf3>
811307a8:	102b883a 	mov	r21,r2
811307ac:	182d883a 	mov	r22,r3
811307b0:	da001317 	ldw	r8,76(sp)
811307b4:	1800051e 	bne	r3,zero,811307cc <_strtod_r+0x1378>
811307b8:	d8800517 	ldw	r2,20(sp)
811307bc:	a83e4b1e 	bne	r21,zero,811300ec <__reset+0xfb1100ec>
811307c0:	00c00884 	movi	r3,34
811307c4:	80c00015 	stw	r3,0(r16)
811307c8:	003e4806 	br	811300ec <__reset+0xfb1100ec>
811307cc:	d8800517 	ldw	r2,20(sp)
811307d0:	003e4606 	br	811300ec <__reset+0xfb1100ec>
811307d4:	d9000e17 	ldw	r4,56(sp)
811307d8:	dd000a15 	stw	r20,40(sp)
811307dc:	a811883a 	mov	r8,r21
811307e0:	dd001217 	ldw	r20,72(sp)
811307e4:	dd401117 	ldw	r21,68(sp)
811307e8:	dd801017 	ldw	r22,64(sp)
811307ec:	203fe61e 	bne	r4,zero,81130788 <__reset+0xfb110788>
811307f0:	903fe51e 	bne	r18,zero,81130788 <__reset+0xfb110788>
811307f4:	00800434 	movhi	r2,16
811307f8:	10bfffc4 	addi	r2,r2,-1
811307fc:	8884703a 	and	r2,r17,r2
81130800:	103fe11e 	bne	r2,zero,81130788 <__reset+0xfb110788>
81130804:	8ddffc2c 	andhi	r23,r17,32752
81130808:	0081ac34 	movhi	r2,1712
8113080c:	15ffde2e 	bgeu	r2,r23,81130788 <__reset+0xfb110788>
81130810:	40800517 	ldw	r2,20(r8)
81130814:	1000031e 	bne	r2,zero,81130824 <_strtod_r+0x13d0>
81130818:	40800417 	ldw	r2,16(r8)
8113081c:	00c00044 	movi	r3,1
81130820:	18bfd90e 	bge	r3,r2,81130788 <__reset+0xfb110788>
81130824:	400b883a 	mov	r5,r8
81130828:	01800044 	movi	r6,1
8113082c:	8009883a 	mov	r4,r16
81130830:	112e3400 	call	8112e340 <__lshift>
81130834:	980b883a 	mov	r5,r19
81130838:	1009883a 	mov	r4,r2
8113083c:	d8801315 	stw	r2,76(sp)
81130840:	112e4900 	call	8112e490 <__mcmp>
81130844:	da001317 	ldw	r8,76(sp)
81130848:	00bfcf0e 	bge	zero,r2,81130788 <__reset+0xfb110788>
8113084c:	d8c00917 	ldw	r3,36(sp)
81130850:	18005c26 	beq	r3,zero,811309c4 <_strtod_r+0x1570>
81130854:	0081ac34 	movhi	r2,1712
81130858:	15c05a16 	blt	r2,r23,811309c4 <_strtod_r+0x1570>
8113085c:	0080dc34 	movhi	r2,880
81130860:	15ffcb16 	blt	r2,r23,81130790 <__reset+0xfb110790>
81130864:	003f1106 	br	811304ac <__reset+0xfb1104ac>
81130868:	002d883a 	mov	r22,zero
8113086c:	022ff834 	movhi	r8,49120
81130870:	d8000d15 	stw	zero,52(sp)
81130874:	05cff834 	movhi	r23,16352
81130878:	003ded06 	br	81130030 <__reset+0xfb110030>
8113087c:	0440d434 	movhi	r17,848
81130880:	1c63883a 	add	r17,r3,r17
81130884:	d8000915 	stw	zero,36(sp)
81130888:	003cc806 	br	8112fbac <__reset+0xfb10fbac>
8113088c:	8884703a 	and	r2,r17,r2
81130890:	103faa1e 	bne	r2,zero,8113073c <__reset+0xfb11073c>
81130894:	903fa91e 	bne	r18,zero,8113073c <__reset+0xfb11073c>
81130898:	8ddffc2c 	andhi	r23,r17,32752
8113089c:	003feb06 	br	8113084c <__reset+0xfb11084c>
811308a0:	d8c00d17 	ldw	r3,52(sp)
811308a4:	1cae703a 	and	r23,r3,r18
811308a8:	b83fb726 	beq	r23,zero,81130788 <__reset+0xfb110788>
811308ac:	003fa706 	br	8113074c <__reset+0xfb11074c>
811308b0:	21000044 	addi	r4,r4,1
811308b4:	d9000615 	stw	r4,24(sp)
811308b8:	003f9006 	br	811306fc <__reset+0xfb1106fc>
811308bc:	01604574 	movhi	r5,33045
811308c0:	29475804 	addi	r5,r5,7520
811308c4:	d9400915 	stw	r5,36(sp)
811308c8:	0027883a 	mov	r19,zero
811308cc:	003ca206 	br	8112fb58 <__reset+0xfb10fb58>
811308d0:	9009883a 	mov	r4,r18
811308d4:	880b883a 	mov	r5,r17
811308d8:	da001315 	stw	r8,76(sp)
811308dc:	112f3e80 	call	8112f3e8 <sulp>
811308e0:	100d883a 	mov	r6,r2
811308e4:	180f883a 	mov	r7,r3
811308e8:	9009883a 	mov	r4,r18
811308ec:	880b883a 	mov	r5,r17
811308f0:	1121a440 	call	81121a44 <__subdf3>
811308f4:	000d883a 	mov	r6,zero
811308f8:	000f883a 	mov	r7,zero
811308fc:	1009883a 	mov	r4,r2
81130900:	180b883a 	mov	r5,r3
81130904:	102b883a 	mov	r21,r2
81130908:	182d883a 	mov	r22,r3
8113090c:	11373280 	call	81137328 <__eqdf2>
81130910:	da001317 	ldw	r8,76(sp)
81130914:	103ee526 	beq	r2,zero,811304ac <__reset+0xfb1104ac>
81130918:	003f9b06 	br	81130788 <__reset+0xfb110788>
8113091c:	d8800917 	ldw	r2,36(sp)
81130920:	10002226 	beq	r2,zero,811309ac <_strtod_r+0x1558>
81130924:	889ffc2c 	andhi	r2,r17,32752
81130928:	00c1a834 	movhi	r3,1696
8113092c:	18801f36 	bltu	r3,r2,811309ac <_strtod_r+0x1558>
81130930:	1004d53a 	srli	r2,r2,20
81130934:	00c01ac4 	movi	r3,107
81130938:	1887c83a 	sub	r3,r3,r2
8113093c:	00bfffc4 	movi	r2,-1
81130940:	10c4983a 	sll	r2,r2,r3
81130944:	14bf7d1e 	bne	r2,r18,8113073c <__reset+0xfb11073c>
81130948:	00dffc34 	movhi	r3,32752
8113094c:	18ffffc4 	addi	r3,r3,-1
81130950:	88c03526 	beq	r17,r3,81130a28 <_strtod_r+0x15d4>
81130954:	8c5ffc2c 	andhi	r17,r17,32752
81130958:	00800434 	movhi	r2,16
8113095c:	002b883a 	mov	r21,zero
81130960:	88ad883a 	add	r22,r17,r2
81130964:	003f8806 	br	81130788 <__reset+0xfb110788>
81130968:	01401a84 	movi	r5,106
8113096c:	d9400915 	stw	r5,36(sp)
81130970:	8ddffc2c 	andhi	r23,r17,32752
81130974:	b82ed53a 	srli	r23,r23,20
81130978:	00801ac4 	movi	r2,107
8113097c:	15c5c83a 	sub	r2,r2,r23
81130980:	00be8e0e 	bge	zero,r2,811303bc <__reset+0xfb1103bc>
81130984:	00c007c4 	movi	r3,31
81130988:	18800a0e 	bge	r3,r2,811309b4 <_strtod_r+0x1560>
8113098c:	00c00d04 	movi	r3,52
81130990:	0025883a 	mov	r18,zero
81130994:	1880270e 	bge	r3,r2,81130a34 <_strtod_r+0x15e0>
81130998:	0440dc34 	movhi	r17,880
8113099c:	003e8706 	br	811303bc <__reset+0xfb1103bc>
811309a0:	d8000915 	stw	zero,36(sp)
811309a4:	05fe6a16 	blt	zero,r23,81130350 <__reset+0xfb110350>
811309a8:	003e8406 	br	811303bc <__reset+0xfb1103bc>
811309ac:	00bfffc4 	movi	r2,-1
811309b0:	003fe406 	br	81130944 <__reset+0xfb110944>
811309b4:	00ffffc4 	movi	r3,-1
811309b8:	1884983a 	sll	r2,r3,r2
811309bc:	14a4703a 	and	r18,r2,r18
811309c0:	003e7e06 	br	811303bc <__reset+0xfb1103bc>
811309c4:	00bffc34 	movhi	r2,65520
811309c8:	b8af883a 	add	r23,r23,r2
811309cc:	057fffc4 	movi	r21,-1
811309d0:	00800434 	movhi	r2,16
811309d4:	1545883a 	add	r2,r2,r21
811309d8:	b8acb03a 	or	r22,r23,r2
811309dc:	003f6a06 	br	81130788 <__reset+0xfb110788>
811309e0:	01604574 	movhi	r5,33045
811309e4:	29479804 	addi	r5,r5,7776
811309e8:	d9800204 	addi	r6,sp,8
811309ec:	d9000604 	addi	r4,sp,24
811309f0:	1134de00 	call	81134de0 <__hexnan>
811309f4:	00c00144 	movi	r3,5
811309f8:	10fb5c1e 	bne	r2,r3,8112f76c <__reset+0xfb10f76c>
811309fc:	dc400317 	ldw	r17,12(sp)
81130a00:	dc800217 	ldw	r18,8(sp)
81130a04:	8c5ffc34 	orhi	r17,r17,32752
81130a08:	003b5a06 	br	8112f774 <__reset+0xfb10f774>
81130a0c:	480b883a 	mov	r5,r9
81130a10:	d9800617 	ldw	r6,24(sp)
81130a14:	4a400044 	addi	r9,r9,1
81130a18:	003eeb06 	br	811305c8 <__reset+0xfb1105c8>
81130a1c:	1025883a 	mov	r18,r2
81130a20:	1823883a 	mov	r17,r3
81130a24:	003c4c06 	br	8112fb58 <__reset+0xfb10fb58>
81130a28:	00ffffc4 	movi	r3,-1
81130a2c:	10ffc91e 	bne	r2,r3,81130954 <__reset+0xfb110954>
81130a30:	003da906 	br	811300d8 <__reset+0xfb1100d8>
81130a34:	10bff804 	addi	r2,r2,-32
81130a38:	00ffffc4 	movi	r3,-1
81130a3c:	1884983a 	sll	r2,r3,r2
81130a40:	1462703a 	and	r17,r2,r17
81130a44:	003e5d06 	br	811303bc <__reset+0xfb1103bc>
81130a48:	1025883a 	mov	r18,r2
81130a4c:	1823883a 	mov	r17,r3
81130a50:	003e5806 	br	811303b4 <__reset+0xfb1103b4>

81130a54 <strtod>:
81130a54:	00a04574 	movhi	r2,33045
81130a58:	1090f104 	addi	r2,r2,17348
81130a5c:	280d883a 	mov	r6,r5
81130a60:	200b883a 	mov	r5,r4
81130a64:	11000017 	ldw	r4,0(r2)
81130a68:	112f4541 	jmpi	8112f454 <_strtod_r>

81130a6c <strtof>:
81130a6c:	defffb04 	addi	sp,sp,-20
81130a70:	de00012e 	bgeu	sp,et,81130a78 <strtof+0xc>
81130a74:	003b68fa 	trap	3
81130a78:	dcc00315 	stw	r19,12(sp)
81130a7c:	04e04574 	movhi	r19,33045
81130a80:	9cd0f104 	addi	r19,r19,17348
81130a84:	280d883a 	mov	r6,r5
81130a88:	200b883a 	mov	r5,r4
81130a8c:	99000017 	ldw	r4,0(r19)
81130a90:	dfc00415 	stw	ra,16(sp)
81130a94:	dc800215 	stw	r18,8(sp)
81130a98:	dc400115 	stw	r17,4(sp)
81130a9c:	dc000015 	stw	r16,0(sp)
81130aa0:	112f4540 	call	8112f454 <_strtod_r>
81130aa4:	1009883a 	mov	r4,r2
81130aa8:	180b883a 	mov	r5,r3
81130aac:	1025883a 	mov	r18,r2
81130ab0:	1823883a 	mov	r17,r3
81130ab4:	11225c40 	call	811225c4 <__truncdfsf2>
81130ab8:	000b883a 	mov	r5,zero
81130abc:	1009883a 	mov	r4,r2
81130ac0:	1021883a 	mov	r16,r2
81130ac4:	1135f880 	call	81135f88 <__eqsf2>
81130ac8:	1000111e 	bne	r2,zero,81130b10 <strtof+0xa4>
81130acc:	000d883a 	mov	r6,zero
81130ad0:	000f883a 	mov	r7,zero
81130ad4:	9009883a 	mov	r4,r18
81130ad8:	880b883a 	mov	r5,r17
81130adc:	11373280 	call	81137328 <__eqdf2>
81130ae0:	10000b26 	beq	r2,zero,81130b10 <strtof+0xa4>
81130ae4:	98800017 	ldw	r2,0(r19)
81130ae8:	00c00884 	movi	r3,34
81130aec:	10c00015 	stw	r3,0(r2)
81130af0:	8005883a 	mov	r2,r16
81130af4:	dfc00417 	ldw	ra,16(sp)
81130af8:	dcc00317 	ldw	r19,12(sp)
81130afc:	dc800217 	ldw	r18,8(sp)
81130b00:	dc400117 	ldw	r17,4(sp)
81130b04:	dc000017 	ldw	r16,0(sp)
81130b08:	dec00504 	addi	sp,sp,20
81130b0c:	f800283a 	ret
81130b10:	015fe034 	movhi	r5,32640
81130b14:	297fffc4 	addi	r5,r5,-1
81130b18:	8009883a 	mov	r4,r16
81130b1c:	11360000 	call	81136000 <__gesf2>
81130b20:	0080070e 	bge	zero,r2,81130b40 <strtof+0xd4>
81130b24:	01dffc34 	movhi	r7,32752
81130b28:	39ffffc4 	addi	r7,r7,-1
81130b2c:	01bfffc4 	movi	r6,-1
81130b30:	9009883a 	mov	r4,r18
81130b34:	880b883a 	mov	r5,r17
81130b38:	11212480 	call	81121248 <__gedf2>
81130b3c:	00bfe90e 	bge	zero,r2,81130ae4 <__reset+0xfb110ae4>
81130b40:	017fe034 	movhi	r5,65408
81130b44:	297fffc4 	addi	r5,r5,-1
81130b48:	8009883a 	mov	r4,r16
81130b4c:	11360bc0 	call	811360bc <__lesf2>
81130b50:	103fe70e 	bge	r2,zero,81130af0 <__reset+0xfb110af0>
81130b54:	01fffc34 	movhi	r7,65520
81130b58:	39ffffc4 	addi	r7,r7,-1
81130b5c:	01bfffc4 	movi	r6,-1
81130b60:	9009883a 	mov	r4,r18
81130b64:	880b883a 	mov	r5,r17
81130b68:	11373b00 	call	811373b0 <__ledf2>
81130b6c:	103fdd0e 	bge	r2,zero,81130ae4 <__reset+0xfb110ae4>
81130b70:	003fdf06 	br	81130af0 <__reset+0xfb110af0>

81130b74 <_strtoll_r>:
81130b74:	00a04574 	movhi	r2,33045
81130b78:	defff304 	addi	sp,sp,-52
81130b7c:	1090ef04 	addi	r2,r2,17340
81130b80:	de00012e 	bgeu	sp,et,81130b88 <_strtoll_r+0x14>
81130b84:	003b68fa 	trap	3
81130b88:	dc800515 	stw	r18,20(sp)
81130b8c:	14800017 	ldw	r18,0(r2)
81130b90:	dd800915 	stw	r22,36(sp)
81130b94:	dd400815 	stw	r21,32(sp)
81130b98:	dcc00615 	stw	r19,24(sp)
81130b9c:	d9000015 	stw	r4,0(sp)
81130ba0:	dfc00c15 	stw	ra,48(sp)
81130ba4:	df000b15 	stw	fp,44(sp)
81130ba8:	ddc00a15 	stw	r23,40(sp)
81130bac:	dd000715 	stw	r20,28(sp)
81130bb0:	dc400415 	stw	r17,16(sp)
81130bb4:	dc000315 	stw	r16,12(sp)
81130bb8:	282d883a 	mov	r22,r5
81130bbc:	302b883a 	mov	r21,r6
81130bc0:	3827883a 	mov	r19,r7
81130bc4:	2809883a 	mov	r4,r5
81130bc8:	24000003 	ldbu	r16,0(r4)
81130bcc:	24400044 	addi	r17,r4,1
81130bd0:	2007883a 	mov	r3,r4
81130bd4:	9405883a 	add	r2,r18,r16
81130bd8:	10800043 	ldbu	r2,1(r2)
81130bdc:	8809883a 	mov	r4,r17
81130be0:	1080020c 	andi	r2,r2,8
81130be4:	103ff81e 	bne	r2,zero,81130bc8 <__reset+0xfb110bc8>
81130be8:	00800b44 	movi	r2,45
81130bec:	80807826 	beq	r16,r2,81130dd0 <_strtoll_r+0x25c>
81130bf0:	00800ac4 	movi	r2,43
81130bf4:	80807a26 	beq	r16,r2,81130de0 <_strtoll_r+0x26c>
81130bf8:	0039883a 	mov	fp,zero
81130bfc:	98004e26 	beq	r19,zero,81130d38 <_strtoll_r+0x1c4>
81130c00:	00800404 	movi	r2,16
81130c04:	98808226 	beq	r19,r2,81130e10 <_strtoll_r+0x29c>
81130c08:	982fd7fa 	srai	r23,r19,31
81130c0c:	9829883a 	mov	r20,r19
81130c10:	e0004f26 	beq	fp,zero,81130d50 <_strtoll_r+0x1dc>
81130c14:	0017883a 	mov	r11,zero
81130c18:	02a00034 	movhi	r10,32768
81130c1c:	5809883a 	mov	r4,r11
81130c20:	500b883a 	mov	r5,r10
81130c24:	a00d883a 	mov	r6,r20
81130c28:	b80f883a 	mov	r7,r23
81130c2c:	da800215 	stw	r10,8(sp)
81130c30:	dac00115 	stw	r11,4(sp)
81130c34:	11358940 	call	81135894 <__umoddi3>
81130c38:	dac00117 	ldw	r11,4(sp)
81130c3c:	da800217 	ldw	r10,8(sp)
81130c40:	a00d883a 	mov	r6,r20
81130c44:	5809883a 	mov	r4,r11
81130c48:	500b883a 	mov	r5,r10
81130c4c:	b80f883a 	mov	r7,r23
81130c50:	d8800115 	stw	r2,4(sp)
81130c54:	11353140 	call	81135314 <__udivdi3>
81130c58:	9409883a 	add	r4,r18,r16
81130c5c:	21000043 	ldbu	r4,1(r4)
81130c60:	1019883a 	mov	r12,r2
81130c64:	880b883a 	mov	r5,r17
81130c68:	2240010c 	andi	r9,r4,4
81130c6c:	0015883a 	mov	r10,zero
81130c70:	000d883a 	mov	r6,zero
81130c74:	000f883a 	mov	r7,zero
81130c78:	03400044 	movi	r13,1
81130c7c:	02ffffc4 	movi	r11,-1
81130c80:	da000117 	ldw	r8,4(sp)
81130c84:	48000d26 	beq	r9,zero,81130cbc <_strtoll_r+0x148>
81130c88:	843ff404 	addi	r16,r16,-48
81130c8c:	84c0110e 	bge	r16,r19,81130cd4 <_strtoll_r+0x160>
81130c90:	52c00426 	beq	r10,r11,81130ca4 <_strtoll_r+0x130>
81130c94:	19c00236 	bltu	r3,r7,81130ca0 <_strtoll_r+0x12c>
81130c98:	38c0311e 	bne	r7,r3,81130d60 <_strtoll_r+0x1ec>
81130c9c:	6180302e 	bgeu	r12,r6,81130d60 <_strtoll_r+0x1ec>
81130ca0:	02bfffc4 	movi	r10,-1
81130ca4:	2c000003 	ldbu	r16,0(r5)
81130ca8:	29400044 	addi	r5,r5,1
81130cac:	9409883a 	add	r4,r18,r16
81130cb0:	21000043 	ldbu	r4,1(r4)
81130cb4:	2240010c 	andi	r9,r4,4
81130cb8:	483ff31e 	bne	r9,zero,81130c88 <__reset+0xfb110c88>
81130cbc:	210000cc 	andi	r4,r4,3
81130cc0:	20000426 	beq	r4,zero,81130cd4 <_strtoll_r+0x160>
81130cc4:	23403426 	beq	r4,r13,81130d98 <_strtoll_r+0x224>
81130cc8:	008015c4 	movi	r2,87
81130ccc:	80a1c83a 	sub	r16,r16,r2
81130cd0:	84ffef16 	blt	r16,r19,81130c90 <__reset+0xfb110c90>
81130cd4:	00bfffc4 	movi	r2,-1
81130cd8:	50803426 	beq	r10,r2,81130dac <_strtoll_r+0x238>
81130cdc:	e0000426 	beq	fp,zero,81130cf0 <_strtoll_r+0x17c>
81130ce0:	018dc83a 	sub	r6,zero,r6
81130ce4:	3004c03a 	cmpne	r2,r6,zero
81130ce8:	01e1c83a 	sub	r16,zero,r7
81130cec:	808fc83a 	sub	r7,r16,r2
81130cf0:	3005883a 	mov	r2,r6
81130cf4:	3807883a 	mov	r3,r7
81130cf8:	a8000326 	beq	r21,zero,81130d08 <_strtoll_r+0x194>
81130cfc:	5000321e 	bne	r10,zero,81130dc8 <_strtoll_r+0x254>
81130d00:	b00b883a 	mov	r5,r22
81130d04:	a9400015 	stw	r5,0(r21)
81130d08:	dfc00c17 	ldw	ra,48(sp)
81130d0c:	df000b17 	ldw	fp,44(sp)
81130d10:	ddc00a17 	ldw	r23,40(sp)
81130d14:	dd800917 	ldw	r22,36(sp)
81130d18:	dd400817 	ldw	r21,32(sp)
81130d1c:	dd000717 	ldw	r20,28(sp)
81130d20:	dcc00617 	ldw	r19,24(sp)
81130d24:	dc800517 	ldw	r18,20(sp)
81130d28:	dc400417 	ldw	r17,16(sp)
81130d2c:	dc000317 	ldw	r16,12(sp)
81130d30:	dec00d04 	addi	sp,sp,52
81130d34:	f800283a 	ret
81130d38:	00800c04 	movi	r2,48
81130d3c:	80802c26 	beq	r16,r2,81130df0 <_strtoll_r+0x27c>
81130d40:	05000284 	movi	r20,10
81130d44:	002f883a 	mov	r23,zero
81130d48:	a027883a 	mov	r19,r20
81130d4c:	e03fb11e 	bne	fp,zero,81130c14 <__reset+0xfb110c14>
81130d50:	02a00034 	movhi	r10,32768
81130d54:	52bfffc4 	addi	r10,r10,-1
81130d58:	02ffffc4 	movi	r11,-1
81130d5c:	003faf06 	br	81130c1c <__reset+0xfb110c1c>
81130d60:	33000f26 	beq	r6,r12,81130da0 <_strtoll_r+0x22c>
81130d64:	b985383a 	mul	r2,r23,r6
81130d68:	3d0f383a 	mul	r7,r7,r20
81130d6c:	3508383a 	mulxuu	r4,r6,r20
81130d70:	350d383a 	mul	r6,r6,r20
81130d74:	8013d7fa 	srai	r9,r16,31
81130d78:	388f883a 	add	r7,r7,r2
81130d7c:	818d883a 	add	r6,r16,r6
81130d80:	390f883a 	add	r7,r7,r4
81130d84:	3421803a 	cmpltu	r16,r6,r16
81130d88:	49cf883a 	add	r7,r9,r7
81130d8c:	81cf883a 	add	r7,r16,r7
81130d90:	02800044 	movi	r10,1
81130d94:	003fc306 	br	81130ca4 <__reset+0xfb110ca4>
81130d98:	00800dc4 	movi	r2,55
81130d9c:	003fcb06 	br	81130ccc <__reset+0xfb110ccc>
81130da0:	38fff01e 	bne	r7,r3,81130d64 <__reset+0xfb110d64>
81130da4:	443fbe16 	blt	r8,r16,81130ca0 <__reset+0xfb110ca0>
81130da8:	003fee06 	br	81130d64 <__reset+0xfb110d64>
81130dac:	e0002426 	beq	fp,zero,81130e40 <_strtoll_r+0x2cc>
81130db0:	0005883a 	mov	r2,zero
81130db4:	00e00034 	movhi	r3,32768
81130db8:	d9800017 	ldw	r6,0(sp)
81130dbc:	01000884 	movi	r4,34
81130dc0:	31000015 	stw	r4,0(r6)
81130dc4:	a83fd026 	beq	r21,zero,81130d08 <__reset+0xfb110d08>
81130dc8:	297fffc4 	addi	r5,r5,-1
81130dcc:	003fcd06 	br	81130d04 <__reset+0xfb110d04>
81130dd0:	1c400084 	addi	r17,r3,2
81130dd4:	1c000043 	ldbu	r16,1(r3)
81130dd8:	07000044 	movi	fp,1
81130ddc:	003f8706 	br	81130bfc <__reset+0xfb110bfc>
81130de0:	1c400084 	addi	r17,r3,2
81130de4:	1c000043 	ldbu	r16,1(r3)
81130de8:	0039883a 	mov	fp,zero
81130dec:	003f8306 	br	81130bfc <__reset+0xfb110bfc>
81130df0:	88800003 	ldbu	r2,0(r17)
81130df4:	00c01604 	movi	r3,88
81130df8:	108037cc 	andi	r2,r2,223
81130dfc:	10c00a26 	beq	r2,r3,81130e28 <_strtoll_r+0x2b4>
81130e00:	05000204 	movi	r20,8
81130e04:	002f883a 	mov	r23,zero
81130e08:	a027883a 	mov	r19,r20
81130e0c:	003f8006 	br	81130c10 <__reset+0xfb110c10>
81130e10:	00800c04 	movi	r2,48
81130e14:	80800e1e 	bne	r16,r2,81130e50 <_strtoll_r+0x2dc>
81130e18:	88800003 	ldbu	r2,0(r17)
81130e1c:	00c01604 	movi	r3,88
81130e20:	108037cc 	andi	r2,r2,223
81130e24:	10c00a1e 	bne	r2,r3,81130e50 <_strtoll_r+0x2dc>
81130e28:	05000404 	movi	r20,16
81130e2c:	8c000043 	ldbu	r16,1(r17)
81130e30:	002f883a 	mov	r23,zero
81130e34:	8c400084 	addi	r17,r17,2
81130e38:	a027883a 	mov	r19,r20
81130e3c:	003f7406 	br	81130c10 <__reset+0xfb110c10>
81130e40:	00e00034 	movhi	r3,32768
81130e44:	18ffffc4 	addi	r3,r3,-1
81130e48:	5005883a 	mov	r2,r10
81130e4c:	003fda06 	br	81130db8 <__reset+0xfb110db8>
81130e50:	9829883a 	mov	r20,r19
81130e54:	002f883a 	mov	r23,zero
81130e58:	003f6d06 	br	81130c10 <__reset+0xfb110c10>

81130e5c <_strtoul_r>:
81130e5c:	00a04574 	movhi	r2,33045
81130e60:	defff604 	addi	sp,sp,-40
81130e64:	1090ef04 	addi	r2,r2,17340
81130e68:	de00012e 	bgeu	sp,et,81130e70 <_strtoul_r+0x14>
81130e6c:	003b68fa 	trap	3
81130e70:	dc800315 	stw	r18,12(sp)
81130e74:	14800017 	ldw	r18,0(r2)
81130e78:	dd400615 	stw	r21,24(sp)
81130e7c:	dd000515 	stw	r20,20(sp)
81130e80:	dcc00415 	stw	r19,16(sp)
81130e84:	2029883a 	mov	r20,r4
81130e88:	dfc00915 	stw	ra,36(sp)
81130e8c:	ddc00815 	stw	r23,32(sp)
81130e90:	dd800715 	stw	r22,28(sp)
81130e94:	dc400215 	stw	r17,8(sp)
81130e98:	dc000115 	stw	r16,4(sp)
81130e9c:	2827883a 	mov	r19,r5
81130ea0:	382b883a 	mov	r21,r7
81130ea4:	2809883a 	mov	r4,r5
81130ea8:	24000003 	ldbu	r16,0(r4)
81130eac:	24400044 	addi	r17,r4,1
81130eb0:	2007883a 	mov	r3,r4
81130eb4:	9405883a 	add	r2,r18,r16
81130eb8:	10800043 	ldbu	r2,1(r2)
81130ebc:	8809883a 	mov	r4,r17
81130ec0:	1080020c 	andi	r2,r2,8
81130ec4:	103ff81e 	bne	r2,zero,81130ea8 <__reset+0xfb110ea8>
81130ec8:	00800b44 	movi	r2,45
81130ecc:	80805326 	beq	r16,r2,8113101c <_strtoul_r+0x1c0>
81130ed0:	00800ac4 	movi	r2,43
81130ed4:	80805526 	beq	r16,r2,8113102c <_strtoul_r+0x1d0>
81130ed8:	002f883a 	mov	r23,zero
81130edc:	a8000f26 	beq	r21,zero,81130f1c <_strtoul_r+0xc0>
81130ee0:	00800404 	movi	r2,16
81130ee4:	a8805f26 	beq	r21,r2,81131064 <_strtoul_r+0x208>
81130ee8:	013fffc4 	movi	r4,-1
81130eec:	a80b883a 	mov	r5,r21
81130ef0:	d9800015 	stw	r6,0(sp)
81130ef4:	1135ecc0 	call	81135ecc <__udivsi3>
81130ef8:	a80b883a 	mov	r5,r21
81130efc:	013fffc4 	movi	r4,-1
81130f00:	102d883a 	mov	r22,r2
81130f04:	1135f300 	call	81135f30 <__umodsi3>
81130f08:	d9800017 	ldw	r6,0(sp)
81130f0c:	1019883a 	mov	r12,r2
81130f10:	a817883a 	mov	r11,r21
81130f14:	b00f883a 	mov	r7,r22
81130f18:	00000706 	br	81130f38 <_strtoul_r+0xdc>
81130f1c:	00800c04 	movi	r2,48
81130f20:	80804626 	beq	r16,r2,8113103c <_strtoul_r+0x1e0>
81130f24:	05400284 	movi	r21,10
81130f28:	01c666b4 	movhi	r7,6554
81130f2c:	03000144 	movi	r12,5
81130f30:	39e66644 	addi	r7,r7,-26215
81130f34:	a817883a 	mov	r11,r21
81130f38:	9407883a 	add	r3,r18,r16
81130f3c:	18c00043 	ldbu	r3,1(r3)
81130f40:	8809883a 	mov	r4,r17
81130f44:	0011883a 	mov	r8,zero
81130f48:	1940010c 	andi	r5,r3,4
81130f4c:	0005883a 	mov	r2,zero
81130f50:	02800044 	movi	r10,1
81130f54:	027fffc4 	movi	r9,-1
81130f58:	28000e26 	beq	r5,zero,81130f94 <_strtoul_r+0x138>
81130f5c:	843ff404 	addi	r16,r16,-48
81130f60:	8540120e 	bge	r16,r21,81130fac <_strtoul_r+0x150>
81130f64:	42400526 	beq	r8,r9,81130f7c <_strtoul_r+0x120>
81130f68:	38802236 	bltu	r7,r2,81130ff4 <_strtoul_r+0x198>
81130f6c:	11c02026 	beq	r2,r7,81130ff0 <_strtoul_r+0x194>
81130f70:	12c5383a 	mul	r2,r2,r11
81130f74:	02000044 	movi	r8,1
81130f78:	8085883a 	add	r2,r16,r2
81130f7c:	24000003 	ldbu	r16,0(r4)
81130f80:	21000044 	addi	r4,r4,1
81130f84:	9407883a 	add	r3,r18,r16
81130f88:	18c00043 	ldbu	r3,1(r3)
81130f8c:	1940010c 	andi	r5,r3,4
81130f90:	283ff21e 	bne	r5,zero,81130f5c <__reset+0xfb110f5c>
81130f94:	18c000cc 	andi	r3,r3,3
81130f98:	18000426 	beq	r3,zero,81130fac <_strtoul_r+0x150>
81130f9c:	1a801726 	beq	r3,r10,81130ffc <_strtoul_r+0x1a0>
81130fa0:	00c015c4 	movi	r3,87
81130fa4:	80e1c83a 	sub	r16,r16,r3
81130fa8:	857fee16 	blt	r16,r21,81130f64 <__reset+0xfb110f64>
81130fac:	40001516 	blt	r8,zero,81131004 <_strtoul_r+0x1a8>
81130fb0:	b8000126 	beq	r23,zero,81130fb8 <_strtoul_r+0x15c>
81130fb4:	0085c83a 	sub	r2,zero,r2
81130fb8:	30000226 	beq	r6,zero,81130fc4 <_strtoul_r+0x168>
81130fbc:	4000151e 	bne	r8,zero,81131014 <_strtoul_r+0x1b8>
81130fc0:	34c00015 	stw	r19,0(r6)
81130fc4:	dfc00917 	ldw	ra,36(sp)
81130fc8:	ddc00817 	ldw	r23,32(sp)
81130fcc:	dd800717 	ldw	r22,28(sp)
81130fd0:	dd400617 	ldw	r21,24(sp)
81130fd4:	dd000517 	ldw	r20,20(sp)
81130fd8:	dcc00417 	ldw	r19,16(sp)
81130fdc:	dc800317 	ldw	r18,12(sp)
81130fe0:	dc400217 	ldw	r17,8(sp)
81130fe4:	dc000117 	ldw	r16,4(sp)
81130fe8:	dec00a04 	addi	sp,sp,40
81130fec:	f800283a 	ret
81130ff0:	643fdf0e 	bge	r12,r16,81130f70 <__reset+0xfb110f70>
81130ff4:	023fffc4 	movi	r8,-1
81130ff8:	003fe006 	br	81130f7c <__reset+0xfb110f7c>
81130ffc:	00c00dc4 	movi	r3,55
81131000:	003fe806 	br	81130fa4 <__reset+0xfb110fa4>
81131004:	00800884 	movi	r2,34
81131008:	a0800015 	stw	r2,0(r20)
8113100c:	00bfffc4 	movi	r2,-1
81131010:	303fec26 	beq	r6,zero,81130fc4 <__reset+0xfb110fc4>
81131014:	24ffffc4 	addi	r19,r4,-1
81131018:	003fe906 	br	81130fc0 <__reset+0xfb110fc0>
8113101c:	1c400084 	addi	r17,r3,2
81131020:	1c000043 	ldbu	r16,1(r3)
81131024:	05c00044 	movi	r23,1
81131028:	003fac06 	br	81130edc <__reset+0xfb110edc>
8113102c:	1c400084 	addi	r17,r3,2
81131030:	1c000043 	ldbu	r16,1(r3)
81131034:	002f883a 	mov	r23,zero
81131038:	003fa806 	br	81130edc <__reset+0xfb110edc>
8113103c:	88800003 	ldbu	r2,0(r17)
81131040:	00c01604 	movi	r3,88
81131044:	108037cc 	andi	r2,r2,223
81131048:	10c00c26 	beq	r2,r3,8113107c <_strtoul_r+0x220>
8113104c:	05400204 	movi	r21,8
81131050:	01c80034 	movhi	r7,8192
81131054:	030001c4 	movi	r12,7
81131058:	39ffffc4 	addi	r7,r7,-1
8113105c:	a817883a 	mov	r11,r21
81131060:	003fb506 	br	81130f38 <__reset+0xfb110f38>
81131064:	00800c04 	movi	r2,48
81131068:	80800c1e 	bne	r16,r2,8113109c <_strtoul_r+0x240>
8113106c:	88800003 	ldbu	r2,0(r17)
81131070:	00c01604 	movi	r3,88
81131074:	108037cc 	andi	r2,r2,223
81131078:	10c0081e 	bne	r2,r3,8113109c <_strtoul_r+0x240>
8113107c:	02c00404 	movi	r11,16
81131080:	05840034 	movhi	r22,4096
81131084:	8c000043 	ldbu	r16,1(r17)
81131088:	030003c4 	movi	r12,15
8113108c:	8c400084 	addi	r17,r17,2
81131090:	b5bfffc4 	addi	r22,r22,-1
81131094:	582b883a 	mov	r21,r11
81131098:	003f9e06 	br	81130f14 <__reset+0xfb110f14>
8113109c:	01c40034 	movhi	r7,4096
811310a0:	030003c4 	movi	r12,15
811310a4:	39ffffc4 	addi	r7,r7,-1
811310a8:	a817883a 	mov	r11,r21
811310ac:	003fa206 	br	81130f38 <__reset+0xfb110f38>

811310b0 <strtoul>:
811310b0:	00a04574 	movhi	r2,33045
811310b4:	1090f104 	addi	r2,r2,17348
811310b8:	300f883a 	mov	r7,r6
811310bc:	280d883a 	mov	r6,r5
811310c0:	200b883a 	mov	r5,r4
811310c4:	11000017 	ldw	r4,0(r2)
811310c8:	1130e5c1 	jmpi	81130e5c <_strtoul_r>

811310cc <_strtoull_r>:
811310cc:	00a04574 	movhi	r2,33045
811310d0:	defff404 	addi	sp,sp,-48
811310d4:	1090ef04 	addi	r2,r2,17340
811310d8:	de00012e 	bgeu	sp,et,811310e0 <_strtoull_r+0x14>
811310dc:	003b68fa 	trap	3
811310e0:	dc400315 	stw	r17,12(sp)
811310e4:	14400017 	ldw	r17,0(r2)
811310e8:	dd400715 	stw	r21,28(sp)
811310ec:	dd000615 	stw	r20,24(sp)
811310f0:	dcc00515 	stw	r19,20(sp)
811310f4:	dc800415 	stw	r18,16(sp)
811310f8:	dfc00b15 	stw	ra,44(sp)
811310fc:	df000a15 	stw	fp,40(sp)
81131100:	ddc00915 	stw	r23,36(sp)
81131104:	dd800815 	stw	r22,32(sp)
81131108:	dc000215 	stw	r16,8(sp)
8113110c:	2827883a 	mov	r19,r5
81131110:	202b883a 	mov	r21,r4
81131114:	3029883a 	mov	r20,r6
81131118:	3825883a 	mov	r18,r7
8113111c:	2807883a 	mov	r3,r5
81131120:	1c000003 	ldbu	r16,0(r3)
81131124:	1f000044 	addi	fp,r3,1
81131128:	1809883a 	mov	r4,r3
8113112c:	8c05883a 	add	r2,r17,r16
81131130:	10800043 	ldbu	r2,1(r2)
81131134:	e007883a 	mov	r3,fp
81131138:	1080020c 	andi	r2,r2,8
8113113c:	103ff81e 	bne	r2,zero,81131120 <__reset+0xfb111120>
81131140:	00800b44 	movi	r2,45
81131144:	80806e26 	beq	r16,r2,81131300 <_strtoull_r+0x234>
81131148:	00800ac4 	movi	r2,43
8113114c:	80807026 	beq	r16,r2,81131310 <_strtoull_r+0x244>
81131150:	002f883a 	mov	r23,zero
81131154:	90001426 	beq	r18,zero,811311a8 <_strtoull_r+0xdc>
81131158:	00800404 	movi	r2,16
8113115c:	90807c26 	beq	r18,r2,81131350 <_strtoull_r+0x284>
81131160:	902dd7fa 	srai	r22,r18,31
81131164:	013fffc4 	movi	r4,-1
81131168:	200b883a 	mov	r5,r4
8113116c:	900d883a 	mov	r6,r18
81131170:	b00f883a 	mov	r7,r22
81131174:	11353140 	call	81135314 <__udivdi3>
81131178:	013fffc4 	movi	r4,-1
8113117c:	900d883a 	mov	r6,r18
81131180:	b00f883a 	mov	r7,r22
81131184:	200b883a 	mov	r5,r4
81131188:	d8c00115 	stw	r3,4(sp)
8113118c:	d8800015 	stw	r2,0(sp)
81131190:	11358940 	call	81135894 <__umoddi3>
81131194:	101b883a 	mov	r13,r2
81131198:	9015883a 	mov	r10,r18
8113119c:	dac00017 	ldw	r11,0(sp)
811311a0:	da000117 	ldw	r8,4(sp)
811311a4:	00000a06 	br	811311d0 <_strtoull_r+0x104>
811311a8:	00800c04 	movi	r2,48
811311ac:	80805c26 	beq	r16,r2,81131320 <_strtoull_r+0x254>
811311b0:	02800284 	movi	r10,10
811311b4:	02e666b4 	movhi	r11,39322
811311b8:	020666b4 	movhi	r8,6554
811311bc:	03400144 	movi	r13,5
811311c0:	5ae66644 	addi	r11,r11,-26215
811311c4:	42266644 	addi	r8,r8,-26215
811311c8:	002d883a 	mov	r22,zero
811311cc:	5025883a 	mov	r18,r10
811311d0:	8c0b883a 	add	r5,r17,r16
811311d4:	29400043 	ldbu	r5,1(r5)
811311d8:	e009883a 	mov	r4,fp
811311dc:	000f883a 	mov	r7,zero
811311e0:	2980010c 	andi	r6,r5,4
811311e4:	0005883a 	mov	r2,zero
811311e8:	0007883a 	mov	r3,zero
811311ec:	03000044 	movi	r12,1
811311f0:	027fffc4 	movi	r9,-1
811311f4:	30000d26 	beq	r6,zero,8113122c <_strtoull_r+0x160>
811311f8:	843ff404 	addi	r16,r16,-48
811311fc:	8480110e 	bge	r16,r18,81131244 <_strtoull_r+0x178>
81131200:	3a400426 	beq	r7,r9,81131214 <_strtoull_r+0x148>
81131204:	40c00236 	bltu	r8,r3,81131210 <_strtoull_r+0x144>
81131208:	1a00231e 	bne	r3,r8,81131298 <_strtoull_r+0x1cc>
8113120c:	5880222e 	bgeu	r11,r2,81131298 <_strtoull_r+0x1cc>
81131210:	01ffffc4 	movi	r7,-1
81131214:	24000003 	ldbu	r16,0(r4)
81131218:	21000044 	addi	r4,r4,1
8113121c:	8c0b883a 	add	r5,r17,r16
81131220:	29400043 	ldbu	r5,1(r5)
81131224:	2980010c 	andi	r6,r5,4
81131228:	303ff31e 	bne	r6,zero,811311f8 <__reset+0xfb1111f8>
8113122c:	294000cc 	andi	r5,r5,3
81131230:	28000426 	beq	r5,zero,81131244 <_strtoull_r+0x178>
81131234:	2b002626 	beq	r5,r12,811312d0 <_strtoull_r+0x204>
81131238:	014015c4 	movi	r5,87
8113123c:	8161c83a 	sub	r16,r16,r5
81131240:	84bfef16 	blt	r16,r18,81131200 <__reset+0xfb111200>
81131244:	38002716 	blt	r7,zero,811312e4 <_strtoull_r+0x218>
81131248:	b8000426 	beq	r23,zero,8113125c <_strtoull_r+0x190>
8113124c:	0085c83a 	sub	r2,zero,r2
81131250:	100ac03a 	cmpne	r5,r2,zero
81131254:	00e1c83a 	sub	r16,zero,r3
81131258:	8147c83a 	sub	r3,r16,r5
8113125c:	a0000226 	beq	r20,zero,81131268 <_strtoull_r+0x19c>
81131260:	3800251e 	bne	r7,zero,811312f8 <_strtoull_r+0x22c>
81131264:	a4c00015 	stw	r19,0(r20)
81131268:	dfc00b17 	ldw	ra,44(sp)
8113126c:	df000a17 	ldw	fp,40(sp)
81131270:	ddc00917 	ldw	r23,36(sp)
81131274:	dd800817 	ldw	r22,32(sp)
81131278:	dd400717 	ldw	r21,28(sp)
8113127c:	dd000617 	ldw	r20,24(sp)
81131280:	dcc00517 	ldw	r19,20(sp)
81131284:	dc800417 	ldw	r18,16(sp)
81131288:	dc400317 	ldw	r17,12(sp)
8113128c:	dc000217 	ldw	r16,8(sp)
81131290:	dec00c04 	addi	sp,sp,48
81131294:	f800283a 	ret
81131298:	12c00f26 	beq	r2,r11,811312d8 <_strtoull_r+0x20c>
8113129c:	b08d383a 	mul	r6,r22,r2
811312a0:	1a87383a 	mul	r3,r3,r10
811312a4:	128a383a 	mulxuu	r5,r2,r10
811312a8:	1285383a 	mul	r2,r2,r10
811312ac:	800fd7fa 	srai	r7,r16,31
811312b0:	1987883a 	add	r3,r3,r6
811312b4:	8085883a 	add	r2,r16,r2
811312b8:	1947883a 	add	r3,r3,r5
811312bc:	38c7883a 	add	r3,r7,r3
811312c0:	1421803a 	cmpltu	r16,r2,r16
811312c4:	80c7883a 	add	r3,r16,r3
811312c8:	01c00044 	movi	r7,1
811312cc:	003fd106 	br	81131214 <__reset+0xfb111214>
811312d0:	01400dc4 	movi	r5,55
811312d4:	003fd906 	br	8113123c <__reset+0xfb11123c>
811312d8:	1a3ff01e 	bne	r3,r8,8113129c <__reset+0xfb11129c>
811312dc:	6c3fcc16 	blt	r13,r16,81131210 <__reset+0xfb111210>
811312e0:	003fee06 	br	8113129c <__reset+0xfb11129c>
811312e4:	00800884 	movi	r2,34
811312e8:	a8800015 	stw	r2,0(r21)
811312ec:	00bfffc4 	movi	r2,-1
811312f0:	1007883a 	mov	r3,r2
811312f4:	a03fdc26 	beq	r20,zero,81131268 <__reset+0xfb111268>
811312f8:	24ffffc4 	addi	r19,r4,-1
811312fc:	003fd906 	br	81131264 <__reset+0xfb111264>
81131300:	27000084 	addi	fp,r4,2
81131304:	24000043 	ldbu	r16,1(r4)
81131308:	05c00044 	movi	r23,1
8113130c:	003f9106 	br	81131154 <__reset+0xfb111154>
81131310:	27000084 	addi	fp,r4,2
81131314:	24000043 	ldbu	r16,1(r4)
81131318:	002f883a 	mov	r23,zero
8113131c:	003f8d06 	br	81131154 <__reset+0xfb111154>
81131320:	e0800003 	ldbu	r2,0(fp)
81131324:	00c01604 	movi	r3,88
81131328:	108037cc 	andi	r2,r2,223
8113132c:	10c00e26 	beq	r2,r3,81131368 <_strtoull_r+0x29c>
81131330:	02800204 	movi	r10,8
81131334:	02ffffc4 	movi	r11,-1
81131338:	02080034 	movhi	r8,8192
8113133c:	034001c4 	movi	r13,7
81131340:	42d1883a 	add	r8,r8,r11
81131344:	002d883a 	mov	r22,zero
81131348:	5025883a 	mov	r18,r10
8113134c:	003fa006 	br	811311d0 <__reset+0xfb1111d0>
81131350:	00800c04 	movi	r2,48
81131354:	80800e1e 	bne	r16,r2,81131390 <_strtoull_r+0x2c4>
81131358:	e0800003 	ldbu	r2,0(fp)
8113135c:	00c01604 	movi	r3,88
81131360:	108037cc 	andi	r2,r2,223
81131364:	10c00a1e 	bne	r2,r3,81131390 <_strtoull_r+0x2c4>
81131368:	02800404 	movi	r10,16
8113136c:	02ffffc4 	movi	r11,-1
81131370:	02040034 	movhi	r8,4096
81131374:	e4000043 	ldbu	r16,1(fp)
81131378:	034003c4 	movi	r13,15
8113137c:	e7000084 	addi	fp,fp,2
81131380:	42d1883a 	add	r8,r8,r11
81131384:	002d883a 	mov	r22,zero
81131388:	5025883a 	mov	r18,r10
8113138c:	003f9006 	br	811311d0 <__reset+0xfb1111d0>
81131390:	02ffffc4 	movi	r11,-1
81131394:	02040034 	movhi	r8,4096
81131398:	034003c4 	movi	r13,15
8113139c:	42d1883a 	add	r8,r8,r11
811313a0:	9015883a 	mov	r10,r18
811313a4:	002d883a 	mov	r22,zero
811313a8:	003f8906 	br	811311d0 <__reset+0xfb1111d0>

811313ac <__ssprint_r>:
811313ac:	defff604 	addi	sp,sp,-40
811313b0:	de00012e 	bgeu	sp,et,811313b8 <__ssprint_r+0xc>
811313b4:	003b68fa 	trap	3
811313b8:	30800217 	ldw	r2,8(r6)
811313bc:	dc800215 	stw	r18,8(sp)
811313c0:	dfc00915 	stw	ra,36(sp)
811313c4:	df000815 	stw	fp,32(sp)
811313c8:	ddc00715 	stw	r23,28(sp)
811313cc:	dd800615 	stw	r22,24(sp)
811313d0:	dd400515 	stw	r21,20(sp)
811313d4:	dd000415 	stw	r20,16(sp)
811313d8:	dcc00315 	stw	r19,12(sp)
811313dc:	dc400115 	stw	r17,4(sp)
811313e0:	dc000015 	stw	r16,0(sp)
811313e4:	3025883a 	mov	r18,r6
811313e8:	10005826 	beq	r2,zero,8113154c <__ssprint_r+0x1a0>
811313ec:	2027883a 	mov	r19,r4
811313f0:	35c00017 	ldw	r23,0(r6)
811313f4:	29000017 	ldw	r4,0(r5)
811313f8:	28800217 	ldw	r2,8(r5)
811313fc:	2823883a 	mov	r17,r5
81131400:	0039883a 	mov	fp,zero
81131404:	0021883a 	mov	r16,zero
81131408:	80003926 	beq	r16,zero,811314f0 <__ssprint_r+0x144>
8113140c:	102b883a 	mov	r21,r2
81131410:	102d883a 	mov	r22,r2
81131414:	80803a36 	bltu	r16,r2,81131500 <__ssprint_r+0x154>
81131418:	88c0030b 	ldhu	r3,12(r17)
8113141c:	1881200c 	andi	r2,r3,1152
81131420:	10002626 	beq	r2,zero,811314bc <__ssprint_r+0x110>
81131424:	88800517 	ldw	r2,20(r17)
81131428:	89400417 	ldw	r5,16(r17)
8113142c:	81800044 	addi	r6,r16,1
81131430:	108f883a 	add	r7,r2,r2
81131434:	3885883a 	add	r2,r7,r2
81131438:	100ed7fa 	srli	r7,r2,31
8113143c:	216dc83a 	sub	r22,r4,r5
81131440:	3589883a 	add	r4,r6,r22
81131444:	3885883a 	add	r2,r7,r2
81131448:	102bd07a 	srai	r21,r2,1
8113144c:	a80d883a 	mov	r6,r21
81131450:	a900022e 	bgeu	r21,r4,8113145c <__ssprint_r+0xb0>
81131454:	202b883a 	mov	r21,r4
81131458:	200d883a 	mov	r6,r4
8113145c:	18c1000c 	andi	r3,r3,1024
81131460:	18002a26 	beq	r3,zero,8113150c <__ssprint_r+0x160>
81131464:	300b883a 	mov	r5,r6
81131468:	9809883a 	mov	r4,r19
8113146c:	11231c80 	call	811231c8 <_malloc_r>
81131470:	1029883a 	mov	r20,r2
81131474:	10002c26 	beq	r2,zero,81131528 <__ssprint_r+0x17c>
81131478:	89400417 	ldw	r5,16(r17)
8113147c:	b00d883a 	mov	r6,r22
81131480:	1009883a 	mov	r4,r2
81131484:	11239dc0 	call	811239dc <memcpy>
81131488:	8880030b 	ldhu	r2,12(r17)
8113148c:	00fedfc4 	movi	r3,-1153
81131490:	10c4703a 	and	r2,r2,r3
81131494:	10802014 	ori	r2,r2,128
81131498:	8880030d 	sth	r2,12(r17)
8113149c:	a589883a 	add	r4,r20,r22
811314a0:	adadc83a 	sub	r22,r21,r22
811314a4:	8d400515 	stw	r21,20(r17)
811314a8:	8d800215 	stw	r22,8(r17)
811314ac:	8d000415 	stw	r20,16(r17)
811314b0:	89000015 	stw	r4,0(r17)
811314b4:	802b883a 	mov	r21,r16
811314b8:	802d883a 	mov	r22,r16
811314bc:	b00d883a 	mov	r6,r22
811314c0:	e00b883a 	mov	r5,fp
811314c4:	112da340 	call	8112da34 <memmove>
811314c8:	88800217 	ldw	r2,8(r17)
811314cc:	89000017 	ldw	r4,0(r17)
811314d0:	90c00217 	ldw	r3,8(r18)
811314d4:	1545c83a 	sub	r2,r2,r21
811314d8:	2589883a 	add	r4,r4,r22
811314dc:	88800215 	stw	r2,8(r17)
811314e0:	89000015 	stw	r4,0(r17)
811314e4:	1c21c83a 	sub	r16,r3,r16
811314e8:	94000215 	stw	r16,8(r18)
811314ec:	80001726 	beq	r16,zero,8113154c <__ssprint_r+0x1a0>
811314f0:	bf000017 	ldw	fp,0(r23)
811314f4:	bc000117 	ldw	r16,4(r23)
811314f8:	bdc00204 	addi	r23,r23,8
811314fc:	003fc206 	br	81131408 <__reset+0xfb111408>
81131500:	802b883a 	mov	r21,r16
81131504:	802d883a 	mov	r22,r16
81131508:	003fec06 	br	811314bc <__reset+0xfb1114bc>
8113150c:	9809883a 	mov	r4,r19
81131510:	112ec540 	call	8112ec54 <_realloc_r>
81131514:	1029883a 	mov	r20,r2
81131518:	103fe01e 	bne	r2,zero,8113149c <__reset+0xfb11149c>
8113151c:	89400417 	ldw	r5,16(r17)
81131520:	9809883a 	mov	r4,r19
81131524:	112cbc00 	call	8112cbc0 <_free_r>
81131528:	88c0030b 	ldhu	r3,12(r17)
8113152c:	00800304 	movi	r2,12
81131530:	98800015 	stw	r2,0(r19)
81131534:	18c01014 	ori	r3,r3,64
81131538:	88c0030d 	sth	r3,12(r17)
8113153c:	00bfffc4 	movi	r2,-1
81131540:	90000215 	stw	zero,8(r18)
81131544:	90000115 	stw	zero,4(r18)
81131548:	00000206 	br	81131554 <__ssprint_r+0x1a8>
8113154c:	90000115 	stw	zero,4(r18)
81131550:	0005883a 	mov	r2,zero
81131554:	dfc00917 	ldw	ra,36(sp)
81131558:	df000817 	ldw	fp,32(sp)
8113155c:	ddc00717 	ldw	r23,28(sp)
81131560:	dd800617 	ldw	r22,24(sp)
81131564:	dd400517 	ldw	r21,20(sp)
81131568:	dd000417 	ldw	r20,16(sp)
8113156c:	dcc00317 	ldw	r19,12(sp)
81131570:	dc800217 	ldw	r18,8(sp)
81131574:	dc400117 	ldw	r17,4(sp)
81131578:	dc000017 	ldw	r16,0(sp)
8113157c:	dec00a04 	addi	sp,sp,40
81131580:	f800283a 	ret

81131584 <___svfiprintf_internal_r>:
81131584:	deffc804 	addi	sp,sp,-224
81131588:	de00012e 	bgeu	sp,et,81131590 <___svfiprintf_internal_r+0xc>
8113158c:	003b68fa 	trap	3
81131590:	2880030b 	ldhu	r2,12(r5)
81131594:	dcc03115 	stw	r19,196(sp)
81131598:	dfc03715 	stw	ra,220(sp)
8113159c:	df003615 	stw	fp,216(sp)
811315a0:	ddc03515 	stw	r23,212(sp)
811315a4:	dd803415 	stw	r22,208(sp)
811315a8:	dd403315 	stw	r21,204(sp)
811315ac:	dd003215 	stw	r20,200(sp)
811315b0:	dc803015 	stw	r18,192(sp)
811315b4:	dc402f15 	stw	r17,188(sp)
811315b8:	dc002e15 	stw	r16,184(sp)
811315bc:	d9402715 	stw	r5,156(sp)
811315c0:	d9002a15 	stw	r4,168(sp)
811315c4:	1080200c 	andi	r2,r2,128
811315c8:	d9c02315 	stw	r7,140(sp)
811315cc:	3027883a 	mov	r19,r6
811315d0:	10000226 	beq	r2,zero,811315dc <___svfiprintf_internal_r+0x58>
811315d4:	28800417 	ldw	r2,16(r5)
811315d8:	10041d26 	beq	r2,zero,81132650 <___svfiprintf_internal_r+0x10cc>
811315dc:	dac01a04 	addi	r11,sp,104
811315e0:	dac01e15 	stw	r11,120(sp)
811315e4:	d8801e17 	ldw	r2,120(sp)
811315e8:	dac019c4 	addi	r11,sp,103
811315ec:	dd402a17 	ldw	r21,168(sp)
811315f0:	ddc02717 	ldw	r23,156(sp)
811315f4:	05a04574 	movhi	r22,33045
811315f8:	05204574 	movhi	r20,33045
811315fc:	dac01f15 	stw	r11,124(sp)
81131600:	12d7c83a 	sub	r11,r2,r11
81131604:	b587b004 	addi	r22,r22,7872
81131608:	a507ac04 	addi	r20,r20,7856
8113160c:	dec01a15 	stw	sp,104(sp)
81131610:	d8001c15 	stw	zero,112(sp)
81131614:	d8001b15 	stw	zero,108(sp)
81131618:	d811883a 	mov	r8,sp
8113161c:	d8002915 	stw	zero,164(sp)
81131620:	d8002515 	stw	zero,148(sp)
81131624:	dac02b15 	stw	r11,172(sp)
81131628:	98800007 	ldb	r2,0(r19)
8113162c:	1002dd26 	beq	r2,zero,811321a4 <___svfiprintf_internal_r+0xc20>
81131630:	00c00944 	movi	r3,37
81131634:	9823883a 	mov	r17,r19
81131638:	10c0021e 	bne	r2,r3,81131644 <___svfiprintf_internal_r+0xc0>
8113163c:	00001406 	br	81131690 <___svfiprintf_internal_r+0x10c>
81131640:	10c00326 	beq	r2,r3,81131650 <___svfiprintf_internal_r+0xcc>
81131644:	8c400044 	addi	r17,r17,1
81131648:	88800007 	ldb	r2,0(r17)
8113164c:	103ffc1e 	bne	r2,zero,81131640 <__reset+0xfb111640>
81131650:	8ce1c83a 	sub	r16,r17,r19
81131654:	80000e26 	beq	r16,zero,81131690 <___svfiprintf_internal_r+0x10c>
81131658:	d8c01c17 	ldw	r3,112(sp)
8113165c:	d8801b17 	ldw	r2,108(sp)
81131660:	44c00015 	stw	r19,0(r8)
81131664:	1c07883a 	add	r3,r3,r16
81131668:	10800044 	addi	r2,r2,1
8113166c:	d8c01c15 	stw	r3,112(sp)
81131670:	44000115 	stw	r16,4(r8)
81131674:	d8801b15 	stw	r2,108(sp)
81131678:	00c001c4 	movi	r3,7
8113167c:	18831e16 	blt	r3,r2,811322f8 <___svfiprintf_internal_r+0xd74>
81131680:	42000204 	addi	r8,r8,8
81131684:	dac02517 	ldw	r11,148(sp)
81131688:	5c17883a 	add	r11,r11,r16
8113168c:	dac02515 	stw	r11,148(sp)
81131690:	88800007 	ldb	r2,0(r17)
81131694:	1002c526 	beq	r2,zero,811321ac <___svfiprintf_internal_r+0xc28>
81131698:	88c00047 	ldb	r3,1(r17)
8113169c:	8cc00044 	addi	r19,r17,1
811316a0:	d8001d85 	stb	zero,118(sp)
811316a4:	0009883a 	mov	r4,zero
811316a8:	000f883a 	mov	r7,zero
811316ac:	043fffc4 	movi	r16,-1
811316b0:	d8002415 	stw	zero,144(sp)
811316b4:	0025883a 	mov	r18,zero
811316b8:	01401604 	movi	r5,88
811316bc:	01800244 	movi	r6,9
811316c0:	02800a84 	movi	r10,42
811316c4:	02401b04 	movi	r9,108
811316c8:	9cc00044 	addi	r19,r19,1
811316cc:	18bff804 	addi	r2,r3,-32
811316d0:	2881dd36 	bltu	r5,r2,81131e48 <___svfiprintf_internal_r+0x8c4>
811316d4:	100490ba 	slli	r2,r2,2
811316d8:	02e044f4 	movhi	r11,33043
811316dc:	5ac5bb04 	addi	r11,r11,5868
811316e0:	12c5883a 	add	r2,r2,r11
811316e4:	10800017 	ldw	r2,0(r2)
811316e8:	1000683a 	jmp	r2
811316ec:	811318e8 	cmpgeui	r4,r16,19555
811316f0:	81131e48 	cmpgei	r4,r16,19577
811316f4:	81131e48 	cmpgei	r4,r16,19577
811316f8:	811318dc 	xori	r4,r16,19555
811316fc:	81131e48 	cmpgei	r4,r16,19577
81131700:	81131e48 	cmpgei	r4,r16,19577
81131704:	81131e48 	cmpgei	r4,r16,19577
81131708:	81131e48 	cmpgei	r4,r16,19577
8113170c:	81131e48 	cmpgei	r4,r16,19577
81131710:	81131e48 	cmpgei	r4,r16,19577
81131714:	81131850 	cmplti	r4,r16,19553
81131718:	81131a2c 	andhi	r4,r16,19560
8113171c:	81131e48 	cmpgei	r4,r16,19577
81131720:	8113187c 	xorhi	r4,r16,19553
81131724:	81131e7c 	xorhi	r4,r16,19577
81131728:	81131e48 	cmpgei	r4,r16,19577
8113172c:	81131e70 	cmpltui	r4,r16,19577
81131730:	81131e10 	cmplti	r4,r16,19576
81131734:	81131e10 	cmplti	r4,r16,19576
81131738:	81131e10 	cmplti	r4,r16,19576
8113173c:	81131e10 	cmplti	r4,r16,19576
81131740:	81131e10 	cmplti	r4,r16,19576
81131744:	81131e10 	cmplti	r4,r16,19576
81131748:	81131e10 	cmplti	r4,r16,19576
8113174c:	81131e10 	cmplti	r4,r16,19576
81131750:	81131e10 	cmplti	r4,r16,19576
81131754:	81131e48 	cmpgei	r4,r16,19577
81131758:	81131e48 	cmpgei	r4,r16,19577
8113175c:	81131e48 	cmpgei	r4,r16,19577
81131760:	81131e48 	cmpgei	r4,r16,19577
81131764:	81131e48 	cmpgei	r4,r16,19577
81131768:	81131e48 	cmpgei	r4,r16,19577
8113176c:	81131e48 	cmpgei	r4,r16,19577
81131770:	81131e48 	cmpgei	r4,r16,19577
81131774:	81131e48 	cmpgei	r4,r16,19577
81131778:	81131e48 	cmpgei	r4,r16,19577
8113177c:	81131dac 	andhi	r4,r16,19574
81131780:	81131e48 	cmpgei	r4,r16,19577
81131784:	81131e48 	cmpgei	r4,r16,19577
81131788:	81131e48 	cmpgei	r4,r16,19577
8113178c:	81131e48 	cmpgei	r4,r16,19577
81131790:	81131e48 	cmpgei	r4,r16,19577
81131794:	81131e48 	cmpgei	r4,r16,19577
81131798:	81131e48 	cmpgei	r4,r16,19577
8113179c:	81131e48 	cmpgei	r4,r16,19577
811317a0:	81131e48 	cmpgei	r4,r16,19577
811317a4:	81131e48 	cmpgei	r4,r16,19577
811317a8:	81131f24 	muli	r4,r16,19580
811317ac:	81131e48 	cmpgei	r4,r16,19577
811317b0:	81131e48 	cmpgei	r4,r16,19577
811317b4:	81131e48 	cmpgei	r4,r16,19577
811317b8:	81131e48 	cmpgei	r4,r16,19577
811317bc:	81131e48 	cmpgei	r4,r16,19577
811317c0:	81131ebc 	xorhi	r4,r16,19578
811317c4:	81131e48 	cmpgei	r4,r16,19577
811317c8:	81131e48 	cmpgei	r4,r16,19577
811317cc:	81131bf0 	cmpltui	r4,r16,19567
811317d0:	81131e48 	cmpgei	r4,r16,19577
811317d4:	81131e48 	cmpgei	r4,r16,19577
811317d8:	81131e48 	cmpgei	r4,r16,19577
811317dc:	81131e48 	cmpgei	r4,r16,19577
811317e0:	81131e48 	cmpgei	r4,r16,19577
811317e4:	81131e48 	cmpgei	r4,r16,19577
811317e8:	81131e48 	cmpgei	r4,r16,19577
811317ec:	81131e48 	cmpgei	r4,r16,19577
811317f0:	81131e48 	cmpgei	r4,r16,19577
811317f4:	81131e48 	cmpgei	r4,r16,19577
811317f8:	81131ae0 	cmpeqi	r4,r16,19563
811317fc:	81131c8c 	andi	r4,r16,19570
81131800:	81131e48 	cmpgei	r4,r16,19577
81131804:	81131e48 	cmpgei	r4,r16,19577
81131808:	81131e48 	cmpgei	r4,r16,19577
8113180c:	81131c80 	call	881131c8 <__reset+0x20f31c8>
81131810:	81131c8c 	andi	r4,r16,19570
81131814:	81131e48 	cmpgei	r4,r16,19577
81131818:	81131e48 	cmpgei	r4,r16,19577
8113181c:	81131c70 	cmpltui	r4,r16,19569
81131820:	81131e48 	cmpgei	r4,r16,19577
81131824:	81131c34 	orhi	r4,r16,19568
81131828:	81131a3c 	xorhi	r4,r16,19560
8113182c:	81131888 	cmpgei	r4,r16,19554
81131830:	81131da0 	cmpeqi	r4,r16,19574
81131834:	81131e48 	cmpgei	r4,r16,19577
81131838:	81131d54 	ori	r4,r16,19573
8113183c:	81131e48 	cmpgei	r4,r16,19577
81131840:	811319ac 	andhi	r4,r16,19558
81131844:	81131e48 	cmpgei	r4,r16,19577
81131848:	81131e48 	cmpgei	r4,r16,19577
8113184c:	81131908 	cmpgei	r4,r16,19556
81131850:	dac02317 	ldw	r11,140(sp)
81131854:	5ac00017 	ldw	r11,0(r11)
81131858:	dac02415 	stw	r11,144(sp)
8113185c:	dac02317 	ldw	r11,140(sp)
81131860:	58800104 	addi	r2,r11,4
81131864:	dac02417 	ldw	r11,144(sp)
81131868:	5802e90e 	bge	r11,zero,81132410 <___svfiprintf_internal_r+0xe8c>
8113186c:	dac02417 	ldw	r11,144(sp)
81131870:	d8802315 	stw	r2,140(sp)
81131874:	02d7c83a 	sub	r11,zero,r11
81131878:	dac02415 	stw	r11,144(sp)
8113187c:	94800114 	ori	r18,r18,4
81131880:	98c00007 	ldb	r3,0(r19)
81131884:	003f9006 	br	811316c8 <__reset+0xfb1116c8>
81131888:	00800c04 	movi	r2,48
8113188c:	dac02317 	ldw	r11,140(sp)
81131890:	d8801d05 	stb	r2,116(sp)
81131894:	00801e04 	movi	r2,120
81131898:	d8801d45 	stb	r2,117(sp)
8113189c:	d8001d85 	stb	zero,118(sp)
811318a0:	58c00104 	addi	r3,r11,4
811318a4:	5f000017 	ldw	fp,0(r11)
811318a8:	0013883a 	mov	r9,zero
811318ac:	90800094 	ori	r2,r18,2
811318b0:	80032b16 	blt	r16,zero,81132560 <___svfiprintf_internal_r+0xfdc>
811318b4:	00bfdfc4 	movi	r2,-129
811318b8:	90a4703a 	and	r18,r18,r2
811318bc:	d8c02315 	stw	r3,140(sp)
811318c0:	94800094 	ori	r18,r18,2
811318c4:	e002dc26 	beq	fp,zero,81132438 <___svfiprintf_internal_r+0xeb4>
811318c8:	01204574 	movhi	r4,33045
811318cc:	21072204 	addi	r4,r4,7304
811318d0:	0015883a 	mov	r10,zero
811318d4:	d9002915 	stw	r4,164(sp)
811318d8:	00002306 	br	81131968 <___svfiprintf_internal_r+0x3e4>
811318dc:	94800054 	ori	r18,r18,1
811318e0:	98c00007 	ldb	r3,0(r19)
811318e4:	003f7806 	br	811316c8 <__reset+0xfb1116c8>
811318e8:	38803fcc 	andi	r2,r7,255
811318ec:	1080201c 	xori	r2,r2,128
811318f0:	10bfe004 	addi	r2,r2,-128
811318f4:	1002f31e 	bne	r2,zero,811324c4 <___svfiprintf_internal_r+0xf40>
811318f8:	01000044 	movi	r4,1
811318fc:	01c00804 	movi	r7,32
81131900:	98c00007 	ldb	r3,0(r19)
81131904:	003f7006 	br	811316c8 <__reset+0xfb1116c8>
81131908:	21003fcc 	andi	r4,r4,255
8113190c:	2003aa1e 	bne	r4,zero,811327b8 <___svfiprintf_internal_r+0x1234>
81131910:	00a04574 	movhi	r2,33045
81131914:	10872204 	addi	r2,r2,7304
81131918:	d8802915 	stw	r2,164(sp)
8113191c:	9080080c 	andi	r2,r18,32
81131920:	1000ba26 	beq	r2,zero,81131c0c <___svfiprintf_internal_r+0x688>
81131924:	dac02317 	ldw	r11,140(sp)
81131928:	5f000017 	ldw	fp,0(r11)
8113192c:	5a400117 	ldw	r9,4(r11)
81131930:	5ac00204 	addi	r11,r11,8
81131934:	dac02315 	stw	r11,140(sp)
81131938:	9080004c 	andi	r2,r18,1
8113193c:	10029026 	beq	r2,zero,81132380 <___svfiprintf_internal_r+0xdfc>
81131940:	e244b03a 	or	r2,fp,r9
81131944:	1002d41e 	bne	r2,zero,81132498 <___svfiprintf_internal_r+0xf14>
81131948:	d8001d85 	stb	zero,118(sp)
8113194c:	80030b16 	blt	r16,zero,8113257c <___svfiprintf_internal_r+0xff8>
81131950:	00bfdfc4 	movi	r2,-129
81131954:	90a4703a 	and	r18,r18,r2
81131958:	0015883a 	mov	r10,zero
8113195c:	80002426 	beq	r16,zero,811319f0 <___svfiprintf_internal_r+0x46c>
81131960:	0039883a 	mov	fp,zero
81131964:	0013883a 	mov	r9,zero
81131968:	d9002917 	ldw	r4,164(sp)
8113196c:	dc401a04 	addi	r17,sp,104
81131970:	e08003cc 	andi	r2,fp,15
81131974:	4806973a 	slli	r3,r9,28
81131978:	2085883a 	add	r2,r4,r2
8113197c:	e038d13a 	srli	fp,fp,4
81131980:	10800003 	ldbu	r2,0(r2)
81131984:	4812d13a 	srli	r9,r9,4
81131988:	8c7fffc4 	addi	r17,r17,-1
8113198c:	1f38b03a 	or	fp,r3,fp
81131990:	88800005 	stb	r2,0(r17)
81131994:	e244b03a 	or	r2,fp,r9
81131998:	103ff51e 	bne	r2,zero,81131970 <__reset+0xfb111970>
8113199c:	dac01e17 	ldw	r11,120(sp)
811319a0:	5c57c83a 	sub	r11,r11,r17
811319a4:	dac02115 	stw	r11,132(sp)
811319a8:	00001406 	br	811319fc <___svfiprintf_internal_r+0x478>
811319ac:	21003fcc 	andi	r4,r4,255
811319b0:	2003741e 	bne	r4,zero,81132784 <___svfiprintf_internal_r+0x1200>
811319b4:	9080080c 	andi	r2,r18,32
811319b8:	10014526 	beq	r2,zero,81131ed0 <___svfiprintf_internal_r+0x94c>
811319bc:	dac02317 	ldw	r11,140(sp)
811319c0:	d8001d85 	stb	zero,118(sp)
811319c4:	58c00204 	addi	r3,r11,8
811319c8:	5f000017 	ldw	fp,0(r11)
811319cc:	5a400117 	ldw	r9,4(r11)
811319d0:	8002d916 	blt	r16,zero,81132538 <___svfiprintf_internal_r+0xfb4>
811319d4:	013fdfc4 	movi	r4,-129
811319d8:	e244b03a 	or	r2,fp,r9
811319dc:	d8c02315 	stw	r3,140(sp)
811319e0:	9124703a 	and	r18,r18,r4
811319e4:	0015883a 	mov	r10,zero
811319e8:	1000b91e 	bne	r2,zero,81131cd0 <___svfiprintf_internal_r+0x74c>
811319ec:	8002e61e 	bne	r16,zero,81132588 <___svfiprintf_internal_r+0x1004>
811319f0:	0021883a 	mov	r16,zero
811319f4:	d8002115 	stw	zero,132(sp)
811319f8:	dc401a04 	addi	r17,sp,104
811319fc:	d8c02117 	ldw	r3,132(sp)
81131a00:	dc002015 	stw	r16,128(sp)
81131a04:	80c0010e 	bge	r16,r3,81131a0c <___svfiprintf_internal_r+0x488>
81131a08:	d8c02015 	stw	r3,128(sp)
81131a0c:	52803fcc 	andi	r10,r10,255
81131a10:	5280201c 	xori	r10,r10,128
81131a14:	52bfe004 	addi	r10,r10,-128
81131a18:	50003c26 	beq	r10,zero,81131b0c <___svfiprintf_internal_r+0x588>
81131a1c:	dac02017 	ldw	r11,128(sp)
81131a20:	5ac00044 	addi	r11,r11,1
81131a24:	dac02015 	stw	r11,128(sp)
81131a28:	00003806 	br	81131b0c <___svfiprintf_internal_r+0x588>
81131a2c:	01000044 	movi	r4,1
81131a30:	01c00ac4 	movi	r7,43
81131a34:	98c00007 	ldb	r3,0(r19)
81131a38:	003f2306 	br	811316c8 <__reset+0xfb1116c8>
81131a3c:	21003fcc 	andi	r4,r4,255
81131a40:	2003481e 	bne	r4,zero,81132764 <___svfiprintf_internal_r+0x11e0>
81131a44:	9080080c 	andi	r2,r18,32
81131a48:	10013b26 	beq	r2,zero,81131f38 <___svfiprintf_internal_r+0x9b4>
81131a4c:	dac02317 	ldw	r11,140(sp)
81131a50:	d8001d85 	stb	zero,118(sp)
81131a54:	58800204 	addi	r2,r11,8
81131a58:	5f000017 	ldw	fp,0(r11)
81131a5c:	5a400117 	ldw	r9,4(r11)
81131a60:	8002a816 	blt	r16,zero,81132504 <___svfiprintf_internal_r+0xf80>
81131a64:	013fdfc4 	movi	r4,-129
81131a68:	e246b03a 	or	r3,fp,r9
81131a6c:	d8802315 	stw	r2,140(sp)
81131a70:	9124703a 	and	r18,r18,r4
81131a74:	18013c26 	beq	r3,zero,81131f68 <___svfiprintf_internal_r+0x9e4>
81131a78:	0015883a 	mov	r10,zero
81131a7c:	dc401a04 	addi	r17,sp,104
81131a80:	e006d0fa 	srli	r3,fp,3
81131a84:	4808977a 	slli	r4,r9,29
81131a88:	4812d0fa 	srli	r9,r9,3
81131a8c:	e70001cc 	andi	fp,fp,7
81131a90:	e0800c04 	addi	r2,fp,48
81131a94:	8c7fffc4 	addi	r17,r17,-1
81131a98:	20f8b03a 	or	fp,r4,r3
81131a9c:	88800005 	stb	r2,0(r17)
81131aa0:	e246b03a 	or	r3,fp,r9
81131aa4:	183ff61e 	bne	r3,zero,81131a80 <__reset+0xfb111a80>
81131aa8:	90c0004c 	andi	r3,r18,1
81131aac:	1800a526 	beq	r3,zero,81131d44 <___svfiprintf_internal_r+0x7c0>
81131ab0:	10803fcc 	andi	r2,r2,255
81131ab4:	1080201c 	xori	r2,r2,128
81131ab8:	10bfe004 	addi	r2,r2,-128
81131abc:	00c00c04 	movi	r3,48
81131ac0:	10ffb626 	beq	r2,r3,8113199c <__reset+0xfb11199c>
81131ac4:	88ffffc5 	stb	r3,-1(r17)
81131ac8:	d8c01e17 	ldw	r3,120(sp)
81131acc:	88bfffc4 	addi	r2,r17,-1
81131ad0:	1023883a 	mov	r17,r2
81131ad4:	1887c83a 	sub	r3,r3,r2
81131ad8:	d8c02115 	stw	r3,132(sp)
81131adc:	003fc706 	br	811319fc <__reset+0xfb1119fc>
81131ae0:	dac02317 	ldw	r11,140(sp)
81131ae4:	00c00044 	movi	r3,1
81131ae8:	d8c02015 	stw	r3,128(sp)
81131aec:	58800017 	ldw	r2,0(r11)
81131af0:	5ac00104 	addi	r11,r11,4
81131af4:	d8001d85 	stb	zero,118(sp)
81131af8:	d8801005 	stb	r2,64(sp)
81131afc:	dac02315 	stw	r11,140(sp)
81131b00:	d8c02115 	stw	r3,132(sp)
81131b04:	dc401004 	addi	r17,sp,64
81131b08:	0021883a 	mov	r16,zero
81131b0c:	90c0008c 	andi	r3,r18,2
81131b10:	d8c02215 	stw	r3,136(sp)
81131b14:	18000326 	beq	r3,zero,81131b24 <___svfiprintf_internal_r+0x5a0>
81131b18:	dac02017 	ldw	r11,128(sp)
81131b1c:	5ac00084 	addi	r11,r11,2
81131b20:	dac02015 	stw	r11,128(sp)
81131b24:	90c0210c 	andi	r3,r18,132
81131b28:	d8c02615 	stw	r3,152(sp)
81131b2c:	1801131e 	bne	r3,zero,81131f7c <___svfiprintf_internal_r+0x9f8>
81131b30:	dac02417 	ldw	r11,144(sp)
81131b34:	d8c02017 	ldw	r3,128(sp)
81131b38:	58f9c83a 	sub	fp,r11,r3
81131b3c:	07010f0e 	bge	zero,fp,81131f7c <___svfiprintf_internal_r+0x9f8>
81131b40:	02400404 	movi	r9,16
81131b44:	d8c01c17 	ldw	r3,112(sp)
81131b48:	d8801b17 	ldw	r2,108(sp)
81131b4c:	4f02d60e 	bge	r9,fp,811326a8 <___svfiprintf_internal_r+0x1124>
81131b50:	01604574 	movhi	r5,33045
81131b54:	2947b004 	addi	r5,r5,7872
81131b58:	d9402815 	stw	r5,160(sp)
81131b5c:	028001c4 	movi	r10,7
81131b60:	00000306 	br	81131b70 <___svfiprintf_internal_r+0x5ec>
81131b64:	e73ffc04 	addi	fp,fp,-16
81131b68:	42000204 	addi	r8,r8,8
81131b6c:	4f00150e 	bge	r9,fp,81131bc4 <___svfiprintf_internal_r+0x640>
81131b70:	18c00404 	addi	r3,r3,16
81131b74:	10800044 	addi	r2,r2,1
81131b78:	45800015 	stw	r22,0(r8)
81131b7c:	42400115 	stw	r9,4(r8)
81131b80:	d8c01c15 	stw	r3,112(sp)
81131b84:	d8801b15 	stw	r2,108(sp)
81131b88:	50bff60e 	bge	r10,r2,81131b64 <__reset+0xfb111b64>
81131b8c:	d9801a04 	addi	r6,sp,104
81131b90:	b80b883a 	mov	r5,r23
81131b94:	a809883a 	mov	r4,r21
81131b98:	da402c15 	stw	r9,176(sp)
81131b9c:	da802d15 	stw	r10,180(sp)
81131ba0:	11313ac0 	call	811313ac <__ssprint_r>
81131ba4:	da402c17 	ldw	r9,176(sp)
81131ba8:	da802d17 	ldw	r10,180(sp)
81131bac:	1001851e 	bne	r2,zero,811321c4 <___svfiprintf_internal_r+0xc40>
81131bb0:	e73ffc04 	addi	fp,fp,-16
81131bb4:	d8c01c17 	ldw	r3,112(sp)
81131bb8:	d8801b17 	ldw	r2,108(sp)
81131bbc:	d811883a 	mov	r8,sp
81131bc0:	4f3feb16 	blt	r9,fp,81131b70 <__reset+0xfb111b70>
81131bc4:	dac02817 	ldw	r11,160(sp)
81131bc8:	e0c7883a 	add	r3,fp,r3
81131bcc:	10800044 	addi	r2,r2,1
81131bd0:	42c00015 	stw	r11,0(r8)
81131bd4:	47000115 	stw	fp,4(r8)
81131bd8:	d8c01c15 	stw	r3,112(sp)
81131bdc:	d8801b15 	stw	r2,108(sp)
81131be0:	010001c4 	movi	r4,7
81131be4:	2081ee16 	blt	r4,r2,811323a0 <___svfiprintf_internal_r+0xe1c>
81131be8:	42000204 	addi	r8,r8,8
81131bec:	0000e506 	br	81131f84 <___svfiprintf_internal_r+0xa00>
81131bf0:	21003fcc 	andi	r4,r4,255
81131bf4:	2002dd1e 	bne	r4,zero,8113276c <___svfiprintf_internal_r+0x11e8>
81131bf8:	00a04574 	movhi	r2,33045
81131bfc:	10871d04 	addi	r2,r2,7284
81131c00:	d8802915 	stw	r2,164(sp)
81131c04:	9080080c 	andi	r2,r18,32
81131c08:	103f461e 	bne	r2,zero,81131924 <__reset+0xfb111924>
81131c0c:	9080040c 	andi	r2,r18,16
81131c10:	10022e1e 	bne	r2,zero,811324cc <___svfiprintf_internal_r+0xf48>
81131c14:	9080100c 	andi	r2,r18,64
81131c18:	dac02317 	ldw	r11,140(sp)
81131c1c:	10027326 	beq	r2,zero,811325ec <___svfiprintf_internal_r+0x1068>
81131c20:	5f00000b 	ldhu	fp,0(r11)
81131c24:	5ac00104 	addi	r11,r11,4
81131c28:	0013883a 	mov	r9,zero
81131c2c:	dac02315 	stw	r11,140(sp)
81131c30:	003f4106 	br	81131938 <__reset+0xfb111938>
81131c34:	21003fcc 	andi	r4,r4,255
81131c38:	2002e11e 	bne	r4,zero,811327c0 <___svfiprintf_internal_r+0x123c>
81131c3c:	9080080c 	andi	r2,r18,32
81131c40:	1002011e 	bne	r2,zero,81132448 <___svfiprintf_internal_r+0xec4>
81131c44:	9080040c 	andi	r2,r18,16
81131c48:	10023e1e 	bne	r2,zero,81132544 <___svfiprintf_internal_r+0xfc0>
81131c4c:	9480100c 	andi	r18,r18,64
81131c50:	90023c26 	beq	r18,zero,81132544 <___svfiprintf_internal_r+0xfc0>
81131c54:	dac02317 	ldw	r11,140(sp)
81131c58:	58800017 	ldw	r2,0(r11)
81131c5c:	5ac00104 	addi	r11,r11,4
81131c60:	dac02315 	stw	r11,140(sp)
81131c64:	dac02517 	ldw	r11,148(sp)
81131c68:	12c0000d 	sth	r11,0(r2)
81131c6c:	003e6e06 	br	81131628 <__reset+0xfb111628>
81131c70:	98c00007 	ldb	r3,0(r19)
81131c74:	1a422926 	beq	r3,r9,8113251c <___svfiprintf_internal_r+0xf98>
81131c78:	94800414 	ori	r18,r18,16
81131c7c:	003e9206 	br	811316c8 <__reset+0xfb1116c8>
81131c80:	94801014 	ori	r18,r18,64
81131c84:	98c00007 	ldb	r3,0(r19)
81131c88:	003e8f06 	br	811316c8 <__reset+0xfb1116c8>
81131c8c:	21003fcc 	andi	r4,r4,255
81131c90:	2002c71e 	bne	r4,zero,811327b0 <___svfiprintf_internal_r+0x122c>
81131c94:	9080080c 	andi	r2,r18,32
81131c98:	10004926 	beq	r2,zero,81131dc0 <___svfiprintf_internal_r+0x83c>
81131c9c:	dac02317 	ldw	r11,140(sp)
81131ca0:	58800117 	ldw	r2,4(r11)
81131ca4:	5f000017 	ldw	fp,0(r11)
81131ca8:	5ac00204 	addi	r11,r11,8
81131cac:	dac02315 	stw	r11,140(sp)
81131cb0:	1013883a 	mov	r9,r2
81131cb4:	10004b16 	blt	r2,zero,81131de4 <___svfiprintf_internal_r+0x860>
81131cb8:	da801d83 	ldbu	r10,118(sp)
81131cbc:	8001cb16 	blt	r16,zero,811323ec <___svfiprintf_internal_r+0xe68>
81131cc0:	00ffdfc4 	movi	r3,-129
81131cc4:	e244b03a 	or	r2,fp,r9
81131cc8:	90e4703a 	and	r18,r18,r3
81131ccc:	103f4726 	beq	r2,zero,811319ec <__reset+0xfb1119ec>
81131cd0:	48008c26 	beq	r9,zero,81131f04 <___svfiprintf_internal_r+0x980>
81131cd4:	dc802015 	stw	r18,128(sp)
81131cd8:	dc002115 	stw	r16,132(sp)
81131cdc:	dc401a04 	addi	r17,sp,104
81131ce0:	e021883a 	mov	r16,fp
81131ce4:	da002215 	stw	r8,136(sp)
81131ce8:	5039883a 	mov	fp,r10
81131cec:	4825883a 	mov	r18,r9
81131cf0:	8009883a 	mov	r4,r16
81131cf4:	900b883a 	mov	r5,r18
81131cf8:	01800284 	movi	r6,10
81131cfc:	000f883a 	mov	r7,zero
81131d00:	11358940 	call	81135894 <__umoddi3>
81131d04:	10800c04 	addi	r2,r2,48
81131d08:	8c7fffc4 	addi	r17,r17,-1
81131d0c:	8009883a 	mov	r4,r16
81131d10:	900b883a 	mov	r5,r18
81131d14:	88800005 	stb	r2,0(r17)
81131d18:	01800284 	movi	r6,10
81131d1c:	000f883a 	mov	r7,zero
81131d20:	11353140 	call	81135314 <__udivdi3>
81131d24:	1021883a 	mov	r16,r2
81131d28:	10c4b03a 	or	r2,r2,r3
81131d2c:	1825883a 	mov	r18,r3
81131d30:	103fef1e 	bne	r2,zero,81131cf0 <__reset+0xfb111cf0>
81131d34:	dc802017 	ldw	r18,128(sp)
81131d38:	dc002117 	ldw	r16,132(sp)
81131d3c:	da002217 	ldw	r8,136(sp)
81131d40:	e015883a 	mov	r10,fp
81131d44:	d8c01e17 	ldw	r3,120(sp)
81131d48:	1c47c83a 	sub	r3,r3,r17
81131d4c:	d8c02115 	stw	r3,132(sp)
81131d50:	003f2a06 	br	811319fc <__reset+0xfb1119fc>
81131d54:	dac02317 	ldw	r11,140(sp)
81131d58:	d8001d85 	stb	zero,118(sp)
81131d5c:	5c400017 	ldw	r17,0(r11)
81131d60:	5f000104 	addi	fp,r11,4
81131d64:	88022f26 	beq	r17,zero,81132624 <___svfiprintf_internal_r+0x10a0>
81131d68:	80022516 	blt	r16,zero,81132600 <___svfiprintf_internal_r+0x107c>
81131d6c:	800d883a 	mov	r6,r16
81131d70:	000b883a 	mov	r5,zero
81131d74:	8809883a 	mov	r4,r17
81131d78:	da002c15 	stw	r8,176(sp)
81131d7c:	112d9500 	call	8112d950 <memchr>
81131d80:	da002c17 	ldw	r8,176(sp)
81131d84:	10026426 	beq	r2,zero,81132718 <___svfiprintf_internal_r+0x1194>
81131d88:	1445c83a 	sub	r2,r2,r17
81131d8c:	d8802115 	stw	r2,132(sp)
81131d90:	da801d83 	ldbu	r10,118(sp)
81131d94:	df002315 	stw	fp,140(sp)
81131d98:	0021883a 	mov	r16,zero
81131d9c:	003f1706 	br	811319fc <__reset+0xfb1119fc>
81131da0:	94800814 	ori	r18,r18,32
81131da4:	98c00007 	ldb	r3,0(r19)
81131da8:	003e4706 	br	811316c8 <__reset+0xfb1116c8>
81131dac:	21003fcc 	andi	r4,r4,255
81131db0:	2002701e 	bne	r4,zero,81132774 <___svfiprintf_internal_r+0x11f0>
81131db4:	94800414 	ori	r18,r18,16
81131db8:	9080080c 	andi	r2,r18,32
81131dbc:	103fb71e 	bne	r2,zero,81131c9c <__reset+0xfb111c9c>
81131dc0:	9080040c 	andi	r2,r18,16
81131dc4:	1001ab26 	beq	r2,zero,81132474 <___svfiprintf_internal_r+0xef0>
81131dc8:	dac02317 	ldw	r11,140(sp)
81131dcc:	5f000017 	ldw	fp,0(r11)
81131dd0:	5ac00104 	addi	r11,r11,4
81131dd4:	dac02315 	stw	r11,140(sp)
81131dd8:	e013d7fa 	srai	r9,fp,31
81131ddc:	4805883a 	mov	r2,r9
81131de0:	103fb50e 	bge	r2,zero,81131cb8 <__reset+0xfb111cb8>
81131de4:	0739c83a 	sub	fp,zero,fp
81131de8:	02800b44 	movi	r10,45
81131dec:	e004c03a 	cmpne	r2,fp,zero
81131df0:	0253c83a 	sub	r9,zero,r9
81131df4:	da801d85 	stb	r10,118(sp)
81131df8:	4893c83a 	sub	r9,r9,r2
81131dfc:	80023016 	blt	r16,zero,811326c0 <___svfiprintf_internal_r+0x113c>
81131e00:	00bfdfc4 	movi	r2,-129
81131e04:	90a4703a 	and	r18,r18,r2
81131e08:	483fb21e 	bne	r9,zero,81131cd4 <__reset+0xfb111cd4>
81131e0c:	00003d06 	br	81131f04 <___svfiprintf_internal_r+0x980>
81131e10:	9817883a 	mov	r11,r19
81131e14:	d8002415 	stw	zero,144(sp)
81131e18:	18bff404 	addi	r2,r3,-48
81131e1c:	0019883a 	mov	r12,zero
81131e20:	58c00007 	ldb	r3,0(r11)
81131e24:	630002a4 	muli	r12,r12,10
81131e28:	9cc00044 	addi	r19,r19,1
81131e2c:	9817883a 	mov	r11,r19
81131e30:	1319883a 	add	r12,r2,r12
81131e34:	18bff404 	addi	r2,r3,-48
81131e38:	30bff92e 	bgeu	r6,r2,81131e20 <__reset+0xfb111e20>
81131e3c:	db002415 	stw	r12,144(sp)
81131e40:	18bff804 	addi	r2,r3,-32
81131e44:	28be232e 	bgeu	r5,r2,811316d4 <__reset+0xfb1116d4>
81131e48:	21003fcc 	andi	r4,r4,255
81131e4c:	20024b1e 	bne	r4,zero,8113277c <___svfiprintf_internal_r+0x11f8>
81131e50:	1800d626 	beq	r3,zero,811321ac <___svfiprintf_internal_r+0xc28>
81131e54:	02c00044 	movi	r11,1
81131e58:	dac02015 	stw	r11,128(sp)
81131e5c:	d8c01005 	stb	r3,64(sp)
81131e60:	d8001d85 	stb	zero,118(sp)
81131e64:	dac02115 	stw	r11,132(sp)
81131e68:	dc401004 	addi	r17,sp,64
81131e6c:	003f2606 	br	81131b08 <__reset+0xfb111b08>
81131e70:	94802014 	ori	r18,r18,128
81131e74:	98c00007 	ldb	r3,0(r19)
81131e78:	003e1306 	br	811316c8 <__reset+0xfb1116c8>
81131e7c:	98c00007 	ldb	r3,0(r19)
81131e80:	9ac00044 	addi	r11,r19,1
81131e84:	1a822b26 	beq	r3,r10,81132734 <___svfiprintf_internal_r+0x11b0>
81131e88:	18bff404 	addi	r2,r3,-48
81131e8c:	0021883a 	mov	r16,zero
81131e90:	30821e36 	bltu	r6,r2,8113270c <___svfiprintf_internal_r+0x1188>
81131e94:	58c00007 	ldb	r3,0(r11)
81131e98:	840002a4 	muli	r16,r16,10
81131e9c:	5cc00044 	addi	r19,r11,1
81131ea0:	9817883a 	mov	r11,r19
81131ea4:	80a1883a 	add	r16,r16,r2
81131ea8:	18bff404 	addi	r2,r3,-48
81131eac:	30bff92e 	bgeu	r6,r2,81131e94 <__reset+0xfb111e94>
81131eb0:	803e060e 	bge	r16,zero,811316cc <__reset+0xfb1116cc>
81131eb4:	043fffc4 	movi	r16,-1
81131eb8:	003e0406 	br	811316cc <__reset+0xfb1116cc>
81131ebc:	21003fcc 	andi	r4,r4,255
81131ec0:	2002371e 	bne	r4,zero,811327a0 <___svfiprintf_internal_r+0x121c>
81131ec4:	94800414 	ori	r18,r18,16
81131ec8:	9080080c 	andi	r2,r18,32
81131ecc:	103ebb1e 	bne	r2,zero,811319bc <__reset+0xfb1119bc>
81131ed0:	9080040c 	andi	r2,r18,16
81131ed4:	10013b26 	beq	r2,zero,811323c4 <___svfiprintf_internal_r+0xe40>
81131ed8:	dac02317 	ldw	r11,140(sp)
81131edc:	d8001d85 	stb	zero,118(sp)
81131ee0:	0013883a 	mov	r9,zero
81131ee4:	58800104 	addi	r2,r11,4
81131ee8:	5f000017 	ldw	fp,0(r11)
81131eec:	80013d16 	blt	r16,zero,811323e4 <___svfiprintf_internal_r+0xe60>
81131ef0:	00ffdfc4 	movi	r3,-129
81131ef4:	d8802315 	stw	r2,140(sp)
81131ef8:	90e4703a 	and	r18,r18,r3
81131efc:	0015883a 	mov	r10,zero
81131f00:	e03eba26 	beq	fp,zero,811319ec <__reset+0xfb1119ec>
81131f04:	00800244 	movi	r2,9
81131f08:	173f7236 	bltu	r2,fp,81131cd4 <__reset+0xfb111cd4>
81131f0c:	dac02b17 	ldw	r11,172(sp)
81131f10:	e7000c04 	addi	fp,fp,48
81131f14:	df0019c5 	stb	fp,103(sp)
81131f18:	dac02115 	stw	r11,132(sp)
81131f1c:	dc4019c4 	addi	r17,sp,103
81131f20:	003eb606 	br	811319fc <__reset+0xfb1119fc>
81131f24:	21003fcc 	andi	r4,r4,255
81131f28:	20021f1e 	bne	r4,zero,811327a8 <___svfiprintf_internal_r+0x1224>
81131f2c:	94800414 	ori	r18,r18,16
81131f30:	9080080c 	andi	r2,r18,32
81131f34:	103ec51e 	bne	r2,zero,81131a4c <__reset+0xfb111a4c>
81131f38:	9080040c 	andi	r2,r18,16
81131f3c:	10016926 	beq	r2,zero,811324e4 <___svfiprintf_internal_r+0xf60>
81131f40:	dac02317 	ldw	r11,140(sp)
81131f44:	d8001d85 	stb	zero,118(sp)
81131f48:	0013883a 	mov	r9,zero
81131f4c:	58800104 	addi	r2,r11,4
81131f50:	5f000017 	ldw	fp,0(r11)
81131f54:	80016b16 	blt	r16,zero,81132504 <___svfiprintf_internal_r+0xf80>
81131f58:	00ffdfc4 	movi	r3,-129
81131f5c:	d8802315 	stw	r2,140(sp)
81131f60:	90e4703a 	and	r18,r18,r3
81131f64:	e03ec41e 	bne	fp,zero,81131a78 <__reset+0xfb111a78>
81131f68:	0015883a 	mov	r10,zero
81131f6c:	8001c226 	beq	r16,zero,81132678 <___svfiprintf_internal_r+0x10f4>
81131f70:	0039883a 	mov	fp,zero
81131f74:	0013883a 	mov	r9,zero
81131f78:	003ec006 	br	81131a7c <__reset+0xfb111a7c>
81131f7c:	d8c01c17 	ldw	r3,112(sp)
81131f80:	d8801b17 	ldw	r2,108(sp)
81131f84:	d9001d87 	ldb	r4,118(sp)
81131f88:	20000b26 	beq	r4,zero,81131fb8 <___svfiprintf_internal_r+0xa34>
81131f8c:	d9001d84 	addi	r4,sp,118
81131f90:	18c00044 	addi	r3,r3,1
81131f94:	10800044 	addi	r2,r2,1
81131f98:	41000015 	stw	r4,0(r8)
81131f9c:	01000044 	movi	r4,1
81131fa0:	41000115 	stw	r4,4(r8)
81131fa4:	d8c01c15 	stw	r3,112(sp)
81131fa8:	d8801b15 	stw	r2,108(sp)
81131fac:	010001c4 	movi	r4,7
81131fb0:	2080e116 	blt	r4,r2,81132338 <___svfiprintf_internal_r+0xdb4>
81131fb4:	42000204 	addi	r8,r8,8
81131fb8:	dac02217 	ldw	r11,136(sp)
81131fbc:	58000b26 	beq	r11,zero,81131fec <___svfiprintf_internal_r+0xa68>
81131fc0:	d9001d04 	addi	r4,sp,116
81131fc4:	18c00084 	addi	r3,r3,2
81131fc8:	10800044 	addi	r2,r2,1
81131fcc:	41000015 	stw	r4,0(r8)
81131fd0:	01000084 	movi	r4,2
81131fd4:	41000115 	stw	r4,4(r8)
81131fd8:	d8c01c15 	stw	r3,112(sp)
81131fdc:	d8801b15 	stw	r2,108(sp)
81131fe0:	010001c4 	movi	r4,7
81131fe4:	2080dd16 	blt	r4,r2,8113235c <___svfiprintf_internal_r+0xdd8>
81131fe8:	42000204 	addi	r8,r8,8
81131fec:	dac02617 	ldw	r11,152(sp)
81131ff0:	01002004 	movi	r4,128
81131ff4:	59008426 	beq	r11,r4,81132208 <___svfiprintf_internal_r+0xc84>
81131ff8:	dac02117 	ldw	r11,132(sp)
81131ffc:	82e1c83a 	sub	r16,r16,r11
81132000:	0400270e 	bge	zero,r16,811320a0 <___svfiprintf_internal_r+0xb1c>
81132004:	01c00404 	movi	r7,16
81132008:	3c016a0e 	bge	r7,r16,811325b4 <___svfiprintf_internal_r+0x1030>
8113200c:	01604574 	movhi	r5,33045
81132010:	2947ac04 	addi	r5,r5,7856
81132014:	d9402215 	stw	r5,136(sp)
81132018:	070001c4 	movi	fp,7
8113201c:	00000306 	br	8113202c <___svfiprintf_internal_r+0xaa8>
81132020:	843ffc04 	addi	r16,r16,-16
81132024:	42000204 	addi	r8,r8,8
81132028:	3c00130e 	bge	r7,r16,81132078 <___svfiprintf_internal_r+0xaf4>
8113202c:	18c00404 	addi	r3,r3,16
81132030:	10800044 	addi	r2,r2,1
81132034:	45000015 	stw	r20,0(r8)
81132038:	41c00115 	stw	r7,4(r8)
8113203c:	d8c01c15 	stw	r3,112(sp)
81132040:	d8801b15 	stw	r2,108(sp)
81132044:	e0bff60e 	bge	fp,r2,81132020 <__reset+0xfb112020>
81132048:	d9801a04 	addi	r6,sp,104
8113204c:	b80b883a 	mov	r5,r23
81132050:	a809883a 	mov	r4,r21
81132054:	d9c02c15 	stw	r7,176(sp)
81132058:	11313ac0 	call	811313ac <__ssprint_r>
8113205c:	d9c02c17 	ldw	r7,176(sp)
81132060:	1000581e 	bne	r2,zero,811321c4 <___svfiprintf_internal_r+0xc40>
81132064:	843ffc04 	addi	r16,r16,-16
81132068:	d8c01c17 	ldw	r3,112(sp)
8113206c:	d8801b17 	ldw	r2,108(sp)
81132070:	d811883a 	mov	r8,sp
81132074:	3c3fed16 	blt	r7,r16,8113202c <__reset+0xfb11202c>
81132078:	dac02217 	ldw	r11,136(sp)
8113207c:	1c07883a 	add	r3,r3,r16
81132080:	10800044 	addi	r2,r2,1
81132084:	42c00015 	stw	r11,0(r8)
81132088:	44000115 	stw	r16,4(r8)
8113208c:	d8c01c15 	stw	r3,112(sp)
81132090:	d8801b15 	stw	r2,108(sp)
81132094:	010001c4 	movi	r4,7
81132098:	20809e16 	blt	r4,r2,81132314 <___svfiprintf_internal_r+0xd90>
8113209c:	42000204 	addi	r8,r8,8
811320a0:	dac02117 	ldw	r11,132(sp)
811320a4:	10800044 	addi	r2,r2,1
811320a8:	44400015 	stw	r17,0(r8)
811320ac:	58c7883a 	add	r3,r11,r3
811320b0:	42c00115 	stw	r11,4(r8)
811320b4:	d8c01c15 	stw	r3,112(sp)
811320b8:	d8801b15 	stw	r2,108(sp)
811320bc:	010001c4 	movi	r4,7
811320c0:	20807f16 	blt	r4,r2,811322c0 <___svfiprintf_internal_r+0xd3c>
811320c4:	42000204 	addi	r8,r8,8
811320c8:	9480010c 	andi	r18,r18,4
811320cc:	90002926 	beq	r18,zero,81132174 <___svfiprintf_internal_r+0xbf0>
811320d0:	dac02417 	ldw	r11,144(sp)
811320d4:	d8802017 	ldw	r2,128(sp)
811320d8:	58a1c83a 	sub	r16,r11,r2
811320dc:	0400250e 	bge	zero,r16,81132174 <___svfiprintf_internal_r+0xbf0>
811320e0:	04400404 	movi	r17,16
811320e4:	d8801b17 	ldw	r2,108(sp)
811320e8:	8c017c0e 	bge	r17,r16,811326dc <___svfiprintf_internal_r+0x1158>
811320ec:	01604574 	movhi	r5,33045
811320f0:	2947b004 	addi	r5,r5,7872
811320f4:	d9402815 	stw	r5,160(sp)
811320f8:	048001c4 	movi	r18,7
811320fc:	00000306 	br	8113210c <___svfiprintf_internal_r+0xb88>
81132100:	843ffc04 	addi	r16,r16,-16
81132104:	42000204 	addi	r8,r8,8
81132108:	8c00110e 	bge	r17,r16,81132150 <___svfiprintf_internal_r+0xbcc>
8113210c:	18c00404 	addi	r3,r3,16
81132110:	10800044 	addi	r2,r2,1
81132114:	45800015 	stw	r22,0(r8)
81132118:	44400115 	stw	r17,4(r8)
8113211c:	d8c01c15 	stw	r3,112(sp)
81132120:	d8801b15 	stw	r2,108(sp)
81132124:	90bff60e 	bge	r18,r2,81132100 <__reset+0xfb112100>
81132128:	d9801a04 	addi	r6,sp,104
8113212c:	b80b883a 	mov	r5,r23
81132130:	a809883a 	mov	r4,r21
81132134:	11313ac0 	call	811313ac <__ssprint_r>
81132138:	1000221e 	bne	r2,zero,811321c4 <___svfiprintf_internal_r+0xc40>
8113213c:	843ffc04 	addi	r16,r16,-16
81132140:	d8c01c17 	ldw	r3,112(sp)
81132144:	d8801b17 	ldw	r2,108(sp)
81132148:	d811883a 	mov	r8,sp
8113214c:	8c3fef16 	blt	r17,r16,8113210c <__reset+0xfb11210c>
81132150:	dac02817 	ldw	r11,160(sp)
81132154:	1c07883a 	add	r3,r3,r16
81132158:	10800044 	addi	r2,r2,1
8113215c:	42c00015 	stw	r11,0(r8)
81132160:	44000115 	stw	r16,4(r8)
81132164:	d8c01c15 	stw	r3,112(sp)
81132168:	d8801b15 	stw	r2,108(sp)
8113216c:	010001c4 	movi	r4,7
81132170:	2080aa16 	blt	r4,r2,8113241c <___svfiprintf_internal_r+0xe98>
81132174:	d8802417 	ldw	r2,144(sp)
81132178:	dac02017 	ldw	r11,128(sp)
8113217c:	12c0010e 	bge	r2,r11,81132184 <___svfiprintf_internal_r+0xc00>
81132180:	5805883a 	mov	r2,r11
81132184:	dac02517 	ldw	r11,148(sp)
81132188:	5897883a 	add	r11,r11,r2
8113218c:	dac02515 	stw	r11,148(sp)
81132190:	1800531e 	bne	r3,zero,811322e0 <___svfiprintf_internal_r+0xd5c>
81132194:	98800007 	ldb	r2,0(r19)
81132198:	d8001b15 	stw	zero,108(sp)
8113219c:	d811883a 	mov	r8,sp
811321a0:	103d231e 	bne	r2,zero,81131630 <__reset+0xfb111630>
811321a4:	9823883a 	mov	r17,r19
811321a8:	003d3906 	br	81131690 <__reset+0xfb111690>
811321ac:	d8801c17 	ldw	r2,112(sp)
811321b0:	10000426 	beq	r2,zero,811321c4 <___svfiprintf_internal_r+0xc40>
811321b4:	d9402717 	ldw	r5,156(sp)
811321b8:	d9002a17 	ldw	r4,168(sp)
811321bc:	d9801a04 	addi	r6,sp,104
811321c0:	11313ac0 	call	811313ac <__ssprint_r>
811321c4:	dac02717 	ldw	r11,156(sp)
811321c8:	d8802517 	ldw	r2,148(sp)
811321cc:	58c0030b 	ldhu	r3,12(r11)
811321d0:	18c0100c 	andi	r3,r3,64
811321d4:	1801381e 	bne	r3,zero,811326b8 <___svfiprintf_internal_r+0x1134>
811321d8:	dfc03717 	ldw	ra,220(sp)
811321dc:	df003617 	ldw	fp,216(sp)
811321e0:	ddc03517 	ldw	r23,212(sp)
811321e4:	dd803417 	ldw	r22,208(sp)
811321e8:	dd403317 	ldw	r21,204(sp)
811321ec:	dd003217 	ldw	r20,200(sp)
811321f0:	dcc03117 	ldw	r19,196(sp)
811321f4:	dc803017 	ldw	r18,192(sp)
811321f8:	dc402f17 	ldw	r17,188(sp)
811321fc:	dc002e17 	ldw	r16,184(sp)
81132200:	dec03804 	addi	sp,sp,224
81132204:	f800283a 	ret
81132208:	dac02417 	ldw	r11,144(sp)
8113220c:	d9002017 	ldw	r4,128(sp)
81132210:	5939c83a 	sub	fp,r11,r4
81132214:	073f780e 	bge	zero,fp,81131ff8 <__reset+0xfb111ff8>
81132218:	02400404 	movi	r9,16
8113221c:	4f01370e 	bge	r9,fp,811326fc <___svfiprintf_internal_r+0x1178>
81132220:	02e04574 	movhi	r11,33045
81132224:	5ac7ac04 	addi	r11,r11,7856
81132228:	dac02215 	stw	r11,136(sp)
8113222c:	028001c4 	movi	r10,7
81132230:	00000306 	br	81132240 <___svfiprintf_internal_r+0xcbc>
81132234:	e73ffc04 	addi	fp,fp,-16
81132238:	42000204 	addi	r8,r8,8
8113223c:	4f00150e 	bge	r9,fp,81132294 <___svfiprintf_internal_r+0xd10>
81132240:	18c00404 	addi	r3,r3,16
81132244:	10800044 	addi	r2,r2,1
81132248:	45000015 	stw	r20,0(r8)
8113224c:	42400115 	stw	r9,4(r8)
81132250:	d8c01c15 	stw	r3,112(sp)
81132254:	d8801b15 	stw	r2,108(sp)
81132258:	50bff60e 	bge	r10,r2,81132234 <__reset+0xfb112234>
8113225c:	d9801a04 	addi	r6,sp,104
81132260:	b80b883a 	mov	r5,r23
81132264:	a809883a 	mov	r4,r21
81132268:	da402c15 	stw	r9,176(sp)
8113226c:	da802d15 	stw	r10,180(sp)
81132270:	11313ac0 	call	811313ac <__ssprint_r>
81132274:	da402c17 	ldw	r9,176(sp)
81132278:	da802d17 	ldw	r10,180(sp)
8113227c:	103fd11e 	bne	r2,zero,811321c4 <__reset+0xfb1121c4>
81132280:	e73ffc04 	addi	fp,fp,-16
81132284:	d8c01c17 	ldw	r3,112(sp)
81132288:	d8801b17 	ldw	r2,108(sp)
8113228c:	d811883a 	mov	r8,sp
81132290:	4f3feb16 	blt	r9,fp,81132240 <__reset+0xfb112240>
81132294:	dac02217 	ldw	r11,136(sp)
81132298:	1f07883a 	add	r3,r3,fp
8113229c:	10800044 	addi	r2,r2,1
811322a0:	42c00015 	stw	r11,0(r8)
811322a4:	47000115 	stw	fp,4(r8)
811322a8:	d8c01c15 	stw	r3,112(sp)
811322ac:	d8801b15 	stw	r2,108(sp)
811322b0:	010001c4 	movi	r4,7
811322b4:	2080b616 	blt	r4,r2,81132590 <___svfiprintf_internal_r+0x100c>
811322b8:	42000204 	addi	r8,r8,8
811322bc:	003f4e06 	br	81131ff8 <__reset+0xfb111ff8>
811322c0:	d9801a04 	addi	r6,sp,104
811322c4:	b80b883a 	mov	r5,r23
811322c8:	a809883a 	mov	r4,r21
811322cc:	11313ac0 	call	811313ac <__ssprint_r>
811322d0:	103fbc1e 	bne	r2,zero,811321c4 <__reset+0xfb1121c4>
811322d4:	d8c01c17 	ldw	r3,112(sp)
811322d8:	d811883a 	mov	r8,sp
811322dc:	003f7a06 	br	811320c8 <__reset+0xfb1120c8>
811322e0:	d9801a04 	addi	r6,sp,104
811322e4:	b80b883a 	mov	r5,r23
811322e8:	a809883a 	mov	r4,r21
811322ec:	11313ac0 	call	811313ac <__ssprint_r>
811322f0:	103fa826 	beq	r2,zero,81132194 <__reset+0xfb112194>
811322f4:	003fb306 	br	811321c4 <__reset+0xfb1121c4>
811322f8:	d9801a04 	addi	r6,sp,104
811322fc:	b80b883a 	mov	r5,r23
81132300:	a809883a 	mov	r4,r21
81132304:	11313ac0 	call	811313ac <__ssprint_r>
81132308:	103fae1e 	bne	r2,zero,811321c4 <__reset+0xfb1121c4>
8113230c:	d811883a 	mov	r8,sp
81132310:	003cdc06 	br	81131684 <__reset+0xfb111684>
81132314:	d9801a04 	addi	r6,sp,104
81132318:	b80b883a 	mov	r5,r23
8113231c:	a809883a 	mov	r4,r21
81132320:	11313ac0 	call	811313ac <__ssprint_r>
81132324:	103fa71e 	bne	r2,zero,811321c4 <__reset+0xfb1121c4>
81132328:	d8c01c17 	ldw	r3,112(sp)
8113232c:	d8801b17 	ldw	r2,108(sp)
81132330:	d811883a 	mov	r8,sp
81132334:	003f5a06 	br	811320a0 <__reset+0xfb1120a0>
81132338:	d9801a04 	addi	r6,sp,104
8113233c:	b80b883a 	mov	r5,r23
81132340:	a809883a 	mov	r4,r21
81132344:	11313ac0 	call	811313ac <__ssprint_r>
81132348:	103f9e1e 	bne	r2,zero,811321c4 <__reset+0xfb1121c4>
8113234c:	d8c01c17 	ldw	r3,112(sp)
81132350:	d8801b17 	ldw	r2,108(sp)
81132354:	d811883a 	mov	r8,sp
81132358:	003f1706 	br	81131fb8 <__reset+0xfb111fb8>
8113235c:	d9801a04 	addi	r6,sp,104
81132360:	b80b883a 	mov	r5,r23
81132364:	a809883a 	mov	r4,r21
81132368:	11313ac0 	call	811313ac <__ssprint_r>
8113236c:	103f951e 	bne	r2,zero,811321c4 <__reset+0xfb1121c4>
81132370:	d8c01c17 	ldw	r3,112(sp)
81132374:	d8801b17 	ldw	r2,108(sp)
81132378:	d811883a 	mov	r8,sp
8113237c:	003f1b06 	br	81131fec <__reset+0xfb111fec>
81132380:	d8001d85 	stb	zero,118(sp)
81132384:	80007b16 	blt	r16,zero,81132574 <___svfiprintf_internal_r+0xff0>
81132388:	00ffdfc4 	movi	r3,-129
8113238c:	e244b03a 	or	r2,fp,r9
81132390:	90e4703a 	and	r18,r18,r3
81132394:	103d7026 	beq	r2,zero,81131958 <__reset+0xfb111958>
81132398:	0015883a 	mov	r10,zero
8113239c:	003d7206 	br	81131968 <__reset+0xfb111968>
811323a0:	d9801a04 	addi	r6,sp,104
811323a4:	b80b883a 	mov	r5,r23
811323a8:	a809883a 	mov	r4,r21
811323ac:	11313ac0 	call	811313ac <__ssprint_r>
811323b0:	103f841e 	bne	r2,zero,811321c4 <__reset+0xfb1121c4>
811323b4:	d8c01c17 	ldw	r3,112(sp)
811323b8:	d8801b17 	ldw	r2,108(sp)
811323bc:	d811883a 	mov	r8,sp
811323c0:	003ef006 	br	81131f84 <__reset+0xfb111f84>
811323c4:	9080100c 	andi	r2,r18,64
811323c8:	d8001d85 	stb	zero,118(sp)
811323cc:	dac02317 	ldw	r11,140(sp)
811323d0:	10008126 	beq	r2,zero,811325d8 <___svfiprintf_internal_r+0x1054>
811323d4:	58800104 	addi	r2,r11,4
811323d8:	5f00000b 	ldhu	fp,0(r11)
811323dc:	0013883a 	mov	r9,zero
811323e0:	803ec30e 	bge	r16,zero,81131ef0 <__reset+0xfb111ef0>
811323e4:	d8802315 	stw	r2,140(sp)
811323e8:	0015883a 	mov	r10,zero
811323ec:	e244b03a 	or	r2,fp,r9
811323f0:	103e371e 	bne	r2,zero,81131cd0 <__reset+0xfb111cd0>
811323f4:	00800044 	movi	r2,1
811323f8:	10803fcc 	andi	r2,r2,255
811323fc:	00c00044 	movi	r3,1
81132400:	10c06126 	beq	r2,r3,81132588 <___svfiprintf_internal_r+0x1004>
81132404:	00c00084 	movi	r3,2
81132408:	10fd5526 	beq	r2,r3,81131960 <__reset+0xfb111960>
8113240c:	003ed806 	br	81131f70 <__reset+0xfb111f70>
81132410:	d8802315 	stw	r2,140(sp)
81132414:	98c00007 	ldb	r3,0(r19)
81132418:	003cab06 	br	811316c8 <__reset+0xfb1116c8>
8113241c:	d9801a04 	addi	r6,sp,104
81132420:	b80b883a 	mov	r5,r23
81132424:	a809883a 	mov	r4,r21
81132428:	11313ac0 	call	811313ac <__ssprint_r>
8113242c:	103f651e 	bne	r2,zero,811321c4 <__reset+0xfb1121c4>
81132430:	d8c01c17 	ldw	r3,112(sp)
81132434:	003f4f06 	br	81132174 <__reset+0xfb112174>
81132438:	00a04574 	movhi	r2,33045
8113243c:	10872204 	addi	r2,r2,7304
81132440:	d8802915 	stw	r2,164(sp)
81132444:	003d4406 	br	81131958 <__reset+0xfb111958>
81132448:	dac02317 	ldw	r11,140(sp)
8113244c:	58800017 	ldw	r2,0(r11)
81132450:	dac02517 	ldw	r11,148(sp)
81132454:	5807d7fa 	srai	r3,r11,31
81132458:	dac02317 	ldw	r11,140(sp)
8113245c:	10c00115 	stw	r3,4(r2)
81132460:	5ac00104 	addi	r11,r11,4
81132464:	dac02315 	stw	r11,140(sp)
81132468:	dac02517 	ldw	r11,148(sp)
8113246c:	12c00015 	stw	r11,0(r2)
81132470:	003c6d06 	br	81131628 <__reset+0xfb111628>
81132474:	9080100c 	andi	r2,r18,64
81132478:	dac02317 	ldw	r11,140(sp)
8113247c:	103e5326 	beq	r2,zero,81131dcc <__reset+0xfb111dcc>
81132480:	5f00000f 	ldh	fp,0(r11)
81132484:	5ac00104 	addi	r11,r11,4
81132488:	dac02315 	stw	r11,140(sp)
8113248c:	e013d7fa 	srai	r9,fp,31
81132490:	4805883a 	mov	r2,r9
81132494:	003e0706 	br	81131cb4 <__reset+0xfb111cb4>
81132498:	00800c04 	movi	r2,48
8113249c:	d8801d05 	stb	r2,116(sp)
811324a0:	d8c01d45 	stb	r3,117(sp)
811324a4:	d8001d85 	stb	zero,118(sp)
811324a8:	90800094 	ori	r2,r18,2
811324ac:	80008f16 	blt	r16,zero,811326ec <___svfiprintf_internal_r+0x1168>
811324b0:	00bfdfc4 	movi	r2,-129
811324b4:	90a4703a 	and	r18,r18,r2
811324b8:	94800094 	ori	r18,r18,2
811324bc:	0015883a 	mov	r10,zero
811324c0:	003d2906 	br	81131968 <__reset+0xfb111968>
811324c4:	98c00007 	ldb	r3,0(r19)
811324c8:	003c7f06 	br	811316c8 <__reset+0xfb1116c8>
811324cc:	dac02317 	ldw	r11,140(sp)
811324d0:	0013883a 	mov	r9,zero
811324d4:	5f000017 	ldw	fp,0(r11)
811324d8:	5ac00104 	addi	r11,r11,4
811324dc:	dac02315 	stw	r11,140(sp)
811324e0:	003d1506 	br	81131938 <__reset+0xfb111938>
811324e4:	9080100c 	andi	r2,r18,64
811324e8:	d8001d85 	stb	zero,118(sp)
811324ec:	dac02317 	ldw	r11,140(sp)
811324f0:	10003426 	beq	r2,zero,811325c4 <___svfiprintf_internal_r+0x1040>
811324f4:	58800104 	addi	r2,r11,4
811324f8:	5f00000b 	ldhu	fp,0(r11)
811324fc:	0013883a 	mov	r9,zero
81132500:	803e950e 	bge	r16,zero,81131f58 <__reset+0xfb111f58>
81132504:	e246b03a 	or	r3,fp,r9
81132508:	d8802315 	stw	r2,140(sp)
8113250c:	183d5a1e 	bne	r3,zero,81131a78 <__reset+0xfb111a78>
81132510:	0015883a 	mov	r10,zero
81132514:	0005883a 	mov	r2,zero
81132518:	003fb706 	br	811323f8 <__reset+0xfb1123f8>
8113251c:	98c00043 	ldbu	r3,1(r19)
81132520:	94800814 	ori	r18,r18,32
81132524:	9cc00044 	addi	r19,r19,1
81132528:	18c03fcc 	andi	r3,r3,255
8113252c:	18c0201c 	xori	r3,r3,128
81132530:	18ffe004 	addi	r3,r3,-128
81132534:	003c6406 	br	811316c8 <__reset+0xfb1116c8>
81132538:	d8c02315 	stw	r3,140(sp)
8113253c:	0015883a 	mov	r10,zero
81132540:	003faa06 	br	811323ec <__reset+0xfb1123ec>
81132544:	dac02317 	ldw	r11,140(sp)
81132548:	58800017 	ldw	r2,0(r11)
8113254c:	5ac00104 	addi	r11,r11,4
81132550:	dac02315 	stw	r11,140(sp)
81132554:	dac02517 	ldw	r11,148(sp)
81132558:	12c00015 	stw	r11,0(r2)
8113255c:	003c3206 	br	81131628 <__reset+0xfb111628>
81132560:	01204574 	movhi	r4,33045
81132564:	21072204 	addi	r4,r4,7304
81132568:	d9002915 	stw	r4,164(sp)
8113256c:	d8c02315 	stw	r3,140(sp)
81132570:	1025883a 	mov	r18,r2
81132574:	e244b03a 	or	r2,fp,r9
81132578:	103f871e 	bne	r2,zero,81132398 <__reset+0xfb112398>
8113257c:	0015883a 	mov	r10,zero
81132580:	00800084 	movi	r2,2
81132584:	003f9c06 	br	811323f8 <__reset+0xfb1123f8>
81132588:	0039883a 	mov	fp,zero
8113258c:	003e5f06 	br	81131f0c <__reset+0xfb111f0c>
81132590:	d9801a04 	addi	r6,sp,104
81132594:	b80b883a 	mov	r5,r23
81132598:	a809883a 	mov	r4,r21
8113259c:	11313ac0 	call	811313ac <__ssprint_r>
811325a0:	103f081e 	bne	r2,zero,811321c4 <__reset+0xfb1121c4>
811325a4:	d8c01c17 	ldw	r3,112(sp)
811325a8:	d8801b17 	ldw	r2,108(sp)
811325ac:	d811883a 	mov	r8,sp
811325b0:	003e9106 	br	81131ff8 <__reset+0xfb111ff8>
811325b4:	01204574 	movhi	r4,33045
811325b8:	2107ac04 	addi	r4,r4,7856
811325bc:	d9002215 	stw	r4,136(sp)
811325c0:	003ead06 	br	81132078 <__reset+0xfb112078>
811325c4:	58800104 	addi	r2,r11,4
811325c8:	5f000017 	ldw	fp,0(r11)
811325cc:	0013883a 	mov	r9,zero
811325d0:	803e610e 	bge	r16,zero,81131f58 <__reset+0xfb111f58>
811325d4:	003fcb06 	br	81132504 <__reset+0xfb112504>
811325d8:	58800104 	addi	r2,r11,4
811325dc:	5f000017 	ldw	fp,0(r11)
811325e0:	0013883a 	mov	r9,zero
811325e4:	803e420e 	bge	r16,zero,81131ef0 <__reset+0xfb111ef0>
811325e8:	003f7e06 	br	811323e4 <__reset+0xfb1123e4>
811325ec:	5f000017 	ldw	fp,0(r11)
811325f0:	5ac00104 	addi	r11,r11,4
811325f4:	0013883a 	mov	r9,zero
811325f8:	dac02315 	stw	r11,140(sp)
811325fc:	003cce06 	br	81131938 <__reset+0xfb111938>
81132600:	8809883a 	mov	r4,r17
81132604:	da002c15 	stw	r8,176(sp)
81132608:	11244540 	call	81124454 <strlen>
8113260c:	d8802115 	stw	r2,132(sp)
81132610:	da801d83 	ldbu	r10,118(sp)
81132614:	df002315 	stw	fp,140(sp)
81132618:	0021883a 	mov	r16,zero
8113261c:	da002c17 	ldw	r8,176(sp)
81132620:	003cf606 	br	811319fc <__reset+0xfb1119fc>
81132624:	00800184 	movi	r2,6
81132628:	1400012e 	bgeu	r2,r16,81132630 <___svfiprintf_internal_r+0x10ac>
8113262c:	1021883a 	mov	r16,r2
81132630:	dc002115 	stw	r16,132(sp)
81132634:	8005883a 	mov	r2,r16
81132638:	80003c16 	blt	r16,zero,8113272c <___svfiprintf_internal_r+0x11a8>
8113263c:	04604574 	movhi	r17,33045
81132640:	d8802015 	stw	r2,128(sp)
81132644:	df002315 	stw	fp,140(sp)
81132648:	8c472704 	addi	r17,r17,7324
8113264c:	003d2e06 	br	81131b08 <__reset+0xfb111b08>
81132650:	04001004 	movi	r16,64
81132654:	800b883a 	mov	r5,r16
81132658:	11231c80 	call	811231c8 <_malloc_r>
8113265c:	dac02717 	ldw	r11,156(sp)
81132660:	58800015 	stw	r2,0(r11)
81132664:	58800415 	stw	r2,16(r11)
81132668:	10004826 	beq	r2,zero,8113278c <___svfiprintf_internal_r+0x1208>
8113266c:	dac02717 	ldw	r11,156(sp)
81132670:	5c000515 	stw	r16,20(r11)
81132674:	003bd906 	br	811315dc <__reset+0xfb1115dc>
81132678:	9080004c 	andi	r2,r18,1
8113267c:	0015883a 	mov	r10,zero
81132680:	10000626 	beq	r2,zero,8113269c <___svfiprintf_internal_r+0x1118>
81132684:	dac02b17 	ldw	r11,172(sp)
81132688:	00800c04 	movi	r2,48
8113268c:	d88019c5 	stb	r2,103(sp)
81132690:	dac02115 	stw	r11,132(sp)
81132694:	dc4019c4 	addi	r17,sp,103
81132698:	003cd806 	br	811319fc <__reset+0xfb1119fc>
8113269c:	d8002115 	stw	zero,132(sp)
811326a0:	dc401a04 	addi	r17,sp,104
811326a4:	003cd506 	br	811319fc <__reset+0xfb1119fc>
811326a8:	01204574 	movhi	r4,33045
811326ac:	2107b004 	addi	r4,r4,7872
811326b0:	d9002815 	stw	r4,160(sp)
811326b4:	003d4306 	br	81131bc4 <__reset+0xfb111bc4>
811326b8:	00bfffc4 	movi	r2,-1
811326bc:	003ec606 	br	811321d8 <__reset+0xfb1121d8>
811326c0:	00800044 	movi	r2,1
811326c4:	10803fcc 	andi	r2,r2,255
811326c8:	00c00044 	movi	r3,1
811326cc:	10fd8026 	beq	r2,r3,81131cd0 <__reset+0xfb111cd0>
811326d0:	00c00084 	movi	r3,2
811326d4:	10fca426 	beq	r2,r3,81131968 <__reset+0xfb111968>
811326d8:	003ce806 	br	81131a7c <__reset+0xfb111a7c>
811326dc:	01204574 	movhi	r4,33045
811326e0:	2107b004 	addi	r4,r4,7872
811326e4:	d9002815 	stw	r4,160(sp)
811326e8:	003e9906 	br	81132150 <__reset+0xfb112150>
811326ec:	1025883a 	mov	r18,r2
811326f0:	0015883a 	mov	r10,zero
811326f4:	00800084 	movi	r2,2
811326f8:	003ff206 	br	811326c4 <__reset+0xfb1126c4>
811326fc:	01604574 	movhi	r5,33045
81132700:	2947ac04 	addi	r5,r5,7856
81132704:	d9402215 	stw	r5,136(sp)
81132708:	003ee206 	br	81132294 <__reset+0xfb112294>
8113270c:	5827883a 	mov	r19,r11
81132710:	0021883a 	mov	r16,zero
81132714:	003bed06 	br	811316cc <__reset+0xfb1116cc>
81132718:	dc002115 	stw	r16,132(sp)
8113271c:	da801d83 	ldbu	r10,118(sp)
81132720:	df002315 	stw	fp,140(sp)
81132724:	0021883a 	mov	r16,zero
81132728:	003cb406 	br	811319fc <__reset+0xfb1119fc>
8113272c:	0005883a 	mov	r2,zero
81132730:	003fc206 	br	8113263c <__reset+0xfb11263c>
81132734:	d8802317 	ldw	r2,140(sp)
81132738:	98c00043 	ldbu	r3,1(r19)
8113273c:	5827883a 	mov	r19,r11
81132740:	14000017 	ldw	r16,0(r2)
81132744:	10800104 	addi	r2,r2,4
81132748:	d8802315 	stw	r2,140(sp)
8113274c:	803f760e 	bge	r16,zero,81132528 <__reset+0xfb112528>
81132750:	18c03fcc 	andi	r3,r3,255
81132754:	18c0201c 	xori	r3,r3,128
81132758:	043fffc4 	movi	r16,-1
8113275c:	18ffe004 	addi	r3,r3,-128
81132760:	003bd906 	br	811316c8 <__reset+0xfb1116c8>
81132764:	d9c01d85 	stb	r7,118(sp)
81132768:	003cb606 	br	81131a44 <__reset+0xfb111a44>
8113276c:	d9c01d85 	stb	r7,118(sp)
81132770:	003d2106 	br	81131bf8 <__reset+0xfb111bf8>
81132774:	d9c01d85 	stb	r7,118(sp)
81132778:	003d8e06 	br	81131db4 <__reset+0xfb111db4>
8113277c:	d9c01d85 	stb	r7,118(sp)
81132780:	003db306 	br	81131e50 <__reset+0xfb111e50>
81132784:	d9c01d85 	stb	r7,118(sp)
81132788:	003c8a06 	br	811319b4 <__reset+0xfb1119b4>
8113278c:	dac02a17 	ldw	r11,168(sp)
81132790:	00800304 	movi	r2,12
81132794:	58800015 	stw	r2,0(r11)
81132798:	00bfffc4 	movi	r2,-1
8113279c:	003e8e06 	br	811321d8 <__reset+0xfb1121d8>
811327a0:	d9c01d85 	stb	r7,118(sp)
811327a4:	003dc706 	br	81131ec4 <__reset+0xfb111ec4>
811327a8:	d9c01d85 	stb	r7,118(sp)
811327ac:	003ddf06 	br	81131f2c <__reset+0xfb111f2c>
811327b0:	d9c01d85 	stb	r7,118(sp)
811327b4:	003d3706 	br	81131c94 <__reset+0xfb111c94>
811327b8:	d9c01d85 	stb	r7,118(sp)
811327bc:	003c5406 	br	81131910 <__reset+0xfb111910>
811327c0:	d9c01d85 	stb	r7,118(sp)
811327c4:	003d1d06 	br	81131c3c <__reset+0xfb111c3c>

811327c8 <__submore>:
811327c8:	defffa04 	addi	sp,sp,-24
811327cc:	de00012e 	bgeu	sp,et,811327d4 <__submore+0xc>
811327d0:	003b68fa 	trap	3
811327d4:	dc000015 	stw	r16,0(sp)
811327d8:	2821883a 	mov	r16,r5
811327dc:	29400c17 	ldw	r5,48(r5)
811327e0:	dfc00515 	stw	ra,20(sp)
811327e4:	dd000415 	stw	r20,16(sp)
811327e8:	dcc00315 	stw	r19,12(sp)
811327ec:	dc800215 	stw	r18,8(sp)
811327f0:	dc400115 	stw	r17,4(sp)
811327f4:	80801004 	addi	r2,r16,64
811327f8:	28801726 	beq	r5,r2,81132858 <__submore+0x90>
811327fc:	84400d17 	ldw	r17,52(r16)
81132800:	8c67883a 	add	r19,r17,r17
81132804:	980d883a 	mov	r6,r19
81132808:	112ec540 	call	8112ec54 <_realloc_r>
8113280c:	1025883a 	mov	r18,r2
81132810:	10002226 	beq	r2,zero,8113289c <__submore+0xd4>
81132814:	1469883a 	add	r20,r2,r17
81132818:	880d883a 	mov	r6,r17
8113281c:	100b883a 	mov	r5,r2
81132820:	a009883a 	mov	r4,r20
81132824:	11239dc0 	call	811239dc <memcpy>
81132828:	0005883a 	mov	r2,zero
8113282c:	85000015 	stw	r20,0(r16)
81132830:	84800c15 	stw	r18,48(r16)
81132834:	84c00d15 	stw	r19,52(r16)
81132838:	dfc00517 	ldw	ra,20(sp)
8113283c:	dd000417 	ldw	r20,16(sp)
81132840:	dcc00317 	ldw	r19,12(sp)
81132844:	dc800217 	ldw	r18,8(sp)
81132848:	dc400117 	ldw	r17,4(sp)
8113284c:	dc000017 	ldw	r16,0(sp)
81132850:	dec00604 	addi	sp,sp,24
81132854:	f800283a 	ret
81132858:	04410004 	movi	r17,1024
8113285c:	880b883a 	mov	r5,r17
81132860:	11231c80 	call	811231c8 <_malloc_r>
81132864:	1007883a 	mov	r3,r2
81132868:	10000c26 	beq	r2,zero,8113289c <__submore+0xd4>
8113286c:	80801083 	ldbu	r2,66(r16)
81132870:	80c00c15 	stw	r3,48(r16)
81132874:	84400d15 	stw	r17,52(r16)
81132878:	1880ffc5 	stb	r2,1023(r3)
8113287c:	81401043 	ldbu	r5,65(r16)
81132880:	1900ff44 	addi	r4,r3,1021
81132884:	0005883a 	mov	r2,zero
81132888:	1940ff85 	stb	r5,1022(r3)
8113288c:	81401003 	ldbu	r5,64(r16)
81132890:	1940ff45 	stb	r5,1021(r3)
81132894:	81000015 	stw	r4,0(r16)
81132898:	003fe706 	br	81132838 <__reset+0xfb112838>
8113289c:	00bfffc4 	movi	r2,-1
811328a0:	003fe506 	br	81132838 <__reset+0xfb112838>

811328a4 <_ungetc_r>:
811328a4:	00bfffc4 	movi	r2,-1
811328a8:	28806326 	beq	r5,r2,81132a38 <_ungetc_r+0x194>
811328ac:	defffb04 	addi	sp,sp,-20
811328b0:	de00012e 	bgeu	sp,et,811328b8 <_ungetc_r+0x14>
811328b4:	003b68fa 	trap	3
811328b8:	dcc00315 	stw	r19,12(sp)
811328bc:	dc400115 	stw	r17,4(sp)
811328c0:	dc000015 	stw	r16,0(sp)
811328c4:	dfc00415 	stw	ra,16(sp)
811328c8:	dc800215 	stw	r18,8(sp)
811328cc:	2023883a 	mov	r17,r4
811328d0:	3021883a 	mov	r16,r6
811328d4:	2827883a 	mov	r19,r5
811328d8:	20000226 	beq	r4,zero,811328e4 <_ungetc_r+0x40>
811328dc:	20800e17 	ldw	r2,56(r4)
811328e0:	10002e26 	beq	r2,zero,8113299c <_ungetc_r+0xf8>
811328e4:	80c0030b 	ldhu	r3,12(r16)
811328e8:	1888000c 	andi	r2,r3,8192
811328ec:	1000051e 	bne	r2,zero,81132904 <_ungetc_r+0x60>
811328f0:	81001917 	ldw	r4,100(r16)
811328f4:	00b7ffc4 	movi	r2,-8193
811328f8:	18c80014 	ori	r3,r3,8192
811328fc:	2084703a 	and	r2,r4,r2
81132900:	80801915 	stw	r2,100(r16)
81132904:	00bff7c4 	movi	r2,-33
81132908:	1884703a 	and	r2,r3,r2
8113290c:	8080030d 	sth	r2,12(r16)
81132910:	1900010c 	andi	r4,r3,4
81132914:	2000061e 	bne	r4,zero,81132930 <_ungetc_r+0x8c>
81132918:	1900040c 	andi	r4,r3,16
8113291c:	20001d26 	beq	r4,zero,81132994 <_ungetc_r+0xf0>
81132920:	18c0020c 	andi	r3,r3,8
81132924:	1800331e 	bne	r3,zero,811329f4 <_ungetc_r+0x150>
81132928:	10800114 	ori	r2,r2,4
8113292c:	8080030d 	sth	r2,12(r16)
81132930:	80800c17 	ldw	r2,48(r16)
81132934:	9c803fcc 	andi	r18,r19,255
81132938:	10001a26 	beq	r2,zero,811329a4 <_ungetc_r+0x100>
8113293c:	80c00117 	ldw	r3,4(r16)
81132940:	80800d17 	ldw	r2,52(r16)
81132944:	18800f0e 	bge	r3,r2,81132984 <_ungetc_r+0xe0>
81132948:	80c00017 	ldw	r3,0(r16)
8113294c:	9005883a 	mov	r2,r18
81132950:	193fffc4 	addi	r4,r3,-1
81132954:	81000015 	stw	r4,0(r16)
81132958:	1cffffc5 	stb	r19,-1(r3)
8113295c:	80c00117 	ldw	r3,4(r16)
81132960:	18c00044 	addi	r3,r3,1
81132964:	80c00115 	stw	r3,4(r16)
81132968:	dfc00417 	ldw	ra,16(sp)
8113296c:	dcc00317 	ldw	r19,12(sp)
81132970:	dc800217 	ldw	r18,8(sp)
81132974:	dc400117 	ldw	r17,4(sp)
81132978:	dc000017 	ldw	r16,0(sp)
8113297c:	dec00504 	addi	sp,sp,20
81132980:	f800283a 	ret
81132984:	800b883a 	mov	r5,r16
81132988:	8809883a 	mov	r4,r17
8113298c:	11327c80 	call	811327c8 <__submore>
81132990:	103fed26 	beq	r2,zero,81132948 <__reset+0xfb112948>
81132994:	00bfffc4 	movi	r2,-1
81132998:	003ff306 	br	81132968 <__reset+0xfb112968>
8113299c:	112c7280 	call	8112c728 <__sinit>
811329a0:	003fd006 	br	811328e4 <__reset+0xfb1128e4>
811329a4:	80c00417 	ldw	r3,16(r16)
811329a8:	80800017 	ldw	r2,0(r16)
811329ac:	18000326 	beq	r3,zero,811329bc <_ungetc_r+0x118>
811329b0:	1880022e 	bgeu	r3,r2,811329bc <_ungetc_r+0x118>
811329b4:	10ffffc3 	ldbu	r3,-1(r2)
811329b8:	90c01826 	beq	r18,r3,81132a1c <_ungetc_r+0x178>
811329bc:	81400117 	ldw	r5,4(r16)
811329c0:	80800e15 	stw	r2,56(r16)
811329c4:	008000c4 	movi	r2,3
811329c8:	81001004 	addi	r4,r16,64
811329cc:	80c01084 	addi	r3,r16,66
811329d0:	80800d15 	stw	r2,52(r16)
811329d4:	00800044 	movi	r2,1
811329d8:	80800115 	stw	r2,4(r16)
811329dc:	81400f15 	stw	r5,60(r16)
811329e0:	81000c15 	stw	r4,48(r16)
811329e4:	84c01085 	stb	r19,66(r16)
811329e8:	80c00015 	stw	r3,0(r16)
811329ec:	9005883a 	mov	r2,r18
811329f0:	003fdd06 	br	81132968 <__reset+0xfb112968>
811329f4:	800b883a 	mov	r5,r16
811329f8:	8809883a 	mov	r4,r17
811329fc:	112c32c0 	call	8112c32c <_fflush_r>
81132a00:	103fe41e 	bne	r2,zero,81132994 <__reset+0xfb112994>
81132a04:	8080030b 	ldhu	r2,12(r16)
81132a08:	00fffdc4 	movi	r3,-9
81132a0c:	80000215 	stw	zero,8(r16)
81132a10:	1884703a 	and	r2,r3,r2
81132a14:	80000615 	stw	zero,24(r16)
81132a18:	003fc306 	br	81132928 <__reset+0xfb112928>
81132a1c:	80c00117 	ldw	r3,4(r16)
81132a20:	10bfffc4 	addi	r2,r2,-1
81132a24:	80800015 	stw	r2,0(r16)
81132a28:	18800044 	addi	r2,r3,1
81132a2c:	80800115 	stw	r2,4(r16)
81132a30:	9005883a 	mov	r2,r18
81132a34:	003fcc06 	br	81132968 <__reset+0xfb112968>
81132a38:	00bfffc4 	movi	r2,-1
81132a3c:	f800283a 	ret

81132a40 <ungetc>:
81132a40:	00a04574 	movhi	r2,33045
81132a44:	1090f104 	addi	r2,r2,17348
81132a48:	280d883a 	mov	r6,r5
81132a4c:	200b883a 	mov	r5,r4
81132a50:	11000017 	ldw	r4,0(r2)
81132a54:	11328a41 	jmpi	811328a4 <_ungetc_r>

81132a58 <__sprint_r.part.0>:
81132a58:	defff604 	addi	sp,sp,-40
81132a5c:	de00012e 	bgeu	sp,et,81132a64 <__sprint_r.part.0+0xc>
81132a60:	003b68fa 	trap	3
81132a64:	28801917 	ldw	r2,100(r5)
81132a68:	dd400515 	stw	r21,20(sp)
81132a6c:	dfc00915 	stw	ra,36(sp)
81132a70:	df000815 	stw	fp,32(sp)
81132a74:	ddc00715 	stw	r23,28(sp)
81132a78:	dd800615 	stw	r22,24(sp)
81132a7c:	dd000415 	stw	r20,16(sp)
81132a80:	dcc00315 	stw	r19,12(sp)
81132a84:	dc800215 	stw	r18,8(sp)
81132a88:	dc400115 	stw	r17,4(sp)
81132a8c:	dc000015 	stw	r16,0(sp)
81132a90:	1088000c 	andi	r2,r2,8192
81132a94:	302b883a 	mov	r21,r6
81132a98:	10002e26 	beq	r2,zero,81132b54 <__sprint_r.part.0+0xfc>
81132a9c:	30800217 	ldw	r2,8(r6)
81132aa0:	35800017 	ldw	r22,0(r6)
81132aa4:	10002926 	beq	r2,zero,81132b4c <__sprint_r.part.0+0xf4>
81132aa8:	2827883a 	mov	r19,r5
81132aac:	2029883a 	mov	r20,r4
81132ab0:	b5c00104 	addi	r23,r22,4
81132ab4:	04bfffc4 	movi	r18,-1
81132ab8:	bc400017 	ldw	r17,0(r23)
81132abc:	b4000017 	ldw	r16,0(r22)
81132ac0:	0039883a 	mov	fp,zero
81132ac4:	8822d0ba 	srli	r17,r17,2
81132ac8:	8800031e 	bne	r17,zero,81132ad8 <__sprint_r.part.0+0x80>
81132acc:	00001806 	br	81132b30 <__sprint_r.part.0+0xd8>
81132ad0:	84000104 	addi	r16,r16,4
81132ad4:	8f001526 	beq	r17,fp,81132b2c <__sprint_r.part.0+0xd4>
81132ad8:	81400017 	ldw	r5,0(r16)
81132adc:	980d883a 	mov	r6,r19
81132ae0:	a009883a 	mov	r4,r20
81132ae4:	11343fc0 	call	811343fc <_fputwc_r>
81132ae8:	e7000044 	addi	fp,fp,1
81132aec:	14bff81e 	bne	r2,r18,81132ad0 <__reset+0xfb112ad0>
81132af0:	9005883a 	mov	r2,r18
81132af4:	a8000215 	stw	zero,8(r21)
81132af8:	a8000115 	stw	zero,4(r21)
81132afc:	dfc00917 	ldw	ra,36(sp)
81132b00:	df000817 	ldw	fp,32(sp)
81132b04:	ddc00717 	ldw	r23,28(sp)
81132b08:	dd800617 	ldw	r22,24(sp)
81132b0c:	dd400517 	ldw	r21,20(sp)
81132b10:	dd000417 	ldw	r20,16(sp)
81132b14:	dcc00317 	ldw	r19,12(sp)
81132b18:	dc800217 	ldw	r18,8(sp)
81132b1c:	dc400117 	ldw	r17,4(sp)
81132b20:	dc000017 	ldw	r16,0(sp)
81132b24:	dec00a04 	addi	sp,sp,40
81132b28:	f800283a 	ret
81132b2c:	a8800217 	ldw	r2,8(r21)
81132b30:	8c63883a 	add	r17,r17,r17
81132b34:	8c63883a 	add	r17,r17,r17
81132b38:	1445c83a 	sub	r2,r2,r17
81132b3c:	a8800215 	stw	r2,8(r21)
81132b40:	b5800204 	addi	r22,r22,8
81132b44:	bdc00204 	addi	r23,r23,8
81132b48:	103fdb1e 	bne	r2,zero,81132ab8 <__reset+0xfb112ab8>
81132b4c:	0005883a 	mov	r2,zero
81132b50:	003fe806 	br	81132af4 <__reset+0xfb112af4>
81132b54:	112ced80 	call	8112ced8 <__sfvwrite_r>
81132b58:	003fe606 	br	81132af4 <__reset+0xfb112af4>

81132b5c <__sprint_r>:
81132b5c:	30c00217 	ldw	r3,8(r6)
81132b60:	18000126 	beq	r3,zero,81132b68 <__sprint_r+0xc>
81132b64:	1132a581 	jmpi	81132a58 <__sprint_r.part.0>
81132b68:	30000115 	stw	zero,4(r6)
81132b6c:	0005883a 	mov	r2,zero
81132b70:	f800283a 	ret

81132b74 <___vfiprintf_internal_r>:
81132b74:	deffc904 	addi	sp,sp,-220
81132b78:	de00012e 	bgeu	sp,et,81132b80 <___vfiprintf_internal_r+0xc>
81132b7c:	003b68fa 	trap	3
81132b80:	df003515 	stw	fp,212(sp)
81132b84:	dd003115 	stw	r20,196(sp)
81132b88:	dfc03615 	stw	ra,216(sp)
81132b8c:	ddc03415 	stw	r23,208(sp)
81132b90:	dd803315 	stw	r22,204(sp)
81132b94:	dd403215 	stw	r21,200(sp)
81132b98:	dcc03015 	stw	r19,192(sp)
81132b9c:	dc802f15 	stw	r18,188(sp)
81132ba0:	dc402e15 	stw	r17,184(sp)
81132ba4:	dc002d15 	stw	r16,180(sp)
81132ba8:	d9002015 	stw	r4,128(sp)
81132bac:	d9c02215 	stw	r7,136(sp)
81132bb0:	2829883a 	mov	r20,r5
81132bb4:	3039883a 	mov	fp,r6
81132bb8:	20000226 	beq	r4,zero,81132bc4 <___vfiprintf_internal_r+0x50>
81132bbc:	20800e17 	ldw	r2,56(r4)
81132bc0:	1000cf26 	beq	r2,zero,81132f00 <___vfiprintf_internal_r+0x38c>
81132bc4:	a080030b 	ldhu	r2,12(r20)
81132bc8:	10c8000c 	andi	r3,r2,8192
81132bcc:	1800061e 	bne	r3,zero,81132be8 <___vfiprintf_internal_r+0x74>
81132bd0:	a1001917 	ldw	r4,100(r20)
81132bd4:	00f7ffc4 	movi	r3,-8193
81132bd8:	10880014 	ori	r2,r2,8192
81132bdc:	20c6703a 	and	r3,r4,r3
81132be0:	a080030d 	sth	r2,12(r20)
81132be4:	a0c01915 	stw	r3,100(r20)
81132be8:	10c0020c 	andi	r3,r2,8
81132bec:	1800a926 	beq	r3,zero,81132e94 <___vfiprintf_internal_r+0x320>
81132bf0:	a0c00417 	ldw	r3,16(r20)
81132bf4:	1800a726 	beq	r3,zero,81132e94 <___vfiprintf_internal_r+0x320>
81132bf8:	1080068c 	andi	r2,r2,26
81132bfc:	00c00284 	movi	r3,10
81132c00:	10c0ac26 	beq	r2,r3,81132eb4 <___vfiprintf_internal_r+0x340>
81132c04:	da801a04 	addi	r10,sp,104
81132c08:	da801e15 	stw	r10,120(sp)
81132c0c:	d8801e17 	ldw	r2,120(sp)
81132c10:	da8019c4 	addi	r10,sp,103
81132c14:	05a04574 	movhi	r22,33045
81132c18:	05e04574 	movhi	r23,33045
81132c1c:	da801f15 	stw	r10,124(sp)
81132c20:	1295c83a 	sub	r10,r2,r10
81132c24:	b587b804 	addi	r22,r22,7904
81132c28:	bdc7b404 	addi	r23,r23,7888
81132c2c:	dec01a15 	stw	sp,104(sp)
81132c30:	d8001c15 	stw	zero,112(sp)
81132c34:	d8001b15 	stw	zero,108(sp)
81132c38:	d8002615 	stw	zero,152(sp)
81132c3c:	d8002315 	stw	zero,140(sp)
81132c40:	da802715 	stw	r10,156(sp)
81132c44:	d811883a 	mov	r8,sp
81132c48:	dd002115 	stw	r20,132(sp)
81132c4c:	e021883a 	mov	r16,fp
81132c50:	80800007 	ldb	r2,0(r16)
81132c54:	1003ea26 	beq	r2,zero,81133c00 <___vfiprintf_internal_r+0x108c>
81132c58:	00c00944 	movi	r3,37
81132c5c:	8025883a 	mov	r18,r16
81132c60:	10c0021e 	bne	r2,r3,81132c6c <___vfiprintf_internal_r+0xf8>
81132c64:	00001606 	br	81132cc0 <___vfiprintf_internal_r+0x14c>
81132c68:	10c00326 	beq	r2,r3,81132c78 <___vfiprintf_internal_r+0x104>
81132c6c:	94800044 	addi	r18,r18,1
81132c70:	90800007 	ldb	r2,0(r18)
81132c74:	103ffc1e 	bne	r2,zero,81132c68 <__reset+0xfb112c68>
81132c78:	9423c83a 	sub	r17,r18,r16
81132c7c:	88001026 	beq	r17,zero,81132cc0 <___vfiprintf_internal_r+0x14c>
81132c80:	d8c01c17 	ldw	r3,112(sp)
81132c84:	d8801b17 	ldw	r2,108(sp)
81132c88:	44000015 	stw	r16,0(r8)
81132c8c:	88c7883a 	add	r3,r17,r3
81132c90:	10800044 	addi	r2,r2,1
81132c94:	44400115 	stw	r17,4(r8)
81132c98:	d8c01c15 	stw	r3,112(sp)
81132c9c:	d8801b15 	stw	r2,108(sp)
81132ca0:	010001c4 	movi	r4,7
81132ca4:	2080760e 	bge	r4,r2,81132e80 <___vfiprintf_internal_r+0x30c>
81132ca8:	1803821e 	bne	r3,zero,81133ab4 <___vfiprintf_internal_r+0xf40>
81132cac:	da802317 	ldw	r10,140(sp)
81132cb0:	d8001b15 	stw	zero,108(sp)
81132cb4:	d811883a 	mov	r8,sp
81132cb8:	5455883a 	add	r10,r10,r17
81132cbc:	da802315 	stw	r10,140(sp)
81132cc0:	90800007 	ldb	r2,0(r18)
81132cc4:	10044626 	beq	r2,zero,81133de0 <___vfiprintf_internal_r+0x126c>
81132cc8:	90c00047 	ldb	r3,1(r18)
81132ccc:	94000044 	addi	r16,r18,1
81132cd0:	d8001d85 	stb	zero,118(sp)
81132cd4:	0009883a 	mov	r4,zero
81132cd8:	000f883a 	mov	r7,zero
81132cdc:	027fffc4 	movi	r9,-1
81132ce0:	0023883a 	mov	r17,zero
81132ce4:	0029883a 	mov	r20,zero
81132ce8:	01401604 	movi	r5,88
81132cec:	01800244 	movi	r6,9
81132cf0:	03400a84 	movi	r13,42
81132cf4:	03001b04 	movi	r12,108
81132cf8:	84000044 	addi	r16,r16,1
81132cfc:	18bff804 	addi	r2,r3,-32
81132d00:	28827336 	bltu	r5,r2,811336d0 <___vfiprintf_internal_r+0xb5c>
81132d04:	100490ba 	slli	r2,r2,2
81132d08:	02a044f4 	movhi	r10,33043
81132d0c:	528b4704 	addi	r10,r10,11548
81132d10:	1285883a 	add	r2,r2,r10
81132d14:	10800017 	ldw	r2,0(r2)
81132d18:	1000683a 	jmp	r2
81132d1c:	81133404 	addi	r4,r16,19664
81132d20:	811336d0 	cmplti	r4,r16,19675
81132d24:	811336d0 	cmplti	r4,r16,19675
81132d28:	81133424 	muli	r4,r16,19664
81132d2c:	811336d0 	cmplti	r4,r16,19675
81132d30:	811336d0 	cmplti	r4,r16,19675
81132d34:	811336d0 	cmplti	r4,r16,19675
81132d38:	811336d0 	cmplti	r4,r16,19675
81132d3c:	811336d0 	cmplti	r4,r16,19675
81132d40:	811336d0 	cmplti	r4,r16,19675
81132d44:	8113360c 	andi	r4,r16,19672
81132d48:	81133628 	cmpgeui	r4,r16,19672
81132d4c:	811336d0 	cmplti	r4,r16,19675
81132d50:	81132f10 	cmplti	r4,r16,19644
81132d54:	81133638 	rdprs	r4,r16,19672
81132d58:	811336d0 	cmplti	r4,r16,19675
81132d5c:	81133430 	cmpltui	r4,r16,19664
81132d60:	8113343c 	xorhi	r4,r16,19664
81132d64:	8113343c 	xorhi	r4,r16,19664
81132d68:	8113343c 	xorhi	r4,r16,19664
81132d6c:	8113343c 	xorhi	r4,r16,19664
81132d70:	8113343c 	xorhi	r4,r16,19664
81132d74:	8113343c 	xorhi	r4,r16,19664
81132d78:	8113343c 	xorhi	r4,r16,19664
81132d7c:	8113343c 	xorhi	r4,r16,19664
81132d80:	8113343c 	xorhi	r4,r16,19664
81132d84:	811336d0 	cmplti	r4,r16,19675
81132d88:	811336d0 	cmplti	r4,r16,19675
81132d8c:	811336d0 	cmplti	r4,r16,19675
81132d90:	811336d0 	cmplti	r4,r16,19675
81132d94:	811336d0 	cmplti	r4,r16,19675
81132d98:	811336d0 	cmplti	r4,r16,19675
81132d9c:	811336d0 	cmplti	r4,r16,19675
81132da0:	811336d0 	cmplti	r4,r16,19675
81132da4:	811336d0 	cmplti	r4,r16,19675
81132da8:	811336d0 	cmplti	r4,r16,19675
81132dac:	81133468 	cmpgeui	r4,r16,19665
81132db0:	811336d0 	cmplti	r4,r16,19675
81132db4:	811336d0 	cmplti	r4,r16,19675
81132db8:	811336d0 	cmplti	r4,r16,19675
81132dbc:	811336d0 	cmplti	r4,r16,19675
81132dc0:	811336d0 	cmplti	r4,r16,19675
81132dc4:	811336d0 	cmplti	r4,r16,19675
81132dc8:	811336d0 	cmplti	r4,r16,19675
81132dcc:	811336d0 	cmplti	r4,r16,19675
81132dd0:	811336d0 	cmplti	r4,r16,19675
81132dd4:	811336d0 	cmplti	r4,r16,19675
81132dd8:	811334a0 	cmpeqi	r4,r16,19666
81132ddc:	811336d0 	cmplti	r4,r16,19675
81132de0:	811336d0 	cmplti	r4,r16,19675
81132de4:	811336d0 	cmplti	r4,r16,19675
81132de8:	811336d0 	cmplti	r4,r16,19675
81132dec:	811336d0 	cmplti	r4,r16,19675
81132df0:	811334f8 	rdprs	r4,r16,19667
81132df4:	811336d0 	cmplti	r4,r16,19675
81132df8:	811336d0 	cmplti	r4,r16,19675
81132dfc:	81133568 	cmpgeui	r4,r16,19669
81132e00:	811336d0 	cmplti	r4,r16,19675
81132e04:	811336d0 	cmplti	r4,r16,19675
81132e08:	811336d0 	cmplti	r4,r16,19675
81132e0c:	811336d0 	cmplti	r4,r16,19675
81132e10:	811336d0 	cmplti	r4,r16,19675
81132e14:	811336d0 	cmplti	r4,r16,19675
81132e18:	811336d0 	cmplti	r4,r16,19675
81132e1c:	811336d0 	cmplti	r4,r16,19675
81132e20:	811336d0 	cmplti	r4,r16,19675
81132e24:	811336d0 	cmplti	r4,r16,19675
81132e28:	81133314 	ori	r4,r16,19660
81132e2c:	81133340 	call	88113334 <__reset+0x20f3334>
81132e30:	811336d0 	cmplti	r4,r16,19675
81132e34:	811336d0 	cmplti	r4,r16,19675
81132e38:	811336d0 	cmplti	r4,r16,19675
81132e3c:	81133678 	rdprs	r4,r16,19673
81132e40:	81133340 	call	88113334 <__reset+0x20f3334>
81132e44:	811336d0 	cmplti	r4,r16,19675
81132e48:	811336d0 	cmplti	r4,r16,19675
81132e4c:	811331d4 	ori	r4,r16,19655
81132e50:	811336d0 	cmplti	r4,r16,19675
81132e54:	811331e4 	muli	r4,r16,19655
81132e58:	81133220 	cmpeqi	r4,r16,19656
81132e5c:	81132f1c 	xori	r4,r16,19644
81132e60:	811331c8 	cmpgei	r4,r16,19655
81132e64:	811336d0 	cmplti	r4,r16,19675
81132e68:	811335a4 	muli	r4,r16,19670
81132e6c:	811336d0 	cmplti	r4,r16,19675
81132e70:	811335fc 	xorhi	r4,r16,19671
81132e74:	811336d0 	cmplti	r4,r16,19675
81132e78:	811336d0 	cmplti	r4,r16,19675
81132e7c:	811332c0 	call	8811332c <__reset+0x20f332c>
81132e80:	42000204 	addi	r8,r8,8
81132e84:	da802317 	ldw	r10,140(sp)
81132e88:	5455883a 	add	r10,r10,r17
81132e8c:	da802315 	stw	r10,140(sp)
81132e90:	003f8b06 	br	81132cc0 <__reset+0xfb112cc0>
81132e94:	d9002017 	ldw	r4,128(sp)
81132e98:	a00b883a 	mov	r5,r20
81132e9c:	112a6b80 	call	8112a6b8 <__swsetup_r>
81132ea0:	1003b11e 	bne	r2,zero,81133d68 <___vfiprintf_internal_r+0x11f4>
81132ea4:	a080030b 	ldhu	r2,12(r20)
81132ea8:	00c00284 	movi	r3,10
81132eac:	1080068c 	andi	r2,r2,26
81132eb0:	10ff541e 	bne	r2,r3,81132c04 <__reset+0xfb112c04>
81132eb4:	a080038f 	ldh	r2,14(r20)
81132eb8:	103f5216 	blt	r2,zero,81132c04 <__reset+0xfb112c04>
81132ebc:	d9c02217 	ldw	r7,136(sp)
81132ec0:	d9002017 	ldw	r4,128(sp)
81132ec4:	e00d883a 	mov	r6,fp
81132ec8:	a00b883a 	mov	r5,r20
81132ecc:	1133ff40 	call	81133ff4 <__sbprintf>
81132ed0:	dfc03617 	ldw	ra,216(sp)
81132ed4:	df003517 	ldw	fp,212(sp)
81132ed8:	ddc03417 	ldw	r23,208(sp)
81132edc:	dd803317 	ldw	r22,204(sp)
81132ee0:	dd403217 	ldw	r21,200(sp)
81132ee4:	dd003117 	ldw	r20,196(sp)
81132ee8:	dcc03017 	ldw	r19,192(sp)
81132eec:	dc802f17 	ldw	r18,188(sp)
81132ef0:	dc402e17 	ldw	r17,184(sp)
81132ef4:	dc002d17 	ldw	r16,180(sp)
81132ef8:	dec03704 	addi	sp,sp,220
81132efc:	f800283a 	ret
81132f00:	112c7280 	call	8112c728 <__sinit>
81132f04:	003f2f06 	br	81132bc4 <__reset+0xfb112bc4>
81132f08:	0463c83a 	sub	r17,zero,r17
81132f0c:	d8802215 	stw	r2,136(sp)
81132f10:	a5000114 	ori	r20,r20,4
81132f14:	80c00007 	ldb	r3,0(r16)
81132f18:	003f7706 	br	81132cf8 <__reset+0xfb112cf8>
81132f1c:	00800c04 	movi	r2,48
81132f20:	da802217 	ldw	r10,136(sp)
81132f24:	d8801d05 	stb	r2,116(sp)
81132f28:	00801e04 	movi	r2,120
81132f2c:	d8801d45 	stb	r2,117(sp)
81132f30:	d8001d85 	stb	zero,118(sp)
81132f34:	50c00104 	addi	r3,r10,4
81132f38:	54800017 	ldw	r18,0(r10)
81132f3c:	0027883a 	mov	r19,zero
81132f40:	a0800094 	ori	r2,r20,2
81132f44:	48030b16 	blt	r9,zero,81133b74 <___vfiprintf_internal_r+0x1000>
81132f48:	00bfdfc4 	movi	r2,-129
81132f4c:	a096703a 	and	r11,r20,r2
81132f50:	d8c02215 	stw	r3,136(sp)
81132f54:	5d000094 	ori	r20,r11,2
81132f58:	90032b1e 	bne	r18,zero,81133c08 <___vfiprintf_internal_r+0x1094>
81132f5c:	00a04574 	movhi	r2,33045
81132f60:	10872204 	addi	r2,r2,7304
81132f64:	d8802615 	stw	r2,152(sp)
81132f68:	0039883a 	mov	fp,zero
81132f6c:	48017b1e 	bne	r9,zero,8113355c <___vfiprintf_internal_r+0x9e8>
81132f70:	0013883a 	mov	r9,zero
81132f74:	0027883a 	mov	r19,zero
81132f78:	dd401a04 	addi	r21,sp,104
81132f7c:	4825883a 	mov	r18,r9
81132f80:	4cc0010e 	bge	r9,r19,81132f88 <___vfiprintf_internal_r+0x414>
81132f84:	9825883a 	mov	r18,r19
81132f88:	e7003fcc 	andi	fp,fp,255
81132f8c:	e700201c 	xori	fp,fp,128
81132f90:	e73fe004 	addi	fp,fp,-128
81132f94:	e0000126 	beq	fp,zero,81132f9c <___vfiprintf_internal_r+0x428>
81132f98:	94800044 	addi	r18,r18,1
81132f9c:	a380008c 	andi	r14,r20,2
81132fa0:	70000126 	beq	r14,zero,81132fa8 <___vfiprintf_internal_r+0x434>
81132fa4:	94800084 	addi	r18,r18,2
81132fa8:	a700210c 	andi	fp,r20,132
81132fac:	e001df1e 	bne	fp,zero,8113372c <___vfiprintf_internal_r+0xbb8>
81132fb0:	8c87c83a 	sub	r3,r17,r18
81132fb4:	00c1dd0e 	bge	zero,r3,8113372c <___vfiprintf_internal_r+0xbb8>
81132fb8:	01c00404 	movi	r7,16
81132fbc:	d8801c17 	ldw	r2,112(sp)
81132fc0:	38c3ad0e 	bge	r7,r3,81133e78 <___vfiprintf_internal_r+0x1304>
81132fc4:	02a04574 	movhi	r10,33045
81132fc8:	5287b804 	addi	r10,r10,7904
81132fcc:	dc002915 	stw	r16,164(sp)
81132fd0:	d9801b17 	ldw	r6,108(sp)
81132fd4:	da802415 	stw	r10,144(sp)
81132fd8:	03c001c4 	movi	r15,7
81132fdc:	da402515 	stw	r9,148(sp)
81132fe0:	db802815 	stw	r14,160(sp)
81132fe4:	1821883a 	mov	r16,r3
81132fe8:	00000506 	br	81133000 <___vfiprintf_internal_r+0x48c>
81132fec:	31400084 	addi	r5,r6,2
81132ff0:	42000204 	addi	r8,r8,8
81132ff4:	200d883a 	mov	r6,r4
81132ff8:	843ffc04 	addi	r16,r16,-16
81132ffc:	3c000d0e 	bge	r7,r16,81133034 <___vfiprintf_internal_r+0x4c0>
81133000:	10800404 	addi	r2,r2,16
81133004:	31000044 	addi	r4,r6,1
81133008:	45800015 	stw	r22,0(r8)
8113300c:	41c00115 	stw	r7,4(r8)
81133010:	d8801c15 	stw	r2,112(sp)
81133014:	d9001b15 	stw	r4,108(sp)
81133018:	793ff40e 	bge	r15,r4,81132fec <__reset+0xfb112fec>
8113301c:	1001b51e 	bne	r2,zero,811336f4 <___vfiprintf_internal_r+0xb80>
81133020:	843ffc04 	addi	r16,r16,-16
81133024:	000d883a 	mov	r6,zero
81133028:	01400044 	movi	r5,1
8113302c:	d811883a 	mov	r8,sp
81133030:	3c3ff316 	blt	r7,r16,81133000 <__reset+0xfb113000>
81133034:	8007883a 	mov	r3,r16
81133038:	da402517 	ldw	r9,148(sp)
8113303c:	db802817 	ldw	r14,160(sp)
81133040:	dc002917 	ldw	r16,164(sp)
81133044:	da802417 	ldw	r10,144(sp)
81133048:	1885883a 	add	r2,r3,r2
8113304c:	40c00115 	stw	r3,4(r8)
81133050:	42800015 	stw	r10,0(r8)
81133054:	d8801c15 	stw	r2,112(sp)
81133058:	d9401b15 	stw	r5,108(sp)
8113305c:	00c001c4 	movi	r3,7
81133060:	19426016 	blt	r3,r5,811339e4 <___vfiprintf_internal_r+0xe70>
81133064:	d8c01d87 	ldb	r3,118(sp)
81133068:	42000204 	addi	r8,r8,8
8113306c:	29000044 	addi	r4,r5,1
81133070:	1801b31e 	bne	r3,zero,81133740 <___vfiprintf_internal_r+0xbcc>
81133074:	7001c026 	beq	r14,zero,81133778 <___vfiprintf_internal_r+0xc04>
81133078:	d8c01d04 	addi	r3,sp,116
8113307c:	10800084 	addi	r2,r2,2
81133080:	40c00015 	stw	r3,0(r8)
81133084:	00c00084 	movi	r3,2
81133088:	40c00115 	stw	r3,4(r8)
8113308c:	d8801c15 	stw	r2,112(sp)
81133090:	d9001b15 	stw	r4,108(sp)
81133094:	00c001c4 	movi	r3,7
81133098:	1902650e 	bge	r3,r4,81133a30 <___vfiprintf_internal_r+0xebc>
8113309c:	10029a1e 	bne	r2,zero,81133b08 <___vfiprintf_internal_r+0xf94>
811330a0:	00c02004 	movi	r3,128
811330a4:	01000044 	movi	r4,1
811330a8:	000b883a 	mov	r5,zero
811330ac:	d811883a 	mov	r8,sp
811330b0:	e0c1b31e 	bne	fp,r3,81133780 <___vfiprintf_internal_r+0xc0c>
811330b4:	8cb9c83a 	sub	fp,r17,r18
811330b8:	0701b10e 	bge	zero,fp,81133780 <___vfiprintf_internal_r+0xc0c>
811330bc:	01c00404 	movi	r7,16
811330c0:	3f03890e 	bge	r7,fp,81133ee8 <___vfiprintf_internal_r+0x1374>
811330c4:	00e04574 	movhi	r3,33045
811330c8:	18c7b404 	addi	r3,r3,7888
811330cc:	d8c02415 	stw	r3,144(sp)
811330d0:	8007883a 	mov	r3,r16
811330d4:	034001c4 	movi	r13,7
811330d8:	e021883a 	mov	r16,fp
811330dc:	da402515 	stw	r9,148(sp)
811330e0:	1839883a 	mov	fp,r3
811330e4:	00000506 	br	811330fc <___vfiprintf_internal_r+0x588>
811330e8:	29800084 	addi	r6,r5,2
811330ec:	42000204 	addi	r8,r8,8
811330f0:	180b883a 	mov	r5,r3
811330f4:	843ffc04 	addi	r16,r16,-16
811330f8:	3c000d0e 	bge	r7,r16,81133130 <___vfiprintf_internal_r+0x5bc>
811330fc:	10800404 	addi	r2,r2,16
81133100:	28c00044 	addi	r3,r5,1
81133104:	45c00015 	stw	r23,0(r8)
81133108:	41c00115 	stw	r7,4(r8)
8113310c:	d8801c15 	stw	r2,112(sp)
81133110:	d8c01b15 	stw	r3,108(sp)
81133114:	68fff40e 	bge	r13,r3,811330e8 <__reset+0xfb1130e8>
81133118:	1002241e 	bne	r2,zero,811339ac <___vfiprintf_internal_r+0xe38>
8113311c:	843ffc04 	addi	r16,r16,-16
81133120:	01800044 	movi	r6,1
81133124:	000b883a 	mov	r5,zero
81133128:	d811883a 	mov	r8,sp
8113312c:	3c3ff316 	blt	r7,r16,811330fc <__reset+0xfb1130fc>
81133130:	da402517 	ldw	r9,148(sp)
81133134:	e007883a 	mov	r3,fp
81133138:	8039883a 	mov	fp,r16
8113313c:	1821883a 	mov	r16,r3
81133140:	d8c02417 	ldw	r3,144(sp)
81133144:	1705883a 	add	r2,r2,fp
81133148:	47000115 	stw	fp,4(r8)
8113314c:	40c00015 	stw	r3,0(r8)
81133150:	d8801c15 	stw	r2,112(sp)
81133154:	d9801b15 	stw	r6,108(sp)
81133158:	00c001c4 	movi	r3,7
8113315c:	19827616 	blt	r3,r6,81133b38 <___vfiprintf_internal_r+0xfc4>
81133160:	4cf9c83a 	sub	fp,r9,r19
81133164:	42000204 	addi	r8,r8,8
81133168:	31000044 	addi	r4,r6,1
8113316c:	300b883a 	mov	r5,r6
81133170:	07018516 	blt	zero,fp,81133788 <___vfiprintf_internal_r+0xc14>
81133174:	9885883a 	add	r2,r19,r2
81133178:	45400015 	stw	r21,0(r8)
8113317c:	44c00115 	stw	r19,4(r8)
81133180:	d8801c15 	stw	r2,112(sp)
81133184:	d9001b15 	stw	r4,108(sp)
81133188:	00c001c4 	movi	r3,7
8113318c:	1901dd0e 	bge	r3,r4,81133904 <___vfiprintf_internal_r+0xd90>
81133190:	1002401e 	bne	r2,zero,81133a94 <___vfiprintf_internal_r+0xf20>
81133194:	d8001b15 	stw	zero,108(sp)
81133198:	a2c0010c 	andi	r11,r20,4
8113319c:	58000226 	beq	r11,zero,811331a8 <___vfiprintf_internal_r+0x634>
811331a0:	8ca7c83a 	sub	r19,r17,r18
811331a4:	04c2f216 	blt	zero,r19,81133d70 <___vfiprintf_internal_r+0x11fc>
811331a8:	8c80010e 	bge	r17,r18,811331b0 <___vfiprintf_internal_r+0x63c>
811331ac:	9023883a 	mov	r17,r18
811331b0:	da802317 	ldw	r10,140(sp)
811331b4:	5455883a 	add	r10,r10,r17
811331b8:	da802315 	stw	r10,140(sp)
811331bc:	d8001b15 	stw	zero,108(sp)
811331c0:	d811883a 	mov	r8,sp
811331c4:	003ea206 	br	81132c50 <__reset+0xfb112c50>
811331c8:	a5000814 	ori	r20,r20,32
811331cc:	80c00007 	ldb	r3,0(r16)
811331d0:	003ec906 	br	81132cf8 <__reset+0xfb112cf8>
811331d4:	80c00007 	ldb	r3,0(r16)
811331d8:	1b030926 	beq	r3,r12,81133e00 <___vfiprintf_internal_r+0x128c>
811331dc:	a5000414 	ori	r20,r20,16
811331e0:	003ec506 	br	81132cf8 <__reset+0xfb112cf8>
811331e4:	21003fcc 	andi	r4,r4,255
811331e8:	20035e1e 	bne	r4,zero,81133f64 <___vfiprintf_internal_r+0x13f0>
811331ec:	a080080c 	andi	r2,r20,32
811331f0:	1002a526 	beq	r2,zero,81133c88 <___vfiprintf_internal_r+0x1114>
811331f4:	da802217 	ldw	r10,136(sp)
811331f8:	50800017 	ldw	r2,0(r10)
811331fc:	da802317 	ldw	r10,140(sp)
81133200:	5007d7fa 	srai	r3,r10,31
81133204:	da802217 	ldw	r10,136(sp)
81133208:	10c00115 	stw	r3,4(r2)
8113320c:	52800104 	addi	r10,r10,4
81133210:	da802215 	stw	r10,136(sp)
81133214:	da802317 	ldw	r10,140(sp)
81133218:	12800015 	stw	r10,0(r2)
8113321c:	003e8c06 	br	81132c50 <__reset+0xfb112c50>
81133220:	21003fcc 	andi	r4,r4,255
81133224:	2003511e 	bne	r4,zero,81133f6c <___vfiprintf_internal_r+0x13f8>
81133228:	a080080c 	andi	r2,r20,32
8113322c:	1000a126 	beq	r2,zero,811334b4 <___vfiprintf_internal_r+0x940>
81133230:	da802217 	ldw	r10,136(sp)
81133234:	d8001d85 	stb	zero,118(sp)
81133238:	50800204 	addi	r2,r10,8
8113323c:	54800017 	ldw	r18,0(r10)
81133240:	54c00117 	ldw	r19,4(r10)
81133244:	4802b416 	blt	r9,zero,81133d18 <___vfiprintf_internal_r+0x11a4>
81133248:	013fdfc4 	movi	r4,-129
8113324c:	94c6b03a 	or	r3,r18,r19
81133250:	d8802215 	stw	r2,136(sp)
81133254:	a128703a 	and	r20,r20,r4
81133258:	1800a226 	beq	r3,zero,811334e4 <___vfiprintf_internal_r+0x970>
8113325c:	0039883a 	mov	fp,zero
81133260:	dd401a04 	addi	r21,sp,104
81133264:	9006d0fa 	srli	r3,r18,3
81133268:	9808977a 	slli	r4,r19,29
8113326c:	9826d0fa 	srli	r19,r19,3
81133270:	948001cc 	andi	r18,r18,7
81133274:	90800c04 	addi	r2,r18,48
81133278:	ad7fffc4 	addi	r21,r21,-1
8113327c:	20e4b03a 	or	r18,r4,r3
81133280:	a8800005 	stb	r2,0(r21)
81133284:	94c6b03a 	or	r3,r18,r19
81133288:	183ff61e 	bne	r3,zero,81133264 <__reset+0xfb113264>
8113328c:	a0c0004c 	andi	r3,r20,1
81133290:	18005926 	beq	r3,zero,811333f8 <___vfiprintf_internal_r+0x884>
81133294:	10803fcc 	andi	r2,r2,255
81133298:	1080201c 	xori	r2,r2,128
8113329c:	10bfe004 	addi	r2,r2,-128
811332a0:	00c00c04 	movi	r3,48
811332a4:	10c05426 	beq	r2,r3,811333f8 <___vfiprintf_internal_r+0x884>
811332a8:	da801e17 	ldw	r10,120(sp)
811332ac:	a8bfffc4 	addi	r2,r21,-1
811332b0:	a8ffffc5 	stb	r3,-1(r21)
811332b4:	50a7c83a 	sub	r19,r10,r2
811332b8:	102b883a 	mov	r21,r2
811332bc:	003f2f06 	br	81132f7c <__reset+0xfb112f7c>
811332c0:	21003fcc 	andi	r4,r4,255
811332c4:	2003421e 	bne	r4,zero,81133fd0 <___vfiprintf_internal_r+0x145c>
811332c8:	00a04574 	movhi	r2,33045
811332cc:	10872204 	addi	r2,r2,7304
811332d0:	d8802615 	stw	r2,152(sp)
811332d4:	a080080c 	andi	r2,r20,32
811332d8:	1000aa26 	beq	r2,zero,81133584 <___vfiprintf_internal_r+0xa10>
811332dc:	da802217 	ldw	r10,136(sp)
811332e0:	54800017 	ldw	r18,0(r10)
811332e4:	54c00117 	ldw	r19,4(r10)
811332e8:	52800204 	addi	r10,r10,8
811332ec:	da802215 	stw	r10,136(sp)
811332f0:	a080004c 	andi	r2,r20,1
811332f4:	1001d226 	beq	r2,zero,81133a40 <___vfiprintf_internal_r+0xecc>
811332f8:	94c4b03a 	or	r2,r18,r19
811332fc:	1002351e 	bne	r2,zero,81133bd4 <___vfiprintf_internal_r+0x1060>
81133300:	d8001d85 	stb	zero,118(sp)
81133304:	48022216 	blt	r9,zero,81133b90 <___vfiprintf_internal_r+0x101c>
81133308:	00bfdfc4 	movi	r2,-129
8113330c:	a0a8703a 	and	r20,r20,r2
81133310:	003f1506 	br	81132f68 <__reset+0xfb112f68>
81133314:	da802217 	ldw	r10,136(sp)
81133318:	04800044 	movi	r18,1
8113331c:	d8001d85 	stb	zero,118(sp)
81133320:	50800017 	ldw	r2,0(r10)
81133324:	52800104 	addi	r10,r10,4
81133328:	da802215 	stw	r10,136(sp)
8113332c:	d8801005 	stb	r2,64(sp)
81133330:	9027883a 	mov	r19,r18
81133334:	dd401004 	addi	r21,sp,64
81133338:	0013883a 	mov	r9,zero
8113333c:	003f1706 	br	81132f9c <__reset+0xfb112f9c>
81133340:	21003fcc 	andi	r4,r4,255
81133344:	2003201e 	bne	r4,zero,81133fc8 <___vfiprintf_internal_r+0x1454>
81133348:	a080080c 	andi	r2,r20,32
8113334c:	10004b26 	beq	r2,zero,8113347c <___vfiprintf_internal_r+0x908>
81133350:	da802217 	ldw	r10,136(sp)
81133354:	50800117 	ldw	r2,4(r10)
81133358:	54800017 	ldw	r18,0(r10)
8113335c:	52800204 	addi	r10,r10,8
81133360:	da802215 	stw	r10,136(sp)
81133364:	1027883a 	mov	r19,r2
81133368:	10022c16 	blt	r2,zero,81133c1c <___vfiprintf_internal_r+0x10a8>
8113336c:	df001d83 	ldbu	fp,118(sp)
81133370:	48007216 	blt	r9,zero,8113353c <___vfiprintf_internal_r+0x9c8>
81133374:	00ffdfc4 	movi	r3,-129
81133378:	94c4b03a 	or	r2,r18,r19
8113337c:	a0e8703a 	and	r20,r20,r3
81133380:	1000cc26 	beq	r2,zero,811336b4 <___vfiprintf_internal_r+0xb40>
81133384:	98021026 	beq	r19,zero,81133bc8 <___vfiprintf_internal_r+0x1054>
81133388:	dc402415 	stw	r17,144(sp)
8113338c:	dc002515 	stw	r16,148(sp)
81133390:	9823883a 	mov	r17,r19
81133394:	9021883a 	mov	r16,r18
81133398:	dd401a04 	addi	r21,sp,104
8113339c:	4825883a 	mov	r18,r9
811333a0:	4027883a 	mov	r19,r8
811333a4:	8009883a 	mov	r4,r16
811333a8:	880b883a 	mov	r5,r17
811333ac:	01800284 	movi	r6,10
811333b0:	000f883a 	mov	r7,zero
811333b4:	11358940 	call	81135894 <__umoddi3>
811333b8:	10800c04 	addi	r2,r2,48
811333bc:	ad7fffc4 	addi	r21,r21,-1
811333c0:	8009883a 	mov	r4,r16
811333c4:	880b883a 	mov	r5,r17
811333c8:	a8800005 	stb	r2,0(r21)
811333cc:	01800284 	movi	r6,10
811333d0:	000f883a 	mov	r7,zero
811333d4:	11353140 	call	81135314 <__udivdi3>
811333d8:	1021883a 	mov	r16,r2
811333dc:	10c4b03a 	or	r2,r2,r3
811333e0:	1823883a 	mov	r17,r3
811333e4:	103fef1e 	bne	r2,zero,811333a4 <__reset+0xfb1133a4>
811333e8:	dc402417 	ldw	r17,144(sp)
811333ec:	dc002517 	ldw	r16,148(sp)
811333f0:	9013883a 	mov	r9,r18
811333f4:	9811883a 	mov	r8,r19
811333f8:	da801e17 	ldw	r10,120(sp)
811333fc:	5567c83a 	sub	r19,r10,r21
81133400:	003ede06 	br	81132f7c <__reset+0xfb112f7c>
81133404:	38803fcc 	andi	r2,r7,255
81133408:	1080201c 	xori	r2,r2,128
8113340c:	10bfe004 	addi	r2,r2,-128
81133410:	1002371e 	bne	r2,zero,81133cf0 <___vfiprintf_internal_r+0x117c>
81133414:	01000044 	movi	r4,1
81133418:	01c00804 	movi	r7,32
8113341c:	80c00007 	ldb	r3,0(r16)
81133420:	003e3506 	br	81132cf8 <__reset+0xfb112cf8>
81133424:	a5000054 	ori	r20,r20,1
81133428:	80c00007 	ldb	r3,0(r16)
8113342c:	003e3206 	br	81132cf8 <__reset+0xfb112cf8>
81133430:	a5002014 	ori	r20,r20,128
81133434:	80c00007 	ldb	r3,0(r16)
81133438:	003e2f06 	br	81132cf8 <__reset+0xfb112cf8>
8113343c:	8015883a 	mov	r10,r16
81133440:	0023883a 	mov	r17,zero
81133444:	18bff404 	addi	r2,r3,-48
81133448:	50c00007 	ldb	r3,0(r10)
8113344c:	8c4002a4 	muli	r17,r17,10
81133450:	84000044 	addi	r16,r16,1
81133454:	8015883a 	mov	r10,r16
81133458:	1463883a 	add	r17,r2,r17
8113345c:	18bff404 	addi	r2,r3,-48
81133460:	30bff92e 	bgeu	r6,r2,81133448 <__reset+0xfb113448>
81133464:	003e2506 	br	81132cfc <__reset+0xfb112cfc>
81133468:	21003fcc 	andi	r4,r4,255
8113346c:	2002d41e 	bne	r4,zero,81133fc0 <___vfiprintf_internal_r+0x144c>
81133470:	a5000414 	ori	r20,r20,16
81133474:	a080080c 	andi	r2,r20,32
81133478:	103fb51e 	bne	r2,zero,81133350 <__reset+0xfb113350>
8113347c:	a080040c 	andi	r2,r20,16
81133480:	1001f826 	beq	r2,zero,81133c64 <___vfiprintf_internal_r+0x10f0>
81133484:	da802217 	ldw	r10,136(sp)
81133488:	54800017 	ldw	r18,0(r10)
8113348c:	52800104 	addi	r10,r10,4
81133490:	da802215 	stw	r10,136(sp)
81133494:	9027d7fa 	srai	r19,r18,31
81133498:	9805883a 	mov	r2,r19
8113349c:	003fb206 	br	81133368 <__reset+0xfb113368>
811334a0:	21003fcc 	andi	r4,r4,255
811334a4:	2002c41e 	bne	r4,zero,81133fb8 <___vfiprintf_internal_r+0x1444>
811334a8:	a5000414 	ori	r20,r20,16
811334ac:	a080080c 	andi	r2,r20,32
811334b0:	103f5f1e 	bne	r2,zero,81133230 <__reset+0xfb113230>
811334b4:	a080040c 	andi	r2,r20,16
811334b8:	10020f26 	beq	r2,zero,81133cf8 <___vfiprintf_internal_r+0x1184>
811334bc:	da802217 	ldw	r10,136(sp)
811334c0:	d8001d85 	stb	zero,118(sp)
811334c4:	0027883a 	mov	r19,zero
811334c8:	50800104 	addi	r2,r10,4
811334cc:	54800017 	ldw	r18,0(r10)
811334d0:	48021116 	blt	r9,zero,81133d18 <___vfiprintf_internal_r+0x11a4>
811334d4:	00ffdfc4 	movi	r3,-129
811334d8:	d8802215 	stw	r2,136(sp)
811334dc:	a0e8703a 	and	r20,r20,r3
811334e0:	903f5e1e 	bne	r18,zero,8113325c <__reset+0xfb11325c>
811334e4:	0039883a 	mov	fp,zero
811334e8:	4802a626 	beq	r9,zero,81133f84 <___vfiprintf_internal_r+0x1410>
811334ec:	0025883a 	mov	r18,zero
811334f0:	0027883a 	mov	r19,zero
811334f4:	003f5a06 	br	81133260 <__reset+0xfb113260>
811334f8:	21003fcc 	andi	r4,r4,255
811334fc:	20029f1e 	bne	r4,zero,81133f7c <___vfiprintf_internal_r+0x1408>
81133500:	a5000414 	ori	r20,r20,16
81133504:	a080080c 	andi	r2,r20,32
81133508:	10005e1e 	bne	r2,zero,81133684 <___vfiprintf_internal_r+0xb10>
8113350c:	a080040c 	andi	r2,r20,16
81133510:	1001a21e 	bne	r2,zero,81133b9c <___vfiprintf_internal_r+0x1028>
81133514:	a080100c 	andi	r2,r20,64
81133518:	d8001d85 	stb	zero,118(sp)
8113351c:	da802217 	ldw	r10,136(sp)
81133520:	1002231e 	bne	r2,zero,81133db0 <___vfiprintf_internal_r+0x123c>
81133524:	50800104 	addi	r2,r10,4
81133528:	54800017 	ldw	r18,0(r10)
8113352c:	0027883a 	mov	r19,zero
81133530:	4801a00e 	bge	r9,zero,81133bb4 <___vfiprintf_internal_r+0x1040>
81133534:	d8802215 	stw	r2,136(sp)
81133538:	0039883a 	mov	fp,zero
8113353c:	94c4b03a 	or	r2,r18,r19
81133540:	103f901e 	bne	r2,zero,81133384 <__reset+0xfb113384>
81133544:	00800044 	movi	r2,1
81133548:	10803fcc 	andi	r2,r2,255
8113354c:	00c00044 	movi	r3,1
81133550:	10c05926 	beq	r2,r3,811336b8 <___vfiprintf_internal_r+0xb44>
81133554:	00c00084 	movi	r3,2
81133558:	10ffe41e 	bne	r2,r3,811334ec <__reset+0xfb1134ec>
8113355c:	0025883a 	mov	r18,zero
81133560:	0027883a 	mov	r19,zero
81133564:	00013d06 	br	81133a5c <___vfiprintf_internal_r+0xee8>
81133568:	21003fcc 	andi	r4,r4,255
8113356c:	2002811e 	bne	r4,zero,81133f74 <___vfiprintf_internal_r+0x1400>
81133570:	00a04574 	movhi	r2,33045
81133574:	10871d04 	addi	r2,r2,7284
81133578:	d8802615 	stw	r2,152(sp)
8113357c:	a080080c 	andi	r2,r20,32
81133580:	103f561e 	bne	r2,zero,811332dc <__reset+0xfb1132dc>
81133584:	a080040c 	andi	r2,r20,16
81133588:	1001d126 	beq	r2,zero,81133cd0 <___vfiprintf_internal_r+0x115c>
8113358c:	da802217 	ldw	r10,136(sp)
81133590:	0027883a 	mov	r19,zero
81133594:	54800017 	ldw	r18,0(r10)
81133598:	52800104 	addi	r10,r10,4
8113359c:	da802215 	stw	r10,136(sp)
811335a0:	003f5306 	br	811332f0 <__reset+0xfb1132f0>
811335a4:	da802217 	ldw	r10,136(sp)
811335a8:	d8001d85 	stb	zero,118(sp)
811335ac:	55400017 	ldw	r21,0(r10)
811335b0:	50c00104 	addi	r3,r10,4
811335b4:	a8024226 	beq	r21,zero,81133ec0 <___vfiprintf_internal_r+0x134c>
811335b8:	48021816 	blt	r9,zero,81133e1c <___vfiprintf_internal_r+0x12a8>
811335bc:	480d883a 	mov	r6,r9
811335c0:	000b883a 	mov	r5,zero
811335c4:	a809883a 	mov	r4,r21
811335c8:	d8c02a15 	stw	r3,168(sp)
811335cc:	da002b15 	stw	r8,172(sp)
811335d0:	da402c15 	stw	r9,176(sp)
811335d4:	112d9500 	call	8112d950 <memchr>
811335d8:	d8c02a17 	ldw	r3,168(sp)
811335dc:	da002b17 	ldw	r8,172(sp)
811335e0:	da402c17 	ldw	r9,176(sp)
811335e4:	10024826 	beq	r2,zero,81133f08 <___vfiprintf_internal_r+0x1394>
811335e8:	1567c83a 	sub	r19,r2,r21
811335ec:	df001d83 	ldbu	fp,118(sp)
811335f0:	d8c02215 	stw	r3,136(sp)
811335f4:	0013883a 	mov	r9,zero
811335f8:	003e6006 	br	81132f7c <__reset+0xfb112f7c>
811335fc:	21003fcc 	andi	r4,r4,255
81133600:	203fc026 	beq	r4,zero,81133504 <__reset+0xfb113504>
81133604:	d9c01d85 	stb	r7,118(sp)
81133608:	003fbe06 	br	81133504 <__reset+0xfb113504>
8113360c:	da802217 	ldw	r10,136(sp)
81133610:	54400017 	ldw	r17,0(r10)
81133614:	50800104 	addi	r2,r10,4
81133618:	883e3b16 	blt	r17,zero,81132f08 <__reset+0xfb112f08>
8113361c:	d8802215 	stw	r2,136(sp)
81133620:	80c00007 	ldb	r3,0(r16)
81133624:	003db406 	br	81132cf8 <__reset+0xfb112cf8>
81133628:	01000044 	movi	r4,1
8113362c:	01c00ac4 	movi	r7,43
81133630:	80c00007 	ldb	r3,0(r16)
81133634:	003db006 	br	81132cf8 <__reset+0xfb112cf8>
81133638:	80c00007 	ldb	r3,0(r16)
8113363c:	82800044 	addi	r10,r16,1
81133640:	1b423c26 	beq	r3,r13,81133f34 <___vfiprintf_internal_r+0x13c0>
81133644:	18bff404 	addi	r2,r3,-48
81133648:	0013883a 	mov	r9,zero
8113364c:	30822b36 	bltu	r6,r2,81133efc <___vfiprintf_internal_r+0x1388>
81133650:	50c00007 	ldb	r3,0(r10)
81133654:	4a4002a4 	muli	r9,r9,10
81133658:	54000044 	addi	r16,r10,1
8113365c:	8015883a 	mov	r10,r16
81133660:	4893883a 	add	r9,r9,r2
81133664:	18bff404 	addi	r2,r3,-48
81133668:	30bff92e 	bgeu	r6,r2,81133650 <__reset+0xfb113650>
8113366c:	483da30e 	bge	r9,zero,81132cfc <__reset+0xfb112cfc>
81133670:	027fffc4 	movi	r9,-1
81133674:	003da106 	br	81132cfc <__reset+0xfb112cfc>
81133678:	a5001014 	ori	r20,r20,64
8113367c:	80c00007 	ldb	r3,0(r16)
81133680:	003d9d06 	br	81132cf8 <__reset+0xfb112cf8>
81133684:	da802217 	ldw	r10,136(sp)
81133688:	d8001d85 	stb	zero,118(sp)
8113368c:	50c00204 	addi	r3,r10,8
81133690:	54800017 	ldw	r18,0(r10)
81133694:	54c00117 	ldw	r19,4(r10)
81133698:	4801ca16 	blt	r9,zero,81133dc4 <___vfiprintf_internal_r+0x1250>
8113369c:	013fdfc4 	movi	r4,-129
811336a0:	94c4b03a 	or	r2,r18,r19
811336a4:	d8c02215 	stw	r3,136(sp)
811336a8:	a128703a 	and	r20,r20,r4
811336ac:	0039883a 	mov	fp,zero
811336b0:	103f341e 	bne	r2,zero,81133384 <__reset+0xfb113384>
811336b4:	483e2e26 	beq	r9,zero,81132f70 <__reset+0xfb112f70>
811336b8:	0025883a 	mov	r18,zero
811336bc:	94800c04 	addi	r18,r18,48
811336c0:	dc8019c5 	stb	r18,103(sp)
811336c4:	dcc02717 	ldw	r19,156(sp)
811336c8:	dd4019c4 	addi	r21,sp,103
811336cc:	003e2b06 	br	81132f7c <__reset+0xfb112f7c>
811336d0:	21003fcc 	andi	r4,r4,255
811336d4:	2002361e 	bne	r4,zero,81133fb0 <___vfiprintf_internal_r+0x143c>
811336d8:	1801c126 	beq	r3,zero,81133de0 <___vfiprintf_internal_r+0x126c>
811336dc:	04800044 	movi	r18,1
811336e0:	d8c01005 	stb	r3,64(sp)
811336e4:	d8001d85 	stb	zero,118(sp)
811336e8:	9027883a 	mov	r19,r18
811336ec:	dd401004 	addi	r21,sp,64
811336f0:	003f1106 	br	81133338 <__reset+0xfb113338>
811336f4:	d9402117 	ldw	r5,132(sp)
811336f8:	d9002017 	ldw	r4,128(sp)
811336fc:	d9801a04 	addi	r6,sp,104
81133700:	d9c02b15 	stw	r7,172(sp)
81133704:	dbc02a15 	stw	r15,168(sp)
81133708:	1132a580 	call	81132a58 <__sprint_r.part.0>
8113370c:	d9c02b17 	ldw	r7,172(sp)
81133710:	dbc02a17 	ldw	r15,168(sp)
81133714:	10006d1e 	bne	r2,zero,811338cc <___vfiprintf_internal_r+0xd58>
81133718:	d9801b17 	ldw	r6,108(sp)
8113371c:	d8801c17 	ldw	r2,112(sp)
81133720:	d811883a 	mov	r8,sp
81133724:	31400044 	addi	r5,r6,1
81133728:	003e3306 	br	81132ff8 <__reset+0xfb112ff8>
8113372c:	d9401b17 	ldw	r5,108(sp)
81133730:	d8801c17 	ldw	r2,112(sp)
81133734:	29000044 	addi	r4,r5,1
81133738:	d8c01d87 	ldb	r3,118(sp)
8113373c:	183e4d26 	beq	r3,zero,81133074 <__reset+0xfb113074>
81133740:	00c00044 	movi	r3,1
81133744:	d9401d84 	addi	r5,sp,118
81133748:	10c5883a 	add	r2,r2,r3
8113374c:	41400015 	stw	r5,0(r8)
81133750:	40c00115 	stw	r3,4(r8)
81133754:	d8801c15 	stw	r2,112(sp)
81133758:	d9001b15 	stw	r4,108(sp)
8113375c:	014001c4 	movi	r5,7
81133760:	2900a90e 	bge	r5,r4,81133a08 <___vfiprintf_internal_r+0xe94>
81133764:	1000da1e 	bne	r2,zero,81133ad0 <___vfiprintf_internal_r+0xf5c>
81133768:	7000ab1e 	bne	r14,zero,81133a18 <___vfiprintf_internal_r+0xea4>
8113376c:	000b883a 	mov	r5,zero
81133770:	1809883a 	mov	r4,r3
81133774:	d811883a 	mov	r8,sp
81133778:	00c02004 	movi	r3,128
8113377c:	e0fe4d26 	beq	fp,r3,811330b4 <__reset+0xfb1130b4>
81133780:	4cf9c83a 	sub	fp,r9,r19
81133784:	073e7b0e 	bge	zero,fp,81133174 <__reset+0xfb113174>
81133788:	01c00404 	movi	r7,16
8113378c:	3f01900e 	bge	r7,fp,81133dd0 <___vfiprintf_internal_r+0x125c>
81133790:	00e04574 	movhi	r3,33045
81133794:	18c7b404 	addi	r3,r3,7888
81133798:	d8c02415 	stw	r3,144(sp)
8113379c:	034001c4 	movi	r13,7
811337a0:	00000506 	br	811337b8 <___vfiprintf_internal_r+0xc44>
811337a4:	29000084 	addi	r4,r5,2
811337a8:	42000204 	addi	r8,r8,8
811337ac:	180b883a 	mov	r5,r3
811337b0:	e73ffc04 	addi	fp,fp,-16
811337b4:	3f000d0e 	bge	r7,fp,811337ec <___vfiprintf_internal_r+0xc78>
811337b8:	10800404 	addi	r2,r2,16
811337bc:	28c00044 	addi	r3,r5,1
811337c0:	45c00015 	stw	r23,0(r8)
811337c4:	41c00115 	stw	r7,4(r8)
811337c8:	d8801c15 	stw	r2,112(sp)
811337cc:	d8c01b15 	stw	r3,108(sp)
811337d0:	68fff40e 	bge	r13,r3,811337a4 <__reset+0xfb1137a4>
811337d4:	1000101e 	bne	r2,zero,81133818 <___vfiprintf_internal_r+0xca4>
811337d8:	e73ffc04 	addi	fp,fp,-16
811337dc:	01000044 	movi	r4,1
811337e0:	000b883a 	mov	r5,zero
811337e4:	d811883a 	mov	r8,sp
811337e8:	3f3ff316 	blt	r7,fp,811337b8 <__reset+0xfb1137b8>
811337ec:	da802417 	ldw	r10,144(sp)
811337f0:	1705883a 	add	r2,r2,fp
811337f4:	47000115 	stw	fp,4(r8)
811337f8:	42800015 	stw	r10,0(r8)
811337fc:	d8801c15 	stw	r2,112(sp)
81133800:	d9001b15 	stw	r4,108(sp)
81133804:	00c001c4 	movi	r3,7
81133808:	19003616 	blt	r3,r4,811338e4 <___vfiprintf_internal_r+0xd70>
8113380c:	42000204 	addi	r8,r8,8
81133810:	21000044 	addi	r4,r4,1
81133814:	003e5706 	br	81133174 <__reset+0xfb113174>
81133818:	d9402117 	ldw	r5,132(sp)
8113381c:	d9002017 	ldw	r4,128(sp)
81133820:	d9801a04 	addi	r6,sp,104
81133824:	d9c02b15 	stw	r7,172(sp)
81133828:	db402a15 	stw	r13,168(sp)
8113382c:	1132a580 	call	81132a58 <__sprint_r.part.0>
81133830:	d9c02b17 	ldw	r7,172(sp)
81133834:	db402a17 	ldw	r13,168(sp)
81133838:	1000241e 	bne	r2,zero,811338cc <___vfiprintf_internal_r+0xd58>
8113383c:	d9401b17 	ldw	r5,108(sp)
81133840:	d8801c17 	ldw	r2,112(sp)
81133844:	d811883a 	mov	r8,sp
81133848:	29000044 	addi	r4,r5,1
8113384c:	003fd806 	br	811337b0 <__reset+0xfb1137b0>
81133850:	d9401b17 	ldw	r5,108(sp)
81133854:	00e04574 	movhi	r3,33045
81133858:	18c7b804 	addi	r3,r3,7904
8113385c:	d8c02415 	stw	r3,144(sp)
81133860:	29400044 	addi	r5,r5,1
81133864:	d8c02417 	ldw	r3,144(sp)
81133868:	14c5883a 	add	r2,r2,r19
8113386c:	44c00115 	stw	r19,4(r8)
81133870:	40c00015 	stw	r3,0(r8)
81133874:	d8801c15 	stw	r2,112(sp)
81133878:	d9401b15 	stw	r5,108(sp)
8113387c:	00c001c4 	movi	r3,7
81133880:	1940070e 	bge	r3,r5,811338a0 <___vfiprintf_internal_r+0xd2c>
81133884:	103e4826 	beq	r2,zero,811331a8 <__reset+0xfb1131a8>
81133888:	d9402117 	ldw	r5,132(sp)
8113388c:	d9002017 	ldw	r4,128(sp)
81133890:	d9801a04 	addi	r6,sp,104
81133894:	1132a580 	call	81132a58 <__sprint_r.part.0>
81133898:	10000c1e 	bne	r2,zero,811338cc <___vfiprintf_internal_r+0xd58>
8113389c:	d8801c17 	ldw	r2,112(sp)
811338a0:	8c80010e 	bge	r17,r18,811338a8 <___vfiprintf_internal_r+0xd34>
811338a4:	9023883a 	mov	r17,r18
811338a8:	da802317 	ldw	r10,140(sp)
811338ac:	5455883a 	add	r10,r10,r17
811338b0:	da802315 	stw	r10,140(sp)
811338b4:	103e4126 	beq	r2,zero,811331bc <__reset+0xfb1131bc>
811338b8:	d9402117 	ldw	r5,132(sp)
811338bc:	d9002017 	ldw	r4,128(sp)
811338c0:	d9801a04 	addi	r6,sp,104
811338c4:	1132a580 	call	81132a58 <__sprint_r.part.0>
811338c8:	103e3c26 	beq	r2,zero,811331bc <__reset+0xfb1131bc>
811338cc:	dd002117 	ldw	r20,132(sp)
811338d0:	a080030b 	ldhu	r2,12(r20)
811338d4:	1080100c 	andi	r2,r2,64
811338d8:	1001231e 	bne	r2,zero,81133d68 <___vfiprintf_internal_r+0x11f4>
811338dc:	d8802317 	ldw	r2,140(sp)
811338e0:	003d7b06 	br	81132ed0 <__reset+0xfb112ed0>
811338e4:	1000991e 	bne	r2,zero,81133b4c <___vfiprintf_internal_r+0xfd8>
811338e8:	00c00044 	movi	r3,1
811338ec:	9805883a 	mov	r2,r19
811338f0:	dd400015 	stw	r21,0(sp)
811338f4:	dcc00115 	stw	r19,4(sp)
811338f8:	dcc01c15 	stw	r19,112(sp)
811338fc:	d8c01b15 	stw	r3,108(sp)
81133900:	d811883a 	mov	r8,sp
81133904:	42000204 	addi	r8,r8,8
81133908:	a2c0010c 	andi	r11,r20,4
8113390c:	583fe426 	beq	r11,zero,811338a0 <__reset+0xfb1138a0>
81133910:	8ca7c83a 	sub	r19,r17,r18
81133914:	04ffe20e 	bge	zero,r19,811338a0 <__reset+0xfb1138a0>
81133918:	01c00404 	movi	r7,16
8113391c:	3cffcc0e 	bge	r7,r19,81133850 <__reset+0xfb113850>
81133920:	02a04574 	movhi	r10,33045
81133924:	5287b804 	addi	r10,r10,7904
81133928:	d9001b17 	ldw	r4,108(sp)
8113392c:	da802415 	stw	r10,144(sp)
81133930:	382b883a 	mov	r21,r7
81133934:	050001c4 	movi	r20,7
81133938:	df002017 	ldw	fp,128(sp)
8113393c:	00000506 	br	81133954 <___vfiprintf_internal_r+0xde0>
81133940:	21400084 	addi	r5,r4,2
81133944:	42000204 	addi	r8,r8,8
81133948:	1809883a 	mov	r4,r3
8113394c:	9cfffc04 	addi	r19,r19,-16
81133950:	acffc40e 	bge	r21,r19,81133864 <__reset+0xfb113864>
81133954:	10800404 	addi	r2,r2,16
81133958:	20c00044 	addi	r3,r4,1
8113395c:	45800015 	stw	r22,0(r8)
81133960:	45400115 	stw	r21,4(r8)
81133964:	d8801c15 	stw	r2,112(sp)
81133968:	d8c01b15 	stw	r3,108(sp)
8113396c:	a0fff40e 	bge	r20,r3,81133940 <__reset+0xfb113940>
81133970:	1000041e 	bne	r2,zero,81133984 <___vfiprintf_internal_r+0xe10>
81133974:	01400044 	movi	r5,1
81133978:	0009883a 	mov	r4,zero
8113397c:	d811883a 	mov	r8,sp
81133980:	003ff206 	br	8113394c <__reset+0xfb11394c>
81133984:	d9402117 	ldw	r5,132(sp)
81133988:	d9801a04 	addi	r6,sp,104
8113398c:	e009883a 	mov	r4,fp
81133990:	1132a580 	call	81132a58 <__sprint_r.part.0>
81133994:	103fcd1e 	bne	r2,zero,811338cc <__reset+0xfb1138cc>
81133998:	d9001b17 	ldw	r4,108(sp)
8113399c:	d8801c17 	ldw	r2,112(sp)
811339a0:	d811883a 	mov	r8,sp
811339a4:	21400044 	addi	r5,r4,1
811339a8:	003fe806 	br	8113394c <__reset+0xfb11394c>
811339ac:	d9402117 	ldw	r5,132(sp)
811339b0:	d9002017 	ldw	r4,128(sp)
811339b4:	d9801a04 	addi	r6,sp,104
811339b8:	d9c02b15 	stw	r7,172(sp)
811339bc:	db402a15 	stw	r13,168(sp)
811339c0:	1132a580 	call	81132a58 <__sprint_r.part.0>
811339c4:	d9c02b17 	ldw	r7,172(sp)
811339c8:	db402a17 	ldw	r13,168(sp)
811339cc:	103fbf1e 	bne	r2,zero,811338cc <__reset+0xfb1138cc>
811339d0:	d9401b17 	ldw	r5,108(sp)
811339d4:	d8801c17 	ldw	r2,112(sp)
811339d8:	d811883a 	mov	r8,sp
811339dc:	29800044 	addi	r6,r5,1
811339e0:	003dc406 	br	811330f4 <__reset+0xfb1130f4>
811339e4:	1000d21e 	bne	r2,zero,81133d30 <___vfiprintf_internal_r+0x11bc>
811339e8:	d8c01d87 	ldb	r3,118(sp)
811339ec:	18009526 	beq	r3,zero,81133c44 <___vfiprintf_internal_r+0x10d0>
811339f0:	00800044 	movi	r2,1
811339f4:	d8c01d84 	addi	r3,sp,118
811339f8:	1009883a 	mov	r4,r2
811339fc:	d8c00015 	stw	r3,0(sp)
81133a00:	d8800115 	stw	r2,4(sp)
81133a04:	d811883a 	mov	r8,sp
81133a08:	200b883a 	mov	r5,r4
81133a0c:	42000204 	addi	r8,r8,8
81133a10:	21000044 	addi	r4,r4,1
81133a14:	003d9706 	br	81133074 <__reset+0xfb113074>
81133a18:	d9001d04 	addi	r4,sp,116
81133a1c:	00800084 	movi	r2,2
81133a20:	d9000015 	stw	r4,0(sp)
81133a24:	d8800115 	stw	r2,4(sp)
81133a28:	1809883a 	mov	r4,r3
81133a2c:	d811883a 	mov	r8,sp
81133a30:	200b883a 	mov	r5,r4
81133a34:	42000204 	addi	r8,r8,8
81133a38:	21000044 	addi	r4,r4,1
81133a3c:	003f4e06 	br	81133778 <__reset+0xfb113778>
81133a40:	d8001d85 	stb	zero,118(sp)
81133a44:	48005016 	blt	r9,zero,81133b88 <___vfiprintf_internal_r+0x1014>
81133a48:	00ffdfc4 	movi	r3,-129
81133a4c:	94c4b03a 	or	r2,r18,r19
81133a50:	a0e8703a 	and	r20,r20,r3
81133a54:	103d4426 	beq	r2,zero,81132f68 <__reset+0xfb112f68>
81133a58:	0039883a 	mov	fp,zero
81133a5c:	d9002617 	ldw	r4,152(sp)
81133a60:	dd401a04 	addi	r21,sp,104
81133a64:	908003cc 	andi	r2,r18,15
81133a68:	9806973a 	slli	r3,r19,28
81133a6c:	2085883a 	add	r2,r4,r2
81133a70:	9024d13a 	srli	r18,r18,4
81133a74:	10800003 	ldbu	r2,0(r2)
81133a78:	9826d13a 	srli	r19,r19,4
81133a7c:	ad7fffc4 	addi	r21,r21,-1
81133a80:	1ca4b03a 	or	r18,r3,r18
81133a84:	a8800005 	stb	r2,0(r21)
81133a88:	94c4b03a 	or	r2,r18,r19
81133a8c:	103ff51e 	bne	r2,zero,81133a64 <__reset+0xfb113a64>
81133a90:	003e5906 	br	811333f8 <__reset+0xfb1133f8>
81133a94:	d9402117 	ldw	r5,132(sp)
81133a98:	d9002017 	ldw	r4,128(sp)
81133a9c:	d9801a04 	addi	r6,sp,104
81133aa0:	1132a580 	call	81132a58 <__sprint_r.part.0>
81133aa4:	103f891e 	bne	r2,zero,811338cc <__reset+0xfb1138cc>
81133aa8:	d8801c17 	ldw	r2,112(sp)
81133aac:	d811883a 	mov	r8,sp
81133ab0:	003f9506 	br	81133908 <__reset+0xfb113908>
81133ab4:	d9402117 	ldw	r5,132(sp)
81133ab8:	d9002017 	ldw	r4,128(sp)
81133abc:	d9801a04 	addi	r6,sp,104
81133ac0:	1132a580 	call	81132a58 <__sprint_r.part.0>
81133ac4:	103f811e 	bne	r2,zero,811338cc <__reset+0xfb1138cc>
81133ac8:	d811883a 	mov	r8,sp
81133acc:	003ced06 	br	81132e84 <__reset+0xfb112e84>
81133ad0:	d9402117 	ldw	r5,132(sp)
81133ad4:	d9002017 	ldw	r4,128(sp)
81133ad8:	d9801a04 	addi	r6,sp,104
81133adc:	da402c15 	stw	r9,176(sp)
81133ae0:	db802a15 	stw	r14,168(sp)
81133ae4:	1132a580 	call	81132a58 <__sprint_r.part.0>
81133ae8:	da402c17 	ldw	r9,176(sp)
81133aec:	db802a17 	ldw	r14,168(sp)
81133af0:	103f761e 	bne	r2,zero,811338cc <__reset+0xfb1138cc>
81133af4:	d9401b17 	ldw	r5,108(sp)
81133af8:	d8801c17 	ldw	r2,112(sp)
81133afc:	d811883a 	mov	r8,sp
81133b00:	29000044 	addi	r4,r5,1
81133b04:	003d5b06 	br	81133074 <__reset+0xfb113074>
81133b08:	d9402117 	ldw	r5,132(sp)
81133b0c:	d9002017 	ldw	r4,128(sp)
81133b10:	d9801a04 	addi	r6,sp,104
81133b14:	da402c15 	stw	r9,176(sp)
81133b18:	1132a580 	call	81132a58 <__sprint_r.part.0>
81133b1c:	da402c17 	ldw	r9,176(sp)
81133b20:	103f6a1e 	bne	r2,zero,811338cc <__reset+0xfb1138cc>
81133b24:	d9401b17 	ldw	r5,108(sp)
81133b28:	d8801c17 	ldw	r2,112(sp)
81133b2c:	d811883a 	mov	r8,sp
81133b30:	29000044 	addi	r4,r5,1
81133b34:	003f1006 	br	81133778 <__reset+0xfb113778>
81133b38:	1000c31e 	bne	r2,zero,81133e48 <___vfiprintf_internal_r+0x12d4>
81133b3c:	01000044 	movi	r4,1
81133b40:	000b883a 	mov	r5,zero
81133b44:	d811883a 	mov	r8,sp
81133b48:	003f0d06 	br	81133780 <__reset+0xfb113780>
81133b4c:	d9402117 	ldw	r5,132(sp)
81133b50:	d9002017 	ldw	r4,128(sp)
81133b54:	d9801a04 	addi	r6,sp,104
81133b58:	1132a580 	call	81132a58 <__sprint_r.part.0>
81133b5c:	103f5b1e 	bne	r2,zero,811338cc <__reset+0xfb1138cc>
81133b60:	d9001b17 	ldw	r4,108(sp)
81133b64:	d8801c17 	ldw	r2,112(sp)
81133b68:	d811883a 	mov	r8,sp
81133b6c:	21000044 	addi	r4,r4,1
81133b70:	003d8006 	br	81133174 <__reset+0xfb113174>
81133b74:	01204574 	movhi	r4,33045
81133b78:	21072204 	addi	r4,r4,7304
81133b7c:	d9002615 	stw	r4,152(sp)
81133b80:	d8c02215 	stw	r3,136(sp)
81133b84:	1029883a 	mov	r20,r2
81133b88:	94c4b03a 	or	r2,r18,r19
81133b8c:	103fb21e 	bne	r2,zero,81133a58 <__reset+0xfb113a58>
81133b90:	0039883a 	mov	fp,zero
81133b94:	00800084 	movi	r2,2
81133b98:	003e6b06 	br	81133548 <__reset+0xfb113548>
81133b9c:	da802217 	ldw	r10,136(sp)
81133ba0:	d8001d85 	stb	zero,118(sp)
81133ba4:	0027883a 	mov	r19,zero
81133ba8:	50800104 	addi	r2,r10,4
81133bac:	54800017 	ldw	r18,0(r10)
81133bb0:	483e6016 	blt	r9,zero,81133534 <__reset+0xfb113534>
81133bb4:	00ffdfc4 	movi	r3,-129
81133bb8:	d8802215 	stw	r2,136(sp)
81133bbc:	a0e8703a 	and	r20,r20,r3
81133bc0:	0039883a 	mov	fp,zero
81133bc4:	903ebb26 	beq	r18,zero,811336b4 <__reset+0xfb1136b4>
81133bc8:	00800244 	movi	r2,9
81133bcc:	14bdee36 	bltu	r2,r18,81133388 <__reset+0xfb113388>
81133bd0:	003eba06 	br	811336bc <__reset+0xfb1136bc>
81133bd4:	00800c04 	movi	r2,48
81133bd8:	d8c01d45 	stb	r3,117(sp)
81133bdc:	d8801d05 	stb	r2,116(sp)
81133be0:	d8001d85 	stb	zero,118(sp)
81133be4:	a0c00094 	ori	r3,r20,2
81133be8:	4800a916 	blt	r9,zero,81133e90 <___vfiprintf_internal_r+0x131c>
81133bec:	00bfdfc4 	movi	r2,-129
81133bf0:	a096703a 	and	r11,r20,r2
81133bf4:	5d000094 	ori	r20,r11,2
81133bf8:	0039883a 	mov	fp,zero
81133bfc:	003f9706 	br	81133a5c <__reset+0xfb113a5c>
81133c00:	8025883a 	mov	r18,r16
81133c04:	003c2e06 	br	81132cc0 <__reset+0xfb112cc0>
81133c08:	00a04574 	movhi	r2,33045
81133c0c:	10872204 	addi	r2,r2,7304
81133c10:	0039883a 	mov	fp,zero
81133c14:	d8802615 	stw	r2,152(sp)
81133c18:	003f9006 	br	81133a5c <__reset+0xfb113a5c>
81133c1c:	04a5c83a 	sub	r18,zero,r18
81133c20:	07000b44 	movi	fp,45
81133c24:	9004c03a 	cmpne	r2,r18,zero
81133c28:	04e7c83a 	sub	r19,zero,r19
81133c2c:	df001d85 	stb	fp,118(sp)
81133c30:	98a7c83a 	sub	r19,r19,r2
81133c34:	48009f16 	blt	r9,zero,81133eb4 <___vfiprintf_internal_r+0x1340>
81133c38:	00bfdfc4 	movi	r2,-129
81133c3c:	a0a8703a 	and	r20,r20,r2
81133c40:	003dd006 	br	81133384 <__reset+0xfb113384>
81133c44:	70004c26 	beq	r14,zero,81133d78 <___vfiprintf_internal_r+0x1204>
81133c48:	00800084 	movi	r2,2
81133c4c:	d8c01d04 	addi	r3,sp,116
81133c50:	d8c00015 	stw	r3,0(sp)
81133c54:	d8800115 	stw	r2,4(sp)
81133c58:	01000044 	movi	r4,1
81133c5c:	d811883a 	mov	r8,sp
81133c60:	003f7306 	br	81133a30 <__reset+0xfb113a30>
81133c64:	a080100c 	andi	r2,r20,64
81133c68:	da802217 	ldw	r10,136(sp)
81133c6c:	103e0626 	beq	r2,zero,81133488 <__reset+0xfb113488>
81133c70:	5480000f 	ldh	r18,0(r10)
81133c74:	52800104 	addi	r10,r10,4
81133c78:	da802215 	stw	r10,136(sp)
81133c7c:	9027d7fa 	srai	r19,r18,31
81133c80:	9805883a 	mov	r2,r19
81133c84:	003db806 	br	81133368 <__reset+0xfb113368>
81133c88:	a080040c 	andi	r2,r20,16
81133c8c:	1000091e 	bne	r2,zero,81133cb4 <___vfiprintf_internal_r+0x1140>
81133c90:	a2c0100c 	andi	r11,r20,64
81133c94:	58000726 	beq	r11,zero,81133cb4 <___vfiprintf_internal_r+0x1140>
81133c98:	da802217 	ldw	r10,136(sp)
81133c9c:	50800017 	ldw	r2,0(r10)
81133ca0:	52800104 	addi	r10,r10,4
81133ca4:	da802215 	stw	r10,136(sp)
81133ca8:	da802317 	ldw	r10,140(sp)
81133cac:	1280000d 	sth	r10,0(r2)
81133cb0:	003be706 	br	81132c50 <__reset+0xfb112c50>
81133cb4:	da802217 	ldw	r10,136(sp)
81133cb8:	50800017 	ldw	r2,0(r10)
81133cbc:	52800104 	addi	r10,r10,4
81133cc0:	da802215 	stw	r10,136(sp)
81133cc4:	da802317 	ldw	r10,140(sp)
81133cc8:	12800015 	stw	r10,0(r2)
81133ccc:	003be006 	br	81132c50 <__reset+0xfb112c50>
81133cd0:	a080100c 	andi	r2,r20,64
81133cd4:	da802217 	ldw	r10,136(sp)
81133cd8:	10003026 	beq	r2,zero,81133d9c <___vfiprintf_internal_r+0x1228>
81133cdc:	5480000b 	ldhu	r18,0(r10)
81133ce0:	52800104 	addi	r10,r10,4
81133ce4:	0027883a 	mov	r19,zero
81133ce8:	da802215 	stw	r10,136(sp)
81133cec:	003d8006 	br	811332f0 <__reset+0xfb1132f0>
81133cf0:	80c00007 	ldb	r3,0(r16)
81133cf4:	003c0006 	br	81132cf8 <__reset+0xfb112cf8>
81133cf8:	a080100c 	andi	r2,r20,64
81133cfc:	d8001d85 	stb	zero,118(sp)
81133d00:	da802217 	ldw	r10,136(sp)
81133d04:	1000201e 	bne	r2,zero,81133d88 <___vfiprintf_internal_r+0x1214>
81133d08:	50800104 	addi	r2,r10,4
81133d0c:	54800017 	ldw	r18,0(r10)
81133d10:	0027883a 	mov	r19,zero
81133d14:	483def0e 	bge	r9,zero,811334d4 <__reset+0xfb1134d4>
81133d18:	94c6b03a 	or	r3,r18,r19
81133d1c:	d8802215 	stw	r2,136(sp)
81133d20:	183d4e1e 	bne	r3,zero,8113325c <__reset+0xfb11325c>
81133d24:	0039883a 	mov	fp,zero
81133d28:	0005883a 	mov	r2,zero
81133d2c:	003e0606 	br	81133548 <__reset+0xfb113548>
81133d30:	d9402117 	ldw	r5,132(sp)
81133d34:	d9002017 	ldw	r4,128(sp)
81133d38:	d9801a04 	addi	r6,sp,104
81133d3c:	da402c15 	stw	r9,176(sp)
81133d40:	db802a15 	stw	r14,168(sp)
81133d44:	1132a580 	call	81132a58 <__sprint_r.part.0>
81133d48:	da402c17 	ldw	r9,176(sp)
81133d4c:	db802a17 	ldw	r14,168(sp)
81133d50:	103ede1e 	bne	r2,zero,811338cc <__reset+0xfb1138cc>
81133d54:	d9401b17 	ldw	r5,108(sp)
81133d58:	d8801c17 	ldw	r2,112(sp)
81133d5c:	d811883a 	mov	r8,sp
81133d60:	29000044 	addi	r4,r5,1
81133d64:	003e7406 	br	81133738 <__reset+0xfb113738>
81133d68:	00bfffc4 	movi	r2,-1
81133d6c:	003c5806 	br	81132ed0 <__reset+0xfb112ed0>
81133d70:	d811883a 	mov	r8,sp
81133d74:	003ee806 	br	81133918 <__reset+0xfb113918>
81133d78:	000b883a 	mov	r5,zero
81133d7c:	01000044 	movi	r4,1
81133d80:	d811883a 	mov	r8,sp
81133d84:	003e7c06 	br	81133778 <__reset+0xfb113778>
81133d88:	50800104 	addi	r2,r10,4
81133d8c:	5480000b 	ldhu	r18,0(r10)
81133d90:	0027883a 	mov	r19,zero
81133d94:	483dcf0e 	bge	r9,zero,811334d4 <__reset+0xfb1134d4>
81133d98:	003fdf06 	br	81133d18 <__reset+0xfb113d18>
81133d9c:	54800017 	ldw	r18,0(r10)
81133da0:	52800104 	addi	r10,r10,4
81133da4:	0027883a 	mov	r19,zero
81133da8:	da802215 	stw	r10,136(sp)
81133dac:	003d5006 	br	811332f0 <__reset+0xfb1132f0>
81133db0:	50800104 	addi	r2,r10,4
81133db4:	5480000b 	ldhu	r18,0(r10)
81133db8:	0027883a 	mov	r19,zero
81133dbc:	483f7d0e 	bge	r9,zero,81133bb4 <__reset+0xfb113bb4>
81133dc0:	003ddc06 	br	81133534 <__reset+0xfb113534>
81133dc4:	d8c02215 	stw	r3,136(sp)
81133dc8:	0039883a 	mov	fp,zero
81133dcc:	003ddb06 	br	8113353c <__reset+0xfb11353c>
81133dd0:	02a04574 	movhi	r10,33045
81133dd4:	5287b404 	addi	r10,r10,7888
81133dd8:	da802415 	stw	r10,144(sp)
81133ddc:	003e8306 	br	811337ec <__reset+0xfb1137ec>
81133de0:	d8801c17 	ldw	r2,112(sp)
81133de4:	dd002117 	ldw	r20,132(sp)
81133de8:	103eb926 	beq	r2,zero,811338d0 <__reset+0xfb1138d0>
81133dec:	d9002017 	ldw	r4,128(sp)
81133df0:	d9801a04 	addi	r6,sp,104
81133df4:	a00b883a 	mov	r5,r20
81133df8:	1132a580 	call	81132a58 <__sprint_r.part.0>
81133dfc:	003eb406 	br	811338d0 <__reset+0xfb1138d0>
81133e00:	80c00043 	ldbu	r3,1(r16)
81133e04:	a5000814 	ori	r20,r20,32
81133e08:	84000044 	addi	r16,r16,1
81133e0c:	18c03fcc 	andi	r3,r3,255
81133e10:	18c0201c 	xori	r3,r3,128
81133e14:	18ffe004 	addi	r3,r3,-128
81133e18:	003bb706 	br	81132cf8 <__reset+0xfb112cf8>
81133e1c:	a809883a 	mov	r4,r21
81133e20:	d8c02a15 	stw	r3,168(sp)
81133e24:	da002b15 	stw	r8,172(sp)
81133e28:	11244540 	call	81124454 <strlen>
81133e2c:	d8c02a17 	ldw	r3,168(sp)
81133e30:	1027883a 	mov	r19,r2
81133e34:	df001d83 	ldbu	fp,118(sp)
81133e38:	d8c02215 	stw	r3,136(sp)
81133e3c:	0013883a 	mov	r9,zero
81133e40:	da002b17 	ldw	r8,172(sp)
81133e44:	003c4d06 	br	81132f7c <__reset+0xfb112f7c>
81133e48:	d9402117 	ldw	r5,132(sp)
81133e4c:	d9002017 	ldw	r4,128(sp)
81133e50:	d9801a04 	addi	r6,sp,104
81133e54:	da402c15 	stw	r9,176(sp)
81133e58:	1132a580 	call	81132a58 <__sprint_r.part.0>
81133e5c:	da402c17 	ldw	r9,176(sp)
81133e60:	103e9a1e 	bne	r2,zero,811338cc <__reset+0xfb1138cc>
81133e64:	d9401b17 	ldw	r5,108(sp)
81133e68:	d8801c17 	ldw	r2,112(sp)
81133e6c:	d811883a 	mov	r8,sp
81133e70:	29000044 	addi	r4,r5,1
81133e74:	003e4206 	br	81133780 <__reset+0xfb113780>
81133e78:	d9401b17 	ldw	r5,108(sp)
81133e7c:	01204574 	movhi	r4,33045
81133e80:	2107b804 	addi	r4,r4,7904
81133e84:	d9002415 	stw	r4,144(sp)
81133e88:	29400044 	addi	r5,r5,1
81133e8c:	003c6d06 	br	81133044 <__reset+0xfb113044>
81133e90:	0039883a 	mov	fp,zero
81133e94:	00800084 	movi	r2,2
81133e98:	10803fcc 	andi	r2,r2,255
81133e9c:	01000044 	movi	r4,1
81133ea0:	11001e26 	beq	r2,r4,81133f1c <___vfiprintf_internal_r+0x13a8>
81133ea4:	01000084 	movi	r4,2
81133ea8:	11001e1e 	bne	r2,r4,81133f24 <___vfiprintf_internal_r+0x13b0>
81133eac:	1829883a 	mov	r20,r3
81133eb0:	003eea06 	br	81133a5c <__reset+0xfb113a5c>
81133eb4:	a007883a 	mov	r3,r20
81133eb8:	00800044 	movi	r2,1
81133ebc:	003ff606 	br	81133e98 <__reset+0xfb113e98>
81133ec0:	00800184 	movi	r2,6
81133ec4:	1240012e 	bgeu	r2,r9,81133ecc <___vfiprintf_internal_r+0x1358>
81133ec8:	1013883a 	mov	r9,r2
81133ecc:	4827883a 	mov	r19,r9
81133ed0:	4825883a 	mov	r18,r9
81133ed4:	48001516 	blt	r9,zero,81133f2c <___vfiprintf_internal_r+0x13b8>
81133ed8:	05604574 	movhi	r21,33045
81133edc:	d8c02215 	stw	r3,136(sp)
81133ee0:	ad472704 	addi	r21,r21,7324
81133ee4:	003d1406 	br	81133338 <__reset+0xfb113338>
81133ee8:	02a04574 	movhi	r10,33045
81133eec:	5287b404 	addi	r10,r10,7888
81133ef0:	da802415 	stw	r10,144(sp)
81133ef4:	200d883a 	mov	r6,r4
81133ef8:	003c9106 	br	81133140 <__reset+0xfb113140>
81133efc:	5021883a 	mov	r16,r10
81133f00:	0013883a 	mov	r9,zero
81133f04:	003b7d06 	br	81132cfc <__reset+0xfb112cfc>
81133f08:	4827883a 	mov	r19,r9
81133f0c:	df001d83 	ldbu	fp,118(sp)
81133f10:	d8c02215 	stw	r3,136(sp)
81133f14:	0013883a 	mov	r9,zero
81133f18:	003c1806 	br	81132f7c <__reset+0xfb112f7c>
81133f1c:	1829883a 	mov	r20,r3
81133f20:	003d1806 	br	81133384 <__reset+0xfb113384>
81133f24:	1829883a 	mov	r20,r3
81133f28:	003ccd06 	br	81133260 <__reset+0xfb113260>
81133f2c:	0025883a 	mov	r18,zero
81133f30:	003fe906 	br	81133ed8 <__reset+0xfb113ed8>
81133f34:	d8802217 	ldw	r2,136(sp)
81133f38:	80c00043 	ldbu	r3,1(r16)
81133f3c:	5021883a 	mov	r16,r10
81133f40:	12400017 	ldw	r9,0(r2)
81133f44:	10800104 	addi	r2,r2,4
81133f48:	d8802215 	stw	r2,136(sp)
81133f4c:	483faf0e 	bge	r9,zero,81133e0c <__reset+0xfb113e0c>
81133f50:	18c03fcc 	andi	r3,r3,255
81133f54:	18c0201c 	xori	r3,r3,128
81133f58:	027fffc4 	movi	r9,-1
81133f5c:	18ffe004 	addi	r3,r3,-128
81133f60:	003b6506 	br	81132cf8 <__reset+0xfb112cf8>
81133f64:	d9c01d85 	stb	r7,118(sp)
81133f68:	003ca006 	br	811331ec <__reset+0xfb1131ec>
81133f6c:	d9c01d85 	stb	r7,118(sp)
81133f70:	003cad06 	br	81133228 <__reset+0xfb113228>
81133f74:	d9c01d85 	stb	r7,118(sp)
81133f78:	003d7d06 	br	81133570 <__reset+0xfb113570>
81133f7c:	d9c01d85 	stb	r7,118(sp)
81133f80:	003d5f06 	br	81133500 <__reset+0xfb113500>
81133f84:	a080004c 	andi	r2,r20,1
81133f88:	0039883a 	mov	fp,zero
81133f8c:	10000526 	beq	r2,zero,81133fa4 <___vfiprintf_internal_r+0x1430>
81133f90:	00800c04 	movi	r2,48
81133f94:	d88019c5 	stb	r2,103(sp)
81133f98:	dcc02717 	ldw	r19,156(sp)
81133f9c:	dd4019c4 	addi	r21,sp,103
81133fa0:	003bf606 	br	81132f7c <__reset+0xfb112f7c>
81133fa4:	0027883a 	mov	r19,zero
81133fa8:	dd401a04 	addi	r21,sp,104
81133fac:	003bf306 	br	81132f7c <__reset+0xfb112f7c>
81133fb0:	d9c01d85 	stb	r7,118(sp)
81133fb4:	003dc806 	br	811336d8 <__reset+0xfb1136d8>
81133fb8:	d9c01d85 	stb	r7,118(sp)
81133fbc:	003d3a06 	br	811334a8 <__reset+0xfb1134a8>
81133fc0:	d9c01d85 	stb	r7,118(sp)
81133fc4:	003d2a06 	br	81133470 <__reset+0xfb113470>
81133fc8:	d9c01d85 	stb	r7,118(sp)
81133fcc:	003cde06 	br	81133348 <__reset+0xfb113348>
81133fd0:	d9c01d85 	stb	r7,118(sp)
81133fd4:	003cbc06 	br	811332c8 <__reset+0xfb1132c8>

81133fd8 <__vfiprintf_internal>:
81133fd8:	00a04574 	movhi	r2,33045
81133fdc:	1090f104 	addi	r2,r2,17348
81133fe0:	300f883a 	mov	r7,r6
81133fe4:	280d883a 	mov	r6,r5
81133fe8:	200b883a 	mov	r5,r4
81133fec:	11000017 	ldw	r4,0(r2)
81133ff0:	1132b741 	jmpi	81132b74 <___vfiprintf_internal_r>

81133ff4 <__sbprintf>:
81133ff4:	defee204 	addi	sp,sp,-1144
81133ff8:	de00012e 	bgeu	sp,et,81134000 <__sbprintf+0xc>
81133ffc:	003b68fa 	trap	3
81134000:	2880030b 	ldhu	r2,12(r5)
81134004:	2ac01917 	ldw	r11,100(r5)
81134008:	2a80038b 	ldhu	r10,14(r5)
8113400c:	2a400717 	ldw	r9,28(r5)
81134010:	2a000917 	ldw	r8,36(r5)
81134014:	00c10004 	movi	r3,1024
81134018:	dc011a15 	stw	r16,1128(sp)
8113401c:	10bfff4c 	andi	r2,r2,65533
81134020:	2821883a 	mov	r16,r5
81134024:	d8cb883a 	add	r5,sp,r3
81134028:	dc811c15 	stw	r18,1136(sp)
8113402c:	dc411b15 	stw	r17,1132(sp)
81134030:	dfc11d15 	stw	ra,1140(sp)
81134034:	2025883a 	mov	r18,r4
81134038:	d881030d 	sth	r2,1036(sp)
8113403c:	dac11915 	stw	r11,1124(sp)
81134040:	da81038d 	sth	r10,1038(sp)
81134044:	da410715 	stw	r9,1052(sp)
81134048:	da010915 	stw	r8,1060(sp)
8113404c:	dec10015 	stw	sp,1024(sp)
81134050:	dec10415 	stw	sp,1040(sp)
81134054:	d8c10215 	stw	r3,1032(sp)
81134058:	d8c10515 	stw	r3,1044(sp)
8113405c:	d8010615 	stw	zero,1048(sp)
81134060:	1132b740 	call	81132b74 <___vfiprintf_internal_r>
81134064:	1023883a 	mov	r17,r2
81134068:	10000416 	blt	r2,zero,8113407c <__sbprintf+0x88>
8113406c:	d9410004 	addi	r5,sp,1024
81134070:	9009883a 	mov	r4,r18
81134074:	112c32c0 	call	8112c32c <_fflush_r>
81134078:	10000d1e 	bne	r2,zero,811340b0 <__sbprintf+0xbc>
8113407c:	d881030b 	ldhu	r2,1036(sp)
81134080:	1080100c 	andi	r2,r2,64
81134084:	10000326 	beq	r2,zero,81134094 <__sbprintf+0xa0>
81134088:	8080030b 	ldhu	r2,12(r16)
8113408c:	10801014 	ori	r2,r2,64
81134090:	8080030d 	sth	r2,12(r16)
81134094:	8805883a 	mov	r2,r17
81134098:	dfc11d17 	ldw	ra,1140(sp)
8113409c:	dc811c17 	ldw	r18,1136(sp)
811340a0:	dc411b17 	ldw	r17,1132(sp)
811340a4:	dc011a17 	ldw	r16,1128(sp)
811340a8:	dec11e04 	addi	sp,sp,1144
811340ac:	f800283a 	ret
811340b0:	047fffc4 	movi	r17,-1
811340b4:	003ff106 	br	8113407c <__reset+0xfb11407c>

811340b8 <_calloc_r>:
811340b8:	298b383a 	mul	r5,r5,r6
811340bc:	defffe04 	addi	sp,sp,-8
811340c0:	de00012e 	bgeu	sp,et,811340c8 <_calloc_r+0x10>
811340c4:	003b68fa 	trap	3
811340c8:	dfc00115 	stw	ra,4(sp)
811340cc:	dc000015 	stw	r16,0(sp)
811340d0:	11231c80 	call	811231c8 <_malloc_r>
811340d4:	10002926 	beq	r2,zero,8113417c <_calloc_r+0xc4>
811340d8:	11bfff17 	ldw	r6,-4(r2)
811340dc:	1021883a 	mov	r16,r2
811340e0:	00bfff04 	movi	r2,-4
811340e4:	308c703a 	and	r6,r6,r2
811340e8:	00c00904 	movi	r3,36
811340ec:	308d883a 	add	r6,r6,r2
811340f0:	19801636 	bltu	r3,r6,8113414c <_calloc_r+0x94>
811340f4:	008004c4 	movi	r2,19
811340f8:	11800b2e 	bgeu	r2,r6,81134128 <_calloc_r+0x70>
811340fc:	80000015 	stw	zero,0(r16)
81134100:	80000115 	stw	zero,4(r16)
81134104:	008006c4 	movi	r2,27
81134108:	11801a2e 	bgeu	r2,r6,81134174 <_calloc_r+0xbc>
8113410c:	80000215 	stw	zero,8(r16)
81134110:	80000315 	stw	zero,12(r16)
81134114:	30c0151e 	bne	r6,r3,8113416c <_calloc_r+0xb4>
81134118:	80000415 	stw	zero,16(r16)
8113411c:	80800604 	addi	r2,r16,24
81134120:	80000515 	stw	zero,20(r16)
81134124:	00000106 	br	8113412c <_calloc_r+0x74>
81134128:	8005883a 	mov	r2,r16
8113412c:	10000015 	stw	zero,0(r2)
81134130:	10000115 	stw	zero,4(r2)
81134134:	10000215 	stw	zero,8(r2)
81134138:	8005883a 	mov	r2,r16
8113413c:	dfc00117 	ldw	ra,4(sp)
81134140:	dc000017 	ldw	r16,0(sp)
81134144:	dec00204 	addi	sp,sp,8
81134148:	f800283a 	ret
8113414c:	000b883a 	mov	r5,zero
81134150:	8009883a 	mov	r4,r16
81134154:	1123b2c0 	call	81123b2c <memset>
81134158:	8005883a 	mov	r2,r16
8113415c:	dfc00117 	ldw	ra,4(sp)
81134160:	dc000017 	ldw	r16,0(sp)
81134164:	dec00204 	addi	sp,sp,8
81134168:	f800283a 	ret
8113416c:	80800404 	addi	r2,r16,16
81134170:	003fee06 	br	8113412c <__reset+0xfb11412c>
81134174:	80800204 	addi	r2,r16,8
81134178:	003fec06 	br	8113412c <__reset+0xfb11412c>
8113417c:	0005883a 	mov	r2,zero
81134180:	003fee06 	br	8113413c <__reset+0xfb11413c>

81134184 <_fclose_r>:
81134184:	28003b26 	beq	r5,zero,81134274 <_fclose_r+0xf0>
81134188:	defffc04 	addi	sp,sp,-16
8113418c:	de00012e 	bgeu	sp,et,81134194 <_fclose_r+0x10>
81134190:	003b68fa 	trap	3
81134194:	dc400115 	stw	r17,4(sp)
81134198:	dc000015 	stw	r16,0(sp)
8113419c:	dfc00315 	stw	ra,12(sp)
811341a0:	dc800215 	stw	r18,8(sp)
811341a4:	2023883a 	mov	r17,r4
811341a8:	2821883a 	mov	r16,r5
811341ac:	20000226 	beq	r4,zero,811341b8 <_fclose_r+0x34>
811341b0:	20800e17 	ldw	r2,56(r4)
811341b4:	10002726 	beq	r2,zero,81134254 <_fclose_r+0xd0>
811341b8:	8080030f 	ldh	r2,12(r16)
811341bc:	1000071e 	bne	r2,zero,811341dc <_fclose_r+0x58>
811341c0:	0005883a 	mov	r2,zero
811341c4:	dfc00317 	ldw	ra,12(sp)
811341c8:	dc800217 	ldw	r18,8(sp)
811341cc:	dc400117 	ldw	r17,4(sp)
811341d0:	dc000017 	ldw	r16,0(sp)
811341d4:	dec00404 	addi	sp,sp,16
811341d8:	f800283a 	ret
811341dc:	800b883a 	mov	r5,r16
811341e0:	8809883a 	mov	r4,r17
811341e4:	112c1080 	call	8112c108 <__sflush_r>
811341e8:	1025883a 	mov	r18,r2
811341ec:	80800b17 	ldw	r2,44(r16)
811341f0:	10000426 	beq	r2,zero,81134204 <_fclose_r+0x80>
811341f4:	81400717 	ldw	r5,28(r16)
811341f8:	8809883a 	mov	r4,r17
811341fc:	103ee83a 	callr	r2
81134200:	10001616 	blt	r2,zero,8113425c <_fclose_r+0xd8>
81134204:	8080030b 	ldhu	r2,12(r16)
81134208:	1080200c 	andi	r2,r2,128
8113420c:	1000151e 	bne	r2,zero,81134264 <_fclose_r+0xe0>
81134210:	81400c17 	ldw	r5,48(r16)
81134214:	28000526 	beq	r5,zero,8113422c <_fclose_r+0xa8>
81134218:	80801004 	addi	r2,r16,64
8113421c:	28800226 	beq	r5,r2,81134228 <_fclose_r+0xa4>
81134220:	8809883a 	mov	r4,r17
81134224:	112cbc00 	call	8112cbc0 <_free_r>
81134228:	80000c15 	stw	zero,48(r16)
8113422c:	81401117 	ldw	r5,68(r16)
81134230:	28000326 	beq	r5,zero,81134240 <_fclose_r+0xbc>
81134234:	8809883a 	mov	r4,r17
81134238:	112cbc00 	call	8112cbc0 <_free_r>
8113423c:	80001115 	stw	zero,68(r16)
81134240:	112c7380 	call	8112c738 <__sfp_lock_acquire>
81134244:	8000030d 	sth	zero,12(r16)
81134248:	112c73c0 	call	8112c73c <__sfp_lock_release>
8113424c:	9005883a 	mov	r2,r18
81134250:	003fdc06 	br	811341c4 <__reset+0xfb1141c4>
81134254:	112c7280 	call	8112c728 <__sinit>
81134258:	003fd706 	br	811341b8 <__reset+0xfb1141b8>
8113425c:	04bfffc4 	movi	r18,-1
81134260:	003fe806 	br	81134204 <__reset+0xfb114204>
81134264:	81400417 	ldw	r5,16(r16)
81134268:	8809883a 	mov	r4,r17
8113426c:	112cbc00 	call	8112cbc0 <_free_r>
81134270:	003fe706 	br	81134210 <__reset+0xfb114210>
81134274:	0005883a 	mov	r2,zero
81134278:	f800283a 	ret

8113427c <fclose>:
8113427c:	00a04574 	movhi	r2,33045
81134280:	1090f104 	addi	r2,r2,17348
81134284:	200b883a 	mov	r5,r4
81134288:	11000017 	ldw	r4,0(r2)
8113428c:	11341841 	jmpi	81134184 <_fclose_r>

81134290 <__fputwc>:
81134290:	defff804 	addi	sp,sp,-32
81134294:	de00012e 	bgeu	sp,et,8113429c <__fputwc+0xc>
81134298:	003b68fa 	trap	3
8113429c:	dcc00415 	stw	r19,16(sp)
811342a0:	dc800315 	stw	r18,12(sp)
811342a4:	dc000115 	stw	r16,4(sp)
811342a8:	dfc00715 	stw	ra,28(sp)
811342ac:	dd400615 	stw	r21,24(sp)
811342b0:	dd000515 	stw	r20,20(sp)
811342b4:	dc400215 	stw	r17,8(sp)
811342b8:	2027883a 	mov	r19,r4
811342bc:	2825883a 	mov	r18,r5
811342c0:	3021883a 	mov	r16,r6
811342c4:	112d6500 	call	8112d650 <__locale_mb_cur_max>
811342c8:	00c00044 	movi	r3,1
811342cc:	10c03e26 	beq	r2,r3,811343c8 <__fputwc+0x138>
811342d0:	81c01704 	addi	r7,r16,92
811342d4:	900d883a 	mov	r6,r18
811342d8:	d80b883a 	mov	r5,sp
811342dc:	9809883a 	mov	r4,r19
811342e0:	11351140 	call	81135114 <_wcrtomb_r>
811342e4:	1029883a 	mov	r20,r2
811342e8:	00bfffc4 	movi	r2,-1
811342ec:	a0802026 	beq	r20,r2,81134370 <__fputwc+0xe0>
811342f0:	d9400003 	ldbu	r5,0(sp)
811342f4:	a0001c26 	beq	r20,zero,81134368 <__fputwc+0xd8>
811342f8:	0023883a 	mov	r17,zero
811342fc:	05400284 	movi	r21,10
81134300:	00000906 	br	81134328 <__fputwc+0x98>
81134304:	80800017 	ldw	r2,0(r16)
81134308:	11400005 	stb	r5,0(r2)
8113430c:	80c00017 	ldw	r3,0(r16)
81134310:	18c00044 	addi	r3,r3,1
81134314:	80c00015 	stw	r3,0(r16)
81134318:	8c400044 	addi	r17,r17,1
8113431c:	dc45883a 	add	r2,sp,r17
81134320:	8d00112e 	bgeu	r17,r20,81134368 <__fputwc+0xd8>
81134324:	11400003 	ldbu	r5,0(r2)
81134328:	80c00217 	ldw	r3,8(r16)
8113432c:	18ffffc4 	addi	r3,r3,-1
81134330:	80c00215 	stw	r3,8(r16)
81134334:	183ff30e 	bge	r3,zero,81134304 <__reset+0xfb114304>
81134338:	80800617 	ldw	r2,24(r16)
8113433c:	18801916 	blt	r3,r2,811343a4 <__fputwc+0x114>
81134340:	80800017 	ldw	r2,0(r16)
81134344:	11400005 	stb	r5,0(r2)
81134348:	80800017 	ldw	r2,0(r16)
8113434c:	10c00003 	ldbu	r3,0(r2)
81134350:	10800044 	addi	r2,r2,1
81134354:	1d402326 	beq	r3,r21,811343e4 <__fputwc+0x154>
81134358:	80800015 	stw	r2,0(r16)
8113435c:	8c400044 	addi	r17,r17,1
81134360:	dc45883a 	add	r2,sp,r17
81134364:	8d3fef36 	bltu	r17,r20,81134324 <__reset+0xfb114324>
81134368:	9005883a 	mov	r2,r18
8113436c:	00000406 	br	81134380 <__fputwc+0xf0>
81134370:	80c0030b 	ldhu	r3,12(r16)
81134374:	a005883a 	mov	r2,r20
81134378:	18c01014 	ori	r3,r3,64
8113437c:	80c0030d 	sth	r3,12(r16)
81134380:	dfc00717 	ldw	ra,28(sp)
81134384:	dd400617 	ldw	r21,24(sp)
81134388:	dd000517 	ldw	r20,20(sp)
8113438c:	dcc00417 	ldw	r19,16(sp)
81134390:	dc800317 	ldw	r18,12(sp)
81134394:	dc400217 	ldw	r17,8(sp)
81134398:	dc000117 	ldw	r16,4(sp)
8113439c:	dec00804 	addi	sp,sp,32
811343a0:	f800283a 	ret
811343a4:	800d883a 	mov	r6,r16
811343a8:	29403fcc 	andi	r5,r5,255
811343ac:	9809883a 	mov	r4,r19
811343b0:	112a4f00 	call	8112a4f0 <__swbuf_r>
811343b4:	10bfffe0 	cmpeqi	r2,r2,-1
811343b8:	10803fcc 	andi	r2,r2,255
811343bc:	103fd626 	beq	r2,zero,81134318 <__reset+0xfb114318>
811343c0:	00bfffc4 	movi	r2,-1
811343c4:	003fee06 	br	81134380 <__reset+0xfb114380>
811343c8:	90ffffc4 	addi	r3,r18,-1
811343cc:	01003f84 	movi	r4,254
811343d0:	20ffbf36 	bltu	r4,r3,811342d0 <__reset+0xfb1142d0>
811343d4:	900b883a 	mov	r5,r18
811343d8:	dc800005 	stb	r18,0(sp)
811343dc:	1029883a 	mov	r20,r2
811343e0:	003fc506 	br	811342f8 <__reset+0xfb1142f8>
811343e4:	800d883a 	mov	r6,r16
811343e8:	a80b883a 	mov	r5,r21
811343ec:	9809883a 	mov	r4,r19
811343f0:	112a4f00 	call	8112a4f0 <__swbuf_r>
811343f4:	10bfffe0 	cmpeqi	r2,r2,-1
811343f8:	003fef06 	br	811343b8 <__reset+0xfb1143b8>

811343fc <_fputwc_r>:
811343fc:	3080030b 	ldhu	r2,12(r6)
81134400:	10c8000c 	andi	r3,r2,8192
81134404:	1800051e 	bne	r3,zero,8113441c <_fputwc_r+0x20>
81134408:	30c01917 	ldw	r3,100(r6)
8113440c:	10880014 	ori	r2,r2,8192
81134410:	3080030d 	sth	r2,12(r6)
81134414:	18880014 	ori	r2,r3,8192
81134418:	30801915 	stw	r2,100(r6)
8113441c:	11342901 	jmpi	81134290 <__fputwc>

81134420 <fputwc>:
81134420:	00a04574 	movhi	r2,33045
81134424:	defffc04 	addi	sp,sp,-16
81134428:	1090f104 	addi	r2,r2,17348
8113442c:	de00012e 	bgeu	sp,et,81134434 <fputwc+0x14>
81134430:	003b68fa 	trap	3
81134434:	dc000115 	stw	r16,4(sp)
81134438:	14000017 	ldw	r16,0(r2)
8113443c:	dc400215 	stw	r17,8(sp)
81134440:	dfc00315 	stw	ra,12(sp)
81134444:	2023883a 	mov	r17,r4
81134448:	80000226 	beq	r16,zero,81134454 <fputwc+0x34>
8113444c:	80800e17 	ldw	r2,56(r16)
81134450:	10001026 	beq	r2,zero,81134494 <fputwc+0x74>
81134454:	2880030b 	ldhu	r2,12(r5)
81134458:	10c8000c 	andi	r3,r2,8192
8113445c:	1800051e 	bne	r3,zero,81134474 <fputwc+0x54>
81134460:	28c01917 	ldw	r3,100(r5)
81134464:	10880014 	ori	r2,r2,8192
81134468:	2880030d 	sth	r2,12(r5)
8113446c:	18880014 	ori	r2,r3,8192
81134470:	28801915 	stw	r2,100(r5)
81134474:	280d883a 	mov	r6,r5
81134478:	8009883a 	mov	r4,r16
8113447c:	880b883a 	mov	r5,r17
81134480:	dfc00317 	ldw	ra,12(sp)
81134484:	dc400217 	ldw	r17,8(sp)
81134488:	dc000117 	ldw	r16,4(sp)
8113448c:	dec00404 	addi	sp,sp,16
81134490:	11342901 	jmpi	81134290 <__fputwc>
81134494:	8009883a 	mov	r4,r16
81134498:	d9400015 	stw	r5,0(sp)
8113449c:	112c7280 	call	8112c728 <__sinit>
811344a0:	d9400017 	ldw	r5,0(sp)
811344a4:	003feb06 	br	81134454 <__reset+0xfb114454>

811344a8 <rshift>:
811344a8:	2807d17a 	srai	r3,r5,5
811344ac:	20800417 	ldw	r2,16(r4)
811344b0:	22000504 	addi	r8,r4,20
811344b4:	1880250e 	bge	r3,r2,8113454c <rshift+0xa4>
811344b8:	1085883a 	add	r2,r2,r2
811344bc:	18c7883a 	add	r3,r3,r3
811344c0:	1085883a 	add	r2,r2,r2
811344c4:	18c7883a 	add	r3,r3,r3
811344c8:	294007cc 	andi	r5,r5,31
811344cc:	4085883a 	add	r2,r8,r2
811344d0:	40c7883a 	add	r3,r8,r3
811344d4:	28002026 	beq	r5,zero,81134558 <rshift+0xb0>
811344d8:	19800017 	ldw	r6,0(r3)
811344dc:	02c00804 	movi	r11,32
811344e0:	19c00104 	addi	r7,r3,4
811344e4:	5957c83a 	sub	r11,r11,r5
811344e8:	314cd83a 	srl	r6,r6,r5
811344ec:	38802c2e 	bgeu	r7,r2,811345a0 <rshift+0xf8>
811344f0:	4015883a 	mov	r10,r8
811344f4:	3a400017 	ldw	r9,0(r7)
811344f8:	52800104 	addi	r10,r10,4
811344fc:	39c00104 	addi	r7,r7,4
81134500:	4ad2983a 	sll	r9,r9,r11
81134504:	498cb03a 	or	r6,r9,r6
81134508:	51bfff15 	stw	r6,-4(r10)
8113450c:	39bfff17 	ldw	r6,-4(r7)
81134510:	314cd83a 	srl	r6,r6,r5
81134514:	38bff736 	bltu	r7,r2,811344f4 <__reset+0xfb1144f4>
81134518:	10c7c83a 	sub	r3,r2,r3
8113451c:	18fffec4 	addi	r3,r3,-5
81134520:	1806d0ba 	srli	r3,r3,2
81134524:	18c00044 	addi	r3,r3,1
81134528:	18c7883a 	add	r3,r3,r3
8113452c:	18c7883a 	add	r3,r3,r3
81134530:	40c7883a 	add	r3,r8,r3
81134534:	19800015 	stw	r6,0(r3)
81134538:	30000126 	beq	r6,zero,81134540 <rshift+0x98>
8113453c:	18c00104 	addi	r3,r3,4
81134540:	1a05c83a 	sub	r2,r3,r8
81134544:	1005d0ba 	srai	r2,r2,2
81134548:	00001206 	br	81134594 <rshift+0xec>
8113454c:	20000415 	stw	zero,16(r4)
81134550:	20000515 	stw	zero,20(r4)
81134554:	f800283a 	ret
81134558:	18bffc2e 	bgeu	r3,r2,8113454c <__reset+0xfb11454c>
8113455c:	180d883a 	mov	r6,r3
81134560:	400b883a 	mov	r5,r8
81134564:	31c00017 	ldw	r7,0(r6)
81134568:	29400104 	addi	r5,r5,4
8113456c:	31800104 	addi	r6,r6,4
81134570:	29ffff15 	stw	r7,-4(r5)
81134574:	30bffb36 	bltu	r6,r2,81134564 <__reset+0xfb114564>
81134578:	00c6303a 	nor	r3,zero,r3
8113457c:	1885883a 	add	r2,r3,r2
81134580:	1004d0ba 	srli	r2,r2,2
81134584:	10800044 	addi	r2,r2,1
81134588:	1085883a 	add	r2,r2,r2
8113458c:	1085883a 	add	r2,r2,r2
81134590:	1005d0ba 	srai	r2,r2,2
81134594:	20800415 	stw	r2,16(r4)
81134598:	103fed26 	beq	r2,zero,81134550 <__reset+0xfb114550>
8113459c:	f800283a 	ret
811345a0:	4007883a 	mov	r3,r8
811345a4:	003fe306 	br	81134534 <__reset+0xfb114534>

811345a8 <__gethex>:
811345a8:	deffeb04 	addi	sp,sp,-84
811345ac:	de00012e 	bgeu	sp,et,811345b4 <__gethex+0xc>
811345b0:	003b68fa 	trap	3
811345b4:	dfc01415 	stw	ra,80(sp)
811345b8:	dd801115 	stw	r22,68(sp)
811345bc:	dcc00e15 	stw	r19,56(sp)
811345c0:	dc800d15 	stw	r18,52(sp)
811345c4:	2827883a 	mov	r19,r5
811345c8:	d9000115 	stw	r4,4(sp)
811345cc:	d9800015 	stw	r6,0(sp)
811345d0:	d9c00415 	stw	r7,16(sp)
811345d4:	df001315 	stw	fp,76(sp)
811345d8:	ddc01215 	stw	r23,72(sp)
811345dc:	dd401015 	stw	r21,64(sp)
811345e0:	dd000f15 	stw	r20,60(sp)
811345e4:	dc400c15 	stw	r17,48(sp)
811345e8:	dc000b15 	stw	r16,44(sp)
811345ec:	112d6740 	call	8112d674 <_localeconv_r>
811345f0:	14800017 	ldw	r18,0(r2)
811345f4:	9009883a 	mov	r4,r18
811345f8:	11244540 	call	81124454 <strlen>
811345fc:	98c00017 	ldw	r3,0(r19)
81134600:	102d883a 	mov	r22,r2
81134604:	9085883a 	add	r2,r18,r2
81134608:	10bfffc3 	ldbu	r2,-1(r2)
8113460c:	19000083 	ldbu	r4,2(r3)
81134610:	d8800305 	stb	r2,12(sp)
81134614:	00800c04 	movi	r2,48
81134618:	2081521e 	bne	r4,r2,81134b64 <__gethex+0x5bc>
8113461c:	017fff84 	movi	r5,-2
81134620:	188000c4 	addi	r2,r3,3
81134624:	28cbc83a 	sub	r5,r5,r3
81134628:	200d883a 	mov	r6,r4
8113462c:	28a3883a 	add	r17,r5,r2
81134630:	102b883a 	mov	r21,r2
81134634:	10800044 	addi	r2,r2,1
81134638:	113fffc3 	ldbu	r4,-1(r2)
8113463c:	21bffb26 	beq	r4,r6,8113462c <__reset+0xfb11462c>
81134640:	05204574 	movhi	r20,33045
81134644:	a507bc04 	addi	r20,r20,7920
81134648:	a109883a 	add	r4,r20,r4
8113464c:	20800003 	ldbu	r2,0(r4)
81134650:	10008826 	beq	r2,zero,81134874 <__gethex+0x2cc>
81134654:	a8800003 	ldbu	r2,0(r21)
81134658:	0015883a 	mov	r10,zero
8113465c:	002f883a 	mov	r23,zero
81134660:	a085883a 	add	r2,r20,r2
81134664:	10800003 	ldbu	r2,0(r2)
81134668:	a821883a 	mov	r16,r21
8113466c:	10000526 	beq	r2,zero,81134684 <__gethex+0xdc>
81134670:	84000044 	addi	r16,r16,1
81134674:	80800003 	ldbu	r2,0(r16)
81134678:	a085883a 	add	r2,r20,r2
8113467c:	10800003 	ldbu	r2,0(r2)
81134680:	103ffb1e 	bne	r2,zero,81134670 <__reset+0xfb114670>
81134684:	b00d883a 	mov	r6,r22
81134688:	900b883a 	mov	r5,r18
8113468c:	8009883a 	mov	r4,r16
81134690:	da800a15 	stw	r10,40(sp)
81134694:	11350440 	call	81135044 <strncmp>
81134698:	da800a17 	ldw	r10,40(sp)
8113469c:	1000031e 	bne	r2,zero,811346ac <__gethex+0x104>
811346a0:	b8015226 	beq	r23,zero,81134bec <__gethex+0x644>
811346a4:	80800003 	ldbu	r2,0(r16)
811346a8:	00000206 	br	811346b4 <__gethex+0x10c>
811346ac:	80800003 	ldbu	r2,0(r16)
811346b0:	b8011f26 	beq	r23,zero,81134b30 <__gethex+0x588>
811346b4:	85efc83a 	sub	r23,r16,r23
811346b8:	bdef883a 	add	r23,r23,r23
811346bc:	bdef883a 	add	r23,r23,r23
811346c0:	05efc83a 	sub	r23,zero,r23
811346c4:	10803fcc 	andi	r2,r2,255
811346c8:	01001404 	movi	r4,80
811346cc:	11008626 	beq	r2,r4,811348e8 <__gethex+0x340>
811346d0:	01001c04 	movi	r4,112
811346d4:	11008426 	beq	r2,r4,811348e8 <__gethex+0x340>
811346d8:	8039883a 	mov	fp,r16
811346dc:	9c000015 	stw	r16,0(r19)
811346e0:	5000711e 	bne	r10,zero,811348a8 <__gethex+0x300>
811346e4:	e545c83a 	sub	r2,fp,r21
811346e8:	10bfffc4 	addi	r2,r2,-1
811346ec:	010001c4 	movi	r4,7
811346f0:	000b883a 	mov	r5,zero
811346f4:	2080030e 	bge	r4,r2,81134704 <__gethex+0x15c>
811346f8:	1005d07a 	srai	r2,r2,1
811346fc:	29400044 	addi	r5,r5,1
81134700:	20bffd16 	blt	r4,r2,811346f8 <__reset+0xfb1146f8>
81134704:	d9000117 	ldw	r4,4(sp)
81134708:	112db900 	call	8112db90 <_Balloc>
8113470c:	10c00504 	addi	r3,r2,20
81134710:	d8c00215 	stw	r3,8(sp)
81134714:	1021883a 	mov	r16,r2
81134718:	af01732e 	bgeu	r21,fp,81134ce8 <__gethex+0x740>
8113471c:	dc400303 	ldbu	r17,12(sp)
81134720:	03400044 	movi	r13,1
81134724:	1815883a 	mov	r10,r3
81134728:	0013883a 	mov	r9,zero
8113472c:	0027883a 	mov	r19,zero
81134730:	6d9bc83a 	sub	r13,r13,r22
81134734:	02c00804 	movi	r11,32
81134738:	e0bfffc3 	ldbu	r2,-1(fp)
8113473c:	e3bfffc4 	addi	r14,fp,-1
81134740:	88803026 	beq	r17,r2,81134804 <__gethex+0x25c>
81134744:	9ac04526 	beq	r19,r11,8113485c <__gethex+0x2b4>
81134748:	980b883a 	mov	r5,r19
8113474c:	9cc00104 	addi	r19,r19,4
81134750:	e13fffc3 	ldbu	r4,-1(fp)
81134754:	7039883a 	mov	fp,r14
81134758:	a109883a 	add	r4,r20,r4
8113475c:	20800003 	ldbu	r2,0(r4)
81134760:	108003cc 	andi	r2,r2,15
81134764:	1144983a 	sll	r2,r2,r5
81134768:	4892b03a 	or	r9,r9,r2
8113476c:	af3ff236 	bltu	r21,fp,81134738 <__reset+0xfb114738>
81134770:	d8c00217 	ldw	r3,8(sp)
81134774:	50800104 	addi	r2,r10,4
81134778:	52400015 	stw	r9,0(r10)
8113477c:	10c5c83a 	sub	r2,r2,r3
81134780:	1005d0ba 	srai	r2,r2,2
81134784:	4809883a 	mov	r4,r9
81134788:	80800415 	stw	r2,16(r16)
8113478c:	1022917a 	slli	r17,r2,5
81134790:	112de9c0 	call	8112de9c <__hi0bits>
81134794:	d8c00017 	ldw	r3,0(sp)
81134798:	8885c83a 	sub	r2,r17,r2
8113479c:	1c800017 	ldw	r18,0(r3)
811347a0:	9080c716 	blt	r18,r2,81134ac0 <__gethex+0x518>
811347a4:	1480e416 	blt	r2,r18,81134b38 <__gethex+0x590>
811347a8:	0027883a 	mov	r19,zero
811347ac:	d8c00017 	ldw	r3,0(sp)
811347b0:	18800217 	ldw	r2,8(r3)
811347b4:	15c08d16 	blt	r2,r23,811349ec <__gethex+0x444>
811347b8:	d8c00017 	ldw	r3,0(sp)
811347bc:	18800117 	ldw	r2,4(r3)
811347c0:	b880aa0e 	bge	r23,r2,81134a6c <__gethex+0x4c4>
811347c4:	15efc83a 	sub	r23,r2,r23
811347c8:	bc80ed16 	blt	r23,r18,81134b80 <__gethex+0x5d8>
811347cc:	18c00317 	ldw	r3,12(r3)
811347d0:	01000084 	movi	r4,2
811347d4:	19014926 	beq	r3,r4,81134cfc <__gethex+0x754>
811347d8:	010000c4 	movi	r4,3
811347dc:	19012e26 	beq	r3,r4,81134c98 <__gethex+0x6f0>
811347e0:	01000044 	movi	r4,1
811347e4:	19014826 	beq	r3,r4,81134d08 <__gethex+0x760>
811347e8:	d9000117 	ldw	r4,4(sp)
811347ec:	800b883a 	mov	r5,r16
811347f0:	112dc400 	call	8112dc40 <_Bfree>
811347f4:	d8801517 	ldw	r2,84(sp)
811347f8:	10000015 	stw	zero,0(r2)
811347fc:	00801404 	movi	r2,80
81134800:	00002b06 	br	811348b0 <__gethex+0x308>
81134804:	735f883a 	add	r15,r14,r13
81134808:	7d7fce36 	bltu	r15,r21,81134744 <__reset+0xfb114744>
8113480c:	7809883a 	mov	r4,r15
81134810:	b00d883a 	mov	r6,r22
81134814:	900b883a 	mov	r5,r18
81134818:	da400515 	stw	r9,20(sp)
8113481c:	da800a15 	stw	r10,40(sp)
81134820:	dac00915 	stw	r11,36(sp)
81134824:	db400815 	stw	r13,32(sp)
81134828:	db800615 	stw	r14,24(sp)
8113482c:	dbc00715 	stw	r15,28(sp)
81134830:	11350440 	call	81135044 <strncmp>
81134834:	da400517 	ldw	r9,20(sp)
81134838:	da800a17 	ldw	r10,40(sp)
8113483c:	dac00917 	ldw	r11,36(sp)
81134840:	db400817 	ldw	r13,32(sp)
81134844:	db800617 	ldw	r14,24(sp)
81134848:	dbc00717 	ldw	r15,28(sp)
8113484c:	103fbd1e 	bne	r2,zero,81134744 <__reset+0xfb114744>
81134850:	7839883a 	mov	fp,r15
81134854:	af3fb836 	bltu	r21,fp,81134738 <__reset+0xfb114738>
81134858:	003fc506 	br	81134770 <__reset+0xfb114770>
8113485c:	04c00104 	movi	r19,4
81134860:	52400015 	stw	r9,0(r10)
81134864:	000b883a 	mov	r5,zero
81134868:	54d5883a 	add	r10,r10,r19
8113486c:	0013883a 	mov	r9,zero
81134870:	003fb706 	br	81134750 <__reset+0xfb114750>
81134874:	b00d883a 	mov	r6,r22
81134878:	900b883a 	mov	r5,r18
8113487c:	a809883a 	mov	r4,r21
81134880:	11350440 	call	81135044 <strncmp>
81134884:	10006426 	beq	r2,zero,81134a18 <__gethex+0x470>
81134888:	a8800003 	ldbu	r2,0(r21)
8113488c:	a821883a 	mov	r16,r21
81134890:	10803fcc 	andi	r2,r2,255
81134894:	01001404 	movi	r4,80
81134898:	11001126 	beq	r2,r4,811348e0 <__gethex+0x338>
8113489c:	01001c04 	movi	r4,112
811348a0:	11000f26 	beq	r2,r4,811348e0 <__gethex+0x338>
811348a4:	9c000015 	stw	r16,0(r19)
811348a8:	8800831e 	bne	r17,zero,81134ab8 <__gethex+0x510>
811348ac:	00800184 	movi	r2,6
811348b0:	dfc01417 	ldw	ra,80(sp)
811348b4:	df001317 	ldw	fp,76(sp)
811348b8:	ddc01217 	ldw	r23,72(sp)
811348bc:	dd801117 	ldw	r22,68(sp)
811348c0:	dd401017 	ldw	r21,64(sp)
811348c4:	dd000f17 	ldw	r20,60(sp)
811348c8:	dcc00e17 	ldw	r19,56(sp)
811348cc:	dc800d17 	ldw	r18,52(sp)
811348d0:	dc400c17 	ldw	r17,48(sp)
811348d4:	dc000b17 	ldw	r16,44(sp)
811348d8:	dec01504 	addi	sp,sp,84
811348dc:	f800283a 	ret
811348e0:	002f883a 	mov	r23,zero
811348e4:	02800044 	movi	r10,1
811348e8:	80800043 	ldbu	r2,1(r16)
811348ec:	01400ac4 	movi	r5,43
811348f0:	11003fcc 	andi	r4,r2,255
811348f4:	21406e26 	beq	r4,r5,81134ab0 <__gethex+0x508>
811348f8:	01400b44 	movi	r5,45
811348fc:	21404226 	beq	r4,r5,81134a08 <__gethex+0x460>
81134900:	81400044 	addi	r5,r16,1
81134904:	000d883a 	mov	r6,zero
81134908:	10803fcc 	andi	r2,r2,255
8113490c:	a085883a 	add	r2,r20,r2
81134910:	11000003 	ldbu	r4,0(r2)
81134914:	03000604 	movi	r12,24
81134918:	20bfffc4 	addi	r2,r4,-1
8113491c:	10803fcc 	andi	r2,r2,255
81134920:	60bf6d36 	bltu	r12,r2,811346d8 <__reset+0xfb1146d8>
81134924:	2ac00043 	ldbu	r11,1(r5)
81134928:	20803fcc 	andi	r2,r4,255
8113492c:	01204574 	movhi	r4,33045
81134930:	2107bc04 	addi	r4,r4,7920
81134934:	22c9883a 	add	r4,r4,r11
81134938:	23400003 	ldbu	r13,0(r4)
8113493c:	10bffc04 	addi	r2,r2,-16
81134940:	29400044 	addi	r5,r5,1
81134944:	693fffc4 	addi	r4,r13,-1
81134948:	21003fcc 	andi	r4,r4,255
8113494c:	6b403fcc 	andi	r13,r13,255
81134950:	61000b36 	bltu	r12,r4,81134980 <__gethex+0x3d8>
81134954:	29400044 	addi	r5,r5,1
81134958:	29000003 	ldbu	r4,0(r5)
8113495c:	108002a4 	muli	r2,r2,10
81134960:	a109883a 	add	r4,r20,r4
81134964:	22c00003 	ldbu	r11,0(r4)
81134968:	1345883a 	add	r2,r2,r13
8113496c:	10bffc04 	addi	r2,r2,-16
81134970:	593fffc4 	addi	r4,r11,-1
81134974:	21003fcc 	andi	r4,r4,255
81134978:	5b403fcc 	andi	r13,r11,255
8113497c:	613ff52e 	bgeu	r12,r4,81134954 <__reset+0xfb114954>
81134980:	30000126 	beq	r6,zero,81134988 <__gethex+0x3e0>
81134984:	0085c83a 	sub	r2,zero,r2
81134988:	8039883a 	mov	fp,r16
8113498c:	b8af883a 	add	r23,r23,r2
81134990:	2821883a 	mov	r16,r5
81134994:	003f5106 	br	811346dc <__reset+0xfb1146dc>
81134998:	80800217 	ldw	r2,8(r16)
8113499c:	e080f00e 	bge	fp,r2,81134d60 <__gethex+0x7b8>
811349a0:	e007883a 	mov	r3,fp
811349a4:	18800144 	addi	r2,r3,5
811349a8:	1085883a 	add	r2,r2,r2
811349ac:	18c00044 	addi	r3,r3,1
811349b0:	1085883a 	add	r2,r2,r2
811349b4:	8085883a 	add	r2,r16,r2
811349b8:	80c00415 	stw	r3,16(r16)
811349bc:	01000044 	movi	r4,1
811349c0:	11000015 	stw	r4,0(r2)
811349c4:	00800084 	movi	r2,2
811349c8:	8880d826 	beq	r17,r2,81134d2c <__gethex+0x784>
811349cc:	e0c0ac0e 	bge	fp,r3,81134c80 <__gethex+0x6d8>
811349d0:	01400044 	movi	r5,1
811349d4:	8009883a 	mov	r4,r16
811349d8:	11344a80 	call	811344a8 <rshift>
811349dc:	d8c00017 	ldw	r3,0(sp)
811349e0:	bdc00044 	addi	r23,r23,1
811349e4:	18800217 	ldw	r2,8(r3)
811349e8:	15c0a70e 	bge	r2,r23,81134c88 <__gethex+0x6e0>
811349ec:	d9000117 	ldw	r4,4(sp)
811349f0:	800b883a 	mov	r5,r16
811349f4:	112dc400 	call	8112dc40 <_Bfree>
811349f8:	d9001517 	ldw	r4,84(sp)
811349fc:	008028c4 	movi	r2,163
81134a00:	20000015 	stw	zero,0(r4)
81134a04:	003faa06 	br	811348b0 <__reset+0xfb1148b0>
81134a08:	01800044 	movi	r6,1
81134a0c:	80800083 	ldbu	r2,2(r16)
81134a10:	81400084 	addi	r5,r16,2
81134a14:	003fbc06 	br	81134908 <__reset+0xfb114908>
81134a18:	ada1883a 	add	r16,r21,r22
81134a1c:	81000003 	ldbu	r4,0(r16)
81134a20:	21403fcc 	andi	r5,r4,255
81134a24:	a145883a 	add	r2,r20,r5
81134a28:	10800003 	ldbu	r2,0(r2)
81134a2c:	11803fcc 	andi	r6,r2,255
81134a30:	30004f26 	beq	r6,zero,81134b70 <__gethex+0x5c8>
81134a34:	00c00c04 	movi	r3,48
81134a38:	802b883a 	mov	r21,r16
81134a3c:	28c0061e 	bne	r5,r3,81134a58 <__gethex+0x4b0>
81134a40:	2809883a 	mov	r4,r5
81134a44:	ad400044 	addi	r21,r21,1
81134a48:	a8800003 	ldbu	r2,0(r21)
81134a4c:	113ffd26 	beq	r2,r4,81134a44 <__reset+0xfb114a44>
81134a50:	a085883a 	add	r2,r20,r2
81134a54:	10800003 	ldbu	r2,0(r2)
81134a58:	10803fcc 	andi	r2,r2,255
81134a5c:	1015003a 	cmpeq	r10,r2,zero
81134a60:	802f883a 	mov	r23,r16
81134a64:	04400044 	movi	r17,1
81134a68:	003eff06 	br	81134668 <__reset+0xfb114668>
81134a6c:	04400044 	movi	r17,1
81134a70:	98000926 	beq	r19,zero,81134a98 <__gethex+0x4f0>
81134a74:	d8c00017 	ldw	r3,0(sp)
81134a78:	18800317 	ldw	r2,12(r3)
81134a7c:	00c00084 	movi	r3,2
81134a80:	10c06826 	beq	r2,r3,81134c24 <__gethex+0x67c>
81134a84:	00c000c4 	movi	r3,3
81134a88:	10c06a26 	beq	r2,r3,81134c34 <__gethex+0x68c>
81134a8c:	00c00044 	movi	r3,1
81134a90:	10c08d26 	beq	r2,r3,81134cc8 <__gethex+0x720>
81134a94:	8c400414 	ori	r17,r17,16
81134a98:	d9001517 	ldw	r4,84(sp)
81134a9c:	d8c00417 	ldw	r3,16(sp)
81134aa0:	8805883a 	mov	r2,r17
81134aa4:	24000015 	stw	r16,0(r4)
81134aa8:	1dc00015 	stw	r23,0(r3)
81134aac:	003f8006 	br	811348b0 <__reset+0xfb1148b0>
81134ab0:	000d883a 	mov	r6,zero
81134ab4:	003fd506 	br	81134a0c <__reset+0xfb114a0c>
81134ab8:	0005883a 	mov	r2,zero
81134abc:	003f7c06 	br	811348b0 <__reset+0xfb1148b0>
81134ac0:	14a3c83a 	sub	r17,r2,r18
81134ac4:	880b883a 	mov	r5,r17
81134ac8:	8009883a 	mov	r4,r16
81134acc:	112eb600 	call	8112eb60 <__any_on>
81134ad0:	10002926 	beq	r2,zero,81134b78 <__gethex+0x5d0>
81134ad4:	897fffc4 	addi	r5,r17,-1
81134ad8:	2807d17a 	srai	r3,r5,5
81134adc:	d8800217 	ldw	r2,8(sp)
81134ae0:	290007cc 	andi	r4,r5,31
81134ae4:	18c7883a 	add	r3,r3,r3
81134ae8:	18c7883a 	add	r3,r3,r3
81134aec:	04c00044 	movi	r19,1
81134af0:	10c7883a 	add	r3,r2,r3
81134af4:	9908983a 	sll	r4,r19,r4
81134af8:	18c00017 	ldw	r3,0(r3)
81134afc:	20c6703a 	and	r3,r4,r3
81134b00:	18000626 	beq	r3,zero,81134b1c <__gethex+0x574>
81134b04:	99407b0e 	bge	r19,r5,81134cf4 <__gethex+0x74c>
81134b08:	897fff84 	addi	r5,r17,-2
81134b0c:	8009883a 	mov	r4,r16
81134b10:	112eb600 	call	8112eb60 <__any_on>
81134b14:	10007726 	beq	r2,zero,81134cf4 <__gethex+0x74c>
81134b18:	04c000c4 	movi	r19,3
81134b1c:	880b883a 	mov	r5,r17
81134b20:	8009883a 	mov	r4,r16
81134b24:	11344a80 	call	811344a8 <rshift>
81134b28:	bc6f883a 	add	r23,r23,r17
81134b2c:	003f1f06 	br	811347ac <__reset+0xfb1147ac>
81134b30:	002f883a 	mov	r23,zero
81134b34:	003ee306 	br	811346c4 <__reset+0xfb1146c4>
81134b38:	d9000117 	ldw	r4,4(sp)
81134b3c:	90a3c83a 	sub	r17,r18,r2
81134b40:	800b883a 	mov	r5,r16
81134b44:	880d883a 	mov	r6,r17
81134b48:	112e3400 	call	8112e340 <__lshift>
81134b4c:	10c00504 	addi	r3,r2,20
81134b50:	1021883a 	mov	r16,r2
81134b54:	bc6fc83a 	sub	r23,r23,r17
81134b58:	d8c00215 	stw	r3,8(sp)
81134b5c:	0027883a 	mov	r19,zero
81134b60:	003f1206 	br	811347ac <__reset+0xfb1147ac>
81134b64:	1d400084 	addi	r21,r3,2
81134b68:	0023883a 	mov	r17,zero
81134b6c:	003eb406 	br	81134640 <__reset+0xfb114640>
81134b70:	2005883a 	mov	r2,r4
81134b74:	003f4606 	br	81134890 <__reset+0xfb114890>
81134b78:	0027883a 	mov	r19,zero
81134b7c:	003fe706 	br	81134b1c <__reset+0xfb114b1c>
81134b80:	bc7fffc4 	addi	r17,r23,-1
81134b84:	9800421e 	bne	r19,zero,81134c90 <__gethex+0x6e8>
81134b88:	88000426 	beq	r17,zero,81134b9c <__gethex+0x5f4>
81134b8c:	880b883a 	mov	r5,r17
81134b90:	8009883a 	mov	r4,r16
81134b94:	112eb600 	call	8112eb60 <__any_on>
81134b98:	1027883a 	mov	r19,r2
81134b9c:	8805d17a 	srai	r2,r17,5
81134ba0:	d8c00217 	ldw	r3,8(sp)
81134ba4:	8c4007cc 	andi	r17,r17,31
81134ba8:	1085883a 	add	r2,r2,r2
81134bac:	1085883a 	add	r2,r2,r2
81134bb0:	1885883a 	add	r2,r3,r2
81134bb4:	00c00044 	movi	r3,1
81134bb8:	1c62983a 	sll	r17,r3,r17
81134bbc:	10800017 	ldw	r2,0(r2)
81134bc0:	8884703a 	and	r2,r17,r2
81134bc4:	10000126 	beq	r2,zero,81134bcc <__gethex+0x624>
81134bc8:	9cc00094 	ori	r19,r19,2
81134bcc:	b80b883a 	mov	r5,r23
81134bd0:	8009883a 	mov	r4,r16
81134bd4:	11344a80 	call	811344a8 <rshift>
81134bd8:	d8c00017 	ldw	r3,0(sp)
81134bdc:	95e5c83a 	sub	r18,r18,r23
81134be0:	04400084 	movi	r17,2
81134be4:	1dc00117 	ldw	r23,4(r3)
81134be8:	003fa106 	br	81134a70 <__reset+0xfb114a70>
81134bec:	85af883a 	add	r23,r16,r22
81134bf0:	b8800003 	ldbu	r2,0(r23)
81134bf4:	b821883a 	mov	r16,r23
81134bf8:	11003fcc 	andi	r4,r2,255
81134bfc:	a109883a 	add	r4,r20,r4
81134c00:	21000003 	ldbu	r4,0(r4)
81134c04:	203eaa26 	beq	r4,zero,811346b0 <__reset+0xfb1146b0>
81134c08:	84000044 	addi	r16,r16,1
81134c0c:	80800003 	ldbu	r2,0(r16)
81134c10:	11003fcc 	andi	r4,r2,255
81134c14:	a109883a 	add	r4,r20,r4
81134c18:	21000003 	ldbu	r4,0(r4)
81134c1c:	203ffa1e 	bne	r4,zero,81134c08 <__reset+0xfb114c08>
81134c20:	003ea306 	br	811346b0 <__reset+0xfb1146b0>
81134c24:	d9001617 	ldw	r4,88(sp)
81134c28:	00800044 	movi	r2,1
81134c2c:	1109c83a 	sub	r4,r2,r4
81134c30:	d9001615 	stw	r4,88(sp)
81134c34:	d8801617 	ldw	r2,88(sp)
81134c38:	103f9626 	beq	r2,zero,81134a94 <__reset+0xfb114a94>
81134c3c:	87000417 	ldw	fp,16(r16)
81134c40:	d9800217 	ldw	r6,8(sp)
81134c44:	013fffc4 	movi	r4,-1
81134c48:	e727883a 	add	r19,fp,fp
81134c4c:	9ce7883a 	add	r19,r19,r19
81134c50:	3005883a 	mov	r2,r6
81134c54:	34cb883a 	add	r5,r6,r19
81134c58:	00000306 	br	81134c68 <__gethex+0x6c0>
81134c5c:	10000015 	stw	zero,0(r2)
81134c60:	10800104 	addi	r2,r2,4
81134c64:	117f4c2e 	bgeu	r2,r5,81134998 <__reset+0xfb114998>
81134c68:	10c00017 	ldw	r3,0(r2)
81134c6c:	193ffb26 	beq	r3,r4,81134c5c <__reset+0xfb114c5c>
81134c70:	18c00044 	addi	r3,r3,1
81134c74:	10c00015 	stw	r3,0(r2)
81134c78:	00800084 	movi	r2,2
81134c7c:	88802b26 	beq	r17,r2,81134d2c <__gethex+0x784>
81134c80:	948007cc 	andi	r18,r18,31
81134c84:	90002f1e 	bne	r18,zero,81134d44 <__gethex+0x79c>
81134c88:	04400844 	movi	r17,33
81134c8c:	003f8206 	br	81134a98 <__reset+0xfb114a98>
81134c90:	04c00044 	movi	r19,1
81134c94:	003fc106 	br	81134b9c <__reset+0xfb114b9c>
81134c98:	d8c01617 	ldw	r3,88(sp)
81134c9c:	183ed226 	beq	r3,zero,811347e8 <__reset+0xfb1147e8>
81134ca0:	d8c00417 	ldw	r3,16(sp)
81134ca4:	d9001517 	ldw	r4,84(sp)
81134ca8:	18800015 	stw	r2,0(r3)
81134cac:	d8c00217 	ldw	r3,8(sp)
81134cb0:	00800044 	movi	r2,1
81134cb4:	80800415 	stw	r2,16(r16)
81134cb8:	18800015 	stw	r2,0(r3)
81134cbc:	24000015 	stw	r16,0(r4)
81134cc0:	00801884 	movi	r2,98
81134cc4:	003efa06 	br	811348b0 <__reset+0xfb1148b0>
81134cc8:	9880008c 	andi	r2,r19,2
81134ccc:	103f7126 	beq	r2,zero,81134a94 <__reset+0xfb114a94>
81134cd0:	d8c00217 	ldw	r3,8(sp)
81134cd4:	18800017 	ldw	r2,0(r3)
81134cd8:	9884b03a 	or	r2,r19,r2
81134cdc:	1080004c 	andi	r2,r2,1
81134ce0:	103fd61e 	bne	r2,zero,81134c3c <__reset+0xfb114c3c>
81134ce4:	003f6b06 	br	81134a94 <__reset+0xfb114a94>
81134ce8:	da800217 	ldw	r10,8(sp)
81134cec:	0013883a 	mov	r9,zero
81134cf0:	003e9f06 	br	81134770 <__reset+0xfb114770>
81134cf4:	04c00084 	movi	r19,2
81134cf8:	003f8806 	br	81134b1c <__reset+0xfb114b1c>
81134cfc:	d9001617 	ldw	r4,88(sp)
81134d00:	203fe726 	beq	r4,zero,81134ca0 <__reset+0xfb114ca0>
81134d04:	003eb806 	br	811347e8 <__reset+0xfb1147e8>
81134d08:	95feb71e 	bne	r18,r23,811347e8 <__reset+0xfb1147e8>
81134d0c:	1cbfe40e 	bge	r3,r18,81134ca0 <__reset+0xfb114ca0>
81134d10:	917fffc4 	addi	r5,r18,-1
81134d14:	8009883a 	mov	r4,r16
81134d18:	112eb600 	call	8112eb60 <__any_on>
81134d1c:	103eb226 	beq	r2,zero,811347e8 <__reset+0xfb1147e8>
81134d20:	d8c00017 	ldw	r3,0(sp)
81134d24:	18800117 	ldw	r2,4(r3)
81134d28:	003fdd06 	br	81134ca0 <__reset+0xfb114ca0>
81134d2c:	d8c00017 	ldw	r3,0(sp)
81134d30:	18800017 	ldw	r2,0(r3)
81134d34:	10bfffc4 	addi	r2,r2,-1
81134d38:	90801c26 	beq	r18,r2,81134dac <__gethex+0x804>
81134d3c:	04400884 	movi	r17,34
81134d40:	003f5506 	br	81134a98 <__reset+0xfb114a98>
81134d44:	34c5883a 	add	r2,r6,r19
81134d48:	113fff17 	ldw	r4,-4(r2)
81134d4c:	112de9c0 	call	8112de9c <__hi0bits>
81134d50:	00c00804 	movi	r3,32
81134d54:	1ca5c83a 	sub	r18,r3,r18
81134d58:	14bfcb0e 	bge	r2,r18,81134c88 <__reset+0xfb114c88>
81134d5c:	003f1c06 	br	811349d0 <__reset+0xfb1149d0>
81134d60:	81400117 	ldw	r5,4(r16)
81134d64:	d9000117 	ldw	r4,4(sp)
81134d68:	29400044 	addi	r5,r5,1
81134d6c:	112db900 	call	8112db90 <_Balloc>
81134d70:	81800417 	ldw	r6,16(r16)
81134d74:	81400304 	addi	r5,r16,12
81134d78:	11000304 	addi	r4,r2,12
81134d7c:	31800084 	addi	r6,r6,2
81134d80:	318d883a 	add	r6,r6,r6
81134d84:	318d883a 	add	r6,r6,r6
81134d88:	1029883a 	mov	r20,r2
81134d8c:	11239dc0 	call	811239dc <memcpy>
81134d90:	d9000117 	ldw	r4,4(sp)
81134d94:	800b883a 	mov	r5,r16
81134d98:	a021883a 	mov	r16,r20
81134d9c:	112dc400 	call	8112dc40 <_Bfree>
81134da0:	a0c00417 	ldw	r3,16(r20)
81134da4:	a1800504 	addi	r6,r20,20
81134da8:	003efe06 	br	811349a4 <__reset+0xfb1149a4>
81134dac:	9005d17a 	srai	r2,r18,5
81134db0:	944007cc 	andi	r17,r18,31
81134db4:	1085883a 	add	r2,r2,r2
81134db8:	1085883a 	add	r2,r2,r2
81134dbc:	3087883a 	add	r3,r6,r2
81134dc0:	00800044 	movi	r2,1
81134dc4:	1462983a 	sll	r17,r2,r17
81134dc8:	18800017 	ldw	r2,0(r3)
81134dcc:	8884703a 	and	r2,r17,r2
81134dd0:	1022c03a 	cmpne	r17,r2,zero
81134dd4:	00800884 	movi	r2,34
81134dd8:	1463c83a 	sub	r17,r2,r17
81134ddc:	003f2e06 	br	81134a98 <__reset+0xfb114a98>

81134de0 <__hexnan>:
81134de0:	defff904 	addi	sp,sp,-28
81134de4:	de00012e 	bgeu	sp,et,81134dec <__hexnan+0xc>
81134de8:	003b68fa 	trap	3
81134dec:	dc800215 	stw	r18,8(sp)
81134df0:	2c800017 	ldw	r18,0(r5)
81134df4:	dfc00615 	stw	ra,24(sp)
81134df8:	dd400515 	stw	r21,20(sp)
81134dfc:	901fd17a 	srai	r15,r18,5
81134e00:	dd000415 	stw	r20,16(sp)
81134e04:	dcc00315 	stw	r19,12(sp)
81134e08:	7bdf883a 	add	r15,r15,r15
81134e0c:	7bdf883a 	add	r15,r15,r15
81134e10:	dc400115 	stw	r17,4(sp)
81134e14:	dc000015 	stw	r16,0(sp)
81134e18:	948007cc 	andi	r18,r18,31
81134e1c:	33df883a 	add	r15,r6,r15
81134e20:	90000126 	beq	r18,zero,81134e28 <__hexnan+0x48>
81134e24:	7bc00104 	addi	r15,r15,4
81134e28:	22000017 	ldw	r8,0(r4)
81134e2c:	7affff04 	addi	r11,r15,-4
81134e30:	03a04574 	movhi	r14,33045
81134e34:	783fff15 	stw	zero,-4(r15)
81134e38:	581b883a 	mov	r13,r11
81134e3c:	580b883a 	mov	r5,r11
81134e40:	000f883a 	mov	r7,zero
81134e44:	003f883a 	mov	ra,zero
81134e48:	0019883a 	mov	r12,zero
81134e4c:	7387bc04 	addi	r14,r14,7920
81134e50:	04400204 	movi	r17,8
81134e54:	04000804 	movi	r16,32
81134e58:	04c001c4 	movi	r19,7
81134e5c:	42000044 	addi	r8,r8,1
81134e60:	40c00003 	ldbu	r3,0(r8)
81134e64:	18001d26 	beq	r3,zero,81134edc <__hexnan+0xfc>
81134e68:	70c5883a 	add	r2,r14,r3
81134e6c:	10800003 	ldbu	r2,0(r2)
81134e70:	12403fcc 	andi	r9,r2,255
81134e74:	4800301e 	bne	r9,zero,81134f38 <__hexnan+0x158>
81134e78:	80c04236 	bltu	r16,r3,81134f84 <__hexnan+0x1a4>
81134e7c:	fb3ff70e 	bge	ra,r12,81134e5c <__reset+0xfb114e5c>
81134e80:	2b40112e 	bgeu	r5,r13,81134ec8 <__hexnan+0xe8>
81134e84:	99c01016 	blt	r19,r7,81134ec8 <__hexnan+0xe8>
81134e88:	89e9c83a 	sub	r20,r17,r7
81134e8c:	a529883a 	add	r20,r20,r20
81134e90:	2a800017 	ldw	r10,0(r5)
81134e94:	a529883a 	add	r20,r20,r20
81134e98:	852bc83a 	sub	r21,r16,r20
81134e9c:	28c00104 	addi	r3,r5,4
81134ea0:	2805883a 	mov	r2,r5
81134ea4:	19c00017 	ldw	r7,0(r3)
81134ea8:	10800104 	addi	r2,r2,4
81134eac:	18c00104 	addi	r3,r3,4
81134eb0:	3d52983a 	sll	r9,r7,r21
81134eb4:	4a92b03a 	or	r9,r9,r10
81134eb8:	3d14d83a 	srl	r10,r7,r20
81134ebc:	127fff15 	stw	r9,-4(r2)
81134ec0:	1abfff15 	stw	r10,-4(r3)
81134ec4:	137ff736 	bltu	r2,r13,81134ea4 <__reset+0xfb114ea4>
81134ec8:	31402836 	bltu	r6,r5,81134f6c <__hexnan+0x18c>
81134ecc:	42000044 	addi	r8,r8,1
81134ed0:	40c00003 	ldbu	r3,0(r8)
81134ed4:	01c00204 	movi	r7,8
81134ed8:	183fe31e 	bne	r3,zero,81134e68 <__reset+0xfb114e68>
81134edc:	60002b26 	beq	r12,zero,81134f8c <__hexnan+0x1ac>
81134ee0:	2b40022e 	bgeu	r5,r13,81134eec <__hexnan+0x10c>
81134ee4:	008001c4 	movi	r2,7
81134ee8:	11c0430e 	bge	r2,r7,81134ff8 <__hexnan+0x218>
81134eec:	3140312e 	bgeu	r6,r5,81134fb4 <__hexnan+0x1d4>
81134ef0:	3007883a 	mov	r3,r6
81134ef4:	29000017 	ldw	r4,0(r5)
81134ef8:	18800104 	addi	r2,r3,4
81134efc:	29400104 	addi	r5,r5,4
81134f00:	19000015 	stw	r4,0(r3)
81134f04:	1007883a 	mov	r3,r2
81134f08:	597ffa2e 	bgeu	r11,r5,81134ef4 <__reset+0xfb114ef4>
81134f0c:	10000015 	stw	zero,0(r2)
81134f10:	10800104 	addi	r2,r2,4
81134f14:	58bffd2e 	bgeu	r11,r2,81134f0c <__reset+0xfb114f0c>
81134f18:	78bfff17 	ldw	r2,-4(r15)
81134f1c:	1000041e 	bne	r2,zero,81134f30 <__hexnan+0x150>
81134f20:	32c02d26 	beq	r6,r11,81134fd8 <__hexnan+0x1f8>
81134f24:	5affff04 	addi	r11,r11,-4
81134f28:	58800017 	ldw	r2,0(r11)
81134f2c:	103ffc26 	beq	r2,zero,81134f20 <__reset+0xfb114f20>
81134f30:	00800144 	movi	r2,5
81134f34:	00001606 	br	81134f90 <__hexnan+0x1b0>
81134f38:	39c00044 	addi	r7,r7,1
81134f3c:	63000044 	addi	r12,r12,1
81134f40:	89c0040e 	bge	r17,r7,81134f54 <__hexnan+0x174>
81134f44:	317fc52e 	bgeu	r6,r5,81134e5c <__reset+0xfb114e5c>
81134f48:	283fff15 	stw	zero,-4(r5)
81134f4c:	01c00044 	movi	r7,1
81134f50:	297fff04 	addi	r5,r5,-4
81134f54:	28c00017 	ldw	r3,0(r5)
81134f58:	108003cc 	andi	r2,r2,15
81134f5c:	1806913a 	slli	r3,r3,4
81134f60:	1884b03a 	or	r2,r3,r2
81134f64:	28800015 	stw	r2,0(r5)
81134f68:	003fbc06 	br	81134e5c <__reset+0xfb114e5c>
81134f6c:	2b7fff04 	addi	r13,r5,-4
81134f70:	283fff15 	stw	zero,-4(r5)
81134f74:	603f883a 	mov	ra,r12
81134f78:	680b883a 	mov	r5,r13
81134f7c:	000f883a 	mov	r7,zero
81134f80:	003fb606 	br	81134e5c <__reset+0xfb114e5c>
81134f84:	00800a44 	movi	r2,41
81134f88:	18801726 	beq	r3,r2,81134fe8 <__hexnan+0x208>
81134f8c:	00800104 	movi	r2,4
81134f90:	dfc00617 	ldw	ra,24(sp)
81134f94:	dd400517 	ldw	r21,20(sp)
81134f98:	dd000417 	ldw	r20,16(sp)
81134f9c:	dcc00317 	ldw	r19,12(sp)
81134fa0:	dc800217 	ldw	r18,8(sp)
81134fa4:	dc400117 	ldw	r17,4(sp)
81134fa8:	dc000017 	ldw	r16,0(sp)
81134fac:	dec00704 	addi	sp,sp,28
81134fb0:	f800283a 	ret
81134fb4:	903fd826 	beq	r18,zero,81134f18 <__reset+0xfb114f18>
81134fb8:	00c00804 	movi	r3,32
81134fbc:	1ca5c83a 	sub	r18,r3,r18
81134fc0:	00ffffc4 	movi	r3,-1
81134fc4:	78bfff17 	ldw	r2,-4(r15)
81134fc8:	1c86d83a 	srl	r3,r3,r18
81134fcc:	1884703a 	and	r2,r3,r2
81134fd0:	78bfff15 	stw	r2,-4(r15)
81134fd4:	003fd106 	br	81134f1c <__reset+0xfb114f1c>
81134fd8:	00800044 	movi	r2,1
81134fdc:	58800015 	stw	r2,0(r11)
81134fe0:	00800144 	movi	r2,5
81134fe4:	003fea06 	br	81134f90 <__reset+0xfb114f90>
81134fe8:	42000044 	addi	r8,r8,1
81134fec:	22000015 	stw	r8,0(r4)
81134ff0:	603fbb1e 	bne	r12,zero,81134ee0 <__reset+0xfb114ee0>
81134ff4:	003fe506 	br	81134f8c <__reset+0xfb114f8c>
81134ff8:	02400204 	movi	r9,8
81134ffc:	49d3c83a 	sub	r9,r9,r7
81135000:	4a53883a 	add	r9,r9,r9
81135004:	2a000017 	ldw	r8,0(r5)
81135008:	4a53883a 	add	r9,r9,r9
8113500c:	02800804 	movi	r10,32
81135010:	5255c83a 	sub	r10,r10,r9
81135014:	28c00104 	addi	r3,r5,4
81135018:	2805883a 	mov	r2,r5
8113501c:	19c00017 	ldw	r7,0(r3)
81135020:	10800104 	addi	r2,r2,4
81135024:	18c00104 	addi	r3,r3,4
81135028:	3a88983a 	sll	r4,r7,r10
8113502c:	2208b03a 	or	r4,r4,r8
81135030:	3a50d83a 	srl	r8,r7,r9
81135034:	113fff15 	stw	r4,-4(r2)
81135038:	1a3fff15 	stw	r8,-4(r3)
8113503c:	137ff736 	bltu	r2,r13,8113501c <__reset+0xfb11501c>
81135040:	003faa06 	br	81134eec <__reset+0xfb114eec>

81135044 <strncmp>:
81135044:	30003126 	beq	r6,zero,8113510c <strncmp+0xc8>
81135048:	2144b03a 	or	r2,r4,r5
8113504c:	108000cc 	andi	r2,r2,3
81135050:	10001e1e 	bne	r2,zero,811350cc <strncmp+0x88>
81135054:	024000c4 	movi	r9,3
81135058:	49801c2e 	bgeu	r9,r6,811350cc <strncmp+0x88>
8113505c:	20800017 	ldw	r2,0(r4)
81135060:	28c00017 	ldw	r3,0(r5)
81135064:	10c0191e 	bne	r2,r3,811350cc <strncmp+0x88>
81135068:	31bfff04 	addi	r6,r6,-4
8113506c:	30002726 	beq	r6,zero,8113510c <strncmp+0xc8>
81135070:	02ffbff4 	movhi	r11,65279
81135074:	5affbfc4 	addi	r11,r11,-257
81135078:	0086303a 	nor	r3,zero,r2
8113507c:	02a02074 	movhi	r10,32897
81135080:	12c5883a 	add	r2,r2,r11
81135084:	52a02004 	addi	r10,r10,-32640
81135088:	10c4703a 	and	r2,r2,r3
8113508c:	1284703a 	and	r2,r2,r10
81135090:	10000b26 	beq	r2,zero,811350c0 <strncmp+0x7c>
81135094:	00001d06 	br	8113510c <strncmp+0xc8>
81135098:	20c00017 	ldw	r3,0(r4)
8113509c:	29c00017 	ldw	r7,0(r5)
811350a0:	1ad1883a 	add	r8,r3,r11
811350a4:	00c4303a 	nor	r2,zero,r3
811350a8:	4084703a 	and	r2,r8,r2
811350ac:	1284703a 	and	r2,r2,r10
811350b0:	19c0061e 	bne	r3,r7,811350cc <strncmp+0x88>
811350b4:	31bfff04 	addi	r6,r6,-4
811350b8:	30001426 	beq	r6,zero,8113510c <strncmp+0xc8>
811350bc:	1000131e 	bne	r2,zero,8113510c <strncmp+0xc8>
811350c0:	21000104 	addi	r4,r4,4
811350c4:	29400104 	addi	r5,r5,4
811350c8:	49bff336 	bltu	r9,r6,81135098 <__reset+0xfb115098>
811350cc:	28800007 	ldb	r2,0(r5)
811350d0:	20c00007 	ldb	r3,0(r4)
811350d4:	31bfffc4 	addi	r6,r6,-1
811350d8:	10c0081e 	bne	r2,r3,811350fc <strncmp+0xb8>
811350dc:	30000b26 	beq	r6,zero,8113510c <strncmp+0xc8>
811350e0:	10000a26 	beq	r2,zero,8113510c <strncmp+0xc8>
811350e4:	21000044 	addi	r4,r4,1
811350e8:	29400044 	addi	r5,r5,1
811350ec:	20800007 	ldb	r2,0(r4)
811350f0:	28c00007 	ldb	r3,0(r5)
811350f4:	31bfffc4 	addi	r6,r6,-1
811350f8:	10fff826 	beq	r2,r3,811350dc <__reset+0xfb1150dc>
811350fc:	20800003 	ldbu	r2,0(r4)
81135100:	28c00003 	ldbu	r3,0(r5)
81135104:	10c5c83a 	sub	r2,r2,r3
81135108:	f800283a 	ret
8113510c:	0005883a 	mov	r2,zero
81135110:	f800283a 	ret

81135114 <_wcrtomb_r>:
81135114:	defff604 	addi	sp,sp,-40
81135118:	00a04574 	movhi	r2,33045
8113511c:	de00012e 	bgeu	sp,et,81135124 <_wcrtomb_r+0x10>
81135120:	003b68fa 	trap	3
81135124:	1090f604 	addi	r2,r2,17368
81135128:	dc800815 	stw	r18,32(sp)
8113512c:	dc400715 	stw	r17,28(sp)
81135130:	dc000615 	stw	r16,24(sp)
81135134:	dfc00915 	stw	ra,36(sp)
81135138:	2021883a 	mov	r16,r4
8113513c:	3823883a 	mov	r17,r7
81135140:	14800017 	ldw	r18,0(r2)
81135144:	28001426 	beq	r5,zero,81135198 <_wcrtomb_r+0x84>
81135148:	d9400415 	stw	r5,16(sp)
8113514c:	d9800515 	stw	r6,20(sp)
81135150:	112d6440 	call	8112d644 <__locale_charset>
81135154:	d9800517 	ldw	r6,20(sp)
81135158:	d9400417 	ldw	r5,16(sp)
8113515c:	100f883a 	mov	r7,r2
81135160:	dc400015 	stw	r17,0(sp)
81135164:	8009883a 	mov	r4,r16
81135168:	903ee83a 	callr	r18
8113516c:	00ffffc4 	movi	r3,-1
81135170:	10c0031e 	bne	r2,r3,81135180 <_wcrtomb_r+0x6c>
81135174:	88000015 	stw	zero,0(r17)
81135178:	00c02284 	movi	r3,138
8113517c:	80c00015 	stw	r3,0(r16)
81135180:	dfc00917 	ldw	ra,36(sp)
81135184:	dc800817 	ldw	r18,32(sp)
81135188:	dc400717 	ldw	r17,28(sp)
8113518c:	dc000617 	ldw	r16,24(sp)
81135190:	dec00a04 	addi	sp,sp,40
81135194:	f800283a 	ret
81135198:	112d6440 	call	8112d644 <__locale_charset>
8113519c:	100f883a 	mov	r7,r2
811351a0:	dc400015 	stw	r17,0(sp)
811351a4:	000d883a 	mov	r6,zero
811351a8:	d9400104 	addi	r5,sp,4
811351ac:	8009883a 	mov	r4,r16
811351b0:	903ee83a 	callr	r18
811351b4:	003fed06 	br	8113516c <__reset+0xfb11516c>

811351b8 <wcrtomb>:
811351b8:	defff604 	addi	sp,sp,-40
811351bc:	00a04574 	movhi	r2,33045
811351c0:	de00012e 	bgeu	sp,et,811351c8 <wcrtomb+0x10>
811351c4:	003b68fa 	trap	3
811351c8:	1090f104 	addi	r2,r2,17348
811351cc:	dc800615 	stw	r18,24(sp)
811351d0:	dc400515 	stw	r17,20(sp)
811351d4:	dfc00915 	stw	ra,36(sp)
811351d8:	dd000815 	stw	r20,32(sp)
811351dc:	dcc00715 	stw	r19,28(sp)
811351e0:	dc000415 	stw	r16,16(sp)
811351e4:	3025883a 	mov	r18,r6
811351e8:	14400017 	ldw	r17,0(r2)
811351ec:	20001926 	beq	r4,zero,81135254 <wcrtomb+0x9c>
811351f0:	00a04574 	movhi	r2,33045
811351f4:	1090f604 	addi	r2,r2,17368
811351f8:	15000017 	ldw	r20,0(r2)
811351fc:	2021883a 	mov	r16,r4
81135200:	2827883a 	mov	r19,r5
81135204:	112d6440 	call	8112d644 <__locale_charset>
81135208:	100f883a 	mov	r7,r2
8113520c:	dc800015 	stw	r18,0(sp)
81135210:	980d883a 	mov	r6,r19
81135214:	800b883a 	mov	r5,r16
81135218:	8809883a 	mov	r4,r17
8113521c:	a03ee83a 	callr	r20
81135220:	00ffffc4 	movi	r3,-1
81135224:	10c0031e 	bne	r2,r3,81135234 <wcrtomb+0x7c>
81135228:	90000015 	stw	zero,0(r18)
8113522c:	00c02284 	movi	r3,138
81135230:	88c00015 	stw	r3,0(r17)
81135234:	dfc00917 	ldw	ra,36(sp)
81135238:	dd000817 	ldw	r20,32(sp)
8113523c:	dcc00717 	ldw	r19,28(sp)
81135240:	dc800617 	ldw	r18,24(sp)
81135244:	dc400517 	ldw	r17,20(sp)
81135248:	dc000417 	ldw	r16,16(sp)
8113524c:	dec00a04 	addi	sp,sp,40
81135250:	f800283a 	ret
81135254:	00a04574 	movhi	r2,33045
81135258:	1090f604 	addi	r2,r2,17368
8113525c:	14000017 	ldw	r16,0(r2)
81135260:	112d6440 	call	8112d644 <__locale_charset>
81135264:	100f883a 	mov	r7,r2
81135268:	dc800015 	stw	r18,0(sp)
8113526c:	000d883a 	mov	r6,zero
81135270:	d9400104 	addi	r5,sp,4
81135274:	8809883a 	mov	r4,r17
81135278:	803ee83a 	callr	r16
8113527c:	003fe806 	br	81135220 <__reset+0xfb115220>

81135280 <__ascii_wctomb>:
81135280:	28000526 	beq	r5,zero,81135298 <__ascii_wctomb+0x18>
81135284:	00803fc4 	movi	r2,255
81135288:	11800536 	bltu	r2,r6,811352a0 <__ascii_wctomb+0x20>
8113528c:	29800005 	stb	r6,0(r5)
81135290:	00800044 	movi	r2,1
81135294:	f800283a 	ret
81135298:	0005883a 	mov	r2,zero
8113529c:	f800283a 	ret
811352a0:	00802284 	movi	r2,138
811352a4:	20800015 	stw	r2,0(r4)
811352a8:	00bfffc4 	movi	r2,-1
811352ac:	f800283a 	ret

811352b0 <_wctomb_r>:
811352b0:	00a04574 	movhi	r2,33045
811352b4:	defff904 	addi	sp,sp,-28
811352b8:	1090f604 	addi	r2,r2,17368
811352bc:	de00012e 	bgeu	sp,et,811352c4 <_wctomb_r+0x14>
811352c0:	003b68fa 	trap	3
811352c4:	dfc00615 	stw	ra,24(sp)
811352c8:	dc400515 	stw	r17,20(sp)
811352cc:	dc000415 	stw	r16,16(sp)
811352d0:	3823883a 	mov	r17,r7
811352d4:	14000017 	ldw	r16,0(r2)
811352d8:	d9000115 	stw	r4,4(sp)
811352dc:	d9400215 	stw	r5,8(sp)
811352e0:	d9800315 	stw	r6,12(sp)
811352e4:	112d6440 	call	8112d644 <__locale_charset>
811352e8:	d9800317 	ldw	r6,12(sp)
811352ec:	d9400217 	ldw	r5,8(sp)
811352f0:	d9000117 	ldw	r4,4(sp)
811352f4:	100f883a 	mov	r7,r2
811352f8:	dc400015 	stw	r17,0(sp)
811352fc:	803ee83a 	callr	r16
81135300:	dfc00617 	ldw	ra,24(sp)
81135304:	dc400517 	ldw	r17,20(sp)
81135308:	dc000417 	ldw	r16,16(sp)
8113530c:	dec00704 	addi	sp,sp,28
81135310:	f800283a 	ret

81135314 <__udivdi3>:
81135314:	defff504 	addi	sp,sp,-44
81135318:	de00012e 	bgeu	sp,et,81135320 <__udivdi3+0xc>
8113531c:	003b68fa 	trap	3
81135320:	dcc00415 	stw	r19,16(sp)
81135324:	dc000115 	stw	r16,4(sp)
81135328:	dfc00a15 	stw	ra,40(sp)
8113532c:	df000915 	stw	fp,36(sp)
81135330:	ddc00815 	stw	r23,32(sp)
81135334:	dd800715 	stw	r22,28(sp)
81135338:	dd400615 	stw	r21,24(sp)
8113533c:	dd000515 	stw	r20,20(sp)
81135340:	dc800315 	stw	r18,12(sp)
81135344:	dc400215 	stw	r17,8(sp)
81135348:	2027883a 	mov	r19,r4
8113534c:	2821883a 	mov	r16,r5
81135350:	3800411e 	bne	r7,zero,81135458 <__udivdi3+0x144>
81135354:	3023883a 	mov	r17,r6
81135358:	2025883a 	mov	r18,r4
8113535c:	2980522e 	bgeu	r5,r6,811354a8 <__udivdi3+0x194>
81135360:	00bfffd4 	movui	r2,65535
81135364:	282d883a 	mov	r22,r5
81135368:	1180a836 	bltu	r2,r6,8113560c <__udivdi3+0x2f8>
8113536c:	00803fc4 	movi	r2,255
81135370:	1185803a 	cmpltu	r2,r2,r6
81135374:	100490fa 	slli	r2,r2,3
81135378:	3086d83a 	srl	r3,r6,r2
8113537c:	01204574 	movhi	r4,33045
81135380:	21063604 	addi	r4,r4,6360
81135384:	20c7883a 	add	r3,r4,r3
81135388:	18c00003 	ldbu	r3,0(r3)
8113538c:	1885883a 	add	r2,r3,r2
81135390:	00c00804 	movi	r3,32
81135394:	1887c83a 	sub	r3,r3,r2
81135398:	18000526 	beq	r3,zero,811353b0 <__udivdi3+0x9c>
8113539c:	80e0983a 	sll	r16,r16,r3
811353a0:	9884d83a 	srl	r2,r19,r2
811353a4:	30e2983a 	sll	r17,r6,r3
811353a8:	98e4983a 	sll	r18,r19,r3
811353ac:	142cb03a 	or	r22,r2,r16
811353b0:	882ad43a 	srli	r21,r17,16
811353b4:	b009883a 	mov	r4,r22
811353b8:	8d3fffcc 	andi	r20,r17,65535
811353bc:	a80b883a 	mov	r5,r21
811353c0:	1135f300 	call	81135f30 <__umodsi3>
811353c4:	b009883a 	mov	r4,r22
811353c8:	a80b883a 	mov	r5,r21
811353cc:	1027883a 	mov	r19,r2
811353d0:	1135ecc0 	call	81135ecc <__udivsi3>
811353d4:	102d883a 	mov	r22,r2
811353d8:	9826943a 	slli	r19,r19,16
811353dc:	9004d43a 	srli	r2,r18,16
811353e0:	a5a1383a 	mul	r16,r20,r22
811353e4:	14c4b03a 	or	r2,r2,r19
811353e8:	1400052e 	bgeu	r2,r16,81135400 <__udivdi3+0xec>
811353ec:	1445883a 	add	r2,r2,r17
811353f0:	b0ffffc4 	addi	r3,r22,-1
811353f4:	14400136 	bltu	r2,r17,811353fc <__udivdi3+0xe8>
811353f8:	14012336 	bltu	r2,r16,81135888 <__udivdi3+0x574>
811353fc:	182d883a 	mov	r22,r3
81135400:	1421c83a 	sub	r16,r2,r16
81135404:	a80b883a 	mov	r5,r21
81135408:	8009883a 	mov	r4,r16
8113540c:	1135f300 	call	81135f30 <__umodsi3>
81135410:	1027883a 	mov	r19,r2
81135414:	a80b883a 	mov	r5,r21
81135418:	8009883a 	mov	r4,r16
8113541c:	1135ecc0 	call	81135ecc <__udivsi3>
81135420:	9826943a 	slli	r19,r19,16
81135424:	a0a9383a 	mul	r20,r20,r2
81135428:	94bfffcc 	andi	r18,r18,65535
8113542c:	94e4b03a 	or	r18,r18,r19
81135430:	9500052e 	bgeu	r18,r20,81135448 <__udivdi3+0x134>
81135434:	8ca5883a 	add	r18,r17,r18
81135438:	10ffffc4 	addi	r3,r2,-1
8113543c:	9440f136 	bltu	r18,r17,81135804 <__udivdi3+0x4f0>
81135440:	9500f02e 	bgeu	r18,r20,81135804 <__udivdi3+0x4f0>
81135444:	10bfff84 	addi	r2,r2,-2
81135448:	b00c943a 	slli	r6,r22,16
8113544c:	0007883a 	mov	r3,zero
81135450:	3084b03a 	or	r2,r6,r2
81135454:	00005906 	br	811355bc <__udivdi3+0x2a8>
81135458:	29c05636 	bltu	r5,r7,811355b4 <__udivdi3+0x2a0>
8113545c:	00bfffd4 	movui	r2,65535
81135460:	11c0622e 	bgeu	r2,r7,811355ec <__udivdi3+0x2d8>
81135464:	00804034 	movhi	r2,256
81135468:	10bfffc4 	addi	r2,r2,-1
8113546c:	11c0ee36 	bltu	r2,r7,81135828 <__udivdi3+0x514>
81135470:	00800404 	movi	r2,16
81135474:	3886d83a 	srl	r3,r7,r2
81135478:	01204574 	movhi	r4,33045
8113547c:	21063604 	addi	r4,r4,6360
81135480:	20c7883a 	add	r3,r4,r3
81135484:	18c00003 	ldbu	r3,0(r3)
81135488:	05400804 	movi	r21,32
8113548c:	1885883a 	add	r2,r3,r2
81135490:	a8abc83a 	sub	r21,r21,r2
81135494:	a800621e 	bne	r21,zero,81135620 <__udivdi3+0x30c>
81135498:	3c00e936 	bltu	r7,r16,81135840 <__udivdi3+0x52c>
8113549c:	9985403a 	cmpgeu	r2,r19,r6
811354a0:	0007883a 	mov	r3,zero
811354a4:	00004506 	br	811355bc <__udivdi3+0x2a8>
811354a8:	3000041e 	bne	r6,zero,811354bc <__udivdi3+0x1a8>
811354ac:	000b883a 	mov	r5,zero
811354b0:	01000044 	movi	r4,1
811354b4:	1135ecc0 	call	81135ecc <__udivsi3>
811354b8:	1023883a 	mov	r17,r2
811354bc:	00bfffd4 	movui	r2,65535
811354c0:	14404e2e 	bgeu	r2,r17,811355fc <__udivdi3+0x2e8>
811354c4:	00804034 	movhi	r2,256
811354c8:	10bfffc4 	addi	r2,r2,-1
811354cc:	1440d836 	bltu	r2,r17,81135830 <__udivdi3+0x51c>
811354d0:	00800404 	movi	r2,16
811354d4:	8886d83a 	srl	r3,r17,r2
811354d8:	01204574 	movhi	r4,33045
811354dc:	21063604 	addi	r4,r4,6360
811354e0:	20c7883a 	add	r3,r4,r3
811354e4:	18c00003 	ldbu	r3,0(r3)
811354e8:	1885883a 	add	r2,r3,r2
811354ec:	00c00804 	movi	r3,32
811354f0:	1887c83a 	sub	r3,r3,r2
811354f4:	18008f1e 	bne	r3,zero,81135734 <__udivdi3+0x420>
811354f8:	882ad43a 	srli	r21,r17,16
811354fc:	8461c83a 	sub	r16,r16,r17
81135500:	8d3fffcc 	andi	r20,r17,65535
81135504:	00c00044 	movi	r3,1
81135508:	8009883a 	mov	r4,r16
8113550c:	a80b883a 	mov	r5,r21
81135510:	d8c00015 	stw	r3,0(sp)
81135514:	1135f300 	call	81135f30 <__umodsi3>
81135518:	8009883a 	mov	r4,r16
8113551c:	a80b883a 	mov	r5,r21
81135520:	1027883a 	mov	r19,r2
81135524:	1135ecc0 	call	81135ecc <__udivsi3>
81135528:	9826943a 	slli	r19,r19,16
8113552c:	9008d43a 	srli	r4,r18,16
81135530:	1521383a 	mul	r16,r2,r20
81135534:	102d883a 	mov	r22,r2
81135538:	24c8b03a 	or	r4,r4,r19
8113553c:	d8c00017 	ldw	r3,0(sp)
81135540:	2400052e 	bgeu	r4,r16,81135558 <__udivdi3+0x244>
81135544:	2449883a 	add	r4,r4,r17
81135548:	b0bfffc4 	addi	r2,r22,-1
8113554c:	24400136 	bltu	r4,r17,81135554 <__udivdi3+0x240>
81135550:	2400ca36 	bltu	r4,r16,8113587c <__udivdi3+0x568>
81135554:	102d883a 	mov	r22,r2
81135558:	2421c83a 	sub	r16,r4,r16
8113555c:	a80b883a 	mov	r5,r21
81135560:	8009883a 	mov	r4,r16
81135564:	d8c00015 	stw	r3,0(sp)
81135568:	1135f300 	call	81135f30 <__umodsi3>
8113556c:	1027883a 	mov	r19,r2
81135570:	a80b883a 	mov	r5,r21
81135574:	8009883a 	mov	r4,r16
81135578:	1135ecc0 	call	81135ecc <__udivsi3>
8113557c:	9826943a 	slli	r19,r19,16
81135580:	1529383a 	mul	r20,r2,r20
81135584:	94bfffcc 	andi	r18,r18,65535
81135588:	94e4b03a 	or	r18,r18,r19
8113558c:	d8c00017 	ldw	r3,0(sp)
81135590:	9500052e 	bgeu	r18,r20,811355a8 <__udivdi3+0x294>
81135594:	8ca5883a 	add	r18,r17,r18
81135598:	113fffc4 	addi	r4,r2,-1
8113559c:	94409736 	bltu	r18,r17,811357fc <__udivdi3+0x4e8>
811355a0:	9500962e 	bgeu	r18,r20,811357fc <__udivdi3+0x4e8>
811355a4:	10bfff84 	addi	r2,r2,-2
811355a8:	b00c943a 	slli	r6,r22,16
811355ac:	3084b03a 	or	r2,r6,r2
811355b0:	00000206 	br	811355bc <__udivdi3+0x2a8>
811355b4:	0007883a 	mov	r3,zero
811355b8:	0005883a 	mov	r2,zero
811355bc:	dfc00a17 	ldw	ra,40(sp)
811355c0:	df000917 	ldw	fp,36(sp)
811355c4:	ddc00817 	ldw	r23,32(sp)
811355c8:	dd800717 	ldw	r22,28(sp)
811355cc:	dd400617 	ldw	r21,24(sp)
811355d0:	dd000517 	ldw	r20,20(sp)
811355d4:	dcc00417 	ldw	r19,16(sp)
811355d8:	dc800317 	ldw	r18,12(sp)
811355dc:	dc400217 	ldw	r17,8(sp)
811355e0:	dc000117 	ldw	r16,4(sp)
811355e4:	dec00b04 	addi	sp,sp,44
811355e8:	f800283a 	ret
811355ec:	00803fc4 	movi	r2,255
811355f0:	11c5803a 	cmpltu	r2,r2,r7
811355f4:	100490fa 	slli	r2,r2,3
811355f8:	003f9e06 	br	81135474 <__reset+0xfb115474>
811355fc:	00803fc4 	movi	r2,255
81135600:	1445803a 	cmpltu	r2,r2,r17
81135604:	100490fa 	slli	r2,r2,3
81135608:	003fb206 	br	811354d4 <__reset+0xfb1154d4>
8113560c:	00804034 	movhi	r2,256
81135610:	10bfffc4 	addi	r2,r2,-1
81135614:	11808836 	bltu	r2,r6,81135838 <__udivdi3+0x524>
81135618:	00800404 	movi	r2,16
8113561c:	003f5606 	br	81135378 <__reset+0xfb115378>
81135620:	30aed83a 	srl	r23,r6,r2
81135624:	3d4e983a 	sll	r7,r7,r21
81135628:	80acd83a 	srl	r22,r16,r2
8113562c:	9884d83a 	srl	r2,r19,r2
81135630:	3deeb03a 	or	r23,r7,r23
81135634:	b824d43a 	srli	r18,r23,16
81135638:	8560983a 	sll	r16,r16,r21
8113563c:	b009883a 	mov	r4,r22
81135640:	900b883a 	mov	r5,r18
81135644:	3568983a 	sll	r20,r6,r21
81135648:	1420b03a 	or	r16,r2,r16
8113564c:	1135f300 	call	81135f30 <__umodsi3>
81135650:	b009883a 	mov	r4,r22
81135654:	900b883a 	mov	r5,r18
81135658:	1023883a 	mov	r17,r2
8113565c:	1135ecc0 	call	81135ecc <__udivsi3>
81135660:	8808943a 	slli	r4,r17,16
81135664:	bf3fffcc 	andi	fp,r23,65535
81135668:	8006d43a 	srli	r3,r16,16
8113566c:	e0a3383a 	mul	r17,fp,r2
81135670:	100d883a 	mov	r6,r2
81135674:	1906b03a 	or	r3,r3,r4
81135678:	1c40042e 	bgeu	r3,r17,8113568c <__udivdi3+0x378>
8113567c:	1dc7883a 	add	r3,r3,r23
81135680:	10bfffc4 	addi	r2,r2,-1
81135684:	1dc0752e 	bgeu	r3,r23,8113585c <__udivdi3+0x548>
81135688:	100d883a 	mov	r6,r2
8113568c:	1c63c83a 	sub	r17,r3,r17
81135690:	900b883a 	mov	r5,r18
81135694:	8809883a 	mov	r4,r17
81135698:	d9800015 	stw	r6,0(sp)
8113569c:	1135f300 	call	81135f30 <__umodsi3>
811356a0:	102d883a 	mov	r22,r2
811356a4:	8809883a 	mov	r4,r17
811356a8:	900b883a 	mov	r5,r18
811356ac:	1135ecc0 	call	81135ecc <__udivsi3>
811356b0:	b02c943a 	slli	r22,r22,16
811356b4:	e089383a 	mul	r4,fp,r2
811356b8:	843fffcc 	andi	r16,r16,65535
811356bc:	85a0b03a 	or	r16,r16,r22
811356c0:	d9800017 	ldw	r6,0(sp)
811356c4:	8100042e 	bgeu	r16,r4,811356d8 <__udivdi3+0x3c4>
811356c8:	85e1883a 	add	r16,r16,r23
811356cc:	10ffffc4 	addi	r3,r2,-1
811356d0:	85c05e2e 	bgeu	r16,r23,8113584c <__udivdi3+0x538>
811356d4:	1805883a 	mov	r2,r3
811356d8:	300c943a 	slli	r6,r6,16
811356dc:	a17fffcc 	andi	r5,r20,65535
811356e0:	a028d43a 	srli	r20,r20,16
811356e4:	3084b03a 	or	r2,r6,r2
811356e8:	10ffffcc 	andi	r3,r2,65535
811356ec:	100cd43a 	srli	r6,r2,16
811356f0:	194f383a 	mul	r7,r3,r5
811356f4:	1d07383a 	mul	r3,r3,r20
811356f8:	314b383a 	mul	r5,r6,r5
811356fc:	3810d43a 	srli	r8,r7,16
81135700:	8121c83a 	sub	r16,r16,r4
81135704:	1947883a 	add	r3,r3,r5
81135708:	40c7883a 	add	r3,r8,r3
8113570c:	350d383a 	mul	r6,r6,r20
81135710:	1940022e 	bgeu	r3,r5,8113571c <__udivdi3+0x408>
81135714:	01000074 	movhi	r4,1
81135718:	310d883a 	add	r6,r6,r4
8113571c:	1828d43a 	srli	r20,r3,16
81135720:	a18d883a 	add	r6,r20,r6
81135724:	81803e36 	bltu	r16,r6,81135820 <__udivdi3+0x50c>
81135728:	81803826 	beq	r16,r6,8113580c <__udivdi3+0x4f8>
8113572c:	0007883a 	mov	r3,zero
81135730:	003fa206 	br	811355bc <__reset+0xfb1155bc>
81135734:	88e2983a 	sll	r17,r17,r3
81135738:	80a8d83a 	srl	r20,r16,r2
8113573c:	80e0983a 	sll	r16,r16,r3
81135740:	882ad43a 	srli	r21,r17,16
81135744:	9884d83a 	srl	r2,r19,r2
81135748:	a009883a 	mov	r4,r20
8113574c:	a80b883a 	mov	r5,r21
81135750:	142eb03a 	or	r23,r2,r16
81135754:	98e4983a 	sll	r18,r19,r3
81135758:	1135f300 	call	81135f30 <__umodsi3>
8113575c:	a009883a 	mov	r4,r20
81135760:	a80b883a 	mov	r5,r21
81135764:	1021883a 	mov	r16,r2
81135768:	1135ecc0 	call	81135ecc <__udivsi3>
8113576c:	1039883a 	mov	fp,r2
81135770:	8d3fffcc 	andi	r20,r17,65535
81135774:	8020943a 	slli	r16,r16,16
81135778:	b804d43a 	srli	r2,r23,16
8113577c:	a72d383a 	mul	r22,r20,fp
81135780:	1404b03a 	or	r2,r2,r16
81135784:	1580062e 	bgeu	r2,r22,811357a0 <__udivdi3+0x48c>
81135788:	1445883a 	add	r2,r2,r17
8113578c:	e0ffffc4 	addi	r3,fp,-1
81135790:	14403836 	bltu	r2,r17,81135874 <__udivdi3+0x560>
81135794:	1580372e 	bgeu	r2,r22,81135874 <__udivdi3+0x560>
81135798:	e73fff84 	addi	fp,fp,-2
8113579c:	1445883a 	add	r2,r2,r17
811357a0:	15adc83a 	sub	r22,r2,r22
811357a4:	a80b883a 	mov	r5,r21
811357a8:	b009883a 	mov	r4,r22
811357ac:	1135f300 	call	81135f30 <__umodsi3>
811357b0:	1027883a 	mov	r19,r2
811357b4:	b009883a 	mov	r4,r22
811357b8:	a80b883a 	mov	r5,r21
811357bc:	1135ecc0 	call	81135ecc <__udivsi3>
811357c0:	9826943a 	slli	r19,r19,16
811357c4:	a0a1383a 	mul	r16,r20,r2
811357c8:	b93fffcc 	andi	r4,r23,65535
811357cc:	24c8b03a 	or	r4,r4,r19
811357d0:	2400062e 	bgeu	r4,r16,811357ec <__udivdi3+0x4d8>
811357d4:	2449883a 	add	r4,r4,r17
811357d8:	10ffffc4 	addi	r3,r2,-1
811357dc:	24402336 	bltu	r4,r17,8113586c <__udivdi3+0x558>
811357e0:	2400222e 	bgeu	r4,r16,8113586c <__udivdi3+0x558>
811357e4:	10bfff84 	addi	r2,r2,-2
811357e8:	2449883a 	add	r4,r4,r17
811357ec:	e038943a 	slli	fp,fp,16
811357f0:	2421c83a 	sub	r16,r4,r16
811357f4:	e086b03a 	or	r3,fp,r2
811357f8:	003f4306 	br	81135508 <__reset+0xfb115508>
811357fc:	2005883a 	mov	r2,r4
81135800:	003f6906 	br	811355a8 <__reset+0xfb1155a8>
81135804:	1805883a 	mov	r2,r3
81135808:	003f0f06 	br	81135448 <__reset+0xfb115448>
8113580c:	1806943a 	slli	r3,r3,16
81135810:	9d66983a 	sll	r19,r19,r21
81135814:	39ffffcc 	andi	r7,r7,65535
81135818:	19c7883a 	add	r3,r3,r7
8113581c:	98ffc32e 	bgeu	r19,r3,8113572c <__reset+0xfb11572c>
81135820:	10bfffc4 	addi	r2,r2,-1
81135824:	003fc106 	br	8113572c <__reset+0xfb11572c>
81135828:	00800604 	movi	r2,24
8113582c:	003f1106 	br	81135474 <__reset+0xfb115474>
81135830:	00800604 	movi	r2,24
81135834:	003f2706 	br	811354d4 <__reset+0xfb1154d4>
81135838:	00800604 	movi	r2,24
8113583c:	003ece06 	br	81135378 <__reset+0xfb115378>
81135840:	0007883a 	mov	r3,zero
81135844:	00800044 	movi	r2,1
81135848:	003f5c06 	br	811355bc <__reset+0xfb1155bc>
8113584c:	813fa12e 	bgeu	r16,r4,811356d4 <__reset+0xfb1156d4>
81135850:	10bfff84 	addi	r2,r2,-2
81135854:	85e1883a 	add	r16,r16,r23
81135858:	003f9f06 	br	811356d8 <__reset+0xfb1156d8>
8113585c:	1c7f8a2e 	bgeu	r3,r17,81135688 <__reset+0xfb115688>
81135860:	31bfff84 	addi	r6,r6,-2
81135864:	1dc7883a 	add	r3,r3,r23
81135868:	003f8806 	br	8113568c <__reset+0xfb11568c>
8113586c:	1805883a 	mov	r2,r3
81135870:	003fde06 	br	811357ec <__reset+0xfb1157ec>
81135874:	1839883a 	mov	fp,r3
81135878:	003fc906 	br	811357a0 <__reset+0xfb1157a0>
8113587c:	b5bfff84 	addi	r22,r22,-2
81135880:	2449883a 	add	r4,r4,r17
81135884:	003f3406 	br	81135558 <__reset+0xfb115558>
81135888:	b5bfff84 	addi	r22,r22,-2
8113588c:	1445883a 	add	r2,r2,r17
81135890:	003edb06 	br	81135400 <__reset+0xfb115400>

81135894 <__umoddi3>:
81135894:	defff404 	addi	sp,sp,-48
81135898:	de00012e 	bgeu	sp,et,811358a0 <__umoddi3+0xc>
8113589c:	003b68fa 	trap	3
811358a0:	df000a15 	stw	fp,40(sp)
811358a4:	dc400315 	stw	r17,12(sp)
811358a8:	dc000215 	stw	r16,8(sp)
811358ac:	dfc00b15 	stw	ra,44(sp)
811358b0:	ddc00915 	stw	r23,36(sp)
811358b4:	dd800815 	stw	r22,32(sp)
811358b8:	dd400715 	stw	r21,28(sp)
811358bc:	dd000615 	stw	r20,24(sp)
811358c0:	dcc00515 	stw	r19,20(sp)
811358c4:	dc800415 	stw	r18,16(sp)
811358c8:	2021883a 	mov	r16,r4
811358cc:	2823883a 	mov	r17,r5
811358d0:	2839883a 	mov	fp,r5
811358d4:	38003c1e 	bne	r7,zero,811359c8 <__umoddi3+0x134>
811358d8:	3027883a 	mov	r19,r6
811358dc:	2029883a 	mov	r20,r4
811358e0:	2980512e 	bgeu	r5,r6,81135a28 <__umoddi3+0x194>
811358e4:	00bfffd4 	movui	r2,65535
811358e8:	11809a36 	bltu	r2,r6,81135b54 <__umoddi3+0x2c0>
811358ec:	01003fc4 	movi	r4,255
811358f0:	2189803a 	cmpltu	r4,r4,r6
811358f4:	200890fa 	slli	r4,r4,3
811358f8:	3104d83a 	srl	r2,r6,r4
811358fc:	00e04574 	movhi	r3,33045
81135900:	18c63604 	addi	r3,r3,6360
81135904:	1885883a 	add	r2,r3,r2
81135908:	10c00003 	ldbu	r3,0(r2)
8113590c:	00800804 	movi	r2,32
81135910:	1909883a 	add	r4,r3,r4
81135914:	1125c83a 	sub	r18,r2,r4
81135918:	90000526 	beq	r18,zero,81135930 <__umoddi3+0x9c>
8113591c:	8ca2983a 	sll	r17,r17,r18
81135920:	8108d83a 	srl	r4,r16,r4
81135924:	34a6983a 	sll	r19,r6,r18
81135928:	84a8983a 	sll	r20,r16,r18
8113592c:	2478b03a 	or	fp,r4,r17
81135930:	982ed43a 	srli	r23,r19,16
81135934:	e009883a 	mov	r4,fp
81135938:	9dbfffcc 	andi	r22,r19,65535
8113593c:	b80b883a 	mov	r5,r23
81135940:	1135f300 	call	81135f30 <__umodsi3>
81135944:	e009883a 	mov	r4,fp
81135948:	b80b883a 	mov	r5,r23
8113594c:	102b883a 	mov	r21,r2
81135950:	1135ecc0 	call	81135ecc <__udivsi3>
81135954:	a806943a 	slli	r3,r21,16
81135958:	a008d43a 	srli	r4,r20,16
8113595c:	b085383a 	mul	r2,r22,r2
81135960:	20c8b03a 	or	r4,r4,r3
81135964:	2080032e 	bgeu	r4,r2,81135974 <__umoddi3+0xe0>
81135968:	24c9883a 	add	r4,r4,r19
8113596c:	24c00136 	bltu	r4,r19,81135974 <__umoddi3+0xe0>
81135970:	20811036 	bltu	r4,r2,81135db4 <__umoddi3+0x520>
81135974:	20abc83a 	sub	r21,r4,r2
81135978:	b80b883a 	mov	r5,r23
8113597c:	a809883a 	mov	r4,r21
81135980:	1135f300 	call	81135f30 <__umodsi3>
81135984:	1023883a 	mov	r17,r2
81135988:	b80b883a 	mov	r5,r23
8113598c:	a809883a 	mov	r4,r21
81135990:	1135ecc0 	call	81135ecc <__udivsi3>
81135994:	8822943a 	slli	r17,r17,16
81135998:	b085383a 	mul	r2,r22,r2
8113599c:	a0ffffcc 	andi	r3,r20,65535
811359a0:	1c46b03a 	or	r3,r3,r17
811359a4:	1880042e 	bgeu	r3,r2,811359b8 <__umoddi3+0x124>
811359a8:	1cc7883a 	add	r3,r3,r19
811359ac:	1cc00236 	bltu	r3,r19,811359b8 <__umoddi3+0x124>
811359b0:	1880012e 	bgeu	r3,r2,811359b8 <__umoddi3+0x124>
811359b4:	1cc7883a 	add	r3,r3,r19
811359b8:	1885c83a 	sub	r2,r3,r2
811359bc:	1484d83a 	srl	r2,r2,r18
811359c0:	0007883a 	mov	r3,zero
811359c4:	00004f06 	br	81135b04 <__umoddi3+0x270>
811359c8:	29c04c36 	bltu	r5,r7,81135afc <__umoddi3+0x268>
811359cc:	00bfffd4 	movui	r2,65535
811359d0:	11c0582e 	bgeu	r2,r7,81135b34 <__umoddi3+0x2a0>
811359d4:	00804034 	movhi	r2,256
811359d8:	10bfffc4 	addi	r2,r2,-1
811359dc:	11c0e736 	bltu	r2,r7,81135d7c <__umoddi3+0x4e8>
811359e0:	01000404 	movi	r4,16
811359e4:	3904d83a 	srl	r2,r7,r4
811359e8:	00e04574 	movhi	r3,33045
811359ec:	18c63604 	addi	r3,r3,6360
811359f0:	1885883a 	add	r2,r3,r2
811359f4:	14c00003 	ldbu	r19,0(r2)
811359f8:	00c00804 	movi	r3,32
811359fc:	9927883a 	add	r19,r19,r4
81135a00:	1ce9c83a 	sub	r20,r3,r19
81135a04:	a000581e 	bne	r20,zero,81135b68 <__umoddi3+0x2d4>
81135a08:	3c400136 	bltu	r7,r17,81135a10 <__umoddi3+0x17c>
81135a0c:	8180eb36 	bltu	r16,r6,81135dbc <__umoddi3+0x528>
81135a10:	8185c83a 	sub	r2,r16,r6
81135a14:	89e3c83a 	sub	r17,r17,r7
81135a18:	8089803a 	cmpltu	r4,r16,r2
81135a1c:	8939c83a 	sub	fp,r17,r4
81135a20:	e007883a 	mov	r3,fp
81135a24:	00003706 	br	81135b04 <__umoddi3+0x270>
81135a28:	3000041e 	bne	r6,zero,81135a3c <__umoddi3+0x1a8>
81135a2c:	000b883a 	mov	r5,zero
81135a30:	01000044 	movi	r4,1
81135a34:	1135ecc0 	call	81135ecc <__udivsi3>
81135a38:	1027883a 	mov	r19,r2
81135a3c:	00bfffd4 	movui	r2,65535
81135a40:	14c0402e 	bgeu	r2,r19,81135b44 <__umoddi3+0x2b0>
81135a44:	00804034 	movhi	r2,256
81135a48:	10bfffc4 	addi	r2,r2,-1
81135a4c:	14c0cd36 	bltu	r2,r19,81135d84 <__umoddi3+0x4f0>
81135a50:	00800404 	movi	r2,16
81135a54:	9886d83a 	srl	r3,r19,r2
81135a58:	01204574 	movhi	r4,33045
81135a5c:	21063604 	addi	r4,r4,6360
81135a60:	20c7883a 	add	r3,r4,r3
81135a64:	18c00003 	ldbu	r3,0(r3)
81135a68:	1887883a 	add	r3,r3,r2
81135a6c:	00800804 	movi	r2,32
81135a70:	10e5c83a 	sub	r18,r2,r3
81135a74:	9000901e 	bne	r18,zero,81135cb8 <__umoddi3+0x424>
81135a78:	982cd43a 	srli	r22,r19,16
81135a7c:	8ce3c83a 	sub	r17,r17,r19
81135a80:	9d7fffcc 	andi	r21,r19,65535
81135a84:	b00b883a 	mov	r5,r22
81135a88:	8809883a 	mov	r4,r17
81135a8c:	1135f300 	call	81135f30 <__umodsi3>
81135a90:	8809883a 	mov	r4,r17
81135a94:	b00b883a 	mov	r5,r22
81135a98:	1021883a 	mov	r16,r2
81135a9c:	1135ecc0 	call	81135ecc <__udivsi3>
81135aa0:	8006943a 	slli	r3,r16,16
81135aa4:	a008d43a 	srli	r4,r20,16
81135aa8:	1545383a 	mul	r2,r2,r21
81135aac:	20c8b03a 	or	r4,r4,r3
81135ab0:	2080042e 	bgeu	r4,r2,81135ac4 <__umoddi3+0x230>
81135ab4:	24c9883a 	add	r4,r4,r19
81135ab8:	24c00236 	bltu	r4,r19,81135ac4 <__umoddi3+0x230>
81135abc:	2080012e 	bgeu	r4,r2,81135ac4 <__umoddi3+0x230>
81135ac0:	24c9883a 	add	r4,r4,r19
81135ac4:	20a1c83a 	sub	r16,r4,r2
81135ac8:	b00b883a 	mov	r5,r22
81135acc:	8009883a 	mov	r4,r16
81135ad0:	1135f300 	call	81135f30 <__umodsi3>
81135ad4:	1023883a 	mov	r17,r2
81135ad8:	b00b883a 	mov	r5,r22
81135adc:	8009883a 	mov	r4,r16
81135ae0:	1135ecc0 	call	81135ecc <__udivsi3>
81135ae4:	8822943a 	slli	r17,r17,16
81135ae8:	1545383a 	mul	r2,r2,r21
81135aec:	a53fffcc 	andi	r20,r20,65535
81135af0:	a446b03a 	or	r3,r20,r17
81135af4:	18bfb02e 	bgeu	r3,r2,811359b8 <__reset+0xfb1159b8>
81135af8:	003fab06 	br	811359a8 <__reset+0xfb1159a8>
81135afc:	2005883a 	mov	r2,r4
81135b00:	2807883a 	mov	r3,r5
81135b04:	dfc00b17 	ldw	ra,44(sp)
81135b08:	df000a17 	ldw	fp,40(sp)
81135b0c:	ddc00917 	ldw	r23,36(sp)
81135b10:	dd800817 	ldw	r22,32(sp)
81135b14:	dd400717 	ldw	r21,28(sp)
81135b18:	dd000617 	ldw	r20,24(sp)
81135b1c:	dcc00517 	ldw	r19,20(sp)
81135b20:	dc800417 	ldw	r18,16(sp)
81135b24:	dc400317 	ldw	r17,12(sp)
81135b28:	dc000217 	ldw	r16,8(sp)
81135b2c:	dec00c04 	addi	sp,sp,48
81135b30:	f800283a 	ret
81135b34:	04c03fc4 	movi	r19,255
81135b38:	99c9803a 	cmpltu	r4,r19,r7
81135b3c:	200890fa 	slli	r4,r4,3
81135b40:	003fa806 	br	811359e4 <__reset+0xfb1159e4>
81135b44:	00803fc4 	movi	r2,255
81135b48:	14c5803a 	cmpltu	r2,r2,r19
81135b4c:	100490fa 	slli	r2,r2,3
81135b50:	003fc006 	br	81135a54 <__reset+0xfb115a54>
81135b54:	00804034 	movhi	r2,256
81135b58:	10bfffc4 	addi	r2,r2,-1
81135b5c:	11808b36 	bltu	r2,r6,81135d8c <__umoddi3+0x4f8>
81135b60:	01000404 	movi	r4,16
81135b64:	003f6406 	br	811358f8 <__reset+0xfb1158f8>
81135b68:	34c4d83a 	srl	r2,r6,r19
81135b6c:	3d0e983a 	sll	r7,r7,r20
81135b70:	8cf8d83a 	srl	fp,r17,r19
81135b74:	8d10983a 	sll	r8,r17,r20
81135b78:	38aab03a 	or	r21,r7,r2
81135b7c:	a82cd43a 	srli	r22,r21,16
81135b80:	84e2d83a 	srl	r17,r16,r19
81135b84:	e009883a 	mov	r4,fp
81135b88:	b00b883a 	mov	r5,r22
81135b8c:	8a22b03a 	or	r17,r17,r8
81135b90:	3524983a 	sll	r18,r6,r20
81135b94:	1135f300 	call	81135f30 <__umodsi3>
81135b98:	e009883a 	mov	r4,fp
81135b9c:	b00b883a 	mov	r5,r22
81135ba0:	102f883a 	mov	r23,r2
81135ba4:	1135ecc0 	call	81135ecc <__udivsi3>
81135ba8:	100d883a 	mov	r6,r2
81135bac:	b808943a 	slli	r4,r23,16
81135bb0:	aa3fffcc 	andi	r8,r21,65535
81135bb4:	8804d43a 	srli	r2,r17,16
81135bb8:	41af383a 	mul	r23,r8,r6
81135bbc:	8520983a 	sll	r16,r16,r20
81135bc0:	1104b03a 	or	r2,r2,r4
81135bc4:	15c0042e 	bgeu	r2,r23,81135bd8 <__umoddi3+0x344>
81135bc8:	1545883a 	add	r2,r2,r21
81135bcc:	30ffffc4 	addi	r3,r6,-1
81135bd0:	1540742e 	bgeu	r2,r21,81135da4 <__umoddi3+0x510>
81135bd4:	180d883a 	mov	r6,r3
81135bd8:	15efc83a 	sub	r23,r2,r23
81135bdc:	b00b883a 	mov	r5,r22
81135be0:	b809883a 	mov	r4,r23
81135be4:	d9800115 	stw	r6,4(sp)
81135be8:	da000015 	stw	r8,0(sp)
81135bec:	1135f300 	call	81135f30 <__umodsi3>
81135bf0:	b00b883a 	mov	r5,r22
81135bf4:	b809883a 	mov	r4,r23
81135bf8:	1039883a 	mov	fp,r2
81135bfc:	1135ecc0 	call	81135ecc <__udivsi3>
81135c00:	da000017 	ldw	r8,0(sp)
81135c04:	e038943a 	slli	fp,fp,16
81135c08:	100b883a 	mov	r5,r2
81135c0c:	4089383a 	mul	r4,r8,r2
81135c10:	8a3fffcc 	andi	r8,r17,65535
81135c14:	4710b03a 	or	r8,r8,fp
81135c18:	d9800117 	ldw	r6,4(sp)
81135c1c:	4100042e 	bgeu	r8,r4,81135c30 <__umoddi3+0x39c>
81135c20:	4551883a 	add	r8,r8,r21
81135c24:	10bfffc4 	addi	r2,r2,-1
81135c28:	45405a2e 	bgeu	r8,r21,81135d94 <__umoddi3+0x500>
81135c2c:	100b883a 	mov	r5,r2
81135c30:	300c943a 	slli	r6,r6,16
81135c34:	91ffffcc 	andi	r7,r18,65535
81135c38:	9004d43a 	srli	r2,r18,16
81135c3c:	314cb03a 	or	r6,r6,r5
81135c40:	317fffcc 	andi	r5,r6,65535
81135c44:	300cd43a 	srli	r6,r6,16
81135c48:	29d3383a 	mul	r9,r5,r7
81135c4c:	288b383a 	mul	r5,r5,r2
81135c50:	31cf383a 	mul	r7,r6,r7
81135c54:	4806d43a 	srli	r3,r9,16
81135c58:	4111c83a 	sub	r8,r8,r4
81135c5c:	29cb883a 	add	r5,r5,r7
81135c60:	194b883a 	add	r5,r3,r5
81135c64:	3085383a 	mul	r2,r6,r2
81135c68:	29c0022e 	bgeu	r5,r7,81135c74 <__umoddi3+0x3e0>
81135c6c:	00c00074 	movhi	r3,1
81135c70:	10c5883a 	add	r2,r2,r3
81135c74:	2808d43a 	srli	r4,r5,16
81135c78:	280a943a 	slli	r5,r5,16
81135c7c:	4a7fffcc 	andi	r9,r9,65535
81135c80:	2085883a 	add	r2,r4,r2
81135c84:	2a4b883a 	add	r5,r5,r9
81135c88:	40803636 	bltu	r8,r2,81135d64 <__umoddi3+0x4d0>
81135c8c:	40804d26 	beq	r8,r2,81135dc4 <__umoddi3+0x530>
81135c90:	4089c83a 	sub	r4,r8,r2
81135c94:	280f883a 	mov	r7,r5
81135c98:	81cfc83a 	sub	r7,r16,r7
81135c9c:	81c7803a 	cmpltu	r3,r16,r7
81135ca0:	20c7c83a 	sub	r3,r4,r3
81135ca4:	1cc4983a 	sll	r2,r3,r19
81135ca8:	3d0ed83a 	srl	r7,r7,r20
81135cac:	1d06d83a 	srl	r3,r3,r20
81135cb0:	11c4b03a 	or	r2,r2,r7
81135cb4:	003f9306 	br	81135b04 <__reset+0xfb115b04>
81135cb8:	9ca6983a 	sll	r19,r19,r18
81135cbc:	88e8d83a 	srl	r20,r17,r3
81135cc0:	80c4d83a 	srl	r2,r16,r3
81135cc4:	982cd43a 	srli	r22,r19,16
81135cc8:	8ca2983a 	sll	r17,r17,r18
81135ccc:	a009883a 	mov	r4,r20
81135cd0:	b00b883a 	mov	r5,r22
81135cd4:	1478b03a 	or	fp,r2,r17
81135cd8:	1135f300 	call	81135f30 <__umodsi3>
81135cdc:	a009883a 	mov	r4,r20
81135ce0:	b00b883a 	mov	r5,r22
81135ce4:	1023883a 	mov	r17,r2
81135ce8:	1135ecc0 	call	81135ecc <__udivsi3>
81135cec:	9d7fffcc 	andi	r21,r19,65535
81135cf0:	880a943a 	slli	r5,r17,16
81135cf4:	e008d43a 	srli	r4,fp,16
81135cf8:	a885383a 	mul	r2,r21,r2
81135cfc:	84a8983a 	sll	r20,r16,r18
81135d00:	2148b03a 	or	r4,r4,r5
81135d04:	2080042e 	bgeu	r4,r2,81135d18 <__umoddi3+0x484>
81135d08:	24c9883a 	add	r4,r4,r19
81135d0c:	24c00236 	bltu	r4,r19,81135d18 <__umoddi3+0x484>
81135d10:	2080012e 	bgeu	r4,r2,81135d18 <__umoddi3+0x484>
81135d14:	24c9883a 	add	r4,r4,r19
81135d18:	20a3c83a 	sub	r17,r4,r2
81135d1c:	b00b883a 	mov	r5,r22
81135d20:	8809883a 	mov	r4,r17
81135d24:	1135f300 	call	81135f30 <__umodsi3>
81135d28:	102f883a 	mov	r23,r2
81135d2c:	8809883a 	mov	r4,r17
81135d30:	b00b883a 	mov	r5,r22
81135d34:	1135ecc0 	call	81135ecc <__udivsi3>
81135d38:	b82e943a 	slli	r23,r23,16
81135d3c:	a885383a 	mul	r2,r21,r2
81135d40:	e13fffcc 	andi	r4,fp,65535
81135d44:	25c8b03a 	or	r4,r4,r23
81135d48:	2080042e 	bgeu	r4,r2,81135d5c <__umoddi3+0x4c8>
81135d4c:	24c9883a 	add	r4,r4,r19
81135d50:	24c00236 	bltu	r4,r19,81135d5c <__umoddi3+0x4c8>
81135d54:	2080012e 	bgeu	r4,r2,81135d5c <__umoddi3+0x4c8>
81135d58:	24c9883a 	add	r4,r4,r19
81135d5c:	20a3c83a 	sub	r17,r4,r2
81135d60:	003f4806 	br	81135a84 <__reset+0xfb115a84>
81135d64:	2c8fc83a 	sub	r7,r5,r18
81135d68:	1545c83a 	sub	r2,r2,r21
81135d6c:	29cb803a 	cmpltu	r5,r5,r7
81135d70:	1145c83a 	sub	r2,r2,r5
81135d74:	4089c83a 	sub	r4,r8,r2
81135d78:	003fc706 	br	81135c98 <__reset+0xfb115c98>
81135d7c:	01000604 	movi	r4,24
81135d80:	003f1806 	br	811359e4 <__reset+0xfb1159e4>
81135d84:	00800604 	movi	r2,24
81135d88:	003f3206 	br	81135a54 <__reset+0xfb115a54>
81135d8c:	01000604 	movi	r4,24
81135d90:	003ed906 	br	811358f8 <__reset+0xfb1158f8>
81135d94:	413fa52e 	bgeu	r8,r4,81135c2c <__reset+0xfb115c2c>
81135d98:	297fff84 	addi	r5,r5,-2
81135d9c:	4551883a 	add	r8,r8,r21
81135da0:	003fa306 	br	81135c30 <__reset+0xfb115c30>
81135da4:	15ff8b2e 	bgeu	r2,r23,81135bd4 <__reset+0xfb115bd4>
81135da8:	31bfff84 	addi	r6,r6,-2
81135dac:	1545883a 	add	r2,r2,r21
81135db0:	003f8906 	br	81135bd8 <__reset+0xfb115bd8>
81135db4:	24c9883a 	add	r4,r4,r19
81135db8:	003eee06 	br	81135974 <__reset+0xfb115974>
81135dbc:	8005883a 	mov	r2,r16
81135dc0:	003f1706 	br	81135a20 <__reset+0xfb115a20>
81135dc4:	817fe736 	bltu	r16,r5,81135d64 <__reset+0xfb115d64>
81135dc8:	280f883a 	mov	r7,r5
81135dcc:	0009883a 	mov	r4,zero
81135dd0:	003fb106 	br	81135c98 <__reset+0xfb115c98>

81135dd4 <__divsi3>:
81135dd4:	20001b16 	blt	r4,zero,81135e44 <__divsi3+0x70>
81135dd8:	000f883a 	mov	r7,zero
81135ddc:	28001616 	blt	r5,zero,81135e38 <__divsi3+0x64>
81135de0:	200d883a 	mov	r6,r4
81135de4:	29001a2e 	bgeu	r5,r4,81135e50 <__divsi3+0x7c>
81135de8:	00800804 	movi	r2,32
81135dec:	00c00044 	movi	r3,1
81135df0:	00000106 	br	81135df8 <__divsi3+0x24>
81135df4:	10000d26 	beq	r2,zero,81135e2c <__divsi3+0x58>
81135df8:	294b883a 	add	r5,r5,r5
81135dfc:	10bfffc4 	addi	r2,r2,-1
81135e00:	18c7883a 	add	r3,r3,r3
81135e04:	293ffb36 	bltu	r5,r4,81135df4 <__reset+0xfb115df4>
81135e08:	0005883a 	mov	r2,zero
81135e0c:	18000726 	beq	r3,zero,81135e2c <__divsi3+0x58>
81135e10:	0005883a 	mov	r2,zero
81135e14:	31400236 	bltu	r6,r5,81135e20 <__divsi3+0x4c>
81135e18:	314dc83a 	sub	r6,r6,r5
81135e1c:	10c4b03a 	or	r2,r2,r3
81135e20:	1806d07a 	srli	r3,r3,1
81135e24:	280ad07a 	srli	r5,r5,1
81135e28:	183ffa1e 	bne	r3,zero,81135e14 <__reset+0xfb115e14>
81135e2c:	38000126 	beq	r7,zero,81135e34 <__divsi3+0x60>
81135e30:	0085c83a 	sub	r2,zero,r2
81135e34:	f800283a 	ret
81135e38:	014bc83a 	sub	r5,zero,r5
81135e3c:	39c0005c 	xori	r7,r7,1
81135e40:	003fe706 	br	81135de0 <__reset+0xfb115de0>
81135e44:	0109c83a 	sub	r4,zero,r4
81135e48:	01c00044 	movi	r7,1
81135e4c:	003fe306 	br	81135ddc <__reset+0xfb115ddc>
81135e50:	00c00044 	movi	r3,1
81135e54:	003fee06 	br	81135e10 <__reset+0xfb115e10>

81135e58 <__modsi3>:
81135e58:	20001716 	blt	r4,zero,81135eb8 <__modsi3+0x60>
81135e5c:	000f883a 	mov	r7,zero
81135e60:	2005883a 	mov	r2,r4
81135e64:	28001216 	blt	r5,zero,81135eb0 <__modsi3+0x58>
81135e68:	2900162e 	bgeu	r5,r4,81135ec4 <__modsi3+0x6c>
81135e6c:	01800804 	movi	r6,32
81135e70:	00c00044 	movi	r3,1
81135e74:	00000106 	br	81135e7c <__modsi3+0x24>
81135e78:	30000a26 	beq	r6,zero,81135ea4 <__modsi3+0x4c>
81135e7c:	294b883a 	add	r5,r5,r5
81135e80:	31bfffc4 	addi	r6,r6,-1
81135e84:	18c7883a 	add	r3,r3,r3
81135e88:	293ffb36 	bltu	r5,r4,81135e78 <__reset+0xfb115e78>
81135e8c:	18000526 	beq	r3,zero,81135ea4 <__modsi3+0x4c>
81135e90:	1806d07a 	srli	r3,r3,1
81135e94:	11400136 	bltu	r2,r5,81135e9c <__modsi3+0x44>
81135e98:	1145c83a 	sub	r2,r2,r5
81135e9c:	280ad07a 	srli	r5,r5,1
81135ea0:	183ffb1e 	bne	r3,zero,81135e90 <__reset+0xfb115e90>
81135ea4:	38000126 	beq	r7,zero,81135eac <__modsi3+0x54>
81135ea8:	0085c83a 	sub	r2,zero,r2
81135eac:	f800283a 	ret
81135eb0:	014bc83a 	sub	r5,zero,r5
81135eb4:	003fec06 	br	81135e68 <__reset+0xfb115e68>
81135eb8:	0109c83a 	sub	r4,zero,r4
81135ebc:	01c00044 	movi	r7,1
81135ec0:	003fe706 	br	81135e60 <__reset+0xfb115e60>
81135ec4:	00c00044 	movi	r3,1
81135ec8:	003ff106 	br	81135e90 <__reset+0xfb115e90>

81135ecc <__udivsi3>:
81135ecc:	200d883a 	mov	r6,r4
81135ed0:	2900152e 	bgeu	r5,r4,81135f28 <__udivsi3+0x5c>
81135ed4:	28001416 	blt	r5,zero,81135f28 <__udivsi3+0x5c>
81135ed8:	00800804 	movi	r2,32
81135edc:	00c00044 	movi	r3,1
81135ee0:	00000206 	br	81135eec <__udivsi3+0x20>
81135ee4:	10000e26 	beq	r2,zero,81135f20 <__udivsi3+0x54>
81135ee8:	28000516 	blt	r5,zero,81135f00 <__udivsi3+0x34>
81135eec:	294b883a 	add	r5,r5,r5
81135ef0:	10bfffc4 	addi	r2,r2,-1
81135ef4:	18c7883a 	add	r3,r3,r3
81135ef8:	293ffa36 	bltu	r5,r4,81135ee4 <__reset+0xfb115ee4>
81135efc:	18000826 	beq	r3,zero,81135f20 <__udivsi3+0x54>
81135f00:	0005883a 	mov	r2,zero
81135f04:	31400236 	bltu	r6,r5,81135f10 <__udivsi3+0x44>
81135f08:	314dc83a 	sub	r6,r6,r5
81135f0c:	10c4b03a 	or	r2,r2,r3
81135f10:	1806d07a 	srli	r3,r3,1
81135f14:	280ad07a 	srli	r5,r5,1
81135f18:	183ffa1e 	bne	r3,zero,81135f04 <__reset+0xfb115f04>
81135f1c:	f800283a 	ret
81135f20:	0005883a 	mov	r2,zero
81135f24:	f800283a 	ret
81135f28:	00c00044 	movi	r3,1
81135f2c:	003ff406 	br	81135f00 <__reset+0xfb115f00>

81135f30 <__umodsi3>:
81135f30:	2005883a 	mov	r2,r4
81135f34:	2900122e 	bgeu	r5,r4,81135f80 <__umodsi3+0x50>
81135f38:	28001116 	blt	r5,zero,81135f80 <__umodsi3+0x50>
81135f3c:	01800804 	movi	r6,32
81135f40:	00c00044 	movi	r3,1
81135f44:	00000206 	br	81135f50 <__umodsi3+0x20>
81135f48:	30000c26 	beq	r6,zero,81135f7c <__umodsi3+0x4c>
81135f4c:	28000516 	blt	r5,zero,81135f64 <__umodsi3+0x34>
81135f50:	294b883a 	add	r5,r5,r5
81135f54:	31bfffc4 	addi	r6,r6,-1
81135f58:	18c7883a 	add	r3,r3,r3
81135f5c:	293ffa36 	bltu	r5,r4,81135f48 <__reset+0xfb115f48>
81135f60:	18000626 	beq	r3,zero,81135f7c <__umodsi3+0x4c>
81135f64:	1806d07a 	srli	r3,r3,1
81135f68:	11400136 	bltu	r2,r5,81135f70 <__umodsi3+0x40>
81135f6c:	1145c83a 	sub	r2,r2,r5
81135f70:	280ad07a 	srli	r5,r5,1
81135f74:	183ffb1e 	bne	r3,zero,81135f64 <__reset+0xfb115f64>
81135f78:	f800283a 	ret
81135f7c:	f800283a 	ret
81135f80:	00c00044 	movi	r3,1
81135f84:	003ff706 	br	81135f64 <__reset+0xfb115f64>

81135f88 <__eqsf2>:
81135f88:	2006d5fa 	srli	r3,r4,23
81135f8c:	280cd5fa 	srli	r6,r5,23
81135f90:	01c02034 	movhi	r7,128
81135f94:	39ffffc4 	addi	r7,r7,-1
81135f98:	18c03fcc 	andi	r3,r3,255
81135f9c:	02003fc4 	movi	r8,255
81135fa0:	3904703a 	and	r2,r7,r4
81135fa4:	31803fcc 	andi	r6,r6,255
81135fa8:	394e703a 	and	r7,r7,r5
81135fac:	2008d7fa 	srli	r4,r4,31
81135fb0:	280ad7fa 	srli	r5,r5,31
81135fb4:	1a000d26 	beq	r3,r8,81135fec <__eqsf2+0x64>
81135fb8:	02003fc4 	movi	r8,255
81135fbc:	32000826 	beq	r6,r8,81135fe0 <__eqsf2+0x58>
81135fc0:	19800226 	beq	r3,r6,81135fcc <__eqsf2+0x44>
81135fc4:	00800044 	movi	r2,1
81135fc8:	f800283a 	ret
81135fcc:	11fffd1e 	bne	r2,r7,81135fc4 <__reset+0xfb115fc4>
81135fd0:	21400926 	beq	r4,r5,81135ff8 <__eqsf2+0x70>
81135fd4:	183ffb1e 	bne	r3,zero,81135fc4 <__reset+0xfb115fc4>
81135fd8:	1004c03a 	cmpne	r2,r2,zero
81135fdc:	f800283a 	ret
81135fe0:	383ff726 	beq	r7,zero,81135fc0 <__reset+0xfb115fc0>
81135fe4:	00800044 	movi	r2,1
81135fe8:	f800283a 	ret
81135fec:	103ff226 	beq	r2,zero,81135fb8 <__reset+0xfb115fb8>
81135ff0:	00800044 	movi	r2,1
81135ff4:	f800283a 	ret
81135ff8:	0005883a 	mov	r2,zero
81135ffc:	f800283a 	ret

81136000 <__gesf2>:
81136000:	2004d5fa 	srli	r2,r4,23
81136004:	2806d5fa 	srli	r3,r5,23
81136008:	01802034 	movhi	r6,128
8113600c:	31bfffc4 	addi	r6,r6,-1
81136010:	10803fcc 	andi	r2,r2,255
81136014:	01c03fc4 	movi	r7,255
81136018:	3110703a 	and	r8,r6,r4
8113601c:	18c03fcc 	andi	r3,r3,255
81136020:	314c703a 	and	r6,r6,r5
81136024:	2008d7fa 	srli	r4,r4,31
81136028:	280ad7fa 	srli	r5,r5,31
8113602c:	11c01926 	beq	r2,r7,81136094 <__gesf2+0x94>
81136030:	01c03fc4 	movi	r7,255
81136034:	19c00f26 	beq	r3,r7,81136074 <__gesf2+0x74>
81136038:	1000061e 	bne	r2,zero,81136054 <__gesf2+0x54>
8113603c:	400f003a 	cmpeq	r7,r8,zero
81136040:	1800071e 	bne	r3,zero,81136060 <__gesf2+0x60>
81136044:	3000061e 	bne	r6,zero,81136060 <__gesf2+0x60>
81136048:	0005883a 	mov	r2,zero
8113604c:	40000e1e 	bne	r8,zero,81136088 <__gesf2+0x88>
81136050:	f800283a 	ret
81136054:	18000a1e 	bne	r3,zero,81136080 <__gesf2+0x80>
81136058:	30000b26 	beq	r6,zero,81136088 <__gesf2+0x88>
8113605c:	000f883a 	mov	r7,zero
81136060:	29403fcc 	andi	r5,r5,255
81136064:	38000726 	beq	r7,zero,81136084 <__gesf2+0x84>
81136068:	28000826 	beq	r5,zero,8113608c <__gesf2+0x8c>
8113606c:	00800044 	movi	r2,1
81136070:	f800283a 	ret
81136074:	303ff026 	beq	r6,zero,81136038 <__reset+0xfb116038>
81136078:	00bfff84 	movi	r2,-2
8113607c:	f800283a 	ret
81136080:	29403fcc 	andi	r5,r5,255
81136084:	21400526 	beq	r4,r5,8113609c <__gesf2+0x9c>
81136088:	203ff826 	beq	r4,zero,8113606c <__reset+0xfb11606c>
8113608c:	00bfffc4 	movi	r2,-1
81136090:	f800283a 	ret
81136094:	403fe626 	beq	r8,zero,81136030 <__reset+0xfb116030>
81136098:	003ff706 	br	81136078 <__reset+0xfb116078>
8113609c:	18bffa16 	blt	r3,r2,81136088 <__reset+0xfb116088>
811360a0:	10c00216 	blt	r2,r3,811360ac <__gesf2+0xac>
811360a4:	323ff836 	bltu	r6,r8,81136088 <__reset+0xfb116088>
811360a8:	4180022e 	bgeu	r8,r6,811360b4 <__gesf2+0xb4>
811360ac:	203fef1e 	bne	r4,zero,8113606c <__reset+0xfb11606c>
811360b0:	003ff606 	br	8113608c <__reset+0xfb11608c>
811360b4:	0005883a 	mov	r2,zero
811360b8:	f800283a 	ret

811360bc <__lesf2>:
811360bc:	2004d5fa 	srli	r2,r4,23
811360c0:	280cd5fa 	srli	r6,r5,23
811360c4:	00c02034 	movhi	r3,128
811360c8:	18ffffc4 	addi	r3,r3,-1
811360cc:	10803fcc 	andi	r2,r2,255
811360d0:	01c03fc4 	movi	r7,255
811360d4:	1910703a 	and	r8,r3,r4
811360d8:	31803fcc 	andi	r6,r6,255
811360dc:	1946703a 	and	r3,r3,r5
811360e0:	2008d7fa 	srli	r4,r4,31
811360e4:	280ad7fa 	srli	r5,r5,31
811360e8:	11c01b26 	beq	r2,r7,81136158 <__lesf2+0x9c>
811360ec:	01c03fc4 	movi	r7,255
811360f0:	31c01126 	beq	r6,r7,81136138 <__lesf2+0x7c>
811360f4:	1000071e 	bne	r2,zero,81136114 <__lesf2+0x58>
811360f8:	400f003a 	cmpeq	r7,r8,zero
811360fc:	21003fcc 	andi	r4,r4,255
81136100:	3000081e 	bne	r6,zero,81136124 <__lesf2+0x68>
81136104:	1800071e 	bne	r3,zero,81136124 <__lesf2+0x68>
81136108:	0005883a 	mov	r2,zero
8113610c:	40000f1e 	bne	r8,zero,8113614c <__lesf2+0x90>
81136110:	f800283a 	ret
81136114:	21003fcc 	andi	r4,r4,255
81136118:	30000a1e 	bne	r6,zero,81136144 <__lesf2+0x88>
8113611c:	18000b26 	beq	r3,zero,8113614c <__lesf2+0x90>
81136120:	000f883a 	mov	r7,zero
81136124:	29403fcc 	andi	r5,r5,255
81136128:	38000726 	beq	r7,zero,81136148 <__lesf2+0x8c>
8113612c:	28000826 	beq	r5,zero,81136150 <__lesf2+0x94>
81136130:	00800044 	movi	r2,1
81136134:	f800283a 	ret
81136138:	183fee26 	beq	r3,zero,811360f4 <__reset+0xfb1160f4>
8113613c:	00800084 	movi	r2,2
81136140:	f800283a 	ret
81136144:	29403fcc 	andi	r5,r5,255
81136148:	21400626 	beq	r4,r5,81136164 <__lesf2+0xa8>
8113614c:	203ff826 	beq	r4,zero,81136130 <__reset+0xfb116130>
81136150:	00bfffc4 	movi	r2,-1
81136154:	f800283a 	ret
81136158:	403fe426 	beq	r8,zero,811360ec <__reset+0xfb1160ec>
8113615c:	00800084 	movi	r2,2
81136160:	f800283a 	ret
81136164:	30bff916 	blt	r6,r2,8113614c <__reset+0xfb11614c>
81136168:	11800216 	blt	r2,r6,81136174 <__lesf2+0xb8>
8113616c:	1a3ff736 	bltu	r3,r8,8113614c <__reset+0xfb11614c>
81136170:	40c0022e 	bgeu	r8,r3,8113617c <__lesf2+0xc0>
81136174:	203fee1e 	bne	r4,zero,81136130 <__reset+0xfb116130>
81136178:	003ff506 	br	81136150 <__reset+0xfb116150>
8113617c:	0005883a 	mov	r2,zero
81136180:	f800283a 	ret

81136184 <__adddf3>:
81136184:	02c00434 	movhi	r11,16
81136188:	5affffc4 	addi	r11,r11,-1
8113618c:	2806d7fa 	srli	r3,r5,31
81136190:	2ad4703a 	and	r10,r5,r11
81136194:	3ad2703a 	and	r9,r7,r11
81136198:	3804d53a 	srli	r2,r7,20
8113619c:	3018d77a 	srli	r12,r6,29
811361a0:	280ad53a 	srli	r5,r5,20
811361a4:	501490fa 	slli	r10,r10,3
811361a8:	2010d77a 	srli	r8,r4,29
811361ac:	481290fa 	slli	r9,r9,3
811361b0:	380ed7fa 	srli	r7,r7,31
811361b4:	defffb04 	addi	sp,sp,-20
811361b8:	de00012e 	bgeu	sp,et,811361c0 <__adddf3+0x3c>
811361bc:	003b68fa 	trap	3
811361c0:	dc800215 	stw	r18,8(sp)
811361c4:	dc400115 	stw	r17,4(sp)
811361c8:	dc000015 	stw	r16,0(sp)
811361cc:	dfc00415 	stw	ra,16(sp)
811361d0:	dcc00315 	stw	r19,12(sp)
811361d4:	1c803fcc 	andi	r18,r3,255
811361d8:	2c01ffcc 	andi	r16,r5,2047
811361dc:	5210b03a 	or	r8,r10,r8
811361e0:	202290fa 	slli	r17,r4,3
811361e4:	1081ffcc 	andi	r2,r2,2047
811361e8:	4b12b03a 	or	r9,r9,r12
811361ec:	300c90fa 	slli	r6,r6,3
811361f0:	91c07526 	beq	r18,r7,811363c8 <__adddf3+0x244>
811361f4:	8087c83a 	sub	r3,r16,r2
811361f8:	00c0ab0e 	bge	zero,r3,811364a8 <__adddf3+0x324>
811361fc:	10002a1e 	bne	r2,zero,811362a8 <__adddf3+0x124>
81136200:	4984b03a 	or	r2,r9,r6
81136204:	1000961e 	bne	r2,zero,81136460 <__adddf3+0x2dc>
81136208:	888001cc 	andi	r2,r17,7
8113620c:	10000726 	beq	r2,zero,8113622c <__adddf3+0xa8>
81136210:	888003cc 	andi	r2,r17,15
81136214:	00c00104 	movi	r3,4
81136218:	10c00426 	beq	r2,r3,8113622c <__adddf3+0xa8>
8113621c:	88c7883a 	add	r3,r17,r3
81136220:	1c63803a 	cmpltu	r17,r3,r17
81136224:	4451883a 	add	r8,r8,r17
81136228:	1823883a 	mov	r17,r3
8113622c:	4080202c 	andhi	r2,r8,128
81136230:	10005926 	beq	r2,zero,81136398 <__adddf3+0x214>
81136234:	84000044 	addi	r16,r16,1
81136238:	0081ffc4 	movi	r2,2047
8113623c:	8080ba26 	beq	r16,r2,81136528 <__adddf3+0x3a4>
81136240:	00bfe034 	movhi	r2,65408
81136244:	10bfffc4 	addi	r2,r2,-1
81136248:	4090703a 	and	r8,r8,r2
8113624c:	4004977a 	slli	r2,r8,29
81136250:	4010927a 	slli	r8,r8,9
81136254:	8822d0fa 	srli	r17,r17,3
81136258:	8401ffcc 	andi	r16,r16,2047
8113625c:	4010d33a 	srli	r8,r8,12
81136260:	9007883a 	mov	r3,r18
81136264:	1444b03a 	or	r2,r2,r17
81136268:	8401ffcc 	andi	r16,r16,2047
8113626c:	8020953a 	slli	r16,r16,20
81136270:	18c03fcc 	andi	r3,r3,255
81136274:	01000434 	movhi	r4,16
81136278:	213fffc4 	addi	r4,r4,-1
8113627c:	180697fa 	slli	r3,r3,31
81136280:	4110703a 	and	r8,r8,r4
81136284:	4410b03a 	or	r8,r8,r16
81136288:	40c6b03a 	or	r3,r8,r3
8113628c:	dfc00417 	ldw	ra,16(sp)
81136290:	dcc00317 	ldw	r19,12(sp)
81136294:	dc800217 	ldw	r18,8(sp)
81136298:	dc400117 	ldw	r17,4(sp)
8113629c:	dc000017 	ldw	r16,0(sp)
811362a0:	dec00504 	addi	sp,sp,20
811362a4:	f800283a 	ret
811362a8:	0081ffc4 	movi	r2,2047
811362ac:	80bfd626 	beq	r16,r2,81136208 <__reset+0xfb116208>
811362b0:	4a402034 	orhi	r9,r9,128
811362b4:	00800e04 	movi	r2,56
811362b8:	10c09f16 	blt	r2,r3,81136538 <__adddf3+0x3b4>
811362bc:	008007c4 	movi	r2,31
811362c0:	10c0c216 	blt	r2,r3,811365cc <__adddf3+0x448>
811362c4:	00800804 	movi	r2,32
811362c8:	10c5c83a 	sub	r2,r2,r3
811362cc:	488a983a 	sll	r5,r9,r2
811362d0:	30c8d83a 	srl	r4,r6,r3
811362d4:	3084983a 	sll	r2,r6,r2
811362d8:	48c6d83a 	srl	r3,r9,r3
811362dc:	290cb03a 	or	r6,r5,r4
811362e0:	1004c03a 	cmpne	r2,r2,zero
811362e4:	308cb03a 	or	r6,r6,r2
811362e8:	898dc83a 	sub	r6,r17,r6
811362ec:	89a3803a 	cmpltu	r17,r17,r6
811362f0:	40d1c83a 	sub	r8,r8,r3
811362f4:	4451c83a 	sub	r8,r8,r17
811362f8:	3023883a 	mov	r17,r6
811362fc:	4080202c 	andhi	r2,r8,128
81136300:	10002326 	beq	r2,zero,81136390 <__adddf3+0x20c>
81136304:	04c02034 	movhi	r19,128
81136308:	9cffffc4 	addi	r19,r19,-1
8113630c:	44e6703a 	and	r19,r8,r19
81136310:	98007626 	beq	r19,zero,811364ec <__adddf3+0x368>
81136314:	9809883a 	mov	r4,r19
81136318:	112276c0 	call	8112276c <__clzsi2>
8113631c:	10fffe04 	addi	r3,r2,-8
81136320:	010007c4 	movi	r4,31
81136324:	20c07716 	blt	r4,r3,81136504 <__adddf3+0x380>
81136328:	00800804 	movi	r2,32
8113632c:	10c5c83a 	sub	r2,r2,r3
81136330:	8884d83a 	srl	r2,r17,r2
81136334:	98d0983a 	sll	r8,r19,r3
81136338:	88e2983a 	sll	r17,r17,r3
8113633c:	1204b03a 	or	r2,r2,r8
81136340:	1c007416 	blt	r3,r16,81136514 <__adddf3+0x390>
81136344:	1c21c83a 	sub	r16,r3,r16
81136348:	82000044 	addi	r8,r16,1
8113634c:	00c007c4 	movi	r3,31
81136350:	1a009116 	blt	r3,r8,81136598 <__adddf3+0x414>
81136354:	00c00804 	movi	r3,32
81136358:	1a07c83a 	sub	r3,r3,r8
8113635c:	8a08d83a 	srl	r4,r17,r8
81136360:	88e2983a 	sll	r17,r17,r3
81136364:	10c6983a 	sll	r3,r2,r3
81136368:	1210d83a 	srl	r8,r2,r8
8113636c:	8804c03a 	cmpne	r2,r17,zero
81136370:	1906b03a 	or	r3,r3,r4
81136374:	18a2b03a 	or	r17,r3,r2
81136378:	0021883a 	mov	r16,zero
8113637c:	003fa206 	br	81136208 <__reset+0xfb116208>
81136380:	1890b03a 	or	r8,r3,r2
81136384:	40017d26 	beq	r8,zero,8113697c <__adddf3+0x7f8>
81136388:	1011883a 	mov	r8,r2
8113638c:	1823883a 	mov	r17,r3
81136390:	888001cc 	andi	r2,r17,7
81136394:	103f9e1e 	bne	r2,zero,81136210 <__reset+0xfb116210>
81136398:	4004977a 	slli	r2,r8,29
8113639c:	8822d0fa 	srli	r17,r17,3
811363a0:	4010d0fa 	srli	r8,r8,3
811363a4:	9007883a 	mov	r3,r18
811363a8:	1444b03a 	or	r2,r2,r17
811363ac:	0101ffc4 	movi	r4,2047
811363b0:	81002426 	beq	r16,r4,81136444 <__adddf3+0x2c0>
811363b4:	8120703a 	and	r16,r16,r4
811363b8:	01000434 	movhi	r4,16
811363bc:	213fffc4 	addi	r4,r4,-1
811363c0:	4110703a 	and	r8,r8,r4
811363c4:	003fa806 	br	81136268 <__reset+0xfb116268>
811363c8:	8089c83a 	sub	r4,r16,r2
811363cc:	01005e0e 	bge	zero,r4,81136548 <__adddf3+0x3c4>
811363d0:	10002b26 	beq	r2,zero,81136480 <__adddf3+0x2fc>
811363d4:	0081ffc4 	movi	r2,2047
811363d8:	80bf8b26 	beq	r16,r2,81136208 <__reset+0xfb116208>
811363dc:	4a402034 	orhi	r9,r9,128
811363e0:	00800e04 	movi	r2,56
811363e4:	1100a40e 	bge	r2,r4,81136678 <__adddf3+0x4f4>
811363e8:	498cb03a 	or	r6,r9,r6
811363ec:	300ac03a 	cmpne	r5,r6,zero
811363f0:	0013883a 	mov	r9,zero
811363f4:	2c4b883a 	add	r5,r5,r17
811363f8:	2c63803a 	cmpltu	r17,r5,r17
811363fc:	4a11883a 	add	r8,r9,r8
81136400:	8a11883a 	add	r8,r17,r8
81136404:	2823883a 	mov	r17,r5
81136408:	4080202c 	andhi	r2,r8,128
8113640c:	103fe026 	beq	r2,zero,81136390 <__reset+0xfb116390>
81136410:	84000044 	addi	r16,r16,1
81136414:	0081ffc4 	movi	r2,2047
81136418:	8080d226 	beq	r16,r2,81136764 <__adddf3+0x5e0>
8113641c:	00bfe034 	movhi	r2,65408
81136420:	10bfffc4 	addi	r2,r2,-1
81136424:	4090703a 	and	r8,r8,r2
81136428:	880ad07a 	srli	r5,r17,1
8113642c:	400897fa 	slli	r4,r8,31
81136430:	88c0004c 	andi	r3,r17,1
81136434:	28e2b03a 	or	r17,r5,r3
81136438:	4010d07a 	srli	r8,r8,1
8113643c:	2462b03a 	or	r17,r4,r17
81136440:	003f7106 	br	81136208 <__reset+0xfb116208>
81136444:	4088b03a 	or	r4,r8,r2
81136448:	20014526 	beq	r4,zero,81136960 <__adddf3+0x7dc>
8113644c:	01000434 	movhi	r4,16
81136450:	42000234 	orhi	r8,r8,8
81136454:	213fffc4 	addi	r4,r4,-1
81136458:	4110703a 	and	r8,r8,r4
8113645c:	003f8206 	br	81136268 <__reset+0xfb116268>
81136460:	18ffffc4 	addi	r3,r3,-1
81136464:	1800491e 	bne	r3,zero,8113658c <__adddf3+0x408>
81136468:	898bc83a 	sub	r5,r17,r6
8113646c:	8963803a 	cmpltu	r17,r17,r5
81136470:	4251c83a 	sub	r8,r8,r9
81136474:	4451c83a 	sub	r8,r8,r17
81136478:	2823883a 	mov	r17,r5
8113647c:	003f9f06 	br	811362fc <__reset+0xfb1162fc>
81136480:	4984b03a 	or	r2,r9,r6
81136484:	103f6026 	beq	r2,zero,81136208 <__reset+0xfb116208>
81136488:	213fffc4 	addi	r4,r4,-1
8113648c:	2000931e 	bne	r4,zero,811366dc <__adddf3+0x558>
81136490:	898d883a 	add	r6,r17,r6
81136494:	3463803a 	cmpltu	r17,r6,r17
81136498:	4251883a 	add	r8,r8,r9
8113649c:	8a11883a 	add	r8,r17,r8
811364a0:	3023883a 	mov	r17,r6
811364a4:	003fd806 	br	81136408 <__reset+0xfb116408>
811364a8:	1800541e 	bne	r3,zero,811365fc <__adddf3+0x478>
811364ac:	80800044 	addi	r2,r16,1
811364b0:	1081ffcc 	andi	r2,r2,2047
811364b4:	00c00044 	movi	r3,1
811364b8:	1880a00e 	bge	r3,r2,8113673c <__adddf3+0x5b8>
811364bc:	8989c83a 	sub	r4,r17,r6
811364c0:	8905803a 	cmpltu	r2,r17,r4
811364c4:	4267c83a 	sub	r19,r8,r9
811364c8:	98a7c83a 	sub	r19,r19,r2
811364cc:	9880202c 	andhi	r2,r19,128
811364d0:	10006326 	beq	r2,zero,81136660 <__adddf3+0x4dc>
811364d4:	3463c83a 	sub	r17,r6,r17
811364d8:	4a07c83a 	sub	r3,r9,r8
811364dc:	344d803a 	cmpltu	r6,r6,r17
811364e0:	19a7c83a 	sub	r19,r3,r6
811364e4:	3825883a 	mov	r18,r7
811364e8:	983f8a1e 	bne	r19,zero,81136314 <__reset+0xfb116314>
811364ec:	8809883a 	mov	r4,r17
811364f0:	112276c0 	call	8112276c <__clzsi2>
811364f4:	10800804 	addi	r2,r2,32
811364f8:	10fffe04 	addi	r3,r2,-8
811364fc:	010007c4 	movi	r4,31
81136500:	20ff890e 	bge	r4,r3,81136328 <__reset+0xfb116328>
81136504:	10bff604 	addi	r2,r2,-40
81136508:	8884983a 	sll	r2,r17,r2
8113650c:	0023883a 	mov	r17,zero
81136510:	1c3f8c0e 	bge	r3,r16,81136344 <__reset+0xfb116344>
81136514:	023fe034 	movhi	r8,65408
81136518:	423fffc4 	addi	r8,r8,-1
8113651c:	80e1c83a 	sub	r16,r16,r3
81136520:	1210703a 	and	r8,r2,r8
81136524:	003f3806 	br	81136208 <__reset+0xfb116208>
81136528:	9007883a 	mov	r3,r18
8113652c:	0011883a 	mov	r8,zero
81136530:	0005883a 	mov	r2,zero
81136534:	003f4c06 	br	81136268 <__reset+0xfb116268>
81136538:	498cb03a 	or	r6,r9,r6
8113653c:	300cc03a 	cmpne	r6,r6,zero
81136540:	0007883a 	mov	r3,zero
81136544:	003f6806 	br	811362e8 <__reset+0xfb1162e8>
81136548:	20009c1e 	bne	r4,zero,811367bc <__adddf3+0x638>
8113654c:	80800044 	addi	r2,r16,1
81136550:	1141ffcc 	andi	r5,r2,2047
81136554:	01000044 	movi	r4,1
81136558:	2140670e 	bge	r4,r5,811366f8 <__adddf3+0x574>
8113655c:	0101ffc4 	movi	r4,2047
81136560:	11007f26 	beq	r2,r4,81136760 <__adddf3+0x5dc>
81136564:	898d883a 	add	r6,r17,r6
81136568:	4247883a 	add	r3,r8,r9
8113656c:	3451803a 	cmpltu	r8,r6,r17
81136570:	40d1883a 	add	r8,r8,r3
81136574:	402297fa 	slli	r17,r8,31
81136578:	300cd07a 	srli	r6,r6,1
8113657c:	4010d07a 	srli	r8,r8,1
81136580:	1021883a 	mov	r16,r2
81136584:	89a2b03a 	or	r17,r17,r6
81136588:	003f1f06 	br	81136208 <__reset+0xfb116208>
8113658c:	0081ffc4 	movi	r2,2047
81136590:	80bf481e 	bne	r16,r2,811362b4 <__reset+0xfb1162b4>
81136594:	003f1c06 	br	81136208 <__reset+0xfb116208>
81136598:	843ff844 	addi	r16,r16,-31
8113659c:	01000804 	movi	r4,32
811365a0:	1406d83a 	srl	r3,r2,r16
811365a4:	41005026 	beq	r8,r4,811366e8 <__adddf3+0x564>
811365a8:	01001004 	movi	r4,64
811365ac:	2211c83a 	sub	r8,r4,r8
811365b0:	1204983a 	sll	r2,r2,r8
811365b4:	88a2b03a 	or	r17,r17,r2
811365b8:	8822c03a 	cmpne	r17,r17,zero
811365bc:	1c62b03a 	or	r17,r3,r17
811365c0:	0011883a 	mov	r8,zero
811365c4:	0021883a 	mov	r16,zero
811365c8:	003f7106 	br	81136390 <__reset+0xfb116390>
811365cc:	193ff804 	addi	r4,r3,-32
811365d0:	00800804 	movi	r2,32
811365d4:	4908d83a 	srl	r4,r9,r4
811365d8:	18804526 	beq	r3,r2,811366f0 <__adddf3+0x56c>
811365dc:	00801004 	movi	r2,64
811365e0:	10c5c83a 	sub	r2,r2,r3
811365e4:	4886983a 	sll	r3,r9,r2
811365e8:	198cb03a 	or	r6,r3,r6
811365ec:	300cc03a 	cmpne	r6,r6,zero
811365f0:	218cb03a 	or	r6,r4,r6
811365f4:	0007883a 	mov	r3,zero
811365f8:	003f3b06 	br	811362e8 <__reset+0xfb1162e8>
811365fc:	80002a26 	beq	r16,zero,811366a8 <__adddf3+0x524>
81136600:	0101ffc4 	movi	r4,2047
81136604:	11006826 	beq	r2,r4,811367a8 <__adddf3+0x624>
81136608:	00c7c83a 	sub	r3,zero,r3
8113660c:	42002034 	orhi	r8,r8,128
81136610:	01000e04 	movi	r4,56
81136614:	20c07c16 	blt	r4,r3,81136808 <__adddf3+0x684>
81136618:	010007c4 	movi	r4,31
8113661c:	20c0da16 	blt	r4,r3,81136988 <__adddf3+0x804>
81136620:	01000804 	movi	r4,32
81136624:	20c9c83a 	sub	r4,r4,r3
81136628:	4114983a 	sll	r10,r8,r4
8113662c:	88cad83a 	srl	r5,r17,r3
81136630:	8908983a 	sll	r4,r17,r4
81136634:	40c6d83a 	srl	r3,r8,r3
81136638:	5162b03a 	or	r17,r10,r5
8113663c:	2008c03a 	cmpne	r4,r4,zero
81136640:	8922b03a 	or	r17,r17,r4
81136644:	3463c83a 	sub	r17,r6,r17
81136648:	48c7c83a 	sub	r3,r9,r3
8113664c:	344d803a 	cmpltu	r6,r6,r17
81136650:	1991c83a 	sub	r8,r3,r6
81136654:	1021883a 	mov	r16,r2
81136658:	3825883a 	mov	r18,r7
8113665c:	003f2706 	br	811362fc <__reset+0xfb1162fc>
81136660:	24d0b03a 	or	r8,r4,r19
81136664:	40001b1e 	bne	r8,zero,811366d4 <__adddf3+0x550>
81136668:	0005883a 	mov	r2,zero
8113666c:	0007883a 	mov	r3,zero
81136670:	0021883a 	mov	r16,zero
81136674:	003f4d06 	br	811363ac <__reset+0xfb1163ac>
81136678:	008007c4 	movi	r2,31
8113667c:	11003c16 	blt	r2,r4,81136770 <__adddf3+0x5ec>
81136680:	00800804 	movi	r2,32
81136684:	1105c83a 	sub	r2,r2,r4
81136688:	488e983a 	sll	r7,r9,r2
8113668c:	310ad83a 	srl	r5,r6,r4
81136690:	3084983a 	sll	r2,r6,r2
81136694:	4912d83a 	srl	r9,r9,r4
81136698:	394ab03a 	or	r5,r7,r5
8113669c:	1004c03a 	cmpne	r2,r2,zero
811366a0:	288ab03a 	or	r5,r5,r2
811366a4:	003f5306 	br	811363f4 <__reset+0xfb1163f4>
811366a8:	4448b03a 	or	r4,r8,r17
811366ac:	20003e26 	beq	r4,zero,811367a8 <__adddf3+0x624>
811366b0:	00c6303a 	nor	r3,zero,r3
811366b4:	18003a1e 	bne	r3,zero,811367a0 <__adddf3+0x61c>
811366b8:	3463c83a 	sub	r17,r6,r17
811366bc:	4a07c83a 	sub	r3,r9,r8
811366c0:	344d803a 	cmpltu	r6,r6,r17
811366c4:	1991c83a 	sub	r8,r3,r6
811366c8:	1021883a 	mov	r16,r2
811366cc:	3825883a 	mov	r18,r7
811366d0:	003f0a06 	br	811362fc <__reset+0xfb1162fc>
811366d4:	2023883a 	mov	r17,r4
811366d8:	003f0d06 	br	81136310 <__reset+0xfb116310>
811366dc:	0081ffc4 	movi	r2,2047
811366e0:	80bf3f1e 	bne	r16,r2,811363e0 <__reset+0xfb1163e0>
811366e4:	003ec806 	br	81136208 <__reset+0xfb116208>
811366e8:	0005883a 	mov	r2,zero
811366ec:	003fb106 	br	811365b4 <__reset+0xfb1165b4>
811366f0:	0007883a 	mov	r3,zero
811366f4:	003fbc06 	br	811365e8 <__reset+0xfb1165e8>
811366f8:	4444b03a 	or	r2,r8,r17
811366fc:	8000871e 	bne	r16,zero,8113691c <__adddf3+0x798>
81136700:	1000ba26 	beq	r2,zero,811369ec <__adddf3+0x868>
81136704:	4984b03a 	or	r2,r9,r6
81136708:	103ebf26 	beq	r2,zero,81136208 <__reset+0xfb116208>
8113670c:	8985883a 	add	r2,r17,r6
81136710:	4247883a 	add	r3,r8,r9
81136714:	1451803a 	cmpltu	r8,r2,r17
81136718:	40d1883a 	add	r8,r8,r3
8113671c:	40c0202c 	andhi	r3,r8,128
81136720:	1023883a 	mov	r17,r2
81136724:	183f1a26 	beq	r3,zero,81136390 <__reset+0xfb116390>
81136728:	00bfe034 	movhi	r2,65408
8113672c:	10bfffc4 	addi	r2,r2,-1
81136730:	2021883a 	mov	r16,r4
81136734:	4090703a 	and	r8,r8,r2
81136738:	003eb306 	br	81136208 <__reset+0xfb116208>
8113673c:	4444b03a 	or	r2,r8,r17
81136740:	8000291e 	bne	r16,zero,811367e8 <__adddf3+0x664>
81136744:	10004b1e 	bne	r2,zero,81136874 <__adddf3+0x6f0>
81136748:	4990b03a 	or	r8,r9,r6
8113674c:	40008b26 	beq	r8,zero,8113697c <__adddf3+0x7f8>
81136750:	4811883a 	mov	r8,r9
81136754:	3023883a 	mov	r17,r6
81136758:	3825883a 	mov	r18,r7
8113675c:	003eaa06 	br	81136208 <__reset+0xfb116208>
81136760:	1021883a 	mov	r16,r2
81136764:	0011883a 	mov	r8,zero
81136768:	0005883a 	mov	r2,zero
8113676c:	003f0f06 	br	811363ac <__reset+0xfb1163ac>
81136770:	217ff804 	addi	r5,r4,-32
81136774:	00800804 	movi	r2,32
81136778:	494ad83a 	srl	r5,r9,r5
8113677c:	20807d26 	beq	r4,r2,81136974 <__adddf3+0x7f0>
81136780:	00801004 	movi	r2,64
81136784:	1109c83a 	sub	r4,r2,r4
81136788:	4912983a 	sll	r9,r9,r4
8113678c:	498cb03a 	or	r6,r9,r6
81136790:	300cc03a 	cmpne	r6,r6,zero
81136794:	298ab03a 	or	r5,r5,r6
81136798:	0013883a 	mov	r9,zero
8113679c:	003f1506 	br	811363f4 <__reset+0xfb1163f4>
811367a0:	0101ffc4 	movi	r4,2047
811367a4:	113f9a1e 	bne	r2,r4,81136610 <__reset+0xfb116610>
811367a8:	4811883a 	mov	r8,r9
811367ac:	3023883a 	mov	r17,r6
811367b0:	1021883a 	mov	r16,r2
811367b4:	3825883a 	mov	r18,r7
811367b8:	003e9306 	br	81136208 <__reset+0xfb116208>
811367bc:	8000161e 	bne	r16,zero,81136818 <__adddf3+0x694>
811367c0:	444ab03a 	or	r5,r8,r17
811367c4:	28005126 	beq	r5,zero,8113690c <__adddf3+0x788>
811367c8:	0108303a 	nor	r4,zero,r4
811367cc:	20004d1e 	bne	r4,zero,81136904 <__adddf3+0x780>
811367d0:	89a3883a 	add	r17,r17,r6
811367d4:	4253883a 	add	r9,r8,r9
811367d8:	898d803a 	cmpltu	r6,r17,r6
811367dc:	3251883a 	add	r8,r6,r9
811367e0:	1021883a 	mov	r16,r2
811367e4:	003f0806 	br	81136408 <__reset+0xfb116408>
811367e8:	1000301e 	bne	r2,zero,811368ac <__adddf3+0x728>
811367ec:	4984b03a 	or	r2,r9,r6
811367f0:	10007126 	beq	r2,zero,811369b8 <__adddf3+0x834>
811367f4:	4811883a 	mov	r8,r9
811367f8:	3023883a 	mov	r17,r6
811367fc:	3825883a 	mov	r18,r7
81136800:	0401ffc4 	movi	r16,2047
81136804:	003e8006 	br	81136208 <__reset+0xfb116208>
81136808:	4462b03a 	or	r17,r8,r17
8113680c:	8822c03a 	cmpne	r17,r17,zero
81136810:	0007883a 	mov	r3,zero
81136814:	003f8b06 	br	81136644 <__reset+0xfb116644>
81136818:	0141ffc4 	movi	r5,2047
8113681c:	11403b26 	beq	r2,r5,8113690c <__adddf3+0x788>
81136820:	0109c83a 	sub	r4,zero,r4
81136824:	42002034 	orhi	r8,r8,128
81136828:	01400e04 	movi	r5,56
8113682c:	29006716 	blt	r5,r4,811369cc <__adddf3+0x848>
81136830:	014007c4 	movi	r5,31
81136834:	29007016 	blt	r5,r4,811369f8 <__adddf3+0x874>
81136838:	01400804 	movi	r5,32
8113683c:	290bc83a 	sub	r5,r5,r4
81136840:	4154983a 	sll	r10,r8,r5
81136844:	890ed83a 	srl	r7,r17,r4
81136848:	894a983a 	sll	r5,r17,r5
8113684c:	4108d83a 	srl	r4,r8,r4
81136850:	51e2b03a 	or	r17,r10,r7
81136854:	280ac03a 	cmpne	r5,r5,zero
81136858:	8962b03a 	or	r17,r17,r5
8113685c:	89a3883a 	add	r17,r17,r6
81136860:	2253883a 	add	r9,r4,r9
81136864:	898d803a 	cmpltu	r6,r17,r6
81136868:	3251883a 	add	r8,r6,r9
8113686c:	1021883a 	mov	r16,r2
81136870:	003ee506 	br	81136408 <__reset+0xfb116408>
81136874:	4984b03a 	or	r2,r9,r6
81136878:	103e6326 	beq	r2,zero,81136208 <__reset+0xfb116208>
8113687c:	8987c83a 	sub	r3,r17,r6
81136880:	88c9803a 	cmpltu	r4,r17,r3
81136884:	4245c83a 	sub	r2,r8,r9
81136888:	1105c83a 	sub	r2,r2,r4
8113688c:	1100202c 	andhi	r4,r2,128
81136890:	203ebb26 	beq	r4,zero,81136380 <__reset+0xfb116380>
81136894:	3463c83a 	sub	r17,r6,r17
81136898:	4a07c83a 	sub	r3,r9,r8
8113689c:	344d803a 	cmpltu	r6,r6,r17
811368a0:	1991c83a 	sub	r8,r3,r6
811368a4:	3825883a 	mov	r18,r7
811368a8:	003e5706 	br	81136208 <__reset+0xfb116208>
811368ac:	4984b03a 	or	r2,r9,r6
811368b0:	10002e26 	beq	r2,zero,8113696c <__adddf3+0x7e8>
811368b4:	4004d0fa 	srli	r2,r8,3
811368b8:	8822d0fa 	srli	r17,r17,3
811368bc:	4010977a 	slli	r8,r8,29
811368c0:	10c0022c 	andhi	r3,r2,8
811368c4:	4462b03a 	or	r17,r8,r17
811368c8:	18000826 	beq	r3,zero,811368ec <__adddf3+0x768>
811368cc:	4808d0fa 	srli	r4,r9,3
811368d0:	20c0022c 	andhi	r3,r4,8
811368d4:	1800051e 	bne	r3,zero,811368ec <__adddf3+0x768>
811368d8:	300cd0fa 	srli	r6,r6,3
811368dc:	4806977a 	slli	r3,r9,29
811368e0:	2005883a 	mov	r2,r4
811368e4:	3825883a 	mov	r18,r7
811368e8:	19a2b03a 	or	r17,r3,r6
811368ec:	8810d77a 	srli	r8,r17,29
811368f0:	100490fa 	slli	r2,r2,3
811368f4:	882290fa 	slli	r17,r17,3
811368f8:	0401ffc4 	movi	r16,2047
811368fc:	4090b03a 	or	r8,r8,r2
81136900:	003e4106 	br	81136208 <__reset+0xfb116208>
81136904:	0141ffc4 	movi	r5,2047
81136908:	117fc71e 	bne	r2,r5,81136828 <__reset+0xfb116828>
8113690c:	4811883a 	mov	r8,r9
81136910:	3023883a 	mov	r17,r6
81136914:	1021883a 	mov	r16,r2
81136918:	003e3b06 	br	81136208 <__reset+0xfb116208>
8113691c:	10002f26 	beq	r2,zero,811369dc <__adddf3+0x858>
81136920:	4984b03a 	or	r2,r9,r6
81136924:	10001126 	beq	r2,zero,8113696c <__adddf3+0x7e8>
81136928:	4004d0fa 	srli	r2,r8,3
8113692c:	8822d0fa 	srli	r17,r17,3
81136930:	4010977a 	slli	r8,r8,29
81136934:	10c0022c 	andhi	r3,r2,8
81136938:	4462b03a 	or	r17,r8,r17
8113693c:	183feb26 	beq	r3,zero,811368ec <__reset+0xfb1168ec>
81136940:	4808d0fa 	srli	r4,r9,3
81136944:	20c0022c 	andhi	r3,r4,8
81136948:	183fe81e 	bne	r3,zero,811368ec <__reset+0xfb1168ec>
8113694c:	300cd0fa 	srli	r6,r6,3
81136950:	4806977a 	slli	r3,r9,29
81136954:	2005883a 	mov	r2,r4
81136958:	19a2b03a 	or	r17,r3,r6
8113695c:	003fe306 	br	811368ec <__reset+0xfb1168ec>
81136960:	0011883a 	mov	r8,zero
81136964:	0005883a 	mov	r2,zero
81136968:	003e3f06 	br	81136268 <__reset+0xfb116268>
8113696c:	0401ffc4 	movi	r16,2047
81136970:	003e2506 	br	81136208 <__reset+0xfb116208>
81136974:	0013883a 	mov	r9,zero
81136978:	003f8406 	br	8113678c <__reset+0xfb11678c>
8113697c:	0005883a 	mov	r2,zero
81136980:	0007883a 	mov	r3,zero
81136984:	003e8906 	br	811363ac <__reset+0xfb1163ac>
81136988:	197ff804 	addi	r5,r3,-32
8113698c:	01000804 	movi	r4,32
81136990:	414ad83a 	srl	r5,r8,r5
81136994:	19002426 	beq	r3,r4,81136a28 <__adddf3+0x8a4>
81136998:	01001004 	movi	r4,64
8113699c:	20c7c83a 	sub	r3,r4,r3
811369a0:	40c6983a 	sll	r3,r8,r3
811369a4:	1c46b03a 	or	r3,r3,r17
811369a8:	1806c03a 	cmpne	r3,r3,zero
811369ac:	28e2b03a 	or	r17,r5,r3
811369b0:	0007883a 	mov	r3,zero
811369b4:	003f2306 	br	81136644 <__reset+0xfb116644>
811369b8:	0007883a 	mov	r3,zero
811369bc:	5811883a 	mov	r8,r11
811369c0:	00bfffc4 	movi	r2,-1
811369c4:	0401ffc4 	movi	r16,2047
811369c8:	003e7806 	br	811363ac <__reset+0xfb1163ac>
811369cc:	4462b03a 	or	r17,r8,r17
811369d0:	8822c03a 	cmpne	r17,r17,zero
811369d4:	0009883a 	mov	r4,zero
811369d8:	003fa006 	br	8113685c <__reset+0xfb11685c>
811369dc:	4811883a 	mov	r8,r9
811369e0:	3023883a 	mov	r17,r6
811369e4:	0401ffc4 	movi	r16,2047
811369e8:	003e0706 	br	81136208 <__reset+0xfb116208>
811369ec:	4811883a 	mov	r8,r9
811369f0:	3023883a 	mov	r17,r6
811369f4:	003e0406 	br	81136208 <__reset+0xfb116208>
811369f8:	21fff804 	addi	r7,r4,-32
811369fc:	01400804 	movi	r5,32
81136a00:	41ced83a 	srl	r7,r8,r7
81136a04:	21400a26 	beq	r4,r5,81136a30 <__adddf3+0x8ac>
81136a08:	01401004 	movi	r5,64
81136a0c:	2909c83a 	sub	r4,r5,r4
81136a10:	4108983a 	sll	r4,r8,r4
81136a14:	2448b03a 	or	r4,r4,r17
81136a18:	2008c03a 	cmpne	r4,r4,zero
81136a1c:	3922b03a 	or	r17,r7,r4
81136a20:	0009883a 	mov	r4,zero
81136a24:	003f8d06 	br	8113685c <__reset+0xfb11685c>
81136a28:	0007883a 	mov	r3,zero
81136a2c:	003fdd06 	br	811369a4 <__reset+0xfb1169a4>
81136a30:	0009883a 	mov	r4,zero
81136a34:	003ff706 	br	81136a14 <__reset+0xfb116a14>

81136a38 <__divdf3>:
81136a38:	defff204 	addi	sp,sp,-56
81136a3c:	de00012e 	bgeu	sp,et,81136a44 <__divdf3+0xc>
81136a40:	003b68fa 	trap	3
81136a44:	dd400915 	stw	r21,36(sp)
81136a48:	282ad53a 	srli	r21,r5,20
81136a4c:	dd000815 	stw	r20,32(sp)
81136a50:	2828d7fa 	srli	r20,r5,31
81136a54:	dc000415 	stw	r16,16(sp)
81136a58:	04000434 	movhi	r16,16
81136a5c:	df000c15 	stw	fp,48(sp)
81136a60:	843fffc4 	addi	r16,r16,-1
81136a64:	dfc00d15 	stw	ra,52(sp)
81136a68:	ddc00b15 	stw	r23,44(sp)
81136a6c:	dd800a15 	stw	r22,40(sp)
81136a70:	dcc00715 	stw	r19,28(sp)
81136a74:	dc800615 	stw	r18,24(sp)
81136a78:	dc400515 	stw	r17,20(sp)
81136a7c:	ad41ffcc 	andi	r21,r21,2047
81136a80:	2c20703a 	and	r16,r5,r16
81136a84:	a7003fcc 	andi	fp,r20,255
81136a88:	a8006126 	beq	r21,zero,81136c10 <__divdf3+0x1d8>
81136a8c:	0081ffc4 	movi	r2,2047
81136a90:	2025883a 	mov	r18,r4
81136a94:	a8803726 	beq	r21,r2,81136b74 <__divdf3+0x13c>
81136a98:	80800434 	orhi	r2,r16,16
81136a9c:	100490fa 	slli	r2,r2,3
81136aa0:	2020d77a 	srli	r16,r4,29
81136aa4:	202490fa 	slli	r18,r4,3
81136aa8:	ad7f0044 	addi	r21,r21,-1023
81136aac:	80a0b03a 	or	r16,r16,r2
81136ab0:	0027883a 	mov	r19,zero
81136ab4:	0013883a 	mov	r9,zero
81136ab8:	3804d53a 	srli	r2,r7,20
81136abc:	382cd7fa 	srli	r22,r7,31
81136ac0:	04400434 	movhi	r17,16
81136ac4:	8c7fffc4 	addi	r17,r17,-1
81136ac8:	1081ffcc 	andi	r2,r2,2047
81136acc:	3011883a 	mov	r8,r6
81136ad0:	3c62703a 	and	r17,r7,r17
81136ad4:	b5c03fcc 	andi	r23,r22,255
81136ad8:	10006c26 	beq	r2,zero,81136c8c <__divdf3+0x254>
81136adc:	00c1ffc4 	movi	r3,2047
81136ae0:	10c06426 	beq	r2,r3,81136c74 <__divdf3+0x23c>
81136ae4:	88c00434 	orhi	r3,r17,16
81136ae8:	180690fa 	slli	r3,r3,3
81136aec:	3022d77a 	srli	r17,r6,29
81136af0:	301090fa 	slli	r8,r6,3
81136af4:	10bf0044 	addi	r2,r2,-1023
81136af8:	88e2b03a 	or	r17,r17,r3
81136afc:	000f883a 	mov	r7,zero
81136b00:	a58cf03a 	xor	r6,r20,r22
81136b04:	3cc8b03a 	or	r4,r7,r19
81136b08:	a8abc83a 	sub	r21,r21,r2
81136b0c:	008003c4 	movi	r2,15
81136b10:	3007883a 	mov	r3,r6
81136b14:	34c03fcc 	andi	r19,r6,255
81136b18:	11009036 	bltu	r2,r4,81136d5c <__divdf3+0x324>
81136b1c:	200890ba 	slli	r4,r4,2
81136b20:	00a044f4 	movhi	r2,33043
81136b24:	109acd04 	addi	r2,r2,27444
81136b28:	2089883a 	add	r4,r4,r2
81136b2c:	20800017 	ldw	r2,0(r4)
81136b30:	1000683a 	jmp	r2
81136b34:	81136d5c 	xori	r4,r16,19893
81136b38:	81136bac 	andhi	r4,r16,19886
81136b3c:	81136d4c 	andi	r4,r16,19893
81136b40:	81136ba0 	cmpeqi	r4,r16,19886
81136b44:	81136d4c 	andi	r4,r16,19893
81136b48:	81136d20 	cmpeqi	r4,r16,19892
81136b4c:	81136d4c 	andi	r4,r16,19893
81136b50:	81136ba0 	cmpeqi	r4,r16,19886
81136b54:	81136bac 	andhi	r4,r16,19886
81136b58:	81136bac 	andhi	r4,r16,19886
81136b5c:	81136d20 	cmpeqi	r4,r16,19892
81136b60:	81136ba0 	cmpeqi	r4,r16,19886
81136b64:	81136b90 	cmplti	r4,r16,19886
81136b68:	81136b90 	cmplti	r4,r16,19886
81136b6c:	81136b90 	cmplti	r4,r16,19886
81136b70:	81137040 	call	88113704 <__reset+0x20f3704>
81136b74:	2404b03a 	or	r2,r4,r16
81136b78:	1000661e 	bne	r2,zero,81136d14 <__divdf3+0x2dc>
81136b7c:	04c00204 	movi	r19,8
81136b80:	0021883a 	mov	r16,zero
81136b84:	0025883a 	mov	r18,zero
81136b88:	02400084 	movi	r9,2
81136b8c:	003fca06 	br	81136ab8 <__reset+0xfb116ab8>
81136b90:	8023883a 	mov	r17,r16
81136b94:	9011883a 	mov	r8,r18
81136b98:	e02f883a 	mov	r23,fp
81136b9c:	480f883a 	mov	r7,r9
81136ba0:	00800084 	movi	r2,2
81136ba4:	3881311e 	bne	r7,r2,8113706c <__divdf3+0x634>
81136ba8:	b827883a 	mov	r19,r23
81136bac:	98c0004c 	andi	r3,r19,1
81136bb0:	0081ffc4 	movi	r2,2047
81136bb4:	000b883a 	mov	r5,zero
81136bb8:	0025883a 	mov	r18,zero
81136bbc:	1004953a 	slli	r2,r2,20
81136bc0:	18c03fcc 	andi	r3,r3,255
81136bc4:	04400434 	movhi	r17,16
81136bc8:	8c7fffc4 	addi	r17,r17,-1
81136bcc:	180697fa 	slli	r3,r3,31
81136bd0:	2c4a703a 	and	r5,r5,r17
81136bd4:	288ab03a 	or	r5,r5,r2
81136bd8:	28c6b03a 	or	r3,r5,r3
81136bdc:	9005883a 	mov	r2,r18
81136be0:	dfc00d17 	ldw	ra,52(sp)
81136be4:	df000c17 	ldw	fp,48(sp)
81136be8:	ddc00b17 	ldw	r23,44(sp)
81136bec:	dd800a17 	ldw	r22,40(sp)
81136bf0:	dd400917 	ldw	r21,36(sp)
81136bf4:	dd000817 	ldw	r20,32(sp)
81136bf8:	dcc00717 	ldw	r19,28(sp)
81136bfc:	dc800617 	ldw	r18,24(sp)
81136c00:	dc400517 	ldw	r17,20(sp)
81136c04:	dc000417 	ldw	r16,16(sp)
81136c08:	dec00e04 	addi	sp,sp,56
81136c0c:	f800283a 	ret
81136c10:	2404b03a 	or	r2,r4,r16
81136c14:	2027883a 	mov	r19,r4
81136c18:	10003926 	beq	r2,zero,81136d00 <__divdf3+0x2c8>
81136c1c:	80012e26 	beq	r16,zero,811370d8 <__divdf3+0x6a0>
81136c20:	8009883a 	mov	r4,r16
81136c24:	d9800315 	stw	r6,12(sp)
81136c28:	d9c00215 	stw	r7,8(sp)
81136c2c:	112276c0 	call	8112276c <__clzsi2>
81136c30:	d9800317 	ldw	r6,12(sp)
81136c34:	d9c00217 	ldw	r7,8(sp)
81136c38:	113ffd44 	addi	r4,r2,-11
81136c3c:	00c00704 	movi	r3,28
81136c40:	19012116 	blt	r3,r4,811370c8 <__divdf3+0x690>
81136c44:	00c00744 	movi	r3,29
81136c48:	147ffe04 	addi	r17,r2,-8
81136c4c:	1907c83a 	sub	r3,r3,r4
81136c50:	8460983a 	sll	r16,r16,r17
81136c54:	98c6d83a 	srl	r3,r19,r3
81136c58:	9c64983a 	sll	r18,r19,r17
81136c5c:	1c20b03a 	or	r16,r3,r16
81136c60:	1080fcc4 	addi	r2,r2,1011
81136c64:	00abc83a 	sub	r21,zero,r2
81136c68:	0027883a 	mov	r19,zero
81136c6c:	0013883a 	mov	r9,zero
81136c70:	003f9106 	br	81136ab8 <__reset+0xfb116ab8>
81136c74:	3446b03a 	or	r3,r6,r17
81136c78:	18001f1e 	bne	r3,zero,81136cf8 <__divdf3+0x2c0>
81136c7c:	0023883a 	mov	r17,zero
81136c80:	0011883a 	mov	r8,zero
81136c84:	01c00084 	movi	r7,2
81136c88:	003f9d06 	br	81136b00 <__reset+0xfb116b00>
81136c8c:	3446b03a 	or	r3,r6,r17
81136c90:	18001526 	beq	r3,zero,81136ce8 <__divdf3+0x2b0>
81136c94:	88011b26 	beq	r17,zero,81137104 <__divdf3+0x6cc>
81136c98:	8809883a 	mov	r4,r17
81136c9c:	d9800315 	stw	r6,12(sp)
81136ca0:	da400115 	stw	r9,4(sp)
81136ca4:	112276c0 	call	8112276c <__clzsi2>
81136ca8:	d9800317 	ldw	r6,12(sp)
81136cac:	da400117 	ldw	r9,4(sp)
81136cb0:	113ffd44 	addi	r4,r2,-11
81136cb4:	00c00704 	movi	r3,28
81136cb8:	19010e16 	blt	r3,r4,811370f4 <__divdf3+0x6bc>
81136cbc:	00c00744 	movi	r3,29
81136cc0:	123ffe04 	addi	r8,r2,-8
81136cc4:	1907c83a 	sub	r3,r3,r4
81136cc8:	8a22983a 	sll	r17,r17,r8
81136ccc:	30c6d83a 	srl	r3,r6,r3
81136cd0:	3210983a 	sll	r8,r6,r8
81136cd4:	1c62b03a 	or	r17,r3,r17
81136cd8:	1080fcc4 	addi	r2,r2,1011
81136cdc:	0085c83a 	sub	r2,zero,r2
81136ce0:	000f883a 	mov	r7,zero
81136ce4:	003f8606 	br	81136b00 <__reset+0xfb116b00>
81136ce8:	0023883a 	mov	r17,zero
81136cec:	0011883a 	mov	r8,zero
81136cf0:	01c00044 	movi	r7,1
81136cf4:	003f8206 	br	81136b00 <__reset+0xfb116b00>
81136cf8:	01c000c4 	movi	r7,3
81136cfc:	003f8006 	br	81136b00 <__reset+0xfb116b00>
81136d00:	04c00104 	movi	r19,4
81136d04:	0021883a 	mov	r16,zero
81136d08:	0025883a 	mov	r18,zero
81136d0c:	02400044 	movi	r9,1
81136d10:	003f6906 	br	81136ab8 <__reset+0xfb116ab8>
81136d14:	04c00304 	movi	r19,12
81136d18:	024000c4 	movi	r9,3
81136d1c:	003f6606 	br	81136ab8 <__reset+0xfb116ab8>
81136d20:	01400434 	movhi	r5,16
81136d24:	0007883a 	mov	r3,zero
81136d28:	297fffc4 	addi	r5,r5,-1
81136d2c:	04bfffc4 	movi	r18,-1
81136d30:	0081ffc4 	movi	r2,2047
81136d34:	003fa106 	br	81136bbc <__reset+0xfb116bbc>
81136d38:	00c00044 	movi	r3,1
81136d3c:	1887c83a 	sub	r3,r3,r2
81136d40:	01000e04 	movi	r4,56
81136d44:	20c1210e 	bge	r4,r3,811371cc <__divdf3+0x794>
81136d48:	98c0004c 	andi	r3,r19,1
81136d4c:	0005883a 	mov	r2,zero
81136d50:	000b883a 	mov	r5,zero
81136d54:	0025883a 	mov	r18,zero
81136d58:	003f9806 	br	81136bbc <__reset+0xfb116bbc>
81136d5c:	8c00fd36 	bltu	r17,r16,81137154 <__divdf3+0x71c>
81136d60:	8440fb26 	beq	r16,r17,81137150 <__divdf3+0x718>
81136d64:	8007883a 	mov	r3,r16
81136d68:	ad7fffc4 	addi	r21,r21,-1
81136d6c:	0021883a 	mov	r16,zero
81136d70:	4004d63a 	srli	r2,r8,24
81136d74:	8822923a 	slli	r17,r17,8
81136d78:	1809883a 	mov	r4,r3
81136d7c:	402c923a 	slli	r22,r8,8
81136d80:	88b8b03a 	or	fp,r17,r2
81136d84:	e028d43a 	srli	r20,fp,16
81136d88:	d8c00015 	stw	r3,0(sp)
81136d8c:	e5ffffcc 	andi	r23,fp,65535
81136d90:	a00b883a 	mov	r5,r20
81136d94:	1135ecc0 	call	81135ecc <__udivsi3>
81136d98:	d8c00017 	ldw	r3,0(sp)
81136d9c:	a00b883a 	mov	r5,r20
81136da0:	d8800315 	stw	r2,12(sp)
81136da4:	1809883a 	mov	r4,r3
81136da8:	1135f300 	call	81135f30 <__umodsi3>
81136dac:	d9800317 	ldw	r6,12(sp)
81136db0:	1006943a 	slli	r3,r2,16
81136db4:	9004d43a 	srli	r2,r18,16
81136db8:	b9a3383a 	mul	r17,r23,r6
81136dbc:	10c4b03a 	or	r2,r2,r3
81136dc0:	1440062e 	bgeu	r2,r17,81136ddc <__divdf3+0x3a4>
81136dc4:	1705883a 	add	r2,r2,fp
81136dc8:	30ffffc4 	addi	r3,r6,-1
81136dcc:	1700ee36 	bltu	r2,fp,81137188 <__divdf3+0x750>
81136dd0:	1440ed2e 	bgeu	r2,r17,81137188 <__divdf3+0x750>
81136dd4:	31bfff84 	addi	r6,r6,-2
81136dd8:	1705883a 	add	r2,r2,fp
81136ddc:	1463c83a 	sub	r17,r2,r17
81136de0:	a00b883a 	mov	r5,r20
81136de4:	8809883a 	mov	r4,r17
81136de8:	d9800315 	stw	r6,12(sp)
81136dec:	1135ecc0 	call	81135ecc <__udivsi3>
81136df0:	a00b883a 	mov	r5,r20
81136df4:	8809883a 	mov	r4,r17
81136df8:	d8800215 	stw	r2,8(sp)
81136dfc:	1135f300 	call	81135f30 <__umodsi3>
81136e00:	d9c00217 	ldw	r7,8(sp)
81136e04:	1004943a 	slli	r2,r2,16
81136e08:	94bfffcc 	andi	r18,r18,65535
81136e0c:	b9d1383a 	mul	r8,r23,r7
81136e10:	90a4b03a 	or	r18,r18,r2
81136e14:	d9800317 	ldw	r6,12(sp)
81136e18:	9200062e 	bgeu	r18,r8,81136e34 <__divdf3+0x3fc>
81136e1c:	9725883a 	add	r18,r18,fp
81136e20:	38bfffc4 	addi	r2,r7,-1
81136e24:	9700d636 	bltu	r18,fp,81137180 <__divdf3+0x748>
81136e28:	9200d52e 	bgeu	r18,r8,81137180 <__divdf3+0x748>
81136e2c:	39ffff84 	addi	r7,r7,-2
81136e30:	9725883a 	add	r18,r18,fp
81136e34:	3004943a 	slli	r2,r6,16
81136e38:	b012d43a 	srli	r9,r22,16
81136e3c:	b1bfffcc 	andi	r6,r22,65535
81136e40:	11e2b03a 	or	r17,r2,r7
81136e44:	8806d43a 	srli	r3,r17,16
81136e48:	893fffcc 	andi	r4,r17,65535
81136e4c:	218b383a 	mul	r5,r4,r6
81136e50:	30c5383a 	mul	r2,r6,r3
81136e54:	2249383a 	mul	r4,r4,r9
81136e58:	280ed43a 	srli	r7,r5,16
81136e5c:	9225c83a 	sub	r18,r18,r8
81136e60:	2089883a 	add	r4,r4,r2
81136e64:	3909883a 	add	r4,r7,r4
81136e68:	1a47383a 	mul	r3,r3,r9
81136e6c:	2080022e 	bgeu	r4,r2,81136e78 <__divdf3+0x440>
81136e70:	00800074 	movhi	r2,1
81136e74:	1887883a 	add	r3,r3,r2
81136e78:	2004d43a 	srli	r2,r4,16
81136e7c:	2008943a 	slli	r4,r4,16
81136e80:	297fffcc 	andi	r5,r5,65535
81136e84:	10c7883a 	add	r3,r2,r3
81136e88:	2149883a 	add	r4,r4,r5
81136e8c:	90c0a536 	bltu	r18,r3,81137124 <__divdf3+0x6ec>
81136e90:	90c0bf26 	beq	r18,r3,81137190 <__divdf3+0x758>
81136e94:	90c7c83a 	sub	r3,r18,r3
81136e98:	810fc83a 	sub	r7,r16,r4
81136e9c:	81e5803a 	cmpltu	r18,r16,r7
81136ea0:	1ca5c83a 	sub	r18,r3,r18
81136ea4:	e480c126 	beq	fp,r18,811371ac <__divdf3+0x774>
81136ea8:	a00b883a 	mov	r5,r20
81136eac:	9009883a 	mov	r4,r18
81136eb0:	d9800315 	stw	r6,12(sp)
81136eb4:	d9c00215 	stw	r7,8(sp)
81136eb8:	da400115 	stw	r9,4(sp)
81136ebc:	1135ecc0 	call	81135ecc <__udivsi3>
81136ec0:	a00b883a 	mov	r5,r20
81136ec4:	9009883a 	mov	r4,r18
81136ec8:	d8800015 	stw	r2,0(sp)
81136ecc:	1135f300 	call	81135f30 <__umodsi3>
81136ed0:	d9c00217 	ldw	r7,8(sp)
81136ed4:	da000017 	ldw	r8,0(sp)
81136ed8:	1006943a 	slli	r3,r2,16
81136edc:	3804d43a 	srli	r2,r7,16
81136ee0:	ba21383a 	mul	r16,r23,r8
81136ee4:	d9800317 	ldw	r6,12(sp)
81136ee8:	10c4b03a 	or	r2,r2,r3
81136eec:	da400117 	ldw	r9,4(sp)
81136ef0:	1400062e 	bgeu	r2,r16,81136f0c <__divdf3+0x4d4>
81136ef4:	1705883a 	add	r2,r2,fp
81136ef8:	40ffffc4 	addi	r3,r8,-1
81136efc:	1700ad36 	bltu	r2,fp,811371b4 <__divdf3+0x77c>
81136f00:	1400ac2e 	bgeu	r2,r16,811371b4 <__divdf3+0x77c>
81136f04:	423fff84 	addi	r8,r8,-2
81136f08:	1705883a 	add	r2,r2,fp
81136f0c:	1421c83a 	sub	r16,r2,r16
81136f10:	a00b883a 	mov	r5,r20
81136f14:	8009883a 	mov	r4,r16
81136f18:	d9800315 	stw	r6,12(sp)
81136f1c:	d9c00215 	stw	r7,8(sp)
81136f20:	da000015 	stw	r8,0(sp)
81136f24:	da400115 	stw	r9,4(sp)
81136f28:	1135ecc0 	call	81135ecc <__udivsi3>
81136f2c:	8009883a 	mov	r4,r16
81136f30:	a00b883a 	mov	r5,r20
81136f34:	1025883a 	mov	r18,r2
81136f38:	1135f300 	call	81135f30 <__umodsi3>
81136f3c:	d9c00217 	ldw	r7,8(sp)
81136f40:	1004943a 	slli	r2,r2,16
81136f44:	bcaf383a 	mul	r23,r23,r18
81136f48:	393fffcc 	andi	r4,r7,65535
81136f4c:	2088b03a 	or	r4,r4,r2
81136f50:	d9800317 	ldw	r6,12(sp)
81136f54:	da000017 	ldw	r8,0(sp)
81136f58:	da400117 	ldw	r9,4(sp)
81136f5c:	25c0062e 	bgeu	r4,r23,81136f78 <__divdf3+0x540>
81136f60:	2709883a 	add	r4,r4,fp
81136f64:	90bfffc4 	addi	r2,r18,-1
81136f68:	27009436 	bltu	r4,fp,811371bc <__divdf3+0x784>
81136f6c:	25c0932e 	bgeu	r4,r23,811371bc <__divdf3+0x784>
81136f70:	94bfff84 	addi	r18,r18,-2
81136f74:	2709883a 	add	r4,r4,fp
81136f78:	4004943a 	slli	r2,r8,16
81136f7c:	25efc83a 	sub	r23,r4,r23
81136f80:	1490b03a 	or	r8,r2,r18
81136f84:	4008d43a 	srli	r4,r8,16
81136f88:	40ffffcc 	andi	r3,r8,65535
81136f8c:	30c5383a 	mul	r2,r6,r3
81136f90:	1a47383a 	mul	r3,r3,r9
81136f94:	310d383a 	mul	r6,r6,r4
81136f98:	100ad43a 	srli	r5,r2,16
81136f9c:	4913383a 	mul	r9,r9,r4
81136fa0:	1987883a 	add	r3,r3,r6
81136fa4:	28c7883a 	add	r3,r5,r3
81136fa8:	1980022e 	bgeu	r3,r6,81136fb4 <__divdf3+0x57c>
81136fac:	01000074 	movhi	r4,1
81136fb0:	4913883a 	add	r9,r9,r4
81136fb4:	1808d43a 	srli	r4,r3,16
81136fb8:	1806943a 	slli	r3,r3,16
81136fbc:	10bfffcc 	andi	r2,r2,65535
81136fc0:	2253883a 	add	r9,r4,r9
81136fc4:	1887883a 	add	r3,r3,r2
81136fc8:	ba403836 	bltu	r23,r9,811370ac <__divdf3+0x674>
81136fcc:	ba403626 	beq	r23,r9,811370a8 <__divdf3+0x670>
81136fd0:	42000054 	ori	r8,r8,1
81136fd4:	a880ffc4 	addi	r2,r21,1023
81136fd8:	00bf570e 	bge	zero,r2,81136d38 <__reset+0xfb116d38>
81136fdc:	40c001cc 	andi	r3,r8,7
81136fe0:	18000726 	beq	r3,zero,81137000 <__divdf3+0x5c8>
81136fe4:	40c003cc 	andi	r3,r8,15
81136fe8:	01000104 	movi	r4,4
81136fec:	19000426 	beq	r3,r4,81137000 <__divdf3+0x5c8>
81136ff0:	4107883a 	add	r3,r8,r4
81136ff4:	1a11803a 	cmpltu	r8,r3,r8
81136ff8:	8a23883a 	add	r17,r17,r8
81136ffc:	1811883a 	mov	r8,r3
81137000:	88c0402c 	andhi	r3,r17,256
81137004:	18000426 	beq	r3,zero,81137018 <__divdf3+0x5e0>
81137008:	00ffc034 	movhi	r3,65280
8113700c:	18ffffc4 	addi	r3,r3,-1
81137010:	a8810004 	addi	r2,r21,1024
81137014:	88e2703a 	and	r17,r17,r3
81137018:	00c1ff84 	movi	r3,2046
8113701c:	18bee316 	blt	r3,r2,81136bac <__reset+0xfb116bac>
81137020:	8824977a 	slli	r18,r17,29
81137024:	4010d0fa 	srli	r8,r8,3
81137028:	8822927a 	slli	r17,r17,9
8113702c:	1081ffcc 	andi	r2,r2,2047
81137030:	9224b03a 	or	r18,r18,r8
81137034:	880ad33a 	srli	r5,r17,12
81137038:	98c0004c 	andi	r3,r19,1
8113703c:	003edf06 	br	81136bbc <__reset+0xfb116bbc>
81137040:	8080022c 	andhi	r2,r16,8
81137044:	10001226 	beq	r2,zero,81137090 <__divdf3+0x658>
81137048:	8880022c 	andhi	r2,r17,8
8113704c:	1000101e 	bne	r2,zero,81137090 <__divdf3+0x658>
81137050:	00800434 	movhi	r2,16
81137054:	89400234 	orhi	r5,r17,8
81137058:	10bfffc4 	addi	r2,r2,-1
8113705c:	b007883a 	mov	r3,r22
81137060:	288a703a 	and	r5,r5,r2
81137064:	4025883a 	mov	r18,r8
81137068:	003f3106 	br	81136d30 <__reset+0xfb116d30>
8113706c:	008000c4 	movi	r2,3
81137070:	3880a626 	beq	r7,r2,8113730c <__divdf3+0x8d4>
81137074:	00800044 	movi	r2,1
81137078:	3880521e 	bne	r7,r2,811371c4 <__divdf3+0x78c>
8113707c:	b807883a 	mov	r3,r23
81137080:	0005883a 	mov	r2,zero
81137084:	000b883a 	mov	r5,zero
81137088:	0025883a 	mov	r18,zero
8113708c:	003ecb06 	br	81136bbc <__reset+0xfb116bbc>
81137090:	00800434 	movhi	r2,16
81137094:	81400234 	orhi	r5,r16,8
81137098:	10bfffc4 	addi	r2,r2,-1
8113709c:	a007883a 	mov	r3,r20
811370a0:	288a703a 	and	r5,r5,r2
811370a4:	003f2206 	br	81136d30 <__reset+0xfb116d30>
811370a8:	183fca26 	beq	r3,zero,81136fd4 <__reset+0xfb116fd4>
811370ac:	e5ef883a 	add	r23,fp,r23
811370b0:	40bfffc4 	addi	r2,r8,-1
811370b4:	bf00392e 	bgeu	r23,fp,8113719c <__divdf3+0x764>
811370b8:	1011883a 	mov	r8,r2
811370bc:	ba7fc41e 	bne	r23,r9,81136fd0 <__reset+0xfb116fd0>
811370c0:	b0ffc31e 	bne	r22,r3,81136fd0 <__reset+0xfb116fd0>
811370c4:	003fc306 	br	81136fd4 <__reset+0xfb116fd4>
811370c8:	143ff604 	addi	r16,r2,-40
811370cc:	9c20983a 	sll	r16,r19,r16
811370d0:	0025883a 	mov	r18,zero
811370d4:	003ee206 	br	81136c60 <__reset+0xfb116c60>
811370d8:	d9800315 	stw	r6,12(sp)
811370dc:	d9c00215 	stw	r7,8(sp)
811370e0:	112276c0 	call	8112276c <__clzsi2>
811370e4:	10800804 	addi	r2,r2,32
811370e8:	d9c00217 	ldw	r7,8(sp)
811370ec:	d9800317 	ldw	r6,12(sp)
811370f0:	003ed106 	br	81136c38 <__reset+0xfb116c38>
811370f4:	147ff604 	addi	r17,r2,-40
811370f8:	3462983a 	sll	r17,r6,r17
811370fc:	0011883a 	mov	r8,zero
81137100:	003ef506 	br	81136cd8 <__reset+0xfb116cd8>
81137104:	3009883a 	mov	r4,r6
81137108:	d9800315 	stw	r6,12(sp)
8113710c:	da400115 	stw	r9,4(sp)
81137110:	112276c0 	call	8112276c <__clzsi2>
81137114:	10800804 	addi	r2,r2,32
81137118:	da400117 	ldw	r9,4(sp)
8113711c:	d9800317 	ldw	r6,12(sp)
81137120:	003ee306 	br	81136cb0 <__reset+0xfb116cb0>
81137124:	85a1883a 	add	r16,r16,r22
81137128:	8585803a 	cmpltu	r2,r16,r22
8113712c:	1705883a 	add	r2,r2,fp
81137130:	14a5883a 	add	r18,r2,r18
81137134:	88bfffc4 	addi	r2,r17,-1
81137138:	e4800c2e 	bgeu	fp,r18,8113716c <__divdf3+0x734>
8113713c:	90c03e36 	bltu	r18,r3,81137238 <__divdf3+0x800>
81137140:	1c806926 	beq	r3,r18,811372e8 <__divdf3+0x8b0>
81137144:	90c7c83a 	sub	r3,r18,r3
81137148:	1023883a 	mov	r17,r2
8113714c:	003f5206 	br	81136e98 <__reset+0xfb116e98>
81137150:	923f0436 	bltu	r18,r8,81136d64 <__reset+0xfb116d64>
81137154:	800897fa 	slli	r4,r16,31
81137158:	9004d07a 	srli	r2,r18,1
8113715c:	8006d07a 	srli	r3,r16,1
81137160:	902097fa 	slli	r16,r18,31
81137164:	20a4b03a 	or	r18,r4,r2
81137168:	003f0106 	br	81136d70 <__reset+0xfb116d70>
8113716c:	e4bff51e 	bne	fp,r18,81137144 <__reset+0xfb117144>
81137170:	85bff22e 	bgeu	r16,r22,8113713c <__reset+0xfb11713c>
81137174:	e0c7c83a 	sub	r3,fp,r3
81137178:	1023883a 	mov	r17,r2
8113717c:	003f4606 	br	81136e98 <__reset+0xfb116e98>
81137180:	100f883a 	mov	r7,r2
81137184:	003f2b06 	br	81136e34 <__reset+0xfb116e34>
81137188:	180d883a 	mov	r6,r3
8113718c:	003f1306 	br	81136ddc <__reset+0xfb116ddc>
81137190:	813fe436 	bltu	r16,r4,81137124 <__reset+0xfb117124>
81137194:	0007883a 	mov	r3,zero
81137198:	003f3f06 	br	81136e98 <__reset+0xfb116e98>
8113719c:	ba402c36 	bltu	r23,r9,81137250 <__divdf3+0x818>
811371a0:	4dc05426 	beq	r9,r23,811372f4 <__divdf3+0x8bc>
811371a4:	1011883a 	mov	r8,r2
811371a8:	003f8906 	br	81136fd0 <__reset+0xfb116fd0>
811371ac:	023fffc4 	movi	r8,-1
811371b0:	003f8806 	br	81136fd4 <__reset+0xfb116fd4>
811371b4:	1811883a 	mov	r8,r3
811371b8:	003f5406 	br	81136f0c <__reset+0xfb116f0c>
811371bc:	1025883a 	mov	r18,r2
811371c0:	003f6d06 	br	81136f78 <__reset+0xfb116f78>
811371c4:	b827883a 	mov	r19,r23
811371c8:	003f8206 	br	81136fd4 <__reset+0xfb116fd4>
811371cc:	010007c4 	movi	r4,31
811371d0:	20c02616 	blt	r4,r3,8113726c <__divdf3+0x834>
811371d4:	00800804 	movi	r2,32
811371d8:	10c5c83a 	sub	r2,r2,r3
811371dc:	888a983a 	sll	r5,r17,r2
811371e0:	40c8d83a 	srl	r4,r8,r3
811371e4:	4084983a 	sll	r2,r8,r2
811371e8:	88e2d83a 	srl	r17,r17,r3
811371ec:	2906b03a 	or	r3,r5,r4
811371f0:	1004c03a 	cmpne	r2,r2,zero
811371f4:	1886b03a 	or	r3,r3,r2
811371f8:	188001cc 	andi	r2,r3,7
811371fc:	10000726 	beq	r2,zero,8113721c <__divdf3+0x7e4>
81137200:	188003cc 	andi	r2,r3,15
81137204:	01000104 	movi	r4,4
81137208:	11000426 	beq	r2,r4,8113721c <__divdf3+0x7e4>
8113720c:	1805883a 	mov	r2,r3
81137210:	10c00104 	addi	r3,r2,4
81137214:	1885803a 	cmpltu	r2,r3,r2
81137218:	88a3883a 	add	r17,r17,r2
8113721c:	8880202c 	andhi	r2,r17,128
81137220:	10002726 	beq	r2,zero,811372c0 <__divdf3+0x888>
81137224:	98c0004c 	andi	r3,r19,1
81137228:	00800044 	movi	r2,1
8113722c:	000b883a 	mov	r5,zero
81137230:	0025883a 	mov	r18,zero
81137234:	003e6106 	br	81136bbc <__reset+0xfb116bbc>
81137238:	85a1883a 	add	r16,r16,r22
8113723c:	8585803a 	cmpltu	r2,r16,r22
81137240:	1705883a 	add	r2,r2,fp
81137244:	14a5883a 	add	r18,r2,r18
81137248:	8c7fff84 	addi	r17,r17,-2
8113724c:	003f1106 	br	81136e94 <__reset+0xfb116e94>
81137250:	b589883a 	add	r4,r22,r22
81137254:	25ad803a 	cmpltu	r22,r4,r22
81137258:	b739883a 	add	fp,r22,fp
8113725c:	40bfff84 	addi	r2,r8,-2
81137260:	bf2f883a 	add	r23,r23,fp
81137264:	202d883a 	mov	r22,r4
81137268:	003f9306 	br	811370b8 <__reset+0xfb1170b8>
8113726c:	013ff844 	movi	r4,-31
81137270:	2085c83a 	sub	r2,r4,r2
81137274:	8888d83a 	srl	r4,r17,r2
81137278:	00800804 	movi	r2,32
8113727c:	18802126 	beq	r3,r2,81137304 <__divdf3+0x8cc>
81137280:	00801004 	movi	r2,64
81137284:	10c5c83a 	sub	r2,r2,r3
81137288:	8884983a 	sll	r2,r17,r2
8113728c:	1204b03a 	or	r2,r2,r8
81137290:	1004c03a 	cmpne	r2,r2,zero
81137294:	2084b03a 	or	r2,r4,r2
81137298:	144001cc 	andi	r17,r2,7
8113729c:	88000d1e 	bne	r17,zero,811372d4 <__divdf3+0x89c>
811372a0:	000b883a 	mov	r5,zero
811372a4:	1024d0fa 	srli	r18,r2,3
811372a8:	98c0004c 	andi	r3,r19,1
811372ac:	0005883a 	mov	r2,zero
811372b0:	9464b03a 	or	r18,r18,r17
811372b4:	003e4106 	br	81136bbc <__reset+0xfb116bbc>
811372b8:	1007883a 	mov	r3,r2
811372bc:	0023883a 	mov	r17,zero
811372c0:	880a927a 	slli	r5,r17,9
811372c4:	1805883a 	mov	r2,r3
811372c8:	8822977a 	slli	r17,r17,29
811372cc:	280ad33a 	srli	r5,r5,12
811372d0:	003ff406 	br	811372a4 <__reset+0xfb1172a4>
811372d4:	10c003cc 	andi	r3,r2,15
811372d8:	01000104 	movi	r4,4
811372dc:	193ff626 	beq	r3,r4,811372b8 <__reset+0xfb1172b8>
811372e0:	0023883a 	mov	r17,zero
811372e4:	003fca06 	br	81137210 <__reset+0xfb117210>
811372e8:	813fd336 	bltu	r16,r4,81137238 <__reset+0xfb117238>
811372ec:	1023883a 	mov	r17,r2
811372f0:	003fa806 	br	81137194 <__reset+0xfb117194>
811372f4:	b0ffd636 	bltu	r22,r3,81137250 <__reset+0xfb117250>
811372f8:	1011883a 	mov	r8,r2
811372fc:	b0ff341e 	bne	r22,r3,81136fd0 <__reset+0xfb116fd0>
81137300:	003f3406 	br	81136fd4 <__reset+0xfb116fd4>
81137304:	0005883a 	mov	r2,zero
81137308:	003fe006 	br	8113728c <__reset+0xfb11728c>
8113730c:	00800434 	movhi	r2,16
81137310:	89400234 	orhi	r5,r17,8
81137314:	10bfffc4 	addi	r2,r2,-1
81137318:	b807883a 	mov	r3,r23
8113731c:	288a703a 	and	r5,r5,r2
81137320:	4025883a 	mov	r18,r8
81137324:	003e8206 	br	81136d30 <__reset+0xfb116d30>

81137328 <__eqdf2>:
81137328:	2804d53a 	srli	r2,r5,20
8113732c:	3806d53a 	srli	r3,r7,20
81137330:	02000434 	movhi	r8,16
81137334:	423fffc4 	addi	r8,r8,-1
81137338:	1081ffcc 	andi	r2,r2,2047
8113733c:	0281ffc4 	movi	r10,2047
81137340:	2a12703a 	and	r9,r5,r8
81137344:	18c1ffcc 	andi	r3,r3,2047
81137348:	3a10703a 	and	r8,r7,r8
8113734c:	280ad7fa 	srli	r5,r5,31
81137350:	380ed7fa 	srli	r7,r7,31
81137354:	12801026 	beq	r2,r10,81137398 <__eqdf2+0x70>
81137358:	0281ffc4 	movi	r10,2047
8113735c:	1a800a26 	beq	r3,r10,81137388 <__eqdf2+0x60>
81137360:	10c00226 	beq	r2,r3,8113736c <__eqdf2+0x44>
81137364:	00800044 	movi	r2,1
81137368:	f800283a 	ret
8113736c:	4a3ffd1e 	bne	r9,r8,81137364 <__reset+0xfb117364>
81137370:	21bffc1e 	bne	r4,r6,81137364 <__reset+0xfb117364>
81137374:	29c00c26 	beq	r5,r7,811373a8 <__eqdf2+0x80>
81137378:	103ffa1e 	bne	r2,zero,81137364 <__reset+0xfb117364>
8113737c:	2244b03a 	or	r2,r4,r9
81137380:	1004c03a 	cmpne	r2,r2,zero
81137384:	f800283a 	ret
81137388:	3214b03a 	or	r10,r6,r8
8113738c:	503ff426 	beq	r10,zero,81137360 <__reset+0xfb117360>
81137390:	00800044 	movi	r2,1
81137394:	f800283a 	ret
81137398:	2254b03a 	or	r10,r4,r9
8113739c:	503fee26 	beq	r10,zero,81137358 <__reset+0xfb117358>
811373a0:	00800044 	movi	r2,1
811373a4:	f800283a 	ret
811373a8:	0005883a 	mov	r2,zero
811373ac:	f800283a 	ret

811373b0 <__ledf2>:
811373b0:	2804d53a 	srli	r2,r5,20
811373b4:	3810d53a 	srli	r8,r7,20
811373b8:	00c00434 	movhi	r3,16
811373bc:	18ffffc4 	addi	r3,r3,-1
811373c0:	1081ffcc 	andi	r2,r2,2047
811373c4:	0241ffc4 	movi	r9,2047
811373c8:	28d4703a 	and	r10,r5,r3
811373cc:	4201ffcc 	andi	r8,r8,2047
811373d0:	38c6703a 	and	r3,r7,r3
811373d4:	280ad7fa 	srli	r5,r5,31
811373d8:	380ed7fa 	srli	r7,r7,31
811373dc:	12401f26 	beq	r2,r9,8113745c <__ledf2+0xac>
811373e0:	0241ffc4 	movi	r9,2047
811373e4:	42401426 	beq	r8,r9,81137438 <__ledf2+0x88>
811373e8:	1000091e 	bne	r2,zero,81137410 <__ledf2+0x60>
811373ec:	2296b03a 	or	r11,r4,r10
811373f0:	5813003a 	cmpeq	r9,r11,zero
811373f4:	29403fcc 	andi	r5,r5,255
811373f8:	40000a1e 	bne	r8,zero,81137424 <__ledf2+0x74>
811373fc:	30d8b03a 	or	r12,r6,r3
81137400:	6000081e 	bne	r12,zero,81137424 <__ledf2+0x74>
81137404:	0005883a 	mov	r2,zero
81137408:	5800111e 	bne	r11,zero,81137450 <__ledf2+0xa0>
8113740c:	f800283a 	ret
81137410:	29403fcc 	andi	r5,r5,255
81137414:	40000c1e 	bne	r8,zero,81137448 <__ledf2+0x98>
81137418:	30d2b03a 	or	r9,r6,r3
8113741c:	48000c26 	beq	r9,zero,81137450 <__ledf2+0xa0>
81137420:	0013883a 	mov	r9,zero
81137424:	39c03fcc 	andi	r7,r7,255
81137428:	48000826 	beq	r9,zero,8113744c <__ledf2+0x9c>
8113742c:	38001126 	beq	r7,zero,81137474 <__ledf2+0xc4>
81137430:	00800044 	movi	r2,1
81137434:	f800283a 	ret
81137438:	30d2b03a 	or	r9,r6,r3
8113743c:	483fea26 	beq	r9,zero,811373e8 <__reset+0xfb1173e8>
81137440:	00800084 	movi	r2,2
81137444:	f800283a 	ret
81137448:	39c03fcc 	andi	r7,r7,255
8113744c:	39400726 	beq	r7,r5,8113746c <__ledf2+0xbc>
81137450:	2800081e 	bne	r5,zero,81137474 <__ledf2+0xc4>
81137454:	00800044 	movi	r2,1
81137458:	f800283a 	ret
8113745c:	2292b03a 	or	r9,r4,r10
81137460:	483fdf26 	beq	r9,zero,811373e0 <__reset+0xfb1173e0>
81137464:	00800084 	movi	r2,2
81137468:	f800283a 	ret
8113746c:	4080030e 	bge	r8,r2,8113747c <__ledf2+0xcc>
81137470:	383fef26 	beq	r7,zero,81137430 <__reset+0xfb117430>
81137474:	00bfffc4 	movi	r2,-1
81137478:	f800283a 	ret
8113747c:	123feb16 	blt	r2,r8,8113742c <__reset+0xfb11742c>
81137480:	1abff336 	bltu	r3,r10,81137450 <__reset+0xfb117450>
81137484:	50c00326 	beq	r10,r3,81137494 <__ledf2+0xe4>
81137488:	50c0042e 	bgeu	r10,r3,8113749c <__ledf2+0xec>
8113748c:	283fe81e 	bne	r5,zero,81137430 <__reset+0xfb117430>
81137490:	003ff806 	br	81137474 <__reset+0xfb117474>
81137494:	313fee36 	bltu	r6,r4,81137450 <__reset+0xfb117450>
81137498:	21bffc36 	bltu	r4,r6,8113748c <__reset+0xfb11748c>
8113749c:	0005883a 	mov	r2,zero
811374a0:	f800283a 	ret

811374a4 <__floatunsidf>:
811374a4:	defffe04 	addi	sp,sp,-8
811374a8:	de00012e 	bgeu	sp,et,811374b0 <__floatunsidf+0xc>
811374ac:	003b68fa 	trap	3
811374b0:	dc000015 	stw	r16,0(sp)
811374b4:	dfc00115 	stw	ra,4(sp)
811374b8:	2021883a 	mov	r16,r4
811374bc:	20002226 	beq	r4,zero,81137548 <__floatunsidf+0xa4>
811374c0:	112276c0 	call	8112276c <__clzsi2>
811374c4:	01010784 	movi	r4,1054
811374c8:	2089c83a 	sub	r4,r4,r2
811374cc:	01810cc4 	movi	r6,1075
811374d0:	310dc83a 	sub	r6,r6,r4
811374d4:	00c007c4 	movi	r3,31
811374d8:	1980120e 	bge	r3,r6,81137524 <__floatunsidf+0x80>
811374dc:	00c104c4 	movi	r3,1043
811374e0:	1907c83a 	sub	r3,r3,r4
811374e4:	80ca983a 	sll	r5,r16,r3
811374e8:	00800434 	movhi	r2,16
811374ec:	10bfffc4 	addi	r2,r2,-1
811374f0:	2101ffcc 	andi	r4,r4,2047
811374f4:	0021883a 	mov	r16,zero
811374f8:	288a703a 	and	r5,r5,r2
811374fc:	2008953a 	slli	r4,r4,20
81137500:	00c00434 	movhi	r3,16
81137504:	18ffffc4 	addi	r3,r3,-1
81137508:	28c6703a 	and	r3,r5,r3
8113750c:	8005883a 	mov	r2,r16
81137510:	1906b03a 	or	r3,r3,r4
81137514:	dfc00117 	ldw	ra,4(sp)
81137518:	dc000017 	ldw	r16,0(sp)
8113751c:	dec00204 	addi	sp,sp,8
81137520:	f800283a 	ret
81137524:	00c002c4 	movi	r3,11
81137528:	188bc83a 	sub	r5,r3,r2
8113752c:	814ad83a 	srl	r5,r16,r5
81137530:	00c00434 	movhi	r3,16
81137534:	18ffffc4 	addi	r3,r3,-1
81137538:	81a0983a 	sll	r16,r16,r6
8113753c:	2101ffcc 	andi	r4,r4,2047
81137540:	28ca703a 	and	r5,r5,r3
81137544:	003fed06 	br	811374fc <__reset+0xfb1174fc>
81137548:	0009883a 	mov	r4,zero
8113754c:	000b883a 	mov	r5,zero
81137550:	003fea06 	br	811374fc <__reset+0xfb1174fc>

81137554 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
81137554:	defffb04 	addi	sp,sp,-20
81137558:	de00012e 	bgeu	sp,et,81137560 <alt_busy_sleep+0xc>
8113755c:	003b68fa 	trap	3
81137560:	df000415 	stw	fp,16(sp)
81137564:	df000404 	addi	fp,sp,16
81137568:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
8113756c:	008000c4 	movi	r2,3
81137570:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
81137574:	e0fffd17 	ldw	r3,-12(fp)
81137578:	008003f4 	movhi	r2,15
8113757c:	10909004 	addi	r2,r2,16960
81137580:	1887383a 	mul	r3,r3,r2
81137584:	00817db4 	movhi	r2,1526
81137588:	10b84004 	addi	r2,r2,-7936
8113758c:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
81137590:	00a00034 	movhi	r2,32768
81137594:	10bfffc4 	addi	r2,r2,-1
81137598:	10c5203a 	divu	r2,r2,r3
8113759c:	e0ffff17 	ldw	r3,-4(fp)
811375a0:	1885203a 	divu	r2,r3,r2
811375a4:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
811375a8:	e0bffe17 	ldw	r2,-8(fp)
811375ac:	10002526 	beq	r2,zero,81137644 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
811375b0:	e03ffc15 	stw	zero,-16(fp)
811375b4:	00001406 	br	81137608 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
811375b8:	00a00034 	movhi	r2,32768
811375bc:	10bfffc4 	addi	r2,r2,-1
811375c0:	10bfffc4 	addi	r2,r2,-1
811375c4:	103ffe1e 	bne	r2,zero,811375c0 <__reset+0xfb1175c0>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
811375c8:	e0fffd17 	ldw	r3,-12(fp)
811375cc:	008003f4 	movhi	r2,15
811375d0:	10909004 	addi	r2,r2,16960
811375d4:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
811375d8:	00817db4 	movhi	r2,1526
811375dc:	10b84004 	addi	r2,r2,-7936
811375e0:	10c7203a 	divu	r3,r2,r3
811375e4:	00a00034 	movhi	r2,32768
811375e8:	10bfffc4 	addi	r2,r2,-1
811375ec:	10c5203a 	divu	r2,r2,r3
811375f0:	e0ffff17 	ldw	r3,-4(fp)
811375f4:	1885c83a 	sub	r2,r3,r2
811375f8:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
811375fc:	e0bffc17 	ldw	r2,-16(fp)
81137600:	10800044 	addi	r2,r2,1
81137604:	e0bffc15 	stw	r2,-16(fp)
81137608:	e0fffc17 	ldw	r3,-16(fp)
8113760c:	e0bffe17 	ldw	r2,-8(fp)
81137610:	18bfe916 	blt	r3,r2,811375b8 <__reset+0xfb1175b8>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81137614:	e0fffd17 	ldw	r3,-12(fp)
81137618:	008003f4 	movhi	r2,15
8113761c:	10909004 	addi	r2,r2,16960
81137620:	1887383a 	mul	r3,r3,r2
81137624:	00817db4 	movhi	r2,1526
81137628:	10b84004 	addi	r2,r2,-7936
8113762c:	10c7203a 	divu	r3,r2,r3
81137630:	e0bfff17 	ldw	r2,-4(fp)
81137634:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81137638:	10bfffc4 	addi	r2,r2,-1
8113763c:	103ffe1e 	bne	r2,zero,81137638 <__reset+0xfb117638>
81137640:	00000b06 	br	81137670 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81137644:	e0fffd17 	ldw	r3,-12(fp)
81137648:	008003f4 	movhi	r2,15
8113764c:	10909004 	addi	r2,r2,16960
81137650:	1887383a 	mul	r3,r3,r2
81137654:	00817db4 	movhi	r2,1526
81137658:	10b84004 	addi	r2,r2,-7936
8113765c:	10c7203a 	divu	r3,r2,r3
81137660:	e0bfff17 	ldw	r2,-4(fp)
81137664:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81137668:	10bfffc4 	addi	r2,r2,-1
8113766c:	00bffe16 	blt	zero,r2,81137668 <__reset+0xfb117668>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
81137670:	0005883a 	mov	r2,zero
}
81137674:	e037883a 	mov	sp,fp
81137678:	df000017 	ldw	fp,0(sp)
8113767c:	dec00104 	addi	sp,sp,4
81137680:	f800283a 	ret

81137684 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81137684:	defffe04 	addi	sp,sp,-8
81137688:	de00012e 	bgeu	sp,et,81137690 <alt_get_errno+0xc>
8113768c:	003b68fa 	trap	3
81137690:	dfc00115 	stw	ra,4(sp)
81137694:	df000015 	stw	fp,0(sp)
81137698:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113769c:	d0a01017 	ldw	r2,-32704(gp)
811376a0:	10000326 	beq	r2,zero,811376b0 <alt_get_errno+0x2c>
811376a4:	d0a01017 	ldw	r2,-32704(gp)
811376a8:	103ee83a 	callr	r2
811376ac:	00000106 	br	811376b4 <alt_get_errno+0x30>
811376b0:	d0a07804 	addi	r2,gp,-32288
}
811376b4:	e037883a 	mov	sp,fp
811376b8:	dfc00117 	ldw	ra,4(sp)
811376bc:	df000017 	ldw	fp,0(sp)
811376c0:	dec00204 	addi	sp,sp,8
811376c4:	f800283a 	ret

811376c8 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
811376c8:	defffb04 	addi	sp,sp,-20
811376cc:	de00012e 	bgeu	sp,et,811376d4 <close+0xc>
811376d0:	003b68fa 	trap	3
811376d4:	dfc00415 	stw	ra,16(sp)
811376d8:	df000315 	stw	fp,12(sp)
811376dc:	df000304 	addi	fp,sp,12
811376e0:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
811376e4:	e0bfff17 	ldw	r2,-4(fp)
811376e8:	10000616 	blt	r2,zero,81137704 <close+0x3c>
811376ec:	e0bfff17 	ldw	r2,-4(fp)
811376f0:	10c00324 	muli	r3,r2,12
811376f4:	00a04574 	movhi	r2,33045
811376f8:	108bd904 	addi	r2,r2,12132
811376fc:	1885883a 	add	r2,r3,r2
81137700:	00000106 	br	81137708 <close+0x40>
81137704:	0005883a 	mov	r2,zero
81137708:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
8113770c:	e0bffd17 	ldw	r2,-12(fp)
81137710:	10001926 	beq	r2,zero,81137778 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
81137714:	e0bffd17 	ldw	r2,-12(fp)
81137718:	10800017 	ldw	r2,0(r2)
8113771c:	10800417 	ldw	r2,16(r2)
81137720:	10000626 	beq	r2,zero,8113773c <close+0x74>
81137724:	e0bffd17 	ldw	r2,-12(fp)
81137728:	10800017 	ldw	r2,0(r2)
8113772c:	10800417 	ldw	r2,16(r2)
81137730:	e13ffd17 	ldw	r4,-12(fp)
81137734:	103ee83a 	callr	r2
81137738:	00000106 	br	81137740 <close+0x78>
8113773c:	0005883a 	mov	r2,zero
81137740:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
81137744:	e13fff17 	ldw	r4,-4(fp)
81137748:	1138cac0 	call	81138cac <alt_release_fd>
    if (rval < 0)
8113774c:	e0bffe17 	ldw	r2,-8(fp)
81137750:	1000070e 	bge	r2,zero,81137770 <close+0xa8>
    {
      ALT_ERRNO = -rval;
81137754:	11376840 	call	81137684 <alt_get_errno>
81137758:	1007883a 	mov	r3,r2
8113775c:	e0bffe17 	ldw	r2,-8(fp)
81137760:	0085c83a 	sub	r2,zero,r2
81137764:	18800015 	stw	r2,0(r3)
      return -1;
81137768:	00bfffc4 	movi	r2,-1
8113776c:	00000706 	br	8113778c <close+0xc4>
    }
    return 0;
81137770:	0005883a 	mov	r2,zero
81137774:	00000506 	br	8113778c <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
81137778:	11376840 	call	81137684 <alt_get_errno>
8113777c:	1007883a 	mov	r3,r2
81137780:	00801444 	movi	r2,81
81137784:	18800015 	stw	r2,0(r3)
    return -1;
81137788:	00bfffc4 	movi	r2,-1
  }
}
8113778c:	e037883a 	mov	sp,fp
81137790:	dfc00117 	ldw	ra,4(sp)
81137794:	df000017 	ldw	fp,0(sp)
81137798:	dec00204 	addi	sp,sp,8
8113779c:	f800283a 	ret

811377a0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
811377a0:	deffff04 	addi	sp,sp,-4
811377a4:	de00012e 	bgeu	sp,et,811377ac <alt_dcache_flush_all+0xc>
811377a8:	003b68fa 	trap	3
811377ac:	df000015 	stw	fp,0(sp)
811377b0:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
811377b4:	0001883a 	nop
811377b8:	e037883a 	mov	sp,fp
811377bc:	df000017 	ldw	fp,0(sp)
811377c0:	dec00104 	addi	sp,sp,4
811377c4:	f800283a 	ret

811377c8 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
811377c8:	defffc04 	addi	sp,sp,-16
811377cc:	de00012e 	bgeu	sp,et,811377d4 <alt_dev_null_write+0xc>
811377d0:	003b68fa 	trap	3
811377d4:	df000315 	stw	fp,12(sp)
811377d8:	df000304 	addi	fp,sp,12
811377dc:	e13ffd15 	stw	r4,-12(fp)
811377e0:	e17ffe15 	stw	r5,-8(fp)
811377e4:	e1bfff15 	stw	r6,-4(fp)
  return len;
811377e8:	e0bfff17 	ldw	r2,-4(fp)
}
811377ec:	e037883a 	mov	sp,fp
811377f0:	df000017 	ldw	fp,0(sp)
811377f4:	dec00104 	addi	sp,sp,4
811377f8:	f800283a 	ret

811377fc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811377fc:	defffe04 	addi	sp,sp,-8
81137800:	de00012e 	bgeu	sp,et,81137808 <alt_get_errno+0xc>
81137804:	003b68fa 	trap	3
81137808:	dfc00115 	stw	ra,4(sp)
8113780c:	df000015 	stw	fp,0(sp)
81137810:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81137814:	d0a01017 	ldw	r2,-32704(gp)
81137818:	10000326 	beq	r2,zero,81137828 <alt_get_errno+0x2c>
8113781c:	d0a01017 	ldw	r2,-32704(gp)
81137820:	103ee83a 	callr	r2
81137824:	00000106 	br	8113782c <alt_get_errno+0x30>
81137828:	d0a07804 	addi	r2,gp,-32288
}
8113782c:	e037883a 	mov	sp,fp
81137830:	dfc00117 	ldw	ra,4(sp)
81137834:	df000017 	ldw	fp,0(sp)
81137838:	dec00204 	addi	sp,sp,8
8113783c:	f800283a 	ret

81137840 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
81137840:	defffb04 	addi	sp,sp,-20
81137844:	de00012e 	bgeu	sp,et,8113784c <fstat+0xc>
81137848:	003b68fa 	trap	3
8113784c:	dfc00415 	stw	ra,16(sp)
81137850:	df000315 	stw	fp,12(sp)
81137854:	df000304 	addi	fp,sp,12
81137858:	e13ffe15 	stw	r4,-8(fp)
8113785c:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81137860:	e0bffe17 	ldw	r2,-8(fp)
81137864:	10000616 	blt	r2,zero,81137880 <fstat+0x40>
81137868:	e0bffe17 	ldw	r2,-8(fp)
8113786c:	10c00324 	muli	r3,r2,12
81137870:	00a04574 	movhi	r2,33045
81137874:	108bd904 	addi	r2,r2,12132
81137878:	1885883a 	add	r2,r3,r2
8113787c:	00000106 	br	81137884 <fstat+0x44>
81137880:	0005883a 	mov	r2,zero
81137884:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
81137888:	e0bffd17 	ldw	r2,-12(fp)
8113788c:	10001026 	beq	r2,zero,811378d0 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
81137890:	e0bffd17 	ldw	r2,-12(fp)
81137894:	10800017 	ldw	r2,0(r2)
81137898:	10800817 	ldw	r2,32(r2)
8113789c:	10000726 	beq	r2,zero,811378bc <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
811378a0:	e0bffd17 	ldw	r2,-12(fp)
811378a4:	10800017 	ldw	r2,0(r2)
811378a8:	10800817 	ldw	r2,32(r2)
811378ac:	e17fff17 	ldw	r5,-4(fp)
811378b0:	e13ffd17 	ldw	r4,-12(fp)
811378b4:	103ee83a 	callr	r2
811378b8:	00000a06 	br	811378e4 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
811378bc:	e0bfff17 	ldw	r2,-4(fp)
811378c0:	00c80004 	movi	r3,8192
811378c4:	10c00115 	stw	r3,4(r2)
      return 0;
811378c8:	0005883a 	mov	r2,zero
811378cc:	00000506 	br	811378e4 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
811378d0:	11377fc0 	call	811377fc <alt_get_errno>
811378d4:	1007883a 	mov	r3,r2
811378d8:	00801444 	movi	r2,81
811378dc:	18800015 	stw	r2,0(r3)
    return -1;
811378e0:	00bfffc4 	movi	r2,-1
  }
}
811378e4:	e037883a 	mov	sp,fp
811378e8:	dfc00117 	ldw	ra,4(sp)
811378ec:	df000017 	ldw	fp,0(sp)
811378f0:	dec00204 	addi	sp,sp,8
811378f4:	f800283a 	ret

811378f8 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
811378f8:	defff004 	addi	sp,sp,-64
811378fc:	de00012e 	bgeu	sp,et,81137904 <alt_irq_register+0xc>
81137900:	003b68fa 	trap	3
81137904:	df000f15 	stw	fp,60(sp)
81137908:	df000f04 	addi	fp,sp,60
8113790c:	e13ffd15 	stw	r4,-12(fp)
81137910:	e17ffe15 	stw	r5,-8(fp)
81137914:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
81137918:	00bffa84 	movi	r2,-22
8113791c:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81137920:	e0bffd17 	ldw	r2,-12(fp)
81137924:	10800828 	cmpgeui	r2,r2,32
81137928:	1000501e 	bne	r2,zero,81137a6c <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113792c:	0005303a 	rdctl	r2,status
81137930:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137934:	e0fff617 	ldw	r3,-40(fp)
81137938:	00bfff84 	movi	r2,-2
8113793c:	1884703a 	and	r2,r3,r2
81137940:	1001703a 	wrctl	status,r2
  
  return context;
81137944:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
81137948:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
8113794c:	00a045f4 	movhi	r2,33047
81137950:	10b97e04 	addi	r2,r2,-6664
81137954:	e0fffd17 	ldw	r3,-12(fp)
81137958:	180690fa 	slli	r3,r3,3
8113795c:	10c5883a 	add	r2,r2,r3
81137960:	e0ffff17 	ldw	r3,-4(fp)
81137964:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
81137968:	00a045f4 	movhi	r2,33047
8113796c:	10b97e04 	addi	r2,r2,-6664
81137970:	e0fffd17 	ldw	r3,-12(fp)
81137974:	180690fa 	slli	r3,r3,3
81137978:	10c5883a 	add	r2,r2,r3
8113797c:	10800104 	addi	r2,r2,4
81137980:	e0fffe17 	ldw	r3,-8(fp)
81137984:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
81137988:	e0bfff17 	ldw	r2,-4(fp)
8113798c:	10001926 	beq	r2,zero,811379f4 <alt_irq_register+0xfc>
81137990:	e0bffd17 	ldw	r2,-12(fp)
81137994:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137998:	0005303a 	rdctl	r2,status
8113799c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811379a0:	e0fff717 	ldw	r3,-36(fp)
811379a4:	00bfff84 	movi	r2,-2
811379a8:	1884703a 	and	r2,r3,r2
811379ac:	1001703a 	wrctl	status,r2
  
  return context;
811379b0:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811379b4:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
811379b8:	00c00044 	movi	r3,1
811379bc:	e0bff217 	ldw	r2,-56(fp)
811379c0:	1884983a 	sll	r2,r3,r2
811379c4:	1007883a 	mov	r3,r2
811379c8:	d0a08017 	ldw	r2,-32256(gp)
811379cc:	1884b03a 	or	r2,r3,r2
811379d0:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811379d4:	d0a08017 	ldw	r2,-32256(gp)
811379d8:	100170fa 	wrctl	ienable,r2
811379dc:	e0bff817 	ldw	r2,-32(fp)
811379e0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811379e4:	e0bff917 	ldw	r2,-28(fp)
811379e8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811379ec:	0005883a 	mov	r2,zero
811379f0:	00001906 	br	81137a58 <alt_irq_register+0x160>
811379f4:	e0bffd17 	ldw	r2,-12(fp)
811379f8:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811379fc:	0005303a 	rdctl	r2,status
81137a00:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137a04:	e0fffa17 	ldw	r3,-24(fp)
81137a08:	00bfff84 	movi	r2,-2
81137a0c:	1884703a 	and	r2,r3,r2
81137a10:	1001703a 	wrctl	status,r2
  
  return context;
81137a14:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81137a18:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
81137a1c:	00c00044 	movi	r3,1
81137a20:	e0bff417 	ldw	r2,-48(fp)
81137a24:	1884983a 	sll	r2,r3,r2
81137a28:	0084303a 	nor	r2,zero,r2
81137a2c:	1007883a 	mov	r3,r2
81137a30:	d0a08017 	ldw	r2,-32256(gp)
81137a34:	1884703a 	and	r2,r3,r2
81137a38:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81137a3c:	d0a08017 	ldw	r2,-32256(gp)
81137a40:	100170fa 	wrctl	ienable,r2
81137a44:	e0bffb17 	ldw	r2,-20(fp)
81137a48:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137a4c:	e0bffc17 	ldw	r2,-16(fp)
81137a50:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81137a54:	0005883a 	mov	r2,zero
81137a58:	e0bff115 	stw	r2,-60(fp)
81137a5c:	e0bff317 	ldw	r2,-52(fp)
81137a60:	e0bff515 	stw	r2,-44(fp)
81137a64:	e0bff517 	ldw	r2,-44(fp)
81137a68:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
81137a6c:	e0bff117 	ldw	r2,-60(fp)
}
81137a70:	e037883a 	mov	sp,fp
81137a74:	df000017 	ldw	fp,0(sp)
81137a78:	dec00104 	addi	sp,sp,4
81137a7c:	f800283a 	ret

81137a80 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81137a80:	defffe04 	addi	sp,sp,-8
81137a84:	de00012e 	bgeu	sp,et,81137a8c <alt_get_errno+0xc>
81137a88:	003b68fa 	trap	3
81137a8c:	dfc00115 	stw	ra,4(sp)
81137a90:	df000015 	stw	fp,0(sp)
81137a94:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81137a98:	d0a01017 	ldw	r2,-32704(gp)
81137a9c:	10000326 	beq	r2,zero,81137aac <alt_get_errno+0x2c>
81137aa0:	d0a01017 	ldw	r2,-32704(gp)
81137aa4:	103ee83a 	callr	r2
81137aa8:	00000106 	br	81137ab0 <alt_get_errno+0x30>
81137aac:	d0a07804 	addi	r2,gp,-32288
}
81137ab0:	e037883a 	mov	sp,fp
81137ab4:	dfc00117 	ldw	ra,4(sp)
81137ab8:	df000017 	ldw	fp,0(sp)
81137abc:	dec00204 	addi	sp,sp,8
81137ac0:	f800283a 	ret

81137ac4 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
81137ac4:	deffed04 	addi	sp,sp,-76
81137ac8:	de00012e 	bgeu	sp,et,81137ad0 <isatty+0xc>
81137acc:	003b68fa 	trap	3
81137ad0:	dfc01215 	stw	ra,72(sp)
81137ad4:	df001115 	stw	fp,68(sp)
81137ad8:	df001104 	addi	fp,sp,68
81137adc:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81137ae0:	e0bfff17 	ldw	r2,-4(fp)
81137ae4:	10000616 	blt	r2,zero,81137b00 <isatty+0x3c>
81137ae8:	e0bfff17 	ldw	r2,-4(fp)
81137aec:	10c00324 	muli	r3,r2,12
81137af0:	00a04574 	movhi	r2,33045
81137af4:	108bd904 	addi	r2,r2,12132
81137af8:	1885883a 	add	r2,r3,r2
81137afc:	00000106 	br	81137b04 <isatty+0x40>
81137b00:	0005883a 	mov	r2,zero
81137b04:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
81137b08:	e0bfef17 	ldw	r2,-68(fp)
81137b0c:	10000e26 	beq	r2,zero,81137b48 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
81137b10:	e0bfef17 	ldw	r2,-68(fp)
81137b14:	10800017 	ldw	r2,0(r2)
81137b18:	10800817 	ldw	r2,32(r2)
81137b1c:	1000021e 	bne	r2,zero,81137b28 <isatty+0x64>
    {
      return 1;
81137b20:	00800044 	movi	r2,1
81137b24:	00000d06 	br	81137b5c <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
81137b28:	e0bff004 	addi	r2,fp,-64
81137b2c:	100b883a 	mov	r5,r2
81137b30:	e13fff17 	ldw	r4,-4(fp)
81137b34:	11378400 	call	81137840 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
81137b38:	e0bff117 	ldw	r2,-60(fp)
81137b3c:	10880020 	cmpeqi	r2,r2,8192
81137b40:	10803fcc 	andi	r2,r2,255
81137b44:	00000506 	br	81137b5c <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81137b48:	1137a800 	call	81137a80 <alt_get_errno>
81137b4c:	1007883a 	mov	r3,r2
81137b50:	00801444 	movi	r2,81
81137b54:	18800015 	stw	r2,0(r3)
    return 0;
81137b58:	0005883a 	mov	r2,zero
  }
}
81137b5c:	e037883a 	mov	sp,fp
81137b60:	dfc00117 	ldw	ra,4(sp)
81137b64:	df000017 	ldw	fp,0(sp)
81137b68:	dec00204 	addi	sp,sp,8
81137b6c:	f800283a 	ret

81137b70 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
81137b70:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
81137b74:	318c2404 	addi	r6,r6,12432

81137b78 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
81137b78:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
81137b7c:	01c00826 	beq	zero,r7,81137ba0 <end_tx>

81137b80 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
81137b80:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
81137b84:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
81137b88:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
81137b8c:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
81137b90:	283ffb26 	beq	r5,zero,81137b80 <__reset+0xfb117b80>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
81137b94:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
81137b98:	21000044 	addi	r4,r4,1
	br tx_next_char
81137b9c:	003ff606 	br	81137b78 <__reset+0xfb117b78>

81137ba0 <end_tx>:
end_tx:	
        ret
81137ba0:	f800283a 	ret

81137ba4 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
81137ba4:	defffd04 	addi	sp,sp,-12
81137ba8:	de00012e 	bgeu	sp,et,81137bb0 <alt_log_txchar+0xc>
81137bac:	003b68fa 	trap	3
81137bb0:	df000215 	stw	fp,8(sp)
81137bb4:	df000204 	addi	fp,sp,8
81137bb8:	e13ffe15 	stw	r4,-8(fp)
81137bbc:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
81137bc0:	0001883a 	nop
81137bc4:	e0bfff17 	ldw	r2,-4(fp)
81137bc8:	10800104 	addi	r2,r2,4
81137bcc:	10800037 	ldwio	r2,0(r2)
81137bd0:	10bfffec 	andhi	r2,r2,65535
81137bd4:	103ffb26 	beq	r2,zero,81137bc4 <__reset+0xfb117bc4>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81137bd8:	e0bfff17 	ldw	r2,-4(fp)
81137bdc:	e0fffe17 	ldw	r3,-8(fp)
81137be0:	10c00035 	stwio	r3,0(r2)
}
81137be4:	0001883a 	nop
81137be8:	e037883a 	mov	sp,fp
81137bec:	df000017 	ldw	fp,0(sp)
81137bf0:	dec00104 	addi	sp,sp,4
81137bf4:	f800283a 	ret

81137bf8 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
81137bf8:	defffb04 	addi	sp,sp,-20
81137bfc:	de00012e 	bgeu	sp,et,81137c04 <alt_log_repchar+0xc>
81137c00:	003b68fa 	trap	3
81137c04:	dfc00415 	stw	ra,16(sp)
81137c08:	df000315 	stw	fp,12(sp)
81137c0c:	df000304 	addi	fp,sp,12
81137c10:	2005883a 	mov	r2,r4
81137c14:	e17ffe15 	stw	r5,-8(fp)
81137c18:	e1bfff15 	stw	r6,-4(fp)
81137c1c:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
81137c20:	00000506 	br	81137c38 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
81137c24:	e0bffd07 	ldb	r2,-12(fp)
81137c28:	e0ffff17 	ldw	r3,-4(fp)
81137c2c:	180b883a 	mov	r5,r3
81137c30:	1009883a 	mov	r4,r2
81137c34:	1137ba40 	call	81137ba4 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
81137c38:	e0bffe17 	ldw	r2,-8(fp)
81137c3c:	10ffffc4 	addi	r3,r2,-1
81137c40:	e0fffe15 	stw	r3,-8(fp)
81137c44:	00bff716 	blt	zero,r2,81137c24 <__reset+0xfb117c24>
    alt_log_txchar(c,(char*) base);
}
81137c48:	0001883a 	nop
81137c4c:	e037883a 	mov	sp,fp
81137c50:	dfc00117 	ldw	ra,4(sp)
81137c54:	df000017 	ldw	fp,0(sp)
81137c58:	dec00204 	addi	sp,sp,8
81137c5c:	f800283a 	ret

81137c60 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
81137c60:	deffe904 	addi	sp,sp,-92
81137c64:	de00012e 	bgeu	sp,et,81137c6c <alt_log_private_printf+0xc>
81137c68:	003b68fa 	trap	3
81137c6c:	dfc01615 	stw	ra,88(sp)
81137c70:	df001515 	stw	fp,84(sp)
81137c74:	dc001415 	stw	r16,80(sp)
81137c78:	df001504 	addi	fp,sp,84
81137c7c:	e13ffc15 	stw	r4,-16(fp)
81137c80:	e17ffd15 	stw	r5,-12(fp)
81137c84:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
81137c88:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
81137c8c:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
81137c90:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
81137c94:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
81137c98:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
81137c9c:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
81137ca0:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
81137ca4:	e0bffc17 	ldw	r2,-16(fp)
81137ca8:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
81137cac:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
81137cb0:	00014b06 	br	811381e0 <alt_log_private_printf+0x580>
    {
    switch(state)
81137cb4:	e0bfec17 	ldw	r2,-80(fp)
81137cb8:	10c00060 	cmpeqi	r3,r2,1
81137cbc:	18001b1e 	bne	r3,zero,81137d2c <alt_log_private_printf+0xcc>
81137cc0:	10c000a0 	cmpeqi	r3,r2,2
81137cc4:	18002d1e 	bne	r3,zero,81137d7c <alt_log_private_printf+0x11c>
81137cc8:	10000126 	beq	r2,zero,81137cd0 <alt_log_private_printf+0x70>
81137ccc:	00014406 	br	811381e0 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
81137cd0:	e0bffb07 	ldb	r2,-20(fp)
81137cd4:	10800958 	cmpnei	r2,r2,37
81137cd8:	10000e1e 	bne	r2,zero,81137d14 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
81137cdc:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81137ce0:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81137ce4:	00800284 	movi	r2,10
81137ce8:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
81137cec:	00800044 	movi	r2,1
81137cf0:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81137cf4:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
81137cf8:	00bfffc4 	movi	r2,-1
81137cfc:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
81137d00:	00bfffc4 	movi	r2,-1
81137d04:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
81137d08:	00800044 	movi	r2,1
81137d0c:	e0bfec15 	stw	r2,-80(fp)
81137d10:	00013306 	br	811381e0 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
81137d14:	e0bffb07 	ldb	r2,-20(fp)
81137d18:	e0fffd17 	ldw	r3,-12(fp)
81137d1c:	180b883a 	mov	r5,r3
81137d20:	1009883a 	mov	r4,r2
81137d24:	1137ba40 	call	81137ba4 <alt_log_txchar>
        }
        break;
81137d28:	00012d06 	br	811381e0 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
81137d2c:	e0bffb07 	ldb	r2,-20(fp)
81137d30:	10800c18 	cmpnei	r2,r2,48
81137d34:	1000051e 	bne	r2,zero,81137d4c <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
81137d38:	00800044 	movi	r2,1
81137d3c:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
81137d40:	00800084 	movi	r2,2
81137d44:	e0bfec15 	stw	r2,-80(fp)
81137d48:	00012506 	br	811381e0 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
81137d4c:	e0bffb07 	ldb	r2,-20(fp)
81137d50:	10800958 	cmpnei	r2,r2,37
81137d54:	1000071e 	bne	r2,zero,81137d74 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
81137d58:	e0bffb07 	ldb	r2,-20(fp)
81137d5c:	e0fffd17 	ldw	r3,-12(fp)
81137d60:	180b883a 	mov	r5,r3
81137d64:	1009883a 	mov	r4,r2
81137d68:	1137ba40 	call	81137ba4 <alt_log_txchar>
          state = pfState_chars;
81137d6c:	e03fec15 	stw	zero,-80(fp)
81137d70:	00011b06 	br	811381e0 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81137d74:	00800084 	movi	r2,2
81137d78:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
81137d7c:	e0bffb07 	ldb	r2,-20(fp)
81137d80:	10800b98 	cmpnei	r2,r2,46
81137d84:	1000021e 	bne	r2,zero,81137d90 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
81137d88:	e03ff015 	stw	zero,-64(fp)
81137d8c:	00011306 	br	811381dc <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81137d90:	e0bffb07 	ldb	r2,-20(fp)
81137d94:	10800c10 	cmplti	r2,r2,48
81137d98:	10001a1e 	bne	r2,zero,81137e04 <alt_log_private_printf+0x1a4>
81137d9c:	e0bffb07 	ldb	r2,-20(fp)
81137da0:	10800e88 	cmpgei	r2,r2,58
81137da4:	1000171e 	bne	r2,zero,81137e04 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
81137da8:	e0bffb03 	ldbu	r2,-20(fp)
81137dac:	10bff404 	addi	r2,r2,-48
81137db0:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
81137db4:	e0bff017 	ldw	r2,-64(fp)
81137db8:	10000c0e 	bge	r2,zero,81137dec <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
81137dbc:	e0bfef17 	ldw	r2,-68(fp)
81137dc0:	1000020e 	bge	r2,zero,81137dcc <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
81137dc4:	e03fef15 	stw	zero,-68(fp)
81137dc8:	00000306 	br	81137dd8 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
81137dcc:	e0bfef17 	ldw	r2,-68(fp)
81137dd0:	108002a4 	muli	r2,r2,10
81137dd4:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81137dd8:	e0bffb07 	ldb	r2,-20(fp)
81137ddc:	e0ffef17 	ldw	r3,-68(fp)
81137de0:	1885883a 	add	r2,r3,r2
81137de4:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81137de8:	0000fc06 	br	811381dc <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
81137dec:	e0bff017 	ldw	r2,-64(fp)
81137df0:	10c002a4 	muli	r3,r2,10
81137df4:	e0bffb07 	ldb	r2,-20(fp)
81137df8:	1885883a 	add	r2,r3,r2
81137dfc:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81137e00:	0000f606 	br	811381dc <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
81137e04:	e0bffb07 	ldb	r2,-20(fp)
81137e08:	10801b18 	cmpnei	r2,r2,108
81137e0c:	1000031e 	bne	r2,zero,81137e1c <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
81137e10:	00800044 	movi	r2,1
81137e14:	e0bfee15 	stw	r2,-72(fp)
81137e18:	0000f006 	br	811381dc <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
81137e1c:	e0bffb07 	ldb	r2,-20(fp)
81137e20:	10bfea04 	addi	r2,r2,-88
81137e24:	10c00868 	cmpgeui	r3,r2,33
81137e28:	1800eb1e 	bne	r3,zero,811381d8 <alt_log_private_printf+0x578>
81137e2c:	100690ba 	slli	r3,r2,2
81137e30:	00a044f4 	movhi	r2,33043
81137e34:	109f9104 	addi	r2,r2,32324
81137e38:	1885883a 	add	r2,r3,r2
81137e3c:	10800017 	ldw	r2,0(r2)
81137e40:	1000683a 	jmp	r2
81137e44:	81138104 	addi	r4,r16,19972
81137e48:	811381d8 	cmpnei	r4,r16,19975
81137e4c:	811381d8 	cmpnei	r4,r16,19975
81137e50:	811381d8 	cmpnei	r4,r16,19975
81137e54:	811381d8 	cmpnei	r4,r16,19975
81137e58:	811381d8 	cmpnei	r4,r16,19975
81137e5c:	811381d8 	cmpnei	r4,r16,19975
81137e60:	811381d8 	cmpnei	r4,r16,19975
81137e64:	811381d8 	cmpnei	r4,r16,19975
81137e68:	811381d8 	cmpnei	r4,r16,19975
81137e6c:	811381d8 	cmpnei	r4,r16,19975
81137e70:	8113811c 	xori	r4,r16,19972
81137e74:	81137ec8 	cmpgei	r4,r16,19963
81137e78:	811381d8 	cmpnei	r4,r16,19975
81137e7c:	811381d8 	cmpnei	r4,r16,19975
81137e80:	811381d8 	cmpnei	r4,r16,19975
81137e84:	811381d8 	cmpnei	r4,r16,19975
81137e88:	81137ec8 	cmpgei	r4,r16,19963
81137e8c:	811381d8 	cmpnei	r4,r16,19975
81137e90:	811381d8 	cmpnei	r4,r16,19975
81137e94:	811381d8 	cmpnei	r4,r16,19975
81137e98:	811381d8 	cmpnei	r4,r16,19975
81137e9c:	811381d8 	cmpnei	r4,r16,19975
81137ea0:	811380e4 	muli	r4,r16,19971
81137ea4:	811381d8 	cmpnei	r4,r16,19975
81137ea8:	811381d8 	cmpnei	r4,r16,19975
81137eac:	811381d8 	cmpnei	r4,r16,19975
81137eb0:	81138158 	cmpnei	r4,r16,19973
81137eb4:	811381d8 	cmpnei	r4,r16,19975
81137eb8:	811380dc 	xori	r4,r16,19971
81137ebc:	811381d8 	cmpnei	r4,r16,19975
81137ec0:	811381d8 	cmpnei	r4,r16,19975
81137ec4:	811380f4 	orhi	r4,r16,19971
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
81137ec8:	e0bfee17 	ldw	r2,-72(fp)
81137ecc:	10000e26 	beq	r2,zero,81137f08 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
81137ed0:	e0bff217 	ldw	r2,-56(fp)
81137ed4:	10000626 	beq	r2,zero,81137ef0 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81137ed8:	e0bffe17 	ldw	r2,-8(fp)
81137edc:	10c00104 	addi	r3,r2,4
81137ee0:	e0fffe15 	stw	r3,-8(fp)
81137ee4:	10800017 	ldw	r2,0(r2)
81137ee8:	e0bff415 	stw	r2,-48(fp)
81137eec:	00001306 	br	81137f3c <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
81137ef0:	e0bffe17 	ldw	r2,-8(fp)
81137ef4:	10c00104 	addi	r3,r2,4
81137ef8:	e0fffe15 	stw	r3,-8(fp)
81137efc:	10800017 	ldw	r2,0(r2)
81137f00:	e0bff415 	stw	r2,-48(fp)
81137f04:	00000d06 	br	81137f3c <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
81137f08:	e0bff217 	ldw	r2,-56(fp)
81137f0c:	10000626 	beq	r2,zero,81137f28 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
81137f10:	e0bffe17 	ldw	r2,-8(fp)
81137f14:	10c00104 	addi	r3,r2,4
81137f18:	e0fffe15 	stw	r3,-8(fp)
81137f1c:	10800017 	ldw	r2,0(r2)
81137f20:	e0bff415 	stw	r2,-48(fp)
81137f24:	00000506 	br	81137f3c <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
81137f28:	e0bffe17 	ldw	r2,-8(fp)
81137f2c:	10c00104 	addi	r3,r2,4
81137f30:	e0fffe15 	stw	r3,-8(fp)
81137f34:	10800017 	ldw	r2,0(r2)
81137f38:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
81137f3c:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
81137f40:	e0bff217 	ldw	r2,-56(fp)
81137f44:	10000726 	beq	r2,zero,81137f64 <alt_log_private_printf+0x304>
81137f48:	e0bff417 	ldw	r2,-48(fp)
81137f4c:	1000050e 	bge	r2,zero,81137f64 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
81137f50:	e0bff417 	ldw	r2,-48(fp)
81137f54:	0085c83a 	sub	r2,zero,r2
81137f58:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81137f5c:	00800044 	movi	r2,1
81137f60:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81137f64:	e0bff417 	ldw	r2,-48(fp)
81137f68:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81137f6c:	00800044 	movi	r2,1
81137f70:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81137f74:	00800044 	movi	r2,1
81137f78:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
81137f7c:	00000706 	br	81137f9c <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81137f80:	e0bff817 	ldw	r2,-32(fp)
81137f84:	10800044 	addi	r2,r2,1
81137f88:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
81137f8c:	e0bff117 	ldw	r2,-60(fp)
81137f90:	e0fff517 	ldw	r3,-44(fp)
81137f94:	1885383a 	mul	r2,r3,r2
81137f98:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
81137f9c:	e0bff117 	ldw	r2,-60(fp)
81137fa0:	e0fff617 	ldw	r3,-40(fp)
81137fa4:	1885203a 	divu	r2,r3,r2
81137fa8:	e0bff615 	stw	r2,-40(fp)
81137fac:	e0bff617 	ldw	r2,-40(fp)
81137fb0:	103ff31e 	bne	r2,zero,81137f80 <__reset+0xfb117f80>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
81137fb4:	e0ffef17 	ldw	r3,-68(fp)
81137fb8:	e0bff817 	ldw	r2,-32(fp)
81137fbc:	1885c83a 	sub	r2,r3,r2
81137fc0:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
81137fc4:	e0bfed17 	ldw	r2,-76(fp)
81137fc8:	10000e26 	beq	r2,zero,81138004 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
81137fcc:	e0bff717 	ldw	r2,-36(fp)
81137fd0:	10000726 	beq	r2,zero,81137ff0 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
81137fd4:	e0bffd17 	ldw	r2,-12(fp)
81137fd8:	100b883a 	mov	r5,r2
81137fdc:	01000b44 	movi	r4,45
81137fe0:	1137ba40 	call	81137ba4 <alt_log_txchar>
                    fmtBeforeDecimal--;
81137fe4:	e0bfef17 	ldw	r2,-68(fp)
81137fe8:	10bfffc4 	addi	r2,r2,-1
81137fec:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81137ff0:	e1bffd17 	ldw	r6,-12(fp)
81137ff4:	e17fef17 	ldw	r5,-68(fp)
81137ff8:	01000c04 	movi	r4,48
81137ffc:	1137bf80 	call	81137bf8 <alt_log_repchar>
81138000:	00003206 	br	811380cc <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
81138004:	e0bff717 	ldw	r2,-36(fp)
81138008:	10000326 	beq	r2,zero,81138018 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
8113800c:	e0bfef17 	ldw	r2,-68(fp)
81138010:	10bfffc4 	addi	r2,r2,-1
81138014:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
81138018:	e1bffd17 	ldw	r6,-12(fp)
8113801c:	e17fef17 	ldw	r5,-68(fp)
81138020:	01000804 	movi	r4,32
81138024:	1137bf80 	call	81137bf8 <alt_log_repchar>
                    if(sign)
81138028:	e0bff717 	ldw	r2,-36(fp)
8113802c:	10002726 	beq	r2,zero,811380cc <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
81138030:	e0bffd17 	ldw	r2,-12(fp)
81138034:	100b883a 	mov	r5,r2
81138038:	01000b44 	movi	r4,45
8113803c:	1137ba40 	call	81137ba4 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
81138040:	00002206 	br	811380cc <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
81138044:	e0fff417 	ldw	r3,-48(fp)
81138048:	e0bff517 	ldw	r2,-44(fp)
8113804c:	1885203a 	divu	r2,r3,r2
81138050:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
81138054:	e0bff903 	ldbu	r2,-28(fp)
81138058:	10800c04 	addi	r2,r2,48
8113805c:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
81138060:	e0bff903 	ldbu	r2,-28(fp)
81138064:	10800eb0 	cmpltui	r2,r2,58
81138068:	1000081e 	bne	r2,zero,8113808c <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
8113806c:	e0bff317 	ldw	r2,-52(fp)
81138070:	10000226 	beq	r2,zero,8113807c <alt_log_private_printf+0x41c>
81138074:	008001c4 	movi	r2,7
81138078:	00000106 	br	81138080 <alt_log_private_printf+0x420>
8113807c:	008009c4 	movi	r2,39
81138080:	e0fff903 	ldbu	r3,-28(fp)
81138084:	10c5883a 	add	r2,r2,r3
81138088:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
8113808c:	e0bff903 	ldbu	r2,-28(fp)
81138090:	e0fffd17 	ldw	r3,-12(fp)
81138094:	180b883a 	mov	r5,r3
81138098:	1009883a 	mov	r4,r2
8113809c:	1137ba40 	call	81137ba4 <alt_log_txchar>

                  v = v % p;
811380a0:	e0bff417 	ldw	r2,-48(fp)
811380a4:	e0fff517 	ldw	r3,-44(fp)
811380a8:	10c9203a 	divu	r4,r2,r3
811380ac:	e0fff517 	ldw	r3,-44(fp)
811380b0:	20c7383a 	mul	r3,r4,r3
811380b4:	10c5c83a 	sub	r2,r2,r3
811380b8:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
811380bc:	e0bff117 	ldw	r2,-60(fp)
811380c0:	e0fff517 	ldw	r3,-44(fp)
811380c4:	1885203a 	divu	r2,r3,r2
811380c8:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
811380cc:	e0bff517 	ldw	r2,-44(fp)
811380d0:	103fdc1e 	bne	r2,zero,81138044 <__reset+0xfb118044>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
811380d4:	e03fec15 	stw	zero,-80(fp)
              break;
811380d8:	00003f06 	br	811381d8 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
811380dc:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
811380e0:	003f7906 	br	81137ec8 <__reset+0xfb117ec8>
            case 'o':
              fmtSigned = 0;
811380e4:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
811380e8:	00800204 	movi	r2,8
811380ec:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
811380f0:	003f7506 	br	81137ec8 <__reset+0xfb117ec8>
            case 'x':
              fmtSigned = 0;
811380f4:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
811380f8:	00800404 	movi	r2,16
811380fc:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81138100:	003f7106 	br	81137ec8 <__reset+0xfb117ec8>
            case 'X':
              fmtSigned = 0;
81138104:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81138108:	00800404 	movi	r2,16
8113810c:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81138110:	00800044 	movi	r2,1
81138114:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81138118:	003f6b06 	br	81137ec8 <__reset+0xfb117ec8>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
8113811c:	e0bfef17 	ldw	r2,-68(fp)
81138120:	10bfffc4 	addi	r2,r2,-1
81138124:	e1bffd17 	ldw	r6,-12(fp)
81138128:	100b883a 	mov	r5,r2
8113812c:	01000804 	movi	r4,32
81138130:	1137bf80 	call	81137bf8 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
81138134:	e0bffe17 	ldw	r2,-8(fp)
81138138:	10c00104 	addi	r3,r2,4
8113813c:	e0fffe15 	stw	r3,-8(fp)
81138140:	10800017 	ldw	r2,0(r2)
81138144:	e0fffd17 	ldw	r3,-12(fp)
81138148:	180b883a 	mov	r5,r3
8113814c:	1009883a 	mov	r4,r2
81138150:	1137ba40 	call	81137ba4 <alt_log_txchar>
              break;
81138154:	00002006 	br	811381d8 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
81138158:	e0bffe17 	ldw	r2,-8(fp)
8113815c:	10c00104 	addi	r3,r2,4
81138160:	e0fffe15 	stw	r3,-8(fp)
81138164:	10800017 	ldw	r2,0(r2)
81138168:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
8113816c:	e43fef17 	ldw	r16,-68(fp)
81138170:	e13ffa17 	ldw	r4,-24(fp)
81138174:	11244540 	call	81124454 <strlen>
81138178:	8085c83a 	sub	r2,r16,r2
8113817c:	e1bffd17 	ldw	r6,-12(fp)
81138180:	100b883a 	mov	r5,r2
81138184:	01000804 	movi	r4,32
81138188:	1137bf80 	call	81137bf8 <alt_log_repchar>

                while(*s)
8113818c:	00000b06 	br	811381bc <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81138190:	e0bffa17 	ldw	r2,-24(fp)
81138194:	10c00044 	addi	r3,r2,1
81138198:	e0fffa15 	stw	r3,-24(fp)
8113819c:	10800003 	ldbu	r2,0(r2)
811381a0:	10803fcc 	andi	r2,r2,255
811381a4:	1080201c 	xori	r2,r2,128
811381a8:	10bfe004 	addi	r2,r2,-128
811381ac:	e0fffd17 	ldw	r3,-12(fp)
811381b0:	180b883a 	mov	r5,r3
811381b4:	1009883a 	mov	r4,r2
811381b8:	1137ba40 	call	81137ba4 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
811381bc:	e0bffa17 	ldw	r2,-24(fp)
811381c0:	10800003 	ldbu	r2,0(r2)
811381c4:	10803fcc 	andi	r2,r2,255
811381c8:	1080201c 	xori	r2,r2,128
811381cc:	10bfe004 	addi	r2,r2,-128
811381d0:	103fef1e 	bne	r2,zero,81138190 <__reset+0xfb118190>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
811381d4:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
811381d8:	e03fec15 	stw	zero,-80(fp)
          }
        break;
811381dc:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
811381e0:	e0bfeb17 	ldw	r2,-84(fp)
811381e4:	10c00044 	addi	r3,r2,1
811381e8:	e0ffeb15 	stw	r3,-84(fp)
811381ec:	10800003 	ldbu	r2,0(r2)
811381f0:	e0bffb05 	stb	r2,-20(fp)
811381f4:	e0bffb07 	ldb	r2,-20(fp)
811381f8:	103eae1e 	bne	r2,zero,81137cb4 <__reset+0xfb117cb4>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
811381fc:	0001883a 	nop
81138200:	e6ffff04 	addi	sp,fp,-4
81138204:	dfc00217 	ldw	ra,8(sp)
81138208:	df000117 	ldw	fp,4(sp)
8113820c:	dc000017 	ldw	r16,0(sp)
81138210:	dec00304 	addi	sp,sp,12
81138214:	f800283a 	ret

81138218 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81138218:	defff904 	addi	sp,sp,-28
8113821c:	de00012e 	bgeu	sp,et,81138224 <alt_log_printf_proc+0xc>
81138220:	003b68fa 	trap	3
81138224:	dfc00315 	stw	ra,12(sp)
81138228:	df000215 	stw	fp,8(sp)
8113822c:	df000204 	addi	fp,sp,8
81138230:	e13fff15 	stw	r4,-4(fp)
81138234:	e1400215 	stw	r5,8(fp)
81138238:	e1800315 	stw	r6,12(fp)
8113823c:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
81138240:	e0800204 	addi	r2,fp,8
81138244:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
81138248:	e0bffe17 	ldw	r2,-8(fp)
8113824c:	100d883a 	mov	r6,r2
81138250:	01604834 	movhi	r5,33056
81138254:	294c2404 	addi	r5,r5,12432
81138258:	e13fff17 	ldw	r4,-4(fp)
8113825c:	1137c600 	call	81137c60 <alt_log_private_printf>
    return (0);
81138260:	0005883a 	mov	r2,zero
}
81138264:	e037883a 	mov	sp,fp
81138268:	dfc00117 	ldw	ra,4(sp)
8113826c:	df000017 	ldw	fp,0(sp)
81138270:	dec00504 	addi	sp,sp,20
81138274:	f800283a 	ret

81138278 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
81138278:	defff904 	addi	sp,sp,-28
8113827c:	de00012e 	bgeu	sp,et,81138284 <altera_avalon_jtag_uart_report_log+0xc>
81138280:	003b68fa 	trap	3
81138284:	dfc00615 	stw	ra,24(sp)
81138288:	df000515 	stw	fp,20(sp)
8113828c:	dc400415 	stw	r17,16(sp)
81138290:	dc000315 	stw	r16,12(sp)
81138294:	df000504 	addi	fp,sp,20
81138298:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
8113829c:	d0a08183 	ldbu	r2,-32250(gp)
811382a0:	10803fcc 	andi	r2,r2,255
811382a4:	10001426 	beq	r2,zero,811382f8 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
811382a8:	e0bffd17 	ldw	r2,-12(fp)
811382ac:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
811382b0:	00a04574 	movhi	r2,33045
811382b4:	1087ff04 	addi	r2,r2,8188
811382b8:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
811382bc:	e0bffb17 	ldw	r2,-20(fp)
811382c0:	10800017 	ldw	r2,0(r2)
811382c4:	e1bffc17 	ldw	r6,-16(fp)
811382c8:	100b883a 	mov	r5,r2
811382cc:	e13ffb17 	ldw	r4,-20(fp)
811382d0:	11383180 	call	81138318 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811382d4:	d0e08817 	ldw	r3,-32224(gp)
        return ALT_LOG_JTAG_UART_TICKS;
811382d8:	00b33374 	movhi	r2,52429
811382dc:	10b33344 	addi	r2,r2,-13107
811382e0:	1888383a 	mulxuu	r4,r3,r2
811382e4:	1885383a 	mul	r2,r3,r2
811382e8:	1021883a 	mov	r16,r2
811382ec:	2023883a 	mov	r17,r4
811382f0:	8804d0fa 	srli	r2,r17,3
811382f4:	00000106 	br	811382fc <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
811382f8:	0005883a 	mov	r2,zero
    }
}
811382fc:	e6fffe04 	addi	sp,fp,-8
81138300:	dfc00317 	ldw	ra,12(sp)
81138304:	df000217 	ldw	fp,8(sp)
81138308:	dc400117 	ldw	r17,4(sp)
8113830c:	dc000017 	ldw	r16,0(sp)
81138310:	dec00404 	addi	sp,sp,16
81138314:	f800283a 	ret

81138318 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81138318:	deffef04 	addi	sp,sp,-68
8113831c:	de00012e 	bgeu	sp,et,81138324 <alt_log_jtag_uart_print_control_reg+0xc>
81138320:	003b68fa 	trap	3
81138324:	dfc01015 	stw	ra,64(sp)
81138328:	df000f15 	stw	fp,60(sp)
8113832c:	df000f04 	addi	fp,sp,60
81138330:	e13ffd15 	stw	r4,-12(fp)
81138334:	e17ffe15 	stw	r5,-8(fp)
81138338:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8113833c:	e0bffe17 	ldw	r2,-8(fp)
81138340:	10800104 	addi	r2,r2,4
81138344:	10800037 	ldwio	r2,0(r2)
81138348:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
8113834c:	e0bff617 	ldw	r2,-40(fp)
81138350:	1004d43a 	srli	r2,r2,16
81138354:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
81138358:	e0bff617 	ldw	r2,-40(fp)
8113835c:	1080008c 	andi	r2,r2,2
81138360:	1004d07a 	srli	r2,r2,1
81138364:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
81138368:	e0bff617 	ldw	r2,-40(fp)
8113836c:	1080004c 	andi	r2,r2,1
81138370:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
81138374:	e0bff617 	ldw	r2,-40(fp)
81138378:	1080400c 	andi	r2,r2,256
8113837c:	1004d23a 	srli	r2,r2,8
81138380:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
81138384:	e0bff617 	ldw	r2,-40(fp)
81138388:	1080800c 	andi	r2,r2,512
8113838c:	1004d27a 	srli	r2,r2,9
81138390:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
81138394:	e0bff617 	ldw	r2,-40(fp)
81138398:	1081000c 	andi	r2,r2,1024
8113839c:	1004d2ba 	srli	r2,r2,10
811383a0:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
811383a4:	e0bffd17 	ldw	r2,-12(fp)
811383a8:	10c01017 	ldw	r3,64(r2)
811383ac:	e0bffd17 	ldw	r2,-12(fp)
811383b0:	10800f17 	ldw	r2,60(r2)
811383b4:	1887c83a 	sub	r3,r3,r2
811383b8:	e0bff917 	ldw	r2,-28(fp)
811383bc:	d8800415 	stw	r2,16(sp)
811383c0:	e0bff817 	ldw	r2,-32(fp)
811383c4:	d8800315 	stw	r2,12(sp)
811383c8:	e0bffa17 	ldw	r2,-24(fp)
811383cc:	d8800215 	stw	r2,8(sp)
811383d0:	e0bffb17 	ldw	r2,-20(fp)
811383d4:	d8800115 	stw	r2,4(sp)
811383d8:	e0bffc17 	ldw	r2,-16(fp)
811383dc:	d8800015 	stw	r2,0(sp)
811383e0:	e1fff717 	ldw	r7,-36(fp)
811383e4:	180d883a 	mov	r6,r3
811383e8:	e17fff17 	ldw	r5,-4(fp)
811383ec:	01204574 	movhi	r4,33045
811383f0:	21080204 	addi	r4,r4,8200
811383f4:	11382180 	call	81138218 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
811383f8:	0001883a 	nop

}
811383fc:	e037883a 	mov	sp,fp
81138400:	dfc00117 	ldw	ra,4(sp)
81138404:	df000017 	ldw	fp,0(sp)
81138408:	dec00204 	addi	sp,sp,8
8113840c:	f800283a 	ret

81138410 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
81138410:	defffb04 	addi	sp,sp,-20
81138414:	de00012e 	bgeu	sp,et,8113841c <alt_log_jtag_uart_startup_info+0xc>
81138418:	003b68fa 	trap	3
8113841c:	dfc00415 	stw	ra,16(sp)
81138420:	df000315 	stw	fp,12(sp)
81138424:	df000304 	addi	fp,sp,12
81138428:	e13ffe15 	stw	r4,-8(fp)
8113842c:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
81138430:	00a04574 	movhi	r2,33045
81138434:	10881404 	addi	r2,r2,8272
81138438:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
8113843c:	e1bffd17 	ldw	r6,-12(fp)
81138440:	e17fff17 	ldw	r5,-4(fp)
81138444:	e13ffe17 	ldw	r4,-8(fp)
81138448:	11383180 	call	81138318 <alt_log_jtag_uart_print_control_reg>
     return;
8113844c:	0001883a 	nop
}
81138450:	e037883a 	mov	sp,fp
81138454:	dfc00117 	ldw	ra,4(sp)
81138458:	df000017 	ldw	fp,0(sp)
8113845c:	dec00204 	addi	sp,sp,8
81138460:	f800283a 	ret

81138464 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
81138464:	defffb04 	addi	sp,sp,-20
81138468:	de00012e 	bgeu	sp,et,81138470 <alt_log_jtag_uart_isr_proc+0xc>
8113846c:	003b68fa 	trap	3
81138470:	dfc00415 	stw	ra,16(sp)
81138474:	df000315 	stw	fp,12(sp)
81138478:	df000304 	addi	fp,sp,12
8113847c:	e13ffe15 	stw	r4,-8(fp)
81138480:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
81138484:	d0a081c3 	ldbu	r2,-32249(gp)
81138488:	10803fcc 	andi	r2,r2,255
8113848c:	10000826 	beq	r2,zero,811384b0 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
81138490:	00a04574 	movhi	r2,33045
81138494:	10881904 	addi	r2,r2,8292
81138498:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
8113849c:	e1bffd17 	ldw	r6,-12(fp)
811384a0:	e17ffe17 	ldw	r5,-8(fp)
811384a4:	e13fff17 	ldw	r4,-4(fp)
811384a8:	11383180 	call	81138318 <alt_log_jtag_uart_print_control_reg>
    }
    return;
811384ac:	0001883a 	nop
811384b0:	0001883a 	nop
}
811384b4:	e037883a 	mov	sp,fp
811384b8:	dfc00117 	ldw	ra,4(sp)
811384bc:	df000017 	ldw	fp,0(sp)
811384c0:	dec00204 	addi	sp,sp,8
811384c4:	f800283a 	ret

811384c8 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
811384c8:	defffa04 	addi	sp,sp,-24
811384cc:	de00012e 	bgeu	sp,et,811384d4 <alt_log_write+0xc>
811384d0:	003b68fa 	trap	3
811384d4:	dfc00515 	stw	ra,20(sp)
811384d8:	df000415 	stw	fp,16(sp)
811384dc:	df000404 	addi	fp,sp,16
811384e0:	e13ffe15 	stw	r4,-8(fp)
811384e4:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
811384e8:	d0a08103 	ldbu	r2,-32252(gp)
811384ec:	10803fcc 	andi	r2,r2,255
811384f0:	10004026 	beq	r2,zero,811385f4 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
811384f4:	e0bfff17 	ldw	r2,-4(fp)
811384f8:	10c00430 	cmpltui	r3,r2,16
811384fc:	1800011e 	bne	r3,zero,81138504 <alt_log_write+0x3c>
81138500:	008003c4 	movi	r2,15
81138504:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81138508:	e0bffd17 	ldw	r2,-12(fp)
8113850c:	10800088 	cmpgei	r2,r2,2
81138510:	10003726 	beq	r2,zero,811385f0 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
81138514:	e0bffd17 	ldw	r2,-12(fp)
81138518:	100d883a 	mov	r6,r2
8113851c:	e17ffe17 	ldw	r5,-8(fp)
81138520:	012045b4 	movhi	r4,33046
81138524:	211ff804 	addi	r4,r4,32736
81138528:	114c4940 	call	8114c494 <strncpy>
    alt_log_write_buf[length-1]='\n';
8113852c:	e0bffd17 	ldw	r2,-12(fp)
81138530:	10ffffc4 	addi	r3,r2,-1
81138534:	00a045b4 	movhi	r2,33046
81138538:	109ff804 	addi	r2,r2,32736
8113853c:	10c5883a 	add	r2,r2,r3
81138540:	00c00284 	movi	r3,10
81138544:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
81138548:	00a045b4 	movhi	r2,33046
8113854c:	109ff804 	addi	r2,r2,32736
81138550:	e0fffd17 	ldw	r3,-12(fp)
81138554:	10c5883a 	add	r2,r2,r3
81138558:	00c00344 	movi	r3,13
8113855c:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
81138560:	e0bffd17 	ldw	r2,-12(fp)
81138564:	10c00044 	addi	r3,r2,1
81138568:	00a045b4 	movhi	r2,33046
8113856c:	109ff804 	addi	r2,r2,32736
81138570:	10c5883a 	add	r2,r2,r3
81138574:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81138578:	e03ffc15 	stw	zero,-16(fp)
8113857c:	00001306 	br	811385cc <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
81138580:	00a045b4 	movhi	r2,33046
81138584:	109ff804 	addi	r2,r2,32736
81138588:	e0fffc17 	ldw	r3,-16(fp)
8113858c:	10c5883a 	add	r2,r2,r3
81138590:	10800003 	ldbu	r2,0(r2)
81138594:	10803fcc 	andi	r2,r2,255
81138598:	1080201c 	xori	r2,r2,128
8113859c:	10bfe004 	addi	r2,r2,-128
811385a0:	10800118 	cmpnei	r2,r2,4
811385a4:	1000061e 	bne	r2,zero,811385c0 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
811385a8:	00a045b4 	movhi	r2,33046
811385ac:	109ff804 	addi	r2,r2,32736
811385b0:	e0fffc17 	ldw	r3,-16(fp)
811385b4:	10c5883a 	add	r2,r2,r3
811385b8:	00c01104 	movi	r3,68
811385bc:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
811385c0:	e0bffc17 	ldw	r2,-16(fp)
811385c4:	10800044 	addi	r2,r2,1
811385c8:	e0bffc15 	stw	r2,-16(fp)
811385cc:	e0fffc17 	ldw	r3,-16(fp)
811385d0:	e0bffd17 	ldw	r2,-12(fp)
811385d4:	18bfea16 	blt	r3,r2,81138580 <__reset+0xfb118580>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
811385d8:	016045b4 	movhi	r5,33046
811385dc:	295ff804 	addi	r5,r5,32736
811385e0:	01204574 	movhi	r4,33045
811385e4:	21081c04 	addi	r4,r4,8304
811385e8:	11382180 	call	81138218 <alt_log_printf_proc>
811385ec:	00000106 	br	811385f4 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
811385f0:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
811385f4:	e037883a 	mov	sp,fp
811385f8:	dfc00117 	ldw	ra,4(sp)
811385fc:	df000017 	ldw	fp,0(sp)
81138600:	dec00204 	addi	sp,sp,8
81138604:	f800283a 	ret

81138608 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81138608:	defffe04 	addi	sp,sp,-8
8113860c:	de00012e 	bgeu	sp,et,81138614 <alt_log_system_clock+0xc>
81138610:	003b68fa 	trap	3
81138614:	dfc00115 	stw	ra,4(sp)
81138618:	df000015 	stw	fp,0(sp)
8113861c:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
81138620:	d0a08143 	ldbu	r2,-32251(gp)
81138624:	10803fcc 	andi	r2,r2,255
81138628:	10000e26 	beq	r2,zero,81138664 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
8113862c:	d0a08417 	ldw	r2,-32240(gp)
81138630:	10800044 	addi	r2,r2,1
81138634:	d0a08415 	stw	r2,-32240(gp)
81138638:	d0a08817 	ldw	r2,-32224(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
8113863c:	d0e08417 	ldw	r3,-32240(gp)
81138640:	10c0082e 	bgeu	r2,r3,81138664 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
81138644:	d0208415 	stw	zero,-32240(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
81138648:	d0a08317 	ldw	r2,-32244(gp)
8113864c:	10c00044 	addi	r3,r2,1
81138650:	d0e08315 	stw	r3,-32244(gp)
81138654:	100b883a 	mov	r5,r2
81138658:	01204574 	movhi	r4,33045
8113865c:	21082004 	addi	r4,r4,8320
81138660:	11382180 	call	81138218 <alt_log_printf_proc>
        }
    }
}
81138664:	0001883a 	nop
81138668:	e037883a 	mov	sp,fp
8113866c:	dfc00117 	ldw	ra,4(sp)
81138670:	df000017 	ldw	fp,0(sp)
81138674:	dec00204 	addi	sp,sp,8
81138678:	f800283a 	ret

8113867c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113867c:	defffe04 	addi	sp,sp,-8
81138680:	de00012e 	bgeu	sp,et,81138688 <alt_get_errno+0xc>
81138684:	003b68fa 	trap	3
81138688:	dfc00115 	stw	ra,4(sp)
8113868c:	df000015 	stw	fp,0(sp)
81138690:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81138694:	d0a01017 	ldw	r2,-32704(gp)
81138698:	10000326 	beq	r2,zero,811386a8 <alt_get_errno+0x2c>
8113869c:	d0a01017 	ldw	r2,-32704(gp)
811386a0:	103ee83a 	callr	r2
811386a4:	00000106 	br	811386ac <alt_get_errno+0x30>
811386a8:	d0a07804 	addi	r2,gp,-32288
}
811386ac:	e037883a 	mov	sp,fp
811386b0:	dfc00117 	ldw	ra,4(sp)
811386b4:	df000017 	ldw	fp,0(sp)
811386b8:	dec00204 	addi	sp,sp,8
811386bc:	f800283a 	ret

811386c0 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
811386c0:	defff904 	addi	sp,sp,-28
811386c4:	de00012e 	bgeu	sp,et,811386cc <lseek+0xc>
811386c8:	003b68fa 	trap	3
811386cc:	dfc00615 	stw	ra,24(sp)
811386d0:	df000515 	stw	fp,20(sp)
811386d4:	df000504 	addi	fp,sp,20
811386d8:	e13ffd15 	stw	r4,-12(fp)
811386dc:	e17ffe15 	stw	r5,-8(fp)
811386e0:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
811386e4:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811386e8:	e0bffd17 	ldw	r2,-12(fp)
811386ec:	10000616 	blt	r2,zero,81138708 <lseek+0x48>
811386f0:	e0bffd17 	ldw	r2,-12(fp)
811386f4:	10c00324 	muli	r3,r2,12
811386f8:	00a04574 	movhi	r2,33045
811386fc:	108bd904 	addi	r2,r2,12132
81138700:	1885883a 	add	r2,r3,r2
81138704:	00000106 	br	8113870c <lseek+0x4c>
81138708:	0005883a 	mov	r2,zero
8113870c:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
81138710:	e0bffc17 	ldw	r2,-16(fp)
81138714:	10001026 	beq	r2,zero,81138758 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
81138718:	e0bffc17 	ldw	r2,-16(fp)
8113871c:	10800017 	ldw	r2,0(r2)
81138720:	10800717 	ldw	r2,28(r2)
81138724:	10000926 	beq	r2,zero,8113874c <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
81138728:	e0bffc17 	ldw	r2,-16(fp)
8113872c:	10800017 	ldw	r2,0(r2)
81138730:	10800717 	ldw	r2,28(r2)
81138734:	e1bfff17 	ldw	r6,-4(fp)
81138738:	e17ffe17 	ldw	r5,-8(fp)
8113873c:	e13ffc17 	ldw	r4,-16(fp)
81138740:	103ee83a 	callr	r2
81138744:	e0bffb15 	stw	r2,-20(fp)
81138748:	00000506 	br	81138760 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
8113874c:	00bfde84 	movi	r2,-134
81138750:	e0bffb15 	stw	r2,-20(fp)
81138754:	00000206 	br	81138760 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
81138758:	00bfebc4 	movi	r2,-81
8113875c:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
81138760:	e0bffb17 	ldw	r2,-20(fp)
81138764:	1000070e 	bge	r2,zero,81138784 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
81138768:	113867c0 	call	8113867c <alt_get_errno>
8113876c:	1007883a 	mov	r3,r2
81138770:	e0bffb17 	ldw	r2,-20(fp)
81138774:	0085c83a 	sub	r2,zero,r2
81138778:	18800015 	stw	r2,0(r3)
    rc = -1;
8113877c:	00bfffc4 	movi	r2,-1
81138780:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
81138784:	e0bffb17 	ldw	r2,-20(fp)
}
81138788:	e037883a 	mov	sp,fp
8113878c:	dfc00117 	ldw	ra,4(sp)
81138790:	df000017 	ldw	fp,0(sp)
81138794:	dec00204 	addi	sp,sp,8
81138798:	f800283a 	ret

8113879c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
8113879c:	defff904 	addi	sp,sp,-28
811387a0:	de00012e 	bgeu	sp,et,811387a8 <alt_main+0xc>
811387a4:	003b68fa 	trap	3
811387a8:	dfc00615 	stw	ra,24(sp)
811387ac:	df000515 	stw	fp,20(sp)
811387b0:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
811387b4:	d0a01217 	ldw	r2,-32696(gp)
811387b8:	10800058 	cmpnei	r2,r2,1
811387bc:	1000031e 	bne	r2,zero,811387cc <alt_main+0x30>
811387c0:	01204574 	movhi	r4,33045
811387c4:	21082604 	addi	r4,r4,8344
811387c8:	11382180 	call	81138218 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
811387cc:	0009883a 	mov	r4,zero
811387d0:	11432f40 	call	811432f4 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
811387d4:	d0a01217 	ldw	r2,-32696(gp)
811387d8:	10800058 	cmpnei	r2,r2,1
811387dc:	1000031e 	bne	r2,zero,811387ec <alt_main+0x50>
811387e0:	01204574 	movhi	r4,33045
811387e4:	21083404 	addi	r4,r4,8400
811387e8:	11382180 	call	81138218 <alt_log_printf_proc>
  ALT_OS_INIT();
811387ec:	1139d880 	call	81139d88 <OSInit>
811387f0:	01000044 	movi	r4,1
811387f4:	113faa40 	call	8113faa4 <OSSemCreate>
811387f8:	d0a08b15 	stw	r2,-32212(gp)
811387fc:	01000044 	movi	r4,1
81138800:	113faa40 	call	8113faa4 <OSSemCreate>
81138804:	d0a08d15 	stw	r2,-32204(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81138808:	d0a01217 	ldw	r2,-32696(gp)
8113880c:	10800058 	cmpnei	r2,r2,1
81138810:	1000031e 	bne	r2,zero,81138820 <alt_main+0x84>
81138814:	01204574 	movhi	r4,33045
81138818:	21084204 	addi	r4,r4,8456
8113881c:	11382180 	call	81138218 <alt_log_printf_proc>
81138820:	d0a07f04 	addi	r2,gp,-32260
81138824:	e0bffc15 	stw	r2,-16(fp)
81138828:	00800044 	movi	r2,1
8113882c:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81138830:	e0bffd0b 	ldhu	r2,-12(fp)
81138834:	1009883a 	mov	r4,r2
81138838:	113faa40 	call	8113faa4 <OSSemCreate>
8113883c:	1007883a 	mov	r3,r2
81138840:	e0bffc17 	ldw	r2,-16(fp)
81138844:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
81138848:	d0a01217 	ldw	r2,-32696(gp)
8113884c:	10800058 	cmpnei	r2,r2,1
81138850:	1000031e 	bne	r2,zero,81138860 <alt_main+0xc4>
81138854:	01204574 	movhi	r4,33045
81138858:	21085004 	addi	r4,r4,8512
8113885c:	11382180 	call	81138218 <alt_log_printf_proc>
  alt_sys_init();
81138860:	11433340 	call	81143334 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
81138864:	d0a01217 	ldw	r2,-32696(gp)
81138868:	10800058 	cmpnei	r2,r2,1
8113886c:	1000031e 	bne	r2,zero,8113887c <alt_main+0xe0>
81138870:	01204574 	movhi	r4,33045
81138874:	21085a04 	addi	r4,r4,8552
81138878:	11382180 	call	81138218 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
8113887c:	d0a01217 	ldw	r2,-32696(gp)
81138880:	10800058 	cmpnei	r2,r2,1
81138884:	1000031e 	bne	r2,zero,81138894 <alt_main+0xf8>
81138888:	01204574 	movhi	r4,33045
8113888c:	21086304 	addi	r4,r4,8588
81138890:	11382180 	call	81138218 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
81138894:	01a04574 	movhi	r6,33045
81138898:	31886b04 	addi	r6,r6,8620
8113889c:	01604574 	movhi	r5,33045
811388a0:	29487004 	addi	r5,r5,8640
811388a4:	01204574 	movhi	r4,33045
811388a8:	21087004 	addi	r4,r4,8640
811388ac:	114bc240 	call	8114bc24 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
811388b0:	d0a01217 	ldw	r2,-32696(gp)
811388b4:	10800058 	cmpnei	r2,r2,1
811388b8:	1000031e 	bne	r2,zero,811388c8 <alt_main+0x12c>
811388bc:	01204574 	movhi	r4,33045
811388c0:	21087404 	addi	r4,r4,8656
811388c4:	11382180 	call	81138218 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
811388c8:	d0a08517 	ldw	r2,-32236(gp)
811388cc:	d0e08617 	ldw	r3,-32232(gp)
811388d0:	d1208717 	ldw	r4,-32228(gp)
811388d4:	200d883a 	mov	r6,r4
811388d8:	180b883a 	mov	r5,r3
811388dc:	1009883a 	mov	r4,r2
811388e0:	1118bcc0 	call	81118bcc <main>
811388e4:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
811388e8:	01000044 	movi	r4,1
811388ec:	11376c80 	call	811376c8 <close>
  exit (result);
811388f0:	e13ffb17 	ldw	r4,-20(fp)
811388f4:	114c3d80 	call	8114c3d8 <exit>

811388f8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811388f8:	defffe04 	addi	sp,sp,-8
811388fc:	de00012e 	bgeu	sp,et,81138904 <alt_get_errno+0xc>
81138900:	003b68fa 	trap	3
81138904:	dfc00115 	stw	ra,4(sp)
81138908:	df000015 	stw	fp,0(sp)
8113890c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81138910:	d0a01017 	ldw	r2,-32704(gp)
81138914:	10000326 	beq	r2,zero,81138924 <alt_get_errno+0x2c>
81138918:	d0a01017 	ldw	r2,-32704(gp)
8113891c:	103ee83a 	callr	r2
81138920:	00000106 	br	81138928 <alt_get_errno+0x30>
81138924:	d0a07804 	addi	r2,gp,-32288
}
81138928:	e037883a 	mov	sp,fp
8113892c:	dfc00117 	ldw	ra,4(sp)
81138930:	df000017 	ldw	fp,0(sp)
81138934:	dec00204 	addi	sp,sp,8
81138938:	f800283a 	ret

8113893c <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
8113893c:	defffd04 	addi	sp,sp,-12
81138940:	de00012e 	bgeu	sp,et,81138948 <alt_file_locked+0xc>
81138944:	003b68fa 	trap	3
81138948:	df000215 	stw	fp,8(sp)
8113894c:	df000204 	addi	fp,sp,8
81138950:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
81138954:	e0bfff17 	ldw	r2,-4(fp)
81138958:	10800217 	ldw	r2,8(r2)
8113895c:	10d00034 	orhi	r3,r2,16384
81138960:	e0bfff17 	ldw	r2,-4(fp)
81138964:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81138968:	e03ffe15 	stw	zero,-8(fp)
8113896c:	00001d06 	br	811389e4 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81138970:	00a04574 	movhi	r2,33045
81138974:	108bd904 	addi	r2,r2,12132
81138978:	e0fffe17 	ldw	r3,-8(fp)
8113897c:	18c00324 	muli	r3,r3,12
81138980:	10c5883a 	add	r2,r2,r3
81138984:	10c00017 	ldw	r3,0(r2)
81138988:	e0bfff17 	ldw	r2,-4(fp)
8113898c:	10800017 	ldw	r2,0(r2)
81138990:	1880111e 	bne	r3,r2,811389d8 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81138994:	00a04574 	movhi	r2,33045
81138998:	108bd904 	addi	r2,r2,12132
8113899c:	e0fffe17 	ldw	r3,-8(fp)
811389a0:	18c00324 	muli	r3,r3,12
811389a4:	10c5883a 	add	r2,r2,r3
811389a8:	10800204 	addi	r2,r2,8
811389ac:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811389b0:	1000090e 	bge	r2,zero,811389d8 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
811389b4:	e0bffe17 	ldw	r2,-8(fp)
811389b8:	10c00324 	muli	r3,r2,12
811389bc:	00a04574 	movhi	r2,33045
811389c0:	108bd904 	addi	r2,r2,12132
811389c4:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811389c8:	e0bfff17 	ldw	r2,-4(fp)
811389cc:	18800226 	beq	r3,r2,811389d8 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
811389d0:	00bffcc4 	movi	r2,-13
811389d4:	00000806 	br	811389f8 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
811389d8:	e0bffe17 	ldw	r2,-8(fp)
811389dc:	10800044 	addi	r2,r2,1
811389e0:	e0bffe15 	stw	r2,-8(fp)
811389e4:	d0a00f17 	ldw	r2,-32708(gp)
811389e8:	1007883a 	mov	r3,r2
811389ec:	e0bffe17 	ldw	r2,-8(fp)
811389f0:	18bfdf2e 	bgeu	r3,r2,81138970 <__reset+0xfb118970>
    }
  }
  
  /* The device is not locked */
 
  return 0;
811389f4:	0005883a 	mov	r2,zero
}
811389f8:	e037883a 	mov	sp,fp
811389fc:	df000017 	ldw	fp,0(sp)
81138a00:	dec00104 	addi	sp,sp,4
81138a04:	f800283a 	ret

81138a08 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
81138a08:	defff604 	addi	sp,sp,-40
81138a0c:	de00012e 	bgeu	sp,et,81138a14 <open+0xc>
81138a10:	003b68fa 	trap	3
81138a14:	dfc00915 	stw	ra,36(sp)
81138a18:	df000815 	stw	fp,32(sp)
81138a1c:	df000804 	addi	fp,sp,32
81138a20:	e13ffd15 	stw	r4,-12(fp)
81138a24:	e17ffe15 	stw	r5,-8(fp)
81138a28:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
81138a2c:	00bfffc4 	movi	r2,-1
81138a30:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
81138a34:	00bffb44 	movi	r2,-19
81138a38:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
81138a3c:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
81138a40:	d1600d04 	addi	r5,gp,-32716
81138a44:	e13ffd17 	ldw	r4,-12(fp)
81138a48:	114b6040 	call	8114b604 <alt_find_dev>
81138a4c:	e0bff815 	stw	r2,-32(fp)
81138a50:	e0bff817 	ldw	r2,-32(fp)
81138a54:	1000051e 	bne	r2,zero,81138a6c <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
81138a58:	e13ffd17 	ldw	r4,-12(fp)
81138a5c:	114b69c0 	call	8114b69c <alt_find_file>
81138a60:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
81138a64:	00800044 	movi	r2,1
81138a68:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
81138a6c:	e0bff817 	ldw	r2,-32(fp)
81138a70:	10002926 	beq	r2,zero,81138b18 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
81138a74:	e13ff817 	ldw	r4,-32(fp)
81138a78:	114b7ac0 	call	8114b7ac <alt_get_fd>
81138a7c:	e0bff915 	stw	r2,-28(fp)
81138a80:	e0bff917 	ldw	r2,-28(fp)
81138a84:	1000030e 	bge	r2,zero,81138a94 <open+0x8c>
    {
      status = index;
81138a88:	e0bff917 	ldw	r2,-28(fp)
81138a8c:	e0bffa15 	stw	r2,-24(fp)
81138a90:	00002306 	br	81138b20 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
81138a94:	e0bff917 	ldw	r2,-28(fp)
81138a98:	10c00324 	muli	r3,r2,12
81138a9c:	00a04574 	movhi	r2,33045
81138aa0:	108bd904 	addi	r2,r2,12132
81138aa4:	1885883a 	add	r2,r3,r2
81138aa8:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
81138aac:	e0fffe17 	ldw	r3,-8(fp)
81138ab0:	00900034 	movhi	r2,16384
81138ab4:	10bfffc4 	addi	r2,r2,-1
81138ab8:	1886703a 	and	r3,r3,r2
81138abc:	e0bffc17 	ldw	r2,-16(fp)
81138ac0:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
81138ac4:	e0bffb17 	ldw	r2,-20(fp)
81138ac8:	1000051e 	bne	r2,zero,81138ae0 <open+0xd8>
81138acc:	e13ffc17 	ldw	r4,-16(fp)
81138ad0:	113893c0 	call	8113893c <alt_file_locked>
81138ad4:	e0bffa15 	stw	r2,-24(fp)
81138ad8:	e0bffa17 	ldw	r2,-24(fp)
81138adc:	10001016 	blt	r2,zero,81138b20 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
81138ae0:	e0bff817 	ldw	r2,-32(fp)
81138ae4:	10800317 	ldw	r2,12(r2)
81138ae8:	10000826 	beq	r2,zero,81138b0c <open+0x104>
81138aec:	e0bff817 	ldw	r2,-32(fp)
81138af0:	10800317 	ldw	r2,12(r2)
81138af4:	e1ffff17 	ldw	r7,-4(fp)
81138af8:	e1bffe17 	ldw	r6,-8(fp)
81138afc:	e17ffd17 	ldw	r5,-12(fp)
81138b00:	e13ffc17 	ldw	r4,-16(fp)
81138b04:	103ee83a 	callr	r2
81138b08:	00000106 	br	81138b10 <open+0x108>
81138b0c:	0005883a 	mov	r2,zero
81138b10:	e0bffa15 	stw	r2,-24(fp)
81138b14:	00000206 	br	81138b20 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
81138b18:	00bffb44 	movi	r2,-19
81138b1c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
81138b20:	e0bffa17 	ldw	r2,-24(fp)
81138b24:	1000090e 	bge	r2,zero,81138b4c <open+0x144>
  {
    alt_release_fd (index);  
81138b28:	e13ff917 	ldw	r4,-28(fp)
81138b2c:	1138cac0 	call	81138cac <alt_release_fd>
    ALT_ERRNO = -status;
81138b30:	11388f80 	call	811388f8 <alt_get_errno>
81138b34:	1007883a 	mov	r3,r2
81138b38:	e0bffa17 	ldw	r2,-24(fp)
81138b3c:	0085c83a 	sub	r2,zero,r2
81138b40:	18800015 	stw	r2,0(r3)
    return -1;
81138b44:	00bfffc4 	movi	r2,-1
81138b48:	00000106 	br	81138b50 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
81138b4c:	e0bff917 	ldw	r2,-28(fp)
}
81138b50:	e037883a 	mov	sp,fp
81138b54:	dfc00117 	ldw	ra,4(sp)
81138b58:	df000017 	ldw	fp,0(sp)
81138b5c:	dec00204 	addi	sp,sp,8
81138b60:	f800283a 	ret

81138b64 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81138b64:	defffe04 	addi	sp,sp,-8
81138b68:	de00012e 	bgeu	sp,et,81138b70 <alt_get_errno+0xc>
81138b6c:	003b68fa 	trap	3
81138b70:	dfc00115 	stw	ra,4(sp)
81138b74:	df000015 	stw	fp,0(sp)
81138b78:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81138b7c:	d0a01017 	ldw	r2,-32704(gp)
81138b80:	10000326 	beq	r2,zero,81138b90 <alt_get_errno+0x2c>
81138b84:	d0a01017 	ldw	r2,-32704(gp)
81138b88:	103ee83a 	callr	r2
81138b8c:	00000106 	br	81138b94 <alt_get_errno+0x30>
81138b90:	d0a07804 	addi	r2,gp,-32288
}
81138b94:	e037883a 	mov	sp,fp
81138b98:	dfc00117 	ldw	ra,4(sp)
81138b9c:	df000017 	ldw	fp,0(sp)
81138ba0:	dec00204 	addi	sp,sp,8
81138ba4:	f800283a 	ret

81138ba8 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
81138ba8:	defff904 	addi	sp,sp,-28
81138bac:	de00012e 	bgeu	sp,et,81138bb4 <read+0xc>
81138bb0:	003b68fa 	trap	3
81138bb4:	dfc00615 	stw	ra,24(sp)
81138bb8:	df000515 	stw	fp,20(sp)
81138bbc:	df000504 	addi	fp,sp,20
81138bc0:	e13ffd15 	stw	r4,-12(fp)
81138bc4:	e17ffe15 	stw	r5,-8(fp)
81138bc8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81138bcc:	e0bffd17 	ldw	r2,-12(fp)
81138bd0:	10000616 	blt	r2,zero,81138bec <read+0x44>
81138bd4:	e0bffd17 	ldw	r2,-12(fp)
81138bd8:	10c00324 	muli	r3,r2,12
81138bdc:	00a04574 	movhi	r2,33045
81138be0:	108bd904 	addi	r2,r2,12132
81138be4:	1885883a 	add	r2,r3,r2
81138be8:	00000106 	br	81138bf0 <read+0x48>
81138bec:	0005883a 	mov	r2,zero
81138bf0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81138bf4:	e0bffb17 	ldw	r2,-20(fp)
81138bf8:	10002226 	beq	r2,zero,81138c84 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81138bfc:	e0bffb17 	ldw	r2,-20(fp)
81138c00:	10800217 	ldw	r2,8(r2)
81138c04:	108000cc 	andi	r2,r2,3
81138c08:	10800060 	cmpeqi	r2,r2,1
81138c0c:	1000181e 	bne	r2,zero,81138c70 <read+0xc8>
        (fd->dev->read))
81138c10:	e0bffb17 	ldw	r2,-20(fp)
81138c14:	10800017 	ldw	r2,0(r2)
81138c18:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81138c1c:	10001426 	beq	r2,zero,81138c70 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
81138c20:	e0bffb17 	ldw	r2,-20(fp)
81138c24:	10800017 	ldw	r2,0(r2)
81138c28:	10800517 	ldw	r2,20(r2)
81138c2c:	e0ffff17 	ldw	r3,-4(fp)
81138c30:	180d883a 	mov	r6,r3
81138c34:	e17ffe17 	ldw	r5,-8(fp)
81138c38:	e13ffb17 	ldw	r4,-20(fp)
81138c3c:	103ee83a 	callr	r2
81138c40:	e0bffc15 	stw	r2,-16(fp)
81138c44:	e0bffc17 	ldw	r2,-16(fp)
81138c48:	1000070e 	bge	r2,zero,81138c68 <read+0xc0>
        {
          ALT_ERRNO = -rval;
81138c4c:	1138b640 	call	81138b64 <alt_get_errno>
81138c50:	1007883a 	mov	r3,r2
81138c54:	e0bffc17 	ldw	r2,-16(fp)
81138c58:	0085c83a 	sub	r2,zero,r2
81138c5c:	18800015 	stw	r2,0(r3)
          return -1;
81138c60:	00bfffc4 	movi	r2,-1
81138c64:	00000c06 	br	81138c98 <read+0xf0>
        }
        return rval;
81138c68:	e0bffc17 	ldw	r2,-16(fp)
81138c6c:	00000a06 	br	81138c98 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
81138c70:	1138b640 	call	81138b64 <alt_get_errno>
81138c74:	1007883a 	mov	r3,r2
81138c78:	00800344 	movi	r2,13
81138c7c:	18800015 	stw	r2,0(r3)
81138c80:	00000406 	br	81138c94 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
81138c84:	1138b640 	call	81138b64 <alt_get_errno>
81138c88:	1007883a 	mov	r3,r2
81138c8c:	00801444 	movi	r2,81
81138c90:	18800015 	stw	r2,0(r3)
  }
  return -1;
81138c94:	00bfffc4 	movi	r2,-1
}
81138c98:	e037883a 	mov	sp,fp
81138c9c:	dfc00117 	ldw	ra,4(sp)
81138ca0:	df000017 	ldw	fp,0(sp)
81138ca4:	dec00204 	addi	sp,sp,8
81138ca8:	f800283a 	ret

81138cac <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
81138cac:	defffe04 	addi	sp,sp,-8
81138cb0:	de00012e 	bgeu	sp,et,81138cb8 <alt_release_fd+0xc>
81138cb4:	003b68fa 	trap	3
81138cb8:	df000115 	stw	fp,4(sp)
81138cbc:	df000104 	addi	fp,sp,4
81138cc0:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
81138cc4:	e0bfff17 	ldw	r2,-4(fp)
81138cc8:	108000d0 	cmplti	r2,r2,3
81138ccc:	10000d1e 	bne	r2,zero,81138d04 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
81138cd0:	00a04574 	movhi	r2,33045
81138cd4:	108bd904 	addi	r2,r2,12132
81138cd8:	e0ffff17 	ldw	r3,-4(fp)
81138cdc:	18c00324 	muli	r3,r3,12
81138ce0:	10c5883a 	add	r2,r2,r3
81138ce4:	10800204 	addi	r2,r2,8
81138ce8:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
81138cec:	00a04574 	movhi	r2,33045
81138cf0:	108bd904 	addi	r2,r2,12132
81138cf4:	e0ffff17 	ldw	r3,-4(fp)
81138cf8:	18c00324 	muli	r3,r3,12
81138cfc:	10c5883a 	add	r2,r2,r3
81138d00:	10000015 	stw	zero,0(r2)
  }
}
81138d04:	0001883a 	nop
81138d08:	e037883a 	mov	sp,fp
81138d0c:	df000017 	ldw	fp,0(sp)
81138d10:	dec00104 	addi	sp,sp,4
81138d14:	f800283a 	ret

81138d18 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
81138d18:	defff604 	addi	sp,sp,-40
81138d1c:	de00012e 	bgeu	sp,et,81138d24 <sbrk+0xc>
81138d20:	003b68fa 	trap	3
81138d24:	df000915 	stw	fp,36(sp)
81138d28:	df000904 	addi	fp,sp,36
81138d2c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138d30:	0005303a 	rdctl	r2,status
81138d34:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138d38:	e0fffe17 	ldw	r3,-8(fp)
81138d3c:	00bfff84 	movi	r2,-2
81138d40:	1884703a 	and	r2,r3,r2
81138d44:	1001703a 	wrctl	status,r2
  
  return context;
81138d48:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
81138d4c:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
81138d50:	d0a01317 	ldw	r2,-32692(gp)
81138d54:	10c000c4 	addi	r3,r2,3
81138d58:	00bfff04 	movi	r2,-4
81138d5c:	1884703a 	and	r2,r3,r2
81138d60:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81138d64:	d0e01317 	ldw	r3,-32692(gp)
81138d68:	e0bfff17 	ldw	r2,-4(fp)
81138d6c:	1887883a 	add	r3,r3,r2
81138d70:	00a04834 	movhi	r2,33056
81138d74:	10a80004 	addi	r2,r2,-24576
81138d78:	10c0062e 	bgeu	r2,r3,81138d94 <sbrk+0x7c>
81138d7c:	e0bff817 	ldw	r2,-32(fp)
81138d80:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138d84:	e0bff717 	ldw	r2,-36(fp)
81138d88:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
81138d8c:	00bfffc4 	movi	r2,-1
81138d90:	00001c06 	br	81138e04 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81138d94:	d0a01317 	ldw	r2,-32692(gp)
81138d98:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
81138d9c:	d0e01317 	ldw	r3,-32692(gp)
81138da0:	e0bfff17 	ldw	r2,-4(fp)
81138da4:	1885883a 	add	r2,r3,r2
81138da8:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
81138dac:	c005883a 	mov	r2,et
81138db0:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81138db4:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81138db8:	e0bffa17 	ldw	r2,-24(fp)
81138dbc:	18800c1e 	bne	r3,r2,81138df0 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
81138dc0:	d805883a 	mov	r2,sp
81138dc4:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81138dc8:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
81138dcc:	d0e01317 	ldw	r3,-32692(gp)
81138dd0:	18800136 	bltu	r3,r2,81138dd8 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81138dd4:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81138dd8:	d0a01317 	ldw	r2,-32692(gp)
81138ddc:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81138de0:	e0bffc17 	ldw	r2,-16(fp)
81138de4:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81138de8:	e0bffc17 	ldw	r2,-16(fp)
81138dec:	1031883a 	mov	et,r2
81138df0:	e0bff817 	ldw	r2,-32(fp)
81138df4:	e0bffd15 	stw	r2,-12(fp)
81138df8:	e0bffd17 	ldw	r2,-12(fp)
81138dfc:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
81138e00:	e0bffa17 	ldw	r2,-24(fp)
} 
81138e04:	e037883a 	mov	sp,fp
81138e08:	df000017 	ldw	fp,0(sp)
81138e0c:	dec00104 	addi	sp,sp,4
81138e10:	f800283a 	ret

81138e14 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81138e14:	defffa04 	addi	sp,sp,-24
81138e18:	de00012e 	bgeu	sp,et,81138e20 <alt_alarm_stop+0xc>
81138e1c:	003b68fa 	trap	3
81138e20:	df000515 	stw	fp,20(sp)
81138e24:	df000504 	addi	fp,sp,20
81138e28:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138e2c:	0005303a 	rdctl	r2,status
81138e30:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138e34:	e0fffc17 	ldw	r3,-16(fp)
81138e38:	00bfff84 	movi	r2,-2
81138e3c:	1884703a 	and	r2,r3,r2
81138e40:	1001703a 	wrctl	status,r2
  
  return context;
81138e44:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
81138e48:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81138e4c:	e0bfff17 	ldw	r2,-4(fp)
81138e50:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81138e54:	e0bffd17 	ldw	r2,-12(fp)
81138e58:	10800017 	ldw	r2,0(r2)
81138e5c:	e0fffd17 	ldw	r3,-12(fp)
81138e60:	18c00117 	ldw	r3,4(r3)
81138e64:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81138e68:	e0bffd17 	ldw	r2,-12(fp)
81138e6c:	10800117 	ldw	r2,4(r2)
81138e70:	e0fffd17 	ldw	r3,-12(fp)
81138e74:	18c00017 	ldw	r3,0(r3)
81138e78:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
81138e7c:	e0bffd17 	ldw	r2,-12(fp)
81138e80:	e0fffd17 	ldw	r3,-12(fp)
81138e84:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81138e88:	e0bffd17 	ldw	r2,-12(fp)
81138e8c:	e0fffd17 	ldw	r3,-12(fp)
81138e90:	10c00015 	stw	r3,0(r2)
81138e94:	e0bffb17 	ldw	r2,-20(fp)
81138e98:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138e9c:	e0bffe17 	ldw	r2,-8(fp)
81138ea0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81138ea4:	0001883a 	nop
81138ea8:	e037883a 	mov	sp,fp
81138eac:	df000017 	ldw	fp,0(sp)
81138eb0:	dec00104 	addi	sp,sp,4
81138eb4:	f800283a 	ret

81138eb8 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81138eb8:	defffb04 	addi	sp,sp,-20
81138ebc:	de00012e 	bgeu	sp,et,81138ec4 <alt_tick+0xc>
81138ec0:	003b68fa 	trap	3
81138ec4:	dfc00415 	stw	ra,16(sp)
81138ec8:	df000315 	stw	fp,12(sp)
81138ecc:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81138ed0:	d0a01417 	ldw	r2,-32688(gp)
81138ed4:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81138ed8:	d0a08917 	ldw	r2,-32220(gp)
81138edc:	10800044 	addi	r2,r2,1
81138ee0:	d0a08915 	stw	r2,-32220(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81138ee4:	00002e06 	br	81138fa0 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81138ee8:	e0bffd17 	ldw	r2,-12(fp)
81138eec:	10800017 	ldw	r2,0(r2)
81138ef0:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81138ef4:	e0bffd17 	ldw	r2,-12(fp)
81138ef8:	10800403 	ldbu	r2,16(r2)
81138efc:	10803fcc 	andi	r2,r2,255
81138f00:	10000426 	beq	r2,zero,81138f14 <alt_tick+0x5c>
81138f04:	d0a08917 	ldw	r2,-32220(gp)
81138f08:	1000021e 	bne	r2,zero,81138f14 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81138f0c:	e0bffd17 	ldw	r2,-12(fp)
81138f10:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81138f14:	e0bffd17 	ldw	r2,-12(fp)
81138f18:	10800217 	ldw	r2,8(r2)
81138f1c:	d0e08917 	ldw	r3,-32220(gp)
81138f20:	18801d36 	bltu	r3,r2,81138f98 <alt_tick+0xe0>
81138f24:	e0bffd17 	ldw	r2,-12(fp)
81138f28:	10800403 	ldbu	r2,16(r2)
81138f2c:	10803fcc 	andi	r2,r2,255
81138f30:	1000191e 	bne	r2,zero,81138f98 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81138f34:	e0bffd17 	ldw	r2,-12(fp)
81138f38:	10800317 	ldw	r2,12(r2)
81138f3c:	e0fffd17 	ldw	r3,-12(fp)
81138f40:	18c00517 	ldw	r3,20(r3)
81138f44:	1809883a 	mov	r4,r3
81138f48:	103ee83a 	callr	r2
81138f4c:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81138f50:	e0bfff17 	ldw	r2,-4(fp)
81138f54:	1000031e 	bne	r2,zero,81138f64 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81138f58:	e13ffd17 	ldw	r4,-12(fp)
81138f5c:	1138e140 	call	81138e14 <alt_alarm_stop>
81138f60:	00000d06 	br	81138f98 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81138f64:	e0bffd17 	ldw	r2,-12(fp)
81138f68:	10c00217 	ldw	r3,8(r2)
81138f6c:	e0bfff17 	ldw	r2,-4(fp)
81138f70:	1887883a 	add	r3,r3,r2
81138f74:	e0bffd17 	ldw	r2,-12(fp)
81138f78:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81138f7c:	e0bffd17 	ldw	r2,-12(fp)
81138f80:	10c00217 	ldw	r3,8(r2)
81138f84:	d0a08917 	ldw	r2,-32220(gp)
81138f88:	1880032e 	bgeu	r3,r2,81138f98 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81138f8c:	e0bffd17 	ldw	r2,-12(fp)
81138f90:	00c00044 	movi	r3,1
81138f94:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81138f98:	e0bffe17 	ldw	r2,-8(fp)
81138f9c:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81138fa0:	e0fffd17 	ldw	r3,-12(fp)
81138fa4:	d0a01404 	addi	r2,gp,-32688
81138fa8:	18bfcf1e 	bne	r3,r2,81138ee8 <__reset+0xfb118ee8>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
81138fac:	113a1e80 	call	8113a1e8 <OSTimeTick>
}
81138fb0:	0001883a 	nop
81138fb4:	e037883a 	mov	sp,fp
81138fb8:	dfc00117 	ldw	ra,4(sp)
81138fbc:	df000017 	ldw	fp,0(sp)
81138fc0:	dec00204 	addi	sp,sp,8
81138fc4:	f800283a 	ret

81138fc8 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81138fc8:	defffb04 	addi	sp,sp,-20
81138fcc:	de00012e 	bgeu	sp,et,81138fd4 <usleep+0xc>
81138fd0:	003b68fa 	trap	3
81138fd4:	dfc00415 	stw	ra,16(sp)
81138fd8:	df000315 	stw	fp,12(sp)
81138fdc:	df000304 	addi	fp,sp,12
81138fe0:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81138fe4:	d0a09103 	ldbu	r2,-32188(gp)
81138fe8:	10803fcc 	andi	r2,r2,255
81138fec:	1000031e 	bne	r2,zero,81138ffc <usleep+0x34>
  {
    return alt_busy_sleep (us);
81138ff0:	e13fff17 	ldw	r4,-4(fp)
81138ff4:	11375540 	call	81137554 <alt_busy_sleep>
81138ff8:	00003d06 	br	811390f0 <usleep+0x128>
81138ffc:	d0a08817 	ldw	r2,-32224(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81139000:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81139004:	e0ffff17 	ldw	r3,-4(fp)
81139008:	0090c734 	movhi	r2,17180
8113900c:	10b7a0c4 	addi	r2,r2,-8573
81139010:	1888383a 	mulxuu	r4,r3,r2
81139014:	1885383a 	mul	r2,r3,r2
81139018:	1013883a 	mov	r9,r2
8113901c:	2015883a 	mov	r10,r4
81139020:	5006d4ba 	srli	r3,r10,18
81139024:	e0bffe17 	ldw	r2,-8(fp)
81139028:	1893383a 	mul	r9,r3,r2
8113902c:	e0ffff17 	ldw	r3,-4(fp)
81139030:	0090c734 	movhi	r2,17180
81139034:	10b7a0c4 	addi	r2,r2,-8573
81139038:	1888383a 	mulxuu	r4,r3,r2
8113903c:	1885383a 	mul	r2,r3,r2
81139040:	100f883a 	mov	r7,r2
81139044:	2011883a 	mov	r8,r4
81139048:	4004d4ba 	srli	r2,r8,18
8113904c:	010003f4 	movhi	r4,15
81139050:	21109004 	addi	r4,r4,16960
81139054:	1105383a 	mul	r2,r2,r4
81139058:	1885c83a 	sub	r2,r3,r2
8113905c:	e0fffe17 	ldw	r3,-8(fp)
81139060:	10c7383a 	mul	r3,r2,r3
81139064:	0090c734 	movhi	r2,17180
81139068:	10b7a0c4 	addi	r2,r2,-8573
8113906c:	1888383a 	mulxuu	r4,r3,r2
81139070:	1885383a 	mul	r2,r3,r2
81139074:	100b883a 	mov	r5,r2
81139078:	200d883a 	mov	r6,r4
8113907c:	3004d4ba 	srli	r2,r6,18
81139080:	4885883a 	add	r2,r9,r2
81139084:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81139088:	00000706 	br	811390a8 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
8113908c:	013fffd4 	movui	r4,65535
81139090:	1141c580 	call	81141c58 <OSTimeDly>
    ticks -= 0xffff;
81139094:	e0fffd17 	ldw	r3,-12(fp)
81139098:	00bffff4 	movhi	r2,65535
8113909c:	10800044 	addi	r2,r2,1
811390a0:	1885883a 	add	r2,r3,r2
811390a4:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
811390a8:	e0bffd17 	ldw	r2,-12(fp)
811390ac:	00ffffd4 	movui	r3,65535
811390b0:	18bff636 	bltu	r3,r2,8113908c <__reset+0xfb11908c>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
811390b4:	e0bffd17 	ldw	r2,-12(fp)
811390b8:	10bfffcc 	andi	r2,r2,65535
811390bc:	1009883a 	mov	r4,r2
811390c0:	1141c580 	call	81141c58 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
811390c4:	008003f4 	movhi	r2,15
811390c8:	10909004 	addi	r2,r2,16960
811390cc:	e0fffe17 	ldw	r3,-8(fp)
811390d0:	10c7203a 	divu	r3,r2,r3
811390d4:	e0bfff17 	ldw	r2,-4(fp)
811390d8:	10c9203a 	divu	r4,r2,r3
811390dc:	20c7383a 	mul	r3,r4,r3
811390e0:	10c5c83a 	sub	r2,r2,r3
811390e4:	1009883a 	mov	r4,r2
811390e8:	11375540 	call	81137554 <alt_busy_sleep>

  return 0;  
811390ec:	0005883a 	mov	r2,zero
}
811390f0:	e037883a 	mov	sp,fp
811390f4:	dfc00117 	ldw	ra,4(sp)
811390f8:	df000017 	ldw	fp,0(sp)
811390fc:	dec00204 	addi	sp,sp,8
81139100:	f800283a 	ret

81139104 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81139104:	defffe04 	addi	sp,sp,-8
81139108:	de00012e 	bgeu	sp,et,81139110 <alt_get_errno+0xc>
8113910c:	003b68fa 	trap	3
81139110:	dfc00115 	stw	ra,4(sp)
81139114:	df000015 	stw	fp,0(sp)
81139118:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113911c:	d0a01017 	ldw	r2,-32704(gp)
81139120:	10000326 	beq	r2,zero,81139130 <alt_get_errno+0x2c>
81139124:	d0a01017 	ldw	r2,-32704(gp)
81139128:	103ee83a 	callr	r2
8113912c:	00000106 	br	81139134 <alt_get_errno+0x30>
81139130:	d0a07804 	addi	r2,gp,-32288
}
81139134:	e037883a 	mov	sp,fp
81139138:	dfc00117 	ldw	ra,4(sp)
8113913c:	df000017 	ldw	fp,0(sp)
81139140:	dec00204 	addi	sp,sp,8
81139144:	f800283a 	ret

81139148 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81139148:	defff904 	addi	sp,sp,-28
8113914c:	de00012e 	bgeu	sp,et,81139154 <write+0xc>
81139150:	003b68fa 	trap	3
81139154:	dfc00615 	stw	ra,24(sp)
81139158:	df000515 	stw	fp,20(sp)
8113915c:	df000504 	addi	fp,sp,20
81139160:	e13ffd15 	stw	r4,-12(fp)
81139164:	e17ffe15 	stw	r5,-8(fp)
81139168:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8113916c:	e0bffd17 	ldw	r2,-12(fp)
81139170:	10000616 	blt	r2,zero,8113918c <write+0x44>
81139174:	e0bffd17 	ldw	r2,-12(fp)
81139178:	10c00324 	muli	r3,r2,12
8113917c:	00a04574 	movhi	r2,33045
81139180:	108bd904 	addi	r2,r2,12132
81139184:	1885883a 	add	r2,r3,r2
81139188:	00000106 	br	81139190 <write+0x48>
8113918c:	0005883a 	mov	r2,zero
81139190:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81139194:	e0bffb17 	ldw	r2,-20(fp)
81139198:	10002426 	beq	r2,zero,8113922c <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
8113919c:	e0bffb17 	ldw	r2,-20(fp)
811391a0:	10800217 	ldw	r2,8(r2)
811391a4:	108000cc 	andi	r2,r2,3
811391a8:	10001b26 	beq	r2,zero,81139218 <write+0xd0>
811391ac:	e0bffb17 	ldw	r2,-20(fp)
811391b0:	10800017 	ldw	r2,0(r2)
811391b4:	10800617 	ldw	r2,24(r2)
811391b8:	10001726 	beq	r2,zero,81139218 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
811391bc:	e17fff17 	ldw	r5,-4(fp)
811391c0:	e13ffe17 	ldw	r4,-8(fp)
811391c4:	11384c80 	call	811384c8 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
811391c8:	e0bffb17 	ldw	r2,-20(fp)
811391cc:	10800017 	ldw	r2,0(r2)
811391d0:	10800617 	ldw	r2,24(r2)
811391d4:	e0ffff17 	ldw	r3,-4(fp)
811391d8:	180d883a 	mov	r6,r3
811391dc:	e17ffe17 	ldw	r5,-8(fp)
811391e0:	e13ffb17 	ldw	r4,-20(fp)
811391e4:	103ee83a 	callr	r2
811391e8:	e0bffc15 	stw	r2,-16(fp)
811391ec:	e0bffc17 	ldw	r2,-16(fp)
811391f0:	1000070e 	bge	r2,zero,81139210 <write+0xc8>
      {
        ALT_ERRNO = -rval;
811391f4:	11391040 	call	81139104 <alt_get_errno>
811391f8:	1007883a 	mov	r3,r2
811391fc:	e0bffc17 	ldw	r2,-16(fp)
81139200:	0085c83a 	sub	r2,zero,r2
81139204:	18800015 	stw	r2,0(r3)
        return -1;
81139208:	00bfffc4 	movi	r2,-1
8113920c:	00000c06 	br	81139240 <write+0xf8>
      }
      return rval;
81139210:	e0bffc17 	ldw	r2,-16(fp)
81139214:	00000a06 	br	81139240 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81139218:	11391040 	call	81139104 <alt_get_errno>
8113921c:	1007883a 	mov	r3,r2
81139220:	00800344 	movi	r2,13
81139224:	18800015 	stw	r2,0(r3)
81139228:	00000406 	br	8113923c <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
8113922c:	11391040 	call	81139104 <alt_get_errno>
81139230:	1007883a 	mov	r3,r2
81139234:	00801444 	movi	r2,81
81139238:	18800015 	stw	r2,0(r3)
  }
  return -1;
8113923c:	00bfffc4 	movi	r2,-1
}
81139240:	e037883a 	mov	sp,fp
81139244:	dfc00117 	ldw	ra,4(sp)
81139248:	df000017 	ldw	fp,0(sp)
8113924c:	dec00204 	addi	sp,sp,8
81139250:	f800283a 	ret

81139254 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81139254:	deffde04 	addi	sp,sp,-136
81139258:	de00012e 	bgeu	sp,et,81139260 <__env_lock+0xc>
8113925c:	003b68fa 	trap	3
81139260:	dfc02115 	stw	ra,132(sp)
81139264:	df002015 	stw	fp,128(sp)
81139268:	df002004 	addi	fp,sp,128
8113926c:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81139270:	e0bfe104 	addi	r2,fp,-124
81139274:	100b883a 	mov	r5,r2
81139278:	01003fc4 	movi	r4,255
8113927c:	1141ab40 	call	81141ab4 <OSTaskQuery>
81139280:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81139284:	e0bffe83 	ldbu	r2,-6(fp)
81139288:	10803fcc 	andi	r2,r2,255
8113928c:	10001e1e 	bne	r2,zero,81139308 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81139290:	e0bfed83 	ldbu	r2,-74(fp)
81139294:	10803fcc 	andi	r2,r2,255
81139298:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
8113929c:	d0a08b17 	ldw	r2,-32212(gp)
811392a0:	e0fffc04 	addi	r3,fp,-16
811392a4:	180b883a 	mov	r5,r3
811392a8:	1009883a 	mov	r4,r2
811392ac:	114026c0 	call	8114026c <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
811392b0:	e0bffe03 	ldbu	r2,-8(fp)
811392b4:	10803fcc 	andi	r2,r2,255
811392b8:	10000726 	beq	r2,zero,811392d8 <__env_lock+0x84>
811392bc:	d0a01617 	ldw	r2,-32680(gp)
811392c0:	e0ffe017 	ldw	r3,-128(fp)
811392c4:	1880041e 	bne	r3,r2,811392d8 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
811392c8:	d0a08a17 	ldw	r2,-32216(gp)
811392cc:	10800044 	addi	r2,r2,1
811392d0:	d0a08a15 	stw	r2,-32216(gp)
811392d4:	00000a06 	br	81139300 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
811392d8:	d0a08b17 	ldw	r2,-32212(gp)
811392dc:	e0fffe84 	addi	r3,fp,-6
811392e0:	180d883a 	mov	r6,r3
811392e4:	000b883a 	mov	r5,zero
811392e8:	1009883a 	mov	r4,r2
811392ec:	113fdcc0 	call	8113fdcc <OSSemPend>
    locks  = 1;
811392f0:	00800044 	movi	r2,1
811392f4:	d0a08a15 	stw	r2,-32216(gp)
    lockid = id;
811392f8:	e0bfe017 	ldw	r2,-128(fp)
811392fc:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81139300:	0001883a 	nop
81139304:	00000106 	br	8113930c <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81139308:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
8113930c:	e037883a 	mov	sp,fp
81139310:	dfc00117 	ldw	ra,4(sp)
81139314:	df000017 	ldw	fp,0(sp)
81139318:	dec00204 	addi	sp,sp,8
8113931c:	f800283a 	ret

81139320 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
81139320:	defffd04 	addi	sp,sp,-12
81139324:	de00012e 	bgeu	sp,et,8113932c <__env_unlock+0xc>
81139328:	003b68fa 	trap	3
8113932c:	dfc00215 	stw	ra,8(sp)
81139330:	df000115 	stw	fp,4(sp)
81139334:	df000104 	addi	fp,sp,4
81139338:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
8113933c:	d0a08a17 	ldw	r2,-32216(gp)
81139340:	10000b26 	beq	r2,zero,81139370 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
81139344:	d0a08a17 	ldw	r2,-32216(gp)
81139348:	10bfffc4 	addi	r2,r2,-1
8113934c:	d0a08a15 	stw	r2,-32216(gp)
81139350:	d0a08a17 	ldw	r2,-32216(gp)
81139354:	1000071e 	bne	r2,zero,81139374 <__env_unlock+0x54>
  {
    lockid = -1;
81139358:	00bfffc4 	movi	r2,-1
8113935c:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
81139360:	d0a08b17 	ldw	r2,-32212(gp)
81139364:	1009883a 	mov	r4,r2
81139368:	11401540 	call	81140154 <OSSemPost>
8113936c:	00000106 	br	81139374 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
81139370:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81139374:	e037883a 	mov	sp,fp
81139378:	dfc00117 	ldw	ra,4(sp)
8113937c:	df000017 	ldw	fp,0(sp)
81139380:	dec00204 	addi	sp,sp,8
81139384:	f800283a 	ret

81139388 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
81139388:	deffda04 	addi	sp,sp,-152
8113938c:	de00012e 	bgeu	sp,et,81139394 <__malloc_lock+0xc>
81139390:	003b68fa 	trap	3
81139394:	dfc02515 	stw	ra,148(sp)
81139398:	df002415 	stw	fp,144(sp)
8113939c:	df002404 	addi	fp,sp,144
811393a0:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811393a4:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
811393a8:	d0a09103 	ldbu	r2,-32188(gp)
811393ac:	10803fcc 	andi	r2,r2,255
811393b0:	10800060 	cmpeqi	r2,r2,1
811393b4:	10003626 	beq	r2,zero,81139490 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
811393b8:	e0bfe104 	addi	r2,fp,-124
811393bc:	100b883a 	mov	r5,r2
811393c0:	01003fc4 	movi	r4,255
811393c4:	1141ab40 	call	81141ab4 <OSTaskQuery>
811393c8:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
811393cc:	e0bffe83 	ldbu	r2,-6(fp)
811393d0:	10803fcc 	andi	r2,r2,255
811393d4:	1000301e 	bne	r2,zero,81139498 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
811393d8:	e0bfed83 	ldbu	r2,-74(fp)
811393dc:	10803fcc 	andi	r2,r2,255
811393e0:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
811393e4:	d0a08d17 	ldw	r2,-32204(gp)
811393e8:	e0fffc04 	addi	r3,fp,-16
811393ec:	180b883a 	mov	r5,r3
811393f0:	1009883a 	mov	r4,r2
811393f4:	114026c0 	call	8114026c <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811393f8:	0005303a 	rdctl	r2,status
811393fc:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139400:	e0ffe017 	ldw	r3,-128(fp)
81139404:	00bfff84 	movi	r2,-2
81139408:	1884703a 	and	r2,r3,r2
8113940c:	1001703a 	wrctl	status,r2
  
  return context;
81139410:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
81139414:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81139418:	e0bffc0b 	ldhu	r2,-16(fp)
8113941c:	10bfffcc 	andi	r2,r2,65535
81139420:	10000b1e 	bne	r2,zero,81139450 <__malloc_lock+0xc8>
81139424:	d0a01717 	ldw	r2,-32676(gp)
81139428:	e0ffdd17 	ldw	r3,-140(fp)
8113942c:	1880081e 	bne	r3,r2,81139450 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
81139430:	d0a08c17 	ldw	r2,-32208(gp)
81139434:	10800044 	addi	r2,r2,1
81139438:	d0a08c15 	stw	r2,-32208(gp)
8113943c:	e0bfdc17 	ldw	r2,-144(fp)
81139440:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139444:	e0bfde17 	ldw	r2,-136(fp)
81139448:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
8113944c:	00000e06 	br	81139488 <__malloc_lock+0x100>
81139450:	e0bfdc17 	ldw	r2,-144(fp)
81139454:	e0bfdf15 	stw	r2,-132(fp)
81139458:	e0bfdf17 	ldw	r2,-132(fp)
8113945c:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
81139460:	d0a08d17 	ldw	r2,-32204(gp)
81139464:	e0fffe84 	addi	r3,fp,-6
81139468:	180d883a 	mov	r6,r3
8113946c:	000b883a 	mov	r5,zero
81139470:	1009883a 	mov	r4,r2
81139474:	113fdcc0 	call	8113fdcc <OSSemPend>
    locks  = 1;
81139478:	00800044 	movi	r2,1
8113947c:	d0a08c15 	stw	r2,-32208(gp)
    lockid = id;
81139480:	e0bfdd17 	ldw	r2,-140(fp)
81139484:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81139488:	0001883a 	nop
8113948c:	00000306 	br	8113949c <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
81139490:	0001883a 	nop
81139494:	00000106 	br	8113949c <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81139498:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
8113949c:	e037883a 	mov	sp,fp
811394a0:	dfc00117 	ldw	ra,4(sp)
811394a4:	df000017 	ldw	fp,0(sp)
811394a8:	dec00204 	addi	sp,sp,8
811394ac:	f800283a 	ret

811394b0 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
811394b0:	defff804 	addi	sp,sp,-32
811394b4:	de00012e 	bgeu	sp,et,811394bc <__malloc_unlock+0xc>
811394b8:	003b68fa 	trap	3
811394bc:	dfc00715 	stw	ra,28(sp)
811394c0:	df000615 	stw	fp,24(sp)
811394c4:	df000604 	addi	fp,sp,24
811394c8:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811394cc:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
811394d0:	d0a09103 	ldbu	r2,-32188(gp)
811394d4:	10803fcc 	andi	r2,r2,255
811394d8:	10800060 	cmpeqi	r2,r2,1
811394dc:	10002326 	beq	r2,zero,8113956c <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811394e0:	0005303a 	rdctl	r2,status
811394e4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811394e8:	e0fffe17 	ldw	r3,-8(fp)
811394ec:	00bfff84 	movi	r2,-2
811394f0:	1884703a 	and	r2,r3,r2
811394f4:	1001703a 	wrctl	status,r2
  
  return context;
811394f8:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
811394fc:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
81139500:	d0a08c17 	ldw	r2,-32208(gp)
81139504:	1000051e 	bne	r2,zero,8113951c <__malloc_unlock+0x6c>
81139508:	e0bffa17 	ldw	r2,-24(fp)
8113950c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139510:	e0bffb17 	ldw	r2,-20(fp)
81139514:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81139518:	00001506 	br	81139570 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
8113951c:	d0a08c17 	ldw	r2,-32208(gp)
81139520:	10bfffc4 	addi	r2,r2,-1
81139524:	d0a08c15 	stw	r2,-32208(gp)
81139528:	d0a08c17 	ldw	r2,-32208(gp)
8113952c:	10000a1e 	bne	r2,zero,81139558 <__malloc_unlock+0xa8>
  {
    lockid = -1;
81139530:	00bfffc4 	movi	r2,-1
81139534:	d0a01715 	stw	r2,-32676(gp)
81139538:	e0bffa17 	ldw	r2,-24(fp)
8113953c:	e0bffc15 	stw	r2,-16(fp)
81139540:	e0bffc17 	ldw	r2,-16(fp)
81139544:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81139548:	d0a08d17 	ldw	r2,-32204(gp)
8113954c:	1009883a 	mov	r4,r2
81139550:	11401540 	call	81140154 <OSSemPost>
81139554:	00000606 	br	81139570 <__malloc_unlock+0xc0>
81139558:	e0bffa17 	ldw	r2,-24(fp)
8113955c:	e0bffd15 	stw	r2,-12(fp)
81139560:	e0bffd17 	ldw	r2,-12(fp)
81139564:	1001703a 	wrctl	status,r2
81139568:	00000106 	br	81139570 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
8113956c:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81139570:	e037883a 	mov	sp,fp
81139574:	dfc00117 	ldw	ra,4(sp)
81139578:	df000017 	ldw	fp,0(sp)
8113957c:	dec00204 	addi	sp,sp,8
81139580:	f800283a 	ret

81139584 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81139584:	defff704 	addi	sp,sp,-36
81139588:	de00012e 	bgeu	sp,et,81139590 <OSEventNameGet+0xc>
8113958c:	003b68fa 	trap	3
81139590:	dfc00815 	stw	ra,32(sp)
81139594:	df000715 	stw	fp,28(sp)
81139598:	df000704 	addi	fp,sp,28
8113959c:	e13ffd15 	stw	r4,-12(fp)
811395a0:	e17ffe15 	stw	r5,-8(fp)
811395a4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811395a8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811395ac:	e0bfff17 	ldw	r2,-4(fp)
811395b0:	1000021e 	bne	r2,zero,811395bc <OSEventNameGet+0x38>
        return (0);
811395b4:	0005883a 	mov	r2,zero
811395b8:	00003706 	br	81139698 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
811395bc:	e0bffd17 	ldw	r2,-12(fp)
811395c0:	1000051e 	bne	r2,zero,811395d8 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
811395c4:	e0bfff17 	ldw	r2,-4(fp)
811395c8:	00c00104 	movi	r3,4
811395cc:	10c00005 	stb	r3,0(r2)
        return (0);
811395d0:	0005883a 	mov	r2,zero
811395d4:	00003006 	br	81139698 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811395d8:	e0bffe17 	ldw	r2,-8(fp)
811395dc:	1000051e 	bne	r2,zero,811395f4 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
811395e0:	e0bfff17 	ldw	r2,-4(fp)
811395e4:	00c00304 	movi	r3,12
811395e8:	10c00005 	stb	r3,0(r2)
        return (0);
811395ec:	0005883a 	mov	r2,zero
811395f0:	00002906 	br	81139698 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811395f4:	d0a0a103 	ldbu	r2,-32124(gp)
811395f8:	10803fcc 	andi	r2,r2,255
811395fc:	10000526 	beq	r2,zero,81139614 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
81139600:	e0bfff17 	ldw	r2,-4(fp)
81139604:	00c00444 	movi	r3,17
81139608:	10c00005 	stb	r3,0(r2)
        return (0);
8113960c:	0005883a 	mov	r2,zero
81139610:	00002106 	br	81139698 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
81139614:	e0bffd17 	ldw	r2,-12(fp)
81139618:	10800003 	ldbu	r2,0(r2)
8113961c:	10803fcc 	andi	r2,r2,255
81139620:	10bfffc4 	addi	r2,r2,-1
81139624:	10800128 	cmpgeui	r2,r2,4
81139628:	10000526 	beq	r2,zero,81139640 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
8113962c:	e0bfff17 	ldw	r2,-4(fp)
81139630:	00c00044 	movi	r3,1
81139634:	10c00005 	stb	r3,0(r2)
             return (0);
81139638:	0005883a 	mov	r2,zero
8113963c:	00001606 	br	81139698 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81139640:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139644:	0005303a 	rdctl	r2,status
81139648:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113964c:	e0fffb17 	ldw	r3,-20(fp)
81139650:	00bfff84 	movi	r2,-2
81139654:	1884703a 	and	r2,r3,r2
81139658:	1001703a 	wrctl	status,r2
  
  return context;
8113965c:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
81139660:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
81139664:	e0bffd17 	ldw	r2,-12(fp)
81139668:	10800444 	addi	r2,r2,17
8113966c:	100b883a 	mov	r5,r2
81139670:	e13ffe17 	ldw	r4,-8(fp)
81139674:	113b0700 	call	8113b070 <OS_StrCopy>
81139678:	e0bffa05 	stb	r2,-24(fp)
8113967c:	e0bff917 	ldw	r2,-28(fp)
81139680:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139684:	e0bffc17 	ldw	r2,-16(fp)
81139688:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113968c:	e0bfff17 	ldw	r2,-4(fp)
81139690:	10000005 	stb	zero,0(r2)
    return (len);
81139694:	e0bffa03 	ldbu	r2,-24(fp)
}
81139698:	e037883a 	mov	sp,fp
8113969c:	dfc00117 	ldw	ra,4(sp)
811396a0:	df000017 	ldw	fp,0(sp)
811396a4:	dec00204 	addi	sp,sp,8
811396a8:	f800283a 	ret

811396ac <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
811396ac:	defff604 	addi	sp,sp,-40
811396b0:	de00012e 	bgeu	sp,et,811396b8 <OSEventNameSet+0xc>
811396b4:	003b68fa 	trap	3
811396b8:	dfc00915 	stw	ra,36(sp)
811396bc:	df000815 	stw	fp,32(sp)
811396c0:	df000804 	addi	fp,sp,32
811396c4:	e13ffd15 	stw	r4,-12(fp)
811396c8:	e17ffe15 	stw	r5,-8(fp)
811396cc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811396d0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811396d4:	e0bfff17 	ldw	r2,-4(fp)
811396d8:	10004026 	beq	r2,zero,811397dc <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
811396dc:	e0bffd17 	ldw	r2,-12(fp)
811396e0:	1000041e 	bne	r2,zero,811396f4 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
811396e4:	e0bfff17 	ldw	r2,-4(fp)
811396e8:	00c00104 	movi	r3,4
811396ec:	10c00005 	stb	r3,0(r2)
        return;
811396f0:	00003b06 	br	811397e0 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811396f4:	e0bffe17 	ldw	r2,-8(fp)
811396f8:	1000041e 	bne	r2,zero,8113970c <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
811396fc:	e0bfff17 	ldw	r2,-4(fp)
81139700:	00c00304 	movi	r3,12
81139704:	10c00005 	stb	r3,0(r2)
        return;
81139708:	00003506 	br	811397e0 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113970c:	d0a0a103 	ldbu	r2,-32124(gp)
81139710:	10803fcc 	andi	r2,r2,255
81139714:	10000426 	beq	r2,zero,81139728 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81139718:	e0bfff17 	ldw	r2,-4(fp)
8113971c:	00c00484 	movi	r3,18
81139720:	10c00005 	stb	r3,0(r2)
        return;
81139724:	00002e06 	br	811397e0 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
81139728:	e0bffd17 	ldw	r2,-12(fp)
8113972c:	10800003 	ldbu	r2,0(r2)
81139730:	10803fcc 	andi	r2,r2,255
81139734:	10bfffc4 	addi	r2,r2,-1
81139738:	10800128 	cmpgeui	r2,r2,4
8113973c:	10000426 	beq	r2,zero,81139750 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81139740:	e0bfff17 	ldw	r2,-4(fp)
81139744:	00c00044 	movi	r3,1
81139748:	10c00005 	stb	r3,0(r2)
             return;
8113974c:	00002406 	br	811397e0 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81139750:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139754:	0005303a 	rdctl	r2,status
81139758:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113975c:	e0fffc17 	ldw	r3,-16(fp)
81139760:	00bfff84 	movi	r2,-2
81139764:	1884703a 	and	r2,r3,r2
81139768:	1001703a 	wrctl	status,r2
  
  return context;
8113976c:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
81139770:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
81139774:	e13ffe17 	ldw	r4,-8(fp)
81139778:	113b0ec0 	call	8113b0ec <OS_StrLen>
8113977c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
81139780:	e0bffa03 	ldbu	r2,-24(fp)
81139784:	10800830 	cmpltui	r2,r2,32
81139788:	1000081e 	bne	r2,zero,811397ac <OSEventNameSet+0x100>
8113978c:	e0bff817 	ldw	r2,-32(fp)
81139790:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139794:	e0bff917 	ldw	r2,-28(fp)
81139798:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
8113979c:	e0bfff17 	ldw	r2,-4(fp)
811397a0:	00c002c4 	movi	r3,11
811397a4:	10c00005 	stb	r3,0(r2)
        return;
811397a8:	00000d06 	br	811397e0 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
811397ac:	e0bffd17 	ldw	r2,-12(fp)
811397b0:	10800444 	addi	r2,r2,17
811397b4:	e17ffe17 	ldw	r5,-8(fp)
811397b8:	1009883a 	mov	r4,r2
811397bc:	113b0700 	call	8113b070 <OS_StrCopy>
811397c0:	e0bff817 	ldw	r2,-32(fp)
811397c4:	e0bffb15 	stw	r2,-20(fp)
811397c8:	e0bffb17 	ldw	r2,-20(fp)
811397cc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811397d0:	e0bfff17 	ldw	r2,-4(fp)
811397d4:	10000005 	stb	zero,0(r2)
811397d8:	00000106 	br	811397e0 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
811397dc:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
811397e0:	e037883a 	mov	sp,fp
811397e4:	dfc00117 	ldw	ra,4(sp)
811397e8:	df000017 	ldw	fp,0(sp)
811397ec:	dec00204 	addi	sp,sp,8
811397f0:	f800283a 	ret

811397f4 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
811397f4:	deffed04 	addi	sp,sp,-76
811397f8:	de00012e 	bgeu	sp,et,81139800 <OSEventPendMulti+0xc>
811397fc:	003b68fa 	trap	3
81139800:	dfc01215 	stw	ra,72(sp)
81139804:	df001115 	stw	fp,68(sp)
81139808:	df001104 	addi	fp,sp,68
8113980c:	e13ffc15 	stw	r4,-16(fp)
81139810:	e17ffd15 	stw	r5,-12(fp)
81139814:	e1bffe15 	stw	r6,-8(fp)
81139818:	3805883a 	mov	r2,r7
8113981c:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
81139820:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
81139824:	e0800217 	ldw	r2,8(fp)
81139828:	1000021e 	bne	r2,zero,81139834 <OSEventPendMulti+0x40>
        return (0);
8113982c:	0005883a 	mov	r2,zero
81139830:	00015006 	br	81139d74 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
81139834:	e0bffc17 	ldw	r2,-16(fp)
81139838:	1000051e 	bne	r2,zero,81139850 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
8113983c:	e0800217 	ldw	r2,8(fp)
81139840:	00c00104 	movi	r3,4
81139844:	10c00005 	stb	r3,0(r2)
        return (0);
81139848:	0005883a 	mov	r2,zero
8113984c:	00014906 	br	81139d74 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
81139850:	e0bffd17 	ldw	r2,-12(fp)
81139854:	1000051e 	bne	r2,zero,8113986c <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
81139858:	e0800217 	ldw	r2,8(fp)
8113985c:	00c00104 	movi	r3,4
81139860:	10c00005 	stb	r3,0(r2)
        return (0);
81139864:	0005883a 	mov	r2,zero
81139868:	00014206 	br	81139d74 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
8113986c:	e0bffe17 	ldw	r2,-8(fp)
81139870:	1000051e 	bne	r2,zero,81139888 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
81139874:	e0800217 	ldw	r2,8(fp)
81139878:	00c00104 	movi	r3,4
8113987c:	10c00005 	stb	r3,0(r2)
        return (0);
81139880:	0005883a 	mov	r2,zero
81139884:	00013b06 	br	81139d74 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
81139888:	e0bffd17 	ldw	r2,-12(fp)
8113988c:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
81139890:	e0bffc17 	ldw	r2,-16(fp)
81139894:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
81139898:	e0bfef17 	ldw	r2,-68(fp)
8113989c:	10800017 	ldw	r2,0(r2)
811398a0:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
811398a4:	00001506 	br	811398fc <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
811398a8:	e0bff017 	ldw	r2,-64(fp)
811398ac:	10800003 	ldbu	r2,0(r2)
811398b0:	10803fcc 	andi	r2,r2,255
811398b4:	10c000a0 	cmpeqi	r3,r2,2
811398b8:	1800071e 	bne	r3,zero,811398d8 <OSEventPendMulti+0xe4>
811398bc:	108000e0 	cmpeqi	r2,r2,3
811398c0:	1000071e 	bne	r2,zero,811398e0 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
811398c4:	e0800217 	ldw	r2,8(fp)
811398c8:	00c00044 	movi	r3,1
811398cc:	10c00005 	stb	r3,0(r2)
                 return (0);
811398d0:	0005883a 	mov	r2,zero
811398d4:	00012706 	br	81139d74 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
811398d8:	0001883a 	nop
811398dc:	00000106 	br	811398e4 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
811398e0:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
811398e4:	e0bfef17 	ldw	r2,-68(fp)
811398e8:	10800104 	addi	r2,r2,4
811398ec:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
811398f0:	e0bfef17 	ldw	r2,-68(fp)
811398f4:	10800017 	ldw	r2,0(r2)
811398f8:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
811398fc:	e0bff017 	ldw	r2,-64(fp)
81139900:	103fe91e 	bne	r2,zero,811398a8 <__reset+0xfb1198a8>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
81139904:	d0a0a103 	ldbu	r2,-32124(gp)
81139908:	10803fcc 	andi	r2,r2,255
8113990c:	10000526 	beq	r2,zero,81139924 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
81139910:	e0800217 	ldw	r2,8(fp)
81139914:	00c00084 	movi	r3,2
81139918:	10c00005 	stb	r3,0(r2)
        return (0);
8113991c:	0005883a 	mov	r2,zero
81139920:	00011406 	br	81139d74 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
81139924:	d0a08f03 	ldbu	r2,-32196(gp)
81139928:	10803fcc 	andi	r2,r2,255
8113992c:	10000526 	beq	r2,zero,81139944 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
81139930:	e0800217 	ldw	r2,8(fp)
81139934:	00c00344 	movi	r3,13
81139938:	10c00005 	stb	r3,0(r2)
        return (0);
8113993c:	0005883a 	mov	r2,zero
81139940:	00010c06 	br	81139d74 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139944:	0005303a 	rdctl	r2,status
81139948:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113994c:	e0fffb17 	ldw	r3,-20(fp)
81139950:	00bfff84 	movi	r2,-2
81139954:	1884703a 	and	r2,r3,r2
81139958:	1001703a 	wrctl	status,r2
  
  return context;
8113995c:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
81139960:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
81139964:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
81139968:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
8113996c:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
81139970:	e0bffc17 	ldw	r2,-16(fp)
81139974:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
81139978:	e0bfef17 	ldw	r2,-68(fp)
8113997c:	10800017 	ldw	r2,0(r2)
81139980:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81139984:	00006406 	br	81139b18 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
81139988:	e0bff017 	ldw	r2,-64(fp)
8113998c:	10800003 	ldbu	r2,0(r2)
81139990:	10803fcc 	andi	r2,r2,255
81139994:	10c000a0 	cmpeqi	r3,r2,2
81139998:	18001f1e 	bne	r3,zero,81139a18 <OSEventPendMulti+0x224>
8113999c:	108000e0 	cmpeqi	r2,r2,3
811399a0:	10004c26 	beq	r2,zero,81139ad4 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
811399a4:	e0bff017 	ldw	r2,-64(fp)
811399a8:	1080020b 	ldhu	r2,8(r2)
811399ac:	10bfffcc 	andi	r2,r2,65535
811399b0:	10001526 	beq	r2,zero,81139a08 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
811399b4:	e0bff017 	ldw	r2,-64(fp)
811399b8:	1080020b 	ldhu	r2,8(r2)
811399bc:	10bfffc4 	addi	r2,r2,-1
811399c0:	1007883a 	mov	r3,r2
811399c4:	e0bff017 	ldw	r2,-64(fp)
811399c8:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
811399cc:	e0bffd17 	ldw	r2,-12(fp)
811399d0:	10c00104 	addi	r3,r2,4
811399d4:	e0fffd15 	stw	r3,-12(fp)
811399d8:	e0fff017 	ldw	r3,-64(fp)
811399dc:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
811399e0:	00800044 	movi	r2,1
811399e4:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
811399e8:	e0bffe17 	ldw	r2,-8(fp)
811399ec:	10c00104 	addi	r3,r2,4
811399f0:	e0fffe15 	stw	r3,-8(fp)
811399f4:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
811399f8:	e0bff18b 	ldhu	r2,-58(fp)
811399fc:	10800044 	addi	r2,r2,1
81139a00:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
81139a04:	00003e06 	br	81139b00 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
81139a08:	e0bff203 	ldbu	r2,-56(fp)
81139a0c:	10800054 	ori	r2,r2,1
81139a10:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81139a14:	00003a06 	br	81139b00 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
81139a18:	e0bff017 	ldw	r2,-64(fp)
81139a1c:	10800117 	ldw	r2,4(r2)
81139a20:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
81139a24:	e0bff517 	ldw	r2,-44(fp)
81139a28:	1080058b 	ldhu	r2,22(r2)
81139a2c:	10bfffcc 	andi	r2,r2,65535
81139a30:	10002426 	beq	r2,zero,81139ac4 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
81139a34:	e0bffe17 	ldw	r2,-8(fp)
81139a38:	10c00104 	addi	r3,r2,4
81139a3c:	e0fffe15 	stw	r3,-8(fp)
81139a40:	e0fff517 	ldw	r3,-44(fp)
81139a44:	18c00417 	ldw	r3,16(r3)
81139a48:	19400104 	addi	r5,r3,4
81139a4c:	e13ff517 	ldw	r4,-44(fp)
81139a50:	21400415 	stw	r5,16(r4)
81139a54:	18c00017 	ldw	r3,0(r3)
81139a58:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
81139a5c:	e0bff517 	ldw	r2,-44(fp)
81139a60:	10c00417 	ldw	r3,16(r2)
81139a64:	e0bff517 	ldw	r2,-44(fp)
81139a68:	10800217 	ldw	r2,8(r2)
81139a6c:	1880041e 	bne	r3,r2,81139a80 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
81139a70:	e0bff517 	ldw	r2,-44(fp)
81139a74:	10c00117 	ldw	r3,4(r2)
81139a78:	e0bff517 	ldw	r2,-44(fp)
81139a7c:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
81139a80:	e0bff517 	ldw	r2,-44(fp)
81139a84:	1080058b 	ldhu	r2,22(r2)
81139a88:	10bfffc4 	addi	r2,r2,-1
81139a8c:	1007883a 	mov	r3,r2
81139a90:	e0bff517 	ldw	r2,-44(fp)
81139a94:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
81139a98:	e0bffd17 	ldw	r2,-12(fp)
81139a9c:	10c00104 	addi	r3,r2,4
81139aa0:	e0fffd15 	stw	r3,-12(fp)
81139aa4:	e0fff017 	ldw	r3,-64(fp)
81139aa8:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
81139aac:	00800044 	movi	r2,1
81139ab0:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
81139ab4:	e0bff18b 	ldhu	r2,-58(fp)
81139ab8:	10800044 	addi	r2,r2,1
81139abc:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
81139ac0:	00000f06 	br	81139b00 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
81139ac4:	e0bff203 	ldbu	r2,-56(fp)
81139ac8:	10800114 	ori	r2,r2,4
81139acc:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81139ad0:	00000b06 	br	81139b00 <OSEventPendMulti+0x30c>
81139ad4:	e0bff317 	ldw	r2,-52(fp)
81139ad8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139adc:	e0bff417 	ldw	r2,-48(fp)
81139ae0:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
81139ae4:	e0bffd17 	ldw	r2,-12(fp)
81139ae8:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
81139aec:	e0800217 	ldw	r2,8(fp)
81139af0:	00c00044 	movi	r3,1
81139af4:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
81139af8:	e0bff18b 	ldhu	r2,-58(fp)
81139afc:	00009d06 	br	81139d74 <OSEventPendMulti+0x580>
        }
        pevents++;
81139b00:	e0bfef17 	ldw	r2,-68(fp)
81139b04:	10800104 	addi	r2,r2,4
81139b08:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81139b0c:	e0bfef17 	ldw	r2,-68(fp)
81139b10:	10800017 	ldw	r2,0(r2)
81139b14:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81139b18:	e0bff017 	ldw	r2,-64(fp)
81139b1c:	103f9a1e 	bne	r2,zero,81139988 <__reset+0xfb119988>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
81139b20:	e0bff103 	ldbu	r2,-60(fp)
81139b24:	10800058 	cmpnei	r2,r2,1
81139b28:	10000a1e 	bne	r2,zero,81139b54 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
81139b2c:	e0bffd17 	ldw	r2,-12(fp)
81139b30:	10000015 	stw	zero,0(r2)
81139b34:	e0bff317 	ldw	r2,-52(fp)
81139b38:	e0bff615 	stw	r2,-40(fp)
81139b3c:	e0bff617 	ldw	r2,-40(fp)
81139b40:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
81139b44:	e0800217 	ldw	r2,8(fp)
81139b48:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
81139b4c:	e0bff18b 	ldhu	r2,-58(fp)
81139b50:	00008806 	br	81139d74 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
81139b54:	d0a0a217 	ldw	r2,-32120(gp)
81139b58:	d0e0a217 	ldw	r3,-32120(gp)
81139b5c:	19000c03 	ldbu	r4,48(r3)
81139b60:	e0fff203 	ldbu	r3,-56(fp)
81139b64:	20c6b03a 	or	r3,r4,r3
81139b68:	1809883a 	mov	r4,r3
81139b6c:	00ffe004 	movi	r3,-128
81139b70:	20c6b03a 	or	r3,r4,r3
81139b74:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81139b78:	d0a0a217 	ldw	r2,-32120(gp)
81139b7c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
81139b80:	d0a0a217 	ldw	r2,-32120(gp)
81139b84:	e0ffff0b 	ldhu	r3,-4(fp)
81139b88:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
81139b8c:	e13ffc17 	ldw	r4,-16(fp)
81139b90:	113a7180 	call	8113a718 <OS_EventTaskWaitMulti>
81139b94:	e0bff317 	ldw	r2,-52(fp)
81139b98:	e0bff915 	stw	r2,-28(fp)
81139b9c:	e0bff917 	ldw	r2,-28(fp)
81139ba0:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
81139ba4:	113af1c0 	call	8113af1c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139ba8:	0005303a 	rdctl	r2,status
81139bac:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139bb0:	e0fff717 	ldw	r3,-36(fp)
81139bb4:	00bfff84 	movi	r2,-2
81139bb8:	1884703a 	and	r2,r3,r2
81139bbc:	1001703a 	wrctl	status,r2
  
  return context;
81139bc0:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
81139bc4:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
81139bc8:	d0a0a217 	ldw	r2,-32120(gp)
81139bcc:	10800c43 	ldbu	r2,49(r2)
81139bd0:	10803fcc 	andi	r2,r2,255
81139bd4:	10000226 	beq	r2,zero,81139be0 <OSEventPendMulti+0x3ec>
81139bd8:	108000a0 	cmpeqi	r2,r2,2
81139bdc:	10001826 	beq	r2,zero,81139c40 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
81139be0:	d0a0a217 	ldw	r2,-32120(gp)
81139be4:	10800717 	ldw	r2,28(r2)
81139be8:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
81139bec:	e0bff017 	ldw	r2,-64(fp)
81139bf0:	10000b26 	beq	r2,zero,81139c20 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
81139bf4:	e0bffd17 	ldw	r2,-12(fp)
81139bf8:	10c00104 	addi	r3,r2,4
81139bfc:	e0fffd15 	stw	r3,-12(fp)
81139c00:	e0fff017 	ldw	r3,-64(fp)
81139c04:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
81139c08:	e0bffd17 	ldw	r2,-12(fp)
81139c0c:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
81139c10:	e0bff18b 	ldhu	r2,-58(fp)
81139c14:	10800044 	addi	r2,r2,1
81139c18:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
81139c1c:	00000d06 	br	81139c54 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
81139c20:	d0a0a217 	ldw	r2,-32120(gp)
81139c24:	00c00044 	movi	r3,1
81139c28:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81139c2c:	d0a0a217 	ldw	r2,-32120(gp)
81139c30:	e17ffc17 	ldw	r5,-16(fp)
81139c34:	1009883a 	mov	r4,r2
81139c38:	113a9300 	call	8113a930 <OS_EventTaskRemoveMulti>
             }
			 break;
81139c3c:	00000506 	br	81139c54 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81139c40:	d0a0a217 	ldw	r2,-32120(gp)
81139c44:	e17ffc17 	ldw	r5,-16(fp)
81139c48:	1009883a 	mov	r4,r2
81139c4c:	113a9300 	call	8113a930 <OS_EventTaskRemoveMulti>
             break;
81139c50:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
81139c54:	d0a0a217 	ldw	r2,-32120(gp)
81139c58:	10800c43 	ldbu	r2,49(r2)
81139c5c:	10803fcc 	andi	r2,r2,255
81139c60:	10000326 	beq	r2,zero,81139c70 <OSEventPendMulti+0x47c>
81139c64:	108000a0 	cmpeqi	r2,r2,2
81139c68:	1000231e 	bne	r2,zero,81139cf8 <OSEventPendMulti+0x504>
81139c6c:	00002a06 	br	81139d18 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
81139c70:	e0bff017 	ldw	r2,-64(fp)
81139c74:	10800003 	ldbu	r2,0(r2)
81139c78:	10803fcc 	andi	r2,r2,255
81139c7c:	0080100e 	bge	zero,r2,81139cc0 <OSEventPendMulti+0x4cc>
81139c80:	10c000d0 	cmplti	r3,r2,3
81139c84:	1800071e 	bne	r3,zero,81139ca4 <OSEventPendMulti+0x4b0>
81139c88:	108000e0 	cmpeqi	r2,r2,3
81139c8c:	10000c26 	beq	r2,zero,81139cc0 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
81139c90:	e0bffe17 	ldw	r2,-8(fp)
81139c94:	10c00104 	addi	r3,r2,4
81139c98:	e0fffe15 	stw	r3,-8(fp)
81139c9c:	10000015 	stw	zero,0(r2)
                      break;
81139ca0:	00001206 	br	81139cec <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
81139ca4:	e0bffe17 	ldw	r2,-8(fp)
81139ca8:	10c00104 	addi	r3,r2,4
81139cac:	e0fffe15 	stw	r3,-8(fp)
81139cb0:	d0e0a217 	ldw	r3,-32120(gp)
81139cb4:	18c00917 	ldw	r3,36(r3)
81139cb8:	10c00015 	stw	r3,0(r2)
                      break;
81139cbc:	00000b06 	br	81139cec <OSEventPendMulti+0x4f8>
81139cc0:	e0bff317 	ldw	r2,-52(fp)
81139cc4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139cc8:	e0bff817 	ldw	r2,-32(fp)
81139ccc:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
81139cd0:	e0bffd17 	ldw	r2,-12(fp)
81139cd4:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81139cd8:	e0800217 	ldw	r2,8(fp)
81139cdc:	00c00044 	movi	r3,1
81139ce0:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81139ce4:	e0bff18b 	ldhu	r2,-58(fp)
81139ce8:	00002206 	br	81139d74 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
81139cec:	e0800217 	ldw	r2,8(fp)
81139cf0:	10000005 	stb	zero,0(r2)
             break;
81139cf4:	00001006 	br	81139d38 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
81139cf8:	e0bffe17 	ldw	r2,-8(fp)
81139cfc:	10c00104 	addi	r3,r2,4
81139d00:	e0fffe15 	stw	r3,-8(fp)
81139d04:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
81139d08:	e0800217 	ldw	r2,8(fp)
81139d0c:	00c00384 	movi	r3,14
81139d10:	10c00005 	stb	r3,0(r2)
             break;
81139d14:	00000806 	br	81139d38 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
81139d18:	e0bffe17 	ldw	r2,-8(fp)
81139d1c:	10c00104 	addi	r3,r2,4
81139d20:	e0fffe15 	stw	r3,-8(fp)
81139d24:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
81139d28:	e0800217 	ldw	r2,8(fp)
81139d2c:	00c00284 	movi	r3,10
81139d30:	10c00005 	stb	r3,0(r2)
             break;
81139d34:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
81139d38:	d0a0a217 	ldw	r2,-32120(gp)
81139d3c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
81139d40:	d0a0a217 	ldw	r2,-32120(gp)
81139d44:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
81139d48:	d0a0a217 	ldw	r2,-32120(gp)
81139d4c:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81139d50:	d0a0a217 	ldw	r2,-32120(gp)
81139d54:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
81139d58:	d0a0a217 	ldw	r2,-32120(gp)
81139d5c:	10000915 	stw	zero,36(r2)
81139d60:	e0bff317 	ldw	r2,-52(fp)
81139d64:	e0bffa15 	stw	r2,-24(fp)
81139d68:	e0bffa17 	ldw	r2,-24(fp)
81139d6c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
81139d70:	e0bff18b 	ldhu	r2,-58(fp)
}
81139d74:	e037883a 	mov	sp,fp
81139d78:	dfc00117 	ldw	ra,4(sp)
81139d7c:	df000017 	ldw	fp,0(sp)
81139d80:	dec00204 	addi	sp,sp,8
81139d84:	f800283a 	ret

81139d88 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
81139d88:	defffe04 	addi	sp,sp,-8
81139d8c:	de00012e 	bgeu	sp,et,81139d94 <OSInit+0xc>
81139d90:	003b68fa 	trap	3
81139d94:	dfc00115 	stw	ra,4(sp)
81139d98:	df000015 	stw	fp,0(sp)
81139d9c:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
81139da0:	114c28c0 	call	8114c28c <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81139da4:	113ab900 	call	8113ab90 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
81139da8:	113abe00 	call	8113abe0 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
81139dac:	113ad640 	call	8113ad64 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
81139db0:	113aaa80 	call	8113aaa8 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
81139db4:	113cd240 	call	8113cd24 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
81139db8:	113d66c0 	call	8113d66c <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
81139dbc:	113f93c0 	call	8113f93c <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
81139dc0:	113ac540 	call	8113ac54 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
81139dc4:	113acdc0 	call	8113acdc <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
81139dc8:	1142ce00 	call	81142ce0 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
81139dcc:	114c2b80 	call	8114c2b8 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
81139dd0:	113b6400 	call	8113b640 <OSDebugInit>
#endif
}
81139dd4:	0001883a 	nop
81139dd8:	e037883a 	mov	sp,fp
81139ddc:	dfc00117 	ldw	ra,4(sp)
81139de0:	df000017 	ldw	fp,0(sp)
81139de4:	dec00204 	addi	sp,sp,8
81139de8:	f800283a 	ret

81139dec <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
81139dec:	deffff04 	addi	sp,sp,-4
81139df0:	de00012e 	bgeu	sp,et,81139df8 <OSIntEnter+0xc>
81139df4:	003b68fa 	trap	3
81139df8:	df000015 	stw	fp,0(sp)
81139dfc:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
81139e00:	d0a09103 	ldbu	r2,-32188(gp)
81139e04:	10803fcc 	andi	r2,r2,255
81139e08:	10800058 	cmpnei	r2,r2,1
81139e0c:	1000071e 	bne	r2,zero,81139e2c <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
81139e10:	d0a0a103 	ldbu	r2,-32124(gp)
81139e14:	10803fcc 	andi	r2,r2,255
81139e18:	10803fe0 	cmpeqi	r2,r2,255
81139e1c:	1000031e 	bne	r2,zero,81139e2c <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
81139e20:	d0a0a103 	ldbu	r2,-32124(gp)
81139e24:	10800044 	addi	r2,r2,1
81139e28:	d0a0a105 	stb	r2,-32124(gp)
        }
    }
}
81139e2c:	0001883a 	nop
81139e30:	e037883a 	mov	sp,fp
81139e34:	df000017 	ldw	fp,0(sp)
81139e38:	dec00104 	addi	sp,sp,4
81139e3c:	f800283a 	ret

81139e40 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
81139e40:	defffb04 	addi	sp,sp,-20
81139e44:	de00012e 	bgeu	sp,et,81139e4c <OSIntExit+0xc>
81139e48:	003b68fa 	trap	3
81139e4c:	dfc00415 	stw	ra,16(sp)
81139e50:	df000315 	stw	fp,12(sp)
81139e54:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139e58:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81139e5c:	d0a09103 	ldbu	r2,-32188(gp)
81139e60:	10803fcc 	andi	r2,r2,255
81139e64:	10800058 	cmpnei	r2,r2,1
81139e68:	10002f1e 	bne	r2,zero,81139f28 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139e6c:	0005303a 	rdctl	r2,status
81139e70:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139e74:	e0ffff17 	ldw	r3,-4(fp)
81139e78:	00bfff84 	movi	r2,-2
81139e7c:	1884703a 	and	r2,r3,r2
81139e80:	1001703a 	wrctl	status,r2
  
  return context;
81139e84:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81139e88:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
81139e8c:	d0a0a103 	ldbu	r2,-32124(gp)
81139e90:	10803fcc 	andi	r2,r2,255
81139e94:	10000326 	beq	r2,zero,81139ea4 <OSIntExit+0x64>
            OSIntNesting--;
81139e98:	d0a0a103 	ldbu	r2,-32124(gp)
81139e9c:	10bfffc4 	addi	r2,r2,-1
81139ea0:	d0a0a105 	stb	r2,-32124(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81139ea4:	d0a0a103 	ldbu	r2,-32124(gp)
81139ea8:	10803fcc 	andi	r2,r2,255
81139eac:	10001a1e 	bne	r2,zero,81139f18 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
81139eb0:	d0a08f03 	ldbu	r2,-32196(gp)
81139eb4:	10803fcc 	andi	r2,r2,255
81139eb8:	1000171e 	bne	r2,zero,81139f18 <OSIntExit+0xd8>
                OS_SchedNew();
81139ebc:	113aff40 	call	8113aff4 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
81139ec0:	d0e09383 	ldbu	r3,-32178(gp)
81139ec4:	d0a093c3 	ldbu	r2,-32177(gp)
81139ec8:	18c03fcc 	andi	r3,r3,255
81139ecc:	10803fcc 	andi	r2,r2,255
81139ed0:	18801126 	beq	r3,r2,81139f18 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81139ed4:	d0a09383 	ldbu	r2,-32178(gp)
81139ed8:	10c03fcc 	andi	r3,r2,255
81139edc:	00a045f4 	movhi	r2,33047
81139ee0:	10b7f904 	addi	r2,r2,-8220
81139ee4:	18c7883a 	add	r3,r3,r3
81139ee8:	18c7883a 	add	r3,r3,r3
81139eec:	10c5883a 	add	r2,r2,r3
81139ef0:	10800017 	ldw	r2,0(r2)
81139ef4:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
81139ef8:	d0a09c17 	ldw	r2,-32144(gp)
81139efc:	10c00e17 	ldw	r3,56(r2)
81139f00:	18c00044 	addi	r3,r3,1
81139f04:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
81139f08:	d0a09617 	ldw	r2,-32168(gp)
81139f0c:	10800044 	addi	r2,r2,1
81139f10:	d0a09615 	stw	r2,-32168(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
81139f14:	114bf4c0 	call	8114bf4c <OSCtxSw>
81139f18:	e0bffd17 	ldw	r2,-12(fp)
81139f1c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139f20:	e0bffe17 	ldw	r2,-8(fp)
81139f24:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81139f28:	0001883a 	nop
81139f2c:	e037883a 	mov	sp,fp
81139f30:	dfc00117 	ldw	ra,4(sp)
81139f34:	df000017 	ldw	fp,0(sp)
81139f38:	dec00204 	addi	sp,sp,8
81139f3c:	f800283a 	ret

81139f40 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
81139f40:	defffc04 	addi	sp,sp,-16
81139f44:	de00012e 	bgeu	sp,et,81139f4c <OSSchedLock+0xc>
81139f48:	003b68fa 	trap	3
81139f4c:	df000315 	stw	fp,12(sp)
81139f50:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139f54:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
81139f58:	d0a09103 	ldbu	r2,-32188(gp)
81139f5c:	10803fcc 	andi	r2,r2,255
81139f60:	10800058 	cmpnei	r2,r2,1
81139f64:	1000161e 	bne	r2,zero,81139fc0 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139f68:	0005303a 	rdctl	r2,status
81139f6c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139f70:	e0ffff17 	ldw	r3,-4(fp)
81139f74:	00bfff84 	movi	r2,-2
81139f78:	1884703a 	and	r2,r3,r2
81139f7c:	1001703a 	wrctl	status,r2
  
  return context;
81139f80:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81139f84:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
81139f88:	d0a0a103 	ldbu	r2,-32124(gp)
81139f8c:	10803fcc 	andi	r2,r2,255
81139f90:	1000071e 	bne	r2,zero,81139fb0 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81139f94:	d0a08f03 	ldbu	r2,-32196(gp)
81139f98:	10803fcc 	andi	r2,r2,255
81139f9c:	10803fe0 	cmpeqi	r2,r2,255
81139fa0:	1000031e 	bne	r2,zero,81139fb0 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
81139fa4:	d0a08f03 	ldbu	r2,-32196(gp)
81139fa8:	10800044 	addi	r2,r2,1
81139fac:	d0a08f05 	stb	r2,-32196(gp)
81139fb0:	e0bffd17 	ldw	r2,-12(fp)
81139fb4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139fb8:	e0bffe17 	ldw	r2,-8(fp)
81139fbc:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81139fc0:	0001883a 	nop
81139fc4:	e037883a 	mov	sp,fp
81139fc8:	df000017 	ldw	fp,0(sp)
81139fcc:	dec00104 	addi	sp,sp,4
81139fd0:	f800283a 	ret

81139fd4 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
81139fd4:	defff804 	addi	sp,sp,-32
81139fd8:	de00012e 	bgeu	sp,et,81139fe0 <OSSchedUnlock+0xc>
81139fdc:	003b68fa 	trap	3
81139fe0:	dfc00715 	stw	ra,28(sp)
81139fe4:	df000615 	stw	fp,24(sp)
81139fe8:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139fec:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
81139ff0:	d0a09103 	ldbu	r2,-32188(gp)
81139ff4:	10803fcc 	andi	r2,r2,255
81139ff8:	10800058 	cmpnei	r2,r2,1
81139ffc:	1000281e 	bne	r2,zero,8113a0a0 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a000:	0005303a 	rdctl	r2,status
8113a004:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a008:	e0ffff17 	ldw	r3,-4(fp)
8113a00c:	00bfff84 	movi	r2,-2
8113a010:	1884703a 	and	r2,r3,r2
8113a014:	1001703a 	wrctl	status,r2
  
  return context;
8113a018:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8113a01c:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
8113a020:	d0a08f03 	ldbu	r2,-32196(gp)
8113a024:	10803fcc 	andi	r2,r2,255
8113a028:	10001926 	beq	r2,zero,8113a090 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
8113a02c:	d0a08f03 	ldbu	r2,-32196(gp)
8113a030:	10bfffc4 	addi	r2,r2,-1
8113a034:	d0a08f05 	stb	r2,-32196(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
8113a038:	d0a08f03 	ldbu	r2,-32196(gp)
8113a03c:	10803fcc 	andi	r2,r2,255
8113a040:	10000e1e 	bne	r2,zero,8113a07c <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
8113a044:	d0a0a103 	ldbu	r2,-32124(gp)
8113a048:	10803fcc 	andi	r2,r2,255
8113a04c:	1000061e 	bne	r2,zero,8113a068 <OSSchedUnlock+0x94>
8113a050:	e0bffa17 	ldw	r2,-24(fp)
8113a054:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a058:	e0bffb17 	ldw	r2,-20(fp)
8113a05c:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
8113a060:	113af1c0 	call	8113af1c <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
8113a064:	00000e06 	br	8113a0a0 <OSSchedUnlock+0xcc>
8113a068:	e0bffa17 	ldw	r2,-24(fp)
8113a06c:	e0bffc15 	stw	r2,-16(fp)
8113a070:	e0bffc17 	ldw	r2,-16(fp)
8113a074:	1001703a 	wrctl	status,r2
8113a078:	00000906 	br	8113a0a0 <OSSchedUnlock+0xcc>
8113a07c:	e0bffa17 	ldw	r2,-24(fp)
8113a080:	e0bffd15 	stw	r2,-12(fp)
8113a084:	e0bffd17 	ldw	r2,-12(fp)
8113a088:	1001703a 	wrctl	status,r2
8113a08c:	00000406 	br	8113a0a0 <OSSchedUnlock+0xcc>
8113a090:	e0bffa17 	ldw	r2,-24(fp)
8113a094:	e0bffe15 	stw	r2,-8(fp)
8113a098:	e0bffe17 	ldw	r2,-8(fp)
8113a09c:	1001703a 	wrctl	status,r2
8113a0a0:	0001883a 	nop
8113a0a4:	e037883a 	mov	sp,fp
8113a0a8:	dfc00117 	ldw	ra,4(sp)
8113a0ac:	df000017 	ldw	fp,0(sp)
8113a0b0:	dec00204 	addi	sp,sp,8
8113a0b4:	f800283a 	ret

8113a0b8 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
8113a0b8:	defffe04 	addi	sp,sp,-8
8113a0bc:	de00012e 	bgeu	sp,et,8113a0c4 <OSStart+0xc>
8113a0c0:	003b68fa 	trap	3
8113a0c4:	dfc00115 	stw	ra,4(sp)
8113a0c8:	df000015 	stw	fp,0(sp)
8113a0cc:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
8113a0d0:	d0a09103 	ldbu	r2,-32188(gp)
8113a0d4:	10803fcc 	andi	r2,r2,255
8113a0d8:	10000f1e 	bne	r2,zero,8113a118 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
8113a0dc:	113aff40 	call	8113aff4 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
8113a0e0:	d0a09383 	ldbu	r2,-32178(gp)
8113a0e4:	d0a093c5 	stb	r2,-32177(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
8113a0e8:	d0a09383 	ldbu	r2,-32178(gp)
8113a0ec:	10c03fcc 	andi	r3,r2,255
8113a0f0:	00a045f4 	movhi	r2,33047
8113a0f4:	10b7f904 	addi	r2,r2,-8220
8113a0f8:	18c7883a 	add	r3,r3,r3
8113a0fc:	18c7883a 	add	r3,r3,r3
8113a100:	10c5883a 	add	r2,r2,r3
8113a104:	10800017 	ldw	r2,0(r2)
8113a108:	d0a09c15 	stw	r2,-32144(gp)
        OSTCBCur      = OSTCBHighRdy;
8113a10c:	d0a09c17 	ldw	r2,-32144(gp)
8113a110:	d0a0a215 	stw	r2,-32120(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
8113a114:	114bfe80 	call	8114bfe8 <OSStartHighRdy>
    }
}
8113a118:	0001883a 	nop
8113a11c:	e037883a 	mov	sp,fp
8113a120:	dfc00117 	ldw	ra,4(sp)
8113a124:	df000017 	ldw	fp,0(sp)
8113a128:	dec00204 	addi	sp,sp,8
8113a12c:	f800283a 	ret

8113a130 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
8113a130:	defff904 	addi	sp,sp,-28
8113a134:	de00012e 	bgeu	sp,et,8113a13c <OSStatInit+0xc>
8113a138:	003b68fa 	trap	3
8113a13c:	dfc00615 	stw	ra,24(sp)
8113a140:	df000515 	stw	fp,20(sp)
8113a144:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a148:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
8113a14c:	01000084 	movi	r4,2
8113a150:	1141c580 	call	81141c58 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a154:	0005303a 	rdctl	r2,status
8113a158:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a15c:	e0fffc17 	ldw	r3,-16(fp)
8113a160:	00bfff84 	movi	r2,-2
8113a164:	1884703a 	and	r2,r3,r2
8113a168:	1001703a 	wrctl	status,r2
  
  return context;
8113a16c:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
8113a170:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
8113a174:	d0209215 	stw	zero,-32184(gp)
8113a178:	e0bffb17 	ldw	r2,-20(fp)
8113a17c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a180:	e0bffd17 	ldw	r2,-12(fp)
8113a184:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
8113a188:	01001904 	movi	r4,100
8113a18c:	1141c580 	call	81141c58 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a190:	0005303a 	rdctl	r2,status
8113a194:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a198:	e0fffe17 	ldw	r3,-8(fp)
8113a19c:	00bfff84 	movi	r2,-2
8113a1a0:	1884703a 	and	r2,r3,r2
8113a1a4:	1001703a 	wrctl	status,r2
  
  return context;
8113a1a8:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
8113a1ac:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
8113a1b0:	d0a09217 	ldw	r2,-32184(gp)
8113a1b4:	d0a09815 	stw	r2,-32160(gp)
    OSStatRdy    = OS_TRUE;
8113a1b8:	00800044 	movi	r2,1
8113a1bc:	d0a0a705 	stb	r2,-32100(gp)
8113a1c0:	e0bffb17 	ldw	r2,-20(fp)
8113a1c4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a1c8:	e0bfff17 	ldw	r2,-4(fp)
8113a1cc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113a1d0:	0001883a 	nop
8113a1d4:	e037883a 	mov	sp,fp
8113a1d8:	dfc00117 	ldw	ra,4(sp)
8113a1dc:	df000017 	ldw	fp,0(sp)
8113a1e0:	dec00204 	addi	sp,sp,8
8113a1e4:	f800283a 	ret

8113a1e8 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
8113a1e8:	defff704 	addi	sp,sp,-36
8113a1ec:	de00012e 	bgeu	sp,et,8113a1f4 <OSTimeTick+0xc>
8113a1f0:	003b68fa 	trap	3
8113a1f4:	dfc00815 	stw	ra,32(sp)
8113a1f8:	df000715 	stw	fp,28(sp)
8113a1fc:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113a200:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
8113a204:	114c2380 	call	8114c238 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a208:	0005303a 	rdctl	r2,status
8113a20c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a210:	e0fffd17 	ldw	r3,-12(fp)
8113a214:	00bfff84 	movi	r2,-2
8113a218:	1884703a 	and	r2,r3,r2
8113a21c:	1001703a 	wrctl	status,r2
  
  return context;
8113a220:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
8113a224:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
8113a228:	d0a0a417 	ldw	r2,-32112(gp)
8113a22c:	10800044 	addi	r2,r2,1
8113a230:	d0a0a415 	stw	r2,-32112(gp)
8113a234:	e0bffb17 	ldw	r2,-20(fp)
8113a238:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a23c:	e0bfff17 	ldw	r2,-4(fp)
8113a240:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
8113a244:	d0a09103 	ldbu	r2,-32188(gp)
8113a248:	10803fcc 	andi	r2,r2,255
8113a24c:	10800058 	cmpnei	r2,r2,1
8113a250:	10006a1e 	bne	r2,zero,8113a3fc <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
8113a254:	d0a09503 	ldbu	r2,-32172(gp)
8113a258:	10803fcc 	andi	r2,r2,255
8113a25c:	10c00060 	cmpeqi	r3,r2,1
8113a260:	1800061e 	bne	r3,zero,8113a27c <OSTimeTick+0x94>
8113a264:	10c000a0 	cmpeqi	r3,r2,2
8113a268:	1800061e 	bne	r3,zero,8113a284 <OSTimeTick+0x9c>
8113a26c:	10000a1e 	bne	r2,zero,8113a298 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
8113a270:	00800044 	movi	r2,1
8113a274:	e0bffa05 	stb	r2,-24(fp)
                 break;
8113a278:	00000b06 	br	8113a2a8 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
8113a27c:	e03ffa05 	stb	zero,-24(fp)
                 break;
8113a280:	00000906 	br	8113a2a8 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
8113a284:	00800044 	movi	r2,1
8113a288:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
8113a28c:	00800044 	movi	r2,1
8113a290:	d0a09505 	stb	r2,-32172(gp)
                 break;
8113a294:	00000406 	br	8113a2a8 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
8113a298:	00800044 	movi	r2,1
8113a29c:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
8113a2a0:	d0209505 	stb	zero,-32172(gp)
                 break;
8113a2a4:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
8113a2a8:	e0bffa03 	ldbu	r2,-24(fp)
8113a2ac:	10005226 	beq	r2,zero,8113a3f8 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
8113a2b0:	d0a09417 	ldw	r2,-32176(gp)
8113a2b4:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8113a2b8:	00004906 	br	8113a3e0 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a2bc:	0005303a 	rdctl	r2,status
8113a2c0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a2c4:	e0fffc17 	ldw	r3,-16(fp)
8113a2c8:	00bfff84 	movi	r2,-2
8113a2cc:	1884703a 	and	r2,r3,r2
8113a2d0:	1001703a 	wrctl	status,r2
  
  return context;
8113a2d4:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
8113a2d8:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
8113a2dc:	e0bff917 	ldw	r2,-28(fp)
8113a2e0:	10800b8b 	ldhu	r2,46(r2)
8113a2e4:	10bfffcc 	andi	r2,r2,65535
8113a2e8:	10003626 	beq	r2,zero,8113a3c4 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
8113a2ec:	e0bff917 	ldw	r2,-28(fp)
8113a2f0:	10800b8b 	ldhu	r2,46(r2)
8113a2f4:	10bfffc4 	addi	r2,r2,-1
8113a2f8:	1007883a 	mov	r3,r2
8113a2fc:	e0bff917 	ldw	r2,-28(fp)
8113a300:	10c00b8d 	sth	r3,46(r2)
8113a304:	e0bff917 	ldw	r2,-28(fp)
8113a308:	10800b8b 	ldhu	r2,46(r2)
8113a30c:	10bfffcc 	andi	r2,r2,65535
8113a310:	10002c1e 	bne	r2,zero,8113a3c4 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113a314:	e0bff917 	ldw	r2,-28(fp)
8113a318:	10800c03 	ldbu	r2,48(r2)
8113a31c:	10803fcc 	andi	r2,r2,255
8113a320:	10800dcc 	andi	r2,r2,55
8113a324:	10000b26 	beq	r2,zero,8113a354 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
8113a328:	e0bff917 	ldw	r2,-28(fp)
8113a32c:	10c00c03 	ldbu	r3,48(r2)
8113a330:	00bff204 	movi	r2,-56
8113a334:	1884703a 	and	r2,r3,r2
8113a338:	1007883a 	mov	r3,r2
8113a33c:	e0bff917 	ldw	r2,-28(fp)
8113a340:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
8113a344:	e0bff917 	ldw	r2,-28(fp)
8113a348:	00c00044 	movi	r3,1
8113a34c:	10c00c45 	stb	r3,49(r2)
8113a350:	00000206 	br	8113a35c <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113a354:	e0bff917 	ldw	r2,-28(fp)
8113a358:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
8113a35c:	e0bff917 	ldw	r2,-28(fp)
8113a360:	10800c03 	ldbu	r2,48(r2)
8113a364:	10803fcc 	andi	r2,r2,255
8113a368:	1080020c 	andi	r2,r2,8
8113a36c:	1000151e 	bne	r2,zero,8113a3c4 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
8113a370:	e0bff917 	ldw	r2,-28(fp)
8113a374:	10c00d83 	ldbu	r3,54(r2)
8113a378:	d0a09e03 	ldbu	r2,-32136(gp)
8113a37c:	1884b03a 	or	r2,r3,r2
8113a380:	d0a09e05 	stb	r2,-32136(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113a384:	e0bff917 	ldw	r2,-28(fp)
8113a388:	10800d03 	ldbu	r2,52(r2)
8113a38c:	10c03fcc 	andi	r3,r2,255
8113a390:	e0bff917 	ldw	r2,-28(fp)
8113a394:	10800d03 	ldbu	r2,52(r2)
8113a398:	11003fcc 	andi	r4,r2,255
8113a39c:	d0a09e44 	addi	r2,gp,-32135
8113a3a0:	2085883a 	add	r2,r4,r2
8113a3a4:	11000003 	ldbu	r4,0(r2)
8113a3a8:	e0bff917 	ldw	r2,-28(fp)
8113a3ac:	10800d43 	ldbu	r2,53(r2)
8113a3b0:	2084b03a 	or	r2,r4,r2
8113a3b4:	1009883a 	mov	r4,r2
8113a3b8:	d0a09e44 	addi	r2,gp,-32135
8113a3bc:	1885883a 	add	r2,r3,r2
8113a3c0:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
8113a3c4:	e0bff917 	ldw	r2,-28(fp)
8113a3c8:	10800517 	ldw	r2,20(r2)
8113a3cc:	e0bff915 	stw	r2,-28(fp)
8113a3d0:	e0bffb17 	ldw	r2,-20(fp)
8113a3d4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a3d8:	e0bffe17 	ldw	r2,-8(fp)
8113a3dc:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8113a3e0:	e0bff917 	ldw	r2,-28(fp)
8113a3e4:	10800c83 	ldbu	r2,50(r2)
8113a3e8:	10803fcc 	andi	r2,r2,255
8113a3ec:	10800a98 	cmpnei	r2,r2,42
8113a3f0:	103fb21e 	bne	r2,zero,8113a2bc <__reset+0xfb11a2bc>
8113a3f4:	00000106 	br	8113a3fc <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
8113a3f8:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
8113a3fc:	e037883a 	mov	sp,fp
8113a400:	dfc00117 	ldw	ra,4(sp)
8113a404:	df000017 	ldw	fp,0(sp)
8113a408:	dec00204 	addi	sp,sp,8
8113a40c:	f800283a 	ret

8113a410 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
8113a410:	deffff04 	addi	sp,sp,-4
8113a414:	de00012e 	bgeu	sp,et,8113a41c <OSVersion+0xc>
8113a418:	003b68fa 	trap	3
8113a41c:	df000015 	stw	fp,0(sp)
8113a420:	d839883a 	mov	fp,sp
    return (OS_VERSION);
8113a424:	00804784 	movi	r2,286
}
8113a428:	e037883a 	mov	sp,fp
8113a42c:	df000017 	ldw	fp,0(sp)
8113a430:	dec00104 	addi	sp,sp,4
8113a434:	f800283a 	ret

8113a438 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
8113a438:	deffff04 	addi	sp,sp,-4
8113a43c:	de00012e 	bgeu	sp,et,8113a444 <OS_Dummy+0xc>
8113a440:	003b68fa 	trap	3
8113a444:	df000015 	stw	fp,0(sp)
8113a448:	d839883a 	mov	fp,sp
}
8113a44c:	0001883a 	nop
8113a450:	e037883a 	mov	sp,fp
8113a454:	df000017 	ldw	fp,0(sp)
8113a458:	dec00104 	addi	sp,sp,4
8113a45c:	f800283a 	ret

8113a460 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
8113a460:	defff804 	addi	sp,sp,-32
8113a464:	de00012e 	bgeu	sp,et,8113a46c <OS_EventTaskRdy+0xc>
8113a468:	003b68fa 	trap	3
8113a46c:	dfc00715 	stw	ra,28(sp)
8113a470:	df000615 	stw	fp,24(sp)
8113a474:	df000604 	addi	fp,sp,24
8113a478:	e13ffc15 	stw	r4,-16(fp)
8113a47c:	e17ffd15 	stw	r5,-12(fp)
8113a480:	3007883a 	mov	r3,r6
8113a484:	3805883a 	mov	r2,r7
8113a488:	e0fffe05 	stb	r3,-8(fp)
8113a48c:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
8113a490:	e0bffc17 	ldw	r2,-16(fp)
8113a494:	10800283 	ldbu	r2,10(r2)
8113a498:	10c03fcc 	andi	r3,r2,255
8113a49c:	00a04574 	movhi	r2,33045
8113a4a0:	10887c04 	addi	r2,r2,8688
8113a4a4:	10c5883a 	add	r2,r2,r3
8113a4a8:	10800003 	ldbu	r2,0(r2)
8113a4ac:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
8113a4b0:	e0bffa03 	ldbu	r2,-24(fp)
8113a4b4:	e0fffc17 	ldw	r3,-16(fp)
8113a4b8:	1885883a 	add	r2,r3,r2
8113a4bc:	108002c4 	addi	r2,r2,11
8113a4c0:	10800003 	ldbu	r2,0(r2)
8113a4c4:	10c03fcc 	andi	r3,r2,255
8113a4c8:	00a04574 	movhi	r2,33045
8113a4cc:	10887c04 	addi	r2,r2,8688
8113a4d0:	10c5883a 	add	r2,r2,r3
8113a4d4:	10800003 	ldbu	r2,0(r2)
8113a4d8:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
8113a4dc:	e0bffa03 	ldbu	r2,-24(fp)
8113a4e0:	100490fa 	slli	r2,r2,3
8113a4e4:	1007883a 	mov	r3,r2
8113a4e8:	e0bffa43 	ldbu	r2,-23(fp)
8113a4ec:	1885883a 	add	r2,r3,r2
8113a4f0:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
8113a4f4:	e0fffa83 	ldbu	r3,-22(fp)
8113a4f8:	00a045f4 	movhi	r2,33047
8113a4fc:	10b7f904 	addi	r2,r2,-8220
8113a500:	18c7883a 	add	r3,r3,r3
8113a504:	18c7883a 	add	r3,r3,r3
8113a508:	10c5883a 	add	r2,r2,r3
8113a50c:	10800017 	ldw	r2,0(r2)
8113a510:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
8113a514:	e0bffb17 	ldw	r2,-20(fp)
8113a518:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
8113a51c:	e0bffb17 	ldw	r2,-20(fp)
8113a520:	e0fffd17 	ldw	r3,-12(fp)
8113a524:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
8113a528:	e0bffb17 	ldw	r2,-20(fp)
8113a52c:	10800c03 	ldbu	r2,48(r2)
8113a530:	1007883a 	mov	r3,r2
8113a534:	e0bffe03 	ldbu	r2,-8(fp)
8113a538:	0084303a 	nor	r2,zero,r2
8113a53c:	1884703a 	and	r2,r3,r2
8113a540:	1007883a 	mov	r3,r2
8113a544:	e0bffb17 	ldw	r2,-20(fp)
8113a548:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
8113a54c:	e0bffb17 	ldw	r2,-20(fp)
8113a550:	e0ffff03 	ldbu	r3,-4(fp)
8113a554:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
8113a558:	e0bffb17 	ldw	r2,-20(fp)
8113a55c:	10800c03 	ldbu	r2,48(r2)
8113a560:	10803fcc 	andi	r2,r2,255
8113a564:	1080020c 	andi	r2,r2,8
8113a568:	1000111e 	bne	r2,zero,8113a5b0 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
8113a56c:	e0bffb17 	ldw	r2,-20(fp)
8113a570:	10c00d83 	ldbu	r3,54(r2)
8113a574:	d0a09e03 	ldbu	r2,-32136(gp)
8113a578:	1884b03a 	or	r2,r3,r2
8113a57c:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
8113a580:	e0fffa03 	ldbu	r3,-24(fp)
8113a584:	e13ffa03 	ldbu	r4,-24(fp)
8113a588:	d0a09e44 	addi	r2,gp,-32135
8113a58c:	2085883a 	add	r2,r4,r2
8113a590:	11000003 	ldbu	r4,0(r2)
8113a594:	e0bffb17 	ldw	r2,-20(fp)
8113a598:	10800d43 	ldbu	r2,53(r2)
8113a59c:	2084b03a 	or	r2,r4,r2
8113a5a0:	1009883a 	mov	r4,r2
8113a5a4:	d0a09e44 	addi	r2,gp,-32135
8113a5a8:	1885883a 	add	r2,r3,r2
8113a5ac:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
8113a5b0:	e17ffc17 	ldw	r5,-16(fp)
8113a5b4:	e13ffb17 	ldw	r4,-20(fp)
8113a5b8:	113a8700 	call	8113a870 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
8113a5bc:	e0bffb17 	ldw	r2,-20(fp)
8113a5c0:	10800817 	ldw	r2,32(r2)
8113a5c4:	10000826 	beq	r2,zero,8113a5e8 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113a5c8:	e0bffb17 	ldw	r2,-20(fp)
8113a5cc:	10800817 	ldw	r2,32(r2)
8113a5d0:	100b883a 	mov	r5,r2
8113a5d4:	e13ffb17 	ldw	r4,-20(fp)
8113a5d8:	113a9300 	call	8113a930 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
8113a5dc:	e0bffb17 	ldw	r2,-20(fp)
8113a5e0:	e0fffc17 	ldw	r3,-16(fp)
8113a5e4:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
8113a5e8:	e0bffa83 	ldbu	r2,-22(fp)
}
8113a5ec:	e037883a 	mov	sp,fp
8113a5f0:	dfc00117 	ldw	ra,4(sp)
8113a5f4:	df000017 	ldw	fp,0(sp)
8113a5f8:	dec00204 	addi	sp,sp,8
8113a5fc:	f800283a 	ret

8113a600 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
8113a600:	defffd04 	addi	sp,sp,-12
8113a604:	de00012e 	bgeu	sp,et,8113a60c <OS_EventTaskWait+0xc>
8113a608:	003b68fa 	trap	3
8113a60c:	df000215 	stw	fp,8(sp)
8113a610:	df000204 	addi	fp,sp,8
8113a614:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
8113a618:	d0a0a217 	ldw	r2,-32120(gp)
8113a61c:	e0ffff17 	ldw	r3,-4(fp)
8113a620:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
8113a624:	d0a0a217 	ldw	r2,-32120(gp)
8113a628:	10800d03 	ldbu	r2,52(r2)
8113a62c:	10803fcc 	andi	r2,r2,255
8113a630:	d0e0a217 	ldw	r3,-32120(gp)
8113a634:	18c00d03 	ldbu	r3,52(r3)
8113a638:	18c03fcc 	andi	r3,r3,255
8113a63c:	e13fff17 	ldw	r4,-4(fp)
8113a640:	20c7883a 	add	r3,r4,r3
8113a644:	18c002c4 	addi	r3,r3,11
8113a648:	19000003 	ldbu	r4,0(r3)
8113a64c:	d0e0a217 	ldw	r3,-32120(gp)
8113a650:	18c00d43 	ldbu	r3,53(r3)
8113a654:	20c6b03a 	or	r3,r4,r3
8113a658:	1809883a 	mov	r4,r3
8113a65c:	e0ffff17 	ldw	r3,-4(fp)
8113a660:	1885883a 	add	r2,r3,r2
8113a664:	108002c4 	addi	r2,r2,11
8113a668:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8113a66c:	e0bfff17 	ldw	r2,-4(fp)
8113a670:	10c00283 	ldbu	r3,10(r2)
8113a674:	d0a0a217 	ldw	r2,-32120(gp)
8113a678:	10800d83 	ldbu	r2,54(r2)
8113a67c:	1884b03a 	or	r2,r3,r2
8113a680:	1007883a 	mov	r3,r2
8113a684:	e0bfff17 	ldw	r2,-4(fp)
8113a688:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8113a68c:	d0a0a217 	ldw	r2,-32120(gp)
8113a690:	10800d03 	ldbu	r2,52(r2)
8113a694:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8113a698:	e0fffe03 	ldbu	r3,-8(fp)
8113a69c:	e13ffe03 	ldbu	r4,-8(fp)
8113a6a0:	d0a09e44 	addi	r2,gp,-32135
8113a6a4:	2085883a 	add	r2,r4,r2
8113a6a8:	10800003 	ldbu	r2,0(r2)
8113a6ac:	1009883a 	mov	r4,r2
8113a6b0:	d0a0a217 	ldw	r2,-32120(gp)
8113a6b4:	10800d43 	ldbu	r2,53(r2)
8113a6b8:	0084303a 	nor	r2,zero,r2
8113a6bc:	2084703a 	and	r2,r4,r2
8113a6c0:	1009883a 	mov	r4,r2
8113a6c4:	d0a09e44 	addi	r2,gp,-32135
8113a6c8:	1885883a 	add	r2,r3,r2
8113a6cc:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113a6d0:	e0fffe03 	ldbu	r3,-8(fp)
8113a6d4:	d0a09e44 	addi	r2,gp,-32135
8113a6d8:	1885883a 	add	r2,r3,r2
8113a6dc:	10800003 	ldbu	r2,0(r2)
8113a6e0:	10803fcc 	andi	r2,r2,255
8113a6e4:	1000071e 	bne	r2,zero,8113a704 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8113a6e8:	d0a0a217 	ldw	r2,-32120(gp)
8113a6ec:	10800d83 	ldbu	r2,54(r2)
8113a6f0:	0084303a 	nor	r2,zero,r2
8113a6f4:	1007883a 	mov	r3,r2
8113a6f8:	d0a09e03 	ldbu	r2,-32136(gp)
8113a6fc:	1884703a 	and	r2,r3,r2
8113a700:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113a704:	0001883a 	nop
8113a708:	e037883a 	mov	sp,fp
8113a70c:	df000017 	ldw	fp,0(sp)
8113a710:	dec00104 	addi	sp,sp,4
8113a714:	f800283a 	ret

8113a718 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
8113a718:	defffb04 	addi	sp,sp,-20
8113a71c:	de00012e 	bgeu	sp,et,8113a724 <OS_EventTaskWaitMulti+0xc>
8113a720:	003b68fa 	trap	3
8113a724:	df000415 	stw	fp,16(sp)
8113a728:	df000404 	addi	fp,sp,16
8113a72c:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
8113a730:	d0a0a217 	ldw	r2,-32120(gp)
8113a734:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
8113a738:	d0a0a217 	ldw	r2,-32120(gp)
8113a73c:	e0ffff17 	ldw	r3,-4(fp)
8113a740:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
8113a744:	e0bfff17 	ldw	r2,-4(fp)
8113a748:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
8113a74c:	e0bffc17 	ldw	r2,-16(fp)
8113a750:	10800017 	ldw	r2,0(r2)
8113a754:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8113a758:	00002006 	br	8113a7dc <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
8113a75c:	d0a0a217 	ldw	r2,-32120(gp)
8113a760:	10800d03 	ldbu	r2,52(r2)
8113a764:	10803fcc 	andi	r2,r2,255
8113a768:	d0e0a217 	ldw	r3,-32120(gp)
8113a76c:	18c00d03 	ldbu	r3,52(r3)
8113a770:	18c03fcc 	andi	r3,r3,255
8113a774:	e13ffd17 	ldw	r4,-12(fp)
8113a778:	20c7883a 	add	r3,r4,r3
8113a77c:	18c002c4 	addi	r3,r3,11
8113a780:	19000003 	ldbu	r4,0(r3)
8113a784:	d0e0a217 	ldw	r3,-32120(gp)
8113a788:	18c00d43 	ldbu	r3,53(r3)
8113a78c:	20c6b03a 	or	r3,r4,r3
8113a790:	1809883a 	mov	r4,r3
8113a794:	e0fffd17 	ldw	r3,-12(fp)
8113a798:	1885883a 	add	r2,r3,r2
8113a79c:	108002c4 	addi	r2,r2,11
8113a7a0:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8113a7a4:	e0bffd17 	ldw	r2,-12(fp)
8113a7a8:	10c00283 	ldbu	r3,10(r2)
8113a7ac:	d0a0a217 	ldw	r2,-32120(gp)
8113a7b0:	10800d83 	ldbu	r2,54(r2)
8113a7b4:	1884b03a 	or	r2,r3,r2
8113a7b8:	1007883a 	mov	r3,r2
8113a7bc:	e0bffd17 	ldw	r2,-12(fp)
8113a7c0:	10c00285 	stb	r3,10(r2)
        pevents++;
8113a7c4:	e0bffc17 	ldw	r2,-16(fp)
8113a7c8:	10800104 	addi	r2,r2,4
8113a7cc:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
8113a7d0:	e0bffc17 	ldw	r2,-16(fp)
8113a7d4:	10800017 	ldw	r2,0(r2)
8113a7d8:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8113a7dc:	e0bffd17 	ldw	r2,-12(fp)
8113a7e0:	103fde1e 	bne	r2,zero,8113a75c <__reset+0xfb11a75c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8113a7e4:	d0a0a217 	ldw	r2,-32120(gp)
8113a7e8:	10800d03 	ldbu	r2,52(r2)
8113a7ec:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8113a7f0:	e0fffe03 	ldbu	r3,-8(fp)
8113a7f4:	e13ffe03 	ldbu	r4,-8(fp)
8113a7f8:	d0a09e44 	addi	r2,gp,-32135
8113a7fc:	2085883a 	add	r2,r4,r2
8113a800:	10800003 	ldbu	r2,0(r2)
8113a804:	1009883a 	mov	r4,r2
8113a808:	d0a0a217 	ldw	r2,-32120(gp)
8113a80c:	10800d43 	ldbu	r2,53(r2)
8113a810:	0084303a 	nor	r2,zero,r2
8113a814:	2084703a 	and	r2,r4,r2
8113a818:	1009883a 	mov	r4,r2
8113a81c:	d0a09e44 	addi	r2,gp,-32135
8113a820:	1885883a 	add	r2,r3,r2
8113a824:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113a828:	e0fffe03 	ldbu	r3,-8(fp)
8113a82c:	d0a09e44 	addi	r2,gp,-32135
8113a830:	1885883a 	add	r2,r3,r2
8113a834:	10800003 	ldbu	r2,0(r2)
8113a838:	10803fcc 	andi	r2,r2,255
8113a83c:	1000071e 	bne	r2,zero,8113a85c <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8113a840:	d0a0a217 	ldw	r2,-32120(gp)
8113a844:	10800d83 	ldbu	r2,54(r2)
8113a848:	0084303a 	nor	r2,zero,r2
8113a84c:	1007883a 	mov	r3,r2
8113a850:	d0a09e03 	ldbu	r2,-32136(gp)
8113a854:	1884703a 	and	r2,r3,r2
8113a858:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113a85c:	0001883a 	nop
8113a860:	e037883a 	mov	sp,fp
8113a864:	df000017 	ldw	fp,0(sp)
8113a868:	dec00104 	addi	sp,sp,4
8113a86c:	f800283a 	ret

8113a870 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
8113a870:	defffc04 	addi	sp,sp,-16
8113a874:	de00012e 	bgeu	sp,et,8113a87c <OS_EventTaskRemove+0xc>
8113a878:	003b68fa 	trap	3
8113a87c:	df000315 	stw	fp,12(sp)
8113a880:	df000304 	addi	fp,sp,12
8113a884:	e13ffe15 	stw	r4,-8(fp)
8113a888:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
8113a88c:	e0bffe17 	ldw	r2,-8(fp)
8113a890:	10800d03 	ldbu	r2,52(r2)
8113a894:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
8113a898:	e0bffd03 	ldbu	r2,-12(fp)
8113a89c:	e0fffd03 	ldbu	r3,-12(fp)
8113a8a0:	e13fff17 	ldw	r4,-4(fp)
8113a8a4:	20c7883a 	add	r3,r4,r3
8113a8a8:	18c002c4 	addi	r3,r3,11
8113a8ac:	18c00003 	ldbu	r3,0(r3)
8113a8b0:	1809883a 	mov	r4,r3
8113a8b4:	e0fffe17 	ldw	r3,-8(fp)
8113a8b8:	18c00d43 	ldbu	r3,53(r3)
8113a8bc:	00c6303a 	nor	r3,zero,r3
8113a8c0:	20c6703a 	and	r3,r4,r3
8113a8c4:	1809883a 	mov	r4,r3
8113a8c8:	e0ffff17 	ldw	r3,-4(fp)
8113a8cc:	1885883a 	add	r2,r3,r2
8113a8d0:	108002c4 	addi	r2,r2,11
8113a8d4:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
8113a8d8:	e0bffd03 	ldbu	r2,-12(fp)
8113a8dc:	e0ffff17 	ldw	r3,-4(fp)
8113a8e0:	1885883a 	add	r2,r3,r2
8113a8e4:	108002c4 	addi	r2,r2,11
8113a8e8:	10800003 	ldbu	r2,0(r2)
8113a8ec:	10803fcc 	andi	r2,r2,255
8113a8f0:	10000a1e 	bne	r2,zero,8113a91c <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
8113a8f4:	e0bfff17 	ldw	r2,-4(fp)
8113a8f8:	10800283 	ldbu	r2,10(r2)
8113a8fc:	1007883a 	mov	r3,r2
8113a900:	e0bffe17 	ldw	r2,-8(fp)
8113a904:	10800d83 	ldbu	r2,54(r2)
8113a908:	0084303a 	nor	r2,zero,r2
8113a90c:	1884703a 	and	r2,r3,r2
8113a910:	1007883a 	mov	r3,r2
8113a914:	e0bfff17 	ldw	r2,-4(fp)
8113a918:	10c00285 	stb	r3,10(r2)
    }
}
8113a91c:	0001883a 	nop
8113a920:	e037883a 	mov	sp,fp
8113a924:	df000017 	ldw	fp,0(sp)
8113a928:	dec00104 	addi	sp,sp,4
8113a92c:	f800283a 	ret

8113a930 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
8113a930:	defffa04 	addi	sp,sp,-24
8113a934:	de00012e 	bgeu	sp,et,8113a93c <OS_EventTaskRemoveMulti+0xc>
8113a938:	003b68fa 	trap	3
8113a93c:	df000515 	stw	fp,20(sp)
8113a940:	df000504 	addi	fp,sp,20
8113a944:	e13ffe15 	stw	r4,-8(fp)
8113a948:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
8113a94c:	e0bffe17 	ldw	r2,-8(fp)
8113a950:	10800d03 	ldbu	r2,52(r2)
8113a954:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
8113a958:	e0bffe17 	ldw	r2,-8(fp)
8113a95c:	10800d83 	ldbu	r2,54(r2)
8113a960:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
8113a964:	e0bffe17 	ldw	r2,-8(fp)
8113a968:	10800d43 	ldbu	r2,53(r2)
8113a96c:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
8113a970:	e0bfff17 	ldw	r2,-4(fp)
8113a974:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
8113a978:	e0bffb17 	ldw	r2,-20(fp)
8113a97c:	10800017 	ldw	r2,0(r2)
8113a980:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8113a984:	00002506 	br	8113aa1c <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
8113a988:	e0bffd03 	ldbu	r2,-12(fp)
8113a98c:	e0fffd03 	ldbu	r3,-12(fp)
8113a990:	e13ffc17 	ldw	r4,-16(fp)
8113a994:	20c7883a 	add	r3,r4,r3
8113a998:	18c002c4 	addi	r3,r3,11
8113a99c:	18c00003 	ldbu	r3,0(r3)
8113a9a0:	1809883a 	mov	r4,r3
8113a9a4:	e0fffd83 	ldbu	r3,-10(fp)
8113a9a8:	00c6303a 	nor	r3,zero,r3
8113a9ac:	20c6703a 	and	r3,r4,r3
8113a9b0:	1809883a 	mov	r4,r3
8113a9b4:	e0fffc17 	ldw	r3,-16(fp)
8113a9b8:	1885883a 	add	r2,r3,r2
8113a9bc:	108002c4 	addi	r2,r2,11
8113a9c0:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
8113a9c4:	e0bffd03 	ldbu	r2,-12(fp)
8113a9c8:	e0fffc17 	ldw	r3,-16(fp)
8113a9cc:	1885883a 	add	r2,r3,r2
8113a9d0:	108002c4 	addi	r2,r2,11
8113a9d4:	10800003 	ldbu	r2,0(r2)
8113a9d8:	10803fcc 	andi	r2,r2,255
8113a9dc:	1000091e 	bne	r2,zero,8113aa04 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
8113a9e0:	e0bffc17 	ldw	r2,-16(fp)
8113a9e4:	10800283 	ldbu	r2,10(r2)
8113a9e8:	1007883a 	mov	r3,r2
8113a9ec:	e0bffd43 	ldbu	r2,-11(fp)
8113a9f0:	0084303a 	nor	r2,zero,r2
8113a9f4:	1884703a 	and	r2,r3,r2
8113a9f8:	1007883a 	mov	r3,r2
8113a9fc:	e0bffc17 	ldw	r2,-16(fp)
8113aa00:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
8113aa04:	e0bffb17 	ldw	r2,-20(fp)
8113aa08:	10800104 	addi	r2,r2,4
8113aa0c:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
8113aa10:	e0bffb17 	ldw	r2,-20(fp)
8113aa14:	10800017 	ldw	r2,0(r2)
8113aa18:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8113aa1c:	e0bffc17 	ldw	r2,-16(fp)
8113aa20:	103fd91e 	bne	r2,zero,8113a988 <__reset+0xfb11a988>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
8113aa24:	0001883a 	nop
8113aa28:	e037883a 	mov	sp,fp
8113aa2c:	df000017 	ldw	fp,0(sp)
8113aa30:	dec00104 	addi	sp,sp,4
8113aa34:	f800283a 	ret

8113aa38 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
8113aa38:	defffc04 	addi	sp,sp,-16
8113aa3c:	de00012e 	bgeu	sp,et,8113aa44 <OS_EventWaitListInit+0xc>
8113aa40:	003b68fa 	trap	3
8113aa44:	df000315 	stw	fp,12(sp)
8113aa48:	df000304 	addi	fp,sp,12
8113aa4c:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
8113aa50:	e0bfff17 	ldw	r2,-4(fp)
8113aa54:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
8113aa58:	e0bfff17 	ldw	r2,-4(fp)
8113aa5c:	108002c4 	addi	r2,r2,11
8113aa60:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113aa64:	e03ffe05 	stb	zero,-8(fp)
8113aa68:	00000706 	br	8113aa88 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
8113aa6c:	e0bffd17 	ldw	r2,-12(fp)
8113aa70:	10c00044 	addi	r3,r2,1
8113aa74:	e0fffd15 	stw	r3,-12(fp)
8113aa78:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113aa7c:	e0bffe03 	ldbu	r2,-8(fp)
8113aa80:	10800044 	addi	r2,r2,1
8113aa84:	e0bffe05 	stb	r2,-8(fp)
8113aa88:	e0bffe03 	ldbu	r2,-8(fp)
8113aa8c:	108001b0 	cmpltui	r2,r2,6
8113aa90:	103ff61e 	bne	r2,zero,8113aa6c <__reset+0xfb11aa6c>
        *ptbl++ = 0;
    }
}
8113aa94:	0001883a 	nop
8113aa98:	e037883a 	mov	sp,fp
8113aa9c:	df000017 	ldw	fp,0(sp)
8113aaa0:	dec00104 	addi	sp,sp,4
8113aaa4:	f800283a 	ret

8113aaa8 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
8113aaa8:	defffb04 	addi	sp,sp,-20
8113aaac:	de00012e 	bgeu	sp,et,8113aab4 <OS_InitEventList+0xc>
8113aab0:	003b68fa 	trap	3
8113aab4:	dfc00415 	stw	ra,16(sp)
8113aab8:	df000315 	stw	fp,12(sp)
8113aabc:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
8113aac0:	01434004 	movi	r5,3328
8113aac4:	012045f4 	movhi	r4,33047
8113aac8:	21304b04 	addi	r4,r4,-16084
8113aacc:	113ae500 	call	8113ae50 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
8113aad0:	00a045f4 	movhi	r2,33047
8113aad4:	10b04b04 	addi	r2,r2,-16084
8113aad8:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
8113aadc:	00a045f4 	movhi	r2,33047
8113aae0:	10b05804 	addi	r2,r2,-16032
8113aae4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8113aae8:	e03ffd0d 	sth	zero,-12(fp)
8113aaec:	00001306 	br	8113ab3c <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113aaf0:	e0bffe17 	ldw	r2,-8(fp)
8113aaf4:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
8113aaf8:	e0bffe17 	ldw	r2,-8(fp)
8113aafc:	e0ffff17 	ldw	r3,-4(fp)
8113ab00:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
8113ab04:	e0bffe17 	ldw	r2,-8(fp)
8113ab08:	00c00fc4 	movi	r3,63
8113ab0c:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
8113ab10:	e0bffe17 	ldw	r2,-8(fp)
8113ab14:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
8113ab18:	e0bffe17 	ldw	r2,-8(fp)
8113ab1c:	10800d04 	addi	r2,r2,52
8113ab20:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
8113ab24:	e0bfff17 	ldw	r2,-4(fp)
8113ab28:	10800d04 	addi	r2,r2,52
8113ab2c:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8113ab30:	e0bffd0b 	ldhu	r2,-12(fp)
8113ab34:	10800044 	addi	r2,r2,1
8113ab38:	e0bffd0d 	sth	r2,-12(fp)
8113ab3c:	e0bffd0b 	ldhu	r2,-12(fp)
8113ab40:	10800ff0 	cmpltui	r2,r2,63
8113ab44:	103fea1e 	bne	r2,zero,8113aaf0 <__reset+0xfb11aaf0>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
8113ab48:	e0bffe17 	ldw	r2,-8(fp)
8113ab4c:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
8113ab50:	e0bffe17 	ldw	r2,-8(fp)
8113ab54:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
8113ab58:	e0bffe17 	ldw	r2,-8(fp)
8113ab5c:	00c00fc4 	movi	r3,63
8113ab60:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
8113ab64:	e0bffe17 	ldw	r2,-8(fp)
8113ab68:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
8113ab6c:	00a045f4 	movhi	r2,33047
8113ab70:	10b04b04 	addi	r2,r2,-16084
8113ab74:	d0a0a015 	stw	r2,-32128(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
8113ab78:	0001883a 	nop
8113ab7c:	e037883a 	mov	sp,fp
8113ab80:	dfc00117 	ldw	ra,4(sp)
8113ab84:	df000017 	ldw	fp,0(sp)
8113ab88:	dec00204 	addi	sp,sp,8
8113ab8c:	f800283a 	ret

8113ab90 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
8113ab90:	deffff04 	addi	sp,sp,-4
8113ab94:	de00012e 	bgeu	sp,et,8113ab9c <OS_InitMisc+0xc>
8113ab98:	003b68fa 	trap	3
8113ab9c:	df000015 	stw	fp,0(sp)
8113aba0:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
8113aba4:	d020a415 	stw	zero,-32112(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
8113aba8:	d020a105 	stb	zero,-32124(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
8113abac:	d0208f05 	stb	zero,-32196(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
8113abb0:	d0209a45 	stb	zero,-32151(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
8113abb4:	d0209105 	stb	zero,-32188(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
8113abb8:	d0209615 	stw	zero,-32168(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
8113abbc:	d0209215 	stw	zero,-32184(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
8113abc0:	d020a815 	stw	zero,-32096(gp)
    OSIdleCtrMax  = 0L;
8113abc4:	d0209815 	stw	zero,-32160(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
8113abc8:	d020a705 	stb	zero,-32100(gp)
#endif
}
8113abcc:	0001883a 	nop
8113abd0:	e037883a 	mov	sp,fp
8113abd4:	df000017 	ldw	fp,0(sp)
8113abd8:	dec00104 	addi	sp,sp,4
8113abdc:	f800283a 	ret

8113abe0 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
8113abe0:	defffd04 	addi	sp,sp,-12
8113abe4:	de00012e 	bgeu	sp,et,8113abec <OS_InitRdyList+0xc>
8113abe8:	003b68fa 	trap	3
8113abec:	df000215 	stw	fp,8(sp)
8113abf0:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
8113abf4:	d0209e05 	stb	zero,-32136(gp)
    prdytbl       = &OSRdyTbl[0];
8113abf8:	d0a09e44 	addi	r2,gp,-32135
8113abfc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113ac00:	e03ffe05 	stb	zero,-8(fp)
8113ac04:	00000706 	br	8113ac24 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
8113ac08:	e0bfff17 	ldw	r2,-4(fp)
8113ac0c:	10c00044 	addi	r3,r2,1
8113ac10:	e0ffff15 	stw	r3,-4(fp)
8113ac14:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113ac18:	e0bffe03 	ldbu	r2,-8(fp)
8113ac1c:	10800044 	addi	r2,r2,1
8113ac20:	e0bffe05 	stb	r2,-8(fp)
8113ac24:	e0bffe03 	ldbu	r2,-8(fp)
8113ac28:	108001b0 	cmpltui	r2,r2,6
8113ac2c:	103ff61e 	bne	r2,zero,8113ac08 <__reset+0xfb11ac08>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
8113ac30:	d02093c5 	stb	zero,-32177(gp)
    OSPrioHighRdy = 0;
8113ac34:	d0209385 	stb	zero,-32178(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
8113ac38:	d0209c15 	stw	zero,-32144(gp)
    OSTCBCur      = (OS_TCB *)0;
8113ac3c:	d020a215 	stw	zero,-32120(gp)
}
8113ac40:	0001883a 	nop
8113ac44:	e037883a 	mov	sp,fp
8113ac48:	df000017 	ldw	fp,0(sp)
8113ac4c:	dec00104 	addi	sp,sp,4
8113ac50:	f800283a 	ret

8113ac54 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
8113ac54:	defff804 	addi	sp,sp,-32
8113ac58:	de00012e 	bgeu	sp,et,8113ac60 <OS_InitTaskIdle+0xc>
8113ac5c:	003b68fa 	trap	3
8113ac60:	dfc00715 	stw	ra,28(sp)
8113ac64:	df000615 	stw	fp,24(sp)
8113ac68:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
8113ac6c:	008000c4 	movi	r2,3
8113ac70:	d8800415 	stw	r2,16(sp)
8113ac74:	d8000315 	stw	zero,12(sp)
8113ac78:	00810004 	movi	r2,1024
8113ac7c:	d8800215 	stw	r2,8(sp)
8113ac80:	00a045f4 	movhi	r2,33047
8113ac84:	10ac4b04 	addi	r2,r2,-20180
8113ac88:	d8800115 	stw	r2,4(sp)
8113ac8c:	00bfffd4 	movui	r2,65535
8113ac90:	d8800015 	stw	r2,0(sp)
8113ac94:	01c00a84 	movi	r7,42
8113ac98:	01a045f4 	movhi	r6,33047
8113ac9c:	31b04a04 	addi	r6,r6,-16088
8113aca0:	000b883a 	mov	r5,zero
8113aca4:	01204534 	movhi	r4,33044
8113aca8:	212c5204 	addi	r4,r4,-20152
8113acac:	1140b380 	call	81140b38 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
8113acb0:	e1bfff04 	addi	r6,fp,-4
8113acb4:	01604574 	movhi	r5,33045
8113acb8:	2948bc04 	addi	r5,r5,8944
8113acbc:	01000a84 	movi	r4,42
8113acc0:	11413680 	call	81141368 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
8113acc4:	0001883a 	nop
8113acc8:	e037883a 	mov	sp,fp
8113accc:	dfc00117 	ldw	ra,4(sp)
8113acd0:	df000017 	ldw	fp,0(sp)
8113acd4:	dec00204 	addi	sp,sp,8
8113acd8:	f800283a 	ret

8113acdc <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
8113acdc:	defff804 	addi	sp,sp,-32
8113ace0:	de00012e 	bgeu	sp,et,8113ace8 <OS_InitTaskStat+0xc>
8113ace4:	003b68fa 	trap	3
8113ace8:	dfc00715 	stw	ra,28(sp)
8113acec:	df000615 	stw	fp,24(sp)
8113acf0:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
8113acf4:	008000c4 	movi	r2,3
8113acf8:	d8800415 	stw	r2,16(sp)
8113acfc:	d8000315 	stw	zero,12(sp)
8113ad00:	00810004 	movi	r2,1024
8113ad04:	d8800215 	stw	r2,8(sp)
8113ad08:	00a045f4 	movhi	r2,33047
8113ad0c:	10a58b04 	addi	r2,r2,-27092
8113ad10:	d8800115 	stw	r2,4(sp)
8113ad14:	00bfff94 	movui	r2,65534
8113ad18:	d8800015 	stw	r2,0(sp)
8113ad1c:	01c00a44 	movi	r7,41
8113ad20:	01a045f4 	movhi	r6,33047
8113ad24:	31a98a04 	addi	r6,r6,-23000
8113ad28:	000b883a 	mov	r5,zero
8113ad2c:	01204534 	movhi	r4,33044
8113ad30:	212c6b04 	addi	r4,r4,-20052
8113ad34:	1140b380 	call	81140b38 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
8113ad38:	e1bfff04 	addi	r6,fp,-4
8113ad3c:	01604574 	movhi	r5,33045
8113ad40:	2948c004 	addi	r5,r5,8960
8113ad44:	01000a44 	movi	r4,41
8113ad48:	11413680 	call	81141368 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
8113ad4c:	0001883a 	nop
8113ad50:	e037883a 	mov	sp,fp
8113ad54:	dfc00117 	ldw	ra,4(sp)
8113ad58:	df000017 	ldw	fp,0(sp)
8113ad5c:	dec00204 	addi	sp,sp,8
8113ad60:	f800283a 	ret

8113ad64 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
8113ad64:	defffb04 	addi	sp,sp,-20
8113ad68:	de00012e 	bgeu	sp,et,8113ad70 <OS_InitTCBList+0xc>
8113ad6c:	003b68fa 	trap	3
8113ad70:	dfc00415 	stw	ra,16(sp)
8113ad74:	df000315 	stw	fp,12(sp)
8113ad78:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
8113ad7c:	01446e04 	movi	r5,4536
8113ad80:	012045f4 	movhi	r4,33047
8113ad84:	21338b04 	addi	r4,r4,-12756
8113ad88:	113ae500 	call	8113ae50 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
8113ad8c:	01402b04 	movi	r5,172
8113ad90:	012045f4 	movhi	r4,33047
8113ad94:	2137f904 	addi	r4,r4,-8220
8113ad98:	113ae500 	call	8113ae50 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
8113ad9c:	00a045f4 	movhi	r2,33047
8113ada0:	10b38b04 	addi	r2,r2,-12756
8113ada4:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
8113ada8:	00a045f4 	movhi	r2,33047
8113adac:	10b3a604 	addi	r2,r2,-12648
8113adb0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8113adb4:	e03ffd05 	stb	zero,-12(fp)
8113adb8:	00001106 	br	8113ae00 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
8113adbc:	e0bffe17 	ldw	r2,-8(fp)
8113adc0:	e0ffff17 	ldw	r3,-4(fp)
8113adc4:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
8113adc8:	e0bffe17 	ldw	r2,-8(fp)
8113adcc:	00c00fc4 	movi	r3,63
8113add0:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8113add4:	e0bffe17 	ldw	r2,-8(fp)
8113add8:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
8113addc:	e0bffe17 	ldw	r2,-8(fp)
8113ade0:	10801b04 	addi	r2,r2,108
8113ade4:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
8113ade8:	e0bfff17 	ldw	r2,-4(fp)
8113adec:	10801b04 	addi	r2,r2,108
8113adf0:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8113adf4:	e0bffd03 	ldbu	r2,-12(fp)
8113adf8:	10800044 	addi	r2,r2,1
8113adfc:	e0bffd05 	stb	r2,-12(fp)
8113ae00:	e0bffd03 	ldbu	r2,-12(fp)
8113ae04:	10800a70 	cmpltui	r2,r2,41
8113ae08:	103fec1e 	bne	r2,zero,8113adbc <__reset+0xfb11adbc>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
8113ae0c:	e0bffe17 	ldw	r2,-8(fp)
8113ae10:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
8113ae14:	e0bffe17 	ldw	r2,-8(fp)
8113ae18:	00c00fc4 	movi	r3,63
8113ae1c:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8113ae20:	e0bffe17 	ldw	r2,-8(fp)
8113ae24:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
8113ae28:	d0209415 	stw	zero,-32176(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
8113ae2c:	00a045f4 	movhi	r2,33047
8113ae30:	10b38b04 	addi	r2,r2,-12756
8113ae34:	d0a09915 	stw	r2,-32156(gp)
}
8113ae38:	0001883a 	nop
8113ae3c:	e037883a 	mov	sp,fp
8113ae40:	dfc00117 	ldw	ra,4(sp)
8113ae44:	df000017 	ldw	fp,0(sp)
8113ae48:	dec00204 	addi	sp,sp,8
8113ae4c:	f800283a 	ret

8113ae50 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
8113ae50:	defffd04 	addi	sp,sp,-12
8113ae54:	de00012e 	bgeu	sp,et,8113ae5c <OS_MemClr+0xc>
8113ae58:	003b68fa 	trap	3
8113ae5c:	df000215 	stw	fp,8(sp)
8113ae60:	df000204 	addi	fp,sp,8
8113ae64:	e13ffe15 	stw	r4,-8(fp)
8113ae68:	2805883a 	mov	r2,r5
8113ae6c:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8113ae70:	00000706 	br	8113ae90 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
8113ae74:	e0bffe17 	ldw	r2,-8(fp)
8113ae78:	10c00044 	addi	r3,r2,1
8113ae7c:	e0fffe15 	stw	r3,-8(fp)
8113ae80:	10000005 	stb	zero,0(r2)
        size--;
8113ae84:	e0bfff0b 	ldhu	r2,-4(fp)
8113ae88:	10bfffc4 	addi	r2,r2,-1
8113ae8c:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
8113ae90:	e0bfff0b 	ldhu	r2,-4(fp)
8113ae94:	103ff71e 	bne	r2,zero,8113ae74 <__reset+0xfb11ae74>
        *pdest++ = (INT8U)0;
        size--;
    }
}
8113ae98:	0001883a 	nop
8113ae9c:	e037883a 	mov	sp,fp
8113aea0:	df000017 	ldw	fp,0(sp)
8113aea4:	dec00104 	addi	sp,sp,4
8113aea8:	f800283a 	ret

8113aeac <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
8113aeac:	defffc04 	addi	sp,sp,-16
8113aeb0:	de00012e 	bgeu	sp,et,8113aeb8 <OS_MemCopy+0xc>
8113aeb4:	003b68fa 	trap	3
8113aeb8:	df000315 	stw	fp,12(sp)
8113aebc:	df000304 	addi	fp,sp,12
8113aec0:	e13ffd15 	stw	r4,-12(fp)
8113aec4:	e17ffe15 	stw	r5,-8(fp)
8113aec8:	3005883a 	mov	r2,r6
8113aecc:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8113aed0:	00000b06 	br	8113af00 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
8113aed4:	e0bffd17 	ldw	r2,-12(fp)
8113aed8:	10c00044 	addi	r3,r2,1
8113aedc:	e0fffd15 	stw	r3,-12(fp)
8113aee0:	e0fffe17 	ldw	r3,-8(fp)
8113aee4:	19000044 	addi	r4,r3,1
8113aee8:	e13ffe15 	stw	r4,-8(fp)
8113aeec:	18c00003 	ldbu	r3,0(r3)
8113aef0:	10c00005 	stb	r3,0(r2)
        size--;
8113aef4:	e0bfff0b 	ldhu	r2,-4(fp)
8113aef8:	10bfffc4 	addi	r2,r2,-1
8113aefc:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
8113af00:	e0bfff0b 	ldhu	r2,-4(fp)
8113af04:	103ff31e 	bne	r2,zero,8113aed4 <__reset+0xfb11aed4>
        *pdest++ = *psrc++;
        size--;
    }
}
8113af08:	0001883a 	nop
8113af0c:	e037883a 	mov	sp,fp
8113af10:	df000017 	ldw	fp,0(sp)
8113af14:	dec00104 	addi	sp,sp,4
8113af18:	f800283a 	ret

8113af1c <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
8113af1c:	defffb04 	addi	sp,sp,-20
8113af20:	de00012e 	bgeu	sp,et,8113af28 <OS_Sched+0xc>
8113af24:	003b68fa 	trap	3
8113af28:	dfc00415 	stw	ra,16(sp)
8113af2c:	df000315 	stw	fp,12(sp)
8113af30:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113af34:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113af38:	0005303a 	rdctl	r2,status
8113af3c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113af40:	e0ffff17 	ldw	r3,-4(fp)
8113af44:	00bfff84 	movi	r2,-2
8113af48:	1884703a 	and	r2,r3,r2
8113af4c:	1001703a 	wrctl	status,r2
  
  return context;
8113af50:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
8113af54:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
8113af58:	d0a0a103 	ldbu	r2,-32124(gp)
8113af5c:	10803fcc 	andi	r2,r2,255
8113af60:	10001a1e 	bne	r2,zero,8113afcc <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
8113af64:	d0a08f03 	ldbu	r2,-32196(gp)
8113af68:	10803fcc 	andi	r2,r2,255
8113af6c:	1000171e 	bne	r2,zero,8113afcc <OS_Sched+0xb0>
            OS_SchedNew();
8113af70:	113aff40 	call	8113aff4 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
8113af74:	d0e09383 	ldbu	r3,-32178(gp)
8113af78:	d0a093c3 	ldbu	r2,-32177(gp)
8113af7c:	18c03fcc 	andi	r3,r3,255
8113af80:	10803fcc 	andi	r2,r2,255
8113af84:	18801126 	beq	r3,r2,8113afcc <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
8113af88:	d0a09383 	ldbu	r2,-32178(gp)
8113af8c:	10c03fcc 	andi	r3,r2,255
8113af90:	00a045f4 	movhi	r2,33047
8113af94:	10b7f904 	addi	r2,r2,-8220
8113af98:	18c7883a 	add	r3,r3,r3
8113af9c:	18c7883a 	add	r3,r3,r3
8113afa0:	10c5883a 	add	r2,r2,r3
8113afa4:	10800017 	ldw	r2,0(r2)
8113afa8:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
8113afac:	d0a09c17 	ldw	r2,-32144(gp)
8113afb0:	10c00e17 	ldw	r3,56(r2)
8113afb4:	18c00044 	addi	r3,r3,1
8113afb8:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
8113afbc:	d0a09617 	ldw	r2,-32168(gp)
8113afc0:	10800044 	addi	r2,r2,1
8113afc4:	d0a09615 	stw	r2,-32168(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
8113afc8:	114bf4c0 	call	8114bf4c <OSCtxSw>
8113afcc:	e0bffd17 	ldw	r2,-12(fp)
8113afd0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113afd4:	e0bffe17 	ldw	r2,-8(fp)
8113afd8:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
8113afdc:	0001883a 	nop
8113afe0:	e037883a 	mov	sp,fp
8113afe4:	dfc00117 	ldw	ra,4(sp)
8113afe8:	df000017 	ldw	fp,0(sp)
8113afec:	dec00204 	addi	sp,sp,8
8113aff0:	f800283a 	ret

8113aff4 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
8113aff4:	defffe04 	addi	sp,sp,-8
8113aff8:	de00012e 	bgeu	sp,et,8113b000 <OS_SchedNew+0xc>
8113affc:	003b68fa 	trap	3
8113b000:	df000115 	stw	fp,4(sp)
8113b004:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
8113b008:	d0a09e03 	ldbu	r2,-32136(gp)
8113b00c:	10c03fcc 	andi	r3,r2,255
8113b010:	00a04574 	movhi	r2,33045
8113b014:	10887c04 	addi	r2,r2,8688
8113b018:	10c5883a 	add	r2,r2,r3
8113b01c:	10800003 	ldbu	r2,0(r2)
8113b020:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
8113b024:	e0bfff03 	ldbu	r2,-4(fp)
8113b028:	100490fa 	slli	r2,r2,3
8113b02c:	1009883a 	mov	r4,r2
8113b030:	e0ffff03 	ldbu	r3,-4(fp)
8113b034:	d0a09e44 	addi	r2,gp,-32135
8113b038:	1885883a 	add	r2,r3,r2
8113b03c:	10800003 	ldbu	r2,0(r2)
8113b040:	10c03fcc 	andi	r3,r2,255
8113b044:	00a04574 	movhi	r2,33045
8113b048:	10887c04 	addi	r2,r2,8688
8113b04c:	10c5883a 	add	r2,r2,r3
8113b050:	10800003 	ldbu	r2,0(r2)
8113b054:	2085883a 	add	r2,r4,r2
8113b058:	d0a09385 	stb	r2,-32178(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
8113b05c:	0001883a 	nop
8113b060:	e037883a 	mov	sp,fp
8113b064:	df000017 	ldw	fp,0(sp)
8113b068:	dec00104 	addi	sp,sp,4
8113b06c:	f800283a 	ret

8113b070 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
8113b070:	defffc04 	addi	sp,sp,-16
8113b074:	de00012e 	bgeu	sp,et,8113b07c <OS_StrCopy+0xc>
8113b078:	003b68fa 	trap	3
8113b07c:	df000315 	stw	fp,12(sp)
8113b080:	df000304 	addi	fp,sp,12
8113b084:	e13ffe15 	stw	r4,-8(fp)
8113b088:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
8113b08c:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
8113b090:	00000b06 	br	8113b0c0 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
8113b094:	e0bffe17 	ldw	r2,-8(fp)
8113b098:	10c00044 	addi	r3,r2,1
8113b09c:	e0fffe15 	stw	r3,-8(fp)
8113b0a0:	e0ffff17 	ldw	r3,-4(fp)
8113b0a4:	19000044 	addi	r4,r3,1
8113b0a8:	e13fff15 	stw	r4,-4(fp)
8113b0ac:	18c00003 	ldbu	r3,0(r3)
8113b0b0:	10c00005 	stb	r3,0(r2)
        len++;
8113b0b4:	e0bffd03 	ldbu	r2,-12(fp)
8113b0b8:	10800044 	addi	r2,r2,1
8113b0bc:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8113b0c0:	e0bfff17 	ldw	r2,-4(fp)
8113b0c4:	10800003 	ldbu	r2,0(r2)
8113b0c8:	10803fcc 	andi	r2,r2,255
8113b0cc:	103ff11e 	bne	r2,zero,8113b094 <__reset+0xfb11b094>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
8113b0d0:	e0bffe17 	ldw	r2,-8(fp)
8113b0d4:	10000005 	stb	zero,0(r2)
    return (len);
8113b0d8:	e0bffd03 	ldbu	r2,-12(fp)
}
8113b0dc:	e037883a 	mov	sp,fp
8113b0e0:	df000017 	ldw	fp,0(sp)
8113b0e4:	dec00104 	addi	sp,sp,4
8113b0e8:	f800283a 	ret

8113b0ec <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
8113b0ec:	defffd04 	addi	sp,sp,-12
8113b0f0:	de00012e 	bgeu	sp,et,8113b0f8 <OS_StrLen+0xc>
8113b0f4:	003b68fa 	trap	3
8113b0f8:	df000215 	stw	fp,8(sp)
8113b0fc:	df000204 	addi	fp,sp,8
8113b100:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
8113b104:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
8113b108:	00000606 	br	8113b124 <OS_StrLen+0x38>
        psrc++;
8113b10c:	e0bfff17 	ldw	r2,-4(fp)
8113b110:	10800044 	addi	r2,r2,1
8113b114:	e0bfff15 	stw	r2,-4(fp)
        len++;
8113b118:	e0bffe03 	ldbu	r2,-8(fp)
8113b11c:	10800044 	addi	r2,r2,1
8113b120:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8113b124:	e0bfff17 	ldw	r2,-4(fp)
8113b128:	10800003 	ldbu	r2,0(r2)
8113b12c:	10803fcc 	andi	r2,r2,255
8113b130:	103ff61e 	bne	r2,zero,8113b10c <__reset+0xfb11b10c>
        psrc++;
        len++;
    }
    return (len);
8113b134:	e0bffe03 	ldbu	r2,-8(fp)
}
8113b138:	e037883a 	mov	sp,fp
8113b13c:	df000017 	ldw	fp,0(sp)
8113b140:	dec00104 	addi	sp,sp,4
8113b144:	f800283a 	ret

8113b148 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
8113b148:	defffa04 	addi	sp,sp,-24
8113b14c:	de00012e 	bgeu	sp,et,8113b154 <OS_TaskIdle+0xc>
8113b150:	003b68fa 	trap	3
8113b154:	dfc00515 	stw	ra,20(sp)
8113b158:	df000415 	stw	fp,16(sp)
8113b15c:	df000404 	addi	fp,sp,16
8113b160:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b164:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b168:	0005303a 	rdctl	r2,status
8113b16c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b170:	e0fffd17 	ldw	r3,-12(fp)
8113b174:	00bfff84 	movi	r2,-2
8113b178:	1884703a 	and	r2,r3,r2
8113b17c:	1001703a 	wrctl	status,r2
  
  return context;
8113b180:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
8113b184:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
8113b188:	d0a09217 	ldw	r2,-32184(gp)
8113b18c:	10800044 	addi	r2,r2,1
8113b190:	d0a09215 	stw	r2,-32184(gp)
8113b194:	e0bffc17 	ldw	r2,-16(fp)
8113b198:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b19c:	e0bffe17 	ldw	r2,-8(fp)
8113b1a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
8113b1a4:	114c2e00 	call	8114c2e0 <OSTaskIdleHook>
    }
8113b1a8:	003fef06 	br	8113b168 <__reset+0xfb11b168>

8113b1ac <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
8113b1ac:	defff804 	addi	sp,sp,-32
8113b1b0:	de00012e 	bgeu	sp,et,8113b1b8 <OS_TaskStat+0xc>
8113b1b4:	003b68fa 	trap	3
8113b1b8:	dfc00715 	stw	ra,28(sp)
8113b1bc:	df000615 	stw	fp,24(sp)
8113b1c0:	dc400515 	stw	r17,20(sp)
8113b1c4:	dc000415 	stw	r16,16(sp)
8113b1c8:	df000604 	addi	fp,sp,24
8113b1cc:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b1d0:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8113b1d4:	00000206 	br	8113b1e0 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
8113b1d8:	01003204 	movi	r4,200
8113b1dc:	1141c580 	call	81141c58 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8113b1e0:	d0a0a703 	ldbu	r2,-32100(gp)
8113b1e4:	10803fcc 	andi	r2,r2,255
8113b1e8:	103ffb26 	beq	r2,zero,8113b1d8 <__reset+0xfb11b1d8>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
8113b1ec:	d0e09817 	ldw	r3,-32160(gp)
8113b1f0:	00947b34 	movhi	r2,20972
8113b1f4:	10a147c4 	addi	r2,r2,-31457
8113b1f8:	1888383a 	mulxuu	r4,r3,r2
8113b1fc:	1885383a 	mul	r2,r3,r2
8113b200:	1021883a 	mov	r16,r2
8113b204:	2023883a 	mov	r17,r4
8113b208:	8804d17a 	srli	r2,r17,5
8113b20c:	d0a09815 	stw	r2,-32160(gp)
    if (OSIdleCtrMax == 0L) {
8113b210:	d0a09817 	ldw	r2,-32160(gp)
8113b214:	1000031e 	bne	r2,zero,8113b224 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
8113b218:	d0209a05 	stb	zero,-32152(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
8113b21c:	01003fc4 	movi	r4,255
8113b220:	11418c80 	call	811418c8 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b224:	0005303a 	rdctl	r2,status
8113b228:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b22c:	e0fffb17 	ldw	r3,-20(fp)
8113b230:	00bfff84 	movi	r2,-2
8113b234:	1884703a 	and	r2,r3,r2
8113b238:	1001703a 	wrctl	status,r2
  
  return context;
8113b23c:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
8113b240:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
8113b244:	d0a09217 	ldw	r2,-32184(gp)
8113b248:	d0a0a815 	stw	r2,-32096(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
8113b24c:	d0209215 	stw	zero,-32184(gp)
8113b250:	e0bffa17 	ldw	r2,-24(fp)
8113b254:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b258:	e0bffc17 	ldw	r2,-16(fp)
8113b25c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
8113b260:	d0e0a817 	ldw	r3,-32096(gp)
8113b264:	d0a09817 	ldw	r2,-32160(gp)
8113b268:	1885203a 	divu	r2,r3,r2
8113b26c:	1007883a 	mov	r3,r2
8113b270:	00801904 	movi	r2,100
8113b274:	10c5c83a 	sub	r2,r2,r3
8113b278:	d0a09a05 	stb	r2,-32152(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
8113b27c:	114c2100 	call	8114c210 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
8113b280:	113b2900 	call	8113b290 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
8113b284:	01001904 	movi	r4,100
8113b288:	1141c580 	call	81141c58 <OSTimeDly>
    }
8113b28c:	003fe506 	br	8113b224 <__reset+0xfb11b224>

8113b290 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
8113b290:	defffa04 	addi	sp,sp,-24
8113b294:	de00012e 	bgeu	sp,et,8113b29c <OS_TaskStatStkChk+0xc>
8113b298:	003b68fa 	trap	3
8113b29c:	dfc00515 	stw	ra,20(sp)
8113b2a0:	df000415 	stw	fp,16(sp)
8113b2a4:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8113b2a8:	e03ffc05 	stb	zero,-16(fp)
8113b2ac:	00002406 	br	8113b340 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
8113b2b0:	e0bffc03 	ldbu	r2,-16(fp)
8113b2b4:	e0fffe04 	addi	r3,fp,-8
8113b2b8:	180b883a 	mov	r5,r3
8113b2bc:	1009883a 	mov	r4,r2
8113b2c0:	11417000 	call	81141700 <OSTaskStkChk>
8113b2c4:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
8113b2c8:	e0bffc43 	ldbu	r2,-15(fp)
8113b2cc:	1000191e 	bne	r2,zero,8113b334 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
8113b2d0:	e0fffc03 	ldbu	r3,-16(fp)
8113b2d4:	00a045f4 	movhi	r2,33047
8113b2d8:	10b7f904 	addi	r2,r2,-8220
8113b2dc:	18c7883a 	add	r3,r3,r3
8113b2e0:	18c7883a 	add	r3,r3,r3
8113b2e4:	10c5883a 	add	r2,r2,r3
8113b2e8:	10800017 	ldw	r2,0(r2)
8113b2ec:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
8113b2f0:	e0bffd17 	ldw	r2,-12(fp)
8113b2f4:	10000f26 	beq	r2,zero,8113b334 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
8113b2f8:	e0bffd17 	ldw	r2,-12(fp)
8113b2fc:	10800060 	cmpeqi	r2,r2,1
8113b300:	10000c1e 	bne	r2,zero,8113b334 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
8113b304:	e0bffd17 	ldw	r2,-12(fp)
8113b308:	10c00217 	ldw	r3,8(r2)
8113b30c:	e0bffd17 	ldw	r2,-12(fp)
8113b310:	10800317 	ldw	r2,12(r2)
8113b314:	1085883a 	add	r2,r2,r2
8113b318:	1085883a 	add	r2,r2,r2
8113b31c:	1887883a 	add	r3,r3,r2
8113b320:	e0bffd17 	ldw	r2,-12(fp)
8113b324:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
8113b328:	e0ffff17 	ldw	r3,-4(fp)
8113b32c:	e0bffd17 	ldw	r2,-12(fp)
8113b330:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8113b334:	e0bffc03 	ldbu	r2,-16(fp)
8113b338:	10800044 	addi	r2,r2,1
8113b33c:	e0bffc05 	stb	r2,-16(fp)
8113b340:	e0bffc03 	ldbu	r2,-16(fp)
8113b344:	10800af0 	cmpltui	r2,r2,43
8113b348:	103fd91e 	bne	r2,zero,8113b2b0 <__reset+0xfb11b2b0>
#endif
                }
            }
        }
    }
}
8113b34c:	0001883a 	nop
8113b350:	e037883a 	mov	sp,fp
8113b354:	dfc00117 	ldw	ra,4(sp)
8113b358:	df000017 	ldw	fp,0(sp)
8113b35c:	dec00204 	addi	sp,sp,8
8113b360:	f800283a 	ret

8113b364 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
8113b364:	defff204 	addi	sp,sp,-56
8113b368:	de00012e 	bgeu	sp,et,8113b370 <OS_TCBInit+0xc>
8113b36c:	003b68fa 	trap	3
8113b370:	dfc00d15 	stw	ra,52(sp)
8113b374:	df000c15 	stw	fp,48(sp)
8113b378:	df000c04 	addi	fp,sp,48
8113b37c:	e17ffc15 	stw	r5,-16(fp)
8113b380:	e1bffd15 	stw	r6,-12(fp)
8113b384:	3807883a 	mov	r3,r7
8113b388:	e0800417 	ldw	r2,16(fp)
8113b38c:	e13ffb05 	stb	r4,-20(fp)
8113b390:	e0fffe0d 	sth	r3,-8(fp)
8113b394:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113b398:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b39c:	0005303a 	rdctl	r2,status
8113b3a0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b3a4:	e0fffa17 	ldw	r3,-24(fp)
8113b3a8:	00bfff84 	movi	r2,-2
8113b3ac:	1884703a 	and	r2,r3,r2
8113b3b0:	1001703a 	wrctl	status,r2
  
  return context;
8113b3b4:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
8113b3b8:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
8113b3bc:	d0a09917 	ldw	r2,-32156(gp)
8113b3c0:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
8113b3c4:	e0bff617 	ldw	r2,-40(fp)
8113b3c8:	10009326 	beq	r2,zero,8113b618 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
8113b3cc:	e0bff617 	ldw	r2,-40(fp)
8113b3d0:	10800517 	ldw	r2,20(r2)
8113b3d4:	d0a09915 	stw	r2,-32156(gp)
8113b3d8:	e0bff417 	ldw	r2,-48(fp)
8113b3dc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b3e0:	e0bff817 	ldw	r2,-32(fp)
8113b3e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
8113b3e8:	e0bff617 	ldw	r2,-40(fp)
8113b3ec:	e0fffc17 	ldw	r3,-16(fp)
8113b3f0:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
8113b3f4:	e0bff617 	ldw	r2,-40(fp)
8113b3f8:	e0fffb03 	ldbu	r3,-20(fp)
8113b3fc:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
8113b400:	e0bff617 	ldw	r2,-40(fp)
8113b404:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
8113b408:	e0bff617 	ldw	r2,-40(fp)
8113b40c:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
8113b410:	e0bff617 	ldw	r2,-40(fp)
8113b414:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
8113b418:	e0bff617 	ldw	r2,-40(fp)
8113b41c:	e0c00317 	ldw	r3,12(fp)
8113b420:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
8113b424:	e0bff617 	ldw	r2,-40(fp)
8113b428:	e0c00217 	ldw	r3,8(fp)
8113b42c:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
8113b430:	e0bff617 	ldw	r2,-40(fp)
8113b434:	e0fffd17 	ldw	r3,-12(fp)
8113b438:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
8113b43c:	e0bff617 	ldw	r2,-40(fp)
8113b440:	e0ffff0b 	ldhu	r3,-4(fp)
8113b444:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
8113b448:	e0bff617 	ldw	r2,-40(fp)
8113b44c:	e0fffe0b 	ldhu	r3,-8(fp)
8113b450:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
8113b454:	e0bff617 	ldw	r2,-40(fp)
8113b458:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
8113b45c:	e0bffb03 	ldbu	r2,-20(fp)
8113b460:	1004d0fa 	srli	r2,r2,3
8113b464:	1007883a 	mov	r3,r2
8113b468:	e0bff617 	ldw	r2,-40(fp)
8113b46c:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
8113b470:	e0bffb03 	ldbu	r2,-20(fp)
8113b474:	108001cc 	andi	r2,r2,7
8113b478:	1007883a 	mov	r3,r2
8113b47c:	e0bff617 	ldw	r2,-40(fp)
8113b480:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
8113b484:	e0bff617 	ldw	r2,-40(fp)
8113b488:	10800d03 	ldbu	r2,52(r2)
8113b48c:	10803fcc 	andi	r2,r2,255
8113b490:	00c00044 	movi	r3,1
8113b494:	1884983a 	sll	r2,r3,r2
8113b498:	1007883a 	mov	r3,r2
8113b49c:	e0bff617 	ldw	r2,-40(fp)
8113b4a0:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
8113b4a4:	e0bff617 	ldw	r2,-40(fp)
8113b4a8:	10800cc3 	ldbu	r2,51(r2)
8113b4ac:	10803fcc 	andi	r2,r2,255
8113b4b0:	00c00044 	movi	r3,1
8113b4b4:	1884983a 	sll	r2,r3,r2
8113b4b8:	1007883a 	mov	r3,r2
8113b4bc:	e0bff617 	ldw	r2,-40(fp)
8113b4c0:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
8113b4c4:	e0bff617 	ldw	r2,-40(fp)
8113b4c8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
8113b4cc:	e0bff617 	ldw	r2,-40(fp)
8113b4d0:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
8113b4d4:	e0bff617 	ldw	r2,-40(fp)
8113b4d8:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
8113b4dc:	e0bff617 	ldw	r2,-40(fp)
8113b4e0:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
8113b4e4:	e0bff617 	ldw	r2,-40(fp)
8113b4e8:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
8113b4ec:	e0bff617 	ldw	r2,-40(fp)
8113b4f0:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
8113b4f4:	e0bff617 	ldw	r2,-40(fp)
8113b4f8:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
8113b4fc:	e0bff617 	ldw	r2,-40(fp)
8113b500:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
8113b504:	e0bff617 	ldw	r2,-40(fp)
8113b508:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
8113b50c:	e0bff617 	ldw	r2,-40(fp)
8113b510:	00c00fc4 	movi	r3,63
8113b514:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113b518:	e0bff617 	ldw	r2,-40(fp)
8113b51c:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
8113b520:	e13ff617 	ldw	r4,-40(fp)
8113b524:	114c3080 	call	8114c308 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
8113b528:	e13ff617 	ldw	r4,-40(fp)
8113b52c:	114c1900 	call	8114c190 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b530:	0005303a 	rdctl	r2,status
8113b534:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b538:	e0fff517 	ldw	r3,-44(fp)
8113b53c:	00bfff84 	movi	r2,-2
8113b540:	1884703a 	and	r2,r3,r2
8113b544:	1001703a 	wrctl	status,r2
  
  return context;
8113b548:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
8113b54c:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
8113b550:	e0fffb03 	ldbu	r3,-20(fp)
8113b554:	00a045f4 	movhi	r2,33047
8113b558:	10b7f904 	addi	r2,r2,-8220
8113b55c:	18c7883a 	add	r3,r3,r3
8113b560:	18c7883a 	add	r3,r3,r3
8113b564:	10c5883a 	add	r2,r2,r3
8113b568:	e0fff617 	ldw	r3,-40(fp)
8113b56c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
8113b570:	d0e09417 	ldw	r3,-32176(gp)
8113b574:	e0bff617 	ldw	r2,-40(fp)
8113b578:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
8113b57c:	e0bff617 	ldw	r2,-40(fp)
8113b580:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
8113b584:	d0a09417 	ldw	r2,-32176(gp)
8113b588:	10000326 	beq	r2,zero,8113b598 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
8113b58c:	d0a09417 	ldw	r2,-32176(gp)
8113b590:	e0fff617 	ldw	r3,-40(fp)
8113b594:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
8113b598:	e0bff617 	ldw	r2,-40(fp)
8113b59c:	d0a09415 	stw	r2,-32176(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
8113b5a0:	e0bff617 	ldw	r2,-40(fp)
8113b5a4:	10c00d83 	ldbu	r3,54(r2)
8113b5a8:	d0a09e03 	ldbu	r2,-32136(gp)
8113b5ac:	1884b03a 	or	r2,r3,r2
8113b5b0:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113b5b4:	e0bff617 	ldw	r2,-40(fp)
8113b5b8:	10800d03 	ldbu	r2,52(r2)
8113b5bc:	10c03fcc 	andi	r3,r2,255
8113b5c0:	e0bff617 	ldw	r2,-40(fp)
8113b5c4:	10800d03 	ldbu	r2,52(r2)
8113b5c8:	11003fcc 	andi	r4,r2,255
8113b5cc:	d0a09e44 	addi	r2,gp,-32135
8113b5d0:	2085883a 	add	r2,r4,r2
8113b5d4:	11000003 	ldbu	r4,0(r2)
8113b5d8:	e0bff617 	ldw	r2,-40(fp)
8113b5dc:	10800d43 	ldbu	r2,53(r2)
8113b5e0:	2084b03a 	or	r2,r4,r2
8113b5e4:	1009883a 	mov	r4,r2
8113b5e8:	d0a09e44 	addi	r2,gp,-32135
8113b5ec:	1885883a 	add	r2,r3,r2
8113b5f0:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
8113b5f4:	d0a09a43 	ldbu	r2,-32151(gp)
8113b5f8:	10800044 	addi	r2,r2,1
8113b5fc:	d0a09a45 	stb	r2,-32151(gp)
8113b600:	e0bff417 	ldw	r2,-48(fp)
8113b604:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b608:	e0bff717 	ldw	r2,-36(fp)
8113b60c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113b610:	0005883a 	mov	r2,zero
8113b614:	00000506 	br	8113b62c <OS_TCBInit+0x2c8>
8113b618:	e0bff417 	ldw	r2,-48(fp)
8113b61c:	e0bff915 	stw	r2,-28(fp)
8113b620:	e0bff917 	ldw	r2,-28(fp)
8113b624:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
8113b628:	00801084 	movi	r2,66
}
8113b62c:	e037883a 	mov	sp,fp
8113b630:	dfc00117 	ldw	ra,4(sp)
8113b634:	df000017 	ldw	fp,0(sp)
8113b638:	dec00204 	addi	sp,sp,8
8113b63c:	f800283a 	ret

8113b640 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
8113b640:	defffe04 	addi	sp,sp,-8
8113b644:	de00012e 	bgeu	sp,et,8113b64c <OSDebugInit+0xc>
8113b648:	003b68fa 	trap	3
8113b64c:	df000115 	stw	fp,4(sp)
8113b650:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
8113b654:	d0a01804 	addi	r2,gp,-32672
8113b658:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
8113b65c:	d0a01904 	addi	r2,gp,-32668
8113b660:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
8113b664:	d0a01a84 	addi	r2,gp,-32662
8113b668:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
8113b66c:	d0a01b04 	addi	r2,gp,-32660
8113b670:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
8113b674:	d0a01a04 	addi	r2,gp,-32664
8113b678:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
8113b67c:	d0a01b84 	addi	r2,gp,-32658
8113b680:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
8113b684:	d0a01c04 	addi	r2,gp,-32656
8113b688:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
8113b68c:	d0a01c84 	addi	r2,gp,-32654
8113b690:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
8113b694:	d0a01d04 	addi	r2,gp,-32652
8113b698:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
8113b69c:	d0a01d84 	addi	r2,gp,-32650
8113b6a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
8113b6a4:	d0a01e04 	addi	r2,gp,-32648
8113b6a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
8113b6ac:	d0a01e84 	addi	r2,gp,-32646
8113b6b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
8113b6b4:	d0a01f04 	addi	r2,gp,-32644
8113b6b8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
8113b6bc:	d0a01f84 	addi	r2,gp,-32642
8113b6c0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
8113b6c4:	d0a02004 	addi	r2,gp,-32640
8113b6c8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
8113b6cc:	d0a02084 	addi	r2,gp,-32638
8113b6d0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
8113b6d4:	d0a02104 	addi	r2,gp,-32636
8113b6d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
8113b6dc:	d0a02184 	addi	r2,gp,-32634
8113b6e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
8113b6e4:	d0a02204 	addi	r2,gp,-32632
8113b6e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
8113b6ec:	d0a02284 	addi	r2,gp,-32630
8113b6f0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
8113b6f4:	d0a02304 	addi	r2,gp,-32628
8113b6f8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
8113b6fc:	d0a02384 	addi	r2,gp,-32626
8113b700:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
8113b704:	d0a02404 	addi	r2,gp,-32624
8113b708:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
8113b70c:	d0a02484 	addi	r2,gp,-32622
8113b710:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
8113b714:	d0a02504 	addi	r2,gp,-32620
8113b718:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
8113b71c:	d0a02584 	addi	r2,gp,-32618
8113b720:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
8113b724:	d0a02604 	addi	r2,gp,-32616
8113b728:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
8113b72c:	d0a02684 	addi	r2,gp,-32614
8113b730:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
8113b734:	d0a02704 	addi	r2,gp,-32612
8113b738:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
8113b73c:	d0a02784 	addi	r2,gp,-32610
8113b740:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
8113b744:	d0a02804 	addi	r2,gp,-32608
8113b748:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
8113b74c:	d0a02884 	addi	r2,gp,-32606
8113b750:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
8113b754:	d0a02904 	addi	r2,gp,-32604
8113b758:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
8113b75c:	d0a02984 	addi	r2,gp,-32602
8113b760:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
8113b764:	d0a02a04 	addi	r2,gp,-32600
8113b768:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
8113b76c:	d0a02a84 	addi	r2,gp,-32598
8113b770:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
8113b774:	d0a02b04 	addi	r2,gp,-32596
8113b778:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
8113b77c:	d0a02b84 	addi	r2,gp,-32594
8113b780:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
8113b784:	d0a02c04 	addi	r2,gp,-32592
8113b788:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
8113b78c:	d0a02c84 	addi	r2,gp,-32590
8113b790:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
8113b794:	d0a02d04 	addi	r2,gp,-32588
8113b798:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
8113b79c:	d0a02d84 	addi	r2,gp,-32586
8113b7a0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
8113b7a4:	d0a02e04 	addi	r2,gp,-32584
8113b7a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
8113b7ac:	d0a02e84 	addi	r2,gp,-32582
8113b7b0:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
8113b7b4:	00a045f4 	movhi	r2,33047
8113b7b8:	10a21704 	addi	r2,r2,-30628
8113b7bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
8113b7c0:	00a045f4 	movhi	r2,33047
8113b7c4:	10a00304 	addi	r2,r2,-32756
8113b7c8:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
8113b7cc:	d0a02f84 	addi	r2,gp,-32578
8113b7d0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
8113b7d4:	d0a03004 	addi	r2,gp,-32576
8113b7d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
8113b7dc:	d0a03084 	addi	r2,gp,-32574
8113b7e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
8113b7e4:	d0a03104 	addi	r2,gp,-32572
8113b7e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
8113b7ec:	d0a03184 	addi	r2,gp,-32570
8113b7f0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
8113b7f4:	d0a03204 	addi	r2,gp,-32568
8113b7f8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
8113b7fc:	d0a03284 	addi	r2,gp,-32566
8113b800:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
8113b804:	d0a03304 	addi	r2,gp,-32564
8113b808:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
8113b80c:	d0a03384 	addi	r2,gp,-32562
8113b810:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
8113b814:	d0a02f04 	addi	r2,gp,-32580
8113b818:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
8113b81c:	d0a03404 	addi	r2,gp,-32560
8113b820:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
8113b824:	0001883a 	nop
8113b828:	e037883a 	mov	sp,fp
8113b82c:	df000017 	ldw	fp,0(sp)
8113b830:	dec00104 	addi	sp,sp,4
8113b834:	f800283a 	ret

8113b838 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
8113b838:	defff204 	addi	sp,sp,-56
8113b83c:	de00012e 	bgeu	sp,et,8113b844 <OSFlagAccept+0xc>
8113b840:	003b68fa 	trap	3
8113b844:	df000d15 	stw	fp,52(sp)
8113b848:	df000d04 	addi	fp,sp,52
8113b84c:	e13ffc15 	stw	r4,-16(fp)
8113b850:	2807883a 	mov	r3,r5
8113b854:	3005883a 	mov	r2,r6
8113b858:	e1ffff15 	stw	r7,-4(fp)
8113b85c:	e0fffd0d 	sth	r3,-12(fp)
8113b860:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113b864:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113b868:	e0bfff17 	ldw	r2,-4(fp)
8113b86c:	1000021e 	bne	r2,zero,8113b878 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
8113b870:	0005883a 	mov	r2,zero
8113b874:	0000b006 	br	8113bb38 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113b878:	e0bffc17 	ldw	r2,-16(fp)
8113b87c:	1000051e 	bne	r2,zero,8113b894 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113b880:	e0bfff17 	ldw	r2,-4(fp)
8113b884:	00c01b84 	movi	r3,110
8113b888:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b88c:	0005883a 	mov	r2,zero
8113b890:	0000a906 	br	8113bb38 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113b894:	e0bffc17 	ldw	r2,-16(fp)
8113b898:	10800003 	ldbu	r2,0(r2)
8113b89c:	10803fcc 	andi	r2,r2,255
8113b8a0:	10800160 	cmpeqi	r2,r2,5
8113b8a4:	1000051e 	bne	r2,zero,8113b8bc <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
8113b8a8:	e0bfff17 	ldw	r2,-4(fp)
8113b8ac:	00c00044 	movi	r3,1
8113b8b0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b8b4:	0005883a 	mov	r2,zero
8113b8b8:	00009f06 	br	8113bb38 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113b8bc:	e0fffe03 	ldbu	r3,-8(fp)
8113b8c0:	00bfe004 	movi	r2,-128
8113b8c4:	1884703a 	and	r2,r3,r2
8113b8c8:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
8113b8cc:	e0bff503 	ldbu	r2,-44(fp)
8113b8d0:	10000626 	beq	r2,zero,8113b8ec <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
8113b8d4:	e0bffe03 	ldbu	r2,-8(fp)
8113b8d8:	10801fcc 	andi	r2,r2,127
8113b8dc:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113b8e0:	00800044 	movi	r2,1
8113b8e4:	e0bff385 	stb	r2,-50(fp)
8113b8e8:	00000106 	br	8113b8f0 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
8113b8ec:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
8113b8f0:	e0bfff17 	ldw	r2,-4(fp)
8113b8f4:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b8f8:	0005303a 	rdctl	r2,status
8113b8fc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b900:	e0fffb17 	ldw	r3,-20(fp)
8113b904:	00bfff84 	movi	r2,-2
8113b908:	1884703a 	and	r2,r3,r2
8113b90c:	1001703a 	wrctl	status,r2
  
  return context;
8113b910:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
8113b914:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
8113b918:	e0bffe03 	ldbu	r2,-8(fp)
8113b91c:	10c00060 	cmpeqi	r3,r2,1
8113b920:	18005f1e 	bne	r3,zero,8113baa0 <OSFlagAccept+0x268>
8113b924:	10c00088 	cmpgei	r3,r2,2
8113b928:	1800021e 	bne	r3,zero,8113b934 <OSFlagAccept+0xfc>
8113b92c:	10003f26 	beq	r2,zero,8113ba2c <OSFlagAccept+0x1f4>
8113b930:	00007706 	br	8113bb10 <OSFlagAccept+0x2d8>
8113b934:	10c000a0 	cmpeqi	r3,r2,2
8113b938:	1800031e 	bne	r3,zero,8113b948 <OSFlagAccept+0x110>
8113b93c:	108000e0 	cmpeqi	r2,r2,3
8113b940:	10001e1e 	bne	r2,zero,8113b9bc <OSFlagAccept+0x184>
8113b944:	00007206 	br	8113bb10 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113b948:	e0bffc17 	ldw	r2,-16(fp)
8113b94c:	10c0020b 	ldhu	r3,8(r2)
8113b950:	e0bffd0b 	ldhu	r2,-12(fp)
8113b954:	1884703a 	and	r2,r3,r2
8113b958:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113b95c:	e0fff30b 	ldhu	r3,-52(fp)
8113b960:	e0bffd0b 	ldhu	r2,-12(fp)
8113b964:	18800d1e 	bne	r3,r2,8113b99c <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113b968:	e0bff383 	ldbu	r2,-50(fp)
8113b96c:	10800058 	cmpnei	r2,r2,1
8113b970:	10000d1e 	bne	r2,zero,8113b9a8 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113b974:	e0bffc17 	ldw	r2,-16(fp)
8113b978:	1080020b 	ldhu	r2,8(r2)
8113b97c:	1007883a 	mov	r3,r2
8113b980:	e0bff30b 	ldhu	r2,-52(fp)
8113b984:	0084303a 	nor	r2,zero,r2
8113b988:	1884703a 	and	r2,r3,r2
8113b98c:	1007883a 	mov	r3,r2
8113b990:	e0bffc17 	ldw	r2,-16(fp)
8113b994:	10c0020d 	sth	r3,8(r2)
8113b998:	00000306 	br	8113b9a8 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113b99c:	e0bfff17 	ldw	r2,-4(fp)
8113b9a0:	00c01c04 	movi	r3,112
8113b9a4:	10c00005 	stb	r3,0(r2)
8113b9a8:	e0bff417 	ldw	r2,-48(fp)
8113b9ac:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b9b0:	e0bff617 	ldw	r2,-40(fp)
8113b9b4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113b9b8:	00005e06 	br	8113bb34 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113b9bc:	e0bffc17 	ldw	r2,-16(fp)
8113b9c0:	10c0020b 	ldhu	r3,8(r2)
8113b9c4:	e0bffd0b 	ldhu	r2,-12(fp)
8113b9c8:	1884703a 	and	r2,r3,r2
8113b9cc:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113b9d0:	e0bff30b 	ldhu	r2,-52(fp)
8113b9d4:	10000d26 	beq	r2,zero,8113ba0c <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113b9d8:	e0bff383 	ldbu	r2,-50(fp)
8113b9dc:	10800058 	cmpnei	r2,r2,1
8113b9e0:	10000d1e 	bne	r2,zero,8113ba18 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113b9e4:	e0bffc17 	ldw	r2,-16(fp)
8113b9e8:	1080020b 	ldhu	r2,8(r2)
8113b9ec:	1007883a 	mov	r3,r2
8113b9f0:	e0bff30b 	ldhu	r2,-52(fp)
8113b9f4:	0084303a 	nor	r2,zero,r2
8113b9f8:	1884703a 	and	r2,r3,r2
8113b9fc:	1007883a 	mov	r3,r2
8113ba00:	e0bffc17 	ldw	r2,-16(fp)
8113ba04:	10c0020d 	sth	r3,8(r2)
8113ba08:	00000306 	br	8113ba18 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113ba0c:	e0bfff17 	ldw	r2,-4(fp)
8113ba10:	00c01c04 	movi	r3,112
8113ba14:	10c00005 	stb	r3,0(r2)
8113ba18:	e0bff417 	ldw	r2,-48(fp)
8113ba1c:	e0bff715 	stw	r2,-36(fp)
8113ba20:	e0bff717 	ldw	r2,-36(fp)
8113ba24:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113ba28:	00004206 	br	8113bb34 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113ba2c:	e0bffc17 	ldw	r2,-16(fp)
8113ba30:	1080020b 	ldhu	r2,8(r2)
8113ba34:	0084303a 	nor	r2,zero,r2
8113ba38:	1007883a 	mov	r3,r2
8113ba3c:	e0bffd0b 	ldhu	r2,-12(fp)
8113ba40:	1884703a 	and	r2,r3,r2
8113ba44:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113ba48:	e0fff30b 	ldhu	r3,-52(fp)
8113ba4c:	e0bffd0b 	ldhu	r2,-12(fp)
8113ba50:	18800b1e 	bne	r3,r2,8113ba80 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113ba54:	e0bff383 	ldbu	r2,-50(fp)
8113ba58:	10800058 	cmpnei	r2,r2,1
8113ba5c:	10000b1e 	bne	r2,zero,8113ba8c <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113ba60:	e0bffc17 	ldw	r2,-16(fp)
8113ba64:	10c0020b 	ldhu	r3,8(r2)
8113ba68:	e0bff30b 	ldhu	r2,-52(fp)
8113ba6c:	1884b03a 	or	r2,r3,r2
8113ba70:	1007883a 	mov	r3,r2
8113ba74:	e0bffc17 	ldw	r2,-16(fp)
8113ba78:	10c0020d 	sth	r3,8(r2)
8113ba7c:	00000306 	br	8113ba8c <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113ba80:	e0bfff17 	ldw	r2,-4(fp)
8113ba84:	00c01c04 	movi	r3,112
8113ba88:	10c00005 	stb	r3,0(r2)
8113ba8c:	e0bff417 	ldw	r2,-48(fp)
8113ba90:	e0bff815 	stw	r2,-32(fp)
8113ba94:	e0bff817 	ldw	r2,-32(fp)
8113ba98:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113ba9c:	00002506 	br	8113bb34 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113baa0:	e0bffc17 	ldw	r2,-16(fp)
8113baa4:	1080020b 	ldhu	r2,8(r2)
8113baa8:	0084303a 	nor	r2,zero,r2
8113baac:	1007883a 	mov	r3,r2
8113bab0:	e0bffd0b 	ldhu	r2,-12(fp)
8113bab4:	1884703a 	and	r2,r3,r2
8113bab8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113babc:	e0bff30b 	ldhu	r2,-52(fp)
8113bac0:	10000b26 	beq	r2,zero,8113baf0 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113bac4:	e0bff383 	ldbu	r2,-50(fp)
8113bac8:	10800058 	cmpnei	r2,r2,1
8113bacc:	10000b1e 	bne	r2,zero,8113bafc <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113bad0:	e0bffc17 	ldw	r2,-16(fp)
8113bad4:	10c0020b 	ldhu	r3,8(r2)
8113bad8:	e0bff30b 	ldhu	r2,-52(fp)
8113badc:	1884b03a 	or	r2,r3,r2
8113bae0:	1007883a 	mov	r3,r2
8113bae4:	e0bffc17 	ldw	r2,-16(fp)
8113bae8:	10c0020d 	sth	r3,8(r2)
8113baec:	00000306 	br	8113bafc <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113baf0:	e0bfff17 	ldw	r2,-4(fp)
8113baf4:	00c01c04 	movi	r3,112
8113baf8:	10c00005 	stb	r3,0(r2)
8113bafc:	e0bff417 	ldw	r2,-48(fp)
8113bb00:	e0bff915 	stw	r2,-28(fp)
8113bb04:	e0bff917 	ldw	r2,-28(fp)
8113bb08:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113bb0c:	00000906 	br	8113bb34 <OSFlagAccept+0x2fc>
8113bb10:	e0bff417 	ldw	r2,-48(fp)
8113bb14:	e0bffa15 	stw	r2,-24(fp)
8113bb18:	e0bffa17 	ldw	r2,-24(fp)
8113bb1c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113bb20:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
8113bb24:	e0bfff17 	ldw	r2,-4(fp)
8113bb28:	00c01bc4 	movi	r3,111
8113bb2c:	10c00005 	stb	r3,0(r2)
             break;
8113bb30:	0001883a 	nop
    }
    return (flags_rdy);
8113bb34:	e0bff30b 	ldhu	r2,-52(fp)
}
8113bb38:	e037883a 	mov	sp,fp
8113bb3c:	df000017 	ldw	fp,0(sp)
8113bb40:	dec00104 	addi	sp,sp,4
8113bb44:	f800283a 	ret

8113bb48 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
8113bb48:	defff804 	addi	sp,sp,-32
8113bb4c:	de00012e 	bgeu	sp,et,8113bb54 <OSFlagCreate+0xc>
8113bb50:	003b68fa 	trap	3
8113bb54:	df000715 	stw	fp,28(sp)
8113bb58:	df000704 	addi	fp,sp,28
8113bb5c:	2005883a 	mov	r2,r4
8113bb60:	e17fff15 	stw	r5,-4(fp)
8113bb64:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
8113bb68:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
8113bb6c:	e0bfff17 	ldw	r2,-4(fp)
8113bb70:	1000021e 	bne	r2,zero,8113bb7c <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
8113bb74:	0005883a 	mov	r2,zero
8113bb78:	00003306 	br	8113bc48 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
8113bb7c:	d0a0a103 	ldbu	r2,-32124(gp)
8113bb80:	10803fcc 	andi	r2,r2,255
8113bb84:	10000526 	beq	r2,zero,8113bb9c <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
8113bb88:	e0bfff17 	ldw	r2,-4(fp)
8113bb8c:	00c00404 	movi	r3,16
8113bb90:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
8113bb94:	0005883a 	mov	r2,zero
8113bb98:	00002b06 	br	8113bc48 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bb9c:	0005303a 	rdctl	r2,status
8113bba0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bba4:	e0fffd17 	ldw	r3,-12(fp)
8113bba8:	00bfff84 	movi	r2,-2
8113bbac:	1884703a 	and	r2,r3,r2
8113bbb0:	1001703a 	wrctl	status,r2
  
  return context;
8113bbb4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113bbb8:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
8113bbbc:	d0a0a617 	ldw	r2,-32104(gp)
8113bbc0:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
8113bbc4:	e0bffb17 	ldw	r2,-20(fp)
8113bbc8:	10001726 	beq	r2,zero,8113bc28 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
8113bbcc:	d0a0a617 	ldw	r2,-32104(gp)
8113bbd0:	10800117 	ldw	r2,4(r2)
8113bbd4:	d0a0a615 	stw	r2,-32104(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
8113bbd8:	e0bffb17 	ldw	r2,-20(fp)
8113bbdc:	00c00144 	movi	r3,5
8113bbe0:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
8113bbe4:	e0bffb17 	ldw	r2,-20(fp)
8113bbe8:	e0fffe0b 	ldhu	r3,-8(fp)
8113bbec:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8113bbf0:	e0bffb17 	ldw	r2,-20(fp)
8113bbf4:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
8113bbf8:	e0bffb17 	ldw	r2,-20(fp)
8113bbfc:	00c00fc4 	movi	r3,63
8113bc00:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113bc04:	e0bffb17 	ldw	r2,-20(fp)
8113bc08:	100002c5 	stb	zero,11(r2)
8113bc0c:	e0bff917 	ldw	r2,-28(fp)
8113bc10:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bc14:	e0bffa17 	ldw	r2,-24(fp)
8113bc18:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
8113bc1c:	e0bfff17 	ldw	r2,-4(fp)
8113bc20:	10000005 	stb	zero,0(r2)
8113bc24:	00000706 	br	8113bc44 <OSFlagCreate+0xfc>
8113bc28:	e0bff917 	ldw	r2,-28(fp)
8113bc2c:	e0bffc15 	stw	r2,-16(fp)
8113bc30:	e0bffc17 	ldw	r2,-16(fp)
8113bc34:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
8113bc38:	e0bfff17 	ldw	r2,-4(fp)
8113bc3c:	00c01c84 	movi	r3,114
8113bc40:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
8113bc44:	e0bffb17 	ldw	r2,-20(fp)
}
8113bc48:	e037883a 	mov	sp,fp
8113bc4c:	df000017 	ldw	fp,0(sp)
8113bc50:	dec00104 	addi	sp,sp,4
8113bc54:	f800283a 	ret

8113bc58 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
8113bc58:	defff204 	addi	sp,sp,-56
8113bc5c:	de00012e 	bgeu	sp,et,8113bc64 <OSFlagDel+0xc>
8113bc60:	003b68fa 	trap	3
8113bc64:	dfc00d15 	stw	ra,52(sp)
8113bc68:	df000c15 	stw	fp,48(sp)
8113bc6c:	df000c04 	addi	fp,sp,48
8113bc70:	e13ffd15 	stw	r4,-12(fp)
8113bc74:	2805883a 	mov	r2,r5
8113bc78:	e1bfff15 	stw	r6,-4(fp)
8113bc7c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113bc80:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113bc84:	e0bfff17 	ldw	r2,-4(fp)
8113bc88:	1000021e 	bne	r2,zero,8113bc94 <OSFlagDel+0x3c>
        return (pgrp);
8113bc8c:	e0bffd17 	ldw	r2,-12(fp)
8113bc90:	00008006 	br	8113be94 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113bc94:	e0bffd17 	ldw	r2,-12(fp)
8113bc98:	1000051e 	bne	r2,zero,8113bcb0 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113bc9c:	e0bfff17 	ldw	r2,-4(fp)
8113bca0:	00c01b84 	movi	r3,110
8113bca4:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113bca8:	e0bffd17 	ldw	r2,-12(fp)
8113bcac:	00007906 	br	8113be94 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113bcb0:	d0a0a103 	ldbu	r2,-32124(gp)
8113bcb4:	10803fcc 	andi	r2,r2,255
8113bcb8:	10000526 	beq	r2,zero,8113bcd0 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113bcbc:	e0bfff17 	ldw	r2,-4(fp)
8113bcc0:	00c003c4 	movi	r3,15
8113bcc4:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113bcc8:	e0bffd17 	ldw	r2,-12(fp)
8113bccc:	00007106 	br	8113be94 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
8113bcd0:	e0bffd17 	ldw	r2,-12(fp)
8113bcd4:	10800003 	ldbu	r2,0(r2)
8113bcd8:	10803fcc 	andi	r2,r2,255
8113bcdc:	10800160 	cmpeqi	r2,r2,5
8113bce0:	1000051e 	bne	r2,zero,8113bcf8 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
8113bce4:	e0bfff17 	ldw	r2,-4(fp)
8113bce8:	00c00044 	movi	r3,1
8113bcec:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113bcf0:	e0bffd17 	ldw	r2,-12(fp)
8113bcf4:	00006706 	br	8113be94 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bcf8:	0005303a 	rdctl	r2,status
8113bcfc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bd00:	e0fffc17 	ldw	r3,-16(fp)
8113bd04:	00bfff84 	movi	r2,-2
8113bd08:	1884703a 	and	r2,r3,r2
8113bd0c:	1001703a 	wrctl	status,r2
  
  return context;
8113bd10:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113bd14:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
8113bd18:	e0bffd17 	ldw	r2,-12(fp)
8113bd1c:	10800117 	ldw	r2,4(r2)
8113bd20:	10000326 	beq	r2,zero,8113bd30 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113bd24:	00800044 	movi	r2,1
8113bd28:	e0bff405 	stb	r2,-48(fp)
8113bd2c:	00000106 	br	8113bd34 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113bd30:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113bd34:	e0bffe03 	ldbu	r2,-8(fp)
8113bd38:	10000326 	beq	r2,zero,8113bd48 <OSFlagDel+0xf0>
8113bd3c:	10800060 	cmpeqi	r2,r2,1
8113bd40:	1000231e 	bne	r2,zero,8113bdd0 <OSFlagDel+0x178>
8113bd44:	00004806 	br	8113be68 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
8113bd48:	e0bff403 	ldbu	r2,-48(fp)
8113bd4c:	1000161e 	bne	r2,zero,8113bda8 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
8113bd50:	e0bffd17 	ldw	r2,-12(fp)
8113bd54:	00c00fc4 	movi	r3,63
8113bd58:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113bd5c:	e0bffd17 	ldw	r2,-12(fp)
8113bd60:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113bd64:	e0bffd17 	ldw	r2,-12(fp)
8113bd68:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
8113bd6c:	d0e0a617 	ldw	r3,-32104(gp)
8113bd70:	e0bffd17 	ldw	r2,-12(fp)
8113bd74:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113bd78:	e0bffd17 	ldw	r2,-12(fp)
8113bd7c:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
8113bd80:	e0bffd17 	ldw	r2,-12(fp)
8113bd84:	d0a0a615 	stw	r2,-32104(gp)
8113bd88:	e0bff717 	ldw	r2,-36(fp)
8113bd8c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bd90:	e0bff817 	ldw	r2,-32(fp)
8113bd94:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
8113bd98:	e0bfff17 	ldw	r2,-4(fp)
8113bd9c:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
8113bda0:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
8113bda4:	00003a06 	br	8113be90 <OSFlagDel+0x238>
8113bda8:	e0bff717 	ldw	r2,-36(fp)
8113bdac:	e0bff915 	stw	r2,-28(fp)
8113bdb0:	e0bff917 	ldw	r2,-28(fp)
8113bdb4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
8113bdb8:	e0bfff17 	ldw	r2,-4(fp)
8113bdbc:	00c01244 	movi	r3,73
8113bdc0:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
8113bdc4:	e0bffd17 	ldw	r2,-12(fp)
8113bdc8:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113bdcc:	00003006 	br	8113be90 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113bdd0:	e0bffd17 	ldw	r2,-12(fp)
8113bdd4:	10800117 	ldw	r2,4(r2)
8113bdd8:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113bddc:	00000606 	br	8113bdf8 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
8113bde0:	000b883a 	mov	r5,zero
8113bde4:	e13ff517 	ldw	r4,-44(fp)
8113bde8:	113ce0c0 	call	8113ce0c <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113bdec:	e0bff517 	ldw	r2,-44(fp)
8113bdf0:	10800017 	ldw	r2,0(r2)
8113bdf4:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113bdf8:	e0bff517 	ldw	r2,-44(fp)
8113bdfc:	103ff81e 	bne	r2,zero,8113bde0 <__reset+0xfb11bde0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
8113be00:	e0bffd17 	ldw	r2,-12(fp)
8113be04:	00c00fc4 	movi	r3,63
8113be08:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113be0c:	e0bffd17 	ldw	r2,-12(fp)
8113be10:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113be14:	e0bffd17 	ldw	r2,-12(fp)
8113be18:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
8113be1c:	d0e0a617 	ldw	r3,-32104(gp)
8113be20:	e0bffd17 	ldw	r2,-12(fp)
8113be24:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113be28:	e0bffd17 	ldw	r2,-12(fp)
8113be2c:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
8113be30:	e0bffd17 	ldw	r2,-12(fp)
8113be34:	d0a0a615 	stw	r2,-32104(gp)
8113be38:	e0bff717 	ldw	r2,-36(fp)
8113be3c:	e0bffa15 	stw	r2,-24(fp)
8113be40:	e0bffa17 	ldw	r2,-24(fp)
8113be44:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113be48:	e0bff403 	ldbu	r2,-48(fp)
8113be4c:	10800058 	cmpnei	r2,r2,1
8113be50:	1000011e 	bne	r2,zero,8113be58 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113be54:	113af1c0 	call	8113af1c <OS_Sched>
             }
             *perr = OS_ERR_NONE;
8113be58:	e0bfff17 	ldw	r2,-4(fp)
8113be5c:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
8113be60:	e03ff615 	stw	zero,-40(fp)
             break;
8113be64:	00000a06 	br	8113be90 <OSFlagDel+0x238>
8113be68:	e0bff717 	ldw	r2,-36(fp)
8113be6c:	e0bffb15 	stw	r2,-20(fp)
8113be70:	e0bffb17 	ldw	r2,-20(fp)
8113be74:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
8113be78:	e0bfff17 	ldw	r2,-4(fp)
8113be7c:	00c001c4 	movi	r3,7
8113be80:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
8113be84:	e0bffd17 	ldw	r2,-12(fp)
8113be88:	e0bff615 	stw	r2,-40(fp)
             break;
8113be8c:	0001883a 	nop
    }
    return (pgrp_return);
8113be90:	e0bff617 	ldw	r2,-40(fp)
}
8113be94:	e037883a 	mov	sp,fp
8113be98:	dfc00117 	ldw	ra,4(sp)
8113be9c:	df000017 	ldw	fp,0(sp)
8113bea0:	dec00204 	addi	sp,sp,8
8113bea4:	f800283a 	ret

8113bea8 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113bea8:	defff604 	addi	sp,sp,-40
8113beac:	de00012e 	bgeu	sp,et,8113beb4 <OSFlagNameGet+0xc>
8113beb0:	003b68fa 	trap	3
8113beb4:	dfc00915 	stw	ra,36(sp)
8113beb8:	df000815 	stw	fp,32(sp)
8113bebc:	df000804 	addi	fp,sp,32
8113bec0:	e13ffd15 	stw	r4,-12(fp)
8113bec4:	e17ffe15 	stw	r5,-8(fp)
8113bec8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113becc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113bed0:	e0bfff17 	ldw	r2,-4(fp)
8113bed4:	1000021e 	bne	r2,zero,8113bee0 <OSFlagNameGet+0x38>
        return (0);
8113bed8:	0005883a 	mov	r2,zero
8113bedc:	00003906 	br	8113bfc4 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113bee0:	e0bffd17 	ldw	r2,-12(fp)
8113bee4:	1000051e 	bne	r2,zero,8113befc <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113bee8:	e0bfff17 	ldw	r2,-4(fp)
8113beec:	00c01b84 	movi	r3,110
8113bef0:	10c00005 	stb	r3,0(r2)
        return (0);
8113bef4:	0005883a 	mov	r2,zero
8113bef8:	00003206 	br	8113bfc4 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113befc:	e0bffe17 	ldw	r2,-8(fp)
8113bf00:	1000051e 	bne	r2,zero,8113bf18 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113bf04:	e0bfff17 	ldw	r2,-4(fp)
8113bf08:	00c00304 	movi	r3,12
8113bf0c:	10c00005 	stb	r3,0(r2)
        return (0);
8113bf10:	0005883a 	mov	r2,zero
8113bf14:	00002b06 	br	8113bfc4 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113bf18:	d0a0a103 	ldbu	r2,-32124(gp)
8113bf1c:	10803fcc 	andi	r2,r2,255
8113bf20:	10000526 	beq	r2,zero,8113bf38 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113bf24:	e0bfff17 	ldw	r2,-4(fp)
8113bf28:	00c00444 	movi	r3,17
8113bf2c:	10c00005 	stb	r3,0(r2)
        return (0);
8113bf30:	0005883a 	mov	r2,zero
8113bf34:	00002306 	br	8113bfc4 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bf38:	0005303a 	rdctl	r2,status
8113bf3c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bf40:	e0fffc17 	ldw	r3,-16(fp)
8113bf44:	00bfff84 	movi	r2,-2
8113bf48:	1884703a 	and	r2,r3,r2
8113bf4c:	1001703a 	wrctl	status,r2
  
  return context;
8113bf50:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113bf54:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113bf58:	e0bffd17 	ldw	r2,-12(fp)
8113bf5c:	10800003 	ldbu	r2,0(r2)
8113bf60:	10803fcc 	andi	r2,r2,255
8113bf64:	10800160 	cmpeqi	r2,r2,5
8113bf68:	1000091e 	bne	r2,zero,8113bf90 <OSFlagNameGet+0xe8>
8113bf6c:	e0bff817 	ldw	r2,-32(fp)
8113bf70:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bf74:	e0bff917 	ldw	r2,-28(fp)
8113bf78:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113bf7c:	e0bfff17 	ldw	r2,-4(fp)
8113bf80:	00c00044 	movi	r3,1
8113bf84:	10c00005 	stb	r3,0(r2)
        return (0);
8113bf88:	0005883a 	mov	r2,zero
8113bf8c:	00000d06 	br	8113bfc4 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
8113bf90:	e0bffd17 	ldw	r2,-12(fp)
8113bf94:	10800284 	addi	r2,r2,10
8113bf98:	100b883a 	mov	r5,r2
8113bf9c:	e13ffe17 	ldw	r4,-8(fp)
8113bfa0:	113b0700 	call	8113b070 <OS_StrCopy>
8113bfa4:	e0bffb05 	stb	r2,-20(fp)
8113bfa8:	e0bff817 	ldw	r2,-32(fp)
8113bfac:	e0bffa15 	stw	r2,-24(fp)
8113bfb0:	e0bffa17 	ldw	r2,-24(fp)
8113bfb4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113bfb8:	e0bfff17 	ldw	r2,-4(fp)
8113bfbc:	10000005 	stb	zero,0(r2)
    return (len);
8113bfc0:	e0bffb03 	ldbu	r2,-20(fp)
}
8113bfc4:	e037883a 	mov	sp,fp
8113bfc8:	dfc00117 	ldw	ra,4(sp)
8113bfcc:	df000017 	ldw	fp,0(sp)
8113bfd0:	dec00204 	addi	sp,sp,8
8113bfd4:	f800283a 	ret

8113bfd8 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113bfd8:	defff504 	addi	sp,sp,-44
8113bfdc:	de00012e 	bgeu	sp,et,8113bfe4 <OSFlagNameSet+0xc>
8113bfe0:	003b68fa 	trap	3
8113bfe4:	dfc00a15 	stw	ra,40(sp)
8113bfe8:	df000915 	stw	fp,36(sp)
8113bfec:	df000904 	addi	fp,sp,36
8113bff0:	e13ffd15 	stw	r4,-12(fp)
8113bff4:	e17ffe15 	stw	r5,-8(fp)
8113bff8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bffc:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113c000:	e0bfff17 	ldw	r2,-4(fp)
8113c004:	10004326 	beq	r2,zero,8113c114 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113c008:	e0bffd17 	ldw	r2,-12(fp)
8113c00c:	1000041e 	bne	r2,zero,8113c020 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113c010:	e0bfff17 	ldw	r2,-4(fp)
8113c014:	00c01b84 	movi	r3,110
8113c018:	10c00005 	stb	r3,0(r2)
        return;
8113c01c:	00003e06 	br	8113c118 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113c020:	e0bffe17 	ldw	r2,-8(fp)
8113c024:	1000041e 	bne	r2,zero,8113c038 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113c028:	e0bfff17 	ldw	r2,-4(fp)
8113c02c:	00c00304 	movi	r3,12
8113c030:	10c00005 	stb	r3,0(r2)
        return;
8113c034:	00003806 	br	8113c118 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113c038:	d0a0a103 	ldbu	r2,-32124(gp)
8113c03c:	10803fcc 	andi	r2,r2,255
8113c040:	10000426 	beq	r2,zero,8113c054 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113c044:	e0bfff17 	ldw	r2,-4(fp)
8113c048:	00c00484 	movi	r3,18
8113c04c:	10c00005 	stb	r3,0(r2)
        return;
8113c050:	00003106 	br	8113c118 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c054:	0005303a 	rdctl	r2,status
8113c058:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c05c:	e0fffc17 	ldw	r3,-16(fp)
8113c060:	00bfff84 	movi	r2,-2
8113c064:	1884703a 	and	r2,r3,r2
8113c068:	1001703a 	wrctl	status,r2
  
  return context;
8113c06c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113c070:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113c074:	e0bffd17 	ldw	r2,-12(fp)
8113c078:	10800003 	ldbu	r2,0(r2)
8113c07c:	10803fcc 	andi	r2,r2,255
8113c080:	10800160 	cmpeqi	r2,r2,5
8113c084:	1000081e 	bne	r2,zero,8113c0a8 <OSFlagNameSet+0xd0>
8113c088:	e0bff717 	ldw	r2,-36(fp)
8113c08c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c090:	e0bff817 	ldw	r2,-32(fp)
8113c094:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113c098:	e0bfff17 	ldw	r2,-4(fp)
8113c09c:	00c00044 	movi	r3,1
8113c0a0:	10c00005 	stb	r3,0(r2)
        return;
8113c0a4:	00001c06 	br	8113c118 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113c0a8:	e13ffe17 	ldw	r4,-8(fp)
8113c0ac:	113b0ec0 	call	8113b0ec <OS_StrLen>
8113c0b0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
8113c0b4:	e0bffa03 	ldbu	r2,-24(fp)
8113c0b8:	10800830 	cmpltui	r2,r2,32
8113c0bc:	1000081e 	bne	r2,zero,8113c0e0 <OSFlagNameSet+0x108>
8113c0c0:	e0bff717 	ldw	r2,-36(fp)
8113c0c4:	e0bff915 	stw	r2,-28(fp)
8113c0c8:	e0bff917 	ldw	r2,-28(fp)
8113c0cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
8113c0d0:	e0bfff17 	ldw	r2,-4(fp)
8113c0d4:	00c01cc4 	movi	r3,115
8113c0d8:	10c00005 	stb	r3,0(r2)
        return;
8113c0dc:	00000e06 	br	8113c118 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
8113c0e0:	e0bffd17 	ldw	r2,-12(fp)
8113c0e4:	10800284 	addi	r2,r2,10
8113c0e8:	e17ffe17 	ldw	r5,-8(fp)
8113c0ec:	1009883a 	mov	r4,r2
8113c0f0:	113b0700 	call	8113b070 <OS_StrCopy>
8113c0f4:	e0bff717 	ldw	r2,-36(fp)
8113c0f8:	e0bffb15 	stw	r2,-20(fp)
8113c0fc:	e0bffb17 	ldw	r2,-20(fp)
8113c100:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113c104:	e0bfff17 	ldw	r2,-4(fp)
8113c108:	10000005 	stb	zero,0(r2)
    return;
8113c10c:	0001883a 	nop
8113c110:	00000106 	br	8113c118 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113c114:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
8113c118:	e037883a 	mov	sp,fp
8113c11c:	dfc00117 	ldw	ra,4(sp)
8113c120:	df000017 	ldw	fp,0(sp)
8113c124:	dec00204 	addi	sp,sp,8
8113c128:	f800283a 	ret

8113c12c <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
8113c12c:	deffe104 	addi	sp,sp,-124
8113c130:	de00012e 	bgeu	sp,et,8113c138 <OSFlagPend+0xc>
8113c134:	003b68fa 	trap	3
8113c138:	dfc01e15 	stw	ra,120(sp)
8113c13c:	df001d15 	stw	fp,116(sp)
8113c140:	df001d04 	addi	fp,sp,116
8113c144:	e13ffc15 	stw	r4,-16(fp)
8113c148:	2809883a 	mov	r4,r5
8113c14c:	3007883a 	mov	r3,r6
8113c150:	3805883a 	mov	r2,r7
8113c154:	e13ffd0d 	sth	r4,-12(fp)
8113c158:	e0fffe05 	stb	r3,-8(fp)
8113c15c:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113c160:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c164:	e0800217 	ldw	r2,8(fp)
8113c168:	1000021e 	bne	r2,zero,8113c174 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
8113c16c:	0005883a 	mov	r2,zero
8113c170:	00015906 	br	8113c6d8 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113c174:	e0bffc17 	ldw	r2,-16(fp)
8113c178:	1000051e 	bne	r2,zero,8113c190 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113c17c:	e0800217 	ldw	r2,8(fp)
8113c180:	00c01b84 	movi	r3,110
8113c184:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c188:	0005883a 	mov	r2,zero
8113c18c:	00015206 	br	8113c6d8 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c190:	d0a0a103 	ldbu	r2,-32124(gp)
8113c194:	10803fcc 	andi	r2,r2,255
8113c198:	10000526 	beq	r2,zero,8113c1b0 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113c19c:	e0800217 	ldw	r2,8(fp)
8113c1a0:	00c00084 	movi	r3,2
8113c1a4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c1a8:	0005883a 	mov	r2,zero
8113c1ac:	00014a06 	br	8113c6d8 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113c1b0:	d0a08f03 	ldbu	r2,-32196(gp)
8113c1b4:	10803fcc 	andi	r2,r2,255
8113c1b8:	10000526 	beq	r2,zero,8113c1d0 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113c1bc:	e0800217 	ldw	r2,8(fp)
8113c1c0:	00c00344 	movi	r3,13
8113c1c4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c1c8:	0005883a 	mov	r2,zero
8113c1cc:	00014206 	br	8113c6d8 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113c1d0:	e0bffc17 	ldw	r2,-16(fp)
8113c1d4:	10800003 	ldbu	r2,0(r2)
8113c1d8:	10803fcc 	andi	r2,r2,255
8113c1dc:	10800160 	cmpeqi	r2,r2,5
8113c1e0:	1000051e 	bne	r2,zero,8113c1f8 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
8113c1e4:	e0800217 	ldw	r2,8(fp)
8113c1e8:	00c00044 	movi	r3,1
8113c1ec:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c1f0:	0005883a 	mov	r2,zero
8113c1f4:	00013806 	br	8113c6d8 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113c1f8:	e0fffe03 	ldbu	r3,-8(fp)
8113c1fc:	00bfe004 	movi	r2,-128
8113c200:	1884703a 	and	r2,r3,r2
8113c204:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
8113c208:	e0bfe603 	ldbu	r2,-104(fp)
8113c20c:	10000626 	beq	r2,zero,8113c228 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
8113c210:	e0bffe03 	ldbu	r2,-8(fp)
8113c214:	10801fcc 	andi	r2,r2,127
8113c218:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113c21c:	00800044 	movi	r2,1
8113c220:	e0bfe405 	stb	r2,-112(fp)
8113c224:	00000106 	br	8113c22c <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
8113c228:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c22c:	0005303a 	rdctl	r2,status
8113c230:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c234:	e0fff617 	ldw	r3,-40(fp)
8113c238:	00bfff84 	movi	r2,-2
8113c23c:	1884703a 	and	r2,r3,r2
8113c240:	1001703a 	wrctl	status,r2
  
  return context;
8113c244:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113c248:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
8113c24c:	e0bffe03 	ldbu	r2,-8(fp)
8113c250:	10c00060 	cmpeqi	r3,r2,1
8113c254:	1800921e 	bne	r3,zero,8113c4a0 <OSFlagPend+0x374>
8113c258:	10c00088 	cmpgei	r3,r2,2
8113c25c:	1800021e 	bne	r3,zero,8113c268 <OSFlagPend+0x13c>
8113c260:	10006126 	beq	r2,zero,8113c3e8 <OSFlagPend+0x2bc>
8113c264:	0000bb06 	br	8113c554 <OSFlagPend+0x428>
8113c268:	10c000a0 	cmpeqi	r3,r2,2
8113c26c:	1800031e 	bne	r3,zero,8113c27c <OSFlagPend+0x150>
8113c270:	108000e0 	cmpeqi	r2,r2,3
8113c274:	10002f1e 	bne	r2,zero,8113c334 <OSFlagPend+0x208>
8113c278:	0000b606 	br	8113c554 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
8113c27c:	e0bffc17 	ldw	r2,-16(fp)
8113c280:	10c0020b 	ldhu	r3,8(r2)
8113c284:	e0bffd0b 	ldhu	r2,-12(fp)
8113c288:	1884703a 	and	r2,r3,r2
8113c28c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113c290:	e0ffe80b 	ldhu	r3,-96(fp)
8113c294:	e0bffd0b 	ldhu	r2,-12(fp)
8113c298:	1880171e 	bne	r3,r2,8113c2f8 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c29c:	e0bfe403 	ldbu	r2,-112(fp)
8113c2a0:	10800058 	cmpnei	r2,r2,1
8113c2a4:	1000091e 	bne	r2,zero,8113c2cc <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113c2a8:	e0bffc17 	ldw	r2,-16(fp)
8113c2ac:	1080020b 	ldhu	r2,8(r2)
8113c2b0:	1007883a 	mov	r3,r2
8113c2b4:	e0bfe80b 	ldhu	r2,-96(fp)
8113c2b8:	0084303a 	nor	r2,zero,r2
8113c2bc:	1884703a 	and	r2,r3,r2
8113c2c0:	1007883a 	mov	r3,r2
8113c2c4:	e0bffc17 	ldw	r2,-16(fp)
8113c2c8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113c2cc:	d0a0a217 	ldw	r2,-32120(gp)
8113c2d0:	e0ffe80b 	ldhu	r3,-96(fp)
8113c2d4:	10c00b0d 	sth	r3,44(r2)
8113c2d8:	e0bfe517 	ldw	r2,-108(fp)
8113c2dc:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c2e0:	e0bfe717 	ldw	r2,-100(fp)
8113c2e4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113c2e8:	e0800217 	ldw	r2,8(fp)
8113c2ec:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113c2f0:	e0bfe80b 	ldhu	r2,-96(fp)
8113c2f4:	0000f806 	br	8113c6d8 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113c2f8:	e13ffd0b 	ldhu	r4,-12(fp)
8113c2fc:	e17ffe03 	ldbu	r5,-8(fp)
8113c300:	e0bfff0b 	ldhu	r2,-4(fp)
8113c304:	e0fff704 	addi	r3,fp,-36
8113c308:	d8800015 	stw	r2,0(sp)
8113c30c:	280f883a 	mov	r7,r5
8113c310:	200d883a 	mov	r6,r4
8113c314:	180b883a 	mov	r5,r3
8113c318:	e13ffc17 	ldw	r4,-16(fp)
8113c31c:	113cbbc0 	call	8113cbbc <OS_FlagBlock>
8113c320:	e0bfe517 	ldw	r2,-108(fp)
8113c324:	e0bfe915 	stw	r2,-92(fp)
8113c328:	e0bfe917 	ldw	r2,-92(fp)
8113c32c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113c330:	00009206 	br	8113c57c <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
8113c334:	e0bffc17 	ldw	r2,-16(fp)
8113c338:	10c0020b 	ldhu	r3,8(r2)
8113c33c:	e0bffd0b 	ldhu	r2,-12(fp)
8113c340:	1884703a 	and	r2,r3,r2
8113c344:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113c348:	e0bfe80b 	ldhu	r2,-96(fp)
8113c34c:	10001726 	beq	r2,zero,8113c3ac <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c350:	e0bfe403 	ldbu	r2,-112(fp)
8113c354:	10800058 	cmpnei	r2,r2,1
8113c358:	1000091e 	bne	r2,zero,8113c380 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113c35c:	e0bffc17 	ldw	r2,-16(fp)
8113c360:	1080020b 	ldhu	r2,8(r2)
8113c364:	1007883a 	mov	r3,r2
8113c368:	e0bfe80b 	ldhu	r2,-96(fp)
8113c36c:	0084303a 	nor	r2,zero,r2
8113c370:	1884703a 	and	r2,r3,r2
8113c374:	1007883a 	mov	r3,r2
8113c378:	e0bffc17 	ldw	r2,-16(fp)
8113c37c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113c380:	d0a0a217 	ldw	r2,-32120(gp)
8113c384:	e0ffe80b 	ldhu	r3,-96(fp)
8113c388:	10c00b0d 	sth	r3,44(r2)
8113c38c:	e0bfe517 	ldw	r2,-108(fp)
8113c390:	e0bfea15 	stw	r2,-88(fp)
8113c394:	e0bfea17 	ldw	r2,-88(fp)
8113c398:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113c39c:	e0800217 	ldw	r2,8(fp)
8113c3a0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113c3a4:	e0bfe80b 	ldhu	r2,-96(fp)
8113c3a8:	0000cb06 	br	8113c6d8 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113c3ac:	e13ffd0b 	ldhu	r4,-12(fp)
8113c3b0:	e17ffe03 	ldbu	r5,-8(fp)
8113c3b4:	e0bfff0b 	ldhu	r2,-4(fp)
8113c3b8:	e0fff704 	addi	r3,fp,-36
8113c3bc:	d8800015 	stw	r2,0(sp)
8113c3c0:	280f883a 	mov	r7,r5
8113c3c4:	200d883a 	mov	r6,r4
8113c3c8:	180b883a 	mov	r5,r3
8113c3cc:	e13ffc17 	ldw	r4,-16(fp)
8113c3d0:	113cbbc0 	call	8113cbbc <OS_FlagBlock>
8113c3d4:	e0bfe517 	ldw	r2,-108(fp)
8113c3d8:	e0bfeb15 	stw	r2,-84(fp)
8113c3dc:	e0bfeb17 	ldw	r2,-84(fp)
8113c3e0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113c3e4:	00006506 	br	8113c57c <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113c3e8:	e0bffc17 	ldw	r2,-16(fp)
8113c3ec:	1080020b 	ldhu	r2,8(r2)
8113c3f0:	0084303a 	nor	r2,zero,r2
8113c3f4:	1007883a 	mov	r3,r2
8113c3f8:	e0bffd0b 	ldhu	r2,-12(fp)
8113c3fc:	1884703a 	and	r2,r3,r2
8113c400:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113c404:	e0ffe80b 	ldhu	r3,-96(fp)
8113c408:	e0bffd0b 	ldhu	r2,-12(fp)
8113c40c:	1880151e 	bne	r3,r2,8113c464 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c410:	e0bfe403 	ldbu	r2,-112(fp)
8113c414:	10800058 	cmpnei	r2,r2,1
8113c418:	1000071e 	bne	r2,zero,8113c438 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113c41c:	e0bffc17 	ldw	r2,-16(fp)
8113c420:	10c0020b 	ldhu	r3,8(r2)
8113c424:	e0bfe80b 	ldhu	r2,-96(fp)
8113c428:	1884b03a 	or	r2,r3,r2
8113c42c:	1007883a 	mov	r3,r2
8113c430:	e0bffc17 	ldw	r2,-16(fp)
8113c434:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113c438:	d0a0a217 	ldw	r2,-32120(gp)
8113c43c:	e0ffe80b 	ldhu	r3,-96(fp)
8113c440:	10c00b0d 	sth	r3,44(r2)
8113c444:	e0bfe517 	ldw	r2,-108(fp)
8113c448:	e0bfec15 	stw	r2,-80(fp)
8113c44c:	e0bfec17 	ldw	r2,-80(fp)
8113c450:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113c454:	e0800217 	ldw	r2,8(fp)
8113c458:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113c45c:	e0bfe80b 	ldhu	r2,-96(fp)
8113c460:	00009d06 	br	8113c6d8 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113c464:	e13ffd0b 	ldhu	r4,-12(fp)
8113c468:	e17ffe03 	ldbu	r5,-8(fp)
8113c46c:	e0bfff0b 	ldhu	r2,-4(fp)
8113c470:	e0fff704 	addi	r3,fp,-36
8113c474:	d8800015 	stw	r2,0(sp)
8113c478:	280f883a 	mov	r7,r5
8113c47c:	200d883a 	mov	r6,r4
8113c480:	180b883a 	mov	r5,r3
8113c484:	e13ffc17 	ldw	r4,-16(fp)
8113c488:	113cbbc0 	call	8113cbbc <OS_FlagBlock>
8113c48c:	e0bfe517 	ldw	r2,-108(fp)
8113c490:	e0bfed15 	stw	r2,-76(fp)
8113c494:	e0bfed17 	ldw	r2,-76(fp)
8113c498:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113c49c:	00003706 	br	8113c57c <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113c4a0:	e0bffc17 	ldw	r2,-16(fp)
8113c4a4:	1080020b 	ldhu	r2,8(r2)
8113c4a8:	0084303a 	nor	r2,zero,r2
8113c4ac:	1007883a 	mov	r3,r2
8113c4b0:	e0bffd0b 	ldhu	r2,-12(fp)
8113c4b4:	1884703a 	and	r2,r3,r2
8113c4b8:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113c4bc:	e0bfe80b 	ldhu	r2,-96(fp)
8113c4c0:	10001526 	beq	r2,zero,8113c518 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113c4c4:	e0bfe403 	ldbu	r2,-112(fp)
8113c4c8:	10800058 	cmpnei	r2,r2,1
8113c4cc:	1000071e 	bne	r2,zero,8113c4ec <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113c4d0:	e0bffc17 	ldw	r2,-16(fp)
8113c4d4:	10c0020b 	ldhu	r3,8(r2)
8113c4d8:	e0bfe80b 	ldhu	r2,-96(fp)
8113c4dc:	1884b03a 	or	r2,r3,r2
8113c4e0:	1007883a 	mov	r3,r2
8113c4e4:	e0bffc17 	ldw	r2,-16(fp)
8113c4e8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113c4ec:	d0a0a217 	ldw	r2,-32120(gp)
8113c4f0:	e0ffe80b 	ldhu	r3,-96(fp)
8113c4f4:	10c00b0d 	sth	r3,44(r2)
8113c4f8:	e0bfe517 	ldw	r2,-108(fp)
8113c4fc:	e0bfee15 	stw	r2,-72(fp)
8113c500:	e0bfee17 	ldw	r2,-72(fp)
8113c504:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113c508:	e0800217 	ldw	r2,8(fp)
8113c50c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113c510:	e0bfe80b 	ldhu	r2,-96(fp)
8113c514:	00007006 	br	8113c6d8 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113c518:	e13ffd0b 	ldhu	r4,-12(fp)
8113c51c:	e17ffe03 	ldbu	r5,-8(fp)
8113c520:	e0bfff0b 	ldhu	r2,-4(fp)
8113c524:	e0fff704 	addi	r3,fp,-36
8113c528:	d8800015 	stw	r2,0(sp)
8113c52c:	280f883a 	mov	r7,r5
8113c530:	200d883a 	mov	r6,r4
8113c534:	180b883a 	mov	r5,r3
8113c538:	e13ffc17 	ldw	r4,-16(fp)
8113c53c:	113cbbc0 	call	8113cbbc <OS_FlagBlock>
8113c540:	e0bfe517 	ldw	r2,-108(fp)
8113c544:	e0bfef15 	stw	r2,-68(fp)
8113c548:	e0bfef17 	ldw	r2,-68(fp)
8113c54c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113c550:	00000a06 	br	8113c57c <OSFlagPend+0x450>
8113c554:	e0bfe517 	ldw	r2,-108(fp)
8113c558:	e0bff015 	stw	r2,-64(fp)
8113c55c:	e0bff017 	ldw	r2,-64(fp)
8113c560:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113c564:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
8113c568:	e0800217 	ldw	r2,8(fp)
8113c56c:	00c01bc4 	movi	r3,111
8113c570:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
8113c574:	e0bfe80b 	ldhu	r2,-96(fp)
8113c578:	00005706 	br	8113c6d8 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
8113c57c:	113af1c0 	call	8113af1c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c580:	0005303a 	rdctl	r2,status
8113c584:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c588:	e0fff117 	ldw	r3,-60(fp)
8113c58c:	00bfff84 	movi	r2,-2
8113c590:	1884703a 	and	r2,r3,r2
8113c594:	1001703a 	wrctl	status,r2
  
  return context;
8113c598:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
8113c59c:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
8113c5a0:	d0a0a217 	ldw	r2,-32120(gp)
8113c5a4:	10800c43 	ldbu	r2,49(r2)
8113c5a8:	10803fcc 	andi	r2,r2,255
8113c5ac:	10001c26 	beq	r2,zero,8113c620 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
8113c5b0:	d0a0a217 	ldw	r2,-32120(gp)
8113c5b4:	10800c43 	ldbu	r2,49(r2)
8113c5b8:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113c5bc:	d0a0a217 	ldw	r2,-32120(gp)
8113c5c0:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
8113c5c4:	e0bff704 	addi	r2,fp,-36
8113c5c8:	1009883a 	mov	r4,r2
8113c5cc:	113cf080 	call	8113cf08 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
8113c5d0:	d0a0a217 	ldw	r2,-32120(gp)
8113c5d4:	10000c05 	stb	zero,48(r2)
8113c5d8:	e0bfe517 	ldw	r2,-108(fp)
8113c5dc:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c5e0:	e0bff217 	ldw	r2,-56(fp)
8113c5e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
8113c5e8:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
8113c5ec:	e0bff303 	ldbu	r2,-52(fp)
8113c5f0:	108000a0 	cmpeqi	r2,r2,2
8113c5f4:	10000426 	beq	r2,zero,8113c608 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
8113c5f8:	e0800217 	ldw	r2,8(fp)
8113c5fc:	00c00384 	movi	r3,14
8113c600:	10c00005 	stb	r3,0(r2)
                 break;
8113c604:	00000406 	br	8113c618 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
8113c608:	e0800217 	ldw	r2,8(fp)
8113c60c:	00c00284 	movi	r3,10
8113c610:	10c00005 	stb	r3,0(r2)
                 break;
8113c614:	0001883a 	nop
        }
        return (flags_rdy);
8113c618:	e0bfe80b 	ldhu	r2,-96(fp)
8113c61c:	00002e06 	br	8113c6d8 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
8113c620:	d0a0a217 	ldw	r2,-32120(gp)
8113c624:	10800b0b 	ldhu	r2,44(r2)
8113c628:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
8113c62c:	e0bfe403 	ldbu	r2,-112(fp)
8113c630:	10800058 	cmpnei	r2,r2,1
8113c634:	1000211e 	bne	r2,zero,8113c6bc <OSFlagPend+0x590>
        switch (wait_type) {
8113c638:	e0bffe03 	ldbu	r2,-8(fp)
8113c63c:	10001616 	blt	r2,zero,8113c698 <OSFlagPend+0x56c>
8113c640:	10c00090 	cmplti	r3,r2,2
8113c644:	18000c1e 	bne	r3,zero,8113c678 <OSFlagPend+0x54c>
8113c648:	10800108 	cmpgei	r2,r2,4
8113c64c:	1000121e 	bne	r2,zero,8113c698 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
8113c650:	e0bffc17 	ldw	r2,-16(fp)
8113c654:	1080020b 	ldhu	r2,8(r2)
8113c658:	1007883a 	mov	r3,r2
8113c65c:	e0bfe80b 	ldhu	r2,-96(fp)
8113c660:	0084303a 	nor	r2,zero,r2
8113c664:	1884703a 	and	r2,r3,r2
8113c668:	1007883a 	mov	r3,r2
8113c66c:	e0bffc17 	ldw	r2,-16(fp)
8113c670:	10c0020d 	sth	r3,8(r2)
                 break;
8113c674:	00001106 	br	8113c6bc <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
8113c678:	e0bffc17 	ldw	r2,-16(fp)
8113c67c:	10c0020b 	ldhu	r3,8(r2)
8113c680:	e0bfe80b 	ldhu	r2,-96(fp)
8113c684:	1884b03a 	or	r2,r3,r2
8113c688:	1007883a 	mov	r3,r2
8113c68c:	e0bffc17 	ldw	r2,-16(fp)
8113c690:	10c0020d 	sth	r3,8(r2)
                 break;
8113c694:	00000906 	br	8113c6bc <OSFlagPend+0x590>
8113c698:	e0bfe517 	ldw	r2,-108(fp)
8113c69c:	e0bff415 	stw	r2,-48(fp)
8113c6a0:	e0bff417 	ldw	r2,-48(fp)
8113c6a4:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113c6a8:	e0800217 	ldw	r2,8(fp)
8113c6ac:	00c01bc4 	movi	r3,111
8113c6b0:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113c6b4:	0005883a 	mov	r2,zero
8113c6b8:	00000706 	br	8113c6d8 <OSFlagPend+0x5ac>
8113c6bc:	e0bfe517 	ldw	r2,-108(fp)
8113c6c0:	e0bff515 	stw	r2,-44(fp)
8113c6c4:	e0bff517 	ldw	r2,-44(fp)
8113c6c8:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
8113c6cc:	e0800217 	ldw	r2,8(fp)
8113c6d0:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
8113c6d4:	e0bfe80b 	ldhu	r2,-96(fp)
}
8113c6d8:	e037883a 	mov	sp,fp
8113c6dc:	dfc00117 	ldw	ra,4(sp)
8113c6e0:	df000017 	ldw	fp,0(sp)
8113c6e4:	dec00204 	addi	sp,sp,8
8113c6e8:	f800283a 	ret

8113c6ec <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
8113c6ec:	defffb04 	addi	sp,sp,-20
8113c6f0:	de00012e 	bgeu	sp,et,8113c6f8 <OSFlagPendGetFlagsRdy+0xc>
8113c6f4:	003b68fa 	trap	3
8113c6f8:	df000415 	stw	fp,16(sp)
8113c6fc:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113c700:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c704:	0005303a 	rdctl	r2,status
8113c708:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c70c:	e0fffe17 	ldw	r3,-8(fp)
8113c710:	00bfff84 	movi	r2,-2
8113c714:	1884703a 	and	r2,r3,r2
8113c718:	1001703a 	wrctl	status,r2
  
  return context;
8113c71c:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113c720:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
8113c724:	d0a0a217 	ldw	r2,-32120(gp)
8113c728:	10800b0b 	ldhu	r2,44(r2)
8113c72c:	e0bffd0d 	sth	r2,-12(fp)
8113c730:	e0bffc17 	ldw	r2,-16(fp)
8113c734:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c738:	e0bfff17 	ldw	r2,-4(fp)
8113c73c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
8113c740:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113c744:	e037883a 	mov	sp,fp
8113c748:	df000017 	ldw	fp,0(sp)
8113c74c:	dec00104 	addi	sp,sp,4
8113c750:	f800283a 	ret

8113c754 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
8113c754:	deffef04 	addi	sp,sp,-68
8113c758:	de00012e 	bgeu	sp,et,8113c760 <OSFlagPost+0xc>
8113c75c:	003b68fa 	trap	3
8113c760:	dfc01015 	stw	ra,64(sp)
8113c764:	df000f15 	stw	fp,60(sp)
8113c768:	df000f04 	addi	fp,sp,60
8113c76c:	e13ffc15 	stw	r4,-16(fp)
8113c770:	2807883a 	mov	r3,r5
8113c774:	3005883a 	mov	r2,r6
8113c778:	e1ffff15 	stw	r7,-4(fp)
8113c77c:	e0fffd0d 	sth	r3,-12(fp)
8113c780:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
8113c784:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113c788:	e0bfff17 	ldw	r2,-4(fp)
8113c78c:	1000021e 	bne	r2,zero,8113c798 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
8113c790:	0005883a 	mov	r2,zero
8113c794:	0000d106 	br	8113cadc <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
8113c798:	e0bffc17 	ldw	r2,-16(fp)
8113c79c:	1000051e 	bne	r2,zero,8113c7b4 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113c7a0:	e0bfff17 	ldw	r2,-4(fp)
8113c7a4:	00c01b84 	movi	r3,110
8113c7a8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c7ac:	0005883a 	mov	r2,zero
8113c7b0:	0000ca06 	br	8113cadc <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
8113c7b4:	e0bffc17 	ldw	r2,-16(fp)
8113c7b8:	10800003 	ldbu	r2,0(r2)
8113c7bc:	10803fcc 	andi	r2,r2,255
8113c7c0:	10800160 	cmpeqi	r2,r2,5
8113c7c4:	1000051e 	bne	r2,zero,8113c7dc <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
8113c7c8:	e0bfff17 	ldw	r2,-4(fp)
8113c7cc:	00c00044 	movi	r3,1
8113c7d0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113c7d4:	0005883a 	mov	r2,zero
8113c7d8:	0000c006 	br	8113cadc <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c7dc:	0005303a 	rdctl	r2,status
8113c7e0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c7e4:	e0fffb17 	ldw	r3,-20(fp)
8113c7e8:	00bfff84 	movi	r2,-2
8113c7ec:	1884703a 	and	r2,r3,r2
8113c7f0:	1001703a 	wrctl	status,r2
  
  return context;
8113c7f4:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113c7f8:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
8113c7fc:	e0bffe03 	ldbu	r2,-8(fp)
8113c800:	10000326 	beq	r2,zero,8113c810 <OSFlagPost+0xbc>
8113c804:	10800060 	cmpeqi	r2,r2,1
8113c808:	10000b1e 	bne	r2,zero,8113c838 <OSFlagPost+0xe4>
8113c80c:	00001206 	br	8113c858 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
8113c810:	e0bffc17 	ldw	r2,-16(fp)
8113c814:	1080020b 	ldhu	r2,8(r2)
8113c818:	1007883a 	mov	r3,r2
8113c81c:	e0bffd0b 	ldhu	r2,-12(fp)
8113c820:	0084303a 	nor	r2,zero,r2
8113c824:	1884703a 	and	r2,r3,r2
8113c828:	1007883a 	mov	r3,r2
8113c82c:	e0bffc17 	ldw	r2,-16(fp)
8113c830:	10c0020d 	sth	r3,8(r2)
             break;
8113c834:	00001106 	br	8113c87c <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
8113c838:	e0bffc17 	ldw	r2,-16(fp)
8113c83c:	10c0020b 	ldhu	r3,8(r2)
8113c840:	e0bffd0b 	ldhu	r2,-12(fp)
8113c844:	1884b03a 	or	r2,r3,r2
8113c848:	1007883a 	mov	r3,r2
8113c84c:	e0bffc17 	ldw	r2,-16(fp)
8113c850:	10c0020d 	sth	r3,8(r2)
             break;
8113c854:	00000906 	br	8113c87c <OSFlagPost+0x128>
8113c858:	e0bff317 	ldw	r2,-52(fp)
8113c85c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c860:	e0bff417 	ldw	r2,-48(fp)
8113c864:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
8113c868:	e0bfff17 	ldw	r2,-4(fp)
8113c86c:	00c01c44 	movi	r3,113
8113c870:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
8113c874:	0005883a 	mov	r2,zero
8113c878:	00009806 	br	8113cadc <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
8113c87c:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113c880:	e0bffc17 	ldw	r2,-16(fp)
8113c884:	10800117 	ldw	r2,4(r2)
8113c888:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113c88c:	00007706 	br	8113ca6c <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
8113c890:	e0bff117 	ldw	r2,-60(fp)
8113c894:	10800483 	ldbu	r2,18(r2)
8113c898:	10803fcc 	andi	r2,r2,255
8113c89c:	10c00060 	cmpeqi	r3,r2,1
8113c8a0:	18004a1e 	bne	r3,zero,8113c9cc <OSFlagPost+0x278>
8113c8a4:	10c00088 	cmpgei	r3,r2,2
8113c8a8:	1800021e 	bne	r3,zero,8113c8b4 <OSFlagPost+0x160>
8113c8ac:	10002f26 	beq	r2,zero,8113c96c <OSFlagPost+0x218>
8113c8b0:	00005b06 	br	8113ca20 <OSFlagPost+0x2cc>
8113c8b4:	10c000a0 	cmpeqi	r3,r2,2
8113c8b8:	1800031e 	bne	r3,zero,8113c8c8 <OSFlagPost+0x174>
8113c8bc:	108000e0 	cmpeqi	r2,r2,3
8113c8c0:	1000171e 	bne	r2,zero,8113c920 <OSFlagPost+0x1cc>
8113c8c4:	00005606 	br	8113ca20 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113c8c8:	e0bffc17 	ldw	r2,-16(fp)
8113c8cc:	10c0020b 	ldhu	r3,8(r2)
8113c8d0:	e0bff117 	ldw	r2,-60(fp)
8113c8d4:	1080040b 	ldhu	r2,16(r2)
8113c8d8:	1884703a 	and	r2,r3,r2
8113c8dc:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113c8e0:	e0bff117 	ldw	r2,-60(fp)
8113c8e4:	1080040b 	ldhu	r2,16(r2)
8113c8e8:	10ffffcc 	andi	r3,r2,65535
8113c8ec:	e0bff60b 	ldhu	r2,-40(fp)
8113c8f0:	1880541e 	bne	r3,r2,8113ca44 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113c8f4:	e0bff60b 	ldhu	r2,-40(fp)
8113c8f8:	100b883a 	mov	r5,r2
8113c8fc:	e13ff117 	ldw	r4,-60(fp)
8113c900:	113ce0c0 	call	8113ce0c <OS_FlagTaskRdy>
8113c904:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113c908:	e0bff683 	ldbu	r2,-38(fp)
8113c90c:	10800058 	cmpnei	r2,r2,1
8113c910:	10004c1e 	bne	r2,zero,8113ca44 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113c914:	00800044 	movi	r2,1
8113c918:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113c91c:	00004906 	br	8113ca44 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113c920:	e0bffc17 	ldw	r2,-16(fp)
8113c924:	10c0020b 	ldhu	r3,8(r2)
8113c928:	e0bff117 	ldw	r2,-60(fp)
8113c92c:	1080040b 	ldhu	r2,16(r2)
8113c930:	1884703a 	and	r2,r3,r2
8113c934:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113c938:	e0bff60b 	ldhu	r2,-40(fp)
8113c93c:	10004326 	beq	r2,zero,8113ca4c <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113c940:	e0bff60b 	ldhu	r2,-40(fp)
8113c944:	100b883a 	mov	r5,r2
8113c948:	e13ff117 	ldw	r4,-60(fp)
8113c94c:	113ce0c0 	call	8113ce0c <OS_FlagTaskRdy>
8113c950:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113c954:	e0bff683 	ldbu	r2,-38(fp)
8113c958:	10800058 	cmpnei	r2,r2,1
8113c95c:	10003b1e 	bne	r2,zero,8113ca4c <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113c960:	00800044 	movi	r2,1
8113c964:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113c968:	00003806 	br	8113ca4c <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113c96c:	e0bffc17 	ldw	r2,-16(fp)
8113c970:	1080020b 	ldhu	r2,8(r2)
8113c974:	0084303a 	nor	r2,zero,r2
8113c978:	1007883a 	mov	r3,r2
8113c97c:	e0bff117 	ldw	r2,-60(fp)
8113c980:	1080040b 	ldhu	r2,16(r2)
8113c984:	1884703a 	and	r2,r3,r2
8113c988:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113c98c:	e0bff117 	ldw	r2,-60(fp)
8113c990:	1080040b 	ldhu	r2,16(r2)
8113c994:	10ffffcc 	andi	r3,r2,65535
8113c998:	e0bff60b 	ldhu	r2,-40(fp)
8113c99c:	18802d1e 	bne	r3,r2,8113ca54 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113c9a0:	e0bff60b 	ldhu	r2,-40(fp)
8113c9a4:	100b883a 	mov	r5,r2
8113c9a8:	e13ff117 	ldw	r4,-60(fp)
8113c9ac:	113ce0c0 	call	8113ce0c <OS_FlagTaskRdy>
8113c9b0:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113c9b4:	e0bff683 	ldbu	r2,-38(fp)
8113c9b8:	10800058 	cmpnei	r2,r2,1
8113c9bc:	1000251e 	bne	r2,zero,8113ca54 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113c9c0:	00800044 	movi	r2,1
8113c9c4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113c9c8:	00002206 	br	8113ca54 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113c9cc:	e0bffc17 	ldw	r2,-16(fp)
8113c9d0:	1080020b 	ldhu	r2,8(r2)
8113c9d4:	0084303a 	nor	r2,zero,r2
8113c9d8:	1007883a 	mov	r3,r2
8113c9dc:	e0bff117 	ldw	r2,-60(fp)
8113c9e0:	1080040b 	ldhu	r2,16(r2)
8113c9e4:	1884703a 	and	r2,r3,r2
8113c9e8:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113c9ec:	e0bff60b 	ldhu	r2,-40(fp)
8113c9f0:	10001a26 	beq	r2,zero,8113ca5c <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113c9f4:	e0bff60b 	ldhu	r2,-40(fp)
8113c9f8:	100b883a 	mov	r5,r2
8113c9fc:	e13ff117 	ldw	r4,-60(fp)
8113ca00:	113ce0c0 	call	8113ce0c <OS_FlagTaskRdy>
8113ca04:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113ca08:	e0bff683 	ldbu	r2,-38(fp)
8113ca0c:	10800058 	cmpnei	r2,r2,1
8113ca10:	1000121e 	bne	r2,zero,8113ca5c <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113ca14:	00800044 	movi	r2,1
8113ca18:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113ca1c:	00000f06 	br	8113ca5c <OSFlagPost+0x308>
8113ca20:	e0bff317 	ldw	r2,-52(fp)
8113ca24:	e0bff515 	stw	r2,-44(fp)
8113ca28:	e0bff517 	ldw	r2,-44(fp)
8113ca2c:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113ca30:	e0bfff17 	ldw	r2,-4(fp)
8113ca34:	00c01bc4 	movi	r3,111
8113ca38:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113ca3c:	0005883a 	mov	r2,zero
8113ca40:	00002606 	br	8113cadc <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113ca44:	0001883a 	nop
8113ca48:	00000506 	br	8113ca60 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113ca4c:	0001883a 	nop
8113ca50:	00000306 	br	8113ca60 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113ca54:	0001883a 	nop
8113ca58:	00000106 	br	8113ca60 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113ca5c:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
8113ca60:	e0bff117 	ldw	r2,-60(fp)
8113ca64:	10800017 	ldw	r2,0(r2)
8113ca68:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113ca6c:	e0bff117 	ldw	r2,-60(fp)
8113ca70:	103f871e 	bne	r2,zero,8113c890 <__reset+0xfb11c890>
8113ca74:	e0bff317 	ldw	r2,-52(fp)
8113ca78:	e0bff715 	stw	r2,-36(fp)
8113ca7c:	e0bff717 	ldw	r2,-36(fp)
8113ca80:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
8113ca84:	e0bff203 	ldbu	r2,-56(fp)
8113ca88:	10800058 	cmpnei	r2,r2,1
8113ca8c:	1000011e 	bne	r2,zero,8113ca94 <OSFlagPost+0x340>
        OS_Sched();
8113ca90:	113af1c0 	call	8113af1c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ca94:	0005303a 	rdctl	r2,status
8113ca98:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ca9c:	e0fffa17 	ldw	r3,-24(fp)
8113caa0:	00bfff84 	movi	r2,-2
8113caa4:	1884703a 	and	r2,r3,r2
8113caa8:	1001703a 	wrctl	status,r2
  
  return context;
8113caac:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
8113cab0:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
8113cab4:	e0bffc17 	ldw	r2,-16(fp)
8113cab8:	1080020b 	ldhu	r2,8(r2)
8113cabc:	e0bff90d 	sth	r2,-28(fp)
8113cac0:	e0bff317 	ldw	r2,-52(fp)
8113cac4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cac8:	e0bff817 	ldw	r2,-32(fp)
8113cacc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
8113cad0:	e0bfff17 	ldw	r2,-4(fp)
8113cad4:	10000005 	stb	zero,0(r2)
    return (flags_cur);
8113cad8:	e0bff90b 	ldhu	r2,-28(fp)
}
8113cadc:	e037883a 	mov	sp,fp
8113cae0:	dfc00117 	ldw	ra,4(sp)
8113cae4:	df000017 	ldw	fp,0(sp)
8113cae8:	dec00204 	addi	sp,sp,8
8113caec:	f800283a 	ret

8113caf0 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
8113caf0:	defff904 	addi	sp,sp,-28
8113caf4:	de00012e 	bgeu	sp,et,8113cafc <OSFlagQuery+0xc>
8113caf8:	003b68fa 	trap	3
8113cafc:	df000615 	stw	fp,24(sp)
8113cb00:	df000604 	addi	fp,sp,24
8113cb04:	e13ffe15 	stw	r4,-8(fp)
8113cb08:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
8113cb0c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
8113cb10:	e0bfff17 	ldw	r2,-4(fp)
8113cb14:	1000021e 	bne	r2,zero,8113cb20 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
8113cb18:	0005883a 	mov	r2,zero
8113cb1c:	00002306 	br	8113cbac <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
8113cb20:	e0bffe17 	ldw	r2,-8(fp)
8113cb24:	1000051e 	bne	r2,zero,8113cb3c <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113cb28:	e0bfff17 	ldw	r2,-4(fp)
8113cb2c:	00c01b84 	movi	r3,110
8113cb30:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113cb34:	0005883a 	mov	r2,zero
8113cb38:	00001c06 	br	8113cbac <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
8113cb3c:	e0bffe17 	ldw	r2,-8(fp)
8113cb40:	10800003 	ldbu	r2,0(r2)
8113cb44:	10803fcc 	andi	r2,r2,255
8113cb48:	10800160 	cmpeqi	r2,r2,5
8113cb4c:	1000051e 	bne	r2,zero,8113cb64 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113cb50:	e0bfff17 	ldw	r2,-4(fp)
8113cb54:	00c00044 	movi	r3,1
8113cb58:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113cb5c:	0005883a 	mov	r2,zero
8113cb60:	00001206 	br	8113cbac <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cb64:	0005303a 	rdctl	r2,status
8113cb68:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cb6c:	e0fffc17 	ldw	r3,-16(fp)
8113cb70:	00bfff84 	movi	r2,-2
8113cb74:	1884703a 	and	r2,r3,r2
8113cb78:	1001703a 	wrctl	status,r2
  
  return context;
8113cb7c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113cb80:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
8113cb84:	e0bffe17 	ldw	r2,-8(fp)
8113cb88:	1080020b 	ldhu	r2,8(r2)
8113cb8c:	e0bffb0d 	sth	r2,-20(fp)
8113cb90:	e0bffa17 	ldw	r2,-24(fp)
8113cb94:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cb98:	e0bffd17 	ldw	r2,-12(fp)
8113cb9c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113cba0:	e0bfff17 	ldw	r2,-4(fp)
8113cba4:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
8113cba8:	e0bffb0b 	ldhu	r2,-20(fp)
}
8113cbac:	e037883a 	mov	sp,fp
8113cbb0:	df000017 	ldw	fp,0(sp)
8113cbb4:	dec00104 	addi	sp,sp,4
8113cbb8:	f800283a 	ret

8113cbbc <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
8113cbbc:	defff804 	addi	sp,sp,-32
8113cbc0:	de00012e 	bgeu	sp,et,8113cbc8 <OS_FlagBlock+0xc>
8113cbc4:	003b68fa 	trap	3
8113cbc8:	df000715 	stw	fp,28(sp)
8113cbcc:	df000704 	addi	fp,sp,28
8113cbd0:	e13ffb15 	stw	r4,-20(fp)
8113cbd4:	e17ffc15 	stw	r5,-16(fp)
8113cbd8:	3009883a 	mov	r4,r6
8113cbdc:	3807883a 	mov	r3,r7
8113cbe0:	e0800117 	ldw	r2,4(fp)
8113cbe4:	e13ffd0d 	sth	r4,-12(fp)
8113cbe8:	e0fffe05 	stb	r3,-8(fp)
8113cbec:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8113cbf0:	d0a0a217 	ldw	r2,-32120(gp)
8113cbf4:	d0e0a217 	ldw	r3,-32120(gp)
8113cbf8:	18c00c03 	ldbu	r3,48(r3)
8113cbfc:	18c00814 	ori	r3,r3,32
8113cc00:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
8113cc04:	d0a0a217 	ldw	r2,-32120(gp)
8113cc08:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
8113cc0c:	d0a0a217 	ldw	r2,-32120(gp)
8113cc10:	e0ffff0b 	ldhu	r3,-4(fp)
8113cc14:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
8113cc18:	d0a0a217 	ldw	r2,-32120(gp)
8113cc1c:	e0fffc17 	ldw	r3,-16(fp)
8113cc20:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
8113cc24:	e0bffc17 	ldw	r2,-16(fp)
8113cc28:	e0fffd0b 	ldhu	r3,-12(fp)
8113cc2c:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
8113cc30:	e0bffc17 	ldw	r2,-16(fp)
8113cc34:	e0fffe03 	ldbu	r3,-8(fp)
8113cc38:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
8113cc3c:	d0e0a217 	ldw	r3,-32120(gp)
8113cc40:	e0bffc17 	ldw	r2,-16(fp)
8113cc44:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
8113cc48:	e0bffb17 	ldw	r2,-20(fp)
8113cc4c:	10c00117 	ldw	r3,4(r2)
8113cc50:	e0bffc17 	ldw	r2,-16(fp)
8113cc54:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
8113cc58:	e0bffc17 	ldw	r2,-16(fp)
8113cc5c:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
8113cc60:	e0bffc17 	ldw	r2,-16(fp)
8113cc64:	e0fffb17 	ldw	r3,-20(fp)
8113cc68:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113cc6c:	e0bffb17 	ldw	r2,-20(fp)
8113cc70:	10800117 	ldw	r2,4(r2)
8113cc74:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
8113cc78:	e0bff917 	ldw	r2,-28(fp)
8113cc7c:	10000326 	beq	r2,zero,8113cc8c <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
8113cc80:	e0bff917 	ldw	r2,-28(fp)
8113cc84:	e0fffc17 	ldw	r3,-16(fp)
8113cc88:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
8113cc8c:	e0bffb17 	ldw	r2,-20(fp)
8113cc90:	e0fffc17 	ldw	r3,-16(fp)
8113cc94:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
8113cc98:	d0a0a217 	ldw	r2,-32120(gp)
8113cc9c:	10800d03 	ldbu	r2,52(r2)
8113cca0:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113cca4:	e0fffa03 	ldbu	r3,-24(fp)
8113cca8:	e13ffa03 	ldbu	r4,-24(fp)
8113ccac:	d0a09e44 	addi	r2,gp,-32135
8113ccb0:	2085883a 	add	r2,r4,r2
8113ccb4:	10800003 	ldbu	r2,0(r2)
8113ccb8:	1009883a 	mov	r4,r2
8113ccbc:	d0a0a217 	ldw	r2,-32120(gp)
8113ccc0:	10800d43 	ldbu	r2,53(r2)
8113ccc4:	0084303a 	nor	r2,zero,r2
8113ccc8:	2084703a 	and	r2,r4,r2
8113cccc:	1009883a 	mov	r4,r2
8113ccd0:	d0a09e44 	addi	r2,gp,-32135
8113ccd4:	1885883a 	add	r2,r3,r2
8113ccd8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
8113ccdc:	e0fffa03 	ldbu	r3,-24(fp)
8113cce0:	d0a09e44 	addi	r2,gp,-32135
8113cce4:	1885883a 	add	r2,r3,r2
8113cce8:	10800003 	ldbu	r2,0(r2)
8113ccec:	10803fcc 	andi	r2,r2,255
8113ccf0:	1000071e 	bne	r2,zero,8113cd10 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113ccf4:	d0a0a217 	ldw	r2,-32120(gp)
8113ccf8:	10800d83 	ldbu	r2,54(r2)
8113ccfc:	0084303a 	nor	r2,zero,r2
8113cd00:	1007883a 	mov	r3,r2
8113cd04:	d0a09e03 	ldbu	r2,-32136(gp)
8113cd08:	1884703a 	and	r2,r3,r2
8113cd0c:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113cd10:	0001883a 	nop
8113cd14:	e037883a 	mov	sp,fp
8113cd18:	df000017 	ldw	fp,0(sp)
8113cd1c:	dec00104 	addi	sp,sp,4
8113cd20:	f800283a 	ret

8113cd24 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
8113cd24:	defffb04 	addi	sp,sp,-20
8113cd28:	de00012e 	bgeu	sp,et,8113cd30 <OS_FlagInit+0xc>
8113cd2c:	003b68fa 	trap	3
8113cd30:	dfc00415 	stw	ra,16(sp)
8113cd34:	df000315 	stw	fp,12(sp)
8113cd38:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
8113cd3c:	01421004 	movi	r5,2112
8113cd40:	012045f4 	movhi	r4,33047
8113cd44:	21200704 	addi	r4,r4,-32740
8113cd48:	113ae500 	call	8113ae50 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
8113cd4c:	00a045f4 	movhi	r2,33047
8113cd50:	10a00704 	addi	r2,r2,-32740
8113cd54:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
8113cd58:	00a045f4 	movhi	r2,33047
8113cd5c:	10a01204 	addi	r2,r2,-32696
8113cd60:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113cd64:	e03ffd0d 	sth	zero,-12(fp)
8113cd68:	00001306 	br	8113cdb8 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113cd6c:	e0bffe17 	ldw	r2,-8(fp)
8113cd70:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
8113cd74:	e0bffe17 	ldw	r2,-8(fp)
8113cd78:	e0ffff17 	ldw	r3,-4(fp)
8113cd7c:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
8113cd80:	e0bffe17 	ldw	r2,-8(fp)
8113cd84:	00c00fc4 	movi	r3,63
8113cd88:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113cd8c:	e0bffe17 	ldw	r2,-8(fp)
8113cd90:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
8113cd94:	e0bffe17 	ldw	r2,-8(fp)
8113cd98:	10800b04 	addi	r2,r2,44
8113cd9c:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
8113cda0:	e0bfff17 	ldw	r2,-4(fp)
8113cda4:	10800b04 	addi	r2,r2,44
8113cda8:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113cdac:	e0bffd0b 	ldhu	r2,-12(fp)
8113cdb0:	10800044 	addi	r2,r2,1
8113cdb4:	e0bffd0d 	sth	r2,-12(fp)
8113cdb8:	e0bffd0b 	ldhu	r2,-12(fp)
8113cdbc:	10800bf0 	cmpltui	r2,r2,47
8113cdc0:	103fea1e 	bne	r2,zero,8113cd6c <__reset+0xfb11cd6c>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113cdc4:	e0bffe17 	ldw	r2,-8(fp)
8113cdc8:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
8113cdcc:	e0bffe17 	ldw	r2,-8(fp)
8113cdd0:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
8113cdd4:	e0bffe17 	ldw	r2,-8(fp)
8113cdd8:	00c00fc4 	movi	r3,63
8113cddc:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113cde0:	e0bffe17 	ldw	r2,-8(fp)
8113cde4:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
8113cde8:	00a045f4 	movhi	r2,33047
8113cdec:	10a00704 	addi	r2,r2,-32740
8113cdf0:	d0a0a615 	stw	r2,-32104(gp)
#endif
}
8113cdf4:	0001883a 	nop
8113cdf8:	e037883a 	mov	sp,fp
8113cdfc:	dfc00117 	ldw	ra,4(sp)
8113ce00:	df000017 	ldw	fp,0(sp)
8113ce04:	dec00204 	addi	sp,sp,8
8113ce08:	f800283a 	ret

8113ce0c <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
8113ce0c:	defffa04 	addi	sp,sp,-24
8113ce10:	de00012e 	bgeu	sp,et,8113ce18 <OS_FlagTaskRdy+0xc>
8113ce14:	003b68fa 	trap	3
8113ce18:	dfc00515 	stw	ra,20(sp)
8113ce1c:	df000415 	stw	fp,16(sp)
8113ce20:	df000404 	addi	fp,sp,16
8113ce24:	e13ffe15 	stw	r4,-8(fp)
8113ce28:	2805883a 	mov	r2,r5
8113ce2c:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
8113ce30:	e0bffe17 	ldw	r2,-8(fp)
8113ce34:	10800217 	ldw	r2,8(r2)
8113ce38:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
8113ce3c:	e0bffd17 	ldw	r2,-12(fp)
8113ce40:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
8113ce44:	e0bffd17 	ldw	r2,-12(fp)
8113ce48:	e0ffff0b 	ldhu	r3,-4(fp)
8113ce4c:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
8113ce50:	e0bffd17 	ldw	r2,-12(fp)
8113ce54:	10c00c03 	ldbu	r3,48(r2)
8113ce58:	00bff7c4 	movi	r2,-33
8113ce5c:	1884703a 	and	r2,r3,r2
8113ce60:	1007883a 	mov	r3,r2
8113ce64:	e0bffd17 	ldw	r2,-12(fp)
8113ce68:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
8113ce6c:	e0bffd17 	ldw	r2,-12(fp)
8113ce70:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
8113ce74:	e0bffd17 	ldw	r2,-12(fp)
8113ce78:	10800c03 	ldbu	r2,48(r2)
8113ce7c:	10803fcc 	andi	r2,r2,255
8113ce80:	1000181e 	bne	r2,zero,8113cee4 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
8113ce84:	e0bffd17 	ldw	r2,-12(fp)
8113ce88:	10c00d83 	ldbu	r3,54(r2)
8113ce8c:	d0a09e03 	ldbu	r2,-32136(gp)
8113ce90:	1884b03a 	or	r2,r3,r2
8113ce94:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113ce98:	e0bffd17 	ldw	r2,-12(fp)
8113ce9c:	10800d03 	ldbu	r2,52(r2)
8113cea0:	10c03fcc 	andi	r3,r2,255
8113cea4:	e0bffd17 	ldw	r2,-12(fp)
8113cea8:	10800d03 	ldbu	r2,52(r2)
8113ceac:	11003fcc 	andi	r4,r2,255
8113ceb0:	d0a09e44 	addi	r2,gp,-32135
8113ceb4:	2085883a 	add	r2,r4,r2
8113ceb8:	11000003 	ldbu	r4,0(r2)
8113cebc:	e0bffd17 	ldw	r2,-12(fp)
8113cec0:	10800d43 	ldbu	r2,53(r2)
8113cec4:	2084b03a 	or	r2,r4,r2
8113cec8:	1009883a 	mov	r4,r2
8113cecc:	d0a09e44 	addi	r2,gp,-32135
8113ced0:	1885883a 	add	r2,r3,r2
8113ced4:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
8113ced8:	00800044 	movi	r2,1
8113cedc:	e0bffc05 	stb	r2,-16(fp)
8113cee0:	00000106 	br	8113cee8 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
8113cee4:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
8113cee8:	e13ffe17 	ldw	r4,-8(fp)
8113ceec:	113cf080 	call	8113cf08 <OS_FlagUnlink>
    return (sched);
8113cef0:	e0bffc03 	ldbu	r2,-16(fp)
}
8113cef4:	e037883a 	mov	sp,fp
8113cef8:	dfc00117 	ldw	ra,4(sp)
8113cefc:	df000017 	ldw	fp,0(sp)
8113cf00:	dec00204 	addi	sp,sp,8
8113cf04:	f800283a 	ret

8113cf08 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
8113cf08:	defffa04 	addi	sp,sp,-24
8113cf0c:	de00012e 	bgeu	sp,et,8113cf14 <OS_FlagUnlink+0xc>
8113cf10:	003b68fa 	trap	3
8113cf14:	df000515 	stw	fp,20(sp)
8113cf18:	df000504 	addi	fp,sp,20
8113cf1c:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
8113cf20:	e0bfff17 	ldw	r2,-4(fp)
8113cf24:	10800117 	ldw	r2,4(r2)
8113cf28:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113cf2c:	e0bfff17 	ldw	r2,-4(fp)
8113cf30:	10800017 	ldw	r2,0(r2)
8113cf34:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
8113cf38:	e0bffb17 	ldw	r2,-20(fp)
8113cf3c:	10000b1e 	bne	r2,zero,8113cf6c <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
8113cf40:	e0bfff17 	ldw	r2,-4(fp)
8113cf44:	10800317 	ldw	r2,12(r2)
8113cf48:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
8113cf4c:	e0bffd17 	ldw	r2,-12(fp)
8113cf50:	e0fffc17 	ldw	r3,-16(fp)
8113cf54:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
8113cf58:	e0bffc17 	ldw	r2,-16(fp)
8113cf5c:	10000b26 	beq	r2,zero,8113cf8c <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
8113cf60:	e0bffc17 	ldw	r2,-16(fp)
8113cf64:	10000115 	stw	zero,4(r2)
8113cf68:	00000806 	br	8113cf8c <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
8113cf6c:	e0bffb17 	ldw	r2,-20(fp)
8113cf70:	e0fffc17 	ldw	r3,-16(fp)
8113cf74:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
8113cf78:	e0bffc17 	ldw	r2,-16(fp)
8113cf7c:	10000326 	beq	r2,zero,8113cf8c <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
8113cf80:	e0bffc17 	ldw	r2,-16(fp)
8113cf84:	e0fffb17 	ldw	r3,-20(fp)
8113cf88:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
8113cf8c:	e0bfff17 	ldw	r2,-4(fp)
8113cf90:	10800217 	ldw	r2,8(r2)
8113cf94:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
8113cf98:	e0bffe17 	ldw	r2,-8(fp)
8113cf9c:	10000a15 	stw	zero,40(r2)
#endif
}
8113cfa0:	0001883a 	nop
8113cfa4:	e037883a 	mov	sp,fp
8113cfa8:	df000017 	ldw	fp,0(sp)
8113cfac:	dec00104 	addi	sp,sp,4
8113cfb0:	f800283a 	ret

8113cfb4 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
8113cfb4:	defff404 	addi	sp,sp,-48
8113cfb8:	de00012e 	bgeu	sp,et,8113cfc0 <OSMemCreate+0xc>
8113cfbc:	003b68fa 	trap	3
8113cfc0:	df000b15 	stw	fp,44(sp)
8113cfc4:	df000b04 	addi	fp,sp,44
8113cfc8:	e13ffc15 	stw	r4,-16(fp)
8113cfcc:	e17ffd15 	stw	r5,-12(fp)
8113cfd0:	e1bffe15 	stw	r6,-8(fp)
8113cfd4:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113cfd8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113cfdc:	e0bfff17 	ldw	r2,-4(fp)
8113cfe0:	1000021e 	bne	r2,zero,8113cfec <OSMemCreate+0x38>
        return ((OS_MEM *)0);
8113cfe4:	0005883a 	mov	r2,zero
8113cfe8:	00006506 	br	8113d180 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
8113cfec:	e0bffc17 	ldw	r2,-16(fp)
8113cff0:	1000051e 	bne	r2,zero,8113d008 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113cff4:	e0bfff17 	ldw	r2,-4(fp)
8113cff8:	00c01884 	movi	r3,98
8113cffc:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d000:	0005883a 	mov	r2,zero
8113d004:	00005e06 	br	8113d180 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
8113d008:	e0bffc17 	ldw	r2,-16(fp)
8113d00c:	108000cc 	andi	r2,r2,3
8113d010:	10000526 	beq	r2,zero,8113d028 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113d014:	e0bfff17 	ldw	r2,-4(fp)
8113d018:	00c01884 	movi	r3,98
8113d01c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d020:	0005883a 	mov	r2,zero
8113d024:	00005606 	br	8113d180 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
8113d028:	e0bffd17 	ldw	r2,-12(fp)
8113d02c:	108000a8 	cmpgeui	r2,r2,2
8113d030:	1000051e 	bne	r2,zero,8113d048 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
8113d034:	e0bfff17 	ldw	r2,-4(fp)
8113d038:	00c016c4 	movi	r3,91
8113d03c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d040:	0005883a 	mov	r2,zero
8113d044:	00004e06 	br	8113d180 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
8113d048:	e0bffe17 	ldw	r2,-8(fp)
8113d04c:	10800128 	cmpgeui	r2,r2,4
8113d050:	1000051e 	bne	r2,zero,8113d068 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
8113d054:	e0bfff17 	ldw	r2,-4(fp)
8113d058:	00c01704 	movi	r3,92
8113d05c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d060:	0005883a 	mov	r2,zero
8113d064:	00004606 	br	8113d180 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d068:	0005303a 	rdctl	r2,status
8113d06c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d070:	e0fffb17 	ldw	r3,-20(fp)
8113d074:	00bfff84 	movi	r2,-2
8113d078:	1884703a 	and	r2,r3,r2
8113d07c:	1001703a 	wrctl	status,r2
  
  return context;
8113d080:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d084:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
8113d088:	d0a09b17 	ldw	r2,-32148(gp)
8113d08c:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
8113d090:	d0a09b17 	ldw	r2,-32148(gp)
8113d094:	10000326 	beq	r2,zero,8113d0a4 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
8113d098:	d0a09b17 	ldw	r2,-32148(gp)
8113d09c:	10800117 	ldw	r2,4(r2)
8113d0a0:	d0a09b15 	stw	r2,-32148(gp)
8113d0a4:	e0bff817 	ldw	r2,-32(fp)
8113d0a8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d0ac:	e0bff917 	ldw	r2,-28(fp)
8113d0b0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
8113d0b4:	e0bffa17 	ldw	r2,-24(fp)
8113d0b8:	1000051e 	bne	r2,zero,8113d0d0 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
8113d0bc:	e0bfff17 	ldw	r2,-4(fp)
8113d0c0:	00c01684 	movi	r3,90
8113d0c4:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113d0c8:	0005883a 	mov	r2,zero
8113d0cc:	00002c06 	br	8113d180 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
8113d0d0:	e0bffc17 	ldw	r2,-16(fp)
8113d0d4:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
8113d0d8:	e0fffc17 	ldw	r3,-16(fp)
8113d0dc:	e0bffe17 	ldw	r2,-8(fp)
8113d0e0:	1885883a 	add	r2,r3,r2
8113d0e4:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
8113d0e8:	e03ff715 	stw	zero,-36(fp)
8113d0ec:	00000c06 	br	8113d120 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
8113d0f0:	e0bff617 	ldw	r2,-40(fp)
8113d0f4:	e0fff517 	ldw	r3,-44(fp)
8113d0f8:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
8113d0fc:	e0bff517 	ldw	r2,-44(fp)
8113d100:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
8113d104:	e0fff517 	ldw	r3,-44(fp)
8113d108:	e0bffe17 	ldw	r2,-8(fp)
8113d10c:	1885883a 	add	r2,r3,r2
8113d110:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
8113d114:	e0bff717 	ldw	r2,-36(fp)
8113d118:	10800044 	addi	r2,r2,1
8113d11c:	e0bff715 	stw	r2,-36(fp)
8113d120:	e0bffd17 	ldw	r2,-12(fp)
8113d124:	10bfffc4 	addi	r2,r2,-1
8113d128:	e0fff717 	ldw	r3,-36(fp)
8113d12c:	18bff036 	bltu	r3,r2,8113d0f0 <__reset+0xfb11d0f0>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
8113d130:	e0bff617 	ldw	r2,-40(fp)
8113d134:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
8113d138:	e0bffa17 	ldw	r2,-24(fp)
8113d13c:	e0fffc17 	ldw	r3,-16(fp)
8113d140:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
8113d144:	e0bffa17 	ldw	r2,-24(fp)
8113d148:	e0fffc17 	ldw	r3,-16(fp)
8113d14c:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
8113d150:	e0bffa17 	ldw	r2,-24(fp)
8113d154:	e0fffd17 	ldw	r3,-12(fp)
8113d158:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
8113d15c:	e0bffa17 	ldw	r2,-24(fp)
8113d160:	e0fffd17 	ldw	r3,-12(fp)
8113d164:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
8113d168:	e0bffa17 	ldw	r2,-24(fp)
8113d16c:	e0fffe17 	ldw	r3,-8(fp)
8113d170:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
8113d174:	e0bfff17 	ldw	r2,-4(fp)
8113d178:	10000005 	stb	zero,0(r2)
    return (pmem);
8113d17c:	e0bffa17 	ldw	r2,-24(fp)
}
8113d180:	e037883a 	mov	sp,fp
8113d184:	df000017 	ldw	fp,0(sp)
8113d188:	dec00104 	addi	sp,sp,4
8113d18c:	f800283a 	ret

8113d190 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
8113d190:	defff804 	addi	sp,sp,-32
8113d194:	de00012e 	bgeu	sp,et,8113d19c <OSMemGet+0xc>
8113d198:	003b68fa 	trap	3
8113d19c:	df000715 	stw	fp,28(sp)
8113d1a0:	df000704 	addi	fp,sp,28
8113d1a4:	e13ffe15 	stw	r4,-8(fp)
8113d1a8:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113d1ac:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113d1b0:	e0bfff17 	ldw	r2,-4(fp)
8113d1b4:	1000021e 	bne	r2,zero,8113d1c0 <OSMemGet+0x30>
        return ((void *)0);
8113d1b8:	0005883a 	mov	r2,zero
8113d1bc:	00002e06 	br	8113d278 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
8113d1c0:	e0bffe17 	ldw	r2,-8(fp)
8113d1c4:	1000051e 	bne	r2,zero,8113d1dc <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113d1c8:	e0bfff17 	ldw	r2,-4(fp)
8113d1cc:	00c01804 	movi	r3,96
8113d1d0:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113d1d4:	0005883a 	mov	r2,zero
8113d1d8:	00002706 	br	8113d278 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d1dc:	0005303a 	rdctl	r2,status
8113d1e0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d1e4:	e0fffd17 	ldw	r3,-12(fp)
8113d1e8:	00bfff84 	movi	r2,-2
8113d1ec:	1884703a 	and	r2,r3,r2
8113d1f0:	1001703a 	wrctl	status,r2
  
  return context;
8113d1f4:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d1f8:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
8113d1fc:	e0bffe17 	ldw	r2,-8(fp)
8113d200:	10800417 	ldw	r2,16(r2)
8113d204:	10001426 	beq	r2,zero,8113d258 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
8113d208:	e0bffe17 	ldw	r2,-8(fp)
8113d20c:	10800117 	ldw	r2,4(r2)
8113d210:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
8113d214:	e0bffb17 	ldw	r2,-20(fp)
8113d218:	10c00017 	ldw	r3,0(r2)
8113d21c:	e0bffe17 	ldw	r2,-8(fp)
8113d220:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
8113d224:	e0bffe17 	ldw	r2,-8(fp)
8113d228:	10800417 	ldw	r2,16(r2)
8113d22c:	10ffffc4 	addi	r3,r2,-1
8113d230:	e0bffe17 	ldw	r2,-8(fp)
8113d234:	10c00415 	stw	r3,16(r2)
8113d238:	e0bff917 	ldw	r2,-28(fp)
8113d23c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d240:	e0bffa17 	ldw	r2,-24(fp)
8113d244:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
8113d248:	e0bfff17 	ldw	r2,-4(fp)
8113d24c:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
8113d250:	e0bffb17 	ldw	r2,-20(fp)
8113d254:	00000806 	br	8113d278 <OSMemGet+0xe8>
8113d258:	e0bff917 	ldw	r2,-28(fp)
8113d25c:	e0bffc15 	stw	r2,-16(fp)
8113d260:	e0bffc17 	ldw	r2,-16(fp)
8113d264:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
8113d268:	e0bfff17 	ldw	r2,-4(fp)
8113d26c:	00c01744 	movi	r3,93
8113d270:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
8113d274:	0005883a 	mov	r2,zero
}
8113d278:	e037883a 	mov	sp,fp
8113d27c:	df000017 	ldw	fp,0(sp)
8113d280:	dec00104 	addi	sp,sp,4
8113d284:	f800283a 	ret

8113d288 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113d288:	defff704 	addi	sp,sp,-36
8113d28c:	de00012e 	bgeu	sp,et,8113d294 <OSMemNameGet+0xc>
8113d290:	003b68fa 	trap	3
8113d294:	dfc00815 	stw	ra,32(sp)
8113d298:	df000715 	stw	fp,28(sp)
8113d29c:	df000704 	addi	fp,sp,28
8113d2a0:	e13ffd15 	stw	r4,-12(fp)
8113d2a4:	e17ffe15 	stw	r5,-8(fp)
8113d2a8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d2ac:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113d2b0:	e0bfff17 	ldw	r2,-4(fp)
8113d2b4:	1000021e 	bne	r2,zero,8113d2c0 <OSMemNameGet+0x38>
        return (0);
8113d2b8:	0005883a 	mov	r2,zero
8113d2bc:	00002b06 	br	8113d36c <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113d2c0:	e0bffd17 	ldw	r2,-12(fp)
8113d2c4:	1000051e 	bne	r2,zero,8113d2dc <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113d2c8:	e0bfff17 	ldw	r2,-4(fp)
8113d2cc:	00c01804 	movi	r3,96
8113d2d0:	10c00005 	stb	r3,0(r2)
        return (0);
8113d2d4:	0005883a 	mov	r2,zero
8113d2d8:	00002406 	br	8113d36c <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113d2dc:	e0bffe17 	ldw	r2,-8(fp)
8113d2e0:	1000051e 	bne	r2,zero,8113d2f8 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113d2e4:	e0bfff17 	ldw	r2,-4(fp)
8113d2e8:	00c00304 	movi	r3,12
8113d2ec:	10c00005 	stb	r3,0(r2)
        return (0);
8113d2f0:	0005883a 	mov	r2,zero
8113d2f4:	00001d06 	br	8113d36c <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113d2f8:	d0a0a103 	ldbu	r2,-32124(gp)
8113d2fc:	10803fcc 	andi	r2,r2,255
8113d300:	10000526 	beq	r2,zero,8113d318 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113d304:	e0bfff17 	ldw	r2,-4(fp)
8113d308:	00c00444 	movi	r3,17
8113d30c:	10c00005 	stb	r3,0(r2)
        return (0);
8113d310:	0005883a 	mov	r2,zero
8113d314:	00001506 	br	8113d36c <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d318:	0005303a 	rdctl	r2,status
8113d31c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d320:	e0fffb17 	ldw	r3,-20(fp)
8113d324:	00bfff84 	movi	r2,-2
8113d328:	1884703a 	and	r2,r3,r2
8113d32c:	1001703a 	wrctl	status,r2
  
  return context;
8113d330:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
8113d334:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
8113d338:	e0bffd17 	ldw	r2,-12(fp)
8113d33c:	10800504 	addi	r2,r2,20
8113d340:	100b883a 	mov	r5,r2
8113d344:	e13ffe17 	ldw	r4,-8(fp)
8113d348:	113b0700 	call	8113b070 <OS_StrCopy>
8113d34c:	e0bffa05 	stb	r2,-24(fp)
8113d350:	e0bff917 	ldw	r2,-28(fp)
8113d354:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d358:	e0bffc17 	ldw	r2,-16(fp)
8113d35c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113d360:	e0bfff17 	ldw	r2,-4(fp)
8113d364:	10000005 	stb	zero,0(r2)
    return (len);
8113d368:	e0bffa03 	ldbu	r2,-24(fp)
}
8113d36c:	e037883a 	mov	sp,fp
8113d370:	dfc00117 	ldw	ra,4(sp)
8113d374:	df000017 	ldw	fp,0(sp)
8113d378:	dec00204 	addi	sp,sp,8
8113d37c:	f800283a 	ret

8113d380 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113d380:	defff604 	addi	sp,sp,-40
8113d384:	de00012e 	bgeu	sp,et,8113d38c <OSMemNameSet+0xc>
8113d388:	003b68fa 	trap	3
8113d38c:	dfc00915 	stw	ra,36(sp)
8113d390:	df000815 	stw	fp,32(sp)
8113d394:	df000804 	addi	fp,sp,32
8113d398:	e13ffd15 	stw	r4,-12(fp)
8113d39c:	e17ffe15 	stw	r5,-8(fp)
8113d3a0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d3a4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113d3a8:	e0bfff17 	ldw	r2,-4(fp)
8113d3ac:	10003526 	beq	r2,zero,8113d484 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113d3b0:	e0bffd17 	ldw	r2,-12(fp)
8113d3b4:	1000041e 	bne	r2,zero,8113d3c8 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113d3b8:	e0bfff17 	ldw	r2,-4(fp)
8113d3bc:	00c01804 	movi	r3,96
8113d3c0:	10c00005 	stb	r3,0(r2)
        return;
8113d3c4:	00003006 	br	8113d488 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113d3c8:	e0bffe17 	ldw	r2,-8(fp)
8113d3cc:	1000041e 	bne	r2,zero,8113d3e0 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113d3d0:	e0bfff17 	ldw	r2,-4(fp)
8113d3d4:	00c00304 	movi	r3,12
8113d3d8:	10c00005 	stb	r3,0(r2)
        return;
8113d3dc:	00002a06 	br	8113d488 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113d3e0:	d0a0a103 	ldbu	r2,-32124(gp)
8113d3e4:	10803fcc 	andi	r2,r2,255
8113d3e8:	10000426 	beq	r2,zero,8113d3fc <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113d3ec:	e0bfff17 	ldw	r2,-4(fp)
8113d3f0:	00c00484 	movi	r3,18
8113d3f4:	10c00005 	stb	r3,0(r2)
        return;
8113d3f8:	00002306 	br	8113d488 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d3fc:	0005303a 	rdctl	r2,status
8113d400:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d404:	e0fffc17 	ldw	r3,-16(fp)
8113d408:	00bfff84 	movi	r2,-2
8113d40c:	1884703a 	and	r2,r3,r2
8113d410:	1001703a 	wrctl	status,r2
  
  return context;
8113d414:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113d418:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113d41c:	e13ffe17 	ldw	r4,-8(fp)
8113d420:	113b0ec0 	call	8113b0ec <OS_StrLen>
8113d424:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
8113d428:	e0bffa03 	ldbu	r2,-24(fp)
8113d42c:	10800830 	cmpltui	r2,r2,32
8113d430:	1000081e 	bne	r2,zero,8113d454 <OSMemNameSet+0xd4>
8113d434:	e0bff817 	ldw	r2,-32(fp)
8113d438:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d43c:	e0bff917 	ldw	r2,-28(fp)
8113d440:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
8113d444:	e0bfff17 	ldw	r2,-4(fp)
8113d448:	00c018c4 	movi	r3,99
8113d44c:	10c00005 	stb	r3,0(r2)
        return;
8113d450:	00000d06 	br	8113d488 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
8113d454:	e0bffd17 	ldw	r2,-12(fp)
8113d458:	10800504 	addi	r2,r2,20
8113d45c:	e17ffe17 	ldw	r5,-8(fp)
8113d460:	1009883a 	mov	r4,r2
8113d464:	113b0700 	call	8113b070 <OS_StrCopy>
8113d468:	e0bff817 	ldw	r2,-32(fp)
8113d46c:	e0bffb15 	stw	r2,-20(fp)
8113d470:	e0bffb17 	ldw	r2,-20(fp)
8113d474:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113d478:	e0bfff17 	ldw	r2,-4(fp)
8113d47c:	10000005 	stb	zero,0(r2)
8113d480:	00000106 	br	8113d488 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113d484:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113d488:	e037883a 	mov	sp,fp
8113d48c:	dfc00117 	ldw	ra,4(sp)
8113d490:	df000017 	ldw	fp,0(sp)
8113d494:	dec00204 	addi	sp,sp,8
8113d498:	f800283a 	ret

8113d49c <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
8113d49c:	defff904 	addi	sp,sp,-28
8113d4a0:	de00012e 	bgeu	sp,et,8113d4a8 <OSMemPut+0xc>
8113d4a4:	003b68fa 	trap	3
8113d4a8:	df000615 	stw	fp,24(sp)
8113d4ac:	df000604 	addi	fp,sp,24
8113d4b0:	e13ffe15 	stw	r4,-8(fp)
8113d4b4:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d4b8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113d4bc:	e0bffe17 	ldw	r2,-8(fp)
8113d4c0:	1000021e 	bne	r2,zero,8113d4cc <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113d4c4:	00801804 	movi	r2,96
8113d4c8:	00002806 	br	8113d56c <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
8113d4cc:	e0bfff17 	ldw	r2,-4(fp)
8113d4d0:	1000021e 	bne	r2,zero,8113d4dc <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
8113d4d4:	008017c4 	movi	r2,95
8113d4d8:	00002406 	br	8113d56c <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d4dc:	0005303a 	rdctl	r2,status
8113d4e0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d4e4:	e0fffd17 	ldw	r3,-12(fp)
8113d4e8:	00bfff84 	movi	r2,-2
8113d4ec:	1884703a 	and	r2,r3,r2
8113d4f0:	1001703a 	wrctl	status,r2
  
  return context;
8113d4f4:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d4f8:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
8113d4fc:	e0bffe17 	ldw	r2,-8(fp)
8113d500:	10c00417 	ldw	r3,16(r2)
8113d504:	e0bffe17 	ldw	r2,-8(fp)
8113d508:	10800317 	ldw	r2,12(r2)
8113d50c:	18800636 	bltu	r3,r2,8113d528 <OSMemPut+0x8c>
8113d510:	e0bffa17 	ldw	r2,-24(fp)
8113d514:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d518:	e0bffb17 	ldw	r2,-20(fp)
8113d51c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
8113d520:	00801784 	movi	r2,94
8113d524:	00001106 	br	8113d56c <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
8113d528:	e0bffe17 	ldw	r2,-8(fp)
8113d52c:	10c00117 	ldw	r3,4(r2)
8113d530:	e0bfff17 	ldw	r2,-4(fp)
8113d534:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
8113d538:	e0bffe17 	ldw	r2,-8(fp)
8113d53c:	e0ffff17 	ldw	r3,-4(fp)
8113d540:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
8113d544:	e0bffe17 	ldw	r2,-8(fp)
8113d548:	10800417 	ldw	r2,16(r2)
8113d54c:	10c00044 	addi	r3,r2,1
8113d550:	e0bffe17 	ldw	r2,-8(fp)
8113d554:	10c00415 	stw	r3,16(r2)
8113d558:	e0bffa17 	ldw	r2,-24(fp)
8113d55c:	e0bffc15 	stw	r2,-16(fp)
8113d560:	e0bffc17 	ldw	r2,-16(fp)
8113d564:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
8113d568:	0005883a 	mov	r2,zero
}
8113d56c:	e037883a 	mov	sp,fp
8113d570:	df000017 	ldw	fp,0(sp)
8113d574:	dec00104 	addi	sp,sp,4
8113d578:	f800283a 	ret

8113d57c <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
8113d57c:	defffa04 	addi	sp,sp,-24
8113d580:	de00012e 	bgeu	sp,et,8113d588 <OSMemQuery+0xc>
8113d584:	003b68fa 	trap	3
8113d588:	df000515 	stw	fp,20(sp)
8113d58c:	df000504 	addi	fp,sp,20
8113d590:	e13ffe15 	stw	r4,-8(fp)
8113d594:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d598:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113d59c:	e0bffe17 	ldw	r2,-8(fp)
8113d5a0:	1000021e 	bne	r2,zero,8113d5ac <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113d5a4:	00801804 	movi	r2,96
8113d5a8:	00002c06 	br	8113d65c <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
8113d5ac:	e0bfff17 	ldw	r2,-4(fp)
8113d5b0:	1000021e 	bne	r2,zero,8113d5bc <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
8113d5b4:	00801844 	movi	r2,97
8113d5b8:	00002806 	br	8113d65c <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d5bc:	0005303a 	rdctl	r2,status
8113d5c0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d5c4:	e0fffc17 	ldw	r3,-16(fp)
8113d5c8:	00bfff84 	movi	r2,-2
8113d5cc:	1884703a 	and	r2,r3,r2
8113d5d0:	1001703a 	wrctl	status,r2
  
  return context;
8113d5d4:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d5d8:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
8113d5dc:	e0bffe17 	ldw	r2,-8(fp)
8113d5e0:	10c00017 	ldw	r3,0(r2)
8113d5e4:	e0bfff17 	ldw	r2,-4(fp)
8113d5e8:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
8113d5ec:	e0bffe17 	ldw	r2,-8(fp)
8113d5f0:	10c00117 	ldw	r3,4(r2)
8113d5f4:	e0bfff17 	ldw	r2,-4(fp)
8113d5f8:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
8113d5fc:	e0bffe17 	ldw	r2,-8(fp)
8113d600:	10c00217 	ldw	r3,8(r2)
8113d604:	e0bfff17 	ldw	r2,-4(fp)
8113d608:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
8113d60c:	e0bffe17 	ldw	r2,-8(fp)
8113d610:	10c00317 	ldw	r3,12(r2)
8113d614:	e0bfff17 	ldw	r2,-4(fp)
8113d618:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
8113d61c:	e0bffe17 	ldw	r2,-8(fp)
8113d620:	10c00417 	ldw	r3,16(r2)
8113d624:	e0bfff17 	ldw	r2,-4(fp)
8113d628:	10c00415 	stw	r3,16(r2)
8113d62c:	e0bffb17 	ldw	r2,-20(fp)
8113d630:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d634:	e0bffd17 	ldw	r2,-12(fp)
8113d638:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
8113d63c:	e0bfff17 	ldw	r2,-4(fp)
8113d640:	10c00317 	ldw	r3,12(r2)
8113d644:	e0bfff17 	ldw	r2,-4(fp)
8113d648:	10800417 	ldw	r2,16(r2)
8113d64c:	1887c83a 	sub	r3,r3,r2
8113d650:	e0bfff17 	ldw	r2,-4(fp)
8113d654:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
8113d658:	0005883a 	mov	r2,zero
}
8113d65c:	e037883a 	mov	sp,fp
8113d660:	df000017 	ldw	fp,0(sp)
8113d664:	dec00104 	addi	sp,sp,4
8113d668:	f800283a 	ret

8113d66c <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
8113d66c:	defffc04 	addi	sp,sp,-16
8113d670:	de00012e 	bgeu	sp,et,8113d678 <OS_MemInit+0xc>
8113d674:	003b68fa 	trap	3
8113d678:	dfc00315 	stw	ra,12(sp)
8113d67c:	df000215 	stw	fp,8(sp)
8113d680:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
8113d684:	01430c04 	movi	r5,3120
8113d688:	012045f4 	movhi	r4,33047
8113d68c:	21227f04 	addi	r4,r4,-30212
8113d690:	113ae500 	call	8113ae50 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
8113d694:	00a045f4 	movhi	r2,33047
8113d698:	10a27f04 	addi	r2,r2,-30212
8113d69c:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113d6a0:	e03fff0d 	sth	zero,-4(fp)
8113d6a4:	00001306 	br	8113d6f4 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
8113d6a8:	e0bfff0b 	ldhu	r2,-4(fp)
8113d6ac:	10800044 	addi	r2,r2,1
8113d6b0:	10c00d24 	muli	r3,r2,52
8113d6b4:	00a045f4 	movhi	r2,33047
8113d6b8:	10a27f04 	addi	r2,r2,-30212
8113d6bc:	1887883a 	add	r3,r3,r2
8113d6c0:	e0bffe17 	ldw	r2,-8(fp)
8113d6c4:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
8113d6c8:	e0bffe17 	ldw	r2,-8(fp)
8113d6cc:	00c00fc4 	movi	r3,63
8113d6d0:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
8113d6d4:	e0bffe17 	ldw	r2,-8(fp)
8113d6d8:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
8113d6dc:	e0bffe17 	ldw	r2,-8(fp)
8113d6e0:	10800d04 	addi	r2,r2,52
8113d6e4:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113d6e8:	e0bfff0b 	ldhu	r2,-4(fp)
8113d6ec:	10800044 	addi	r2,r2,1
8113d6f0:	e0bfff0d 	sth	r2,-4(fp)
8113d6f4:	e0bfff0b 	ldhu	r2,-4(fp)
8113d6f8:	10800ef0 	cmpltui	r2,r2,59
8113d6fc:	103fea1e 	bne	r2,zero,8113d6a8 <__reset+0xfb11d6a8>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
8113d700:	e0bffe17 	ldw	r2,-8(fp)
8113d704:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
8113d708:	e0bffe17 	ldw	r2,-8(fp)
8113d70c:	00c00fc4 	movi	r3,63
8113d710:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
8113d714:	e0bffe17 	ldw	r2,-8(fp)
8113d718:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
8113d71c:	00a045f4 	movhi	r2,33047
8113d720:	10a27f04 	addi	r2,r2,-30212
8113d724:	d0a09b15 	stw	r2,-32148(gp)
#endif
}
8113d728:	0001883a 	nop
8113d72c:	e037883a 	mov	sp,fp
8113d730:	dfc00117 	ldw	ra,4(sp)
8113d734:	df000017 	ldw	fp,0(sp)
8113d738:	dec00204 	addi	sp,sp,8
8113d73c:	f800283a 	ret

8113d740 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
8113d740:	defff704 	addi	sp,sp,-36
8113d744:	de00012e 	bgeu	sp,et,8113d74c <OSMutexAccept+0xc>
8113d748:	003b68fa 	trap	3
8113d74c:	df000815 	stw	fp,32(sp)
8113d750:	df000804 	addi	fp,sp,32
8113d754:	e13ffe15 	stw	r4,-8(fp)
8113d758:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113d75c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
8113d760:	e0bfff17 	ldw	r2,-4(fp)
8113d764:	1000021e 	bne	r2,zero,8113d770 <OSMutexAccept+0x30>
        return (OS_FALSE);
8113d768:	0005883a 	mov	r2,zero
8113d76c:	00005b06 	br	8113d8dc <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113d770:	e0bffe17 	ldw	r2,-8(fp)
8113d774:	1000051e 	bne	r2,zero,8113d78c <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113d778:	e0bfff17 	ldw	r2,-4(fp)
8113d77c:	00c00104 	movi	r3,4
8113d780:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d784:	0005883a 	mov	r2,zero
8113d788:	00005406 	br	8113d8dc <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
8113d78c:	e0bffe17 	ldw	r2,-8(fp)
8113d790:	10800003 	ldbu	r2,0(r2)
8113d794:	10803fcc 	andi	r2,r2,255
8113d798:	10800120 	cmpeqi	r2,r2,4
8113d79c:	1000051e 	bne	r2,zero,8113d7b4 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113d7a0:	e0bfff17 	ldw	r2,-4(fp)
8113d7a4:	00c00044 	movi	r3,1
8113d7a8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d7ac:	0005883a 	mov	r2,zero
8113d7b0:	00004a06 	br	8113d8dc <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
8113d7b4:	d0a0a103 	ldbu	r2,-32124(gp)
8113d7b8:	10803fcc 	andi	r2,r2,255
8113d7bc:	10000526 	beq	r2,zero,8113d7d4 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
8113d7c0:	e0bfff17 	ldw	r2,-4(fp)
8113d7c4:	00c00084 	movi	r3,2
8113d7c8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d7cc:	0005883a 	mov	r2,zero
8113d7d0:	00004206 	br	8113d8dc <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d7d4:	0005303a 	rdctl	r2,status
8113d7d8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d7dc:	e0fffd17 	ldw	r3,-12(fp)
8113d7e0:	00bfff84 	movi	r2,-2
8113d7e4:	1884703a 	and	r2,r3,r2
8113d7e8:	1001703a 	wrctl	status,r2
  
  return context;
8113d7ec:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
8113d7f0:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
8113d7f4:	e0bffe17 	ldw	r2,-8(fp)
8113d7f8:	1080020b 	ldhu	r2,8(r2)
8113d7fc:	10bfffcc 	andi	r2,r2,65535
8113d800:	1004d23a 	srli	r2,r2,8
8113d804:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113d808:	e0bffe17 	ldw	r2,-8(fp)
8113d80c:	1080020b 	ldhu	r2,8(r2)
8113d810:	10bfffcc 	andi	r2,r2,65535
8113d814:	10803fcc 	andi	r2,r2,255
8113d818:	10803fd8 	cmpnei	r2,r2,255
8113d81c:	1000281e 	bne	r2,zero,8113d8c0 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
8113d820:	e0bffe17 	ldw	r2,-8(fp)
8113d824:	10c0020b 	ldhu	r3,8(r2)
8113d828:	00bfc004 	movi	r2,-256
8113d82c:	1884703a 	and	r2,r3,r2
8113d830:	1007883a 	mov	r3,r2
8113d834:	e0bffe17 	ldw	r2,-8(fp)
8113d838:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
8113d83c:	e0bffe17 	ldw	r2,-8(fp)
8113d840:	10c0020b 	ldhu	r3,8(r2)
8113d844:	d0a0a217 	ldw	r2,-32120(gp)
8113d848:	10800c83 	ldbu	r2,50(r2)
8113d84c:	10803fcc 	andi	r2,r2,255
8113d850:	1884b03a 	or	r2,r3,r2
8113d854:	1007883a 	mov	r3,r2
8113d858:	e0bffe17 	ldw	r2,-8(fp)
8113d85c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8113d860:	d0e0a217 	ldw	r3,-32120(gp)
8113d864:	e0bffe17 	ldw	r2,-8(fp)
8113d868:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
8113d86c:	d0a0a217 	ldw	r2,-32120(gp)
8113d870:	10800c83 	ldbu	r2,50(r2)
8113d874:	10803fcc 	andi	r2,r2,255
8113d878:	e0fffa03 	ldbu	r3,-24(fp)
8113d87c:	18800836 	bltu	r3,r2,8113d8a0 <OSMutexAccept+0x160>
8113d880:	e0bff817 	ldw	r2,-32(fp)
8113d884:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d888:	e0bff917 	ldw	r2,-28(fp)
8113d88c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
8113d890:	e0bfff17 	ldw	r2,-4(fp)
8113d894:	00c01e04 	movi	r3,120
8113d898:	10c00005 	stb	r3,0(r2)
8113d89c:	00000606 	br	8113d8b8 <OSMutexAccept+0x178>
8113d8a0:	e0bff817 	ldw	r2,-32(fp)
8113d8a4:	e0bffb15 	stw	r2,-20(fp)
8113d8a8:	e0bffb17 	ldw	r2,-20(fp)
8113d8ac:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113d8b0:	e0bfff17 	ldw	r2,-4(fp)
8113d8b4:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
8113d8b8:	00800044 	movi	r2,1
8113d8bc:	00000706 	br	8113d8dc <OSMutexAccept+0x19c>
8113d8c0:	e0bff817 	ldw	r2,-32(fp)
8113d8c4:	e0bffc15 	stw	r2,-16(fp)
8113d8c8:	e0bffc17 	ldw	r2,-16(fp)
8113d8cc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113d8d0:	e0bfff17 	ldw	r2,-4(fp)
8113d8d4:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
8113d8d8:	0005883a 	mov	r2,zero
}
8113d8dc:	e037883a 	mov	sp,fp
8113d8e0:	df000017 	ldw	fp,0(sp)
8113d8e4:	dec00104 	addi	sp,sp,4
8113d8e8:	f800283a 	ret

8113d8ec <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
8113d8ec:	defff604 	addi	sp,sp,-40
8113d8f0:	de00012e 	bgeu	sp,et,8113d8f8 <OSMutexCreate+0xc>
8113d8f4:	003b68fa 	trap	3
8113d8f8:	dfc00915 	stw	ra,36(sp)
8113d8fc:	df000815 	stw	fp,32(sp)
8113d900:	df000804 	addi	fp,sp,32
8113d904:	2005883a 	mov	r2,r4
8113d908:	e17fff15 	stw	r5,-4(fp)
8113d90c:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113d910:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113d914:	e0bfff17 	ldw	r2,-4(fp)
8113d918:	1000021e 	bne	r2,zero,8113d924 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
8113d91c:	0005883a 	mov	r2,zero
8113d920:	00006106 	br	8113daa8 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
8113d924:	e0bffe03 	ldbu	r2,-8(fp)
8113d928:	10800ab0 	cmpltui	r2,r2,42
8113d92c:	1000051e 	bne	r2,zero,8113d944 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
8113d930:	e0bfff17 	ldw	r2,-4(fp)
8113d934:	00c00a84 	movi	r3,42
8113d938:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113d93c:	0005883a 	mov	r2,zero
8113d940:	00005906 	br	8113daa8 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113d944:	d0a0a103 	ldbu	r2,-32124(gp)
8113d948:	10803fcc 	andi	r2,r2,255
8113d94c:	10000526 	beq	r2,zero,8113d964 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
8113d950:	e0bfff17 	ldw	r2,-4(fp)
8113d954:	00c00404 	movi	r3,16
8113d958:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113d95c:	0005883a 	mov	r2,zero
8113d960:	00005106 	br	8113daa8 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d964:	0005303a 	rdctl	r2,status
8113d968:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d96c:	e0fffd17 	ldw	r3,-12(fp)
8113d970:	00bfff84 	movi	r2,-2
8113d974:	1884703a 	and	r2,r3,r2
8113d978:	1001703a 	wrctl	status,r2
  
  return context;
8113d97c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d980:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
8113d984:	e0fffe03 	ldbu	r3,-8(fp)
8113d988:	00a045f4 	movhi	r2,33047
8113d98c:	10b7f904 	addi	r2,r2,-8220
8113d990:	18c7883a 	add	r3,r3,r3
8113d994:	18c7883a 	add	r3,r3,r3
8113d998:	10c5883a 	add	r2,r2,r3
8113d99c:	10800017 	ldw	r2,0(r2)
8113d9a0:	10000926 	beq	r2,zero,8113d9c8 <OSMutexCreate+0xdc>
8113d9a4:	e0bff817 	ldw	r2,-32(fp)
8113d9a8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d9ac:	e0bff917 	ldw	r2,-28(fp)
8113d9b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
8113d9b4:	e0bfff17 	ldw	r2,-4(fp)
8113d9b8:	00c00a04 	movi	r3,40
8113d9bc:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113d9c0:	0005883a 	mov	r2,zero
8113d9c4:	00003806 	br	8113daa8 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
8113d9c8:	e0fffe03 	ldbu	r3,-8(fp)
8113d9cc:	00a045f4 	movhi	r2,33047
8113d9d0:	10b7f904 	addi	r2,r2,-8220
8113d9d4:	18c7883a 	add	r3,r3,r3
8113d9d8:	18c7883a 	add	r3,r3,r3
8113d9dc:	10c5883a 	add	r2,r2,r3
8113d9e0:	00c00044 	movi	r3,1
8113d9e4:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
8113d9e8:	d0a0a017 	ldw	r2,-32128(gp)
8113d9ec:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8113d9f0:	e0bffb17 	ldw	r2,-20(fp)
8113d9f4:	1000101e 	bne	r2,zero,8113da38 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
8113d9f8:	e0fffe03 	ldbu	r3,-8(fp)
8113d9fc:	00a045f4 	movhi	r2,33047
8113da00:	10b7f904 	addi	r2,r2,-8220
8113da04:	18c7883a 	add	r3,r3,r3
8113da08:	18c7883a 	add	r3,r3,r3
8113da0c:	10c5883a 	add	r2,r2,r3
8113da10:	10000015 	stw	zero,0(r2)
8113da14:	e0bff817 	ldw	r2,-32(fp)
8113da18:	e0bffa15 	stw	r2,-24(fp)
8113da1c:	e0bffa17 	ldw	r2,-24(fp)
8113da20:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
8113da24:	e0bfff17 	ldw	r2,-4(fp)
8113da28:	00c00104 	movi	r3,4
8113da2c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113da30:	e0bffb17 	ldw	r2,-20(fp)
8113da34:	00001c06 	br	8113daa8 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
8113da38:	d0a0a017 	ldw	r2,-32128(gp)
8113da3c:	10800117 	ldw	r2,4(r2)
8113da40:	d0a0a015 	stw	r2,-32128(gp)
8113da44:	e0bff817 	ldw	r2,-32(fp)
8113da48:	e0bffc15 	stw	r2,-16(fp)
8113da4c:	e0bffc17 	ldw	r2,-16(fp)
8113da50:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
8113da54:	e0bffb17 	ldw	r2,-20(fp)
8113da58:	00c00104 	movi	r3,4
8113da5c:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8113da60:	e0bffe03 	ldbu	r2,-8(fp)
8113da64:	1004923a 	slli	r2,r2,8
8113da68:	10803fd4 	ori	r2,r2,255
8113da6c:	1007883a 	mov	r3,r2
8113da70:	e0bffb17 	ldw	r2,-20(fp)
8113da74:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
8113da78:	e0bffb17 	ldw	r2,-20(fp)
8113da7c:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
8113da80:	e0bffb17 	ldw	r2,-20(fp)
8113da84:	00c00fc4 	movi	r3,63
8113da88:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
8113da8c:	e0bffb17 	ldw	r2,-20(fp)
8113da90:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
8113da94:	e13ffb17 	ldw	r4,-20(fp)
8113da98:	113aa380 	call	8113aa38 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
8113da9c:	e0bfff17 	ldw	r2,-4(fp)
8113daa0:	10000005 	stb	zero,0(r2)
    return (pevent);
8113daa4:	e0bffb17 	ldw	r2,-20(fp)
}
8113daa8:	e037883a 	mov	sp,fp
8113daac:	dfc00117 	ldw	ra,4(sp)
8113dab0:	df000017 	ldw	fp,0(sp)
8113dab4:	dec00204 	addi	sp,sp,8
8113dab8:	f800283a 	ret

8113dabc <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113dabc:	defff004 	addi	sp,sp,-64
8113dac0:	de00012e 	bgeu	sp,et,8113dac8 <OSMutexDel+0xc>
8113dac4:	003b68fa 	trap	3
8113dac8:	dfc00f15 	stw	ra,60(sp)
8113dacc:	df000e15 	stw	fp,56(sp)
8113dad0:	df000e04 	addi	fp,sp,56
8113dad4:	e13ffd15 	stw	r4,-12(fp)
8113dad8:	2805883a 	mov	r2,r5
8113dadc:	e1bfff15 	stw	r6,-4(fp)
8113dae0:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113dae4:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113dae8:	e0bfff17 	ldw	r2,-4(fp)
8113daec:	1000021e 	bne	r2,zero,8113daf8 <OSMutexDel+0x3c>
        return (pevent);
8113daf0:	e0bffd17 	ldw	r2,-12(fp)
8113daf4:	0000ad06 	br	8113ddac <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113daf8:	e0bffd17 	ldw	r2,-12(fp)
8113dafc:	1000051e 	bne	r2,zero,8113db14 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113db00:	e0bfff17 	ldw	r2,-4(fp)
8113db04:	00c00104 	movi	r3,4
8113db08:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113db0c:	e0bffd17 	ldw	r2,-12(fp)
8113db10:	0000a606 	br	8113ddac <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113db14:	e0bffd17 	ldw	r2,-12(fp)
8113db18:	10800003 	ldbu	r2,0(r2)
8113db1c:	10803fcc 	andi	r2,r2,255
8113db20:	10800120 	cmpeqi	r2,r2,4
8113db24:	1000051e 	bne	r2,zero,8113db3c <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113db28:	e0bfff17 	ldw	r2,-4(fp)
8113db2c:	00c00044 	movi	r3,1
8113db30:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113db34:	e0bffd17 	ldw	r2,-12(fp)
8113db38:	00009c06 	br	8113ddac <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113db3c:	d0a0a103 	ldbu	r2,-32124(gp)
8113db40:	10803fcc 	andi	r2,r2,255
8113db44:	10000526 	beq	r2,zero,8113db5c <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113db48:	e0bfff17 	ldw	r2,-4(fp)
8113db4c:	00c003c4 	movi	r3,15
8113db50:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113db54:	e0bffd17 	ldw	r2,-12(fp)
8113db58:	00009406 	br	8113ddac <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113db5c:	0005303a 	rdctl	r2,status
8113db60:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113db64:	e0fffc17 	ldw	r3,-16(fp)
8113db68:	00bfff84 	movi	r2,-2
8113db6c:	1884703a 	and	r2,r3,r2
8113db70:	1001703a 	wrctl	status,r2
  
  return context;
8113db74:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113db78:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
8113db7c:	e0bffd17 	ldw	r2,-12(fp)
8113db80:	10800283 	ldbu	r2,10(r2)
8113db84:	10803fcc 	andi	r2,r2,255
8113db88:	10000326 	beq	r2,zero,8113db98 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113db8c:	00800044 	movi	r2,1
8113db90:	e0bff205 	stb	r2,-56(fp)
8113db94:	00000106 	br	8113db9c <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113db98:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
8113db9c:	e0bffe03 	ldbu	r2,-8(fp)
8113dba0:	10000326 	beq	r2,zero,8113dbb0 <OSMutexDel+0xf4>
8113dba4:	10800060 	cmpeqi	r2,r2,1
8113dba8:	10002f1e 	bne	r2,zero,8113dc68 <OSMutexDel+0x1ac>
8113dbac:	00007406 	br	8113dd80 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
8113dbb0:	e0bff203 	ldbu	r2,-56(fp)
8113dbb4:	1000221e 	bne	r2,zero,8113dc40 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113dbb8:	e0bffd17 	ldw	r2,-12(fp)
8113dbbc:	00c00fc4 	movi	r3,63
8113dbc0:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113dbc4:	e0bffd17 	ldw	r2,-12(fp)
8113dbc8:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113dbcc:	e0bffd17 	ldw	r2,-12(fp)
8113dbd0:	1080020b 	ldhu	r2,8(r2)
8113dbd4:	10bfffcc 	andi	r2,r2,65535
8113dbd8:	1004d23a 	srli	r2,r2,8
8113dbdc:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8113dbe0:	e0fff603 	ldbu	r3,-40(fp)
8113dbe4:	00a045f4 	movhi	r2,33047
8113dbe8:	10b7f904 	addi	r2,r2,-8220
8113dbec:	18c7883a 	add	r3,r3,r3
8113dbf0:	18c7883a 	add	r3,r3,r3
8113dbf4:	10c5883a 	add	r2,r2,r3
8113dbf8:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113dbfc:	e0bffd17 	ldw	r2,-12(fp)
8113dc00:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
8113dc04:	d0e0a017 	ldw	r3,-32128(gp)
8113dc08:	e0bffd17 	ldw	r2,-12(fp)
8113dc0c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
8113dc10:	e0bffd17 	ldw	r2,-12(fp)
8113dc14:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
8113dc18:	e0bffd17 	ldw	r2,-12(fp)
8113dc1c:	d0a0a015 	stw	r2,-32128(gp)
8113dc20:	e0bff417 	ldw	r2,-48(fp)
8113dc24:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dc28:	e0bff517 	ldw	r2,-44(fp)
8113dc2c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
8113dc30:	e0bfff17 	ldw	r2,-4(fp)
8113dc34:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
8113dc38:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
8113dc3c:	00005a06 	br	8113dda8 <OSMutexDel+0x2ec>
8113dc40:	e0bff417 	ldw	r2,-48(fp)
8113dc44:	e0bff715 	stw	r2,-36(fp)
8113dc48:	e0bff717 	ldw	r2,-36(fp)
8113dc4c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
8113dc50:	e0bfff17 	ldw	r2,-4(fp)
8113dc54:	00c01244 	movi	r3,73
8113dc58:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
8113dc5c:	e0bffd17 	ldw	r2,-12(fp)
8113dc60:	e0bff315 	stw	r2,-52(fp)
             }
             break;
8113dc64:	00005006 	br	8113dda8 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
8113dc68:	e0bffd17 	ldw	r2,-12(fp)
8113dc6c:	1080020b 	ldhu	r2,8(r2)
8113dc70:	10bfffcc 	andi	r2,r2,65535
8113dc74:	1004d23a 	srli	r2,r2,8
8113dc78:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
8113dc7c:	e0bffd17 	ldw	r2,-12(fp)
8113dc80:	1080020b 	ldhu	r2,8(r2)
8113dc84:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
8113dc88:	e0bffd17 	ldw	r2,-12(fp)
8113dc8c:	10800117 	ldw	r2,4(r2)
8113dc90:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
8113dc94:	e0bffa17 	ldw	r2,-24(fp)
8113dc98:	10000f26 	beq	r2,zero,8113dcd8 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
8113dc9c:	e0bffa17 	ldw	r2,-24(fp)
8113dca0:	10800c83 	ldbu	r2,50(r2)
8113dca4:	10c03fcc 	andi	r3,r2,255
8113dca8:	e0bff603 	ldbu	r2,-40(fp)
8113dcac:	18800a1e 	bne	r3,r2,8113dcd8 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
8113dcb0:	e0bff903 	ldbu	r2,-28(fp)
8113dcb4:	100b883a 	mov	r5,r2
8113dcb8:	e13ffa17 	ldw	r4,-24(fp)
8113dcbc:	113e6f80 	call	8113e6f8 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113dcc0:	00000506 	br	8113dcd8 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113dcc4:	000f883a 	mov	r7,zero
8113dcc8:	01800404 	movi	r6,16
8113dccc:	000b883a 	mov	r5,zero
8113dcd0:	e13ffd17 	ldw	r4,-12(fp)
8113dcd4:	113a4600 	call	8113a460 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113dcd8:	e0bffd17 	ldw	r2,-12(fp)
8113dcdc:	10800283 	ldbu	r2,10(r2)
8113dce0:	10803fcc 	andi	r2,r2,255
8113dce4:	103ff71e 	bne	r2,zero,8113dcc4 <__reset+0xfb11dcc4>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113dce8:	e0bffd17 	ldw	r2,-12(fp)
8113dcec:	00c00fc4 	movi	r3,63
8113dcf0:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113dcf4:	e0bffd17 	ldw	r2,-12(fp)
8113dcf8:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113dcfc:	e0bffd17 	ldw	r2,-12(fp)
8113dd00:	1080020b 	ldhu	r2,8(r2)
8113dd04:	10bfffcc 	andi	r2,r2,65535
8113dd08:	1004d23a 	srli	r2,r2,8
8113dd0c:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
8113dd10:	e0fff603 	ldbu	r3,-40(fp)
8113dd14:	00a045f4 	movhi	r2,33047
8113dd18:	10b7f904 	addi	r2,r2,-8220
8113dd1c:	18c7883a 	add	r3,r3,r3
8113dd20:	18c7883a 	add	r3,r3,r3
8113dd24:	10c5883a 	add	r2,r2,r3
8113dd28:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113dd2c:	e0bffd17 	ldw	r2,-12(fp)
8113dd30:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
8113dd34:	d0e0a017 	ldw	r3,-32128(gp)
8113dd38:	e0bffd17 	ldw	r2,-12(fp)
8113dd3c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
8113dd40:	e0bffd17 	ldw	r2,-12(fp)
8113dd44:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
8113dd48:	e0bffd17 	ldw	r2,-12(fp)
8113dd4c:	d0a0a015 	stw	r2,-32128(gp)
8113dd50:	e0bff417 	ldw	r2,-48(fp)
8113dd54:	e0bff815 	stw	r2,-32(fp)
8113dd58:	e0bff817 	ldw	r2,-32(fp)
8113dd5c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113dd60:	e0bff203 	ldbu	r2,-56(fp)
8113dd64:	10800058 	cmpnei	r2,r2,1
8113dd68:	1000011e 	bne	r2,zero,8113dd70 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113dd6c:	113af1c0 	call	8113af1c <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
8113dd70:	e0bfff17 	ldw	r2,-4(fp)
8113dd74:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
8113dd78:	e03ff315 	stw	zero,-52(fp)
             break;
8113dd7c:	00000a06 	br	8113dda8 <OSMutexDel+0x2ec>
8113dd80:	e0bff417 	ldw	r2,-48(fp)
8113dd84:	e0bffb15 	stw	r2,-20(fp)
8113dd88:	e0bffb17 	ldw	r2,-20(fp)
8113dd8c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
8113dd90:	e0bfff17 	ldw	r2,-4(fp)
8113dd94:	00c001c4 	movi	r3,7
8113dd98:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
8113dd9c:	e0bffd17 	ldw	r2,-12(fp)
8113dda0:	e0bff315 	stw	r2,-52(fp)
             break;
8113dda4:	0001883a 	nop
    }
    return (pevent_return);
8113dda8:	e0bff317 	ldw	r2,-52(fp)
}
8113ddac:	e037883a 	mov	sp,fp
8113ddb0:	dfc00117 	ldw	ra,4(sp)
8113ddb4:	df000017 	ldw	fp,0(sp)
8113ddb8:	dec00204 	addi	sp,sp,8
8113ddbc:	f800283a 	ret

8113ddc0 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113ddc0:	deffee04 	addi	sp,sp,-72
8113ddc4:	de00012e 	bgeu	sp,et,8113ddcc <OSMutexPend+0xc>
8113ddc8:	003b68fa 	trap	3
8113ddcc:	dfc01115 	stw	ra,68(sp)
8113ddd0:	df001015 	stw	fp,64(sp)
8113ddd4:	df001004 	addi	fp,sp,64
8113ddd8:	e13ffd15 	stw	r4,-12(fp)
8113dddc:	2805883a 	mov	r2,r5
8113dde0:	e1bfff15 	stw	r6,-4(fp)
8113dde4:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113dde8:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113ddec:	e0bfff17 	ldw	r2,-4(fp)
8113ddf0:	10015626 	beq	r2,zero,8113e34c <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113ddf4:	e0bffd17 	ldw	r2,-12(fp)
8113ddf8:	1000041e 	bne	r2,zero,8113de0c <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113ddfc:	e0bfff17 	ldw	r2,-4(fp)
8113de00:	00c00104 	movi	r3,4
8113de04:	10c00005 	stb	r3,0(r2)
        return;
8113de08:	00015106 	br	8113e350 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113de0c:	e0bffd17 	ldw	r2,-12(fp)
8113de10:	10800003 	ldbu	r2,0(r2)
8113de14:	10803fcc 	andi	r2,r2,255
8113de18:	10800120 	cmpeqi	r2,r2,4
8113de1c:	1000041e 	bne	r2,zero,8113de30 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113de20:	e0bfff17 	ldw	r2,-4(fp)
8113de24:	00c00044 	movi	r3,1
8113de28:	10c00005 	stb	r3,0(r2)
        return;
8113de2c:	00014806 	br	8113e350 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113de30:	d0a0a103 	ldbu	r2,-32124(gp)
8113de34:	10803fcc 	andi	r2,r2,255
8113de38:	10000426 	beq	r2,zero,8113de4c <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113de3c:	e0bfff17 	ldw	r2,-4(fp)
8113de40:	00c00084 	movi	r3,2
8113de44:	10c00005 	stb	r3,0(r2)
        return;
8113de48:	00014106 	br	8113e350 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113de4c:	d0a08f03 	ldbu	r2,-32196(gp)
8113de50:	10803fcc 	andi	r2,r2,255
8113de54:	10000426 	beq	r2,zero,8113de68 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113de58:	e0bfff17 	ldw	r2,-4(fp)
8113de5c:	00c00344 	movi	r3,13
8113de60:	10c00005 	stb	r3,0(r2)
        return;
8113de64:	00013a06 	br	8113e350 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113de68:	0005303a 	rdctl	r2,status
8113de6c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113de70:	e0fffc17 	ldw	r3,-16(fp)
8113de74:	00bfff84 	movi	r2,-2
8113de78:	1884703a 	and	r2,r3,r2
8113de7c:	1001703a 	wrctl	status,r2
  
  return context;
8113de80:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113de84:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
8113de88:	e0bffd17 	ldw	r2,-12(fp)
8113de8c:	1080020b 	ldhu	r2,8(r2)
8113de90:	10bfffcc 	andi	r2,r2,65535
8113de94:	1004d23a 	srli	r2,r2,8
8113de98:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113de9c:	e0bffd17 	ldw	r2,-12(fp)
8113dea0:	1080020b 	ldhu	r2,8(r2)
8113dea4:	10803fcc 	andi	r2,r2,255
8113dea8:	10803fd8 	cmpnei	r2,r2,255
8113deac:	1000271e 	bne	r2,zero,8113df4c <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
8113deb0:	e0bffd17 	ldw	r2,-12(fp)
8113deb4:	10c0020b 	ldhu	r3,8(r2)
8113deb8:	00bfc004 	movi	r2,-256
8113debc:	1884703a 	and	r2,r3,r2
8113dec0:	1007883a 	mov	r3,r2
8113dec4:	e0bffd17 	ldw	r2,-12(fp)
8113dec8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
8113decc:	e0bffd17 	ldw	r2,-12(fp)
8113ded0:	10c0020b 	ldhu	r3,8(r2)
8113ded4:	d0a0a217 	ldw	r2,-32120(gp)
8113ded8:	10800c83 	ldbu	r2,50(r2)
8113dedc:	10803fcc 	andi	r2,r2,255
8113dee0:	1884b03a 	or	r2,r3,r2
8113dee4:	1007883a 	mov	r3,r2
8113dee8:	e0bffd17 	ldw	r2,-12(fp)
8113deec:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
8113def0:	d0e0a217 	ldw	r3,-32120(gp)
8113def4:	e0bffd17 	ldw	r2,-12(fp)
8113def8:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
8113defc:	d0a0a217 	ldw	r2,-32120(gp)
8113df00:	10800c83 	ldbu	r2,50(r2)
8113df04:	10803fcc 	andi	r2,r2,255
8113df08:	e0fff303 	ldbu	r3,-52(fp)
8113df0c:	18800836 	bltu	r3,r2,8113df30 <OSMutexPend+0x170>
8113df10:	e0bff117 	ldw	r2,-60(fp)
8113df14:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113df18:	e0bff217 	ldw	r2,-56(fp)
8113df1c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
8113df20:	e0bfff17 	ldw	r2,-4(fp)
8113df24:	00c01e04 	movi	r3,120
8113df28:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
8113df2c:	00010806 	br	8113e350 <OSMutexPend+0x590>
8113df30:	e0bff117 	ldw	r2,-60(fp)
8113df34:	e0bff415 	stw	r2,-48(fp)
8113df38:	e0bff417 	ldw	r2,-48(fp)
8113df3c:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113df40:	e0bfff17 	ldw	r2,-4(fp)
8113df44:	10000005 	stb	zero,0(r2)
        }
        return;
8113df48:	00010106 	br	8113e350 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
8113df4c:	e0bffd17 	ldw	r2,-12(fp)
8113df50:	1080020b 	ldhu	r2,8(r2)
8113df54:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
8113df58:	e0bffd17 	ldw	r2,-12(fp)
8113df5c:	10800117 	ldw	r2,4(r2)
8113df60:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
8113df64:	e0bff717 	ldw	r2,-36(fp)
8113df68:	10800c83 	ldbu	r2,50(r2)
8113df6c:	10803fcc 	andi	r2,r2,255
8113df70:	e0fff303 	ldbu	r3,-52(fp)
8113df74:	1880b92e 	bgeu	r3,r2,8113e25c <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
8113df78:	d0a0a217 	ldw	r2,-32120(gp)
8113df7c:	10800c83 	ldbu	r2,50(r2)
8113df80:	10c03fcc 	andi	r3,r2,255
8113df84:	e0bff603 	ldbu	r2,-40(fp)
8113df88:	1880b42e 	bgeu	r3,r2,8113e25c <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
8113df8c:	e0bff717 	ldw	r2,-36(fp)
8113df90:	10800d03 	ldbu	r2,52(r2)
8113df94:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
8113df98:	e0fff803 	ldbu	r3,-32(fp)
8113df9c:	d0a09e44 	addi	r2,gp,-32135
8113dfa0:	1885883a 	add	r2,r3,r2
8113dfa4:	10c00003 	ldbu	r3,0(r2)
8113dfa8:	e0bff717 	ldw	r2,-36(fp)
8113dfac:	10800d43 	ldbu	r2,53(r2)
8113dfb0:	1884703a 	and	r2,r3,r2
8113dfb4:	10803fcc 	andi	r2,r2,255
8113dfb8:	10001e26 	beq	r2,zero,8113e034 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
8113dfbc:	e0fff803 	ldbu	r3,-32(fp)
8113dfc0:	e13ff803 	ldbu	r4,-32(fp)
8113dfc4:	d0a09e44 	addi	r2,gp,-32135
8113dfc8:	2085883a 	add	r2,r4,r2
8113dfcc:	10800003 	ldbu	r2,0(r2)
8113dfd0:	1009883a 	mov	r4,r2
8113dfd4:	e0bff717 	ldw	r2,-36(fp)
8113dfd8:	10800d43 	ldbu	r2,53(r2)
8113dfdc:	0084303a 	nor	r2,zero,r2
8113dfe0:	2084703a 	and	r2,r4,r2
8113dfe4:	1009883a 	mov	r4,r2
8113dfe8:	d0a09e44 	addi	r2,gp,-32135
8113dfec:	1885883a 	add	r2,r3,r2
8113dff0:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
8113dff4:	e0fff803 	ldbu	r3,-32(fp)
8113dff8:	d0a09e44 	addi	r2,gp,-32135
8113dffc:	1885883a 	add	r2,r3,r2
8113e000:	10800003 	ldbu	r2,0(r2)
8113e004:	10803fcc 	andi	r2,r2,255
8113e008:	1000071e 	bne	r2,zero,8113e028 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
8113e00c:	e0bff717 	ldw	r2,-36(fp)
8113e010:	10800d83 	ldbu	r2,54(r2)
8113e014:	0084303a 	nor	r2,zero,r2
8113e018:	1007883a 	mov	r3,r2
8113e01c:	d0a09e03 	ldbu	r2,-32136(gp)
8113e020:	1884703a 	and	r2,r3,r2
8113e024:	d0a09e05 	stb	r2,-32136(gp)
                }
                rdy = OS_TRUE;
8113e028:	00800044 	movi	r2,1
8113e02c:	e0bff005 	stb	r2,-64(fp)
8113e030:	00002a06 	br	8113e0dc <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113e034:	e0bff717 	ldw	r2,-36(fp)
8113e038:	10800717 	ldw	r2,28(r2)
8113e03c:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
8113e040:	e0bff917 	ldw	r2,-28(fp)
8113e044:	10002426 	beq	r2,zero,8113e0d8 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
8113e048:	e0bff717 	ldw	r2,-36(fp)
8113e04c:	10800d03 	ldbu	r2,52(r2)
8113e050:	10803fcc 	andi	r2,r2,255
8113e054:	e0fff717 	ldw	r3,-36(fp)
8113e058:	18c00d03 	ldbu	r3,52(r3)
8113e05c:	18c03fcc 	andi	r3,r3,255
8113e060:	e13ff917 	ldw	r4,-28(fp)
8113e064:	20c7883a 	add	r3,r4,r3
8113e068:	18c002c4 	addi	r3,r3,11
8113e06c:	18c00003 	ldbu	r3,0(r3)
8113e070:	1809883a 	mov	r4,r3
8113e074:	e0fff717 	ldw	r3,-36(fp)
8113e078:	18c00d43 	ldbu	r3,53(r3)
8113e07c:	00c6303a 	nor	r3,zero,r3
8113e080:	20c6703a 	and	r3,r4,r3
8113e084:	1809883a 	mov	r4,r3
8113e088:	e0fff917 	ldw	r3,-28(fp)
8113e08c:	1887883a 	add	r3,r3,r2
8113e090:	18c002c4 	addi	r3,r3,11
8113e094:	19000005 	stb	r4,0(r3)
8113e098:	e0fff917 	ldw	r3,-28(fp)
8113e09c:	1885883a 	add	r2,r3,r2
8113e0a0:	108002c4 	addi	r2,r2,11
8113e0a4:	10800003 	ldbu	r2,0(r2)
8113e0a8:	10803fcc 	andi	r2,r2,255
8113e0ac:	10000a1e 	bne	r2,zero,8113e0d8 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
8113e0b0:	e0bff917 	ldw	r2,-28(fp)
8113e0b4:	10800283 	ldbu	r2,10(r2)
8113e0b8:	1007883a 	mov	r3,r2
8113e0bc:	e0bff717 	ldw	r2,-36(fp)
8113e0c0:	10800d83 	ldbu	r2,54(r2)
8113e0c4:	0084303a 	nor	r2,zero,r2
8113e0c8:	1884703a 	and	r2,r3,r2
8113e0cc:	1007883a 	mov	r3,r2
8113e0d0:	e0bff917 	ldw	r2,-28(fp)
8113e0d4:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
8113e0d8:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
8113e0dc:	e0bff717 	ldw	r2,-36(fp)
8113e0e0:	e0fff303 	ldbu	r3,-52(fp)
8113e0e4:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
8113e0e8:	e0bff717 	ldw	r2,-36(fp)
8113e0ec:	10800c83 	ldbu	r2,50(r2)
8113e0f0:	10803fcc 	andi	r2,r2,255
8113e0f4:	1004d0fa 	srli	r2,r2,3
8113e0f8:	1007883a 	mov	r3,r2
8113e0fc:	e0bff717 	ldw	r2,-36(fp)
8113e100:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
8113e104:	e0bff717 	ldw	r2,-36(fp)
8113e108:	10800c83 	ldbu	r2,50(r2)
8113e10c:	108001cc 	andi	r2,r2,7
8113e110:	1007883a 	mov	r3,r2
8113e114:	e0bff717 	ldw	r2,-36(fp)
8113e118:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
8113e11c:	e0bff717 	ldw	r2,-36(fp)
8113e120:	10800d03 	ldbu	r2,52(r2)
8113e124:	10803fcc 	andi	r2,r2,255
8113e128:	00c00044 	movi	r3,1
8113e12c:	1884983a 	sll	r2,r3,r2
8113e130:	1007883a 	mov	r3,r2
8113e134:	e0bff717 	ldw	r2,-36(fp)
8113e138:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
8113e13c:	e0bff717 	ldw	r2,-36(fp)
8113e140:	10800cc3 	ldbu	r2,51(r2)
8113e144:	10803fcc 	andi	r2,r2,255
8113e148:	00c00044 	movi	r3,1
8113e14c:	1884983a 	sll	r2,r3,r2
8113e150:	1007883a 	mov	r3,r2
8113e154:	e0bff717 	ldw	r2,-36(fp)
8113e158:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
8113e15c:	e0bff003 	ldbu	r2,-64(fp)
8113e160:	10800058 	cmpnei	r2,r2,1
8113e164:	1000161e 	bne	r2,zero,8113e1c0 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
8113e168:	e0bff717 	ldw	r2,-36(fp)
8113e16c:	10c00d83 	ldbu	r3,54(r2)
8113e170:	d0a09e03 	ldbu	r2,-32136(gp)
8113e174:	1884b03a 	or	r2,r3,r2
8113e178:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113e17c:	e0bff717 	ldw	r2,-36(fp)
8113e180:	10800d03 	ldbu	r2,52(r2)
8113e184:	10c03fcc 	andi	r3,r2,255
8113e188:	e0bff717 	ldw	r2,-36(fp)
8113e18c:	10800d03 	ldbu	r2,52(r2)
8113e190:	11003fcc 	andi	r4,r2,255
8113e194:	d0a09e44 	addi	r2,gp,-32135
8113e198:	2085883a 	add	r2,r4,r2
8113e19c:	11000003 	ldbu	r4,0(r2)
8113e1a0:	e0bff717 	ldw	r2,-36(fp)
8113e1a4:	10800d43 	ldbu	r2,53(r2)
8113e1a8:	2084b03a 	or	r2,r4,r2
8113e1ac:	1009883a 	mov	r4,r2
8113e1b0:	d0a09e44 	addi	r2,gp,-32135
8113e1b4:	1885883a 	add	r2,r3,r2
8113e1b8:	11000005 	stb	r4,0(r2)
8113e1bc:	00001f06 	br	8113e23c <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113e1c0:	e0bff717 	ldw	r2,-36(fp)
8113e1c4:	10800717 	ldw	r2,28(r2)
8113e1c8:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
8113e1cc:	e0bff917 	ldw	r2,-28(fp)
8113e1d0:	10001a26 	beq	r2,zero,8113e23c <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
8113e1d4:	e0bff917 	ldw	r2,-28(fp)
8113e1d8:	10c00283 	ldbu	r3,10(r2)
8113e1dc:	e0bff717 	ldw	r2,-36(fp)
8113e1e0:	10800d83 	ldbu	r2,54(r2)
8113e1e4:	1884b03a 	or	r2,r3,r2
8113e1e8:	1007883a 	mov	r3,r2
8113e1ec:	e0bff917 	ldw	r2,-28(fp)
8113e1f0:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113e1f4:	e0bff717 	ldw	r2,-36(fp)
8113e1f8:	10800d03 	ldbu	r2,52(r2)
8113e1fc:	10803fcc 	andi	r2,r2,255
8113e200:	e0fff717 	ldw	r3,-36(fp)
8113e204:	18c00d03 	ldbu	r3,52(r3)
8113e208:	18c03fcc 	andi	r3,r3,255
8113e20c:	e13ff917 	ldw	r4,-28(fp)
8113e210:	20c7883a 	add	r3,r4,r3
8113e214:	18c002c4 	addi	r3,r3,11
8113e218:	19000003 	ldbu	r4,0(r3)
8113e21c:	e0fff717 	ldw	r3,-36(fp)
8113e220:	18c00d43 	ldbu	r3,53(r3)
8113e224:	20c6b03a 	or	r3,r4,r3
8113e228:	1809883a 	mov	r4,r3
8113e22c:	e0fff917 	ldw	r3,-28(fp)
8113e230:	1885883a 	add	r2,r3,r2
8113e234:	108002c4 	addi	r2,r2,11
8113e238:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
8113e23c:	e0fff303 	ldbu	r3,-52(fp)
8113e240:	00a045f4 	movhi	r2,33047
8113e244:	10b7f904 	addi	r2,r2,-8220
8113e248:	18c7883a 	add	r3,r3,r3
8113e24c:	18c7883a 	add	r3,r3,r3
8113e250:	10c5883a 	add	r2,r2,r3
8113e254:	e0fff717 	ldw	r3,-36(fp)
8113e258:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
8113e25c:	d0a0a217 	ldw	r2,-32120(gp)
8113e260:	d0e0a217 	ldw	r3,-32120(gp)
8113e264:	18c00c03 	ldbu	r3,48(r3)
8113e268:	18c00414 	ori	r3,r3,16
8113e26c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113e270:	d0a0a217 	ldw	r2,-32120(gp)
8113e274:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
8113e278:	d0a0a217 	ldw	r2,-32120(gp)
8113e27c:	e0fffe0b 	ldhu	r3,-8(fp)
8113e280:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113e284:	e13ffd17 	ldw	r4,-12(fp)
8113e288:	113a6000 	call	8113a600 <OS_EventTaskWait>
8113e28c:	e0bff117 	ldw	r2,-60(fp)
8113e290:	e0bffb15 	stw	r2,-20(fp)
8113e294:	e0bffb17 	ldw	r2,-20(fp)
8113e298:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113e29c:	113af1c0 	call	8113af1c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e2a0:	0005303a 	rdctl	r2,status
8113e2a4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e2a8:	e0fff517 	ldw	r3,-44(fp)
8113e2ac:	00bfff84 	movi	r2,-2
8113e2b0:	1884703a 	and	r2,r3,r2
8113e2b4:	1001703a 	wrctl	status,r2
  
  return context;
8113e2b8:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
8113e2bc:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113e2c0:	d0a0a217 	ldw	r2,-32120(gp)
8113e2c4:	10800c43 	ldbu	r2,49(r2)
8113e2c8:	10803fcc 	andi	r2,r2,255
8113e2cc:	10000326 	beq	r2,zero,8113e2dc <OSMutexPend+0x51c>
8113e2d0:	108000a0 	cmpeqi	r2,r2,2
8113e2d4:	1000041e 	bne	r2,zero,8113e2e8 <OSMutexPend+0x528>
8113e2d8:	00000706 	br	8113e2f8 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113e2dc:	e0bfff17 	ldw	r2,-4(fp)
8113e2e0:	10000005 	stb	zero,0(r2)
             break;
8113e2e4:	00000c06 	br	8113e318 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
8113e2e8:	e0bfff17 	ldw	r2,-4(fp)
8113e2ec:	00c00384 	movi	r3,14
8113e2f0:	10c00005 	stb	r3,0(r2)
             break;
8113e2f4:	00000806 	br	8113e318 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113e2f8:	d0a0a217 	ldw	r2,-32120(gp)
8113e2fc:	e17ffd17 	ldw	r5,-12(fp)
8113e300:	1009883a 	mov	r4,r2
8113e304:	113a8700 	call	8113a870 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
8113e308:	e0bfff17 	ldw	r2,-4(fp)
8113e30c:	00c00284 	movi	r3,10
8113e310:	10c00005 	stb	r3,0(r2)
             break;
8113e314:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113e318:	d0a0a217 	ldw	r2,-32120(gp)
8113e31c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113e320:	d0a0a217 	ldw	r2,-32120(gp)
8113e324:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113e328:	d0a0a217 	ldw	r2,-32120(gp)
8113e32c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113e330:	d0a0a217 	ldw	r2,-32120(gp)
8113e334:	10000815 	stw	zero,32(r2)
8113e338:	e0bff117 	ldw	r2,-60(fp)
8113e33c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e340:	e0bffa17 	ldw	r2,-24(fp)
8113e344:	1001703a 	wrctl	status,r2
8113e348:	00000106 	br	8113e350 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
8113e34c:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113e350:	e037883a 	mov	sp,fp
8113e354:	dfc00117 	ldw	ra,4(sp)
8113e358:	df000017 	ldw	fp,0(sp)
8113e35c:	dec00204 	addi	sp,sp,8
8113e360:	f800283a 	ret

8113e364 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
8113e364:	defff604 	addi	sp,sp,-40
8113e368:	de00012e 	bgeu	sp,et,8113e370 <OSMutexPost+0xc>
8113e36c:	003b68fa 	trap	3
8113e370:	dfc00915 	stw	ra,36(sp)
8113e374:	df000815 	stw	fp,32(sp)
8113e378:	df000804 	addi	fp,sp,32
8113e37c:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e380:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113e384:	d0a0a103 	ldbu	r2,-32124(gp)
8113e388:	10803fcc 	andi	r2,r2,255
8113e38c:	10000226 	beq	r2,zero,8113e398 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
8113e390:	00800144 	movi	r2,5
8113e394:	00007606 	br	8113e570 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e398:	e0bfff17 	ldw	r2,-4(fp)
8113e39c:	1000021e 	bne	r2,zero,8113e3a8 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
8113e3a0:	00800104 	movi	r2,4
8113e3a4:	00007206 	br	8113e570 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
8113e3a8:	e0bfff17 	ldw	r2,-4(fp)
8113e3ac:	10800003 	ldbu	r2,0(r2)
8113e3b0:	10803fcc 	andi	r2,r2,255
8113e3b4:	10800120 	cmpeqi	r2,r2,4
8113e3b8:	1000021e 	bne	r2,zero,8113e3c4 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
8113e3bc:	00800044 	movi	r2,1
8113e3c0:	00006b06 	br	8113e570 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e3c4:	0005303a 	rdctl	r2,status
8113e3c8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e3cc:	e0fffe17 	ldw	r3,-8(fp)
8113e3d0:	00bfff84 	movi	r2,-2
8113e3d4:	1884703a 	and	r2,r3,r2
8113e3d8:	1001703a 	wrctl	status,r2
  
  return context;
8113e3dc:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113e3e0:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
8113e3e4:	e0bfff17 	ldw	r2,-4(fp)
8113e3e8:	1080020b 	ldhu	r2,8(r2)
8113e3ec:	10bfffcc 	andi	r2,r2,65535
8113e3f0:	1004d23a 	srli	r2,r2,8
8113e3f4:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
8113e3f8:	e0bfff17 	ldw	r2,-4(fp)
8113e3fc:	1080020b 	ldhu	r2,8(r2)
8113e400:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
8113e404:	e0bfff17 	ldw	r2,-4(fp)
8113e408:	10c00117 	ldw	r3,4(r2)
8113e40c:	d0a0a217 	ldw	r2,-32120(gp)
8113e410:	18800626 	beq	r3,r2,8113e42c <OSMutexPost+0xc8>
8113e414:	e0bff817 	ldw	r2,-32(fp)
8113e418:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e41c:	e0bff917 	ldw	r2,-28(fp)
8113e420:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
8113e424:	00801904 	movi	r2,100
8113e428:	00005106 	br	8113e570 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
8113e42c:	d0a0a217 	ldw	r2,-32120(gp)
8113e430:	10800c83 	ldbu	r2,50(r2)
8113e434:	10c03fcc 	andi	r3,r2,255
8113e438:	e0bffa03 	ldbu	r2,-24(fp)
8113e43c:	1880051e 	bne	r3,r2,8113e454 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
8113e440:	d0a0a217 	ldw	r2,-32120(gp)
8113e444:	e0fffa43 	ldbu	r3,-23(fp)
8113e448:	180b883a 	mov	r5,r3
8113e44c:	1009883a 	mov	r4,r2
8113e450:	113e6f80 	call	8113e6f8 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
8113e454:	e0fffa03 	ldbu	r3,-24(fp)
8113e458:	00a045f4 	movhi	r2,33047
8113e45c:	10b7f904 	addi	r2,r2,-8220
8113e460:	18c7883a 	add	r3,r3,r3
8113e464:	18c7883a 	add	r3,r3,r3
8113e468:	10c5883a 	add	r2,r2,r3
8113e46c:	00c00044 	movi	r3,1
8113e470:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
8113e474:	e0bfff17 	ldw	r2,-4(fp)
8113e478:	10800283 	ldbu	r2,10(r2)
8113e47c:	10803fcc 	andi	r2,r2,255
8113e480:	10002e26 	beq	r2,zero,8113e53c <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113e484:	000f883a 	mov	r7,zero
8113e488:	01800404 	movi	r6,16
8113e48c:	000b883a 	mov	r5,zero
8113e490:	e13fff17 	ldw	r4,-4(fp)
8113e494:	113a4600 	call	8113a460 <OS_EventTaskRdy>
8113e498:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
8113e49c:	e0bfff17 	ldw	r2,-4(fp)
8113e4a0:	10c0020b 	ldhu	r3,8(r2)
8113e4a4:	00bfc004 	movi	r2,-256
8113e4a8:	1884703a 	and	r2,r3,r2
8113e4ac:	1007883a 	mov	r3,r2
8113e4b0:	e0bfff17 	ldw	r2,-4(fp)
8113e4b4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
8113e4b8:	e0bfff17 	ldw	r2,-4(fp)
8113e4bc:	10c0020b 	ldhu	r3,8(r2)
8113e4c0:	e0bffa43 	ldbu	r2,-23(fp)
8113e4c4:	1884b03a 	or	r2,r3,r2
8113e4c8:	1007883a 	mov	r3,r2
8113e4cc:	e0bfff17 	ldw	r2,-4(fp)
8113e4d0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
8113e4d4:	e0fffa43 	ldbu	r3,-23(fp)
8113e4d8:	00a045f4 	movhi	r2,33047
8113e4dc:	10b7f904 	addi	r2,r2,-8220
8113e4e0:	18c7883a 	add	r3,r3,r3
8113e4e4:	18c7883a 	add	r3,r3,r3
8113e4e8:	10c5883a 	add	r2,r2,r3
8113e4ec:	10c00017 	ldw	r3,0(r2)
8113e4f0:	e0bfff17 	ldw	r2,-4(fp)
8113e4f4:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
8113e4f8:	e0bffa43 	ldbu	r2,-23(fp)
8113e4fc:	e0fffa03 	ldbu	r3,-24(fp)
8113e500:	18800736 	bltu	r3,r2,8113e520 <OSMutexPost+0x1bc>
8113e504:	e0bff817 	ldw	r2,-32(fp)
8113e508:	e0bffb15 	stw	r2,-20(fp)
8113e50c:	e0bffb17 	ldw	r2,-20(fp)
8113e510:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113e514:	113af1c0 	call	8113af1c <OS_Sched>
            return (OS_ERR_PIP_LOWER);
8113e518:	00801e04 	movi	r2,120
8113e51c:	00001406 	br	8113e570 <OSMutexPost+0x20c>
8113e520:	e0bff817 	ldw	r2,-32(fp)
8113e524:	e0bffc15 	stw	r2,-16(fp)
8113e528:	e0bffc17 	ldw	r2,-16(fp)
8113e52c:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113e530:	113af1c0 	call	8113af1c <OS_Sched>
            return (OS_ERR_NONE);
8113e534:	0005883a 	mov	r2,zero
8113e538:	00000d06 	br	8113e570 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
8113e53c:	e0bfff17 	ldw	r2,-4(fp)
8113e540:	1080020b 	ldhu	r2,8(r2)
8113e544:	10803fd4 	ori	r2,r2,255
8113e548:	1007883a 	mov	r3,r2
8113e54c:	e0bfff17 	ldw	r2,-4(fp)
8113e550:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
8113e554:	e0bfff17 	ldw	r2,-4(fp)
8113e558:	10000115 	stw	zero,4(r2)
8113e55c:	e0bff817 	ldw	r2,-32(fp)
8113e560:	e0bffd15 	stw	r2,-12(fp)
8113e564:	e0bffd17 	ldw	r2,-12(fp)
8113e568:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e56c:	0005883a 	mov	r2,zero
}
8113e570:	e037883a 	mov	sp,fp
8113e574:	dfc00117 	ldw	ra,4(sp)
8113e578:	df000017 	ldw	fp,0(sp)
8113e57c:	dec00204 	addi	sp,sp,8
8113e580:	f800283a 	ret

8113e584 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
8113e584:	defff704 	addi	sp,sp,-36
8113e588:	de00012e 	bgeu	sp,et,8113e590 <OSMutexQuery+0xc>
8113e58c:	003b68fa 	trap	3
8113e590:	df000815 	stw	fp,32(sp)
8113e594:	df000804 	addi	fp,sp,32
8113e598:	e13ffe15 	stw	r4,-8(fp)
8113e59c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113e5a0:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e5a4:	d0a0a103 	ldbu	r2,-32124(gp)
8113e5a8:	10803fcc 	andi	r2,r2,255
8113e5ac:	10000226 	beq	r2,zero,8113e5b8 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
8113e5b0:	00800184 	movi	r2,6
8113e5b4:	00004c06 	br	8113e6e8 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113e5b8:	e0bffe17 	ldw	r2,-8(fp)
8113e5bc:	1000021e 	bne	r2,zero,8113e5c8 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
8113e5c0:	00800104 	movi	r2,4
8113e5c4:	00004806 	br	8113e6e8 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
8113e5c8:	e0bfff17 	ldw	r2,-4(fp)
8113e5cc:	1000021e 	bne	r2,zero,8113e5d8 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
8113e5d0:	00800244 	movi	r2,9
8113e5d4:	00004406 	br	8113e6e8 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113e5d8:	e0bffe17 	ldw	r2,-8(fp)
8113e5dc:	10800003 	ldbu	r2,0(r2)
8113e5e0:	10803fcc 	andi	r2,r2,255
8113e5e4:	10800120 	cmpeqi	r2,r2,4
8113e5e8:	1000021e 	bne	r2,zero,8113e5f4 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
8113e5ec:	00800044 	movi	r2,1
8113e5f0:	00003d06 	br	8113e6e8 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e5f4:	0005303a 	rdctl	r2,status
8113e5f8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e5fc:	e0fffd17 	ldw	r3,-12(fp)
8113e600:	00bfff84 	movi	r2,-2
8113e604:	1884703a 	and	r2,r3,r2
8113e608:	1001703a 	wrctl	status,r2
  
  return context;
8113e60c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113e610:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
8113e614:	e0bffe17 	ldw	r2,-8(fp)
8113e618:	1080020b 	ldhu	r2,8(r2)
8113e61c:	10bfffcc 	andi	r2,r2,65535
8113e620:	1004d23a 	srli	r2,r2,8
8113e624:	1007883a 	mov	r3,r2
8113e628:	e0bfff17 	ldw	r2,-4(fp)
8113e62c:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
8113e630:	e0bffe17 	ldw	r2,-8(fp)
8113e634:	1080020b 	ldhu	r2,8(r2)
8113e638:	1007883a 	mov	r3,r2
8113e63c:	e0bfff17 	ldw	r2,-4(fp)
8113e640:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
8113e644:	e0bfff17 	ldw	r2,-4(fp)
8113e648:	10800203 	ldbu	r2,8(r2)
8113e64c:	10803fcc 	andi	r2,r2,255
8113e650:	10803fd8 	cmpnei	r2,r2,255
8113e654:	1000041e 	bne	r2,zero,8113e668 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
8113e658:	e0bfff17 	ldw	r2,-4(fp)
8113e65c:	00c00044 	movi	r3,1
8113e660:	10c001c5 	stb	r3,7(r2)
8113e664:	00000206 	br	8113e670 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
8113e668:	e0bfff17 	ldw	r2,-4(fp)
8113e66c:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
8113e670:	e0bffe17 	ldw	r2,-8(fp)
8113e674:	10c00283 	ldbu	r3,10(r2)
8113e678:	e0bfff17 	ldw	r2,-4(fp)
8113e67c:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
8113e680:	e0bffe17 	ldw	r2,-8(fp)
8113e684:	108002c4 	addi	r2,r2,11
8113e688:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
8113e68c:	e0bfff17 	ldw	r2,-4(fp)
8113e690:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113e694:	e03ff805 	stb	zero,-32(fp)
8113e698:	00000b06 	br	8113e6c8 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
8113e69c:	e0bffa17 	ldw	r2,-24(fp)
8113e6a0:	10c00044 	addi	r3,r2,1
8113e6a4:	e0fffa15 	stw	r3,-24(fp)
8113e6a8:	e0fff917 	ldw	r3,-28(fp)
8113e6ac:	19000044 	addi	r4,r3,1
8113e6b0:	e13ff915 	stw	r4,-28(fp)
8113e6b4:	18c00003 	ldbu	r3,0(r3)
8113e6b8:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113e6bc:	e0bff803 	ldbu	r2,-32(fp)
8113e6c0:	10800044 	addi	r2,r2,1
8113e6c4:	e0bff805 	stb	r2,-32(fp)
8113e6c8:	e0bff803 	ldbu	r2,-32(fp)
8113e6cc:	108001b0 	cmpltui	r2,r2,6
8113e6d0:	103ff21e 	bne	r2,zero,8113e69c <__reset+0xfb11e69c>
8113e6d4:	e0bffb17 	ldw	r2,-20(fp)
8113e6d8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e6dc:	e0bffc17 	ldw	r2,-16(fp)
8113e6e0:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e6e4:	0005883a 	mov	r2,zero
}
8113e6e8:	e037883a 	mov	sp,fp
8113e6ec:	df000017 	ldw	fp,0(sp)
8113e6f0:	dec00104 	addi	sp,sp,4
8113e6f4:	f800283a 	ret

8113e6f8 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
8113e6f8:	defffc04 	addi	sp,sp,-16
8113e6fc:	de00012e 	bgeu	sp,et,8113e704 <OSMutex_RdyAtPrio+0xc>
8113e700:	003b68fa 	trap	3
8113e704:	df000315 	stw	fp,12(sp)
8113e708:	df000304 	addi	fp,sp,12
8113e70c:	e13ffe15 	stw	r4,-8(fp)
8113e710:	2805883a 	mov	r2,r5
8113e714:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
8113e718:	e0bffe17 	ldw	r2,-8(fp)
8113e71c:	10800d03 	ldbu	r2,52(r2)
8113e720:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
8113e724:	e0fffd03 	ldbu	r3,-12(fp)
8113e728:	e13ffd03 	ldbu	r4,-12(fp)
8113e72c:	d0a09e44 	addi	r2,gp,-32135
8113e730:	2085883a 	add	r2,r4,r2
8113e734:	10800003 	ldbu	r2,0(r2)
8113e738:	1009883a 	mov	r4,r2
8113e73c:	e0bffe17 	ldw	r2,-8(fp)
8113e740:	10800d43 	ldbu	r2,53(r2)
8113e744:	0084303a 	nor	r2,zero,r2
8113e748:	2084703a 	and	r2,r4,r2
8113e74c:	1009883a 	mov	r4,r2
8113e750:	d0a09e44 	addi	r2,gp,-32135
8113e754:	1885883a 	add	r2,r3,r2
8113e758:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113e75c:	e0fffd03 	ldbu	r3,-12(fp)
8113e760:	d0a09e44 	addi	r2,gp,-32135
8113e764:	1885883a 	add	r2,r3,r2
8113e768:	10800003 	ldbu	r2,0(r2)
8113e76c:	10803fcc 	andi	r2,r2,255
8113e770:	1000071e 	bne	r2,zero,8113e790 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113e774:	e0bffe17 	ldw	r2,-8(fp)
8113e778:	10800d83 	ldbu	r2,54(r2)
8113e77c:	0084303a 	nor	r2,zero,r2
8113e780:	1007883a 	mov	r3,r2
8113e784:	d0a09e03 	ldbu	r2,-32136(gp)
8113e788:	1884703a 	and	r2,r3,r2
8113e78c:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBPrio         = prio;
8113e790:	e0bffe17 	ldw	r2,-8(fp)
8113e794:	e0ffff03 	ldbu	r3,-4(fp)
8113e798:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
8113e79c:	e0bfff03 	ldbu	r2,-4(fp)
8113e7a0:	1004d0fa 	srli	r2,r2,3
8113e7a4:	108001cc 	andi	r2,r2,7
8113e7a8:	1007883a 	mov	r3,r2
8113e7ac:	e0bffe17 	ldw	r2,-8(fp)
8113e7b0:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
8113e7b4:	e0bfff03 	ldbu	r2,-4(fp)
8113e7b8:	108001cc 	andi	r2,r2,7
8113e7bc:	1007883a 	mov	r3,r2
8113e7c0:	e0bffe17 	ldw	r2,-8(fp)
8113e7c4:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
8113e7c8:	e0bffe17 	ldw	r2,-8(fp)
8113e7cc:	10800d03 	ldbu	r2,52(r2)
8113e7d0:	10803fcc 	andi	r2,r2,255
8113e7d4:	00c00044 	movi	r3,1
8113e7d8:	1884983a 	sll	r2,r3,r2
8113e7dc:	1007883a 	mov	r3,r2
8113e7e0:	e0bffe17 	ldw	r2,-8(fp)
8113e7e4:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
8113e7e8:	e0bffe17 	ldw	r2,-8(fp)
8113e7ec:	10800cc3 	ldbu	r2,51(r2)
8113e7f0:	10803fcc 	andi	r2,r2,255
8113e7f4:	00c00044 	movi	r3,1
8113e7f8:	1884983a 	sll	r2,r3,r2
8113e7fc:	1007883a 	mov	r3,r2
8113e800:	e0bffe17 	ldw	r2,-8(fp)
8113e804:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
8113e808:	e0bffe17 	ldw	r2,-8(fp)
8113e80c:	10c00d83 	ldbu	r3,54(r2)
8113e810:	d0a09e03 	ldbu	r2,-32136(gp)
8113e814:	1884b03a 	or	r2,r3,r2
8113e818:	d0a09e05 	stb	r2,-32136(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113e81c:	e0bffe17 	ldw	r2,-8(fp)
8113e820:	10800d03 	ldbu	r2,52(r2)
8113e824:	10c03fcc 	andi	r3,r2,255
8113e828:	e0bffe17 	ldw	r2,-8(fp)
8113e82c:	10800d03 	ldbu	r2,52(r2)
8113e830:	11003fcc 	andi	r4,r2,255
8113e834:	d0a09e44 	addi	r2,gp,-32135
8113e838:	2085883a 	add	r2,r4,r2
8113e83c:	11000003 	ldbu	r4,0(r2)
8113e840:	e0bffe17 	ldw	r2,-8(fp)
8113e844:	10800d43 	ldbu	r2,53(r2)
8113e848:	2084b03a 	or	r2,r4,r2
8113e84c:	1009883a 	mov	r4,r2
8113e850:	d0a09e44 	addi	r2,gp,-32135
8113e854:	1885883a 	add	r2,r3,r2
8113e858:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
8113e85c:	e0ffff03 	ldbu	r3,-4(fp)
8113e860:	00a045f4 	movhi	r2,33047
8113e864:	10b7f904 	addi	r2,r2,-8220
8113e868:	18c7883a 	add	r3,r3,r3
8113e86c:	18c7883a 	add	r3,r3,r3
8113e870:	10c5883a 	add	r2,r2,r3
8113e874:	e0fffe17 	ldw	r3,-8(fp)
8113e878:	10c00015 	stw	r3,0(r2)
}
8113e87c:	0001883a 	nop
8113e880:	e037883a 	mov	sp,fp
8113e884:	df000017 	ldw	fp,0(sp)
8113e888:	dec00104 	addi	sp,sp,4
8113e88c:	f800283a 	ret

8113e890 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8113e890:	defff804 	addi	sp,sp,-32
8113e894:	de00012e 	bgeu	sp,et,8113e89c <OSQAccept+0xc>
8113e898:	003b68fa 	trap	3
8113e89c:	df000715 	stw	fp,28(sp)
8113e8a0:	df000704 	addi	fp,sp,28
8113e8a4:	e13ffe15 	stw	r4,-8(fp)
8113e8a8:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113e8ac:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113e8b0:	e0bfff17 	ldw	r2,-4(fp)
8113e8b4:	1000021e 	bne	r2,zero,8113e8c0 <OSQAccept+0x30>
        return ((void *)0);
8113e8b8:	0005883a 	mov	r2,zero
8113e8bc:	00004206 	br	8113e9c8 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113e8c0:	e0bffe17 	ldw	r2,-8(fp)
8113e8c4:	1000051e 	bne	r2,zero,8113e8dc <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113e8c8:	e0bfff17 	ldw	r2,-4(fp)
8113e8cc:	00c00104 	movi	r3,4
8113e8d0:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113e8d4:	0005883a 	mov	r2,zero
8113e8d8:	00003b06 	br	8113e9c8 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113e8dc:	e0bffe17 	ldw	r2,-8(fp)
8113e8e0:	10800003 	ldbu	r2,0(r2)
8113e8e4:	10803fcc 	andi	r2,r2,255
8113e8e8:	108000a0 	cmpeqi	r2,r2,2
8113e8ec:	1000051e 	bne	r2,zero,8113e904 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113e8f0:	e0bfff17 	ldw	r2,-4(fp)
8113e8f4:	00c00044 	movi	r3,1
8113e8f8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113e8fc:	0005883a 	mov	r2,zero
8113e900:	00003106 	br	8113e9c8 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e904:	0005303a 	rdctl	r2,status
8113e908:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e90c:	e0fffd17 	ldw	r3,-12(fp)
8113e910:	00bfff84 	movi	r2,-2
8113e914:	1884703a 	and	r2,r3,r2
8113e918:	1001703a 	wrctl	status,r2
  
  return context;
8113e91c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113e920:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113e924:	e0bffe17 	ldw	r2,-8(fp)
8113e928:	10800117 	ldw	r2,4(r2)
8113e92c:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113e930:	e0bffc17 	ldw	r2,-16(fp)
8113e934:	1080058b 	ldhu	r2,22(r2)
8113e938:	10bfffcc 	andi	r2,r2,65535
8113e93c:	10001926 	beq	r2,zero,8113e9a4 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113e940:	e0bffc17 	ldw	r2,-16(fp)
8113e944:	10800417 	ldw	r2,16(r2)
8113e948:	11000104 	addi	r4,r2,4
8113e94c:	e0fffc17 	ldw	r3,-16(fp)
8113e950:	19000415 	stw	r4,16(r3)
8113e954:	10800017 	ldw	r2,0(r2)
8113e958:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113e95c:	e0bffc17 	ldw	r2,-16(fp)
8113e960:	1080058b 	ldhu	r2,22(r2)
8113e964:	10bfffc4 	addi	r2,r2,-1
8113e968:	1007883a 	mov	r3,r2
8113e96c:	e0bffc17 	ldw	r2,-16(fp)
8113e970:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113e974:	e0bffc17 	ldw	r2,-16(fp)
8113e978:	10c00417 	ldw	r3,16(r2)
8113e97c:	e0bffc17 	ldw	r2,-16(fp)
8113e980:	10800217 	ldw	r2,8(r2)
8113e984:	1880041e 	bne	r3,r2,8113e998 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
8113e988:	e0bffc17 	ldw	r2,-16(fp)
8113e98c:	10c00117 	ldw	r3,4(r2)
8113e990:	e0bffc17 	ldw	r2,-16(fp)
8113e994:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
8113e998:	e0bfff17 	ldw	r2,-4(fp)
8113e99c:	10000005 	stb	zero,0(r2)
8113e9a0:	00000406 	br	8113e9b4 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
8113e9a4:	e0bfff17 	ldw	r2,-4(fp)
8113e9a8:	00c007c4 	movi	r3,31
8113e9ac:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8113e9b0:	e03ff915 	stw	zero,-28(fp)
8113e9b4:	e0bffa17 	ldw	r2,-24(fp)
8113e9b8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e9bc:	e0bffb17 	ldw	r2,-20(fp)
8113e9c0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
8113e9c4:	e0bff917 	ldw	r2,-28(fp)
}
8113e9c8:	e037883a 	mov	sp,fp
8113e9cc:	df000017 	ldw	fp,0(sp)
8113e9d0:	dec00104 	addi	sp,sp,4
8113e9d4:	f800283a 	ret

8113e9d8 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
8113e9d8:	defff404 	addi	sp,sp,-48
8113e9dc:	de00012e 	bgeu	sp,et,8113e9e4 <OSQCreate+0xc>
8113e9e0:	003b68fa 	trap	3
8113e9e4:	dfc00b15 	stw	ra,44(sp)
8113e9e8:	df000a15 	stw	fp,40(sp)
8113e9ec:	df000a04 	addi	fp,sp,40
8113e9f0:	e13ffe15 	stw	r4,-8(fp)
8113e9f4:	2805883a 	mov	r2,r5
8113e9f8:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113e9fc:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113ea00:	d0a0a103 	ldbu	r2,-32124(gp)
8113ea04:	10803fcc 	andi	r2,r2,255
8113ea08:	10000226 	beq	r2,zero,8113ea14 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
8113ea0c:	0005883a 	mov	r2,zero
8113ea10:	00005906 	br	8113eb78 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ea14:	0005303a 	rdctl	r2,status
8113ea18:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ea1c:	e0fffd17 	ldw	r3,-12(fp)
8113ea20:	00bfff84 	movi	r2,-2
8113ea24:	1884703a 	and	r2,r3,r2
8113ea28:	1001703a 	wrctl	status,r2
  
  return context;
8113ea2c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113ea30:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
8113ea34:	d0a0a017 	ldw	r2,-32128(gp)
8113ea38:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
8113ea3c:	d0a0a017 	ldw	r2,-32128(gp)
8113ea40:	10000326 	beq	r2,zero,8113ea50 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113ea44:	d0a0a017 	ldw	r2,-32128(gp)
8113ea48:	10800117 	ldw	r2,4(r2)
8113ea4c:	d0a0a015 	stw	r2,-32128(gp)
8113ea50:	e0bff717 	ldw	r2,-36(fp)
8113ea54:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ea58:	e0bff817 	ldw	r2,-32(fp)
8113ea5c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113ea60:	e0bff617 	ldw	r2,-40(fp)
8113ea64:	10004326 	beq	r2,zero,8113eb74 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ea68:	0005303a 	rdctl	r2,status
8113ea6c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ea70:	e0fff917 	ldw	r3,-28(fp)
8113ea74:	00bfff84 	movi	r2,-2
8113ea78:	1884703a 	and	r2,r3,r2
8113ea7c:	1001703a 	wrctl	status,r2
  
  return context;
8113ea80:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
8113ea84:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
8113ea88:	d0a09d17 	ldw	r2,-32140(gp)
8113ea8c:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8113ea90:	e0bffb17 	ldw	r2,-20(fp)
8113ea94:	10002d26 	beq	r2,zero,8113eb4c <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
8113ea98:	d0a09d17 	ldw	r2,-32140(gp)
8113ea9c:	10800017 	ldw	r2,0(r2)
8113eaa0:	d0a09d15 	stw	r2,-32140(gp)
8113eaa4:	e0bff717 	ldw	r2,-36(fp)
8113eaa8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113eaac:	e0bffa17 	ldw	r2,-24(fp)
8113eab0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
8113eab4:	e0bffb17 	ldw	r2,-20(fp)
8113eab8:	e0fffe17 	ldw	r3,-8(fp)
8113eabc:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8113eac0:	e0bfff0b 	ldhu	r2,-4(fp)
8113eac4:	1085883a 	add	r2,r2,r2
8113eac8:	1085883a 	add	r2,r2,r2
8113eacc:	1007883a 	mov	r3,r2
8113ead0:	e0bffe17 	ldw	r2,-8(fp)
8113ead4:	10c7883a 	add	r3,r2,r3
8113ead8:	e0bffb17 	ldw	r2,-20(fp)
8113eadc:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8113eae0:	e0bffb17 	ldw	r2,-20(fp)
8113eae4:	e0fffe17 	ldw	r3,-8(fp)
8113eae8:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8113eaec:	e0bffb17 	ldw	r2,-20(fp)
8113eaf0:	e0fffe17 	ldw	r3,-8(fp)
8113eaf4:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
8113eaf8:	e0bffb17 	ldw	r2,-20(fp)
8113eafc:	e0ffff0b 	ldhu	r3,-4(fp)
8113eb00:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
8113eb04:	e0bffb17 	ldw	r2,-20(fp)
8113eb08:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
8113eb0c:	e0bff617 	ldw	r2,-40(fp)
8113eb10:	00c00084 	movi	r3,2
8113eb14:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
8113eb18:	e0bff617 	ldw	r2,-40(fp)
8113eb1c:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
8113eb20:	e0bff617 	ldw	r2,-40(fp)
8113eb24:	e0fffb17 	ldw	r3,-20(fp)
8113eb28:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
8113eb2c:	e0bff617 	ldw	r2,-40(fp)
8113eb30:	00c00fc4 	movi	r3,63
8113eb34:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
8113eb38:	e0bff617 	ldw	r2,-40(fp)
8113eb3c:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
8113eb40:	e13ff617 	ldw	r4,-40(fp)
8113eb44:	113aa380 	call	8113aa38 <OS_EventWaitListInit>
8113eb48:	00000a06 	br	8113eb74 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
8113eb4c:	d0e0a017 	ldw	r3,-32128(gp)
8113eb50:	e0bff617 	ldw	r2,-40(fp)
8113eb54:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
8113eb58:	e0bff617 	ldw	r2,-40(fp)
8113eb5c:	d0a0a015 	stw	r2,-32128(gp)
8113eb60:	e0bff717 	ldw	r2,-36(fp)
8113eb64:	e0bffc15 	stw	r2,-16(fp)
8113eb68:	e0bffc17 	ldw	r2,-16(fp)
8113eb6c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8113eb70:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
8113eb74:	e0bff617 	ldw	r2,-40(fp)
}
8113eb78:	e037883a 	mov	sp,fp
8113eb7c:	dfc00117 	ldw	ra,4(sp)
8113eb80:	df000017 	ldw	fp,0(sp)
8113eb84:	dec00204 	addi	sp,sp,8
8113eb88:	f800283a 	ret

8113eb8c <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113eb8c:	defff204 	addi	sp,sp,-56
8113eb90:	de00012e 	bgeu	sp,et,8113eb98 <OSQDel+0xc>
8113eb94:	003b68fa 	trap	3
8113eb98:	dfc00d15 	stw	ra,52(sp)
8113eb9c:	df000c15 	stw	fp,48(sp)
8113eba0:	df000c04 	addi	fp,sp,48
8113eba4:	e13ffd15 	stw	r4,-12(fp)
8113eba8:	2805883a 	mov	r2,r5
8113ebac:	e1bfff15 	stw	r6,-4(fp)
8113ebb0:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113ebb4:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113ebb8:	e0bfff17 	ldw	r2,-4(fp)
8113ebbc:	1000021e 	bne	r2,zero,8113ebc8 <OSQDel+0x3c>
        return (pevent);
8113ebc0:	e0bffd17 	ldw	r2,-12(fp)
8113ebc4:	00008e06 	br	8113ee00 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113ebc8:	e0bffd17 	ldw	r2,-12(fp)
8113ebcc:	1000051e 	bne	r2,zero,8113ebe4 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113ebd0:	e0bfff17 	ldw	r2,-4(fp)
8113ebd4:	00c00104 	movi	r3,4
8113ebd8:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113ebdc:	e0bffd17 	ldw	r2,-12(fp)
8113ebe0:	00008706 	br	8113ee00 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113ebe4:	e0bffd17 	ldw	r2,-12(fp)
8113ebe8:	10800003 	ldbu	r2,0(r2)
8113ebec:	10803fcc 	andi	r2,r2,255
8113ebf0:	108000a0 	cmpeqi	r2,r2,2
8113ebf4:	1000051e 	bne	r2,zero,8113ec0c <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113ebf8:	e0bfff17 	ldw	r2,-4(fp)
8113ebfc:	00c00044 	movi	r3,1
8113ec00:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113ec04:	e0bffd17 	ldw	r2,-12(fp)
8113ec08:	00007d06 	br	8113ee00 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113ec0c:	d0a0a103 	ldbu	r2,-32124(gp)
8113ec10:	10803fcc 	andi	r2,r2,255
8113ec14:	10000526 	beq	r2,zero,8113ec2c <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113ec18:	e0bfff17 	ldw	r2,-4(fp)
8113ec1c:	00c003c4 	movi	r3,15
8113ec20:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113ec24:	e0bffd17 	ldw	r2,-12(fp)
8113ec28:	00007506 	br	8113ee00 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ec2c:	0005303a 	rdctl	r2,status
8113ec30:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ec34:	e0fffc17 	ldw	r3,-16(fp)
8113ec38:	00bfff84 	movi	r2,-2
8113ec3c:	1884703a 	and	r2,r3,r2
8113ec40:	1001703a 	wrctl	status,r2
  
  return context;
8113ec44:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ec48:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
8113ec4c:	e0bffd17 	ldw	r2,-12(fp)
8113ec50:	10800283 	ldbu	r2,10(r2)
8113ec54:	10803fcc 	andi	r2,r2,255
8113ec58:	10000326 	beq	r2,zero,8113ec68 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113ec5c:	00800044 	movi	r2,1
8113ec60:	e0bff405 	stb	r2,-48(fp)
8113ec64:	00000106 	br	8113ec6c <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113ec68:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113ec6c:	e0bffe03 	ldbu	r2,-8(fp)
8113ec70:	10000326 	beq	r2,zero,8113ec80 <OSQDel+0xf4>
8113ec74:	10800060 	cmpeqi	r2,r2,1
8113ec78:	1000301e 	bne	r2,zero,8113ed3c <OSQDel+0x1b0>
8113ec7c:	00005506 	br	8113edd4 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
8113ec80:	e0bff403 	ldbu	r2,-48(fp)
8113ec84:	10001e1e 	bne	r2,zero,8113ed00 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113ec88:	e0bffd17 	ldw	r2,-12(fp)
8113ec8c:	00c00fc4 	movi	r3,63
8113ec90:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113ec94:	e0bffd17 	ldw	r2,-12(fp)
8113ec98:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8113ec9c:	e0bffd17 	ldw	r2,-12(fp)
8113eca0:	10800117 	ldw	r2,4(r2)
8113eca4:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
8113eca8:	d0e09d17 	ldw	r3,-32140(gp)
8113ecac:	e0bff817 	ldw	r2,-32(fp)
8113ecb0:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
8113ecb4:	e0bff817 	ldw	r2,-32(fp)
8113ecb8:	d0a09d15 	stw	r2,-32140(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113ecbc:	e0bffd17 	ldw	r2,-12(fp)
8113ecc0:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113ecc4:	d0e0a017 	ldw	r3,-32128(gp)
8113ecc8:	e0bffd17 	ldw	r2,-12(fp)
8113eccc:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113ecd0:	e0bffd17 	ldw	r2,-12(fp)
8113ecd4:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113ecd8:	e0bffd17 	ldw	r2,-12(fp)
8113ecdc:	d0a0a015 	stw	r2,-32128(gp)
8113ece0:	e0bff617 	ldw	r2,-40(fp)
8113ece4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ece8:	e0bff717 	ldw	r2,-36(fp)
8113ecec:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113ecf0:	e0bfff17 	ldw	r2,-4(fp)
8113ecf4:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
8113ecf8:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113ecfc:	00003f06 	br	8113edfc <OSQDel+0x270>
8113ed00:	e0bff617 	ldw	r2,-40(fp)
8113ed04:	e0bff915 	stw	r2,-28(fp)
8113ed08:	e0bff917 	ldw	r2,-28(fp)
8113ed0c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113ed10:	e0bfff17 	ldw	r2,-4(fp)
8113ed14:	00c01244 	movi	r3,73
8113ed18:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113ed1c:	e0bffd17 	ldw	r2,-12(fp)
8113ed20:	e0bff515 	stw	r2,-44(fp)
             }
             break;
8113ed24:	00003506 	br	8113edfc <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
8113ed28:	000f883a 	mov	r7,zero
8113ed2c:	01800104 	movi	r6,4
8113ed30:	000b883a 	mov	r5,zero
8113ed34:	e13ffd17 	ldw	r4,-12(fp)
8113ed38:	113a4600 	call	8113a460 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
8113ed3c:	e0bffd17 	ldw	r2,-12(fp)
8113ed40:	10800283 	ldbu	r2,10(r2)
8113ed44:	10803fcc 	andi	r2,r2,255
8113ed48:	103ff71e 	bne	r2,zero,8113ed28 <__reset+0xfb11ed28>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113ed4c:	e0bffd17 	ldw	r2,-12(fp)
8113ed50:	00c00fc4 	movi	r3,63
8113ed54:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113ed58:	e0bffd17 	ldw	r2,-12(fp)
8113ed5c:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8113ed60:	e0bffd17 	ldw	r2,-12(fp)
8113ed64:	10800117 	ldw	r2,4(r2)
8113ed68:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
8113ed6c:	d0e09d17 	ldw	r3,-32140(gp)
8113ed70:	e0bff817 	ldw	r2,-32(fp)
8113ed74:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
8113ed78:	e0bff817 	ldw	r2,-32(fp)
8113ed7c:	d0a09d15 	stw	r2,-32140(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113ed80:	e0bffd17 	ldw	r2,-12(fp)
8113ed84:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113ed88:	d0e0a017 	ldw	r3,-32128(gp)
8113ed8c:	e0bffd17 	ldw	r2,-12(fp)
8113ed90:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113ed94:	e0bffd17 	ldw	r2,-12(fp)
8113ed98:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113ed9c:	e0bffd17 	ldw	r2,-12(fp)
8113eda0:	d0a0a015 	stw	r2,-32128(gp)
8113eda4:	e0bff617 	ldw	r2,-40(fp)
8113eda8:	e0bffa15 	stw	r2,-24(fp)
8113edac:	e0bffa17 	ldw	r2,-24(fp)
8113edb0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113edb4:	e0bff403 	ldbu	r2,-48(fp)
8113edb8:	10800058 	cmpnei	r2,r2,1
8113edbc:	1000011e 	bne	r2,zero,8113edc4 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113edc0:	113af1c0 	call	8113af1c <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113edc4:	e0bfff17 	ldw	r2,-4(fp)
8113edc8:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
8113edcc:	e03ff515 	stw	zero,-44(fp)
             break;
8113edd0:	00000a06 	br	8113edfc <OSQDel+0x270>
8113edd4:	e0bff617 	ldw	r2,-40(fp)
8113edd8:	e0bffb15 	stw	r2,-20(fp)
8113eddc:	e0bffb17 	ldw	r2,-20(fp)
8113ede0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113ede4:	e0bfff17 	ldw	r2,-4(fp)
8113ede8:	00c001c4 	movi	r3,7
8113edec:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113edf0:	e0bffd17 	ldw	r2,-12(fp)
8113edf4:	e0bff515 	stw	r2,-44(fp)
             break;
8113edf8:	0001883a 	nop
    }
    return (pevent_return);
8113edfc:	e0bff517 	ldw	r2,-44(fp)
}
8113ee00:	e037883a 	mov	sp,fp
8113ee04:	dfc00117 	ldw	ra,4(sp)
8113ee08:	df000017 	ldw	fp,0(sp)
8113ee0c:	dec00204 	addi	sp,sp,8
8113ee10:	f800283a 	ret

8113ee14 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
8113ee14:	defffa04 	addi	sp,sp,-24
8113ee18:	de00012e 	bgeu	sp,et,8113ee20 <OSQFlush+0xc>
8113ee1c:	003b68fa 	trap	3
8113ee20:	df000515 	stw	fp,20(sp)
8113ee24:	df000504 	addi	fp,sp,20
8113ee28:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ee2c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ee30:	e0bfff17 	ldw	r2,-4(fp)
8113ee34:	1000021e 	bne	r2,zero,8113ee40 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
8113ee38:	00800104 	movi	r2,4
8113ee3c:	00002106 	br	8113eec4 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113ee40:	e0bfff17 	ldw	r2,-4(fp)
8113ee44:	10800003 	ldbu	r2,0(r2)
8113ee48:	10803fcc 	andi	r2,r2,255
8113ee4c:	108000a0 	cmpeqi	r2,r2,2
8113ee50:	1000021e 	bne	r2,zero,8113ee5c <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
8113ee54:	00800044 	movi	r2,1
8113ee58:	00001a06 	br	8113eec4 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ee5c:	0005303a 	rdctl	r2,status
8113ee60:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ee64:	e0fffd17 	ldw	r3,-12(fp)
8113ee68:	00bfff84 	movi	r2,-2
8113ee6c:	1884703a 	and	r2,r3,r2
8113ee70:	1001703a 	wrctl	status,r2
  
  return context;
8113ee74:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113ee78:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
8113ee7c:	e0bfff17 	ldw	r2,-4(fp)
8113ee80:	10800117 	ldw	r2,4(r2)
8113ee84:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
8113ee88:	e0bffc17 	ldw	r2,-16(fp)
8113ee8c:	10c00117 	ldw	r3,4(r2)
8113ee90:	e0bffc17 	ldw	r2,-16(fp)
8113ee94:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
8113ee98:	e0bffc17 	ldw	r2,-16(fp)
8113ee9c:	10c00117 	ldw	r3,4(r2)
8113eea0:	e0bffc17 	ldw	r2,-16(fp)
8113eea4:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
8113eea8:	e0bffc17 	ldw	r2,-16(fp)
8113eeac:	1000058d 	sth	zero,22(r2)
8113eeb0:	e0bffb17 	ldw	r2,-20(fp)
8113eeb4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113eeb8:	e0bffe17 	ldw	r2,-8(fp)
8113eebc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113eec0:	0005883a 	mov	r2,zero
}
8113eec4:	e037883a 	mov	sp,fp
8113eec8:	df000017 	ldw	fp,0(sp)
8113eecc:	dec00104 	addi	sp,sp,4
8113eed0:	f800283a 	ret

8113eed4 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113eed4:	defff304 	addi	sp,sp,-52
8113eed8:	de00012e 	bgeu	sp,et,8113eee0 <OSQPend+0xc>
8113eedc:	003b68fa 	trap	3
8113eee0:	dfc00c15 	stw	ra,48(sp)
8113eee4:	df000b15 	stw	fp,44(sp)
8113eee8:	df000b04 	addi	fp,sp,44
8113eeec:	e13ffd15 	stw	r4,-12(fp)
8113eef0:	2805883a 	mov	r2,r5
8113eef4:	e1bfff15 	stw	r6,-4(fp)
8113eef8:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113eefc:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113ef00:	e0bfff17 	ldw	r2,-4(fp)
8113ef04:	1000021e 	bne	r2,zero,8113ef10 <OSQPend+0x3c>
        return ((void *)0);
8113ef08:	0005883a 	mov	r2,zero
8113ef0c:	00009106 	br	8113f154 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113ef10:	e0bffd17 	ldw	r2,-12(fp)
8113ef14:	1000051e 	bne	r2,zero,8113ef2c <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113ef18:	e0bfff17 	ldw	r2,-4(fp)
8113ef1c:	00c00104 	movi	r3,4
8113ef20:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113ef24:	0005883a 	mov	r2,zero
8113ef28:	00008a06 	br	8113f154 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113ef2c:	e0bffd17 	ldw	r2,-12(fp)
8113ef30:	10800003 	ldbu	r2,0(r2)
8113ef34:	10803fcc 	andi	r2,r2,255
8113ef38:	108000a0 	cmpeqi	r2,r2,2
8113ef3c:	1000051e 	bne	r2,zero,8113ef54 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113ef40:	e0bfff17 	ldw	r2,-4(fp)
8113ef44:	00c00044 	movi	r3,1
8113ef48:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113ef4c:	0005883a 	mov	r2,zero
8113ef50:	00008006 	br	8113f154 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113ef54:	d0a0a103 	ldbu	r2,-32124(gp)
8113ef58:	10803fcc 	andi	r2,r2,255
8113ef5c:	10000526 	beq	r2,zero,8113ef74 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8113ef60:	e0bfff17 	ldw	r2,-4(fp)
8113ef64:	00c00084 	movi	r3,2
8113ef68:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113ef6c:	0005883a 	mov	r2,zero
8113ef70:	00007806 	br	8113f154 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
8113ef74:	d0a08f03 	ldbu	r2,-32196(gp)
8113ef78:	10803fcc 	andi	r2,r2,255
8113ef7c:	10000526 	beq	r2,zero,8113ef94 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
8113ef80:	e0bfff17 	ldw	r2,-4(fp)
8113ef84:	00c00344 	movi	r3,13
8113ef88:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113ef8c:	0005883a 	mov	r2,zero
8113ef90:	00007006 	br	8113f154 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ef94:	0005303a 	rdctl	r2,status
8113ef98:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ef9c:	e0fffc17 	ldw	r3,-16(fp)
8113efa0:	00bfff84 	movi	r2,-2
8113efa4:	1884703a 	and	r2,r3,r2
8113efa8:	1001703a 	wrctl	status,r2
  
  return context;
8113efac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113efb0:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113efb4:	e0bffd17 	ldw	r2,-12(fp)
8113efb8:	10800117 	ldw	r2,4(r2)
8113efbc:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113efc0:	e0bff817 	ldw	r2,-32(fp)
8113efc4:	1080058b 	ldhu	r2,22(r2)
8113efc8:	10bfffcc 	andi	r2,r2,65535
8113efcc:	10001e26 	beq	r2,zero,8113f048 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113efd0:	e0bff817 	ldw	r2,-32(fp)
8113efd4:	10800417 	ldw	r2,16(r2)
8113efd8:	11000104 	addi	r4,r2,4
8113efdc:	e0fff817 	ldw	r3,-32(fp)
8113efe0:	19000415 	stw	r4,16(r3)
8113efe4:	10800017 	ldw	r2,0(r2)
8113efe8:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113efec:	e0bff817 	ldw	r2,-32(fp)
8113eff0:	1080058b 	ldhu	r2,22(r2)
8113eff4:	10bfffc4 	addi	r2,r2,-1
8113eff8:	1007883a 	mov	r3,r2
8113effc:	e0bff817 	ldw	r2,-32(fp)
8113f000:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113f004:	e0bff817 	ldw	r2,-32(fp)
8113f008:	10c00417 	ldw	r3,16(r2)
8113f00c:	e0bff817 	ldw	r2,-32(fp)
8113f010:	10800217 	ldw	r2,8(r2)
8113f014:	1880041e 	bne	r3,r2,8113f028 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
8113f018:	e0bff817 	ldw	r2,-32(fp)
8113f01c:	10c00117 	ldw	r3,4(r2)
8113f020:	e0bff817 	ldw	r2,-32(fp)
8113f024:	10c00415 	stw	r3,16(r2)
8113f028:	e0bff617 	ldw	r2,-40(fp)
8113f02c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f030:	e0bff717 	ldw	r2,-36(fp)
8113f034:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113f038:	e0bfff17 	ldw	r2,-4(fp)
8113f03c:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
8113f040:	e0bff517 	ldw	r2,-44(fp)
8113f044:	00004306 	br	8113f154 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
8113f048:	d0a0a217 	ldw	r2,-32120(gp)
8113f04c:	d0e0a217 	ldw	r3,-32120(gp)
8113f050:	18c00c03 	ldbu	r3,48(r3)
8113f054:	18c00114 	ori	r3,r3,4
8113f058:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113f05c:	d0a0a217 	ldw	r2,-32120(gp)
8113f060:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
8113f064:	d0a0a217 	ldw	r2,-32120(gp)
8113f068:	e0fffe0b 	ldhu	r3,-8(fp)
8113f06c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8113f070:	e13ffd17 	ldw	r4,-12(fp)
8113f074:	113a6000 	call	8113a600 <OS_EventTaskWait>
8113f078:	e0bff617 	ldw	r2,-40(fp)
8113f07c:	e0bffb15 	stw	r2,-20(fp)
8113f080:	e0bffb17 	ldw	r2,-20(fp)
8113f084:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
8113f088:	113af1c0 	call	8113af1c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f08c:	0005303a 	rdctl	r2,status
8113f090:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f094:	e0fff917 	ldw	r3,-28(fp)
8113f098:	00bfff84 	movi	r2,-2
8113f09c:	1884703a 	and	r2,r3,r2
8113f0a0:	1001703a 	wrctl	status,r2
  
  return context;
8113f0a4:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113f0a8:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113f0ac:	d0a0a217 	ldw	r2,-32120(gp)
8113f0b0:	10800c43 	ldbu	r2,49(r2)
8113f0b4:	10803fcc 	andi	r2,r2,255
8113f0b8:	10000326 	beq	r2,zero,8113f0c8 <OSQPend+0x1f4>
8113f0bc:	108000a0 	cmpeqi	r2,r2,2
8113f0c0:	1000071e 	bne	r2,zero,8113f0e0 <OSQPend+0x20c>
8113f0c4:	00000b06 	br	8113f0f4 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
8113f0c8:	d0a0a217 	ldw	r2,-32120(gp)
8113f0cc:	10800917 	ldw	r2,36(r2)
8113f0d0:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
8113f0d4:	e0bfff17 	ldw	r2,-4(fp)
8113f0d8:	10000005 	stb	zero,0(r2)
             break;
8113f0dc:	00000e06 	br	8113f118 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113f0e0:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113f0e4:	e0bfff17 	ldw	r2,-4(fp)
8113f0e8:	00c00384 	movi	r3,14
8113f0ec:	10c00005 	stb	r3,0(r2)
             break;
8113f0f0:	00000906 	br	8113f118 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113f0f4:	d0a0a217 	ldw	r2,-32120(gp)
8113f0f8:	e17ffd17 	ldw	r5,-12(fp)
8113f0fc:	1009883a 	mov	r4,r2
8113f100:	113a8700 	call	8113a870 <OS_EventTaskRemove>
             pmsg = (void *)0;
8113f104:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113f108:	e0bfff17 	ldw	r2,-4(fp)
8113f10c:	00c00284 	movi	r3,10
8113f110:	10c00005 	stb	r3,0(r2)
             break;
8113f114:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113f118:	d0a0a217 	ldw	r2,-32120(gp)
8113f11c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113f120:	d0a0a217 	ldw	r2,-32120(gp)
8113f124:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113f128:	d0a0a217 	ldw	r2,-32120(gp)
8113f12c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113f130:	d0a0a217 	ldw	r2,-32120(gp)
8113f134:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
8113f138:	d0a0a217 	ldw	r2,-32120(gp)
8113f13c:	10000915 	stw	zero,36(r2)
8113f140:	e0bff617 	ldw	r2,-40(fp)
8113f144:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f148:	e0bffa17 	ldw	r2,-24(fp)
8113f14c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8113f150:	e0bff517 	ldw	r2,-44(fp)
}
8113f154:	e037883a 	mov	sp,fp
8113f158:	dfc00117 	ldw	ra,4(sp)
8113f15c:	df000017 	ldw	fp,0(sp)
8113f160:	dec00204 	addi	sp,sp,8
8113f164:	f800283a 	ret

8113f168 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113f168:	defff604 	addi	sp,sp,-40
8113f16c:	de00012e 	bgeu	sp,et,8113f174 <OSQPendAbort+0xc>
8113f170:	003b68fa 	trap	3
8113f174:	dfc00915 	stw	ra,36(sp)
8113f178:	df000815 	stw	fp,32(sp)
8113f17c:	df000804 	addi	fp,sp,32
8113f180:	e13ffd15 	stw	r4,-12(fp)
8113f184:	2805883a 	mov	r2,r5
8113f188:	e1bfff15 	stw	r6,-4(fp)
8113f18c:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113f190:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113f194:	e0bfff17 	ldw	r2,-4(fp)
8113f198:	1000021e 	bne	r2,zero,8113f1a4 <OSQPendAbort+0x3c>
        return (0);
8113f19c:	0005883a 	mov	r2,zero
8113f1a0:	00004906 	br	8113f2c8 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113f1a4:	e0bffd17 	ldw	r2,-12(fp)
8113f1a8:	1000051e 	bne	r2,zero,8113f1c0 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113f1ac:	e0bfff17 	ldw	r2,-4(fp)
8113f1b0:	00c00104 	movi	r3,4
8113f1b4:	10c00005 	stb	r3,0(r2)
        return (0);
8113f1b8:	0005883a 	mov	r2,zero
8113f1bc:	00004206 	br	8113f2c8 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113f1c0:	e0bffd17 	ldw	r2,-12(fp)
8113f1c4:	10800003 	ldbu	r2,0(r2)
8113f1c8:	10803fcc 	andi	r2,r2,255
8113f1cc:	108000a0 	cmpeqi	r2,r2,2
8113f1d0:	1000051e 	bne	r2,zero,8113f1e8 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113f1d4:	e0bfff17 	ldw	r2,-4(fp)
8113f1d8:	00c00044 	movi	r3,1
8113f1dc:	10c00005 	stb	r3,0(r2)
        return (0);
8113f1e0:	0005883a 	mov	r2,zero
8113f1e4:	00003806 	br	8113f2c8 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f1e8:	0005303a 	rdctl	r2,status
8113f1ec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f1f0:	e0fffc17 	ldw	r3,-16(fp)
8113f1f4:	00bfff84 	movi	r2,-2
8113f1f8:	1884703a 	and	r2,r3,r2
8113f1fc:	1001703a 	wrctl	status,r2
  
  return context;
8113f200:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113f204:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
8113f208:	e0bffd17 	ldw	r2,-12(fp)
8113f20c:	10800283 	ldbu	r2,10(r2)
8113f210:	10803fcc 	andi	r2,r2,255
8113f214:	10002526 	beq	r2,zero,8113f2ac <OSQPendAbort+0x144>
        nbr_tasks = 0;
8113f218:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113f21c:	e0bffe03 	ldbu	r2,-8(fp)
8113f220:	10800060 	cmpeqi	r2,r2,1
8113f224:	10000e26 	beq	r2,zero,8113f260 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113f228:	00000806 	br	8113f24c <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113f22c:	01c00084 	movi	r7,2
8113f230:	01800104 	movi	r6,4
8113f234:	000b883a 	mov	r5,zero
8113f238:	e13ffd17 	ldw	r4,-12(fp)
8113f23c:	113a4600 	call	8113a460 <OS_EventTaskRdy>
                     nbr_tasks++;
8113f240:	e0bff803 	ldbu	r2,-32(fp)
8113f244:	10800044 	addi	r2,r2,1
8113f248:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113f24c:	e0bffd17 	ldw	r2,-12(fp)
8113f250:	10800283 	ldbu	r2,10(r2)
8113f254:	10803fcc 	andi	r2,r2,255
8113f258:	103ff41e 	bne	r2,zero,8113f22c <__reset+0xfb11f22c>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113f25c:	00000906 	br	8113f284 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113f260:	01c00084 	movi	r7,2
8113f264:	01800104 	movi	r6,4
8113f268:	000b883a 	mov	r5,zero
8113f26c:	e13ffd17 	ldw	r4,-12(fp)
8113f270:	113a4600 	call	8113a460 <OS_EventTaskRdy>
                 nbr_tasks++;
8113f274:	e0bff803 	ldbu	r2,-32(fp)
8113f278:	10800044 	addi	r2,r2,1
8113f27c:	e0bff805 	stb	r2,-32(fp)
                 break;
8113f280:	0001883a 	nop
8113f284:	e0bff917 	ldw	r2,-28(fp)
8113f288:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f28c:	e0bffa17 	ldw	r2,-24(fp)
8113f290:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
8113f294:	113af1c0 	call	8113af1c <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113f298:	e0bfff17 	ldw	r2,-4(fp)
8113f29c:	00c00384 	movi	r3,14
8113f2a0:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113f2a4:	e0bff803 	ldbu	r2,-32(fp)
8113f2a8:	00000706 	br	8113f2c8 <OSQPendAbort+0x160>
8113f2ac:	e0bff917 	ldw	r2,-28(fp)
8113f2b0:	e0bffb15 	stw	r2,-20(fp)
8113f2b4:	e0bffb17 	ldw	r2,-20(fp)
8113f2b8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113f2bc:	e0bfff17 	ldw	r2,-4(fp)
8113f2c0:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
8113f2c4:	0005883a 	mov	r2,zero
}
8113f2c8:	e037883a 	mov	sp,fp
8113f2cc:	dfc00117 	ldw	ra,4(sp)
8113f2d0:	df000017 	ldw	fp,0(sp)
8113f2d4:	dec00204 	addi	sp,sp,8
8113f2d8:	f800283a 	ret

8113f2dc <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8113f2dc:	defff604 	addi	sp,sp,-40
8113f2e0:	de00012e 	bgeu	sp,et,8113f2e8 <OSQPost+0xc>
8113f2e4:	003b68fa 	trap	3
8113f2e8:	dfc00915 	stw	ra,36(sp)
8113f2ec:	df000815 	stw	fp,32(sp)
8113f2f0:	df000804 	addi	fp,sp,32
8113f2f4:	e13ffe15 	stw	r4,-8(fp)
8113f2f8:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113f2fc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113f300:	e0bffe17 	ldw	r2,-8(fp)
8113f304:	1000021e 	bne	r2,zero,8113f310 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
8113f308:	00800104 	movi	r2,4
8113f30c:	00004a06 	br	8113f438 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113f310:	e0bffe17 	ldw	r2,-8(fp)
8113f314:	10800003 	ldbu	r2,0(r2)
8113f318:	10803fcc 	andi	r2,r2,255
8113f31c:	108000a0 	cmpeqi	r2,r2,2
8113f320:	1000021e 	bne	r2,zero,8113f32c <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
8113f324:	00800044 	movi	r2,1
8113f328:	00004306 	br	8113f438 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f32c:	0005303a 	rdctl	r2,status
8113f330:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f334:	e0fffd17 	ldw	r3,-12(fp)
8113f338:	00bfff84 	movi	r2,-2
8113f33c:	1884703a 	and	r2,r3,r2
8113f340:	1001703a 	wrctl	status,r2
  
  return context;
8113f344:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113f348:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8113f34c:	e0bffe17 	ldw	r2,-8(fp)
8113f350:	10800283 	ldbu	r2,10(r2)
8113f354:	10803fcc 	andi	r2,r2,255
8113f358:	10000c26 	beq	r2,zero,8113f38c <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113f35c:	000f883a 	mov	r7,zero
8113f360:	01800104 	movi	r6,4
8113f364:	e17fff17 	ldw	r5,-4(fp)
8113f368:	e13ffe17 	ldw	r4,-8(fp)
8113f36c:	113a4600 	call	8113a460 <OS_EventTaskRdy>
8113f370:	e0bff817 	ldw	r2,-32(fp)
8113f374:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f378:	e0bff917 	ldw	r2,-28(fp)
8113f37c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
8113f380:	113af1c0 	call	8113af1c <OS_Sched>
        return (OS_ERR_NONE);
8113f384:	0005883a 	mov	r2,zero
8113f388:	00002b06 	br	8113f438 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
8113f38c:	e0bffe17 	ldw	r2,-8(fp)
8113f390:	10800117 	ldw	r2,4(r2)
8113f394:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
8113f398:	e0bffb17 	ldw	r2,-20(fp)
8113f39c:	10c0058b 	ldhu	r3,22(r2)
8113f3a0:	e0bffb17 	ldw	r2,-20(fp)
8113f3a4:	1080050b 	ldhu	r2,20(r2)
8113f3a8:	18ffffcc 	andi	r3,r3,65535
8113f3ac:	10bfffcc 	andi	r2,r2,65535
8113f3b0:	18800636 	bltu	r3,r2,8113f3cc <OSQPost+0xf0>
8113f3b4:	e0bff817 	ldw	r2,-32(fp)
8113f3b8:	e0bffa15 	stw	r2,-24(fp)
8113f3bc:	e0bffa17 	ldw	r2,-24(fp)
8113f3c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113f3c4:	00800784 	movi	r2,30
8113f3c8:	00001b06 	br	8113f438 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8113f3cc:	e0bffb17 	ldw	r2,-20(fp)
8113f3d0:	10800317 	ldw	r2,12(r2)
8113f3d4:	11000104 	addi	r4,r2,4
8113f3d8:	e0fffb17 	ldw	r3,-20(fp)
8113f3dc:	19000315 	stw	r4,12(r3)
8113f3e0:	e0ffff17 	ldw	r3,-4(fp)
8113f3e4:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
8113f3e8:	e0bffb17 	ldw	r2,-20(fp)
8113f3ec:	1080058b 	ldhu	r2,22(r2)
8113f3f0:	10800044 	addi	r2,r2,1
8113f3f4:	1007883a 	mov	r3,r2
8113f3f8:	e0bffb17 	ldw	r2,-20(fp)
8113f3fc:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8113f400:	e0bffb17 	ldw	r2,-20(fp)
8113f404:	10c00317 	ldw	r3,12(r2)
8113f408:	e0bffb17 	ldw	r2,-20(fp)
8113f40c:	10800217 	ldw	r2,8(r2)
8113f410:	1880041e 	bne	r3,r2,8113f424 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
8113f414:	e0bffb17 	ldw	r2,-20(fp)
8113f418:	10c00117 	ldw	r3,4(r2)
8113f41c:	e0bffb17 	ldw	r2,-20(fp)
8113f420:	10c00315 	stw	r3,12(r2)
8113f424:	e0bff817 	ldw	r2,-32(fp)
8113f428:	e0bffc15 	stw	r2,-16(fp)
8113f42c:	e0bffc17 	ldw	r2,-16(fp)
8113f430:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f434:	0005883a 	mov	r2,zero
}
8113f438:	e037883a 	mov	sp,fp
8113f43c:	dfc00117 	ldw	ra,4(sp)
8113f440:	df000017 	ldw	fp,0(sp)
8113f444:	dec00204 	addi	sp,sp,8
8113f448:	f800283a 	ret

8113f44c <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8113f44c:	defff604 	addi	sp,sp,-40
8113f450:	de00012e 	bgeu	sp,et,8113f458 <OSQPostFront+0xc>
8113f454:	003b68fa 	trap	3
8113f458:	dfc00915 	stw	ra,36(sp)
8113f45c:	df000815 	stw	fp,32(sp)
8113f460:	df000804 	addi	fp,sp,32
8113f464:	e13ffe15 	stw	r4,-8(fp)
8113f468:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113f46c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113f470:	e0bffe17 	ldw	r2,-8(fp)
8113f474:	1000021e 	bne	r2,zero,8113f480 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
8113f478:	00800104 	movi	r2,4
8113f47c:	00004c06 	br	8113f5b0 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113f480:	e0bffe17 	ldw	r2,-8(fp)
8113f484:	10800003 	ldbu	r2,0(r2)
8113f488:	10803fcc 	andi	r2,r2,255
8113f48c:	108000a0 	cmpeqi	r2,r2,2
8113f490:	1000021e 	bne	r2,zero,8113f49c <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
8113f494:	00800044 	movi	r2,1
8113f498:	00004506 	br	8113f5b0 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f49c:	0005303a 	rdctl	r2,status
8113f4a0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f4a4:	e0fffd17 	ldw	r3,-12(fp)
8113f4a8:	00bfff84 	movi	r2,-2
8113f4ac:	1884703a 	and	r2,r3,r2
8113f4b0:	1001703a 	wrctl	status,r2
  
  return context;
8113f4b4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113f4b8:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
8113f4bc:	e0bffe17 	ldw	r2,-8(fp)
8113f4c0:	10800283 	ldbu	r2,10(r2)
8113f4c4:	10803fcc 	andi	r2,r2,255
8113f4c8:	10000c26 	beq	r2,zero,8113f4fc <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113f4cc:	000f883a 	mov	r7,zero
8113f4d0:	01800104 	movi	r6,4
8113f4d4:	e17fff17 	ldw	r5,-4(fp)
8113f4d8:	e13ffe17 	ldw	r4,-8(fp)
8113f4dc:	113a4600 	call	8113a460 <OS_EventTaskRdy>
8113f4e0:	e0bff817 	ldw	r2,-32(fp)
8113f4e4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f4e8:	e0bff917 	ldw	r2,-28(fp)
8113f4ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113f4f0:	113af1c0 	call	8113af1c <OS_Sched>
        return (OS_ERR_NONE);
8113f4f4:	0005883a 	mov	r2,zero
8113f4f8:	00002d06 	br	8113f5b0 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113f4fc:	e0bffe17 	ldw	r2,-8(fp)
8113f500:	10800117 	ldw	r2,4(r2)
8113f504:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113f508:	e0bffb17 	ldw	r2,-20(fp)
8113f50c:	10c0058b 	ldhu	r3,22(r2)
8113f510:	e0bffb17 	ldw	r2,-20(fp)
8113f514:	1080050b 	ldhu	r2,20(r2)
8113f518:	18ffffcc 	andi	r3,r3,65535
8113f51c:	10bfffcc 	andi	r2,r2,65535
8113f520:	18800636 	bltu	r3,r2,8113f53c <OSQPostFront+0xf0>
8113f524:	e0bff817 	ldw	r2,-32(fp)
8113f528:	e0bffa15 	stw	r2,-24(fp)
8113f52c:	e0bffa17 	ldw	r2,-24(fp)
8113f530:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113f534:	00800784 	movi	r2,30
8113f538:	00001d06 	br	8113f5b0 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8113f53c:	e0bffb17 	ldw	r2,-20(fp)
8113f540:	10c00417 	ldw	r3,16(r2)
8113f544:	e0bffb17 	ldw	r2,-20(fp)
8113f548:	10800117 	ldw	r2,4(r2)
8113f54c:	1880041e 	bne	r3,r2,8113f560 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8113f550:	e0bffb17 	ldw	r2,-20(fp)
8113f554:	10c00217 	ldw	r3,8(r2)
8113f558:	e0bffb17 	ldw	r2,-20(fp)
8113f55c:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113f560:	e0bffb17 	ldw	r2,-20(fp)
8113f564:	10800417 	ldw	r2,16(r2)
8113f568:	10ffff04 	addi	r3,r2,-4
8113f56c:	e0bffb17 	ldw	r2,-20(fp)
8113f570:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
8113f574:	e0bffb17 	ldw	r2,-20(fp)
8113f578:	10800417 	ldw	r2,16(r2)
8113f57c:	e0ffff17 	ldw	r3,-4(fp)
8113f580:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113f584:	e0bffb17 	ldw	r2,-20(fp)
8113f588:	1080058b 	ldhu	r2,22(r2)
8113f58c:	10800044 	addi	r2,r2,1
8113f590:	1007883a 	mov	r3,r2
8113f594:	e0bffb17 	ldw	r2,-20(fp)
8113f598:	10c0058d 	sth	r3,22(r2)
8113f59c:	e0bff817 	ldw	r2,-32(fp)
8113f5a0:	e0bffc15 	stw	r2,-16(fp)
8113f5a4:	e0bffc17 	ldw	r2,-16(fp)
8113f5a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f5ac:	0005883a 	mov	r2,zero
}
8113f5b0:	e037883a 	mov	sp,fp
8113f5b4:	dfc00117 	ldw	ra,4(sp)
8113f5b8:	df000017 	ldw	fp,0(sp)
8113f5bc:	dec00204 	addi	sp,sp,8
8113f5c0:	f800283a 	ret

8113f5c4 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
8113f5c4:	defff504 	addi	sp,sp,-44
8113f5c8:	de00012e 	bgeu	sp,et,8113f5d0 <OSQPostOpt+0xc>
8113f5cc:	003b68fa 	trap	3
8113f5d0:	dfc00a15 	stw	ra,40(sp)
8113f5d4:	df000915 	stw	fp,36(sp)
8113f5d8:	df000904 	addi	fp,sp,36
8113f5dc:	e13ffd15 	stw	r4,-12(fp)
8113f5e0:	e17ffe15 	stw	r5,-8(fp)
8113f5e4:	3005883a 	mov	r2,r6
8113f5e8:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113f5ec:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113f5f0:	e0bffd17 	ldw	r2,-12(fp)
8113f5f4:	1000021e 	bne	r2,zero,8113f600 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
8113f5f8:	00800104 	movi	r2,4
8113f5fc:	00007106 	br	8113f7c4 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113f600:	e0bffd17 	ldw	r2,-12(fp)
8113f604:	10800003 	ldbu	r2,0(r2)
8113f608:	10803fcc 	andi	r2,r2,255
8113f60c:	108000a0 	cmpeqi	r2,r2,2
8113f610:	1000021e 	bne	r2,zero,8113f61c <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
8113f614:	00800044 	movi	r2,1
8113f618:	00006a06 	br	8113f7c4 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f61c:	0005303a 	rdctl	r2,status
8113f620:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f624:	e0fffc17 	ldw	r3,-16(fp)
8113f628:	00bfff84 	movi	r2,-2
8113f62c:	1884703a 	and	r2,r3,r2
8113f630:	1001703a 	wrctl	status,r2
  
  return context;
8113f634:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113f638:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8113f63c:	e0bffd17 	ldw	r2,-12(fp)
8113f640:	10800283 	ldbu	r2,10(r2)
8113f644:	10803fcc 	andi	r2,r2,255
8113f648:	10001d26 	beq	r2,zero,8113f6c0 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8113f64c:	e0bfff03 	ldbu	r2,-4(fp)
8113f650:	1080004c 	andi	r2,r2,1
8113f654:	10000b26 	beq	r2,zero,8113f684 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113f658:	00000506 	br	8113f670 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113f65c:	000f883a 	mov	r7,zero
8113f660:	01800104 	movi	r6,4
8113f664:	e17ffe17 	ldw	r5,-8(fp)
8113f668:	e13ffd17 	ldw	r4,-12(fp)
8113f66c:	113a4600 	call	8113a460 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113f670:	e0bffd17 	ldw	r2,-12(fp)
8113f674:	10800283 	ldbu	r2,10(r2)
8113f678:	10803fcc 	andi	r2,r2,255
8113f67c:	103ff71e 	bne	r2,zero,8113f65c <__reset+0xfb11f65c>
8113f680:	00000506 	br	8113f698 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113f684:	000f883a 	mov	r7,zero
8113f688:	01800104 	movi	r6,4
8113f68c:	e17ffe17 	ldw	r5,-8(fp)
8113f690:	e13ffd17 	ldw	r4,-12(fp)
8113f694:	113a4600 	call	8113a460 <OS_EventTaskRdy>
8113f698:	e0bff717 	ldw	r2,-36(fp)
8113f69c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f6a0:	e0bff817 	ldw	r2,-32(fp)
8113f6a4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
8113f6a8:	e0bfff03 	ldbu	r2,-4(fp)
8113f6ac:	1080010c 	andi	r2,r2,4
8113f6b0:	1000011e 	bne	r2,zero,8113f6b8 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
8113f6b4:	113af1c0 	call	8113af1c <OS_Sched>
        }
        return (OS_ERR_NONE);
8113f6b8:	0005883a 	mov	r2,zero
8113f6bc:	00004106 	br	8113f7c4 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113f6c0:	e0bffd17 	ldw	r2,-12(fp)
8113f6c4:	10800117 	ldw	r2,4(r2)
8113f6c8:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113f6cc:	e0bffa17 	ldw	r2,-24(fp)
8113f6d0:	10c0058b 	ldhu	r3,22(r2)
8113f6d4:	e0bffa17 	ldw	r2,-24(fp)
8113f6d8:	1080050b 	ldhu	r2,20(r2)
8113f6dc:	18ffffcc 	andi	r3,r3,65535
8113f6e0:	10bfffcc 	andi	r2,r2,65535
8113f6e4:	18800636 	bltu	r3,r2,8113f700 <OSQPostOpt+0x13c>
8113f6e8:	e0bff717 	ldw	r2,-36(fp)
8113f6ec:	e0bff915 	stw	r2,-28(fp)
8113f6f0:	e0bff917 	ldw	r2,-28(fp)
8113f6f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113f6f8:	00800784 	movi	r2,30
8113f6fc:	00003106 	br	8113f7c4 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
8113f700:	e0bfff03 	ldbu	r2,-4(fp)
8113f704:	1080008c 	andi	r2,r2,2
8113f708:	10001326 	beq	r2,zero,8113f758 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8113f70c:	e0bffa17 	ldw	r2,-24(fp)
8113f710:	10c00417 	ldw	r3,16(r2)
8113f714:	e0bffa17 	ldw	r2,-24(fp)
8113f718:	10800117 	ldw	r2,4(r2)
8113f71c:	1880041e 	bne	r3,r2,8113f730 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
8113f720:	e0bffa17 	ldw	r2,-24(fp)
8113f724:	10c00217 	ldw	r3,8(r2)
8113f728:	e0bffa17 	ldw	r2,-24(fp)
8113f72c:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
8113f730:	e0bffa17 	ldw	r2,-24(fp)
8113f734:	10800417 	ldw	r2,16(r2)
8113f738:	10ffff04 	addi	r3,r2,-4
8113f73c:	e0bffa17 	ldw	r2,-24(fp)
8113f740:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
8113f744:	e0bffa17 	ldw	r2,-24(fp)
8113f748:	10800417 	ldw	r2,16(r2)
8113f74c:	e0fffe17 	ldw	r3,-8(fp)
8113f750:	10c00015 	stw	r3,0(r2)
8113f754:	00001006 	br	8113f798 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
8113f758:	e0bffa17 	ldw	r2,-24(fp)
8113f75c:	10800317 	ldw	r2,12(r2)
8113f760:	11000104 	addi	r4,r2,4
8113f764:	e0fffa17 	ldw	r3,-24(fp)
8113f768:	19000315 	stw	r4,12(r3)
8113f76c:	e0fffe17 	ldw	r3,-8(fp)
8113f770:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
8113f774:	e0bffa17 	ldw	r2,-24(fp)
8113f778:	10c00317 	ldw	r3,12(r2)
8113f77c:	e0bffa17 	ldw	r2,-24(fp)
8113f780:	10800217 	ldw	r2,8(r2)
8113f784:	1880041e 	bne	r3,r2,8113f798 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
8113f788:	e0bffa17 	ldw	r2,-24(fp)
8113f78c:	10c00117 	ldw	r3,4(r2)
8113f790:	e0bffa17 	ldw	r2,-24(fp)
8113f794:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113f798:	e0bffa17 	ldw	r2,-24(fp)
8113f79c:	1080058b 	ldhu	r2,22(r2)
8113f7a0:	10800044 	addi	r2,r2,1
8113f7a4:	1007883a 	mov	r3,r2
8113f7a8:	e0bffa17 	ldw	r2,-24(fp)
8113f7ac:	10c0058d 	sth	r3,22(r2)
8113f7b0:	e0bff717 	ldw	r2,-36(fp)
8113f7b4:	e0bffb15 	stw	r2,-20(fp)
8113f7b8:	e0bffb17 	ldw	r2,-20(fp)
8113f7bc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f7c0:	0005883a 	mov	r2,zero
}
8113f7c4:	e037883a 	mov	sp,fp
8113f7c8:	dfc00117 	ldw	ra,4(sp)
8113f7cc:	df000017 	ldw	fp,0(sp)
8113f7d0:	dec00204 	addi	sp,sp,8
8113f7d4:	f800283a 	ret

8113f7d8 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
8113f7d8:	defff604 	addi	sp,sp,-40
8113f7dc:	de00012e 	bgeu	sp,et,8113f7e4 <OSQQuery+0xc>
8113f7e0:	003b68fa 	trap	3
8113f7e4:	df000915 	stw	fp,36(sp)
8113f7e8:	df000904 	addi	fp,sp,36
8113f7ec:	e13ffe15 	stw	r4,-8(fp)
8113f7f0:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113f7f4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113f7f8:	e0bffe17 	ldw	r2,-8(fp)
8113f7fc:	1000021e 	bne	r2,zero,8113f808 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113f800:	00800104 	movi	r2,4
8113f804:	00004906 	br	8113f92c <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
8113f808:	e0bfff17 	ldw	r2,-4(fp)
8113f80c:	1000021e 	bne	r2,zero,8113f818 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113f810:	00800244 	movi	r2,9
8113f814:	00004506 	br	8113f92c <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113f818:	e0bffe17 	ldw	r2,-8(fp)
8113f81c:	10800003 	ldbu	r2,0(r2)
8113f820:	10803fcc 	andi	r2,r2,255
8113f824:	108000a0 	cmpeqi	r2,r2,2
8113f828:	1000021e 	bne	r2,zero,8113f834 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113f82c:	00800044 	movi	r2,1
8113f830:	00003e06 	br	8113f92c <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f834:	0005303a 	rdctl	r2,status
8113f838:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f83c:	e0fffd17 	ldw	r3,-12(fp)
8113f840:	00bfff84 	movi	r2,-2
8113f844:	1884703a 	and	r2,r3,r2
8113f848:	1001703a 	wrctl	status,r2
  
  return context;
8113f84c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113f850:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
8113f854:	e0bffe17 	ldw	r2,-8(fp)
8113f858:	10c00283 	ldbu	r3,10(r2)
8113f85c:	e0bfff17 	ldw	r2,-4(fp)
8113f860:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
8113f864:	e0bffe17 	ldw	r2,-8(fp)
8113f868:	108002c4 	addi	r2,r2,11
8113f86c:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8113f870:	e0bfff17 	ldw	r2,-4(fp)
8113f874:	10800204 	addi	r2,r2,8
8113f878:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113f87c:	e03ff705 	stb	zero,-36(fp)
8113f880:	00000b06 	br	8113f8b0 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
8113f884:	e0bff917 	ldw	r2,-28(fp)
8113f888:	10c00044 	addi	r3,r2,1
8113f88c:	e0fff915 	stw	r3,-28(fp)
8113f890:	e0fff817 	ldw	r3,-32(fp)
8113f894:	19000044 	addi	r4,r3,1
8113f898:	e13ff815 	stw	r4,-32(fp)
8113f89c:	18c00003 	ldbu	r3,0(r3)
8113f8a0:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113f8a4:	e0bff703 	ldbu	r2,-36(fp)
8113f8a8:	10800044 	addi	r2,r2,1
8113f8ac:	e0bff705 	stb	r2,-36(fp)
8113f8b0:	e0bff703 	ldbu	r2,-36(fp)
8113f8b4:	108001b0 	cmpltui	r2,r2,6
8113f8b8:	103ff21e 	bne	r2,zero,8113f884 <__reset+0xfb11f884>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
8113f8bc:	e0bffe17 	ldw	r2,-8(fp)
8113f8c0:	10800117 	ldw	r2,4(r2)
8113f8c4:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
8113f8c8:	e0bffc17 	ldw	r2,-16(fp)
8113f8cc:	1080058b 	ldhu	r2,22(r2)
8113f8d0:	10bfffcc 	andi	r2,r2,65535
8113f8d4:	10000626 	beq	r2,zero,8113f8f0 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
8113f8d8:	e0bffc17 	ldw	r2,-16(fp)
8113f8dc:	10800417 	ldw	r2,16(r2)
8113f8e0:	10c00017 	ldw	r3,0(r2)
8113f8e4:	e0bfff17 	ldw	r2,-4(fp)
8113f8e8:	10c00015 	stw	r3,0(r2)
8113f8ec:	00000206 	br	8113f8f8 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8113f8f0:	e0bfff17 	ldw	r2,-4(fp)
8113f8f4:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
8113f8f8:	e0bffc17 	ldw	r2,-16(fp)
8113f8fc:	10c0058b 	ldhu	r3,22(r2)
8113f900:	e0bfff17 	ldw	r2,-4(fp)
8113f904:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
8113f908:	e0bffc17 	ldw	r2,-16(fp)
8113f90c:	10c0050b 	ldhu	r3,20(r2)
8113f910:	e0bfff17 	ldw	r2,-4(fp)
8113f914:	10c0018d 	sth	r3,6(r2)
8113f918:	e0bffa17 	ldw	r2,-24(fp)
8113f91c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f920:	e0bffb17 	ldw	r2,-20(fp)
8113f924:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f928:	0005883a 	mov	r2,zero
}
8113f92c:	e037883a 	mov	sp,fp
8113f930:	df000017 	ldw	fp,0(sp)
8113f934:	dec00104 	addi	sp,sp,4
8113f938:	f800283a 	ret

8113f93c <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
8113f93c:	defffb04 	addi	sp,sp,-20
8113f940:	de00012e 	bgeu	sp,et,8113f948 <OS_QInit+0xc>
8113f944:	003b68fa 	trap	3
8113f948:	dfc00415 	stw	ra,16(sp)
8113f94c:	df000315 	stw	fp,12(sp)
8113f950:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
8113f954:	0140c004 	movi	r5,768
8113f958:	012045f4 	movhi	r4,33047
8113f95c:	21298b04 	addi	r4,r4,-22996
8113f960:	113ae500 	call	8113ae50 <OS_MemClr>
    pq1 = &OSQTbl[0];
8113f964:	00a045f4 	movhi	r2,33047
8113f968:	10a98b04 	addi	r2,r2,-22996
8113f96c:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8113f970:	00a045f4 	movhi	r2,33047
8113f974:	10a99104 	addi	r2,r2,-22972
8113f978:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113f97c:	e03ffd0d 	sth	zero,-12(fp)
8113f980:	00000c06 	br	8113f9b4 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
8113f984:	e0bffe17 	ldw	r2,-8(fp)
8113f988:	e0ffff17 	ldw	r3,-4(fp)
8113f98c:	10c00015 	stw	r3,0(r2)
        pq1++;
8113f990:	e0bffe17 	ldw	r2,-8(fp)
8113f994:	10800604 	addi	r2,r2,24
8113f998:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8113f99c:	e0bfff17 	ldw	r2,-4(fp)
8113f9a0:	10800604 	addi	r2,r2,24
8113f9a4:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113f9a8:	e0bffd0b 	ldhu	r2,-12(fp)
8113f9ac:	10800044 	addi	r2,r2,1
8113f9b0:	e0bffd0d 	sth	r2,-12(fp)
8113f9b4:	e0bffd0b 	ldhu	r2,-12(fp)
8113f9b8:	108007f0 	cmpltui	r2,r2,31
8113f9bc:	103ff11e 	bne	r2,zero,8113f984 <__reset+0xfb11f984>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
8113f9c0:	e0bffe17 	ldw	r2,-8(fp)
8113f9c4:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
8113f9c8:	00a045f4 	movhi	r2,33047
8113f9cc:	10a98b04 	addi	r2,r2,-22996
8113f9d0:	d0a09d15 	stw	r2,-32140(gp)
#endif
}
8113f9d4:	0001883a 	nop
8113f9d8:	e037883a 	mov	sp,fp
8113f9dc:	dfc00117 	ldw	ra,4(sp)
8113f9e0:	df000017 	ldw	fp,0(sp)
8113f9e4:	dec00204 	addi	sp,sp,8
8113f9e8:	f800283a 	ret

8113f9ec <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8113f9ec:	defffa04 	addi	sp,sp,-24
8113f9f0:	de00012e 	bgeu	sp,et,8113f9f8 <OSSemAccept+0xc>
8113f9f4:	003b68fa 	trap	3
8113f9f8:	df000515 	stw	fp,20(sp)
8113f9fc:	df000504 	addi	fp,sp,20
8113fa00:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113fa04:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113fa08:	e0bfff17 	ldw	r2,-4(fp)
8113fa0c:	1000021e 	bne	r2,zero,8113fa18 <OSSemAccept+0x2c>
        return (0);
8113fa10:	0005883a 	mov	r2,zero
8113fa14:	00001f06 	br	8113fa94 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113fa18:	e0bfff17 	ldw	r2,-4(fp)
8113fa1c:	10800003 	ldbu	r2,0(r2)
8113fa20:	10803fcc 	andi	r2,r2,255
8113fa24:	108000e0 	cmpeqi	r2,r2,3
8113fa28:	1000021e 	bne	r2,zero,8113fa34 <OSSemAccept+0x48>
        return (0);
8113fa2c:	0005883a 	mov	r2,zero
8113fa30:	00001806 	br	8113fa94 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fa34:	0005303a 	rdctl	r2,status
8113fa38:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fa3c:	e0fffe17 	ldw	r3,-8(fp)
8113fa40:	00bfff84 	movi	r2,-2
8113fa44:	1884703a 	and	r2,r3,r2
8113fa48:	1001703a 	wrctl	status,r2
  
  return context;
8113fa4c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113fa50:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
8113fa54:	e0bfff17 	ldw	r2,-4(fp)
8113fa58:	1080020b 	ldhu	r2,8(r2)
8113fa5c:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8113fa60:	e0bffd0b 	ldhu	r2,-12(fp)
8113fa64:	10000626 	beq	r2,zero,8113fa80 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
8113fa68:	e0bfff17 	ldw	r2,-4(fp)
8113fa6c:	1080020b 	ldhu	r2,8(r2)
8113fa70:	10bfffc4 	addi	r2,r2,-1
8113fa74:	1007883a 	mov	r3,r2
8113fa78:	e0bfff17 	ldw	r2,-4(fp)
8113fa7c:	10c0020d 	sth	r3,8(r2)
8113fa80:	e0bffb17 	ldw	r2,-20(fp)
8113fa84:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fa88:	e0bffc17 	ldw	r2,-16(fp)
8113fa8c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
8113fa90:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113fa94:	e037883a 	mov	sp,fp
8113fa98:	df000017 	ldw	fp,0(sp)
8113fa9c:	dec00104 	addi	sp,sp,4
8113faa0:	f800283a 	ret

8113faa4 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
8113faa4:	defff904 	addi	sp,sp,-28
8113faa8:	de00012e 	bgeu	sp,et,8113fab0 <OSSemCreate+0xc>
8113faac:	003b68fa 	trap	3
8113fab0:	dfc00615 	stw	ra,24(sp)
8113fab4:	df000515 	stw	fp,20(sp)
8113fab8:	df000504 	addi	fp,sp,20
8113fabc:	2005883a 	mov	r2,r4
8113fac0:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113fac4:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113fac8:	d0a0a103 	ldbu	r2,-32124(gp)
8113facc:	10803fcc 	andi	r2,r2,255
8113fad0:	10000226 	beq	r2,zero,8113fadc <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
8113fad4:	0005883a 	mov	r2,zero
8113fad8:	00002506 	br	8113fb70 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fadc:	0005303a 	rdctl	r2,status
8113fae0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fae4:	e0fffe17 	ldw	r3,-8(fp)
8113fae8:	00bfff84 	movi	r2,-2
8113faec:	1884703a 	and	r2,r3,r2
8113faf0:	1001703a 	wrctl	status,r2
  
  return context;
8113faf4:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113faf8:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8113fafc:	d0a0a017 	ldw	r2,-32128(gp)
8113fb00:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
8113fb04:	d0a0a017 	ldw	r2,-32128(gp)
8113fb08:	10000326 	beq	r2,zero,8113fb18 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113fb0c:	d0a0a017 	ldw	r2,-32128(gp)
8113fb10:	10800117 	ldw	r2,4(r2)
8113fb14:	d0a0a015 	stw	r2,-32128(gp)
8113fb18:	e0bffb17 	ldw	r2,-20(fp)
8113fb1c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fb20:	e0bffc17 	ldw	r2,-16(fp)
8113fb24:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
8113fb28:	e0bffd17 	ldw	r2,-12(fp)
8113fb2c:	10000f26 	beq	r2,zero,8113fb6c <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
8113fb30:	e0bffd17 	ldw	r2,-12(fp)
8113fb34:	00c000c4 	movi	r3,3
8113fb38:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
8113fb3c:	e0bffd17 	ldw	r2,-12(fp)
8113fb40:	e0ffff0b 	ldhu	r3,-4(fp)
8113fb44:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
8113fb48:	e0bffd17 	ldw	r2,-12(fp)
8113fb4c:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
8113fb50:	e0bffd17 	ldw	r2,-12(fp)
8113fb54:	00c00fc4 	movi	r3,63
8113fb58:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
8113fb5c:	e0bffd17 	ldw	r2,-12(fp)
8113fb60:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
8113fb64:	e13ffd17 	ldw	r4,-12(fp)
8113fb68:	113aa380 	call	8113aa38 <OS_EventWaitListInit>
    }
    return (pevent);
8113fb6c:	e0bffd17 	ldw	r2,-12(fp)
}
8113fb70:	e037883a 	mov	sp,fp
8113fb74:	dfc00117 	ldw	ra,4(sp)
8113fb78:	df000017 	ldw	fp,0(sp)
8113fb7c:	dec00204 	addi	sp,sp,8
8113fb80:	f800283a 	ret

8113fb84 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113fb84:	defff304 	addi	sp,sp,-52
8113fb88:	de00012e 	bgeu	sp,et,8113fb90 <OSSemDel+0xc>
8113fb8c:	003b68fa 	trap	3
8113fb90:	dfc00c15 	stw	ra,48(sp)
8113fb94:	df000b15 	stw	fp,44(sp)
8113fb98:	df000b04 	addi	fp,sp,44
8113fb9c:	e13ffd15 	stw	r4,-12(fp)
8113fba0:	2805883a 	mov	r2,r5
8113fba4:	e1bfff15 	stw	r6,-4(fp)
8113fba8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113fbac:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113fbb0:	e0bfff17 	ldw	r2,-4(fp)
8113fbb4:	1000021e 	bne	r2,zero,8113fbc0 <OSSemDel+0x3c>
        return (pevent);
8113fbb8:	e0bffd17 	ldw	r2,-12(fp)
8113fbbc:	00007e06 	br	8113fdb8 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113fbc0:	e0bffd17 	ldw	r2,-12(fp)
8113fbc4:	1000051e 	bne	r2,zero,8113fbdc <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113fbc8:	e0bfff17 	ldw	r2,-4(fp)
8113fbcc:	00c00104 	movi	r3,4
8113fbd0:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113fbd4:	e0bffd17 	ldw	r2,-12(fp)
8113fbd8:	00007706 	br	8113fdb8 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113fbdc:	e0bffd17 	ldw	r2,-12(fp)
8113fbe0:	10800003 	ldbu	r2,0(r2)
8113fbe4:	10803fcc 	andi	r2,r2,255
8113fbe8:	108000e0 	cmpeqi	r2,r2,3
8113fbec:	1000051e 	bne	r2,zero,8113fc04 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113fbf0:	e0bfff17 	ldw	r2,-4(fp)
8113fbf4:	00c00044 	movi	r3,1
8113fbf8:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113fbfc:	e0bffd17 	ldw	r2,-12(fp)
8113fc00:	00006d06 	br	8113fdb8 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113fc04:	d0a0a103 	ldbu	r2,-32124(gp)
8113fc08:	10803fcc 	andi	r2,r2,255
8113fc0c:	10000526 	beq	r2,zero,8113fc24 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113fc10:	e0bfff17 	ldw	r2,-4(fp)
8113fc14:	00c003c4 	movi	r3,15
8113fc18:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113fc1c:	e0bffd17 	ldw	r2,-12(fp)
8113fc20:	00006506 	br	8113fdb8 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fc24:	0005303a 	rdctl	r2,status
8113fc28:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fc2c:	e0fffc17 	ldw	r3,-16(fp)
8113fc30:	00bfff84 	movi	r2,-2
8113fc34:	1884703a 	and	r2,r3,r2
8113fc38:	1001703a 	wrctl	status,r2
  
  return context;
8113fc3c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113fc40:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
8113fc44:	e0bffd17 	ldw	r2,-12(fp)
8113fc48:	10800283 	ldbu	r2,10(r2)
8113fc4c:	10803fcc 	andi	r2,r2,255
8113fc50:	10000326 	beq	r2,zero,8113fc60 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113fc54:	00800044 	movi	r2,1
8113fc58:	e0bff505 	stb	r2,-44(fp)
8113fc5c:	00000106 	br	8113fc64 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113fc60:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
8113fc64:	e0bffe03 	ldbu	r2,-8(fp)
8113fc68:	10000326 	beq	r2,zero,8113fc78 <OSSemDel+0xf4>
8113fc6c:	10800060 	cmpeqi	r2,r2,1
8113fc70:	1000281e 	bne	r2,zero,8113fd14 <OSSemDel+0x190>
8113fc74:	00004506 	br	8113fd8c <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
8113fc78:	e0bff503 	ldbu	r2,-44(fp)
8113fc7c:	1000161e 	bne	r2,zero,8113fcd8 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113fc80:	e0bffd17 	ldw	r2,-12(fp)
8113fc84:	00c00fc4 	movi	r3,63
8113fc88:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113fc8c:	e0bffd17 	ldw	r2,-12(fp)
8113fc90:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113fc94:	e0bffd17 	ldw	r2,-12(fp)
8113fc98:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113fc9c:	d0e0a017 	ldw	r3,-32128(gp)
8113fca0:	e0bffd17 	ldw	r2,-12(fp)
8113fca4:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113fca8:	e0bffd17 	ldw	r2,-12(fp)
8113fcac:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113fcb0:	e0bffd17 	ldw	r2,-12(fp)
8113fcb4:	d0a0a015 	stw	r2,-32128(gp)
8113fcb8:	e0bff717 	ldw	r2,-36(fp)
8113fcbc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fcc0:	e0bff817 	ldw	r2,-32(fp)
8113fcc4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113fcc8:	e0bfff17 	ldw	r2,-4(fp)
8113fccc:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
8113fcd0:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113fcd4:	00003706 	br	8113fdb4 <OSSemDel+0x230>
8113fcd8:	e0bff717 	ldw	r2,-36(fp)
8113fcdc:	e0bff915 	stw	r2,-28(fp)
8113fce0:	e0bff917 	ldw	r2,-28(fp)
8113fce4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113fce8:	e0bfff17 	ldw	r2,-4(fp)
8113fcec:	00c01244 	movi	r3,73
8113fcf0:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113fcf4:	e0bffd17 	ldw	r2,-12(fp)
8113fcf8:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113fcfc:	00002d06 	br	8113fdb4 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113fd00:	000f883a 	mov	r7,zero
8113fd04:	01800044 	movi	r6,1
8113fd08:	000b883a 	mov	r5,zero
8113fd0c:	e13ffd17 	ldw	r4,-12(fp)
8113fd10:	113a4600 	call	8113a460 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
8113fd14:	e0bffd17 	ldw	r2,-12(fp)
8113fd18:	10800283 	ldbu	r2,10(r2)
8113fd1c:	10803fcc 	andi	r2,r2,255
8113fd20:	103ff71e 	bne	r2,zero,8113fd00 <__reset+0xfb11fd00>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113fd24:	e0bffd17 	ldw	r2,-12(fp)
8113fd28:	00c00fc4 	movi	r3,63
8113fd2c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113fd30:	e0bffd17 	ldw	r2,-12(fp)
8113fd34:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113fd38:	e0bffd17 	ldw	r2,-12(fp)
8113fd3c:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113fd40:	d0e0a017 	ldw	r3,-32128(gp)
8113fd44:	e0bffd17 	ldw	r2,-12(fp)
8113fd48:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113fd4c:	e0bffd17 	ldw	r2,-12(fp)
8113fd50:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113fd54:	e0bffd17 	ldw	r2,-12(fp)
8113fd58:	d0a0a015 	stw	r2,-32128(gp)
8113fd5c:	e0bff717 	ldw	r2,-36(fp)
8113fd60:	e0bffa15 	stw	r2,-24(fp)
8113fd64:	e0bffa17 	ldw	r2,-24(fp)
8113fd68:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113fd6c:	e0bff503 	ldbu	r2,-44(fp)
8113fd70:	10800058 	cmpnei	r2,r2,1
8113fd74:	1000011e 	bne	r2,zero,8113fd7c <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113fd78:	113af1c0 	call	8113af1c <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113fd7c:	e0bfff17 	ldw	r2,-4(fp)
8113fd80:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
8113fd84:	e03ff615 	stw	zero,-40(fp)
             break;
8113fd88:	00000a06 	br	8113fdb4 <OSSemDel+0x230>
8113fd8c:	e0bff717 	ldw	r2,-36(fp)
8113fd90:	e0bffb15 	stw	r2,-20(fp)
8113fd94:	e0bffb17 	ldw	r2,-20(fp)
8113fd98:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113fd9c:	e0bfff17 	ldw	r2,-4(fp)
8113fda0:	00c001c4 	movi	r3,7
8113fda4:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113fda8:	e0bffd17 	ldw	r2,-12(fp)
8113fdac:	e0bff615 	stw	r2,-40(fp)
             break;
8113fdb0:	0001883a 	nop
    }
    return (pevent_return);
8113fdb4:	e0bff617 	ldw	r2,-40(fp)
}
8113fdb8:	e037883a 	mov	sp,fp
8113fdbc:	dfc00117 	ldw	ra,4(sp)
8113fdc0:	df000017 	ldw	fp,0(sp)
8113fdc4:	dec00204 	addi	sp,sp,8
8113fdc8:	f800283a 	ret

8113fdcc <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113fdcc:	defff504 	addi	sp,sp,-44
8113fdd0:	de00012e 	bgeu	sp,et,8113fdd8 <OSSemPend+0xc>
8113fdd4:	003b68fa 	trap	3
8113fdd8:	dfc00a15 	stw	ra,40(sp)
8113fddc:	df000915 	stw	fp,36(sp)
8113fde0:	df000904 	addi	fp,sp,36
8113fde4:	e13ffd15 	stw	r4,-12(fp)
8113fde8:	2805883a 	mov	r2,r5
8113fdec:	e1bfff15 	stw	r6,-4(fp)
8113fdf0:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113fdf4:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113fdf8:	e0bfff17 	ldw	r2,-4(fp)
8113fdfc:	10007226 	beq	r2,zero,8113ffc8 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113fe00:	e0bffd17 	ldw	r2,-12(fp)
8113fe04:	1000041e 	bne	r2,zero,8113fe18 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113fe08:	e0bfff17 	ldw	r2,-4(fp)
8113fe0c:	00c00104 	movi	r3,4
8113fe10:	10c00005 	stb	r3,0(r2)
        return;
8113fe14:	00006d06 	br	8113ffcc <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113fe18:	e0bffd17 	ldw	r2,-12(fp)
8113fe1c:	10800003 	ldbu	r2,0(r2)
8113fe20:	10803fcc 	andi	r2,r2,255
8113fe24:	108000e0 	cmpeqi	r2,r2,3
8113fe28:	1000041e 	bne	r2,zero,8113fe3c <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113fe2c:	e0bfff17 	ldw	r2,-4(fp)
8113fe30:	00c00044 	movi	r3,1
8113fe34:	10c00005 	stb	r3,0(r2)
        return;
8113fe38:	00006406 	br	8113ffcc <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113fe3c:	d0a0a103 	ldbu	r2,-32124(gp)
8113fe40:	10803fcc 	andi	r2,r2,255
8113fe44:	10000426 	beq	r2,zero,8113fe58 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
8113fe48:	e0bfff17 	ldw	r2,-4(fp)
8113fe4c:	00c00084 	movi	r3,2
8113fe50:	10c00005 	stb	r3,0(r2)
        return;
8113fe54:	00005d06 	br	8113ffcc <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
8113fe58:	d0a08f03 	ldbu	r2,-32196(gp)
8113fe5c:	10803fcc 	andi	r2,r2,255
8113fe60:	10000426 	beq	r2,zero,8113fe74 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
8113fe64:	e0bfff17 	ldw	r2,-4(fp)
8113fe68:	00c00344 	movi	r3,13
8113fe6c:	10c00005 	stb	r3,0(r2)
        return;
8113fe70:	00005606 	br	8113ffcc <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fe74:	0005303a 	rdctl	r2,status
8113fe78:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fe7c:	e0fffc17 	ldw	r3,-16(fp)
8113fe80:	00bfff84 	movi	r2,-2
8113fe84:	1884703a 	and	r2,r3,r2
8113fe88:	1001703a 	wrctl	status,r2
  
  return context;
8113fe8c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113fe90:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
8113fe94:	e0bffd17 	ldw	r2,-12(fp)
8113fe98:	1080020b 	ldhu	r2,8(r2)
8113fe9c:	10bfffcc 	andi	r2,r2,65535
8113fea0:	10000d26 	beq	r2,zero,8113fed8 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
8113fea4:	e0bffd17 	ldw	r2,-12(fp)
8113fea8:	1080020b 	ldhu	r2,8(r2)
8113feac:	10bfffc4 	addi	r2,r2,-1
8113feb0:	1007883a 	mov	r3,r2
8113feb4:	e0bffd17 	ldw	r2,-12(fp)
8113feb8:	10c0020d 	sth	r3,8(r2)
8113febc:	e0bff717 	ldw	r2,-36(fp)
8113fec0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fec4:	e0bff817 	ldw	r2,-32(fp)
8113fec8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113fecc:	e0bfff17 	ldw	r2,-4(fp)
8113fed0:	10000005 	stb	zero,0(r2)
        return;
8113fed4:	00003d06 	br	8113ffcc <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8113fed8:	d0a0a217 	ldw	r2,-32120(gp)
8113fedc:	d0e0a217 	ldw	r3,-32120(gp)
8113fee0:	18c00c03 	ldbu	r3,48(r3)
8113fee4:	18c00054 	ori	r3,r3,1
8113fee8:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113feec:	d0a0a217 	ldw	r2,-32120(gp)
8113fef0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
8113fef4:	d0a0a217 	ldw	r2,-32120(gp)
8113fef8:	e0fffe0b 	ldhu	r3,-8(fp)
8113fefc:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113ff00:	e13ffd17 	ldw	r4,-12(fp)
8113ff04:	113a6000 	call	8113a600 <OS_EventTaskWait>
8113ff08:	e0bff717 	ldw	r2,-36(fp)
8113ff0c:	e0bffb15 	stw	r2,-20(fp)
8113ff10:	e0bffb17 	ldw	r2,-20(fp)
8113ff14:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113ff18:	113af1c0 	call	8113af1c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ff1c:	0005303a 	rdctl	r2,status
8113ff20:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ff24:	e0fff917 	ldw	r3,-28(fp)
8113ff28:	00bfff84 	movi	r2,-2
8113ff2c:	1884703a 	and	r2,r3,r2
8113ff30:	1001703a 	wrctl	status,r2
  
  return context;
8113ff34:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113ff38:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113ff3c:	d0a0a217 	ldw	r2,-32120(gp)
8113ff40:	10800c43 	ldbu	r2,49(r2)
8113ff44:	10803fcc 	andi	r2,r2,255
8113ff48:	10000326 	beq	r2,zero,8113ff58 <OSSemPend+0x18c>
8113ff4c:	108000a0 	cmpeqi	r2,r2,2
8113ff50:	1000041e 	bne	r2,zero,8113ff64 <OSSemPend+0x198>
8113ff54:	00000706 	br	8113ff74 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113ff58:	e0bfff17 	ldw	r2,-4(fp)
8113ff5c:	10000005 	stb	zero,0(r2)
             break;
8113ff60:	00000c06 	br	8113ff94 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113ff64:	e0bfff17 	ldw	r2,-4(fp)
8113ff68:	00c00384 	movi	r3,14
8113ff6c:	10c00005 	stb	r3,0(r2)
             break;
8113ff70:	00000806 	br	8113ff94 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
8113ff74:	d0a0a217 	ldw	r2,-32120(gp)
8113ff78:	e17ffd17 	ldw	r5,-12(fp)
8113ff7c:	1009883a 	mov	r4,r2
8113ff80:	113a8700 	call	8113a870 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113ff84:	e0bfff17 	ldw	r2,-4(fp)
8113ff88:	00c00284 	movi	r3,10
8113ff8c:	10c00005 	stb	r3,0(r2)
             break;
8113ff90:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113ff94:	d0a0a217 	ldw	r2,-32120(gp)
8113ff98:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113ff9c:	d0a0a217 	ldw	r2,-32120(gp)
8113ffa0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113ffa4:	d0a0a217 	ldw	r2,-32120(gp)
8113ffa8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113ffac:	d0a0a217 	ldw	r2,-32120(gp)
8113ffb0:	10000815 	stw	zero,32(r2)
8113ffb4:	e0bff717 	ldw	r2,-36(fp)
8113ffb8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ffbc:	e0bffa17 	ldw	r2,-24(fp)
8113ffc0:	1001703a 	wrctl	status,r2
8113ffc4:	00000106 	br	8113ffcc <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113ffc8:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113ffcc:	e037883a 	mov	sp,fp
8113ffd0:	dfc00117 	ldw	ra,4(sp)
8113ffd4:	df000017 	ldw	fp,0(sp)
8113ffd8:	dec00204 	addi	sp,sp,8
8113ffdc:	f800283a 	ret

8113ffe0 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113ffe0:	defff604 	addi	sp,sp,-40
8113ffe4:	de00012e 	bgeu	sp,et,8113ffec <OSSemPendAbort+0xc>
8113ffe8:	003b68fa 	trap	3
8113ffec:	dfc00915 	stw	ra,36(sp)
8113fff0:	df000815 	stw	fp,32(sp)
8113fff4:	df000804 	addi	fp,sp,32
8113fff8:	e13ffd15 	stw	r4,-12(fp)
8113fffc:	2805883a 	mov	r2,r5
81140000:	e1bfff15 	stw	r6,-4(fp)
81140004:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140008:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8114000c:	e0bfff17 	ldw	r2,-4(fp)
81140010:	1000021e 	bne	r2,zero,8114001c <OSSemPendAbort+0x3c>
        return (0);
81140014:	0005883a 	mov	r2,zero
81140018:	00004906 	br	81140140 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8114001c:	e0bffd17 	ldw	r2,-12(fp)
81140020:	1000051e 	bne	r2,zero,81140038 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81140024:	e0bfff17 	ldw	r2,-4(fp)
81140028:	00c00104 	movi	r3,4
8114002c:	10c00005 	stb	r3,0(r2)
        return (0);
81140030:	0005883a 	mov	r2,zero
81140034:	00004206 	br	81140140 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81140038:	e0bffd17 	ldw	r2,-12(fp)
8114003c:	10800003 	ldbu	r2,0(r2)
81140040:	10803fcc 	andi	r2,r2,255
81140044:	108000e0 	cmpeqi	r2,r2,3
81140048:	1000051e 	bne	r2,zero,81140060 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8114004c:	e0bfff17 	ldw	r2,-4(fp)
81140050:	00c00044 	movi	r3,1
81140054:	10c00005 	stb	r3,0(r2)
        return (0);
81140058:	0005883a 	mov	r2,zero
8114005c:	00003806 	br	81140140 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140060:	0005303a 	rdctl	r2,status
81140064:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140068:	e0fffc17 	ldw	r3,-16(fp)
8114006c:	00bfff84 	movi	r2,-2
81140070:	1884703a 	and	r2,r3,r2
81140074:	1001703a 	wrctl	status,r2
  
  return context;
81140078:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8114007c:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
81140080:	e0bffd17 	ldw	r2,-12(fp)
81140084:	10800283 	ldbu	r2,10(r2)
81140088:	10803fcc 	andi	r2,r2,255
8114008c:	10002526 	beq	r2,zero,81140124 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
81140090:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81140094:	e0bffe03 	ldbu	r2,-8(fp)
81140098:	10800060 	cmpeqi	r2,r2,1
8114009c:	10000e26 	beq	r2,zero,811400d8 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
811400a0:	00000806 	br	811400c4 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
811400a4:	01c00084 	movi	r7,2
811400a8:	01800044 	movi	r6,1
811400ac:	000b883a 	mov	r5,zero
811400b0:	e13ffd17 	ldw	r4,-12(fp)
811400b4:	113a4600 	call	8113a460 <OS_EventTaskRdy>
                     nbr_tasks++;
811400b8:	e0bff803 	ldbu	r2,-32(fp)
811400bc:	10800044 	addi	r2,r2,1
811400c0:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
811400c4:	e0bffd17 	ldw	r2,-12(fp)
811400c8:	10800283 	ldbu	r2,10(r2)
811400cc:	10803fcc 	andi	r2,r2,255
811400d0:	103ff41e 	bne	r2,zero,811400a4 <__reset+0xfb1200a4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
811400d4:	00000906 	br	811400fc <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
811400d8:	01c00084 	movi	r7,2
811400dc:	01800044 	movi	r6,1
811400e0:	000b883a 	mov	r5,zero
811400e4:	e13ffd17 	ldw	r4,-12(fp)
811400e8:	113a4600 	call	8113a460 <OS_EventTaskRdy>
                 nbr_tasks++;
811400ec:	e0bff803 	ldbu	r2,-32(fp)
811400f0:	10800044 	addi	r2,r2,1
811400f4:	e0bff805 	stb	r2,-32(fp)
                 break;
811400f8:	0001883a 	nop
811400fc:	e0bff917 	ldw	r2,-28(fp)
81140100:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140104:	e0bffa17 	ldw	r2,-24(fp)
81140108:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8114010c:	113af1c0 	call	8113af1c <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81140110:	e0bfff17 	ldw	r2,-4(fp)
81140114:	00c00384 	movi	r3,14
81140118:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8114011c:	e0bff803 	ldbu	r2,-32(fp)
81140120:	00000706 	br	81140140 <OSSemPendAbort+0x160>
81140124:	e0bff917 	ldw	r2,-28(fp)
81140128:	e0bffb15 	stw	r2,-20(fp)
8114012c:	e0bffb17 	ldw	r2,-20(fp)
81140130:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81140134:	e0bfff17 	ldw	r2,-4(fp)
81140138:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
8114013c:	0005883a 	mov	r2,zero
}
81140140:	e037883a 	mov	sp,fp
81140144:	dfc00117 	ldw	ra,4(sp)
81140148:	df000017 	ldw	fp,0(sp)
8114014c:	dec00204 	addi	sp,sp,8
81140150:	f800283a 	ret

81140154 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
81140154:	defff804 	addi	sp,sp,-32
81140158:	de00012e 	bgeu	sp,et,81140160 <OSSemPost+0xc>
8114015c:	003b68fa 	trap	3
81140160:	dfc00715 	stw	ra,28(sp)
81140164:	df000615 	stw	fp,24(sp)
81140168:	df000604 	addi	fp,sp,24
8114016c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140170:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81140174:	e0bfff17 	ldw	r2,-4(fp)
81140178:	1000021e 	bne	r2,zero,81140184 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
8114017c:	00800104 	movi	r2,4
81140180:	00003506 	br	81140258 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81140184:	e0bfff17 	ldw	r2,-4(fp)
81140188:	10800003 	ldbu	r2,0(r2)
8114018c:	10803fcc 	andi	r2,r2,255
81140190:	108000e0 	cmpeqi	r2,r2,3
81140194:	1000021e 	bne	r2,zero,811401a0 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
81140198:	00800044 	movi	r2,1
8114019c:	00002e06 	br	81140258 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811401a0:	0005303a 	rdctl	r2,status
811401a4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811401a8:	e0fffe17 	ldw	r3,-8(fp)
811401ac:	00bfff84 	movi	r2,-2
811401b0:	1884703a 	and	r2,r3,r2
811401b4:	1001703a 	wrctl	status,r2
  
  return context;
811401b8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811401bc:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
811401c0:	e0bfff17 	ldw	r2,-4(fp)
811401c4:	10800283 	ldbu	r2,10(r2)
811401c8:	10803fcc 	andi	r2,r2,255
811401cc:	10000c26 	beq	r2,zero,81140200 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
811401d0:	000f883a 	mov	r7,zero
811401d4:	01800044 	movi	r6,1
811401d8:	000b883a 	mov	r5,zero
811401dc:	e13fff17 	ldw	r4,-4(fp)
811401e0:	113a4600 	call	8113a460 <OS_EventTaskRdy>
811401e4:	e0bffa17 	ldw	r2,-24(fp)
811401e8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811401ec:	e0bffb17 	ldw	r2,-20(fp)
811401f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
811401f4:	113af1c0 	call	8113af1c <OS_Sched>
        return (OS_ERR_NONE);
811401f8:	0005883a 	mov	r2,zero
811401fc:	00001606 	br	81140258 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
81140200:	e0bfff17 	ldw	r2,-4(fp)
81140204:	1080020b 	ldhu	r2,8(r2)
81140208:	10ffffcc 	andi	r3,r2,65535
8114020c:	00bfffd4 	movui	r2,65535
81140210:	18800c26 	beq	r3,r2,81140244 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
81140214:	e0bfff17 	ldw	r2,-4(fp)
81140218:	1080020b 	ldhu	r2,8(r2)
8114021c:	10800044 	addi	r2,r2,1
81140220:	1007883a 	mov	r3,r2
81140224:	e0bfff17 	ldw	r2,-4(fp)
81140228:	10c0020d 	sth	r3,8(r2)
8114022c:	e0bffa17 	ldw	r2,-24(fp)
81140230:	e0bffc15 	stw	r2,-16(fp)
81140234:	e0bffc17 	ldw	r2,-16(fp)
81140238:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8114023c:	0005883a 	mov	r2,zero
81140240:	00000506 	br	81140258 <OSSemPost+0x104>
81140244:	e0bffa17 	ldw	r2,-24(fp)
81140248:	e0bffd15 	stw	r2,-12(fp)
8114024c:	e0bffd17 	ldw	r2,-12(fp)
81140250:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
81140254:	00800c84 	movi	r2,50
}
81140258:	e037883a 	mov	sp,fp
8114025c:	dfc00117 	ldw	ra,4(sp)
81140260:	df000017 	ldw	fp,0(sp)
81140264:	dec00204 	addi	sp,sp,8
81140268:	f800283a 	ret

8114026c <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8114026c:	defff704 	addi	sp,sp,-36
81140270:	de00012e 	bgeu	sp,et,81140278 <OSSemQuery+0xc>
81140274:	003b68fa 	trap	3
81140278:	df000815 	stw	fp,32(sp)
8114027c:	df000804 	addi	fp,sp,32
81140280:	e13ffe15 	stw	r4,-8(fp)
81140284:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81140288:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8114028c:	e0bffe17 	ldw	r2,-8(fp)
81140290:	1000021e 	bne	r2,zero,8114029c <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81140294:	00800104 	movi	r2,4
81140298:	00003606 	br	81140374 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8114029c:	e0bfff17 	ldw	r2,-4(fp)
811402a0:	1000021e 	bne	r2,zero,811402ac <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
811402a4:	00800244 	movi	r2,9
811402a8:	00003206 	br	81140374 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
811402ac:	e0bffe17 	ldw	r2,-8(fp)
811402b0:	10800003 	ldbu	r2,0(r2)
811402b4:	10803fcc 	andi	r2,r2,255
811402b8:	108000e0 	cmpeqi	r2,r2,3
811402bc:	1000021e 	bne	r2,zero,811402c8 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
811402c0:	00800044 	movi	r2,1
811402c4:	00002b06 	br	81140374 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811402c8:	0005303a 	rdctl	r2,status
811402cc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811402d0:	e0fffd17 	ldw	r3,-12(fp)
811402d4:	00bfff84 	movi	r2,-2
811402d8:	1884703a 	and	r2,r3,r2
811402dc:	1001703a 	wrctl	status,r2
  
  return context;
811402e0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811402e4:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
811402e8:	e0bffe17 	ldw	r2,-8(fp)
811402ec:	10c00283 	ldbu	r3,10(r2)
811402f0:	e0bfff17 	ldw	r2,-4(fp)
811402f4:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
811402f8:	e0bffe17 	ldw	r2,-8(fp)
811402fc:	108002c4 	addi	r2,r2,11
81140300:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
81140304:	e0bfff17 	ldw	r2,-4(fp)
81140308:	10800084 	addi	r2,r2,2
8114030c:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81140310:	e03ffa05 	stb	zero,-24(fp)
81140314:	00000b06 	br	81140344 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
81140318:	e0bff917 	ldw	r2,-28(fp)
8114031c:	10c00044 	addi	r3,r2,1
81140320:	e0fff915 	stw	r3,-28(fp)
81140324:	e0fff817 	ldw	r3,-32(fp)
81140328:	19000044 	addi	r4,r3,1
8114032c:	e13ff815 	stw	r4,-32(fp)
81140330:	18c00003 	ldbu	r3,0(r3)
81140334:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81140338:	e0bffa03 	ldbu	r2,-24(fp)
8114033c:	10800044 	addi	r2,r2,1
81140340:	e0bffa05 	stb	r2,-24(fp)
81140344:	e0bffa03 	ldbu	r2,-24(fp)
81140348:	108001b0 	cmpltui	r2,r2,6
8114034c:	103ff21e 	bne	r2,zero,81140318 <__reset+0xfb120318>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
81140350:	e0bffe17 	ldw	r2,-8(fp)
81140354:	10c0020b 	ldhu	r3,8(r2)
81140358:	e0bfff17 	ldw	r2,-4(fp)
8114035c:	10c0000d 	sth	r3,0(r2)
81140360:	e0bffb17 	ldw	r2,-20(fp)
81140364:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140368:	e0bffc17 	ldw	r2,-16(fp)
8114036c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81140370:	0005883a 	mov	r2,zero
}
81140374:	e037883a 	mov	sp,fp
81140378:	df000017 	ldw	fp,0(sp)
8114037c:	dec00104 	addi	sp,sp,4
81140380:	f800283a 	ret

81140384 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
81140384:	defff904 	addi	sp,sp,-28
81140388:	de00012e 	bgeu	sp,et,81140390 <OSSemSet+0xc>
8114038c:	003b68fa 	trap	3
81140390:	df000615 	stw	fp,24(sp)
81140394:	df000604 	addi	fp,sp,24
81140398:	e13ffd15 	stw	r4,-12(fp)
8114039c:	2805883a 	mov	r2,r5
811403a0:	e1bfff15 	stw	r6,-4(fp)
811403a4:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811403a8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
811403ac:	e0bfff17 	ldw	r2,-4(fp)
811403b0:	10003126 	beq	r2,zero,81140478 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811403b4:	e0bffd17 	ldw	r2,-12(fp)
811403b8:	1000041e 	bne	r2,zero,811403cc <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
811403bc:	e0bfff17 	ldw	r2,-4(fp)
811403c0:	00c00104 	movi	r3,4
811403c4:	10c00005 	stb	r3,0(r2)
        return;
811403c8:	00002c06 	br	8114047c <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811403cc:	e0bffd17 	ldw	r2,-12(fp)
811403d0:	10800003 	ldbu	r2,0(r2)
811403d4:	10803fcc 	andi	r2,r2,255
811403d8:	108000e0 	cmpeqi	r2,r2,3
811403dc:	1000041e 	bne	r2,zero,811403f0 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
811403e0:	e0bfff17 	ldw	r2,-4(fp)
811403e4:	00c00044 	movi	r3,1
811403e8:	10c00005 	stb	r3,0(r2)
        return;
811403ec:	00002306 	br	8114047c <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811403f0:	0005303a 	rdctl	r2,status
811403f4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811403f8:	e0fffc17 	ldw	r3,-16(fp)
811403fc:	00bfff84 	movi	r2,-2
81140400:	1884703a 	and	r2,r3,r2
81140404:	1001703a 	wrctl	status,r2
  
  return context;
81140408:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8114040c:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
81140410:	e0bfff17 	ldw	r2,-4(fp)
81140414:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
81140418:	e0bffd17 	ldw	r2,-12(fp)
8114041c:	1080020b 	ldhu	r2,8(r2)
81140420:	10bfffcc 	andi	r2,r2,65535
81140424:	10000426 	beq	r2,zero,81140438 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
81140428:	e0bffd17 	ldw	r2,-12(fp)
8114042c:	e0fffe0b 	ldhu	r3,-8(fp)
81140430:	10c0020d 	sth	r3,8(r2)
81140434:	00000b06 	br	81140464 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
81140438:	e0bffd17 	ldw	r2,-12(fp)
8114043c:	10800283 	ldbu	r2,10(r2)
81140440:	10803fcc 	andi	r2,r2,255
81140444:	1000041e 	bne	r2,zero,81140458 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
81140448:	e0bffd17 	ldw	r2,-12(fp)
8114044c:	e0fffe0b 	ldhu	r3,-8(fp)
81140450:	10c0020d 	sth	r3,8(r2)
81140454:	00000306 	br	81140464 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
81140458:	e0bfff17 	ldw	r2,-4(fp)
8114045c:	00c01244 	movi	r3,73
81140460:	10c00005 	stb	r3,0(r2)
81140464:	e0bffa17 	ldw	r2,-24(fp)
81140468:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114046c:	e0bffb17 	ldw	r2,-20(fp)
81140470:	1001703a 	wrctl	status,r2
81140474:	00000106 	br	8114047c <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81140478:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
8114047c:	e037883a 	mov	sp,fp
81140480:	df000017 	ldw	fp,0(sp)
81140484:	dec00104 	addi	sp,sp,4
81140488:	f800283a 	ret

8114048c <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
8114048c:	defff104 	addi	sp,sp,-60
81140490:	de00012e 	bgeu	sp,et,81140498 <OSTaskChangePrio+0xc>
81140494:	003b68fa 	trap	3
81140498:	dfc00e15 	stw	ra,56(sp)
8114049c:	df000d15 	stw	fp,52(sp)
811404a0:	df000d04 	addi	fp,sp,52
811404a4:	2007883a 	mov	r3,r4
811404a8:	2805883a 	mov	r2,r5
811404ac:	e0fffe05 	stb	r3,-8(fp)
811404b0:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
811404b4:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
811404b8:	e0bffe03 	ldbu	r2,-8(fp)
811404bc:	10800ab0 	cmpltui	r2,r2,42
811404c0:	1000051e 	bne	r2,zero,811404d8 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
811404c4:	e0bffe03 	ldbu	r2,-8(fp)
811404c8:	10803fe0 	cmpeqi	r2,r2,255
811404cc:	1000021e 	bne	r2,zero,811404d8 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
811404d0:	00800a84 	movi	r2,42
811404d4:	00012606 	br	81140970 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
811404d8:	e0bfff03 	ldbu	r2,-4(fp)
811404dc:	10800ab0 	cmpltui	r2,r2,42
811404e0:	1000021e 	bne	r2,zero,811404ec <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
811404e4:	00800a84 	movi	r2,42
811404e8:	00012106 	br	81140970 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811404ec:	0005303a 	rdctl	r2,status
811404f0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811404f4:	e0fffd17 	ldw	r3,-12(fp)
811404f8:	00bfff84 	movi	r2,-2
811404fc:	1884703a 	and	r2,r3,r2
81140500:	1001703a 	wrctl	status,r2
  
  return context;
81140504:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81140508:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8114050c:	e0ffff03 	ldbu	r3,-4(fp)
81140510:	00a045f4 	movhi	r2,33047
81140514:	10b7f904 	addi	r2,r2,-8220
81140518:	18c7883a 	add	r3,r3,r3
8114051c:	18c7883a 	add	r3,r3,r3
81140520:	10c5883a 	add	r2,r2,r3
81140524:	10800017 	ldw	r2,0(r2)
81140528:	10000626 	beq	r2,zero,81140544 <OSTaskChangePrio+0xb8>
8114052c:	e0bff517 	ldw	r2,-44(fp)
81140530:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140534:	e0bff617 	ldw	r2,-40(fp)
81140538:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
8114053c:	00800a04 	movi	r2,40
81140540:	00010b06 	br	81140970 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
81140544:	e0bffe03 	ldbu	r2,-8(fp)
81140548:	10803fd8 	cmpnei	r2,r2,255
8114054c:	1000031e 	bne	r2,zero,8114055c <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
81140550:	d0a0a217 	ldw	r2,-32120(gp)
81140554:	10800c83 	ldbu	r2,50(r2)
81140558:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
8114055c:	e0fffe03 	ldbu	r3,-8(fp)
81140560:	00a045f4 	movhi	r2,33047
81140564:	10b7f904 	addi	r2,r2,-8220
81140568:	18c7883a 	add	r3,r3,r3
8114056c:	18c7883a 	add	r3,r3,r3
81140570:	10c5883a 	add	r2,r2,r3
81140574:	10800017 	ldw	r2,0(r2)
81140578:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
8114057c:	e0bff817 	ldw	r2,-32(fp)
81140580:	1000061e 	bne	r2,zero,8114059c <OSTaskChangePrio+0x110>
81140584:	e0bff517 	ldw	r2,-44(fp)
81140588:	e0bff715 	stw	r2,-36(fp)
8114058c:	e0bff717 	ldw	r2,-36(fp)
81140590:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
81140594:	00800a44 	movi	r2,41
81140598:	0000f506 	br	81140970 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
8114059c:	e0bff817 	ldw	r2,-32(fp)
811405a0:	10800058 	cmpnei	r2,r2,1
811405a4:	1000061e 	bne	r2,zero,811405c0 <OSTaskChangePrio+0x134>
811405a8:	e0bff517 	ldw	r2,-44(fp)
811405ac:	e0bff915 	stw	r2,-28(fp)
811405b0:	e0bff917 	ldw	r2,-28(fp)
811405b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
811405b8:	008010c4 	movi	r2,67
811405bc:	0000ec06 	br	81140970 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
811405c0:	e0bfff03 	ldbu	r2,-4(fp)
811405c4:	1004d0fa 	srli	r2,r2,3
811405c8:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
811405cc:	e0bfff03 	ldbu	r2,-4(fp)
811405d0:	108001cc 	andi	r2,r2,7
811405d4:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
811405d8:	e0bffb03 	ldbu	r2,-20(fp)
811405dc:	00c00044 	movi	r3,1
811405e0:	1884983a 	sll	r2,r3,r2
811405e4:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
811405e8:	e0bffb43 	ldbu	r2,-19(fp)
811405ec:	00c00044 	movi	r3,1
811405f0:	1884983a 	sll	r2,r3,r2
811405f4:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
811405f8:	e0fffe03 	ldbu	r3,-8(fp)
811405fc:	00a045f4 	movhi	r2,33047
81140600:	10b7f904 	addi	r2,r2,-8220
81140604:	18c7883a 	add	r3,r3,r3
81140608:	18c7883a 	add	r3,r3,r3
8114060c:	10c5883a 	add	r2,r2,r3
81140610:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
81140614:	e0ffff03 	ldbu	r3,-4(fp)
81140618:	00a045f4 	movhi	r2,33047
8114061c:	10b7f904 	addi	r2,r2,-8220
81140620:	18c7883a 	add	r3,r3,r3
81140624:	18c7883a 	add	r3,r3,r3
81140628:	10c5883a 	add	r2,r2,r3
8114062c:	e0fff817 	ldw	r3,-32(fp)
81140630:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
81140634:	e0bff817 	ldw	r2,-32(fp)
81140638:	10800d03 	ldbu	r2,52(r2)
8114063c:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
81140640:	e0bff817 	ldw	r2,-32(fp)
81140644:	10800d83 	ldbu	r2,54(r2)
81140648:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
8114064c:	e0bff817 	ldw	r2,-32(fp)
81140650:	10800d43 	ldbu	r2,53(r2)
81140654:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
81140658:	e0fffc03 	ldbu	r3,-16(fp)
8114065c:	d0a09e44 	addi	r2,gp,-32135
81140660:	1885883a 	add	r2,r3,r2
81140664:	10c00003 	ldbu	r3,0(r2)
81140668:	e0bffc83 	ldbu	r2,-14(fp)
8114066c:	1884703a 	and	r2,r3,r2
81140670:	10803fcc 	andi	r2,r2,255
81140674:	10002826 	beq	r2,zero,81140718 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
81140678:	e0fffc03 	ldbu	r3,-16(fp)
8114067c:	e13ffc03 	ldbu	r4,-16(fp)
81140680:	d0a09e44 	addi	r2,gp,-32135
81140684:	2085883a 	add	r2,r4,r2
81140688:	10800003 	ldbu	r2,0(r2)
8114068c:	1009883a 	mov	r4,r2
81140690:	e0bffc83 	ldbu	r2,-14(fp)
81140694:	0084303a 	nor	r2,zero,r2
81140698:	2084703a 	and	r2,r4,r2
8114069c:	1009883a 	mov	r4,r2
811406a0:	d0a09e44 	addi	r2,gp,-32135
811406a4:	1885883a 	add	r2,r3,r2
811406a8:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
811406ac:	e0fffc03 	ldbu	r3,-16(fp)
811406b0:	d0a09e44 	addi	r2,gp,-32135
811406b4:	1885883a 	add	r2,r3,r2
811406b8:	10800003 	ldbu	r2,0(r2)
811406bc:	10803fcc 	andi	r2,r2,255
811406c0:	1000061e 	bne	r2,zero,811406dc <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
811406c4:	e0bffc43 	ldbu	r2,-15(fp)
811406c8:	0084303a 	nor	r2,zero,r2
811406cc:	1007883a 	mov	r3,r2
811406d0:	d0a09e03 	ldbu	r2,-32136(gp)
811406d4:	1884703a 	and	r2,r3,r2
811406d8:	d0a09e05 	stb	r2,-32136(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
811406dc:	d0e09e03 	ldbu	r3,-32136(gp)
811406e0:	e0bffb83 	ldbu	r2,-18(fp)
811406e4:	1884b03a 	or	r2,r3,r2
811406e8:	d0a09e05 	stb	r2,-32136(gp)
         OSRdyTbl[y_new] |= bitx_new;
811406ec:	e0fffb03 	ldbu	r3,-20(fp)
811406f0:	e13ffb03 	ldbu	r4,-20(fp)
811406f4:	d0a09e44 	addi	r2,gp,-32135
811406f8:	2085883a 	add	r2,r4,r2
811406fc:	11000003 	ldbu	r4,0(r2)
81140700:	e0bffbc3 	ldbu	r2,-17(fp)
81140704:	2084b03a 	or	r2,r4,r2
81140708:	1009883a 	mov	r4,r2
8114070c:	d0a09e44 	addi	r2,gp,-32135
81140710:	1885883a 	add	r2,r3,r2
81140714:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
81140718:	e0bff817 	ldw	r2,-32(fp)
8114071c:	10800717 	ldw	r2,28(r2)
81140720:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
81140724:	e0bff317 	ldw	r2,-52(fp)
81140728:	10003326 	beq	r2,zero,811407f8 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8114072c:	e0bffc03 	ldbu	r2,-16(fp)
81140730:	e0fffc03 	ldbu	r3,-16(fp)
81140734:	e13ff317 	ldw	r4,-52(fp)
81140738:	20c7883a 	add	r3,r4,r3
8114073c:	18c002c4 	addi	r3,r3,11
81140740:	18c00003 	ldbu	r3,0(r3)
81140744:	1809883a 	mov	r4,r3
81140748:	e0fffc83 	ldbu	r3,-14(fp)
8114074c:	00c6303a 	nor	r3,zero,r3
81140750:	20c6703a 	and	r3,r4,r3
81140754:	1809883a 	mov	r4,r3
81140758:	e0fff317 	ldw	r3,-52(fp)
8114075c:	1885883a 	add	r2,r3,r2
81140760:	108002c4 	addi	r2,r2,11
81140764:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
81140768:	e0bffc03 	ldbu	r2,-16(fp)
8114076c:	e0fff317 	ldw	r3,-52(fp)
81140770:	1885883a 	add	r2,r3,r2
81140774:	108002c4 	addi	r2,r2,11
81140778:	10800003 	ldbu	r2,0(r2)
8114077c:	10803fcc 	andi	r2,r2,255
81140780:	1000091e 	bne	r2,zero,811407a8 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
81140784:	e0bff317 	ldw	r2,-52(fp)
81140788:	10800283 	ldbu	r2,10(r2)
8114078c:	1007883a 	mov	r3,r2
81140790:	e0bffc43 	ldbu	r2,-15(fp)
81140794:	0084303a 	nor	r2,zero,r2
81140798:	1884703a 	and	r2,r3,r2
8114079c:	1007883a 	mov	r3,r2
811407a0:	e0bff317 	ldw	r2,-52(fp)
811407a4:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
811407a8:	e0bff317 	ldw	r2,-52(fp)
811407ac:	10c00283 	ldbu	r3,10(r2)
811407b0:	e0bffb83 	ldbu	r2,-18(fp)
811407b4:	1884b03a 	or	r2,r3,r2
811407b8:	1007883a 	mov	r3,r2
811407bc:	e0bff317 	ldw	r2,-52(fp)
811407c0:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
811407c4:	e0bffb03 	ldbu	r2,-20(fp)
811407c8:	e0fffb03 	ldbu	r3,-20(fp)
811407cc:	e13ff317 	ldw	r4,-52(fp)
811407d0:	20c7883a 	add	r3,r4,r3
811407d4:	18c002c4 	addi	r3,r3,11
811407d8:	19000003 	ldbu	r4,0(r3)
811407dc:	e0fffbc3 	ldbu	r3,-17(fp)
811407e0:	20c6b03a 	or	r3,r4,r3
811407e4:	1809883a 	mov	r4,r3
811407e8:	e0fff317 	ldw	r3,-52(fp)
811407ec:	1885883a 	add	r2,r3,r2
811407f0:	108002c4 	addi	r2,r2,11
811407f4:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
811407f8:	e0bff817 	ldw	r2,-32(fp)
811407fc:	10800817 	ldw	r2,32(r2)
81140800:	10004226 	beq	r2,zero,8114090c <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
81140804:	e0bff817 	ldw	r2,-32(fp)
81140808:	10800817 	ldw	r2,32(r2)
8114080c:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
81140810:	e0bff417 	ldw	r2,-48(fp)
81140814:	10800017 	ldw	r2,0(r2)
81140818:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8114081c:	00003906 	br	81140904 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
81140820:	e0bffc03 	ldbu	r2,-16(fp)
81140824:	e0fffc03 	ldbu	r3,-16(fp)
81140828:	e13ff317 	ldw	r4,-52(fp)
8114082c:	20c7883a 	add	r3,r4,r3
81140830:	18c002c4 	addi	r3,r3,11
81140834:	18c00003 	ldbu	r3,0(r3)
81140838:	1809883a 	mov	r4,r3
8114083c:	e0fffc83 	ldbu	r3,-14(fp)
81140840:	00c6303a 	nor	r3,zero,r3
81140844:	20c6703a 	and	r3,r4,r3
81140848:	1809883a 	mov	r4,r3
8114084c:	e0fff317 	ldw	r3,-52(fp)
81140850:	1885883a 	add	r2,r3,r2
81140854:	108002c4 	addi	r2,r2,11
81140858:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
8114085c:	e0bffc03 	ldbu	r2,-16(fp)
81140860:	e0fff317 	ldw	r3,-52(fp)
81140864:	1885883a 	add	r2,r3,r2
81140868:	108002c4 	addi	r2,r2,11
8114086c:	10800003 	ldbu	r2,0(r2)
81140870:	10803fcc 	andi	r2,r2,255
81140874:	1000091e 	bne	r2,zero,8114089c <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
81140878:	e0bff317 	ldw	r2,-52(fp)
8114087c:	10800283 	ldbu	r2,10(r2)
81140880:	1007883a 	mov	r3,r2
81140884:	e0bffc43 	ldbu	r2,-15(fp)
81140888:	0084303a 	nor	r2,zero,r2
8114088c:	1884703a 	and	r2,r3,r2
81140890:	1007883a 	mov	r3,r2
81140894:	e0bff317 	ldw	r2,-52(fp)
81140898:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8114089c:	e0bff317 	ldw	r2,-52(fp)
811408a0:	10c00283 	ldbu	r3,10(r2)
811408a4:	e0bffb83 	ldbu	r2,-18(fp)
811408a8:	1884b03a 	or	r2,r3,r2
811408ac:	1007883a 	mov	r3,r2
811408b0:	e0bff317 	ldw	r2,-52(fp)
811408b4:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
811408b8:	e0bffb03 	ldbu	r2,-20(fp)
811408bc:	e0fffb03 	ldbu	r3,-20(fp)
811408c0:	e13ff317 	ldw	r4,-52(fp)
811408c4:	20c7883a 	add	r3,r4,r3
811408c8:	18c002c4 	addi	r3,r3,11
811408cc:	19000003 	ldbu	r4,0(r3)
811408d0:	e0fffbc3 	ldbu	r3,-17(fp)
811408d4:	20c6b03a 	or	r3,r4,r3
811408d8:	1809883a 	mov	r4,r3
811408dc:	e0fff317 	ldw	r3,-52(fp)
811408e0:	1885883a 	add	r2,r3,r2
811408e4:	108002c4 	addi	r2,r2,11
811408e8:	11000005 	stb	r4,0(r2)
            pevents++;
811408ec:	e0bff417 	ldw	r2,-48(fp)
811408f0:	10800104 	addi	r2,r2,4
811408f4:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
811408f8:	e0bff417 	ldw	r2,-48(fp)
811408fc:	10800017 	ldw	r2,0(r2)
81140900:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
81140904:	e0bff317 	ldw	r2,-52(fp)
81140908:	103fc51e 	bne	r2,zero,81140820 <__reset+0xfb120820>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8114090c:	e0bff817 	ldw	r2,-32(fp)
81140910:	e0ffff03 	ldbu	r3,-4(fp)
81140914:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
81140918:	e0bff817 	ldw	r2,-32(fp)
8114091c:	e0fffb03 	ldbu	r3,-20(fp)
81140920:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
81140924:	e0bff817 	ldw	r2,-32(fp)
81140928:	e0fffb43 	ldbu	r3,-19(fp)
8114092c:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
81140930:	e0bff817 	ldw	r2,-32(fp)
81140934:	e0fffb83 	ldbu	r3,-18(fp)
81140938:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
8114093c:	e0bff817 	ldw	r2,-32(fp)
81140940:	e0fffbc3 	ldbu	r3,-17(fp)
81140944:	10c00d45 	stb	r3,53(r2)
81140948:	e0bff517 	ldw	r2,-44(fp)
8114094c:	e0bffa15 	stw	r2,-24(fp)
81140950:	e0bffa17 	ldw	r2,-24(fp)
81140954:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
81140958:	d0a09103 	ldbu	r2,-32188(gp)
8114095c:	10803fcc 	andi	r2,r2,255
81140960:	10800058 	cmpnei	r2,r2,1
81140964:	1000011e 	bne	r2,zero,8114096c <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
81140968:	113af1c0 	call	8113af1c <OS_Sched>
    }
    return (OS_ERR_NONE);
8114096c:	0005883a 	mov	r2,zero
}
81140970:	e037883a 	mov	sp,fp
81140974:	dfc00117 	ldw	ra,4(sp)
81140978:	df000017 	ldw	fp,0(sp)
8114097c:	dec00204 	addi	sp,sp,8
81140980:	f800283a 	ret

81140984 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
81140984:	deffee04 	addi	sp,sp,-72
81140988:	de00012e 	bgeu	sp,et,81140990 <OSTaskCreate+0xc>
8114098c:	003b68fa 	trap	3
81140990:	dfc01115 	stw	ra,68(sp)
81140994:	df001015 	stw	fp,64(sp)
81140998:	df001004 	addi	fp,sp,64
8114099c:	e13ffc15 	stw	r4,-16(fp)
811409a0:	e17ffd15 	stw	r5,-12(fp)
811409a4:	e1bffe15 	stw	r6,-8(fp)
811409a8:	3805883a 	mov	r2,r7
811409ac:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
811409b0:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
811409b4:	e0bfff03 	ldbu	r2,-4(fp)
811409b8:	10800af0 	cmpltui	r2,r2,43
811409bc:	1000021e 	bne	r2,zero,811409c8 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
811409c0:	00800a84 	movi	r2,42
811409c4:	00005706 	br	81140b24 <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811409c8:	0005303a 	rdctl	r2,status
811409cc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811409d0:	e0fffb17 	ldw	r3,-20(fp)
811409d4:	00bfff84 	movi	r2,-2
811409d8:	1884703a 	and	r2,r3,r2
811409dc:	1001703a 	wrctl	status,r2
  
  return context;
811409e0:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811409e4:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
811409e8:	d0a0a103 	ldbu	r2,-32124(gp)
811409ec:	10803fcc 	andi	r2,r2,255
811409f0:	10000626 	beq	r2,zero,81140a0c <OSTaskCreate+0x88>
811409f4:	e0bff317 	ldw	r2,-52(fp)
811409f8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811409fc:	e0bff417 	ldw	r2,-48(fp)
81140a00:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
81140a04:	00800f04 	movi	r2,60
81140a08:	00004606 	br	81140b24 <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
81140a0c:	e0ffff03 	ldbu	r3,-4(fp)
81140a10:	00a045f4 	movhi	r2,33047
81140a14:	10b7f904 	addi	r2,r2,-8220
81140a18:	18c7883a 	add	r3,r3,r3
81140a1c:	18c7883a 	add	r3,r3,r3
81140a20:	10c5883a 	add	r2,r2,r3
81140a24:	10800017 	ldw	r2,0(r2)
81140a28:	1000391e 	bne	r2,zero,81140b10 <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
81140a2c:	e0ffff03 	ldbu	r3,-4(fp)
81140a30:	00a045f4 	movhi	r2,33047
81140a34:	10b7f904 	addi	r2,r2,-8220
81140a38:	18c7883a 	add	r3,r3,r3
81140a3c:	18c7883a 	add	r3,r3,r3
81140a40:	10c5883a 	add	r2,r2,r3
81140a44:	00c00044 	movi	r3,1
81140a48:	10c00015 	stw	r3,0(r2)
81140a4c:	e0bff317 	ldw	r2,-52(fp)
81140a50:	e0bff515 	stw	r2,-44(fp)
81140a54:	e0bff517 	ldw	r2,-44(fp)
81140a58:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
81140a5c:	000f883a 	mov	r7,zero
81140a60:	e1bffe17 	ldw	r6,-8(fp)
81140a64:	e17ffd17 	ldw	r5,-12(fp)
81140a68:	e13ffc17 	ldw	r4,-16(fp)
81140a6c:	114c02c0 	call	8114c02c <OSTaskStkInit>
81140a70:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
81140a74:	e0bfff03 	ldbu	r2,-4(fp)
81140a78:	d8000215 	stw	zero,8(sp)
81140a7c:	d8000115 	stw	zero,4(sp)
81140a80:	d8000015 	stw	zero,0(sp)
81140a84:	000f883a 	mov	r7,zero
81140a88:	000d883a 	mov	r6,zero
81140a8c:	e17ff717 	ldw	r5,-36(fp)
81140a90:	1009883a 	mov	r4,r2
81140a94:	113b3640 	call	8113b364 <OS_TCBInit>
81140a98:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
81140a9c:	e0bff803 	ldbu	r2,-32(fp)
81140aa0:	1000061e 	bne	r2,zero,81140abc <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
81140aa4:	d0a09103 	ldbu	r2,-32188(gp)
81140aa8:	10803fcc 	andi	r2,r2,255
81140aac:	10800058 	cmpnei	r2,r2,1
81140ab0:	1000151e 	bne	r2,zero,81140b08 <OSTaskCreate+0x184>
                OS_Sched();
81140ab4:	113af1c0 	call	8113af1c <OS_Sched>
81140ab8:	00001306 	br	81140b08 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140abc:	0005303a 	rdctl	r2,status
81140ac0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140ac4:	e0fffa17 	ldw	r3,-24(fp)
81140ac8:	00bfff84 	movi	r2,-2
81140acc:	1884703a 	and	r2,r3,r2
81140ad0:	1001703a 	wrctl	status,r2
  
  return context;
81140ad4:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81140ad8:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
81140adc:	e0ffff03 	ldbu	r3,-4(fp)
81140ae0:	00a045f4 	movhi	r2,33047
81140ae4:	10b7f904 	addi	r2,r2,-8220
81140ae8:	18c7883a 	add	r3,r3,r3
81140aec:	18c7883a 	add	r3,r3,r3
81140af0:	10c5883a 	add	r2,r2,r3
81140af4:	10000015 	stw	zero,0(r2)
81140af8:	e0bff317 	ldw	r2,-52(fp)
81140afc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140b00:	e0bff617 	ldw	r2,-40(fp)
81140b04:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
81140b08:	e0bff803 	ldbu	r2,-32(fp)
81140b0c:	00000506 	br	81140b24 <OSTaskCreate+0x1a0>
81140b10:	e0bff317 	ldw	r2,-52(fp)
81140b14:	e0bff915 	stw	r2,-28(fp)
81140b18:	e0bff917 	ldw	r2,-28(fp)
81140b1c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
81140b20:	00800a04 	movi	r2,40
}
81140b24:	e037883a 	mov	sp,fp
81140b28:	dfc00117 	ldw	ra,4(sp)
81140b2c:	df000017 	ldw	fp,0(sp)
81140b30:	dec00204 	addi	sp,sp,8
81140b34:	f800283a 	ret

81140b38 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
81140b38:	deffec04 	addi	sp,sp,-80
81140b3c:	de00012e 	bgeu	sp,et,81140b44 <OSTaskCreateExt+0xc>
81140b40:	003b68fa 	trap	3
81140b44:	dfc01315 	stw	ra,76(sp)
81140b48:	df001215 	stw	fp,72(sp)
81140b4c:	df001204 	addi	fp,sp,72
81140b50:	e13ffa15 	stw	r4,-24(fp)
81140b54:	e17ffb15 	stw	r5,-20(fp)
81140b58:	e1bffc15 	stw	r6,-16(fp)
81140b5c:	3809883a 	mov	r4,r7
81140b60:	e0c00217 	ldw	r3,8(fp)
81140b64:	e0800617 	ldw	r2,24(fp)
81140b68:	e13ffd05 	stb	r4,-12(fp)
81140b6c:	e0fffe0d 	sth	r3,-8(fp)
81140b70:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
81140b74:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
81140b78:	e0bffd03 	ldbu	r2,-12(fp)
81140b7c:	10800af0 	cmpltui	r2,r2,43
81140b80:	1000021e 	bne	r2,zero,81140b8c <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
81140b84:	00800a84 	movi	r2,42
81140b88:	00006106 	br	81140d10 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140b8c:	0005303a 	rdctl	r2,status
81140b90:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140b94:	e0fff917 	ldw	r3,-28(fp)
81140b98:	00bfff84 	movi	r2,-2
81140b9c:	1884703a 	and	r2,r3,r2
81140ba0:	1001703a 	wrctl	status,r2
  
  return context;
81140ba4:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81140ba8:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
81140bac:	d0a0a103 	ldbu	r2,-32124(gp)
81140bb0:	10803fcc 	andi	r2,r2,255
81140bb4:	10000626 	beq	r2,zero,81140bd0 <OSTaskCreateExt+0x98>
81140bb8:	e0bff117 	ldw	r2,-60(fp)
81140bbc:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140bc0:	e0bff217 	ldw	r2,-56(fp)
81140bc4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
81140bc8:	00800f04 	movi	r2,60
81140bcc:	00005006 	br	81140d10 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
81140bd0:	e0fffd03 	ldbu	r3,-12(fp)
81140bd4:	00a045f4 	movhi	r2,33047
81140bd8:	10b7f904 	addi	r2,r2,-8220
81140bdc:	18c7883a 	add	r3,r3,r3
81140be0:	18c7883a 	add	r3,r3,r3
81140be4:	10c5883a 	add	r2,r2,r3
81140be8:	10800017 	ldw	r2,0(r2)
81140bec:	1000431e 	bne	r2,zero,81140cfc <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
81140bf0:	e0fffd03 	ldbu	r3,-12(fp)
81140bf4:	00a045f4 	movhi	r2,33047
81140bf8:	10b7f904 	addi	r2,r2,-8220
81140bfc:	18c7883a 	add	r3,r3,r3
81140c00:	18c7883a 	add	r3,r3,r3
81140c04:	10c5883a 	add	r2,r2,r3
81140c08:	00c00044 	movi	r3,1
81140c0c:	10c00015 	stw	r3,0(r2)
81140c10:	e0bff117 	ldw	r2,-60(fp)
81140c14:	e0bff315 	stw	r2,-52(fp)
81140c18:	e0bff317 	ldw	r2,-52(fp)
81140c1c:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
81140c20:	e0bfff0b 	ldhu	r2,-4(fp)
81140c24:	100d883a 	mov	r6,r2
81140c28:	e1400417 	ldw	r5,16(fp)
81140c2c:	e1000317 	ldw	r4,12(fp)
81140c30:	1141be00 	call	81141be0 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
81140c34:	e0bfff0b 	ldhu	r2,-4(fp)
81140c38:	100f883a 	mov	r7,r2
81140c3c:	e1bffc17 	ldw	r6,-16(fp)
81140c40:	e17ffb17 	ldw	r5,-20(fp)
81140c44:	e13ffa17 	ldw	r4,-24(fp)
81140c48:	114c02c0 	call	8114c02c <OSTaskStkInit>
81140c4c:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
81140c50:	e0fffd03 	ldbu	r3,-12(fp)
81140c54:	e13ffe0b 	ldhu	r4,-8(fp)
81140c58:	e0bfff0b 	ldhu	r2,-4(fp)
81140c5c:	d8800215 	stw	r2,8(sp)
81140c60:	e0800517 	ldw	r2,20(fp)
81140c64:	d8800115 	stw	r2,4(sp)
81140c68:	e0800417 	ldw	r2,16(fp)
81140c6c:	d8800015 	stw	r2,0(sp)
81140c70:	200f883a 	mov	r7,r4
81140c74:	e1800317 	ldw	r6,12(fp)
81140c78:	e17ff517 	ldw	r5,-44(fp)
81140c7c:	1809883a 	mov	r4,r3
81140c80:	113b3640 	call	8113b364 <OS_TCBInit>
81140c84:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
81140c88:	e0bff603 	ldbu	r2,-40(fp)
81140c8c:	1000061e 	bne	r2,zero,81140ca8 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
81140c90:	d0a09103 	ldbu	r2,-32188(gp)
81140c94:	10803fcc 	andi	r2,r2,255
81140c98:	10800058 	cmpnei	r2,r2,1
81140c9c:	1000151e 	bne	r2,zero,81140cf4 <OSTaskCreateExt+0x1bc>
                OS_Sched();
81140ca0:	113af1c0 	call	8113af1c <OS_Sched>
81140ca4:	00001306 	br	81140cf4 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140ca8:	0005303a 	rdctl	r2,status
81140cac:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140cb0:	e0fff817 	ldw	r3,-32(fp)
81140cb4:	00bfff84 	movi	r2,-2
81140cb8:	1884703a 	and	r2,r3,r2
81140cbc:	1001703a 	wrctl	status,r2
  
  return context;
81140cc0:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81140cc4:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
81140cc8:	e0fffd03 	ldbu	r3,-12(fp)
81140ccc:	00a045f4 	movhi	r2,33047
81140cd0:	10b7f904 	addi	r2,r2,-8220
81140cd4:	18c7883a 	add	r3,r3,r3
81140cd8:	18c7883a 	add	r3,r3,r3
81140cdc:	10c5883a 	add	r2,r2,r3
81140ce0:	10000015 	stw	zero,0(r2)
81140ce4:	e0bff117 	ldw	r2,-60(fp)
81140ce8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140cec:	e0bff417 	ldw	r2,-48(fp)
81140cf0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
81140cf4:	e0bff603 	ldbu	r2,-40(fp)
81140cf8:	00000506 	br	81140d10 <OSTaskCreateExt+0x1d8>
81140cfc:	e0bff117 	ldw	r2,-60(fp)
81140d00:	e0bff715 	stw	r2,-36(fp)
81140d04:	e0bff717 	ldw	r2,-36(fp)
81140d08:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
81140d0c:	00800a04 	movi	r2,40
}
81140d10:	e037883a 	mov	sp,fp
81140d14:	dfc00117 	ldw	ra,4(sp)
81140d18:	df000017 	ldw	fp,0(sp)
81140d1c:	dec00204 	addi	sp,sp,8
81140d20:	f800283a 	ret

81140d24 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
81140d24:	defff404 	addi	sp,sp,-48
81140d28:	de00012e 	bgeu	sp,et,81140d30 <OSTaskDel+0xc>
81140d2c:	003b68fa 	trap	3
81140d30:	dfc00b15 	stw	ra,44(sp)
81140d34:	df000a15 	stw	fp,40(sp)
81140d38:	df000a04 	addi	fp,sp,40
81140d3c:	2005883a 	mov	r2,r4
81140d40:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
81140d44:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
81140d48:	d0a0a103 	ldbu	r2,-32124(gp)
81140d4c:	10803fcc 	andi	r2,r2,255
81140d50:	10000226 	beq	r2,zero,81140d5c <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
81140d54:	00801004 	movi	r2,64
81140d58:	0000c006 	br	8114105c <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
81140d5c:	e0bfff03 	ldbu	r2,-4(fp)
81140d60:	10800a98 	cmpnei	r2,r2,42
81140d64:	1000021e 	bne	r2,zero,81140d70 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
81140d68:	00800f84 	movi	r2,62
81140d6c:	0000bb06 	br	8114105c <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
81140d70:	e0bfff03 	ldbu	r2,-4(fp)
81140d74:	10800ab0 	cmpltui	r2,r2,42
81140d78:	1000051e 	bne	r2,zero,81140d90 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
81140d7c:	e0bfff03 	ldbu	r2,-4(fp)
81140d80:	10803fe0 	cmpeqi	r2,r2,255
81140d84:	1000021e 	bne	r2,zero,81140d90 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
81140d88:	00800a84 	movi	r2,42
81140d8c:	0000b306 	br	8114105c <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140d90:	0005303a 	rdctl	r2,status
81140d94:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140d98:	e0fffe17 	ldw	r3,-8(fp)
81140d9c:	00bfff84 	movi	r2,-2
81140da0:	1884703a 	and	r2,r3,r2
81140da4:	1001703a 	wrctl	status,r2
  
  return context;
81140da8:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
81140dac:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
81140db0:	e0bfff03 	ldbu	r2,-4(fp)
81140db4:	10803fd8 	cmpnei	r2,r2,255
81140db8:	1000031e 	bne	r2,zero,81140dc8 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
81140dbc:	d0a0a217 	ldw	r2,-32120(gp)
81140dc0:	10800c83 	ldbu	r2,50(r2)
81140dc4:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81140dc8:	e0ffff03 	ldbu	r3,-4(fp)
81140dcc:	00a045f4 	movhi	r2,33047
81140dd0:	10b7f904 	addi	r2,r2,-8220
81140dd4:	18c7883a 	add	r3,r3,r3
81140dd8:	18c7883a 	add	r3,r3,r3
81140ddc:	10c5883a 	add	r2,r2,r3
81140de0:	10800017 	ldw	r2,0(r2)
81140de4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
81140de8:	e0bff817 	ldw	r2,-32(fp)
81140dec:	1000061e 	bne	r2,zero,81140e08 <OSTaskDel+0xe4>
81140df0:	e0bff617 	ldw	r2,-40(fp)
81140df4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140df8:	e0bff717 	ldw	r2,-36(fp)
81140dfc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81140e00:	008010c4 	movi	r2,67
81140e04:	00009506 	br	8114105c <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
81140e08:	e0bff817 	ldw	r2,-32(fp)
81140e0c:	10800058 	cmpnei	r2,r2,1
81140e10:	1000061e 	bne	r2,zero,81140e2c <OSTaskDel+0x108>
81140e14:	e0bff617 	ldw	r2,-40(fp)
81140e18:	e0bff915 	stw	r2,-28(fp)
81140e1c:	e0bff917 	ldw	r2,-28(fp)
81140e20:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81140e24:	00800f44 	movi	r2,61
81140e28:	00008c06 	br	8114105c <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
81140e2c:	e0bff817 	ldw	r2,-32(fp)
81140e30:	10800d03 	ldbu	r2,52(r2)
81140e34:	10c03fcc 	andi	r3,r2,255
81140e38:	e0bff817 	ldw	r2,-32(fp)
81140e3c:	10800d03 	ldbu	r2,52(r2)
81140e40:	11003fcc 	andi	r4,r2,255
81140e44:	d0a09e44 	addi	r2,gp,-32135
81140e48:	2085883a 	add	r2,r4,r2
81140e4c:	10800003 	ldbu	r2,0(r2)
81140e50:	1009883a 	mov	r4,r2
81140e54:	e0bff817 	ldw	r2,-32(fp)
81140e58:	10800d43 	ldbu	r2,53(r2)
81140e5c:	0084303a 	nor	r2,zero,r2
81140e60:	2084703a 	and	r2,r4,r2
81140e64:	1009883a 	mov	r4,r2
81140e68:	d0a09e44 	addi	r2,gp,-32135
81140e6c:	1885883a 	add	r2,r3,r2
81140e70:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
81140e74:	e0bff817 	ldw	r2,-32(fp)
81140e78:	10800d03 	ldbu	r2,52(r2)
81140e7c:	10c03fcc 	andi	r3,r2,255
81140e80:	d0a09e44 	addi	r2,gp,-32135
81140e84:	1885883a 	add	r2,r3,r2
81140e88:	10800003 	ldbu	r2,0(r2)
81140e8c:	10803fcc 	andi	r2,r2,255
81140e90:	1000071e 	bne	r2,zero,81140eb0 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
81140e94:	e0bff817 	ldw	r2,-32(fp)
81140e98:	10800d83 	ldbu	r2,54(r2)
81140e9c:	0084303a 	nor	r2,zero,r2
81140ea0:	1007883a 	mov	r3,r2
81140ea4:	d0a09e03 	ldbu	r2,-32136(gp)
81140ea8:	1884703a 	and	r2,r3,r2
81140eac:	d0a09e05 	stb	r2,-32136(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
81140eb0:	e0bff817 	ldw	r2,-32(fp)
81140eb4:	10800717 	ldw	r2,28(r2)
81140eb8:	10000526 	beq	r2,zero,81140ed0 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
81140ebc:	e0bff817 	ldw	r2,-32(fp)
81140ec0:	10800717 	ldw	r2,28(r2)
81140ec4:	100b883a 	mov	r5,r2
81140ec8:	e13ff817 	ldw	r4,-32(fp)
81140ecc:	113a8700 	call	8113a870 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
81140ed0:	e0bff817 	ldw	r2,-32(fp)
81140ed4:	10800817 	ldw	r2,32(r2)
81140ed8:	10000526 	beq	r2,zero,81140ef0 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81140edc:	e0bff817 	ldw	r2,-32(fp)
81140ee0:	10800817 	ldw	r2,32(r2)
81140ee4:	100b883a 	mov	r5,r2
81140ee8:	e13ff817 	ldw	r4,-32(fp)
81140eec:	113a9300 	call	8113a930 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
81140ef0:	e0bff817 	ldw	r2,-32(fp)
81140ef4:	10800a17 	ldw	r2,40(r2)
81140ef8:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
81140efc:	e0bffb17 	ldw	r2,-20(fp)
81140f00:	10000226 	beq	r2,zero,81140f0c <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
81140f04:	e13ffb17 	ldw	r4,-20(fp)
81140f08:	113cf080 	call	8113cf08 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
81140f0c:	e0bff817 	ldw	r2,-32(fp)
81140f10:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
81140f14:	e0bff817 	ldw	r2,-32(fp)
81140f18:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81140f1c:	e0bff817 	ldw	r2,-32(fp)
81140f20:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
81140f24:	d0a08f03 	ldbu	r2,-32196(gp)
81140f28:	10803fcc 	andi	r2,r2,255
81140f2c:	10803fe0 	cmpeqi	r2,r2,255
81140f30:	1000031e 	bne	r2,zero,81140f40 <OSTaskDel+0x21c>
        OSLockNesting++;
81140f34:	d0a08f03 	ldbu	r2,-32196(gp)
81140f38:	10800044 	addi	r2,r2,1
81140f3c:	d0a08f05 	stb	r2,-32196(gp)
81140f40:	e0bff617 	ldw	r2,-40(fp)
81140f44:	e0bffd15 	stw	r2,-12(fp)
81140f48:	e0bffd17 	ldw	r2,-12(fp)
81140f4c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
81140f50:	113a4380 	call	8113a438 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140f54:	0005303a 	rdctl	r2,status
81140f58:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140f5c:	e0fffa17 	ldw	r3,-24(fp)
81140f60:	00bfff84 	movi	r2,-2
81140f64:	1884703a 	and	r2,r3,r2
81140f68:	1001703a 	wrctl	status,r2
  
  return context;
81140f6c:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
81140f70:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
81140f74:	d0a08f03 	ldbu	r2,-32196(gp)
81140f78:	10803fcc 	andi	r2,r2,255
81140f7c:	10000326 	beq	r2,zero,81140f8c <OSTaskDel+0x268>
        OSLockNesting--;
81140f80:	d0a08f03 	ldbu	r2,-32196(gp)
81140f84:	10bfffc4 	addi	r2,r2,-1
81140f88:	d0a08f05 	stb	r2,-32196(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
81140f8c:	e13ff817 	ldw	r4,-32(fp)
81140f90:	114c1bc0 	call	8114c1bc <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
81140f94:	d0a09a43 	ldbu	r2,-32151(gp)
81140f98:	10bfffc4 	addi	r2,r2,-1
81140f9c:	d0a09a45 	stb	r2,-32151(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
81140fa0:	e0ffff03 	ldbu	r3,-4(fp)
81140fa4:	00a045f4 	movhi	r2,33047
81140fa8:	10b7f904 	addi	r2,r2,-8220
81140fac:	18c7883a 	add	r3,r3,r3
81140fb0:	18c7883a 	add	r3,r3,r3
81140fb4:	10c5883a 	add	r2,r2,r3
81140fb8:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
81140fbc:	e0bff817 	ldw	r2,-32(fp)
81140fc0:	10800617 	ldw	r2,24(r2)
81140fc4:	1000071e 	bne	r2,zero,81140fe4 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
81140fc8:	e0bff817 	ldw	r2,-32(fp)
81140fcc:	10800517 	ldw	r2,20(r2)
81140fd0:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
81140fd4:	e0bff817 	ldw	r2,-32(fp)
81140fd8:	10800517 	ldw	r2,20(r2)
81140fdc:	d0a09415 	stw	r2,-32176(gp)
81140fe0:	00000a06 	br	8114100c <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
81140fe4:	e0bff817 	ldw	r2,-32(fp)
81140fe8:	10800617 	ldw	r2,24(r2)
81140fec:	e0fff817 	ldw	r3,-32(fp)
81140ff0:	18c00517 	ldw	r3,20(r3)
81140ff4:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
81140ff8:	e0bff817 	ldw	r2,-32(fp)
81140ffc:	10800517 	ldw	r2,20(r2)
81141000:	e0fff817 	ldw	r3,-32(fp)
81141004:	18c00617 	ldw	r3,24(r3)
81141008:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8114100c:	d0e09917 	ldw	r3,-32156(gp)
81141010:	e0bff817 	ldw	r2,-32(fp)
81141014:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
81141018:	e0bff817 	ldw	r2,-32(fp)
8114101c:	d0a09915 	stw	r2,-32156(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
81141020:	e0bff817 	ldw	r2,-32(fp)
81141024:	00c00fc4 	movi	r3,63
81141028:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8114102c:	e0bff817 	ldw	r2,-32(fp)
81141030:	10001345 	stb	zero,77(r2)
81141034:	e0bff617 	ldw	r2,-40(fp)
81141038:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114103c:	e0bffc17 	ldw	r2,-16(fp)
81141040:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
81141044:	d0a09103 	ldbu	r2,-32188(gp)
81141048:	10803fcc 	andi	r2,r2,255
8114104c:	10800058 	cmpnei	r2,r2,1
81141050:	1000011e 	bne	r2,zero,81141058 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
81141054:	113af1c0 	call	8113af1c <OS_Sched>
    }
    return (OS_ERR_NONE);
81141058:	0005883a 	mov	r2,zero
}
8114105c:	e037883a 	mov	sp,fp
81141060:	dfc00117 	ldw	ra,4(sp)
81141064:	df000017 	ldw	fp,0(sp)
81141068:	dec00204 	addi	sp,sp,8
8114106c:	f800283a 	ret

81141070 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
81141070:	defff504 	addi	sp,sp,-44
81141074:	de00012e 	bgeu	sp,et,8114107c <OSTaskDelReq+0xc>
81141078:	003b68fa 	trap	3
8114107c:	df000a15 	stw	fp,40(sp)
81141080:	df000a04 	addi	fp,sp,40
81141084:	2005883a 	mov	r2,r4
81141088:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8114108c:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
81141090:	e0bfff03 	ldbu	r2,-4(fp)
81141094:	10800a98 	cmpnei	r2,r2,42
81141098:	1000021e 	bne	r2,zero,811410a4 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8114109c:	00800f84 	movi	r2,62
811410a0:	00004506 	br	811411b8 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
811410a4:	e0bfff03 	ldbu	r2,-4(fp)
811410a8:	10800ab0 	cmpltui	r2,r2,42
811410ac:	1000051e 	bne	r2,zero,811410c4 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
811410b0:	e0bfff03 	ldbu	r2,-4(fp)
811410b4:	10803fe0 	cmpeqi	r2,r2,255
811410b8:	1000021e 	bne	r2,zero,811410c4 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
811410bc:	00800a84 	movi	r2,42
811410c0:	00003d06 	br	811411b8 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
811410c4:	e0bfff03 	ldbu	r2,-4(fp)
811410c8:	10803fd8 	cmpnei	r2,r2,255
811410cc:	1000111e 	bne	r2,zero,81141114 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811410d0:	0005303a 	rdctl	r2,status
811410d4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811410d8:	e0fff917 	ldw	r3,-28(fp)
811410dc:	00bfff84 	movi	r2,-2
811410e0:	1884703a 	and	r2,r3,r2
811410e4:	1001703a 	wrctl	status,r2
  
  return context;
811410e8:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
811410ec:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
811410f0:	d0a0a217 	ldw	r2,-32120(gp)
811410f4:	10800dc3 	ldbu	r2,55(r2)
811410f8:	e0bff805 	stb	r2,-32(fp)
811410fc:	e0bff617 	ldw	r2,-40(fp)
81141100:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141104:	e0bffe17 	ldw	r2,-8(fp)
81141108:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
8114110c:	e0bff803 	ldbu	r2,-32(fp)
81141110:	00002906 	br	811411b8 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141114:	0005303a 	rdctl	r2,status
81141118:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114111c:	e0fff717 	ldw	r3,-36(fp)
81141120:	00bfff84 	movi	r2,-2
81141124:	1884703a 	and	r2,r3,r2
81141128:	1001703a 	wrctl	status,r2
  
  return context;
8114112c:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
81141130:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
81141134:	e0ffff03 	ldbu	r3,-4(fp)
81141138:	00a045f4 	movhi	r2,33047
8114113c:	10b7f904 	addi	r2,r2,-8220
81141140:	18c7883a 	add	r3,r3,r3
81141144:	18c7883a 	add	r3,r3,r3
81141148:	10c5883a 	add	r2,r2,r3
8114114c:	10800017 	ldw	r2,0(r2)
81141150:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
81141154:	e0bffb17 	ldw	r2,-20(fp)
81141158:	1000061e 	bne	r2,zero,81141174 <OSTaskDelReq+0x104>
8114115c:	e0bff617 	ldw	r2,-40(fp)
81141160:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141164:	e0bffa17 	ldw	r2,-24(fp)
81141168:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8114116c:	008010c4 	movi	r2,67
81141170:	00001106 	br	811411b8 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
81141174:	e0bffb17 	ldw	r2,-20(fp)
81141178:	10800058 	cmpnei	r2,r2,1
8114117c:	1000061e 	bne	r2,zero,81141198 <OSTaskDelReq+0x128>
81141180:	e0bff617 	ldw	r2,-40(fp)
81141184:	e0bffc15 	stw	r2,-16(fp)
81141188:	e0bffc17 	ldw	r2,-16(fp)
8114118c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81141190:	00800f44 	movi	r2,61
81141194:	00000806 	br	811411b8 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
81141198:	e0bffb17 	ldw	r2,-20(fp)
8114119c:	00c00fc4 	movi	r3,63
811411a0:	10c00dc5 	stb	r3,55(r2)
811411a4:	e0bff617 	ldw	r2,-40(fp)
811411a8:	e0bffd15 	stw	r2,-12(fp)
811411ac:	e0bffd17 	ldw	r2,-12(fp)
811411b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811411b4:	0005883a 	mov	r2,zero
}
811411b8:	e037883a 	mov	sp,fp
811411bc:	df000017 	ldw	fp,0(sp)
811411c0:	dec00104 	addi	sp,sp,4
811411c4:	f800283a 	ret

811411c8 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
811411c8:	defff404 	addi	sp,sp,-48
811411cc:	de00012e 	bgeu	sp,et,811411d4 <OSTaskNameGet+0xc>
811411d0:	003b68fa 	trap	3
811411d4:	dfc00b15 	stw	ra,44(sp)
811411d8:	df000a15 	stw	fp,40(sp)
811411dc:	df000a04 	addi	fp,sp,40
811411e0:	2005883a 	mov	r2,r4
811411e4:	e17ffe15 	stw	r5,-8(fp)
811411e8:	e1bfff15 	stw	r6,-4(fp)
811411ec:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
811411f0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
811411f4:	e0bfff17 	ldw	r2,-4(fp)
811411f8:	1000021e 	bne	r2,zero,81141204 <OSTaskNameGet+0x3c>
        return (0);
811411fc:	0005883a 	mov	r2,zero
81141200:	00005406 	br	81141354 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
81141204:	e0bffd03 	ldbu	r2,-12(fp)
81141208:	10800af0 	cmpltui	r2,r2,43
8114120c:	1000081e 	bne	r2,zero,81141230 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
81141210:	e0bffd03 	ldbu	r2,-12(fp)
81141214:	10803fe0 	cmpeqi	r2,r2,255
81141218:	1000051e 	bne	r2,zero,81141230 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
8114121c:	e0bfff17 	ldw	r2,-4(fp)
81141220:	00c00a84 	movi	r3,42
81141224:	10c00005 	stb	r3,0(r2)
            return (0);
81141228:	0005883a 	mov	r2,zero
8114122c:	00004906 	br	81141354 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
81141230:	e0bffe17 	ldw	r2,-8(fp)
81141234:	1000051e 	bne	r2,zero,8114124c <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
81141238:	e0bfff17 	ldw	r2,-4(fp)
8114123c:	00c00304 	movi	r3,12
81141240:	10c00005 	stb	r3,0(r2)
        return (0);
81141244:	0005883a 	mov	r2,zero
81141248:	00004206 	br	81141354 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
8114124c:	d0a0a103 	ldbu	r2,-32124(gp)
81141250:	10803fcc 	andi	r2,r2,255
81141254:	10000526 	beq	r2,zero,8114126c <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
81141258:	e0bfff17 	ldw	r2,-4(fp)
8114125c:	00c00444 	movi	r3,17
81141260:	10c00005 	stb	r3,0(r2)
        return (0);
81141264:	0005883a 	mov	r2,zero
81141268:	00003a06 	br	81141354 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114126c:	0005303a 	rdctl	r2,status
81141270:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141274:	e0fffc17 	ldw	r3,-16(fp)
81141278:	00bfff84 	movi	r2,-2
8114127c:	1884703a 	and	r2,r3,r2
81141280:	1001703a 	wrctl	status,r2
  
  return context;
81141284:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81141288:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
8114128c:	e0bffd03 	ldbu	r2,-12(fp)
81141290:	10803fd8 	cmpnei	r2,r2,255
81141294:	1000031e 	bne	r2,zero,811412a4 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
81141298:	d0a0a217 	ldw	r2,-32120(gp)
8114129c:	10800c83 	ldbu	r2,50(r2)
811412a0:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811412a4:	e0fffd03 	ldbu	r3,-12(fp)
811412a8:	00a045f4 	movhi	r2,33047
811412ac:	10b7f904 	addi	r2,r2,-8220
811412b0:	18c7883a 	add	r3,r3,r3
811412b4:	18c7883a 	add	r3,r3,r3
811412b8:	10c5883a 	add	r2,r2,r3
811412bc:	10800017 	ldw	r2,0(r2)
811412c0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
811412c4:	e0bff817 	ldw	r2,-32(fp)
811412c8:	1000091e 	bne	r2,zero,811412f0 <OSTaskNameGet+0x128>
811412cc:	e0bff617 	ldw	r2,-40(fp)
811412d0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811412d4:	e0bff717 	ldw	r2,-36(fp)
811412d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
811412dc:	e0bfff17 	ldw	r2,-4(fp)
811412e0:	00c010c4 	movi	r3,67
811412e4:	10c00005 	stb	r3,0(r2)
        return (0);
811412e8:	0005883a 	mov	r2,zero
811412ec:	00001906 	br	81141354 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
811412f0:	e0bff817 	ldw	r2,-32(fp)
811412f4:	10800058 	cmpnei	r2,r2,1
811412f8:	1000091e 	bne	r2,zero,81141320 <OSTaskNameGet+0x158>
811412fc:	e0bff617 	ldw	r2,-40(fp)
81141300:	e0bff915 	stw	r2,-28(fp)
81141304:	e0bff917 	ldw	r2,-28(fp)
81141308:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
8114130c:	e0bfff17 	ldw	r2,-4(fp)
81141310:	00c010c4 	movi	r3,67
81141314:	10c00005 	stb	r3,0(r2)
        return (0);
81141318:	0005883a 	mov	r2,zero
8114131c:	00000d06 	br	81141354 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
81141320:	e0bff817 	ldw	r2,-32(fp)
81141324:	10801304 	addi	r2,r2,76
81141328:	100b883a 	mov	r5,r2
8114132c:	e13ffe17 	ldw	r4,-8(fp)
81141330:	113b0700 	call	8113b070 <OS_StrCopy>
81141334:	e0bffb05 	stb	r2,-20(fp)
81141338:	e0bff617 	ldw	r2,-40(fp)
8114133c:	e0bffa15 	stw	r2,-24(fp)
81141340:	e0bffa17 	ldw	r2,-24(fp)
81141344:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81141348:	e0bfff17 	ldw	r2,-4(fp)
8114134c:	10000005 	stb	zero,0(r2)
    return (len);
81141350:	e0bffb03 	ldbu	r2,-20(fp)
}
81141354:	e037883a 	mov	sp,fp
81141358:	dfc00117 	ldw	ra,4(sp)
8114135c:	df000017 	ldw	fp,0(sp)
81141360:	dec00204 	addi	sp,sp,8
81141364:	f800283a 	ret

81141368 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
81141368:	defff304 	addi	sp,sp,-52
8114136c:	de00012e 	bgeu	sp,et,81141374 <OSTaskNameSet+0xc>
81141370:	003b68fa 	trap	3
81141374:	dfc00c15 	stw	ra,48(sp)
81141378:	df000b15 	stw	fp,44(sp)
8114137c:	df000b04 	addi	fp,sp,44
81141380:	2005883a 	mov	r2,r4
81141384:	e17ffe15 	stw	r5,-8(fp)
81141388:	e1bfff15 	stw	r6,-4(fp)
8114138c:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
81141390:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
81141394:	e0bfff17 	ldw	r2,-4(fp)
81141398:	10005c26 	beq	r2,zero,8114150c <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
8114139c:	e0bffd03 	ldbu	r2,-12(fp)
811413a0:	10800af0 	cmpltui	r2,r2,43
811413a4:	1000071e 	bne	r2,zero,811413c4 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
811413a8:	e0bffd03 	ldbu	r2,-12(fp)
811413ac:	10803fe0 	cmpeqi	r2,r2,255
811413b0:	1000041e 	bne	r2,zero,811413c4 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
811413b4:	e0bfff17 	ldw	r2,-4(fp)
811413b8:	00c00a84 	movi	r3,42
811413bc:	10c00005 	stb	r3,0(r2)
            return;
811413c0:	00005306 	br	81141510 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
811413c4:	e0bffe17 	ldw	r2,-8(fp)
811413c8:	1000041e 	bne	r2,zero,811413dc <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
811413cc:	e0bfff17 	ldw	r2,-4(fp)
811413d0:	00c00304 	movi	r3,12
811413d4:	10c00005 	stb	r3,0(r2)
        return;
811413d8:	00004d06 	br	81141510 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
811413dc:	d0a0a103 	ldbu	r2,-32124(gp)
811413e0:	10803fcc 	andi	r2,r2,255
811413e4:	10000426 	beq	r2,zero,811413f8 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
811413e8:	e0bfff17 	ldw	r2,-4(fp)
811413ec:	00c00484 	movi	r3,18
811413f0:	10c00005 	stb	r3,0(r2)
        return;
811413f4:	00004606 	br	81141510 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811413f8:	0005303a 	rdctl	r2,status
811413fc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141400:	e0fffc17 	ldw	r3,-16(fp)
81141404:	00bfff84 	movi	r2,-2
81141408:	1884703a 	and	r2,r3,r2
8114140c:	1001703a 	wrctl	status,r2
  
  return context;
81141410:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81141414:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
81141418:	e0bffd03 	ldbu	r2,-12(fp)
8114141c:	10803fd8 	cmpnei	r2,r2,255
81141420:	1000031e 	bne	r2,zero,81141430 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
81141424:	d0a0a217 	ldw	r2,-32120(gp)
81141428:	10800c83 	ldbu	r2,50(r2)
8114142c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81141430:	e0fffd03 	ldbu	r3,-12(fp)
81141434:	00a045f4 	movhi	r2,33047
81141438:	10b7f904 	addi	r2,r2,-8220
8114143c:	18c7883a 	add	r3,r3,r3
81141440:	18c7883a 	add	r3,r3,r3
81141444:	10c5883a 	add	r2,r2,r3
81141448:	10800017 	ldw	r2,0(r2)
8114144c:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
81141450:	e0bff717 	ldw	r2,-36(fp)
81141454:	1000081e 	bne	r2,zero,81141478 <OSTaskNameSet+0x110>
81141458:	e0bff517 	ldw	r2,-44(fp)
8114145c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141460:	e0bff617 	ldw	r2,-40(fp)
81141464:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
81141468:	e0bfff17 	ldw	r2,-4(fp)
8114146c:	00c010c4 	movi	r3,67
81141470:	10c00005 	stb	r3,0(r2)
        return;
81141474:	00002606 	br	81141510 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
81141478:	e0bff717 	ldw	r2,-36(fp)
8114147c:	10800058 	cmpnei	r2,r2,1
81141480:	1000081e 	bne	r2,zero,811414a4 <OSTaskNameSet+0x13c>
81141484:	e0bff517 	ldw	r2,-44(fp)
81141488:	e0bff815 	stw	r2,-32(fp)
8114148c:	e0bff817 	ldw	r2,-32(fp)
81141490:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
81141494:	e0bfff17 	ldw	r2,-4(fp)
81141498:	00c010c4 	movi	r3,67
8114149c:	10c00005 	stb	r3,0(r2)
        return;
811414a0:	00001b06 	br	81141510 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
811414a4:	e13ffe17 	ldw	r4,-8(fp)
811414a8:	113b0ec0 	call	8113b0ec <OS_StrLen>
811414ac:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
811414b0:	e0bffa03 	ldbu	r2,-24(fp)
811414b4:	10800830 	cmpltui	r2,r2,32
811414b8:	1000081e 	bne	r2,zero,811414dc <OSTaskNameSet+0x174>
811414bc:	e0bff517 	ldw	r2,-44(fp)
811414c0:	e0bff915 	stw	r2,-28(fp)
811414c4:	e0bff917 	ldw	r2,-28(fp)
811414c8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
811414cc:	e0bfff17 	ldw	r2,-4(fp)
811414d0:	00c01044 	movi	r3,65
811414d4:	10c00005 	stb	r3,0(r2)
        return;
811414d8:	00000d06 	br	81141510 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
811414dc:	e0bff717 	ldw	r2,-36(fp)
811414e0:	10801304 	addi	r2,r2,76
811414e4:	e17ffe17 	ldw	r5,-8(fp)
811414e8:	1009883a 	mov	r4,r2
811414ec:	113b0700 	call	8113b070 <OS_StrCopy>
811414f0:	e0bff517 	ldw	r2,-44(fp)
811414f4:	e0bffb15 	stw	r2,-20(fp)
811414f8:	e0bffb17 	ldw	r2,-20(fp)
811414fc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81141500:	e0bfff17 	ldw	r2,-4(fp)
81141504:	10000005 	stb	zero,0(r2)
81141508:	00000106 	br	81141510 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
8114150c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81141510:	e037883a 	mov	sp,fp
81141514:	dfc00117 	ldw	ra,4(sp)
81141518:	df000017 	ldw	fp,0(sp)
8114151c:	dec00204 	addi	sp,sp,8
81141520:	f800283a 	ret

81141524 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
81141524:	defff404 	addi	sp,sp,-48
81141528:	de00012e 	bgeu	sp,et,81141530 <OSTaskResume+0xc>
8114152c:	003b68fa 	trap	3
81141530:	dfc00b15 	stw	ra,44(sp)
81141534:	df000a15 	stw	fp,40(sp)
81141538:	df000a04 	addi	fp,sp,40
8114153c:	2005883a 	mov	r2,r4
81141540:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
81141544:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
81141548:	e0bfff03 	ldbu	r2,-4(fp)
8114154c:	10800ab0 	cmpltui	r2,r2,42
81141550:	1000021e 	bne	r2,zero,8114155c <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81141554:	00800a84 	movi	r2,42
81141558:	00006406 	br	811416ec <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114155c:	0005303a 	rdctl	r2,status
81141560:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141564:	e0fffe17 	ldw	r3,-8(fp)
81141568:	00bfff84 	movi	r2,-2
8114156c:	1884703a 	and	r2,r3,r2
81141570:	1001703a 	wrctl	status,r2
  
  return context;
81141574:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81141578:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8114157c:	e0ffff03 	ldbu	r3,-4(fp)
81141580:	00a045f4 	movhi	r2,33047
81141584:	10b7f904 	addi	r2,r2,-8220
81141588:	18c7883a 	add	r3,r3,r3
8114158c:	18c7883a 	add	r3,r3,r3
81141590:	10c5883a 	add	r2,r2,r3
81141594:	10800017 	ldw	r2,0(r2)
81141598:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
8114159c:	e0bff817 	ldw	r2,-32(fp)
811415a0:	1000061e 	bne	r2,zero,811415bc <OSTaskResume+0x98>
811415a4:	e0bff617 	ldw	r2,-40(fp)
811415a8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811415ac:	e0bff717 	ldw	r2,-36(fp)
811415b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
811415b4:	00801184 	movi	r2,70
811415b8:	00004c06 	br	811416ec <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
811415bc:	e0bff817 	ldw	r2,-32(fp)
811415c0:	10800058 	cmpnei	r2,r2,1
811415c4:	1000061e 	bne	r2,zero,811415e0 <OSTaskResume+0xbc>
811415c8:	e0bff617 	ldw	r2,-40(fp)
811415cc:	e0bff915 	stw	r2,-28(fp)
811415d0:	e0bff917 	ldw	r2,-28(fp)
811415d4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
811415d8:	008010c4 	movi	r2,67
811415dc:	00004306 	br	811416ec <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
811415e0:	e0bff817 	ldw	r2,-32(fp)
811415e4:	10800c03 	ldbu	r2,48(r2)
811415e8:	10803fcc 	andi	r2,r2,255
811415ec:	1080020c 	andi	r2,r2,8
811415f0:	10003926 	beq	r2,zero,811416d8 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
811415f4:	e0bff817 	ldw	r2,-32(fp)
811415f8:	10c00c03 	ldbu	r3,48(r2)
811415fc:	00bffdc4 	movi	r2,-9
81141600:	1884703a 	and	r2,r3,r2
81141604:	1007883a 	mov	r3,r2
81141608:	e0bff817 	ldw	r2,-32(fp)
8114160c:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
81141610:	e0bff817 	ldw	r2,-32(fp)
81141614:	10800c03 	ldbu	r2,48(r2)
81141618:	10803fcc 	andi	r2,r2,255
8114161c:	1000281e 	bne	r2,zero,811416c0 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
81141620:	e0bff817 	ldw	r2,-32(fp)
81141624:	10800b8b 	ldhu	r2,46(r2)
81141628:	10bfffcc 	andi	r2,r2,65535
8114162c:	10001f1e 	bne	r2,zero,811416ac <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
81141630:	e0bff817 	ldw	r2,-32(fp)
81141634:	10c00d83 	ldbu	r3,54(r2)
81141638:	d0a09e03 	ldbu	r2,-32136(gp)
8114163c:	1884b03a 	or	r2,r3,r2
81141640:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81141644:	e0bff817 	ldw	r2,-32(fp)
81141648:	10800d03 	ldbu	r2,52(r2)
8114164c:	10c03fcc 	andi	r3,r2,255
81141650:	e0bff817 	ldw	r2,-32(fp)
81141654:	10800d03 	ldbu	r2,52(r2)
81141658:	11003fcc 	andi	r4,r2,255
8114165c:	d0a09e44 	addi	r2,gp,-32135
81141660:	2085883a 	add	r2,r4,r2
81141664:	11000003 	ldbu	r4,0(r2)
81141668:	e0bff817 	ldw	r2,-32(fp)
8114166c:	10800d43 	ldbu	r2,53(r2)
81141670:	2084b03a 	or	r2,r4,r2
81141674:	1009883a 	mov	r4,r2
81141678:	d0a09e44 	addi	r2,gp,-32135
8114167c:	1885883a 	add	r2,r3,r2
81141680:	11000005 	stb	r4,0(r2)
81141684:	e0bff617 	ldw	r2,-40(fp)
81141688:	e0bffa15 	stw	r2,-24(fp)
8114168c:	e0bffa17 	ldw	r2,-24(fp)
81141690:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
81141694:	d0a09103 	ldbu	r2,-32188(gp)
81141698:	10803fcc 	andi	r2,r2,255
8114169c:	10800058 	cmpnei	r2,r2,1
811416a0:	10000b1e 	bne	r2,zero,811416d0 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
811416a4:	113af1c0 	call	8113af1c <OS_Sched>
811416a8:	00000906 	br	811416d0 <OSTaskResume+0x1ac>
811416ac:	e0bff617 	ldw	r2,-40(fp)
811416b0:	e0bffb15 	stw	r2,-20(fp)
811416b4:	e0bffb17 	ldw	r2,-20(fp)
811416b8:	1001703a 	wrctl	status,r2
811416bc:	00000406 	br	811416d0 <OSTaskResume+0x1ac>
811416c0:	e0bff617 	ldw	r2,-40(fp)
811416c4:	e0bffc15 	stw	r2,-16(fp)
811416c8:	e0bffc17 	ldw	r2,-16(fp)
811416cc:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
811416d0:	0005883a 	mov	r2,zero
811416d4:	00000506 	br	811416ec <OSTaskResume+0x1c8>
811416d8:	e0bff617 	ldw	r2,-40(fp)
811416dc:	e0bffd15 	stw	r2,-12(fp)
811416e0:	e0bffd17 	ldw	r2,-12(fp)
811416e4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
811416e8:	00801104 	movi	r2,68
}
811416ec:	e037883a 	mov	sp,fp
811416f0:	dfc00117 	ldw	ra,4(sp)
811416f4:	df000017 	ldw	fp,0(sp)
811416f8:	dec00204 	addi	sp,sp,8
811416fc:	f800283a 	ret

81141700 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
81141700:	defff304 	addi	sp,sp,-52
81141704:	de00012e 	bgeu	sp,et,8114170c <OSTaskStkChk+0xc>
81141708:	003b68fa 	trap	3
8114170c:	df000c15 	stw	fp,48(sp)
81141710:	df000c04 	addi	fp,sp,48
81141714:	2005883a 	mov	r2,r4
81141718:	e17fff15 	stw	r5,-4(fp)
8114171c:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81141720:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
81141724:	e0bffe03 	ldbu	r2,-8(fp)
81141728:	10800af0 	cmpltui	r2,r2,43
8114172c:	1000051e 	bne	r2,zero,81141744 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
81141730:	e0bffe03 	ldbu	r2,-8(fp)
81141734:	10803fe0 	cmpeqi	r2,r2,255
81141738:	1000021e 	bne	r2,zero,81141744 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
8114173c:	00800a84 	movi	r2,42
81141740:	00005d06 	br	811418b8 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
81141744:	e0bfff17 	ldw	r2,-4(fp)
81141748:	1000021e 	bne	r2,zero,81141754 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
8114174c:	00800244 	movi	r2,9
81141750:	00005906 	br	811418b8 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
81141754:	e0bfff17 	ldw	r2,-4(fp)
81141758:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8114175c:	e0bfff17 	ldw	r2,-4(fp)
81141760:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141764:	0005303a 	rdctl	r2,status
81141768:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114176c:	e0fffd17 	ldw	r3,-12(fp)
81141770:	00bfff84 	movi	r2,-2
81141774:	1884703a 	and	r2,r3,r2
81141778:	1001703a 	wrctl	status,r2
  
  return context;
8114177c:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
81141780:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
81141784:	e0bffe03 	ldbu	r2,-8(fp)
81141788:	10803fd8 	cmpnei	r2,r2,255
8114178c:	1000031e 	bne	r2,zero,8114179c <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
81141790:	d0a0a217 	ldw	r2,-32120(gp)
81141794:	10800c83 	ldbu	r2,50(r2)
81141798:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8114179c:	e0fffe03 	ldbu	r3,-8(fp)
811417a0:	00a045f4 	movhi	r2,33047
811417a4:	10b7f904 	addi	r2,r2,-8220
811417a8:	18c7883a 	add	r3,r3,r3
811417ac:	18c7883a 	add	r3,r3,r3
811417b0:	10c5883a 	add	r2,r2,r3
811417b4:	10800017 	ldw	r2,0(r2)
811417b8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
811417bc:	e0bff817 	ldw	r2,-32(fp)
811417c0:	1000061e 	bne	r2,zero,811417dc <OSTaskStkChk+0xdc>
811417c4:	e0bff617 	ldw	r2,-40(fp)
811417c8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811417cc:	e0bff717 	ldw	r2,-36(fp)
811417d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
811417d4:	008010c4 	movi	r2,67
811417d8:	00003706 	br	811418b8 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
811417dc:	e0bff817 	ldw	r2,-32(fp)
811417e0:	10800058 	cmpnei	r2,r2,1
811417e4:	1000061e 	bne	r2,zero,81141800 <OSTaskStkChk+0x100>
811417e8:	e0bff617 	ldw	r2,-40(fp)
811417ec:	e0bff915 	stw	r2,-28(fp)
811417f0:	e0bff917 	ldw	r2,-28(fp)
811417f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
811417f8:	008010c4 	movi	r2,67
811417fc:	00002e06 	br	811418b8 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
81141800:	e0bff817 	ldw	r2,-32(fp)
81141804:	1080040b 	ldhu	r2,16(r2)
81141808:	10bfffcc 	andi	r2,r2,65535
8114180c:	1080004c 	andi	r2,r2,1
81141810:	1000061e 	bne	r2,zero,8114182c <OSTaskStkChk+0x12c>
81141814:	e0bff617 	ldw	r2,-40(fp)
81141818:	e0bffa15 	stw	r2,-24(fp)
8114181c:	e0bffa17 	ldw	r2,-24(fp)
81141820:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
81141824:	00801144 	movi	r2,69
81141828:	00002306 	br	811418b8 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8114182c:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
81141830:	e0bff817 	ldw	r2,-32(fp)
81141834:	10800317 	ldw	r2,12(r2)
81141838:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8114183c:	e0bff817 	ldw	r2,-32(fp)
81141840:	10800217 	ldw	r2,8(r2)
81141844:	e0bff415 	stw	r2,-48(fp)
81141848:	e0bff617 	ldw	r2,-40(fp)
8114184c:	e0bffb15 	stw	r2,-20(fp)
81141850:	e0bffb17 	ldw	r2,-20(fp)
81141854:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
81141858:	00000306 	br	81141868 <OSTaskStkChk+0x168>
        nfree++;
8114185c:	e0bff517 	ldw	r2,-44(fp)
81141860:	10800044 	addi	r2,r2,1
81141864:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
81141868:	e0bff417 	ldw	r2,-48(fp)
8114186c:	10c00104 	addi	r3,r2,4
81141870:	e0fff415 	stw	r3,-48(fp)
81141874:	10800017 	ldw	r2,0(r2)
81141878:	103ff826 	beq	r2,zero,8114185c <__reset+0xfb12185c>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8114187c:	e0bff517 	ldw	r2,-44(fp)
81141880:	1085883a 	add	r2,r2,r2
81141884:	1085883a 	add	r2,r2,r2
81141888:	1007883a 	mov	r3,r2
8114188c:	e0bfff17 	ldw	r2,-4(fp)
81141890:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
81141894:	e0fffc17 	ldw	r3,-16(fp)
81141898:	e0bff517 	ldw	r2,-44(fp)
8114189c:	1885c83a 	sub	r2,r3,r2
811418a0:	1085883a 	add	r2,r2,r2
811418a4:	1085883a 	add	r2,r2,r2
811418a8:	1007883a 	mov	r3,r2
811418ac:	e0bfff17 	ldw	r2,-4(fp)
811418b0:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
811418b4:	0005883a 	mov	r2,zero
}
811418b8:	e037883a 	mov	sp,fp
811418bc:	df000017 	ldw	fp,0(sp)
811418c0:	dec00104 	addi	sp,sp,4
811418c4:	f800283a 	ret

811418c8 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
811418c8:	defff504 	addi	sp,sp,-44
811418cc:	de00012e 	bgeu	sp,et,811418d4 <OSTaskSuspend+0xc>
811418d0:	003b68fa 	trap	3
811418d4:	dfc00a15 	stw	ra,40(sp)
811418d8:	df000915 	stw	fp,36(sp)
811418dc:	df000904 	addi	fp,sp,36
811418e0:	2005883a 	mov	r2,r4
811418e4:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811418e8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
811418ec:	e0bfff03 	ldbu	r2,-4(fp)
811418f0:	10800a98 	cmpnei	r2,r2,42
811418f4:	1000021e 	bne	r2,zero,81141900 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
811418f8:	008011c4 	movi	r2,71
811418fc:	00006806 	br	81141aa0 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
81141900:	e0bfff03 	ldbu	r2,-4(fp)
81141904:	10800ab0 	cmpltui	r2,r2,42
81141908:	1000051e 	bne	r2,zero,81141920 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
8114190c:	e0bfff03 	ldbu	r2,-4(fp)
81141910:	10803fe0 	cmpeqi	r2,r2,255
81141914:	1000021e 	bne	r2,zero,81141920 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
81141918:	00800a84 	movi	r2,42
8114191c:	00006006 	br	81141aa0 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141920:	0005303a 	rdctl	r2,status
81141924:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141928:	e0fffe17 	ldw	r3,-8(fp)
8114192c:	00bfff84 	movi	r2,-2
81141930:	1884703a 	and	r2,r3,r2
81141934:	1001703a 	wrctl	status,r2
  
  return context;
81141938:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
8114193c:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
81141940:	e0bfff03 	ldbu	r2,-4(fp)
81141944:	10803fd8 	cmpnei	r2,r2,255
81141948:	1000061e 	bne	r2,zero,81141964 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8114194c:	d0a0a217 	ldw	r2,-32120(gp)
81141950:	10800c83 	ldbu	r2,50(r2)
81141954:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
81141958:	00800044 	movi	r2,1
8114195c:	e0bff705 	stb	r2,-36(fp)
81141960:	00000906 	br	81141988 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
81141964:	d0a0a217 	ldw	r2,-32120(gp)
81141968:	10800c83 	ldbu	r2,50(r2)
8114196c:	10c03fcc 	andi	r3,r2,255
81141970:	e0bfff03 	ldbu	r2,-4(fp)
81141974:	1880031e 	bne	r3,r2,81141984 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
81141978:	00800044 	movi	r2,1
8114197c:	e0bff705 	stb	r2,-36(fp)
81141980:	00000106 	br	81141988 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
81141984:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81141988:	e0ffff03 	ldbu	r3,-4(fp)
8114198c:	00a045f4 	movhi	r2,33047
81141990:	10b7f904 	addi	r2,r2,-8220
81141994:	18c7883a 	add	r3,r3,r3
81141998:	18c7883a 	add	r3,r3,r3
8114199c:	10c5883a 	add	r2,r2,r3
811419a0:	10800017 	ldw	r2,0(r2)
811419a4:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
811419a8:	e0bffa17 	ldw	r2,-24(fp)
811419ac:	1000061e 	bne	r2,zero,811419c8 <OSTaskSuspend+0x100>
811419b0:	e0bff817 	ldw	r2,-32(fp)
811419b4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811419b8:	e0bff917 	ldw	r2,-28(fp)
811419bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
811419c0:	00801204 	movi	r2,72
811419c4:	00003606 	br	81141aa0 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
811419c8:	e0bffa17 	ldw	r2,-24(fp)
811419cc:	10800058 	cmpnei	r2,r2,1
811419d0:	1000061e 	bne	r2,zero,811419ec <OSTaskSuspend+0x124>
811419d4:	e0bff817 	ldw	r2,-32(fp)
811419d8:	e0bffb15 	stw	r2,-20(fp)
811419dc:	e0bffb17 	ldw	r2,-20(fp)
811419e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
811419e4:	008010c4 	movi	r2,67
811419e8:	00002d06 	br	81141aa0 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
811419ec:	e0bffa17 	ldw	r2,-24(fp)
811419f0:	10800d03 	ldbu	r2,52(r2)
811419f4:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
811419f8:	e0fffd03 	ldbu	r3,-12(fp)
811419fc:	e13ffd03 	ldbu	r4,-12(fp)
81141a00:	d0a09e44 	addi	r2,gp,-32135
81141a04:	2085883a 	add	r2,r4,r2
81141a08:	10800003 	ldbu	r2,0(r2)
81141a0c:	1009883a 	mov	r4,r2
81141a10:	e0bffa17 	ldw	r2,-24(fp)
81141a14:	10800d43 	ldbu	r2,53(r2)
81141a18:	0084303a 	nor	r2,zero,r2
81141a1c:	2084703a 	and	r2,r4,r2
81141a20:	1009883a 	mov	r4,r2
81141a24:	d0a09e44 	addi	r2,gp,-32135
81141a28:	1885883a 	add	r2,r3,r2
81141a2c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81141a30:	e0fffd03 	ldbu	r3,-12(fp)
81141a34:	d0a09e44 	addi	r2,gp,-32135
81141a38:	1885883a 	add	r2,r3,r2
81141a3c:	10800003 	ldbu	r2,0(r2)
81141a40:	10803fcc 	andi	r2,r2,255
81141a44:	1000071e 	bne	r2,zero,81141a64 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
81141a48:	e0bffa17 	ldw	r2,-24(fp)
81141a4c:	10800d83 	ldbu	r2,54(r2)
81141a50:	0084303a 	nor	r2,zero,r2
81141a54:	1007883a 	mov	r3,r2
81141a58:	d0a09e03 	ldbu	r2,-32136(gp)
81141a5c:	1884703a 	and	r2,r3,r2
81141a60:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
81141a64:	e0bffa17 	ldw	r2,-24(fp)
81141a68:	10800c03 	ldbu	r2,48(r2)
81141a6c:	10800214 	ori	r2,r2,8
81141a70:	1007883a 	mov	r3,r2
81141a74:	e0bffa17 	ldw	r2,-24(fp)
81141a78:	10c00c05 	stb	r3,48(r2)
81141a7c:	e0bff817 	ldw	r2,-32(fp)
81141a80:	e0bffc15 	stw	r2,-16(fp)
81141a84:	e0bffc17 	ldw	r2,-16(fp)
81141a88:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
81141a8c:	e0bff703 	ldbu	r2,-36(fp)
81141a90:	10800058 	cmpnei	r2,r2,1
81141a94:	1000011e 	bne	r2,zero,81141a9c <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
81141a98:	113af1c0 	call	8113af1c <OS_Sched>
    }
    return (OS_ERR_NONE);
81141a9c:	0005883a 	mov	r2,zero
}
81141aa0:	e037883a 	mov	sp,fp
81141aa4:	dfc00117 	ldw	ra,4(sp)
81141aa8:	df000017 	ldw	fp,0(sp)
81141aac:	dec00204 	addi	sp,sp,8
81141ab0:	f800283a 	ret

81141ab4 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
81141ab4:	defff604 	addi	sp,sp,-40
81141ab8:	de00012e 	bgeu	sp,et,81141ac0 <OSTaskQuery+0xc>
81141abc:	003b68fa 	trap	3
81141ac0:	dfc00915 	stw	ra,36(sp)
81141ac4:	df000815 	stw	fp,32(sp)
81141ac8:	df000804 	addi	fp,sp,32
81141acc:	2005883a 	mov	r2,r4
81141ad0:	e17fff15 	stw	r5,-4(fp)
81141ad4:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81141ad8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
81141adc:	e0bffe03 	ldbu	r2,-8(fp)
81141ae0:	10800af0 	cmpltui	r2,r2,43
81141ae4:	1000051e 	bne	r2,zero,81141afc <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
81141ae8:	e0bffe03 	ldbu	r2,-8(fp)
81141aec:	10803fe0 	cmpeqi	r2,r2,255
81141af0:	1000021e 	bne	r2,zero,81141afc <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
81141af4:	00800a84 	movi	r2,42
81141af8:	00003406 	br	81141bcc <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
81141afc:	e0bfff17 	ldw	r2,-4(fp)
81141b00:	1000021e 	bne	r2,zero,81141b0c <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
81141b04:	00800244 	movi	r2,9
81141b08:	00003006 	br	81141bcc <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141b0c:	0005303a 	rdctl	r2,status
81141b10:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141b14:	e0fffd17 	ldw	r3,-12(fp)
81141b18:	00bfff84 	movi	r2,-2
81141b1c:	1884703a 	and	r2,r3,r2
81141b20:	1001703a 	wrctl	status,r2
  
  return context;
81141b24:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81141b28:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
81141b2c:	e0bffe03 	ldbu	r2,-8(fp)
81141b30:	10803fd8 	cmpnei	r2,r2,255
81141b34:	1000031e 	bne	r2,zero,81141b44 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
81141b38:	d0a0a217 	ldw	r2,-32120(gp)
81141b3c:	10800c83 	ldbu	r2,50(r2)
81141b40:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81141b44:	e0fffe03 	ldbu	r3,-8(fp)
81141b48:	00a045f4 	movhi	r2,33047
81141b4c:	10b7f904 	addi	r2,r2,-8220
81141b50:	18c7883a 	add	r3,r3,r3
81141b54:	18c7883a 	add	r3,r3,r3
81141b58:	10c5883a 	add	r2,r2,r3
81141b5c:	10800017 	ldw	r2,0(r2)
81141b60:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
81141b64:	e0bffa17 	ldw	r2,-24(fp)
81141b68:	1000061e 	bne	r2,zero,81141b84 <OSTaskQuery+0xd0>
81141b6c:	e0bff817 	ldw	r2,-32(fp)
81141b70:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141b74:	e0bff917 	ldw	r2,-28(fp)
81141b78:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
81141b7c:	00800a44 	movi	r2,41
81141b80:	00001206 	br	81141bcc <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
81141b84:	e0bffa17 	ldw	r2,-24(fp)
81141b88:	10800058 	cmpnei	r2,r2,1
81141b8c:	1000061e 	bne	r2,zero,81141ba8 <OSTaskQuery+0xf4>
81141b90:	e0bff817 	ldw	r2,-32(fp)
81141b94:	e0bffb15 	stw	r2,-20(fp)
81141b98:	e0bffb17 	ldw	r2,-20(fp)
81141b9c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81141ba0:	008010c4 	movi	r2,67
81141ba4:	00000906 	br	81141bcc <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
81141ba8:	01801b04 	movi	r6,108
81141bac:	e17ffa17 	ldw	r5,-24(fp)
81141bb0:	e13fff17 	ldw	r4,-4(fp)
81141bb4:	113aeac0 	call	8113aeac <OS_MemCopy>
81141bb8:	e0bff817 	ldw	r2,-32(fp)
81141bbc:	e0bffc15 	stw	r2,-16(fp)
81141bc0:	e0bffc17 	ldw	r2,-16(fp)
81141bc4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81141bc8:	0005883a 	mov	r2,zero
}
81141bcc:	e037883a 	mov	sp,fp
81141bd0:	dfc00117 	ldw	ra,4(sp)
81141bd4:	df000017 	ldw	fp,0(sp)
81141bd8:	dec00204 	addi	sp,sp,8
81141bdc:	f800283a 	ret

81141be0 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
81141be0:	defffc04 	addi	sp,sp,-16
81141be4:	de00012e 	bgeu	sp,et,81141bec <OS_TaskStkClr+0xc>
81141be8:	003b68fa 	trap	3
81141bec:	df000315 	stw	fp,12(sp)
81141bf0:	df000304 	addi	fp,sp,12
81141bf4:	e13ffd15 	stw	r4,-12(fp)
81141bf8:	e17ffe15 	stw	r5,-8(fp)
81141bfc:	3005883a 	mov	r2,r6
81141c00:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
81141c04:	e0bfff0b 	ldhu	r2,-4(fp)
81141c08:	1080004c 	andi	r2,r2,1
81141c0c:	10000d26 	beq	r2,zero,81141c44 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
81141c10:	e0bfff0b 	ldhu	r2,-4(fp)
81141c14:	1080008c 	andi	r2,r2,2
81141c18:	10000a26 	beq	r2,zero,81141c44 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
81141c1c:	00000706 	br	81141c3c <OS_TaskStkClr+0x5c>
                size--;
81141c20:	e0bffe17 	ldw	r2,-8(fp)
81141c24:	10bfffc4 	addi	r2,r2,-1
81141c28:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
81141c2c:	e0bffd17 	ldw	r2,-12(fp)
81141c30:	10c00104 	addi	r3,r2,4
81141c34:	e0fffd15 	stw	r3,-12(fp)
81141c38:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
81141c3c:	e0bffe17 	ldw	r2,-8(fp)
81141c40:	103ff71e 	bne	r2,zero,81141c20 <__reset+0xfb121c20>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
81141c44:	0001883a 	nop
81141c48:	e037883a 	mov	sp,fp
81141c4c:	df000017 	ldw	fp,0(sp)
81141c50:	dec00104 	addi	sp,sp,4
81141c54:	f800283a 	ret

81141c58 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
81141c58:	defff904 	addi	sp,sp,-28
81141c5c:	de00012e 	bgeu	sp,et,81141c64 <OSTimeDly+0xc>
81141c60:	003b68fa 	trap	3
81141c64:	dfc00615 	stw	ra,24(sp)
81141c68:	df000515 	stw	fp,20(sp)
81141c6c:	df000504 	addi	fp,sp,20
81141c70:	2005883a 	mov	r2,r4
81141c74:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81141c78:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81141c7c:	d0a0a103 	ldbu	r2,-32124(gp)
81141c80:	10803fcc 	andi	r2,r2,255
81141c84:	1000311e 	bne	r2,zero,81141d4c <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
81141c88:	e0bfff0b 	ldhu	r2,-4(fp)
81141c8c:	10003026 	beq	r2,zero,81141d50 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141c90:	0005303a 	rdctl	r2,status
81141c94:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141c98:	e0fffe17 	ldw	r3,-8(fp)
81141c9c:	00bfff84 	movi	r2,-2
81141ca0:	1884703a 	and	r2,r3,r2
81141ca4:	1001703a 	wrctl	status,r2
  
  return context;
81141ca8:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
81141cac:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
81141cb0:	d0a0a217 	ldw	r2,-32120(gp)
81141cb4:	10800d03 	ldbu	r2,52(r2)
81141cb8:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
81141cbc:	e0fffd03 	ldbu	r3,-12(fp)
81141cc0:	e13ffd03 	ldbu	r4,-12(fp)
81141cc4:	d0a09e44 	addi	r2,gp,-32135
81141cc8:	2085883a 	add	r2,r4,r2
81141ccc:	10800003 	ldbu	r2,0(r2)
81141cd0:	1009883a 	mov	r4,r2
81141cd4:	d0a0a217 	ldw	r2,-32120(gp)
81141cd8:	10800d43 	ldbu	r2,53(r2)
81141cdc:	0084303a 	nor	r2,zero,r2
81141ce0:	2084703a 	and	r2,r4,r2
81141ce4:	1009883a 	mov	r4,r2
81141ce8:	d0a09e44 	addi	r2,gp,-32135
81141cec:	1885883a 	add	r2,r3,r2
81141cf0:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
81141cf4:	e0fffd03 	ldbu	r3,-12(fp)
81141cf8:	d0a09e44 	addi	r2,gp,-32135
81141cfc:	1885883a 	add	r2,r3,r2
81141d00:	10800003 	ldbu	r2,0(r2)
81141d04:	10803fcc 	andi	r2,r2,255
81141d08:	1000071e 	bne	r2,zero,81141d28 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81141d0c:	d0a0a217 	ldw	r2,-32120(gp)
81141d10:	10800d83 	ldbu	r2,54(r2)
81141d14:	0084303a 	nor	r2,zero,r2
81141d18:	1007883a 	mov	r3,r2
81141d1c:	d0a09e03 	ldbu	r2,-32136(gp)
81141d20:	1884703a 	and	r2,r3,r2
81141d24:	d0a09e05 	stb	r2,-32136(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
81141d28:	d0a0a217 	ldw	r2,-32120(gp)
81141d2c:	e0ffff0b 	ldhu	r3,-4(fp)
81141d30:	10c00b8d 	sth	r3,46(r2)
81141d34:	e0bffb17 	ldw	r2,-20(fp)
81141d38:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141d3c:	e0bffc17 	ldw	r2,-16(fp)
81141d40:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
81141d44:	113af1c0 	call	8113af1c <OS_Sched>
81141d48:	00000106 	br	81141d50 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
81141d4c:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
81141d50:	e037883a 	mov	sp,fp
81141d54:	dfc00117 	ldw	ra,4(sp)
81141d58:	df000017 	ldw	fp,0(sp)
81141d5c:	dec00204 	addi	sp,sp,8
81141d60:	f800283a 	ret

81141d64 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
81141d64:	defff804 	addi	sp,sp,-32
81141d68:	de00012e 	bgeu	sp,et,81141d70 <OSTimeDlyHMSM+0xc>
81141d6c:	003b68fa 	trap	3
81141d70:	dfc00715 	stw	ra,28(sp)
81141d74:	df000615 	stw	fp,24(sp)
81141d78:	df000604 	addi	fp,sp,24
81141d7c:	2015883a 	mov	r10,r4
81141d80:	2809883a 	mov	r4,r5
81141d84:	3007883a 	mov	r3,r6
81141d88:	3805883a 	mov	r2,r7
81141d8c:	e2bffc05 	stb	r10,-16(fp)
81141d90:	e13ffd05 	stb	r4,-12(fp)
81141d94:	e0fffe05 	stb	r3,-8(fp)
81141d98:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81141d9c:	d0a0a103 	ldbu	r2,-32124(gp)
81141da0:	10803fcc 	andi	r2,r2,255
81141da4:	10000226 	beq	r2,zero,81141db0 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
81141da8:	00801544 	movi	r2,85
81141dac:	00004106 	br	81141eb4 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
81141db0:	e0bffc03 	ldbu	r2,-16(fp)
81141db4:	1000081e 	bne	r2,zero,81141dd8 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
81141db8:	e0bffd03 	ldbu	r2,-12(fp)
81141dbc:	1000061e 	bne	r2,zero,81141dd8 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
81141dc0:	e0bffe03 	ldbu	r2,-8(fp)
81141dc4:	1000041e 	bne	r2,zero,81141dd8 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
81141dc8:	e0bfff0b 	ldhu	r2,-4(fp)
81141dcc:	1000021e 	bne	r2,zero,81141dd8 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
81141dd0:	00801504 	movi	r2,84
81141dd4:	00003706 	br	81141eb4 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
81141dd8:	e0bffd03 	ldbu	r2,-12(fp)
81141ddc:	10800f30 	cmpltui	r2,r2,60
81141de0:	1000021e 	bne	r2,zero,81141dec <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
81141de4:	00801444 	movi	r2,81
81141de8:	00003206 	br	81141eb4 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
81141dec:	e0bffe03 	ldbu	r2,-8(fp)
81141df0:	10800f30 	cmpltui	r2,r2,60
81141df4:	1000021e 	bne	r2,zero,81141e00 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
81141df8:	00801484 	movi	r2,82
81141dfc:	00002d06 	br	81141eb4 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
81141e00:	e0bfff0b 	ldhu	r2,-4(fp)
81141e04:	1080fa30 	cmpltui	r2,r2,1000
81141e08:	1000021e 	bne	r2,zero,81141e14 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
81141e0c:	008014c4 	movi	r2,83
81141e10:	00002806 	br	81141eb4 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81141e14:	e0bffc03 	ldbu	r2,-16(fp)
81141e18:	10c38424 	muli	r3,r2,3600
81141e1c:	e0bffd03 	ldbu	r2,-12(fp)
81141e20:	10800f24 	muli	r2,r2,60
81141e24:	1887883a 	add	r3,r3,r2
81141e28:	e0bffe03 	ldbu	r2,-8(fp)
81141e2c:	1885883a 	add	r2,r3,r2
81141e30:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
81141e34:	e0bfff0b 	ldhu	r2,-4(fp)
81141e38:	10c0fa24 	muli	r3,r2,1000
81141e3c:	008418b4 	movhi	r2,4194
81141e40:	109374c4 	addi	r2,r2,19923
81141e44:	188a383a 	mulxuu	r5,r3,r2
81141e48:	1885383a 	mul	r2,r3,r2
81141e4c:	1011883a 	mov	r8,r2
81141e50:	2813883a 	mov	r9,r5
81141e54:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81141e58:	2085883a 	add	r2,r4,r2
81141e5c:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
81141e60:	e0bffb17 	ldw	r2,-20(fp)
81141e64:	1004d43a 	srli	r2,r2,16
81141e68:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
81141e6c:	e0bffb17 	ldw	r2,-20(fp)
81141e70:	10bfffcc 	andi	r2,r2,65535
81141e74:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
81141e78:	e0bffb17 	ldw	r2,-20(fp)
81141e7c:	10bfffcc 	andi	r2,r2,65535
81141e80:	1009883a 	mov	r4,r2
81141e84:	1141c580 	call	81141c58 <OSTimeDly>
    while (loops > 0) {
81141e88:	00000706 	br	81141ea8 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
81141e8c:	01200014 	movui	r4,32768
81141e90:	1141c580 	call	81141c58 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
81141e94:	01200014 	movui	r4,32768
81141e98:	1141c580 	call	81141c58 <OSTimeDly>
        loops--;
81141e9c:	e0bffa0b 	ldhu	r2,-24(fp)
81141ea0:	10bfffc4 	addi	r2,r2,-1
81141ea4:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
81141ea8:	e0bffa0b 	ldhu	r2,-24(fp)
81141eac:	103ff71e 	bne	r2,zero,81141e8c <__reset+0xfb121e8c>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
81141eb0:	0005883a 	mov	r2,zero
}
81141eb4:	e037883a 	mov	sp,fp
81141eb8:	dfc00117 	ldw	ra,4(sp)
81141ebc:	df000017 	ldw	fp,0(sp)
81141ec0:	dec00204 	addi	sp,sp,8
81141ec4:	f800283a 	ret

81141ec8 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
81141ec8:	defff504 	addi	sp,sp,-44
81141ecc:	de00012e 	bgeu	sp,et,81141ed4 <OSTimeDlyResume+0xc>
81141ed0:	003b68fa 	trap	3
81141ed4:	dfc00a15 	stw	ra,40(sp)
81141ed8:	df000915 	stw	fp,36(sp)
81141edc:	df000904 	addi	fp,sp,36
81141ee0:	2005883a 	mov	r2,r4
81141ee4:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81141ee8:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
81141eec:	e0bfff03 	ldbu	r2,-4(fp)
81141ef0:	10800ab0 	cmpltui	r2,r2,42
81141ef4:	1000021e 	bne	r2,zero,81141f00 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81141ef8:	00800a84 	movi	r2,42
81141efc:	00006406 	br	81142090 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141f00:	0005303a 	rdctl	r2,status
81141f04:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141f08:	e0fffe17 	ldw	r3,-8(fp)
81141f0c:	00bfff84 	movi	r2,-2
81141f10:	1884703a 	and	r2,r3,r2
81141f14:	1001703a 	wrctl	status,r2
  
  return context;
81141f18:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81141f1c:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
81141f20:	e0ffff03 	ldbu	r3,-4(fp)
81141f24:	00a045f4 	movhi	r2,33047
81141f28:	10b7f904 	addi	r2,r2,-8220
81141f2c:	18c7883a 	add	r3,r3,r3
81141f30:	18c7883a 	add	r3,r3,r3
81141f34:	10c5883a 	add	r2,r2,r3
81141f38:	10800017 	ldw	r2,0(r2)
81141f3c:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
81141f40:	e0bff917 	ldw	r2,-28(fp)
81141f44:	1000061e 	bne	r2,zero,81141f60 <OSTimeDlyResume+0x98>
81141f48:	e0bff717 	ldw	r2,-36(fp)
81141f4c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141f50:	e0bff817 	ldw	r2,-32(fp)
81141f54:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81141f58:	008010c4 	movi	r2,67
81141f5c:	00004c06 	br	81142090 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81141f60:	e0bff917 	ldw	r2,-28(fp)
81141f64:	10800058 	cmpnei	r2,r2,1
81141f68:	1000061e 	bne	r2,zero,81141f84 <OSTimeDlyResume+0xbc>
81141f6c:	e0bff717 	ldw	r2,-36(fp)
81141f70:	e0bffa15 	stw	r2,-24(fp)
81141f74:	e0bffa17 	ldw	r2,-24(fp)
81141f78:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81141f7c:	008010c4 	movi	r2,67
81141f80:	00004306 	br	81142090 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
81141f84:	e0bff917 	ldw	r2,-28(fp)
81141f88:	10800b8b 	ldhu	r2,46(r2)
81141f8c:	10bfffcc 	andi	r2,r2,65535
81141f90:	1000061e 	bne	r2,zero,81141fac <OSTimeDlyResume+0xe4>
81141f94:	e0bff717 	ldw	r2,-36(fp)
81141f98:	e0bffb15 	stw	r2,-20(fp)
81141f9c:	e0bffb17 	ldw	r2,-20(fp)
81141fa0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
81141fa4:	00801404 	movi	r2,80
81141fa8:	00003906 	br	81142090 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
81141fac:	e0bff917 	ldw	r2,-28(fp)
81141fb0:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81141fb4:	e0bff917 	ldw	r2,-28(fp)
81141fb8:	10800c03 	ldbu	r2,48(r2)
81141fbc:	10803fcc 	andi	r2,r2,255
81141fc0:	10800dcc 	andi	r2,r2,55
81141fc4:	10000b26 	beq	r2,zero,81141ff4 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
81141fc8:	e0bff917 	ldw	r2,-28(fp)
81141fcc:	10c00c03 	ldbu	r3,48(r2)
81141fd0:	00bff204 	movi	r2,-56
81141fd4:	1884703a 	and	r2,r3,r2
81141fd8:	1007883a 	mov	r3,r2
81141fdc:	e0bff917 	ldw	r2,-28(fp)
81141fe0:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
81141fe4:	e0bff917 	ldw	r2,-28(fp)
81141fe8:	00c00044 	movi	r3,1
81141fec:	10c00c45 	stb	r3,49(r2)
81141ff0:	00000206 	br	81141ffc <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
81141ff4:	e0bff917 	ldw	r2,-28(fp)
81141ff8:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
81141ffc:	e0bff917 	ldw	r2,-28(fp)
81142000:	10800c03 	ldbu	r2,48(r2)
81142004:	10803fcc 	andi	r2,r2,255
81142008:	1080020c 	andi	r2,r2,8
8114200c:	10001b1e 	bne	r2,zero,8114207c <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
81142010:	e0bff917 	ldw	r2,-28(fp)
81142014:	10c00d83 	ldbu	r3,54(r2)
81142018:	d0a09e03 	ldbu	r2,-32136(gp)
8114201c:	1884b03a 	or	r2,r3,r2
81142020:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81142024:	e0bff917 	ldw	r2,-28(fp)
81142028:	10800d03 	ldbu	r2,52(r2)
8114202c:	10c03fcc 	andi	r3,r2,255
81142030:	e0bff917 	ldw	r2,-28(fp)
81142034:	10800d03 	ldbu	r2,52(r2)
81142038:	11003fcc 	andi	r4,r2,255
8114203c:	d0a09e44 	addi	r2,gp,-32135
81142040:	2085883a 	add	r2,r4,r2
81142044:	11000003 	ldbu	r4,0(r2)
81142048:	e0bff917 	ldw	r2,-28(fp)
8114204c:	10800d43 	ldbu	r2,53(r2)
81142050:	2084b03a 	or	r2,r4,r2
81142054:	1009883a 	mov	r4,r2
81142058:	d0a09e44 	addi	r2,gp,-32135
8114205c:	1885883a 	add	r2,r3,r2
81142060:	11000005 	stb	r4,0(r2)
81142064:	e0bff717 	ldw	r2,-36(fp)
81142068:	e0bffc15 	stw	r2,-16(fp)
8114206c:	e0bffc17 	ldw	r2,-16(fp)
81142070:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
81142074:	113af1c0 	call	8113af1c <OS_Sched>
81142078:	00000406 	br	8114208c <OSTimeDlyResume+0x1c4>
8114207c:	e0bff717 	ldw	r2,-36(fp)
81142080:	e0bffd15 	stw	r2,-12(fp)
81142084:	e0bffd17 	ldw	r2,-12(fp)
81142088:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
8114208c:	0005883a 	mov	r2,zero
}
81142090:	e037883a 	mov	sp,fp
81142094:	dfc00117 	ldw	ra,4(sp)
81142098:	df000017 	ldw	fp,0(sp)
8114209c:	dec00204 	addi	sp,sp,8
811420a0:	f800283a 	ret

811420a4 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
811420a4:	defffb04 	addi	sp,sp,-20
811420a8:	de00012e 	bgeu	sp,et,811420b0 <OSTimeGet+0xc>
811420ac:	003b68fa 	trap	3
811420b0:	df000415 	stw	fp,16(sp)
811420b4:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811420b8:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811420bc:	0005303a 	rdctl	r2,status
811420c0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811420c4:	e0fffe17 	ldw	r3,-8(fp)
811420c8:	00bfff84 	movi	r2,-2
811420cc:	1884703a 	and	r2,r3,r2
811420d0:	1001703a 	wrctl	status,r2
  
  return context;
811420d4:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
811420d8:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
811420dc:	d0a0a417 	ldw	r2,-32112(gp)
811420e0:	e0bffd15 	stw	r2,-12(fp)
811420e4:	e0bffc17 	ldw	r2,-16(fp)
811420e8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811420ec:	e0bfff17 	ldw	r2,-4(fp)
811420f0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
811420f4:	e0bffd17 	ldw	r2,-12(fp)
}
811420f8:	e037883a 	mov	sp,fp
811420fc:	df000017 	ldw	fp,0(sp)
81142100:	dec00104 	addi	sp,sp,4
81142104:	f800283a 	ret

81142108 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
81142108:	defffb04 	addi	sp,sp,-20
8114210c:	de00012e 	bgeu	sp,et,81142114 <OSTimeSet+0xc>
81142110:	003b68fa 	trap	3
81142114:	df000415 	stw	fp,16(sp)
81142118:	df000404 	addi	fp,sp,16
8114211c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81142120:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142124:	0005303a 	rdctl	r2,status
81142128:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114212c:	e0fffd17 	ldw	r3,-12(fp)
81142130:	00bfff84 	movi	r2,-2
81142134:	1884703a 	and	r2,r3,r2
81142138:	1001703a 	wrctl	status,r2
  
  return context;
8114213c:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
81142140:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
81142144:	e0bfff17 	ldw	r2,-4(fp)
81142148:	d0a0a415 	stw	r2,-32112(gp)
8114214c:	e0bffc17 	ldw	r2,-16(fp)
81142150:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142154:	e0bffe17 	ldw	r2,-8(fp)
81142158:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8114215c:	0001883a 	nop
81142160:	e037883a 	mov	sp,fp
81142164:	df000017 	ldw	fp,0(sp)
81142168:	dec00104 	addi	sp,sp,4
8114216c:	f800283a 	ret

81142170 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
81142170:	defff804 	addi	sp,sp,-32
81142174:	de00012e 	bgeu	sp,et,8114217c <OSTmrCreate+0xc>
81142178:	003b68fa 	trap	3
8114217c:	dfc00715 	stw	ra,28(sp)
81142180:	df000615 	stw	fp,24(sp)
81142184:	df000604 	addi	fp,sp,24
81142188:	e13ffc15 	stw	r4,-16(fp)
8114218c:	e17ffd15 	stw	r5,-12(fp)
81142190:	3005883a 	mov	r2,r6
81142194:	e1ffff15 	stw	r7,-4(fp)
81142198:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8114219c:	e0800417 	ldw	r2,16(fp)
811421a0:	1000021e 	bne	r2,zero,811421ac <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
811421a4:	0005883a 	mov	r2,zero
811421a8:	00005d06 	br	81142320 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
811421ac:	e0bffe03 	ldbu	r2,-8(fp)
811421b0:	10c00060 	cmpeqi	r3,r2,1
811421b4:	1800091e 	bne	r3,zero,811421dc <OSTmrCreate+0x6c>
811421b8:	108000a0 	cmpeqi	r2,r2,2
811421bc:	10000e26 	beq	r2,zero,811421f8 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
811421c0:	e0bffd17 	ldw	r2,-12(fp)
811421c4:	1000111e 	bne	r2,zero,8114220c <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
811421c8:	e0800417 	ldw	r2,16(fp)
811421cc:	00ffe0c4 	movi	r3,-125
811421d0:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
811421d4:	0005883a 	mov	r2,zero
811421d8:	00005106 	br	81142320 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
811421dc:	e0bffc17 	ldw	r2,-16(fp)
811421e0:	10000c1e 	bne	r2,zero,81142214 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
811421e4:	e0800417 	ldw	r2,16(fp)
811421e8:	00ffe084 	movi	r3,-126
811421ec:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
811421f0:	0005883a 	mov	r2,zero
811421f4:	00004a06 	br	81142320 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
811421f8:	e0800417 	ldw	r2,16(fp)
811421fc:	00ffe104 	movi	r3,-124
81142200:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
81142204:	0005883a 	mov	r2,zero
81142208:	00004506 	br	81142320 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
8114220c:	0001883a 	nop
81142210:	00000106 	br	81142218 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
81142214:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81142218:	d0a0a103 	ldbu	r2,-32124(gp)
8114221c:	10803fcc 	andi	r2,r2,255
81142220:	10000526 	beq	r2,zero,81142238 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
81142224:	e0800417 	ldw	r2,16(fp)
81142228:	00ffe2c4 	movi	r3,-117
8114222c:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81142230:	0005883a 	mov	r2,zero
81142234:	00003a06 	br	81142320 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
81142238:	11431280 	call	81143128 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
8114223c:	1142bc80 	call	81142bc8 <OSTmr_Alloc>
81142240:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
81142244:	e0bffa17 	ldw	r2,-24(fp)
81142248:	1000061e 	bne	r2,zero,81142264 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
8114224c:	114316c0 	call	8114316c <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
81142250:	e0800417 	ldw	r2,16(fp)
81142254:	00ffe184 	movi	r3,-122
81142258:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8114225c:	0005883a 	mov	r2,zero
81142260:	00002f06 	br	81142320 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
81142264:	e0bffa17 	ldw	r2,-24(fp)
81142268:	00c00044 	movi	r3,1
8114226c:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
81142270:	e0bffa17 	ldw	r2,-24(fp)
81142274:	e0fffc17 	ldw	r3,-16(fp)
81142278:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
8114227c:	e0bffa17 	ldw	r2,-24(fp)
81142280:	e0fffd17 	ldw	r3,-12(fp)
81142284:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
81142288:	e0bffa17 	ldw	r2,-24(fp)
8114228c:	e0fffe03 	ldbu	r3,-8(fp)
81142290:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
81142294:	e0bffa17 	ldw	r2,-24(fp)
81142298:	e0ffff17 	ldw	r3,-4(fp)
8114229c:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
811422a0:	e0bffa17 	ldw	r2,-24(fp)
811422a4:	e0c00217 	ldw	r3,8(fp)
811422a8:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
811422ac:	e0800317 	ldw	r2,12(fp)
811422b0:	10001726 	beq	r2,zero,81142310 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
811422b4:	e1000317 	ldw	r4,12(fp)
811422b8:	113b0ec0 	call	8113b0ec <OS_StrLen>
811422bc:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
811422c0:	e0bffb03 	ldbu	r2,-20(fp)
811422c4:	10800428 	cmpgeui	r2,r2,16
811422c8:	1000061e 	bne	r2,zero,811422e4 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
811422cc:	e0bffa17 	ldw	r2,-24(fp)
811422d0:	10800804 	addi	r2,r2,32
811422d4:	e1400317 	ldw	r5,12(fp)
811422d8:	1009883a 	mov	r4,r2
811422dc:	113b0700 	call	8113b070 <OS_StrCopy>
811422e0:	00000b06 	br	81142310 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
811422e4:	e0bffa17 	ldw	r2,-24(fp)
811422e8:	00c008c4 	movi	r3,35
811422ec:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
811422f0:	e0bffa17 	ldw	r2,-24(fp)
811422f4:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
811422f8:	e0800417 	ldw	r2,16(fp)
811422fc:	00ffe304 	movi	r3,-116
81142300:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
81142304:	114316c0 	call	8114316c <OSTmr_Unlock>
            return (ptmr);
81142308:	e0bffa17 	ldw	r2,-24(fp)
8114230c:	00000406 	br	81142320 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
81142310:	114316c0 	call	8114316c <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
81142314:	e0800417 	ldw	r2,16(fp)
81142318:	10000005 	stb	zero,0(r2)
    return (ptmr);
8114231c:	e0bffa17 	ldw	r2,-24(fp)
}
81142320:	e037883a 	mov	sp,fp
81142324:	dfc00117 	ldw	ra,4(sp)
81142328:	df000017 	ldw	fp,0(sp)
8114232c:	dec00204 	addi	sp,sp,8
81142330:	f800283a 	ret

81142334 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
81142334:	defffc04 	addi	sp,sp,-16
81142338:	de00012e 	bgeu	sp,et,81142340 <OSTmrDel+0xc>
8114233c:	003b68fa 	trap	3
81142340:	dfc00315 	stw	ra,12(sp)
81142344:	df000215 	stw	fp,8(sp)
81142348:	df000204 	addi	fp,sp,8
8114234c:	e13ffe15 	stw	r4,-8(fp)
81142350:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81142354:	e0bfff17 	ldw	r2,-4(fp)
81142358:	1000021e 	bne	r2,zero,81142364 <OSTmrDel+0x30>
        return (OS_FALSE);
8114235c:	0005883a 	mov	r2,zero
81142360:	00003f06 	br	81142460 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81142364:	e0bffe17 	ldw	r2,-8(fp)
81142368:	1000051e 	bne	r2,zero,81142380 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8114236c:	e0bfff17 	ldw	r2,-4(fp)
81142370:	00ffe284 	movi	r3,-118
81142374:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81142378:	0005883a 	mov	r2,zero
8114237c:	00003806 	br	81142460 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
81142380:	e0bffe17 	ldw	r2,-8(fp)
81142384:	10800003 	ldbu	r2,0(r2)
81142388:	10803fcc 	andi	r2,r2,255
8114238c:	10801920 	cmpeqi	r2,r2,100
81142390:	1000051e 	bne	r2,zero,811423a8 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81142394:	e0bfff17 	ldw	r2,-4(fp)
81142398:	00ffe244 	movi	r3,-119
8114239c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811423a0:	0005883a 	mov	r2,zero
811423a4:	00002e06 	br	81142460 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
811423a8:	d0a0a103 	ldbu	r2,-32124(gp)
811423ac:	10803fcc 	andi	r2,r2,255
811423b0:	10000526 	beq	r2,zero,811423c8 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
811423b4:	e0bfff17 	ldw	r2,-4(fp)
811423b8:	00ffe2c4 	movi	r3,-117
811423bc:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811423c0:	0005883a 	mov	r2,zero
811423c4:	00002606 	br	81142460 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
811423c8:	11431280 	call	81143128 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811423cc:	e0bffe17 	ldw	r2,-8(fp)
811423d0:	10800c43 	ldbu	r2,49(r2)
811423d4:	10803fcc 	andi	r2,r2,255
811423d8:	10c000c8 	cmpgei	r3,r2,3
811423dc:	1800031e 	bne	r3,zero,811423ec <OSTmrDel+0xb8>
811423e0:	00800d16 	blt	zero,r2,81142418 <OSTmrDel+0xe4>
811423e4:	10001326 	beq	r2,zero,81142434 <OSTmrDel+0x100>
811423e8:	00001806 	br	8114244c <OSTmrDel+0x118>
811423ec:	108000e0 	cmpeqi	r2,r2,3
811423f0:	10001626 	beq	r2,zero,8114244c <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
811423f4:	e13ffe17 	ldw	r4,-8(fp)
811423f8:	114302c0 	call	8114302c <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
811423fc:	e13ffe17 	ldw	r4,-8(fp)
81142400:	1142c3c0 	call	81142c3c <OSTmr_Free>
             OSTmr_Unlock();
81142404:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81142408:	e0bfff17 	ldw	r2,-4(fp)
8114240c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81142410:	00800044 	movi	r2,1
81142414:	00001206 	br	81142460 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81142418:	e13ffe17 	ldw	r4,-8(fp)
8114241c:	1142c3c0 	call	81142c3c <OSTmr_Free>
             OSTmr_Unlock();
81142420:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81142424:	e0bfff17 	ldw	r2,-4(fp)
81142428:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8114242c:	00800044 	movi	r2,1
81142430:	00000b06 	br	81142460 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
81142434:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81142438:	e0bfff17 	ldw	r2,-4(fp)
8114243c:	00ffe1c4 	movi	r3,-121
81142440:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81142444:	0005883a 	mov	r2,zero
81142448:	00000506 	br	81142460 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
8114244c:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81142450:	e0bfff17 	ldw	r2,-4(fp)
81142454:	00ffe344 	movi	r3,-115
81142458:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8114245c:	0005883a 	mov	r2,zero
    }
}
81142460:	e037883a 	mov	sp,fp
81142464:	dfc00117 	ldw	ra,4(sp)
81142468:	df000017 	ldw	fp,0(sp)
8114246c:	dec00204 	addi	sp,sp,8
81142470:	f800283a 	ret

81142474 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
81142474:	defffa04 	addi	sp,sp,-24
81142478:	de00012e 	bgeu	sp,et,81142480 <OSTmrNameGet+0xc>
8114247c:	003b68fa 	trap	3
81142480:	dfc00515 	stw	ra,20(sp)
81142484:	df000415 	stw	fp,16(sp)
81142488:	df000404 	addi	fp,sp,16
8114248c:	e13ffd15 	stw	r4,-12(fp)
81142490:	e17ffe15 	stw	r5,-8(fp)
81142494:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81142498:	e0bfff17 	ldw	r2,-4(fp)
8114249c:	1000021e 	bne	r2,zero,811424a8 <OSTmrNameGet+0x34>
        return (0);
811424a0:	0005883a 	mov	r2,zero
811424a4:	00003e06 	br	811425a0 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
811424a8:	e0bffe17 	ldw	r2,-8(fp)
811424ac:	1000051e 	bne	r2,zero,811424c4 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
811424b0:	e0bfff17 	ldw	r2,-4(fp)
811424b4:	00ffe204 	movi	r3,-120
811424b8:	10c00005 	stb	r3,0(r2)
        return (0);
811424bc:	0005883a 	mov	r2,zero
811424c0:	00003706 	br	811425a0 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
811424c4:	e0bffd17 	ldw	r2,-12(fp)
811424c8:	1000051e 	bne	r2,zero,811424e0 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
811424cc:	e0bfff17 	ldw	r2,-4(fp)
811424d0:	00ffe284 	movi	r3,-118
811424d4:	10c00005 	stb	r3,0(r2)
        return (0);
811424d8:	0005883a 	mov	r2,zero
811424dc:	00003006 	br	811425a0 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
811424e0:	e0bffd17 	ldw	r2,-12(fp)
811424e4:	10800003 	ldbu	r2,0(r2)
811424e8:	10803fcc 	andi	r2,r2,255
811424ec:	10801920 	cmpeqi	r2,r2,100
811424f0:	1000051e 	bne	r2,zero,81142508 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811424f4:	e0bfff17 	ldw	r2,-4(fp)
811424f8:	00ffe244 	movi	r3,-119
811424fc:	10c00005 	stb	r3,0(r2)
        return (0);
81142500:	0005883a 	mov	r2,zero
81142504:	00002606 	br	811425a0 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81142508:	d0a0a103 	ldbu	r2,-32124(gp)
8114250c:	10803fcc 	andi	r2,r2,255
81142510:	10000526 	beq	r2,zero,81142528 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
81142514:	e0bfff17 	ldw	r2,-4(fp)
81142518:	00c00444 	movi	r3,17
8114251c:	10c00005 	stb	r3,0(r2)
        return (0);
81142520:	0005883a 	mov	r2,zero
81142524:	00001e06 	br	811425a0 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
81142528:	11431280 	call	81143128 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8114252c:	e0bffd17 	ldw	r2,-12(fp)
81142530:	10800c43 	ldbu	r2,49(r2)
81142534:	10803fcc 	andi	r2,r2,255
81142538:	10000e26 	beq	r2,zero,81142574 <OSTmrNameGet+0x100>
8114253c:	10001316 	blt	r2,zero,8114258c <OSTmrNameGet+0x118>
81142540:	10800108 	cmpgei	r2,r2,4
81142544:	1000111e 	bne	r2,zero,8114258c <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
81142548:	e0bffd17 	ldw	r2,-12(fp)
8114254c:	10800804 	addi	r2,r2,32
81142550:	100b883a 	mov	r5,r2
81142554:	e13ffe17 	ldw	r4,-8(fp)
81142558:	113b0700 	call	8113b070 <OS_StrCopy>
8114255c:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
81142560:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81142564:	e0bfff17 	ldw	r2,-4(fp)
81142568:	10000005 	stb	zero,0(r2)
             return (len);
8114256c:	e0bffc03 	ldbu	r2,-16(fp)
81142570:	00000b06 	br	811425a0 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
81142574:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81142578:	e0bfff17 	ldw	r2,-4(fp)
8114257c:	00ffe1c4 	movi	r3,-121
81142580:	10c00005 	stb	r3,0(r2)
             return (0);
81142584:	0005883a 	mov	r2,zero
81142588:	00000506 	br	811425a0 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
8114258c:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81142590:	e0bfff17 	ldw	r2,-4(fp)
81142594:	00ffe344 	movi	r3,-115
81142598:	10c00005 	stb	r3,0(r2)
             return (0);
8114259c:	0005883a 	mov	r2,zero
    }
}
811425a0:	e037883a 	mov	sp,fp
811425a4:	dfc00117 	ldw	ra,4(sp)
811425a8:	df000017 	ldw	fp,0(sp)
811425ac:	dec00204 	addi	sp,sp,8
811425b0:	f800283a 	ret

811425b4 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
811425b4:	defffb04 	addi	sp,sp,-20
811425b8:	de00012e 	bgeu	sp,et,811425c0 <OSTmrRemainGet+0xc>
811425bc:	003b68fa 	trap	3
811425c0:	dfc00415 	stw	ra,16(sp)
811425c4:	df000315 	stw	fp,12(sp)
811425c8:	df000304 	addi	fp,sp,12
811425cc:	e13ffe15 	stw	r4,-8(fp)
811425d0:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
811425d4:	e0bfff17 	ldw	r2,-4(fp)
811425d8:	1000021e 	bne	r2,zero,811425e4 <OSTmrRemainGet+0x30>
        return (0);
811425dc:	0005883a 	mov	r2,zero
811425e0:	00005d06 	br	81142758 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
811425e4:	e0bffe17 	ldw	r2,-8(fp)
811425e8:	1000051e 	bne	r2,zero,81142600 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811425ec:	e0bfff17 	ldw	r2,-4(fp)
811425f0:	00ffe284 	movi	r3,-118
811425f4:	10c00005 	stb	r3,0(r2)
        return (0);
811425f8:	0005883a 	mov	r2,zero
811425fc:	00005606 	br	81142758 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81142600:	e0bffe17 	ldw	r2,-8(fp)
81142604:	10800003 	ldbu	r2,0(r2)
81142608:	10803fcc 	andi	r2,r2,255
8114260c:	10801920 	cmpeqi	r2,r2,100
81142610:	1000051e 	bne	r2,zero,81142628 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81142614:	e0bfff17 	ldw	r2,-4(fp)
81142618:	00ffe244 	movi	r3,-119
8114261c:	10c00005 	stb	r3,0(r2)
        return (0);
81142620:	0005883a 	mov	r2,zero
81142624:	00004c06 	br	81142758 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81142628:	d0a0a103 	ldbu	r2,-32124(gp)
8114262c:	10803fcc 	andi	r2,r2,255
81142630:	10000526 	beq	r2,zero,81142648 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81142634:	e0bfff17 	ldw	r2,-4(fp)
81142638:	00ffe2c4 	movi	r3,-117
8114263c:	10c00005 	stb	r3,0(r2)
        return (0);
81142640:	0005883a 	mov	r2,zero
81142644:	00004406 	br	81142758 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
81142648:	11431280 	call	81143128 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8114264c:	e0bffe17 	ldw	r2,-8(fp)
81142650:	10800c43 	ldbu	r2,49(r2)
81142654:	10803fcc 	andi	r2,r2,255
81142658:	10c00060 	cmpeqi	r3,r2,1
8114265c:	1800121e 	bne	r3,zero,811426a8 <OSTmrRemainGet+0xf4>
81142660:	10c00088 	cmpgei	r3,r2,2
81142664:	1800021e 	bne	r3,zero,81142670 <OSTmrRemainGet+0xbc>
81142668:	10003026 	beq	r2,zero,8114272c <OSTmrRemainGet+0x178>
8114266c:	00003506 	br	81142744 <OSTmrRemainGet+0x190>
81142670:	10c000a0 	cmpeqi	r3,r2,2
81142674:	1800281e 	bne	r3,zero,81142718 <OSTmrRemainGet+0x164>
81142678:	108000e0 	cmpeqi	r2,r2,3
8114267c:	10003126 	beq	r2,zero,81142744 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
81142680:	e0bffe17 	ldw	r2,-8(fp)
81142684:	10c00517 	ldw	r3,20(r2)
81142688:	d0a0a317 	ldw	r2,-32116(gp)
8114268c:	1885c83a 	sub	r2,r3,r2
81142690:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
81142694:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
81142698:	e0bfff17 	ldw	r2,-4(fp)
8114269c:	10000005 	stb	zero,0(r2)
             return (remain);
811426a0:	e0bffd17 	ldw	r2,-12(fp)
811426a4:	00002c06 	br	81142758 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
811426a8:	e0bffe17 	ldw	r2,-8(fp)
811426ac:	10800c03 	ldbu	r2,48(r2)
811426b0:	10803fcc 	andi	r2,r2,255
811426b4:	108000a0 	cmpeqi	r2,r2,2
811426b8:	10000e26 	beq	r2,zero,811426f4 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
811426bc:	e0bffe17 	ldw	r2,-8(fp)
811426c0:	10800617 	ldw	r2,24(r2)
811426c4:	1000041e 	bne	r2,zero,811426d8 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
811426c8:	e0bffe17 	ldw	r2,-8(fp)
811426cc:	10800717 	ldw	r2,28(r2)
811426d0:	e0bffd15 	stw	r2,-12(fp)
811426d4:	00000306 	br	811426e4 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
811426d8:	e0bffe17 	ldw	r2,-8(fp)
811426dc:	10800617 	ldw	r2,24(r2)
811426e0:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
811426e4:	114316c0 	call	8114316c <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
811426e8:	e0bfff17 	ldw	r2,-4(fp)
811426ec:	10000005 	stb	zero,0(r2)
                      break;
811426f0:	00000706 	br	81142710 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
811426f4:	e0bffe17 	ldw	r2,-8(fp)
811426f8:	10800617 	ldw	r2,24(r2)
811426fc:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
81142700:	114316c0 	call	8114316c <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81142704:	e0bfff17 	ldw	r2,-4(fp)
81142708:	10000005 	stb	zero,0(r2)
                      break;
8114270c:	0001883a 	nop
             }
             return (remain);
81142710:	e0bffd17 	ldw	r2,-12(fp)
81142714:	00001006 	br	81142758 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
81142718:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8114271c:	e0bfff17 	ldw	r2,-4(fp)
81142720:	10000005 	stb	zero,0(r2)
             return (0);
81142724:	0005883a 	mov	r2,zero
81142728:	00000b06 	br	81142758 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
8114272c:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81142730:	e0bfff17 	ldw	r2,-4(fp)
81142734:	00ffe1c4 	movi	r3,-121
81142738:	10c00005 	stb	r3,0(r2)
             return (0);
8114273c:	0005883a 	mov	r2,zero
81142740:	00000506 	br	81142758 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
81142744:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81142748:	e0bfff17 	ldw	r2,-4(fp)
8114274c:	00ffe344 	movi	r3,-115
81142750:	10c00005 	stb	r3,0(r2)
             return (0);
81142754:	0005883a 	mov	r2,zero
    }
}
81142758:	e037883a 	mov	sp,fp
8114275c:	dfc00117 	ldw	ra,4(sp)
81142760:	df000017 	ldw	fp,0(sp)
81142764:	dec00204 	addi	sp,sp,8
81142768:	f800283a 	ret

8114276c <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
8114276c:	defffb04 	addi	sp,sp,-20
81142770:	de00012e 	bgeu	sp,et,81142778 <OSTmrStateGet+0xc>
81142774:	003b68fa 	trap	3
81142778:	dfc00415 	stw	ra,16(sp)
8114277c:	df000315 	stw	fp,12(sp)
81142780:	df000304 	addi	fp,sp,12
81142784:	e13ffe15 	stw	r4,-8(fp)
81142788:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8114278c:	e0bfff17 	ldw	r2,-4(fp)
81142790:	1000021e 	bne	r2,zero,8114279c <OSTmrStateGet+0x30>
        return (0);
81142794:	0005883a 	mov	r2,zero
81142798:	00002a06 	br	81142844 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
8114279c:	e0bffe17 	ldw	r2,-8(fp)
811427a0:	1000051e 	bne	r2,zero,811427b8 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811427a4:	e0bfff17 	ldw	r2,-4(fp)
811427a8:	00ffe284 	movi	r3,-118
811427ac:	10c00005 	stb	r3,0(r2)
        return (0);
811427b0:	0005883a 	mov	r2,zero
811427b4:	00002306 	br	81142844 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
811427b8:	e0bffe17 	ldw	r2,-8(fp)
811427bc:	10800003 	ldbu	r2,0(r2)
811427c0:	10803fcc 	andi	r2,r2,255
811427c4:	10801920 	cmpeqi	r2,r2,100
811427c8:	1000051e 	bne	r2,zero,811427e0 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811427cc:	e0bfff17 	ldw	r2,-4(fp)
811427d0:	00ffe244 	movi	r3,-119
811427d4:	10c00005 	stb	r3,0(r2)
        return (0);
811427d8:	0005883a 	mov	r2,zero
811427dc:	00001906 	br	81142844 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
811427e0:	d0a0a103 	ldbu	r2,-32124(gp)
811427e4:	10803fcc 	andi	r2,r2,255
811427e8:	10000526 	beq	r2,zero,81142800 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
811427ec:	e0bfff17 	ldw	r2,-4(fp)
811427f0:	00ffe2c4 	movi	r3,-117
811427f4:	10c00005 	stb	r3,0(r2)
        return (0);
811427f8:	0005883a 	mov	r2,zero
811427fc:	00001106 	br	81142844 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
81142800:	11431280 	call	81143128 <OSTmr_Lock>
    state = ptmr->OSTmrState;
81142804:	e0bffe17 	ldw	r2,-8(fp)
81142808:	10800c43 	ldbu	r2,49(r2)
8114280c:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
81142810:	e0bffd03 	ldbu	r2,-12(fp)
81142814:	1005883a 	mov	r2,r2
81142818:	10800128 	cmpgeui	r2,r2,4
8114281c:	1000031e 	bne	r2,zero,8114282c <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
81142820:	e0bfff17 	ldw	r2,-4(fp)
81142824:	10000005 	stb	zero,0(r2)
             break;
81142828:	00000406 	br	8114283c <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
8114282c:	e0bfff17 	ldw	r2,-4(fp)
81142830:	00ffe344 	movi	r3,-115
81142834:	10c00005 	stb	r3,0(r2)
             break;
81142838:	0001883a 	nop
    }
    OSTmr_Unlock();
8114283c:	114316c0 	call	8114316c <OSTmr_Unlock>
    return (state);
81142840:	e0bffd03 	ldbu	r2,-12(fp)
}
81142844:	e037883a 	mov	sp,fp
81142848:	dfc00117 	ldw	ra,4(sp)
8114284c:	df000017 	ldw	fp,0(sp)
81142850:	dec00204 	addi	sp,sp,8
81142854:	f800283a 	ret

81142858 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
81142858:	defffc04 	addi	sp,sp,-16
8114285c:	de00012e 	bgeu	sp,et,81142864 <OSTmrStart+0xc>
81142860:	003b68fa 	trap	3
81142864:	dfc00315 	stw	ra,12(sp)
81142868:	df000215 	stw	fp,8(sp)
8114286c:	df000204 	addi	fp,sp,8
81142870:	e13ffe15 	stw	r4,-8(fp)
81142874:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81142878:	e0bfff17 	ldw	r2,-4(fp)
8114287c:	1000021e 	bne	r2,zero,81142888 <OSTmrStart+0x30>
        return (OS_FALSE);
81142880:	0005883a 	mov	r2,zero
81142884:	00004106 	br	8114298c <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
81142888:	e0bffe17 	ldw	r2,-8(fp)
8114288c:	1000051e 	bne	r2,zero,811428a4 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81142890:	e0bfff17 	ldw	r2,-4(fp)
81142894:	00ffe284 	movi	r3,-118
81142898:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8114289c:	0005883a 	mov	r2,zero
811428a0:	00003a06 	br	8114298c <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
811428a4:	e0bffe17 	ldw	r2,-8(fp)
811428a8:	10800003 	ldbu	r2,0(r2)
811428ac:	10803fcc 	andi	r2,r2,255
811428b0:	10801920 	cmpeqi	r2,r2,100
811428b4:	1000051e 	bne	r2,zero,811428cc <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811428b8:	e0bfff17 	ldw	r2,-4(fp)
811428bc:	00ffe244 	movi	r3,-119
811428c0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811428c4:	0005883a 	mov	r2,zero
811428c8:	00003006 	br	8114298c <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
811428cc:	d0a0a103 	ldbu	r2,-32124(gp)
811428d0:	10803fcc 	andi	r2,r2,255
811428d4:	10000526 	beq	r2,zero,811428ec <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
811428d8:	e0bfff17 	ldw	r2,-4(fp)
811428dc:	00ffe2c4 	movi	r3,-117
811428e0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811428e4:	0005883a 	mov	r2,zero
811428e8:	00002806 	br	8114298c <OSTmrStart+0x134>
    }
    OSTmr_Lock();
811428ec:	11431280 	call	81143128 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811428f0:	e0bffe17 	ldw	r2,-8(fp)
811428f4:	10800c43 	ldbu	r2,49(r2)
811428f8:	10803fcc 	andi	r2,r2,255
811428fc:	10c000c8 	cmpgei	r3,r2,3
81142900:	1800031e 	bne	r3,zero,81142910 <OSTmrStart+0xb8>
81142904:	00800e16 	blt	zero,r2,81142940 <OSTmrStart+0xe8>
81142908:	10001526 	beq	r2,zero,81142960 <OSTmrStart+0x108>
8114290c:	00001a06 	br	81142978 <OSTmrStart+0x120>
81142910:	108000e0 	cmpeqi	r2,r2,3
81142914:	10001826 	beq	r2,zero,81142978 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
81142918:	e13ffe17 	ldw	r4,-8(fp)
8114291c:	114302c0 	call	8114302c <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
81142920:	000b883a 	mov	r5,zero
81142924:	e13ffe17 	ldw	r4,-8(fp)
81142928:	1142edc0 	call	81142edc <OSTmr_Link>
             OSTmr_Unlock();
8114292c:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81142930:	e0bfff17 	ldw	r2,-4(fp)
81142934:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81142938:	00800044 	movi	r2,1
8114293c:	00001306 	br	8114298c <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
81142940:	000b883a 	mov	r5,zero
81142944:	e13ffe17 	ldw	r4,-8(fp)
81142948:	1142edc0 	call	81142edc <OSTmr_Link>
             OSTmr_Unlock();
8114294c:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81142950:	e0bfff17 	ldw	r2,-4(fp)
81142954:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81142958:	00800044 	movi	r2,1
8114295c:	00000b06 	br	8114298c <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
81142960:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81142964:	e0bfff17 	ldw	r2,-4(fp)
81142968:	00ffe1c4 	movi	r3,-121
8114296c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81142970:	0005883a 	mov	r2,zero
81142974:	00000506 	br	8114298c <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
81142978:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8114297c:	e0bfff17 	ldw	r2,-4(fp)
81142980:	00ffe344 	movi	r3,-115
81142984:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81142988:	0005883a 	mov	r2,zero
    }
}
8114298c:	e037883a 	mov	sp,fp
81142990:	dfc00117 	ldw	ra,4(sp)
81142994:	df000017 	ldw	fp,0(sp)
81142998:	dec00204 	addi	sp,sp,8
8114299c:	f800283a 	ret

811429a0 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
811429a0:	defff904 	addi	sp,sp,-28
811429a4:	de00012e 	bgeu	sp,et,811429ac <OSTmrStop+0xc>
811429a8:	003b68fa 	trap	3
811429ac:	dfc00615 	stw	ra,24(sp)
811429b0:	df000515 	stw	fp,20(sp)
811429b4:	df000504 	addi	fp,sp,20
811429b8:	e13ffc15 	stw	r4,-16(fp)
811429bc:	2805883a 	mov	r2,r5
811429c0:	e1bffe15 	stw	r6,-8(fp)
811429c4:	e1ffff15 	stw	r7,-4(fp)
811429c8:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
811429cc:	e0bfff17 	ldw	r2,-4(fp)
811429d0:	1000021e 	bne	r2,zero,811429dc <OSTmrStop+0x3c>
        return (OS_FALSE);
811429d4:	0005883a 	mov	r2,zero
811429d8:	00006606 	br	81142b74 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
811429dc:	e0bffc17 	ldw	r2,-16(fp)
811429e0:	1000051e 	bne	r2,zero,811429f8 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
811429e4:	e0bfff17 	ldw	r2,-4(fp)
811429e8:	00ffe284 	movi	r3,-118
811429ec:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811429f0:	0005883a 	mov	r2,zero
811429f4:	00005f06 	br	81142b74 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
811429f8:	e0bffc17 	ldw	r2,-16(fp)
811429fc:	10800003 	ldbu	r2,0(r2)
81142a00:	10803fcc 	andi	r2,r2,255
81142a04:	10801920 	cmpeqi	r2,r2,100
81142a08:	1000051e 	bne	r2,zero,81142a20 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81142a0c:	e0bfff17 	ldw	r2,-4(fp)
81142a10:	00ffe244 	movi	r3,-119
81142a14:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81142a18:	0005883a 	mov	r2,zero
81142a1c:	00005506 	br	81142b74 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
81142a20:	d0a0a103 	ldbu	r2,-32124(gp)
81142a24:	10803fcc 	andi	r2,r2,255
81142a28:	10000526 	beq	r2,zero,81142a40 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
81142a2c:	e0bfff17 	ldw	r2,-4(fp)
81142a30:	00ffe2c4 	movi	r3,-117
81142a34:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81142a38:	0005883a 	mov	r2,zero
81142a3c:	00004d06 	br	81142b74 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
81142a40:	11431280 	call	81143128 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81142a44:	e0bffc17 	ldw	r2,-16(fp)
81142a48:	10800c43 	ldbu	r2,49(r2)
81142a4c:	10803fcc 	andi	r2,r2,255
81142a50:	10c000c8 	cmpgei	r3,r2,3
81142a54:	1800031e 	bne	r3,zero,81142a64 <OSTmrStop+0xc4>
81142a58:	00803516 	blt	zero,r2,81142b30 <OSTmrStop+0x190>
81142a5c:	10003a26 	beq	r2,zero,81142b48 <OSTmrStop+0x1a8>
81142a60:	00003f06 	br	81142b60 <OSTmrStop+0x1c0>
81142a64:	108000e0 	cmpeqi	r2,r2,3
81142a68:	10003d26 	beq	r2,zero,81142b60 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
81142a6c:	e13ffc17 	ldw	r4,-16(fp)
81142a70:	114302c0 	call	8114302c <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
81142a74:	e0bfff17 	ldw	r2,-4(fp)
81142a78:	10000005 	stb	zero,0(r2)
             switch (opt) {
81142a7c:	e0bffd03 	ldbu	r2,-12(fp)
81142a80:	10c000e0 	cmpeqi	r3,r2,3
81142a84:	1800041e 	bne	r3,zero,81142a98 <OSTmrStop+0xf8>
81142a88:	10c00120 	cmpeqi	r3,r2,4
81142a8c:	1800121e 	bne	r3,zero,81142ad8 <OSTmrStop+0x138>
81142a90:	10002326 	beq	r2,zero,81142b20 <OSTmrStop+0x180>
81142a94:	00001e06 	br	81142b10 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81142a98:	e0bffc17 	ldw	r2,-16(fp)
81142a9c:	10800117 	ldw	r2,4(r2)
81142aa0:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81142aa4:	e0bffb17 	ldw	r2,-20(fp)
81142aa8:	10000726 	beq	r2,zero,81142ac8 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
81142aac:	e0bffc17 	ldw	r2,-16(fp)
81142ab0:	10c00217 	ldw	r3,8(r2)
81142ab4:	e0bffb17 	ldw	r2,-20(fp)
81142ab8:	180b883a 	mov	r5,r3
81142abc:	e13ffc17 	ldw	r4,-16(fp)
81142ac0:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81142ac4:	00001706 	br	81142b24 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81142ac8:	e0bfff17 	ldw	r2,-4(fp)
81142acc:	00ffe3c4 	movi	r3,-113
81142ad0:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81142ad4:	00001306 	br	81142b24 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81142ad8:	e0bffc17 	ldw	r2,-16(fp)
81142adc:	10800117 	ldw	r2,4(r2)
81142ae0:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81142ae4:	e0bffb17 	ldw	r2,-20(fp)
81142ae8:	10000526 	beq	r2,zero,81142b00 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
81142aec:	e0bffb17 	ldw	r2,-20(fp)
81142af0:	e17ffe17 	ldw	r5,-8(fp)
81142af4:	e13ffc17 	ldw	r4,-16(fp)
81142af8:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81142afc:	00000906 	br	81142b24 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81142b00:	e0bfff17 	ldw	r2,-4(fp)
81142b04:	00ffe3c4 	movi	r3,-113
81142b08:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81142b0c:	00000506 	br	81142b24 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
81142b10:	e0bfff17 	ldw	r2,-4(fp)
81142b14:	00ffe104 	movi	r3,-124
81142b18:	10c00005 	stb	r3,0(r2)
                     break;
81142b1c:	00000106 	br	81142b24 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
81142b20:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
81142b24:	114316c0 	call	8114316c <OSTmr_Unlock>
             return (OS_TRUE);
81142b28:	00800044 	movi	r2,1
81142b2c:	00001106 	br	81142b74 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
81142b30:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
81142b34:	e0bfff17 	ldw	r2,-4(fp)
81142b38:	00ffe384 	movi	r3,-114
81142b3c:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
81142b40:	00800044 	movi	r2,1
81142b44:	00000b06 	br	81142b74 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
81142b48:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81142b4c:	e0bfff17 	ldw	r2,-4(fp)
81142b50:	00ffe1c4 	movi	r3,-121
81142b54:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81142b58:	0005883a 	mov	r2,zero
81142b5c:	00000506 	br	81142b74 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
81142b60:	114316c0 	call	8114316c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81142b64:	e0bfff17 	ldw	r2,-4(fp)
81142b68:	00ffe344 	movi	r3,-115
81142b6c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81142b70:	0005883a 	mov	r2,zero
    }
}
81142b74:	e037883a 	mov	sp,fp
81142b78:	dfc00117 	ldw	ra,4(sp)
81142b7c:	df000017 	ldw	fp,0(sp)
81142b80:	dec00204 	addi	sp,sp,8
81142b84:	f800283a 	ret

81142b88 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
81142b88:	defffd04 	addi	sp,sp,-12
81142b8c:	de00012e 	bgeu	sp,et,81142b94 <OSTmrSignal+0xc>
81142b90:	003b68fa 	trap	3
81142b94:	dfc00215 	stw	ra,8(sp)
81142b98:	df000115 	stw	fp,4(sp)
81142b9c:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
81142ba0:	d0a09017 	ldw	r2,-32192(gp)
81142ba4:	1009883a 	mov	r4,r2
81142ba8:	11401540 	call	81140154 <OSSemPost>
81142bac:	e0bfff05 	stb	r2,-4(fp)
    return (err);
81142bb0:	e0bfff03 	ldbu	r2,-4(fp)
}
81142bb4:	e037883a 	mov	sp,fp
81142bb8:	dfc00117 	ldw	ra,4(sp)
81142bbc:	df000017 	ldw	fp,0(sp)
81142bc0:	dec00204 	addi	sp,sp,8
81142bc4:	f800283a 	ret

81142bc8 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
81142bc8:	defffe04 	addi	sp,sp,-8
81142bcc:	de00012e 	bgeu	sp,et,81142bd4 <OSTmr_Alloc+0xc>
81142bd0:	003b68fa 	trap	3
81142bd4:	df000115 	stw	fp,4(sp)
81142bd8:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
81142bdc:	d0a08e17 	ldw	r2,-32200(gp)
81142be0:	1000021e 	bne	r2,zero,81142bec <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
81142be4:	0005883a 	mov	r2,zero
81142be8:	00001006 	br	81142c2c <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
81142bec:	d0a08e17 	ldw	r2,-32200(gp)
81142bf0:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
81142bf4:	e0bfff17 	ldw	r2,-4(fp)
81142bf8:	10800317 	ldw	r2,12(r2)
81142bfc:	d0a08e15 	stw	r2,-32200(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
81142c00:	e0bfff17 	ldw	r2,-4(fp)
81142c04:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
81142c08:	e0bfff17 	ldw	r2,-4(fp)
81142c0c:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
81142c10:	d0a0930b 	ldhu	r2,-32180(gp)
81142c14:	10800044 	addi	r2,r2,1
81142c18:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree--;
81142c1c:	d0a0970b 	ldhu	r2,-32164(gp)
81142c20:	10bfffc4 	addi	r2,r2,-1
81142c24:	d0a0970d 	sth	r2,-32164(gp)
    return (ptmr);
81142c28:	e0bfff17 	ldw	r2,-4(fp)
}
81142c2c:	e037883a 	mov	sp,fp
81142c30:	df000017 	ldw	fp,0(sp)
81142c34:	dec00104 	addi	sp,sp,4
81142c38:	f800283a 	ret

81142c3c <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
81142c3c:	defffe04 	addi	sp,sp,-8
81142c40:	de00012e 	bgeu	sp,et,81142c48 <OSTmr_Free+0xc>
81142c44:	003b68fa 	trap	3
81142c48:	df000115 	stw	fp,4(sp)
81142c4c:	df000104 	addi	fp,sp,4
81142c50:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
81142c54:	e0bfff17 	ldw	r2,-4(fp)
81142c58:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
81142c5c:	e0bfff17 	ldw	r2,-4(fp)
81142c60:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
81142c64:	e0bfff17 	ldw	r2,-4(fp)
81142c68:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
81142c6c:	e0bfff17 	ldw	r2,-4(fp)
81142c70:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
81142c74:	e0bfff17 	ldw	r2,-4(fp)
81142c78:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
81142c7c:	e0bfff17 	ldw	r2,-4(fp)
81142c80:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
81142c84:	e0bfff17 	ldw	r2,-4(fp)
81142c88:	00c00fc4 	movi	r3,63
81142c8c:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
81142c90:	e0bfff17 	ldw	r2,-4(fp)
81142c94:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
81142c98:	e0bfff17 	ldw	r2,-4(fp)
81142c9c:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
81142ca0:	d0e08e17 	ldw	r3,-32200(gp)
81142ca4:	e0bfff17 	ldw	r2,-4(fp)
81142ca8:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
81142cac:	e0bfff17 	ldw	r2,-4(fp)
81142cb0:	d0a08e15 	stw	r2,-32200(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
81142cb4:	d0a0930b 	ldhu	r2,-32180(gp)
81142cb8:	10bfffc4 	addi	r2,r2,-1
81142cbc:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree++;
81142cc0:	d0a0970b 	ldhu	r2,-32164(gp)
81142cc4:	10800044 	addi	r2,r2,1
81142cc8:	d0a0970d 	sth	r2,-32164(gp)
}
81142ccc:	0001883a 	nop
81142cd0:	e037883a 	mov	sp,fp
81142cd4:	df000017 	ldw	fp,0(sp)
81142cd8:	dec00104 	addi	sp,sp,4
81142cdc:	f800283a 	ret

81142ce0 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
81142ce0:	defffa04 	addi	sp,sp,-24
81142ce4:	de00012e 	bgeu	sp,et,81142cec <OSTmr_Init+0xc>
81142ce8:	003b68fa 	trap	3
81142cec:	dfc00515 	stw	ra,20(sp)
81142cf0:	df000415 	stw	fp,16(sp)
81142cf4:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
81142cf8:	01406804 	movi	r5,416
81142cfc:	012045f4 	movhi	r4,33047
81142d00:	21221704 	addi	r4,r4,-30628
81142d04:	113ae500 	call	8113ae50 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
81142d08:	01400404 	movi	r5,16
81142d0c:	012045f4 	movhi	r4,33047
81142d10:	21200304 	addi	r4,r4,-32756
81142d14:	113ae500 	call	8113ae50 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
81142d18:	00a045f4 	movhi	r2,33047
81142d1c:	10a21704 	addi	r2,r2,-30628
81142d20:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
81142d24:	00a045f4 	movhi	r2,33047
81142d28:	10a22404 	addi	r2,r2,-30576
81142d2c:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81142d30:	e03ffc0d 	sth	zero,-16(fp)
81142d34:	00001606 	br	81142d90 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
81142d38:	e0bffd17 	ldw	r2,-12(fp)
81142d3c:	00c01904 	movi	r3,100
81142d40:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
81142d44:	e0bffd17 	ldw	r2,-12(fp)
81142d48:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
81142d4c:	e0bffd17 	ldw	r2,-12(fp)
81142d50:	e0fffe17 	ldw	r3,-8(fp)
81142d54:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
81142d58:	e0bffd17 	ldw	r2,-12(fp)
81142d5c:	00c00fc4 	movi	r3,63
81142d60:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81142d64:	e0bffd17 	ldw	r2,-12(fp)
81142d68:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
81142d6c:	e0bffd17 	ldw	r2,-12(fp)
81142d70:	10800d04 	addi	r2,r2,52
81142d74:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
81142d78:	e0bffe17 	ldw	r2,-8(fp)
81142d7c:	10800d04 	addi	r2,r2,52
81142d80:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81142d84:	e0bffc0b 	ldhu	r2,-16(fp)
81142d88:	10800044 	addi	r2,r2,1
81142d8c:	e0bffc0d 	sth	r2,-16(fp)
81142d90:	e0bffc0b 	ldhu	r2,-16(fp)
81142d94:	108001f0 	cmpltui	r2,r2,7
81142d98:	103fe71e 	bne	r2,zero,81142d38 <__reset+0xfb122d38>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
81142d9c:	e0bffd17 	ldw	r2,-12(fp)
81142da0:	00c01904 	movi	r3,100
81142da4:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
81142da8:	e0bffd17 	ldw	r2,-12(fp)
81142dac:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
81142db0:	e0bffd17 	ldw	r2,-12(fp)
81142db4:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
81142db8:	e0bffd17 	ldw	r2,-12(fp)
81142dbc:	00c00fc4 	movi	r3,63
81142dc0:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81142dc4:	e0bffd17 	ldw	r2,-12(fp)
81142dc8:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
81142dcc:	d020a315 	stw	zero,-32116(gp)
    OSTmrUsed           = 0;
81142dd0:	d020930d 	sth	zero,-32180(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
81142dd4:	00800204 	movi	r2,8
81142dd8:	d0a0970d 	sth	r2,-32164(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
81142ddc:	00a045f4 	movhi	r2,33047
81142de0:	10a21704 	addi	r2,r2,-30628
81142de4:	d0a08e15 	stw	r2,-32200(gp)
    OSTmrSem            = OSSemCreate(1);
81142de8:	01000044 	movi	r4,1
81142dec:	113faa40 	call	8113faa4 <OSSemCreate>
81142df0:	d0a0a515 	stw	r2,-32108(gp)
    OSTmrSemSignal      = OSSemCreate(0);
81142df4:	0009883a 	mov	r4,zero
81142df8:	113faa40 	call	8113faa4 <OSSemCreate>
81142dfc:	d0a09015 	stw	r2,-32192(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
81142e00:	d0a0a517 	ldw	r2,-32108(gp)
81142e04:	e0ffff04 	addi	r3,fp,-4
81142e08:	180d883a 	mov	r6,r3
81142e0c:	01604574 	movhi	r5,33045
81142e10:	2948c404 	addi	r5,r5,8976
81142e14:	1009883a 	mov	r4,r2
81142e18:	11396ac0 	call	811396ac <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
81142e1c:	d0a09017 	ldw	r2,-32192(gp)
81142e20:	e0ffff04 	addi	r3,fp,-4
81142e24:	180d883a 	mov	r6,r3
81142e28:	01604574 	movhi	r5,33045
81142e2c:	2948c904 	addi	r5,r5,8996
81142e30:	1009883a 	mov	r4,r2
81142e34:	11396ac0 	call	811396ac <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
81142e38:	1142e540 	call	81142e54 <OSTmr_InitTask>
}
81142e3c:	0001883a 	nop
81142e40:	e037883a 	mov	sp,fp
81142e44:	dfc00117 	ldw	ra,4(sp)
81142e48:	df000017 	ldw	fp,0(sp)
81142e4c:	dec00204 	addi	sp,sp,8
81142e50:	f800283a 	ret

81142e54 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
81142e54:	defff804 	addi	sp,sp,-32
81142e58:	de00012e 	bgeu	sp,et,81142e60 <OSTmr_InitTask+0xc>
81142e5c:	003b68fa 	trap	3
81142e60:	dfc00715 	stw	ra,28(sp)
81142e64:	df000615 	stw	fp,24(sp)
81142e68:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
81142e6c:	008000c4 	movi	r2,3
81142e70:	d8800415 	stw	r2,16(sp)
81142e74:	d8000315 	stw	zero,12(sp)
81142e78:	00808004 	movi	r2,512
81142e7c:	d8800215 	stw	r2,8(sp)
81142e80:	00a045f4 	movhi	r2,33047
81142e84:	10aa4b04 	addi	r2,r2,-22228
81142e88:	d8800115 	stw	r2,4(sp)
81142e8c:	00bfff54 	movui	r2,65533
81142e90:	d8800015 	stw	r2,0(sp)
81142e94:	01c00744 	movi	r7,29
81142e98:	01a045f4 	movhi	r6,33047
81142e9c:	31ac4a04 	addi	r6,r6,-20184
81142ea0:	000b883a 	mov	r5,zero
81142ea4:	01204534 	movhi	r4,33044
81142ea8:	210c6a04 	addi	r4,r4,12712
81142eac:	1140b380 	call	81140b38 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
81142eb0:	e1bfff04 	addi	r6,fp,-4
81142eb4:	01604574 	movhi	r5,33045
81142eb8:	2948ce04 	addi	r5,r5,9016
81142ebc:	01000744 	movi	r4,29
81142ec0:	11413680 	call	81141368 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
81142ec4:	0001883a 	nop
81142ec8:	e037883a 	mov	sp,fp
81142ecc:	dfc00117 	ldw	ra,4(sp)
81142ed0:	df000017 	ldw	fp,0(sp)
81142ed4:	dec00204 	addi	sp,sp,8
81142ed8:	f800283a 	ret

81142edc <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
81142edc:	defffa04 	addi	sp,sp,-24
81142ee0:	de00012e 	bgeu	sp,et,81142ee8 <OSTmr_Link+0xc>
81142ee4:	003b68fa 	trap	3
81142ee8:	df000515 	stw	fp,20(sp)
81142eec:	df000504 	addi	fp,sp,20
81142ef0:	e13ffe15 	stw	r4,-8(fp)
81142ef4:	2805883a 	mov	r2,r5
81142ef8:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
81142efc:	e0bffe17 	ldw	r2,-8(fp)
81142f00:	00c000c4 	movi	r3,3
81142f04:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
81142f08:	e0bfff03 	ldbu	r2,-4(fp)
81142f0c:	10800058 	cmpnei	r2,r2,1
81142f10:	1000071e 	bne	r2,zero,81142f30 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81142f14:	e0bffe17 	ldw	r2,-8(fp)
81142f18:	10c00717 	ldw	r3,28(r2)
81142f1c:	d0a0a317 	ldw	r2,-32116(gp)
81142f20:	1887883a 	add	r3,r3,r2
81142f24:	e0bffe17 	ldw	r2,-8(fp)
81142f28:	10c00515 	stw	r3,20(r2)
81142f2c:	00001006 	br	81142f70 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
81142f30:	e0bffe17 	ldw	r2,-8(fp)
81142f34:	10800617 	ldw	r2,24(r2)
81142f38:	1000071e 	bne	r2,zero,81142f58 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81142f3c:	e0bffe17 	ldw	r2,-8(fp)
81142f40:	10c00717 	ldw	r3,28(r2)
81142f44:	d0a0a317 	ldw	r2,-32116(gp)
81142f48:	1887883a 	add	r3,r3,r2
81142f4c:	e0bffe17 	ldw	r2,-8(fp)
81142f50:	10c00515 	stw	r3,20(r2)
81142f54:	00000606 	br	81142f70 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
81142f58:	e0bffe17 	ldw	r2,-8(fp)
81142f5c:	10c00617 	ldw	r3,24(r2)
81142f60:	d0a0a317 	ldw	r2,-32116(gp)
81142f64:	1887883a 	add	r3,r3,r2
81142f68:	e0bffe17 	ldw	r2,-8(fp)
81142f6c:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81142f70:	e0bffe17 	ldw	r2,-8(fp)
81142f74:	10800517 	ldw	r2,20(r2)
81142f78:	1080004c 	andi	r2,r2,1
81142f7c:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81142f80:	e0bffb0b 	ldhu	r2,-20(fp)
81142f84:	100690fa 	slli	r3,r2,3
81142f88:	00a045f4 	movhi	r2,33047
81142f8c:	10a00304 	addi	r2,r2,-32756
81142f90:	1885883a 	add	r2,r3,r2
81142f94:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
81142f98:	e0bffc17 	ldw	r2,-16(fp)
81142f9c:	10800017 	ldw	r2,0(r2)
81142fa0:	1000091e 	bne	r2,zero,81142fc8 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
81142fa4:	e0bffc17 	ldw	r2,-16(fp)
81142fa8:	e0fffe17 	ldw	r3,-8(fp)
81142fac:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
81142fb0:	e0bffe17 	ldw	r2,-8(fp)
81142fb4:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
81142fb8:	e0bffc17 	ldw	r2,-16(fp)
81142fbc:	00c00044 	movi	r3,1
81142fc0:	10c0010d 	sth	r3,4(r2)
81142fc4:	00001206 	br	81143010 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
81142fc8:	e0bffc17 	ldw	r2,-16(fp)
81142fcc:	10800017 	ldw	r2,0(r2)
81142fd0:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
81142fd4:	e0bffc17 	ldw	r2,-16(fp)
81142fd8:	e0fffe17 	ldw	r3,-8(fp)
81142fdc:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
81142fe0:	e0bffe17 	ldw	r2,-8(fp)
81142fe4:	e0fffd17 	ldw	r3,-12(fp)
81142fe8:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
81142fec:	e0bffd17 	ldw	r2,-12(fp)
81142ff0:	e0fffe17 	ldw	r3,-8(fp)
81142ff4:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
81142ff8:	e0bffc17 	ldw	r2,-16(fp)
81142ffc:	1080010b 	ldhu	r2,4(r2)
81143000:	10800044 	addi	r2,r2,1
81143004:	1007883a 	mov	r3,r2
81143008:	e0bffc17 	ldw	r2,-16(fp)
8114300c:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
81143010:	e0bffe17 	ldw	r2,-8(fp)
81143014:	10000415 	stw	zero,16(r2)
}
81143018:	0001883a 	nop
8114301c:	e037883a 	mov	sp,fp
81143020:	df000017 	ldw	fp,0(sp)
81143024:	dec00104 	addi	sp,sp,4
81143028:	f800283a 	ret

8114302c <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
8114302c:	defffa04 	addi	sp,sp,-24
81143030:	de00012e 	bgeu	sp,et,81143038 <OSTmr_Unlink+0xc>
81143034:	003b68fa 	trap	3
81143038:	df000515 	stw	fp,20(sp)
8114303c:	df000504 	addi	fp,sp,20
81143040:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81143044:	e0bfff17 	ldw	r2,-4(fp)
81143048:	10800517 	ldw	r2,20(r2)
8114304c:	1080004c 	andi	r2,r2,1
81143050:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81143054:	e0bffb0b 	ldhu	r2,-20(fp)
81143058:	100690fa 	slli	r3,r2,3
8114305c:	00a045f4 	movhi	r2,33047
81143060:	10a00304 	addi	r2,r2,-32756
81143064:	1885883a 	add	r2,r3,r2
81143068:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
8114306c:	e0bffc17 	ldw	r2,-16(fp)
81143070:	10c00017 	ldw	r3,0(r2)
81143074:	e0bfff17 	ldw	r2,-4(fp)
81143078:	18800b1e 	bne	r3,r2,811430a8 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
8114307c:	e0bfff17 	ldw	r2,-4(fp)
81143080:	10800317 	ldw	r2,12(r2)
81143084:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
81143088:	e0bffc17 	ldw	r2,-16(fp)
8114308c:	e0fffd17 	ldw	r3,-12(fp)
81143090:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
81143094:	e0bffd17 	ldw	r2,-12(fp)
81143098:	10001126 	beq	r2,zero,811430e0 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
8114309c:	e0bffd17 	ldw	r2,-12(fp)
811430a0:	10000415 	stw	zero,16(r2)
811430a4:	00000e06 	br	811430e0 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
811430a8:	e0bfff17 	ldw	r2,-4(fp)
811430ac:	10800417 	ldw	r2,16(r2)
811430b0:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
811430b4:	e0bfff17 	ldw	r2,-4(fp)
811430b8:	10800317 	ldw	r2,12(r2)
811430bc:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
811430c0:	e0bffd17 	ldw	r2,-12(fp)
811430c4:	e0fffe17 	ldw	r3,-8(fp)
811430c8:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
811430cc:	e0bffe17 	ldw	r2,-8(fp)
811430d0:	10000326 	beq	r2,zero,811430e0 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
811430d4:	e0bffe17 	ldw	r2,-8(fp)
811430d8:	e0fffd17 	ldw	r3,-12(fp)
811430dc:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
811430e0:	e0bfff17 	ldw	r2,-4(fp)
811430e4:	00c00044 	movi	r3,1
811430e8:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
811430ec:	e0bfff17 	ldw	r2,-4(fp)
811430f0:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
811430f4:	e0bfff17 	ldw	r2,-4(fp)
811430f8:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
811430fc:	e0bffc17 	ldw	r2,-16(fp)
81143100:	1080010b 	ldhu	r2,4(r2)
81143104:	10bfffc4 	addi	r2,r2,-1
81143108:	1007883a 	mov	r3,r2
8114310c:	e0bffc17 	ldw	r2,-16(fp)
81143110:	10c0010d 	sth	r3,4(r2)
}
81143114:	0001883a 	nop
81143118:	e037883a 	mov	sp,fp
8114311c:	df000017 	ldw	fp,0(sp)
81143120:	dec00104 	addi	sp,sp,4
81143124:	f800283a 	ret

81143128 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
81143128:	defffd04 	addi	sp,sp,-12
8114312c:	de00012e 	bgeu	sp,et,81143134 <OSTmr_Lock+0xc>
81143130:	003b68fa 	trap	3
81143134:	dfc00215 	stw	ra,8(sp)
81143138:	df000115 	stw	fp,4(sp)
8114313c:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
81143140:	d0a0a517 	ldw	r2,-32108(gp)
81143144:	e1bfff04 	addi	r6,fp,-4
81143148:	000b883a 	mov	r5,zero
8114314c:	1009883a 	mov	r4,r2
81143150:	113fdcc0 	call	8113fdcc <OSSemPend>
    (void)err;
}
81143154:	0001883a 	nop
81143158:	e037883a 	mov	sp,fp
8114315c:	dfc00117 	ldw	ra,4(sp)
81143160:	df000017 	ldw	fp,0(sp)
81143164:	dec00204 	addi	sp,sp,8
81143168:	f800283a 	ret

8114316c <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
8114316c:	defffe04 	addi	sp,sp,-8
81143170:	de00012e 	bgeu	sp,et,81143178 <OSTmr_Unlock+0xc>
81143174:	003b68fa 	trap	3
81143178:	dfc00115 	stw	ra,4(sp)
8114317c:	df000015 	stw	fp,0(sp)
81143180:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
81143184:	d0a0a517 	ldw	r2,-32108(gp)
81143188:	1009883a 	mov	r4,r2
8114318c:	11401540 	call	81140154 <OSSemPost>
}
81143190:	0001883a 	nop
81143194:	e037883a 	mov	sp,fp
81143198:	dfc00117 	ldw	ra,4(sp)
8114319c:	df000017 	ldw	fp,0(sp)
811431a0:	dec00204 	addi	sp,sp,8
811431a4:	f800283a 	ret

811431a8 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
811431a8:	defff704 	addi	sp,sp,-36
811431ac:	de00012e 	bgeu	sp,et,811431b4 <OSTmr_Task+0xc>
811431b0:	003b68fa 	trap	3
811431b4:	dfc00815 	stw	ra,32(sp)
811431b8:	df000715 	stw	fp,28(sp)
811431bc:	df000704 	addi	fp,sp,28
811431c0:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
811431c4:	d0a09017 	ldw	r2,-32192(gp)
811431c8:	e0fffe04 	addi	r3,fp,-8
811431cc:	180d883a 	mov	r6,r3
811431d0:	000b883a 	mov	r5,zero
811431d4:	1009883a 	mov	r4,r2
811431d8:	113fdcc0 	call	8113fdcc <OSSemPend>
        OSTmr_Lock();
811431dc:	11431280 	call	81143128 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
811431e0:	d0a0a317 	ldw	r2,-32116(gp)
811431e4:	10800044 	addi	r2,r2,1
811431e8:	d0a0a315 	stw	r2,-32116(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
811431ec:	d0a0a317 	ldw	r2,-32116(gp)
811431f0:	1080004c 	andi	r2,r2,1
811431f4:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
811431f8:	e0bffa0b 	ldhu	r2,-24(fp)
811431fc:	100690fa 	slli	r3,r2,3
81143200:	00a045f4 	movhi	r2,33047
81143204:	10a00304 	addi	r2,r2,-32756
81143208:	1885883a 	add	r2,r3,r2
8114320c:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
81143210:	e0bffb17 	ldw	r2,-20(fp)
81143214:	10800017 	ldw	r2,0(r2)
81143218:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
8114321c:	00002206 	br	811432a8 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
81143220:	e0bff917 	ldw	r2,-28(fp)
81143224:	10800317 	ldw	r2,12(r2)
81143228:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
8114322c:	e0bff917 	ldw	r2,-28(fp)
81143230:	10c00517 	ldw	r3,20(r2)
81143234:	d0a0a317 	ldw	r2,-32116(gp)
81143238:	1880191e 	bne	r3,r2,811432a0 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
8114323c:	e0bff917 	ldw	r2,-28(fp)
81143240:	10800117 	ldw	r2,4(r2)
81143244:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
81143248:	e0bffd17 	ldw	r2,-12(fp)
8114324c:	10000626 	beq	r2,zero,81143268 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
81143250:	e0bff917 	ldw	r2,-28(fp)
81143254:	10c00217 	ldw	r3,8(r2)
81143258:	e0bffd17 	ldw	r2,-12(fp)
8114325c:	180b883a 	mov	r5,r3
81143260:	e13ff917 	ldw	r4,-28(fp)
81143264:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
81143268:	e13ff917 	ldw	r4,-28(fp)
8114326c:	114302c0 	call	8114302c <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
81143270:	e0bff917 	ldw	r2,-28(fp)
81143274:	10800c03 	ldbu	r2,48(r2)
81143278:	10803fcc 	andi	r2,r2,255
8114327c:	10800098 	cmpnei	r2,r2,2
81143280:	1000041e 	bne	r2,zero,81143294 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
81143284:	01400044 	movi	r5,1
81143288:	e13ff917 	ldw	r4,-28(fp)
8114328c:	1142edc0 	call	81142edc <OSTmr_Link>
81143290:	00000306 	br	811432a0 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
81143294:	e0bff917 	ldw	r2,-28(fp)
81143298:	00c00084 	movi	r3,2
8114329c:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
811432a0:	e0bffc17 	ldw	r2,-16(fp)
811432a4:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
811432a8:	e0bff917 	ldw	r2,-28(fp)
811432ac:	103fdc1e 	bne	r2,zero,81143220 <__reset+0xfb123220>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
811432b0:	114316c0 	call	8114316c <OSTmr_Unlock>
    }
811432b4:	003fc306 	br	811431c4 <__reset+0xfb1231c4>

811432b8 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
811432b8:	defffd04 	addi	sp,sp,-12
811432bc:	de00012e 	bgeu	sp,et,811432c4 <alt_dev_reg+0xc>
811432c0:	003b68fa 	trap	3
811432c4:	dfc00215 	stw	ra,8(sp)
811432c8:	df000115 	stw	fp,4(sp)
811432cc:	df000104 	addi	fp,sp,4
811432d0:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
811432d4:	d1600d04 	addi	r5,gp,-32716
811432d8:	e13fff17 	ldw	r4,-4(fp)
811432dc:	114b5580 	call	8114b558 <alt_dev_llist_insert>
}
811432e0:	e037883a 	mov	sp,fp
811432e4:	dfc00117 	ldw	ra,4(sp)
811432e8:	df000017 	ldw	fp,0(sp)
811432ec:	dec00204 	addi	sp,sp,8
811432f0:	f800283a 	ret

811432f4 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
811432f4:	defffd04 	addi	sp,sp,-12
811432f8:	de00012e 	bgeu	sp,et,81143300 <alt_irq_init+0xc>
811432fc:	003b68fa 	trap	3
81143300:	dfc00215 	stw	ra,8(sp)
81143304:	df000115 	stw	fp,4(sp)
81143308:	df000104 	addi	fp,sp,4
8114330c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
81143310:	114bf200 	call	8114bf20 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
81143314:	00800044 	movi	r2,1
81143318:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
8114331c:	0001883a 	nop
81143320:	e037883a 	mov	sp,fp
81143324:	dfc00117 	ldw	ra,4(sp)
81143328:	df000017 	ldw	fp,0(sp)
8114332c:	dec00204 	addi	sp,sp,8
81143330:	f800283a 	ret

81143334 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
81143334:	defffe04 	addi	sp,sp,-8
81143338:	de00012e 	bgeu	sp,et,81143340 <alt_sys_init+0xc>
8114333c:	003b68fa 	trap	3
81143340:	dfc00115 	stw	ra,4(sp)
81143344:	df000015 	stw	fp,0(sp)
81143348:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
8114334c:	01c0fa04 	movi	r7,1000
81143350:	01800304 	movi	r6,12
81143354:	000b883a 	mov	r5,zero
81143358:	01200034 	movhi	r4,32768
8114335c:	21022004 	addi	r4,r4,2176
81143360:	114868c0 	call	8114868c <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
81143364:	018002c4 	movi	r6,11
81143368:	000b883a 	mov	r5,zero
8114336c:	01204574 	movhi	r4,33045
81143370:	210c6a04 	addi	r4,r4,12712
81143374:	11479780 	call	81147978 <altera_avalon_jtag_uart_init>
81143378:	01204574 	movhi	r4,33045
8114337c:	210c6004 	addi	r4,r4,12672
81143380:	11432b80 	call	811432b8 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
81143384:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
81143388:	018003c4 	movi	r6,15
8114338c:	000b883a 	mov	r5,zero
81143390:	01204574 	movhi	r4,33045
81143394:	21108504 	addi	r4,r4,16916
81143398:	11488380 	call	81148838 <altera_avalon_uart_init>
8114339c:	01204574 	movhi	r4,33045
811433a0:	21107b04 	addi	r4,r4,16876
811433a4:	11432b80 	call	811432b8 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
811433a8:	00a04574 	movhi	r2,33045
811433ac:	1090af04 	addi	r2,r2,17084
811433b0:	10c00717 	ldw	r3,28(r2)
811433b4:	00a04574 	movhi	r2,33045
811433b8:	1090af04 	addi	r2,r2,17084
811433bc:	10800817 	ldw	r2,32(r2)
811433c0:	100d883a 	mov	r6,r2
811433c4:	180b883a 	mov	r5,r3
811433c8:	01204574 	movhi	r4,33045
811433cc:	2110af04 	addi	r4,r4,17084
811433d0:	114b0c00 	call	8114b0c0 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
811433d4:	00a04574 	movhi	r2,33045
811433d8:	1090c804 	addi	r2,r2,17184
811433dc:	10c00717 	ldw	r3,28(r2)
811433e0:	00a04574 	movhi	r2,33045
811433e4:	1090c804 	addi	r2,r2,17184
811433e8:	10800817 	ldw	r2,32(r2)
811433ec:	100d883a 	mov	r6,r2
811433f0:	180b883a 	mov	r5,r3
811433f4:	01204574 	movhi	r4,33045
811433f8:	2110c804 	addi	r4,r4,17184
811433fc:	114b0c00 	call	8114b0c0 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
81143400:	01204574 	movhi	r4,33045
81143404:	2110e104 	addi	r4,r4,17284
81143408:	11432b80 	call	811432b8 <alt_dev_reg>
}
8114340c:	0001883a 	nop
81143410:	e037883a 	mov	sp,fp
81143414:	dfc00117 	ldw	ra,4(sp)
81143418:	df000017 	ldw	fp,0(sp)
8114341c:	dec00204 	addi	sp,sp,8
81143420:	f800283a 	ret

81143424 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
81143424:	defffa04 	addi	sp,sp,-24
81143428:	de00012e 	bgeu	sp,et,81143430 <Write_Sector_Data+0xc>
8114342c:	003b68fa 	trap	3
81143430:	dfc00515 	stw	ra,20(sp)
81143434:	df000415 	stw	fp,16(sp)
81143438:	df000404 	addi	fp,sp,16
8114343c:	e13ffe15 	stw	r4,-8(fp)
81143440:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81143444:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
81143448:	114620c0 	call	8114620c <alt_up_sd_card_is_Present>
8114344c:	10001e26 	beq	r2,zero,811434c8 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
81143450:	00803fc4 	movi	r2,255
81143454:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81143458:	d0a0af17 	ldw	r2,-32068(gp)
8114345c:	e13ffe17 	ldw	r4,-8(fp)
81143460:	e0ffff17 	ldw	r3,-4(fp)
81143464:	20c7883a 	add	r3,r4,r3
81143468:	1806927a 	slli	r3,r3,9
8114346c:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
81143470:	d0a0ae17 	ldw	r2,-32072(gp)
81143474:	00c00604 	movi	r3,24
81143478:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8114347c:	d0a0ab17 	ldw	r2,-32084(gp)
81143480:	1080002b 	ldhuio	r2,0(r2)
81143484:	10bfffcc 	andi	r2,r2,65535
81143488:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
8114348c:	e0bffd0b 	ldhu	r2,-12(fp)
81143490:	10bfffcc 	andi	r2,r2,65535
81143494:	1080010c 	andi	r2,r2,4
81143498:	103ff81e 	bne	r2,zero,8114347c <__reset+0xfb12347c>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
8114349c:	e0bffd0b 	ldhu	r2,-12(fp)
811434a0:	10bfffcc 	andi	r2,r2,65535
811434a4:	1080040c 	andi	r2,r2,16
811434a8:	1000071e 	bne	r2,zero,811434c8 <Write_Sector_Data+0xa4>
        {
            result = true;
811434ac:	00800044 	movi	r2,1
811434b0:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
811434b4:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
811434b8:	e0fffe17 	ldw	r3,-8(fp)
811434bc:	e0bfff17 	ldw	r2,-4(fp)
811434c0:	1885883a 	add	r2,r3,r2
811434c4:	d0a0b515 	stw	r2,-32044(gp)
        }
    }
    return result;
811434c8:	e0bffc17 	ldw	r2,-16(fp)
}
811434cc:	e037883a 	mov	sp,fp
811434d0:	dfc00117 	ldw	ra,4(sp)
811434d4:	df000017 	ldw	fp,0(sp)
811434d8:	dec00204 	addi	sp,sp,8
811434dc:	f800283a 	ret

811434e0 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
811434e0:	defffd04 	addi	sp,sp,-12
811434e4:	de00012e 	bgeu	sp,et,811434ec <Save_Modified_Sector+0xc>
811434e8:	003b68fa 	trap	3
811434ec:	dfc00215 	stw	ra,8(sp)
811434f0:	df000115 	stw	fp,4(sp)
811434f4:	df000104 	addi	fp,sp,4
    bool result = true;
811434f8:	00800044 	movi	r2,1
811434fc:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
81143500:	d0a0b417 	ldw	r2,-32048(gp)
81143504:	10000526 	beq	r2,zero,8114351c <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
81143508:	d0a0b517 	ldw	r2,-32044(gp)
8114350c:	000b883a 	mov	r5,zero
81143510:	1009883a 	mov	r4,r2
81143514:	11434240 	call	81143424 <Write_Sector_Data>
81143518:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
8114351c:	e0bfff17 	ldw	r2,-4(fp)
}
81143520:	e037883a 	mov	sp,fp
81143524:	dfc00117 	ldw	ra,4(sp)
81143528:	df000017 	ldw	fp,0(sp)
8114352c:	dec00204 	addi	sp,sp,8
81143530:	f800283a 	ret

81143534 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
81143534:	defffa04 	addi	sp,sp,-24
81143538:	de00012e 	bgeu	sp,et,81143540 <Read_Sector_Data+0xc>
8114353c:	003b68fa 	trap	3
81143540:	dfc00515 	stw	ra,20(sp)
81143544:	df000415 	stw	fp,16(sp)
81143548:	df000404 	addi	fp,sp,16
8114354c:	e13ffe15 	stw	r4,-8(fp)
81143550:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
81143554:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
81143558:	114620c0 	call	8114620c <alt_up_sd_card_is_Present>
8114355c:	10002726 	beq	r2,zero,811435fc <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
81143560:	00803fc4 	movi	r2,255
81143564:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
81143568:	d0a0b417 	ldw	r2,-32048(gp)
8114356c:	10000726 	beq	r2,zero,8114358c <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
81143570:	d0a0b517 	ldw	r2,-32044(gp)
81143574:	000b883a 	mov	r5,zero
81143578:	1009883a 	mov	r4,r2
8114357c:	11434240 	call	81143424 <Write_Sector_Data>
81143580:	1000021e 	bne	r2,zero,8114358c <Read_Sector_Data+0x58>
            {
                return false;
81143584:	0005883a 	mov	r2,zero
81143588:	00001d06 	br	81143600 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8114358c:	d0a0af17 	ldw	r2,-32068(gp)
81143590:	e13ffe17 	ldw	r4,-8(fp)
81143594:	e0ffff17 	ldw	r3,-4(fp)
81143598:	20c7883a 	add	r3,r4,r3
8114359c:	1806927a 	slli	r3,r3,9
811435a0:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
811435a4:	d0a0ae17 	ldw	r2,-32072(gp)
811435a8:	00c00444 	movi	r3,17
811435ac:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
811435b0:	d0a0ab17 	ldw	r2,-32084(gp)
811435b4:	1080002b 	ldhuio	r2,0(r2)
811435b8:	10bfffcc 	andi	r2,r2,65535
811435bc:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
811435c0:	e0bffd0b 	ldhu	r2,-12(fp)
811435c4:	10bfffcc 	andi	r2,r2,65535
811435c8:	1080010c 	andi	r2,r2,4
811435cc:	103ff81e 	bne	r2,zero,811435b0 <__reset+0xfb1235b0>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
811435d0:	e0bffd0b 	ldhu	r2,-12(fp)
811435d4:	10bfffcc 	andi	r2,r2,65535
811435d8:	1080040c 	andi	r2,r2,16
811435dc:	1000071e 	bne	r2,zero,811435fc <Read_Sector_Data+0xc8>
		{
			result = true;
811435e0:	00800044 	movi	r2,1
811435e4:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
811435e8:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
811435ec:	e0fffe17 	ldw	r3,-8(fp)
811435f0:	e0bfff17 	ldw	r2,-4(fp)
811435f4:	1885883a 	add	r2,r3,r2
811435f8:	d0a0b515 	stw	r2,-32044(gp)
		}
	}
	return result;
811435fc:	e0bffc17 	ldw	r2,-16(fp)
}
81143600:	e037883a 	mov	sp,fp
81143604:	dfc00117 	ldw	ra,4(sp)
81143608:	df000017 	ldw	fp,0(sp)
8114360c:	dec00204 	addi	sp,sp,8
81143610:	f800283a 	ret

81143614 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
81143614:	defffb04 	addi	sp,sp,-20
81143618:	de00012e 	bgeu	sp,et,81143620 <get_cluster_flag+0xc>
8114361c:	003b68fa 	trap	3
81143620:	dfc00415 	stw	ra,16(sp)
81143624:	df000315 	stw	fp,12(sp)
81143628:	df000304 	addi	fp,sp,12
8114362c:	e13ffe15 	stw	r4,-8(fp)
81143630:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
81143634:	e0bffe17 	ldw	r2,-8(fp)
81143638:	1004d23a 	srli	r2,r2,8
8114363c:	d0e0b117 	ldw	r3,-32060(gp)
81143640:	10c5883a 	add	r2,r2,r3
81143644:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81143648:	00a045f4 	movhi	r2,33047
8114364c:	10b82904 	addi	r2,r2,-8028
81143650:	10801117 	ldw	r2,68(r2)
81143654:	e0fffd17 	ldw	r3,-12(fp)
81143658:	1885883a 	add	r2,r3,r2
8114365c:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
81143660:	d0a0b517 	ldw	r2,-32044(gp)
81143664:	e0fffd17 	ldw	r3,-12(fp)
81143668:	18800726 	beq	r3,r2,81143688 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8114366c:	e0bffd17 	ldw	r2,-12(fp)
81143670:	000b883a 	mov	r5,zero
81143674:	1009883a 	mov	r4,r2
81143678:	11435340 	call	81143534 <Read_Sector_Data>
8114367c:	1000021e 	bne	r2,zero,81143688 <get_cluster_flag+0x74>
        {
            return false;
81143680:	0005883a 	mov	r2,zero
81143684:	00000d06 	br	811436bc <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
81143688:	e0bffe17 	ldw	r2,-8(fp)
8114368c:	10803fcc 	andi	r2,r2,255
81143690:	1085883a 	add	r2,r2,r2
81143694:	1007883a 	mov	r3,r2
81143698:	d0a0b317 	ldw	r2,-32052(gp)
8114369c:	10800a17 	ldw	r2,40(r2)
811436a0:	1885883a 	add	r2,r3,r2
811436a4:	1080002b 	ldhuio	r2,0(r2)
811436a8:	10bfffcc 	andi	r2,r2,65535
811436ac:	1007883a 	mov	r3,r2
811436b0:	e0bfff17 	ldw	r2,-4(fp)
811436b4:	10c0000d 	sth	r3,0(r2)
    return true;
811436b8:	00800044 	movi	r2,1
}
811436bc:	e037883a 	mov	sp,fp
811436c0:	dfc00117 	ldw	ra,4(sp)
811436c4:	df000017 	ldw	fp,0(sp)
811436c8:	dec00204 	addi	sp,sp,8
811436cc:	f800283a 	ret

811436d0 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
811436d0:	defffa04 	addi	sp,sp,-24
811436d4:	de00012e 	bgeu	sp,et,811436dc <mark_cluster+0xc>
811436d8:	003b68fa 	trap	3
811436dc:	dfc00515 	stw	ra,20(sp)
811436e0:	df000415 	stw	fp,16(sp)
811436e4:	df000404 	addi	fp,sp,16
811436e8:	e13ffd15 	stw	r4,-12(fp)
811436ec:	2805883a 	mov	r2,r5
811436f0:	e1bfff15 	stw	r6,-4(fp)
811436f4:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
811436f8:	e0bffd17 	ldw	r2,-12(fp)
811436fc:	1004d23a 	srli	r2,r2,8
81143700:	d0e0b117 	ldw	r3,-32060(gp)
81143704:	10c5883a 	add	r2,r2,r3
81143708:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
8114370c:	e0bfff17 	ldw	r2,-4(fp)
81143710:	10000726 	beq	r2,zero,81143730 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81143714:	00a045f4 	movhi	r2,33047
81143718:	10b82904 	addi	r2,r2,-8028
8114371c:	10801117 	ldw	r2,68(r2)
81143720:	e0fffc17 	ldw	r3,-16(fp)
81143724:	1885883a 	add	r2,r3,r2
81143728:	e0bffc15 	stw	r2,-16(fp)
8114372c:	00000606 	br	81143748 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
81143730:	00a045f4 	movhi	r2,33047
81143734:	10b82904 	addi	r2,r2,-8028
81143738:	10801217 	ldw	r2,72(r2)
8114373c:	e0fffc17 	ldw	r3,-16(fp)
81143740:	1885883a 	add	r2,r3,r2
81143744:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
81143748:	d0a0b517 	ldw	r2,-32044(gp)
8114374c:	e0fffc17 	ldw	r3,-16(fp)
81143750:	18800726 	beq	r3,r2,81143770 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
81143754:	e0bffc17 	ldw	r2,-16(fp)
81143758:	000b883a 	mov	r5,zero
8114375c:	1009883a 	mov	r4,r2
81143760:	11435340 	call	81143534 <Read_Sector_Data>
81143764:	1000021e 	bne	r2,zero,81143770 <mark_cluster+0xa0>
        {
            return false;
81143768:	0005883a 	mov	r2,zero
8114376c:	00000d06 	br	811437a4 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
81143770:	e0bffd17 	ldw	r2,-12(fp)
81143774:	10803fcc 	andi	r2,r2,255
81143778:	1085883a 	add	r2,r2,r2
8114377c:	1007883a 	mov	r3,r2
81143780:	d0a0b317 	ldw	r2,-32052(gp)
81143784:	10800a17 	ldw	r2,40(r2)
81143788:	1885883a 	add	r2,r3,r2
8114378c:	1007883a 	mov	r3,r2
81143790:	e0bffe0f 	ldh	r2,-8(fp)
81143794:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
81143798:	00800044 	movi	r2,1
8114379c:	d0a0b415 	stw	r2,-32048(gp)
    return true;
811437a0:	00800044 	movi	r2,1
}
811437a4:	e037883a 	mov	sp,fp
811437a8:	dfc00117 	ldw	ra,4(sp)
811437ac:	df000017 	ldw	fp,0(sp)
811437b0:	dec00204 	addi	sp,sp,8
811437b4:	f800283a 	ret

811437b8 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
811437b8:	defff704 	addi	sp,sp,-36
811437bc:	de00012e 	bgeu	sp,et,811437c4 <Check_for_Master_Boot_Record+0xc>
811437c0:	003b68fa 	trap	3
811437c4:	dfc00815 	stw	ra,32(sp)
811437c8:	df000715 	stw	fp,28(sp)
811437cc:	df000704 	addi	fp,sp,28
	bool result = false;
811437d0:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
811437d4:	000b883a 	mov	r5,zero
811437d8:	0009883a 	mov	r4,zero
811437dc:	11435340 	call	81143534 <Read_Sector_Data>
811437e0:	10005a26 	beq	r2,zero,8114394c <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
811437e4:	d0a0b317 	ldw	r2,-32052(gp)
811437e8:	10800a17 	ldw	r2,40(r2)
811437ec:	10807f84 	addi	r2,r2,510
811437f0:	1080002b 	ldhuio	r2,0(r2)
811437f4:	10bfffcc 	andi	r2,r2,65535
811437f8:	10bfffcc 	andi	r2,r2,65535
811437fc:	10a0001c 	xori	r2,r2,32768
81143800:	10a00004 	addi	r2,r2,-32768
81143804:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
81143808:	e0bffb17 	ldw	r2,-20(fp)
8114380c:	10ffffcc 	andi	r3,r2,65535
81143810:	00aa9554 	movui	r2,43605
81143814:	18804d1e 	bne	r3,r2,8114394c <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81143818:	e03ffa15 	stw	zero,-24(fp)
8114381c:	00004806 	br	81143940 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
81143820:	e0bffa17 	ldw	r2,-24(fp)
81143824:	1004913a 	slli	r2,r2,4
81143828:	10806f84 	addi	r2,r2,446
8114382c:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
81143830:	d0a0b317 	ldw	r2,-32052(gp)
81143834:	10c00a17 	ldw	r3,40(r2)
81143838:	e0bffc17 	ldw	r2,-16(fp)
8114383c:	1885883a 	add	r2,r3,r2
81143840:	10800104 	addi	r2,r2,4
81143844:	10800023 	ldbuio	r2,0(r2)
81143848:	10803fcc 	andi	r2,r2,255
8114384c:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
81143850:	e0bffd07 	ldb	r2,-12(fp)
81143854:	10800060 	cmpeqi	r2,r2,1
81143858:	1000091e 	bne	r2,zero,81143880 <Check_for_Master_Boot_Record+0xc8>
8114385c:	e0bffd07 	ldb	r2,-12(fp)
81143860:	10800120 	cmpeqi	r2,r2,4
81143864:	1000061e 	bne	r2,zero,81143880 <Check_for_Master_Boot_Record+0xc8>
81143868:	e0bffd07 	ldb	r2,-12(fp)
8114386c:	108001a0 	cmpeqi	r2,r2,6
81143870:	1000031e 	bne	r2,zero,81143880 <Check_for_Master_Boot_Record+0xc8>
81143874:	e0bffd07 	ldb	r2,-12(fp)
81143878:	10800398 	cmpnei	r2,r2,14
8114387c:	10002d1e 	bne	r2,zero,81143934 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
81143880:	d0a0b317 	ldw	r2,-32052(gp)
81143884:	10c00a17 	ldw	r3,40(r2)
81143888:	e0bffc17 	ldw	r2,-16(fp)
8114388c:	1885883a 	add	r2,r3,r2
81143890:	10800284 	addi	r2,r2,10
81143894:	1080002b 	ldhuio	r2,0(r2)
81143898:	10bfffcc 	andi	r2,r2,65535
8114389c:	1006943a 	slli	r3,r2,16
811438a0:	d0a0b317 	ldw	r2,-32052(gp)
811438a4:	11000a17 	ldw	r4,40(r2)
811438a8:	e0bffc17 	ldw	r2,-16(fp)
811438ac:	2085883a 	add	r2,r4,r2
811438b0:	10800204 	addi	r2,r2,8
811438b4:	1080002b 	ldhuio	r2,0(r2)
811438b8:	10bfffcc 	andi	r2,r2,65535
811438bc:	10bfffcc 	andi	r2,r2,65535
811438c0:	1884b03a 	or	r2,r3,r2
811438c4:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
811438c8:	d0a0b317 	ldw	r2,-32052(gp)
811438cc:	10c00a17 	ldw	r3,40(r2)
811438d0:	e0bffc17 	ldw	r2,-16(fp)
811438d4:	1885883a 	add	r2,r3,r2
811438d8:	10800384 	addi	r2,r2,14
811438dc:	1080002b 	ldhuio	r2,0(r2)
811438e0:	10bfffcc 	andi	r2,r2,65535
811438e4:	1006943a 	slli	r3,r2,16
811438e8:	d0a0b317 	ldw	r2,-32052(gp)
811438ec:	11000a17 	ldw	r4,40(r2)
811438f0:	e0bffc17 	ldw	r2,-16(fp)
811438f4:	2085883a 	add	r2,r4,r2
811438f8:	10800304 	addi	r2,r2,12
811438fc:	1080002b 	ldhuio	r2,0(r2)
81143900:	10bfffcc 	andi	r2,r2,65535
81143904:	10bfffcc 	andi	r2,r2,65535
81143908:	1884b03a 	or	r2,r3,r2
8114390c:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
81143910:	e0bfff17 	ldw	r2,-4(fp)
81143914:	0080070e 	bge	zero,r2,81143934 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
81143918:	00800044 	movi	r2,1
8114391c:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
81143920:	e0bfff17 	ldw	r2,-4(fp)
81143924:	d0a0b215 	stw	r2,-32056(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
81143928:	e0bffe17 	ldw	r2,-8(fp)
8114392c:	d0a0b115 	stw	r2,-32060(gp)
						break;
81143930:	00000606 	br	8114394c <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81143934:	e0bffa17 	ldw	r2,-24(fp)
81143938:	10800044 	addi	r2,r2,1
8114393c:	e0bffa15 	stw	r2,-24(fp)
81143940:	e0bffa17 	ldw	r2,-24(fp)
81143944:	10800110 	cmplti	r2,r2,4
81143948:	103fb51e 	bne	r2,zero,81143820 <__reset+0xfb123820>
				}
			}
		}
	}

	return result;
8114394c:	e0bff917 	ldw	r2,-28(fp)
}
81143950:	e037883a 	mov	sp,fp
81143954:	dfc00117 	ldw	ra,4(sp)
81143958:	df000017 	ldw	fp,0(sp)
8114395c:	dec00204 	addi	sp,sp,8
81143960:	f800283a 	ret

81143964 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
81143964:	defff804 	addi	sp,sp,-32
81143968:	de00012e 	bgeu	sp,et,81143970 <Read_File_Record_At_Offset+0xc>
8114396c:	003b68fa 	trap	3
81143970:	dfc00715 	stw	ra,28(sp)
81143974:	df000615 	stw	fp,24(sp)
81143978:	df000604 	addi	fp,sp,24
8114397c:	e13ffc15 	stw	r4,-16(fp)
81143980:	e17ffd15 	stw	r5,-12(fp)
81143984:	e1bffe15 	stw	r6,-8(fp)
81143988:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
8114398c:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81143990:	e0bffc17 	ldw	r2,-16(fp)
81143994:	108007cc 	andi	r2,r2,31
81143998:	10008d1e 	bne	r2,zero,81143bd0 <Read_File_Record_At_Offset+0x26c>
8114399c:	114620c0 	call	8114620c <alt_up_sd_card_is_Present>
811439a0:	10008b26 	beq	r2,zero,81143bd0 <Read_File_Record_At_Offset+0x26c>
811439a4:	d0a0aa17 	ldw	r2,-32088(gp)
811439a8:	10008926 	beq	r2,zero,81143bd0 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
811439ac:	e03ffb15 	stw	zero,-20(fp)
811439b0:	00001106 	br	811439f8 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
811439b4:	e0fffc17 	ldw	r3,-16(fp)
811439b8:	e0bffb17 	ldw	r2,-20(fp)
811439bc:	1885883a 	add	r2,r3,r2
811439c0:	1007883a 	mov	r3,r2
811439c4:	d0a0b317 	ldw	r2,-32052(gp)
811439c8:	10800a17 	ldw	r2,40(r2)
811439cc:	1885883a 	add	r2,r3,r2
811439d0:	10800023 	ldbuio	r2,0(r2)
811439d4:	10803fcc 	andi	r2,r2,255
811439d8:	1009883a 	mov	r4,r2
811439dc:	e0fffd17 	ldw	r3,-12(fp)
811439e0:	e0bffb17 	ldw	r2,-20(fp)
811439e4:	1885883a 	add	r2,r3,r2
811439e8:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
811439ec:	e0bffb17 	ldw	r2,-20(fp)
811439f0:	10800044 	addi	r2,r2,1
811439f4:	e0bffb15 	stw	r2,-20(fp)
811439f8:	e0bffb17 	ldw	r2,-20(fp)
811439fc:	10800210 	cmplti	r2,r2,8
81143a00:	103fec1e 	bne	r2,zero,811439b4 <__reset+0xfb1239b4>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
81143a04:	e03ffb15 	stw	zero,-20(fp)
81143a08:	00001306 	br	81143a58 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
81143a0c:	e0fffc17 	ldw	r3,-16(fp)
81143a10:	e0bffb17 	ldw	r2,-20(fp)
81143a14:	1885883a 	add	r2,r3,r2
81143a18:	1007883a 	mov	r3,r2
81143a1c:	d0a0b317 	ldw	r2,-32052(gp)
81143a20:	10800a17 	ldw	r2,40(r2)
81143a24:	1885883a 	add	r2,r3,r2
81143a28:	10800204 	addi	r2,r2,8
81143a2c:	10800023 	ldbuio	r2,0(r2)
81143a30:	10803fcc 	andi	r2,r2,255
81143a34:	1009883a 	mov	r4,r2
81143a38:	e0fffd17 	ldw	r3,-12(fp)
81143a3c:	e0bffb17 	ldw	r2,-20(fp)
81143a40:	1885883a 	add	r2,r3,r2
81143a44:	10800204 	addi	r2,r2,8
81143a48:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
81143a4c:	e0bffb17 	ldw	r2,-20(fp)
81143a50:	10800044 	addi	r2,r2,1
81143a54:	e0bffb15 	stw	r2,-20(fp)
81143a58:	e0bffb17 	ldw	r2,-20(fp)
81143a5c:	108000d0 	cmplti	r2,r2,3
81143a60:	103fea1e 	bne	r2,zero,81143a0c <__reset+0xfb123a0c>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
81143a64:	d0a0b317 	ldw	r2,-32052(gp)
81143a68:	10c00a17 	ldw	r3,40(r2)
81143a6c:	e0bffc17 	ldw	r2,-16(fp)
81143a70:	1885883a 	add	r2,r3,r2
81143a74:	108002c4 	addi	r2,r2,11
81143a78:	10800023 	ldbuio	r2,0(r2)
81143a7c:	10803fcc 	andi	r2,r2,255
81143a80:	1007883a 	mov	r3,r2
81143a84:	e0bffd17 	ldw	r2,-12(fp)
81143a88:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
81143a8c:	d0a0b317 	ldw	r2,-32052(gp)
81143a90:	10c00a17 	ldw	r3,40(r2)
81143a94:	e0bffc17 	ldw	r2,-16(fp)
81143a98:	1885883a 	add	r2,r3,r2
81143a9c:	10800384 	addi	r2,r2,14
81143aa0:	1080002b 	ldhuio	r2,0(r2)
81143aa4:	10bfffcc 	andi	r2,r2,65535
81143aa8:	1007883a 	mov	r3,r2
81143aac:	e0bffd17 	ldw	r2,-12(fp)
81143ab0:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
81143ab4:	d0a0b317 	ldw	r2,-32052(gp)
81143ab8:	10c00a17 	ldw	r3,40(r2)
81143abc:	e0bffc17 	ldw	r2,-16(fp)
81143ac0:	1885883a 	add	r2,r3,r2
81143ac4:	10800404 	addi	r2,r2,16
81143ac8:	1080002b 	ldhuio	r2,0(r2)
81143acc:	10bfffcc 	andi	r2,r2,65535
81143ad0:	1007883a 	mov	r3,r2
81143ad4:	e0bffd17 	ldw	r2,-12(fp)
81143ad8:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
81143adc:	d0a0b317 	ldw	r2,-32052(gp)
81143ae0:	10c00a17 	ldw	r3,40(r2)
81143ae4:	e0bffc17 	ldw	r2,-16(fp)
81143ae8:	1885883a 	add	r2,r3,r2
81143aec:	10800484 	addi	r2,r2,18
81143af0:	1080002b 	ldhuio	r2,0(r2)
81143af4:	10bfffcc 	andi	r2,r2,65535
81143af8:	1007883a 	mov	r3,r2
81143afc:	e0bffd17 	ldw	r2,-12(fp)
81143b00:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
81143b04:	d0a0b317 	ldw	r2,-32052(gp)
81143b08:	10c00a17 	ldw	r3,40(r2)
81143b0c:	e0bffc17 	ldw	r2,-16(fp)
81143b10:	1885883a 	add	r2,r3,r2
81143b14:	10800584 	addi	r2,r2,22
81143b18:	1080002b 	ldhuio	r2,0(r2)
81143b1c:	10bfffcc 	andi	r2,r2,65535
81143b20:	1007883a 	mov	r3,r2
81143b24:	e0bffd17 	ldw	r2,-12(fp)
81143b28:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
81143b2c:	d0a0b317 	ldw	r2,-32052(gp)
81143b30:	10c00a17 	ldw	r3,40(r2)
81143b34:	e0bffc17 	ldw	r2,-16(fp)
81143b38:	1885883a 	add	r2,r3,r2
81143b3c:	10800604 	addi	r2,r2,24
81143b40:	1080002b 	ldhuio	r2,0(r2)
81143b44:	10bfffcc 	andi	r2,r2,65535
81143b48:	1007883a 	mov	r3,r2
81143b4c:	e0bffd17 	ldw	r2,-12(fp)
81143b50:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
81143b54:	d0a0b317 	ldw	r2,-32052(gp)
81143b58:	10c00a17 	ldw	r3,40(r2)
81143b5c:	e0bffc17 	ldw	r2,-16(fp)
81143b60:	1885883a 	add	r2,r3,r2
81143b64:	10800684 	addi	r2,r2,26
81143b68:	1080002b 	ldhuio	r2,0(r2)
81143b6c:	10bfffcc 	andi	r2,r2,65535
81143b70:	1007883a 	mov	r3,r2
81143b74:	e0bffd17 	ldw	r2,-12(fp)
81143b78:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
81143b7c:	d0a0b317 	ldw	r2,-32052(gp)
81143b80:	10c00a17 	ldw	r3,40(r2)
81143b84:	e0bffc17 	ldw	r2,-16(fp)
81143b88:	1885883a 	add	r2,r3,r2
81143b8c:	10800704 	addi	r2,r2,28
81143b90:	10800037 	ldwio	r2,0(r2)
81143b94:	1007883a 	mov	r3,r2
81143b98:	e0bffd17 	ldw	r2,-12(fp)
81143b9c:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
81143ba0:	e0bffd17 	ldw	r2,-12(fp)
81143ba4:	e0fffe17 	ldw	r3,-8(fp)
81143ba8:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
81143bac:	e0bffd17 	ldw	r2,-12(fp)
81143bb0:	e0ffff17 	ldw	r3,-4(fp)
81143bb4:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
81143bb8:	e0bffc17 	ldw	r2,-16(fp)
81143bbc:	1007883a 	mov	r3,r2
81143bc0:	e0bffd17 	ldw	r2,-12(fp)
81143bc4:	10c00c0d 	sth	r3,48(r2)
		result = true;
81143bc8:	00800044 	movi	r2,1
81143bcc:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
81143bd0:	e0bffa17 	ldw	r2,-24(fp)
}
81143bd4:	e037883a 	mov	sp,fp
81143bd8:	dfc00117 	ldw	ra,4(sp)
81143bdc:	df000017 	ldw	fp,0(sp)
81143be0:	dec00204 	addi	sp,sp,8
81143be4:	f800283a 	ret

81143be8 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
81143be8:	defff904 	addi	sp,sp,-28
81143bec:	de00012e 	bgeu	sp,et,81143bf4 <Write_File_Record_At_Offset+0xc>
81143bf0:	003b68fa 	trap	3
81143bf4:	dfc00615 	stw	ra,24(sp)
81143bf8:	df000515 	stw	fp,20(sp)
81143bfc:	df000504 	addi	fp,sp,20
81143c00:	e13ffe15 	stw	r4,-8(fp)
81143c04:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81143c08:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81143c0c:	e0bffe17 	ldw	r2,-8(fp)
81143c10:	108007cc 	andi	r2,r2,31
81143c14:	1000931e 	bne	r2,zero,81143e64 <Write_File_Record_At_Offset+0x27c>
81143c18:	114620c0 	call	8114620c <alt_up_sd_card_is_Present>
81143c1c:	10009126 	beq	r2,zero,81143e64 <Write_File_Record_At_Offset+0x27c>
81143c20:	d0a0aa17 	ldw	r2,-32088(gp)
81143c24:	10008f26 	beq	r2,zero,81143e64 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81143c28:	e03ffc15 	stw	zero,-16(fp)
81143c2c:	00001f06 	br	81143cac <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
81143c30:	e0bffc17 	ldw	r2,-16(fp)
81143c34:	10800044 	addi	r2,r2,1
81143c38:	e0ffff17 	ldw	r3,-4(fp)
81143c3c:	1885883a 	add	r2,r3,r2
81143c40:	10800003 	ldbu	r2,0(r2)
81143c44:	10803fcc 	andi	r2,r2,255
81143c48:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
81143c4c:	e0bffd0f 	ldh	r2,-12(fp)
81143c50:	1004923a 	slli	r2,r2,8
81143c54:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
81143c58:	e0ffff17 	ldw	r3,-4(fp)
81143c5c:	e0bffc17 	ldw	r2,-16(fp)
81143c60:	1885883a 	add	r2,r3,r2
81143c64:	10800003 	ldbu	r2,0(r2)
81143c68:	10c03fcc 	andi	r3,r2,255
81143c6c:	e0bffd0b 	ldhu	r2,-12(fp)
81143c70:	1884b03a 	or	r2,r3,r2
81143c74:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
81143c78:	e0fffe17 	ldw	r3,-8(fp)
81143c7c:	e0bffc17 	ldw	r2,-16(fp)
81143c80:	1885883a 	add	r2,r3,r2
81143c84:	1007883a 	mov	r3,r2
81143c88:	d0a0b317 	ldw	r2,-32052(gp)
81143c8c:	10800a17 	ldw	r2,40(r2)
81143c90:	1885883a 	add	r2,r3,r2
81143c94:	1007883a 	mov	r3,r2
81143c98:	e0bffd0f 	ldh	r2,-12(fp)
81143c9c:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81143ca0:	e0bffc17 	ldw	r2,-16(fp)
81143ca4:	10800084 	addi	r2,r2,2
81143ca8:	e0bffc15 	stw	r2,-16(fp)
81143cac:	e0bffc17 	ldw	r2,-16(fp)
81143cb0:	10800210 	cmplti	r2,r2,8
81143cb4:	103fde1e 	bne	r2,zero,81143c30 <__reset+0xfb123c30>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81143cb8:	e03ffc15 	stw	zero,-16(fp)
81143cbc:	00001306 	br	81143d0c <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
81143cc0:	e0fffe17 	ldw	r3,-8(fp)
81143cc4:	e0bffc17 	ldw	r2,-16(fp)
81143cc8:	1885883a 	add	r2,r3,r2
81143ccc:	1007883a 	mov	r3,r2
81143cd0:	d0a0b317 	ldw	r2,-32052(gp)
81143cd4:	10800a17 	ldw	r2,40(r2)
81143cd8:	1885883a 	add	r2,r3,r2
81143cdc:	10800204 	addi	r2,r2,8
81143ce0:	1009883a 	mov	r4,r2
81143ce4:	e0ffff17 	ldw	r3,-4(fp)
81143ce8:	e0bffc17 	ldw	r2,-16(fp)
81143cec:	1885883a 	add	r2,r3,r2
81143cf0:	10800204 	addi	r2,r2,8
81143cf4:	10800003 	ldbu	r2,0(r2)
81143cf8:	10803fcc 	andi	r2,r2,255
81143cfc:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81143d00:	e0bffc17 	ldw	r2,-16(fp)
81143d04:	10800044 	addi	r2,r2,1
81143d08:	e0bffc15 	stw	r2,-16(fp)
81143d0c:	e0bffc17 	ldw	r2,-16(fp)
81143d10:	108000d0 	cmplti	r2,r2,3
81143d14:	103fea1e 	bne	r2,zero,81143cc0 <__reset+0xfb123cc0>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
81143d18:	d0a0b317 	ldw	r2,-32052(gp)
81143d1c:	10c00a17 	ldw	r3,40(r2)
81143d20:	e0bffe17 	ldw	r2,-8(fp)
81143d24:	1885883a 	add	r2,r3,r2
81143d28:	108002c4 	addi	r2,r2,11
81143d2c:	1007883a 	mov	r3,r2
81143d30:	e0bfff17 	ldw	r2,-4(fp)
81143d34:	108002c3 	ldbu	r2,11(r2)
81143d38:	10803fcc 	andi	r2,r2,255
81143d3c:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
81143d40:	d0a0b317 	ldw	r2,-32052(gp)
81143d44:	10c00a17 	ldw	r3,40(r2)
81143d48:	e0bffe17 	ldw	r2,-8(fp)
81143d4c:	1885883a 	add	r2,r3,r2
81143d50:	10800384 	addi	r2,r2,14
81143d54:	1007883a 	mov	r3,r2
81143d58:	e0bfff17 	ldw	r2,-4(fp)
81143d5c:	1080030b 	ldhu	r2,12(r2)
81143d60:	10bfffcc 	andi	r2,r2,65535
81143d64:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
81143d68:	d0a0b317 	ldw	r2,-32052(gp)
81143d6c:	10c00a17 	ldw	r3,40(r2)
81143d70:	e0bffe17 	ldw	r2,-8(fp)
81143d74:	1885883a 	add	r2,r3,r2
81143d78:	10800404 	addi	r2,r2,16
81143d7c:	1007883a 	mov	r3,r2
81143d80:	e0bfff17 	ldw	r2,-4(fp)
81143d84:	1080038b 	ldhu	r2,14(r2)
81143d88:	10bfffcc 	andi	r2,r2,65535
81143d8c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
81143d90:	d0a0b317 	ldw	r2,-32052(gp)
81143d94:	10c00a17 	ldw	r3,40(r2)
81143d98:	e0bffe17 	ldw	r2,-8(fp)
81143d9c:	1885883a 	add	r2,r3,r2
81143da0:	10800484 	addi	r2,r2,18
81143da4:	1007883a 	mov	r3,r2
81143da8:	e0bfff17 	ldw	r2,-4(fp)
81143dac:	1080040b 	ldhu	r2,16(r2)
81143db0:	10bfffcc 	andi	r2,r2,65535
81143db4:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
81143db8:	d0a0b317 	ldw	r2,-32052(gp)
81143dbc:	10c00a17 	ldw	r3,40(r2)
81143dc0:	e0bffe17 	ldw	r2,-8(fp)
81143dc4:	1885883a 	add	r2,r3,r2
81143dc8:	10800584 	addi	r2,r2,22
81143dcc:	1007883a 	mov	r3,r2
81143dd0:	e0bfff17 	ldw	r2,-4(fp)
81143dd4:	1080048b 	ldhu	r2,18(r2)
81143dd8:	10bfffcc 	andi	r2,r2,65535
81143ddc:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
81143de0:	d0a0b317 	ldw	r2,-32052(gp)
81143de4:	10c00a17 	ldw	r3,40(r2)
81143de8:	e0bffe17 	ldw	r2,-8(fp)
81143dec:	1885883a 	add	r2,r3,r2
81143df0:	10800604 	addi	r2,r2,24
81143df4:	1007883a 	mov	r3,r2
81143df8:	e0bfff17 	ldw	r2,-4(fp)
81143dfc:	1080050b 	ldhu	r2,20(r2)
81143e00:	10bfffcc 	andi	r2,r2,65535
81143e04:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
81143e08:	d0a0b317 	ldw	r2,-32052(gp)
81143e0c:	10c00a17 	ldw	r3,40(r2)
81143e10:	e0bffe17 	ldw	r2,-8(fp)
81143e14:	1885883a 	add	r2,r3,r2
81143e18:	10800684 	addi	r2,r2,26
81143e1c:	1007883a 	mov	r3,r2
81143e20:	e0bfff17 	ldw	r2,-4(fp)
81143e24:	1080058b 	ldhu	r2,22(r2)
81143e28:	10bfffcc 	andi	r2,r2,65535
81143e2c:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
81143e30:	d0a0b317 	ldw	r2,-32052(gp)
81143e34:	10c00a17 	ldw	r3,40(r2)
81143e38:	e0bffe17 	ldw	r2,-8(fp)
81143e3c:	1885883a 	add	r2,r3,r2
81143e40:	10800704 	addi	r2,r2,28
81143e44:	1007883a 	mov	r3,r2
81143e48:	e0bfff17 	ldw	r2,-4(fp)
81143e4c:	10800617 	ldw	r2,24(r2)
81143e50:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
81143e54:	00800044 	movi	r2,1
81143e58:	d0a0b415 	stw	r2,-32048(gp)
        result = true;
81143e5c:	00800044 	movi	r2,1
81143e60:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
81143e64:	e0bffb17 	ldw	r2,-20(fp)
}
81143e68:	e037883a 	mov	sp,fp
81143e6c:	dfc00117 	ldw	ra,4(sp)
81143e70:	df000017 	ldw	fp,0(sp)
81143e74:	dec00204 	addi	sp,sp,8
81143e78:	f800283a 	ret

81143e7c <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
81143e7c:	defff904 	addi	sp,sp,-28
81143e80:	de00012e 	bgeu	sp,et,81143e88 <Check_for_DOS_FAT+0xc>
81143e84:	003b68fa 	trap	3
81143e88:	dfc00615 	stw	ra,24(sp)
81143e8c:	df000515 	stw	fp,20(sp)
81143e90:	df000504 	addi	fp,sp,20
81143e94:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
81143e98:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
81143e9c:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
81143ea0:	e17fff17 	ldw	r5,-4(fp)
81143ea4:	0009883a 	mov	r4,zero
81143ea8:	11435340 	call	81143534 <Read_Sector_Data>
81143eac:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
81143eb0:	d0a0b317 	ldw	r2,-32052(gp)
81143eb4:	10800a17 	ldw	r2,40(r2)
81143eb8:	10807f84 	addi	r2,r2,510
81143ebc:	1080002b 	ldhuio	r2,0(r2)
81143ec0:	10bfffcc 	andi	r2,r2,65535
81143ec4:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
81143ec8:	e0bffe0f 	ldh	r2,-8(fp)
81143ecc:	10ffffcc 	andi	r3,r2,65535
81143ed0:	00aa9554 	movui	r2,43605
81143ed4:	1881841e 	bne	r3,r2,811444e8 <Check_for_DOS_FAT+0x66c>
81143ed8:	e0bffb17 	ldw	r2,-20(fp)
81143edc:	10018226 	beq	r2,zero,811444e8 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
81143ee0:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
81143ee4:	d0a0b317 	ldw	r2,-32052(gp)
81143ee8:	10800a17 	ldw	r2,40(r2)
81143eec:	10800023 	ldbuio	r2,0(r2)
81143ef0:	10803fcc 	andi	r2,r2,255
81143ef4:	1007883a 	mov	r3,r2
81143ef8:	00a045f4 	movhi	r2,33047
81143efc:	10b82904 	addi	r2,r2,-8028
81143f00:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
81143f04:	d0a0b317 	ldw	r2,-32052(gp)
81143f08:	10800a17 	ldw	r2,40(r2)
81143f0c:	10800044 	addi	r2,r2,1
81143f10:	10800023 	ldbuio	r2,0(r2)
81143f14:	10803fcc 	andi	r2,r2,255
81143f18:	1007883a 	mov	r3,r2
81143f1c:	00a045f4 	movhi	r2,33047
81143f20:	10b82904 	addi	r2,r2,-8028
81143f24:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
81143f28:	d0a0b317 	ldw	r2,-32052(gp)
81143f2c:	10800a17 	ldw	r2,40(r2)
81143f30:	10800084 	addi	r2,r2,2
81143f34:	10800023 	ldbuio	r2,0(r2)
81143f38:	10803fcc 	andi	r2,r2,255
81143f3c:	1007883a 	mov	r3,r2
81143f40:	00a045f4 	movhi	r2,33047
81143f44:	10b82904 	addi	r2,r2,-8028
81143f48:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
81143f4c:	e03ffc15 	stw	zero,-16(fp)
81143f50:	00001106 	br	81143f98 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
81143f54:	d0a0b317 	ldw	r2,-32052(gp)
81143f58:	10c00a17 	ldw	r3,40(r2)
81143f5c:	e0bffc17 	ldw	r2,-16(fp)
81143f60:	1885883a 	add	r2,r3,r2
81143f64:	108000c4 	addi	r2,r2,3
81143f68:	10800023 	ldbuio	r2,0(r2)
81143f6c:	10803fcc 	andi	r2,r2,255
81143f70:	1009883a 	mov	r4,r2
81143f74:	00a045f4 	movhi	r2,33047
81143f78:	10b82904 	addi	r2,r2,-8028
81143f7c:	e0fffc17 	ldw	r3,-16(fp)
81143f80:	10c5883a 	add	r2,r2,r3
81143f84:	108000c4 	addi	r2,r2,3
81143f88:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
81143f8c:	e0bffc17 	ldw	r2,-16(fp)
81143f90:	10800044 	addi	r2,r2,1
81143f94:	e0bffc15 	stw	r2,-16(fp)
81143f98:	e0bffc17 	ldw	r2,-16(fp)
81143f9c:	10800210 	cmplti	r2,r2,8
81143fa0:	103fec1e 	bne	r2,zero,81143f54 <__reset+0xfb123f54>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
81143fa4:	d0a0b317 	ldw	r2,-32052(gp)
81143fa8:	10800a17 	ldw	r2,40(r2)
81143fac:	10800304 	addi	r2,r2,12
81143fb0:	10800023 	ldbuio	r2,0(r2)
81143fb4:	10803fcc 	andi	r2,r2,255
81143fb8:	1004923a 	slli	r2,r2,8
81143fbc:	1007883a 	mov	r3,r2
81143fc0:	d0a0b317 	ldw	r2,-32052(gp)
81143fc4:	10800a17 	ldw	r2,40(r2)
81143fc8:	108002c4 	addi	r2,r2,11
81143fcc:	10800023 	ldbuio	r2,0(r2)
81143fd0:	10803fcc 	andi	r2,r2,255
81143fd4:	10803fcc 	andi	r2,r2,255
81143fd8:	1080201c 	xori	r2,r2,128
81143fdc:	10bfe004 	addi	r2,r2,-128
81143fe0:	1884b03a 	or	r2,r3,r2
81143fe4:	1007883a 	mov	r3,r2
81143fe8:	00a045f4 	movhi	r2,33047
81143fec:	10b82904 	addi	r2,r2,-8028
81143ff0:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
81143ff4:	d0a0b317 	ldw	r2,-32052(gp)
81143ff8:	10800a17 	ldw	r2,40(r2)
81143ffc:	10800344 	addi	r2,r2,13
81144000:	10800023 	ldbuio	r2,0(r2)
81144004:	10803fcc 	andi	r2,r2,255
81144008:	1007883a 	mov	r3,r2
8114400c:	00a045f4 	movhi	r2,33047
81144010:	10b82904 	addi	r2,r2,-8028
81144014:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
81144018:	d0a0b317 	ldw	r2,-32052(gp)
8114401c:	10800a17 	ldw	r2,40(r2)
81144020:	10800384 	addi	r2,r2,14
81144024:	1080002b 	ldhuio	r2,0(r2)
81144028:	10bfffcc 	andi	r2,r2,65535
8114402c:	1007883a 	mov	r3,r2
81144030:	00a045f4 	movhi	r2,33047
81144034:	10b82904 	addi	r2,r2,-8028
81144038:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
8114403c:	d0a0b317 	ldw	r2,-32052(gp)
81144040:	10800a17 	ldw	r2,40(r2)
81144044:	10800404 	addi	r2,r2,16
81144048:	10800023 	ldbuio	r2,0(r2)
8114404c:	10803fcc 	andi	r2,r2,255
81144050:	1007883a 	mov	r3,r2
81144054:	00a045f4 	movhi	r2,33047
81144058:	10b82904 	addi	r2,r2,-8028
8114405c:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
81144060:	d0a0b317 	ldw	r2,-32052(gp)
81144064:	10800a17 	ldw	r2,40(r2)
81144068:	10800484 	addi	r2,r2,18
8114406c:	10800023 	ldbuio	r2,0(r2)
81144070:	10803fcc 	andi	r2,r2,255
81144074:	1004923a 	slli	r2,r2,8
81144078:	1007883a 	mov	r3,r2
8114407c:	d0a0b317 	ldw	r2,-32052(gp)
81144080:	10800a17 	ldw	r2,40(r2)
81144084:	10800444 	addi	r2,r2,17
81144088:	10800023 	ldbuio	r2,0(r2)
8114408c:	10803fcc 	andi	r2,r2,255
81144090:	10803fcc 	andi	r2,r2,255
81144094:	1884b03a 	or	r2,r3,r2
81144098:	1007883a 	mov	r3,r2
8114409c:	00a045f4 	movhi	r2,33047
811440a0:	10b82904 	addi	r2,r2,-8028
811440a4:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
811440a8:	d0a0b317 	ldw	r2,-32052(gp)
811440ac:	10800a17 	ldw	r2,40(r2)
811440b0:	10800504 	addi	r2,r2,20
811440b4:	10800023 	ldbuio	r2,0(r2)
811440b8:	10803fcc 	andi	r2,r2,255
811440bc:	1004923a 	slli	r2,r2,8
811440c0:	1007883a 	mov	r3,r2
811440c4:	d0a0b317 	ldw	r2,-32052(gp)
811440c8:	10800a17 	ldw	r2,40(r2)
811440cc:	108004c4 	addi	r2,r2,19
811440d0:	10800023 	ldbuio	r2,0(r2)
811440d4:	10803fcc 	andi	r2,r2,255
811440d8:	10803fcc 	andi	r2,r2,255
811440dc:	1884b03a 	or	r2,r3,r2
811440e0:	1007883a 	mov	r3,r2
811440e4:	00a045f4 	movhi	r2,33047
811440e8:	10b82904 	addi	r2,r2,-8028
811440ec:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
811440f0:	d0a0b317 	ldw	r2,-32052(gp)
811440f4:	10800a17 	ldw	r2,40(r2)
811440f8:	10800544 	addi	r2,r2,21
811440fc:	10800023 	ldbuio	r2,0(r2)
81144100:	10803fcc 	andi	r2,r2,255
81144104:	1007883a 	mov	r3,r2
81144108:	00a045f4 	movhi	r2,33047
8114410c:	10b82904 	addi	r2,r2,-8028
81144110:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
81144114:	d0a0b317 	ldw	r2,-32052(gp)
81144118:	10800a17 	ldw	r2,40(r2)
8114411c:	10800584 	addi	r2,r2,22
81144120:	1080002b 	ldhuio	r2,0(r2)
81144124:	10bfffcc 	andi	r2,r2,65535
81144128:	1007883a 	mov	r3,r2
8114412c:	00a045f4 	movhi	r2,33047
81144130:	10b82904 	addi	r2,r2,-8028
81144134:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
81144138:	d0a0b317 	ldw	r2,-32052(gp)
8114413c:	10800a17 	ldw	r2,40(r2)
81144140:	10800604 	addi	r2,r2,24
81144144:	1080002b 	ldhuio	r2,0(r2)
81144148:	10bfffcc 	andi	r2,r2,65535
8114414c:	1007883a 	mov	r3,r2
81144150:	00a045f4 	movhi	r2,33047
81144154:	10b82904 	addi	r2,r2,-8028
81144158:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
8114415c:	d0a0b317 	ldw	r2,-32052(gp)
81144160:	10800a17 	ldw	r2,40(r2)
81144164:	10800684 	addi	r2,r2,26
81144168:	1080002b 	ldhuio	r2,0(r2)
8114416c:	10bfffcc 	andi	r2,r2,65535
81144170:	1007883a 	mov	r3,r2
81144174:	00a045f4 	movhi	r2,33047
81144178:	10b82904 	addi	r2,r2,-8028
8114417c:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
81144180:	d0a0b317 	ldw	r2,-32052(gp)
81144184:	10800a17 	ldw	r2,40(r2)
81144188:	10800704 	addi	r2,r2,28
8114418c:	10800037 	ldwio	r2,0(r2)
81144190:	1007883a 	mov	r3,r2
81144194:	00a045f4 	movhi	r2,33047
81144198:	10b82904 	addi	r2,r2,-8028
8114419c:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
811441a0:	d0a0b317 	ldw	r2,-32052(gp)
811441a4:	10800a17 	ldw	r2,40(r2)
811441a8:	10800804 	addi	r2,r2,32
811441ac:	10800037 	ldwio	r2,0(r2)
811441b0:	1007883a 	mov	r3,r2
811441b4:	00a045f4 	movhi	r2,33047
811441b8:	10b82904 	addi	r2,r2,-8028
811441bc:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
811441c0:	d0a0b317 	ldw	r2,-32052(gp)
811441c4:	10800a17 	ldw	r2,40(r2)
811441c8:	10800904 	addi	r2,r2,36
811441cc:	10800023 	ldbuio	r2,0(r2)
811441d0:	10803fcc 	andi	r2,r2,255
811441d4:	1007883a 	mov	r3,r2
811441d8:	00a045f4 	movhi	r2,33047
811441dc:	10b82904 	addi	r2,r2,-8028
811441e0:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
811441e4:	d0a0b317 	ldw	r2,-32052(gp)
811441e8:	10800a17 	ldw	r2,40(r2)
811441ec:	10800944 	addi	r2,r2,37
811441f0:	10800023 	ldbuio	r2,0(r2)
811441f4:	10803fcc 	andi	r2,r2,255
811441f8:	1007883a 	mov	r3,r2
811441fc:	00a045f4 	movhi	r2,33047
81144200:	10b82904 	addi	r2,r2,-8028
81144204:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
81144208:	d0a0b317 	ldw	r2,-32052(gp)
8114420c:	10800a17 	ldw	r2,40(r2)
81144210:	10800984 	addi	r2,r2,38
81144214:	10800023 	ldbuio	r2,0(r2)
81144218:	10803fcc 	andi	r2,r2,255
8114421c:	1007883a 	mov	r3,r2
81144220:	00a045f4 	movhi	r2,33047
81144224:	10b82904 	addi	r2,r2,-8028
81144228:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
8114422c:	00a045f4 	movhi	r2,33047
81144230:	10b82904 	addi	r2,r2,-8028
81144234:	1080040b 	ldhu	r2,16(r2)
81144238:	10ffffcc 	andi	r3,r2,65535
8114423c:	00a045f4 	movhi	r2,33047
81144240:	10b82904 	addi	r2,r2,-8028
81144244:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
81144248:	00a045f4 	movhi	r2,33047
8114424c:	10b82904 	addi	r2,r2,-8028
81144250:	10c01117 	ldw	r3,68(r2)
81144254:	00a045f4 	movhi	r2,33047
81144258:	10b82904 	addi	r2,r2,-8028
8114425c:	1080068b 	ldhu	r2,26(r2)
81144260:	10bfffcc 	andi	r2,r2,65535
81144264:	1887883a 	add	r3,r3,r2
81144268:	00a045f4 	movhi	r2,33047
8114426c:	10b82904 	addi	r2,r2,-8028
81144270:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
81144274:	00a045f4 	movhi	r2,33047
81144278:	10b82904 	addi	r2,r2,-8028
8114427c:	10c01217 	ldw	r3,72(r2)
81144280:	00a045f4 	movhi	r2,33047
81144284:	10b82904 	addi	r2,r2,-8028
81144288:	1080068b 	ldhu	r2,26(r2)
8114428c:	10bfffcc 	andi	r2,r2,65535
81144290:	1887883a 	add	r3,r3,r2
81144294:	00a045f4 	movhi	r2,33047
81144298:	10b82904 	addi	r2,r2,-8028
8114429c:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
811442a0:	00a045f4 	movhi	r2,33047
811442a4:	10b82904 	addi	r2,r2,-8028
811442a8:	10c01317 	ldw	r3,76(r2)
811442ac:	00a045f4 	movhi	r2,33047
811442b0:	10b82904 	addi	r2,r2,-8028
811442b4:	1080050b 	ldhu	r2,20(r2)
811442b8:	10bfffcc 	andi	r2,r2,65535
811442bc:	1008917a 	slli	r4,r2,5
811442c0:	00a045f4 	movhi	r2,33047
811442c4:	10b82904 	addi	r2,r2,-8028
811442c8:	1080030b 	ldhu	r2,12(r2)
811442cc:	10bfffcc 	andi	r2,r2,65535
811442d0:	2085283a 	div	r2,r4,r2
811442d4:	1887883a 	add	r3,r3,r2
811442d8:	00a045f4 	movhi	r2,33047
811442dc:	10b82904 	addi	r2,r2,-8028
811442e0:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
811442e4:	00a045f4 	movhi	r2,33047
811442e8:	10b82904 	addi	r2,r2,-8028
811442ec:	1080058b 	ldhu	r2,22(r2)
811442f0:	10bfffcc 	andi	r2,r2,65535
811442f4:	10000b26 	beq	r2,zero,81144324 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
811442f8:	00a045f4 	movhi	r2,33047
811442fc:	10b82904 	addi	r2,r2,-8028
81144300:	1080058b 	ldhu	r2,22(r2)
81144304:	10ffffcc 	andi	r3,r2,65535
81144308:	00a045f4 	movhi	r2,33047
8114430c:	10b82904 	addi	r2,r2,-8028
81144310:	10800383 	ldbu	r2,14(r2)
81144314:	10803fcc 	andi	r2,r2,255
81144318:	1885283a 	div	r2,r3,r2
8114431c:	e0bffd15 	stw	r2,-12(fp)
81144320:	00000906 	br	81144348 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
81144324:	00a045f4 	movhi	r2,33047
81144328:	10b82904 	addi	r2,r2,-8028
8114432c:	10c00917 	ldw	r3,36(r2)
81144330:	00a045f4 	movhi	r2,33047
81144334:	10b82904 	addi	r2,r2,-8028
81144338:	10800383 	ldbu	r2,14(r2)
8114433c:	10803fcc 	andi	r2,r2,255
81144340:	1885203a 	divu	r2,r3,r2
81144344:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
81144348:	e0bffd17 	ldw	r2,-12(fp)
8114434c:	1083fdc8 	cmpgei	r2,r2,4087
81144350:	1000051e 	bne	r2,zero,81144368 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
81144354:	00a045f4 	movhi	r2,33047
81144358:	10b82904 	addi	r2,r2,-8028
8114435c:	00c00304 	movi	r3,12
81144360:	10c01085 	stb	r3,66(r2)
81144364:	00000c06 	br	81144398 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
81144368:	e0bffd17 	ldw	r2,-12(fp)
8114436c:	00fffb54 	movui	r3,65517
81144370:	18800516 	blt	r3,r2,81144388 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
81144374:	00a045f4 	movhi	r2,33047
81144378:	10b82904 	addi	r2,r2,-8028
8114437c:	00c00404 	movi	r3,16
81144380:	10c01085 	stb	r3,66(r2)
81144384:	00000406 	br	81144398 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
81144388:	00a045f4 	movhi	r2,33047
8114438c:	10b82904 	addi	r2,r2,-8028
81144390:	00c00804 	movi	r3,32
81144394:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
81144398:	e03ffc15 	stw	zero,-16(fp)
8114439c:	00001106 	br	811443e4 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
811443a0:	d0a0b317 	ldw	r2,-32052(gp)
811443a4:	10c00a17 	ldw	r3,40(r2)
811443a8:	e0bffc17 	ldw	r2,-16(fp)
811443ac:	1885883a 	add	r2,r3,r2
811443b0:	108009c4 	addi	r2,r2,39
811443b4:	10800023 	ldbuio	r2,0(r2)
811443b8:	10803fcc 	andi	r2,r2,255
811443bc:	1009883a 	mov	r4,r2
811443c0:	00a045f4 	movhi	r2,33047
811443c4:	10b82904 	addi	r2,r2,-8028
811443c8:	e0fffc17 	ldw	r3,-16(fp)
811443cc:	10c5883a 	add	r2,r2,r3
811443d0:	10800ac4 	addi	r2,r2,43
811443d4:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
811443d8:	e0bffc17 	ldw	r2,-16(fp)
811443dc:	10800044 	addi	r2,r2,1
811443e0:	e0bffc15 	stw	r2,-16(fp)
811443e4:	e0bffc17 	ldw	r2,-16(fp)
811443e8:	10800110 	cmplti	r2,r2,4
811443ec:	103fec1e 	bne	r2,zero,811443a0 <__reset+0xfb1243a0>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
811443f0:	e03ffc15 	stw	zero,-16(fp)
811443f4:	00001106 	br	8114443c <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
811443f8:	d0a0b317 	ldw	r2,-32052(gp)
811443fc:	10c00a17 	ldw	r3,40(r2)
81144400:	e0bffc17 	ldw	r2,-16(fp)
81144404:	1885883a 	add	r2,r3,r2
81144408:	10800ac4 	addi	r2,r2,43
8114440c:	10800023 	ldbuio	r2,0(r2)
81144410:	10803fcc 	andi	r2,r2,255
81144414:	1009883a 	mov	r4,r2
81144418:	00a045f4 	movhi	r2,33047
8114441c:	10b82904 	addi	r2,r2,-8028
81144420:	e0fffc17 	ldw	r3,-16(fp)
81144424:	10c5883a 	add	r2,r2,r3
81144428:	10800bc4 	addi	r2,r2,47
8114442c:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81144430:	e0bffc17 	ldw	r2,-16(fp)
81144434:	10800044 	addi	r2,r2,1
81144438:	e0bffc15 	stw	r2,-16(fp)
8114443c:	e0bffc17 	ldw	r2,-16(fp)
81144440:	108002d0 	cmplti	r2,r2,11
81144444:	103fec1e 	bne	r2,zero,811443f8 <__reset+0xfb1243f8>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81144448:	e03ffc15 	stw	zero,-16(fp)
8114444c:	00001106 	br	81144494 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
81144450:	d0a0b317 	ldw	r2,-32052(gp)
81144454:	10c00a17 	ldw	r3,40(r2)
81144458:	e0bffc17 	ldw	r2,-16(fp)
8114445c:	1885883a 	add	r2,r3,r2
81144460:	10800d84 	addi	r2,r2,54
81144464:	10800023 	ldbuio	r2,0(r2)
81144468:	10803fcc 	andi	r2,r2,255
8114446c:	1009883a 	mov	r4,r2
81144470:	00a045f4 	movhi	r2,33047
81144474:	10b82904 	addi	r2,r2,-8028
81144478:	e0fffc17 	ldw	r3,-16(fp)
8114447c:	10c5883a 	add	r2,r2,r3
81144480:	10800e84 	addi	r2,r2,58
81144484:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81144488:	e0bffc17 	ldw	r2,-16(fp)
8114448c:	10800044 	addi	r2,r2,1
81144490:	e0bffc15 	stw	r2,-16(fp)
81144494:	e0bffc17 	ldw	r2,-16(fp)
81144498:	10800210 	cmplti	r2,r2,8
8114449c:	103fec1e 	bne	r2,zero,81144450 <__reset+0xfb124450>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
811444a0:	e03ffc15 	stw	zero,-16(fp)
811444a4:	00000a06 	br	811444d0 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
811444a8:	00a045f4 	movhi	r2,33047
811444ac:	10b83e04 	addi	r2,r2,-7944
811444b0:	e0fffc17 	ldw	r3,-16(fp)
811444b4:	180691ba 	slli	r3,r3,6
811444b8:	10c5883a 	add	r2,r2,r3
811444bc:	10800f04 	addi	r2,r2,60
811444c0:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
811444c4:	e0bffc17 	ldw	r2,-16(fp)
811444c8:	10800044 	addi	r2,r2,1
811444cc:	e0bffc15 	stw	r2,-16(fp)
811444d0:	e0bffc17 	ldw	r2,-16(fp)
811444d4:	10800510 	cmplti	r2,r2,20
811444d8:	103ff31e 	bne	r2,zero,811444a8 <__reset+0xfb1244a8>
		{
			active_files[counter].in_use = false;
		}
		result = true;
811444dc:	00800044 	movi	r2,1
811444e0:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
811444e4:	00000106 	br	811444ec <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
811444e8:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
811444ec:	e0bffb17 	ldw	r2,-20(fp)
}
811444f0:	e037883a 	mov	sp,fp
811444f4:	dfc00117 	ldw	ra,4(sp)
811444f8:	df000017 	ldw	fp,0(sp)
811444fc:	dec00204 	addi	sp,sp,8
81144500:	f800283a 	ret

81144504 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
81144504:	defffc04 	addi	sp,sp,-16
81144508:	de00012e 	bgeu	sp,et,81144510 <Look_for_FAT16+0xc>
8114450c:	003b68fa 	trap	3
81144510:	dfc00315 	stw	ra,12(sp)
81144514:	df000215 	stw	fp,8(sp)
81144518:	df000204 	addi	fp,sp,8
	bool result = false;
8114451c:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
81144520:	114620c0 	call	8114620c <alt_up_sd_card_is_Present>
81144524:	10002e26 	beq	r2,zero,811445e0 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
81144528:	d0a0ad17 	ldw	r2,-32076(gp)
8114452c:	1080000b 	ldhu	r2,0(r2)
81144530:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
81144534:	d020b115 	stw	zero,-32060(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
81144538:	d020b215 	stw	zero,-32056(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
8114453c:	e0bfff0f 	ldh	r2,-4(fp)
81144540:	10002716 	blt	r2,zero,811445e0 <Look_for_FAT16+0xdc>
81144544:	e0bfff0b 	ldhu	r2,-4(fp)
81144548:	10bfffcc 	andi	r2,r2,65535
8114454c:	1083000c 	andi	r2,r2,3072
81144550:	10830020 	cmpeqi	r2,r2,3072
81144554:	1000221e 	bne	r2,zero,811445e0 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
81144558:	e0bfff0b 	ldhu	r2,-4(fp)
8114455c:	10bfffcc 	andi	r2,r2,65535
81144560:	1083000c 	andi	r2,r2,3072
81144564:	10810018 	cmpnei	r2,r2,1024
81144568:	1000031e 	bne	r2,zero,81144578 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
8114456c:	0009883a 	mov	r4,zero
81144570:	1143e7c0 	call	81143e7c <Check_for_DOS_FAT>
81144574:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
81144578:	e0bfff0b 	ldhu	r2,-4(fp)
8114457c:	10bfffcc 	andi	r2,r2,65535
81144580:	1083000c 	andi	r2,r2,3072
81144584:	1000061e 	bne	r2,zero,811445a0 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
81144588:	11437b80 	call	811437b8 <Check_for_Master_Boot_Record>
8114458c:	10000426 	beq	r2,zero,811445a0 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
81144590:	d0a0b117 	ldw	r2,-32060(gp)
81144594:	1009883a 	mov	r4,r2
81144598:	1143e7c0 	call	81143e7c <Check_for_DOS_FAT>
8114459c:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
811445a0:	e0bffe17 	ldw	r2,-8(fp)
811445a4:	10800058 	cmpnei	r2,r2,1
811445a8:	10000d1e 	bne	r2,zero,811445e0 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
811445ac:	00a045f4 	movhi	r2,33047
811445b0:	10b82904 	addi	r2,r2,-8028
811445b4:	10801083 	ldbu	r2,66(r2)
811445b8:	10803fcc 	andi	r2,r2,255
811445bc:	10800420 	cmpeqi	r2,r2,16
811445c0:	1000021e 	bne	r2,zero,811445cc <Look_for_FAT16+0xc8>
				{
					result = false;
811445c4:	e03ffe15 	stw	zero,-8(fp)
811445c8:	00000506 	br	811445e0 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
811445cc:	00a045f4 	movhi	r2,33047
811445d0:	10b82904 	addi	r2,r2,-8028
811445d4:	1080058b 	ldhu	r2,22(r2)
811445d8:	10bfffcc 	andi	r2,r2,65535
811445dc:	d0a0b215 	stw	r2,-32056(gp)
				}
			}
		}
	}
	return result;
811445e0:	e0bffe17 	ldw	r2,-8(fp)
}
811445e4:	e037883a 	mov	sp,fp
811445e8:	dfc00117 	ldw	ra,4(sp)
811445ec:	df000017 	ldw	fp,0(sp)
811445f0:	dec00204 	addi	sp,sp,8
811445f4:	f800283a 	ret

811445f8 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
811445f8:	defffb04 	addi	sp,sp,-20
811445fc:	de00012e 	bgeu	sp,et,81144604 <filename_to_upper_case+0xc>
81144600:	003b68fa 	trap	3
81144604:	dfc00415 	stw	ra,16(sp)
81144608:	df000315 	stw	fp,12(sp)
8114460c:	df000304 	addi	fp,sp,12
81144610:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
81144614:	e13fff17 	ldw	r4,-4(fp)
81144618:	11244540 	call	81124454 <strlen>
8114461c:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
81144620:	e03ffd15 	stw	zero,-12(fp)
81144624:	00001e06 	br	811446a0 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
81144628:	e0bffd17 	ldw	r2,-12(fp)
8114462c:	e0ffff17 	ldw	r3,-4(fp)
81144630:	1885883a 	add	r2,r3,r2
81144634:	10800003 	ldbu	r2,0(r2)
81144638:	10803fcc 	andi	r2,r2,255
8114463c:	1080201c 	xori	r2,r2,128
81144640:	10bfe004 	addi	r2,r2,-128
81144644:	10801850 	cmplti	r2,r2,97
81144648:	1000121e 	bne	r2,zero,81144694 <filename_to_upper_case+0x9c>
8114464c:	e0bffd17 	ldw	r2,-12(fp)
81144650:	e0ffff17 	ldw	r3,-4(fp)
81144654:	1885883a 	add	r2,r3,r2
81144658:	10800003 	ldbu	r2,0(r2)
8114465c:	10803fcc 	andi	r2,r2,255
81144660:	1080201c 	xori	r2,r2,128
81144664:	10bfe004 	addi	r2,r2,-128
81144668:	10801ec8 	cmpgei	r2,r2,123
8114466c:	1000091e 	bne	r2,zero,81144694 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
81144670:	e0bffd17 	ldw	r2,-12(fp)
81144674:	e0ffff17 	ldw	r3,-4(fp)
81144678:	1885883a 	add	r2,r3,r2
8114467c:	e0fffd17 	ldw	r3,-12(fp)
81144680:	e13fff17 	ldw	r4,-4(fp)
81144684:	20c7883a 	add	r3,r4,r3
81144688:	18c00003 	ldbu	r3,0(r3)
8114468c:	18fff804 	addi	r3,r3,-32
81144690:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
81144694:	e0bffd17 	ldw	r2,-12(fp)
81144698:	10800044 	addi	r2,r2,1
8114469c:	e0bffd15 	stw	r2,-12(fp)
811446a0:	e0fffd17 	ldw	r3,-12(fp)
811446a4:	e0bffe17 	ldw	r2,-8(fp)
811446a8:	18bfdf16 	blt	r3,r2,81144628 <__reset+0xfb124628>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
811446ac:	0001883a 	nop
811446b0:	e037883a 	mov	sp,fp
811446b4:	dfc00117 	ldw	ra,4(sp)
811446b8:	df000017 	ldw	fp,0(sp)
811446bc:	dec00204 	addi	sp,sp,8
811446c0:	f800283a 	ret

811446c4 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
811446c4:	defff804 	addi	sp,sp,-32
811446c8:	de00012e 	bgeu	sp,et,811446d0 <check_file_name_for_FAT16_compliance+0xc>
811446cc:	003b68fa 	trap	3
811446d0:	dfc00715 	stw	ra,28(sp)
811446d4:	df000615 	stw	fp,24(sp)
811446d8:	df000604 	addi	fp,sp,24
811446dc:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
811446e0:	e13fff17 	ldw	r4,-4(fp)
811446e4:	11244540 	call	81124454 <strlen>
811446e8:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
811446ec:	00bfffc4 	movi	r2,-1
811446f0:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
811446f4:	00bfffc4 	movi	r2,-1
811446f8:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
811446fc:	00800044 	movi	r2,1
81144700:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
81144704:	e03ffa15 	stw	zero,-24(fp)
81144708:	00006d06 	br	811448c0 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
8114470c:	e0bffa17 	ldw	r2,-24(fp)
81144710:	e0ffff17 	ldw	r3,-4(fp)
81144714:	1885883a 	add	r2,r3,r2
81144718:	10800003 	ldbu	r2,0(r2)
8114471c:	10803fcc 	andi	r2,r2,255
81144720:	1080201c 	xori	r2,r2,128
81144724:	10bfe004 	addi	r2,r2,-128
81144728:	10800820 	cmpeqi	r2,r2,32
8114472c:	10003e1e 	bne	r2,zero,81144828 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81144730:	e0bffa17 	ldw	r2,-24(fp)
81144734:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
81144738:	e0bffb17 	ldw	r2,-20(fp)
8114473c:	1880121e 	bne	r3,r2,81144788 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81144740:	e0bffa17 	ldw	r2,-24(fp)
81144744:	e0ffff17 	ldw	r3,-4(fp)
81144748:	1885883a 	add	r2,r3,r2
8114474c:	10800003 	ldbu	r2,0(r2)
81144750:	10803fcc 	andi	r2,r2,255
81144754:	1080201c 	xori	r2,r2,128
81144758:	10bfe004 	addi	r2,r2,-128
8114475c:	10801720 	cmpeqi	r2,r2,92
81144760:	1000311e 	bne	r2,zero,81144828 <check_file_name_for_FAT16_compliance+0x164>
81144764:	e0bffa17 	ldw	r2,-24(fp)
81144768:	e0ffff17 	ldw	r3,-4(fp)
8114476c:	1885883a 	add	r2,r3,r2
81144770:	10800003 	ldbu	r2,0(r2)
81144774:	10803fcc 	andi	r2,r2,255
81144778:	1080201c 	xori	r2,r2,128
8114477c:	10bfe004 	addi	r2,r2,-128
81144780:	10800be0 	cmpeqi	r2,r2,47
81144784:	1000281e 	bne	r2,zero,81144828 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81144788:	e0fffa17 	ldw	r3,-24(fp)
8114478c:	e0bffc17 	ldw	r2,-16(fp)
81144790:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81144794:	10800258 	cmpnei	r2,r2,9
81144798:	1000091e 	bne	r2,zero,811447c0 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8114479c:	e0bffa17 	ldw	r2,-24(fp)
811447a0:	e0ffff17 	ldw	r3,-4(fp)
811447a4:	1885883a 	add	r2,r3,r2
811447a8:	10800003 	ldbu	r2,0(r2)
811447ac:	10803fcc 	andi	r2,r2,255
811447b0:	1080201c 	xori	r2,r2,128
811447b4:	10bfe004 	addi	r2,r2,-128
811447b8:	10800b98 	cmpnei	r2,r2,46
811447bc:	10001a1e 	bne	r2,zero,81144828 <check_file_name_for_FAT16_compliance+0x164>
811447c0:	e0fffb17 	ldw	r3,-20(fp)
811447c4:	e0bffc17 	ldw	r2,-16(fp)
811447c8:	18801926 	beq	r3,r2,81144830 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
811447cc:	e0fffa17 	ldw	r3,-24(fp)
811447d0:	e0bffc17 	ldw	r2,-16(fp)
811447d4:	1885c83a 	sub	r2,r3,r2
811447d8:	10800110 	cmplti	r2,r2,4
811447dc:	1000141e 	bne	r2,zero,81144830 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
811447e0:	e0bffa17 	ldw	r2,-24(fp)
811447e4:	e0ffff17 	ldw	r3,-4(fp)
811447e8:	1885883a 	add	r2,r3,r2
811447ec:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
811447f0:	10803fcc 	andi	r2,r2,255
811447f4:	1080201c 	xori	r2,r2,128
811447f8:	10bfe004 	addi	r2,r2,-128
811447fc:	10801720 	cmpeqi	r2,r2,92
81144800:	10000b1e 	bne	r2,zero,81144830 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81144804:	e0bffa17 	ldw	r2,-24(fp)
81144808:	e0ffff17 	ldw	r3,-4(fp)
8114480c:	1885883a 	add	r2,r3,r2
81144810:	10800003 	ldbu	r2,0(r2)
81144814:	10803fcc 	andi	r2,r2,255
81144818:	1080201c 	xori	r2,r2,128
8114481c:	10bfe004 	addi	r2,r2,-128
81144820:	10800be0 	cmpeqi	r2,r2,47
81144824:	1000021e 	bne	r2,zero,81144830 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
81144828:	e03ffd15 	stw	zero,-12(fp)
            break;
8114482c:	00002706 	br	811448cc <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
81144830:	e0bffa17 	ldw	r2,-24(fp)
81144834:	e0ffff17 	ldw	r3,-4(fp)
81144838:	1885883a 	add	r2,r3,r2
8114483c:	10800003 	ldbu	r2,0(r2)
81144840:	10803fcc 	andi	r2,r2,255
81144844:	1080201c 	xori	r2,r2,128
81144848:	10bfe004 	addi	r2,r2,-128
8114484c:	10801720 	cmpeqi	r2,r2,92
81144850:	1000091e 	bne	r2,zero,81144878 <check_file_name_for_FAT16_compliance+0x1b4>
81144854:	e0bffa17 	ldw	r2,-24(fp)
81144858:	e0ffff17 	ldw	r3,-4(fp)
8114485c:	1885883a 	add	r2,r3,r2
81144860:	10800003 	ldbu	r2,0(r2)
81144864:	10803fcc 	andi	r2,r2,255
81144868:	1080201c 	xori	r2,r2,128
8114486c:	10bfe004 	addi	r2,r2,-128
81144870:	10800bd8 	cmpnei	r2,r2,47
81144874:	1000041e 	bne	r2,zero,81144888 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
81144878:	e0bffa17 	ldw	r2,-24(fp)
8114487c:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
81144880:	e0bffa17 	ldw	r2,-24(fp)
81144884:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
81144888:	e0bffa17 	ldw	r2,-24(fp)
8114488c:	e0ffff17 	ldw	r3,-4(fp)
81144890:	1885883a 	add	r2,r3,r2
81144894:	10800003 	ldbu	r2,0(r2)
81144898:	10803fcc 	andi	r2,r2,255
8114489c:	1080201c 	xori	r2,r2,128
811448a0:	10bfe004 	addi	r2,r2,-128
811448a4:	10800b98 	cmpnei	r2,r2,46
811448a8:	1000021e 	bne	r2,zero,811448b4 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
811448ac:	e0bffa17 	ldw	r2,-24(fp)
811448b0:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
811448b4:	e0bffa17 	ldw	r2,-24(fp)
811448b8:	10800044 	addi	r2,r2,1
811448bc:	e0bffa15 	stw	r2,-24(fp)
811448c0:	e0fffa17 	ldw	r3,-24(fp)
811448c4:	e0bffe17 	ldw	r2,-8(fp)
811448c8:	18bf9016 	blt	r3,r2,8114470c <__reset+0xfb12470c>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
811448cc:	e0bffe17 	ldw	r2,-8(fp)
811448d0:	10bfffc4 	addi	r2,r2,-1
811448d4:	e0ffff17 	ldw	r3,-4(fp)
811448d8:	1885883a 	add	r2,r3,r2
811448dc:	10800003 	ldbu	r2,0(r2)
811448e0:	10803fcc 	andi	r2,r2,255
811448e4:	1080201c 	xori	r2,r2,128
811448e8:	10bfe004 	addi	r2,r2,-128
811448ec:	10801720 	cmpeqi	r2,r2,92
811448f0:	10000a1e 	bne	r2,zero,8114491c <check_file_name_for_FAT16_compliance+0x258>
811448f4:	e0bffe17 	ldw	r2,-8(fp)
811448f8:	10bfffc4 	addi	r2,r2,-1
811448fc:	e0ffff17 	ldw	r3,-4(fp)
81144900:	1885883a 	add	r2,r3,r2
81144904:	10800003 	ldbu	r2,0(r2)
81144908:	10803fcc 	andi	r2,r2,255
8114490c:	1080201c 	xori	r2,r2,128
81144910:	10bfe004 	addi	r2,r2,-128
81144914:	10800bd8 	cmpnei	r2,r2,47
81144918:	1000011e 	bne	r2,zero,81144920 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
8114491c:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
81144920:	e0bffd17 	ldw	r2,-12(fp)
}
81144924:	e037883a 	mov	sp,fp
81144928:	dfc00117 	ldw	ra,4(sp)
8114492c:	df000017 	ldw	fp,0(sp)
81144930:	dec00204 	addi	sp,sp,8
81144934:	f800283a 	ret

81144938 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
81144938:	defffb04 	addi	sp,sp,-20
8114493c:	de00012e 	bgeu	sp,et,81144944 <get_dir_divider_location+0xc>
81144940:	003b68fa 	trap	3
81144944:	dfc00415 	stw	ra,16(sp)
81144948:	df000315 	stw	fp,12(sp)
8114494c:	df000304 	addi	fp,sp,12
81144950:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
81144954:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
81144958:	e13fff17 	ldw	r4,-4(fp)
8114495c:	11244540 	call	81124454 <strlen>
81144960:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
81144964:	e03ffd15 	stw	zero,-12(fp)
81144968:	00001506 	br	811449c0 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
8114496c:	e0bffd17 	ldw	r2,-12(fp)
81144970:	e0ffff17 	ldw	r3,-4(fp)
81144974:	1885883a 	add	r2,r3,r2
81144978:	10800003 	ldbu	r2,0(r2)
8114497c:	10803fcc 	andi	r2,r2,255
81144980:	1080201c 	xori	r2,r2,128
81144984:	10bfe004 	addi	r2,r2,-128
81144988:	10801720 	cmpeqi	r2,r2,92
8114498c:	10000f1e 	bne	r2,zero,811449cc <get_dir_divider_location+0x94>
81144990:	e0bffd17 	ldw	r2,-12(fp)
81144994:	e0ffff17 	ldw	r3,-4(fp)
81144998:	1885883a 	add	r2,r3,r2
8114499c:	10800003 	ldbu	r2,0(r2)
811449a0:	10803fcc 	andi	r2,r2,255
811449a4:	1080201c 	xori	r2,r2,128
811449a8:	10bfe004 	addi	r2,r2,-128
811449ac:	10800be0 	cmpeqi	r2,r2,47
811449b0:	1000061e 	bne	r2,zero,811449cc <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
811449b4:	e0bffd17 	ldw	r2,-12(fp)
811449b8:	10800044 	addi	r2,r2,1
811449bc:	e0bffd15 	stw	r2,-12(fp)
811449c0:	e0fffd17 	ldw	r3,-12(fp)
811449c4:	e0bffe17 	ldw	r2,-8(fp)
811449c8:	18bfe816 	blt	r3,r2,8114496c <__reset+0xfb12496c>
        {
            break;
        }
    }
    
    if (index == length)
811449cc:	e0fffd17 	ldw	r3,-12(fp)
811449d0:	e0bffe17 	ldw	r2,-8(fp)
811449d4:	1880021e 	bne	r3,r2,811449e0 <get_dir_divider_location+0xa8>
    {
        index = -1;
811449d8:	00bfffc4 	movi	r2,-1
811449dc:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
811449e0:	e0bffd17 	ldw	r2,-12(fp)
}
811449e4:	e037883a 	mov	sp,fp
811449e8:	dfc00117 	ldw	ra,4(sp)
811449ec:	df000017 	ldw	fp,0(sp)
811449f0:	dec00204 	addi	sp,sp,8
811449f4:	f800283a 	ret

811449f8 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
811449f8:	defffa04 	addi	sp,sp,-24
811449fc:	de00012e 	bgeu	sp,et,81144a04 <match_file_record_to_name_ext+0xc>
81144a00:	003b68fa 	trap	3
81144a04:	df000515 	stw	fp,20(sp)
81144a08:	df000504 	addi	fp,sp,20
81144a0c:	e13ffd15 	stw	r4,-12(fp)
81144a10:	e17ffe15 	stw	r5,-8(fp)
81144a14:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
81144a18:	00800044 	movi	r2,1
81144a1c:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
81144a20:	e03ffc15 	stw	zero,-16(fp)
81144a24:	00004606 	br	81144b40 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
81144a28:	e0fffd17 	ldw	r3,-12(fp)
81144a2c:	e0bffc17 	ldw	r2,-16(fp)
81144a30:	1885883a 	add	r2,r3,r2
81144a34:	10800003 	ldbu	r2,0(r2)
81144a38:	10803fcc 	andi	r2,r2,255
81144a3c:	10801870 	cmpltui	r2,r2,97
81144a40:	1000101e 	bne	r2,zero,81144a84 <match_file_record_to_name_ext+0x8c>
81144a44:	e0fffd17 	ldw	r3,-12(fp)
81144a48:	e0bffc17 	ldw	r2,-16(fp)
81144a4c:	1885883a 	add	r2,r3,r2
81144a50:	10800003 	ldbu	r2,0(r2)
81144a54:	10803fcc 	andi	r2,r2,255
81144a58:	10801ee8 	cmpgeui	r2,r2,123
81144a5c:	1000091e 	bne	r2,zero,81144a84 <match_file_record_to_name_ext+0x8c>
81144a60:	e0fffd17 	ldw	r3,-12(fp)
81144a64:	e0bffc17 	ldw	r2,-16(fp)
81144a68:	1885883a 	add	r2,r3,r2
81144a6c:	10800003 	ldbu	r2,0(r2)
81144a70:	10bff804 	addi	r2,r2,-32
81144a74:	10c03fcc 	andi	r3,r2,255
81144a78:	18c0201c 	xori	r3,r3,128
81144a7c:	18ffe004 	addi	r3,r3,-128
81144a80:	00000706 	br	81144aa0 <match_file_record_to_name_ext+0xa8>
81144a84:	e0fffd17 	ldw	r3,-12(fp)
81144a88:	e0bffc17 	ldw	r2,-16(fp)
81144a8c:	1885883a 	add	r2,r3,r2
81144a90:	10800003 	ldbu	r2,0(r2)
81144a94:	10c03fcc 	andi	r3,r2,255
81144a98:	18c0201c 	xori	r3,r3,128
81144a9c:	18ffe004 	addi	r3,r3,-128
81144aa0:	e0bffc17 	ldw	r2,-16(fp)
81144aa4:	e13ffe17 	ldw	r4,-8(fp)
81144aa8:	2085883a 	add	r2,r4,r2
81144aac:	10800003 	ldbu	r2,0(r2)
81144ab0:	10803fcc 	andi	r2,r2,255
81144ab4:	1080201c 	xori	r2,r2,128
81144ab8:	10bfe004 	addi	r2,r2,-128
81144abc:	10801850 	cmplti	r2,r2,97
81144ac0:	1000121e 	bne	r2,zero,81144b0c <match_file_record_to_name_ext+0x114>
81144ac4:	e0bffc17 	ldw	r2,-16(fp)
81144ac8:	e13ffe17 	ldw	r4,-8(fp)
81144acc:	2085883a 	add	r2,r4,r2
81144ad0:	10800003 	ldbu	r2,0(r2)
81144ad4:	10803fcc 	andi	r2,r2,255
81144ad8:	1080201c 	xori	r2,r2,128
81144adc:	10bfe004 	addi	r2,r2,-128
81144ae0:	10801ec8 	cmpgei	r2,r2,123
81144ae4:	1000091e 	bne	r2,zero,81144b0c <match_file_record_to_name_ext+0x114>
81144ae8:	e0bffc17 	ldw	r2,-16(fp)
81144aec:	e13ffe17 	ldw	r4,-8(fp)
81144af0:	2085883a 	add	r2,r4,r2
81144af4:	10800003 	ldbu	r2,0(r2)
81144af8:	10bff804 	addi	r2,r2,-32
81144afc:	10803fcc 	andi	r2,r2,255
81144b00:	1080201c 	xori	r2,r2,128
81144b04:	10bfe004 	addi	r2,r2,-128
81144b08:	00000706 	br	81144b28 <match_file_record_to_name_ext+0x130>
81144b0c:	e0bffc17 	ldw	r2,-16(fp)
81144b10:	e13ffe17 	ldw	r4,-8(fp)
81144b14:	2085883a 	add	r2,r4,r2
81144b18:	10800003 	ldbu	r2,0(r2)
81144b1c:	10803fcc 	andi	r2,r2,255
81144b20:	1080201c 	xori	r2,r2,128
81144b24:	10bfe004 	addi	r2,r2,-128
81144b28:	18800226 	beq	r3,r2,81144b34 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
81144b2c:	e03ffb15 	stw	zero,-20(fp)
			break;
81144b30:	00000606 	br	81144b4c <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
81144b34:	e0bffc17 	ldw	r2,-16(fp)
81144b38:	10800044 	addi	r2,r2,1
81144b3c:	e0bffc15 	stw	r2,-16(fp)
81144b40:	e0bffc17 	ldw	r2,-16(fp)
81144b44:	10800210 	cmplti	r2,r2,8
81144b48:	103fb71e 	bne	r2,zero,81144a28 <__reset+0xfb124a28>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81144b4c:	e03ffc15 	stw	zero,-16(fp)
81144b50:	00004a06 	br	81144c7c <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
81144b54:	e0fffd17 	ldw	r3,-12(fp)
81144b58:	e0bffc17 	ldw	r2,-16(fp)
81144b5c:	1885883a 	add	r2,r3,r2
81144b60:	10800204 	addi	r2,r2,8
81144b64:	10800003 	ldbu	r2,0(r2)
81144b68:	10803fcc 	andi	r2,r2,255
81144b6c:	10801870 	cmpltui	r2,r2,97
81144b70:	1000121e 	bne	r2,zero,81144bbc <match_file_record_to_name_ext+0x1c4>
81144b74:	e0fffd17 	ldw	r3,-12(fp)
81144b78:	e0bffc17 	ldw	r2,-16(fp)
81144b7c:	1885883a 	add	r2,r3,r2
81144b80:	10800204 	addi	r2,r2,8
81144b84:	10800003 	ldbu	r2,0(r2)
81144b88:	10803fcc 	andi	r2,r2,255
81144b8c:	10801ee8 	cmpgeui	r2,r2,123
81144b90:	10000a1e 	bne	r2,zero,81144bbc <match_file_record_to_name_ext+0x1c4>
81144b94:	e0fffd17 	ldw	r3,-12(fp)
81144b98:	e0bffc17 	ldw	r2,-16(fp)
81144b9c:	1885883a 	add	r2,r3,r2
81144ba0:	10800204 	addi	r2,r2,8
81144ba4:	10800003 	ldbu	r2,0(r2)
81144ba8:	10bff804 	addi	r2,r2,-32
81144bac:	10c03fcc 	andi	r3,r2,255
81144bb0:	18c0201c 	xori	r3,r3,128
81144bb4:	18ffe004 	addi	r3,r3,-128
81144bb8:	00000806 	br	81144bdc <match_file_record_to_name_ext+0x1e4>
81144bbc:	e0fffd17 	ldw	r3,-12(fp)
81144bc0:	e0bffc17 	ldw	r2,-16(fp)
81144bc4:	1885883a 	add	r2,r3,r2
81144bc8:	10800204 	addi	r2,r2,8
81144bcc:	10800003 	ldbu	r2,0(r2)
81144bd0:	10c03fcc 	andi	r3,r2,255
81144bd4:	18c0201c 	xori	r3,r3,128
81144bd8:	18ffe004 	addi	r3,r3,-128
81144bdc:	e0bffc17 	ldw	r2,-16(fp)
81144be0:	e13fff17 	ldw	r4,-4(fp)
81144be4:	2085883a 	add	r2,r4,r2
81144be8:	10800003 	ldbu	r2,0(r2)
81144bec:	10803fcc 	andi	r2,r2,255
81144bf0:	1080201c 	xori	r2,r2,128
81144bf4:	10bfe004 	addi	r2,r2,-128
81144bf8:	10801850 	cmplti	r2,r2,97
81144bfc:	1000121e 	bne	r2,zero,81144c48 <match_file_record_to_name_ext+0x250>
81144c00:	e0bffc17 	ldw	r2,-16(fp)
81144c04:	e13fff17 	ldw	r4,-4(fp)
81144c08:	2085883a 	add	r2,r4,r2
81144c0c:	10800003 	ldbu	r2,0(r2)
81144c10:	10803fcc 	andi	r2,r2,255
81144c14:	1080201c 	xori	r2,r2,128
81144c18:	10bfe004 	addi	r2,r2,-128
81144c1c:	10801ec8 	cmpgei	r2,r2,123
81144c20:	1000091e 	bne	r2,zero,81144c48 <match_file_record_to_name_ext+0x250>
81144c24:	e0bffc17 	ldw	r2,-16(fp)
81144c28:	e13fff17 	ldw	r4,-4(fp)
81144c2c:	2085883a 	add	r2,r4,r2
81144c30:	10800003 	ldbu	r2,0(r2)
81144c34:	10bff804 	addi	r2,r2,-32
81144c38:	10803fcc 	andi	r2,r2,255
81144c3c:	1080201c 	xori	r2,r2,128
81144c40:	10bfe004 	addi	r2,r2,-128
81144c44:	00000706 	br	81144c64 <match_file_record_to_name_ext+0x26c>
81144c48:	e0bffc17 	ldw	r2,-16(fp)
81144c4c:	e13fff17 	ldw	r4,-4(fp)
81144c50:	2085883a 	add	r2,r4,r2
81144c54:	10800003 	ldbu	r2,0(r2)
81144c58:	10803fcc 	andi	r2,r2,255
81144c5c:	1080201c 	xori	r2,r2,128
81144c60:	10bfe004 	addi	r2,r2,-128
81144c64:	18800226 	beq	r3,r2,81144c70 <match_file_record_to_name_ext+0x278>
        {
            match = false;
81144c68:	e03ffb15 	stw	zero,-20(fp)
			break;
81144c6c:	00000606 	br	81144c88 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81144c70:	e0bffc17 	ldw	r2,-16(fp)
81144c74:	10800044 	addi	r2,r2,1
81144c78:	e0bffc15 	stw	r2,-16(fp)
81144c7c:	e0bffc17 	ldw	r2,-16(fp)
81144c80:	108000d0 	cmplti	r2,r2,3
81144c84:	103fb31e 	bne	r2,zero,81144b54 <__reset+0xfb124b54>
        {
            match = false;
			break;
        }
    }
	return match;
81144c88:	e0bffb17 	ldw	r2,-20(fp)
}
81144c8c:	e037883a 	mov	sp,fp
81144c90:	df000017 	ldw	fp,0(sp)
81144c94:	dec00104 	addi	sp,sp,4
81144c98:	f800283a 	ret

81144c9c <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
81144c9c:	deffe704 	addi	sp,sp,-100
81144ca0:	de00012e 	bgeu	sp,et,81144ca8 <get_home_directory_cluster_for_file+0xc>
81144ca4:	003b68fa 	trap	3
81144ca8:	dfc01815 	stw	ra,96(sp)
81144cac:	df001715 	stw	fp,92(sp)
81144cb0:	df001704 	addi	fp,sp,92
81144cb4:	e13ffd15 	stw	r4,-12(fp)
81144cb8:	e17ffe15 	stw	r5,-8(fp)
81144cbc:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
81144cc0:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
81144cc4:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
81144cc8:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
81144ccc:	e13ffd17 	ldw	r4,-12(fp)
81144cd0:	11449380 	call	81144938 <get_dir_divider_location>
81144cd4:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
81144cd8:	00012f06 	br	81145198 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81144cdc:	00800804 	movi	r2,32
81144ce0:	e0bff905 	stb	r2,-28(fp)
81144ce4:	00800804 	movi	r2,32
81144ce8:	e0bff945 	stb	r2,-27(fp)
81144cec:	00800804 	movi	r2,32
81144cf0:	e0bff985 	stb	r2,-26(fp)
81144cf4:	00800804 	movi	r2,32
81144cf8:	e0bff9c5 	stb	r2,-25(fp)
81144cfc:	00800804 	movi	r2,32
81144d00:	e0bffa05 	stb	r2,-24(fp)
81144d04:	00800804 	movi	r2,32
81144d08:	e0bffa45 	stb	r2,-23(fp)
81144d0c:	00800804 	movi	r2,32
81144d10:	e0bffa85 	stb	r2,-22(fp)
81144d14:	00800804 	movi	r2,32
81144d18:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
81144d1c:	00800804 	movi	r2,32
81144d20:	e0bffb05 	stb	r2,-20(fp)
81144d24:	00800804 	movi	r2,32
81144d28:	e0bffb45 	stb	r2,-19(fp)
81144d2c:	00800804 	movi	r2,32
81144d30:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
81144d34:	00bfffc4 	movi	r2,-1
81144d38:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
81144d3c:	e0bfea17 	ldw	r2,-88(fp)
81144d40:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81144d44:	e03fec15 	stw	zero,-80(fp)
81144d48:	00002d06 	br	81144e00 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
81144d4c:	e0ffec17 	ldw	r3,-80(fp)
81144d50:	e0bfed17 	ldw	r2,-76(fp)
81144d54:	1885883a 	add	r2,r3,r2
81144d58:	1007883a 	mov	r3,r2
81144d5c:	e0bffd17 	ldw	r2,-12(fp)
81144d60:	10c5883a 	add	r2,r2,r3
81144d64:	10800003 	ldbu	r2,0(r2)
81144d68:	10803fcc 	andi	r2,r2,255
81144d6c:	1080201c 	xori	r2,r2,128
81144d70:	10bfe004 	addi	r2,r2,-128
81144d74:	10800b98 	cmpnei	r2,r2,46
81144d78:	1000031e 	bne	r2,zero,81144d88 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
81144d7c:	e0bfec17 	ldw	r2,-80(fp)
81144d80:	e0bfee15 	stw	r2,-72(fp)
81144d84:	00001b06 	br	81144df4 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
81144d88:	e0bfee17 	ldw	r2,-72(fp)
81144d8c:	10000c0e 	bge	r2,zero,81144dc0 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
81144d90:	e0ffec17 	ldw	r3,-80(fp)
81144d94:	e0bfed17 	ldw	r2,-76(fp)
81144d98:	1885883a 	add	r2,r3,r2
81144d9c:	1007883a 	mov	r3,r2
81144da0:	e0bffd17 	ldw	r2,-12(fp)
81144da4:	10c5883a 	add	r2,r2,r3
81144da8:	10c00003 	ldbu	r3,0(r2)
81144dac:	e13ff904 	addi	r4,fp,-28
81144db0:	e0bfec17 	ldw	r2,-80(fp)
81144db4:	2085883a 	add	r2,r4,r2
81144db8:	10c00005 	stb	r3,0(r2)
81144dbc:	00000d06 	br	81144df4 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
81144dc0:	e0ffec17 	ldw	r3,-80(fp)
81144dc4:	e0bfee17 	ldw	r2,-72(fp)
81144dc8:	1885c83a 	sub	r2,r3,r2
81144dcc:	e13fec17 	ldw	r4,-80(fp)
81144dd0:	e0ffed17 	ldw	r3,-76(fp)
81144dd4:	20c7883a 	add	r3,r4,r3
81144dd8:	1809883a 	mov	r4,r3
81144ddc:	e0fffd17 	ldw	r3,-12(fp)
81144de0:	1907883a 	add	r3,r3,r4
81144de4:	18c00003 	ldbu	r3,0(r3)
81144de8:	e13ffb04 	addi	r4,fp,-20
81144dec:	2085883a 	add	r2,r4,r2
81144df0:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81144df4:	e0bfec17 	ldw	r2,-80(fp)
81144df8:	10800044 	addi	r2,r2,1
81144dfc:	e0bfec15 	stw	r2,-80(fp)
81144e00:	e0ffec17 	ldw	r3,-80(fp)
81144e04:	e0bfeb17 	ldw	r2,-84(fp)
81144e08:	18bfd016 	blt	r3,r2,81144d4c <__reset+0xfb124d4c>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
81144e0c:	e0bfea17 	ldw	r2,-88(fp)
81144e10:	10005c1e 	bne	r2,zero,81144f84 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81144e14:	00a045f4 	movhi	r2,33047
81144e18:	10b82904 	addi	r2,r2,-8028
81144e1c:	1080050b 	ldhu	r2,20(r2)
81144e20:	10bfffcc 	andi	r2,r2,65535
81144e24:	1006917a 	slli	r3,r2,5
81144e28:	00a045f4 	movhi	r2,33047
81144e2c:	10b82904 	addi	r2,r2,-8028
81144e30:	1080030b 	ldhu	r2,12(r2)
81144e34:	10bfffcc 	andi	r2,r2,65535
81144e38:	1885283a 	div	r2,r3,r2
81144e3c:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81144e40:	e03ff015 	stw	zero,-64(fp)
81144e44:	00003b06 	br	81144f34 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
81144e48:	00a045f4 	movhi	r2,33047
81144e4c:	10b82904 	addi	r2,r2,-8028
81144e50:	10c01317 	ldw	r3,76(r2)
81144e54:	e0bff017 	ldw	r2,-64(fp)
81144e58:	1885883a 	add	r2,r3,r2
81144e5c:	1007883a 	mov	r3,r2
81144e60:	d0a0b117 	ldw	r2,-32060(gp)
81144e64:	100b883a 	mov	r5,r2
81144e68:	1809883a 	mov	r4,r3
81144e6c:	11435340 	call	81143534 <Read_Sector_Data>
81144e70:	10003426 	beq	r2,zero,81144f44 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81144e74:	e03ff115 	stw	zero,-60(fp)
81144e78:	00002506 	br	81144f10 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81144e7c:	e0bff117 	ldw	r2,-60(fp)
81144e80:	1004917a 	slli	r2,r2,5
81144e84:	e0fff017 	ldw	r3,-64(fp)
81144e88:	180f883a 	mov	r7,r3
81144e8c:	000d883a 	mov	r6,zero
81144e90:	e17fff17 	ldw	r5,-4(fp)
81144e94:	1009883a 	mov	r4,r2
81144e98:	11439640 	call	81143964 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81144e9c:	e0bfff17 	ldw	r2,-4(fp)
81144ea0:	10800003 	ldbu	r2,0(r2)
81144ea4:	10803fcc 	andi	r2,r2,255
81144ea8:	10803960 	cmpeqi	r2,r2,229
81144eac:	1000151e 	bne	r2,zero,81144f04 <get_home_directory_cluster_for_file+0x268>
81144eb0:	e0bfff17 	ldw	r2,-4(fp)
81144eb4:	10800003 	ldbu	r2,0(r2)
81144eb8:	10803fcc 	andi	r2,r2,255
81144ebc:	10001126 	beq	r2,zero,81144f04 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81144ec0:	e0fffb04 	addi	r3,fp,-20
81144ec4:	e0bff904 	addi	r2,fp,-28
81144ec8:	180d883a 	mov	r6,r3
81144ecc:	100b883a 	mov	r5,r2
81144ed0:	e13fff17 	ldw	r4,-4(fp)
81144ed4:	11449f80 	call	811449f8 <match_file_record_to_name_ext>
81144ed8:	e0bff815 	stw	r2,-32(fp)
                            if (match)
81144edc:	e0bff817 	ldw	r2,-32(fp)
81144ee0:	10000826 	beq	r2,zero,81144f04 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
81144ee4:	e0bfff17 	ldw	r2,-4(fp)
81144ee8:	1080058b 	ldhu	r2,22(r2)
81144eec:	10bfffcc 	andi	r2,r2,65535
81144ef0:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
81144ef4:	e0bfff17 	ldw	r2,-4(fp)
81144ef8:	00c00044 	movi	r3,1
81144efc:	10c00a15 	stw	r3,40(r2)
                                break;
81144f00:	00000606 	br	81144f1c <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81144f04:	e0bff117 	ldw	r2,-60(fp)
81144f08:	10800044 	addi	r2,r2,1
81144f0c:	e0bff115 	stw	r2,-60(fp)
81144f10:	e0bff117 	ldw	r2,-60(fp)
81144f14:	10800410 	cmplti	r2,r2,16
81144f18:	103fd81e 	bne	r2,zero,81144e7c <__reset+0xfb124e7c>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
81144f1c:	e0ffef17 	ldw	r3,-68(fp)
81144f20:	e0bfea17 	ldw	r2,-88(fp)
81144f24:	1880091e 	bne	r3,r2,81144f4c <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81144f28:	e0bff017 	ldw	r2,-64(fp)
81144f2c:	10800044 	addi	r2,r2,1
81144f30:	e0bff015 	stw	r2,-64(fp)
81144f34:	e0fff017 	ldw	r3,-64(fp)
81144f38:	e0bff717 	ldw	r2,-36(fp)
81144f3c:	18bfc216 	blt	r3,r2,81144e48 <__reset+0xfb124e48>
81144f40:	00000306 	br	81144f50 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
81144f44:	0001883a 	nop
81144f48:	00000106 	br	81144f50 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
81144f4c:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
81144f50:	e0ffef17 	ldw	r3,-68(fp)
81144f54:	e0bfea17 	ldw	r2,-88(fp)
81144f58:	18800826 	beq	r3,r2,81144f7c <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81144f5c:	e0bfef17 	ldw	r2,-68(fp)
81144f60:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81144f64:	e0ffed17 	ldw	r3,-76(fp)
81144f68:	e0bfeb17 	ldw	r2,-84(fp)
81144f6c:	1885883a 	add	r2,r3,r2
81144f70:	10800044 	addi	r2,r2,1
81144f74:	e0bfed15 	stw	r2,-76(fp)
81144f78:	00007d06 	br	81145170 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81144f7c:	0005883a 	mov	r2,zero
81144f80:	00009106 	br	811451c8 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
81144f84:	e0bfea17 	ldw	r2,-88(fp)
81144f88:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81144f8c:	e0bff417 	ldw	r2,-48(fp)
81144f90:	10ffff84 	addi	r3,r2,-2
81144f94:	00a045f4 	movhi	r2,33047
81144f98:	10b82904 	addi	r2,r2,-8028
81144f9c:	10800383 	ldbu	r2,14(r2)
81144fa0:	10803fcc 	andi	r2,r2,255
81144fa4:	1885383a 	mul	r2,r3,r2
81144fa8:	1007883a 	mov	r3,r2
81144fac:	00a045f4 	movhi	r2,33047
81144fb0:	10b82904 	addi	r2,r2,-8028
81144fb4:	10801417 	ldw	r2,80(r2)
81144fb8:	1885883a 	add	r2,r3,r2
81144fbc:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81144fc0:	e03ff215 	stw	zero,-56(fp)
81144fc4:	00003606 	br	811450a0 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81144fc8:	e0fff217 	ldw	r3,-56(fp)
81144fcc:	e0bff517 	ldw	r2,-44(fp)
81144fd0:	1885883a 	add	r2,r3,r2
81144fd4:	d0e0b117 	ldw	r3,-32060(gp)
81144fd8:	180b883a 	mov	r5,r3
81144fdc:	1009883a 	mov	r4,r2
81144fe0:	11435340 	call	81143534 <Read_Sector_Data>
81144fe4:	10003526 	beq	r2,zero,811450bc <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81144fe8:	e03ff315 	stw	zero,-52(fp)
81144fec:	00002306 	br	8114507c <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81144ff0:	e0bff317 	ldw	r2,-52(fp)
81144ff4:	1004917a 	slli	r2,r2,5
81144ff8:	e0fff417 	ldw	r3,-48(fp)
81144ffc:	e13ff217 	ldw	r4,-56(fp)
81145000:	200f883a 	mov	r7,r4
81145004:	180d883a 	mov	r6,r3
81145008:	e17fff17 	ldw	r5,-4(fp)
8114500c:	1009883a 	mov	r4,r2
81145010:	11439640 	call	81143964 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81145014:	e0bfff17 	ldw	r2,-4(fp)
81145018:	10800003 	ldbu	r2,0(r2)
8114501c:	10803fcc 	andi	r2,r2,255
81145020:	10803960 	cmpeqi	r2,r2,229
81145024:	1000121e 	bne	r2,zero,81145070 <get_home_directory_cluster_for_file+0x3d4>
81145028:	e0bfff17 	ldw	r2,-4(fp)
8114502c:	10800003 	ldbu	r2,0(r2)
81145030:	10803fcc 	andi	r2,r2,255
81145034:	10000e26 	beq	r2,zero,81145070 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
81145038:	e0fffb04 	addi	r3,fp,-20
8114503c:	e0bff904 	addi	r2,fp,-28
81145040:	180d883a 	mov	r6,r3
81145044:	100b883a 	mov	r5,r2
81145048:	e13fff17 	ldw	r4,-4(fp)
8114504c:	11449f80 	call	811449f8 <match_file_record_to_name_ext>
81145050:	e0bff615 	stw	r2,-40(fp)
                                if (match)
81145054:	e0bff617 	ldw	r2,-40(fp)
81145058:	10000526 	beq	r2,zero,81145070 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
8114505c:	e0bfff17 	ldw	r2,-4(fp)
81145060:	1080058b 	ldhu	r2,22(r2)
81145064:	10bfffcc 	andi	r2,r2,65535
81145068:	e0bfef15 	stw	r2,-68(fp)
                                    break;
8114506c:	00000606 	br	81145088 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81145070:	e0bff317 	ldw	r2,-52(fp)
81145074:	10800044 	addi	r2,r2,1
81145078:	e0bff315 	stw	r2,-52(fp)
8114507c:	e0bff317 	ldw	r2,-52(fp)
81145080:	10800410 	cmplti	r2,r2,16
81145084:	103fda1e 	bne	r2,zero,81144ff0 <__reset+0xfb124ff0>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
81145088:	e0ffef17 	ldw	r3,-68(fp)
8114508c:	e0bfea17 	ldw	r2,-88(fp)
81145090:	18800c1e 	bne	r3,r2,811450c4 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145094:	e0bff217 	ldw	r2,-56(fp)
81145098:	10800044 	addi	r2,r2,1
8114509c:	e0bff215 	stw	r2,-56(fp)
811450a0:	00a045f4 	movhi	r2,33047
811450a4:	10b82904 	addi	r2,r2,-8028
811450a8:	10800383 	ldbu	r2,14(r2)
811450ac:	10803fcc 	andi	r2,r2,255
811450b0:	e0fff217 	ldw	r3,-56(fp)
811450b4:	18bfc416 	blt	r3,r2,81144fc8 <__reset+0xfb124fc8>
811450b8:	00000306 	br	811450c8 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
811450bc:	0001883a 	nop
811450c0:	00000106 	br	811450c8 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
811450c4:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
811450c8:	e0ffef17 	ldw	r3,-68(fp)
811450cc:	e0bfea17 	ldw	r2,-88(fp)
811450d0:	1880141e 	bne	r3,r2,81145124 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
811450d4:	e0bfef17 	ldw	r2,-68(fp)
811450d8:	e0fffc04 	addi	r3,fp,-16
811450dc:	180b883a 	mov	r5,r3
811450e0:	1009883a 	mov	r4,r2
811450e4:	11436140 	call	81143614 <get_cluster_flag>
811450e8:	10000c26 	beq	r2,zero,8114511c <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
811450ec:	e0bffc0b 	ldhu	r2,-16(fp)
811450f0:	10bfffcc 	andi	r2,r2,65535
811450f4:	10fffe0c 	andi	r3,r2,65528
811450f8:	00bffe14 	movui	r2,65528
811450fc:	1880021e 	bne	r3,r2,81145108 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
81145100:	0005883a 	mov	r2,zero
81145104:	00003006 	br	811451c8 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
81145108:	e0bffc0b 	ldhu	r2,-16(fp)
8114510c:	10bfffcc 	andi	r2,r2,65535
81145110:	10bffe0c 	andi	r2,r2,65528
81145114:	e0bfef15 	stw	r2,-68(fp)
81145118:	00000206 	br	81145124 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
8114511c:	0005883a 	mov	r2,zero
81145120:	00002906 	br	811451c8 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
81145124:	e0bff417 	ldw	r2,-48(fp)
81145128:	00fffdd4 	movui	r3,65527
8114512c:	18800316 	blt	r3,r2,8114513c <get_home_directory_cluster_for_file+0x4a0>
81145130:	e0ffef17 	ldw	r3,-68(fp)
81145134:	e0bfea17 	ldw	r2,-88(fp)
81145138:	18bf9426 	beq	r3,r2,81144f8c <__reset+0xfb124f8c>
            if (new_cluster != home_dir_cluster)
8114513c:	e0ffef17 	ldw	r3,-68(fp)
81145140:	e0bfea17 	ldw	r2,-88(fp)
81145144:	18800826 	beq	r3,r2,81145168 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81145148:	e0bfef17 	ldw	r2,-68(fp)
8114514c:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81145150:	e0ffed17 	ldw	r3,-76(fp)
81145154:	e0bfeb17 	ldw	r2,-84(fp)
81145158:	1885883a 	add	r2,r3,r2
8114515c:	10800044 	addi	r2,r2,1
81145160:	e0bfed15 	stw	r2,-76(fp)
81145164:	00000206 	br	81145170 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81145168:	0005883a 	mov	r2,zero
8114516c:	00001606 	br	811451c8 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
81145170:	e0bfed17 	ldw	r2,-76(fp)
81145174:	e0fffd17 	ldw	r3,-12(fp)
81145178:	1885883a 	add	r2,r3,r2
8114517c:	1009883a 	mov	r4,r2
81145180:	11449380 	call	81144938 <get_dir_divider_location>
81145184:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
81145188:	e0bfeb17 	ldw	r2,-84(fp)
8114518c:	1000020e 	bge	r2,zero,81145198 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
81145190:	00800044 	movi	r2,1
81145194:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
81145198:	e0bfeb17 	ldw	r2,-84(fp)
8114519c:	00becf16 	blt	zero,r2,81144cdc <__reset+0xfb124cdc>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
811451a0:	e0bffe17 	ldw	r2,-8(fp)
811451a4:	e0ffea17 	ldw	r3,-88(fp)
811451a8:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
811451ac:	e0bfea17 	ldw	r2,-88(fp)
811451b0:	1000041e 	bne	r2,zero,811451c4 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
811451b4:	e0bfff17 	ldw	r2,-4(fp)
811451b8:	10000a15 	stw	zero,40(r2)
		result = true;
811451bc:	00800044 	movi	r2,1
811451c0:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
811451c4:	e0bfe917 	ldw	r2,-92(fp)
}
811451c8:	e037883a 	mov	sp,fp
811451cc:	dfc00117 	ldw	ra,4(sp)
811451d0:	df000017 	ldw	fp,0(sp)
811451d4:	dec00204 	addi	sp,sp,8
811451d8:	f800283a 	ret

811451dc <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
811451dc:	deffe804 	addi	sp,sp,-96
811451e0:	de00012e 	bgeu	sp,et,811451e8 <find_file_in_directory+0xc>
811451e4:	003b68fa 	trap	3
811451e8:	dfc01715 	stw	ra,92(sp)
811451ec:	df001615 	stw	fp,88(sp)
811451f0:	df001604 	addi	fp,sp,88
811451f4:	e13ffd15 	stw	r4,-12(fp)
811451f8:	e17ffe15 	stw	r5,-8(fp)
811451fc:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
81145200:	e13ffe17 	ldw	r4,-8(fp)
81145204:	11449380 	call	81144938 <get_dir_divider_location>
81145208:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
8114520c:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81145210:	00800804 	movi	r2,32
81145214:	e0bff905 	stb	r2,-28(fp)
81145218:	00800804 	movi	r2,32
8114521c:	e0bff945 	stb	r2,-27(fp)
81145220:	00800804 	movi	r2,32
81145224:	e0bff985 	stb	r2,-26(fp)
81145228:	00800804 	movi	r2,32
8114522c:	e0bff9c5 	stb	r2,-25(fp)
81145230:	00800804 	movi	r2,32
81145234:	e0bffa05 	stb	r2,-24(fp)
81145238:	00800804 	movi	r2,32
8114523c:	e0bffa45 	stb	r2,-23(fp)
81145240:	00800804 	movi	r2,32
81145244:	e0bffa85 	stb	r2,-22(fp)
81145248:	00800804 	movi	r2,32
8114524c:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
81145250:	00800804 	movi	r2,32
81145254:	e0bffb05 	stb	r2,-20(fp)
81145258:	00800804 	movi	r2,32
8114525c:	e0bffb45 	stb	r2,-19(fp)
81145260:	00800804 	movi	r2,32
81145264:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
81145268:	00bfffc4 	movi	r2,-1
8114526c:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
81145270:	e0bffd17 	ldw	r2,-12(fp)
81145274:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
81145278:	e13ffe17 	ldw	r4,-8(fp)
8114527c:	11244540 	call	81124454 <strlen>
81145280:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
81145284:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
81145288:	00000b06 	br	811452b8 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
8114528c:	e0ffeb17 	ldw	r3,-84(fp)
81145290:	e0bfea17 	ldw	r2,-88(fp)
81145294:	1885883a 	add	r2,r3,r2
81145298:	10800044 	addi	r2,r2,1
8114529c:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
811452a0:	e0bfeb17 	ldw	r2,-84(fp)
811452a4:	e0fffe17 	ldw	r3,-8(fp)
811452a8:	1885883a 	add	r2,r3,r2
811452ac:	1009883a 	mov	r4,r2
811452b0:	11449380 	call	81144938 <get_dir_divider_location>
811452b4:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
811452b8:	e0bfea17 	ldw	r2,-88(fp)
811452bc:	00bff316 	blt	zero,r2,8114528c <__reset+0xfb12528c>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
811452c0:	e0bfeb17 	ldw	r2,-84(fp)
811452c4:	e0bfee15 	stw	r2,-72(fp)
811452c8:	00002706 	br	81145368 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
811452cc:	e0bfee17 	ldw	r2,-72(fp)
811452d0:	e0fffe17 	ldw	r3,-8(fp)
811452d4:	1885883a 	add	r2,r3,r2
811452d8:	10800003 	ldbu	r2,0(r2)
811452dc:	10803fcc 	andi	r2,r2,255
811452e0:	1080201c 	xori	r2,r2,128
811452e4:	10bfe004 	addi	r2,r2,-128
811452e8:	10800b98 	cmpnei	r2,r2,46
811452ec:	1000031e 	bne	r2,zero,811452fc <find_file_in_directory+0x120>
        {
            ext_index = index;
811452f0:	e0bfee17 	ldw	r2,-72(fp)
811452f4:	e0bfec15 	stw	r2,-80(fp)
811452f8:	00001806 	br	8114535c <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
811452fc:	e0bfec17 	ldw	r2,-80(fp)
81145300:	10000b0e 	bge	r2,zero,81145330 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
81145304:	e0ffee17 	ldw	r3,-72(fp)
81145308:	e0bfeb17 	ldw	r2,-84(fp)
8114530c:	1885c83a 	sub	r2,r3,r2
81145310:	e0ffee17 	ldw	r3,-72(fp)
81145314:	e13ffe17 	ldw	r4,-8(fp)
81145318:	20c7883a 	add	r3,r4,r3
8114531c:	18c00003 	ldbu	r3,0(r3)
81145320:	e13ff904 	addi	r4,fp,-28
81145324:	2085883a 	add	r2,r4,r2
81145328:	10c00005 	stb	r3,0(r2)
8114532c:	00000b06 	br	8114535c <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
81145330:	e0ffee17 	ldw	r3,-72(fp)
81145334:	e0bfec17 	ldw	r2,-80(fp)
81145338:	1885c83a 	sub	r2,r3,r2
8114533c:	10bfffc4 	addi	r2,r2,-1
81145340:	e0ffee17 	ldw	r3,-72(fp)
81145344:	e13ffe17 	ldw	r4,-8(fp)
81145348:	20c7883a 	add	r3,r4,r3
8114534c:	18c00003 	ldbu	r3,0(r3)
81145350:	e13ffb04 	addi	r4,fp,-20
81145354:	2085883a 	add	r2,r4,r2
81145358:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8114535c:	e0bfee17 	ldw	r2,-72(fp)
81145360:	10800044 	addi	r2,r2,1
81145364:	e0bfee15 	stw	r2,-72(fp)
81145368:	e0ffee17 	ldw	r3,-72(fp)
8114536c:	e0bff417 	ldw	r2,-48(fp)
81145370:	18bfd616 	blt	r3,r2,811452cc <__reset+0xfb1252cc>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
81145374:	e0bffd17 	ldw	r2,-12(fp)
81145378:	1000461e 	bne	r2,zero,81145494 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8114537c:	00a045f4 	movhi	r2,33047
81145380:	10b82904 	addi	r2,r2,-8028
81145384:	1080050b 	ldhu	r2,20(r2)
81145388:	10bfffcc 	andi	r2,r2,65535
8114538c:	1006917a 	slli	r3,r2,5
81145390:	00a045f4 	movhi	r2,33047
81145394:	10b82904 	addi	r2,r2,-8028
81145398:	1080030b 	ldhu	r2,12(r2)
8114539c:	10bfffcc 	andi	r2,r2,65535
811453a0:	1885283a 	div	r2,r3,r2
811453a4:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811453a8:	e03ff015 	stw	zero,-64(fp)
811453ac:	00003506 	br	81145484 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811453b0:	00a045f4 	movhi	r2,33047
811453b4:	10b82904 	addi	r2,r2,-8028
811453b8:	10c01317 	ldw	r3,76(r2)
811453bc:	e0bff017 	ldw	r2,-64(fp)
811453c0:	1885883a 	add	r2,r3,r2
811453c4:	1007883a 	mov	r3,r2
811453c8:	d0a0b117 	ldw	r2,-32060(gp)
811453cc:	100b883a 	mov	r5,r2
811453d0:	1809883a 	mov	r4,r3
811453d4:	11435340 	call	81143534 <Read_Sector_Data>
811453d8:	10009626 	beq	r2,zero,81145634 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811453dc:	e03ff115 	stw	zero,-60(fp)
811453e0:	00002006 	br	81145464 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
811453e4:	e0bff117 	ldw	r2,-60(fp)
811453e8:	1004917a 	slli	r2,r2,5
811453ec:	e0fff017 	ldw	r3,-64(fp)
811453f0:	180f883a 	mov	r7,r3
811453f4:	000d883a 	mov	r6,zero
811453f8:	e17fff17 	ldw	r5,-4(fp)
811453fc:	1009883a 	mov	r4,r2
81145400:	11439640 	call	81143964 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81145404:	e0bfff17 	ldw	r2,-4(fp)
81145408:	10800003 	ldbu	r2,0(r2)
8114540c:	10803fcc 	andi	r2,r2,255
81145410:	10803960 	cmpeqi	r2,r2,229
81145414:	1000101e 	bne	r2,zero,81145458 <find_file_in_directory+0x27c>
81145418:	e0bfff17 	ldw	r2,-4(fp)
8114541c:	10800003 	ldbu	r2,0(r2)
81145420:	10803fcc 	andi	r2,r2,255
81145424:	10000c26 	beq	r2,zero,81145458 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
81145428:	e0fffb04 	addi	r3,fp,-20
8114542c:	e0bff904 	addi	r2,fp,-28
81145430:	180d883a 	mov	r6,r3
81145434:	100b883a 	mov	r5,r2
81145438:	e13fff17 	ldw	r4,-4(fp)
8114543c:	11449f80 	call	811449f8 <match_file_record_to_name_ext>
81145440:	e0bff815 	stw	r2,-32(fp)

                        if (match)
81145444:	e0bff817 	ldw	r2,-32(fp)
81145448:	10000326 	beq	r2,zero,81145458 <find_file_in_directory+0x27c>
                        {
                            result = true;
8114544c:	00800044 	movi	r2,1
81145450:	e0bfef15 	stw	r2,-68(fp)
                            break;
81145454:	00000606 	br	81145470 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81145458:	e0bff117 	ldw	r2,-60(fp)
8114545c:	10800044 	addi	r2,r2,1
81145460:	e0bff115 	stw	r2,-60(fp)
81145464:	e0bff117 	ldw	r2,-60(fp)
81145468:	10800410 	cmplti	r2,r2,16
8114546c:	103fdd1e 	bne	r2,zero,811453e4 <__reset+0xfb1253e4>
            }
            else
            {
                break;
            }
            if (result)
81145470:	e0bfef17 	ldw	r2,-68(fp)
81145474:	1000711e 	bne	r2,zero,8114563c <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81145478:	e0bff017 	ldw	r2,-64(fp)
8114547c:	10800044 	addi	r2,r2,1
81145480:	e0bff015 	stw	r2,-64(fp)
81145484:	e0fff017 	ldw	r3,-64(fp)
81145488:	e0bff717 	ldw	r2,-36(fp)
8114548c:	18bfc816 	blt	r3,r2,811453b0 <__reset+0xfb1253b0>
81145490:	00006b06 	br	81145640 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81145494:	e0bfed17 	ldw	r2,-76(fp)
81145498:	10ffff84 	addi	r3,r2,-2
8114549c:	00a045f4 	movhi	r2,33047
811454a0:	10b82904 	addi	r2,r2,-8028
811454a4:	10800383 	ldbu	r2,14(r2)
811454a8:	10803fcc 	andi	r2,r2,255
811454ac:	1885383a 	mul	r2,r3,r2
811454b0:	1007883a 	mov	r3,r2
811454b4:	00a045f4 	movhi	r2,33047
811454b8:	10b82904 	addi	r2,r2,-8028
811454bc:	10801417 	ldw	r2,80(r2)
811454c0:	1885883a 	add	r2,r3,r2
811454c4:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811454c8:	e03ff215 	stw	zero,-56(fp)
811454cc:	00003306 	br	8114559c <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811454d0:	e0fff217 	ldw	r3,-56(fp)
811454d4:	e0bff517 	ldw	r2,-44(fp)
811454d8:	1885883a 	add	r2,r3,r2
811454dc:	d0e0b117 	ldw	r3,-32060(gp)
811454e0:	180b883a 	mov	r5,r3
811454e4:	1009883a 	mov	r4,r2
811454e8:	11435340 	call	81143534 <Read_Sector_Data>
811454ec:	10003226 	beq	r2,zero,811455b8 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
811454f0:	e03ff315 	stw	zero,-52(fp)
811454f4:	00002106 	br	8114557c <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
811454f8:	e0bff317 	ldw	r2,-52(fp)
811454fc:	1004917a 	slli	r2,r2,5
81145500:	e0ffed17 	ldw	r3,-76(fp)
81145504:	e13ff217 	ldw	r4,-56(fp)
81145508:	200f883a 	mov	r7,r4
8114550c:	180d883a 	mov	r6,r3
81145510:	e17fff17 	ldw	r5,-4(fp)
81145514:	1009883a 	mov	r4,r2
81145518:	11439640 	call	81143964 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8114551c:	e0bfff17 	ldw	r2,-4(fp)
81145520:	10800003 	ldbu	r2,0(r2)
81145524:	10803fcc 	andi	r2,r2,255
81145528:	10803960 	cmpeqi	r2,r2,229
8114552c:	1000101e 	bne	r2,zero,81145570 <find_file_in_directory+0x394>
81145530:	e0bfff17 	ldw	r2,-4(fp)
81145534:	10800003 	ldbu	r2,0(r2)
81145538:	10803fcc 	andi	r2,r2,255
8114553c:	10000c26 	beq	r2,zero,81145570 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81145540:	e0fffb04 	addi	r3,fp,-20
81145544:	e0bff904 	addi	r2,fp,-28
81145548:	180d883a 	mov	r6,r3
8114554c:	100b883a 	mov	r5,r2
81145550:	e13fff17 	ldw	r4,-4(fp)
81145554:	11449f80 	call	811449f8 <match_file_record_to_name_ext>
81145558:	e0bff615 	stw	r2,-40(fp)

                            if (match)
8114555c:	e0bff617 	ldw	r2,-40(fp)
81145560:	10000326 	beq	r2,zero,81145570 <find_file_in_directory+0x394>
                            {                               
                                result = true;
81145564:	00800044 	movi	r2,1
81145568:	e0bfef15 	stw	r2,-68(fp)
                                break;
8114556c:	00000606 	br	81145588 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81145570:	e0bff317 	ldw	r2,-52(fp)
81145574:	10800044 	addi	r2,r2,1
81145578:	e0bff315 	stw	r2,-52(fp)
8114557c:	e0bff317 	ldw	r2,-52(fp)
81145580:	10800410 	cmplti	r2,r2,16
81145584:	103fdc1e 	bne	r2,zero,811454f8 <__reset+0xfb1254f8>
                }
                else
                {
                    break;
                }
                if (result)
81145588:	e0bfef17 	ldw	r2,-68(fp)
8114558c:	10000c1e 	bne	r2,zero,811455c0 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145590:	e0bff217 	ldw	r2,-56(fp)
81145594:	10800044 	addi	r2,r2,1
81145598:	e0bff215 	stw	r2,-56(fp)
8114559c:	00a045f4 	movhi	r2,33047
811455a0:	10b82904 	addi	r2,r2,-8028
811455a4:	10800383 	ldbu	r2,14(r2)
811455a8:	10803fcc 	andi	r2,r2,255
811455ac:	e0fff217 	ldw	r3,-56(fp)
811455b0:	18bfc716 	blt	r3,r2,811454d0 <__reset+0xfb1254d0>
811455b4:	00000306 	br	811455c4 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
811455b8:	0001883a 	nop
811455bc:	00000106 	br	811455c4 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
811455c0:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
811455c4:	e0bfef17 	ldw	r2,-68(fp)
811455c8:	1000141e 	bne	r2,zero,8114561c <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
811455cc:	e0bfed17 	ldw	r2,-76(fp)
811455d0:	e0fffc04 	addi	r3,fp,-16
811455d4:	180b883a 	mov	r5,r3
811455d8:	1009883a 	mov	r4,r2
811455dc:	11436140 	call	81143614 <get_cluster_flag>
811455e0:	10000c26 	beq	r2,zero,81145614 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
811455e4:	e0bffc0b 	ldhu	r2,-16(fp)
811455e8:	10bfffcc 	andi	r2,r2,65535
811455ec:	10fffe0c 	andi	r3,r2,65528
811455f0:	00bffe14 	movui	r2,65528
811455f4:	1880021e 	bne	r3,r2,81145600 <find_file_in_directory+0x424>
					{
						return false;
811455f8:	0005883a 	mov	r2,zero
811455fc:	00001106 	br	81145644 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
81145600:	e0bffc0b 	ldhu	r2,-16(fp)
81145604:	10bfffcc 	andi	r2,r2,65535
81145608:	10bffe0c 	andi	r2,r2,65528
8114560c:	e0bfed15 	stw	r2,-76(fp)
81145610:	00000206 	br	8114561c <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
81145614:	0005883a 	mov	r2,zero
81145618:	00000a06 	br	81145644 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
8114561c:	e0bfed17 	ldw	r2,-76(fp)
81145620:	00fffdd4 	movui	r3,65527
81145624:	18800616 	blt	r3,r2,81145640 <find_file_in_directory+0x464>
81145628:	e0bfef17 	ldw	r2,-68(fp)
8114562c:	103f9926 	beq	r2,zero,81145494 <__reset+0xfb125494>
81145630:	00000306 	br	81145640 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
81145634:	0001883a 	nop
81145638:	00000106 	br	81145640 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
8114563c:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
81145640:	e0bfef17 	ldw	r2,-68(fp)
}
81145644:	e037883a 	mov	sp,fp
81145648:	dfc00117 	ldw	ra,4(sp)
8114564c:	df000017 	ldw	fp,0(sp)
81145650:	dec00204 	addi	sp,sp,8
81145654:	f800283a 	ret

81145658 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
81145658:	defff504 	addi	sp,sp,-44
8114565c:	de00012e 	bgeu	sp,et,81145664 <find_first_empty_cluster+0xc>
81145660:	003b68fa 	trap	3
81145664:	dfc00a15 	stw	ra,40(sp)
81145668:	df000915 	stw	fp,36(sp)
8114566c:	df000904 	addi	fp,sp,36
81145670:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
81145674:	00a045f4 	movhi	r2,33047
81145678:	10b82904 	addi	r2,r2,-8028
8114567c:	10801117 	ldw	r2,68(r2)
81145680:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
81145684:	00800084 	movi	r2,2
81145688:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
8114568c:	00bfffc4 	movi	r2,-1
81145690:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
81145694:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
81145698:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
8114569c:	00a045f4 	movhi	r2,33047
811456a0:	10b82904 	addi	r2,r2,-8028
811456a4:	10801417 	ldw	r2,80(r2)
811456a8:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
811456ac:	00a045f4 	movhi	r2,33047
811456b0:	10b82904 	addi	r2,r2,-8028
811456b4:	1080058b 	ldhu	r2,22(r2)
811456b8:	10bfffcc 	andi	r2,r2,65535
811456bc:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
811456c0:	00a045f4 	movhi	r2,33047
811456c4:	10b82904 	addi	r2,r2,-8028
811456c8:	10800917 	ldw	r2,36(r2)
811456cc:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
811456d0:	e0bffd17 	ldw	r2,-12(fp)
811456d4:	e0fffe17 	ldw	r3,-8(fp)
811456d8:	18800b2e 	bgeu	r3,r2,81145708 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
811456dc:	e0fffd17 	ldw	r3,-12(fp)
811456e0:	e0bffc17 	ldw	r2,-16(fp)
811456e4:	1887c83a 	sub	r3,r3,r2
811456e8:	00a045f4 	movhi	r2,33047
811456ec:	10b82904 	addi	r2,r2,-8028
811456f0:	10800383 	ldbu	r2,14(r2)
811456f4:	10803fcc 	andi	r2,r2,255
811456f8:	1885203a 	divu	r2,r3,r2
811456fc:	10800044 	addi	r2,r2,1
81145700:	e0bffb15 	stw	r2,-20(fp)
81145704:	00002a06 	br	811457b0 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81145708:	e0fffe17 	ldw	r3,-8(fp)
8114570c:	e0bffc17 	ldw	r2,-16(fp)
81145710:	1887c83a 	sub	r3,r3,r2
81145714:	00a045f4 	movhi	r2,33047
81145718:	10b82904 	addi	r2,r2,-8028
8114571c:	10800383 	ldbu	r2,14(r2)
81145720:	10803fcc 	andi	r2,r2,255
81145724:	1885203a 	divu	r2,r3,r2
81145728:	10800044 	addi	r2,r2,1
8114572c:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81145730:	00001f06 	br	811457b0 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
81145734:	e0bff717 	ldw	r2,-36(fp)
81145738:	d0e0b117 	ldw	r3,-32060(gp)
8114573c:	180b883a 	mov	r5,r3
81145740:	1009883a 	mov	r4,r2
81145744:	11435340 	call	81143534 <Read_Sector_Data>
81145748:	10001426 	beq	r2,zero,8114579c <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
8114574c:	e0bff817 	ldw	r2,-32(fp)
81145750:	10803fcc 	andi	r2,r2,255
81145754:	1085883a 	add	r2,r2,r2
81145758:	1007883a 	mov	r3,r2
8114575c:	d0a0b317 	ldw	r2,-32052(gp)
81145760:	10800a17 	ldw	r2,40(r2)
81145764:	1885883a 	add	r2,r3,r2
81145768:	1080002b 	ldhuio	r2,0(r2)
8114576c:	10bfffcc 	andi	r2,r2,65535
81145770:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
81145774:	e0bff90f 	ldh	r2,-28(fp)
81145778:	10000726 	beq	r2,zero,81145798 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
8114577c:	e0bff817 	ldw	r2,-32(fp)
81145780:	10800044 	addi	r2,r2,1
81145784:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
81145788:	e0bff817 	ldw	r2,-32(fp)
8114578c:	10803fcc 	andi	r2,r2,255
81145790:	103fee1e 	bne	r2,zero,8114574c <__reset+0xfb12574c>
81145794:	00000106 	br	8114579c <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
81145798:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
8114579c:	e0bff90f 	ldh	r2,-28(fp)
811457a0:	10000926 	beq	r2,zero,811457c8 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
811457a4:	e0bff717 	ldw	r2,-36(fp)
811457a8:	10800044 	addi	r2,r2,1
811457ac:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
811457b0:	00a045f4 	movhi	r2,33047
811457b4:	10b82904 	addi	r2,r2,-8028
811457b8:	10c01217 	ldw	r3,72(r2)
811457bc:	e0bff717 	ldw	r2,-36(fp)
811457c0:	18bfdc1e 	bne	r3,r2,81145734 <__reset+0xfb125734>
811457c4:	00000106 	br	811457cc <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
811457c8:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
811457cc:	e0bff90f 	ldh	r2,-28(fp)
811457d0:	1000081e 	bne	r2,zero,811457f4 <find_first_empty_cluster+0x19c>
811457d4:	e0bff90f 	ldh	r2,-28(fp)
811457d8:	e0fffb17 	ldw	r3,-20(fp)
811457dc:	18800536 	bltu	r3,r2,811457f4 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
811457e0:	e0bfff17 	ldw	r2,-4(fp)
811457e4:	e0fff817 	ldw	r3,-32(fp)
811457e8:	10c00015 	stw	r3,0(r2)
		result = true;
811457ec:	00800044 	movi	r2,1
811457f0:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
811457f4:	e0bffa17 	ldw	r2,-24(fp)
}
811457f8:	e037883a 	mov	sp,fp
811457fc:	dfc00117 	ldw	ra,4(sp)
81145800:	df000017 	ldw	fp,0(sp)
81145804:	dec00204 	addi	sp,sp,8
81145808:	f800283a 	ret

8114580c <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
8114580c:	defff604 	addi	sp,sp,-40
81145810:	de00012e 	bgeu	sp,et,81145818 <find_first_empty_record_in_a_subdirectory+0xc>
81145814:	003b68fa 	trap	3
81145818:	dfc00915 	stw	ra,36(sp)
8114581c:	df000815 	stw	fp,32(sp)
81145820:	df000804 	addi	fp,sp,32
81145824:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
81145828:	00bfffc4 	movi	r2,-1
8114582c:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
81145830:	e0bfff17 	ldw	r2,-4(fp)
81145834:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81145838:	e0bff917 	ldw	r2,-28(fp)
8114583c:	10ffff84 	addi	r3,r2,-2
81145840:	00a045f4 	movhi	r2,33047
81145844:	10b82904 	addi	r2,r2,-8028
81145848:	10800383 	ldbu	r2,14(r2)
8114584c:	10803fcc 	andi	r2,r2,255
81145850:	1885383a 	mul	r2,r3,r2
81145854:	1007883a 	mov	r3,r2
81145858:	00a045f4 	movhi	r2,33047
8114585c:	10b82904 	addi	r2,r2,-8028
81145860:	10801417 	ldw	r2,80(r2)
81145864:	1885883a 	add	r2,r3,r2
81145868:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8114586c:	e03ffa15 	stw	zero,-24(fp)
81145870:	00002c06 	br	81145924 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81145874:	e0fffa17 	ldw	r3,-24(fp)
81145878:	e0bffc17 	ldw	r2,-16(fp)
8114587c:	1885883a 	add	r2,r3,r2
81145880:	d0e0b117 	ldw	r3,-32060(gp)
81145884:	180b883a 	mov	r5,r3
81145888:	1009883a 	mov	r4,r2
8114588c:	11435340 	call	81143534 <Read_Sector_Data>
81145890:	10002b26 	beq	r2,zero,81145940 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81145894:	e03ffb15 	stw	zero,-20(fp)
81145898:	00001c06 	br	8114590c <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8114589c:	e0bffb17 	ldw	r2,-20(fp)
811458a0:	1004917a 	slli	r2,r2,5
811458a4:	1007883a 	mov	r3,r2
811458a8:	d0a0b317 	ldw	r2,-32052(gp)
811458ac:	10800a17 	ldw	r2,40(r2)
811458b0:	1885883a 	add	r2,r3,r2
811458b4:	10800023 	ldbuio	r2,0(r2)
811458b8:	10803fcc 	andi	r2,r2,255
811458bc:	10803fcc 	andi	r2,r2,255
811458c0:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
811458c4:	e0bffd0b 	ldhu	r2,-12(fp)
811458c8:	10803960 	cmpeqi	r2,r2,229
811458cc:	1000021e 	bne	r2,zero,811458d8 <find_first_empty_record_in_a_subdirectory+0xcc>
811458d0:	e0bffd0b 	ldhu	r2,-12(fp)
811458d4:	10000a1e 	bne	r2,zero,81145900 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
811458d8:	e0bffa17 	ldw	r2,-24(fp)
811458dc:	1006913a 	slli	r3,r2,4
811458e0:	e0bffb17 	ldw	r2,-20(fp)
811458e4:	1885883a 	add	r2,r3,r2
811458e8:	1006943a 	slli	r3,r2,16
811458ec:	e0bff917 	ldw	r2,-28(fp)
811458f0:	1884b03a 	or	r2,r3,r2
811458f4:	e0bff815 	stw	r2,-32(fp)
                        return result;
811458f8:	e0bff817 	ldw	r2,-32(fp)
811458fc:	00005306 	br	81145a4c <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81145900:	e0bffb17 	ldw	r2,-20(fp)
81145904:	10800044 	addi	r2,r2,1
81145908:	e0bffb15 	stw	r2,-20(fp)
8114590c:	e0bffb17 	ldw	r2,-20(fp)
81145910:	10800410 	cmplti	r2,r2,16
81145914:	103fe11e 	bne	r2,zero,8114589c <__reset+0xfb12589c>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81145918:	e0bffa17 	ldw	r2,-24(fp)
8114591c:	10800044 	addi	r2,r2,1
81145920:	e0bffa15 	stw	r2,-24(fp)
81145924:	00a045f4 	movhi	r2,33047
81145928:	10b82904 	addi	r2,r2,-8028
8114592c:	10800383 	ldbu	r2,14(r2)
81145930:	10803fcc 	andi	r2,r2,255
81145934:	e0fffa17 	ldw	r3,-24(fp)
81145938:	18bfce16 	blt	r3,r2,81145874 <__reset+0xfb125874>
8114593c:	00000106 	br	81145944 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
81145940:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
81145944:	e0bff817 	ldw	r2,-32(fp)
81145948:	1000390e 	bge	r2,zero,81145a30 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
8114594c:	e0bff917 	ldw	r2,-28(fp)
81145950:	e0fffd84 	addi	r3,fp,-10
81145954:	180b883a 	mov	r5,r3
81145958:	1009883a 	mov	r4,r2
8114595c:	11436140 	call	81143614 <get_cluster_flag>
81145960:	10003126 	beq	r2,zero,81145a28 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81145964:	e0bffd8b 	ldhu	r2,-10(fp)
81145968:	10bfffcc 	andi	r2,r2,65535
8114596c:	10fffe0c 	andi	r3,r2,65528
81145970:	00bffe14 	movui	r2,65528
81145974:	18802e1e 	bne	r3,r2,81145a30 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
81145978:	e0bffe04 	addi	r2,fp,-8
8114597c:	1009883a 	mov	r4,r2
81145980:	11456580 	call	81145658 <find_first_empty_cluster>
81145984:	10002326 	beq	r2,zero,81145a14 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81145988:	e0bff917 	ldw	r2,-28(fp)
8114598c:	e0fffe17 	ldw	r3,-8(fp)
81145990:	18ffffcc 	andi	r3,r3,65535
81145994:	18e0001c 	xori	r3,r3,32768
81145998:	18e00004 	addi	r3,r3,-32768
8114599c:	01800044 	movi	r6,1
811459a0:	180b883a 	mov	r5,r3
811459a4:	1009883a 	mov	r4,r2
811459a8:	11436d00 	call	811436d0 <mark_cluster>
811459ac:	10001926 	beq	r2,zero,81145a14 <find_first_empty_record_in_a_subdirectory+0x208>
811459b0:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
811459b4:	01800044 	movi	r6,1
811459b8:	017fffc4 	movi	r5,-1
811459bc:	1009883a 	mov	r4,r2
811459c0:	11436d00 	call	811436d0 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
811459c4:	10001326 	beq	r2,zero,81145a14 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811459c8:	e0bff917 	ldw	r2,-28(fp)
811459cc:	e0fffe17 	ldw	r3,-8(fp)
811459d0:	18ffffcc 	andi	r3,r3,65535
811459d4:	18e0001c 	xori	r3,r3,32768
811459d8:	18e00004 	addi	r3,r3,-32768
811459dc:	000d883a 	mov	r6,zero
811459e0:	180b883a 	mov	r5,r3
811459e4:	1009883a 	mov	r4,r2
811459e8:	11436d00 	call	811436d0 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
811459ec:	10000926 	beq	r2,zero,81145a14 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811459f0:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
811459f4:	000d883a 	mov	r6,zero
811459f8:	017fffc4 	movi	r5,-1
811459fc:	1009883a 	mov	r4,r2
81145a00:	11436d00 	call	811436d0 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81145a04:	10000326 	beq	r2,zero,81145a14 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
81145a08:	11434e00 	call	811434e0 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
81145a0c:	e0bffe17 	ldw	r2,-8(fp)
81145a10:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
81145a14:	e0bffd8b 	ldhu	r2,-10(fp)
81145a18:	10bfffcc 	andi	r2,r2,65535
81145a1c:	10bffe0c 	andi	r2,r2,65528
81145a20:	e0bff915 	stw	r2,-28(fp)
81145a24:	00000206 	br	81145a30 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
81145a28:	00bfffc4 	movi	r2,-1
81145a2c:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
81145a30:	e0bff917 	ldw	r2,-28(fp)
81145a34:	00fffdd4 	movui	r3,65527
81145a38:	18800316 	blt	r3,r2,81145a48 <find_first_empty_record_in_a_subdirectory+0x23c>
81145a3c:	e0bff817 	ldw	r2,-32(fp)
81145a40:	10bfffe0 	cmpeqi	r2,r2,-1
81145a44:	103f7c1e 	bne	r2,zero,81145838 <__reset+0xfb125838>
    return result; 
81145a48:	e0bff817 	ldw	r2,-32(fp)
}
81145a4c:	e037883a 	mov	sp,fp
81145a50:	dfc00117 	ldw	ra,4(sp)
81145a54:	df000017 	ldw	fp,0(sp)
81145a58:	dec00204 	addi	sp,sp,8
81145a5c:	f800283a 	ret

81145a60 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
81145a60:	defff904 	addi	sp,sp,-28
81145a64:	de00012e 	bgeu	sp,et,81145a6c <find_first_empty_record_in_root_directory+0xc>
81145a68:	003b68fa 	trap	3
81145a6c:	dfc00615 	stw	ra,24(sp)
81145a70:	df000515 	stw	fp,20(sp)
81145a74:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81145a78:	00a045f4 	movhi	r2,33047
81145a7c:	10b82904 	addi	r2,r2,-8028
81145a80:	1080050b 	ldhu	r2,20(r2)
81145a84:	10bfffcc 	andi	r2,r2,65535
81145a88:	1006917a 	slli	r3,r2,5
81145a8c:	00a045f4 	movhi	r2,33047
81145a90:	10b82904 	addi	r2,r2,-8028
81145a94:	1080030b 	ldhu	r2,12(r2)
81145a98:	10bfffcc 	andi	r2,r2,65535
81145a9c:	1885283a 	div	r2,r3,r2
81145aa0:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
81145aa4:	00bfffc4 	movi	r2,-1
81145aa8:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81145aac:	e03ffb15 	stw	zero,-20(fp)
81145ab0:	00002d06 	br	81145b68 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81145ab4:	00a045f4 	movhi	r2,33047
81145ab8:	10b82904 	addi	r2,r2,-8028
81145abc:	10c01317 	ldw	r3,76(r2)
81145ac0:	e0bffb17 	ldw	r2,-20(fp)
81145ac4:	1885883a 	add	r2,r3,r2
81145ac8:	1007883a 	mov	r3,r2
81145acc:	d0a0b117 	ldw	r2,-32060(gp)
81145ad0:	100b883a 	mov	r5,r2
81145ad4:	1809883a 	mov	r4,r3
81145ad8:	11435340 	call	81143534 <Read_Sector_Data>
81145adc:	10002626 	beq	r2,zero,81145b78 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81145ae0:	e03ffc15 	stw	zero,-16(fp)
81145ae4:	00001a06 	br	81145b50 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
81145ae8:	e0bffc17 	ldw	r2,-16(fp)
81145aec:	1004917a 	slli	r2,r2,5
81145af0:	1007883a 	mov	r3,r2
81145af4:	d0a0b317 	ldw	r2,-32052(gp)
81145af8:	10800a17 	ldw	r2,40(r2)
81145afc:	1885883a 	add	r2,r3,r2
81145b00:	10800023 	ldbuio	r2,0(r2)
81145b04:	10803fcc 	andi	r2,r2,255
81145b08:	10803fcc 	andi	r2,r2,255
81145b0c:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
81145b10:	e0bfff0b 	ldhu	r2,-4(fp)
81145b14:	10803960 	cmpeqi	r2,r2,229
81145b18:	1000021e 	bne	r2,zero,81145b24 <find_first_empty_record_in_root_directory+0xc4>
81145b1c:	e0bfff0b 	ldhu	r2,-4(fp)
81145b20:	1000081e 	bne	r2,zero,81145b44 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
81145b24:	e0bffb17 	ldw	r2,-20(fp)
81145b28:	1006913a 	slli	r3,r2,4
81145b2c:	e0bffc17 	ldw	r2,-16(fp)
81145b30:	1885883a 	add	r2,r3,r2
81145b34:	1004943a 	slli	r2,r2,16
81145b38:	e0bffe15 	stw	r2,-8(fp)
                    return result;
81145b3c:	e0bffe17 	ldw	r2,-8(fp)
81145b40:	00000f06 	br	81145b80 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81145b44:	e0bffc17 	ldw	r2,-16(fp)
81145b48:	10800044 	addi	r2,r2,1
81145b4c:	e0bffc15 	stw	r2,-16(fp)
81145b50:	e0bffc17 	ldw	r2,-16(fp)
81145b54:	10800410 	cmplti	r2,r2,16
81145b58:	103fe31e 	bne	r2,zero,81145ae8 <__reset+0xfb125ae8>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81145b5c:	e0bffb17 	ldw	r2,-20(fp)
81145b60:	10800044 	addi	r2,r2,1
81145b64:	e0bffb15 	stw	r2,-20(fp)
81145b68:	e0fffb17 	ldw	r3,-20(fp)
81145b6c:	e0bffd17 	ldw	r2,-12(fp)
81145b70:	18bfd016 	blt	r3,r2,81145ab4 <__reset+0xfb125ab4>
81145b74:	00000106 	br	81145b7c <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
81145b78:	0001883a 	nop
        }
    }
    return result;
81145b7c:	e0bffe17 	ldw	r2,-8(fp)
}
81145b80:	e037883a 	mov	sp,fp
81145b84:	dfc00117 	ldw	ra,4(sp)
81145b88:	df000017 	ldw	fp,0(sp)
81145b8c:	dec00204 	addi	sp,sp,8
81145b90:	f800283a 	ret

81145b94 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
81145b94:	defffa04 	addi	sp,sp,-24
81145b98:	de00012e 	bgeu	sp,et,81145ba0 <convert_filename_to_name_extension+0xc>
81145b9c:	003b68fa 	trap	3
81145ba0:	df000515 	stw	fp,20(sp)
81145ba4:	df000504 	addi	fp,sp,20
81145ba8:	e13ffd15 	stw	r4,-12(fp)
81145bac:	e17ffe15 	stw	r5,-8(fp)
81145bb0:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
81145bb4:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
81145bb8:	e03ffb15 	stw	zero,-20(fp)
81145bbc:	00002506 	br	81145c54 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
81145bc0:	e0bffc17 	ldw	r2,-16(fp)
81145bc4:	e0fffd17 	ldw	r3,-12(fp)
81145bc8:	1885883a 	add	r2,r3,r2
81145bcc:	10800003 	ldbu	r2,0(r2)
81145bd0:	10803fcc 	andi	r2,r2,255
81145bd4:	1080201c 	xori	r2,r2,128
81145bd8:	10bfe004 	addi	r2,r2,-128
81145bdc:	10800ba0 	cmpeqi	r2,r2,46
81145be0:	1000141e 	bne	r2,zero,81145c34 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
81145be4:	e0bffb17 	ldw	r2,-20(fp)
81145be8:	e0fffe17 	ldw	r3,-8(fp)
81145bec:	1885883a 	add	r2,r3,r2
81145bf0:	e0fffc17 	ldw	r3,-16(fp)
81145bf4:	e13ffd17 	ldw	r4,-12(fp)
81145bf8:	20c7883a 	add	r3,r4,r3
81145bfc:	18c00003 	ldbu	r3,0(r3)
81145c00:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
81145c04:	e0bffc17 	ldw	r2,-16(fp)
81145c08:	e0fffd17 	ldw	r3,-12(fp)
81145c0c:	1885883a 	add	r2,r3,r2
81145c10:	10800003 	ldbu	r2,0(r2)
81145c14:	10803fcc 	andi	r2,r2,255
81145c18:	1080201c 	xori	r2,r2,128
81145c1c:	10bfe004 	addi	r2,r2,-128
81145c20:	10000926 	beq	r2,zero,81145c48 <convert_filename_to_name_extension+0xb4>
81145c24:	e0bffc17 	ldw	r2,-16(fp)
81145c28:	10800044 	addi	r2,r2,1
81145c2c:	e0bffc15 	stw	r2,-16(fp)
81145c30:	00000506 	br	81145c48 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
81145c34:	e0bffb17 	ldw	r2,-20(fp)
81145c38:	e0fffe17 	ldw	r3,-8(fp)
81145c3c:	1885883a 	add	r2,r3,r2
81145c40:	00c00804 	movi	r3,32
81145c44:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
81145c48:	e0bffb17 	ldw	r2,-20(fp)
81145c4c:	10800044 	addi	r2,r2,1
81145c50:	e0bffb15 	stw	r2,-20(fp)
81145c54:	e0bffb17 	ldw	r2,-20(fp)
81145c58:	10800210 	cmplti	r2,r2,8
81145c5c:	103fd81e 	bne	r2,zero,81145bc0 <__reset+0xfb125bc0>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
81145c60:	e0bffc17 	ldw	r2,-16(fp)
81145c64:	e0fffd17 	ldw	r3,-12(fp)
81145c68:	1885883a 	add	r2,r3,r2
81145c6c:	10800003 	ldbu	r2,0(r2)
81145c70:	10803fcc 	andi	r2,r2,255
81145c74:	1080201c 	xori	r2,r2,128
81145c78:	10bfe004 	addi	r2,r2,-128
81145c7c:	10800b98 	cmpnei	r2,r2,46
81145c80:	1000031e 	bne	r2,zero,81145c90 <convert_filename_to_name_extension+0xfc>
81145c84:	e0bffc17 	ldw	r2,-16(fp)
81145c88:	10800044 	addi	r2,r2,1
81145c8c:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
81145c90:	e03ffb15 	stw	zero,-20(fp)
81145c94:	00001c06 	br	81145d08 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
81145c98:	e0bffc17 	ldw	r2,-16(fp)
81145c9c:	e0fffd17 	ldw	r3,-12(fp)
81145ca0:	1885883a 	add	r2,r3,r2
81145ca4:	10800003 	ldbu	r2,0(r2)
81145ca8:	10803fcc 	andi	r2,r2,255
81145cac:	1080201c 	xori	r2,r2,128
81145cb0:	10bfe004 	addi	r2,r2,-128
81145cb4:	10000c26 	beq	r2,zero,81145ce8 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
81145cb8:	e0bffb17 	ldw	r2,-20(fp)
81145cbc:	e0ffff17 	ldw	r3,-4(fp)
81145cc0:	1885883a 	add	r2,r3,r2
81145cc4:	e0fffc17 	ldw	r3,-16(fp)
81145cc8:	e13ffd17 	ldw	r4,-12(fp)
81145ccc:	20c7883a 	add	r3,r4,r3
81145cd0:	18c00003 	ldbu	r3,0(r3)
81145cd4:	10c00005 	stb	r3,0(r2)
            local++;
81145cd8:	e0bffc17 	ldw	r2,-16(fp)
81145cdc:	10800044 	addi	r2,r2,1
81145ce0:	e0bffc15 	stw	r2,-16(fp)
81145ce4:	00000506 	br	81145cfc <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
81145ce8:	e0bffb17 	ldw	r2,-20(fp)
81145cec:	e0ffff17 	ldw	r3,-4(fp)
81145cf0:	1885883a 	add	r2,r3,r2
81145cf4:	00c00804 	movi	r3,32
81145cf8:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
81145cfc:	e0bffb17 	ldw	r2,-20(fp)
81145d00:	10800044 	addi	r2,r2,1
81145d04:	e0bffb15 	stw	r2,-20(fp)
81145d08:	e0bffb17 	ldw	r2,-20(fp)
81145d0c:	108000d0 	cmplti	r2,r2,3
81145d10:	103fe11e 	bne	r2,zero,81145c98 <__reset+0xfb125c98>
        {
            extension[counter] = ' ';
        }
    }

}
81145d14:	0001883a 	nop
81145d18:	e037883a 	mov	sp,fp
81145d1c:	df000017 	ldw	fp,0(sp)
81145d20:	dec00104 	addi	sp,sp,4
81145d24:	f800283a 	ret

81145d28 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
81145d28:	defff504 	addi	sp,sp,-44
81145d2c:	de00012e 	bgeu	sp,et,81145d34 <create_file+0xc>
81145d30:	003b68fa 	trap	3
81145d34:	dfc00a15 	stw	ra,40(sp)
81145d38:	df000915 	stw	fp,36(sp)
81145d3c:	df000904 	addi	fp,sp,36
81145d40:	e13ffd15 	stw	r4,-12(fp)
81145d44:	e17ffe15 	stw	r5,-8(fp)
81145d48:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
81145d4c:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
81145d50:	e0bffc04 	addi	r2,fp,-16
81145d54:	1009883a 	mov	r4,r2
81145d58:	11456580 	call	81145658 <find_first_empty_cluster>
81145d5c:	1000a026 	beq	r2,zero,81145fe0 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
81145d60:	e0bfff17 	ldw	r2,-4(fp)
81145d64:	10800a17 	ldw	r2,40(r2)
81145d68:	1000031e 	bne	r2,zero,81145d78 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
81145d6c:	1145a600 	call	81145a60 <find_first_empty_record_in_root_directory>
81145d70:	e0bff815 	stw	r2,-32(fp)
81145d74:	00000606 	br	81145d90 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
81145d78:	e0bfff17 	ldw	r2,-4(fp)
81145d7c:	1080058b 	ldhu	r2,22(r2)
81145d80:	10bfffcc 	andi	r2,r2,65535
81145d84:	1009883a 	mov	r4,r2
81145d88:	114580c0 	call	8114580c <find_first_empty_record_in_a_subdirectory>
81145d8c:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
81145d90:	e0bff817 	ldw	r2,-32(fp)
81145d94:	10009216 	blt	r2,zero,81145fe0 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
81145d98:	e13ffd17 	ldw	r4,-12(fp)
81145d9c:	11449380 	call	81144938 <get_dir_divider_location>
81145da0:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
81145da4:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
81145da8:	00000b06 	br	81145dd8 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
81145dac:	e0fffa17 	ldw	r3,-24(fp)
81145db0:	e0bff917 	ldw	r2,-28(fp)
81145db4:	1885883a 	add	r2,r3,r2
81145db8:	10800044 	addi	r2,r2,1
81145dbc:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
81145dc0:	e0bffa17 	ldw	r2,-24(fp)
81145dc4:	e0fffd17 	ldw	r3,-12(fp)
81145dc8:	1885883a 	add	r2,r3,r2
81145dcc:	1009883a 	mov	r4,r2
81145dd0:	11449380 	call	81144938 <get_dir_divider_location>
81145dd4:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
81145dd8:	e0bff917 	ldw	r2,-28(fp)
81145ddc:	00bff316 	blt	zero,r2,81145dac <__reset+0xfb125dac>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
81145de0:	e0bffa17 	ldw	r2,-24(fp)
81145de4:	e0fffd17 	ldw	r3,-12(fp)
81145de8:	1887883a 	add	r3,r3,r2
81145dec:	e13ffe17 	ldw	r4,-8(fp)
81145df0:	e0bffe17 	ldw	r2,-8(fp)
81145df4:	10800204 	addi	r2,r2,8
81145df8:	100d883a 	mov	r6,r2
81145dfc:	200b883a 	mov	r5,r4
81145e00:	1809883a 	mov	r4,r3
81145e04:	1145b940 	call	81145b94 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
81145e08:	e0bffe17 	ldw	r2,-8(fp)
81145e0c:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
81145e10:	e0bffe17 	ldw	r2,-8(fp)
81145e14:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
81145e18:	e0bffe17 	ldw	r2,-8(fp)
81145e1c:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
81145e20:	e0bffe17 	ldw	r2,-8(fp)
81145e24:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
81145e28:	e0bffe17 	ldw	r2,-8(fp)
81145e2c:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
81145e30:	e0bffe17 	ldw	r2,-8(fp)
81145e34:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
81145e38:	e0bffc17 	ldw	r2,-16(fp)
81145e3c:	1007883a 	mov	r3,r2
81145e40:	e0bffe17 	ldw	r2,-8(fp)
81145e44:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
81145e48:	e0bffe17 	ldw	r2,-8(fp)
81145e4c:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
81145e50:	e0fffc17 	ldw	r3,-16(fp)
81145e54:	e0bffe17 	ldw	r2,-8(fp)
81145e58:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
81145e5c:	e0bffe17 	ldw	r2,-8(fp)
81145e60:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81145e64:	e0bffe17 	ldw	r2,-8(fp)
81145e68:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
81145e6c:	e0bff817 	ldw	r2,-32(fp)
81145e70:	10ffffcc 	andi	r3,r2,65535
81145e74:	e0bffe17 	ldw	r2,-8(fp)
81145e78:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
81145e7c:	e0bff817 	ldw	r2,-32(fp)
81145e80:	1004d43a 	srli	r2,r2,16
81145e84:	1000010e 	bge	r2,zero,81145e8c <create_file+0x164>
81145e88:	108003c4 	addi	r2,r2,15
81145e8c:	1005d13a 	srai	r2,r2,4
81145e90:	1007883a 	mov	r3,r2
81145e94:	e0bffe17 	ldw	r2,-8(fp)
81145e98:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
81145e9c:	e0bff817 	ldw	r2,-32(fp)
81145ea0:	1004d43a 	srli	r2,r2,16
81145ea4:	1007883a 	mov	r3,r2
81145ea8:	00a00034 	movhi	r2,32768
81145eac:	108003c4 	addi	r2,r2,15
81145eb0:	1884703a 	and	r2,r3,r2
81145eb4:	1000040e 	bge	r2,zero,81145ec8 <create_file+0x1a0>
81145eb8:	10bfffc4 	addi	r2,r2,-1
81145ebc:	00fffc04 	movi	r3,-16
81145ec0:	10c4b03a 	or	r2,r2,r3
81145ec4:	10800044 	addi	r2,r2,1
81145ec8:	1004917a 	slli	r2,r2,5
81145ecc:	1007883a 	mov	r3,r2
81145ed0:	e0bffe17 	ldw	r2,-8(fp)
81145ed4:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
81145ed8:	e0bfff17 	ldw	r2,-4(fp)
81145edc:	1080058b 	ldhu	r2,22(r2)
81145ee0:	10ffffcc 	andi	r3,r2,65535
81145ee4:	e0bffe17 	ldw	r2,-8(fp)
81145ee8:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
81145eec:	e0bffe17 	ldw	r2,-8(fp)
81145ef0:	00c00044 	movi	r3,1
81145ef4:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
81145ef8:	e0bffe17 	ldw	r2,-8(fp)
81145efc:	00c00044 	movi	r3,1
81145f00:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81145f04:	e0bffe17 	ldw	r2,-8(fp)
81145f08:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81145f0c:	1000071e 	bne	r2,zero,81145f2c <create_file+0x204>
81145f10:	00a045f4 	movhi	r2,33047
81145f14:	10b82904 	addi	r2,r2,-8028
81145f18:	10c01317 	ldw	r3,76(r2)
81145f1c:	e0bffe17 	ldw	r2,-8(fp)
81145f20:	10800b17 	ldw	r2,44(r2)
81145f24:	1885883a 	add	r2,r3,r2
81145f28:	00000f06 	br	81145f68 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
81145f2c:	00a045f4 	movhi	r2,33047
81145f30:	10b82904 	addi	r2,r2,-8028
81145f34:	10c01417 	ldw	r3,80(r2)
81145f38:	e0bffe17 	ldw	r2,-8(fp)
81145f3c:	10800a17 	ldw	r2,40(r2)
81145f40:	113fff84 	addi	r4,r2,-2
81145f44:	00a045f4 	movhi	r2,33047
81145f48:	10b82904 	addi	r2,r2,-8028
81145f4c:	10800383 	ldbu	r2,14(r2)
81145f50:	10803fcc 	andi	r2,r2,255
81145f54:	2085383a 	mul	r2,r4,r2
81145f58:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
81145f5c:	e0bffe17 	ldw	r2,-8(fp)
81145f60:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81145f64:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81145f68:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
81145f6c:	e0bffb17 	ldw	r2,-20(fp)
81145f70:	d0e0b117 	ldw	r3,-32060(gp)
81145f74:	180b883a 	mov	r5,r3
81145f78:	1009883a 	mov	r4,r2
81145f7c:	11435340 	call	81143534 <Read_Sector_Data>
81145f80:	10001726 	beq	r2,zero,81145fe0 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
81145f84:	e0bffe17 	ldw	r2,-8(fp)
81145f88:	10800c0b 	ldhu	r2,48(r2)
81145f8c:	10bfffcc 	andi	r2,r2,65535
81145f90:	10a0001c 	xori	r2,r2,32768
81145f94:	10a00004 	addi	r2,r2,-32768
81145f98:	e17ffe17 	ldw	r5,-8(fp)
81145f9c:	1009883a 	mov	r4,r2
81145fa0:	1143be80 	call	81143be8 <Write_File_Record_At_Offset>
81145fa4:	10000e26 	beq	r2,zero,81145fe0 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
81145fa8:	11434e00 	call	811434e0 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
81145fac:	e0bffc17 	ldw	r2,-16(fp)
81145fb0:	01800044 	movi	r6,1
81145fb4:	017fffc4 	movi	r5,-1
81145fb8:	1009883a 	mov	r4,r2
81145fbc:	11436d00 	call	811436d0 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
81145fc0:	e0bffc17 	ldw	r2,-16(fp)
81145fc4:	000d883a 	mov	r6,zero
81145fc8:	017fffc4 	movi	r5,-1
81145fcc:	1009883a 	mov	r4,r2
81145fd0:	11436d00 	call	811436d0 <mark_cluster>
81145fd4:	10000226 	beq	r2,zero,81145fe0 <create_file+0x2b8>
                    {
                        result = true;
81145fd8:	00800044 	movi	r2,1
81145fdc:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
81145fe0:	e0bff717 	ldw	r2,-36(fp)
}
81145fe4:	e037883a 	mov	sp,fp
81145fe8:	dfc00117 	ldw	ra,4(sp)
81145fec:	df000017 	ldw	fp,0(sp)
81145ff0:	dec00204 	addi	sp,sp,8
81145ff4:	f800283a 	ret

81145ff8 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
81145ff8:	defffb04 	addi	sp,sp,-20
81145ffc:	de00012e 	bgeu	sp,et,81146004 <copy_file_record_name_to_string+0xc>
81146000:	003b68fa 	trap	3
81146004:	df000415 	stw	fp,16(sp)
81146008:	df000404 	addi	fp,sp,16
8114600c:	e13ffe15 	stw	r4,-8(fp)
81146010:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
81146014:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81146018:	e03ffc15 	stw	zero,-16(fp)
8114601c:	00001506 	br	81146074 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
81146020:	e0fffe17 	ldw	r3,-8(fp)
81146024:	e0bffc17 	ldw	r2,-16(fp)
81146028:	1885883a 	add	r2,r3,r2
8114602c:	10800003 	ldbu	r2,0(r2)
81146030:	10803fcc 	andi	r2,r2,255
81146034:	10800820 	cmpeqi	r2,r2,32
81146038:	10000b1e 	bne	r2,zero,81146068 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
8114603c:	e0bffd17 	ldw	r2,-12(fp)
81146040:	e0ffff17 	ldw	r3,-4(fp)
81146044:	1885883a 	add	r2,r3,r2
81146048:	e13ffe17 	ldw	r4,-8(fp)
8114604c:	e0fffc17 	ldw	r3,-16(fp)
81146050:	20c7883a 	add	r3,r4,r3
81146054:	18c00003 	ldbu	r3,0(r3)
81146058:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
8114605c:	e0bffd17 	ldw	r2,-12(fp)
81146060:	10800044 	addi	r2,r2,1
81146064:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81146068:	e0bffc17 	ldw	r2,-16(fp)
8114606c:	10800044 	addi	r2,r2,1
81146070:	e0bffc15 	stw	r2,-16(fp)
81146074:	e0bffc17 	ldw	r2,-16(fp)
81146078:	10800210 	cmplti	r2,r2,8
8114607c:	103fe81e 	bne	r2,zero,81146020 <__reset+0xfb126020>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
81146080:	e0bffe17 	ldw	r2,-8(fp)
81146084:	10800203 	ldbu	r2,8(r2)
81146088:	10803fcc 	andi	r2,r2,255
8114608c:	10800820 	cmpeqi	r2,r2,32
81146090:	1000241e 	bne	r2,zero,81146124 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
81146094:	e0bffd17 	ldw	r2,-12(fp)
81146098:	e0ffff17 	ldw	r3,-4(fp)
8114609c:	1885883a 	add	r2,r3,r2
811460a0:	00c00b84 	movi	r3,46
811460a4:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
811460a8:	e0bffd17 	ldw	r2,-12(fp)
811460ac:	10800044 	addi	r2,r2,1
811460b0:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
811460b4:	e03ffc15 	stw	zero,-16(fp)
811460b8:	00001706 	br	81146118 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
811460bc:	e0fffe17 	ldw	r3,-8(fp)
811460c0:	e0bffc17 	ldw	r2,-16(fp)
811460c4:	1885883a 	add	r2,r3,r2
811460c8:	10800204 	addi	r2,r2,8
811460cc:	10800003 	ldbu	r2,0(r2)
811460d0:	10803fcc 	andi	r2,r2,255
811460d4:	10800820 	cmpeqi	r2,r2,32
811460d8:	10000c1e 	bne	r2,zero,8114610c <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
811460dc:	e0bffd17 	ldw	r2,-12(fp)
811460e0:	e0ffff17 	ldw	r3,-4(fp)
811460e4:	1885883a 	add	r2,r3,r2
811460e8:	e13ffe17 	ldw	r4,-8(fp)
811460ec:	e0fffc17 	ldw	r3,-16(fp)
811460f0:	20c7883a 	add	r3,r4,r3
811460f4:	18c00204 	addi	r3,r3,8
811460f8:	18c00003 	ldbu	r3,0(r3)
811460fc:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
81146100:	e0bffd17 	ldw	r2,-12(fp)
81146104:	10800044 	addi	r2,r2,1
81146108:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
8114610c:	e0bffc17 	ldw	r2,-16(fp)
81146110:	10800044 	addi	r2,r2,1
81146114:	e0bffc15 	stw	r2,-16(fp)
81146118:	e0bffc17 	ldw	r2,-16(fp)
8114611c:	108000d0 	cmplti	r2,r2,3
81146120:	103fe61e 	bne	r2,zero,811460bc <__reset+0xfb1260bc>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
81146124:	e0bffd17 	ldw	r2,-12(fp)
81146128:	e0ffff17 	ldw	r3,-4(fp)
8114612c:	1885883a 	add	r2,r3,r2
81146130:	10000005 	stb	zero,0(r2)
}
81146134:	0001883a 	nop
81146138:	e037883a 	mov	sp,fp
8114613c:	df000017 	ldw	fp,0(sp)
81146140:	dec00104 	addi	sp,sp,4
81146144:	f800283a 	ret

81146148 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
81146148:	defffc04 	addi	sp,sp,-16
8114614c:	de00012e 	bgeu	sp,et,81146154 <alt_up_sd_card_open_dev+0xc>
81146150:	003b68fa 	trap	3
81146154:	dfc00315 	stw	ra,12(sp)
81146158:	df000215 	stw	fp,8(sp)
8114615c:	df000204 	addi	fp,sp,8
81146160:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
81146164:	d1600d04 	addi	r5,gp,-32716
81146168:	e13fff17 	ldw	r4,-4(fp)
8114616c:	114b6040 	call	8114b604 <alt_find_dev>
81146170:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
81146174:	e0bffe17 	ldw	r2,-8(fp)
81146178:	10001e26 	beq	r2,zero,811461f4 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
8114617c:	e0bffe17 	ldw	r2,-8(fp)
81146180:	10800a17 	ldw	r2,40(r2)
81146184:	10808d04 	addi	r2,r2,564
81146188:	d0a0ab15 	stw	r2,-32084(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
8114618c:	e0bffe17 	ldw	r2,-8(fp)
81146190:	10800a17 	ldw	r2,40(r2)
81146194:	10808904 	addi	r2,r2,548
81146198:	d0a0ac15 	stw	r2,-32080(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
8114619c:	e0bffe17 	ldw	r2,-8(fp)
811461a0:	10800a17 	ldw	r2,40(r2)
811461a4:	10808404 	addi	r2,r2,528
811461a8:	d0a0ad15 	stw	r2,-32076(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
811461ac:	e0bffe17 	ldw	r2,-8(fp)
811461b0:	10800a17 	ldw	r2,40(r2)
811461b4:	10808c04 	addi	r2,r2,560
811461b8:	d0a0ae15 	stw	r2,-32072(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
811461bc:	e0bffe17 	ldw	r2,-8(fp)
811461c0:	10800a17 	ldw	r2,40(r2)
811461c4:	10808b04 	addi	r2,r2,556
811461c8:	d0a0af15 	stw	r2,-32068(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
811461cc:	e0bffe17 	ldw	r2,-8(fp)
811461d0:	10800a17 	ldw	r2,40(r2)
811461d4:	d0a0b015 	stw	r2,-32064(gp)
		device_pointer = dev;
811461d8:	e0bffe17 	ldw	r2,-8(fp)
811461dc:	d0a0b315 	stw	r2,-32052(gp)
		initialized = false;
811461e0:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
811461e4:	d020aa15 	stw	zero,-32088(gp)
		search_data.valid = false;
811461e8:	00a045f4 	movhi	r2,33047
811461ec:	10b82404 	addi	r2,r2,-8048
811461f0:	10000415 	stw	zero,16(r2)
	}
	return dev;
811461f4:	e0bffe17 	ldw	r2,-8(fp)
}
811461f8:	e037883a 	mov	sp,fp
811461fc:	dfc00117 	ldw	ra,4(sp)
81146200:	df000017 	ldw	fp,0(sp)
81146204:	dec00204 	addi	sp,sp,8
81146208:	f800283a 	ret

8114620c <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
8114620c:	defffd04 	addi	sp,sp,-12
81146210:	de00012e 	bgeu	sp,et,81146218 <alt_up_sd_card_is_Present+0xc>
81146214:	003b68fa 	trap	3
81146218:	df000215 	stw	fp,8(sp)
8114621c:	df000204 	addi	fp,sp,8
    bool result = false;
81146220:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
81146224:	d0a0b317 	ldw	r2,-32052(gp)
81146228:	10000826 	beq	r2,zero,8114624c <alt_up_sd_card_is_Present+0x40>
8114622c:	d0a0ab17 	ldw	r2,-32084(gp)
81146230:	1080002b 	ldhuio	r2,0(r2)
81146234:	10bfffcc 	andi	r2,r2,65535
81146238:	1080008c 	andi	r2,r2,2
8114623c:	10000326 	beq	r2,zero,8114624c <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
81146240:	00800044 	movi	r2,1
81146244:	e0bffe15 	stw	r2,-8(fp)
81146248:	00001e06 	br	811462c4 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
8114624c:	d0a0a917 	ldw	r2,-32092(gp)
81146250:	10800058 	cmpnei	r2,r2,1
81146254:	10001b1e 	bne	r2,zero,811462c4 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
81146258:	d020a915 	stw	zero,-32092(gp)
		search_data.valid = false;
8114625c:	00a045f4 	movhi	r2,33047
81146260:	10b82404 	addi	r2,r2,-8048
81146264:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
81146268:	d020aa15 	stw	zero,-32088(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
8114626c:	e03fff15 	stw	zero,-4(fp)
81146270:	00001106 	br	811462b8 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
81146274:	00a045f4 	movhi	r2,33047
81146278:	10b83e04 	addi	r2,r2,-7944
8114627c:	e0ffff17 	ldw	r3,-4(fp)
81146280:	180691ba 	slli	r3,r3,6
81146284:	10c5883a 	add	r2,r2,r3
81146288:	10800f04 	addi	r2,r2,60
8114628c:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
81146290:	00a045f4 	movhi	r2,33047
81146294:	10b83e04 	addi	r2,r2,-7944
81146298:	e0ffff17 	ldw	r3,-4(fp)
8114629c:	180691ba 	slli	r3,r3,6
811462a0:	10c5883a 	add	r2,r2,r3
811462a4:	10800e04 	addi	r2,r2,56
811462a8:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
811462ac:	e0bfff17 	ldw	r2,-4(fp)
811462b0:	10800044 	addi	r2,r2,1
811462b4:	e0bfff15 	stw	r2,-4(fp)
811462b8:	e0bfff17 	ldw	r2,-4(fp)
811462bc:	10800510 	cmplti	r2,r2,20
811462c0:	103fec1e 	bne	r2,zero,81146274 <__reset+0xfb126274>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
811462c4:	e0bffe17 	ldw	r2,-8(fp)
}
811462c8:	e037883a 	mov	sp,fp
811462cc:	df000017 	ldw	fp,0(sp)
811462d0:	dec00104 	addi	sp,sp,4
811462d4:	f800283a 	ret

811462d8 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
811462d8:	defffd04 	addi	sp,sp,-12
811462dc:	de00012e 	bgeu	sp,et,811462e4 <alt_up_sd_card_is_FAT16+0xc>
811462e0:	003b68fa 	trap	3
811462e4:	dfc00215 	stw	ra,8(sp)
811462e8:	df000115 	stw	fp,4(sp)
811462ec:	df000104 	addi	fp,sp,4
	bool result = false;
811462f0:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
811462f4:	114620c0 	call	8114620c <alt_up_sd_card_is_Present>
811462f8:	10000c26 	beq	r2,zero,8114632c <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
811462fc:	d0a0a917 	ldw	r2,-32092(gp)
81146300:	1000071e 	bne	r2,zero,81146320 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
81146304:	11445040 	call	81144504 <Look_for_FAT16>
81146308:	d0a0aa15 	stw	r2,-32088(gp)
			initialized = is_sd_card_formated_as_FAT16;
8114630c:	d0a0aa17 	ldw	r2,-32088(gp)
81146310:	d0a0a915 	stw	r2,-32092(gp)
			search_data.valid = false;
81146314:	00a045f4 	movhi	r2,33047
81146318:	10b82404 	addi	r2,r2,-8048
8114631c:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
81146320:	d0a0aa17 	ldw	r2,-32088(gp)
81146324:	e0bfff15 	stw	r2,-4(fp)
81146328:	00000206 	br	81146334 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
8114632c:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
81146330:	d020aa15 	stw	zero,-32088(gp)
	}

	return result;
81146334:	e0bfff17 	ldw	r2,-4(fp)
}
81146338:	e037883a 	mov	sp,fp
8114633c:	dfc00117 	ldw	ra,4(sp)
81146340:	df000017 	ldw	fp,0(sp)
81146344:	dec00204 	addi	sp,sp,8
81146348:	f800283a 	ret

8114634c <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
8114634c:	deffea04 	addi	sp,sp,-88
81146350:	de00012e 	bgeu	sp,et,81146358 <alt_up_sd_card_find_first+0xc>
81146354:	003b68fa 	trap	3
81146358:	dfc01515 	stw	ra,84(sp)
8114635c:	df001415 	stw	fp,80(sp)
81146360:	df001404 	addi	fp,sp,80
81146364:	e13ffe15 	stw	r4,-8(fp)
81146368:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
8114636c:	00800084 	movi	r2,2
81146370:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81146374:	114620c0 	call	8114620c <alt_up_sd_card_is_Present>
81146378:	10002426 	beq	r2,zero,8114640c <alt_up_sd_card_find_first+0xc0>
8114637c:	d0a0aa17 	ldw	r2,-32088(gp)
81146380:	10002226 	beq	r2,zero,8114640c <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
81146384:	e0ffee04 	addi	r3,fp,-72
81146388:	e0bfed04 	addi	r2,fp,-76
8114638c:	180d883a 	mov	r6,r3
81146390:	100b883a 	mov	r5,r2
81146394:	e13ffe17 	ldw	r4,-8(fp)
81146398:	1144c9c0 	call	81144c9c <get_home_directory_cluster_for_file>
8114639c:	10001926 	beq	r2,zero,81146404 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
811463a0:	e0bfed17 	ldw	r2,-76(fp)
811463a4:	1007883a 	mov	r3,r2
811463a8:	00a045f4 	movhi	r2,33047
811463ac:	10b82404 	addi	r2,r2,-8048
811463b0:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
811463b4:	e0bfed17 	ldw	r2,-76(fp)
811463b8:	1007883a 	mov	r3,r2
811463bc:	00a045f4 	movhi	r2,33047
811463c0:	10b82404 	addi	r2,r2,-8048
811463c4:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
811463c8:	00a045f4 	movhi	r2,33047
811463cc:	10b82404 	addi	r2,r2,-8048
811463d0:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
811463d4:	00a045f4 	movhi	r2,33047
811463d8:	10b82404 	addi	r2,r2,-8048
811463dc:	00ffffc4 	movi	r3,-1
811463e0:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
811463e4:	00a045f4 	movhi	r2,33047
811463e8:	10b82404 	addi	r2,r2,-8048
811463ec:	00c00044 	movi	r3,1
811463f0:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
811463f4:	e13fff17 	ldw	r4,-4(fp)
811463f8:	11464240 	call	81146424 <alt_up_sd_card_find_next>
811463fc:	e0bfec0d 	sth	r2,-80(fp)
81146400:	00000206 	br	8114640c <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
81146404:	00800044 	movi	r2,1
81146408:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
8114640c:	e0bfec0b 	ldhu	r2,-80(fp)
}
81146410:	e037883a 	mov	sp,fp
81146414:	dfc00117 	ldw	ra,4(sp)
81146418:	df000017 	ldw	fp,0(sp)
8114641c:	dec00204 	addi	sp,sp,8
81146420:	f800283a 	ret

81146424 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
81146424:	deffe404 	addi	sp,sp,-112
81146428:	de00012e 	bgeu	sp,et,81146430 <alt_up_sd_card_find_next+0xc>
8114642c:	003b68fa 	trap	3
81146430:	dfc01b15 	stw	ra,108(sp)
81146434:	df001a15 	stw	fp,104(sp)
81146438:	df001a04 	addi	fp,sp,104
8114643c:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
81146440:	00800084 	movi	r2,2
81146444:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81146448:	114620c0 	call	8114620c <alt_up_sd_card_is_Present>
8114644c:	1000df26 	beq	r2,zero,811467cc <alt_up_sd_card_find_next+0x3a8>
81146450:	d0a0aa17 	ldw	r2,-32088(gp)
81146454:	1000dd26 	beq	r2,zero,811467cc <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
81146458:	00a045f4 	movhi	r2,33047
8114645c:	10b82404 	addi	r2,r2,-8048
81146460:	10800417 	ldw	r2,16(r2)
81146464:	1000d726 	beq	r2,zero,811467c4 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
81146468:	00a045f4 	movhi	r2,33047
8114646c:	10b82404 	addi	r2,r2,-8048
81146470:	10800117 	ldw	r2,4(r2)
81146474:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
81146478:	e0bfe717 	ldw	r2,-100(fp)
8114647c:	1000561e 	bne	r2,zero,811465d8 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81146480:	00a045f4 	movhi	r2,33047
81146484:	10b82904 	addi	r2,r2,-8028
81146488:	1080050b 	ldhu	r2,20(r2)
8114648c:	10bfffcc 	andi	r2,r2,65535
81146490:	1006917a 	slli	r3,r2,5
81146494:	00a045f4 	movhi	r2,33047
81146498:	10b82904 	addi	r2,r2,-8028
8114649c:	1080030b 	ldhu	r2,12(r2)
811464a0:	10bfffcc 	andi	r2,r2,65535
811464a4:	1885283a 	div	r2,r3,r2
811464a8:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
811464ac:	00a045f4 	movhi	r2,33047
811464b0:	10b82404 	addi	r2,r2,-8048
811464b4:	10800217 	ldw	r2,8(r2)
811464b8:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
811464bc:	00a045f4 	movhi	r2,33047
811464c0:	10b82404 	addi	r2,r2,-8048
811464c4:	1080030b 	ldhu	r2,12(r2)
811464c8:	10bfffcc 	andi	r2,r2,65535
811464cc:	10a0001c 	xori	r2,r2,32768
811464d0:	10a00004 	addi	r2,r2,-32768
811464d4:	10800044 	addi	r2,r2,1
811464d8:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
811464dc:	00003606 	br	811465b8 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811464e0:	00a045f4 	movhi	r2,33047
811464e4:	10b82904 	addi	r2,r2,-8028
811464e8:	10c01317 	ldw	r3,76(r2)
811464ec:	e0bfe817 	ldw	r2,-96(fp)
811464f0:	1885883a 	add	r2,r3,r2
811464f4:	1007883a 	mov	r3,r2
811464f8:	d0a0b117 	ldw	r2,-32060(gp)
811464fc:	100b883a 	mov	r5,r2
81146500:	1809883a 	mov	r4,r3
81146504:	11435340 	call	81143534 <Read_Sector_Data>
81146508:	10002f26 	beq	r2,zero,811465c8 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
8114650c:	00002306 	br	8114659c <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
81146510:	e0bfe917 	ldw	r2,-92(fp)
81146514:	1004917a 	slli	r2,r2,5
81146518:	e13fe817 	ldw	r4,-96(fp)
8114651c:	e0ffef04 	addi	r3,fp,-68
81146520:	200f883a 	mov	r7,r4
81146524:	000d883a 	mov	r6,zero
81146528:	180b883a 	mov	r5,r3
8114652c:	1009883a 	mov	r4,r2
81146530:	11439640 	call	81143964 <Read_File_Record_At_Offset>
81146534:	10001626 	beq	r2,zero,81146590 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81146538:	e0bfef03 	ldbu	r2,-68(fp)
8114653c:	10803fcc 	andi	r2,r2,255
81146540:	10001326 	beq	r2,zero,81146590 <alt_up_sd_card_find_next+0x16c>
81146544:	e0bfef03 	ldbu	r2,-68(fp)
81146548:	10803fcc 	andi	r2,r2,255
8114654c:	10803960 	cmpeqi	r2,r2,229
81146550:	10000f1e 	bne	r2,zero,81146590 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
81146554:	e0bfe917 	ldw	r2,-92(fp)
81146558:	1007883a 	mov	r3,r2
8114655c:	00a045f4 	movhi	r2,33047
81146560:	10b82404 	addi	r2,r2,-8048
81146564:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
81146568:	e0ffe817 	ldw	r3,-96(fp)
8114656c:	00a045f4 	movhi	r2,33047
81146570:	10b82404 	addi	r2,r2,-8048
81146574:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
81146578:	e0bfef04 	addi	r2,fp,-68
8114657c:	e17fff17 	ldw	r5,-4(fp)
81146580:	1009883a 	mov	r4,r2
81146584:	1145ff80 	call	81145ff8 <copy_file_record_name_to_string>
									return 0;
81146588:	0005883a 	mov	r2,zero
8114658c:	00009006 	br	811467d0 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81146590:	e0bfe917 	ldw	r2,-92(fp)
81146594:	10800044 	addi	r2,r2,1
81146598:	e0bfe915 	stw	r2,-92(fp)
8114659c:	e0bfe917 	ldw	r2,-92(fp)
811465a0:	10800410 	cmplti	r2,r2,16
811465a4:	103fda1e 	bne	r2,zero,81146510 <__reset+0xfb126510>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
811465a8:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
811465ac:	e0bfe817 	ldw	r2,-96(fp)
811465b0:	10800044 	addi	r2,r2,1
811465b4:	e0bfe815 	stw	r2,-96(fp)
811465b8:	e0ffe817 	ldw	r3,-96(fp)
811465bc:	e0bfec17 	ldw	r2,-80(fp)
811465c0:	18bfc716 	blt	r3,r2,811464e0 <__reset+0xfb1264e0>
811465c4:	00000106 	br	811465cc <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
811465c8:	0001883a 	nop
					}
				}
				result = -1;
811465cc:	00bfffc4 	movi	r2,-1
811465d0:	e0bfe60d 	sth	r2,-104(fp)
811465d4:	00007d06 	br	811467cc <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
811465d8:	00a045f4 	movhi	r2,33047
811465dc:	10b82404 	addi	r2,r2,-8048
811465e0:	1080030b 	ldhu	r2,12(r2)
811465e4:	10bfffcc 	andi	r2,r2,65535
811465e8:	10a0001c 	xori	r2,r2,32768
811465ec:	10a00004 	addi	r2,r2,-32768
811465f0:	10800044 	addi	r2,r2,1
811465f4:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811465f8:	e0bfe717 	ldw	r2,-100(fp)
811465fc:	10ffff84 	addi	r3,r2,-2
81146600:	00a045f4 	movhi	r2,33047
81146604:	10b82904 	addi	r2,r2,-8028
81146608:	10800383 	ldbu	r2,14(r2)
8114660c:	10803fcc 	andi	r2,r2,255
81146610:	1885383a 	mul	r2,r3,r2
81146614:	1007883a 	mov	r3,r2
81146618:	00a045f4 	movhi	r2,33047
8114661c:	10b82904 	addi	r2,r2,-8028
81146620:	10801417 	ldw	r2,80(r2)
81146624:	1885883a 	add	r2,r3,r2
81146628:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
8114662c:	00a045f4 	movhi	r2,33047
81146630:	10b82404 	addi	r2,r2,-8048
81146634:	10800217 	ldw	r2,8(r2)
81146638:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8114663c:	00003806 	br	81146720 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81146640:	e0ffeb17 	ldw	r3,-84(fp)
81146644:	e0bfed17 	ldw	r2,-76(fp)
81146648:	1885883a 	add	r2,r3,r2
8114664c:	d0e0b117 	ldw	r3,-32060(gp)
81146650:	180b883a 	mov	r5,r3
81146654:	1009883a 	mov	r4,r2
81146658:	11435340 	call	81143534 <Read_Sector_Data>
8114665c:	10003726 	beq	r2,zero,8114673c <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
81146660:	00002806 	br	81146704 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
81146664:	e0bfea17 	ldw	r2,-88(fp)
81146668:	1004917a 	slli	r2,r2,5
8114666c:	e13fe717 	ldw	r4,-100(fp)
81146670:	e17feb17 	ldw	r5,-84(fp)
81146674:	e0ffef04 	addi	r3,fp,-68
81146678:	280f883a 	mov	r7,r5
8114667c:	200d883a 	mov	r6,r4
81146680:	180b883a 	mov	r5,r3
81146684:	1009883a 	mov	r4,r2
81146688:	11439640 	call	81143964 <Read_File_Record_At_Offset>
8114668c:	10001a26 	beq	r2,zero,811466f8 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81146690:	e0bfef03 	ldbu	r2,-68(fp)
81146694:	10803fcc 	andi	r2,r2,255
81146698:	10001726 	beq	r2,zero,811466f8 <alt_up_sd_card_find_next+0x2d4>
8114669c:	e0bfef03 	ldbu	r2,-68(fp)
811466a0:	10803fcc 	andi	r2,r2,255
811466a4:	10803960 	cmpeqi	r2,r2,229
811466a8:	1000131e 	bne	r2,zero,811466f8 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
811466ac:	e0ffe717 	ldw	r3,-100(fp)
811466b0:	00a045f4 	movhi	r2,33047
811466b4:	10b82404 	addi	r2,r2,-8048
811466b8:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
811466bc:	e0bfea17 	ldw	r2,-88(fp)
811466c0:	1007883a 	mov	r3,r2
811466c4:	00a045f4 	movhi	r2,33047
811466c8:	10b82404 	addi	r2,r2,-8048
811466cc:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
811466d0:	e0ffeb17 	ldw	r3,-84(fp)
811466d4:	00a045f4 	movhi	r2,33047
811466d8:	10b82404 	addi	r2,r2,-8048
811466dc:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
811466e0:	e0bfef04 	addi	r2,fp,-68
811466e4:	e17fff17 	ldw	r5,-4(fp)
811466e8:	1009883a 	mov	r4,r2
811466ec:	1145ff80 	call	81145ff8 <copy_file_record_name_to_string>
										return 0;
811466f0:	0005883a 	mov	r2,zero
811466f4:	00003606 	br	811467d0 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
811466f8:	e0bfea17 	ldw	r2,-88(fp)
811466fc:	10800044 	addi	r2,r2,1
81146700:	e0bfea15 	stw	r2,-88(fp)
81146704:	e0bfea17 	ldw	r2,-88(fp)
81146708:	10800410 	cmplti	r2,r2,16
8114670c:	103fd51e 	bne	r2,zero,81146664 <__reset+0xfb126664>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
81146710:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81146714:	e0bfeb17 	ldw	r2,-84(fp)
81146718:	10800044 	addi	r2,r2,1
8114671c:	e0bfeb15 	stw	r2,-84(fp)
81146720:	00a045f4 	movhi	r2,33047
81146724:	10b82904 	addi	r2,r2,-8028
81146728:	10800383 	ldbu	r2,14(r2)
8114672c:	10803fcc 	andi	r2,r2,255
81146730:	e0ffeb17 	ldw	r3,-84(fp)
81146734:	18bfc216 	blt	r3,r2,81146640 <__reset+0xfb126640>
81146738:	00000106 	br	81146740 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
8114673c:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
81146740:	00a045f4 	movhi	r2,33047
81146744:	10b82904 	addi	r2,r2,-8028
81146748:	10800383 	ldbu	r2,14(r2)
8114674c:	10803fcc 	andi	r2,r2,255
81146750:	e0ffeb17 	ldw	r3,-84(fp)
81146754:	18801716 	blt	r3,r2,811467b4 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
81146758:	e0bfe717 	ldw	r2,-100(fp)
8114675c:	e0ffee04 	addi	r3,fp,-72
81146760:	180b883a 	mov	r5,r3
81146764:	1009883a 	mov	r4,r2
81146768:	11436140 	call	81143614 <get_cluster_flag>
8114676c:	10000f26 	beq	r2,zero,811467ac <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81146770:	e0bfee0b 	ldhu	r2,-72(fp)
81146774:	10bfffcc 	andi	r2,r2,65535
81146778:	10fffe0c 	andi	r3,r2,65528
8114677c:	00bffe14 	movui	r2,65528
81146780:	1880051e 	bne	r3,r2,81146798 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
81146784:	00bfffc4 	movi	r2,-1
81146788:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
8114678c:	00a045f4 	movhi	r2,33047
81146790:	10b82404 	addi	r2,r2,-8048
81146794:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
81146798:	e0bfee0b 	ldhu	r2,-72(fp)
8114679c:	10bfffcc 	andi	r2,r2,65535
811467a0:	10bffe0c 	andi	r2,r2,65528
811467a4:	e0bfe715 	stw	r2,-100(fp)
811467a8:	00000206 	br	811467b4 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
811467ac:	00bfffc4 	movi	r2,-1
811467b0:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
811467b4:	e0bfe717 	ldw	r2,-100(fp)
811467b8:	00fffdd4 	movui	r3,65527
811467bc:	18bf8e0e 	bge	r3,r2,811465f8 <__reset+0xfb1265f8>
811467c0:	00000206 	br	811467cc <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
811467c4:	008000c4 	movi	r2,3
811467c8:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
811467cc:	e0bfe60b 	ldhu	r2,-104(fp)
}
811467d0:	e037883a 	mov	sp,fp
811467d4:	dfc00117 	ldw	ra,4(sp)
811467d8:	df000017 	ldw	fp,0(sp)
811467dc:	dec00204 	addi	sp,sp,8
811467e0:	f800283a 	ret

811467e4 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
811467e4:	deffe904 	addi	sp,sp,-92
811467e8:	de00012e 	bgeu	sp,et,811467f0 <alt_up_sd_card_fopen+0xc>
811467ec:	003b68fa 	trap	3
811467f0:	dfc01615 	stw	ra,88(sp)
811467f4:	df001515 	stw	fp,84(sp)
811467f8:	df001504 	addi	fp,sp,84
811467fc:	e13ffe15 	stw	r4,-8(fp)
81146800:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
81146804:	00bfffc4 	movi	r2,-1
81146808:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8114680c:	114620c0 	call	8114620c <alt_up_sd_card_is_Present>
81146810:	1000cf26 	beq	r2,zero,81146b50 <alt_up_sd_card_fopen+0x36c>
81146814:	d0a0aa17 	ldw	r2,-32088(gp)
81146818:	1000cd26 	beq	r2,zero,81146b50 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
8114681c:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
81146820:	e13ffe17 	ldw	r4,-8(fp)
81146824:	11445f80 	call	811445f8 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
81146828:	e13ffe17 	ldw	r4,-8(fp)
8114682c:	11446c40 	call	811446c4 <check_file_name_for_FAT16_compliance>
81146830:	1000c726 	beq	r2,zero,81146b50 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
81146834:	e0ffee04 	addi	r3,fp,-72
81146838:	e0bfed04 	addi	r2,fp,-76
8114683c:	180d883a 	mov	r6,r3
81146840:	100b883a 	mov	r5,r2
81146844:	e13ffe17 	ldw	r4,-8(fp)
81146848:	1144c9c0 	call	81144c9c <get_home_directory_cluster_for_file>
8114684c:	1000021e 	bne	r2,zero,81146858 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
81146850:	e0bfeb0b 	ldhu	r2,-84(fp)
81146854:	0000bf06 	br	81146b54 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81146858:	e03fec15 	stw	zero,-80(fp)
8114685c:	00000e06 	br	81146898 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
81146860:	00a045f4 	movhi	r2,33047
81146864:	10b83e04 	addi	r2,r2,-7944
81146868:	e0ffec17 	ldw	r3,-80(fp)
8114686c:	180691ba 	slli	r3,r3,6
81146870:	10c5883a 	add	r2,r2,r3
81146874:	10800f04 	addi	r2,r2,60
81146878:	10800017 	ldw	r2,0(r2)
8114687c:	1000031e 	bne	r2,zero,8114688c <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
81146880:	e0bfec17 	ldw	r2,-80(fp)
81146884:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
81146888:	00000606 	br	811468a4 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8114688c:	e0bfec17 	ldw	r2,-80(fp)
81146890:	10800044 	addi	r2,r2,1
81146894:	e0bfec15 	stw	r2,-80(fp)
81146898:	e0bfec17 	ldw	r2,-80(fp)
8114689c:	10800510 	cmplti	r2,r2,20
811468a0:	103fef1e 	bne	r2,zero,81146860 <__reset+0xfb126860>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
811468a4:	e0bfeb0f 	ldh	r2,-84(fp)
811468a8:	1000a916 	blt	r2,zero,81146b50 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
811468ac:	e0bfed17 	ldw	r2,-76(fp)
811468b0:	1009883a 	mov	r4,r2
811468b4:	e0bfeb0f 	ldh	r2,-84(fp)
811468b8:	100691ba 	slli	r3,r2,6
811468bc:	00a045f4 	movhi	r2,33047
811468c0:	10b83e04 	addi	r2,r2,-7944
811468c4:	1885883a 	add	r2,r3,r2
811468c8:	100d883a 	mov	r6,r2
811468cc:	e17ffe17 	ldw	r5,-8(fp)
811468d0:	11451dc0 	call	811451dc <find_file_in_directory>
811468d4:	10007b26 	beq	r2,zero,81146ac4 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
811468d8:	e0bfff17 	ldw	r2,-4(fp)
811468dc:	10000226 	beq	r2,zero,811468e8 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
811468e0:	00bfffc4 	movi	r2,-1
811468e4:	00009b06 	br	81146b54 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
811468e8:	e13feb0f 	ldh	r4,-84(fp)
811468ec:	e0ffeb0f 	ldh	r3,-84(fp)
811468f0:	00a045f4 	movhi	r2,33047
811468f4:	10b83e04 	addi	r2,r2,-7944
811468f8:	180691ba 	slli	r3,r3,6
811468fc:	10c5883a 	add	r2,r2,r3
81146900:	10800584 	addi	r2,r2,22
81146904:	1080000b 	ldhu	r2,0(r2)
81146908:	10ffffcc 	andi	r3,r2,65535
8114690c:	00a045f4 	movhi	r2,33047
81146910:	10b83e04 	addi	r2,r2,-7944
81146914:	200891ba 	slli	r4,r4,6
81146918:	1105883a 	add	r2,r2,r4
8114691c:	10800704 	addi	r2,r2,28
81146920:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
81146924:	e0ffeb0f 	ldh	r3,-84(fp)
81146928:	00a045f4 	movhi	r2,33047
8114692c:	10b83e04 	addi	r2,r2,-7944
81146930:	180691ba 	slli	r3,r3,6
81146934:	10c5883a 	add	r2,r2,r3
81146938:	10800804 	addi	r2,r2,32
8114693c:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
81146940:	e0ffeb0f 	ldh	r3,-84(fp)
81146944:	00a045f4 	movhi	r2,33047
81146948:	10b83e04 	addi	r2,r2,-7944
8114694c:	180691ba 	slli	r3,r3,6
81146950:	10c5883a 	add	r2,r2,r3
81146954:	10800904 	addi	r2,r2,36
81146958:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
8114695c:	e0ffeb0f 	ldh	r3,-84(fp)
81146960:	00a045f4 	movhi	r2,33047
81146964:	10b83e04 	addi	r2,r2,-7944
81146968:	180691ba 	slli	r3,r3,6
8114696c:	10c5883a 	add	r2,r2,r3
81146970:	10800f04 	addi	r2,r2,60
81146974:	00c00044 	movi	r3,1
81146978:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
8114697c:	e0ffeb0f 	ldh	r3,-84(fp)
81146980:	00a045f4 	movhi	r2,33047
81146984:	10b83e04 	addi	r2,r2,-7944
81146988:	180691ba 	slli	r3,r3,6
8114698c:	10c5883a 	add	r2,r2,r3
81146990:	10800e04 	addi	r2,r2,56
81146994:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81146998:	e03fec15 	stw	zero,-80(fp)
8114699c:	00004506 	br	81146ab4 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
811469a0:	e0ffeb0f 	ldh	r3,-84(fp)
811469a4:	e0bfec17 	ldw	r2,-80(fp)
811469a8:	18803f26 	beq	r3,r2,81146aa8 <alt_up_sd_card_fopen+0x2c4>
811469ac:	00a045f4 	movhi	r2,33047
811469b0:	10b83e04 	addi	r2,r2,-7944
811469b4:	e0ffec17 	ldw	r3,-80(fp)
811469b8:	180691ba 	slli	r3,r3,6
811469bc:	10c5883a 	add	r2,r2,r3
811469c0:	10800f04 	addi	r2,r2,60
811469c4:	10800017 	ldw	r2,0(r2)
811469c8:	10800058 	cmpnei	r2,r2,1
811469cc:	1000361e 	bne	r2,zero,81146aa8 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
811469d0:	e0ffeb0f 	ldh	r3,-84(fp)
811469d4:	00a045f4 	movhi	r2,33047
811469d8:	10b83e04 	addi	r2,r2,-7944
811469dc:	180691ba 	slli	r3,r3,6
811469e0:	10c5883a 	add	r2,r2,r3
811469e4:	10800a04 	addi	r2,r2,40
811469e8:	10c00017 	ldw	r3,0(r2)
811469ec:	00a045f4 	movhi	r2,33047
811469f0:	10b83e04 	addi	r2,r2,-7944
811469f4:	e13fec17 	ldw	r4,-80(fp)
811469f8:	200891ba 	slli	r4,r4,6
811469fc:	1105883a 	add	r2,r2,r4
81146a00:	10800a04 	addi	r2,r2,40
81146a04:	10800017 	ldw	r2,0(r2)
81146a08:	1880271e 	bne	r3,r2,81146aa8 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81146a0c:	e0ffeb0f 	ldh	r3,-84(fp)
81146a10:	00a045f4 	movhi	r2,33047
81146a14:	10b83e04 	addi	r2,r2,-7944
81146a18:	180691ba 	slli	r3,r3,6
81146a1c:	10c5883a 	add	r2,r2,r3
81146a20:	10800b04 	addi	r2,r2,44
81146a24:	10c00017 	ldw	r3,0(r2)
81146a28:	00a045f4 	movhi	r2,33047
81146a2c:	10b83e04 	addi	r2,r2,-7944
81146a30:	e13fec17 	ldw	r4,-80(fp)
81146a34:	200891ba 	slli	r4,r4,6
81146a38:	1105883a 	add	r2,r2,r4
81146a3c:	10800b04 	addi	r2,r2,44
81146a40:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81146a44:	1880181e 	bne	r3,r2,81146aa8 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
81146a48:	e0ffeb0f 	ldh	r3,-84(fp)
81146a4c:	00a045f4 	movhi	r2,33047
81146a50:	10b83e04 	addi	r2,r2,-7944
81146a54:	180691ba 	slli	r3,r3,6
81146a58:	10c5883a 	add	r2,r2,r3
81146a5c:	10800c04 	addi	r2,r2,48
81146a60:	1100000b 	ldhu	r4,0(r2)
81146a64:	00a045f4 	movhi	r2,33047
81146a68:	10b83e04 	addi	r2,r2,-7944
81146a6c:	e0ffec17 	ldw	r3,-80(fp)
81146a70:	180691ba 	slli	r3,r3,6
81146a74:	10c5883a 	add	r2,r2,r3
81146a78:	10800c04 	addi	r2,r2,48
81146a7c:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81146a80:	20ffffcc 	andi	r3,r4,65535
81146a84:	18e0001c 	xori	r3,r3,32768
81146a88:	18e00004 	addi	r3,r3,-32768
81146a8c:	10bfffcc 	andi	r2,r2,65535
81146a90:	10a0001c 	xori	r2,r2,32768
81146a94:	10a00004 	addi	r2,r2,-32768
81146a98:	1880031e 	bne	r3,r2,81146aa8 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
81146a9c:	00bfff84 	movi	r2,-2
81146aa0:	e0bfeb0d 	sth	r2,-84(fp)
								break;
81146aa4:	00002a06 	br	81146b50 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81146aa8:	e0bfec17 	ldw	r2,-80(fp)
81146aac:	10800044 	addi	r2,r2,1
81146ab0:	e0bfec15 	stw	r2,-80(fp)
81146ab4:	e0bfec17 	ldw	r2,-80(fp)
81146ab8:	10800510 	cmplti	r2,r2,20
81146abc:	103fb81e 	bne	r2,zero,811469a0 <__reset+0xfb1269a0>
81146ac0:	00002306 	br	81146b50 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
81146ac4:	e0bfff17 	ldw	r2,-4(fp)
81146ac8:	10001f26 	beq	r2,zero,81146b48 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
81146acc:	e0bfeb0f 	ldh	r2,-84(fp)
81146ad0:	100691ba 	slli	r3,r2,6
81146ad4:	00a045f4 	movhi	r2,33047
81146ad8:	10b83e04 	addi	r2,r2,-7944
81146adc:	1885883a 	add	r2,r3,r2
81146ae0:	e0ffee04 	addi	r3,fp,-72
81146ae4:	180d883a 	mov	r6,r3
81146ae8:	100b883a 	mov	r5,r2
81146aec:	e13ffe17 	ldw	r4,-8(fp)
81146af0:	1145d280 	call	81145d28 <create_file>
81146af4:	10001126 	beq	r2,zero,81146b3c <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
81146af8:	e0ffeb0f 	ldh	r3,-84(fp)
81146afc:	00a045f4 	movhi	r2,33047
81146b00:	10b83e04 	addi	r2,r2,-7944
81146b04:	180691ba 	slli	r3,r3,6
81146b08:	10c5883a 	add	r2,r2,r3
81146b0c:	10800f04 	addi	r2,r2,60
81146b10:	00c00044 	movi	r3,1
81146b14:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
81146b18:	e0ffeb0f 	ldh	r3,-84(fp)
81146b1c:	00a045f4 	movhi	r2,33047
81146b20:	10b83e04 	addi	r2,r2,-7944
81146b24:	180691ba 	slli	r3,r3,6
81146b28:	10c5883a 	add	r2,r2,r3
81146b2c:	10800e04 	addi	r2,r2,56
81146b30:	00c00044 	movi	r3,1
81146b34:	10c00015 	stw	r3,0(r2)
81146b38:	00000506 	br	81146b50 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
81146b3c:	00bfffc4 	movi	r2,-1
81146b40:	e0bfeb0d 	sth	r2,-84(fp)
81146b44:	00000206 	br	81146b50 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
81146b48:	00bfffc4 	movi	r2,-1
81146b4c:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
81146b50:	e0bfeb0b 	ldhu	r2,-84(fp)
}
81146b54:	e037883a 	mov	sp,fp
81146b58:	dfc00117 	ldw	ra,4(sp)
81146b5c:	df000017 	ldw	fp,0(sp)
81146b60:	dec00204 	addi	sp,sp,8
81146b64:	f800283a 	ret

81146b68 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81146b68:	defffd04 	addi	sp,sp,-12
81146b6c:	de00012e 	bgeu	sp,et,81146b74 <alt_up_sd_card_set_attributes+0xc>
81146b70:	003b68fa 	trap	3
81146b74:	df000215 	stw	fp,8(sp)
81146b78:	df000204 	addi	fp,sp,8
81146b7c:	2007883a 	mov	r3,r4
81146b80:	2805883a 	mov	r2,r5
81146b84:	e0fffe0d 	sth	r3,-8(fp)
81146b88:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81146b8c:	e0bffe0f 	ldh	r2,-8(fp)
81146b90:	10001416 	blt	r2,zero,81146be4 <alt_up_sd_card_set_attributes+0x7c>
81146b94:	e0bffe0f 	ldh	r2,-8(fp)
81146b98:	10800508 	cmpgei	r2,r2,20
81146b9c:	1000111e 	bne	r2,zero,81146be4 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81146ba0:	e0fffe0f 	ldh	r3,-8(fp)
81146ba4:	00a045f4 	movhi	r2,33047
81146ba8:	10b83e04 	addi	r2,r2,-7944
81146bac:	180691ba 	slli	r3,r3,6
81146bb0:	10c5883a 	add	r2,r2,r3
81146bb4:	10800f04 	addi	r2,r2,60
81146bb8:	10800017 	ldw	r2,0(r2)
81146bbc:	10000926 	beq	r2,zero,81146be4 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
81146bc0:	e0fffe0f 	ldh	r3,-8(fp)
81146bc4:	e0bfff0b 	ldhu	r2,-4(fp)
81146bc8:	1009883a 	mov	r4,r2
81146bcc:	00a045f4 	movhi	r2,33047
81146bd0:	10b83e04 	addi	r2,r2,-7944
81146bd4:	180691ba 	slli	r3,r3,6
81146bd8:	10c5883a 	add	r2,r2,r3
81146bdc:	108002c4 	addi	r2,r2,11
81146be0:	11000005 	stb	r4,0(r2)
        }
    }
}
81146be4:	0001883a 	nop
81146be8:	e037883a 	mov	sp,fp
81146bec:	df000017 	ldw	fp,0(sp)
81146bf0:	dec00104 	addi	sp,sp,4
81146bf4:	f800283a 	ret

81146bf8 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81146bf8:	defffd04 	addi	sp,sp,-12
81146bfc:	de00012e 	bgeu	sp,et,81146c04 <alt_up_sd_card_get_attributes+0xc>
81146c00:	003b68fa 	trap	3
81146c04:	df000215 	stw	fp,8(sp)
81146c08:	df000204 	addi	fp,sp,8
81146c0c:	2005883a 	mov	r2,r4
81146c10:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
81146c14:	00bfffc4 	movi	r2,-1
81146c18:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81146c1c:	e0bfff0f 	ldh	r2,-4(fp)
81146c20:	10001416 	blt	r2,zero,81146c74 <alt_up_sd_card_get_attributes+0x7c>
81146c24:	e0bfff0f 	ldh	r2,-4(fp)
81146c28:	10800508 	cmpgei	r2,r2,20
81146c2c:	1000111e 	bne	r2,zero,81146c74 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81146c30:	e0ffff0f 	ldh	r3,-4(fp)
81146c34:	00a045f4 	movhi	r2,33047
81146c38:	10b83e04 	addi	r2,r2,-7944
81146c3c:	180691ba 	slli	r3,r3,6
81146c40:	10c5883a 	add	r2,r2,r3
81146c44:	10800f04 	addi	r2,r2,60
81146c48:	10800017 	ldw	r2,0(r2)
81146c4c:	10000926 	beq	r2,zero,81146c74 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
81146c50:	e0ffff0f 	ldh	r3,-4(fp)
81146c54:	00a045f4 	movhi	r2,33047
81146c58:	10b83e04 	addi	r2,r2,-7944
81146c5c:	180691ba 	slli	r3,r3,6
81146c60:	10c5883a 	add	r2,r2,r3
81146c64:	108002c4 	addi	r2,r2,11
81146c68:	10800003 	ldbu	r2,0(r2)
81146c6c:	10803fcc 	andi	r2,r2,255
81146c70:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
81146c74:	e0bffe0b 	ldhu	r2,-8(fp)
}
81146c78:	e037883a 	mov	sp,fp
81146c7c:	df000017 	ldw	fp,0(sp)
81146c80:	dec00104 	addi	sp,sp,4
81146c84:	f800283a 	ret

81146c88 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
81146c88:	defffa04 	addi	sp,sp,-24
81146c8c:	de00012e 	bgeu	sp,et,81146c94 <alt_up_sd_card_read+0xc>
81146c90:	003b68fa 	trap	3
81146c94:	dfc00515 	stw	ra,20(sp)
81146c98:	df000415 	stw	fp,16(sp)
81146c9c:	df000404 	addi	fp,sp,16
81146ca0:	2005883a 	mov	r2,r4
81146ca4:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
81146ca8:	00bfffc4 	movi	r2,-1
81146cac:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81146cb0:	e0bfff0f 	ldh	r2,-4(fp)
81146cb4:	1000ce16 	blt	r2,zero,81146ff0 <alt_up_sd_card_read+0x368>
81146cb8:	e0bfff0f 	ldh	r2,-4(fp)
81146cbc:	10800508 	cmpgei	r2,r2,20
81146cc0:	1000cb1e 	bne	r2,zero,81146ff0 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
81146cc4:	e0ffff0f 	ldh	r3,-4(fp)
81146cc8:	00a045f4 	movhi	r2,33047
81146ccc:	10b83e04 	addi	r2,r2,-7944
81146cd0:	180691ba 	slli	r3,r3,6
81146cd4:	10c5883a 	add	r2,r2,r3
81146cd8:	10800f04 	addi	r2,r2,60
81146cdc:	10800017 	ldw	r2,0(r2)
81146ce0:	1000c326 	beq	r2,zero,81146ff0 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81146ce4:	e0ffff0f 	ldh	r3,-4(fp)
81146ce8:	00a045f4 	movhi	r2,33047
81146cec:	10b83e04 	addi	r2,r2,-7944
81146cf0:	180691ba 	slli	r3,r3,6
81146cf4:	10c5883a 	add	r2,r2,r3
81146cf8:	10800904 	addi	r2,r2,36
81146cfc:	10c00017 	ldw	r3,0(r2)
81146d00:	e13fff0f 	ldh	r4,-4(fp)
81146d04:	00a045f4 	movhi	r2,33047
81146d08:	10b83e04 	addi	r2,r2,-7944
81146d0c:	200891ba 	slli	r4,r4,6
81146d10:	1105883a 	add	r2,r2,r4
81146d14:	10800604 	addi	r2,r2,24
81146d18:	10800017 	ldw	r2,0(r2)
81146d1c:	1880b42e 	bgeu	r3,r2,81146ff0 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81146d20:	00a045f4 	movhi	r2,33047
81146d24:	10b82904 	addi	r2,r2,-8028
81146d28:	10c01417 	ldw	r3,80(r2)
81146d2c:	e13fff0f 	ldh	r4,-4(fp)
81146d30:	00a045f4 	movhi	r2,33047
81146d34:	10b83e04 	addi	r2,r2,-7944
81146d38:	200891ba 	slli	r4,r4,6
81146d3c:	1105883a 	add	r2,r2,r4
81146d40:	10800704 	addi	r2,r2,28
81146d44:	10800017 	ldw	r2,0(r2)
81146d48:	113fff84 	addi	r4,r2,-2
81146d4c:	00a045f4 	movhi	r2,33047
81146d50:	10b82904 	addi	r2,r2,-8028
81146d54:	10800383 	ldbu	r2,14(r2)
81146d58:	10803fcc 	andi	r2,r2,255
81146d5c:	2085383a 	mul	r2,r4,r2
81146d60:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81146d64:	e13fff0f 	ldh	r4,-4(fp)
81146d68:	00a045f4 	movhi	r2,33047
81146d6c:	10b83e04 	addi	r2,r2,-7944
81146d70:	200891ba 	slli	r4,r4,6
81146d74:	1105883a 	add	r2,r2,r4
81146d78:	10800804 	addi	r2,r2,32
81146d7c:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81146d80:	1885883a 	add	r2,r3,r2
81146d84:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
81146d88:	e0ffff0f 	ldh	r3,-4(fp)
81146d8c:	00a045f4 	movhi	r2,33047
81146d90:	10b83e04 	addi	r2,r2,-7944
81146d94:	180691ba 	slli	r3,r3,6
81146d98:	10c5883a 	add	r2,r2,r3
81146d9c:	10800904 	addi	r2,r2,36
81146da0:	10800017 	ldw	r2,0(r2)
81146da4:	10006826 	beq	r2,zero,81146f48 <alt_up_sd_card_read+0x2c0>
81146da8:	e0ffff0f 	ldh	r3,-4(fp)
81146dac:	00a045f4 	movhi	r2,33047
81146db0:	10b83e04 	addi	r2,r2,-7944
81146db4:	180691ba 	slli	r3,r3,6
81146db8:	10c5883a 	add	r2,r2,r3
81146dbc:	10800904 	addi	r2,r2,36
81146dc0:	10800017 	ldw	r2,0(r2)
81146dc4:	10807fcc 	andi	r2,r2,511
81146dc8:	10005f1e 	bne	r2,zero,81146f48 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81146dcc:	e0ffff0f 	ldh	r3,-4(fp)
81146dd0:	00a045f4 	movhi	r2,33047
81146dd4:	10b83e04 	addi	r2,r2,-7944
81146dd8:	180691ba 	slli	r3,r3,6
81146ddc:	10c5883a 	add	r2,r2,r3
81146de0:	10800804 	addi	r2,r2,32
81146de4:	10c00017 	ldw	r3,0(r2)
81146de8:	00a045f4 	movhi	r2,33047
81146dec:	10b82904 	addi	r2,r2,-8028
81146df0:	10800383 	ldbu	r2,14(r2)
81146df4:	10803fcc 	andi	r2,r2,255
81146df8:	10bfffc4 	addi	r2,r2,-1
81146dfc:	1880401e 	bne	r3,r2,81146f00 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81146e00:	e0ffff0f 	ldh	r3,-4(fp)
81146e04:	00a045f4 	movhi	r2,33047
81146e08:	10b83e04 	addi	r2,r2,-7944
81146e0c:	180691ba 	slli	r3,r3,6
81146e10:	10c5883a 	add	r2,r2,r3
81146e14:	10800704 	addi	r2,r2,28
81146e18:	10800017 	ldw	r2,0(r2)
81146e1c:	e0fffe04 	addi	r3,fp,-8
81146e20:	180b883a 	mov	r5,r3
81146e24:	1009883a 	mov	r4,r2
81146e28:	11436140 	call	81143614 <get_cluster_flag>
81146e2c:	10003226 	beq	r2,zero,81146ef8 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81146e30:	e0bffe0b 	ldhu	r2,-8(fp)
81146e34:	10bfffcc 	andi	r2,r2,65535
81146e38:	10fffe0c 	andi	r3,r2,65528
81146e3c:	00bffe14 	movui	r2,65528
81146e40:	1880021e 	bne	r3,r2,81146e4c <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81146e44:	00bfffc4 	movi	r2,-1
81146e48:	00006a06 	br	81146ff4 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81146e4c:	e13fff0f 	ldh	r4,-4(fp)
81146e50:	e0bffe0b 	ldhu	r2,-8(fp)
81146e54:	10ffffcc 	andi	r3,r2,65535
81146e58:	00a045f4 	movhi	r2,33047
81146e5c:	10b83e04 	addi	r2,r2,-7944
81146e60:	200891ba 	slli	r4,r4,6
81146e64:	1105883a 	add	r2,r2,r4
81146e68:	10800704 	addi	r2,r2,28
81146e6c:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81146e70:	e0ffff0f 	ldh	r3,-4(fp)
81146e74:	00a045f4 	movhi	r2,33047
81146e78:	10b83e04 	addi	r2,r2,-7944
81146e7c:	180691ba 	slli	r3,r3,6
81146e80:	10c5883a 	add	r2,r2,r3
81146e84:	10800804 	addi	r2,r2,32
81146e88:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81146e8c:	00a045f4 	movhi	r2,33047
81146e90:	10b82904 	addi	r2,r2,-8028
81146e94:	10c01417 	ldw	r3,80(r2)
81146e98:	e13fff0f 	ldh	r4,-4(fp)
81146e9c:	00a045f4 	movhi	r2,33047
81146ea0:	10b83e04 	addi	r2,r2,-7944
81146ea4:	200891ba 	slli	r4,r4,6
81146ea8:	1105883a 	add	r2,r2,r4
81146eac:	10800704 	addi	r2,r2,28
81146eb0:	10800017 	ldw	r2,0(r2)
81146eb4:	113fff84 	addi	r4,r2,-2
81146eb8:	00a045f4 	movhi	r2,33047
81146ebc:	10b82904 	addi	r2,r2,-8028
81146ec0:	10800383 	ldbu	r2,14(r2)
81146ec4:	10803fcc 	andi	r2,r2,255
81146ec8:	2085383a 	mul	r2,r4,r2
81146ecc:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81146ed0:	e13fff0f 	ldh	r4,-4(fp)
81146ed4:	00a045f4 	movhi	r2,33047
81146ed8:	10b83e04 	addi	r2,r2,-7944
81146edc:	200891ba 	slli	r4,r4,6
81146ee0:	1105883a 	add	r2,r2,r4
81146ee4:	10800804 	addi	r2,r2,32
81146ee8:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81146eec:	1885883a 	add	r2,r3,r2
81146ef0:	e0bffd15 	stw	r2,-12(fp)
81146ef4:	00001406 	br	81146f48 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
81146ef8:	00bfff84 	movi	r2,-2
81146efc:	00003d06 	br	81146ff4 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81146f00:	e13fff0f 	ldh	r4,-4(fp)
81146f04:	e0ffff0f 	ldh	r3,-4(fp)
81146f08:	00a045f4 	movhi	r2,33047
81146f0c:	10b83e04 	addi	r2,r2,-7944
81146f10:	180691ba 	slli	r3,r3,6
81146f14:	10c5883a 	add	r2,r2,r3
81146f18:	10800804 	addi	r2,r2,32
81146f1c:	10800017 	ldw	r2,0(r2)
81146f20:	10c00044 	addi	r3,r2,1
81146f24:	00a045f4 	movhi	r2,33047
81146f28:	10b83e04 	addi	r2,r2,-7944
81146f2c:	200891ba 	slli	r4,r4,6
81146f30:	1105883a 	add	r2,r2,r4
81146f34:	10800804 	addi	r2,r2,32
81146f38:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81146f3c:	e0bffd17 	ldw	r2,-12(fp)
81146f40:	10800044 	addi	r2,r2,1
81146f44:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
81146f48:	d0e0b117 	ldw	r3,-32060(gp)
81146f4c:	e0bffd17 	ldw	r2,-12(fp)
81146f50:	1885883a 	add	r2,r3,r2
81146f54:	1007883a 	mov	r3,r2
81146f58:	d0a0b517 	ldw	r2,-32044(gp)
81146f5c:	18800726 	beq	r3,r2,81146f7c <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81146f60:	d0a0b117 	ldw	r2,-32060(gp)
81146f64:	100b883a 	mov	r5,r2
81146f68:	e13ffd17 	ldw	r4,-12(fp)
81146f6c:	11435340 	call	81143534 <Read_Sector_Data>
81146f70:	1000021e 	bne	r2,zero,81146f7c <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81146f74:	00bfff84 	movi	r2,-2
81146f78:	00001e06 	br	81146ff4 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
81146f7c:	d0e0b017 	ldw	r3,-32064(gp)
81146f80:	e13fff0f 	ldh	r4,-4(fp)
81146f84:	00a045f4 	movhi	r2,33047
81146f88:	10b83e04 	addi	r2,r2,-7944
81146f8c:	200891ba 	slli	r4,r4,6
81146f90:	1105883a 	add	r2,r2,r4
81146f94:	10800904 	addi	r2,r2,36
81146f98:	10800017 	ldw	r2,0(r2)
81146f9c:	10807fcc 	andi	r2,r2,511
81146fa0:	1885883a 	add	r2,r3,r2
81146fa4:	10800023 	ldbuio	r2,0(r2)
81146fa8:	10803fcc 	andi	r2,r2,255
81146fac:	10803fcc 	andi	r2,r2,255
81146fb0:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81146fb4:	e13fff0f 	ldh	r4,-4(fp)
81146fb8:	e0ffff0f 	ldh	r3,-4(fp)
81146fbc:	00a045f4 	movhi	r2,33047
81146fc0:	10b83e04 	addi	r2,r2,-7944
81146fc4:	180691ba 	slli	r3,r3,6
81146fc8:	10c5883a 	add	r2,r2,r3
81146fcc:	10800904 	addi	r2,r2,36
81146fd0:	10800017 	ldw	r2,0(r2)
81146fd4:	10c00044 	addi	r3,r2,1
81146fd8:	00a045f4 	movhi	r2,33047
81146fdc:	10b83e04 	addi	r2,r2,-7944
81146fe0:	200891ba 	slli	r4,r4,6
81146fe4:	1105883a 	add	r2,r2,r4
81146fe8:	10800904 	addi	r2,r2,36
81146fec:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
81146ff0:	e0bffc0b 	ldhu	r2,-16(fp)
}
81146ff4:	e037883a 	mov	sp,fp
81146ff8:	dfc00117 	ldw	ra,4(sp)
81146ffc:	df000017 	ldw	fp,0(sp)
81147000:	dec00204 	addi	sp,sp,8
81147004:	f800283a 	ret

81147008 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
81147008:	defff804 	addi	sp,sp,-32
8114700c:	de00012e 	bgeu	sp,et,81147014 <alt_up_sd_card_write+0xc>
81147010:	003b68fa 	trap	3
81147014:	dfc00715 	stw	ra,28(sp)
81147018:	df000615 	stw	fp,24(sp)
8114701c:	df000604 	addi	fp,sp,24
81147020:	2007883a 	mov	r3,r4
81147024:	2805883a 	mov	r2,r5
81147028:	e0fffe0d 	sth	r3,-8(fp)
8114702c:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
81147030:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81147034:	e0bffe0f 	ldh	r2,-8(fp)
81147038:	10017716 	blt	r2,zero,81147618 <alt_up_sd_card_write+0x610>
8114703c:	e0bffe0f 	ldh	r2,-8(fp)
81147040:	10800508 	cmpgei	r2,r2,20
81147044:	1001741e 	bne	r2,zero,81147618 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
81147048:	e0fffe0f 	ldh	r3,-8(fp)
8114704c:	00a045f4 	movhi	r2,33047
81147050:	10b83e04 	addi	r2,r2,-7944
81147054:	180691ba 	slli	r3,r3,6
81147058:	10c5883a 	add	r2,r2,r3
8114705c:	10800f04 	addi	r2,r2,60
81147060:	10800017 	ldw	r2,0(r2)
81147064:	10016c26 	beq	r2,zero,81147618 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147068:	00a045f4 	movhi	r2,33047
8114706c:	10b82904 	addi	r2,r2,-8028
81147070:	10c01417 	ldw	r3,80(r2)
81147074:	e13ffe0f 	ldh	r4,-8(fp)
81147078:	00a045f4 	movhi	r2,33047
8114707c:	10b83e04 	addi	r2,r2,-7944
81147080:	200891ba 	slli	r4,r4,6
81147084:	1105883a 	add	r2,r2,r4
81147088:	10800704 	addi	r2,r2,28
8114708c:	10800017 	ldw	r2,0(r2)
81147090:	113fff84 	addi	r4,r2,-2
81147094:	00a045f4 	movhi	r2,33047
81147098:	10b82904 	addi	r2,r2,-8028
8114709c:	10800383 	ldbu	r2,14(r2)
811470a0:	10803fcc 	andi	r2,r2,255
811470a4:	2085383a 	mul	r2,r4,r2
811470a8:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
811470ac:	e13ffe0f 	ldh	r4,-8(fp)
811470b0:	00a045f4 	movhi	r2,33047
811470b4:	10b83e04 	addi	r2,r2,-7944
811470b8:	200891ba 	slli	r4,r4,6
811470bc:	1105883a 	add	r2,r2,r4
811470c0:	10800804 	addi	r2,r2,32
811470c4:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811470c8:	1885883a 	add	r2,r3,r2
811470cc:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
811470d0:	e0fffe0f 	ldh	r3,-8(fp)
811470d4:	00a045f4 	movhi	r2,33047
811470d8:	10b83e04 	addi	r2,r2,-7944
811470dc:	180691ba 	slli	r3,r3,6
811470e0:	10c5883a 	add	r2,r2,r3
811470e4:	10800904 	addi	r2,r2,36
811470e8:	10c00017 	ldw	r3,0(r2)
811470ec:	00a045f4 	movhi	r2,33047
811470f0:	10b82904 	addi	r2,r2,-8028
811470f4:	1080030b 	ldhu	r2,12(r2)
811470f8:	10bfffcc 	andi	r2,r2,65535
811470fc:	1889203a 	divu	r4,r3,r2
81147100:	2085383a 	mul	r2,r4,r2
81147104:	1885c83a 	sub	r2,r3,r2
81147108:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
8114710c:	e0fffe0f 	ldh	r3,-8(fp)
81147110:	00a045f4 	movhi	r2,33047
81147114:	10b83e04 	addi	r2,r2,-7944
81147118:	180691ba 	slli	r3,r3,6
8114711c:	10c5883a 	add	r2,r2,r3
81147120:	10800904 	addi	r2,r2,36
81147124:	10c00017 	ldw	r3,0(r2)
81147128:	e13ffe0f 	ldh	r4,-8(fp)
8114712c:	00a045f4 	movhi	r2,33047
81147130:	10b83e04 	addi	r2,r2,-7944
81147134:	200891ba 	slli	r4,r4,6
81147138:	1105883a 	add	r2,r2,r4
8114713c:	10800604 	addi	r2,r2,24
81147140:	10800017 	ldw	r2,0(r2)
81147144:	1880672e 	bgeu	r3,r2,811472e4 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81147148:	e0fffe0f 	ldh	r3,-8(fp)
8114714c:	00a045f4 	movhi	r2,33047
81147150:	10b83e04 	addi	r2,r2,-7944
81147154:	180691ba 	slli	r3,r3,6
81147158:	10c5883a 	add	r2,r2,r3
8114715c:	10800904 	addi	r2,r2,36
81147160:	10800017 	ldw	r2,0(r2)
81147164:	1000e126 	beq	r2,zero,811474ec <alt_up_sd_card_write+0x4e4>
81147168:	e0bffc0f 	ldh	r2,-16(fp)
8114716c:	1000df1e 	bne	r2,zero,811474ec <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81147170:	e0fffe0f 	ldh	r3,-8(fp)
81147174:	00a045f4 	movhi	r2,33047
81147178:	10b83e04 	addi	r2,r2,-7944
8114717c:	180691ba 	slli	r3,r3,6
81147180:	10c5883a 	add	r2,r2,r3
81147184:	10800804 	addi	r2,r2,32
81147188:	10c00017 	ldw	r3,0(r2)
8114718c:	00a045f4 	movhi	r2,33047
81147190:	10b82904 	addi	r2,r2,-8028
81147194:	10800383 	ldbu	r2,14(r2)
81147198:	10803fcc 	andi	r2,r2,255
8114719c:	10bfffc4 	addi	r2,r2,-1
811471a0:	18803d1e 	bne	r3,r2,81147298 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
811471a4:	e0fffe0f 	ldh	r3,-8(fp)
811471a8:	00a045f4 	movhi	r2,33047
811471ac:	10b83e04 	addi	r2,r2,-7944
811471b0:	180691ba 	slli	r3,r3,6
811471b4:	10c5883a 	add	r2,r2,r3
811471b8:	10800704 	addi	r2,r2,28
811471bc:	10800017 	ldw	r2,0(r2)
811471c0:	e0fffc84 	addi	r3,fp,-14
811471c4:	180b883a 	mov	r5,r3
811471c8:	1009883a 	mov	r4,r2
811471cc:	11436140 	call	81143614 <get_cluster_flag>
811471d0:	10002f26 	beq	r2,zero,81147290 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
811471d4:	e0bffc8b 	ldhu	r2,-14(fp)
811471d8:	10bfffcc 	andi	r2,r2,65535
811471dc:	10bffe28 	cmpgeui	r2,r2,65528
811471e0:	1000c21e 	bne	r2,zero,811474ec <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
811471e4:	e13ffe0f 	ldh	r4,-8(fp)
811471e8:	e0bffc8b 	ldhu	r2,-14(fp)
811471ec:	10ffffcc 	andi	r3,r2,65535
811471f0:	00a045f4 	movhi	r2,33047
811471f4:	10b83e04 	addi	r2,r2,-7944
811471f8:	200891ba 	slli	r4,r4,6
811471fc:	1105883a 	add	r2,r2,r4
81147200:	10800704 	addi	r2,r2,28
81147204:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81147208:	e0fffe0f 	ldh	r3,-8(fp)
8114720c:	00a045f4 	movhi	r2,33047
81147210:	10b83e04 	addi	r2,r2,-7944
81147214:	180691ba 	slli	r3,r3,6
81147218:	10c5883a 	add	r2,r2,r3
8114721c:	10800804 	addi	r2,r2,32
81147220:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147224:	00a045f4 	movhi	r2,33047
81147228:	10b82904 	addi	r2,r2,-8028
8114722c:	10c01417 	ldw	r3,80(r2)
81147230:	e13ffe0f 	ldh	r4,-8(fp)
81147234:	00a045f4 	movhi	r2,33047
81147238:	10b83e04 	addi	r2,r2,-7944
8114723c:	200891ba 	slli	r4,r4,6
81147240:	1105883a 	add	r2,r2,r4
81147244:	10800704 	addi	r2,r2,28
81147248:	10800017 	ldw	r2,0(r2)
8114724c:	113fff84 	addi	r4,r2,-2
81147250:	00a045f4 	movhi	r2,33047
81147254:	10b82904 	addi	r2,r2,-8028
81147258:	10800383 	ldbu	r2,14(r2)
8114725c:	10803fcc 	andi	r2,r2,255
81147260:	2085383a 	mul	r2,r4,r2
81147264:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81147268:	e13ffe0f 	ldh	r4,-8(fp)
8114726c:	00a045f4 	movhi	r2,33047
81147270:	10b83e04 	addi	r2,r2,-7944
81147274:	200891ba 	slli	r4,r4,6
81147278:	1105883a 	add	r2,r2,r4
8114727c:	10800804 	addi	r2,r2,32
81147280:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147284:	1885883a 	add	r2,r3,r2
81147288:	e0bffb15 	stw	r2,-20(fp)
8114728c:	00009706 	br	811474ec <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
81147290:	0005883a 	mov	r2,zero
81147294:	0000e106 	br	8114761c <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81147298:	e13ffe0f 	ldh	r4,-8(fp)
8114729c:	e0fffe0f 	ldh	r3,-8(fp)
811472a0:	00a045f4 	movhi	r2,33047
811472a4:	10b83e04 	addi	r2,r2,-7944
811472a8:	180691ba 	slli	r3,r3,6
811472ac:	10c5883a 	add	r2,r2,r3
811472b0:	10800804 	addi	r2,r2,32
811472b4:	10800017 	ldw	r2,0(r2)
811472b8:	10c00044 	addi	r3,r2,1
811472bc:	00a045f4 	movhi	r2,33047
811472c0:	10b83e04 	addi	r2,r2,-7944
811472c4:	200891ba 	slli	r4,r4,6
811472c8:	1105883a 	add	r2,r2,r4
811472cc:	10800804 	addi	r2,r2,32
811472d0:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
811472d4:	e0bffb17 	ldw	r2,-20(fp)
811472d8:	10800044 	addi	r2,r2,1
811472dc:	e0bffb15 	stw	r2,-20(fp)
811472e0:	00008206 	br	811474ec <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
811472e4:	e0fffe0f 	ldh	r3,-8(fp)
811472e8:	00a045f4 	movhi	r2,33047
811472ec:	10b83e04 	addi	r2,r2,-7944
811472f0:	180691ba 	slli	r3,r3,6
811472f4:	10c5883a 	add	r2,r2,r3
811472f8:	10800904 	addi	r2,r2,36
811472fc:	10800017 	ldw	r2,0(r2)
81147300:	10007a26 	beq	r2,zero,811474ec <alt_up_sd_card_write+0x4e4>
81147304:	e0bffc0f 	ldh	r2,-16(fp)
81147308:	1000781e 	bne	r2,zero,811474ec <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8114730c:	e0fffe0f 	ldh	r3,-8(fp)
81147310:	00a045f4 	movhi	r2,33047
81147314:	10b83e04 	addi	r2,r2,-7944
81147318:	180691ba 	slli	r3,r3,6
8114731c:	10c5883a 	add	r2,r2,r3
81147320:	10800804 	addi	r2,r2,32
81147324:	10c00017 	ldw	r3,0(r2)
81147328:	00a045f4 	movhi	r2,33047
8114732c:	10b82904 	addi	r2,r2,-8028
81147330:	10800383 	ldbu	r2,14(r2)
81147334:	10803fcc 	andi	r2,r2,255
81147338:	10bfffc4 	addi	r2,r2,-1
8114733c:	18803e1e 	bne	r3,r2,81147438 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
81147340:	e0bffd04 	addi	r2,fp,-12
81147344:	1009883a 	mov	r4,r2
81147348:	11456580 	call	81145658 <find_first_empty_cluster>
8114734c:	10003826 	beq	r2,zero,81147430 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
81147350:	e0fffe0f 	ldh	r3,-8(fp)
81147354:	00a045f4 	movhi	r2,33047
81147358:	10b83e04 	addi	r2,r2,-7944
8114735c:	180691ba 	slli	r3,r3,6
81147360:	10c5883a 	add	r2,r2,r3
81147364:	10800704 	addi	r2,r2,28
81147368:	10800017 	ldw	r2,0(r2)
8114736c:	e0fffd17 	ldw	r3,-12(fp)
81147370:	18ffffcc 	andi	r3,r3,65535
81147374:	18e0001c 	xori	r3,r3,32768
81147378:	18e00004 	addi	r3,r3,-32768
8114737c:	01800044 	movi	r6,1
81147380:	180b883a 	mov	r5,r3
81147384:	1009883a 	mov	r4,r2
81147388:	11436d00 	call	811436d0 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
8114738c:	e0bffd17 	ldw	r2,-12(fp)
81147390:	01800044 	movi	r6,1
81147394:	017fffc4 	movi	r5,-1
81147398:	1009883a 	mov	r4,r2
8114739c:	11436d00 	call	811436d0 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
811473a0:	e0fffe0f 	ldh	r3,-8(fp)
811473a4:	00a045f4 	movhi	r2,33047
811473a8:	10b83e04 	addi	r2,r2,-7944
811473ac:	180691ba 	slli	r3,r3,6
811473b0:	10c5883a 	add	r2,r2,r3
811473b4:	10800704 	addi	r2,r2,28
811473b8:	10800017 	ldw	r2,0(r2)
811473bc:	e0fffd17 	ldw	r3,-12(fp)
811473c0:	18ffffcc 	andi	r3,r3,65535
811473c4:	18e0001c 	xori	r3,r3,32768
811473c8:	18e00004 	addi	r3,r3,-32768
811473cc:	000d883a 	mov	r6,zero
811473d0:	180b883a 	mov	r5,r3
811473d4:	1009883a 	mov	r4,r2
811473d8:	11436d00 	call	811436d0 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
811473dc:	e0bffd17 	ldw	r2,-12(fp)
811473e0:	000d883a 	mov	r6,zero
811473e4:	017fffc4 	movi	r5,-1
811473e8:	1009883a 	mov	r4,r2
811473ec:	11436d00 	call	811436d0 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
811473f0:	e13ffe0f 	ldh	r4,-8(fp)
811473f4:	e0fffd17 	ldw	r3,-12(fp)
811473f8:	00a045f4 	movhi	r2,33047
811473fc:	10b83e04 	addi	r2,r2,-7944
81147400:	200891ba 	slli	r4,r4,6
81147404:	1105883a 	add	r2,r2,r4
81147408:	10800704 	addi	r2,r2,28
8114740c:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
81147410:	e0fffe0f 	ldh	r3,-8(fp)
81147414:	00a045f4 	movhi	r2,33047
81147418:	10b83e04 	addi	r2,r2,-7944
8114741c:	180691ba 	slli	r3,r3,6
81147420:	10c5883a 	add	r2,r2,r3
81147424:	10800804 	addi	r2,r2,32
81147428:	10000015 	stw	zero,0(r2)
8114742c:	00001506 	br	81147484 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
81147430:	0005883a 	mov	r2,zero
81147434:	00007906 	br	8114761c <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81147438:	e13ffe0f 	ldh	r4,-8(fp)
8114743c:	e0fffe0f 	ldh	r3,-8(fp)
81147440:	00a045f4 	movhi	r2,33047
81147444:	10b83e04 	addi	r2,r2,-7944
81147448:	180691ba 	slli	r3,r3,6
8114744c:	10c5883a 	add	r2,r2,r3
81147450:	10800904 	addi	r2,r2,36
81147454:	10c00017 	ldw	r3,0(r2)
81147458:	00a045f4 	movhi	r2,33047
8114745c:	10b82904 	addi	r2,r2,-8028
81147460:	1080030b 	ldhu	r2,12(r2)
81147464:	10bfffcc 	andi	r2,r2,65535
81147468:	1887203a 	divu	r3,r3,r2
8114746c:	00a045f4 	movhi	r2,33047
81147470:	10b83e04 	addi	r2,r2,-7944
81147474:	200891ba 	slli	r4,r4,6
81147478:	1105883a 	add	r2,r2,r4
8114747c:	10800804 	addi	r2,r2,32
81147480:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81147484:	00a045f4 	movhi	r2,33047
81147488:	10b82904 	addi	r2,r2,-8028
8114748c:	10c01417 	ldw	r3,80(r2)
81147490:	e13ffe0f 	ldh	r4,-8(fp)
81147494:	00a045f4 	movhi	r2,33047
81147498:	10b83e04 	addi	r2,r2,-7944
8114749c:	200891ba 	slli	r4,r4,6
811474a0:	1105883a 	add	r2,r2,r4
811474a4:	10800704 	addi	r2,r2,28
811474a8:	10800017 	ldw	r2,0(r2)
811474ac:	113fff84 	addi	r4,r2,-2
811474b0:	00a045f4 	movhi	r2,33047
811474b4:	10b82904 	addi	r2,r2,-8028
811474b8:	10800383 	ldbu	r2,14(r2)
811474bc:	10803fcc 	andi	r2,r2,255
811474c0:	2085383a 	mul	r2,r4,r2
811474c4:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
811474c8:	e13ffe0f 	ldh	r4,-8(fp)
811474cc:	00a045f4 	movhi	r2,33047
811474d0:	10b83e04 	addi	r2,r2,-7944
811474d4:	200891ba 	slli	r4,r4,6
811474d8:	1105883a 	add	r2,r2,r4
811474dc:	10800804 	addi	r2,r2,32
811474e0:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811474e4:	1885883a 	add	r2,r3,r2
811474e8:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
811474ec:	d0e0b117 	ldw	r3,-32060(gp)
811474f0:	e0bffb17 	ldw	r2,-20(fp)
811474f4:	1885883a 	add	r2,r3,r2
811474f8:	1007883a 	mov	r3,r2
811474fc:	d0a0b517 	ldw	r2,-32044(gp)
81147500:	18800726 	beq	r3,r2,81147520 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81147504:	d0a0b117 	ldw	r2,-32060(gp)
81147508:	100b883a 	mov	r5,r2
8114750c:	e13ffb17 	ldw	r4,-20(fp)
81147510:	11435340 	call	81143534 <Read_Sector_Data>
81147514:	1000021e 	bne	r2,zero,81147520 <alt_up_sd_card_write+0x518>
                {
					return false;
81147518:	0005883a 	mov	r2,zero
8114751c:	00003f06 	br	8114761c <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
81147520:	d0e0b017 	ldw	r3,-32064(gp)
81147524:	e0bffc0f 	ldh	r2,-16(fp)
81147528:	1885883a 	add	r2,r3,r2
8114752c:	e0ffff07 	ldb	r3,-4(fp)
81147530:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81147534:	e13ffe0f 	ldh	r4,-8(fp)
81147538:	e0fffe0f 	ldh	r3,-8(fp)
8114753c:	00a045f4 	movhi	r2,33047
81147540:	10b83e04 	addi	r2,r2,-7944
81147544:	180691ba 	slli	r3,r3,6
81147548:	10c5883a 	add	r2,r2,r3
8114754c:	10800904 	addi	r2,r2,36
81147550:	10800017 	ldw	r2,0(r2)
81147554:	10c00044 	addi	r3,r2,1
81147558:	00a045f4 	movhi	r2,33047
8114755c:	10b83e04 	addi	r2,r2,-7944
81147560:	200891ba 	slli	r4,r4,6
81147564:	1105883a 	add	r2,r2,r4
81147568:	10800904 	addi	r2,r2,36
8114756c:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
81147570:	e0fffe0f 	ldh	r3,-8(fp)
81147574:	00a045f4 	movhi	r2,33047
81147578:	10b83e04 	addi	r2,r2,-7944
8114757c:	180691ba 	slli	r3,r3,6
81147580:	10c5883a 	add	r2,r2,r3
81147584:	10800904 	addi	r2,r2,36
81147588:	10c00017 	ldw	r3,0(r2)
8114758c:	e13ffe0f 	ldh	r4,-8(fp)
81147590:	00a045f4 	movhi	r2,33047
81147594:	10b83e04 	addi	r2,r2,-7944
81147598:	200891ba 	slli	r4,r4,6
8114759c:	1105883a 	add	r2,r2,r4
811475a0:	10800604 	addi	r2,r2,24
811475a4:	10800017 	ldw	r2,0(r2)
811475a8:	18801736 	bltu	r3,r2,81147608 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
811475ac:	e13ffe0f 	ldh	r4,-8(fp)
811475b0:	e0fffe0f 	ldh	r3,-8(fp)
811475b4:	00a045f4 	movhi	r2,33047
811475b8:	10b83e04 	addi	r2,r2,-7944
811475bc:	180691ba 	slli	r3,r3,6
811475c0:	10c5883a 	add	r2,r2,r3
811475c4:	10800604 	addi	r2,r2,24
811475c8:	10800017 	ldw	r2,0(r2)
811475cc:	10c00044 	addi	r3,r2,1
811475d0:	00a045f4 	movhi	r2,33047
811475d4:	10b83e04 	addi	r2,r2,-7944
811475d8:	200891ba 	slli	r4,r4,6
811475dc:	1105883a 	add	r2,r2,r4
811475e0:	10800604 	addi	r2,r2,24
811475e4:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
811475e8:	e0fffe0f 	ldh	r3,-8(fp)
811475ec:	00a045f4 	movhi	r2,33047
811475f0:	10b83e04 	addi	r2,r2,-7944
811475f4:	180691ba 	slli	r3,r3,6
811475f8:	10c5883a 	add	r2,r2,r3
811475fc:	10800e04 	addi	r2,r2,56
81147600:	00c00044 	movi	r3,1
81147604:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81147608:	00800044 	movi	r2,1
8114760c:	d0a0b415 	stw	r2,-32048(gp)
			result = true;
81147610:	00800044 	movi	r2,1
81147614:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81147618:	e0bffa17 	ldw	r2,-24(fp)
}
8114761c:	e037883a 	mov	sp,fp
81147620:	dfc00117 	ldw	ra,4(sp)
81147624:	df000017 	ldw	fp,0(sp)
81147628:	dec00204 	addi	sp,sp,8
8114762c:	f800283a 	ret

81147630 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
81147630:	defffb04 	addi	sp,sp,-20
81147634:	de00012e 	bgeu	sp,et,8114763c <alt_up_sd_card_fclose+0xc>
81147638:	003b68fa 	trap	3
8114763c:	dfc00415 	stw	ra,16(sp)
81147640:	df000315 	stw	fp,12(sp)
81147644:	df000304 	addi	fp,sp,12
81147648:	2005883a 	mov	r2,r4
8114764c:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
81147650:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81147654:	114620c0 	call	8114620c <alt_up_sd_card_is_Present>
81147658:	10006026 	beq	r2,zero,811477dc <alt_up_sd_card_fclose+0x1ac>
8114765c:	d0a0aa17 	ldw	r2,-32088(gp)
81147660:	10005e26 	beq	r2,zero,811477dc <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
81147664:	e0ffff0f 	ldh	r3,-4(fp)
81147668:	00a045f4 	movhi	r2,33047
8114766c:	10b83e04 	addi	r2,r2,-7944
81147670:	180691ba 	slli	r3,r3,6
81147674:	10c5883a 	add	r2,r2,r3
81147678:	10800f04 	addi	r2,r2,60
8114767c:	10800017 	ldw	r2,0(r2)
81147680:	10005626 	beq	r2,zero,811477dc <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
81147684:	e0ffff0f 	ldh	r3,-4(fp)
81147688:	00a045f4 	movhi	r2,33047
8114768c:	10b83e04 	addi	r2,r2,-7944
81147690:	180691ba 	slli	r3,r3,6
81147694:	10c5883a 	add	r2,r2,r3
81147698:	10800e04 	addi	r2,r2,56
8114769c:	10800017 	ldw	r2,0(r2)
811476a0:	10004526 	beq	r2,zero,811477b8 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
811476a4:	e0ffff0f 	ldh	r3,-4(fp)
811476a8:	00a045f4 	movhi	r2,33047
811476ac:	10b83e04 	addi	r2,r2,-7944
811476b0:	180691ba 	slli	r3,r3,6
811476b4:	10c5883a 	add	r2,r2,r3
811476b8:	10800b04 	addi	r2,r2,44
811476bc:	10800017 	ldw	r2,0(r2)
811476c0:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
811476c4:	e0ffff0f 	ldh	r3,-4(fp)
811476c8:	00a045f4 	movhi	r2,33047
811476cc:	10b83e04 	addi	r2,r2,-7944
811476d0:	180691ba 	slli	r3,r3,6
811476d4:	10c5883a 	add	r2,r2,r3
811476d8:	10800a04 	addi	r2,r2,40
811476dc:	10800017 	ldw	r2,0(r2)
811476e0:	1000071e 	bne	r2,zero,81147700 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
811476e4:	00a045f4 	movhi	r2,33047
811476e8:	10b82904 	addi	r2,r2,-8028
811476ec:	10801317 	ldw	r2,76(r2)
811476f0:	e0fffe17 	ldw	r3,-8(fp)
811476f4:	1885883a 	add	r2,r3,r2
811476f8:	e0bffe15 	stw	r2,-8(fp)
811476fc:	00001406 	br	81147750 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81147700:	00a045f4 	movhi	r2,33047
81147704:	10b82904 	addi	r2,r2,-8028
81147708:	10c01417 	ldw	r3,80(r2)
8114770c:	e0bffe17 	ldw	r2,-8(fp)
81147710:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
81147714:	e13fff0f 	ldh	r4,-4(fp)
81147718:	00a045f4 	movhi	r2,33047
8114771c:	10b83e04 	addi	r2,r2,-7944
81147720:	200891ba 	slli	r4,r4,6
81147724:	1105883a 	add	r2,r2,r4
81147728:	10800a04 	addi	r2,r2,40
8114772c:	10800017 	ldw	r2,0(r2)
81147730:	113fff84 	addi	r4,r2,-2
81147734:	00a045f4 	movhi	r2,33047
81147738:	10b82904 	addi	r2,r2,-8028
8114773c:	10800383 	ldbu	r2,14(r2)
81147740:	10803fcc 	andi	r2,r2,255
81147744:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81147748:	1885883a 	add	r2,r3,r2
8114774c:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
81147750:	e0bffe17 	ldw	r2,-8(fp)
81147754:	d0e0b117 	ldw	r3,-32060(gp)
81147758:	180b883a 	mov	r5,r3
8114775c:	1009883a 	mov	r4,r2
81147760:	11435340 	call	81143534 <Read_Sector_Data>
81147764:	10001426 	beq	r2,zero,811477b8 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
81147768:	e0ffff0f 	ldh	r3,-4(fp)
8114776c:	00a045f4 	movhi	r2,33047
81147770:	10b83e04 	addi	r2,r2,-7944
81147774:	180691ba 	slli	r3,r3,6
81147778:	10c5883a 	add	r2,r2,r3
8114777c:	10800c04 	addi	r2,r2,48
81147780:	1080000b 	ldhu	r2,0(r2)
81147784:	113fffcc 	andi	r4,r2,65535
81147788:	2120001c 	xori	r4,r4,32768
8114778c:	21200004 	addi	r4,r4,-32768
81147790:	e0bfff0f 	ldh	r2,-4(fp)
81147794:	100691ba 	slli	r3,r2,6
81147798:	00a045f4 	movhi	r2,33047
8114779c:	10b83e04 	addi	r2,r2,-7944
811477a0:	1885883a 	add	r2,r3,r2
811477a4:	100b883a 	mov	r5,r2
811477a8:	1143be80 	call	81143be8 <Write_File_Record_At_Offset>
811477ac:	10000226 	beq	r2,zero,811477b8 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
811477b0:	11434e00 	call	811434e0 <Save_Modified_Sector>
811477b4:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
811477b8:	e0ffff0f 	ldh	r3,-4(fp)
811477bc:	00a045f4 	movhi	r2,33047
811477c0:	10b83e04 	addi	r2,r2,-7944
811477c4:	180691ba 	slli	r3,r3,6
811477c8:	10c5883a 	add	r2,r2,r3
811477cc:	10800f04 	addi	r2,r2,60
811477d0:	10000015 	stw	zero,0(r2)
			result = true;
811477d4:	00800044 	movi	r2,1
811477d8:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
811477dc:	e0bffd17 	ldw	r2,-12(fp)
}
811477e0:	e037883a 	mov	sp,fp
811477e4:	dfc00117 	ldw	ra,4(sp)
811477e8:	df000017 	ldw	fp,0(sp)
811477ec:	dec00204 	addi	sp,sp,8
811477f0:	f800283a 	ret

811477f4 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
811477f4:	defffa04 	addi	sp,sp,-24
811477f8:	de00012e 	bgeu	sp,et,81147800 <altera_avalon_jtag_uart_read_fd+0xc>
811477fc:	003b68fa 	trap	3
81147800:	dfc00515 	stw	ra,20(sp)
81147804:	df000415 	stw	fp,16(sp)
81147808:	df000404 	addi	fp,sp,16
8114780c:	e13ffd15 	stw	r4,-12(fp)
81147810:	e17ffe15 	stw	r5,-8(fp)
81147814:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81147818:	e0bffd17 	ldw	r2,-12(fp)
8114781c:	10800017 	ldw	r2,0(r2)
81147820:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
81147824:	e0bffc17 	ldw	r2,-16(fp)
81147828:	10c00a04 	addi	r3,r2,40
8114782c:	e0bffd17 	ldw	r2,-12(fp)
81147830:	10800217 	ldw	r2,8(r2)
81147834:	100f883a 	mov	r7,r2
81147838:	e1bfff17 	ldw	r6,-4(fp)
8114783c:	e17ffe17 	ldw	r5,-8(fp)
81147840:	1809883a 	mov	r4,r3
81147844:	11480780 	call	81148078 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
81147848:	e037883a 	mov	sp,fp
8114784c:	dfc00117 	ldw	ra,4(sp)
81147850:	df000017 	ldw	fp,0(sp)
81147854:	dec00204 	addi	sp,sp,8
81147858:	f800283a 	ret

8114785c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
8114785c:	defffa04 	addi	sp,sp,-24
81147860:	de00012e 	bgeu	sp,et,81147868 <altera_avalon_jtag_uart_write_fd+0xc>
81147864:	003b68fa 	trap	3
81147868:	dfc00515 	stw	ra,20(sp)
8114786c:	df000415 	stw	fp,16(sp)
81147870:	df000404 	addi	fp,sp,16
81147874:	e13ffd15 	stw	r4,-12(fp)
81147878:	e17ffe15 	stw	r5,-8(fp)
8114787c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81147880:	e0bffd17 	ldw	r2,-12(fp)
81147884:	10800017 	ldw	r2,0(r2)
81147888:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
8114788c:	e0bffc17 	ldw	r2,-16(fp)
81147890:	10c00a04 	addi	r3,r2,40
81147894:	e0bffd17 	ldw	r2,-12(fp)
81147898:	10800217 	ldw	r2,8(r2)
8114789c:	100f883a 	mov	r7,r2
811478a0:	e1bfff17 	ldw	r6,-4(fp)
811478a4:	e17ffe17 	ldw	r5,-8(fp)
811478a8:	1809883a 	mov	r4,r3
811478ac:	114833c0 	call	8114833c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
811478b0:	e037883a 	mov	sp,fp
811478b4:	dfc00117 	ldw	ra,4(sp)
811478b8:	df000017 	ldw	fp,0(sp)
811478bc:	dec00204 	addi	sp,sp,8
811478c0:	f800283a 	ret

811478c4 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
811478c4:	defffc04 	addi	sp,sp,-16
811478c8:	de00012e 	bgeu	sp,et,811478d0 <altera_avalon_jtag_uart_close_fd+0xc>
811478cc:	003b68fa 	trap	3
811478d0:	dfc00315 	stw	ra,12(sp)
811478d4:	df000215 	stw	fp,8(sp)
811478d8:	df000204 	addi	fp,sp,8
811478dc:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811478e0:	e0bfff17 	ldw	r2,-4(fp)
811478e4:	10800017 	ldw	r2,0(r2)
811478e8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
811478ec:	e0bffe17 	ldw	r2,-8(fp)
811478f0:	10c00a04 	addi	r3,r2,40
811478f4:	e0bfff17 	ldw	r2,-4(fp)
811478f8:	10800217 	ldw	r2,8(r2)
811478fc:	100b883a 	mov	r5,r2
81147900:	1809883a 	mov	r4,r3
81147904:	1147f100 	call	81147f10 <altera_avalon_jtag_uart_close>
}
81147908:	e037883a 	mov	sp,fp
8114790c:	dfc00117 	ldw	ra,4(sp)
81147910:	df000017 	ldw	fp,0(sp)
81147914:	dec00204 	addi	sp,sp,8
81147918:	f800283a 	ret

8114791c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
8114791c:	defffa04 	addi	sp,sp,-24
81147920:	de00012e 	bgeu	sp,et,81147928 <altera_avalon_jtag_uart_ioctl_fd+0xc>
81147924:	003b68fa 	trap	3
81147928:	dfc00515 	stw	ra,20(sp)
8114792c:	df000415 	stw	fp,16(sp)
81147930:	df000404 	addi	fp,sp,16
81147934:	e13ffd15 	stw	r4,-12(fp)
81147938:	e17ffe15 	stw	r5,-8(fp)
8114793c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
81147940:	e0bffd17 	ldw	r2,-12(fp)
81147944:	10800017 	ldw	r2,0(r2)
81147948:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
8114794c:	e0bffc17 	ldw	r2,-16(fp)
81147950:	10800a04 	addi	r2,r2,40
81147954:	e1bfff17 	ldw	r6,-4(fp)
81147958:	e17ffe17 	ldw	r5,-8(fp)
8114795c:	1009883a 	mov	r4,r2
81147960:	1147f800 	call	81147f80 <altera_avalon_jtag_uart_ioctl>
}
81147964:	e037883a 	mov	sp,fp
81147968:	dfc00117 	ldw	ra,4(sp)
8114796c:	df000017 	ldw	fp,0(sp)
81147970:	dec00204 	addi	sp,sp,8
81147974:	f800283a 	ret

81147978 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
81147978:	deffef04 	addi	sp,sp,-68
8114797c:	de00012e 	bgeu	sp,et,81147984 <altera_avalon_jtag_uart_init+0xc>
81147980:	003b68fa 	trap	3
81147984:	dfc01015 	stw	ra,64(sp)
81147988:	df000f15 	stw	fp,60(sp)
8114798c:	dc400e15 	stw	r17,56(sp)
81147990:	dc000d15 	stw	r16,52(sp)
81147994:	df000f04 	addi	fp,sp,60
81147998:	e13ff715 	stw	r4,-36(fp)
8114799c:	e17ff815 	stw	r5,-32(fp)
811479a0:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
811479a4:	e0bff717 	ldw	r2,-36(fp)
811479a8:	10800c04 	addi	r2,r2,48
811479ac:	e0bff215 	stw	r2,-56(fp)
811479b0:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
811479b4:	e0bff60b 	ldhu	r2,-40(fp)
811479b8:	e0fff684 	addi	r3,fp,-38
811479bc:	180b883a 	mov	r5,r3
811479c0:	1009883a 	mov	r4,r2
811479c4:	113bb480 	call	8113bb48 <OSFlagCreate>
811479c8:	1007883a 	mov	r3,r2
811479cc:	e0bff217 	ldw	r2,-56(fp)
811479d0:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
811479d4:	e0bff717 	ldw	r2,-36(fp)
811479d8:	10800a04 	addi	r2,r2,40
811479dc:	e0bff315 	stw	r2,-52(fp)
811479e0:	00800044 	movi	r2,1
811479e4:	e0bff58d 	sth	r2,-42(fp)
811479e8:	e0bff58b 	ldhu	r2,-42(fp)
811479ec:	1009883a 	mov	r4,r2
811479f0:	113faa40 	call	8113faa4 <OSSemCreate>
811479f4:	1007883a 	mov	r3,r2
811479f8:	e0bff317 	ldw	r2,-52(fp)
811479fc:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
81147a00:	e0bff717 	ldw	r2,-36(fp)
81147a04:	10800b04 	addi	r2,r2,44
81147a08:	e0bff415 	stw	r2,-48(fp)
81147a0c:	00800044 	movi	r2,1
81147a10:	e0bff50d 	sth	r2,-44(fp)
81147a14:	e0bff50b 	ldhu	r2,-44(fp)
81147a18:	1009883a 	mov	r4,r2
81147a1c:	113faa40 	call	8113faa4 <OSSemCreate>
81147a20:	1007883a 	mov	r3,r2
81147a24:	e0bff417 	ldw	r2,-48(fp)
81147a28:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81147a2c:	e0bff717 	ldw	r2,-36(fp)
81147a30:	00c00044 	movi	r3,1
81147a34:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
81147a38:	e0bff717 	ldw	r2,-36(fp)
81147a3c:	10800017 	ldw	r2,0(r2)
81147a40:	10800104 	addi	r2,r2,4
81147a44:	1007883a 	mov	r3,r2
81147a48:	e0bff717 	ldw	r2,-36(fp)
81147a4c:	10800817 	ldw	r2,32(r2)
81147a50:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
81147a54:	e0bff817 	ldw	r2,-32(fp)
81147a58:	e0fff917 	ldw	r3,-28(fp)
81147a5c:	d8000015 	stw	zero,0(sp)
81147a60:	e1fff717 	ldw	r7,-36(fp)
81147a64:	01a04534 	movhi	r6,33044
81147a68:	319ed204 	addi	r6,r6,31560
81147a6c:	180b883a 	mov	r5,r3
81147a70:	1009883a 	mov	r4,r2
81147a74:	114b8900 	call	8114b890 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
81147a78:	e0bff717 	ldw	r2,-36(fp)
81147a7c:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
81147a80:	e0bff717 	ldw	r2,-36(fp)
81147a84:	10800204 	addi	r2,r2,8
81147a88:	d0e08817 	ldw	r3,-32224(gp)
81147a8c:	e1fff717 	ldw	r7,-36(fp)
81147a90:	01a04534 	movhi	r6,33044
81147a94:	319f8104 	addi	r6,r6,32260
81147a98:	180b883a 	mov	r5,r3
81147a9c:	1009883a 	mov	r4,r2
81147aa0:	114b3e00 	call	8114b3e0 <alt_alarm_start>
81147aa4:	1000040e 	bge	r2,zero,81147ab8 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
81147aa8:	e0fff717 	ldw	r3,-36(fp)
81147aac:	00a00034 	movhi	r2,32768
81147ab0:	10bfffc4 	addi	r2,r2,-1
81147ab4:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
81147ab8:	d0a08183 	ldbu	r2,-32250(gp)
81147abc:	10803fcc 	andi	r2,r2,255
81147ac0:	10800058 	cmpnei	r2,r2,1
81147ac4:	10000f1e 	bne	r2,zero,81147b04 <altera_avalon_jtag_uart_init+0x18c>
81147ac8:	d0e08817 	ldw	r3,-32224(gp)
81147acc:	00b33374 	movhi	r2,52429
81147ad0:	10b33344 	addi	r2,r2,-13107
81147ad4:	1888383a 	mulxuu	r4,r3,r2
81147ad8:	1885383a 	mul	r2,r3,r2
81147adc:	1021883a 	mov	r16,r2
81147ae0:	2023883a 	mov	r17,r4
81147ae4:	8804d0fa 	srli	r2,r17,3
81147ae8:	e1fff717 	ldw	r7,-36(fp)
81147aec:	01a04534 	movhi	r6,33044
81147af0:	31a09e04 	addi	r6,r6,-32136
81147af4:	100b883a 	mov	r5,r2
81147af8:	012045b4 	movhi	r4,33046
81147afc:	211ffd04 	addi	r4,r4,32756
81147b00:	114b3e00 	call	8114b3e0 <alt_alarm_start>
81147b04:	d0a08203 	ldbu	r2,-32248(gp)
81147b08:	10803fcc 	andi	r2,r2,255
81147b0c:	10800058 	cmpnei	r2,r2,1
81147b10:	1000051e 	bne	r2,zero,81147b28 <altera_avalon_jtag_uart_init+0x1b0>
81147b14:	e0bff717 	ldw	r2,-36(fp)
81147b18:	10800017 	ldw	r2,0(r2)
81147b1c:	100b883a 	mov	r5,r2
81147b20:	e13ff717 	ldw	r4,-36(fp)
81147b24:	11384100 	call	81138410 <alt_log_jtag_uart_startup_info>
}
81147b28:	0001883a 	nop
81147b2c:	e6fffe04 	addi	sp,fp,-8
81147b30:	dfc00317 	ldw	ra,12(sp)
81147b34:	df000217 	ldw	fp,8(sp)
81147b38:	dc400117 	ldw	r17,4(sp)
81147b3c:	dc000017 	ldw	r16,0(sp)
81147b40:	dec00404 	addi	sp,sp,16
81147b44:	f800283a 	ret

81147b48 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
81147b48:	defff204 	addi	sp,sp,-56
81147b4c:	de00012e 	bgeu	sp,et,81147b54 <altera_avalon_jtag_uart_irq+0xc>
81147b50:	003b68fa 	trap	3
81147b54:	dfc00d15 	stw	ra,52(sp)
81147b58:	df000c15 	stw	fp,48(sp)
81147b5c:	df000c04 	addi	fp,sp,48
81147b60:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
81147b64:	e0bfff17 	ldw	r2,-4(fp)
81147b68:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
81147b6c:	e0bff617 	ldw	r2,-40(fp)
81147b70:	10800017 	ldw	r2,0(r2)
81147b74:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
81147b78:	e0bff717 	ldw	r2,-36(fp)
81147b7c:	e17ff617 	ldw	r5,-40(fp)
81147b80:	1009883a 	mov	r4,r2
81147b84:	11384640 	call	81138464 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81147b88:	e0bff717 	ldw	r2,-36(fp)
81147b8c:	10800104 	addi	r2,r2,4
81147b90:	10800037 	ldwio	r2,0(r2)
81147b94:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
81147b98:	e0bff817 	ldw	r2,-32(fp)
81147b9c:	1080c00c 	andi	r2,r2,768
81147ba0:	10009126 	beq	r2,zero,81147de8 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
81147ba4:	e0bff817 	ldw	r2,-32(fp)
81147ba8:	1080400c 	andi	r2,r2,256
81147bac:	10004726 	beq	r2,zero,81147ccc <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
81147bb0:	00800074 	movhi	r2,1
81147bb4:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81147bb8:	e0bff617 	ldw	r2,-40(fp)
81147bbc:	10800d17 	ldw	r2,52(r2)
81147bc0:	10800044 	addi	r2,r2,1
81147bc4:	1081ffcc 	andi	r2,r2,2047
81147bc8:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
81147bcc:	e0bff617 	ldw	r2,-40(fp)
81147bd0:	10c00e17 	ldw	r3,56(r2)
81147bd4:	e0bff917 	ldw	r2,-28(fp)
81147bd8:	18802726 	beq	r3,r2,81147c78 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
81147bdc:	e0bff717 	ldw	r2,-36(fp)
81147be0:	10800037 	ldwio	r2,0(r2)
81147be4:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
81147be8:	e0bff417 	ldw	r2,-48(fp)
81147bec:	10a0000c 	andi	r2,r2,32768
81147bf0:	10002326 	beq	r2,zero,81147c80 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
81147bf4:	e0bff617 	ldw	r2,-40(fp)
81147bf8:	10800d17 	ldw	r2,52(r2)
81147bfc:	e0fff417 	ldw	r3,-48(fp)
81147c00:	1809883a 	mov	r4,r3
81147c04:	e0fff617 	ldw	r3,-40(fp)
81147c08:	1885883a 	add	r2,r3,r2
81147c0c:	10801104 	addi	r2,r2,68
81147c10:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81147c14:	e0bff617 	ldw	r2,-40(fp)
81147c18:	10800d17 	ldw	r2,52(r2)
81147c1c:	10800044 	addi	r2,r2,1
81147c20:	10c1ffcc 	andi	r3,r2,2047
81147c24:	e0bff617 	ldw	r2,-40(fp)
81147c28:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
81147c2c:	e0bff617 	ldw	r2,-40(fp)
81147c30:	10800c17 	ldw	r2,48(r2)
81147c34:	e0bffb15 	stw	r2,-20(fp)
81147c38:	00800044 	movi	r2,1
81147c3c:	e0bffc0d 	sth	r2,-16(fp)
81147c40:	00800044 	movi	r2,1
81147c44:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81147c48:	d0a09103 	ldbu	r2,-32188(gp)
81147c4c:	10803fcc 	andi	r2,r2,255
81147c50:	103fd926 	beq	r2,zero,81147bb8 <__reset+0xfb127bb8>
  {
    OSFlagPost (group, flags, opt, &err);
81147c54:	e0bffc0b 	ldhu	r2,-16(fp)
81147c58:	e0fffc83 	ldbu	r3,-14(fp)
81147c5c:	e13ffdc4 	addi	r4,fp,-9
81147c60:	200f883a 	mov	r7,r4
81147c64:	180d883a 	mov	r6,r3
81147c68:	100b883a 	mov	r5,r2
81147c6c:	e13ffb17 	ldw	r4,-20(fp)
81147c70:	113c7540 	call	8113c754 <OSFlagPost>
      }
81147c74:	003fd006 	br	81147bb8 <__reset+0xfb127bb8>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
81147c78:	0001883a 	nop
81147c7c:	00000106 	br	81147c84 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
81147c80:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
81147c84:	e0bff417 	ldw	r2,-48(fp)
81147c88:	10bfffec 	andhi	r2,r2,65535
81147c8c:	10000f26 	beq	r2,zero,81147ccc <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81147c90:	e0bff617 	ldw	r2,-40(fp)
81147c94:	10c00817 	ldw	r3,32(r2)
81147c98:	00bfff84 	movi	r2,-2
81147c9c:	1886703a 	and	r3,r3,r2
81147ca0:	e0bff617 	ldw	r2,-40(fp)
81147ca4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
81147ca8:	e0bff717 	ldw	r2,-36(fp)
81147cac:	10800104 	addi	r2,r2,4
81147cb0:	1007883a 	mov	r3,r2
81147cb4:	e0bff617 	ldw	r2,-40(fp)
81147cb8:	10800817 	ldw	r2,32(r2)
81147cbc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81147cc0:	e0bff717 	ldw	r2,-36(fp)
81147cc4:	10800104 	addi	r2,r2,4
81147cc8:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
81147ccc:	e0bff817 	ldw	r2,-32(fp)
81147cd0:	1080800c 	andi	r2,r2,512
81147cd4:	103fac26 	beq	r2,zero,81147b88 <__reset+0xfb127b88>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
81147cd8:	e0bff817 	ldw	r2,-32(fp)
81147cdc:	1004d43a 	srli	r2,r2,16
81147ce0:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
81147ce4:	00002606 	br	81147d80 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
81147ce8:	e0bff717 	ldw	r2,-36(fp)
81147cec:	e0fff617 	ldw	r3,-40(fp)
81147cf0:	18c01017 	ldw	r3,64(r3)
81147cf4:	e13ff617 	ldw	r4,-40(fp)
81147cf8:	20c7883a 	add	r3,r4,r3
81147cfc:	18c21104 	addi	r3,r3,2116
81147d00:	18c00003 	ldbu	r3,0(r3)
81147d04:	18c03fcc 	andi	r3,r3,255
81147d08:	18c0201c 	xori	r3,r3,128
81147d0c:	18ffe004 	addi	r3,r3,-128
81147d10:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81147d14:	e0bff617 	ldw	r2,-40(fp)
81147d18:	10801017 	ldw	r2,64(r2)
81147d1c:	10800044 	addi	r2,r2,1
81147d20:	10c1ffcc 	andi	r3,r2,2047
81147d24:	e0bff617 	ldw	r2,-40(fp)
81147d28:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81147d2c:	e0bff617 	ldw	r2,-40(fp)
81147d30:	10800c17 	ldw	r2,48(r2)
81147d34:	e0bffa15 	stw	r2,-24(fp)
81147d38:	00800084 	movi	r2,2
81147d3c:	e0bffd0d 	sth	r2,-12(fp)
81147d40:	00800044 	movi	r2,1
81147d44:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81147d48:	d0a09103 	ldbu	r2,-32188(gp)
81147d4c:	10803fcc 	andi	r2,r2,255
81147d50:	10000826 	beq	r2,zero,81147d74 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81147d54:	e0bffd0b 	ldhu	r2,-12(fp)
81147d58:	e0fffd83 	ldbu	r3,-10(fp)
81147d5c:	e13ffe04 	addi	r4,fp,-8
81147d60:	200f883a 	mov	r7,r4
81147d64:	180d883a 	mov	r6,r3
81147d68:	100b883a 	mov	r5,r2
81147d6c:	e13ffa17 	ldw	r4,-24(fp)
81147d70:	113c7540 	call	8113c754 <OSFlagPost>

        space--;
81147d74:	e0bff517 	ldw	r2,-44(fp)
81147d78:	10bfffc4 	addi	r2,r2,-1
81147d7c:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
81147d80:	e0bff517 	ldw	r2,-44(fp)
81147d84:	10000526 	beq	r2,zero,81147d9c <altera_avalon_jtag_uart_irq+0x254>
81147d88:	e0bff617 	ldw	r2,-40(fp)
81147d8c:	10c01017 	ldw	r3,64(r2)
81147d90:	e0bff617 	ldw	r2,-40(fp)
81147d94:	10800f17 	ldw	r2,60(r2)
81147d98:	18bfd31e 	bne	r3,r2,81147ce8 <__reset+0xfb127ce8>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
81147d9c:	e0bff517 	ldw	r2,-44(fp)
81147da0:	103f7926 	beq	r2,zero,81147b88 <__reset+0xfb127b88>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81147da4:	e0bff617 	ldw	r2,-40(fp)
81147da8:	10c00817 	ldw	r3,32(r2)
81147dac:	00bfff44 	movi	r2,-3
81147db0:	1886703a 	and	r3,r3,r2
81147db4:	e0bff617 	ldw	r2,-40(fp)
81147db8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81147dbc:	e0bff617 	ldw	r2,-40(fp)
81147dc0:	10800017 	ldw	r2,0(r2)
81147dc4:	10800104 	addi	r2,r2,4
81147dc8:	1007883a 	mov	r3,r2
81147dcc:	e0bff617 	ldw	r2,-40(fp)
81147dd0:	10800817 	ldw	r2,32(r2)
81147dd4:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81147dd8:	e0bff717 	ldw	r2,-36(fp)
81147ddc:	10800104 	addi	r2,r2,4
81147de0:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
81147de4:	003f6806 	br	81147b88 <__reset+0xfb127b88>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
81147de8:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
81147dec:	0001883a 	nop
81147df0:	e037883a 	mov	sp,fp
81147df4:	dfc00117 	ldw	ra,4(sp)
81147df8:	df000017 	ldw	fp,0(sp)
81147dfc:	dec00204 	addi	sp,sp,8
81147e00:	f800283a 	ret

81147e04 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
81147e04:	defff904 	addi	sp,sp,-28
81147e08:	de00012e 	bgeu	sp,et,81147e10 <altera_avalon_jtag_uart_timeout+0xc>
81147e0c:	003b68fa 	trap	3
81147e10:	dfc00615 	stw	ra,24(sp)
81147e14:	df000515 	stw	fp,20(sp)
81147e18:	df000504 	addi	fp,sp,20
81147e1c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
81147e20:	e0bfff17 	ldw	r2,-4(fp)
81147e24:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
81147e28:	e0bffb17 	ldw	r2,-20(fp)
81147e2c:	10800017 	ldw	r2,0(r2)
81147e30:	10800104 	addi	r2,r2,4
81147e34:	10800037 	ldwio	r2,0(r2)
81147e38:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81147e3c:	e0bffc17 	ldw	r2,-16(fp)
81147e40:	1081000c 	andi	r2,r2,1024
81147e44:	10000b26 	beq	r2,zero,81147e74 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
81147e48:	e0bffb17 	ldw	r2,-20(fp)
81147e4c:	10800017 	ldw	r2,0(r2)
81147e50:	10800104 	addi	r2,r2,4
81147e54:	1007883a 	mov	r3,r2
81147e58:	e0bffb17 	ldw	r2,-20(fp)
81147e5c:	10800817 	ldw	r2,32(r2)
81147e60:	10810014 	ori	r2,r2,1024
81147e64:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81147e68:	e0bffb17 	ldw	r2,-20(fp)
81147e6c:	10000915 	stw	zero,36(r2)
81147e70:	00002106 	br	81147ef8 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81147e74:	e0bffb17 	ldw	r2,-20(fp)
81147e78:	10c00917 	ldw	r3,36(r2)
81147e7c:	00a00034 	movhi	r2,32768
81147e80:	10bfff04 	addi	r2,r2,-4
81147e84:	10c01c36 	bltu	r2,r3,81147ef8 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81147e88:	e0bffb17 	ldw	r2,-20(fp)
81147e8c:	10800917 	ldw	r2,36(r2)
81147e90:	10c00044 	addi	r3,r2,1
81147e94:	e0bffb17 	ldw	r2,-20(fp)
81147e98:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
81147e9c:	e0bffb17 	ldw	r2,-20(fp)
81147ea0:	10c00917 	ldw	r3,36(r2)
81147ea4:	e0bffb17 	ldw	r2,-20(fp)
81147ea8:	10800117 	ldw	r2,4(r2)
81147eac:	18801236 	bltu	r3,r2,81147ef8 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
81147eb0:	e0bffb17 	ldw	r2,-20(fp)
81147eb4:	10800c17 	ldw	r2,48(r2)
81147eb8:	e0bffd15 	stw	r2,-12(fp)
81147ebc:	00800104 	movi	r2,4
81147ec0:	e0bffe0d 	sth	r2,-8(fp)
81147ec4:	00800044 	movi	r2,1
81147ec8:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81147ecc:	d0a09103 	ldbu	r2,-32188(gp)
81147ed0:	10803fcc 	andi	r2,r2,255
81147ed4:	10000826 	beq	r2,zero,81147ef8 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81147ed8:	e0bffe0b 	ldhu	r2,-8(fp)
81147edc:	e0fffe83 	ldbu	r3,-6(fp)
81147ee0:	e13ffec4 	addi	r4,fp,-5
81147ee4:	200f883a 	mov	r7,r4
81147ee8:	180d883a 	mov	r6,r3
81147eec:	100b883a 	mov	r5,r2
81147ef0:	e13ffd17 	ldw	r4,-12(fp)
81147ef4:	113c7540 	call	8113c754 <OSFlagPost>
81147ef8:	d0a08817 	ldw	r2,-32224(gp)
    }
  }

  return alt_ticks_per_second();
}
81147efc:	e037883a 	mov	sp,fp
81147f00:	dfc00117 	ldw	ra,4(sp)
81147f04:	df000017 	ldw	fp,0(sp)
81147f08:	dec00204 	addi	sp,sp,8
81147f0c:	f800283a 	ret

81147f10 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
81147f10:	defffd04 	addi	sp,sp,-12
81147f14:	de00012e 	bgeu	sp,et,81147f1c <altera_avalon_jtag_uart_close+0xc>
81147f18:	003b68fa 	trap	3
81147f1c:	df000215 	stw	fp,8(sp)
81147f20:	df000204 	addi	fp,sp,8
81147f24:	e13ffe15 	stw	r4,-8(fp)
81147f28:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81147f2c:	00000506 	br	81147f44 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81147f30:	e0bfff17 	ldw	r2,-4(fp)
81147f34:	1090000c 	andi	r2,r2,16384
81147f38:	10000226 	beq	r2,zero,81147f44 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81147f3c:	00bffd44 	movi	r2,-11
81147f40:	00000b06 	br	81147f70 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81147f44:	e0bffe17 	ldw	r2,-8(fp)
81147f48:	10c01017 	ldw	r3,64(r2)
81147f4c:	e0bffe17 	ldw	r2,-8(fp)
81147f50:	10800f17 	ldw	r2,60(r2)
81147f54:	18800526 	beq	r3,r2,81147f6c <altera_avalon_jtag_uart_close+0x5c>
81147f58:	e0bffe17 	ldw	r2,-8(fp)
81147f5c:	10c00917 	ldw	r3,36(r2)
81147f60:	e0bffe17 	ldw	r2,-8(fp)
81147f64:	10800117 	ldw	r2,4(r2)
81147f68:	18bff136 	bltu	r3,r2,81147f30 <__reset+0xfb127f30>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81147f6c:	0005883a 	mov	r2,zero
}
81147f70:	e037883a 	mov	sp,fp
81147f74:	df000017 	ldw	fp,0(sp)
81147f78:	dec00104 	addi	sp,sp,4
81147f7c:	f800283a 	ret

81147f80 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81147f80:	defffa04 	addi	sp,sp,-24
81147f84:	de00012e 	bgeu	sp,et,81147f8c <altera_avalon_jtag_uart_ioctl+0xc>
81147f88:	003b68fa 	trap	3
81147f8c:	df000515 	stw	fp,20(sp)
81147f90:	df000504 	addi	fp,sp,20
81147f94:	e13ffd15 	stw	r4,-12(fp)
81147f98:	e17ffe15 	stw	r5,-8(fp)
81147f9c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81147fa0:	00bff9c4 	movi	r2,-25
81147fa4:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81147fa8:	e0bffe17 	ldw	r2,-8(fp)
81147fac:	10da8060 	cmpeqi	r3,r2,27137
81147fb0:	1800031e 	bne	r3,zero,81147fc0 <altera_avalon_jtag_uart_ioctl+0x40>
81147fb4:	109a80a0 	cmpeqi	r2,r2,27138
81147fb8:	1000181e 	bne	r2,zero,8114801c <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
81147fbc:	00002906 	br	81148064 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
81147fc0:	e0bffd17 	ldw	r2,-12(fp)
81147fc4:	10c00117 	ldw	r3,4(r2)
81147fc8:	00a00034 	movhi	r2,32768
81147fcc:	10bfffc4 	addi	r2,r2,-1
81147fd0:	18802126 	beq	r3,r2,81148058 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
81147fd4:	e0bfff17 	ldw	r2,-4(fp)
81147fd8:	10800017 	ldw	r2,0(r2)
81147fdc:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81147fe0:	e0bffc17 	ldw	r2,-16(fp)
81147fe4:	10800090 	cmplti	r2,r2,2
81147fe8:	1000061e 	bne	r2,zero,81148004 <altera_avalon_jtag_uart_ioctl+0x84>
81147fec:	e0fffc17 	ldw	r3,-16(fp)
81147ff0:	00a00034 	movhi	r2,32768
81147ff4:	10bfffc4 	addi	r2,r2,-1
81147ff8:	18800226 	beq	r3,r2,81148004 <altera_avalon_jtag_uart_ioctl+0x84>
81147ffc:	e0bffc17 	ldw	r2,-16(fp)
81148000:	00000206 	br	8114800c <altera_avalon_jtag_uart_ioctl+0x8c>
81148004:	00a00034 	movhi	r2,32768
81148008:	10bfff84 	addi	r2,r2,-2
8114800c:	e0fffd17 	ldw	r3,-12(fp)
81148010:	18800115 	stw	r2,4(r3)
      rc = 0;
81148014:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81148018:	00000f06 	br	81148058 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
8114801c:	e0bffd17 	ldw	r2,-12(fp)
81148020:	10c00117 	ldw	r3,4(r2)
81148024:	00a00034 	movhi	r2,32768
81148028:	10bfffc4 	addi	r2,r2,-1
8114802c:	18800c26 	beq	r3,r2,81148060 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81148030:	e0bffd17 	ldw	r2,-12(fp)
81148034:	10c00917 	ldw	r3,36(r2)
81148038:	e0bffd17 	ldw	r2,-12(fp)
8114803c:	10800117 	ldw	r2,4(r2)
81148040:	1885803a 	cmpltu	r2,r3,r2
81148044:	10c03fcc 	andi	r3,r2,255
81148048:	e0bfff17 	ldw	r2,-4(fp)
8114804c:	10c00015 	stw	r3,0(r2)
      rc = 0;
81148050:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81148054:	00000206 	br	81148060 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
81148058:	0001883a 	nop
8114805c:	00000106 	br	81148064 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
81148060:	0001883a 	nop

  default:
    break;
  }

  return rc;
81148064:	e0bffb17 	ldw	r2,-20(fp)
}
81148068:	e037883a 	mov	sp,fp
8114806c:	df000017 	ldw	fp,0(sp)
81148070:	dec00104 	addi	sp,sp,4
81148074:	f800283a 	ret

81148078 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
81148078:	deffed04 	addi	sp,sp,-76
8114807c:	de00012e 	bgeu	sp,et,81148084 <altera_avalon_jtag_uart_read+0xc>
81148080:	003b68fa 	trap	3
81148084:	dfc01215 	stw	ra,72(sp)
81148088:	df001115 	stw	fp,68(sp)
8114808c:	df001104 	addi	fp,sp,68
81148090:	e13ffc15 	stw	r4,-16(fp)
81148094:	e17ffd15 	stw	r5,-12(fp)
81148098:	e1bffe15 	stw	r6,-8(fp)
8114809c:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
811480a0:	e0bffd17 	ldw	r2,-12(fp)
811480a4:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
811480a8:	e0bffc17 	ldw	r2,-16(fp)
811480ac:	10800a17 	ldw	r2,40(r2)
811480b0:	e0bff815 	stw	r2,-32(fp)
811480b4:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
811480b8:	e0bff90b 	ldhu	r2,-28(fp)
811480bc:	e0fffb04 	addi	r3,fp,-20
811480c0:	180d883a 	mov	r6,r3
811480c4:	100b883a 	mov	r5,r2
811480c8:	e13ff817 	ldw	r4,-32(fp)
811480cc:	113fdcc0 	call	8113fdcc <OSSemPend>

  while (space > 0)
811480d0:	00006106 	br	81148258 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
811480d4:	e0bffc17 	ldw	r2,-16(fp)
811480d8:	10800d17 	ldw	r2,52(r2)
811480dc:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
811480e0:	e0bffc17 	ldw	r2,-16(fp)
811480e4:	10800e17 	ldw	r2,56(r2)
811480e8:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
811480ec:	e0fff317 	ldw	r3,-52(fp)
811480f0:	e0bff417 	ldw	r2,-48(fp)
811480f4:	18800536 	bltu	r3,r2,8114810c <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
811480f8:	e0fff317 	ldw	r3,-52(fp)
811480fc:	e0bff417 	ldw	r2,-48(fp)
81148100:	1885c83a 	sub	r2,r3,r2
81148104:	e0bff115 	stw	r2,-60(fp)
81148108:	00000406 	br	8114811c <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
8114810c:	00c20004 	movi	r3,2048
81148110:	e0bff417 	ldw	r2,-48(fp)
81148114:	1885c83a 	sub	r2,r3,r2
81148118:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
8114811c:	e0bff117 	ldw	r2,-60(fp)
81148120:	10001e26 	beq	r2,zero,8114819c <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81148124:	e0fffe17 	ldw	r3,-8(fp)
81148128:	e0bff117 	ldw	r2,-60(fp)
8114812c:	1880022e 	bgeu	r3,r2,81148138 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81148130:	e0bffe17 	ldw	r2,-8(fp)
81148134:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81148138:	e0bffc17 	ldw	r2,-16(fp)
8114813c:	10c01104 	addi	r3,r2,68
81148140:	e0bff417 	ldw	r2,-48(fp)
81148144:	1885883a 	add	r2,r3,r2
81148148:	e1bff117 	ldw	r6,-60(fp)
8114814c:	100b883a 	mov	r5,r2
81148150:	e13ff017 	ldw	r4,-64(fp)
81148154:	11239dc0 	call	811239dc <memcpy>
      ptr   += n;
81148158:	e0fff017 	ldw	r3,-64(fp)
8114815c:	e0bff117 	ldw	r2,-60(fp)
81148160:	1885883a 	add	r2,r3,r2
81148164:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81148168:	e0fffe17 	ldw	r3,-8(fp)
8114816c:	e0bff117 	ldw	r2,-60(fp)
81148170:	1885c83a 	sub	r2,r3,r2
81148174:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81148178:	e0fff417 	ldw	r3,-48(fp)
8114817c:	e0bff117 	ldw	r2,-60(fp)
81148180:	1885883a 	add	r2,r3,r2
81148184:	10c1ffcc 	andi	r3,r2,2047
81148188:	e0bffc17 	ldw	r2,-16(fp)
8114818c:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81148190:	e0bffe17 	ldw	r2,-8(fp)
81148194:	00bfcf16 	blt	zero,r2,811480d4 <__reset+0xfb1280d4>
81148198:	00000106 	br	811481a0 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
8114819c:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
811481a0:	e0fff017 	ldw	r3,-64(fp)
811481a4:	e0bffd17 	ldw	r2,-12(fp)
811481a8:	18802e1e 	bne	r3,r2,81148264 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
811481ac:	e0bfff17 	ldw	r2,-4(fp)
811481b0:	1090000c 	andi	r2,r2,16384
811481b4:	10002d1e 	bne	r2,zero,8114826c <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
811481b8:	d0a09103 	ldbu	r2,-32188(gp)
811481bc:	10803fcc 	andi	r2,r2,255
811481c0:	10800058 	cmpnei	r2,r2,1
811481c4:	1000161e 	bne	r2,zero,81148220 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
811481c8:	e0bffc17 	ldw	r2,-16(fp)
811481cc:	10800c17 	ldw	r2,48(r2)
811481d0:	e0bff215 	stw	r2,-56(fp)
811481d4:	00800144 	movi	r2,5
811481d8:	e0bff98d 	sth	r2,-26(fp)
811481dc:	00bfe0c4 	movi	r2,-125
811481e0:	e0bffa05 	stb	r2,-24(fp)
811481e4:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
811481e8:	d0a09103 	ldbu	r2,-32188(gp)
811481ec:	10803fcc 	andi	r2,r2,255
811481f0:	10001526 	beq	r2,zero,81148248 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
811481f4:	e0fff98b 	ldhu	r3,-26(fp)
811481f8:	e13ffa03 	ldbu	r4,-24(fp)
811481fc:	e17ffa8b 	ldhu	r5,-22(fp)
81148200:	e0bffb44 	addi	r2,fp,-19
81148204:	d8800015 	stw	r2,0(sp)
81148208:	280f883a 	mov	r7,r5
8114820c:	200d883a 	mov	r6,r4
81148210:	180b883a 	mov	r5,r3
81148214:	e13ff217 	ldw	r4,-56(fp)
81148218:	113c12c0 	call	8113c12c <OSFlagPend>
8114821c:	00000a06 	br	81148248 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81148220:	0001883a 	nop
81148224:	e0bffc17 	ldw	r2,-16(fp)
81148228:	10c00d17 	ldw	r3,52(r2)
8114822c:	e0bff317 	ldw	r2,-52(fp)
81148230:	1880051e 	bne	r3,r2,81148248 <altera_avalon_jtag_uart_read+0x1d0>
81148234:	e0bffc17 	ldw	r2,-16(fp)
81148238:	10c00917 	ldw	r3,36(r2)
8114823c:	e0bffc17 	ldw	r2,-16(fp)
81148240:	10800117 	ldw	r2,4(r2)
81148244:	18bff736 	bltu	r3,r2,81148224 <__reset+0xfb128224>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81148248:	e0bffc17 	ldw	r2,-16(fp)
8114824c:	10c00d17 	ldw	r3,52(r2)
81148250:	e0bff317 	ldw	r2,-52(fp)
81148254:	18800726 	beq	r3,r2,81148274 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81148258:	e0bffe17 	ldw	r2,-8(fp)
8114825c:	00bf9d16 	blt	zero,r2,811480d4 <__reset+0xfb1280d4>
81148260:	00000506 	br	81148278 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81148264:	0001883a 	nop
81148268:	00000306 	br	81148278 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
8114826c:	0001883a 	nop
81148270:	00000106 	br	81148278 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81148274:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81148278:	e0bffc17 	ldw	r2,-16(fp)
8114827c:	10800a17 	ldw	r2,40(r2)
81148280:	1009883a 	mov	r4,r2
81148284:	11401540 	call	81140154 <OSSemPost>

  if (ptr != buffer)
81148288:	e0fff017 	ldw	r3,-64(fp)
8114828c:	e0bffd17 	ldw	r2,-12(fp)
81148290:	18801826 	beq	r3,r2,811482f4 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148294:	0005303a 	rdctl	r2,status
81148298:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114829c:	e0fff717 	ldw	r3,-36(fp)
811482a0:	00bfff84 	movi	r2,-2
811482a4:	1884703a 	and	r2,r3,r2
811482a8:	1001703a 	wrctl	status,r2
  
  return context;
811482ac:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
811482b0:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811482b4:	e0bffc17 	ldw	r2,-16(fp)
811482b8:	10800817 	ldw	r2,32(r2)
811482bc:	10c00054 	ori	r3,r2,1
811482c0:	e0bffc17 	ldw	r2,-16(fp)
811482c4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811482c8:	e0bffc17 	ldw	r2,-16(fp)
811482cc:	10800017 	ldw	r2,0(r2)
811482d0:	10800104 	addi	r2,r2,4
811482d4:	1007883a 	mov	r3,r2
811482d8:	e0bffc17 	ldw	r2,-16(fp)
811482dc:	10800817 	ldw	r2,32(r2)
811482e0:	18800035 	stwio	r2,0(r3)
811482e4:	e0bff617 	ldw	r2,-40(fp)
811482e8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811482ec:	e0bff517 	ldw	r2,-44(fp)
811482f0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
811482f4:	e0fff017 	ldw	r3,-64(fp)
811482f8:	e0bffd17 	ldw	r2,-12(fp)
811482fc:	18800426 	beq	r3,r2,81148310 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
81148300:	e0fff017 	ldw	r3,-64(fp)
81148304:	e0bffd17 	ldw	r2,-12(fp)
81148308:	1885c83a 	sub	r2,r3,r2
8114830c:	00000606 	br	81148328 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
81148310:	e0bfff17 	ldw	r2,-4(fp)
81148314:	1090000c 	andi	r2,r2,16384
81148318:	10000226 	beq	r2,zero,81148324 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
8114831c:	00bffd44 	movi	r2,-11
81148320:	00000106 	br	81148328 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81148324:	00bffec4 	movi	r2,-5
}
81148328:	e037883a 	mov	sp,fp
8114832c:	dfc00117 	ldw	ra,4(sp)
81148330:	df000017 	ldw	fp,0(sp)
81148334:	dec00204 	addi	sp,sp,8
81148338:	f800283a 	ret

8114833c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
8114833c:	deffed04 	addi	sp,sp,-76
81148340:	de00012e 	bgeu	sp,et,81148348 <altera_avalon_jtag_uart_write+0xc>
81148344:	003b68fa 	trap	3
81148348:	dfc01215 	stw	ra,72(sp)
8114834c:	df001115 	stw	fp,68(sp)
81148350:	df001104 	addi	fp,sp,68
81148354:	e13ffc15 	stw	r4,-16(fp)
81148358:	e17ffd15 	stw	r5,-12(fp)
8114835c:	e1bffe15 	stw	r6,-8(fp)
81148360:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
81148364:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
81148368:	e0bffd17 	ldw	r2,-12(fp)
8114836c:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
81148370:	e0bffc17 	ldw	r2,-16(fp)
81148374:	10800b17 	ldw	r2,44(r2)
81148378:	e0bff815 	stw	r2,-32(fp)
8114837c:	e03ff90d 	sth	zero,-28(fp)
81148380:	e0bff90b 	ldhu	r2,-28(fp)
81148384:	e0fffb44 	addi	r3,fp,-19
81148388:	180d883a 	mov	r6,r3
8114838c:	100b883a 	mov	r5,r2
81148390:	e13ff817 	ldw	r4,-32(fp)
81148394:	113fdcc0 	call	8113fdcc <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81148398:	00003706 	br	81148478 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
8114839c:	e0bffc17 	ldw	r2,-16(fp)
811483a0:	10800f17 	ldw	r2,60(r2)
811483a4:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
811483a8:	e0bffc17 	ldw	r2,-16(fp)
811483ac:	10801017 	ldw	r2,64(r2)
811483b0:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
811483b4:	e0fff417 	ldw	r3,-48(fp)
811483b8:	e0bff017 	ldw	r2,-64(fp)
811483bc:	1880062e 	bgeu	r3,r2,811483d8 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
811483c0:	e0fff017 	ldw	r3,-64(fp)
811483c4:	e0bff417 	ldw	r2,-48(fp)
811483c8:	1885c83a 	sub	r2,r3,r2
811483cc:	10bfffc4 	addi	r2,r2,-1
811483d0:	e0bff115 	stw	r2,-60(fp)
811483d4:	00000b06 	br	81148404 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
811483d8:	e0bff017 	ldw	r2,-64(fp)
811483dc:	10000526 	beq	r2,zero,811483f4 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
811483e0:	00c20004 	movi	r3,2048
811483e4:	e0bff417 	ldw	r2,-48(fp)
811483e8:	1885c83a 	sub	r2,r3,r2
811483ec:	e0bff115 	stw	r2,-60(fp)
811483f0:	00000406 	br	81148404 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
811483f4:	00c1ffc4 	movi	r3,2047
811483f8:	e0bff417 	ldw	r2,-48(fp)
811483fc:	1885c83a 	sub	r2,r3,r2
81148400:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81148404:	e0bff117 	ldw	r2,-60(fp)
81148408:	10001e26 	beq	r2,zero,81148484 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
8114840c:	e0fffe17 	ldw	r3,-8(fp)
81148410:	e0bff117 	ldw	r2,-60(fp)
81148414:	1880022e 	bgeu	r3,r2,81148420 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81148418:	e0bffe17 	ldw	r2,-8(fp)
8114841c:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
81148420:	e0bffc17 	ldw	r2,-16(fp)
81148424:	10c21104 	addi	r3,r2,2116
81148428:	e0bff417 	ldw	r2,-48(fp)
8114842c:	1885883a 	add	r2,r3,r2
81148430:	e1bff117 	ldw	r6,-60(fp)
81148434:	e17ffd17 	ldw	r5,-12(fp)
81148438:	1009883a 	mov	r4,r2
8114843c:	11239dc0 	call	811239dc <memcpy>
      ptr   += n;
81148440:	e0fffd17 	ldw	r3,-12(fp)
81148444:	e0bff117 	ldw	r2,-60(fp)
81148448:	1885883a 	add	r2,r3,r2
8114844c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
81148450:	e0fffe17 	ldw	r3,-8(fp)
81148454:	e0bff117 	ldw	r2,-60(fp)
81148458:	1885c83a 	sub	r2,r3,r2
8114845c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81148460:	e0fff417 	ldw	r3,-48(fp)
81148464:	e0bff117 	ldw	r2,-60(fp)
81148468:	1885883a 	add	r2,r3,r2
8114846c:	10c1ffcc 	andi	r3,r2,2047
81148470:	e0bffc17 	ldw	r2,-16(fp)
81148474:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81148478:	e0bffe17 	ldw	r2,-8(fp)
8114847c:	00bfc716 	blt	zero,r2,8114839c <__reset+0xfb12839c>
81148480:	00000106 	br	81148488 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
81148484:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148488:	0005303a 	rdctl	r2,status
8114848c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148490:	e0fff717 	ldw	r3,-36(fp)
81148494:	00bfff84 	movi	r2,-2
81148498:	1884703a 	and	r2,r3,r2
8114849c:	1001703a 	wrctl	status,r2
  
  return context;
811484a0:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
811484a4:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
811484a8:	e0bffc17 	ldw	r2,-16(fp)
811484ac:	10800817 	ldw	r2,32(r2)
811484b0:	10c00094 	ori	r3,r2,2
811484b4:	e0bffc17 	ldw	r2,-16(fp)
811484b8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811484bc:	e0bffc17 	ldw	r2,-16(fp)
811484c0:	10800017 	ldw	r2,0(r2)
811484c4:	10800104 	addi	r2,r2,4
811484c8:	1007883a 	mov	r3,r2
811484cc:	e0bffc17 	ldw	r2,-16(fp)
811484d0:	10800817 	ldw	r2,32(r2)
811484d4:	18800035 	stwio	r2,0(r3)
811484d8:	e0bff617 	ldw	r2,-40(fp)
811484dc:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811484e0:	e0bff317 	ldw	r2,-52(fp)
811484e4:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
811484e8:	e0bffe17 	ldw	r2,-8(fp)
811484ec:	00802a0e 	bge	zero,r2,81148598 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
811484f0:	e0bfff17 	ldw	r2,-4(fp)
811484f4:	1090000c 	andi	r2,r2,16384
811484f8:	10002a1e 	bne	r2,zero,811485a4 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
811484fc:	d0a09103 	ldbu	r2,-32188(gp)
81148500:	10803fcc 	andi	r2,r2,255
81148504:	10800058 	cmpnei	r2,r2,1
81148508:	1000161e 	bne	r2,zero,81148564 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
8114850c:	e0bffc17 	ldw	r2,-16(fp)
81148510:	10800c17 	ldw	r2,48(r2)
81148514:	e0bff515 	stw	r2,-44(fp)
81148518:	00800184 	movi	r2,6
8114851c:	e0bff98d 	sth	r2,-26(fp)
81148520:	00bfe0c4 	movi	r2,-125
81148524:	e0bffa05 	stb	r2,-24(fp)
81148528:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8114852c:	d0a09103 	ldbu	r2,-32188(gp)
81148530:	10803fcc 	andi	r2,r2,255
81148534:	10001526 	beq	r2,zero,8114858c <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81148538:	e0fff98b 	ldhu	r3,-26(fp)
8114853c:	e13ffa03 	ldbu	r4,-24(fp)
81148540:	e17ffa8b 	ldhu	r5,-22(fp)
81148544:	e0bffb04 	addi	r2,fp,-20
81148548:	d8800015 	stw	r2,0(sp)
8114854c:	280f883a 	mov	r7,r5
81148550:	200d883a 	mov	r6,r4
81148554:	180b883a 	mov	r5,r3
81148558:	e13ff517 	ldw	r4,-44(fp)
8114855c:	113c12c0 	call	8113c12c <OSFlagPend>
81148560:	00000a06 	br	8114858c <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
81148564:	0001883a 	nop
81148568:	e0bffc17 	ldw	r2,-16(fp)
8114856c:	10c01017 	ldw	r3,64(r2)
81148570:	e0bff017 	ldw	r2,-64(fp)
81148574:	1880051e 	bne	r3,r2,8114858c <altera_avalon_jtag_uart_write+0x250>
81148578:	e0bffc17 	ldw	r2,-16(fp)
8114857c:	10c00917 	ldw	r3,36(r2)
81148580:	e0bffc17 	ldw	r2,-16(fp)
81148584:	10800117 	ldw	r2,4(r2)
81148588:	18bff736 	bltu	r3,r2,81148568 <__reset+0xfb128568>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
8114858c:	e0bffc17 	ldw	r2,-16(fp)
81148590:	10800917 	ldw	r2,36(r2)
81148594:	1000051e 	bne	r2,zero,811485ac <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
81148598:	e0bffe17 	ldw	r2,-8(fp)
8114859c:	00bfb616 	blt	zero,r2,81148478 <__reset+0xfb128478>
811485a0:	00000306 	br	811485b0 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
811485a4:	0001883a 	nop
811485a8:	00000106 	br	811485b0 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
811485ac:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
811485b0:	e0bffc17 	ldw	r2,-16(fp)
811485b4:	10800b17 	ldw	r2,44(r2)
811485b8:	1009883a 	mov	r4,r2
811485bc:	11401540 	call	81140154 <OSSemPost>

  if (ptr != start)
811485c0:	e0fffd17 	ldw	r3,-12(fp)
811485c4:	e0bff217 	ldw	r2,-56(fp)
811485c8:	18800426 	beq	r3,r2,811485dc <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
811485cc:	e0fffd17 	ldw	r3,-12(fp)
811485d0:	e0bff217 	ldw	r2,-56(fp)
811485d4:	1885c83a 	sub	r2,r3,r2
811485d8:	00000606 	br	811485f4 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
811485dc:	e0bfff17 	ldw	r2,-4(fp)
811485e0:	1090000c 	andi	r2,r2,16384
811485e4:	10000226 	beq	r2,zero,811485f0 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
811485e8:	00bffd44 	movi	r2,-11
811485ec:	00000106 	br	811485f4 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
811485f0:	00bffec4 	movi	r2,-5
}
811485f4:	e037883a 	mov	sp,fp
811485f8:	dfc00117 	ldw	ra,4(sp)
811485fc:	df000017 	ldw	fp,0(sp)
81148600:	dec00204 	addi	sp,sp,8
81148604:	f800283a 	ret

81148608 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81148608:	defffa04 	addi	sp,sp,-24
8114860c:	de00012e 	bgeu	sp,et,81148614 <alt_avalon_timer_sc_irq+0xc>
81148610:	003b68fa 	trap	3
81148614:	dfc00515 	stw	ra,20(sp)
81148618:	df000415 	stw	fp,16(sp)
8114861c:	df000404 	addi	fp,sp,16
81148620:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
81148624:	0007883a 	mov	r3,zero
81148628:	e0bfff17 	ldw	r2,-4(fp)
8114862c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
81148630:	e0bfff17 	ldw	r2,-4(fp)
81148634:	10800104 	addi	r2,r2,4
81148638:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
8114863c:	11386080 	call	81138608 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148640:	0005303a 	rdctl	r2,status
81148644:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148648:	e0fffd17 	ldw	r3,-12(fp)
8114864c:	00bfff84 	movi	r2,-2
81148650:	1884703a 	and	r2,r3,r2
81148654:	1001703a 	wrctl	status,r2
  
  return context;
81148658:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
8114865c:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
81148660:	1138eb80 	call	81138eb8 <alt_tick>
81148664:	e0bffc17 	ldw	r2,-16(fp)
81148668:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114866c:	e0bffe17 	ldw	r2,-8(fp)
81148670:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
81148674:	0001883a 	nop
81148678:	e037883a 	mov	sp,fp
8114867c:	dfc00117 	ldw	ra,4(sp)
81148680:	df000017 	ldw	fp,0(sp)
81148684:	dec00204 	addi	sp,sp,8
81148688:	f800283a 	ret

8114868c <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
8114868c:	defff804 	addi	sp,sp,-32
81148690:	de00012e 	bgeu	sp,et,81148698 <alt_avalon_timer_sc_init+0xc>
81148694:	003b68fa 	trap	3
81148698:	dfc00715 	stw	ra,28(sp)
8114869c:	df000615 	stw	fp,24(sp)
811486a0:	df000604 	addi	fp,sp,24
811486a4:	e13ffc15 	stw	r4,-16(fp)
811486a8:	e17ffd15 	stw	r5,-12(fp)
811486ac:	e1bffe15 	stw	r6,-8(fp)
811486b0:	e1ffff15 	stw	r7,-4(fp)
811486b4:	e0bfff17 	ldw	r2,-4(fp)
811486b8:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
811486bc:	d0a08817 	ldw	r2,-32224(gp)
811486c0:	1000021e 	bne	r2,zero,811486cc <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
811486c4:	e0bffb17 	ldw	r2,-20(fp)
811486c8:	d0a08815 	stw	r2,-32224(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
811486cc:	e0bffc17 	ldw	r2,-16(fp)
811486d0:	10800104 	addi	r2,r2,4
811486d4:	00c001c4 	movi	r3,7
811486d8:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
811486dc:	d8000015 	stw	zero,0(sp)
811486e0:	e1fffc17 	ldw	r7,-16(fp)
811486e4:	01a04574 	movhi	r6,33045
811486e8:	31a18204 	addi	r6,r6,-31224
811486ec:	e17ffe17 	ldw	r5,-8(fp)
811486f0:	e13ffd17 	ldw	r4,-12(fp)
811486f4:	114b8900 	call	8114b890 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
811486f8:	0001883a 	nop
811486fc:	e037883a 	mov	sp,fp
81148700:	dfc00117 	ldw	ra,4(sp)
81148704:	df000017 	ldw	fp,0(sp)
81148708:	dec00204 	addi	sp,sp,8
8114870c:	f800283a 	ret

81148710 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81148710:	defffa04 	addi	sp,sp,-24
81148714:	de00012e 	bgeu	sp,et,8114871c <altera_avalon_uart_read_fd+0xc>
81148718:	003b68fa 	trap	3
8114871c:	dfc00515 	stw	ra,20(sp)
81148720:	df000415 	stw	fp,16(sp)
81148724:	df000404 	addi	fp,sp,16
81148728:	e13ffd15 	stw	r4,-12(fp)
8114872c:	e17ffe15 	stw	r5,-8(fp)
81148730:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81148734:	e0bffd17 	ldw	r2,-12(fp)
81148738:	10800017 	ldw	r2,0(r2)
8114873c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
81148740:	e0bffc17 	ldw	r2,-16(fp)
81148744:	10c00a04 	addi	r3,r2,40
81148748:	e0bffd17 	ldw	r2,-12(fp)
8114874c:	10800217 	ldw	r2,8(r2)
81148750:	100f883a 	mov	r7,r2
81148754:	e1bfff17 	ldw	r6,-4(fp)
81148758:	e17ffe17 	ldw	r5,-8(fp)
8114875c:	1809883a 	mov	r4,r3
81148760:	1148dd00 	call	81148dd0 <altera_avalon_uart_read>
      fd->fd_flags);
}
81148764:	e037883a 	mov	sp,fp
81148768:	dfc00117 	ldw	ra,4(sp)
8114876c:	df000017 	ldw	fp,0(sp)
81148770:	dec00204 	addi	sp,sp,8
81148774:	f800283a 	ret

81148778 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81148778:	defffa04 	addi	sp,sp,-24
8114877c:	de00012e 	bgeu	sp,et,81148784 <altera_avalon_uart_write_fd+0xc>
81148780:	003b68fa 	trap	3
81148784:	dfc00515 	stw	ra,20(sp)
81148788:	df000415 	stw	fp,16(sp)
8114878c:	df000404 	addi	fp,sp,16
81148790:	e13ffd15 	stw	r4,-12(fp)
81148794:	e17ffe15 	stw	r5,-8(fp)
81148798:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8114879c:	e0bffd17 	ldw	r2,-12(fp)
811487a0:	10800017 	ldw	r2,0(r2)
811487a4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
811487a8:	e0bffc17 	ldw	r2,-16(fp)
811487ac:	10c00a04 	addi	r3,r2,40
811487b0:	e0bffd17 	ldw	r2,-12(fp)
811487b4:	10800217 	ldw	r2,8(r2)
811487b8:	100f883a 	mov	r7,r2
811487bc:	e1bfff17 	ldw	r6,-4(fp)
811487c0:	e17ffe17 	ldw	r5,-8(fp)
811487c4:	1809883a 	mov	r4,r3
811487c8:	11490840 	call	81149084 <altera_avalon_uart_write>
      fd->fd_flags);
}
811487cc:	e037883a 	mov	sp,fp
811487d0:	dfc00117 	ldw	ra,4(sp)
811487d4:	df000017 	ldw	fp,0(sp)
811487d8:	dec00204 	addi	sp,sp,8
811487dc:	f800283a 	ret

811487e0 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
811487e0:	defffc04 	addi	sp,sp,-16
811487e4:	de00012e 	bgeu	sp,et,811487ec <altera_avalon_uart_close_fd+0xc>
811487e8:	003b68fa 	trap	3
811487ec:	dfc00315 	stw	ra,12(sp)
811487f0:	df000215 	stw	fp,8(sp)
811487f4:	df000204 	addi	fp,sp,8
811487f8:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811487fc:	e0bfff17 	ldw	r2,-4(fp)
81148800:	10800017 	ldw	r2,0(r2)
81148804:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81148808:	e0bffe17 	ldw	r2,-8(fp)
8114880c:	10c00a04 	addi	r3,r2,40
81148810:	e0bfff17 	ldw	r2,-4(fp)
81148814:	10800217 	ldw	r2,8(r2)
81148818:	100b883a 	mov	r5,r2
8114881c:	1809883a 	mov	r4,r3
81148820:	1148d300 	call	81148d30 <altera_avalon_uart_close>
}
81148824:	e037883a 	mov	sp,fp
81148828:	dfc00117 	ldw	ra,4(sp)
8114882c:	df000017 	ldw	fp,0(sp)
81148830:	dec00204 	addi	sp,sp,8
81148834:	f800283a 	ret

81148838 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
81148838:	defff304 	addi	sp,sp,-52
8114883c:	de00012e 	bgeu	sp,et,81148844 <altera_avalon_uart_init+0xc>
81148840:	003b68fa 	trap	3
81148844:	dfc00c15 	stw	ra,48(sp)
81148848:	df000b15 	stw	fp,44(sp)
8114884c:	df000b04 	addi	fp,sp,44
81148850:	e13ffd15 	stw	r4,-12(fp)
81148854:	e17ffe15 	stw	r5,-8(fp)
81148858:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
8114885c:	e0bffd17 	ldw	r2,-12(fp)
81148860:	10800017 	ldw	r2,0(r2)
81148864:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81148868:	e0bffd17 	ldw	r2,-12(fp)
8114886c:	10800704 	addi	r2,r2,28
81148870:	e0bffa15 	stw	r2,-24(fp)
81148874:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81148878:	e0bffb0b 	ldhu	r2,-20(fp)
8114887c:	e0fffc84 	addi	r3,fp,-14
81148880:	180b883a 	mov	r5,r3
81148884:	1009883a 	mov	r4,r2
81148888:	113bb480 	call	8113bb48 <OSFlagCreate>
8114888c:	1007883a 	mov	r3,r2
81148890:	e0bffa17 	ldw	r2,-24(fp)
81148894:	10c00015 	stw	r3,0(r2)
  return err;
81148898:	e0bffc83 	ldbu	r2,-14(fp)
8114889c:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
811488a0:	1000241e 	bne	r2,zero,81148934 <altera_avalon_uart_init+0xfc>
811488a4:	e0bffd17 	ldw	r2,-12(fp)
811488a8:	10800804 	addi	r2,r2,32
811488ac:	e0bff715 	stw	r2,-36(fp)
811488b0:	00800044 	movi	r2,1
811488b4:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811488b8:	e0bffb8b 	ldhu	r2,-18(fp)
811488bc:	1009883a 	mov	r4,r2
811488c0:	113faa40 	call	8113faa4 <OSSemCreate>
811488c4:	1007883a 	mov	r3,r2
811488c8:	e0bff717 	ldw	r2,-36(fp)
811488cc:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
811488d0:	e0bff717 	ldw	r2,-36(fp)
811488d4:	10800017 	ldw	r2,0(r2)
811488d8:	10000226 	beq	r2,zero,811488e4 <altera_avalon_uart_init+0xac>
811488dc:	0005883a 	mov	r2,zero
811488e0:	00000106 	br	811488e8 <altera_avalon_uart_init+0xb0>
811488e4:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811488e8:	1000121e 	bne	r2,zero,81148934 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
811488ec:	e0bffd17 	ldw	r2,-12(fp)
811488f0:	10800904 	addi	r2,r2,36
811488f4:	e0bff815 	stw	r2,-32(fp)
811488f8:	00800044 	movi	r2,1
811488fc:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81148900:	e0bffc0b 	ldhu	r2,-16(fp)
81148904:	1009883a 	mov	r4,r2
81148908:	113faa40 	call	8113faa4 <OSSemCreate>
8114890c:	1007883a 	mov	r3,r2
81148910:	e0bff817 	ldw	r2,-32(fp)
81148914:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81148918:	e0bff817 	ldw	r2,-32(fp)
8114891c:	10800017 	ldw	r2,0(r2)
81148920:	10000226 	beq	r2,zero,8114892c <altera_avalon_uart_init+0xf4>
81148924:	0005883a 	mov	r2,zero
81148928:	00000106 	br	81148930 <altera_avalon_uart_init+0xf8>
8114892c:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81148930:	10000226 	beq	r2,zero,8114893c <altera_avalon_uart_init+0x104>
81148934:	00800044 	movi	r2,1
81148938:	00000106 	br	81148940 <altera_avalon_uart_init+0x108>
8114893c:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81148940:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
81148944:	e0bff917 	ldw	r2,-28(fp)
81148948:	10000f1e 	bne	r2,zero,81148988 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
8114894c:	e0bffd17 	ldw	r2,-12(fp)
81148950:	00c32004 	movi	r3,3200
81148954:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
81148958:	e0bff617 	ldw	r2,-40(fp)
8114895c:	10800304 	addi	r2,r2,12
81148960:	e0fffd17 	ldw	r3,-12(fp)
81148964:	18c00117 	ldw	r3,4(r3)
81148968:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
8114896c:	d8000015 	stw	zero,0(sp)
81148970:	e1fffd17 	ldw	r7,-12(fp)
81148974:	01a04574 	movhi	r6,33045
81148978:	31a26804 	addi	r6,r6,-30304
8114897c:	e17fff17 	ldw	r5,-4(fp)
81148980:	e13ffe17 	ldw	r4,-8(fp)
81148984:	114b8900 	call	8114b890 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
81148988:	0001883a 	nop
8114898c:	e037883a 	mov	sp,fp
81148990:	dfc00117 	ldw	ra,4(sp)
81148994:	df000017 	ldw	fp,0(sp)
81148998:	dec00204 	addi	sp,sp,8
8114899c:	f800283a 	ret

811489a0 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
811489a0:	defffa04 	addi	sp,sp,-24
811489a4:	de00012e 	bgeu	sp,et,811489ac <altera_avalon_uart_irq+0xc>
811489a8:	003b68fa 	trap	3
811489ac:	dfc00515 	stw	ra,20(sp)
811489b0:	df000415 	stw	fp,16(sp)
811489b4:	df000404 	addi	fp,sp,16
811489b8:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
811489bc:	e0bfff17 	ldw	r2,-4(fp)
811489c0:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
811489c4:	e0bffc17 	ldw	r2,-16(fp)
811489c8:	10800017 	ldw	r2,0(r2)
811489cc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
811489d0:	e0bffd17 	ldw	r2,-12(fp)
811489d4:	10800204 	addi	r2,r2,8
811489d8:	10800037 	ldwio	r2,0(r2)
811489dc:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
811489e0:	e0bffd17 	ldw	r2,-12(fp)
811489e4:	10800204 	addi	r2,r2,8
811489e8:	0007883a 	mov	r3,zero
811489ec:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
811489f0:	e0bffd17 	ldw	r2,-12(fp)
811489f4:	10800204 	addi	r2,r2,8
811489f8:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
811489fc:	e0bffe17 	ldw	r2,-8(fp)
81148a00:	1080200c 	andi	r2,r2,128
81148a04:	10000326 	beq	r2,zero,81148a14 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
81148a08:	e17ffe17 	ldw	r5,-8(fp)
81148a0c:	e13ffc17 	ldw	r4,-16(fp)
81148a10:	1148a440 	call	81148a44 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
81148a14:	e0bffe17 	ldw	r2,-8(fp)
81148a18:	1081100c 	andi	r2,r2,1088
81148a1c:	10000326 	beq	r2,zero,81148a2c <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
81148a20:	e17ffe17 	ldw	r5,-8(fp)
81148a24:	e13ffc17 	ldw	r4,-16(fp)
81148a28:	1148b840 	call	81148b84 <altera_avalon_uart_txirq>
  }
  

}
81148a2c:	0001883a 	nop
81148a30:	e037883a 	mov	sp,fp
81148a34:	dfc00117 	ldw	ra,4(sp)
81148a38:	df000017 	ldw	fp,0(sp)
81148a3c:	dec00204 	addi	sp,sp,8
81148a40:	f800283a 	ret

81148a44 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81148a44:	defff904 	addi	sp,sp,-28
81148a48:	de00012e 	bgeu	sp,et,81148a50 <altera_avalon_uart_rxirq+0xc>
81148a4c:	003b68fa 	trap	3
81148a50:	dfc00615 	stw	ra,24(sp)
81148a54:	df000515 	stw	fp,20(sp)
81148a58:	df000504 	addi	fp,sp,20
81148a5c:	e13ffe15 	stw	r4,-8(fp)
81148a60:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
81148a64:	e0bfff17 	ldw	r2,-4(fp)
81148a68:	108000cc 	andi	r2,r2,3
81148a6c:	10003f1e 	bne	r2,zero,81148b6c <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
81148a70:	e0bffe17 	ldw	r2,-8(fp)
81148a74:	10c00317 	ldw	r3,12(r2)
81148a78:	e0bffe17 	ldw	r2,-8(fp)
81148a7c:	10800217 	ldw	r2,8(r2)
81148a80:	1880121e 	bne	r3,r2,81148acc <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
81148a84:	e0bffe17 	ldw	r2,-8(fp)
81148a88:	10800717 	ldw	r2,28(r2)
81148a8c:	e0bffc15 	stw	r2,-16(fp)
81148a90:	00800044 	movi	r2,1
81148a94:	e0bffd0d 	sth	r2,-12(fp)
81148a98:	00800044 	movi	r2,1
81148a9c:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81148aa0:	d0a09103 	ldbu	r2,-32188(gp)
81148aa4:	10803fcc 	andi	r2,r2,255
81148aa8:	10000826 	beq	r2,zero,81148acc <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
81148aac:	e0bffd0b 	ldhu	r2,-12(fp)
81148ab0:	e0fffd83 	ldbu	r3,-10(fp)
81148ab4:	e13ffdc4 	addi	r4,fp,-9
81148ab8:	200f883a 	mov	r7,r4
81148abc:	180d883a 	mov	r6,r3
81148ac0:	100b883a 	mov	r5,r2
81148ac4:	e13ffc17 	ldw	r4,-16(fp)
81148ac8:	113c7540 	call	8113c754 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81148acc:	e0bffe17 	ldw	r2,-8(fp)
81148ad0:	10800317 	ldw	r2,12(r2)
81148ad4:	10800044 	addi	r2,r2,1
81148ad8:	10800fcc 	andi	r2,r2,63
81148adc:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
81148ae0:	e0bffe17 	ldw	r2,-8(fp)
81148ae4:	10800317 	ldw	r2,12(r2)
81148ae8:	e0fffe17 	ldw	r3,-8(fp)
81148aec:	18c00017 	ldw	r3,0(r3)
81148af0:	18c00037 	ldwio	r3,0(r3)
81148af4:	1809883a 	mov	r4,r3
81148af8:	e0fffe17 	ldw	r3,-8(fp)
81148afc:	1885883a 	add	r2,r3,r2
81148b00:	10800a04 	addi	r2,r2,40
81148b04:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
81148b08:	e0bffe17 	ldw	r2,-8(fp)
81148b0c:	e0fffb17 	ldw	r3,-20(fp)
81148b10:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81148b14:	e0bffe17 	ldw	r2,-8(fp)
81148b18:	10800317 	ldw	r2,12(r2)
81148b1c:	10800044 	addi	r2,r2,1
81148b20:	10800fcc 	andi	r2,r2,63
81148b24:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
81148b28:	e0bffe17 	ldw	r2,-8(fp)
81148b2c:	10c00217 	ldw	r3,8(r2)
81148b30:	e0bffb17 	ldw	r2,-20(fp)
81148b34:	18800e1e 	bne	r3,r2,81148b70 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81148b38:	e0bffe17 	ldw	r2,-8(fp)
81148b3c:	10c00117 	ldw	r3,4(r2)
81148b40:	00bfdfc4 	movi	r2,-129
81148b44:	1886703a 	and	r3,r3,r2
81148b48:	e0bffe17 	ldw	r2,-8(fp)
81148b4c:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
81148b50:	e0bffe17 	ldw	r2,-8(fp)
81148b54:	10800017 	ldw	r2,0(r2)
81148b58:	10800304 	addi	r2,r2,12
81148b5c:	e0fffe17 	ldw	r3,-8(fp)
81148b60:	18c00117 	ldw	r3,4(r3)
81148b64:	10c00035 	stwio	r3,0(r2)
81148b68:	00000106 	br	81148b70 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
81148b6c:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
81148b70:	e037883a 	mov	sp,fp
81148b74:	dfc00117 	ldw	ra,4(sp)
81148b78:	df000017 	ldw	fp,0(sp)
81148b7c:	dec00204 	addi	sp,sp,8
81148b80:	f800283a 	ret

81148b84 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81148b84:	defffa04 	addi	sp,sp,-24
81148b88:	de00012e 	bgeu	sp,et,81148b90 <altera_avalon_uart_txirq+0xc>
81148b8c:	003b68fa 	trap	3
81148b90:	dfc00515 	stw	ra,20(sp)
81148b94:	df000415 	stw	fp,16(sp)
81148b98:	df000404 	addi	fp,sp,16
81148b9c:	e13ffe15 	stw	r4,-8(fp)
81148ba0:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
81148ba4:	e0bffe17 	ldw	r2,-8(fp)
81148ba8:	10c00417 	ldw	r3,16(r2)
81148bac:	e0bffe17 	ldw	r2,-8(fp)
81148bb0:	10800517 	ldw	r2,20(r2)
81148bb4:	18804726 	beq	r3,r2,81148cd4 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81148bb8:	e0bffe17 	ldw	r2,-8(fp)
81148bbc:	10800617 	ldw	r2,24(r2)
81148bc0:	1080008c 	andi	r2,r2,2
81148bc4:	10000326 	beq	r2,zero,81148bd4 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81148bc8:	e0bfff17 	ldw	r2,-4(fp)
81148bcc:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81148bd0:	10003226 	beq	r2,zero,81148c9c <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
81148bd4:	e0bffe17 	ldw	r2,-8(fp)
81148bd8:	10c00417 	ldw	r3,16(r2)
81148bdc:	e0bffe17 	ldw	r2,-8(fp)
81148be0:	10800517 	ldw	r2,20(r2)
81148be4:	10800044 	addi	r2,r2,1
81148be8:	10800fcc 	andi	r2,r2,63
81148bec:	1880121e 	bne	r3,r2,81148c38 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
81148bf0:	e0bffe17 	ldw	r2,-8(fp)
81148bf4:	10800717 	ldw	r2,28(r2)
81148bf8:	e0bffc15 	stw	r2,-16(fp)
81148bfc:	00800084 	movi	r2,2
81148c00:	e0bffd0d 	sth	r2,-12(fp)
81148c04:	00800044 	movi	r2,1
81148c08:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81148c0c:	d0a09103 	ldbu	r2,-32188(gp)
81148c10:	10803fcc 	andi	r2,r2,255
81148c14:	10000826 	beq	r2,zero,81148c38 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
81148c18:	e0bffd0b 	ldhu	r2,-12(fp)
81148c1c:	e0fffd83 	ldbu	r3,-10(fp)
81148c20:	e13ffdc4 	addi	r4,fp,-9
81148c24:	200f883a 	mov	r7,r4
81148c28:	180d883a 	mov	r6,r3
81148c2c:	100b883a 	mov	r5,r2
81148c30:	e13ffc17 	ldw	r4,-16(fp)
81148c34:	113c7540 	call	8113c754 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
81148c38:	e0bffe17 	ldw	r2,-8(fp)
81148c3c:	10800017 	ldw	r2,0(r2)
81148c40:	10800104 	addi	r2,r2,4
81148c44:	e0fffe17 	ldw	r3,-8(fp)
81148c48:	18c00417 	ldw	r3,16(r3)
81148c4c:	e13ffe17 	ldw	r4,-8(fp)
81148c50:	20c7883a 	add	r3,r4,r3
81148c54:	18c01a04 	addi	r3,r3,104
81148c58:	18c00003 	ldbu	r3,0(r3)
81148c5c:	18c03fcc 	andi	r3,r3,255
81148c60:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
81148c64:	e0bffe17 	ldw	r2,-8(fp)
81148c68:	10800417 	ldw	r2,16(r2)
81148c6c:	10800044 	addi	r2,r2,1
81148c70:	e0fffe17 	ldw	r3,-8(fp)
81148c74:	18800415 	stw	r2,16(r3)
81148c78:	10c00fcc 	andi	r3,r2,63
81148c7c:	e0bffe17 	ldw	r2,-8(fp)
81148c80:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81148c84:	e0bffe17 	ldw	r2,-8(fp)
81148c88:	10800117 	ldw	r2,4(r2)
81148c8c:	10c01014 	ori	r3,r2,64
81148c90:	e0bffe17 	ldw	r2,-8(fp)
81148c94:	10c00115 	stw	r3,4(r2)
81148c98:	00000e06 	br	81148cd4 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
81148c9c:	e0bffe17 	ldw	r2,-8(fp)
81148ca0:	10800017 	ldw	r2,0(r2)
81148ca4:	10800204 	addi	r2,r2,8
81148ca8:	10800037 	ldwio	r2,0(r2)
81148cac:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81148cb0:	e0bfff17 	ldw	r2,-4(fp)
81148cb4:	1082000c 	andi	r2,r2,2048
81148cb8:	1000061e 	bne	r2,zero,81148cd4 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81148cbc:	e0bffe17 	ldw	r2,-8(fp)
81148cc0:	10c00117 	ldw	r3,4(r2)
81148cc4:	00bfefc4 	movi	r2,-65
81148cc8:	1886703a 	and	r3,r3,r2
81148ccc:	e0bffe17 	ldw	r2,-8(fp)
81148cd0:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
81148cd4:	e0bffe17 	ldw	r2,-8(fp)
81148cd8:	10c00417 	ldw	r3,16(r2)
81148cdc:	e0bffe17 	ldw	r2,-8(fp)
81148ce0:	10800517 	ldw	r2,20(r2)
81148ce4:	1880061e 	bne	r3,r2,81148d00 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81148ce8:	e0bffe17 	ldw	r2,-8(fp)
81148cec:	10c00117 	ldw	r3,4(r2)
81148cf0:	00beefc4 	movi	r2,-1089
81148cf4:	1886703a 	and	r3,r3,r2
81148cf8:	e0bffe17 	ldw	r2,-8(fp)
81148cfc:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81148d00:	e0bffe17 	ldw	r2,-8(fp)
81148d04:	10800017 	ldw	r2,0(r2)
81148d08:	10800304 	addi	r2,r2,12
81148d0c:	e0fffe17 	ldw	r3,-8(fp)
81148d10:	18c00117 	ldw	r3,4(r3)
81148d14:	10c00035 	stwio	r3,0(r2)
}
81148d18:	0001883a 	nop
81148d1c:	e037883a 	mov	sp,fp
81148d20:	dfc00117 	ldw	ra,4(sp)
81148d24:	df000017 	ldw	fp,0(sp)
81148d28:	dec00204 	addi	sp,sp,8
81148d2c:	f800283a 	ret

81148d30 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
81148d30:	defffd04 	addi	sp,sp,-12
81148d34:	de00012e 	bgeu	sp,et,81148d3c <altera_avalon_uart_close+0xc>
81148d38:	003b68fa 	trap	3
81148d3c:	df000215 	stw	fp,8(sp)
81148d40:	df000204 	addi	fp,sp,8
81148d44:	e13ffe15 	stw	r4,-8(fp)
81148d48:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81148d4c:	00000506 	br	81148d64 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81148d50:	e0bfff17 	ldw	r2,-4(fp)
81148d54:	1090000c 	andi	r2,r2,16384
81148d58:	10000226 	beq	r2,zero,81148d64 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81148d5c:	00bffd44 	movi	r2,-11
81148d60:	00000606 	br	81148d7c <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81148d64:	e0bffe17 	ldw	r2,-8(fp)
81148d68:	10c00417 	ldw	r3,16(r2)
81148d6c:	e0bffe17 	ldw	r2,-8(fp)
81148d70:	10800517 	ldw	r2,20(r2)
81148d74:	18bff61e 	bne	r3,r2,81148d50 <__reset+0xfb128d50>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81148d78:	0005883a 	mov	r2,zero
}
81148d7c:	e037883a 	mov	sp,fp
81148d80:	df000017 	ldw	fp,0(sp)
81148d84:	dec00104 	addi	sp,sp,4
81148d88:	f800283a 	ret

81148d8c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81148d8c:	defffe04 	addi	sp,sp,-8
81148d90:	de00012e 	bgeu	sp,et,81148d98 <alt_get_errno+0xc>
81148d94:	003b68fa 	trap	3
81148d98:	dfc00115 	stw	ra,4(sp)
81148d9c:	df000015 	stw	fp,0(sp)
81148da0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81148da4:	d0a01017 	ldw	r2,-32704(gp)
81148da8:	10000326 	beq	r2,zero,81148db8 <alt_get_errno+0x2c>
81148dac:	d0a01017 	ldw	r2,-32704(gp)
81148db0:	103ee83a 	callr	r2
81148db4:	00000106 	br	81148dbc <alt_get_errno+0x30>
81148db8:	d0a07804 	addi	r2,gp,-32288
}
81148dbc:	e037883a 	mov	sp,fp
81148dc0:	dfc00117 	ldw	ra,4(sp)
81148dc4:	df000017 	ldw	fp,0(sp)
81148dc8:	dec00204 	addi	sp,sp,8
81148dcc:	f800283a 	ret

81148dd0 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
81148dd0:	deffec04 	addi	sp,sp,-80
81148dd4:	de00012e 	bgeu	sp,et,81148ddc <altera_avalon_uart_read+0xc>
81148dd8:	003b68fa 	trap	3
81148ddc:	dfc01315 	stw	ra,76(sp)
81148de0:	df001215 	stw	fp,72(sp)
81148de4:	df001204 	addi	fp,sp,72
81148de8:	e13ffc15 	stw	r4,-16(fp)
81148dec:	e17ffd15 	stw	r5,-12(fp)
81148df0:	e1bffe15 	stw	r6,-8(fp)
81148df4:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
81148df8:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
81148dfc:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
81148e00:	e0bfff17 	ldw	r2,-4(fp)
81148e04:	1090000c 	andi	r2,r2,16384
81148e08:	1005003a 	cmpeq	r2,r2,zero
81148e0c:	10803fcc 	andi	r2,r2,255
81148e10:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81148e14:	e0bffc17 	ldw	r2,-16(fp)
81148e18:	10800817 	ldw	r2,32(r2)
81148e1c:	e0bff815 	stw	r2,-32(fp)
81148e20:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81148e24:	e0bff90b 	ldhu	r2,-28(fp)
81148e28:	e0fffb44 	addi	r3,fp,-19
81148e2c:	180d883a 	mov	r6,r3
81148e30:	100b883a 	mov	r5,r2
81148e34:	e13ff817 	ldw	r4,-32(fp)
81148e38:	113fdcc0 	call	8113fdcc <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81148e3c:	00001306 	br	81148e8c <altera_avalon_uart_read+0xbc>
    {
      count++;
81148e40:	e0bff017 	ldw	r2,-64(fp)
81148e44:	10800044 	addi	r2,r2,1
81148e48:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81148e4c:	e0bffd17 	ldw	r2,-12(fp)
81148e50:	10c00044 	addi	r3,r2,1
81148e54:	e0fffd15 	stw	r3,-12(fp)
81148e58:	e0fffc17 	ldw	r3,-16(fp)
81148e5c:	18c00217 	ldw	r3,8(r3)
81148e60:	e13ffc17 	ldw	r4,-16(fp)
81148e64:	20c7883a 	add	r3,r4,r3
81148e68:	18c00a04 	addi	r3,r3,40
81148e6c:	18c00003 	ldbu	r3,0(r3)
81148e70:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81148e74:	e0bffc17 	ldw	r2,-16(fp)
81148e78:	10800217 	ldw	r2,8(r2)
81148e7c:	10800044 	addi	r2,r2,1
81148e80:	10c00fcc 	andi	r3,r2,63
81148e84:	e0bffc17 	ldw	r2,-16(fp)
81148e88:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81148e8c:	e0fff017 	ldw	r3,-64(fp)
81148e90:	e0bffe17 	ldw	r2,-8(fp)
81148e94:	1880050e 	bge	r3,r2,81148eac <altera_avalon_uart_read+0xdc>
81148e98:	e0bffc17 	ldw	r2,-16(fp)
81148e9c:	10c00217 	ldw	r3,8(r2)
81148ea0:	e0bffc17 	ldw	r2,-16(fp)
81148ea4:	10800317 	ldw	r2,12(r2)
81148ea8:	18bfe51e 	bne	r3,r2,81148e40 <__reset+0xfb128e40>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
81148eac:	e0bff017 	ldw	r2,-64(fp)
81148eb0:	10003a1e 	bne	r2,zero,81148f9c <altera_avalon_uart_read+0x1cc>
81148eb4:	e0bffc17 	ldw	r2,-16(fp)
81148eb8:	10c00217 	ldw	r3,8(r2)
81148ebc:	e0bffc17 	ldw	r2,-16(fp)
81148ec0:	10800317 	ldw	r2,12(r2)
81148ec4:	1880351e 	bne	r3,r2,81148f9c <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81148ec8:	e0bff117 	ldw	r2,-60(fp)
81148ecc:	1000071e 	bne	r2,zero,81148eec <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
81148ed0:	1148d8c0 	call	81148d8c <alt_get_errno>
81148ed4:	1007883a 	mov	r3,r2
81148ed8:	008002c4 	movi	r2,11
81148edc:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
81148ee0:	00800044 	movi	r2,1
81148ee4:	e0bfef05 	stb	r2,-68(fp)
        break;
81148ee8:	00003006 	br	81148fac <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148eec:	0005303a 	rdctl	r2,status
81148ef0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148ef4:	e0fff517 	ldw	r3,-44(fp)
81148ef8:	00bfff84 	movi	r2,-2
81148efc:	1884703a 	and	r2,r3,r2
81148f00:	1001703a 	wrctl	status,r2
  
  return context;
81148f04:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
81148f08:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81148f0c:	e0bffc17 	ldw	r2,-16(fp)
81148f10:	10800117 	ldw	r2,4(r2)
81148f14:	10c02014 	ori	r3,r2,128
81148f18:	e0bffc17 	ldw	r2,-16(fp)
81148f1c:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81148f20:	e0bffc17 	ldw	r2,-16(fp)
81148f24:	10800017 	ldw	r2,0(r2)
81148f28:	10800304 	addi	r2,r2,12
81148f2c:	e0fffc17 	ldw	r3,-16(fp)
81148f30:	18c00117 	ldw	r3,4(r3)
81148f34:	10c00035 	stwio	r3,0(r2)
81148f38:	e0bff417 	ldw	r2,-48(fp)
81148f3c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148f40:	e0bff617 	ldw	r2,-40(fp)
81148f44:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
81148f48:	e0bffc17 	ldw	r2,-16(fp)
81148f4c:	10800717 	ldw	r2,28(r2)
81148f50:	e0bff215 	stw	r2,-56(fp)
81148f54:	00800044 	movi	r2,1
81148f58:	e0bff98d 	sth	r2,-26(fp)
81148f5c:	00bfe0c4 	movi	r2,-125
81148f60:	e0bffa05 	stb	r2,-24(fp)
81148f64:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81148f68:	d0a09103 	ldbu	r2,-32188(gp)
81148f6c:	10803fcc 	andi	r2,r2,255
81148f70:	10000a26 	beq	r2,zero,81148f9c <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81148f74:	e0fff98b 	ldhu	r3,-26(fp)
81148f78:	e13ffa03 	ldbu	r4,-24(fp)
81148f7c:	e17ffa8b 	ldhu	r5,-22(fp)
81148f80:	e0bffb04 	addi	r2,fp,-20
81148f84:	d8800015 	stw	r2,0(sp)
81148f88:	280f883a 	mov	r7,r5
81148f8c:	200d883a 	mov	r6,r4
81148f90:	180b883a 	mov	r5,r3
81148f94:	e13ff217 	ldw	r4,-56(fp)
81148f98:	113c12c0 	call	8113c12c <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81148f9c:	e0bff017 	ldw	r2,-64(fp)
81148fa0:	1000021e 	bne	r2,zero,81148fac <altera_avalon_uart_read+0x1dc>
81148fa4:	e0bffe17 	ldw	r2,-8(fp)
81148fa8:	103fb81e 	bne	r2,zero,81148e8c <__reset+0xfb128e8c>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81148fac:	e0bffc17 	ldw	r2,-16(fp)
81148fb0:	10800817 	ldw	r2,32(r2)
81148fb4:	1009883a 	mov	r4,r2
81148fb8:	11401540 	call	81140154 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148fbc:	0005303a 	rdctl	r2,status
81148fc0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148fc4:	e0fff717 	ldw	r3,-36(fp)
81148fc8:	00bfff84 	movi	r2,-2
81148fcc:	1884703a 	and	r2,r3,r2
81148fd0:	1001703a 	wrctl	status,r2
  
  return context;
81148fd4:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81148fd8:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81148fdc:	e0bffc17 	ldw	r2,-16(fp)
81148fe0:	10800117 	ldw	r2,4(r2)
81148fe4:	10c02014 	ori	r3,r2,128
81148fe8:	e0bffc17 	ldw	r2,-16(fp)
81148fec:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81148ff0:	e0bffc17 	ldw	r2,-16(fp)
81148ff4:	10800017 	ldw	r2,0(r2)
81148ff8:	10800304 	addi	r2,r2,12
81148ffc:	e0fffc17 	ldw	r3,-16(fp)
81149000:	18c00117 	ldw	r3,4(r3)
81149004:	10c00035 	stwio	r3,0(r2)
81149008:	e0bff417 	ldw	r2,-48(fp)
8114900c:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149010:	e0bff317 	ldw	r2,-52(fp)
81149014:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81149018:	e0bfef03 	ldbu	r2,-68(fp)
8114901c:	10000226 	beq	r2,zero,81149028 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81149020:	00bffd44 	movi	r2,-11
81149024:	00000106 	br	8114902c <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81149028:	e0bff017 	ldw	r2,-64(fp)
  }
}
8114902c:	e037883a 	mov	sp,fp
81149030:	dfc00117 	ldw	ra,4(sp)
81149034:	df000017 	ldw	fp,0(sp)
81149038:	dec00204 	addi	sp,sp,8
8114903c:	f800283a 	ret

81149040 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81149040:	defffe04 	addi	sp,sp,-8
81149044:	de00012e 	bgeu	sp,et,8114904c <alt_get_errno+0xc>
81149048:	003b68fa 	trap	3
8114904c:	dfc00115 	stw	ra,4(sp)
81149050:	df000015 	stw	fp,0(sp)
81149054:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81149058:	d0a01017 	ldw	r2,-32704(gp)
8114905c:	10000326 	beq	r2,zero,8114906c <alt_get_errno+0x2c>
81149060:	d0a01017 	ldw	r2,-32704(gp)
81149064:	103ee83a 	callr	r2
81149068:	00000106 	br	81149070 <alt_get_errno+0x30>
8114906c:	d0a07804 	addi	r2,gp,-32288
}
81149070:	e037883a 	mov	sp,fp
81149074:	dfc00117 	ldw	ra,4(sp)
81149078:	df000017 	ldw	fp,0(sp)
8114907c:	dec00204 	addi	sp,sp,8
81149080:	f800283a 	ret

81149084 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81149084:	deffec04 	addi	sp,sp,-80
81149088:	de00012e 	bgeu	sp,et,81149090 <altera_avalon_uart_write+0xc>
8114908c:	003b68fa 	trap	3
81149090:	dfc01315 	stw	ra,76(sp)
81149094:	df001215 	stw	fp,72(sp)
81149098:	df001204 	addi	fp,sp,72
8114909c:	e13ffc15 	stw	r4,-16(fp)
811490a0:	e17ffd15 	stw	r5,-12(fp)
811490a4:	e1bffe15 	stw	r6,-8(fp)
811490a8:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
811490ac:	e0bffe17 	ldw	r2,-8(fp)
811490b0:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
811490b4:	e0bfff17 	ldw	r2,-4(fp)
811490b8:	1090000c 	andi	r2,r2,16384
811490bc:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
811490c0:	e0bffc17 	ldw	r2,-16(fp)
811490c4:	10800917 	ldw	r2,36(r2)
811490c8:	e0bff815 	stw	r2,-32(fp)
811490cc:	e03ff90d 	sth	zero,-28(fp)
811490d0:	e0bff90b 	ldhu	r2,-28(fp)
811490d4:	e0fffb44 	addi	r3,fp,-19
811490d8:	180d883a 	mov	r6,r3
811490dc:	100b883a 	mov	r5,r2
811490e0:	e13ff817 	ldw	r4,-32(fp)
811490e4:	113fdcc0 	call	8113fdcc <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
811490e8:	00005106 	br	81149230 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811490ec:	e0bffc17 	ldw	r2,-16(fp)
811490f0:	10800517 	ldw	r2,20(r2)
811490f4:	10800044 	addi	r2,r2,1
811490f8:	10800fcc 	andi	r2,r2,63
811490fc:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81149100:	e0bffc17 	ldw	r2,-16(fp)
81149104:	10c00417 	ldw	r3,16(r2)
81149108:	e0bff217 	ldw	r2,-56(fp)
8114910c:	1880371e 	bne	r3,r2,811491ec <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81149110:	e0bff017 	ldw	r2,-64(fp)
81149114:	10000526 	beq	r2,zero,8114912c <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81149118:	11490400 	call	81149040 <alt_get_errno>
8114911c:	1007883a 	mov	r3,r2
81149120:	008002c4 	movi	r2,11
81149124:	18800015 	stw	r2,0(r3)
        break;
81149128:	00004306 	br	81149238 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114912c:	0005303a 	rdctl	r2,status
81149130:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149134:	e0fff517 	ldw	r3,-44(fp)
81149138:	00bfff84 	movi	r2,-2
8114913c:	1884703a 	and	r2,r3,r2
81149140:	1001703a 	wrctl	status,r2
  
  return context;
81149144:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81149148:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
8114914c:	e0bffc17 	ldw	r2,-16(fp)
81149150:	10800117 	ldw	r2,4(r2)
81149154:	10c11014 	ori	r3,r2,1088
81149158:	e0bffc17 	ldw	r2,-16(fp)
8114915c:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81149160:	e0bffc17 	ldw	r2,-16(fp)
81149164:	10800017 	ldw	r2,0(r2)
81149168:	10800304 	addi	r2,r2,12
8114916c:	e0fffc17 	ldw	r3,-16(fp)
81149170:	18c00117 	ldw	r3,4(r3)
81149174:	10c00035 	stwio	r3,0(r2)
81149178:	e0bff417 	ldw	r2,-48(fp)
8114917c:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149180:	e0bff117 	ldw	r2,-60(fp)
81149184:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81149188:	e0bffc17 	ldw	r2,-16(fp)
8114918c:	10800717 	ldw	r2,28(r2)
81149190:	e0bff315 	stw	r2,-52(fp)
81149194:	00800084 	movi	r2,2
81149198:	e0bff98d 	sth	r2,-26(fp)
8114919c:	00bfe0c4 	movi	r2,-125
811491a0:	e0bffa05 	stb	r2,-24(fp)
811491a4:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
811491a8:	d0a09103 	ldbu	r2,-32188(gp)
811491ac:	10803fcc 	andi	r2,r2,255
811491b0:	10000a26 	beq	r2,zero,811491dc <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
811491b4:	e0fff98b 	ldhu	r3,-26(fp)
811491b8:	e13ffa03 	ldbu	r4,-24(fp)
811491bc:	e17ffa8b 	ldhu	r5,-22(fp)
811491c0:	e0bffb04 	addi	r2,fp,-20
811491c4:	d8800015 	stw	r2,0(sp)
811491c8:	280f883a 	mov	r7,r5
811491cc:	200d883a 	mov	r6,r4
811491d0:	180b883a 	mov	r5,r3
811491d4:	e13ff317 	ldw	r4,-52(fp)
811491d8:	113c12c0 	call	8113c12c <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
811491dc:	e0bffc17 	ldw	r2,-16(fp)
811491e0:	10c00417 	ldw	r3,16(r2)
811491e4:	e0bff217 	ldw	r2,-56(fp)
811491e8:	18bfe726 	beq	r3,r2,81149188 <__reset+0xfb129188>
      }
    }

    count--;
811491ec:	e0bfef17 	ldw	r2,-68(fp)
811491f0:	10bfffc4 	addi	r2,r2,-1
811491f4:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
811491f8:	e0bffc17 	ldw	r2,-16(fp)
811491fc:	10c00517 	ldw	r3,20(r2)
81149200:	e0bffd17 	ldw	r2,-12(fp)
81149204:	11000044 	addi	r4,r2,1
81149208:	e13ffd15 	stw	r4,-12(fp)
8114920c:	10800003 	ldbu	r2,0(r2)
81149210:	1009883a 	mov	r4,r2
81149214:	e0bffc17 	ldw	r2,-16(fp)
81149218:	10c5883a 	add	r2,r2,r3
8114921c:	10801a04 	addi	r2,r2,104
81149220:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81149224:	e0bffc17 	ldw	r2,-16(fp)
81149228:	e0fff217 	ldw	r3,-56(fp)
8114922c:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81149230:	e0bfef17 	ldw	r2,-68(fp)
81149234:	103fad1e 	bne	r2,zero,811490ec <__reset+0xfb1290ec>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81149238:	e0bffc17 	ldw	r2,-16(fp)
8114923c:	10800917 	ldw	r2,36(r2)
81149240:	1009883a 	mov	r4,r2
81149244:	11401540 	call	81140154 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149248:	0005303a 	rdctl	r2,status
8114924c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149250:	e0fff717 	ldw	r3,-36(fp)
81149254:	00bfff84 	movi	r2,-2
81149258:	1884703a 	and	r2,r3,r2
8114925c:	1001703a 	wrctl	status,r2
  
  return context;
81149260:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81149264:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81149268:	e0bffc17 	ldw	r2,-16(fp)
8114926c:	10800117 	ldw	r2,4(r2)
81149270:	10c11014 	ori	r3,r2,1088
81149274:	e0bffc17 	ldw	r2,-16(fp)
81149278:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8114927c:	e0bffc17 	ldw	r2,-16(fp)
81149280:	10800017 	ldw	r2,0(r2)
81149284:	10800304 	addi	r2,r2,12
81149288:	e0fffc17 	ldw	r3,-16(fp)
8114928c:	18c00117 	ldw	r3,4(r3)
81149290:	10c00035 	stwio	r3,0(r2)
81149294:	e0bff417 	ldw	r2,-48(fp)
81149298:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114929c:	e0bff617 	ldw	r2,-40(fp)
811492a0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
811492a4:	e0fffe17 	ldw	r3,-8(fp)
811492a8:	e0bfef17 	ldw	r2,-68(fp)
811492ac:	1885c83a 	sub	r2,r3,r2
}
811492b0:	e037883a 	mov	sp,fp
811492b4:	dfc00117 	ldw	ra,4(sp)
811492b8:	df000017 	ldw	fp,0(sp)
811492bc:	dec00204 	addi	sp,sp,8
811492c0:	f800283a 	ret

811492c4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811492c4:	defffe04 	addi	sp,sp,-8
811492c8:	de00012e 	bgeu	sp,et,811492d0 <alt_get_errno+0xc>
811492cc:	003b68fa 	trap	3
811492d0:	dfc00115 	stw	ra,4(sp)
811492d4:	df000015 	stw	fp,0(sp)
811492d8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811492dc:	d0a01017 	ldw	r2,-32704(gp)
811492e0:	10000326 	beq	r2,zero,811492f0 <alt_get_errno+0x2c>
811492e4:	d0a01017 	ldw	r2,-32704(gp)
811492e8:	103ee83a 	callr	r2
811492ec:	00000106 	br	811492f4 <alt_get_errno+0x30>
811492f0:	d0a07804 	addi	r2,gp,-32288
}
811492f4:	e037883a 	mov	sp,fp
811492f8:	dfc00117 	ldw	ra,4(sp)
811492fc:	df000017 	ldw	fp,0(sp)
81149300:	dec00204 	addi	sp,sp,8
81149304:	f800283a 	ret

81149308 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81149308:	defffc04 	addi	sp,sp,-16
8114930c:	de00012e 	bgeu	sp,et,81149314 <alt_msgdma_write_standard_descriptor+0xc>
81149310:	003b68fa 	trap	3
81149314:	df000315 	stw	fp,12(sp)
81149318:	df000304 	addi	fp,sp,12
8114931c:	e13ffd15 	stw	r4,-12(fp)
81149320:	e17ffe15 	stw	r5,-8(fp)
81149324:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81149328:	e0bffd17 	ldw	r2,-12(fp)
8114932c:	10800037 	ldwio	r2,0(r2)
81149330:	1080010c 	andi	r2,r2,4
81149334:	10000226 	beq	r2,zero,81149340 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81149338:	00bff904 	movi	r2,-28
8114933c:	00001506 	br	81149394 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
81149340:	e0bfff17 	ldw	r2,-4(fp)
81149344:	10800017 	ldw	r2,0(r2)
81149348:	1007883a 	mov	r3,r2
8114934c:	e0bffe17 	ldw	r2,-8(fp)
81149350:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
81149354:	e0bffe17 	ldw	r2,-8(fp)
81149358:	10800104 	addi	r2,r2,4
8114935c:	e0ffff17 	ldw	r3,-4(fp)
81149360:	18c00117 	ldw	r3,4(r3)
81149364:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81149368:	e0bffe17 	ldw	r2,-8(fp)
8114936c:	10800204 	addi	r2,r2,8
81149370:	e0ffff17 	ldw	r3,-4(fp)
81149374:	18c00217 	ldw	r3,8(r3)
81149378:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
8114937c:	e0bffe17 	ldw	r2,-8(fp)
81149380:	10800304 	addi	r2,r2,12
81149384:	e0ffff17 	ldw	r3,-4(fp)
81149388:	18c00317 	ldw	r3,12(r3)
8114938c:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
81149390:	0005883a 	mov	r2,zero
}
81149394:	e037883a 	mov	sp,fp
81149398:	df000017 	ldw	fp,0(sp)
8114939c:	dec00104 	addi	sp,sp,4
811493a0:	f800283a 	ret

811493a4 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
811493a4:	defffc04 	addi	sp,sp,-16
811493a8:	de00012e 	bgeu	sp,et,811493b0 <alt_msgdma_write_extended_descriptor+0xc>
811493ac:	003b68fa 	trap	3
811493b0:	df000315 	stw	fp,12(sp)
811493b4:	df000304 	addi	fp,sp,12
811493b8:	e13ffd15 	stw	r4,-12(fp)
811493bc:	e17ffe15 	stw	r5,-8(fp)
811493c0:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
811493c4:	e0bffd17 	ldw	r2,-12(fp)
811493c8:	10800037 	ldwio	r2,0(r2)
811493cc:	1080010c 	andi	r2,r2,4
811493d0:	10000226 	beq	r2,zero,811493dc <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
811493d4:	00bff904 	movi	r2,-28
811493d8:	00003b06 	br	811494c8 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
811493dc:	e0bfff17 	ldw	r2,-4(fp)
811493e0:	10800017 	ldw	r2,0(r2)
811493e4:	1007883a 	mov	r3,r2
811493e8:	e0bffe17 	ldw	r2,-8(fp)
811493ec:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
811493f0:	e0bffe17 	ldw	r2,-8(fp)
811493f4:	10800104 	addi	r2,r2,4
811493f8:	e0ffff17 	ldw	r3,-4(fp)
811493fc:	18c00117 	ldw	r3,4(r3)
81149400:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
81149404:	e0bffe17 	ldw	r2,-8(fp)
81149408:	10800204 	addi	r2,r2,8
8114940c:	e0ffff17 	ldw	r3,-4(fp)
81149410:	18c00217 	ldw	r3,8(r3)
81149414:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81149418:	e0bffe17 	ldw	r2,-8(fp)
8114941c:	10800304 	addi	r2,r2,12
81149420:	e0ffff17 	ldw	r3,-4(fp)
81149424:	18c0030b 	ldhu	r3,12(r3)
81149428:	18ffffcc 	andi	r3,r3,65535
8114942c:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
81149430:	e0bffe17 	ldw	r2,-8(fp)
81149434:	10800384 	addi	r2,r2,14
81149438:	e0ffff17 	ldw	r3,-4(fp)
8114943c:	18c00383 	ldbu	r3,14(r3)
81149440:	18c03fcc 	andi	r3,r3,255
81149444:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81149448:	e0bffe17 	ldw	r2,-8(fp)
8114944c:	108003c4 	addi	r2,r2,15
81149450:	e0ffff17 	ldw	r3,-4(fp)
81149454:	18c003c3 	ldbu	r3,15(r3)
81149458:	18c03fcc 	andi	r3,r3,255
8114945c:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
81149460:	e0bffe17 	ldw	r2,-8(fp)
81149464:	10800404 	addi	r2,r2,16
81149468:	e0ffff17 	ldw	r3,-4(fp)
8114946c:	18c0040b 	ldhu	r3,16(r3)
81149470:	18ffffcc 	andi	r3,r3,65535
81149474:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
81149478:	e0bffe17 	ldw	r2,-8(fp)
8114947c:	10800484 	addi	r2,r2,18
81149480:	e0ffff17 	ldw	r3,-4(fp)
81149484:	18c0048b 	ldhu	r3,18(r3)
81149488:	18ffffcc 	andi	r3,r3,65535
8114948c:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
81149490:	e0bffe17 	ldw	r2,-8(fp)
81149494:	10800504 	addi	r2,r2,20
81149498:	0007883a 	mov	r3,zero
8114949c:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
811494a0:	e0bffe17 	ldw	r2,-8(fp)
811494a4:	10800604 	addi	r2,r2,24
811494a8:	0007883a 	mov	r3,zero
811494ac:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
811494b0:	e0bffe17 	ldw	r2,-8(fp)
811494b4:	10800704 	addi	r2,r2,28
811494b8:	e0ffff17 	ldw	r3,-4(fp)
811494bc:	18c00717 	ldw	r3,28(r3)
811494c0:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
811494c4:	0005883a 	mov	r2,zero
}
811494c8:	e037883a 	mov	sp,fp
811494cc:	df000017 	ldw	fp,0(sp)
811494d0:	dec00104 	addi	sp,sp,4
811494d4:	f800283a 	ret

811494d8 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
811494d8:	defff804 	addi	sp,sp,-32
811494dc:	de00012e 	bgeu	sp,et,811494e4 <alt_msgdma_irq+0xc>
811494e0:	003b68fa 	trap	3
811494e4:	dfc00715 	stw	ra,28(sp)
811494e8:	df000615 	stw	fp,24(sp)
811494ec:	df000604 	addi	fp,sp,24
811494f0:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
811494f4:	e0bfff17 	ldw	r2,-4(fp)
811494f8:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
811494fc:	e0bffa17 	ldw	r2,-24(fp)
81149500:	10801783 	ldbu	r2,94(r2)
81149504:	10803fcc 	andi	r2,r2,255
81149508:	10001126 	beq	r2,zero,81149550 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
8114950c:	e0bffa17 	ldw	r2,-24(fp)
81149510:	10800617 	ldw	r2,24(r2)
81149514:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81149518:	1007883a 	mov	r3,r2
8114951c:	00bffdc4 	movi	r2,-9
81149520:	1884703a 	and	r2,r3,r2
81149524:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81149528:	e0bffa17 	ldw	r2,-24(fp)
8114952c:	10800617 	ldw	r2,24(r2)
81149530:	e0fffb17 	ldw	r3,-20(fp)
81149534:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81149538:	e0bffa17 	ldw	r2,-24(fp)
8114953c:	10800617 	ldw	r2,24(r2)
81149540:	10800404 	addi	r2,r2,16
81149544:	00c00044 	movi	r3,1
81149548:	10c00035 	stwio	r3,0(r2)
8114954c:	00001106 	br	81149594 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81149550:	e0bffa17 	ldw	r2,-24(fp)
81149554:	10800317 	ldw	r2,12(r2)
81149558:	10800104 	addi	r2,r2,4
8114955c:	10800037 	ldwio	r2,0(r2)
81149560:	1007883a 	mov	r3,r2
81149564:	00bffbc4 	movi	r2,-17
81149568:	1884703a 	and	r2,r3,r2
8114956c:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81149570:	e0bffa17 	ldw	r2,-24(fp)
81149574:	10800317 	ldw	r2,12(r2)
81149578:	10800104 	addi	r2,r2,4
8114957c:	e0fffb17 	ldw	r3,-20(fp)
81149580:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81149584:	e0bffa17 	ldw	r2,-24(fp)
81149588:	10800317 	ldw	r2,12(r2)
8114958c:	00c08004 	movi	r3,512
81149590:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
81149594:	e0bffa17 	ldw	r2,-24(fp)
81149598:	10800b17 	ldw	r2,44(r2)
8114959c:	10001226 	beq	r2,zero,811495e8 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811495a0:	0005303a 	rdctl	r2,status
811495a4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811495a8:	e0fffd17 	ldw	r3,-12(fp)
811495ac:	00bfff84 	movi	r2,-2
811495b0:	1884703a 	and	r2,r3,r2
811495b4:	1001703a 	wrctl	status,r2
  
  return context;
811495b8:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
811495bc:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
811495c0:	e0bffa17 	ldw	r2,-24(fp)
811495c4:	10800b17 	ldw	r2,44(r2)
811495c8:	e0fffa17 	ldw	r3,-24(fp)
811495cc:	18c00c17 	ldw	r3,48(r3)
811495d0:	1809883a 	mov	r4,r3
811495d4:	103ee83a 	callr	r2
811495d8:	e0bffc17 	ldw	r2,-16(fp)
811495dc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811495e0:	e0bffe17 	ldw	r2,-8(fp)
811495e4:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
811495e8:	e0bffa17 	ldw	r2,-24(fp)
811495ec:	10801783 	ldbu	r2,94(r2)
811495f0:	10803fcc 	andi	r2,r2,255
811495f4:	10000a26 	beq	r2,zero,81149620 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
811495f8:	e0bffa17 	ldw	r2,-24(fp)
811495fc:	10800617 	ldw	r2,24(r2)
81149600:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81149604:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81149608:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
8114960c:	e0bffa17 	ldw	r2,-24(fp)
81149610:	10800617 	ldw	r2,24(r2)
81149614:	e0fffb17 	ldw	r3,-20(fp)
81149618:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
8114961c:	00000c06 	br	81149650 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81149620:	e0bffa17 	ldw	r2,-24(fp)
81149624:	10800317 	ldw	r2,12(r2)
81149628:	10800104 	addi	r2,r2,4
8114962c:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
81149630:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81149634:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81149638:	e0bffa17 	ldw	r2,-24(fp)
8114963c:	10800317 	ldw	r2,12(r2)
81149640:	10800104 	addi	r2,r2,4
81149644:	e0fffb17 	ldw	r3,-20(fp)
81149648:	10c00035 	stwio	r3,0(r2)
    }

    return;
8114964c:	0001883a 	nop
}
81149650:	e037883a 	mov	sp,fp
81149654:	dfc00117 	ldw	ra,4(sp)
81149658:	df000017 	ldw	fp,0(sp)
8114965c:	dec00204 	addi	sp,sp,8
81149660:	f800283a 	ret

81149664 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81149664:	defffb04 	addi	sp,sp,-20
81149668:	de00012e 	bgeu	sp,et,81149670 <alt_msgdma_construct_standard_descriptor+0xc>
8114966c:	003b68fa 	trap	3
81149670:	df000415 	stw	fp,16(sp)
81149674:	df000404 	addi	fp,sp,16
81149678:	e13ffc15 	stw	r4,-16(fp)
8114967c:	e17ffd15 	stw	r5,-12(fp)
81149680:	e1bffe15 	stw	r6,-8(fp)
81149684:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81149688:	e0bffc17 	ldw	r2,-16(fp)
8114968c:	10c01217 	ldw	r3,72(r2)
81149690:	e0800117 	ldw	r2,4(fp)
81149694:	18800436 	bltu	r3,r2,811496a8 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
81149698:	e0bffc17 	ldw	r2,-16(fp)
8114969c:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
811496a0:	10803fcc 	andi	r2,r2,255
811496a4:	10000226 	beq	r2,zero,811496b0 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
811496a8:	00bffa84 	movi	r2,-22
811496ac:	00000e06 	br	811496e8 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
811496b0:	e0bffd17 	ldw	r2,-12(fp)
811496b4:	e0fffe17 	ldw	r3,-8(fp)
811496b8:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
811496bc:	e0bffd17 	ldw	r2,-12(fp)
811496c0:	e0ffff17 	ldw	r3,-4(fp)
811496c4:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
811496c8:	e0bffd17 	ldw	r2,-12(fp)
811496cc:	e0c00117 	ldw	r3,4(fp)
811496d0:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811496d4:	e0800217 	ldw	r2,8(fp)
811496d8:	10e00034 	orhi	r3,r2,32768
811496dc:	e0bffd17 	ldw	r2,-12(fp)
811496e0:	10c00315 	stw	r3,12(r2)
    
    return 0;
811496e4:	0005883a 	mov	r2,zero
}
811496e8:	e037883a 	mov	sp,fp
811496ec:	df000017 	ldw	fp,0(sp)
811496f0:	dec00104 	addi	sp,sp,4
811496f4:	f800283a 	ret

811496f8 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
811496f8:	defff604 	addi	sp,sp,-40
811496fc:	de00012e 	bgeu	sp,et,81149704 <alt_msgdma_construct_extended_descriptor+0xc>
81149700:	003b68fa 	trap	3
81149704:	df000915 	stw	fp,36(sp)
81149708:	df000904 	addi	fp,sp,36
8114970c:	e13ff715 	stw	r4,-36(fp)
81149710:	e17ff815 	stw	r5,-32(fp)
81149714:	e1bff915 	stw	r6,-28(fp)
81149718:	e1fffa15 	stw	r7,-24(fp)
8114971c:	e1800317 	ldw	r6,12(fp)
81149720:	e1400417 	ldw	r5,16(fp)
81149724:	e1000517 	ldw	r4,20(fp)
81149728:	e0c00617 	ldw	r3,24(fp)
8114972c:	e0800717 	ldw	r2,28(fp)
81149730:	e1bffb0d 	sth	r6,-20(fp)
81149734:	e17ffc05 	stb	r5,-16(fp)
81149738:	e13ffd05 	stb	r4,-12(fp)
8114973c:	e0fffe0d 	sth	r3,-8(fp)
81149740:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
81149744:	e0bff717 	ldw	r2,-36(fp)
81149748:	10c01217 	ldw	r3,72(r2)
8114974c:	e0800117 	ldw	r2,4(fp)
81149750:	18801936 	bltu	r3,r2,811497b8 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81149754:	e13ff717 	ldw	r4,-36(fp)
81149758:	20801317 	ldw	r2,76(r4)
8114975c:	20c01417 	ldw	r3,80(r4)
81149760:	e13ffe0b 	ldhu	r4,-8(fp)
81149764:	213fffcc 	andi	r4,r4,65535
81149768:	2015883a 	mov	r10,r4
8114976c:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
81149770:	1ac01136 	bltu	r3,r11,811497b8 <alt_msgdma_construct_extended_descriptor+0xc0>
81149774:	58c0011e 	bne	r11,r3,8114977c <alt_msgdma_construct_extended_descriptor+0x84>
81149778:	12800f36 	bltu	r2,r10,811497b8 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114977c:	e13ff717 	ldw	r4,-36(fp)
81149780:	20801317 	ldw	r2,76(r4)
81149784:	20c01417 	ldw	r3,80(r4)
81149788:	e13fff0b 	ldhu	r4,-4(fp)
8114978c:	213fffcc 	andi	r4,r4,65535
81149790:	2011883a 	mov	r8,r4
81149794:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81149798:	1a400736 	bltu	r3,r9,811497b8 <alt_msgdma_construct_extended_descriptor+0xc0>
8114979c:	48c0011e 	bne	r9,r3,811497a4 <alt_msgdma_construct_extended_descriptor+0xac>
811497a0:	12000536 	bltu	r2,r8,811497b8 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
811497a4:	e0bff717 	ldw	r2,-36(fp)
811497a8:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811497ac:	10803fcc 	andi	r2,r2,255
811497b0:	10800060 	cmpeqi	r2,r2,1
811497b4:	1000021e 	bne	r2,zero,811497c0 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
811497b8:	00bffa84 	movi	r2,-22
811497bc:	00002106 	br	81149844 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
811497c0:	e0bff817 	ldw	r2,-32(fp)
811497c4:	e0fff917 	ldw	r3,-28(fp)
811497c8:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
811497cc:	e0bff817 	ldw	r2,-32(fp)
811497d0:	e0fffa17 	ldw	r3,-24(fp)
811497d4:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
811497d8:	e0bff817 	ldw	r2,-32(fp)
811497dc:	e0c00117 	ldw	r3,4(fp)
811497e0:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
811497e4:	e0bff817 	ldw	r2,-32(fp)
811497e8:	e0fffb0b 	ldhu	r3,-20(fp)
811497ec:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
811497f0:	e0bff817 	ldw	r2,-32(fp)
811497f4:	e0fffc03 	ldbu	r3,-16(fp)
811497f8:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
811497fc:	e0bff817 	ldw	r2,-32(fp)
81149800:	e0fffd03 	ldbu	r3,-12(fp)
81149804:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
81149808:	e0bff817 	ldw	r2,-32(fp)
8114980c:	e0fffe0b 	ldhu	r3,-8(fp)
81149810:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
81149814:	e0bff817 	ldw	r2,-32(fp)
81149818:	e0ffff0b 	ldhu	r3,-4(fp)
8114981c:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
81149820:	e0bff817 	ldw	r2,-32(fp)
81149824:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
81149828:	e0bff817 	ldw	r2,-32(fp)
8114982c:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81149830:	e0800217 	ldw	r2,8(fp)
81149834:	10e00034 	orhi	r3,r2,32768
81149838:	e0bff817 	ldw	r2,-32(fp)
8114983c:	10c00715 	stw	r3,28(r2)

  return 0 ;
81149840:	0005883a 	mov	r2,zero

}
81149844:	e037883a 	mov	sp,fp
81149848:	df000017 	ldw	fp,0(sp)
8114984c:	dec00104 	addi	sp,sp,4
81149850:	f800283a 	ret

81149854 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81149854:	deffee04 	addi	sp,sp,-72
81149858:	de00012e 	bgeu	sp,et,81149860 <alt_msgdma_descriptor_async_transfer+0xc>
8114985c:	003b68fa 	trap	3
81149860:	dfc01115 	stw	ra,68(sp)
81149864:	df001015 	stw	fp,64(sp)
81149868:	df001004 	addi	fp,sp,64
8114986c:	e13ffd15 	stw	r4,-12(fp)
81149870:	e17ffe15 	stw	r5,-8(fp)
81149874:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
81149878:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
8114987c:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
81149880:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81149884:	e0bffd17 	ldw	r2,-12(fp)
81149888:	10800317 	ldw	r2,12(r2)
8114988c:	10800204 	addi	r2,r2,8
81149890:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81149894:	10bfffcc 	andi	r2,r2,65535
81149898:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114989c:	e0bffd17 	ldw	r2,-12(fp)
811498a0:	10800317 	ldw	r2,12(r2)
811498a4:	10800204 	addi	r2,r2,8
811498a8:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811498ac:	1004d43a 	srli	r2,r2,16
811498b0:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811498b4:	e0bffd17 	ldw	r2,-12(fp)
811498b8:	10800917 	ldw	r2,36(r2)
811498bc:	e0fff417 	ldw	r3,-48(fp)
811498c0:	1880042e 	bgeu	r3,r2,811498d4 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
811498c4:	e0bffd17 	ldw	r2,-12(fp)
811498c8:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811498cc:	e0fff317 	ldw	r3,-52(fp)
811498d0:	18800236 	bltu	r3,r2,811498dc <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
811498d4:	00bff904 	movi	r2,-28
811498d8:	0000a906 	br	81149b80 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
811498dc:	e0bffd17 	ldw	r2,-12(fp)
811498e0:	10801817 	ldw	r2,96(r2)
811498e4:	e0bff615 	stw	r2,-40(fp)
811498e8:	e03ffc0d 	sth	zero,-16(fp)
811498ec:	e0bffc0b 	ldhu	r2,-16(fp)
811498f0:	e0fffc84 	addi	r3,fp,-14
811498f4:	180d883a 	mov	r6,r3
811498f8:	100b883a 	mov	r5,r2
811498fc:	e13ff617 	ldw	r4,-40(fp)
81149900:	113fdcc0 	call	8113fdcc <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81149904:	00800804 	movi	r2,32
81149908:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114990c:	0005303a 	rdctl	r2,status
81149910:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149914:	e0fff717 	ldw	r3,-36(fp)
81149918:	00bfff84 	movi	r2,-2
8114991c:	1884703a 	and	r2,r3,r2
81149920:	1001703a 	wrctl	status,r2
  
  return context;
81149924:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81149928:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8114992c:	e0bffd17 	ldw	r2,-12(fp)
81149930:	10800317 	ldw	r2,12(r2)
81149934:	10800104 	addi	r2,r2,4
81149938:	e0fff117 	ldw	r3,-60(fp)
8114993c:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
81149940:	e0bffd17 	ldw	r2,-12(fp)
81149944:	10800317 	ldw	r2,12(r2)
81149948:	e0fffd17 	ldw	r3,-12(fp)
8114994c:	18c00317 	ldw	r3,12(r3)
81149950:	18c00037 	ldwio	r3,0(r3)
81149954:	10c00035 	stwio	r3,0(r2)
81149958:	e0bff217 	ldw	r2,-56(fp)
8114995c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149960:	e0bffb17 	ldw	r2,-20(fp)
81149964:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81149968:	e0bffe17 	ldw	r2,-8(fp)
8114996c:	10001e26 	beq	r2,zero,811499e8 <alt_msgdma_descriptor_async_transfer+0x194>
81149970:	e0bfff17 	ldw	r2,-4(fp)
81149974:	10001c1e 	bne	r2,zero,811499e8 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81149978:	00001106 	br	811499c0 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8114997c:	01000044 	movi	r4,1
81149980:	11375540 	call	81137554 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81149984:	e0bff00b 	ldhu	r2,-64(fp)
81149988:	1084e230 	cmpltui	r2,r2,5000
8114998c:	1000091e 	bne	r2,zero,811499b4 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
81149990:	01204574 	movhi	r4,33045
81149994:	2108f604 	addi	r4,r4,9176
81149998:	114bca80 	call	8114bca8 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114999c:	e0bffd17 	ldw	r2,-12(fp)
811499a0:	10801817 	ldw	r2,96(r2)
811499a4:	1009883a 	mov	r4,r2
811499a8:	11401540 	call	81140154 <OSSemPost>
				
                return -ETIME;
811499ac:	00bff084 	movi	r2,-62
811499b0:	00007306 	br	81149b80 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
811499b4:	e0bff00b 	ldhu	r2,-64(fp)
811499b8:	10800044 	addi	r2,r2,1
811499bc:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811499c0:	e0bffd17 	ldw	r2,-12(fp)
811499c4:	10c00317 	ldw	r3,12(r2)
811499c8:	e0bffd17 	ldw	r2,-12(fp)
811499cc:	10800417 	ldw	r2,16(r2)
811499d0:	e1bffe17 	ldw	r6,-8(fp)
811499d4:	100b883a 	mov	r5,r2
811499d8:	1809883a 	mov	r4,r3
811499dc:	11493080 	call	81149308 <alt_msgdma_write_standard_descriptor>
811499e0:	103fe61e 	bne	r2,zero,8114997c <__reset+0xfb12997c>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
811499e4:	00002706 	br	81149a84 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811499e8:	e0bffe17 	ldw	r2,-8(fp)
811499ec:	10001f1e 	bne	r2,zero,81149a6c <alt_msgdma_descriptor_async_transfer+0x218>
811499f0:	e0bfff17 	ldw	r2,-4(fp)
811499f4:	10001d26 	beq	r2,zero,81149a6c <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
811499f8:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811499fc:	00001106 	br	81149a44 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81149a00:	01000044 	movi	r4,1
81149a04:	11375540 	call	81137554 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81149a08:	e0bff00b 	ldhu	r2,-64(fp)
81149a0c:	1084e230 	cmpltui	r2,r2,5000
81149a10:	1000091e 	bne	r2,zero,81149a38 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
81149a14:	01204574 	movhi	r4,33045
81149a18:	21090c04 	addi	r4,r4,9264
81149a1c:	114bca80 	call	8114bca8 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81149a20:	e0bffd17 	ldw	r2,-12(fp)
81149a24:	10801817 	ldw	r2,96(r2)
81149a28:	1009883a 	mov	r4,r2
81149a2c:	11401540 	call	81140154 <OSSemPost>
				
                return -ETIME;
81149a30:	00bff084 	movi	r2,-62
81149a34:	00005206 	br	81149b80 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81149a38:	e0bff00b 	ldhu	r2,-64(fp)
81149a3c:	10800044 	addi	r2,r2,1
81149a40:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81149a44:	e0bffd17 	ldw	r2,-12(fp)
81149a48:	10c00317 	ldw	r3,12(r2)
81149a4c:	e0bffd17 	ldw	r2,-12(fp)
81149a50:	10800417 	ldw	r2,16(r2)
81149a54:	e1bfff17 	ldw	r6,-4(fp)
81149a58:	100b883a 	mov	r5,r2
81149a5c:	1809883a 	mov	r4,r3
81149a60:	11493a40 	call	811493a4 <alt_msgdma_write_extended_descriptor>
81149a64:	103fe61e 	bne	r2,zero,81149a00 <__reset+0xfb129a00>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81149a68:	00000606 	br	81149a84 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81149a6c:	e0bffd17 	ldw	r2,-12(fp)
81149a70:	10801817 	ldw	r2,96(r2)
81149a74:	1009883a 	mov	r4,r2
81149a78:	11401540 	call	81140154 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81149a7c:	00bfffc4 	movi	r2,-1
81149a80:	00003f06 	br	81149b80 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
81149a84:	e0bffd17 	ldw	r2,-12(fp)
81149a88:	10800b17 	ldw	r2,44(r2)
81149a8c:	10001c26 	beq	r2,zero,81149b00 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
81149a90:	e0bffd17 	ldw	r2,-12(fp)
81149a94:	10c00d17 	ldw	r3,52(r2)
81149a98:	e0bff117 	ldw	r2,-60(fp)
81149a9c:	1884b03a 	or	r2,r3,r2
81149aa0:	10800514 	ori	r2,r2,20
81149aa4:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81149aa8:	e0fff117 	ldw	r3,-60(fp)
81149aac:	00bff7c4 	movi	r2,-33
81149ab0:	1884703a 	and	r2,r3,r2
81149ab4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149ab8:	0005303a 	rdctl	r2,status
81149abc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149ac0:	e0fff917 	ldw	r3,-28(fp)
81149ac4:	00bfff84 	movi	r2,-2
81149ac8:	1884703a 	and	r2,r3,r2
81149acc:	1001703a 	wrctl	status,r2
  
  return context;
81149ad0:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
81149ad4:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81149ad8:	e0bffd17 	ldw	r2,-12(fp)
81149adc:	10800317 	ldw	r2,12(r2)
81149ae0:	10800104 	addi	r2,r2,4
81149ae4:	e0fff117 	ldw	r3,-60(fp)
81149ae8:	10c00035 	stwio	r3,0(r2)
81149aec:	e0bff217 	ldw	r2,-56(fp)
81149af0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149af4:	e0bff517 	ldw	r2,-44(fp)
81149af8:	1001703a 	wrctl	status,r2
81149afc:	00001b06 	br	81149b6c <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
81149b00:	e0bffd17 	ldw	r2,-12(fp)
81149b04:	10c00d17 	ldw	r3,52(r2)
81149b08:	e0bff117 	ldw	r2,-60(fp)
81149b0c:	1884b03a 	or	r2,r3,r2
81149b10:	10800114 	ori	r2,r2,4
81149b14:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
81149b18:	e0fff117 	ldw	r3,-60(fp)
81149b1c:	00bff3c4 	movi	r2,-49
81149b20:	1884703a 	and	r2,r3,r2
81149b24:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149b28:	0005303a 	rdctl	r2,status
81149b2c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149b30:	e0fffa17 	ldw	r3,-24(fp)
81149b34:	00bfff84 	movi	r2,-2
81149b38:	1884703a 	and	r2,r3,r2
81149b3c:	1001703a 	wrctl	status,r2
  
  return context;
81149b40:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
81149b44:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81149b48:	e0bffd17 	ldw	r2,-12(fp)
81149b4c:	10800317 	ldw	r2,12(r2)
81149b50:	10800104 	addi	r2,r2,4
81149b54:	e0fff117 	ldw	r3,-60(fp)
81149b58:	10c00035 	stwio	r3,0(r2)
81149b5c:	e0bff217 	ldw	r2,-56(fp)
81149b60:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149b64:	e0bff817 	ldw	r2,-32(fp)
81149b68:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
81149b6c:	e0bffd17 	ldw	r2,-12(fp)
81149b70:	10801817 	ldw	r2,96(r2)
81149b74:	1009883a 	mov	r4,r2
81149b78:	11401540 	call	81140154 <OSSemPost>
    
    return 0;
81149b7c:	0005883a 	mov	r2,zero
}
81149b80:	e037883a 	mov	sp,fp
81149b84:	dfc00117 	ldw	ra,4(sp)
81149b88:	df000017 	ldw	fp,0(sp)
81149b8c:	dec00204 	addi	sp,sp,8
81149b90:	f800283a 	ret

81149b94 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81149b94:	deffee04 	addi	sp,sp,-72
81149b98:	de00012e 	bgeu	sp,et,81149ba0 <alt_msgdma_descriptor_sync_transfer+0xc>
81149b9c:	003b68fa 	trap	3
81149ba0:	dfc01115 	stw	ra,68(sp)
81149ba4:	df001015 	stw	fp,64(sp)
81149ba8:	df001004 	addi	fp,sp,64
81149bac:	e13ffd15 	stw	r4,-12(fp)
81149bb0:	e17ffe15 	stw	r5,-8(fp)
81149bb4:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
81149bb8:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
81149bbc:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
81149bc0:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
81149bc4:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81149bc8:	e0bffd17 	ldw	r2,-12(fp)
81149bcc:	10800317 	ldw	r2,12(r2)
81149bd0:	10800204 	addi	r2,r2,8
81149bd4:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81149bd8:	10bfffcc 	andi	r2,r2,65535
81149bdc:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81149be0:	e0bffd17 	ldw	r2,-12(fp)
81149be4:	10800317 	ldw	r2,12(r2)
81149be8:	10800204 	addi	r2,r2,8
81149bec:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
81149bf0:	1004d43a 	srli	r2,r2,16
81149bf4:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
81149bf8:	00807804 	movi	r2,480
81149bfc:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81149c00:	00001906 	br	81149c68 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
81149c04:	01000044 	movi	r4,1
81149c08:	11375540 	call	81137554 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81149c0c:	e0bff10b 	ldhu	r2,-60(fp)
81149c10:	1084e230 	cmpltui	r2,r2,5000
81149c14:	1000051e 	bne	r2,zero,81149c2c <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
81149c18:	01204574 	movhi	r4,33045
81149c1c:	21092204 	addi	r4,r4,9352
81149c20:	114bca80 	call	8114bca8 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
81149c24:	00bff084 	movi	r2,-62
81149c28:	0000d706 	br	81149f88 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
81149c2c:	e0bff10b 	ldhu	r2,-60(fp)
81149c30:	10800044 	addi	r2,r2,1
81149c34:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81149c38:	e0bffd17 	ldw	r2,-12(fp)
81149c3c:	10800317 	ldw	r2,12(r2)
81149c40:	10800204 	addi	r2,r2,8
81149c44:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
81149c48:	10bfffcc 	andi	r2,r2,65535
81149c4c:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81149c50:	e0bffd17 	ldw	r2,-12(fp)
81149c54:	10800317 	ldw	r2,12(r2)
81149c58:	10800204 	addi	r2,r2,8
81149c5c:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
81149c60:	1004d43a 	srli	r2,r2,16
81149c64:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81149c68:	e0bffd17 	ldw	r2,-12(fp)
81149c6c:	10800917 	ldw	r2,36(r2)
81149c70:	e0fff317 	ldw	r3,-52(fp)
81149c74:	18bfe32e 	bgeu	r3,r2,81149c04 <__reset+0xfb129c04>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81149c78:	e0bffd17 	ldw	r2,-12(fp)
81149c7c:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81149c80:	e0fff217 	ldw	r3,-56(fp)
81149c84:	18bfdf2e 	bgeu	r3,r2,81149c04 <__reset+0xfb129c04>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
81149c88:	e0bffd17 	ldw	r2,-12(fp)
81149c8c:	10801817 	ldw	r2,96(r2)
81149c90:	e0bff815 	stw	r2,-32(fp)
81149c94:	e03ffc0d 	sth	zero,-16(fp)
81149c98:	e0bffc0b 	ldhu	r2,-16(fp)
81149c9c:	e0fffc84 	addi	r3,fp,-14
81149ca0:	180d883a 	mov	r6,r3
81149ca4:	100b883a 	mov	r5,r2
81149ca8:	e13ff817 	ldw	r4,-32(fp)
81149cac:	113fdcc0 	call	8113fdcc <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149cb0:	0005303a 	rdctl	r2,status
81149cb4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149cb8:	e0fffb17 	ldw	r3,-20(fp)
81149cbc:	00bfff84 	movi	r2,-2
81149cc0:	1884703a 	and	r2,r3,r2
81149cc4:	1001703a 	wrctl	status,r2
  
  return context;
81149cc8:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
81149ccc:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81149cd0:	e0bffd17 	ldw	r2,-12(fp)
81149cd4:	10800317 	ldw	r2,12(r2)
81149cd8:	10800104 	addi	r2,r2,4
81149cdc:	00c00804 	movi	r3,32
81149ce0:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81149ce4:	e0bffd17 	ldw	r2,-12(fp)
81149ce8:	10800317 	ldw	r2,12(r2)
81149cec:	e0fffd17 	ldw	r3,-12(fp)
81149cf0:	18c00317 	ldw	r3,12(r3)
81149cf4:	18c00037 	ldwio	r3,0(r3)
81149cf8:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81149cfc:	e0bffe17 	ldw	r2,-8(fp)
81149d00:	10001f26 	beq	r2,zero,81149d80 <alt_msgdma_descriptor_sync_transfer+0x1ec>
81149d04:	e0bfff17 	ldw	r2,-4(fp)
81149d08:	10001d1e 	bne	r2,zero,81149d80 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
81149d0c:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81149d10:	00001106 	br	81149d58 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
81149d14:	01000044 	movi	r4,1
81149d18:	11375540 	call	81137554 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81149d1c:	e0bff10b 	ldhu	r2,-60(fp)
81149d20:	1084e230 	cmpltui	r2,r2,5000
81149d24:	1000091e 	bne	r2,zero,81149d4c <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
81149d28:	01204574 	movhi	r4,33045
81149d2c:	21093604 	addi	r4,r4,9432
81149d30:	114bca80 	call	8114bca8 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81149d34:	e0bffd17 	ldw	r2,-12(fp)
81149d38:	10801817 	ldw	r2,96(r2)
81149d3c:	1009883a 	mov	r4,r2
81149d40:	11401540 	call	81140154 <OSSemPost>
				
                return -ETIME;
81149d44:	00bff084 	movi	r2,-62
81149d48:	00008f06 	br	81149f88 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81149d4c:	e0bff10b 	ldhu	r2,-60(fp)
81149d50:	10800044 	addi	r2,r2,1
81149d54:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81149d58:	e0bffd17 	ldw	r2,-12(fp)
81149d5c:	10c00317 	ldw	r3,12(r2)
81149d60:	e0bffd17 	ldw	r2,-12(fp)
81149d64:	10800417 	ldw	r2,16(r2)
81149d68:	e1bffe17 	ldw	r6,-8(fp)
81149d6c:	100b883a 	mov	r5,r2
81149d70:	1809883a 	mov	r4,r3
81149d74:	11493080 	call	81149308 <alt_msgdma_write_standard_descriptor>
81149d78:	103fe61e 	bne	r2,zero,81149d14 <__reset+0xfb129d14>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81149d7c:	00002706 	br	81149e1c <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81149d80:	e0bffe17 	ldw	r2,-8(fp)
81149d84:	10001f1e 	bne	r2,zero,81149e04 <alt_msgdma_descriptor_sync_transfer+0x270>
81149d88:	e0bfff17 	ldw	r2,-4(fp)
81149d8c:	10001d26 	beq	r2,zero,81149e04 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
81149d90:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81149d94:	00001106 	br	81149ddc <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81149d98:	01000044 	movi	r4,1
81149d9c:	11375540 	call	81137554 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81149da0:	e0bff10b 	ldhu	r2,-60(fp)
81149da4:	1084e230 	cmpltui	r2,r2,5000
81149da8:	1000091e 	bne	r2,zero,81149dd0 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
81149dac:	01204574 	movhi	r4,33045
81149db0:	21094704 	addi	r4,r4,9500
81149db4:	114bca80 	call	8114bca8 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81149db8:	e0bffd17 	ldw	r2,-12(fp)
81149dbc:	10801817 	ldw	r2,96(r2)
81149dc0:	1009883a 	mov	r4,r2
81149dc4:	11401540 	call	81140154 <OSSemPost>
				
                return -ETIME;
81149dc8:	00bff084 	movi	r2,-62
81149dcc:	00006e06 	br	81149f88 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
81149dd0:	e0bff10b 	ldhu	r2,-60(fp)
81149dd4:	10800044 	addi	r2,r2,1
81149dd8:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81149ddc:	e0bffd17 	ldw	r2,-12(fp)
81149de0:	10c00317 	ldw	r3,12(r2)
81149de4:	e0bffd17 	ldw	r2,-12(fp)
81149de8:	10800417 	ldw	r2,16(r2)
81149dec:	e1bfff17 	ldw	r6,-4(fp)
81149df0:	100b883a 	mov	r5,r2
81149df4:	1809883a 	mov	r4,r3
81149df8:	11493a40 	call	811493a4 <alt_msgdma_write_extended_descriptor>
81149dfc:	103fe61e 	bne	r2,zero,81149d98 <__reset+0xfb129d98>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81149e00:	00000606 	br	81149e1c <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81149e04:	e0bffd17 	ldw	r2,-12(fp)
81149e08:	10801817 	ldw	r2,96(r2)
81149e0c:	1009883a 	mov	r4,r2
81149e10:	11401540 	call	81140154 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81149e14:	00bfffc4 	movi	r2,-1
81149e18:	00005b06 	br	81149f88 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81149e1c:	e0bffd17 	ldw	r2,-12(fp)
81149e20:	10800317 	ldw	r2,12(r2)
81149e24:	10800104 	addi	r2,r2,4
81149e28:	e0fffd17 	ldw	r3,-12(fp)
81149e2c:	19000d17 	ldw	r4,52(r3)
81149e30:	00fff2c4 	movi	r3,-53
81149e34:	20c6703a 	and	r3,r4,r3
81149e38:	18c00114 	ori	r3,r3,4
81149e3c:	10c00035 	stwio	r3,0(r2)
81149e40:	e0bff517 	ldw	r2,-44(fp)
81149e44:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149e48:	e0bff717 	ldw	r2,-36(fp)
81149e4c:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
81149e50:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81149e54:	e0bffd17 	ldw	r2,-12(fp)
81149e58:	10800317 	ldw	r2,12(r2)
81149e5c:	10800037 	ldwio	r2,0(r2)
81149e60:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81149e64:	00001506 	br	81149ebc <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81149e68:	01000044 	movi	r4,1
81149e6c:	11375540 	call	81137554 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81149e70:	e0bff10b 	ldhu	r2,-60(fp)
81149e74:	1084e230 	cmpltui	r2,r2,5000
81149e78:	1000091e 	bne	r2,zero,81149ea0 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
81149e7c:	01204574 	movhi	r4,33045
81149e80:	21095804 	addi	r4,r4,9568
81149e84:	114bca80 	call	8114bca8 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
81149e88:	e0bffd17 	ldw	r2,-12(fp)
81149e8c:	10801817 	ldw	r2,96(r2)
81149e90:	1009883a 	mov	r4,r2
81149e94:	11401540 	call	81140154 <OSSemPost>
			
            return -ETIME;
81149e98:	00bff084 	movi	r2,-62
81149e9c:	00003a06 	br	81149f88 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
81149ea0:	e0bff10b 	ldhu	r2,-60(fp)
81149ea4:	10800044 	addi	r2,r2,1
81149ea8:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81149eac:	e0bffd17 	ldw	r2,-12(fp)
81149eb0:	10800317 	ldw	r2,12(r2)
81149eb4:	10800037 	ldwio	r2,0(r2)
81149eb8:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81149ebc:	e0fff017 	ldw	r3,-64(fp)
81149ec0:	e0bff617 	ldw	r2,-40(fp)
81149ec4:	1884703a 	and	r2,r3,r2
81149ec8:	1000031e 	bne	r2,zero,81149ed8 <alt_msgdma_descriptor_sync_transfer+0x344>
81149ecc:	e0bff017 	ldw	r2,-64(fp)
81149ed0:	1080004c 	andi	r2,r2,1
81149ed4:	103fe41e 	bne	r2,zero,81149e68 <__reset+0xfb129e68>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
81149ed8:	e0fff017 	ldw	r3,-64(fp)
81149edc:	e0bff617 	ldw	r2,-40(fp)
81149ee0:	1884703a 	and	r2,r3,r2
81149ee4:	10000626 	beq	r2,zero,81149f00 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81149ee8:	e0bffd17 	ldw	r2,-12(fp)
81149eec:	10801817 	ldw	r2,96(r2)
81149ef0:	1009883a 	mov	r4,r2
81149ef4:	11401540 	call	81140154 <OSSemPost>
		
        return error;
81149ef8:	e0bff617 	ldw	r2,-40(fp)
81149efc:	00002206 	br	81149f88 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
81149f00:	e0bffd17 	ldw	r2,-12(fp)
81149f04:	10800317 	ldw	r2,12(r2)
81149f08:	10800104 	addi	r2,r2,4
81149f0c:	10800037 	ldwio	r2,0(r2)
81149f10:	10800814 	ori	r2,r2,32
81149f14:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149f18:	0005303a 	rdctl	r2,status
81149f1c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149f20:	e0fffa17 	ldw	r3,-24(fp)
81149f24:	00bfff84 	movi	r2,-2
81149f28:	1884703a 	and	r2,r3,r2
81149f2c:	1001703a 	wrctl	status,r2
  
  return context;
81149f30:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
81149f34:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81149f38:	e0bffd17 	ldw	r2,-12(fp)
81149f3c:	10800317 	ldw	r2,12(r2)
81149f40:	10800104 	addi	r2,r2,4
81149f44:	e0fff417 	ldw	r3,-48(fp)
81149f48:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81149f4c:	e0bffd17 	ldw	r2,-12(fp)
81149f50:	10800317 	ldw	r2,12(r2)
81149f54:	e0fffd17 	ldw	r3,-12(fp)
81149f58:	18c00317 	ldw	r3,12(r3)
81149f5c:	18c00037 	ldwio	r3,0(r3)
81149f60:	10c00035 	stwio	r3,0(r2)
81149f64:	e0bff517 	ldw	r2,-44(fp)
81149f68:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149f6c:	e0bff917 	ldw	r2,-28(fp)
81149f70:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81149f74:	e0bffd17 	ldw	r2,-12(fp)
81149f78:	10801817 	ldw	r2,96(r2)
81149f7c:	1009883a 	mov	r4,r2
81149f80:	11401540 	call	81140154 <OSSemPost>
    
    return 0;
81149f84:	0005883a 	mov	r2,zero

}
81149f88:	e037883a 	mov	sp,fp
81149f8c:	dfc00117 	ldw	ra,4(sp)
81149f90:	df000017 	ldw	fp,0(sp)
81149f94:	dec00204 	addi	sp,sp,8
81149f98:	f800283a 	ret

81149f9c <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
81149f9c:	defff804 	addi	sp,sp,-32
81149fa0:	de00012e 	bgeu	sp,et,81149fa8 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
81149fa4:	003b68fa 	trap	3
81149fa8:	dfc00715 	stw	ra,28(sp)
81149fac:	df000615 	stw	fp,24(sp)
81149fb0:	df000604 	addi	fp,sp,24
81149fb4:	e13ffc15 	stw	r4,-16(fp)
81149fb8:	e17ffd15 	stw	r5,-12(fp)
81149fbc:	e1bffe15 	stw	r6,-8(fp)
81149fc0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
81149fc4:	e0800217 	ldw	r2,8(fp)
81149fc8:	d8800115 	stw	r2,4(sp)
81149fcc:	e0bfff17 	ldw	r2,-4(fp)
81149fd0:	d8800015 	stw	r2,0(sp)
81149fd4:	e1fffe17 	ldw	r7,-8(fp)
81149fd8:	000d883a 	mov	r6,zero
81149fdc:	e17ffd17 	ldw	r5,-12(fp)
81149fe0:	e13ffc17 	ldw	r4,-16(fp)
81149fe4:	11496640 	call	81149664 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81149fe8:	e037883a 	mov	sp,fp
81149fec:	dfc00117 	ldw	ra,4(sp)
81149ff0:	df000017 	ldw	fp,0(sp)
81149ff4:	dec00204 	addi	sp,sp,8
81149ff8:	f800283a 	ret

81149ffc <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
81149ffc:	defff804 	addi	sp,sp,-32
8114a000:	de00012e 	bgeu	sp,et,8114a008 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
8114a004:	003b68fa 	trap	3
8114a008:	dfc00715 	stw	ra,28(sp)
8114a00c:	df000615 	stw	fp,24(sp)
8114a010:	df000604 	addi	fp,sp,24
8114a014:	e13ffc15 	stw	r4,-16(fp)
8114a018:	e17ffd15 	stw	r5,-12(fp)
8114a01c:	e1bffe15 	stw	r6,-8(fp)
8114a020:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
8114a024:	e0800217 	ldw	r2,8(fp)
8114a028:	d8800115 	stw	r2,4(sp)
8114a02c:	e0bfff17 	ldw	r2,-4(fp)
8114a030:	d8800015 	stw	r2,0(sp)
8114a034:	000f883a 	mov	r7,zero
8114a038:	e1bffe17 	ldw	r6,-8(fp)
8114a03c:	e17ffd17 	ldw	r5,-12(fp)
8114a040:	e13ffc17 	ldw	r4,-16(fp)
8114a044:	11496640 	call	81149664 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
8114a048:	e037883a 	mov	sp,fp
8114a04c:	dfc00117 	ldw	ra,4(sp)
8114a050:	df000017 	ldw	fp,0(sp)
8114a054:	dec00204 	addi	sp,sp,8
8114a058:	f800283a 	ret

8114a05c <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114a05c:	defff804 	addi	sp,sp,-32
8114a060:	de00012e 	bgeu	sp,et,8114a068 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
8114a064:	003b68fa 	trap	3
8114a068:	dfc00715 	stw	ra,28(sp)
8114a06c:	df000615 	stw	fp,24(sp)
8114a070:	df000604 	addi	fp,sp,24
8114a074:	e13ffc15 	stw	r4,-16(fp)
8114a078:	e17ffd15 	stw	r5,-12(fp)
8114a07c:	e1bffe15 	stw	r6,-8(fp)
8114a080:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
8114a084:	e0800317 	ldw	r2,12(fp)
8114a088:	d8800115 	stw	r2,4(sp)
8114a08c:	e0800217 	ldw	r2,8(fp)
8114a090:	d8800015 	stw	r2,0(sp)
8114a094:	e1ffff17 	ldw	r7,-4(fp)
8114a098:	e1bffe17 	ldw	r6,-8(fp)
8114a09c:	e17ffd17 	ldw	r5,-12(fp)
8114a0a0:	e13ffc17 	ldw	r4,-16(fp)
8114a0a4:	11496640 	call	81149664 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8114a0a8:	e037883a 	mov	sp,fp
8114a0ac:	dfc00117 	ldw	ra,4(sp)
8114a0b0:	df000017 	ldw	fp,0(sp)
8114a0b4:	dec00204 	addi	sp,sp,8
8114a0b8:	f800283a 	ret

8114a0bc <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
8114a0bc:	defff004 	addi	sp,sp,-64
8114a0c0:	de00012e 	bgeu	sp,et,8114a0c8 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
8114a0c4:	003b68fa 	trap	3
8114a0c8:	dfc00f15 	stw	ra,60(sp)
8114a0cc:	df000e15 	stw	fp,56(sp)
8114a0d0:	df000e04 	addi	fp,sp,56
8114a0d4:	e13ff915 	stw	r4,-28(fp)
8114a0d8:	e17ffa15 	stw	r5,-24(fp)
8114a0dc:	e1bffb15 	stw	r6,-20(fp)
8114a0e0:	e1fffc15 	stw	r7,-16(fp)
8114a0e4:	e1000317 	ldw	r4,12(fp)
8114a0e8:	e0c00417 	ldw	r3,16(fp)
8114a0ec:	e0800517 	ldw	r2,20(fp)
8114a0f0:	e13ffd0d 	sth	r4,-12(fp)
8114a0f4:	e0fffe05 	stb	r3,-8(fp)
8114a0f8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8114a0fc:	e0bffd0b 	ldhu	r2,-12(fp)
8114a100:	e0fffe03 	ldbu	r3,-8(fp)
8114a104:	e13fff0b 	ldhu	r4,-4(fp)
8114a108:	d9000615 	stw	r4,24(sp)
8114a10c:	d8000515 	stw	zero,20(sp)
8114a110:	d8c00415 	stw	r3,16(sp)
8114a114:	d8000315 	stw	zero,12(sp)
8114a118:	d8800215 	stw	r2,8(sp)
8114a11c:	e0800217 	ldw	r2,8(fp)
8114a120:	d8800115 	stw	r2,4(sp)
8114a124:	e0bffc17 	ldw	r2,-16(fp)
8114a128:	d8800015 	stw	r2,0(sp)
8114a12c:	e1fffb17 	ldw	r7,-20(fp)
8114a130:	000d883a 	mov	r6,zero
8114a134:	e17ffa17 	ldw	r5,-24(fp)
8114a138:	e13ff917 	ldw	r4,-28(fp)
8114a13c:	11496f80 	call	811496f8 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
8114a140:	e037883a 	mov	sp,fp
8114a144:	dfc00117 	ldw	ra,4(sp)
8114a148:	df000017 	ldw	fp,0(sp)
8114a14c:	dec00204 	addi	sp,sp,8
8114a150:	f800283a 	ret

8114a154 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8114a154:	defff004 	addi	sp,sp,-64
8114a158:	de00012e 	bgeu	sp,et,8114a160 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
8114a15c:	003b68fa 	trap	3
8114a160:	dfc00f15 	stw	ra,60(sp)
8114a164:	df000e15 	stw	fp,56(sp)
8114a168:	df000e04 	addi	fp,sp,56
8114a16c:	e13ff915 	stw	r4,-28(fp)
8114a170:	e17ffa15 	stw	r5,-24(fp)
8114a174:	e1bffb15 	stw	r6,-20(fp)
8114a178:	e1fffc15 	stw	r7,-16(fp)
8114a17c:	e1000317 	ldw	r4,12(fp)
8114a180:	e0c00417 	ldw	r3,16(fp)
8114a184:	e0800517 	ldw	r2,20(fp)
8114a188:	e13ffd0d 	sth	r4,-12(fp)
8114a18c:	e0fffe05 	stb	r3,-8(fp)
8114a190:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
8114a194:	e0bffd0b 	ldhu	r2,-12(fp)
8114a198:	e0fffe03 	ldbu	r3,-8(fp)
8114a19c:	e13fff0b 	ldhu	r4,-4(fp)
8114a1a0:	d8000615 	stw	zero,24(sp)
8114a1a4:	d9000515 	stw	r4,20(sp)
8114a1a8:	d8000415 	stw	zero,16(sp)
8114a1ac:	d8c00315 	stw	r3,12(sp)
8114a1b0:	d8800215 	stw	r2,8(sp)
8114a1b4:	e0800217 	ldw	r2,8(fp)
8114a1b8:	d8800115 	stw	r2,4(sp)
8114a1bc:	e0bffc17 	ldw	r2,-16(fp)
8114a1c0:	d8800015 	stw	r2,0(sp)
8114a1c4:	000f883a 	mov	r7,zero
8114a1c8:	e1bffb17 	ldw	r6,-20(fp)
8114a1cc:	e17ffa17 	ldw	r5,-24(fp)
8114a1d0:	e13ff917 	ldw	r4,-28(fp)
8114a1d4:	11496f80 	call	811496f8 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
8114a1d8:	e037883a 	mov	sp,fp
8114a1dc:	dfc00117 	ldw	ra,4(sp)
8114a1e0:	df000017 	ldw	fp,0(sp)
8114a1e4:	dec00204 	addi	sp,sp,8
8114a1e8:	f800283a 	ret

8114a1ec <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
8114a1ec:	deffee04 	addi	sp,sp,-72
8114a1f0:	de00012e 	bgeu	sp,et,8114a1f8 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
8114a1f4:	003b68fa 	trap	3
8114a1f8:	dfc01115 	stw	ra,68(sp)
8114a1fc:	df001015 	stw	fp,64(sp)
8114a200:	df001004 	addi	fp,sp,64
8114a204:	e13ff715 	stw	r4,-36(fp)
8114a208:	e17ff815 	stw	r5,-32(fp)
8114a20c:	e1bff915 	stw	r6,-28(fp)
8114a210:	e1fffa15 	stw	r7,-24(fp)
8114a214:	e1800417 	ldw	r6,16(fp)
8114a218:	e1400517 	ldw	r5,20(fp)
8114a21c:	e1000617 	ldw	r4,24(fp)
8114a220:	e0c00717 	ldw	r3,28(fp)
8114a224:	e0800817 	ldw	r2,32(fp)
8114a228:	e1bffb0d 	sth	r6,-20(fp)
8114a22c:	e17ffc05 	stb	r5,-16(fp)
8114a230:	e13ffd05 	stb	r4,-12(fp)
8114a234:	e0fffe0d 	sth	r3,-8(fp)
8114a238:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8114a23c:	e0bffb0b 	ldhu	r2,-20(fp)
8114a240:	e0fffc03 	ldbu	r3,-16(fp)
8114a244:	e13ffd03 	ldbu	r4,-12(fp)
8114a248:	e17ffe0b 	ldhu	r5,-8(fp)
8114a24c:	e1bfff0b 	ldhu	r6,-4(fp)
8114a250:	d9800615 	stw	r6,24(sp)
8114a254:	d9400515 	stw	r5,20(sp)
8114a258:	d9000415 	stw	r4,16(sp)
8114a25c:	d8c00315 	stw	r3,12(sp)
8114a260:	d8800215 	stw	r2,8(sp)
8114a264:	e0800317 	ldw	r2,12(fp)
8114a268:	d8800115 	stw	r2,4(sp)
8114a26c:	e0800217 	ldw	r2,8(fp)
8114a270:	d8800015 	stw	r2,0(sp)
8114a274:	e1fffa17 	ldw	r7,-24(fp)
8114a278:	e1bff917 	ldw	r6,-28(fp)
8114a27c:	e17ff817 	ldw	r5,-32(fp)
8114a280:	e13ff717 	ldw	r4,-36(fp)
8114a284:	11496f80 	call	811496f8 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
8114a288:	e037883a 	mov	sp,fp
8114a28c:	dfc00117 	ldw	ra,4(sp)
8114a290:	df000017 	ldw	fp,0(sp)
8114a294:	dec00204 	addi	sp,sp,8
8114a298:	f800283a 	ret

8114a29c <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114a29c:	defffb04 	addi	sp,sp,-20
8114a2a0:	de00012e 	bgeu	sp,et,8114a2a8 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
8114a2a4:	003b68fa 	trap	3
8114a2a8:	df000415 	stw	fp,16(sp)
8114a2ac:	df000404 	addi	fp,sp,16
8114a2b0:	e13ffc15 	stw	r4,-16(fp)
8114a2b4:	e17ffd15 	stw	r5,-12(fp)
8114a2b8:	e1bffe15 	stw	r6,-8(fp)
8114a2bc:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
8114a2c0:	e0bffc17 	ldw	r2,-16(fp)
8114a2c4:	10c01217 	ldw	r3,72(r2)
8114a2c8:	e0800117 	ldw	r2,4(fp)
8114a2cc:	18800436 	bltu	r3,r2,8114a2e0 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
8114a2d0:	e0bffc17 	ldw	r2,-16(fp)
8114a2d4:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
8114a2d8:	10803fcc 	andi	r2,r2,255
8114a2dc:	10000226 	beq	r2,zero,8114a2e8 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8114a2e0:	00bffa84 	movi	r2,-22
8114a2e4:	00001406 	br	8114a338 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
8114a2e8:	e0bffd17 	ldw	r2,-12(fp)
8114a2ec:	e0fffe17 	ldw	r3,-8(fp)
8114a2f0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
8114a2f4:	e0bffd17 	ldw	r2,-12(fp)
8114a2f8:	e0ffff17 	ldw	r3,-4(fp)
8114a2fc:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114a300:	e0bffd17 	ldw	r2,-12(fp)
8114a304:	e0c00117 	ldw	r3,4(fp)
8114a308:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
8114a30c:	e0fffd17 	ldw	r3,-12(fp)
8114a310:	e0bffd17 	ldw	r2,-12(fp)
8114a314:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114a318:	e0c00217 	ldw	r3,8(fp)
8114a31c:	00900034 	movhi	r2,16384
8114a320:	10bfffc4 	addi	r2,r2,-1
8114a324:	1884703a 	and	r2,r3,r2
8114a328:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
8114a32c:	e0bffd17 	ldw	r2,-12(fp)
8114a330:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
8114a334:	0005883a 	mov	r2,zero
}
8114a338:	e037883a 	mov	sp,fp
8114a33c:	df000017 	ldw	fp,0(sp)
8114a340:	dec00104 	addi	sp,sp,4
8114a344:	f800283a 	ret

8114a348 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8114a348:	defff404 	addi	sp,sp,-48
8114a34c:	de00012e 	bgeu	sp,et,8114a354 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
8114a350:	003b68fa 	trap	3
8114a354:	df000b15 	stw	fp,44(sp)
8114a358:	df000b04 	addi	fp,sp,44
8114a35c:	e13ff715 	stw	r4,-36(fp)
8114a360:	e17ff815 	stw	r5,-32(fp)
8114a364:	e1bff915 	stw	r6,-28(fp)
8114a368:	e1fffa15 	stw	r7,-24(fp)
8114a36c:	e1800517 	ldw	r6,20(fp)
8114a370:	e1400617 	ldw	r5,24(fp)
8114a374:	e1000717 	ldw	r4,28(fp)
8114a378:	e0c00817 	ldw	r3,32(fp)
8114a37c:	e0800917 	ldw	r2,36(fp)
8114a380:	e1bffb0d 	sth	r6,-20(fp)
8114a384:	e17ffc05 	stb	r5,-16(fp)
8114a388:	e13ffd05 	stb	r4,-12(fp)
8114a38c:	e0fffe0d 	sth	r3,-8(fp)
8114a390:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8114a394:	e0bff717 	ldw	r2,-36(fp)
8114a398:	10c01217 	ldw	r3,72(r2)
8114a39c:	e0800317 	ldw	r2,12(fp)
8114a3a0:	18801936 	bltu	r3,r2,8114a408 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8114a3a4:	e13ff717 	ldw	r4,-36(fp)
8114a3a8:	20801317 	ldw	r2,76(r4)
8114a3ac:	20c01417 	ldw	r3,80(r4)
8114a3b0:	e13ffe0b 	ldhu	r4,-8(fp)
8114a3b4:	213fffcc 	andi	r4,r4,65535
8114a3b8:	2015883a 	mov	r10,r4
8114a3bc:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8114a3c0:	1ac01136 	bltu	r3,r11,8114a408 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8114a3c4:	58c0011e 	bne	r11,r3,8114a3cc <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
8114a3c8:	12800f36 	bltu	r2,r10,8114a408 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114a3cc:	e13ff717 	ldw	r4,-36(fp)
8114a3d0:	20801317 	ldw	r2,76(r4)
8114a3d4:	20c01417 	ldw	r3,80(r4)
8114a3d8:	e13fff0b 	ldhu	r4,-4(fp)
8114a3dc:	213fffcc 	andi	r4,r4,65535
8114a3e0:	2011883a 	mov	r8,r4
8114a3e4:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
8114a3e8:	1a400736 	bltu	r3,r9,8114a408 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8114a3ec:	48c0011e 	bne	r9,r3,8114a3f4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
8114a3f0:	12000536 	bltu	r2,r8,8114a408 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8114a3f4:	e0bff717 	ldw	r2,-36(fp)
8114a3f8:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114a3fc:	10803fcc 	andi	r2,r2,255
8114a400:	10800060 	cmpeqi	r2,r2,1
8114a404:	1000021e 	bne	r2,zero,8114a410 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
8114a408:	00bffa84 	movi	r2,-22
8114a40c:	00003106 	br	8114a4d4 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
8114a410:	e0bff817 	ldw	r2,-32(fp)
8114a414:	e0fff917 	ldw	r3,-28(fp)
8114a418:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
8114a41c:	e0bff817 	ldw	r2,-32(fp)
8114a420:	e0fffa17 	ldw	r3,-24(fp)
8114a424:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
8114a428:	e0bff817 	ldw	r2,-32(fp)
8114a42c:	e0c00117 	ldw	r3,4(fp)
8114a430:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
8114a434:	e0bff817 	ldw	r2,-32(fp)
8114a438:	e0c00217 	ldw	r3,8(fp)
8114a43c:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114a440:	e0bff817 	ldw	r2,-32(fp)
8114a444:	e0c00317 	ldw	r3,12(fp)
8114a448:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8114a44c:	e0bff817 	ldw	r2,-32(fp)
8114a450:	e0fffb0b 	ldhu	r3,-20(fp)
8114a454:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
8114a458:	e0bff817 	ldw	r2,-32(fp)
8114a45c:	e0fffc03 	ldbu	r3,-16(fp)
8114a460:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
8114a464:	e0bff817 	ldw	r2,-32(fp)
8114a468:	e0fffd03 	ldbu	r3,-12(fp)
8114a46c:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
8114a470:	e0bff817 	ldw	r2,-32(fp)
8114a474:	e0fffe0b 	ldhu	r3,-8(fp)
8114a478:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
8114a47c:	e0bff817 	ldw	r2,-32(fp)
8114a480:	e0ffff0b 	ldhu	r3,-4(fp)
8114a484:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
8114a488:	e0bff817 	ldw	r2,-32(fp)
8114a48c:	1019883a 	mov	r12,r2
8114a490:	001b883a 	mov	r13,zero
8114a494:	e33ff515 	stw	r12,-44(fp)
8114a498:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
8114a49c:	e0fff517 	ldw	r3,-44(fp)
8114a4a0:	e0bff817 	ldw	r2,-32(fp)
8114a4a4:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
8114a4a8:	e0fff617 	ldw	r3,-40(fp)
8114a4ac:	e0bff817 	ldw	r2,-32(fp)
8114a4b0:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114a4b4:	e0c00417 	ldw	r3,16(fp)
8114a4b8:	00900034 	movhi	r2,16384
8114a4bc:	10bfffc4 	addi	r2,r2,-1
8114a4c0:	1884703a 	and	r2,r3,r2
8114a4c4:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
8114a4c8:	e0bff817 	ldw	r2,-32(fp)
8114a4cc:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
8114a4d0:	0005883a 	mov	r2,zero
}
8114a4d4:	e037883a 	mov	sp,fp
8114a4d8:	df000017 	ldw	fp,0(sp)
8114a4dc:	dec00104 	addi	sp,sp,4
8114a4e0:	f800283a 	ret

8114a4e4 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
8114a4e4:	defff804 	addi	sp,sp,-32
8114a4e8:	de00012e 	bgeu	sp,et,8114a4f0 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
8114a4ec:	003b68fa 	trap	3
8114a4f0:	dfc00715 	stw	ra,28(sp)
8114a4f4:	df000615 	stw	fp,24(sp)
8114a4f8:	df000604 	addi	fp,sp,24
8114a4fc:	e13ffc15 	stw	r4,-16(fp)
8114a500:	e17ffd15 	stw	r5,-12(fp)
8114a504:	e1bffe15 	stw	r6,-8(fp)
8114a508:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114a50c:	e0800317 	ldw	r2,12(fp)
8114a510:	d8800115 	stw	r2,4(sp)
8114a514:	e0800217 	ldw	r2,8(fp)
8114a518:	d8800015 	stw	r2,0(sp)
8114a51c:	e1ffff17 	ldw	r7,-4(fp)
8114a520:	e1bffe17 	ldw	r6,-8(fp)
8114a524:	e17ffd17 	ldw	r5,-12(fp)
8114a528:	e13ffc17 	ldw	r4,-16(fp)
8114a52c:	114a29c0 	call	8114a29c <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
8114a530:	e037883a 	mov	sp,fp
8114a534:	dfc00117 	ldw	ra,4(sp)
8114a538:	df000017 	ldw	fp,0(sp)
8114a53c:	dec00204 	addi	sp,sp,8
8114a540:	f800283a 	ret

8114a544 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114a544:	defff804 	addi	sp,sp,-32
8114a548:	de00012e 	bgeu	sp,et,8114a550 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
8114a54c:	003b68fa 	trap	3
8114a550:	dfc00715 	stw	ra,28(sp)
8114a554:	df000615 	stw	fp,24(sp)
8114a558:	df000604 	addi	fp,sp,24
8114a55c:	e13ffc15 	stw	r4,-16(fp)
8114a560:	e17ffd15 	stw	r5,-12(fp)
8114a564:	e1bffe15 	stw	r6,-8(fp)
8114a568:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114a56c:	e0800217 	ldw	r2,8(fp)
8114a570:	d8800115 	stw	r2,4(sp)
8114a574:	e0bfff17 	ldw	r2,-4(fp)
8114a578:	d8800015 	stw	r2,0(sp)
8114a57c:	e1fffe17 	ldw	r7,-8(fp)
8114a580:	000d883a 	mov	r6,zero
8114a584:	e17ffd17 	ldw	r5,-12(fp)
8114a588:	e13ffc17 	ldw	r4,-16(fp)
8114a58c:	114a29c0 	call	8114a29c <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
8114a590:	e037883a 	mov	sp,fp
8114a594:	dfc00117 	ldw	ra,4(sp)
8114a598:	df000017 	ldw	fp,0(sp)
8114a59c:	dec00204 	addi	sp,sp,8
8114a5a0:	f800283a 	ret

8114a5a4 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114a5a4:	defff804 	addi	sp,sp,-32
8114a5a8:	de00012e 	bgeu	sp,et,8114a5b0 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
8114a5ac:	003b68fa 	trap	3
8114a5b0:	dfc00715 	stw	ra,28(sp)
8114a5b4:	df000615 	stw	fp,24(sp)
8114a5b8:	df000604 	addi	fp,sp,24
8114a5bc:	e13ffc15 	stw	r4,-16(fp)
8114a5c0:	e17ffd15 	stw	r5,-12(fp)
8114a5c4:	e1bffe15 	stw	r6,-8(fp)
8114a5c8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114a5cc:	e0800217 	ldw	r2,8(fp)
8114a5d0:	d8800115 	stw	r2,4(sp)
8114a5d4:	e0bfff17 	ldw	r2,-4(fp)
8114a5d8:	d8800015 	stw	r2,0(sp)
8114a5dc:	000f883a 	mov	r7,zero
8114a5e0:	e1bffe17 	ldw	r6,-8(fp)
8114a5e4:	e17ffd17 	ldw	r5,-12(fp)
8114a5e8:	e13ffc17 	ldw	r4,-16(fp)
8114a5ec:	114a29c0 	call	8114a29c <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
8114a5f0:	e037883a 	mov	sp,fp
8114a5f4:	dfc00117 	ldw	ra,4(sp)
8114a5f8:	df000017 	ldw	fp,0(sp)
8114a5fc:	dec00204 	addi	sp,sp,8
8114a600:	f800283a 	ret

8114a604 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
8114a604:	deffee04 	addi	sp,sp,-72
8114a608:	de00012e 	bgeu	sp,et,8114a610 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
8114a60c:	003b68fa 	trap	3
8114a610:	dfc01115 	stw	ra,68(sp)
8114a614:	df001015 	stw	fp,64(sp)
8114a618:	df001004 	addi	fp,sp,64
8114a61c:	e13ff915 	stw	r4,-28(fp)
8114a620:	e17ffa15 	stw	r5,-24(fp)
8114a624:	e1bffb15 	stw	r6,-20(fp)
8114a628:	e1fffc15 	stw	r7,-16(fp)
8114a62c:	e1000417 	ldw	r4,16(fp)
8114a630:	e0c00517 	ldw	r3,20(fp)
8114a634:	e0800617 	ldw	r2,24(fp)
8114a638:	e13ffd0d 	sth	r4,-12(fp)
8114a63c:	e0fffe05 	stb	r3,-8(fp)
8114a640:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
8114a644:	e0bffd0b 	ldhu	r2,-12(fp)
8114a648:	e0fffe03 	ldbu	r3,-8(fp)
8114a64c:	e13fff0b 	ldhu	r4,-4(fp)
8114a650:	d9000815 	stw	r4,32(sp)
8114a654:	d8000715 	stw	zero,28(sp)
8114a658:	d8c00615 	stw	r3,24(sp)
8114a65c:	d8000515 	stw	zero,20(sp)
8114a660:	d8800415 	stw	r2,16(sp)
8114a664:	e0800317 	ldw	r2,12(fp)
8114a668:	d8800315 	stw	r2,12(sp)
8114a66c:	e0800217 	ldw	r2,8(fp)
8114a670:	d8800215 	stw	r2,8(sp)
8114a674:	e0bffc17 	ldw	r2,-16(fp)
8114a678:	d8800115 	stw	r2,4(sp)
8114a67c:	e0bffb17 	ldw	r2,-20(fp)
8114a680:	d8800015 	stw	r2,0(sp)
8114a684:	000f883a 	mov	r7,zero
8114a688:	000d883a 	mov	r6,zero
8114a68c:	e17ffa17 	ldw	r5,-24(fp)
8114a690:	e13ff917 	ldw	r4,-28(fp)
8114a694:	114a3480 	call	8114a348 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
8114a698:	e037883a 	mov	sp,fp
8114a69c:	dfc00117 	ldw	ra,4(sp)
8114a6a0:	df000017 	ldw	fp,0(sp)
8114a6a4:	dec00204 	addi	sp,sp,8
8114a6a8:	f800283a 	ret

8114a6ac <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8114a6ac:	deffee04 	addi	sp,sp,-72
8114a6b0:	de00012e 	bgeu	sp,et,8114a6b8 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
8114a6b4:	003b68fa 	trap	3
8114a6b8:	dfc01115 	stw	ra,68(sp)
8114a6bc:	df001015 	stw	fp,64(sp)
8114a6c0:	df001004 	addi	fp,sp,64
8114a6c4:	e13ff915 	stw	r4,-28(fp)
8114a6c8:	e17ffa15 	stw	r5,-24(fp)
8114a6cc:	e1bffb15 	stw	r6,-20(fp)
8114a6d0:	e1fffc15 	stw	r7,-16(fp)
8114a6d4:	e1000417 	ldw	r4,16(fp)
8114a6d8:	e0c00517 	ldw	r3,20(fp)
8114a6dc:	e0800617 	ldw	r2,24(fp)
8114a6e0:	e13ffd0d 	sth	r4,-12(fp)
8114a6e4:	e0fffe05 	stb	r3,-8(fp)
8114a6e8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8114a6ec:	e0bffd0b 	ldhu	r2,-12(fp)
8114a6f0:	e0fffe03 	ldbu	r3,-8(fp)
8114a6f4:	e13fff0b 	ldhu	r4,-4(fp)
8114a6f8:	d8000815 	stw	zero,32(sp)
8114a6fc:	d9000715 	stw	r4,28(sp)
8114a700:	d8000615 	stw	zero,24(sp)
8114a704:	d8c00515 	stw	r3,20(sp)
8114a708:	d8800415 	stw	r2,16(sp)
8114a70c:	e0800317 	ldw	r2,12(fp)
8114a710:	d8800315 	stw	r2,12(sp)
8114a714:	e0800217 	ldw	r2,8(fp)
8114a718:	d8800215 	stw	r2,8(sp)
8114a71c:	d8000115 	stw	zero,4(sp)
8114a720:	d8000015 	stw	zero,0(sp)
8114a724:	e1fffc17 	ldw	r7,-16(fp)
8114a728:	e1bffb17 	ldw	r6,-20(fp)
8114a72c:	e17ffa17 	ldw	r5,-24(fp)
8114a730:	e13ff917 	ldw	r4,-28(fp)
8114a734:	114a3480 	call	8114a348 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
8114a738:	e037883a 	mov	sp,fp
8114a73c:	dfc00117 	ldw	ra,4(sp)
8114a740:	df000017 	ldw	fp,0(sp)
8114a744:	dec00204 	addi	sp,sp,8
8114a748:	f800283a 	ret

8114a74c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8114a74c:	deffec04 	addi	sp,sp,-80
8114a750:	de00012e 	bgeu	sp,et,8114a758 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
8114a754:	003b68fa 	trap	3
8114a758:	dfc01315 	stw	ra,76(sp)
8114a75c:	df001215 	stw	fp,72(sp)
8114a760:	df001204 	addi	fp,sp,72
8114a764:	e13ff715 	stw	r4,-36(fp)
8114a768:	e17ff815 	stw	r5,-32(fp)
8114a76c:	e1bff915 	stw	r6,-28(fp)
8114a770:	e1fffa15 	stw	r7,-24(fp)
8114a774:	e1800617 	ldw	r6,24(fp)
8114a778:	e1400717 	ldw	r5,28(fp)
8114a77c:	e1000817 	ldw	r4,32(fp)
8114a780:	e0c00917 	ldw	r3,36(fp)
8114a784:	e0800a17 	ldw	r2,40(fp)
8114a788:	e1bffb0d 	sth	r6,-20(fp)
8114a78c:	e17ffc05 	stb	r5,-16(fp)
8114a790:	e13ffd05 	stb	r4,-12(fp)
8114a794:	e0fffe0d 	sth	r3,-8(fp)
8114a798:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8114a79c:	e0bffb0b 	ldhu	r2,-20(fp)
8114a7a0:	e0fffc03 	ldbu	r3,-16(fp)
8114a7a4:	e13ffd03 	ldbu	r4,-12(fp)
8114a7a8:	e17ffe0b 	ldhu	r5,-8(fp)
8114a7ac:	e1bfff0b 	ldhu	r6,-4(fp)
8114a7b0:	d9800815 	stw	r6,32(sp)
8114a7b4:	d9400715 	stw	r5,28(sp)
8114a7b8:	d9000615 	stw	r4,24(sp)
8114a7bc:	d8c00515 	stw	r3,20(sp)
8114a7c0:	d8800415 	stw	r2,16(sp)
8114a7c4:	e0800517 	ldw	r2,20(fp)
8114a7c8:	d8800315 	stw	r2,12(sp)
8114a7cc:	e0800417 	ldw	r2,16(fp)
8114a7d0:	d8800215 	stw	r2,8(sp)
8114a7d4:	e0800317 	ldw	r2,12(fp)
8114a7d8:	d8800115 	stw	r2,4(sp)
8114a7dc:	e0800217 	ldw	r2,8(fp)
8114a7e0:	d8800015 	stw	r2,0(sp)
8114a7e4:	e1fffa17 	ldw	r7,-24(fp)
8114a7e8:	e1bff917 	ldw	r6,-28(fp)
8114a7ec:	e17ff817 	ldw	r5,-32(fp)
8114a7f0:	e13ff717 	ldw	r4,-36(fp)
8114a7f4:	114a3480 	call	8114a348 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
8114a7f8:	e037883a 	mov	sp,fp
8114a7fc:	dfc00117 	ldw	ra,4(sp)
8114a800:	df000017 	ldw	fp,0(sp)
8114a804:	dec00204 	addi	sp,sp,8
8114a808:	f800283a 	ret

8114a80c <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
8114a80c:	defffc04 	addi	sp,sp,-16
8114a810:	de00012e 	bgeu	sp,et,8114a818 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
8114a814:	003b68fa 	trap	3
8114a818:	df000315 	stw	fp,12(sp)
8114a81c:	df000304 	addi	fp,sp,12
8114a820:	e13ffe15 	stw	r4,-8(fp)
8114a824:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
8114a828:	e0bfff17 	ldw	r2,-4(fp)
8114a82c:	1000021e 	bne	r2,zero,8114a838 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8114a830:	00bffa84 	movi	r2,-22
8114a834:	00002f06 	br	8114a8f4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
8114a838:	e0bfff17 	ldw	r2,-4(fp)
8114a83c:	10c00317 	ldw	r3,12(r2)
8114a840:	e0bfff17 	ldw	r2,-4(fp)
8114a844:	18800226 	beq	r3,r2,8114a850 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8114a848:	00bffa84 	movi	r2,-22
8114a84c:	00002906 	br	8114a8f4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
8114a850:	e0bffe17 	ldw	r2,-8(fp)
8114a854:	10800017 	ldw	r2,0(r2)
8114a858:	1000051e 	bne	r2,zero,8114a870 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
8114a85c:	e0bffe17 	ldw	r2,-8(fp)
8114a860:	e0ffff17 	ldw	r3,-4(fp)
8114a864:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
8114a868:	0005883a 	mov	r2,zero
8114a86c:	00002106 	br	8114a8f4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
8114a870:	e0bffe17 	ldw	r2,-8(fp)
8114a874:	10c00017 	ldw	r3,0(r2)
8114a878:	e0bfff17 	ldw	r2,-4(fp)
8114a87c:	1880021e 	bne	r3,r2,8114a888 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8114a880:	00bffa84 	movi	r2,-22
8114a884:	00001b06 	br	8114a8f4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8114a888:	e0bffe17 	ldw	r2,-8(fp)
8114a88c:	10800017 	ldw	r2,0(r2)
8114a890:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8114a894:	00000906 	br	8114a8bc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
8114a898:	e0bffd17 	ldw	r2,-12(fp)
8114a89c:	10c00317 	ldw	r3,12(r2)
8114a8a0:	e0bfff17 	ldw	r2,-4(fp)
8114a8a4:	1880021e 	bne	r3,r2,8114a8b0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8114a8a8:	00bffa84 	movi	r2,-22
8114a8ac:	00001106 	br	8114a8f4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8114a8b0:	e0bffd17 	ldw	r2,-12(fp)
8114a8b4:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
8114a8b8:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8114a8bc:	e0bffd17 	ldw	r2,-12(fp)
8114a8c0:	10800317 	ldw	r2,12(r2)
8114a8c4:	e0fffe17 	ldw	r3,-8(fp)
8114a8c8:	18c00017 	ldw	r3,0(r3)
8114a8cc:	10fff21e 	bne	r2,r3,8114a898 <__reset+0xfb12a898>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
8114a8d0:	e0ffff17 	ldw	r3,-4(fp)
8114a8d4:	e0bffd17 	ldw	r2,-12(fp)
8114a8d8:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
8114a8dc:	e0bffe17 	ldw	r2,-8(fp)
8114a8e0:	10800017 	ldw	r2,0(r2)
8114a8e4:	1007883a 	mov	r3,r2
8114a8e8:	e0bfff17 	ldw	r2,-4(fp)
8114a8ec:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
8114a8f0:	0005883a 	mov	r2,zero
}
8114a8f4:	e037883a 	mov	sp,fp
8114a8f8:	df000017 	ldw	fp,0(sp)
8114a8fc:	dec00104 	addi	sp,sp,4
8114a900:	f800283a 	ret

8114a904 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
8114a904:	defff804 	addi	sp,sp,-32
8114a908:	de00012e 	bgeu	sp,et,8114a910 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
8114a90c:	003b68fa 	trap	3
8114a910:	df000715 	stw	fp,28(sp)
8114a914:	df000704 	addi	fp,sp,28
8114a918:	e13ffe15 	stw	r4,-8(fp)
8114a91c:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
8114a920:	e13fff17 	ldw	r4,-4(fp)
8114a924:	2000021e 	bne	r4,zero,8114a930 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8114a928:	00bffa84 	movi	r2,-22
8114a92c:	00005906 	br	8114aa94 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
8114a930:	e13fff17 	ldw	r4,-4(fp)
8114a934:	2015883a 	mov	r10,r4
8114a938:	0017883a 	mov	r11,zero
8114a93c:	e2bffc15 	stw	r10,-16(fp)
8114a940:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114a944:	e13fff17 	ldw	r4,-4(fp)
8114a948:	21400317 	ldw	r5,12(r4)
8114a94c:	e13ffc17 	ldw	r4,-16(fp)
8114a950:	29000626 	beq	r5,r4,8114a96c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
8114a954:	e13fff17 	ldw	r4,-4(fp)
8114a958:	21400b17 	ldw	r5,44(r4)
8114a95c:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114a960:	29000226 	beq	r5,r4,8114a96c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8114a964:	00bffa84 	movi	r2,-22
8114a968:	00004a06 	br	8114aa94 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
8114a96c:	e13ffe17 	ldw	r4,-8(fp)
8114a970:	21000017 	ldw	r4,0(r4)
8114a974:	2000051e 	bne	r4,zero,8114a98c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
8114a978:	e0bffe17 	ldw	r2,-8(fp)
8114a97c:	e0ffff17 	ldw	r3,-4(fp)
8114a980:	10c00015 	stw	r3,0(r2)
		return 0;
8114a984:	0005883a 	mov	r2,zero
8114a988:	00004206 	br	8114aa94 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
8114a98c:	e13ffe17 	ldw	r4,-8(fp)
8114a990:	21400017 	ldw	r5,0(r4)
8114a994:	e13fff17 	ldw	r4,-4(fp)
8114a998:	2900021e 	bne	r5,r4,8114a9a4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8114a99c:	00bffa84 	movi	r2,-22
8114a9a0:	00003c06 	br	8114aa94 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8114a9a4:	e13ffe17 	ldw	r4,-8(fp)
8114a9a8:	21000017 	ldw	r4,0(r4)
8114a9ac:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
8114a9b0:	e13ffe17 	ldw	r4,-8(fp)
8114a9b4:	21000017 	ldw	r4,0(r4)
8114a9b8:	2011883a 	mov	r8,r4
8114a9bc:	0013883a 	mov	r9,zero
8114a9c0:	e23ffa15 	stw	r8,-24(fp)
8114a9c4:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114a9c8:	00001806 	br	8114aa2c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
8114a9cc:	e13fff17 	ldw	r4,-4(fp)
8114a9d0:	200d883a 	mov	r6,r4
8114a9d4:	000f883a 	mov	r7,zero
8114a9d8:	e1bffc15 	stw	r6,-16(fp)
8114a9dc:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
8114a9e0:	e13ff917 	ldw	r4,-28(fp)
8114a9e4:	21400317 	ldw	r5,12(r4)
8114a9e8:	e13ffc17 	ldw	r4,-16(fp)
8114a9ec:	2900061e 	bne	r5,r4,8114aa08 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
8114a9f0:	e13ff917 	ldw	r4,-28(fp)
8114a9f4:	21400b17 	ldw	r5,44(r4)
8114a9f8:	e13ffd17 	ldw	r4,-12(fp)
8114a9fc:	2900021e 	bne	r5,r4,8114aa08 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8114aa00:	00bffa84 	movi	r2,-22
8114aa04:	00002306 	br	8114aa94 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8114aa08:	e13ff917 	ldw	r4,-28(fp)
8114aa0c:	21000317 	ldw	r4,12(r4)
8114aa10:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8114aa14:	e13ff917 	ldw	r4,-28(fp)
8114aa18:	21000b17 	ldw	r4,44(r4)
8114aa1c:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8114aa20:	e13ffc17 	ldw	r4,-16(fp)
8114aa24:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8114aa28:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114aa2c:	e13ff917 	ldw	r4,-28(fp)
8114aa30:	21400317 	ldw	r5,12(r4)
8114aa34:	e13ffa17 	ldw	r4,-24(fp)
8114aa38:	29000426 	beq	r5,r4,8114aa4c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114aa3c:	e13ff917 	ldw	r4,-28(fp)
8114aa40:	21400b17 	ldw	r5,44(r4)
8114aa44:	e13ffb17 	ldw	r4,-20(fp)
8114aa48:	293fe01e 	bne	r5,r4,8114a9cc <__reset+0xfb12a9cc>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
8114aa4c:	e13fff17 	ldw	r4,-4(fp)
8114aa50:	2005883a 	mov	r2,r4
8114aa54:	0007883a 	mov	r3,zero
8114aa58:	e0bffc15 	stw	r2,-16(fp)
8114aa5c:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
8114aa60:	e0fffc17 	ldw	r3,-16(fp)
8114aa64:	e0bff917 	ldw	r2,-28(fp)
8114aa68:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
8114aa6c:	e0fffd17 	ldw	r3,-12(fp)
8114aa70:	e0bff917 	ldw	r2,-28(fp)
8114aa74:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
8114aa78:	e0fffa17 	ldw	r3,-24(fp)
8114aa7c:	e0bfff17 	ldw	r2,-4(fp)
8114aa80:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
8114aa84:	e0fffb17 	ldw	r3,-20(fp)
8114aa88:	e0bfff17 	ldw	r2,-4(fp)
8114aa8c:	10c00b15 	stw	r3,44(r2)
	return 0;
8114aa90:	0005883a 	mov	r2,zero
}
8114aa94:	e037883a 	mov	sp,fp
8114aa98:	df000017 	ldw	fp,0(sp)
8114aa9c:	dec00104 	addi	sp,sp,4
8114aaa0:	f800283a 	ret

8114aaa4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
8114aaa4:	defffc04 	addi	sp,sp,-16
8114aaa8:	de00012e 	bgeu	sp,et,8114aab0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
8114aaac:	003b68fa 	trap	3
8114aab0:	df000315 	stw	fp,12(sp)
8114aab4:	df000304 	addi	fp,sp,12
8114aab8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8114aabc:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
8114aac0:	e0bfff17 	ldw	r2,-4(fp)
8114aac4:	1000021e 	bne	r2,zero,8114aad0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8114aac8:	00bffa84 	movi	r2,-22
8114aacc:	00001906 	br	8114ab34 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114aad0:	e0bfff17 	ldw	r2,-4(fp)
8114aad4:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8114aad8:	00000a06 	br	8114ab04 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
8114aadc:	e0bffd17 	ldw	r2,-12(fp)
8114aae0:	10800717 	ldw	r2,28(r2)
8114aae4:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114aae8:	e0bffe17 	ldw	r2,-8(fp)
8114aaec:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8114aaf0:	e0bffd17 	ldw	r2,-12(fp)
8114aaf4:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8114aaf8:	e0bffd17 	ldw	r2,-12(fp)
8114aafc:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
8114ab00:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8114ab04:	e0bffd17 	ldw	r2,-12(fp)
8114ab08:	10c00317 	ldw	r3,12(r2)
8114ab0c:	e0bfff17 	ldw	r2,-4(fp)
8114ab10:	18bff21e 	bne	r3,r2,8114aadc <__reset+0xfb12aadc>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
8114ab14:	e0bffd17 	ldw	r2,-12(fp)
8114ab18:	10800717 	ldw	r2,28(r2)
8114ab1c:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114ab20:	e0bffe17 	ldw	r2,-8(fp)
8114ab24:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8114ab28:	e0bffd17 	ldw	r2,-12(fp)
8114ab2c:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
8114ab30:	0005883a 	mov	r2,zero
}
8114ab34:	e037883a 	mov	sp,fp
8114ab38:	df000017 	ldw	fp,0(sp)
8114ab3c:	dec00104 	addi	sp,sp,4
8114ab40:	f800283a 	ret

8114ab44 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
8114ab44:	defff804 	addi	sp,sp,-32
8114ab48:	de00012e 	bgeu	sp,et,8114ab50 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
8114ab4c:	003b68fa 	trap	3
8114ab50:	df000715 	stw	fp,28(sp)
8114ab54:	df000704 	addi	fp,sp,28
8114ab58:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8114ab5c:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
8114ab60:	e13fff17 	ldw	r4,-4(fp)
8114ab64:	2000021e 	bne	r4,zero,8114ab70 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8114ab68:	00bffa84 	movi	r2,-22
8114ab6c:	00002806 	br	8114ac10 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114ab70:	e13fff17 	ldw	r4,-4(fp)
8114ab74:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
8114ab78:	e13fff17 	ldw	r4,-4(fp)
8114ab7c:	2005883a 	mov	r2,r4
8114ab80:	0007883a 	mov	r3,zero
8114ab84:	e0bffb15 	stw	r2,-20(fp)
8114ab88:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114ab8c:	00001006 	br	8114abd0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
8114ab90:	e0bff917 	ldw	r2,-28(fp)
8114ab94:	10800f17 	ldw	r2,60(r2)
8114ab98:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114ab9c:	e0bffa17 	ldw	r2,-24(fp)
8114aba0:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8114aba4:	e0bff917 	ldw	r2,-28(fp)
8114aba8:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8114abac:	e0bff917 	ldw	r2,-28(fp)
8114abb0:	10800317 	ldw	r2,12(r2)
8114abb4:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8114abb8:	e0bff917 	ldw	r2,-28(fp)
8114abbc:	10800b17 	ldw	r2,44(r2)
8114abc0:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8114abc4:	e0bffd17 	ldw	r2,-12(fp)
8114abc8:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8114abcc:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114abd0:	e0bff917 	ldw	r2,-28(fp)
8114abd4:	10c00317 	ldw	r3,12(r2)
8114abd8:	e0bffb17 	ldw	r2,-20(fp)
8114abdc:	18800426 	beq	r3,r2,8114abf0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114abe0:	e0bff917 	ldw	r2,-28(fp)
8114abe4:	10c00b17 	ldw	r3,44(r2)
8114abe8:	e0bffc17 	ldw	r2,-16(fp)
8114abec:	18bfe81e 	bne	r3,r2,8114ab90 <__reset+0xfb12ab90>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
8114abf0:	e0bff917 	ldw	r2,-28(fp)
8114abf4:	10800f17 	ldw	r2,60(r2)
8114abf8:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114abfc:	e0bffa17 	ldw	r2,-24(fp)
8114ac00:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8114ac04:	e0bff917 	ldw	r2,-28(fp)
8114ac08:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
8114ac0c:	0005883a 	mov	r2,zero
}
8114ac10:	e037883a 	mov	sp,fp
8114ac14:	df000017 	ldw	fp,0(sp)
8114ac18:	dec00104 	addi	sp,sp,4
8114ac1c:	f800283a 	ret

8114ac20 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8114ac20:	deffeb04 	addi	sp,sp,-84
8114ac24:	de00012e 	bgeu	sp,et,8114ac2c <alt_msgdma_start_prefetcher_with_list_addr+0xc>
8114ac28:	003b68fa 	trap	3
8114ac2c:	dfc01415 	stw	ra,80(sp)
8114ac30:	df001315 	stw	fp,76(sp)
8114ac34:	df001304 	addi	fp,sp,76
8114ac38:	e13ffb15 	stw	r4,-20(fp)
8114ac3c:	e17ffc15 	stw	r5,-16(fp)
8114ac40:	e1bffd15 	stw	r6,-12(fp)
8114ac44:	3807883a 	mov	r3,r7
8114ac48:	e0800217 	ldw	r2,8(fp)
8114ac4c:	e0fffe05 	stb	r3,-8(fp)
8114ac50:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
8114ac54:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
8114ac58:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
8114ac5c:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
8114ac60:	e0bffc17 	ldw	r2,-16(fp)
8114ac64:	e0bff815 	stw	r2,-32(fp)
8114ac68:	e0bffd17 	ldw	r2,-12(fp)
8114ac6c:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
8114ac70:	e0bffb17 	ldw	r2,-20(fp)
8114ac74:	10801817 	ldw	r2,96(r2)
8114ac78:	e0bff615 	stw	r2,-40(fp)
8114ac7c:	e03ff70d 	sth	zero,-36(fp)
8114ac80:	e0bff70b 	ldhu	r2,-36(fp)
8114ac84:	e0fffa04 	addi	r3,fp,-24
8114ac88:	180d883a 	mov	r6,r3
8114ac8c:	100b883a 	mov	r5,r2
8114ac90:	e13ff617 	ldw	r4,-40(fp)
8114ac94:	113fdcc0 	call	8113fdcc <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
8114ac98:	e0bffb17 	ldw	r2,-20(fp)
8114ac9c:	10800617 	ldw	r2,24(r2)
8114aca0:	10800037 	ldwio	r2,0(r2)
8114aca4:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
8114aca8:	e0bfed17 	ldw	r2,-76(fp)
8114acac:	1080004c 	andi	r2,r2,1
8114acb0:	10000626 	beq	r2,zero,8114accc <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
8114acb4:	e0bffb17 	ldw	r2,-20(fp)
8114acb8:	10801817 	ldw	r2,96(r2)
8114acbc:	1009883a 	mov	r4,r2
8114acc0:	11401540 	call	81140154 <OSSemPost>
		return -EBUSY;
8114acc4:	00bffc04 	movi	r2,-16
8114acc8:	00009606 	br	8114af24 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114accc:	00800804 	movi	r2,32
8114acd0:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114acd4:	0005303a 	rdctl	r2,status
8114acd8:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114acdc:	e0fff217 	ldw	r3,-56(fp)
8114ace0:	00bfff84 	movi	r2,-2
8114ace4:	1884703a 	and	r2,r3,r2
8114ace8:	1001703a 	wrctl	status,r2
  
  return context;
8114acec:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8114acf0:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114acf4:	e0bffb17 	ldw	r2,-20(fp)
8114acf8:	10800317 	ldw	r2,12(r2)
8114acfc:	10800104 	addi	r2,r2,4
8114ad00:	e0ffee17 	ldw	r3,-72(fp)
8114ad04:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
8114ad08:	e0bffb17 	ldw	r2,-20(fp)
8114ad0c:	10800317 	ldw	r2,12(r2)
8114ad10:	e0fffb17 	ldw	r3,-20(fp)
8114ad14:	18c00317 	ldw	r3,12(r3)
8114ad18:	18c00037 	ldwio	r3,0(r3)
8114ad1c:	10c00035 	stwio	r3,0(r2)
8114ad20:	e0bfef17 	ldw	r2,-68(fp)
8114ad24:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114ad28:	e0bff017 	ldw	r2,-64(fp)
8114ad2c:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
8114ad30:	e0bffb17 	ldw	r2,-20(fp)
8114ad34:	10800b17 	ldw	r2,44(r2)
8114ad38:	10002326 	beq	r2,zero,8114adc8 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
8114ad3c:	e0bffb17 	ldw	r2,-20(fp)
8114ad40:	10c00d17 	ldw	r3,52(r2)
8114ad44:	e0bfee17 	ldw	r2,-72(fp)
8114ad48:	1884b03a 	or	r2,r3,r2
8114ad4c:	10800514 	ori	r2,r2,20
8114ad50:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8114ad54:	e0ffee17 	ldw	r3,-72(fp)
8114ad58:	00bff7c4 	movi	r2,-33
8114ad5c:	1884703a 	and	r2,r3,r2
8114ad60:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8114ad64:	e0bfed17 	ldw	r2,-76(fp)
8114ad68:	10800214 	ori	r2,r2,8
8114ad6c:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114ad70:	0005303a 	rdctl	r2,status
8114ad74:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114ad78:	e0fff417 	ldw	r3,-48(fp)
8114ad7c:	00bfff84 	movi	r2,-2
8114ad80:	1884703a 	and	r2,r3,r2
8114ad84:	1001703a 	wrctl	status,r2
  
  return context;
8114ad88:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
8114ad8c:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114ad90:	e0bffb17 	ldw	r2,-20(fp)
8114ad94:	10800317 	ldw	r2,12(r2)
8114ad98:	10800104 	addi	r2,r2,4
8114ad9c:	e0ffee17 	ldw	r3,-72(fp)
8114ada0:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114ada4:	e0bffb17 	ldw	r2,-20(fp)
8114ada8:	10800617 	ldw	r2,24(r2)
8114adac:	e0ffed17 	ldw	r3,-76(fp)
8114adb0:	10c00035 	stwio	r3,0(r2)
8114adb4:	e0bfef17 	ldw	r2,-68(fp)
8114adb8:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114adbc:	e0bff117 	ldw	r2,-60(fp)
8114adc0:	1001703a 	wrctl	status,r2
8114adc4:	00002306 	br	8114ae54 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
8114adc8:	e0bffb17 	ldw	r2,-20(fp)
8114adcc:	10c00d17 	ldw	r3,52(r2)
8114add0:	e0bfee17 	ldw	r2,-72(fp)
8114add4:	1884b03a 	or	r2,r3,r2
8114add8:	10800114 	ori	r2,r2,4
8114addc:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
8114ade0:	e0ffee17 	ldw	r3,-72(fp)
8114ade4:	00bff3c4 	movi	r2,-49
8114ade8:	1884703a 	and	r2,r3,r2
8114adec:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
8114adf0:	e0ffed17 	ldw	r3,-76(fp)
8114adf4:	00bffdc4 	movi	r2,-9
8114adf8:	1884703a 	and	r2,r3,r2
8114adfc:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114ae00:	0005303a 	rdctl	r2,status
8114ae04:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114ae08:	e0fff517 	ldw	r3,-44(fp)
8114ae0c:	00bfff84 	movi	r2,-2
8114ae10:	1884703a 	and	r2,r3,r2
8114ae14:	1001703a 	wrctl	status,r2
  
  return context;
8114ae18:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
8114ae1c:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114ae20:	e0bffb17 	ldw	r2,-20(fp)
8114ae24:	10800317 	ldw	r2,12(r2)
8114ae28:	10800104 	addi	r2,r2,4
8114ae2c:	e0ffee17 	ldw	r3,-72(fp)
8114ae30:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114ae34:	e0bffb17 	ldw	r2,-20(fp)
8114ae38:	10800617 	ldw	r2,24(r2)
8114ae3c:	e0ffed17 	ldw	r3,-76(fp)
8114ae40:	10c00035 	stwio	r3,0(r2)
8114ae44:	e0bfef17 	ldw	r2,-68(fp)
8114ae48:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114ae4c:	e0bff317 	ldw	r2,-52(fp)
8114ae50:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
8114ae54:	e0bffb17 	ldw	r2,-20(fp)
8114ae58:	10800617 	ldw	r2,24(r2)
8114ae5c:	10800104 	addi	r2,r2,4
8114ae60:	e0fff817 	ldw	r3,-32(fp)
8114ae64:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
8114ae68:	e0bffb17 	ldw	r2,-20(fp)
8114ae6c:	10800617 	ldw	r2,24(r2)
8114ae70:	10800204 	addi	r2,r2,8
8114ae74:	e0fff917 	ldw	r3,-28(fp)
8114ae78:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
8114ae7c:	e0bffe03 	ldbu	r2,-8(fp)
8114ae80:	10000426 	beq	r2,zero,8114ae94 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
8114ae84:	e0bfed17 	ldw	r2,-76(fp)
8114ae88:	10800414 	ori	r2,r2,16
8114ae8c:	e0bfed15 	stw	r2,-76(fp)
8114ae90:	00000406 	br	8114aea4 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
8114ae94:	e0ffed17 	ldw	r3,-76(fp)
8114ae98:	00bffbc4 	movi	r2,-17
8114ae9c:	1884703a 	and	r2,r3,r2
8114aea0:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
8114aea4:	e0bfff03 	ldbu	r2,-4(fp)
8114aea8:	10000e26 	beq	r2,zero,8114aee4 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
8114aeac:	e0bfed17 	ldw	r2,-76(fp)
8114aeb0:	10800094 	ori	r2,r2,2
8114aeb4:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8114aeb8:	e0bffb17 	ldw	r2,-20(fp)
8114aebc:	10800617 	ldw	r2,24(r2)
8114aec0:	10800304 	addi	r2,r2,12
8114aec4:	10800037 	ldwio	r2,0(r2)
8114aec8:	10000a1e 	bne	r2,zero,8114aef4 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8114aecc:	e0bffb17 	ldw	r2,-20(fp)
8114aed0:	10800617 	ldw	r2,24(r2)
8114aed4:	10800304 	addi	r2,r2,12
8114aed8:	00c03fc4 	movi	r3,255
8114aedc:	10c00035 	stwio	r3,0(r2)
8114aee0:	00000406 	br	8114aef4 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
8114aee4:	e0ffed17 	ldw	r3,-76(fp)
8114aee8:	00bfff44 	movi	r2,-3
8114aeec:	1884703a 	and	r2,r3,r2
8114aef0:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
8114aef4:	e0bfed17 	ldw	r2,-76(fp)
8114aef8:	10800054 	ori	r2,r2,1
8114aefc:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114af00:	e0bffb17 	ldw	r2,-20(fp)
8114af04:	10800617 	ldw	r2,24(r2)
8114af08:	e0ffed17 	ldw	r3,-76(fp)
8114af0c:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
8114af10:	e0bffb17 	ldw	r2,-20(fp)
8114af14:	10801817 	ldw	r2,96(r2)
8114af18:	1009883a 	mov	r4,r2
8114af1c:	11401540 	call	81140154 <OSSemPost>
	 
	 return 0;
8114af20:	0005883a 	mov	r2,zero
}
8114af24:	e037883a 	mov	sp,fp
8114af28:	dfc00117 	ldw	ra,4(sp)
8114af2c:	df000017 	ldw	fp,0(sp)
8114af30:	dec00204 	addi	sp,sp,8
8114af34:	f800283a 	ret

8114af38 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
8114af38:	defff704 	addi	sp,sp,-36
8114af3c:	de00012e 	bgeu	sp,et,8114af44 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
8114af40:	003b68fa 	trap	3
8114af44:	dfc00815 	stw	ra,32(sp)
8114af48:	df000715 	stw	fp,28(sp)
8114af4c:	dc400615 	stw	r17,24(sp)
8114af50:	dc000515 	stw	r16,20(sp)
8114af54:	df000704 	addi	fp,sp,28
8114af58:	e13ffa15 	stw	r4,-24(fp)
8114af5c:	e17ffb15 	stw	r5,-20(fp)
8114af60:	3007883a 	mov	r3,r6
8114af64:	3805883a 	mov	r2,r7
8114af68:	e0fffc05 	stb	r3,-16(fp)
8114af6c:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
8114af70:	e13ffb17 	ldw	r4,-20(fp)
8114af74:	114aaa40 	call	8114aaa4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
8114af78:	10000226 	beq	r2,zero,8114af84 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
8114af7c:	00bffa84 	movi	r2,-22
8114af80:	00000b06 	br	8114afb0 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
8114af84:	e0bffb17 	ldw	r2,-20(fp)
8114af88:	1021883a 	mov	r16,r2
8114af8c:	0023883a 	mov	r17,zero
8114af90:	e0fffc03 	ldbu	r3,-16(fp)
8114af94:	e0bffd03 	ldbu	r2,-12(fp)
8114af98:	d8800015 	stw	r2,0(sp)
8114af9c:	180f883a 	mov	r7,r3
8114afa0:	800b883a 	mov	r5,r16
8114afa4:	880d883a 	mov	r6,r17
8114afa8:	e13ffa17 	ldw	r4,-24(fp)
8114afac:	114ac200 	call	8114ac20 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8114afb0:	e6fffe04 	addi	sp,fp,-8
8114afb4:	dfc00317 	ldw	ra,12(sp)
8114afb8:	df000217 	ldw	fp,8(sp)
8114afbc:	dc400117 	ldw	r17,4(sp)
8114afc0:	dc000017 	ldw	r16,0(sp)
8114afc4:	dec00404 	addi	sp,sp,16
8114afc8:	f800283a 	ret

8114afcc <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8114afcc:	defff704 	addi	sp,sp,-36
8114afd0:	de00012e 	bgeu	sp,et,8114afd8 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
8114afd4:	003b68fa 	trap	3
8114afd8:	dfc00815 	stw	ra,32(sp)
8114afdc:	df000715 	stw	fp,28(sp)
8114afe0:	dc400615 	stw	r17,24(sp)
8114afe4:	dc000515 	stw	r16,20(sp)
8114afe8:	df000704 	addi	fp,sp,28
8114afec:	e13ffa15 	stw	r4,-24(fp)
8114aff0:	e17ffb15 	stw	r5,-20(fp)
8114aff4:	3007883a 	mov	r3,r6
8114aff8:	3805883a 	mov	r2,r7
8114affc:	e0fffc05 	stb	r3,-16(fp)
8114b000:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
8114b004:	e13ffb17 	ldw	r4,-20(fp)
8114b008:	114ab440 	call	8114ab44 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
8114b00c:	10000226 	beq	r2,zero,8114b018 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
8114b010:	00bffa84 	movi	r2,-22
8114b014:	00000b06 	br	8114b044 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
8114b018:	e0bffb17 	ldw	r2,-20(fp)
8114b01c:	1021883a 	mov	r16,r2
8114b020:	0023883a 	mov	r17,zero
8114b024:	e0fffc03 	ldbu	r3,-16(fp)
8114b028:	e0bffd03 	ldbu	r2,-12(fp)
8114b02c:	d8800015 	stw	r2,0(sp)
8114b030:	180f883a 	mov	r7,r3
8114b034:	800b883a 	mov	r5,r16
8114b038:	880d883a 	mov	r6,r17
8114b03c:	e13ffa17 	ldw	r4,-24(fp)
8114b040:	114ac200 	call	8114ac20 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8114b044:	e6fffe04 	addi	sp,fp,-8
8114b048:	dfc00317 	ldw	ra,12(sp)
8114b04c:	df000217 	ldw	fp,8(sp)
8114b050:	dc400117 	ldw	r17,4(sp)
8114b054:	dc000017 	ldw	r16,0(sp)
8114b058:	dec00404 	addi	sp,sp,16
8114b05c:	f800283a 	ret

8114b060 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
8114b060:	defffc04 	addi	sp,sp,-16
8114b064:	de00012e 	bgeu	sp,et,8114b06c <alt_msgdma_open+0xc>
8114b068:	003b68fa 	trap	3
8114b06c:	dfc00315 	stw	ra,12(sp)
8114b070:	df000215 	stw	fp,8(sp)
8114b074:	df000204 	addi	fp,sp,8
8114b078:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
8114b07c:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
8114b080:	d1603504 	addi	r5,gp,-32556
8114b084:	e13fff17 	ldw	r4,-4(fp)
8114b088:	114b6040 	call	8114b604 <alt_find_dev>
8114b08c:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
8114b090:	e0bffe17 	ldw	r2,-8(fp)
8114b094:	1000041e 	bne	r2,zero,8114b0a8 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
8114b098:	11492c40 	call	811492c4 <alt_get_errno>
8114b09c:	1007883a 	mov	r3,r2
8114b0a0:	008004c4 	movi	r2,19
8114b0a4:	18800015 	stw	r2,0(r3)
    }

    return dev;
8114b0a8:	e0bffe17 	ldw	r2,-8(fp)
}
8114b0ac:	e037883a 	mov	sp,fp
8114b0b0:	dfc00117 	ldw	ra,4(sp)
8114b0b4:	df000017 	ldw	fp,0(sp)
8114b0b8:	dec00204 	addi	sp,sp,8
8114b0bc:	f800283a 	ret

8114b0c0 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
8114b0c0:	defff604 	addi	sp,sp,-40
8114b0c4:	de00012e 	bgeu	sp,et,8114b0cc <alt_msgdma_init+0xc>
8114b0c8:	003b68fa 	trap	3
8114b0cc:	dfc00915 	stw	ra,36(sp)
8114b0d0:	df000815 	stw	fp,32(sp)
8114b0d4:	df000804 	addi	fp,sp,32
8114b0d8:	e13ffd15 	stw	r4,-12(fp)
8114b0dc:	e17ffe15 	stw	r5,-8(fp)
8114b0e0:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
8114b0e4:	e0bffd17 	ldw	r2,-12(fp)
8114b0e8:	10801783 	ldbu	r2,94(r2)
8114b0ec:	10803fcc 	andi	r2,r2,255
8114b0f0:	10000b26 	beq	r2,zero,8114b120 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
8114b0f4:	e0bffd17 	ldw	r2,-12(fp)
8114b0f8:	10800617 	ldw	r2,24(r2)
8114b0fc:	00c00104 	movi	r3,4
8114b100:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
8114b104:	0001883a 	nop
8114b108:	e0bffd17 	ldw	r2,-12(fp)
8114b10c:	10800617 	ldw	r2,24(r2)
8114b110:	10800037 	ldwio	r2,0(r2)
8114b114:	1080010c 	andi	r2,r2,4
8114b118:	1005d0ba 	srai	r2,r2,2
8114b11c:	103ffa1e 	bne	r2,zero,8114b108 <__reset+0xfb12b108>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
8114b120:	e0bffd17 	ldw	r2,-12(fp)
8114b124:	10800317 	ldw	r2,12(r2)
8114b128:	10800104 	addi	r2,r2,4
8114b12c:	00c00084 	movi	r3,2
8114b130:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8114b134:	0001883a 	nop
8114b138:	e0bffd17 	ldw	r2,-12(fp)
8114b13c:	10800317 	ldw	r2,12(r2)
8114b140:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
8114b144:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8114b148:	103ffb1e 	bne	r2,zero,8114b138 <__reset+0xfb12b138>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8114b14c:	e0bffd17 	ldw	r2,-12(fp)
8114b150:	10800317 	ldw	r2,12(r2)
8114b154:	10800104 	addi	r2,r2,4
8114b158:	10800037 	ldwio	r2,0(r2)
8114b15c:	1007883a 	mov	r3,r2
8114b160:	00bffbc4 	movi	r2,-17
8114b164:	1884703a 	and	r2,r3,r2
8114b168:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114b16c:	e0bff917 	ldw	r2,-28(fp)
8114b170:	10800814 	ori	r2,r2,32
8114b174:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8114b178:	e0bffd17 	ldw	r2,-12(fp)
8114b17c:	10800317 	ldw	r2,12(r2)
8114b180:	10800104 	addi	r2,r2,4
8114b184:	e0fff917 	ldw	r3,-28(fp)
8114b188:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
8114b18c:	e0bffd17 	ldw	r2,-12(fp)
8114b190:	10800317 	ldw	r2,12(r2)
8114b194:	e0fffd17 	ldw	r3,-12(fp)
8114b198:	18c00317 	ldw	r3,12(r3)
8114b19c:	18c00037 	ldwio	r3,0(r3)
8114b1a0:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
8114b1a4:	e0bffd17 	ldw	r2,-12(fp)
8114b1a8:	10801783 	ldbu	r2,94(r2)
8114b1ac:	10803fcc 	andi	r2,r2,255
8114b1b0:	10000826 	beq	r2,zero,8114b1d4 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
8114b1b4:	e0bffd17 	ldw	r2,-12(fp)
8114b1b8:	10800617 	ldw	r2,24(r2)
8114b1bc:	10800404 	addi	r2,r2,16
8114b1c0:	e0fffd17 	ldw	r3,-12(fp)
8114b1c4:	18c00617 	ldw	r3,24(r3)
8114b1c8:	18c00404 	addi	r3,r3,16
8114b1cc:	18c00037 	ldwio	r3,0(r3)
8114b1d0:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
8114b1d4:	d1603504 	addi	r5,gp,-32556
8114b1d8:	e13ffd17 	ldw	r4,-12(fp)
8114b1dc:	114b5580 	call	8114b558 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
8114b1e0:	e0bffd17 	ldw	r2,-12(fp)
8114b1e4:	10801804 	addi	r2,r2,96
8114b1e8:	e0bffb15 	stw	r2,-20(fp)
8114b1ec:	00800044 	movi	r2,1
8114b1f0:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8114b1f4:	e0bffc0b 	ldhu	r2,-16(fp)
8114b1f8:	1009883a 	mov	r4,r2
8114b1fc:	113faa40 	call	8113faa4 <OSSemCreate>
8114b200:	1007883a 	mov	r3,r2
8114b204:	e0bffb17 	ldw	r2,-20(fp)
8114b208:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8114b20c:	e0bffb17 	ldw	r2,-20(fp)
8114b210:	10800017 	ldw	r2,0(r2)
8114b214:	10000226 	beq	r2,zero,8114b220 <alt_msgdma_init+0x160>
8114b218:	0005883a 	mov	r2,zero
8114b21c:	00000106 	br	8114b224 <alt_msgdma_init+0x164>
8114b220:	00bfffc4 	movi	r2,-1
8114b224:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
8114b228:	e0bffa17 	ldw	r2,-24(fp)
8114b22c:	1000081e 	bne	r2,zero,8114b250 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
8114b230:	d8000015 	stw	zero,0(sp)
8114b234:	e1fffd17 	ldw	r7,-12(fp)
8114b238:	01a04574 	movhi	r6,33045
8114b23c:	31a53604 	addi	r6,r6,-27432
8114b240:	e17fff17 	ldw	r5,-4(fp)
8114b244:	e13ffe17 	ldw	r4,-8(fp)
8114b248:	114b8900 	call	8114b890 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
8114b24c:	00000406 	br	8114b260 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
8114b250:	01204574 	movhi	r4,33045
8114b254:	21096a04 	addi	r4,r4,9640
8114b258:	114bca80 	call	8114bca8 <alt_printf>
    }
    
    return;
8114b25c:	0001883a 	nop

}
8114b260:	e037883a 	mov	sp,fp
8114b264:	dfc00117 	ldw	ra,4(sp)
8114b268:	df000017 	ldw	fp,0(sp)
8114b26c:	dec00204 	addi	sp,sp,8
8114b270:	f800283a 	ret

8114b274 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
8114b274:	defffb04 	addi	sp,sp,-20
8114b278:	de00012e 	bgeu	sp,et,8114b280 <alt_msgdma_register_callback+0xc>
8114b27c:	003b68fa 	trap	3
8114b280:	df000415 	stw	fp,16(sp)
8114b284:	df000404 	addi	fp,sp,16
8114b288:	e13ffc15 	stw	r4,-16(fp)
8114b28c:	e17ffd15 	stw	r5,-12(fp)
8114b290:	e1bffe15 	stw	r6,-8(fp)
8114b294:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
8114b298:	e0bffc17 	ldw	r2,-16(fp)
8114b29c:	e0fffd17 	ldw	r3,-12(fp)
8114b2a0:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
8114b2a4:	e0bffc17 	ldw	r2,-16(fp)
8114b2a8:	e0ffff17 	ldw	r3,-4(fp)
8114b2ac:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
8114b2b0:	e0bffc17 	ldw	r2,-16(fp)
8114b2b4:	e0fffe17 	ldw	r3,-8(fp)
8114b2b8:	10c00d15 	stw	r3,52(r2)

    return ;
8114b2bc:	0001883a 	nop
}
8114b2c0:	e037883a 	mov	sp,fp
8114b2c4:	df000017 	ldw	fp,0(sp)
8114b2c8:	dec00104 	addi	sp,sp,4
8114b2cc:	f800283a 	ret

8114b2d0 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8114b2d0:	defffc04 	addi	sp,sp,-16
8114b2d4:	de00012e 	bgeu	sp,et,8114b2dc <alt_msgdma_standard_descriptor_async_transfer+0xc>
8114b2d8:	003b68fa 	trap	3
8114b2dc:	dfc00315 	stw	ra,12(sp)
8114b2e0:	df000215 	stw	fp,8(sp)
8114b2e4:	df000204 	addi	fp,sp,8
8114b2e8:	e13ffe15 	stw	r4,-8(fp)
8114b2ec:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
8114b2f0:	000d883a 	mov	r6,zero
8114b2f4:	e17fff17 	ldw	r5,-4(fp)
8114b2f8:	e13ffe17 	ldw	r4,-8(fp)
8114b2fc:	11498540 	call	81149854 <alt_msgdma_descriptor_async_transfer>

}
8114b300:	e037883a 	mov	sp,fp
8114b304:	dfc00117 	ldw	ra,4(sp)
8114b308:	df000017 	ldw	fp,0(sp)
8114b30c:	dec00204 	addi	sp,sp,8
8114b310:	f800283a 	ret

8114b314 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114b314:	defffc04 	addi	sp,sp,-16
8114b318:	de00012e 	bgeu	sp,et,8114b320 <alt_msgdma_extended_descriptor_async_transfer+0xc>
8114b31c:	003b68fa 	trap	3
8114b320:	dfc00315 	stw	ra,12(sp)
8114b324:	df000215 	stw	fp,8(sp)
8114b328:	df000204 	addi	fp,sp,8
8114b32c:	e13ffe15 	stw	r4,-8(fp)
8114b330:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
8114b334:	e1bfff17 	ldw	r6,-4(fp)
8114b338:	000b883a 	mov	r5,zero
8114b33c:	e13ffe17 	ldw	r4,-8(fp)
8114b340:	11498540 	call	81149854 <alt_msgdma_descriptor_async_transfer>
}
8114b344:	e037883a 	mov	sp,fp
8114b348:	dfc00117 	ldw	ra,4(sp)
8114b34c:	df000017 	ldw	fp,0(sp)
8114b350:	dec00204 	addi	sp,sp,8
8114b354:	f800283a 	ret

8114b358 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8114b358:	defffc04 	addi	sp,sp,-16
8114b35c:	de00012e 	bgeu	sp,et,8114b364 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
8114b360:	003b68fa 	trap	3
8114b364:	dfc00315 	stw	ra,12(sp)
8114b368:	df000215 	stw	fp,8(sp)
8114b36c:	df000204 	addi	fp,sp,8
8114b370:	e13ffe15 	stw	r4,-8(fp)
8114b374:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
8114b378:	000d883a 	mov	r6,zero
8114b37c:	e17fff17 	ldw	r5,-4(fp)
8114b380:	e13ffe17 	ldw	r4,-8(fp)
8114b384:	1149b940 	call	81149b94 <alt_msgdma_descriptor_sync_transfer>
}
8114b388:	e037883a 	mov	sp,fp
8114b38c:	dfc00117 	ldw	ra,4(sp)
8114b390:	df000017 	ldw	fp,0(sp)
8114b394:	dec00204 	addi	sp,sp,8
8114b398:	f800283a 	ret

8114b39c <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114b39c:	defffc04 	addi	sp,sp,-16
8114b3a0:	de00012e 	bgeu	sp,et,8114b3a8 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
8114b3a4:	003b68fa 	trap	3
8114b3a8:	dfc00315 	stw	ra,12(sp)
8114b3ac:	df000215 	stw	fp,8(sp)
8114b3b0:	df000204 	addi	fp,sp,8
8114b3b4:	e13ffe15 	stw	r4,-8(fp)
8114b3b8:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
8114b3bc:	e1bfff17 	ldw	r6,-4(fp)
8114b3c0:	000b883a 	mov	r5,zero
8114b3c4:	e13ffe17 	ldw	r4,-8(fp)
8114b3c8:	1149b940 	call	81149b94 <alt_msgdma_descriptor_sync_transfer>
}
8114b3cc:	e037883a 	mov	sp,fp
8114b3d0:	dfc00117 	ldw	ra,4(sp)
8114b3d4:	df000017 	ldw	fp,0(sp)
8114b3d8:	dec00204 	addi	sp,sp,8
8114b3dc:	f800283a 	ret

8114b3e0 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
8114b3e0:	defff504 	addi	sp,sp,-44
8114b3e4:	de00012e 	bgeu	sp,et,8114b3ec <alt_alarm_start+0xc>
8114b3e8:	003b68fa 	trap	3
8114b3ec:	df000a15 	stw	fp,40(sp)
8114b3f0:	df000a04 	addi	fp,sp,40
8114b3f4:	e13ffc15 	stw	r4,-16(fp)
8114b3f8:	e17ffd15 	stw	r5,-12(fp)
8114b3fc:	e1bffe15 	stw	r6,-8(fp)
8114b400:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
8114b404:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8114b408:	d0a08817 	ldw	r2,-32224(gp)
  
  if (alt_ticks_per_second ())
8114b40c:	10003c26 	beq	r2,zero,8114b500 <alt_alarm_start+0x120>
  {
    if (alarm)
8114b410:	e0bffc17 	ldw	r2,-16(fp)
8114b414:	10003826 	beq	r2,zero,8114b4f8 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
8114b418:	e0bffc17 	ldw	r2,-16(fp)
8114b41c:	e0fffe17 	ldw	r3,-8(fp)
8114b420:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
8114b424:	e0bffc17 	ldw	r2,-16(fp)
8114b428:	e0ffff17 	ldw	r3,-4(fp)
8114b42c:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114b430:	0005303a 	rdctl	r2,status
8114b434:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114b438:	e0fff917 	ldw	r3,-28(fp)
8114b43c:	00bfff84 	movi	r2,-2
8114b440:	1884703a 	and	r2,r3,r2
8114b444:	1001703a 	wrctl	status,r2
  
  return context;
8114b448:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
8114b44c:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8114b450:	d0a08917 	ldw	r2,-32220(gp)
      
      current_nticks = alt_nticks();
8114b454:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
8114b458:	e0fffd17 	ldw	r3,-12(fp)
8114b45c:	e0bff617 	ldw	r2,-40(fp)
8114b460:	1885883a 	add	r2,r3,r2
8114b464:	10c00044 	addi	r3,r2,1
8114b468:	e0bffc17 	ldw	r2,-16(fp)
8114b46c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
8114b470:	e0bffc17 	ldw	r2,-16(fp)
8114b474:	10c00217 	ldw	r3,8(r2)
8114b478:	e0bff617 	ldw	r2,-40(fp)
8114b47c:	1880042e 	bgeu	r3,r2,8114b490 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
8114b480:	e0bffc17 	ldw	r2,-16(fp)
8114b484:	00c00044 	movi	r3,1
8114b488:	10c00405 	stb	r3,16(r2)
8114b48c:	00000206 	br	8114b498 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
8114b490:	e0bffc17 	ldw	r2,-16(fp)
8114b494:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
8114b498:	e0bffc17 	ldw	r2,-16(fp)
8114b49c:	d0e01404 	addi	r3,gp,-32688
8114b4a0:	e0fffa15 	stw	r3,-24(fp)
8114b4a4:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8114b4a8:	e0bffb17 	ldw	r2,-20(fp)
8114b4ac:	e0fffa17 	ldw	r3,-24(fp)
8114b4b0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114b4b4:	e0bffa17 	ldw	r2,-24(fp)
8114b4b8:	10c00017 	ldw	r3,0(r2)
8114b4bc:	e0bffb17 	ldw	r2,-20(fp)
8114b4c0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114b4c4:	e0bffa17 	ldw	r2,-24(fp)
8114b4c8:	10800017 	ldw	r2,0(r2)
8114b4cc:	e0fffb17 	ldw	r3,-20(fp)
8114b4d0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114b4d4:	e0bffa17 	ldw	r2,-24(fp)
8114b4d8:	e0fffb17 	ldw	r3,-20(fp)
8114b4dc:	10c00015 	stw	r3,0(r2)
8114b4e0:	e0bff817 	ldw	r2,-32(fp)
8114b4e4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114b4e8:	e0bff717 	ldw	r2,-36(fp)
8114b4ec:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
8114b4f0:	0005883a 	mov	r2,zero
8114b4f4:	00000306 	br	8114b504 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
8114b4f8:	00bffa84 	movi	r2,-22
8114b4fc:	00000106 	br	8114b504 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
8114b500:	00bfde84 	movi	r2,-134
  }
}
8114b504:	e037883a 	mov	sp,fp
8114b508:	df000017 	ldw	fp,0(sp)
8114b50c:	dec00104 	addi	sp,sp,4
8114b510:	f800283a 	ret

8114b514 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114b514:	defffe04 	addi	sp,sp,-8
8114b518:	de00012e 	bgeu	sp,et,8114b520 <alt_get_errno+0xc>
8114b51c:	003b68fa 	trap	3
8114b520:	dfc00115 	stw	ra,4(sp)
8114b524:	df000015 	stw	fp,0(sp)
8114b528:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8114b52c:	d0a01017 	ldw	r2,-32704(gp)
8114b530:	10000326 	beq	r2,zero,8114b540 <alt_get_errno+0x2c>
8114b534:	d0a01017 	ldw	r2,-32704(gp)
8114b538:	103ee83a 	callr	r2
8114b53c:	00000106 	br	8114b544 <alt_get_errno+0x30>
8114b540:	d0a07804 	addi	r2,gp,-32288
}
8114b544:	e037883a 	mov	sp,fp
8114b548:	dfc00117 	ldw	ra,4(sp)
8114b54c:	df000017 	ldw	fp,0(sp)
8114b550:	dec00204 	addi	sp,sp,8
8114b554:	f800283a 	ret

8114b558 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
8114b558:	defffa04 	addi	sp,sp,-24
8114b55c:	de00012e 	bgeu	sp,et,8114b564 <alt_dev_llist_insert+0xc>
8114b560:	003b68fa 	trap	3
8114b564:	dfc00515 	stw	ra,20(sp)
8114b568:	df000415 	stw	fp,16(sp)
8114b56c:	df000404 	addi	fp,sp,16
8114b570:	e13ffe15 	stw	r4,-8(fp)
8114b574:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
8114b578:	e0bffe17 	ldw	r2,-8(fp)
8114b57c:	10000326 	beq	r2,zero,8114b58c <alt_dev_llist_insert+0x34>
8114b580:	e0bffe17 	ldw	r2,-8(fp)
8114b584:	10800217 	ldw	r2,8(r2)
8114b588:	1000061e 	bne	r2,zero,8114b5a4 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
8114b58c:	114b5140 	call	8114b514 <alt_get_errno>
8114b590:	1007883a 	mov	r3,r2
8114b594:	00800584 	movi	r2,22
8114b598:	18800015 	stw	r2,0(r3)
    return -EINVAL;
8114b59c:	00bffa84 	movi	r2,-22
8114b5a0:	00001306 	br	8114b5f0 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
8114b5a4:	e0bffe17 	ldw	r2,-8(fp)
8114b5a8:	e0ffff17 	ldw	r3,-4(fp)
8114b5ac:	e0fffc15 	stw	r3,-16(fp)
8114b5b0:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8114b5b4:	e0bffd17 	ldw	r2,-12(fp)
8114b5b8:	e0fffc17 	ldw	r3,-16(fp)
8114b5bc:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114b5c0:	e0bffc17 	ldw	r2,-16(fp)
8114b5c4:	10c00017 	ldw	r3,0(r2)
8114b5c8:	e0bffd17 	ldw	r2,-12(fp)
8114b5cc:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114b5d0:	e0bffc17 	ldw	r2,-16(fp)
8114b5d4:	10800017 	ldw	r2,0(r2)
8114b5d8:	e0fffd17 	ldw	r3,-12(fp)
8114b5dc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114b5e0:	e0bffc17 	ldw	r2,-16(fp)
8114b5e4:	e0fffd17 	ldw	r3,-12(fp)
8114b5e8:	10c00015 	stw	r3,0(r2)

  return 0;  
8114b5ec:	0005883a 	mov	r2,zero
}
8114b5f0:	e037883a 	mov	sp,fp
8114b5f4:	dfc00117 	ldw	ra,4(sp)
8114b5f8:	df000017 	ldw	fp,0(sp)
8114b5fc:	dec00204 	addi	sp,sp,8
8114b600:	f800283a 	ret

8114b604 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
8114b604:	defffa04 	addi	sp,sp,-24
8114b608:	de00012e 	bgeu	sp,et,8114b610 <alt_find_dev+0xc>
8114b60c:	003b68fa 	trap	3
8114b610:	dfc00515 	stw	ra,20(sp)
8114b614:	df000415 	stw	fp,16(sp)
8114b618:	df000404 	addi	fp,sp,16
8114b61c:	e13ffe15 	stw	r4,-8(fp)
8114b620:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
8114b624:	e0bfff17 	ldw	r2,-4(fp)
8114b628:	10800017 	ldw	r2,0(r2)
8114b62c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
8114b630:	e13ffe17 	ldw	r4,-8(fp)
8114b634:	11244540 	call	81124454 <strlen>
8114b638:	10800044 	addi	r2,r2,1
8114b63c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114b640:	00000d06 	br	8114b678 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
8114b644:	e0bffc17 	ldw	r2,-16(fp)
8114b648:	10800217 	ldw	r2,8(r2)
8114b64c:	e0fffd17 	ldw	r3,-12(fp)
8114b650:	180d883a 	mov	r6,r3
8114b654:	e17ffe17 	ldw	r5,-8(fp)
8114b658:	1009883a 	mov	r4,r2
8114b65c:	114c4180 	call	8114c418 <memcmp>
8114b660:	1000021e 	bne	r2,zero,8114b66c <alt_find_dev+0x68>
    {
      /* match found */

      return next;
8114b664:	e0bffc17 	ldw	r2,-16(fp)
8114b668:	00000706 	br	8114b688 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
8114b66c:	e0bffc17 	ldw	r2,-16(fp)
8114b670:	10800017 	ldw	r2,0(r2)
8114b674:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114b678:	e0fffc17 	ldw	r3,-16(fp)
8114b67c:	e0bfff17 	ldw	r2,-4(fp)
8114b680:	18bff01e 	bne	r3,r2,8114b644 <__reset+0xfb12b644>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
8114b684:	0005883a 	mov	r2,zero
}
8114b688:	e037883a 	mov	sp,fp
8114b68c:	dfc00117 	ldw	ra,4(sp)
8114b690:	df000017 	ldw	fp,0(sp)
8114b694:	dec00204 	addi	sp,sp,8
8114b698:	f800283a 	ret

8114b69c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
8114b69c:	defffb04 	addi	sp,sp,-20
8114b6a0:	de00012e 	bgeu	sp,et,8114b6a8 <alt_find_file+0xc>
8114b6a4:	003b68fa 	trap	3
8114b6a8:	dfc00415 	stw	ra,16(sp)
8114b6ac:	df000315 	stw	fp,12(sp)
8114b6b0:	df000304 	addi	fp,sp,12
8114b6b4:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
8114b6b8:	d0a00b17 	ldw	r2,-32724(gp)
8114b6bc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114b6c0:	00003106 	br	8114b788 <alt_find_file+0xec>
  {
    len = strlen(next->name);
8114b6c4:	e0bffd17 	ldw	r2,-12(fp)
8114b6c8:	10800217 	ldw	r2,8(r2)
8114b6cc:	1009883a 	mov	r4,r2
8114b6d0:	11244540 	call	81124454 <strlen>
8114b6d4:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
8114b6d8:	e0bffd17 	ldw	r2,-12(fp)
8114b6dc:	10c00217 	ldw	r3,8(r2)
8114b6e0:	e0bffe17 	ldw	r2,-8(fp)
8114b6e4:	10bfffc4 	addi	r2,r2,-1
8114b6e8:	1885883a 	add	r2,r3,r2
8114b6ec:	10800003 	ldbu	r2,0(r2)
8114b6f0:	10803fcc 	andi	r2,r2,255
8114b6f4:	1080201c 	xori	r2,r2,128
8114b6f8:	10bfe004 	addi	r2,r2,-128
8114b6fc:	10800bd8 	cmpnei	r2,r2,47
8114b700:	1000031e 	bne	r2,zero,8114b710 <alt_find_file+0x74>
    {
      len -= 1;
8114b704:	e0bffe17 	ldw	r2,-8(fp)
8114b708:	10bfffc4 	addi	r2,r2,-1
8114b70c:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114b710:	e0bffe17 	ldw	r2,-8(fp)
8114b714:	e0ffff17 	ldw	r3,-4(fp)
8114b718:	1885883a 	add	r2,r3,r2
8114b71c:	10800003 	ldbu	r2,0(r2)
8114b720:	10803fcc 	andi	r2,r2,255
8114b724:	1080201c 	xori	r2,r2,128
8114b728:	10bfe004 	addi	r2,r2,-128
8114b72c:	10800be0 	cmpeqi	r2,r2,47
8114b730:	1000081e 	bne	r2,zero,8114b754 <alt_find_file+0xb8>
8114b734:	e0bffe17 	ldw	r2,-8(fp)
8114b738:	e0ffff17 	ldw	r3,-4(fp)
8114b73c:	1885883a 	add	r2,r3,r2
8114b740:	10800003 	ldbu	r2,0(r2)
8114b744:	10803fcc 	andi	r2,r2,255
8114b748:	1080201c 	xori	r2,r2,128
8114b74c:	10bfe004 	addi	r2,r2,-128
8114b750:	10000a1e 	bne	r2,zero,8114b77c <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
8114b754:	e0bffd17 	ldw	r2,-12(fp)
8114b758:	10800217 	ldw	r2,8(r2)
8114b75c:	e0fffe17 	ldw	r3,-8(fp)
8114b760:	180d883a 	mov	r6,r3
8114b764:	e17fff17 	ldw	r5,-4(fp)
8114b768:	1009883a 	mov	r4,r2
8114b76c:	114c4180 	call	8114c418 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114b770:	1000021e 	bne	r2,zero,8114b77c <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
8114b774:	e0bffd17 	ldw	r2,-12(fp)
8114b778:	00000706 	br	8114b798 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
8114b77c:	e0bffd17 	ldw	r2,-12(fp)
8114b780:	10800017 	ldw	r2,0(r2)
8114b784:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114b788:	e0fffd17 	ldw	r3,-12(fp)
8114b78c:	d0a00b04 	addi	r2,gp,-32724
8114b790:	18bfcc1e 	bne	r3,r2,8114b6c4 <__reset+0xfb12b6c4>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
8114b794:	0005883a 	mov	r2,zero
}
8114b798:	e037883a 	mov	sp,fp
8114b79c:	dfc00117 	ldw	ra,4(sp)
8114b7a0:	df000017 	ldw	fp,0(sp)
8114b7a4:	dec00204 	addi	sp,sp,8
8114b7a8:	f800283a 	ret

8114b7ac <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
8114b7ac:	defff904 	addi	sp,sp,-28
8114b7b0:	de00012e 	bgeu	sp,et,8114b7b8 <alt_get_fd+0xc>
8114b7b4:	003b68fa 	trap	3
8114b7b8:	dfc00615 	stw	ra,24(sp)
8114b7bc:	df000515 	stw	fp,20(sp)
8114b7c0:	df000504 	addi	fp,sp,20
8114b7c4:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
8114b7c8:	00bffa04 	movi	r2,-24
8114b7cc:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
8114b7d0:	d0a07f17 	ldw	r2,-32260(gp)
8114b7d4:	e0bffd15 	stw	r2,-12(fp)
8114b7d8:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8114b7dc:	e0bffe0b 	ldhu	r2,-8(fp)
8114b7e0:	e0fffe84 	addi	r3,fp,-6
8114b7e4:	180d883a 	mov	r6,r3
8114b7e8:	100b883a 	mov	r5,r2
8114b7ec:	e13ffd17 	ldw	r4,-12(fp)
8114b7f0:	113fdcc0 	call	8113fdcc <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114b7f4:	e03ffb15 	stw	zero,-20(fp)
8114b7f8:	00001906 	br	8114b860 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
8114b7fc:	00a04574 	movhi	r2,33045
8114b800:	108bd904 	addi	r2,r2,12132
8114b804:	e0fffb17 	ldw	r3,-20(fp)
8114b808:	18c00324 	muli	r3,r3,12
8114b80c:	10c5883a 	add	r2,r2,r3
8114b810:	10800017 	ldw	r2,0(r2)
8114b814:	10000f1e 	bne	r2,zero,8114b854 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
8114b818:	00a04574 	movhi	r2,33045
8114b81c:	108bd904 	addi	r2,r2,12132
8114b820:	e0fffb17 	ldw	r3,-20(fp)
8114b824:	18c00324 	muli	r3,r3,12
8114b828:	10c5883a 	add	r2,r2,r3
8114b82c:	e0ffff17 	ldw	r3,-4(fp)
8114b830:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
8114b834:	d0e00f17 	ldw	r3,-32708(gp)
8114b838:	e0bffb17 	ldw	r2,-20(fp)
8114b83c:	1880020e 	bge	r3,r2,8114b848 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
8114b840:	e0bffb17 	ldw	r2,-20(fp)
8114b844:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
8114b848:	e0bffb17 	ldw	r2,-20(fp)
8114b84c:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
8114b850:	00000606 	br	8114b86c <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114b854:	e0bffb17 	ldw	r2,-20(fp)
8114b858:	10800044 	addi	r2,r2,1
8114b85c:	e0bffb15 	stw	r2,-20(fp)
8114b860:	e0bffb17 	ldw	r2,-20(fp)
8114b864:	10800810 	cmplti	r2,r2,32
8114b868:	103fe41e 	bne	r2,zero,8114b7fc <__reset+0xfb12b7fc>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
8114b86c:	d0a07f17 	ldw	r2,-32260(gp)
8114b870:	1009883a 	mov	r4,r2
8114b874:	11401540 	call	81140154 <OSSemPost>

  return rc;
8114b878:	e0bffc17 	ldw	r2,-16(fp)
}
8114b87c:	e037883a 	mov	sp,fp
8114b880:	dfc00117 	ldw	ra,4(sp)
8114b884:	df000017 	ldw	fp,0(sp)
8114b888:	dec00204 	addi	sp,sp,8
8114b88c:	f800283a 	ret

8114b890 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114b890:	defff904 	addi	sp,sp,-28
8114b894:	de00012e 	bgeu	sp,et,8114b89c <alt_ic_isr_register+0xc>
8114b898:	003b68fa 	trap	3
8114b89c:	dfc00615 	stw	ra,24(sp)
8114b8a0:	df000515 	stw	fp,20(sp)
8114b8a4:	df000504 	addi	fp,sp,20
8114b8a8:	e13ffc15 	stw	r4,-16(fp)
8114b8ac:	e17ffd15 	stw	r5,-12(fp)
8114b8b0:	e1bffe15 	stw	r6,-8(fp)
8114b8b4:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
8114b8b8:	e0800217 	ldw	r2,8(fp)
8114b8bc:	d8800015 	stw	r2,0(sp)
8114b8c0:	e1ffff17 	ldw	r7,-4(fp)
8114b8c4:	e1bffe17 	ldw	r6,-8(fp)
8114b8c8:	e17ffd17 	ldw	r5,-12(fp)
8114b8cc:	e13ffc17 	ldw	r4,-16(fp)
8114b8d0:	114ba600 	call	8114ba60 <alt_iic_isr_register>
}  
8114b8d4:	e037883a 	mov	sp,fp
8114b8d8:	dfc00117 	ldw	ra,4(sp)
8114b8dc:	df000017 	ldw	fp,0(sp)
8114b8e0:	dec00204 	addi	sp,sp,8
8114b8e4:	f800283a 	ret

8114b8e8 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
8114b8e8:	defff904 	addi	sp,sp,-28
8114b8ec:	de00012e 	bgeu	sp,et,8114b8f4 <alt_ic_irq_enable+0xc>
8114b8f0:	003b68fa 	trap	3
8114b8f4:	df000615 	stw	fp,24(sp)
8114b8f8:	df000604 	addi	fp,sp,24
8114b8fc:	e13ffe15 	stw	r4,-8(fp)
8114b900:	e17fff15 	stw	r5,-4(fp)
8114b904:	e0bfff17 	ldw	r2,-4(fp)
8114b908:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114b90c:	0005303a 	rdctl	r2,status
8114b910:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114b914:	e0fffb17 	ldw	r3,-20(fp)
8114b918:	00bfff84 	movi	r2,-2
8114b91c:	1884703a 	and	r2,r3,r2
8114b920:	1001703a 	wrctl	status,r2
  
  return context;
8114b924:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114b928:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
8114b92c:	00c00044 	movi	r3,1
8114b930:	e0bffa17 	ldw	r2,-24(fp)
8114b934:	1884983a 	sll	r2,r3,r2
8114b938:	1007883a 	mov	r3,r2
8114b93c:	d0a08017 	ldw	r2,-32256(gp)
8114b940:	1884b03a 	or	r2,r3,r2
8114b944:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114b948:	d0a08017 	ldw	r2,-32256(gp)
8114b94c:	100170fa 	wrctl	ienable,r2
8114b950:	e0bffc17 	ldw	r2,-16(fp)
8114b954:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114b958:	e0bffd17 	ldw	r2,-12(fp)
8114b95c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114b960:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
8114b964:	0001883a 	nop
}
8114b968:	e037883a 	mov	sp,fp
8114b96c:	df000017 	ldw	fp,0(sp)
8114b970:	dec00104 	addi	sp,sp,4
8114b974:	f800283a 	ret

8114b978 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
8114b978:	defff904 	addi	sp,sp,-28
8114b97c:	de00012e 	bgeu	sp,et,8114b984 <alt_ic_irq_disable+0xc>
8114b980:	003b68fa 	trap	3
8114b984:	df000615 	stw	fp,24(sp)
8114b988:	df000604 	addi	fp,sp,24
8114b98c:	e13ffe15 	stw	r4,-8(fp)
8114b990:	e17fff15 	stw	r5,-4(fp)
8114b994:	e0bfff17 	ldw	r2,-4(fp)
8114b998:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114b99c:	0005303a 	rdctl	r2,status
8114b9a0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114b9a4:	e0fffb17 	ldw	r3,-20(fp)
8114b9a8:	00bfff84 	movi	r2,-2
8114b9ac:	1884703a 	and	r2,r3,r2
8114b9b0:	1001703a 	wrctl	status,r2
  
  return context;
8114b9b4:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114b9b8:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
8114b9bc:	00c00044 	movi	r3,1
8114b9c0:	e0bffa17 	ldw	r2,-24(fp)
8114b9c4:	1884983a 	sll	r2,r3,r2
8114b9c8:	0084303a 	nor	r2,zero,r2
8114b9cc:	1007883a 	mov	r3,r2
8114b9d0:	d0a08017 	ldw	r2,-32256(gp)
8114b9d4:	1884703a 	and	r2,r3,r2
8114b9d8:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114b9dc:	d0a08017 	ldw	r2,-32256(gp)
8114b9e0:	100170fa 	wrctl	ienable,r2
8114b9e4:	e0bffc17 	ldw	r2,-16(fp)
8114b9e8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114b9ec:	e0bffd17 	ldw	r2,-12(fp)
8114b9f0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114b9f4:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
8114b9f8:	0001883a 	nop
}
8114b9fc:	e037883a 	mov	sp,fp
8114ba00:	df000017 	ldw	fp,0(sp)
8114ba04:	dec00104 	addi	sp,sp,4
8114ba08:	f800283a 	ret

8114ba0c <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
8114ba0c:	defffc04 	addi	sp,sp,-16
8114ba10:	de00012e 	bgeu	sp,et,8114ba18 <alt_ic_irq_enabled+0xc>
8114ba14:	003b68fa 	trap	3
8114ba18:	df000315 	stw	fp,12(sp)
8114ba1c:	df000304 	addi	fp,sp,12
8114ba20:	e13ffe15 	stw	r4,-8(fp)
8114ba24:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
8114ba28:	000530fa 	rdctl	r2,ienable
8114ba2c:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
8114ba30:	00c00044 	movi	r3,1
8114ba34:	e0bfff17 	ldw	r2,-4(fp)
8114ba38:	1884983a 	sll	r2,r3,r2
8114ba3c:	1007883a 	mov	r3,r2
8114ba40:	e0bffd17 	ldw	r2,-12(fp)
8114ba44:	1884703a 	and	r2,r3,r2
8114ba48:	1004c03a 	cmpne	r2,r2,zero
8114ba4c:	10803fcc 	andi	r2,r2,255
}
8114ba50:	e037883a 	mov	sp,fp
8114ba54:	df000017 	ldw	fp,0(sp)
8114ba58:	dec00104 	addi	sp,sp,4
8114ba5c:	f800283a 	ret

8114ba60 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114ba60:	defff504 	addi	sp,sp,-44
8114ba64:	de00012e 	bgeu	sp,et,8114ba6c <alt_iic_isr_register+0xc>
8114ba68:	003b68fa 	trap	3
8114ba6c:	dfc00a15 	stw	ra,40(sp)
8114ba70:	df000915 	stw	fp,36(sp)
8114ba74:	df000904 	addi	fp,sp,36
8114ba78:	e13ffc15 	stw	r4,-16(fp)
8114ba7c:	e17ffd15 	stw	r5,-12(fp)
8114ba80:	e1bffe15 	stw	r6,-8(fp)
8114ba84:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
8114ba88:	00bffa84 	movi	r2,-22
8114ba8c:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
8114ba90:	e0bffd17 	ldw	r2,-12(fp)
8114ba94:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8114ba98:	e0bff817 	ldw	r2,-32(fp)
8114ba9c:	10800808 	cmpgei	r2,r2,32
8114baa0:	1000271e 	bne	r2,zero,8114bb40 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114baa4:	0005303a 	rdctl	r2,status
8114baa8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114baac:	e0fffb17 	ldw	r3,-20(fp)
8114bab0:	00bfff84 	movi	r2,-2
8114bab4:	1884703a 	and	r2,r3,r2
8114bab8:	1001703a 	wrctl	status,r2
  
  return context;
8114babc:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
8114bac0:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
8114bac4:	00a045f4 	movhi	r2,33047
8114bac8:	10b97e04 	addi	r2,r2,-6664
8114bacc:	e0fff817 	ldw	r3,-32(fp)
8114bad0:	180690fa 	slli	r3,r3,3
8114bad4:	10c5883a 	add	r2,r2,r3
8114bad8:	e0fffe17 	ldw	r3,-8(fp)
8114badc:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
8114bae0:	00a045f4 	movhi	r2,33047
8114bae4:	10b97e04 	addi	r2,r2,-6664
8114bae8:	e0fff817 	ldw	r3,-32(fp)
8114baec:	180690fa 	slli	r3,r3,3
8114baf0:	10c5883a 	add	r2,r2,r3
8114baf4:	10800104 	addi	r2,r2,4
8114baf8:	e0ffff17 	ldw	r3,-4(fp)
8114bafc:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
8114bb00:	e0bffe17 	ldw	r2,-8(fp)
8114bb04:	10000526 	beq	r2,zero,8114bb1c <alt_iic_isr_register+0xbc>
8114bb08:	e0bff817 	ldw	r2,-32(fp)
8114bb0c:	100b883a 	mov	r5,r2
8114bb10:	e13ffc17 	ldw	r4,-16(fp)
8114bb14:	114b8e80 	call	8114b8e8 <alt_ic_irq_enable>
8114bb18:	00000406 	br	8114bb2c <alt_iic_isr_register+0xcc>
8114bb1c:	e0bff817 	ldw	r2,-32(fp)
8114bb20:	100b883a 	mov	r5,r2
8114bb24:	e13ffc17 	ldw	r4,-16(fp)
8114bb28:	114b9780 	call	8114b978 <alt_ic_irq_disable>
8114bb2c:	e0bff715 	stw	r2,-36(fp)
8114bb30:	e0bffa17 	ldw	r2,-24(fp)
8114bb34:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114bb38:	e0bff917 	ldw	r2,-28(fp)
8114bb3c:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
8114bb40:	e0bff717 	ldw	r2,-36(fp)
}
8114bb44:	e037883a 	mov	sp,fp
8114bb48:	dfc00117 	ldw	ra,4(sp)
8114bb4c:	df000017 	ldw	fp,0(sp)
8114bb50:	dec00204 	addi	sp,sp,8
8114bb54:	f800283a 	ret

8114bb58 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
8114bb58:	defff904 	addi	sp,sp,-28
8114bb5c:	de00012e 	bgeu	sp,et,8114bb64 <alt_open_fd+0xc>
8114bb60:	003b68fa 	trap	3
8114bb64:	dfc00615 	stw	ra,24(sp)
8114bb68:	df000515 	stw	fp,20(sp)
8114bb6c:	df000504 	addi	fp,sp,20
8114bb70:	e13ffc15 	stw	r4,-16(fp)
8114bb74:	e17ffd15 	stw	r5,-12(fp)
8114bb78:	e1bffe15 	stw	r6,-8(fp)
8114bb7c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
8114bb80:	e1bfff17 	ldw	r6,-4(fp)
8114bb84:	e17ffe17 	ldw	r5,-8(fp)
8114bb88:	e13ffd17 	ldw	r4,-12(fp)
8114bb8c:	1138a080 	call	81138a08 <open>
8114bb90:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
8114bb94:	e0bffb17 	ldw	r2,-20(fp)
8114bb98:	10001c16 	blt	r2,zero,8114bc0c <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
8114bb9c:	00a04574 	movhi	r2,33045
8114bba0:	108bd904 	addi	r2,r2,12132
8114bba4:	e0fffb17 	ldw	r3,-20(fp)
8114bba8:	18c00324 	muli	r3,r3,12
8114bbac:	10c5883a 	add	r2,r2,r3
8114bbb0:	10c00017 	ldw	r3,0(r2)
8114bbb4:	e0bffc17 	ldw	r2,-16(fp)
8114bbb8:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
8114bbbc:	00a04574 	movhi	r2,33045
8114bbc0:	108bd904 	addi	r2,r2,12132
8114bbc4:	e0fffb17 	ldw	r3,-20(fp)
8114bbc8:	18c00324 	muli	r3,r3,12
8114bbcc:	10c5883a 	add	r2,r2,r3
8114bbd0:	10800104 	addi	r2,r2,4
8114bbd4:	10c00017 	ldw	r3,0(r2)
8114bbd8:	e0bffc17 	ldw	r2,-16(fp)
8114bbdc:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
8114bbe0:	00a04574 	movhi	r2,33045
8114bbe4:	108bd904 	addi	r2,r2,12132
8114bbe8:	e0fffb17 	ldw	r3,-20(fp)
8114bbec:	18c00324 	muli	r3,r3,12
8114bbf0:	10c5883a 	add	r2,r2,r3
8114bbf4:	10800204 	addi	r2,r2,8
8114bbf8:	10c00017 	ldw	r3,0(r2)
8114bbfc:	e0bffc17 	ldw	r2,-16(fp)
8114bc00:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
8114bc04:	e13ffb17 	ldw	r4,-20(fp)
8114bc08:	1138cac0 	call	81138cac <alt_release_fd>
  }
} 
8114bc0c:	0001883a 	nop
8114bc10:	e037883a 	mov	sp,fp
8114bc14:	dfc00117 	ldw	ra,4(sp)
8114bc18:	df000017 	ldw	fp,0(sp)
8114bc1c:	dec00204 	addi	sp,sp,8
8114bc20:	f800283a 	ret

8114bc24 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
8114bc24:	defffb04 	addi	sp,sp,-20
8114bc28:	de00012e 	bgeu	sp,et,8114bc30 <alt_io_redirect+0xc>
8114bc2c:	003b68fa 	trap	3
8114bc30:	dfc00415 	stw	ra,16(sp)
8114bc34:	df000315 	stw	fp,12(sp)
8114bc38:	df000304 	addi	fp,sp,12
8114bc3c:	e13ffd15 	stw	r4,-12(fp)
8114bc40:	e17ffe15 	stw	r5,-8(fp)
8114bc44:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
8114bc48:	01c07fc4 	movi	r7,511
8114bc4c:	01800044 	movi	r6,1
8114bc50:	e17ffd17 	ldw	r5,-12(fp)
8114bc54:	01204574 	movhi	r4,33045
8114bc58:	210bdc04 	addi	r4,r4,12144
8114bc5c:	114bb580 	call	8114bb58 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
8114bc60:	01c07fc4 	movi	r7,511
8114bc64:	000d883a 	mov	r6,zero
8114bc68:	e17ffe17 	ldw	r5,-8(fp)
8114bc6c:	01204574 	movhi	r4,33045
8114bc70:	210bd904 	addi	r4,r4,12132
8114bc74:	114bb580 	call	8114bb58 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
8114bc78:	01c07fc4 	movi	r7,511
8114bc7c:	01800044 	movi	r6,1
8114bc80:	e17fff17 	ldw	r5,-4(fp)
8114bc84:	01204574 	movhi	r4,33045
8114bc88:	210bdf04 	addi	r4,r4,12156
8114bc8c:	114bb580 	call	8114bb58 <alt_open_fd>
}  
8114bc90:	0001883a 	nop
8114bc94:	e037883a 	mov	sp,fp
8114bc98:	dfc00117 	ldw	ra,4(sp)
8114bc9c:	df000017 	ldw	fp,0(sp)
8114bca0:	dec00204 	addi	sp,sp,8
8114bca4:	f800283a 	ret

8114bca8 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
8114bca8:	defff204 	addi	sp,sp,-56
8114bcac:	de00012e 	bgeu	sp,et,8114bcb4 <alt_printf+0xc>
8114bcb0:	003b68fa 	trap	3
8114bcb4:	dfc00a15 	stw	ra,40(sp)
8114bcb8:	df000915 	stw	fp,36(sp)
8114bcbc:	df000904 	addi	fp,sp,36
8114bcc0:	e13fff15 	stw	r4,-4(fp)
8114bcc4:	e1400215 	stw	r5,8(fp)
8114bcc8:	e1800315 	stw	r6,12(fp)
8114bccc:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
8114bcd0:	e0800204 	addi	r2,fp,8
8114bcd4:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
8114bcd8:	e0bfff17 	ldw	r2,-4(fp)
8114bcdc:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
8114bce0:	00006f06 	br	8114bea0 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
8114bce4:	e0bff807 	ldb	r2,-32(fp)
8114bce8:	10800960 	cmpeqi	r2,r2,37
8114bcec:	1000041e 	bne	r2,zero,8114bd00 <alt_printf+0x58>
        {
            alt_putchar(c);
8114bcf0:	e0bff807 	ldb	r2,-32(fp)
8114bcf4:	1009883a 	mov	r4,r2
8114bcf8:	114bedc0 	call	8114bedc <alt_putchar>
8114bcfc:	00006806 	br	8114bea0 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
8114bd00:	e0bff717 	ldw	r2,-36(fp)
8114bd04:	10c00044 	addi	r3,r2,1
8114bd08:	e0fff715 	stw	r3,-36(fp)
8114bd0c:	10800003 	ldbu	r2,0(r2)
8114bd10:	e0bff805 	stb	r2,-32(fp)
8114bd14:	e0bff807 	ldb	r2,-32(fp)
8114bd18:	10006926 	beq	r2,zero,8114bec0 <alt_printf+0x218>
            {
                if (c == '%')
8114bd1c:	e0bff807 	ldb	r2,-32(fp)
8114bd20:	10800958 	cmpnei	r2,r2,37
8114bd24:	1000041e 	bne	r2,zero,8114bd38 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
8114bd28:	e0bff807 	ldb	r2,-32(fp)
8114bd2c:	1009883a 	mov	r4,r2
8114bd30:	114bedc0 	call	8114bedc <alt_putchar>
8114bd34:	00005a06 	br	8114bea0 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
8114bd38:	e0bff807 	ldb	r2,-32(fp)
8114bd3c:	108018d8 	cmpnei	r2,r2,99
8114bd40:	1000081e 	bne	r2,zero,8114bd64 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
8114bd44:	e0bffe17 	ldw	r2,-8(fp)
8114bd48:	10c00104 	addi	r3,r2,4
8114bd4c:	e0fffe15 	stw	r3,-8(fp)
8114bd50:	10800017 	ldw	r2,0(r2)
8114bd54:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
8114bd58:	e13ffd17 	ldw	r4,-12(fp)
8114bd5c:	114bedc0 	call	8114bedc <alt_putchar>
8114bd60:	00004f06 	br	8114bea0 <alt_printf+0x1f8>
                }
                else if (c == 'x')
8114bd64:	e0bff807 	ldb	r2,-32(fp)
8114bd68:	10801e18 	cmpnei	r2,r2,120
8114bd6c:	1000341e 	bne	r2,zero,8114be40 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
8114bd70:	e0bffe17 	ldw	r2,-8(fp)
8114bd74:	10c00104 	addi	r3,r2,4
8114bd78:	e0fffe15 	stw	r3,-8(fp)
8114bd7c:	10800017 	ldw	r2,0(r2)
8114bd80:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
8114bd84:	e0bffb17 	ldw	r2,-20(fp)
8114bd88:	1000031e 	bne	r2,zero,8114bd98 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
8114bd8c:	01000c04 	movi	r4,48
8114bd90:	114bedc0 	call	8114bedc <alt_putchar>
                        continue;
8114bd94:	00004206 	br	8114bea0 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
8114bd98:	00800704 	movi	r2,28
8114bd9c:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
8114bda0:	00000306 	br	8114bdb0 <alt_printf+0x108>
                        digit_shift -= 4;
8114bda4:	e0bff917 	ldw	r2,-28(fp)
8114bda8:	10bfff04 	addi	r2,r2,-4
8114bdac:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
8114bdb0:	00c003c4 	movi	r3,15
8114bdb4:	e0bff917 	ldw	r2,-28(fp)
8114bdb8:	1884983a 	sll	r2,r3,r2
8114bdbc:	1007883a 	mov	r3,r2
8114bdc0:	e0bffb17 	ldw	r2,-20(fp)
8114bdc4:	1884703a 	and	r2,r3,r2
8114bdc8:	103ff626 	beq	r2,zero,8114bda4 <__reset+0xfb12bda4>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114bdcc:	00001906 	br	8114be34 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
8114bdd0:	00c003c4 	movi	r3,15
8114bdd4:	e0bff917 	ldw	r2,-28(fp)
8114bdd8:	1884983a 	sll	r2,r3,r2
8114bddc:	1007883a 	mov	r3,r2
8114bde0:	e0bffb17 	ldw	r2,-20(fp)
8114bde4:	1886703a 	and	r3,r3,r2
8114bde8:	e0bff917 	ldw	r2,-28(fp)
8114bdec:	1884d83a 	srl	r2,r3,r2
8114bdf0:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
8114bdf4:	e0bffc17 	ldw	r2,-16(fp)
8114bdf8:	108002a8 	cmpgeui	r2,r2,10
8114bdfc:	1000041e 	bne	r2,zero,8114be10 <alt_printf+0x168>
                            c = '0' + digit;
8114be00:	e0bffc17 	ldw	r2,-16(fp)
8114be04:	10800c04 	addi	r2,r2,48
8114be08:	e0bff805 	stb	r2,-32(fp)
8114be0c:	00000306 	br	8114be1c <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
8114be10:	e0bffc17 	ldw	r2,-16(fp)
8114be14:	108015c4 	addi	r2,r2,87
8114be18:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
8114be1c:	e0bff807 	ldb	r2,-32(fp)
8114be20:	1009883a 	mov	r4,r2
8114be24:	114bedc0 	call	8114bedc <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114be28:	e0bff917 	ldw	r2,-28(fp)
8114be2c:	10bfff04 	addi	r2,r2,-4
8114be30:	e0bff915 	stw	r2,-28(fp)
8114be34:	e0bff917 	ldw	r2,-28(fp)
8114be38:	103fe50e 	bge	r2,zero,8114bdd0 <__reset+0xfb12bdd0>
8114be3c:	00001806 	br	8114bea0 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
8114be40:	e0bff807 	ldb	r2,-32(fp)
8114be44:	10801cd8 	cmpnei	r2,r2,115
8114be48:	1000151e 	bne	r2,zero,8114bea0 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
8114be4c:	e0bffe17 	ldw	r2,-8(fp)
8114be50:	10c00104 	addi	r3,r2,4
8114be54:	e0fffe15 	stw	r3,-8(fp)
8114be58:	10800017 	ldw	r2,0(r2)
8114be5c:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
8114be60:	00000906 	br	8114be88 <alt_printf+0x1e0>
                      alt_putchar(*s++);
8114be64:	e0bffa17 	ldw	r2,-24(fp)
8114be68:	10c00044 	addi	r3,r2,1
8114be6c:	e0fffa15 	stw	r3,-24(fp)
8114be70:	10800003 	ldbu	r2,0(r2)
8114be74:	10803fcc 	andi	r2,r2,255
8114be78:	1080201c 	xori	r2,r2,128
8114be7c:	10bfe004 	addi	r2,r2,-128
8114be80:	1009883a 	mov	r4,r2
8114be84:	114bedc0 	call	8114bedc <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
8114be88:	e0bffa17 	ldw	r2,-24(fp)
8114be8c:	10800003 	ldbu	r2,0(r2)
8114be90:	10803fcc 	andi	r2,r2,255
8114be94:	1080201c 	xori	r2,r2,128
8114be98:	10bfe004 	addi	r2,r2,-128
8114be9c:	103ff11e 	bne	r2,zero,8114be64 <__reset+0xfb12be64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
8114bea0:	e0bff717 	ldw	r2,-36(fp)
8114bea4:	10c00044 	addi	r3,r2,1
8114bea8:	e0fff715 	stw	r3,-36(fp)
8114beac:	10800003 	ldbu	r2,0(r2)
8114beb0:	e0bff805 	stb	r2,-32(fp)
8114beb4:	e0bff807 	ldb	r2,-32(fp)
8114beb8:	103f8a1e 	bne	r2,zero,8114bce4 <__reset+0xfb12bce4>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114bebc:	00000106 	br	8114bec4 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
8114bec0:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114bec4:	0001883a 	nop
8114bec8:	e037883a 	mov	sp,fp
8114becc:	dfc00117 	ldw	ra,4(sp)
8114bed0:	df000017 	ldw	fp,0(sp)
8114bed4:	dec00504 	addi	sp,sp,20
8114bed8:	f800283a 	ret

8114bedc <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
8114bedc:	defffd04 	addi	sp,sp,-12
8114bee0:	de00012e 	bgeu	sp,et,8114bee8 <alt_putchar+0xc>
8114bee4:	003b68fa 	trap	3
8114bee8:	dfc00215 	stw	ra,8(sp)
8114beec:	df000115 	stw	fp,4(sp)
8114bef0:	df000104 	addi	fp,sp,4
8114bef4:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
8114bef8:	d0a00517 	ldw	r2,-32748(gp)
8114befc:	10800217 	ldw	r2,8(r2)
8114bf00:	100b883a 	mov	r5,r2
8114bf04:	e13fff17 	ldw	r4,-4(fp)
8114bf08:	1123d640 	call	81123d64 <putc>
#endif
#endif
}
8114bf0c:	e037883a 	mov	sp,fp
8114bf10:	dfc00117 	ldw	ra,4(sp)
8114bf14:	df000017 	ldw	fp,0(sp)
8114bf18:	dec00204 	addi	sp,sp,8
8114bf1c:	f800283a 	ret

8114bf20 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
8114bf20:	deffff04 	addi	sp,sp,-4
8114bf24:	de00012e 	bgeu	sp,et,8114bf2c <altera_nios2_gen2_irq_init+0xc>
8114bf28:	003b68fa 	trap	3
8114bf2c:	df000015 	stw	fp,0(sp)
8114bf30:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
8114bf34:	000170fa 	wrctl	ienable,zero
}
8114bf38:	0001883a 	nop
8114bf3c:	e037883a 	mov	sp,fp
8114bf40:	df000017 	ldw	fp,0(sp)
8114bf44:	dec00104 	addi	sp,sp,4
8114bf48:	f800283a 	ret

8114bf4c <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
8114bf4c:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
8114bf50:	de002436 	bltu	sp,et,8114bfe4 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
8114bf54:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
8114bf58:	d120a217 	ldw	r4,-32120(gp)

      stw ra,  0(sp)
8114bf5c:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
8114bf60:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
8114bf64:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
8114bf68:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
8114bf6c:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
8114bf70:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
8114bf74:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
8114bf78:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
8114bf7c:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
8114bf80:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
8114bf84:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
8114bf88:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114bf8c:	114c1e80 	call	8114c1e8 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
8114bf90:	d1209c17 	ldw	r4,-32144(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
8114bf94:	d1609387 	ldb	r5,-32178(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
8114bf98:	d120a215 	stw	r4,-32120(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
8114bf9c:	d16093c5 	stb	r5,-32177(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
8114bfa0:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
8114bfa4:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
8114bfa8:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
8114bfac:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
8114bfb0:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
8114bfb4:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
8114bfb8:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
8114bfbc:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
8114bfc0:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
8114bfc4:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
8114bfc8:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
8114bfcc:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
8114bfd0:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
8114bfd4:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
8114bfd8:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
8114bfdc:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
8114bfe0:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
8114bfe4:	003da0fa 	break	3

8114bfe8 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
8114bfe8:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
8114bfec:	047fff84 	movi	r17,-2
      and   r18, r18, r17
8114bff0:	9464703a 	and	r18,r18,r17
      wrctl status, r18
8114bff4:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114bff8:	114c1e80 	call	8114c1e8 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
8114bffc:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
8114c000:	d4a09105 	stb	r18,-32188(gp)

      /*
       * start execution of the new task.
       */

      br 9b
8114c004:	003fe206 	br	8114bf90 <__reset+0xfb12bf90>

8114c008 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
8114c008:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
8114c00c:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
8114c010:	10800054 	ori	r2,r2,1
      wrctl status, r2
8114c014:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
8114c018:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
8114c01c:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
8114c020:	dec00204 	addi	sp,sp,8

      callr r2
8114c024:	103ee83a 	callr	r2

      nop
8114c028:	0001883a 	nop

8114c02c <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
8114c02c:	defff704 	addi	sp,sp,-36
8114c030:	de00012e 	bgeu	sp,et,8114c038 <OSTaskStkInit+0xc>
8114c034:	003b68fa 	trap	3
8114c038:	dfc00815 	stw	ra,32(sp)
8114c03c:	df000715 	stw	fp,28(sp)
8114c040:	df000704 	addi	fp,sp,28
8114c044:	e13ffc15 	stw	r4,-16(fp)
8114c048:	e17ffd15 	stw	r5,-12(fp)
8114c04c:	e1bffe15 	stw	r6,-8(fp)
8114c050:	3805883a 	mov	r2,r7
8114c054:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
8114c058:	e0fffe17 	ldw	r3,-8(fp)
8114c05c:	00bfff04 	movi	r2,-4
8114c060:	1884703a 	and	r2,r3,r2
8114c064:	10bef704 	addi	r2,r2,-1060
8114c068:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
8114c06c:	01810904 	movi	r6,1060
8114c070:	000b883a 	mov	r5,zero
8114c074:	e13ff917 	ldw	r4,-28(fp)
8114c078:	1123b2c0 	call	81123b2c <memset>
8114c07c:	e0bff917 	ldw	r2,-28(fp)
8114c080:	10c0bb04 	addi	r3,r2,748
8114c084:	e0bff917 	ldw	r2,-28(fp)
8114c088:	10c00115 	stw	r3,4(r2)
8114c08c:	e0bff917 	ldw	r2,-28(fp)
8114c090:	10c0d504 	addi	r3,r2,852
8114c094:	e0bff917 	ldw	r2,-28(fp)
8114c098:	10c00215 	stw	r3,8(r2)
8114c09c:	e0bff917 	ldw	r2,-28(fp)
8114c0a0:	10c0ef04 	addi	r3,r2,956
8114c0a4:	e0bff917 	ldw	r2,-28(fp)
8114c0a8:	10c00315 	stw	r3,12(r2)
8114c0ac:	e0fff917 	ldw	r3,-28(fp)
8114c0b0:	00a04574 	movhi	r2,33045
8114c0b4:	10897204 	addi	r2,r2,9672
8114c0b8:	18800d15 	stw	r2,52(r3)
8114c0bc:	e0bff917 	ldw	r2,-28(fp)
8114c0c0:	00c00044 	movi	r3,1
8114c0c4:	10c02915 	stw	r3,164(r2)
8114c0c8:	10002a15 	stw	zero,168(r2)
8114c0cc:	e0bff917 	ldw	r2,-28(fp)
8114c0d0:	00ccc384 	movi	r3,13070
8114c0d4:	10c02b0d 	sth	r3,172(r2)
8114c0d8:	e0bff917 	ldw	r2,-28(fp)
8114c0dc:	00eaf344 	movi	r3,-21555
8114c0e0:	10c02b8d 	sth	r3,174(r2)
8114c0e4:	e0bff917 	ldw	r2,-28(fp)
8114c0e8:	00c48d04 	movi	r3,4660
8114c0ec:	10c02c0d 	sth	r3,176(r2)
8114c0f0:	e0bff917 	ldw	r2,-28(fp)
8114c0f4:	00f99b44 	movi	r3,-6547
8114c0f8:	10c02c8d 	sth	r3,178(r2)
8114c0fc:	e0bff917 	ldw	r2,-28(fp)
8114c100:	00f7bb04 	movi	r3,-8468
8114c104:	10c02d0d 	sth	r3,180(r2)
8114c108:	e0bff917 	ldw	r2,-28(fp)
8114c10c:	00c00144 	movi	r3,5
8114c110:	10c02d8d 	sth	r3,182(r2)
8114c114:	e0bff917 	ldw	r2,-28(fp)
8114c118:	00c002c4 	movi	r3,11
8114c11c:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
8114c120:	e0bff917 	ldw	r2,-28(fp)
8114c124:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
8114c128:	e0bffa17 	ldw	r2,-24(fp)
8114c12c:	10bff304 	addi	r2,r2,-52
8114c130:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
8114c134:	e0bffb17 	ldw	r2,-20(fp)
8114c138:	10800c04 	addi	r2,r2,48
8114c13c:	e0fffc17 	ldw	r3,-16(fp)
8114c140:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
8114c144:	e0bffb17 	ldw	r2,-20(fp)
8114c148:	10800b04 	addi	r2,r2,44
8114c14c:	e0fffd17 	ldw	r3,-12(fp)
8114c150:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
8114c154:	e0bffb17 	ldw	r2,-20(fp)
8114c158:	10800a04 	addi	r2,r2,40
8114c15c:	e0fff917 	ldw	r3,-28(fp)
8114c160:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
8114c164:	00a04574 	movhi	r2,33045
8114c168:	10b00204 	addi	r2,r2,-16376
8114c16c:	10c00104 	addi	r3,r2,4
8114c170:	e0bffb17 	ldw	r2,-20(fp)
8114c174:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
8114c178:	e0bffb17 	ldw	r2,-20(fp)
}
8114c17c:	e037883a 	mov	sp,fp
8114c180:	dfc00117 	ldw	ra,4(sp)
8114c184:	df000017 	ldw	fp,0(sp)
8114c188:	dec00204 	addi	sp,sp,8
8114c18c:	f800283a 	ret

8114c190 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
8114c190:	defffe04 	addi	sp,sp,-8
8114c194:	de00012e 	bgeu	sp,et,8114c19c <OSTaskCreateHook+0xc>
8114c198:	003b68fa 	trap	3
8114c19c:	df000115 	stw	fp,4(sp)
8114c1a0:	df000104 	addi	fp,sp,4
8114c1a4:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
8114c1a8:	0001883a 	nop
8114c1ac:	e037883a 	mov	sp,fp
8114c1b0:	df000017 	ldw	fp,0(sp)
8114c1b4:	dec00104 	addi	sp,sp,4
8114c1b8:	f800283a 	ret

8114c1bc <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
8114c1bc:	defffe04 	addi	sp,sp,-8
8114c1c0:	de00012e 	bgeu	sp,et,8114c1c8 <OSTaskDelHook+0xc>
8114c1c4:	003b68fa 	trap	3
8114c1c8:	df000115 	stw	fp,4(sp)
8114c1cc:	df000104 	addi	fp,sp,4
8114c1d0:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
8114c1d4:	0001883a 	nop
8114c1d8:	e037883a 	mov	sp,fp
8114c1dc:	df000017 	ldw	fp,0(sp)
8114c1e0:	dec00104 	addi	sp,sp,4
8114c1e4:	f800283a 	ret

8114c1e8 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
8114c1e8:	deffff04 	addi	sp,sp,-4
8114c1ec:	de00012e 	bgeu	sp,et,8114c1f4 <OSTaskSwHook+0xc>
8114c1f0:	003b68fa 	trap	3
8114c1f4:	df000015 	stw	fp,0(sp)
8114c1f8:	d839883a 	mov	fp,sp
}
8114c1fc:	0001883a 	nop
8114c200:	e037883a 	mov	sp,fp
8114c204:	df000017 	ldw	fp,0(sp)
8114c208:	dec00104 	addi	sp,sp,4
8114c20c:	f800283a 	ret

8114c210 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
8114c210:	deffff04 	addi	sp,sp,-4
8114c214:	de00012e 	bgeu	sp,et,8114c21c <OSTaskStatHook+0xc>
8114c218:	003b68fa 	trap	3
8114c21c:	df000015 	stw	fp,0(sp)
8114c220:	d839883a 	mov	fp,sp
}
8114c224:	0001883a 	nop
8114c228:	e037883a 	mov	sp,fp
8114c22c:	df000017 	ldw	fp,0(sp)
8114c230:	dec00104 	addi	sp,sp,4
8114c234:	f800283a 	ret

8114c238 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
8114c238:	defffe04 	addi	sp,sp,-8
8114c23c:	de00012e 	bgeu	sp,et,8114c244 <OSTimeTickHook+0xc>
8114c240:	003b68fa 	trap	3
8114c244:	dfc00115 	stw	ra,4(sp)
8114c248:	df000015 	stw	fp,0(sp)
8114c24c:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
8114c250:	d0a0b60b 	ldhu	r2,-32040(gp)
8114c254:	10800044 	addi	r2,r2,1
8114c258:	d0a0b60d 	sth	r2,-32040(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
8114c25c:	d0a0b60b 	ldhu	r2,-32040(gp)
8114c260:	10bfffcc 	andi	r2,r2,65535
8114c264:	10807d30 	cmpltui	r2,r2,500
8114c268:	1000021e 	bne	r2,zero,8114c274 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
8114c26c:	d020b60d 	sth	zero,-32040(gp)
        OSTmrSignal();
8114c270:	1142b880 	call	81142b88 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
8114c274:	0001883a 	nop
8114c278:	e037883a 	mov	sp,fp
8114c27c:	dfc00117 	ldw	ra,4(sp)
8114c280:	df000017 	ldw	fp,0(sp)
8114c284:	dec00204 	addi	sp,sp,8
8114c288:	f800283a 	ret

8114c28c <OSInitHookBegin>:

void OSInitHookBegin(void)
{
8114c28c:	deffff04 	addi	sp,sp,-4
8114c290:	de00012e 	bgeu	sp,et,8114c298 <OSInitHookBegin+0xc>
8114c294:	003b68fa 	trap	3
8114c298:	df000015 	stw	fp,0(sp)
8114c29c:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
8114c2a0:	d020b60d 	sth	zero,-32040(gp)
#endif
}
8114c2a4:	0001883a 	nop
8114c2a8:	e037883a 	mov	sp,fp
8114c2ac:	df000017 	ldw	fp,0(sp)
8114c2b0:	dec00104 	addi	sp,sp,4
8114c2b4:	f800283a 	ret

8114c2b8 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
8114c2b8:	deffff04 	addi	sp,sp,-4
8114c2bc:	de00012e 	bgeu	sp,et,8114c2c4 <OSInitHookEnd+0xc>
8114c2c0:	003b68fa 	trap	3
8114c2c4:	df000015 	stw	fp,0(sp)
8114c2c8:	d839883a 	mov	fp,sp
}
8114c2cc:	0001883a 	nop
8114c2d0:	e037883a 	mov	sp,fp
8114c2d4:	df000017 	ldw	fp,0(sp)
8114c2d8:	dec00104 	addi	sp,sp,4
8114c2dc:	f800283a 	ret

8114c2e0 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
8114c2e0:	deffff04 	addi	sp,sp,-4
8114c2e4:	de00012e 	bgeu	sp,et,8114c2ec <OSTaskIdleHook+0xc>
8114c2e8:	003b68fa 	trap	3
8114c2ec:	df000015 	stw	fp,0(sp)
8114c2f0:	d839883a 	mov	fp,sp
}
8114c2f4:	0001883a 	nop
8114c2f8:	e037883a 	mov	sp,fp
8114c2fc:	df000017 	ldw	fp,0(sp)
8114c300:	dec00104 	addi	sp,sp,4
8114c304:	f800283a 	ret

8114c308 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
8114c308:	defffe04 	addi	sp,sp,-8
8114c30c:	de00012e 	bgeu	sp,et,8114c314 <OSTCBInitHook+0xc>
8114c310:	003b68fa 	trap	3
8114c314:	df000115 	stw	fp,4(sp)
8114c318:	df000104 	addi	fp,sp,4
8114c31c:	e13fff15 	stw	r4,-4(fp)
}
8114c320:	0001883a 	nop
8114c324:	e037883a 	mov	sp,fp
8114c328:	df000017 	ldw	fp,0(sp)
8114c32c:	dec00104 	addi	sp,sp,4
8114c330:	f800283a 	ret

8114c334 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
8114c334:	defffe04 	addi	sp,sp,-8
8114c338:	de00012e 	bgeu	sp,et,8114c340 <alt_exception_cause_generated_bad_addr+0xc>
8114c33c:	003b68fa 	trap	3
8114c340:	df000115 	stw	fp,4(sp)
8114c344:	df000104 	addi	fp,sp,4
8114c348:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
8114c34c:	e0bfff17 	ldw	r2,-4(fp)
8114c350:	10bffe84 	addi	r2,r2,-6
8114c354:	10c00428 	cmpgeui	r3,r2,16
8114c358:	18001a1e 	bne	r3,zero,8114c3c4 <alt_exception_cause_generated_bad_addr+0x90>
8114c35c:	100690ba 	slli	r3,r2,2
8114c360:	00a04574 	movhi	r2,33045
8114c364:	10b0dd04 	addi	r2,r2,-15500
8114c368:	1885883a 	add	r2,r3,r2
8114c36c:	10800017 	ldw	r2,0(r2)
8114c370:	1000683a 	jmp	r2
8114c374:	8114c3b4 	orhi	r4,r16,21262
8114c378:	8114c3b4 	orhi	r4,r16,21262
8114c37c:	8114c3c4 	addi	r4,r16,21263
8114c380:	8114c3c4 	addi	r4,r16,21263
8114c384:	8114c3c4 	addi	r4,r16,21263
8114c388:	8114c3b4 	orhi	r4,r16,21262
8114c38c:	8114c3bc 	xorhi	r4,r16,21262
8114c390:	8114c3c4 	addi	r4,r16,21263
8114c394:	8114c3b4 	orhi	r4,r16,21262
8114c398:	8114c3b4 	orhi	r4,r16,21262
8114c39c:	8114c3c4 	addi	r4,r16,21263
8114c3a0:	8114c3b4 	orhi	r4,r16,21262
8114c3a4:	8114c3bc 	xorhi	r4,r16,21262
8114c3a8:	8114c3c4 	addi	r4,r16,21263
8114c3ac:	8114c3c4 	addi	r4,r16,21263
8114c3b0:	8114c3b4 	orhi	r4,r16,21262
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
8114c3b4:	00800044 	movi	r2,1
8114c3b8:	00000306 	br	8114c3c8 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
8114c3bc:	0005883a 	mov	r2,zero
8114c3c0:	00000106 	br	8114c3c8 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
8114c3c4:	0005883a 	mov	r2,zero
  }
}
8114c3c8:	e037883a 	mov	sp,fp
8114c3cc:	df000017 	ldw	fp,0(sp)
8114c3d0:	dec00104 	addi	sp,sp,4
8114c3d4:	f800283a 	ret

8114c3d8 <exit>:
8114c3d8:	defffe04 	addi	sp,sp,-8
8114c3dc:	000b883a 	mov	r5,zero
8114c3e0:	de00012e 	bgeu	sp,et,8114c3e8 <exit+0x10>
8114c3e4:	003b68fa 	trap	3
8114c3e8:	dc000015 	stw	r16,0(sp)
8114c3ec:	dfc00115 	stw	ra,4(sp)
8114c3f0:	2021883a 	mov	r16,r4
8114c3f4:	114c5800 	call	8114c580 <__call_exitprocs>
8114c3f8:	00a04574 	movhi	r2,33045
8114c3fc:	1090f004 	addi	r2,r2,17344
8114c400:	11000017 	ldw	r4,0(r2)
8114c404:	20800f17 	ldw	r2,60(r4)
8114c408:	10000126 	beq	r2,zero,8114c410 <exit+0x38>
8114c40c:	103ee83a 	callr	r2
8114c410:	8009883a 	mov	r4,r16
8114c414:	114c7080 	call	8114c708 <_exit>

8114c418 <memcmp>:
8114c418:	01c000c4 	movi	r7,3
8114c41c:	3980192e 	bgeu	r7,r6,8114c484 <memcmp+0x6c>
8114c420:	2144b03a 	or	r2,r4,r5
8114c424:	11c4703a 	and	r2,r2,r7
8114c428:	10000f26 	beq	r2,zero,8114c468 <memcmp+0x50>
8114c42c:	20800003 	ldbu	r2,0(r4)
8114c430:	28c00003 	ldbu	r3,0(r5)
8114c434:	10c0151e 	bne	r2,r3,8114c48c <memcmp+0x74>
8114c438:	31bfff84 	addi	r6,r6,-2
8114c43c:	01ffffc4 	movi	r7,-1
8114c440:	00000406 	br	8114c454 <memcmp+0x3c>
8114c444:	20800003 	ldbu	r2,0(r4)
8114c448:	28c00003 	ldbu	r3,0(r5)
8114c44c:	31bfffc4 	addi	r6,r6,-1
8114c450:	10c00e1e 	bne	r2,r3,8114c48c <memcmp+0x74>
8114c454:	21000044 	addi	r4,r4,1
8114c458:	29400044 	addi	r5,r5,1
8114c45c:	31fff91e 	bne	r6,r7,8114c444 <__reset+0xfb12c444>
8114c460:	0005883a 	mov	r2,zero
8114c464:	f800283a 	ret
8114c468:	20c00017 	ldw	r3,0(r4)
8114c46c:	28800017 	ldw	r2,0(r5)
8114c470:	18bfee1e 	bne	r3,r2,8114c42c <__reset+0xfb12c42c>
8114c474:	31bfff04 	addi	r6,r6,-4
8114c478:	21000104 	addi	r4,r4,4
8114c47c:	29400104 	addi	r5,r5,4
8114c480:	39bff936 	bltu	r7,r6,8114c468 <__reset+0xfb12c468>
8114c484:	303fe91e 	bne	r6,zero,8114c42c <__reset+0xfb12c42c>
8114c488:	003ff506 	br	8114c460 <__reset+0xfb12c460>
8114c48c:	10c5c83a 	sub	r2,r2,r3
8114c490:	f800283a 	ret

8114c494 <strncpy>:
8114c494:	2906b03a 	or	r3,r5,r4
8114c498:	18c000cc 	andi	r3,r3,3
8114c49c:	2005883a 	mov	r2,r4
8114c4a0:	18002c1e 	bne	r3,zero,8114c554 <strncpy+0xc0>
8114c4a4:	010000c4 	movi	r4,3
8114c4a8:	21802a2e 	bgeu	r4,r6,8114c554 <strncpy+0xc0>
8114c4ac:	033fbff4 	movhi	r12,65279
8114c4b0:	02e02074 	movhi	r11,32897
8114c4b4:	633fbfc4 	addi	r12,r12,-257
8114c4b8:	5ae02004 	addi	r11,r11,-32640
8114c4bc:	100f883a 	mov	r7,r2
8114c4c0:	2a000017 	ldw	r8,0(r5)
8114c4c4:	3815883a 	mov	r10,r7
8114c4c8:	4313883a 	add	r9,r8,r12
8114c4cc:	0206303a 	nor	r3,zero,r8
8114c4d0:	48c6703a 	and	r3,r9,r3
8114c4d4:	1ac6703a 	and	r3,r3,r11
8114c4d8:	1800261e 	bne	r3,zero,8114c574 <strncpy+0xe0>
8114c4dc:	39c00104 	addi	r7,r7,4
8114c4e0:	52000015 	stw	r8,0(r10)
8114c4e4:	31bfff04 	addi	r6,r6,-4
8114c4e8:	3811883a 	mov	r8,r7
8114c4ec:	29400104 	addi	r5,r5,4
8114c4f0:	21bff336 	bltu	r4,r6,8114c4c0 <__reset+0xfb12c4c0>
8114c4f4:	30001e26 	beq	r6,zero,8114c570 <strncpy+0xdc>
8114c4f8:	29c00003 	ldbu	r7,0(r5)
8114c4fc:	31bfffc4 	addi	r6,r6,-1
8114c500:	40c00044 	addi	r3,r8,1
8114c504:	41c00005 	stb	r7,0(r8)
8114c508:	39c03fcc 	andi	r7,r7,255
8114c50c:	39c0201c 	xori	r7,r7,128
8114c510:	39ffe004 	addi	r7,r7,-128
8114c514:	29400044 	addi	r5,r5,1
8114c518:	38001026 	beq	r7,zero,8114c55c <strncpy+0xc8>
8114c51c:	1811883a 	mov	r8,r3
8114c520:	00000906 	br	8114c548 <strncpy+0xb4>
8114c524:	29c00003 	ldbu	r7,0(r5)
8114c528:	31bfffc4 	addi	r6,r6,-1
8114c52c:	29400044 	addi	r5,r5,1
8114c530:	41c00005 	stb	r7,0(r8)
8114c534:	39c03fcc 	andi	r7,r7,255
8114c538:	39c0201c 	xori	r7,r7,128
8114c53c:	39ffe004 	addi	r7,r7,-128
8114c540:	1811883a 	mov	r8,r3
8114c544:	38000526 	beq	r7,zero,8114c55c <strncpy+0xc8>
8114c548:	18c00044 	addi	r3,r3,1
8114c54c:	303ff51e 	bne	r6,zero,8114c524 <__reset+0xfb12c524>
8114c550:	f800283a 	ret
8114c554:	1011883a 	mov	r8,r2
8114c558:	003fe606 	br	8114c4f4 <__reset+0xfb12c4f4>
8114c55c:	30000726 	beq	r6,zero,8114c57c <strncpy+0xe8>
8114c560:	198d883a 	add	r6,r3,r6
8114c564:	18000005 	stb	zero,0(r3)
8114c568:	18c00044 	addi	r3,r3,1
8114c56c:	19bffd1e 	bne	r3,r6,8114c564 <__reset+0xfb12c564>
8114c570:	f800283a 	ret
8114c574:	3811883a 	mov	r8,r7
8114c578:	003fdf06 	br	8114c4f8 <__reset+0xfb12c4f8>
8114c57c:	f800283a 	ret

8114c580 <__call_exitprocs>:
8114c580:	defff504 	addi	sp,sp,-44
8114c584:	de00012e 	bgeu	sp,et,8114c58c <__call_exitprocs+0xc>
8114c588:	003b68fa 	trap	3
8114c58c:	df000915 	stw	fp,36(sp)
8114c590:	dd400615 	stw	r21,24(sp)
8114c594:	dc800315 	stw	r18,12(sp)
8114c598:	dfc00a15 	stw	ra,40(sp)
8114c59c:	ddc00815 	stw	r23,32(sp)
8114c5a0:	dd800715 	stw	r22,28(sp)
8114c5a4:	dd000515 	stw	r20,20(sp)
8114c5a8:	dcc00415 	stw	r19,16(sp)
8114c5ac:	dc400215 	stw	r17,8(sp)
8114c5b0:	dc000115 	stw	r16,4(sp)
8114c5b4:	d9000015 	stw	r4,0(sp)
8114c5b8:	2839883a 	mov	fp,r5
8114c5bc:	04800044 	movi	r18,1
8114c5c0:	057fffc4 	movi	r21,-1
8114c5c4:	00a04574 	movhi	r2,33045
8114c5c8:	1090f004 	addi	r2,r2,17344
8114c5cc:	12000017 	ldw	r8,0(r2)
8114c5d0:	45005217 	ldw	r20,328(r8)
8114c5d4:	44c05204 	addi	r19,r8,328
8114c5d8:	a0001c26 	beq	r20,zero,8114c64c <__call_exitprocs+0xcc>
8114c5dc:	a0800117 	ldw	r2,4(r20)
8114c5e0:	15ffffc4 	addi	r23,r2,-1
8114c5e4:	b8000d16 	blt	r23,zero,8114c61c <__call_exitprocs+0x9c>
8114c5e8:	14000044 	addi	r16,r2,1
8114c5ec:	8421883a 	add	r16,r16,r16
8114c5f0:	8421883a 	add	r16,r16,r16
8114c5f4:	84402004 	addi	r17,r16,128
8114c5f8:	a463883a 	add	r17,r20,r17
8114c5fc:	a421883a 	add	r16,r20,r16
8114c600:	e0001e26 	beq	fp,zero,8114c67c <__call_exitprocs+0xfc>
8114c604:	80804017 	ldw	r2,256(r16)
8114c608:	e0801c26 	beq	fp,r2,8114c67c <__call_exitprocs+0xfc>
8114c60c:	bdffffc4 	addi	r23,r23,-1
8114c610:	843fff04 	addi	r16,r16,-4
8114c614:	8c7fff04 	addi	r17,r17,-4
8114c618:	bd7ff91e 	bne	r23,r21,8114c600 <__reset+0xfb12c600>
8114c61c:	00800034 	movhi	r2,0
8114c620:	10800004 	addi	r2,r2,0
8114c624:	10000926 	beq	r2,zero,8114c64c <__call_exitprocs+0xcc>
8114c628:	a0800117 	ldw	r2,4(r20)
8114c62c:	1000301e 	bne	r2,zero,8114c6f0 <__call_exitprocs+0x170>
8114c630:	a0800017 	ldw	r2,0(r20)
8114c634:	10003226 	beq	r2,zero,8114c700 <__call_exitprocs+0x180>
8114c638:	a009883a 	mov	r4,r20
8114c63c:	98800015 	stw	r2,0(r19)
8114c640:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8114c644:	9d000017 	ldw	r20,0(r19)
8114c648:	a03fe41e 	bne	r20,zero,8114c5dc <__reset+0xfb12c5dc>
8114c64c:	dfc00a17 	ldw	ra,40(sp)
8114c650:	df000917 	ldw	fp,36(sp)
8114c654:	ddc00817 	ldw	r23,32(sp)
8114c658:	dd800717 	ldw	r22,28(sp)
8114c65c:	dd400617 	ldw	r21,24(sp)
8114c660:	dd000517 	ldw	r20,20(sp)
8114c664:	dcc00417 	ldw	r19,16(sp)
8114c668:	dc800317 	ldw	r18,12(sp)
8114c66c:	dc400217 	ldw	r17,8(sp)
8114c670:	dc000117 	ldw	r16,4(sp)
8114c674:	dec00b04 	addi	sp,sp,44
8114c678:	f800283a 	ret
8114c67c:	a0800117 	ldw	r2,4(r20)
8114c680:	80c00017 	ldw	r3,0(r16)
8114c684:	10bfffc4 	addi	r2,r2,-1
8114c688:	15c01426 	beq	r2,r23,8114c6dc <__call_exitprocs+0x15c>
8114c68c:	80000015 	stw	zero,0(r16)
8114c690:	183fde26 	beq	r3,zero,8114c60c <__reset+0xfb12c60c>
8114c694:	95c8983a 	sll	r4,r18,r23
8114c698:	a0806217 	ldw	r2,392(r20)
8114c69c:	a5800117 	ldw	r22,4(r20)
8114c6a0:	2084703a 	and	r2,r4,r2
8114c6a4:	10000b26 	beq	r2,zero,8114c6d4 <__call_exitprocs+0x154>
8114c6a8:	a0806317 	ldw	r2,396(r20)
8114c6ac:	2088703a 	and	r4,r4,r2
8114c6b0:	20000c1e 	bne	r4,zero,8114c6e4 <__call_exitprocs+0x164>
8114c6b4:	89400017 	ldw	r5,0(r17)
8114c6b8:	d9000017 	ldw	r4,0(sp)
8114c6bc:	183ee83a 	callr	r3
8114c6c0:	a0800117 	ldw	r2,4(r20)
8114c6c4:	15bfbf1e 	bne	r2,r22,8114c5c4 <__reset+0xfb12c5c4>
8114c6c8:	98800017 	ldw	r2,0(r19)
8114c6cc:	153fcf26 	beq	r2,r20,8114c60c <__reset+0xfb12c60c>
8114c6d0:	003fbc06 	br	8114c5c4 <__reset+0xfb12c5c4>
8114c6d4:	183ee83a 	callr	r3
8114c6d8:	003ff906 	br	8114c6c0 <__reset+0xfb12c6c0>
8114c6dc:	a5c00115 	stw	r23,4(r20)
8114c6e0:	003feb06 	br	8114c690 <__reset+0xfb12c690>
8114c6e4:	89000017 	ldw	r4,0(r17)
8114c6e8:	183ee83a 	callr	r3
8114c6ec:	003ff406 	br	8114c6c0 <__reset+0xfb12c6c0>
8114c6f0:	a0800017 	ldw	r2,0(r20)
8114c6f4:	a027883a 	mov	r19,r20
8114c6f8:	1029883a 	mov	r20,r2
8114c6fc:	003fb606 	br	8114c5d8 <__reset+0xfb12c5d8>
8114c700:	0005883a 	mov	r2,zero
8114c704:	003ffb06 	br	8114c6f4 <__reset+0xfb12c6f4>

8114c708 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
8114c708:	defffc04 	addi	sp,sp,-16
8114c70c:	de00012e 	bgeu	sp,et,8114c714 <_exit+0xc>
8114c710:	003b68fa 	trap	3
8114c714:	dfc00315 	stw	ra,12(sp)
8114c718:	df000215 	stw	fp,8(sp)
8114c71c:	df000204 	addi	fp,sp,8
8114c720:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
8114c724:	d0a01217 	ldw	r2,-32696(gp)
8114c728:	10800058 	cmpnei	r2,r2,1
8114c72c:	1000031e 	bne	r2,zero,8114c73c <_exit+0x34>
8114c730:	01204574 	movhi	r4,33045
8114c734:	21097304 	addi	r4,r4,9676
8114c738:	11382180 	call	81138218 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
8114c73c:	d0a01217 	ldw	r2,-32696(gp)
8114c740:	10800058 	cmpnei	r2,r2,1
8114c744:	1000041e 	bne	r2,zero,8114c758 <_exit+0x50>
8114c748:	e17fff17 	ldw	r5,-4(fp)
8114c74c:	01204574 	movhi	r4,33045
8114c750:	21097e04 	addi	r4,r4,9720
8114c754:	11382180 	call	81138218 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
8114c758:	d0a01217 	ldw	r2,-32696(gp)
8114c75c:	10800058 	cmpnei	r2,r2,1
8114c760:	1000031e 	bne	r2,zero,8114c770 <_exit+0x68>
8114c764:	01204574 	movhi	r4,33045
8114c768:	21098904 	addi	r4,r4,9764
8114c76c:	11382180 	call	81138218 <alt_log_printf_proc>
  ALT_OS_STOP();
8114c770:	d0209105 	stb	zero,-32188(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
8114c774:	d0a01217 	ldw	r2,-32696(gp)
8114c778:	10800058 	cmpnei	r2,r2,1
8114c77c:	1000031e 	bne	r2,zero,8114c78c <_exit+0x84>
8114c780:	01204574 	movhi	r4,33045
8114c784:	21099304 	addi	r4,r4,9804
8114c788:	11382180 	call	81138218 <alt_log_printf_proc>
8114c78c:	e0bfff17 	ldw	r2,-4(fp)
8114c790:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
8114c794:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
8114c798:	10000226 	beq	r2,zero,8114c7a4 <_exit+0x9c>
    ALT_SIM_FAIL();
8114c79c:	002af070 	cmpltui	zero,zero,43969
8114c7a0:	00000106 	br	8114c7a8 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
8114c7a4:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
8114c7a8:	d0a01217 	ldw	r2,-32696(gp)
8114c7ac:	10800058 	cmpnei	r2,r2,1
8114c7b0:	1000031e 	bne	r2,zero,8114c7c0 <_exit+0xb8>
8114c7b4:	01204574 	movhi	r4,33045
8114c7b8:	21099d04 	addi	r4,r4,9844
8114c7bc:	11382180 	call	81138218 <alt_log_printf_proc>
  while (1);
8114c7c0:	003fff06 	br	8114c7c0 <__reset+0xfb12c7c0>
